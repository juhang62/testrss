<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>ASP.NET 开源导入导出库Magicodes.IE 完成Csv导入导出 - HueiFeng</title>
<link>http://www.cnblogs.com/yyfh/p/12886258.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yyfh/p/12886258.html</guid>
<description>&lt;h2 id=&quot;说明&quot;&gt;说明&lt;/h2&gt;
&lt;p&gt;本章主要说明如何使用Magicodes.IE.Csv进行Csv导入导出.&lt;/p&gt;
&lt;h2 id=&quot;主要步骤&quot;&gt;主要步骤&lt;/h2&gt;
&lt;h3 id=&quot;1安装包magicodesiecsv&quot;&gt;1.安装包Magicodes.IE.Csv&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-powershell&quot;&gt;Install-Package Magicodes.IE.Csv
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;2使用magicodesiecsv导出csv&quot;&gt;2.使用Magicodes.IE.Csv导出Csv&lt;/h3&gt;
&lt;p&gt;通过如下代码片段我们将导出的内容通过相应的特性做出相应的处理.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ExporterHeaderAttribute&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;DisplayName： 显示名称&lt;/li&gt;
&lt;li&gt;Format： 格式化&lt;/li&gt;
&lt;li&gt;IsIgnore： 是否忽略&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;    public class ExportTestDataWithAttrs
    {
        [ExporterHeader(DisplayName = &quot;加粗文本&quot;, IsBold = true)]
        public string Text { get; set; }
        [ExporterHeader(DisplayName = &quot;普通文本&quot;)] public string Text2 { get; set; }
        [ExporterHeader(DisplayName = &quot;忽略&quot;, IsIgnore = true)]
        public string Text3 { get; set; }
        [ExporterHeader(DisplayName = &quot;数值&quot;, Format = &quot;#,##0&quot;)]
        public decimal Number { get; set; }
        [ExporterHeader(DisplayName = &quot;名称&quot;, IsAutoFit = true)]
        public string Name { get; set; }

        /// &amp;lt;summary&amp;gt;
        /// 时间测试
        /// &amp;lt;/summary&amp;gt;
        [ExporterHeader(DisplayName = &quot;日期1&quot;, Format = &quot;yyyy-MM-dd&quot;)]
        public DateTime Time1 { get; set; }

        /// &amp;lt;summary&amp;gt;
        /// 时间测试
        /// &amp;lt;/summary&amp;gt;
        [ExporterHeader(DisplayName = &quot;日期2&quot;, Format = &quot;yyyy-MM-dd HH:mm:ss&quot;)]
        public DateTime? Time2 { get; set; }

        public DateTime Time3 { get; set; }

        public DateTime Time4 { get; set; }

        /// &amp;lt;summary&amp;gt;
        /// 长数值测试
        /// &amp;lt;/summary&amp;gt;
        [ExporterHeader(DisplayName = &quot;长数值&quot;, Format = &quot;#,##0&quot;)]
        public long LongNo { get; set; }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过DTO导出&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;        public async Task ExportHeaderAsByteArray_Test()
        {
            IExporter exporter = new CsvExporter();

            var filePath = GetTestFilePath($&quot;{nameof(ExportHeaderAsByteArray_Test)}.csv&quot;);

            DeleteFile(filePath);

            var result = await exporter.ExportHeaderAsByteArray(GenFu.GenFu.New&amp;lt;ExportTestDataWithAttrs&amp;gt;());
        }

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;3使用magicodesiecsv导入csv&quot;&gt;3.使用Magicodes.IE.Csv导入Csv&lt;/h3&gt;
&lt;p&gt;对于csv导入我们可以通过,&lt;strong&gt;ImporterHeader&lt;/strong&gt; Name属性去对应我们的Dto属性.并且可以通过&lt;strong&gt;ValueMapping&lt;/strong&gt;对枚举类型进行相关的映射，并向我们返回相对应的值&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;        public async Task StudentInfoImporter_Test()
        {
            var filePath = Path.Combine(Directory.GetCurrentDirectory(), &quot;TestFiles&quot;, &quot;Import&quot;, &quot;学生基础数据导入.csv&quot;);
            var import = await Importer.Import&amp;lt;ImportStudentDto&amp;gt;(filePath);
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt; /// &amp;lt;summary&amp;gt;
    /// 导入学生数据Dto
    /// &amp;lt;/summary&amp;gt;
    public class ImportStudentDto
    {
        /// &amp;lt;summary&amp;gt;
        ///     序号
        /// &amp;lt;/summary&amp;gt;
        [ImporterHeader(Name = &quot;序号&quot;)]
        public long SerialNumber { get; set; }

        /// &amp;lt;summary&amp;gt;
        ///     学籍号
        /// &amp;lt;/summary&amp;gt;
        [ImporterHeader(Name = &quot;学籍号&quot;)]
        public string StudentCode { get; set; }
        /// &amp;lt;summary&amp;gt;
        ///     姓名
        /// &amp;lt;/summary&amp;gt;
        [ImporterHeader(Name = &quot;姓名&quot;)]
        public string Name { get; set; }

        /// &amp;lt;summary&amp;gt;
        ///     身份证号码
        /// &amp;lt;/summary&amp;gt;
        [ImporterHeader(Name = &quot;身份证号&quot;)]
        public string IdCard { get; set; }

        /// &amp;lt;summary&amp;gt;
        ///     性别
        /// &amp;lt;/summary&amp;gt;
        [ImporterHeader(Name = &quot;性别&quot;)]
        [ValueMapping(&quot;男&quot;, 0)]
        [ValueMapping(&quot;女&quot;, 1)]
        public Genders Gender { get; set; }

        /// &amp;lt;summary&amp;gt;
        ///     家庭地址
        /// &amp;lt;/summary&amp;gt;
        [ImporterHeader(Name = &quot;家庭住址&quot;)]
        public string Address { get; set; }

        /// &amp;lt;summary&amp;gt;
        ///     家长姓名
        /// &amp;lt;/summary&amp;gt;
        [ImporterHeader(Name = &quot;家长姓名&quot;)]
        public string Guardian { get; set; }

        /// &amp;lt;summary&amp;gt;
        ///     家长联系电话
        /// &amp;lt;/summary&amp;gt;
        [ImporterHeader(Name = &quot;家长联系电话&quot;)]
        public string GuardianPhone { get; set; }

        /// &amp;lt;summary&amp;gt;
        ///     学号
        /// &amp;lt;/summary&amp;gt;
        [ImporterHeader(Name = &quot;学号&quot;)]
        public string StudentNub { get; set; }

        /// &amp;lt;summary&amp;gt;
        ///     宿舍号
        /// &amp;lt;/summary&amp;gt;
        [ImporterHeader(Name = &quot;宿舍号&quot;)]
        public string DormitoryNo { get; set; }

        /// &amp;lt;summary&amp;gt;
        ///     QQ
        /// &amp;lt;/summary&amp;gt;
        [ImporterHeader(Name = &quot;QQ号&quot;)]
        public string QQ { get; set; }

        /// &amp;lt;summary&amp;gt;
        ///     民族
        /// &amp;lt;/summary&amp;gt;
        [ImporterHeader(Name = &quot;民族&quot;)]
        public string Nation { get; set; }

        /// &amp;lt;summary&amp;gt;
        ///     户口性质
        /// &amp;lt;/summary&amp;gt;
        [ImporterHeader(Name = &quot;户口性质&quot;)]
        public string HouseholdType { get; set; }

        /// &amp;lt;summary&amp;gt;
        ///     联系电话
        /// &amp;lt;/summary&amp;gt;
        [ImporterHeader(Name = &quot;学生联系电话&quot;)]
        public string Phone { get; set; }

        /// &amp;lt;summary&amp;gt;
        ///     状态
        ///     测试可为空的枚举类型
        /// &amp;lt;/summary&amp;gt;
        [ImporterHeader(Name = &quot;状态&quot;)] 
        public StudentStatus? Status { get; set; }

        /// &amp;lt;summary&amp;gt;
        ///     备注
        /// &amp;lt;/summary&amp;gt;
        [ImporterHeader(Name = &quot;备注&quot;)]
        public string Remark { get; set; }

        /// &amp;lt;summary&amp;gt;
        ///     是否住校(宿舍)
        /// &amp;lt;/summary&amp;gt;
        [ImporterHeader(IsIgnore = true)]
        public bool? IsBoarding { get; set; }

        /// &amp;lt;summary&amp;gt;
        ///     所属班级id
        /// &amp;lt;/summary&amp;gt;
        [ImporterHeader(IsIgnore = true)]
        public Guid ClassId { get; set; }

        /// &amp;lt;summary&amp;gt;
        ///     学校Id
        /// &amp;lt;/summary&amp;gt;
        [ImporterHeader(IsIgnore = true)]
        public Guid? SchoolId { get; set; }

        /// &amp;lt;summary&amp;gt;
        ///     校区Id
        /// &amp;lt;/summary&amp;gt;
        [ImporterHeader(IsIgnore = true)]
        public Guid? CampusId { get; set; }

        /// &amp;lt;summary&amp;gt;
        ///     专业Id
        /// &amp;lt;/summary&amp;gt;
        [ImporterHeader(IsIgnore = true)]
        public Guid? MajorsId { get; set; }

        /// &amp;lt;summary&amp;gt;
        ///     年级Id
        /// &amp;lt;/summary&amp;gt;
        [ImporterHeader(IsIgnore = true)]
        public Guid? GradeId { get; set; }
    }

&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/dotnetcore/Magicodes.IE&quot;&gt;https://github.com/dotnetcore/Magicodes.IE&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 14 May 2020 00:37:00 +0000</pubDate>
<dc:creator>HueiFeng</dc:creator>
<og:description>Magicodes.IE Csv导入导出 说明 本章主要说明如何使用Magicodes.IE.Csv进行Csv导入导出. 主要步骤 1.安装包Magicodes.IE.Csv 2.使用Magicode</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yyfh/p/12886258.html</dc:identifier>
</item>
<item>
<title>C#枚举高级战术 - Liam Wang</title>
<link>http://www.cnblogs.com/willick/p/csharp-enum-superior-tactics.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/willick/p/csharp-enum-superior-tactics.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/191097/202005/191097-20200514001002688-1155327685.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;文章开头先给大家出一道面试题：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;在设计某小型项目的数据库（假设用的是 MySQL）时，如果给用户表（User）添加一个字段（Roles）用来存储用户的角色，你会给这个字段设置什么类型？提示：要考虑到角色在后端开发时需要用枚举表示，且一个用户可能会拥有多个角色。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;映入你脑海的第一个答案可能是：varchar 类型，用分隔符的方式来存储多个角色，比如用 &lt;code&gt;1|2|3&lt;/code&gt; 或 &lt;code&gt;1,2,3&lt;/code&gt; 来表示用户拥有多个角色。当然如果角色数量可能超过个位数，考虑到数据库的查询方便（比如用 INSTR 或 POSITION 来判断用户是否包含某个角色），角色的值至少要从数字 10 开始。方案是可行的，可是不是太简单了，有没有更好的方案？更好的回答应是整型（int、bigint 等），优点是写 SQL 查询条件更方便，性能、空间上都优于 varchar。但整型毕竟只是一个数字，怎么表示多个角色呢？此时想到了二进制位操作的你，心中应该早有了答案。且保留你心中的答案，接着看完本文，或许你会有意外的收获，因为实际应用中可能还会遇到一连串的问题。为了更好的说明后面的问题，我们先来回顾一下枚举的基础知识。&lt;/p&gt;
&lt;h2&gt;枚举基础&lt;/h2&gt;
&lt;p&gt;枚举类型的作用是限制其变量只能从有限的选项中取值，这些选项（枚举类型的成员）各自对应于一个数字，数字默认从 0 开始，并以此递增。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt; Days&lt;br/&gt;{&lt;br/&gt;Sunday, Monday, Tuesday, &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中 Sunday 的值是 0，Monday 是 1，以此类推。为了一眼能看出每个成员代表的值，一般推荐显示地将成员值写出来，不要省略：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt; Days&lt;br/&gt;{&lt;br/&gt;Sunday = &lt;span&gt;0&lt;/span&gt;, Monday = &lt;span&gt;1&lt;/span&gt;, Tuesday = &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;C# 枚举成员的类型默认是 int 类型，通过继承可以声明枚举成员为其它类型，比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt; Days : &lt;span&gt;byte&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;Monday = &lt;span&gt;1&lt;/span&gt;,&lt;br/&gt;Tuesday = &lt;span&gt;2&lt;/span&gt;,&lt;br/&gt;Wednesday = &lt;span&gt;3&lt;/span&gt;,&lt;br/&gt;Thursday = &lt;span&gt;4&lt;/span&gt;,&lt;br/&gt;Friday = &lt;span&gt;5&lt;/span&gt;,&lt;br/&gt;Saturday = &lt;span&gt;6&lt;/span&gt;,&lt;br/&gt;Sunday = &lt;span&gt;7&lt;/span&gt;&lt;br/&gt;}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;枚举类型一定是继承自 byte、sbyte、short、ushort、int、uint、long 和 ulong 中的一种，不能是其它类型。下面是几个枚举的常见用法（以上面的 Days 枚举为例）：&lt;/p&gt;
&lt;pre readability=&quot;7.5&quot;&gt;
&lt;code readability=&quot;9&quot;&gt;&lt;span&gt;// 枚举转字符串&lt;/span&gt;&lt;br/&gt;&lt;span&gt;string&lt;/span&gt; foo = Days.Saturday.ToString(); &lt;span&gt;// &quot;Saturday&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;string&lt;/span&gt; foo = Enum.GetName(&lt;span&gt;typeof&lt;/span&gt;(DayOfWeek), &lt;span&gt;6&lt;/span&gt;); &lt;span&gt;// &quot;Saturday&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 字符串转枚举&lt;/span&gt;&lt;br/&gt;Enum.TryParse(&lt;span&gt;&quot;Tuesday&quot;&lt;/span&gt;, &lt;span&gt;out&lt;/span&gt; Days bar); &lt;span&gt;// true, bar = Days.Tuesday&lt;/span&gt;&lt;br/&gt;(Days)Enum.Parse(&lt;span&gt;typeof&lt;/span&gt;(Days), &lt;span&gt;&quot;Tuesday&quot;&lt;/span&gt;); &lt;span&gt;// Days.Tuesday&lt;/span&gt;&lt;p&gt;&lt;span&gt;// 枚举转数字&lt;/span&gt;&lt;br/&gt;&lt;span&gt;byte&lt;/span&gt; foo = (&lt;span&gt;byte&lt;/span&gt;)Days.Monday; &lt;span&gt;// 1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 数字转枚举&lt;/span&gt;&lt;br/&gt;Days foo = (Days)&lt;span&gt;2&lt;/span&gt;; &lt;span&gt;// Days.Tuesday&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;// 获取枚举所属的数字类型&lt;/span&gt;&lt;br/&gt;Type foo = Enum.GetUnderlyingType(&lt;span&gt;typeof&lt;/span&gt;(Days))); &lt;span&gt;// System.Byte&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;// 获取所有的枚举成员&lt;/span&gt;&lt;br/&gt;Array foo = Enum.GetValues(&lt;span&gt;typeof&lt;/span&gt;(MyEnum);&lt;br/&gt;&lt;span&gt;// 获取所有枚举成员的字段名&lt;/span&gt;&lt;br/&gt;&lt;span&gt;string&lt;/span&gt;[] foo = Enum.GetNames(&lt;span&gt;typeof&lt;/span&gt;(Days));&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另外，值得注意的是，枚举可能会得到非预期的值（值没有对应的成员）。比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Days d = (Days)&lt;span&gt;21&lt;/span&gt;; &lt;span&gt;// 不会报错&lt;/span&gt;&lt;br/&gt;Enum.IsDefined(&lt;span&gt;typeof&lt;/span&gt;(Days), d); &lt;span&gt;// false&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;即使枚举没有值为 0 的成员，它的默认值永远都是 0。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span&gt;var&lt;/span&gt; z = &lt;span&gt;default&lt;/span&gt;(Days); &lt;span&gt;// 0&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;枚举可以通过 Description、Display 等特性来为成员添加有用的辅助信息，比如：&lt;/p&gt;
&lt;pre readability=&quot;7&quot;&gt;
&lt;code readability=&quot;8&quot;&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;ApiStatus&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;[&lt;span&gt;Description(&lt;span&gt;&quot;成功&quot;&lt;/span&gt;)&lt;/span&gt;]&lt;br/&gt;OK = &lt;span&gt;0&lt;/span&gt;,&lt;br/&gt;[&lt;span&gt;Description(&lt;span&gt;&quot;资源未找到&quot;&lt;/span&gt;)&lt;/span&gt;]&lt;br/&gt;NotFound = &lt;span&gt;2&lt;/span&gt;,&lt;br/&gt;[&lt;span&gt;Description(&lt;span&gt;&quot;拒绝访问&quot;&lt;/span&gt;)&lt;/span&gt;]&lt;br/&gt;AccessDenied = &lt;span&gt;3&lt;/span&gt;&lt;br/&gt;}&lt;p&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;EnumExtensions&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; &lt;span&gt;GetDescription&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt; Enum val)&lt;br/&gt;{&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; field = val.GetType().GetField(val.ToString());&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; customAttribute = Attribute.GetCustomAttribute(field, &lt;span&gt;typeof&lt;/span&gt;(DescriptionAttribute));&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (customAttribute == &lt;span&gt;null&lt;/span&gt;) { &lt;span&gt;return&lt;/span&gt; val.ToString(); }&lt;br/&gt;&lt;span&gt;else&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt; ((DescriptionAttribute)customAttribute).Description; }&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;Main&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt;[] args)&lt;br/&gt;{&lt;br/&gt;Console.WriteLine(ApiStatus.Ok.GetDescription()); &lt;span&gt;// &quot;成功&quot;&lt;/span&gt;&lt;br/&gt;}&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面这些我认为已经包含了大部分我们日常用到的枚举知识了。下面我们继续回到文章开头说的用户角色存储问题。&lt;/p&gt;
&lt;h2&gt;用户角色存储问题&lt;/h2&gt;
&lt;p&gt;我们先定义一个枚举类型来表示两种用户角色：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt; Roles&lt;br/&gt;{&lt;br/&gt;Admin = &lt;span&gt;1&lt;/span&gt;,&lt;br/&gt;Member = &lt;span&gt;2&lt;/span&gt;&lt;br/&gt;}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样，如果某个用户同时拥有 Admin 和 Member 两种角色，那么 User 表的 Roles 字段就应该存 3。那问题来了，此时若查询所有拥有 Admin 角色的用户的 SQL 该怎么写呢？对于有基础的程序员来说，这个问题很简单，只要用位操作符逻辑与（‘&amp;amp;’）来查询即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span&gt;SELECT&lt;/span&gt; * &lt;span&gt;FROM&lt;/span&gt; &lt;span&gt;`User`&lt;/span&gt; &lt;span&gt;WHERE&lt;/span&gt; &lt;span&gt;`Roles`&lt;/span&gt; &amp;amp; &lt;span&gt;1&lt;/span&gt; = &lt;span&gt;1&lt;/span&gt;;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同理，查询同时拥有这两种角色的用户，SQL 语句应该这么写：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span&gt;SELECT&lt;/span&gt; * &lt;span&gt;FROM&lt;/span&gt; &lt;span&gt;`User`&lt;/span&gt; &lt;span&gt;WHERE&lt;/span&gt; &lt;span&gt;`Roles`&lt;/span&gt; &amp;amp; &lt;span&gt;3&lt;/span&gt; = &lt;span&gt;3&lt;/span&gt;;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对这条 SQL 语句用 C# 来实现查询是这样的（为了简单，这里使用了 Dapper）：&lt;/p&gt;
&lt;pre readability=&quot;5&quot;&gt;
&lt;code readability=&quot;4&quot;&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;User&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Id { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; }&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; Roles Roles { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; }&lt;br/&gt;}&lt;p&gt;connection.Query&amp;lt;User&amp;gt;(&lt;br/&gt;&lt;span&gt;&quot;SELECT * FROM `User` WHERE `Roles` &amp;amp; @roles = @roles;&quot;&lt;/span&gt;,&lt;br/&gt;&lt;span&gt;new&lt;/span&gt; { roles = Roles.Admin | Roles.Member });&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对应的，在 C# 中要判断用户是否拥有某个角色，可以这么判断：&lt;/p&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;code readability=&quot;2&quot;&gt;&lt;span&gt;// 方式一&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (user.Roles &amp;amp; Roles.Admin == Roles.Admin)&lt;br/&gt;{&lt;br/&gt;&lt;span&gt;// 做管理员可以做的事情&lt;/span&gt;&lt;br/&gt;}&lt;p&gt;&lt;span&gt;// 方式二&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (user.Roles.HasFlag(Roles.Admin))&lt;br/&gt;{&lt;br/&gt;&lt;span&gt;// 做管理员可以做的事情&lt;/span&gt;&lt;br/&gt;}&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同理，在 C# 中你可以对枚举进行任意位逻辑运算，比如要把角色从某个枚举变量中移除：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span&gt;var&lt;/span&gt; foo = Roles.Admin | Roles.Member;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; bar = foo &amp;amp; ~foo;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这就解决了文章前面提到的用整型来存储多角色的问题，不论数据库还是 C# 语言，操作上都是可行的，而且也很方便灵活。&lt;/p&gt;
&lt;h2&gt;枚举的 Flags 特性&lt;/h2&gt;
&lt;p&gt;下面我们提供一个通过角色来查询用户的方法，并演示如何调用，如下：&lt;/p&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;code readability=&quot;2&quot;&gt;&lt;span&gt;public&lt;/span&gt; IEnumerable&amp;lt;User&amp;gt; &lt;span&gt;GetUsersInRoles&lt;/span&gt;(Roles roles)&lt;br/&gt;{&lt;br/&gt;_logger.LogDebug(roles.ToString());&lt;br/&gt;_connection.Query&amp;lt;User&amp;gt;(&lt;br/&gt;&lt;span&gt;&quot;SELECT * FROM `User` WHERE `Roles` &amp;amp; @roles = @roles;&quot;&lt;/span&gt;,&lt;br/&gt;&lt;span&gt;new&lt;/span&gt; { roles });&lt;br/&gt;}&lt;p&gt;&lt;span&gt;// 调用&lt;/span&gt;&lt;br/&gt;_repository.GetUsersInRoles(Roles.Admin | Roles.Member);&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Roles.Admin | Roles.Member&lt;/code&gt; 的值是 3，由于 Roles 枚举类型中并没有定义一个值为 3 的字段，所以在方法内 roles 参数显示的是 3。3 这个信息对于我们调试或打印日志很不友好。在方法内，我们并不知道这个 3 代表的是什么。为了解决这个问题，C# 枚举有个很有用的特性：FlagsAtrribute。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[&lt;span&gt;Flags&lt;/span&gt;]&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt; Roles&lt;br/&gt;{&lt;br/&gt;Admin = &lt;span&gt;1&lt;/span&gt;,&lt;br/&gt;Member = &lt;span&gt;2&lt;/span&gt;&lt;br/&gt;}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;加上这个 Flags 特性后，我们再来调试 &lt;code&gt;GetUsersInRoles(Roles roles)&lt;/code&gt; 方法时，roles 参数的值就会显示为 &lt;code&gt;Admin|Member&lt;/code&gt; 了。简单来说，加不加 Flags 的区别是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span&gt;var&lt;/span&gt; roles = Roles.Admin | Roles.Member;&lt;br/&gt;Console.WriteLing(roles.ToString()); &lt;span&gt;// &quot;3&quot;，没有 Flags 特性&lt;/span&gt;&lt;br/&gt;Console.WriteLing(roles.ToString()); &lt;span&gt;// &quot;Admin, Member&quot;，有 Flags 特性&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;给枚举加上 Flags 特性，我觉得应当视为 C# 编程的一种最佳实践，在定义枚举时尽量加上 Flags 特性。&lt;/p&gt;
&lt;h2&gt;解决枚举值冲突：2 的幂&lt;/h2&gt;
&lt;p&gt;到这，枚举类型 Roles 一切看上去没什么问题，但如果现在要增加一个角色：Mananger，会发生什么情况？按照数字值递增的规则，Manager 的值应当设为 3。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[&lt;span&gt;Flags&lt;/span&gt;]&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt; Roles&lt;br/&gt;{&lt;br/&gt;Admin = &lt;span&gt;1&lt;/span&gt;,&lt;br/&gt;Member = &lt;span&gt;2&lt;/span&gt;,&lt;br/&gt;Manager = &lt;span&gt;3&lt;/span&gt;&lt;br/&gt;}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;能不能把 Manager 的值设为 3？显然不能，因为 Admin 和 Member 进行位的或逻辑运算（即：Admin | Member） 的值也是 3，表示同时拥有这两种角色，这和 Manager 冲突了。那怎样设值才能避免冲突呢？既然是二进制逻辑运算“或”会和成员值产生冲突，那就利用逻辑运算或的规律来解决。我们知道“或”运算的逻辑是两边只要出现一个 1 结果就会 1，比如 1|1、1|0 结果都是 1，只有 0|0 的情况结果才是 0。那么我们就要避免任意两个值在相同的位置上出现 1。根据二进制满 2 进 1 的特点，只要保证枚举的各项值都是 2 的幂即可。比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span&gt;1&lt;/span&gt;:  &lt;span&gt;00000001&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;:  &lt;span&gt;00000010&lt;/span&gt;&lt;br/&gt;&lt;span&gt;4&lt;/span&gt;:  &lt;span&gt;00000100&lt;/span&gt;&lt;br/&gt;&lt;span&gt;8&lt;/span&gt;:  &lt;span&gt;00001000&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再往后增加的话就是 16、32、64...，其中各值不论怎么相加都不会和成员的任一值冲突。这样问题就解决了，所以我们要这样定义 Roles 枚举的值：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[&lt;span&gt;Flags&lt;/span&gt;]&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt; Roles&lt;br/&gt;{&lt;br/&gt;Admin = &lt;span&gt;1&lt;/span&gt;,&lt;br/&gt;Member = &lt;span&gt;2&lt;/span&gt;,&lt;br/&gt;Manager = &lt;span&gt;4&lt;/span&gt;,&lt;br/&gt;Operator = &lt;span&gt;8&lt;/span&gt;&lt;br/&gt;}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不过在定义值的时候要在心中小小计算一下，如果你想懒一点，可以用下面这种“位移”的方法来定义：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[&lt;span&gt;Flags&lt;/span&gt;]&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt; Roles&lt;br/&gt;{&lt;br/&gt;Admin    = &lt;span&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;0&lt;/span&gt;,&lt;br/&gt;Member   = &lt;span&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;1&lt;/span&gt;,&lt;br/&gt;Manager  = &lt;span&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;2&lt;/span&gt;,&lt;br/&gt;Operator = &lt;span&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;3&lt;/span&gt;&lt;br/&gt;}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一直往下递增编值即可，阅读体验好，也不容易编错。两种方式是等效的，常量位移的计算是在编译的时候进行的，所以相比不会有额外的开销。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;本文通过一道小小的面试题引发一连串对枚举的思考。在小型系统中，把用户角色直接存储在用户表是很常见的做法，此时把角色字段设为整型（比如 int）是比较好的设计方案。但与此同时，也要考虑到一些最佳实践，比如使用 Flags 特性来帮助更好的调试和日志输出。也要考虑到实际开发中的各种潜在问题，比如多个枚举值进行或（‘|’）运算与成员值发生冲突的问题。&lt;/p&gt;
</description>
<pubDate>Thu, 14 May 2020 00:07:00 +0000</pubDate>
<dc:creator>Liam Wang</dc:creator>
<og:description>文章开头先给大家出一道面试题： 在设计某小型项目的数据库（假设用的是 MySQL）时，如果给用户表（User）添加一个字段（Roles）用来存储用户的角色，你会给这个字段设置什么类型？提示：要考虑到角</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/willick/p/csharp-enum-superior-tactics.html</dc:identifier>
</item>
<item>
<title>Spark SQL源码解析（四）Optimization和Physical Planning阶段解析 - zzzzMing</title>
<link>http://www.cnblogs.com/listenfwind/p/12886205.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/listenfwind/p/12886205.html</guid>
<description>&lt;p&gt;Spark SQL原理解析前言：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/listenfwind/p/12724381.html&quot;&gt;Spark SQL源码剖析（一）SQL解析框架Catalyst流程概述&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/listenfwind/p/12735833.html&quot;&gt;Spark SQL源码解析（二）Antlr4解析Sql并生成树&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/listenfwind/p/12795934.html&quot;&gt;Spark SQL源码解析（三）Analysis阶段分析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;前面已经介绍了SQL parse，将一条SQL语句使用antlr4解析成语法树并使用访问者模式生成Unresolved LogicalPlan，然后是Analysis阶段将Unresolved LogicalPlan转换成Resolved LogicalPlan。这一篇我们介绍Optimization阶段，和生成Physical Planning阶段。&lt;/p&gt;
&lt;p&gt;经过这两个阶段后，就差不多要到最后转换成Spark的RDD任务了。&lt;/p&gt;

&lt;p&gt;先来看看Logical Optimization阶段。&lt;/p&gt;
&lt;p&gt;上一篇我们讨论了Analysis阶段如何生成一个真正的Logical Plan树。这一阶段听名字就知道是优化阶段，Spark SQL中有两个部分的优化，第一部分就是这里，是rule-base阶段的优化，就是根据各种关系代数的优化规则，对生成的Logical Plan适配，匹配到就进行相应的优化逻辑。这些规则大概有：投影消除，constant folding，替换null值，布尔表达式简化等等。当然大部分规则细节我也不是很清楚，仅仅能从名字推断一二。这&lt;/p&gt;
&lt;p&gt;同时还可以添加自己的优化rule，也比较容易实现，论文中就给出了一段自定义优化rule的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;object DecimalAggregates extends Rule[LogicalPlan] {
  /** Maximum number of decimal digits in a Long */
  val MAX_LONG_DIGITS = 18
  def apply(plan: LogicalPlan): LogicalPlan = {
    plan transformAllExpressions {
      case Sum(e @ DecimalType.Expression(prec , scale))
        if prec + 10 &amp;lt;= MAX_LONG_DIGITS =&amp;gt;
          MakeDecimal(Sum(UnscaledValue(e)), prec + 10, scale)
  }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码的大意是自定义了一个rule，如果匹配到SUM的表达式，那就执行相应的逻辑，论文里描述这里是找到对应的小数并将其转换为未缩放的64位LONG。具体逻辑看不是很明白不过不重要，重要的是编写自己的优化rule很方便就是。&lt;/p&gt;
&lt;p&gt;顺便点一下另一种优化，名字叫做cost-base优化（CBO），是发生在Physical Planning阶段的，这里就先卖个关子，后面说到的时候再讨论吧。&lt;/p&gt;
&lt;p&gt;然后看到源码的时候，会发现Optimizer这个类也是继承自RuleExecutor，继承这个类之后的流程基本都是一样的。前面分析Analysis阶段的时候已经有详细介绍过这个流程，这里就不展开说了。&lt;/p&gt;
&lt;p&gt;其实这优化器的重点应该是各种优化规则，这里我觉得更多的是设计到关系代数表达式优化理论方面的知识，这部分我也不甚精通，所以也就不说了。对这块感兴趣的童鞋可以看看网上别人的文章，这里顺便列几个可能有帮助的博客，&lt;/p&gt;
&lt;p&gt;下面还是来看看最开始的例子进行Optimization阶段后会变成什么样吧，先看看之前的示例代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    val df = Seq((1, 1)).toDF(&quot;key&quot;, &quot;value&quot;)
    df.createOrReplaceTempView(&quot;src&quot;)
    val queryCaseWhen = sql(&quot;select key from src &quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在Optimization优化阶段后，变成了：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Project [_1#2 AS key#5]
+- LocalRelation [_1#2, _2#3]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;好吧，看起来没什么变化，与Analysis阶段相比，也就少了个SubqueryAlias ，符合预期。不过也对，就一条SELECT语句能优化到哪去啊。&lt;/p&gt;

&lt;p&gt;相比较于Logical Plan，Physical plan算是Spark可以去执行的东西了，当然本质上它也是一棵树。&lt;/p&gt;
&lt;p&gt;前面说到，Spark有一种cost-based的优化。主要就在这一阶段，在这一阶段，会生成一个或多个Physical Plan，然后使用cost model预估各个Physical Plan的处理性能，最后选择一个最优的Physical Plan。这里最主要优化的是join操作，当触发join操作的时候，会根据左右两边的数据集判断，然后决定使用Broadcast join，还是传统的Hash join，抑或是MergeSort join，有关这几种join的区别这里就不详细解释了，有兴趣童鞋可以百度看看。&lt;/p&gt;
&lt;p&gt;除了cost-based优化，这一阶段也依旧会有rule-based优化，所以说RuleExecutor这个类是很重要的，前面提到的Analysis阶段也好，Optimization阶段也好，包括这里的Physical Plan阶段，只要是涉及到rule-based优化，都会跟RuleExecutor这个类扯上关系。当然这样无疑是极大使用了面向对象的特性，不同的阶段编写不同的rule就行，一次编写，到处复用。&lt;/p&gt;

&lt;p&gt;首先是在QueryExecution中调度，&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class QueryExecution(val sparkSession: SparkSession, val logical: LogicalPlan) {
  ......其他代码
  lazy val sparkPlan: SparkPlan = {
    SparkSession.setActiveSession(sparkSession)
    // TODO: We use next(), i.e. take the first plan returned by the planner, here for now,
    //       but we will implement to choose the best plan.
    planner.plan(ReturnAnswer(optimizedPlan)).next()
  }
  ......其他代码
}
  
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的planner是org.apache.spark.sql.execution.SparkPlanner这个类，而这个类继承自org.apache.spark.sql.catalyst.planning.QueryPlanner，plan()方法也是在父类QueryPlanner中实现的。和RuleExecution类似，QueryPlanner中有一个返回Seq[GenericStrategy[PhysicalPlan]]的方法：&lt;strong&gt;def strategies: Seq[GenericStrategy[PhysicalPlan]]&lt;/strong&gt;，这个方法会在子类（也就是SparkPlanner）重写，然后被QueryPlanner的plan()方法调用。&lt;/p&gt;
&lt;p&gt;我们来看看SparkPlanner中strategies方法的重写，再来看QueryPlanner的plan()方法吧。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class SparkPlanner(
    val sparkContext: SparkContext,
    val conf: SQLConf,
    val experimentalMethods: ExperimentalMethods)
  extends SparkStrategies {
  ......其他代码
  override def strategies: Seq[Strategy] =
    experimentalMethods.extraStrategies ++
      extraPlanningStrategies ++ (
      PythonEvals ::
      DataSourceV2Strategy ::
      FileSourceStrategy ::
      DataSourceStrategy(conf) ::
      SpecialLimits ::
      Aggregation ::
      Window ::
      JoinSelection ::
      InMemoryScans ::
      BasicOperators :: Nil)
        ......其他代码
        
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;strategies()返回策略列表，是生成策略GenericStrategy，这是个具体的抽象类，位于org.apache.spark.sql.catalyst.planning包。所谓生成策略，就是决定如果根据Logical Plan生成Physical Plan的策略。比如上面介绍的join操作可以生成Broadcast join，Hash join，抑或是MergeSort join，就是一种生成策略，具体的类就是上面代码中的JoinSelection。每个生成策略GenericStrategy都是object，其apply()方法返回的是Seq[SparkPlan]，&lt;strong&gt;这里的SparkPlan就是PhysicalPlan&lt;/strong&gt;（注意：下文会将SparkPlan和PhysicalPlan混着用）。&lt;/p&gt;
&lt;p&gt;明白了生成策略后，就可以来看看QueryPlanner的plan()方法了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;abstract class QueryPlanner[PhysicalPlan &amp;lt;: TreeNode[PhysicalPlan]] {
  ......其他代码
  def plan(plan: LogicalPlan): Iterator[PhysicalPlan] = {
    // Obviously a lot to do here still...

    // Collect physical plan candidates.
    val candidates = strategies.iterator.flatMap(_(plan))       //迭代调用并平铺，变成Iterator[SparkPlan]

    // The candidates may contain placeholders marked as [[planLater]],
    // so try to replace them by their child plans.
    val plans = candidates.flatMap { candidate =&amp;gt;
      val placeholders = collectPlaceholders(candidate)

      if (placeholders.isEmpty) {
        // Take the candidate as is because it does not contain placeholders.
        Iterator(candidate)
      } else {
        // Plan the logical plan marked as [[planLater]] and replace the placeholders.
        placeholders.iterator.foldLeft(Iterator(candidate)) {
          case (candidatesWithPlaceholders, (placeholder, logicalPlan)) =&amp;gt;
            // Plan the logical plan for the placeholder.
            val childPlans = this.plan(logicalPlan)     

            candidatesWithPlaceholders.flatMap { candidateWithPlaceholders =&amp;gt;
              childPlans.map { childPlan =&amp;gt;
                // Replace the placeholder by the child plan
                candidateWithPlaceholders.transformUp {
                  case p if p.eq(placeholder) =&amp;gt; childPlan
                }
              }
            }
        }
      }
    }

    val pruned = prunePlans(plans)
    assert(pruned.hasNext, s&quot;No plan for $plan&quot;)
    pruned
  }
  
  ......其他代码
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的流程其实不难，主要工作其实就是调用各个生成策略GenericStrategy的apply()方法，生成Iterator[SparkPlan]。后面很大部分代码是处理占位符，按我的理解，在生成Logical Plan的时候，可能有些无意义的占位符，这种需要使用子节点替换调它。倒数第三行prunePlans()方法按注释说是用来去掉bad plan的，但看实际代码只是原封不动返回。&lt;/p&gt;
&lt;p&gt;这样最终就得到一个Iterator[SparkPlan]，每个SparkPlan就是可执行的物理操作了。&lt;/p&gt;
&lt;p&gt;大致流程就是如此，当然具体到一些生成策略没有细说，包括输入源策略，聚合策略等等，每一个都蛮复杂的，这里就不细说，有兴趣可以自行查阅。&lt;/p&gt;
&lt;p&gt;对了，最后还要看看示例代码到这一步变成什么样了，先上示例代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    //生成DataFrame
    val df = Seq((1, 1)).toDF(&quot;key&quot;, &quot;value&quot;)
    df.createOrReplaceTempView(&quot;src&quot;)
    //调用spark.sql
    val queryCaseWhen = sql(&quot;select key from src &quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;经过Physical Planning阶段后，变成如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Project [_1#2 AS key#5]
+- LocalTableScan [_1#2, _2#3]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对比上面的optimized阶段，直观看就是LocalRelation变成LocalTableScan。变得更加具体了，但实际上，Project也变了，虽然打印名字相同，但一个的类型是Project，本质上是LogicalPlan。而一个是ProjectExec，本质上是SparkPlan（也就是PhysicalPlan）。这一点通过断点看的更清楚。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1011838/202004/1011838-20200422180713613-1374963727.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到这一步已经很解决终点了，后面再经过一个Preparations阶段就能生成RDD了，剩下的部分留待下篇介绍吧。&lt;/p&gt;
&lt;p&gt;以上~&lt;/p&gt;
</description>
<pubDate>Thu, 14 May 2020 00:04:00 +0000</pubDate>
<dc:creator>zzzzMing</dc:creator>
<og:description>Spark SQL原理解析前言： &amp;quot;Spark SQL源码剖析（一）SQL解析框架Catalyst流程概述&amp;quot; &amp;quot;Spark SQL源码解析（二）Antlr4解析Sql并生</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/listenfwind/p/12886205.html</dc:identifier>
</item>
<item>
<title>讲道理，只要你是一个爱折腾的程序员，毕业找工作真的不需要再花钱培训！ - 小傅哥</title>
<link>http://www.cnblogs.com/xiaofuge/p/12886203.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaofuge/p/12886203.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020043022510635.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;作者：小傅哥&lt;br/&gt;博客：&lt;a href=&quot;https://bugstack.cn&quot;&gt;https://bugstack.cn&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;沉淀、分享、成长，让自己和他人都能有所收获！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一、前言&quot;&gt;一、前言&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;标题&lt;/strong&gt;&lt;em&gt;想吸引你进来参考下我的学习方式，或许能给你带来一些经验。当然不乏一些培训中也有超级优秀的开发人员。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;讲道理&lt;/code&gt;，程序员上学这段时光相对每个人都是公平的。同样是拿到了一本 &lt;code&gt;谭浩强&lt;/code&gt; 的《Java 2 实用教程》，也同样有一台笔记本电脑，和一个宿舍一张床。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://bugstack.cn/assets/images/2020/itstack-code-life-04-01.jpg&quot; alt=&quot;那些年的男生宿舍&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说说我自己&lt;/strong&gt;，刚上大一编程方面的课程是&lt;code&gt;C语言&lt;/code&gt;，先不说能不能运行出来 &lt;code&gt;HelloWorld&lt;/code&gt; ,就连安装个 &lt;code&gt;VC++ 6.0&lt;/code&gt; ,都折腾好几天。&lt;em&gt;可能也是神奇，因为萌新小白学习东西能遇到各种各样的问题。&lt;/em&gt; 最后安装好了软件的电脑真的不敢乱弄，怕它坏。&lt;code&gt;C语言&lt;/code&gt; 学了一个学期后开始了 &lt;code&gt;Java&lt;/code&gt; 课程，大家都说 &lt;code&gt;Java&lt;/code&gt; 简单，巴拉巴拉 有很多函数、开发工具好用、内存自己回收等等。但确实，工具还是蛮好安装的，除了配置环境变量要去网上抄一下，还是可以写出一个 &lt;code&gt;Hi Java&lt;/code&gt; 的。从此便开始了 &lt;code&gt;Java&lt;/code&gt; 学习的旅途。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;从你&lt;/strong&gt;摸起电脑的那一刻，每个人学习编程都会遇到很多问题，包括；&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;完全不知道是啥，不知道从哪开始，老师讲过也不会。&lt;/li&gt;
&lt;li&gt;多次碰壁运行不出结果，带不来成就感。没有游戏和隔壁系的妹子好。&lt;/li&gt;
&lt;li&gt;学完就忘，背了也记不住，觉得自己也没有项目，不能锻炼。&lt;/li&gt;
&lt;li&gt;能交流的人少，身边也是打游戏的多，大学校园花花绿绿，有钱没钱，我也想玩玩。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;code&gt;除了这些问题&lt;/code&gt;，可能比这些多的还有很多问题。我也同样遇到过，初学时我也去加一些QQ群，但是很多都是比较水，能讨论技术的不多。也看过一些技术论坛，确实还是有引导性的帮助的。也跟一些师哥师姐交流，大学学哪些知识才能找到工作。好在，慢慢摸索出一条学习路线。同时为了可以与&lt;code&gt;同好&lt;/code&gt;共同学习，就自己建了技术QQ群(&lt;code&gt;东软帝国&lt;/code&gt;)，认识了一群好友，在我大学期间时常给我解决bug；&lt;code&gt;大帝&lt;/code&gt;、&lt;code&gt;糖糖&lt;/code&gt;、&lt;code&gt;苏二毛&lt;/code&gt;、&lt;code&gt;蚂蚁&lt;/code&gt;、&lt;code&gt;ZERO&lt;/code&gt;、&lt;code&gt;小凯&lt;/code&gt;、&lt;code&gt;Ticmy&lt;/code&gt;、&lt;code&gt;大宝&lt;/code&gt;、&lt;code&gt;萌货&lt;/code&gt;等众多好友。他们现在也分布在BAT等一线互联网的中，也有做到总监级别的大佬。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;给自己打打气&lt;/strong&gt;，有时候真的需要给自己点激励，毕竟这条路走起来不是那么容易。我的方式是上学期间时常会写一些自己认为算是诗句的诗，来提升自己的斗志。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;红尘世界几个王，我自不服迎头上。
日敲代码两百行，冲进世界五百强。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;如果你在网上搜这几句话，还是可以搜的到的！&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;学习编程的过程很大一个问题是写的少，总有一部分人觉得只要看了视频，背了代码，这东西就能会。但往往真的不是这样，只要这东西不是你亲手敲了几十遍，你就永远也记不住。因为这个过程是在锻炼你的逻辑思维和肌肉记忆，为啥说是肌肉记忆呢？就像你打字聊天，输入一个拼音&lt;code&gt;nihao&lt;/code&gt;，你会现在会想到它是从哪个手指敲出去的吗？根本就不会了，肌肉记忆早已形成，你只需要把你要的内容想到就能立刻通过键盘呈现出来。同样写代码也是也有的，&lt;code&gt;public static void main&lt;/code&gt;，如果这一句代码你要反复看着键盘去敲，那么就是你写的代码量还是太少。&lt;/p&gt;
&lt;p&gt;愿努力拼搏的你都能承载一份美好！&lt;/p&gt;
&lt;h2 id=&quot;二、初学编程用过的书&quot;&gt;二、初学编程用过的书&lt;/h2&gt;
&lt;p&gt;嗯！是&lt;em&gt;用过&lt;/em&gt;的书，不是&lt;em&gt;看过&lt;/em&gt;的书。&lt;/p&gt;
&lt;p&gt;初学编程的人往往并不需要太多的书，因为一本书所涵盖的知识基本已经很全面了，难的是要一字一句的把里面的内容都搞定。如果只是看还是很容易的，但是要想按照里面说的都实现运行出结果，那对收获来说就不不一样了。当然，如果你已经深入的学习了，领悟性有很好。可以在继续扩展其他书籍的学习，包括一些深入的原理、源码的分析、技能的拓展等等。&lt;/p&gt;
&lt;h3 id=&quot;1-谭浩强的这本书看了好久&quot;&gt;1. 谭浩强的这本书看了好久&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://bugstack.cn/assets/images/2020/itstack-code-life-04-02.png&quot; alt=&quot;谭浩强《Java 2 实用教程》&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一遍遍翻，一遍遍看，一遍遍运行里面的代码。这本书真的给我带来很大的帮助，时至今日它也一直在我的身边。&lt;/p&gt;
&lt;h3 id=&quot;2-ssh-几百页的书翻烂了&quot;&gt;2. SSH 几百页的书翻烂了&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://bugstack.cn/assets/images/2020/itstack-code-life-04-03.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;学习完基础编程后，就需要去拓展Spring相关技能，去开发真正的项目。类似这样的书还是比较多的，书中也包括了一些项目可以跟着学习。&lt;/p&gt;
&lt;h3 id=&quot;3-除了书还有视频可以看&quot;&gt;3. 除了书还有视频可以看&lt;/h3&gt;
&lt;p&gt;似乎每个程序员都看过 &lt;code&gt;马士兵&lt;/code&gt; 的视频，主要是他的声音和讲课方式很吸引人，不沉闷又能学的干货。至少他的视频我是看了5-6遍，也跟着写了5-6遍。&lt;/p&gt;
&lt;h2 id=&quot;三、同样的项目做了n遍&quot;&gt;三、同样的项目做了N遍&lt;/h2&gt;
&lt;p&gt;在学习编程的过程中，我搞过很多的项目，当然这些项目的需求很多都是我臆想出来的。通过我需要锻炼什么样的知识点，之后去想着大概一个什么样的项目可以涵盖的去练习。&lt;/p&gt;
&lt;p&gt;但！学到 &lt;code&gt;Socket&lt;/code&gt; 后，大家应该都做过局域网聊天，而我比较能折腾做了N次。直到最后这次不仅自己得到锻炼，还可以帮助被人成长。&lt;/p&gt;
&lt;h3 id=&quot;1-上学期间第一个仿qq聊天&quot;&gt;1. 上学期间第一个仿QQ聊天&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;登录&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://bugstack.cn/assets/images/2020/itstack-code-life-04-04.jpg&quot; alt=&quot;仿QQ聊天，登录&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;好友&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://bugstack.cn/assets/images/2020/itstack-code-life-04-05.jpg&quot; alt=&quot;仿QQ聊天，好友&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;聊天&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://bugstack.cn/assets/images/2020/itstack-code-life-04-06.jpg&quot; alt=&quot;仿QQ聊天，聊天&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;这个期间是学校聘请了外部的老师来教我们做项目，为了尽可能做的好一点，当时就研究着仿照QQ做一款通信。现在看还是比较丑的，但是当时也是比较牛的了。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;2-培训期间局域网聊天&quot;&gt;2. 培训期间局域网聊天&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;登录&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://bugstack.cn/assets/images/2020/itstack-code-life-04-07.jpg&quot; alt=&quot;局域网通信，登录&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;聊天&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://bugstack.cn/assets/images/2020/itstack-code-life-04-08.jpg&quot; alt=&quot;局域网通信，聊天&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;控制台&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://bugstack.cn/assets/images/2020/itstack-code-life-04-09.jpg&quot; alt=&quot;局域网通信，控制台&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;清楚的记得这是当时搞了一周写完的，毕竟还是比较熟练了。&lt;/li&gt;
&lt;li&gt;甚至我在考虑把好友与聊天窗口合并，貌似现在大部分聊天软件也都是这么干的了！嗯！优秀！&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;3-学netty50写局域网聊天&quot;&gt;3. 学Netty5.0写局域网聊天&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;登录&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://bugstack.cn/assets/images/2020/itstack-code-life-04-10.png&quot; alt=&quot;Netty5.0通信，登录&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;聊天&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://bugstack.cn/assets/images/2020/itstack-code-life-04-11.png&quot; alt=&quot;Netty5.0通信，聊天&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;4-学websocket仿微信聊天&quot;&gt;4. 学WebSocket仿微信聊天&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;聊天&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://bugstack.cn/assets/images/2020/itstack-code-life-04-12.png&quot; alt=&quot;WebSocket通信，聊天&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;15开始学习 &lt;code&gt;netty5.0&lt;/code&gt;，但是后来由于&lt;code&gt;5.0&lt;/code&gt;版本问题，netty官网下掉5.0。于是去年19年，我又开始编写 &lt;code&gt;nett4.0&lt;/code&gt; 案例。为此也写了一次 &lt;code&gt;WebSocket&lt;/code&gt; 通信。&lt;/li&gt;
&lt;li&gt;源码：&lt;a href=&quot;https://github.com/fuzhengwei/itstack-demo-netty&quot;&gt;https://github.com/fuzhengwei/itstack-demo-netty&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;5-出专栏仿桌面版微信&quot;&gt;5. 出专栏仿桌面版微信&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;登录&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://bugstack.cn/assets/images/2020/itstack-code-life-04-13.png&quot; alt=&quot;Netty仿桌面版微信，登录&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;聊天&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://bugstack.cn/assets/images/2020/itstack-code-life-04-14.png&quot; alt=&quot;Netty仿桌面版微信，聊天&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;好友&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://bugstack.cn/assets/images/2020/itstack-code-life-04-15.png&quot; alt=&quot;Netty仿桌面版微信，好友&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;这个项目是20年过年期间发起的，使用JavaFx、Netty4.x、SpringBoot、Mysql等技术栈和偏向于DDD领域驱动设计方式，搭建的仿桌面版微信聊天工程实现通信核心功能。&lt;/li&gt;
&lt;li&gt;源码：&lt;a href=&quot;https://github.com/fuzhengwei/NaiveChat&quot;&gt;https://github.com/fuzhengwei/NaiveChat&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;6-除了这些还搞过很多&quot;&gt;6. 除了这些还搞过很多&lt;/h3&gt;
&lt;p&gt;只要是能学习编程的内容，我似乎一直在折腾。谁学习期间也没有一个项目，但是可以自己去想出来一个项目，之后通过这样的项目锻炼自己的知识，尽可能让学到的内容得以实践。下面在列举一些；&lt;/p&gt;
&lt;h4 id=&quot;1-分数计算机&quot;&gt;1. 分数计算机&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://bugstack.cn/assets/images/2020/itstack-code-life-04-16-01.png&quot; alt=&quot;计算器&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;2-学生成绩管理系统&quot;&gt;2. 学生成绩管理系统&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://bugstack.cn/assets/images/2020/itstack-code-life-04-16-02.png&quot; alt=&quot;成绩系统&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;3-考试题库系统&quot;&gt;3. 考试题库系统&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://bugstack.cn/assets/images/2020/itstack-code-life-04-16-03.png&quot; alt=&quot;考试题库系统&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;4-图书馆系统&quot;&gt;4. 图书馆系统&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://bugstack.cn/assets/images/2020/itstack-code-life-04-16-04.png&quot; alt=&quot;图书馆系统&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;5-彩礼管理系统&quot;&gt;5. 彩礼管理系统&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://bugstack.cn/assets/images/2020/itstack-code-life-04-16-05.png&quot; alt=&quot;彩礼管理系统&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;6-在线考试系统&quot;&gt;6. 在线考试系统&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://bugstack.cn/assets/images/2020/itstack-code-life-04-16-06.png&quot; alt=&quot;在线考试系统&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;好在当年留了一些图片&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虽然这些系统在现在看有点点丑，甚至算不上项目，但对于编码从初识到了解的一个学习过程是需要的。总归，是要做一些实际的目标性内容，引导自己不断地强化知识。把一些未知的知识尽可能通过问题诉求学习到。&lt;/p&gt;
&lt;h2 id=&quot;四、沉淀、分享，交个朋友&quot;&gt;四、沉淀、分享，交个朋友&lt;/h2&gt;
&lt;p&gt;从19年开始，我想着生活里要添加一点自己能长期坚持的事情，不要把时间都浪费掉。于是，选择了我最擅长的方向，做原创技术输出。这样既能让自己有所沉淀，也能把知识传播给他人带来成长。&lt;/p&gt;
&lt;ul readability=&quot;7.9148550724638&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;2019年7月&lt;/strong&gt;，搭建个人博客；&lt;a href=&quot;https://bugstack.cn/&quot;&gt;https://bugstack.cn&lt;/a&gt; - 沉淀、分享、成长，让自己和他人都能有所收获&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;2019年8月&lt;/strong&gt;，找回公众号&lt;code&gt;bugstack虫洞栈&lt;/code&gt;，定期推送个人原创技术文章&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;2019年9月&lt;/strong&gt;，CSDN 申请博客专家通过&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;2019年10月&lt;/strong&gt;，微信公众号终于又了1k的读者&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;2019年11月&lt;/strong&gt;，完成三个专栏内容编写；&lt;code&gt;《用Java实现JVM》&lt;/code&gt;、&lt;code&gt;《Netty4.x专栏学习》&lt;/code&gt;、&lt;code&gt;《基于JavaAgent全链路监控》&lt;/code&gt;、&lt;code&gt;《DDD领域驱动设计实践》&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;2019年12月&lt;/strong&gt;，开发微信公众号与博客打通引流粉丝&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;2020年&lt;/strong&gt;，还在进行中！发布了&lt;a href=&quot;http://chat.itstack.org&quot;&gt;&lt;code&gt;GitChat专栏&lt;/code&gt;&lt;/a&gt; 、&lt;code&gt;深入编写了字节码编程&lt;/code&gt;、&lt;code&gt;持续做原创技术输出&lt;/code&gt;，&lt;code&gt;加强个人技术栈学习&lt;/code&gt;，&lt;code&gt;吸纳架构设计精髓&lt;/code&gt;等等。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2.6517150395778&quot;&gt;
&lt;p&gt;&lt;strong&gt;整理了一整套&lt;code&gt;CodeGuide 程序员编码指南&lt;/code&gt;&lt;/strong&gt; - &lt;a href=&quot;https://github.com/fuzhengwei/CodeGuide/wiki&quot;&gt;https://github.com/fuzhengwei/CodeGuide/wiki&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;本代码库是作者小傅哥多年从事一线互联网 Java 开发的学习历程技术汇总，旨在为大家提供一个清晰详细的学习教程，侧重点更倾向编写Java核心内容。如果本仓库能为您提供帮助，请给予支持(关注、点赞、分享)！&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;p&gt;做这些事情，更多是我的&lt;code&gt;爱好&lt;/code&gt;和&lt;code&gt;爱折腾的性格&lt;/code&gt;在支撑我。也希望将我的编程学习经验和技术沉淀多多分享。&lt;/p&gt;
&lt;p&gt;其实大家可支配的时间都差不多，只不过开始写技术文章后，不吃鸡、不王者、不去电影、夜里0点前不睡觉也有2点的时候、周末放假不出去浪(今年也出不去)。那么你还是可以做一些有意义的事。当然，如果你说这样不是生活，但每个人爱好不同。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;收入&lt;/strong&gt;，写文章是会有收入的，公众号里日常4毛，也有1块多的时候，但几分也有。好在，我现在也不在乎这个，主要是要做一件可以坚持的有意义的事。&lt;/p&gt;
&lt;p&gt;如果说能给你一些意见，我也建议你可以折腾折腾，程序员的世界里折腾一下还是可以全方位的学到很多东西的。做的久了会提升全栈的研发技能（后端、前端、部署、运维等等），而且还会获得；业务、运营、产品定位等等方面的提升。&lt;/p&gt;
&lt;h2 id=&quot;五、收个尾&quot;&gt;五、收个尾&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;em&gt;以上呢&lt;/em&gt;，是我学习和不断折腾的一个方式。算不上优秀，但至少这样的学习可以保证你毕业时候找一份不错的工作，也能为你将来做好后路的根基。虽然每个人都有自己的路，但如果到了年纪还是要多把时间放到有价值的事上。&lt;/li&gt;
&lt;li&gt;持续学习的过程遇到了很多伙伴，各有优秀。虽然他们不会把钱给咱们😁，但是这些伙伴的宝贵经验都是会无偿告诉你的。&lt;code&gt;包括你学的技术遇到问题&lt;/code&gt;、&lt;code&gt;包括你写文章需要看哪些书籍&lt;/code&gt;、&lt;code&gt;包括你对各个领域的认知&lt;/code&gt;等等。&lt;/li&gt;
&lt;li&gt;做人，做事，我喜欢亲和友善，广结同好。自从写公众号文章，有很多小伙伴加了我的微信，也和很多人成为了好朋友，他们日常帮我点赞、分享文章，深深感谢！&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Thu, 14 May 2020 00:03:00 +0000</pubDate>
<dc:creator>小傅哥</dc:creator>
<og:description>作者：小傅哥 博客： &amp;quot;https://bugstack.cn&amp;quot; 沉淀、分享、成长，让自己和他人都能有所收获！ 一、前言 标题 想吸引你进来参考下我的学习方式，或许能给你带来一些经</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiaofuge/p/12886203.html</dc:identifier>
</item>
<item>
<title>构建一个杂志布局（译文） - css design</title>
<link>http://www.cnblogs.com/css/p/12881168.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/css/p/12881168.html</guid>
<description>&lt;p&gt;与以往的Web布局不同的杂志布局，原文地址 &lt;a title=&quot;Highlights From Building a Magazine Layout&quot; href=&quot;https://ishadeed.com/article/magazine-layout-highlights/&quot; target=&quot;_blank&quot;&gt;Highlights From Building a Magazine Layout&lt;/a&gt; 25 Nov 2019&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/35163/202005/35163-20200513093635691-235033092.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一个杂志的照片&lt;/p&gt;
&lt;p&gt;时至今日，我们掌握的web技术已经是今非昔比。日新月异。由我们来决定：要么接受挑战，要么不学习新事物。我想选择一种可以使用新CSS技术的设计，并尝试进一步掌握它们。今天，我选择一个杂志布局，其中包含一些非常有趣，具有挑战性的设计细节。&lt;/p&gt;
&lt;h3&gt;内容&lt;/h3&gt;
&lt;p&gt;为了正确地用HTML标记，首先我浏览了所有内容。对我来说，它读起来就像一篇带有标题和描述段落的文章。我想象成像下面的设计模型。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/35163/202005/35163-20200513100839356-1052342146.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然，我们不会构建它，但是我想向你们展示在不用杂志版面的情况下设计的外观。&lt;/p&gt;
&lt;p&gt;在HTML中，我添加了以下内容：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;magazine&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;item item-72&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;item item-50&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;...Has lived quietly in harvard square for nearly&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;num&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;50&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;years&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; Other items &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意，我将内容放置在&amp;lt;span&amp;gt;内，以便以后可以通过CSS轻松控制它。初始HTML的外观如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/35163/202005/35163-20200513101449598-1941063401.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;Grid&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/35163/202005/35163-20200513101559502-170216590.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;网格布局具有三列，每列具有唯一的大小。我认为这就是为什么布局首先看起来很有创意的原因。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.magazine &lt;/span&gt;{&lt;span&gt;
  display&lt;/span&gt;:&lt;span&gt; grid&lt;/span&gt;;&lt;span&gt;
  grid-template-columns&lt;/span&gt;:&lt;span&gt; 1.35fr 1fr 110px&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;定义网格后，需要使用&lt;code&gt;grid-column&lt;/code&gt;和&lt;code&gt;grid-row&lt;/code&gt;将每个元素放置在其位置。借助Firefox DevTools的网格，这很容易。确保激活“Display line numbers”。&lt;/p&gt;
&lt;p&gt;例如，编号为“50”的项目的位置如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.item-50 &lt;/span&gt;{&lt;span&gt;
    grid-row&lt;/span&gt;:&lt;span&gt; 1/3&lt;/span&gt;;&lt;span&gt;
    grid-column&lt;/span&gt;:&lt;span&gt; 2/3&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;与其余项目类似。完成后，它应该像这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/35163/202005/35163-20200513103624719-42218945.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;百分比边距&lt;/h3&gt;
&lt;p&gt;我很少使用百分比作为边距的值，但是对于这种布局，我发现它适合某些情况。我重点突出了可以用到的项目。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/35163/202005/35163-20200513104148012-81780992.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我在每个项目中添加了以下内容：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.item-72 &lt;/span&gt;{&lt;span&gt; margin-left&lt;/span&gt;:&lt;span&gt; 25%&lt;/span&gt;; }&lt;span&gt;

.item-50 &lt;/span&gt;{&lt;span&gt; margin-top&lt;/span&gt;:&lt;span&gt; 6%&lt;/span&gt;; }&lt;span&gt;

.item-decades &lt;/span&gt;{&lt;span&gt; margin-left&lt;/span&gt;:&lt;span&gt; 10%&lt;/span&gt;; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;…等等。这些值是通过反复试验选择的，所以不是使用的特定数字。完成后，它应如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/35163/202005/35163-20200513104507810-1973211487.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;弹性盒&lt;/h3&gt;
&lt;p&gt;如果你尚未发现，布局中的某些项目可以使用flexbox完成。我将向您展示如何构建其中两个项目。不用说，项目的突出显示是由Firefox DevTools完成的。&lt;/p&gt;
&lt;h4&gt;case 1&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/35163/202005/35163-20200513105109777-1280455648.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;item item-friends&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;She wrote a new drama about&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;num&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;4&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;cambridge friends&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.item-friends &lt;/span&gt;{&lt;span&gt;
    display&lt;/span&gt;:&lt;span&gt; flex&lt;/span&gt;;
}&lt;span&gt;

.item-friends span:last-child &lt;/span&gt;{&lt;span&gt;
    align-self&lt;/span&gt;:&lt;span&gt; flex-end&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;&lt;span&gt;case 2&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;在这种情况下，弹性项目的方向是垂直的（列）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/35163/202005/35163-20200513105342880-313217894.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;item item-50&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;...Has lived quietly in harvard square for nearly&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;num&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;50&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;years.&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.item-50 &lt;/span&gt;{&lt;span&gt;
    display&lt;/span&gt;:&lt;span&gt; flex&lt;/span&gt;;&lt;span&gt;
    flex-direction&lt;/span&gt;:&lt;span&gt; column&lt;/span&gt;;
}&lt;span&gt;

.item-50 span:last-child &lt;/span&gt;{&lt;span&gt;
    align-self&lt;/span&gt;:&lt;span&gt; flex-end&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;强制换行&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/35163/202005/35163-20200513105828222-1804119734.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;根据设计，有两个项目，每个项目都有一个句子，每个单词都要换行。我需要一种在每个词后强制换行的方法。&lt;/p&gt;
&lt;p&gt;最初，我考虑过使用&lt;code&gt;min-content&lt;/code&gt;作为元素宽度的值。根据元素内容来计算最小宽度来运行。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.elem &lt;/span&gt;{&lt;span&gt;
    width&lt;/span&gt;:&lt;span&gt; min-content&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;虽然这可能在所有情况下都行不通。我稍微改变了文字可以了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/35163/202005/35163-20200513135006360-2122926204.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另一个更保险的解决方案是使用&lt;code&gt;word-spacing&lt;/code&gt;大像素值或视窗值的字间距。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.elem &lt;/span&gt;{&lt;span&gt;
    word-spacing&lt;/span&gt;:&lt;span&gt; 9999px&lt;/span&gt;;
    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Or &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    word-spacing&lt;/span&gt;:&lt;span&gt; 100vw&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;使字体大小适应容器宽度&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/35163/202005/35163-20200513134741362-905113342.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;无论屏幕大小如何，具有深珊瑚色背景的句子都必须保持一行。我尝试使用视窗单位，但没用。经过&lt;a href=&quot;https://css-tricks.com/fitting-text-to-a-container/&quot; target=&quot;_blank&quot;&gt;研究&lt;/a&gt;，我了解了fittext.js而不是其父容器中的合适文本。&lt;/p&gt;
&lt;p&gt;但是，我考虑过使用ResizeObserver，对于我的用例来说，就好像有一种魔力！我试着算出一个关键值将除以父容器的宽度。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
let itemBar = document.querySelector('.item-bar'&lt;span&gt;);

const ro &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ResizeObserver(entries =&amp;gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (let entry of entries) {
    let w &lt;/span&gt;= entry.contentRect.width; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Width of parent &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    let fz &lt;/span&gt;= w/29; /* Font size */&lt;span&gt;
    itemBar.style.fontSize &lt;/span&gt;= fz + &quot;px&quot;&lt;span&gt;;
  }
});

ro.observe(itemBar);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;难道不比使用脚本好吗？ResizeObserver更好。这是显示的GIF：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/35163/202005/35163-20200513135402690-1978834044.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;视窗单位&lt;/h3&gt;
&lt;p&gt;因为值大小的改变是流畅，所以我使用了视窗单位。使用它时，请不要忘记设置字体的最大值，以免在大屏幕上显得太大。&lt;/p&gt;
&lt;p&gt;我使用了一个&lt;a href=&quot;https://pxtovw.dev-calc.space/&quot; target=&quot;_blank&quot;&gt;工具&lt;/a&gt;将像素值转换为视窗单位。它是基于视窗宽度和字体大小（以像素为单位）工作的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/35163/202005/35163-20200513140330623-1302066710.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我还使用它将文本与其对应的数字对齐。我使用CSS Calc()组合了&lt;code&gt;vw&lt;/code&gt;和vh值，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.elem &lt;/span&gt;{&lt;span&gt;
    position&lt;/span&gt;:&lt;span&gt; relative&lt;/span&gt;;&lt;span&gt;
    bottom&lt;/span&gt;:&lt;span&gt; calc(-2vw - 9vh)&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/35163/202005/35163-20200513142049698-846569039.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;可变字体&lt;/h3&gt;
&lt;p&gt;这是网络上最令人兴奋和最有用的功能之一。在布局中，我考虑过使用可变字体来改变调整字的粗细。&lt;/p&gt;
&lt;p&gt;最初，我为字体的宽度和粗细定义了两个CSS变量。然后，我用它来定义&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-variation-settings&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;font-variation-settings&lt;/code&gt;&lt;/a&gt;的值。如果您好奇的话，&lt;a href=&quot;https://developers.google.com/web/fundamentals/design-and-ux/typography/variable-fonts&quot; target=&quot;_blank&quot;&gt;这&lt;/a&gt;是有关可变字体的精彩介绍。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;:root &lt;/span&gt;{&lt;span&gt;
  --width&lt;/span&gt;:&lt;span&gt; 100&lt;/span&gt;;&lt;span&gt;
  --weight&lt;/span&gt;:&lt;span&gt; 500&lt;/span&gt;;
}&lt;span&gt;

.num &lt;/span&gt;{&lt;span&gt;
    font-variation-settings&lt;/span&gt;:&lt;span&gt; 'wdth' var(--width), 'wght' var(--weight)&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为了控制调整大小的变量，我为此使用了ResizeObserver。字体粗细将根据其父元素进行更改。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
const ro_2 = &lt;span&gt;new&lt;/span&gt; ResizeObserver(entries =&amp;gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (let entry of entries) {
    let w &lt;/span&gt;=&lt;span&gt; entry.contentRect.width;
    let wdth &lt;/span&gt;= parseInt(getComputedStyle(document.documentElement).getPropertyValue('--width'&lt;span&gt;));
    let f &lt;/span&gt;= wdth +&lt;span&gt; w;
    document.documentElement.style.setProperty(&lt;/span&gt;'--weight', w*1.5&lt;span&gt;);
  }
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/35163/202005/35163-20200513143502049-272371772.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在网格中自身对齐&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/35163/202005/35163-20200513143559231-2124822661.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;署名（右边的突出显示）应在横条和杂志设计末端之间的中间。&lt;/p&gt;
&lt;p&gt;起初，我认为简单的上边距就能解决问题，因此我加了以下内容。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.item-byline &lt;/span&gt;{&lt;span&gt;
    margin-top&lt;/span&gt;:&lt;span&gt; -100%&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这种情况下，边距等于项目的宽度。没用！而不是将项目推到顶部，就像加了&lt;code&gt;padding&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/35163/202005/35163-20200513143709225-1757932489.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于该行是网格项，因此我应该将对齐方式从默认更改为&lt;code&gt;start&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.item-byline &lt;/span&gt;{&lt;span&gt;
    margin-top&lt;/span&gt;:&lt;span&gt; -100%&lt;/span&gt;;&lt;span&gt;
    align-self&lt;/span&gt;:&lt;span&gt; start&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/35163/202005/35163-20200513143746596-486223783.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最终效果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/35163/202005/35163-20200513164328184-2019540483.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 14 May 2020 00:02:00 +0000</pubDate>
<dc:creator>css design</dc:creator>
<og:description>与以往的Web布局不同的杂志布局，原文地址&amp;#160;Highlights From Building a Magazine Layout&amp;#160;25 Nov 2019 一个杂志的照片 时至今日，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/css/p/12881168.html</dc:identifier>
</item>
<item>
<title>一文带你了解Spring核心接口Ordered的实现及应用 - 经典鸡翅</title>
<link>http://www.cnblogs.com/jichi/p/12884915.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jichi/p/12884915.html</guid>
<description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;最近在看框架的时候，发现了这个接口，在此进行总结，希望能够给大家帮助，同时提升自己。&lt;/p&gt;
&lt;h3 id=&quot;order接口的大体介绍&quot;&gt;order接口的大体介绍&lt;/h3&gt;
&lt;p&gt;Spring框架中有这个一个接口，名字叫Ordered，联想我们在数据库中应用的Ordered，很容易想到它的含义就是用来排序。那么问题来了，Spring中为什么要定义这样一个排序接口呢。我们知道spring框架使用了大量的策略设计模式。策略设计模式意味着我们的同一个接口，会有大量的不同实现。那么这么多实现，先执行哪个，后执行哪个呢。这就产生了一个排序和优先级的问题，于是Ordered接口登场，用来解决这一问题。&lt;/p&gt;
&lt;h3 id=&quot;ordered接口的正式介绍&quot;&gt;ordered接口的正式介绍&lt;/h3&gt;
&lt;p&gt;首先我们通过spring的源码看一下Ordered接口，源码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public interface Ordered {
  
    int HIGHEST_PRECEDENCE = -2147483648;

    int LOWEST_PRECEDENCE = 2147483647;

    int getOrder();
  
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上述代码中，我们可以看到ordered接口的实现是非常简单的。有一个最高的优先级和一个最低的优先级，还提供了一个获得当前实现类的order数值的方法。&lt;br/&gt;spring的order中。越小的值，优先级越高，越大的值优先级越低。&lt;/p&gt;
&lt;h3 id=&quot;ordered接口的应用&quot;&gt;ordered接口的应用&lt;/h3&gt;
&lt;p&gt;介绍完ordered接口之后，我们来看一下实际的应用场景。&lt;br/&gt;有一个典型的场景，我们知道spring的事务管理是通过aop切面来实现的。当我们自己写aop实现的时候，与事务的切面同时切到了一段代码。那么spring应该先执行谁呢。举一个具体的例子，我们写了一个切换数据源的aspect切面。如果说事务的执行在数据源切换的前面，那么切换数据源就失败了。我们肯定希望先执行切换数据源，再执行事务。&lt;br/&gt;于是ordered的应用场景就来了。&lt;br/&gt;假设我们写一个下面的切面。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Component
@Aspect
public class ChangeDataBase implements Ordered {
    
    //拦截所有的service操作
    @Pointcut(&quot;execution( * com.color.*.service.*.*(..))&quot;)
    public void point() {
    }
 
    @Before(&quot;point()&quot;)
    public void onlyReadPre() {
        DataSourceContextHolder.setDataSourceType(DataSourceType.MYSQL);
        System.out.println(&quot;数据库切换MYSQL&quot;);
    }
 
    @After(&quot;point()&quot;)
    public void onlyReadPast() {
        DataSourceContextHolder.setDataSourceType(DataSourceType.ORACLE);
        System.out.println(&quot;数据库切换回ORACLE&quot;);
    }
 
    @Override
    public int getOrder() {
        return 1;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上述代码中，我们定义了一个切点，用于拦截所有的service的方法。然后再方法执行前，我们将数据库切换到mysql，方法执行之后，数据库切换成oracle。&lt;br/&gt;最后重写了ordered接口的getOrder方法。这里我们设置order的级别为1。&lt;br/&gt;这个时候，我们在配置事务切面的时候。在xml中配置order。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot; order=&quot;2&quot;/&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果是使用注入bean的方式的话，直接实现接口和上方一样使用即可。&lt;br/&gt;这个时候，我们就会发现。切换数据源的方法会永远在事务之前执行，这就实现了我们的目的。&lt;/p&gt;
&lt;h3 id=&quot;order注解的使用&quot;&gt;order注解的使用&lt;/h3&gt;
&lt;p&gt;读到现在的读者在想，还要实现接口感觉好麻烦啊，有没有什么更方便的方法呢。当然有，我们介绍一下@Order注解。&lt;br/&gt;还是先看一下order注解的源码。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.TYPE, ElementType.METHOD, ElementType.FIELD})
@Documented
public @interface Order {
    int value() default 2147483647;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;默认的优先级是最小的。&lt;br/&gt;我们在使用的时候，只要在类上面打上order注解即可。&lt;br/&gt;我们模拟两个类，打上order注解，然后再spring容器启动的时候，对类进行空参构造函数加载，通过空参构造函数里面的打印情况，我们就可以看到类初始化和执行的顺序。&lt;br/&gt;建立我们的第一个order类。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Component 
 
//使用order属性，设置该类在spring容器中的加载顺序
@Order(1)  
public class Order1 {
     
    private final int ORDERED = 1;
     
    public Order1(){
        System.out.println(this);
    }
  
    @Override
    public String toString() {
        return &quot;Order1 is  loaded @ORDERED=&quot; + ORDERED + &quot;]&quot;;
    }
 
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;建立我们的第二个order类。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Component 
 
//使用order属性，设置该类在spring容器中的加载顺序
@Order(2)  
public class Order2 {
     
    private final int ORDERED = 2;
     
    public Order2(){
        System.out.println(this);
    }
  
    @Override
    public String toString() {
        return &quot;Order2 is  loaded @ORDERED=&quot; + ORDERED + &quot;]&quot;;
    }
 
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动spring容器之后，我们看到控制台执行如下结果。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Order1 is  loaded @ORDERED=1]
Order2 is  loaded @ORDERED=2]
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;ordercomparator的介绍&quot;&gt;orderComparator的介绍&lt;/h3&gt;
&lt;p&gt;那么我们假如想知道一个类的order的值，或者想比较两个类的order值谁大谁小，这个时候要如何操作呢，Spring贴心的给我们提供了一个类。OrderComparator，通过这个类，我们获得实例后，使用它所提供的getOrder或者compare方法即可实现上述的需求。&lt;br/&gt;我们照例还是先来看一下源码。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class OrderComparator implements Comparator&amp;lt;Object&amp;gt; {
    public static final OrderComparator INSTANCE = new OrderComparator();

    public OrderComparator() {
    }

    public Comparator&amp;lt;Object&amp;gt; withSourceProvider(OrderComparator.OrderSourceProvider sourceProvider) {
        return (o1, o2) -&amp;gt; {
            return this.doCompare(o1, o2, sourceProvider);
        };
    }

    public int compare(@Nullable Object o1, @Nullable Object o2) {
        return this.doCompare(o1, o2, (OrderComparator.OrderSourceProvider)null);
    }

    private int doCompare(@Nullable Object o1, @Nullable Object o2, @Nullable OrderComparator.OrderSourceProvider sourceProvider) {
        boolean p1 = o1 instanceof PriorityOrdered;
        boolean p2 = o2 instanceof PriorityOrdered;
        if (p1 &amp;amp;&amp;amp; !p2) {
            return -1;
        } else if (p2 &amp;amp;&amp;amp; !p1) {
            return 1;
        } else {
            int i1 = this.getOrder(o1, sourceProvider);
            int i2 = this.getOrder(o2, sourceProvider);
            return Integer.compare(i1, i2);
        }
    }

    private int getOrder(@Nullable Object obj, @Nullable OrderComparator.OrderSourceProvider sourceProvider) {
        Integer order = null;
        if (obj != null &amp;amp;&amp;amp; sourceProvider != null) {
            Object orderSource = sourceProvider.getOrderSource(obj);
            if (orderSource != null) {
                if (orderSource.getClass().isArray()) {
                    Object[] sources = ObjectUtils.toObjectArray(orderSource);
                    Object[] var6 = sources;
                    int var7 = sources.length;

                    for(int var8 = 0; var8 &amp;lt; var7; ++var8) {
                        Object source = var6[var8];
                        order = this.findOrder(source);
                        if (order != null) {
                            break;
                        }
                    }
                } else {
                    order = this.findOrder(orderSource);
                }
            }
        }

        return order != null ? order.intValue() : this.getOrder(obj);
    }

    protected int getOrder(@Nullable Object obj) {
        if (obj != null) {
            Integer order = this.findOrder(obj);
            if (order != null) {
                return order.intValue();
            }
        }

        return 2147483647;
    }

    @Nullable
    protected Integer findOrder(Object obj) {
        return obj instanceof Ordered ? ((Ordered)obj).getOrder() : null;
    }

    @Nullable
    public Integer getPriority(Object obj) {
        return null;
    }

    public static void sort(List&amp;lt;?&amp;gt; list) {
        if (list.size() &amp;gt; 1) {
            list.sort(INSTANCE);
        }

    }

    public static void sort(Object[] array) {
        if (array.length &amp;gt; 1) {
            Arrays.sort(array, INSTANCE);
        }

    }

    public static void sortIfNecessary(Object value) {
        if (value instanceof Object[]) {
            sort((Object[])((Object[])value));
        } else if (value instanceof List) {
            sort((List)value);
        }

    }

    @FunctionalInterface
    public interface OrderSourceProvider {
        @Nullable
        Object getOrderSource(Object var1);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们先来重点看一下doCompare方法。判断逻辑如下：&lt;br/&gt;若对象o1是Ordered接口类型，o2是PriorityOrdered接口类型，那么o2的优先级高于o1&lt;br/&gt;若对象o1是PriorityOrdered接口类型，o2是Ordered接口类型，那么o1的优先级高于o2&lt;br/&gt;其他情况，若两者都是Ordered接口类型或两者都是PriorityOrdered接口类型，调用Ordered接口的getOrder方法得到order值，order值越大，优先级越小&lt;br/&gt;那么一句话来说就是这样的。&lt;br/&gt;OrderComparator比较器进行排序的时候，若2个对象中有一个对象实现了PriorityOrdered接口，那么这个对象的优先级更高。&lt;br/&gt;若2个对象都是PriorityOrdered或Ordered接口的实现类，那么比较Ordered接口的getOrder方法得到order值，值越低，优先级越高。&lt;/p&gt;
&lt;p&gt;再来看一下getOrder方法。&lt;br/&gt;传入一个对象后，通过provider取得原始对象。如果不为空，继续进行判断。&lt;br/&gt;如果是数组对象，对对象进行遍历，得到order后，跳出。如果不是数组则直接获得对象的order。&lt;br/&gt;最后如果order如果不是空，直接返回order的int值，为空的时候，通过findOrder查看，返回的是order的最大值，也就是最低优先级。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;protected int getOrder(@Nullable Object obj) {
        if (obj != null) {
            Integer order = this.findOrder(obj);
            if (order != null) {
                return order.intValue();
            }
        }

        return 2147483647;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;至此 ordered相关的东西就介绍到此为止，文中难免有不足，希望大家提出指正，感谢。&lt;/p&gt;
</description>
<pubDate>Thu, 14 May 2020 00:00:00 +0000</pubDate>
<dc:creator>经典鸡翅</dc:creator>
<og:description>前言 最近在看框架的时候，发现了这个接口，在此进行总结，希望能够给大家帮助，同时提升自己。 order接口的大体介绍 Spring框架中有这个一个接口，名字叫Ordered，联想我们在数据库中应用的O</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jichi/p/12884915.html</dc:identifier>
</item>
<item>
<title>这份书单会告诉你，Java网络编程其实很重要 - 程序员书单</title>
<link>http://www.cnblogs.com/AntCoder/p/12886194.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/AntCoder/p/12886194.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1813797/202005/1813797-20200514074440268-833001464.jpg&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; title=&quot;点击并拖拽以移动&quot;/&gt;​&lt;/p&gt;
&lt;p&gt;Java工程师往往容易忽视的一块知识点，其实就是Java网络编程，为什么呢，因为如果我想写一个Java Web项目，我只要用SSM就可以轻松搞定，写好我们的controller、service和dao就可以了，也就是只需要关心业务逻辑，不需要关心前端请求的路由、甚至是后端的负载均衡和网络请求处理，因为这些东西很多时候都被Nginx和Tomcat给吃掉了，Nginx帮我们做好了负载均衡，Tomcat则帮我们完成TCP连接的建立，HTTP请求的处理，把所有复杂的技术细节都给屏蔽了。&lt;/p&gt;
&lt;p&gt;不过随着技术发展和更迭，大公司对于人才的要求也越来越高，对于高并发服务端编程能力的要求也在提高，比如在直播、实时通讯、游戏服务端开发等技术领域，通信协议和网络编程就成为了很重要的一个技术课题，相应的在Java领域，我们就必须要了解NIO、Linux epoll以及Netty等和网络通信相关的技术。如果你想做基础技术研发，比如消息队列、RPC框架的研发，那么网络编程也是必备的基础能力。&lt;/p&gt;
&lt;p&gt;那么今天我们就借此机会，来介绍几本关于Java网络编程方面的优质书籍，以帮助大家更好地掌握这方面的知识，我们将从Java Web出发，依次介绍NIO网络编程、Tomcat的设计原理，以及Netty这类通信编程框架领域的权威书籍。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Java网络编程系列书单&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyOTk5NDQwOA==&amp;amp;mid=2247490272&amp;amp;idx=5&amp;amp;sn=aea711739ef0d46b4233e612963d36ff&amp;amp;chksm=fa59dd27cd2e5431f1dc183d7ef6fa2bd6a5ae9a6c99e98fa9bc92ec1c3fb007f745445f8300&amp;amp;scene=21#wechat_redirect&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1813797/202005/1813797-20200514074440534-1408346306.jpg&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;img src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; title=&quot;点击并拖拽以移动&quot;/&gt;​&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;深入分析JavaWeb技术内幕&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;点击书籍图片即可查看对应思维导图！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这本书是Java Web的集大成之作，涵盖了大部分Java Web开发的知识点，作者是资深的淘宝Java工程师，恨不得在一本书里把所有的Java Web知识点丢给讲清楚，不过，一本书显然无法把所有细节都讲完，但是作为Java Web的入门或者进阶书籍来看的话还是很不错的。&lt;/p&gt;
&lt;p&gt;Java网络编程其实和Java web息息相关，Java Web的技术其实很大程度上都是基于Java网络编程来实现的，只不过Tomcat已经把网络编程的事情做好了，于是你需要做的就是通过spring等一些Javaweb框架来完成业务代码的开发。但如果想要深入了解Java网络编程，光会这些还不够。这本书不仅介绍了JavaWeb技术栈的核心内容，也可以帮助我们打开Java网络编程世界的大门，&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;作者介绍：&lt;/p&gt;
&lt;p&gt;许令波，毕业于合肥工业大学，获计算机硕士学位。热爱Java Web技术，关注服务端性能优化，热衷开源技术的研究和分享，曾获developerWorks最佳作者称号。2009年进入淘宝工作，目前从事模板渲染框架与MVC框架的开发与应用、Java Web的性能优化、高访问量系统静态化和商品详情系统的业务改造等工作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyOTk5NDQwOA==&amp;amp;mid=2247490343&amp;amp;idx=3&amp;amp;sn=f35ac0728158b8c8dad52836285960bc&amp;amp;chksm=fa59dce0cd2e55f674207cda9b7b10b9e0242a45fe10a635b955e7a15d8a819482473cfbb712&amp;amp;scene=21#wechat_redirect&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1813797/202005/1813797-20200514074440729-429981387.jpg&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;img src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; title=&quot;点击并拖拽以移动&quot;/&gt;​&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NIO与socket编程技术指南&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;点击书籍图片即可查看对应思维导图！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;想要学习Java网络编程，首先你应该学的就是socket和NIO，在过去，Java还没有NIO的时代，我们使用socket建立连接，用BIO也就是阻塞IO来完成服务端的网络编程，后来NIO出现了以后，基于NIO的各种框架和Web容器也逐渐更新换代，比如netty网络编程框架，Tomcat容器等，都是用了NIO技术，了解了NIO，就是了解网络编程的第一步，而这也是一切Java网络编程框架的核心技术。&lt;/p&gt;
&lt;p&gt;这本书主要介绍Java语言中高性能处理的原理技术：NIO和Socket。非常详细地讲解了NIO中的缓冲区、通道、选择器、编码，以及使用Socket技术实现TCP/IP和UDP编程，这对理解基于NIO和Socket技术为基础所开发的NIO框架是非常有好处的，在互联网技术日新月异的时代，Netty以及Kafka等这些高性能处理框架都在底层应用到了NIO和Socket，所以当你目前是有计划进军互联网技术时，本书也许会带给你一个方向。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;h3 id=&quot;作者简介&quot;&gt;作者简介&lt;/h3&gt;
&lt;p&gt;高洪岩，某世界500强项目经理，有10年Java相关开发经验，精通Java语言，擅长J2EE、EJB、Android、报表和多线程，以及并发相关的技术内容，理论与实践经验颇丰。著有《Java多线程编程核心技术》《Java并发编程：核心方法与框架》《NIO与Socket编程技术指南》《Java EE核心框架实战 第2版》《Jasper Reports+iReport报表开发详解》《Android学习精要》等书籍。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyOTk5NDQwOA==&amp;amp;mid=2247490343&amp;amp;idx=4&amp;amp;sn=726eb273e565404ed1ee3ecd184701d6&amp;amp;chksm=fa59dce0cd2e55f6aef7cf31376b8b032069916b3ce2ccd76dac018525b70d5416cb3c67f74e&amp;amp;scene=21#wechat_redirect&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1813797/202005/1813797-20200514074440869-17355995.jpg&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;img src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; title=&quot;点击并拖拽以移动&quot;/&gt;​&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tomcat架构解析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;点击书籍图片即可查看对应思维导图！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;作为一个Java工程师，想必你对于Tomcat这个web容器并不陌生，毕竟我们开发的大部分web应用都要运行在这只猫上面，那么你是否思考过，为什么Tomcat可以做到这一切呢，为什么不是你写好业务代码，直接在本地或者云端直接运行和部署，而是需要运行在一个Web容器上呢。其实Tomcat就是帮你把客户端发来的Web请求准确地投放到每个控制器上，如果你想要更深入了解其中原理，那么这本书可能值得你一读。&lt;/p&gt;
&lt;p&gt;这本书全面介绍了Tomcat的架构、各组件的实现方案以及使用方式，主要包括Tomcat的基础组件架构以及工作原理，Tomcat各组件的实现方案、使用方式以及详细配置说明，Tomcat与Web服务器集成以及性能优化，Tomcat部分扩展特性介绍等，市面上关于Tomcat的书确实不多，这本书值得推荐。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;h3 id=&quot;作者简介-2&quot;&gt;作者简介&lt;/h3&gt;
&lt;p&gt;刘光瑞，北京窝客研发总监，负责窝客产品研发管理及总体架构设计。拥有十几年的企业级大型业务系统研发架构经验，成功带领团队设计并研发基于Tomcat的组件化微服务架构。2007年在四达软件担任高级架构师，主导了数个省份的广播电视省网业务运营支撑系统的架构设计及优化工作。2012年在电讯盈科担任高级技术顾问，参与了中国移动供应链系统的架构及研发。在应用系统架构及性能优化方面积累了丰富的经验。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyOTk5NDQwOA==&amp;amp;mid=2247490343&amp;amp;idx=6&amp;amp;sn=faf28bc70ad5b4b878d0b040ade83cc4&amp;amp;chksm=fa59dce0cd2e55f6a59e2cf719e00c0cdfb4253c117e718ec82a38949f4352f6fb4ef8c6afae&amp;amp;scene=21#wechat_redirect&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1813797/202005/1813797-20200514074441030-1360966507.jpg&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;img src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; title=&quot;点击并拖拽以移动&quot;/&gt;​&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;netty权威指南&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;点击书籍图片即可查看对应思维导图！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;讲完了Tomcat，接下来就到知名的异步网络编程框架netty了，netty其实就是一个对NIO进行包装的开源网络编程框架，它不需要你基于NIO去开发复杂的网络应用程序，而是直接通过一套非常易于使用的API直接把最实用的功能提供给开发者，像平时的业务开发工程师其实对于这类框架接触并不会太多，反而是做中间件、底层开发的同学会对这些东西更加关注，如果你有兴趣学习netty，那么这本书是一个不错的选择。&lt;/p&gt;
&lt;p&gt;《Netty 权威指南（第2 版）》是异步非阻塞通信领域的经典之作，基于全新版本的Netty 5.0 编写，是国内首本深入介绍Netty 原理和架构的书籍，也是作者多年实战经验的总结和浓缩，内容不仅包含Java NIO入门知识、Netty 的基础功能开发指导、编解码框架定制等，还包括私有协议栈定制和开发、Netty 核心类库源码分析，以及Netty 的架构剖析。&lt;/p&gt;
&lt;blockquote&gt;
&lt;h3 id=&quot;作者简介-3&quot;&gt;作者简介&lt;/h3&gt;
&lt;h3 id=&quot;李林峰，netty中国推广者，现华为技术有限公司平台中间件架构与设计部设计师，公司总裁技术创新奖获得者。长期从事高性能通信软件的架构设计和开发工作，有多年在nio领域的设计、开发和运维经验，精通nio编程和netty、mina等主流nio框架。&quot;&gt;李林峰，Netty中国推广者，现华为技术有限公司平台中间件架构与设计部设计师，公司总裁技术创新奖获得者。长期从事高性能通信软件的架构设计和开发工作，有多年在NIO领域的设计、开发和运维经验，精通NIO编程和Netty、Mina等主流NIO框架。&lt;/h3&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果想看更多技术好书，可以关注微信公众号【程序员书单】作者黄小斜，目前是阿里Java工程师，业余时间广泛读书，在公众号里除了分享程序员必读的技术书籍之外，也会推荐很多关于个人成长、投资理财等方面的书籍。你烦恼的每个问题，书中都有答案。**&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;在这里，我们将为你推荐帮助程序员以及互联网从业者自我提升的各类好书、优质学习资源和工具，每周pick精品书单，解读经典书籍。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1813797/202005/1813797-20200514074441276-673386141.jpg&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; title=&quot;点击并拖拽以移动&quot;/&gt;​&lt;/p&gt;
</description>
<pubDate>Wed, 13 May 2020 23:45:00 +0000</pubDate>
<dc:creator>程序员书单</dc:creator>
<og:description>​ Java工程师往往容易忽视的一块知识点，其实就是Java网络编程，为什么呢，因为如果我想写一个Java Web项目，我只要用SSM就可以轻松搞定，写好我们的controller、service和d</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/AntCoder/p/12886194.html</dc:identifier>
</item>
<item>
<title>配置类为什么要添加@Configuration注解呢？ - 程序员DMZ</title>
<link>http://www.cnblogs.com/daimzh/p/12886161.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/daimzh/p/12886161.html</guid>
<description>&lt;p&gt;本系列文章将会带你一行行的将Spring的源码吃透，做到彻底精通Spring&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;380.72277511049&quot;&gt;
&lt;p&gt;配置类为什么要添加@Configuration注解呢？&lt;/p&gt;
&lt;blockquote readability=&quot;6.4421052631579&quot;&gt;
&lt;p&gt;&lt;strong&gt;本系列文章：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_41907991/article/details/105667900&quot;&gt;读源码，我们可以从第一行读起&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_41907991/article/details/105743462&quot;&gt;你知道Spring是怎么解析配置类的吗？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;推荐阅读：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_41907991/article/details/105502255&quot;&gt;Spring官网阅读 | 总结篇&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_41907991/category_9808373.html&quot;&gt;Spring杂谈&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本系列文章将会带你一行行的将Spring的源码吃透，推荐阅读的文章是阅读源码的基础！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们先来看看如果不在配置类上添加@Configuration注解会有什么问题，代码示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@ComponentScan(&quot;com.dmz.source.code&quot;)
//@Configuration
public class Config{
        @Bean
        public A a(){
        return new A(dmzService());
        }

        @Bean
        public DmzService dmzService(){
                return new DmzService();
        }
}

public class A {
        public A(DmzService dmzService){
                System.out.println(&quot;create A by dmzService&quot;);
        }
}

@Component
public class DmzService {
        public DmzService(){
                System.out.println(&quot;create dmzService&quot;);
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不添加@Configuration注解运行结果:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;create dmzService
create A by dmzService
create dmzService
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;添加@Configuration注解运行结果:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;create dmzService
create A by dmzService
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上面的例子中，我们会发现没有添加@Configuraion注解时&lt;code&gt;dmzService&lt;/code&gt;被创建了两次， 这是因为第一次创建是被Spring容器所创建的，Spring调用这个dmzService()创建了一个Bean被放入了单例池中（没有添加其它配置默认是单例的），第二次创建是Spring容器在创建a时调用了a()，而a()又调用了dmzService()方法。&lt;/p&gt;
&lt;p&gt;这样的话，就出现问题了。&lt;/p&gt;
&lt;p&gt;第一，对于dmzService而言，它被创建了两次，单例被打破了&lt;/p&gt;
&lt;p&gt;第二，对于a而言，它所依赖的dmzService不是Spring所管理的，而是直接调用的一个普通的java method创建的普通对象。这个对象不被Spring所管理意味着，首先它的&lt;strong&gt;域（Scope）定义失效了&lt;/strong&gt;，&lt;strong&gt;其次它没有经过一个完整的生命周期，那么我们所定义所有的Bean的后置处理器都没有作用到它身上，其中就包括了完成AOP的后置处理器，所以AOP也失效了&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;上面的分析不能说服你的话，我们可以看看官方在@Bean上给出的这一段注释&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vd3hfY2MzNDdiZTY5Ni9ibG9nSW1hZ2UvcmF3L21hc3Rlci9iZWFuMi5wbmc?x-oss-process=image/format,png&quot; alt=&quot;bean2&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先，Spring就在注释中指出了，&lt;strong&gt;通常来说，BeanMethod一般都申明在一个被@Configuration注解标注的类中，在这种情况下，BeanMethod可能直接引用了在同一个类中申明的beanMethod&lt;/strong&gt;,就像本文给出的例子那样，a()直接引用了dmzService()，我们重点再看看划红线的部分，&lt;strong&gt;通过调用另外一个beanMethod进入的Bean的引用会被保证是遵从域定义以及AOP语义的，就像getBean所做的那样&lt;/strong&gt;。这是怎么实现的呢？在最后被红线标注的地方也有说明，是通过在运行时期为没有被@Configuration注解标注的配置类生成一个CGLIB的子类。&lt;/p&gt;

&lt;p&gt;Spring是在什么时候创建的代理呢？到目前为止我们应该没有落掉Spring整个启动流程的任何关键代码，那么我们不妨带着这个问题继续往下看。目前来说我们已经阅读到了&lt;a href=&quot;https://www.processon.com/view/link/5e022908e4b0125e291a73e0&quot;&gt;Spring执行流程图&lt;/a&gt;中的&lt;code&gt;3-5&lt;/code&gt;步，也就是&lt;code&gt;org.springframework.context.support.AbstractApplicationContext#invokeBeanFactoryPostProcessors&lt;/code&gt;方法，在之前的分析中我们已经知道了，这个方法的主要作用就是执行BeanFactoryPostProcessor中的方法，首先执行的是BeanDefinitionRegistryPostProcessor（继承了BeanFactoryPostProcessor）的&lt;code&gt;postProcessBeanDefinitionRegistry&lt;/code&gt;方法，然后执行&lt;code&gt;postProcessBeanFactory&lt;/code&gt;方法。而到目前为止我们并没有向容器中注册bean工厂的后置处理器（BeanFactoryPostProcessor），这就意味着当前容器中只有一个ConfigurationClassPostProcessor会被执行，在前文中我们已经分析过了它的&lt;code&gt;postProcessBeanDefinitionRegistry&lt;/code&gt;方法，紧接着我们就来看看它的&lt;code&gt;postProcessBeanFactory&lt;/code&gt;方法做了什么。其源码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {
   int factoryId = System.identityHashCode(beanFactory);
   // 防止重复处理
   if (this.factoriesPostProcessed.contains(factoryId)) {
       throw new IllegalStateException(
           &quot;postProcessBeanFactory already called on this post-processor against &quot; + beanFactory);
   }
   this.factoriesPostProcessed.add(factoryId);
   // 在执行postProcessBeanDefinitionRegistry方法的时就已经将这个id添加到registriesPostProcessed集合中了
   if (!this.registriesPostProcessed.contains(factoryId)) {
       processConfigBeanDefinitions((BeanDefinitionRegistry) beanFactory);
   }
        // 看起来这个方法就是完成了代理
   enhanceConfigurationClasses(beanFactory);
   // 添加了一个后置处理器
   beanFactory.addBeanPostProcessor(new ImportAwareBeanPostProcessor(beanFactory));
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;       public void enhanceConfigurationClasses(ConfigurableListableBeanFactory beanFactory) {          // map中放置的是所有需要被代理的类
                Map&amp;lt;String, AbstractBeanDefinition&amp;gt; configBeanDefs = new LinkedHashMap&amp;lt;&amp;gt;();
                for (String beanName : beanFactory.getBeanDefinitionNames()) {
                        BeanDefinition beanDef = beanFactory.getBeanDefinition(beanName);
                        if (ConfigurationClassUtils.isFullConfigurationClass(beanDef)) {
                                // 省略异常跟日志代码....
               // 这个代码的含义就是如果是一个被@Configuration注解标注的类,那么将其放入到configBeanDefs这个集合中
                                configBeanDefs.put(beanName, (AbstractBeanDefinition) beanDef);
                        }
                }
       
                if (configBeanDefs.isEmpty()) {
                        // nothing to enhance -&amp;gt; return immediately
                        return;
                }
                
       // 对配置类进行代理的核心类
                ConfigurationClassEnhancer enhancer = new ConfigurationClassEnhancer();
                for (Map.Entry&amp;lt;String, AbstractBeanDefinition&amp;gt; entry : configBeanDefs.entrySet()) {
                        AbstractBeanDefinition beanDef = entry.getValue();
                        // 对于配置类永远使用cglib代理
                        beanDef.setAttribute(AutoProxyUtils.PRESERVE_TARGET_CLASS_ATTRIBUTE, Boolean.TRUE);
                        try {
                                // cglib代理是基于类实现的,所以在这之前要明确代理的类是什么
                                Class&amp;lt;?&amp;gt; configClass = beanDef.resolveBeanClass(this.beanClassLoader);
                                if (configClass != null) {
                   // 通过ConfigurationClassEnhancer获取到一个经过代理的class
                                        Class&amp;lt;?&amp;gt; enhancedClass = enhancer.enhance(configClass, this.beanClassLoader);
                  // 省略日志....
                   
                   // 将原有的配置类的bd中的beanClass属性替换成代理后的class
                                                beanDef.setBeanClass(enhancedClass);
                                        }
                                }
                        }
                        catch (Throwable ex) {
                                throw new IllegalStateException(&quot;Cannot load configuration class: &quot; + beanDef.getBeanClassName(), ex);
                        }
                }
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码非常简单,核心的代码在&lt;code&gt;ConfigurationClassEnhancer&lt;/code&gt;中,所以我们要分析下&lt;code&gt;ConfigurationClassEnhancer&lt;/code&gt;的源码,在分析它的源码前,我们需要对cglib有一定的了解。&lt;/p&gt;
&lt;h2 id=&quot;1、cglib原理分析&quot;&gt;1、cglib原理分析&lt;/h2&gt;
&lt;h3 id=&quot;11、使用示例&quot;&gt;1.1、使用示例&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Target{
   public void f(){
       System.out.println(&quot;Target f()&quot;);
   }
   public void g(){
       System.out.println(&quot;Target g()&quot;);
   }
}

public class Interceptor implements MethodInterceptor {
   @Override
   public Object intercept(Object obj, Method method, Object[] args,    MethodProxy proxy) throws Throwable {
       System.out.println(&quot;I am intercept begin&quot;);
//Note: 此处一定要使用proxy的invokeSuper方法来调用目标类的方法
       proxy.invokeSuper(obj, args);
       System.out.println(&quot;I am intercept end&quot;);
       return null;
   }
}

public class Test {
   public static void main(String[] args) {
       // 设置这个属性，将代理类的字节码文件生成到F盘的code目录下
   System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, &quot;F:\\code&quot;);
        //实例化一个增强器，也就是cglib中的一个class generator
       Enhancer eh = new Enhancer();
        //设置目标类
       eh.setSuperclass(Target.class);
       // 设置拦截对象
       eh.setCallback(new Interceptor());
       // 生成代理类并返回一个实例
       Target t = (Target) eh.create();
       t.f();
       t.g();
   }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;I am intercept begin
Target f()
I am intercept end
I am intercept begin
Target g()
I am intercept end

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;12、原理分析&quot;&gt;1.2、原理分析&lt;/h3&gt;
&lt;p&gt;查看F盘的code目录，会发现多了以下几个文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vd3hfY2MzNDdiZTY5Ni9ibG9nSW1hZ2UvcmF3L21hc3Rlci9jZ2xpYi5wbmc?x-oss-process=image/format,png&quot; alt=&quot;cglib&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中第二个文件就是我们的代理类字节码，将其直接用IDEA打开&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 省略多余的方法，我们就关注g方法
public class Target$$EnhancerByCGLIB$$788444a0 extends Target implements Factory
{
   
   final void CGLIB$g$0()
   {
     super.g();
   }
   
   // 经过代理过的g方法
   public final void g()
   {
   
   // 查看是否有拦截器存在
     MethodInterceptor tmp4_1 = this.CGLIB$CALLBACK_0;
     if (tmp4_1 == null)
     {
         CGLIB$BIND_CALLBACKS(this);
         tmp4_1 = this.CGLIB$CALLBACK_0;
     }
     
     // 如果有拦截器的存在的话，直接调用拦截器的方法
     if (this.CGLIB$CALLBACK_0 != null) {
         tmp4_1.intercept(this, CGLIB$g$0$Method, CGLIB$emptyArgs, CGLIB$g$0$Proxy);
     }
     
     // 如果没有拦截器，说明不需要代理，直接调用父类方法，也就是目标类的方法
     else{
         super.g();
     }
   }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;可以看到，代理类继承了目标类（Target），代理类为每个目标类的方法生成两个方法，例如针对目标类中的每个非private方法，代理类会生成两个方法，以g方法为例：一个是@Override的g方法，一个是CGLIB$g$0（CGLIB$g$0相当于目标类的g方法）。我们在示例代码中调用目标类的方法t.g()时，实际上调用的是代理类中的g()方法。

从这里就能看出，跟JDK动态代理不同的是，cglib代理采用的是继承的方式生成的代理对象。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上面的例子中，我们实现了对cglib中方法的拦截，但是就目前而言我们没有办法选择性的拦截目标类中的某一个方法，假设现在我们只想拦截Target中的g方法而不拦截f方法有什么方法呢？我们看下面这个例子&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Main {
        public static void main(String[] args) {
                System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, &quot;F:\\code&quot;);
                //实例化一个增强器，也就是cglib中的一个class generator
                Enhancer eh = new Enhancer();
                //设置目标类
                eh.setSuperclass(Target.class);
                // 设置拦截对象
                eh.setCallbacks(new Callback[]{new Interceptor(), NoOp.INSTANCE});
                eh.setCallbackFilter(new CallbackFilter() {
                        @Override
                        public int accept(Method method) {
                                if(method.getName().equals(&quot;g&quot;))
             // 这里返回的是上面定义的callback数组的下标，0就是我们的Interceptor对象，1是内置的NoOp对象，代表不做任何操作
                                return 0;
                                else return 1;
                        }
                });
                // 生成代理类并返回一个实例
                Target t = (Target) eh.create();
                t.f();
                t.g();
        }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Target f()
I am intercept begin
Target g()
I am intercept end

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时f方法已经不会被代理了&lt;/p&gt;
&lt;h2 id=&quot;2、configurationclassenhancer源码分析&quot;&gt;2、ConfigurationClassEnhancer源码分析&lt;/h2&gt;
&lt;h3 id=&quot;21、创建代理过程分析&quot;&gt;2.1、创建代理过程分析&lt;/h3&gt;
&lt;p&gt;在对cglib的原理有了一定了解后，我们再来看&lt;code&gt;ConfigurationClassEnhancer&lt;/code&gt;的源码就轻松多了&lt;/p&gt;
&lt;p&gt;我们就关注其中核心的几个方法，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public Class&amp;lt;?&amp;gt; enhance(Class&amp;lt;?&amp;gt; configClass, @Nullable ClassLoader classLoader) {
   // 如果已经实现了EnhancedConfiguration接口，说明被代理过了，直接返回
   if (EnhancedConfiguration.class.isAssignableFrom(configClass)) {
       return configClass;
   }
   // 否则调用newEnhancer方法先创建一个增强器，然后直接使用这个增强器生成代理类的字节码对象
   Class&amp;lt;?&amp;gt; enhancedClass = createClass(newEnhancer(configClass, classLoader));
   if (logger.isDebugEnabled()) {
       logger.debug(String.format(&quot;Successfully enhanced %s; enhanced class name is: %s&quot;,
                                  configClass.getName(), enhancedClass.getName()));
   }
   return enhancedClass;
}

private Enhancer newEnhancer(Class&amp;lt;?&amp;gt; configSuperClass, @Nullable ClassLoader classLoader) {
   Enhancer enhancer = new Enhancer();
   // 设置目标类
   enhancer.setSuperclass(configSuperClass);
   // 让代理类实现EnhancedConfiguration接口，这个接口继承了BeanFactoryAware接口
   // 主要两个作用：1.起到标记作用，如果实现了，代表已经被代理过了
   // 2.代理类需要访问BeanFactory，所有实现了BeanFactoryAware接口
   enhancer.setInterfaces(new Class&amp;lt;?&amp;gt;[] {EnhancedConfiguration.class});
   // 设置生成的代理类不实现factory接口
   enhancer.setUseFactory(false);
   // 设置代理类名称的生成策略
   enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);
   // 代理类中引入一个BeanFactory字段
   enhancer.setStrategy(new BeanFactoryAwareGeneratorStrategy(classLoader));
   // 设置过滤器，CALLBACK_FILTER中也同时设置了拦截器
   enhancer.setCallbackFilter(CALLBACK_FILTER);
   enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes());
   return enhancer;
}

// 使用增强器生成代理类的字节码对象
private Class&amp;lt;?&amp;gt; createClass(Enhancer enhancer) {
   Class&amp;lt;?&amp;gt; subclass = enhancer.createClass();
   Enhancer.registerStaticCallbacks(subclass, CALLBACKS);
   return subclass;
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;并且我们会发现，在最开始这个类就申明了三个拦截器&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 声明的三个拦截器
private static final Callback[] CALLBACKS = new Callback[] {
   new BeanMethodInterceptor(),
   new BeanFactoryAwareMethodInterceptor(),
   NoOp.INSTANCE
};

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;22、拦截器源码分析&quot;&gt;2.2、拦截器源码分析&lt;/h3&gt;
&lt;p&gt;基于我们之前对cglib的学习，肯定能知道，代理的核心逻辑就是依赖于拦截器实现的。其中&lt;code&gt;NoOp.INSTANCE&lt;/code&gt;代表什么都没做，我们就关注前面两个。&lt;/p&gt;
&lt;h4 id=&quot;beanfactoryawaremethodinterceptor&quot;&gt;BeanFactoryAwareMethodInterceptor&lt;/h4&gt;
&lt;p&gt;之所以把这个拦截器放到前面分析是因为这个拦截器的执行时机是在创建配置类的时候，其源码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private static class BeanFactoryAwareMethodInterceptor implements MethodInterceptor, ConditionalCallback {

                @Override
                @Nullable
                public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
                        // 在生成代理类的字节码时，使用了BeanFactoryAwareGeneratorStrategy策略
                        // 这个策略会在代理类中添加一个字段，BEAN_FACTORY_FIELD = &quot;$$beanFactory&quot;
                        Field field = ReflectionUtils.findField(obj.getClass(), BEAN_FACTORY_FIELD);
                        Assert.state(field != null, &quot;Unable to find generated BeanFactory field&quot;);
                        // 此时调用的方法是setBeanFactory方法，
                        // 直接通过反射将beanFactory赋值给BEAN_FACTORY_FIELD字段
                        field.set(obj, args[0]);

                        // Does the actual (non-CGLIB) superclass implement BeanFactoryAware?
                        // If so, call its setBeanFactory() method. If not, just exit.
                        // 如果目标配置类直接实现了BeanFactoryAware接口，那么直接调用目标类的setBeanFactory方法
                        if (BeanFactoryAware.class.isAssignableFrom(ClassUtils.getUserClass(obj.getClass().getSuperclass()))) {
                                return proxy.invokeSuper(obj, args);
                        }
                        return null;
                }

                @Override
                // 在调用setBeanFactory方法时才会拦截
                // 从前文我们知道，代理类是实现了实现EnhancedConfiguration接口的，
                // 这就意味着它也实现了BeanFactoryAware接口，那么在创建配置类时，
                // setBeanFactory方法就会被调用，之后会就进入到这个拦截器的intercept方法逻辑中
                public boolean isMatch(Method candidateMethod) {
                        return isSetBeanFactory(candidateMethod);
                }

                public static boolean isSetBeanFactory(Method candidateMethod) {
                        return (candidateMethod.getName().equals(&quot;setBeanFactory&quot;) &amp;amp;&amp;amp;
                                        candidateMethod.getParameterCount() == 1 &amp;amp;&amp;amp;
                                        BeanFactory.class == candidateMethod.getParameterTypes()[0] &amp;amp;&amp;amp;
                                        BeanFactoryAware.class.isAssignableFrom(candidateMethod.getDeclaringClass()));
                }
        }


&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;beanmethodinterceptor&quot;&gt;BeanMethodInterceptor&lt;/h4&gt;
&lt;p&gt;相比于上面一个拦截器，这个拦截器的逻辑就要复杂多了，我们先来看看它的执行时机，也就是isMatch方法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public boolean isMatch(Method candidateMethod) {
   // 第一个条件，不能是Object，这个必定是满足的
   // 第二个条件，不能是setBeanFactory方法，显而易见的嘛，我们要拦截的方法实际只应该是添加了@Bean注解的方法
   // 第三个条件，添加了@Bean注解
   return (candidateMethod.getDeclaringClass() != Object.class &amp;amp;&amp;amp;
           !BeanFactoryAwareMethodInterceptor.isSetBeanFactory(candidateMethod) &amp;amp;&amp;amp;
           BeanAnnotationHelper.isBeanAnnotated(candidateMethod));
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;简而言之，就是拦截@Bean标注的方法，知道了执行时机后，我们再来看看它的拦截逻辑，代码其实不是很长，但是理解起来确很不容易，牵涉到AOP以及Bean的创建了，不过放心，我会结合实例给你讲明白这段代码，下面我们先看源码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs,
                                                                MethodProxy cglibMethodProxy) throws Throwable {
                        // 之前不是给BEAN_FACTORY_FIELD这个字段赋值了BeanFactory吗，这里就是反射获取之前赋的值
                        ConfigurableBeanFactory beanFactory = getBeanFactory(enhancedConfigInstance);
                        // 确定Bean的名称
                        String beanName = BeanAnnotationHelper.determineBeanNameFor(beanMethod);

                        // Determine whether this bean is a scoped-proxy
                        // 判断这个Bean是否是一个域代理的类
                        Scope scope = AnnotatedElementUtils.findMergedAnnotation(beanMethod, Scope.class);
                        // 存在@Scope注解，并且开启了域代理模式
                        if (scope != null &amp;amp;&amp;amp; scope.proxyMode() != ScopedProxyMode.NO) {
                                String scopedBeanName = ScopedProxyCreator.getTargetBeanName(beanName);
                                // 域代理对象的目标对象正在被创建,什么时候会被创建？当然是使用的时候嘛
                                if (beanFactory.isCurrentlyInCreation(scopedBeanName)) {
                                        // 使用的时候调用@Bean方法来创建这个域代理的目标对象，所以@Bean方法代理的时候针对的是域代理的目标对象，目标对象需要通过getBean的方式创建
                                        beanName = scopedBeanName;
                                }
                        }

                        // 判断这个bean是否是一个factoryBean
                        if (factoryContainsBean(beanFactory, BeanFactory.FACTORY_BEAN_PREFIX + beanName) &amp;amp;&amp;amp;
                                        factoryContainsBean(beanFactory, beanName)) {
                                Object factoryBean = beanFactory.getBean(BeanFactory.FACTORY_BEAN_PREFIX + beanName);
                                if (factoryBean instanceof ScopedProxyFactoryBean) {
                                        // ScopedProxyFactoryBean还记得吗？在进行域代理时使用的就是这个对象
                                        // 对于这个FactoryBean我们是不需要进行代理的，因为这个factoryBean的getObject方法
                                        // 只是为了得到一个类似于占位符的Bean,这个Bean只是为了让依赖它的Bean在创建的过程中不会报错
                                        // 所以对于这个FactoryBean我们是不需要进行代理的
                                        // 我们只需要保证这个FactoryBean所生成的代理对象的目标对象是通过getBean的方式创建的即可
                                } else {
                                        // 而对于普通的FactoryBean我们需要代理其getObject方法，确保getObject方法产生的Bean是通过getBean的方式创建的
                                        // It is a candidate FactoryBean - go ahead with enhancement
                                        return enhanceFactoryBean(factoryBean, beanMethod.getReturnType(), beanFactory, beanName);
                                }
                        }
                        // 举个例子，假设我们被@Bean标注的是A方法，当前创建的BeanName也是a，这样就符合了这个条件
                        // 但是如果是这种请求，a(){b()},a方法中调用的b方法，那么此时调用b方法创建b对象时正在执行的就是a方法
                        // 此时就不满足这个条件，会调用这个resolveBeanReference方法来解决方法引用
                        if (isCurrentlyInvokedFactoryMethod(beanMethod)) {
                                // 如果当前执行的方法就是这个被拦截的方法，（说明是在创建这个Bean的过程中）
                                // 那么直接执行目标类中的方法，也就是我们在配置类中用@Bean标注的方法
                                return cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs);
                        }
   // 说明不是在创建中了，而是别的地方直接调用了这个方法，这时候就需要代理了，实际调用getBean方法
   return resolveBeanReference(beanMethod, beanMethodArgs, beanFactory, beanName);

&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;               private Object resolveBeanReference(Method beanMethod, Object[] beanMethodArgs,
                                                                                        ConfigurableBeanFactory beanFactory, String beanName) {

                        // The user (i.e. not the factory) is requesting this bean through a call to
                        // the bean method, direct or indirect. The bean may have already been marked
                        // as 'in creation' in certain autowiring scenarios; if so, temporarily set
                        // the in-creation status to false in order to avoid an exception.
                        // 什么时候会是alreadyInCreation？就是正在创建中，当Spring完成扫描后得到了所有的BeanDefinition
                        // 那么之后就会遍历所有的BeanDefinition，根据BeanDefinition一个个的创建Bean，在创建Bean前会将这个Bean
                        // 标记为正在创建的，如果是正在创建的Bean,先将其标记为非正在创建，也就是这行代码beanFactory.setCurrentlyInCreation(beanName, false)
                        // 这是因为之后又会调用getBean方法，如果已经被标记为创建中了，那么在调用getBean时会报错
                        boolean alreadyInCreation = beanFactory.isCurrentlyInCreation(beanName);
                        try {
               // 如果是正在创建的Bean,先将其标记为非正在创建，避免后续调用getBean时报错
                                if (alreadyInCreation) {
                                        beanFactory.setCurrentlyInCreation(beanName, false);
                                }
               
               // 在调用beanMthod的时候，也就是被@Bean注解标注的方法的时候如果使用了参数，只要有一个参数为null,就直接调用getBean(beanName),否则带参数调用getBean(beanName,args)，后面通过例子解释这段代码
                                boolean useArgs = !ObjectUtils.isEmpty(beanMethodArgs);
                                if (useArgs &amp;amp;&amp;amp; beanFactory.isSingleton(beanName)) {
                                        for (Object arg : beanMethodArgs) {
                                                if (arg == null) {
                                                        useArgs = false;
                                                        break;
                                                }
                                        }
                                }
                                Object beanInstance = (useArgs ? beanFactory.getBean(beanName, beanMethodArgs) :
                                                beanFactory.getBean(beanName));
               // 这里发现getBean返回的类型不是我们方法返回的类型，这意味着什么呢？
               // 在《你知道Spring是怎么解析配置类的吗？》我有提到过BeanDefinition的覆盖
               // 这个地方说明beanMethod所定义的bd被覆盖了
                                if (!ClassUtils.isAssignableValue(beanMethod.getReturnType(), beanInstance)) {

                                        if (beanInstance.equals(null)) {
                                                beanInstance = null;
                                        } else {
                                                // 省略日志
                                                throw new IllegalStateException(msg);
                                        }
                                }
               // 注册Bean之间的依赖关系
               // 这个method是当前执行的一个创建bean的方法
                                Method currentlyInvoked = SimpleInstantiationStrategy.getCurrentlyInvokedFactoryMethod();
               // 不等于null意味着currentlyInvoked这个方法创建的bean依赖了beanName所代表的Bean
                        // 在开头的例子中，currentlyInvoked就是a(),beanName就是dmzService,outBeanName就是a
                                if (currentlyInvoked != null) {
                                        String outerBeanName = BeanAnnotationHelper.determineBeanNafanhr(currentlyInvoked);
                   // 注册的就是a跟dmzService的依赖关系，注册到容器中的dependentBeanMap中
                   // key为依赖，value为依赖所在的bean
                                        beanFactory.registerDependentBean(beanName, outerBeanName);
                                }
                                return beanInstance;
                        } finally {
                                if (alreadyInCreation) {
                   // 实际还在创建中，要走完整个生命周期流程
                                        beanFactory.setCurrentlyInCreation(beanName, true);
                                }
                        }
                }



&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;3、结合例子讲解难点代码&quot;&gt;3、结合例子讲解难点代码&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;这部分内容非常细节，不感兴趣可以跳过，主要是BeanMethodInterceptor中的方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;31、判断这个bean是否是一个域代理的类&quot;&gt;3.1、判断这个Bean是否是一个域代理的类&lt;/h4&gt;
&lt;h5 id=&quot;示例代码&quot;&gt;示例代码&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Configuration
@EnableAspectJAutoProxy
public class Config {
   @Bean
   @Scope(value = WebApplicationContext.SCOPE_REQUEST,proxyMode = ScopedProxyMode.TARGET_CLASS)
   public DmzService dmzService() {
       return new DmzService();
   }
}

@RestController
@RequestMapping(&quot;/test&quot;)
public class Controller {

   DmzService dmzService;

   @Autowired
   public void setDmzService(DmzService dmzService) {
       this.dmzService = dmzService;
   }

   @GetMapping(&quot;/get&quot;)
   public ResponseEntity&amp;lt;?&amp;gt; get() {
       System.out.println(dmzService);
       return ResponseEntity.ok().build();
   }
}


&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们需要调试两种情况&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;创建Controller时，注入dmzService，因为dmzService是一个request域的对象，正常情况下注入肯定是报错的，但是我们在配置类上对域对象开启了代理模式，所以在创建Controller时会注入一个代理对象。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vd3hfY2MzNDdiZTY5Ni9ibG9nSW1hZ2UvcmF3L21hc3Rlci8wNTExLnBuZw?x-oss-process=image/format,png&quot; alt=&quot;0511&quot;/&gt;&lt;/p&gt;
&lt;p&gt;端点调试，也确实如我们所料，这个地方注入的确实是一个代理对象，因为我们在配置类上申明了&lt;code&gt;proxyMode = ScopedProxyMode.TARGET_CLASS&lt;/code&gt;，所以这里是一个cglib的代理对象。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用dmzService的时候，这个时候使用的应该是实际的目标对象。所以按照我们的分析应该通过getBean(targetBeanName)的方式来获取到这个Bean，执行流程应该是代理对象cglibDmzService调用了toString方法，然后调用getBean，getBean要根据BeanDefinition创建Bean，而根据BeanDefinition的定义，需要使用配置类中的BeanMethod来创建Bean，所以此时会进入到BeanMethodInterceptor的intecept方法。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们直接在intecept方法中进行断点，会发现此时的调用栈如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vd3hfY2MzNDdiZTY5Ni9ibG9nSW1hZ2UvcmF3L21hc3Rlci8wNTEzLnBuZw?x-oss-process=image/format,png&quot; alt=&quot;0513&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;打印时，调用了toString方法&lt;/li&gt;
&lt;li&gt;实际将会去创建目标Bean，所以此时getBean时对应的BeanName为targetBeanName（&quot;scopedTarget.&quot;+beanName）&lt;/li&gt;
&lt;li&gt;在getBean时根据BeanDefinition的定义会通过执行配置类中的beanMethod方法来创建Bean&lt;/li&gt;
&lt;li&gt;最终就进入了拦截器中这个方法&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这种情况下就会进入到下面这段代码的逻辑中&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 判断这个Bean是否是一个域代理的类
Scope scope = AnnotatedElementUtils.findMergedAnnotation(beanMethod, Scope.class);
// 存在@Scope注解，并且开启了域代理模式
if (scope != null &amp;amp;&amp;amp; scope.proxyMode() != ScopedProxyMode.NO) {
   String scopedBeanName = ScopedProxyCreator.getTargetBeanName(beanName);
   // 域代理对象的目标对象正在被创建,什么时候会被创建？当然是使用的时候嘛
   if (beanFactory.isCurrentlyInCreation(scopedBeanName)) {
       // 使用的时候调用@Bean方法来创建这个域代理的目标对象，所以@Bean方法代理的时候针对的是域代理的目标对象
       beanName = scopedBeanName;
   }
}


&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;33、方法引用的情况下，为什么会出现bean正在创建中（iscurrentlyincreation）？&quot;&gt;3.3、方法引用的情况下，为什么会出现Bean正在创建中（isCurrentlyInCreation）？&lt;/h4&gt;
&lt;p&gt;也就是下面这段代码什么时候会成立&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;if (alreadyInCreation) {
   beanFactory.setCurrentlyInCreation(beanName, false);
}


&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;示例代码-2&quot;&gt;示例代码&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@ComponentScan(value = &quot;com.dmz.spring.first&quot;)
@Configuration
public class Config {
        @Bean
        public A a(){
                return new A();
        }

        @Bean
        public B b(){
                a();
                return new B();
        }
}

class A{
        B b;

        @Autowired
        public void setB(B b) {
                this.b = b;
        }
}
class B{

}


&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面这种配置，在启动的时候就会进入到if条件中，在创建a的时候发现需要注入b，那么Spring此时就会去创建b，b在创建的过程中又调用了a方法，此时a方法在执行时又被拦截了，然后就会进入到if判断中去。对Spring有一定了解的同学应该能感觉到，这个其实跟循环依赖的原理是一样的。关于循环依赖，在后面我单独写一篇文章进行说明。&lt;/p&gt;
&lt;h4 id=&quot;34、if-arg--null-useargs--false是什么意思？&quot;&gt;3.4、if (arg == null) {useArgs = false;}是什么意思？&lt;/h4&gt;
&lt;p&gt;这个代码我初看时也很不明白，为什么只要有一个参数为null就直接标记成不使用参数呢？我说说自己的理解。&lt;/p&gt;
&lt;p&gt;beanMethodArgs代表了调用beanMethod时传入的参数，正常Spring自身是不会传入这个参数的，因为没有必要，创建Bean时其依赖早就通过BeanDefinition确定了，但是可能出现下面这种情况&lt;/p&gt;
&lt;h5 id=&quot;示例代码-3&quot;&gt;示例代码&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Configuration
public class AnotherConfig {
        @Bean
        public DmzService dmzService(IndexService indexService) {
                return new DmzService(indexService);
        }

        @Bean
        public OrderService orderService() {
                DmzService dmzService = dmzService(null);
                return dmzService.createOrder();
        }
}


@Component
public class IndexService {
}

public class DmzService {
        public DmzService(IndexService indexService) {

        }

        public OrderService createOrder() {
                return new OrderService();
        }
}

public class OrderService {
}


&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种情况下，我们在orderService()为了得到当前容器中的dmzService调用了对应的BeanMethod，但是按照方法的定义我们不得不传入一个参数，但是实际上我们知道BeanMethod等价于getBean，所以上面这段代码可以等价于&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Configuration
public class AnotherConfig {
        
        @Autowired
        ApplicationContext applicationContext;
        
        @Bean
        public DmzService dmzService(IndexService indexService) {
                return new DmzService(indexService);
        }

        @Bean
        public OrderService orderService() {
                DmzService dmzService = (DmzService) applicationContext.getBean(&quot;dmzService&quot;);
                return dmzService.createOrder();
        }
}



&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于getBean而言，传入参数跟不传参数在创建Bean时是有区别的，但是创建后从容器中获取Bean时跟传入的参数没有一毛钱关系（单例情况），因为这是从缓存中获取嘛。也就是说单例下，传入的参数只会影响第一次创建。正因为如此，getBean在单纯的做获取的时候不需要参数，那就意味着beanMthod在获取Bean的时候也可以不传入参数嘛，但是beanMthod作为一个方法又定义了形参，Spring就说，这种情况你就传个null吧，反正我知道要去getBean，当然，这只是笔者的个人理解。&lt;/p&gt;
&lt;h2 id=&quot;4、结合spring整体对configurationclassenhancer相关源码分析总结&quot;&gt;4、结合Spring整体对ConfigurationClassEnhancer相关源码分析总结&lt;/h2&gt;
&lt;h3 id=&quot;41、bean工厂后置处理器修改bd对应enhance方法&quot;&gt;4.1、Bean工厂后置处理器修改bd,对应enhance方法&lt;/h3&gt;
&lt;h4 id=&quot;执行流程&quot;&gt;执行流程&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;修改bd的整个过程都发生在Bean工厂后置处理器的执行逻辑中&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200512200720201.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTA3OTkx,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;执行逻辑&quot;&gt;执行逻辑&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200512200724326.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTA3OTkx,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在上文中我们已经知道了，在执行bean工厂后置处理器前，Spring容器的状态如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vd3hfY2MzNDdiZTY5Ni9ibG9nSW1hZ2UvcmF3L21hc3Rlci8xLnBuZw?x-oss-process=image/format,png&quot; alt=&quot;1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么执行完成Bean工厂后置处理器后（不考虑程序员自定义的后置处理器），容器的状态应该是这样的&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vd3hfY2MzNDdiZTY5Ni9ibG9nSW1hZ2UvcmF3L21hc3Rlci8yLnBuZw?x-oss-process=image/format,png&quot; alt=&quot;2&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;42、beanfactoryawaremethodinterceptor&quot;&gt;4.2、BeanFactoryAwareMethodInterceptor&lt;/h3&gt;
&lt;h4 id=&quot;执行流程-2&quot;&gt;执行流程&lt;/h4&gt;
&lt;p&gt;在容器中的bd就绪后，Spring会通过bd来创建Bean了，会先创建配置类，然后创建配置类中beanMethod定义的bean。在创建配置类的过程中在初始化Bean时，如果实现了Aware接口，会调用对于的setXxx方法，具体代码位于&lt;code&gt;org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#initializeBean&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vd3hfY2MzNDdiZTY5Ni9ibG9nSW1hZ2UvcmF3L21hc3Rlci8zLnBuZw?x-oss-process=image/format,png&quot; alt=&quot;3&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在调用&lt;code&gt;setBeanFactory&lt;/code&gt;方法时，会被拦截，进入到拦截器的逻辑中&lt;/p&gt;
&lt;h4 id=&quot;执行逻辑-2&quot;&gt;执行逻辑&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200512200729513.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTA3OTkx,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;43、beanmethodinterceptor&quot;&gt;4.3、BeanMethodInterceptor&lt;/h3&gt;
&lt;h4 id=&quot;执行流程-3&quot;&gt;执行流程&lt;/h4&gt;
&lt;p&gt;以下面这段代码为例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Configuration
public class AnotherConfig {
        @Bean
        public DmzService dmzService(){
                return new DmzService();
        }

        @Bean
        public OrderService orderService(){
                return new OrderService(dmzService());
        }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Spring会根据&lt;code&gt;beanMethod&lt;/code&gt;在配置类中定义顺序来创建Bean，所以上面这段配置会先创建&lt;code&gt;dmzServcice&lt;/code&gt;，之后在创建&lt;code&gt;orderService&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;那么&lt;code&gt;BeanMethodInterceptor&lt;/code&gt;的拦截将会发生在两个地方&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;直接创建&lt;code&gt;dmzService&lt;/code&gt;的过程中，拦截的是&lt;code&gt;dmzService()&lt;/code&gt;方法&lt;/li&gt;
&lt;li&gt;创建&lt;code&gt;orderService&lt;/code&gt;过程中，第一次拦截的是&lt;code&gt;orderService()&lt;/code&gt;方法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;orderService()&lt;/code&gt;方法调用了&lt;code&gt;dmzService()&lt;/code&gt;方法，&lt;code&gt;dmzService()&lt;/code&gt;方法又被拦截&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在直接创建&lt;code&gt;dmzService&lt;/code&gt;时，由于&lt;code&gt;isCurrentlyInvokedFactoryMethod(beanMethod)&lt;/code&gt;这句代码会成立，所以会直接调用目标类的方法，也就是&lt;code&gt;cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs)&lt;/code&gt;,就是我们在配置类中定义的&lt;code&gt;dmzService()&lt;/code&gt;方法，通过这个方法返回一个&lt;code&gt;dmzService&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;而创建&lt;code&gt;orderService&lt;/code&gt;时，方法的调用就略显复杂，首先它类似于上面的直接创建&lt;code&gt;dmzService&lt;/code&gt;的流程，&lt;code&gt;orderService()&lt;/code&gt;方法会被拦截，但是由于正在执行的方法就是&lt;code&gt;orderService()&lt;/code&gt;方法，所以&lt;code&gt;orderService()&lt;/code&gt;也会被直接调用。但是&lt;code&gt;orderService()&lt;/code&gt;中又调用了&lt;code&gt;dmzService()&lt;/code&gt;方法，&lt;code&gt;dmzService()&lt;/code&gt;方法又被拦截了，此时&lt;code&gt;orderService()&lt;/code&gt;还没被执行完成，也就是说正在执行的方法是&lt;code&gt;orderService()&lt;/code&gt;方法，所以&lt;code&gt;isCurrentlyInvokedFactoryMethod(beanMethod)&lt;/code&gt;这句代码就不成立了，那么就会进入&lt;code&gt;org.springframework.context.annotation.ConfigurationClassEnhancer.BeanMethodInterceptor#resolveBeanReference&lt;/code&gt;这个方法的逻辑中，在这个方法中，最终又通过&lt;code&gt;getBean&lt;/code&gt;方法来获取&lt;code&gt;dmzService&lt;/code&gt;，因为&lt;code&gt;dmzService&lt;/code&gt;之前已经被创建过了，所以在单例模式下，就直接从单例池中返回了，而不会再次调用我们在配置类中定义的&lt;code&gt;dmzService()&lt;/code&gt;方法。&lt;/p&gt;
&lt;h4 id=&quot;执行逻辑-3&quot;&gt;执行逻辑&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200513163611227.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTA3OTkx,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这里就在上篇文章的基础上对流程图再做一次完善吧，因为图片太大了，就放个链接~&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.processon.com/diagraming/5eb576387d9c08156c2d8760&quot;&gt;Spring创建bean前的执行流程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;码字不易，要是觉得对你有帮助的话，记得点个赞吧~！&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Wed, 13 May 2020 22:28:00 +0000</pubDate>
<dc:creator>程序员DMZ</dc:creator>
<og:description>本系列文章将会带你一行行的将Spring的源码吃透，做到彻底精通Spring</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/daimzh/p/12886161.html</dc:identifier>
</item>
<item>
<title>人工智能领域常用的开源框架和库（含机器学习/深度学习/强化学习/知识图谱/图神经网络） - FinTecher</title>
<link>http://www.cnblogs.com/zhengzhicong/p/12875348.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhengzhicong/p/12875348.html</guid>
<description>&lt;p&gt;一、机器学习常用的开源框架和库 二、深度学习常用的开源框架和库 三、强化学习常用的开源框架和库 四、图神经网络常用的开源框架和库 五、知识图谱常用的开源框架和库 六、智能推荐常用的开源框架和库&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;165.82902584493&quot;&gt;
&lt;p&gt;【说在前面】本人博客新手一枚，象牙塔的老白，职业场的小白。以下内容仅为个人见解，欢迎批评指正，不喜勿喷！[认真看图][认真看图]&lt;/p&gt;
&lt;p&gt;【补充说明】本文主要讨论人工智能领域中常用的&lt;strong&gt;支持 Python 编程语言&lt;/strong&gt;的开源框架和库，因此全面性肯定有限！&lt;/p&gt;
&lt;h2&gt;一、机器学习常用的开源框架和库&lt;/h2&gt;
&lt;h3&gt;1. Scikit-learn&lt;/h3&gt;
&lt;p&gt;作为专门面向机器学习的 Python 开源框架，Scikit-learn 内部实现了多种机器学习算法，容易安装和使用，样例丰富。&lt;/p&gt;
&lt;h3&gt;2. Mahout&lt;/h3&gt;
&lt;p&gt;在大数据分布式框架 Hadoop 下使用，包含了机器学习中常用的算法（含推荐算法）。&lt;/p&gt;
&lt;h3&gt;3. MLlib / spark.ml&lt;/h3&gt;
&lt;p&gt;在大数据分布式框架 Spark 下使用，同样包含了机器学习中常用的算法，可采用 Java / Sacala / Python / R 语言作为编程语言。&lt;/p&gt;
&lt;h3&gt;4. 其他&lt;/h3&gt;
&lt;p&gt;例如针对计算机视觉的 SimpleCV、针对自然语言处理的 NLTK 等，这里不再拓展。&lt;/p&gt;
&lt;h2&gt;二、深度学习常用的开源框架和库&lt;/h2&gt;
&lt;h3&gt;1. TensorFlow&lt;/h3&gt;
&lt;p&gt;由 Google Brain 团队开发，能够实现各种深度神经网络的搭建。为初学者和专家提供了各种 API，以便对桌面、移动终端、Web和云进行开发。但是，计算图必须构建为静态图，这让很多计算变得难以实现，尤其是序列预测中经常使用的 beam search。&lt;/p&gt;
&lt;h3&gt;2. Keras&lt;/h3&gt;
&lt;p&gt;由 Python 编写的高级神经网络 API，相当于 Tensorflow、Theano、 CNTK 的上层接口。强调极简主义，降低了编程和阅读别人代码时的理解开销， 目前封装有全连接网络、CNN、RNN 和 LSTM 等算法。但是，封装得太高级，细节很难修改，无法直接使用多 GPU。&lt;/p&gt;
&lt;h3&gt;3. PyTorch&lt;/h3&gt;
&lt;p&gt;由 Facebook 团队基于 Torch 开发的深度学习框架。与 TensorFlow 不同的是，PyTorch 是基于动态图的，目前也非常火热。&lt;/p&gt;
&lt;h3&gt;4. Caffe&lt;/h3&gt;
&lt;p&gt;在 TensorFlow 出现之前，一直是深度学习领域 Github star 最多的项目。Caffe 的优势在于容易上手（网络结构都是以配置文件形式定义，不需要用代码设计网络）、训练速度快（组件模块化，可以方便的拓展到新的模型和学习任务上）。但是，Caffe 不好安装，且最开始设计时的目标只针对于图像，因此对 CNN 的支持非常好（例如 AlexNet、VGG、Inception 等），但是对 RNN、LSTM 等的支持不是特别充分。&lt;/p&gt;
&lt;h3&gt;5. 其他&lt;/h3&gt;
&lt;p&gt;例如百度提出的深度学习框架 PaddlePaddle、华为最新开源的深度学习框架 MindSpore 等，这里不再拓展。&lt;/p&gt;
&lt;h2&gt;三、强化学习常用的开源框架和库&lt;/h2&gt;
&lt;h3&gt;1. OpenAI Gym&lt;/h3&gt;
&lt;p&gt;提供了非常多的虚拟环境，具体强化学习算法的代码需要自己来写，可以很好验证强化学习算法，众多强化学习环境都为其提供接口。&lt;/p&gt;
&lt;h3&gt;2. OpenAI Baseline&lt;/h3&gt;
&lt;p&gt;基于 Tensorflow 和 OpenAI Gym 开发的，封装了许多强化学习算法（例如 DQN / PPO / TRPO / DDPG 等）。但是，代码规范性不好。&lt;/p&gt;
&lt;h3&gt;3. RLlib&lt;/h3&gt;
&lt;p&gt;支持 TensorFlow 和 PyTorch，可通过简单的 Python API 使用，目前附带了许多流行的RL算法。&lt;/p&gt;
&lt;h3&gt;4. Horizon&lt;/h3&gt;
&lt;p&gt;Facebook基于 PyTorch、Caffe 和 Spark 构建的强化学习框架，是首个使用应用强化学习在大规模生产环境中优化系统的端到端开源平台。&lt;/p&gt;
&lt;h3&gt;5. 天授：最近了解的，应该比较新吧&lt;/h3&gt;
&lt;p&gt;清华大学人工智能研究院自研的深度强化学习算法平台，支持 TensorFlow 和 PyTorch。可以完整支持 PG、DQN、DDQN、A2C、DDPG、PPO、TD3、SAC 等主流强化学习算法。对比既有主流强化学习平台，大佬给出了天授的性能对比图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1998154/202005/1998154-20200512115000391-1036774773.png&quot; alt=&quot;&quot; width=&quot;615&quot; height=&quot;434&quot;/&gt;&lt;/p&gt;
&lt;p&gt;未来大佬团队将从三个维度拓展“天授”平台，算法层面将更加全面支持地支持主流强化学习算法（包括 model-based RL, imitation learning 等），任务层面将进一步支持包括 Atari、VizDoom 等复杂任务，性能层面将进一步提升平台在模型性能、训练速度、鲁棒性等方面的核心指标，更好的为学术界服务。&lt;/p&gt;
&lt;h3&gt;6. 其他&lt;/h3&gt;
&lt;p&gt;例如知乎有人提到的 tf-agents（与工业紧密连接）、tensorlayer、百度 PaddlePaddle 发布的 PARL 等，这里不再拓展。&lt;/p&gt;
&lt;h2 class=&quot;article-title&quot; data-spm-anchor-id=&quot;a2c6h.12873639.0.i7.7eb14865HhGPHJ&quot;&gt;四、图神经网络常用的开源框架和库&lt;/h2&gt;
&lt;h3&gt;1. 四大图神经网络框架&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;deep graph library (DGL)：支持 pytorch、tensorflow&lt;/li&gt;
&lt;li&gt;pytorch geometric (PyG)：基于 pytorch&lt;/li&gt;
&lt;li&gt;ant graph machine learning system：蚂蚁金服团队推出的大规模图机器学习系统&lt;/li&gt;
&lt;li&gt;tf_geometric：借鉴 pytorch geometric，创建了 tensorflow 版本&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;2. CogDL ：最近了解的，应该比较新吧&lt;/h3&gt;
&lt;p&gt;清华大学知识工程研究室推出了一个大规模图表示学习工具包 CogDL，可以让研究者和开发者更加方便地训练和对比用于节点分类、链路预测以及其他图任务的基准或定制模型。该工具包采用 PyTorch 实现，集成了Deepwalk、LINE、node2vec、GraRep、NetMF、NetSMF、ProNE 等非图神经网络和GCN、GAT、GraphSage、DrGCN、NSGCN、GraphSGAN 等图神经网络模型基准模型的实现。&lt;/p&gt;
&lt;p&gt;与其他图表示学习工具包相比，CogDL 具有以下特点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;稀疏性：在具有数千万节点的大规模网络上实现快速网络嵌入。&lt;/li&gt;
&lt;li&gt;任意性：能够处理属性化、多路和异构等不同图结构的网络。&lt;/li&gt;
&lt;li&gt;并行处理：在多个 GPU 上实现不同种子和模型的并行训练并自动输出结果表格。&lt;/li&gt;
&lt;li&gt;可扩展性：轻松添加新的数据集、模型和任务并在所有现有的模型/数据集上测试。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 class=&quot;article-title&quot; data-spm-anchor-id=&quot;a2c6h.12873639.0.i7.7eb14865HhGPHJ&quot;&gt;3. Graph-Learn（原 AliGraph ）：一个工业级的图神经网络平台&lt;/h3&gt;
&lt;p class=&quot;article-title&quot; data-spm-anchor-id=&quot;a2c6h.12873639.0.i7.7eb14865HhGPHJ&quot;&gt;阿里巴巴提出的 AliGraph 涵盖了从原始图数据到 GNN 应用的整体链路。根据阿里巴巴的介绍：&lt;/p&gt;
&lt;p class=&quot;article-title&quot; data-spm-anchor-id=&quot;a2c6h.12873639.0.i7.7eb14865HhGPHJ&quot;&gt;系统层面：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;数据种类：支持同构图、异构图、属性图，有向图、无向图，可方便与任意分布式文件系统对接。&lt;/li&gt;
&lt;li&gt;数据规模：支持千亿级边、十亿级顶点的超大规模图（原始存储TB级）。&lt;/li&gt;
&lt;li&gt;算子种类：支持几十种可与深度学习相结合的图查询、采样算子，支持向量检索，支持算子按需自定义。&lt;/li&gt;
&lt;li&gt;性能指标：支持分钟级超大规模图构建，毫秒级多跳异构图采样，毫秒级大规模向量检索。&lt;/li&gt;
&lt;li data-spm-anchor-id=&quot;a2c6h.12873639.0.i9.7eb14865HhGPHJ&quot;&gt;用户接口：纯 Python 接口，与 TensorFlow 构成一体化 IDE，开发成本相比一般TF模型无异。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;算法层面：&lt;/p&gt;
&lt;ul&gt;&lt;li data-spm-anchor-id=&quot;a2c6h.12873639.0.i3.7eb14865HhGPHJ&quot;&gt;已支持业界主流的 Graph Embedding 算法，包括：DeepWalk、Node2Vec、GraphSAGE、GATNE等。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;4. 其他&lt;/h3&gt;
&lt;p&gt;图神经网络研究者和工业界在 Github 上开源了很多算法的具体实现及其框架，包括GCN、GAT、Graph Nets框架等，这里不再拓展。&lt;/p&gt;
&lt;h2&gt;五、知识图谱常用的开源框架和库&lt;/h2&gt;
&lt;h3&gt;1. 开源的知识库 &lt;/h3&gt;
&lt;p&gt;主要包括WikiData、DBPedia、WordNet、YAGO、ConceptGraph、BabelNet、CN-DBPeidia、OpenKG 等，这里不再拓展。&lt;/p&gt;
&lt;h3&gt;2. 开源的构建工具&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;bjh-p&quot;&gt;斯坦福大学医学院生物信息研究中心提出的Protege是基于Java语言开发的本体编辑和知识获取软件。Protege提供本体概念类、关系、属性和实例的构建，不基于具体的本体描述语言，因此用户可以在概念层次上构建领域本体模型。&lt;/span&gt;&lt;span class=&quot;bjh-p&quot;&gt;除了Protege，还有其他应用于知识图谱构建的开源软件，而且完整的知识图谱构建还包括知识的存储、知识融合等。&lt;/span&gt;&lt;strong&gt;&lt;span class=&quot;bjh-p&quot;&gt;我想后续单独写一个专题来介绍知识图谱的构建问题，这里不再拓展。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;3. DGL-KE：亚马逊提出的知识图谱嵌入表示框架&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;亚马逊 AI 团队继 DGL 之后，又开源了一款专门针对大规模知识图谱嵌入表示的新训练框架 DGL-KE，旨在能让研究人员和工业界用户方便、快速地在大规模知识图谱数据集上进行机器学习训练任务。相比于已有的开源框架，DGL-KE 的亮点如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;支持各种主流知识图谱表示学习算法，包括 TransE、ComplEx、DistMult、TransR、RESCAL、RotatE 等。&lt;/li&gt;
&lt;li&gt;已有开源框架中唯一支持多核 CPU，多卡 GPU，CPU-GPU 混合训练，以及分布式训练的知识图谱嵌入表示框架。&lt;/li&gt;
&lt;li&gt;简单易用，用户无需编写代码，直接将知识图谱数据作为输入即可。&lt;/li&gt;
&lt;li&gt;高性能且可扩展。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;4. 其他&lt;/h3&gt;
&lt;p&gt;知识图谱研究者和工业界在 Github 上应该开源了很多方法的具体实现及其框架，博主有看到再分享，这里不再拓展。&lt;/p&gt;
&lt;h2&gt;六、智能推荐常用的开源框架和库&lt;/h2&gt;
&lt;h3&gt;1. DeepMatch：用于广告和推荐的深度召回匹配算法库&lt;/h3&gt;
&lt;p&gt;提供了若干主流的深度召回匹配算法的实现，并支持快速导出用户和物品向量进行ANN检索。非常适合同学们进行快速实验和学习。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1998154/202005/1998154-20200512214741318-1036266157.png&quot; alt=&quot;&quot; width=&quot;605&quot; height=&quot;185&quot;/&gt;&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;2. 其他&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;智能推荐研究者和工业界在 Github 上应该开源了很多方法的具体实现及其框架，博主有看到再分享，这里不再拓展。&lt;/p&gt;

&lt;p&gt;如果你对智能推荐感兴趣，欢迎先浏览我的另几篇随笔：&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/zhengzhicong/p/12817941.html&quot;&gt;智能推荐算法演变及学习笔记&lt;/a&gt;、&lt;a class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/zhengzhicong/p/12862816.html&quot;&gt;CTR预估模型演变及学习笔记&lt;/a&gt; 、&lt;a class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/zhengzhicong/p/12850056.html&quot;&gt;基于图模型的智能推荐算法学习笔记（含知识图谱/图神经网络，不止于智能推荐） &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果您对数据挖掘感兴趣，欢迎浏览我的另几篇博客：&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/zhengzhicong/p/12728491.html&quot;&gt;数据挖掘比赛/项目全流程介绍&lt;/a&gt;、&lt;a class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/zhengzhicong/p/12857003.html&quot;&gt;从中国农业银行“雅典娜杯”数据挖掘大赛看金融行业数据分析与建模方法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果您对人工智能算法感兴趣，欢迎浏览我的另一篇博客：&lt;a href=&quot;https://www.cnblogs.com/zhengzhicong/p/12670260.html&quot;&gt;人工智能新手入门学习路线和学习资源合集（含AI综述/python/机器学习/深度学习/tensorflow）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果你是计算机专业的应届毕业生，欢迎浏览我的另外一篇博客：&lt;a href=&quot;https://www.cnblogs.com/zhengzhicong/p/12650878.html&quot;&gt;如果你是一个计算机领域的应届生，你如何准备求职面试？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果你是计算机专业的本科生，欢迎浏览我的另外一篇博客：&lt;a href=&quot;https://www.cnblogs.com/zhengzhicong/p/12650191.html&quot;&gt;如果你是一个计算机领域的本科生，你可以选择学习什么？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果你是计算机专业的研究生，欢迎浏览我的另外一篇博客：&lt;a href=&quot;https://www.cnblogs.com/zhengzhicong/p/12650369.html&quot;&gt;如果你是一个计算机领域的研究生，你可以选择学习什么？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果你对金融科技感兴趣，欢迎浏览我的另一篇博客：&lt;a href=&quot;https://www.cnblogs.com/zhengzhicong/p/12657428.html&quot;&gt;如果你想了解金融科技，不妨先了解金融科技有哪些可能？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;之后博主将持续分享各大算法的学习思路和学习笔记：&lt;a href=&quot;https://www.cnblogs.com/zhengzhicong/p/12641421.html&quot;&gt;hello world: 我的博客写作思路&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Wed, 13 May 2020 17:14:00 +0000</pubDate>
<dc:creator>FinTecher</dc:creator>
<og:description>一、机器学习常用的开源框架和库 二、深度学习常用的开源框架和库 三、强化学习常用的开源框架和库 四、图神经网络常用的开源框架和库 五、知识图谱常用的开源框架和库 六、智能推荐常用的开源框架和库</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhengzhicong/p/12875348.html</dc:identifier>
</item>
<item>
<title>告别传统工业互联网，提高数字管控思维：三维组态分布式能源站 - xhload3d</title>
<link>http://www.cnblogs.com/xhload3d/p/12881471.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xhload3d/p/12881471.html</guid>
<description>&lt;div id=&quot;cnblogs_post_description&quot; readability=&quot;35&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202005/1496396-20200512110134628-282871361.gif&quot; class=&quot;desc_img&quot;/&gt; 在网络迅速发展的今天，人们的交流已经不再仅限与面对面，一个视频通话就能拉近彼此之间的距离，而在工业管控上却不仅仅局限于实时视频流的监控，HTML 本身拥有强大的 web 组件可供我们去实施一些好玩的例子，甚至加上一些简单有趣的动画和实时数据的对接，效果上可不止提高了一个水平。加上现如今已经启动许久的 工业4.0 衍生出的新一代 工业互联网 和不久才面世于众的 5G 新时代，数据可视化与网络带宽发展的碰撞，激发出了一代 3D 数据可视化监管的发展。而 Hightopo（以下简称 HT ）的 HT for Web 产品上的 web 组态提供了丰富的 2D 组态和 3D 组态效果，可以根据需求快速实现一套完整的数据可视化系统。本文将通过一个 HT 的 3D 组态实现的一个可视化分布式能源站系统带你走进丰富的组态的大门。&lt;/div&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;91.179083094556&quot;&gt;
&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在网络迅速发展的今天，人们的交流已经不再仅限与面对面，一个视频通话就能拉近彼此之间的距离，而在工业管控上却不仅仅局限于实时视频流的监控，HTML 本身拥有强大的 web 组件可供我们去实施一些好玩的例子，甚至加上一些简单有趣的动画和实时数据的对接，效果上可不止提高了一个水平。加上现如今已经启动许久的 &lt;strong&gt;工业4.0&lt;/strong&gt; 衍生出的新一代 &lt;strong&gt;工业互联网&lt;/strong&gt; 和不久才面世于众的 &lt;strong&gt;5G&lt;/strong&gt; 新时代，数据可视化与网络带宽发展的碰撞，激发出了一代 3D 数据可视化监管的发展。而 &lt;strong&gt;Hightopo&lt;/strong&gt;（以下简称 HT ）的 &lt;strong&gt;HT for Web&lt;/strong&gt; 产品上的 &lt;strong&gt;web&lt;/strong&gt; 组态提供了丰富的 &lt;strong&gt;2D 组态&lt;/strong&gt;和 &lt;strong&gt;3D 组态&lt;/strong&gt;效果，可以根据需求快速实现一套完整的数据可视化系统。本文将通过一个 HT 的 &lt;strong&gt;3D 组态&lt;/strong&gt;实现的一个可视化分布式能源站系统带你走进丰富的组态的大门。&lt;/p&gt;

&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;strong&gt;界面简介及效果预览&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;场景搭建上我们呈现了以热、电、冷联供为主要形式的多联产系统的分布式能源站系统，根据管道流动传递的流程步骤下，有效地实现了能源的梯级利用的展示效果：&lt;/p&gt;
&lt;div&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202005/1496396-20200512110134628-282871361.gif&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;strong&gt;代码实现&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在能源站的建设中，分布式能源站是指小规模化、利用热、电、冷联供为主要形式分布于负荷附近的清洁环保发电设施，是一种相对可靠又高效的发电形式。&lt;/p&gt;
&lt;p&gt;3D 场景实现上通过创建 &lt;strong&gt;ht.graph3d.Graph3dView&lt;/strong&gt; 来呈现 3D 的内容，3D 视图组件进行 deserialize() 反序列化对应的 json 呈现出 3D 场景内容，然后将 3D 组件再加入到 body下的方式实现场景的加载渲染的效果。还可以自定义修改一些交互或者视角上的限制，如修改左右键的交互方式或者设置场景的最大仰角，都能使用户在交互体验上更为流畅。&lt;/p&gt;
&lt;div readability=&quot;46.919658119658&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 创建三维拓扑视图
&lt;span data-mce-=&quot;&quot;&gt;this.g3d = &lt;span data-mce-=&quot;&quot;&gt;new&lt;span data-mce-=&quot;&quot;&gt; ht.graph3d.Graph3dView();
&lt;span data-mce-=&quot;&quot;&gt;this.g3dDm = &lt;span data-mce-=&quot;&quot;&gt;this&lt;span data-mce-=&quot;&quot;&gt;.g3d.dm();
&lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 将 3D 组件加入到 body 下
&lt;span data-mce-=&quot;&quot;&gt;this&lt;span data-mce-=&quot;&quot;&gt;.g3d.addToDOM();
&lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 修改左右键交互方式
let mapInteractor = &lt;span data-mce-=&quot;&quot;&gt;new ht.graph3d.MapInteractor(&lt;span data-mce-=&quot;&quot;&gt;this&lt;span data-mce-=&quot;&quot;&gt;.g3d);
&lt;span data-mce-=&quot;&quot;&gt;this&lt;span data-mce-=&quot;&quot;&gt;.g3d.setInteractors([mapInteractor]);
&lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 修改最大仰角为 PI / 2
mapInteractor.maxPhi = Math.PI / 2;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;为了能在悬浮建筑模型的时候，视觉上有交互体验，这里设置了模型的高亮模式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202005/1496396-20200512111932719-1624900209.gif&quot; alt=&quot;&quot; width=&quot;630&quot; height=&quot;306&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 设置鼠标悬浮高亮模式
&lt;span data-mce-=&quot;&quot;&gt;this.g3d.setHighlightMode('mouseover'&lt;span data-mce-=&quot;&quot;&gt;);
&lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 设置高亮颜色
ht.Style['highlight.color'] = '#FEB64D';&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;场景渲染加载出来后，我们就能对于分布式能源站的工业流程可以通过管道的动画来展示。HT 提供的 ht.Shape 是极其强大的图元类型，其在 GraphView 和 Graph3dView 组件上都能展示出各种二维和三维的形状效果， 其扩展子类 ht.PolyLine 可实现三维空间管道的功能，我们可以通过 ht.PolyLine 绘制出流程所经的路径，通过 ht.Default.startAnim() 动画函数去执行调用变化管道上的 uv 贴图的偏移值，就可以达到流动的效果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202005/1496396-20200512110153089-675738608.gif&quot; alt=&quot;&quot; width=&quot;641&quot; height=&quot;311&quot;/&gt;&lt;/p&gt;
&lt;p&gt;实现的代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span data-mce-=&quot;&quot;&gt;animflow() {
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 动画执行函数
&lt;span data-mce-=&quot;&quot;&gt;    ht.Default.startAnim({
        duration: 2000&lt;span data-mce-=&quot;&quot;&gt;,
        easing: (t) =&amp;gt; { &lt;span data-mce-=&quot;&quot;&gt;return&lt;span data-mce-=&quot;&quot;&gt;  t },
        action: (v, t) =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {
            &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 通过数据模型获取唯一标识 tag 得到管道节点设置 uv 偏移流动动画
            &lt;span data-mce-=&quot;&quot;&gt;this.g3dDm.getDataByTag('flow1').setStyle('top.uv.offset', [ v, 0&lt;span data-mce-=&quot;&quot;&gt; ]); 
            &lt;span data-mce-=&quot;&quot;&gt;this.g3dDm.getDataByTag('flow2').setStyle('top.uv.offset', [ v, 0.5&lt;span data-mce-=&quot;&quot;&gt; ]);
            &lt;span data-mce-=&quot;&quot;&gt;this,g3dDm.getDataByTag('flow3').setStyle('top.uv.offset', [ -v, 0.5&lt;span data-mce-=&quot;&quot;&gt; ]);
            ...            
        },
        finishFunc:  () =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {
            animflow();
        }
    });
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;而场景中呈现出来的数据，我们可以通过对接一些主流的接口，例如 &lt;strong&gt;ajax&lt;/strong&gt;、&lt;strong&gt;&lt;strong&gt;axios &lt;/strong&gt;&lt;/strong&gt;或者是 &lt;strong&gt;&lt;strong&gt;&lt;strong&gt;WebSocket&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;，根据自己对接交互的需求，可以判断采用轮询调用接口或者是对接双向进行数据传输，起到实时刷新数据的需求，而数据的载体可以对接到 HT 的 3D公告板 billboard 上进行展示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202005/1496396-20200512110230448-713542102.png&quot; alt=&quot;&quot; width=&quot;780&quot; height=&quot;381&quot;/&gt;&lt;/p&gt;

&lt;p&gt;billboard 同样是基于 ht.Shape 的子类，对于 Shape 不管是在 2D 组态或者是 3D 组态上呈现，都可以通过一些定义的属性 styleMap 来设定一些本身自带的属性值，当然用户也可以自己通过在 attrObject 里设定一些自定义属性。而分布式能源站中，我们通过对 billboard 设定了一些属性值来控制公告板的属性信息：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
let billboard = &lt;span data-mce-=&quot;&quot;&gt;new&lt;span data-mce-=&quot;&quot;&gt; ht.Node();
billboard.s({
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 设定 shpe3d 的类型为公告板 billboard
    &quot;shape3d&quot;: &quot;billboard&quot;&lt;span data-mce-=&quot;&quot;&gt;,
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 设置公告板的图片 image
    &quot;shape3d.image&quot;: &quot;symbols/htdesign/box/panel.json&quot;&lt;span data-mce-=&quot;&quot;&gt;,
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 设置公告板始终自动旋转面对屏幕
    &quot;shape3d.autorotate&quot;: &lt;span data-mce-=&quot;&quot;&gt;true&lt;span data-mce-=&quot;&quot;&gt;,
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 设置公告板开启透明
    &quot;shape3d.transparent&quot;: &lt;span data-mce-=&quot;&quot;&gt;true&lt;span data-mce-=&quot;&quot;&gt;,
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 设置公告板不可移动
    &quot;3d.movable&quot;: &lt;span data-mce-=&quot;&quot;&gt;false&lt;span data-mce-=&quot;&quot;&gt;,
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 设置公告板始终置顶
    &quot;shape3d.alwaysOnTop&quot;: &lt;span data-mce-=&quot;&quot;&gt;true&lt;span data-mce-=&quot;&quot;&gt;,
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 设置公告板不可选中
    &quot;3d.selectable&quot;: &lt;span data-mce-=&quot;&quot;&gt;false&lt;span data-mce-=&quot;&quot;&gt;,
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 公告板开启缓存
    &quot;shape3d.image.cache&quot;: &lt;span data-mce-=&quot;&quot;&gt;true&lt;span data-mce-=&quot;&quot;&gt;
});&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果贴图是矢量，对于开启了缓存的公告板，性能上会大大提高。对比一下这个 &lt;a href=&quot;https://www.hightopo.com/guide2/ht/guide/core/vector/examples/example_cache.html&quot; target=&quot;_blank&quot;&gt;例子&lt;/a&gt;，你会发现缓存机制上性能的差异性。由此看出，缓存机制对于整体场景的流畅度是至关重要的，对于一些不必要实时刷新的面板信息，我们可以采取缓存的方式，并且在下一次更新的时候调用 Graph3dView.invalidateShape3dCachedImage(node)来手动刷新这个节点，从而大大提高了场景的性能：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
g3d.invalidateShape3dCachedImage(billboard);
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;12.382042253521&quot;&gt;历经了2018的工业互联网元年和2019的 5G 元年，不止是分布式能源站可视化系统的呈现，工业互联网在管控方面将迎来了新时代。为了给精彩的 HTML web 组态添加上绚丽的颜色，HT 在&lt;strong&gt; 2D 组态&lt;/strong&gt;和 &lt;strong&gt;3D 组态&lt;/strong&gt;上不断地完善，可以通过 2/3D 融合的场景与图纸搭建出一个个好玩的可视化系统。而作为在 3D 组态上可以呈现出多样化效果下搭建的可视化系统场景，传统上一些数据可视化的工艺流程同样能通过 2D 组态来实现：&lt;a href=&quot;https://www.hightopo.com/demo/heat-station/blue/&quot; target=&quot;_blank&quot;&gt;换热站远程监控系统&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202004/1496396-20200426214840115-1850580621.gif&quot; alt=&quot;&quot; width=&quot;808&quot; height=&quot;396&quot;/&gt;&lt;/div&gt;



&lt;/div&gt;</description>
<pubDate>Wed, 13 May 2020 15:50:00 +0000</pubDate>
<dc:creator>xhload3d</dc:creator>
<og:description>前言 在网络迅速发展的今天，人们的交流已经不再仅限与面对面，一个视频通话就能拉近彼此之间的距离，而在工业管控上却不仅仅局限于实时视频流的监控，HTML 本身拥有强大的 web 组件可供我们去实施一些好</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xhload3d/p/12881471.html</dc:identifier>
</item>
</channel>
</rss>