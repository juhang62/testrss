<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>[源码分析]ArrayList和LinkedList如何实现的？我看你还有机会！ - 未读代码</title>
<link>http://www.cnblogs.com/niumoo/p/13494348.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/niumoo/p/13494348.html</guid>
<description>&lt;blockquote readability=&quot;4.8066298342541&quot;&gt;
&lt;p&gt;文章已经收录在 &lt;a href=&quot;https://github.com/niumoo/JavaNotes&quot;&gt;Github.com/niumoo/JavaNotes&lt;/a&gt; ，更有 Java 程序员所需要掌握的核心知识，欢迎Star和指教。&lt;br/&gt;欢迎关注我的&lt;a href=&quot;https://github.com/niumoo/JavaNotes#%E5%85%AC%E4%BC%97%E5%8F%B7&quot;&gt;公众号&lt;/a&gt;，文章每周更新。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;说真的，在 Java 使用最多的集合类中，List 绝对占有一席之地的，它和 Map 一样适用于很多场景，非常方便我们的日常开发，毕竟存储一个列表的需求随处可见。尽管如此，还是有很多同学没有弄明白 List 中 &lt;strong&gt;ArrayList&lt;/strong&gt; 和 &lt;strong&gt;LinkedList&lt;/strong&gt; 有什么区别，这简直太遗憾了，这两者其实都是数据结构中的&lt;strong&gt;基础内容&lt;/strong&gt;，这篇文章会从&lt;strong&gt;基础概念&lt;/strong&gt;开始，分析两者在 Java 中的&lt;strong&gt;具体源码实现&lt;/strong&gt;，寻找两者的不同之处，最后思考它们使用时的注意事项。&lt;/p&gt;
&lt;p&gt;这篇文章会包含以下内容。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;介绍线性表的概念，详细介绍线性表中&lt;strong&gt;数组&lt;/strong&gt;和&lt;strong&gt;链表&lt;/strong&gt;的数据结构。&lt;/li&gt;
&lt;li&gt;进行 ArrayList 的源码分析，比如存储结构、扩容机制、数据新增、数据获取等。&lt;/li&gt;
&lt;li&gt;进行 LinkedList 的源码分析，比如它的存储结构、数据插入、数据查询、数据删除和 LinkedList 作为队列的使用方式等。&lt;/li&gt;
&lt;li&gt;进行 ArrayList 和 LinkedList 的总结。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;线性表&quot;&gt;线性表&lt;/h2&gt;
&lt;p&gt;要研究 &lt;strong&gt;ArrayList&lt;/strong&gt; 和 &lt;strong&gt;LinkedList&lt;/strong&gt; ，首先要弄明白什么是&lt;strong&gt;线性表&lt;/strong&gt;，这里引用百度百科的一段文字。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;线性表是最基本、最简单、也是最常用的一种数据结构。线性表（linear list）是数据结构的一种，一个线性表是n个具有相同特性的数据元素的有限序列。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;你肯定看到了，线性表在数据结构中是一种&lt;strong&gt;最基本、最简单、最常用&lt;/strong&gt;的数据结构。它将数据一个接一个的排成一条线（可能逻辑上），也因此线性表上的每个数据只有前后两个方向，而在数据结构中，&lt;strong&gt;数组、链表、栈、队列&lt;/strong&gt;都是线性表。你可以想象一下整整齐齐排队的样子。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/niumoo/cdn-assets/2020/image-20200809004119875.png&quot; alt=&quot;线性表&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看到这里你可能有疑问了，有线性表，那么肯定有&lt;strong&gt;非线性表&lt;/strong&gt;喽？没错。&lt;strong&gt;二叉树&lt;/strong&gt;和&lt;strong&gt;图&lt;/strong&gt;就是典型的非线性结构了。不要被这些花里胡哨的图吓到，其实这篇文章非常简单，希望同学耐心看完&lt;strong&gt;点个赞&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/niumoo/cdn-assets/2020/grap.png&quot; alt=&quot;非线性接口（图片来自网络）&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;数组&quot;&gt;数组&lt;/h3&gt;
&lt;p&gt;既然知道了什么是线性表，那么理解数组也就很容易了，首先数组是线性表的一种实现。数组是由&lt;strong&gt;相同类型&lt;/strong&gt;元素组成的一种数据结构，数组需要分配&lt;strong&gt;一段连续的内存&lt;/strong&gt;用来存储。注意关键词，&lt;strong&gt;相同类型&lt;/strong&gt;，&lt;strong&gt;连续内存&lt;/strong&gt;，像这样。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/niumoo/cdn-assets/2020/image-20200810224700319.png&quot; alt=&quot;数组&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不好意思放错图了，像这样。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/niumoo/cdn-assets/2020/image-20200808232102227.png&quot; alt=&quot;数组概念&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面的图可以很直观的体现数组的存储结构，因为数组内存地址连续，元素类型固定，所有具有&lt;strong&gt;快速查找&lt;/strong&gt;某个位置的元素的特性；同时也因为数组需要一段连续内存，所以长度在初始化&lt;strong&gt;长度已经固定&lt;/strong&gt;，且不能更改。Java 中的 &lt;strong&gt;ArrayList&lt;/strong&gt; 本质上就是一个数组的封装。&lt;/p&gt;
&lt;h3 id=&quot;链表&quot;&gt;链表&lt;/h3&gt;
&lt;p&gt;链表也是一种线性表，和数组不同的是链表&lt;strong&gt;不需要连续的内存&lt;/strong&gt;进行数据存储，而是在每个节点里同时&lt;strong&gt;存储下一个节点&lt;/strong&gt;的指针，又要注意关键词了，每个节点都有一个指针指向下一个节点。那么这个链表应该是什么样子呢？看图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/niumoo/cdn-assets/2020/image-20200810224910849.png&quot; alt=&quot;单向链表&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;哦不，放错图了，是这样。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/niumoo/cdn-assets/2020/image-20200808233941445.png&quot; alt=&quot;链表存储结构（图片来自网络）&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图很好的展示了链表的存储结构，图中每个节点都有一个指针指向下一个节点位置，这种我们称为&lt;strong&gt;单向链表&lt;/strong&gt;；还有一种链表在每个节点上还有一个指针指向上一个节点，这种链表我们称为&lt;strong&gt;双向链表&lt;/strong&gt;。图我就不画了，像下面这样。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/niumoo/cdn-assets/2020/image-20200810224500217.png&quot; alt=&quot;双向链表&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以发现链表不必连续内存存储了，因为链表是通过节点指针进行下一个或者上一个节点的，只要找到头节点，就可以以此找到后面一串的节点。不过也因此，链表在&lt;strong&gt;查找或者访问某个位置的节点&lt;/strong&gt;时，需要&lt;strong&gt;O(n)&lt;/strong&gt;的时间复杂度。但是插入数据时可以达到&lt;strong&gt;O(1)&lt;/strong&gt;的复杂度，因为只需要修改节点指针指向。&lt;/p&gt;
&lt;h2 id=&quot;arratlist&quot;&gt;ArratList&lt;/h2&gt;
&lt;p&gt;上面介绍了线性表的概念，并举出了两个线性表的实际实现例子，既数组和链表。在 Java 的集合类 ArrayList 里，实际上使用的就是数组存储结构，ArrayList 对 Array 进行了封装，并增加了方便的插入、获取、扩容等操作。因为 ArrayList 的底层是数组，所以存取非常迅速，但是增删时，因为要移动后面的元素位置，所以增删效率相对较低。那么它具体是怎么实现的呢？不妨深入源码一探究竟。&lt;/p&gt;
&lt;h3 id=&quot;arraylist-存储结构&quot;&gt;ArrayList 存储结构&lt;/h3&gt;
&lt;p&gt;查看 ArrayList 的源码可以看到它就是一个简单的数组，用来数据存储。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * The array buffer into which the elements of the ArrayList are stored.
 * The capacity of the ArrayList is the length of this array buffer. Any
 * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA
 * will be expanded to DEFAULT_CAPACITY when the first element is added.
 */
transient Object[] elementData; // non-private to simplify nested class access

/**
 * Shared empty array instance used for default sized empty instances. We
 * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when
 * first element is added.
 */
private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};

/**
 * Default initial capacity.
 */
private static final int DEFAULT_CAPACITY = 10;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过上面的注释了解到，ArrayList 无参构造时是会共享一个长度为 0 的数组 DEFAULTCAPACITY_EMPTY_ELEMENTDATA. 只有当第一个元素添加时才会第一次扩容，这样也防止了创建对象时更多的内存浪费。&lt;/p&gt;
&lt;h3 id=&quot;arraylist-扩容机制&quot;&gt;ArrayList 扩容机制&lt;/h3&gt;
&lt;p&gt;我们都知道数组的大小一但确定是不能改变的，那么 ArrayList 明显可以不断的添加元素，它的底层又是数组，它是怎么实现的呢？从上面的 ArrayList 存储结构以及注释中了解到，ArrayList 在初始化时，是共享一个长度为 0 的数组的，当第一个元素添加进来时会进行第一次扩容，我们可以想像出 ArrayList 每当空间不够使用时就会进行一次扩容，那么扩容的机制是什么样子的呢?&lt;/p&gt;
&lt;p&gt;依旧从源码开始，追踪 add() 方法的内部实现。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * Appends the specified element to the end of this list.
 *
 * @param e element to be appended to this list
 * @return &amp;lt;tt&amp;gt;true&amp;lt;/tt&amp;gt; (as specified by {@link Collection#add})
 */
public boolean add(E e) {
    ensureCapacityInternal(size + 1);  // Increments modCount!!
    elementData[size++] = e;
    return true;
}
// 开始检查当前插入位置时数组容量是否足够
private void ensureCapacityInternal(int minCapacity) {
    // ArrayList 是否未初始化，未初始化是则初始化 ArrayList ，容量给 10.
    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);
    }
    ensureExplicitCapacity(minCapacity);
}
// 比较插入 index 是否大于当前数组长度，大于就 grow 进行扩容
private void ensureExplicitCapacity(int minCapacity) {
    modCount++;
    // overflow-conscious code
    if (minCapacity - elementData.length &amp;gt; 0)
        grow(minCapacity);
}

/**
 * Increases the capacity to ensure that it can hold at least the
 * number of elements specified by the minimum capacity argument.
 *
 * @param minCapacity the desired minimum capacity
 */
private void grow(int minCapacity) {
    // overflow-conscious code
    int oldCapacity = elementData.length;
    // 扩容规则是当前容量 + 当前容量右移1位。也就是1.5倍。
    int newCapacity = oldCapacity + (oldCapacity &amp;gt;&amp;gt; 1);
    if (newCapacity - minCapacity &amp;lt; 0)
        newCapacity = minCapacity;
    // 是否大于 Int 最大值，也就是容量最大值
    if (newCapacity - MAX_ARRAY_SIZE &amp;gt; 0)
        newCapacity = hugeCapacity(minCapacity);
    // minCapacity is usually close to size, so this is a win:
    // 拷贝元素到扩充后的新的 ArrayList
    elementData = Arrays.copyOf(elementData, newCapacity);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过源码发现扩容逻辑还是比较简单的，整理下具体的扩容流程如下：&lt;/p&gt;
&lt;ol readability=&quot;2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;开始检查当前插入位置时数组容量是否足够&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;ArrayList 是否未初始化，未初始化是则初始化 ArrayList ，容量给 10.&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;判断当前要插入的下标是否大于容量&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;不大于，插入新增元素，新增流程完毕。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如果所需的容量大于当前容量，开始扩充。&lt;/p&gt;
&lt;ol readability=&quot;2&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;扩容规则是当前容量 + 当前容量右移1位。也就是1.5倍。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;int newCapacity = oldCapacity + (oldCapacity &amp;gt;&amp;gt; 1);&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如果扩充之后还是小于需要的最小容量，则把所需最小容量作为容量。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如果容量大于默认最大容量，则使用 最大值 Integer 作为容量。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;拷贝老数组元素到扩充后的新数组&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;插入新增元素，新增流程完毕。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;arraylist--数据新增&quot;&gt;ArrayList 数据新增&lt;/h3&gt;
&lt;p&gt;上面分析扩容时候已经看到了新增一个元素的具体逻辑，因为底层是数组，所以直接指定下标赋值即可，非常简单。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public boolean add(E e) {
    ensureCapacityInternal(size + 1);  // Increments modCount!!
    elementData[size++] = e; // 直接赋值
    return true;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是还有一种新增数据得情况，就是新增时指定了要加入的下标位置。这时逻辑有什么不同呢？&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * Inserts the specified element at the specified position in this
 * list. Shifts the element currently at that position (if any) and
 * any subsequent elements to the right (adds one to their indices).
 *
 * @param index index at which the specified element is to be inserted
 * @param element element to be inserted
 * @throws IndexOutOfBoundsException {@inheritDoc}
 */
public void add(int index, E element) {
    rangeCheckForAdd(index);
    ensureCapacityInternal(size + 1);  // Increments modCount!!
     // 指定下标开始所有元素后移一位
    System.arraycopy(elementData, index, elementData, index + 1,size - index);
    elementData[index] = element;
    size++;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以发现这种新增多了关键的一行，它的作用是把从要插入的坐标开始的元素都向后移动一位，这样才能给指定下标腾出空间，才可以放入新增的元素。&lt;/p&gt;
&lt;p&gt;比如你要在下标为 3 的位置新增数据100，那么下标为3开始的所有元素都需要后移一位。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/niumoo/cdn-assets/2020/image-20200809004018640.png&quot; alt=&quot;ArrayList 随机新增数据&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由此也可以看到 ArrayList 的一个缺点，&lt;strong&gt;随机插入新数据时效率不高&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;arraylist-数据获取&quot;&gt;ArrayList 数据获取&lt;/h3&gt;
&lt;p&gt;数据下标获取元素值，&lt;strong&gt;一步到位，不必多言&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public E get(int index) {
    rangeCheck(index);
    return elementData(index);
}
E elementData(int index) {
    return (E) elementData[index];
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;linkedlist&quot;&gt;LinkedList&lt;/h2&gt;
&lt;p&gt;LinkedList 的底层就是一个链表线性结构了，链表除了要有一个节点对象外，根据单向链表和双向链表的不同，还有一个或者两个指针。那么 LinkedList 是单链表还是双向链表呢？&lt;/p&gt;
&lt;h3 id=&quot;linkedlist-存储结构&quot;&gt;LinkedList 存储结构&lt;/h3&gt;
&lt;p&gt;依旧深入 LinkedList 源码一探究竟，可以看到 LinkedList 无参构造里没有任何操作，不过我们通过查看变量 first、last 可以发现它们就是存储链表第一个和最后 一个的节点。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;transient int size = 0;
/**
 * Pointer to first node.
 * Invariant: (first == null &amp;amp;&amp;amp; last == null) ||
 *            (first.prev == null &amp;amp;&amp;amp; first.item != null)
 */
transient Node&amp;lt;E&amp;gt; first;

/**
 * Pointer to last node.
 * Invariant: (first == null &amp;amp;&amp;amp; last == null) ||
 *            (last.next == null &amp;amp;&amp;amp; last.item != null)
 */
transient Node&amp;lt;E&amp;gt; last;

/**
 * Constructs an empty list.
 */
public LinkedList() {
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;变量 first 和 last 都是 Node 类型，继而查看 Node 源码。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private static class Node&amp;lt;E&amp;gt; {
    E item;
    Node&amp;lt;E&amp;gt; next;
    Node&amp;lt;E&amp;gt; prev;

    Node(Node&amp;lt;E&amp;gt; prev, E element, Node&amp;lt;E&amp;gt; next) {
        this.item = element;
        this.next = next;
        this.prev = prev;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到这就是一个典型的&lt;strong&gt;双向链表&lt;/strong&gt;结构，item 用来存放元素值；next 指向下一个 node 节点，prev 指向上一个 node 节点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/niumoo/cdn-assets/2020/image-20200809142450661.png&quot; alt=&quot;双向链表（图片来自 appcoda.com）&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;linkedlist-数据获取&quot;&gt;LinkedList 数据获取&lt;/h3&gt;
&lt;p&gt;链表不像数组是连续的内存地址，链表是通过next 和 prev 指向记录链接路径的，所以查找指定位置的 node 只能遍历查找，查看源码也是如此。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public E get(int index) {
    checkElementIndex(index);
    return node(index).item;
}
/**
 * Returns the (non-null) Node at the specified element index.
 */
// 遍历查找 index 位置的节点信息
Node&amp;lt;E&amp;gt; node(int index) {
    // assert isElementIndex(index);
    // 这里判断 index 是在当前链表的前半部分还是后半部分，然后决定是从
    // first 向后查找还是从 last 向前查找。
    if (index &amp;lt; (size &amp;gt;&amp;gt; 1)) {
        Node&amp;lt;E&amp;gt; x = first;
        for (int i = 0; i &amp;lt; index; i++)
            x = x.next;
        return x;
    } else {
        Node&amp;lt;E&amp;gt; x = last;
        for (int i = size - 1; i &amp;gt; index; i--)
            x = x.prev;
        return x;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查找指定位置的 node 对象，这个部分要注意的是，查找会首先判断 index 是在当前链表的前半部分还是后半部分，然后决定是从 first 向后查找还是从 last 向前查找。这样可以增加查找速度。从这里也可以看出链表在查找指定位置元素时，效率不高。&lt;/p&gt;
&lt;h3 id=&quot;linkedlist-数据新增&quot;&gt;LinkedList 数据新增&lt;/h3&gt;
&lt;p&gt;因为 LinkedList 是链表，所以 LinkedList 的新增也就是链表的数据新增了，这时候要根据要插入的位置的区分操作。&lt;/p&gt;
&lt;ol readability=&quot;12.5&quot;&gt;&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;尾部插入&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public boolean add(E e) {
    linkLast(e);
    return true;
}
void linkLast(E e) {
    final Node&amp;lt;E&amp;gt; l = last;
    // 新节点，prev 为当前尾部节点，e为元素值，next 为 null，
    final Node&amp;lt;E&amp;gt; newNode = new Node&amp;lt;&amp;gt;(l, e, null);
    last = newNode;
    if (l == null)
        first = newNode;
    else
         // 目前的尾部节点 next 指向新的节点
        l.next = newNode;
    size++;
    modCount++;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;默认的 add 方式就是尾部新增了，尾部新增的逻辑很简单，只需要创建一个新的节点，新节点的 prev 设置现有的末尾节点，现有的末尾 Node 指向新节点 Node，新节点的 next 设为 null 即可。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;17&quot;&gt;
&lt;p&gt;中间新增&lt;/p&gt;
&lt;p&gt;下面是在指定位置新增元素，涉及到的源码部分。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void add(int index, E element) {
    checkPositionIndex(index);
    if (index == size)
        // 如果位置就是当前链表尾部，直接尾插
        linkLast(element);
    else
        // 获取 index 位置的节点，插入新的元素
        linkBefore(element, node(index));
}

/**
 * Inserts element e before non-null Node succ.
 */
// 在指定节点处新增元素，修改指定元素的下一个节点为新增元素，新增元素的下一个节点是查找到得 node 的next节点指向，
// 新增元素的上一个节点为查找到的 node 节点，查找到的 node 节点的 next 指向 node 的 prev 修改为新 Node
void linkBefore(E e, Node&amp;lt;E&amp;gt; succ) {
    // assert succ != null;
    final Node&amp;lt;E&amp;gt; pred = succ.prev;
    final Node&amp;lt;E&amp;gt; newNode = new Node&amp;lt;&amp;gt;(pred, e, succ);
    succ.prev = newNode;
    if (pred == null)
        first = newNode;
    else
        pred.next = newNode;
    size++;
    modCount++;
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到指定位置插入元素主要分为两个部分，第一个部分是查找 node 节点部分，这部分就是上面介绍的 LinkedList 数据获取部分，&lt;/p&gt;
&lt;p&gt;第二个部分是在查找到得 node 对象后插入元素。主要就是修改 node 的 next 指向为新节点，新节点的 prev 指向为查找到的 node 节点，新节点的 next 指向为查找到的 node 节点的 next 指向。查找到的 node 节点的 next 指向的 node 节点的 prev 修改为新节点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/niumoo/cdn-assets/2020/image-20200809145942634.png&quot; alt=&quot;LinkedLst 插入元素&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;linkedlist-数据删除&quot;&gt;LinkedList 数据删除&lt;/h3&gt;
&lt;p&gt;依旧查看源码进行分析，源码中看到如果节点是头结点或者尾节点，删除比较简单。我们主要看删除中间一个节点时的操作&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public E remove(int index) {
    checkElementIndex(index);
    return unlink(node(index));
}
/**
 * Unlinks non-null node x.
 */
E unlink(Node&amp;lt;E&amp;gt; x) {
    // assert x != null;
    final E element = x.item;
    final Node&amp;lt;E&amp;gt; next = x.next;
    final Node&amp;lt;E&amp;gt; prev = x.prev;

    if (prev == null) {
        first = next;
    } else {
        prev.next = next;
        x.prev = null;
    }

    if (next == null) {
        last = prev;
    } else {
        next.prev = prev;
        x.next = null;
    }

    x.item = null;
    size--;
    modCount++;
    return element;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;node(index) 方法依旧是二分查找目标位置，然后进行删除操作。比如要删除的节点叫做 X，删除操作主要是修改 X 节点的 prev 节点的 next 指向为 X 节点的 next 指向，修改 X 节点的 next 节点的 prev 指向为 X 节点的 prev 指向，最后把 X 节点的 prev 和 next 指向清空。如果理解起来有点费劲，可以看下面这个图，可能会比较明白。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/niumoo/cdn-assets/2020/image-20200810222445628.png&quot; alt=&quot;LinkedList 删除数据&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;扩展&quot;&gt;扩展&lt;/h3&gt;
&lt;p&gt;你以为 LinkedList 只是一个 List，其他它不仅实现了 List 接口，还实现了 Deque ，所以它表面上是一个 List，其实它还是一个队列。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class LinkedList&amp;lt;E&amp;gt; extends AbstractSequentialList&amp;lt;E&amp;gt;
    implements List&amp;lt;E&amp;gt;, Deque&amp;lt;E&amp;gt;, Cloneable, java.io.Serializable
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;体验一下先进先出的队列。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Queue&amp;lt;String&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;();
queue.add(&quot;a&quot;);
queue.add(&quot;b&quot;);
queue.add(&quot;c&quot;);
queue.add(&quot;d&quot;);
System.out.println(queue.poll());
System.out.println(queue.poll());
System.out.println(queue.poll());
System.out.println(queue.poll());
// result：
// a
// b
// c
// d
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同学可以思考一下这个队列是怎么实现的，其实很简单对不对，就是先进先出嘛，&lt;code&gt;poll&lt;/code&gt; 时删除 first 节点不就完事了嘛。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;不管是 ArrayList 还是 LinkedList 都是开发中常用的集合类，这篇文章分析了两者的底层实现，通过对底层实现的分析我们可以总结出两者的主要优缺点。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;遍历，ArrayList 每次都是&lt;strong&gt;直接定位&lt;/strong&gt;，LinkedList 通过 &lt;strong&gt;next 节点定位&lt;/strong&gt;，不相上下。这里要注意的是 LinkedList 只有使用&lt;strong&gt;迭代器&lt;/strong&gt;的方式遍历才会使用 next 节点。如果使用 &lt;code&gt;get&lt;/code&gt; ，则因为遍历查找效率低下。&lt;/li&gt;
&lt;li&gt;新增，ArrayList 可能会需要&lt;strong&gt;扩容&lt;/strong&gt;，中间插入时，ArrayList 需要&lt;strong&gt;后移&lt;/strong&gt;插入位置之后的所有元素。LinkedList &lt;strong&gt;直接修改&lt;/strong&gt; node 的 prev, next 指向，LinkedList 胜出。&lt;/li&gt;
&lt;li&gt;删除，同 2.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;随机访问&lt;/strong&gt;指定位置，ArrayList 直接定位，LinkedList 从头会尾开始查找，&lt;strong&gt;数组胜出&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;综上所述，ArrayList 适合存储和访问数据，LinkedList 则更适合数据的处理，希望你以后在使用时可以合理的选择 List 结构。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最后的话&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;4.672131147541&quot;&gt;
&lt;p&gt;我把我所有文章都开源在 &lt;a href=&quot;https://github.com/niumoo/JavaNotes&quot;&gt;Github.com/niumoo/JavaNotes&lt;/a&gt; ，欢迎 &lt;strong&gt;Star&lt;/strong&gt; 和完善，希望我们一起变得优秀。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;文章有帮助可以点个「&lt;strong&gt;赞&lt;/strong&gt;」或「&lt;strong&gt;分享&lt;/strong&gt;」，都是支持，我都喜欢！&lt;br/&gt;文章每周持续更新，要实时关注我更新的文章以及分享的干货，可以关注「 &lt;strong&gt;未读代码&lt;/strong&gt; 」公众号或者&lt;a href=&quot;https://www.wdbyte.com/&quot;&gt;我的博客&lt;/a&gt;。&lt;br/&gt;&lt;img src=&quot;https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6023eaa2464044668e006df71de87b19~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cb6d9d0609b34451897289a6ec771232~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 13 Aug 2020 00:38:00 +0000</pubDate>
<dc:creator>未读代码</dc:creator>
<og:description>文章已经收录在 Github.com/niumoo/JavaNotes ，更有 Java 程序员所需要掌握的核心知识，欢迎Star和指教。 欢迎关注我的公众号，文章每周更新。 前言 说真的，在 Jav</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/niumoo/p/13494348.html</dc:identifier>
</item>
<item>
<title>【译】GitHub 为什么挂？官方的可行性报告为你解答 - 削微寒</title>
<link>http://www.cnblogs.com/xueweihan/p/13492570.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xueweihan/p/13492570.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202008/759200-20200812193252157-1257908395.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5.9073359073359&quot;&gt;
&lt;p&gt;本文翻译自 GitHub 官方博客《Introducing the GitHub Availability Report》&lt;/p&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://github.blog/2020-07-08-introducing-the-github-availability-report/&quot;&gt;https://github.blog/2020-07-08-introducing-the-github-availability-report/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者：&lt;a href=&quot;https://github.blog/author/keithballinger/&quot;&gt;Keith Ballinger&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;翻译：HelloGitHub-丫丫 | 校对：HelloGitHub-小鱼干&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;什么是可用性报告？&quot;&gt;什么是可用性报告？&lt;/h2&gt;
&lt;p&gt;从历史上看，GitHub 对影响服务可用性的重大事件会发表事后评论。无论我们是分享新的基础设施投资，还是详细的网站停机时间，我们的信念是，可以通过相互学习共同成长为一个行业。 这个月，我们很高兴介绍下 GitHub 可用性报告。&lt;/p&gt;
&lt;h2 id=&quot;你能期待什么？&quot;&gt;你能期待什么？&lt;/h2&gt;
&lt;p&gt;在每个月的第一个星期三，我们将发布一份描述 GitHub 可用性的报告，包括对可能发生的任何事件的描述，并向您介绍我们是如何发展工程系统和响应实践。您会期待这些更新，它包括对已有事件的总结，以及对我们认为是新奇事件的技术解释，并包含帮助世界各地的工程师学习如何大规模改进产品运营的信息。&lt;/p&gt;
&lt;h2 id=&quot;为什么我们要做可行性报告？&quot;&gt;为什么我们要做可行性报告？&lt;/h2&gt;
&lt;p&gt;可用性和性能是一个核心特性，包括 GitHub 如何响应服务中断。我们努力设计高可用、容错系统，我们希望这些每月更新可以回忆起 GitHub 高于 99% 的可用时间。当事情不按计划进行时，比起等待分享特别有趣的事件信息，我们更倾向于告知你所有可能影响你的事件。我们的希望是，通过提高我们的消息透明度、分享我们学到的东西，而不是简单地在状态页面上报告停机时间的分钟，从而让每个人都可以从我们的经验中受益。在 GitHub，我们非常诚挚地对待您的这份信任，我们希望这是您帮助我们对不断改进我们的卓越运营和我们的产品功能负责的一种方式。&lt;/p&gt;
&lt;h2 id=&quot;五月和六月的可用性报告&quot;&gt;五月和六月的可用性报告&lt;/h2&gt;
&lt;p&gt;在 5 月和 6 月，我们经历了四次不同的事件，导致 GitHub.com 缺乏可用性或服务降级。&lt;/p&gt;
&lt;h3 id=&quot;utc-5-月-5-日-00：45（持续-2-小时-24-分钟）&quot;&gt;UTC 5 月 5 日 00：45（持续 2 小时 24 分钟）&lt;/h3&gt;
&lt;p&gt;在事件发生期间，共享数据库表的自动增量 ID 列超过了 MySQL Integer 类型（Railsint（11)）：2147483647 可以表示的大小。当我们试图往列中插入较大整数时，数据库拒绝了该值，Rails 引发了 ActiveModel::RangeError，这导致 API 端的 500s 延迟。&lt;/p&gt;
&lt;p&gt;这影响了依赖于获得安装令牌的 GitHub 应用程序。最受影响的 GitHub 内部应用程序包括 Actions、Pages 和 Dependabot。&lt;/p&gt;
&lt;p&gt;GitHub 的监控系统当前在表达到主键所用大小的 70% 时会发出警报。我们在扩展我们的测试框架，以包含 int / bigint 外键不匹配的 linter。&lt;/p&gt;
&lt;h3 id=&quot;utc-5-月-22-日-16：41（持续-5-小时-09-分钟）&quot;&gt;UTC 5 月 22 日 16：41（持续 5 小时 09 分钟）&lt;/h3&gt;
&lt;p&gt;在原定的维护操作（MySQL 主实例失败）期间，在新升级的 MySQL 主服务器上 MySQL 进程经历了一次新的崩溃。为了减轻崩溃带来的影响，我们手动将流量重定向到原始主服务器。但是，崩溃的 MySQL 主服务器已经提供了大约 6 秒的写流量。此时，启动了从新主服务器恢复副本的操作，这大约需要 4 个小时，集群重新配置需要 1 个小时才能重新启用完全读取能力。在这近 5 个小时里，在 web 见面和 API 中看到数据写入到受影响数据库集群之前，用户可能已经观察到了延迟。&lt;/p&gt;
&lt;p&gt;我们已经运行了多个内部模拟演习（gameday exercise），以应对类似的拓扑不一致，及继续训练我们的故障转移系统以减少故障恢复时间。&lt;/p&gt;
&lt;h3 id=&quot;utc--6-月-19-日-8：-52（持续-51-分钟）&quot;&gt;UTC 6 月 19 日 8： 52（持续 51 分钟）&lt;/h3&gt;
&lt;p&gt;为改进 UI 的更好 A / B 实验工具引入了一种未知的依赖关系，依赖于独立应用提供的特定、动态生成文件的存在。&lt;/p&gt;
&lt;p&gt;在应用部署期间，由于上游应用程序限制了较高的检索率，因此很大一部分的应用程序部署无法生成文件。这导致了参与实验的用户中有一定比例会出现应用程序错误。经过检测，我们能够禁用此文件需求，这将恢复对所有用户的服务。&lt;/p&gt;
&lt;p&gt;接下来，A / B 和多元实验的配置将在内部缓存，以确保依赖关系的成功传播。&lt;/p&gt;
&lt;h3 id=&quot;utc-6-月-29-日-12：03（持续-2-小时-29-分钟）&quot;&gt;UTC 6 月 29 日 12：03（持续 2 小时 29 分钟）&lt;/h3&gt;
&lt;p&gt;作为维护的一部分，数据库团队在 6 月 22 日星期一推出了一个更新版本的 ProxySQL。一周后，我们的一个主数据库集群上的 MySQL 主节点出现故障，并被一个新主机自动替换。几秒钟内，新升级的主服务器崩溃。 &lt;a href=&quot;https://github.com/openark/orchestrator&quot;&gt;Orchestrator&lt;/a&gt; 的防止互相踢皮球机制阻止了随后的自动故障转移。 在我们手动恢复服务后，新的主服务器又开始耗尽 CPU 资源，并再次崩溃。 为了恢复，我们回滚到 ProxySQL 旧版本并禁用了应用程序中 ProxySQL 新版本所需的变更。 完成此操作后，我们可以允许在主节点上进行写操作而不会崩溃。&lt;/p&gt;
&lt;p&gt;我们正在分析应用程序日志、MySQL 核心转储和我们的内部遥测，作为继续调查 CPU 耗尽问题的一部分，以避免类似的故障模式继续。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;作为一个组织，我们继续在可行性方面投入大量资金。我们把这里讨论的每一件事视为一个宝贵的机会来学习和成长。我们的系统和流程继续基于这些学习而发展，我们期待着在未来的更新中分享我们的进展。&lt;/p&gt;
&lt;p&gt;请按照我们的&lt;a href=&quot;https://githubstatus.com/&quot;&gt;状态页面&lt;/a&gt;进行实时更新，并查看我们的博客下个月的可用性报告。&lt;/p&gt;
&lt;p&gt;2020 年 7 月 2 日&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;HelloGitHub 推出的「译文亦舞」系列&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果小伙伴们有什么有趣的英文文章也可以留言把链接发给我（题材：GitHub、编程、程序员）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202008/759200-20200812193312212-1666601388.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关注我们的公众号，加入我们吧&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 13 Aug 2020 00:31:00 +0000</pubDate>
<dc:creator>削微寒</dc:creator>
<og:description>本文翻译自 GitHub 官方博客《Introducing the GitHub Availability Report》 原文链接：https://github.blog/2020-07-08-in</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xueweihan/p/13492570.html</dc:identifier>
</item>
<item>
<title>初识ABP vNext（1）：开篇计划&amp;基础知识 - xhznl</title>
<link>http://www.cnblogs.com/xhznl/p/13491480.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xhznl/p/13491480.html</guid>
<description>&lt;p&gt;ABP vNext（以下简称ABP）的前身是asp.net boilerplate（老版abp），它不是一个简单的版本更新，而是完全基于.NET Core的重写。之前有听说过ABP框架，但是一直没有去详细了解。最近认真学习了一下，准备记录下自己的一些心得，计划分为3部分来进行：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;ABP基础（就是官网上一些基本的功能）&lt;/li&gt;
&lt;li&gt;ABP实战（使用ABP+vue开发一个简单项目）&lt;/li&gt;
&lt;li&gt;ABP模块化（微服务简单介绍）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;首先，这是以一个0基础的视角去写的，所以会比较基础，适合新手。文中如果有不对的地方，大家可以帮我指出来相互学习。。。&lt;/p&gt;

&lt;p&gt;ABP官网：&lt;a href=&quot;https://www.abp.io/&quot;&gt;https://www.abp.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ABP GitHub：&lt;a href=&quot;https://github.com/abpframework/abp&quot;&gt;https://github.com/abpframework/abp&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;要学习ABP，首先肯定要认真看一下官方的文档，虽然目前官方文档还不完整；然后对哪一部分不理解的，可以适当的阅读一下源码。&lt;/p&gt;
&lt;p&gt;ABP是基于DDD:Domain-Driven Design（领域驱动设计）去开发的，当然框架本身不强制你使用DDD，但是他建议把DDD作为最佳实践。如果了解DDD，并且使用过老版本abp的话，看官方文档可能就比较轻松，反之则会比较吃力。。。首先DDD理论就非常抽象和复杂，要深刻理解它并不容易；其次是ABP内部使用了很多开源组件，比如EF Core，IdentityServer4，Autofac，AutoMapper，Swagger等等，所以也需要对这些组件有所了解。&lt;/p&gt;
&lt;p&gt;本篇简单介绍一下ABP官方文档上一些重要的关键字，先理解这些关键字，才能更好的进一步学习。&lt;/p&gt;
&lt;h2 id=&quot;审计audit&quot;&gt;审计(Audit)&lt;/h2&gt;
&lt;p&gt;审计是用于追踪数据变化的过程。平时开发中，你一定经常见到类似创建时间、创建人、修改时间、修改人等属性，这些属性就是用于数据审计。ABP框架提供了一些接口和基类来标准化这些属性，并自动设置它们的值；并且ABP提供了一个可扩展的审计日志系统，自动化的根据约定记录审计日志，并提供配置来控制审计日志的级别。ABP中审计相关基类/接口有：&lt;code&gt;IAuditedObject&lt;/code&gt;、&lt;code&gt;AuditedEntity&lt;/code&gt;、&lt;code&gt;AuditedAggregateRoot&lt;/code&gt;等等。&lt;/p&gt;
&lt;h2 id=&quot;本地化localization&quot;&gt;本地化(Localization)&lt;/h2&gt;
&lt;p&gt;使应用程序支持多国语言。ABP的本地化系统与ASP.NET Core的本地化兼容。&lt;/p&gt;
&lt;h2 id=&quot;事件总线event-bus&quot;&gt;事件总线(Event Bus)&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;事件总线是对观察者（发布-订阅）模式的一种实现。它是一种集中式事件处理机制，允许不同的组件之间进行彼此通信而又不需要相互依赖，达到一种解耦的目的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果没有接触过Event Bus，可能不太好理解。一个不太恰当的例子：A需要租房，B需要把房子租出去，A想直接找到B是比较困难的，A也不想去认识B，所以才有房产中介C，C就是Event Bus；B提前跟C说我的房子需要出租，A跟C说我给你钱你帮我租一个房，那么C很容易就帮A找到B完成租房，A甚至不需要知道B是谁，这里A就是事件的发布者，B是事件的订阅者。ABP支持本地Event Bus和分布式Event Bus。&lt;/p&gt;
&lt;h2 id=&quot;多租户multi-tenancy-technology&quot;&gt;多租户(multi-tenancy technology)&lt;/h2&gt;
&lt;p&gt;多租户是一种软件架构技术，这种架构可以让多个租户共用相同的系统，并且可以确保各租户间数据的隔离性。相信很多人都遇到过类似需求，同一个系统中根据不同客户区分数据；通常我们会在数据库表中增加一个客户Id作为标识，或者根据不同客户读取不同的数据库，这都是多租户数据隔离的实现方式，想自己很好的实现多租户还是很繁琐的。ABP的多租户模块提供了创建多租户应用程序的基本功能，可以很轻松的帮你实现多租户。&lt;/p&gt;
&lt;h2 id=&quot;ddd分层&quot;&gt;DDD分层&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;表示层&lt;/strong&gt;: 为用户提供接口，使用应用层实现与用户交互。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;应用层&lt;/strong&gt;: 表示层与领域层的中介，编排业务对象执行特定的应用程序任务，使用应用程序逻辑实现用例。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;领域层&lt;/strong&gt;: 包含业务对象以及业务规则，是应用程序的核心。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;基础设施层&lt;/strong&gt;: 提供通用的技术功能，支持更高的层，主要使用第三方类库。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;实体entity&quot;&gt;实体(Entity)&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;一个没有从其属性，而是通过连续性和身份的线索来定义的对象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;官方文档中这句话非常难理解。。。&lt;/p&gt;
&lt;p&gt;简单来说，当一个对象只能由他的标识（Id）来区分，而不是从其他属性来区分时，这种对象被称为实体。比如有很多叫“张三”的男人，你不能通过姓名和性别来区分到底是哪个张三，只能通过Id。实体是可以持续变化的，我们可以对实体进行多次修改，但是无论怎么修改，实体始终拥有它唯一的标识。DDD中的实体通常都是充血模型，充血模型就是实体中不光有属性，还会包含行为（方法），反之DTO，ViewModel就是典型的贫血模型。实体通常映射到关系型数据库的表中，ABP中实体相关的基类/接口有：&lt;code&gt;Entity&lt;/code&gt;、&lt;code&gt;IEntity&lt;/code&gt;、&lt;code&gt;AuditedEntity&lt;/code&gt;等等。&lt;/p&gt;
&lt;h2 id=&quot;值对象value-object&quot;&gt;值对象(Value Object)&lt;/h2&gt;
&lt;p&gt;值对象和实体恰好相反，它不需要唯一标识，并且它不可以被改变。值对象通常是用来度量和描述事物，当你只关注某个对象的属性时，该对象便可以是一个值对象。比如“北京”就是“北京”，不存在Id=1或者Id=2的北京的说法。当然，值对象虽然不存在唯一标识，但是不代表它在数据库中就没有Id主键。。。&lt;/p&gt;
&lt;h2 id=&quot;聚合根aggregate-root&quot;&gt;聚合根(Aggregate Root)&lt;/h2&gt;
&lt;p&gt;聚合是业务逻辑紧密关联的实体和值对象组合而成，聚合是数据修改和持久化的基本单元，聚合后产生的根实体称为聚合根。若一个聚合仅有一个实体，那这个实体就是聚合根。聚合根被视为一个单元，你不能单独去修改聚合根中的子实体。例如，某个业务流程中，会操作A、B、C、D四个对象（简单理解为数据库表），那么将ABCD聚合，产生一个聚合根E，对外部来说只需要操作E就可以了，领域内部会处理好ABCD。这样一方面避免了多个对象的混乱，另一方面也保证了数据的完整性，不会出现AB操作成功了，CD操作失败了，导致数据库产生脏数据。&lt;/p&gt;
&lt;p&gt;聚合根引用聚合根：通过ID。&lt;/p&gt;
&lt;p&gt;聚合根引用实体：通过对象（导航属性）。&lt;/p&gt;
&lt;p&gt;聚合根引用值对象：通过对象（导航属性）。&lt;/p&gt;
&lt;h2 id=&quot;仓储repository&quot;&gt;仓储(Repository)&lt;/h2&gt;
&lt;p&gt;仓储用于操作领域对象（实际就是操作数据库），通常会为每个聚合根或不同的实体创建对应的仓储。ABP也提供了通用的泛型仓储：&lt;code&gt;IRepository&amp;lt;TEntity, TKey&amp;gt;&lt;/code&gt;，内置了增删改查基本功能，直接注入就可以使用。&lt;/p&gt;
&lt;h2 id=&quot;应用服务application-services&quot;&gt;应用服务(Application Services)&lt;/h2&gt;
&lt;p&gt;应用层处于展示层与领域层之间，展示层通常调用应用服务，应用服务调用领域然后返回数据给展示层。展示层也可以直接调用领域。APB中应用服务相关的基类/接口有：&lt;code&gt;IApplicationService&lt;/code&gt;、&lt;code&gt;ApplicationService&lt;/code&gt;、&lt;code&gt;ICrudAppService&lt;/code&gt;、&lt;code&gt;CrudAppService&lt;/code&gt;等等。&lt;/p&gt;
&lt;h2 id=&quot;数据传输对象dto&quot;&gt;数据传输对象(DTO)&lt;/h2&gt;
&lt;p&gt;通常领域对象不适合直接在应用层与展示层之间传递，比如User中的Passwod字段，这时候就需要用到DTO，DTO和ViewModel类似。ABP提供了一些DTO基类/接口：&lt;code&gt;IEntityDto&lt;/code&gt;、&lt;code&gt;EntityDto&lt;/code&gt;、&lt;code&gt;AuditedEntityDto&lt;/code&gt;等等。&lt;/p&gt;
&lt;h2 id=&quot;工作单元unit-of-work&quot;&gt;工作单元(Unit Of Work)&lt;/h2&gt;
&lt;p&gt;UOW模式是为了保证一次业务操作的数据完整性。ABP框架的UOW实现提供了对应用程序中的数据库连接和事务范围的抽象和控制，使用ABP的话通常你不用自己去写数据库事务相关代码。实际上工作单元不一定非要创建数据库事务，比如HTTP GET请求就不会启动事务性UOW，它们仍然启动UOW，但不创建数据库事务。这一切都由ABP框架自动完成。&lt;/p&gt;

&lt;p&gt;目前关于ABP的学习资源比较少，官方的文档也还没写完。。。不过ABP的作者最近开始发布自己的教学视频了，有条件的可以自行搜索一下。&lt;/p&gt;
</description>
<pubDate>Thu, 13 Aug 2020 00:20:00 +0000</pubDate>
<dc:creator>xhznl</dc:creator>
<og:description>前言 ABP vNext（以下简称ABP）的前身是asp.net boilerplate（老版abp），它不是一个简单的版本更新，而是完全基于.NET Core的重写。之前有听说过ABP框架，但是一直</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xhznl/p/13491480.html</dc:identifier>
</item>
<item>
<title>在.NET Core中使用MongoDB明细教程(1):驱动基础及文档插入 - 依乐祝</title>
<link>http://www.cnblogs.com/yilezhu/p/13493195.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yilezhu/p/13493195.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1377250/202008/1377250-20200812213830922-252214510.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;MongoDB，被归类为&lt;a href=&quot;https://en.wikipedia.org/wiki/NoSQL&quot;&gt;NoSQL&lt;/a&gt;数据库，是一个以类JSON格式存储数据的面向文档的数据库系统.MongoDB在底层以名为bson的二进制编码格式表示JSON文档，MongoDB bson实现是轻量级、快速和高度可遍历的。这意味着MongoDB为用户提供了JSON文档的易用性和灵活性，以及轻量级二进制格式的速度和丰富性。其实在我看来在很多场景中MongoDb都可以取代关系型数据库。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;作者：依乐祝&lt;br/&gt;原文地址：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在本教程系列中，我将向您展示如何使用.NET驱动程序提供的CRUD函数在.NET应用程序中使用MongoDB。MongoDB&lt;a href=&quot;https://docs.mongodb.com/ecosystem/drivers/&quot;&gt;驱动&lt;/a&gt;允许您使用来自不同编程语言的MongoDB。在本系列教程中，我们将使用&lt;a href=&quot;https://docs.mongodb.com/ecosystem/drivers/&quot;&gt;C#驱动程序&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&quot;准备工作&quot;&gt;准备工作&lt;/h3&gt;
&lt;p&gt;在开始之前，我们需要打开VisualStudio并创建一个新项目。我将在本教程中使用一个控制台项目。为了演示我们需要安装对应的NuGet包。这里我们需要三个NuGet包，即：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;http://www.nuget.org/packages/mongodb.bson&quot;&gt;&lt;strong&gt;MongoDB.Bson&lt;/strong&gt;&lt;/a&gt;独立的BSON库，它处理POCOS到BSON类型的转换(这是MongoDB的文件格式)，反之亦然。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.nuget.org/packages/mongodb.driver.core&quot;&gt;&lt;strong&gt;MongoDB.Driver.Core&lt;/strong&gt;&lt;/a&gt;：--它本身就是一个驱动程序，具有驱动程序的核心组件(如如何连接到&lt;code&gt;mongod&lt;/code&gt;实例，连接池)，用于从.net到MongoDB的通信，并且它依赖于&lt;code&gt;MongoDB.Bson&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.nuget.org/packages/mongodb.driver&quot;&gt;&lt;strong&gt;MongoDB.Driver&lt;/strong&gt;&lt;/a&gt;*依赖于&lt;code&gt;Driver.Core&lt;/code&gt;这反过来又依赖于&lt;code&gt;MongoDB.Bson&lt;/code&gt;。它更容易在核心组件驱动程序上使用api，并具有异步方法，并支持&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/bb308959.aspx&quot;&gt;Linq&lt;/a&gt;.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;运行以下命令，会同时安装上面三个包：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Install-Package MongoDB.Driver
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;访问数据库&quot;&gt;访问数据库&lt;/h3&gt;
&lt;p&gt;若要连接到数据库，请使用&lt;code&gt;MongoClient&lt;/code&gt;类访问MongoDB实例，并通过它选择要使用的数据库。这个类有四个构造函数。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;默认情况下，连接到端口27017上的实例的无参数结构器：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;var client = new MongoClient();
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;接受连接字符串：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;var connectionString = &quot;mongodb://localhost:27017&quot;;
var client = new MongoClient(connectionString);
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;接受一个&lt;a href=&quot;http://api.mongodb.com/csharp/current/html/T_MongoDB_Driver_MongoUrl.htm&quot;&gt;&lt;code&gt;MongoUrl&lt;/code&gt;&lt;/a&gt;的实例，而MongoUrl跟使用&lt;code&gt;connectionstring&lt;/code&gt;构造函数很类似，您可以通过使用默认构造函数来创建此类实例：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;var client = new MongoClient(new MongoUrl(&quot;mongodb://localhost:27017&quot;));
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;.或者使用静态的&lt;code&gt;Create&lt;/code&gt;方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;var client = new MongoClient(MongoUrl.Create(&quot;mongodb://localhost:27017&quot;));
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;最后一个是接受一个&lt;code&gt;MongoClientSettings&lt;/code&gt;的构造函数，这里你可以设置很多东西，比如凭据、连接生存期和超时时间等等。下面是两个例子：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;var settings1 = MongoClientSettings
        .FromUrl(MongoUrl.Create(&quot;mongodb://localhost:27017&quot;));

var settings2 = new MongoClientSettings
          {
          Server = new MongoServerAddress(&quot;localhost&quot;, 27017),
          UseSsl = false
          };

var client1 = new MongoClient(settings1);
var client2 = new MongoClient(settings2);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通常，你只需要使用包含一个&lt;code&gt;connectionString&lt;/code&gt;参数的构造函数就可以了，我们将在本教程中使用此构造函数。代码如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;using MongoDB.Driver;
using System;
namespace MongoDBDemo
{
    class Program
    {
        static void Main(string[] args)
        {
            Test();
            Console.ReadLine();
        }

        static void Test()
        {
            var connectionString = &quot;mongodb://localhost:27017&quot;;

            var client = new MongoClient(connectionString);
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用MongoClient实例，我们可以做很多事情，如删除数据库、获取数据库或检索服务器上的数据库名称列表等。这里没有一个用于创建数据库方法，因为一旦您选择一个数据库并将数据插入其中，它将自动创建数据库。&lt;/p&gt;
&lt;p&gt;这里我们使用的是&lt;code&gt;GetDatabase&lt;/code&gt;方法，它将自动为我们创建一个数据库。如下所示获取一个名为&lt;code&gt;bookstore&lt;/code&gt; 的数据库：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;IMongoDatabase db = client.GetDatabase(&quot;bookstore&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个&lt;a href=&quot;http://api.mongodb.com/csharp/current/html/M_MongoDB_Driver_MongoClient_GetDatabase.htm&quot;&gt;GetDatabase&lt;/a&gt;方法返回一个对象，该对象是数据库的表示形式，我们可以从该对象访问不同的集合并操作数据库。这个&lt;code&gt;MongoClient&lt;/code&gt;对象是线程安全的，因此您可以将其放在静态字段中，使其成为可以通过DI容器随时获得的Singleton对象，或者使用相同的连接设置实例化一个新的字段(下面将使用相同的连接池)；通过这个对象，您可以选择您想要使用的任何数据库。&lt;/p&gt;
&lt;p&gt;使用数据库对象，可以从数据库创建、重命名、检索或获取集合列表。文档存储在集合中，如果你对SQL比较熟悉的话，可以将集合视为表，将文档视为表中的记录。&lt;/p&gt;
&lt;h3 id=&quot;创建一个集合&quot;&gt;创建一个集合&lt;/h3&gt;
&lt;p&gt;若要创建集合，我们将使用 &lt;code&gt;IMongoDatabase&lt;/code&gt;对象的&lt;a href=&quot;http://api.mongodb.com/csharp/current/html/M_MongoDB_Driver_IMongoDatabase_CreateCollection.htm&quot;&gt;CreateCollection&lt;/a&gt; 或&lt;a href=&quot;http://api.mongodb.com/csharp/current/html/M_MongoDB_Driver_IMongoDatabase_CreateCollectionAsync.htm&quot;&gt;CreateCollection Async&lt;/a&gt;方法来进行 。该方法接受三个参数(最后两个参数是可选的)：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;集合的名称。&lt;/li&gt;
&lt;li&gt;创建集合的选项&lt;/li&gt;
&lt;li&gt;取消令牌&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt; void CreateCollection(
                string name,
                CreateCollectionOptions options = null,
                CancellationToken cancellationToken = default);

Task CreateCollectionAsync(
                string name, 
                CreateCollectionOptions options = null, 
                CancellationToken cancellationToken = default);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个&lt;a href=&quot;http://api.mongodb.com/csharp/current/html/T_MongoDB_Driver_CreateCollectionOptions.htm&quot;&gt;CreateCollectionOptions&lt;/a&gt;指定集合的特殊设置，例如它应该包含的最大文档数。下面是一个例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt; IMongoDatabase database = client.GetDatabase(&quot;bookstore&quot;);
 await database.CreateCollectionAsync(&quot;books&quot;, new CreateCollectionOptions
            {
                Capped=true,
                MaxDocuments=100,
            });
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;大多数情况下，我们只需要创建一个集合，并使用默认的创建设置，因此我们只需要传递一个&lt;code&gt;collection&lt;/code&gt;的名称即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;await database.CreateCollectionAsync(&quot;books&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建集合的另一种方法是使用&lt;a href=&quot;http://api.mongodb.com/csharp/current/html/M_MongoDB_Driver_IMongoDatabase_GetCollection__1.htm&quot;&gt;GetCollection&lt;/a&gt;它接受集合的名称和集合设置选项作为参数。使用此方法，即使不存在该名称的集合，一旦创建文档，它也会在此之前创建该集合。这通常是您想要的方式，因此这里建议只在你需要创建一个有上限的集合时才使用CREATE进行集合的创建。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.mongodb.com/manual/core/capped-collections/&quot;&gt;Capped&lt;/a&gt;集合是一个固定大小的集合，当它达到最大值时，它会自动覆盖其最旧的条目。GetCollection方法是泛型的，在调用此方法时需要指定文档类型。该类型表示要处理的对象/文档的类型。它可以被强类型化为我们定义的任何类，或者使用&lt;code&gt;BsonDocument&lt;/code&gt;类型表示一个允许我们处理集合中任何文档形状的动态架构。&lt;/p&gt;
&lt;h3 id=&quot;获取一个集合&quot;&gt;获取一个集合&lt;/h3&gt;
&lt;p&gt;在讨论了创建集合之后，还需要一个额外的步骤来检查集合是否存在，创建它，然后将文档添加到集合中。如果集合不存在，&lt;code&gt;GetCollection&lt;/code&gt;会自动创建一个集合，并将文档添加到该集合中。因此，即使有一个&lt;code&gt;CreateCollection&lt;/code&gt;，我们通常还是希望使用&lt;code&gt;GetCollection&lt;/code&gt;。就像数据库一样，集合也是线程安全的，并且创建起来非常j简单。为了获得一个集合，我们调用&lt;code&gt;GetCollection&lt;/code&gt;方法来指定文档类型&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt; static async Task TestAsync()
        {
            var connectionString = &quot;mongodb://localhost:27017&quot;;
            var client = new MongoClient(connectionString);
            IMongoDatabase database = client.GetDatabase(&quot;bookstore&quot;);
            IMongoCollection&amp;lt;BsonDocument&amp;gt; collection = database.GetCollection&amp;lt;BsonDocument&amp;gt;(&quot;books&quot;);
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;http://api.mongodb.com/csharp/current/html/T_MongoDB_Bson_BsonDocument.htm&quot;&gt;BsonDocument&lt;/a&gt;是来自MongoDB.Bson包的类型，它表示BSON文档，使用这种类型，我们可以处理来自数据库的任何形状的数据。这&lt;a href=&quot;http://api.mongodb.com/csharp/current/html/N_MongoDB_Bson.htm&quot;&gt;包&lt;/a&gt;包含了所有基本BSON类型和其他一些用于使用BSON的方法。&lt;/p&gt;
&lt;p&gt;在这个包中，我们有表示BSON类型的类，以及如何在.NET类型和BsonValue之间映射。下面简单列举一些：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;我们已经讨论过的BsonDocument类型&lt;/li&gt;
&lt;li&gt;表示BSON元素的BsonElement&lt;/li&gt;
&lt;li&gt;BsonValue是各种子类使用的抽象基类，如BsonString、BsonInt 32等。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这个&lt;code&gt;BsonDocument&lt;/code&gt;是字符串到bson值的字典，因此我们可以像初始化字典一样来进行初始化：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt; var document = new BsonDocument
            {
                  {&quot;bookname&quot;, BsonValue.Create(&quot;.net core3.1 with mongodb&quot;)},
                  {&quot;description&quot;, new BsonString(&quot;这是一本关于在.net core3.1中使用mongodb进行开发的教程&quot;)},
                  {&quot;tags&quot;, new BsonArray(new[] {&quot;.net core&quot;, &quot;mongodb&quot;}) },
                  {&quot;remark&quot;, &quot;C#是世界上最好的语言&quot; },
                  {&quot;publishyear&quot;, 2020 }
            };
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;.或者使用&lt;code&gt;Add&lt;/code&gt;方法，该方法具有多个重载：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt; var document2 = new BsonDocument();
            document2.Add(&quot;bookname&quot;, &quot;.net core3.1 with mongodb2&quot;);
            document2.Add(&quot;description&quot;, &quot;这是一本关于在.net core3.1中使用mongodb进行开发的教程2&quot;);
            document2.Add(&quot;tags&quot;, new BsonArray(new[] { &quot;.net core&quot;, &quot;mongodb&quot; }));
            document2.Add(&quot;remark&quot;, &quot;C#是世界上最好的语言&quot;);
            document2.Add(&quot;publishyear&quot;, 2020);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;.或者使用索引器：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;var document3 = new BsonDocument();
            document3[&quot;bookname&quot;] = &quot;.net core3.1 with mongodb3&quot;;
            document3[&quot;description&quot;] = &quot;这是一本关于在.net core3.1中使用mongodb进行开发的教程3&quot;;
            document3[&quot;tags&quot;] = new BsonArray(new[] { &quot;.net core&quot;, &quot;mongodb&quot; });
            document3[&quot;remark&quot;] = &quot;C#是世界上最好的语言&quot;;
            document3[&quot;publishyear&quot;] = 2020;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;创建插入文档&quot;&gt;创建/插入文档&lt;/h3&gt;
&lt;p&gt;文档存储在集合中，在查看了创建和获取集合之后，我们将继续在集合中插入新文档。Mongo集合实例提供了一次插入单个文档和一次插入多个文档的方法。&lt;/p&gt;
&lt;p&gt;接下来让我们一步一步来进行实现吧：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;获取一个&lt;code&gt;IMongocollection&lt;/code&gt;类型的对象，该对象表示我们要使用的集合：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt; IMongoCollection&amp;lt;BsonDocument&amp;gt; collection = database.GetCollection&amp;lt;BsonDocument&amp;gt;(&quot;books&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;然后创建我们想要插入的文档：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt; var document = new BsonDocument
            {
                  {&quot;bookname&quot;, BsonValue.Create(&quot;.net core3.1 with mongodb&quot;)},
                  {&quot;description&quot;, new BsonString(&quot;这是一本关于在.net core3.1中使用mongodb进行开发的教程&quot;)},
                  {&quot;tags&quot;, new BsonArray(new[] {&quot;.net core&quot;, &quot;mongodb&quot;}) },
                  {&quot;remark&quot;, &quot;C#是世界上最好的语言&quot; },
                  {&quot;publishyear&quot;, 2020 }
            };
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;最后插入该文件：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;await collection.InsertOneAsync(document);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;要想看到这个效果，让我们开始一个&lt;code&gt;mongod&lt;/code&gt;实例，并从控制台监视事件的同时运行以下完整代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;class Program
    {
        static async Task Main(string[] args)
        {
            await TestAsync();
            Console.ReadLine();
        }

        /// &amp;lt;summary&amp;gt;
        /// 测试代码
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        static async Task TestAsync()
        {
            var connectionString = &quot;mongodb://localhost:27017&quot;;

            var client = new MongoClient(connectionString);
            IMongoDatabase database = client.GetDatabase(&quot;bookstore&quot;);
            IMongoCollection&amp;lt;BsonDocument&amp;gt; collection = database.GetCollection&amp;lt;BsonDocument&amp;gt;(&quot;books&quot;);
            var document = new BsonDocument
            {
                  {&quot;bookname&quot;, BsonValue.Create(&quot;.net core3.1 with mongodb&quot;)},
                  {&quot;description&quot;, new BsonString(&quot;这是一本关于在.net core3.1中使用mongodb进行开发的教程&quot;)},
                  {&quot;tags&quot;, new BsonArray(new[] {&quot;.net core&quot;, &quot;mongodb&quot;}) },
                  {&quot;remark&quot;, &quot;C#是世界上最好的语言&quot; },
                  {&quot;publishyear&quot;, 2020 }
            };
            await collection.InsertOneAsync(document);
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;...启动你的mongo服务并运行程序，看到如下所示的数据：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1377250/202008/1377250-20200812213921826-1033313422.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里的&lt;code&gt;InsertOneAsync&lt;/code&gt;方法还有一个同步的版本&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;collection.InsertOne(document);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们还可以使用&lt;code&gt;InsertMany&lt;/code&gt;或&lt;code&gt;InsertManyAsync&lt;/code&gt;方法进行批量插入。假设我们图书馆又来了三本新书，我们可以使用这个方法同时插入所有的内容，并且它们将被插入到一个批中(假设您使用的是MongoDB2.6或更高版本)。要查看此操作，我们将继续更新代码并运行应用程序：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;class Program
    {
        static async Task Main(string[] args)
        {
            await TestAsync();
            Console.ReadLine();
        }

        /// &amp;lt;summary&amp;gt;
        /// 测试代码
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        static async Task TestAsync()
        {
            var connectionString = &quot;mongodb://localhost:27017&quot;;
            var client = new MongoClient(connectionString);
            IMongoDatabase database = client.GetDatabase(&quot;bookstore&quot;);
            IMongoCollection&amp;lt;BsonDocument&amp;gt; collection = database.GetCollection&amp;lt;BsonDocument&amp;gt;(&quot;books&quot;);
            await collection.InsertManyAsync(GetBooks());
          
        }

        static IEnumerable&amp;lt;BsonDocument&amp;gt; GetBooks() =&amp;gt; new List&amp;lt;BsonDocument&amp;gt; {
            new BsonDocument
            {
                  {&quot;bookname&quot;, BsonValue.Create(&quot;.net core3.1 with mongodb1&quot;)},
                  {&quot;description&quot;, new BsonString(&quot;这是一本关于在.net core3.1中使用mongodb进行开发的教程1&quot;)},
                  {&quot;tags&quot;, new BsonArray(new[] {&quot;.net core&quot;, &quot;mongodb&quot;}) },
                  {&quot;remark&quot;, &quot;C#是世界上最好的语言&quot; },
                  {&quot;publishyear&quot;, 2020 }
            },
            new BsonDocument
            {
                  {&quot;bookname&quot;, BsonValue.Create(&quot;.net core3.1 with mongodb2&quot;)},
                  {&quot;description&quot;, new BsonString(&quot;这是一本关于在.net core3.1中使用mongodb进行开发的教程2&quot;)},
                  {&quot;tags&quot;, new BsonArray(new[] {&quot;.net core&quot;, &quot;mongodb&quot;}) },
                  {&quot;remark&quot;, &quot;C#是世界上最好的语言&quot; },
                  {&quot;publishyear&quot;, 2020 }
            },
            new BsonDocument
            {
                  {&quot;bookname&quot;, BsonValue.Create(&quot;.net core3.1 with mongodb2&quot;)},
                  {&quot;description&quot;, new BsonString(&quot;这是一本关于在.net core3.1中使用mongodb进行开发的教程2&quot;)},
                  {&quot;tags&quot;, new BsonArray(new[] {&quot;.net core&quot;, &quot;mongodb&quot;}) },
                  {&quot;remark&quot;, &quot;C#是世界上最好的语言&quot; },
                  {&quot;publishyear&quot;, 2020 }
            },
        };
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这时候我们再进行夏查询，看到所有数据都入库了&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2767091-d06745388e0fa700.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;1597204359324.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;除了使用&lt;code&gt;BsonDocument&lt;/code&gt;，我们通常预先知道我们想要处理的是什么样的数据，并且我们可以为它们创建自定义的.NET类。遵循我们使用&lt;code&gt;books&lt;/code&gt;集合的事例，让我们创建一个&lt;code&gt;Book&lt;/code&gt;类并插入使用此类表示的新书籍：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;internal class Book
{
        public string BookName { get; set; }
        public string Description { get; set; }
        public IEnumerable&amp;lt;string&amp;gt; Tags { get; set; }
        public string Remark { get; set; }
        public int PublishYear { get; set; }
}
class Program
    {
        static async Task Main(string[] args)
        {
            await TestAsync();
            Console.ReadLine();
        }

        /// &amp;lt;summary&amp;gt;
        /// 测试代码
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        static async Task TestAsync()
        {
            var connectionString = &quot;mongodb://localhost:27017&quot;;
            var client = new MongoClient(connectionString);
            IMongoDatabase database = client.GetDatabase(&quot;bookstore&quot;);
            IMongoCollection&amp;lt;Book&amp;gt; collection = database.GetCollection&amp;lt;Book&amp;gt;(&quot;books&quot;);
            await collection.InsertManyAsync(GetBooks());
        }

        static IEnumerable&amp;lt;Book&amp;gt; GetBooks() =&amp;gt; new List&amp;lt;Book&amp;gt; { 
            new Book
            {
                BookName=&quot;.net core3.1 with mongodb21&quot;,
                Description=&quot;这是一本关于在.net core3.1中使用mongodb进行开发的教程21&quot;,
                Tags=new List&amp;lt;string&amp;gt;{ &quot;.net core&quot;, &quot;mongodb&quot;},
                Remark=&quot;C#是世界上最好的语言&quot;,
                PublishYear=2020,
            },
            new Book
            {
                BookName=&quot;.net core3.1 with mongodb22&quot;,
                Description=&quot;这是一本关于在.net core3.1中使用mongodb进行开发的教程22&quot;,
                Tags=new List&amp;lt;string&amp;gt;{ &quot;.net core&quot;, &quot;mongodb&quot;},
                Remark=&quot;C#是世界上最好的语言&quot;,
                PublishYear=2020,
            },
            new Book
            {
                BookName=&quot;.net core3.1 with mongodb23&quot;,
                Description=&quot;这是一本关于在.net core3.1中使用mongodb进行开发的教程23&quot;,
                Tags=new List&amp;lt;string&amp;gt;{ &quot;.net core&quot;, &quot;mongodb&quot;},
                Remark=&quot;C#是世界上最好的语言&quot;,
                PublishYear=2020,
            },
        };
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用上面的代码，我们可以将集合的文档类型更改为新类，并调用&lt;code&gt;InsertManyAsync&lt;/code&gt;方法。运行下程序，然后查询下集合数据如下所示：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1377250/202008/1377250-20200812213950938-870099150.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;通过上面的示例代码的讲解，你应该对如何通过MongoDB .NET 驱动程序来操作MongoDB集合跟文档有所了解了，并且你也应该知道如何进行文档的插入，在下一篇文章中，我将介绍如何对文档进行检索以及为此构建的各种filter及linq查询技巧，有兴趣的可以关注下我的公众号“DotNetCore实战”第一时间进行更新！&lt;/p&gt;
&lt;p&gt;参考资料：&lt;a href=&quot;https://www.codementor.io/@pmbanugo/working-with-mongodb-in-net-1-basics-g4frivcvz&quot;&gt;https://www.codementor.io/@pmbanugo/working-with-mongodb-in-net-1-basics-g4frivcvz&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 12 Aug 2020 23:53:00 +0000</pubDate>
<dc:creator>依乐祝</dc:creator>
<og:description>MongoDB，被归类为NoSQL数据库，是一个以类JSON格式存储数据的面向文档的数据库系统.MongoDB在底层以名为bson的二进制编码格式表示JSON文档，MongoDB bson实现是轻量级</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yilezhu/p/13493195.html</dc:identifier>
</item>
<item>
<title>[开源] .Net ORM FreeSql 1.8.0-preview 最新动态播报（番号：我还活着） - nicye</title>
<link>http://www.cnblogs.com/kellynic/p/13494164.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kellynic/p/13494164.html</guid>
<description>&lt;p&gt;FreeSql 是 .NET 开源生态下的 ORM 轮子，在一些人眼里属于重复造轮子：不看也罢。就像昨天有位朋友截图某培训直播发给我看，内容为：“FreeSQL（个人产品），自己玩可以，不要商用。ORM框架：1.安全、稳定（更新稳定、有BUG有人修复，有人升级）”。&lt;/p&gt;
&lt;p&gt;这突出其来的“关爱”，让我的内心毫无波澜，确实是毫无波澜，比起当初 FreeSql 初出茅庐之时的讽刺友好得多。写在开头的这些内容并不祈求这部分人改变观念，该黑的请继续黑，黑总比没有关注好，是吧？我无所谓你，但是别人呢？麻烦你们不要无脑抨击，你们这种行为不知道挽杀了多少社区项目。&lt;/p&gt;
&lt;p&gt;2018 年 12 月份开发 FreeSql 到现在，1859 颗星，412 Issues，18 PR，170K 包下载量。说明还是有开发者关注和喜爱，只要有人关注，就不会停更不修 BUG 一说。大家有兴趣可以看看更新记录，看看我们的代码提交量，4700+ 单元测试不说非常多，我个人觉得已经超过很多国产项目，有兴趣的再去隔壁“国产第一” ORM 上看看，对比对比！如果不更新了，请把位置让出来；如果有BUG修复不了，请让 FreeSql 来；如果不好用，就不要搞一堆 SEO 害人入坑；如果。。。如果。。。&lt;/p&gt;
&lt;p&gt;这不是挑衅，看到对方的 issues 实在不忍，看到对方的源码，哇哦，单元测试在哪里？好了不废话了。。&lt;/p&gt;
&lt;p&gt;20个月了，FreeSql 还活着，而且生命力顽强见下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/31407/202008/31407-20200813060133069-1556358591.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;预告：年底发布 2.0.0 版本将冻结新功能开发，不再制造新 BUG，一心修复老功能引出的 BUG，完善文档。&lt;/p&gt;
&lt;p&gt;本文将介绍在过去的三个月完成的一些有意义的功能介绍。&lt;/p&gt;

&lt;p&gt;FreeSql 是 .Net ORM，能支持 .NetFramework4.0+、.NetCore、Xamarin、XAUI、Blazor、以及还有说不出来的运行平台，因为代码绿色无依赖，支持新平台非常简单。目前单元测试数量：4700+，Nuget下载数量：170K+，源码几乎每天都有提交。值得高兴的是 FreeSql 加入了 ncc 开源社区：&lt;a href=&quot;https://github.com/dotnetcore/FreeSql&quot;&gt;https://github.com/dotnetcore/FreeSql&lt;/a&gt;，加入组织之后社区责任感更大，需要更努力做好品质，为开源社区出一份力。&lt;/p&gt;
&lt;p&gt;QQ群：4336577(已满)、8578575(在线)&lt;/p&gt;
&lt;p&gt;为什么要重复造轮子？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/31407/202005/31407-20200525013907903-1470982538.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;FreeSql 主要优势在于易用性上，基本是开箱即用，在不同数据库之间切换兼容性比较好。作者花了大量的时间精力在这个项目，肯请您花半小时了解下项目，谢谢。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;FreeSql 整体的功能特性如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;支持 CodeFirst 对比结构变化迁移；&lt;/li&gt;
&lt;li&gt;支持 DbFirst 从数据库导入实体类；&lt;/li&gt;
&lt;li&gt;支持 丰富的表达式函数，自定义解析；&lt;/li&gt;
&lt;li&gt;支持 批量添加、批量更新、BulkCopy；&lt;/li&gt;
&lt;li&gt;支持 导航属性，贪婪加载、延时加载、级联保存；&lt;/li&gt;
&lt;li&gt;支持 读写分离、分表分库，租户设计；&lt;/li&gt;
&lt;li&gt;支持 MySql/SqlServer/PostgreSQL/Oracle/Sqlite/达梦/神通/人大金仓/MsAccess；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;1.5.0 -&amp;gt; 1.8.0-preview 更新的重要功能如下：&lt;/p&gt;
&lt;p&gt;一、增加 $&quot;{a.Code}_{a.Id}&quot; lambda 解析；&lt;/p&gt;
&lt;p&gt;二、增加 lambda 表达式树解析子查询 ToList + string.Join() 产生 类似 group_concat 的效果；&lt;/p&gt;
&lt;p&gt;三、增加 SqlExt 常用开窗函数的自定义表达式解析；&lt;/p&gt;
&lt;p&gt;四、完善 WhereDynamicFilter 动态过滤查询；&lt;/p&gt;
&lt;p&gt;五、增加 BeginEdit/EndEdit 批量编辑数据的功能；&lt;/p&gt;
&lt;p&gt;六、增加 人大金仓/神通 数据库的访问支持；&lt;/p&gt;
&lt;p&gt;七、增加 父子表（树表）递归查询、删除功能；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/31407/202005/31407-20200525014307613-207448539.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;FreeSql 使用非常简单，只需要定义一个 IFreeSql 对象即可：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;static IFreeSql fsql = new FreeSql.FreeSqlBuilder()
    .UseConnectionString(FreeSql.DataType.MySql, connectionString)
    .UseAutoSyncStructure(true) //自动同步实体结构到数据库
    .Build(); //请务必定义成 Singleton 单例模式
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;在之前查询数据的时候，$&quot;&quot; 这种语法糖神器居然不能使用在 lambda 表达式中，实属遗憾。现在终于可以了，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;var item = fsql.GetRepository&amp;lt;Topic&amp;gt;().Insert(new Topic { Clicks = 101, Title = &quot;我是中国人101&quot;, CreateTime = DateTime.Parse(&quot;2020-7-5&quot;) });
var sql = fsql.Select&amp;lt;Topic&amp;gt;().WhereDynamic(item).ToSql(a =&amp;gt; new
{
    str = $&quot;x{a.Id + 1}z-{a.CreateTime.ToString(&quot;yyyyMM&quot;)}{a.Title}{a.Title}&quot;
});
Assert.Equal($@&quot;SELECT concat('x',ifnull((a.`Id` + 1), ''),'z-',ifnull(date_format(a.`CreateTime`,'%Y%m'), ''),'',ifnull(a.`Title`, ''),'',ifnull(a.`Title`, ''),'') as1 
FROM `tb_topic` a 
WHERE (a.`Id` = {item.Id})&quot;, sql);
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;再次说明：都是亲儿子，并且都有对应的单元测试，兄台大可放心用在不同的数据库中&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;v1.8.0+ string.Join + ToList 实现将子查询的多行结果，拼接为一个字符串，如：&quot;1,2,3,4&quot;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;fsql.Select&amp;lt;Topic&amp;gt;().ToList(a =&amp;gt; new {
  id = a.Id,
  concat = string.Join(&quot;,&quot;, fsql.Select&amp;lt;StringJoin01&amp;gt;().ToList(b =&amp;gt; b.Id))
});
//SELECT a.`Id`, (SELECT group_concat(b.`Id` separator ',') 
//    FROM `StringJoin01` b) 
//FROM `Topic` a
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该语法，在不同数据库都作了相应的 SQL 翻译。&lt;/p&gt;

&lt;p&gt;SqlExt.cs 定义了一些常用的表达式树解析，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;fsql.Select&amp;lt;T1, T2&amp;gt;()
  .InnerJoin((a, b) =&amp;gt; b.Id == a.Id)
  .ToList((a, b) =&amp;gt; new
  {
    Id = a.Id,
    EdiId = b.Id,
    over1 = SqlExt.Rank().Over().OrderBy(a.Id).OrderByDescending(b.EdiId).ToValue(),
    case1 = SqlExt.Case()
      .When(a.Id == 1, 10)
      .When(a.Id == 2, 11)
      .When(a.Id == 3, 12)
      .When(a.Id == 4, 13)
      .When(a.Id == 5, SqlExt.Case().When(b.Id == 1, 10000).Else(999).End())
  .End(), //这里因为复杂才这样，一般使用三元表达式即可：a.Id == 1 ? 10 : 11
  groupct1 = SqlExt.GroupConcat(a.Id).Distinct().OrderBy(b.EdiId).Separator(&quot;_&quot;).ToValue()
  });
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;本功能利用 FreeSql 自定义解析实现常用表达式树解析，欢迎 PR 补充&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/31407/202005/31407-20200524235718959-1427957349.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;是否见过这样的高级查询功能，WhereDynamicFilter 在后端可以轻松完成这件事情，前端根据 UI 组装好对应的 json 字符串传给后端就行，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;DynamicFilterInfo dyfilter = JsonConvert.DeserializeObject&amp;lt;DynamicFilterInfo&amp;gt;(@&quot;
{
  &quot;&quot;Logic&quot;&quot; : &quot;&quot;Or&quot;&quot;,
  &quot;&quot;Filters&quot;&quot; :
  [
    {
      &quot;&quot;Field&quot;&quot; : &quot;&quot;Code&quot;&quot;,
      &quot;&quot;Operator&quot;&quot; : &quot;&quot;NotContains&quot;&quot;,
      &quot;&quot;Value&quot;&quot; : &quot;&quot;val1&quot;&quot;,
      &quot;&quot;Filters&quot;&quot; :
      [
        {
          &quot;&quot;Field&quot;&quot; : &quot;&quot;Name&quot;&quot;,
          &quot;&quot;Operator&quot;&quot; : &quot;&quot;NotStartsWith&quot;&quot;,
          &quot;&quot;Value&quot;&quot; : &quot;&quot;val2&quot;&quot;,
        }
      ]
    },
    {
      &quot;&quot;Field&quot;&quot; : &quot;&quot;Parent.Code&quot;&quot;,
      &quot;&quot;Operator&quot;&quot; : &quot;&quot;Equals&quot;&quot;,
      &quot;&quot;Value&quot;&quot; : &quot;&quot;val11&quot;&quot;,
      &quot;&quot;Filters&quot;&quot; :
      [
        {
          &quot;&quot;Field&quot;&quot; : &quot;&quot;Parent.Name&quot;&quot;,
          &quot;&quot;Operator&quot;&quot; : &quot;&quot;Contains&quot;&quot;,
          &quot;&quot;Value&quot;&quot; : &quot;&quot;val22&quot;&quot;,
        }
      ]
    }
  ]
}
&quot;);
fsql.Select&amp;lt;VM_District_Parent&amp;gt;().WhereDynamicFilter(dyfilter).ToList();
//SELECT a.&quot;&quot;Code&quot;&quot;, a.&quot;&quot;Name&quot;&quot;, a.&quot;&quot;ParentCode&quot;&quot;, a__Parent.&quot;&quot;Code&quot;&quot; as4, a__Parent.&quot;&quot;Name&quot;&quot; as5, a__Parent.&quot;&quot;ParentCode&quot;&quot; as6 
//FROM &quot;&quot;D_District&quot;&quot; a 
//LEFT JOIN &quot;&quot;D_District&quot;&quot; a__Parent ON a__Parent.&quot;&quot;Code&quot;&quot; = a.&quot;&quot;ParentCode&quot;&quot; 
//WHERE (not((a.&quot;&quot;Code&quot;&quot;) LIKE '%val1%') AND not((a.&quot;&quot;Name&quot;&quot;) LIKE 'val2%') OR a__Parent.&quot;&quot;Code&quot;&quot; = 'val11' AND (a__Parent.&quot;&quot;Name&quot;&quot;) LIKE '%val22%')
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ISelect.WhereDynamicFilter 方法实现动态过滤条件（与前端交互），支持的操作符：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Contains/StartsWith/EndsWith/NotContains/NotStartsWith/NotEndsWith：包含/不包含，like '%xx%'，或者 like 'xx%'，或者 like '%xx'&lt;/li&gt;
&lt;li&gt;Equal/NotEqual：等于/不等于&lt;/li&gt;
&lt;li&gt;GreaterThan/GreaterThanOrEqual：大于/大于等于&lt;/li&gt;
&lt;li&gt;LessThan/LessThanOrEqual：小于/小于等于&lt;/li&gt;
&lt;li&gt;Range：范围查询&lt;/li&gt;
&lt;li&gt;DateRange：日期范围，有特殊处理 value[1] + 1&lt;/li&gt;
&lt;li&gt;Any/NotAny：是否符合 value 中任何一项（直白的说是 SQL IN）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;场景：winform 加载表数据后，一顿添加、修改、删除操作之后，点击【保存】&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;[Fact]
public void BeginEdit()
{
    fsql.Delete&amp;lt;BeginEdit01&amp;gt;().Where(&quot;1=1&quot;).ExecuteAffrows();
    var repo = fsql.GetRepository&amp;lt;BeginEdit01&amp;gt;();
    var cts = new[] {
        new BeginEdit01 { Name = &quot;分类1&quot; },
        new BeginEdit01 { Name = &quot;分类1_1&quot; },
        new BeginEdit01 { Name = &quot;分类1_2&quot; },
        new BeginEdit01 { Name = &quot;分类1_3&quot; },
        new BeginEdit01 { Name = &quot;分类2&quot; },
        new BeginEdit01 { Name = &quot;分类2_1&quot; },
        new BeginEdit01 { Name = &quot;分类2_2&quot; }
    }.ToList();
    repo.Insert(cts);

    repo.BeginEdit(cts); //开始对 cts 进行编辑

    cts.Add(new BeginEdit01 { Name = &quot;分类2_3&quot; });
    cts[0].Name = &quot;123123&quot;;
    cts.RemoveAt(1);

    Assert.Equal(3, repo.EndEdit());
}
class BeginEdit01
{
    public Guid Id { get; set; }
    public string Name { get; set; }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码 EndEdit 方法执行的时候产生 3 条 SQL 如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;INSERT INTO &quot;BeginEdit01&quot;(&quot;Id&quot;, &quot;Name&quot;) VALUES('5f26bf07-6ac3-cbe8-00da-7dd74818c3a6', '分类2_3')


UPDATE &quot;BeginEdit01&quot; SET &quot;Name&quot; = '123123' 
WHERE (&quot;Id&quot; = '5f26bf00-6ac3-cbe8-00da-7dd01be76e26')


DELETE FROM &quot;BeginEdit01&quot; WHERE (&quot;Id&quot; = '5f26bf00-6ac3-cbe8-00da-7dd11bcf54dc')
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;提醒：该操作只对变量 cts 有效，不是针对全表对比更新。&lt;/p&gt;

&lt;p&gt;天津神舟通用数据技术有限公司（简称“神舟通用公司”），隶属于中国航天科技集团（CASC）。是国内从事数据库、大数据解决方案和数据挖掘分析产品研发的专业公司。公司获得了国家核高基科技重大专项重点支持，是核高基专项的牵头承担单位。自1993年在航天科技集团开展数据库研发以来，神通数据库已历经27年的发展历程。公司核心产品主要包括神通关系型数据库、神通KStore海量数据管理系统、神通商业智能套件等系列产品研发和市场销售。基于产品组合，可形成支持交易处理、MPP数据库集群、数据分析与处理等解决方案，可满足多种应用场景需求。产品通过了国家保密局涉密信息系统、公安部等保四级、军B +级等安全评测和认证。&lt;/p&gt;
&lt;p&gt;北京人大金仓信息技术股份有限公司（以下简称“人大金仓”）是具有自主知识产权的国产数据管理软件与服务提供商。人大金仓由中国人民大学一批最早在国内开展数据库教学、科研、开发的专家于1999年发起创立，先后承担了国家“863”、“核高基”等重大专项，研发出了具有国际先进水平的大型通用数据库产品。2018年，人大金仓申报的“数据库管理系统核心技术的创新与金仓数据库产业化”项目荣获2018年度国家科学技术进步二等奖，产学研的融合进一步助力国家信息化建设。&lt;/p&gt;
&lt;p&gt;随着华为、中兴事务，国产数据库市场相信是未来是趋势走向，纵观 .net core 整个圈子对国产神舟通用、人大金仓数据库的支持几乎为 0，今天 FreeSql ORM 可以使用 CodeFirst/DbFirst 两种模式进行开发。&lt;/p&gt;
&lt;p&gt;并且声称：FreeSql 对各数据库没有亲儿子一说，除了 MsAcces 其他全部是亲儿子，在功能提供方面一碗水端平。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/31407/202005/31407-20200525014801483-1494727409.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;众所周知 EFCore for oracle 问题多，并且现在才刚刚更新到 3.x，在这样的背景下，一个国产数据库更不能指望谁实现好用的 EFCore。目前看来除了 EFCore for sqlserver 我们没把握完全占优势，起码在其他数据库肯定是我们更接地气。&lt;/p&gt;
&lt;p&gt;使用 FreeSql 访问人大金仓/神通 数据库，只需要修改代码如下即可：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;static IFreeSql fsql = new FreeSql.FreeSqlBuilder()
    .UseConnectionString(FreeSql.DataType.ShenTong, connectionString) //修改 DataType 设置切换数据库
    .UseAutoSyncStructure(true) //自动同步实体结构到数据库
    .Build(); //请务必定义成 Singleton 单例模式
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;无限级分类（父子）是一种比较常用的表设计，每种设计方式突出优势的同时也带来缺陷，如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;方法1：表设计中只有 parent_id 字段，困扰：查询麻烦（本文可解决）；&lt;/li&gt;
&lt;li&gt;方法2：表设计中冗余子级id便于查询，困扰：添加/更新/删除的时候需要重新计算；&lt;/li&gt;
&lt;li&gt;方法3：表设计中存储左右值编码，困扰：同上；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;方法1设计最简单，我们正是解决它设计简单，使用复杂的问题。&lt;/p&gt;
&lt;p&gt;首先，按照导航属性的定义，定义好父子属性：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public class Area
{
  [Column(IsPrimary = true)]
  public string Code { get; set; }

  public string Name { get; set; }
  public virtual string ParentCode { get; set; }

  [Navigate(nameof(ParentCode))]
  public Area Parent { get; set; }
  [Navigate(nameof(ParentCode))]
  public List&amp;lt;Area&amp;gt; Childs { get; set; }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;定义 Parent 属性，在表达式中可以这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;fsql.Select&amp;lt;Area&amp;gt;().Where(a =&amp;gt; a.Parent.Parent.Parent.Name == &quot;中国&quot;).First();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;定义 Childs 属性，在表达式中可以这样（子查询）：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;fsql.Select&amp;lt;Area&amp;gt;().Where(a =&amp;gt; a.Childs.AsSelect().Any(c =&amp;gt; c.Name == &quot;北京&quot;)).First();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;定义 Childs 属性，还可以使用&lt;a href=&quot;https://github.com/dotnetcore/FreeSql/wiki/%E8%81%94%E7%BA%A7%E4%BF%9D%E5%AD%98&quot;&gt;【级联保存】&lt;/a&gt;、&lt;a href=&quot;https://github.com/2881099/FreeSql/wiki/%e8%b4%aa%e5%a9%aa%e5%8a%a0%e8%bd%bd&quot;&gt;【贪婪加载】&lt;/a&gt; 等等操作。&lt;/p&gt;
&lt;p&gt;利用级联保存，添加测试数据如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;fsql.Delete&amp;lt;Area&amp;gt;().Where(&quot;1=1&quot;).ExecuteAffrows();
var repo = fsql.GetRepository&amp;lt;Area&amp;gt;();
repo.DbContextOptions.EnableAddOrUpdateNavigateList = true;
repo.DbContextOptions.NoneParameter = true;
repo.Insert(new Area
{
  Code = &quot;100000&quot;,
  Name = &quot;中国&quot;,
  Childs = new List&amp;lt;Area&amp;gt;(new[] {
    new Area
    {
      Code = &quot;110000&quot;,
      Name = &quot;北京&quot;,
      Childs = new List&amp;lt;Area&amp;gt;(new[] {
        new Area{ Code=&quot;110100&quot;, Name = &quot;北京市&quot; },
        new Area{ Code=&quot;110101&quot;, Name = &quot;东城区&quot; },
      })
    }
  })
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;功能1：ToTreeList&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;配置好父子属性之后，就可以这样用了：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;var t1 = fsql.Select&amp;lt;Area&amp;gt;().ToTreeList();
Assert.Single(t1);
Assert.Equal(&quot;100000&quot;, t1[0].Code);
Assert.Single(t1[0].Childs);
Assert.Equal(&quot;110000&quot;, t1[0].Childs[0].Code);
Assert.Equal(2, t1[0].Childs[0].Childs.Count);
Assert.Equal(&quot;110100&quot;, t1[0].Childs[0].Childs[0].Code);
Assert.Equal(&quot;110101&quot;, t1[0].Childs[0].Childs[1].Code);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查询数据本来是平面的，ToTreeList 方法将返回的平面数据在内存中加工为树型 List 返回。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;功能2：AsTreeCte 递归删除&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;很常见的无限级分类表功能，删除树节点时，把子节点也处理一下。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;fsql.Select&amp;lt;Area&amp;gt;()
  .Where(a =&amp;gt; a.Name == &quot;中国&quot;)
  .AsTreeCte()
  .ToDelete()
  .ExecuteAffrows(); //删除 中国 下的所有记录
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果软删除：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;fsql.Select&amp;lt;Area&amp;gt;()
  .Where(a =&amp;gt; a.Name == &quot;中国&quot;)
  .AsTreeCte()
  .ToUpdate()
  .Set(a =&amp;gt; a.IsDeleted, true)
  .ExecuteAffrows(); //软删除 中国 下的所有记录
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;功能3：AsTreeCte 递归查询&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;若不做数据冗余的无限级分类表设计，递归查询少不了，AsTreeCte 正是解决递归查询的封装，方法参数说明：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;(可选) pathSelector&lt;/td&gt;
&lt;td&gt;路径内容选择，可以设置查询返回：中国 -&amp;gt; 北京 -&amp;gt; 东城区&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;(可选) up&lt;/td&gt;
&lt;td&gt;false(默认)：由父级向子级的递归查询，true：由子级向父级的递归查询&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;(可选) pathSeparator&lt;/td&gt;
&lt;td&gt;设置 pathSelector 的连接符，默认：-&amp;gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;(可选) level&lt;/td&gt;
&lt;td&gt;设置递归层级&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;通过测试的数据库：MySql8.0、SqlServer、PostgreSQL、Oracle、Sqlite、达梦、人大金仓&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;姿势一：AsTreeCte() + ToTreeList&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;var t2 = fsql.Select&amp;lt;Area&amp;gt;()
  .Where(a =&amp;gt; a.Name == &quot;中国&quot;)
  .AsTreeCte() //查询 中国 下的所有记录
  .OrderBy(a =&amp;gt; a.Code)
  .ToTreeList(); //非必须，也可以使用 ToList（见姿势二）
Assert.Single(t2);
Assert.Equal(&quot;100000&quot;, t2[0].Code);
Assert.Single(t2[0].Childs);
Assert.Equal(&quot;110000&quot;, t2[0].Childs[0].Code);
Assert.Equal(2, t2[0].Childs[0].Childs.Count);
Assert.Equal(&quot;110100&quot;, t2[0].Childs[0].Childs[0].Code);
Assert.Equal(&quot;110101&quot;, t2[0].Childs[0].Childs[1].Code);
// WITH &quot;as_tree_cte&quot;
// as
// (
// SELECT 0 as cte_level, a.&quot;Code&quot;, a.&quot;Name&quot;, a.&quot;ParentCode&quot; 
// FROM &quot;Area&quot; a 
// WHERE (a.&quot;Name&quot; = '中国')

// union all

// SELECT wct1.cte_level + 1 as cte_level, wct2.&quot;Code&quot;, wct2.&quot;Name&quot;, wct2.&quot;ParentCode&quot; 
// FROM &quot;as_tree_cte&quot; wct1 
// INNER JOIN &quot;Area&quot; wct2 ON wct2.&quot;ParentCode&quot; = wct1.&quot;Code&quot;
// )
// SELECT a.&quot;Code&quot;, a.&quot;Name&quot;, a.&quot;ParentCode&quot; 
// FROM &quot;as_tree_cte&quot; a 
// ORDER BY a.&quot;Code&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;姿势二：AsTreeCte() + ToList&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;var t3 = fsql.Select&amp;lt;Area&amp;gt;()
  .Where(a =&amp;gt; a.Name == &quot;中国&quot;)
  .AsTreeCte()
  .OrderBy(a =&amp;gt; a.Code)
  .ToList();
Assert.Equal(4, t3.Count);
Assert.Equal(&quot;100000&quot;, t3[0].Code);
Assert.Equal(&quot;110000&quot;, t3[1].Code);
Assert.Equal(&quot;110100&quot;, t3[2].Code);
Assert.Equal(&quot;110101&quot;, t3[3].Code);
//执行的 SQL 与姿势一相同
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;姿势三：AsTreeCte(pathSelector) + ToList&lt;/p&gt;
&lt;p&gt;设置 pathSelector 参数后，如何返回隐藏字段？&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;var t4 = fsql.Select&amp;lt;Area&amp;gt;()
  .Where(a =&amp;gt; a.Name == &quot;中国&quot;)
  .AsTreeCte(a =&amp;gt; a.Name + &quot;[&quot; + a.Code + &quot;]&quot;)
  .OrderBy(a =&amp;gt; a.Code)
  .ToList(a =&amp;gt; new { 
    item = a, 
    level = Convert.ToInt32(&quot;a.cte_level&quot;), 
    path = &quot;a.cte_path&quot; 
  });
Assert.Equal(4, t4.Count);
Assert.Equal(&quot;100000&quot;, t4[0].item.Code);
Assert.Equal(&quot;110000&quot;, t4[1].item.Code);
Assert.Equal(&quot;110100&quot;, t4[2].item.Code);
Assert.Equal(&quot;110101&quot;, t4[3].item.Code);
Assert.Equal(&quot;中国[100000]&quot;, t4[0].path);
Assert.Equal(&quot;中国[100000] -&amp;gt; 北京[110000]&quot;, t4[1].path);
Assert.Equal(&quot;中国[100000] -&amp;gt; 北京[110000] -&amp;gt; 北京市[110100]&quot;, t4[2].path);
Assert.Equal(&quot;中国[100000] -&amp;gt; 北京[110000] -&amp;gt; 东城区[110101]&quot;, t4[3].path);
// WITH &quot;as_tree_cte&quot;
// as
// (
// SELECT 0 as cte_level, a.&quot;Name&quot; || '[' || a.&quot;Code&quot; || ']' as cte_path, a.&quot;Code&quot;, a.&quot;Name&quot;, a.&quot;ParentCode&quot; 
// FROM &quot;Area&quot; a 
// WHERE (a.&quot;Name&quot; = '中国')

// union all

// SELECT wct1.cte_level + 1 as cte_level, wct1.cte_path || ' -&amp;gt; ' || wct2.&quot;Name&quot; || '[' || wct2.&quot;Code&quot; || ']' as cte_path, wct2.&quot;Code&quot;, wct2.&quot;Name&quot;, wct2.&quot;ParentCode&quot; 
// FROM &quot;as_tree_cte&quot; wct1 
// INNER JOIN &quot;Area&quot; wct2 ON wct2.&quot;ParentCode&quot; = wct1.&quot;Code&quot;
// )
// SELECT a.&quot;Code&quot; as1, a.&quot;Name&quot; as2, a.&quot;ParentCode&quot; as5, a.cte_level as6, a.cte_path as7 
// FROM &quot;as_tree_cte&quot; a 
// ORDER BY a.&quot;Code&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;更多姿势...请根据代码注释进行尝试&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;作者的努力，喜欢能打动到你，希望正在使用的、善良的您能动一动小手指，把文章转发一下，让更多人知道 .NET 有这样一个好用的 ORM 存在。谢谢了！！&lt;/p&gt;
&lt;p&gt;FreeSql 开源协议 MIT &lt;a href=&quot;https://github.com/dotnetcore/FreeSql&quot;&gt;https://github.com/dotnetcore/FreeSql&lt;/a&gt;，可以商用，文档齐全。QQ群：4336577(已满)、8578575(在线)&lt;/p&gt;
&lt;p&gt;如果你有好的 ORM 实现想法，欢迎给作者留言讨论，谢谢观看！&lt;/p&gt;
</description>
<pubDate>Wed, 12 Aug 2020 22:59:00 +0000</pubDate>
<dc:creator>nicye</dc:creator>
<og:description>写在开头 FreeSql 是 .NET 开源生态下的 ORM 轮子，在一些人眼里属于重复造轮子：不看也罢。就像昨天有位朋友截图某培训直播发给我看，内容为：“FreeSQL（个人产品），自己玩可以，不要</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kellynic/p/13494164.html</dc:identifier>
</item>
<item>
<title>关于Dapper实现读写分离的个人思考 - yi念之间</title>
<link>http://www.cnblogs.com/wucy/p/13485508.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wucy/p/13485508.html</guid>
<description>&lt;h3 id=&quot;概念相关&quot;&gt;概念相关&lt;/h3&gt;
&lt;p&gt;    为了确保多线上环境数据库的稳定性和可用性，大部分情况下都使用了双机热备的技术。一般是一个主库+一个从库或者多个从库的结构，从库的数据来自于主库的同步。在此基础上我们可以通过数据库反向代理工具或者使用程序的方式实现读写分离，即主库接受事务性操作比如删除、修改、新增等操作，从库接受读操作。&lt;span&gt;笔者自认为读写分离解决的痛点是，数据库读写负载非常高的情况下，单点数据库存在读写冲突，从而导致数据库压力过大，出现读写操作缓慢甚至出现死锁或者拒绝服务的情况。&lt;/span&gt;它适用与读大于写，并可以容忍一段时间内不一致的情况，因为主从同步存在一定的延迟，大致的实现架构图如下(图片来自于网络)。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2042116/202008/2042116-20200812231109744-1401776234.png&quot; alt=&quot;数据库主从架构&quot; width=&quot;40%&quot; height=&quot;25%&quot; align=&quot;middle&quot;/&gt;    虽然我们可以通过数据库代理实现读写分离，比如mycat，这类方案的优势就是对程序本身没有入侵，通过代理本身来拦截sql语句分发到具体数据。甚至是更好的解决方案NewSQL去解决，比如TiDB。但是还是那个原则，无论使用数据库代理或者NewSQL的情况都是比较重型的解决方案，会增加服务节点和运维成本，有时候还没到使用这些终极解决方案的地步，这时候我们会在程序中处理读写分离，所以有个好的思路去在程序中解决读写分离也尤为重要。&lt;/p&gt;
&lt;h3 id=&quot;基本结构&quot;&gt;基本结构&lt;/h3&gt;
&lt;p&gt;接下来我们新建三个类，当然这个并不固定，可以根据自己的情况新建类。首先我们新建一个ConnectionStringConsts用来存放连接字符串常量，也就是用来存放读取自配置文件或者配置中心的字符串，这里我直接写死，当然你也可以存放多个连接字符串，大致实现如下。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;public class ConnectionStringConsts
{
    /// &amp;lt;summary&amp;gt;
    /// 主库连接字符串
    /// &amp;lt;/summary&amp;gt;
    public static readonly string MasterConnectionString = &quot;server=db.master.com;Database=crm_db;UID=root;PWD=1&quot;;

    /// &amp;lt;summary&amp;gt;
    /// 从库连接字符串
    /// &amp;lt;/summary&amp;gt;
    public static readonly string SlaveConnectionString = &quot;server=db.slave.com;Database=crm_db;UID=root;PWD=1&quot;;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后新建存储数据库连接字符串主从映射关系的映射类ConnectionStringMapper，这个类的主要功能就是通过连接字符串建立主库和从库的关系，并且根据映射规则返回实际要操作的字符串，大致实现如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;public static class ConnectionStringMapper
{
    //存放字符串主从关系
    private static readonly IDictionary&amp;lt;string, string[]&amp;gt; _mapper = new Dictionary&amp;lt;string, string[]&amp;gt;();
    private static readonly Random _random = new Random();

    static ConnectionStringMapper()
    {
        //添加数关系映射
        _mapper.Add(ConnectionStringConsts.MasterConnectionString, new[] { ConnectionStringConsts.SlaveConnectionString });
    }

    /// &amp;lt;summary&amp;gt;
    /// 获取连接字符串
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;masterConnectionStr&quot;&amp;gt;主库连接字符串&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&quot;useMaster&quot;&amp;gt;是否选择读主库&amp;lt;/param&amp;gt;
    /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
    public static string GetConnectionString(string masterConnectionStr,bool useMaster)
    {
        //是否走主库
        if (useMaster)
        {
            return masterConnectionStr;
        }

        if (!_mapper.Keys.Contains(masterConnectionStr))
        {
            throw new KeyNotFoundException(&quot;不存在的连接字符串&quot;);
        }

        //根据主库获取从库连接字符串
        string[] slaveStrs = _mapper[masterConnectionStr];
        if (slaveStrs.Length == 1)
        {
            return slaveStrs[0];
        }
        return slaveStrs[_random.Next(0, slaveStrs.Length - 1)];
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个类是比较核心的操作，关于实现读写分离的核心逻辑都在这，当然你可以根据自己的具体业务实现类似的操作。接下来，我们将封装一个DapperHelper的操作，虽然Dapper用起来比较简单方便，但是依然强烈建议！！！封装一个Dapper操作类，这样的话可以统一处理数据库相关的操作，对于以后的维护修改都非常方便，扩展性的时候也会相对容易一些&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;public static class DapperHelper
{
    public static IDbConnection GetConnection(string connectionStr)
    {
        return new MySqlConnection(connectionStr);
    }

    /// &amp;lt;summary&amp;gt;
    /// 执行查询相关操作
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;sql&quot;&amp;gt;sql语句&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&quot;param&quot;&amp;gt;参数&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&quot;useMaster&quot;&amp;gt;是否去读主库&amp;lt;/param&amp;gt;
    /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
    public static IEnumerable&amp;lt;T&amp;gt; Query&amp;lt;T&amp;gt;(string sql, object param = null, bool useMaster=false)
    {
        //根据实际情况选择需要读取数据库的字符串
        string connectionStr = ConnectionStringMapper.GetConnectionString(ConnectionStringConsts.MasterConnectionString, useMaster);
        using (var connection = GetConnection(connectionStr))
        {
            return connection.Query&amp;lt;T&amp;gt;(sql, param);
        }
    }

    /// &amp;lt;summary&amp;gt;
    /// 执行查询相关操作
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;connectionStr&quot;&amp;gt;连接字符串&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&quot;sql&quot;&amp;gt;sql语句&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&quot;param&quot;&amp;gt;参数&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&quot;useMaster&quot;&amp;gt;是否去读主库&amp;lt;/param&amp;gt;
    /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
    public static IEnumerable&amp;lt;T&amp;gt; Query&amp;lt;T&amp;gt;(string connectionStr, string sql, object param = null, bool useMaster = false)
    {
        //根据实际情况选择需要读取数据库的字符串
        connectionStr = ConnectionStringMapper.GetConnectionString(connectionStr, useMaster);
        using (var connection = GetConnection(connectionStr))
        {
            return connection.Query&amp;lt;T&amp;gt;(sql, param);
        }
    }

    /// &amp;lt;summary&amp;gt;
    /// 执行事务相关操作
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;sql&quot;&amp;gt;sql语句&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&quot;param&quot;&amp;gt;参数&amp;lt;/param&amp;gt;
    /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
    public static int Execute(string sql, object param = null)
    {
        return Execute(ConnectionStringConsts.MasterConnectionString, sql, param);
    }

    /// &amp;lt;summary&amp;gt;
    /// 执行事务相关操作
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;connectionStr&quot;&amp;gt;连接字符串&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&quot;sql&quot;&amp;gt;sql语句&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&quot;param&quot;&amp;gt;参数&amp;lt;/param&amp;gt;
    /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
    public static int Execute(string connectionStr,string sql,object param=null)
    {
        using (var connection = GetConnection(connectionStr))
        {
            return connection.Execute(sql,param);
        }
    }

    /// &amp;lt;summary&amp;gt;
    /// 事务封装
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;func&quot;&amp;gt;操作&amp;lt;/param&amp;gt;
    /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
    public static bool ExecuteTransaction(Func&amp;lt;IDbConnection, IDbTransaction, int&amp;gt; func)
    {
        return ExecuteTransaction(ConnectionStringConsts.MasterConnectionString, func);
    }

    /// &amp;lt;summary&amp;gt;
    /// 事务封装
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;connectionStr&quot;&amp;gt;连接字符串&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&quot;func&quot;&amp;gt;操作&amp;lt;/param&amp;gt;
    /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
    public static bool ExecuteTransaction(string connectionStr, Func&amp;lt;IDbConnection, IDbTransaction, int&amp;gt; func)
    {
        using (var conn = GetConnection(connectionStr))
        {
            IDbTransaction trans = conn.BeginTransaction();
            return func(conn, trans)&amp;gt;0;
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;    首先和大家说一句非常抱歉的话，这个类我是随手封装的，并没有实验是否可用，因为我自己的电脑并没有安装数据库这套环境，但是绝对是可以体现我要讲解的思路，希望大家多多见谅。&lt;br/&gt;    在这里可以看出来Query查询方法中我们传递了一个缺省参数useMaster默认值是false，主要的原因是，&lt;span&gt;很多时候我们可能不能完全的使用事务性操作走主库，读取操作走从库的情况，也就是我们有些场景可能要选择性读主库，这时候我们可以通过这个参数去控制。当然这个字段具体的含义根据你的具体业务实际情况而定，其主要原则就是让更多的操作能命中缺省的情况，比如你大部分读操作都需要去主库，那么你可以设置默认值为true，这样的话特殊情况传递false，这样的话会省下许多操作。如果你大部分读操作都是走从库，只有少数场景需要选择性读主库，那么这个参数你可以设置为false。&lt;/span&gt;写就没有这种情况，因为无论哪种场景写都是要在主库进行的，除非双主的情况，这也不是我们本次讨论的重点。&lt;/p&gt;
&lt;h3 id=&quot;使用方式&quot;&gt;使用方式&lt;/h3&gt;
&lt;p&gt;通过上述方式完成封装之后，我们在具体数据访问层适用的时候可以通过如下方式，如果按照默认的方式查询可以采用如下的方式。在这里关于写的操作我们就不展示了，因为写的情况是固定的&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;string queryPersonSql = &quot;select id,name from Person where id=@id&quot;;
var person = DapperHelper.Query&amp;lt;Person&amp;gt;(queryPersonSql, new { id = 1 }).FirstOrDefault();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果需要存在特殊情况，查询需要选择主库的话可以不使用缺省参数，我们可以选择给缺省参数传值，比如我要让查询走主库&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;string queryPersonSql = &quot;select id,name from Person where id=@id&quot;;
var person = DapperHelper.Query&amp;lt;Person&amp;gt;(queryPersonSql, new { id = 1 }, true).FirstOrDefault();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然，我们上面也提到了，缺省值useMaster是true还是false，这个完全可以结合自身的业务决定。如果大部分查询都是走从库的情况下，缺省值可以为false。如果大部分查询情况都是走主库的时候，缺省值可以给true。关于以上所有的相关封装，模式并不固定，这一点可以完全结合自己的实际业务和代码实现，只是希望能多给大家提供一种思路，其他ORM也有自身提供了操作读写分离的具体实现。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;    以上就是笔者关于Dapper实现读写分离的一些个人想法，这种方法也适合其他类似Dapper偏原生SQL操作的ORM框架。这种方式还有一个优点就是如果在现有的项目中，需要支持读写分离的时候，这种操作方式可能对原有代码逻辑，入侵不会那么强，如果你前期封装还比较合理的话，那么改动将会非常小。当然这只是笔者的个人的观点，毕竟具体的实践方式还需要结合实际项目和业务。本次我个人希望能得到大家更多关于这方面的想法，如果你有更好的实现方式欢迎评论区多多留言。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;span&gt;👇欢迎扫码关注我的公众号👇&lt;/span&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/2042116/202006/2042116-20200622133425514-1420050576.png&quot;/&gt;&lt;/div&gt;
</description>
<pubDate>Wed, 12 Aug 2020 16:05:00 +0000</pubDate>
<dc:creator>yi念之间</dc:creator>
<og:description>概念相关 为了确保多线上环境数据库的稳定性和可用性，大部分情况下都使用了双机热备的技术。一般是一个主库+一个从库或者多个从库的结构，从库的数据来自于主库的同步。在此基础上我们可以通过数据库反向代理工具</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wucy/p/13485508.html</dc:identifier>
</item>
<item>
<title>【Spring注解驱动开发】使用@Autowired@Qualifier@Primary三大注解自动装配组件，你会了吗？ - 冰河团队</title>
<link>http://www.cnblogs.com/binghe001/p/13493844.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/binghe001/p/13493844.html</guid>
<description>&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;blockquote readability=&quot;13.064066852368&quot;&gt;
&lt;p&gt;【Spring专题】停更一个多月，期间在更新其他专题的内容，不少小伙伴纷纷留言说：冰河，你【Spring专题】是不是停更了啊！其实并没有停更，只是中途有很多小伙伴留言说急需学习一些知识技能，以便于跳槽，哈哈，大家都懂得！所以，中途停更了一段时间，写了一些其他专题的文章。现在，继续更新【String专题】。&lt;/p&gt;
&lt;p&gt;关注 &lt;strong&gt;冰河技术&lt;/strong&gt; 微信公众号，订阅更多技术干货！如果文章对你有所帮助，请不要吝惜你的点赞、在看、留言和转发，你的支持是我持续创作的最大动力！&lt;/p&gt;
&lt;p&gt;项目工程源码已经提交到GitHub：&lt;a href=&quot;https://github.com/sunshinelyz/spring-annotation&quot;&gt;https://github.com/sunshinelyz/spring-annotation&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;注解说明&quot;&gt;注解说明&lt;/h2&gt;
&lt;h3 id=&quot;autowired注解&quot;&gt;@Autowired注解&lt;/h3&gt;
&lt;p&gt;@Autowired 注解，可以对类成员变量、方法和构造函数进行标注，完成自动装配的工作。@Autowired 注解可以放在类，接口以及方法上。在使用@Autowired之前，我们对一个bean配置属性时，是用如下xml文件的形式进行配置的。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;property name=&quot;属性名&quot; value=&quot; 属性值&quot;/&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;@Autowired 注解的源码如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package org.springframework.beans.factory.annotation;
import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
@Target({ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.PARAMETER, ElementType.FIELD, ElementType.ANNOTATION_TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Autowired {
        boolean required() default true;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;@Autowired 注解说明：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（1）默认优先按照类型去容器中找对应的组件，找到就赋值；&lt;/p&gt;
&lt;p&gt;（2）如果找到多个相同类型的组件，再将属性名称作为组件的id，到 IOC 容器中进行查找。&lt;/p&gt;
&lt;h3 id=&quot;qualifier注解&quot;&gt;@Qualifier注解&lt;/h3&gt;
&lt;p&gt;@Autowired是根据类型进行自动装配的，如果需要按名称进行装配，则需要配合@Qualifier 注解使用。&lt;/p&gt;
&lt;p&gt;@Qualifier注解源码如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package org.springframework.beans.factory.annotation;
import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Inherited;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
@Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.TYPE, ElementType.ANNOTATION_TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Inherited
@Documented
public @interface Qualifier {
        String value() default &quot;&quot;;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;primary注解&quot;&gt;@Primary注解&lt;/h3&gt;
&lt;p&gt;在Spring 中使用注解，常使用@Autowired， 默认是根据类型Type来自动注入的。但有些特殊情况，对同一个接口，可能会有几种不同的实现类，而默认只会采取其中一种实现的情况下， 就可以使用@Primary注解来标注优先使用哪一个实现类。&lt;/p&gt;
&lt;p&gt;@Primary注解的源码如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package org.springframework.context.annotation;
import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Primary {

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;自动装配&quot;&gt;自动装配&lt;/h2&gt;
&lt;p&gt;在进行项目实战之前，我们先来说说什么是Spring组件的自动装配。Spring组件的自动装配就是：&lt;strong&gt;Spring利用依赖注入，也就是我们通常所说的DI，完成对IOC容器中各个组件的依赖关系赋值。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;项目实战&quot;&gt;项目实战&lt;/h2&gt;
&lt;h3 id=&quot;测试autowired注解&quot;&gt;测试@Autowired注解&lt;/h3&gt;
&lt;p&gt;这里，我们以之前项目中创建的dao、service和controller为例进行说明。dao、service和controller的初始代码分别如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package io.mykit.spring.plugins.register.dao;
import org.springframework.stereotype.Repository;
/**
 * @author binghe
 * @version 1.0.0
 * @description 测试的dao
 */
@Repository
public class PersonDao {
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package io.mykit.spring.plugins.register.service;
import io.mykit.spring.plugins.register.dao.PersonDao;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
/**
 * @author binghe
 * @version 1.0.0
 * @description 测试的Service
 */
@Service
public class PersonService {
    @Autowired
    private PersonDao personDao;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;controller&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package io.mykit.spring.plugins.register.controller;
import org.springframework.stereotype.Controller;
/**
 * @author binghe
 * @version 1.0.0
 * @description 测试的controller
 */
@Controller
public class PersonController {
    @Autowired
    private PersonService personService;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，我们在Service中使用@Autowired注解注入了Dao，在Controller中使用@Autowired注解注入了Service。为了方便测试，我们在PersonService类中生成一个toString()方法，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package io.mykit.spring.plugins.register.service;
import io.mykit.spring.plugins.register.dao.PersonDao;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
/**
 * @author binghe
 * @version 1.0.0
 * @description 测试的Service
 */
@Service
public class PersonService {
    @Autowired
    private PersonDao personDao;

    @Override
    public String toString() {
        return personDao.toString();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里，我们在PersonService类的toString()方法中直接调用personDao的toString()方法并返回。为了更好的演示效果，我们在项目的 &lt;code&gt;io.mykit.spring.plugins.register.config&lt;/code&gt; 包下创建AutowiredConfig类，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package io.mykit.spring.plugins.register.config;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
/**
 * @author binghe
 * @version 1.0.0
 * @description 测试自动装配组件的Config配置类
 */
@Configuration
@ComponentScan(value = {
        &quot;io.mykit.spring.plugins.register.dao&quot;, 
        &quot;io.mykit.spring.plugins.register.service&quot;, 
        &quot;io.mykit.spring.plugins.register.controller&quot;})
public class AutowiredConfig {

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来，我们来测试一下上面的程序，我们在项目的src/test/java目录下的 &lt;code&gt;io.mykit.spring.test&lt;/code&gt; 包下创建AutowiredTest类，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package io.mykit.spring.test;
import io.mykit.spring.plugins.register.config.AutowiredConfig;
import io.mykit.spring.plugins.register.service.PersonService;
import org.junit.Test;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
/**
 * @author binghe
 * @version 1.0.0
 * @description 测试自动装配
 */
public class AutowiredTest {
    @Test
    public void testAutowired01(){
        //创建IOC容器
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AutowiredConfig.class);
        PersonService personService = context.getBean(PersonService.class);
        System.out.println(personService);
        context.close();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试方法比较简单，这里，我就不做过多说明了。接下来，我们运行AutowiredTest类的testAutowired01()方法，得出的输出结果信息如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;io.mykit.spring.plugins.register.dao.PersonDao@10e92f8f
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，输出了PersonDao信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那么问题来了：我们在PersonService类中输出的PersonDao，和我们直接在Spring IOC容器中获取的PersonDao是不是同一个对象呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们可以在AutowiredTest类的testAutowired01()方法中添加获取PersonDao对象的方法，并输出获取到的PersonDao对象，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void testAutowired01(){
    //创建IOC容器
    AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AutowiredConfig.class);
    PersonService personService = context.getBean(PersonService.class);
    System.out.println(personService);
    PersonDao personDao = context.getBean(PersonDao.class);
    System.out.println(personDao);
    context.close();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们再次运行AutowiredTest类的testAutowired01()方法，输出的结果信息如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;io.mykit.spring.plugins.register.dao.PersonDao@10e92f8f
io.mykit.spring.plugins.register.dao.PersonDao@10e92f8f
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，我们在PersonService类中输出的PersonDao对象和直接从IOC容器中获取的PersonDao对象是同一个对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果在Spring容器中存在对多个PersonDao对象该如何处理呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先，为了更加直观的看到我们使用@Autowired注解装配的是哪个PersonDao对象，我们对PersonDao类进行改造，为其加上一个remark字段，为其赋一个默认值，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package io.mykit.spring.plugins.register.dao;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.springframework.stereotype.Repository;
/**
 * @author binghe
 * @version 1.0.0
 * @description 测试的dao
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Repository
public class PersonDao {
    private String remark = &quot;1&quot;;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来，我们就在AutowiredConfig类中注入一个PersonDao对象，并且显示指定PersonDao对象在IOC容器中的bean的名称为personDao2，并为PersonDao对象的remark字段赋值为2，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;  @Bean(&quot;personDao2&quot;)
  public PersonDao personDao(){
      return new PersonDao(&quot;2&quot;);
  }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;目前，在我们的IOC容器中就会注入两个PersonDao对象。那此时，&lt;strong&gt;@Autowired注解装配的是哪个PersonDao对象呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接下来，我们运行AutowiredTest类的testAutowired01()方法，输出的结果信息如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;PersonDao{remark='1'}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，结果信息输出了1，说明：&lt;strong&gt;@Autowired注解默认优先按照类型去容器中找对应的组件，找到就赋值；如果找到多个相同类型的组件，再将属性名称作为组件的id，到 IOC 容器中进行查找。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那我们如何让@Autowired装配personDao2呢？&lt;/strong&gt; 这个问题问的好，其实很简单，我们将PersonService类中的personDao全部修改为personDao2，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package io.mykit.spring.plugins.register.service;
import io.mykit.spring.plugins.register.dao.PersonDao;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
/**
 * @author binghe
 * @version 1.0.0
 * @description 测试的Service
 */
@Service
public class PersonService {
    @Autowired
    private PersonDao personDao2;
    @Override
    public String toString() {
        return personDao2.toString();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时，我们再次运行AutowiredTest类的testAutowired01()方法，输出的结果信息如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;PersonDao{remark='2'}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，此时命令行输出了personDao2的信息。&lt;/p&gt;
&lt;h3 id=&quot;测试qualifier注解&quot;&gt;测试@Qualifier注解&lt;/h3&gt;
&lt;p&gt;从测试@Autowired注解的结果来看：&lt;strong&gt;@Autowired注解默认优先按照类型去容器中找对应的组件，找到就赋值；如果找到多个相同类型的组件，再将属性名称作为组件的id，到 IOC 容器中进行查找。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果IOC容器中存在多个相同类型的组件时，我们可不可以显示指定@Autowired注解装配哪个组件呢？有些小伙伴肯定会说：废话！你都这么问了，那肯定可以啊！没错，确实可以啊！此时，@Qualifier注解就派上用场了！&lt;/p&gt;
&lt;p&gt;在之前的测试案例中，命令行输出了 &lt;code&gt;PersonDao{remark='2'}&lt;/code&gt; 说明@Autowired注解装配了personDao2，那我们如何显示的让@Autowired注解装配personDao呢？&lt;/p&gt;
&lt;p&gt;比较简单，我们只需要在PersonService类上personDao2字段上添加@Qualifier注解，显示指定@Autowired注解装配personDao，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Qualifier(&quot;personDao&quot;)
@Autowired
private PersonDao personDao2;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时，我们再次运行AutowiredTest类的testAutowired01()方法，输出的结果信息如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;PersonDao{remark='1'}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，此时尽管字段的名称为personDao2，但是我们使用了@Qualifier注解显示指定@Autowired注解装配personDao对象，所以，最终的结果输出了personDao对象的信息。&lt;/p&gt;
&lt;h3 id=&quot;测试容器中无组件的情况&quot;&gt;测试容器中无组件的情况&lt;/h3&gt;
&lt;p&gt;如果IOC容器中无相应的组件，会发生什么情况呢？此时，我们删除PersonDao类上的@Repository注解，并且删除AutowiredConfig类中的personDao()方法上的@Bean注解，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package io.mykit.spring.plugins.register.dao;

/**
 * @author binghe
 * @version 1.0.0
 * @description 测试的dao
 */
public class PersonDao {
    private String remark = &quot;1&quot;;

    public String getRemark() {
        return remark;
    }

    public void setRemark(String remark) {
        this.remark = remark;
    }

    @Override
    public String toString() {
        return &quot;PersonDao{&quot; +
                &quot;remark='&quot; + remark + '\'' +
                '}';
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package io.mykit.spring.plugins.register.config;

import io.mykit.spring.plugins.register.dao.PersonDao;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;

/**
 * @author binghe
 * @version 1.0.0
 * @description 测试自动装配组件的Config配置类
 */
@Configuration
@ComponentScan(value = {
        &quot;io.mykit.spring.plugins.register.dao&quot;,
        &quot;io.mykit.spring.plugins.register.service&quot;,
        &quot;io.mykit.spring.plugins.register.controller&quot;})
public class AutowiredConfig {
    public PersonDao personDao(){
        PersonDao personDao = new PersonDao();
        personDao.setRemark(&quot;2&quot;);
        return personDao;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时IOC容器中不再有personDao，我们再次运行AutowiredTest类的testAutowired01()方法，输出的结果信息如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;Caused by: org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type 'io.mykit.spring.plugins.register.dao.PersonDao' available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: {@org.springframework.beans.factory.annotation.Qualifier(value=personDao), @org.springframework.beans.factory.annotation.Autowired(required=true)}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，Spring抛出了异常，未找到相应的bean对象，&lt;strong&gt;我们能不能让Spring不报错呢？&lt;/strong&gt; 那肯定可以啊！Spring的异常信息中都给出了相应的提示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;{@org.springframework.beans.factory.annotation.Qualifier(value=personDao), @org.springframework.beans.factory.annotation.Autowired(required=true)}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解决方案就是在PersonService类的@Autowired添加一个属性&lt;code&gt;required=false&lt;/code&gt;，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Qualifier(&quot;personDao&quot;)
@Autowired(required = false)
private PersonDao personDao2;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;并且我们修改下PersonService的toString()方法，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Override
public String toString() {
    return &quot;PersonService{&quot; +
        &quot;personDao2=&quot; + personDao2 +
        '}';
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时，还需要将AutowiredTest类的testAutowired01()方法中直接从IOC容器中获取personDao的代码删除，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void testAutowired01(){
    //创建IOC容器
    AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AutowiredConfig.class);
    PersonService personService = context.getBean(PersonService.class);
    System.out.println(personService);
    context.close();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时，我们再次运行AutowiredTest类的testAutowired01()方法，输出的结果信息如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;PersonService{personDao2=null}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，当为@Autowired添加属性&lt;code&gt;required=false&lt;/code&gt;后，即使IOC容器中没有对应的对象，Spring也不会抛出异常。此时，装配的对象就为null。&lt;/p&gt;
&lt;p&gt;测试完成后，我们再次为PersonDao类添加@Repository注解，并且为AutowiredConfig类中的personDao()方法添加@Bean注解。&lt;/p&gt;
&lt;h3 id=&quot;测试primary注解&quot;&gt;测试@Primary注解&lt;/h3&gt;
&lt;p&gt;在Spring中，对同一个接口，可能会有几种不同的实现类，而默认只会采取其中一种实现的情况下， 就可以使用@Primary注解来标注优先使用哪一个实现类。&lt;/p&gt;
&lt;p&gt;首先，我们在AutowiredConfig类的personDao()方法上添加@Primary注解，此时，我们需要删除PersonService类中personDao字段上的@Qualifier注解，这是因为@Qualifier注解为显示指定装配哪个组件，如果使用了@Qualifier注解，无论是否使用了@Primary注解，都会装配@Qualifier注解标注的对象。&lt;/p&gt;
&lt;p&gt;设置完成后，我们再次运行AutowiredTest类的testAutowired01()方法，输出的结果信息如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;PersonService{personDao2=PersonDao{remark='2'}}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，此时remark的值为2，装配了AutowiredConfig类中注入的personDao。&lt;/p&gt;
&lt;p&gt;接下来，我们为PersonService类中personDao字段再次添加@Qualifier注解，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Qualifier(&quot;personDao&quot;)
@Autowired(required = false)
private PersonDao personDao;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时，我们再次运行AutowiredTest类的testAutowired01()方法，输出的结果信息如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;PersonService{personDao=PersonDao{remark='1'}}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，此时，Spring装配了使用@Qualifier标注的personDao。&lt;/p&gt;
&lt;h2 id=&quot;重磅福利&quot;&gt;重磅福利&lt;/h2&gt;
&lt;p&gt;关注「 &lt;strong&gt;冰河技术&lt;/strong&gt; 」微信公众号，后台回复 “&lt;strong&gt;设计模式&lt;/strong&gt;” 关键字领取《&lt;strong&gt;深入浅出Java 23种设计模式&lt;/strong&gt;》PDF文档。回复“&lt;strong&gt;Java8&lt;/strong&gt;”关键字领取《&lt;strong&gt;Java8新特性教程&lt;/strong&gt;》PDF文档。回复“&lt;strong&gt;限流&lt;/strong&gt;”关键字获取《&lt;strong&gt;亿级流量下的分布式限流解决方案&lt;/strong&gt;》PDF文档，三本PDF均是由冰河原创并整理的超硬核教程，面试必备！！&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;好了，今天就聊到这儿吧！别忘了点个赞，给个在看和转发，让更多的人看到，一起学习，一起进步！！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;写在最后&quot;&gt;写在最后&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;如果你觉得冰河写的还不错，请微信搜索并关注「 &lt;strong&gt;冰河技术&lt;/strong&gt; 」微信公众号，跟冰河学习高并发、分布式、微服务、大数据、互联网和云原生技术，「 &lt;strong&gt;冰河技术&lt;/strong&gt; 」微信公众号更新了大量技术专题，每一篇技术文章干货满满！不少读者已经通过阅读「 &lt;strong&gt;冰河技术&lt;/strong&gt; 」微信公众号文章，吊打面试官，成功跳槽到大厂；也有不少读者实现了技术上的飞跃，成为公司的技术骨干！如果你也想像他们一样提升自己的能力，实现技术能力的飞跃，进大厂，升职加薪，那就关注「 &lt;strong&gt;冰河技术&lt;/strong&gt; 」微信公众号吧，每天更新超硬核技术干货，让你对如何提升技术能力不再迷茫！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200716220443647.png#pic_center&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 12 Aug 2020 15:47:00 +0000</pubDate>
<dc:creator>冰河团队</dc:creator>
<og:description>写在前面 【Spring专题】停更一个多月，期间在更新其他专题的内容，不少小伙伴纷纷留言说：冰河，你【Spring专题】是不是停更了啊！其实并没有停更，只是中途有很多小伙伴留言说急需学习一些知识技能，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/binghe001/p/13493844.html</dc:identifier>
</item>
<item>
<title>Springboot入门 - 平酱</title>
<link>http://www.cnblogs.com/p1ng/p/13493746.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/p1ng/p/13493746.html</guid>
<description>&lt;ul&gt;&lt;li&gt;了解SpringBoot的作用&lt;/li&gt;
&lt;li&gt;掌握java配置的方式&lt;/li&gt;
&lt;li&gt;了解SpringBoot自动配置原理&lt;/li&gt;
&lt;li&gt;掌握SpringBoot的基本使用&lt;/li&gt;
&lt;li&gt;了解Thymeleaf的基本使用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在这一部分，我们主要了解以下3个问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;什么是SpringBoot&lt;/li&gt;
&lt;li&gt;为什么要学习SpringBoot&lt;/li&gt;
&lt;li&gt;SpringBoot的特点&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;11什么是springboot&quot;&gt;1.1.什么是SpringBoot&lt;/h2&gt;
&lt;p&gt;SpringBoot是Spring项目中的一个子工程，与我们所熟知的Spring-framework 同属于spring的产品:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200812100822024-872226664.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以看到下面的一段介绍：&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;Spring Boot makes it easy to create stand-alone, production-grade Spring based Applications that you can &quot;just run&quot;.&lt;/p&gt;
&lt;p&gt;We take an opinionated view of the Spring platform and third-party libraries so you can get started with minimum fuss. Most Spring Boot applications need very little Spring configuration.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;翻译一下：&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;Spring Boot你只需要“run”就可以非常轻易的构建独立的、生产级别的spring应用。&lt;/p&gt;
&lt;p&gt;我们为spring平台和第三方依赖库提供了一种固定化的使用方式，使你能非常轻松的开始开发你的应用程序。大部分Spring Boot应用只需要很少的配置。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其实人们把Spring Boot称为搭建程序的&lt;code&gt;脚手架&lt;/code&gt;。其最主要作用就是帮我们快速的构建庞大的spring项目，并且尽可能的减少一切xml配置，做到开箱即用，迅速上手，让我们关注于业务而非配置。&lt;/p&gt;
&lt;p&gt;我们可以使用SpringBoot创建java应用，并使用java –jar 启动它，就能得到一个生产级别的web工程。&lt;/p&gt;
&lt;h2 id=&quot;12为什么要学习springboot&quot;&gt;1.2.为什么要学习SpringBoot&lt;/h2&gt;
&lt;p&gt;java一直被人诟病的一点就是臃肿、麻烦。当我们还在辛苦的搭建项目时，可能Python程序员已经把功能写好了，究其原因主要是两点：&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;复杂的配置&lt;/p&gt;
&lt;p&gt;项目各种配置其实是开发时的损耗， 因为在思考 Spring 特性配置和解决业务问题之间需要进行思维切换，所以写配置挤占了写应用程序逻辑的时间。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;混乱的依赖管理&lt;/p&gt;
&lt;p&gt;项目的依赖管理也是件吃力不讨好的事情。决定项目里要用哪些库就已经够让人头痛的了，你还要知道这些库的哪个版本和其他库不会有冲突，这也是件棘手的问题。并且，依赖管理也是一种损耗，添加依赖不是写应用程序代码。一旦选错了依赖的版本，随之而来的不兼容问题毫无疑问会是生产力杀手。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;而SpringBoot让这一切成为过去！&lt;/p&gt;
&lt;h2 id=&quot;13springboot的特点&quot;&gt;1.3.SpringBoot的特点&lt;/h2&gt;
&lt;p&gt;Spring Boot 主要特征是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;创建独立的spring应用程序&lt;/li&gt;
&lt;li&gt;直接内嵌tomcat、jetty和undertow（不需要打包成war包部署）&lt;/li&gt;
&lt;li&gt;提供了固定化的“starter”配置，以简化构建配置&lt;/li&gt;
&lt;li&gt;尽可能的自动配置spring和第三方库&lt;/li&gt;
&lt;li&gt;提供产品级的功能，如：安全指标、运行状况监测和外部化配置等&lt;/li&gt;
&lt;li&gt;绝对不会生成代码，并且不需要XML配置&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;总之，Spring Boot为所有 Spring 的开发者提供一个开箱即用的、非常快速的、广泛接受的入门体验&lt;/p&gt;
&lt;p&gt;更多细节，大家可以到&lt;a href=&quot;http://projects.spring.io/spring-boot/&quot;&gt;官网&lt;/a&gt;查看。&lt;/p&gt;

&lt;p&gt;接下来，我们就来利用SpringBoot搭建一个web工程，体会一下SpringBoot的魅力所在！&lt;/p&gt;
&lt;p&gt;环境要求：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200812100913173-1306366748.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;21创建工程&quot;&gt;2.1.创建工程&lt;/h2&gt;
&lt;p&gt;我们先新建一个空的demo工程，创建moduel并填写坐标信息。&lt;/p&gt;
&lt;p&gt;创建完成后的目录结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200812104815459-602838940.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;22引入依赖&quot;&gt;2.2.引入依赖&lt;/h2&gt;
&lt;p&gt;看到这里很多同学会有疑惑，前面说传统开发的问题之一就是依赖管理混乱，怎么这里我们还需要管理依赖呢？难道SpringBoot不帮我们管理吗？&lt;/p&gt;
&lt;p&gt;别着急，现在我们的项目与SpringBoot还没有什么关联。SpringBoot提供了一个名为spring-boot-starter-parent的工程，里面已经对各种常用依赖（并非全部）的版本进行了管理，我们的项目需要以这个项目为父工程，这样我们就不用操心依赖的版本问题了，需要什么依赖，直接引入坐标即可！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200812104840115-1286582288.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

    &amp;lt;groupId&amp;gt;cn.itcast.springboot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;itcast-springboot&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;

    &amp;lt;!-- 所有的springboot的工程都以spring父工程为父工程 --&amp;gt;
    &amp;lt;parent&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;2.0.6.RELEASE&amp;lt;/version&amp;gt;
    &amp;lt;/parent&amp;gt;

    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;
&amp;lt;/project&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;23编写hellocontroller&quot;&gt;2.3.编写HelloController&lt;/h2&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@RestController
@EnableAutoConfiguration
public class HelloController {

    @GetMapping(&quot;show&quot;)
    public String test(){
        return &quot;hello Spring Boot!&quot;;
    }

    public static void main(String[] args) {
        SpringApplication.run(HelloController.class, args);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;24启动测试&quot;&gt;2.4.启动测试&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200812105053003-329120713.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200812105102814-115870354.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;bingo！访问成功！&lt;/p&gt;
&lt;h2 id=&quot;25详解&quot;&gt;2.5.详解&lt;/h2&gt;
&lt;p&gt;入门工程中：pom.xml里引入了启动器的概念以@EnableAutoConfiguration注解。&lt;/p&gt;
&lt;h3 id=&quot;251启动器&quot;&gt;2.5.1.启动器&lt;/h3&gt;
&lt;p&gt;为了让SpringBoot帮我们完成各种自动配置，我们必须引入SpringBoot提供的自动配置依赖，我们称为&lt;code&gt;启动器&lt;/code&gt;。spring-boot-starter-parent工程将依赖关系声明为一个或者多个启动器，我们可以根据项目需求引入相应的启动器，因为我们是web项目，这里我们引入web启动器：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要注意的是，我们并没有在这里指定版本信息。因为SpringBoot的父工程已经对版本进行了管理了。&lt;/p&gt;
&lt;p&gt;这个时候，我们会发现项目中多出了大量的依赖：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200812112043372-1814302716.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这些都是SpringBoot根据spring-boot-starter-web这个依赖自动引入的，而且所有的版本都已经管理好，不会出现冲突。&lt;/p&gt;
&lt;h3 id=&quot;252enableautoconfiguration&quot;&gt;2.5.2.@EnableAutoConfiguration&lt;/h3&gt;
&lt;p&gt;关于这个注解，官网上有一段说明：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Enable auto-configuration of the Spring Application Context, attempting to guess and configure beans that you are likely to need. Auto-configuration classes are usually applied based on your classpath and what beans you have defined.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单翻译以下：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;开启spring应用程序的自动配置，SpringBoot基于你所添加的依赖和你自己定义的bean，试图去猜测并配置你想要的配置。比如我们引入了&lt;code&gt;spring-boot-starter-web&lt;/code&gt;，而这个启动器中帮我们添加了&lt;code&gt;tomcat&lt;/code&gt;、&lt;code&gt;SpringMVC&lt;/code&gt;的依赖。此时自动配置就知道你是要开发一个web应用，所以就帮你完成了web及SpringMVC的默认配置了！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;总结，SpringBoot内部对大量的第三方库或Spring内部库进行了默认配置，这些配置是否生效，取决于我们是否引入了对应库所需的依赖，如果有那么默认配置就会生效。&lt;/p&gt;
&lt;p&gt;所以，我们使用SpringBoot构建一个项目，只需要引入所需依赖，配置就可以交给SpringBoot处理了。&lt;/p&gt;
&lt;h2 id=&quot;26优化入门程序&quot;&gt;2.6.优化入门程序&lt;/h2&gt;
&lt;p&gt;现在工程中只有一个Controller，可以这么玩；那么如果有多个Controller，怎么办呢？&lt;/p&gt;
&lt;p&gt;添加Hello2Controller&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@RestController
public class Hello2Controller {

    @GetMapping(&quot;show2&quot;)
    public String test(){
        return &quot;hello Spring Boot2!&quot;;
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动重新启动，访问show2测试，失败：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200812112123750-1081580507.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;难道要在每一个Controller中都添加一个main方法和@EnableAutoConfiguration注解，这样启动一个springboot程序也太麻烦了。也无法同时启动多个Controller，因为每个main方法都监听8080端口。所以，一个springboot程序应该只有一个springboot的main方法。&lt;/p&gt;
&lt;p&gt;所以，springboot程序引入了一个全局的引导类。&lt;/p&gt;
&lt;h3 id=&quot;251添加引导类&quot;&gt;2.5.1.添加引导类&lt;/h3&gt;
&lt;p&gt;通常请求下，我们在一个springboot工程中都会在基包下创建一个引导类，一些springboot的全局注解（@EnableAutoConfiguration注解）以及springboot程序的入口main方法都放在该类中。&lt;/p&gt;
&lt;p&gt;在springboot的程序的基包下（引导类和Controller包在同级目录下），创建TestApplication.class：&lt;/p&gt;
&lt;p&gt;内容如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@EnableAutoConfiguration
public class TestApplication {

    public static void main(String[] args) {
        SpringApplication.run(TestApplication.class, args);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;并修改HelloController，去掉main方法及@EnableAutoConfiguration：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@RestController
public class HelloController {

    @GetMapping(&quot;show&quot;)
    public String test(){
        return &quot;hello Spring Boot!&quot;;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动引导类，访问show测试：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200812112208769-1456894759.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;发现所有的Controller都不能访问，为什么？&lt;/p&gt;
&lt;p&gt;回想以前程序，我们在配置文件中添加了注解扫描，它能扫描指定包下的所有Controller，而现在并没有。怎么解决——@ComponentScan注解&lt;/p&gt;
&lt;h3 id=&quot;252componentscan&quot;&gt;2.5.2.@ComponentScan&lt;/h3&gt;
&lt;p&gt;spring框架除了提供配置方式的注解扫描&lt;code&gt;&amp;lt;context:component-scan /&amp;gt;&lt;/code&gt;，还提供了注解方式的注解扫描&lt;code&gt;@ComponentScan&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在TestApplication.class中，使用@ComponentScan注解：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@EnableAutoConfiguration
@ComponentScan
public class TestApplication {

    public static void main(String[] args) {
        SpringApplication.run(TestApplication.class, args);
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重新启动，访问show或者show2：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200812112412780-241408672.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200812112421078-747463963.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们跟进该注解的源码，并没有看到什么特殊的地方。我们查看注释：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200812112430510-127048390.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;大概的意思：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;配置组件扫描的指令。提供了类似与&lt;code&gt;&amp;lt;context:component-scan&amp;gt;&lt;/code&gt;标签的作用&lt;/p&gt;
&lt;p&gt;通过basePackageClasses或者basePackages属性来指定要扫描的包。如果没有指定这些属性，那么将从声明这个注解的类所在的包开始，扫描包及子包&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;而我们的@ComponentScan注解声明的类就是main函数所在的启动类，因此扫描的包是该类所在包及其子包。&lt;strong&gt;一般启动类会放在一个比较浅的包目录中。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;253springbootapplication&quot;&gt;2.5.3.@SpringBootApplication&lt;/h3&gt;
&lt;p&gt;我们现在的引导类中使用了@EnableAutoConfiguration和@ComponentScan注解，有点麻烦。springboot提供了一种简便的玩法：@SpringBootApplication注解&lt;/p&gt;
&lt;p&gt;使用@SpringBootApplication改造TestApplication：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@SpringBootApplication
public class TestApplication {

    public static void main(String[] args) {
        SpringApplication.run(TestApplication.class, args);
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;点击进入，查看源码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200812113321551-173628630.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;发现@SpringBootApplication其实是一个组合注解，这里重点的注解有3个：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;@SpringBootConfiguration&lt;/li&gt;
&lt;li&gt;@EnableAutoConfiguration：开启自动配置&lt;/li&gt;
&lt;li&gt;@ComponentScan：开启注解扫描&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;254springbootconfiguration&quot;&gt;2.5.4.@SpringBootConfiguration&lt;/h3&gt;
&lt;p&gt;@SpringBootConfiguration注解的源码：&lt;/p&gt;
&lt;p&gt;我们继续点击查看源码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200812113342811-273455654.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过这段我们可以看出，在这个注解上面，又有一个&lt;code&gt;@Configuration&lt;/code&gt;注解。通过上面的注释阅读我们知道：这个注解的作用就是声明当前类是一个配置类，然后Spring会自动扫描到添加了&lt;code&gt;@Configuration&lt;/code&gt;的类，并且读取其中的配置信息。而&lt;code&gt;@SpringBootConfiguration&lt;/code&gt;是来声明当前类是SpringBoot应用的配置类，项目中只能有一个。所以一般我们无需自己添加。&lt;/p&gt;

&lt;p&gt;springboot的默认配置方式和我们之前玩的配置方式不太一样，没有任何的xml。那么如果自己要新增配置该怎么办？比如我们要配置一个数据库连接池，以前会这么做：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;!-- 配置连接池 --&amp;gt;
&amp;lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;
      init-method=&quot;init&quot; destroy-method=&quot;close&quot;&amp;gt;
    &amp;lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot; /&amp;gt;
    &amp;lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot; /&amp;gt;
    &amp;lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在该怎么做呢?&lt;/p&gt;
&lt;h2 id=&quot;31回顾历史&quot;&gt;3.1.回顾历史&lt;/h2&gt;
&lt;p&gt;事实上，在Spring3.0开始，Spring官方就已经开始推荐使用java配置来代替传统的xml配置了，我们不妨来回顾一下Spring的历史：&lt;/p&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;Spring1.0时代&lt;/p&gt;
&lt;p&gt;在此时因为jdk1.5刚刚出来，注解开发并未盛行，因此一切Spring配置都是xml格式，想象一下所有的bean都用xml配置，细思极恐啊，心疼那个时候的程序员2秒&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Spring2.0时代&lt;/p&gt;
&lt;p&gt;Spring引入了注解开发，但是因为并不完善，因此并未完全替代xml，此时的程序员往往是把xml与注解进行结合，貌似我们之前都是这种方式。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;Spring3.0及以后&lt;/p&gt;
&lt;p&gt;3.0以后Spring的注解已经非常完善了，因此Spring推荐大家使用完全的java配置来代替以前的xml，不过似乎在国内并未推广盛行。然后当SpringBoot来临，人们才慢慢认识到java配置的优雅。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;有句古话说的好：拥抱变化，拥抱未来。所以我们也应该顺应时代潮流，做时尚的弄潮儿，一起来学习下java配置的玩法。&lt;/p&gt;
&lt;h2 id=&quot;32尝试java配置&quot;&gt;3.2.尝试java配置&lt;/h2&gt;
&lt;p&gt;java配置主要靠java类和一些注解来达到和xml配置一样的效果，比较常用的注解有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;@Configuration&lt;/code&gt;：声明一个类作为配置类，代替xml文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Bean&lt;/code&gt;：声明在方法上，将方法的返回值加入Bean容器，代替&lt;code&gt;&amp;lt;bean&amp;gt;&lt;/code&gt;标签&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Value&lt;/code&gt;：属性注入&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@PropertySource&lt;/code&gt;：指定外部属性文件。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们接下来用java配置来尝试实现连接池配置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200812113435477-1600842575.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;321引入依赖&quot;&gt;3.2.1.引入依赖&lt;/h3&gt;
&lt;p&gt;首先在pom.xml中，引入Druid连接池依赖：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.github.drtrang&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;druid-spring-boot2-starter&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.1.10&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;322添加jdbcproperties&quot;&gt;3.2.2.添加jdbc.properties&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-properties&quot;&gt;jdbc.driverClassName=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql://127.0.0.1:3306/leyou
jdbc.username=root
jdbc.password=root
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;323配置数据源&quot;&gt;3.2.3.配置数据源&lt;/h3&gt;
&lt;p&gt;创建JdbcConfiguration类：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Configuration
@PropertySource(&quot;classpath:jdbc.properties&quot;)
public class JdbcConfiguration {

    @Value(&quot;${jdbc.url}&quot;)
    String url;
    @Value(&quot;${jdbc.driverClassName}&quot;)
    String driverClassName;
    @Value(&quot;${jdbc.username}&quot;)
    String username;
    @Value(&quot;${jdbc.password}&quot;)
    String password;

    @Bean
    public DataSource dataSource() {
        DruidDataSource dataSource = new DruidDataSource();
        dataSource.setUrl(url);
        dataSource.setDriverClassName(driverClassName);
        dataSource.setUsername(username);
        dataSource.setPassword(password);
        return dataSource;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解读：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;@Configuration&lt;/code&gt;：声明&lt;code&gt;JdbcConfiguration&lt;/code&gt;是一个配置类。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@PropertySource&lt;/code&gt;：指定属性文件的路径是:&lt;code&gt;classpath:jdbc.properties&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;通过&lt;code&gt;@Value&lt;/code&gt;为属性注入值。&lt;/li&gt;
&lt;li&gt;通过@Bean将 &lt;code&gt;dataSource()&lt;/code&gt;方法声明为一个注册Bean的方法，Spring会自动调用该方法，将方法的返回值加入Spring容器中。相当于以前的bean标签&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;然后就可以在任意位置通过&lt;code&gt;@Autowired&lt;/code&gt;注入DataSource了！&lt;/p&gt;
&lt;h3 id=&quot;324测试&quot;&gt;3.2.4.测试&lt;/h3&gt;
&lt;p&gt;我们在&lt;code&gt;HelloController&lt;/code&gt;中测试：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@RestController
public class HelloController {

    @Autowired
    private DataSource dataSource;

    @GetMapping(&quot;show&quot;)
    public String test(){
        return &quot;hello Spring Boot!&quot;;
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在test方法中打一个断点，然后Debug运行并查看：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200812113509971-1574422682.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;属性注入成功了！&lt;/p&gt;
&lt;h2 id=&quot;33springboot的属性注入&quot;&gt;3.3.SpringBoot的属性注入&lt;/h2&gt;
&lt;p&gt;在上面的案例中，我们实验了java配置方式。不过属性注入使用的是@Value注解。这种方式虽然可行，但是不够强大，因为它只能注入基本类型值。&lt;/p&gt;
&lt;p&gt;在SpringBoot中，提供了一种新的属性注入方式，支持各种java基本数据类型及复杂类型的注入。&lt;/p&gt;
&lt;p&gt;1）新建&lt;code&gt;JdbcProperties&lt;/code&gt;，用来进行属性注入：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200812113534253-266332270.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@ConfigurationProperties(prefix = &quot;jdbc&quot;)
public class JdbcProperties {
    private String url;
    private String driverClassName;
    private String username;
    private String password;
    // ... 略
    // getters 和 setters
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在类上通过@ConfigurationProperties注解声明当前类为属性读取类&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;prefix=&quot;jdbc&quot;&lt;/code&gt;读取属性文件中，前缀为jdbc的值。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;在类上定义各个属性，名称必须与属性文件中&lt;code&gt;jdbc.&lt;/code&gt;后面部分一致，并且必须具有getter和setter方法&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;需要注意的是，这里我们并没有指定属性文件的地址，SpringBoot默认会读取文件名为application.properties的资源文件，所以我们&lt;strong&gt;把jdbc.properties名称改为application.properties&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;2）在JdbcConfiguration中使用这个属性：&lt;/p&gt;
&lt;ul readability=&quot;5.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;通过&lt;code&gt;@EnableConfigurationProperties(JdbcProperties.class)&lt;/code&gt;来声明要使用&lt;code&gt;JdbcProperties&lt;/code&gt;这个类的对象&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;11&quot;&gt;
&lt;p&gt;然后你可以通过以下方式在JdbcConfiguration类中注入JdbcProperties：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;@Autowired注入&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Configuration
@EnableConfigurationProperties(JdbcProperties.class)
public class JdbcConfiguration {

    @Autowired
    private JdbcProperties jdbcProperties;

    @Bean
    public DataSource dataSource() {
        DruidDataSource dataSource = new DruidDataSource();
        dataSource.setUrl(jdbcProperties.getUrl());
        dataSource.setDriverClassName(jdbcProperties.getDriverClassName());
        dataSource.setUsername(jdbcProperties.getUsername());
        dataSource.setPassword(jdbcProperties.getPassword());
        return dataSource;
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;构造函数注入&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Configuration
@EnableConfigurationProperties(JdbcProperties.class)
public class JdbcConfiguration {

    private JdbcProperties jdbcProperties;

    public JdbcConfiguration(JdbcProperties jdbcProperties){
        this.jdbcProperties = jdbcProperties;
    }

    @Bean
    public DataSource dataSource() {
        // 略
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;@Bean方法的参数注入&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Configuration
@EnableConfigurationProperties(JdbcProperties.class)
public class JdbcConfiguration {

    @Bean
    public DataSource dataSource(JdbcProperties jdbcProperties) {
        // ...
    }
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;本例中，我们采用第三种方式。&lt;/p&gt;
&lt;p&gt;3）测试结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200812113604301-1504262142.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;大家会觉得这种方式似乎更麻烦了，事实上这种方式有更强大的功能，也是SpringBoot推荐的注入方式。两者对比关系：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200812113809407-478954793.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;优势：&lt;/p&gt;
&lt;h2 id=&quot;34更优雅的注入&quot;&gt;3.4.更优雅的注入&lt;/h2&gt;
&lt;p&gt;事实上，如果一段属性只有一个Bean需要使用，我们无需将其注入到一个类（JdbcProperties）中。而是直接在需要的地方声明即可：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Configuration
public class JdbcConfiguration {
    
    @Bean
    // 声明要注入的属性前缀，SpringBoot会自动把相关属性通过set方法注入到DataSource中
    @ConfigurationProperties(prefix = &quot;jdbc&quot;)
    public DataSource dataSource() {
        DruidDataSource dataSource = new DruidDataSource();
        return dataSource;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们直接把&lt;code&gt;@ConfigurationProperties(prefix = &quot;jdbc&quot;)&lt;/code&gt;声明在需要使用的&lt;code&gt;@Bean&lt;/code&gt;的方法上，然后SpringBoot就会自动调用这个Bean（此处是DataSource）的set方法，然后完成注入。使用的前提是：&lt;strong&gt;该类必须有对应属性的set方法！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们将jdbc的url改成：/heima，再次测试：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200812134149416-199509072.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;35springboot中的默认配置&quot;&gt;3.5.SpringBoot中的默认配置&lt;/h2&gt;
&lt;p&gt;通过刚才的学习，我们知道@EnableAutoConfiguration会开启SpringBoot的自动配置，并且根据你引入的依赖来生效对应的默认配置。那么问题来了：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;这些默认配置是怎么配置的，在哪里配置的呢？&lt;/li&gt;
&lt;li&gt;为何依赖引入就会触发配置呢？&lt;/li&gt;
&lt;li&gt;这些默认配置的属性来自哪里呢？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其实在我们的项目中，已经引入了一个依赖：spring-boot-autoconfigure，其中定义了大量自动配置类：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200812134208782-409102317.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还有：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200812134217945-853138873.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;非常多，几乎涵盖了现在主流的开源框架，例如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;redis&lt;/li&gt;
&lt;li&gt;jms&lt;/li&gt;
&lt;li&gt;amqp&lt;/li&gt;
&lt;li&gt;jdbc&lt;/li&gt;
&lt;li&gt;jackson&lt;/li&gt;
&lt;li&gt;mongodb&lt;/li&gt;
&lt;li&gt;jpa&lt;/li&gt;
&lt;li&gt;solr&lt;/li&gt;
&lt;li&gt;elasticsearch&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;... 等等&lt;/p&gt;
&lt;p&gt;我们来看一个我们熟悉的，例如SpringMVC，查看mvc 的自动配置类：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200812134228799-1594006113.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;打开WebMvcAutoConfiguration：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200812141432815-747323711.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们看到这个类上的4个注解：&lt;/p&gt;
&lt;ul readability=&quot;8&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;@Configuration&lt;/code&gt;：声明这个类是一个配置类&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;code&gt;@ConditionalOnWebApplication(type = Type.SERVLET)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;ConditionalOn，翻译就是在某个条件下，此处就是满足项目的类是是Type.SERVLET类型，也就是一个普通web工程，显然我们就是&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;code&gt;@ConditionalOnClass({ Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class })&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这里的条件是OnClass，也就是满足以下类存在：Servlet、DispatcherServlet、WebMvcConfigurer，其中Servlet只要引入了tomcat依赖自然会有，后两个需要引入SpringMVC才会有。这里就是判断你是否引入了相关依赖，引入依赖后该条件成立，当前类的配置才会生效！&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;&lt;code&gt;@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这个条件与上面不同，OnMissingBean，是说环境中没有指定的Bean这个才生效。其实这就是自定义配置的入口，也就是说，如果我们自己配置了一个WebMVCConfigurationSupport的类，那么这个默认配置就会失效！&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;接着，我们查看该类中定义了什么：&lt;/p&gt;
&lt;p&gt;视图解析器：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200812141446802-1757508598.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;处理器适配器（HandlerAdapter）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200812141511250-1343414040.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还有很多，这里就不一一截图了。&lt;/p&gt;
&lt;p&gt;另外，这些默认配置的属性来自哪里呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200812141544527-913332032.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们看到，这里通过@EnableAutoConfiguration注解引入了两个属性：WebMvcProperties和ResourceProperties。&lt;/p&gt;
&lt;p&gt;我们查看这两个属性类：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200812141554416-531986944.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;找到了内部资源视图解析器的prefix和suffix属性。&lt;/p&gt;
&lt;p&gt;ResourceProperties中主要定义了静态资源（.js,.html,.css等)的路径：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200812141604149-1087891347.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果我们要覆盖这些默认属性，只需要在application.properties中定义与其前缀prefix和字段名一致的属性即可。&lt;/p&gt;
&lt;h2 id=&quot;36总结&quot;&gt;3.6.总结&lt;/h2&gt;
&lt;p&gt;SpringBoot为我们提供了默认配置，而默认配置生效的条件一般有两个：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;你引入了相关依赖&lt;/li&gt;
&lt;li&gt;你自己没有配置&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;1）启动器&lt;/p&gt;
&lt;p&gt;之所以，我们如果不想配置，只需要引入依赖即可，而依赖版本我们也不用操心，因为只要引入了SpringBoot提供的stater（启动器），就会自动管理依赖及版本了。&lt;/p&gt;
&lt;p&gt;因此，玩SpringBoot的第一件事情，就是找启动器，SpringBoot提供了大量的默认启动器，参考&lt;a href=&quot;https://www.cnblogs.com/p1ng/p/13493755.html&quot;&gt;SpringBoot启动器&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2）全局配置&lt;/p&gt;
&lt;p&gt;另外，SpringBoot的默认配置，都会读取默认属性，而这些属性可以通过自定义&lt;code&gt;application.properties&lt;/code&gt;文件来进行覆盖。这样虽然使用的还是默认配置，但是配置中的值改成了我们自定义的。&lt;/p&gt;
&lt;p&gt;因此，玩SpringBoot的第二件事情，就是通过&lt;code&gt;application.properties&lt;/code&gt;来覆盖默认属性值，形成自定义配置。我们需要知道SpringBoot的默认属性key，非常多，参考&lt;a href=&quot;https://www.cnblogs.com/p1ng/p/13493766.html&quot;&gt;SpringBoot全局属性&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;接下来，我们来看看如何用SpringBoot来玩转以前的SSM,我们使用数据库tb_user和实体类User&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200812221047141-1175529073.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;41创建工程&quot;&gt;4.1.创建工程&lt;/h2&gt;
&lt;h2 id=&quot;42编写基本代码&quot;&gt;4.2.编写基本代码&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200812141859044-1875607584.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;pom.xml:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;

    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

    &amp;lt;groupId&amp;gt;cn.itcast.user&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;itcast-user&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;

    &amp;lt;parent&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;2.0.6.RELEASE&amp;lt;/version&amp;gt;
    &amp;lt;/parent&amp;gt;

    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;

&amp;lt;/project&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参照上边的项目，编写引导类：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@SpringBootApplication
public class UserApplication {

    public static void main(String[] args) {
        SpringApplication.run(UserApplication.class);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;编写UserController：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@RestController
@RequestMapping(&quot;user&quot;)
public class UserController {

    @GetMapping(&quot;hello&quot;)
    public String test(){
        return &quot;hello ssm&quot;;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;43整合springmvc&quot;&gt;4.3.整合SpringMVC&lt;/h2&gt;
&lt;p&gt;虽然默认配置已经可以使用SpringMVC了，不过我们有时候需要进行自定义配置。&lt;/p&gt;
&lt;h3 id=&quot;431修改端口&quot;&gt;4.3.1.修改端口&lt;/h3&gt;
&lt;p&gt;添加全局配置文件：application.properties&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200812142739574-2015433702.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;端口通过以下方式配置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200812142802763-1544775623.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-properties&quot;&gt;# 映射端口
server.port=80
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重启服务后测试：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200812142852391-1190871468.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200812142900190-666294165.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;432访问静态资源&quot;&gt;4.3.2.访问静态资源&lt;/h3&gt;
&lt;p&gt;现在，我们的项目是一个jar工程，那么就没有webapp，我们的静态资源该放哪里呢？&lt;/p&gt;
&lt;p&gt;回顾我们上面看的源码，有一个叫做ResourceProperties的类，里面就定义了静态资源的默认查找路径：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200812143055260-921042397.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;默认的静态资源路径为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;classpath:/META-INF/resources/&lt;/li&gt;
&lt;li&gt;classpath:/resources/&lt;/li&gt;
&lt;li&gt;classpath:/static/&lt;/li&gt;
&lt;li&gt;classpath:/public/&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;只要静态资源放在这些目录中任何一个，SpringMVC都会帮我们处理。&lt;/p&gt;
&lt;p&gt;我们习惯会把静态资源放在&lt;code&gt;classpath:/static/&lt;/code&gt;目录下。我们创建目录，并且添加一些静态资源：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200812143105995-1983850434.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;重启项目后测试：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200812143120215-804809121.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;433添加拦截器&quot;&gt;4.3.3.添加拦截器&lt;/h3&gt;
&lt;p&gt;拦截器也是我们经常需要使用的，在SpringBoot中该如何配置呢？&lt;/p&gt;
&lt;p&gt;拦截器不是一个普通属性，而是一个类，所以就要用到java配置方式了。在SpringBoot官方文档中有这么一段说明：&lt;/p&gt;
&lt;blockquote readability=&quot;18.456228956229&quot;&gt;
&lt;p&gt;If you want to keep Spring Boot MVC features and you want to add additional &lt;a href=&quot;https://docs.spring.io/spring/docs/5.0.5.RELEASE/spring-framework-reference/web.html#mvc&quot;&gt;MVC configuration&lt;/a&gt; (interceptors, formatters, view controllers, and other features), you can add your own &lt;code&gt;@Configuration&lt;/code&gt; class of type &lt;code&gt;WebMvcConfigurer&lt;/code&gt; but &lt;strong&gt;without&lt;/strong&gt; &lt;code&gt;@EnableWebMvc&lt;/code&gt;. If you wish to provide custom instances of &lt;code&gt;RequestMappingHandlerMapping&lt;/code&gt;, &lt;code&gt;RequestMappingHandlerAdapter&lt;/code&gt;, or &lt;code&gt;ExceptionHandlerExceptionResolver&lt;/code&gt;, you can declare a &lt;code&gt;WebMvcRegistrationsAdapter&lt;/code&gt; instance to provide such components.&lt;/p&gt;
&lt;p&gt;If you want to take complete control of Spring MVC, you can add your own &lt;code&gt;@Configuration&lt;/code&gt; annotated with &lt;code&gt;@EnableWebMvc&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;翻译：&lt;/p&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;如果你想要保持Spring Boot 的一些默认MVC特征，同时又想自定义一些MVC配置（包括：拦截器，格式化器, 视图控制器、消息转换器 等等），你应该让一个类实现&lt;code&gt;WebMvcConfigurer&lt;/code&gt;，并且添加&lt;code&gt;@Configuration&lt;/code&gt;注解，但是&lt;strong&gt;千万不要&lt;/strong&gt;加&lt;code&gt;@EnableWebMvc&lt;/code&gt;注解。如果你想要自定义&lt;code&gt;HandlerMapping&lt;/code&gt;、&lt;code&gt;HandlerAdapter&lt;/code&gt;、&lt;code&gt;ExceptionResolver&lt;/code&gt;等组件，你可以创建一个&lt;code&gt;WebMvcRegistrationsAdapter&lt;/code&gt;实例 来提供以上组件。&lt;/p&gt;
&lt;p&gt;如果你想要完全自定义SpringMVC，不保留SpringBoot提供的一切特征，你可以自己定义类并且添加&lt;code&gt;@Configuration&lt;/code&gt;注解和&lt;code&gt;@EnableWebMvc&lt;/code&gt;注解&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;总结：通过实现&lt;code&gt;WebMvcConfigurer&lt;/code&gt;并添加&lt;code&gt;@Configuration&lt;/code&gt;注解来实现自定义部分SpringMvc配置。&lt;/p&gt;
&lt;p&gt;实现如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200812143314738-910281040.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先我们定义一个拦截器：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Component
public class MyInterceptor implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        System.out.println(&quot;preHandle method is running!&quot;);
        return true;
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        System.out.println(&quot;postHandle method is running!&quot;);
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        System.out.println(&quot;afterCompletion method is running!&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后定义配置类，注册拦截器：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Configuration
public class MvcConfiguration implements WebMvcConfigurer {

    @Autowired
    private HandlerInterceptor myInterceptor;

    /**
     * 重写接口中的addInterceptors方法，添加自定义拦截器
     * @param registry
     */
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(myInterceptor).addPathPatterns(&quot;/**&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来运行并查看日志：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-verilog&quot;&gt;preHandle method is running!
postHandle method is running!
afterCompletion method is running!
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你会发现日志中只有这些打印信息，springMVC的日志信息都没有，因为springMVC记录的log级别是debug，springboot默认是显示info以上，我们需要进行配置。&lt;/p&gt;
&lt;p&gt;SpringBoot通过&lt;code&gt;logging.level.*=debug&lt;/code&gt;来配置日志级别，*填写包名&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-properties&quot;&gt;# 设置org.springframework包的日志级别为debug
logging.level.org.springframework=debug
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再次运行查看：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200812143343872-1376324663.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;44整合连接池&quot;&gt;4.4.整合连接池&lt;/h2&gt;
&lt;p&gt;jdbc连接池是spring配置中的重要一环，在SpringBoot中该如何处理呢？&lt;/p&gt;
&lt;p&gt;答案是不需要处理，我们只要找到SpringBoot提供的启动器即可：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200812143420895-738610627.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在pom.xml中引入jdbc的启动器：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;!--jdbc的启动器，默认使用HikariCP连接池--&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-jdbc&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;!--不要忘记数据库驱动，因为springboot不知道我们使用的什么数据库，这里选择mysql--&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;SpringBoot已经自动帮我们引入了一个连接池：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200812143534728-805334412.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;HikariCP应该是目前速度最快的连接池了，我们看看它与c3p0的对比：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200812143543249-1047180469.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因此，我们只需要指定连接池参数即可：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-properties&quot;&gt;# 连接四大参数
spring.datasource.url=jdbc:mysql://localhost:3306/heima
spring.datasource.username=root
spring.datasource.password=root
# 可省略，SpringBoot自动推断
spring.datasource.driverClassName=com.mysql.jdbc.Driver

spring.datasource.hikari.idle-timeout=60000
spring.datasource.hikari.maximum-pool-size=30
spring.datasource.hikari.minimum-idle=10
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然，如果你更喜欢Druid连接池，也可以使用Druid官方提供的启动器：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;!-- Druid连接池 --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;druid-spring-boot-starter&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.1.6&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而连接信息的配置与上面是类似的，只不过在连接池特有属性上，方式略有不同：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-properties&quot;&gt;#初始化连接数
spring.datasource.druid.initial-size=1
#最小空闲连接
spring.datasource.druid.min-idle=1
#最大活动连接
spring.datasource.druid.max-active=20
#获取连接时测试是否可用
spring.datasource.druid.test-on-borrow=true
#监控页面启动
spring.datasource.druid.stat-view-servlet.allow=true
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;45整合mybatis&quot;&gt;4.5.整合mybatis&lt;/h2&gt;
&lt;h3 id=&quot;451mybatis&quot;&gt;4.5.1.mybatis&lt;/h3&gt;
&lt;p&gt;SpringBoot官方并没有提供Mybatis的启动器，不过Mybatis&lt;a href=&quot;https://github.com/mybatis/spring-boot-starter&quot;&gt;官方&lt;/a&gt;自己实现了：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;!--mybatis --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.mybatis.spring.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;mybatis-spring-boot-starter&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.3.2&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置，基本没有需要配置的：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-properties&quot;&gt;# mybatis 别名扫描
mybatis.type-aliases-package=cn.itcast.pojo
# mapper.xml文件位置,如果没有映射文件，请注释掉
mybatis.mapper-locations=classpath:mappers/*.xml
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要注意，这里没有配置mapper接口扫描包，因此我们需要给每一个Mapper接口添加&lt;code&gt;@Mapper&lt;/code&gt;注解，才能被识别。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200812143603850-933383715.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Mapper
public interface UserMapper {
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;user对象：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Table(name = &quot;tb_user&quot;)
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String userName;

    private String password;

    private String name;

    private Integer age;

    private Integer sex;

    private Date birthday;

    private Date created;

    private Date updated;
      
    //getter and setter 省略...
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来，就去集成通用mapper。&lt;/p&gt;
&lt;h3 id=&quot;452通用mapper&quot;&gt;4.5.2.通用mapper&lt;/h3&gt;
&lt;p&gt;通用Mapper的作者也为自己的插件编写了启动器，我们直接引入即可：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;!-- 通用mapper --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;tk.mybatis&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;mapper-spring-boot-starter&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.0.2&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不需要做任何配置就可以使用了。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Mapper
public interface UserMapper extends tk.mybatis.mapper.common.Mapper&amp;lt;User&amp;gt;{
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;46整合事务&quot;&gt;4.6.整合事务&lt;/h2&gt;
&lt;p&gt;其实，我们引入jdbc或者web的启动器，就已经引入事务相关的依赖及默认配置了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200812144336841-1981748200.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至于事务，SpringBoot中通过注解来控制。就是我们熟知的&lt;code&gt;@Transactional&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Service
public class UserService {

    @Autowired
    private UserMapper userMapper;

    public User queryById(Long id){
        return this.userMapper.selectByPrimaryKey(id);
    }

    @Transactional
    public void deleteById(Long id){
        this.userMapper.deleteByPrimaryKey(id);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;47启动测试&quot;&gt;4.7.启动测试&lt;/h2&gt;
&lt;p&gt;在UserController中添加测试方法，内容：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@RestController
@RequestMapping(&quot;user&quot;)
public class UserController {

    @Autowired
    private UserService userService;

    @GetMapping(&quot;{id}&quot;)
    public User queryUserById(@PathVariable(&quot;id&quot;)Long id){
        return this.userService.queryById(id);
    }

    @GetMapping(&quot;hello&quot;)
    public String test(){
        return &quot;hello ssm&quot;;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们启动项目，查看：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200812221301525-1281882052.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;48完整项目结构&quot;&gt;4.8.完整项目结构&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200812221333971-1542189744.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;完整的pom.xml：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;

    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

    &amp;lt;groupId&amp;gt;cn.itcast.user&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;itcast-user&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;

    &amp;lt;parent&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;2.0.6.RELEASE&amp;lt;/version&amp;gt;
    &amp;lt;/parent&amp;gt;

    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!--jdbc的启动器，默认使用HikariCP连接池--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-jdbc&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!--不要忘记数据库驱动，因为springboot不知道我们使用的什么数据库，这里选择mysql--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;!--mybatis --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.mybatis.spring.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;mybatis-spring-boot-starter&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.3.2&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;!-- 通用mapper --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;tk.mybatis&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;mapper-spring-boot-starter&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;2.0.2&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;

&amp;lt;/project&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;完整的application.properties：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-properties&quot;&gt;server.port=80

logging.level.org.springframework=debug

spring.datasource.url=jdbc:mysql://localhost:3306/heima
spring.datasource.username=root
spring.datasource.password=root

# mybatis 别名扫描
mybatis.type-aliases-package=cn.itcast.pojo
# mapper.xml文件位置,如果没有映射文件，请注释掉
# mybatis.mapper-locations=classpath:mappers/*.xml
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;SpringBoot并不推荐使用jsp，但是支持一些模板引擎技术：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200812221358009-874521076.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以前大家用的比较多的是Freemarker，但是我们今天的主角是Thymeleaf！&lt;/p&gt;
&lt;h2 id=&quot;51为什么是thymeleaf？&quot;&gt;5.1.为什么是Thymeleaf？&lt;/h2&gt;
&lt;p&gt;简单说， Thymeleaf 是一个跟 Velocity、FreeMarker 类似的模板引擎，它可以完全替代 JSP 。相较于其他的模板引擎，它有如下四个极吸引人的特点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;动静结合：Thymeleaf 在有网络和无网络的环境下皆可运行，即它可以让美工在浏览器查看页面的静态效果，也可以让程序员在服务器查看带数据的动态页面效果。这是由于它支持 html 原型，然后在 html 标签里增加额外的属性来达到模板+数据的展示方式。浏览器解释 html 时会忽略未定义的标签属性，所以 thymeleaf 的模板可以静态地运行；当有数据返回到页面时，Thymeleaf 标签会动态地替换掉静态内容，使页面动态显示。&lt;/li&gt;
&lt;li&gt;开箱即用：它提供标准和spring标准两种方言，可以直接套用模板实现JSTL、 OGNL表达式效果，避免每天套模板、改jstl、改标签的困扰。同时开发人员也可以扩展和创建自定义的方言。&lt;/li&gt;
&lt;li&gt;多方言支持：Thymeleaf 提供spring标准方言和一个与 SpringMVC 完美集成的可选模块，可以快速的实现表单绑定、属性编辑器、国际化等功能。&lt;/li&gt;
&lt;li&gt;与SpringBoot完美整合，SpringBoot提供了Thymeleaf的默认配置，并且为Thymeleaf设置了视图解析器，我们可以像以前操作jsp一样来操作Thymeleaf。代码几乎没有任何区别，就是在模板语法上有区别。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;接下来，我们就通过入门案例来体会Thymeleaf的魅力：&lt;/p&gt;
&lt;h2 id=&quot;52提供数据&quot;&gt;5.2.提供数据&lt;/h2&gt;
&lt;p&gt;编写一个controller方法，返回一些用户数据，放入模型中，将来在页面渲染&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@GetMapping(&quot;/all&quot;)
public String all(ModelMap model) {
    // 查询用户
    List&amp;lt;User&amp;gt; users = this.userService.queryAll();
    // 放入模型
    model.addAttribute(&quot;users&quot;, users);
    // 返回模板名称（就是classpath:/templates/目录下的html文件名）
    return &quot;users&quot;;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;53引入启动器&quot;&gt;5.3.引入启动器&lt;/h2&gt;
&lt;p&gt;直接引入启动器：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-thymeleaf&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;SpringBoot会自动为Thymeleaf注册一个视图解析器：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200812221458382-514730201.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;与解析JSP的InternalViewResolver类似，Thymeleaf也会根据前缀和后缀来确定模板文件的位置：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200812223509451-469873477.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;默认前缀：&lt;code&gt;classpath:/templates/&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;默认后缀：&lt;code&gt;.html&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以如果我们返回视图：&lt;code&gt;users&lt;/code&gt;，会指向到 &lt;code&gt;classpath:/templates/users.html&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;一般我们无需进行修改，默认即可。&lt;/p&gt;
&lt;h2 id=&quot;54静态页面&quot;&gt;5.4.静态页面&lt;/h2&gt;
&lt;p&gt;根据上面的文档介绍，模板默认放在classpath下的templates文件夹，我们新建一个html文件放入其中：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200812223603985-1696132732.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;编写html模板，渲染模型中的数据：&lt;/p&gt;
&lt;p&gt;注意，把html 的名称空间，改成：&lt;code&gt;xmlns:th=&quot;http://www.thymeleaf.org&quot;&lt;/code&gt; 会有语法提示&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;首页&amp;lt;/title&amp;gt;
    &amp;lt;style type=&quot;text/css&quot;&amp;gt;
        table {border-collapse: collapse; font-size: 14px; width: 80%; margin: auto}
        table, th, td {border: 1px solid darkslategray;padding: 10px}
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;div style=&quot;text-align: center&quot;&amp;gt;
    &amp;lt;span style=&quot;color: darkslategray; font-size: 30px&quot;&amp;gt;欢迎光临！&amp;lt;/span&amp;gt;
    &amp;lt;hr/&amp;gt;
    &amp;lt;table class=&quot;list&quot;&amp;gt;
        &amp;lt;tr&amp;gt;
            &amp;lt;th&amp;gt;id&amp;lt;/th&amp;gt;
            &amp;lt;th&amp;gt;姓名&amp;lt;/th&amp;gt;
            &amp;lt;th&amp;gt;用户名&amp;lt;/th&amp;gt;
            &amp;lt;th&amp;gt;年龄&amp;lt;/th&amp;gt;
            &amp;lt;th&amp;gt;性别&amp;lt;/th&amp;gt;
            &amp;lt;th&amp;gt;生日&amp;lt;/th&amp;gt;
        &amp;lt;/tr&amp;gt;
        &amp;lt;tr th:each=&quot;user : ${users}&quot;&amp;gt;
            &amp;lt;td th:text=&quot;${user.id}&quot;&amp;gt;1&amp;lt;/td&amp;gt;
            &amp;lt;td th:text=&quot;${user.name}&quot;&amp;gt;张三&amp;lt;/td&amp;gt;
            &amp;lt;td th:text=&quot;${user.userName}&quot;&amp;gt;zhangsan&amp;lt;/td&amp;gt;
            &amp;lt;td th:text=&quot;${user.age}&quot;&amp;gt;20&amp;lt;/td&amp;gt;
            &amp;lt;td th:text=&quot;${user.sex}&quot;&amp;gt;男&amp;lt;/td&amp;gt;
            &amp;lt;td th:text=&quot;${user.birthday}&quot;&amp;gt;1980-02-30&amp;lt;/td&amp;gt;
        &amp;lt;/tr&amp;gt;
    &amp;lt;/table&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们看到这里使用了以下语法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;${}&lt;/code&gt; ：这个类似与el表达式，但其实是ognl的语法，比el表达式更加强大&lt;/li&gt;
&lt;li&gt;&lt;code&gt;th-&lt;/code&gt;指令：&lt;code&gt;th-&lt;/code&gt;是利用了Html5中的自定义属性来实现的。如果不支持H5，可以用&lt;code&gt;data-th-&lt;/code&gt;来代替
&lt;ul&gt;&lt;li&gt;&lt;code&gt;th:each&lt;/code&gt;：类似于&lt;code&gt;c:foreach&lt;/code&gt; 遍历集合，但是语法更加简洁&lt;/li&gt;
&lt;li&gt;&lt;code&gt;th:text&lt;/code&gt;：声明标签中的文本
&lt;ul&gt;&lt;li&gt;例如&lt;code&gt;&amp;lt;td th-text='${user.id}'&amp;gt;1&amp;lt;/td&amp;gt;&lt;/code&gt;，如果user.id有值，会覆盖默认的1&lt;/li&gt;
&lt;li&gt;如果没有值，则会显示td中默认的1。这正是thymeleaf能够动静结合的原因，模板解析失败不影响页面的显示效果，因为会显示默认值！&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;55测试&quot;&gt;5.5.测试&lt;/h2&gt;
&lt;p&gt;接下来，我们打开页面测试一下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200812223722945-797116159.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;56模板缓存&quot;&gt;5.6.模板缓存&lt;/h2&gt;
&lt;p&gt;Thymeleaf会在第一次对模板解析之后进行缓存，极大的提高了并发处理能力。但是这给我们开发带来了不便，修改页面后并不会立刻看到效果，我们开发阶段可以关掉缓存使用：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-properties&quot;&gt;# 开发阶段关闭thymeleaf的模板缓存
spring.thymeleaf.cache=false
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;在Idea中，我们需要在修改页面后按快捷键：`Ctrl + Shift + F9` 对项目进行rebuild才可以。

eclipse中没有测试过。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以修改页面，测试一下。&lt;/p&gt;
</description>
<pubDate>Wed, 12 Aug 2020 15:27:00 +0000</pubDate>
<dc:creator>平酱</dc:creator>
<og:description>0.学习目标 了解SpringBoot的作用 掌握java配置的方式 了解SpringBoot自动配置原理 掌握SpringBoot的基本使用 了解Thymeleaf的基本使用 1. 了解Spring</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/p1ng/p/13493746.html</dc:identifier>
</item>
<item>
<title>一致性Hash - jihite</title>
<link>http://www.cnblogs.com/kaituorensheng/p/13461983.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kaituorensheng/p/13461983.html</guid>
<description>&lt;h3&gt;缘起&lt;/h3&gt;
&lt;p&gt;我有一个图片存取服务，为了快速获取图片，我架起了3台缓存服务器，用简单的Hash映射决定图片存储在哪台缓存上。比如:&lt;/p&gt;
&lt;p&gt;f(x) % 3 = 0 存储在s0上&lt;/p&gt;
&lt;p&gt;f(x) % 3 = 1 存储在s1上&lt;/p&gt;
&lt;p&gt;f(x) % 3 = 2存储在s2上&lt;/p&gt;
&lt;p&gt;某天，缓存负载过高，需要扩容1台，缓存数量由3变为4，那么按获取图片按公式：f(x) % n,很多会请求失败，这样会直接访问后台服务，给后台服务造成很大的压力，可能造成雪崩。&lt;/p&gt;
&lt;p&gt;是否有这样的算法，解决分布式缓存中，解决简单Hash随缓存服务器伸缩，造成大面积缓存失效的问题&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/408927/202008/408927-20200809221417780-2083179089.png&quot; alt=&quot;&quot; width=&quot;588&quot; height=&quot;355&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;缓存穿透&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/408927/202008/408927-20200810215156233-1027690255.png&quot; alt=&quot;&quot; width=&quot;574&quot; height=&quot;369&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;h3&gt;介绍 &lt;/h3&gt;
&lt;p&gt;一致性哈希算法在1997年由麻省理工学院提出，是一种特殊的哈希算法，目的是解决&lt;strong&gt;分布式缓存&lt;/strong&gt;的问题，解决了简单哈希算法在分布式哈希表中存在的&lt;strong&gt;动态伸缩&lt;/strong&gt;等问题&lt;/p&gt;
&lt;h3&gt;原理&lt;/h3&gt;
&lt;p&gt;引入Hash环&lt;/p&gt;
&lt;p&gt;假如有3个节点，三个节点位于环的不同位置&lt;/p&gt;
&lt;p&gt;具体的值，根据Hash值取余环的大小，顺时针方向找到最近的节点就是具体的存储节点&lt;/p&gt;
&lt;p&gt;比如：f(x1)存储在Node1, f(x2)存储在node2， f(x3)存储在Node0&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/408927/202008/408927-20200810214128879-659072478.png&quot; alt=&quot;&quot; width=&quot;590&quot; height=&quot;540&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;此时，如果加入了节点Node4，那么原来指向Node2的红色箭头部分，缓存会失效，变成存储在Node4&lt;/p&gt;
&lt;p&gt;如：f(x2)存储在Node4&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/408927/202008/408927-20200810214608497-445494088.png&quot; alt=&quot;&quot; width=&quot;570&quot; height=&quot;491&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;可以看到的效果是：当缓存服务器数量发生伸缩时，只有部分缓存失效&lt;/p&gt;
&lt;h3&gt;实现&lt;/h3&gt;
&lt;p&gt;圆环大小：2&lt;sup&gt;32&lt;/sup&gt;，由来：整数4B=4*8bit(32位无符号整形)，值从0~2&lt;sup&gt;32&lt;/sup&gt; -1&lt;/p&gt;
&lt;p&gt;每个节点位置：hash(ip) % 2&lt;sup&gt;32&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;存储的key位置：hash(key) % 2&lt;sup&gt;32&lt;/sup&gt;&lt;/p&gt;
&lt;h3&gt;使用场景&lt;/h3&gt;
&lt;p&gt;在分布式系统中一致性hash起着不可忽略的地位，无论是&lt;strong&gt;分布式缓存&lt;/strong&gt;，还是分布式Rpc框架的&lt;strong&gt;负载均衡策略&lt;/strong&gt;都有所使用。&lt;/p&gt;
&lt;h3&gt;优缺点&lt;/h3&gt;
&lt;p&gt;优点:在分布式缓存中&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;冗余少&lt;/li&gt;
&lt;li&gt;负载均衡&lt;/li&gt;
&lt;li&gt;过渡平滑&lt;/li&gt;
&lt;li&gt;存储均衡&lt;/li&gt;
&lt;li&gt;关键词单调&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;缺点：可能存在Hash偏斜，如&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/408927/202008/408927-20200810223806518-195544565.png&quot; alt=&quot;&quot; width=&quot;493&quot; height=&quot;451&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;解决策略&lt;/p&gt;
&lt;h3&gt;虚拟节点&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/408927/202008/408927-20200810224214861-987904020.png&quot; alt=&quot;&quot; width=&quot;524&quot; height=&quot;483&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 12 Aug 2020 15:16:00 +0000</pubDate>
<dc:creator>jihite</dc:creator>
<og:description>缘起 我有一个图片存取服务，为了快速获取图片，我架起了3台缓存服务器，用简单的Hash映射决定图片存储在哪台缓存上。比如: f(x) % 3 = 0 存储在s0上 f(x) % 3 = 1 存储在s1</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kaituorensheng/p/13461983.html</dc:identifier>
</item>
<item>
<title>最新情报：所有的递归都可以改写成非递归？ - 彤哥读源码</title>
<link>http://www.cnblogs.com/tong-yuan/p/13493678.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tong-yuan/p/13493678.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1648938/202008/1648938-20200812230900725-1001373334.jpg&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;4.0625&quot;&gt;
&lt;p&gt;本文收录于专辑：&lt;a href=&quot;http://dwz.win/HjK&quot;&gt;http://dwz.win/HjK&lt;/a&gt;，点击解锁更多数据结构与算法的知识。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;你好，我是彤哥，一个每天爬二十六层楼还不忘读源码的硬核男人。&lt;/p&gt;
&lt;p&gt;上一节，我们使用位图介绍了12306抢票算法的实现，没有收到推送的同学可以点击上方专辑查看，或者在公主号历史消息中查看。&lt;/p&gt;
&lt;p&gt;在上一节的最后，彤哥收到最新情报，说是所有的递归都可以改写成非递归，是不是真的呢？如何实现呢？有没有套路呢？&lt;/p&gt;
&lt;p&gt;让我们带着这些问题进入今天的学习吧。&lt;/p&gt;

&lt;p&gt;所谓递归，是指程序在运行的过程中调用自身的行为。&lt;/p&gt;
&lt;p&gt;这种行为也不能无限制地进行下去，得有个出口，叫做&lt;code&gt;边界条件&lt;/code&gt;，所以，递归可以分成三个段：前进段、达到边界条件，返回段，在这三个段我们都可以做一些事，比如前进段对问题规模进行缩小，返回段对结果进行整理。&lt;/p&gt;
&lt;p&gt;这么说可能比较抽象，让我们看一个简单的案例：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何用递归实现1到100的相加？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1到100相加使用循环大家都会解，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Sum {
    public static void main(String[] args) {
        System.out.println(sumCircle(1, 100));
    }

    private static int sumCircle(int min, int max) {
        int sum = 0;
        for (int i = min; i &amp;lt;= max; i++) {
            sum += i;
        }
        return sum;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么，如何使用递归实现呢？&lt;/p&gt;

&lt;p&gt;首先，我们要找到这道题的边界条件，1到100相加，边界条件可以是1，也可以是100，如果从1开始，那么边界条件就是100，反之亦然。&lt;/p&gt;
&lt;p&gt;找到了边界条件之后，就是将问题规模缩小，对于这道题，计算1到100相加，那么，能不能先计算1到99相加再把100加上呢？肯定是可以的，这样问题的规模就缩小了，直到，问题规模缩小为1到1相加为止。&lt;/p&gt;
&lt;p&gt;OK，让我们看代码实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private static int sumRecursive(int min, int max) {
    // 边界条件
    if (min &amp;gt;= max) {
        return min;
    }
    // 问题规模缩小
    int sum = sumRecursive(min, max - 1);
    // 加上当前值
    sum += max;
    // 返回
    return sum;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;是不是很简单？还可以更简单：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private static int sumRecursive2(int min, int max) {
    return min &amp;gt;= max ? min : sumRecursive2(min, max - 1) + max;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;686?&lt;/p&gt;
&lt;p&gt;所以，使用递归最重要的就是找到边界条件，然后让问题的规模朝着边界条件的方向一直缩小，直到达到边界条件，最后依次返回即可，这也是快速实现递归的套路。&lt;/p&gt;
&lt;p&gt;这么看来，使用递归似乎很简单，但是，它有没有什么缺点呢？&lt;/p&gt;
&lt;p&gt;要了解缺点就得从递归的本质入手。&lt;/p&gt;

&lt;p&gt;我们知道，JVM启动的时候有个参数叫做&lt;code&gt;-Xss&lt;/code&gt;，它不是表示XSS攻击哈，它是指每个线程可以使用的线程栈的大小。&lt;/p&gt;
&lt;p&gt;那么，什么又是线程栈呢？&lt;/p&gt;
&lt;p&gt;栈大家都理解了，我们在前面的章节也学习过了，使用栈，可以实现计算器的功能，非常方便。&lt;/p&gt;
&lt;p&gt;线程栈，顾名思义，就是指线程运行过程中使用的栈。&lt;/p&gt;
&lt;p&gt;那么，线程在运行的过程中为什么要使用栈呢？&lt;/p&gt;
&lt;p&gt;这就不得不说方法调用的本质了。&lt;/p&gt;
&lt;p&gt;举个简单的例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private static int a(int num) {
    int a = 1;
    return a + b(num);
}

private static int b(int num) {
    int b = 2;
    return c(num) + b;
}

private static int c(int num) {
    int c = 3;
    return c + num;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这段代码中，方法a() 调用 方法b()，方法b() 调用 方法c()，在实际运行的过程中，是这样处理的：调用方法a()时，发现需要调用方法b()才能返回，那就把方法a()及其状态保存到栈中，然后调用方法b()，同样地，调用方法b()时，发现需要先调用方法c()才能返回，那就把方法b()及其状态入栈，然后调用方法c()，调用方法c()时，不需要额外调用别的方法了，计算完毕返回，返回之后，从栈顶取出方法b()及当时的状态，继续运行方法b()，方法b()运行完毕，返回，再从栈中取出方法a()及当时的状态，计算完毕，方法a()返回，程序等待结束。&lt;/p&gt;
&lt;p&gt;还是上图吧：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1648938/202008/1648938-20200812230901044-178555665.jpg&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以，方法调用的本质，就是栈的使用。&lt;/p&gt;
&lt;p&gt;同理，递归的调用就是方法的调用，所以，递归的调用，也是栈的使用，不过，这个栈会变得非常大，比如，对于1到100相加，就有99次入栈出栈的操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1648938/202008/1648938-20200812230901309-684295708.jpg&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因此，总结起来，递归有以下两个缺点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;操作耗时，因为牵涉到大量的入栈出栈操作；&lt;/li&gt;
&lt;li&gt;有可能导致线程栈溢出，因为递归调用占用了线程栈很大的空间。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;那么，我们是不是就不要使用递归了呢？&lt;/p&gt;
&lt;p&gt;当然不是，之所以使用递归，就是因为它使用起来非常简单，能够快速地解决我们的问题，合理控制递归调用链的长度，就是一个好递归。&lt;/p&gt;
&lt;p&gt;既然，递归调用的本质，就是栈的使用，那么，我们能不能自己模拟一个栈，将递归调用改成非递归呢？&lt;/p&gt;
&lt;p&gt;当然可以。&lt;/p&gt;

&lt;p&gt;还是使用上面的例子，现在我们需要把递归修改成非递归，且不是使用for循环的那种形式，要怎么实现呢？&lt;/p&gt;
&lt;p&gt;首先，我们要自己模拟一个栈；&lt;/p&gt;
&lt;p&gt;然后，找到边界条件；&lt;/p&gt;
&lt;p&gt;最后，朝着边界条件的方向缩小问题规模；&lt;/p&gt;
&lt;p&gt;OK，上代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private static int sumNonRecursive(int min, int max) {
        int sum = 0;
        // 声明一个栈
        Stack&amp;lt;Integer&amp;gt; stack = new Stack&amp;lt;Integer&amp;gt;();
        stack.push(max);
        while (!stack.isEmpty()) {
            if (max &amp;gt; min) {
                // 要计算max，先计算max-1
                stack.push(--max);
            } else {
                // 问题规模缩小到一定程度，计算返回
                sum += stack.pop();
            }
        }
        return sum;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;好了，是不是很简单，其实跟递归的套路是一样的，只不过改成自己模拟栈来实现。&lt;/p&gt;
&lt;p&gt;这个例子可能不是那么明显，我们再举个二叉树遍历的例子来看一下。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class BinaryTree {

    Node root;

    // 插入元素
    void put(int value) {
        if (root == null) {
            root = new Node(value);
        } else {
            Node parent = root;
            while (true) {
                if (value &amp;lt;= parent.value) {
                    if (parent.left == null) {
                        parent.left = new Node(value);
                        return;
                    } else {
                        parent = parent.left;
                    }
                } else {
                    if (parent.right == null) {
                        parent.right = new Node(value);
                        return;
                    } else {
                        parent = parent.right;
                    }
                }

            }
        }
    }

    // 先序遍历
    void preTraversal(Node x) {
        if (x == null) return;
        System.out.print(x.value + &quot;,&quot;);
        preTraversal(x.left);
        preTraversal(x.right);
    }

    static class Node {
        int value;
        Node left;
        Node right;

        public Node(int value) {
            this.value = value;
        }
    }

    public static void main(String[] args) {
        BinaryTree binaryTree = new BinaryTree();
        binaryTree.put(3);
        binaryTree.put(1);
        binaryTree.put(2);
        binaryTree.put(7);
        binaryTree.put(8);
        binaryTree.put(5);
        binaryTree.put(4);
        binaryTree.put(6);
        binaryTree.put(9);
        binaryTree.put(0);

        binaryTree.preTraversal(binaryTree.root);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我这里随手写了一颗二叉树，并实现了其先序遍历，这个测试用例中的二叉树长这个样子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1648938/202008/1648938-20200812230901558-1742153072.jpg&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以，这个二叉树的先序遍历结果为&lt;code&gt;3,1,0,2,7,5,4,6,8,9,&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;可以看到，使用递归先序遍历二叉树非常简单，而且代码清晰易懂，那么，它如何修改为非递归实现呢？&lt;/p&gt;
&lt;p&gt;首先，我们要自己模拟一个栈；&lt;/p&gt;
&lt;p&gt;然后，找到边界条件，为节点等于空时；&lt;/p&gt;
&lt;p&gt;最后，缩小问题规模，这里是先把右子树压栈，再把左子树压栈，因为先左后右；&lt;/p&gt;
&lt;p&gt;好了，来看代码实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 先序遍历非递归形式
void nonRecursivePreTraversal(Node x) {
    // 自己模拟一个栈
    Stack&amp;lt;Node&amp;gt; stack = new Stack&amp;lt;Node&amp;gt;();
    stack.push(x);
    while (!stack.isEmpty()) {
        Node tmp = stack.pop();
        // 隐含的边界条件
        if (tmp != null) {
            System.out.print(tmp.value + &quot;,&quot;);
            // 缩小问题规模
            stack.push(tmp.right);
            stack.push(tmp.left);
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;掌握了这个套路是不是把递归改写为非递归非常简单，不过，改写之后的代码显然没有递归那么清晰。&lt;/p&gt;
&lt;p&gt;好了，递归改写为非递归的套路我们就讲到这里，不知道你Get到了没有呢？你也可以找个递归自己来改写试试看。&lt;/p&gt;

&lt;p&gt;本节，我们从递归的概念入手，学习了如何快速实现递归，以及递归的本质，最后，学习了递归改写为非递归的套路。&lt;/p&gt;
&lt;p&gt;本质上，这也是栈这种数据结构的常规用法。&lt;/p&gt;
&lt;p&gt;既然讲到了栈，不讲队列是不是有点过分？&lt;/p&gt;
&lt;p&gt;所以，下一节，遍历各种源码的彤哥将介绍如何实现高性能的队列，想了解其中的套路吗？还不快点来关注我！&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;关注公号主“彤哥读源码”，解锁更多源码、基础、架构知识。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 12 Aug 2020 15:09:00 +0000</pubDate>
<dc:creator>彤哥读源码</dc:creator>
<og:description>前言 本文收录于专辑：http://dwz.win/HjK，点击解锁更多数据结构与算法的知识。 你好，我是彤哥，一个每天爬二十六层楼还不忘读源码的硬核男人。 上一节，我们使用位图介绍了12306抢票算</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tong-yuan/p/13493678.html</dc:identifier>
</item>
</channel>
</rss>