<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>实验隐藏参数&quot;_allow_resetlogs_corruption&quot;的使用 - AlfredZhao</title>
<link>http://www.cnblogs.com/jyzhao/p/10177212.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jyzhao/p/10177212.html</guid>
<description>&lt;p&gt;&lt;strong&gt;实验环境：&lt;/strong&gt;OEL 5.7 + Oracle 10.2.0.5&lt;br/&gt;&lt;strong&gt;Tips：&lt;/strong&gt;该参数仅在特殊恢复场景下使用，需要在专业Oracle工程师指导下进行操作。&lt;/p&gt;

&lt;p&gt;查询隐藏参数&quot;_allow_resetlogs_corruption&quot;及说明：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;set linesize 333
col name for a35
col description for a66
col value for a30
SELECT i.ksppinm name,  
   i.ksppdesc description,  
   CV.ksppstvl VALUE
FROM   sys.x$ksppi i, sys.x$ksppcv CV  
   WHERE   i.inst_id = USERENV ('Instance')  
   AND CV.inst_id = USERENV ('Instance')  
   AND i.indx = CV.indx  
   AND i.ksppinm LIKE '%&amp;amp;keyword%' 
ORDER BY 1; 

Enter value for keyword: allow_resetlog
old   8:    AND i.ksppinm LIKE '%&amp;amp;keyword%'
new   8:    AND i.ksppinm LIKE '%allow_resetlog%'

NAME                                DESCRIPTION                                                        VALUE
----------------------------------- ------------------------------------------------------------------ ------------------------------
_allow_resetlogs_corruption         allow resetlogs even if it will cause corruption                   FALSE&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过这个隐藏参数非常规恢复的库，原则建议还是要重建库的。其实在alert日志中也会看到有这样的建议：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Wed Dec 26 00:00:41 CST 2018
alter database open resetlogs
Wed Dec 26 00:00:41 CST 2018
RESETLOGS is being done without consistancy checks. This may result
in a corrupted database. The database should be recreated.&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;模拟常规开库失败的场景：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SQL&amp;gt; select checkpoint_change# from v$datafile_header;

CHECKPOINT_CHANGE#
------------------
       10013731555
       10014045643
       10014045643
       10014045643
       10014045643
       10014045643
       10014045643
       10014045643
       10014045643

9 rows selected.


SQL&amp;gt; alter database open;
alter database open
*
ERROR at line 1:
ORA-01589: must use RESETLOGS or NORESETLOGS option for database open


SQL&amp;gt; alter database open resetlogs;
alter database open resetlogs
*
ERROR at line 1:
ORA-01194: file 1 needs more recovery to be consistent
ORA-01110: data file 1: '+ZHAOJINGYU/jy/datafile/system.256.839673875'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;这个环境是模拟数据文件1丢失，最终从备份restore出来一个旧的文件，但由于种种原因，总之没有后续的归档去做recover，导致无法追平。&lt;br/&gt;此时就可尝试使用_allow_resetlogs_corruption隐藏参数强制开库：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SQL&amp;gt; alter system set &quot;_allow_resetlogs_corruption&quot; = true scope=spfile;
SQL&amp;gt; shutdown immediate
SQL&amp;gt; startup mount
SQL&amp;gt; alter database open resetlogs;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时再去查询数据文件头的SCN已经一致：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SQL&amp;gt; select checkpoint_change# from v$datafile_header;

  CHECKPOINT_CHANGE#
--------------------
         10014022016
         10014022016
         10014022016
         10014022016
         10014022016
         10014022016
         10014022016
         10014022016
         10014022016

9 rows selected.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意处理完毕后及时改回这个隐藏参数为false：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;alter system set &quot;_allow_resetlogs_corruption&quot; = false scope=spfile;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;其他注意事项：&lt;/strong&gt;如果开库遇到ORA-600 [2662]类错误，可以参考之前随笔：&lt;/p&gt;
&lt;p&gt;最终通过推进SCN的手段来解决ORA-600 [2662]类问题。&lt;br/&gt;其实这个场景其实可能会遇到各种问题，都属于非常规恢复范畴，后续我会计划去继续测试验证一些常见场景及解决方案。&lt;/p&gt;
</description>
<pubDate>Tue, 25 Dec 2018 18:04:00 +0000</pubDate>
<dc:creator>AlfredZhao</dc:creator>
<og:description>实验环境： OEL 5.7 + Oracle 10.2.0.5 Tips： 该参数仅在特殊恢复场景下使用，需要在专业Oracle工程师指导下进行操作。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jyzhao/p/10177212.html</dc:identifier>
</item>
<item>
<title>commanderJs编写命令行工具(cli) - 子慕大诗人</title>
<link>http://www.cnblogs.com/1wen/p/10142210.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/1wen/p/10142210.html</guid>
<description>&lt;h2&gt;前言：&lt;/h2&gt;
&lt;p&gt;　　最近需要做一个内部的node cli来独立构建流程，对整个命令行工具实现流程有了大致了解，下面来解释一下如何实现一个cli，和如何使用 &lt;strong&gt;commander &lt;/strong&gt;库。&lt;/p&gt;

&lt;h2&gt;新手误区：&lt;/h2&gt;
&lt;p&gt;　　在开始实现之前，我知道有 &lt;strong&gt;commander &lt;/strong&gt;这个node库，有很多cli使用了它，对它的大致了解就是它可以帮助开发者简化实现命令流程。  于是最初以为不利用库要去实现命令行会很麻烦，&lt;strong&gt;commander &lt;/strong&gt;帮我们解决了各种兼容问题等等。  后来发现并不是的，没有&lt;strong&gt;commander&lt;/strong&gt; 我们也可以不用化多大力气实现命令行，&lt;strong&gt;commander&lt;/strong&gt; 仅仅是一个本身也不太复杂的封装（源码也只有1200行）。  我们的第一步还是应该先搞清楚，通过&lt;strong&gt;npm&lt;/strong&gt;如何实现命令行。&lt;/p&gt;

&lt;h2&gt;一个简单的cli：&lt;/h2&gt;
&lt;h3&gt;bin：&lt;/h3&gt;
&lt;div readability=&quot;24&quot;&gt;
&lt;p&gt;　　&lt;strong&gt;package.json &lt;/strong&gt;中有一个 &lt;strong&gt;bin &lt;/strong&gt;字段，指定各个内部命令对应的可执行文件的位置。   在包安装时，如果是全局安装，&lt;strong&gt;npm &lt;/strong&gt;将会把 &lt;strong&gt;package.json&lt;/strong&gt; 里定义的 &lt;strong&gt;bin&lt;/strong&gt; 文件软连接到全局 &lt;strong&gt;node_modules/bin&lt;/strong&gt;，如果是非全局安装，会软链接到项目文件夹&lt;strong&gt;./node_modules/.bin/&lt;/strong&gt;。  根据下面代码的配置，当我们全局安装此包后，在任意位置运行 &lt;strong&gt;cli-test&lt;/strong&gt;，都会执行全局 &lt;strong&gt;node_modules &lt;/strong&gt;中的 &lt;strong&gt;cli-test&lt;/strong&gt; 文件。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;cli-test 的 package.json&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&quot;bin&quot;&lt;span&gt;: {
    &lt;/span&gt;&quot;cli-test&quot;: &quot;./bin/cli-test&quot;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果我们把cli安装在项目A &lt;strong&gt;node_modules&lt;/strong&gt;中，通过设置项目中 &lt;strong&gt;package.json&lt;/strong&gt; 的 &lt;strong&gt;scripts&lt;/strong&gt;，运行 &lt;strong&gt;npm run cli&lt;/strong&gt;，&lt;strong&gt;npm&lt;/strong&gt; 就会在项目的 &lt;strong&gt;node_modules/.bin&lt;/strong&gt; 寻找并运行 &lt;strong&gt;cli-test&lt;/strong&gt; 文件。 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*项目A &lt;/span&gt;&lt;span&gt;package.json&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&quot;scripts&quot;&lt;span&gt;: {
    &lt;/span&gt;&quot;cli&quot;: &quot;cli-test&quot;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;cli文件：&lt;/h3&gt;
&lt;p&gt;　　下面是 &lt;strong&gt;cli-test&lt;/strong&gt; 文件，第一行必写，是告诉Unix和Linux系统这个文件中的代码用node可执行程序去运行它。  后面就做我们要做的事情就行了 。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
#!/usr/bin/env node

&lt;span&gt;//&lt;/span&gt;&lt;span&gt;do something&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;好了，到这里我们的cli就完成了。  其实有很多三方cli也并没有用类似 &lt;strong&gt;commander&lt;/strong&gt; 的 &lt;strong&gt;node&lt;/strong&gt; 库，如果我们的 cli 足够简单，以上这样就可以了。  下面接着讲 &lt;strong&gt;commander&lt;/strong&gt;。&lt;/p&gt;
&lt;/div&gt;

&lt;h2&gt;commander：&lt;/h2&gt;
&lt;div readability=&quot;62.5&quot;&gt;
&lt;p&gt;现在我们先写一个简单的文件来理解（也推荐先自行预览一下 &lt;strong&gt;commander &lt;/strong&gt;官方文档），下面是 &lt;strong&gt;bin &lt;/strong&gt;文件夹的 &lt;strong&gt;cli-test，&lt;/strong&gt;代码如下：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
#!/usr/bin/env node
&lt;span&gt;
const program &lt;/span&gt;=require('commander'&lt;span&gt;);
program
.usage(&lt;/span&gt;'[option]', '--type required'&lt;span&gt;)
.option(&lt;/span&gt;'--type [typeName]', 'type: dev &amp;amp;&amp;amp; build'&lt;span&gt;)
.parse(process.argv);

const {type} &lt;/span&gt;=&lt;span&gt; program;
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(type == 'dev'&lt;span&gt;){
    console.log(&lt;/span&gt;'do something'&lt;span&gt;, type)
}&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(type == 'build'&lt;span&gt;){
    console.log(&lt;/span&gt;'do something'&lt;span&gt;, type)
}&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
    console.log(&lt;/span&gt;'params error'&lt;span&gt;);
    program.help();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;解释一下上面的代码，从查看源码里发现 &lt;strong&gt;require('commander')&lt;/strong&gt;  会 &lt;strong&gt;new&lt;/strong&gt;一个&lt;strong&gt;commander &lt;/strong&gt;内部的单例对象并返回，&lt;strong&gt;program &lt;/strong&gt;已经是一个实例，&lt;img src=&quot;https://img2018.cnblogs.com/blog/623144/201812/623144-20181225225839681-1501128054.png&quot; alt=&quot;&quot;/&gt;。  .&lt;strong&gt;usage &lt;/strong&gt; 仅仅描述了参数规则，会在 &lt;strong&gt;--help &lt;/strong&gt;中打印出来。.&lt;strong&gt;option &lt;/strong&gt;定义了一个参数名和描述，  &lt;strong&gt;parse &lt;/strong&gt;会解析命令之中的参数，根据上面定义好的规则执行相关命令。  比如上面的代码定义了 &lt;strong&gt;option &lt;/strong&gt;类型的参数 &lt;strong&gt;--type&lt;/strong&gt;，执行 &lt;strong&gt;.parse &lt;/strong&gt;的时候，&lt;strong&gt;parse &lt;/strong&gt;根据 &lt;strong&gt;process.argv&lt;/strong&gt; 之中的参数，获取到 &lt;strong&gt;--type&lt;/strong&gt;，并把参数命和参数值存储在内部 &lt;strong&gt;commander&lt;/strong&gt; 实例的属性之中，因此后面的代码就能从 &lt;strong&gt;program&lt;/strong&gt; 之中取到 &lt;strong&gt;type&lt;/strong&gt;，如果 &lt;strong&gt;type &lt;/strong&gt;不存在或者不是我们约定的值，最后我们打印参数错误，并执行&lt;strong&gt;help&lt;/strong&gt;方法打印了 &lt;strong&gt;--help&lt;/strong&gt;。  如下截图，我们 &lt;strong&gt;node &lt;/strong&gt;执行 &lt;strong&gt;cli-test&lt;/strong&gt;，因为没有约定参数，所以执行了 &lt;strong&gt;else &lt;/strong&gt;的程序。（因为这里是本地的demo程序，所以直接使用node命令）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/623144/201812/623144-20181225231058911-1407294323.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;接着，我们执行正确的命令参数，如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/623144/201812/623144-20181225231623579-1672672213.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这样一个简单的demo就实现了，看起来也挺简单的，&lt;strong&gt;commander &lt;/strong&gt;封装了一些也不算很复杂的功能。 &lt;/p&gt;

&lt;h3&gt;再来一个例子：&lt;/h3&gt;
&lt;p&gt;新建了两个文件，要以 &lt;strong&gt;bin &lt;/strong&gt;命令的执行文件命后面加上 &lt;strong&gt;-name&lt;/strong&gt;，作为子命令文件&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/623144/201812/623144-20181225232747062-1758451478.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;cli-test：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
#!/usr/bin/env node
&lt;span&gt;
const program &lt;/span&gt;=require('commander'&lt;span&gt;);

program&lt;/span&gt;&lt;span&gt;
.usage(&lt;/span&gt;'&amp;lt;command&amp;gt; [option]', 'option --type required'&lt;span&gt;)
.command(&lt;/span&gt;'h5', 'to h5'&lt;span&gt;)
.command(&lt;/span&gt;'rn', 'to rn'&lt;span&gt;)
.parse(process.argv);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;cli-test-h5：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
#!/usr/bin/env node
&lt;span&gt;
const program &lt;/span&gt;=require('commander'&lt;span&gt;);
program
.option(&lt;/span&gt;'--type [typeName]', 'type: dev &amp;amp;&amp;amp; build'&lt;span&gt;)
.parse(process.argv);

const {type} &lt;/span&gt;=&lt;span&gt; program;
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(type == 'dev'&lt;span&gt;){
    console.log(&lt;/span&gt;'do something h5'&lt;span&gt;, type)
}&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(type == 'build'&lt;span&gt;){
    console.log(&lt;/span&gt;'do something h5'&lt;span&gt;, type)
}&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
    console.log(&lt;/span&gt;'params error'&lt;span&gt;);
    program.help();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;cli-test-rn：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
#!/usr/bin/env node
&lt;span&gt;
const program &lt;/span&gt;=require('commander'&lt;span&gt;);
program
.option(&lt;/span&gt;'--type [typeName]', 'type: dev &amp;amp;&amp;amp; build'&lt;span&gt;)
.parse(process.argv);

const {type} &lt;/span&gt;=&lt;span&gt; program;
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(type == 'dev'&lt;span&gt;){
    console.log(&lt;/span&gt;'do something rn'&lt;span&gt;, type)
}&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(type == 'build'&lt;span&gt;){
    console.log(&lt;/span&gt;'do something rn'&lt;span&gt;, type)
}&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
    console.log(&lt;/span&gt;'params error'&lt;span&gt;);
    program.help();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;先直接运行3个命令运行程序，看下结果，而后分别解释一下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/623144/201812/623144-20181226003011444-2117775280.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;node ./bin/cli-test:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义了&lt;strong&gt;.command&lt;/strong&gt;子命令却没有相应执行参数，&lt;strong&gt;commander&lt;/strong&gt;对象会直接打印&lt;strong&gt;-help，&lt;/strong&gt;并&lt;strong&gt;process.exit&lt;/strong&gt;退出进程&lt;strong&gt;。  &lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;strong&gt;node ./bin/cli-test h5 --type dev:&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;cli-test &lt;/strong&gt;通过 &lt;strong&gt;command &lt;/strong&gt;方法约定子命令名称和描述，如 &lt;strong&gt;h5&lt;/strong&gt;，当执行 &lt;strong&gt;&lt;strong&gt;node cli-test h5 --type dev&lt;/strong&gt;&lt;/strong&gt;的时候，&lt;strong&gt;cli-test&lt;/strong&gt; 执行到 &lt;strong&gt;.command('h5', 'to h5') &lt;/strong&gt; ，会在当前 &lt;strong&gt;commande&lt;/strong&gt;r 实例内部，&lt;strong&gt;new&lt;/strong&gt; 一个 &lt;strong&gt;name&lt;/strong&gt; 为 &lt;strong&gt;h5&lt;/strong&gt; 的子 &lt;strong&gt;commander，&lt;/strong&gt;存储在当前父实例的 &lt;strong&gt;commands&lt;/strong&gt; 数组中&lt;strong&gt;，当 .parse(process.argv) &lt;/strong&gt;执行，获取到参数中 &lt;strong&gt;h5&lt;/strong&gt; 后，在 &lt;strong&gt;commands&lt;/strong&gt; 里查找是否有 &lt;strong&gt;name&lt;/strong&gt; 为 &lt;strong&gt;h5&lt;/strong&gt; 的 &lt;strong&gt;commander&lt;/strong&gt; 子实例，如果查找到，启动一个子进程按照命名规则执行 &lt;strong&gt;&lt;strong&gt;cli-test-h5&lt;/strong&gt;&lt;/strong&gt; 文件并带入后面的 &lt;strong&gt;&lt;strong&gt;option&lt;/strong&gt;&lt;/strong&gt; 参数&lt;strong&gt;&lt;strong&gt;。&lt;/strong&gt;&lt;/strong&gt; 这样 &lt;strong&gt;commander&lt;/strong&gt; 就帮助我们实现了多文件命令划分，我们可以把不同类型的执行代码放在不同的文件中&lt;strong&gt;&lt;strong&gt;。&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;strong&gt;node ./bin/cli-test h5 --type dev:&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;同上&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;bin &lt;/strong&gt;文件夹下的这3个 &lt;strong&gt;node&lt;/strong&gt; 文件他们都是 &lt;strong&gt;commander &lt;/strong&gt;实例，&lt;strong&gt;commander &lt;/strong&gt;库只是一个简单的封装，帮助定义 多文件命令、执行参数 、简易文档，参数验证等。  以上就是 &lt;strong&gt;commander &lt;/strong&gt;的大致使用和我对其的理解。   源码不多，建议可以深入学习一下。&lt;/p&gt;

&lt;h2&gt;最后&lt;/h2&gt;
&lt;p&gt;　　到最后大家结合实现以上所说的 &lt;strong&gt;cli &lt;/strong&gt;和 &lt;strong&gt;commander，&lt;/strong&gt;一个 &lt;strong&gt;commander&lt;/strong&gt; 实现的命令行工具就能完成了，是不是很简单！？  &lt;/p&gt;

&lt;h2&gt;注意&lt;/h2&gt;
&lt;p&gt;　　如果执行命令发现报错为 error: xx(1) not executable. try chmod or run with root，要注意下创建的文件类型。&lt;/p&gt;



&lt;/div&gt;
</description>
<pubDate>Tue, 25 Dec 2018 16:48:00 +0000</pubDate>
<dc:creator>子慕大诗人</dc:creator>
<og:description>前言： 最近需要做一个内部的node cli来独立构建流程，对整个命令行工具实现流程有了大致了解，下面来解释一下如何实现一个cli，和如何使用 commander 库。 新手误区：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/1wen/p/10142210.html</dc:identifier>
</item>
<item>
<title>IDEA的几个常用配置，日常开发必备。 - 纪莫</title>
<link>http://www.cnblogs.com/jimoer/p/10166343.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jimoer/p/10166343.html</guid>
<description>&lt;p&gt;用了IDEA有很长时间了，身边的同事朋友也都慢慢的开始都从Eclipse切换到IDEA了，其实无论是Eclipse还是IntelliJ IDEA都是开发工具而已，各自都有优点。但是刚从Eclipse切换到IDEA的时候还是很不适应的，有些人用了一段时间的IDEA适应不了就又切换回Eclipse了，也有的人把IDEA的快捷键设置成了Eclipse的快捷方式。这些都能说明IDEA的使用还是有点门槛的。那我就结合自己的使用过程，来介绍一下我的一些IDEA的日常配置。&lt;/p&gt;
&lt;h2&gt;默认设置（Other Settings）&lt;/h2&gt;
&lt;p&gt;IDEA不像Eclipse那样可以在一个窗口中打开多个项目，IDEA每次打开一个新的项目都需要开一个新的窗口或者覆盖掉当前窗口，所以在打开多个项目的时候就需要开多个窗口，但是如果不设置好默认设置，每次打开一个新的窗口就要重新设置。例如：每次打开新的项目的时候maven的本地仓库地址都要重新设置。通过设置Other Settings就可以解决这类问题。File--&amp;gt;Other Settings--&amp;gt;Preferences for New Projects。然后在左上角的搜索框中搜maven，就能看到如下图所示配置了。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/772743/201812/772743-20181225215755670-969534675.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;配置默认打开的项目的JDK也和这个类似，File--&amp;gt;Other Settings--&amp;gt;Structure for New Projects。然后就可以看到项目配置（Project Settings）和平台配置(Platform Settings)了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772743/201812/772743-20181225220504302-2130467494.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;自动编译开关&lt;/h2&gt;
&lt;p&gt;在IDEA当中自动编译是需要手动打开的，File--&amp;gt;settings--&amp;gt;Build,Execution,Deployment--&amp;gt;Compiler，然后将下图红框处勾上。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772743/201812/772743-20181225221427509-18512067.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;自动引包&lt;/h2&gt;
&lt;p&gt;IDEA默认是没有开启自动引包功能的。需要手动打开，位置在：File--&amp;gt;Settings--&amp;gt;Editor--&amp;gt;General--&amp;gt;Auto Import。然后在下图的1和2的位置上进行勾选。&lt;/p&gt;
&lt;p&gt;勾选上1的位置后，IDEA 将在我们书写代码的时候自动帮我们优化引入的包，比如自动去掉一些没有用到的包。&lt;/p&gt;
&lt;p&gt;勾选上2的位置后，IDEA 将在我们书写代码的时候自动帮我们导入需要用到的包。但是对于那些同名的包，还是需要手动 &lt;code&gt;Alt + Enter&lt;/code&gt; 进行导入的，IntelliJ IDEA 目前还无法智能到替我们做判断。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772743/201812/772743-20181225222419341-488060697.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;内存使用量展示&lt;/h2&gt;
&lt;p&gt;由于日常开发时都是在公司的办公电脑上进行的，所以内存总是不够用，但是又不清楚IDEA具体实时的占用了多少内存。这个时候对于一些内存并不是太够的开发人员来说能看到实时的内存使用量还是比较好的。IDEA是提供这项功能的，但是需要手动的打开。具体位置在：File--&amp;gt;Settings--&amp;gt;Apperance--&amp;gt;Window Options--&amp;gt;Show Memory indicator。&lt;/p&gt;
&lt;p&gt;勾选上后在IDEA的右下角就可以看到实时的内存使用量了，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772743/201812/772743-20181225223753297-1576333971.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;悬浮提示&lt;/h2&gt;
&lt;p&gt;有时候在看代码的时候，不清楚一个类具体是干什么的，就会点进去看这个类的注释，但是强大的IDEA是支持不用点进去就可以看到注释的以及类的相关信息的。但是需要手动打开。具体位置在：File--&amp;gt;Settings--&amp;gt;Editor--&amp;gt;General。然后在下图所示的位置上进行勾选，后面的时间是悬浮提示的显示时间。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772743/201812/772743-20181225225236485-1113981065.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;效果如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772743/201812/772743-20181225225914542-1551506507.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;Ctrl+鼠标滚轴修改字体大小&lt;/h2&gt;
&lt;p&gt;IDEA也支持向浏览器那样按住Ctrl+鼠标滚轴来改变编辑区的字体的大小，设置的开关在：File--&amp;gt;Settings--&amp;gt;Editor--&amp;gt;General。&lt;/p&gt;
&lt;p&gt;将如下图所示的位置勾选上。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772743/201812/772743-20181225230638607-1355401996.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;效果如下动图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772743/201812/772743-20181225230955456-594266557.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;显示多行Tab&lt;/h2&gt;
&lt;p&gt;当我们打开的标签页多了的时候，默认的会隐藏在右侧，当我们需要的时候在右侧找到后再打开。IDEA是支持多行显示的，这样在大屏幕的显示器上也不用总去点击右侧的去找刚才打开过的文件了（其实通过Ctril+E也可以找到刚才打开过的文件）。具体开关位置在：File--&amp;gt;Settings--&amp;gt;Editor--&amp;gt;General--&amp;gt;Editor Tabs。&lt;/p&gt;
&lt;p&gt;下图位置1的把勾选去掉就可以了。位置2是设置最多展示多少个Tab。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772743/201812/772743-20181225232143183-583755060.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;显示行号，显示svn/git最近提交人&lt;/h2&gt;
&lt;p&gt;在编辑区直接操作，能看到每一行代码的最近一次修改人，以及提交记录信息。这样每行代码都有记录。能很快定位到谁动过代码，然后找到指定的人来解决问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772743/201812/772743-20181225233620846-929596446.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;查看文件的本地历史记录&lt;/h2&gt;
&lt;p&gt;鼠标选中文件，然后右键，在弹出的列表中选择Local History然后就可以看到文件的本地修改记录，即使没有版本控制工具也可以看到这些记录。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;这些都只是我个人总结的习惯设置，因人而异，不一定我的习惯就适合你。所以根据自己需要来进行设置吧。IDEA有很多好用的功能，等着我们去挖掘，并且IDEA团队也在不断的更新迭代，后续我发现了其他好用的功能后会继续推荐给大家的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772743/201809/772743-20180915224244625-861430438.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;文章会同步到我的公众号上面，欢迎关注。&lt;/p&gt;
</description>
<pubDate>Tue, 25 Dec 2018 16:30:00 +0000</pubDate>
<dc:creator>纪莫</dc:creator>
<og:description>用了IDEA有很长时间了，身边的同事朋友也都慢慢的开始都从Eclipse切换到IDEA了，其实无论是Eclipse还是IntelliJ IDEA都是开发工具而已，各自都有优点。但是刚从Eclipse切</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jimoer/p/10166343.html</dc:identifier>
</item>
<item>
<title>012.Docker私有仓库多Harbor同步部署 - 木二</title>
<link>http://www.cnblogs.com/itzgr/p/10177143.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/itzgr/p/10177143.html</guid>
<description>&lt;h2&gt;一 Harbor主从介绍&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;harbor官方默认提供主从复制的方案来解决镜像同步问题，通过复制的方式，我们可以实时将测试环境harbor仓库的镜像同步到生产环境harbor，类似于如下流程：&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181226002146297-1355890457.png&quot;&gt;&lt;img title=&quot;97_thumb1&quot; src=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181226002146680-719123731.png&quot; alt=&quot;97_thumb1&quot; width=&quot;803&quot; height=&quot;348&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;Harbor以“项目”为中心，通过对项目配置“复制策略”，标明需要复制的项目以及镜像。管理员在复制策略中指明目标实例，即复制的“目的地”，并对它的地址和连接时使用的用户名密码进行设置。当复制策略被激活时，源项目下的所有镜像，都会被复制到目标实例；此外，当源项目下的镜像被添加或删除（push或delete), 只要策略还在激活状态，镜像的变化都会同步到目标实例上去， 如下图所示：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181226002146884-1230033513.png&quot;&gt;&lt;img title=&quot;98_thumb1&quot; src=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181226002147095-560404519.png&quot; alt=&quot;98_thumb1&quot; width=&quot;645&quot; height=&quot;418&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;在实际生产运维的中，需要把镜像发布到几十或上百台集群节点上。这时，单个Registry已经无法满足大量节点的下载需求，因此要配置多个Registry实例做负载均衡。手工维护多个Registry实例上的镜像，将是十分繁琐的事情。Harbor可以支持一主多从的镜像发布模式，可以解决大规模镜像分发与同步，架构如下：&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181226002147306-778524077.png&quot;&gt;&lt;img title=&quot;99_thumb1&quot; src=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181226002147607-374539754.png&quot; alt=&quot;99_thumb1&quot; width=&quot;745&quot; height=&quot;416&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;h2&gt;二 Harbor主从部署&lt;/h2&gt;
&lt;h3&gt;2.1 前期准备&lt;/h3&gt;
&lt;div&gt;
&lt;table&gt;&lt;colgroup&gt;&lt;col width=&quot;170&quot;/&gt;&lt;col width=&quot;191&quot;/&gt;&lt;col width=&quot;191&quot;/&gt;&lt;/colgroup&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr&gt;&lt;td data-cell-id=&quot;7626-1540615523826-cell-0-0&quot;&gt;
&lt;p&gt;&lt;span&gt;节点&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td data-cell-id=&quot;7626-1540615523826-cell-0-1&quot;&gt;
&lt;p&gt;&lt;span&gt;IP地址&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td data-cell-id=&quot;7626-1540615523826-cell-0-2&quot;&gt;
&lt;p&gt;&lt;span&gt;备注&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td data-cell-id=&quot;7626-1540615523826-cell-1-0&quot;&gt;
&lt;p&gt;&lt;span&gt;docker01&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td data-cell-id=&quot;7626-1540615523826-cell-1-1&quot;&gt;
&lt;p&gt;&lt;span&gt;172.24.8.111&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td data-cell-id=&quot;7626-1540615523826-cell-1-2&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;Docker harbor主节点，reg.harbor01.com&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td data-cell-id=&quot;7626-1540615523826-cell-2-0&quot;&gt;
&lt;p&gt;&lt;span&gt;docker02&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td data-cell-id=&quot;7626-1540615523826-cell-2-1&quot;&gt;
&lt;p&gt;&lt;span&gt;172.24.8.112&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td data-cell-id=&quot;7626-1540615523826-cell-2-2&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;Docker harbor从节点，reg.harbor02.com&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td data-cell-id=&quot;7626-1540615523826-cell-3-0&quot;&gt;
&lt;p&gt;&lt;span&gt;docker03&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td data-cell-id=&quot;7626-1540615523826-cell-3-1&quot;&gt;
&lt;p&gt;&lt;span&gt;172.24.8.113&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td data-cell-id=&quot;7626-1540615523826-cell-3-2&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;Docker客户端，用于测试仓库&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;建议所有节点添加hosts解析：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; 172.24.8.111 reg.harbor01.com
&lt;span&gt;  2&lt;/span&gt; 172.24.8.112 reg.harbor02.com
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;2.1 主从节点部署Harbor&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;部署方法可参考《011.Docker仓库管理》部署。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;提示：主从节点都必须部署Harbor，本实验采用http形式，只需要修改hostname为对应的域名即可。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意：Job services主要用于镜像复制，本地镜像可以被同步到远程Harbor实例上。因此若采用域名配置，则需要在jobservice的hosts中添加主从解析，为方便修改，可将使用以下脚本快速在所有容器hosts添加相应解析：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; root@docker02:~/harbor# cat addhosts.sh
&lt;span&gt;  2&lt;/span&gt; #!/bin/sh
&lt;span&gt;  3&lt;/span&gt; #****************************************************************#
&lt;span&gt;  4&lt;/span&gt; # ScriptName: test.sh
&lt;span&gt;  5&lt;/span&gt; # Author: xhy@itzgr.com
&lt;span&gt;  6&lt;/span&gt; # Create Date: 2018-10-27 15:48
&lt;span&gt;  7&lt;/span&gt; # Modify Author: xhy@itzgr.com
&lt;span&gt;  8&lt;/span&gt; #***************************************************************#
&lt;span&gt;  9&lt;/span&gt; docker ps | awk '{print $1}'&amp;gt;./dockerlist.txt
&lt;span&gt; 10&lt;/span&gt; for id in `cat ./dockerlist.txt`
&lt;span&gt; 11&lt;/span&gt; do
&lt;span&gt; 12&lt;/span&gt;     HOSTS=`docker inspect $id | grep hosts | awk -F &quot;\&quot;&quot; '{print $4}'`
&lt;span&gt; 13&lt;/span&gt;     echo -e &quot;172.24.8.111 reg.harbor01.com\n172.24.8.112 reg.harbor02.com&quot; &amp;gt;&amp;gt; $HOSTS
&lt;span&gt; 14&lt;/span&gt; done
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;在Harbor部署完毕后执行该脚本：chmod u+x addhosts.sh &amp;amp;&amp;amp; bash addhosts.sh。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;2.2 主节点测试&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;浏览器使用默认账号和密码Harbor12345访问：http://reg.harbor01.com&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181226002147843-1507886319.png&quot;&gt;&lt;img title=&quot;100_thumb1&quot; src=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181226002148253-1831412475.png&quot; alt=&quot;100_thumb1&quot; width=&quot;945&quot; height=&quot;434&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;2.3 创建用于复制的测试项目&lt;/h3&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181226002148667-733731638.png&quot;&gt;&lt;img title=&quot;101_thumb1&quot; src=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181226002149047-631569231.png&quot; alt=&quot;101_thumb1&quot; width=&quot;772&quot; height=&quot;545&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;2.4 仓库管理新建从目标&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181226002149333-57598077.png&quot;&gt;&lt;img title=&quot;102_thumb1&quot; src=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181226002149663-1551210594.png&quot; alt=&quot;102_thumb1&quot; width=&quot;582&quot; height=&quot;543&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;2.5 创建复制策略&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181226002149993-2120470104.png&quot;&gt;&lt;img title=&quot;103_thumb1&quot; src=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181226002150299-1284367929.png&quot; alt=&quot;103_thumb1&quot; width=&quot;749&quot; height=&quot;664&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;2.6 docker 客户端测试&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; root@docker03:~# vi /etc/hosts
&lt;span&gt;  2&lt;/span&gt; 172.24.8.111 reg.harbor01.com
&lt;span&gt;  3&lt;/span&gt; 172.24.8.112 reg.harbor02.com
&lt;span&gt;  4&lt;/span&gt; root@docker03:~# vi /etc/docker/daemon.json
&lt;span&gt;  5&lt;/span&gt; {
&lt;span&gt;  6&lt;/span&gt;     &quot;insecure-registries&quot;: [&quot;http://reg.harbor01.com&quot;,&quot;http://reg.harbor02.com&quot;]
&lt;span&gt;  7&lt;/span&gt; }
&lt;span&gt;  8&lt;/span&gt; root@docker03:~# systemctl daemon-reload
&lt;span&gt;  9&lt;/span&gt; root@docker03:~# systemctl restart docker.service
&lt;span&gt; 10&lt;/span&gt; root@docker03:~# docker login reg.harbor01.com          #登录registry
&lt;span&gt; 11&lt;/span&gt; Username: admin
&lt;span&gt; 12&lt;/span&gt; Password:
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;提示：公开的registry可pull，但push也必须登录，私有的registry必须登录才可pull和push。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; root@docker03:~# docker pull hello-world
&lt;span&gt;  2&lt;/span&gt; root@docker03:~# docker tag hello-world:latest reg.harbor01.com/copyregistry/hello-world:xhy
&lt;span&gt;  3&lt;/span&gt; root@docker03:~# docker push reg.harbor01.com/copyregistry/hello-world:xhy
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;浏览器使用默认账号和密码Harbor12345访问：http://reg.harbor01.com，查看是否同步状态：&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181226002150680-1428586897.png&quot;&gt;&lt;img title=&quot;104_thumb1&quot; src=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181226002151043-1300505061.png&quot; alt=&quot;104_thumb1&quot; width=&quot;945&quot; height=&quot;628&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;浏览器使用默认账号和密码Harbor12345访问：http://reg.harbor02.com，查看是否同步成功：&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181226002151544-1084550747.png&quot;&gt;&lt;img title=&quot;105_thumb1&quot; src=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181226002151856-281043195.png&quot; alt=&quot;105_thumb1&quot; width=&quot;933&quot; height=&quot;435&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;参考链接：https://www.cnblogs.com/breezey/p/9444231.html&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参考链接：https://blog.csdn.net/hiyun9/article/details/79655385&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 25 Dec 2018 16:22:00 +0000</pubDate>
<dc:creator>木二</dc:creator>
<og:description>一 Harbor主从介绍 harbor官方默认提供主从复制的方案来解决镜像同步问题，通过复制的方式，我们可以实时将测试环境harbor仓库的镜像同步到生产环境harbor，类似于如下流程： Harbo</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/itzgr/p/10177143.html</dc:identifier>
</item>
<item>
<title>GridView在不写后端代码绑定数据源且无数据的情况下显示脚注行Footer的新方法 - 卓酷</title>
<link>http://www.cnblogs.com/joy2code/p/10177131.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/joy2code/p/10177131.html</guid>
<description>&lt;p&gt;        记录一下今天解决的一个需求，GridView在页面上用SqlDataSource控件配置数据源直接绑定，不用后台代码动态绑定，然后为了方便插入数据，在参考了各位大佬的博文后，采用了在字段的脚注行里插入文本框控件，收集各列的数据，然后在后台用SqlDataSource的插入参数配置之后，直接insert方法完成新记录的入库。&lt;/p&gt;
&lt;p&gt;        理想是美好的，但现实总是有点扭曲。这个新记录插入方法在数据源有数据的时候很好使，因为只要设置了showfooter=true，脚注行就能显示。但是如果没数据的时候，脚注行就消失了，这简直就是反人类啊，明明没数据才是最需要你出现的时候，但你偏偏消失了。而且表头有个ShowHeaderWhenEmpty属性可以解决无数据显示表头的问题，偏偏没有对应的showFooterWhenEmpty来解决无数据显示脚注行的需求。&lt;/p&gt;
&lt;p&gt;        于是又参观了几个大牛的相关问题的博文，发现他们要么是动态绑定数据源，监测数据条数为0就自动插入一个空白新行，把无数据变成有数据，以此来解决需求。但本着能偷懒就不写后台代码的原则，这个方法就没法套用了。另外还有一个方法也有点类似，但是能保持数据源还是aspx页面里配置的，有点偷梁换柱意思，就是在PreRender里检查是否有数据，没有数据就用一个同样列框架的DataTable插入一个空行并替换掉SqlDataSource，最终使GridView变成有数据；但这个替换还要有个还原的操作，在Page_Load里，每次都要把SqlDataSource设置回来，不然数据源就不统一了。这个方法的确也能解决问题，但设置太复杂。&lt;/p&gt;
&lt;p&gt;        因为实在没有更好地偷懒的方法了，所以自己研究了一下，思路都差不多，要想让Footer模板显示，唯一的方式就是在SqlDataSource无数据时，能够插入一个空行，这就变成有数据了，自然就能显示Footer了。上面几种方式的思维都是正向的，在发现没数据时才想尽办法插一条，但可惜GridView和SqlDataSource都不能手动加空白数据，所以只能更换数据源。于是我干脆来个逆向思维，为什么不能在SqlDataSource查询数据的时候就直接加一个空行进来呢？所以到这里，一切问题都解决了，只需要在SqlDataSource的查询SQL里用UNION整合一条空白数据进来即可，完美解决无数据而造数据的问题。&lt;/p&gt;
&lt;p&gt;        具体代码就不写了，核心思路就是从数据源头保证至少会有一条空数据存在，这样在GridView里空白数据显示的只是末行的空白而已，无伤大雅，而Footer行也能自动出现了。如果你有强迫症或者数据列里有控件，显示出来不优雅，没关系，也容易解决，在行数据绑定的事件里检查一下当前数据行是不是键值为空，是就让当前行的Visible=false就好了。&lt;/p&gt;
</description>
<pubDate>Tue, 25 Dec 2018 16:11:00 +0000</pubDate>
<dc:creator>卓酷</dc:creator>
<og:description>记录一下今天解决的一个需求，GridView在页面上用SqlDataSource控件配置数据源直接绑定，不用后台代码动态绑定，然后为了方便插入数据，在参考了各位大佬的博文后，采用了在字段的脚注行里插入</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/joy2code/p/10177131.html</dc:identifier>
</item>
<item>
<title>机器学习笔记(5)  KNN算法 - sdu20112013</title>
<link>http://www.cnblogs.com/sdu20112013/p/10171425.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sdu20112013/p/10171425.html</guid>
<description>&lt;p&gt;这篇其实应该作为机器学习的第一篇笔记的,但是在刚开始学习的时候,我还没有用博客记录笔记的打算.所以也就想到哪写到哪了.&lt;/p&gt;
&lt;p&gt;你在网上搜索机器学习系列文章的话,大部分都是以KNN（k nearest neighbors）作为第一篇入门的,因为这个算法实在是太简单了.简单到其实没啥可说的.&lt;/p&gt;
&lt;p&gt;                                       &lt;img src=&quot;https://img2018.cnblogs.com/blog/583030/201812/583030-20181225203204218-1963305370.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;问题：已知正方形和三角形两种分类,现在来了个圆,问：应该归到正方形更合适还是三角形更合适？&lt;/p&gt;
&lt;p&gt;算法的思想很朴素,假设我们有一个M*N的矩阵(M个样本,每个样本有N个特征).当我们来了一个新的样本test,我们要去判断这个样本属于什么类别,我们去计算test与M个样本中每一个样本的距离,选取最近的K个样本,投票出test的类别.&lt;/p&gt;

&lt;p&gt;前面说了,通过判断两个样本之间的距离(或者说N维空间中的2个点之间的距离),来判断两个样本的相似程度. &lt;span&gt;那问题来了,我们如何表达&quot;两个点之间的距离呢&quot;？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;二维空间中距离：$$\sqrt {(x^{(a)}-x^{(b)})^2+(y^{(a)}-y^{(b)})^2}$$&lt;/p&gt;
&lt;p&gt;三维空间中距离：$$\sqrt {(x^{(a)}-x^{(b)})^2+(y^{(a)}-y^{(b)})^2+(z^{(a)}-z^{(b)})^2}$$&lt;/p&gt;
&lt;p&gt;推而广之,N维空间中距离：$$\sqrt {(x_1^{(a)}-x_1^{(b)})^2+(x_2^{(a)}-x_2^{(b)})^2+…+(x_n^{(a)}-x_n^{(b)})^2} =\sqrt {\sum_{i=1}^n(x_i^{(a)}-x_i^{(b)})^2}$$&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这就是我们熟知的欧拉距离.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;实际上,如何度量距离,还有&lt;span&gt;曼哈顿距离&lt;/span&gt;,$$\sum_{i=1}^n |X_i^{(a)}-X_i^{(b)}|$$&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;欧拉距离和曼哈顿距离都可以统一表达为&lt;span&gt;明科夫斯基距离&lt;/span&gt;$$（\sum_{i=1}^n |X_i^{(a)}-X_i^{(b)}|^p）^\frac 1 p$$,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当p=1时,即是曼哈顿距离,当p=2时,即是欧拉距离.sklearn中默认的p=2.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;事实上,距离的表达不仅仅是明科夫斯基距离,还有很多种,就不一一介绍了：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Metrics intended for real-valued vector spaces:&lt;/strong&gt;&lt;/p&gt;
&lt;table class=&quot;docutils&quot; border=&quot;1&quot;&gt;&lt;colgroup&gt;&lt;col width=&quot;19%&quot;/&gt;&lt;col width=&quot;27%&quot;/&gt;&lt;col width=&quot;11%&quot;/&gt;&lt;col width=&quot;42%&quot;/&gt;&lt;/colgroup&gt;&lt;tbody valign=&quot;top&quot; readability=&quot;3&quot;&gt;&lt;tr class=&quot;row-odd&quot;&gt;&lt;td&gt;identifier&lt;/td&gt;
&lt;td&gt;class name&lt;/td&gt;
&lt;td&gt;args&lt;/td&gt;
&lt;td&gt;distance function&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;row-even&quot;&gt;&lt;td&gt;“euclidean”&lt;/td&gt;
&lt;td&gt;EuclideanDistance&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;&lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;sqrt(sum((x &lt;span class=&quot;pre&quot;&gt;- &lt;span class=&quot;pre&quot;&gt;y)^2))&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;row-odd&quot;&gt;&lt;td&gt;“manhattan”&lt;/td&gt;
&lt;td&gt;ManhattanDistance&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;&lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;sum(|x &lt;span class=&quot;pre&quot;&gt;- &lt;span class=&quot;pre&quot;&gt;y|)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;row-even&quot;&gt;&lt;td&gt;“chebyshev”&lt;/td&gt;
&lt;td&gt;ChebyshevDistance&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;&lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;max(|x &lt;span class=&quot;pre&quot;&gt;- &lt;span class=&quot;pre&quot;&gt;y|)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;row-odd&quot;&gt;&lt;td&gt;“minkowski”&lt;/td&gt;
&lt;td&gt;MinkowskiDistance&lt;/td&gt;
&lt;td&gt;p&lt;/td&gt;
&lt;td&gt;&lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;sum(|x &lt;span class=&quot;pre&quot;&gt;- &lt;span class=&quot;pre&quot;&gt;y|^p)^(1/p)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;row-even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;“wminkowski”&lt;/td&gt;
&lt;td&gt;WMinkowskiDistance&lt;/td&gt;
&lt;td&gt;p, w&lt;/td&gt;
&lt;td&gt;&lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;sum(|w &lt;span class=&quot;pre&quot;&gt;* &lt;span class=&quot;pre&quot;&gt;(x &lt;span class=&quot;pre&quot;&gt;- &lt;span class=&quot;pre&quot;&gt;y)|^p)^(1/p)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;row-odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;“seuclidean”&lt;/td&gt;
&lt;td&gt;SEuclideanDistance&lt;/td&gt;
&lt;td&gt;V&lt;/td&gt;
&lt;td&gt;&lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;sqrt(sum((x &lt;span class=&quot;pre&quot;&gt;- &lt;span class=&quot;pre&quot;&gt;y)^2 &lt;span class=&quot;pre&quot;&gt;/ &lt;span class=&quot;pre&quot;&gt;V))&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;row-even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;“mahalanobis”&lt;/td&gt;
&lt;td&gt;MahalanobisDistance&lt;/td&gt;
&lt;td&gt;V or VI&lt;/td&gt;
&lt;td&gt;&lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;sqrt((x &lt;span class=&quot;pre&quot;&gt;- &lt;span class=&quot;pre&quot;&gt;y)' &lt;span class=&quot;pre&quot;&gt;V^-1 &lt;span class=&quot;pre&quot;&gt;(x &lt;span class=&quot;pre&quot;&gt;- &lt;span class=&quot;pre&quot;&gt;y))&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;Metrics intended for integer-valued vector spaces:&lt;/strong&gt; Though intended for integer-valued vectors, these are also valid metrics in the case of real-valued vectors.&lt;/p&gt;
&lt;table class=&quot;docutils&quot; border=&quot;1&quot;&gt;&lt;colgroup&gt;&lt;col width=&quot;18%&quot;/&gt;&lt;col width=&quot;27%&quot;/&gt;&lt;col width=&quot;55%&quot;/&gt;&lt;/colgroup&gt;&lt;tbody valign=&quot;top&quot; readability=&quot;3.5&quot;&gt;&lt;tr class=&quot;row-odd&quot;&gt;&lt;td&gt;identifier&lt;/td&gt;
&lt;td&gt;class name&lt;/td&gt;
&lt;td&gt;distance function&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;row-even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;“hamming”&lt;/td&gt;
&lt;td&gt;HammingDistance&lt;/td&gt;
&lt;td&gt;&lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;N_unequal(x, &lt;span class=&quot;pre&quot;&gt;y) &lt;span class=&quot;pre&quot;&gt;/ &lt;span class=&quot;pre&quot;&gt;N_tot&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;row-odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;“canberra”&lt;/td&gt;
&lt;td&gt;CanberraDistance&lt;/td&gt;
&lt;td&gt;&lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;sum(|x &lt;span class=&quot;pre&quot;&gt;- &lt;span class=&quot;pre&quot;&gt;y| &lt;span class=&quot;pre&quot;&gt;/ &lt;span class=&quot;pre&quot;&gt;(|x| &lt;span class=&quot;pre&quot;&gt;+ &lt;span class=&quot;pre&quot;&gt;|y|))&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;row-even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;“braycurtis”&lt;/td&gt;
&lt;td&gt;BrayCurtisDistance&lt;/td&gt;
&lt;td&gt;&lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;sum(|x &lt;span class=&quot;pre&quot;&gt;- &lt;span class=&quot;pre&quot;&gt;y|) &lt;span class=&quot;pre&quot;&gt;/ &lt;span class=&quot;pre&quot;&gt;(sum(|x|) &lt;span class=&quot;pre&quot;&gt;+ &lt;span class=&quot;pre&quot;&gt;sum(|y|))&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;&lt;span&gt;知道如何计算距离了,似乎我们的KNN已经可以工作了,但是,问题又来了&lt;/span&gt;,考虑一下这个场景：我们选取K=3，然鹅,好巧不巧的,最终算出来的最近的3个距离是一样的,而这3个样本又分别属于不同的类别,这我们要怎么归类呢？如果你觉得这个例子比较极端,那考虑一下这个场景：我们通过计算找出了距离待测样本最近的3个点,假设这3个点p1,p2,p3分别属于类别A，B，B. 但是,待测样本点距离点p1的距离为1,距离p2的距离为100，距离p3的距离为50.这个时候显然待测点和p1是极为接近的,把待测样本归类到A是更合理的.而由p1,p2,p3投票的话会把待测样本归类为B。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这就引入了权重(weight)的概念.由于p1和待测样本点距离极为接近,所以我们应该把p1的投票权重提高.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;sklearn中的KNeighborsClassifier的weight参数有以下3个取值.&lt;/p&gt;
&lt;ul class=&quot;last simple&quot;&gt;&lt;li&gt;‘uniform’ : uniform weights. All points in each neighborhood are weighted equally.&lt;/li&gt;
&lt;li&gt;‘distance’ : weight points by the inverse of their distance. in this case, closer neighbors of a query point will have a greater influence than neighbors which are further away.&lt;/li&gt;
&lt;li&gt;[callable] : a user-defined function which accepts an array of distances, and returns an array of the same shape containing the weights.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;uniform 代表等权重. sklean中默认取值是uniform。&lt;/p&gt;
&lt;p&gt;distance代表用距离的倒数作为权重.&lt;/p&gt;
&lt;p&gt;callable代表用户自定义函数.&lt;/p&gt;

&lt;p&gt;以下是sklearn中KNeighborsClassifier的具体参数.&lt;/p&gt;
&lt;blockquote readability=&quot;70.902124114952&quot;&gt;
&lt;p&gt;&lt;em class=&quot;property&quot;&gt;class &lt;/em&gt;&lt;code class=&quot;descclassname&quot;&gt;sklearn.neighbors.&lt;/code&gt;&lt;code class=&quot;descname&quot;&gt;KNeighborsClassifier&lt;/code&gt;&lt;span class=&quot;sig-paren&quot;&gt;(&lt;em&gt;n_neighbors=5&lt;/em&gt;, &lt;em&gt;weights=’uniform’&lt;/em&gt;, &lt;em&gt;algorithm=’auto’&lt;/em&gt;, &lt;em&gt;leaf_size=30&lt;/em&gt;, &lt;em&gt;p=2&lt;/em&gt;, &lt;em&gt;metric=’minkowski’&lt;/em&gt;, &lt;em&gt;metric_params=None&lt;/em&gt;, &lt;em&gt;n_jobs=None&lt;/em&gt;, &lt;em&gt;**kwargs&lt;/em&gt;&lt;span class=&quot;sig-paren&quot;&gt;)&lt;a class=&quot;reference external&quot; href=&quot;https://github.com/scikit-learn/scikit-learn/blob/7389dba/sklearn/neighbors/classification.py#L23&quot;&gt;&lt;span class=&quot;viewcode-link&quot;&gt;[source]&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;n_neighbors&lt;/strong&gt; &lt;span class=&quot;classifier-delimiter&quot;&gt;: &lt;span class=&quot;classifier&quot;&gt;int, optional (default = 5)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;first last&quot;&gt;Number of neighbors to use by default for &lt;a class=&quot;reference internal&quot; title=&quot;sklearn.neighbors.KNeighborsClassifier.kneighbors&quot; href=&quot;https://scikit-learn.org/stable/modules/generated/sklearn.neighbors.KNeighborsClassifier.html#sklearn.neighbors.KNeighborsClassifier.kneighbors&quot;&gt;&lt;code class=&quot;xref py py-meth docutils literal&quot;&gt;kneighbors&lt;/code&gt;&lt;/a&gt; queries.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;weights&lt;/strong&gt; &lt;span class=&quot;classifier-delimiter&quot;&gt;: &lt;span class=&quot;classifier&quot;&gt;str or callable, optional (default = ‘uniform’)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;first&quot;&gt;weight function used in prediction. Possible values:&lt;/p&gt;
&lt;ul class=&quot;last simple&quot;&gt;&lt;li&gt;‘uniform’ : uniform weights. All points in each neighborhood are weighted equally.&lt;/li&gt;
&lt;li&gt;‘distance’ : weight points by the inverse of their distance. in this case, closer neighbors of a query point will have a greater influence than neighbors which are further away.&lt;/li&gt;
&lt;li&gt;[callable] : a user-defined function which accepts an array of distances, and returns an array of the same shape containing the weights.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;algorithm&lt;/strong&gt; &lt;span class=&quot;classifier-delimiter&quot;&gt;: &lt;span class=&quot;classifier&quot;&gt;{‘auto’, ‘ball_tree’, ‘kd_tree’, ‘brute’}, optional&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;first&quot;&gt;Algorithm used to compute the nearest neighbors:&lt;/p&gt;
&lt;ul class=&quot;simple&quot;&gt;&lt;li&gt;‘ball_tree’ will use &lt;a class=&quot;reference internal&quot; title=&quot;sklearn.neighbors.BallTree&quot; href=&quot;https://scikit-learn.org/stable/modules/generated/sklearn.neighbors.BallTree.html#sklearn.neighbors.BallTree&quot;&gt;&lt;code class=&quot;xref py py-class docutils literal&quot;&gt;BallTree&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;‘kd_tree’ will use &lt;a class=&quot;reference internal&quot; title=&quot;sklearn.neighbors.KDTree&quot; href=&quot;https://scikit-learn.org/stable/modules/generated/sklearn.neighbors.KDTree.html#sklearn.neighbors.KDTree&quot;&gt;&lt;code class=&quot;xref py py-class docutils literal&quot;&gt;KDTree&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;‘brute’ will use a brute-force search.&lt;/li&gt;
&lt;li&gt;‘auto’ will attempt to decide the most appropriate algorithm based on the values passed to &lt;a class=&quot;reference internal&quot; title=&quot;sklearn.neighbors.KNeighborsClassifier.fit&quot; href=&quot;https://scikit-learn.org/stable/modules/generated/sklearn.neighbors.KNeighborsClassifier.html#sklearn.neighbors.KNeighborsClassifier.fit&quot;&gt;&lt;code class=&quot;xref py py-meth docutils literal&quot;&gt;fit&lt;/code&gt;&lt;/a&gt;method.&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;last&quot;&gt;Note: fitting on sparse input will override the setting of this parameter, using brute force.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;leaf_size&lt;/strong&gt; &lt;span class=&quot;classifier-delimiter&quot;&gt;: &lt;span class=&quot;classifier&quot;&gt;int, optional (default = 30)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;first last&quot;&gt;Leaf size passed to BallTree or KDTree. This can affect the speed of the construction and query, as well as the memory required to store the tree. The optimal value depends on the nature of the problem.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;p&lt;/strong&gt; &lt;span class=&quot;classifier-delimiter&quot;&gt;: &lt;span class=&quot;classifier&quot;&gt;integer, optional (default = 2)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;first last&quot;&gt;Power parameter for the Minkowski metric. When p = 1, this is equivalent to using manhattan_distance (l1), and euclidean_distance (l2) for p = 2. For arbitrary p, minkowski_distance (l_p) is used.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;metric&lt;/strong&gt; &lt;span class=&quot;classifier-delimiter&quot;&gt;: &lt;span class=&quot;classifier&quot;&gt;string or callable, default ‘minkowski’&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;first last&quot;&gt;the distance metric to use for the tree. The default metric is minkowski, and with p=2 is equivalent to the standard Euclidean metric. See the documentation of the DistanceMetric class for a list of available metrics.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;metric_params&lt;/strong&gt; &lt;span class=&quot;classifier-delimiter&quot;&gt;: &lt;span class=&quot;classifier&quot;&gt;dict, optional (default = None)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;first last&quot;&gt;Additional keyword arguments for the metric function.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;n_jobs&lt;/strong&gt; &lt;span class=&quot;classifier-delimiter&quot;&gt;: &lt;span class=&quot;classifier&quot;&gt;int or None, optional (default=None)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;first last&quot;&gt;The number of parallel jobs to run for neighbors search. &lt;code class=&quot;docutils literal&quot;&gt;None&lt;/code&gt; means 1 unless in a &lt;a class=&quot;reference external&quot; title=&quot;(in joblib v0.13.0)&quot; href=&quot;https://joblib.readthedocs.io/en/latest/parallel.html#joblib.parallel_backend&quot;&gt;&lt;code class=&quot;xref py py-obj docutils literal&quot;&gt;joblib.parallel_backend&lt;/code&gt;&lt;/a&gt; context. &lt;code class=&quot;docutils literal&quot;&gt;-1&lt;/code&gt; means using all processors. See &lt;a class=&quot;reference internal&quot; href=&quot;https://scikit-learn.org/stable/glossary.html#term-n-jobs&quot;&gt;Glossary&lt;/a&gt; for more details. Doesn’t affect &lt;a class=&quot;reference internal&quot; title=&quot;sklearn.neighbors.KNeighborsClassifier.fit&quot; href=&quot;https://scikit-learn.org/stable/modules/generated/sklearn.neighbors.KNeighborsClassifier.html#sklearn.neighbors.KNeighborsClassifier.fit&quot;&gt;&lt;code class=&quot;xref py py-meth docutils literal&quot;&gt;fit&lt;/code&gt;&lt;/a&gt; method.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; X = [[0], [1], [2], [3&lt;span&gt;]]
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; y = [0, 0, 1, 1&lt;span&gt;]
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;from&lt;/span&gt; sklearn.neighbors &lt;span&gt;import&lt;/span&gt;&lt;span&gt; KNeighborsClassifier
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; neigh = KNeighborsClassifier(n_neighbors=3&lt;span&gt;)
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; neigh.fit(X, y) 
KNeighborsClassifier(...)
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;print&lt;/span&gt;(neigh.predict([[1.1&lt;span&gt;]]))
[0]
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;print&lt;/span&gt;(neigh.predict_proba([[0.9&lt;span&gt;]]))
[[&lt;/span&gt;0.66666667 0.33333333]]
&lt;/pre&gt;&lt;/div&gt;

&lt;hr/&gt;&lt;p&gt;到了这里,是不是觉得大功告成了呢？等等,还有问题...........&lt;/p&gt;
&lt;p&gt;思考下这个场景：（一时间没有想出特别合适的例子,凑合看吧）&lt;/p&gt;
&lt;p&gt;我们根据头发长度和指甲长度去判断一个人是男是女&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/583030/201812/583030-20181225224009283-234508646.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;发现什么问题没有,两列数据的量级不在一个尺度上.所以在我们计算距离时,指甲长度的影响几乎可以忽略不计了.这显然不是我们想要的结果.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里就引入了一个话题：数据的归一化.  数据归一化将所有的数据映射到同一尺度.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最值归一化&lt;/strong&gt;，既用下面的公式把所有数据映射到0-1之间：&lt;/p&gt;
&lt;p&gt;$$x_{scale} = \frac {x - x_{min}} {x_{max} - x_{min}}$$&lt;/p&gt;
&lt;p&gt;最值归一化虽然简便，但是是有一定适用范围的，那就是适用于样本数据有明显分布边界的情况，并且最值归一化太容易受异常样本点的影响了,实际并不常用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;均值方差归一化&lt;/strong&gt;，该方法就是把所有数据归一到均值为0方差为1的分布中，公式如下：&lt;/p&gt;
&lt;p&gt;$$x_{scale} = \frac {x - x_{mean}} S$$&lt;/p&gt;
&lt;p&gt;就是将每个值减去均值，然后除以方差，通过均值方差归一化后的数据不一定在0-1之间，但是他们的均值为0，方差为1。&lt;/p&gt;
&lt;p&gt;关于两种归一化的适用场景,优缺点等请戳&lt;a href=&quot;https://www.jianshu.com/p/540d56ef350f&quot; target=&quot;_blank&quot;&gt;这里.&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;至此,KNN使用时需要注意的一些点也就写的差不多了,希望对大家有所启发.&lt;/p&gt;
</description>
<pubDate>Tue, 25 Dec 2018 15:35:00 +0000</pubDate>
<dc:creator>sdu20112013</dc:creator>
<og:description>这篇其实应该作为机器学习的第一篇笔记的,但是在刚开始学习的时候,我还没有用博客记录笔记的打算.所以也就想到哪写到哪了. 你在网上搜索机器学习系列文章的话,大部分都是以KNN（k nearest nei</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sdu20112013/p/10171425.html</dc:identifier>
</item>
<item>
<title>Vuex入门 - 格子熊</title>
<link>http://www.cnblogs.com/karthuslorin/p/10169651.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/karthuslorin/p/10169651.html</guid>
<description>&lt;p&gt;在 &lt;code&gt;vue&lt;/code&gt; 开发中，组件通信一直是一大痛点。&lt;/p&gt;
&lt;p&gt;当项目是很简单的 &lt;code&gt;SPA&lt;/code&gt; 或者多入口项目时，可以靠着 &lt;code&gt;vue&lt;/code&gt; 自带的 &lt;code&gt;prop/$emit&lt;/code&gt; 进行组件通信；规模再大一些，可以搭配使用 &lt;code&gt;bus&lt;/code&gt; 总线进行兄弟组件通信；项目再大一些，出现更复杂的组件关系时，复杂的组件通信可以让你写得怀疑人生。&lt;/p&gt;
&lt;p&gt;万幸的是， &lt;code&gt;vue&lt;/code&gt; 官方出品了 &lt;code&gt;vuex&lt;/code&gt; ，通过全局式的状态管理，解决了这一痛点。&lt;/p&gt;
&lt;p&gt;虽然 &lt;code&gt;vuex&lt;/code&gt; 很好用，但是，很多小伙伴和我吐槽 &lt;code&gt;vuex&lt;/code&gt; 的文档和 &lt;code&gt;vue-ssr&lt;/code&gt; 的文档一样，让人看得一脸懵逼。&lt;/p&gt;
&lt;p&gt;好吧，下面就让我来带着大家一起入门 &lt;code&gt;vuex&lt;/code&gt; 。&lt;/p&gt;
&lt;h3 id=&quot;安装并引入&quot;&gt;安装并引入&lt;/h3&gt;
&lt;p&gt;正常情况下，我们使用 &lt;code&gt;vue-cli3&lt;/code&gt; 生成项目时，可以选择集成 &lt;code&gt;vuex&lt;/code&gt; 到项目中。此时， &lt;code&gt;vue-cli3&lt;/code&gt; 会自动安装 &lt;code&gt;vuex&lt;/code&gt; ，并在 &lt;code&gt;src&lt;/code&gt; 文件夹下生成 &lt;code&gt;store.js&lt;/code&gt; 完成 &lt;code&gt;vuex&lt;/code&gt; 的引入和配置。&lt;/p&gt;
&lt;p&gt;但是，很多同学并没有使用 &lt;code&gt;vue-cli3&lt;/code&gt; 或者生成项目时没有选择集成 &lt;code&gt;vuex&lt;/code&gt; 。此时，就只能手动安装并引入 &lt;code&gt;vuex&lt;/code&gt; 了。&lt;/p&gt;
&lt;h4 id=&quot;安装&quot;&gt;安装&lt;/h4&gt;
&lt;p&gt;由于 &lt;code&gt;vuex&lt;/code&gt; 是用于全局状态管理的，所以，它不仅仅作用于开发环境，而且还要用于生产环境。&lt;/p&gt;
&lt;p&gt;显而易见，安装 &lt;code&gt;vuex&lt;/code&gt; 应该使用 &lt;code&gt;-S&lt;/code&gt; 即 &lt;code&gt;--save&lt;/code&gt; 命令。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;npm install vuex -S&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;引入&quot;&gt;引入&lt;/h4&gt;
&lt;p&gt;类似于 &lt;code&gt;vue-cli3&lt;/code&gt; 生成的项目，我们在 &lt;code&gt;src&lt;/code&gt; 文件夹下新建 &lt;code&gt;store.js&lt;/code&gt; ，并在其中写入：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// store.js
import Vue from 'vue'
import Vuex from 'vuex'

Vue.use(Vuex)

export default new Vuex.Store({})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后，我们只需要在 &lt;code&gt;vue&lt;/code&gt; 实例中引入 &lt;code&gt;store.js&lt;/code&gt; 中的 &lt;code&gt;Vuex.Store&lt;/code&gt; 实例即可：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// main.js
import Vue from 'vue'
import App from './App.vue'
import router from './router'
import store from './store'

Vue.config.productionTip = false

new Vue({
  router,
  // 引入store
  store,
  render: h =&amp;gt; h(App)
}).$mount('#app')&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;vuex的使用&quot;&gt;Vuex的使用&lt;/h3&gt;
&lt;p&gt;完成了 &lt;code&gt;vuex&lt;/code&gt; 的安装和引入，接下来我们进入 &lt;code&gt;Vuex&lt;/code&gt; 的使用。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vuex&lt;/code&gt; 中有三要素： &lt;code&gt;state&lt;/code&gt;， &lt;code&gt;mutation&lt;/code&gt; 以及 &lt;code&gt;action&lt;/code&gt; 。它们之间的关系可以用官网那张著名的图来表示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://vuex.vuejs.org/vuex.png&quot; alt=&quot;vuex&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;state&quot;&gt;State&lt;/h4&gt;
&lt;p&gt;简单来说， &lt;code&gt;state&lt;/code&gt; 表示状态，类似于 &lt;code&gt;vue&lt;/code&gt; 中的 &lt;code&gt;data&lt;/code&gt; （其实本质上就是差不多的， &lt;code&gt;vuex&lt;/code&gt; 在 &lt;code&gt;vue&lt;/code&gt; 的 &lt;code&gt;beforeCreate&lt;/code&gt; 钩子中将 &lt;code&gt;state&lt;/code&gt; 混入进 &lt;code&gt;data&lt;/code&gt;）。但是，它们又有很大的不同： 在使用者看来， &lt;code&gt;state&lt;/code&gt; 是全局的，这得益于 &lt;code&gt;vuex&lt;/code&gt; 的设计理念——单一状态树。这些我将在后几篇文章中详细，现在我们只需要知道 &lt;code&gt;state&lt;/code&gt; 是类似于全局下的 &lt;code&gt;data&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;接下来我们通过一个简单例子来感受下 &lt;code&gt;state&lt;/code&gt; ：&lt;/p&gt;
&lt;p&gt;首先，我们需要修改 &lt;code&gt;store.js&lt;/code&gt; 文件，配置 &lt;code&gt;state&lt;/code&gt; 。可以看到，我们在生成 &lt;code&gt;Vuex.Store&lt;/code&gt; 实例时传入了实例化选项对象，对象包含一个 &lt;code&gt;state&lt;/code&gt; 属性， &lt;code&gt;state&lt;/code&gt; 对象的属性就是我们定义的全局状态。&lt;/p&gt;
&lt;p&gt;此时，我们定义了一个全局状态——&lt;code&gt;count&lt;/code&gt; ，并将其的初始值设为&lt;code&gt;1&lt;/code&gt; 。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// store.js
import Vue from 'vue'
import Vuex from 'vuex'

Vue.use(Vuex)

export default new Vuex.Store({
  // 添加state
  state: {
    count: 1
  }
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来，我们需要在组件中引用 &lt;code&gt;count&lt;/code&gt;，由于它是全局状态，我们可以在任何一个组件中使用。为了展示其威力，我们在两个不同的组件中使用它。&lt;/p&gt;
&lt;p&gt;首先我们在 &lt;code&gt;App.vue&lt;/code&gt; 中使用它：&lt;/p&gt;
&lt;p&gt;在模板中，我们使用 &lt;code&gt;$store.state.count&lt;/code&gt; 引入该全局状态，没错，使用它就是那么简单，只需要 以 &lt;code&gt;$store.state.key&lt;/code&gt; 的形式调用。&lt;/p&gt;
&lt;pre class=&quot;vue&quot;&gt;
&lt;code&gt;// App.vue
&amp;lt;template&amp;gt;
  &amp;lt;div id=&quot;app&quot;&amp;gt;
    &amp;lt;div id=&quot;nav&quot;&amp;gt;
      {{$store.state.count}}
      &amp;lt;router-link to=&quot;/&quot;&amp;gt;Home&amp;lt;/router-link&amp;gt; |
      &amp;lt;router-link to=&quot;/about&quot;&amp;gt;About&amp;lt;/router-link&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;router-view/&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以发现， &lt;code&gt;Home&lt;/code&gt; 前多出了一个 &lt;code&gt;1&lt;/code&gt; ，这代表着我们成功引入了全局状态 &lt;code&gt;count&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;接下来我们在 &lt;code&gt;Home.vue&lt;/code&gt; 的子组件 &lt;code&gt;HelloWorld.vue&lt;/code&gt; 中引入 &lt;code&gt;count&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;相同的引用方式： &lt;code&gt;$store.state.count&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;vue&quot;&gt;
&lt;code&gt;// HelloWorld.vue
&amp;lt;template&amp;gt;
  &amp;lt;div class=&quot;hello&quot;&amp;gt;
    {{$store.state.count}}
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以发现，页面中又多出了一个 &lt;code&gt;1&lt;/code&gt; ，代表着我们又一次引用成功。现在，是不是已经感受到了 &lt;code&gt;vuex&lt;/code&gt; 的威力？&lt;/p&gt;
&lt;h4 id=&quot;mutation&quot;&gt;Mutation&lt;/h4&gt;
&lt;p&gt;但是，上面的示例有个问题，那就是全局状态是静态的。如果在实际应用场景中，一般来说，会经常更改状态。&lt;/p&gt;
&lt;p&gt;有的同学会说，我们直接在方法中修改 &lt;code&gt;this.$store.state.key&lt;/code&gt; 的值不就行了吗？&lt;/p&gt;
&lt;p&gt;不好意思，当然是不行的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;state&lt;/code&gt; 和 &lt;code&gt;data&lt;/code&gt; 的另一大区别在于，你不能直接改变 &lt;code&gt;state&lt;/code&gt; 。改变 store 中的状态的唯一途径就是显式地提交 (&lt;code&gt;commit&lt;/code&gt;) &lt;code&gt;mutation&lt;/code&gt;。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。&lt;/p&gt;
&lt;p&gt;简而言之，我们把 &lt;code&gt;mutation&lt;/code&gt; 当做接收 &lt;code&gt;state&lt;/code&gt; 作为参数并修改 &lt;code&gt;state&lt;/code&gt; 的自定义事件即可，上一段所说的 &lt;code&gt;commit&lt;/code&gt; 就是触发 &lt;code&gt;mutaion&lt;/code&gt; 这个自定义事件的方法。&lt;/p&gt;
&lt;p&gt;光说不练假把式，接下来，我们对为 &lt;code&gt;vuex&lt;/code&gt; 添加上 &lt;code&gt;mutation&lt;/code&gt; ，实现 &lt;code&gt;state&lt;/code&gt; 的动态改变：&lt;/p&gt;
&lt;p&gt;首先，当然是修改生成 &lt;code&gt;Vuex.Store&lt;/code&gt; 示例的选项对象，为其添加 &lt;code&gt;mutations&lt;/code&gt; 。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;import Vue from 'vue'
import Vuex from 'vuex'

Vue.use(Vuex)

export default new Vuex.Store({
  state: {
    count: 1
  },
  // 添加mutation
  mutations: {
    increment (state) {
      state.count++
    }
  }
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上面的代码中，我们添加了一个名为 &lt;code&gt;increment&lt;/code&gt; 的 &lt;code&gt;mutation&lt;/code&gt; 。完成了自定义事件，接下来，我们只需要在组件中对 &lt;code&gt;mutation&lt;/code&gt; 进行触发即可。&lt;/p&gt;
&lt;p&gt;我们在 &lt;code&gt;HelloWorld.vue&lt;/code&gt; 添加一个按钮，每次点击触发一次 &lt;code&gt;increment&lt;/code&gt; 这个 &lt;code&gt;mutation&lt;/code&gt; 。可以发现，触发方式很简单，只需要调用 &lt;code&gt;store&lt;/code&gt; 自带的 &lt;code&gt;commit&lt;/code&gt; 方法，其中参数为需要触发的 &lt;code&gt;mutation&lt;/code&gt; 的名称。&lt;/p&gt;
&lt;pre class=&quot;vue&quot;&gt;
&lt;code&gt;// HelloWorld.vue
&amp;lt;template&amp;gt;
  &amp;lt;div class=&quot;hello&quot;&amp;gt;
    &amp;lt;div&amp;gt;{{$store.state.count}}&amp;lt;/div&amp;gt;
    &amp;lt;button @click=&quot;$store.commit('increment')&quot;&amp;gt;修改count&amp;lt;/button&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;点击页面中的按钮，你会发现，页面中的两个 &lt;code&gt;count&lt;/code&gt; 都同时增加了1，说明我们成功实现了 &lt;code&gt;state&lt;/code&gt; 的动态修改。&lt;/p&gt;
&lt;h4 id=&quot;action&quot;&gt;Action&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;action&lt;/code&gt; 类似于 &lt;code&gt;mutation&lt;/code&gt; ，也相当于一种自定义事件。只不过， &lt;code&gt;action&lt;/code&gt; 操作的是 &lt;code&gt;mutation&lt;/code&gt; 而不是 &lt;code&gt;state&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;添加 &lt;code&gt;action&lt;/code&gt; 的方法类似，在选项对象中新增 &lt;code&gt;action&lt;/code&gt; 属性即可。与 &lt;code&gt;mutation&lt;/code&gt; 的参数不同， &lt;code&gt;action&lt;/code&gt; 的参数就是当前创建的 &lt;code&gt;Vue.store&lt;/code&gt; 对象实例的上下文，一般将其命名为 &lt;code&gt;context&lt;/code&gt; 。我们需要使用其自带的 &lt;code&gt;commit&lt;/code&gt; 方法来触发 &lt;code&gt;mutation&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;下面我通过实际的例子来尝试下 &lt;code&gt;action&lt;/code&gt; ：&lt;/p&gt;
&lt;p&gt;首先，修改选项对象，使得新添加的 &lt;code&gt;action&lt;/code&gt; 可以触发之前的 &lt;code&gt;mutation&lt;/code&gt; ：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// store.js
import Vue from 'vue'
import Vuex from 'vuex'

Vue.use(Vuex)

export default new Vuex.Store({
  state: {
    count: 1
  },
  mutations: {
    increment (state) {
      state.count++
    }
  },
  actions: {
    increment ({ commit }) {
      commit('increment')
    }
  }
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于我们一般来说仅仅需要 &lt;code&gt;context&lt;/code&gt; 中的 &lt;code&gt;commit&lt;/code&gt; 方法，所以可以采用解构的方式，直接调用 &lt;code&gt;commit&lt;/code&gt; 方法，而不需要以 &lt;code&gt;context.commit&lt;/code&gt; 的方式使用它。&lt;/p&gt;
&lt;p&gt;接下来，只需要修改 &lt;code&gt;HelloWorld.vue&lt;/code&gt; ，使其能够在点击按钮时触发即可。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;action&lt;/code&gt; 的触发方式和 &lt;code&gt;mutation&lt;/code&gt; 类似，只不过调用的方法是 &lt;code&gt;dispatch&lt;/code&gt; 。&lt;/p&gt;
&lt;pre class=&quot;vue&quot;&gt;
&lt;code&gt;// HelloWorld.vue
&amp;lt;template&amp;gt;
  &amp;lt;div class=&quot;hello&quot;&amp;gt;
    &amp;lt;div&amp;gt;{{$store.state.count}}&amp;lt;/div&amp;gt;
    &amp;lt;button @click=&quot;$store.dispatch('increment')&quot;&amp;gt;修改count&amp;lt;/button&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;点击页面按钮，你会发现，实现了和之前相同的效果。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;学会了 &lt;code&gt;vuex&lt;/code&gt; 三贱客： &lt;code&gt;state&lt;/code&gt; ， &lt;code&gt;mutation&lt;/code&gt; ， &lt;code&gt;action&lt;/code&gt; ，我们再回过头看看前面的那张关系图，此时应该很容易理解了吧？&lt;/p&gt;
&lt;p&gt;组件交互触发 &lt;code&gt;action&lt;/code&gt; ， 在 &lt;code&gt;action&lt;/code&gt; 中进行异步操作（可选）并触发 &lt;code&gt;mutation&lt;/code&gt; ， &lt;code&gt;mutation&lt;/code&gt; 控制 &lt;code&gt;state&lt;/code&gt; 的变动， &lt;code&gt;state&lt;/code&gt; 修改之后，触发响应式，重新渲染组件。&lt;/p&gt;
&lt;h3 id=&quot;彩蛋&quot;&gt;彩蛋&lt;/h3&gt;
&lt;p&gt;在官方文档中，提到需要将异步操作放入 &lt;code&gt;action&lt;/code&gt; 中，而不能放在 &lt;code&gt;mutation&lt;/code&gt; 中。实际上，在 &lt;code&gt;mutation&lt;/code&gt; 中也可以进行异步操作，而且也不会导致什么奇怪的事情。&lt;/p&gt;
&lt;p&gt;但是，既然官方文档中这么说了，我们在实际开发中，一般还是老老实实地将所有异步操作放在 &lt;code&gt;action&lt;/code&gt; 中。（猥琐保平安 -_-）&lt;/p&gt;
&lt;p&gt;另外，说了这么多，其实在一些项目中，可以使用 &lt;code&gt;provide/inject&lt;/code&gt; 代替 &lt;code&gt;vuex&lt;/code&gt; 。具体的用法在此不再赘述，就当一个课后作业吧。&lt;/p&gt;
&lt;p&gt;在项目中灵活使用 &lt;code&gt;provide/inject&lt;/code&gt; ，有时可以起到出乎意料的作用哦。&lt;/p&gt;
&lt;h3 id=&quot;最后的最后&quot;&gt;最后的最后&lt;/h3&gt;
&lt;p&gt;篇幅有限，所以该篇文章只讲述了 &lt;code&gt;vuex&lt;/code&gt; 三贱客的基本用法，其他的进阶用法，如： &lt;code&gt;getter&lt;/code&gt; ， &lt;code&gt;module&lt;/code&gt; ， 简写以及 &lt;code&gt;vuex&lt;/code&gt; 项目结构优化，甚至 &lt;code&gt;vuex&lt;/code&gt; 源码解析将会在之后的文章一一讲解。&lt;/p&gt;
&lt;p&gt;如果您觉得这片文章不错的话，不如给我的 &lt;a href=&quot;https://github.com/KarthusLorin/vue-ebook&quot;&gt;gayhub&lt;/a&gt; 点个star再走呗。&lt;/p&gt;
&lt;p&gt;这个项目个人认为对很多新手在实际开发中使用 &lt;code&gt;vuex&lt;/code&gt; 还是很有启发和帮助的（手动狗头）。&lt;/p&gt;
&lt;p&gt;欢迎交流，谢谢~&lt;/p&gt;
</description>
<pubDate>Tue, 25 Dec 2018 15:31:00 +0000</pubDate>
<dc:creator>格子熊</dc:creator>
<og:description>在 开发中，组件通信一直是一大痛点。 当项目是很简单的 或者多入口项目时，可以靠着 自带的 进行组件通信；规模再大一些，可以搭配使用 总线进行兄弟组件通信；项目再大一些，出现更复杂的组件关系时，复杂的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/karthuslorin/p/10169651.html</dc:identifier>
</item>
<item>
<title>高中生的IT之路-自序 - 阿正-WEB</title>
<link>http://www.cnblogs.com/azheng007/p/10176892.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/azheng007/p/10176892.html</guid>
<description>&lt;p&gt;    近几年来越来越多的人问我关于 高中生要不要读大学、大学选择专业、毕业后的择业问题，索性我不如把我对这几方面的理解写出来，如果有幸能帮助到更多的人，那也算是个人对社会做出了一点贡献。&lt;/p&gt;

&lt;p&gt;    我高中毕业后并没有进入大学，而是直接进入到社会工作。刚进入社会的时候去餐厅当过服务员，后来又在朋友的帮助下进到一家IT公司进行实习生培训，再后来就正式进入到软件工程师的行业，从刚开始的门外汉通过自学 从实习生成为工程师、高级工程师、项目经理、技术经理，到现在在一家互联网公司任职技术经理的职位并且自己在经营一家餐饮公司。&lt;/p&gt;

&lt;p&gt;    从业九年以来，从工程师小白到技术经理，积累了一些学习心得和学习方法，后续会继续分享给大家；在整个晋升过程中也在反思当年选择不去读大学的得与失，总结来看，包括现在对那些咨询到我的人，我还是建议他们要读大学，其中缘由会在后续继续和大家沟通；在整个个人发展过程中除了发现专业技能的重要性，比如对编程领域的知识掌握，也逐渐的更加重视一个人在 高度、耐心、做人、沟通、协调、自律、时间、策略 等各个方面的对个人发展的重要性，后续也会继续和大家一起分享；以及关于个人发展以及理财等方面也被颠覆了很多观念，从小学校和社会传输给我们的许多观念也在个人发展过程中逐渐的被颠覆。其实我总结来看，进入社会的成长其实就是一个不断颠覆这个社会和学校从小就灌输给我们大脑里的那些根深蒂固的观念。&lt;/p&gt;

&lt;p&gt;    接下来，我会连载《高中生的IT之路》系列文章，把我的一些 个人经历、学习方法和心得、职场发展、个人发展等通过这个系列文章和大家一起来沟通，一起成长。&lt;/p&gt;
</description>
<pubDate>Tue, 25 Dec 2018 14:48:00 +0000</pubDate>
<dc:creator>阿正-WEB</dc:creator>
<og:description>近几年来越来越多的人问我关于 高中生要不要读大学、大学选择专业、毕业后的择业问题，索性我不如把我对这几方面的理解写出来，如果有幸能帮助到更多的人，那也算是个人对社会做出了一点贡献。 我高中毕业后并没有</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/azheng007/p/10176892.html</dc:identifier>
</item>
<item>
<title>FreeCodeCamp 题目 Profile lookup 思考 - 墨狐</title>
<link>http://www.cnblogs.com/kaluosifa/p/10176871.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kaluosifa/p/10176871.html</guid>
<description>&lt;p&gt;原题目链接：&lt;a href=&quot;https://freecodecamp.cn/challenges/profile-lookup#&quot; data-cke-saved-href=&quot;https://freecodecamp.cn/challenges/profile-lookup#&quot;&gt;https://freecodecamp.cn/challenges/profile-lookup#&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;题目&lt;/strong&gt;：&lt;/h2&gt;
&lt;p&gt;&lt;br/&gt;    我们有一个对象数组，里面存储着通讯录。 函数 lookUp 有两个预定义参数：firstName值和prop属性 。函数将会检查通讯录中是否存在一个与传入的firstName相同的联系人。 如果存在，那么还需要检查对应的联系人中是否存在 prop属性。如果它们都存在，函数返回prop属性对应的值。如果firstName 值不存在，返回 &quot;No such contact&quot;。 如果prop 属性不存在，返回 &quot;No such property&quot;。&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;个人思路&lt;/strong&gt;：&lt;/h2&gt;
&lt;p&gt;&lt;br/&gt;    循环判断有与参数 firstName值 匹配的联系人；&lt;br/&gt;        如果存在，那么继续判断是否存在参数 prop 匹配的属性；&lt;br/&gt;            如果存在，就返回该属性的值，并结束循环。&lt;br/&gt;            如果不存在，就返回&quot;No such property&quot;，并结束循环。&lt;br/&gt;    当循环到最后一个联系人却还没有匹配到时，就返回&quot;No such contact&quot;，此时循环顺势结束了。 &lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;数据测试&lt;/strong&gt;：&lt;/h2&gt;
&lt;p&gt;&lt;br/&gt;    &quot;Kristian&quot;, &quot;lastName&quot; 应该返回 &quot;Vos&quot;&lt;br/&gt;    &quot;Sherlock&quot;, &quot;likes&quot; 应该返回 [&quot;Intriguing Cases&quot;, &quot;Violin&quot;]&lt;br/&gt;    &quot;Harry&quot;,&quot;likes&quot; 应该返回一个数组&lt;br/&gt;    &quot;Bob&quot;, &quot;number&quot; 应该返回 &quot;No such contact&quot;&lt;br/&gt;    &quot;Akira&quot;, &quot;address&quot; 应该返回 &quot;No such property&quot;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;代码段&lt;/strong&gt;：&lt;em&gt;（复制到控制台即可看结果，修改最后一行的参数完成测试。）&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;如果有更好的思路，欢迎评论一起讨论！&lt;/p&gt;
</description>
<pubDate>Tue, 25 Dec 2018 14:42:00 +0000</pubDate>
<dc:creator>墨狐</dc:creator>
<og:description>原题目链接：https://freecodecamp.cn/challenges/profile-lookup# 题目： 我们有一个对象数组，里面存储着通讯录。 函数 lookUp 有两个预</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kaluosifa/p/10176871.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core 实战：构建带有版本控制的 API 接口 - 墨墨墨墨小宇</title>
<link>http://www.cnblogs.com/danvic712/p/10176823.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/danvic712/p/10176823.html</guid>
<description>&lt;h3&gt;&lt;strong&gt; 一、前言&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt; 　　在上一篇的文章中，主要是搭建了我们的开发环境，同时创建了我们的项目模板框架。在整个前后端分离的项目中，后端的 API 接口至关重要，它是前端与后端之间进行沟通的媒介，如何构建一个 “好用” 的 API 接口，是需要我们后端人员好好思考的。&lt;br/&gt;　　在系统迭代的整个过程中，不可避免的会添加新的资源，或是修改现有的资源，后端接口作为暴露给外界的服务，变动的越小，对服务的使用方造成的印象就越小，因此，如何对我们的 API 接口进行合适的版本控制，我们势必需要首先考虑。&lt;/p&gt;
&lt;p&gt;　　系列目录地址：&lt;a title=&quot;ASP.NET Core 项目实战&quot; href=&quot;https://www.cnblogs.com/danvic712/p/10124831.html&quot;&gt;ASP.NET Core 项目实战&lt;/a&gt;&lt;br/&gt;　　仓储地址：&lt;a title=&quot;https://github.com/Lanesra712/Grapefruit.VuCore&quot; href=&quot;https://github.com/Lanesra712/Grapefruit.VuCore&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;https://github.com/Lanesra712/Grapefruit.VuCore&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt; 二、Step by Step&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　项目总是在不断迭代的，某些时候，因为业务发展的需要，需要将现有的接口进行升级，而原有的接口却不能立刻停止使用。比如说，你开发了一个接口提供给爱啪啪 1.0 版本使用，后来爱啪啪的版本迭代了，需要接口返回的数据与原先 1.0 版本返回的数据不同了，这时候，接口肯定是需要升级的，可是如果直接升级原有的接口，还在使用 1.0 版本的用户不就 GG 了，因此，如何做到既可以让 1.0 版本的用户使用，也可以让 2.0 版本的用户使用就需要好好考虑了，常见的解决方案，主要有以下几种。&lt;/p&gt;
&lt;p&gt;　　a）使用不同的 API 名称&lt;/p&gt;
&lt;p&gt;　　最简单粗暴，需要变更接口逻辑时就重新起个 API 名称，新的版本调用新的 API 名称，旧的版本调用旧的 API 名称。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;https://yuiter.com/api/Secret/Login ##爱啪啪 1.0
https://yuiter.com/api/Secret/NewLogin ##爱啪啪 2.0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　b）在 Url 中标明版本号&lt;/p&gt;
&lt;p&gt;　　直接将 API 版本信息添加到请求的 Url 中，调用不同版本的 API ，就在 URL 中直接标明使用的是哪个版本。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;https://yuiter.com/api/v1/Secret/Login ##爱啪啪 1.0
https://yuiter.com/api/v2/Secret/Login ##爱啪啪 2.0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　c）请求参数中添加版本信息&lt;/p&gt;
&lt;p&gt;　　将 API 的版本信息作为请求的一个参数传递，通过指定参数值来确定请求的 API 版本。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;https://yuiter.com/api/Secret/Login?version=1 ##爱啪啪 1.0
https://yuiter.com/api/Secret/Login?version=2 ##爱啪啪 2.0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　d）在 header 中标明版本号&lt;/p&gt;
&lt;p&gt;　　前端在请求 API 接口时，在 header 中添加一个参数用来表明请求的版本信息，后端通过前端在 header 中设置的参数来判断，从而执行不同的业务逻辑分支。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;POST https://yuiter.com/api/Secret/Login
Host: yuiter.com  
api-version: v1   ##爱啪啪 1.0

POST https://yuiter.com/api/Secret/Login
Host: yuiter.com  
api-version: v2   ##爱啪啪 2.0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在 Grapefruit.VuCore 这个项目中，我选择将 API 的版本信息添加到请求的地址中，从而明确的指出当前请求的接口版本信息。&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;　　1、Swagger 集成&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;后端完成了接口之后，肯定需要告诉前端，不管是整理成 txt/excel/markdown 文档，亦或是写完一个接口就直接发微信告诉前端，总是要多做一步的事情，而 Swagger 则可以帮我们省去这一步。通过配置之后，Swagger 就可以根据我们的接口自动生成 API 的接口文档，省时，省力。&lt;span&gt;当然，如果前端小姐姐单身可撩，而你碰巧有意的话，另谈。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　Swagger 是一个可以将接口文档自动生成，同时可以对接口功能进行测试的开源框架，在 ASP.NET Core 环境下，主流的有 Swashbuckle.AspNetCore 和 NSwag 这两个开源框架帮助我们生成 Swagger documents。这里，我采用的是 &lt;a title=&quot;Swashbuckle.AspNetCore&quot; href=&quot;https://github.com/domaindrivendev/Swashbuckle.AspNetCore&quot; target=&quot;_blank&quot;&gt;Swashbuckle.AspNetCore&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;　　在使用 Swashbuckle.AspNetCore 之前，首先我们需要在 API(Grapefruit.WebApi) 项目中添加对于 Swashbuckle.AspNetCore 的引用。你可以直接右键选中 API 项目选择管理 Nuget 程序包进行加载引用，也可以通过程序包管理控制台进行添加引用，这里注意，使用程序包管理控制台时，你需要将默认的项目修改成 API(Grapefruit.WebApi) 项目。当引用添加完成后，我们就可以在项目中配置 Swagger 了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1310859/201812/1310859-20181225221555692-1341993265.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Install-Package Swashbuckle.AspNetCore
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1310859/201812/1310859-20181225221625202-216407620.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　ASP.NET Core 的本质上可以看成是一个控制台程序，在我们创建好的 ASP.NET Core Web API 项目中，存在着两个类文件：Program.cs 以及 Startup.cs。与控制台应用一样，Program 类中的 Main 方法是整个程序的入口，在这个方法中，我们将配置好的 IWebHostBuilder 对象，构建成 IWebHost 对象，并运行该 IWebHost 对象从而达到运行 Web 项目的作用。&lt;/p&gt;
&lt;p&gt;　　在框架生成的 Program 类文件中，在配置 IWebHostBuilder 的过程时，框架默认为我们添加了一些服务，当然，这里你可以注释掉默认的写法，去自己创建一个 WebHostBuilder 对象。同时，对于一个 ASP.NET Core 程序来说，Startup 类是必须的（你可以删除生成的 Startup 类，重新创建一个新的类，但是，这个新创建的类必须包含 Configure 方法，之后只需要在 UseStartup&amp;lt;Startup&amp;gt; 中将该类配置为 Startup 类即可），这里如果不指定 Startup 类会导致启动失败。&lt;/p&gt;
&lt;p&gt;　　在 Startup 类中，存在着 ConfigureServices 和 Configure 这两个方法，在 ConfigureServices 方法中，我们将自定义服务通过依赖注入的方式添加到 IServiceCollection 容器中，而这些容器中的服务，最终都可以在 Configure 方法中进行使用；而 Configure 方法则用于指定 ASP.NET Core 应用程序将如何响应每一个 HTTP 请求，我们可以在这里将我们自己创建的中间件（Middleware）绑定到 IApplicationBuilder 上，从而添加到 HTTP 请求管道中。&lt;/p&gt;
&lt;p&gt;　　这里只是很粗略的说明了 ASP.NET Core 项目的启动过程，想要仔细了解启动过程的推荐园子里的这篇文章 =》&lt;a title=&quot;ASP.NET Core 2.0 : 七.一张图看透启动背后的秘密&quot; href=&quot;https://www.cnblogs.com/FlyLolo/p/ASPNETCore2_7.html&quot; target=&quot;_blank&quot;&gt;ASP.NET Core 2.0 : 七.一张图看透启动背后的秘密&lt;/a&gt;，因为 ASP.NET Core 2.1 版本相比于 2.0 版本又有些改变，这里有一些不一样的地方需要你去注意。&lt;/p&gt;
&lt;p&gt;　　当我们简单了解了启动过程后，就可以配置我们的 Swagger 了。Swashbuckle.AspNetCore 帮我们构建好了使用 Swagger 的中间件，我们只需要直接使用即可。&lt;/p&gt;
&lt;p&gt;　　首先我们需要在 ConfigureServices 方法中，将我们的服务添加到 IServiceCollection 容器中，这里，我们需要为生成的 Swagger Document 进行一些配置。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
services.AddSwaggerGen(s =&amp;gt;&lt;span&gt;
{
    s.SwaggerDoc(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;v1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Info
    {
        Contact &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Contact
        {
            Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Danvic Wang&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            Email &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;danvic96@hotmail.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            Url &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://yuiter.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        },
        Description &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A front-background project build by ASP.NET Core 2.1 and Vue&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        Title &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Grapefruit.VuCore&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        Version &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;v1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    });
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　之后，我们就可以在 Configure 方法中启用我们的 Swagger 中间件。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;app.UseSwagger();
app.UseSwaggerUI(s &lt;/span&gt;=&amp;gt;&lt;span&gt;
{
    s.SwaggerEndpoint(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/swagger/v1/swagger.json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Grapefruit.VuCore API V1.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　此时，当你运行程序，在域名后面输入/swagger 即可访问到我们的 API 文档页面。因为项目启动时默认访问的是我们 api/values 的 GET 请求接口，这里我们可以打开 Properties 下的 launchSetting.json 文件去配置我们的程序默认打开页面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1310859/201812/1310859-20181225221909953-697366673.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　从上面的图可以看出，不管是使用 IIS 或是程序自托管，我们默认打开的 Url 都是 api/values，这里我们将两种启动方式的 launchUrl 值都修改成 swagger 之后再次运行我们的项目，可以发现，程序默认的打开页面就会变成我们的 API 文档页面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1310859/201812/1310859-20181225221929552-1700007097.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　我们使用 API 文档的目的，就是为了让前端知道请求的方法地址是什么，需要传递什么参数，而现在，并没有办法显示出我们对于参数以及方法的注释，通过查看 Swashbuckle.AspNetCore 的 github 首页可以看到，我们可以通过配置，将生成的 json 文件中包含我们对于 Controller or Action 的 Xml 注释内容，从而达到显示注释信息的功能（最终呈现的 Swagger Doc 是根据之前我们定义的这个 “/swagger/v1/swagger.json” json 文件来生成的）。&lt;/p&gt;
&lt;p&gt;　　右键我们的 API 项目，属性 =》生产，勾选上 XML 文档文件，系统会默认帮我们创建生成 XML 文件的地址，这时候，我们重新生成项目，则会发现，当前项目下会多出这个 XML 文件。在重新生成项目的过程中，你会发现，错误列表会显示很多警告信息，提示我们一些方法没有添加 XML 注释。如果你和我一样强迫症的话，可以把 1591 这个错误添加到上面的禁止显示警告中，这样就可以不再显示这个警告了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1310859/201812/1310859-20181225221956658-1986003811.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　创建好 XML 的注释文件后，我们就可以配置我们的 Swagger 文档，从而达到显示注释的功能。这里，因为我会在 Grapefruit.Application 类库中创建各种的 Dto 对象，而接口中是会调用到这些 Dto 对象的。因此，为了显示这些 Dto 上的注释信息，这里我们也需要生成 Grapefruit.Application 项目的 XML 注释文件。&lt;/p&gt;
&lt;p&gt;　　PS：这里我是将每个项目生成的注释信息 xml 文档地址都放在了程序的基础路径下，如果你将 xml 文档生成在别的位置，这里获取 xml 的方法就需要你进行修改。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
services.AddSwaggerGen(s =&amp;gt;&lt;span&gt;
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;...

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Add comments description
    &lt;/span&gt;&lt;span&gt;//
&lt;/span&gt;    &lt;span&gt;var&lt;/span&gt; basePath = Path.GetDirectoryName(AppContext.BaseDirectory);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;get application located directory&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; apiPath = Path.Combine(basePath, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Grapefruit.WebApi.xml&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; dtoPath = Path.Combine(basePath, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Grapefruit.Application.xml&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    s.IncludeXmlComments(apiPath, &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
    s.IncludeXmlComments(dtoPath, &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1310859/201812/1310859-20181225222136421-627796562.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　当我们把 Swagger 配置完成之后，我们就可以创建具有版本控制的 API 接口了。&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;　　2、带有版本控制的 API 接口实现&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;　　在请求的 API Url 中标明版本号，我不知道你第一时间看到这个实现方式，会想到什么，对于我来说，直接在路由信息中添加版本号不就可以了。。。em，这样过于投机取巧了。。。。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[Route(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api/v1/[controller]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)]&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加版本信息为v1&lt;/span&gt;
&lt;span&gt;[ApiController]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ValuesController : ControllerBase
{
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　想了想，在 Url 中添加版本号，这个版本号是不是很像我们在 MVC 中使用的 Area。&lt;/p&gt;
&lt;p&gt;　　Area 是 MVC 中经常使用到的一个功能，我们通常会将某些小的模块拆分成一个个的 Area，而这一个个的小 Area 其实就是这个 MVC 项目中的 MVC。通过为 controller 和 action 添加另一个路由参数 area，从而达到创建具有层次路由的结构。比如，这里，我们可以创建一个 Area 叫 v1，用来存储我们 1.x 版本的 API 接口，之后如果有新的 API 版本，新增一个 Area 即可，是不是很简单，嗯，说干就干。&lt;/p&gt;
&lt;p&gt;　　右击我们的 API 项目，选择添加区域，新增的 Area 名称为 v1。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1310859/201812/1310859-20181225222255778-10300864.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　当 ASP.NET Core 的脚手架程序添加完成 Area 后，则会打开一个文件提示我们需要在 MVC 中间件中创建适用于 Area 的路由定义。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
app.UseMvc(routes =&amp;gt;&lt;span&gt;
{
  routes.MapRoute(
    name : &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;areas&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    template : &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{area:exists}/{controller=Home}/{action=Index}/{id?}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  );
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　当我们添加好路由规则定义后，我们在 Area 的 Controllers 文件夹下添加一个 WebAPI Controller。不同于 ASP.NET 中的 Area ，当我们在 ASP.NET Core 创建好一个 Area 之后，脚手架生成的文件中不再有 XXXAreaRegistration（XXX 为 Area 的名称）文件去注册这个 Area，而我们只需要在 Area 中的 Controller 中添加 Area 特性，即可告诉系统框架，这个 Controller 是在当前的 Area 下的。&lt;/p&gt;
&lt;p&gt;　　如果你有自己尝试的话，就会发现，当我们创建好一个 v1 的 Area 后，这个请求的地址并没有按照我们的想法会体现在路由信息中，我们最后还是需要在 Route 中手动指明 API 版本。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[Area(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;v1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
[Route(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api/v1/[controller]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
[ApiController]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ValuesController : ControllerBase
{
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1310859/201812/1310859-20181225222353441-1110080758.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这样的话，和最开始直接在路由信息中写死版本信息其实也就没什么差别了，上网搜了搜，发现巨硬爸爸，也早已为我们准备好了实现版本控制 API 的利器 - Microsoft.AspNetCore.Mvc.Versioning。&lt;/p&gt;
&lt;p&gt;　　和上面使用 Swashbuckle.AspNetCore 的方式相同，在我们使用 Versioning 之前，需要在我们的 API 项目中添加对于该 dll 的引用。这里需要注意下安装的版本问题，因为 Grapefruit.VuCore 这个框架距离现在搭建也有几个月的时间了，在这个月初的时候 .NET Core 2.2 也已经发布了，如果你和我一样还是采用的 .NET Core 2.1 版本的话，这里安装的 Versioning 版本最高只能到 2.3。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Install-Package Microsoft.AspNetCore.Mvc.Versioning
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　当我们安装完成之后，就可以进行配置了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
{
    services.AddApiVersioning(o &lt;/span&gt;=&amp;gt;&lt;span&gt;
    {
        o.ReportApiVersions &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;return versions in a response header&lt;/span&gt;
        o.DefaultApiVersion = &lt;span&gt;new&lt;/span&gt; ApiVersion(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;default version select &lt;/span&gt;
        o.AssumeDefaultVersionWhenUnspecified = &lt;span&gt;true&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;if not specifying an api version,show the default version&lt;/span&gt;
&lt;span&gt;    });
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　ReportApiVersions：这个配置是可选的，当我们设置为 true 时，API 会在响应的 header 中返回版本信息。&lt;/p&gt;
&lt;p&gt;　　DefaultApiVersion：指定在请求中未指明版本时要使用的默认 API 版本。这将默认版本为1.0。&lt;/p&gt;
&lt;p&gt;　　AssumeDefaultVersionWhenUnspecified：这个配置项将用于在没有指明 API 版本的情况下提供请求，默认情况下，会请求默认版本的 API，例如，这里就会请求 1.0 版本的 API。&lt;/p&gt;
&lt;p&gt;　　这里，删除我们之前的创建的 Area 和默认的 ValuesController，在 Controllers 文件夹下新增一个 v1 文件夹，将所有 v1 版本的 Controller 都建在这个目录下。新建一个 Controller，添加上 ApiVersion Attribute 指明当前的版本信息。因为我采用的方案是在 Url 中指明 API 版本，所以，我们还需要在 Route 中修改我们的路由属性以对应 API 的版本。这里的 v 只是一个默认的惯例，你也可以不添加。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[ApiVersion(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
[Route(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api/v{version:apiVersion}/[controller]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
[ApiController]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; VaulesController : ControllerBase
{
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　当我们修改好我们的 Controller 之后，运行我们的项目，你会发现，API 文档中显示的请求地址是不对的，难道是我们的配置没起作用吗？通过 Swagger 自带的 API 测试工具测试下我们的接口，原来这里请求的 Url 中已经包含了我们定义的版本信息，当我们指定错误的版本信息时，工具也会告诉我们这个版本的接口不存在。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1310859/201812/1310859-20181225222558824-840046028.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　虽然我们请求的 Url 中已经带上了版本信息，但是 API 文档上显示的请求地址却是不准确的，强迫症，不能忍。这里，需要我们修改生成 Swagger 文档的配置代码，将路由中的版本信息进行替换。重新运行我们的项目，可以发现，文档显示的 Url 地址也已经正确了，自此，我们创建带有版本控制的 API 也就完成了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
{
    services.AddSwaggerGen(s &lt;/span&gt;=&amp;gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;...

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Show the api version in url address&lt;/span&gt;
        s.DocInclusionPredicate((version, apiDescription) =&amp;gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; values =&lt;span&gt; apiDescription.RelativePath
                .Split(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
                .Select(v &lt;/span&gt;=&amp;gt; v.Replace(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;v{version}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, version));

            apiDescription.RelativePath &lt;/span&gt;= &lt;span&gt;string&lt;/span&gt;.Join(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, values);

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        });
    });
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1310859/201812/1310859-20181225222649692-483012929.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt; 三、总结&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt; 　　本章使用了 Microsoft.AspNetCore.Mvc.Versioning 这一组件来实现我们对于 API 版本控制的功能实现，可能你会有疑问，我们直接在路由中写明版本信息不是更简单吗？在我看来，使用这一组件的目的，在于我们可以以多种的方式实现 API 版本控制的目的，如果哪天你不想在 Url 中指明版本信息后，你可以很快的使用别的形式来完成 API 的版本控制。另外，直接在路由中写上版本信息，是不是会显得我们比较 ‘low’，哈哈哈，开玩笑，最后祝大家圣诞快乐~~~&lt;/p&gt;
</description>
<pubDate>Tue, 25 Dec 2018 14:29:00 +0000</pubDate>
<dc:creator>墨墨墨墨小宇</dc:creator>
<og:description>一、前言 在上一篇的文章中，主要是搭建了我们的开发环境，同时创建了我们的项目模板框架。在整个前后端分离的项目中，后端的 API 接口至关重要，它是前端与后端之间进行沟通的媒介，如何构建一个 “好用”</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/danvic712/p/10176823.html</dc:identifier>
</item>
</channel>
</rss>