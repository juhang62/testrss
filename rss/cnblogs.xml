<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Elastcisearch.Nest 7.x 系列`伪`官方翻译：通过 NEST 来快捷试用 Elasticsearch - DeepThought</title>
<link>http://www.cnblogs.com/deepthought/p/12231714.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/deepthought/p/12231714.html</guid>
<description>&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;p&gt;Elasticsearch.Net 和 NEST 对比说明：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Elasticsearch 官方为 .NET 提供了 2 个官方客户端库：Elasticsearch.Net 和 NEST。&lt;/li&gt;
&lt;li&gt;可以简单理解为 Elasticsearch.Net 是 NEST 的一个子集。&lt;/li&gt;
&lt;li&gt;NEST 内部使用了 ElasticSearch.Net ，并通过 NEST 可以对外暴露 ElasticSearch.Net 客户端。&lt;/li&gt;
&lt;li&gt;但 NEST 包含了 ElasticSearch.Net 所没有的一些高级功能，如：
&lt;ul&gt;&lt;li&gt;强类型查询 DSL：可以将所有请求和响应的对象类型转换 1:1 的.NET 类型。&lt;/li&gt;
&lt;li&gt;自动转换为 CLR 的数据类型。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;基本上 .NET 项目到了要使用上 ElasticSearch 的地步，直接选择 NEST 即可。&lt;/p&gt;
&lt;p&gt;在使用 NEST 作为客户端的时候，建议将 ElasticClient 对象作为单例来使用。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ElasticClient 被设计为线程安全。&lt;/li&gt;
&lt;li&gt;ES 中的缓存是根据 ConnectionSettings 来划分的，即服务端缓存针对的是每一个 ConnectionStrings&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;例外：&lt;/strong&gt; 当你需要连接不同的 ES 集群的时候，就不要用单例了，应为不同的 ElasticClient 使用不同的 ConnectionStrings。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;使用 Nest 的时候约定 Nest 版本需要跟 ElasticSearch 版本保持一致，即服务端 ES版本为 7.3.1，则 Nest 版本也要使用 7.3.1&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;以下示例通过 IoC 进行注入（单例），你也可以直接通过单例模式来实现。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h2 id=&quot;配置连接-elasticsearch&quot;&gt;配置、连接 ElasticSearch&lt;/h2&gt;
&lt;p&gt;配置类：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class ElasticSearchSettings
{
    public string ServerUri { get; set; }
    public string DefaultIndex { get; set; } = &quot;defaultindex&quot;;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ElasticSearch 客户端：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;连接到 ElasticSearch，并设定默认索引&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class ElasticSearchClient : IElasticSearchRepository
{
    private readonly ElasticSearchSettings _esSettings;
    private readonly ElasticClient _client;

    public ElasticSearchClient(IOptions&amp;lt;ElasticSearchSettings&amp;gt; esSettings)
    {
        _esSettings = esSettings.Value;

        var settings = new ConnectionSettings(new Uri(_esSettings.ServerUri)).DefaultIndex(_esSettings.DefaultIndex);
        _client = new ElasticClient(settings);
    }

    public ElasticSearchClient(ElasticSearchSettings esSettings)
    {
        _esSettings = esSettings;
        var settings = new ConnectionSettings(new Uri(_esSettings.ServerUri)).DefaultIndex(_esSettings.DefaultIndex);
        _client = new ElasticClient(settings);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;连接配置上使用密码凭证&quot;&gt;连接配置上使用密码凭证&lt;/h3&gt;
&lt;p&gt;ElasticSearch 可以直接在 Uri 上指定密码，如下：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;    var uri = new Uri(&quot;http://username:password@localhost:9200&quot;)
    var settings = new ConnectionConfiguration(uri);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;使用连接池&quot;&gt;使用连接池&lt;/h3&gt;
&lt;p&gt;ConnectionSettings 不仅支持单地址的连接方式，同样提供了不同类型的连接池来让你配置客户端，如使用 SniffingConnectionPool 来连接集群中的 3 个 Elasticsearch 节点，客户端将使用该类型的连接池来维护集群中的可用节点列表，并会以循环的方式发送调用请求。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var uris = new[]{
    new Uri(&quot;http://localhost:9200&quot;),
    new Uri(&quot;http://localhost:9201&quot;),
    new Uri(&quot;http://localhost:9202&quot;),};

var connectionPool = new SniffingConnectionPool(uris);var settings = new ConnectionSettings(connectionPool)
    .DefaultIndex(&quot;people&quot;);

_client = new ElasticClient(settings);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.zhuliang.ltd/2020/01/Elasticsearch/Elasticsearch-Nest-ConfigurationOptions.html&quot;&gt;NEST 教程系列 2-1 连接：Configuration options| 配置选项&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;索引indexing&quot;&gt;索引（Indexing）&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;这里的“索引”需理解为动词，用 indexing 来理解会更好，表示将一份文档插入到 ES 中。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;假设有如下类 User.cs&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class User
{
    public Guid Id { get; set; }
    public string FirstName { get; set; }
    public string LastName { get; set; }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;索引(Indexing)/添加 一份文档到 ES 中&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;//同步
var response = _client.IndexDocument&amp;lt;User&amp;gt;(new User
            {
                Id = new Guid(&quot;3a351ea1-bfc3-43df-ae12-9c89e22af144&quot;),
                FirstName = &quot;f1&quot;,
                LastName = &quot;l1&quot;
            });

//异步
var response = _client.IndexDocumentAsync&amp;lt;User&amp;gt;(new User
            {
                Id = new Guid(&quot;82f323e3-b5ec-486b-ac88-1bc5e47ec643&quot;),
                FirstName = &quot;f2&quot;,
                LastName = &quot;l2&quot;
            });&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;目前提供的方法基本上都含有同步和异步版本（异步方法以 *Async 结尾）&lt;/li&gt;
&lt;li&gt;IndexDocument 方法会判断添加的文档是否已经存在(根据 _id)，若存在，则添加失败。&lt;/li&gt;
&lt;li&gt;NEST 会自动将 Id 属性作为 ES 中的 _id，更多关于 id 的推断方式见此博文：&lt;a href=&quot;https://blog.zhuliang.ltd/2020/01/Elasticsearch/Elasticsearch-Nest-id-inference.html&quot;&gt;NEST 教程系列 9-3 转换：Id 推断&lt;/a&gt;
&lt;ul&gt;&lt;li&gt;默认情况下，会使用 camel 命名方式进行转换，你可以使用 ConnectionSettings 对象的 .DefaultFieldNameInferrer(Func&amp;lt;string, string&amp;gt;) 方法来调整默认转换行为，更多关于属性的推断的见此博文：&lt;a href=&quot;https://blog.zhuliang.ltd/2020/01/Elasticsearch/Elasticsearch-Nest-field-inference.html&quot;&gt;NEST 教程系列 9-4 转换：Field 属性推断&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;最终请求地址为：&lt;/p&gt;
&lt;pre class=&quot;sh&quot;&gt;
&lt;code&gt;PUT  /users/_doc/3a351ea1-bfc3-43df-ae12-9c89e22af144&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;embed src=&quot;https://pic.zhuliang.ltd/20200114143327.png-c&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;查询&quot;&gt;查询&lt;/h2&gt;
&lt;h3 id=&quot;通过类-lambda-表达式进行查询&quot;&gt;通过类 lambda 表达式进行查询&lt;/h3&gt;
&lt;p&gt;通过 Search 方法进行查询。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var result = _client.Search&amp;lt;User&amp;gt;(s=&amp;gt;s.From(0)
                .Size(10)
                .Query(q=&amp;gt;q.Match(m=&amp;gt;m.Field(f=&amp;gt;f.LastName).Query(&quot;l1&quot;))));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;请求 URL 如下：&lt;/p&gt;
&lt;pre class=&quot;sh&quot;&gt;
&lt;code&gt;POST /users/_search?typed_keys=true&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;以上搜索是基于“users”索引来进行搜寻&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如何在 ES 上的所有索引上进行搜索？通过 AllIndices()，如下：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var result = _client.Search&amp;lt;User&amp;gt;(s=&amp;gt;s
    .AllIndices()  //指定在所有索引上进行查询
    .From(0)
    .Size(10)
    .Query(q=&amp;gt;q.Match(m=&amp;gt;m.Field(f=&amp;gt;f.LastName).Query(&quot;l1&quot;))));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;假设有如下文档：&lt;/p&gt;
&lt;pre class=&quot;sh&quot;&gt;
&lt;code&gt;//users 索引
&quot;hits&quot; : [
      {
        &quot;_index&quot; : &quot;users&quot;,
        &quot;_type&quot; : &quot;_doc&quot;,
        &quot;_id&quot; : &quot;3a351ea1-bfc3-43df-ae12-9c89e22af144&quot;,
        &quot;_score&quot; : 1.0,
        &quot;_source&quot; : {
          &quot;id&quot; : &quot;3a351ea1-bfc3-43df-ae12-9c89e22af144&quot;,
          &quot;firstName&quot; : &quot;f1&quot;,
          &quot;lastName&quot; : &quot;l1&quot;
        }
      },
      {
        &quot;_index&quot; : &quot;users&quot;,
        &quot;_type&quot; : &quot;_doc&quot;,
        &quot;_id&quot; : &quot;05245504-053c-431a-984f-23e16d8fbbc9&quot;,
        &quot;_score&quot; : 1.0,
        &quot;_source&quot; : {
          &quot;id&quot; : &quot;05245504-053c-431a-984f-23e16d8fbbc9&quot;,
          &quot;firstName&quot; : &quot;f2&quot;,
          &quot;lastName&quot; : &quot;l2&quot;
        }
      }
    ]
// thirdusers 索引
&quot;hits&quot; : [
  {
    &quot;_index&quot; : &quot;thirdusers&quot;,
    &quot;_type&quot; : &quot;_doc&quot;,
    &quot;_id&quot; : &quot;619ad5f8-c918-46ef-82a8-82a724ca5443&quot;,
    &quot;_score&quot; : 1.0,
    &quot;_source&quot; : {
      &quot;firstName&quot; : &quot;f1&quot;,
      &quot;lastName&quot; : &quot;l1&quot;
    }
  }
]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;则最终可以获取到 users 和 thirdusers 索引中分别获取到 _id 为 3a351ea1-bfc3-43df-ae12-9c89e22af144 和 619ad5f8-c918-46ef-82a8-82a724ca5443 的文档信息。&lt;/p&gt;
&lt;p&gt;可以通过 .AllTypes() 和 .AllIndices() 从所有 类型（types） 和 所有 索引（index）中查询数据，最终查询会生成在 /_search 请求中。关于 Type 和 Index，可分别参考：&lt;a href=&quot;https://blog.zhuliang.ltd/2020/01/Elasticsearch/Elasticsearch-Nest-Documents-path.html&quot;&gt;NEST 教程系列 9-6 转换：Document Paths 文档路径&lt;/a&gt;和&lt;a href=&quot;https://blog.zhuliang.ltd/2020/01/Elasticsearch/Elasticsearch-Nest-Indices-Paths.html&quot;&gt;跳转：NEST 教程系列 9-7 转换：Indices Paths 索引路径&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;通过查询对象进行查询&quot;&gt;通过查询对象进行查询&lt;/h3&gt;
&lt;p&gt;通过 SearchRequest 对象进行查询。&lt;/p&gt;
&lt;p&gt;例：在所有索引查询 LastName=&quot;l1&quot;的文档信息&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var request = new SearchRequest(Nest.Indices.All) //在所有索引上查询
{
    From = 0,
    Size = 10,
    Query = new MatchQuery
    {
        Field = Infer.Field&amp;lt;User&amp;gt;(f =&amp;gt; f.LastName),
        Query = &quot;l1&quot;
    }
};
var response = _client.Search&amp;lt;User&amp;gt;(request);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;生成的请求 URL 为：&lt;/p&gt;
&lt;pre class=&quot;sh&quot;&gt;
&lt;code&gt;POST  /_all/_search?typed_keys=true&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;通过-.lowlever-属性来使用-elasticsearch.net-来进行查询&quot;&gt;通过 .LowLever 属性来使用 Elasticsearch.Net 来进行查询&lt;/h3&gt;
&lt;p&gt;使用 Elasticsearch.Net 来进行查询的契机：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当客户端存在 bug，即使用上述 NEST 的 Search 和 SearchRequest 异常的时候，可以考虑用 Elasticsearch.Net 提供的查询方式。&lt;/li&gt;
&lt;li&gt;当你希望用一个匿名对象或者 JSON 字符串来进行查询的时候。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var response = _client.LowLevel.Search&amp;lt;SearchResponse&amp;lt;User&amp;gt;&amp;gt;(&quot;users&quot;, PostData.Serializable(new
{
    from = 0,
    size = 10,
    query = new
    {
        match = new
        {
            lastName = &quot;l1&quot;
        }
    }
}));&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;聚合查询&quot;&gt;聚合查询&lt;/h3&gt;
&lt;p&gt;除了结构化和非结构化查询之外， ES 同样支持聚合（Aggregations）查询：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var result = _client.Search&amp;lt;User&amp;gt;(s =&amp;gt; s
    .Size(0) //设置为 0 ，可以让结果只包含聚合的部分：即 hits 属性中没有结果，聚合结果显示在 ”aggregations“
    .Query(q =&amp;gt;
        q.Match(m =&amp;gt;
            m.Field(f =&amp;gt; f.FirstName)
                .Query(&quot;f2&quot;)))
    .Aggregations(a =&amp;gt; //使用 terms 聚合，并指定到桶 last_name 中
        a.Terms(&quot;last_name&quot;, ta =&amp;gt;
            ta.Field(f =&amp;gt; f.LastName)))
    );&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;一般使用 term 聚合来获取每个存储桶的文档数量，其中每个桶将以 lastName 作为关键字。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;更多关于聚合的操作可见此：&lt;a href=&quot;https://blog.zhuliang.ltd/2020/01/Elasticsearch/Elasticsearch-Nest-Writing-Aggregations.html&quot;&gt;NEST 教程系列 8 聚合：Writing aggregations | 使用聚合&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 23 Jan 2020 15:48:00 +0000</pubDate>
<dc:creator>DeepThought</dc:creator>
<og:description>本系列已经全部完成，完整版可见 ： &amp;quot;https://blog.zhuliang.ltd/categories/Elasticsearch/&amp;quot; 本系列博文是“伪”官方文档翻译（更加</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/deepthought/p/12231714.html</dc:identifier>
</item>
<item>
<title>B-Tree 和 B+Tree 结构及应用，InnoDB 引擎， MyISAM 引擎 - 永不停转</title>
<link>http://www.cnblogs.com/ITnoteforlsy/p/12228149.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ITnoteforlsy/p/12228149.html</guid>
<description>&lt;p&gt;&lt;strong&gt;1.什么是B-Tree 和 B+Tree，他们是做什么用的？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    B-Tree是为了磁盘或其它存储设备而设计的一种&lt;strong&gt;多叉平衡查找树&lt;/strong&gt;，B-Tree 和 B+Tree 广泛应用于文件存储系统以及数据库系统中。&lt;/p&gt;
&lt;div readability=&quot;24.5&quot;&gt;
&lt;p&gt;    在大规模数据存储中，实现索引查询这样一个实际背景下，树节点存储的元素数量是有限的（如果元素数量非常多的话，树的高度就会增大，查找就退化成节点内部的线性查找了），这样导致二叉查找树结构由于&lt;strong&gt;树的深度过大而造成磁盘I/O读写过于频繁，进而导致查询效率低下&lt;/strong&gt;（为什么会出现这种情况？这跟外部存储器-磁盘的存储方式有关）。那么该如何减少树的高度呢？一个基本的想法就是：采用&lt;strong&gt;多叉树&lt;/strong&gt;结构（每个节点存放多个元素，每个节点有多个子节点，这样树的高度就降低了）。根据平衡二叉树的启发，自然就想到平衡多路查找树结构。B-Tree的各种操作能使B-Tree保持较低的高度，从而达到有效避免磁盘过于频繁的查找存取操作，从而有效提高查找效率。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.B-Tree&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.1定义&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; m阶B-Tree满足以下条件：&lt;/p&gt;
&lt;div readability=&quot;20&quot;&gt;
&lt;p&gt;1、每个节点最多拥有m个子树&lt;/p&gt;
&lt;p&gt;2、根节点至少有2个子树&lt;/p&gt;
&lt;p&gt;3、分支节点至少拥有m/2颗子树（除根节点和叶子节点外都是分支节点）&lt;/p&gt;
&lt;p&gt;4、所有叶子节点都在同一层&lt;/p&gt;
&lt;p&gt;5、每个节点最多可以有m-1个key&lt;/p&gt;
&lt;p&gt;6、每个节点中的key以升序排列&lt;/p&gt;
&lt;p&gt;7、节点中key元素左节点的所有值都小于或等于该元素，元素右节点的所有值都大于或等于该元素&lt;/p&gt;
&lt;/div&gt;
 下面是一个3阶的B树：
&lt;p&gt;                                                                              &lt;img src=&quot;https://images2017.cnblogs.com/blog/831179/201707/831179-20170726165129453-1906239446.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2.2.B-Tree的建立过程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面我们以一个[0,1,2,3,4,5,6,7]的数组插入一棵 3 阶的 B-Tree 为例，将所有的条件都串起来！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1596700/202001/1596700-20200123155208024-357818266.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么，你是否对 B-Tree 的几点特性都清晰了呢？在二叉树中，每个结点只有一个元素。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1596700/202001/1596700-20200123160137612-544558999.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是在 B-Tree 中，每个结点都可能包含多个元素，并且非叶子结点在元素的左右都有指向子结点的指针。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1596700/202001/1596700-20200123160223471-313209425.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1596700/202001/1596700-20200123222807605-538460159.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1596700/202001/1596700-20200123222826551-274236967.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1596700/202001/1596700-20200123222846669-981147427.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 在 B-Tree 中，每个结点都可能包含多个元素，并且非叶子结点在元素的左右都有指向子结点的指针。 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.3.B-Tree搜索原理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 如果需要查找一个元素，那流程是怎么样的呢？我们看下图，如果我们要在下面的 B-Tree 中找到关键字 24，那流程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1596700/202001/1596700-20200123223018883-37429919.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1596700/202001/1596700-20200123223042920-1600493977.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1596700/202001/1596700-20200123223105196-2038099331.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1596700/202001/1596700-20200123223125405-1715677836.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从这个流程我们能看出，B-Tree 的查询效率好像也并不比平衡二叉树高。但是查询所经过的结点数量要少很多，也就意味着要少很多次的磁盘 IO，这对性能的提升是很大的。 &lt;/p&gt;
&lt;p&gt;从前面对 B-Tree 操作的图，我们能看出来，元素就是类似 1、2、3 这样的数值。 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.4.B-Tree在数据库中的应用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;但是数据库的数据都是一条条的数据，如果某个数据库以 B-Tree 的数据结构存储数据，那数据怎么存放的呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1596700/202001/1596700-20200123223346338-1656813429.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 普通的 B-Tree 的结点中，元素就是一个个的数字。但是上图中，我们把元素部分拆分成了 key-data 的形式，Key 就是数据的主键，Data 就是具体的数据。 &lt;/p&gt;
&lt;p&gt;这样我们在找一条数的时候，就沿着根结点往下找就 OK 了，效率是比较高的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 3.B+Tree&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;B+Tree 是在 B-Tree 基础上的一种优化，使其更适合实现外存储索引结构。 &lt;/p&gt;
&lt;p&gt;B+Tree 与 B-Tree 的结构很像，但是也有几个自己的特性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ol readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;所有的非叶子节点只存储关键字信息。 &lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;所有卫星数据（具体数据）都存在叶子结点中。 &lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;所有的叶子结点中包含了全部元素的信息。 &lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;所有叶子节点之间都有一个链指针。 &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果上面 B-Tree 的图变成 B+Tree，那应该如下： &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1596700/202001/1596700-20200123224959614-727002668.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 细对比于 B-Tree 的图，他们之间存在以下不同：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;非叶子结点上已经只有 Key 信息了，满足上面第 1 点特性！ &lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;所有叶子结点下面都有一个 Data 区域，满足上面第 2 点特性！ &lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;非叶子结点的数据在叶子结点上都能找到，如根结点的元素 4、8 在最底层的叶子结点上也能找到，满足上面第 3 点特性！ &lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;注意图中叶子结点之间的箭头，满足上面第 4 点特性！&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;4、B-Tree 和 B+Tree 该如何选择呢？都有哪些优劣呢？ &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;①B-Tree 因为非叶子结点也保存具体数据，所以在查找某个关键字的时候找到即可返回。 &lt;/p&gt;
&lt;p&gt;而 B+Tree 所有的数据都在叶子结点，每次查找都得到叶子结点。所以在同样高度的 B-Tree 和 B+Tree 中，B-Tree 查找某个关键字的效率更高。  &lt;/p&gt;
&lt;p&gt;②由于 B+Tree 所有的数据都在叶子结点，并且结点之间有指针连接，在找大于某个关键字或者小于某个关键字的数据的时候，B+Tree 只需要找到该关键字然后沿着链表遍历就可以了，而 B-Tree 还需要遍历该关键字结点的根结点去搜索。  &lt;/p&gt;
&lt;p&gt;③由于 B-Tree 的每个结点（这里的结点可以理解为一个数据页）都存储主键+实际数据，而 B+Tree 非叶子结点只存储关键字信息，而每个页的大小是有限的，所以同一页能存储的 B-Tree 的数据会比 B+Tree 存储的更少。 &lt;/p&gt;
&lt;p&gt;这样同样总量的数据，B-Tree 的深度会更大，增大查询时的磁盘 I/O 次数，进而影响查询效率。  &lt;/p&gt;
&lt;p&gt;鉴于以上的比较，所以在常用的关系型数据库中，都是选择 B+Tree 的数据结构来存储数据！ &lt;/p&gt;
&lt;p&gt;下面我们以 MySQL 的 InnoDB 存储引擎为例讲解，其他类似 SQL Server、Oracle 的原理！ &lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;InnoDB 引擎数据存储&lt;/strong&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在 InnoDB 存储引擎中，也有页的概念，默认每个页的大小为 16K，也就是每次读取数据时都是读取 4*4K 的大小！ &lt;/p&gt;
&lt;p&gt;假设我们现在有一个用户表，我们往里面写数据：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1596700/202001/1596700-20200123225356121-353765382.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 这里需要注意的一点是，在某个页内插入新行时，为了减少数据的移动，通常是插入到当前行的后面或者是已删除行留下来的空间，所以在某一个页内的数据并不是完全有序的（后面页结构部分有细讲）。 &lt;/p&gt;
&lt;p&gt;但是为了数据访问顺序性，在每个记录中都有一个指向下一条记录的指针，以此构成了一条单向有序链表，不过在这里为了方便演示我是按顺序排列的！ &lt;/p&gt;
&lt;p&gt;由于数据还比较少，一个页就能容下，所以只有一个根结点，主键和数据也都是保存在根结点（左边的数字代表主键，右边名字、性别代表具体的数据）。 &lt;/p&gt;
&lt;p&gt;假设我们写入 10 条数据之后，Page1 满了，再写入新的数据会怎么存放呢？ &lt;/p&gt;
&lt;p&gt;我们继续看下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1596700/202001/1596700-20200123225448358-1537314545.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 有个叫“秦寿生”的朋友来了，但是 Page1 已经放不下数据了，这时候就需要进行页分裂，产生一个新的 Page。 &lt;/p&gt;
&lt;p&gt;&lt;span&gt;在 InnoDB 中的流程是怎么样的呢？&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;产生新的 Page2，然后将 Page1 的内容复制到 Page2。 &lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;产生新的 Page3，“秦寿生”的数据放入 Page3。 &lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;原来的 Page1 依然作为根结点，但是变成了一个不存放数据只存放索引的页，并且有两个子结点 Page2、Page3。 &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;这里有两个问题需要注意的是：&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;①为什么要复制 Page1 为 Page2 而不是创建一个新的页作为根结点，这样就少了一步复制的开销了？ &lt;/p&gt;
&lt;p&gt;如果是重新创建根结点，那根结点存储的物理地址可能经常会变，不利于查找。 &lt;/p&gt;
&lt;p&gt;并且在 InnoDB 中根结点是会预读到内存中的，所以结点的物理地址固定会比较好！ &lt;/p&gt;
&lt;p&gt;②原来 Page1 有 10 条数据，在插入第 11 条数据的时候进行裂变，根据前面对 B-Tree、B+Tree 特性的了解，那这至少是一棵 11 阶的树，裂变之后每个结点的元素至少为 11/2=5 个。 &lt;/p&gt;
&lt;p&gt;那是不是应该页裂变之后主键 1-5 的数据还是在原来的页，主键 6-11 的数据会放到新的页，根结点存放主键 6？  &lt;/p&gt;
&lt;p&gt;如果是这样的话，新的页空间利用率只有 50%，并且会导致更为频繁的页分裂。 &lt;/p&gt;
&lt;p&gt;所以 InnoDB 对这一点做了优化，新的数据放入新创建的页，不移动原有页面的任何记录。 &lt;/p&gt;
&lt;p&gt;&lt;span&gt;随着数据的不断写入，这棵树也逐渐枝繁叶茂，如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1596700/202001/1596700-20200123225558905-729345438.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 每次新增数据，都是将一个页写满，然后新创建一个页继续写，这里其实是有个隐含条件的，那就是主键自增！ &lt;/p&gt;
&lt;p&gt;主键自增写入时新插入的数据不会影响到原有页，插入效率高！且页的利用率高！ &lt;/p&gt;
&lt;p&gt;但是如果主键是无序的或者随机的，那每次的插入可能会导致原有页频繁的分裂，影响插入效率！降低页的利用率！这也是为什么在 InnoDB 中建议设置主键自增的原因！ &lt;/p&gt;
&lt;p&gt;这棵树的非叶子结点上存的都是主键，那如果一个表没有主键会怎么样？在 InnoDB 中，如果一个表没有主键，那默认会找建了唯一索引的列，如果也没有，则会生成一个隐形的字段作为主键！ &lt;/p&gt;
&lt;p&gt;有数据插入那就有删除，如果这个用户表频繁的插入和删除，那会导致数据页产生碎片，页的空间利用率低，还会导致树变的“虚高”，降低查询效率！这可以通过索引重建来消除碎片提高查询效率！ &lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;InnoDB 引擎数据查找&lt;/strong&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;数据插入了怎么查找呢？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;找到数据所在的页。&lt;/strong&gt;这个查找过程就跟前面说到的 B+Tree 的搜索过程是一样的，从根结点开始查找一直到叶子结点。 &lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;在页内找具体的数据。&lt;/strong&gt;读取第 1 步找到的叶子结点数据到内存中，然后通过分块查找的方法找到具体的数据。 &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这跟我们在新华字典中找某个汉字是一样的，先通过字典的索引定位到该汉字拼音所在的页，然后到指定的页找到具体的汉字。 &lt;/p&gt;
&lt;p&gt;InnoDB 中定位到页后用了哪种策略快速查找某个主键呢？这我们就需要从页结构开始了解。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1596700/202001/1596700-20200123225938713-872253117.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;左边蓝色区域称为 Page Directory，这块区域由多个 Slot 组成，是一个稀疏索引结构，即一个槽中可能属于多个记录，最少属于 4 条记录，最多属于 8 条记录。 &lt;/p&gt;
&lt;p&gt;槽内的数据是有序存放的，所以当我们寻找一条数据的时候可以先在槽中通过二分法查找到一个大致的位置。 &lt;/p&gt;
&lt;p&gt;右边区域为数据区域，每一个数据页中都包含多条行数据。注意看图中最上面和最下面的两条特殊的行记录 Infimum 和 Supremum，这是两个虚拟的行记录。 &lt;/p&gt;
&lt;p&gt;在没有其他用户数据的时候 Infimum 的下一条记录的指针指向 Supremum。 &lt;/p&gt;
&lt;p&gt;当有用户数据的时候，Infimum 的下一条记录的指针指向当前页中最小的用户记录，当前页中最大的用户记录的下一条记录的指针指向 Supremum，至此整个页内的所有行记录形成一个单向链表。 &lt;/p&gt;
&lt;p&gt;行记录被 Page Directory 逻辑的分成了多个块，块与块之间是有序的，也就是说“4”这个槽指向的数据块内最大的行记录的主键都要比“8”这个槽指向的数据块内最小的行记录的主键要小。但是块内部的行记录不一定有序。 &lt;/p&gt;
&lt;p&gt;每个行记录的都有一个 n_owned 的区域（图中粉红色区域），n_owned 标识这个块有多少条数据。 &lt;/p&gt;
&lt;p&gt;伪记录 Infimum 的 n_owned 值总是 1，记录 Supremum 的 n_owned 的取值范围为[1,8]，其他用户记录 n_owned 的取值范围[4,8]。 &lt;/p&gt;
&lt;p&gt;并且只有每个块中最大的那条记录的 n_owned 才会有值，其他的用户记录的 n_owned 为 0。 &lt;/p&gt;
&lt;p&gt;所以当我们要找主键为 6 的记录时，先通过二分法在稀疏索引中找到对应的槽，也就是 Page Directory 中“8”这个槽。 &lt;/p&gt;
&lt;p&gt;“8”这个槽指向的是该数据块中最大的记录，而数据是单向链表结构，所以无法逆向查找。 &lt;/p&gt;
&lt;p&gt;所以需要找到上一个槽即“4”这个槽，然后通过“4”这个槽中最大的用户记录的指针沿着链表顺序查找到目标记录。 &lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;聚集索引&amp;amp;非聚集索引&lt;/strong&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;前面关于数据存储的都是演示的聚集索引的实现，如果上面的用户表需要以“用户名字”建立一个非聚集索引，是怎么实现的呢？ &lt;/p&gt;
&lt;p&gt;我们看下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1596700/202001/1596700-20200123230230777-2013440107.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 非聚集索引的存储结构与前面是一样的，不同的是在叶子结点的数据部分存的不再是具体的数据，而是数据的聚集索引的 Key。 &lt;/p&gt;
&lt;p&gt;所以通过非聚集索引查找的过程是先找到该索引 Key 对应的聚集索引的 Key，然后再拿聚集索引的 Key 到主键索引树上查找对应的数据，这个过程称为&lt;span&gt;回表&lt;/span&gt;！&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;InnoDB 与 MyISAM 引擎对比&lt;/strong&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;上面包括存储和搜索都是拿的 InnoDB 引擎为例，那 MyISAM 与 InnoDB 在存储上有啥不同呢？看图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1596700/202001/1596700-20200123230514648-1390884276.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图为 MyISAM 主键索引的存储结构，我们能看到的不同是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;主键索引树的叶子结点的数据区域没有存放实际的数据，存放的是数据记录的地址。 &lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;数据的存储不是按主键顺序存放的，是按写入的顺序存放。 &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;也就是说 InnoDB 引擎数据在物理上是按主键顺序存放，而 MyISAM 引擎数据在物理上按插入的顺序存放。 &lt;/p&gt;
&lt;p&gt;并且 MyISAM 的叶子结点不存放数据，所以非聚集索引的存储结构与聚集索引类似，在使用非聚集索引查找数据的时候通过非聚集索引树就能直接找到数据的地址了，不需要回表，这比 InnoDB 的搜索效率会更高呢！&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;索引优化建议&lt;/strong&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;大家经常会在很多的文章或书中能看到一些索引的使用建议，比如说：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;like 的模糊查询以 % 开头，会导致索引失效。 &lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;一个表建的索引尽量不要超过 5 个。 &lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;尽量使用覆盖索引。 &lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;尽量不要在重复数据多的列上建索引。 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;...... &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;很多这里就不一一列举了！那看完这篇文章，我们能否带着疑问去分析一下为什么要有这些建议？ &lt;/p&gt;
&lt;p&gt;为什么 like 的模糊查询以 % 开头，会导致索引失效？为什么一个表建的索引尽量不要超过 5 个？&lt;/p&gt;
</description>
<pubDate>Thu, 23 Jan 2020 15:11:00 +0000</pubDate>
<dc:creator>永不停转</dc:creator>
<og:description>1.什么是B-Tree 和 B+Tree，他们是做什么用的？ B-Tree是为了磁盘或其它存储设备而设计的一种多叉平衡查找树，B-Tree 和 B+Tree&amp;#160;广泛应用于文件存储系统以及数据库</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ITnoteforlsy/p/12228149.html</dc:identifier>
</item>
<item>
<title>Redis（四）：del/unlink 命令源码解析 - 等你归去来</title>
<link>http://www.cnblogs.com/yougewe/p/12231419.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yougewe/p/12231419.html</guid>
<description>&lt;p&gt;　　上一篇文章从根本上理解了set/get的处理过程，相当于理解了 增、改、查的过程，现在就差一个删了。本篇我们来看一下删除过程。&lt;/p&gt;
&lt;p&gt;　　对于客户端来说，删除操作无需区分何种数据类型，只管进行 del 操作即可。&lt;/p&gt;

&lt;p&gt;零、删除命令 del 的定义&lt;/p&gt;
&lt;p&gt;　　主要有两个: del/unlink, 差别是 unlink 速度会更快, 因为其使用了异步删除优化模式, 其定义如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 标识只有一个 w, 说明就是一个普通的写操作，没啥好说的&lt;/span&gt;
    {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;del&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,delCommand,-&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,NULL,&lt;span&gt;1&lt;/span&gt;,-&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;}
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 标识为 wF, 说明它是一个快速写的操作，其实就是有一个异步优化的过程，稍后详解&lt;/span&gt;
    {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;unlink&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,unlinkCommand,-&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wF&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,NULL,&lt;span&gt;1&lt;/span&gt;,-&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;一、delCommand&lt;/p&gt;
&lt;p&gt;　　delCommand 的作用就是直接删除某个 key 的数据，释放内存即可。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; db.c, del 命令处理    &lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; delCommand(client *&lt;span&gt;c) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 同步删除&lt;/span&gt;
    delGenericCommand(c,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; This command implements DEL and LAZYDEL. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; delGenericCommand(client *c, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; lazy) {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; numdel = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, j;

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (j = &lt;span&gt;1&lt;/span&gt;; j &amp;lt; c-&amp;gt;argc; j++&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 自动过期数据清理&lt;/span&gt;
        expireIfNeeded(c-&amp;gt;db,c-&amp;gt;&lt;span&gt;argv[j]);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 此处分同步删除和异步删除, 主要差别在于对于复杂数据类型的删除方面，如hash,list,set...
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 针对 string 的删除是完全一样的&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; deleted  = lazy ? dbAsyncDelete(c-&amp;gt;db,c-&amp;gt;&lt;span&gt;argv[j]) :
                              dbSyncDelete(c&lt;/span&gt;-&amp;gt;db,c-&amp;gt;&lt;span&gt;argv[j]);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 写命令的传播问题&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (deleted) {
            signalModifiedKey(c&lt;/span&gt;-&amp;gt;db,c-&amp;gt;&lt;span&gt;argv[j]);
            notifyKeyspaceEvent(NOTIFY_GENERIC,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;del&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,c-&amp;gt;argv[j],c-&amp;gt;db-&amp;gt;&lt;span&gt;id);
            server.dirty&lt;/span&gt;++&lt;span&gt;;
            numdel&lt;/span&gt;++&lt;span&gt;;
        }
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 响应删除数据量, 粒度到 key 级别&lt;/span&gt;
&lt;span&gt;    addReplyLongLong(c,numdel);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　框架代码一看即明，只是相比于我们普通的删除是多了不少事情。否则也不存在设计了。&lt;/p&gt;

&lt;p&gt;二、unlinkCommand&lt;/p&gt;
&lt;p&gt;　　如下，其实和del是一毛一样的，仅是变化了一个 lazy 标识而已。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; db.c, unlink 删除处理&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; unlinkCommand(client *&lt;span&gt;c) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 与 del 一致，只是 lazy 标识不一样&lt;/span&gt;
    delGenericCommand(c,&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;三、删除数据过程详解&lt;/p&gt;
&lt;p&gt;　　删除数据分同步和异步两种实现方式，道理都差不多，只是一个是后台删一个是前台删。我们分别来看看。&lt;/p&gt;
&lt;p&gt;1. 同步删除 dbSyncDelete&lt;/p&gt;
&lt;p&gt;　　同步删除很简单，只要把对应的key删除，val删除就行了，如果有内层引用，则进行递归删除即可。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; db.c, 同步删除数据&lt;/span&gt;&lt;span&gt;
/*&lt;/span&gt;&lt;span&gt; Delete a key, value, and associated expiration entry if any, from the DB &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; dbSyncDelete(redisDb *db, robj *&lt;span&gt;key) {
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Deleting an entry from the expires dict will not free the sds of
     * the key, because it is shared with the main dictionary. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 首先从 expires 队列删除，然后再从 db-&amp;gt;dict 中删除&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (dictSize(db-&amp;gt;expires) &amp;gt; &lt;span&gt;0&lt;/span&gt;) dictDelete(db-&amp;gt;expires,key-&amp;gt;&lt;span&gt;ptr);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (dictDelete(db-&amp;gt;dict,key-&amp;gt;ptr) ==&lt;span&gt; DICT_OK) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (server.cluster_enabled) slotToKeyDel(key);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    }
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; dict.c, 如上, 仅仅是 dictDelete() 就可以了，所以真正的删除动作是在 dict 中实现的。&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; dictDelete(dict *ht, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; *&lt;span&gt;key) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; nofree: 0, 即要求释放内存&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; dictGenericDelete(ht,key,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; dict.c, nofree: 0:要释放相应的val内存, 1:不释放相应val内存只删除key&lt;/span&gt;&lt;span&gt;
/*&lt;/span&gt;&lt;span&gt; Search and remove an element &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; dictGenericDelete(dict *d, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; *key, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; nofree)
{
    unsigned &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; h, idx;
    dictEntry &lt;/span&gt;*he, *&lt;span&gt;prevHe;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; table;

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (d-&amp;gt;ht[&lt;span&gt;0&lt;/span&gt;].size == &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; DICT_ERR; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; d-&amp;gt;ht[0].table is NULL &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (dictIsRehashing(d)) _dictRehashStep(d);
    h &lt;/span&gt;=&lt;span&gt; dictHashKey(d, key);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ht[0] 和 ht[1] 如有可能都进行扫描&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; (table = &lt;span&gt;0&lt;/span&gt;; table &amp;lt;= &lt;span&gt;1&lt;/span&gt;; table++&lt;span&gt;) {
        idx &lt;/span&gt;= h &amp;amp; d-&amp;gt;&lt;span&gt;ht[table].sizemask;
        he &lt;/span&gt;= d-&amp;gt;&lt;span&gt;ht[table].table[idx];
        prevHe &lt;/span&gt;=&lt;span&gt; NULL;
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt;(he) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (dictCompareKeys(d, key, he-&amp;gt;&lt;span&gt;key)) {
                &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Unlink the element from the list &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (prevHe)
                    prevHe&lt;/span&gt;-&amp;gt;next = he-&amp;gt;&lt;span&gt;next;
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                    d&lt;/span&gt;-&amp;gt;ht[table].table[idx] = he-&amp;gt;&lt;span&gt;next;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; no nofree, 就是要 free 内存咯&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;nofree) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 看起来 key/value 需要单独释放内存哦&lt;/span&gt;
&lt;span&gt;                    dictFreeKey(d, he);
                    dictFreeVal(d, he);
                }
                zfree(he);
                d&lt;/span&gt;-&amp;gt;ht[table].used--&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; DICT_OK;
            }
            prevHe &lt;/span&gt;=&lt;span&gt; he;
            he &lt;/span&gt;= he-&amp;gt;&lt;span&gt;next;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果没有进行 rehashing, 只需扫描0就行了&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (!dictIsRehashing(d)) &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; DICT_ERR; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; not found &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　其实对于有GC收集器的语言来说，根本不用关注内存的释放问题，自有后台工具处理，然而对于 c 语言这种级别语言，则是需要自行关注内存的。这也是本文存在的意义，不然对于一个 hash 表的元素删除操作，如上很难吗？并没有。&lt;/p&gt;
&lt;p&gt;　　下面，我们就来看看 redis 是如何具体释放内存的吧。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; dict.h, 释放key, value 的逻辑也是非常简单，用一个宏就定义好了
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 释放依赖于 keyDestructor, valDestructor&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; dictFreeKey(d, entry) \
    &lt;span&gt;if&lt;/span&gt; ((d)-&amp;gt;type-&amp;gt;&lt;span&gt;keyDestructor) \
        (d)&lt;/span&gt;-&amp;gt;type-&amp;gt;keyDestructor((d)-&amp;gt;privdata, (entry)-&amp;gt;&lt;span&gt;key)
&lt;/span&gt;&lt;span&gt;#define&lt;/span&gt; dictFreeVal(d, entry) \
    &lt;span&gt;if&lt;/span&gt; ((d)-&amp;gt;type-&amp;gt;&lt;span&gt;valDestructor) \
        (d)&lt;/span&gt;-&amp;gt;type-&amp;gt;valDestructor((d)-&amp;gt;privdata, (entry)-&amp;gt;&lt;span&gt;v.val)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 所以，我们有必要回去看看 key,value 的析构方法
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 而这，又依赖于具体的数据类型，也就是你在 setXXX 的时候用到的数据类型
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 我们看一下这个 keyDestructor,valDestructor 初始化的样子
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; server.c  kv的析构函数定义&lt;/span&gt;&lt;span&gt;
/*&lt;/span&gt;&lt;span&gt; Db-&amp;gt;dict, keys are sds strings, vals are Redis objects. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
dictType dbDictType &lt;/span&gt;=&lt;span&gt; {
    dictSdsHash,                &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; hash function &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    NULL,                       &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; key dup &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    NULL,                       &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; val dup &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    dictSdsKeyCompare,          &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; key compare &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    dictSdsDestructor,          &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; key destructor &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    dictObjectDestructor   &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; val destructor &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
};

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1. 先看看 key destructor, key 的释放
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; server.c, 直接调用 sds 提供的服务即可&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; dictSdsDestructor(&lt;span&gt;void&lt;/span&gt; *privdata, &lt;span&gt;void&lt;/span&gt; *&lt;span&gt;val)
{
    DICT_NOTUSED(privdata);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; sds 直接释放key就行了&lt;/span&gt;
&lt;span&gt;    sdsfree(val);
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; sds.c, 真正释放 value 内存&lt;/span&gt;&lt;span&gt;
/*&lt;/span&gt;&lt;span&gt; Free an sds string. No operation is performed if 's' is NULL. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; sdsfree(sds s) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (s == NULL) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; zfree, 确实很简单嘛, 因为 sds 是连续的内存空间，直接使用系统提供的方法即可删除&lt;/span&gt;
    s_free((&lt;span&gt;char&lt;/span&gt;*)s-sdsHdrSize(s[-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]));
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2. value destructor 对value的释放, 如果说 key 一定是string格式的话，value可主不一定了，因为 redis提供丰富的数据类型呢
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; server.c&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; dictObjectDestructor(&lt;span&gt;void&lt;/span&gt; *privdata, &lt;span&gt;void&lt;/span&gt; *&lt;span&gt;val)
{
    DICT_NOTUSED(privdata);

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (val == NULL) &lt;span&gt;return&lt;/span&gt;; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Lazy freeing will set value to NULL. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    decrRefCount(val);
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 减少 value 的引用计数&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; decrRefCount(robj *&lt;span&gt;o) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (o-&amp;gt;refcount == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;(o-&amp;gt;&lt;span&gt;type) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; string 类型&lt;/span&gt;
            &lt;span&gt;case&lt;/span&gt; OBJ_STRING: freeStringObject(o); &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; list 类型&lt;/span&gt;
            &lt;span&gt;case&lt;/span&gt; OBJ_LIST: freeListObject(o); &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; set 类型&lt;/span&gt;
            &lt;span&gt;case&lt;/span&gt; OBJ_SET: freeSetObject(o); &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; zset 类型&lt;/span&gt;
            &lt;span&gt;case&lt;/span&gt; OBJ_ZSET: freeZsetObject(o); &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; hash 类型&lt;/span&gt;
            &lt;span&gt;case&lt;/span&gt; OBJ_HASH: freeHashObject(o); &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;: serverPanic(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Unknown object type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;); &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
        zfree(o);
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (o-&amp;gt;refcount &amp;lt;= &lt;span&gt;0&lt;/span&gt;) serverPanic(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;decrRefCount against refcount &amp;lt;= 0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (o-&amp;gt;refcount != OBJ_SHARED_REFCOUNT) o-&amp;gt;refcount--&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　额，可以看出，对key的释放自然是简单之极。而对 value 则谨慎许多，首先它表面上只对引用做减操作。只有发只剩下1个引用即只有当前引用的情况下，本次释放就是最后一次释放，所以才会回收内存。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在介绍不同数据类型的内存释放前，我们可以先来看下每个元素的数据结构
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; dict.h&lt;/span&gt;
typedef &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; dictEntry {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 存储 key 字段内容&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; *&lt;span&gt;key;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用一个联合体存储value&lt;/span&gt;
&lt;span&gt;    union {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 存储数据时使用 *val 存储&lt;/span&gt;
        &lt;span&gt;void&lt;/span&gt; *&lt;span&gt;val;
        uint64_t u64;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 存储过期时间时使用该字段&lt;/span&gt;
&lt;span&gt;        int64_t s64;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 存储 score 时使用&lt;/span&gt;
        &lt;span&gt;double&lt;/span&gt;&lt;span&gt; d;
    } v;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 存在hash冲突时，作链表使用&lt;/span&gt;
    &lt;span&gt;struct&lt;/span&gt; dictEntry *&lt;span&gt;next;
} dictEntry;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1. string 类型的释放
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; object.c&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; freeStringObject(robj *&lt;span&gt;o) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 直接调用 sds服务释放&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (o-&amp;gt;encoding ==&lt;span&gt; OBJ_ENCODING_RAW) {
        sdsfree(o&lt;/span&gt;-&amp;gt;&lt;span&gt;ptr);
    }
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2. list 类型的释放
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; object.c&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; freeListObject(robj *&lt;span&gt;o) {
    &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt; (o-&amp;gt;&lt;span&gt;encoding) {
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; OBJ_ENCODING_QUICKLIST:
        quicklistRelease(o&lt;/span&gt;-&amp;gt;&lt;span&gt;ptr);
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
        serverPanic(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Unknown list encoding type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; quicklist.c&lt;/span&gt;&lt;span&gt;
/*&lt;/span&gt;&lt;span&gt; Free entire quicklist. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; quicklistRelease(quicklist *&lt;span&gt;quicklist) {
    unsigned &lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt; len;
    quicklistNode &lt;/span&gt;*current, *&lt;span&gt;next;

    current &lt;/span&gt;= quicklist-&amp;gt;&lt;span&gt;head;
    len &lt;/span&gt;= quicklist-&amp;gt;&lt;span&gt;len;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 链表依次迭代就可以释放完成了&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt; (len--&lt;span&gt;) {
        next &lt;/span&gt;= current-&amp;gt;&lt;span&gt;next;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 释放list具体值&lt;/span&gt;
        zfree(current-&amp;gt;&lt;span&gt;zl);
        quicklist&lt;/span&gt;-&amp;gt;count -= current-&amp;gt;&lt;span&gt;count;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 释放list对象&lt;/span&gt;
&lt;span&gt;        zfree(current);

        quicklist&lt;/span&gt;-&amp;gt;len--&lt;span&gt;;
        current &lt;/span&gt;=&lt;span&gt; next;
    }
    zfree(quicklist);
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3. set 类型的释放
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; object.c, set 分两种类型, ht, intset&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; freeSetObject(robj *&lt;span&gt;o) {
    &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt; (o-&amp;gt;&lt;span&gt;encoding) {
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; OBJ_ENCODING_HT:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; hash 类型则需要删除每个 hash 的 kv&lt;/span&gt;
        dictRelease((dict*) o-&amp;gt;&lt;span&gt;ptr);
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; OBJ_ENCODING_INTSET:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; intset 直接释放&lt;/span&gt;
        zfree(o-&amp;gt;&lt;span&gt;ptr);
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
        serverPanic(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Unknown set encoding type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; dict.c, &lt;/span&gt;&lt;span&gt;
/*&lt;/span&gt;&lt;span&gt; Clear &amp;amp; Release the hash table &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; dictRelease(dict *&lt;span&gt;d)
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ht[0],ht[1] 依次清理&lt;/span&gt;
    _dictClear(d,&amp;amp;d-&amp;gt;ht[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;],NULL);
    _dictClear(d,&lt;/span&gt;&amp;amp;d-&amp;gt;ht[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;],NULL);
    zfree(d);
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; dict.c, &lt;/span&gt;&lt;span&gt;
/*&lt;/span&gt;&lt;span&gt; Destroy an entire dictionary &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; _dictClear(dict *d, dictht *ht, &lt;span&gt;void&lt;/span&gt;(callback)(&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;)) {
    unsigned &lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt; i;

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Free all the elements &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; (i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; ht-&amp;gt;size &amp;amp;&amp;amp; ht-&amp;gt;used &amp;gt; &lt;span&gt;0&lt;/span&gt;; i++&lt;span&gt;) {
        dictEntry &lt;/span&gt;*he, *&lt;span&gt;nextHe;

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (callback &amp;amp;&amp;amp; (i &amp;amp; &lt;span&gt;65535&lt;/span&gt;) == &lt;span&gt;0&lt;/span&gt;) callback(d-&amp;gt;&lt;span&gt;privdata);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 元素为空，hash未命中，但只要 used &amp;gt; 0, 代表就还有需要删除的元素存在
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 其实对于只有少数几个元素的情况下，这个效率就呵呵了&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; ((he = ht-&amp;gt;table[i]) == NULL) &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt;(he) {
            nextHe &lt;/span&gt;= he-&amp;gt;&lt;span&gt;next;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里的释放 kv 逻辑和前面是一致的
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 看起来像是递归，其实不然，因为redis不存在数据类型嵌套问题，比如 hash下存储hash, 所以不会存在递归
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 具体结构会在后续解读到&lt;/span&gt;
&lt;span&gt;            dictFreeKey(d, he);
            dictFreeVal(d, he);
            zfree(he);
            ht&lt;/span&gt;-&amp;gt;used--&lt;span&gt;;
            he &lt;/span&gt;=&lt;span&gt; nextHe;
        }
    }
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Free the table and the allocated cache structure &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    zfree(ht&lt;/span&gt;-&amp;gt;&lt;span&gt;table);
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Re-initialize the table &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    _dictReset(ht);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; DICT_OK; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; never fails &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 4. hash 类型的释放
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; object.c, hash和set其实是很相似的，代码也做了大量的复用&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; freeHashObject(robj *&lt;span&gt;o) {
    &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt; (o-&amp;gt;&lt;span&gt;encoding) {
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; OBJ_ENCODING_HT:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ht 形式与set一致&lt;/span&gt;
        dictRelease((dict*) o-&amp;gt;&lt;span&gt;ptr);
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; OBJ_ENCODING_ZIPLIST:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ziplist 直接释放&lt;/span&gt;
        zfree(o-&amp;gt;&lt;span&gt;ptr);
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
        serverPanic(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Unknown hash encoding type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
    }
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 5. zset 类型的释放
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; object.c, zset 的存储形式与其他几个&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; freeZsetObject(robj *&lt;span&gt;o) {
    zset &lt;/span&gt;*&lt;span&gt;zs;
    &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt; (o-&amp;gt;&lt;span&gt;encoding) {
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; OBJ_ENCODING_SKIPLIST:
        zs &lt;/span&gt;= o-&amp;gt;&lt;span&gt;ptr;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 释放dict 数据, ht 0,1 的释放&lt;/span&gt;
        dictRelease(zs-&amp;gt;&lt;span&gt;dict);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 释放skiplist 数据, 主要看下这个&lt;/span&gt;
        zslFree(zs-&amp;gt;&lt;span&gt;zsl);
        zfree(zs);
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; OBJ_ENCODING_ZIPLIST:
        zfree(o&lt;/span&gt;-&amp;gt;&lt;span&gt;ptr);
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
        serverPanic(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Unknown sorted set encoding&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; t_zset.c, 释放跳表数据&lt;/span&gt;&lt;span&gt;
/*&lt;/span&gt;&lt;span&gt; Free a whole skiplist. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; zslFree(zskiplist *&lt;span&gt;zsl) {
    zskiplistNode &lt;/span&gt;*node = zsl-&amp;gt;header-&amp;gt;level[&lt;span&gt;0&lt;/span&gt;].forward, *&lt;span&gt;next;

    zfree(zsl&lt;/span&gt;-&amp;gt;&lt;span&gt;header);
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt;(node) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 基于第0层数据释放，也基于第0层做迭代，直到删除完成
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 因为其他层数据都是引用的第0层的数据，所以释放时无需关注&lt;/span&gt;
        next = node-&amp;gt;level[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;].forward;
        zslFreeNode(node);
        node &lt;/span&gt;=&lt;span&gt; next;
    }
    zfree(zsl);
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; t_zset 也很简单，只是把 node.ele 释放掉，再把自身释放到即可
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这样的删除方式依赖于其存储结构，咱们后续再聊&lt;/span&gt;&lt;span&gt;
/*&lt;/span&gt;&lt;span&gt; Free the specified skiplist node. The referenced SDS string representation
 * of the element is freed too, unless node-&amp;gt;ele is set to NULL before calling
 * this function. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; zslFreeNode(zskiplistNode *&lt;span&gt;node) {
    sdsfree(node&lt;/span&gt;-&amp;gt;&lt;span&gt;ele);
    zfree(node);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2. 异步删除过程&lt;/p&gt;
&lt;p&gt;　　异步删除按理说会更复杂，更有意思些。只不过我们前面已经把核心的东西撸了个遍，这剩下的也不多了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;77&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; lazyfree.c, &lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; dbAsyncDelete(redisDb *db, robj *&lt;span&gt;key) {
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Deleting an entry from the expires dict will not free the sds of
     * the key, because it is shared with the main dictionary. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (dictSize(db-&amp;gt;expires) &amp;gt; &lt;span&gt;0&lt;/span&gt;) dictDelete(db-&amp;gt;expires,key-&amp;gt;&lt;span&gt;ptr);

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; If the value is composed of a few allocations, to free in a lazy way
     * is actually just slower... So under a certain limit we just free
     * the object synchronously. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    dictEntry &lt;/span&gt;*de = dictFind(db-&amp;gt;dict,key-&amp;gt;&lt;span&gt;ptr);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (de) {
        robj &lt;/span&gt;*val =&lt;span&gt; dictGetVal(de);
        size_t free_effort &lt;/span&gt;=&lt;span&gt; lazyfreeGetFreeEffort(val);

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; If releasing the object is too much work, let's put it into the
         * lazy free list. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 其实异步方法与同步方法的差别在这，即要求 删除的元素影响须大于某阀值(64)
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 否则按照同步方式直接删除，因为那样代价更小&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (free_effort &amp;gt;&lt;span&gt; LAZYFREE_THRESHOLD) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 异步释放+1，原子操作&lt;/span&gt;
            atomicIncr(lazyfree_objects,&lt;span&gt;1&lt;/span&gt;,&amp;amp;&lt;span&gt;lazyfree_objects_mutex);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将 value 的释放添加到异步线程队列中去，后台处理, 任务类型为 异步释放内存&lt;/span&gt;
&lt;span&gt;            bioCreateBackgroundJob(BIO_LAZY_FREE,val,NULL,NULL);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置val为NULL, 以便在外部进行删除时忽略释放value相关内存&lt;/span&gt;
            dictSetVal(db-&amp;gt;&lt;span&gt;dict,de,NULL);
        }
    }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Release the key-val pair, or just the key if we set the val
     * field to NULL in order to lazy free it later. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (dictDelete(db-&amp;gt;dict,key-&amp;gt;ptr) ==&lt;span&gt; DICT_OK) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (server.cluster_enabled) slotToKeyDel(key);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    }
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; bio.c, 添加异步任务到线程中, 类型由type决定，线程安全地添加
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 然后嘛，后台线程就不会停地运行了任务了&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; bioCreateBackgroundJob(&lt;span&gt;int&lt;/span&gt; type, &lt;span&gt;void&lt;/span&gt; *arg1, &lt;span&gt;void&lt;/span&gt; *arg2, &lt;span&gt;void&lt;/span&gt; *&lt;span&gt;arg3) {
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; bio_job *job = zmalloc(&lt;span&gt;sizeof&lt;/span&gt;(*&lt;span&gt;job));

    job&lt;/span&gt;-&amp;gt;time =&lt;span&gt; time(NULL);
    job&lt;/span&gt;-&amp;gt;arg1 =&lt;span&gt; arg1;
    job&lt;/span&gt;-&amp;gt;arg2 =&lt;span&gt; arg2;
    job&lt;/span&gt;-&amp;gt;arg3 =&lt;span&gt; arg3;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 上锁操作&lt;/span&gt;
    pthread_mutex_lock(&amp;amp;&lt;span&gt;bio_mutex[type]);
    listAddNodeTail(bio_jobs[type],job);
    bio_pending[type]&lt;/span&gt;++&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 唤醒任务线程&lt;/span&gt;
    pthread_cond_signal(&amp;amp;&lt;span&gt;bio_newjob_cond[type]);
    pthread_mutex_unlock(&lt;/span&gt;&amp;amp;&lt;span&gt;bio_mutex[type]);
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; bio.c, 后台线程任务框架，总之还是有事情可做了。&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; *bioProcessBackgroundJobs(&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;arg) {
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; bio_job *&lt;span&gt;job;
    unsigned &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; type = (unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt;) arg;
    sigset_t sigset;

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Check that the type is within the right interval. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (type &amp;gt;=&lt;span&gt; BIO_NUM_OPS) {
        serverLog(LL_WARNING,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Warning: bio thread started with wrong type %lu&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,type);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NULL;
    }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Make the thread killable at any time, so that bioKillThreads()
     * can work reliably. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);
    pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);

    pthread_mutex_lock(&lt;/span&gt;&amp;amp;&lt;span&gt;bio_mutex[type]);
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Block SIGALRM so we are sure that only the main thread will
     * receive the watchdog signal. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    sigemptyset(&lt;/span&gt;&amp;amp;&lt;span&gt;sigset);
    sigaddset(&lt;/span&gt;&amp;amp;&lt;span&gt;sigset, SIGALRM);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (pthread_sigmask(SIG_BLOCK, &amp;amp;&lt;span&gt;sigset, NULL))
        serverLog(LL_WARNING,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Warning: can't mask SIGALRM in bio.c thread: %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, strerror(errno));
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 任务一直运行&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
        listNode &lt;/span&gt;*&lt;span&gt;ln;

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; The loop always starts with the lock hold. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (listLength(bio_jobs[type]) == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注意此处将会释放锁哟，以便外部可以添加任务进来&lt;/span&gt;
            pthread_cond_wait(&amp;amp;bio_newjob_cond[type],&amp;amp;&lt;span&gt;bio_mutex[type]);
            &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Pop the job from the queue. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        ln &lt;/span&gt;=&lt;span&gt; listFirst(bio_jobs[type]);
        job &lt;/span&gt;= ln-&amp;gt;&lt;span&gt;value;
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; It is now possible to unlock the background system as we know have
         * a stand alone job structure to process.&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        pthread_mutex_unlock(&lt;/span&gt;&amp;amp;&lt;span&gt;bio_mutex[type]);

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Process the job accordingly to its type. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (type ==&lt;span&gt; BIO_CLOSE_FILE) {
            close((&lt;/span&gt;&lt;span&gt;long&lt;/span&gt;)job-&amp;gt;&lt;span&gt;arg1);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (type ==&lt;span&gt; BIO_AOF_FSYNC) {
            aof_fsync((&lt;/span&gt;&lt;span&gt;long&lt;/span&gt;)job-&amp;gt;&lt;span&gt;arg1);
        } 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 也就是这玩意了，会去处理提交过来的任务&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (type ==&lt;span&gt; BIO_LAZY_FREE) {
            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; What we free changes depending on what arguments are set:
             * arg1 -&amp;gt; free the object at pointer.
             * arg2 &amp;amp; arg3 -&amp;gt; free two dictionaries (a Redis DB).
             * only arg3 -&amp;gt; free the skiplist. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 本文介绍的删除value形式，用第一种情况&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (job-&amp;gt;&lt;span&gt;arg1)
                lazyfreeFreeObjectFromBioThread(job&lt;/span&gt;-&amp;gt;&lt;span&gt;arg1);
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (job-&amp;gt;arg2 &amp;amp;&amp;amp; job-&amp;gt;&lt;span&gt;arg3)
                lazyfreeFreeDatabaseFromBioThread(job&lt;/span&gt;-&amp;gt;arg2,job-&amp;gt;&lt;span&gt;arg3);
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (job-&amp;gt;&lt;span&gt;arg3)
                lazyfreeFreeSlotsMapFromBioThread(job&lt;/span&gt;-&amp;gt;&lt;span&gt;arg3);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            serverPanic(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Wrong job type in bioProcessBackgroundJobs().&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
        zfree(job);

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Unblock threads blocked on bioWaitStepOfType() if any. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 唤醒所有相关等待线程&lt;/span&gt;
        pthread_cond_broadcast(&amp;amp;&lt;span&gt;bio_step_cond[type]);

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Lock again before reiterating the loop, if there are no longer
         * jobs to process we'll block again in pthread_cond_wait(). &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        pthread_mutex_lock(&lt;/span&gt;&amp;amp;&lt;span&gt;bio_mutex[type]);
        listDelNode(bio_jobs[type],ln);
        bio_pending[type]&lt;/span&gt;--&lt;span&gt;;
    }
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; lazyfree.c, 和同步删除一致了&lt;/span&gt;&lt;span&gt;
/*&lt;/span&gt;&lt;span&gt; Release objects from the lazyfree thread. It's just decrRefCount()
 * updating the count of objects to release. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; lazyfreeFreeObjectFromBioThread(robj *&lt;span&gt;o) {
    decrRefCount(o);
    atomicDecr(lazyfree_objects,&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;,&amp;amp;&lt;span&gt;lazyfree_objects_mutex);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　从此处redis异步处理过程，我们可以看到，redis并不是每次进入异步时都进行异步操作，而是在必要的时候才会进行。这也提示我们，不要为了异步而异步，而是应该计算利弊。&lt;/p&gt;

&lt;p&gt;　　如此，整个 del/unlink 的过程就完成了。总体来说，删除都是基于hash的简单remove而已，唯一有点难度是对内存的回收问题，这其实就是一个简单的使用引用计数器算法实现的垃圾回收器应该做的事而已。勿须多言。具体过程需依赖于数据的存储结构，主要目的自然是递归释放空间，避免内存泄漏了。&lt;/p&gt;
</description>
<pubDate>Thu, 23 Jan 2020 13:24:00 +0000</pubDate>
<dc:creator>等你归去来</dc:creator>
<og:description>上一篇文章从根本上理解了set/get的处理过程，相当于理解了 增、改、查的过程，现在就差一个删了。本篇我们来看一下删除过程。 对于客户端来说，删除操作无需区分何种数据类型，只管进行 del 操作即可</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yougewe/p/12231419.html</dc:identifier>
</item>
<item>
<title>【WPF on .NET Core 3.0】 Stylet演示项目 - 简易图书管理系统(4) - 图书列表界面 - WAKU</title>
<link>http://www.cnblogs.com/waku/p/12231354.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/waku/p/12231354.html</guid>
<description>&lt;p&gt;在前三章中我们完成了登录窗口, 并掌握了使用Conductor来切换窗口, 但这些其实都是在为我们的系统打基础.&lt;/p&gt;
&lt;p&gt;而本章中我们就要开始开发系统的核心功能, 即图书管理功能了.&lt;/p&gt;
&lt;p&gt;通过本章, 我们会接触到以下知识点:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用Stylet内置IoC&lt;/li&gt;
&lt;li&gt;使用ViewModel First解耦UI&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;让我们开始吧!&lt;/p&gt;
&lt;h2 id=&quot;关于ui&quot;&gt;关于UI&lt;/h2&gt;
&lt;p&gt;有朋友说我们的系统界面有点简陋, 有点辜负WPF的美名. 其实UI并不是本系列文章主要关注的内容. 但是既然有朋友指出来, 那么这里就稍微美化一下UI, 这样看起来也赏心悦目一些.&lt;/p&gt;
&lt;p&gt;WPF的UI库有很多, 这里我们使用一个很有名的开源UI库: &lt;a href=&quot;http://materialdesigninxaml.net/&quot;&gt;Material Design In XAML&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;WPF使用UI库是很简单的, 这里就不做过多说明了, 朋友们可直接看代码. 使用后本章最终效果如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/648050/202001/648050-20200123204341435-1305279482.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/648050/202001/648050-20200123204350187-479280582.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;book-model&quot;&gt;Book Model&lt;/h2&gt;
&lt;p&gt;MVVM中第一个M即为Model的意思, 接下来我们就为图书创建Model类, 做为图书信息的模型.&lt;/p&gt;
&lt;ul readability=&quot;11.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;在工程中创建一个名为&quot;Models&quot;的文件夹,并在该文件夹下创建&lt;code&gt;Book&lt;/code&gt;类和&lt;code&gt;BookType&lt;/code&gt;枚举,分别代表图书类和图书类型枚举:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/648050/202001/648050-20200123204411236-1709684135.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;code&gt;Book&lt;/code&gt;类内容如下:&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// 图书
/// &amp;lt;/summary&amp;gt;
public class Book
{
    /// &amp;lt;summary&amp;gt;
    /// 书名
    /// &amp;lt;/summary&amp;gt;
    public string Name { get; set; }

    /// &amp;lt;summary&amp;gt;
    /// 类型
    /// &amp;lt;/summary&amp;gt;
    public BookType Type { get; set; }

    /// &amp;lt;summary&amp;gt;
    /// 出版年月
    /// &amp;lt;/summary&amp;gt;
    public DateTime PublishDate { get; set; }

    /// &amp;lt;summary&amp;gt;
    /// 价格
    /// &amp;lt;/summary&amp;gt;
    public float Price { get; set; }

    /// &amp;lt;summary&amp;gt;
    /// 封面URL
    /// &amp;lt;/summary&amp;gt;
    public string CoverUrl { get; set; }

    public Book(string name, BookType type, DateTime publishDate, float price, string coverUrl)
    {
        Name = name;
        Type = type;
        PublishDate = publishDate;
        Price = price;
        CoverUrl = coverUrl;
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;12&quot;&gt;
&lt;p&gt;&lt;code&gt;BookType&lt;/code&gt;内容如下:&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;    public enum BookType
{
    /// &amp;lt;summary&amp;gt;
    /// 未定义
    /// &amp;lt;/summary&amp;gt;
    Undefined,

    /// &amp;lt;summary&amp;gt;
    /// 传记
    /// &amp;lt;/summary&amp;gt;
    Biography,

    /// &amp;lt;summary&amp;gt;
    /// 奇幻
    /// &amp;lt;/summary&amp;gt;
    Fantastic,

    /// &amp;lt;summary&amp;gt;
    /// 恐怖
    /// &amp;lt;/summary&amp;gt;
    Horror,

    /// &amp;lt;summary&amp;gt;
    /// 科幻
    /// &amp;lt;/summary&amp;gt;
    ScienceFiction,

    /// &amp;lt;summary&amp;gt;
    /// 悬疑
    /// &amp;lt;/summary&amp;gt;
    Mystery,

    /// &amp;lt;summary&amp;gt;
    /// 编程
    /// &amp;lt;/summary&amp;gt;
    Programming,
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;两个文件内容都很简单, 无需做过多解释.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;book服务&quot;&gt;Book服务&lt;/h2&gt;
&lt;p&gt;虽然我们的简易系统并不使用数据库, 但是我们仍然需要将图书信息的获取抽象为一个单独的服务, 这样将来如果要实现从数据库(或其它位置, 如网络)获取图书信息, 只需要提供相关实现即可.&lt;/p&gt;
&lt;ul readability=&quot;21.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;创建一个名为&quot;Services&quot;的文件夹, 并创建&lt;code&gt;IBookService&lt;/code&gt;接口和&lt;code&gt;BookService&lt;/code&gt;实现类&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/648050/202001/648050-20200123204431236-1526973054.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;&lt;code&gt;IBookService&lt;/code&gt;接口定义如下:&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public interface IBookService
{
    IEnumerable&amp;lt;Book&amp;gt; GetAllBooks();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在只需要有一个方法: &lt;code&gt;GetAllBooks&lt;/code&gt; - 获取所有图书&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;29&quot;&gt;
&lt;p&gt;&lt;code&gt;BookService&lt;/code&gt;类实现如下:&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class BookService : IBookService
{
    private readonly List&amp;lt;Book&amp;gt; _bookStore;

    public BookService()
    {
       _bookStore = new List&amp;lt;Book&amp;gt;
       {
           new Book(&quot;阿米尔·汗：我行我素&quot;, BookType.Biography, DateTime.Parse(&quot;2017-6&quot;), 52.8f, &quot;https://img1.doubanio.com/view/subject/l/public/s29467958.jpg&quot;),
           new Book(&quot;三体：“地球往事”三部曲之一&quot;, BookType.ScienceFiction, DateTime.Parse(&quot;2008-1&quot;), 23f, &quot;https://img1.doubanio.com/view/subject/l/public/s2768378.jpg&quot;),
           new Book(&quot;三体Ⅱ：黑暗森林&quot;, BookType.ScienceFiction, DateTime.Parse(&quot;2008-5&quot;), 32f, &quot;https://img3.doubanio.com/view/subject/l/public/s3078482.jpg&quot;),
           new Book(&quot;三体Ⅲ：死神永生&quot;, BookType.ScienceFiction, DateTime.Parse(&quot;2010-11&quot;), 32f, &quot;https://img9.doubanio.com/view/subject/l/public/s26012674.jpg&quot;),
           new Book(&quot;肖申克的救赎&quot;, BookType.Mystery, DateTime.Parse(&quot;2006-7&quot;), 26.9f, &quot;https://img9.doubanio.com/view/subject/l/public/s4007145.jpg&quot;),
       }; 
    }

    public IEnumerable&amp;lt;Book&amp;gt; GetAllBooks()
    {
        return _bookStore;
    }
}    &lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;在构造方法中, 创建一个List用来存储Book信息, 并使用代码初始化图书信息. 实际应用中, 这里一般是从数据库中取得数据.&lt;/li&gt;
&lt;li&gt;GetAllBooks中直接返回list&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;在&lt;code&gt;Bootstrapper&lt;/code&gt;类中的&lt;code&gt;ConfigureIoC&lt;/code&gt;方法中, 注册服务:&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;protected override void ConfigureIoC(IStyletIoCBuilder builder)
{
    // Configure the IoC container in here
    builder.Bind&amp;lt;IBookService&amp;gt;().To&amp;lt;BookService&amp;gt;();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样我们就可以将&lt;code&gt;IBookService&lt;/code&gt;注入到需要使用的类中了.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;book项目&quot;&gt;Book项目&lt;/h2&gt;
&lt;p&gt;MVVM中, 我们可将界面拆解成一个个的小组件, 然后将它们组合在一起形成一个复杂的界面. 这样的好处有很多:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;不同的开发者可负责不同的组件, 便于开发&lt;/li&gt;
&lt;li&gt;每个组件有自己View和ViewModel, 便于测试&lt;/li&gt;
&lt;li&gt;组件可以复用, 提高开发效率&lt;/li&gt;
&lt;li&gt;组件可替换, 便于扩展维护&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;总之, 就是将UI的部分进行解耦, 达到分而治之的目的.&lt;/p&gt;
&lt;p&gt;在未接触MVMM之前, 也许我会将图书显示的UI代码直接放在&lt;code&gt;IndexView&lt;/code&gt;中, 而学习了MVVM之后, 我们就会很自然的想到将&lt;strong&gt;每个图书项目&lt;/strong&gt;的显示做成一个组件, 然后在&lt;code&gt;IndexView&lt;/code&gt;中将所有图书组合成一个列表来显示.&lt;/p&gt;
&lt;p&gt;所以, 接下来看一下是如何创建图书项目的.&lt;/p&gt;
&lt;ul readability=&quot;6&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;在&quot;Pages\Books&quot;文件夹下, 创建&quot;BookItems&quot;文件夹, 并创建一个&lt;code&gt;BookItemViewModel&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class BookItemViewModel : Screen
{
    public Book Book { get; }

    public BookItemViewModel(Book book)
    {
        Book = book;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;该ViewModel非常简单, 通过构造方法接收一个Book model, 然后通过只读属性将Book暴露出来.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;10&quot;&gt;
&lt;p&gt;在同一文件夹内, 创建&lt;code&gt;BookItemView&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;UserControl ...
         d:DataContext=&quot;{d:DesignInstance bookItems:BookItemViewModel}&quot;
         &amp;gt;
    &amp;lt;materialDesign:Card Background=&quot;WhiteSmoke&quot;&amp;gt;
        &amp;lt;Grid&amp;gt;
            &amp;lt;Grid.RowDefinitions&amp;gt;
                &amp;lt;RowDefinition Height=&quot;Auto&quot; /&amp;gt;
                &amp;lt;RowDefinition Height=&quot;Auto&quot; /&amp;gt;
            &amp;lt;/Grid.RowDefinitions&amp;gt;
            &amp;lt;Image
                Margin=&quot;0 10 0 0&quot;
                Source=&quot;{Binding Book.CoverUrl}&quot;
                Height=&quot;150&quot;
                Stretch=&quot;Uniform&quot; /&amp;gt;
            &amp;lt;DockPanel Grid.Row=&quot;1&quot;&amp;gt;
                &amp;lt;TextBlock Margin=&quot;0 10 0 0&quot; DockPanel.Dock=&quot;Top&quot; FontWeight=&quot;Bold&quot; Text=&quot;{Binding Book.Name}&quot; HorizontalAlignment=&quot;Center&quot;&amp;gt;&amp;lt;/TextBlock&amp;gt;
                &amp;lt;TextBlock Text=&quot;{Binding Book.Price, StringFormat='￥{0}'}&quot; Margin=&quot;0 20 10 10&quot; Foreground=&quot;Red&quot; FontWeight=&quot;Bold&quot; VerticalAlignment=&quot;Bottom&quot; HorizontalAlignment=&quot;Right&quot;&amp;gt;&amp;lt;/TextBlock&amp;gt;
            &amp;lt;/DockPanel&amp;gt;
        &amp;lt;/Grid&amp;gt;
    &amp;lt;/materialDesign:Card&amp;gt;
&amp;lt;/UserControl&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;使用UserControl做为图书组件&lt;/li&gt;
&lt;li&gt;与Login类似, 使用d:DataContext指定&lt;code&gt;BookItemViewModel&lt;/code&gt;为设计时实例, 为XAML提供智能提示&lt;/li&gt;
&lt;li&gt;使用MaterialDesign提供的Card控件来做为图书项目UI的容器&lt;/li&gt;
&lt;li&gt;然后分别显示了图书的封面, 书名和价格. 这里未用到Stylet的功能, 都是使用了WPF基本的绑定语法&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;实际开发中, 可充分利用第一章中讲解的Hot Reload功能, 在运行时调整XAML.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;完成后的工程结构是这样的:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/648050/202001/648050-20200123205408065-1905568048.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;book列表&quot;&gt;Book列表&lt;/h2&gt;
&lt;p&gt;有了图书项目组件, 我们就可以来填充图书列表了.&lt;/p&gt;
&lt;p&gt;我们使用ListView来显示图书信息, WPF中的ListView是一个非常灵活的控件, 配合WPF强大的模板特性, 在展现集合数据时, 几乎可以实现任何效果.&lt;/p&gt;
&lt;ul readability=&quot;6&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;改造&lt;code&gt;IndexViewModel&lt;/code&gt;如下:&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class IndexViewModel : Screen
{
    private readonly IBookService _bookService;
    public ObservableCollection&amp;lt;BookItemViewModel&amp;gt; BookItems { get; set; } = new ObservableCollection&amp;lt;BookItemViewModel&amp;gt;();

    public IndexViewModel(IBookService bookService)
    {
        _bookService = bookService;
    }

    protected override void OnViewLoaded()
    {
        var viewModels = _bookService.GetAllBooks()
                .Select(book =&amp;gt; new BookItemViewModel(book))
            ;

        BookItems = new ObservableCollection&amp;lt;BookItemViewModel&amp;gt;(viewModels);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;为图书项目创建一个&lt;code&gt;ObservableCollection&lt;/code&gt;类型的属性, 名为&lt;code&gt;BookItems&lt;/code&gt;. 使用ObservableCollection可以在图书增加或减少时自动发送通知&lt;/li&gt;
&lt;li&gt;在构造方法中, 注入&lt;code&gt;IBookService&lt;/code&gt;, 并存储为成员变量&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;OnViewLoaded&lt;/code&gt;方法中, 调用&lt;code&gt;IBookService.GetAllBooks&lt;/code&gt;然后转换成图书列表ViewModel&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;改造&lt;code&gt;IndexView&lt;/code&gt;如下:&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;UserControl 
    ...
    &amp;gt;
    &amp;lt;ListView ItemsSource=&quot;{Binding BookItems}&quot; ScrollViewer.HorizontalScrollBarVisibility=&quot;Disabled&quot;&amp;gt;
        &amp;lt;ListView.ItemsPanel&amp;gt;
            &amp;lt;ItemsPanelTemplate&amp;gt;
                &amp;lt;WrapPanel/&amp;gt;
            &amp;lt;/ItemsPanelTemplate&amp;gt;
        &amp;lt;/ListView.ItemsPanel&amp;gt;
        &amp;lt;ListView.ItemTemplate&amp;gt;
            &amp;lt;DataTemplate&amp;gt;
                &amp;lt;ContentControl s:View.Model=&quot;{Binding}&quot;&amp;gt;&amp;lt;/ContentControl&amp;gt;
            &amp;lt;/DataTemplate&amp;gt;
        &amp;lt;/ListView.ItemTemplate&amp;gt;
    &amp;lt;/ListView&amp;gt;
&amp;lt;/UserControl&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;将ListView的ItemSource绑定到&lt;code&gt;IndexViewModel&lt;/code&gt;中&lt;code&gt;BookItems&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;ContentControl&lt;/code&gt;做为ListView.ItemTemplate的数据模板
&lt;ul&gt;&lt;li&gt;同&lt;code&gt;ShellView&lt;/code&gt;中的写法类似, 使用Stylet提供的&lt;code&gt;s:View.Model&lt;/code&gt;为ContentControl绑定一个ViewModel(这里即是BookItemViewModel), Stylet会自动为该ContentControl加载View(即BookItemView)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;可以看到, IndexView并不知道BookItemView的存在, 一切都是由后面的ViewModel关联在一起的, 这样我们就实现了View之间的解耦.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;最后运行程序, 确认运行正常.&lt;/p&gt;
&lt;p&gt;本章的任务就完成了. 在本章中, 我们创建了一个图书组件, 并使用ViewModel First来驱动各个UI部分.下一章中我们会讲解Master-Detail这种经典的数据表现形式. 希望朋友们能多多留言, 交流心得. 源码托管在&lt;a href=&quot;https://github.com/wakuflair/MyBlogDemoCode/tree/Chapter4/StyletBookStore&quot;&gt;GITHUB&lt;/a&gt;上.&lt;/p&gt;
&lt;p&gt;Happy Coding~&lt;/p&gt;
</description>
<pubDate>Thu, 23 Jan 2020 13:03:00 +0000</pubDate>
<dc:creator>WAKU</dc:creator>
<og:description>在前三章中我们完成了登录窗口, 并掌握了使用Conductor来切换窗口, 但这些其实都是在为我们的系统打基础. 而本章中我们就要开始开发系统的核心功能, 即图书管理功能了. 通过本章, 我们会接触到</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/waku/p/12231354.html</dc:identifier>
</item>
<item>
<title>托管对象本质-第一部分-布局 - 杰哥很忙</title>
<link>http://www.cnblogs.com/Jack-Blog/p/12230616.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Jack-Blog/p/12230616.html</guid>
<description>&lt;hr/&gt;&lt;hr/&gt;
&lt;blockquote readability=&quot;2.5490196078431&quot;&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;https://devblogs.microsoft.com/premier-developer/managed-object-internals-part-1-layout/&quot; class=&quot;uri&quot;&gt;https://devblogs.microsoft.com/premier-developer/managed-object-internals-part-1-layout/&lt;/a&gt;&lt;br/&gt;原文作者：Sergey&lt;br/&gt;译文作者：杰哥很忙&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;目录&quot;&gt;目录&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/Jack-Blog/p/12230616.html&quot;&gt;托管对象本质1-布局&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/Jack-Blog/p/12230616.html&quot;&gt;托管对象本质2-对象头布局和锁成本&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/Jack-Blog/p/12230616.html&quot;&gt;托管对象本质3-托管数组结构&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/Jack-Blog/p/12230616.html&quot;&gt;托管对象本质4-字段布局&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;托管对象的布局非常简单：托管对象包含实例数据、指向元数据的指针（也称为方法表指针）和内部信息包（也称为对象头）。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;译者补充: 方法表指针在某些文章也被称之为类型句柄，英文是TypeHandle。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://devblogs.microsoft.com/wp-content/uploads/sites/31/2019/06/clip_image002_thumb9.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当我第一次看到对象的布局时，我产生了一些疑问：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;为什么对象的布局如此怪异？&lt;/li&gt;
&lt;li&gt;为什么托管引用指向对象的中间，而对象头的偏移量为负？&lt;/li&gt;
&lt;li&gt;对象头中存储了哪些信息？&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;译者补充:作者对于布局怪异实际指的就是对象头的偏移量为负数。由于托管对象以引用地址的偏移量记为0，对象头大小为4或8字节(取决于是32位还是64位，实际64位对象头也仅使用4字节，前面4个字节填充0)。因此由于对象头在对象指针之前，因此它的偏移量位-4或-8。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当我开始思考布局并做了一个快速研究时，我只有几个选择：&lt;/p&gt;
&lt;ol readability=&quot;2.7747989276139&quot;&gt;&lt;li readability=&quot;3.1601239669421&quot;&gt;
&lt;p&gt;JVM 从一开始就对托管对象使用了类似的布局。&lt;br/&gt;今天听起来有点疯狂，但请记住，由于Java早就有了一个特性（又名&lt;a href=&quot;http://www.voidcn.com/article/p-yjocauww-buv.html&quot;&gt;数组协方差&lt;/a&gt;），C#在借鉴Java语言时也引用了这一有史以来最糟糕的特性。与这个决定相比，重用一些关于对象结构的想法听起来并不合理。&lt;/p&gt;
&lt;blockquote readability=&quot;4.72&quot;&gt;
&lt;p&gt;译者补充:数组协方差可能存在无法保证类型安全，从而产生一个运行时异常。详情可以看&lt;a href=&quot;http://www.voidcn.com/article/p-yjocauww-buv.html&quot;&gt;与C#数组的协方差和逆差&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;3.3350168350168&quot;&gt;
&lt;p&gt;对象头的大小可以增大，而在 CLR 中没有横切更改。&lt;br/&gt;对象头包含 CLR 使用的一些辅助信息，CLR 可能需要比指针大小字段更多的信息。事实上，移动电话中使用的 .Net Compact Framework 对于大小对象具有不同的头（有关详细信息，请参阅 &lt;a href=&quot;https://blogs.msdn.microsoft.com/abhinaba/2012/02/02/wp7-clr-managed-object-overhead/&quot;&gt;WP7：CLR 托管对象开销&lt;/a&gt;）。桌面 CLR 从未使用过此功能，但这并不意味着将来不可能实现此功能。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;译者补充:这里说的CLR没有根据切面大小改变对象头，指的是桌面CLR，因为移动设备的CLR会根据对象大小改变对象头的布局。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;-0.76923076923077&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/mba16c35/article/details/40894949&quot;&gt;缓存行&lt;/a&gt;和其他性能相关特征。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;a href=&quot;https://devblogs.microsoft.com/cbrumme/&quot;&gt;Chris Brumme&lt;/a&gt; – CLR 架构师之一，在他的发表的&lt;a href=&quot;https://devblogs.microsoft.com/cbrumme/value-types/&quot;&gt;Value Types&lt;/a&gt;的评论中提到，缓存友好性正是托管对象布局的原因。从理论上讲，由于缓存行大小（64 字节），访问彼此较近的字段的效率可能更高。这意味着根据字段在对象中的位置不同，访问间接引用字段会有不同的性能差异。我花了一些时间试图证明对于现代处理器该理论依据仍然是成立的，但无法获得任何能够显示存在的差异基准测试数据。&lt;/p&gt;
&lt;p&gt;花了一些时间试图验证我的理论后，我联系了&lt;a href=&quot;https://blogs.msdn.microsoft.com/vancem/&quot;&gt;Vance Morrison&lt;/a&gt;问这个问题，并得到了以下的答案：目前的设计没有特别考虑。&lt;/p&gt;
&lt;p&gt;因此，对于&quot;为什么托管对象的布局如此怪异？&quot;的一个简单回答是由于历史原因造成的。老实说，我可以看到在负索引移动对象头的逻辑，以强调此数据块是 CLR 的实现细节，它的大小可以随时间而变化，并且不应由用户检查。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;译者补充:原作者说的是由于历史原因造成的也没有毛病，因为非托管代码就包含了对象头和对象引用地址，因此托管代码延续了这一风格。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;现在是时候审视布局的更多细节了。再次之前，我们思考一下，CLR可以与托管对象实例关联哪些额外信息？以下是一些想法:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;GC可以用来标记可从应用程序根访问对象的特殊标志。&lt;/li&gt;
&lt;li&gt;一种特殊的标志用于通知GC某个对象已固定，在垃圾收集期间不应移动。&lt;/li&gt;
&lt;li&gt;托管对象的哈希代码（当未重写GetHashCode方法时）。&lt;/li&gt;
&lt;li&gt;锁语句使用的关键节和其他信息：获取锁的线程等。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;除了实例状态之外，CLR还存储了许多与类型相关的信息，如方法表、接口映射、实例大小等等，但这与我们当前的讨论无关。&lt;/p&gt;
&lt;h2 id=&quot;ismarked-标记&quot;&gt;IsMarked 标记&lt;/h2&gt;
&lt;p&gt;托管对象头可用于多种不同的用途。你可能认为垃圾收集器（GC）使用对象头中的一个位来标记该对象是由根引用的，并且应该保持活动状态。这是一种常见的误解，只有少量的名著提及。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;比如Jeffrey Richter写的《CLR via C#》, 《Pro .NET Performance》作者是Sasha Goldstein，当然还有一些其他人.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;CLR 作者决定不使用对象头，而是使用一个巧妙的技巧：方法表指针的最低位用于存储在垃圾回收期间存储对象可访问且不应被回收的标志。&lt;/p&gt;
&lt;p&gt;下面是来自Coreclr的一个mark标记的实现，在文件&lt;a href=&quot;https://github.com/dotnet/coreclr/blob/a6c2f7834d338e08bf3dcf9dedb48b2a0c08fcfa/src/gc/gc.cpp&quot;&gt;gc.cpp&lt;/a&gt;的8974行:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#define marked(i) header(i) -&amp;gt; IsMmarked();
#define set_marked(i) header(i)-&amp;gt;SetMarked()
#define clear_marked(i) header(i)-&amp;gt;ClearMarked()
 
// class CObjectHeader
BOOL IsMarked() const
{
    return !!(((size_t)RawGetMethodTable()) &amp;amp; GC_MARKED);
}
void ClearMarked()
{
    RawSetMethodTable(GetMethodTable());
}
void SetMarked()
{
    RawSetMethodTable((MethodTable*)(((size_t)RawGetMethodTable()) | GC_MARKED));
}
MethodTable* GetMethodTable() const
{
    return((MethodTable*)(((size_t)RawGetMethodTable()) &amp;amp; (~(GC_MARKED))));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/580757/202001/580757-20200123114440473-281359752.png&quot; alt=&quot;20200123114440.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;由于gc.cpp文件太大导致GitHub不分析它。 这意味着我不能将超链接添加到特定代码行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;CLR 堆中的托管指针以4个或8个字节地址长度进行对齐，取决于32位还是64位平台。这意味着每个指针的 2 或 3 位始终为 0，可用于其他目的。JVM 也使用同样的技巧，称为&quot;&lt;a href=&quot;https://blog.csdn.net/liuxiao723846/article/details/91981757&quot;&gt;压缩 Oops&lt;/a&gt;&quot;，该功能允许 JVM 具有 32 GB 堆大小，并且仍使用 4 个字节作为托管指针。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;译者补充:当我们在对象上标注StructLayout以控制对象的分布甚至偏移值。若对象没有填满4字节或8字节时，CLR会进行自动填充。&lt;br/&gt;&lt;span&gt;“这意味着每个指针的 2 或 3 位始终为 0，可用于其他目的。”&lt;/span&gt;对于这句话的解释，个人理解如下：由于64位指针最多支持2^64^内存，即16TiB的内存大小，而对于windows系统则有软件上的内存大小限制，windows7旗舰版支持192GB的内存，而windows server 2008 R2支持2TiB内存大小，Windows Server 2012提高到4TiB的最大内存限制。因此可以如作者所说，windows 64位操作系统预留了2到3位指针用于其他目的，因此最大内存支持4TiB。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从技术上讲，即使在 32 位平台上，也有 2 位可用于标志。基于 object.h 文件的注释，我们可以认为确实如此，并且方法表指针的第二个最低位用于固定（以标记在垃圾回收的压缩阶段不应移动对象）。不幸的是，并不能判断该说法是否正确，因为来自 gc.cpp（行 3850-3859）的 SetPinned/IsPinned 方法基于对象头中的保留位实现，并且我无法在 coreclr 代码版本库中找到实际设置方法表指针位的任何代码。&lt;/p&gt;
&lt;p&gt;下次我们会讨论所得实现以及锁的性能消耗大小。&lt;/p&gt;
&lt;h2 id=&quot;相关文献&quot;&gt;相关文献&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/melao2006/p/4241661.html&quot;&gt;数组协方差&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/mba16c35/article/details/40894949&quot;&gt;CPU高速缓存行对齐(cache line)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/happyhippy/archive/2007/04/12/710929.html&quot;&gt;类型实例的创建位置、托管对象在托管堆上的结构&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/happyhippy/archive/2007/04/12/710927.html&quot;&gt;.net托管环境下struct实例字段的内存布局(Layout)和大小(Size)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/happyhippy/archive/2007/04/17/717028.html&quot;&gt;托管堆上对象的大小(Size)和Layout&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/vowei/p/4471338.html&quot;&gt;.NET对象的内存布局&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/archive/msdn-magazine/2005/may/net-framework-internals-how-the-clr-creates-runtime-objects&quot;&gt;.NET Framework Internals: How the CLR Creates Runtime Objects&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://superuser.com/questions/710955/what-limits-windows-7-x64-machines-to-192gb-ram&quot;&gt;What limits Windows 7 x64 machines to &amp;lt;=192GB RAM?&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;&lt;blockquote readability=&quot;5.594262295082&quot;&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/580757/201911/580757-20191127212135806-961496201.png&quot; alt=&quot;20191127212134.png&quot;/&gt;&lt;br/&gt;微信扫一扫二维码关注订阅号杰哥技术分享&lt;br/&gt;出处：&lt;a href=&quot;https://www.cnblogs.com/Jack-Blog/p/12230616.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/Jack-Blog/p/12230616.html&lt;/a&gt;&lt;br/&gt;作者：杰哥很忙&lt;br/&gt;本文使用「CC BY 4.0」创作共享协议。欢迎转载，请在明显位置给出出处及链接。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 23 Jan 2020 06:52:00 +0000</pubDate>
<dc:creator>杰哥很忙</dc:creator>
<og:description>本文对CLR托管对象的布局进行讲解</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Jack-Blog/p/12230616.html</dc:identifier>
</item>
<item>
<title>漫画 | 什么是散列表（哈希表）？ - 我脱下短袖</title>
<link>http://www.cnblogs.com/wotxdx/p/12230486.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wotxdx/p/12230486.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1890852/202001/1890852-20200123125333786-1159563174.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1890852/202001/1890852-20200123125347410-4447833.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1890852/202001/1890852-20200123125359216-429332961.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://q3zes9i1x.bkt.clouddn.com/FnYehyVmqo3BkCtEF9jOMuyApkeu&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1890852/202001/1890852-20200123125436989-1891599455.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;创建与输入数组相等长度的新数组，作为直接寻址表。两数之和的期望是Target，将Target依次减输入数组的元素，得到的值和直接寻址表比较，如果寻址表存在这个值则返回；如果不存在这个值则将输入数组中的元素插入寻址表，再进行输入数组中的下一个元素。&lt;/p&gt;
&lt;p&gt;再进一步优化可以将输入数组直接作为直接寻址表，控制对应的下标就好，代码如下：&lt;/p&gt;
&lt;h5 id=&quot;code直接寻址表&quot;&gt;Code：直接寻址表&lt;/h5&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class Solution {
        public int[] twoSum(int[] nums, int target) {
        for (int i = 1; i &amp;lt; nums.length; i++) {
            int temp = target - nums[i];
            for (int j = 0; j &amp;lt; i; j++) {
                if (temp == nums[j]) return new int[]{j, i};
            }
        }
        return null;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;动画直接寻址表&quot;&gt;动画：直接寻址表&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1890852/202001/1890852-20200123125441056-1866135903.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;数组里面每一个槽位放的是8个字节，用于一个指向外部类的引用。这个外部类可以是链表对象，也可以是红黑树对象，都可以存一个或者一个以上的元素，也可以是空链表或空树。散列表在某种意义上需要的数组空间可以比直接寻址表要少的很多。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1890852/202001/1890852-20200123125444964-1451574710.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;散列函数是将所有元素的键转换为自然数，自然数的数集是{0，1，2，……}。&lt;/p&gt;
&lt;p&gt;如果所有元素的键是正整数，最常用的方法是求模（除留余数法）。我们选择长度为素数M的数组，对于任意正整数k，计算k mod M求得余数；&lt;/p&gt;
&lt;p&gt;如果所有元素的键是浮点数，我们将它表示为二进制数，忽略小数点再转化为十进制，然后求模；&lt;/p&gt;
&lt;p&gt;如果所有元素的键是字符串，可以将它字符串里面的每一个字符通过ASCII码转换，并相加得到这个字符串的hash，然后求模；&lt;/p&gt;
&lt;p&gt;如果所有元素的键是对象或者组合键（对象里面的是属性类型不定），也可以通过上面的方法混合起来。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1890852/202001/1890852-20200123125453792-1484789041.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;除了线性探测法，还有二次探测还有双重探测。&lt;/p&gt;
&lt;p&gt;线性探测法是，通过散列函数得到散列值，检查这个散列值是否被占用，如果被占用，将索引增大，到达数组结尾时折回数组的开头，直到找到没有被占用的散列值。&lt;/p&gt;
&lt;p&gt;线性探测采用的散列函数为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1890852/202001/1890852-20200123125454021-86283778.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中h`(k)是第一次通过散列函数得到的散列值。&lt;/p&gt;
&lt;p&gt;二次探测采用的散列函数为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1890852/202001/1890852-20200123125454184-2101761681.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;双重探测采用的散列函数为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1890852/202001/1890852-20200123125454308-513188388.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1890852/202001/1890852-20200123125454438-1580183604.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1890852/202001/1890852-20200123125457129-1663044431.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;键簇，是指元素在插入数组后聚集成的一组连续的条目，决定线性探测的平均成本。&lt;/p&gt;
&lt;p&gt;如下图所示，插入之前已经看到了两个比较长的键簇，如果待插入元素通过散列函数得到的散列值正好是这两个键簇中的第一个位置，就需要探测很多次才能找到空的位置；如果落在了两个键簇间的只有一个空位置，那就产生了更长的键簇，对线性探测的平均成本大大增加。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1890852/202001/1890852-20200123125459073-1855150553.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;显然，短小的键簇才能保证较高的效率，不管是插入、查找还是删除算法。随着插入的键越来越多，较长的键簇越来越多，有可能插入一个元素就将两个很长的键簇合并。所以才有了两次探测和双重探测，可以降低这种情况出现。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1890852/202001/1890852-20200123125504258-812870800.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;动态空间处理其实就是改变数组的长度，可以设定一个构造函数，这个构造函数可以接受一个固定的容量作为参数。&lt;/p&gt;
&lt;p&gt;M是目前散列表数组的长度，N是目前在散列表已插入元素的个数。如何扩容和缩容可以设定一个条件，如果N/M &amp;gt;= 上边界，即平均每个槽承载元素超过一定程度，就进行扩容；如果N/M &amp;lt;= 下边界，即平均每个槽承载元素降到一定程度，就进行缩容。&lt;/p&gt;
&lt;p&gt;扩容和缩容都会创建一个新的长度M的散列表，散列函数也会因为M而改变，原来的所有元素通过新的散列函数重新散列并插入新的散列表中。&lt;/p&gt;
&lt;h5 id=&quot;动画动态空间处理&quot;&gt;动画：动态空间处理&lt;/h5&gt;
&lt;p&gt;Java 8之前，每一个槽对应一个链表；&lt;/p&gt;
&lt;p&gt;Java 8开始之后，当哈希冲突达到一定程度时，每一个位置槽从链表转成红黑树。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1890852/202001/1890852-20200123125506389-1559689098.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;面试官很客气，一直送我到门口，我依依不舍地离开这个地方。嗯，面试官真是个好人。&lt;/p&gt;
&lt;p&gt;我出去大门，看见一个面试者在拿着A4纸一直默读，我想那个面试官待会要面这个人吧。小伙子，你运气真好，希望你面试成功。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1890852/202001/1890852-20200123125513692-1742795849.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;场景虚构，如有雷同，实属巧合&lt;/p&gt;
&lt;p&gt;-----完结-----&lt;/p&gt;
&lt;p&gt;喜欢本文的朋友，欢迎关注公众号 @ 算法无遗策，和我们一起学数据结构、刷算法题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1890852/202001/1890852-20200123125514360-1485610423.png&quot;/&gt;&lt;br/&gt;喜欢本文的朋友，欢迎关注公众号「算法无遗策」，收看更多精彩内容&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1890852/202001/1890852-20200123125514466-1558787045.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 23 Jan 2020 04:55:00 +0000</pubDate>
<dc:creator>我脱下短袖</dc:creator>
<og:description>创建与输入数组相等长度的新数组，作为直接寻址表。两数之和的期望是Target，将Target依次减输入数组的元素，得到的值和直接寻址表比较，如果寻址表存在这个值则返回；如果不存在这个值则将输入数组中的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wotxdx/p/12230486.html</dc:identifier>
</item>
<item>
<title>动画 | 什么是红黑树？（与2-3-4树等价） - 我脱下短袖</title>
<link>http://www.cnblogs.com/wotxdx/p/12230482.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wotxdx/p/12230482.html</guid>
<description>&lt;p&gt;二分搜索树是为了快速查找而生，它是一颗二叉树，每一个节点只有一个元素（值或键值对），左子树所有节点的值均小于父节点的值，右子树所有的值均大于父节点的值，左右子树也是一颗二分搜索树，而且没有键值相等的节点。它的查找、插入和删除的时间复杂度都与树高成比例，期望值是O(log n)。&lt;/p&gt;
&lt;p&gt;但是插入数组如[]，二分搜索树的缺点就暴露出来了，二分搜索树退化成线性表，查找的时间复杂度达到最坏时间复杂度O(n)。&lt;/p&gt;
&lt;h5 id=&quot;动画二分搜索树退化成线性表&quot;&gt;动画：二分搜索树退化成线性表&lt;/h5&gt;

&lt;p&gt;那有没有插入和删除操作都能保持树的完美平衡性（任何一个节点到其叶子节点的路径长度都是相等的）？&lt;/p&gt;
&lt;p&gt;有，B树。B树是一种自平衡的树，根节点到其叶子节点的路径高度都是一样的，能够保持数据有序（通过中序遍历能得到有序数据）。B树一个节点可以拥有2个以上的子树，如2-3树、2-3-4树甚至2-3-4-5-6-7-8树，它们满足二分搜索树的性质，但它们不属于二叉树，也不属于二分搜索树。&lt;/p&gt;
&lt;p&gt;2-3-4树的完美平衡，每条从根节点到叶子节点的路径的高度都是一样的&lt;/p&gt;
&lt;p&gt;2-3-4树有以下节点组成：&lt;/p&gt;
&lt;p&gt;2-节点，含有一个元素（值或键值对）和两个子树（左右子树），左子树所有的值均小于父节点的值，右子树所有的值均大于父节点的值；&lt;/p&gt;
&lt;p&gt;3-节点，含有两个元素和三个子树，左子树所有的值均小于父节点最小元素的值，中间子树所有的值均位于父节点两个元素之间，右子树所有的值均大于父节点最大元素的值；&lt;/p&gt;
&lt;p&gt;4-节点，含有三个元素和四个子树，节点之间的比较也满足二分搜索树的性质。&lt;/p&gt;
&lt;h5 id=&quot;树查找算法&quot;&gt;2-3-4树查找算法&lt;/h5&gt;
&lt;p&gt;2-3-4树的查找类似二分搜索树的查找。&lt;/p&gt;
&lt;h5 id=&quot;树插入算法&quot;&gt;2-3-4树插入算法&lt;/h5&gt;
&lt;p&gt;2-3-4树的插入算法是消除当前节点是4-节点，将4-节点分解成多个2-节点，中间的2-节点与父节点合并成3-节点或4-节点。&lt;/p&gt;
&lt;p&gt;沿着链接向下进行变换分解4-节点分为两种情况：&lt;/p&gt;
&lt;p&gt;1）4-节点作为根节点，分解成3个2-节点，中间的2-节点作为根节点；&lt;/p&gt;
&lt;p&gt;2）当前节点为4-节点，分解成3个2-节点，中间的2-节点与父节点合并成3-节点或4-节点；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1890852/202001/1890852-20200123124832510-1213872448.png&quot; alt=&quot;file&quot;/&gt;&lt;br/&gt;图：沿着链接向下进行变换，分解4-节点&lt;/p&gt;
&lt;p&gt;在沿着左右链接向下进行变换的同时，也会进行命中查找。如果元素是键值对的话，查找命中将旧的值赋值为新的值；如果元素是一个值的话，查找命中将忽略之，因为二分搜索树需要满足没有相等的元素；如果需要支持重复的元素，则在元素对象添加count属性，默认为1。&lt;/p&gt;
&lt;p&gt;如果查找未命中，则将待插入元素插入在叶子节点上。树底下插入一个元素只有两种情况：向2-节点中插入和向3-节点中插入。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1890852/202001/1890852-20200123124832709-270318577.png&quot; alt=&quot;file&quot;/&gt;&lt;br/&gt;图：树底下插入一个元素&lt;/p&gt;
&lt;h5 id=&quot;树删除算法&quot;&gt;2-3-4树删除算法&lt;/h5&gt;
&lt;p&gt;2-3-4树的删除算法是消除当前节点是2-节点，向兄弟节点或父节点借一个元素过来。&lt;/p&gt;
&lt;h5 id=&quot;删除最小元素&quot;&gt;删除最小元素&lt;/h5&gt;
&lt;p&gt;从根节点的左孩子开始，沿着左链接向下进行变换可以分为三种情况：&lt;/p&gt;
&lt;p&gt;1）当前节点不是2-节点，跳过；&lt;/p&gt;
&lt;p&gt;2）当前节点是2-节点，兄弟节点是2-节点，将当前节点、父节点最小元素和兄弟节点合并为4-节点，当前节点变换成4-节点；&lt;/p&gt;
&lt;p&gt;3）当前节点是2-节点，兄弟节点不是2-节点，将兄弟节点的最小元素移到父节点，父节点的最小元素移到当前节点，当前节点变换成3-节点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1890852/202001/1890852-20200123124832877-297087730.png&quot; alt=&quot;file&quot;/&gt;&lt;br/&gt;图：沿着左链接向下进行变换&lt;/p&gt;
&lt;h5 id=&quot;删除最大元素&quot;&gt;删除最大元素&lt;/h5&gt;
&lt;p&gt;从根节点的右孩子开始，沿着右链接向下进行变换也同样分为三种情况：&lt;/p&gt;
&lt;p&gt;1）当前节点不是2-节点，跳过；&lt;/p&gt;
&lt;p&gt;2）当前节点是2-节点，兄弟节点是2-节点，将当前节点、父节点的最大元素和兄弟节点合并为4-节点，当前节点变换成4-节点；&lt;/p&gt;
&lt;p&gt;3）当前节点是2-节点，兄弟节点不是2-节点，将兄弟节点的最大元素移到父节点，父节点的最大元素移到当前节点，当前节点变换成3-节点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1890852/202001/1890852-20200123124833051-1815289373.png&quot; alt=&quot;file&quot;/&gt;&lt;br/&gt;图：沿着右链接向下进行变换&lt;/p&gt;
&lt;h5 id=&quot;删除任意元素&quot;&gt;删除任意元素&lt;/h5&gt;
&lt;p&gt;学习过删除最小元素和删除最大元素算法之后，删除任意元素的算法自然就简单了。删除任意元素算法需要先进行命中查找，若查找命中，则将右子树的最小值替换掉待删除元素，然后将右子树进行删除最小元素的算法。&lt;/p&gt;
&lt;p&gt;2-3-4树虽满足二分搜索树的性质，但不是一颗二分搜索树。如果期望它是一颗二分搜索树，就需要将3-节点和4-节点替换为多个2-节点，还需要注明元素之间的关系（用红链接表示）。&lt;/p&gt;
&lt;h5 id=&quot;替换3-节点和4-节点&quot;&gt;替换3-节点和4-节点&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1890852/202001/1890852-20200123124833463-540453117.png&quot; alt=&quot;file&quot;/&gt;&lt;br/&gt;图：替换3-节点&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1890852/202001/1890852-20200123124833635-934260014.png&quot; alt=&quot;file&quot;/&gt;&lt;br/&gt;图：替换4-节点&lt;/p&gt;
&lt;p&gt;但是存在一个问题，2-3-4树因为3-节点的不同表示会有很多种不同的红黑树，3-节点既可以左倾，也可以右倾。所以为了保证树的唯一性，3-节点只考虑左倾，当然你也可以只考虑右倾。&lt;/p&gt;
&lt;p&gt;这样对于任何一颗2-3-4树，只考虑左倾的情况下，都能得到唯一的一颗对应的红黑树，这种树也叫左倾红黑树，相对比较减少了复杂性，设计更容易被实现。&lt;/p&gt;
&lt;h5 id=&quot;红黑树查找算法&quot;&gt;红黑树查找算法&lt;/h5&gt;
&lt;p&gt;红黑树的查找算法和二分搜索树一样。&lt;/p&gt;
&lt;p&gt;关于链接的颜色变换只跟颜色转换有关，而旋转不会改变链接的颜色变换，只在被红链接指向的节点变成红色，被黑链接指向的节点变成黑色。&lt;/p&gt;
&lt;h5 id=&quot;旋转&quot;&gt;旋转&lt;/h5&gt;
&lt;p&gt;旋转是将不满足红黑树性质的3-节点和4-节点进行旋转，如果3-节点出现右链接，则将右链接通过左旋转变成左链接；如果4-节点出现一个红节点连着两条红链接，则将4-节点配平。&lt;/p&gt;
&lt;h5 id=&quot;左旋转&quot;&gt;左旋转&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1890852/202001/1890852-20200123124833811-452732363.png&quot; alt=&quot;file&quot;/&gt;&lt;br/&gt;图：左旋转&lt;/p&gt;
&lt;h5 id=&quot;右旋转&quot;&gt;右旋转&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1890852/202001/1890852-20200123124833988-2042828755.png&quot; alt=&quot;file&quot;/&gt;&lt;br/&gt;图：右旋转&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1890852/202001/1890852-20200123124834420-732165207.png&quot; alt=&quot;file&quot;/&gt;&lt;br/&gt;图：3-节点和4-节点的旋转&lt;/p&gt;
&lt;h5 id=&quot;code右旋转和左旋转&quot;&gt;Code：右旋转和左旋转&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1890852/202001/1890852-20200123124835616-1146767207.png&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;颜色转换&quot;&gt;颜色转换&lt;/h5&gt;
&lt;p&gt;颜色转换只应用于4-节点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1890852/202001/1890852-20200123124835815-123340828.png&quot; alt=&quot;file&quot;/&gt;&lt;br/&gt;图：颜色转换&lt;/p&gt;
&lt;h5 id=&quot;code颜色转换&quot;&gt;Code：颜色转换&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1890852/202001/1890852-20200123124836300-1437814193.png&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;红黑树插入算法&quot;&gt;红黑树插入算法&lt;/h5&gt;
&lt;p&gt;回顾之前的2-3-4树的插入算法，它有两个过程：沿着链接向下进行分解4-节点和树底下插入一个元素。&lt;/p&gt;
&lt;p&gt;红黑树的插入算法和2-3-4树的插入算法类似，它不仅包含前面两个过程，还增加了向上进行变换的过程，此过程是将3-节点左倾和4-节点配平。&lt;/p&gt;
&lt;p&gt;红黑树插入算法会先从根节点开始，沿着左右链接向下进行变换，目的是为了分解4-节点。如果该节点的左右孩子都是红节点，则通过flipColors方法进行颜色转换，接着进行下一个子节点；如果不是，则直接进行下一个子节点。&lt;/p&gt;
&lt;p&gt;到达树底的时候，则意味着可以开始插入新的元素。&lt;/p&gt;
&lt;p&gt;如果红黑树目前是一颗空树，插入红色的元素作为第一个节点，然后该节点变成黑色。如果不是一颗空树，插入元素分为三种情况：向2-节点插入新元素、向3-节点插入新元素和向4-节点插入新元素。&lt;/p&gt;
&lt;h5 id=&quot;向2-节点插入新元素&quot;&gt;向2-节点插入新元素&lt;/h5&gt;
&lt;p&gt;向2-节点插入新元素很简单，如果新元素的值小于父节点，直接插入红色的节点即可；如果新元素的值大于父节点，则产生一个红色右链接，插完之后则将3-节点进行左旋转，将右链接变成左链接，被红链接指向的节点变成红色，被黑链接指向的节点变成黑色。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1890852/202001/1890852-20200123124836782-201340482.png&quot; alt=&quot;file&quot;/&gt;&lt;br/&gt;图：向2-节点插入新元素&lt;/p&gt;
&lt;h5 id=&quot;向3-节点插入新元素&quot;&gt;向3-节点插入新元素&lt;/h5&gt;
&lt;p&gt;因为前面的3-节点进行过旋转，此时的3-节点肯定满足左倾红黑树的性质。向3-节点插入新元素分为三种情况：&lt;/p&gt;
&lt;p&gt;1）新元素的值位于3-节点中的两元素之间；&lt;/p&gt;
&lt;p&gt;2）新元素的值小于3-节点中的最小元素；&lt;/p&gt;
&lt;p&gt;3）新元素的值大于3-节点中的最大元素。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1890852/202001/1890852-20200123124836990-1959415546.png&quot; alt=&quot;file&quot;/&gt;&lt;br/&gt;图：向3-节点插入新元素&lt;/p&gt;
&lt;h5 id=&quot;向4-节点插入新元素&quot;&gt;##### 向4-节点插入新元素&lt;/h5&gt;
&lt;p&gt;向4-节点插入新元素之前需要先进行颜色转换，才可以进行插入新的元素。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1890852/202001/1890852-20200123124837821-420469365.png&quot; alt=&quot;file&quot;/&gt;&lt;br/&gt;图：向4-节点插入新元素&lt;/p&gt;
&lt;p&gt;插完新元素之后需要满足红黑树的性质，则在沿着父节点的链接向上进行变换，具体做法和向3-节点插入新元素的做法类似，通过左旋转将3-节点左倾和左右旋转将4-节点配平，没有颜色转换。&lt;/p&gt;
&lt;h5 id=&quot;动画2-3-4树与红黑树的插入&quot;&gt;动画：2-3-4树与红黑树的插入&lt;/h5&gt;

&lt;p&gt;Code：红黑树插入算法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1890852/202001/1890852-20200123124839628-549887102.png&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;红黑树删除算法&quot;&gt;红黑树删除算法&lt;/h5&gt;
&lt;p&gt;红黑树删除算法也需要进行旋转和颜色转换操作，在插入算法中为了待插入元素所在的节点不是4-节点，所以在沿着左右链接向下进行变换时将4-节点分解成3个2-节点，中间的2-节点与父节点合并；而在删除算法中为了待删除元素所在的节点不是2-节点，所以在沿着左右链接向下进行变换时将2-节点向其它不是2-节点的节点（兄弟节点或父节点）借一个元素过来，合并成3-节点。&lt;/p&gt;
&lt;p&gt;所以，只要是2-节点的节点，如果兄弟节点不是2-节点，就将兄弟节点的与父节点邻近的元素移到父节点，而父节点将与当前节点邻近的元素移到当前节点；如果兄弟节点是2-节点，则将父节点的与当前节点邻近的元素移到当前节点。（是不是很绕？待会在后面删除最值算法中详细给出）&lt;/p&gt;
&lt;p&gt;然后删除完一个元素之后需要进行修复调整，将这个树满足红黑树的性质。如果右链接是红色，将右链接通过左旋转变成左链接；如果有连续的左链接，通过右旋转配平，然后进行颜色转换。&lt;/p&gt;
&lt;h5 id=&quot;code向上变换修复调整&quot;&gt;Code：向上变换（修复调整）&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1890852/202001/1890852-20200123124840460-1323549653.png&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;删除最小元素-1&quot;&gt;删除最小元素&lt;/h5&gt;
&lt;p&gt;删除最小元素算法和二分搜索树一样，一直递归它的左孩子，直到它的左孩子为空才进行删除这个最小元素。但是红黑树在递归的同时如何旋转和颜色转换是个问题。&lt;/p&gt;
&lt;p&gt;删除最小元素算法一直沿着左链接向下进行转换，对照2-3-4树，我们可以给出三种情况，从根节点开始：&lt;/p&gt;
&lt;p&gt;1）当前节点（父节点位置）的左子节点不是2-节点，直接进行下一个节点（左子节点）；&lt;/p&gt;
&lt;p&gt;2）当前节点的左子节点和右子节点都是2-节点，则将左子节点、当前节点的最小元素和右子节点合并成4-节点，然后进行下一个节点；&lt;/p&gt;
&lt;p&gt;3）当前节点的左子节点是2-节点，右子节点不是2-节点，则将右子节点的最小元素移到当前节点的位置，当前节点的最小元素移到左子节点，然后进行下一个节点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1890852/202001/1890852-20200123124840659-2135359508.png&quot; alt=&quot;file&quot;/&gt;&lt;br/&gt;图：沿着左链接向下进行转换&lt;/p&gt;
&lt;h5 id=&quot;code沿着左链接向下变换&quot;&gt;Code：沿着左链接向下变换&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1890852/202001/1890852-20200123124841412-2094764909.png&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;直到某元素左孩子为空的时候，此时的元素是这个树的最小元素。因为通过前面的转换，最小元素肯定被一个红链接指向，删除这个元素之后通过balance方法修复调整为红黑树。&lt;/p&gt;
&lt;p&gt;Code：删除最小元素算法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1890852/202001/1890852-20200123124842468-1178936016.png&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;删除最大元素-1&quot;&gt;删除最大元素&lt;/h5&gt;
&lt;p&gt;删除最大元素算法和删除最小元素算法类似的，也分为三种情况：&lt;/p&gt;
&lt;p&gt;1）当前节点（父节点位置）的右子节点不是2-节点，直接进行下一个节点（右子节点）；&lt;/p&gt;
&lt;p&gt;2）当前节点的右子节点和左子节点都是2-节点，则将右子节点、当前节点的最大元素和左子节点合并成4-节点，然后进行下一个节点；&lt;/p&gt;
&lt;p&gt;3）当前节点的右子节点是2-节点，左子节点不是2-节点，则将左子节点的最大元素移到当前节点的位置，当前节点的最大元素移到左子节点，然后进行下一个节点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1890852/202001/1890852-20200123124842693-1097191905.png&quot; alt=&quot;file&quot;/&gt;&lt;br/&gt;图：沿着右链接向下进行变换&lt;/p&gt;
&lt;h5 id=&quot;code沿着右链接向下变换&quot;&gt;Code：沿着右链接向下变换&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1890852/202001/1890852-20200123124843152-2145584112.png&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;code删除最大元素算法&quot;&gt;Code：删除最大元素算法&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1890852/202001/1890852-20200123124846057-1375324407.png&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;删除任意元素-1&quot;&gt;删除任意元素&lt;/h5&gt;
&lt;p&gt;学习过前面的删除最小元素算法和删除最大元素算法，删除任意元素会变得很简单。删除最小元素算法会一直沿着左链接向下进行变换，删除最大元素算法会一直沿着右链接向下进行变换，而删除任意元素算法需要同时存在着左右链接向下进行变换。&lt;/p&gt;
&lt;p&gt;删除任意元素算法需要先进行命中查找，在命中查找的过程中会进行沿着左右链接向下变换，如果查找命中则将右子树的最小元素替换掉待删除元素，然后进行右子树的删除最小元素算法；如果查找未命中，则直接返回balance函数，向上将3-节点左倾或将4-节点配平。&lt;/p&gt;
&lt;h5 id=&quot;code删除任意元素算法&quot;&gt;Code：删除任意元素算法&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1890852/202001/1890852-20200123124848970-414621276.png&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;动画2-3-4树与红黑树的删除&quot;&gt;动画：2-3-4树与红黑树的删除&lt;/h5&gt;

&lt;p&gt;学习完上面的算法之后，可以总结下红黑树的性质：&lt;/p&gt;
&lt;p&gt;1）每个节点或是红色的，或是黑色的；&lt;/p&gt;
&lt;p&gt;2）根节点是黑色的；&lt;/p&gt;
&lt;p&gt;3）每个叶子节点（NIL）是黑色的；&lt;/p&gt;
&lt;p&gt;4）如果一个节点是红色的，则它的两个子节点都是黑色的（NIL节点也是黑色的）；&lt;/p&gt;
&lt;p&gt;5）对每个结点，从该节点到其所有后代叶子节点的简单路径上，均包含相同数目的黑色节点（黑链接平衡）。&lt;/p&gt;
&lt;p&gt;喜欢本文的朋友，欢迎关注公众号「算法无遗策」，收看更多精彩内容&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1890852/202001/1890852-20200123124849502-586932194.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 23 Jan 2020 04:49:00 +0000</pubDate>
<dc:creator>我脱下短袖</dc:creator>
<og:description>二分搜索树是为了快速查找而生，它是一颗二叉树，每一个节点只有一个元素（值或键值对），左子树所有节点的值均小于父节点的值，右子树所有的值均大于父节点的值，左右子树也是一颗二分搜索树，而且没有键值相等的节</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wotxdx/p/12230482.html</dc:identifier>
</item>
<item>
<title>Java框架之SpringMVC 05-拦截器-异常映射-Spring工作流程 - 远离颠倒梦想</title>
<link>http://www.cnblogs.com/Open-ing/p/12230419.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Open-ing/p/12230419.html</guid>
<description>&lt;h2&gt;SpringMVC&lt;/h2&gt;
&lt;h3&gt;拦截器&lt;/h3&gt;
&lt;p&gt;　　Spring MVC也可以使用拦截器对请求进行拦截处理，可以自定义拦截器来实现特定的功能，自定义的拦截器可以&lt;strong&gt;实现&lt;/strong&gt;&lt;strong&gt;HandlerInterceptor接口&lt;/strong&gt;中的&lt;strong&gt;三&lt;/strong&gt;个方法&lt;strong&gt;，&lt;/strong&gt;也可以&lt;strong&gt;继承HandlerInterceptorAdapter &lt;/strong&gt;适配器类按照需要那个方法，就实现哪个方法&lt;/p&gt;
&lt;p&gt;过滤器与拦截器区别&lt;/p&gt;
&lt;p&gt;　　过滤器：过滤器在Servlet之前操作&lt;br/&gt;　　拦截器：拦截器在Servlet之后，请求处理器（Controller）之前操作。&lt;/p&gt;
&lt;p&gt;拦截器三个方法&lt;/p&gt;
&lt;p&gt;　　① &lt;strong&gt;preHandle&lt;/strong&gt;()：这个方法在（Controller）&lt;strong&gt;处理器处理请求之前被调用&lt;/strong&gt;，在该方法中对用户请求 request 进行处理。如果该拦截器对请求进行拦截处理后还要调用其他的拦截器，或者是业务处理器去进行处理，则返回&lt;strong&gt; true&lt;/strong&gt;；如果不需要再调用其他的组件去处理请求，则返回false。（如果返回false则后续操作都不再执行，类似于过滤器的 doFilter 所以正常情况下不要返回 false）&lt;/p&gt;
&lt;p&gt;　　② &lt;strong&gt;postHandle&lt;/strong&gt;()：这个方法在（Controller）&lt;strong&gt;处理器处理完请求后，但是 &lt;/strong&gt;DispatcherServlet 向客户端返回响应前&lt;strong&gt;（在视图渲染之前）被调用&lt;/strong&gt;，在该方法中对用户请求request进行处理。&lt;/p&gt;
&lt;p&gt;　　③ &lt;strong&gt;afterCompletion&lt;/strong&gt;()：这个方法在 DispatcherServlet 完全处理完请求后&lt;strong&gt;（转发|重定向 之后）被调用&lt;/strong&gt;，可以在该方法中进行一些资源清理关闭的操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;配置拦截器&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mvc:interceptors&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;   为所有请求设置拦截器 也可用 ref 引用已经装配好的拦截器&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;firstHandlerInterceptor&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;main.controller.FirstHandlerInterceptor&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mvc:interceptor&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;     表示指定拦截器只拦截/test/下的所有请求&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mvc:mapping &lt;/span&gt;&lt;span&gt;path&lt;/span&gt;&lt;span&gt;=&quot;/test/**/&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;     表示访问/test/test.do的请求不会触发拦截器&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mvc:exclude-mapping &lt;/span&gt;&lt;span&gt;path&lt;/span&gt;&lt;span&gt;=&quot;/test/test.do&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
　　　  　　  &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;     为指定的请求设置拦截器 也可用 ref 引用已经装配好的拦截器&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
　　　  　　  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;testInterceptor&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;main.controller.TestInterceptor&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;mvc:interceptor&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;mvc:interceptors&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt; 程序执行顺序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　1. preHandle():执行请求处理器的请求（Controller）方法之前执行。 &lt;br/&gt;　　2. 执行请求处理器的请求（Controller）方法&lt;br/&gt;　　3. postHandle():执行请求处理器的请求（Controller）方法之后，在视图渲染之前。&lt;br/&gt;　　4. 视图渲染&lt;br/&gt;　　5. afterCompletion():视图渲染（转发|重定向）之后执行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多个拦截器&lt;/strong&gt;的执行流程&lt;/p&gt;
&lt;p&gt;　　当存在多个拦截器时的执行顺序，由配置的先后顺序决定。（preHandle() 先配置，先执行） &lt;br/&gt;　　preHandle():与拦截器配置的先后顺序&lt;strong&gt;一致&lt;/strong&gt;。&lt;br/&gt;　　postHandle():与拦截器配置的先后顺序&lt;strong&gt;相反&lt;/strong&gt;。底层倒序循环调用的&lt;br/&gt;　　afterCompletion():与拦截器配置的先后顺序相反。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;preHandle()返回值为false时&lt;/strong&gt;的工作原理&lt;/p&gt;
&lt;p&gt;　　第一个拦截器的preHandle()的返回值为false:&lt;br/&gt;　　　　只执行第一个拦截器的prehandle()方法，执行完，return;(后续的方法都不执行) &lt;br/&gt;　　不是第一个拦截器的preHandle()的返回值为false: &lt;br/&gt;　　　　当前拦截器之前的拦截器的afterCompletion()都会被执行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1863179/202001/1863179-20200121201254007-1971006374.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　当两个拦截器的 preHandle() 方法都返回 true 时，按照虚线路执行&lt;/p&gt;
&lt;p&gt;　　当第二个拦截器 preHandle() 方法返回 false 时按照实现路线执行&lt;/p&gt;
&lt;h3&gt; 异常处理&lt;/h3&gt;
&lt;p&gt;　　在SpringMVC中，无论请求控制器中是否存在异常，都会返回ModelAndView对象&lt;/p&gt;
&lt;p&gt;　　Spring MVC 通过 HandlerExceptionResolver  处理程序的异常，包括 Handler 映射、数据绑定以及目标方法执行时发生的异常&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;　　DispatcherServlet  默认装配的&lt;span lang=&quot;EN-US&quot;&gt; HandlerExceptionResolver 有 DefaultHandlerExceptionResolver 解析器会自动将标准的Spring MVC异常解析为HTTP错误状态码&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　使用&lt;span lang=&quot;EN-US&quot;&gt; &amp;lt;mvc:annotation-driven/&amp;gt; 配置会装配Spring3.0后新增的异常解析器，实现更精细化处理。&lt;/span&gt;如果希望对所有异常进行统一处理或指定某一异常跳转页面，可以使用 SimpleMappingExceptionResolver，它&lt;strong&gt;将异常类名映射为视图名，可实现跳转到指定页面&lt;/strong&gt;，并报告异常.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;配置异常解析器&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;    为所有异常定义默认的处理页面,exceptionMappings未定义的，
                value表示跳转页面，至于文件路径和后缀已经在 viewResolver 中指定&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;defaultErrorView&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;error&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;    定义异常处理页面用来获取异常信息的变量名，被存放到 request 域中&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;exceptionAttribute&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;exception&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;    需要特殊处理的异常，全类名作为key，异常页文件名作为值，可将不同的异常映射到不同的页面上&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;exceptionMappings&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;props&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;prop &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;java.lang.NullPointerException&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;nullPointer&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;prop&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;props&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&amp;lt;mvc:annotation-driven/&amp;gt;&lt;/h3&gt;
&lt;p&gt;　　是spring MVC为@Controllers分发请求所必须的，即启用注解驱动，解决了@Controller注解使用的前提配置。&lt;/p&gt;
&lt;p&gt;　　同时它还提供了：数据绑定支持，@NumberFormatannotation支持，@DateTimeFormat支持，@Valid支持，读写XML的支持（JAXB，读写JSON的支持（Jackson）。&lt;/p&gt;
&lt;p&gt;　　它会自动为我们注册了很多的Bean，最重要的就是&lt;strong&gt;RequestMappingHandlerMapping&lt;/strong&gt;和&lt;strong&gt;RequestMappingHandlerAdapter&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　　　第一个是HandlerMapping的实现类，它会处理@RequestMapping 注解，并将其注册到请求映射表中。&lt;br/&gt;　　　　第二个是HandlerAdapter的实现类，它是处理请求的适配器，说白了，就是确定调用哪个类的哪个方法，并且构造方法参数，返回值。&lt;/p&gt;
&lt;p&gt;　　简单的说，用什么注解，就需要声明对应的BeanPostProcessor。而Spring为我们提供了一种极为方便注册这些BeanPostProcessor的方式，即使用各种标签来隐式地向 Spring 容器注册&lt;/p&gt;
&lt;h3&gt;Spring工作流程&lt;/h3&gt;
&lt;p&gt;　　相关类&lt;/p&gt;
&lt;p&gt;　　　　HandlerMapping(请求处理器的映射对象):定义了一个所有请求和请求处理器对象之间的映射关系对象&lt;/p&gt;
&lt;p&gt;　　　　HandlerExecutionChain(请求处理器执行链对象):定义了 当前请求处理器对象，和所有拦截器对象。&lt;/p&gt;
&lt;p&gt;　　　　HandlerAdapter(请求处理器的适配器对象):调用当前请求处理器的请求方法。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;执行流程&lt;/strong&gt;对应下图理解&lt;/p&gt;
&lt;p&gt;　　　　1）用户向服务器发送请求，请求被SpringMVC 前端控制器 DispatcherServlet捕获&lt;/p&gt;
&lt;p&gt;　　　　2）DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI）:判断请求URI对应的映射&lt;br/&gt;　　　　　　① 不存在：&lt;br/&gt;　　　　　　　　再判断是否配置了 mvc:default-servlet-handler：&lt;br/&gt;　　　　　　　　如果没配置，则控制台报映射查找不到，客户端展示404错误&lt;br/&gt;　　　　　　　　如果有配置，则执行目标资源（一般为静态资源，如：JS,CSS,HTML）&lt;br/&gt;　　　　　　② 存在：&lt;br/&gt;　　　　　　　　执行下面流程&lt;/p&gt;
&lt;p&gt;　　　　3）根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象（包括Handler对象以及Handler对象对应的拦截器），最后以HandlerExecutionChain对象的形式返回；&lt;/p&gt;
&lt;p&gt;　　　　4）DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter。&lt;/p&gt;
&lt;p&gt;　　　　5）如果成功获得HandlerAdapter后，此时将开始执行拦截器的preHandler(...)方法【正向】&lt;/p&gt;
&lt;p&gt;　　　　6）提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)方法，处理请求。在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作：&lt;br/&gt;　　　　　　① HttpMessageConveter： 将请求消息（如Json、xml等数据）转换成一个对象，将对象转换为指定的响应信息&lt;br/&gt;　　　　　　② 数据转换：对请求消息进行数据转换。如String转换成Integer、Double等&lt;br/&gt;　　　　　　③ 数据格式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等&lt;br/&gt;　　　　　　④ 数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中&lt;/p&gt;
&lt;p&gt;　　　　7）Handler执行完成后，向DispatcherServlet 返回一个ModelAndView对象；&lt;/p&gt;
&lt;p&gt;　　　　8）此时将开始执行拦截器的postHandle(...)方法【逆向】&lt;/p&gt;
&lt;p&gt;　　　　9）根据返回的ModelAndView（此时会判断是否存在异常：如果存在异常，则执行HandlerExceptionResolver进行异常处理）选择一个适合的ViewResolver（必须是已经注册到Spring容器中的ViewResolver)返回给DispatcherServlet，根据Model和View，来渲染视图&lt;/p&gt;
&lt;p&gt;　　　　10）在返回给客户端时需要执行拦截器的AfterCompletion方法【逆向】&lt;/p&gt;
&lt;p&gt;　　　　11）将渲染结果返回给客户端&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/common/1863179/202001/1863179-20200121231742456-1914557008.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;Spring与SpringMVC&lt;/h3&gt;
&lt;p&gt;　　spring容器与springMVC容器对象的关系&lt;/p&gt;
&lt;p&gt;　　　　springMVC容器对象，默认交个DispatcherServlet管理&lt;/p&gt;
&lt;p&gt;　　　　spring容器对象，需要我们管理（交给Listener管理）&lt;/p&gt;
&lt;p&gt;　　spring容器对象描述&lt;/p&gt;
&lt;p&gt;　　　　Root WebApplicationContext: root of context hierarchy&lt;/p&gt;
&lt;p&gt;　　springMVC容器对象描述&lt;/p&gt;
&lt;p&gt;　　　　WebApplicationContext for namespace 'springDispatcherServlet-servlet':root of context hierarchy&lt;/p&gt;
&lt;p&gt;　　spring容器对象是父，springMVC容器对象是子。子类可以直接调用父类方法。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;SpringMVC 的 IOC 容器中的 bean 可以引用 Spring IOC 容器中的 bean.反之则不行. &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　在web应用下，获取spring容器对象方式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
ServletContext servletContext =&lt;span&gt; httpSession.getServletContext();
ApplicationContext context &lt;/span&gt;= WebApplicationContextUtils.getWebApplicationContext(servletContext);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　在web应用下，获取springMVC容器对象可直接通过装配属性的方式获取&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; XmlWebApplicationContext context;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/Open-ing/articles/12230479.html&quot; target=&quot;_blank&quot;&gt;配置文件&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　若 Spring 的 IOC 容器和 SpringMVC 的 IOC 容器扫描组件的包有重合的部分, 就会导致有的 bean 会被创建 2 次，可通过一个包含一个排除的方式解决&lt;/p&gt;
</description>
<pubDate>Thu, 23 Jan 2020 04:47:00 +0000</pubDate>
<dc:creator>远离颠倒梦想</dc:creator>
<og:description>SpringMVC 拦截器 Spring MVC也可以使用拦截器对请求进行拦截处理，可以自定义拦截器来实现特定的功能，自定义的拦截器可以实现HandlerInterceptor接口中的三个方法，也可以</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Open-ing/p/12230419.html</dc:identifier>
</item>
<item>
<title>关于C#程序的单元测试 - shanzm</title>
<link>http://www.cnblogs.com/shanzhiming/p/12230417.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shanzhiming/p/12230417.html</guid>
<description>&lt;p&gt;志铭-2020年1月23日 11:49:41&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;单元测试概念&quot;&gt;1.单元测试概念&lt;/h3&gt;
&lt;ul readability=&quot;24&quot;&gt;&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;什么是单元测试？&lt;/p&gt;
&lt;p&gt;单元测试（unit testing）是一段自动化的代码，用来调用被测试的方法或类，而后验证基于该方法或类的逻辑行为的一些假设。&lt;/p&gt;
&lt;p&gt;简而言之说：单元测试是一段代码（通常一个方法）调用另外一段代码，随后检验一些假设的正确性。&lt;/p&gt;
&lt;p&gt;在过程化编程中，一个单元就是单个程序、函数、过程等；&lt;/p&gt;
&lt;p&gt;对于面向对象编程，&lt;strong&gt;最小单元就是方法&lt;/strong&gt;，包括基类（超类）、抽象类、或者派生类（子类）中的方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;14&quot;&gt;
&lt;p&gt;为什么要单元测试？&lt;/p&gt;
&lt;p&gt;单元测试的目标是隔离程序部件并证明这些单个部件是正确的。单元测试在软件开发过程的早期就能发现问题。&lt;/p&gt;
&lt;p&gt;在代码重构或是修改的时候，可以根据单元测试快速验证新修改的代码的正确性，换句话说为了方便系统的后期维护升级！&lt;/p&gt;
&lt;p&gt;单元测试某种程度上&lt;strong&gt;相当于系统的文档&lt;/strong&gt;。借助于查看单元测试提供的功能和单元测试中如何使用程序单元，开发人员可以直观的理解程序单元的基础API，即提高了代码的可读性！&lt;/p&gt;
&lt;p&gt;若是开发流程按照&lt;strong&gt;测试驱动开发&lt;/strong&gt;则先行编写的单元测试案例就相当于：软件工程瀑布模式中第二阶段——设计阶段的文档&lt;br/&gt;使用测试驱动开发，可以避免实际开发中编程人员不完全按照文档规范，因为是基于单元测试设计方法，开发人员不遵循设计要求的解决方案永远不会通过测试。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;什么时候需要单元测试?&lt;/p&gt;
&lt;p&gt;“单元测试通常被认为是编码阶段的附属工作。可以在编码开始之前或源代码生成之后进行单元测试的设计。”——《软件工程：实践者的研究方法》&lt;/p&gt;
&lt;p&gt;对于需要长期维护的项目，单元测试可以说是必须的&lt;/p&gt;
&lt;p&gt;通常来说，程序员每修改一次程序就会进行最少一次单元测试，在编写程序的过程中前后很可能要进行多次单元测试，以保证没有程序错误；虽然单元测试不是必须的，但也不坏，这牵涉到项目管理的政策决定。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;单元测试谁来编写？&lt;/p&gt;
&lt;p&gt;不需要专门的软件测试人员编写测试案例，单元测试通常由软件开发人员编写。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;也正式因为是开发人员自己写单元测试部分，也可以让开发者仔细的思考自己方法和接口是否可以更加便于调用&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;单元测试局限性&lt;/p&gt;
&lt;p&gt;不能发现集成错误、性能问题、或者其他系统级别的问题。单元测试结合其他软件测试活动更为有效。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;单元测试框架&lt;/p&gt;
&lt;p&gt;通常在没有特定框架支持下，自行创建一个项目作为单元测试项目完全是可行的。&lt;br/&gt;使用单元测试框架，同时配合编辑器VS，编写单元测试相对来说会简单许多。&lt;br/&gt;.NET下的单元测试框架：MSTest、NUnit&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr/&gt;&lt;h3 id=&quot;单元测试的原则&quot;&gt;2.单元测试的原则&lt;/h3&gt;
&lt;p&gt;根本原则：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Automatic(自动化)&lt;br/&gt;单元测试应该是全自动执行的，并且非交互式的&lt;/li&gt;
&lt;li&gt;Independent&lt;br/&gt;单元测试方法的执行顺序无关紧要&lt;br/&gt;单元测试的各个方法之间不应该相互依赖&lt;/li&gt;
&lt;li&gt;Repeatable&lt;br/&gt;功能代码不改的前提下，相同的测试代码多次运行，应该得到相同的结果&lt;/li&gt;
&lt;li&gt;Self-validating&lt;br/&gt;单元测试方法只有两个可能的运行结果：通过或失败，没有第三种情况。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其他一些规范：&lt;/p&gt;
&lt;ul readability=&quot;7&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;最理想的情况下，应该尽量多写测试用例，以保证代码功能的正确性符合预期，具有良好的容错性。如果代码较复杂，条件分支较多，测试用例最好能覆盖所有的分支路径。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;实际开发中，没有必要对每一个函数都进行单元测试。但是若是一个比较独立的功能（当然也可能这个功能就一个函数），应该对这个功能进行比较详尽的测试。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;单元测试的基本目标:语句覆盖率达到 70%;核心模块的语句覆盖率和分支覆盖率都要达到 100%。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;注意一个类中可能有许多方法，我们不是要把所有的方法的单元测试都写完，在去实现代码，而是写完一个单元测试，就去实现一个方法，是一种快速的迭代&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;不测试私有方法，因为私有方法不被外部调用，测试意义不大，而且你非要测试，那就要使用反射，比较麻烦。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;一个测试只测试一个功能&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr/&gt;&lt;h3 id=&quot;单元测试简单示例&quot;&gt;3.单元测试简单示例&lt;/h3&gt;
&lt;h4 id=&quot;一个简单的手写单元测试实例&quot;&gt;3.1一个简单的手写单元测试实例&lt;/h4&gt;
&lt;p&gt;为了简洁明了的说明什么是单元测试，首先不使用单元测试框架，自行编写单元测试项目&lt;/p&gt;
&lt;p&gt;比如说新建了一个类Calculator用于对数据的计算，&lt;/p&gt;
&lt;p&gt;如下只是随便的的写了个方法，方便理解：&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;public class Calculator
{
    //求一个数的二倍
    public int DoubleValue(int i)
    {
        return i * 2;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;新建了Calculator类之后，我们编写单元测试代码对该类中方法进行单元测试：&lt;br/&gt;首先新建一个项目，对待测试的方法所在的项目添加引用,&lt;/p&gt;
&lt;p&gt;编写代码，测试ClassLib项目中Calculator类中的DoubleValue()方法&lt;/p&gt;
&lt;p&gt;测试DoubleValue(int value),该函数是求一个数的二倍，给其一个参数value=2,则期望其得到的结果是4，若是其他值则说明函数编写是错误的，测试不通过。若是该函数的运行结果和期望的结果一样则运行通过&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;public static void CalculatorDoubleValueTest()
{  
    //生成一个测试对象的实例
    Calculator obj = new Calculator();
    //设计测试案例
    int value = 2;
    int expected = 4;
        
    //与预期比较
    if (expected == obj.DoubleValue(value))
    {
        Console.WriteLine(&quot;测试通过&quot;);
    }
    else
    {
        Console.WriteLine($&quot;测试未通过,测试的实际结果是{obj.DoubleValue(value)}&quot;);
    }
    Console.ReadKey();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过上面的示例，简单的演示了单元测试是什么，但是实际中一般都是使用已有的单元测试框架。而且测试一个方法为了完备性一般都要到所有的逻辑路径进行测试，所以会对一个方法写多个测试方法。&lt;/p&gt;
&lt;h4 id=&quot;单元测试框架mstest&quot;&gt;3.2单元测试框架MSTest&lt;/h4&gt;
&lt;p&gt;单元测试一般都是使用现成的单元测试框架，关于.net的单元测试框架有许多，常见的有NUnit,MSTest等等。&lt;/p&gt;
&lt;p&gt;这里使用VS自带的MStest框架做简单的演示（一般推荐使用NUnit框架：Undone）&lt;/p&gt;
&lt;p&gt;演示的案例，继续对上述的Calculator类中的DoubleValue()进行单元测试&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：通常的做法是为每个被测项目建立一个测试项目，为每个被测类建立一个测试类，并且为每个被测方法至少建立一个测试方法。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新建项目---&amp;gt;选择测试类项目中的单元测试项目，命名为&quot;被测试项目名+Tests&quot;&lt;/p&gt;
&lt;p&gt;测试类的命名为“被测试的类+Tests”&lt;/p&gt;
&lt;p&gt;测试函数的命名按照 ：**[被测方法]_ [测试场景]_[预期行为]** 格式命名&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;方法名——被测试的方法&lt;/li&gt;
&lt;li&gt;测试场景——能产生预期行为的条件&lt;/li&gt;
&lt;li&gt;预期行为——在给定条件下，期望被测试方法产生什么结果&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当然在VS中也可以在想要测试的函数上右键，创建单元测试，弹出如下窗口，直接点击确定即可,即可生成默认的单元测试代码模版&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1576687/202001/1576687-20200123115301674-1064484802.png&quot; alt=&quot;新建单元测试&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里先使用默认自带的MSTest框架，使用默认的命名格式，会自动生成相应的测试项目和测试函数格式。&lt;/p&gt;
&lt;p&gt;编写单元测试的代码，一般按照以下四步编写:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Arrange:配置测试对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TestCase:准备测试案例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Act:操作测试对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Assert:对操作断言&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;//注意 [TestClass]和[TestClass()]，[TestMethod()]和[TestMethod]写法等价
namespace ClassLib.Tests
{
    [TestClass()]//通过标注该特性标签表明该类为测试类
    public class CalculatorTests
    {
        [TestMethod()]//通过标注该特性标签表明该函数为测试函数
        public void DoubleValueTest_DoubleValue_ReturnTrue()
        {
            //Arrange:准备，实例化一个带测试的类
            Calculator obj = new Calculator();

            //Test Case:设计测试案例
            int value = 2;
            int expected = 4;

            //Act：执行
            int actual = obj.DoubleValue(value);

            //Assert：断言
            Assert.AreEqual(expected, actual);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;点击测试--&amp;gt;运行--&amp;gt;所有测试&lt;br/&gt;或点击测试--&amp;gt;窗口--&amp;gt;测试资源管理器--&amp;gt;运行所有测试&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1576687/202001/1576687-20200123115406706-1670973465.gif&quot; alt=&quot;运行&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面运行显示测试通过显示的是绿色的标志，若是测试不通过则会则显示红色标志，在单元测试中有一种“红绿灯”的概念（你是使用其他的单元测试框架也是同样的红绿标志）。&lt;/p&gt;
&lt;p&gt;在测试驱动开发的流程中，就是“红灯--&amp;gt;修改--&amp;gt;绿灯--&amp;gt;重构--&amp;gt;绿灯”的开发流程。&lt;/p&gt;
&lt;p&gt;注意：我是使用的不是VS Enterprise版本故无法直接查看代码的测试覆盖率，可以使用插件OpenCover或NCover等其他工具查看单元测试的覆盖率。&lt;/p&gt;
&lt;p&gt;上面只是演示了怎么进行一次单元测试，但是实际中我们的测试案例不能仅仅一个，所以要添加多个测试，以提高到测试的完备性&lt;/p&gt;
&lt;p&gt;若是对需要大量测试案例的，可以把测试数据存放在专门的用于测试使用的数据库中，在测试时通过连接数据库，使用数据库中的数据进行测试&lt;/p&gt;
&lt;p&gt;依旧是上面的示例，把大量的测试案例存放在数据库&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;Id                   Input       Expected
-------------------- ----------- -----------
1                    2           4
2                    6           12
3                    13          26
4                    0           0
5                    -2          -4&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;单元测试的代码如下&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt; public TestContext TestContext { get; set; }//注意为了获取数据库的数据，我们要自定义一个TestContext属性
[TestMethod()]
[DataSource(&quot;System.Data.SqlClient&quot;,
            @&quot;server=.;database=db_Tome1;uid=sa;pwd=shanzhiming&quot;,//数据库连接字符串
            &quot;tb_szmUnitTestDemo&quot;,//测试数据存放的表
            DataAccessMethod.Sequential)]//对表中的数据测试的顺序，可以是顺序的，也可以是随机的，这里是我们选择顺序
public void DoubleValueTest_DoubleValue_ReturnTrue()
{
    //Arrange
    Calculator target = neCalculator();
    //TestCase
    int value = Convert.ToInt(TestContext.DataR[&quot;Input&quot;]);
    int expected Convert.ToInt(TestContext.DataR[&quot;Expected&quot;]);
    //Act
    int actual target.DoubleValu(value);
    //Assert
    Assert.AreEqual(expected, actual);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;ol readability=&quot;1.9387096774194&quot;&gt;&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;特性标签&lt;code&gt;[TestClass]&lt;/code&gt; &lt;code&gt;[TestMethod]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;MSTest框架通过标签识别并加载测试&lt;/p&gt;
&lt;p&gt;&lt;code&gt;[TestClass]&lt;/code&gt;用来标识包含一个MSTest自动好测试的类，&lt;/p&gt;
&lt;p&gt;&lt;code&gt;[TestMethod]&lt;/code&gt;用来标识需要被调用的自动化测试的方法&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-0.962890625&quot;&gt;
&lt;p&gt;特性标签&lt;code&gt;[DataSource]&lt;/code&gt;标识用来测试的数据源，其的参数如下：&lt;/p&gt;
&lt;ul readability=&quot;4.7989417989418&quot;&gt;&lt;li readability=&quot;0.924&quot;&gt;
&lt;p&gt;第一个参数是providername，即使用的数据源的命名空间，其实我们也是可是使用Excel表格的（菜单“项目”--&amp;gt;添加新的数据源……）参考：&lt;a href=&quot;https://blog.csdn.net/site008/article/details/77070945&quot;&gt;CSDN:vs2015数据驱动的单元测试&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;providername值参考：&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;&quot;system.data.sqlclient&quot;&lt;/code&gt; ----说明使用的是mssqlserver数据库&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;&quot;system.data.sqllite&quot;&lt;/code&gt; ----说明使用的是sqllite数据库&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;&quot;system.data.oracleclient&quot;&lt;/code&gt; ----说明使用的是oracle数据库或&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;&quot;mysql.data.mysqlclient&quot;&lt;/code&gt; ----说明使用的是mysql数据库&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;第二个参数是connectionString，我习惯是这样写：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;@&quot;server=.;database=数据库;uid=用户ID;pwd=密码&quot;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;但是推荐这样写：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;@&quot;Data Source=localhost;Initial Catalog=数据库;User ID=用户ID;Password=密码&quot;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;第三个参数是tablename,选择使用的数据库中的哪张表&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;第四个参数确定对表中的数据测试的顺序.&lt;br/&gt;可以是顺序的：&lt;code&gt;DataAccessMethod.Sequential&lt;/code&gt;，&lt;br/&gt;可以是随机的:&lt;code&gt;DataAccessMethod.Random&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr/&gt;&lt;h3 id=&quot;单元测试框架特性标签&quot;&gt;4.单元测试框架特性标签&lt;/h3&gt;
&lt;p&gt;在MSTest单元测试框架中主要有以下的一些特性标签：&lt;/p&gt;
&lt;p&gt;(&lt;a href=&quot;https://www.cnblogs.com/ColdJokeLife/p/3158812.html&quot;&gt;参考&lt;/a&gt;)&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;14&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;[TestClass]&lt;/td&gt;
&lt;td&gt;定义一个测试类，里面可以包含很多测试函数和初始化、销毁函数（以下所有标签和其他断言）。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;[TestMethod]&lt;/td&gt;
&lt;td&gt;定义一个独立的测试函数。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;[ClassInitialize]&lt;/td&gt;
&lt;td&gt;定义一个测试类初始化函数，每当运行测试类中的一个或多个测试函数时，这个函数将会在测试函数被调用前被调用一次（在第一个测试函数运行前会被调用）。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;[ClassCleanup]&lt;/td&gt;
&lt;td&gt;定义一个测试类销毁函数，每当测试类中的选中的测试函数全部运行结束后运行（在最后一个测试函数运行结束后运行）。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;[TestInitialize]&lt;/td&gt;
&lt;td&gt;定义测试函数初始化函数，每个测试函数运行前都会被调用一次。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;[TestCleanup]&lt;/td&gt;
&lt;td&gt;定义测试函数销毁函数，每个测试函数执行完后都会被调用一次。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;[AssemblyInitialize]&lt;/td&gt;
&lt;td&gt;定义测试Assembly初始化函数，每当这个Assembly中的有测试函数被运行前，会被调用一次（在Assembly中第一个测试函数运行前会被调用）。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;[AssemblyCleanup]&lt;/td&gt;
&lt;td&gt;定义测试Assembly销毁函数，当Assembly中所有测试函数运行结束后，运行一次。（在Assembly中所有测试函数运行结束后被调用）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;[Ignore]&lt;/td&gt;
&lt;td&gt;跳过（忽略）该测试函数&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;[TestCategory(&quot;测试类别&quot;)]&lt;/td&gt;
&lt;td&gt;给测试自定义分类，便于有选择的运行指定类别的单元测试&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;说明：&lt;/p&gt;
&lt;ul readability=&quot;5&quot;&gt;&lt;li readability=&quot;13&quot;&gt;
&lt;p&gt;使用&lt;code&gt;[ClassInitialize]&lt;/code&gt;和&lt;code&gt;[ClassCleanup]&lt;/code&gt;标签特性&lt;/p&gt;
&lt;p&gt;可以在测试之前或之后方便地控制测试的初始化和清理，从而确保所有的测试都是使用新的未更改的状态。&lt;/p&gt;
&lt;p&gt;注意，这是很有必要的，可以有效的防止测试失败是因为测试之间的依赖性导致失败。&lt;/p&gt;
&lt;p&gt;注意两个标签特性需要放在一个无返回值的静态方法上,&lt;/p&gt;
&lt;p&gt;且标注&lt;code&gt;[ClassInitialize]&lt;/code&gt;特性的方法的参数是：&lt;code&gt;TestContext testcontext&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;示例：比如说在一个测试类初始化一个测试对象，并在测试完成后释放，代码如下：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;
[TestClass()]
public class CalculatorTests
{
    //使用ClassInitialize标签初始化一个Calculator对象以供下面所有的测试([ClassCleanup]之前）使用
    private static Calculator calc = null;
    [ClassInitialize]
    public static  void  ClassInit(TestContext testcontext)
    {
        calc = new Calculator();
    }

    [TestMethod()]
    public void testMethod1()
    {
         //测试
    }
    [TestMethod()]
    public void testMethod2()
    {
        //测试
    }
    [TestMethod()]
    public void testMethod3()
    {
        //测试
    }
     
    [ClassCleanup]
    public static  void Classup()
    {
        calc = null;
    }
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;hr/&gt;&lt;h3 id=&quot;单元测试中的断言assert&quot;&gt;5.单元测试中的断言Assert&lt;/h3&gt;
&lt;ol readability=&quot;4.917864476386&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;断言是什么？可以从字面理解是“十分肯定的说”，在编程中可以通过 不同的断言来测试方法实际运行的结果和你期望的结果是否一致。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;断言是单元测试最基本的组成部分，Assert类的静态方法提供了不同形式的多种断言。&lt;br/&gt;MStest中Assert的常用静态方法：(&lt;a href=&quot;https://www.cnblogs.com/ColdJokeLife/p/3158812.html&quot;&gt;参考&lt;/a&gt;)：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Assert.AreEqual()&lt;/td&gt;
&lt;td&gt;验证值相等&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Assert.AreNotEqual()&lt;/td&gt;
&lt;td&gt;验证值不相等&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Assert.AreSame()&lt;/td&gt;
&lt;td&gt;验证引用相等&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Assert.AreNotSame()&lt;/td&gt;
&lt;td&gt;验证引用不相等&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Assert.Inconclusive()&lt;/td&gt;
&lt;td&gt;暗示条件还未被验证&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Assert.IsTrue()&lt;/td&gt;
&lt;td&gt;验证条件为真&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Assert.IsFalse()&lt;/td&gt;
&lt;td&gt;验证条件为假&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Assert.IsInstanceOfType()&lt;/td&gt;
&lt;td&gt;验证实例匹配类型&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;Assert.IsNotInstanceOfType()&lt;/td&gt;
&lt;td&gt;验证实例不匹配类型&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Assert.IsNotNull()&lt;/td&gt;
&lt;td&gt;验证条件为NULL&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Assert.IsNull()&lt;/td&gt;
&lt;td&gt;验证条件不为 NULL&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Assert.Fail()&lt;/td&gt;
&lt;td&gt;验证失败&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/li&gt;
&lt;li readability=&quot;1.9529147982063&quot;&gt;
&lt;p&gt;针对字符串的断言，使用StringAssert的静态方法：&lt;/p&gt;
&lt;p&gt;注意可以根据VS的只能提示自行查看&lt;code&gt;StringAssert&lt;/code&gt;的所有静态方法，或是查看&lt;code&gt;StringAssert&lt;/code&gt;的定义，可以查看其所有的静态方法&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/tylerzhou/p/11300896.html&quot;&gt;详细使用可参考&lt;/a&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;12.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;9&quot;&gt;&lt;td&gt;StringAssert.AreEqualIgnoringCase(string expected,string actual)&lt;/td&gt;
&lt;td&gt;用于断言 两个字符串在不区分大小写情况下是否相等,需要提供两个参 数,第一个是期待的结果,第二个是实际结果.&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;StringAssert.Contains()&lt;/td&gt;
&lt;td&gt;用于断言一个字符串是否包含另一字符串,其中第一个参数为被包含的字符串,第二个为实际字符串&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;7&quot;&gt;&lt;td&gt;StringAssert.StartsWith()&lt;/td&gt;
&lt;td&gt;断言字符串是否以某(几)字符开始, 第一个参数为开头的字符串 ,第二个为实际字符串&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;StringAssert.EndsWith()&lt;/td&gt;
&lt;td&gt;断言字符串是否以某(几)字符结束&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;StringAssert.Matches()&lt;/td&gt;
&lt;td&gt;断言字符串是否符合特定的正则表达式&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/li&gt;
&lt;li readability=&quot;1.9649122807018&quot;&gt;
&lt;p&gt;针对集合的断言，使用CollectionAssert的静态方法：&lt;/p&gt;
&lt;p&gt;注意可以根据VS的只能提示自行查看&lt;code&gt;CollectionAssert&lt;/code&gt;所有的静态方法，或是查看&lt;code&gt;CollectionAssert&lt;/code&gt;的定义，可以查看其所有的静态方法&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/tylerzhou/p/11300896.html&quot;&gt;详细使用可参考&lt;/a&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;22&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;8&quot;&gt;&lt;td&gt;CollectionAssert.AllItemsAreNotNull&lt;/td&gt;
&lt;td&gt;断言集合里的元素全部不是Null,也即集合不包含null元素,这个方法只有一个参数,传入我们要判断的集合即可&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;CollectionAssert.AllItemsAreUnique&lt;/td&gt;
&lt;td&gt;断言集合里面的元素全部是惟一的,即集合里没有重复元素.&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;CollectionAssert.AreEqual&lt;/td&gt;
&lt;td&gt;用于断言两个集合是否相等&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;10&quot;&gt;&lt;td&gt;CollectionAssert.AreEquivalent&lt;/td&gt;
&lt;td&gt;用来判断两个集合的元素是否等价,如果两个集合元素类型相同,个数也相同,即视为等价,与上面的AreEqual方法相比,它不关心顺序&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;CollectionAssert.Contains&lt;/td&gt;
&lt;td&gt;断言集合是否包含某一元素&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;CollectionAssert.IsEmpty&lt;/td&gt;
&lt;td&gt;断言某一集合是空集合,即元素个数为0&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;10&quot;&gt;&lt;td&gt;CollectionAssert.IsSubsetOf&lt;/td&gt;
&lt;td&gt;判断一个集合是否为另一个集合的子集,这两个集合不必是同一类集合(可以一个是array,一个是list),只要一个集合的元素完全包含在另一个集合中,即认为它是另一个集合的子集&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr/&gt;&lt;h3 id=&quot;单元测试中验证预期的异常&quot;&gt;6.单元测试中验证预期的异常&lt;/h3&gt;
&lt;p&gt;若是程序中在某种特定的条件下有异常抛出，为了进行单元测试，我们设计指定的测试案例，期望在该测试案例程序抛出异常，并检验其是否抛出异常。&lt;/p&gt;
&lt;p&gt;简单示例：&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// 计算从from到to的所有整数的和
/// &amp;lt;/summary&amp;gt;
public int Sum(int from, int to)
{
    if (from &amp;gt; to)
    {
        throw new ArgumentException(&quot;参数from必须小于to&quot;);
    }
    int sum = 0;
    for (int i = from; i &amp;lt;= to; i++)
    {
        sum += i;
    }
    return sum;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在程序中，若是参数&lt;code&gt;from&lt;/code&gt; &amp;gt;&lt;code&gt;to&lt;/code&gt;则抛出异常&lt;code&gt;new ArgumentException(&quot;参数from必须小于to&quot;);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;为了检验该程序在该条件下是否真的会抛出异常，可以创造测试案例from=100 &amp;gt; to=50&lt;br/&gt;期望Sum()函数代码中执行：&lt;code&gt;throw new ArgumentException(&quot;参数from必须小于to&quot;);&lt;/code&gt;，所以我们要测试期望抛出的异常&lt;code&gt;ArgumentException&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;使用标签&lt;code&gt;[ExpectedException(typeof(“抛出的异常对象”))]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;单元测试代码：&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;       
//异常测试，添加ExpectedException
[TestMethod]
[ExpectedException(type(ArgumentException))]
public void SumTest_ArgumentException_TrowException()
{
    Calculator bjCalcultor = new Calculator();
    int from=100,to=50；
    calc.Sum(from, to);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为程序抛出了我们期望的异常，所以该测试通过。如若程序没有抛出该异常则测试失败。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1576687/202001/1576687-20200123115439260-1949352561.png&quot; alt=&quot;异常测试&quot;/&gt;&lt;/p&gt;

&lt;hr/&gt;&lt;h3 id=&quot;单元测试中针对状态的间接测试&quot;&gt;7.单元测试中针对状态的间接测试&lt;/h3&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;基于状态的测试（也称状态验证），是指在方法执行之后，通过检查被测系统及其协作者（依赖项）的状态来检测该方法是否正确工作&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;简单示例：&lt;/p&gt;
&lt;p&gt;下面的方法&lt;code&gt;isLastFilenameValid(string filename)&lt;/code&gt;在运行后会改变类中属性&lt;code&gt;wasLastFileNameValid&lt;/code&gt;的值&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;//用于存储状态的结果用于以后的验证
public bool wasLastFileNameValid { get; set; }
//判断输入的字符串是否是.txt文件名
public bool isLastFilenameValid(string filename)
{
   if (!(filename .ToLower()).EndsWith(&quot;txt&quot;))
   {
       wasLastFileNameValid = false;
       return false ;
   }
   else
   {
       wasLastFileNameValid = true;
       return true;
   }
} &lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;单元测试函数：&lt;/p&gt;
&lt;p&gt;该测试是测试isLastFilenameValid()，&lt;/p&gt;
&lt;p&gt;因为该函数是把结果赋值给类中属性wasLastFileNameValid，&lt;/p&gt;
&lt;p&gt;所以此处验证的是Calculator类中属性wasLastFileNameValid是否符合我们的期望，&lt;/p&gt;
&lt;p&gt;而不是简单的验证isLastFilenameValid(）的返回值是否符合我们的期望。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;[TestMethod()]
public void isLastFilenameValid_ValidName_ReturnTrue()
{
    Calculator calc = new Calculator();
    string fileName = &quot;test.txt&quot;;
    calc.isLastFilenameValid(fileName)
    Assert.IsTrue(calc.wasLastFileNameValid);
  
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;hr/&gt;&lt;h3 id=&quot;单元测试在mvc模式中的实现&quot;&gt;8.单元测试在MVC模式中的实现&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/tylerzhou/p/11361598.html&quot;&gt;参考&lt;/a&gt;&lt;/p&gt;
&lt;ul readability=&quot;10.5&quot;&gt;&lt;li readability=&quot;24&quot;&gt;
&lt;p&gt;因为MVC模式中的Controller类中的Action的返回值是和普通类的方法不一样的，&lt;/p&gt;
&lt;p&gt;Action的返回值是ActionResult类型的，其子类又有许多，&lt;/p&gt;
&lt;p&gt;具体怎么实现对MVC模式的单元测试呢？请看一个简单的示例：&lt;/p&gt;
&lt;p&gt;代码背景：在一个MVC项目中的HomeController控制器中有一个Action是Index()&lt;/p&gt;
&lt;p&gt;首先先定义一个Person类其中有Id和Name两个属性&lt;/p&gt;
&lt;p&gt;Action如下：&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;  public class HomeController : Controller
  {
      // GET: Home
      public ActionResult Index()
      {
          return View(&quot;Index&quot;,new Person { Id = 001, Name = &quot;shanzm&quot; });
      }
  }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对上面的HomeController中的Index()进行一个简单的单元测试&lt;/p&gt;
&lt;p&gt;新建一个单元测试项目（或者在创建MVC项目的时候选中单元测试的按钮，则自动生成一个单元测试项目）&lt;/p&gt;
&lt;p&gt;注意一定要先安装MVC的程序集，NuGet:&lt;code&gt;Install-Package Microsoft.AspNet.Mvc -Version 5.2.3&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;  [TestMethod()]
  public void Index_Index_ReturnTrue()
  {
      //Arrage:准备测试对象
      HomeController hcont = new HomeController();
      //Act:执行测试函数
      ViewResult  result =(ViewResult)hcont.Index();
      var viewName = result.ViewName;
      Person model = (Person)result.Model;
      //Assert:断言符合期望
      Assert.IsTrue(viewName == &quot;Index&quot; &amp;amp;&amp;amp; model.Id == 001 &amp;amp;&amp;amp; model.Name == &quot;shanzm&quot;&amp;amp;&amp;amp; );
  }&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;说明：&lt;/p&gt;
&lt;ol readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果View()函数没指定视图，而是使用默认的视图，则视图名为空，所以如果名称不写的时候我们可以断言ViewName是空。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;注意在Action中的ViewBag传递的数据在单元测试中需要通过ViewData方式获取（因为ViewBag是对ViewData的动态封装，在同一个Action中二者数据相通，此乃ASP.NET MVC的基础，不详述）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;其实呀，MVC模式作为UI层，有许多东西其实是很难（但不是不可以）模拟对象去进行单元测试的，一般其实不推荐做过多的单元测试。（注意不是不做，是不做过多过复杂的单元测试）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr/&gt;&lt;h3 id=&quot;单元测试相关参考&quot;&gt;8.单元测试相关参考&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://book.douban.com/subject/25934516/&quot;&gt;书籍：.NET 单元测试的艺术&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://pan.baidu.com/s/11VuVW&quot;&gt;书籍：单元测试之道C#版&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/zh-cn/dotnet/core/testing/unit-testing-with-mstest&quot;&gt;微软：dotnet文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/ColdJokeLife/p/3158812.html&quot;&gt;博客园：对比MS Test与NUnit Test框架&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/tylerzhou/p/11300896.html&quot;&gt;博客园：.net持续集成测试篇之Nunit文件断言、字符串断言及集合断言&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/tylerzhou/p/11361598.html&quot;&gt;博客园：.netcore持续集成测试篇之MVC层单元测试&lt;/a&gt;&lt;/p&gt;

&lt;hr/&gt;&lt;h3 id=&quot;示例源代码下载&quot;&gt;9.示例源代码下载&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/shanzm/UnitTesting&quot;&gt;示例源代码下载&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 23 Jan 2020 03:57:00 +0000</pubDate>
<dc:creator>shanzm</dc:creator>
<og:description>[TOC] 志铭 2020年1月23日 11:49:41 1.单元测试概念 什么是单元测试？ 单元测试（unit testing）是一段自动化的代码，用来调用被测试的方法或类，而后验证基于该方法或类的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/shanzhiming/p/12230417.html</dc:identifier>
</item>
<item>
<title>关于随机数的前世今生 - CHNmuxii</title>
<link>http://www.cnblogs.com/CHNmuxii/p/12230361.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CHNmuxii/p/12230361.html</guid>
<description>&lt;p&gt;提起随机数，大家一定都不陌生。无论是在计算机科学领域，还是现实生活中，随机数的作用都不可小觑。&lt;/p&gt;
&lt;p&gt;但随机数究竟是怎么一会事？它的作用是什么？它有事如何产生的？&lt;/p&gt;
&lt;p&gt;本文会着重谈计算机的随机数以及产生算法，偏理论的只是会放到另一篇博客上[随机数那些事](https://www.luogu.org/blog/muxii/sui-ji-shuo-wei-wan-cheng-post)&lt;/p&gt;
&lt;p&gt;# 随机数定义及其性质&lt;/p&gt;
&lt;p&gt;想要讨论随机数，首先应该明确一下随机数的定义。毕竟这个东西比较虚，并不像算法那样明确。在各大网上也没有给出很好的定义。&lt;/p&gt;
&lt;p&gt;那...就不死抠定义了。&lt;/p&gt;
&lt;p&gt;随机数一般来说符合下面这几个性质。&lt;/p&gt;
&lt;p&gt;&amp;gt;1. 它产生时后面那个数与前面的毫无关系&lt;/p&gt;
&lt;p&gt;&amp;gt;1. 给定样本的一部分和随机算法，无法推出样本的剩余部分&lt;/p&gt;
&lt;p&gt;&amp;gt;1. 其随机样本不可重现&lt;/p&gt;
&lt;p&gt;另外还要说一下统计学伪随机数概念，**划重点**&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;##### 统计学伪随机性。统计学伪随机性指的是在给定的随机比特流样本中，1的数量大致等于0的数量，同理，“10”“01”“00”“11”四者数量大致相等。类似的标准被称为统计学随机性。满足这类要求的数字在人类“一眼看上去”是随机的。（摘自百度词条）&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;实际上这也是在计算机中对伪随机数优劣的概念。&lt;/p&gt;
&lt;p&gt;continue-&amp;gt;&lt;/p&gt;
&lt;p&gt;# 伪随机数&lt;/p&gt;
&lt;p&gt;伪随机数，也就是我们c++中常用的随机数。为什么说它是“伪”随机呢？其实只要稍微详细的了解过c++ rand函数的人应该都能懂得这一点。&lt;/p&gt;
&lt;p&gt;因为计算机本身并不能够产生和随机数，只能通过产生一组循环节很长的数来“伪造”随机。&lt;/p&gt;
&lt;p&gt;c++的rand函数实际上只是根据你提供的种子计算出来的一组循环节很长的数。只要两次提供的种子是一样的，那么rand函数提供的随机数也是一样的。&lt;/p&gt;
&lt;p&gt;可能有好奇的小伙伴就要问了，你说循环节很长，那到底长到什么程度呢？&lt;/p&gt;
&lt;p&gt;经过不懈的努力，笔者成功弄到了rand()函数在LINUX系统下的实现：&lt;/p&gt;
&lt;p&gt;```&lt;br/&gt;static unsigned long next = 1;&lt;/p&gt;
&lt;p&gt;/* RAND_MAX assumed to be 32767 */&lt;br/&gt;int myrand(void) {&lt;br/&gt;next = next * 1103515245 + 12345;&lt;br/&gt;return((unsigned)(next/65536) % 32768);&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;void mysrand(unsigned seed) {&lt;br/&gt;next = seed;&lt;br/&gt;}&lt;br/&gt;```&lt;br/&gt;（ 该代码摘自CSDN [原文链接](https://blog.csdn.net/Cashey1991/article/details/45042291)）&lt;/p&gt;
&lt;p&gt;通过这个算法我们可以推知，rand函数的循环节应该是在32768（2的15次方）以内。&lt;/p&gt;
&lt;p&gt;（ 所以我白测试了是吗 ）&lt;/p&gt;
&lt;p&gt;做这些测试实际上就是想说，在计算机方面。目前来说，如果不借助外部帮助，是无法达到真随机的。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;# 计算机的随机数&lt;/p&gt;
&lt;p&gt;计算机随机数的产生，我在讲伪随机时已经~~水过~~做过介绍了，也就不多说。&lt;/p&gt;
&lt;p&gt;你以为我会帮忙把前面的代码拷过来吗？想太多了，自己翻页去。&lt;/p&gt;
&lt;p&gt;（ 本来想放点图可能可以增加可读性，但好像放不了什么... ）&lt;/p&gt;
&lt;p&gt;这里我主要想讲的是关于计算机在没有外界帮助下为什么不能产生真随机数。&lt;/p&gt;
&lt;p&gt;真随机数的产生应该是与之前的数是没有任何关联的（ 论证过 ），那么在计算机中想对应的就是产生随机数的函数应该不需要调用任何参数（ 因为一旦调用了的参数，那么这个随机数的产生就会与参数相关 ）那么对于计算机来说，如何不调用任何参数并且产生不同的数呢？&lt;/p&gt;
&lt;p&gt;这个...好像做不到。&lt;/p&gt;
&lt;p&gt;这个换一个思维来解释好一点。因为计算机是一个绝对理智的存在，也就是说，计算机的一切行为都是可预测可推导的。而这恰恰违背了我们随机数标准中的第二条，即不可推断。对于计算机的任何程序，如果使用完全相同的参数来调用，它所输出的结果一定是完全一样的&lt;/p&gt;
&lt;p&gt;农夫山泉不生产水，他们只是大自然的搬运工&lt;/p&gt;
&lt;p&gt;![](https://cdn.luogu.com.cn/upload/pic/72418.png)&lt;/p&gt;
&lt;p&gt;计算机不生产数据，它只是数据的加工厂。&lt;/p&gt;
&lt;p&gt;![](https://cdn.luogu.com.cn/upload/pic/72433.png)&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;# 真随机数生成&lt;/p&gt;
&lt;p&gt;不是重点，知道了就好。&lt;/p&gt;
&lt;p&gt;真随机数生成器是一种通过物理过程而不是计算机程序来生成随机数字的设备。&lt;/p&gt;
&lt;p&gt;这样的设备通常是基于一些能生成低等级、统计学随机的“噪声”信号的微观现象，如热力学噪声、光电效应和量子现象。这些物理过程在理论上是完全不可预测的，并且已经得到了实验的证实。硬件随机数生成器通常由换能器、放大器和模拟数字转换器组成。其中换能器用来将物理过程中的某些效果转换为电信号，放大器及其电路用来将随机扰动的振幅放大到宏观级别，而模拟数字转换器则用来将输出变成数字，通常是二进制的零和一。通过重复采样这些随机的信号，一系列的随机数得以生成。&lt;/p&gt;
&lt;p&gt;（摘自百度词条[原文链接](https://baike.baidu.com/item/%E7%9C%9F%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8/13023188?fr=aladdin)）&lt;/p&gt;
&lt;p&gt;# 随机数在OI中的常见应用&lt;/p&gt;
&lt;p&gt;首先是用于检验程序。&lt;/p&gt;
&lt;p&gt;估计这是大部分OIer的用法，拿一个随机数生成器去验证程序的速度,以及是否会RE（ 正确率是测不了的，毕竟自己手推答案比较慢 ）。&lt;/p&gt;
&lt;p&gt;然后的话是某些算法的需要&lt;/p&gt;
&lt;p&gt;这里因为算法太多，笔者也就大概介绍一下：&lt;/p&gt;
&lt;p&gt;&amp;gt;1. 大家熟悉的平衡树treap，它是通过生成随机权值引导进行旋转操作来使树接近平衡。&lt;/p&gt;
&lt;p&gt;&amp;gt;2. 相对常见的模拟退火就是随机算法的一个极致实现。它通过完全随机的操作变换解，使其不断接近正解。也是大家在OI中最多的用法。&lt;/p&gt;
&lt;p&gt;&amp;gt;3. 可能大家相对陌生的遗传算法中也有随机数的体现。主要表现在交叉和变异两方面上。&lt;/p&gt;
&lt;p&gt;&amp;gt;4. 可能大家听都没通说过的Pollard_Rho算法，就是超大数的分解质因数。因为数字过大无法用O（N）的算法。此时我们就通过随机数去“猜”质因数：不断生成随机值，判断是否出现两者之差为因子。（因为两者差为指定值的出现概率会比一个个猜大一倍），然后不断递归随机到的那个因子和那个数初一因子的另一半，直到找到质因子。具体算法比较复杂。有机会单独写一篇讲。[模板题传送门](https://www.luogu.org/problem/P4718)&lt;/p&gt;
&lt;p&gt;&amp;gt;5. 然后与遗传算法类似的粒子群算法，随机主要出现在单个粒子的更新上。&lt;/p&gt;
&lt;p&gt;&amp;gt;6. 蚁群算法有用到，但因为过于冷门，就不多做介绍了。&lt;/p&gt;
&lt;p&gt;（ 感觉随机数好像也就这么点用，在密码学统计学中用的比较多 ）&lt;/p&gt;
&lt;p&gt;# 随机数优劣判定&lt;/p&gt;
&lt;p&gt;在讲随机数算法之前，应该先讲讲随机数优劣的判定。&lt;/p&gt;
&lt;p&gt;毕竟只有清除了随机数的优劣，我们才能说如何生成优质随机数。&lt;/p&gt;
&lt;p&gt;在这里我们就要用到前面说的统计学伪随机性：&lt;/p&gt;
&lt;p&gt;统计学伪随机性。统计学伪随机性指的是在给定的随机比特流样本中，1的数量大致等于0的数量，同理，“10”“01”“00”“11”四者数量大致相等。类似的标准被称为统计学随机性。满足这类要求的数字在人类“一眼看上去”是随机的。（我帮忙搬下来了）&lt;/p&gt;
&lt;p&gt;结合计算机随机数的特性，我们能够得出以下三项判断随机数优劣的性质：&lt;/p&gt;
&lt;p&gt;&amp;gt;1. 随机程度，即随机算法是否足够复杂，随机数之间会不会存在明显联系。&lt;/p&gt;
&lt;p&gt;&amp;gt;2. 分布范围，即是否存在随机数在分布区域内大量出现偏大偏小的现象。分布是否足够平均。&lt;/p&gt;
&lt;p&gt;&amp;gt;3. 循环长度，即是否会在大量调用时很快地出现循环的情况。&lt;/p&gt;
&lt;p&gt;有了这些评判规则，我们就比较好学习优质随机数的生成。&lt;/p&gt;
&lt;p&gt;# 如何生成优质随机数&lt;/p&gt;
&lt;p&gt;终于到了塞实货时间。&lt;/p&gt;
&lt;p&gt;~~水不动了~~&lt;/p&gt;
&lt;p&gt;这里前三个我讲一下在rand函数调用基础上自己做一点小操作来产生三种不同特性的随机数。&lt;/p&gt;
&lt;p&gt;第四个专题讲MT19337算法（**重点，绝对的重点**），也就是目前优质随机数生成的普遍算法。&lt;/p&gt;
&lt;p&gt;### 来回摆动式&lt;/p&gt;
&lt;p&gt;这种随机数主要是针对退火算法之类的需要用随机数来修正答案的。&lt;/p&gt;
&lt;p&gt;既然是修正答案，那么我们希望最好是来回摆动，一正一负的。&lt;/p&gt;
&lt;p&gt;这种随机数的特点便是通过一部分人工处理，将原本的rand函数产生的随机数变成正负交替的。&lt;/p&gt;
&lt;p&gt;```cpp&lt;br/&gt;int f = 3000 ;&lt;br/&gt;int change = 0.999 ; // f和change是用来控制随机数幅度不断变小的&lt;br/&gt;int con = -1 ;&lt;br/&gt;int g = 1 ; // 控制正负交替&lt;br/&gt;int newrand ( ) {&lt;br/&gt;f *= change ;&lt;br/&gt;g *= con ;&lt;br/&gt;int tmp = f * g * rand ( ) ;&lt;br/&gt;return tmp ;&lt;br/&gt;}&lt;br/&gt;```&lt;/p&gt;
&lt;p&gt;这种随机数的产生引入了退火的思路，当然，你也可以直接使用算法中现成的温度来控制。&lt;/p&gt;
&lt;p&gt;### 平均式&lt;/p&gt;
&lt;p&gt;这种主要是用于平衡树treap的，特点就是在保证单个数随机的情况下在整体上保证分布比较平均。&lt;/p&gt;
&lt;p&gt;实现原理也没什么好讲的，上代码就完事了。&lt;/p&gt;
&lt;p&gt;```cpp&lt;br/&gt;int p ; // 希望的分布位置&lt;br/&gt;int newrand ( ) {&lt;br/&gt;int tmp = ( p + rand ( ) ) / 2 ; // 通过取于分布位置的平均数，是产生的数更加靠近希望分布&lt;br/&gt;return tmp ;&lt;br/&gt;}&lt;br/&gt;```&lt;/p&gt;
&lt;p&gt;### 多次调用不重复式&lt;/p&gt;
&lt;p&gt;当然，如果有人真的需要非常接近真随机的数。也就是多次运行程序也不会出现相同的情况。那就需要用到一定的外部干扰了。&lt;/p&gt;
&lt;p&gt;首先是clock函数，上文已经说过，一个程序在不断调用期间。每一次的运行时间都会有细小的变化。我们就可以利用好这个变化。每次调用完后都重置一次随机数种子。&lt;/p&gt;
&lt;p&gt;还有一个可能大家都会忽视的方法。计算机本身的误差。众所周知，计算机在做浮点运算时是会产生精度损失的，那么我们也可以利用这个特点辅助clock调整种子（毕竟程序调用时间相同其实可能性也不小，毕竟clock只精确到s/1000）。&lt;/p&gt;
&lt;p&gt;```cpp&lt;br/&gt;int count ;&lt;br/&gt;int realrand ( ) {&lt;br/&gt;count ++ ;&lt;br/&gt;int t = clock ( ) + 1 ; // 使用当前时间&lt;br/&gt;for ( int i = 1 ; i &amp;lt; 12121307 ; i ++ ) { // 降速（如果放到具体代码里面使用可以将此参数调低）&lt;br/&gt;t += rand ( ) ;&lt;br/&gt;}&lt;br/&gt;t += clock ( ) ; // 降速后扩大时间变化&lt;br/&gt;t *= -1234 ;&lt;br/&gt;srand ( t * count + rand ( ) ) ; // 重置随机数种子&lt;br/&gt;return rand ( ) ;&lt;br/&gt;}&lt;br/&gt;```&lt;/p&gt;
&lt;p&gt;笔者经过大量实验，发现该函数前三个数出现重复几率相对会比较大（7~9%）建议从第四个开始使用。&lt;/p&gt;
&lt;p&gt;上面的代码我并没用用精度损失来随机化，因为我发现同一个式子的进度损失值太小，以至于几乎不会发生什么改变，所以并没有使用。&lt;/p&gt;
&lt;p&gt;### 随机数优劣度分析：&lt;/p&gt;
&lt;p&gt;因为三个函数实际上都是在调用rand()函数，所以实际上他们的优质程度是与rand()函数相同的。记得我之前题的判断随机数优劣的标准吗？&lt;/p&gt;
&lt;p&gt;&amp;gt;1. 随机程度，即随机算法是否足够复杂，随机数之间会不会存在明显联系。&lt;/p&gt;
&lt;p&gt;&amp;gt;2. 分布范围，即是否存在随机数在分布区域内大量出现偏大偏小的现象。分布是否足够平均。&lt;/p&gt;
&lt;p&gt;&amp;gt;3. 循环长度，即是否会在大量调用时很快地出现循环的情况。&lt;/p&gt;
&lt;p&gt;就是这个&lt;/p&gt;
&lt;p&gt;我们来逐条分析。&lt;/p&gt;
&lt;p&gt;首先，随机程度方面，虽然你们之前看过rand()函数代码，可能清楚数字之间的关联&lt;br/&gt;。但在实际运用中，这个数字之间的关联还是基本可以忽略的。所以在随机程度方面，rand()函数还是能够勉强通过的。&lt;/p&gt;
&lt;p&gt;在平均分布方面，单看代码可能感觉不出来。&lt;/p&gt;
&lt;p&gt;那么，笔者就做一个测试：&lt;/p&gt;
&lt;p&gt;```cpp&lt;br/&gt;#include&amp;lt;iostream&amp;gt;&lt;br/&gt;#include&amp;lt;stdlib.h&amp;gt;&lt;br/&gt;using namespace std ;&lt;br/&gt;int data[1000] ;&lt;br/&gt;int main ( ) {&lt;br/&gt;for ( long long i = 1 ; i &amp;lt;= 100000000 ; i ++ ){&lt;br/&gt;int tmp = rand ( ) % 100000 ; //生成一个100000以内的随机数&lt;br/&gt;data[ tmp / 10 ] ++ ; //统计出现次数&lt;br/&gt;}&lt;br/&gt;for ( int i = 1 ; i &amp;lt;= 100 ; i ++ ) {&lt;br/&gt;cout &amp;lt;&amp;lt; data[i] &amp;lt;&amp;lt; endl ;&lt;br/&gt;}&lt;br/&gt;cout &amp;lt;&amp;lt; &quot; ok &quot; &amp;lt;&amp;lt; endl ;&lt;br/&gt;return 0 ;&lt;br/&gt;}&lt;br/&gt;```&lt;/p&gt;
&lt;p&gt;最后结果：&lt;/p&gt;
&lt;p&gt;![结果](https://cdn.luogu.com.cn/upload/image_hosting/4xqo9q63.png)&lt;/p&gt;
&lt;p&gt;从中我们可以看到，这个分布还是非常平均的。&lt;/p&gt;
&lt;p&gt;循环长度...&lt;/p&gt;
&lt;p&gt;这个主要就是rand()函数的硬伤了，32768这个长度真的挺不够用的。在需要大量调用rand()函数的算法中（比如退火），基本都会把rand()卡出循环。&lt;/p&gt;
&lt;p&gt;那有没有既优质又循环节长的算法呢？&lt;/p&gt;
&lt;p&gt;# 梅森旋转算法（MT19337）&lt;/p&gt;
&lt;p&gt;**这个很重要，所以标题升了一级**&lt;/p&gt;
&lt;p&gt;这个是目前产生优质伪随机数的普遍算法&lt;/p&gt;
&lt;p&gt;在C++11，python等多种语言中都有使用# 旋转算法简介&lt;/p&gt;
&lt;p&gt;梅森旋转算法，也可以写作MT19937。是有由松本真和西村拓士在1997年开发的一种能快速产生优质随机数的算法。&lt;/p&gt;
&lt;p&gt;其实这个算法跟梅森没有什么关系，它之所以叫做是梅森旋转算法是因为它的循环节是2^19937-1，这个叫做梅森素数。&lt;/p&gt;
&lt;p&gt;这个算法之所以说是产生优质随机数，是因为它在循环节特别长的情况下（2^19337-1）还能保证平均分布。&lt;/p&gt;
&lt;p&gt;#### 可能有的同学对这个循环节有点质疑。可能觉得2^19937-1有点短？&lt;/p&gt;&lt;p&gt;我在这里大概给一个概念：&lt;/p&gt;
&lt;p&gt;银河系中的恒星数量级10^11&lt;/p&gt;
&lt;p&gt;撒哈拉沙漠中的沙子数数量级是10^26&lt;/p&gt;
&lt;p&gt;宇宙中目前可观察的粒子数量级是10^87&lt;/p&gt;
&lt;p&gt;**2^19937数量级是10^6001**&lt;/p&gt;
&lt;p&gt;这个比较大概心里有数了吧&lt;/p&gt;
&lt;p&gt;相差的已经不止是一个数量级了&lt;/p&gt;
&lt;p&gt;同时他在623维中的分布都十分的均匀（这个不用理解）&lt;/p&gt;
&lt;p&gt;知道分布平均就好了&lt;/p&gt;
&lt;p&gt;![梅森](https://cdn.luogu.com.cn/upload/pic/74125.png)&lt;/p&gt;
&lt;p&gt;（梅森镇楼）&lt;/p&gt;
&lt;p&gt;-&amp;gt;continue&lt;/p&gt;
&lt;p&gt;# 前置知识&lt;/p&gt;
&lt;p&gt;分析这个算法的原理需要的前置知识在网上讲的都比较绕，我在这里就通俗的科普一下，主要是认识这几个名词。&lt;/p&gt;
&lt;p&gt;（用词不准确轻喷）&lt;/p&gt;
&lt;p&gt;#### 线性反馈移位寄存器（LFSR）&lt;/p&gt;
&lt;p&gt;![线性反馈位移寄存器](https://cdn.luogu.com.cn/upload/pic/74127.png)&lt;/p&gt;
&lt;p&gt;这个，就当它是随机数发生器就完事了，不要太去纠结定义。后面会讲。&lt;/p&gt;
&lt;p&gt;#### 本原多项式&lt;/p&gt;
&lt;p&gt;简单的说来就是没法化简的多项式&lt;/p&gt;
&lt;p&gt;比如 $y=x^4+x^2$ 就可以化简为$( x^2 + 1) x ^ 2$&lt;/p&gt;
&lt;p&gt;也是知道就好，不用过于追求定义&lt;/p&gt;
&lt;p&gt;#### 级&lt;/p&gt;
&lt;p&gt;计算机的一个二进制单位（0或1）就是一级&lt;/p&gt;
&lt;p&gt;这个应该比较好理解&lt;/p&gt;
&lt;p&gt;#### 反馈函数&lt;/p&gt;
&lt;p&gt;这个应该是网上看别的博客最绕的知识点&lt;/p&gt;
&lt;p&gt;简单地理解成你要对这个寄存器干什么的一个函数就好了&lt;/p&gt;
&lt;p&gt;（看到这里应该还没懵吧）&lt;/p&gt;
&lt;p&gt;#### 异或&lt;/p&gt;
&lt;p&gt;这个...&lt;/p&gt;
&lt;p&gt;还要我科普吗？&lt;/p&gt;
&lt;p&gt;就是两个数，如果都是0或都是1就输出0，一个1一个0输出1.&lt;/p&gt;
&lt;p&gt;-&amp;gt;continue&lt;/p&gt;
&lt;p&gt;# 原理分析&lt;/p&gt;
&lt;p&gt;这个旋转算法实际上是对一个19937级的二进制序列作变换。&lt;/p&gt;
&lt;p&gt;首先我们达成一个共识：&lt;/p&gt;
&lt;p&gt;一个长度为n的二进制序列，它的排列长度最长为2^n。&lt;/p&gt;
&lt;p&gt;当然这个也是理论上的，实际上可能因为某些操作不当，没挺到2^n个就开始循环了。&lt;/p&gt;
&lt;p&gt;那么如何将这个序列的排列撑满2^n个，就是这个旋转算法的精髓。&lt;/p&gt;
&lt;p&gt;**如果反馈函数的本身+1是一个本原多项式，那么它的循环节达到最长，即2^n-1**&lt;/p&gt;
&lt;p&gt;这个数学证明本文不作过多论述，有兴趣者可以自己查阅资料&lt;/p&gt;
&lt;p&gt;个人感觉单讲知识点挺难懂的（笔者就是这么被坑的）&lt;/p&gt;
&lt;p&gt;我们就拿一个4级的寄存器模拟一下：&lt;/p&gt;
&lt;p&gt;我们这里使用的反馈函数是 y=x^4+x^2+x+1（这个不是本原多项式，只是拿来好理解）&lt;/p&gt;
&lt;p&gt;这个式子中x^4,x^2,x的意思就是我们每次对这个二进制序列的从后往前数第4位和第2位做异或运算 ，然后x的意思是我们再拿结果和最后一位做异或运算。把最后的结果放到序列的开头，整个序列后移一位，最后一位舍弃。&lt;/p&gt;
&lt;p&gt;![第一步](https://cdn.luogu.com.cn/upload/pic/74139.png)&lt;/p&gt;
&lt;p&gt;1. 初始数组 { 1 ， 0 ， 0 ， 0 } （为什么不是 0，0，0，0 你们可以自己想想，文章末尾揭晓）&lt;/p&gt;
&lt;p&gt;![第二步](https://cdn.luogu.com.cn/upload/pic/74141.png)&lt;/p&gt;
&lt;p&gt;2. 将它的第四位和第二位抓出来做异或运算&lt;/p&gt;
&lt;p&gt;![第三步](https://cdn.luogu.com.cn/upload/pic/74143.png)&lt;/p&gt;
&lt;p&gt;3. 把刚刚的运算结果和最后一位再做一次运算&lt;/p&gt;
&lt;p&gt;![第四步](https://cdn.luogu.com.cn/upload/pic/74144.png)&lt;/p&gt;
&lt;p&gt;4. 把最后的运算结果放到第一位，序列后移。最后一位被无情的抛弃&lt;/p&gt;
&lt;p&gt;这就是一次运算，然后这个算法就是不断循环这几步，从而不断伪随机改变这个序列。&lt;/p&gt;
&lt;p&gt;![](https://cdn.luogu.com.cn/upload/pic/74151.png)&lt;/p&gt;
&lt;p&gt;上图是一个网上找的一个4级寄存器的模拟过程&lt;/p&gt;
&lt;p&gt;大家可以推一下，它所使用的反馈函数（y=x^4+x+1）&lt;/p&gt;
&lt;p&gt;因为这个是本原多项式&lt;/p&gt;
&lt;p&gt;所以他最后的循环节是2^4-1=15&lt;/p&gt;
&lt;p&gt;运算结果如下：&lt;/p&gt;
&lt;p&gt;![结果](https://cdn.luogu.com.cn/upload/pic/74152.png)&lt;/p&gt;
&lt;p&gt;（图片摘自[原文链接](https://www.cnblogs.com/mengfanrong/p/3840765.html)）&lt;/p&gt;
&lt;p&gt;大家可以看到这个运算结果包含到了2^4-1~1中的所有数字，并且没有循环。&lt;/p&gt;
&lt;p&gt;同时拥有很好的随机性。&lt;/p&gt;
&lt;p&gt;可能又有人有疑问了：&lt;/p&gt;
&lt;p&gt;这个运算结果明明能看出规律啊，我不是看到了很多1的平行四边形吗？&lt;/p&gt;
&lt;p&gt;醒醒&lt;/p&gt;
&lt;p&gt;这是二进制数。&lt;/p&gt;
&lt;p&gt;如果你把它转化成数字。&lt;/p&gt;
&lt;p&gt;8 12 14 15 7 11 ...&lt;/p&gt;
&lt;p&gt;能看出规律？&lt;/p&gt;
&lt;p&gt;#### 关于旋转&lt;/p&gt;
&lt;p&gt;可能有人到这里还没看出“旋转”在哪里。&lt;/p&gt;
&lt;p&gt;因为我们每次计算出来的结果会放在开头，序列后移一位。看起来就像数组在向后旋转...&lt;/p&gt;
&lt;p&gt;（本来想做gif的，后来不知道怎么做出旋转）&lt;/p&gt;
&lt;p&gt;大家自行脑补&lt;/p&gt;
&lt;p&gt;![](https://cdn.luogu.com.cn/upload/pic/74153.png)&lt;/p&gt;
&lt;p&gt;-&amp;gt;continue&lt;/p&gt;
&lt;p&gt;### 算法评价&lt;/p&gt;
&lt;p&gt;1.随机程度：&lt;/p&gt;
&lt;p&gt;这个应该不用说了，认真看这个原理的都应该清楚它的随机程度比rand（）~~不知道高到哪里去了~~。如果说rand（）还能够用公式表达的话，这个19337已经无法通过算式表达了。&lt;/p&gt;
&lt;p&gt;2.分布范围：&lt;/p&gt;
&lt;p&gt;这里笔者~~比较懒~~就不做证明了。有兴趣的可以拿上面的代码自行检测。&lt;/p&gt;
&lt;p&gt;3.循环长度：&lt;/p&gt;
&lt;p&gt;其实这点我可以直接跳过的。19337算法最不慌的就是循环长度。2^19337的循环长度根本不需任何算法。毕竟人家这个算法的循环长度是与空间大小成指数级关系的……&lt;/p&gt;
&lt;p&gt;# 代码实现&lt;/p&gt;
&lt;p&gt;（笔者很懒，直接搬[原代码出处](http://www.it610.com/article/1902097.htm)的代码）&lt;/p&gt;
&lt;p&gt;```cpp&lt;br/&gt;#include &amp;lt;iostream&amp;gt;&lt;br/&gt;#include &amp;lt;string.h&amp;gt;&lt;br/&gt;#include &amp;lt;stdio.h&amp;gt;&lt;br/&gt;#include &amp;lt;time.h&amp;gt;&lt;/p&gt;
&lt;p&gt;using namespace std;&lt;/p&gt;
&lt;p&gt;bool isInit;&lt;br/&gt;int index;&lt;br/&gt;int MT[624]; //624 * 32 - 31 = 19937&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;随机种子&lt;br/&gt;void srand(int seed)&lt;br/&gt;{&lt;br/&gt;index = 0;&lt;br/&gt;isInit = 1;&lt;br/&gt;MT[0] = seed;&lt;br/&gt;for(int i=1; i&amp;lt;624; i++)&lt;br/&gt;{&lt;br/&gt;int t = 1812433253 * (MT[i-1] ^ (MT[i-1] &amp;gt;&amp;gt; 30)) + i;&lt;br/&gt;MT[i] = t &amp;amp; 0xffffffff; //取最后的32位&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;梅森旋转&lt;br/&gt;void generate()&lt;br/&gt;{&lt;br/&gt;for(int i=0; i&amp;lt;624; i++)&lt;br/&gt;{&lt;br/&gt;// 2^31 = 0x80000000&lt;br/&gt;// 2^31-1 = 0x7fffffff&lt;br/&gt;int y = (MT[i] &amp;amp; 0x80000000) + (MT[(i+1) % 624] &amp;amp; 0x7fffffff);&lt;br/&gt;MT[i] = MT[(i + 397) % 624] ^ (y &amp;gt;&amp;gt; 1);&lt;br/&gt;if (y &amp;amp; 1)&lt;br/&gt;MT[i] ^= 2567483615;&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;输出函数&lt;br/&gt;int rand()&lt;br/&gt;{&lt;br/&gt;if(!isInit)&lt;br/&gt;srand((int)time(NULL));&lt;br/&gt;if(index == 0)&lt;br/&gt;generate();&lt;br/&gt;int y = MT[index];&lt;br/&gt;y = y ^ (y &amp;gt;&amp;gt; 11);&lt;br/&gt;y = y ^ ((y &amp;lt;&amp;lt; 7) &amp;amp; 2636928640);&lt;br/&gt;y = y ^ ((y &amp;lt;&amp;lt; 15) &amp;amp; 4022730752);&lt;br/&gt;y = y ^ (y &amp;gt;&amp;gt; 18);&lt;br/&gt;index = (index + 1) % 624;&lt;br/&gt;return y; //笔者注：y即为产生的随机数&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;int main()&lt;br/&gt;{&lt;br/&gt;srand(0); //设置随机种子&lt;br/&gt;int cnt = 0;&lt;br/&gt;for(int i=0; i&amp;lt;1000000; i++) //下面的循环是用来判断随机数的奇偶概率的&lt;br/&gt;{&lt;br/&gt;if(rand() &amp;amp; 1)&lt;br/&gt;cnt++;&lt;br/&gt;}&lt;br/&gt;cout&amp;lt;&amp;lt;cnt / 10000.0&amp;lt;&amp;lt;&quot;%&quot;&amp;lt;&amp;lt;endl;&lt;br/&gt;return 0;&lt;br/&gt;}&lt;br/&gt;```&lt;/p&gt;
&lt;p&gt;-&amp;gt;continue&lt;/p&gt;
&lt;p&gt;# 填一下前面的坑&lt;/p&gt;
&lt;p&gt;这里回答一下前面的那个问题：&lt;/p&gt;
&lt;p&gt;为什么循环节是2^n-1而不是2^n&lt;/p&gt;
&lt;p&gt;这个问题的答案和为什么初始序列不能是 { 0 , 0 , 0 , 0 }是一样的，因为如果全是0的话，无论怎么异或运算都不能产生循环。那么还怎么伪随机啊。&lt;/p&gt;
&lt;p&gt;因为不能是全0，所以循环节要-1&lt;/p&gt;
&lt;p&gt;最后非常感谢你能有耐心读到这里。&lt;/p&gt;
&lt;p&gt;本文到这里应该就 ~~水完~~ 结束了，当然，既然你好不容易看到了这里，我就给一个彩蛋吧（ 有点勉强 ）。&lt;/p&gt;
&lt;p&gt;关于rand函数为什么是用1103515245和12345这两个数...你可以理解为玄学。 不过真是原因是用这两个数推算出来的的随机数分布相对平均。更符合伪随机数的特性。（ 这个我尽力用实验来论证，目前还在构思，也可能正在实验 ）&lt;/p&gt;
&lt;p&gt;感谢@[qbu666666](https://www.luogu.org/space/show?uid=157598)和@[dgklr](https://www.luogu.org/space/show?uid=157598)大佬对本文文字错误以及论述缺陷的指出。&lt;/p&gt;
&lt;p&gt;然后特别感谢一下@[MZW_BG](https://www.luogu.org/space/show?uid=97504)对本文真随机部分的提醒以及帮助。&lt;/p&gt;
&lt;p&gt;大家都很强，可与之共勉。&lt;/p&gt;
</description>
<pubDate>Thu, 23 Jan 2020 03:17:00 +0000</pubDate>
<dc:creator>CHNmuxii</dc:creator>
<og:description>提起随机数，大家一定都不陌生。无论是在计算机科学领域，还是现实生活中，随机数的作用都不可小觑。 但随机数究竟是怎么一会事？它的作用是什么？它有事如何产生的？ 本文会着重谈计算机的随机数以及产生算法，偏</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/CHNmuxii/p/12230361.html</dc:identifier>
</item>
</channel>
</rss>