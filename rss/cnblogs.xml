<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>JUC中的原子操作类及其原理 - java小新人</title>
<link>http://www.cnblogs.com/wyq1995/p/12240777.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wyq1995/p/12240777.html</guid>
<description>&lt;p&gt;　　昨天简单的看了看Unsafe的使用，今天我们看看JUC中的原子类是怎么使用Unsafe的，以及分析一下其中的原理！&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;一.简单使用AtomicLong&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　还记的上一篇博客中我们使用了volatile关键字修饰了一个int类型的变量，然后两个线程，分别对这个变量进行10000次+1操作，最后结果不是20000，现在我们改成AtomicLong之后，你会发现结果始终都是20000了！有兴趣的可以试试，代码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.example.demo.study;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.atomic.AtomicLong;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Study0127 {

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这是一个全局变量,注意，这里使用了一个原子类AtomicLong&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; AtomicLong num = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AtomicLong();

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;每次调用这个方法，都会对全局变量加一操作，执行10000次&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; sum() {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 10000; i++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用了原子类的incrementAndGet方法，其实就是把num++封装成原子操作&lt;/span&gt;
&lt;span&gt;            num.incrementAndGet();
            System.out.println(&lt;/span&gt;&quot;当前num的值为num= &quot;+&lt;span&gt; num);
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
        Study0127 demo &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Study0127();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;下面就是新建两个线程,分别调用一次sum方法&lt;/span&gt;
        &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                demo.sum();
            }
        }).start();

        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {

            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                demo.sum();
            }
        }).start();    
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;二.走近AtomicLong类&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　在java中JDK 1.5之后，就出现了一个包，简称JUC并发包，全称就是java.util .concurrent，其中我们应该听说过一个类ConcurrentHashMap，这个map挺有意思的，有兴趣可以看看源码！还有很多并发时候需要使用的类比如AtomicInteger，AtomicLong，AtomicBoolean等等，其实都差不多，这次我们就简单看看AtomicLong，其他的几个类也差不多&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; AtomicLong &lt;span&gt;extends&lt;/span&gt; Number &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; java.io.Serializable {
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取Unsafe对象，上篇博客说了我们自己的类中不能使用这种方式的原因，但是官方的这个类为什么可以这样获取呢？因为本类AtomicLong
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;就是在rt.jar包下面，本类就是用Bootstrap类加载的，所以就可以用这种方式&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Unsafe unsafe =&lt;span&gt; Unsafe.getUnsafe();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;value这个字段的偏移量&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; valueOffset;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断jvm是否支持long类型的CAS操作&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; VM_SUPPORTS_LONG_CAS =&lt;span&gt; VMSupportsCS8();
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; VMSupportsCS8();

    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            valueOffset &lt;/span&gt;=&lt;span&gt; unsafe.objectFieldOffset
                (AtomicLong.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;.getDeclaredField(&quot;value&quot;&lt;span&gt;));
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt; (Exception ex) { &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Error(ex); }
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里用了volatile使的多线程下可见性，一定要分清楚原子性和可见性啊&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; value;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;两个构造器不多说&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; AtomicLong() {
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; AtomicLong(&lt;span&gt;long&lt;/span&gt;&lt;span&gt; initialValue) {
        value &lt;/span&gt;=&lt;span&gt; initialValue;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　然后我们看看AtomicLong的+1操作，可以看到使用的还是unsafe这个类，只需要看看getAndAddLong方法就可以了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1368608/202001/1368608-20200129160000571-1242234621.png&quot; alt=&quot;&quot; width=&quot;514&quot; height=&quot;62&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　方法getAndAddLong里面就是进行了CAS操作，可以看成如果同时有多个线程都调用incrementAndGet方法进行+1，那么同一时间只有一个线程会去进行操作，而其他的会不断的使用CAS去尝试+1，每次尝试的时候都会去主内存中获取最新的值；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; getAndAddLong(Object o, &lt;span&gt;long&lt;/span&gt; offset, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; delta) {
        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt; v;
        &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt; {&lt;br/&gt;　　　　&lt;span&gt;//这个方法就是重新获取主内存的值，因为使用了volatile修饰了那个变量，所以缓存就没用了&lt;/span&gt;
            v &lt;/span&gt;=&lt;span&gt; getLongVolatile(o, offset);
　　　　&lt;/span&gt;&lt;span&gt;//这里就是一个dowhile无限循环，多个线程不断的调用compareAndSwapLong方法去设置值，其实就是CAS，没什么特别好说的吧，&lt;br/&gt;　　　　//当某个线程CAS成功就跳出这个循环，否则就一直在循环不断的尝试，这也是CAS和线程阻塞的区别
&lt;/span&gt;        } &lt;span&gt;while&lt;/span&gt; (!compareAndSwapLong(o, offset, v, v +&lt;span&gt; delta));
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; v;
    }&lt;br/&gt;&lt;/span&gt;&lt;span&gt;//这个CAS方法看不到，c实现的
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; compareAndSwapLong(Object o, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; offset,&lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt; expected,&lt;/span&gt;&lt;span&gt;long&lt;/span&gt; x);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　有兴趣的可以看看AtomicLong的其他方法，很多都一样，CAS是核心&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;三.CAS的不足以及认识LongAdder&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　从上面的例子中，我们可以知道在多线程下使用AtomicLong类的时候，&lt;strong&gt;&lt;span&gt;同一个时刻使用那个共享变量的只能是一个线程&lt;/span&gt;&lt;/strong&gt;，其他的线程都是在无限循环，这种循环也是需要消耗性能的，如果线程比较多，很多的线程都在各自的无限循环中，或者叫做多个线程都在自旋；每个线程都在自旋无数次真的是比较坑，比较消耗性能，我们可以想办法自旋一定的次数，线程就结束运行了，有兴趣的可以了解一下自旋锁，其实就是这么一个原理，很容易，哈哈哈！&lt;/p&gt;
&lt;p&gt;　　在JDK8之后，提供了一个更好的类取代AtomicLong，那就是LongAdder，上面说过同一时间只有一个线程在使用那个共享变量，其他的线程都在自旋，那么如果可以把这个共享变量拆开成多个部分，那么是不是可以多个线程同时可以去操作呢？然后操作完之后再综合起来，有点分治法的思想，分而治之，最后综合起来。&lt;/p&gt;
&lt;p&gt;　　那么我们怎么把那个共享变量拆成多个部分呢？&lt;/p&gt;
&lt;p&gt;　　在LongAdder中是这样处理的，把那个变量拆成一个base（这个是long类型的，初始值为0）和一个Cell（这个里面封装了一个long类型的值，初始值为0），每个线程只会去竞争很多Cell就行了，最后把多个Cell中的值和base累加起来就是最终结果；而且一个线程如果没有竞争到Cell之后不会傻傻的自旋，直接想办法去竞争下一个Cell；&lt;/p&gt;
&lt;p&gt;　　下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1368608/202001/1368608-20200129163638213-1825657354.png&quot; alt=&quot;&quot; width=&quot;459&quot; height=&quot;233&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;四.简单使用LongAdder&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　用法其实和AtomicLong差不多，有兴趣的可以试试，最后的结果始终都是20000&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.example.demo.study;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.atomic.LongAdder;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Study0127 {

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;strong&gt;&lt;span&gt;这里使用LongAdder类&lt;/span&gt;&lt;/strong&gt;
    &lt;span&gt;public&lt;/span&gt; LongAdder num = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LongAdder();

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;每次调用这个方法，都会对全局变量加一操作，执行10000次&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; sum() {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 10000; i++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;&lt;strong&gt;LongAdder类的自增操作，相当于i++&lt;/strong&gt;&lt;/span&gt;
&lt;span&gt;            num.increment();
            System.out.println(&lt;/span&gt;&quot;当前num的值为num= &quot;+&lt;span&gt; num);
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
        Study0127 demo &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Study0127();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;下面就是新建两个线程,分别调用一次sum方法&lt;/span&gt;
        &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                demo.sum();
            }
        }).start();

        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {

            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                demo.sum();
            }
        }).start();    
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;五.走进LongAdder&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　从上面可以看到base只能是一个，而Cell可能有多个，而且Cell太多了也是很占内存的，所以一开始的时候不会创建Cell，只有在需要时才创建，也叫做惰性加载。&lt;/p&gt;
&lt;p&gt;　　我们可以知道LongAdder是继承自Striped64这个类的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1368608/202001/1368608-20200129165932363-930817746.png&quot; alt=&quot;&quot; width=&quot;537&quot; height=&quot;23&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　而Striped64类中有三个字段，cells数组用于存放多个Cell，一个是base不多说，还有一个cellsBusy用来实现自旋锁，状态只能是0或1(0表示Cell数组没有被初始化和扩容，也没有正在创建Cell元素，反之则为1)，在创建Cell，初始化Cell数组或者扩容Cell数组的时候，就会用到这个字段，保证同一时刻只有一个线程可以进行其中之一的操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1368608/202001/1368608-20200129170112675-2060638286.png&quot; alt=&quot;&quot; width=&quot;346&quot; height=&quot;219&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;1.我们简单看看Cell的结构&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　从下面代码中可以很清楚的看到所谓的Cell就是对一个long类型变量的CAS操作&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
@sun.misc.Contended &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个注解的作用是为了避免伪共享，至于什么伪共享，后面有机会再说说&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Cell {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;每个Cell类中就是这个声明的变量后期要进行累加的&lt;/span&gt;
    &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; value;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;构造函数&lt;/span&gt;
    Cell(&lt;span&gt;long&lt;/span&gt; x) { value =&lt;span&gt; x; }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Unsafe对象&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; sun.misc.Unsafe UNSAFE;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;value的偏移量&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; valueOffset;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个静态代码块中就是获取Unsafe对象和偏移量的&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            UNSAFE &lt;/span&gt;=&lt;span&gt; sun.misc.Unsafe.getUnsafe();
            Class&lt;/span&gt;&amp;lt;?&amp;gt; ak = Cell.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;;
            valueOffset &lt;/span&gt;=&lt;span&gt; UNSAFE.objectFieldOffset
                (ak.getDeclaredField(&lt;/span&gt;&quot;value&quot;&lt;span&gt;));
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Error(e);
        }
    }
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;CAS操作，没什么好说的&lt;/span&gt;
    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; cas(&lt;span&gt;long&lt;/span&gt; cmp, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; val) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; UNSAFE.compareAndSwapLong(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, valueOffset, cmp, val);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;2.LongAdder类自增方法increment()&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　我们可以看到increment()方法其实就是调用了add方法，我们需要关注add方法干了一些什么；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1368608/202001/1368608-20200129224543103-1343564658.png&quot; alt=&quot;&quot; width=&quot;339&quot; height=&quot;88&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1368608/202001/1368608-20200129224603929-540208854.png&quot; alt=&quot;&quot; width=&quot;522&quot; height=&quot;181&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1368608/202001/1368608-20200129225050671-1131281337.png&quot; alt=&quot;&quot; width=&quot;465&quot; height=&quot;58&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; add(&lt;span&gt;long&lt;/span&gt;&lt;span&gt; x) {
    Cell[] as; &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; b, v; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; m; Cell a;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里的cells是父类Striped64中的，不为空的话就保存到as中，然后调用casBase方法，就是CAS给base更新为base+x,也就是每次都新增x，
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在这里由于add(1L)传入的参数是1，也就是每次就是加一
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果CAS成功之后就不说了，就完成操作了，如果CAS失败，则进入到里面去&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; ((as = cells) != &lt;span&gt;null&lt;/span&gt; || !casBase(b = base, b +&lt;span&gt; x)) {
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; uncontended = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个if判断条件贼长，我们把这几个条件分为1，2，3，4部分，前三部分都是用于决定线程应该访问Cell数组中哪一个Cell元素，最后一个部分用于更新Cell的值
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果第1，2，3部分都不满足，也就是说Cell数组存在而且已经找到了确定的Cell元素，那就到第四部分，更新对应的Cell中的值（在Cell类中的cas方法已经看过了）
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果第1，2，3部分满足其中一个，那也就是说Cell数组根本就不存在或者线程找不到对应的Cell，就执行longAccumulate方法&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (as == &lt;span&gt;null&lt;/span&gt; || (m = as.length - 1) &amp;lt; 0 || (a = as[getProbe() &amp;amp; m]) == &lt;span&gt;null&lt;/span&gt; || !(uncontended = a.cas(v = a.value, v +&lt;span&gt; x)))
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;后面仔细看看这个方法，这是对Cell数组的初始化和扩容，很有意思&lt;/span&gt;
            longAccumulate(x, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;, uncontended);
    }
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;一个简单的CAS操作&lt;/span&gt;
&lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; casBase(&lt;span&gt;long&lt;/span&gt; cmp, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; val) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; UNSAFE.compareAndSwapLong(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, BASE, cmp, val);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　对于上面的，有兴趣的可以看看是怎么找到指定的Cell的，在上面的a = as[getProbe() &amp;amp; m]中，其中m=数组的长度-1，其实这里也是一个取余的运算，而getProbe()这个方法是用于获取当前线程的threadLocalRandomProb(当前本地线程探测值，初始值为0)，其实也就是一个随机数啊，然后对数组的长度取余得到的就是对应的数组的索引，首次调用这个方法是数组的第一个元素，如果数组的第一个元素为null，那么就说明没有找到对应的Cell；&lt;/p&gt;
&lt;p&gt;　　对于取余运算，举个简单的例子吧，我也有点忘记了，比如随机数9要对4进行取余，我们可以9&amp;amp;(4-1)=9&amp;amp;3=1001&amp;amp;0011=1，利用位运算取余了解一下；&lt;/p&gt;
&lt;p&gt;　　现在我们重点看看longAccumulate方法，代码比较长，单独提取出来看看&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;3.longAccumulate方法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;此方法是对Cell数组的初始化和扩容，注意有个形参LongBinaryOperator，这是JDK8新增的函数式编程的接口，函数签名为(T,T)-&amp;gt;T,这里传进来的是null&lt;/span&gt;
&lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; longAccumulate(&lt;span&gt;long&lt;/span&gt; x, LongBinaryOperator fn, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; wasUncontended) {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; h;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化当前线程的threadLocalRandomProbd的值，也就是生成一个随机数&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; ((h = getProbe()) == 0&lt;span&gt;) {
        ThreadLocalRandom.current(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; force initialization&lt;/span&gt;
        h =&lt;span&gt; getProbe();
        wasUncontended &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; collide = &lt;span&gt;false&lt;/span&gt;;                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; True if last slot nonempty&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
        Cell[] as; Cell a; &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; n; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; v;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里表示初始化完毕了&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; ((as = cells) != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; (n = as.length) &amp;gt; 0&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里表示随机数和数组大小取余，得到的结果就是&lt;span&gt;&lt;strong&gt;当前线程要匹配到的Cell元素的索引，如果索引对应在Cell数组中的元素为null，就新增一个Cell对象扔进去&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; ((a = as[(n - 1) &amp;amp; h]) == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;cellsBusy为0，表示当前Cell没有进行扩容、初始化操作或者正在创建Cell等操作，那么当前线程可以对这个Cell数组为所欲为&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (cellsBusy == 0) {       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Try to attach new Cell&lt;/span&gt;
                    Cell r = &lt;span&gt;new&lt;/span&gt; Cell(x);   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Optimistically create
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;看下面的Cell数组初始化，说的很清楚，主要是设置cellsBusy为1，然后将当前线程匹配到的Cell设置为新创建的Cell对象&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; (cellsBusy == 0 &amp;amp;&amp;amp;&lt;span&gt; casCellsBusy()) {
                        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; created = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt; {               &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Recheck under lock&lt;/span&gt;
                            Cell[] rs; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; m, j;
                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((rs = cells) != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt;
                                (m &lt;/span&gt;= rs.length) &amp;gt; 0 &amp;amp;&amp;amp;&lt;span&gt;
                                rs[j &lt;/span&gt;= (m - 1) &amp;amp; h] == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                                rs[j] &lt;/span&gt;=&lt;span&gt; r;
                                created &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                            }
                        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将cellsBusy重置为0，表示此时其他线程又可以对Cell数组为所欲为了&lt;/span&gt;
                            cellsBusy = 0&lt;span&gt;;
                        }
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (created)
                            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                        &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;;           &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Slot is now non-empty&lt;/span&gt;
&lt;span&gt;                    }
                }
                collide &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }


            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!wasUncontended)       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; CAS already known to fail&lt;/span&gt;
                wasUncontended = &lt;span&gt;true&lt;/span&gt;;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Continue after rehash

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Cell元素存在就执行CAS更新Cell中的值，这里fn是形参为null&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (a.cas(v = a.value, ((fn == &lt;span&gt;null&lt;/span&gt;) ? v +&lt;span&gt; x :
                                            fn.applyAsLong(v, x))))
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;



            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当Cell数组元素个数大于CPU的个数&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (n &amp;gt;= NCPU || cells !=&lt;span&gt; as)
                collide &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; At max size or stale
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否有冲突&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;collide)
                collide &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;扩容Cell数组&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;，和上面两个else if一起看
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果当前Cell数组元素没有达到CPU个数而且有冲突就新型扩容，扩容的数量是原来的两倍Cell[] rs = new Cell[n &amp;lt;&amp;lt; 1];，为什么要和CPU个数比较呢？
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;因为当Cell数组元素和CPU个数相同的时候，效率是最高的，因为每一个线程都是一个CPU来执行，再来修改其中其中一个Cell中的值
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里还是利用cellsBusy这个字段，在下面初始化Cell数组中的用法一样，就不多说了&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (cellsBusy == 0 &amp;amp;&amp;amp;&lt;span&gt; casCellsBusy()) {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里就是新建一个数组是原来的两倍，然后将原来数组的元素复制到新的数组，再改变原来的cells的引用指向新的数组&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; (cells == as) {      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Expand table unless stale&lt;/span&gt;
                        Cell[] rs = &lt;span&gt;new&lt;/span&gt; Cell[n &amp;lt;&amp;lt; 1&lt;span&gt;];
                        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; n; ++&lt;span&gt;i)
                            rs[i] &lt;/span&gt;=&lt;span&gt; as[i];
                        cells &lt;/span&gt;=&lt;span&gt; rs;
                    }
                } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用完就重置为0&lt;/span&gt;
                    cellsBusy = 0&lt;span&gt;;
                }
                collide &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;;                   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Retry with expanded table&lt;/span&gt;
&lt;span&gt;            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里的作用是当线程找了好久，发现所有Cell个数已经和CPU个数相同了，然后匹配到的Cell正在被其他线程使用
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;于是&lt;span&gt;&lt;strong&gt;为了找到一个空闲的Cell，于是要重新计算hash值&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;
            h =&lt;span&gt; advanceProbe(h);
        }



        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;初始化Cell数组
        &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;记得上面好像说过cellsBusy这个字段是能是0或者是1，当时0的时候，说明Cell数组没有初始化和扩容，也没有正在创建Cell元素，
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;反之则为1，而casCellsBusy()方法就是用CAS将cellsBusy的值从0修改为1，表示当前线程正在初始化Cell数组，其他线程就不能进行扩容操作了
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果一个线程在初始化这个Cell数组，其他线程在扩容的时候，看上面扩容，也会执行casCellsBusy()方法进行CAS操作，会失败，因为期望的值是1，而不是0&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (cellsBusy == 0 &amp;amp;&amp;amp; cells == as &amp;amp;&amp;amp;&lt;span&gt; casCellsBusy()) {
            &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; init = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt; {                           &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Initialize table&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (cells ==&lt;span&gt; as) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里首先新建一个容量为2的数组，然后用随机数h&amp;amp;1，也就是随机数对数组的容量取余的方式得到索引，然后初始化数组中每个Cell元素&lt;/span&gt;
                    Cell[] rs = &lt;span&gt;new&lt;/span&gt; Cell[2&lt;span&gt;];
                    rs[h &lt;/span&gt;&amp;amp; 1] = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Cell(x);
                    cells &lt;/span&gt;=&lt;span&gt; rs;
                    init &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                }
            } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化完成之后要把这个字段重置为0，表示此时其他线程就又可以对这个Cell进行扩容了&lt;/span&gt;
                cellsBusy = 0&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (init)
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }&lt;br/&gt;　　　　　&lt;span&gt;//将base更新为base+x，表示base会逐渐累加Cell数组中每一个Cell中的值
        &lt;/span&gt;&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (casBase(v = base, ((fn == &lt;span&gt;null&lt;/span&gt;) ? v +&lt;span&gt; x :
                                    fn.applyAsLong(v, x))))
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;;                          &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Fall back on using base&lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　其实longAccumulate方法就是表示多线程的时候对Cell数组的初始化，添加Cell元素还有扩容操作，还有就是当一个线程匹配到了Cell元素，发现其他线程正在使用就会重新计算随机数，然后继续匹配其他的Cell元素去了，没什么特别难的吧！别看这个方法很长，就是做这几个操作&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;六.总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　这一篇核心就是CAS，我们简单的说了一下原子操作类AtomicLong的自增，但是当线程很多的情况下，使用CAS有很大的缺点，就是同一时间是会有一个线程在执行，其他所有线程都在自旋，自旋会消耗性能，于是可以使用JDK提供的一个LongAdder类代替，这个类的作用就是将AtomicLong中的值优化为了一个base和一个Cell数组，多线程去竞争的时候，假设线程个数个CPU个数相同，那么此时每一个线程都有单独的一个CPU去运行，然后单独的匹配到Cell数组中的某个元素，如果没有匹配到那么会对这个Cell数组进行初始化操作；如果匹配到的Cell数组中的元素正在使用，那么久判断是否可以新建一个Cell丢数组里面去，如果数组已经满了，而且数组数量小于CPU个数，那么久进行扩容；扩容结束后，还是匹配到的Cell数组中的位置正在使用，那么就是冲突，就会重新计算，通过一个新的随机数和数组的取余，得到一个新的索引，再去访问该对应的Cell数组的位置。。。。&lt;/p&gt;
&lt;p&gt;　　仔细看看还是挺有意思的啊！&lt;/p&gt;
</description>
<pubDate>Wed, 29 Jan 2020 17:16:00 +0000</pubDate>
<dc:creator>java小新人</dc:creator>
<og:description>昨天简单的看了看Unsafe的使用，今天我们看看JUC中的原子类是怎么使用Unsafe的，以及分析一下其中的原理！ 一.简单使用AtomicLong 还记的上一篇博客中我们使用了volatile关键字</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wyq1995/p/12240777.html</dc:identifier>
</item>
<item>
<title>C++ lambda 分析 - 小胖西瓜</title>
<link>http://www.cnblogs.com/shuqin/p/12241954.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shuqin/p/12241954.html</guid>
<description>&lt;p&gt;构造闭包：能够捕获作用域中变量的匿名函数的对象，Lambda 表达式是纯右值表达式，其类型是独有的无名非联合非聚合类类型，被称为闭包类型（closure type），所以在声明的时候必须使用 &lt;code&gt;auto&lt;/code&gt; 来声明。&lt;/p&gt;
&lt;p&gt;在其它语言如lua中，闭包的格式相对更为简单，可以使用 lambda 表达式作用域的所有变量，并且返回闭包&lt;/p&gt;
&lt;pre class=&quot;lua&quot;&gt;
&lt;code&gt;local function add10(arg)
    local i = 10
    local ret = function()
        i = i - 1
        return i + arg
    end
    return ret
end

print( add10(1)() ) -- 10&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;C++ 中则显得复杂些，也提供了更多的功能来控制闭包函数的属性。&lt;/p&gt;
&lt;h2 id=&quot;lambda-和-stdfunction&quot;&gt;lambda 和 std::function&lt;/h2&gt;
&lt;p&gt;虽然 lambda 的使用和函数对象的调用方式有相似之处，&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;std::function&amp;lt;int(int, int)&amp;gt; add2 = [&amp;amp;](int a, int b) -&amp;gt; int {
    return a + b + val + f1.value;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但他们并不是同一种东西，lambda 的类型是不可知的（在编译期决定），使用 &lt;code&gt;sizeof&lt;/code&gt; 两者的大小也是不相同的，&lt;code&gt;std::function&lt;/code&gt; 是函数对象，通过消除类型再重载 &lt;code&gt;operator()&lt;/code&gt; 达到调用的效果，只要这个函数满足可以调用的条件，就可以使用&lt;code&gt;std::function&lt;/code&gt;保存起来，这也是上面例子的体现。&lt;/p&gt;
&lt;h2 id=&quot;语法-c-17&quot;&gt;语法 C++ 17&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;[ 捕获 ] ( 形参 ) 说明符(&lt;em&gt;可选&lt;/em&gt;) 异常说明 -&amp;gt; ret { 函数体 }
&lt;ul&gt;&lt;li&gt;全量声明&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;[ 捕获 ] ( 形参 ) -&amp;gt; ret { 函数体 }
&lt;ul&gt;&lt;li&gt;const lambda 声明，&lt;strong&gt;复制捕获&lt;/strong&gt; 的对象在 lambda 体内为 const&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;[ 捕获 ] ( 形参 ) { 函数体 }
&lt;ul&gt;&lt;li&gt;省略返回类型的声明，返回的类型从函数体的返回推导&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;[ 捕获 ] { 函数体 }
&lt;ul&gt;&lt;li&gt;无实参的函数&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;em&gt;说明符&lt;/em&gt; ：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;mutable&lt;/code&gt;, 允许 &lt;em&gt;函数体&lt;/em&gt; 修改各个复制捕获的形参&lt;/li&gt;
&lt;li&gt;&lt;code&gt;constexpr&lt;/code&gt; C++ 17, 显式指定函数调用符为 &lt;code&gt;constexpr&lt;/code&gt;，当函数体满足 &lt;code&gt;constexpr&lt;/code&gt;函数要求时，即使未显式指定，也会是 &lt;code&gt;constexpr&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;em&gt;异常说明&lt;/em&gt; ：提供 &lt;code&gt;throw&lt;/code&gt; 或者 &lt;code&gt;noexpect&lt;/code&gt; 字句&lt;/p&gt;
&lt;p&gt;使用如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;struct Foo {
    int value;
    Foo() : value(1) { std::cout &amp;lt;&amp;lt; &quot;Foo::Foo();\n&quot;; }
    Foo(const Foo &amp;amp;other) {
        value = other.value;
        std::cout &amp;lt;&amp;lt; &quot;Foo::Foo(const Foo &amp;amp;)\n&quot;;
    }
    ~Foo() {
        value = 0;
        std::cout &amp;lt;&amp;lt; &quot;Foo::~Foo();\n&quot;;
    }
};

int main() {
    int val = 7;
    Foo f1;
    auto add1 = [&amp;amp;](int a, int b) mutable noexcept-&amp;gt;int {
        return a + b + val + f1.value;
    };

    // 使用 std::function 包装
    std::function&amp;lt;int(int, int)&amp;gt; add2 = [&amp;amp;](int a, int b) -&amp;gt; int {
        f1.value = val;  // OK，引用捕获
        return a + b + val + f1.value;
    };
    auto add3 = [&amp;amp;](int a, int b) { return a + b + val + f1.value; };
    auto add4 = [=] {
        // f1.value = val; // 错误，复制捕获 的对象在 lambda 体内为 const
        return val + f1.value;
    };

    // 全 auto 也是可以，返回的这个 auto 不写也行
    auto add5 = [=](auto a, int b) -&amp;gt; auto { return a + b; };
}

// 输出：
Foo::Foo();
Foo::Foo(const Foo &amp;amp;)
Foo::~Foo();
Foo::~Foo();&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;lambda-捕获&quot;&gt;Lambda 捕获&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;（以引用隐式捕获被使用的自动变量）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;=&lt;/code&gt;（以复制隐式捕获被使用的自动变量）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当出现任一默认捕获符时，都能隐式捕获当前对象（&lt;em&gt;this）。当它被隐式捕获时，始终被以引用捕获，即使默认捕获符是 = 也是如此。~~当默认捕获符为 = 时，（&lt;/em&gt;this） 的隐式捕获被弃用。 (C++20 起)~~，见&lt;a href=&quot;https://www.cnblogs.com/shuqin/p/12241954.html#this&quot;&gt;this&lt;/a&gt;分析&lt;br/&gt;&lt;em&gt;捕获&lt;/em&gt; 中单独的捕获符的语法是&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;标识符
&lt;ul&gt;&lt;li&gt;简单以复制捕获&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;标识符 &lt;strong&gt;...&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;作为包展开的简单以复制捕获&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;标识符 初始化器
&lt;ul&gt;&lt;li&gt;带初始化器的以复制捕获&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&amp;amp;&lt;/strong&gt; 标识符
&lt;ul&gt;&lt;li&gt;简单以引用捕获&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&amp;amp;&lt;/strong&gt; 标识符 &lt;strong&gt;...&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;作为包展开的简单引用捕获&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&amp;amp;&lt;/strong&gt; 标识符 初始化器
&lt;ul&gt;&lt;li&gt;带初始化器的以引用捕获&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;this&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;当前对象的简单以引用捕获&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;*&lt;strong&gt;this&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;当前对象的简单以复制捕获, C++17&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;捕获列表可以不同的捕获方式，当默认捕获符是 &amp;amp; 时，后继的简单捕获符必须不以 &amp;amp; 开始, 当默认捕获符是 = 时，后继的简单捕获符必须以 &amp;amp; 开始，或者为 *this (C++17 起) 或 this (C++20 起).&lt;/p&gt;
&lt;p&gt;在上面的示例main中增加，部分代码如下，包括了两种捕获方式，及在函数体内修改lambda捕获变量的值，及返回对象&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;    Foo f1;
    Foo f2;
    int val = 7;
    auto add6 = [=, &amp;amp;f2](int a) mutable {
        f2.value *= a;
        f1.value += f2.value + val;
        return f1;
    };

    Foo f3 = add6(3);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;又到了喜闻乐见反汇编的情况了，看看编译器是怎么实现的lambda表达式的。&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;_ZZ4mainENUliE_clEi:
.LFB10:
    .cfi_startproc
    pushq   %rbp
    .cfi_def_cfa_offset 16
    .cfi_offset 6, -16
    movq    %rsp, %rbp
    .cfi_def_cfa_register 6
    subq    $32, %rsp
    movq    %rdi, -8(%rbp)
    movq    %rsi, -16(%rbp)
    movl    %edx, -20(%rbp)   // int a
    movq    -16(%rbp), %rax   // -16(%rbp) = &amp;amp; this(f2)，每次都这么赋值，没优化的指令真的很冗余
    movq    (%rax), %rax
    movl    (%rax), %edx      // %edx = f2.value
    movq    -16(%rbp), %rax
    movq    (%rax), %rax
    imull   -20(%rbp), %edx   // %edx = f2.value * a
    movl    %edx, (%rax)      // f2.value = %edx
    movq    -16(%rbp), %rax
    movl    8(%rax), %edx     // 在main函数中 -32(%rbp) + 8 = -24(%rbp) 也就是copy构造函数产生的 this 指针
    movq    -16(%rbp), %rax   // 以下的就是那些加减了，
    movq    (%rax), %rax
    movl    (%rax), %ecx
    movq    -16(%rbp), %rax
    movl    12(%rax), %eax
    addl    %ecx, %eax
    addl    %eax, %edx
    movq    -16(%rbp), %rax
    movl    %edx, 8(%rax)
    movq    -16(%rbp), %rax
    leaq    8(%rax), %rdx
    movq    -8(%rbp), %rax
    movq    %rdx, %rsi        // 上一个copy构造函数内的 this 指针
    movq    %rax, %rdi        // copy构造的this指针
    call    _ZN3FooC1ERKS_    // 继续调用copy构造函数，返回
    movq    -8(%rbp), %rax
    leave
    .cfi_def_cfa 7, 8
    ret
    .cfi_endproc

// lambda 的析构函数，这个函数是隐式声明的
_ZZ4mainENUliE_D2Ev:
.LFB12:
    .cfi_startproc
    pushq   %rbp
    .cfi_def_cfa_offset 16
    .cfi_offset 6, -16
    movq    %rsp, %rbp
    .cfi_def_cfa_register 6
    subq    $16, %rsp
    movq    %rdi, -8(%rbp)
    movq    -8(%rbp), %rax
    addq    $8, %rax
    movq    %rax, %rdi
    call    _ZN3FooD1Ev
    nop
    leave
    .cfi_def_cfa 7, 8
    ret
    .cfi_endproc

main:
.LFB9:
    .cfi_startproc
    pushq   %rbp
    .cfi_def_cfa_offset 16
    .cfi_offset 6, -16
    movq    %rsp, %rbp
    .cfi_def_cfa_register 6
    subq    $48, %rsp
    movl    $7, -4(%rbp)     // int val = 7;
    leaq    -8(%rbp), %rax   // -8(%rbp) = this(f1)
    movq    %rax, %rdi
    call    _ZN3FooC1Ev       // Foo f1;
    leaq    -12(%rbp), %rax   // -12(%rbp) = this(f2)
    movq    %rax, %rdi
    call    _ZN3FooC1Ev       // Foo f2;
    leaq    -12(%rbp), %rax
    movq    %rax, -32(%rbp)   // -32(%rbp) = this(f2)
    leaq    -8(%rbp), %rax    // 取 this(f1)
    leaq    -32(%rbp), %rdx
    addq    $8, %rdx          // copy 构造函数的 this = -24(%rbp)，记住这个 24
    movq    %rax, %rsi        // 第二个参数 this（f1）
    movq    %rdx, %rdi        // 第一个参数，调用copy构造函数的 this
    call    _ZN3FooC1ERKS_    // Foo(const Foo &amp;amp;);
    movl    -4(%rbp), %eax
    movl    %eax, -20(%rbp)   // -20(%rbp) = 7
    leaq    -36(%rbp), %rax
    leaq    -32(%rbp), %rcx
    movl    $3, %edx
    movq    %rcx, %rsi        // 第二个参数 this(f2) 的地址（两次 leaq）
    movq    %rax, %rdi        // 需要返回的 Foo 对象的 this 指针
    call    _ZZ4mainENUliE_clEi // lambda 的匿名函数
    leaq    -36(%rbp), %rax
    movq    %rax, %rdi
    call    _ZN3FooD1Ev
    leaq    -32(%rbp), %rax
    movq    %rax, %rdi
    call    _ZZ4mainENUliE_D1Ev // 析构函数
    leaq    -12(%rbp), %rax
    movq    %rax, %rdi
    call    _ZN3FooD1Ev
    leaq    -8(%rbp), %rax
    movq    %rax, %rdi
    call    _ZN3FooD1Ev
    movl    $0, %eax
    leave
    .cfi_def_cfa 7, 8
    ret
    .cfi_endproc&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的汇编代码相对cpp代码还是比较多的，由于一些隐含规则的约束下，编译器做了很多的工作，产生的代码的顺序就比较混乱&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;使用 &lt;code&gt;=&lt;/code&gt; 值捕获时，会先调用copy构造函数&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;&amp;amp;&lt;/code&gt; 引用捕获时，将捕获对象的引用（地址）作为隐式参数传给匿名函数&lt;/li&gt;
&lt;li&gt;编译器不仅会产生匿名函数，还会有一个析构函数产生，这个函数负责调用在匿名函数内的析构函数&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;生命周期&quot;&gt;生命周期&lt;/h2&gt;
&lt;p&gt;lambda表达式相关的对象的生命周期，见上反汇编：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;全局，更外层作用域的生命周期不受影响&lt;/li&gt;
&lt;li&gt;使用值捕获的情况，先于lambda表达式函数体构造对象，后于函数体执行完析构&lt;/li&gt;
&lt;li&gt;在lambda表达式函数体内的对象，在函数体执行时创建，在闭包析构函数内析构&lt;/li&gt;
&lt;li&gt;lambda 对象的生命周期为所在作用域结束，析构的顺序为声明的逆序析构&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;this&quot;&gt;&lt;span id=&quot;this&quot;&gt;this&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;使用 -std=c++14 生成的汇编代码在 &lt;code&gt;=&lt;/code&gt;，&lt;code&gt;&amp;amp;&lt;/code&gt;，&lt;code&gt;this&lt;/code&gt; 捕获的情况下，产生的汇编代码几乎一样，都是使用的引用（this地址）传参，使用 -std=c++2a 的情况下，编译器不推荐使用值捕获的方式（虽然还是使用的引用捕获）。&lt;/p&gt;
&lt;h2 id=&quot;todo&quot;&gt;TODO&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;补全对参数包的分析&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://zh.cppreference.com/w/cpp/language/lambda&quot;&gt;lambda 表达式&lt;/a&gt;，cppreference Lambda 表达式 (C++11 起)。&lt;/p&gt;
</description>
<pubDate>Wed, 29 Jan 2020 17:01:00 +0000</pubDate>
<dc:creator>小胖西瓜</dc:creator>
<og:description>lambda 表达式分析 构造闭包：能够捕获作用域中变量的匿名函数的对象，Lambda 表达式是纯右值表达式，其类型是独有的无名非联合非聚合类类型，被称为闭包类型（closure type），所以在声</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/shuqin/p/12241954.html</dc:identifier>
</item>
<item>
<title>c++  文件的简单操作 - 李显虎</title>
<link>http://www.cnblogs.com/lixianhu1998/p/12241890.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lixianhu1998/p/12241890.html</guid>
<description>&lt;h3 id=&quot;文件的读取操作&quot;&gt;文件的读取操作&lt;/h3&gt;
&lt;p&gt;在程序设计中，文件常用的操作不外乎——打开、读、写、流指针操作、关闭。我日常中使用的比较多，但从来 没有细细总结今天就总结下具体的用法。&lt;/p&gt;
&lt;h4 id=&quot;相关概念&quot;&gt;相关概念&lt;/h4&gt;
&lt;p&gt;计算机上的文件其实是数据的集合，对文件的读写其实是对数据的读写。&lt;br/&gt;文件可以大致分为两种：文本文件和二进制文件。　　&lt;br/&gt;1、文本文件：它的每一个字节存放的是一个ASCII码，代表一个字符。&lt;br/&gt;2、二进制文件：将内存中的数据按照其在内存中的存储形式原样存放在磁盘上。我们用记事本打开则是乱码。&lt;/p&gt;
&lt;h3 id=&quot;文件的路径&quot;&gt;文件的路径&lt;/h3&gt;
&lt;p&gt;文件的相对路径（重在理解）——英文的双引号&lt;br/&gt;定义：目标文件相对于当前文件的路径。&lt;br/&gt;表达形式：&lt;br/&gt;（1）&quot;./“或”.”表示显示当前目录，也可以省略，表示默认当前目录&lt;br/&gt;（2）”…/&quot;或”…”表示返回到上一级的目录。&lt;br/&gt;（3）如果有多个上一级目录，可以使用多个“…/”或”…”。&lt;/p&gt;
&lt;h3 id=&quot;文件的打开方式&quot;&gt;文件的打开方式&lt;/h3&gt;
&lt;p&gt;（三）文件的打开方式&lt;br/&gt;ios::in 以输入方式打开文件，支持读数据流。如果文件不存在会找不到文件。&lt;br/&gt;ios::out 以输出方式打开文件，支持写数据流。如果文件不存在则新建，如果文件存在就清空其原有内容。&lt;br/&gt;ios::app 输出的数据追加到文件末尾，只支持读，不支持写&lt;br/&gt;ios::ate 打开一个文件，并将指针定位到文件末尾&lt;br/&gt;ios::trunc 打开一个文件，如果文件不存在则新建，如果存在，则清空原有文件中的内容&lt;br/&gt;ios::binary 以二进制方式打开文件，如果不指定则默认采用文本方式打开文件&lt;br/&gt;说明：&lt;br/&gt;①缺省时，默认为以输出和输入方式打开文件，支持读和写数据流。&lt;br/&gt;②当以多种形式打开文件时，中间用运算符”|”（或）连接起来。如：&lt;br/&gt;ios::in | ios::out 以输出和输入方式打开文件&lt;br/&gt;ios::out| ios::binary 以输出方式打开一个二进制文件&lt;/p&gt;
&lt;h3 id=&quot;数据流对象指针简称流指针&quot;&gt;数据流对象指针（简称“流指针”）&lt;/h3&gt;
&lt;p&gt;对文件进行读写操作首先必须要定义一个数据流对象指针。数据流对象指针有三种类型，在这里我只介绍一种我最常用的方式：&lt;code&gt;fstream&lt;/code&gt;（头文件&lt;code&gt;#include&amp;lt;fstream&amp;gt;&lt;/code&gt;）&lt;br/&gt;表示文件读取/写入流，对文件进行读和写操作，既可以将数据从存储设备读取到内存中，也可以将数据从内存写入存储设备中。&lt;br/&gt;下面代码实例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;fstream  f1(&quot;F:\\DAAT.txt&quot;,ios::in | ios::out|ios::trunc);//定义一个名为f1的数据流指针，并且以in/out/trunc方式打开文件，支持读和写操作。
    if(!f1)cout&amp;lt;&amp;lt;&quot;未找到文件&quot;&amp;lt;&amp;lt;endl;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;获取流指针的位置&quot;&gt;获取流指针的位置&lt;/h3&gt;
&lt;p&gt;（1）tellg( )&lt;br/&gt;根据ANSI-C++ 标准，就是一个整数，代表当前读取流指针的位置；&lt;br/&gt;&lt;code&gt;long long m=f1.tellg( );//返回f1的位置&lt;/code&gt;&lt;br/&gt;*设置读取流指针的位置&lt;br/&gt;&lt;code&gt;①seekg ( pos_type position );&lt;/code&gt;&lt;br/&gt;（2）tellp( )&lt;br/&gt;根据ANSI-C++ 标准，就是一个整数，代表当前写入流指针的位置；&lt;br/&gt;&lt;code&gt;long long m=f2.tellp( );//返回f2的位置&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;*设置写入流指针的位置&lt;br/&gt;&lt;code&gt;①seekp ( pos_type position );&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;文件的打开与关闭操作&quot;&gt;文件的打开与关闭操作&lt;/h3&gt;
&lt;p&gt;*文件的open函数的具体使用：eg&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;         fstream f1,f2;//定义一个名为f1的数据流指针
         f1.open(&quot;D:\\a.txt&quot;); //以读和写方式打开D盘中的a.txt文件,与f1(&quot;F:\\DAAT.txt&quot;,ios::in | ios::out|ios::trunc);这种方式结果一致。
         F2.open(“../a.txt”.ios::in);//以读方式打开当前目录的上级目录中的a.txt文件&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;*文件的关闭&lt;br/&gt;文件的关闭非常重要，每次使用后必须关闭，不然会造成其他后果。&lt;br/&gt;&lt;code&gt;f1。close（）；&lt;/code&gt;即可&lt;/p&gt;
&lt;h3 id=&quot;文本文件的写操作符号&quot;&gt;文本文件的写操作——符号”&amp;lt;&amp;lt;”&lt;/h3&gt;
&lt;p&gt;①定义一个数据指针流；（注：根据写操作选择对应的数据指针流类型）&lt;br/&gt;②表达形式：数据指针流 &amp;lt;&amp;lt; 被写入的对象;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;char  b[]=&quot;李虎ftv句柄饱和度iyivbh oguobhnynbubo8ubu0nn  88898 76y8 9980 bhh&quot;;
    int i=0;
    fstream  f1(&quot;F:\\DAAT.txt&quot;,ios::in | ios::out|ios::trunc);//定义一个名为f1的数据流指针
    if(!f1)cout&amp;lt;&amp;lt;&quot;未找到文件&quot;&amp;lt;&amp;lt;endl;
    f1.seekg(ios::beg);  //重置数据流指针
    for (i=0;i&amp;lt;strlen(b);i++)
    {
        f1&amp;lt;&amp;lt;b[i];//依次将数组里面的东西写入文件中。

    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;文本文件的读操作符号&quot;&gt;文本文件的读操作——符号”&amp;gt;&amp;gt;”&lt;/h3&gt;
&lt;p&gt;①定义一个数据指针流；（注：根据读操作选择对应的数据指针流类型）&lt;br/&gt;②表达形式：数据指针流 &amp;gt;&amp;gt; 读取后存储的对象;&lt;br/&gt;注意：读取数据时按照文件中数据的格式读取。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;法一：
nt  b[10];
fstream f2;//定义一个名为f2的数据流指针
    f2.open(&quot;D:\\a.txt&quot;); //以读和写方式打开D盘中的a.txt文件
for (int i = 0; i &amp;lt; 10; i++) {
        f1 &amp;gt;&amp;gt; b[i] ;  //读取时会根据文件中的格式读取。
    }
f2.close();//关闭文件
//法二：
//char  b[]
    //f1.open(&quot;D:\\DAAT.txt&quot;); //以读和写方式打开D盘中的a.txt文件
    //if(!f1)cout&amp;lt;&amp;lt;&quot;未找到文件&quot;&amp;lt;&amp;lt;endl;
    //f1.seekg(ios::beg);  //重置数据流指针
    //f1.getline(b,80,EOF);eof()函数是判断文件是否读到了末尾。
    //cout&amp;lt;&amp;lt;b&amp;lt;&amp;lt;endl;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;二进制文件的读和写操作&quot;&gt;二进制文件的读和写操作&lt;/h3&gt;
&lt;p&gt;此处我没有整理，大家可以参考他的这篇文章，写的很详细：&lt;a href=&quot;https://blog.csdn.net/weixin_43956598/article/details/90694117&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/weixin_43956598/article/details/90694117&lt;/a&gt;；&lt;/p&gt;
&lt;h3 id=&quot;文件的其他函数操作&quot;&gt;文件的其他函数操作&lt;/h3&gt;
&lt;p&gt;Is_open( ) 判断文件是否处于打开的状态。如果是，返回true；如果不是，返回false&lt;/p&gt;
&lt;p&gt;eof() 判断读文件是否到达文件末尾。如果是，返回true；如果不是，返回false&lt;/p&gt;
&lt;p&gt;bad() 如果在读写过程中出错，返回 true 。例如：当我们要对一个不是打开为写状态的文件进行写入时，或者我们要写入的设备没有剩余空间时，就会报错。&lt;/p&gt;
&lt;p&gt;fail() 除了与bad() 同样的情况下会返回 true 以外，加上格式错误时也返回true ，例如当想要读入一个整数，而获得了一个字母的时候。&lt;/p&gt;
&lt;p&gt;good() 这是最通用的：如果调用以上任何一个函数返回true 的话，函数返回 false 。&lt;/p&gt;
&lt;p&gt;clear() 重置以上成员函数所检查的状态标志。&lt;/p&gt;
</description>
<pubDate>Wed, 29 Jan 2020 15:59:00 +0000</pubDate>
<dc:creator>李显虎</dc:creator>
<og:description>文件的读取操作 在程序设计中，文件常用的操作不外乎——打开、读、写、流指针操作、关闭。我日常中使用的比较多，但从来 没有细细总结今天就总结下具体的用法。 相关概念 计算机上的文件其实是数据的集合，对文</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lixianhu1998/p/12241890.html</dc:identifier>
</item>
<item>
<title>【Java并发基础】Java线程的生命周期 - sakuraxx</title>
<link>http://www.cnblogs.com/myworld7/p/12241842.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/myworld7/p/12241842.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;线程是操作系统中的一个概念，支持多线程的语言都是对OS中的线程进行了封装。要学好线程，就要搞清除它的生命周期，也就是生命周期各个节点的状态转换机制。不同的开发语言对操作系统中的线程进行了不同的封装，但是对于线程的声明周期这部分基本是相同的。下面先介绍通用的线程生命周期模型，然后详细介绍Java中的线程生命周期以及Java生命周期中各个状态是如何转换的。&lt;/p&gt;
&lt;h2 id=&quot;通用的线程生命周期&quot;&gt;通用的线程生命周期&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1099419/202001/1099419-20200129232850397-95979079.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图为通用线程状态转换图（五态模型）。&lt;/p&gt;
&lt;ol readability=&quot;5.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;初始状态&lt;/p&gt;
&lt;p&gt;线程被创建，但是还不允许分配CPU执行。这里的创建&lt;strong&gt;仅仅是指在编程语言层面被创建&lt;/strong&gt;；在OS层面还没有被创建。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;可运行状态&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;线程可以分配CPU执行&lt;/strong&gt;。在这种状态下，真正的OS线程已经被成功创建，所以可以分配CPU执行。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;运行状态&lt;/p&gt;
&lt;p&gt;当有&lt;strong&gt;空闲的CPU&lt;/strong&gt;时，OS就会将空闲CPU&lt;strong&gt;分配给一个处于可运行状态的线程&lt;/strong&gt;，被分配到CPU的线程的状态就转换成了运行状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;休眠状态&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;运行状态的线程如果调用一个阻塞的API&lt;/strong&gt;（例如以阻塞方式读文件）或者&lt;strong&gt;等待某个事件&lt;/strong&gt;（例如条件变量），那么线程的状态就会&lt;strong&gt;转到休眠状态&lt;/strong&gt;，此时会&lt;strong&gt;释放CPU使用权&lt;/strong&gt;，休眠状态的线程永远没有机会获得CPU的使用权。当等待的事件出现了（线程被唤醒），线程就会从休眠状态转到可运行状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;终止状态&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;程序执行完成&lt;/strong&gt;或者&lt;strong&gt;出现异常&lt;/strong&gt;就会进入此状态。终止状态的线程不会切换到其他任何状态，进入终止状态也就意味着线程的生命周期结束了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;以上五种状态在不同的编程语言中会&lt;strong&gt;简化合并&lt;/strong&gt;（C中POSIX Thread规范将初始状态和可运行状态合并）或者&lt;strong&gt;细化&lt;/strong&gt;（Java中细化了休眠状态）。Java中将可运行状态和运行状态合并了，Java虚拟机不关心这两个状态，把线程的调度交给了操作系统。&lt;/p&gt;
&lt;h2 id=&quot;java线程的生命周期&quot;&gt;Java线程的生命周期&lt;/h2&gt;
&lt;p&gt;Java语言的线程共有六种状态：&lt;code&gt;New&lt;/code&gt;（初始化状态）、&lt;code&gt;RUNNABLE&lt;/code&gt;（可运行状态/运行状态）、&lt;code&gt;BLOCKED&lt;/code&gt;（阻塞状态）、&lt;code&gt;WAITING&lt;/code&gt;（无时限等待）、&lt;code&gt;TIMED_WAITING&lt;/code&gt;（有时限等待）、&lt;code&gt;TERMINATED&lt;/code&gt;（终止状态）。&lt;/p&gt;
&lt;p&gt;在操作系统层面，Java线程中的 BLOCKED、 WAITING 、TIMED_WAITING都是休眠状态。只要Java处于这三种状态之一，那么这个线程就永远没有CPU使用权。&lt;/p&gt;
&lt;p&gt;下面是Java线程的状态转换图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1099419/202001/1099419-20200129232820585-1854094518.png&quot; alt=&quot;image-20200129221515225&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这六种状态之间的转换，&lt;strong&gt;注意箭头的方向，哪些状态是可以互转的哪些是不可以互转&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;runnable-blocked&quot;&gt;RUNNABLE ——&amp;gt; BLOCKED&lt;/h3&gt;
&lt;p&gt;只有一种场景会触发这种转换，即&lt;strong&gt;线程等待synchronized内置锁&lt;/strong&gt;。synchronized关键修饰的方法、代码块同一时刻只允许一个线程执行，其他未能执行的线程则等待。这种情况下，等待的线程就会从RUNNABLE转换到 BLOCKED状态。当等待的线程获得内置锁时，就会从BLOCKED转换到RUNNABLE状态。&lt;/p&gt;
&lt;p&gt;线程调用阻塞式API时，在操作系统层面线程是会转到休眠状态，但是在Java虚拟机层面，Java线程的状态是不会发生变化的，会保持RUNNABLE状态。Java虚拟机层面并不关心操作系统相关调度状态，在它眼里，等待CPU使用权（OS层面处于可执行状态）和等待I/O（OS层面处于休眠状态）没有区别，都是在等待某个资源，所以都归入了RUNNABLE状态。&lt;br/&gt;所以，&lt;span&gt;平时说Java在调用阻塞式API时，线程会阻塞，指的是操作系统线程的状态，并不是Java线程的状态&lt;/span&gt;。&lt;/p&gt;
&lt;h3 id=&quot;runnable-waiting&quot;&gt;RUNNABLE ——&amp;gt; WAITING&lt;/h3&gt;
&lt;p&gt;有三种场景会触发这种转换：&lt;/p&gt;
&lt;ol readability=&quot;6&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;获取synchronized内置锁的线程，调用无参数的&lt;code&gt;Object.wait()&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;当前线程调用&lt;code&gt;wait()&lt;/code&gt;方法会将自己阻塞，状态就从从RUNNABLE转到WAITING状态。使用同一内置锁的其他线程可调用&lt;code&gt;notifyAll()&lt;/code&gt;唤醒阻塞在该锁上的所有线程，此时被阻塞的线程状态就会从WAITING转到RUNNABLE状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;调用&lt;code&gt;Thread.join()&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;一个线程对象thread A，当调用&lt;code&gt;A.join()&lt;/code&gt;的时候，执行这条语句的线程会等待thread A执行完，而等待的这个线程，其状态就会就会从RUNNABLE转到WAITING状态。当thread A执行完，原来的这个等待线程就会从WAITING状态转到RUNNABLE状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;调用&lt;code&gt;LockSupport.park()&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;Java并发包中的锁都是基于&lt;code&gt;LockSupport&lt;/code&gt;对象实现的。调用&lt;code&gt;LockSupport.park()&lt;/code&gt;的当前线程会被阻塞，线程的状态会从RUNNABLE转到WAITING状态。调用&lt;code&gt;LockSupport.unpark(Thread t)&lt;/code&gt;可唤醒被阻塞的目标线程，目标线程的状态就会从WAITING转到RUNNABLE状态。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;runnable-timed_waiting&quot;&gt;RUNNABLE ——&amp;gt; TIMED_WAITING&lt;/h3&gt;
&lt;p&gt;以下场景将会触发这个状态转变：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;调用带超时参数的&lt;code&gt;Thread.sleep(long millis)&lt;/code&gt;方法。&lt;/li&gt;
&lt;li&gt;获得 synchronized 内置锁的线程，调用带超时参数的 &lt;code&gt;Object.wait(long timeout)&lt;/code&gt;方法；&lt;/li&gt;
&lt;li&gt;调用带超时参数的 &lt;code&gt;Thread.join(long millis)&lt;/code&gt;方法；&lt;/li&gt;
&lt;li&gt;调用带超时参数的 &lt;code&gt;LockSupport.parkNanos(Object blocker, long deadline)&lt;/code&gt;方法；&lt;/li&gt;
&lt;li&gt;调用带超时参数的 &lt;code&gt;LockSupport.parkUntil(long deadline)&lt;/code&gt; 方法。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;较与WAITING状态触发条件多了超时参数。&lt;/p&gt;
&lt;h3 id=&quot;new-runnale创建线程的两种方式&quot;&gt;NEW ——&amp;gt; RUNNALE，创建线程的两种方式&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Java刚创建出来的Thread对象就是NEW状态&lt;/strong&gt;，而创建Thread对象主要有两种方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一种是继承Thread对象，重写run()方法。&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 自定义线程类
class MyThread extends Thread {
    @Override  
    public void run() {
        // 线程需要执行的代码
        ......
    }
}
// 创建线程对象
MyThread myThread = new MyThread();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;二是实现Runnable接口，重写run()方法，并将该实现类作为Thread对象的参数&lt;/strong&gt;。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 实现 Runnable 接口
class Runner implements Runnable {
    @Override
    public void run() {
        // 线程需要执行的代码
        ......
    }
}
// 创建线程对象
Thread thread = new Thread(new Runner());&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;NEW状态的线程是不会被操作系统调度的&lt;/strong&gt;，因此不会执行。&lt;strong&gt;Java线程要执行，就必须转换到RUNNABLE状态&lt;/strong&gt;。那么如何转到RUNNABLE状态呢？那就需要线程启动，即调用线程的&lt;code&gt;start()&lt;/code&gt;方法。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;MyThread myThread = new MyThread();
// 从 NEW 状态转换到 RUNNABLE 状态
myThread.start()；&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;runnable-terminated&quot;&gt;RUNNABLE——&amp;gt; TERMINATED&lt;/h3&gt;
&lt;p&gt;线程执行完 &lt;code&gt;run()&lt;/code&gt;方法后，会自动转换到 TERMINATED 状态。&lt;br/&gt;如果执行 run() 方法的时候异常抛出，也会导致线程终止。有时候我们需要强制中断 run() 方法的执行，可以发现Java 的 Thread 类里面倒是有个 &lt;code&gt;stop()&lt;/code&gt;方法，但是该方法被标记为 &lt;code&gt;@Deprecated&lt;/code&gt;，已经被弃用了。所以，正确的方式是调用 &lt;code&gt;interrupt()&lt;/code&gt; 方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;stop()方法和interrupt()方法的主要区别：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;stop()方法会直接杀死线程。如果线程持有 ReentrantLock 锁，被 stop() 的线程并不会自动调用 ReentrantLock 的 unlock() 去释放锁，那其他线程将再也没机会获得 ReentrantLock 锁。这将会导致非常糟糕的结果。所以该方法已经被废弃。&lt;/p&gt;
&lt;p&gt;而 interrupt() 方法就比较温柔，interrupt() 方法仅仅是通知线程，线程有机会执行一些后续操作，同时也可以无视这个通知。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;线程是如何收到interrupt通知呢？有两种方式，一种是异常，一种是主动检测。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;异常获取通知&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;当线程 A 处于 WAITING、TIMED_WAITING 状态时，如果其他线程调用线程 A 的 interrupt() 方法，会使线程 A 返回到 RUNNABLE 状态，同时线程 A 的代码会触发 &lt;code&gt;InterruptedException&lt;/code&gt;异常。&lt;br/&gt;上面介绍状态转换时， WAITING、TIMED_WAITING 状态的触发条件，都是调用了 wait()、join()、sleep() 这样的方法。 我们看这些方法的签名，会发现它们都会throws InterruptedException 这个异常。这个异常的触发条件就是：其他线程调用了该线程的 interrupt() 方法。&lt;/p&gt;
&lt;p&gt;当线程 A 处于 RUNNABLE 状态时，并且阻塞在&lt;code&gt;java.nio.channels.InterruptibleChannel&lt;/code&gt;上时，如果其他线程调用线程 A 的 interrupt() 方法，线程 A 会触发 &lt;code&gt;java.nio.channels.ClosedByInterruptException&lt;/code&gt; 这个异常；而阻塞在 &lt;code&gt;java.nio.channels.Selector&lt;/code&gt;上时，如果其他线程调用线程 A 的 interrupt() 方法，线程 A 的 &lt;code&gt;java.nio.channels.Selector&lt;/code&gt;会立即返回。（这种方式我还没有使用过暂时还不太明白，先写将这种触发方式写在这里）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主动检测获取通知&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果线程处于 RUNNABLE 状态，并且没有阻塞在某个 I/O 操作上，这时就得依赖线程 A 主动检测中断状态。如果其他线程调用线程 A 的 interrupt() 方法，那么线程 A 可以通过 isInterrupted() 方法，检测是不是自己被中断了。&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;线程的生命周期以及各个状态的转换要好好掌握，这对于调试bug还是很有用的。&lt;/p&gt;
&lt;p&gt;参考：&lt;br/&gt;[1]极客时间专栏王宝令《Java并发编程实战》&lt;/p&gt;
</description>
<pubDate>Wed, 29 Jan 2020 15:30:00 +0000</pubDate>
<dc:creator>sakuraxx</dc:creator>
<og:description>前言 线程是操作系统中的一个概念，支持多线程的语言都是对OS中的线程进行了封装。要学好线程，就要搞清除它的生命周期，也就是生命周期各个节点的状态转换机制。不同的开发语言对操作系统中的线程进行了不同的封</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/myworld7/p/12241842.html</dc:identifier>
</item>
<item>
<title>Linux系统搭建私有CA证书服务器 - qiuhom</title>
<link>http://www.cnblogs.com/qiuhom-1874/p/12237944.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qiuhom-1874/p/12237944.html</guid>
<description>&lt;p&gt;一、CA简介&lt;/p&gt;
&lt;p&gt;　　CA是什么？CA是Certificate Authority的简写，从字面意思翻译过来是凭证管理中心，认证授权。它有点类似我们生活中的身份证颁发机构，这里的CA就相当于生活中颁发身份证的机构。不同于生活中的颁发机构，这里的CA是给服务器颁发证书。颁发证书的目的同生活中的办理身份证的目的类似，都是为了证明一件事，生活中的身份证可以证明我们是一个合法的公民，而服务器颁发证书的目的也是证明我们服务是一个合法的服务器，换句话说就是有了证书我们就可以清楚知道我们访问的服务器到底是不是我们真正想访问的服务器。从而识别我们访问的服务器的真假。&lt;/p&gt;
&lt;p&gt;二、中间人攻击原理&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1503305/202001/1503305-20200129163335099-1355038842.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　如上图所示，我们在和对方服务器通信的过程，存在着中间人攻击的情况。所谓中间人攻击，就是攻击者站在通讯双方的中间，对于客户端它充当着服务器的角色，对于服务器端它又充当着客户端的角色。简单说它就是两边欺骗。当我们向服务器发起通信请求时，中间人会截获我们发向服务器端的报文，从而进行修改，然后把修改后的报文发送给服务端，服务端收到中间人篡改的数据报文，进行响应，把响应报文发送给中间人，然后中间人再发给客户端。这样一个过程就是中间人攻击的过程。可以看到客户端服务端双方直接通信是不安全的。如上图所示，通信双方交换密钥，直接交换就存在中间人欺骗，因为我们不能够确定远端服务器的真伪和客户端的真伪。为了解决这一问题，由此衍生出CA。CA在这里的充当的角色相当于中间人角色，不同的是CA是一个权威的中间人。它可以证明客户端和服务端的真伪。&lt;/p&gt;
&lt;p&gt;三、加密解密以及获取公钥过程&lt;/p&gt;
&lt;p&gt;　　众所周知常用的加密方式有三种，单向加密，对称加密，和非对称加密。单向加密从字面意思理解就是一方加密，在加密过程中不使用密钥，我们把单向加密也叫不可逆加密，通常用于验证文件的真假，或者验证文件是否改动，从而验证文件的完整性。常用的单向加密算法有md5,sha。对称加密讲的是加密和解密用的同一密钥。换句话说对称加密只有一个密钥，只要拿到对应的密钥就可以解密。常用的对称加密有des。非对称加密讲的是公钥加密私钥解密，私钥加密公钥解密，且公钥和私钥是一对，加密解密都需要的是一对密钥里的任意一个。这种加密比前两种更加安全和适用，缺点是加解密大文件速度慢。&lt;/p&gt;
&lt;p&gt;　　了解了非对称加密的特性，我们再来说说它的过程。通信双方要进行非对称加密通信，前提是需要拿到对方的公钥，私钥放在各自手里，各自的公钥则存放在对方的手上。换句话讲，客户端需要拿到服务端的公钥，才能和服务端通信，服务端需要拿到客户端的公钥，才能主动和客户端通信。从而才可以实现非对称加密通信。那么客户端怎么得到服务端的公钥呢？如果客户端直接向服务端发送公钥，上面我们说过，这种方式存在中间人攻击，因为直接交换公钥是不都能确定对方身份的。这个时候就需要说说CA证书的作用了。&lt;/p&gt;
&lt;p&gt;　　证书里面存放了申请证书机构服务器的公钥和CA的信息以及有效期。通讯双方在建立加密通信的时候，需要验证证书的合法性，从而实现验证身份的目的。通常情况我们要验证证书的合法性就需要证书颁发机构的公钥来对证书解密，因为证书在颁发的时候，里面的公钥是通过颁发机构的私钥对其进行加密的。只要我们能够用颁发机构的公钥解开证书，那么就说明这个证书就是一个合法的证书，至少它证明了这个证书是权威机构（我们信任的）CA颁发的。同理通信双方要进行加密通信也是通过证书来获取密钥的。具体过程是这样的，客户端向服务端发起通信请求，服务端发送证书给客户端，客户端拿到证书进行解密，如果能够用信任CA机构的公钥解开，说明服务器发送过来的证书没有问题，然后把服务端公钥给存起来。客户端有了服务端的公钥后就可以向服务端发送用服务端的公钥加密的数据了，但是服务端没有客户端的公钥，它不能够用自己的私钥来加密数据发送给客户端，因为它的公钥是公开的，不光客户端上有服务端的公钥，中间人也有。所以为了确保数据的安全，客户端需要随机生成一个密码，然后通过服务器的公钥，把随机生成的密码加密后发送给服务端，服务端收到客户端发来的加密数据后，用自己的私钥解开，从而拿到客户端发来的随机密码，有了这个随机密码后，服务端就拿这个随机密码对称加密数据，然后发送给客户端。客户端收到服务端发送过来的加密报文，用刚才发送给服务端的随机密码解密，从而得到真正的数据。后续双方就是通过这个随机密码来加密解密传输数据。这里还需要说明的是，这个随机密码不是一直不变的，每隔一段时间后，客户端和服务端就会协商，重复上面的过程，生成新的随机密码进行加密解密通信。&lt;/p&gt;
&lt;p&gt;　　从上面的通信过程我们可以知道，证书的作用就是为了验证其服务器的真实合法性，以及传输服务端的公钥的作用。而服务器的公钥就是用来客户端向服务端发送随机密码，用来加密随机密码的作用，从而实现，只有服务端可以拿到这个随机密码的作用，实现安全加密通信。&lt;/p&gt;
&lt;p&gt;四、CA服务器的实现&lt;/p&gt;
&lt;p&gt;　　1、安装openssl软件&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]# yum install openssl -y
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：通常情况下openssl是系统默认安装的有，如果没有需要安装。&lt;/p&gt;
&lt;p&gt;　　2、查看配置文件，以及匹配策略&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
 36 [ ca ]
 37 default_ca  = CA_default        # The default ca section
 38 
 39 ####################################################################
 40 [ CA_default ]
 41 
 42 dir     = /etc/pki/CA       # Where everything is kept
 43 certs       = $dir/certs        # Where the issued certs are kept
 44 crl_dir     = $dir/crl      # Where the issued crl are kept
 45 database    = $dir/index.txt    # database index file.
 46 #unique_subject = no            # Set to 'no' to allow creation of
 47                     # several ctificates with same subject.
 48 new_certs_dir   = $dir/newcerts     # default place for new certs.
 49 
 50 certificate = $dir/cacert.pem   # The CA certificate
 51 serial      = $dir/serial       # The current serial number
 52 crlnumber   = $dir/crlnumber    # the current crl number
 53                     # must be commented out to leave a V1 CRL
 54 crl     = $dir/crl.pem      # The current CRL
 55 private_key = $dir/private/cakey.pem# The private key
 56 RANDFILE    = $dir/private/.rand    # private random number file
 57 
 58 x509_extensions = usr_cert      # The extentions to add to the cert
 59 
 60 # Comment out the following two lines for the &quot;traditional&quot;
 61 # (and highly broken) format.
 62 name_opt    = ca_default        # Subject Name options
 63 cert_opt    = ca_default        # Certificate field options
 64 
 65 # Extension copying option: use with caution.
 66 # copy_extensions = copy
 67 
 68 # Extensions to add to a CRL. Note: Netscape communicator chokes on V2 CRLs
 69 # so this is commented out by default to leave a V1 CRL.
 70 # crlnumber must also be commented out to leave a V1 CRL.
 71 # crl_extensions    = crl_ext
 72 
 73 default_days    = 365           # how long to certify for
 74 default_crl_days= 30            # how long before next CRL
75 default_md  = sha256        # use SHA-256 by default
 76 preserve    = no            # keep passed DN ordering
 77 
 78 # A few difference way of specifying how similar the request should look
 79 # For type CA, the listed attributes must be the same, and the optional
 80 # and supplied fields are just that :-)
 81 policy      = policy_match
 82 
 83 # For the CA policy
 84 [ policy_match ]
 85 countryName     = match
 86 stateOrProvinceName = match
 87 organizationName    = match
 88 organizationalUnitName  = optional
 89 commonName      = supplied
 90 emailAddress        = optional
 91 
 92 # For the 'anything' policy
 93 # At this point in time, you must list all acceptable 'object'
 94 # types.
 95 [ policy_anything ]
 96 countryName     = optional
 97 stateOrProvinceName = optional
 98 localityName        = optional
 99 organizationName    = optional
100 organizationalUnitName  = optional
101 commonName      = supplied
102 emailAddress        = optional
103 
104 ####################################################################
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：可看到openssl默认配置里面指定了证书存放相关文件的路径，和CA默认匹配策略，其中国家名称、省州名称、组织名称是必须同CA设置的信息一致，当然这些匹配是否和CA设置的一样，是通过配置文件来判断的可自行设置。通用名称是必须要填写的，其他都是可选。&lt;/p&gt;
&lt;p&gt;　　3、创建CA自签名证书&lt;/p&gt;
&lt;p&gt;　　　　3.1、生成私钥&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]# cd /etc/pki/CA/
[root@test CA]# tree
.
├── certs
├── crl
├── newcerts
└── private

4 directories, 0 files
[root@test CA]# (umask 077;openssl genrsa -out /etc/pki/CA/private/cakey.pem 2048)
Generating RSA private key, 2048 bit long modulus
..............................+++
............+++
e is 65537 (0x10001)
[root@test CA]# tree
.
├── certs
├── crl
├── newcerts
└── private
    └── cakey.pem

4 directories, 1 file
[root@test CA]# cat private/cakey.pem 
-----BEGIN RSA PRIVATE KEY-----
MIIEogIBAAKCAQEAmM8gDY90zksYI2myhqsGgMBGAPnlLbIBwiqYnte2PJZRnEJv
aYRzCgw9wSca9oI5rUGu1wLOk8NlAkE6W4hXu6JaAp/eMZcqzYVU2a6VhxPQLBP3
5dvfZT4vps737OR+l8gcJRX2VPcfJuMU+r4KbBT4F3gP79hz/JxwK0yShlIGCnPP
cCK5xS6jKBH3ezdLsRy0ZCRUwX+ivlAJ8zJ/bV4m2OesiDW1LFPrvotRo+aBwexI
1vk01Yww1x/DUnxiYCrOPS0V3wWpSS6r2qXVv0FyZGS1ZP/+Jf1ZfbvL2w9kcmlQ
0wadHkx3M4HJyvWinOEpMsrTr3p9RK67oNs48QIDAQABAoIBADUWQBx16i6BCDHF
VrBSWkAAjFFqf6QQY2wBQGRurHEAB/oxWmNeEFk9R3cDDur08vSuDP/Fid7r0vul
jZCfHVuiW4Lt51NzIPulhoTZkjkLORcXGNhSOpoBsKxS2u8BsrkoXB7GMn3yHHB2
E6PIwfYqksYUf/TjTehEsPNZ9s2Sx/ioscHfnIRd7Uct0Gu5mI5C6qP/7BhEyNRb
bnFGGB0dSFDtFPqGUIfTeWApJUH1/vUTUXrrZLH4FEubMuf4k0ZIV3cGyvdZVVQ+
iyoWTTetPOhFbRMnKtqgJ+yVhck7uEAgIB/JrMI3x768JoJpyAgxGlZFmxS86mdr
TzDzZcECgYEAxwv/Jcrb3E5gGC77qSEWlq+IVomAgHRVU4M81byw6YV7wAssW10t
X8pm84H3G8yJMuxGYdHdXpl9PzxwXaS7Qh82uZVQbGALiWyhHloEIoI+oH9pGtXf
uWqQKmrYURtq8AoULhALn03zCjJINGfY9/WlYX6qi32UpnKg6snmDD8CgYEAxIhA
u+By9YazW/YVgEHoh5UmWL0yfX8rBEn1fRwwhjfhQtfs50zoL83SVKpKY8VtfR/r
/YcIaWx8+R5g+g/aAYDeKHO1x+uW2yqWMdXjdkY/kzoM0G7gPvSC7F3vr6dWuHUC
6v4839EElIKHyCK0NMumnPvoUUDrbP1YlJ1cLs8CgYBsGU/QLoOI+eemOp3iFF44
J8xbcwGewY81c6iuS3Oo3x1+BpNoawohY8LVrFePeV1pkngG1/rpTWJ/3UsJEFXC
a0FFOJocwWyCjcRSv4BPXXy1nXxvXofKIt14q94e7kz9X/vlqEEnmyXK+9PK4jsr
LvVKJYhpiSIZ41cRK+UL8QKBgF0S3f1b3XWTtkt97k7QZ8wWAZQS/d9bI0cjs4Pt
nrlhq2eZlNMxo+BHzC1WfGZlsGWKgZuOoJg0zba5AVpLuYXuvsdPjS5Bzy66K2ks
j02LFT6nRjxL1h1adMp17jY0vKgcmiYqAzBH77BZZO6OKOO78orz7eDVKulxzcqL
/4UXAoGAKk1Yfa8ZVJGlzjZHl/imvce2B+78ALJItw8hUAOxjU3780vzuppyG5o/
Zg25XbW9FbOUXt+8Tyd3/yFBBGdZ1OvL9YSngtGyLX7X3aWbg9xwR7fz8bheI+J7
QcLouNuHoUis+3EHbQIcQM9CTrP7sjFMM2LxPzxz7qPuV0ru2bg=
-----END RSA PRIVATE KEY-----
[root@test CA]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：为了创建的私钥的安全，建议把其权限修改成600。当然创建私钥的时候也可以用对称加密算法对其私钥加密，这样更加安全。需要注意的是加密后的私钥，我们要用的时候就需要对其输入对称加密的口令。如果需要把私钥用对称加密算法加密，需要指定其加密算法即可。生成的私钥名称必须同配置文件中的名称相同。&lt;/p&gt;
&lt;p&gt;　　　　3.2、签发自签名证书&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test CA]# openssl req -new -x509 -key /etc/pki/CA/private/cakey.pem -out /etc/pki/CA/cacert.pem -days 1000You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [XX]:CN
State or Province Name (full name) []:SICHUAN
Locality Name (eg, city) [Default City]:GUANGYUAN
Organization Name (eg, company) [Default Company Ltd]:TEST
Organizational Unit Name (eg, section) []:DEVOPS
Common Name (eg, your name or your server's hostname) []:ca.test.com
Email Address []:
[root@test CA]# tree
.
├── cacert.pem
├── certs
├── crl
├── newcerts
└── private
    └── cakey.pem

4 directories, 2 files
[root@test CA]# cat cacert.pem 
-----BEGIN CERTIFICATE-----
MIIDpTCCAo2gAwIBAgIJANCoyQ6AYK/SMA0GCSqGSIb3DQEBCwUAMGkxCzAJBgNV
BAYTAkNOMRAwDgYDVQQIDAdTSUNIVUFOMRIwEAYDVQQHDAlHVUFOR1lVQU4xDTAL
BgNVBAoMBFRFU1QxDzANBgNVBAsMBkRFVk9QUzEUMBIGA1UEAwwLY2EudGVzdC5j
b20wHhcNMjAwMTI5MTAzNjM2WhcNMjIxMDI1MTAzNjM2WjBpMQswCQYDVQQGEwJD
TjEQMA4GA1UECAwHU0lDSFVBTjESMBAGA1UEBwwJR1VBTkdZVUFOMQ0wCwYDVQQK
DARURVNUMQ8wDQYDVQQLDAZERVZPUFMxFDASBgNVBAMMC2NhLnRlc3QuY29tMIIB
IjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAmM8gDY90zksYI2myhqsGgMBG
APnlLbIBwiqYnte2PJZRnEJvaYRzCgw9wSca9oI5rUGu1wLOk8NlAkE6W4hXu6Ja
Ap/eMZcqzYVU2a6VhxPQLBP35dvfZT4vps737OR+l8gcJRX2VPcfJuMU+r4KbBT4
F3gP79hz/JxwK0yShlIGCnPPcCK5xS6jKBH3ezdLsRy0ZCRUwX+ivlAJ8zJ/bV4m
2OesiDW1LFPrvotRo+aBwexI1vk01Yww1x/DUnxiYCrOPS0V3wWpSS6r2qXVv0Fy
ZGS1ZP/+Jf1ZfbvL2w9kcmlQ0wadHkx3M4HJyvWinOEpMsrTr3p9RK67oNs48QID
AQABo1AwTjAdBgNVHQ4EFgQUQ/0tcuVAvzoOA13SD2x8W9Brx0EwHwYDVR0jBBgw
FoAUQ/0tcuVAvzoOA13SD2x8W9Brx0EwDAYDVR0TBAUwAwEB/zANBgkqhkiG9w0B
AQsFAAOCAQEAAl/gUsSCgKjeSq5K2TyLc3VUP2KN1m+Wu9qWKAgXiaMxY8iWj3I8
AxfNkTAqNGz66BpXh9G4hDL844spvnomjdUbCufFlNLnrkxCIyWPNVKk69fCa61T
ANzgvTbIfh/xfdfyctZpU3q9Ptcra9ksYUg7mY7209xJ+emqsBnKwYKigCCrQTT3
dxvRHFOV3Z0wJgHCtTetMI25OcpEXk3Tk75k+ayEmiTdMp2Zdk00qmOtZfCmtHO9
KdHVTAOCAOaQtd4aOZMsgADBWXVP2NPmosUm2onvrKTFB6tYXXhj5j6tPVFunCZE
R2w2VMa+Q+Pgmmt5AeqoALQaBdR31IFj0Q==
-----END CERTIFICATE-----
[root@test CA]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：颁发的证书默认是没法用cat命令来查看证书里面的信息的，我们可以通过把证书导出到windows上查看，也可以通过openssl来查看。ca的私钥和证书存放路径需要参考其配置文件中的定义来指定存放。&lt;/p&gt;
&lt;p&gt;　　在windows上查看办法的证书&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1503305/202001/1503305-20200129184026372-1650703824.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1503305/202001/1503305-20200129184451836-452480117.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1503305/202001/1503305-20200129184503302-368588483.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　说明：在Windows上查看，需要把其后缀更改为.crt才可以双击查看。之所以它提示我们说此CA根目录证书不受信用，是因为windows上没有将其证书导入，没有改根CA的信息。默认情况下，Windows里面内置了一些权威CA的证书，所以我们在权威的CA下申请的证书，放在windows上就不会报不信任的CA证书了。&lt;/p&gt;
&lt;p&gt;　　用openssl查看证书&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;45&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test CA]# openssl x509 -in cacert.pem -noout -text
Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number:
            d0:a8:c9:0e:80:60:af:d2
    Signature Algorithm: sha256WithRSAEncryption
        Issuer: C=CN, ST=SICHUAN, L=GUANGYUAN, O=TEST, OU=DEVOPS, CN=ca.test.com
        Validity
            Not Before: Jan 29 10:36:36 2020 GMT
            Not After : Oct 25 10:36:36 2022 GMT
        Subject: C=CN, ST=SICHUAN, L=GUANGYUAN, O=TEST, OU=DEVOPS, CN=ca.test.com
        Subject Public Key Info:
            Public Key Algorithm: rsaEncryption
                Public-Key: (2048 bit)
                Modulus:
                    00:98:cf:20:0d:8f:74:ce:4b:18:23:69:b2:86:ab:
                    06:80:c0:46:00:f9:e5:2d:b2:01:c2:2a:98:9e:d7:
                    b6:3c:96:51:9c:42:6f:69:84:73:0a:0c:3d:c1:27:
                    1a:f6:82:39:ad:41:ae:d7:02:ce:93:c3:65:02:41:
                    3a:5b:88:57:bb:a2:5a:02:9f:de:31:97:2a:cd:85:
                    54:d9:ae:95:87:13:d0:2c:13:f7:e5:db:df:65:3e:
                    2f:a6:ce:f7:ec:e4:7e:97:c8:1c:25:15:f6:54:f7:
                    1f:26:e3:14:fa:be:0a:6c:14:f8:17:78:0f:ef:d8:
                    73:fc:9c:70:2b:4c:92:86:52:06:0a:73:cf:70:22:
                    b9:c5:2e:a3:28:11:f7:7b:37:4b:b1:1c:b4:64:24:
                    54:c1:7f:a2:be:50:09:f3:32:7f:6d:5e:26:d8:e7:
                    ac:88:35:b5:2c:53:eb:be:8b:51:a3:e6:81:c1:ec:
                    48:d6:f9:34:d5:8c:30:d7:1f:c3:52:7c:62:60:2a:
                    ce:3d:2d:15:df:05:a9:49:2e:ab:da:a5:d5:bf:41:
                    72:64:64:b5:64:ff:fe:25:fd:59:7d:bb:cb:db:0f:
                    64:72:69:50:d3:06:9d:1e:4c:77:33:81:c9:ca:f5:
                    a2:9c:e1:29:32:ca:d3:af:7a:7d:44:ae:bb:a0:db:
                    38:f1
                Exponent: 65537 (0x10001)
        X509v3 extensions:
            X509v3 Subject Key Identifier: 
                43:FD:2D:72:E5:40:BF:3A:0E:03:5D:D2:0F:6C:7C:5B:D0:6B:C7:41
            X509v3 Authority Key Identifier: 
                keyid:43:FD:2D:72:E5:40:BF:3A:0E:03:5D:D2:0F:6C:7C:5B:D0:6B:C7:41

            X509v3 Basic Constraints: 
                CA:TRUE
    Signature Algorithm: sha256WithRSAEncryption
         02:5f:e0:52:c4:82:80:a8:de:4a:ae:4a:d9:3c:8b:73:75:54:
         3f:62:8d:d6:6f:96:bb:da:96:28:08:17:89:a3:31:63:c8:96:
         8f:72:3c:03:17:cd:91:30:2a:34:6c:fa:e8:1a:57:87:d1:b8:
         84:32:fc:e3:8b:29:be:7a:26:8d:d5:1b:0a:e7:c5:94:d2:e7:
         ae:4c:42:23:25:8f:35:52:a4:eb:d7:c2:6b:ad:53:00:dc:e0:
         bd:36:c8:7e:1f:f1:7d:d7:f2:72:d6:69:53:7a:bd:3e:d7:2b:
         6b:d9:2c:61:48:3b:99:8e:f6:d3:dc:49:f9:e9:aa:b0:19:ca:
         c1:82:a2:80:20:ab:41:34:f7:77:1b:d1:1c:53:95:dd:9d:30:
         26:01:c2:b5:37:ad:30:8d:b9:39:ca:44:5e:4d:d3:93:be:64:
         f9:ac:84:9a:24:dd:32:9d:99:76:4d:34:aa:63:ad:65:f0:a6:
         b4:73:bd:29:d1:d5:4c:03:82:00:e6:90:b5:de:1a:39:93:2c:
         80:00:c1:59:75:4f:d8:d3:e6:a2:c5:26:da:89:ef:ac:a4:c5:
         07:ab:58:5d:78:63:e6:3e:ad:3d:51:6e:9c:26:44:47:6c:36:
         54:c6:be:43:e3:e0:9a:6b:79:01:ea:a8:00:b4:1a:05:d4:77:
         d4:81:63:d1
[root@test CA]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　4、在客户端创建证书申请&lt;/p&gt;
&lt;p&gt;　　　　4.1、生成私钥信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-node3 ~]# mkdir ssl
[root@test-node3 ~]# cd ssl/
[root@test-node3 ssl]# (umask 077;openssl genrsa -out /root/ssl/app.key 2048)
Generating RSA private key, 2048 bit long modulus
.............................................................+++
.........................+++
e is 65537 (0x10001)
[root@test-node3 ssl]# ls
app.key
[root@test-node3 ssl]# cat app.key 
-----BEGIN RSA PRIVATE KEY-----
MIIEpQIBAAKCAQEA6XtScxyxgI7gC+1xYQFSXIF9RqCTAZ4WpWGQYzs30XLT1cxl
/hJ8McxMQ137H1g+PeEFbNV3oyBjEt3feCck5sb9TP4tsIhT6Lt3Zt6PIqOfDZ8k
OxWDJp/DNXHwuC8ME/mfv3CleJbL5Clyb9ovYeZkEQPK9TgG7pCHU0AxTw0r7ELP
A29Ugd/lFGQNTJt39Kmy7uBOPhKEQ+fHVaMqtmy1q/SpnM92vGvR40xRgl+HJ17A
0ACAEjbf3wK+qoQ/WBCCpMkeTLoFEn/Sa7SmZZt2F0k2cTyxSzVKadPQUlrpWVHb
zX4IDI/ssS9weiDsLL5eScj/CWWRFhKu7z98YQIDAQABAoIBAQDKu6RqA741DNqK
QNC0FHu5i06GJyO+wdCUJdVD9MWQ/o3mFSdyqAZjDywhStek7fCNtngJeon5gUPF
vBYwtHycTqjfU83EfXuumCkjj5jl0QFoyIijLRjGTu8n1xnYNDHenmAR0PQ9c2Lz
aPHPIbsG3RCCnbJ7nvyV5bU7mn+2TOb41csMVjLJoK2N91QEljkAn+4oqpTVJgJa
TnUKvafBjCn+ctZDKcsZ0H/yFhGbt0ZFEXql3WFM5AOE5tBmlmqrQY/4CzeqlPCX
zYpuUCHQBj9UYj58SfVUEoaN+gNX82amUqBOablJMpGR0vDh0CxsAxnPYF7O1o6P
hXIjjmPJAoGBAPg74aMUMoG3o91NpoedLdRrMOYcYBdd3H7KwPyXzHMoYHQjfHEm
hJKqZgE53U+TfxdFr8EJcR8aoDzDLp3+5F1ANCZD2FgvWptAyABx+I09J0OES0VB
M3hhp0pOYot1ylBbFrvGGANFa8WAnO+yyNU91CFUhp7kmQ5TuUUHt2kzAoGBAPDJ
SiXn30hQO8zVCHXzCrcltKfSnU4LiceI0jhneHfW8b42/tEegXVTEOIBiPmhLA8x
8xeIC/fS1B0ih7Uus9MUBJUN7RhlWSxGPcxA//JAxffGJwmxoYxYFkwvoTyTQrJE
igBmE6+PdSb7JOB4c3nt/YwPYvjQOieNolRMIwwbAoGBAOoNhA2AwLKAVVgXnBoo
QIsV2pBNVukRThKa1+YStuopuvAmeXIysDOdyPoE9j/OwblOso2fenKqZ0WDf1Pn
fqjSHZmqxLU5SQQzy6Bn1cROUdQeS95rwL0TzmmIiPAXyv+DM2cvO3ryHNCnGNIF
T8mIN5iJmzj8L7hLhteok+3zAoGAbot7RzvU/tYXHksPv1b9rGfbMNE49wPFFZ5z
JQIcBKjiA3osMsXWmY6xSZF62WBtYeyEtmD3XaelSlr4Au6WEGo4UFY8a97bub/l
z0hoOUgTm1WVxpWOnWgzlHaph630CPP+h4BVuVwbZPIYVBX4rhndNdg6kBDJIi+c
PydVT9ECgYEAwF5U/YS9IIb8n1NXARXA3nWmfqdJM2JcYwh33ILFB0+2gm4nr4Ie
xb14BlFMl8mYVKqykHpdE73/LYZWu/inkti8APmHyP3+7QHMWagpCucCHxGzagWy
sdo8HSqbkcQJoB0pTLPZGHEGuLMzzAII6fc+sZsHPi2NLbZZFPGdWjk=
-----END RSA PRIVATE KEY-----
[root@test-node3 ssl]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　4.2、生成证书申请文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-node3 ssl]# ll
total 4
-rw------- 1 root root 1679 Jan 29 18:55 app.key
[root@test-node3 ssl]# openssl req -new -key app.key -out app.csr
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [XX]:CN
State or Province Name (full name) []:SICHUAN
Locality Name (eg, city) [Default City]:CHENGDU
Organization Name (eg, company) [Default Company Ltd]:TEST
Organizational Unit Name (eg, section) []:DEVOPS    
Common Name (eg, your name or your server's hostname) []:www.test.org
Email Address []:

Please enter the following 'extra' attributes
to be sent with your certificate request
A challenge password []:
An optional company name []:
[root@test-node3 ssl]# ll
total 8
-rw-r--r-- 1 root root 1005 Jan 29 19:02 app.csr
-rw------- 1 root root 1679 Jan 29 18:55 app.key
[root@test-node3 ssl]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　4.3、把文件传给CA，在CA上进行证书颁发&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test CA]# rz
rz waiting to receive.
 zmodem trl+C ȡ

  100%    1005 bytes 1005 bytes/s 00:00:01       0 Errors

[root@test CA]# ls
app.csr  cacert.pem  certs  crl  newcerts  private
[root@test CA]# openssl ca -in app.csr -out /etc/pki/CA/certs/app.crt -days 365
Using configuration from /etc/pki/tls/openssl.cnf
/etc/pki/CA/index.txt: No such file or directory
unable to open '/etc/pki/CA/index.txt'
140645247747984:error:02001002:system library:fopen:No such file or directory:bss_file.c:402:fopen('/etc/pki/CA/index.txt','r')
140645247747984:error:20074002:BIO routines:FILE_CTRL:system lib:bss_file.c:404:
[root@test CA]# touch /etc/pki/CA/index.txt
[root@test CA]# openssl ca -in app.csr -out /etc/pki/CA/certs/app.crt -days 365
Using configuration from /etc/pki/tls/openssl.cnf
/etc/pki/CA/serial: No such file or directory
error while loading serial number
140572255938448:error:02001002:system library:fopen:No such file or directory:bss_file.c:402:fopen('/etc/pki/CA/serial','r')
140572255938448:error:20074002:BIO routines:FILE_CTRL:system lib:bss_file.c:404:
[root@test CA]# echo 00 &amp;gt; /etc/pki/CA/serial
[root@test CA]# openssl ca -in app.csr -out /etc/pki/CA/certs/app.crt -days 365
Using configuration from /etc/pki/tls/openssl.cnf
Check that the request matches the signature
Signature ok
Certificate Details:
        Serial Number: 0 (0x0)
        Validity
            Not Before: Jan 29 11:06:08 2020 GMT
            Not After : Jan 28 11:06:08 2021 GMT
        Subject:
            countryName               = CN
            stateOrProvinceName       = SICHUAN
            organizationName          = TEST
            organizationalUnitName    = DEVOPS
            commonName                = www.test.org
        X509v3 extensions:
            X509v3 Basic Constraints: 
                CA:FALSE
            Netscape Comment: 
                OpenSSL Generated Certificate
            X509v3 Subject Key Identifier: 
                AE:E9:31:DE:B1:86:4F:68:AB:D7:BB:E3:1B:74:AD:7A:44:D2:60:BB
            X509v3 Authority Key Identifier: 
                keyid:43:FD:2D:72:E5:40:BF:3A:0E:03:5D:D2:0F:6C:7C:5B:D0:6B:C7:41

Certificate is to be certified until Jan 28 11:06:08 2021 GMT (365 days)
Sign the certificate? [y/n]:y


1 out of 1 certificate requests certified, commit? [y/n]y
Write out database with 1 new entries
Data Base Updated
[root@test CA]# tree
.
├── app.crs
├── cacert.pem
├── certs
│   └── app.crt
├── crl
├── index.txt
├── index.txt.attr
├── index.txt.old
├── newcerts
│   └── 00.pem
├── private
│   └── cakey.pem
├── serial
└── serial.old

4 directories, 10 files
[root@test CA]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：在跟客户端颁发证书的时候需要依赖两个文件/etc/pki/CA/index.txt和/etc/pki/CA/serial，前者文件主要存放已经颁发的证书信息，后者存放下一个将要颁发的证书的序列号。这里说一下/etc/pki/CA下的各个文件和目录的作用吧，certs目录存放颁发证书的目录，crl存放吊销证书列表文件的目录，index.txt.attr存放证书subject信息是否唯一的配置信息，index.txt.old存放上一次颁发证书的信息，newcerts目录存放已经颁发的证书，并且以序列号命名的证书，每颁发一次证书，在我们指定的路径下生成指定名称的证书后，newcerts目录下会自动生成一个以序列号为名称的证书，这个证书同我们指定路径下存放的证书信息一模一样。private目录存放私钥文件。serial.old存放上一次颁发证书的序列号。&lt;/p&gt;
&lt;p&gt;　　　　4.4、查看颁发证书的信息&lt;/p&gt;
&lt;p&gt;　　Windows上查看&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1503305/202001/1503305-20200129192446377-937133347.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1503305/202001/1503305-20200129192511275-1717572937.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1503305/202001/1503305-20200129192521504-351726468.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　Linux上查看&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;44&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test CA]# openssl x509 -in certs/app.crt -noout -text
Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number: 0 (0x0)
    Signature Algorithm: sha256WithRSAEncryption
        Issuer: C=CN, ST=SICHUAN, L=GUANGYUAN, O=TEST, OU=DEVOPS, CN=ca.test.com
        Validity
            Not Before: Jan 29 11:06:08 2020 GMT
            Not After : Jan 28 11:06:08 2021 GMT
        Subject: C=CN, ST=SICHUAN, O=TEST, OU=DEVOPS, CN=www.test.org
        Subject Public Key Info:
            Public Key Algorithm: rsaEncryption
                Public-Key: (2048 bit)
                Modulus:
                    00:e9:7b:52:73:1c:b1:80:8e:e0:0b:ed:71:61:01:
                    52:5c:81:7d:46:a0:93:01:9e:16:a5:61:90:63:3b:
                    37:d1:72:d3:d5:cc:65:fe:12:7c:31:cc:4c:43:5d:
                    fb:1f:58:3e:3d:e1:05:6c:d5:77:a3:20:63:12:dd:
                    df:78:27:24:e6:c6:fd:4c:fe:2d:b0:88:53:e8:bb:
                    77:66:de:8f:22:a3:9f:0d:9f:24:3b:15:83:26:9f:
                    c3:35:71:f0:b8:2f:0c:13:f9:9f:bf:70:a5:78:96:
                    cb:e4:29:72:6f:da:2f:61:e6:64:11:03:ca:f5:38:
                    06:ee:90:87:53:40:31:4f:0d:2b:ec:42:cf:03:6f:
                    54:81:df:e5:14:64:0d:4c:9b:77:f4:a9:b2:ee:e0:
                    4e:3e:12:84:43:e7:c7:55:a3:2a:b6:6c:b5:ab:f4:
                    a9:9c:cf:76:bc:6b:d1:e3:4c:51:82:5f:87:27:5e:
                    c0:d0:00:80:12:36:df:df:02:be:aa:84:3f:58:10:
                    82:a4:c9:1e:4c:ba:05:12:7f:d2:6b:b4:a6:65:9b:
                    76:17:49:36:71:3c:b1:4b:35:4a:69:d3:d0:52:5a:
                    e9:59:51:db:cd:7e:08:0c:8f:ec:b1:2f:70:7a:20:
                    ec:2c:be:5e:49:c8:ff:09:65:91:16:12:ae:ef:3f:
                    7c:61
                Exponent: 65537 (0x10001)
        X509v3 extensions:
            X509v3 Basic Constraints: 
                CA:FALSE
            Netscape Comment: 
                OpenSSL Generated Certificate
            X509v3 Subject Key Identifier: 
                AE:E9:31:DE:B1:86:4F:68:AB:D7:BB:E3:1B:74:AD:7A:44:D2:60:BB
            X509v3 Authority Key Identifier: 
                keyid:43:FD:2D:72:E5:40:BF:3A:0E:03:5D:D2:0F:6C:7C:5B:D0:6B:C7:41

    Signature Algorithm: sha256WithRSAEncryption
         46:94:4f:ab:6f:43:43:fb:0d:d1:e2:71:ff:5d:5b:0e:39:59:
         c2:3f:92:47:88:84:2f:80:e4:00:a1:94:86:9a:bc:19:bb:22:
         22:e1:2f:93:d1:1b:19:92:5f:de:46:47:30:e4:f5:b7:d8:b4:
         e7:62:37:9c:17:cc:e7:8c:f4:b7:8a:cc:09:62:fd:6f:56:e3:
         a3:22:1d:d8:01:e2:34:87:45:86:04:be:c7:91:b4:e9:49:f6:
         39:c9:c4:67:6a:f7:8b:96:09:2f:d3:d4:a4:e5:a3:f0:d9:1d:
         e6:dc:28:65:da:70:27:9b:70:5a:6a:a5:5a:77:c3:51:e0:54:
         b0:7f:e4:a1:9a:4c:b5:d2:82:84:d9:3f:c8:57:dd:25:0a:80:
         81:61:c6:a4:d1:5b:19:21:5d:19:1e:7d:b4:4f:a2:54:f4:bf:
         f9:d0:2e:ba:4a:94:f1:93:be:54:cc:3b:19:7a:ae:fd:bd:4a:
         b5:e3:55:a3:2a:a0:69:0e:08:78:9d:91:d5:df:02:bd:ec:c9:
         cc:d2:6e:68:bf:48:3c:73:df:e9:62:92:8f:6c:9d:2f:2c:32:
         85:46:a7:30:22:22:9c:2d:af:d0:cf:02:e0:21:3b:1d:6a:a3:
         f7:81:0b:63:10:8c:f1:30:4a:05:08:4b:52:ad:4a:1d:14:9c:
         0c:64:2b:71
[root@test CA]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　到此私有CA服务器的搭建、证书的申请和颁发就完成了，后续使用证书，就需要把证书放到对应的应用目录，配置其应用服务来使用其证书即可。通常申请证书不用在客户端申请，在服务端创建私钥，创建申请证书文件，然后签发证书，生成证书文件，然后把私钥和证书发给客户端即可。&lt;/p&gt;
&lt;p&gt;　　5、吊销证书&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test CA]# openssl x509 -in certs/app.crt -noout -serial -subject
serial=00
subject= /C=CN/ST=SICHUAN/O=TEST/OU=DEVOPS/CN=www.test.org
[root@test CA]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：以上命令是对要吊销的证书获取其序列号和subject信息，这个操作一般是客户端上查看，然后把信息发送给CA&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test CA]# openssl ca -revoke /etc/pki/CA/newcerts/00.pem 
Using configuration from /etc/pki/tls/openssl.cnf
Revoking Certificate 00.
Data Base Updated
[root@test CA]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：在CA上，根据客户端提交的serial与subject信息，对比检验是否与index.txt文件的信息一致，然后在进行吊销证书操作&lt;/p&gt;
&lt;p&gt;　　6、更新证书吊销列表crl文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test CA]# openssl ca -gencrl -out /etc/pki/CA/crl.pem
Using configuration from /etc/pki/tls/openssl.cnf
/etc/pki/CA/crlnumber: No such file or directory
error while loading CRL number
140437997475728:error:02001002:system library:fopen:No such file or directory:bss_file.c:402:fopen('/etc/pki/CA/crlnumber','r')
140437997475728:error:20074002:BIO routines:FILE_CTRL:system lib:bss_file.c:404:
[root@test CA]# echo 00 &amp;gt; /etc/pki/CA/crlnumber
[root@test CA]# openssl ca -gencrl -out /etc/pki/CA/crl.pem
Using configuration from /etc/pki/tls/openssl.cnf
[root@test CA]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：第一次更新证书吊销列表，它会提示我们说缺少crlnumber文件，这个文件同serial的作用类似，都是存放的是版本号，我们需要创建其文件，并写一个16进制的编号，通常是从00或者01开始。（这个文件同serial一样都会自动增长，一般后续不需要怎么维护它）&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test CA]# openssl crl -in /etc/pki/CA/crl.pem -noout -text
Certificate Revocation List (CRL):
        Version 2 (0x1)
    Signature Algorithm: sha256WithRSAEncryption
        Issuer: /C=CN/ST=SICHUAN/L=GUANGYUAN/O=TEST/OU=DEVOPS/CN=ca.test.com
        Last Update: Jan 29 11:48:03 2020 GMT
        Next Update: Feb 28 11:48:03 2020 GMT
        CRL extensions:
            X509v3 CRL Number: 
                0
Revoked Certificates:
    Serial Number: 00
        Revocation Date: Jan 29 11:41:28 2020 GMT
    Signature Algorithm: sha256WithRSAEncryption
         87:12:f8:b2:ec:b7:77:94:4b:bc:e4:ea:69:03:27:78:d3:b5:
         43:8d:45:c5:a4:50:53:d7:3b:81:48:a1:cf:5d:43:4e:13:01:
         91:5e:a2:f2:87:44:87:84:16:b2:1d:0e:28:81:88:d4:1a:c2:
         a4:55:22:9f:d0:b9:6b:3c:80:e2:6e:98:fb:c3:18:3e:d3:a0:
         49:a3:0e:19:64:2f:03:51:4b:ec:32:1c:c8:41:62:46:e8:4f:
         8c:ec:a2:07:1c:fc:4b:20:61:ca:04:0e:31:8b:b9:4e:ce:42:
         81:66:d6:09:3e:1e:15:44:76:33:27:07:fd:17:10:6d:d0:12:
         cf:4f:ce:cb:3d:b4:6d:68:f1:5a:1a:4f:44:a6:65:cd:f6:3b:
         4e:2e:3f:6d:2a:f8:d5:8a:52:5a:b0:8d:b1:8f:73:08:50:9c:
         89:d3:c0:97:0e:13:89:37:cc:13:ad:d9:db:61:06:6d:4f:0a:
         6b:58:a0:53:0a:2b:e8:23:18:cd:3b:0c:5d:9e:77:c3:85:3e:
         e3:3c:ab:ad:45:9e:3c:18:7a:85:b0:51:7e:4d:8e:c6:18:e7:
         fc:4d:f1:01:ac:b3:89:2c:eb:f7:0e:f9:3c:ea:5a:42:ff:43:
         6b:98:9f:a0:89:59:28:92:c9:ed:d3:59:87:ca:04:8c:8c:92:
         c0:a1:72:8a
[root@test CA]# cat /etc/pki/CA/index.txt
R       210128110608Z   200129114128Z   00      unknown /C=CN/ST=SICHUAN/O=TEST/OU=DEVOPS/CN=www.test.org
[root@test CA]# cat /etc/pki/CA/crlnumber
01
[root@test CA]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：证书吊销后其index.txt里的信息会发生变化，R表示该证书已经被吊销，V表示该证书未吊销。&lt;/p&gt;
&lt;p&gt;　　在windows上查看证书吊销列表crl文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1503305/202001/1503305-20200129200110921-1055976167.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1503305/202001/1503305-20200129200121603-544110985.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
</description>
<pubDate>Wed, 29 Jan 2020 14:19:00 +0000</pubDate>
<dc:creator>qiuhom</dc:creator>
<og:description>一、CA简介 CA是什么？CA是Certificate Authority的简写，从字面意思翻译过来是凭证管理中心，认证授权。它有点类似我们生活中的身份证颁发机构，这里的CA就相当于生活中颁发身份证的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qiuhom-1874/p/12237944.html</dc:identifier>
</item>
<item>
<title>Python装饰器 - Yabea</title>
<link>http://www.cnblogs.com/ybjourney/p/12241697.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ybjourney/p/12241697.html</guid>
<description>&lt;p&gt;装饰器在Python中是一个强大的高级用法，并且在流行Python框架中变得越来越常见。经常会用到装饰器来增强函数的行为（动态的给一个对象添加一些额外的职责），包括记录日志，权限校验，性能测试，数据封装等。有了装饰器，我们可以抽离出大量和函数功能本身无关的雷同代码并继续重用。&lt;/p&gt;
&lt;p&gt;Python装饰器有两种：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;函数装饰器：管理函数调用和函数对象&lt;/li&gt;
&lt;li&gt;类装饰器：管理类实例和类自身&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;为什么使用装饰器？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;经常会遇到给函数或类增加新功能的场景，当然我们可以使用函数调用或者其它技术来实现，但是使用装饰器意图明确，最小化扩展代码的冗余，使用@语法糖，相对优雅。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;装饰器的原理是什么？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们先来看一个最简单的装饰器：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import time
from functools import wraps

def time_it(func):
    &quot;&quot;&quot;
    输出函数的运行时间
    :param func:
    :return:
    &quot;&quot;&quot;
    @wraps(func)
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func()
        end_time = time.time()
        process_time = end_time - start_time
        print(func.__name__, process_time)
        return result
    return wrapper

@time_it
def func_a():
    time.sleep(2)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对上述代码进行解释：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;time_it返回wrapper函数对象&lt;/li&gt;
&lt;li&gt;使用time_it装饰func_a函数&lt;/li&gt;
&lt;li&gt;调用被装饰的func_a函数会运行wrapper函数，func_a其实是wrapper的引用&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;原理：我们知道Python中一切皆对象，可以将函数作为其它函数的返回值。可以看到，装饰器的本质是一个函数，返回一个函数对象，通过&quot;@&quot;语法糖在包装函数中引入装饰器。&lt;/p&gt;
&lt;p&gt;装饰器的一个关键特性是，在被装饰的函数定义之后立即执行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@wraps&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上述装饰器中用到的了@wraps(func)，在创建装饰器时，一定要记得为包装函数添加functools库中的@wraps装饰器，以保证函数的元数据（包括函数名，函数注解等）不被丢失。&lt;/p&gt;
&lt;p&gt;当我们需要访问为被装饰器修饰的原包装函数时，可以使用@wraps的&lt;code&gt;__wrapped__&lt;/code&gt;属性来访问。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;内置装饰器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Python有三个内置装饰器：@staticmathod、@classmethod和@property&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;@staticmethod：类的静态方法，跟成员方法的区别是没有self参数，并且可以在类不进行实例化的情况下调用。&lt;/li&gt;
&lt;li&gt;@classmethod：跟成员方法的区别是接收的第一个参数不是self，而是cls（当前类的具体类型）&lt;/li&gt;
&lt;li&gt;@property：表示可以直接通过类实例直接访问的信息。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;装饰器嵌套&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了支持多步骤的扩展，装饰器语法允许我们向一个装饰的函数或方法添加多个装饰器，若多个装饰器同时装饰一个函数，那么装饰器的调用顺序和@语法糖的声明顺序相反，也就是：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;@decorator1
@decorator2
def func():
    pass&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;等效于：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;func = decorator1(decorator2(func()))&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;装饰器参数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;函数装饰器和类装饰器都能接收参数，这些参数传递给了真正返回装饰器的可调用对象，而装饰器反过来又返回一个可调用对象。&lt;/p&gt;
&lt;p&gt;装饰器参数在装饰发生之前就解析了，并且它们通常用来保持状态信息供随后的调用使用。&lt;/p&gt;
&lt;p&gt;上述实例中，func_a()是没有参数的，那如果添加参数的话，装饰器该如何编写以接收参数呢？可以在装饰器中使用*args和**kwargs代替参数：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def time_it(func):
    &quot;&quot;&quot;
    输出函数的运行时间
    :param func:
    :return:
    &quot;&quot;&quot;
    @wraps(func)
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        process_time = end_time - start_time
        print(func.__name__, process_time)
        return result
    return wrapper&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;带参数的装饰器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们有时候需要提供给被装饰的函数特定的功能，需要在装饰器中带参数。比如在业务处理中我们需要限定函数的执行超时时间，由于每个函数所对应的超时时间不一样，所以需要在装饰器中带参数以实现。&lt;/p&gt;
&lt;p&gt;装饰器的语法允许我们在调用时，提供其它参数，实现上述场景：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import time
import signal
import functools


def func_timeout(timeout):
    &quot;&quot;&quot;
    超时时间装饰器
    :param timeout:
    :return:
    &quot;&quot;&quot;
    def decorator(func):
        def handler(signum, frame):
            raise RuntimeError(&quot;run %s timeout !&quot; % func.__name__)

        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            signal.signal(signal.SIGALRM, handler)
            signal.alarm(timeout)
            func(*args, **kwargs)
            signal.alarm(0)
        return wrapper
    return decorator


@func_timeout(timeout=10)
def func():
    time.sleep(11)
    print(&quot;#&quot; * 100)


if __name__ == '__main__':
    func()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;类装饰器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上述实例都是函数装饰器，相比函数装饰器，类装饰器更加灵活，主要依靠类的&lt;code&gt;__call__&lt;/code&gt;方法，当使用@形式将装饰器附加到函数上时，就会调用此方法。&lt;/p&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class Foo(object):
    def __init__(self, func):
        self._func = func

    def __call__(self, *args, **kwargs):
        print(&quot;class decorator start&quot;)
        self._func(*args, **kwargs)
        print(&quot;class decorator end&quot;)


@Foo
def func():
    print(&quot;test123&quot;)

if __name__ == '__main__':
    func()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上，代码见 &lt;a href=&quot;https://github.com/Yabea/Python/tree/master/learn_python/decorator&quot;&gt;my github&lt;/a&gt;。&lt;/p&gt;
</description>
<pubDate>Wed, 29 Jan 2020 14:18:00 +0000</pubDate>
<dc:creator>Yabea</dc:creator>
<og:description>本文介绍了Python装饰器及其原理，并实现了常见实例。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ybjourney/p/12241697.html</dc:identifier>
</item>
<item>
<title>python接口自动化测试 - openpyxl基本使用 - 小菠萝测试笔记</title>
<link>http://www.cnblogs.com/poloyy/p/12239344.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/poloyy/p/12239344.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;当你做接口自动化测试时，测试用例逐渐变多情况下，如果所有测试用例都通过代码管理将会使得代码十分臃肿，而且维护成本会很高；&lt;/li&gt;
&lt;li&gt;所以我们一般会通过Excel去管理所有的测试用例，而openpyxl库提供了访问Excel的方法&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;openpyxl简单介绍&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;一个Python库，用于读取/写入Excel 2010  &lt;span class=&quot;cnblogs_code&quot;&gt;xlsx&lt;/span&gt; 、&lt;span class=&quot;cnblogs_code&quot;&gt;xlsm&lt;/span&gt; 、&lt;span class=&quot;cnblogs_code&quot;&gt;xltx&lt;/span&gt; 、&lt;span class=&quot;cnblogs_code&quot;&gt;xltm&lt;/span&gt; 文件&lt;/li&gt;
&lt;li&gt;不能操作 &lt;span class=&quot;cnblogs_code&quot;&gt;xls&lt;/span&gt; 文件&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;openpyxl简单概念&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Workbook&lt;/strong&gt;：excel工作表&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Sheet&lt;/strong&gt;：工作表中的一张表&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Cell&lt;/strong&gt;：其中的一个单元格&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;简单步骤&lt;/strong&gt;：打开Workbook，选中Sheet，操作Cell&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;openpyxl简单使用&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; openpyxl
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     path = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;F:/imocInterface/case/imooc.xlsx&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 读取excel文件&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     workbook =&lt;span&gt; openpyxl.load_workbook(path)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 读取所有sheet&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     sheet =&lt;span&gt; workbook.get_sheet_names()
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取某个sheet&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     sheet =&lt;span&gt; workbook[sheet[0]]
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取某个cell的值&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     cell_val = sheet.cell(row=2, column=2&lt;span&gt;).value
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(cell_val)
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;包含知识点&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;调用 &lt;span class=&quot;cnblogs_code&quot;&gt;load_workbook()&lt;/span&gt; 等同于调用 &lt;span class=&quot;cnblogs_code&quot;&gt;open()&lt;/span&gt; &lt;/li&gt;
&lt;li&gt;第8、10行代码可能浓缩成一行代码 &lt;span class=&quot;cnblogs_code&quot;&gt;workbook.get_sheet_by_name(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sheet的名字&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)&lt;/span&gt; ，前提是你得知道sheet的命名&lt;/li&gt;
&lt;li&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;cell(row, column, value=None)&lt;/span&gt; 三个参数分别是：行，列，值；若设置了value相当于赋值操作，会覆盖原本的值&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;访问单个cell&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 方式一：获取A4单元格的值&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;     cell_val = sheet[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;A4&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;].value
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 方式二：获取第二行,第二列的单元格的值&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;     cell_val = sheet.cell(row=2, column=2).value
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;访问多个cell&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; A1-B3的单元格 共6个&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;     cell_range = sheet[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;A1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;B3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; A1-A3的单元格 共3个&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     cell_range = sheet[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;A1:A3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 第十行的单元格&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     cell_range = sheet[10&lt;span&gt;]
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 第1、2行的单元格&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     cell_range = sheet[1:2]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt; 注意：&lt;/strong&gt;以上方法返回的是都是cell对象组成tuple&lt;/p&gt;

&lt;h2&gt;获取指定范围的cell&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回行&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; col &lt;span&gt;in&lt;/span&gt; sheet.iter_rows(min_row=1, min_col=1, max_col=3, max_row=2&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; cell &lt;span&gt;in&lt;/span&gt;&lt;span&gt; col:
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(cell)
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; 
&lt;span&gt;6&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回列&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; col &lt;span&gt;in&lt;/span&gt; sheet.iter_cols(min_row=1, min_col=1, max_col=3, max_row=2&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; cell &lt;span&gt;in&lt;/span&gt;&lt;span&gt; col:
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(cell)
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;获取指定范围cell的测试结果&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回行&lt;/span&gt;
&amp;lt;Cell &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Sheet1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.A1&amp;gt;
&amp;lt;Cell &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Sheet1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.B1&amp;gt;
&amp;lt;Cell &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Sheet1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.C1&amp;gt;
&amp;lt;Cell &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Sheet1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.A2&amp;gt;
&amp;lt;Cell &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Sheet1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.B2&amp;gt;
&amp;lt;Cell &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Sheet1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.C2&amp;gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回列&lt;/span&gt;
&amp;lt;Cell &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Sheet1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.A1&amp;gt;
&amp;lt;Cell &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Sheet1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.A2&amp;gt;
&amp;lt;Cell &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Sheet1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.B1&amp;gt;
&amp;lt;Cell &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Sheet1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.B2&amp;gt;
&amp;lt;Cell &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Sheet1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.C1&amp;gt;
&amp;lt;Cell &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Sheet1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.C2&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;官方提醒：&lt;/strong&gt;出于性能考虑， &lt;span class=&quot;cnblogs_code&quot;&gt;sheet.iter_cols()&lt;/span&gt; 方法不支持在只读模式使用&lt;/p&gt;

&lt;h2&gt;获取sheet内所有行和列的cell&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 以列的形式,获取sheet的全部cell&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;     data =&lt;span&gt; tuple(sheet.columns)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 以行的形式,获取sheet的全部cell&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     data =&lt;span&gt; tuple(sheet.rows)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取所有数据&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     data =&lt;span&gt; tuple(sheet.values)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 指定返回某一行数据&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(data[2])
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;sheet.rows&lt;/span&gt; 返回的是一个对象，需要用 &lt;span class=&quot;cnblogs_code&quot;&gt;tuple()&lt;/span&gt; 才能将对象转换成tuple&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;官方提醒：&lt;/strong&gt;出于性能考虑， &lt;span class=&quot;cnblogs_code&quot;&gt;sheet.cloumns 方法不支持在只读模式使用&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;获取sheet的行数、列数&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取sheet最大行&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;     data =&lt;span&gt; sheet.max_row
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取sheet最多列&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     data =&lt;span&gt; sheet.max_column
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取sheet最小行&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     data =&lt;span&gt; sheet.min_row
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取sheet最小列&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     data = sheet.min_column
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;openpyxl写入数据&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     workbook =&lt;span&gt; openpyxl.load_workbook(path)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     sheet =&lt;span&gt; workbook.active
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     sheet.cell(row=2, col=2, value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;213&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     workbook.save(filename=path)
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;包含知识点&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;写入数据的文件需要是可写文件，需要已关闭；若打开着excel的话无法写入会报 &lt;span class=&quot;cnblogs_code&quot;&gt;PermissionError: [Errno 13] Permission denied: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;XXXXX.xlsx&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;/span&gt; &lt;/li&gt;
&lt;li&gt;其实就是四部曲：获取excel - 执行 &lt;span class=&quot;cnblogs_code&quot;&gt;workbook.active&lt;/span&gt; - 赋值操作 - 保存文件&lt;/li&gt;
&lt;li&gt;赋值操作还可以是  &lt;span class=&quot;cnblogs_code&quot;&gt;sheet[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;B2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;213&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt; ，等价于上面第三行代码&lt;/li&gt;
&lt;li&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;save()&lt;/span&gt; 会覆盖原有文件，不会有提醒&lt;/li&gt;
&lt;/ul&gt;
</description>
<pubDate>Wed, 29 Jan 2020 13:05:00 +0000</pubDate>
<dc:creator>小菠萝测试笔记</dc:creator>
<og:description>前言 当你做接口自动化测试时，测试用例逐渐变多情况下，如果所有测试用例都通过代码管理将会使得代码十分臃肿，而且维护成本会很高； 所以我们一般会通过Excel去管理所有的测试用例，而openpyxl库提</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/poloyy/p/12239344.html</dc:identifier>
</item>
<item>
<title>用代码说话：如何正确启动线程 - James_Shangguan</title>
<link>http://www.cnblogs.com/sgh1023/p/12241220.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sgh1023/p/12241220.html</guid>
<description>&lt;p&gt;先来看下结论：正确启动线程的方式是使用start()方法，而不是使用run()方法。&lt;/p&gt;
&lt;h2 id=&quot;代码实战&quot;&gt;代码实战&lt;/h2&gt;
&lt;h3 id=&quot;输出线程名称&quot;&gt;1. 输出线程名称&lt;/h3&gt;
&lt;p&gt;“Talk is cheap. Show me the code”，用代码说话：分别调用run()方法和start()方法，打印输出线程的名字。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class StartAndRunThread {
    public static void main(String[] args) {
        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                System.out.println(Thread.currentThread().getName());
            }
        };
        runnable.run();
        new Thread(runnable).start();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/6842240-bac335138a6a4560.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;深入一点&quot;&gt;2. 深入一点&lt;/h3&gt;
&lt;p&gt;如果代码是这样的，执行结果有什么不同呢？&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class StartAndRunThread {
    public static void main(String[] args) {
        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                System.out.println(Thread.currentThread().getName());
            }
        };
        runnable.run();
        new Thread(runnable).start();
        runnable.run();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果为：&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/6842240-5cb4d99b1e8faa11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;是不是有点意外？然而，这就是真相。其实也不难解释。&lt;/p&gt;
&lt;ol readability=&quot;1.8867924528302&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;我们说的并发是什么，并发不就是线程之间的运行互不干扰嘛？当JVM启动的时候，创建一个mian线程来运行main()方法。当执行到“new Thread(runnable).start();”的时候main线程会新建一个Thread-0线程。main线程和Thread-0线程的执行时互不相干的，所以可能不会出现“main-Thread-0-main”的结果。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1.8452380952381&quot;&gt;
&lt;p&gt;我执行了n（n&amp;gt;20）次，运行结果依然如上图所示，没有出现“main-Thread-0-main”。这是为什么呢？回忆一下线程的生命周期， Java中，线程（Thread）定义了6种状态： NEW（新建）、RUNNABLE（可执行）、BLOCKED（阻塞）、WAITING（等待）、TIMED_WAITING（限时等待）、TERMINATED（结束）。当调用了start()方法之后，线程进入RUNNABLE状态，RUNNABLE的意思是可运行，即可能正在执行，也可能没有正在执行。那调用了start方法之后，什么时候执行呢？调用start()方法之后，我们只是告诉JVM去执行这个线程，至于什么时候运行是由线程调度器来决定的。从操作系统层面，其实调用start()方法之后要去获取操作系统的时间片，获取到才会执行。这个问题，可以对比思考“ thread.start()调用之后线程会立刻执行吗？”更多可以参考：&lt;a href=&quot;https://www.cnblogs.com/sgh1023/p/10528000.html&quot;&gt;从源码解读线程（Thread）和线程池（ThreadPoolExecutor）的状态&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;start方法源码分析&quot;&gt;start()方法源码分析&lt;/h2&gt;
&lt;p&gt;start()源码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public synchronized void start() {
    /**
     * This method is not invoked for the main method thread or &quot;system&quot;
     * group threads created/set up by the VM. Any new functionality added
     * to this method in the future may have to also be added to the VM.
     *
     * A zero status value corresponds to state &quot;NEW&quot;.
     */
    if (threadStatus != 0)
        throw new IllegalThreadStateException();


    /* Notify the group that this thread is about to be started
     * so that it can be added to the group's list of threads
     * and the group's unstarted count can be decremented. */
    group.add(this);


    boolean started = false;
    try {
        start0();
        started = true;
    } finally {
        try {
            if (!started) {
                group.threadStartFailed(this);
            }
        } catch (Throwable ignore) {
            /* do nothing. If start0 threw a Throwable then
              it will be passed up the call stack */
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，start()方法被synchronized关键字修饰，保证了线程安全。启动流程分为下面三个步骤：&lt;/p&gt;
&lt;ol readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;首先会检查线程状态，只有threadStatus == 0（也就是线程处于NEW状态）状态下的线程才能继续，否则会抛出IllegalThreadStateException。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将线程加入线程组&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;调用native方法——start0()方法启动线程。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;线程启动相关问题&quot;&gt;线程启动相关问题&lt;/h2&gt;
&lt;h3 id=&quot;一个线程两次调用start方法会出现什么情况&quot;&gt;1. 一个线程两次调用start()方法会出现什么情况？&lt;/h3&gt;
&lt;p&gt;会抛出IllegalThreadStateException，具体原因可以用源码和线程启动步骤进行说明。&lt;/p&gt;
&lt;h3 id=&quot;既然-start-方法会调用-run-方法为什么我们选择调用-start-方法而不是直接调用-run-方法呢&quot;&gt;2. 既然 start() 方法会调用 run() 方法，为什么我们选择调用 start() 方法，而不是直接调用 run() 方法呢？&lt;/h3&gt;
&lt;p&gt;start()才是真正启动一个线程，而如果直接调用run()，那么run()只是一个普通的方法而已，和线程的生命周期没有任何关系。用代码验证一下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Main implements Runnable {

    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName());
    }

    public static void main(String[] args) {
        new Main().run();
        new Thread(new Main()).start();
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/6842240-8c41c94cb04478b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在上面代码中，直接调用run()方法，run()只是一个普通的方法，由当前线程——main线程执行。start()才是真正启动一个线程——Thread0，run()方法由线程Thread0执行。&lt;/p&gt;
&lt;h3 id=&quot;上面说start会调用run方法这个怎么证明为什么在start方法的源码中没有看到调用了run方法&quot;&gt;3. 上面说start()会调用run()方法，这个怎么证明？为什么在start(）方法的源码中没有看到调用了run()方法？&lt;/h3&gt;
&lt;p&gt;可以看start()方法的注释部分：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
* Causes this thread to begin execution; the Java Virtual Machine
* calls the &amp;lt;code&amp;gt;run&amp;lt;/code&amp;gt; method of this thread.
* &amp;lt;p&amp;gt;
* The result is that two threads are running concurrently: the
* current thread (which returns from the call to the
* &amp;lt;code&amp;gt;start&amp;lt;/code&amp;gt; method) and the other thread (which executes its
* &amp;lt;code&amp;gt;run&amp;lt;/code&amp;gt; method).
* &amp;lt;p&amp;gt;
* It is never legal to start a thread more than once.
* In particular, a thread may not be restarted once it has completed
* execution.
*
* @exception  IllegalThreadStateException  if the thread was already
*               started.
* @see        #run()
* @see        #stop()
*/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也就是说当该线程开始执行的时候，Java虚拟机会自动调用该线程的run()方法。&lt;/p&gt;
</description>
<pubDate>Wed, 29 Jan 2020 12:36:00 +0000</pubDate>
<dc:creator>James_Shangguan</dc:creator>
<og:description>先来看下结论：正确启动线程的方式是使用start()方法，而不是使用run()方法。 代码实战 1. 输出线程名称 “Talk is cheap. Show me the code”，用代码说话：分别</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sgh1023/p/12241220.html</dc:identifier>
</item>
<item>
<title>16、python面对对象之类和继承 - miki_peng</title>
<link>http://www.cnblogs.com/miki-peng/p/12241177.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/miki-peng/p/12241177.html</guid>
<description>
&lt;p&gt;&lt;span&gt;前言：本文主要介绍python面对对象中的类和继承，包括类方法、静态方法、只读属性、继承等。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;一、类方法&lt;/h2&gt;
&lt;hr/&gt;&lt;h4&gt; 1.类方法定义&lt;/h4&gt;
&lt;p&gt;　　使用装饰器@classmethod装饰，且第一个参数必须是当前类对象，该参数名一般约定为“cls&quot;，通过它来传递类的属性和方法&lt;/p&gt;
&lt;p&gt;（不能传递实例属性和实例方法），跟实例方法的self用法相似。&lt;/p&gt;
&lt;h4&gt;2.类方法的调用&lt;/h4&gt;
&lt;p&gt;　　实例对象和类对象都可以调用&lt;/p&gt;
&lt;h4&gt;3.应用场景&lt;/h4&gt;
&lt;p&gt;　　在需要站在类的角度执行某个行为时，那么就可以定义为类方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Student:

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, name, age):
        self.name &lt;/span&gt;=&lt;span&gt; name
        self.age &lt;/span&gt;=&lt;span&gt; age

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; student_info(self):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;实例方法&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-----student_info-----&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name：{}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(self.name))
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;age：{}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(self.age))

    @classmethod  　　　　 &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 带有@classmethod标志的就是类方法，@xxx 就是装饰器&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; class_info(cls):  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; cls与self的用法一致，self代表的是实例对象本身，cls代表的是类本身&lt;/span&gt;
        &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;类方法&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt; 　　　 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 应用场景：需要站在类的角度执行某个行为时，就定义为类方法&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-----class_info-----&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;在校学生&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cls:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, cls)


case &lt;/span&gt;= Student(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;张三&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 22&lt;span&gt;)
case.student_info()
case.class_info()  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 通过实例对象访问类方法&lt;/span&gt;
Student.class_info()  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 通过类对象访问类方法&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
C:\software\python\python.exe D:/learn/python18_http_request/exercise/&lt;span&gt;test.py
&lt;/span&gt;-----student_info-----&lt;span&gt;
name：张三
age：&lt;/span&gt;22
-----class_info-----&lt;span&gt;
在校学生
cls: &lt;/span&gt;&amp;lt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__.Student&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;
-----class_info-----&lt;span&gt;
在校学生
cls: &lt;/span&gt;&amp;lt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__.Student&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;&lt;span&gt;

Process finished with exit code 0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;二、静态方法&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt; （了解即可，在自动化测试中暂时用不到）&lt;/p&gt;
&lt;h4&gt;1.静态方法定义&lt;/h4&gt;
&lt;p&gt;　　使用装饰器@staticmethod装饰，参数随意，不需要“self“和“cls&quot;参数，但是方法体中不能使用类或实例的任何属性和方法&lt;/p&gt;
&lt;h4&gt;2.静态方法的调用&lt;/h4&gt;
&lt;p&gt;　　实例对象和类对象都可以调用&lt;/p&gt;
&lt;h4&gt;3.应用场景&lt;/h4&gt;
&lt;p&gt;　　用于存放纯逻辑代码，内部不需要引用类或实例的属性和方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Student:

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, name, age):
        self.name &lt;/span&gt;=&lt;span&gt; name
        self.age &lt;/span&gt;=&lt;span&gt; age

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; student_info(self):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;实例方法&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-----student_info-----&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name：{}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(self.name))
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;age：{}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(self.age))

    @staticmethod       &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 静态方法不会牵涉到类和实例，里面只存放逻辑代码&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; static_move():  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 类和实例都可以调用静态方法&lt;/span&gt;
        &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;静态方法&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-----static_info-----&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;清华大学的学生&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)


case &lt;/span&gt;= Student(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;张三&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 22&lt;span&gt;)
case.student_info()
case.static_move()  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 通过实例对象访问静态方法&lt;/span&gt;
Student.static_move()  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 通过类对象访问静态方法&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
C:\software\python\python.exe D:/learn/python18_http_request/exercise/&lt;span&gt;test.py
&lt;/span&gt;-----student_info-----&lt;span&gt;
name：张三
age：&lt;/span&gt;22
-----static_info-----&lt;span&gt;
清华大学的学生
&lt;/span&gt;-----static_info-----&lt;span&gt;
清华大学的学生

Process finished with exit code 0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;三、只读属性&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt; （了解即可，在自动化测试中暂时用不到）&lt;/p&gt;
&lt;h4&gt;1.只读属性定义&lt;/h4&gt;
&lt;p&gt;　　使用装饰器@property装饰，需要一个self参数，即实例对象本身，用于定义一个属性（一般指实例属性），只能读，不能写入&lt;/p&gt;
&lt;h4&gt;2.只读属性的调用&lt;/h4&gt;
&lt;p&gt;　　通过实例对象去调用&lt;/p&gt;
&lt;h4&gt;3.应用场景&lt;/h4&gt;
&lt;p&gt;　　属性只能读，不可以写入或更改&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Student:

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, name, age):
        self.name &lt;/span&gt;=&lt;span&gt; name
        self.age &lt;/span&gt;=&lt;span&gt; age

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; student_info(self):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;实例方法&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-----student_info-----&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name：{}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(self.name))
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;age：{}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(self.age))

    @property
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; property(self):  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 定义一个只能用，不能改的属性，了解即可&lt;/span&gt;
        &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;只读属性&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-----property_info-----&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 18&lt;span&gt;


case &lt;/span&gt;= Student(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;张三&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 22&lt;span&gt;)
case.student_info()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(case.property)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 通过实例对象访问只读属性&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
C:\software\python\python.exe D:/learn/python18_http_request/exercise/&lt;span&gt;test.py
&lt;/span&gt;-----student_info-----&lt;span&gt;
name：张三
age：&lt;/span&gt;22
-----property_info-----
18&lt;span&gt;

Process finished with exit code 0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;四、继承&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt; 　　在上一章的随笔中也提到过，在python3中，所有的类都默认继承自object这个父类（基础类）。那么什么是继承？继承的作用是什么呢？&lt;/p&gt;
&lt;h3&gt;1.继承的定义及作用&lt;/h3&gt;
&lt;p&gt;　　　　　　继承的类叫子类&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;作用&lt;/strong&gt;：子类可以通过继承获得父类的属性和方法，从而提高开发的效率和代码的复用&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;2.调用父类里的方法&lt;/h3&gt;
&lt;p&gt;　　子类的实例对象能访问所有父类的实例方法，不管往上有几层父类都可以访问，但不能往下访问自己的子类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; BasePhone(object):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;定义一个手机基础类&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, brand, model, price):
        self.brand &lt;/span&gt;=&lt;span&gt; brand
        self.model &lt;/span&gt;=&lt;span&gt; model
        self.price &lt;/span&gt;=&lt;span&gt; price

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; phone_func(self):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;手机功能&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;这款手机是触屏手机&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;这款手机是智能手机&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;这款手机有红外线功能&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;这款手机有nfc功能&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; HonorPhone(BasePhone):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;继承手机基础类，这是荣耀系列手机，基础功能都有&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; phone_info(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;您的手机品牌是{}，型号{}，价格{}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(self.brand,self.model,self.price))

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; honor_func(self):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;荣耀功能&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;这款手机支持HiFi&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;这款手机可以玩mobile游戏&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;这款手机支持应用分屏&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; HonorPorPhone(HonorPhone):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;继承手机基础类，这是荣耀pro系列手机，基础功能和荣耀功能都有&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; new_func(self):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;新功能&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;这款手机支持30倍变焦&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 实例化对象，继承后有最上层父类的初始化方法，需要传三个参数&lt;/span&gt;
phone1 = HonorPorPhone(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;荣耀手机&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Honor20pro&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;￥3599&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
phone1.phone_info()
phone1.phone_func()    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 调用最上层父类的方法（子类创建出来的对象能访问所有父类的实例方法）&lt;/span&gt;
phone1.honor_func()   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 调用父类的方法&lt;/span&gt;
phone1.new_func()   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 调用自己的方法&lt;/span&gt;
&lt;span&gt;
phone2 &lt;/span&gt;= HonorPhone(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;荣耀手机&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Honor20&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;￥2999&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 作为HonorPorPhone类的父类，创建出来的对象不能访问子类（即HonorPorPhone类）的实例方法，不能往下访问&lt;/span&gt;
phone2.new_func()     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 因此这里运行会报错&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
C:\software\python\python.exe D:/learn/python18_http_request/exercise/&lt;span&gt;test.py
您的手机品牌是荣耀手机，型号Honor20pro，价格￥&lt;/span&gt;3599&lt;span&gt;
这款手机是触屏手机
这款手机是智能手机
这款手机有红外线功能
这款手机有nfc功能
这款手机支持HiFi
这款手机可以玩mobile游戏
这款手机支持应用分屏
这款手机支持30倍变焦
Traceback (most recent call last):
  File &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D:/learn/python18_http_request/exercise/test.py&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, line 62, &lt;span&gt;in&lt;/span&gt; &amp;lt;module&amp;gt;&lt;span&gt;
    phone2.new_func()&lt;/span&gt;
AttributeError: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;HonorPhone&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; object has no attribute &lt;span&gt;'&lt;/span&gt;&lt;span&gt;new_func&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

Process finished with exit code &lt;/span&gt;1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调用父类的属性也是如此，这里就不再举例了。&lt;/p&gt;

&lt;h3&gt;3.子类中调用重名的父类方法&lt;/h3&gt;
&lt;p&gt;　　子类不仅仅可以调用父类的方法，也可以重写父类的方法再重新调用，简单来说在子类中写一个与父类同名的方法，并且也沿用父类方法里的代码，&lt;/p&gt;
&lt;p&gt;只是在父类方法基础上再增加一些代码，&lt;span class=&quot;md-plain&quot;&gt;子类重写了父类的方法后，再调用父类方法的方式有两种：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding:utf8 -*-&lt;/span&gt;
&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
=================================
    Time    : 2019/10/8 21:04
    Author  : miki_peng
    Email   : 307325534@qq.com
    File    : day12_class_object.py
==================================
&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 继承：在python3的继承中，所有的类都默认继承自object这个父类（基础类）&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 两种写法都默认继承object类&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; class Phone:&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;     pass&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; class BasePhone(object):&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;     pass&lt;/span&gt;


&lt;span&gt;class&lt;/span&gt;&lt;span&gt; BasePhone(object):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;定义一个手机基础类&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, brand, model, price):
        self.brand &lt;/span&gt;=&lt;span&gt; brand
        self.model &lt;/span&gt;=&lt;span&gt; model
        self.price &lt;/span&gt;=&lt;span&gt; price

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; phone_func(self):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;手机功能&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;这款手机是触屏手机&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;这款手机是智能手机&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;这款手机有红外线功能&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;这款手机有nfc功能&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; HonorPhone(BasePhone):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;继承手机基础类，这是荣耀系列手机，基础功能都有&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; phone_info(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;您的手机品牌是{}，型号{}，价格{}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(self.brand,self.model,self.price))

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; phone_func(self):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;重写父类的手机功能方法，在这基础上增加一个功能&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;这款手机有双摄像头&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; BasePhone.phone_func(self)  # 重写父类同名方法后，再调用父类的方法   第一种方式&lt;/span&gt;
        super().phone_func()    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 重写父类同名方法后，再调用父类的方法   第二种方式(常用)&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; honor_func(self):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;荣耀功能&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;这款手机支持HiFi&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;这款手机可以玩mobile游戏&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;这款手机支持应用分屏&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; BetaPhone(BasePhone):    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这个类没有重写父类的手机功能方法&lt;/span&gt;
    &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;继承手机基础类，这是Beta系列手机，有基础功能&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; phone_info(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;您的手机品牌是{}，型号{}，价格{}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(self.brand,self.model,self.price))

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; new_func(self):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;新功能&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;这款手机支持30倍变焦&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 实例化对象，继承后有最上层父类的初始化方法，需要传三个参数&lt;/span&gt;
phone1 = HonorPhone(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;荣耀手机&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Honor20&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;￥2999&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
phone1.phone_info()
phone1.phone_func()    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 调用父类的方法&lt;/span&gt;
phone1.honor_func()   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 调用自己的方法&lt;/span&gt;

&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-------------分割线------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
phone2 &lt;/span&gt;= BetaPhone(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Beta手机&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Beta8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;￥3299&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
phone2.phone_info()
phone2.phone_func()
phone2.new_func()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
C:\software\python\python.exe D:/learn/python18_http_request/exercise/&lt;span&gt;test.py
您的手机品牌是荣耀手机，型号Honor20，价格￥&lt;/span&gt;2999&lt;span&gt;
这款手机有双摄像头
这款手机是触屏手机
这款手机是智能手机
这款手机有红外线功能
这款手机有nfc功能
这款手机支持HiFi
这款手机可以玩mobile游戏
这款手机支持应用分屏
&lt;/span&gt;-------------分割线------------&lt;span&gt;
您的手机品牌是Beta手机，型号Beta8，价格￥&lt;/span&gt;3299&lt;span&gt;
这款手机是触屏手机
这款手机是智能手机
这款手机有红外线功能
这款手机有nfc功能
这款手机支持30倍变焦

Process finished with exit code 0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;重写父类方法后也可以不再调用父类方法，相当于把重名的方法重新写一遍，如果觉得理解不了，自己多敲几遍，举一反三练习一下吧！&lt;/p&gt;


&lt;p&gt;作者：miki_peng&lt;/p&gt;
&lt;p&gt;出处：&lt;a href=&quot;https://www.cnblogs.com/miki-peng&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/miki-peng&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，请大家尊重原创，如要转载，请在文章页面明显位置注明出处，否则保留追究法律责任的权利。&lt;/p&gt;
</description>
<pubDate>Wed, 29 Jan 2020 12:25:00 +0000</pubDate>
<dc:creator>miki_peng</dc:creator>
<og:description>前言：本文主要介绍python面对对象中的类和继承，包括类方法、静态方法、只读属性、继承等。 一、类方法 1.类方法定义 使用装饰器@classmethod装饰，且第一个参数必须是当前类对象，该参数名</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/miki-peng/p/12241177.html</dc:identifier>
</item>
<item>
<title>机器学习-TensorFlow建模过程  Linear Regression线性拟合应用 - HappyPuppy</title>
<link>http://www.cnblogs.com/tangxiaobo199181/p/12241170.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tangxiaobo199181/p/12241170.html</guid>
<description>&lt;p&gt;TensorFlow是咱们机器学习领域非常常用的一个组件，它在数据处理，模型建立，模型验证等等关于机器学习方面的领域都有很好的表现，前面的一节我已经简单介绍了一下TensorFlow里面基础的数据结构即：Tensor和Dataset； 这里咱们开始介绍TensorFlow的建模过程以及验证模型的一些简单方法。其实无论是sklearn还是TensorFlow，他们的模型建立过程都是相似的，都是经历columns类型声明，模型定义，数据训练，validation等等几个步骤。前面的几节内容我已经简单的介绍了如何用sklearn建立tree_based模型，这里我主要是想演示TensorFlow的应用，所以我就用linear regressor来当做例子来演示TensorFlow是如何从数据加载一直到数据验证的阶段。至于线性拟合的实现的具体细节，我在下一节的内容会从数学的角度具体解释的。本节内容所使用的数据都是来自于网络中，大家可以忽略具体的数据的意思，主要的了解TensorFlow的应用过程，不必过于纠结于模型的细节部分，模型的细节我会在随后的章节解释。好了，那么咱们现在开始吧&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一步：数据准备&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;顾名思义，就是咱们准备数据的过程，这里包括有missing value handling， categorical data encoding，data split， data permutation等等内容，这一步咱们要将咱们将来模型训练所用到的数据都能准备好。这个准备过程无非也就是上面的这些步骤，咱们可以看下面的代码演示&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
cali_housing_dataset_original = pd.read_csv(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://download.mlcc.google.com/mledu-datasets/california_housing_train.csv&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
cali_housing_dataset_original[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;median_house_value&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] /= 1000.0
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;create a random generator&lt;/span&gt;
generator =&lt;span&gt; np.random.Generator(np.random.PCG64())
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;permutate the data frame&lt;/span&gt;
cali_housing_dataset_permutation =&lt;span&gt; cali_housing_dataset_original.reindex(
        generator.permutation(cali_housing_dataset_original.index)
        )
cali_housing_dataset_permutation.describe()

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;select the features that we will use in the model trainning process&lt;/span&gt;
my_feature = cali_housing_dataset_permutation[[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;total_rooms&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]]
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;select the targets of the dataset&lt;/span&gt;
targets = cali_housing_dataset_permutation[[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;median_house_value&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里我就不演示那些feature engineering的过程，那些内容太多，大家可以看我之前的博客，这里主要是想向大家演示一下permutation的过程。因为最新的numpy对于randomize的过程已经有更新了，不再使用的那些老的API了，numpy中最新的randomize的过程是通过创建2个generator来实现随机过程和随机数的生成了，这两个generator一个个是bit generator, 就如咱们上面代码中的PCG64(), 它能产生一个随机的bit stream, 根据numpy的官方文档，虽然有很多种bit generator，但是PCG64是最稳定的一种；另外一个就是Generator, 它是通过np.random.Generator()函数来实例化一个对象的，它能将bit generator产生的bit stream转化成数字。这里的数据咱们就选择一个最最简单的linear regression的方式，那就是只选择一个feature，那就是total_rooms; 咱们的target是median_house_value。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二步：定义feature 类型 和 optimizer&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 既然咱们的数据都准备好了，那么之后那么得定义一下咱们数据的类型（每一个column的类型都得定义），将来在咱们定义模型的时候咱们也得将columns的信息传递给咱们的模型对象；以及用什么optimizer将来来训练咱们的模型，这个optimizer将来也得传递给咱们的模型对象。&lt;strong&gt; &lt;/strong&gt;具体optimizer是什么我下面会慢慢讲的。为了方便演示，还是先上代码给大家看&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;indicates what is the data type of the feature to tensorflow&lt;/span&gt;
feature_columns = [tf.feature_column.numeric_column(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;total_rooms&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]&lt;br/&gt;&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;using stochastic gradient descent as the optimizer for our model&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;to ensure the magtitute of gradient do not become too large, we apply clipping_norm to our optimizer&lt;/span&gt;
my_optimizer = tf.optimizers.SGD(learning_rate = 0.0000001, clipnorm=5.0)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从上面的代码可以看出，第一句是声明咱们feature_columns里面只有一个numeric_column，记住每一个column都有一个feature_column对象，这里因为咱们只选取了一个feature是total_rooms，所以咱们这里就一个tf.feature_column对象。这里的第二行代码是咱们的重点，也是以后优化模型中经常要调整的部分，这里咱们可以看出，这里的optimizer是一个SGD， SGD是stochastic gradient descent的缩写，就是每一次计算咱们的gradient descent的时候，咱们只选取一组数据进行计算，如果每一次计算gradient descent的时候咱们都用整个数据进行计算，那么咱们的计算机是负担不起的，消耗的存储空间和计算能力都太大了，因为在实际中咱们的数据集的数量经常都是以万为单位的。具体计算gradient descent的过程我会在下一节中讲述模型训练过程中演示的。咱们可以看出来，SGD中还有两个参数，分别是learning_rate和clipnorm, 咱们知道，当我们在训练我们的模型的时候，我们需要逐步的训练很多次，知道咱们的gradient descent趋于0是才停止，咱们的每一步的大小都要合理，如果learning_rate太小，咱们训练的步数就会太多，影响咱们的效率；如果learning_rate太大，则可能导致咱们训练模型的过程不能converge，就是永远找不到那个最小值，从而导致训练的模型失败；为了防止咱们咱们的gradient太大，我们这里不单单用learning_rate来限制，咱们还加了一个clipnorm来限制咱们的gradient magtitute大小，防止咱们fail to converge, 这相当于一个双重保险。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第三步：定义一个模型model&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将上面的参数都定义完成后，咱们就得定义一下咱们的模型啦，TensorFlow提供了大量的模型可供使用，几乎所有主流的机器学习的模型和深度学习相关的模型，TensorFlow几乎实现全覆盖了，具体咱们可以去他的官网查询, 他的官网地址是：&lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf&quot;&gt;https://www.tensorflow.org/api_docs/python/tf&lt;/a&gt;  ，记住在TensorFlow中，他的模型都在tf.estimator这个模块中。因为这里是咱们讲述用TensorFlow开发机器学习应用的入门，咱们就选一个最简单的模型linear regressor模型来演示&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
linear_regressor =&lt;span&gt; tf.estimator.LinearRegressor(
        feature_columns &lt;/span&gt;=&lt;span&gt; feature_columns,
        optimizer &lt;/span&gt;=&lt;span&gt; my_optimizer
        )&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里咱们可以看出是如何初始化一个LinearRegressor对象的，同样的，咱们可以看出来它初始化的时候也是需要传递feature_columns和optimizer这2个参数的，而这两个参数正是咱们第二步中所初始化的，可以说是环环相扣啊，哈哈，也可以看出咱们前面定义初始化的一个对象都是没有多余的，都是要用到的。这两个参数分别告诉了咱们的模型咱们数据columns的类型以及用什么optimizer来训练这2个信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第四步：数据源input_fn&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;既然咱们的原始数据准备好了，模型也都定义好了，如果需要训练咱们的模型，咱们还差什么呢？对了就是将咱们的原始数据（这里的例子是dataframe）转化成TensorFlow中的dataset，并将转化后的data传递给咱们的模型，让咱们之前定义的模型用这些数据去训练。这里应该也是咱们用TensorFlow来建模的一个核心部分了，咱们先看代码演示，然后我会逐个详细解释的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt; my_input(features, targets, batch_size=500, shuffle=True, num_epochs=&lt;span&gt;None):
    
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    epochs: while trainning, in the case of steps is larger than the length of dataset, we set the epochs to None, which means repeat forever. However,
    in trainning process, we have the steps to control the total number of iterations.  While in the case of making predictions of a given dataset, we must
    set epochs to 1 and shuffle to False. Because we only want the input function return the dataset once, otherwise the function will keep returnning the 
    results forvere once and once again.
    
    shuffle: in the trainning process, in order to balance the dataset, we set it to True. However while in prediction process, we have to set it to False, which
    could help us to evaluate the outputs. For example, if the outputs are shuffled, we have no way to compare the outputs to our original lables.
    
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;convert panda dataframe to a dict of Numpy array&lt;/span&gt;
    features = {key:tf.multiply(np.array(value),1) &lt;span&gt;for&lt;/span&gt; key,value &lt;span&gt;in&lt;/span&gt;&lt;span&gt; dict(features).items()}
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;construct a dataset&lt;/span&gt;
    ds =&lt;span&gt; tf.data.Dataset.from_tensor_slices((features,targets))
    ds &lt;/span&gt;=&lt;span&gt; ds.batch(batch_size).repeat(num_epochs)
    
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; shuffle:
        ds &lt;/span&gt;= ds.shuffle(buffer_size = 10000&lt;span&gt;)    &lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; ds
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里有几个核心的参数我需要解释一下，首先features和target两个参数很明显就是咱们第一步中获取的数据，分别是用来训练这个模型的特征变量和label；重点这里解释一下batch_size, shuffle 和 num_epochs这三个参数，这三个参数在咱们TensorFlow的整个学习过程中都得用到，绝对的重点，不容怀疑。首先咱们来看batch_size, 因为SGD每一次都只会选用一条数据来计算咱们的gradient（训练模型），而咱们的数据具有很强的随机性，那么就会导致咱们的模型最后很可能不可用，但是如果咱们每一个step都选用整个dataset来训练模型，又会导致咱们的训练过程非常漫长，那么聪明的人类就自然而然的想到了咱们可以每一次选用一定数量的数据来训练模型，一般的数据量咱们大致的范围都是在10-10000之间，这种方式就成为mini-batch SGD, 在这里咱们就是采用了这种方式，咱们每一次选用500条数据来训练咱们的模型，这是通过设置batch_size的值来实现的。对于shuffle这个参数呢，也是为了打乱咱们的数据来进行训练，最终的目的也是为了能帮助咱们训练出更加精确的模型，防止咱们的数据分布不合理导致模型有偏差，它里面的buffer_size的意思是先从ds中选中buffer_size个数据（这些数据暂时还是有序的，顺序和ds中一样），然后iterate的时候呢，就从这个buffer中随机的选择数据（这个选择数据的过程就是无序的选择了，实现了随机的目的）。最后还有这个repeat(num_epochs)的函数，首先repeat函数在training的过程中一定需要的，因为当咱们设置steps步数参数的时候，如果steps的总数要多余整个dataset的数据量的时候，那么这时候咱们一定得重复利用咱们的dataset来达到训练的目的，否则咱们的数据源的数据量不够了，会出错的，这就是为什么需要repeat的原因，至于num_epochs是来控制重复的次数的，一般在training阶段咱们将它设置成None, 意思就是无限循环，知道training中的steps全部走完位置，如果在predict阶段，咱们一般就设置成1，因为咱们验证阶段不需要重复的，同样的在predict的时候，数据源函数中的shuffle也要设置成False的，否则predict的结果都是乱序的，无法跟原来的数据进行对比了。前面几个参数在咱们模型训练过程中可以说是最重要的参数了，这里说的也比较多，所以一点得用心搞明白。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第五步：训练模型 training&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;既然上面咱们把模型的参数都设置好了，数据源也定义好了，那么接下来咱们的任务就是训练咱们定义的模型了，这个过程在代码中是很简单的，但它内部做的工作是很多的，它需要计算在每个维度（feature）上的gradient descent，知道它趋于0为止，它的计算细节我会在接下来的一个章节中展示出来，咱们先看代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;linear_regressor.train(
        input_fn &lt;/span&gt;= &lt;span&gt;lambda&lt;/span&gt;&lt;span&gt;:my_input(my_feature, targets),
        steps &lt;/span&gt;= 1000&lt;span&gt;
        )&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;是不是很简单，咱们只需要将数据源函数作为参数传递给他，并且设置一个steps就可以了。这里input_fn我就不解释了，简单说一下steps，steps指的是咱们训练的步数，咱们每计算一次gradient descent，就算一步，这里指咱们最多计算1000次，即使1000的时候gradient descent不等于0咱也停止咱的训练过程，然后咱们可以重新设置optimizer中的learning_rate来重新训练。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第六步：predict和evaluate&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;经过前面五步后，咱们已经训练出来了一个模型，那么接下来咱们需要用这个模型来预测一下数据，并且看看它的效果，去evaluate一下这个模型。正常的情况下咱们会将数据split成training data 和 validation data，这里我为了方便，咱就直接用training data来演示如何predict还有如何evaluate咱们的模型。简单的代码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;create a input function for prediction&lt;/span&gt;
prediction_input_fn = &lt;span&gt;lambda&lt;/span&gt;:my_input(my_feature,targets,shuffle=False,num_epochs=1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;prediction&lt;/span&gt;
predictions = linear_regressor.predict(input_fn =&lt;span&gt; prediction_input_fn)
predictions &lt;/span&gt;= np.array([item[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;predictions&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;][0] &lt;span&gt;for&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; predictions])

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;errors MSE&lt;/span&gt;
mean_squared_error(targets,predictions)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在咱们做prediction的时候，咱们也是需要数据源input_fn的，在prediction的时候，shuffle=False, num_epochs=1; 然后调用这个模型linear_regressor的predict方法，将数据源函数传递给他， 它返回的结果是一个list，这个list里面的element是一个dictionary，这个dictionary的key值“predictions”, value也是一个一个list，并且只有一个元素element，此element就是咱们要的结果。最后咱们要evaluate这个模型预测的结果，咱们有很多种方式可以验证，这里只展示了一个最简单的方式，就是计算咱们的target和prediction的方差，其实有很多很多种方式，在后面的章节我会慢慢介绍。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第七步：data visualization&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;好了，最后咱们来看一下根据咱们的学习的模型，咱们想看看它的具体的拟合的效果，这里就需要用一点之前咱们学习的数据可视化的内容了，这里比较简单，咱们通过模型学习到的参数，画一条拟合线，然后在将数据画到画布上，坐标分别是&quot;total_rooms&quot;和&quot;house_median_price&quot;,然后通过scatter plot展示出来。代码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
sample = cali_housing_dataset_permutation.sample(n=300&lt;span&gt;)
x_0 &lt;/span&gt;= sample[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;total_rooms&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;].min()
x_1 &lt;/span&gt;= sample[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;total_rooms&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;].max()
linear_regressor.get_variable_names()&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;retrieve the name of the variable&lt;/span&gt;
weights = linear_regressor.get_variable_value(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;linear/linear_model/total_rooms/weights&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)[0]&lt;span&gt;#&lt;/span&gt;&lt;span&gt;returns the value of variable given by name&lt;/span&gt;
bias = linear_regressor.get_variable_value(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;linear/linear_model/bias_weights&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;retruns the value of bias&lt;/span&gt;
y_0 = weights*x_0+&lt;span&gt;bias
y_1 &lt;/span&gt;= weights*x_1+&lt;span&gt;bias
plt.plot([x_0,x_1],[y_0,y_1])&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;plot our regression line&lt;/span&gt;
plt.ylabel(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;median_house_value&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;label the y Axes&lt;/span&gt;
plt.xlabel(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;total_rooms&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;label the x Axes&lt;/span&gt;
plt.scatter(sample[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;total_rooms&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;],sample[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;median_house_value&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;])&lt;span&gt;#&lt;/span&gt;&lt;span&gt;plot a scatter plot from the sample&lt;/span&gt;
plt.show()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1287224/202001/1287224-20200129200535003-950923965.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 可以看得出来，拟合的还不错。嘿嘿，关于模型训练过程的可视化，后面还有很多种，以后我慢慢说，例如：x坐标是steps, y坐标是loss, 也是非常常见的一种方式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;今天完整的展示了用TensorFlow创建模型的整个过程，一直从data preparation到最后的evaluation，可以说贯穿了TensorFlow开发机器学习应用的整个过程。今天先用一个最简单的线性拟合例子展示这个过程，后面我还会展示更多的更加复杂的模型，例如：Logistic Regression, DNN, LSTM，等等等等。但是万变不离其宗，他们的基础步骤都是上面的七个步骤。最后 ，祝武汉加油！！！！！！！！&lt;/p&gt;
</description>
<pubDate>Wed, 29 Jan 2020 12:13:00 +0000</pubDate>
<dc:creator>HappyPuppy</dc:creator>
<og:description>TensorFlow是咱们机器学习领域非常常用的一个组件，它在数据处理，模型建立，模型验证等等关于机器学习方面的领域都有很好的表现，前面的一节我已经简单介绍了一下TensorFlow里面基础的数据结构</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tangxiaobo199181/p/12241170.html</dc:identifier>
</item>
</channel>
</rss>