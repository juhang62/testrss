<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>飞控遥控器原型 - McKay</title>
<link>http://www.cnblogs.com/aarond/p/flycontroller.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/aarond/p/flycontroller.html</guid>
<description>&lt;p&gt;最近打算折腾飞控，找了找资料和淘宝，发现一个飞控遥控器都要500起步，实在莫名奇妙，研究了下，没啥新奇，就自己做吧&lt;/p&gt;
&lt;p&gt;看看效果，只是原型，还要做PCB，目前尺寸还是很占空间的。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;遥控器：1个arduino UNO+2个旋转电位器开关+1个2.4G信号发射器+1块面包板&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接收端：1个LED灯+1个舵机+1个arduino UNO+1个2.4G信号接收器+1块面包板&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/68230/201902/68230-20190202030340852-1722327665.gif&quot; alt=&quot;&quot; width=&quot;533&quot; height=&quot;400&quot;/&gt;&lt;/p&gt;
&lt;p&gt;元器件都是能买到的，单算遥控器端的话，成本在30-40之间。&lt;/p&gt;
&lt;h3&gt;遥控器代码：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
#include &amp;lt;SPI.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;Mirf.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;nRF24L01.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;MirfHardwareSpiDriver.h&amp;gt;



&lt;span&gt;void&lt;/span&gt;&lt;span&gt; setup() {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; put your setup code here, to run once:&lt;/span&gt;
  Serial.begin(&lt;span&gt;9600&lt;/span&gt;&lt;span&gt;);

  Mirf.cePin &lt;/span&gt;= &lt;span&gt;9&lt;/span&gt;;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置CE引脚为D9&lt;/span&gt;
  Mirf.csnPin = &lt;span&gt;10&lt;/span&gt;;               &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置CE引脚为D10&lt;/span&gt;
  Mirf.spi = &amp;amp;MirfHardwareSpi;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;加载24L01  SPI&lt;/span&gt;
  Mirf.init();                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化nRF24L01&lt;/span&gt;
&lt;span&gt;
  Mirf.setRADDR((&lt;/span&gt;&lt;span&gt;byte&lt;/span&gt; *)&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;contr&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
  Mirf.payload &lt;/span&gt;= &lt;span&gt;2&lt;/span&gt; * &lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;);
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送通道，可以填0~128，收发必须一致。&lt;/span&gt;
  Mirf.channel = &lt;span&gt;3&lt;/span&gt;&lt;span&gt;;
  Mirf.config();
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里标识写入了Sender.ino&lt;/span&gt;
  Serial.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;I'm controller...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; loop() {
  &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; targetValue1=&lt;span&gt;analogRead(A0);
  &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; targetValue2=&lt;span&gt;analogRead(A1);
  &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; adaptedValue1=map(targetValue1, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1024&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;500&lt;/span&gt;&lt;span&gt;);
  &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; adaptedValue2=map(targetValue2, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1024&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;181&lt;/span&gt;&lt;span&gt;);


  send_data((&lt;/span&gt;&lt;span&gt;byte&lt;/span&gt; *)&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;react&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, adaptedValue1, adaptedValue2);
  delay(&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;);
  
  
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; send_data(&lt;span&gt;byte&lt;/span&gt; * targetName, &lt;span&gt;int&lt;/span&gt; dt1, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; dt2)
{
  &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt; data[Mirf.payload];
  data[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;] =&lt;span&gt; dt1;
  data[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] =&lt;span&gt; dt2;

  Mirf.setTADDR(targetName);
  Mirf.send(data);
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Mirf.send((byte *)&amp;amp;dt);
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;while死循环等待发送完毕，才能进行下一步操作。
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Serial.println(&quot;--&amp;gt;&quot;);&lt;/span&gt;
  &lt;span&gt;while&lt;/span&gt;&lt;span&gt; (Mirf.isSending()) 
  {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Serial.print(&quot;.&quot;);&lt;/span&gt;
      delay(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
  }

  Serial.print(data[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]);
  Serial.print(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
  Serial.print(data[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]);
  Serial.println(&lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;);
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Serial.println(&quot;OK&quot;);&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;接收端：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
#include &amp;lt;SPI.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;Mirf.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;nRF24L01.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;MirfHardwareSpiDriver.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;Servo.h&amp;gt;&lt;span&gt;

Servo myservo;

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; setup() {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; put your setup code here, to run once:&lt;/span&gt;
  Serial.begin(&lt;span&gt;9600&lt;/span&gt;&lt;span&gt;);
  pinMode(&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;, OUTPUT);

  myservo.attach(&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;&lt;span&gt;);

  Mirf.cePin &lt;/span&gt;= &lt;span&gt;4&lt;/span&gt;;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置CE引脚为D4&lt;/span&gt;
  Mirf.csnPin = &lt;span&gt;10&lt;/span&gt;;               &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置CE引脚为D10&lt;/span&gt;
  Mirf.spi = &amp;amp;MirfHardwareSpi;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;加载24L01  SPI&lt;/span&gt;
  Mirf.init();                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化nRF24L01&lt;/span&gt;
&lt;span&gt;
  Mirf.setRADDR((&lt;/span&gt;&lt;span&gt;byte&lt;/span&gt; *)&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;react&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
  Mirf.payload &lt;/span&gt;= &lt;span&gt;2&lt;/span&gt; * &lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;);
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送通道，可以填0~128，收发必须一致。&lt;/span&gt;
  Mirf.channel = &lt;span&gt;3&lt;/span&gt;&lt;span&gt;;
  Mirf.config();
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里标识写入了Sender.ino&lt;/span&gt;
  Serial.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;I'm reactor...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; dt1=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; dt2=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; loop() {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; put your main code here, to run repeatedly:&lt;/span&gt;
  &lt;span&gt;byte&lt;/span&gt;&lt;span&gt; data[Mirf.payload];
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (Mirf.dataReady())   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;等待接收数据准备好&lt;/span&gt;
&lt;span&gt;  {
    Mirf.getData(data);    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;接收数据到data数组&lt;/span&gt;
    dt1 = (&lt;span&gt;int&lt;/span&gt;)data[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];
    dt2 &lt;/span&gt;= (&lt;span&gt;int&lt;/span&gt;)data[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
    Serial.print(dt1);
    Serial.print(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    Serial.print(dt2);
    Serial.println(&lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;);
  }
  
  output_pwm(&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;, dt1);
  myservo.write(dt2);
}


&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; output_pwm(&lt;span&gt;int&lt;/span&gt; pin, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; pwm)
{
  &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; highTime=map(pwm, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;500&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1000&lt;/span&gt;&lt;span&gt;);
  &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; lowTime=&lt;span&gt;1000&lt;/span&gt;-&lt;span&gt;highTime;
  
  digitalWrite(pin, HIGH);
  delayMicroseconds(highTime);
  
  digitalWrite(pin, LOW);
  delayMicroseconds(lowTime);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;2.4信号发射器接法（接入arduino UNO）型号是nRF24L01，淘宝上卖7块钱1个，要完成本实验的话，需要至少2个，1个发，1个收，型号一模一样就可以。&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/68230/201902/68230-20190202030944047-42978737.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;arduino UNO,淘宝卖大约是20一块&lt;/h3&gt;
&lt;h3&gt;旋转电位器，淘宝卖5块一个，在arduino中读取模拟值&lt;/h3&gt;
&lt;p&gt;综上所述，其实就是把2个模拟值（分别来源于2个旋转电位器）放入byte[] 数组中，用2.4G发送出去（类似&lt;a href=&quot;http://nicekwell.net/blog/20161223/ppmxin-hao-jie-shao.html&quot; target=&quot;_blank&quot;&gt;PPM&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;用到的库函数文件下载地址：&lt;a href=&quot;https://files.cnblogs.com/files/aarond/Arduino%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F-%E5%BA%93%E5%87%BD%E6%95%B0.rar&quot; target=&quot;_blank&quot;&gt;Arduino驱动程序-库函数.rar&lt;/a&gt;&lt;a href=&quot;https://files.cnblogs.com/files/aarond/Arduino%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F-%E5%BA%93%E5%87%BD%E6%95%B0.rar&quot; target=&quot;_blank&quot;&gt;&lt;br/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;好了，后续再迭代。&lt;/p&gt;

</description>
<pubDate>Fri, 01 Feb 2019 19:31:00 +0000</pubDate>
<dc:creator>McKay</dc:creator>
<og:description>最近打算折腾飞控，找了找资料和淘宝，发现一个飞控遥控器都要500起步，实在莫名奇妙，研究了下，没啥新奇，就自己做吧 看看效果，只是原型，还要做PCB，目前尺寸还是很占空间的。 遥控器：1个arduin</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/aarond/p/flycontroller.html</dc:identifier>
</item>
<item>
<title>由优劣语言之争引起的思考 - 溪源More</title>
<link>http://www.cnblogs.com/xiyuanMore/p/10347346.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiyuanMore/p/10347346.html</guid>
<description>&lt;h2 align=&quot;center&quot;&gt;#欲使其灭亡，必使其疯狂&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;         昨天上午由阿里云中间件公众号和架构师小秘圈公众号发布的一篇文章《天天敲代码会使人变聪明么》在.net开发者中掀起了一阵巨浪，文章中提到的语言的先进与落后之争让基于.net开发者们义愤填膺，不少嫉恶如仇的开发者纷纷前往公众号去谴责作者的这种行为。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;         作为高级工程师和架构师圈子里有着出色影响力的优秀公众号，在公开场合发表这种充满意识形态的争议性文字，实属罕见，我觉得应该是小编未能注意到作者在正文的某个角落夹杂着的个人观点引起的疏漏。在读者在公众号后台留言之后，编辑很快就对内容进行了修改，于是很快原文就看不到这段令人不适的文字了。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;         互联网时代，任何意识形态之争或语言优劣之争，都只是图一时的口舌之快。优秀的开发语言也好，开发者也好，都应该拥有一颗博大的胸怀，时刻怀揣着用技术改变生活的梦想，用心去体会开发语言的妙处。我觉得，没有最优秀的开发语言，只有最适合的开发语言，就像有人喜欢吃甜椒，有人喜欢吃辣椒一般，没有必要因为自己的喜好，就讽刺别人的爱好。而只要是能解决问题的开发语言，都可以成为是开发优秀的语言。也从来没有什么优秀的语言能够使大脑聪明的道理，任何运用得当的开发语言或者技术，都会让精神愉悦。Java也好,.C#也罢，都是开发者们用来解决问题的工具。平和、包容、开放的心态，跳跃敏捷的思维方式，是我们解决问题的法宝。而那些抱着狭隘技术心态、自以为是的开发者，不过徒增笑柄而已。&lt;/p&gt;
&lt;h2 align=&quot;center&quot;&gt;       #平台开发VS业务系统开发&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;　　在这个事情的背后，我觉得或许反应的是某些狭隘的平台开发者（或中间件）对于业务开发者的鄙视链。随着互联网的飞速发展和工作岗位职责的进一步细分，也让平台开发者与业务开发者之间的技术体系变得截然不同。尤其是近年来PaaS市场的风起云涌，更是让平台开发者成为时代的宠儿。最近看到有人分享的蚂蚁金服面试经，&lt;a href=&quot;https://github.com/aylei/interview%20&quot; target=&quot;_blank&quot;&gt;查看原文&lt;/a&gt;。在这篇文字中，我们可以看到，作为平台开发者所需要掌握的技术体系，无论是go语言，或者k8s这些，都需要非常深入的了解。 而平台开发者必须深刻领悟当今时代最先进技术的发展方向和技术的技术深度，才能应对平台建设过程中所带来的挑战。而这种挑战也同样引起了IT产业技术非常深远的变革，DevOps的盛行就是这个典型的案例。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;     而业务开发者也同样促进了行业的进步和时代的发展。与平台开发者相比，业务应用开发者的知识体系则相对不同，更侧重于将技术灵活的运用到实际产品的开发过程中。经常可以在博客园看到一些专家的分享，讨论技术中方方面面的细节。之前看到路过秋天的分享，&lt;a href=&quot;https://www.cnblogs.com/cyq1162/p/9073634.html&quot; target=&quot;_blank&quot;&gt;查看原文&lt;/a&gt;，作者介绍了他招聘架构师过程中遇到的一些常见的现象，实际上值得所有高级.NET工程师关注。随着时代的变迁，优秀的开发者关注的重点，应该不仅仅只是在业务范围内，有时候对业务系统、技术的每个细节都应该了如指掌，形成的是一整套完善的知识体系。事实上，像路过秋天这样的顶尖开发者所拥有的技术层次让我这个十年经验的开发者一阵冷汗。在过去若干年的项目开发过程中，由于太过于在乎业务细节的实现，而忽略了对于技术本质的探索，导致了我的知识体系看起来广大，实际上不过是浮在水面上的薄冰，触之即碎、太阳一晒就一点不留。甚至不留情面的说，与真正浸淫其道的专家眼里，这种仅仅停留在皮毛表面的技术积累，不过是小学生水平。 &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　坦率来说，对于.NET技术而言，从某种意义上来讲，面临的是最差的时代。由于.NET技术主要的应用场景是各类业务系统的开发过程，虽然.NET技术的开发成本和开发效率相较于其他平台来说有不错的优势，在前期能够让企业开发者以最快的速度完成系统的建设，但是在互联网飞速发展的时代，由于高昂的windows授权费用和深度与windows的高度绑定等众多原因，让这些应用只能局限于互联网企业的非线上系统之中，鲜有胆大的企业把他应用在互联网的系统中，在加上.NET开发者梯队构成的原因，最终让大量优秀的企业纷纷选择了Java。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　头部玩家们的背离，跟随者们的抛弃，让.NET技术逐渐丧失了天时、地利、人和，终于与时代脱节。&lt;/p&gt;
&lt;h2 align=&quot;center&quot;&gt;      .NET Core助力传统产业转型&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;       即便如此，.NET作为一款优秀的语言体系，在面向B端的传统软件开发领域，有着广阔的市场拥趸，在传统产业的信息化系统中占比非常大的比重。例如，许多制造业巨头或者零售业巨头，其制造信息化系统或仓储物流管理系统往往会使用.NET构建。 &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　作为旧时代IT企业的代表，微软实际上一直处于被误读的状态。微软一直以来对社区秉承着开放的理念。犹记得多少年前听雷军讲过，他认为最伟大的IT企业，非微软莫属。哪怕是昔日金山的wps软件曾经占据了中国的半壁江山，让微软的office一度措手不及，微软也从来不会发起什么3Q大战，让用户二者择一。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　而微软一直以来对开发者非常的亲和，除了微软之外，也几乎找不到其他公司能够把帮助文档写得像MSDN这么详细。而微软新任CEO纳德拉提出的“云为先”的战略以及.NET Core技术的诞生，我们可以看到微软放下了心理的包袱，以更加包容的心态来迎接本该属于他的成功。而当下传统产业的互联网转型，必将迎来.NET Core发展的新契机。 作为传统.NET技术开发者们，目前是入手.NET Core的时机了。2019年，.NET 社区以及.NET Core技术将迎来一波巨大的社区红利，让我们期待2019年的到来。　　&lt;/p&gt;
</description>
<pubDate>Fri, 01 Feb 2019 16:01:00 +0000</pubDate>
<dc:creator>溪源More</dc:creator>
<og:description>由优劣语言之争引起的思考 #欲使其灭亡，必使其疯狂 昨天上午由阿里云中间件公众号和架构师小秘圈公众号发布的一篇文章《天天敲代码会使人变聪明么》在.net开发者中掀起了一阵巨浪，文章中提到的语言的先进与</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiyuanMore/p/10347346.html</dc:identifier>
</item>
<item>
<title>（数据科学学习手札54）Python中retry的简单用法 - 费弗里</title>
<link>http://www.cnblogs.com/feffery/p/10347348.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/feffery/p/10347348.html</guid>
<description>&lt;p&gt;&lt;span&gt;一、简介&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　retry是一个用于错误处理的模块，功能类似try-except，但更加快捷方便，本文就将简单地介绍一下retry的基本用法。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;二、基本用法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;retry&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　作为装饰器进行使用，不传入参数时功能如下例所示：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; retry &lt;span&gt;import&lt;/span&gt;&lt;span&gt; retry

@retry()
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; demo():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;错误&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;raise&lt;/span&gt;&lt;span&gt;

demo()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　我们编写了每次运行都会通过raise报错的自定义函数demo()，利用默认参数的retry()进行装饰，运行结果如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1344061/201902/1344061-20190201231337553-1428367993.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　可以看到，retry()在这里的功能，是在其装饰的函数运行报错后重新运行该函数，在上例中的效果就是反复运行demo()，这也是retry()的基本用法，下面介绍其几个主要参数：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;exceptions：传入指定的错误类型，默认为Exception，即捕获所有类型的错误，也可传入元组形式的多种指定错误类型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;tries：定义捕获错误之后重复运行次数，默认为-1，即为无数次&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;delay：定义每次重复运行之间的停顿时长，单位秒，默认为0，即无停顿&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;backoff：呈指数增长的每次重复运行之间的停顿时长，需要配合delay来使用，譬如delay设置为3，backoff设置为2，则第一次间隔为3*2**0=&lt;/span&gt;&lt;span&gt;1秒，第二次3*2**1=2秒，第三次3*2**2=4秒，以此类推，默认为1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;max_delay：定义backoff和delay配合下出现的等待时间上限，当delay*backoff**n大于max_delay时，等待间隔固定为该值而不再增长&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　下面我们通过几个直观的例子来更加深刻地认识上述参数：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; retry &lt;span&gt;import&lt;/span&gt;&lt;span&gt; retry

&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;记录初始时刻&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
start_time &lt;/span&gt;=&lt;span&gt; time.clock()


@retry(delay&lt;/span&gt;=1,tries=4,backoff=2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; demo(start_time):
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;将当前时刻与初始时刻的时间差（单位：S）作差并四舍五入&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(round(time.clock()-&lt;span&gt;start_time,0))
    &lt;/span&gt;&lt;span&gt;raise&lt;/span&gt;&lt;span&gt;

demo(start_time)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　在上例中，我们设置delay为1，tries为4，backoff为2，通过我们的自定义函数来记录每次重复运行与初始时刻的时间差，这样第一次与第二次间隔时间为1*2**0=1，第二次与第三次间隔为1*2**1=2，第三次与第四次间隔4，运行结果如下，到达预定的运行状况后程序就会报错从而终止运行：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1344061/201902/1344061-20190201234602589-1601935008.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　符合我们上面的计算结果，下面我们设置一个较小的max_delay：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; retry &lt;span&gt;import&lt;/span&gt;&lt;span&gt; retry

&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;记录初始时刻&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
start_time &lt;/span&gt;=&lt;span&gt; time.clock()


@retry(delay&lt;/span&gt;=1,tries=10,backoff=2,max_delay=20&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; demo(start_time):
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;将当前时刻与初始时刻的时间差（单位：S）作差并四舍五入&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(round(time.clock()-&lt;span&gt;start_time,0))
    &lt;/span&gt;&lt;span&gt;raise&lt;/span&gt;&lt;span&gt;

demo(start_time)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　运行结果如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1344061/201902/1344061-20190201235122348-960852571.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　可以看到，在delay和backoff共同控制下的间隔时长超过20秒后，之后的每一次间隔时长都固定为20秒，直到所有的tries运行结束。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　利用retry，我们可以在譬如网络爬虫过程中更加简洁灵活地控制错误处理过程，使得代码具有更好的可读性，以上就是本文的基本内容，如有笔误，望指出。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 01 Feb 2019 15:54:00 +0000</pubDate>
<dc:creator>费弗里</dc:creator>
<og:description>一、简介 retry是一个用于错误处理的模块，功能类似try-except，但更加快捷方便，本文就将简单地介绍一下retry的基本用法。 二、基本用法 retry: 作为装饰器进行使用，不传入参数时功</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/feffery/p/10347348.html</dc:identifier>
</item>
<item>
<title>数组作为函数参数 - 巫师笔记</title>
<link>http://www.cnblogs.com/lvfengkun/p/10347339.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lvfengkun/p/10347339.html</guid>
<description>&lt;p&gt;数组可以作为函数的参数使用，进行数据传送。数组作为函数参数有两种形式。&lt;/p&gt;
&lt;p&gt;（1）把元素作为实参使用。&lt;/p&gt;
&lt;p&gt;（2）把数组名作为函数的形参和实参使用。&lt;/p&gt;
&lt;p&gt;1、数组元素作为函数实参&lt;/p&gt;
&lt;p&gt;数组元素就是下标变量，它与普通变量并无区别。因此它作为函数实参使用与普通变量是完全相同的，在发生函数调用时，把作为实参的数组元素的值传递给形参，实现单向的值传递。&lt;/p&gt;
&lt;p&gt;例：判别一个整数数组a[10]={1,2,3,4,-1,-2,-3,-4,2,3}中个元素的值，若大于0，则输出该值，若小于等于0，则输出0。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
#include &amp;lt;stdafx.h&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;stdio.h&amp;gt;

&lt;span&gt;void&lt;/span&gt; test(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; v);
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; a[&lt;span&gt;10&lt;/span&gt;]={&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,-&lt;span&gt;1&lt;/span&gt;,-&lt;span&gt;2&lt;/span&gt;,-&lt;span&gt;3&lt;/span&gt;,-&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;&lt;span&gt;};
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;=&lt;span&gt;10&lt;/span&gt;;i++&lt;span&gt;)
    {
        test(a[i]);
    }
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
}
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; test(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; v)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(v&amp;gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
    {
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,v);
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    {
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、数组名作为函数参数&lt;/p&gt;
&lt;p&gt;注：（1）与数组元素作为函数参数不同的是，用数组名作为函数参数时，要求形参与相对应的实参都必须是类型相同的数组，否则会发生错误。&lt;/p&gt;
&lt;p&gt;（2）用数组名作为函数参数时，并不是进行值的传递，即不是把实参数组的每一个元素的值都赋与形参数组的各个元素。因为实际上形参数组并不存在，编译系统并不为形参数组分配内存。&lt;/p&gt;
&lt;p&gt;数据的传递：数组名就是数组的首地址。因此在数组名作为函数参数时所进行的传递只是地址的传递，也就是说把实参数组的首地址赋予形参数组名。形参数组名取得该首地址之后，也等于有了实际的数组，即实参与形参有一段共用的内存空间。&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
#include &amp;lt;stdafx.h&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;stdio.h&amp;gt;

&lt;span&gt;void&lt;/span&gt; test (&lt;span&gt;int&lt;/span&gt; b[&lt;span&gt;10&lt;/span&gt;&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; a[&lt;span&gt;10&lt;/span&gt;]={&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;,&lt;span&gt;8&lt;/span&gt;,&lt;span&gt;10&lt;/span&gt;,&lt;span&gt;12&lt;/span&gt;,&lt;span&gt;14&lt;/span&gt;,&lt;span&gt;16&lt;/span&gt;,&lt;span&gt;18&lt;/span&gt;,&lt;span&gt;20&lt;/span&gt;&lt;span&gt;};
    test(a);
    putchar(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
}
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; test (&lt;span&gt;int&lt;/span&gt; b[&lt;span&gt;10&lt;/span&gt;&lt;span&gt;])
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(;i&amp;lt;&lt;span&gt;10&lt;/span&gt;;i++&lt;span&gt;)
    {
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%6d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,b[i]);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;例：有一个一维数组score，内放10个学生成绩，求平均成绩。（写一个average函数获取平均成绩）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
#include &amp;lt;stdafx.h&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;stdio.h&amp;gt;

&lt;span&gt;double&lt;/span&gt; average(&lt;span&gt;double&lt;/span&gt; array[&lt;span&gt;10&lt;/span&gt;]);&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;函数声明&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; score[&lt;span&gt;10&lt;/span&gt;]={&lt;span&gt;82&lt;/span&gt;,&lt;span&gt;100&lt;/span&gt;,&lt;span&gt;55&lt;/span&gt;,&lt;span&gt;80&lt;/span&gt;,&lt;span&gt;64&lt;/span&gt;,&lt;span&gt;78&lt;/span&gt;,&lt;span&gt;26&lt;/span&gt;,&lt;span&gt;65&lt;/span&gt;,&lt;span&gt;36&lt;/span&gt;,&lt;span&gt;85&lt;/span&gt;&lt;span&gt;},result;
    result&lt;/span&gt;=&lt;span&gt;average(score);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%lf\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,result);
}

&lt;/span&gt;&lt;span&gt;double&lt;/span&gt; average(&lt;span&gt;double&lt;/span&gt; array[&lt;span&gt;10&lt;/span&gt;&lt;span&gt;])
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i;
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; f=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;=&lt;span&gt;9&lt;/span&gt;;i++&lt;span&gt;)
    {
        f&lt;/span&gt;+=&lt;span&gt;array[i];
    }
    f &lt;/span&gt;/= &lt;span&gt;10&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (f);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Fri, 01 Feb 2019 15:50:00 +0000</pubDate>
<dc:creator>巫师笔记</dc:creator>
<og:description>数组可以作为函数的参数使用，进行数据传送。数组作为函数参数有两种形式。 （1）把元素作为实参使用。 （2）把数组名作为函数的形参和实参使用。 1、数组元素作为函数实参 数组元素就是下标变量，它与普通变</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lvfengkun/p/10347339.html</dc:identifier>
</item>
<item>
<title>java 11 值得关注的新特性 - 西北野狼</title>
<link>http://www.cnblogs.com/androidsuperman/p/10347327.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/androidsuperman/p/10347327.html</guid>
<description>&lt;p&gt;JEP 181: Nest-Based Access Control 基于嵌套的访问控制&lt;/p&gt;
&lt;p&gt;JEP 309: Dynamic Class-File Constants 动态类文件&lt;/p&gt;
&lt;p&gt;JEP 315: Improve Aarch64 Intrinsics 改进 Aarch64 的效率&lt;/p&gt;
&lt;p&gt;JEP 318: Epsilon: A No-Op Garbage Collector 无任何操作的垃圾收集器Epsilon（实验性质）&lt;/p&gt;
&lt;p&gt;JEP 320: Remove the Java EE and CORBA Modules 删除Java EE 和CORBA模块&lt;/p&gt;
&lt;p&gt;JEP 321: HTTP Client (Standard) http客户端标准api&lt;/p&gt;
&lt;p&gt;JEP 323: Local-Variable Syntax for Lambda Parameters 局部变量的lambda表达式&lt;/p&gt;
&lt;p&gt;JEP 324: Key Agreement with Curve25519 and Curve448 新增Curve25519和Curve448加密算法&lt;/p&gt;
&lt;p&gt;JEP 327: Unicode 10&lt;/p&gt;
&lt;p&gt;JEP 328: Flight Recorder 飞行记录仪，记录虚拟机内部运作细节&lt;/p&gt;
&lt;p&gt;JEP 329: ChaCha20 and Poly1305 Cryptographic Algorithms 加密算法&lt;/p&gt;
&lt;p&gt;JEP 330: Launch Single-File Source-Code Programs 源程序直接执行&lt;/p&gt;
&lt;p&gt;JEP 331: Low-Overhead Heap Profiling 低成本的堆分析&lt;/p&gt;
&lt;p&gt;JEP 332: Transport Layer Security (TLS) 1.3 安全方面的更新&lt;/p&gt;
&lt;p&gt;JEP 333: ZGC: A Scalable Low-Latency Garbage Collector (Experimental)&lt;/p&gt;
&lt;p&gt;ZGC: 可扩展的低延迟垃圾收集器（实验性质）&lt;/p&gt;
&lt;p&gt;JEP 335: Deprecate the Nashorn JavaScript Engine Nashorn JavaScript废弃掉&lt;/p&gt;
&lt;p&gt;JEP 336: Deprecate the Pack200 Tools and API 压缩工具废弃&lt;/p&gt;
</description>
<pubDate>Fri, 01 Feb 2019 15:44:00 +0000</pubDate>
<dc:creator>西北野狼</dc:creator>
<og:description>JEP 181: Nest Based Access Control 基于嵌套的访问控制 JEP 309: Dynamic Class File Constants 动态类文件 JEP 315: Im</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/androidsuperman/p/10347327.html</dc:identifier>
</item>
<item>
<title>XGBoost小记 - 0xCAFE</title>
<link>http://www.cnblogs.com/0xcafe/p/10347304.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/0xcafe/p/10347304.html</guid>
<description>&lt;p&gt;//TODO&lt;/p&gt;

&lt;h2&gt;2.1输入&lt;/h2&gt;
&lt;p&gt;数据的特征分为两类，一类是连续型，比如：体重，一种是分类型，比如性别。&lt;/p&gt;
&lt;p&gt;在scikit-learn中的Glossary of Common Terms and API Elements有这么一段话：&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Categorical Feature&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;A categorical or nominal feature is one that has a finite set of discrete values across the population of data. These are commonly represented as columns of integers or strings. Strings will be rejected by most scikit-learn estimators, and integers will be treated as ordinal or count-valued. For the use with most estimators, categorical variables should be one-hot encoded. &lt;span&gt;Notable exceptions include tree-based models such as random forests and gradient boosting models that often work better and faster with integer-coded categorical variables.&lt;/span&gt; OrdinalEncoder helps encoding string-valued categorical features as ordinal integers, and OneHotEncoder can be used to one-hot encode categorical features. See also Encoding categorical features and the http://contrib.scikit-learn.org/categorical-encoding package for tools related to encoding categorical features.&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;大意是在利用基于树的模型训练时推荐使用数值编码而不是one-hot编码。&lt;/p&gt;
&lt;p&gt;详情：https://scikit-learn.org/stable/glossary.html#glossary&lt;/p&gt;
&lt;h2&gt;2.2输出&lt;/h2&gt;
&lt;p&gt;在这里只说两点：multi:softmax和multi:softprob，官方文档是这么说的：&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;span&gt;multi:softmax: set XGBoost to do multiclass classification using the softmax objective, you also need to set num_class(number of classes)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;multi:softprob: same as softmax, but output a vector of ndata * nclass, which can be further reshaped to ndata * nclass matrix. The result contains predicted probability of each data point belonging to each class.&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在这里略坑，建立model时无论填哪一个，在model fit之后，打印模型时参数却都是multi:softprob，但是predict的结果也和上述解释也不一致，结果是multi:softmax的结果，只有预测的标签，没有概率分布。&lt;/p&gt;
&lt;p&gt;官方代码如下：可见num_class也是不用设置的，objective被强制替换成了multi:softprob.最后若想输出概率分布请用predict_proba函数来预测.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
self.classes_ =&lt;span&gt; np.unique(y)
self.n_classes_ &lt;/span&gt;=&lt;span&gt; len(self.classes_)

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; self.n_classes_ &amp;gt; 2&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Switch to using a multiclass objective in the underlying XGB instance&lt;/span&gt;
            xgb_options[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;objective&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;multi:softprob&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
            xgb_options[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;num_class&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = self.n_classes_
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;//TODO&lt;/p&gt;
</description>
<pubDate>Fri, 01 Feb 2019 15:28:00 +0000</pubDate>
<dc:creator>0xCAFE</dc:creator>
<og:description>1.原理 //TODO 2.Python Package Scikit-Learn API 2.1输入 数据的特征分为两类，一类是连续型，比如：体重，一种是分类型，比如性别。 在scikit-lear</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/0xcafe/p/10347304.html</dc:identifier>
</item>
<item>
<title>微信为什么要搞一个小游戏？ - 石桥码农</title>
<link>http://www.cnblogs.com/sban/p/10347071.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sban/p/10347071.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/567788/201902/567788-20190201212425836-1341291777.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;众厂关于 H5 游戏市场的争夺，自 2014 年以来，一直就没有停止过。但一直也没有尘埃落定，最终花落谁家，鹿死谁手现在还不好讲。微信推出小程序，继而推出小游戏，只是腾讯数年来在 H5 市场企业战略的一环。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;微信为什么要自定义一套技术，起名为小程序？明明就是原来的 H5 技术，为什么 CSS 不叫 CSS，叫 WXSS；为什么 HTML 不叫 HTML，叫 WXML；为什么明明有 JS、TS，还要自主研发一个 WXS，并且声称“WXS 与 JS 是不同的语言，有自己的语法，并不和 JS 一致”、“在 iOS 设备上小程序内的 WXS 会比传统 JS 代码快 2 ~ 20 倍”。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;这一切固然有技术革新、提升效率的考量，但从商业竞争上考虑，也是为了获得话语权，以便掌握更多市场主动权。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;目录&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;一、关于H5&lt;/p&gt;
&lt;p&gt;1.1，H5兴起的原因&lt;/p&gt;
&lt;p&gt;1.2，H5游戏的技术缺陷&lt;/p&gt;
&lt;p&gt;二、关于H5的市场争夺，腾讯一直在做&lt;/p&gt;
&lt;p&gt;三、关于微信小程序/小游戏的兴起&lt;/p&gt;
&lt;p&gt;3.1，资本对小游戏的看法&lt;/p&gt;
&lt;p&gt;3.2，激烈竞争的小游戏生态&lt;/p&gt;
&lt;p&gt;3.3，第三方开发引擎对小游戏的支持&lt;/p&gt;
&lt;p&gt;3.4，微信对小游戏开发者的支持&lt;/p&gt;
&lt;p&gt;3.5，微信对小游戏开发者的限制&lt;/p&gt;
&lt;p&gt;四、个人应该开发什么类型的小程序？&lt;/p&gt;
&lt;p&gt;4.1，从《围住神经猫》看，轻度社交类是首选&lt;/p&gt;
&lt;p&gt;4.2，从2015年曾经火爆的产品来看，重度游戏难以持久&lt;/p&gt;
&lt;p&gt;4.3，后H5时代留下来的都是什么游戏类型&lt;/p&gt;
&lt;p&gt;4.4，适合个人开发的只有休闲社交游戏，但并不是所有都适合&lt;/p&gt;
&lt;p&gt;4.5，从哪里学习小游戏的创意&lt;/p&gt;
&lt;p&gt;五，企业应该开发什么类型的小程序？&lt;/p&gt;
&lt;p&gt;六、小游戏如何盈利？&lt;/p&gt;
&lt;p&gt;6.1，小游戏的盈利模式有哪些&lt;/p&gt;
&lt;p&gt;6.2，个人开发者的希望在哪里？&lt;/p&gt;
&lt;p&gt;七、小游戏如何推广？&lt;/p&gt;
&lt;p&gt;入、微信为什么不做一个小程序/小游戏应用中心？&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;hr/&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;一、关于 H5&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;一切都要从 H 5说起。H5 是 HTML5 的简称，HTML5 是 HTML 最新的修订版本，起订于 2013 年，于 2014 年正式颁布。H5 已经不是一门简单的标识性语言，而是一项综合技术，除了最基本的JS、CSS、HTML之外，还提供音频、视频、图像动画（包括硬件加速）、本地存储等各种浏览器宿主接口。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;1.1，H5 兴起的原因&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;H5 的兴起，不是哪个大厂独立策划和运营的效果，而是由众多平台、公司在全球互联网市场经济的相互作用下自然发展的结果。可以从以下四个方面总结H5 兴起的原因。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;（1）从市场角度看 H5 兴起&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;最早尝试新技术的公司，他们最先应用 H5 技术制作出了炫酷的互动页面。市场人员为了推广效果，在客户面前会将自家技术夸大，市场营销人员的吹嘘，促进了 H5 技术的传播。凡是看到过H5页面效果的客户，他们也会要求自家技术人员实现同样的效果。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;产品是最好的名片，效果是最好的宣传单。使用 H5 制作响应式互动页面，催生了一批 H5 制作公司，例如易企秀、人人秀、MAKA、百度H5、腾讯玉兔、腾讯风铃、搜狐快站、京东密享等。新的技术总是意味着新的机遇，就连百度、腾讯这样的大公司，也参与了新技术的角逐。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;（2）从原 App 的缺陷看 H5 兴起&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic3.zhimg.com/80/v2-e2197fe12771d543e1dc128012ee3702_hd.jpg&quot; alt=&quot;&quot; width=&quot;366&quot; height=&quot;244&quot; data-caption=&quot;&quot; data-size=&quot;small&quot; data-rawwidth=&quot;600&quot; data-rawheight=&quot;400&quot; data-original=&quot;https://pic3.zhimg.com/v2-e2197fe12771d543e1dc128012ee3702_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-e2197fe12771d543e1dc128012ee3702_b.jpg&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;经过 5 年的秘密研发，2007 年 1 月 9 日，乔布斯在 Macworld 发布会上宣布，“我们重新定义了手机”。乔布斯不但是重新定义了手机，还改变了人们进行电子娱乐的方式。在 iPhone 之前，人们在任天堂、索尼等游戏机上玩游戏，购买的是设备和介质；在 iPhone 之后，人们只需要花很少的钱，就可以随时随地玩无限多的游戏。手机内存虽然不是无限大，但可以删除、重新下载新游戏。iPhone 革的是传统游戏厂商的命。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;2008 年 7 月 11 日，App Store 上线。3 天后，App Store 就迎来了 800 个应用，和一千万人次的下载。在 iPhone 初期，所有风靡一时的好游戏都是单机版，例如《愤怒的小鸟》《水果忍者》等。因为那时候无线网络不发达，户外只有2G网络，Wifi 只存在于办公室、家里和街上少量的咖啡馆里。人们需要通过 Wifi 或通过 iTunes 软件在电脑上下载、安装 App。那个时候，下载和安装 App 并不是一件麻烦事，而且还是一件幸福的事。它帮用户节省了流量。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;但事情很快就发生了变化。2015 年，在国内伴随着国务院印发《关于加快宽带网络建设推进网络提速降费的指导意见》，4G网络很快在中国城市里得到了普及。原来只在单机版领域耕耘的游戏开发商，继而转战手机网游，这时期诞生了一批质量不错的手游，如网易的《阴阳师》、腾讯的《王者荣耀》等。大厂的杀入，意味着研发成本和推广成本的飙升。单用户获客成本，由原来的几块钱迅速上升到了几十块钱甚至一百多块。竞争如此白炽化，小公司已经没有机会进入了。创业团队和独立游戏开发者，只能另觅出路。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;这个时候，H5 进入了开发者的视野。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;早在 2011 年，国外 Mozilla 公司的沙利文就在一篇科技报道中预言，App 没有未来，Web App 才是未来。这里的 Web App，即使用 H5 技术开发的微站应用。沙利文的理由主要有以下三点：一、开发 App 要适配 Android、iOS 等多个系统，学习多门技术，这是反人类的；二，开发一个 Navtive App（相比Web App，原来的 App 称之为 Native App）的成本，可以开发 3 ~ 10 个 Web App；三，虽然 Web App 与 Native App 的体验还有些差距，但这只是时间问题。随着手机硬件性能的提升，差距会越来越小。沙利文预言，Web App 的真正爆发，只差一个合适而完备的商业模式。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;2014 年，手游和端游都已是红海，H5 游戏尚是蓝海。使用H5开发游戏成本低，做一个 App 手游的钱可以做 10 个 H5 游戏，创业者第一个试水项目都乐于从 H5 技术入手。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;2016 年，DCloud CEO 王安曾表示，在电商转化场景中 H5 具有天生的优势。例如，当用户看到一个电商广告，想下单购买。但需要扫码 -&amp;gt; 下载 App -&amp;gt; 安装 -&amp;gt; 注册 -&amp;gt; 付费，这个流程太繁琐了，成单率低。但如果是微页面，只需扫码 -&amp;gt; 秒开 H5 页面 -&amp;gt; 付费，流程就会顺畅许多，成单率高。这个想法，一年以后张小龙用微信小程序实现了，无须下载，扫码即用，用完即走。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;（3）从原 HTML 技术的缺陷看 H5 兴起&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;在 H5 之前，HTML 是没有办法播放视频和处理动画的，这一切都需要通过 Adobe 的 Flash 技术完成。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;2010 年，苹果 CEO 乔布斯发表了一篇文章：“Thoughts on Flash（对 Flash 的想法）”，将 Adobe Flash Player 的性能和潜在安全问题暴露在开发者面前。乔布斯给 Adobe CEO 打电话解决问题，被拒接。乔布斯认为 Adobe 根本没有解决软件工程问题的意愿，遂决定 iPhone 浏览器不再支持 Flash。后来的事实证明，乔布斯的决定是正确的。其它 Android 手机虽然支持 Flash，但性能表现不佳。当然当时 Android 手机的性能普遍表现不佳，某一点表现不佳并不明显。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;在当时音视频网站已经相当普及。2005 创立的 Youtube，在 2010 年每日视频浏览量已经达到了 20 亿次。这些视频都是以 Flash 技术播放的。包括其它使用 Flash 技术开发的页游、社游、视频直播网站等互联网产品形态，迫切需要有一个新技术替代 Flash。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;事实上 H5 新增的音视频功能，及 Canvas 绘图 Api 很好的替代了 Flash 技术在 PC 互联网时代扮演的角色。当下除了教育行业使用 AIR 研发教育产品，广告业公司使用 Flash CS 制作广告片之外，已经很少有开发者使用 Flash 技术了。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;（4）从 SaaS 的发展看 H5 兴起&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;Saas 是 Software as a Service 的缩写，中文软件即服务。这是一种通过 Internet 提供软件服务的模式，用户不用再购买软件，而改用向提供商租用基于 Web 的软件，来管理企业经营活动，且无需对软件进行日常维护。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;木疙瘩 CEO 王志认为，HTML5 真正会带来革命性变化的是它会让很多软件云端化。王志认为，90% 的软件以后不再是客户端软件了，将会变成服务在浏览器就可以使用。这个变化基于两点：一，H5 带来了这种能力，它允许开发者访问硬盘，允许调数据库、摄像头、地图等，它把浏览器的功能极大扩展了；二，云计算和 4G 网络的发展，催生了 SaaS 的发展。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;1.2，H5 游戏的技术缺陷&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;当然，H5 也不是没有缺点。自 2014年《围住神经猫》火爆以后，H5 游戏一直被寄予重望，期待其成为新风口。但几年过去了，H5 游戏一直不温不火。偶尔海面泛起的涟漪，撑不起一众游戏开发者海盗的野心。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;H5 游戏一般在手机 App 内或在浏览器内打开，网络不好时，加载页面需要十几秒，体验非常不好。并且 H5 游戏没有办法全屏，很多时候都要带一着多余的 App 导航条。有时候在横屏模式下，一个顶部导航占去了差不多 50% 的屏幕，很影响玩家体验。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;H5 游戏开发商普通认为，目前 H5 尚存在以下三个问题：一，兼容性。并不是所有手机都支持 WebGL 加速；二，安全性。所有页面源码都像在裸奔，精心打造的精致页面很容易被山寨团队抄袭；三、性能问题。虽然差距越来越小，但在某些 Android 低端机上，H5 页面还是会很卡顿。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;二、关于 H5 的市场争夺，腾讯一直在做&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;自 2015 年 H5 游戏市场爆出千万流水的产品之后，腾讯一直在布局 H5 市场，并且是内部多个部门同时在做。腾讯主要是以下三个平台：&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;（1）QQ 游戏中心&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;在移动 QQ 游戏中心中， 有一个独立类目，叫秒玩专区。该类目下所有产品均为 H5 游戏，目前共有 5 款：《欢乐消消消》、《保卫萝卜迅玩版》、《欢乐斗地主 H5》、《全民大乐斗》以及《爱消除乐园》。每款产品都堪称重磅，而《欢乐消消消》和《爱消除乐园》，均为休闲品类中用户量最大，接受最广泛的消除类产品。这些游戏无论是在美术品质、还是用户体验方面都堪称精品之作。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;为什么叫秒玩专区，因为单局时间短，符合网民时间日益碎片化的生活特点。消除类游戏虽然为都市青年喜爱，是最佳H5游戏类型，但腾讯做了，个人开发者和小微团队就不要做了。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;（2）QQ 厘米游戏平台&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;在 2016 年 7 月发布的厘米秀，已经推出过不少 H5 小游戏，包括腾讯自研的《厘米 Fly》，《厘米大乱斗》，《欢乐斗地主》等。其中《厘米 Fly》单产品存量用户已达 1.2 亿。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;腾讯在“厘米游戏开放平台发布会”上，称厘米游戏平台是一个互动平台。腾讯集团副总裁殷宇表示，“游戏正逐渐成为年轻人主流的一种社交方式”。由此可见，腾讯将“社交”作为 H5 游戏市场的突破点。在厘米平台上，游戏多为时长较短的轻度竞技游戏。这对开发者的启示是，在腾讯平台做游戏产品，互动是关键，社交是灵魂。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;（3）QQ 空间玩吧&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;在 2017 年 4 月召开的以“开放·成长”为主题的 QQ 空间 H5 游戏大会上，腾讯公司副总裁梁柱指出，QQ 空间 H5 小游戏整体运营向“轻量级、休闲类，容易上手方向”发展。QQ 空间玩吧接入的产品主要为休闲益智、策略经营，社交桌游，轻度 RPG 等四大类别，数量达几百款。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;在社交平台如何做 H5 游戏，想必开发者都没有腾讯系自家平台理解得深刻。单局时间短、易上手、休闲益智、轻度社交互动等等，如果只有这些类型的 H5 游戏才能腾讯系平台上赚钱，那么腾讯都做了，还需要开发者做什么？&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;三、关于微信小程序 / 小游戏的兴起&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;2017 年 1 月 9 日，在乔布斯发布 iPhone 一代整整十年之后，张小龙在微信公开课发布了小程序。小游戏是小程序的一个特别类目，两者的开发工具和运行环境都是相同的，一年后在微信 6.6.1 的版本更新中推出。如果小程序尚有 UI 框架的束缚（以使小程序产品保持队形整齐），那么小游戏完全可以自由驰骋创意。小程序和小游戏本质上都是 H5 技术的延伸。小游戏虽然名字中有“游戏”二字，但一切不适合用小程序实现的创意，都可以用小游戏实现。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;张小龙实现了 2011 年沙利文预想的合适的商业平台：&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;（1）获客成本低。&lt;/p&gt;
&lt;p&gt;（2）具有强大的跨平台特性。&lt;/p&gt;
&lt;p&gt;（3）具有良好的运行性能。目前与原生 App 尚有差距，但差距在慢慢缩小。&lt;/p&gt;
&lt;p&gt;（4）具有良好的 App 引流转化能力，从小程序中可以直接向 App 跳转。仅此一点，就可能革掉 4399、3366。&lt;/p&gt;
&lt;p&gt;（5）通过小软件包规定和使用离线缓存，解决了传统 Web App 的卡顿问题。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;2018 年 4 月 26 日，在 2018 微信朋友圈小游戏专场活动的现场，微信小游戏团队首次公布了开放后的最新成绩，已发布小游戏达 300 多款，数款小游戏实现总用户规模过亿，多款小游戏单月安卓端流水超千万。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;《跳一跳》是微信开屏推荐的第一款小游戏，从此“玩一个小游戏才是正经事”走入千家万户，原来从不玩游戏的小学生和退体老人也赶热闹，做一做这个正经事。《跳一跳》是 2018 年春节最受用户欢迎的小程序，最高同时在线 2800 万，日活跃用户达到 1.7 亿。美国著名运动品牌耐克在《跳一跳》中投了三天的植入广告，花了 2000 万人民币。《跳一跳》很好的为 H5 游戏开发商打了个样，但开发商如果想再造《跳一跳》的辉煌，几乎是不可能的。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;3.1，资本对小游戏的看法&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;2018 年，金沙江创投董事总经理朱啸虎几乎在其出席的每一场峰会上都要谈到他对“小程序”的看好。朱啸虎表示，“小游戏是最有潜力的领域之一”，“去年（2017年）小程序披露的投资是 7 亿，而今年（2018 年）到 4 月份，这个数字可能已经加了个零，达到了 70 亿”。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;3.2，激烈竞争的小游戏生态&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;据悉，包括腾讯互娱的自研工作室、飞鱼科技、第七大道、掌趣、电魂、三七互娱、西山居、盛大等众多大型游戏厂商都已经上线了自己的微信小游戏，或者处于马上上线和正在研发当中。以《最强弹一弹》《海盗来了》《欢乐球球》等小游戏为例，其日活都在千万级别。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;截至2018年3月，微信小程序的月活跃用户规模已经突破了 4 亿，小游戏数量已经达到了 300 多款，DAU 超过 1000 万的游戏有数款。头脑王者团队的《海盗来了》、腾讯的《欢乐斗地主》和《全民大乐斗》三款游戏月流水已经过千万。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;小游戏研发成本低，获客成本低，资本的鼓动，以及先行者的获利，让开发者们趋之若鹜，像飞蛾奔向小游戏战场。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;前飞鱼游戏的负责人张志斌表示，他正带领着一家小型游戏创业公司 All IN 小游戏，用他的话来说“这是千载难逢的巨大机会，怎么着也得杀进去”。除了手头已经开发了接近半年的休闲动作类小游戏，目前张志斌的团队还在同时进行着多款小游戏的研发，每个项目只有 2 ~ 3 个团队成员参与。对于很多游戏开发商特别是小微团队来说，不需要付出太多成本就可以在一个 10 亿用户的平台上上线新游戏，这在之前是“想都不敢想的事”。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;深圳一家小游戏开发端表示，他们整个办公楼层从事小游戏开发的就有近 20 家，很多时候自家的小游戏刚在微信平台审核通过，几天后就能在平台上看到很多类似的游戏。山寨问题，已经开始损害开发者的热情。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;在北上广深，换皮手游的成本在 80 ~ 150 万之间。这个成本可以做五六款小游戏，并且速度非常快，如果做出来量不错的话还可以给自己的 App 产品导流。对于自研团队，在成功研发多款小游戏后，研发周期与成本都会降低。这是山寨团队的生存之道。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;由于小程序开发门槛低，从事过软件开发的企业都能向这个方向转型，或同时拓展这项业务。做的团队多了，市场价格自然就低，利润被压保。1000 块可以做出一款小游戏，10000 块也可以做出一款小游戏。激烈的竞争，同质化，抄袭和山寨现象，让小游戏平台鱼目混杂，后进场者们感到彷徨，同时又担心错失良机。在欲望面前，大家一样浮躁。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;3.3，第三方开发引擎对小游戏的支持&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;第三方公司也纷纷推出工具套装，开始支持小游戏开发。在 H5 时代就已赫赫有名的三家游戏引擎，均已支持小游戏，它们是：&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;1，Layabox，开发速度快，软件包小，游戏画面品质略低；&lt;/p&gt;
&lt;p&gt;2，白鹭，可以保证品质和软件包大小适当；&lt;/p&gt;
&lt;p&gt;3，Cocos2d，软件包较大，游戏画面品质较高；&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;开发者使用最多的是白鹭。这款从 Adobe 时代进化而来的游戏引擎，在框架结构和 Api 风格上都与原 Adobe Flex 技术很像。该引擎的首席架构师是原 Adobe 平台技术经理马鉴，网名叫 7yue，老闪客都很熟悉这个名字。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;如果技术人员原来会 AS3 编程，开发过页游或社游，现在团队准备上小游戏战场做换皮游戏导游，无疑，白鹭引擎是首选。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;3.4，微信对小游戏开发者的支持&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;微信一直想办法促进开发者加入小游戏生态。自小游戏发布以来，微信每天都在紧锣密鼓地完善开发工具和类库，以给开发者提供更多、更方便的平台功能和技术接口。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;默认微信对所有小游戏的渠道技术费统一按 40% 比例收取。2018 年 4 月 19 日，微信在新一期的小游戏开发者扶持计划中宣布，在 2018 年内，每款小游戏每月安卓内购流水在 50 万元以下（包含 50 万）部分，腾讯收取的 40% 渠道技术服务费将反哺给小游戏开发者，即腾讯不收取此部分的渠道技术服务费 2019 年该反哺政策是否有效，到时再说。不过由于微信与苹果在游戏付费支付方面的条款还没谈妥，iOS 版本小游戏没有内购付费功能，所以微信的反哺计划只集中在 Android 端。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;针对抄袭、盗版等问题，微信官方已正式发布小游戏原创保护措施，将从名称保护，侵权投诉，技术以及运营等多方面来保护游戏开发者的权益。&lt;/p&gt;
&lt;p&gt;微信工作人员李卿表示，“微信小游戏目前还是一个新生事物，作为平台，还是希望能更多地激发开发者去创造，而不是想着去盈利。” 但是作为开发者，生存是第一要务，如果挣不到钱，哪有力气开发游戏呢。毕竟微信给微信员工发了薪资，并没有给开发者发了薪资。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;3.5，微信对小游戏开发者的限制&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;由于技术力量有限，许多小微团队对如何做出H5精品小游戏并没有太大热情，更多寄望于依赖社交网络的病毒传播效应一夜成名。为了促进用户分享，开发者们使用了“复活分享”等许多招术。“复活分享”即是当用户玩游戏没有能量时，将游戏分享至微信群或分享给好友，就可以获得一次重新玩游戏的机会。这一诱导传播的“复活”功能异常疯狂，尤其是 2018 年五一假期期间，复活分享在众多微信群内刷屏。很多微信用户不堪其扰。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;2018 年 5 月 9 日，微信官方发布公告，提醒小游戏拒绝“分享滥用”行为，违规情形将会受到处理。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;小游戏由于开发简单，更多依赖创意与模式取胜，一个好的小游戏被抄袭取代的概率很高。微信通过软件著作权法保护开发者的原创热情。但是只能开发小体量休闲游戏、并且是腾讯系工作室不感兴趣的休闲类型，如何才能保证获取足额的收入呢？申请软著虽然免费，但时间即成本。如果委托代理公司加急申请，也是一笔开支。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;四、个人应该开发什么类型的小程序？&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;4.1，从《围住神经猫》看，轻度社交类是首选&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic4.zhimg.com/80/v2-56d0a6bb8e8122afb5fd31a0ed63712f_hd.jpg&quot; alt=&quot;&quot; width=&quot;269&quot; height=&quot;418&quot; data-caption=&quot;&quot; data-size=&quot;small&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;1676&quot; data-original=&quot;https://pic4.zhimg.com/v2-56d0a6bb8e8122afb5fd31a0ed63712f_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-56d0a6bb8e8122afb5fd31a0ed63712f_b.jpg&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;2014 年，H5 游戏领域出现了一个现象级产品：《围住神经猫》。开发时间一天半，美术一人，程序一人。上线 48 小时，PV 达 1000 多万。3 天时间，500 万用户，1 亿总访问量。“自从得了神经病，整个人精神多了”。这是一款益智休闲小游戏，玩法非常简单，玩家单击 9 x 9 的棋盘，将猫围住中间即赢。玩家热衷在社交网络中分享自己的得分。当时业界凯歌高旋，称《围住神经猫》是中国 H5 游戏产业的转折点。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;2014 年之前，H5 开发的 Web APP 在安卓 4.4 以下版本无法流畅运行，用户体验很差。在当时的 iOS 版本手机中则不存在这种问题。究其原因，是Android 4.4 以下版本内置的 Webview 版本太低，不支持 WebGL 加速技术。从 2013 开始，Android 4.4 以下版本逐步减少，这对 H5 游戏的普及创造了有利条件。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;根据 H5 游戏的特点，哪些游戏更易获得自然传播？一，从网络流量上讲，游戏资源越丰富占用流量越多，限制了用户的使用环境；二，H5 游戏没有长驻桌面，用户留存率低，需要通过社交传播等方式弥补留存率的不足。所以资源包不大，玩法简单，单局时间短，有社交传播能力的游戏，是 H5 游戏的首先题材类型。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;《围住神经猫》就符合这个特点。对于个人开发者或小微团队来讲，如果一款游戏在 1 ~ 3 天内不能上线，这款游戏就不值得投入了。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;4.2，从 2015 年曾经火爆的产品来看，重度游戏难以持久&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;2014 年，据不完全统计，当时有数以百计的开发者纷纷启动H5游戏项目，再加上各大技术服务商、发行商和平台商，整个生态瞬间集中了百亿资本。当时有种说法是，H5 游戏将会是下一个像手游一样的风口。据报导，2015 年 H5 移动游戏市场用户规模达到 1.75 亿人，产品规模超过 3000 款。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;2015 年初，《传奇世界 H5》缔造了 H5 手游月流水 2 千万级的爆款。这款游戏使用白鹭引擎开发，无论付费率、ARPU 等多项数据都已向传统手游看齐。同年 3 月 22 日，全球首款 MMO 与 ARPG 深度结合的 H5 游戏《醉西游》开启首测，该游戏七日留存达 26.79 %。这款采用 Layabox 引擎开发，数据不仅问鼎 H5 游戏行业的数据巅峰，甚至超越绝大多数主流 APP 手游。同年 4 月 12 日，LayaBox曝出产业里程碑级的大作《梦幻家园》，这是首款裸跑性能比肩 App 的大型 H5 游戏，其次留数据为 36.84 %。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;在 2015 年，利益于浏览器中 WebGL 的硬件加速能力，Web App 性能就已经跑赢 Native App。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;不过可惜的是， H5 游戏并没有如约爆发，仍然不温不火。硬件不是问题，缺少一个合适的商业平台。大厂采用的洗量变现玩法终归难以持久。而在这艰苦探索的过程中，不少 H5 游戏厂商还没有迎来春天，就已经在一个个寒冬中夭折。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;传统赚钱的H5游戏，90%都是重度游戏。但短平快、过于轻量化的游戏很难让用户长期沉迷。以前 H5 现象级轻度游戏都会遇到这样的困境：传播链条短，用户会很快产生审美疲劳。但是，即使如此，腾讯几大 H5 游戏平台接入的游戏主要有三个特点：重社交、大IP、精品化。在玩法层面主要以轻度休闲，社交游戏，棋牌桌游为主，刻意避免了传统重度游戏。腾讯在以社交性，弥补 H5 游戏传播链条短、生命周期短、用户留存低的缺点。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;4.3，从后 H5 时代的游戏类型来看，轻度社交是关键&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;2015 年 H5 游戏爆发之后，大厂转去做 App 重度手游了，H5 游戏市场进入后 H5 时代。留下来继续在 H5 游戏市场耕耘的开发者，他们游戏作品有以下特点：&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;（1）时间短。游戏要 1 分钟甚至是 30 秒内可以玩完，神经猫，疯狂手指，数钞票都属于这类。疯狂手指甚至短到了 10 秒。&lt;/p&gt;
&lt;p&gt;（2）简单。能火的都是快餐类游戏，很多都为开发人员所不屑。传播量最大的都是不需要智商的弱智游戏。&lt;/p&gt;
&lt;p&gt;（3）有轻度竞技特征。这部分体现在分数，有的有排行榜。&lt;/p&gt;
&lt;p&gt;（4）蹭热点，拼创意。疯狂手指创意来自于一个工程师，另一工程师开发 1 个小时上线，第二天就快千万流量，创意爆款可遇不可求。房祖名，冰桶则是抓热点事件，通过疯狂手指，黑白格，找你妹等游戏变化得出。&lt;/p&gt;
&lt;p&gt;（5）大多需要种子流量拉动。没有种子流量能火，肯定是运气，神经猫是一个。疯狂手指是由种子流量带动的，大约带了10~20w的流量，这是火的前提。怎么找种子流量？可以找我们轻游戏的聚合平台合作。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;在后 H5 游戏时代，留下来一批小游戏平台公司，例如 4399、3366 等。这些平台通过小游戏向广告端的 App 导流，与开发者共享广告分成。仅靠这一种模式，平台养活了自身，也维系了众多小游戏开发端。但是在微信小游戏进入后，他们将面临没落，因为从小游戏向 App 导流，比之在 PC 上扫码导流方便多了。就流量而言，所有传统小游戏平台加起来，也没有微信的体量大。所以，对于那些仍然混 4399、3366 等小游戏平台的开发商，现在应该转攻微信小游戏了，如果还没行动的话。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;4.4，适合个人开发的只有休闲社交游戏，但并不是所有都适合&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;小游戏对游戏包限制是 4 Mb 以内，这种大小的游戏包只支持轻量游戏。在被问及什么品类的小游戏会表现更好时，微信工作人员李卿表示，玩法是基础，有一些玩法天然就是有很大的潜在用户人群的。游戏品类本身的玩法决定了游戏的用户规模。平台赋予游戏排行榜、关系链等能力，是放大游戏玩法的补充。李卿认为，有着基础玩法的三消类游戏，在获取玩家用户以及与社交属性挂钩上都有着极大优势。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;但是，传统三消类、棋牌类小游戏都在腾讯系工作室做遍了。所以这类游戏，并不建议开发者尝试。相册的游戏题材，即使有信心比腾讯团队做得更好，也要看一看微信发现 -&amp;gt; 游戏页面。在这个页面，列举的都是腾讯系自家游戏。在这个页面列出的游戏，开发者尤其是个人开发者均不需要尝试了。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;4.5，从哪里学习小游戏的创意&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;以下传统游戏平台，都可以经常上去看看，凡腾讯系工作室不感兴趣的、小众的、短期1~3天即可完成开发并上架的题材，都可以尝试。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;（1）爱微游、疯狂游乐场、9G，群黑游戏，1758 等&lt;/p&gt;
&lt;p&gt;（2）68 微，电魂，小伙伴），金榜游戏&lt;/p&gt;
&lt;p&gt;（3）4399，3366，游戏酱紫，7724，核弹头，2144&lt;/p&gt;
&lt;p&gt;（4）鲸鱼游戏，果子游戏，07073&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;五，企业应该开发什么类型的小程序？&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;张小龙说，微信不会做小程序应用商店。“我们不支持纯以分发为目标的第三方平台，不支持导流性质的小游戏（小程序）互跳。我们希望好的小游戏是因用户的认可而涌现，而不是流量运营的结果。”这是微信团队在《致小游戏开发者的一封信》中表明的态度。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;截止到 2018 年 7 月，微信上线的小游戏已经超过 2000 款，这些游戏目前依然分散在微信平台的各个角落，缺乏推广平台。那么，创业团队能不能做游戏盒子？能不能做流量分发平台，为小程序及小游戏做导流生意？答案至少暂时是可以的。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;当年在手游数量膨胀时，一批从业者率先建立了第三方应用商店，以此聚合大量应用。拇指玩、卓易市场、安智市场、机锋市场、应用汇、木蚂蚁等应用商店就是在当时应运而生的。做流量盒子，有成功先例。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;微信虽然一直宣称去中心化，但我们发现腾讯自家也推出了游戏盒子小程序：QQ 游戏盒子、腾讯爱玩盒子等。据悉，目前微信上现已出现 400 多个游戏盒子，并且还在不断增长之中。快乐游戏盒子、逗玩游戏盒子、爱微游游戏盒子、潘多拉游戏盒子、海盗游戏盒子是目前排名前五的微信小游戏游戏盒子。游戏盒子的宣传语是“无需下载、即点即玩的小游戏合集”，“合集”成为了游戏盒子的生存之道。在游戏盒子中，分享好友、收藏盒子等引导功能是普遍存在的，目的是进一步扩大盒子粘性。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;QQ 游戏盒子中分为“精选”、“发现”、“分类”三个大类，囊括了大量小游戏，数量庞大、种类齐全、排列有序，有榜单、有推荐，有热评度，有礼包中心，俨然应用商店。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;如果微信一直不做小程序/小游戏应用商店。对于创业团队，能不能做？可以做，但是不能只局限于小程序、小游戏的聚合分发，也不能只在微信生态下去做。小程序、小游戏的本质仍然是 H5，应该跳出微信的生态，囊括所有 H5 生态产品，支付宝小程序、百度小程序，快应用等，都应该囊括进来。在产品形态上，一定要有自己的 App，从小程序、小游戏中向自己的 App 引流，建立自己独立的品牌。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;如果微信坚持不做小游戏应用商店，那么像 4399、3366 那样，诞生一两个小游戏分发平台是合理的。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;六、小游戏如何盈利？&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;小游戏并没有很强的变现能力。目前大厂在坚持投入，无非是收入大于支出，待红利期过了，游戏开发商们自会转向别处。40% 的渠道费，作者认为太贵了。苹果 App Store 的分成，也仅有三成；并且苹果是允许个人开发者使用支付功能的，接口与企业开发者几无分别。但在小游戏中，个人开发者和企业开发者的权限分别，就大了去了。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;6.1，小游戏的盈利模式有哪些&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;微信小游戏的变现主要有以下4种：&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;（1）广告变现。无论是企业开发者还是个人开发者，都可以使用。&lt;/p&gt;
&lt;p&gt;（2）游戏内付费，这种模式只适合企业开发者，并且目前在 iOS 端尚不可用。&lt;/p&gt;
&lt;p&gt;（3）裂变回收，就是当用户将游戏分享出去时，带上其它产品，向自家产品导流，或打包将流量卖给第三方。&lt;/p&gt;
&lt;p&gt;（4）外包定制。&lt;/p&gt;
&lt;p&gt;（5）直接卖号。每款小游戏的生命周期大约有 6 ~ 8 个月。如果流量运营起来了，可以在第 3 个月的时候，将帐号卖给第三方。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;据悉，有公司在做从小游戏向 H5 游戏导量，已经做到了 3000 万流水。但导流对个人来讲，并不适合。广告模式和直接卖号，是适合个人开发者和小微团队的变现方式。据微信工作人员分享，广告收入会支撑住一个小团队自身的生存。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;6.2，个人开发者的希望在哪里？&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;对于个人开发者，如果能够开发出一款类似于《围住神经猫》那样的小游戏，并能创造 1000 万的 UV，那么结合微信广告平台千次展示的广告价格及平均单次单击价格和单击概念，保守估计，可以有 1 ~ 5 万的广告收入。&lt;/p&gt;
&lt;p&gt;而这样的小游戏，只可以花 1 ~ 3 天的时间开发，如果超过这个时间没有完成，说明游戏可能不适合这个平台。至于说每个开发者只能注册 5 个小游戏开发帐号的限制，有其它办法可以解决。例如使用亲友身份注册，或将成名卖给第三方。如果上架后没有火起来，甚至都可以推倒从新开发另一款。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;七、小游戏如何推广？&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;社交分享与排行榜是小游戏推广中的产品利器，但也不能滥用。在 2018 年 5 月过度使用“复活分享”的产品，都被微信勒令整顿了。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;在用户流量获取方面，在 2018 年 2 月份就已经有团队在用网盟买量。成本非常低，15 元可以覆盖 1000 个 2000 人大群，假设只有 1‰ 的转化率也有 2000 的转化。如果企业准备做游戏盒子，可以考虑做这方面的生意。但微信工作人员曾对媒体表示，未来微信有可能自己做买量市场。开发者交线，微信通过各种渠道给游戏导流，额满为止。听起来这不像微信的产品风格，如果微信真这样做，很快个人开发者就没有机会了。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;八、微信为什么不做一个小程序 / 小游戏应用中心？&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;张小龙在微信公开课上一再强调，微信坚持去中心化，微信不会做小程序或小游戏应用商店。为什么？&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;作者认为，微信是从微信整个商业生态上考虑的。微信是一个 App，它拥有朋友圈、公众号、看一看等生态领域，这些领域都是微信为第三方投放广告进行企业变现的地方。如果微信搞了一个小游戏应用商店，那么无疑这个商店就是开发者最大的流量入口，开发者就会争着在这个商店里获得推荐、获得靠前排名，谁还会去广告主平台投放广告呢？&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;做为一个平台，微信必须维持公正公平的基本原则，如果有这个商店，必然不能像百度那样通过竞价排名收费，后果只会造成第三方公司通过各种刷单手段，帮开发者争取高位排名。微信不但一分钱挣不到，还要投入更多的人力物力打击刷单行为。微信为什么要这么做？&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;有了这个商店，微信的广告收入会减少。并且一旦在商店内出现第三方非腾讯系的大流量产品，还面临着微信用户被第三方企业拉走的威胁，到时候以什么理由封杀第三方呢？&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;事实上，在微信 -&amp;gt; 发现导航页，有一个“游戏”分栏，这个页面列举的全是腾讯系游戏产品或与腾讯合作的游戏产品。微信并不是不做商店，是只做自己能完全控制的商店。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;从这点来看，微信的扁平化社交产品模式，比淘宝、京东的瀑布布分类产品模式，更胜一筹。没有情怀，所有的产品设计背后，都是血泪经验。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;微信推出小游戏，只是腾讯在多年H5游戏市场众多企业战略的一坏，相比其它腾讯系H5平台，这一次微信很多可能成功。微信推出小游戏平台，不但与腾讯的总战略契合，还有助于提高各个微信生态的用户粘性和变现能力。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;但是，当年乔布斯推出 iPhone，是重新定义了手机，众多游戏开发者在 App Store 上线游戏，是因为 iPhone 有其它地方没有的硬件能力。张小龙同样选择 1 月 9 日推出小程序，在没有额外的硬件能力加持的前提下，微信如何让开发者留在小游戏平台并保持平台活力？如果微信未来能推出一款微信VR手机，就另当别论了。否则，目前的小游戏平台和 2015 年一样，在火过一阵之后，大厂开发者会退出，留下小微团队和几个流量盒子坚守。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;个人开发者固然可以从中赚到一笔钱，但也不要抱实现财富自由的幻想。尝试做流量盒子的企业，莫要希翼自己一家独大；当微信不做这个生意时，这个生意就变成了一种类型，将被 N 多企业争相瓜分。做为流量盒子，谁也不会一家独大，和小游戏一样，竞争越激烈，从中渔利的只有微信。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;2019年2月1日&lt;/p&gt;
&lt;p&gt;石桥码农&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;本文首发于微信公众号「艺述思维」：&lt;a class=&quot; wrap external&quot; href=&quot;http://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/Tqx0UcGpbT_ltbsRlfmBFA&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot; data-za-detail-view-id=&quot;1043&quot;&gt;微信为什么要搞一个小游戏？&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 01 Feb 2019 13:26:00 +0000</pubDate>
<dc:creator>石桥码农</dc:creator>
<og:description>众厂关于 H5 游戏市场的争夺，自 2014 年以来，一直就没有停止过。但一直也没有尘埃落定，最终花落谁家，鹿死谁手现在还不好讲。微信推出小程序，继而推出小游戏，只是腾讯数年来在 H5 市场企业战略的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sban/p/10347071.html</dc:identifier>
</item>
<item>
<title>【Go】优雅的读取http请求或响应的数据-续 - 戚银</title>
<link>http://www.cnblogs.com/thinkeridea/p/10347026.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/thinkeridea/p/10347026.html</guid>
<description>&lt;p&gt;原文链接：&lt;a href=&quot;https://blog.thinkeridea.com/201902/go/you_ya_de_du_qu_http_qing_qiu_huo_xiang_ying_de_shu_ju_2.html&quot; class=&quot;uri&quot;&gt;https://blog.thinkeridea.com/201902/go/you_ya_de_du_qu_http_qing_qiu_huo_xiang_ying_de_shu_ju_2.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;之前发布 &lt;a href=&quot;https://blog.thinkeridea.com/201901/go/you_ya_de_du_qu_http_qing_qiu_huo_xiang_ying_de_shu_ju.html&quot;&gt;【Go】优雅的读取http请求或响应的数据&lt;/a&gt; 文章，网友 “wxe” 咨询：“优化前后的请求耗时变化有多大”，之前只分析了内存分配，这篇文章用单元测试的方式分析优化前后的耗时情况，&lt;a href=&quot;https://github.com/thinkeridea/example/tree/master/iouitl_readall&quot;&gt;本文源码&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;非常感谢 “wxe” 网友的提问，让我在测试过程中发现一个 &lt;code&gt;json&lt;/code&gt; 序列化的问题。&lt;/p&gt;
&lt;p&gt;之前我们优化了两个部分，&lt;code&gt;json&lt;/code&gt; 与 &lt;code&gt;ioutil.ReadAll&lt;/code&gt;， 先对比 &lt;code&gt;ioutil.ReadAll&lt;/code&gt;, 这里测试的代码分成两个部分做对比，一部分单纯对比 &lt;code&gt;ioutil.ReadAll&lt;/code&gt; 和 &lt;code&gt;io.Copy&lt;/code&gt; + &lt;code&gt;sync.Pool&lt;/code&gt;，另一部分增加 &lt;code&gt;jsoniter.Unmarshal&lt;/code&gt; 来延迟 &lt;code&gt;pool.Put(buffer)&lt;/code&gt; 的执行, &lt;a href=&quot;https://github.com/thinkeridea/example/blob/master/iouitl_readall/io.go&quot;&gt;源码&lt;/a&gt;。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package iouitl_readall

import (
    &quot;bytes&quot;
    &quot;io&quot;
    &quot;io/ioutil&quot;
    &quot;sync&quot;

    jsoniter &quot;github.com/json-iterator/go&quot;
)

var pool = sync.Pool{
    New: func() interface{} {
        return bytes.NewBuffer(make([]byte, 4096))
    },
}

func IoCopyAndJson(r io.Reader) error {
    buffer := pool.Get().(*bytes.Buffer)
    buffer.Reset()
    defer pool.Put(buffer)

    res := Do(r)
    _, err := io.Copy(buffer, res)
    if err != nil {
        return err
    }

    m := map[string]string{}
    err = jsoniter.Unmarshal(buffer.Bytes(), &amp;amp;m)
    return err
}

func IouitlReadAllAndJson(r io.Reader) error {
    res := Do(r)
    data, err := ioutil.ReadAll(res)
    if err != nil {
        return err
    }

    m := map[string]string{}
    err = jsoniter.Unmarshal(data, &amp;amp;m)
    return err
}

func IoCopy(r io.Reader) error {
    buffer := pool.Get().(*bytes.Buffer)
    buffer.Reset()
    defer pool.Put(buffer)

    res := Do(r)
    _, err := io.Copy(buffer, res)
    if err != nil {
        return err
    }

    return err
}

func IouitlReadAll(r io.Reader) error {
    res := Do(r)
    data, err := ioutil.ReadAll(res)
    if err != nil {
        return err
    }
    _ = data
    return err
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试代码如下&lt;a href=&quot;https://github.com/thinkeridea/example/blob/master/iouitl_readall/io_test.go&quot;&gt;源码&lt;/a&gt;:&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package iouitl_readall

import (
    &quot;bytes&quot;
    &quot;testing&quot;
)

var data = bytes.Repeat([]byte(&quot;ABCD&quot;), 1000)

func BenchmarkIouitlReadAll(b *testing.B) {
    b.RunParallel(func(pb *testing.PB) {
        for pb.Next() {
            err := IouitlReadAll(bytes.NewReader(data))
            if err != nil {
                b.Error(err.Error())
            }
        }
    })
}

func BenchmarkIoCopy(b *testing.B) {
    b.RunParallel(func(pb *testing.PB) {
        for pb.Next() {
            err := IoCopy(bytes.NewReader(data))
            if err != nil {
                b.Error(err.Error())
            }
        }
    })
}

func BenchmarkIouitlReadAllAndJson(b *testing.B) {
    b.RunParallel(func(pb *testing.PB) {
        for pb.Next() {
            err := IouitlReadAllAndJson(bytes.NewReader(data))
            if err != nil {
                b.Error(err.Error())
            }
        }
    })
}

func BenchmarkIoCopyAndJson(b *testing.B) {
    b.RunParallel(func(pb *testing.PB) {
        for pb.Next() {
            err := IoCopyAndJson(bytes.NewReader(data))
            if err != nil {
                b.Error(err.Error())
            }
        }
    })
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试结果如下:&lt;/p&gt;
&lt;pre class=&quot;txt&quot;&gt;
&lt;code&gt;goos: darwin
goarch: amd64
pkg: github.com/thinkeridea/example/iouitl_readall
BenchmarkIouitlReadAll-8              500000          2752 ns/op       14496 B/op          6 allocs/op
BenchmarkIoCopy-8                   20000000            65.2 ns/op        48 B/op          1 allocs/op
BenchmarkIouitlReadAllAndJson-8       100000         20022 ns/op       46542 B/op        616 allocs/op
BenchmarkIoCopyAndJson-8              100000         17615 ns/op       32102 B/op        611 allocs/op&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结论：&lt;/p&gt;
&lt;p&gt;可以发现 &lt;code&gt;IoCopy&lt;/code&gt; 方法是 &lt;code&gt;IouitlReadAll&lt;/code&gt; 方法效率的 40 倍，内存分配也很少，而 &lt;code&gt;IoCopyAndJson&lt;/code&gt; 和 &lt;code&gt;IouitlReadAllAndJson&lt;/code&gt; 的效率差异极小仅有 &lt;code&gt;2407ns&lt;/code&gt;，大约是 1.13倍，不过内存分配还是少了很多的，为什么会这样呢，这就是 &lt;code&gt;sync.Pool&lt;/code&gt; 的导致的，&lt;code&gt;sync.Pool&lt;/code&gt; 每次获取使用时间越短，命中率就越高，就可以减少创建新的缓存，这样效率就会大大提高，而 &lt;code&gt;jsoniter.Unmarshal&lt;/code&gt; 很耗时，就导致 &lt;code&gt;sync.Pool&lt;/code&gt; 的命中率降低了，所以性能下降极其明显.&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;io.Copy&lt;/code&gt; + &lt;code&gt;sync.Pool&lt;/code&gt; 表面上执行效率不会有很大提升，但是会大幅度减少内存分配，从而可以减少 &lt;code&gt;GC&lt;/code&gt; 的负担，在单元测试中我们并没有考虑 &lt;code&gt;GC&lt;/code&gt; 的问题，而 &lt;code&gt;GC&lt;/code&gt; 能带来的性能提升会更有优势。&lt;/p&gt;
&lt;p&gt;在看一下 &lt;code&gt;json&lt;/code&gt; 使用 &lt;code&gt;sync.Pool&lt;/code&gt; 的效果吧 &lt;a href=&quot;https://github.com/thinkeridea/example/blob/master/iouitl_readall/json.go&quot;&gt;源码&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package iouitl_readall

import (
    &quot;bytes&quot;
    &quot;encoding/json&quot;

    jsoniter &quot;github.com/json-iterator/go&quot;
)

func Json(r map[string]string) error {
    data, err := json.Marshal(r)
    if err != nil {
        return err
    }

    _ = data
    return nil
}

func JsonPool(r map[string]string) error {
    buffer := pool.Get().(*bytes.Buffer)
    buffer.Reset()
    defer pool.Put(buffer)

    e := json.NewEncoder(buffer)
    err := e.Encode(r)
    if err != nil {
        return err
    }

    return nil
}

func JsonIter(r map[string]string) error {
    data, err := jsoniter.Marshal(r)
    if err != nil {
        return err
    }

    _ = data
    return nil
}

func JsonIterPool(r map[string]string) error {
    buffer := pool.Get().(*bytes.Buffer)
    buffer.Reset()
    defer pool.Put(buffer)

    e := jsoniter.NewEncoder(buffer)
    err := e.Encode(r)
    if err != nil {
        return err
    }

    return nil
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;性能测试代码&lt;a href=&quot;https://github.com/thinkeridea/example/blob/master/iouitl_readall/json_test.go&quot;&gt;源码&lt;/a&gt;:&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package iouitl_readall

import (
    &quot;strconv&quot;
    &quot;strings&quot;
    &quot;testing&quot;
)

var request map[string]string

func init() {
    request = make(map[string]string, 100)
    for i := 0; i &amp;lt; 100; i++ {
        request[&quot;X&quot;+strconv.Itoa(i)] = strings.Repeat(&quot;A&quot;, i/2)
    }
}
func BenchmarkJson(b *testing.B) {
    b.RunParallel(func(pb *testing.PB) {
        for pb.Next() {
            err := Json(request)
            if err != nil {
                b.Error(err.Error())
            }
        }
    })
}

func BenchmarkJsonIter(b *testing.B) {
    b.RunParallel(func(pb *testing.PB) {
        for pb.Next() {
            err := JsonIter(request)
            if err != nil {
                b.Error(err.Error())
            }
        }
    })
}

func BenchmarkJsonPool(b *testing.B) {
    b.RunParallel(func(pb *testing.PB) {
        for pb.Next() {
            err := JsonPool(request)
            if err != nil {
                b.Error(err.Error())
            }
        }
    })
}

func BenchmarkJsonIterPool(b *testing.B) {
    b.RunParallel(func(pb *testing.PB) {
        for pb.Next() {
            err := JsonIterPool(request)
            if err != nil {
                b.Error(err.Error())
            }
        }
    })
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试结果如下:&lt;/p&gt;
&lt;pre class=&quot;txt&quot;&gt;
&lt;code&gt;goos: darwin
goarch: amd64
pkg: github.com/thinkeridea/example/iouitl_readall
BenchmarkJson-8                       100000         13297 ns/op       13669 B/op        207 allocs/op
BenchmarkJsonPool-8                   100000         13310 ns/op       10218 B/op        206 allocs/op
BenchmarkJsonIter-8                   500000          2948 ns/op        3594 B/op          4 allocs/op
BenchmarkJsonIterPool-8               200000          6126 ns/op        6040 B/op        144 allocs/op
PASS
ok      github.com/thinkeridea/example/iouitl_readall   12.716s&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里使用了两个 &lt;code&gt;json&lt;/code&gt; 包， 一个是标准库的，一个是 &lt;code&gt;jsoniter&lt;/code&gt; (也是社区反馈效率最高的)，对比两个包使用 &lt;code&gt;sync.Pool&lt;/code&gt; 和不使用之间的差异，发现标准库 &lt;code&gt;json&lt;/code&gt; 包使用后内存有少量减少，但是运行效率稍微下降了，差异不是很大，&lt;code&gt;jsoniter&lt;/code&gt; 包差异之所谓非常明显，发现使用 &lt;code&gt;sync.Pool&lt;/code&gt; 之后不仅内存分配更多了，执行效率也大幅度下降，差了将近3倍有余。&lt;/p&gt;
&lt;p&gt;是不是很奔溃，这是啥情况 &lt;code&gt;jsoniter&lt;/code&gt; 本身就使用了 &lt;code&gt;sync.Pool&lt;/code&gt; 作缓冲，我们使用 &lt;code&gt;jsoniter.NewEncoder(buffer)&lt;/code&gt; 创建一个序列化实例，但是其内部并没有直接使用 &lt;code&gt;io.Writer&lt;/code&gt; 而是先使用缓冲序列化数据，之后写入 &lt;code&gt;io.Writer&lt;/code&gt;, 具体代码如下：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;// Flush writes any buffered data to the underlying io.Writer.
func (stream *Stream) Flush() error {
    if stream.out == nil {
        return nil
    }
    if stream.Error != nil {
        return stream.Error
    }
    n, err := stream.out.Write(stream.buf)
    if err != nil {
        if stream.Error == nil {
            stream.Error = err
        }
        return err
    }
    stream.buf = stream.buf[n:]
    return nil
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样一来我们使用 &lt;code&gt;buffer&lt;/code&gt; 做 &lt;code&gt;json&lt;/code&gt; 序列化优化效果就大打折扣，甚至适得其反了。&lt;/p&gt;
&lt;p&gt;再次感谢 “wxe” 网友的提问，这里没有使用实际的应用场景做性能测试，主要发现在性能测试中使用 &lt;code&gt;http&lt;/code&gt; 服务会导致 &lt;code&gt;connect: can't assign requested address&lt;/code&gt; 问题，所以测试用使用了函数模拟，如果有朋友有更好的测试方法欢迎一起交流。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;转载：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文作者： 戚银（&lt;a href=&quot;https://blog.thinkeridea.com/&quot;&gt;thinkeridea&lt;/a&gt;）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文链接： &lt;a href=&quot;https://blog.thinkeridea.com/201902/go/you_ya_de_du_qu_http_qing_qiu_huo_xiang_ying_de_shu_ju_2.html&quot; class=&quot;uri&quot;&gt;https://blog.thinkeridea.com/201902/go/you_ya_de_du_qu_http_qing_qiu_huo_xiang_ying_de_shu_ju_2.html&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;版权声明： 本博客所有文章除特别声明外，均采用 &lt;a href=&quot;http://creativecommons.org/licenses/by/4.0/deed.zh&quot;&gt;CC BY 4.0 CN协议&lt;/a&gt; 许可协议。转载请注明出处！&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 01 Feb 2019 13:09:00 +0000</pubDate>
<dc:creator>戚银</dc:creator>
<og:description>原文链接：https://blog.thinkeridea.com/201902/go/you_ya_de_du_qu_http_qing_qiu_huo_xiang_ying_de_shu_ju_2</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/thinkeridea/p/10347026.html</dc:identifier>
</item>
<item>
<title>JAVA I/O（六）多路复用IO - 水木竹水</title>
<link>http://www.cnblogs.com/shuimuzhushui/p/10323011.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shuimuzhushui/p/10323011.html</guid>
<description>&lt;p&gt;在前边介绍Socket和ServerSocket连接交互的过程中，读写都是阻塞的。套接字写数据时，数据先写入操作系统的缓存中，形成TCP或UDP的负载，作为套接字传输到目标端，当缓存大小不足时，线程会阻塞。套接字读数据时，如果操作系统缓存没有接收到信息，则读线程阻塞。线程阻塞情况下，就不能处理其他事情。JDK1.4引入了通道和选择器的概念，以支持异步或多路复用的IO。&lt;/p&gt;
&lt;p&gt;Unix系统中的select()方法可以实现异步IO，可以给该Selector注册多个描述符（可读或可写），然后对这些描述符进行监控。在Java中，描述符即为套接字Socket。&lt;/p&gt;
&lt;p&gt;如&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/shuimuzhushui/p/10269216.html&quot;&gt;JAVA I/O（二）文件NIO&lt;/a&gt;中对选择器的介绍，在非阻塞模式下，用select()方法检测发生变化的通道，每个通道都关联一个Socket，用一个线程实现多个客户端的请求，从而实现多路复用。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1012728/201902/1012728-20190201170500349-845921177.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;h2&gt;1. 简单实例&lt;/h2&gt;
&lt;h3&gt;&lt;strong&gt;服务器端&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.net.InetSocketAddress;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.nio.ByteBuffer;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.nio.CharBuffer;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.nio.channels.SelectionKey;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.nio.channels.Selector;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.nio.channels.ServerSocketChannel;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.nio.channels.SocketChannel;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.nio.charset.Charset;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Iterator;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MultiJabberServer1 {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; PORT = 8080&lt;span&gt;;
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException{
        
        String encoding &lt;/span&gt;= System.getProperty(&quot;file.encoding&quot;&lt;span&gt;);
        Charset cs &lt;/span&gt;=&lt;span&gt; Charset.forName(encoding);
        ByteBuffer buffer &lt;/span&gt;= ByteBuffer.allocate(16&lt;span&gt;);
        SocketChannel ch &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Socket对应的channel
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.创建ServerSocketChannel&lt;/span&gt;
        ServerSocketChannel ssc =&lt;span&gt; ServerSocketChannel.open();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.创建选择器Selector&lt;/span&gt;
        Selector sel =&lt;span&gt; Selector.open();
        
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3.设置ServerSocketChannel通道为非阻塞&lt;/span&gt;
            ssc.configureBlocking(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;4.ServerSocketChannel关联Socket，用于监听连接，使用本地ip和port
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注意：Socket也对通道进行了改造，直接调Socket.getChannel()将返回bull，除非通过下边与通道关联
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;the expression (ssc.socket().getChannel() != null) is true&lt;/span&gt;
            ssc.socket().bind(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; InetSocketAddress(PORT));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;5.将通道注册到Selector，感兴趣的事件为  连接  事件&lt;/span&gt;
&lt;span&gt;            ssc.register(sel, SelectionKey.OP_ACCEPT);
            System.out.println(&lt;/span&gt;&quot;Server on port: &quot; +&lt;span&gt; PORT);
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;6.没有事件发生时，一直阻塞等待&lt;/span&gt;
&lt;span&gt;                sel.select();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;7.有事件发生时，获取Selector中所有SelectorKey（持有选择器与通道的关联关系）。
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;由于基于操作系统的poll()方法，当有事件发生时，只返回事件个数，无法确定具体通道，故只能对所有注册的通道进行遍历。&lt;/span&gt;
                Iterator&amp;lt;SelectionKey&amp;gt; it =&lt;span&gt; sel.selectedKeys().iterator();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;8.遍历所有SelectorKey，处理事件&lt;/span&gt;
                &lt;span&gt;while&lt;/span&gt;&lt;span&gt;(it.hasNext()) {
                    SelectionKey sKey &lt;/span&gt;=&lt;span&gt; it.next();
                    it.remove();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;防止重复处理
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;9.判断SelectorKey对应的channel发生的事件是否socket连接&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(sKey.isAcceptable()) {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;10.与ServerSocket.accept()方法相似，接收到该通道套接字的连接，返回SocketChannel，与客户端进行交互&lt;/span&gt;
                        ch =&lt;span&gt; ssc.accept();
                        System.out.println(
                                &lt;/span&gt;&quot;Accepted connection from:&quot; +&lt;span&gt; ch.socket());
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;11.设置该SocketChannel为非阻塞模式&lt;/span&gt;
                        ch.configureBlocking(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;12.将该通道注册到Selector中，感兴趣的事件为OP_READ（读）&lt;/span&gt;
&lt;span&gt;                        ch.register(sel, SelectionKey.OP_READ);
                    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;13.发生非连接事件，此处为OP_READ事件。SelectorKey获取注册的SocketChannel，用于读写&lt;/span&gt;
                        ch =&lt;span&gt; (SocketChannel)sKey.channel();
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;14.将数据从channel读到ByteBuffer中&lt;/span&gt;
&lt;span&gt;                        ch.read(buffer);
                        CharBuffer cb &lt;/span&gt;=&lt;span&gt; cs.decode((ByteBuffer)buffer.flip());
                        String response &lt;/span&gt;=&lt;span&gt; cb.toString();
                        System.out.print(&lt;/span&gt;&quot;Echoing : &quot; +&lt;span&gt; response);
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;15.再将获取到的数据会写给客户端&lt;/span&gt;
&lt;span&gt;                        ch.write((ByteBuffer)buffer.rewind());
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(response.indexOf(&quot;END&quot;) != -1&lt;span&gt;)
                            ch.close();
                        buffer.clear();
                    }
                }
            }
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(ch != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                ch.close();
            ssc.close();
            sel.close();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 如代码中注释标明，大致步骤包含：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;创建ServerSocketChannel和Selector，设置通道非阻塞，并与服务端的Socket绑定&lt;/li&gt;
&lt;li&gt;注册 ServerSocketChannel到Selector，感兴趣的事件为OP_CONNECT（获取连接）&lt;/li&gt;
&lt;li&gt;select()方法阻塞等待，直到有事件发生&lt;/li&gt;
&lt;li&gt;遍历Selector中的所有注册事件，通过SelectorKey维护Selector和Channel关联关系&lt;/li&gt;
&lt;li&gt;如果是连接事件，则调ServerSocketChannel.accept()方法获取SocketChannel，与客户端交互&lt;/li&gt;
&lt;li&gt;如果是读事件，则通过SelectorKey中获取SocketChannel，读写数据&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;运行结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
Server on port: 8080
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;strong&gt;客户端&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.net.InetAddress;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.net.InetSocketAddress;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.nio.ByteBuffer;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.nio.channels.SelectionKey;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.nio.channels.Selector;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.nio.channels.SocketChannel;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.nio.charset.Charset;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Iterator;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.test.socketio.JabberServer;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 采用这种方式，读与写是非阻塞的
 * 普通的读写是阻塞的，直到读完或写完&lt;/span&gt;&lt;span&gt;
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; JabberClient1 {
    
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; clPot = 8899&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException{
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.创建SocketChannel&lt;/span&gt;
        SocketChannel sc =&lt;span&gt; SocketChannel.open();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.创建Selector&lt;/span&gt;
        Selector sel =&lt;span&gt; Selector.open();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            sc.configureBlocking(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3.关联SocketChannel和Socket，socket绑定到本机端口&lt;/span&gt;
            sc.socket().bind(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; InetSocketAddress(clPot));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;4.注册到Selector，感兴趣的事件为OP_CONNECT、OP_READ、OP_WRITE&lt;/span&gt;
            sc.register(sel, SelectionKey.OP_CONNECT | SelectionKey.OP_READ |&lt;span&gt; SelectionKey.OP_WRITE);
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i = 0&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; written = &lt;span&gt;false&lt;/span&gt;, done = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            String encoding &lt;/span&gt;= System.getProperty(&quot;file.encoding&quot;&lt;span&gt;);
            Charset cs &lt;/span&gt;=&lt;span&gt; Charset.forName(encoding);
            ByteBuffer buffer &lt;/span&gt;= ByteBuffer.allocate(16&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(!&lt;span&gt;done) {
                sel.select();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;5.从选择器中获取所有注册的通道信息（SelectionKey作为标识）&lt;/span&gt;
                Iterator&amp;lt;SelectionKey&amp;gt; it =&lt;span&gt; sel.selectedKeys().iterator();
                &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt;(it.hasNext()) {
                    SelectionKey key &lt;/span&gt;=&lt;span&gt; it.next();
                    it.remove();
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;6.获取通道，此处即为上边创建的channel&lt;/span&gt;
                    sc =&lt;span&gt; (SocketChannel)key.channel();    
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;7.判断SelectorKey对应的channel发生的事件是否socket连接，并且还没有连接&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt;(key.isConnectable() &amp;amp;&amp;amp; !&lt;span&gt;sc.isConnected()) {
                        InetAddress addr &lt;/span&gt;= InetAddress.getByName(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;连接addr和port对应的服务器&lt;/span&gt;
                        &lt;span&gt;boolean&lt;/span&gt; success = sc.connect(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; InetSocketAddress(addr, JabberServer.PORT));
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;success)
                            sc.finishConnect();
                    }
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;8.读与写是非阻塞的：客户端写一个信息到服务器，服务器发送一个信息到客户端，客户端再读&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt;(key.isReadable() &amp;amp;&amp;amp;&lt;span&gt; written) {
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(sc.read((ByteBuffer)buffer.clear()) &amp;gt; 0&lt;span&gt;) {
                            written &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                            String response &lt;/span&gt;=&lt;span&gt; cs.decode((ByteBuffer)buffer.flip()).toString();
                            System.out.println(response);
                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(response.indexOf(&quot;END&quot;) != -1&lt;span&gt;)
                                done &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                        }
                    }
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(key.isWritable() &amp;amp;&amp;amp; !&lt;span&gt;written) {
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(i &amp;lt; 10&lt;span&gt;)
                            sc.write(ByteBuffer.wrap(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; String(&quot;howdy &quot; + i + &quot;\n&quot;&lt;span&gt;).getBytes()));
                        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(i == 10&lt;span&gt;){
                            sc.write(ByteBuffer.wrap(&lt;/span&gt;&quot;END&quot;&lt;span&gt;.getBytes()));
                        }
                        written &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                        i&lt;/span&gt;++&lt;span&gt;;
                    }
                }
            }
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            sc.close();
            sel.close();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;客户端与服务端类似，不同之处：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;创建SocketChannel通道，注册到选择器，刚兴趣的事件为OP_CONNECT、OP_READ、OP_WRITE&lt;/li&gt;
&lt;li&gt;调试发现，客户端sel.select()不会阻塞，对注册通道不断的遍历，并且每次都可写。&lt;strong&gt;原因是OP_WRITE事件会持续生效，即只要连接存在就可以写，不管服务端是否有返回&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;本例中，客户端发送一条数据，服务端接收一条，并返回给客户端；客户端接到服务端的消息后，才会发生下一条数据，主要通过written标识进行控制的。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;运行机制&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1012728/201902/1012728-20190201200931876-1886426926.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;运行结果&lt;/h3&gt;
&lt;p&gt;服务端&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
Server on port: 8080&lt;span&gt;
Accepted connection from:Socket[addr&lt;/span&gt;=/127.0.0.1,port=8899,localport=8080&lt;span&gt;]
Echoing : howdy &lt;/span&gt;0&lt;span&gt;
Echoing : howdy &lt;/span&gt;1&lt;span&gt;
Echoing : howdy &lt;/span&gt;2&lt;span&gt;
Echoing : howdy &lt;/span&gt;3&lt;span&gt;
Echoing : howdy &lt;/span&gt;4&lt;span&gt;
Echoing : howdy &lt;/span&gt;5&lt;span&gt;
Echoing : howdy &lt;/span&gt;6&lt;span&gt;
Echoing : howdy &lt;/span&gt;7&lt;span&gt;
Echoing : howdy &lt;/span&gt;8&lt;span&gt;
Echoing : howdy &lt;/span&gt;9&lt;span&gt;
Echoing : END&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;客户端&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
howdy 0&lt;span&gt;
howdy &lt;/span&gt;1&lt;span&gt;
howdy &lt;/span&gt;2&lt;span&gt;
howdy &lt;/span&gt;3&lt;span&gt;
howdy &lt;/span&gt;4&lt;span&gt;
howdy &lt;/span&gt;5&lt;span&gt;
howdy &lt;/span&gt;6&lt;span&gt;
howdy &lt;/span&gt;7&lt;span&gt;
howdy &lt;/span&gt;8&lt;span&gt;
howdy &lt;/span&gt;9&lt;span&gt;
END&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2.核心类分析&lt;/h2&gt;
&lt;h3&gt;（1）通道（SelectableChannel）&lt;/h3&gt;
&lt;p&gt; 通道Channel继承体系如下，其中ServerSocketChannel和SocketChannel都继承自SelectableChannel。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1012728/201902/1012728-20190201192109054-1286209010.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;SelectableChannel通道可以通过Selector实现多路复用（multiplexed）。&lt;/li&gt;
&lt;li&gt;通道通过register(Selector,int,Object)方法注册到Selector中，并返回SelectorKey（代表注册到Selector上的注册信息）。&lt;/li&gt;
&lt;li&gt;在一个Selector中，同一个通道只能注册一份；是否可以注册到多个Selector中，由程序调用isRegistered()方法决定。&lt;/li&gt;
&lt;li&gt;SelectableChannel通道是线程安全的。&lt;/li&gt;
&lt;li&gt;SelectableChannel包含阻塞和非阻塞两种模式，只有非阻塞时才可以注册到Selector中。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;ServerSocketChannel&lt;/strong&gt;（A selectable channel for stream-oriented &lt;strong&gt;listening&lt;/strong&gt; sockets.），用于&lt;strong&gt;监听&lt;/strong&gt;Socket的基于流的可选通道。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SocketChannel&lt;/strong&gt;（A selectable channel for stream-oriented &lt;strong&gt;connecting&lt;/strong&gt; sockets.），用于&lt;strong&gt;连接&lt;/strong&gt;Socket的基于流额可选通道。&lt;/p&gt;
&lt;h3&gt;（2）选择器（Selector）&lt;/h3&gt;
&lt;p&gt;Selector是SelectableChannel的多路复选器，该类包含以下方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1012728/201902/1012728-20190201195834278-1537359619.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通过open()方法创建Selector&lt;/li&gt;
&lt;li&gt;包含三种SelectorKey Set：所有注册的SelectorKey、被选的SelectorKey（通道发生事件）、被取消的SelectorKey（不可直接访问）&lt;/li&gt;
&lt;li&gt;每次select()操作，都会从被选的SelectorKey集合中删除或新增，清楚被取消的SelectorKey中的SelectorKey&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;&lt;strong&gt;（3）选择建（SelectorKey）&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　选择键封装了特定的&lt;strong&gt;通道&lt;/strong&gt;与&lt;strong&gt;特定的选择器&lt;/strong&gt;的注册关系。选择键对象被SelectableChannel.register()返回并提供一个表示这种注册关系的标记。选择键包含了两个比特集(以整数的形式进行编码)，指示了该注册关系所关心的通道操作，以及通道已经准备好的操作。包括读、写、连接和接收操作，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; OP_READ = 1 &amp;lt;&amp;lt; 0&lt;span&gt;;
&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; OP_WRITE = 1 &amp;lt;&amp;lt; 2&lt;span&gt;;
&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; OP_CONNECT = 1 &amp;lt;&amp;lt; 3&lt;span&gt;;
&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; OP_ACCEPT = 1 &amp;lt;&amp;lt; 4;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3.Reactor设计模式&lt;/h2&gt;
&lt;p&gt;基于Selector的多路复用IO，机制是采用Reactor设计模式，将一个或多个客户的服务请求分离（demultiplex）和事件分发器 （dispatch）给应用程序（&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/duanxz/p/3698530.html&quot;&gt;I/O模型之三：两种高性能 I/O 设计模式 Reactor 和 Proactor&lt;/a&gt;），即通过Selector阻塞等待事件发生，然后再分发给相应的处理器接口。详情可以参考该篇文章或更多的资料。&lt;/p&gt;
&lt;p&gt;摘自链接文章中的一幅图如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Reactor是调度中心，包含select()阻塞，等待事件发生，并分发不同的业务处理。&lt;/li&gt;
&lt;li&gt;客户端请求连接时，select()接收到事件后，会调acceptor，创建连接并与客户端交互。&lt;/li&gt;
&lt;li&gt;客户端写数据给服务端时，select()接收到事件后，调read操作，读取客户端数据，可以采用线程池对与客户端交互，对数据进行处理。&lt;/li&gt;
&lt;li&gt;服务端可也以发生数据给客户端。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1012728/201902/1012728-20190201172832793-283721133.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;4.总结&lt;/h2&gt;
&lt;p&gt;　　1. SelectableChannel（ServerSocketChannel和SocketChannel）可以注册到Selector中，并用选择键（SelectorKey）进行分装&lt;/p&gt;
&lt;p&gt;　　2. SelectorKey中包含选择器感兴趣的事件（读、写、连接和接收）&lt;/p&gt;
&lt;p&gt;　　3. Selector中select()方法阻塞，直到注册通道有事件发生，可以一个线程监控多个客户端，实现多路复用&lt;/p&gt;
&lt;p&gt;　　4. 基于Selector的多路复用采用Reactor设计模式，使得选择器与业务处理进行分离。&lt;/p&gt;
&lt;p&gt;　　5. Netty是异步基于事件的应用框架，其实现是基于Java NIO的，并对其进行了优化，可以进一步学习。&lt;/p&gt;
&lt;h2&gt;5. 参考&lt;/h2&gt;
&lt;p&gt;《Thinking in Enterprise Java》&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/duanxz/p/6782783.html&quot;&gt;Java NIO系列教程（六） 多路复用器Selector&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 01 Feb 2019 12:24:00 +0000</pubDate>
<dc:creator>水木竹水</dc:creator>
<og:description>在前边介绍Socket和ServerSocket连接交互的过程中，读写都是阻塞的。套接字写数据时，数据先写入操作系统的缓存中，形成TCP或UDP的负载，作为套接字传输到目标端，当缓存大小不足时，线程会</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shuimuzhushui/p/10323011.html</dc:identifier>
</item>
<item>
<title>VS2015编译GEOS的debug和release版本 - charlee44</title>
<link>http://www.cnblogs.com/charlee44/p/10346863.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/charlee44/p/10346863.html</guid>
<description>&lt;p&gt;目前GEOS最新的3.7.1版本支持camke进行编译。经过尝试发现通过cmake生成的工程在vs2015下面编译的时候还是存在问题，而且在中文网上也没找到解决方案。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1000410/201902/1000410-20190201194720805-241262921.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以还是采用了nmake进行编译。解压出geos-3.7.1文件夹，双击运行其中的autogen.bat。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1000410/201902/1000410-20190201194831089-67668947.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在目录中找到nmake.opt，这个文件控制着nmake编译的一些参数。记事本打开，找到如下片段：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;######################################################################
# Set WIN64=YES if you are building for 64-bit windows (x64).
# Alternatively, pass WIN64=YES as NMAKE command line argument.
######################################################################
!IFNDEF WIN64
WIN64 = NO
!ENDIF&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过注释知道这里控制编译出的是64位版本还是32位版本，我这里用的64版本，所以改为WIN64=YES。&lt;br/&gt;同样，再次找到如下片段：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# Set BUILD_DEBUG to YES if you want to make debug build
# and to prepare not optimized binaries.

!IFNDEF BUILD_DEBUG
BUILD_DEBUG = NO
!ENDIF&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同样通过注释知道这里控制编译出的是Release版本还是debug版本，我这里用的debug版本，所以改成BUILD_DEBUG=YES。&lt;br/&gt;修改好配置之后，找到VS2015的本机工具命令提示符，CD到geos-3.7.1文件夹，输入命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;nmake /f makefile.vc&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1000410/201902/1000410-20190201194902037-657059776.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后等待编译完成就可以了，最终的输出结果在geos-3.7.1文件夹的src文件夹里面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1000410/201902/1000410-20190201194924420-1962278306.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果需要Release版本，那么可以修改对应的配置用同样的方式编译一边就可以了，它们是以_d后缀来区分的。&lt;/p&gt;
</description>
<pubDate>Fri, 01 Feb 2019 11:54:00 +0000</pubDate>
<dc:creator>charlee44</dc:creator>
<og:description>简要的介绍了再VS2015环境下编译GEOS的过程。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/charlee44/p/10346863.html</dc:identifier>
</item>
</channel>
</rss>