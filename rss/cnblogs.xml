<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Java，你告诉我 fail-fast 是什么鬼？ - 沉默王二</title>
<link>http://www.cnblogs.com/qing-gee/p/11909576.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qing-gee/p/11909576.html</guid>
<description>&lt;p&gt;本篇我们来聊聊 Java 的 fail-fast 机制，文字一如既往的有趣哦。&lt;/p&gt;
&lt;h3 id=&quot;前言&quot;&gt;01、前言&lt;/h3&gt;
&lt;p&gt;说起来真特么惭愧：十年 IT 老兵，Java 菜鸟一枚。今天我才了解到 Java 还有 fail-fast 一说。不得不感慨啊，学习真的是没有止境。只要肯学，就会有巨多巨多别人眼中的“旧”知识涌现出来，并且在我这全是新的。&lt;/p&gt;
&lt;p&gt;能怎么办呢？除了羞愧，就只能赶紧全身心地投入学习，把这些知识掌握。&lt;/p&gt;
&lt;p&gt;为了镇楼，必须搬一段英文来解释一下 fail-fast。&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;In systems design, a fail-fast system is one which immediately reports at its interface any condition that is likely to indicate a failure. Fail-fast systems are usually designed to stop normal operation rather than attempt to continue a possibly flawed process. Such designs often check the system's state at several points in an operation, so any failures can be detected early. The responsibility of a fail-fast module is detecting errors, then letting the next-highest level of the system handle them.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;大家不嫌弃的话，我就用蹩脚的英语能力翻译一下。某场战役当中，政委发现司令员在乱指挥的话，就立马报告给权限更高的中央军委——这样可以有效地避免更严重的后果出现。当然了，如果司令员是李云龙的话，报告也没啥用。&lt;/p&gt;
&lt;p&gt;不过，Java 的世界里不存在李云龙。fail-fast 扮演的就是政委的角色，一旦报告给上级，后面的行动就别想执行。&lt;/p&gt;
&lt;p&gt;怎么和代码关联起来呢？看下面这段代码。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void test(Wanger wanger) {   
    if (wanger == null) {
        throw new RuntimeException(&quot;wanger 不能为空&quot;);
    }
    
    System.out.println(wanger.toString());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一旦检测到 wanger 为 null，就立马抛出异常，让调用者来决定这种情况下该怎么处理，下一步 &lt;code&gt;wanger.toString()&lt;/code&gt; 就不会执行了——避免更严重的错误出现，这段代码由于太过简单，体现不出来，后面会讲到。&lt;/p&gt;
&lt;p&gt;瞧，fail-fast 就是这个鬼，没什么神秘的。如果大家源码看得比较多的话，这种例子多得就像旅游高峰期的人头。&lt;/p&gt;
&lt;p&gt;然后呢，没了？三秒钟，别着急，我们继续。&lt;/p&gt;
&lt;h3 id=&quot;for-each-中集合的-remove-操作&quot;&gt;02、for each 中集合的 remove 操作&lt;/h3&gt;
&lt;p&gt;很长一段时间里，&lt;a href=&quot;https://mp.weixin.qq.com/s/feoOINGSyivBO8Z1gaQVOA&quot;&gt;我&lt;/a&gt;都不明白为什么不能在 &lt;code&gt;for each&lt;/code&gt; 循环里进行元素的 remove。今天我们就来借机来体验一把。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
list.add(&quot;沉默王二&quot;);
list.add(&quot;沉默王三&quot;);
list.add(&quot;一个文章真特么有趣的程序员&quot;);

for (String str : list) {
    if (&quot;沉默王二&quot;.equals(str)) {
        list.remove(str);
    }
}

System.out.println(list);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码看起来没有任何问题，但运行起来就糟糕了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Exception in thread &quot;main&quot; java.util.ConcurrentModificationException
    at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:909)
    at java.util.ArrayList$Itr.next(ArrayList.java:859)
    at com.cmower.java_demo.str.Cmower3.main(Cmower3.java:14)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为毛呢？&lt;/p&gt;
&lt;h3 id=&quot;分析问题的杀手锏&quot;&gt;03、分析问题的杀手锏&lt;/h3&gt;
&lt;p&gt;这时候就只能看源码了，ArrayList.java 的 909 行代码是这样的。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;final void checkForComodification() {
    if (modCount != expectedModCount)
        throw new ConcurrentModificationException();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也就是说，remove 的时候执行了 &lt;code&gt;checkForComodification&lt;/code&gt; 方法，该方法对 modCount 和 expectedModCount 进行了比较，发现两者不等，就抛出了 &lt;code&gt;ConcurrentModificationException&lt;/code&gt; 异常。&lt;/p&gt;
&lt;p&gt;可为什么会执行 &lt;code&gt;checkForComodification&lt;/code&gt; 方法呢？这就需要反编译一下 &lt;code&gt;for each&lt;/code&gt; 那段代码了。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;List&amp;lt;String&amp;gt; list = new ArrayList();
list.add(&quot;沉默王二&quot;);
list.add(&quot;沉默王三&quot;);
list.add(&quot;一个文章真特么有趣的程序员&quot;);
Iterator var3 = list.iterator();

while (var3.hasNext()) {
    String str = (String) var3.next();
    if (&quot;沉默王二&quot;.equals(str)) {
        list.remove(str);
    }
}

System.out.println(list);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;原来 &lt;code&gt;for each&lt;/code&gt; 是通过迭代器 Iterator 配合 while 循环实现的。&lt;/p&gt;
&lt;p&gt;1）&lt;code&gt;ArrayList.iterator()&lt;/code&gt; 返回的 Iterator 其实是 ArrayList 的一个内部类 Itr。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public Iterator&amp;lt;E&amp;gt; iterator() {
    return new Itr();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Itr 实现了 Iterator 接口。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private class Itr implements Iterator&amp;lt;E&amp;gt; {
    int cursor;       // index of next element to return
    int lastRet = -1; // index of last element returned; -1 if no such
    int expectedModCount = modCount;

    Itr() {}

    public boolean hasNext() {
        return cursor != size;
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    public E next() {
        checkForComodification();
        int i = cursor;
        Object[] elementData = ArrayList.this.elementData;
        if (i &amp;gt;= elementData.length)
            throw new ConcurrentModificationException();
        cursor = i + 1;
        return (E) elementData[lastRet = i];
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也就是说 &lt;code&gt;new Itr()&lt;/code&gt; 的时候 expectedModCount 被赋值为 modCount，而 modCount 是 List 的一个成员变量，表示集合被修改的次数。由于 list 此前执行了 3 次 add 方法，所以 modCount 的值为 3；expectedModCount 的值也为 3。&lt;/p&gt;
&lt;p&gt;可当执行 &lt;code&gt;list.remove(str)&lt;/code&gt; 后，modCount 的值变成了 4。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private void fastRemove(int index) {
    modCount++;
    int numMoved = size - index - 1;
    if (numMoved &amp;gt; 0)
        System.arraycopy(elementData, index+1, elementData, index,
                         numMoved);
    elementData[--size] = null; // clear to let GC do its work
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注：remove 方法内部调用了 fastRemove 方法。&lt;/p&gt;
&lt;p&gt;下一次循环执行到 &lt;code&gt;String str = (String) var3.next();&lt;/code&gt; 的时候，就会调用 &lt;code&gt;checkForComodification&lt;/code&gt; 方法，此时一个为 3，一个为 4，就只好抛出异常 ConcurrentModificationException 了。&lt;/p&gt;
&lt;p&gt;不信，可以直接在 ArrayList 类的 909 行打个断点 debug 一下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.itwanger.com/assets/images/2019/11/java-fail-fast-1.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;真的耶，一个是 4 一个是 3。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结一下&lt;/strong&gt;。在 &lt;code&gt;for each&lt;/code&gt; 循环中，集合遍历其实是通过迭代器 Iterator 配合 while 循环实现的，但是元素的 remove 却直接使用的集合类自身的方法。这就导致 Iterator 在遍历的时候，会发现元素在自己不知情的情况下被修改了，它觉得很难接受，就抛出了异常。&lt;/p&gt;
&lt;p&gt;读者朋友们，你们是不是觉得我跑题了，fail-fast 和 &lt;code&gt;for each&lt;/code&gt; 中集合的 remove 操作有什么关系呢？&lt;/p&gt;
&lt;p&gt;有！Iterator 使用了 fail-fast 的保护机制。&lt;/p&gt;
&lt;h3 id=&quot;怎么避开-fail-fast-保护机制呢&quot;&gt;04、怎么避开 fail-fast 保护机制呢&lt;/h3&gt;
&lt;p&gt;通过上面的分析，相信大家都明白为什么不能在 &lt;code&gt;for each&lt;/code&gt; 循环里进行元素的 remove 了。&lt;/p&gt;
&lt;p&gt;那怎么避开 fail-fast 保护机制呢？毕竟删除元素是常规操作，咱不能因噎废食啊。&lt;/p&gt;
&lt;p&gt;1）remove 后 break&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
list.add(&quot;沉默王二&quot;);
list.add(&quot;沉默王三&quot;);
list.add(&quot;一个文章真特么有趣的程序员&quot;);

for (String str : list) {
    if (&quot;沉默王二&quot;.equals(str)) {
        list.remove(str);
        break;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我怎么这么聪明，忍不住骄傲一下。有读者不明白为什么吗？那我上面的源码分析可就白分析了，爬楼再看一遍吧！&lt;/p&gt;
&lt;p&gt;略微透露一下原因：break 后循环就不再遍历了，意味着 Iterator 的 next 方法不再执行了，也就意味着 &lt;code&gt;checkForComodification&lt;/code&gt; 方法不再执行了，所以异常也就不会抛出了。&lt;/p&gt;
&lt;p&gt;但是呢，当 List 中有重复元素要删除的时候，break 就不合适了。&lt;/p&gt;
&lt;p&gt;2）for 循环&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
list.add(&quot;沉默王二&quot;);
list.add(&quot;沉默王三&quot;);
list.add(&quot;一个文章真特么有趣的程序员&quot;);
for (int i = 0, n = list.size(); i &amp;lt; n; i++) {
    String str = list.get(i);
    if (&quot;沉默王二&quot;.equals(str)) {
        list.remove(str);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;for 循环虽然可以避开 fail-fast 保护机制，也就说 remove 元素后不再抛出异常；但是呢，这段程序在原则上是有问题的。为什么呢？&lt;/p&gt;
&lt;p&gt;第一次循环的时候，i 为 0，&lt;code&gt;list.size()&lt;/code&gt; 为 3，当执行完 remove 方法后，i 为 1，&lt;code&gt;list.size()&lt;/code&gt; 却变成了 2，因为 list 的大小在 remove 后发生了变化，也就意味着“沉默王三”这个元素被跳过了。能明白吗？&lt;/p&gt;
&lt;p&gt;remove 之前 &lt;code&gt;list.get(1)&lt;/code&gt; 为“沉默王三”；但 remove 之后 &lt;code&gt;list.get(1)&lt;/code&gt; 变成了“一个文章真特么有趣的程序员”，而 &lt;code&gt;list.get(0)&lt;/code&gt; 变成了“沉默王三”。&lt;/p&gt;
&lt;p&gt;3）Iterator&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
list.add(&quot;沉默王二&quot;);
list.add(&quot;沉默王三&quot;);
list.add(&quot;一个文章真特么有趣的程序员&quot;);

Iterator&amp;lt;String&amp;gt; itr = list.iterator();

while (itr.hasNext()) {
    String str = itr.next();
    if (&quot;沉默王二&quot;.equals(str)) {
        itr.remove();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为什么使用 Iterator 的 remove 方法就可以避开 fail-fast 保护机制呢？看一下 remove 的源码就明白了。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void remove() {
    if (lastRet &amp;lt; 0)
        throw new IllegalStateException();
    checkForComodification();

    try {
        ArrayList.this.remove(lastRet);
        cursor = lastRet;
        lastRet = -1;
        expectedModCount = modCount;
    } catch (IndexOutOfBoundsException ex) {
        throw new ConcurrentModificationException();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;虽然删除元素依然使用的是 ArrayList 的 remove 方法，但是删除完会执行 &lt;code&gt;expectedModCount = modCount&lt;/code&gt;，保证了 expectedModCount 与 modCount 的同步。&lt;/p&gt;
&lt;h3 id=&quot;最后&quot;&gt;05、最后&lt;/h3&gt;
&lt;p&gt;在 Java 中，fail-fast 从狭义上讲是针对多线程情况下的集合迭代器而言的。这一点可以从 &lt;code&gt;ConcurrentModificationException&lt;/code&gt; 定义上看得出来。&lt;/p&gt;
&lt;blockquote readability=&quot;16&quot;&gt;
&lt;p&gt;This exception may be thrown by methods that have detected concurrent&lt;br/&gt;modification of an object when such modification is not permissible.&lt;/p&gt;&lt;p&gt;For example, it is not generally permissible for one thread to modify a Collectionwhile another thread is iterating over it. In general, the results of theiteration are undefined under these circumstances. Some Iteratorimplementations (including those of all the general purpose collection implementationsprovided by the JRE) may choose to throw this exception if this behavior isdetected. Iterators that do this are known as fail-fast iterators,as they fail quickly and cleanly, rather that risking arbitrary,non-deterministic behavior at an undetermined time in the future.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;再次拙劣地翻译一下。&lt;/p&gt;
&lt;p&gt;该异常可能由于检测到对象在并发情况下被修改而抛出的，而这种修改是不允许的。&lt;/p&gt;
&lt;p&gt;通常，这种操作是不允许的，比如说一个线程在修改集合，而另一个线程在迭代它。这种情况下，迭代的结果是不确定的。如果检测到这种行为，一些 Iterator（比如说 ArrayList 的内部类 Itr）就会选择抛出该异常。这样的迭代器被称为 fail-fast 迭代器，因为尽早的失败比未来出现不确定的风险更好。&lt;/p&gt;
&lt;p&gt;既然是针对多线程，为什么我们之前的分析都是基于单线程的呢？因为从广义上讲，fail-fast 指的是当有异常或者错误发生时就立即中断执行的这种设计，从单线程的角度去分析，大家更容易明白。&lt;/p&gt;
&lt;p&gt;你说对吗？&lt;/p&gt;
&lt;h3 id=&quot;致谢&quot;&gt;06、致谢&lt;/h3&gt;
&lt;p&gt;谢谢大家的阅读，原创不易，喜欢就随手点个赞👍，这将是我最强的写作动力。&lt;/p&gt;
</description>
<pubDate>Fri, 22 Nov 2019 00:48:00 +0000</pubDate>
<dc:creator>沉默王二</dc:creator>
<og:description>本篇我们来聊聊 Java 的 fail fast 机制，文字一如既往的有趣哦。 &lt;! more 01、前言 说起来真特么惭愧：十年 IT 老兵，Java 菜鸟一枚。今天我才了解到 Java 还有 fa</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qing-gee/p/11909576.html</dc:identifier>
</item>
<item>
<title>小白学 Python 爬虫（2）：前置准备（一）基本类库的安装 - 极客挖掘机</title>
<link>http://www.cnblogs.com/babycomeon/p/11909567.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/babycomeon/p/11909567.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201911/908359-20191122084440582-186699232.jpg&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;人生苦短，我用 Python&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;前文传送门：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/13/3303836941/&quot;&gt;小白学 Python 爬虫（1）：开篇&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;本篇内容较长，各位同学可以先收藏后再看~~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在开始讲爬虫之前，还是先把环境搞搞好，工欲善其事必先利其器嘛~~~&lt;/p&gt;
&lt;p&gt;本篇文章主要介绍 Python 爬虫所使用到的请求库和解析库，请求库用来请求目标内容，解析库用来解析请求回来的内容。&lt;/p&gt;
&lt;h2 id=&quot;开发环境&quot;&gt;开发环境&lt;/h2&gt;
&lt;p&gt;首先介绍小编本地的开发环境：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Python3.7.4&lt;/li&gt;
&lt;li&gt;win10&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;差不多就这些，最基础的环境，其他环境需要我们一个一个安装，现在开始。&lt;/p&gt;
&lt;h2 id=&quot;请求库&quot;&gt;请求库&lt;/h2&gt;
&lt;p&gt;虽然 Python 为我们内置了 HTTP 请求库 urllib ，使用姿势并不是很优雅，但是很多第三方的提供的 HTTP 库确实更加的简洁优雅，我们下面开始。&lt;/p&gt;
&lt;h3 id=&quot;requests&quot;&gt;Requests&lt;/h3&gt;
&lt;p&gt;Requests 类库是一个第三方提供的用于发送 HTTP 同步请求的类库，相比较 Python 自带的 urllib 类库更加的方便和简洁。&lt;/p&gt;
&lt;p&gt;Python 为我们提供了包管理工具 pip ，使用 pip 安装将会非常的方便，安装命令如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;pip install requests&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;验证：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;C:\Users\inwsy&amp;gt;python
Python 3.7.4 (tags/v3.7.4:e09359112e, Jul  8 2019, 20:34:20) [MSC v.1916 64 bit (AMD64)] on win32
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&amp;gt;&amp;gt;&amp;gt; import requests&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先在 CMD 命令行中输入 python ，进入 python 的命令行模式，然后输入 &lt;code&gt;import requests&lt;/code&gt; 如果没有任何错误提示，说明我们已经成功安装 &lt;code&gt;Requests&lt;/code&gt; 类库。&lt;/p&gt;
&lt;h3 id=&quot;selenium&quot;&gt;Selenium&lt;/h3&gt;
&lt;p&gt;Selenium 现在更多的是用来做自动化测试工具，相关的书籍也不少，同时，我们也可以使用它来做爬虫工具，毕竟是自动化测试么，利用它我们可以让浏览器执行我们想要的动作，比如点击某个按钮、滚动滑轮之类的操作，这对我们模拟真实用户操作是非常方便的。&lt;/p&gt;
&lt;p&gt;安装命令如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;pip install selenium&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;验证：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;C:\Users\inwsy&amp;gt;python
Python 3.7.4 (tags/v3.7.4:e09359112e, Jul  8 2019, 20:34:20) [MSC v.1916 64 bit (AMD64)] on win32
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&amp;gt;&amp;gt;&amp;gt; import selenium&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样没报错我们就安装完成，但是你以为这样就算好了么？图样图森破啊。&lt;/p&gt;
&lt;h4 id=&quot;chromedriver&quot;&gt;ChromeDriver&lt;/h4&gt;
&lt;p&gt;我们还需要浏览器的支持来配合 &lt;code&gt;selenium&lt;/code&gt; 的工作，开发人员嘛，常用的浏览器莫非那么几种：Chrome、Firefox，那位说 IE 的同学，你给我站起来，小心我跳起来打你膝盖，还有说 360 浏览器的，你们可让我省省心吧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201911/908359-20191122084440906-318678530.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来，安装 Chrome 浏览器就不用讲了吧。。。。&lt;/p&gt;
&lt;p&gt;再接下来，我们开始安装 ChromeDriver ，安装了 ChromeDriver 后，我们才能通过刚才安装的 &lt;code&gt;selenium&lt;/code&gt; 来驱动 Chrome 来完成各种骚操作。&lt;/p&gt;
&lt;p&gt;首先，我们需要查看自己的 Chrome 浏览器的版本，在 Chrome 浏览器右上角的三个点钟，点击 帮助 -&amp;gt; 关于，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201911/908359-20191122084441351-1447529644.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;将这个版本找个小本本记下来，小编这里的版本为： 版本 78.0.3904.97（正式版本） （64 位）&lt;/p&gt;
&lt;p&gt;接下来我们需要去 ChromeDriver 的官网查看当前 Chrome 对应的驱动。&lt;/p&gt;
&lt;p&gt;官网地址： &lt;a href=&quot;https://sites.google.com/a/chromium.org/chromedriver/&quot; class=&quot;uri&quot;&gt;https://sites.google.com/a/chromium.org/chromedriver/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;因某些原因，访问时需某些手段，访问不了的就看小编为大家准备的版本对应表格吧。。。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;78.0.3904.11&lt;/td&gt;
&lt;td&gt;78&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;77.0.3865.40&lt;/td&gt;
&lt;td&gt;77&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;77.0.3865.10&lt;/td&gt;
&lt;td&gt;77&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;76.0.3809.126&lt;/td&gt;
&lt;td&gt;76&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;76.0.3809.68&lt;/td&gt;
&lt;td&gt;76&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;76.0.3809.25&lt;/td&gt;
&lt;td&gt;76&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;76.0.3809.12&lt;/td&gt;
&lt;td&gt;76&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;75.0.3770.90&lt;/td&gt;
&lt;td&gt;75&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;75.0.3770.8&lt;/td&gt;
&lt;td&gt;75&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;74.0.3729.6&lt;/td&gt;
&lt;td&gt;74&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;73.0.3683.68&lt;/td&gt;
&lt;td&gt;73&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;72.0.3626.69&lt;/td&gt;
&lt;td&gt;72&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;2.46&lt;/td&gt;
&lt;td&gt;71-73&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;2.45&lt;/td&gt;
&lt;td&gt;70-72&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;2.44&lt;/td&gt;
&lt;td&gt;69-71&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;2.43&lt;/td&gt;
&lt;td&gt;69-71&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;2.42&lt;/td&gt;
&lt;td&gt;68-70&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;2.41&lt;/td&gt;
&lt;td&gt;67-69&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;2.40&lt;/td&gt;
&lt;td&gt;66-68&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;2.39&lt;/td&gt;
&lt;td&gt;66-68&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;2.38&lt;/td&gt;
&lt;td&gt;65-67&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;2.37&lt;/td&gt;
&lt;td&gt;64-66&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;2.36&lt;/td&gt;
&lt;td&gt;63-65&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;2.35&lt;/td&gt;
&lt;td&gt;62-64&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;顺便小编找到了国内对应的下载的镜像站，由淘宝提供，如下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://npm.taobao.org/mirrors/chromedriver&quot; class=&quot;uri&quot;&gt;http://npm.taobao.org/mirrors/chromedriver&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;虽然和小编本地的小版本对不上，但是看样子只要大版本符合应该没啥问题，so，去镜像站下载对应的版本即可，小编这里下载的版本是：78.0.3904.70 ，ChromeDriver 78版本的最后一个小版本。&lt;/p&gt;
&lt;p&gt;下载完成后，将可执行文件 &lt;code&gt;chromedriver.exe&lt;/code&gt; 移动至 Python 安装目录的 Scripts 目录下。如果使用默认安装未修改过安装目录的话目录是：&lt;code&gt;%homepath%\AppData\Local\Programs\Python\Python37\Scripts&lt;/code&gt; ，如果有过修改，那就自力更生吧。。。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201911/908359-20191122084441850-1902910520.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;将 &lt;code&gt;chromedriver.exe&lt;/code&gt; 添加后结果如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201911/908359-20191122084443173-133848336.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;验证：&lt;/p&gt;
&lt;p&gt;还是在 CMD 命令行中，输入以下内容：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;C:\Users\inwsy&amp;gt;python
Python 3.7.4 (tags/v3.7.4:e09359112e, Jul  8 2019, 20:34:20) [MSC v.1916 64 bit (AMD64)] on win32
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&amp;gt;&amp;gt;&amp;gt; from selenium import webdriver
&amp;gt;&amp;gt;&amp;gt; browser = webdriver.Chrome()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果打开一个空白的 Chrome 页面说明安装成功。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201911/908359-20191122084444496-932010255.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;geckodriver&quot;&gt;GeckoDriver&lt;/h4&gt;
&lt;p&gt;上面我们通过安装 Chrome 的驱动完成了 Selenium 与 Chrome 的对接，想要完成 Selenium 与 FireFox 的对接则需要安装另一个驱动 GeckoDriver 。&lt;/p&gt;
&lt;p&gt;FireFox 的安装小编这里就不介绍了，大家最好去官网下载安装，路径如下：&lt;/p&gt;
&lt;p&gt;FireFox 官网地址： &lt;a href=&quot;http://www.firefox.com.cn/&quot; class=&quot;uri&quot;&gt;http://www.firefox.com.cn/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;GeckoDriver 的下载需要去 Github （全球最大的同性交友网站），下载路径小编已经找好了，可以选择最新的 releases 版本进行下载。&lt;/p&gt;
&lt;p&gt;下载地址： &lt;a href=&quot;https://github.com/mozilla/geckodriver/releases&quot; class=&quot;uri&quot;&gt;https://github.com/mozilla/geckodriver/releases&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;选择对应自己的环境，小编这里选择 win-64 ，版本为 v0.26.0 进行下载。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201911/908359-20191122084444761-1998973815.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;具体配置方式和上面一样，将可执行的 &lt;code&gt;.exe&lt;/code&gt; 文件放入 &lt;code&gt;%homepath%\AppData\Local\Programs\Python\Python37\Scripts&lt;/code&gt; 目录下即可。&lt;/p&gt;
&lt;p&gt;验证：&lt;/p&gt;
&lt;p&gt;还是在 CMD 命令行中，输入以下内容：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;C:\Users\inwsy&amp;gt;python
Python 3.7.4 (tags/v3.7.4:e09359112e, Jul  8 2019, 20:34:20) [MSC v.1916 64 bit (AMD64)] on win32
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&amp;gt;&amp;gt;&amp;gt; from selenium import webdriver
&amp;gt;&amp;gt;&amp;gt; browser = webdriver.Firefox()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;应该是可以正常打开一个空白的 FireFox 页面的，结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201911/908359-20191122084445231-1634203140.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; GeckoDriver 指出一点，当前的版本在 win 下使用有已知 bug ，需要安装微软的一个插件才能解决，原文如下：&lt;/p&gt;
&lt;blockquote readability=&quot;4.4590163934426&quot;&gt;
&lt;p&gt;You must still have the &lt;a href=&quot;https://support.microsoft.com/en-us/help/2977003/the-latest-supported-visual-c-downloads&quot;&gt;Microsoft Visual Studio redistributable runtime&lt;/a&gt; installed on your system for the binary to run. This is a known bug which we weren't able fix for this release.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;插件下载地址： &lt;a href=&quot;https://support.microsoft.com/en-us/help/2977003/the-latest-supported-visual-c-downloads&quot; class=&quot;uri&quot;&gt;https://support.microsoft.com/en-us/help/2977003/the-latest-supported-visual-c-downloads&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;请各位同学选择自己对应的系统版本进行下载安装。&lt;/p&gt;
&lt;h3 id=&quot;aiohttp&quot;&gt;Aiohttp&lt;/h3&gt;
&lt;p&gt;上面我们介绍了同步的 Http 请求库 Requests ，而 Aiohttp 则是一个提供异步 Http 请求的类库。&lt;/p&gt;
&lt;p&gt;那么，问题来了，什么是同步请求？什么是异步请求呢？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;同步：阻塞式，简单理解就是当发出一个请求以后，程序会一直等待这个请求响应，直到响应以后，才继续做下一步。&lt;/li&gt;
&lt;li&gt;异步：非阻塞式，还是上面的例子，当发出一个请求以后，程序并不会阻塞在这里，等待请求响应，而是可以去做其他事情。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;从资源消耗和效率上来说，同步请求是肯定比不过异步请求的，这也是为什么异步请求会比同步请求拥有更大的吞吐量。在抓取数据时使用异步请求，可以大大提升抓取的效率。&lt;/p&gt;
&lt;p&gt;如果还想了解跟多有关 aiohttp 的内容，可以访问官方文档： &lt;a href=&quot;https://aiohttp.readthedocs.io/en/stable/&quot; class=&quot;uri&quot;&gt;https://aiohttp.readthedocs.io/en/stable/&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;aiohttp 安装如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;pip install aiohttp&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;aiohttp 还推荐我们安装另外两个库，一个是字符编码检测库 cchardet ，另一个是加速DNS的解析库 aiodns 。&lt;/p&gt;
&lt;p&gt;安装 cchardet 库：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;pip install cchardet&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装 aiodns 库：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;pip install aiodns&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;aiohttp 十分贴心的为我们准备了整合的安装命令，无需一个一个键入命令，如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;pip install aiohttp[speedups]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;验证：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;C:\Users\inwsy&amp;gt;python
Python 3.7.4 (tags/v3.7.4:e09359112e, Jul  8 2019, 20:34:20) [MSC v.1916 64 bit (AMD64)] on win32
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&amp;gt;&amp;gt;&amp;gt; import aiohttp&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;没报错就安装成功。&lt;/p&gt;
&lt;h2 id=&quot;解析库&quot;&gt;解析库&lt;/h2&gt;
&lt;h3 id=&quot;lxml&quot;&gt;lxml&lt;/h3&gt;
&lt;p&gt;lxml 是 Python 的一个解析库，支持 HTML 和 XML 的解析，支持 XPath 的解析方式，而且解析效率非常高。&lt;/p&gt;
&lt;p&gt;什么是 XPath ？&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;XPath即为XML路径语言（XML Path Language），它是一种用来确定XML文档中某部分位置的语言。&lt;br/&gt;XPath基于XML的树状结构，提供在数据结构树中找寻节点的能力。起初XPath的提出的初衷是将其作为一个通用的、介于XPointer与XSL间的语法模型。&lt;/p&gt;
&lt;p&gt;以上内容来源《百度百科》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;好吧，小编说人话，就是可以从 XML 文档或者 HTML 文档中快速的定位到所需要的位置的路径语言。&lt;/p&gt;
&lt;p&gt;还没看懂？emmmmmmmmmmm，我们可以使用 XPath 快速的取出 XML 或者 HTML 文档中想要的值。用法的话我们放到后面再聊。&lt;/p&gt;
&lt;p&gt;安装 lxml 库：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;pip install lxml&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;验证：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;C:\Users\inwsy&amp;gt;python
Python 3.7.4 (tags/v3.7.4:e09359112e, Jul  8 2019, 20:34:20) [MSC v.1916 64 bit (AMD64)] on win32
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&amp;gt;&amp;gt;&amp;gt; import lxml&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;没报错就安装成功。&lt;/p&gt;
&lt;h3 id=&quot;beautiful-soup&quot;&gt;Beautiful Soup&lt;/h3&gt;
&lt;p&gt;Beautiful Soup 同样也是一个 Python 的 HTML 或 XML 的解析库 。它拥有强大的解析能力，我们可以使用它更方便的从 HTML 文档中提取数据。&lt;/p&gt;
&lt;p&gt;首先，放一下 Beautiful Soup 的官方网址，有各种问题都可以在官网查看文档，各位同学养成一个好习惯，有问题找官方文档，虽然是英文的，使用 Chrome 自带的翻译功能还是勉强能看的。&lt;/p&gt;
&lt;p&gt;官方网站：&lt;a href=&quot;https://www.crummy.com/software/BeautifulSoup/&quot; class=&quot;uri&quot;&gt;https://www.crummy.com/software/BeautifulSoup/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安装方式依然使用 pip 进行安装：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;pip install beautifulsoup4&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Beautiful Soup 的 HTML 和 XML 解析器是依赖于 lxml 库的，所以在此之前请确保已经成功安装好了 lxml 库 。&lt;/p&gt;
&lt;p&gt;验证：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;C:\Users\inwsy&amp;gt;python
Python 3.7.4 (tags/v3.7.4:e09359112e, Jul  8 2019, 20:34:20) [MSC v.1916 64 bit (AMD64)] on win32
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&amp;gt;&amp;gt;&amp;gt; from bs4 import BeautifulSoup&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;没报错就安装成功。&lt;/p&gt;
&lt;h3 id=&quot;pyquery&quot;&gt;pyquery&lt;/h3&gt;
&lt;p&gt;pyquery 同样也是一个网页解析库，只不过和前面两个有区别的是它提供了类似 jQuery 的语法来解析 HTML 文档，前端有经验的同学应该会非常喜欢这款解析库。&lt;/p&gt;
&lt;p&gt;首先还是放一下 pyquery 的官方文档地址。&lt;/p&gt;
&lt;p&gt;官方文档： &lt;a href=&quot;https://pyquery.readthedocs.io/en/latest/&quot; class=&quot;uri&quot;&gt;https://pyquery.readthedocs.io/en/latest/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安装：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;pip install pyquery&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;验证：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;C:\Users\inwsy&amp;gt;python
Python 3.7.4 (tags/v3.7.4:e09359112e, Jul  8 2019, 20:34:20) [MSC v.1916 64 bit (AMD64)] on win32
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&amp;gt;&amp;gt;&amp;gt; import pyquery&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;没报错就安装成功。&lt;/p&gt;
&lt;p&gt;本篇的内容就先到这里结束了。请各位同学在自己的电脑上将上面介绍的内容都安装一遍，以便后续学习使用。&lt;/p&gt;
</description>
<pubDate>Fri, 22 Nov 2019 00:45:00 +0000</pubDate>
<dc:creator>极客挖掘机</dc:creator>
<og:description>人生苦短，我用 Python 前文传送门： '小白学 Python 爬虫（1）：开篇' 本篇内容较长，各位同学可以先收藏后再看~~ 在开始讲爬虫之前，还是先把环境搞搞好，工欲善其事必先利其器嘛~~~</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/babycomeon/p/11909567.html</dc:identifier>
</item>
<item>
<title>【python测试开发栈】带你彻底搞明白python3编码原理 - 布道师玄柯</title>
<link>http://www.cnblogs.com/zhouliweiblog/p/11909554.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhouliweiblog/p/11909554.html</guid>
<description>&lt;p&gt;在之前的文章中，我们介绍过编码格式的发展史：[文章传送门-todo]。今天我们通过几个例子，来彻底搞清楚python3中的编码格式原理，这样你之后写python脚本时碰到编码问题，才能有章可循。&lt;/p&gt;
&lt;p&gt;我们先搞清楚几个概念：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;系统默认编码&lt;/strong&gt;：指python解释器默认的编码格式，在python文件头部没有声明其他编码格式时，python3默认的编码格式是utf-8。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;本地默认编码&lt;/strong&gt;：操作系统默认的编码，常见的Windows的默认编码是gbk，Linux的默认编码是UTF-8。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;python文件头部声明编码格式&lt;/strong&gt;：修改的是文件的默认编码格式，只是会影响python解释器读取python文件时的编码格式，并不会改变系统默认编码和本地默认编码。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;通过python自带的库，可以查看系统默认编码和本地默认编码&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;Python 3.7.4 (tags/v3.7.4:e09359112e, Jul  8 2019, 20:34:20) [MSC v.1916 64 bit (AMD64)] on win32
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&amp;gt;&amp;gt;&amp;gt; import sys
&amp;gt;&amp;gt;&amp;gt; sys.getdefaultencoding()
'utf-8'
&amp;gt;&amp;gt;&amp;gt; import locale
&amp;gt;&amp;gt;&amp;gt; locale.getdefaultlocale()
('zh_CN', 'cp936')
&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意，因为我在windows系统的电脑上 进行测试，所以系统默认编码返回“cp936”, 这是代码页（是字符编码集的别名），而936对应的就是gbk。如果你在linux或者mac上执行上面的代码，应该会返回utf-8编码。&lt;/p&gt;
&lt;p&gt;其实总结来看，容易出现乱码的场景，基本都与读写程序有关，比如：读取/写入某个文件，或者从网络流中读取数据等，因为这个过程中涉及到了&lt;strong&gt;编码&lt;/strong&gt; 和&lt;strong&gt;解码&lt;/strong&gt;的过程，只要编码和解码的编码格式对应不上，就容易出现乱码。下面我们举两个具体的例子，来验证下python的编码原理，帮助你理解这个过程。注意：下面的例子都是在pycharm中写的。&lt;/p&gt;
&lt;h2 id=&quot;默认的编码格式&quot;&gt;01默认的编码格式&lt;/h2&gt;
&lt;p&gt;我们新建一个encode_demo.py的文件，其文件默认的编码格式是UTF-8（可以从pycharm右下角看到编码格式），代码如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;&quot;&quot;&quot;
    @author: asus
    @time: 2019/11/21
    @function: 验证编码格式
&quot;&quot;&quot;
import sys, locale


def write_str_default_encode():
    s = &quot;我是一个str&quot;
    print(s)
    print(type(s))
    print(sys.getdefaultencoding())
    print(locale.getdefaultlocale())

    with open(&quot;utf_file&quot;, &quot;w&quot;, encoding=&quot;utf-8&quot;) as f:
        f.write(s)
    with open(&quot;gbk_file&quot;, &quot;w&quot;, encoding=&quot;gbk&quot;) as f:
        f.write(s)
    with open(&quot;jis_file&quot;, &quot;w&quot;, encoding=&quot;shift-jis&quot;) as f:
        f.write(s)


if __name__ == '__main__':
    write_str_default_encode()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们先来猜测下结果，因为我们没有声明编码格式，所以python解释器默认用UTF-8去解码文件，因为文件默认编码格式就是UTF-8，所以字符串s可以正常打印。同时以UTF-8编码格式写文件不会出现乱码，而以gbk和shift-jis（日文编码）写文件会出现乱码（这里说明一点，我是用pycharm直接打开生成的文件查看的，编辑器默认编码是UTF-8，如果在windows上用记事本打开则其默认编码跟随系统是GBK，gbk_file和utf_file均不会出现乱码，只有jis_file是乱码），我们运行看下结果：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;# 运行结果
我是一个str
&amp;lt;class 'str'&amp;gt;
utf-8
('zh_CN', 'cp936')

# 写文件utf_file、gbk_file、jis_file文件内容分别是：
我是一个str
����һ��str
�䐥�꘢str&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;和我们猜测的结果一致，下面我们做个改变，在文件头部声明个编码格式，再来看看效果。&lt;/p&gt;
&lt;h2 id=&quot;python头文件声明编码格式&quot;&gt;02 python头文件声明编码格式&lt;/h2&gt;
&lt;p&gt;因为上面文件encode_demo.py的格式是UTF-8，那么我们就将其变为gbk编码。同样的我们先来推测下结果，在pycharm中，在python文件头部声明编码为gbk后（头部加上 # coding=gbk ），文件的编码格式变成gbk，同时python解释器会用gbk去解码encode_demo.py文件，所以运行结果应该和用UTF-8编码时一样。运行结果如下：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;# 运行结果
我是一个str
&amp;lt;class 'str'&amp;gt;
utf-8
('zh_CN', 'cp936')

# 写文件utf_file、gbk_file、jis_file文件内容分别是：
我是一个str
����һ��str
�䐥�꘢str&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果确实是一样的，证明我们推论是正确的。接下来我们再做个尝试，假如我们将（# coding=gbk）去掉（需要注意，在pycharm中将 # coding=gbk去掉，并不会改变文件的编码格式，也就是说encode_demo.py还是gbk编码），我们再运行一次看结果：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;  File &quot;D:/codespace/python/pythonObject/pythonSample/basic/encodeDemo/encode_demo.py&quot;, line 4
SyntaxError: Non-UTF-8 code starting with '\xd1' in file D:/codespace/python/pythonObject/pythonSample/basic/encodeDemo/encode_demo.py on line 5, but no encoding declared; see http://python.org/dev/peps/pep-0263/ for details
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行直接报错了，我们加个断点，看看具体的异常信息：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/367944/201911/367944-20191122083608020-528296077.png&quot; alt=&quot;编码错误.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看错误提示是UnicodeDecodeError，python解释器在对encode_demo.py文件解码时，使用默认的UTF-8编码，但是文件本身是gbk编码，所以当碰到有中文没办法识别时，就抛出DecodeError。&lt;/p&gt;
&lt;h2 id=&quot;敲黑板划重点&quot;&gt;03 敲黑板，划重点&lt;/h2&gt;
&lt;h3 id=&quot;python3中的str和bytes&quot;&gt;python3中的str和bytes&lt;/h3&gt;
&lt;p&gt;python3的重要特性之一就是对字符串和二进制流做了严格的区分，我们声明的字符串都是str类型，不过Str和bytes是可以相互转换的：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;def str_transfor_bytes():
    s = '我是一个测试Str'
    print(type(s))
    # str 转bytes
    b = s.encode()
    print(b)
    print(type(b))
    # bytes转str
    c = b.decode('utf-8')
    print(c)
    print(type(c))


if __name__ == '__main__':
    str_transfor_bytes()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要注意一点：在调用encode()和decode()方法时，如果不传参数，则会使用python解释器默认的编码格式UTF-8（如果不在python头文件声明编码格式）。但是如果传参的话，encode和decode使用的编码格式要能对应上。&lt;/p&gt;
&lt;h3 id=&quot;python3默认编码是utf-8还是unicode&quot;&gt;python3默认编码是UTF-8？还是Unicode？&lt;/h3&gt;
&lt;p&gt;经常在很多文章里看到，python3的默认编码格式是Unicode，但是我在本文中却一直在说python3的默认编码格式是UTF-8，那么哪种说法是正确的呢？其实两种说法都对，主要得搞清楚Unicode和UTF-8的区别（之前文章有提到）：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Unicode是一个字符集，说白了就是把各种编码的映射关系全都整合起来，不过它是不可变长的，全部都以两个字节或四个字节来表示，占用的内存空间比较大。&lt;/li&gt;
&lt;li&gt;UTF-8是Unicode的一种实现方式，主要对 Unicode 码的数据进行转换，方便存储和网络传输 。它是可变长编码，比如对于英文字母，它使用一个字节就可以表示。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在python3内存中使用的字符串全都是Unicode码，当python解释器解析python文件时，默认使用UTF-8编码。&lt;/p&gt;
&lt;h3 id=&quot;open方法默认使用本地编码&quot;&gt;open()方法默认使用本地编码&lt;/h3&gt;
&lt;p&gt;在上面的例子中，我们往磁盘写入文件时，都指定了编码格式。如果不指定编码格式，那么默认将使用操作系统本地默认的编码格式，比如：Linux默认是UTF-8，windows默认是GBK。其实这也好理解，因为和磁盘交互，肯定要考虑操作系统的编码格式。这有区别于encode()和decode()使用的是python解释器的默认编码格式，千万别搞混淆了。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;不知道你看完上面的例子后，是否已经彻底理解了python3的编码原理。不过所有的编码问题，都逃不过“编码”和“解码”两个过程，当你碰到编码问题时，先确定源文件使用的编码，再确定目标文件需要的编码格式，只要能匹配，一般就可以解决编码的问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/367944/201911/367944-20191122083608225-453511459.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 22 Nov 2019 00:36:00 +0000</pubDate>
<dc:creator>布道师玄柯</dc:creator>
<og:description>在之前的文章中，我们介绍过编码格式的发展史：[文章传送门 todo]。今天我们通过几个例子，来彻底搞清楚python3中的编码格式原理，这样你之后写python脚本时碰到编码问题，才能有章可循。 我们</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhouliweiblog/p/11909554.html</dc:identifier>
</item>
<item>
<title>五分钟学会HTML5的WebSocket协议 - Peerless1029</title>
<link>http://www.cnblogs.com/peerless1029/p/11909446.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/peerless1029/p/11909446.html</guid>
<description>&lt;h2 id=&quot;背景&quot;&gt;1、背景&lt;/h2&gt;
&lt;p&gt;  很多网站为了实现推送技术，所用的技术都是&lt;strong&gt;Ajax轮询&lt;/strong&gt;。轮询是在特定的的时间间隔由浏览器对服务器发出HTTP请求，然后由服务器返回最新的数据给客户端的浏览器。这种传统的模式带来很明显的缺点，即浏览器需要不断的向服务器发出请求，然而HTTP请求可能包含较长的头部，其中真正有效的数据可能只是很小的一部分，显然这样会浪费很多的带宽等资源。HTML5新增的一些新协议&lt;strong&gt;WebSocket&lt;/strong&gt;,可以提供在单个TCP连接上&lt;strong&gt;提供全双工，双向通信&lt;/strong&gt;，能够节省服务器资源和带宽，并且能够实时进行通信。&lt;/p&gt;
&lt;h2 id=&quot;websocket介绍&quot;&gt;2、WebSocket介绍&lt;/h2&gt;
&lt;p&gt;  传统的http也是一种协议，WebSocket是一种协议，使用http服务器无法实现WebSocket，&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.1.浏览器支持情况&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;基本主流浏览器都支持&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1103967/201911/1103967-20191122022640237-1033309185.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.2.优点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;相对于http有如下好处：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1.客户端与服务器只建立一个TCP连接，可以使用更少的连接。&lt;/li&gt;
&lt;li&gt;2.WebSocket服务器端可以主动推送数据到客户端，更灵活高效。&lt;/li&gt;
&lt;li&gt;3.更轻量级的协议头，减少数据传送量。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对比轮训机制&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1103967/201911/1103967-20191122022658213-1496251397.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;websocket用法&quot;&gt;3、WebSocket用法&lt;/h2&gt;
&lt;p&gt;  我们了解WebSocket是什么，有哪些优点后，怎么使用呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.1.WebSocket创建&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;WebSocket使用了自定义协议，url模式与http略有不同，未加密的连接是ws://，加密的连接是wss://，WebSocket实例使用&lt;code&gt;new WebSocket()&lt;/code&gt;方法来创建，&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var ws = new WebSocket(url, [protocol] );&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;第一个参数 url, 指定连接的 URL。第二个参数 protocol 是可选的，指定了可接受的子协议。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.2.WebSocket属性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当创建ws对象后，readyState为ws实例状态，共4种状态&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;0 表示连接尚未建立。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;1 表示连接已建立，可以进行通信。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;2 表示连接正在进行关闭。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;3 表示连接已经关闭或者连接不能打开。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Tips：&lt;/strong&gt;在发送报文之前要判断状态，断开也应该有重连机制。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.3.WebSocket事件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在创建ws实例对象后，会拥有以下几个事件，根据不同状态可在事件回调写方法。&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;ws.onopen 连接建立时触发&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;ws.onmessage 客户端接收服务端数据时触发&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;ws.onerror 通信发生错误时触发&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;ws.onclose 连接关闭时触发&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;ws.onmessage = (res) =&amp;gt; {
  console.log(res.data);
};

ws.onopen = () =&amp;gt; {
  console.log('OPEN...');
};

ws.onclose=()=&amp;gt;{
 console.log('CLOSE...');
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3.4.WebSocket方法&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;demo演示&quot;&gt;4、Demo演示&lt;/h2&gt;
&lt;p&gt;  了解WebSocket的一些API之后，趁热打铁，做一个小案例跑一下。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.1.Node服务器端&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;WebSocket协议与Node一起用非常好，原因有以下两点：&lt;/p&gt;
&lt;p&gt;1.WebSocket客户端基于事件编程与Node中自定义事件差不多。&lt;/p&gt;
&lt;p&gt;2.WebSocket实现客户端与服务器端长连接，Node基本事件驱动的方式十分适合高并发连接&lt;/p&gt;
&lt;p&gt;创建一个webSocket.js如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const WebSocketServer = require('ws').Server;
const wss = new WebSocketServer({ port: 8080 });
wss.on('connection', function (ws) {
    console.log('client connected');
    ws.on('message', function (message) {
        ws.send('我收到了' + message);
    });
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打开windows命令窗口运行&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1103967/201911/1103967-20191122022622029-1771959083.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.2.HTML客户端&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新建一个index.html页面&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;webSocket小Demo&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div class=&quot;container&quot;&amp;gt;
        &amp;lt;div&amp;gt;
            &amp;lt;input type=&quot;text&quot; id=&quot;msg&quot;&amp;gt;
            &amp;lt;button onclick=&quot;sendMsg()&quot;&amp;gt;发送报文&amp;lt;/button&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;script&amp;gt;
        const ws = new WebSocket('ws://localhost:8080');
        ws.onmessage = (res) =&amp;gt; {
            console.log(res);
        };
        ws.onopen = () =&amp;gt; {
            console.log('OPEN...');
        };
        ws.onclose = () =&amp;gt; {
            console.log('CLOSE...');
        }
        function sendMsg() {
            let msg = document.getElementById('msg').value;
            ws.send(msg);
        }
    &amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打开浏览器依次输入字符1,2,3，每次输入完点击发送报体，可见在ws.onmessage事件中res.data中返回来我们发的报文&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1103967/201911/1103967-20191122022609323-1300599992.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;问题与总结&quot;&gt;5、问题与总结&lt;/h2&gt;
&lt;p&gt;  以上只是简单的介绍了下WebSocket的API与简单用法，在处理高并发，长连接这些需求上，例如聊天室，可能WebSocket的http请求更加合适高效。&lt;/p&gt;
&lt;p&gt;   但在使用WebSocket过程中发现容易断开连接等问题，所以在每次发送报文前要判断是否断开，当多次发送报文时，由于服务器端返回数据量不同，返回客户端前后顺序也不同，所以需要在客户端收到上一个报文返回数据后再发送下一个报文，为了避免回调嵌套过多，通过Promise ，async ,await等同步方式解决。关于WebSocket就写这么多，如有不足，欢迎多多指正！&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;参考资料：&lt;br/&gt;《JavaScript高级教程》&lt;br/&gt;《深入检出NodeJs》&lt;br/&gt;&lt;a href=&quot;https://www.runoob.com/&quot;&gt;《菜鸟教程》&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 22 Nov 2019 00:12:00 +0000</pubDate>
<dc:creator>Peerless1029</dc:creator>
<og:description>1、背景 &amp;emsp;&amp;emsp;很多网站为了实现推送技术，所用的技术都是 Ajax轮询 。轮询是在特定的的时间间隔由浏览器对服务器发出HTTP请求，然后由服务器返回最新的数据给客户端的浏览器。这种传</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/peerless1029/p/11909446.html</dc:identifier>
</item>
<item>
<title>[springboot 开发单体web shop] 7. 多种形式提供商品列表 - IsaacZhang</title>
<link>http://www.cnblogs.com/zhangpan1244/p/11909515.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangpan1244/p/11909515.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000021047932&quot;&gt;上节&lt;/a&gt; 我们实现了仿&lt;code&gt;jd&lt;/code&gt;的轮播广告以及商品分类的功能，并且讲解了不同的注入方式，本节我们将继续实现我们的电商主业务，商品信息的展示。&lt;/p&gt;

&lt;p&gt;首先，在我们开始本节编码之前，我们先来分析一下都有哪些地方会对商品进行展示，打开&lt;code&gt;jd&lt;/code&gt;首页，鼠标下拉可以看到如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/48397/201911/48397-20191122075917091-108425741.png&quot; alt=&quot;首页商品列表示例&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，在大类型下查询了部分商品在首页进行展示（可以是最新的，也可以是网站推荐等等），然后点击任何一个分类，可以看到如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/48397/201911/48397-20191122075920969-2048505841.png&quot; alt=&quot;分类商品列表示例&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们一般进到电商网站之后，最常用的一个功能就是搜索，&lt;a href=&quot;%5Bhttps://search.jd.com/Search?keyword=%E7%94%B5%E9%92%A2%E7%90%B4&amp;amp;enc=utf-8&amp;amp;spm=a.0.0&amp;amp;wq=&amp;amp;pvid=2162c63a5cb942d0aa73b921fb00dca9%5D(https://search.jd.com/Search?keyword=%E7%94%B5%E9%92%A2%E7%90%B4&amp;amp;enc=utf-8&amp;amp;spm=a.0.0&amp;amp;wq=&amp;amp;pvid=2162c63a5cb942d0aa73b921fb00dca9)&quot;&gt;搜索钢琴&lt;/a&gt; 结果如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/48397/201911/48397-20191122075924676-1965450771.png&quot; alt=&quot;搜索查询结果示例&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择任意一个商品点击，都可以进入到详情页面，这个是单个商品的信息展示。&lt;br/&gt;综上，我们可以知道，要实现一个电商平台的商品展示，最基本的包含：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首页推荐/最新上架商品&lt;/li&gt;
&lt;li&gt;分类查询商品&lt;/li&gt;
&lt;li&gt;关键词搜索商品&lt;/li&gt;
&lt;li&gt;商品详情展示&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;接下来，我们就可以开始商品相关的业务开发了。&lt;/p&gt;

&lt;h2 id=&quot;开发梳理&quot;&gt;开发梳理&lt;/h2&gt;
&lt;p&gt;我们首先来实现在首页展示的推荐商品列表，来看一下都需要展示哪些信息，以及如何进行展示。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;商品主键(product_id)&lt;/li&gt;
&lt;li&gt;展示图片（image_url）&lt;/li&gt;
&lt;li&gt;商品名称（product_name）&lt;/li&gt;
&lt;li&gt;商品价格(product_price)&lt;/li&gt;
&lt;li&gt;分类说明(description)&lt;/li&gt;
&lt;li&gt;分类名称(category_name)&lt;/li&gt;
&lt;li&gt;分类主键（category_id）&lt;/li&gt;
&lt;li&gt;其他...&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;编码实现&quot;&gt;编码实现&lt;/h2&gt;
&lt;h3 id=&quot;根据一级分类查询&quot;&gt;根据一级分类查询&lt;/h3&gt;
&lt;p&gt;遵循开发顺序，自下而上，如果基础mapper解决不了，那么优先编写SQL mapper，因为我们需要在同一张表中根据&lt;code&gt;parent_id&lt;/code&gt;递归的实现数据查询，当然我们这里使用的是&lt;code&gt;表链接&lt;/code&gt;的方式实现。因此，&lt;code&gt;common mapper&lt;/code&gt;无法满足我们的需求，需要自定义mapper实现。&lt;/p&gt;
&lt;h4 id=&quot;custom-mapper实现&quot;&gt;Custom Mapper实现&lt;/h4&gt;
&lt;p&gt;和&lt;a href=&quot;https://segmentfault.com/a/1190000021047932&quot;&gt;上节&lt;/a&gt;根据一级分类查询子分类一样，在项目&lt;code&gt;mscx-shop-mapper&lt;/code&gt;中添加一个自定义实现接口&lt;code&gt;com.liferunner.custom.ProductCustomMapper&lt;/code&gt;，然后在&lt;code&gt;resources\mapper\custom&lt;/code&gt;路径下同步创建xml文件&lt;code&gt;mapper/custom/ProductCustomMapper.xml&lt;/code&gt;，此时，因为我们在上节中已经配置了当前文件夹可以被容器扫描到，所以我们添加的新的mapper就会在启动时被扫描加载，代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * ProductCustomMapper for : 自定义商品Mapper
 */
public interface ProductCustomMapper {

    /***
     * 根据一级分类查询商品
     *
     * @param paramMap 传递一级分类（map传递多参数）
     * @return java.util.List&amp;lt;com.liferunner.dto.IndexProductDTO&amp;gt;
     */
    List&amp;lt;IndexProductDTO&amp;gt; getIndexProductDtoList(@Param(&quot;paramMap&quot;) Map&amp;lt;String, Integer&amp;gt; paramMap);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&amp;gt;
&amp;lt;mapper namespace=&quot;com.liferunner.custom.ProductCustomMapper&quot;&amp;gt;
    &amp;lt;resultMap id=&quot;IndexProductDTO&quot; type=&quot;com.liferunner.dto.IndexProductDTO&quot;&amp;gt;
        &amp;lt;id column=&quot;rootCategoryId&quot; property=&quot;rootCategoryId&quot;/&amp;gt;
        &amp;lt;result column=&quot;rootCategoryName&quot; property=&quot;rootCategoryName&quot;/&amp;gt;
        &amp;lt;result column=&quot;slogan&quot; property=&quot;slogan&quot;/&amp;gt;
        &amp;lt;result column=&quot;categoryImage&quot; property=&quot;categoryImage&quot;/&amp;gt;
        &amp;lt;result column=&quot;bgColor&quot; property=&quot;bgColor&quot;/&amp;gt;
        &amp;lt;collection property=&quot;productItemList&quot; ofType=&quot;com.liferunner.dto.IndexProductItemDTO&quot;&amp;gt;
            &amp;lt;id column=&quot;productId&quot; property=&quot;productId&quot;/&amp;gt;
            &amp;lt;result column=&quot;productName&quot; property=&quot;productName&quot;/&amp;gt;
            &amp;lt;result column=&quot;productMainImageUrl&quot; property=&quot;productMainImageUrl&quot;/&amp;gt;
            &amp;lt;result column=&quot;productCreateTime&quot; property=&quot;productCreateTime&quot;/&amp;gt;
        &amp;lt;/collection&amp;gt;
    &amp;lt;/resultMap&amp;gt;
    &amp;lt;select id=&quot;getIndexProductDtoList&quot; resultMap=&quot;IndexProductDTO&quot; parameterType=&quot;Map&quot;&amp;gt;
        SELECT
        c.id as rootCategoryId,
        c.name as rootCategoryName,
        c.slogan as slogan,
        c.category_image as categoryImage,
        c.bg_color as bgColor,
        p.id as productId,
        p.product_name as productName,
        pi.url as productMainImageUrl,
        p.created_time as productCreateTime
        FROM category c
        LEFT JOIN products p
        ON c.id = p.root_category_id
        LEFT JOIN products_img pi
        ON p.id = pi.product_id
        WHERE c.type = 1
        AND p.root_category_id = #{paramMap.rootCategoryId}
        AND pi.is_main = 1
        LIMIT 0,10;
    &amp;lt;/select&amp;gt;
&amp;lt;/mapper&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;service实现&quot;&gt;Service实现&lt;/h4&gt;
&lt;p&gt;在&lt;code&gt;service&lt;/code&gt;project 创建&lt;code&gt;com.liferunner.service.IProductService接口&lt;/code&gt;以及其实现类&lt;code&gt;com.liferunner.service.impl.ProductServiceImpl&lt;/code&gt;,添加查询方法如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface IProductService {

    /**
     * 根据一级分类id获取首页推荐的商品list
     *
     * @param rootCategoryId 一级分类id
     * @return 商品list
     */
    List&amp;lt;IndexProductDTO&amp;gt; getIndexProductDtoList(Integer rootCategoryId);
    ...
}

---
    
@Slf4j
@Service
@RequiredArgsConstructor(onConstructor = @__(@Autowired))
public class ProductServiceImpl implements IProductService {

    // RequiredArgsConstructor 构造器注入
    private final ProductCustomMapper productCustomMapper;

    @Transactional(propagation = Propagation.SUPPORTS)
    @Override
    public List&amp;lt;IndexProductDTO&amp;gt; getIndexProductDtoList(Integer rootCategoryId) {
        log.info(&quot;====== ProductServiceImpl#getIndexProductDtoList(rootCategoryId) : {}=======&quot;, rootCategoryId);
        Map&amp;lt;String, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
        map.put(&quot;rootCategoryId&quot;, rootCategoryId);
        val indexProductDtoList = this.productCustomMapper.getIndexProductDtoList(map);
        if (CollectionUtils.isEmpty(indexProductDtoList)) {
            log.warn(&quot;ProductServiceImpl#getIndexProductDtoList未查询到任何商品信息&quot;);
        }
        log.info(&quot;查询结果：{}&quot;, indexProductDtoList);
        return indexProductDtoList;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;controller实现&quot;&gt;Controller实现&lt;/h4&gt;
&lt;p&gt;接着，在&lt;code&gt;com.liferunner.api.controller.IndexController&lt;/code&gt;中实现对外暴露的查询接口：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RestController
@RequestMapping(&quot;/index&quot;)
@Api(value = &quot;首页信息controller&quot;, tags = &quot;首页信息接口API&quot;)
@Slf4j
public class IndexController {
    ...
    @Autowired
    private IProductService productService;

    @GetMapping(&quot;/rootCategorys&quot;)
    @ApiOperation(value = &quot;查询一级分类&quot;, notes = &quot;查询一级分类&quot;)
    public JsonResponse findAllRootCategorys() {
        log.info(&quot;============查询一级分类==============&quot;);
        val categoryResponseDTOS = this.categoryService.getAllRootCategorys();
        if (CollectionUtils.isEmpty(categoryResponseDTOS)) {
            log.info(&quot;============未查询到任何分类==============&quot;);
            return JsonResponse.ok(Collections.EMPTY_LIST);
        }
        log.info(&quot;============一级分类查询result：{}==============&quot;, categoryResponseDTOS);
        return JsonResponse.ok(categoryResponseDTOS);
    }
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;test-api&quot;&gt;Test API&lt;/h4&gt;
&lt;p&gt;编写完成之后，我们需要对我们的代码进行测试验证，还是通过使用&lt;code&gt;RestService&lt;/code&gt;插件来实现，当然，大家也可以通过Postman来测试，结果如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/48397/201911/48397-20191122075924996-1852241189.png&quot; alt=&quot;根据一级分类查询商品列表&quot;/&gt;&lt;/p&gt;

&lt;p&gt;如开文之初我们看到的京东商品列表一样，我们先分析一下在商品列表页面都需要哪些元素信息？&lt;/p&gt;
&lt;h2 id=&quot;开发梳理-1&quot;&gt;开发梳理&lt;/h2&gt;
&lt;p&gt;商品列表的展示按照我们之前的分析，总共分为2大类:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;选择商品分类之后，展示当前分类下所有商品&lt;/li&gt;
&lt;li&gt;输入搜索关键词后，展示当前搜索到相关的所有商品&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在这两类中展示的商品列表数据，除了数据来源不同以外，其他元素基本都保持一致，那么我们是否可以使用统一的接口来根据参数实现隔离呢？ 理论上不存在问题，完全可以通过传参判断的方式进行数据回传，但是，在我们实现一些可预见的功能需求时，一定要给自己的开发预留后路，也就是我们常说的&lt;code&gt;可拓展性&lt;/code&gt;，基于此，我们会分开实现各自的接口，以便于后期的扩展。&lt;br/&gt;接着来分析在列表页中我们需要展示的元素，首先因为需要分上述两种情况，因此我们需要在我们API设计的时候分别处理，针对于&lt;br/&gt;1.分类的商品列表展示，需要传入的参数有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;分类id&lt;/li&gt;
&lt;li&gt;排序（在电商列表我们常见的几种排序（销量，价格等等））&lt;/li&gt;
&lt;li&gt;分页相关（因为我们不可能把数据库中所有的商品都取出来）
&lt;ul&gt;&lt;li&gt;PageNumber（当前第几页）&lt;/li&gt;
&lt;li&gt;PageSize（每页显示多少条数据）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;2.关键词查询商品列表，需要传入的参数有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;关键词&lt;/li&gt;
&lt;li&gt;排序（在电商列表我们常见的几种排序（销量，价格等等））&lt;/li&gt;
&lt;li&gt;分页相关（因为我们不可能把数据库中所有的商品都取出来）
&lt;ul&gt;&lt;li&gt;PageNumber（当前第几页）&lt;/li&gt;
&lt;li&gt;PageSize（每页显示多少条数据）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;需要在页面展示的信息有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;商品id(用于跳转商品详情使用)&lt;/li&gt;
&lt;li&gt;商品名称&lt;/li&gt;
&lt;li&gt;商品价格&lt;/li&gt;
&lt;li&gt;商品销量&lt;/li&gt;
&lt;li&gt;商品图片&lt;/li&gt;
&lt;li&gt;商品优惠&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;编码实现-1&quot;&gt;编码实现&lt;/h2&gt;
&lt;p&gt;根据上面我们的分析，接下来开始我们的编码：&lt;/p&gt;
&lt;h3 id=&quot;根据商品分类查询&quot;&gt;根据商品分类查询&lt;/h3&gt;
&lt;p&gt;根据我们的分析，肯定不会在一张表中把所有数据获取全，因此我们需要进行多表联查，故我们需要在自定义mapper中实现我们的功能查询.&lt;/p&gt;
&lt;h4 id=&quot;responsedto-实现&quot;&gt;ResponseDTO 实现&lt;/h4&gt;
&lt;p&gt;根据我们前面分析的前端需要展示的信息，我们来定义一个用于展示这些信息的对象&lt;code&gt;com.liferunner.dto.SearchProductDTO&lt;/code&gt;，代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class SearchProductDTO {
    private String productId;
    private String productName;
    private Integer sellCounts;
    private String imgUrl;
    private Integer priceDiscount;
    //商品优惠，我们直接计算之后返回优惠后价格
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;custom-mapper-实现&quot;&gt;Custom Mapper 实现&lt;/h4&gt;
&lt;p&gt;在&lt;code&gt;com.liferunner.custom.ProductCustomMapper.java&lt;/code&gt;中新增一个方法接口：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    List&amp;lt;SearchProductDTO&amp;gt; searchProductListByCategoryId(@Param(&quot;paramMap&quot;) Map&amp;lt;String, Object&amp;gt; paramMap);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同时，在&lt;code&gt;mapper/custom/ProductCustomMapper.xml&lt;/code&gt;中实现我们的查询方法：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;select id=&quot;searchProductListByCategoryId&quot; resultType=&quot;com.liferunner.dto.SearchProductDTO&quot; parameterType=&quot;Map&quot;&amp;gt;
        SELECT
        p.id as productId,
        p.product_name as productName,
        p.sell_counts as sellCounts,
        pi.url as imgUrl,
        tp.priceDiscount
        FROM products p
        LEFT JOIN products_img pi
        ON p.id = pi.product_id
        LEFT JOIN
        (
        SELECT product_id, MIN(price_discount) as priceDiscount
        FROM products_spec
        GROUP BY product_id
        ) tp
        ON tp.product_id = p.id
        WHERE pi.is_main = 1
        AND p.category_id = #{paramMap.categoryId}
        ORDER BY
        &amp;lt;choose&amp;gt;
            &amp;lt;when test=&quot;paramMap.sortby != null and paramMap.sortby == 'sell'&quot;&amp;gt;
                p.sell_counts DESC
            &amp;lt;/when&amp;gt;
            &amp;lt;when test=&quot;paramMap.sortby != null and paramMap.sortby == 'price'&quot;&amp;gt;
                tp.priceDiscount ASC
            &amp;lt;/when&amp;gt;
            &amp;lt;otherwise&amp;gt;
                p.created_time DESC
            &amp;lt;/otherwise&amp;gt;
        &amp;lt;/choose&amp;gt;
    &amp;lt;/select&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;主要来说明一下这里的&lt;code&gt;&amp;lt;choose&amp;gt;&lt;/code&gt;模块，以及为什么不使用&lt;code&gt;if&lt;/code&gt;标签。&lt;br/&gt;在有的时候，我们并不希望所有的条件都同时生效，而只是想从多个选项中选择一个，但是在使用&lt;code&gt;IF&lt;/code&gt;标签时，只要&lt;code&gt;test&lt;/code&gt;中的表达式为 &lt;code&gt;true&lt;/code&gt;，就会执行&lt;code&gt;IF&lt;/code&gt; 标签中的条件。MyBatis 提供了 &lt;code&gt;choose&lt;/code&gt; 元素。&lt;code&gt;IF&lt;/code&gt;标签是&lt;code&gt;与(and)&lt;/code&gt;的关系，而 choose 是&lt;code&gt;或(or)&lt;/code&gt;的关系。&lt;br/&gt;它的选择是按照顺序自上而下，一旦有任何一个满足条件，则选择退出。&lt;/p&gt;
&lt;h4 id=&quot;service-实现&quot;&gt;Service 实现&lt;/h4&gt;
&lt;p&gt;然后在service&lt;code&gt;com.liferunner.service.IProductService&lt;/code&gt;中添加方法接口：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    /**
     * 根据商品分类查询商品列表
     *
     * @param categoryId 分类id
     * @param sortby     排序方式
     * @param pageNumber 当前页码
     * @param pageSize   每页展示多少条数据
     * @return 通用分页结果视图
     */
    CommonPagedResult searchProductList(Integer categoryId, String sortby, Integer pageNumber, Integer pageSize);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在实现类&lt;code&gt;com.liferunner.service.impl.ProductServiceImpl&lt;/code&gt;中，实现上述方法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    // 方法重载
    @Override
    public CommonPagedResult searchProductList(Integer categoryId, String sortby, Integer pageNumber, Integer pageSize) {
        Map&amp;lt;String, Object&amp;gt; paramMap = new HashMap&amp;lt;&amp;gt;();
        paramMap.put(&quot;categoryId&quot;, categoryId);
        paramMap.put(&quot;sortby&quot;, sortby);
        // mybatis-pagehelper
        PageHelper.startPage(pageNumber, pageSize);
        val searchProductDTOS = this.productCustomMapper.searchProductListByCategoryId(paramMap);
        // 获取mybatis插件中获取到信息
        PageInfo&amp;lt;?&amp;gt; pageInfo = new PageInfo&amp;lt;&amp;gt;(searchProductDTOS);
        // 封装为返回到前端分页组件可识别的视图
        val commonPagedResult = CommonPagedResult.builder()
                .pageNumber(pageNumber)
                .rows(searchProductDTOS)
                .totalPage(pageInfo.getPages())
                .records(pageInfo.getTotal())
                .build();
        return commonPagedResult;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这里，我们使用到了一个&lt;code&gt;mybatis-pagehelper&lt;/code&gt;插件，会在下面的福利讲解中分解。&lt;/p&gt;
&lt;h4 id=&quot;controller-实现&quot;&gt;Controller 实现&lt;/h4&gt;
&lt;p&gt;继续在&lt;code&gt;com.liferunner.api.controller.ProductController&lt;/code&gt;中添加对外暴露的接口API：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@GetMapping(&quot;/searchByCategoryId&quot;)
    @ApiOperation(value = &quot;查询商品信息列表&quot;, notes = &quot;根据商品分类查询商品列表&quot;)
    public JsonResponse searchProductListByCategoryId(
        @ApiParam(name = &quot;categoryId&quot;, value = &quot;商品分类id&quot;, required = true, example = &quot;0&quot;)
        @RequestParam Integer categoryId,
        @ApiParam(name = &quot;sortby&quot;, value = &quot;排序方式&quot;, required = false)
        @RequestParam String sortby,
        @ApiParam(name = &quot;pageNumber&quot;, value = &quot;当前页码&quot;, required = false, example = &quot;1&quot;)
        @RequestParam Integer pageNumber,
        @ApiParam(name = &quot;pageSize&quot;, value = &quot;每页展示记录数&quot;, required = false, example = &quot;10&quot;)
        @RequestParam Integer pageSize
    ) {
        if (null == categoryId || categoryId == 0) {
            return JsonResponse.errorMsg(&quot;分类id错误！&quot;);
        }
        if (null == pageNumber || 0 == pageNumber) {
            pageNumber = DEFAULT_PAGE_NUMBER;
        }
        if (null == pageSize || 0 == pageSize) {
            pageSize = DEFAULT_PAGE_SIZE;
        }
        log.info(&quot;============根据分类:{} 搜索列表==============&quot;, categoryId);

        val searchResult = this.productService.searchProductList(categoryId, sortby, pageNumber, pageSize);
        return JsonResponse.ok(searchResult);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为我们的请求中，只会要求商品分类id是必填项，其余的调用方都可以不提供，但是如果不提供的话，我们系统就需要给定一些默认的参数来保证我们的系统正常稳定的运行，因此，我定义了&lt;code&gt;com.liferunner.api.controller.BaseController&lt;/code&gt;,用于存储一些公共的配置信息。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * BaseController for : controller 基类
 */
@Controller
public class BaseController {
    /**
     * 默认展示第1页
     */
    public final Integer DEFAULT_PAGE_NUMBER = 1;
    /**
     * 默认每页展示10条数据
     */
    public final Integer DEFAULT_PAGE_SIZE = 10;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;test-api-1&quot;&gt;Test API&lt;/h4&gt;
&lt;p&gt;测试的参数分别是：categoryId : 51 ，sortby : price，pageNumber : 1，pageSize : 5&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/48397/201911/48397-20191122075925210-760122496.png&quot; alt=&quot;根据分类id查询&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，我们查询到7条数据，总页数&lt;code&gt;totalPage&lt;/code&gt;为2，并且根据价格从小到大进行了排序，证明我们的编码是正确的。接下来，通过相同的代码逻辑，我们继续实现根据搜索关键词进行查询。&lt;/p&gt;
&lt;h3 id=&quot;根据关键词查询&quot;&gt;根据关键词查询&lt;/h3&gt;
&lt;h4 id=&quot;response-dto-实现&quot;&gt;Response DTO 实现&lt;/h4&gt;
&lt;p&gt;使用上面实现的&lt;code&gt;com.liferunner.dto.SearchProductDTO&lt;/code&gt;.&lt;/p&gt;
&lt;h4 id=&quot;custom-mapper-实现-1&quot;&gt;Custom Mapper 实现&lt;/h4&gt;
&lt;p&gt;在&lt;code&gt;com.liferunner.custom.ProductCustomMapper&lt;/code&gt;中新增方法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;List&amp;lt;SearchProductDTO&amp;gt; searchProductList(@Param(&quot;paramMap&quot;) Map&amp;lt;String, Object&amp;gt; paramMap);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在&lt;code&gt;mapper/custom/ProductCustomMapper.xml&lt;/code&gt;中添加查询SQL：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;select id=&quot;searchProductList&quot; resultType=&quot;com.liferunner.dto.SearchProductDTO&quot; parameterType=&quot;Map&quot;&amp;gt;
        SELECT
        p.id as productId,
        p.product_name as productName,
        p.sell_counts as sellCounts,
        pi.url as imgUrl,
        tp.priceDiscount
        FROM products p
        LEFT JOIN products_img pi
        ON p.id = pi.product_id
        LEFT JOIN
        (
        SELECT product_id, MIN(price_discount) as priceDiscount
        FROM products_spec
        GROUP BY product_id
        ) tp
        ON tp.product_id = p.id
        WHERE pi.is_main = 1
        &amp;lt;if test=&quot;paramMap.keyword != null and paramMap.keyword != ''&quot;&amp;gt;
            AND p.item_name LIKE &quot;%${paramMap.keyword}%&quot;
        &amp;lt;/if&amp;gt;
        ORDER BY
        &amp;lt;choose&amp;gt;
            &amp;lt;when test=&quot;paramMap.sortby != null and paramMap.sortby == 'sell'&quot;&amp;gt;
                p.sell_counts DESC
            &amp;lt;/when&amp;gt;
            &amp;lt;when test=&quot;paramMap.sortby != null and paramMap.sortby == 'price'&quot;&amp;gt;
                tp.priceDiscount ASC
            &amp;lt;/when&amp;gt;
            &amp;lt;otherwise&amp;gt;
                p.created_time DESC
            &amp;lt;/otherwise&amp;gt;
        &amp;lt;/choose&amp;gt;
    &amp;lt;/select&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;service-实现-1&quot;&gt;Service 实现&lt;/h4&gt;
&lt;p&gt;在&lt;code&gt;com.liferunner.service.IProductService&lt;/code&gt;中新增查询接口：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    /**
     * 查询商品列表
     *
     * @param keyword    查询关键词
     * @param sortby     排序方式
     * @param pageNumber 当前页码
     * @param pageSize   每页展示多少条数据
     * @return 通用分页结果视图
     */
    CommonPagedResult searchProductList(String keyword, String sortby, Integer pageNumber, Integer pageSize);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在&lt;code&gt;com.liferunner.service.impl.ProductServiceImpl&lt;/code&gt;实现上述接口方法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    @Override
    public CommonPagedResult searchProductList(String keyword, String sortby, Integer pageNumber, Integer pageSize) {
        Map&amp;lt;String, Object&amp;gt; paramMap = new HashMap&amp;lt;&amp;gt;();
        paramMap.put(&quot;keyword&quot;, keyword);
        paramMap.put(&quot;sortby&quot;, sortby);
        // mybatis-pagehelper
        PageHelper.startPage(pageNumber, pageSize);
        val searchProductDTOS = this.productCustomMapper.searchProductList(paramMap);
        // 获取mybatis插件中获取到信息
        PageInfo&amp;lt;?&amp;gt; pageInfo = new PageInfo&amp;lt;&amp;gt;(searchProductDTOS);
        // 封装为返回到前端分页组件可识别的视图
        val commonPagedResult = CommonPagedResult.builder()
                .pageNumber(pageNumber)
                .rows(searchProductDTOS)
                .totalPage(pageInfo.getPages())
                .records(pageInfo.getTotal())
                .build();
        return commonPagedResult;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述方法和之前&lt;code&gt;searchProductList(Integer categoryId, String sortby, Integer pageNumber, Integer pageSize)&lt;/code&gt;唯一的区别就是它是肯定搜索关键词来进行数据查询，使用重载的目的是为了我们后续不同类型的业务扩展而考虑的。&lt;/p&gt;
&lt;h4 id=&quot;controller-实现-1&quot;&gt;Controller 实现&lt;/h4&gt;
&lt;p&gt;在&lt;code&gt;com.liferunner.api.controller.ProductController&lt;/code&gt;中添加关键词搜索API：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    @GetMapping(&quot;/search&quot;)
    @ApiOperation(value = &quot;查询商品信息列表&quot;, notes = &quot;查询商品信息列表&quot;)
    public JsonResponse searchProductList(
        @ApiParam(name = &quot;keyword&quot;, value = &quot;搜索关键词&quot;, required = true)
        @RequestParam String keyword,
        @ApiParam(name = &quot;sortby&quot;, value = &quot;排序方式&quot;, required = false)
        @RequestParam String sortby,
        @ApiParam(name = &quot;pageNumber&quot;, value = &quot;当前页码&quot;, required = false, example = &quot;1&quot;)
        @RequestParam Integer pageNumber,
        @ApiParam(name = &quot;pageSize&quot;, value = &quot;每页展示记录数&quot;, required = false, example = &quot;10&quot;)
        @RequestParam Integer pageSize
    ) {
        if (StringUtils.isBlank(keyword)) {
            return JsonResponse.errorMsg(&quot;搜索关键词不能为空！&quot;);
        }
        if (null == pageNumber || 0 == pageNumber) {
            pageNumber = DEFAULT_PAGE_NUMBER;
        }
        if (null == pageSize || 0 == pageSize) {
            pageSize = DEFAULT_PAGE_SIZE;
        }
        log.info(&quot;============根据关键词:{} 搜索列表==============&quot;, keyword);

        val searchResult = this.productService.searchProductList(keyword, sortby, pageNumber, pageSize);
        return JsonResponse.ok(searchResult);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;test-api-2&quot;&gt;Test API&lt;/h4&gt;
&lt;p&gt;测试参数：keyword : 西凤，sortby : sell，pageNumber : 1，pageSize : 10&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/48397/201911/48397-20191122075925650-1726770316.png&quot; alt=&quot;测试关键词结果&quot;/&gt;&lt;br/&gt;根据销量排序正常，查询关键词正常，总条数32，每页10条，总共3页正常。&lt;/p&gt;

&lt;p&gt;在本节编码实现中，我们使用到了一个通用的mybatis分页插件&lt;code&gt;mybatis-pagehelper&lt;/code&gt;,接下来，我们来了解一下这个插件的基本情况。&lt;/p&gt;
&lt;h2 id=&quot;mybatis-pagehelper&quot;&gt;&lt;code&gt;mybatis-pagehelper&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;如果各位小伙伴使用过：&lt;a href=&quot;https://pagehelper.github.io/&quot;&gt;MyBatis 分页插件 PageHelper&lt;/a&gt;, 那么对于这个就很容易理解了，它其实就是基于&lt;a href=&quot;https://pagehelper.github.io/docs/interceptor/&quot;&gt;Executor 拦截器&lt;/a&gt;来实现的，当拦截到原始SQL之后，对SQL进行一次改造处理。&lt;br/&gt;我们来看看我们自己代码中的实现，根据springboot编码三部曲：&lt;/p&gt;
&lt;p&gt;1.添加依赖&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;        &amp;lt;!-- 引入mybatis-pagehelper 插件--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.github.pagehelper&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;pagehelper-spring-boot-starter&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.2.12&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有同学就要问了，为什么引入的这个依赖和我原来使用的不同？以前使用的是：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.github.pagehelper&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;pagehelper&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;5.1.10&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;答案就在这里：&lt;a href=&quot;https://github.com/pagehelper&quot;&gt;依赖传送门&lt;/a&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/48397/201911/48397-20191122075925846-1472508877.png&quot; alt=&quot;spring-boot-pagehelper&quot;/&gt;&lt;br/&gt;我们使用的是springboot进行的项目开发，既然使用的是springboot,那我们完全可以用到它的&lt;code&gt;自动装配&lt;/code&gt;特性,作者帮我们实现了这么一个&lt;a href=&quot;https://github.com/pagehelper/pagehelper-spring-boot&quot;&gt;自动装配的jar&lt;/a&gt;,我们只需要参考示例来编写就ok了。&lt;/p&gt;
&lt;p&gt;2.改配置&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;# mybatis 分页组件配置
pagehelper:
  helperDialect: mysql #插件支持12种数据库，选择类型
  supportMethodsArguments: true&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.改代码&lt;/p&gt;
&lt;p&gt;如下示例代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    @Override
    public CommonPagedResult searchProductList(String keyword, String sortby, Integer pageNumber, Integer pageSize) {
        Map&amp;lt;String, Object&amp;gt; paramMap = new HashMap&amp;lt;&amp;gt;();
        paramMap.put(&quot;keyword&quot;, keyword);
        paramMap.put(&quot;sortby&quot;, sortby);
        // mybatis-pagehelper
        PageHelper.startPage(pageNumber, pageSize);
        val searchProductDTOS = this.productCustomMapper.searchProductList(paramMap);
        // 获取mybatis插件中获取到信息
        PageInfo&amp;lt;?&amp;gt; pageInfo = new PageInfo&amp;lt;&amp;gt;(searchProductDTOS);
        // 封装为返回到前端分页组件可识别的视图
        val commonPagedResult = CommonPagedResult.builder()
                .pageNumber(pageNumber)
                .rows(searchProductDTOS)
                .totalPage(pageInfo.getPages())
                .records(pageInfo.getTotal())
                .build();
        return commonPagedResult;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在我们查询数据库之前，我们引入了一句&lt;code&gt;PageHelper.startPage(pageNumber, pageSize);&lt;/code&gt;,告诉mybatis我们要对查询进行分页处理，这个时候插件会启动一个拦截器&lt;code&gt;com.github.pagehelper.PageInterceptor&lt;/code&gt;,针对所有的&lt;code&gt;query&lt;/code&gt;进行拦截，添加自定义参数和添加查询数据总数。（后续我们会打印sql来证明。）&lt;/p&gt;
&lt;p&gt;当查询到结果之后，我们需要将我们查询到的结果通知给插件，也就是&lt;code&gt;PageInfo&amp;lt;?&amp;gt; pageInfo = new PageInfo&amp;lt;&amp;gt;(searchProductDTOS);&lt;/code&gt;（&lt;code&gt;com.github.pagehelper.PageInfo&lt;/code&gt;是对插件针对分页做的一个属性包装，具体可以查看&lt;a href=&quot;http://bbs.csdn.net/topics/360010907&quot;&gt;属性传送门&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;至此，我们的插件使用就已经结束了。但是为什么我们在后面又封装了一个对象来对外进行返回，而不是使用查询到的&lt;code&gt;PageInfo&lt;/code&gt;呢？这是因为我们实际开发过程中，为了数据结构的一致性做的一次结构封装，你也可不实现该步骤，都是对结果没有任何影响的。&lt;/p&gt;
&lt;h2 id=&quot;sql打印对比&quot;&gt;SQL打印对比&lt;/h2&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;2019-11-21 12:04:21 INFO  ProductController:134 - ============根据关键词:西凤 搜索列表==============
Creating a new SqlSession
SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@4ff449ba] was not registered for synchronization because synchronization is not active
JDBC Connection [HikariProxyConnection@1980420239 wrapping com.mysql.cj.jdbc.ConnectionImpl@563b22b1] will not be managed by Spring
==&amp;gt;  Preparing: SELECT count(0) FROM products p LEFT JOIN products_img pi ON p.id = pi.product_id LEFT JOIN (SELECT product_id, MIN(price_discount) AS priceDiscount FROM products_spec GROUP BY product_id) tp ON tp.product_id = p.id WHERE pi.is_main = 1 AND p.product_name LIKE &quot;%西凤%&quot; 
==&amp;gt; Parameters: 
&amp;lt;==    Columns: count(0)
&amp;lt;==        Row: 32
&amp;lt;==      Total: 1
==&amp;gt;  Preparing: SELECT p.id as productId, p.product_name as productName, p.sell_counts as sellCounts, pi.url as imgUrl, tp.priceDiscount FROM product p LEFT JOIN products_img pi ON p.id = pi.product_id LEFT JOIN ( SELECT product_id, MIN(price_discount) as priceDiscount FROM products_spec GROUP BY product_id ) tp ON tp.product_id = p.id WHERE pi.is_main = 1 AND p.product_name LIKE &quot;%西凤%&quot; ORDER BY p.sell_counts DESC LIMIT ? 
==&amp;gt; Parameters: 10(Integer)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以看到，我们的SQL中多了一个&lt;code&gt;SELECT count(0)&lt;/code&gt;，第二条SQL多了一个&lt;code&gt;LIMIT&lt;/code&gt;参数，在代码中，我们很明确的知道，我们并没有显示的去搜索总数和查询条数，可以确定它就是插件帮我们实现的。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/Isaac-Zhang/expensive-shop&quot;&gt;Github 传送门&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://gitee.com/IsaacZhang/expensive-shop&quot;&gt;Gitee 传送门&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;下一节我们将继续开发商品详情展示以及商品评价业务，在过程中使用到的任何开发组件，我都会通过专门的一节来进行介绍的，兄弟们末慌！&lt;/p&gt;
&lt;p&gt;gogogo！&lt;/p&gt;
</description>
<pubDate>Thu, 21 Nov 2019 23:59:00 +0000</pubDate>
<dc:creator>IsaacZhang</dc:creator>
<og:description>上文回顾 '上节' 我们实现了仿 的轮播广告以及商品分类的功能，并且讲解了不同的注入方式，本节我们将继续实现我们的电商主业务，商品信息的展示。 需求分析 首先，在我们开始本节编码之前，我们先来分析一下</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhangpan1244/p/11909515.html</dc:identifier>
</item>
<item>
<title>如何教会女友递归算法？ - 宜春</title>
<link>http://www.cnblogs.com/yichunguo/p/11909512.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yichunguo/p/11909512.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190904112822217.gif&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;一到周末就开始放荡自我，这不带着女朋友去万达电影院看电影（其实是由于整天呆在家敲代码硬是&lt;/p&gt;
&lt;p&gt;被女朋友强行拖拽去看电影，作为一个有理想的程序员，我想各位应该都能体谅我），一到电影院，&lt;/p&gt;
&lt;p&gt;女朋友说要买爆米花和可乐，我当时二话没说，臣本布衣躬耕于南阳，壤中羞涩，所以单买了爆米&lt;/p&gt;
&lt;p&gt;花，买完都不带回头看老板的那种，饮料喝多了不好，出门的时候我带了白开水，还得亏我长得销&lt;/p&gt;
&lt;p&gt;魂，乍一看就能看出是个社会精神小伙，女朋友也没多说什么，只是对我微了微笑（我估计是被我的&lt;/p&gt;
&lt;p&gt;颜值以及独到的见解所折服），刚坐下没多久，女朋友突然问我，咱们现在坐在第几排啊？电影院里&lt;/p&gt;
&lt;p&gt;面太黑了，看不清，没法数，这个时候，如果是你现在你怎么办？别忘了你我是程序员，这个可难不&lt;/p&gt;
&lt;p&gt;倒我，递归就开始排上用场了。于是我就问前面一排的人他是第几排，你想只要在他的数字上加一，&lt;/p&gt;
&lt;p&gt;就知道自己在哪一排了。但是，前面的人也看不清啊，所以他也问他前面的人。就这样一排一排往前&lt;/p&gt;
&lt;p&gt;问，直到问到第一排的人，说我在第一排，然后再这样一排一排再把数字传回来。直到你前面的人告&lt;/p&gt;
&lt;p&gt;诉你他在哪一排，于是你就知道答案了。这就是一个非常标准的递归求解问题的分解过程，去的过程&lt;/p&gt;
&lt;p&gt;叫“递”，回来的过程叫“归”。基本上，所有的递归问题都可以用递推公式来表示。我们用递推公式将&lt;/p&gt;
&lt;p&gt;它表示出来就是这样的&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;f ( n ) = f (n - 1) + 1 其中，f ( 1 ) = 1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;f(n)表示你想知道自己在哪一排，f(n-1)表示前面一排所在的排数，f(1)=1表示第一排的人知道自己在&lt;/p&gt;
&lt;p&gt;第一排。有了这个递推公式，我们就可以很轻松地将它改为递归代码，如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;int f(int n) {
  if (n == 1) return 1;
  return f(n-1) + 1;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;女朋友不懂递归，于是我给她讲递归需要满足的三个条件：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;1.一个问题的解可以分解为几个子问题的解&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;何为子问题？子问题就是数据规模更小的问题。就好比，在电影院，你要知道，“自己在哪一排”的问&lt;/p&gt;
&lt;p&gt;题，可以分解为“前一排的人在哪一排”这样一个子问题。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;2.这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;你求解“自己在哪一排”的思路，和前面一排人求解“自己在哪一排”的思路，是一模一样的。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;3.存在递归终止条件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;把问题分解为子问题，把子问题再分解为子子问题，一层一层分解下去，不能存在无限循环，这就需&lt;/p&gt;
&lt;p&gt;要有终止条件。就好比，第一排的人不需要再继续询问任何人，就知道自己在哪一排，也就是&lt;/p&gt;
&lt;p&gt;f(1)=1，这就是递归的终止条件。&lt;/p&gt;
&lt;h2 id=&quot;如何教女友敲递归代码&quot;&gt;如何教女友敲递归代码？&lt;/h2&gt;
&lt;p&gt;刚刚铺垫了这么多，现在我们来看，如何来教女友敲递归代码？个人觉得，写递归代码最关键的是写&lt;/p&gt;
&lt;p&gt;出递推公式，找到终止条件，剩下将递推公式转化为代码就很简单了。&lt;/p&gt;
&lt;p&gt;你先记住这个理论。我举一个例子，带你一步一步实现一个递归代码，帮你理解。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;假如这里有n个台阶，每次你可以跨1个台阶或者2个台阶，请问走这n个台阶有多少种走法？如果有7个台阶，你可以2，2，2，1这样子上去，也可以1，2，1，1，2这样子上去，总之走法有很多，那如何用编程求得总共有多少种走法呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们仔细想下，实际上，可以根据第一步的走法把所有走法分为两类，第一类是第一步走了1个台&lt;/p&gt;
&lt;p&gt;阶，另一类是第一步走了2个台阶。所以n个台阶的走法就等于先走1阶后，n-1个台阶的走法 加上先&lt;/p&gt;
&lt;p&gt;走2阶后，n-2个台阶的走法。用公式表示就是：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;f ( n ) = f (n - 1) + f ( n - 2 )&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有了递推公式，递归代码基本上就完成了一半。我们再来看下终止条件。当有一个台阶时，我们不需&lt;/p&gt;
&lt;p&gt;要再继续递归，就只有一种走法。所以f(1)=1。这个递归终止条件足够吗？我们可以用n=2，n=3这样&lt;/p&gt;
&lt;p&gt;比较小的数试验一下。&lt;/p&gt;
&lt;p&gt;n=2时，f(2)=f(1)+f(0)。如果递归终止条件只有一个f(1)=1，那f(2)就无法求解了。所以除了f(1)=1这一&lt;/p&gt;
&lt;p&gt;个递归终止条件外，还要有f(0)=1，表示走0个台阶有一种走法，不过这样子看起来就不符合正常的&lt;/p&gt;
&lt;p&gt;逻辑思维了。所以，我们可以把f(2)=2作为一种终止条件，表示走2个台阶，有两种走法，一步走完&lt;/p&gt;
&lt;p&gt;或者分两步来走。&lt;/p&gt;
&lt;p&gt;所以，递归终止条件就是f(1)=1，f(2)=2。这个时候，你可以再拿n=3，n=4来验证一下，这个终止条&lt;/p&gt;
&lt;p&gt;件是否足够并且正确。&lt;/p&gt;
&lt;p&gt;我们把递归终止条件和刚刚得到的递推公式放到一起就是这样的：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;f(1) = 1;
f(2) = 2;
f(n) = f(n-1)+f(n-2)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有了这个公式，我们转化成递归代码就简单多了。最终的递归代码是这样的：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;int f(int n) {
  if (n == 1) return 1;
  if (n == 2) return 2;
  return f(n-1) + f(n-2);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我总结一下，写递归代码的关键就是找到如何将&lt;span&gt;&lt;strong&gt;大问题分解为小问题&lt;/strong&gt;&lt;/span&gt;的规律，并且基于此&lt;span&gt;&lt;strong&gt;写出递推公式&lt;/strong&gt;&lt;/span&gt;，然后再&lt;span&gt;&lt;strong&gt;推敲终止条件&lt;/strong&gt;&lt;/span&gt;，最后将&lt;span&gt;&lt;strong&gt;递推公式和终止条件&lt;/strong&gt;&lt;/span&gt;翻译成代码。&lt;/p&gt;
&lt;p&gt;如果以后再遇到类似问题，A可以分解为若干子问题B、C、D情况，你可以假设子问题B、C、D已经&lt;/p&gt;
&lt;p&gt;解决，在此基础上思考如何解决问题A。而且，你只需要思考问题A与子问题B、C、D两层之间的关&lt;/p&gt;
&lt;p&gt;系即可，不需要一层一层往下思考子问题与子子问题，子子问题与子子子问题之间的关系。屏蔽掉递&lt;/p&gt;
&lt;p&gt;归细节，这样子理解起来就简单多了。&lt;/p&gt;
&lt;p&gt;因此，编写递归代码的关键是，&lt;span&gt;只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用关系，不要试图用人脑去分解递归的每个步骤&lt;/span&gt;。&lt;/p&gt;
&lt;h2 id=&quot;如何教女友玩转汉罗塔&quot;&gt;如何教女友玩转汉罗塔&lt;/h2&gt;
&lt;p&gt;好了，讲完了递归算法，再回到电影院，不说别的，我还真那么做了，我真问了前面一排的人他是第&lt;/p&gt;
&lt;p&gt;几排如果不清楚并让他跟我一样问他的上一排，显然，没循环到第三人，我差点被认为是神经病，差&lt;/p&gt;
&lt;p&gt;点没被几个社会精神小伙打si，座位事情暂时告一段落，话说这电影属实够无聊，于是我不知是趁热&lt;/p&gt;
&lt;p&gt;打铁，还是心血来潮，非要给女朋友玩一个汉罗塔游戏，我这暴脾气，刚实践递归算法被怼，是时候&lt;/p&gt;
&lt;p&gt;挽回形象了，不秀一把递归算法我就不得劲。就是这个游戏，至于游戏规则，我觉得你体验一两把绝&lt;/p&gt;
&lt;p&gt;对比我说的更加记忆深刻，&lt;a href=&quot;http://www.4399.com/flash/109504_1.htm&quot;&gt;点击蓝色字体进入汉罗塔游戏&lt;/a&gt;，别看4399觉得有点弱zhi，再怎么说也承&lt;/p&gt;
&lt;p&gt;载着童年&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190904105215293.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;果然，女朋友是个哈皮，刚过第三关就扑街了，这个时候，头冒五丈光芒的我身披金甲挺身而出（貌&lt;/p&gt;
&lt;p&gt;似有一点点小夸张，剧情需要嘛）一声不吭地敲了几行靓丽的代码&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class TestHanoi {

    public static void main(String[] args) {
        hanoi(5,'A','B','C');  //可以理解为5个圈或者第5关
    }
    
    /**
     * @param n     共有N个圈
     * @param A    开始的柱子
     * @param B 中间的柱子
     * @param C 目标的柱子
     * 无论有多少个圈，都认为只有两个。上面的所有圈和最下面一个圈。
     */
    public static void hanoi(int n,char A,char B,char C) {
        //只有一个圈。
        if(n==1) {
            System.out.println(&quot;第1个盘子从&quot;+A+&quot;移到&quot;+C);
        //无论有多少个圈，都认为只有两个。上面的所有圈和最下面一个圈。
        }else {
            //移动上面所有的圈到中间位置
            hanoi(n-1,A,C,B);
            //移动下面的圈
            System.out.println(&quot;第&quot;+n+&quot;个圈从&quot;+A+&quot;移到&quot;+C);
            //把上面的所有圈从中间位置移到目标位置
            hanoi(n-1,B,A,C);
        }
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;只要main方法一致行，对着结果移动即可，就跟开了挂一样的，其实汉罗塔问题核心关键是无论有多少个圈，都认为只有两个。上面的所有圈和最下面一个圈。&lt;img src=&quot;https://img-blog.csdnimg.cn/20190904111942623.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190904113016587.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;strong&gt;到这里，教女友敲递归算法代码，你学会了吗？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;哦豁，明天还是一个晴天~老天赐给宜春一个女朋友吧~毕竟我们程序员长得又帅敲代码又好看，是吧哥几个~~&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果本文对你有一点点帮助，那么请点个赞呗，谢谢~&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;最后，若有不足或者不正之处，欢迎指正批评，感激不尽！如果有疑问欢迎留言，绝对第一时间回复！&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;欢迎各位关注我的公众号，一起探讨技术，向往技术，追求技术，说好了来了就是盆友喔...&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191028085725979.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 21 Nov 2019 23:58:00 +0000</pubDate>
<dc:creator>宜春</dc:creator>
<og:description>一到周末就开始放荡自我，这不带着女朋友去万达电影院看电影（其实是由于整天呆在家敲代码硬是 被女朋友强行拖拽去看电影，作为一个有理想的程序员，我想各位应该都能体谅我），一到电影院， 女朋友说要买爆米花和</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yichunguo/p/11909512.html</dc:identifier>
</item>
<item>
<title>java中hashmap容量的初始化 - 杨冠标</title>
<link>http://www.cnblogs.com/yanggb/p/11613070.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yanggb/p/11613070.html</guid>
<description>&lt;p&gt;HashMap使用HashMap(int initialCapacity)对集合进行初始化。&lt;/p&gt;
&lt;p&gt;在默认的情况下，HashMap的容量是16。但是如果用户通过构造函数指定了一个数字作为容量，那么Hash会选择大于该数字的第一个2的幂作为容量。比如如果指定了3，则容量是4；如果指定了7，则容量是8；如果指定了9，则容量是16。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;为什么要设置HashMap的初始化容量&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在《阿里巴巴Java开发手册》中，有一条开发建议是建议我们设置HashMap的初始化容量。&lt;/p&gt;
&lt;p&gt;下面我们通过具体的代码来了解下为什么会这么建议。&lt;/p&gt;
&lt;p&gt;我们先来写一段代码在JDK1.7的环境下运行，来分别测试下，在不指定初始化容量和指定初始化容量的情况下性能情况的不同。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; aHundredMillion = 10000000&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 未初始化容量&lt;/span&gt;
    Map&amp;lt;Integer, Integer&amp;gt; map = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;&lt;span&gt;();
    &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; s1 =&lt;span&gt; System.currentTimeMillis();
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; aHundredMillion; i++&lt;span&gt;) {
        map.put(i, i);
    }
    &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; s2 =&lt;span&gt; System.currentTimeMillis();
    System.out.println(&lt;/span&gt;&quot;未初始化容量，耗时： &quot; + (s2 - s1)); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 14322

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化容量为50000000&lt;/span&gt;
    Map&amp;lt;Integer, Integer&amp;gt; map1 = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;(aHundredMillion / 2&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; s3 =&lt;span&gt; System.currentTimeMillis();
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; aHundredMillion; i++&lt;span&gt;) {
        map1.put(i, i);
    }
    &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; s4 =&lt;span&gt; System.currentTimeMillis();
    System.out.println(&lt;/span&gt;&quot;初始化容量5000000，耗时： &quot; + (s4 - s3)); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 11819

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化容量为100000000&lt;/span&gt;
    Map&amp;lt;Integer, Integer&amp;gt; map2 = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;&lt;span&gt;(aHundredMillion);
    &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; s5 =&lt;span&gt; System.currentTimeMillis();
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; aHundredMillion; i++&lt;span&gt;) {
        map2.put(i, i);
    }
    &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; s6 =&lt;span&gt; System.currentTimeMillis();
    System.out.println(&lt;/span&gt;&quot;初始化容量为10000000，耗时： &quot; + (s6 - s5)); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 7978&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从以上的代码不难理解，我们创建了3个HashMap，分别使用默认的容量（16）、使用元素个数的一半（5千万）作为初始容量和使用元素个数（一亿）作为初始容量进行初始化，然后分别向其中put一亿个KV。&lt;/p&gt;
&lt;p&gt;从上面的打印结果中可以得到一个初步的结论：在已知HashMap中将要存放的KV个数的时候，设置一个合理的初始化容量可以有效地提高性能。下面我们来简单分析一下原因。&lt;/p&gt;
&lt;p&gt;我们知道，HashMap是有扩容机制的。所谓的扩容机制，指的是当达到扩容条件的时候，HashMap就会自动进行扩容。而HashMap的扩容条件就是当HashMap中的元素个数（Size）超过临界值（Threshold）的情况下就会自动扩容。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
threshold = loadFactor * capacity
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在元素个数超过临界值的情况下，随着元素的不断增加，HashMap就会发生扩容，而HashMap中的扩容机制决定了每次扩容都需要重建hash表，这一操作需要消耗大量资源，是非常影响性能的。因此，如果我们没有设置初始的容量大小，HashMap就可能会不断发生扩容，也就使得程序的性能降低了。&lt;/p&gt;
&lt;p&gt;另外，在上面的代码中我们会发现，同样是设置了初始化容量，设置的数值不同也会影响性能，那么当我们已知HashMap中即将存放的KV个数的时候，容量的设置就成了一个问题。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;HashMap中容量的初始化&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;开头提到，在默认的情况下，当我们设置HashMap的初始化容量时，实际上HashMap会采用第一个大于该数值的2的幂作为初始化容量。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
Map&amp;lt;String, String&amp;gt; map = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;(1&lt;span&gt;);
map.put(&lt;/span&gt;&quot;huangq&quot;, &quot;yanggb&quot;&lt;span&gt;);

Class&lt;/span&gt;&amp;lt;?&amp;gt; mapType =&lt;span&gt; map.getClass();
Method capacity &lt;/span&gt;= mapType.getDeclaredMethod(&quot;capacity&quot;&lt;span&gt;);
capacity.setAccessible(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
System.out.println(&lt;/span&gt;&quot;capacity : &quot; + capacity.invoke(map)); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当初始化的容量设置成1的时候，通过反射取出来的capacity却是2。在JDK1.8中，如果我们传入的初始化容量为1，实际上设置的结果也是1。上面的代码打印的结果为2的原因，是代码中给map塞入值的操作导致了扩容，容量从1扩容到了2。事实上，在JDK1.7和JDK1.8中，HashMap初始化容量（capacity）的时机不同。在JDK1.8中，调用HashMap的构造函数定义HashMap的时候，就会进行容量的设定。而在JDK1.7中，要等到第一次put操作时才进行这一操作。&lt;/p&gt;
&lt;p&gt;因此，当我们通过HashMap(int initialCapacity)设置初始容量的时候，HashMap并不一定会直接采用我们传入的数值，而是经过计算，得到一个新值，目的是提高hash的效率。比如1-&amp;gt;1、3-&amp;gt;4、7-&amp;gt;8和9-&amp;gt;16。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;HashMap中初始容量的合理值&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;通过上面的分析我们可以知道，当我们使用HashMap(int initialCapacity)来初始化容量的时候，JDK会默认帮我们计算一个相对合理的值当做初始容量。那么，是不是我们只需要把已知的HashMap中即将存放的元素个数直接传给initialCapacity就可以了呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
initialCapacity = (需要存储的元素个数 / 负载因子) + 1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里的负载因子就是loaderFactor，默认值为0.75。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
initialCapacity = expectedSize / 0.75F + 1.0F
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面这个公式是《阿里巴巴Java开发手册》中的一个建议，在Guava中也是提供了相同的算法，更甚之，这个算法实际上是JDK8中putAll()方法的实现。这是公式的得出是因为，当HashMap内部维护的哈希表的容量达到75%时（默认情况下），就会触发rehash（重建hash表）操作。而rehash的过程是比较耗费时间的。所以初始化容量要设置成expectedSize/0.75 + 1的话，可以有效地减少冲突，也可以减小误差。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;当我们想要在代码中创建一个HashMap的时候，如果我们已知这个Map中即将存放的元素个数，给HashMap设置初始容量可以在一定程度上提升效率。&lt;/p&gt;
&lt;p&gt;但是，JDK并不会直接拿用户传进来的数字当做默认容量，而是会进行一番运算，最终得到一个2的幂。而为了最大程度地避免扩容带来的性能消耗，通常是建议可以把默认容量的数字设置成expectedSize / 0.75F + 1.0F。&lt;/p&gt;
&lt;p&gt;在日常开发中，可以使用Guava提供的一个方法来创建一个HashMap，计算的过程Guava会帮我们完成。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Map&amp;lt;String, String&amp;gt; map = Maps.newHashMapWithExpectedSize(10);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后要说的一点是，这种算法实际上是一种使用内存换取性能的做法，在真正的应用场景中要考虑到内存的影响。&lt;/p&gt;

&lt;p&gt;&quot;当你认真喜欢一个人的时候，你的全世界都是她。&quot;&lt;/p&gt;
</description>
<pubDate>Thu, 21 Nov 2019 22:05:00 +0000</pubDate>
<dc:creator>杨冠标</dc:creator>
<og:description>HashMap使用HashMap(int initialCapacity)对集合进行初始化。 在默认的情况下，HashMap的容量是16。但是如果用户通过构造函数指定了一个数字作为容量，那么Hash会</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yanggb/p/11613070.html</dc:identifier>
</item>
<item>
<title>linux与Windows进程控制 - LightningStar</title>
<link>http://www.cnblogs.com/harrypotterjackson/p/11908825.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/harrypotterjackson/p/11908825.html</guid>
<description>&lt;h2 id=&quot;进程管理控制&quot;&gt;进程管理控制&lt;/h2&gt;
&lt;p&gt;这里实现的是一个自定义timer用于统计子进程运行的时间。使用方式主要是&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;timer [-t seconds] command arguments&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例如要统计&lt;code&gt;ls&lt;/code&gt;的运行时间可以直接输入&lt;code&gt;timer ls&lt;/code&gt;，其后的&lt;code&gt;arguments&lt;/code&gt;是指所要运行的程序的参数。如：&lt;code&gt;timer ls -al&lt;/code&gt;。如果要指定程序运行多少时间，如5秒钟，可以输入&lt;code&gt;timer -t 5 ls -al&lt;/code&gt;。需要注意的是，该程序对输入没有做异常检测，所以要确保程序输入正确。&lt;/p&gt;
&lt;h2 id=&quot;linux&quot;&gt;Linux&lt;/h2&gt;
&lt;h4 id=&quot;程序思路&quot;&gt;程序思路&lt;/h4&gt;
&lt;ol readability=&quot;3.9857566765579&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;获取时间&lt;/p&gt;
&lt;p&gt;时间获取函数使用&lt;code&gt;gettimeofday&lt;/code&gt;，精度可以达到微秒&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;struct timeval{
     long tv_sec;*//秒*
     long tv_usec;*//微秒*
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;6.9740018570102&quot;&gt;
&lt;p&gt;子进程创建&lt;/p&gt;
&lt;ol readability=&quot;15.423298969072&quot;&gt;&lt;li readability=&quot;4.8347107438017&quot;&gt;
&lt;p&gt;&lt;code&gt;fork()&lt;/code&gt;函数&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
pid_t fork(void);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;fork&lt;/code&gt;调用失败则返回-1，调用成功则：&lt;/p&gt;
&lt;p&gt;fork函数会有两种返回值，一是为0，一是为正整数。若为0，则说明当前进程为子进程；若为正整数，则该进程为父进程且该值为子进程pid。关于进程控制的详细说明请参考：&lt;a href=&quot;https://www.cnblogs.com/harrypotterjackson/p/docs.linuxtone.org/ebooks/C&amp;amp;CPP/c/ch30s03.html&quot;&gt;进程控制&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;21&quot;&gt;
&lt;p&gt;&lt;code&gt;exec&lt;/code&gt;函数&lt;/p&gt;
&lt;p&gt;用fork创建子进程后执行的是和父进程相同的程序（但有可能执行不同的代码分支），子进程往往要调用一种exec函数以执行另一个程序。当进程调用一种exec函数时，该进程的用户空间代码和数据完全被新程序替换，从新程序的启动例程开始执行。调用exec并不创建新进程，所以调用exec前后该进程的id并未改变。&lt;br/&gt;其实有六种以exec开头的函数，统称exec函数：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;unistd.h&amp;gt;
int execl(const char *path, const char *arg, ...);
int execlp(const char *file, const char *arg, ...);
int execle(const char *path, const char *arg, ..., char *const envp[]);
int execv(const char *path, char *const argv[]);
int execvp(const char *file, char *const argv[]);
int execve(const char *path, char *const argv[], char *const envp[]);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这些函数如果调用成功则加载新的程序从启动代码开始执行，不再返回，如果调用出错则返回-1，所以exec函数只有出错的返回值而没有成功的返回值。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;code&gt;wait&lt;/code&gt;与&lt;code&gt;waitpid&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;一个进程在终止时会关闭所有文件描述符，释放在用户空间分配的内存，但它的PCB还保留着，内核在其中保存了一些信息：如果是正常终止则保存着退出状态，如果是异常终止则保存着导致该进程终止的信号是哪个。这个进程的父进程可以调用wait或waitpid获取这些信息，然后彻底清除掉这个进程。我们知道一个进程的退出状态可以在Shell中用特殊变量$?查看，因为Shell是它的父进程，当它终止时Shell调用wait或waitpid得到它的退出状态同时彻底清除掉这个进程。&lt;br/&gt;如果一个进程已经终止，但是它的父进程尚未调用wait或waitpid对它进行清理，这时的进程状态称为僵尸（Zombie）进程。任何进程在刚终止时都是僵尸进程，正常情况下，僵尸进程都立刻被父进程清理了。&lt;br/&gt;僵尸进程是不能用kill命令清除掉的，因为kill命令只是用来终止进程的，而僵尸进程已经终止了。&lt;br/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/wait.h&amp;gt;
pid_t wait(int *status);
pid_t waitpid(pid_t pid, int *status, int options);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;若调用成功则返回清理掉的子进程id，若调用出错则返回-1。父进程调用wait或waitpid时可能会：&lt;/p&gt;
&lt;p&gt;这两个函数的区别是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果父进程的所有子进程都还在运行，调用wait将使父进程阻塞，而调用waitpid时如果在options参数中指定WNOHANG可以使父进程不阻塞而立即返回0&lt;/li&gt;
&lt;li&gt;wait等待第一个终止的子进程，而waitpid可以通过pid参数指定等待哪一个子进程&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;​&lt;/p&gt;
&lt;h4 id=&quot;源代码&quot;&gt;源代码&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;timer源代码&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;math.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;sys/time.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;wait.h&amp;gt;
#include &amp;lt;ctime&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstring&amp;gt;
//程序假定输入完全正确，没有做异常处理
//mytime [-t number] 程序
using namespace std;
//调用系统时间
struct timeval time_start;
struct timeval time_end;

void printTime();

void newProcess(const char *child_process, char *argv[], double duration);

int main(int argc, char const *argv[])
{
    double duration = 0;
    char **arg;
    int step = 2;
    if (argc &amp;gt; 3 &amp;amp;&amp;amp; (strcmp((char *)&quot;-t&quot;, argv[1]) == 0)) //如果指定了运行时间
    {
        step = 4;
        duration = atof(argv[2]); //没有做异常处理
    }

    arg = new char *[argc - step + 1];
    for (int i = 0; i &amp;lt; argc - step; i++)
    {
        arg[i] = new char[100];
        strcpy(arg[i], argv[i + step]);
    }
    arg[argc - step] = NULL;

    newProcess(argv[step - 1], arg, duration);
    return 0;
}

void printTime()
{
    //用以记录进程运行的时间
    int time_use = 0;  // us
    int time_left = 0; // us
    int time_hour = 0, time_min = 0, time_sec = 0, time_ms = 0, time_us = 0;
    gettimeofday(&amp;amp;time_end, NULL);

    time_use = (time_end.tv_sec - time_start.tv_sec) * 1000000 + (time_end.tv_usec - time_start.tv_usec);
    time_hour = time_use / (60 * 60 * (int)pow(10, 6));
    time_left = time_use % (60 * 60 * (int)pow(10, 6));
    time_min = time_left / (60 * (int)pow(10, 6));
    time_left %= (60 * (int)pow(10, 6));
    time_sec = time_left / ((int)pow(10, 6));
    time_left %= ((int)pow(10, 6));
    time_ms = time_left / 1000;
    time_left %= 1000;
    time_us = time_left;
    printf(&quot;此程序运行的时间为：%d 小时, %d 分钟, %d 秒, %d 毫秒, %d 微秒\n&quot;, time_hour, time_min, time_sec, time_ms, time_us);
}

void newProcess(const char* child_process, char **argv, double duration)
{
    pid_t pid = fork();
    if (pid &amp;lt; 0) //出错
    {
        printf(&quot;创建子进程失败！&quot;);
        exit(1);
    }
    if (pid == 0) //子进程
    {
        execvp(child_process, argv);
    }
    else
    {
        if (abs(duration - 0) &amp;lt; 1e-6)
        {
            gettimeofday(&amp;amp;time_start, NULL);
            wait(NULL); //等待子进程结束
            printTime();
        }
        else
        {
            gettimeofday(&amp;amp;time_start, NULL);
            // printf(&quot;sleep: %lf\n&quot;, duration);
            waitpid(pid, NULL, WNOHANG);
            usleep(duration * 1000000); // sec to usec
            int kill_ret_val = kill(pid, SIGKILL);
            if (kill_ret_val == -1) // return -1, fail
            {
                printf(&quot;kill failed.\n&quot;);
                perror(&quot;kill&quot;);
            }
            else if (kill_ret_val == 0) // return 0, success
            {
                printf(&quot;process %d has been killed\n&quot;, pid);
            }
            printTime();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试源代码&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;ctime&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
using namespace std;
int main(int argc, char const *argv[])
{
    for(int n = 0; n &amp;lt; argc; n++)
    {
        printf(&quot;arg[%d]:%s\n&quot;,n, argv[n]);
    }
    sleep(5);
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;测试&quot;&gt;测试&lt;/h3&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li&gt;
&lt;p&gt;自行编写程序测试&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1653979/201911/1653979-20191122002202384-1573837414.png&quot; alt=&quot;1574351830016&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;系统程序测试&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1653979/201911/1653979-20191122002202710-1833783194.png&quot; alt=&quot;1574351915002&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;将timer加入环境变量&lt;/p&gt;
&lt;p&gt;这里仅进行了临时变量修改。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1653979/201911/1653979-20191122002206211-1121320256.png&quot; alt=&quot;1574352171410&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;windows&quot;&gt;Windows&lt;/h2&gt;
&lt;p&gt;在Windows下进行父子进程的创建和管理在api调用上相较Linux有一定难度，但实际上在使用管理上比Linux容易的多。&lt;/p&gt;
&lt;h3 id=&quot;createprocess&quot;&gt;CreateProcess&lt;/h3&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;Windows.h&amp;gt;
BOOL CreateProcessA(
  LPCSTR                lpApplicationName,
  LPSTR                 lpCommandLine,
  LPSECURITY_ATTRIBUTES lpProcessAttributes,
  LPSECURITY_ATTRIBUTES lpThreadAttributes,
  BOOL                  bInheritHandles,
  DWORD                 dwCreationFlags,
  LPVOID                lpEnvironment,
  LPCSTR                lpCurrentDirectory,
  LPSTARTUPINFOA        lpStartupInfo,
  LPPROCESS_INFORMATION lpProcessInformation
);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;源代码实现&quot;&gt;源代码实现&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;timer程序&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// 进程管理.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。
//

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;wchar.h&amp;gt;
#include &amp;lt;Windows.h&amp;gt;
#include &amp;lt;tchar.h&amp;gt;
using namespace std;


void printTime(SYSTEMTIME* start, SYSTEMTIME* end);
void newProcess(TCHAR* cWinDir, double duration);

int _tmain(int argc, TCHAR *argv[])
{
    TCHAR* cWinDir = new TCHAR[MAX_PATH];
    memset(cWinDir, sizeof(TCHAR) * MAX_PATH, 0);

    printf(&quot;argc:   %d\n&quot;, argc);

    int step = 1;
    double duration = 0;
    if (argc &amp;gt; 1)
    {
        if (argv[1][0] == TCHAR('-') &amp;amp;&amp;amp; argv[1][1] == TCHAR('t') &amp;amp;&amp;amp; argv[1][2] == TCHAR('\0'))
        {
            step = 3;
            duration = atof((char*)argv[2]);
        }
    }
    //printf(&quot;printf content start: %ls\n&quot;, argv[1]);
    int j = 0;
    for (int i = 0, h = 0; i &amp;lt; argc - step; i++)
    {
        wcscpy_s(cWinDir + j, MAX_PATH - j, argv[i + step]);
        for (h = 0; argv[i + step][h] != TCHAR('\0'); h++);
        j += h;
        cWinDir[j++] = ' ';
        //printf(&quot;%d : %d\n&quot;, i, j);
        //printf(&quot;printf content start: %ls\n&quot;, cWinDir);
    }
    cWinDir[j - 2] = TCHAR('\0');
    //printf(&quot;printf content start: %ls\n&quot;, cWinDir);

    newProcess(cWinDir,duration);

    return 0;
}


void printTime(SYSTEMTIME* start, SYSTEMTIME* end)
{
    int hours = end-&amp;gt;wHour - start-&amp;gt;wHour;
    int minutes = end-&amp;gt;wMinute - start-&amp;gt;wMinute;
    int seconds = end-&amp;gt;wSecond - start-&amp;gt;wSecond;
    int ms = end-&amp;gt;wMilliseconds - start-&amp;gt;wMilliseconds;
    if (ms &amp;lt; 0)
    {
        ms += 1000;
        seconds -= 1;
    }
    if (seconds &amp;lt; 0)
    {
        seconds += 60;
        minutes -= 1;
    }
    if (minutes &amp;lt; 0)
    {
        minutes += 60;
        hours -= 1;
    }
    //由于仅考虑在一天之内，不考虑小时会变成负数的情况
    printf(&quot;runtime: %02dhours %02dminutes %02dseconds %02dmilliseconds\n&quot;, hours, minutes, seconds, ms);
}

void newProcess(TCHAR* cWinDir, double duration)
{
    PROCESS_INFORMATION pi;
    STARTUPINFO si;
    ZeroMemory(&amp;amp;si, sizeof(si));
    si.cb = sizeof(si);
    ZeroMemory(&amp;amp;pi, sizeof(pi));
    

    SYSTEMTIME start_time, end_time;
    memset(&amp;amp;start_time, sizeof(SYSTEMTIME), 0);
    memset(&amp;amp;end_time, sizeof(SYSTEMTIME), 0);
    GetSystemTime(&amp;amp;start_time);

    if (CreateProcess(
        NULL,       //lpApplicationName.若为空，则lpCommandLine必须指定可执行程序
                    //若路径中存在空格，必须使用引号框定
        cWinDir,    //lpCommandLine
                    //若lpApplicationName为空，lpCommandLine长度不超过MAX_PATH
        NULL,       //指向一个SECURITY_ATTRIBUTES结构体，这个结构体决定是否返回的句柄可以被子进程继承，进程安全性
        NULL,       //  如果lpProcessAttributes参数为空（NULL），那么句柄不能被继承。&amp;lt;同上&amp;gt;，线程安全性
        false,      //  指示新进程是否从调用进程处继承了句柄。句柄可继承性
        0,          //  指定附加的、用来控制优先类和进程的创建的标识符（优先级）
                    //  CREATE_NEW_CONSOLE  新控制台打开子进程
                    //  CREATE_SUSPENDED    子进程创建后挂起，直到调用ResumeThread函数
        NULL,       //  指向一个新进程的环境块。如果此参数为空，新进程使用调用进程的环境。指向环境字符串
        NULL,       //  指定子进程的工作路径
        &amp;amp;si,        //  决定新进程的主窗体如何显示的STARTUPINFO结构体
        &amp;amp;pi         //  接收新进程的识别信息的PROCESS_INFORMATION结构体。进程线程以及句柄
    ))
    {
    }
    else
    {
        printf(&quot;CreateProcess failed (%d).\n&quot;, GetLastError());
        return;
    }


    //wait untill the child process exits
    if (abs(duration - 0) &amp;lt; 1e-6)
        WaitForSingleObject(pi.hProcess, INFINITE);//这里指定运行时间，单位毫秒
    else
        WaitForSingleObject(pi.hProcess, duration * 1000);

    GetSystemTime(&amp;amp;end_time);

    printTime(&amp;amp;start_time, &amp;amp;end_time);

    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试程序&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;Windows.h&amp;gt;
using namespace std;
int main(int argc, char* argv[])
{
    for (int n = 0; n &amp;lt; argc; n++)
    {
        printf(&quot;arg[%d]:%s\n&quot;, n, argv[n]);
    }
    Sleep(5*1000);
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;测试-1&quot;&gt;测试&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;
&lt;p&gt;自行编写程序测试&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1653979/201911/1653979-20191122002208277-1323864899.png&quot; alt=&quot;1574352549870&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;系统程序测试&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1653979/201911/1653979-20191122002208962-1876671015.png&quot; alt=&quot;1574352658762&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;添加至环境变量&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1653979/201911/1653979-20191122002210576-895999278.png&quot; alt=&quot;1574353167296&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
&lt;h3 id=&quot;windows-1&quot;&gt;Windows&lt;/h3&gt;
&lt;h3 id=&quot;linux-1&quot;&gt;Linux&lt;/h3&gt;
</description>
<pubDate>Thu, 21 Nov 2019 16:27:00 +0000</pubDate>
<dc:creator>LightningStar</dc:creator>
<og:description>进程管理控制 这里实现的是一个自定义timer用于统计子进程运行的时间。使用方式主要是 例如要统计 的运行时间可以直接输入 ，其后的 是指所要运行的程序的参数。如： 。如果要指定程序运行多少时间，如5</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/harrypotterjackson/p/11908825.html</dc:identifier>
</item>
<item>
<title>深入理解Kafka必知必会（2） - luozhiyun</title>
<link>http://www.cnblogs.com/luozhiyun/p/11909315.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/luozhiyun/p/11909315.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/luozhiyun/p/11811835.html&quot;&gt;深入理解Kafka必知必会（1）&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;kafka目前有哪些内部topic它们都有什么特征各自的作用又是什么&quot;&gt;Kafka目前有哪些内部topic，它们都有什么特征？各自的作用又是什么？&lt;/h3&gt;
&lt;p&gt;__consumer_offsets：作用是保存 Kafka 消费者的位移信息&lt;br/&gt;__transaction_state：用来存储事务日志消息&lt;/p&gt;
&lt;h3 id=&quot;优先副本是什么它有什么特殊的作用&quot;&gt;优先副本是什么？它有什么特殊的作用？&lt;/h3&gt;
&lt;p&gt;所谓的优先副本是指在AR集合列表中的第一个副本。&lt;br/&gt;理想情况下，优先副本就是该分区的leader 副本，所以也可以称之为 preferred leader。Kafka 要确保所有主题的优先副本在 Kafka 集群中均匀分布，这样就保证了所有分区的 leader 均衡分布。以此来促进集群的负载均衡，这一行为也可以称为“分区平衡”。&lt;/p&gt;
&lt;h3 id=&quot;kafka有哪几处地方有分区分配的概念简述大致的过程及原理&quot;&gt;Kafka有哪几处地方有分区分配的概念？简述大致的过程及原理&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;生产者的分区分配是指为每条消息指定其所要发往的分区。可以编写一个具体的类实现org.apache.kafka.clients.producer.Partitioner接口。&lt;/li&gt;
&lt;li&gt;消费者中的分区分配是指为消费者指定其可以消费消息的分区。Kafka 提供了消费者客户端参数 partition.assignment.strategy 来设置消费者与订阅主题之间的分区分配策略。&lt;/li&gt;
&lt;li&gt;分区副本的分配是指为集群制定创建主题时的分区副本分配方案，即在哪个 broker 中创建哪些分区的副本。kafka-topics.sh 脚本中提供了一个 replica-assignment 参数来手动指定分区副本的分配方案。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;简述kafka的日志目录结构&quot;&gt;简述Kafka的日志目录结构&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204119/201911/1204119-20191122000040480-372639560.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Kafka 中的消息是以主题为基本单位进行归类的，各个主题在逻辑上相互独立。每个主题又可以分为一个或多个分区。不考虑多副本的情况，一个分区对应一个日志（Log）。为了防止 Log 过大，Kafka 又引入了日志分段（LogSegment）的概念，将 Log 切分为多个 LogSegment，相当于一个巨型文件被平均分配为多个相对较小的文件。&lt;/p&gt;
&lt;p&gt;Log 和 LogSegment 也不是纯粹物理意义上的概念，Log 在物理上只以文件夹的形式存储，而每个 LogSegment 对应于磁盘上的一个日志文件和两个索引文件，以及可能的其他文件（比如以“.txnindex”为后缀的事务索引文件）&lt;/p&gt;
&lt;h3 id=&quot;kafka中有那些索引文件&quot;&gt;Kafka中有那些索引文件？&lt;/h3&gt;
&lt;p&gt;每个日志分段文件对应了两个索引文件，主要用来提高查找消息的效率。&lt;br/&gt;偏移量索引文件用来建立消息偏移量（offset）到物理地址之间的映射关系，方便快速定位消息所在的物理文件位置&lt;br/&gt;时间戳索引文件则根据指定的时间戳（timestamp）来查找对应的偏移量信息。&lt;/p&gt;
&lt;h3 id=&quot;如果我指定了一个offsetkafka怎么查找到对应的消息&quot;&gt;如果我指定了一个offset，Kafka怎么查找到对应的消息？&lt;/h3&gt;
&lt;p&gt;Kafka是通过seek() 方法来指定消费的，在执行seek() 方法之前要去执行一次poll()方法，等到分配到分区之后会去对应的分区的指定位置开始消费，如果指定的位置发生了越界，那么会根据auto.offset.reset 参数设置的情况进行消费。&lt;/p&gt;
&lt;h3 id=&quot;如果我指定了一个timestampkafka怎么查找到对应的消息&quot;&gt;如果我指定了一个timestamp，Kafka怎么查找到对应的消息？&lt;/h3&gt;
&lt;p&gt;Kafka提供了一个 offsetsForTimes() 方法，通过 timestamp 来查询与此对应的分区位置。offsetsForTimes() 方法的参数 timestampsToSearch 是一个 Map 类型，key 为待查询的分区，而 value 为待查询的时间戳，该方法会返回时间戳大于等于待查询时间的第一条消息对应的位置和时间戳，对应于 OffsetAndTimestamp 中的 offset 和 timestamp 字段。&lt;/p&gt;
&lt;h3 id=&quot;聊一聊你对kafka的log-retention的理解&quot;&gt;聊一聊你对Kafka的Log Retention的理解&lt;/h3&gt;
&lt;p&gt;日志删除（Log Retention）：按照一定的保留策略直接删除不符合条件的日志分段。&lt;br/&gt;我们可以通过 broker 端参数 log.cleanup.policy 来设置日志清理策略，此参数的默认值为“delete”，即采用日志删除的清理策略。&lt;/p&gt;
&lt;ol readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;基于时间&lt;br/&gt;日志删除任务会检查当前日志文件中是否有保留时间超过设定的阈值（retentionMs）来寻找可删除的日志分段文件集合（deletableSegments）retentionMs 可以通过 broker 端参数 log.retention.hours、log.retention.minutes 和 log.retention.ms 来配置，其中 log.retention.ms 的优先级最高，log.retention.minutes 次之，log.retention.hours 最低。默认情况下只配置了 log.retention.hours 参数，其值为168，故默认情况下日志分段文件的保留时间为7天。&lt;br/&gt;删除日志分段时，首先会从 Log 对象中所维护日志分段的跳跃表中移除待删除的日志分段，以保证没有线程对这些日志分段进行读取操作。然后将日志分段所对应的所有文件添加上“.deleted”的后缀（当然也包括对应的索引文件）。最后交由一个以“delete-file”命名的延迟任务来删除这些以“.deleted”为后缀的文件，这个任务的延迟执行时间可以通过 file.delete.delay.ms 参数来调配，此参数的默认值为60000，即1分钟。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;基于日志大小&lt;br/&gt;日志删除任务会检查当前日志的大小是否超过设定的阈值（retentionSize）来寻找可删除的日志分段的文件集合（deletableSegments）。&lt;br/&gt;retentionSize 可以通过 broker 端参数 log.retention.bytes 来配置，默认值为-1，表示无穷大。注意 log.retention.bytes 配置的是 Log 中所有日志文件的总大小，而不是单个日志分段（确切地说应该为 .log 日志文件）的大小。单个日志分段的大小由 broker 端参数 log.segment.bytes 来限制，默认值为1073741824，即 1GB。&lt;br/&gt;这个删除操作和基于时间的保留策略的删除操作相同。&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;基于日志起始偏移量&lt;br/&gt;基于日志起始偏移量的保留策略的判断依据是某日志分段的下一个日志分段的起始偏移量 baseOffset 是否小于等于 logStartOffset，若是，则可以删除此日志分段。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204119/201911/1204119-20191122000056481-1861985387.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如上图所示，假设 logStartOffset 等于25，日志分段1的起始偏移量为0，日志分段2的起始偏移量为11，日志分段3的起始偏移量为23，通过如下动作收集可删除的日志分段的文件集合 deletableSegments：&lt;/p&gt;
&lt;p&gt;从头开始遍历每个日志分段，日志分段1的下一个日志分段的起始偏移量为11，小于 logStartOffset 的大小，将日志分段1加入 deletableSegments。&lt;br/&gt;日志分段2的下一个日志偏移量的起始偏移量为23，也小于 logStartOffset 的大小，将日志分段2加入 deletableSegments。&lt;br/&gt;日志分段3的下一个日志偏移量在 logStartOffset 的右侧，故从日志分段3开始的所有日志分段都不会加入 deletableSegments。&lt;br/&gt;收集完可删除的日志分段的文件集合之后的删除操作同基于日志大小的保留策略和基于时间的保留策略相同&lt;/p&gt;
&lt;h3 id=&quot;聊一聊你对kafka的log-compaction的理解&quot;&gt;聊一聊你对Kafka的Log Compaction的理解&lt;/h3&gt;
&lt;p&gt;日志压缩（Log Compaction）：针对每个消息的 key 进行整合，对于有相同 key 的不同 value 值，只保留最后一个版本。&lt;br/&gt;如果要采用日志压缩的清理策略，就需要将 log.cleanup.policy 设置为“compact”，并且还需要将 log.cleaner.enable （默认值为 true）设定为 true。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204119/201911/1204119-20191122000109206-397224030.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如下图所示，Log Compaction 对于有相同 key 的不同 value 值，只保留最后一个版本。如果应用只关心 key 对应的最新 value 值，则可以开启 Kafka 的日志清理功能，Kafka 会定期将相同 key 的消息进行合并，只保留最新的 value 值。&lt;/p&gt;
&lt;h3 id=&quot;聊一聊你对kafka底层存储的理解&quot;&gt;聊一聊你对Kafka底层存储的理解&lt;/h3&gt;
&lt;h4 id=&quot;页缓存&quot;&gt;页缓存&lt;/h4&gt;
&lt;p&gt;页缓存是操作系统实现的一种主要的磁盘缓存，以此用来减少对磁盘 I/O 的操作。具体来说，就是把磁盘中的数据缓存到内存中，把对磁盘的访问变为对内存的访问。&lt;/p&gt;
&lt;p&gt;当一个进程准备读取磁盘上的文件内容时，操作系统会先查看待读取的数据所在的页（page）是否在页缓存（pagecache）中，如果存在（命中）则直接返回数据，从而避免了对物理磁盘的 I/O 操作；如果没有命中，则操作系统会向磁盘发起读取请求并将读取的数据页存入页缓存，之后再将数据返回给进程。&lt;/p&gt;
&lt;p&gt;同样，如果一个进程需要将数据写入磁盘，那么操作系统也会检测数据对应的页是否在页缓存中，如果不存在，则会先在页缓存中添加相应的页，最后将数据写入对应的页。被修改过后的页也就变成了脏页，操作系统会在合适的时间把脏页中的数据写入磁盘，以保持数据的一致性。&lt;/p&gt;
&lt;p&gt;用过 Java 的人一般都知道两点事实：对象的内存开销非常大，通常会是真实数据大小的几倍甚至更多，空间使用率低下；Java 的垃圾回收会随着堆内数据的增多而变得越来越慢。基于这些因素，使用文件系统并依赖于页缓存的做法明显要优于维护一个进程内缓存或其他结构，至少我们可以省去了一份进程内部的缓存消耗，同时还可以通过结构紧凑的字节码来替代使用对象的方式以节省更多的空间。&lt;/p&gt;
&lt;p&gt;此外，即使 Kafka 服务重启，页缓存还是会保持有效，然而进程内的缓存却需要重建。这样也极大地简化了代码逻辑，因为维护页缓存和文件之间的一致性交由操作系统来负责，这样会比进程内维护更加安全有效。&lt;/p&gt;
&lt;h4 id=&quot;零拷贝&quot;&gt;零拷贝&lt;/h4&gt;
&lt;p&gt;除了消息顺序追加、页缓存等技术，Kafka 还使用零拷贝（Zero-Copy）技术来进一步提升性能。所谓的零拷贝是指将数据直接从磁盘文件复制到网卡设备中，而不需要经由应用程序之手。零拷贝大大提高了应用程序的性能，减少了内核和用户模式之间的上下文切换。对 Linux 操作系统而言，零拷贝技术依赖于底层的 sendfile() 方法实现。对应于 Java 语言，FileChannal.transferTo() 方法的底层实现就是 sendfile() 方法。&lt;/p&gt;
&lt;h3 id=&quot;聊一聊kafka的延时操作的原理&quot;&gt;聊一聊Kafka的延时操作的原理&lt;/h3&gt;
&lt;p&gt;Kafka 中有多种延时操作，比如延时生产，还有延时拉取（DelayedFetch）、延时数据删除（DelayedDeleteRecords）等。&lt;br/&gt;延时操作创建之后会被加入延时操作管理器（DelayedOperationPurgatory）来做专门的处理。延时操作有可能会超时，每个延时操作管理器都会配备一个定时器（SystemTimer）来做超时管理，定时器的底层就是采用时间轮（TimingWheel）实现的。&lt;/p&gt;
&lt;h3 id=&quot;聊一聊kafka控制器的作用&quot;&gt;聊一聊Kafka控制器的作用&lt;/h3&gt;
&lt;p&gt;在 Kafka 集群中会有一个或多个 broker，其中有一个 broker 会被选举为控制器（Kafka Controller），它负责管理整个集群中所有分区和副本的状态。当某个分区的 leader 副本出现故障时，由控制器负责为该分区选举新的 leader 副本。当检测到某个分区的 ISR 集合发生变化时，由控制器负责通知所有broker更新其元数据信息。当使用 kafka-topics.sh 脚本为某个 topic 增加分区数量时，同样还是由控制器负责分区的重新分配。&lt;/p&gt;
&lt;h3 id=&quot;kafka的旧版scala的消费者客户端的设计有什么缺陷&quot;&gt;Kafka的旧版Scala的消费者客户端的设计有什么缺陷？&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204119/201911/1204119-20191122000122500-534809481.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图，旧版消费者客户端每个消费组（）在 ZooKeeper 中都维护了一个 /consumers//ids 路径，在此路径下使用临时节点记录隶属于此消费组的消费者的唯一标识（consumerIdString），/consumers//owner 路径下记录了分区和消费者的对应关系，/consumers//offsets 路径下记录了此消费组在分区中对应的消费位移。&lt;/p&gt;
&lt;p&gt;每个消费者在启动时都会在 /consumers//ids 和 /brokers/ids 路径上注册一个监听器。当 /consumers//ids 路径下的子节点发生变化时，表示消费组中的消费者发生了变化；当 /brokers/ids 路径下的子节点发生变化时，表示 broker 出现了增减。这样通过 ZooKeeper 所提供的 Watcher，每个消费者就可以监听消费组和 Kafka 集群的状态了。&lt;/p&gt;
&lt;p&gt;这种方式下每个消费者对 ZooKeeper 的相关路径分别进行监听，当触发再均衡操作时，一个消费组下的所有消费者会同时进行再均衡操作，而消费者之间并不知道彼此操作的结果，这样可能导致 Kafka 工作在一个不正确的状态。与此同时，这种严重依赖于 ZooKeeper 集群的做法还有两个比较严重的问题。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;羊群效应（Herd Effect）：所谓的羊群效应是指ZooKeeper 中一个被监听的节点变化，大量的 Watcher 通知被发送到客户端，导致在通知期间的其他操作延迟，也有可能发生类似死锁的情况。&lt;/li&gt;
&lt;li&gt;脑裂问题（Split Brain）：消费者进行再均衡操作时每个消费者都与 ZooKeeper 进行通信以判断消费者或broker变化的情况，由于 ZooKeeper 本身的特性，可能导致在同一时刻各个消费者获取的状态不一致，这样会导致异常问题发生。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;消费再均衡的原理是什么提示消费者协调器和消费组协调器&quot;&gt;消费再均衡的原理是什么？（提示：消费者协调器和消费组协调器）&lt;/h3&gt;
&lt;p&gt;就目前而言，一共有如下几种情形会触发再均衡的操作：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;有新的消费者加入消费组。&lt;/li&gt;
&lt;li&gt;有消费者宕机下线。消费者并不一定需要真正下线，例如遇到长时间的GC、网络延迟导致消费者长时间未向 GroupCoordinator 发送心跳等情况时，GroupCoordinator 会认为消费者已经下线。&lt;/li&gt;
&lt;li&gt;有消费者主动退出消费组（发送 LeaveGroupRequest 请求）。比如客户端调用了 unsubscrible() 方法取消对某些主题的订阅。&lt;/li&gt;
&lt;li&gt;消费组所对应的 GroupCoorinator 节点发生了变更。&lt;/li&gt;
&lt;li&gt;消费组内所订阅的任一主题或者主题的分区数量发生变化。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;GroupCoordinator 是 Kafka 服务端中用于管理消费组的组件。而消费者客户端中的 ConsumerCoordinator 组件负责与 GroupCoordinator 进行交互。&lt;/p&gt;
&lt;h4 id=&quot;第一阶段find_coordinator&quot;&gt;第一阶段（FIND_COORDINATOR）&lt;/h4&gt;
&lt;p&gt;消费者需要确定它所属的消费组对应的 GroupCoordinator 所在的 broker，并创建与该 broker 相互通信的网络连接。如果消费者已经保存了与消费组对应的 GroupCoordinator 节点的信息，并且与它之间的网络连接是正常的，那么就可以进入第二阶段。否则，就需要向集群中的某个节点发送 FindCoordinatorRequest 请求来查找对应的 GroupCoordinator，这里的“某个节点”并非是集群中的任意节点，而是负载最小的节点。&lt;/p&gt;
&lt;h4 id=&quot;第二阶段join_group&quot;&gt;第二阶段（JOIN_GROUP）&lt;/h4&gt;
&lt;p&gt;在成功找到消费组所对应的 GroupCoordinator 之后就进入加入消费组的阶段，在此阶段的消费者会向 GroupCoordinator 发送 JoinGroupRequest 请求，并处理响应。&lt;/p&gt;
&lt;p&gt;选举消费组的leader&lt;br/&gt;如果消费组内还没有 leader，那么第一个加入消费组的消费者即为消费组的 leader。如果某一时刻 leader 消费者由于某些原因退出了消费组，那么会重新选举一个新的 leader&lt;/p&gt;
&lt;p&gt;选举分区分配策略&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;收集各个消费者支持的所有分配策略，组成候选集 candidates。&lt;/li&gt;
&lt;li&gt;每个消费者从候选集 candidates 中找出第一个自身支持的策略，为这个策略投上一票。&lt;/li&gt;
&lt;li&gt;计算候选集中各个策略的选票数，选票数最多的策略即为当前消费组的分配策略。&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;第三阶段sync_group&quot;&gt;第三阶段（SYNC_GROUP）&lt;/h4&gt;
&lt;p&gt;leader 消费者根据在第二阶段中选举出来的分区分配策略来实施具体的分区分配，在此之后需要将分配的方案同步给各个消费者，通过 GroupCoordinator 这个“中间人”来负责转发同步分配方案的。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204119/201911/1204119-20191122000135707-293241564.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;第四阶段heartbeat&quot;&gt;第四阶段（HEARTBEAT）&lt;/h4&gt;
&lt;p&gt;进入这个阶段之后，消费组中的所有消费者就会处于正常工作状态。在正式消费之前，消费者还需要确定拉取消息的起始位置。假设之前已经将最后的消费位移提交到了 GroupCoordinator，并且 GroupCoordinator 将其保存到了 Kafka 内部的 __consumer_offsets 主题中，此时消费者可以通过 OffsetFetchRequest 请求获取上次提交的消费位移并从此处继续消费。&lt;/p&gt;
&lt;p&gt;消费者通过向 GroupCoordinator 发送心跳来维持它们与消费组的从属关系，以及它们对分区的所有权关系。只要消费者以正常的时间间隔发送心跳，就被认为是活跃的，说明它还在读取分区中的消息。心跳线程是一个独立的线程，可以在轮询消息的空档发送心跳。如果消费者停止发送心跳的时间足够长，则整个会话就被判定为过期，GroupCoordinator 也会认为这个消费者已经死亡，就会触发一次再均衡行为。&lt;/p&gt;
&lt;h3 id=&quot;kafka中的幂等是怎么实现的&quot;&gt;Kafka中的幂等是怎么实现的？&lt;/h3&gt;
&lt;p&gt;为了实现生产者的幂等性，Kafka 为此引入了 producer id（以下简称 PID）和序列号（sequence number）这两个概念。&lt;/p&gt;
&lt;p&gt;每个新的生产者实例在初始化的时候都会被分配一个 PID，这个 PID 对用户而言是完全透明的。对于每个 PID，消息发送到的每一个分区都有对应的序列号，这些序列号从0开始单调递增。生产者每发送一条消息就会将 &amp;lt;PID，分区&amp;gt; 对应的序列号的值加1。&lt;/p&gt;
&lt;p&gt;broker 端会在内存中为每一对 &amp;lt;PID，分区&amp;gt; 维护一个序列号。对于收到的每一条消息，只有当它的序列号的值（SN_new）比 broker 端中维护的对应的序列号的值（SN_old）大1（即 SN_new = SN_old + 1）时，broker 才会接收它。如果 SN_new&amp;lt; SN_old + 1，那么说明消息被重复写入，broker 可以直接将其丢弃。如果 SN_new&amp;gt; SN_old + 1，那么说明中间有数据尚未写入，出现了乱序，暗示可能有消息丢失，对应的生产者会抛出 OutOfOrderSequenceException，这个异常是一个严重的异常，后续的诸如 send()、beginTransaction()、commitTransaction() 等方法的调用都会抛出 IllegalStateException 的异常。&lt;/p&gt;
</description>
<pubDate>Thu, 21 Nov 2019 16:02:00 +0000</pubDate>
<dc:creator>luozhiyun</dc:creator>
<og:description>'深入理解Kafka必知必会（1）' Kafka目前有哪些内部topic，它们都有什么特征？各自的作用又是什么？ __consumer_offsets：作用是保存 Kafka 消费者的位移信息 __t</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/luozhiyun/p/11909315.html</dc:identifier>
</item>
<item>
<title>星际争霸2 AI开发(持续更新) - Rest探路者</title>
<link>http://www.cnblogs.com/Java-Starter/p/11789858.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Java-Starter/p/11789858.html</guid>
<description>&lt;h2 id=&quot;准备&quot;&gt;准备&lt;/h2&gt;
&lt;p&gt;我的环境是python3.6,sc2包0.11.1&lt;br/&gt;机器学习包下载链接：&lt;a href=&quot;https://github.com/deepmind/pysc2&quot;&gt;pysc2&lt;/a&gt;&lt;br/&gt;地图下载链接&lt;a href=&quot;https://github.com/Blizzard/s2client-proto#downloads&quot;&gt;maps&lt;/a&gt;&lt;br/&gt;pysc2是DeepMind开发的星际争霸Ⅱ学习环境。 它是封装星际争霸Ⅱ机器学习API，同时也提供Python增强学习环境。&lt;br/&gt;以神族为例编写代码，神族建筑科技图如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201453/201911/1201453-20191111020642716-1578190460.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;采矿&quot;&gt;采矿&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# -*- encoding: utf-8 -*-
'''
@File    :   __init__.py.py    
@Modify Time      @Author       @Desciption
------------      -------       -----------
2019/11/3 12:32   Jonas           None
'''

import sc2
from sc2 import run_game, maps, Race, Difficulty
from sc2.player import Bot, Computer


class SentdeBot(sc2.BotAI):
    async def on_step(self, iteration: int):
        await self.distribute_workers()


run_game(maps.get(&quot;AcidPlantLE&quot;), [
    Bot(Race.Protoss, SentdeBot()), Computer(Race.Terran, Difficulty.Easy)
],realtime = True)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;br/&gt;game_data.py的&lt;code&gt;assert self.id != 0&lt;/code&gt;注释掉&lt;br/&gt;pixel_map.py的&lt;code&gt;assert self.bits_per_pixel % 8 == 0, &quot;Unsupported pixel density&quot;&lt;/code&gt;注释掉&lt;br/&gt;否则会报错&lt;/p&gt;
&lt;p&gt;运行结果如下，农民开始采矿&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201453/201911/1201453-20191104004907454-545075471.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以正常采矿&lt;/p&gt;
&lt;h2 id=&quot;建造农民和水晶塔&quot;&gt;建造农民和水晶塔&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import sc2
from sc2 import run_game, maps, Race, Difficulty
from sc2.player import Bot, Computer
from sc2.constants import *


class SentdeBot(sc2.BotAI):
    async def on_step(self, iteration: int):
        await self.distribute_workers()
        await self.build_workers()
        await self.build_pylons()

    # 建造农民
    async def build_workers(self):
        # 星灵枢纽(NEXUS)无队列建造，可以提高晶体矿的利用率，不至于占用资源
        for nexus in self.units(UnitTypeId.NEXUS).ready.noqueue:
            # 是否有50晶体矿
            if self.can_afford(UnitTypeId.PROBE):
                await self.do(nexus.train(UnitTypeId.PROBE))

    ## 建造水晶
    async def build_pylons(self):
        ## 供应人口和现有人口之差小于5且水晶不是正在建造
        if self.supply_left&amp;lt;5 and not self.already_pending(UnitTypeId.PYLON):
            nexuses = self.units(UnitTypeId.NEXUS).ready
            if nexuses.exists:
                if self.can_afford(UnitTypeId.PYLON):
                    await self.build(UnitTypeId.PYLON,near=nexuses.first)

## 启动游戏
run_game(maps.get(&quot;AcidPlantLE&quot;), [
    Bot(Race.Protoss, SentdeBot()), Computer(Race.Terran, Difficulty.Easy)
],realtime = True)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果如下，基地造农民，农民造水晶&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201453/201911/1201453-20191104010608035-279973728.gif&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;收集气体和开矿&quot;&gt;收集气体和开矿&lt;/h2&gt;
&lt;p&gt;代码如下&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import sc2
from sc2 import run_game, maps, Race, Difficulty
from sc2.player import Bot, Computer
from sc2.constants import *


class SentdeBot(sc2.BotAI):
    async def on_step(self, iteration: int):
        await self.distribute_workers()
        await self.build_workers()
        await self.build_pylons()
        await self.build_assimilators()
        await self.expand()

    # 建造农民
    async def build_workers(self):
        # 星灵枢纽(NEXUS)无队列建造，可以提高晶体矿的利用率，不至于占用资源
        for nexus in self.units(UnitTypeId.NEXUS).ready.noqueue:
            # 是否有50晶体矿
            if self.can_afford(UnitTypeId.PROBE):
                await self.do(nexus.train(UnitTypeId.PROBE))

    ## 建造水晶
    async def build_pylons(self):
        ## 供应人口和现有人口之差小于5且建筑不是正在建造
        if self.supply_left &amp;lt; 5 and not self.already_pending(UnitTypeId.PYLON):
            nexuses = self.units(UnitTypeId.NEXUS).ready
            if nexuses.exists:
                if self.can_afford(UnitTypeId.PYLON):
                    await self.build(UnitTypeId.PYLON, near=nexuses.first)

    ## 建造吸收厂
    async def build_assimilators(self):
        for nexus in self.units(UnitTypeId.NEXUS).ready:
            # 在瓦斯泉上建造吸收厂
            vaspenes = self.state.vespene_geyser.closer_than(15.0,nexus)
            for vaspene in vaspenes:
                if not self.can_afford(UnitTypeId.ASSIMILATOR):
                    break
                worker = self.select_build_worker(vaspene.position)
                if worker is None:
                    break
                if not self.units(UnitTypeId.ASSIMILATOR).closer_than(1.0,vaspene).exists:
                    await self.do(worker.build(UnitTypeId.ASSIMILATOR,vaspene))

    ## 开矿
    async def expand(self):
        if self.units(UnitTypeId.NEXUS).amount&amp;lt;3 and self.can_afford(UnitTypeId.NEXUS):
            await self.expand_now()

## 启动游戏
run_game(maps.get(&quot;AcidPlantLE&quot;), [
    Bot(Race.Protoss, SentdeBot()), Computer(Race.Terran, Difficulty.Easy)
], realtime=False)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;run_game的realtime设置成False，可以在加速模式下运行游戏。&lt;br/&gt;运行效果如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201453/201911/1201453-20191111032527827-459090165.gif&quot;/&gt;&lt;br/&gt;可以建造吸收厂和开矿&lt;/p&gt;
&lt;h2 id=&quot;建造军队&quot;&gt;建造军队&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import sc2
from sc2 import run_game, maps, Race, Difficulty
from sc2.player import Bot, Computer
from sc2.constants import *


class SentdeBot(sc2.BotAI):
    async def on_step(self, iteration: int):
        await self.distribute_workers()
        await self.build_workers()
        await self.build_pylons()
        await self.build_assimilators()
        await self.expand()
        await self.offensive_force_buildings()
        await self.build_offensive_force()

    # 建造农民
    async def build_workers(self):
        # 星灵枢纽(NEXUS)无队列建造，可以提高晶体矿的利用率，不至于占用资源
        for nexus in self.units(UnitTypeId.NEXUS).ready.noqueue:
            # 是否有50晶体矿
            if self.can_afford(UnitTypeId.PROBE):
                await self.do(nexus.train(UnitTypeId.PROBE))

    ## 建造水晶
    async def build_pylons(self):
        ## 供应人口和现有人口之差小于5且建筑不是正在建造
        if self.supply_left &amp;lt; 5 and not self.already_pending(UnitTypeId.PYLON):
            nexuses = self.units(UnitTypeId.NEXUS).ready
            if nexuses.exists:
                if self.can_afford(UnitTypeId.PYLON):
                    await self.build(UnitTypeId.PYLON, near=nexuses.first)

    ## 建造吸收厂
    async def build_assimilators(self):
        for nexus in self.units(UnitTypeId.NEXUS).ready:
            # 在瓦斯泉上建造吸收厂
            vaspenes = self.state.vespene_geyser.closer_than(15.0,nexus)
            for vaspene in vaspenes:
                if not self.can_afford(UnitTypeId.ASSIMILATOR):
                    break
                worker = self.select_build_worker(vaspene.position)
                if worker is None:
                    break
                if not self.units(UnitTypeId.ASSIMILATOR).closer_than(1.0,vaspene).exists:
                    await self.do(worker.build(UnitTypeId.ASSIMILATOR,vaspene))

    ## 开矿
    async def expand(self):
        if self.units(UnitTypeId.NEXUS).amount&amp;lt;2 and self.can_afford(UnitTypeId.NEXUS):
            await self.expand_now()

    ## 建造进攻性建筑
    async def offensive_force_buildings(self):
        if self.units(UnitTypeId.PYLON).ready.exists:
            pylon = self.units(UnitTypeId.PYLON).ready.random
            if self.units(UnitTypeId.PYLON).ready.exists:
                # 根据神族建筑科技图，折跃门建造过后才可以建造控制核心
                if self.units(UnitTypeId.GATEWAY).ready.exists:
                    if not self.units(UnitTypeId.CYBERNETICSCORE):
                        if self.can_afford(UnitTypeId.CYBERNETICSCORE) and not self.already_pending(UnitTypeId.CYBERNETICSCORE):
                            await self.build(UnitTypeId.CYBERNETICSCORE,near = pylon)
                # 否则建造折跃门
                else:
                    if self.can_afford(UnitTypeId.GATEWAY) and not self.already_pending(UnitTypeId.GATEWAY):
                        await self.build(UnitTypeId.GATEWAY,near=pylon)

    # 造兵
    async def build_offensive_force(self):
        # 无队列化建造
        for gw in self.units(UnitTypeId.GATEWAY).ready.noqueue:
            if self.can_afford(UnitTypeId.STALKER) and self.supply_left&amp;gt;0:
                await self.do(gw.train(UnitTypeId.STALKER))



## 启动游戏
run_game(maps.get(&quot;AcidPlantLE&quot;), [
    Bot(Race.Protoss, SentdeBot()), Computer(Race.Terran, Difficulty.Easy)
], realtime=False)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201453/201911/1201453-20191111192134346-1642738686.gif&quot;/&gt;&lt;br/&gt;可以看到，我们建造了折跃门和控制核心并训练了追猎者&lt;/p&gt;
&lt;h2 id=&quot;控制部队进攻&quot;&gt;控制部队进攻&lt;/h2&gt;
&lt;p&gt;代码如下&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;
import sc2
from sc2 import run_game, maps, Race, Difficulty
from sc2.player import Bot, Computer
from sc2.constants import *
import random

class SentdeBot(sc2.BotAI):
    async def on_step(self, iteration: int):
        await self.distribute_workers()
        await self.build_workers()
        await self.build_pylons()
        await self.build_assimilators()
        await self.expand()
        await self.offensive_force_buildings()
        await self.build_offensive_force()
        await self.attack()

    # 建造农民
    async def build_workers(self):
        # 星灵枢纽(NEXUS)无队列建造，可以提高晶体矿的利用率，不至于占用资源
        for nexus in self.units(UnitTypeId.NEXUS).ready.noqueue:
            # 是否有50晶体矿
            if self.can_afford(UnitTypeId.PROBE):
                await self.do(nexus.train(UnitTypeId.PROBE))

    ## 建造水晶
    async def build_pylons(self):
        ## 供应人口和现有人口之差小于5且建筑不是正在建造
        if self.supply_left &amp;lt; 5 and not self.already_pending(UnitTypeId.PYLON):
            nexuses = self.units(UnitTypeId.NEXUS).ready
            if nexuses.exists:
                if self.can_afford(UnitTypeId.PYLON):
                    await self.build(UnitTypeId.PYLON, near=nexuses.first)

    ## 建造吸收厂
    async def build_assimilators(self):
        for nexus in self.units(UnitTypeId.NEXUS).ready:
            # 在瓦斯泉上建造吸收厂
            vaspenes = self.state.vespene_geyser.closer_than(15.0,nexus)
            for vaspene in vaspenes:
                if not self.can_afford(UnitTypeId.ASSIMILATOR):
                    break
                worker = self.select_build_worker(vaspene.position)
                if worker is None:
                    break
                if not self.units(UnitTypeId.ASSIMILATOR).closer_than(1.0,vaspene).exists:
                    await self.do(worker.build(UnitTypeId.ASSIMILATOR,vaspene))

    ## 开矿
    async def expand(self):
        if self.units(UnitTypeId.NEXUS).amount&amp;lt;3 and self.can_afford(UnitTypeId.NEXUS):
            await self.expand_now()

    ## 建造进攻性建筑
    async def offensive_force_buildings(self):
        if self.units(UnitTypeId.PYLON).ready.exists:
            pylon = self.units(UnitTypeId.PYLON).ready.random
            # 根据神族建筑科技图，折跃门建造过后才可以建造控制核心
            if self.units(UnitTypeId.GATEWAY).ready.exists and not self.units(UnitTypeId.CYBERNETICSCORE):
                if self.can_afford(UnitTypeId.CYBERNETICSCORE) and not self.already_pending(UnitTypeId.CYBERNETICSCORE):
                    await self.build(UnitTypeId.CYBERNETICSCORE,near = pylon)
            # 否则建造折跃门
            elif len(self.units(UnitTypeId.GATEWAY))&amp;lt;=3:
                if self.can_afford(UnitTypeId.GATEWAY) and not self.already_pending(UnitTypeId.GATEWAY):
                    await self.build(UnitTypeId.GATEWAY,near=pylon)

    ## 造兵
    async def build_offensive_force(self):
        # 无队列化建造
        for gw in self.units(UnitTypeId.GATEWAY).ready.noqueue:
            if self.can_afford(UnitTypeId.STALKER) and self.supply_left&amp;gt;0:
                await self.do(gw.train(UnitTypeId.STALKER))

    ## 寻找目标
    def find_target(self,state):
        if len(self.known_enemy_units)&amp;gt;0:
            # 随机选取敌方单位
            return random.choice(self.known_enemy_units)
        elif len(self.known_enemy_units)&amp;gt;0:
            # 随机选取敌方建筑
            return random.choice(self.known_enemy_structures)
        else:
            # 返回敌方出生点位
            return self.enemy_start_locations[0]

    ## 进攻
    async def attack(self):
        # 追猎者数量超过15个开始进攻
        if self.units(UnitTypeId.STALKER).amount&amp;gt;15:
            for s in self.units(UnitTypeId.STALKER).idle:
                await self.do(s.attack(self.find_target(self.state)))

        # 防卫模式：视野范围内存在敌人，开始攻击
        if self.units(UnitTypeId.STALKER).amount&amp;gt;5:
            if len(self.known_enemy_units)&amp;gt;0:
                for s in self.units(UnitTypeId.STALKER).idle:
                    await self.do(s.attack(random.choice(self.known_enemy_units)))

## 启动游戏
run_game(maps.get(&quot;AcidPlantLE&quot;), [
    Bot(Race.Protoss, SentdeBot()), Computer(Race.Terran, Difficulty.Medium)
], realtime=False)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果如下&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201453/201911/1201453-20191113043610981-1172163725.gif&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201453/201911/1201453-20191113042828987-1805943221.png&quot;/&gt;&lt;br/&gt;可以看到，4个折跃门训练追猎者并发动进攻。&lt;/p&gt;
&lt;h2 id=&quot;击败困难电脑&quot;&gt;击败困难电脑&lt;/h2&gt;
&lt;p&gt;我们目前的代码只能击败中等和简单电脑，那么如何击败困难电脑呢？&lt;br/&gt;代码如下&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;
import sc2
from sc2 import run_game, maps, Race, Difficulty
from sc2.player import Bot, Computer
from sc2.constants import *
import random


class SentdeBot(sc2.BotAI):
    def __init__(self):
        # 经过计算，每分钟大约165迭代次数
        self.ITERATIONS_PER_MINUTE = 165
        # 最大农民数量
        self.MAX_WORKERS = 65

    async def on_step(self, iteration: int):
        self.iteration = iteration
        await self.distribute_workers()
        await self.build_workers()
        await self.build_pylons()
        await self.build_assimilators()
        await self.expand()
        await self.offensive_force_buildings()
        await self.build_offensive_force()
        await self.attack()

    # 建造农民
    async def build_workers(self):
        # 星灵枢钮*16（一个基地配备16个农民）大于农民数量并且现有农民数量小于MAX_WORKERS
        if len(self.units(UnitTypeId.NEXUS))*16&amp;gt;len(self.units(UnitTypeId.PROBE)) and len(self.units(UnitTypeId.PROBE))&amp;lt;self.MAX_WORKERS:
                # 星灵枢纽(NEXUS)无队列建造，可以提高晶体矿的利用率，不至于占用资源
                for nexus in self.units(UnitTypeId.NEXUS).ready.noqueue:
                    # 是否有50晶体矿建造农民
                    if self.can_afford(UnitTypeId.PROBE):
                        await self.do(nexus.train(UnitTypeId.PROBE))

    ## 建造水晶
    async def build_pylons(self):
        ## 供应人口和现有人口之差小于5且建筑不是正在建造
        if self.supply_left &amp;lt; 5 and not self.already_pending(UnitTypeId.PYLON):
            nexuses = self.units(UnitTypeId.NEXUS).ready
            if nexuses.exists:
                if self.can_afford(UnitTypeId.PYLON):
                    await self.build(UnitTypeId.PYLON, near=nexuses.first)

    ## 建造吸收厂
    async def build_assimilators(self):
        for nexus in self.units(UnitTypeId.NEXUS).ready:
            # 在瓦斯泉上建造吸收厂
            vaspenes = self.state.vespene_geyser.closer_than(15.0,nexus)
            for vaspene in vaspenes:
                if not self.can_afford(UnitTypeId.ASSIMILATOR):
                    break
                worker = self.select_build_worker(vaspene.position)
                if worker is None:
                    break
                if not self.units(UnitTypeId.ASSIMILATOR).closer_than(1.0,vaspene).exists:
                    await self.do(worker.build(UnitTypeId.ASSIMILATOR,vaspene))

    ## 开矿
    async def expand(self):
        # (self.iteration / self.ITERATIONS_PER_MINUTE)是一个缓慢递增的值,动态开矿
        if self.units(UnitTypeId.NEXUS).amount&amp;lt;self.iteration / self.ITERATIONS_PER_MINUTE and self.can_afford(UnitTypeId.NEXUS):
            await self.expand_now()

    ## 建造进攻性建筑
    async def offensive_force_buildings(self):
        print(self.iteration / self.ITERATIONS_PER_MINUTE)
        if self.units(UnitTypeId.PYLON).ready.exists:
            pylon = self.units(UnitTypeId.PYLON).ready.random
            # 根据神族建筑科技图，折跃门建造过后才可以建造控制核心
            if self.units(UnitTypeId.GATEWAY).ready.exists and not self.units(UnitTypeId.CYBERNETICSCORE):
                if self.can_afford(UnitTypeId.CYBERNETICSCORE) and not self.already_pending(UnitTypeId.CYBERNETICSCORE):
                    await self.build(UnitTypeId.CYBERNETICSCORE, near=pylon)
            # 否则建造折跃门
            # (self.iteration / self.ITERATIONS_PER_MINUTE)/2 是一个缓慢递增的值
            elif len(self.units(UnitTypeId.GATEWAY)) &amp;lt; ((self.iteration / self.ITERATIONS_PER_MINUTE) / 2):
                if self.can_afford(UnitTypeId.GATEWAY) and not self.already_pending(UnitTypeId.GATEWAY):
                    await self.build(UnitTypeId.GATEWAY, near=pylon)
            # 控制核心存在的情况下建造星门
            if self.units(UnitTypeId.CYBERNETICSCORE).ready.exists:
                if len(self.units(UnitTypeId.STARGATE)) &amp;lt; ((self.iteration / self.ITERATIONS_PER_MINUTE) / 2):
                    if self.can_afford(UnitTypeId.STARGATE) and not self.already_pending(UnitTypeId.STARGATE):
                        await self.build(UnitTypeId.STARGATE, near=pylon)

    ## 造兵
    async def build_offensive_force(self):
        # 无队列化建造
        for gw in self.units(UnitTypeId.GATEWAY).ready.noqueue:
            if not self.units(UnitTypeId.STALKER).amount &amp;gt; self.units(UnitTypeId.VOIDRAY).amount:

                if self.can_afford(UnitTypeId.STALKER) and self.supply_left &amp;gt; 0:
                    await self.do(gw.train(UnitTypeId.STALKER))

        for sg in self.units(UnitTypeId.STARGATE).ready.noqueue:
            if self.can_afford(UnitTypeId.VOIDRAY) and self.supply_left &amp;gt; 0:
                await self.do(sg.train(UnitTypeId.VOIDRAY))

    ## 寻找目标
    def find_target(self,state):
        if len(self.known_enemy_units)&amp;gt;0:
            # 随机选取敌方单位
            return random.choice(self.known_enemy_units)
        elif len(self.known_enemy_units)&amp;gt;0:
            # 随机选取敌方建筑
            return random.choice(self.known_enemy_structures)
        else:
            # 返回敌方出生点位
            return self.enemy_start_locations[0]

    ## 进攻
    async def attack(self):
        # {UNIT: [n to fight, n to defend]}
        aggressive_units = {UnitTypeId.STALKER: [15, 5],
                            UnitTypeId.VOIDRAY: [8, 3]}

        for UNIT in aggressive_units:
            # 攻击模式
            if self.units(UNIT).amount &amp;gt; aggressive_units[UNIT][0] and self.units(UNIT).amount &amp;gt; aggressive_units[UNIT][
                1]:
                for s in self.units(UNIT).idle:
                    await self.do(s.attack(self.find_target(self.state)))
            # 防卫模式
            elif self.units(UNIT).amount &amp;gt; aggressive_units[UNIT][1]:
                if len(self.known_enemy_units) &amp;gt; 0:
                    for s in self.units(UNIT).idle:
                        await self.do(s.attack(random.choice(self.known_enemy_units)))
## 启动游戏
run_game(maps.get(&quot;AcidPlantLE&quot;), [
    Bot(Race.Protoss, SentdeBot()), Computer(Race.Terran, Difficulty.Hard)
], realtime=False)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果如下&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201453/201911/1201453-20191114022157776-1789834220.gif&quot;/&gt;&lt;br/&gt;可以看到，击败了困难人族电脑，但是电脑选择了rush战术，我们写得AI脚本会输掉游戏。显然，这不是最佳方案。&lt;br/&gt;“只有AI才能拯救我的胜率”，请看下文。&lt;/p&gt;
&lt;h2 id=&quot;采集地图数据&quot;&gt;采集地图数据&lt;/h2&gt;
&lt;p&gt;这次我们只造一个折跃门，全力通过星门造虚空光辉舰&lt;br/&gt;修改offensive_force_buildings(self)方法的判断&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;elif len(self.units(GATEWAY)) &amp;lt; 1:
                if self.can_afford(GATEWAY) and not self.already_pending(GATEWAY):
                    await self.build(GATEWAY, near=pylon)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注释或者删除build_offensive_force(self)的建造追猎者的代码&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;        ## 造兵
    async def build_offensive_force(self):
        # 无队列化建造
        # for gw in self.units(UnitTypeId.GATEWAY).ready.noqueue:
        #     if not self.units(UnitTypeId.STALKER).amount &amp;gt; self.units(UnitTypeId.VOIDRAY).amount:
        #
        #         if self.can_afford(UnitTypeId.STALKER) and self.supply_left &amp;gt; 0:
        #             await self.do(gw.train(UnitTypeId.STALKER))

        for sg in self.units(UnitTypeId.STARGATE).ready.noqueue:
            if self.can_afford(UnitTypeId.VOIDRAY) and self.supply_left &amp;gt; 0:
                await self.do(sg.train(UnitTypeId.VOIDRAY))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;attack(self)中的aggressive_units注释掉Stalker&lt;br/&gt;导入numpy和cv2库&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;game_data = np.zeros((self.game_info.map_size[1], self.game_info.map_size[0], 3), np.uint8)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;建立以地图Heigt为行，Width为列的三维矩阵&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;for nexus in self.units(NEXUS):
            nex_pos = nexus.position
            print(nex_pos)
            cv2.circle(game_data, (int(nex_pos[0]), int(nex_pos[1])), 10, (0, 255, 0), -1)  # BGR&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;遍历星灵枢纽，获取下一个位置，画圆，circle(承载圆的img, 圆心, 半径, 颜色, thickness=-1表示填充)&lt;br/&gt;接下来我们要垂直翻转三维矩阵，因为我们建立的矩阵左上角是原点(0,0)，纵坐标向下延申，横坐标向右延申。翻转之后就成了正常的坐标系。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;flipped = cv2.flip(game_data, 0)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;图像缩放，达到可视化最佳。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;        resized = cv2.resize(flipped, dsize=None, fx=2, fy=2)
        cv2.imshow('Intel', resized)
        cv2.waitKey(1)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至此，完整代码如下&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import sc2
from sc2 import run_game, maps, Race, Difficulty
from sc2.player import Bot, Computer
from sc2.constants import *
import random
import numpy as np
import cv2


class SentdeBot(sc2.BotAI):
    def __init__(self):
        # 经过计算，每分钟大约165迭代次数
        self.ITERATIONS_PER_MINUTE = 165
        # 最大农民数量
        self.MAX_WORKERS = 65

    async def on_step(self, iteration: int):
        self.iteration = iteration
        await self.distribute_workers()
        await self.build_workers()
        await self.build_pylons()
        await self.build_assimilators()
        await self.expand()
        await self.offensive_force_buildings()
        await self.build_offensive_force()
        await self.intel()
        await self.attack()

    async def intel(self):
        # 根据地图建立的三维矩阵
        game_data = np.zeros((self.game_info.map_size[1], self.game_info.map_size[0], 3), np.uint8)
        for nexus in self.units(UnitTypeId.NEXUS):
            nex_pos = nexus.position
            # circle(承载圆的img, 圆心, 半径, 颜色, thickness=-1表示填充)
            # 记录星灵枢纽的位置
            cv2.circle(game_data, (int(nex_pos[0]), int(nex_pos[1])), 10, (0, 255, 0), -1)
        # 图像翻转垂直镜像
        flipped = cv2.flip(game_data, 0)
        # 图像缩放
        # cv2.resize(原图像,输出图像的大小,width方向的缩放比例,height方向缩放的比例)
        resized = cv2.resize(flipped, dsize=None, fx=2, fy=2)
        cv2.imshow('Intel', resized)

        # cv2.waitKey(每Xms刷新图像)
        cv2.waitKey(1)

    # 建造农民
    async def build_workers(self):
        # 星灵枢钮*16（一个基地配备16个农民）大于农民数量并且现有农民数量小于MAX_WORKERS
        if len(self.units(UnitTypeId.NEXUS)) * 16 &amp;gt; len(self.units(UnitTypeId.PROBE)) and len(
                self.units(UnitTypeId.PROBE)) &amp;lt; self.MAX_WORKERS:
            # 星灵枢纽(NEXUS)无队列建造，可以提高晶体矿的利用率，不至于占用资源
            for nexus in self.units(UnitTypeId.NEXUS).ready.noqueue:
                # 是否有50晶体矿建造农民
                if self.can_afford(UnitTypeId.PROBE):
                    await self.do(nexus.train(UnitTypeId.PROBE))

    ## 建造水晶
    async def build_pylons(self):
        ## 供应人口和现有人口之差小于5且建筑不是正在建造
        if self.supply_left &amp;lt; 5 and not self.already_pending(UnitTypeId.PYLON):
            nexuses = self.units(UnitTypeId.NEXUS).ready
            if nexuses.exists:
                if self.can_afford(UnitTypeId.PYLON):
                    await self.build(UnitTypeId.PYLON, near=nexuses.first)

    ## 建造吸收厂
    async def build_assimilators(self):
        for nexus in self.units(UnitTypeId.NEXUS).ready:
            # 在瓦斯泉上建造吸收厂
            vaspenes = self.state.vespene_geyser.closer_than(15.0, nexus)
            for vaspene in vaspenes:
                if not self.can_afford(UnitTypeId.ASSIMILATOR):
                    break
                worker = self.select_build_worker(vaspene.position)
                if worker is None:
                    break
                if not self.units(UnitTypeId.ASSIMILATOR).closer_than(1.0, vaspene).exists:
                    await self.do(worker.build(UnitTypeId.ASSIMILATOR, vaspene))

    ## 开矿
    async def expand(self):
        # (self.iteration / self.ITERATIONS_PER_MINUTE)是一个缓慢递增的值,动态开矿
        if self.units(UnitTypeId.NEXUS).amount &amp;lt; self.iteration / self.ITERATIONS_PER_MINUTE and self.can_afford(
                UnitTypeId.NEXUS):
            await self.expand_now()

    ## 建造进攻性建筑
    async def offensive_force_buildings(self):
        print(self.iteration / self.ITERATIONS_PER_MINUTE)
        if self.units(UnitTypeId.PYLON).ready.exists:
            pylon = self.units(UnitTypeId.PYLON).ready.random
            # 根据神族建筑科技图，折跃门建造过后才可以建造控制核心
            if self.units(UnitTypeId.GATEWAY).ready.exists and not self.units(UnitTypeId.CYBERNETICSCORE):
                if self.can_afford(UnitTypeId.CYBERNETICSCORE) and not self.already_pending(UnitTypeId.CYBERNETICSCORE):
                    await self.build(UnitTypeId.CYBERNETICSCORE, near=pylon)
            # 否则建造折跃门
            # (self.iteration / self.ITERATIONS_PER_MINUTE)/2 是一个缓慢递增的值
            # elif len(self.units(UnitTypeId.GATEWAY)) &amp;lt; ((self.iteration / self.ITERATIONS_PER_MINUTE) / 2):
            elif len(self.units(UnitTypeId.GATEWAY)) &amp;lt; 1:
                if self.can_afford(UnitTypeId.GATEWAY) and not self.already_pending(UnitTypeId.GATEWAY):
                    await self.build(UnitTypeId.GATEWAY, near=pylon)
            # 控制核心存在的情况下建造星门
            if self.units(UnitTypeId.CYBERNETICSCORE).ready.exists:
                if len(self.units(UnitTypeId.STARGATE)) &amp;lt; ((self.iteration / self.ITERATIONS_PER_MINUTE) / 2):
                    if self.can_afford(UnitTypeId.STARGATE) and not self.already_pending(UnitTypeId.STARGATE):
                        await self.build(UnitTypeId.STARGATE, near=pylon)

    ## 造兵
    async def build_offensive_force(self):
        # 无队列化建造
        for sg in self.units(UnitTypeId.STARGATE).ready.noqueue:
            if self.can_afford(UnitTypeId.VOIDRAY) and self.supply_left &amp;gt; 0:
                await self.do(sg.train(UnitTypeId.VOIDRAY))

    ## 寻找目标
    def find_target(self, state):
        if len(self.known_enemy_units) &amp;gt; 0:
            # 随机选取敌方单位
            return random.choice(self.known_enemy_units)
        elif len(self.known_enemy_units) &amp;gt; 0:
            # 随机选取敌方建筑
            return random.choice(self.known_enemy_structures)
        else:
            # 返回敌方出生点位
            return self.enemy_start_locations[0]

    ## 进攻
    async def attack(self):
        # {UNIT: [n to fight, n to defend]}
        aggressive_units = {UnitTypeId.VOIDRAY: [8, 3]}

        for UNIT in aggressive_units:
            # 攻击模式
            if self.units(UNIT).amount &amp;gt; aggressive_units[UNIT][0] and self.units(UNIT).amount &amp;gt; aggressive_units[UNIT][1]:
                for s in self.units(UNIT).idle:
                    await self.do(s.attack(self.find_target(self.state)))
            # 防卫模式
            elif self.units(UNIT).amount &amp;gt; aggressive_units[UNIT][1]:
                if len(self.known_enemy_units) &amp;gt; 0:
                    for s in self.units(UNIT).idle:
                        await self.do(s.attack(random.choice(self.known_enemy_units)))


## 启动游戏
run_game(maps.get(&quot;AcidPlantLE&quot;), [
    Bot(Race.Protoss, SentdeBot()), Computer(Race.Terran, Difficulty.Hard)
], realtime=False)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果如下&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201453/201911/1201453-20191119022517282-1882042156.png&quot;/&gt;&lt;br/&gt;采集到了地图位置。&lt;/p&gt;
&lt;h2 id=&quot;侦察&quot;&gt;侦察&lt;/h2&gt;
&lt;p&gt;在intel(self)里创建一个字典draw_dict，UnitTypeId作为key,半径和颜色是value&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;
        draw_dict = {
            UnitTypeId.NEXUS: [15, (0, 255, 0)],
            UnitTypeId.PYLON: [3, (20, 235, 0)],
            UnitTypeId.PROBE: [1, (55, 200, 0)],
            UnitTypeId.ASSIMILATOR: [2, (55, 200, 0)],
            UnitTypeId.GATEWAY: [3, (200, 100, 0)],
            UnitTypeId.CYBERNETICSCORE: [3, (150, 150, 0)],
            UnitTypeId.STARGATE: [5, (255, 0, 0)],
            UnitTypeId.ROBOTICSFACILITY: [5, (215, 155, 0)],

            UnitTypeId.VOIDRAY: [3, (255, 100, 0)]
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;迭代同上&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;for unit_type in draw_dict:
            for unit in self.units(unit_type).ready:
                pos = unit.position
                cv2.circle(game_data, (int(pos[0]), int(pos[1])), draw_dict[unit_type][0], draw_dict[unit_type][1], -1)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;存储三族的主基地名称（星灵枢纽，指挥中心，孵化场），刻画敌方建筑。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 主基地名称
        main_base_names = [&quot;nexus&quot;, &quot;supplydepot&quot;, &quot;hatchery&quot;]
        # 记录敌方基地位置
        for enemy_building in self.known_enemy_structures:
            pos = enemy_building.position
            if enemy_building.name.lower() not in main_base_names:
                cv2.circle(game_data, (int(pos[0]), int(pos[1])), 5, (200, 50, 212), -1)
        for enemy_building in self.known_enemy_structures:
            pos = enemy_building.position
            if enemy_building.name.lower() in main_base_names:
                cv2.circle(game_data, (int(pos[0]), int(pos[1])), 15, (0, 0, 255), -1)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;刻画敌方单位，如果是农民画得小些，其他单位则画大些。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;        for enemy_unit in self.known_enemy_units:

            if not enemy_unit.is_structure:
                worker_names = [&quot;probe&quot;, &quot;scv&quot;, &quot;drone&quot;]
                # if that unit is a PROBE, SCV, or DRONE... it's a worker
                pos = enemy_unit.position
                if enemy_unit.name.lower() in worker_names:
                    cv2.circle(game_data, (int(pos[0]), int(pos[1])), 1, (55, 0, 155), -1)
                else:
                    cv2.circle(game_data, (int(pos[0]), int(pos[1])), 3, (50, 0, 215), -1)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在offensive_force_buildings(self)方法中添加建造机械台&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;            if self.units(CYBERNETICSCORE).ready.exists:
                if len(self.units(ROBOTICSFACILITY)) &amp;lt; 1:
                    if self.can_afford(ROBOTICSFACILITY) and not self.already_pending(ROBOTICSFACILITY):
                        await self.build(ROBOTICSFACILITY, near=pylon)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建scout()，训练Observer&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;async def scout(self):
        if len(self.units(OBSERVER)) &amp;gt; 0:
            scout = self.units(OBSERVER)[0]
            if scout.is_idle:
                enemy_location = self.enemy_start_locations[0]
                move_to = self.random_location_variance(enemy_location)
                print(move_to)
                await self.do(scout.move(move_to))

        else:
            for rf in self.units(ROBOTICSFACILITY).ready.noqueue:
                if self.can_afford(OBSERVER) and self.supply_left &amp;gt; 0:
                    await self.do(rf.train(OBSERVER))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;生成随机位置，很简单。意思是横坐标累计递增-0.2和0.2倍的横坐标，限制条件为如果x超过横坐标，那么就是横坐标最大值。&lt;br/&gt;纵坐标同理。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;    def random_location_variance(self, enemy_start_location):
        x = enemy_start_location[0]
        y = enemy_start_location[1]

        x += ((random.randrange(-20, 20))/100) * enemy_start_location[0]
        y += ((random.randrange(-20, 20))/100) * enemy_start_location[1]

        if x &amp;lt; 0:
            x = 0
        if y &amp;lt; 0:
            y = 0
        if x &amp;gt; self.game_info.map_size[0]:
            x = self.game_info.map_size[0]
        if y &amp;gt; self.game_info.map_size[1]:
            y = self.game_info.map_size[1]

        go_to = position.Point2(position.Pointlike((x,y)))
        return go_to&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;完整代码如下&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# -*- encoding: utf-8 -*-
'''
@File    :   demo.py
@Modify Time      @Author       @Desciption
------------      -------       -----------
2019/11/3 12:32   Jonas           None
'''

import sc2
from sc2 import run_game, maps, Race, Difficulty, position
from sc2.player import Bot, Computer
from sc2.constants import *
import random
import numpy as np
import cv2


class SentdeBot(sc2.BotAI):
    def __init__(self):
        # 经过计算，每分钟大约165迭代次数
        self.ITERATIONS_PER_MINUTE = 165
        # 最大农民数量
        self.MAX_WORKERS = 50

    async def on_step(self, iteration: int):
        self.iteration = iteration
        await self.scout()
        await self.distribute_workers()
        await self.build_workers()
        await self.build_pylons()
        await self.build_assimilators()
        await self.expand()
        await self.offensive_force_buildings()
        await self.build_offensive_force()
        await self.intel()
        await self.attack()

    ## 侦察
    async def scout(self):
        if len(self.units(UnitTypeId.OBSERVER)) &amp;gt; 0:
            scout = self.units(UnitTypeId.OBSERVER)[0]
            if scout.is_idle:
                enemy_location = self.enemy_start_locations[0]
                move_to = self.random_location_variance(enemy_location)
                print(move_to)
                await self.do(scout.move(move_to))

        else:
            for rf in self.units(UnitTypeId.ROBOTICSFACILITY).ready.noqueue:
                if self.can_afford(UnitTypeId.OBSERVER) and self.supply_left &amp;gt; 0:
                    await self.do(rf.train(UnitTypeId.OBSERVER))

    async def intel(self):
        game_data = np.zeros((self.game_info.map_size[1], self.game_info.map_size[0], 3), np.uint8)

        # UnitTypeId作为key,半径和颜色是value
        draw_dict = {
            UnitTypeId.NEXUS: [15, (0, 255, 0)],
            UnitTypeId.PYLON: [3, (20, 235, 0)],
            UnitTypeId.PROBE: [1, (55, 200, 0)],
            UnitTypeId.ASSIMILATOR: [2, (55, 200, 0)],
            UnitTypeId.GATEWAY: [3, (200, 100, 0)],
            UnitTypeId.CYBERNETICSCORE: [3, (150, 150, 0)],
            UnitTypeId.STARGATE: [5, (255, 0, 0)],
            UnitTypeId.ROBOTICSFACILITY: [5, (215, 155, 0)],

            UnitTypeId.VOIDRAY: [3, (255, 100, 0)],
            # OBSERVER: [3, (255, 255, 255)],
        }

        for unit_type in draw_dict:
            for unit in self.units(unit_type).ready:
                pos = unit.position
                cv2.circle(game_data, (int(pos[0]), int(pos[1])), draw_dict[unit_type][0], draw_dict[unit_type][1], -1)

        # 主基地名称
        main_base_names = [&quot;nexus&quot;, &quot;supplydepot&quot;, &quot;hatchery&quot;]
        # 记录敌方基地位置
        for enemy_building in self.known_enemy_structures:
            pos = enemy_building.position
            # 不是主基地建筑，画小一些
            if enemy_building.name.lower() not in main_base_names:
                cv2.circle(game_data, (int(pos[0]), int(pos[1])), 5, (200, 50, 212), -1)
        for enemy_building in self.known_enemy_structures:
            pos = enemy_building.position
            if enemy_building.name.lower() in main_base_names:
                cv2.circle(game_data, (int(pos[0]), int(pos[1])), 15, (0, 0, 255), -1)

        for enemy_unit in self.known_enemy_units:

            if not enemy_unit.is_structure:
                worker_names = [&quot;probe&quot;, &quot;scv&quot;, &quot;drone&quot;]
                # if that unit is a PROBE, SCV, or DRONE... it's a worker
                pos = enemy_unit.position
                if enemy_unit.name.lower() in worker_names:
                    cv2.circle(game_data, (int(pos[0]), int(pos[1])), 1, (55, 0, 155), -1)
                else:
                    cv2.circle(game_data, (int(pos[0]), int(pos[1])), 3, (50, 0, 215), -1)

        for obs in self.units(UnitTypeId.OBSERVER).ready:
            pos = obs.position
            cv2.circle(game_data, (int(pos[0]), int(pos[1])), 1, (255, 255, 255), -1)

        # flip horizontally to make our final fix in visual representation:
        flipped = cv2.flip(game_data, 0)
        resized = cv2.resize(flipped, dsize=None, fx=2, fy=2)

        cv2.imshow('Intel', resized)
        cv2.waitKey(1)

    def random_location_variance(self, enemy_start_location):
        x = enemy_start_location[0]
        y = enemy_start_location[1]

        x += ((random.randrange(-20, 20)) / 100) * enemy_start_location[0]
        y += ((random.randrange(-20, 20)) / 100) * enemy_start_location[1]

        if x &amp;lt; 0:
            x = 0
        if y &amp;lt; 0:
            y = 0
        if x &amp;gt; self.game_info.map_size[0]:
            x = self.game_info.map_size[0]
        if y &amp;gt; self.game_info.map_size[1]:
            y = self.game_info.map_size[1]

        go_to = position.Point2(position.Pointlike((x, y)))
        return go_to

    # 建造农民
    async def build_workers(self):
        # 星灵枢钮*16（一个基地配备16个农民）大于农民数量并且现有农民数量小于MAX_WORKERS
        if len(self.units(UnitTypeId.NEXUS)) * 16 &amp;gt; len(self.units(UnitTypeId.PROBE)) and len(
                self.units(UnitTypeId.PROBE)) &amp;lt; self.MAX_WORKERS:
            # 星灵枢纽(NEXUS)无队列建造，可以提高晶体矿的利用率，不至于占用资源
            for nexus in self.units(UnitTypeId.NEXUS).ready.noqueue:
                # 是否有50晶体矿建造农民
                if self.can_afford(UnitTypeId.PROBE):
                    await self.do(nexus.train(UnitTypeId.PROBE))

    ## 建造水晶
    async def build_pylons(self):
        ## 供应人口和现有人口之差小于5且建筑不是正在建造
        if self.supply_left &amp;lt; 5 and not self.already_pending(UnitTypeId.PYLON):
            nexuses = self.units(UnitTypeId.NEXUS).ready
            if nexuses.exists:
                if self.can_afford(UnitTypeId.PYLON):
                    await self.build(UnitTypeId.PYLON, near=nexuses.first)

    ## 建造吸收厂
    async def build_assimilators(self):
        for nexus in self.units(UnitTypeId.NEXUS).ready:
            # 在瓦斯泉上建造吸收厂
            vaspenes = self.state.vespene_geyser.closer_than(15.0, nexus)
            for vaspene in vaspenes:
                if not self.can_afford(UnitTypeId.ASSIMILATOR):
                    break
                worker = self.select_build_worker(vaspene.position)
                if worker is None:
                    break
                if not self.units(UnitTypeId.ASSIMILATOR).closer_than(1.0, vaspene).exists:
                    await self.do(worker.build(UnitTypeId.ASSIMILATOR, vaspene))

    ## 开矿
    async def expand(self):
        # (self.iteration / self.ITERATIONS_PER_MINUTE)是一个缓慢递增的值,动态开矿
        if self.units(UnitTypeId.NEXUS).amount &amp;lt; self.iteration / self.ITERATIONS_PER_MINUTE and self.can_afford(
                UnitTypeId.NEXUS):
            await self.expand_now()

    ## 建造进攻性建筑
    async def offensive_force_buildings(self):
        print(self.iteration / self.ITERATIONS_PER_MINUTE)
        if self.units(UnitTypeId.PYLON).ready.exists:
            pylon = self.units(UnitTypeId.PYLON).ready.random
            # 根据神族建筑科技图，折跃门建造过后才可以建造控制核心
            if self.units(UnitTypeId.GATEWAY).ready.exists and not self.units(UnitTypeId.CYBERNETICSCORE):
                if self.can_afford(UnitTypeId.CYBERNETICSCORE) and not self.already_pending(UnitTypeId.CYBERNETICSCORE):
                    await self.build(UnitTypeId.CYBERNETICSCORE, near=pylon)
            # 否则建造折跃门
            # (self.iteration / self.ITERATIONS_PER_MINUTE)/2 是一个缓慢递增的值
            # elif len(self.units(UnitTypeId.GATEWAY)) &amp;lt; ((self.iteration / self.ITERATIONS_PER_MINUTE) / 2):
            elif len(self.units(UnitTypeId.GATEWAY)) &amp;lt; 1:
                if self.can_afford(UnitTypeId.GATEWAY) and not self.already_pending(UnitTypeId.GATEWAY):
                    await self.build(UnitTypeId.GATEWAY, near=pylon)
            # 控制核心存在的情况下建造机械台
            if self.units(UnitTypeId.CYBERNETICSCORE).ready.exists:
                if len(self.units(UnitTypeId.ROBOTICSFACILITY)) &amp;lt; 1:
                    if self.can_afford(UnitTypeId.ROBOTICSFACILITY) and not self.already_pending(
                            UnitTypeId.ROBOTICSFACILITY):
                        await self.build(UnitTypeId.ROBOTICSFACILITY, near=pylon)

            # 控制核心存在的情况下建造星门
            if self.units(UnitTypeId.CYBERNETICSCORE).ready.exists:
                if len(self.units(UnitTypeId.STARGATE)) &amp;lt; ((self.iteration / self.ITERATIONS_PER_MINUTE) / 2):
                    if self.can_afford(UnitTypeId.STARGATE) and not self.already_pending(UnitTypeId.STARGATE):
                        await self.build(UnitTypeId.STARGATE, near=pylon)

    ## 造兵
    async def build_offensive_force(self):
        # 无队列化建造
        # for gw in self.units(UnitTypeId.GATEWAY).ready.noqueue:
        #     if not self.units(UnitTypeId.STALKER).amount &amp;gt; self.units(UnitTypeId.VOIDRAY).amount:
        #
        #         if self.can_afford(UnitTypeId.STALKER) and self.supply_left &amp;gt; 0:
        #             await self.do(gw.train(UnitTypeId.STALKER))

        for sg in self.units(UnitTypeId.STARGATE).ready.noqueue:
            if self.can_afford(UnitTypeId.VOIDRAY) and self.supply_left &amp;gt; 0:
                await self.do(sg.train(UnitTypeId.VOIDRAY))

    ## 寻找目标
    def find_target(self, state):
        if len(self.known_enemy_units) &amp;gt; 0:
            # 随机选取敌方单位
            return random.choice(self.known_enemy_units)
        elif len(self.known_enemy_units) &amp;gt; 0:
            # 随机选取敌方建筑
            return random.choice(self.known_enemy_structures)
        else:
            # 返回敌方出生点位
            return self.enemy_start_locations[0]

    ## 进攻
    async def attack(self):
        # {UNIT: [n to fight, n to defend]}
        aggressive_units = {UnitTypeId.VOIDRAY: [8, 3]}

        for UNIT in aggressive_units:
            # 攻击模式
            if self.units(UNIT).amount &amp;gt; aggressive_units[UNIT][0] and self.units(UNIT).amount &amp;gt; aggressive_units[UNIT][
                1]:
                for s in self.units(UNIT).idle:
                    await self.do(s.attack(self.find_target(self.state)))
            # 防卫模式
            elif self.units(UNIT).amount &amp;gt; aggressive_units[UNIT][1]:
                if len(self.known_enemy_units) &amp;gt; 0:
                    for s in self.units(UNIT).idle:
                        await self.do(s.attack(random.choice(self.known_enemy_units)))


## 启动游戏
run_game(maps.get(&quot;AcidPlantLE&quot;), [
    Bot(Race.Protoss, SentdeBot()), Computer(Race.Terran, Difficulty.Hard)
], realtime=False)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果如下，红色和粉红色是敌方单位。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201453/201911/1201453-20191121232636261-511874399.gif&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 21 Nov 2019 15:28:00 +0000</pubDate>
<dc:creator>Rest探路者</dc:creator>
<og:description>准备 我的环境是python3.6,sc2包0.11.1 机器学习包下载链接： 'pysc2' 地图下载链接 'maps' pysc2是DeepMind开发的星际争霸Ⅱ学习环境。 它是封装星际争霸Ⅱ机</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Java-Starter/p/11789858.html</dc:identifier>
</item>
</channel>
</rss>