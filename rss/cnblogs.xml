<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>归并算法经典应用——求解逆序数 - TechFlow2019</title>
<link>http://www.cnblogs.com/techflow/p/12302170.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/techflow/p/12302170.html</guid>
<description>&lt;p&gt;本文始发于个人公众号：&lt;strong&gt;TechFlow&lt;/strong&gt;，原创不易，求个关注&lt;/p&gt;

&lt;p&gt;在之前介绍线性代数行列式计算公式的时候，我们曾经介绍过逆序数：我们在列举出行列式的每一项之后，需要通过逆序数来确定这一项符号的正负性。如果有忘记的同学可以回到之前的文章当中复习一下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUyMTM5OTM2NA==&amp;amp;mid=2247483690&amp;amp;idx=1&amp;amp;sn=02ed61a0350e9389bbf4c0e2b6d02350&amp;amp;chksm=f9dafc01cead7517b8717559b128a46c7d16cab3343e0baa1883655b199efcecf235121a524e&amp;amp;scene=21#wechat_redirect&quot;&gt;线性代数行列式&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果忘记呢，问题也不大，这个概念比较简单，我想大家很快就能都搞清楚。&lt;/p&gt;
&lt;p&gt;今天的这一篇文章，我想和大家聊聊逆序数的算法，也是一道非常经典的算法题，经常在各大公司的面试题当中出现。&lt;/p&gt;
&lt;p&gt;我们先来回顾一下逆序数的定义，所谓逆序数指的是数组当中究竟存在多少组数对，使得排在前面的数大于排在后面的数。我们举个例子，假设当下有一个数组是: [1, 3, 2]。&lt;/p&gt;
&lt;p&gt;对于数对(3, 2)来说，由于3排在2前面，并且3 &amp;gt; 2，那么就说明(3, 2)是一对逆序数对。整个数组当中所有逆序数对的个数就是逆序数。&lt;/p&gt;
&lt;p&gt;我们从逆序数的定义当中不难发现，逆序数其实是用来衡量一个数组有序程度的一个指标。逆序数越大，说明这个数组递增性越差。如果逆序数为0，说明这个序列是严格递增的。如果一个长度为n的数组的逆序数是&lt;span class=&quot;math inline&quot;&gt;\(C_n^2\)&lt;/span&gt;，那么说明这个数组是严格递减的，此时逆序数最大。&lt;/p&gt;
&lt;p&gt;那么，我们怎么快速地求解逆序数呢？&lt;/p&gt;

&lt;h2 id=&quot;暴力解法&quot;&gt;暴力解法&lt;/h2&gt;

&lt;p&gt;显然，这个问题可以暴力求解，我们只需要遍历所有的数对，然后判断是否构成逆序即可，最后累加一下所有逆序数对的个数就是最终的答案。&lt;/p&gt;
&lt;p&gt;这个代码非常简单，只需要几行：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;inverse = 0
for i in range(1, 10):
    for j in range(0, i):
        if arr[j] &amp;gt; arr[i]:
            inverse += 1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样当然是可以的，但是我们也很容易发现，这样做的时间复杂度是&lt;span class=&quot;math inline&quot;&gt;\(O(n^2)\)&lt;/span&gt;，这在很多时候是我们不能接受的。即使是运行速度非常快的C++，在单核CPU上一秒钟的时间，也就能跑最多n=1000这个规模。再大需要消耗的时间就会陡然增加，而在实际应用当中，一个长度超过1000的数组简直是家常便饭。显然，我们需要优化这个算法，不能简单地暴力求解。&lt;/p&gt;

&lt;h2 id=&quot;分治&quot;&gt;分治&lt;/h2&gt;

&lt;p&gt;我们可以尝试使用分治算法来解决这个问题。&lt;/p&gt;
&lt;p&gt;对于一个数组arr来说，我们试着将它拆分成两半，比如当下arr是[32, 36, 3, 9, 29, 16, 35, 73, 34, 82]。我们拆分成两半之后分别是[32, 36, 3, 9, 29]和[16, 35, 73, 34, 82]。我们令左边半边的子数组是A，右边半边的子数组是B。显然A和B都是原问题的子问题，我们可以假设通过递归可以求解出A和B子问题的结果。&lt;/p&gt;
&lt;p&gt;那么问题来了，我们怎么通过A、B子问题的结果来构建arr的结果呢？也就是说，我们怎么通过子问题分治来获取原问题的答案呢？&lt;/p&gt;
&lt;p&gt;在回答之前，我们先来分析一下当前的情况。当我们将arr数组拆分成了AB两个部分之后，整个arr的逆序数就变成了三个部分。分别是A数组之间的逆序数、B数组之间的逆序数，以及AB两个数组之间的逆序数，也就是一个元素在A中，一个元素在B中的逆序数对。我们再来分析一下，会发现A数组中的元素交换位置，只会影响A数组之间的逆序数，并不会影响B以及AB之间构成的逆序数。因为A中的元素即使交换位置，也在B数组所有元素之前。&lt;/p&gt;

&lt;p&gt;我们举个例子：&lt;/p&gt;

&lt;p&gt;假设arr=[3, 5, 1, 4]，那么A=[3, 5], B=[1, 4]。对于arr而言，它的逆序数是3分别是(3， 1)， （5， 1）和（5， 4）。对于A而言，它的逆序数是0，B的逆序数也是0。我们试着交换一下B当中的位置，交换之后的B=（4， 1），此时arr=[3, 5, 4, 1]。那么B的逆序数变成1，A的逆序数依然还是0。而整体arr的逆序数变成了4，分别是：（3， 1），（5， 1），（5， 4）和（4，1），很明显整体的逆序数新增的就是B交换元素带来的。通过观察，我们也能发现，对于A中的3和5而言，B中的1和4的顺序并不影响它们构成逆序数的数量。&lt;/p&gt;
&lt;p&gt;想明白了这一层，剩下的就简单了。既然A和B当中的元素无论怎么交换顺序也不会影响对方的结果，那么我们就可以放心地使用分治算法来解决了。我们先假设，我们可以通过递归获取A和B各自的逆序数。那么剩下的问题就是找出所有A和B个占一个元素的逆序数对的情况了。&lt;/p&gt;
&lt;p&gt;我们先对A和B中的元素进行排序，我们之前已经验证过了，我们调整A或者B当中的元素顺序，并不会改变横跨AB逆序数的数量，而我们通过递归已经求到了A和B中各自逆序数对的数量，所以我们存下来之后，就可以对A和B中的元素进行排序了。A和B中元素有序了之后，我们可以用插入排序的方法，将A中的元素依次插入B当中。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;B: XXXXXXXXX j XXXXXXXXXXXX
            /
          ai
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上图我们可以看出来，假设我们把&lt;span class=&quot;math inline&quot;&gt;\(a_i\)&lt;/span&gt;这个元素插入B数组当中j的位置。由于之前&lt;span class=&quot;math inline&quot;&gt;\(a_i\)&lt;/span&gt;排在B这j个元素之前，所以构成了j个逆序数对。我们对于所有A中的元素&lt;span class=&quot;math inline&quot;&gt;\(a_i\)&lt;/span&gt;求出它在B数组所有插入的位置j，然后对j求和即可。&lt;/p&gt;
&lt;p&gt;比较容易想到，由于B元素有序，我们可以通过二分的方法来查找A当中元素的位置。但其实还有更好的办法，我们一个步骤就可以完成AB的排序以及插入，就是将AB两个有序的数组进行归并。在归并的过程当中，我们既可以知道插入的B数组中的位置，又可以完成数组的排序，也就顺带解决了A和B排序的问题。所以整个步骤其实就是归并排序的延伸，虽然整个代码和归并排序差别非常小，但是，这个过程当中的推导和思考非常重要。&lt;/p&gt;
&lt;p&gt;如果你能理解上面这些推导过程，我相信代码对你来说并不困难。如果你还没能完全理解，也没有关系，借着代码，我相信你会理解得更轻松。话不多说了，让我们来看代码吧：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def inverse_num(array):
    n = len(array)
    if n &amp;lt;= 1:
        return 0, array

    mid = n // 2
    # 将数组拆分为二往下递归
    inverse_l, arr_l = inverse_num(array[:mid])
    inverse_r, arr_r = inverse_num(array[mid:])

    nl, nr = len(arr_l), len(arr_r)

    # 插入最大的int作为标兵，可以简化判断超界的代码
    arr_l.append(sys.maxsize)
    arr_r.append(sys.maxsize)

    i, j = 0, 0
    new_arr = []
    # 存储array对应的逆序数
    inverse = inverse_l + inverse_r

    while i &amp;lt; nl or j &amp;lt; nr:
        if arr_l[i] &amp;lt;= arr_r[j]:
            # 插入A[i]的时候逆序数增加j
            inverse += j
            new_arr.append(arr_l[i])
            i += 1
        else:
            new_arr.append(arr_r[j])
            j += 1
    return inverse, new_arr&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从代码层面来看，上面这段代码实现了归并排序的同时也算出了逆序数。所以这就是为什么很多人会将两者相提并论的原因，也是我个人非常喜欢这个问题的原因。看起来完全不相关的两个问题，竟然能用几乎同一套代码来解决，不得不感叹算法的神奇。也正是因此，我们这些算法的研究和学习者，才能获取到源源不断的乐趣。&lt;/p&gt;
&lt;p&gt;今天的文章就到这里，如果觉得有所收获，请&lt;strong&gt;顺手扫码&lt;/strong&gt;点个关注吧，你们的支持是我最大的动力。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/2/13/1703bdfca7437025?w=258&amp;amp;h=258&amp;amp;f=png&amp;amp;s=23988&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 13 Feb 2020 00:10:00 +0000</pubDate>
<dc:creator>TechFlow2019</dc:creator>
<og:description>本文始发于个人公众号： TechFlow ，原创不易，求个关注 在之前介绍线性代数行列式计算公式的时候，我们曾经介绍过逆序数：我们在列举出行列式的每一项之后，需要通过逆序数来确定这一项符号的正负性。如</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/techflow/p/12302170.html</dc:identifier>
</item>
<item>
<title>t-io Java构建p2p网络 - 段小辉</title>
<link>http://www.cnblogs.com/xiaohuiduan/p/12302024.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaohuiduan/p/12302024.html</guid>
<description>&lt;div v=&quot;&quot; class=&quot;preview html_preview xsj_public&quot; readability=&quot;57.799462159047&quot;&gt;


&lt;h2 class=&quot;xsj_heading_hash xsj_heading xsj_heading_h2&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;Java 构建p2p网络&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;这篇文章是一篇关于pbft算法实现的一篇补充文章，但是在这里不会涉及pbft的算法方面，所以可以当做一篇单独的文章食用。如果想查看关于区块链或者PBFT算法的文章，可以参考一下我的&lt;a href=&quot;https://www.cnblogs.com/xiaohuiduan/category/1635542.html&quot; class=&quot;xsj_link xsj_manu_link&quot; target=&quot;_blank&quot;&gt;文章&lt;/a&gt;。&lt;/p&gt;

&lt;h3 class=&quot;xsj_heading_hash xsj_heading xsj_heading_h3&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;文章实现范围&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;这篇文章是构建一个p2p网络，需要拥有独立的ip地址（当然如果是在局域网内使用就无所谓了），不会涉及到内网穿透的一些实现方法，也就是说如果你是把自己电脑构建了一个p2p结点，则其他人的电脑是无法链接你电脑的结点的。&lt;/p&gt;

&lt;h3 class=&quot;xsj_heading_hash xsj_heading xsj_heading_h3&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;预备知识&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;p2p网络中，一个结点既是客户端也是服务端，可以实现任意时刻的双向的通信。因此在每个结点中，会维护一张客户端的表和一张服务端的表。我们可以从代码的方面来理解一下这个东西，如下图所示：&lt;/p&gt;

&lt;div class=&quot;story_image_container story_block_image&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1439869/202002/1439869-20200213010046192-681326495.jpg&quot; alt=&quot;&quot; title=&quot;&quot; name=&quot;images/New_Doc_2020-02-11_23.41.33_1.jpg&quot; data-src=&quot;./images/New_Doc_2020-02-11_23.41.33_1.jpg&quot;/&gt;&lt;br/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_1&quot;&gt;两个被方框圈住的表则是需要维护的表，如果在代码中的话，我们就可以使用List去保存这张表&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_1&quot;&gt;客户端的表我们可以用来发送消息，而服务端的表我们可以用来控制群发。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;这里我们可以解释和理解一下何为p2p。举例：&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;结点1想与结点2进行通信时：A1跑出来说，我有到结点2的通道，然后向结点2发出&lt;code&gt;request&lt;/code&gt;，结点2的服务端接收到结点1（A1）发出来的消息的时，进行response。&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;这个时候，可能就会有人问：为什么不是结点1的服务端向结点2发出request呢，然后结点2再向服务端返回response？yes，这个是可以的，并且能够成功。那是不是意味着客户端的表实际上可以不要？&lt;code&gt;当然不是！！！&lt;/code&gt;首先我们从哲学的角度理解这个东西，request理所当然应该是client发出来的，response也应当是response发出来的。当然，这个完全是扯蛋。在两个结点中，一个当做server一个当做client，这样确实不会出现问题，当时如果是3个节点呢？这样做能不能实现两两&lt;code&gt;单独&lt;/code&gt;发送呢？很抱歉，不能。（注意，在这里是两个结点直接进行request和response，而不借助其他结点）。&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;下面这种模式是一个结点只为Server，另外的几个也只为Client。在这种模式中，C1和其他的结点无法独自进行两两通信，必须借助Server来进行通信。&lt;br/&gt;&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1439869/202002/1439869-20200213010046590-195271243.jpg&quot; alt=&quot;&quot; title=&quot;&quot; name=&quot;images/New_Doc_2020-02-11_23.41.33_2.jpg&quot; data-src=&quot;./images/New_Doc_2020-02-11_23.41.33_2.jpg&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;OK，说了这么多，那么现在让我们来进行构建P2P网络&lt;/p&gt;

&lt;h3 class=&quot;xsj_heading_hash xsj_heading xsj_heading_h3&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;Java构建项目&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;在这里，我将使用maven构建项目，下面是需要使用的工具类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;t-io：进行Socket通信。当然，t-io不是必须的，使用websocket或者netty都是可以的&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;项目地址：&lt;a href=&quot;https://github.com/xiaohuiduan/p2p_java&quot; class=&quot;xsj_link xsj_manu_link&quot; target=&quot;_blank&quot;&gt;github&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;代码其实没什么好讲的，主要是不熟悉tio的使用，这里，emm，吐槽一下tio，妈耶，文档也太贵了吧（╮(╯▽╰)╭，学生优惠没有了，哭唧唧）。&lt;/p&gt;

&lt;div class=&quot;story_image_container story_block_image&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1439869/202002/1439869-20200213010046817-836432792.jpg&quot; alt=&quot;&quot; title=&quot;&quot; name=&quot;images/Thu,_13_Feb_2020_003342.jpeg&quot; data-src=&quot;./images/Thu,_13_Feb_2020_003342.jpeg&quot;/&gt;&lt;br/&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;h3 class=&quot;xsj_heading_hash xsj_heading xsj_heading_h3&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;代码解释&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;代码其实很简单，就是开上几个server，然后client连接Server就行了。&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;主要代码如下所示（实际上使用什么框架都行，自己喜欢就行，把思路弄好就可以了）：&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;18&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java hljs&quot; data-info=&quot;java&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{
        Scanner in = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Scanner(System.in);
        String ip = &lt;span class=&quot;hljs-string&quot;&gt;&quot;127.0.0.1&quot;&lt;/span&gt;;
        
        System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;请输入服务端初始化端口：&quot;&lt;/span&gt;);
        &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; port = in.nextInt();
        
        ServerAioHandler handler = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; P2PServerAioHandler();
        
        ServerAioListener listener = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; ServerListener();
        
        ServerTioConfig config = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; ServerTioConfig(&lt;span class=&quot;hljs-string&quot;&gt;&quot;服务端&quot;&lt;/span&gt;, handler, listener);
        
        config.setHeartbeatTimeout(Const.TIMEOUT *&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;);
        TioServer tioServer = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; TioServer(config);
        &lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt; {
            
            tioServer.start(ip, port);
        } &lt;span class=&quot;hljs-keyword&quot;&gt;catch&lt;/span&gt; (IOException e) {
            System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;启动错误：&quot;&lt;/span&gt; + e.getMessage());
        }

        
        ClientChannelContext[] contexts = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; ClientChannelContext[&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;];
        &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;; i++) {
            
            ClientAioHandler clientAioHandler = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; P2pClientAioHandler();
            
            ClientTioConfig clientTioConfig = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; ClientTioConfig(clientAioHandler, &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; P2PClientLinstener(),&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; ReconnConf(Const.TIMEOUT));
            clientTioConfig.setHeartbeatTimeout(Const.TIMEOUT);
            ClientChannelContext context;
            &lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt; {
                TioClient client = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; TioClient(clientTioConfig);
                System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;输入端口：&quot;&lt;/span&gt;);
                &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; serverPort = in.nextInt();
                context = client.connect(&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Node(ip, serverPort), Const.TIMEOUT);

                contexts[i] = context;
            } &lt;span class=&quot;hljs-keyword&quot;&gt;catch&lt;/span&gt; (Exception e) {
                System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;客户端启动错误：&quot;&lt;/span&gt; + e.getMessage());
            }
        }

        &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;true&lt;/span&gt;) {
            System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;请输入发送的服务端的index&quot;&lt;/span&gt;);
            &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; index = in.nextInt();
            System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;请输入发送的内容&quot;&lt;/span&gt;);
            String body = in.next();
            &lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt; {
                MsgPacket msgPacket = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; MsgPacket();
                msgPacket.setBody(&lt;span class=&quot;hljs-string&quot;&gt;&quot;测试数据&quot;&lt;/span&gt;.getBytes(MsgPacket.CHARSET));
                Tio.send(contexts[index], msgPacket);
            } &lt;span class=&quot;hljs-keyword&quot;&gt;catch&lt;/span&gt; (UnsupportedEncodingException e) {
                e.printStackTrace();
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;思路：&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;思路还是蛮简单的，先进行server创建，并对他进行配置（配置它的消息处理方式和一些超时属性等等），在tio中，server会在后台（也就是P2PServerAioHandler这个类）接受并处理消息。然后是配置client，同样配置一些Handler和timeout等等。在这里我使用了&lt;code&gt;ClientChannelContext[] contexts = new ClientChannelContext[3]&lt;/code&gt;来保存client。ClientChannelContext可以理解为client到server的一根管道，通过他我们可以来控制消息的发送。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_1&quot;&gt;项目地址：&lt;a href=&quot;https://github.com/xiaohuiduan/p2p_java&quot; class=&quot;xsj_link xsj_manu_link&quot; target=&quot;_blank&quot;&gt;GitHub&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
</description>
<pubDate>Wed, 12 Feb 2020 16:53:00 +0000</pubDate>
<dc:creator>段小辉</dc:creator>
<og:description>Java 构建p2p网络 这篇文章是一篇关于pbft算法实现的一篇补充文章，但是在这里不会涉及pbft的算法方面，所以可以当做一篇单独的文章食用。如果想查看关于区块链或者PBFT算法的文章，可以参考一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiaohuiduan/p/12302024.html</dc:identifier>
</item>
<item>
<title>从小白视角理解 - 雪山飞猪</title>
<link>http://www.cnblogs.com/chenqionghe/p/12301905.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenqionghe/p/12301905.html</guid>
<description>&lt;p&gt;当一篇论文被引用的次数越多，证明这篇论文的影响力越大。&lt;br/&gt;一个网页的入链越多，入链越优质，网页的质量越高&lt;/p&gt;
&lt;h2 id=&quot;原理&quot;&gt;原理&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;一个网页的影响力：所有入链的页面的加权影响力之和&lt;/li&gt;
&lt;li&gt;一个网页对其他网页的影响力贡献为：自身影响力/出链数量&lt;/li&gt;
&lt;li&gt;用户并不都是按照跳转链接的方式来上网，还有其他的方式，比如直接输入网址访问，&lt;br/&gt;所以需要设定阻尼因子，代表了用户按照跳转链接来上网的概率&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;比喻说明&quot;&gt;比喻说明&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;微博&lt;br/&gt;一个人的微博粉丝数不一定等于他的实际影响力，还需要看粉丝的质量如何。&lt;br/&gt;如果是僵尸粉没什么用，但如果是很多大V或者明星关注，影响力很高。&lt;/li&gt;
&lt;li&gt;店铺的经营&lt;br/&gt;顾客比较多的店铺质量比较好，但是要看看顾客是不是托。&lt;/li&gt;
&lt;li&gt;兴趣&lt;br/&gt;在感兴趣的人或事身上投入了相对多的时间，对其相关的人事物也会投入一定的时间。&lt;br/&gt;那个人或事，被关注的越多，它的影响力/受众也就越大。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;关于阻尼因子&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;通过你的邻居的影响力来评判你的影响力，但是如果不能通过邻居来访问你，并不代表你没有影响力，因为可以直接访问你，所以引入阻尼因子的概念&lt;/li&gt;
&lt;li&gt;海洋除了有河流流经，还有雨水，但是下雨是随机的（网页影响力=阻尼影响力+所有入链集合页面的加权影响力之和）&lt;/li&gt;
&lt;li&gt;提出阻尼系数，还是为了解决某些网站明明存在大量出链（入链），但是影响力却非常大的情形。&lt;br/&gt;出链例子：hao123导航网页，出链极多入链极少&lt;br/&gt;入链例子：百度谷歌等搜索引擎，入链极多出链极少。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;关联关系挖掘，从消费者交易记录中发掘商品与商品之间的关联关系&lt;/p&gt;
&lt;h2 id=&quot;原理-1&quot;&gt;原理&lt;/h2&gt;
&lt;p&gt;1.支持度&lt;br/&gt;某个商品组合出现的次数与总次数之间的比例&lt;br/&gt;5次购买，4次买了牛奶，牛奶的支持度为4/5=0.8&lt;br/&gt;5次购买，3次买了牛奶+砚，牛奶+面包的支持度为3/5=0.6&lt;/p&gt;
&lt;p&gt;2.置信度&lt;br/&gt;购买了商品A，有多大概率购买商品B，A发生的情况下B发生的概率是多少&lt;br/&gt;买了4次牛奶，其中2次买了啤酒，(牛奶-&amp;gt;啤酒)的置信度为2/4=0.5&lt;br/&gt;买了3次啤酒，其中2次买了牛奶，(啤酒-&amp;gt;牛奶)的置信度为2/3-0.67&lt;/p&gt;
&lt;p&gt;3.提升度&lt;br/&gt;衡量商品A的出现，对商品B的出现 概率提升的程度&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;提升度(A-&amp;gt;B)=置信度(A-&amp;gt;B)/支持度(B)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;提升度&amp;gt;1，有提升； 提升度=1，无变化； 提升度&amp;lt;1，下降&lt;/p&gt;
&lt;p&gt;4.频繁项集&lt;br/&gt;项集：可以是单个商品，也可以是商品组合&lt;br/&gt;频繁项集是支持度大于最小支持度（Min Support）的项集&lt;/p&gt;
&lt;p&gt;计算过程&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;从K=1开始，筛选频繁项集。&lt;/li&gt;
&lt;li&gt;在结果中，组合K+1项集，再次筛选&lt;/li&gt;
&lt;li&gt;循环1、2步。直到找不到结果为止，K-1项集的结果就是最终结果。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;扩展：FP-Growth 算法&lt;br/&gt;Apriori 算法需要多次扫描数据库，性能低下，不适合大数据量&lt;br/&gt;FP-growth算法，通过构建 FP 树的数据结构，将数据存储在 FP 树中，只需要在构建 FP 树时扫描数据库两次，后续处理就不需要再访问数据库了。&lt;/p&gt;
&lt;h2 id=&quot;比喻说明-1&quot;&gt;比喻说明&lt;/h2&gt;
&lt;p&gt;啤酒和尿不湿摆在一起销售&lt;br/&gt;沃尔玛通过数据分析发现，美国有婴儿的家庭中，一般是母亲在家照顾孩子，父亲去超市买尿不湿。父亲在购买尿不湿时，常常会顺便搭配几瓶啤酒来犒劳自己，于是，超市尝试推出了将啤酒和尿不湿摆在一起的促销手段，这个举措居然使尿不湿和啤酒的销量都大幅增加。&lt;/p&gt;

&lt;h2 id=&quot;原理-2&quot;&gt;原理&lt;/h2&gt;
&lt;p&gt;简单的说，多个弱分类器训练成为一个强分类器。&lt;br/&gt;将一系列的弱分类器以不同的权重比组合作为最终分类选择&lt;/p&gt;
&lt;p&gt;计算过程&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;初始化基础权重&lt;/li&gt;
&lt;li&gt;奖权重矩阵，通过已的分类器计算错误率，选择错误率最低的为最优分类器&lt;/li&gt;
&lt;li&gt;通过分类器权重公式，减少正确样本分布，增加错误样本分布，得到新的权重矩阵和当前k轮的分类器权重&lt;/li&gt;
&lt;li&gt;将新的权重矩阵，带入上面的步骤2和3，重新计算权重矩阵&lt;/li&gt;
&lt;li&gt;迭代N轮，记录每一轮的最终分类器权重，得到强分类器&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;比喻说明-2&quot;&gt;比喻说明&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;利用错题提升学习效率&lt;br/&gt;做正确的题，下次少做点，反正都会了&lt;br/&gt;做错的题，下次多做点，集中在错题上&lt;br/&gt;随着学习的深入，做错的题会越来越少&lt;/li&gt;
&lt;li&gt;合理跨界提高盈利&lt;br/&gt;苹果公司，软硬结合，占据了大部分的手机市场利润，两个领域的知识结合起来产生新收益&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;决策就是对于一个问题，有多个答案，选择答案的过程就是决策。&lt;br/&gt;C4.5算法是用于产生决策树的算法，主要用于分类&lt;br/&gt;C4.5使用信息增益率做计算，对ID3算法使用信息率。&lt;/p&gt;
&lt;h2 id=&quot;原理-3&quot;&gt;原理&lt;/h2&gt;
&lt;p&gt;C4.5选择最有效地方式对样本集进行分裂，分裂规则是分析所有属性的信息增益率&lt;br/&gt;信息增益率越大，意味着这个特征分类的能力越强，我们就要优先选择这个特征做分类&lt;/p&gt;
&lt;h2 id=&quot;比喻说明-3&quot;&gt;比喻说明&lt;/h2&gt;
&lt;p&gt;挑西瓜&lt;br/&gt;拿到一个西瓜，先判断它的纹路，如果很模糊，就认为这不是好瓜，如果它清晰，就认为它是一个好瓜，如果它稍稍模糊，就考虑它的密度，密度大于某个值，就认为它是好瓜，否则就是坏瓜。&lt;/p&gt;

&lt;p&gt;CART：Classification And Regression Tree，中文叫分类回归树，即可以做分类也可以做回归。&lt;br/&gt;什么是分类树、回归树？&lt;br/&gt;分类树：处理离散数据，也就是数据种类有限的数据，输出的是样本的类别 。&lt;br/&gt;回归树：可以对连续型的数值进行预测，输出的是一个数值，数值在某个区间内都有取值的可能。&lt;br/&gt;回归问题和分类问题的本质一样，都是针对一个输入做出一个输出预测，其区别在于输出变量的类型&lt;/p&gt;
&lt;h2 id=&quot;原理-4&quot;&gt;原理&lt;/h2&gt;
&lt;p&gt;CART分类树与C4.5算法类似，只是属性选择的指标是基尼系数。&lt;br/&gt;基尼系数反应了样本的不确定度，基尼系数越小，说明样本之间的差异性小，不确定程度低。&lt;br/&gt;分类是一个不确定度降低的过程，CART在构造分类树的时候会选择基尼系数最小的属性作为属性的划分。&lt;br/&gt;CART 回归树是采用均方误差或绝对值误差为标准，选取均方误差或绝对值误差最小的特征&lt;/p&gt;
&lt;h2 id=&quot;比喻说明-4&quot;&gt;比喻说明&lt;/h2&gt;
&lt;p&gt;分类任务：预测明天是阴、晴还是雨&lt;br/&gt;回归任务：预测明天的气温是多少度&lt;/p&gt;

&lt;p&gt;朴素贝叶斯一种简单有效的常用分类算法，计算未知物体出现的条件下各个类别出现的概率，取概率最大的分类&lt;/p&gt;
&lt;h2 id=&quot;原理-5&quot;&gt;原理&lt;/h2&gt;
&lt;p&gt;假设输入的不同特征之间是独立的，基于概率论原理，通过先验概率P(A)、P(B)和条件概率推算出后概率出P(A|B)&lt;br/&gt;P(A)：先验概率，即在B事件发生之前，对A事件概率的一个判断。&lt;br/&gt;P(B|A)：条件概率，事件 B 在另外一个事件 A 已经发生条件下的发生概率&lt;br/&gt;P(A|B)：后验概率，即在B事件发生之后，对A事件概率的重新评估。&lt;/p&gt;
&lt;h2 id=&quot;比喻说明-5&quot;&gt;比喻说明&lt;/h2&gt;
&lt;p&gt;给病人分类&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;打喷嚏&lt;/td&gt;
&lt;td&gt;护士&lt;/td&gt;
&lt;td&gt;感冒&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;打喷嚏&lt;/td&gt;
&lt;td&gt;农夫&lt;/td&gt;
&lt;td&gt;过敏&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;头痛&lt;/td&gt;
&lt;td&gt;建筑工人&lt;/td&gt;
&lt;td&gt;脑震荡&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;头痛&lt;/td&gt;
&lt;td&gt;建筑工人&lt;/td&gt;
&lt;td&gt;感冒&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;打喷嚏&lt;/td&gt;
&lt;td&gt;教师&lt;/td&gt;
&lt;td&gt;感冒&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;头痛&lt;/td&gt;
&lt;td&gt;教师&lt;/td&gt;
&lt;td&gt;脑震荡&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;给定一个新病人，是一个打喷嚏的建筑工人，计算他患感冒的概率&lt;/p&gt;

&lt;p&gt;SVM： Support Vector Machine，中文名为支持向量机，是常见的一种分类方法，在机器学习中，SVM 是有监督的学习模型。&lt;br/&gt;什么是有监督学习和无监督学习 ？&lt;br/&gt;有监督学习：即在已有类别标签的情况下，将样本数据进行分类。&lt;br/&gt;无监督学习：即在无类别标签的情况下，样本数据根据一定的方法进行分类，即聚类，分类好的类别需要进一步分析后，从而得知每个类别的特点。&lt;/p&gt;
&lt;h2 id=&quot;原理-6&quot;&gt;原理&lt;/h2&gt;
&lt;p&gt;找到具有最小间隔的样本点，然后拟合出一个到这些样本点距离和最大的线段/平面。&lt;/p&gt;
&lt;p&gt;硬间隔：数据是线性分布的情况，直接给出分类&lt;br/&gt;软间隔：允许一定量的样本分类错误。&lt;br/&gt;核函数：非线性分布的数据映射为线性分布的数据。&lt;/p&gt;
&lt;h2 id=&quot;比喻说明-6&quot;&gt;比喻说明&lt;/h2&gt;
&lt;p&gt;1.分隔桌上一堆红球和篮球&lt;br/&gt;用一根线将桌上的红球和蓝球分成两部分&lt;br/&gt;2.分隔箱子里一堆红球和篮球&lt;br/&gt;用一个平面将箱子里的红球和蓝球分成两部分&lt;/p&gt;

&lt;p&gt;机器学习算法中最基础、最简单的算法之一。既能用于分类，也能用于回归。通过测量不同特征值之间的距离来进行分类。&lt;/p&gt;
&lt;h2 id=&quot;原理-7&quot;&gt;原理&lt;/h2&gt;
&lt;p&gt;根据场景，选取距离计算方式，计算待分类物体与其他物体之间的距离&lt;br/&gt;对于K个最近的邻居，所占数量最多的类别，预测为该分类对象的类别&lt;/p&gt;
&lt;p&gt;计算步骤&lt;br/&gt;1.根据场景，选取距离计算方式，计算待分类物体与其他物体之间的距离&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;统计距离最近的K个邻居&lt;/li&gt;
&lt;li&gt;对于K个最近的邻居，所占数量最多的类别，预测为该分类对象的类别&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;比喻说明-7&quot;&gt;比喻说明&lt;/h2&gt;
&lt;p&gt;近朱者赤，近墨者黑&lt;/p&gt;

&lt;p&gt;K-means是一个聚类算法，是无监督学习，生成指定K个类，把每个对象分配给距离最近的聚类中心&lt;/p&gt;
&lt;h2 id=&quot;原理-8&quot;&gt;原理&lt;/h2&gt;
&lt;p&gt;1.随机选取K个点为分类中心点&lt;br/&gt;2.将每个点分配到最近的类，这样形成了K个类&lt;br/&gt;3.重新计算每个类的中心点。比如都属于同一个类别里面有10个点，那么新的中心点就是这10个点的中心点，一种简单的方式就是取平均值。&lt;/p&gt;
&lt;h2 id=&quot;比喻说明-8&quot;&gt;比喻说明&lt;/h2&gt;
&lt;p&gt;1.选老大&lt;br/&gt;大家随机选K个老大，谁离得近，就是那个队列的人（计算距离，距离近的人聚合在一上进心）&lt;br/&gt;随着时间的推移，老大的位置在变化（根据算法，重新计算中心点），直到选出真正的中心老大（重复，直到准确率最高）&lt;/p&gt;
&lt;p&gt;2.Kmeans和Knn的区别&lt;br/&gt;Kmeans开发，选老大，风水轮流转，直到选出最佳中心老大&lt;br/&gt;Knn小弟加队伍，离那个班相对近，就是那个班的&lt;/p&gt;

&lt;p&gt;EM 的英文是 Expectation Maximization，所以 EM 算法也叫最大期望算法，&lt;br/&gt;和K-Means的区别：&lt;br/&gt;EM是计算概率，KMeans是计算距离。&lt;br/&gt;它和K-means都属于聚类算法，但是，EM属于软聚类，同一样本可能属于多个类别；而后者则属于硬聚类，一个样本只能属于一个类别。所以前者能够发现一些隐藏的数据。&lt;/p&gt;
&lt;h2 id=&quot;原理-9&quot;&gt;原理&lt;/h2&gt;
&lt;p&gt;先估计一个大概率的可能参数，然后再根据数据不断地进行调整，直到找到最终的确认参数&lt;/p&gt;
&lt;h2 id=&quot;比喻说明-9&quot;&gt;比喻说明&lt;/h2&gt;
&lt;p&gt;菜称重。&lt;br/&gt;很少有人用称对菜进行称重，再计算一半的分量进行平分。&lt;br/&gt;大部分人的方法是先分一部分到碟子 A 中，然后再把剩余的分到碟子 B 中，再来观察碟子 A 和 B 里的菜是否一样多，哪个多就匀一些到少的那个碟子里，然后再观察碟子 A 和 B 里的是否一样多……整个过程一直重复下去，直到份量不发生变化为止。&lt;/p&gt;
</description>
<pubDate>Wed, 12 Feb 2020 15:55:00 +0000</pubDate>
<dc:creator>雪山飞猪</dc:creator>
<og:description>[toc] 一、PageRank 当一篇论文被引用的次数越多，证明这篇论文的影响力越大。 一个网页的入链越多，入链越优质，网页的质量越高 原理 一个网页的影响力：所有入链的页面的加权影响力之和 一个网</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chenqionghe/p/12301905.html</dc:identifier>
</item>
<item>
<title>OpenCV3入门（五）图像的阈值 - 啊哈彭</title>
<link>http://www.cnblogs.com/pingwen/p/12300590.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pingwen/p/12300590.html</guid>
<description>&lt;h2&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;strong&gt;、图像阈值与二值化&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;阈值是一种简单的图像分割方法，一幅图像包括目标物体（前景）、背景还有噪声，要想从数字图像中直接提取出目标物体，可以设定一个像素值即阈值，然后用图像的每一个像素点和阈值做比较，给出判定结果。&lt;/p&gt;
&lt;p&gt;二值化是特殊的阈值分割方法，把图像分为两部分，以阈值T为分割线，大于T的像素群和小于T的像素群，这样图像就变为黑白二色图像。通过设定一个标准如果大于这个标准就设为白，如果小于这个标准就设为黑，而这个标准就是阈值。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;strong&gt;、OpenCV&lt;/strong&gt;&lt;strong&gt;阈值threshold&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;double threshold(InputArray src, OutputArray dst, double thresh, double maxval, int type);&lt;/p&gt;
&lt;p&gt;（1）第一个参数，InputArray 类型的 src，源图像。单通道，8 或 32位浮点数类型的深度。&lt;/p&gt;
&lt;p&gt;（2）第二个参数，OutputArray 类型的 dst，输出图像。&lt;/p&gt;
&lt;p&gt;（3）第三个参数，double 类型的 thresh，选取的阈值。&lt;/p&gt;
&lt;p&gt;（4）第四个参数，double 类型的 maxval。&lt;/p&gt;
&lt;p&gt;（5）第五个参数，int 类型的 type。阈值类型。如下所示：&lt;/p&gt;
&lt;p&gt;type类型如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;enum&lt;/span&gt;&lt;span&gt;  cv::ThresholdTypes { 
  cv::THRESH_BINARY &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, 
  cv::THRESH_BINARY_INV &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;, 
  cv::THRESH_TRUNC &lt;/span&gt;= &lt;span&gt;2&lt;/span&gt;&lt;span&gt;, 
  cv::THRESH_TOZERO &lt;/span&gt;= &lt;span&gt;3&lt;/span&gt;&lt;span&gt;, 
  cv::THRESH_TOZERO_INV &lt;/span&gt;= &lt;span&gt;4&lt;/span&gt;&lt;span&gt;, 
  cv::THRESH_MASK &lt;/span&gt;= &lt;span&gt;7&lt;/span&gt;&lt;span&gt;, 
  cv::THRESH_OTSU &lt;/span&gt;= &lt;span&gt;8&lt;/span&gt;&lt;span&gt;, 
  cv::THRESH_TRIANGLE &lt;/span&gt;= &lt;span&gt;16&lt;/span&gt;&lt;span&gt; 
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;不同的阈值方法生成关系如下图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/743748/202002/743748-20200212231242801-2014021441.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
Mat img = Mat::zeros(&lt;span&gt;6&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt;&lt;span&gt;, CV_8UC1);
randu(img, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;255&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; th = &lt;span&gt;100&lt;/span&gt;&lt;span&gt;;
Mat threshold1, threshold2, threshold3, threshold4, threshold5, threshold6, threshold7, threshold8;
threshold(img, threshold1, th, &lt;/span&gt;&lt;span&gt;200&lt;/span&gt;&lt;span&gt;, THRESH_BINARY);
threshold(img, threshold2, th, &lt;/span&gt;&lt;span&gt;200&lt;/span&gt;&lt;span&gt;, THRESH_BINARY_INV);
threshold(img, threshold3, th, &lt;/span&gt;&lt;span&gt;200&lt;/span&gt;&lt;span&gt;, THRESH_TRUNC);

cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;raw=\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;lt;&amp;lt;img &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;THRESH_BINARY=\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; threshold1 &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;THRESH_BINARY_INV=\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; threshold2 &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;THRESH_TRUNC=\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; threshold3 &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; endl;
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;上面代码中randu(img, 0, 255)作用是产出随机数填充img矩阵。输出结果如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;155&quot;&gt;
&lt;pre&gt;
raw=&lt;span&gt;
[ &lt;/span&gt;&lt;span&gt;91&lt;/span&gt;,   &lt;span&gt;2&lt;/span&gt;,  &lt;span&gt;79&lt;/span&gt;, &lt;span&gt;179&lt;/span&gt;,  &lt;span&gt;52&lt;/span&gt;, &lt;span&gt;205&lt;/span&gt;&lt;span&gt;;
 &lt;/span&gt;&lt;span&gt;236&lt;/span&gt;,   &lt;span&gt;8&lt;/span&gt;, &lt;span&gt;181&lt;/span&gt;, &lt;span&gt;239&lt;/span&gt;,  &lt;span&gt;26&lt;/span&gt;, &lt;span&gt;248&lt;/span&gt;&lt;span&gt;;
 &lt;/span&gt;&lt;span&gt;207&lt;/span&gt;, &lt;span&gt;218&lt;/span&gt;,  &lt;span&gt;45&lt;/span&gt;, &lt;span&gt;183&lt;/span&gt;, &lt;span&gt;158&lt;/span&gt;, &lt;span&gt;101&lt;/span&gt;&lt;span&gt;;
 &lt;/span&gt;&lt;span&gt;102&lt;/span&gt;,  &lt;span&gt;18&lt;/span&gt;, &lt;span&gt;118&lt;/span&gt;,  &lt;span&gt;68&lt;/span&gt;, &lt;span&gt;210&lt;/span&gt;, &lt;span&gt;139&lt;/span&gt;&lt;span&gt;;
 &lt;/span&gt;&lt;span&gt;198&lt;/span&gt;, &lt;span&gt;207&lt;/span&gt;, &lt;span&gt;211&lt;/span&gt;, &lt;span&gt;181&lt;/span&gt;, &lt;span&gt;162&lt;/span&gt;, &lt;span&gt;197&lt;/span&gt;&lt;span&gt;;
 &lt;/span&gt;&lt;span&gt;191&lt;/span&gt;, &lt;span&gt;196&lt;/span&gt;,  &lt;span&gt;40&lt;/span&gt;,   &lt;span&gt;7&lt;/span&gt;, &lt;span&gt;243&lt;/span&gt;, &lt;span&gt;230&lt;/span&gt;&lt;span&gt;]

THRESH_BINARY&lt;/span&gt;=&lt;span&gt;
[  &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;,   &lt;span&gt;0&lt;/span&gt;,   &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;200&lt;/span&gt;,   &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;200&lt;/span&gt;&lt;span&gt;;
 &lt;/span&gt;&lt;span&gt;200&lt;/span&gt;,   &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;200&lt;/span&gt;, &lt;span&gt;200&lt;/span&gt;,   &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;200&lt;/span&gt;&lt;span&gt;;
 &lt;/span&gt;&lt;span&gt;200&lt;/span&gt;, &lt;span&gt;200&lt;/span&gt;,   &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;200&lt;/span&gt;, &lt;span&gt;200&lt;/span&gt;, &lt;span&gt;200&lt;/span&gt;&lt;span&gt;;
 &lt;/span&gt;&lt;span&gt;200&lt;/span&gt;,   &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;200&lt;/span&gt;,   &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;200&lt;/span&gt;, &lt;span&gt;200&lt;/span&gt;&lt;span&gt;;
 &lt;/span&gt;&lt;span&gt;200&lt;/span&gt;, &lt;span&gt;200&lt;/span&gt;, &lt;span&gt;200&lt;/span&gt;, &lt;span&gt;200&lt;/span&gt;, &lt;span&gt;200&lt;/span&gt;, &lt;span&gt;200&lt;/span&gt;&lt;span&gt;;
 &lt;/span&gt;&lt;span&gt;200&lt;/span&gt;, &lt;span&gt;200&lt;/span&gt;,   &lt;span&gt;0&lt;/span&gt;,   &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;200&lt;/span&gt;, &lt;span&gt;200&lt;/span&gt;&lt;span&gt;]

THRESH_BINARY_INV&lt;/span&gt;=&lt;span&gt;
[&lt;/span&gt;&lt;span&gt;200&lt;/span&gt;, &lt;span&gt;200&lt;/span&gt;, &lt;span&gt;200&lt;/span&gt;,   &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;200&lt;/span&gt;,   &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
   &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;200&lt;/span&gt;,   &lt;span&gt;0&lt;/span&gt;,   &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;200&lt;/span&gt;,   &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
   &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;,   &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;200&lt;/span&gt;,   &lt;span&gt;0&lt;/span&gt;,   &lt;span&gt;0&lt;/span&gt;,   &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
   &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;200&lt;/span&gt;,   &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;200&lt;/span&gt;,   &lt;span&gt;0&lt;/span&gt;,   &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
   &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;,   &lt;span&gt;0&lt;/span&gt;,   &lt;span&gt;0&lt;/span&gt;,   &lt;span&gt;0&lt;/span&gt;,   &lt;span&gt;0&lt;/span&gt;,   &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
   &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;,   &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;200&lt;/span&gt;, &lt;span&gt;200&lt;/span&gt;,   &lt;span&gt;0&lt;/span&gt;,   &lt;span&gt;0&lt;/span&gt;&lt;span&gt;]

THRESH_TRUNC&lt;/span&gt;=&lt;span&gt;
[ &lt;/span&gt;&lt;span&gt;91&lt;/span&gt;,   &lt;span&gt;2&lt;/span&gt;,  &lt;span&gt;79&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;,  &lt;span&gt;52&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;&lt;span&gt;;
 &lt;/span&gt;&lt;span&gt;100&lt;/span&gt;,   &lt;span&gt;8&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;,  &lt;span&gt;26&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;&lt;span&gt;;
 &lt;/span&gt;&lt;span&gt;100&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;,  &lt;span&gt;45&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;&lt;span&gt;;
 &lt;/span&gt;&lt;span&gt;100&lt;/span&gt;,  &lt;span&gt;18&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;,  &lt;span&gt;68&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;&lt;span&gt;;
 &lt;/span&gt;&lt;span&gt;100&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;&lt;span&gt;;
 &lt;/span&gt;&lt;span&gt;100&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;,  &lt;span&gt;40&lt;/span&gt;,   &lt;span&gt;7&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;THRESH_BINARY，thresh=100，maxval=200，大于阈值限定为200，小于阈值清零。&lt;/p&gt;
&lt;p&gt;THRESH_BINARY_INV的作用和THRESH_BINARY 相反，小于阈值置200，大于阈值清。&lt;/p&gt;
&lt;p&gt;THRESH_TRUNC的作用是对大于阈值的数据进行截断，其余值保留原值不变。&lt;/p&gt;
&lt;p&gt;图像阈值例子如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
Mat img = imread(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D:/WORK/5.OpenCV/LeanOpenCV/pic_src/pic6.bmp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, IMREAD_GRAYSCALE);
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; th = &lt;span&gt;100&lt;/span&gt;&lt;span&gt;;
Mat threshold1, threshold2, threshold3, threshold4, threshold5, threshold6, threshold7, threshold8;
threshold(img, threshold1, th, &lt;/span&gt;&lt;span&gt;200&lt;/span&gt;&lt;span&gt;, THRESH_BINARY);
threshold(img, threshold2, th, &lt;/span&gt;&lt;span&gt;200&lt;/span&gt;&lt;span&gt;, THRESH_BINARY_INV);
threshold(img, threshold3, th, &lt;/span&gt;&lt;span&gt;200&lt;/span&gt;&lt;span&gt;, THRESH_TRUNC);

imshow(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;raw pic&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,img);
imshow(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;THRESH_BINARY&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, threshold1);
imshow(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;THRESH_BINARY_INV&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, threshold2);
imshow(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;THRESH_TRUNC&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, threshold3);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/743748/202002/743748-20200212231358664-890729396.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;strong&gt;、自动阈值—&lt;/strong&gt;&lt;strong&gt;大津法OTSU&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;最大类间方差是由日本学者大津(Nobuyuki Otsu)于1979年提出，是一种自适应的阈值确定方法。算法假设图像像素能够根据阈值，被分成背景[background]和目标[objects]两部分。然后，计算该最佳阈值来区分这两类像素，使得两类像素区分度最大。&lt;/p&gt;
&lt;p&gt;算法原理为：&lt;/p&gt;
&lt;blockquote readability=&quot;25&quot;&gt;
&lt;p&gt;设图像Img长宽尺寸为M*N, T为二值化的阈值；&lt;/p&gt;
&lt;p&gt;N0为灰度小于T的像素的个数，N0的平均灰度为μ0。&lt;/p&gt;
&lt;p&gt;N1 为灰度大于T的像素的个数，N1的平均灰度为μ1。&lt;/p&gt;
&lt;p&gt;ω0=N0/ M×N                   (1)   //落在N0的概率&lt;/p&gt;
&lt;p&gt;ω1=N1/ M×N                   (2) 　//落在N1的概率&lt;/p&gt;
&lt;p&gt;N0+N1=M×N                    (3) 　&lt;/p&gt;
&lt;p&gt;ω0+ω1=1                        (4) 　　　　　　&lt;/p&gt;
&lt;p&gt;μ=ω0*μ0+ω1*μ1              (5) 　//平均灰度乘以概率 再相加&lt;/p&gt;
&lt;p&gt;g=ω0(μ0-μ)^2+ω1(μ1-μ)^2     (6)   //类间方差&lt;/p&gt;
&lt;p&gt;将式(5)代入式(6),得到等价公式: g=ω0ω1(μ0-μ1)^2    (7)     &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;OpenCV自带了OSTU算法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
Mat img = imread(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D:/WORK/5.OpenCV/LeanOpenCV/pic_src/pic2.bmp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, IMREAD_GRAYSCALE);
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; th = &lt;span&gt;100&lt;/span&gt;&lt;span&gt;;
Mat threshold1, threshold2, threshold3;
threshold(img, threshold1, th, &lt;/span&gt;&lt;span&gt;255&lt;/span&gt;&lt;span&gt;, THRESH_BINARY);
threshold(img, threshold2, th, &lt;/span&gt;&lt;span&gt;255&lt;/span&gt;&lt;span&gt;, THRESH_TRUNC);
threshold(img, threshold3, th, &lt;/span&gt;&lt;span&gt;255&lt;/span&gt;, THRESH_OTSU); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 阈值随意设置即可&lt;/span&gt;
&lt;span&gt;
imshow(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;raw pic&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,img);
imshow(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;THRESH_BINARY&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, threshold1);
imshow(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;THRESH_TRUNC&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,  threshold2);
imshow(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;THRESH_OTSU&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,   threshold3);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用大津法时阈值可以不设置或随意设置，函数会自动计算最合适的阈值，输出图像如下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/743748/202002/743748-20200212231509634-601394647.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;大津法相比其他二值化方法，能很好的筛选出前景图和背景图，让图像分类后黑白区分度最大。&lt;/p&gt;
&lt;h2&gt;4、参考文献&lt;/h2&gt;
&lt;p&gt;1、《学习OpenCV》，清华大学出版社，Gary Bradski， Adrian kaehler著&lt;/p&gt;
&lt;p&gt;2、Miscellaneous Image Transformations&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.opencv.org/3.1.0/d7/d1b/group__imgproc__misc.html#gae8a4a146d1ca78c626a53577199e9c57&quot;&gt;https://docs.opencv.org/3.1.0/d7/d1b/group__imgproc__misc.html#gae8a4a146d1ca78c626a53577199e9c57&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3、OpenCV threshold函数详解&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_42296411/article/details/80901080&quot;&gt;https://blog.csdn.net/weixin_42296411/article/details/80901080&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4、详细及易读懂的 大津法（OTSU）原理 和 算法实现&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/u012198575/article/details/81128799&quot;&gt;https://blog.csdn.net/u012198575/article/details/81128799&lt;/a&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;3.4623655913978&quot;&gt;
&lt;p&gt;尊重原创技术文章，转载请注明。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/pingwen/p/12300590.html&quot;&gt;https://www.cnblogs.com/pingwen/p/12300590.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 12 Feb 2020 15:18:00 +0000</pubDate>
<dc:creator>啊哈彭</dc:creator>
<og:description>OpenCV3入门（五）图像的阈值</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/pingwen/p/12300590.html</dc:identifier>
</item>
<item>
<title>Java并发读书笔记：线程安全与互斥同步 - 天乔巴夏丶</title>
<link>http://www.cnblogs.com/summerday152/p/12301463.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/summerday152/p/12301463.html</guid>
<description>&lt;p&gt;本篇参考许多著名的书籍，形成读书笔记，便于加深记忆。&lt;/p&gt;
&lt;p&gt;前文传送门：&lt;a href=&quot;https://www.cnblogs.com/summerday152/p/12296420.html&quot;&gt;Java并发读书笔记：JMM与重排序&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;当一个变量被多个线程读取，且&lt;strong&gt;至少被一个线程写入&lt;/strong&gt;时，如果读写操作不遵循&lt;code&gt;happens-before&lt;/code&gt;规则，那么就会存在&lt;strong&gt;数据竞争&lt;/strong&gt;的隐患，如果不给予正确的同步手段，将会导致线程不安全。&lt;/p&gt;

&lt;p&gt;Brian Goetz在《Java并发编程实战》中是这样定义的：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;当多个线程访问一个类时，如果不用考虑这些线程在运行时环境下的调度和交替执行，并且&lt;strong&gt;不需要额外的同步&lt;/strong&gt;及在调用方代码&lt;strong&gt;不必做其他的协调&lt;/strong&gt;，这个类的行为仍然是正确的，那么这个类就是&lt;strong&gt;线程安全&lt;/strong&gt;的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;p&gt;周志明在《深入理解Java虚拟机》中提到：多个线程之间存在共享数据时，这些数据可以按照线程安全程度进行分类：&lt;/p&gt;
&lt;h2 id=&quot;不可变&quot;&gt;不可变&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;不可变的对象一定是线程安全的&lt;/strong&gt;，只要一个不可变的对象被正确地构建出来，那么它在多个线程中的&lt;strong&gt;状态就是一致&lt;/strong&gt;的。例如用final关键字修饰对象：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;修饰的是基本数据类型，final修饰不可变。&lt;/li&gt;
&lt;li&gt;修饰的是一个对象，就需要保证其状态不发生变化。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;JavaAPI中符合不可变要求的类型：String类，枚举类，数值包装类型（如Double）和大数据类型（BigDecimal)。&lt;/p&gt;
&lt;h2 id=&quot;绝对线程安全&quot;&gt;绝对线程安全&lt;/h2&gt;
&lt;p&gt;即完全满足上述对于线程安全定义的。&lt;/p&gt;
&lt;p&gt;满足该定义其实需要付出很多代价，Java中标注线程安全的类，实际上绝大多数都不是线程安全的（如Vector），因为它&lt;strong&gt;仍需要在调用端做好同步措施&lt;/strong&gt;。Java中绝对线程安全的类：&lt;code&gt;CopyOnWriteArrayList&lt;/code&gt;、&lt;code&gt;CopyOnWriteArraySet&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;相对线程安全&quot;&gt;相对线程安全&lt;/h2&gt;
&lt;p&gt;即我们通常所说的线程安全，Java中大部分的线程安全类都属于该范畴，如&lt;code&gt;Vector&lt;/code&gt;，&lt;code&gt;HashTable&lt;/code&gt;，&lt;code&gt;Collections&lt;/code&gt;集合工具类的&lt;code&gt;synchronizedCollection()&lt;/code&gt;方法包装的集合等等。就拿Vector举例：如果有个线程在遍历某个Vector、有个线程同时在add这个Vector，99%的情况下都会出现&lt;code&gt;ConcurrentModificationException&lt;/code&gt;，也就是&lt;code&gt;fail-fast&lt;/code&gt;机制。&lt;/p&gt;
&lt;h2 id=&quot;线程兼容&quot;&gt;线程兼容&lt;/h2&gt;
&lt;p&gt;对象本身并不是线程安全的，可以通过在调用段正确同步保证对象在并发环境下安全使用。如我们之前学的分别与Vector和HashTable对应的&lt;code&gt;ArrayList&lt;/code&gt;和&lt;code&gt;HashMap&lt;/code&gt;。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;对象通过synchronized关键字修饰，达到同步效果，本身是安全的，但相对来说，效率会低很多。&lt;/p&gt;
&lt;h2 id=&quot;线程对立&quot;&gt;线程对立&lt;/h2&gt;
&lt;p&gt;无论调用端是否采取同步措施，都无法正确地在多线程环境下执行。Java典型的线程对立：Thread类中的suspend()和resume()方法：如果两个线程同时操控一个线程对象，一个尝试挂起，一个尝试恢复，将会存在死锁风险，&lt;strong&gt;已经被弃用&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;常见的对立：&lt;code&gt;System.setIn()&lt;/code&gt;，&lt;code&gt;System.setOut()&lt;/code&gt;和&lt;code&gt;System.runFinalizersOnExit()&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;互斥同步&lt;/strong&gt;也被称做&lt;strong&gt;阻塞同步&lt;/strong&gt;(因为互斥同步会因为线程阻塞和唤醒产生性能问题），它是实现线程安全的其中一种方法，还有一种是&lt;strong&gt;非阻塞同步&lt;/strong&gt;，之后再做学习。&lt;/p&gt;
&lt;p&gt;互斥同步：&lt;strong&gt;保证并发下，共享数据在同一时刻只被一个线程使用。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;synchronized内置锁&quot;&gt;synchronized内置锁&lt;/h2&gt;
&lt;p&gt;其中使用&lt;code&gt;synchronized&lt;/code&gt;关键字修饰方法或代码块是最基本的互斥同步手段。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;synchronized&lt;/code&gt;是Java提供的一种&lt;strong&gt;强制原子性的内置锁机制&lt;/strong&gt;，以&lt;code&gt;synchronized&lt;/code&gt;代码块的定义方式来说：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;synchronized(lock){
    //访问或修改被锁保护的共享状态
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它包含了两部分：1、锁对象的引用 2、锁保护的代码块。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;每个Java对象都可以作为用于同步的锁对象&lt;/strong&gt;，我们称该类的锁为&lt;strong&gt;监视器锁（monitor locks）&lt;/strong&gt;，也被称作内置锁。&lt;/p&gt;
&lt;p&gt;可以这样理解：线程在进入synchronized之前需要获得这个锁对象，在线程正常结束或者抛出异常都会释放这个锁。&lt;/p&gt;
&lt;p&gt;而这个锁对象很好地完成了互斥，假设A持有锁，这时如果B也想访问这个锁，B就会陷入阻塞。A释放了锁之后，B才可能停止阻塞。&lt;/p&gt;
&lt;h3 id=&quot;锁即对象&quot;&gt;锁即对象&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;对于普通同步方法，锁是当前实例对象（this）。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//普通同步方法
public synchronized void do(){}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;对于静态同步方法，锁是当前的类的Class对象。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//静态同步方法
public static synchronized void f(){}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;对于同步方法块，锁的是括号里配置的对象。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//锁对象为TestLock的类对象
synchronized (TestLock.class){    
    f();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;明确：synchronized方法和代码块本质上没啥不同，方法只是对跨越整个方法体的代码块的简短描述，而这个锁是方法所在对象本身（static修饰的方法，对象是当前类对象）。这个部分可以参考：&lt;a href=&quot;https://www.jianshu.com/p/a499d13ca702?from=timeline&amp;amp;isappinstalled=0&quot;&gt;Java并发之synchronized深度解析&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;是否要释放锁&quot;&gt;是否要释放锁&lt;/h3&gt;
&lt;p&gt;释放锁的情况：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;线程执行完毕。&lt;/li&gt;
&lt;li&gt;遇到return、break终止。&lt;/li&gt;
&lt;li&gt;抛出未处理的异常或错误。&lt;/li&gt;
&lt;li&gt;调用了当前对象的wait()方法。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;不释放锁的情况：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;调用了Thread.sleep()和Thread.yield()暂停执行不会释放锁。&lt;/li&gt;
&lt;li&gt;调用suspend()挂起线程，不会释放锁，已被弃用。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;实现原理&quot;&gt;实现原理&lt;/h3&gt;
&lt;p&gt;JVM基于&lt;strong&gt;进入和退出Monitor对象&lt;/strong&gt;来实现方法同步和代码块同步，但两者实现细节不同。&lt;/p&gt;
&lt;p&gt;代码块同步使用&lt;code&gt;monitorenter&lt;/code&gt;和&lt;code&gt;monitorexit&lt;/code&gt;两个指令实现，JVM的要求如下：&lt;/p&gt;
&lt;h3 id=&quot;啥是重进入&quot;&gt;啥是重进入？&lt;/h3&gt;
&lt;p&gt;重进入意味着：&lt;strong&gt;任意线程在获取到锁之后能够再次获取该锁而不会被锁阻塞&lt;/strong&gt;，&lt;code&gt;synchronized&lt;/code&gt;是隐式支持重进入的，因此不会出现锁死自己的情况。&lt;/p&gt;
&lt;p&gt;这就体现了&lt;strong&gt;锁计数器&lt;/strong&gt;的作用：获得一次锁加一，释放一次锁减一，无论获得还是释放多少次，&lt;strong&gt;只要计数为零，就意味着锁被成功释放&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;reentrantlock重入锁&quot;&gt;ReentrantLock（重入锁）&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;ReentrantLock&lt;/code&gt;位于&lt;code&gt;java.util.concurrent（J.U.C）&lt;/code&gt;包下，是Lock接口的实现类。基本用法与&lt;code&gt;synchronized&lt;/code&gt;相似，都具备&lt;strong&gt;可重入互斥&lt;/strong&gt;的特性，但拥有扩展的功能。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Lock接口的实现提供了比使用synchronized方法和代码块更广泛的锁操作。允许更灵活的结构，具有完全不同的属性，并且可能支持多个关联的&lt;strong&gt;Condition&lt;/strong&gt;对象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;RenntrantLock官方推荐的基本写法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class X {
    //定义锁对象
    private final ReentrantLock lock = new ReentrantLock();
    // ...
    //定义需要保证线程安全的方法
    public void m() {
        //加锁
        lock.lock();  
        try{
        // 保证线程安全的代码
        }
        // 使用finally块保证释放锁
        finally {
            lock.unlock()
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;api层面的互斥锁&quot;&gt;API层面的互斥锁&lt;/h3&gt;
&lt;p&gt;ReentrantLock表现为&lt;strong&gt;API层面的互斥锁&lt;/strong&gt;，通过&lt;code&gt;lock()&lt;/code&gt;和&lt;code&gt;unlock()&lt;/code&gt;方法完成，是显式的，而synchronized表现为&lt;strong&gt;原生语法层面的互斥锁&lt;/strong&gt;，是隐式的。&lt;/p&gt;
&lt;h3 id=&quot;等待可中断&quot;&gt;等待可中断&lt;/h3&gt;
&lt;p&gt;当持有线程长期不释放锁的时候，正在等待的线程可&lt;strong&gt;以选择放弃等待&lt;/strong&gt;或&lt;strong&gt;处理其他事情&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;公平锁&quot;&gt;公平锁&lt;/h3&gt;
&lt;p&gt;ReentrantLock锁是公平锁，即&lt;strong&gt;保证等待的多个线程按照申请锁的时间顺序依次获得锁&lt;/strong&gt;，而synchronized是不公平锁。&lt;/p&gt;
&lt;h3 id=&quot;锁绑定&quot;&gt;锁绑定&lt;/h3&gt;
&lt;p&gt;一个ReentrantLock对象&lt;strong&gt;可以同时绑定多个Condition对象&lt;/strong&gt;。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;JDK1.6之前，ReentrantLock在性能方面是要领先于synchronized锁的，但是JDK1.6版本实现了各种锁优化技术，后续性能改进会更加偏向于原生的synchronized。&lt;/p&gt;
&lt;p&gt;参考数据：《Java并发编程实战》、《Java并发编程的艺术》、《深入理解Java虚拟机》&lt;/p&gt;
</description>
<pubDate>Wed, 12 Feb 2020 14:45:00 +0000</pubDate>
<dc:creator>天乔巴夏丶</dc:creator>
<og:description>[toc] 本篇参考许多著名的书籍，形成读书笔记，便于加深记忆。 前文传送门： &amp;quot;Java并发读书笔记：JMM与重排序&amp;quot; 导致线程不安全的原因 当一个变量被多个线程读取，且 至少被</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/summerday152/p/12301463.html</dc:identifier>
</item>
<item>
<title>红帽RedHat 8.0新特性(网络、yum源、Web界面管理等) - 拿着保温瓶的年轻人</title>
<link>http://www.cnblogs.com/l-hh/p/12301143.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/l-hh/p/12301143.html</guid>
<description>&lt;p&gt;&lt;span&gt;注意：Red Hat8网络管理默认使用NetworkManager，而不是之前版本的network。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;按照之前版本我们一般通过配置文件设置静态IP地址信息，如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@localhost ~]# cd /etc/sysconfig/network-&lt;span&gt;scripts
[root@localhost network&lt;/span&gt;-scripts]# cp ifcfg-ens160 ifcfg-ens160.bak    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 备份一下，要养成习惯&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 手动添加静态IP地址：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@localhost network-scripts]# cat ifcfg-&lt;span&gt;ens160
&lt;/span&gt;----------------------------------------------------&lt;span&gt;
TYPE&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Ethernet&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
PROXY_METHOD&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;none&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
BROWSER_ONLY&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;no&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
# 原来是“dhcp”改为“none”
BOOTPROTO&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;none&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;    
DEFROUTE&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yes&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
IPV4_FAILURE_FATAL&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;no&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
IPV6INIT&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yes&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
IPV6_AUTOCONF&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yes&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
IPV6_DEFROUTE&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yes&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
IPV6_FAILURE_FATAL&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;no&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
IPV6_ADDR_GEN_MODE&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;stable-privacy&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
NAME&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ens160&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
UUID&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;271a2a31-00b9-4e0d-bd5e-b0fa3685b0d0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
DEVICE&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ens160&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
ONBOOT&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yes&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

# 添加静态IP地址信息
IPADDR&lt;/span&gt;=&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;115.31&lt;/span&gt;&lt;span&gt;
PREFIX&lt;/span&gt;=&lt;span&gt;24&lt;/span&gt;&lt;span&gt;
GATEWAY&lt;/span&gt;=&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;115.2&lt;/span&gt;&lt;span&gt;
DNS1&lt;/span&gt;=&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;115.2&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1418489/202002/1418489-20200212215500759-837355055.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是我们发现通过配置文件修改IP地址并没有生效，这是为什么呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1418489/202002/1418489-20200212215535497-129406331.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;是因为Red Hat8版本已经不推荐通过配置文件来修改，而是推荐使用&lt;span&gt;命令行方式&lt;/span&gt;修改。命令如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@localhost ~]# nmcli connection modify ens160 ipv4.addresses &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;115.31&lt;/span&gt;/&lt;span&gt;24&lt;/span&gt;&lt;span&gt; ipv4.method manual ipv4.gateway &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;115.2&lt;/span&gt; ipv4.dns &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;115.2&lt;/span&gt;&lt;span&gt;
[root@localhost &lt;/span&gt;~&lt;span&gt;]# nmcli connection down ens160 
[root@localhost &lt;/span&gt;~]# nmcli connection up ens160&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;补充一点：&lt;/strong&gt;&lt;/span&gt;如果你执意想通过配置文件来修改，跟Red Hat7版本模式一样，需要安装这个包“network-scripts”，启动的服务就回到之前版本的“service network restart”。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;跟以往的版本也有所不同，当你挂载好光盘时，会发现光盘下AppStream和BaseOS目录下都有repodata，所以两个都需要配置，否则软件不全。配置如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@localhost ~]# cd /etc/yum.repos.d/&lt;span&gt;
[root@localhost yum.repos.d]# vim dvd.repo &lt;br/&gt;-----------------------------------------
[dvd]
name&lt;/span&gt;=&lt;span&gt;redhat8 BaseOS
baseurl&lt;/span&gt;=file:&lt;span&gt;///&lt;/span&gt;&lt;span&gt;media/BaseOS&lt;/span&gt;
gpgcheck=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;

[AppStream]
name&lt;/span&gt;=&lt;span&gt;redhat8 AppStream
baseurl&lt;/span&gt;=file:&lt;span&gt;///&lt;/span&gt;&lt;span&gt;media/AppStream&lt;/span&gt;
gpgcheck=&lt;span&gt;0&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;测试yum源：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@localhost ~&lt;span&gt;]# yum clean all
[root@localhost &lt;/span&gt;~]# yum list all&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;使用本地光盘yum安装nginx，在RHEL8里已经把Nginx加入到AppStream源中，可以直接安装：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@localhost ~]# yum install nginx -&lt;span&gt;y
[root@localhost &lt;/span&gt;~]# systemctl enable --now nginx&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;新命令：Red Hat8新增的&quot;立即启动&quot;命令，这个命令非常实用，等同于“systemctl start nginx”和“systemctl enable nginx”两条命令。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1418489/202002/1418489-20200212220016931-664076034.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1418489/202002/1418489-20200212220041087-168925153.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在安装Nginx就简单多了，我之前也写过Nginx安装的相关文章《&lt;a href=&quot;https://www.cnblogs.com/l-hh/p/10594415.html&quot; target=&quot;_blank&quot;&gt;Nginx 安装详细（一）&lt;/a&gt;》，可以对比参考一下哦。&lt;/span&gt;&lt;/p&gt;

&lt;p data-source-line=&quot;90&quot;&gt;&lt;span&gt;Red Hat8默认支持Cockpit，Cockpit是一个提供系统图形化管理工具，也是这次&lt;span&gt;&lt;strong&gt;&lt;span&gt;Red Hat8更新的亮点之一&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p data-source-line=&quot;93&quot;&gt;&lt;span&gt;由于我选择的是“Server with GUI”安装，所以默认已经安装好Cockpit组件了，最小化安装没测试过。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@localhost ~]# systemctl enable --now cockpit.socket&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;默认端口是&quot;9090&quot;，可以在Web界面管理你的Linux系统，开始探索去吧。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1418489/202002/1418489-20200212220246456-999390585.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;实时监控系统各项指标 [/赞]：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1418489/202002/1418489-20200212220324127-228620108.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span&gt;1. 默认支持Docker容器；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2. RHEL8数据库：MariaDB 10.3、MySQL 8.0、PostgreSQL 10；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3. 网络管理：默认使用NetworkManager；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;4. 新增Cockpit项目；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;5. Python 3.6是RHEL8中的默认Python版本；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;6. RHEL8中包括MySQL 8.0、MariaDB 10.3、PostgreSQL 10 &amp;amp; 9.6和Redis 4.0；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;7. PHP版本为PHP 7.2；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;9. Nginx 1.14在RHEL8的核心存储库中可用；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;10. nftables成为firewalld守护进程的默认后端；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;11. 基于Fedora 28，Kernel版本基于4.18；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;12. 地址大小: 43 bits physical, 48 bits virtual；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;13. 软件包使用dnf管理，同时保留yum接口；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;14. nftables替代iptables作为默认的网络过滤框架；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;15. OpenSSH包已升级到7.8p1，并删除了对SSH version 1协议的支持；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;.....&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p id=&quot;简单的举例一下更多新特性还等着你去了解&quot; data-source-line=&quot;126&quot;&gt;&lt;span&gt;简单的举例一下，更多新特性还等着你去了解。&lt;/span&gt;&lt;/p&gt;
&lt;p id=&quot;如果你对-red-hat8的新特性感兴趣不妨去体验一番红帽redhat8-rhel80系统安装教程小白都会&quot; data-source-line=&quot;127&quot;&gt;&lt;span&gt;如果你对 Red Hat8的新特性感兴趣，不妨去安装Red Hat8系统体验一番，《&lt;a href=&quot;https://www.cnblogs.com/l-hh/p/12300888.html&quot; target=&quot;_blank&quot;&gt;红帽(RedHat8) RHEL8.0系统安装教程（小白都会）&lt;/a&gt;》。&lt;/span&gt;&lt;/p&gt;
&lt;p data-source-line=&quot;127&quot;&gt;&lt;span&gt;以上有不恰当或者讲得不对的地方，希望各位留言指正，谢谢！&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 12 Feb 2020 14:14:00 +0000</pubDate>
<dc:creator>拿着保温瓶的年轻人</dc:creator>
<og:description>1、Red Hat8 配置静态IP 注意：Red Hat8网络管理默认使用NetworkManager，而不是之前版本的network。 按照之前版本我们一般通过配置文件设置静态IP地址信息，如下：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/l-hh/p/12301143.html</dc:identifier>
</item>
<item>
<title>Docker 代理脱坑指南 - 以终为始</title>
<link>http://www.cnblogs.com/michael9/p/12300824.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/michael9/p/12300824.html</guid>
<description>&lt;p&gt;由于公司 Lab 服务器无法正常访问公网，想要下载一些外部依赖包需要配置公司的内部代理。Docker 也是同理，想要访问公网需要配置一定的代理。&lt;/p&gt;
&lt;p&gt;Docker 代理分为两种，一种是为运行的 Container 配置代理，用于下载一些依赖包以及访问公网。另一种是为 Docker Daemon 配置代理，用于支持 docker 相关的命令。&lt;/p&gt;
&lt;h2 id=&quot;为容器配置代理&quot;&gt;为容器配置代理&lt;/h2&gt;
&lt;p&gt;配置容器代理一般分为两种，一种是全局配置，另一种是仅为某个容器配置。&lt;/p&gt;
&lt;h3 id=&quot;全局配置&quot;&gt;全局配置&lt;/h3&gt;
&lt;p&gt;首先说明，此修改方法仅支持 17.07 或者更高版本。&lt;/p&gt;
&lt;p&gt;修改或创建 &lt;code&gt;~/.docker/config.json&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 如果有的话，先备份一下
cp ~/.docker/config.json ~/.docker/config.json.bk

# 修改内容如下
cat ~/.docker/config.json
{
        &quot;auths&quot;: {},
        &quot;HttpHeaders&quot;: {
                &quot;User-Agent&quot;: &quot;Docker-Client/19.03.2 (linux)&quot;
        },

        &quot;proxies&quot;:
        {
            &quot;default&quot;:
            {
                &quot;httpProxy&quot;: &quot;http://173.39.112.117:80&quot;,
                &quot;httpsProxy&quot;: &quot;http://173.39.112.117:80&quot;
            }
        }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了确保生效，重启下 docker :&lt;code&gt;systemctl restart docker&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;此时宿主机并没配置代理，查询下 IP:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@localhost ~]# curl cip.cc
IP      : 64.104.xxx.xx
地址    : 中国  香港  cisco.com

数据二  : 香港 | 特别行政区

数据三  : 中国香港

URL     : http://www.cip.cc/64.104.xxx.xx&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;基于之前&lt;a href=&quot;https://docs.docker.com/network/proxy/#configure-the-docker-client&quot;&gt;使用 Docker file 打包镜像&lt;/a&gt;的文章，直接使用打包好带有 systemd 功能的镜像。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 创建 container
[root@localhost home] docker run --privileged=true -ti \
-v /sys/fs/cgroup:/sys/fs/cgroup:ro \
-p 80:80 -d local/c7-systemd

# 进入 container
[root@localhost home] docker exec -it 3eaa1cc71706 /bin/bash

# 查询 IP
[root@3eaa1cc71706 /]# curl cip.cc
IP      : 173.39.112.xxx
地址    : 新加坡  新加坡

数据二  : 新加坡

数据三  : 新加坡

URL     : http://www.cip.cc/173.39.112.xxx&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到容器内已经成功配置了代理，可以正常下载依赖了。&lt;/p&gt;
&lt;h3 id=&quot;局部修改&quot;&gt;局部修改&lt;/h3&gt;
&lt;p&gt;方法1-在 docker run 命令添加参数&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 创建 container
docker run --privileged=true -ti \
-v /sys/fs/cgroup:/sys/fs/cgroup:ro \
--env HTTP_PROXY=&quot;http://173.39.112.117:80 \
--env HTTPS_PROXY=&quot;http://173.39.112.117:80 \
--env http_proxy=&quot;http://173.39.112.117:80 \
--env https_proxy=&quot;http://173.39.112.117:80 \
-p 80:80 -d local/c7-systemd

# 进入 container
[root@localhost home]# docker exec -it 3607976e8f2d /bin/bash

# 查询 IP
[root@3607976e8f2d /]# curl cip.cc
IP      : 173.39.112.xxx
地址    : 新加坡  新加坡

数据二  : 新加坡

数据三  : 新加坡

URL     : http://www.cip.cc/173.39.112.xxx&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;方法2-在 Docker-file 添加&lt;/p&gt;
&lt;p&gt;这里以打包一个 httpd 的 docker file 为例子：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;FROM local/c7-systemd

ENV MY_PROXY_URL=&quot;http://173.39.112.117:80&quot;
ENV HTTP_PROXY=$MY_PROXY_URL \
    HTTPS_PROXY=$MY_PROXY_URL \
    FTP_PROXY=$MY_PROXY_URL \
    http_proxy=$MY_PROXY_URL \
    https_proxy=$MY_PROXY_URL \
    ftp_proxy=$MY_PROXY_URL


RUN yum -y install httpd; yum clean all; systemctl enable httpd.service

EXPOSE 80

CMD [&quot;/usr/sbin/init&quot;]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果是相同的，这里就不演示了。有时添加代理是域名的话，就需要额外的操作。&lt;/p&gt;
&lt;h3 id=&quot;添加代理是域名的处理&quot;&gt;添加代理是域名的处理&lt;/h3&gt;
&lt;p&gt;如果添加的代理是域名的话，如 &lt;code&gt;proxy.esl.cisco.com:80&lt;/code&gt;, 需要再做一步额外的处理。&lt;/p&gt;
&lt;p&gt;方法1-通过 docker run 参数添加&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 创建 container
[root@localhost home]#docker run --privileged=true -ti \
-v /sys/fs/cgroup:/sys/fs/cgroup:ro \
--env HTTP_PROXY=&quot;http://proxy.esl.cisco.com:80 \
--env HTTPS_PROXY=&quot;http://proxy.esl.cisco.com:80 \
--env http_proxy=&quot;http://proxy.esl.cisco.com:80 \
--env https_proxy=&quot;http://proxy.esl.cisco.com:80 \
--dns=64.104.123.245 \
-p 80:80 -d local/c7-systemd

# 进入 container
[root@localhost home]# docker exec -it 992dc27de1cc /bin/bash

# 查看 IP
[root@992dc27de1cc /]# curl cip.cc
IP      : 173.39.xxx.xxx
地址    : 新加坡  新加坡

数据二  : 新加坡

数据三  : 新加坡

URL     : http://www.cip.cc/173.39.xxx.xxx&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;方法2-通过修改 docker daemon 配置添加&lt;/p&gt;
&lt;p&gt;在每个 container 运行前，会继承 Docker daemon 的配置，在 &lt;code&gt;/etc/docker/daemon.json&lt;/code&gt; 文件下.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 为 docker daemon 添加 dns，在运行时会为每个 container 添加上
cat /etc/docker/daemon.json
{
  &quot;dns&quot; : [
    &quot;8.8.4.4&quot;,
    &quot;8.8.8.8&quot;,
    &quot;Your_DNS_SERVER&quot;
  ],

  &quot;registry-mirrors&quot;:[&quot;https://docker.mirrors.ustc.edu.cn&quot;]
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果一样这里就不演示了。&lt;/p&gt;
&lt;h2 id=&quot;为-docker-daemon-添加代理&quot;&gt;为 Docker Daemon 添加代理&lt;/h2&gt;
&lt;p&gt;和 container 的情况一样，如果不为 Docker Daemon 配置代理的话，是无法使用 search, pull, push 等命令的。&lt;/p&gt;
&lt;p&gt;配置如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# STEP1-创建文件夹
[root@localhost home]# sudo mkdir -p /etc/systemd/system/docker.service.d

# STEP2-创建代理文件 http 和 https
[root@localhost home]# cat /etc/systemd/system/docker.service.d/http-proxy.conf
[Service]
Environment=&quot;HTTP_PROXY=http://proxy.esl.cisco.com:80/&quot;

[root@localhost home]# cat /etc/systemd/system/docker.service.d/https-proxy.conf
[Service]
Environment=&quot;HTTPS_PROXY=http://proxy.esl.cisco.com:80/&quot;

# 如果希望访问某些 Docker registries 不是用代理，可以在上面的配置文件后追加
[Service]    
Environment=&quot;HTTP_PROXY=http://proxy.example.com:80/&quot; &quot;NO_PROXY=localhost,127.0.0.1,docker-registry.example.com,.corp&quot;

# STEP3-刷新变更
[root@localhost home]# sudo systemctl daemon-reload

# STEP4-重启 Docker
[root@localhost home]# sudo systemctl restart docker

# STEP5-验证代理是否生效
[root@localhost home]# systemctl show --property=Environment docker
Environment=HTTP_PROXY=http://proxy.esl.cisco.com/ HTTPS_PROXY=http://proxy.esl.cisco.com:80/&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.docker.com/network/proxy/#configure-the-docker-client&quot;&gt;docker-container-proxy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.docker.com/config/containers/container-networking/&quot;&gt;docker-dns&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.docker.com/config/daemon/systemd/&quot;&gt;docker-daemon-proxy&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 12 Feb 2020 12:52:00 +0000</pubDate>
<dc:creator>以终为始</dc:creator>
<og:description>Docker 代理配置 由于公司 Lab 服务器无法正常访问公网，想要下载一些外部依赖包需要配置公司的内部代理。Docker 也是同理，想要访问公网需要配置一定的代理。 Docker 代理分为两种，一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/michael9/p/12300824.html</dc:identifier>
</item>
<item>
<title>学过 C++ 的你，不得不知的这 10 条细节！ - 小林coding</title>
<link>http://www.cnblogs.com/xiaolincoding/p/12300745.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaolincoding/p/12300745.html</guid>
<description>&lt;hr/&gt;&lt;blockquote&gt;
&lt;h6 id=&quot;h&quot;&gt;&lt;span&gt;每日一句英语学习，每天进步一点点：&lt;/span&gt;&lt;/h6&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;“Action may not always bring happiness; but there is no happiness without action.”&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;「行动不见得一定带来快乐，但没有行动就没有快乐。」&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;hr/&gt;
&lt;p&gt;我在阅读 《Effective C++ （第三版本）》 书时做了不少笔记，从中收获了非常多，也明白为什么会书中前言的第一句话会说：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1770351/202002/1770351-20200212202926428-686419559.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于书中的「条款」这一词，我更喜欢以「细节」替换，毕竟年轻的我们在打 LOL 或 王者的时，总会说注意细节！细节！细节~ —— 细节也算伴随我们的青春的字眼&lt;/p&gt;
&lt;p&gt;针对书中的前两个章节，我筛选了 &lt;strong&gt;10&lt;/strong&gt; 个 细节（条款）作为了本文的内容，这些细节也相对基础且重要。&lt;/p&gt;
&lt;p&gt;针对这 &lt;strong&gt;10&lt;/strong&gt; 细节我都用较简洁的例子来加以阐述，同时也把本文所提及细节中的「小结」总结绘画成了一副&lt;strong&gt;思维导图&lt;/strong&gt;，便于大家的阅读。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;温馨提示：本文较长（万字），建议收藏阅读。&lt;br/&gt;后续有时间也会继续分享后面章节的笔记，喜欢的小伙伴「点击左上角」关注我~&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;h1c&quot;&gt;&lt;span&gt;1 让自己习惯C++&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;h01constenuminlinedefine&quot;&gt;&lt;span&gt;细节 01：尽量以const，enum，inline 替换 #define&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;#define 定义的常量有什么不妥？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先我们要清楚程序的编译重要的三个阶段：&lt;strong&gt;预处理阶段，编译阶段和链接阶段&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;#define&lt;/code&gt; 是不被视为语言的一部分，它在程序编译阶段中的&lt;strong&gt;预处理阶段&lt;/strong&gt;的作用，就是做简单的替换。&lt;/p&gt;
&lt;p&gt;如下面的 &lt;code&gt;PI&lt;/code&gt; 宏定义，在程序编译时，编译器在预处理阶段时，会先将源码中所有 &lt;code&gt;PI&lt;/code&gt; 宏定义替换成 &lt;code&gt;3.14&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cpp&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-meta-keyword&quot;&gt;define&lt;/span&gt; PI 3.14&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;程序编译在预处理阶段后，才进行真正的编译阶段。在有的编译器，运用了此 &lt;code&gt;PI&lt;/code&gt; 常量，&lt;strong&gt;如果遇到了编译错误，那么这个错误信息也许会提到 3.14 而不是 PI&lt;/strong&gt;，这就会让人困惑哪里来的&lt;code&gt;3.14&lt;/code&gt;，特别是在项目大的情况下。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;解决之道：以 const 定义一个常量替换上述的宏（#define）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;作为一个语言变量，下面的 const 定义的常量 &lt;code&gt;Pi&lt;/code&gt; 肯定会被编译器看到，出错的时候可以很清楚知道，是这个变量导致的问题：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cpp&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; doule Pi = &lt;span class=&quot;hljs-number&quot;&gt;3.14&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果是定义常量字符串，则必须要 &lt;code&gt;const&lt;/code&gt; 两次，目的是为了防止指针所指内容和指针自身不能被改变：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cpp&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;char&lt;/span&gt;* &lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; myName = &lt;span class=&quot;hljs-string&quot;&gt;&quot;小林coding&quot;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果是定义常量 &lt;code&gt;string&lt;/code&gt;，则只需要在最前面加一次 &lt;code&gt;const&lt;/code&gt;，形式如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cpp&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;myName&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;小林coding&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;#define 不重视作用域，所以对于 class 的专属常量，应避免使用宏定义。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;还有另外一点宏无法涉及的，就是我们无法利用 &lt;code&gt;#define&lt;/code&gt; 创建一个 &lt;code&gt;class&lt;/code&gt; 专属常量，因为 &lt;code&gt;#define&lt;/code&gt; 并不重视作用域。&lt;/p&gt;
&lt;p&gt;对于类里要定义专属常量时，我们依然使用 &lt;code&gt;static&lt;/code&gt; + &lt;code&gt;const&lt;/code&gt;，形式如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs dart&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Student&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;2&lt;/span&gt;private:&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;3&lt;/span&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;num&lt;/span&gt; = &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;4&lt;/span&gt;    &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; scores[&lt;span class=&quot;hljs-built_in&quot;&gt;num&lt;/span&gt;];&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;5&lt;/span&gt;};&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; Student::&lt;span class=&quot;hljs-built_in&quot;&gt;num&lt;/span&gt;; &lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果不想外部获取到 class 专属常量的内存地址，可以使用 enum 的方式定义常量&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;enum&lt;/code&gt; 会帮你约束这个条件，因为取一个 &lt;code&gt;enum&lt;/code&gt; 的地址是不合法的，形式如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs dart&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Student&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;2&lt;/span&gt;private:&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;3&lt;/span&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;enum&lt;/span&gt; { &lt;span class=&quot;hljs-built_in&quot;&gt;num&lt;/span&gt; = &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt; };&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;4&lt;/span&gt;    &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; scores[&lt;span class=&quot;hljs-built_in&quot;&gt;num&lt;/span&gt;];&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;5&lt;/span&gt;};&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;#define 实现的函数容易出错，并且长相丑陋不易阅读。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;另外一个常见的 &lt;code&gt;#define&lt;/code&gt; 误用情况是以它实现宏函数，它不会招致函数调用带来的开销，但是用 &lt;code&gt;#define&lt;/code&gt; 编写宏函数容易出错，如下用宏定义写的求最大值的函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs apache&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这般长相的宏有着太的缺点，比如在下面调用例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cpp&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; a = &lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;, b = &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; max = MAX(a++, b);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;hljs-built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; max &amp;lt;&amp;lt; &lt;span class=&quot;hljs-built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;hljs-built_in&quot;&gt;endl&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;hljs-built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; a &amp;lt;&amp;lt; &lt;span class=&quot;hljs-built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;hljs-built_in&quot;&gt;endl&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果（以下结果是错误的）：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cpp&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt; &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt; &lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;要解释出错的原因很简单，我们把 &lt;code&gt;MAX&lt;/code&gt; 宏做简单替换：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs delphi&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;1&lt;/span&gt;int max = (  ); &lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上述替换后，可以发现 &lt;code&gt;a&lt;/code&gt; 被累加了 &lt;strong&gt;2 次&lt;/strong&gt;。我们可以通过改进 &lt;code&gt;MAX&lt;/code&gt; 宏，来解决这个问题：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs markdown&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;hljs-section&quot;&gt;#define MAX(a, b) ({ \&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;2&lt;/span&gt;    &lt;span class=&quot;hljs-strong&quot;&gt;__typeof(a) __&lt;/span&gt;a = (a), __b = (b); \&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;3&lt;/span&gt;    &lt;span class=&quot;hljs-strong&quot;&gt;__a &amp;gt; __&lt;/span&gt;b ? &lt;span class=&quot;hljs-strong&quot;&gt;__a : __&lt;/span&gt;b; \&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;4&lt;/span&gt;})&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;简单说明下，上述的 &lt;code&gt;__typeof&lt;/code&gt; 可以根据变量的类型来定义一个相同类型的变量，如 &lt;code&gt;a&lt;/code&gt; 变量是 int 类型，那么 &lt;code&gt;__a&lt;/code&gt; 变量的类型也是 int 类型。改进后的 &lt;code&gt;MAX&lt;/code&gt; 宏，&lt;strong&gt;输出的是正确的结果，max 输出 6，a 输出 7。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虽然改进的后 &lt;code&gt;MAX&lt;/code&gt; 宏，解决了问题，但是这种宏的长相就让人困惑。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;解决的方式：用 inline 替换 #define 定义的函数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;用 &lt;code&gt;inline&lt;/code&gt; 修饰的函数，&lt;strong&gt;也是可以解决函数调用的带来的开销，同时阅读性较高&lt;/strong&gt;，不会让人困惑。&lt;/p&gt;
&lt;p&gt;下面用用 template inline 的方式，实现上述宏定义的函数：：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cpp&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;inline&lt;/span&gt; T &lt;span class=&quot;hljs-title&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; T&amp;amp; a, &lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; T&amp;amp; b)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;3&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;4&lt;/span&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; a &amp;gt; b? a : b;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;5&lt;/span&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;max&lt;/code&gt; 是一个真正的函数，它遵循&lt;strong&gt;作用域和访问规则&lt;/strong&gt;，所以不会出现变量被多次累加的现象。&lt;/p&gt;
&lt;p&gt;模板的基础知识内存，可移步到我的旧文进行学习 --&amp;gt; &lt;a href=&quot;https://mp.weixin.qq.com/s/Kmk9kDV4vSAQLrD2bs4PKw&quot;&gt;泛型编程的第一步，掌握模板的特性！&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;blockquote&gt;
&lt;h4 id=&quot;h01&quot;&gt;&lt;span&gt;细节 01 小结 - 请记住&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;对于单纯常量，最好以 const 对象或 enum 替换 #define；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;对于形式函数的宏，最好改用 inline 函数替换 #define。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;hr/&gt;&lt;h3 id=&quot;h02const&quot;&gt;&lt;span&gt;细节 02：尽可能使用 const&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;const 的一件奇妙的事情是：它允许你告诉编译器和其他程序员&lt;strong&gt;某值应该保持不变&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;1.&lt;/strong&gt; 面对&lt;em&gt;指针&lt;/em&gt;，你可以指定指针自身、指针所指物，或两者都（或都不）是 const：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;c++ language-c++ hljs cpp&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;char&lt;/span&gt; myName[] = &lt;span class=&quot;hljs-string&quot;&gt;&quot;小林coding&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;char&lt;/span&gt; *p = myName;             &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;char&lt;/span&gt;* p = myName;       &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;char&lt;/span&gt;* &lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; p = myName;       &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;char&lt;/span&gt;* &lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; p = myName; &lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;如果关键词const出现在星号（&lt;code&gt;*&lt;/code&gt;）&lt;strong&gt;左&lt;/strong&gt;边，表示&lt;strong&gt;指针所指物是常量&lt;/strong&gt;（不能改变 *p 的值）；&lt;/li&gt;
&lt;li&gt;如果关键词const出现在星号（&lt;code&gt;*&lt;/code&gt;）&lt;strong&gt;右&lt;/strong&gt;边，表示&lt;strong&gt;指针自身是常量&lt;/strong&gt;（不能改变 p 的值）；&lt;/li&gt;
&lt;li&gt;如果关键词const出现在星号（&lt;code&gt;*&lt;/code&gt;）&lt;strong&gt;两&lt;/strong&gt;边，表示&lt;strong&gt;指针所指物和指针自身都是常量&lt;/strong&gt;；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;2.&lt;/strong&gt; 面对&lt;em&gt;迭代器&lt;/em&gt;，你也指定迭代器自身或自迭代器所指物不可被改变：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;c++ language-c++ hljs cpp&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;hljs-built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;&amp;gt; vec;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;hljs-built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;&amp;gt;::iterator iter = vec.begin(); &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;4&lt;/span&gt;*iter = &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;; &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;5&lt;/span&gt;++iter;     &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;hljs-built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;&amp;gt;::const_iterator cIter = vec.begin(); &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;8&lt;/span&gt;*cIter = &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;; &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;9&lt;/span&gt;++cIter;     &lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;如果你希望迭代器自身不可被改动，像指针声明为 &lt;code&gt;const&lt;/code&gt; 即可（即声明一个 &lt;code&gt;T* const&lt;/code&gt; 指针）； —— &lt;strong&gt;这个不常用&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;如果你希望迭代器所指的物不可被改动，你需要的是 &lt;code&gt;const_iterator&lt;/code&gt;（即声明一个 &lt;code&gt;const T*&lt;/code&gt; 指针）。—— &lt;strong&gt;这个常用&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;const 最具有威力的用法是面对函数声明时的应用。在一个函数声明式内，const 可以和函数返回值、各参数、成员函数自身产生关联。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;1.&lt;/strong&gt; 令&lt;em&gt;函数返回&lt;/em&gt;一个常量值，往往可以降低因程序员错误而造成的意外。举个例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;cpp language-cpp hljs&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Rational&lt;/span&gt; {&lt;/span&gt; ... };&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; Rational &lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt;* (&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; Rational&amp;amp; lhs, &lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; Rational&amp;amp; rhs);&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为什么要返回一个 &lt;code&gt;const&lt;/code&gt; 对象呢？原因是如果不这样，程序员就能实现这一的暴力行为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;cpp language-cpp hljs&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;1&lt;/span&gt;Rational a, b, c;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (a * b = c) ... &lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果 &lt;code&gt;operator*&lt;/code&gt; 返回的 &lt;code&gt;const&lt;/code&gt; 对象，可以预防这个没意义的赋值动作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.&lt;/strong&gt; 将 &lt;code&gt;const&lt;/code&gt; 实施于&lt;em&gt;成员函数&lt;/em&gt;的目的，是为了确认该成员函数可作用于 &lt;code&gt;const&lt;/code&gt; 对象。理由如下两个：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;理由 1 ：&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;它们使得 &lt;code&gt;class&lt;/code&gt; 接口比较容易理解，因为可以得知哪个函数可以改动对象而哪些函数不行，见如下例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;cpp language-cpp hljs&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 1&lt;/span&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;MyString&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 2&lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 3&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt;:&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 4&lt;/span&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;char&lt;/span&gt;&amp;amp; &lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt;[](&lt;span class=&quot;hljs-built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;hljs-keyword&quot;&gt;size_t&lt;/span&gt; position) &lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 5&lt;/span&gt;    { &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; text[position]; }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 7&lt;/span&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;char&lt;/span&gt;&amp;amp; &lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt;[](&lt;span class=&quot;hljs-built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;hljs-keyword&quot;&gt;size_t&lt;/span&gt; position)  &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 8&lt;/span&gt;    { &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; text[position]; }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 9&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt;:&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;10&lt;/span&gt;    &lt;span class=&quot;hljs-built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt; text;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;11&lt;/span&gt;};&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;MyString 的 &lt;code&gt;operator[]&lt;/code&gt; 可以被这么使用：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;c++ language-c++ hljs cpp&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;hljs-function&quot;&gt;MyString &lt;span class=&quot;hljs-title&quot;&gt;ms&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;小林coding&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;; &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;hljs-built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; ms[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;];   &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;3&lt;/span&gt;ms[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;] = &lt;span class=&quot;hljs-string&quot;&gt;'x'&lt;/span&gt;;          &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; MyString &lt;span class=&quot;hljs-title&quot;&gt;cms&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;小林coding&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;; &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;hljs-built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; cms[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;];   &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;7&lt;/span&gt;cms[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;] = &lt;span class=&quot;hljs-string&quot;&gt;'x'&lt;/span&gt;;          &lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意，上述第 7 行会出错，原因是 &lt;code&gt;cms&lt;/code&gt; 是 const 对象，调用的是函数返回值为 const 类型的 &lt;code&gt;operator[]&lt;/code&gt; ，我们是不可以对 const 类型的变量或变量进行修改的。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;理由 2 ：&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;它们使操作 const 对象成为可能，这对编写高效代码是个关键，因为&lt;strong&gt;改善 C++ 程序效率的一个根本的方法是以 pass by referenc-to-const（const T&amp;amp; a） 方式传递对象&lt;/strong&gt;，见如下例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;c++ language-c++ hljs cpp&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 1&lt;/span&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;MyString&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 2&lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 3&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt;:&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 5&lt;/span&gt;    MyString(&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;char&lt;/span&gt;* str) : text(str)&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 6&lt;/span&gt;    { &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 7&lt;/span&gt;        &lt;span class=&quot;hljs-built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;hljs-built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;构造函数&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;hljs-built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;hljs-built_in&quot;&gt;endl&lt;/span&gt;; &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 8&lt;/span&gt;    }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;10&lt;/span&gt;    MyString(&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; MyString&amp;amp; myString) &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;11&lt;/span&gt;    {&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;12&lt;/span&gt;        &lt;span class=&quot;hljs-built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;hljs-built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;复制构造函数&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;hljs-built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;hljs-built_in&quot;&gt;endl&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;13&lt;/span&gt;        (*&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;).text = myString.text;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;14&lt;/span&gt;    }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;15&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;16&lt;/span&gt;    ~MyString() &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;17&lt;/span&gt;    { &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;18&lt;/span&gt;        &lt;span class=&quot;hljs-built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;hljs-built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;析构函数&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;hljs-built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;hljs-built_in&quot;&gt;endl&lt;/span&gt;; &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;19&lt;/span&gt;    }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;20&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;21&lt;/span&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt;==(MyString rhs) &lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt;      &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;22&lt;/span&gt;    {&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;23&lt;/span&gt;        &lt;span class=&quot;hljs-built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;hljs-built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;operator==(MyString rhs) pass by value&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;hljs-built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;hljs-built_in&quot;&gt;endl&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;24&lt;/span&gt;        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; (*&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;).text == rhs.text;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;25&lt;/span&gt;    }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;26&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt;:&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;27&lt;/span&gt;    &lt;span class=&quot;hljs-built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt; text;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;28&lt;/span&gt;};&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;operator==&lt;/code&gt; 函数是 pass by value， 也就是按值传递，我们使用它，看下会输出什么：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cpp&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 1&lt;/span&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 2&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 3&lt;/span&gt;    &lt;span class=&quot;hljs-built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;hljs-built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;main()&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;hljs-built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;hljs-built_in&quot;&gt;endl&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 4&lt;/span&gt;    &lt;span class=&quot;hljs-function&quot;&gt;MyString &lt;span class=&quot;hljs-title&quot;&gt;ms1&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;小林coding&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 5&lt;/span&gt;    &lt;span class=&quot;hljs-function&quot;&gt;MyString &lt;span class=&quot;hljs-title&quot;&gt;ms2&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;小林coding&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 7&lt;/span&gt;    &lt;span class=&quot;hljs-built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;hljs-built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; ( ms1 == ms2) &amp;lt;&amp;lt; &lt;span class=&quot;hljs-built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;hljs-built_in&quot;&gt;endl&lt;/span&gt;; ;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 8&lt;/span&gt;    &lt;span class=&quot;hljs-built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;hljs-built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;end!&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;hljs-built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;hljs-built_in&quot;&gt;endl&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 9&lt;/span&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;10&lt;/span&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cs&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 1&lt;/span&gt;main()&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 2&lt;/span&gt;构造函数&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 3&lt;/span&gt;构造函数&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 4&lt;/span&gt;复制构造函数&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 5&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt;==(MyString rhs)  pass &lt;span class=&quot;hljs-keyword&quot;&gt;by&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;value&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 6&lt;/span&gt;&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 7&lt;/span&gt;析构函数&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 8&lt;/span&gt;end!&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 9&lt;/span&gt;析构函数&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;10&lt;/span&gt;析构函数&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以发现在进入 &lt;code&gt;operator==&lt;/code&gt; 函数时，发生了「复制构造函」，当离开该函数作用域后发生了「析构函数」。说明「按值传递」，在进入函数时，会产生一个副本，离开作用域后就会消耗，说明这里是存在开销的。&lt;/p&gt;
&lt;p&gt;我们把 &lt;code&gt;operator==&lt;/code&gt; 函数改成 pass by referenc-to-const 后，可以减少上面的副本开销：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs php&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;1&lt;/span&gt;bool operator==(&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; MyString&amp;amp; rhs)&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;2&lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;3&lt;/span&gt;    std::cout &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;operator==(const MyString&amp;amp; rhs)  &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;4&lt;/span&gt;        pass by referenc-to-const&quot;&lt;/span&gt; &amp;lt;&amp;lt; std::endl;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;5&lt;/span&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; (*this).text == rhs.text;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;6&lt;/span&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再次输出的结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs vbnet&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;1&lt;/span&gt;main()&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;2&lt;/span&gt;构造函数&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;3&lt;/span&gt;构造函数&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt;==(&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; MyString&amp;amp; rhs)  pass &lt;span class=&quot;hljs-keyword&quot;&gt;by&lt;/span&gt; referenc-&lt;span class=&quot;hljs-keyword&quot;&gt;to&lt;/span&gt;-&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;end&lt;/span&gt;!&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;7&lt;/span&gt;析构函数&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;8&lt;/span&gt;析构函数&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;没有发生复制构造函数，说明 pass by referenc-to-const 比 pass by value 性能高。&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;在 const 和 non-const 成员函数中避免代码重复&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;假设 MyString 内的 operator[] 在返回一个引用前，先执行边界校验、打印日志、校验数据完整性。把所有这些同时放进 const 和 non-const operator[]中，就会导致代码存在一定的重复：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;cpp language-cpp hljs&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 1&lt;/span&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;MyString&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 2&lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 3&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt;:&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 4&lt;/span&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;char&lt;/span&gt;&amp;amp; &lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt;[](&lt;span class=&quot;hljs-built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;hljs-keyword&quot;&gt;size_t&lt;/span&gt; position) &lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 5&lt;/span&gt;    { &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 6&lt;/span&gt;        ...    &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 7&lt;/span&gt;        ...    &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 8&lt;/span&gt;        ...    &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 9&lt;/span&gt;        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; text[position]; &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;10&lt;/span&gt;    }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;11&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;12&lt;/span&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;char&lt;/span&gt;&amp;amp; &lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt;[](&lt;span class=&quot;hljs-built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;hljs-keyword&quot;&gt;size_t&lt;/span&gt; position)&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;13&lt;/span&gt;    { &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;14&lt;/span&gt;        ...    &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;15&lt;/span&gt;        ...    &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;16&lt;/span&gt;        ...    &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;17&lt;/span&gt;        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; text[position]; &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;18&lt;/span&gt;    }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;19&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt;:&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;20&lt;/span&gt;    &lt;span class=&quot;hljs-built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt; text;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;21&lt;/span&gt;};&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以有一种解决方法，避免代码的重复：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cpp&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 1&lt;/span&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;MyString&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 2&lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 3&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt;:&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 4&lt;/span&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;char&lt;/span&gt;&amp;amp; &lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt;[](&lt;span class=&quot;hljs-built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;hljs-keyword&quot;&gt;size_t&lt;/span&gt; position) &lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt;  &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 5&lt;/span&gt;    { &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 6&lt;/span&gt;        ...    &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 7&lt;/span&gt;        ...    &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 8&lt;/span&gt;        ...    &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 9&lt;/span&gt;        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; text[position]; &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;10&lt;/span&gt;    }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;11&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;12&lt;/span&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;char&lt;/span&gt;&amp;amp; &lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt;[](&lt;span class=&quot;hljs-built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;hljs-keyword&quot;&gt;size_t&lt;/span&gt; position)&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;13&lt;/span&gt;    { &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;14&lt;/span&gt;        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;const_cast&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;char&lt;/span&gt;&amp;amp;&amp;gt;(&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;15&lt;/span&gt;                &lt;span class=&quot;hljs-keyword&quot;&gt;static_cast&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; MyString&amp;amp;&amp;gt;(*&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;)[position]&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;16&lt;/span&gt;                ); &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;17&lt;/span&gt;    }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;18&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt;:&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;19&lt;/span&gt;    &lt;span class=&quot;hljs-built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt; text;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;20&lt;/span&gt;};&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这份代码有两个转型动作：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;static_cast(*this)[position]&lt;/code&gt;，表示将 MyString&amp;amp; 转换成 const MyString&amp;amp;，&lt;strong&gt;可让其调用 const operator[] 兄弟&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;const_cast&amp;lt;char&amp;amp; style=&quot;font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;&quot;&amp;gt;( … )&lt;/code&gt;，表示将 const char &amp;amp; 转换为 char &amp;amp;，&lt;strong&gt;让其是 non-const operator[] 的返回类型&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;虽然语法有一点点奇特，但「运用 const 成员函数实现 non-const 孪生兄弟 」的技术是值得了解的。&lt;/p&gt;
&lt;p&gt;需要注意的是：我们可以在 non-const 成员函数调用 const 成员函数，但是不可以反过来，在 const 成员函数调用 non-const 成员函数调用，原因是对象有可能因此改动，这会违背了 const 的本意。&lt;/p&gt;
&lt;hr/&gt;&lt;blockquote&gt;
&lt;h4 id=&quot;h02&quot;&gt;&lt;span&gt;细节 02 小结 - 请记住&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;将某些东西声明为 const 可帮助编译器探测出错误用法。const 可以被施加于任何作用域内的对象、函数参数、函数返回类型、成员函数本体。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;当 const 和 non-const 成员函数有着实质等价的实现时，令 non-const 版本调用 const 版本可避免代码重复。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;hr/&gt;&lt;h3 id=&quot;h03-1&quot;&gt;&lt;span&gt;细节 03：确定对象被使用前先被初始化&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;内置类型初始化&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果你这么写：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cpp&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; x;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在某些语境下 x 保证被初始化为 0，但在其他语境中却不保证。那么可能在读取未初始化的值会导致不明确的行为。&lt;/p&gt;
&lt;p&gt;为了避免不确定的问题，最佳的处理方法就是：永远在使用对象之前将它初始化。 例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cpp&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; x = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;                    &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;char&lt;/span&gt;* text = &lt;span class=&quot;hljs-string&quot;&gt;&quot;abc&quot;&lt;/span&gt;;     &lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;blockquote&gt;
&lt;p&gt;构造函数初始化&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于内置类型以外的任何其他东西，初始化责任落在&lt;strong&gt;构造函数&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;规则很简单：确保每一个构造函数都将对象的&lt;strong&gt;每一个成员初始化&lt;/strong&gt;。但是别混淆了&lt;strong&gt;赋值&lt;/strong&gt;和&lt;strong&gt;初始化&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;考虑用一个表现学生的class，其构造函数如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;cpp language-cpp hljs&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 1&lt;/span&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Student&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 2&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt;:&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 3&lt;/span&gt;    Student(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; id, &lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt;&amp;amp; name, &lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;hljs-built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;amp; score)&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 4&lt;/span&gt;    {&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 5&lt;/span&gt;        m_Id = id;          &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 6&lt;/span&gt;        m_Name = name;      &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 7&lt;/span&gt;        m_Score = score;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 8&lt;/span&gt;    }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 9&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt;:&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;10&lt;/span&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; m_Id;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;11&lt;/span&gt;    &lt;span class=&quot;hljs-built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt; m_Name;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;12&lt;/span&gt;    &lt;span class=&quot;hljs-built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;hljs-built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;&amp;gt; m_Score;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;13&lt;/span&gt;};&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的做法并非初始化，而是赋值，这不是最佳的做法。因为 &lt;strong&gt;C++ 规定，对象的成员变量的初始化动作发生在进入构造函数本体之前，在构造函数内，都不算是被初始化，而是被赋值&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;初始化的写法是使用成员初值列，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;cpp language-cpp hljs&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;1&lt;/span&gt;    Student(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; id,&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;2&lt;/span&gt;            &lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt; &amp;amp;name,&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;3&lt;/span&gt;            &lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;hljs-built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;&amp;gt; &amp;amp;score)&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;4&lt;/span&gt;            : m_Id(id),&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;5&lt;/span&gt;              m_Name(name),  &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;6&lt;/span&gt;              m_Score(score) &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;7&lt;/span&gt;     {}                      &lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个构造函数和上一个构造函数的最终结果是一样的，但是效率较高，凸显在：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;上一个构造函数（赋值版本）首先会先自动调用 &lt;code&gt;m_Name&lt;/code&gt; 和 &lt;code&gt;m_Score&lt;/code&gt; 对象的&lt;strong&gt;默认构造函数&lt;/strong&gt;作为初值，然后在构造函数体内立刻再对它们进行&lt;strong&gt;赋值操作&lt;/strong&gt;，这期间经历了&lt;strong&gt;两个&lt;/strong&gt;步骤。&lt;/li&gt;
&lt;li&gt;这个构造函数（成员初值列）避免了这个问题，&lt;strong&gt;只会发生了一次复制构造函数&lt;/strong&gt;，本例中的 &lt;code&gt;m_Name&lt;/code&gt; 以 &lt;code&gt;name&lt;/code&gt; 为初值进行复制构造，&lt;code&gt;m_Score&lt;/code&gt; 以 &lt;code&gt;score&lt;/code&gt; 为初值进行复制构造。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;另外一个注意的是初始化次序（顺序），初始化次序（顺序）：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;先是基类对象，再初始化派生类对象（如果存在继承关系）；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;在类里成员变量总是以声明次序被初始化，如本例中 &lt;code&gt;m_Id&lt;/code&gt; 先被初始化，再是 &lt;code&gt;m_Name&lt;/code&gt;，最后是 &lt;code&gt;m_Score&lt;/code&gt;，否则会出现编译出错。&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;避免「跨编译单元之初始化次序」的问题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;现在，我们关系的问题涉及至少两个以上源码文件，每一个内含至少一个 non-local static 对象。&lt;/p&gt;
&lt;p&gt;存在的问题是：如果有一个 non-local static 对象需要等另外一个 non-local static 对象初始化后，才可正常使用，那么这里就需要&lt;strong&gt;保证次序&lt;/strong&gt;的问题。&lt;/p&gt;
&lt;p&gt;下面提供一个例子来对此理解：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;cpp language-cpp hljs&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;FileSystem&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;2&lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt;:&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;4&lt;/span&gt;    ...&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;5&lt;/span&gt;    &lt;span class=&quot;hljs-built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;hljs-keyword&quot;&gt;size_t&lt;/span&gt; numDisk() &lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt;; &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;6&lt;/span&gt;    ...&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;7&lt;/span&gt;};&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;extern&lt;/span&gt; FileSystem tfs; &lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现假设另外一个程序员建立一个class 用以处理文件系统内的目录，很自然他们会用上 tfs 对象：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;cpp language-cpp hljs&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Directory&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;2&lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt;:&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;4&lt;/span&gt;    Directory( params )&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;5&lt;/span&gt;    {&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;6&lt;/span&gt;        &lt;span class=&quot;hljs-built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;hljs-keyword&quot;&gt;size_t&lt;/span&gt; disks = tfs.numDisk(); &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;7&lt;/span&gt;    }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;8&lt;/span&gt;    ...&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;9&lt;/span&gt;};&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用 Directory 对象：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cs&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;hljs-function&quot;&gt;Directory &lt;span class=&quot;hljs-title&quot;&gt;tempDir&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;params&lt;/span&gt; &lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么现在，初始化次序的重要性凸显出来了，除非 tfsd 对象在 tempDir 对象之前被初始化，否则 tempDir 的构造函数会用到尚未初始化的 tfs， 就会出现&lt;strong&gt;未定义的现象&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;由于 C++ 对「定义于不同的编译单元内的 non-local static 对象」的初始化相对次序并无明确定义。但我们可以通过一个小小的设计，解决这个问题。&lt;/p&gt;
&lt;p&gt;唯一需要做的是：将每个 non-local static 对象搬到自己的专属函数内（该对象在此函数内被声明为 static），这些函数返回一个引用指向它所含的对象。&lt;/p&gt;
&lt;p&gt;没错也就是&lt;strong&gt;单例模式&lt;/strong&gt;，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cpp&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 1&lt;/span&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;FileSystem&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 2&lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 3&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt;:&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 4&lt;/span&gt;    ...&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 5&lt;/span&gt;    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; FileSystem&amp;amp; &lt;span class=&quot;hljs-title&quot;&gt;getTfs&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 6&lt;/span&gt;    &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 7&lt;/span&gt;        &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; FileSystem tfs;  &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 8&lt;/span&gt;        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; tfs;             &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 9&lt;/span&gt;    }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;10&lt;/span&gt;    ...&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;11&lt;/span&gt;};&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;12&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;13&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;14&lt;/span&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Directory&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;15&lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt;:&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;17&lt;/span&gt;   ...&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;18&lt;/span&gt;    Directory( params )&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;19&lt;/span&gt;    {&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;20&lt;/span&gt;        &lt;span class=&quot;hljs-built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;hljs-keyword&quot;&gt;size_t&lt;/span&gt; disks = FileSystem::getTfs().numDisk(); &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;21&lt;/span&gt;    }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;22&lt;/span&gt;    ...&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;23&lt;/span&gt;};&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这么修改后，Directory 构造函数就会先初始化 tfs 对象，就可以避免次序问题了。虽然内含了 static 对象，但是在 C++11 以上是线程安全的。&lt;/p&gt;
&lt;hr/&gt;&lt;blockquote&gt;
&lt;h4 id=&quot;h03&quot;&gt;&lt;span&gt;细节 03 小结 - 请记住&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;为内置类型进行手工初始化，因为 C++ 不保证初始化它们。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;构造函数最好使用成员初值列，而不要在构造函数本体内使用赋值操作。初值列列出的成员变量，其排列次序应该和它们在 class 中的声明次序（顺序）相同。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;为避免“跨编译单元之初始化次序”的问题，请以 local static 对象替代 non-local static 对象。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;hr/&gt;&lt;h2 id=&quot;h2&quot;&gt;&lt;span&gt;2 构造/析构/赋值运算&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;h04c&quot;&gt;&lt;span&gt;细节 04：了解 C++ 默默编写并调用哪些函数&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;当你写了如下的空类：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;cpp language-cpp hljs&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Student&lt;/span&gt; {&lt;/span&gt; };&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;编译器就会它声明，并且这些函数都是 public 且 inline：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;复制构造函数&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;赋值操作符函数&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;析构函数&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;默认构造函数（如果没有声明任何构造函数）&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;就好像你写下这样的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;cpp language-cpp hljs&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Student&lt;/span&gt; &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;2&lt;/span&gt;{&lt;/span&gt; &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;3&lt;/span&gt;    Student() { ... }                              &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;4&lt;/span&gt;    Student(&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; Student&amp;amp; rhs) { ... }            &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;5&lt;/span&gt;    Student&amp;amp; &lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt;=(&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; Student&amp;amp; rhs) { ... } &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;6&lt;/span&gt;    ~Student() { ... }                             &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;7&lt;/span&gt;};&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;唯有当这些函数被需要调用时，它们才会被编译器创建出来&lt;/strong&gt;，下面代码造成上述每一个函数被编译器产出：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cpp&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;1&lt;/span&gt;Student stu1;         &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;2&lt;/span&gt;                      &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;hljs-function&quot;&gt;Student &lt;span class=&quot;hljs-title&quot;&gt;stu2&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(stu1)&lt;/span&gt;&lt;/span&gt;;   &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;4&lt;/span&gt;stu2 = stu1;          &lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;编译器为我们写的函数，来说说这些函数做了什么？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;默认构造函数和析构函数主要是给编译器一个地方用来放置隐藏幕后的代码，像是调用基类和非静态成员变量的构造函数和析构函数。注意，编译器产出的析构函数是个 non-virtual，除非这个 class 的 base class 自身声明有 virtual 析构函数。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;复制构造函数和赋值操作符函数，编译器创建的版本只是单纯地将来源对象的每一个非静态成员变量拷贝到目标对象。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;编译器拒绝为 class 生出 operator= 的情况&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于赋值操作符函数，只有当生出的代码合法且有适当机会证明它有意义，才会生出 &lt;code&gt;operator=&lt;/code&gt; ，若万一两个条件有一个不符合，则编译器会&lt;strong&gt;拒绝&lt;/strong&gt;为 class 生出 &lt;code&gt;operator=&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cpp&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 1&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;T&lt;/span&gt;&amp;gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 2&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Student&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 3&lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 4&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt;:&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 5&lt;/span&gt;    Student(&lt;span class=&quot;hljs-built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt; &amp;amp; name, &lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; T&amp;amp; id); &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 6&lt;/span&gt;    ...                          &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 7&lt;/span&gt;priavte:&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 8&lt;/span&gt;    &lt;span class=&quot;hljs-built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt;&amp;amp; m_Name;    &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 9&lt;/span&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; T m_Id; &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;10&lt;/span&gt;};&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现考虑下面会发生什么：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cpp&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;name1&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;小美&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;name2&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;小林&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;4&lt;/span&gt;Student&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;&amp;gt; p(name1, &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;5&lt;/span&gt;Student&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;&amp;gt; s(name2, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;7&lt;/span&gt;p = s;            &lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;赋值之前， &lt;code&gt;p.m_Name&lt;/code&gt; 和 &lt;code&gt;s.m_Name&lt;/code&gt; 都指向 &lt;code&gt;string&lt;/code&gt; 对象且不是同一个。赋值之后 &lt;code&gt;p.m_Name&lt;/code&gt; 应该指向 &lt;code&gt;s.m_Name&lt;/code&gt; 所指的那个 &lt;code&gt;string&lt;/code&gt; 吗？也就是说引用自身可被改动吗？如果是，那就开辟了新天地，&lt;strong&gt;因为 C++ 并不允许「让引用更改指向不同对象」&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;面对这个难题，C++ 的响应是拒绝编译那一行赋值动作，本例子拒绝生成的 &lt;code&gt;operator=&lt;/code&gt; 原因如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果你需要在一个「内含引用的成员」（如本例的 &lt;code&gt;m_Name&lt;/code&gt; ）的class 内支持赋值操作，你必须自己定义赋值操作函数，这种情况是编译器不会为你自动生成赋值操作函数的。&lt;/li&gt;
&lt;li&gt;还有面对「内含 &lt;code&gt;const&lt;/code&gt; 成员」（如本例的 &lt;code&gt;m_Id&lt;/code&gt; ）的class，编译器也是会拒绝生成 &lt;code&gt;operator=&lt;/code&gt;，因为更改 &lt;code&gt;const&lt;/code&gt; 成员是不合法的。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;最后还有一个情况：如果某个基类将 &lt;code&gt;operator=&lt;/code&gt; 函数声明为 &lt;code&gt;private&lt;/code&gt; ，编译器将拒绝为其派生类生成 &lt;code&gt;operator=&lt;/code&gt; 函数。&lt;/p&gt;
&lt;hr/&gt;&lt;blockquote&gt;
&lt;h4 id=&quot;h04&quot;&gt;&lt;span&gt;细节 04 小结 - 请记住&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;编译器可以暗自为 class 创建默认构造函数（如果没有声明任何构造函数）、复制构造函数、赋值操作符函数，以及析构函数。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;编译器拒绝为 class 创建 operator= 函数情况：（1） 内含引用的成员、（2） 内含 const 的成员、（3）基类将 operator= 函数声明为 private。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;hr/&gt;&lt;h3 id=&quot;h05-1&quot;&gt;&lt;span&gt;细节 05：若不想使用编译器自动生成的函数，就该明确拒绝&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;在不允许存在一模一样的两个对象的情况下，可以把&lt;strong&gt;复制构造函数和赋值操作符函数&lt;/strong&gt;声明为 private，这样既可防止编译器自动生成这两个函数。如下例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;cpp language-cpp hljs&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Student&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;2&lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt;:&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;4&lt;/span&gt;    ...&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt;:&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;6&lt;/span&gt;    ... &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;7&lt;/span&gt;    Student(&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; Student&amp;amp;);             &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;8&lt;/span&gt;    Student&amp;amp; &lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt;=(&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; Student&amp;amp;);  &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;9&lt;/span&gt;};&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样的话，Student 对象就无法操作下面的情况了：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;cpp language-cpp hljs&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;1&lt;/span&gt;Student stu1;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;hljs-function&quot;&gt;Student &lt;span class=&quot;hljs-title&quot;&gt;stu2&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(stu1)&lt;/span&gt;&lt;/span&gt;;   &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;4&lt;/span&gt;stu2 = stu1;          &lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;更容易扩展的解决方式是，可以专门写一个为阻止 copying 动作的基类：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cpp&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Uncopyale&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;2&lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;3&lt;/span&gt;protect:              &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;4&lt;/span&gt;    Uncopyale() {}                &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;5&lt;/span&gt;    ~Uncopyale() {}&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt;:             &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;7&lt;/span&gt;    Uncopyale(&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; Uncopyale&amp;amp;);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;8&lt;/span&gt;    Uncopyale&amp;amp; operater=(&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; Uncopyale&amp;amp;);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;9&lt;/span&gt;};&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用方式很简单，只需要 &lt;code&gt;private&lt;/code&gt; 形式的继承：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cpp&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Student&lt;/span&gt; :&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; Uncopyale{  &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;2&lt;/span&gt;    ...  &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;3&lt;/span&gt;};&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么只要某个类需要禁止 copying 动作，则只需要 &lt;code&gt;private&lt;/code&gt; 形式的继承 &lt;code&gt;Uncopyale&lt;/code&gt; 基类即可。&lt;/p&gt;
&lt;hr/&gt;&lt;blockquote&gt;
&lt;h4 id=&quot;h05&quot;&gt;&lt;span&gt;细节 05 小结 - 请记住&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;如果不想编译器自动生成函数，可将相应的成员函数声明为 private 并且不予实现。使用像 Uncopyale 这样的基类也是一种做法。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;hr/&gt;&lt;h3 id=&quot;h06virtual&quot;&gt;&lt;span&gt;细节 06：为多态基类声明 virtual 析构函数&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;多态特性的基础内容，可移步到我的旧文进行学习 --&amp;gt; &lt;a href=&quot;https://mp.weixin.qq.com/s/CeCuXuCjYROgNLmUiLtlHA&quot;&gt;掌握了多态的特性，写英雄联盟的代码更少啦！&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;多态性质基类需声明 virtual 析构函数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果在多态性质的基类，没有声明一个 &lt;code&gt;virtual&lt;/code&gt; 析构函数，那么在 &lt;code&gt;delete&lt;/code&gt; 基类指针对象的时候，只会调用基类的析构函数，而不会调用派生类的析构函数，这就是存在了&lt;strong&gt;泄漏内存和其他资源的情况&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如下有多态性质基类，没有声明一个 &lt;code&gt;virtual&lt;/code&gt; 析构函数的例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cpp&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 2&lt;/span&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;A&lt;/span&gt; &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 3&lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 4&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt;: &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 5&lt;/span&gt;    A()  &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 6&lt;/span&gt;    {&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 7&lt;/span&gt;        &lt;span class=&quot;hljs-built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;construct A&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;hljs-built_in&quot;&gt;endl&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 8&lt;/span&gt;    }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;10&lt;/span&gt;    ~A() &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;11&lt;/span&gt;    {&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;12&lt;/span&gt;        &lt;span class=&quot;hljs-built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;Destructor A&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;hljs-built_in&quot;&gt;endl&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;13&lt;/span&gt;    }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;14&lt;/span&gt;};&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;15&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;16&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;17&lt;/span&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;B&lt;/span&gt; :&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; A &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;18&lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;19&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt;: &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;20&lt;/span&gt;    B()  &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;21&lt;/span&gt;    {&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;22&lt;/span&gt;        &lt;span class=&quot;hljs-built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;construct B&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;hljs-built_in&quot;&gt;endl&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;23&lt;/span&gt;    }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;24&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;25&lt;/span&gt;    ~B()&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;26&lt;/span&gt;    {&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;27&lt;/span&gt;        &lt;span class=&quot;hljs-built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;Destructor B&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;hljs-built_in&quot;&gt;endl&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;28&lt;/span&gt;    }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;29&lt;/span&gt;};&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;30&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;31&lt;/span&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;32&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;33&lt;/span&gt;    A *pa = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; B();&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;34&lt;/span&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;delete&lt;/span&gt; pa;    &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;35&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;36&lt;/span&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;37&lt;/span&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs delphi&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;1&lt;/span&gt;construct A&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;2&lt;/span&gt;construct B&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;Destructor&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;A&lt;/span&gt; &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;4&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面的结果，是发现了在 &lt;code&gt;delete&lt;/code&gt; 基本对象指针时，没有调用派生类 &lt;code&gt;B&lt;/code&gt; 的析构函数。问题出在 &lt;code&gt;pa&lt;/code&gt; 指针指向派生类对象，而那个对象却经由一个基类指针被删除，而目前的基类没有 &lt;code&gt;virtual&lt;/code&gt; 析构函数。&lt;/p&gt;
&lt;p&gt;消除这个问题的做法很简单：为了避免泄漏内存和其他资源，需要把基类的析构函数声明为 &lt;code&gt;virtual&lt;/code&gt; 析构函数。改进如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cpp&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 2&lt;/span&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;A&lt;/span&gt; &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 3&lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 4&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt;: &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 5&lt;/span&gt;    ....            &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 6&lt;/span&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;virtual&lt;/span&gt; ~A()   &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 7&lt;/span&gt;    {&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 8&lt;/span&gt;        &lt;span class=&quot;hljs-built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;Destructor A&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;hljs-built_in&quot;&gt;endl&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 9&lt;/span&gt;    }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;10&lt;/span&gt;};&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;11&lt;/span&gt;...                &lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此后删除派生类对象就会如你想要的那般，是的，它会销毁整个对象，包括所有派生类成份。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;非多态性质基类无需声明 virtual 函数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当类的设计目的不是被当做基类，令其析构函数为 &lt;code&gt;virtual&lt;/code&gt; 往往是个&lt;strong&gt;馊主意&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;若类里声明了 &lt;code&gt;virtual&lt;/code&gt; 函数，对象必须携带某些信息。主要用来运行期间决定哪一个 &lt;code&gt;virtual&lt;/code&gt; 函数被调用。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;这份信息通常是由一个所谓 vptr（virtual table pointer —— 虚函数表指针）指针指出。vptr 指向一个由函数指针构成的数组，称为 vtbl（virtual table —— 虚函数表）；每一个带有 virtual 函数的类都有一个相应的 vtbl。当对象调用某一 virtual 函数，实际被调用的函数取决于该对象的 vptr 所指向的那个 vtbl，接着编译器在其中寻找适当的函数指针，从而调用对应类的函数。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;既然内含 virtual 函数的类的对象必须会携带信息，那么必然其对象的体积是会增加的。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;在 32 位计算机体系结构中将多占用 4个字节（存放 vptr ）；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;在 64 位计算机体系结构则将多占用 8 个字节（存放 vptr ）。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;因此，无端地将所有类的析构函数声明为 virtual ，是错误的，原因是会增加不必要的体积。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;许多人的心得是：只有当 class 内含至少一个 virtual 函数，才为它声明 virtual 析构函数。&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;blockquote&gt;
&lt;h4 id=&quot;h06&quot;&gt;&lt;span&gt;细节 06 小结 - 请记住&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;在多态性质的基类，应该声明一个 virtual 析构函数。如果 class 带有任何 virtual 函数，它就应该拥有一个 virtual 析构函数。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;类的设计目的如果不是为基类使用的，或不是为了具备多态性，就不该声明 virtual 析构函数。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;hr/&gt;&lt;h3 id=&quot;h07virtual&quot;&gt;&lt;span&gt;细节 07：绝不在构造和析构过程中调用 virtual 函数&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;我们不该在构造函数和析构函数体内调用 &lt;code&gt;virtual&lt;/code&gt; 函数，因为这样的调用不会带来你预想的结果。&lt;/p&gt;
&lt;p&gt;我们看如下的代码例子，来说明：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;cpp language-cpp hljs&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 2&lt;/span&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;CFather&lt;/span&gt; &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 3&lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 4&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt;:&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 5&lt;/span&gt;    CFather()&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 6&lt;/span&gt;    {&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 7&lt;/span&gt;        hello();&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 8&lt;/span&gt;    }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;10&lt;/span&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;virtual&lt;/span&gt; ~CFather()&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;11&lt;/span&gt;    {&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;12&lt;/span&gt;        bye();&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;13&lt;/span&gt;    }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;14&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;15&lt;/span&gt;    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;16&lt;/span&gt;    &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;17&lt;/span&gt;        &lt;span class=&quot;hljs-built_in&quot;&gt;cout&lt;/span&gt;&amp;lt;&amp;lt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;hello from father&quot;&lt;/span&gt;&amp;lt;&amp;lt;&lt;span class=&quot;hljs-built_in&quot;&gt;endl&lt;/span&gt;; &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;18&lt;/span&gt;    }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;19&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;20&lt;/span&gt;    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;bye&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;21&lt;/span&gt;    &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;22&lt;/span&gt;        &lt;span class=&quot;hljs-built_in&quot;&gt;cout&lt;/span&gt;&amp;lt;&amp;lt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;bye from father&quot;&lt;/span&gt;&amp;lt;&amp;lt;&lt;span class=&quot;hljs-built_in&quot;&gt;endl&lt;/span&gt;; &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;23&lt;/span&gt;    }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;24&lt;/span&gt;};&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;25&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;26&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;27&lt;/span&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;CSon&lt;/span&gt; :&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; CFather&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;28&lt;/span&gt;{ &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;29&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt;:&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;30&lt;/span&gt;    CSon() &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;31&lt;/span&gt;    { &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;32&lt;/span&gt;        hello(); &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;33&lt;/span&gt;    }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;34&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;35&lt;/span&gt;    ~CSon()  &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;36&lt;/span&gt;    { &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;37&lt;/span&gt;        bye();&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;38&lt;/span&gt;    }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;39&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;40&lt;/span&gt;    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;41&lt;/span&gt;    &lt;/span&gt;{ &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;42&lt;/span&gt;        &lt;span class=&quot;hljs-built_in&quot;&gt;cout&lt;/span&gt;&amp;lt;&amp;lt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;hello from son&quot;&lt;/span&gt;&amp;lt;&amp;lt;&lt;span class=&quot;hljs-built_in&quot;&gt;endl&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;43&lt;/span&gt;    }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;44&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;45&lt;/span&gt;    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;bye&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;46&lt;/span&gt;    &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;47&lt;/span&gt;        &lt;span class=&quot;hljs-built_in&quot;&gt;cout&lt;/span&gt;&amp;lt;&amp;lt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;bye from son&quot;&lt;/span&gt;&amp;lt;&amp;lt;&lt;span class=&quot;hljs-built_in&quot;&gt;endl&lt;/span&gt;; &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;48&lt;/span&gt;    }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;49&lt;/span&gt;};&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在，当以下这行被执行时，会发生什么事情：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs nginx&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;CSon&lt;/span&gt; son;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;先列出输出结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs coffeescript&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;1&lt;/span&gt;hello &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; father&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;2&lt;/span&gt;hello &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; son&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;3&lt;/span&gt;bye &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; son&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;4&lt;/span&gt;bye &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; father&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;无疑地会有一个 CSon（派生类） 构造函数被调用，但首先 CFather（基类） 构造函数一定会更早被调用。 CFather（基类） 构造函数体力调用 virtual 函数 hello，这正是引发惊奇的起点。这时候被调用的 hello 是 CFather 内的版本，而不是 CSon 内的版本。&lt;/p&gt;
&lt;p&gt;说明，&lt;strong&gt;基类构造期间 virtual 函数绝不会下降到派生类阶层&lt;/strong&gt;。取而代之的是，对象的作为就像隶属于基类类型一样。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;非正式的说法或许比较传神：在基类构造期间，virtual 函数不是 virtual 函数。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;相同的道理，也适用于析构函数。&lt;/p&gt;
&lt;hr/&gt;&lt;blockquote&gt;
&lt;h4 id=&quot;h07&quot;&gt;&lt;span&gt;细节 07 小结 - 请记住&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;在构造和析构期间不要调用 virtual，因为这类调用不会下降至派生类。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;hr/&gt;&lt;h3 id=&quot;h08operatorreferencetothis&quot;&gt;&lt;span&gt;细节 08：令 operator= 返回一个 reference to *this&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;关于赋值，又去的是你可以把它们写成连锁形式：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cpp&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; x, y, z;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;2&lt;/span&gt;x = y = z = &lt;span class=&quot;hljs-number&quot;&gt;15&lt;/span&gt;;  &lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同样有趣的是，赋值采用右结合律，所以上述连锁赋值被解析为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs ini&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;hljs-attr&quot;&gt;x&lt;/span&gt; = (y = ( z = &lt;span class=&quot;hljs-number&quot;&gt;15&lt;/span&gt; ));&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里 15 先被赋值给 z，然后其结果再被赋值给 y，然后其结果再赋值给 x 。&lt;/p&gt;
&lt;p&gt;为了实现「连锁赋值」，赋值操作必须返回一个 reference （引用）指向操作符的左侧实参。这是我们为 classes 实现赋值操作符时应该遵循的协议：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;cpp language-cpp hljs&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 1&lt;/span&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;A&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 2&lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 3&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt;:&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 4&lt;/span&gt;...&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 5&lt;/span&gt;    A&amp;amp; &lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt;=(&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; A&amp;amp; rhs) &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 6&lt;/span&gt;    {&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 7&lt;/span&gt;        ...&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 8&lt;/span&gt;        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; *&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;;           &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 9&lt;/span&gt;    }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;10&lt;/span&gt;...&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;11&lt;/span&gt;};&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个协议不仅适用于以上标准赋值形式，也适用于所有赋值相关运算（+=, -=, *=, 等等），例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;cpp language-cpp hljs&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 1&lt;/span&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;A&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 2&lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 3&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt;:&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 4&lt;/span&gt;...&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 5&lt;/span&gt;    A&amp;amp; &lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt;+=(&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; A&amp;amp; rhs) &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 6&lt;/span&gt;    {&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 7&lt;/span&gt;        ...&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 8&lt;/span&gt;        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; *&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;;           &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 9&lt;/span&gt;    }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;10&lt;/span&gt;...&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;11&lt;/span&gt;};&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意，这只是个协议，并无强制性。如果不遵循它，代码一样可以通过编译，但是会&lt;strong&gt;破坏原本的编程习惯。&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;blockquote&gt;
&lt;h4 id=&quot;h08&quot;&gt;&lt;span&gt;细节 08 小结 - 请记住&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;令赋值操作符返回一个 reference to *this。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;hr/&gt;&lt;h3 id=&quot;h09operator&quot;&gt;&lt;span&gt;细节 09：在 operator= 中处理「自我赋值」&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;「自我赋值」发生在对象被赋值给自己时：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cpp&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;A&lt;/span&gt; {&lt;/span&gt; ... };&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;2&lt;/span&gt;A a;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;3&lt;/span&gt;...&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;4&lt;/span&gt;a = a;   &lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这看起来有点愚蠢，但它合法，所以不要认定我们自己绝对不会那么做。&lt;/p&gt;
&lt;p&gt;此外赋值动作并不总是那么一眼被识别出来，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs ini&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;hljs-attr&quot;&gt;a[i]&lt;/span&gt; = a[j]; // 潜在的自我赋值&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果 i 和 j 有相同的值，这便是个自我赋值。再看：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cpp&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;1&lt;/span&gt;*px = *py;  &lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果 px 和 py 刚好指向同一个东西，这也是自我赋值，这些都是并不明显的自我赋值。&lt;/p&gt;
&lt;p&gt;考虑到我们的类内含指针成员变量：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cpp&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;B&lt;/span&gt; {&lt;/span&gt; ... };&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;A&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;3&lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;4&lt;/span&gt;...&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt;:&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;6&lt;/span&gt;    B * pb; &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;7&lt;/span&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面是operator = 实现代码，表面上看起来合理，但自我赋值出现时并不安全：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;cpp language-cpp hljs&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;1&lt;/span&gt;A&amp;amp; A::&lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt;=(&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; A&amp;amp; rhs) &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;2&lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;3&lt;/span&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;delete&lt;/span&gt; pb;             &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;4&lt;/span&gt;    pb = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; B(*rhs.pb);  &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;5&lt;/span&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; *&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;6&lt;/span&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的自我赋值的问题是， &lt;code&gt;operator=&lt;/code&gt; 函数内的 *this（赋值的目的端）和 rhs 有可能是&lt;strong&gt;同一个对象&lt;/strong&gt;。果真如此 delete 就不只是销毁当前对象的 pb，它也销毁 rhs 的 pb。&lt;/p&gt;
&lt;p&gt;相当于发生了自我销毁（自爆/自灭）过程，那么此时 A 类对象持有了一个指向一个被销毁的 B 类对象。非常的危险，请勿模仿！&lt;/p&gt;
&lt;p&gt;下面来说说如何规避这种问题的方式。&lt;/p&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;方式一：比较来源对象和目标对象的地址&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;要想阻止这种错误，传统的做法是在 &lt;code&gt;operator=&lt;/code&gt; 函数最前面加一个 &lt;code&gt;if&lt;/code&gt; 判断，判断是否是自己，不是才进行赋值操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;cpp language-cpp hljs&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;1&lt;/span&gt;A&amp;amp; A::&lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt;=(&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; A&amp;amp; rhs) &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;2&lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;3&lt;/span&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt; == &amp;amp;rhs) &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;4&lt;/span&gt;       &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; *&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;;    &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;6&lt;/span&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;delete&lt;/span&gt; pb;             &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;7&lt;/span&gt;    pb = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; B(*rhs.pb);   &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;8&lt;/span&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; *&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;9&lt;/span&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样错虽然行得通，但是不具备自我赋值的安全性，也不具备异常安全性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;如果「 new B 」这句发生了异常（申请堆内存失败的情况），A 最终会持有一个指针指向一块被删除的 B，这样的指针是有害的。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我旧文里《&lt;a href=&quot;https://mp.weixin.qq.com/s/v2NBHXjD-opzubiQXMo8hA&quot;&gt;C++ 赋值运算符'='的重载（浅拷贝、深拷贝）&lt;/a&gt;》在规避这个问题试，就采用的是方式 一，这个方式是不合适的。&lt;/p&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;方式二：精心周到的语句顺序&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;把代码的顺序重新编排以下就可以避免此问题，例如一下代码，我们只需之一在赋值 pb 所指东西之前别删掉 pb :&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;cpp language-cpp hljs&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;1&lt;/span&gt;A&amp;amp; A::&lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt;=(&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; A&amp;amp; rhs) &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;2&lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;3&lt;/span&gt;    A* pOrig = pb;       &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;4&lt;/span&gt;    pb = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; B(*rhs.pb); &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;5&lt;/span&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;delete&lt;/span&gt; pOrig;        &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;6&lt;/span&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; *&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;7&lt;/span&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在，如果「 new B 」这句发生了异常，pb 依然保持原状。即使没有加 if 自我判断，这段代码还是能够处理自我赋值，因为我们对原 B 做了一份副本、删除原 B 、然后返回引用指向新创造的那个副本。&lt;/p&gt;
&lt;p&gt;它或许不是处理自我赋值的最高效的方法，但它行得通。&lt;/p&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;方式三：copy and swap&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;更高效的方式使用所谓的 copy and swap 技术，实现方法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;cpp language-cpp hljs&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 1&lt;/span&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;A&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 2&lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 3&lt;/span&gt;...&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 4&lt;/span&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;swap&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(A&amp;amp; rhs)&lt;/span&gt; &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 5&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 6&lt;/span&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;std&lt;/span&gt;::swap;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 7&lt;/span&gt;    swap(pb, rhs.pb);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 8&lt;/span&gt;}  &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 9&lt;/span&gt;... &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt;:&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;11&lt;/span&gt;    B * pb; &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;12&lt;/span&gt;}&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;13&lt;/span&gt;};&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;14&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;15&lt;/span&gt;A&amp;amp; A::&lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt;=(&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; A&amp;amp; rhs)&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;16&lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;17&lt;/span&gt;    A temp(rhs); &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;18&lt;/span&gt;    swap(tmp);   &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;19&lt;/span&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; *&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;20&lt;/span&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当类里 &lt;code&gt;operator=&lt;/code&gt; 函数被声明为「以 by value 方式接受实参」，那么由于 by value 方式传递东西会造成一份复件（副本），则直接 swap 交换即可，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs kotlin&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;1&lt;/span&gt;A&amp;amp; A::&lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt;=(A rhs) &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;2&lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;3&lt;/span&gt;    swap(rhs);        &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;4&lt;/span&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; *&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;5&lt;/span&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;blockquote&gt;
&lt;h4 id=&quot;h09&quot;&gt;&lt;span&gt;细节 09 小结 - 请记住&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;确保当对象自我赋值时，operator= 有良好行为。其中技术包括比较来源对象和目标对象的地址、精心周到的语句顺序、以及 copy-and-swap。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;确保任何函数如果操作一个以上的对象，而其中多个对象是同个对象时，其行为忍然正常。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;hr/&gt;&lt;h3 id=&quot;h10-1&quot;&gt;&lt;span&gt;细节 10：复制对象时勿忘其每一个成分&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;在以下我把&lt;strong&gt;复制构造函数和赋值操作符函数&lt;/strong&gt;，称为「copying 函数」。&lt;/p&gt;
&lt;p&gt;如果你声明自己的 copying 函数，那么编译器就不会创建默认的 copying 函数。但是，当你在实现 copying 函数，遗漏了某个成分没被 copying，编译器却不会告诉你。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;确保对象内的所有成员变量 copying&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;考虑用一个 class 用来表示学生，其中自实现 copying 函数，如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;cpp language-cpp hljs&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 1&lt;/span&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Student&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 2&lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 3&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt;:&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 4&lt;/span&gt;    ...&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 5&lt;/span&gt;    Student(&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; Student&amp;amp; rhs);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 6&lt;/span&gt;    Student&amp;amp; &lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt;=(&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; Student&amp;amp; rhs);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 7&lt;/span&gt;    ...&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 8&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt;:&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 9&lt;/span&gt;    &lt;span class=&quot;hljs-built_in&quot;&gt;std&lt;/span&gt;:: &lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt; name;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;10&lt;/span&gt;}&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;11&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;12&lt;/span&gt;Student::Student(&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; Student&amp;amp; rhs) &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;13&lt;/span&gt;  : name(rhs.name)   &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;14&lt;/span&gt;{  }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;15&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;16&lt;/span&gt;Student&amp;amp; Student::&lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt;=(&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; Student&amp;amp; rhs)&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;17&lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;18&lt;/span&gt;    name = rhs.name; &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;19&lt;/span&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; *&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;20&lt;/span&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的每一件事情看起来都很好，直到另一个成员变量加入战局：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;cpp language-cpp hljs&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Student&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;2&lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt;:&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;4&lt;/span&gt;    ... &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt;:&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;6&lt;/span&gt;    &lt;span class=&quot;hljs-built_in&quot;&gt;std&lt;/span&gt;:: &lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt; name;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;7&lt;/span&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; score;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;8&lt;/span&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这时候遗漏对新成员变量的 copying。大多数编译器对此不做任何报错。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;结论很明显：如果你为 class 添加一个成员变量，你必须同时修改 copying 函数。&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;确保所有 base class （基类） 成分 copying&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一旦存在继承关系的类，可能会造成此一主题最黑暗肆意的一个潜在危机。试考虑：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;cpp language-cpp hljs&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 1&lt;/span&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;CollegeStudent&lt;/span&gt; :&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; Student &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 2&lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 3&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt;:&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 4&lt;/span&gt;...&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 5&lt;/span&gt;    CollegeStudent(&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; CollegeStudent&amp;amp; rhs);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 6&lt;/span&gt;    CollegeStudent&amp;amp; &lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt;=(&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; CollegeStudent&amp;amp; rhs);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 7&lt;/span&gt;...&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 8&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt;:&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 9&lt;/span&gt;    &lt;span class=&quot;hljs-built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt; major;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;10&lt;/span&gt;};&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;11&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;12&lt;/span&gt;CollegeStudent::CollegeStudent(&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; CollegeStudent&amp;amp; rhs)&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;13&lt;/span&gt; : major(rhs.major)&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;14&lt;/span&gt;{ }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;15&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;16&lt;/span&gt;CollegeStudent&amp;amp; CollegeStudent::&lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt;=(&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; CollegeStudent&amp;amp; rhs)&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;17&lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;18&lt;/span&gt;    major = rhs.major;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;19&lt;/span&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; *&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;20&lt;/span&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;CollegeStudent&lt;/code&gt; 的 copying 函数看起来好像复制了 &lt;code&gt;CollegeStudent&lt;/code&gt; 内的每一样东西，但是请再看一眼。是的，它们复制了 &lt;code&gt;CollegeStudent&lt;/code&gt; 声明的成员变量，但每个 &lt;code&gt;CollegeStudent&lt;/code&gt; 还内含所继承的 &lt;code&gt;Student&lt;/code&gt; 成员变量复件（副本)，而哪些成员变量却未被复制。&lt;/p&gt;
&lt;p&gt;所以任何时候只要我们承担起「为派生类撰写 copying 函数」的重则大任，必须很小心地也复制其 base class 成分：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cpp&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 1&lt;/span&gt;CollegeStudent::CollegeStudent(&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; CollegeStudent&amp;amp; rhs)&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 2&lt;/span&gt; : Student(rhs),  &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 3&lt;/span&gt;   major(rhs.major)&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 4&lt;/span&gt;{ }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 6&lt;/span&gt;CollegeStudent&amp;amp; CollegeStudent::&lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt;=(&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; CollegeStudent&amp;amp; rhs)&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 7&lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 8&lt;/span&gt;    Student::&lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt;=(rhs); &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 9&lt;/span&gt;    major = rhs.major;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;10&lt;/span&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; *&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;11&lt;/span&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;所以我们不仅要确保复制所有类里的成员变量，还要调用所有 base classes 内的适当的 copying 函数。&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;消除 copying 函数之间的重复代码&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;还要一点需要注意的：不要令复制「构造函数」调用「赋值操作符函数」，来减少代码的重复。这么做也是存在危险的，假设调用赋值操作符函数不是你期望的。—— 错误行为。&lt;/p&gt;
&lt;p&gt;同样也不要令「赋值操作符函数」调用「构造函数」。&lt;/p&gt;
&lt;p&gt;如果你发现你的「复制构造函数和赋值操作符函数」有近似的代码，消除重复代码的做法是：&lt;strong&gt;建立一个新的成员函数给两者调用&lt;/strong&gt;。&lt;/p&gt;
&lt;hr/&gt;&lt;blockquote&gt;
&lt;h4 id=&quot;h10&quot;&gt;&lt;span&gt;细节 10 小结 - 请记住&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;Copying 函数（复制构造函数和赋值操作符函数）应该确保复制「对象内的所有成员变量」及「所有 base class（基类） 成分」。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;不要尝试以某个 copying 函数实现另外一个 coping 函数。应该将共同地方放进第三个函数中，并由两个 copying 函数共同调用。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;hr/&gt;
&lt;p&gt;能看完或滑到这里的小伙伴不容易，给你们点赞，感谢你们！&lt;/p&gt;
&lt;p&gt;送上你们要的的思维导图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1770351/202002/1770351-20200212203008411-1072912802.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;hr/&gt;&lt;p&gt;&lt;span&gt;关注公众号，后台回复「&lt;strong&gt;我要学习&lt;/strong&gt;」，即可&lt;strong&gt;免费&lt;/strong&gt;获取精心整理「服务器 Linux C/C++ 」成长路程（&lt;strong&gt;书籍资料 + 思维导图&lt;/strong&gt;）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1770351/202002/1770351-20200212203056526-2066976612.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 12 Feb 2020 12:33:00 +0000</pubDate>
<dc:creator>小林coding</dc:creator>
<og:description>每日一句英语学习，每天进步一点点： “Action may not always bring happiness; but there is no happiness without action.”</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiaolincoding/p/12300745.html</dc:identifier>
</item>
<item>
<title>MOTS：多目标跟踪和分割论文翻译 - Frnas</title>
<link>http://www.cnblogs.com/fans-fan/p/12300739.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fans-fan/p/12300739.html</guid>
<description>&lt;h2 id=&quot;mots多目标跟踪和分割论文翻译&quot;&gt;MOTS：多目标跟踪和分割论文翻译&lt;/h2&gt;
&lt;h4 id=&quot;摘要&quot;&gt;摘要：&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;    本文将目前流行的多目标跟踪技术扩展到多目标跟踪与分割技术(MOTS)。为了实现这个目标，我们使用半自动化的标注为两个现有的跟踪数据集创建了密集的像素级标注。我们的新标注包含了10870个视频帧中977个不同对象(汽车和行人)的65,213个像素掩膜。为了进行评估，我们将现有的多目标跟踪指标扩展到这个任务。同时，我们还提出了一种新的基线方法，该方法通过单个神经网络解决检测，跟踪和分割问题。我们通过在MOTS标注(MOTS annotations)上面训练时实现性能的改进来展示我们数据集的价值。我们相信，我们的数据集，指标和基线将成为开发超出2D边界框的多目标跟踪方法的宝贵资源。我们在下面的网站上提供了注释，代码和模型：[MOTS](https: //www.vision.rwth-aachen.de/page/mots)&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h4 id=&quot;一介绍&quot;&gt;一、介绍：&lt;/h4&gt;
&lt;p&gt;​ 近年来，计算机视觉领域在日益艰难的任务中取得了显著进步。深度学习技术现在在对象检测以及图像和实例分割中具有很好(impressive)的表现。但是，跟踪仍然具有挑战性，尤其是涉及多个对象时。 特别是最近的跟踪评估结果表明边界级跟踪性能已经达到饱和，只有在移动到像素级别时才能进一步改进。因此，我们建议将所有的三个任务---视为需要一起考虑的相互关联的问题。&lt;/p&gt;
&lt;p&gt;​ 用于训练和评估目标分割模型的数据集通常不提供关于视频数据的标注，甚至不提供关于不同图像中对象身份的信息。另一方面，多目标跟踪的常用数据集仅提供对象的边界框注释。这些可能太过于粗糙。例如：当目标被部分遮挡时，其边界框包含来自其他目标而不是自身的信息(参见图1)。在这种情况下，像素级的目标分割可以得到更加自然的场景描述，并为后续的处理提供额外的信息。对于分割掩膜，有一个定义好的ground truth，而许多不同(non-tight)的框可能大致适合一个对象。类似地，与通常需要在评估时通过启发式匹配过程解决的ground truth相比，带有重叠边界框的跟踪会产生歧义。另一方面，根据定义，基于分割的跟踪结果是不重叠的，因此可以直接与ground truth进行比较。&lt;/p&gt;
&lt;center readability=&quot;4&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/80/v2-8d14addcdd01ce9ebc7e76c8c6c09206_hd.jpg&quot;/&gt;&lt;p&gt;图一：分割vs边界框。当对象相互经过时，该对象的边界框的很大一部分可能属于另一个对象，而逐像素分割掩膜则精确定位目标。上图显示来自KITTI MOTS数据集。&lt;/p&gt;
&lt;/center&gt;
&lt;p&gt;​ 因此，本文提出将多目标跟踪任务扩展到实例分割跟踪。我们称这个新任务为“多目标跟踪和分割(MOTS)”。就我们所知，到目前为止还没有这个任务的数据集。虽然文献中有许多方法来用于边界框跟踪，但MOTS需要结合时间和掩码提示才能成功。因此，我们提出TrackR-CNN作为解决MOTS任务的所有方面的基线方法。TrackR-CNN利用3D卷积扩展Mask R-CNN 以结合时间信息，并通过关联头随时间链接对象身份。&lt;/p&gt;
&lt;p&gt;​ 综上所述，本文做出如下贡献：(1) 基于流行的KITTI和MOTChallenge数据集，我们为解决MOTS任务的训练和评估方法提供了两个具有时间一致性对象实例分割的新数据集。(2) 我们提出了一种新的软多目标跟踪和分割准确度(sMOTSA)测量方法，可以同时对新任务的各个方面进行评估。(3) 我们提出了TrackR-CNN作为一种解决检测、跟踪和分割问题的基线方法，并将其与现有的工作进行了比较。(4) 我们证明了新数据集在像素级多对象跟踪器的端到端训练中的有用性。特别是，我们的数据集表明了分割和跟踪程序的联合训练变得可能，并且在例如分割或边界框跟踪方面产生改进，这在以前是可能的。&lt;/p&gt;
&lt;hr/&gt;&lt;h4 id=&quot;二相关工作&quot;&gt;二、相关工作&lt;/h4&gt;
&lt;p&gt;​ &lt;strong&gt;多目标跟踪数据集：&lt;/strong&gt; 在多目标跟踪（MOT）任务中，必须将来自已知类集的最初未知数量的目标作为视频中的边界框来跟踪。特别是目标可以随时进入和离开场景，并且必须经过长时间的遮挡和外观变化才能恢复。许多MOT数据集专注于街景，例如KITTI跟踪数据集，其中包含来自车载摄像头的视频；MOTChallenge数据集显示了来自各种不同视角的行人。UA-DETRAC也有街景，但仅包含车辆标注。另一个MOT数据集是PathTrack，它提供了不同场景中人体轨迹的标注。PoseTrack包含视频中多人的关节位置标注。这些数据集都没有为带注释的对象提供分割掩码，因此无法充分详细地描述图1中所示的复杂交互。&lt;/p&gt;
&lt;p&gt;​ &lt;strong&gt;视频目标分割数据集：&lt;/strong&gt;在视频目标分割（VOS）任务中，在视频的第一帧中提供一个或多个通用目标的实例分割，并且必须在所有后续帧中以像素精度进行分割。现有的VOS数据集仅包含很少的对象，这些对象也存在于大多数帧中。此外，此任务的常见评估指标（区域Jaccard索引和边界F-measure）不会将跟踪多个对象时可能出现的ID变换等错误情况考虑在内。相比之下，MOTS专注于一组预先定义的类别，并考虑具有许多交互对象的拥挤场景。MOTS还增加了发现和跟踪在场景中出现和消失的不同数量的新对象的难度。&lt;/p&gt;
&lt;p&gt;​ VOS任务的数据集包括DAVIS 2016数据集，它专注于单对象VOS，以及DAVIS 2017 数据集，它扩展了多对象VOS的任务。 并且YouTube-VOS数据集同样可用，并且比DAVIS大几个数量级。 此外，Segtrackv2 数据集，FBMS 和YouTube对象数据集的带注释子集都可用于评估此任务。&lt;/p&gt;
&lt;p&gt;​ &lt;strong&gt;视频实例分割数据集。&lt;/strong&gt;Cityscapes，BDD和ApolloScape为汽车场景提供视频数据。 然而，实例标注仅针对非相邻帧的一小部分提供，或者在ApolloScape的情况下，针对每个帧提供，但不随时间推移提供对象身份。 因此，它们不能用于像素级跟踪方法的端到端训练。&lt;/p&gt;
&lt;p&gt;​ &lt;strong&gt;方法。&lt;/strong&gt;虽然对MOT或VOS任务提出的方法的全面回顾超出了本文的范围，但我们将回顾已经解决MOTS任务（子集）或与在其他方面与TrackR-CNN相关的一些工作。&lt;/p&gt;
&lt;p&gt;​ Seguin等人使用超像素级别的聚类从给定的边界框轨迹导出实例分割，但它们不解决检测或跟踪问题。米兰等人考虑利用超像素信息和给定对象检测在CRF中联合跟踪和分割。与这两种方法相反，我们提出的基线在像素而非超像素级别上运行。 CAMOT 使用立体信息对KITTI数据集上的通用对象进行基于掩模的跟踪，这限制了其对远距离对象的准确性。CDTS 执行无监督的VOS，即不使用第一帧信息。它仅考虑具有少量对象外观和消失的短视频剪辑。然而，在MOTS中，许多物体经常进入或离开拥挤的场景。虽然上述方法能够使用分割掩模生成跟踪输出，但由于不存在具有MOTS标注的数据集，因此无法全面评估其性能。&lt;/p&gt;
&lt;p&gt;​ Lu等人通过聚合每帧的位置和外观特征并使用LSTM跨时间组合来实现跟踪。 Sadeghian等人还使用LSTM的组合将通过裁剪检测获得的外观特征与速度和交互信息组合。 在这两种情况下，组合的特征都输入到传统的匈牙利匹配程序中。 对于我们的基线模型，我们直接使用时间信息直接丰富检测，并与检测器一起学习关联特征，而不仅仅是给定检测进行“后处理”。&lt;/p&gt;
&lt;p&gt;​ &lt;strong&gt;半自动注释。&lt;/strong&gt;存在许多用于半自动实例分割的方法，例如， 从涂鸦或点击生成分割掩模。 这些方法需要用户输入每个要分割的对象，而我们的注释过程可以完全自动地分割许多对象，让注释器专注于改善不同情况的结果。 虽然这有点类似于主动学习设置，但我们将使用人工注释器来决定注释哪些对象，以保证所有注释都达到长期基准数据集所需的质量。&lt;/p&gt;
&lt;p&gt;​ 其他半自动注释技术包括Polygon-RNN，它自动预测多边形形式的分割，顶点可以由注释器校正。Fluid Annotation允许注释器操作Mask RCNN预测的片段，以便注释完整的图像。虽然加快了在隔离帧中对象的分割掩码的创建，但这些方法并不在跟踪级别上操作，也不使用现有的边界框注释，也不利用在其他视频帧中为相同对象注释的分割掩码。&lt;/p&gt;
&lt;hr/&gt;&lt;h4 id=&quot;三数据集&quot;&gt;三、数据集&lt;/h4&gt;
&lt;p&gt;​ 为视频中每个对象的每个帧注释像素掩模是一项非常耗时的任务。 因此，这种数据的可用性非常有限。 我们不知道MOTS任务的任何现有数据集。 但是，有一些带有MOT标注的数据集，即在边界框级别标注的轨迹。 对于MOTS任务，这些数据集缺少分割掩模。 因此，我们的注释过程为两个MOT数据集中的边界框添加了分割掩模。 总共，我们注释了65,213个分割掩模。 这种规模使我们的数据集在训练和评估基于学习的技术方面是可行的。&lt;/p&gt;
&lt;p&gt;​ &lt;strong&gt;半自动标注程序。&lt;/strong&gt;为了使标注工作易于管理，我们提出了一种半自动方法，通过分割掩模扩展边界框级别标注。 我们使用卷积网络从边界框自动生成分割掩膜，然后使用手动多边形标注进行校正步骤。 每条轨迹，我们使用手动标注作为附加训练数据来调整初始网络，类似于[6]。 我们迭代生成和校正掩模的过程，直到达到所有注释掩模的像素级精度。&lt;/p&gt;
&lt;p&gt;​ 为了将边界框转换为分割掩模，我们使用基于DeepLabv3+的完全卷积改进网络，该网络将边界框指定的输入图像作为输入，并添加了一个小的上下文区域，以及附加输入通道，将边界框编码为掩模。 在此基础上，细分网络预测给定框的分割掩码。 改进的网络在COCO 和Mapillary 上进行了预训练，然后针对目标数据集进行了手动创建的分割掩模的训练。&lt;/p&gt;
&lt;p&gt;​ 在开始时，我们为所考虑的数据集中的每个对象注释(作为多边形)两个分割掩膜。网络首先在所有手动创建的掩码上进行训练，然后针对每个对象分别进行微调。然后使用这些网络的微调变量来为数据集中各个对象的所有边界框生成分割掩膜。这样，网络就适应了每个对象的外观。对于每个对象使用两个手工标注的分割掩码进行微调，改进的网络已经为其他帧中对象的外观生成了相对良好的掩膜，但通常仍然存在小错误。因此，我们最终会纠正一些有缺陷的生成掩膜，并在迭代过程中重新运行训练过程。我们的标注器还纠正了原始MOT数据集中的不精确或错误的边框标注。&lt;/p&gt;
&lt;p&gt;​ &lt;strong&gt;KITTI MOTS。&lt;/strong&gt;我们在KITTI跟踪数据集的边界框级别注释上执行了上述标注过程。 标注的样本如图2所示。为了便于训练和评估，我们将KITTI跟踪数据集2的21个训练序列分别划分为训练和验证集3。 我们的分配平衡了每个类别的出现次数—汽车和行人—在训练和验证集中大致相等。 统计数字见表1。&lt;/p&gt;
&lt;center readability=&quot;2&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/80/v2-36fc36d81060014a8b647d10730d7b89_hd.jpg&quot;/&gt;&lt;p&gt;图 2：我们标注的样例图片。KITTIMOTS(上)和MOTSChallenge(下)&lt;/p&gt;
&lt;/center&gt;
&lt;center readability=&quot;3&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/80/v2-ac3809ac8ee9fb8a99ab725c5406ef9b_hd.jpg&quot;/&gt;&lt;p&gt;表 1：引入的KITTI MOTS和MOTSChallenge数据集的统计数据。我们考虑行人的数据集和汽车的KITTI MOTS。&lt;/p&gt;
&lt;/center&gt;
&lt;p&gt;​ 需要相对较多的手动标注表明现有的单图像实例分割技术在此任务上仍然表现不佳。 这是我们提出的MOTS数据集的主要动机，其允许将时间推理结合到实例分割模型中。&lt;/p&gt;
&lt;p&gt;​ &lt;strong&gt;MOTSChallenge。&lt;/strong&gt;我们进一步标注了MOTChallenge 2017 训练数据集4的7个序列中的4个，并获得了MOTSChallenge数据集。 MOTSChallenge专注于拥挤场景中的行人，并且由于许多遮挡情况而非常具有挑战性，因为像素方面的描述尤其有益。 标注的样本如图2所示，统计数据在表1中给出。&lt;/p&gt;
&lt;hr/&gt;&lt;h4 id=&quot;四评价准则&quot;&gt;四、评价准则&lt;/h4&gt;
&lt;p&gt;​ 作为评估措施，我们将完善的CLEAR MOT指标用于多目标跟踪以适应我们的任务。 对于MOTS任务，需要在评估度量中容纳每个对象的分割掩模。 受Panoptic Segmentation任务的启发，我们要求对象的ground truth掩模和MOTS方法产生的掩模都不重叠，即每个像素最多可分配给一个对象。 我们现在介绍我们对MOTS的评估措施。&lt;/p&gt;
&lt;p&gt;​ 形式上，具有&lt;span class=&quot;math inline&quot;&gt;\(T\)&lt;/span&gt;个时间帧，高度&lt;span class=&quot;math inline&quot;&gt;\(h\)&lt;/span&gt;和宽度&lt;span class=&quot;math inline&quot;&gt;\(w\)&lt;/span&gt;的视频的ground truth由一组&lt;span class=&quot;math inline&quot;&gt;\(N\)&lt;/span&gt;个非空的ground truth像素掩模 &lt;img src=&quot;https://www.zhihu.com/equation?tex=M+%3D+%5Cleft%5C%7B+m_%7B1%7D%2C+...%2C+m_%7BN%7D+%5Cright%5C%7D&quot; alt=&quot;[公式]&quot;/&gt; 组成，其中 &lt;img src=&quot;https://www.zhihu.com/equation?tex=m_%7Bi%7D+%5Cin+%5Cleft%5C%7B+0%2C1+%5Cright%5C%7D%5E%7Bh%5Ctimes+w%7D&quot; alt=&quot;[公式]&quot;/&gt; ，每个属于相应的时间帧 &lt;img src=&quot;https://www.zhihu.com/equation?tex=t_%7Bm%7D+%3D+%5Cleft%5C%7B+1%2C+...%2C+T+%5Cright%5C%7D&quot; alt=&quot;[公式]&quot;/&gt; 并被赋予ground truth 跟踪id &lt;img src=&quot;https://www.zhihu.com/equation?tex=id_%7Bm%7D+%5Cin+%5Ctextbf%7BN%7D&quot; alt=&quot;[公式]&quot;/&gt; 。MOTS方法的输出是一组&lt;span class=&quot;math inline&quot;&gt;\(K\)&lt;/span&gt;非空假设掩模 &lt;img src=&quot;https://www.zhihu.com/equation?tex=h+%3D+%5Cleft%5C%7B+h_%7B1%7D%2C...%2Ch_%7BK%7D+%5Cright%5C%7D&quot; alt=&quot;[公式]&quot;/&gt; ，其中 &lt;img src=&quot;https://www.zhihu.com/equation?tex=h_%7Bi%7D+%5Cin+%5Cleft%5C%7B+0%2C1+%5Cright%5C%7D%5E%7Bh%5Ctimes+w%7D&quot; alt=&quot;[公式]&quot;/&gt; ，每个都被赋予一个假设的轨迹id &lt;img src=&quot;https://www.zhihu.com/equation?tex=id_%7Bh%7D+%5Cin+%5Ctextbf%7BN%7D&quot; alt=&quot;[公式]&quot;/&gt; 和一个时间帧 &lt;img src=&quot;https://www.zhihu.com/equation?tex=t_%7Bh%7D+%3D+%5Cleft%5C%7B+1%2C+...%2C+T+%5Cright%5C%7D&quot; alt=&quot;[公式]&quot;/&gt; 。&lt;/p&gt;
&lt;p&gt;​ &lt;strong&gt;建立对应关系。&lt;/strong&gt;CLEAR MOT指标的一个重要步骤是建立ground truth对象和跟踪器假设之间的对应关系。 在基于边界框的设置中，建立对应关系是非平凡的并且通过二分匹配来执行，因为ground truth框可以重叠并且多个假设框可以很好地适应给定的ground truth框。 在MOTS的情况下，由于我们要求每个像素在ground truth和假设中都是唯一的，所以建立对应大大简化了。 因此，对于给定的ground truth掩模，至多一个预测掩模可以具有大于0.5的交叉联合（IoU)。 因此，从假设掩模到ground truth掩模的映射 &lt;img src=&quot;https://www.zhihu.com/equation?tex=c%3AH%5Crightarrow+M+%5Ccup%5Cleft%5C%7B+%5Coslash+%5Cright%5C%7D&quot; alt=&quot;[公式]&quot;/&gt; 可以简单地使用基于掩模的IoU定义为&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pic3.zhimg.com/80/v2-6be966e931e00606d8644251c45c09e6_hd.jpg&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​ True positives的集合 &lt;img src=&quot;https://www.zhihu.com/equation?tex=TP+%3D+%5Cleft%5C%7B+h%5Cin+H+%7C+c%28h%29+%5Cne+%5Coslash+%5Cright%5C%7D&quot; alt=&quot;[公式]&quot;/&gt; 由映射到ground truth掩模的假设掩模组成。 类似地，false positives是未映射到ground truth掩模的假设掩模，即 &lt;img src=&quot;https://www.zhihu.com/equation?tex=FP+%3D+%5Cleft%5C%7B+h%5Cin+H+%7C+c%28h%29+%3D+%5Coslash+%5Cright%5C%7D&quot; alt=&quot;[公式]&quot;/&gt; 。 最后，false negatives的集合 &lt;img src=&quot;https://www.zhihu.com/equation?tex=FN+%3D+%5Cleft%5C%7B+m%5Cin+M+%7C+c%5E%7B-1%7D%5Cleft%28+m+%5Cright%29+%5Cne+%5Coslash+%5Cright%5C%7D&quot; alt=&quot;[公式]&quot;/&gt; 包含未被任何假设掩模覆盖的ground truth掩模。&lt;/p&gt;
&lt;p&gt;​ 在下文中，让 &lt;img src=&quot;https://www.zhihu.com/equation?tex=pred%3A+M%5Crightarrow+M%5Ccup%5Cleft%5C%7B+%5Coslash+%5Cright%5C%7D&quot; alt=&quot;[公式]&quot;/&gt; 表示最近跟踪的ground truth掩模的前一个(predecessor)，或者如果没有跟踪的前一个存在则∅。 所以 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q%3Dpred%28p%29&quot; alt=&quot;[公式]&quot;/&gt; 是具有相同 &lt;span class=&quot;math inline&quot;&gt;\(id(id_q-id_p)\)&lt;/span&gt; 的掩模q和使得 &lt;img src=&quot;https://www.zhihu.com/equation?tex=c%5E%7B-1%7D%5Cleft%28+q+%5Cright%29%5Cne+%5Coslash&quot; alt=&quot;[公式]&quot;/&gt; 的最大 &lt;span class=&quot;math inline&quot;&gt;\(t_q &amp;lt; t_p\)&lt;/span&gt; 。然后将id转换的集合IDS定义为 一系列ground truth掩模，其前一个被跟踪不同的身份。形式上，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pic4.zhimg.com/80/v2-e3e142b48e2cb8eb8c999ccbb4785657_hd.jpg&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​ &lt;strong&gt;基于掩模的评估措施。&lt;/strong&gt;另外，我们 通过&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pic3.zhimg.com/80/v2-073e72b63bdf0016b47a8f72c175b1c6_hd.jpg&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;定义了true positives数量的soft &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctilde%7BTP%7D&quot; alt=&quot;[公式]&quot;/&gt; 。&lt;/p&gt;
&lt;p&gt;鉴于之前的定义，我们定义了原始CLEAR MOT指标的基于掩模的变体。 我们提出多对象跟踪和分割准确度（MOTSA）作为基于框的MOTA度量的基于掩模IoU的版本，即&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pic3.zhimg.com/80/v2-494a7e0cb794820bef0097836bbb215a_hd.jpg&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;并且基于掩模的多目标跟踪和分割精度（MOTSP）为&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pic2.zhimg.com/80/v2-f4ef6eec3b232225a292343db3364155_hd.jpg&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后，我们介绍了soft多目标跟踪和分割精度（sMOTSA）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pic4.zhimg.com/80/v2-5d8c68cd313b181b2dee118fae55f907_hd.jpg&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;它累积了 true positives 的soft number &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctilde%7BTP%7D&quot; alt=&quot;[公式]&quot;/&gt; ，而不是计算有多少掩模达到超过0.5的IoU。因此，sMOTSA可以衡量分割以及检测和跟踪质量。&lt;/p&gt;
&lt;hr/&gt;&lt;h4 id=&quot;五方法&quot;&gt;五、方法&lt;/h4&gt;
&lt;p&gt;​ 为了解决检测，跟踪和分割，即MOTS任务，与神经网络联合，我们建立在流行的Mask R-CNN 架构上，该架构通过掩模head扩展了Faster R-CNN检测器。 我们提出TrackR-CNN（参见图3），其又通过一个关联头（association head）和两个3D卷积层来扩展Mask R-CNN，以便能够随时间关联检测并处理时间动态。 TrackR-CNN提供基于掩模的检测以及关联特性。 两者都输入到跟踪算法，该算法决定选择哪些检测以及如何随时间链接它们。&lt;/p&gt;
&lt;center readability=&quot;4&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/80/v2-4b81e59cc2505e40b3abb9a6fd6c9e4a_hd.jpg&quot;/&gt;&lt;p&gt;图 三: TrackR-CNN概述。我们通过3D卷积扩展Mask R-CNN以结合时间上下文和通过为每次检测产生关联向量的关联头。关联向量之间的欧几里德距离用于将检测随时间关联到轨迹中。与Mask R-CNN的差异以黄色突出显示。&lt;/p&gt;
&lt;/center&gt;
&lt;p&gt;​ &lt;strong&gt;整合时间上下文。&lt;/strong&gt; 为了利用输入视频的临时上下文，我们将3D卷积（其中第三个维度是时间）整合到以ResNet-101为骨干网的Mask R-CNN中。 3D卷积应用于主干特征，以便增强主干特征得时序性。 然后，区域提议网络（RPN）将使用这些增强的特征。 作为替代方案，我们还考虑卷积LSTM 层。 卷积LSTM通过使用卷积而不是矩阵乘积计算其激活来保留输入的空间结构。&lt;/p&gt;
&lt;p&gt;​ &lt;strong&gt;Association Head（关联头）。&lt;/strong&gt;为了将检测随时间关联的数据，我们通过关联头扩展Mask R-CNN，该关联头是一个全连接层，其将区域提议作为输入并且预测每个提议的关联向量。 关联头的灵感来自用于人体重新识别的嵌入向量。 每个关联向量表示汽车或人的身份。它们的训练方式是属于同一实例的向量彼此接近，属于不同实例的向量彼此相距遥远。 我们将两个关联向量v和w之间的距离 &lt;span class=&quot;math inline&quot;&gt;\(d(v, w)\)&lt;/span&gt; 定义为它们的欧几里德距离，即&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pic3.zhimg.com/80/v2-a169d8934963c7618e8f065b5b87aa5a_hd.jpg&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​ 我们使用Hermans等人提出的batch hard triplet loss 来训练关联头适用于视频序列。 这种损失对每次检测都会产生硬阳性（hard positives ）和硬阴性（hard negatives）。 正式地，让&lt;span class=&quot;math inline&quot;&gt;\(D\)&lt;/span&gt;表示视频的检测集。 每个检测 &lt;span class=&quot;math inline&quot;&gt;\(d ∈D\)&lt;/span&gt; 由掩模 &lt;span class=&quot;math inline&quot;&gt;\(mask_d\)&lt;/span&gt; 和关联矢量 &lt;span class=&quot;math inline&quot;&gt;\(a_d\)&lt;/span&gt; 组成，其来自时间帧 &lt;span class=&quot;math inline&quot;&gt;\(t_d\)&lt;/span&gt; ，并且被分配由其与ground truth对象的重叠确定的ground truth轨迹id &lt;span class=&quot;math inline&quot;&gt;\(id_d\)&lt;/span&gt; 。 对于&lt;span class=&quot;math inline&quot;&gt;\(T\)&lt;/span&gt;时间步长的视频序列，具有边际&lt;span class=&quot;math inline&quot;&gt;\(α\)&lt;/span&gt;的batch-hard formulation中的关联损失由下式给出&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pic1.zhimg.com/80/v2-3411377996c8a8dc31d84f6db869537c_hd.jpg&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​ &lt;strong&gt;Mask传播。&lt;/strong&gt; 基于掩模的&lt;span class=&quot;math inline&quot;&gt;\(IoU\)&lt;/span&gt;与光流扭曲（warping）一起是一种强有力的提示，用于随时间关联像素掩模。 因此，我们还尝试使用掩模扭曲作为关联向量相似性的替代提示。 对于在时间&lt;span class=&quot;math inline&quot;&gt;\(t-1\)&lt;/span&gt;处的检测&lt;span class=&quot;math inline&quot;&gt;\(d∈D\)&lt;/span&gt;具有掩模&lt;span class=&quot;math inline&quot;&gt;\(mask_d\)&lt;/span&gt;并且在时间&lt;span class=&quot;math inline&quot;&gt;\(t\)&lt;/span&gt;处具有掩模 &lt;span class=&quot;math inline&quot;&gt;\(mask_e\)&lt;/span&gt; 的检测&lt;span class=&quot;math inline&quot;&gt;\(e∈D\)&lt;/span&gt;，我们定义掩模传播得分为&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pic1.zhimg.com/80/v2-e3efa74186a2e9987c2fcd7200f26af8_hd.jpg&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;span class=&quot;math inline&quot;&gt;\(W(m)\)&lt;/span&gt;表示通过帧&lt;span class=&quot;math inline&quot;&gt;\(t-1\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(t\)&lt;/span&gt;之间的光流向前的扭曲掩模&lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;​ &lt;strong&gt;跟踪。&lt;/strong&gt; 为了产生最终结果，我们仍然需要决定报告哪些检测以及如何将它们随时间链接到轨迹中。 为此，我们将现有的基于关联向量相似度的轨迹检测扩展到该轨迹的最新检测。&lt;/p&gt;
&lt;p&gt;​ 更确切地说，对于每个类和每个帧&lt;span class=&quot;math inline&quot;&gt;\(t\)&lt;/span&gt;，我们将检测置信度大于阈值&lt;span class=&quot;math inline&quot;&gt;\(γ\)&lt;/span&gt;的当前帧的检测与之前帧中使用关联向量距离公式7选择的检测联系在一起。我们只选择最近的检测，直到过去的&lt;span class=&quot;math inline&quot;&gt;\(β\)&lt;/span&gt;帧阈值。 使用匈牙利算法进行匹配，同时仅允许距离小于阈值&lt;span class=&quot;math inline&quot;&gt;\(δ\)&lt;/span&gt;的成对检测。 最后，所有未分配的高置信度检测都会启动新的轨迹。&lt;/p&gt;
&lt;p&gt;​ 生成的轨道可以包含重叠的掩码，我们不允许执行MOTS任务（参见第4节）。 在这种情况下，属于具有较高置信度的检测的像素（由我们的网络的分类头部给出）优先于具有较低置信度的检测。&lt;/p&gt;
&lt;hr/&gt;&lt;h4 id=&quot;六实验&quot;&gt;六、实验&lt;/h4&gt;
&lt;p&gt;​ &lt;strong&gt;实验设置&lt;/strong&gt;。对于Mask R-CNN，我们使用一个ResNet-101主干，并在COCO和Mapillary上进行预训练。然后，我们通过添加关联头，将两个深度的3D卷积层与3×3×3滤波核(二维空间的，三维时间)、ReLU激活层以及1024个背骨与区域建议网络之间的特征映射进行集成，构建TrackR-CNN。将3D卷积初始化为一个标识函数，然后应用ReLU函数，在使用卷积LSTM时，在训练的初始步骤中，随机初始化权值，并在后续层的预训练权值的预服务激活中加入一个跳跃连接。然后，TrackR-CNN对目标数据集进行训练，即KITTI MOTS 或MOTSChallenge，使用Adam优化器，以&lt;span class=&quot;math inline&quot;&gt;\(5*10^{-7}\)&lt;/span&gt;的学习速度进行了40个循环的测试。在训练期间，使用由单个视频的8个相邻帧组成的小批量，其中8是使用Titan X (Pascal)graph-ics卡能够装入内存的最大帧数。在批处理边界处，3D卷积层的输入在时间上是零填充的。使用卷积LSTM时，梯度在训练过程中通过全部8帧反向传播，在测试时在整个序列上传播递归状态。关联头产生的向量有128个维度，公式8中定义的关联损失是在一批检测中计算出来的。我们选择的优势&lt;span class=&quot;math inline&quot;&gt;\(α= 0.2\)&lt;/span&gt;, 这被证明是有用的。对于掩模传播实验，我们使用PWC-Net来计算所有相邻帧对之间的光流。我们的整个跟踪器在测试时达到了大约每秒2帧的速度。当使用卷积LSTM时，它是在线运行的，当使用3D卷积时，由于两帧的关系，它是在3D卷积之前运行的。&lt;/p&gt;
&lt;p&gt;​ 我们每个实验的跟踪系统调优的阈值&lt;span class=&quot;math inline&quot;&gt;\((α, β, γ)\)&lt;/span&gt;每一个类分别在目标训练集与随机搜索进行1000次迭代。&lt;/p&gt;
&lt;center readability=&quot;3&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/80/v2-4eff15c57420f06cf54346679466c0d9_hd.jpg&quot;/&gt;&lt;p&gt;表 2： KITTI MOTS上的结果。+ MG表示使用KITTI MOTS 微调 Mask R-CNN生成掩模。 BeyondPixels是一种先进的汽车MOT方法，使用与其他方法不同的检测器。&lt;/p&gt;
&lt;/center&gt;
&lt;p&gt;​ &lt;strong&gt;主要结果。&lt;/strong&gt; 表2显示了我们在KITTIMOTS验证集上的结果。我们取得了有竞争力的结果，击败了几个基准方法。Mask R-CNN + maskprop表示一个简单的基线，我们在KITTI MOTS训练集的框架上对COCO和Mapillary预训练Mask R-CNN进行了微调。然后我们在验证集上对其进行评估，并使用掩模传播评分(参见第5节)将基于掩模的检测随时间联系起来。与此基线相比，TrackR-CNN获得了更高的sMOTSA 和 MOTSA评分，这意味着3D卷积分层和关联头有助于识别视频中的对象。MOTSP得分也是一样的。&lt;/p&gt;
&lt;p&gt;​ TrackR-CNN(box orig)表示我们的模型在KITTI的原始边界框注释上经过无掩模头部训练的一个版本。然后我们根据KITTI在我们的训练片段上的原始跟踪注释来调整MOTA的分数。在我们的MOTS设置中，我们通过添加分割掩膜(用+MG表示)和KITTI微调掩膜R-CNN的掩膜头部作为后处理步骤来评估这一基线。这种设置的sMOTSA和MOTSA得分比我们的方法和之前的基线更差，特别是考虑到行人时，此外，我们还观察到，非紧密边界框并不是跟踪的理想线索，而仅仅在边界框谓词上使用实例划分方法不足以解决MOTS任务。我们在图4中显示了这条基线的定性结果。基于边界框的模型经常混淆相似的闭塞对象，导致掩膜和身份开关丢失。相反，我们的模型假设了一致的掩模(marks)。&lt;/p&gt;
&lt;center readability=&quot;4&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/80/v2-5bbf0276aee88406c29379ab543eb410_hd.jpg&quot;/&gt;&lt;p&gt;图 4：KITTI MOTS上的定性结果。 (a) +(c): 我们的TrackR-CNN模型评估了KITTI MOTS的验证序列。(b)+(d): TrackR-CNN（box orig）+ MG在相同序列上的评估。在我们的数据上使用掩模进行训练可以避免类似的近距离物体之间的混淆。&lt;/p&gt;
&lt;/center&gt;
&lt;p&gt;​ 为了证明像上面那样添加分割掩膜不会带来(不)公平的优势，我们还使用了MASK R-CNN掩膜头来替换我们的方法生成的掩膜(TrackR-CNN (our) + MG)。结果大致相似，所以没有出现主要的(劣)优势。结合我们的基线实验，我们发现对于视频的时间一致性的实例分割数据的训练比没有时间信息的实例分割数据的训练和仅仅对边界框跟踪数据的训练都有优势。这两方面的联合训练在以前是不可能的，这强调了我们提出的MOTS数据集的有用性。&lt;/p&gt;
&lt;p&gt;​ CAMOT是一个基于掩码的跟踪器，它可以跟踪来自预定义类的对象和使用来自KITTI中立体设置的3D信息的通用对象。在原始版本中，CAMOT将来自SharpMask的通用对象建议作为输入。为了具有更好的可比性，我们使用来自TrackR-CNN的检测(通过运行它作为一个正常的探测器，没有关联)作为输入。请注意，CAMOT只能跟踪立体的深度可用的区域，这限制了它的回调。结果表明，当使用相同的输入检测集时，我们提出的跟踪方法比传统的跟踪方法CAMOT有更好的性能。&lt;/p&gt;
&lt;p&gt;​ 由于基于掩码的跟踪器的源代码不多，我们也考虑了基于边界框的跟踪方法CIWT和BeyondPixels，并再次使用KITTI微调掩码R-CNN掩码头将其结果转换为分割掩码。注意，这些方法经过了调优，在最初的基于边界框的任务上表现良好。&lt;/p&gt;
&lt;p&gt;​ CIWT将基于图像的信息与来自stereo的三维信息相结合，在图像和世界空间中进行联合跟踪。再次，从我们的TrackR-CNN的检测用于可比性。我们所提出的追踪系统在产生自适应的掩膜时，可同时处理追踪与掩膜的产生，其效能优于连续小波变换。&lt;/p&gt;
&lt;p&gt;​ BeyondPixels是KITTI原始跟踪数据集中最强大的汽车跟踪方法之一。它结合了外观信息和3D线索。我们无法运行他们的方法与我们的检测，因为他们的代码提取外观特征是不可用的。相反，我们使用了从RRC获得的原始检测，RRC是一种非常强大的探测器。RRC特别在KITTI上实现了精确的定位，而更为传统的MASK R-CNN检测器设计用于一般的目标检测。最终得到的sMOTSA和MOTSA的分数比我们的方法要高，但仍然表明在MOTS上使用Mask R-CNN分割边界框时，最先进的边界框跟踪方法是有限制的。&lt;/p&gt;
&lt;p&gt;​ &lt;strong&gt;MOTS用Ground Truth边界框。&lt;/strong&gt;为了便于比较，我们基于边界框ground truth得到了分割结果，并在新的标注中对其进行了评估。在这里，我们考虑了ground truth的两个变体:来自KITTI (orig)的原始边界框，它们是模态，即如果只有一个人的上半身是可见的，边界框将仍然延伸到地面，另一种是紧密的边界框(tight)从我们的分割掩膜。同样，我们使用KITTI MOTS微调的MASK R-CNN生成掩膜。我们的研究结果表明，即使使用完美的轨迹假设，生成精确的掩模仍然具有挑战性，尤其是对行人而言。在使用模态框时更是如此，它通常包含不显示对象的较大区域。这进一步证实了我们的观点，MOT任务可以从像素级评估中获益。进一步的基准，我们用矩形或椭圆填充ground truth框可以在补充材料中找到。&lt;/p&gt;
&lt;p&gt;​ &lt;strong&gt;时间成分。&lt;/strong&gt;在表3中，我们比较了TrackR-CNN时间分量的不同变量。&lt;span class=&quot;math inline&quot;&gt;\(1×Conv3D\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(2×Conv3D\)&lt;/span&gt;表示在基干和区域建议网络之间使用一个或叠加两个深度可分的3D卷积层，每层有1024个维度。类似地，&lt;span class=&quot;math inline&quot;&gt;\(1×Conv\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(2×ConvLSTM\)&lt;/span&gt;表示在同一阶段有一个或两个堆叠的卷积LSTM层，每个层有128个特征通道。在卷积LSTM中，由于门的存在，每个特征通道的参数数更高。在最初的实验中，使用更多的特征通道似乎没有什么帮助。最后，不添加任何额外的层作为临时组件&lt;span class=&quot;math inline&quot;&gt;\((None)\)&lt;/span&gt;。与基线相比，增加两个3D卷积层可以显著改善行人的sMOTSA和MOTSA分数，而对汽车的评分则可以进行类比。令人惊讶的是，使用卷积LSTM并没有比基线产生任何显著的效果。&lt;/p&gt;
&lt;center readability=&quot;5&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/80/v2-bb92e3bba205a52fe64542f3b56818ec_hd.jpg&quot;/&gt;&lt;p&gt;表 3：TrackR-CNN的不同时间成分在KITTI MOTS上的结果比较。(a)+(c)我们的TrackR-CNN模型对KITTI MOTS的验证序列进行了评估。(b)+(d) TrackR-CNN (box orig) + MG对同一序列进行评价。在我们的数据上使用蒙板进行训练，可以避免附近相似物体之间的混淆。&lt;/p&gt;
&lt;/center&gt;
&lt;p&gt;​ &lt;strong&gt;关联机制。&lt;/strong&gt;在表4中，我们比较了不同的检测关联机制。每一行都遵循第5节中介绍的建议的跟踪系统，但是匈牙利匹配步骤使用了不同的分数。当使用关联头，关联头向量可能对过去检测到&lt;span class=&quot;math inline&quot;&gt;\(β\)&lt;/span&gt;帧进行匹配。对于其余的关联机制，只有相邻帧之间的匹配才是合理的。&lt;/p&gt;
&lt;center readability=&quot;2&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/80/v2-678806206822b20cee16b8177e2f88a3_hd.jpg&quot;/&gt;&lt;p&gt;表 4：TrackR-CNN的不同关联机制在KITTI MOTS上的结果比较。&lt;/p&gt;
&lt;/center&gt;
&lt;p&gt;​ 对于MASK IoU，我们只使用来自等式9的掩模传播分数，这会降低sMOTSA和MOTSA的分数。这强调了我们的关联头的有用性，它可以使用单个神经网络提供的嵌入来超越基于光流的提示。在这里，我们也尝试了没有关联头损失的训练&lt;span class=&quot;math inline&quot;&gt;\((MASK IoU(train w/oassoc.))\)&lt;/span&gt;，这更降低了MOTSA的分数。因此，关联损耗对检测器本身也有积极的影响。令人惊讶的是，使用边界框IoU(其中边界框被框内的光流值的中间值扭曲，&lt;span class=&quot;math inline&quot;&gt;\(Bbox\ IoU\)&lt;/span&gt;)执行的效果几乎与mask IoU相同。最后，仅使用边界框中心(Bbox Center)的距离进行关联，即做最近邻搜索，会显著降低性能。&lt;/p&gt;
&lt;p&gt;​ &lt;strong&gt;MOTS挑战。&lt;/strong&gt;表5显示了我们在MOTSChallenge数据集上的结果。因为MOTSChallenge只有4个视频序列，所以我们将我们的方法(TrackR-CNN(ours))训练成一种忽略不计的方式(用一个训练过并调整了其他3个序列的模型来评估每个序列)。为了进行比较，我们使用四种在MOT17基准测试中表现良好的方法的预先计算结果，并使用在MOTSChallenge上经过调优的Mask R-CNN生成掩膜(以一种遗漏的方式)来评估我们的数据。我们注意到，所有四组结果都使用了SDP生成的最强公共检测集，而TrackR-CNN生成了自己的检测。同样不清楚的是，这些方法有多少被训练得在MOTChallenge训练集上表现良好。尽管存在这些可能性，但TrackR-CNN的表现优于其他所有方法。最后一行表明，即使随着时间的推移，包括跟踪信息在内的严格的ground truth边界框，准确分割所有行人仍然是困难的&lt;/p&gt;
&lt;center readability=&quot;2&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/80/v2-e43a2e37ab21b31a97716dd5f2668f96_hd.jpg&quot;/&gt;&lt;p&gt;表 5：MOTSChallenge上的结果。+ MG表示使用域fine-tuned的Mask R-CNN生成掩模。&lt;/p&gt;
&lt;/center&gt;
&lt;hr/&gt;&lt;h4 id=&quot;七结论&quot;&gt;七、结论&lt;/h4&gt;
&lt;p&gt;​ 到目前为止，还没有用于评估多对象跟踪和分割的任务的基准或数据集，并且使用这种时间上一致的基于掩模的跟踪信息直接训练方法。 为了缓解这个问题，我们引入了两个基于现有MOT数据集的新数据集，我们使用半自动标注过程进行标注。 我们基于常用的MOTA指标进一步介绍了MOTSA和sMOTSA指标，但适用于评估基于掩模跟踪的所有方面。 我们最终开发了一个旨在利用这些数据的基线模型。 我们通过对数据的训练表明，该方法能够胜过仅用边界框轨迹和单个图像实例分割掩模训练的方法。 我们的新数据集使这种联合训练成为可能，这为未来的研究提供了许多机会。&lt;/p&gt;
</description>
<pubDate>Wed, 12 Feb 2020 12:31:00 +0000</pubDate>
<dc:creator>Frnas</dc:creator>
<og:description>MOTS：多目标跟踪和分割论文翻译 摘要： 本文将目前流行的多目标跟踪技术扩展到多目标跟踪与分割技术(MOTS)。为了实现这个目标，我们使用半自动化的标注为两个现有的跟踪数据集创建了密集的像素级标注。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/fans-fan/p/12300739.html</dc:identifier>
</item>
<item>
<title>深入JVM内存区域管理，值得你收藏 - 阿伟~</title>
<link>http://www.cnblogs.com/sy270321/p/12300578.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sy270321/p/12300578.html</guid>
<description>&lt;h4 id=&quot;jdk和jre和jvm的关系&quot;&gt;JDK和JRE和JVM的关系&lt;/h4&gt;
&lt;p&gt;JDK(Java Development Kit)是程序开发者用来来编译、调试java程序用的开发工具包&lt;/p&gt;
&lt;p&gt;JRE(JavaRuntimeEnvironment，Java运行环境)，也就是Java平台。所有的Java 程序都要在JRE下才能运行。普通用户只需要运行已开发好的java程序，安装JRE即可&lt;/p&gt;
&lt;p&gt;JVM(JavaVirtualMachine，Java虚拟机)是JRE的一部分。它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。JVM有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令系统&lt;/p&gt;
&lt;h4 id=&quot;jvm内存区域&quot;&gt;JVM内存区域&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/706455/202002/706455-20200212195556335-478103326.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本文的讲解都从这个图一一开始，你脑海里先试着回忆一下这个几个区域的概念，是独享的还是共享的？每个区域都存储了什么？哪些区域会被垃圾回收？哪些区域会抛出OOM?哪些区域会抛出SOF?如何避免&lt;/p&gt;
&lt;h4 id=&quot;什么是jvm运行时数据区域&quot;&gt;什么是JVM运行时数据区域？&lt;/h4&gt;
&lt;p&gt;Java虚拟机定义了在程序执行期间使用的各种运行时数据区域。其中一些数据区域是在Java虚拟机启动时创建的，仅在Java虚拟机退出时才被销毁。其他数据区域是每个线程的。创建线程时创建每个线程的数据区域，并在线程退出时销毁每个数据区域。&lt;/p&gt;
&lt;h5 id=&quot;堆内存&quot;&gt;堆内存&lt;/h5&gt;
&lt;p&gt;堆内存中存储的是所有类实例和数组的内存，在虚拟机启动时创建，虚拟机结束时销毁，归还给操作系统，堆内存中对象的销毁都JVM自行管理(垃圾收集器)，当程序创建对象的越来越多时并且这些对象都无法被回收时，这个区域会抛出OOM异常，并且堆内存是所有线程共享的，所以当多个线程操作堆内存的数据时会有并发问题，要加锁。&lt;/p&gt;
&lt;h5 id=&quot;栈内存&quot;&gt;栈内存&lt;/h5&gt;
&lt;p&gt;栈分为虚拟机栈和本地方法栈，首先栈是线程安全的，栈内存随线程创建而创建，随线程销毁而销毁，栈内存是不需要垃圾回收器进行回收的。线程栈的大小可以是在虚拟机启动时指定固定大小，也可以是自行计算动态扩容的。当指定大小时，线程栈的内存随着使用而不足时JVM抛出StackOverFlowError,当不指定大小时，线程栈动态扩容时如果没有足够的内存不足，JVM将会抛出OOM错误。&lt;/p&gt;
&lt;p&gt;虚拟机栈描述的是Java方法执行的内存模型，每个方法在执行时会创建一个栈帧用于存储放法局部变量表，操作数栈，动态链接，出口信息，如下图，整个栈帧是先入后出。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/706455/202002/706455-20200212195615882-1122725038.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;局部变量表&lt;/strong&gt;存放了编译器可知的各种基本数据类型，对象引用（不包含成员变量）每个局部变量表占用32位（4个字节），所以long和double会占用两个局部变量表，其它类型占用一个，哪怕byte虽然只有8位，也占用一个局部变量表，局部变量表所需的内存在编译期就已经确定了也就是进入这个方法时就已经确定了，运行期间不会更改.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;操作数栈&lt;/strong&gt;则存储方法内一些进行了运算操作后的结果.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;动态链接&lt;/strong&gt;,在方法内调用接口，通过字面量链接到具体的实现类，实现Java的动态特性.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;出口地址&lt;/strong&gt;（返回地址），return或者发生Exception等。&lt;/p&gt;
&lt;p&gt;本地方法栈虚拟机栈相似，都是线程私有的，安全的,区别就是虚拟机为虚拟机栈执行Java服务（字节码服务），而本地方法栈为虚拟机使用到的Native方法服务,本地方法栈中使用的语言，使用方式，数据结构没有强制要求。&lt;/p&gt;
&lt;h5 id=&quot;程序计数器&quot;&gt;程序计数器&lt;/h5&gt;
&lt;p&gt;Java程序是多线程执行的，当一个线程执行字节码时，突然CPU切换到另一个线程，那么上一个线程执行的上下文信息怎么保存呢？等到下次再切换到这个线程，从哪里开始执行呢？这些信息都需要在线程切换时记录，这就是程序计数器的职责，是每个线程私有的，线程安全的，因线程创建而创建，因线程销毁而销毁，程序计数器其实就是一小块内存。&lt;/p&gt;
&lt;p&gt;程序计数器指向当前线程所执行的字节码所在的行号，记录着当前程序运行到哪了字节码解释器的工作就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。分支，循环，跳转，异常处理，线程回复等都需要依赖这个计数器来完成&lt;/p&gt;
&lt;p&gt;如果一个线程执行一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址;如果正在执行的是一个本地方法，这个计数器的值则为undefine，此内存区域是唯一一个在Java的虚拟机规范中没有规定任何OutOfMemoryError异常情况的区域&lt;/p&gt;
&lt;h5 id=&quot;元数据区&quot;&gt;元数据区&lt;/h5&gt;
&lt;p&gt;默认情况下，类元数据只受可用的本地内存限制。新参数（MaxMetaspaceSize）用于限制本地内存分配给类元数据的大小。如果没有指定这个参数，元空间会在运行时根据需要动态调整，&lt;/p&gt;
&lt;p&gt;这个区域也是会发生GC的，垃圾回收将在元数据使用达到“MaxMetaspaceSize”参数的设定值时进行，适时地监控和调整元空间对于减小垃圾回收频率和减少延时是很有必要的。如果的元空间持续的发生GC说明可能存在类、类加载器导致的内存泄漏或是大小设置不合适，如果这个空间使用达到了MaxMetaspaceSize，但GC无法回收(所有的类信息都是有用的,所以无法回收)，也会发生OOM错误。&lt;/p&gt;
&lt;p&gt;String常量池已经从方法区(jdk8以前的叫法)中的运行时常量池分离到堆中了，不在元数据中。&lt;/p&gt;
&lt;p&gt;Metaspace由两部分组成：Klass MetaSpace 和 NoKlass MetaSpace，Klass代表的是&lt;br/&gt;class文件在jvm中运行时的数据结构，NoKlass专门用来存储Klass相关的其它数据，比如Method和ConstantPool。&lt;/p&gt;
&lt;h4 id=&quot;回答刚开始的问题&quot;&gt;回答刚开始的问题&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/706455/202002/706455-20200212195636568-1317151873.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;用一段代码分析jvm内存的存储&quot;&gt;用一段代码分析JVM内存的存储&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;new Thread(new Runnable() {
    @Override
    public void run() {
        test();
    }
    public void test(){
        Object obj = new Object();
    }
}).start();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面这段代码很简单，启动了一个线程，线程的run方法中调用了test方法，test方法中创建一个Objet对象，一起来看一下这段代码涉及的JVM内存哪些区域，分别存储了什么。&lt;/p&gt;
&lt;p&gt;首先创建了一个线程，那么这个线程对应的私有的虚拟机栈内存肯定被分配，这个线程的代码执行中对应的程序计数器内存肯定被分配，因为没有涉及到本地方法，所有本地栈内存不会分配，而且虚拟机栈内存是在编译器就确定的。&lt;/p&gt;
&lt;p&gt;Test方法执行时，创建一个Object对象，我们知道obj是一个引用(reference)类型，所以obj保存在Java栈的本地变量表中，而在Java堆中会保存该引用的实例化对象，Java堆中还必须包含能查找到此对象类型数据的地址信息(如对象类型、父类、实现的接口,方法等)这些类型数据则保存在元数据区域中。一般对象引用到对象实例和对象类型指向有两种方法，一种是句柄池方式，一种是直接指针方式。这两种对象的访问方式各有优势，使用句柄访问方式的最大好处就是reference中存放的是稳定的句柄地址，在对象的移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要修改。使用直接指针访问方式的最大好处是速度快，它节省了一次指针定位的时间开销。目前Java默认使用的HotSpot虚拟机采用的便是是第二种方式进行对象访问的，下面用两张图来表述一下这两种方式。&lt;/p&gt;
&lt;p&gt;这张图是句柄池方式&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/706455/202002/706455-20200212195654089-1749721387.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这张图是直接指针方式&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/706455/202002/706455-20200212195712282-518448650.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;关于基本数据类型和引用类型的分配&quot;&gt;关于基本数据类型和引用类型的分配&lt;/h4&gt;
&lt;p&gt;基本数据类型包括 int short long bolean等，引用类型就是我们常见的对象，那么这两种数据类型内存中是怎么分配的呢？这个得区别看待，我们根据下面代码来分析&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class  Dog {
    private int age;
}
class Test{
    public void test(){
        Dog dog = new Dog();
        dog.age = 2;
        int age = 1;
        Integer age = new Integer(3);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在Test类中的test方法中，我们创建了一个Dog对象，这个对象实例是分配在堆上的,dog这个引用是在栈上的，dog中的age在哪里呢？因为Dog对象实例是在堆上的，所有他的成员变量也是在堆上的。 int age这个变量是栈上的，因为它是局部变量，并且是基本数据类型，Integer age实例是在堆上的，引用是在栈上的，根据这个例子，可以总结下面两条基本黄金法则&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;引用类型总是被分配到“堆”上。&lt;/li&gt;
&lt;li&gt;值类型总是分配到它声明的地方：    a. 作为引用类型的成员变量分配到“堆”上    b. 作为方法的局部变量时分配到“栈”上&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;总结&quot;&gt;总结&lt;/h4&gt;
&lt;p&gt;本文详细介绍了JVM内存区域的各个情况，也就是JVM内存模型，也解答了一些常见的面试题和内存分配相关的一些问题，希望能够帮助到读者更好的了解到JVM，可能会有人有些疑问，为什么不说堆内存的分代(年轻代，年老代)问题呢？我认为这个属于JVM垃圾回收的方位，分代思想只是解决垃圾收回问题的一种方法，同理，Java8中G1的region也是一样，都是为了解决垃圾回收效率和性能问题，会放在JVM垃圾回收一文来说。&lt;/p&gt;
&lt;center&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/706455/201909/706455-20190911210708072-261554801.jpg&quot;/&gt;&lt;/p&gt;
&lt;/center&gt;
</description>
<pubDate>Wed, 12 Feb 2020 11:58:00 +0000</pubDate>
<dc:creator>阿伟~</dc:creator>
<og:description>JDK和JRE和JVM的关系 JDK(Java Development Kit)是程序开发者用来来编译、调试java程序用的开发工具包 JRE(JavaRuntimeEnvironment，Java运</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sy270321/p/12300578.html</dc:identifier>
</item>
</channel>
</rss>