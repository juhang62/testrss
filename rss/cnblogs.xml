<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>作为程序员你是如何学习的？ - JaJian</title>
<link>http://www.cnblogs.com/jajian/p/10680563.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jajian/p/10680563.html</guid>
<description>&lt;p&gt;这篇文章不做技术分享，和大家一起讨论一下学习的途径和方法。程序员行业技术更新迭代速度快，这个特点身为行业内的每个猿友们都有深刻体会。&lt;/p&gt;
&lt;p&gt;很多技术基本每年都有一个大小版本，每个版本的出现意味着有新的技术思想和应用技巧出现。也许你用不到但是你需要去了解。你看自从甲骨文公司宣布收购Sun公司，Java 的 JDK 版本基本保持一年一更的频率。2014年，甲骨文公司发布了Java8正式版，5年来，目前最新的已经是JDK12。&lt;/p&gt;
&lt;p&gt;面对各种技术的各种更新，程序员要面对的不仅是某个单个技术的版本更新，即纵向更新。还要比较各种相似技术的优缺点，即横向比较。&lt;/p&gt;
&lt;p&gt;因此猿友必须时刻保持学习和钻研的精神，不但要耐得住寂寞学习技术应用还要静得下心推敲各种繁琐的技术源码和理解其原理，想想都是很头大。&lt;/p&gt;
&lt;p&gt;对于学习，一般因猿而异，分为两种类型。一种是外界驱动型的，另一种则是自我驱动型的。&lt;/p&gt;
&lt;p&gt;外界驱动型的猿友，学习技术相对被动，公司业务需要了某些技术或者面试中问到了某些自己未涉足的技术他才去学习和研究。而自我驱动型的猿友，则是有自己的一套学习定位和技术成长路线规划，他们更主动的去学习自己未涉足的技术领域。&lt;/p&gt;
&lt;p&gt;当然无论哪种类型，谈到学习都离不开如下几个途径：看视频，买技术书籍，逛博客和社区，阅读官方文档，利用知识付费平台。&lt;/p&gt;
&lt;p&gt;我们分别来详细分析和讨论一下以上各个途径的特点，以及大家偏爱哪种？&lt;/p&gt;

&lt;p&gt;免费教学视频，一般很多是培训机构录的，目的当然是为了推广和招生。像我刚入门的时候也是学习毕向东的Java基础教学。对于初学者来说，视频帮助确实蛮大的。&lt;/p&gt;
&lt;p&gt;这些视频它的目的由于是推广和招生，所以录的时候一般都是很认真的而且录制的人也一般有丰富的经验，而且讲解的也很详细，因为这样才能吸引到学生。&lt;/p&gt;
&lt;p&gt;而有些技术视频则是某些教学网站为例吸引流量而录的，但是这些视频都有个特点：&lt;strong&gt;知识点偏于基础&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;对于初学者来说，视频教程是有帮助的，因为学习成本低，而且有老师给你详细讲解每个知识点的总结，这时候你像个初生的婴儿，接纳和吸收的效率比较高。但是如果你工作几年后，已经有几年的行业经验了。视频教程一般是满足不了我们的需求了，为什么？&lt;/p&gt;
&lt;p&gt;因为它的效率太低了。有几年经验的人你去看视频，视频中某些知识点也许你已经掌握或者了解，但是视频不是针对你个人的，所以一个几十分钟的或者接近一小时的视频，对于你而言，也许只有其中的几分钟是你想要的，其他的你可能都会按着快进键跳着看。你会慢慢的感觉到这是在浪费时间，这时你需要调整下节奏了。&lt;/p&gt;

&lt;p&gt;技术书籍，这没什么好说了。身为技术人员，我相信没有哪位猿友说自己没有买过技术书籍，而且一般技术书籍都是偏贵的，平均基本定价都在七八十左右。&lt;/p&gt;
&lt;p&gt;其实，我要是说&lt;strong&gt;每个程序员都为技术书籍掏过腰包，这世上不会有没买过技术书籍的程序员&lt;/strong&gt;。我相信也没人反对。因为这是一种最普通和普遍的学习途径了。&lt;/p&gt;
&lt;p&gt;常说，书籍是人类文明进步的阶梯。每一本书都是作者的多年经验总结和思考。通过阅读一本书来获得成长，相当于与前辈促膝长谈。这么有价值的事情当然是很值得做的。&lt;/p&gt;
&lt;p&gt;我本人就是一名深度书籍购买爱好者，从学校到步入社会到现在，花在书籍上的钱可以说是笔巨大的支出了。好的书孬的书都买过，以前是名文艺爱好者，阅读的习惯主要集中在历史名著、小说、散文、武侠，而自从入行编程界以来，口味变的专一不花心了，书架上就只有 《**权威指南》、《深入分析**原理》，《**源码解析》、《**实战》等等。&lt;/p&gt;
&lt;p&gt;可是随着自己行业经验的积累，发现买技术书也不是件很好的事情 ---- &lt;strong&gt;搬家严重不方便&lt;/strong&gt;。技术书籍大家都知道，厚而且实。&lt;/p&gt;
&lt;p&gt;而且还有一个问题，很多技术书籍其实也只是入门教程，这类书籍当你掌握了技术理论之后，你就再也不会去去触碰它了。例如市面上的《**从入门到精通》，《**基础教程》等。但是这类书籍又占据着你的书架空间，这类书籍就变得食之无味弃之可惜，扔又舍不得不扔又不是。所以为了避免这种情况的发生这类书籍就不要买了。&lt;/p&gt;
&lt;p&gt;我们都知道技术是有时效性的和版本区别的，很多书籍讲解的技术也许是v2.0版本，但是由于技术更新迭代，一年之后v2.0已经过时，主推v3.0了。但是购买的纸质书籍内容是不会自动更新的，内容还停留在老版本，这类书籍也只能作废。例如很久之前购买过 Struts 和 Hibernate相关的技术书籍的猿友们，这些书它们现在还在你们书架上吗？亦或是已经成为火锅垫了。&lt;/p&gt;
&lt;p&gt;其实如果有阅读的必要的话，这类书籍我们可以购买电子书。阅完即可丢，过时也不会占据生活空间，只需要分配几M大小并且可以释放的硬盘空间。&lt;/p&gt;
&lt;p&gt;那什么书籍值得购买呢？那些讲解技术实现原理和架构思路的书籍以及管理经验的书籍。&lt;/p&gt;
&lt;p&gt;因为技术千变万化，但是万变不离其宗。技术的本质是不会变的，技术原理和设计思想是有指导价值的。这类书籍影响的是我们的思维。例如：《数据结构》、《编程思想》、《深入理解Java虚拟机》等这类书籍我们可以反复阅读，就值得占据我们书架的一席之地。&lt;/p&gt;

&lt;p&gt;博客社区和技术公众号是技术分享的网上平台，在这里从基本的到复杂的，有技术新手有技术大牛，每个人都可以在这里分享他们的技术心得和学习笔记。所以这里比较鱼龙混杂，有原创有转载，充斥各种版权纠纷，都在声明版权但是很少能维护到的。&lt;/p&gt;
&lt;p&gt;学习和分享，都是一种获得成长的过程。这里有前人摸石子过河后留下的经验脚印，有高手的经验分享。这里虽然杂乱，但是往往针对某个点的问题，在这里你能很快速的得到答案。人多力量大啊。&lt;/p&gt;
&lt;p&gt;但是，这种途径是有点碎片化的学习特性，并不是笼统的讲解。你在遇到某个问题时去寻找相关解决方案，或者定期阅读推送的文章，但都是针对某个点的，是一种碎片式的方式。&lt;/p&gt;

&lt;p&gt;你要学习某个技术，还有比技术官方文档更好的地方吗？官方文档一般都是该技术开发者本人或所在组织编写和维护的，这时直接接触技术源的地方。&lt;/p&gt;
&lt;p&gt;我去年新接触 Elasticsearch 的时候，从0搭建搜索平台，了解 ES 的搜索原理基本都是通过官方文档来做到的。关于Elasticsearch的一本书籍我都没有买，因为官方文档已经详细的把所有的都介绍了。索引创建，索引原理，分布式原理，按段搜索等等全部都详细的讲解了。&lt;/p&gt;
&lt;p&gt;你唯一需要做的就是静下心来仔细阅读，然后动手自己搭建环境编写Demo，最后总结经验就可以了。&lt;/p&gt;

&lt;p&gt;最近几年流行知识付费，网上出现了很多付费学习平台，一些有经验的技术人将某个技术点通过多期的方式录制成视频，消费者如果感兴趣需要支付一定价位的金额进行购买。而且某个技术点全期的价格一般在百元左右。&lt;/p&gt;
&lt;p&gt;这种现象主要是近年来IT互联网行业的爆发，薪资待遇还不错，然后涌入了大批程序员，有流量就有消费。前面说过程序员是需要不断学习才能应对技术更新的挑战，有需求就有消费。特别是一些流行技术的教学教程和总结视频，就更受大家的喜爱。&lt;/p&gt;

&lt;p&gt;其实以上几个途径大家或多或少都有过，并不是单一的通过一种途径去学习，更多的是多种学习模式，我目前的学习新技术的大致主要方式是：首先调研新技术的特点和适用场景，然后阅读官方文档，编写Demo，本地运行，最后是通过一些方式理解原理，最后是技术总结。&lt;/p&gt;
&lt;p&gt;对于我而言，目前我一般基本不通过看教学之类的视频学习，书籍购买也是有针对性的，买一些原理性的书籍。而博客和社区是我早上或中午时常会逛逛的地方。知识付费平台目前主要是购买了某个移动端App的几个感兴趣的课程，例如数据结构和网络协议方面的，总体感觉还是不错的。&lt;/p&gt;
&lt;p&gt;大家猿友们的学习方式都有哪些？哪些你认为是你目前主要的学习途径，如果愿意大家可以在评论区留言一起分享和讨论。&lt;/p&gt;
</description>
<pubDate>Tue, 09 Apr 2019 23:43:00 +0000</pubDate>
<dc:creator>JaJian</dc:creator>
<og:description>学习的需要 这篇文章不做技术分享，和大家一起讨论一下学习的途径和方法。程序员行业技术更新迭代速度快，这个特点身为行业内的每个猿友们都有深刻体会。 很多技术基本每年都有一个大小版本，每个版本的出现意味着</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jajian/p/10680563.html</dc:identifier>
</item>
<item>
<title>mybatis-4 mybatis与spring结合使用及原理 - 为了WZJ</title>
<link>http://www.cnblogs.com/gnwzj/p/10680940.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gnwzj/p/10680940.html</guid>
<description>&lt;p&gt;1、创建项目maven，方便依赖下载。使用的jar如下：&lt;/p&gt;
&lt;pre readability=&quot;18&quot;&gt;
&amp;lt;dependencies&amp;gt;&lt;br/&gt;&amp;lt;dependency&amp;gt;&lt;br/&gt;&amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;&lt;br/&gt;&amp;lt;artifactId&amp;gt;spring-context&amp;lt;/artifactId&amp;gt;&lt;br/&gt;&amp;lt;version&amp;gt;5.0.8.RELEASE&amp;lt;/version&amp;gt;&lt;br/&gt;&amp;lt;/dependency&amp;gt;&lt;p&gt;&amp;lt;dependency&amp;gt;&lt;br/&gt;&amp;lt;groupId&amp;gt;org.mybatis&amp;lt;/groupId&amp;gt;&lt;br/&gt;&amp;lt;artifactId&amp;gt;mybatis-spring&amp;lt;/artifactId&amp;gt;&lt;br/&gt;&amp;lt;version&amp;gt;2.0.0&amp;lt;/version&amp;gt;&lt;br/&gt;&amp;lt;/dependency&amp;gt;&lt;/p&gt;&lt;p&gt;&amp;lt;dependency&amp;gt;&lt;br/&gt;&amp;lt;groupId&amp;gt;org.mybatis&amp;lt;/groupId&amp;gt;&lt;br/&gt;&amp;lt;artifactId&amp;gt;mybatis&amp;lt;/artifactId&amp;gt;&lt;br/&gt;&amp;lt;version&amp;gt;3.4.6&amp;lt;/version&amp;gt;&lt;br/&gt;&amp;lt;/dependency&amp;gt;&lt;/p&gt;&lt;p&gt;&amp;lt;dependency&amp;gt;&lt;br/&gt;&amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;&lt;br/&gt;&amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;&lt;br/&gt;&amp;lt;version&amp;gt;5.1.34&amp;lt;/version&amp;gt;&lt;br/&gt;&amp;lt;/dependency&amp;gt;&lt;/p&gt;&lt;p&gt;&amp;lt;dependency&amp;gt;&lt;br/&gt;&amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;&lt;br/&gt;&amp;lt;artifactId&amp;gt;spring-jdbc&amp;lt;/artifactId&amp;gt;&lt;br/&gt;&amp;lt;version&amp;gt;5.0.8.RELEASE&amp;lt;/version&amp;gt;&lt;br/&gt;&amp;lt;/dependency&amp;gt;&lt;/p&gt;&lt;p&gt;&amp;lt;dependency&amp;gt;&lt;br/&gt;&amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;&lt;br/&gt;&amp;lt;artifactId&amp;gt;spring-core&amp;lt;/artifactId&amp;gt;&lt;br/&gt;&amp;lt;version&amp;gt;5.0.8.RELEASE&amp;lt;/version&amp;gt;&lt;br/&gt;&amp;lt;/dependency&amp;gt;&lt;/p&gt;&lt;p&gt;&amp;lt;/dependencies&amp;gt;
&lt;/p&gt;&lt;/pre&gt;
&lt;p&gt;2、创建包com &amp;gt;config、dao、service、test&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1388809/201904/1388809-20190409223333473-145932857.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;3、使用spring创建AppConfig文件，创建Bean&amp;gt;SqlSessionFactoryBean、DataSourceBean&lt;/p&gt;
&lt;p&gt;　　1、spring注解@Configuration，说明是配置层&lt;/p&gt;
&lt;p&gt;　　2、注册扫描映射&lt;/p&gt;
&lt;p&gt;　　3、注册包扫描器&lt;/p&gt;
&lt;p&gt;　　4、创建SqlSessionFactoryBean&lt;/p&gt;
&lt;p&gt;　　5、创建数据源Bean&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
package com.config;

import org.mybatis.spring.SqlSessionFactoryBean;
import org.mybatis.spring.annotation.MapperScan;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.jdbc.datasource.DriverManagerDataSource;

import javax.sql.DataSource;


@Configuration
@MapperScan(&quot;com.dao&quot;)//注解 与XML&amp;lt;mybatis:scan base-package=&quot;org.mybatis.spring.sample.mapper&quot; /&amp;gt;
//注册包中递归搜索映射器
@ComponentScan(&quot;com&quot;)//注册Bean
public class AppConfig {

    @Bean
    @Autowired
    public SqlSessionFactoryBean sqlSessionFactoryBean(DataSource dataSource ){
        SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
        sqlSessionFactoryBean.setDataSource(dataSource);
        return sqlSessionFactoryBean;
    }

    @Bean
    public DataSource getDataSource(){
        DriverManagerDataSource dataSource = new DriverManagerDataSource();
        dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);
        dataSource.setUsername(&quot;root&quot;);
        dataSource.setPassword(&quot;110226wjwj&quot;);
        dataSource.setUrl(&quot;jdbc:mysql://localhost:3306/mybatis_wjw?useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;useSSL=false&quot;);
        return dataSource;
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4、创建Dao接口&lt;/p&gt;
&lt;p&gt;　　1、创建query方法并使用注解@Select（Mybatis提供，mybatis-spring官网有相关解释）&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
package com.dao;

import org.apache.ibatis.annotations.Select;

import java.util.List;
import java.util.Map;

public interface UserDao {

    @Select (&quot;select * from t_user where tid =3&quot;)
    public List&amp;lt;Map&amp;gt; query();

}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;5、创建服务层&lt;/p&gt;
&lt;p&gt;　　1、注解服务层&lt;/p&gt;
&lt;p&gt;　　2、引入DaoBean&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
package com.service;

import com.dao.UserDao;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

//spring注解中service与component意思差不多，区别在于component是中立注解，而service是业务逻辑层的注解
//@Component
@Service
public class UserService {

    @Autowired
    UserDao userDao;


    public void query(){
        System.out.println(userDao.query());
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 6、测试 &lt;/p&gt;
&lt;p&gt;　　1、创建application&lt;/p&gt;
&lt;p&gt;　　2、创建service&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
package com.test;

import com.config.AppConfig;
import com.service.UserService;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;


public class MainTest {
    public static void main(String args[]){
        AnnotationConfigApplicationContext acc = new AnnotationConfigApplicationContext(AppConfig.class);
        UserService us = acc.getBean(UserService.class);
        us.query();
    }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;jar包之家：https://mvnrepository.com/artifact&lt;/p&gt;
&lt;p&gt;使用spring依赖注入mapper   根据官网提示需要&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;mybatis:scan &lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;atn&quot;&gt;base-package&lt;span class=&quot;pun&quot;&gt;=&lt;span class=&quot;atv&quot;&gt;&quot;org.mybatis.spring.sample.mapper&quot; &lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;tag&quot;&gt;/&amp;gt;==&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;atn&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;atv&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;tag&quot;&gt;@MapperScan(“需要注入的包”)&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1388809/201904/1388809-20190409203823056-253205888.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;mybatis缺点：使用XML方式与dao开发结合出现严重的臃肿现象，需要维护很多sql语句。&lt;/p&gt;

&lt;p&gt;测试的时候出现这个问题。（版本导致，我直接将最新[mybatis-spring]的导入进来就没问题了）&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1388809/201904/1388809-20190409212153941-628625938.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 上面的问题解决后有出现这个问题，此问题出现的原因是java compiler改成8就OK了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1388809/201904/1388809-20190409214450031-1583061048.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 测试结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1388809/201904/1388809-20190409224630396-817008787.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1388809/201904/1388809-20190409224657928-1602968994.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;重点：&lt;/p&gt;
&lt;p&gt;　　mybatis运行原理&lt;/p&gt;
&lt;p&gt;　　　　我们可以看到，再测试类中用的是UserService对象调用Dao接口中的query，但是mybatis是如何实现将接口转换成对象的呢？ 答案：动态代理 ，我们常用的代理（proxy）一共有两种：cglib和jdk两用代理模式&lt;br/&gt;　　　　无论哪一种最终都是使用反射机制进行代理。详情自己查看度娘（哈哈@0@）&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1388809/201904/1388809-20190409232004526-1140520647.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　mybatis源码解析&lt;/p&gt;
&lt;p&gt;　　　　DefaultSqlSession下如何实现返回一条数据的：底层调用的是selectList方法，对返回的结果集进行数量判断如果==1则直接放回，&amp;gt;1直接抛出TooManyResultsException（感觉很傻，有些妄自菲薄！）&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
public &amp;lt;T&amp;gt; T selectOne(String statement, Object parameter) {
        List&amp;lt;T&amp;gt; list = this.selectList(statement, parameter);
        if (list.size() == 1) {
            return list.get(0);
        } else if (list.size() &amp;gt; 1) {
            throw new TooManyResultsException(&quot;Expected one result (or null) to be returned by selectOne(), but found: &quot; + list.size());
        } else {
            return null;
        }
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　下面我们继续看selectList是如何实现的&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
public &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; selectList(String statement, Object parameter, RowBounds rowBounds) {
        List var5;
        try {
            MappedStatement ms = this.configuration.getMappedStatement(statement);
            var5 = this.executor.query(ms, this.wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);
        } catch (Exception var9) {
            throw ExceptionFactory.wrapException(&quot;Error querying database.  Cause: &quot; + var9, var9);
        } finally {
            ErrorContext.instance().reset();
        }

        return var5;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我们来看看这个defaultSqlSession.configuration.getMappedStatement方法具体是什么&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1388809/201904/1388809-20190409234509875-1930151083.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1388809/201904/1388809-20190410000414332-1095303945.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;结论：再启动项目的时候，mybatis会进行初始化，这个初始化就是将我们的&quot;包+类+方法名&quot;作为key 和 sql语句作为value 的键值对形式赋给下面Map类型的mappedStatements&lt;/p&gt;
&lt;pre&gt;
protected final Map&amp;lt;String, MappedStatement&amp;gt; mappedStatements;&lt;br/&gt;这也是为什么我们使用XML方式一定要将方法名字与id对应上才能使用，如果对应不上再进行Id传值的时候找不到对应的key。
&lt;/pre&gt;
&lt;p&gt;继续往下分析：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1388809/201904/1388809-20190410001817662-134914258.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;已发帖子询问大神具体是什么原因导致不进入124行，等大佬们回答后我将公布结果。直接看看executor是什么鬼&lt;/p&gt;
&lt;p&gt;是一个接口，&lt;a href=&quot;https://blog.csdn.net/ykzhen2015/article/details/50315027&quot;&gt;https://blog.csdn.net/ykzhen2015/article/details/50315027&lt;br/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
protected Set&amp;lt;BeanDefinitionHolder&amp;gt; doScan(String... basePackages) {
        Assert.notEmpty(basePackages, &quot;At least one base package must be specified&quot;);
        Set&amp;lt;BeanDefinitionHolder&amp;gt; beanDefinitions = new LinkedHashSet();
        String[] var3 = basePackages;
        int var4 = basePackages.length;

        for(int var5 = 0; var5 &amp;lt; var4; ++var5) {
            String basePackage = var3[var5];
            Set&amp;lt;BeanDefinition&amp;gt; candidates = this.findCandidateComponents(basePackage);
            Iterator var8 = candidates.iterator();

            while(var8.hasNext()) {
                BeanDefinition candidate = (BeanDefinition)var8.next();
                ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate);
                candidate.setScope(scopeMetadata.getScopeName());
                String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry);
                if (candidate instanceof AbstractBeanDefinition) {
                    this.postProcessBeanDefinition((AbstractBeanDefinition)candidate, beanName);
                }

                if (candidate instanceof AnnotatedBeanDefinition) {
                    AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition)candidate);
                }

                if (this.checkCandidate(beanName, candidate)) {
                    BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName);
                    definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);
                    beanDefinitions.add(definitionHolder);
                    this.registerBeanDefinition(definitionHolder, this.registry);
                }
            }
        }

        return beanDefinitions;
    }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;关于mybatis中的executor与一级缓存的关系：&lt;a href=&quot;https://blog.csdn.net/lmn669/article/details/77900625&quot;&gt;https://blog.csdn.net/lmn669/article/details/77900625&lt;/a&gt;&lt;/p&gt;&lt;p&gt;这里引出一个经典问题，关于mybatis一级缓存问题，这个缓存存储在session中，当sql关闭的时候就会自动销毁，涉及到mybatis中的session生命周期问题&lt;/p&gt;
&lt;p&gt;为什么mybatis与spring结合后一级缓存会失效？以为SqlSession是由SqlSessionFactoryBean生成，二这个SqlSessionFactoryBean是由spring管理，也就是此时的session是由spring进行管理的并不是mybatis管理，所以此时session缓存会失效。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;54&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
public interface Executor {
    ResultHandler NO_RESULT_HANDLER = null;

    int update(MappedStatement var1, Object var2) throws SQLException;

    &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; query(MappedStatement var1, Object var2, RowBounds var3, ResultHandler var4, CacheKey var5, BoundSql var6) throws SQLException;

    &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; query(MappedStatement var1, Object var2, RowBounds var3, ResultHandler var4) throws SQLException;

    &amp;lt;E&amp;gt; Cursor&amp;lt;E&amp;gt; queryCursor(MappedStatement var1, Object var2, RowBounds var3) throws SQLException;

    List&amp;lt;BatchResult&amp;gt; flushStatements() throws SQLException;

    void commit(boolean var1) throws SQLException;

    void rollback(boolean var1) throws SQLException;

    CacheKey createCacheKey(MappedStatement var1, Object var2, RowBounds var3, BoundSql var4);

    boolean isCached(MappedStatement var1, CacheKey var2);

    void clearLocalCache();

    void deferLoad(MappedStatement var1, MetaObject var2, String var3, CacheKey var4, Class&amp;lt;?&amp;gt; var5);

    Transaction getTransaction();

    void close(boolean var1);

    boolean isClosed();

    void setExecutorWrapper(Executor var1);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;mybatis-spring依赖中MapperScannerRegistrar的作用：registerBeanDefinitions方法中的doScan()此方法是将Mapper扫描到初始化中。原理就是获取到项目路径找到对应的classes路径，获取了com.dao包名，将获取的路径+包名转成文件夹，循环获取文件夹下面的文件（UserDao.class），然后使用将UserDao拿到。此时包名+类名都拿到后使用Class.forName(包名+类名)反射出对象，进行bean注册&lt;/p&gt;
&lt;p&gt;总结运行原理：&lt;/p&gt;
&lt;p&gt;　　初始化信息（数据库连接信息，扫描mapper包中的class用于创建bean对象，spring中的类applicationFactory用于创建变对象、mapper中的xml的id与sql放到MapperStatement对象中）&lt;br/&gt;　　　　　　其中对于扫描mapper包中的class路径+参数basePackages转成文件夹，然后循环找到所有的类名，使用.......（请看MapperScannerRegistrar引出的doScan方法）&lt;/p&gt;
&lt;p&gt;　　执行过程：根据SqlSessionFactoryBean创建出sqlSession，调用selectList方法，之后根据参数(nameSpaceName+id)作为key找到MapperStatement对象中存储的value获取到sql语句，再有Executor（mybatis默认使用                               CacheExecutor）执行sql语句查询出结果集&lt;/p&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
&lt;/pre&gt;
&lt;p&gt;　下节内容：自己创建mybatis&lt;/p&gt;



&lt;p&gt;&lt;span class=&quot;tag&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;atn&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;atv&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;tag&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 09 Apr 2019 18:03:00 +0000</pubDate>
<dc:creator>为了WZJ</dc:creator>
<og:description>1、创建项目maven，方便依赖下载。使用的jar如下： 2、创建包com &gt;config、dao、service、test 3、使用spring创建AppConfig文件，创建Bean&gt;</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/gnwzj/p/10680940.html</dc:identifier>
</item>
<item>
<title>[android学习]android_gps定位服务简单实现 - 小舍先生</title>
<link>http://www.cnblogs.com/gemuxiaoshe/p/10680933.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gemuxiaoshe/p/10680933.html</guid>
<description>&lt;ul readability=&quot;6.5&quot;&gt;&lt;li readability=&quot;16&quot;&gt;
&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;br/&gt;gps定位服务的学习是这段时间gps课程的学习内容,之前老师一直在将概念,今天终于是实践课(其实就是给了一个案例,让自己照着敲).不过在照着案列敲了两遍之后,发现老师的案例是在是太老了,并且直接照着案例敲,也无法理解其中很多类,方法的作用.&lt;br/&gt;于是自己在网上查看了其他实现的方法,并尝试敲案列,期间的挫折一言难尽.&lt;br/&gt;&lt;em&gt;(网上找的案例也并不信息,使得我在给予权限,和权限检查方面一直报错,因为我使用的是最新的As和java11,在经过数遍从基础理解到实例编写的过程和不知多少遍google之后,终于完成了这次练习)&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;总结起来:&lt;/strong&gt;
&lt;ul readability=&quot;7&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;还是发现自己有不少的问题,在代码的理解能力上经过了这段时间的学习确实有些长进,但在较复杂的语句上面,理解还是有不小的困难.&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;11&quot;&gt;
&lt;p&gt;其次,在没有事先了解学习某些类之前,是真的不适合直接照案例敲和学习(没有十分详细注释的案例,通常情况下都是如此),其效率实在低下,且很多时候会不知所云.&lt;br/&gt;&lt;em&gt;(个人并不提倡照着敲,敲的多了自然就懂了的学习说法,或许它只是针对于懒的人,亦或许这种说法其实只是一个劝诫我们勤奋努力,多实践的比喻.).&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;源代码&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;activity_main.xml&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    tools:context=&quot;.MainActivity&quot;
    android:orientation=&quot;vertical&quot;
    &amp;gt;
    &amp;lt;TextView
        android:id=&quot;@+id/tv_show&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        android:padding=&quot;5dp&quot;
        android:textSize=&quot;22dp&quot;
        android:textStyle=&quot;bold&quot; /&amp;gt;
&amp;lt;/LinearLayout&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;MainActivity.java&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;package cn.gemuxiaoshe.gpsapplication20;
import android.Manifest;
import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.location.Location;
import android.location.LocationListener;
import android.location.LocationManager;
import android.provider.Settings;
import android.support.v4.app.ActivityCompat;
import android.support.v7.app.AppCompatActivity;
import android.os.Bundle;
import android.widget.TextView;
import android.widget.Toast;
import java.util.Date;
public class MainActivity extends AppCompatActivity {
    private LocationManager lm;
    private TextView tv_show;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        tv_show = (TextView) findViewById(R.id.tv_show);
        lm = (LocationManager) getSystemService(Context.LOCATION_SERVICE);
        if (!isGpsAble(lm)) {
            Toast.makeText(MainActivity.this, &quot;请打开Gps!&quot;, Toast.LENGTH_SHORT).show();
            openGps();
        }
        // 从gps获取最近的定位信息
        if (ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED &amp;amp;&amp;amp; ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_COARSE_LOCATION) != PackageManager.PERMISSION_GRANTED) {
            return;
        }
        Location lc = lm.getLastKnownLocation(LocationManager.GPS_PROVIDER);
        updateShow(lc);
        //设置间隔两秒获得一次gps定位信息
        lm.requestLocationUpdates(LocationManager.GPS_PROVIDER, 2000, 8, new LocationListener() {
            @Override
            public void onLocationChanged(Location location) {
                // 当gps定位信息发生改变时,更新定位
                updateShow(location);
            }
            @Override
            public void onStatusChanged(String s, int i, Bundle bundle) {

            }
            @Override
            public void onProviderEnabled(String provider) {
                // 当gpsLocationProvider可用时,更新定位
                if (ActivityCompat.checkSelfPermission(MainActivity.this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED &amp;amp;&amp;amp; ActivityCompat.checkSelfPermission(MainActivity.this, Manifest.permission.ACCESS_COARSE_LOCATION) != PackageManager.PERMISSION_GRANTED) {
                    return;
                }
                updateShow(lm.getLastKnownLocation(provider));
            }
            @Override
            public void onProviderDisabled(String s) {
            updateShow(null);
            }
        });
    }
    // 定义更新显示的方法
    private void updateShow(Location location){
        if (location!=null){
            StringBuilder sb =new StringBuilder();
            sb.append(&quot;当前gps位置定位信息:\n&quot;);
            sb.append(&quot;经度:&quot;+location.getLongitude()+&quot;\n&quot;);
            sb.append(&quot;维度:&quot;+location.getLatitude()+&quot;\n&quot;);
            sb.append(&quot;海拔:&quot;+location.getAltitude()+&quot;\n&quot;);
            sb.append(&quot;速度:&quot;+location.getSpeed()+&quot;\n&quot;);
            sb.append(&quot;方位:&quot;+location.getBearing()+&quot;\n&quot;);
            sb.append(&quot;时间:&quot;+location.getTime()+&quot;\n&quot;);
            sb.append(&quot;定位精度:&quot;+location.getLongitude()+&quot;\n&quot;);
            tv_show.setText(sb.toString());
        }else
            tv_show.setText(&quot;&quot;);
    }
    
    private boolean isGpsAble(LocationManager lm) {
        return lm.isProviderEnabled(LocationManager.GPS_PROVIDER)?true:false;
    }
    // 打开设置界面让用户自己设置
    private void openGps(){
        Intent intent = new Intent(Settings.ACTION_LOCALE_SETTINGS);
        startActivityForResult(intent,0);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要注意到的是:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;我屡次报错的原因:&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;“从Android 6.0（API级别23）开始，用户在应用程序运行时向应用程序授予权限，而不是在安装应用程序时授予权限。” 在这种情况下，“ACCESS_FINE_LOCATION”是一个“危险权限，因此，你会得到这个'java.lang.SecurityException：”gps“位置提供者需要ACCESS_FINE_LOCATION权限。” 错误.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;解决方法:&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;   if (ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED &amp;amp;&amp;amp; ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_COARSE_LOCATION) != PackageManager.PERMISSION_GRANTED) {
            return;
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;关于该问题的详细说明请参看:&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;%5Bhttps://developer.android.com/training/permissions/requesting.html%5D(https://developer.android.com/training/permissions/requesting.html)&quot;&gt;在运行时请求权限&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8067684-60fd43b34e8ed877.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;2019-4-8-04.gif&quot;/&gt;&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;这里需要注意的是:&lt;/p&gt;
&lt;p&gt;如果你是在模拟器上测试程序时,请手动打开应用的权限设置,并给予程序获取定位信息的权限.否则模拟器是不会有提示的,你只会获得下面这样的一段崩溃记录...&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8067684-0a35072a4a47ace1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;2019-4-10-01.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;就记录到这里了,关于gps定位服务的详细学习在之后会单独出笔记记录,今天是就照案列敲的一次练习,并简记一下从中学到的的一些东西.并深刻体会下这种坑爹的学习方式.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.runoob.com/w3cnote/android-tutorial-gps.html&quot;&gt;android-gps初涉&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/32491960/android-check-permission-for-locationmanager&quot;&gt;一篇关于运行时请求权限问题的博文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.android.com/training/permissions/requesting?hl=zh-cn&quot;&gt;这是android开发文档中的一篇关于权限的说明文档&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;更新时间:&lt;br/&gt;2019-4-10&lt;br/&gt;1:36&lt;/p&gt;
</description>
<pubDate>Tue, 09 Apr 2019 17:54:00 +0000</pubDate>
<dc:creator>小舍先生</dc:creator>
<og:description>前言 gps定位服务的学习是这段时间gps课程的学习内容,之前老师一直在将概念,今天终于是实践课(其实就是给了一个案例,让自己照着敲).不过在照着案列敲了两遍之后,发现老师的案例是在是太老了,并且直接</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/gemuxiaoshe/p/10680933.html</dc:identifier>
</item>
<item>
<title>《领域驱动设计》干货整理 - Dybvig</title>
<link>http://www.cnblogs.com/x2zh/p/10680830.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/x2zh/p/10680830.html</guid>
<description>&lt;p&gt;当然，如果在Java中查询所返回的对象是集合时，客户不管怎样都要执行这样的转换。&lt;br/&gt;Java1.4添加了泛型之后，返回集合时，不再需要用户进行强制类型转换。作者写书时，Java1.4应该还没有发布，所以这样描述并没有错误。但是，这可能给后来的读者造成一些困惑。&lt;/p&gt;
</description>
<pubDate>Tue, 09 Apr 2019 16:56:00 +0000</pubDate>
<dc:creator>Dybvig</dc:creator>
<og:description>Repository代码设计 1. 可以将Repository理解为一个集合（这里的集合更偏重于是Collection，而不是Set），它包括了对存储对象基本的增删改查（CURD）功能。同时，Repo</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/x2zh/p/10680830.html</dc:identifier>
</item>
<item>
<title>Java容器类源码分析之Iterator与ListIterator迭代器（基于JDK8） - 官建</title>
<link>http://www.cnblogs.com/jianguan/p/10680821.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jianguan/p/10680821.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、基本概念&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;    迭代器是一个对象，也是一种设计模式，Java有两个用来实实现&lt;span&gt;迭代器&lt;/span&gt;的接口，分别是Iterator接口和继承自Iterator的ListIterator接口。实现迭代器接口的类的对象有遍历集合对象，选择集合中的元素和删除集合中元素的方法。而在使用它时不必知道该集合对象底层的结构。Java类库中实现Iterator接口的迭代器只能正向遍历集合中的元素，而实现ListIterator接口的迭代器不仅能够正向遍历，还能够反向遍历集合中的元素。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、源码分析&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.1、Iterator接口与ListIterator接口的继承与实现&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1651127/201904/1651127-20190409201229126-1850121815.png&quot; alt=&quot;&quot; width=&quot;940&quot; height=&quot;476&quot;/&gt;&lt;/p&gt;

&lt;p&gt;图2.1  Java迭代器类的继承与接口实现（部分）&lt;/p&gt;

&lt;p&gt;    ListIterator接口继承了Iterator接口。在AbstractList、ArrayList和Vector这三个类中的内部类ListItr实现了ListIterator接口，这三个类的内部类ListItr又分别继承了在这三个类中实现了Iterator接口的内部类Itr。实现ListIterator的类还有LinkedList的内部类ListItr。实现Iterator的类还有LinkedList的内部类DescendingIterator，HashMap的内部类EntryIterator，KeyIterator，ValueIterator，以及TreeMap的内部类PrivateEntryIterator等。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.2、迭代器接口方法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;       &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;        &lt;/strong&gt;1）迭代器的向前移动与向后移动图解&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1651127/201904/1651127-20190409225117292-1733920237.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;       &lt;/strong&gt; &lt;span&gt; 2）Iterator接口方法&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre readability=&quot;13&quot;&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; java.util;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.function.Consumer;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; Iterator&amp;lt;E&amp;gt;&lt;span&gt; {

    &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; hasNext();

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;   在Java中，这个方法的具体实现一般用来在遍历容器时，调用该方法使迭代器向前移动一位，来检测集合中是否还有下一个元素，还有下一个元素返回true，否则返回false&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
 
    E next();

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;   实现这个方法，在遍历容器时，调用该方法将迭代器&lt;/span&gt;&lt;span&gt;向前移动一位，并将迭代器越过的一个元素作为方法的返回值。该方法用来返回集合中下一个元素。&lt;br/&gt;在调用next()方法前，先调用hasNext()方法判断集合中是否还有下一个元素 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt; &lt;p&gt;&lt;span&gt;    default&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; remove() { &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; UnsupportedOperationException(&quot;remove&quot;&lt;span&gt;); } &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;   实现这个方法，用来删除在迭代器调用next()方法迭代器越过的一个元素&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt; &lt;/p&gt;&lt;p&gt;&lt;span&gt;    default&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; forEachRemaining(Consumer&amp;lt;? &lt;span&gt;super&lt;/span&gt; E&amp;gt;&lt;span&gt; action) { Objects.requireNonNull(action); &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (hasNext()) action.accept(next()); }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;/*  &lt;/span&gt;&lt;span&gt; 实现这个方法来顺序遍历容器中的每个元素，用来实现集合类的ForEach遍历操作&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt; &lt;br/&gt;}&lt;/span&gt;
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;   &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;    3）ListIterator接口方法&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; java.util;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; ListIterator&amp;lt;E&amp;gt; &lt;span&gt;extends&lt;/span&gt; Iterator&amp;lt;E&amp;gt;&lt;span&gt; {
  
    &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; hasNext();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;同Iterator接口，用来检测迭代器前面是否还有元素&lt;/span&gt;
&lt;span&gt;   
    E next();&lt;/span&gt;&lt;span&gt;//  &lt;/span&gt;&lt;span&gt;同Iterator接口，使迭代器向前移动一位，获得迭代器越过的下一个元素&lt;/span&gt;

    &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; hasPrevious();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  实现这个方法来检测当前迭代器位置后面是否有元素，用于反向遍历&lt;/span&gt;
&lt;span&gt; 
    E previous();

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;   实现这个方法，将迭代器向后移动一位，并将迭代器越过的后面的一个元素作为方法返回值，在调用该方法前需要调用hasPrevious方法来判断迭代器前是否有元素 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
   
    &lt;span&gt;int&lt;/span&gt; nextIndex();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现该方法获取迭代器前面一个元素的索引&lt;/span&gt;

    &lt;span&gt;int&lt;/span&gt; previousIndex();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现该方法获取迭代器后面一个元素的索引&lt;/span&gt;

    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; remove();

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;   实现该方法，用来删除迭代器调用next()方法或调用previous()方法时迭代器越过的一个元素 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

    &lt;span&gt;void&lt;/span&gt; set(E e);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现该方法在迭代器遍历时修改元素&lt;/span&gt;

    &lt;span&gt;void&lt;/span&gt; add(E e);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现该方法在迭代器遍历时添加元素&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;




&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.3、集合类与迭代器的关系&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;   &lt;/strong&gt; &lt;span&gt;   1）Iterator接口。阅读源码可知，Collectiion接口实现了Iterable接口，Iterable有一个返回一个Iterator&amp;lt;T&amp;gt;对象的iterator()方法，所以继承和实现了Collection接口的所有容器类及其子类和实现类都有一个返回Iterator对象的的iterator()方法。Java中有很多集合类中都设计有实现了Iterator接口的内部类，如ArrayList和LinkedList等类。HashMap和TreeMap类中也包含有实现了Iterator的内部类，来对Map中的KeySet、Value和EntrySet进行迭代。Iterable接口的源代码如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public interface Iterable&amp;lt;T&amp;gt; {

    Iterator&lt;/span&gt;&amp;lt;T&amp;gt;&lt;span&gt; iterator();//&lt;span&gt;实现这个方法，该方法返回一个Iterator迭代器对象。&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; forEach(Consumer&amp;lt;? &lt;span&gt;super&lt;/span&gt; T&amp;gt;&lt;span&gt; action) {
        Objects.requireNonNull(action);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (T t : &lt;span&gt;this&lt;/span&gt;&lt;span&gt;) {
            action.accept(t);
        }
    }//&lt;span&gt;实现这个方法来对容器进行ForEach遍历
  
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;default&lt;/span&gt; Spliterator&amp;lt;T&amp;gt;&lt;span&gt; spliterator() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Spliterators.spliteratorUnknownSize(iterator(), 0&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;      &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;span&gt;       2）ListIterator接口。查看源码可以发现，List接口中有两个返回ListIterator&amp;lt;T&amp;gt;对象的方法，如下。List接口下的的ArrayList和LinkedList都有返回ListIterator对象的方法。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
ListIterator&amp;lt;E&amp;gt;&lt;span&gt; listIterator();&lt;span&gt;//实现这个方法，该方法返回一个ListIterator迭代器对象，迭代器初始化后，一般迭代器位于在容器第一个元素后面。&lt;/span&gt;

ListIterator&lt;/span&gt;&amp;lt;E&amp;gt; listIterator(&lt;span&gt;int&lt;/span&gt; index);//&lt;span&gt;实现这个方法，返回一个指定了开始遍历容器时迭代器初始位置的ListIterator迭代器对象&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;&lt;li&gt;ArrayList类设计有实现了ListIterator接口的内部类ListItr（不过ArrayList的listIterator(final int index)方法并未使用这个内部类，而是在方法中又设计了一个ListIterator匿名内部类作为方法返回值，可以发现ArrayList的Iterator()方法也是调用了这个方法来构建迭代器对象）。ArrayList类中部分有关源码如下&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ListItr &lt;span&gt;extends&lt;/span&gt; Itr &lt;span&gt;implements&lt;/span&gt; ListIterator&amp;lt;E&amp;gt;&lt;span&gt; {
        ListItr(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index) {
            &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;();
            cursor &lt;/span&gt;=&lt;span&gt; index;
        }&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;public&lt;/span&gt; Iterator&amp;lt;E&amp;gt;&lt;span&gt; iterator() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; listIterator();
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ListIterator&amp;lt;E&amp;gt; listIterator(&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; index) {
            checkForComodification();
            rangeCheckForAdd(index);
            &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; offset = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.offset;

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ListIterator&amp;lt;E&amp;gt;&lt;span&gt;() {//&lt;span&gt;返回了一个ListIterator内部类
                &lt;/span&gt;&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; cursor =&lt;span&gt; index;
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; lastRet = -1&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; expectedModCount = ArrayList.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.modCount;

                &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; hasNext() {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; cursor != SubList.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.size;
                }&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;&lt;li&gt;  LinkedList类也有内部类ListItr实现了ListIterator接口，linkedList的listIterator()方法返回了这个内部类的实例。LinkedList中部分有关源码如下&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; ListIterator&amp;lt;E&amp;gt; listIterator(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index) {
        checkPositionIndex(index);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ListItr(index);
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ListItr &lt;span&gt;implements&lt;/span&gt; ListIterator&amp;lt;E&amp;gt; {
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;（小官原创，若有谬误，望各位前辈批评指正）&lt;/p&gt;


&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;






</description>
<pubDate>Tue, 09 Apr 2019 16:50:00 +0000</pubDate>
<dc:creator>官建</dc:creator>
<og:description>一、基本概念 迭代器是一个对象，也是一种设计模式，Java有两个用来实实现迭代器的接口，分别是Iterator接口和继承自Iterator的ListIterator接口。实现迭代器接口的类的对象有遍历</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jianguan/p/10680821.html</dc:identifier>
</item>
<item>
<title>聊一聊C# 8.0中的await foreach - 码农阿宇</title>
<link>http://www.cnblogs.com/CoderAyu/p/10680805.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CoderAyu/p/10680805.html</guid>
<description>&lt;p&gt;很开心今天能与大家一起聊聊C# 8.0中的新特性-&lt;code&gt;Async Streams&lt;/code&gt;,一般人通常看到这个词表情是这样.&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/liuzhenyulive/AsyncStreamsInCShaper8.0/master/Pic/mengbi.jpg&quot; width=&quot;100&quot; height=&quot;100&quot;/&gt;&lt;br/&gt;简单说,其实就是C# 8.0中支持&lt;code&gt;await foreach&lt;/code&gt;.&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/liuzhenyulive/AsyncStreamsInCShaper8.0/master/Pic/mengbi2.jpg&quot; width=&quot;100&quot; height=&quot;100&quot;/&gt;&lt;br/&gt;或者说,C# 8.0中支持异步返回枚举类型&lt;code&gt;async Task&amp;lt;IEnumerable&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;.&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/liuzhenyulive/AsyncStreamsInCShaper8.0/master/Pic/mengbi3.jpeg&quot; width=&quot;100&quot; height=&quot;100&quot;/&gt;&lt;br/&gt;好吧,还不懂?Good,这篇文章就是为你写的,看完这篇文章,你就能明白它的神奇之处了.&lt;/p&gt;
&lt;h2 id=&quot;为什么写这篇文章&quot;&gt;为什么写这篇文章&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Async Streams&lt;/code&gt;这个功能已经发布很久了,在去年的&lt;a href=&quot;https://channel9.msdn.com/Events/Build/2018/BRK2155&quot;&gt;Build 2018 The future of C#&lt;/a&gt;就有演示,最近VS 2019发布,在该版本的&lt;a href=&quot;https://docs.microsoft.com/en-us/visualstudio/releases/2019/release-notes&quot;&gt;Release Notes&lt;/a&gt;中,我再次看到了这个新特性,因为对异步编程不太熟悉,所以借着这个机会,学习新特性的同时,把异步编程重温一遍.&lt;br/&gt;本文内容,参考了&lt;code&gt;Bassam Alugili&lt;/code&gt;在InfoQ中发表的&lt;a href=&quot;https://www.infoq.com/articles/Async-Streams&quot;&gt;Async Streams in C# 8&lt;/a&gt;,撰写本博客前我已联系上该作者并得到他支持.&lt;/p&gt;
&lt;h2 id=&quot;async-await&quot;&gt;Async / Await&lt;/h2&gt;
&lt;p&gt;C# 5 引入了 Async/Await，用以提高用户界面响应能力和对 Web 资源的访问能力。换句话说，异步方法用于执行不阻塞线程并返回一个标量结果的异步操作。&lt;/p&gt;
&lt;p&gt;微软多次尝试简化异步操作，因为 Async/Await 模式易于理解，所以在开发人员当中获得了良好的认可。&lt;/p&gt;
&lt;p&gt;详见&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/async/&quot;&gt;The Task asynchronous programming model in C#&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;常规示例&quot;&gt;常规示例&lt;/h2&gt;
&lt;p&gt;要了解问什么需要&lt;code&gt;Async Streams&lt;/code&gt;,我们先来看看这样的一个示例,求出5以内的整数的和.&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;static int SumFromOneToCount(int count)
        {
            ConsoleExt.WriteLine(&quot;SumFromOneToCount called!&quot;);

            var sum = 0;
            for (var i = 0; i &amp;lt;= count; i++)
            {
                sum = sum + i;
            }
            return sum;
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用方法.&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;static void Main(string[] args)
        {
            const int count = 5;
            ConsoleExt.WriteLine($&quot;Starting the application with count: {count}!&quot;);
            ConsoleExt.WriteLine(&quot;Classic sum starting.&quot;);
            ConsoleExt.WriteLine($&quot;Classic sum result: {SumFromOneToCount(count)}&quot;);
            ConsoleExt.WriteLine(&quot;Classic sum completed.&quot;);
            ConsoleExt.WriteLine(&quot;################################################&quot;);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/liuzhenyulive/AsyncStreamsInCShaper8.0/raw/master/Pic/base.png&quot; width=&quot;1000&quot; height=&quot;200&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到,整个过程就一个线程Id为1的线程自上而下执行,这是最基础的做法.&lt;/p&gt;
&lt;h2 id=&quot;yield-return&quot;&gt;Yield Return&lt;/h2&gt;
&lt;p&gt;接下来,我们使用&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/yield&quot;&gt;yield&lt;/a&gt;运算符使得这个方法编程延迟加载,如下所示.&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;static IEnumerable&amp;lt;int&amp;gt; SumFromOneToCountYield(int count)
        {
            ConsoleExt.WriteLine(&quot;SumFromOneToCountYield called!&quot;);

            var sum = 0;
            for (var i = 0; i &amp;lt;= count; i++)
            {
                sum = sum + i;

                yield return sum;
            }
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;主函数&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;static void Main(string[] args)
        {
            const int count = 5;
            ConsoleExt.WriteLine(&quot;Sum with yield starting.&quot;);
            foreach (var i in SumFromOneToCountYield(count))
            {
                ConsoleExt.WriteLine($&quot;Yield sum: {i}&quot;);
            }
            ConsoleExt.WriteLine(&quot;Sum with yield completed.&quot;);

            ConsoleExt.WriteLine(&quot;################################################&quot;);
            ConsoleExt.WriteLine(Environment.NewLine);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果如下.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/liuzhenyulive/AsyncStreamsInCShaper8.0/raw/master/Pic/YeildReturn.png&quot; width=&quot;1000&quot; height=&quot;200&quot;/&gt;&lt;/p&gt;
&lt;p&gt;正如你在输出窗口中看到的那样，结果被分成几个部分返回，而不是作为一个值返回。以上显示的累积结果被称为惰性枚举。但是，仍然存在一个问题，即 sum 方法阻塞了代码的执行。如果你查看线程ID，可以看到所有东西都在主线程1中运行,这显然不完美,继续改造.&lt;/p&gt;
&lt;h2 id=&quot;async-return&quot;&gt;Async Return&lt;/h2&gt;
&lt;p&gt;我们试着将async用于SumFromOneToCount方法(没有yield关键字).&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;static async Task&amp;lt;int&amp;gt; SumFromOneToCountAsync(int count)
        {
            ConsoleExt.WriteLine(&quot;SumFromOneToCountAsync called!&quot;);

            var result = await Task.Run(() =&amp;gt;
            {
                var sum = 0;

                for (var i = 0; i &amp;lt;= count; i++)
                {
                    sum = sum + i;
                }
                return sum;
            });

            return result;
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;主函数.&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;static async Task Main(string[] args)
        {
            const int count = 5;
            ConsoleExt.WriteLine(&quot;async example starting.&quot;);
            // Sum runs asynchronously! Not enough. We need sum to be async with lazy behavior.
            var result = await SumFromOneToCountAsync(count);
            ConsoleExt.WriteLine(&quot;async Result: &quot; + result);
            ConsoleExt.WriteLine(&quot;async completed.&quot;);

            ConsoleExt.WriteLine(&quot;################################################&quot;);
            ConsoleExt.WriteLine(Environment.NewLine);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/liuzhenyulive/AsyncStreamsInCShaper8.0/raw/master/Pic/AsyncReturn.png&quot; width=&quot;1000&quot; height=&quot;200&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以看到计算过程是在另一个线程中运行，但结果仍然是作为一个值返回！任然不完美.&lt;/p&gt;
&lt;p&gt;如果我们想把惰性枚举（yield return）与异步方法结合起来,即返回Task&amp;lt;IEnumerable,这怎么实现呢?&lt;/p&gt;
&lt;h2 id=&quot;taskienumerable&quot;&gt;Task&amp;lt;IEnumerable&amp;gt;&lt;/h2&gt;
&lt;p&gt;我们根据假设把代码改造一遍,使用&lt;code&gt;Task&amp;lt;IEnumerable&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;来进行计算.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/liuzhenyulive/AsyncStreamsInCShaper8.0/raw/master/Pic/NotSupportError.png&quot; width=&quot;1470&quot; height=&quot;560&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到,直接出现错误.&lt;/p&gt;
&lt;h2 id=&quot;iasyncenumerable&quot;&gt;IAsyncEnumerable&lt;/h2&gt;
&lt;p&gt;其实,在C# 8.0中Task&amp;lt;IEnumerable&amp;gt;这种组合称为IAsyncEnumerable。这个新功能为我们提供了一种很好的技术来解决拉异步延迟加载的问题，例如从网站下载数据或从文件或数据库中读取记录,与 IEnumerable 和 IEnumerator 类似，Async Streams 提供了两个新接口 IAsyncEnumerable 和 IAsyncEnumerator，定义如下：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public interface IAsyncEnumerable&amp;lt;out T&amp;gt;
    {
        IAsyncEnumerator&amp;lt;T&amp;gt; GetAsyncEnumerator();
    }

    public interface IAsyncEnumerator&amp;lt;out T&amp;gt; : IAsyncDisposable
    {
        Task&amp;lt;bool&amp;gt; MoveNextAsync();
        T Current { get; }
    }

   // Async Streams Feature 可以被异步销毁 
   public interface IAsyncDisposable
   {
      Task DiskposeAsync();
   }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;asyncstream&quot;&gt;AsyncStream&lt;/h2&gt;
&lt;p&gt;下面,我们就来见识一下AsyncStrema的威力,我们使用IAsyncEnumerable来对函数进行改造,如下.&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;static async Task ConsumeAsyncSumSeqeunc(IAsyncEnumerable&amp;lt;int&amp;gt; sequence)
        {
            ConsoleExt.WriteLineAsync(&quot;ConsumeAsyncSumSeqeunc Called&quot;);

            await foreach (var value in sequence)
            {
                ConsoleExt.WriteLineAsync($&quot;Consuming the value: {value}&quot;);

                // simulate some delay!
                await Task.Delay(TimeSpan.FromSeconds(1));
            };
        }

        private static async IAsyncEnumerable&amp;lt;int&amp;gt; ProduceAsyncSumSeqeunc(int count)
        {
            ConsoleExt.WriteLineAsync(&quot;ProduceAsyncSumSeqeunc Called&quot;);
            var sum = 0;

            for (var i = 0; i &amp;lt;= count; i++)
            {
                sum = sum + i;

                // simulate some delay!
                await Task.Delay(TimeSpan.FromSeconds(0.5));

                yield return sum;
            }
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;主函数.&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt; static async Task Main(string[] args)
        {
            const int count = 5;
            ConsoleExt.WriteLine(&quot;Starting Async Streams Demo!&quot;);

            // Start a new task. Used to produce async sequence of data!
            IAsyncEnumerable&amp;lt;int&amp;gt; pullBasedAsyncSequence = ProduceAsyncSumSeqeunc(count);

            // Start another task; Used to consume the async data sequence!
            var consumingTask = Task.Run(() =&amp;gt; ConsumeAsyncSumSeqeunc(pullBasedAsyncSequence));

            await Task.Delay(TimeSpan.FromSeconds(3));

            ConsoleExt.WriteLineAsync(&quot;X#X#X#X#X#X#X#X#X#X# Doing some other work X#X#X#X#X#X#X#X#X#X#&quot;);

            // Just for demo! Wait until the task is finished!
            await consumingTask;

            ConsoleExt.WriteLineAsync(&quot;Async Streams Demo Done!&quot;);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果一切顺利,那么就能看到这样的运行结果了.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/liuzhenyulive/AsyncStreamsInCShaper8.0/raw/master/Pic/AsyncStream.png&quot; width=&quot;1000&quot; height=&quot;300&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后,看到这就是我们想要的结果,在枚举的基础上,进行了异步迭代.&lt;br/&gt;可以看到,整个计算过程并没有造成主线程的阻塞,其中,值得重点关注的是红色方框区域的&lt;code&gt;线程5&lt;/code&gt;!&lt;code&gt;线程5&lt;/code&gt;!&lt;code&gt;线程5&lt;/code&gt;!线程5在请求下一个结果后,并没有等待结果返回,而是去了Main()函数中做了别的事情,等待请求的结果返回后,线程5又接着执行foreach中任务.&lt;/p&gt;
&lt;h2 id=&quot;clientserver的异步拉取&quot;&gt;Client/Server的异步拉取&lt;/h2&gt;
&lt;p&gt;如果还没有理解&lt;code&gt;Async Streams&lt;/code&gt;的好处,那么我借助客户端 / 服务器端架构是演示这一功能优势的绝佳方法。&lt;/p&gt;
&lt;h3 id=&quot;同步调用&quot;&gt;同步调用&lt;/h3&gt;
&lt;p&gt;客户端向服务器端发送请求，客户端必须等待（客户端被阻塞），直到服务器端做出响应.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/liuzhenyulive/AsyncStreamsInCShaper8.0/raw/master/Pic/Synchronous-Data-Pull.jpg&quot; width=&quot;407&quot; height=&quot;566&quot;/&gt;&lt;/p&gt;
&lt;p&gt;示例中Yield Return就是以这种方式执行的,所以整个过程只有一个线程即线程1在处理.&lt;/p&gt;
&lt;h3 id=&quot;异步调用&quot;&gt;异步调用&lt;/h3&gt;
&lt;p&gt;客户端发出数据块请求，然后继续执行其他操作。一旦数据块到达，客户端就处理接收到的数据块并询问下一个数据块，依此类推，直到达到最后一个数据块为止。这正是 Async Streams 想法的来源。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/liuzhenyulive/AsyncStreamsInCShaper8.0/raw/master/Pic/Asynchronous-Sequence-Data-Pull-large.jpg&quot; width=&quot;1000&quot; height=&quot;882&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后一个示例就是以这种方式执行的,&lt;code&gt;线程5&lt;/code&gt;询问下一个数据后并没有等待结果返回,而是去做了Main()函数中的别的事情,数据到达后,&lt;code&gt;线程5&lt;/code&gt;又继续处理foreach中的任务.&lt;/p&gt;
&lt;h2 id=&quot;tips&quot;&gt;Tips&lt;/h2&gt;
&lt;p&gt;如果你使用的是&lt;code&gt;.net core 2.2&lt;/code&gt;及以下版本,会遇到这样的报错.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/liuzhenyulive/AsyncStreamsInCShaper8.0/raw/master/Pic/NotSupportAsyncStream2.2.png&quot; width=&quot;1000&quot; height=&quot;300&quot;/&gt;&lt;/p&gt;
&lt;p&gt;需要安装&lt;code&gt;.net core 3.0 preview&lt;/code&gt;的SDK(截至至博客撰写日期4月9日,&lt;code&gt;.net core SDK&lt;/code&gt;最新版本为&lt;code&gt;3.0.100-preview3-010431&lt;/code&gt;),安装好SDK后,如果你是VS 2019正式版,可能无法选择3.0的与预览版,听过只有VS 2019 Preview才支持.Net core 3.0的预览版.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/liuzhenyulive/AsyncStreamsInCShaper8.0/raw/master/Pic/TheSupportToCore3.0PreView.png&quot; width=&quot;1000&quot; height=&quot;300&quot;/&gt;&lt;/p&gt;
&lt;p&gt;总结&lt;/p&gt;
&lt;p&gt;我们已经讨论过 &lt;code&gt;Async Streams&lt;/code&gt;，它是一种出色的异步拉取技术，可用于进行生成多个值的异步计算。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Async Streams&lt;/code&gt; 背后的编程概念是异步拉取模型。我们请求获取序列的下一个元素，并最终得到答复。Async Streams 提供了一种处理异步数据源的绝佳方法，希望对大家能够有所帮助。&lt;/p&gt;
&lt;p&gt;文章中涉及的所有代码已保存在我的GitHub中,请尽情享用!&lt;br/&gt;&lt;a href=&quot;https://github.com/liuzhenyulive/AsyncStreamsInCShaper8.0&quot; class=&quot;uri&quot;&gt;https://github.com/liuzhenyulive/AsyncStreamsInCShaper8.0&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;致谢&lt;/p&gt;
&lt;p&gt;之前一直感觉国外的大师级开发者遥不可及甚至高高在上,在遇到&lt;code&gt;Bassam Alugili&lt;/code&gt;之后,我才真正感受到技术交流没有高低贵贱,正如他对我说的 &lt;code&gt;The most important thing in this world is sharing the knowledge!&lt;/code&gt;&lt;br/&gt;Thank you,I will keep going!!&lt;/p&gt;
&lt;p&gt;参考文献: Async Streams in C# 8 &lt;a href=&quot;https://www.infoq.com/articles/Async-Streams&quot; class=&quot;uri&quot;&gt;https://www.infoq.com/articles/Async-Streams&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 09 Apr 2019 16:41:00 +0000</pubDate>
<dc:creator>码农阿宇</dc:creator>
<og:description>AsyncStreamsInCShaper8.0 很开心今天能与大家一起聊聊C 8.0中的新特性 ,一般人通常看到这个词表情是这样. 简单说,其实就是C 8.0中支持 . 或者说,C 8.0中支持异步</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CoderAyu/p/10680805.html</dc:identifier>
</item>
<item>
<title>kali权限提升之本地提权 - 雨中落叶</title>
<link>http://www.cnblogs.com/yuzly/p/10659643.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuzly/p/10659643.html</guid>
<description>&lt;p&gt;&lt;span&gt;kali权限提升之本地提权&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;系统账号之间权限隔离&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　操作系统的安全基础&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　用户空间&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　内核空间&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;系统账号：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　用户账号登陆时候获取权限令牌&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　服务账号无需用户登录已在后台启动服务&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;windows用户全权限划分:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　Users:普通用户组,Users 组是最安全的组，因为分配给该组的默认权限不允许成员修改操作系统的设置或用户资料&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　Administrators:管理员组，默认情况下，Administrators中的用户对计算机/域有不受限制的完全访问权。分配给该组的默认权限允许对整个系统进行完全控制　&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　System:拥有和Administrators一样、甚至比其还高的权限，但是这个组不允许任何用户的加入，在查看用户组的时候，它也不会被显示出来，它就是SYSTEM组。系统和系统级的服务正常运行所需要的权限都是靠它赋予的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;Linux系统用户权限划分:&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;　&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;Users：普通用户&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Root：管理员账号&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;管理员权限提升为System权限&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.at实现管理员权限提升为system权限  &lt;span&gt;#只能在XP与2003的系统上使用&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.1at 16:53 /interactive cmd   #xp或者win2003&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201904/1592114-20190405172812006-1790515488.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.2使用taskmgr命令打开任务管理器，杀死现用户桌面进程(explorer.exe)，新建explorer.exe，则整个界面都在管理员（因为当前的explorer进程实在system权限运行的）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201904/1592114-20190405173459667-2091338847.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 1.3此时在重新打开cmd,当前用户就变成system了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201904/1592114-20190405173718109-361164805.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.4在win7使用at 17：26 /interactive cmd运行命令提示被限制&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201904/1592114-20190405173856214-1692474303.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.sc实现把administrator提升为system  &lt;span&gt;可在xp、win2003、win7、win8等上使用&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.1sc create yycmd binPath= &quot;cmd /k start&quot;  type= own type= interact   #注意“=”之后有空格  创建服务&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;sc start yycmd  启动创建的服务&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201904/1592114-20190405175212941-1126296094.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.2在win7测试，可以看到提示警告信息，但是还是以交互式模式打开了一个system权限的终端(&lt;span&gt;需要点击下图的“查看消息”)&lt;/span&gt;&lt;/span&gt;　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201904/1592114-20190405175753085-666438235.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;2.3点击上图的查看消息之后，就出现一个以system权限运行的 终端&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201904/1592114-20190405180050008-1383677827.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;2.4使用taskmgr命令打开任务管理器，杀死现用户桌面进程(explorer.exe)，新建explorer.exe，则整个界面都在管理员（因为当前的explorer进程实在system权限运行的）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201904/1592114-20190405180711649-1363396162.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.PsExec 实现把administrator提升为system    &lt;span&gt;#可以在xp、win2003、win7等系统使用&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;以有限的使用者权限执行处理程序&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;windows系统有提供一个套件:https://docs.microsoft.com/zh-cn/sysinternals/downloads/&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;切换到Psexec 所在目录然后执行 Psexec -I -s cmd    #-i交互模式，-s使用system账号&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201904/1592114-20190405190716781-921457287.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.Pinjecter注入进程提权  #&lt;span&gt;只能在xp、win2003中用&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.1切换到Pinjecter所在目录,查看所有进程的ID，找到要注入的进程   #选择system权限的进程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201904/1592114-20190405192811342-1768132593.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.2注入进程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201904/1592114-20190405192836637-265785932.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.3在kali中用nc连接注入的进程的端口&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201904/1592114-20190405192933897-108459554.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.4在win7测试，&lt;span&gt;当前是管理员然后运行程序提示拒绝访问&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201904/1592114-20190405194042317-1870610425.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;fgdump 【一个windows下的应用程序，kali集成】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;fgdump(kali /usr/share/windows-binaries) ，&lt;span&gt;从SAM文件中获取账户信息&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.以system权限运行fgdump(可以先把administrator提权为system，然后结束explorer.exe进程，创建新的explorer.exe,此时当前的整个系统都是system账户运行r然后双击fgdump或者把administrator提权为system，然后在具有system的终端中运行fgdump)，然后可以看到生成三个文件   #如果不以system权限运行fgdump的话，再打开pwdump里面是没有账户信息的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201904/1592114-20190405202138260-2141259326.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.查看pwdump文件可以看到账户信息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201904/1592114-20190405202526690-6403047.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Mimikatz&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Mimikatz   kali(usr/share/mimikatz)   #&lt;span&gt;只能获取处于登录状态的账户的密码,从内存中读取&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用双冒号查看命令模块和子模块　&lt;/span&gt;　&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201904/1592114-20190405203021038-288074484.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;privilege::debug  #提权到debug&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201904/1592114-20190405203132038-994264262.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;sekurlsa::logonPasswords  #查看登录账号密码信息,注意只能查看登录的账户的信息，未登录查看不到，因为是从内存中读取数据&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201904/1592114-20190405203321129-484616350.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;切换登陆另外的账户，然后测试&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201904/1592114-20190405203340851-1523438015.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; process::list 查看当前的所有进程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201904/1592114-20190405203649463-361901156.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;evnet::clear  清除安全日志&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201904/1592114-20190405204058759-1761830030.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;misc::  杂项&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201904/1592114-20190405204312055-836792394.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;token::&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201904/1592114-20190405204500596-1609515088.png&quot; alt=&quot;&quot;/&gt;　　&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Linux提权&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;dirty(脏牛)提权&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;inux内核在处理内存写时拷贝（Copy-on-Write）时存在条件竞争漏洞，导致可以破坏私有只读内存映射。一个低权限的本地用户能够利用此漏洞获取其他只读内存映射的写权限，有可能进一步导致提权漏洞。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;低权限用户可以利用该漏洞修改只读内存，进而执行任意代码获取 root权限。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.内核版本检测&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201904/1592114-20190405220426930-637810897.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.编译　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201904/1592114-20190405215922289-336108670.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.查看/etc/passwd文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201904/1592114-20190405220122335-992603297.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;4.登录利用脏牛漏洞修改的用户&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201904/1592114-20190405220201860-1202902027.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;5.恢复之前的/etc/passwd文件&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201904/1592114-20190405220259538-778419816.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 09 Apr 2019 16:09:00 +0000</pubDate>
<dc:creator>雨中落叶</dc:creator>
<og:description>kali权限提升之本地提权 系统账号之间权限隔离 操作系统的安全基础 用户空间 内核空间 系统账号： 用户账号登陆时候获取权限令牌 服务账号无需用户登录已在后台启动服务 windows用户全权限划分:</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuzly/p/10659643.html</dc:identifier>
</item>
<item>
<title>Odoo 堆积木似的软件构建 - 疯狂的代码搬运工</title>
<link>http://www.cnblogs.com/yanhuaqiang/p/10680691.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yanhuaqiang/p/10680691.html</guid>
<description>&lt;p&gt;七雄争霸秦国一统天下，统一货币度量衡，从此天下统一。。。&lt;/p&gt;
&lt;p&gt;假设在未来的某天，有一款开源的系统平台能将国内的企业管理软件市场进行统一，规范市场，标准开发，所有系统的集成创建通过市场开放的应用独立安装搭建，这将是一个很有意思的事！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1427856/201904/1427856-20190409235851417-498810941.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;odoo是什么鬼？&lt;/p&gt;
&lt;p&gt;关于odoo这里只做简单介绍，是一个开源ERP软件或者开发平台，具有saas和paas的运维支撑，所有系统模块都可以随意拆分独立安装，这当然可能得益于它的模块继承机制。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1427856/201904/1427856-20190409235921479-369901858.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;什么是堆积木？&lt;/p&gt;
&lt;p&gt;你可以想象孩子们玩的积木玩具，格式形状、颜色的积木，通过孩子的想象需求随意组合形成自己的目标建筑。未来的管理软件能否做成像积木一样的平台体系，用户按需构建，独立形成系统。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1427856/201904/1427856-20190409235945427-210488025.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;几个必要条件：&lt;/p&gt;
&lt;p&gt;第一：开源&lt;/p&gt;
&lt;p&gt;为什么要开源？相比于整个行业需求闭门造车似的开发显然是不能满足五花八门的业务场景，以开源的方式吸引更多开发者加入丰富组件库，良性的发展能不断的促进整个系统的进步与发展。&lt;/p&gt;
&lt;p&gt;第二：组件化&lt;/p&gt;
&lt;p&gt;任何一个功能都具有独立的系统分支。安装某个功能之后都可以继续通过安装组件升级完善功能。显然这是个难点，几乎不可能做到万能适用的组件化功能吧，所以只能靠丰富组件的种类来弥补通用的空缺，在组件库中总有一款适合你。在这方面，odoo是满足这种使用场景的。&lt;/p&gt;
&lt;p&gt;第三：平台&lt;/p&gt;
&lt;p&gt;为什么要有平台，平台将大家集合在一切，这是一个所有个人成果的展示，又是大家使用功能的来源。这点odoo也不是问题。&lt;/p&gt;
&lt;p&gt;第四：可行性&lt;/p&gt;
&lt;p&gt;几乎为零，但并不是没有可能。如果是发展，平台的运维势必需要相当大的开支，来源于开源社区的组件代码的合并想必也需要巨大的审核开支，这其中还需要严格制定标准的编码规范，如此等等，必须具有一个可持续发展的运营模式，不然无利不起早，结果很难搞！&lt;/p&gt;

&lt;p&gt;一顿瞎琢磨，纯属个人想法。&lt;/p&gt;

</description>
<pubDate>Tue, 09 Apr 2019 16:00:00 +0000</pubDate>
<dc:creator>疯狂的代码搬运工</dc:creator>
<og:description>七雄争霸秦国一统天下，统一货币度量衡，从此天下统一。。。 假设在未来的某天，有一款开源的系统平台能将国内的企业管理软件市场进行统一，规范市场，标准开发，所有系统的集成创建通过市场开放的应用独立安装搭建</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yanhuaqiang/p/10680691.html</dc:identifier>
</item>
<item>
<title>机器学习——KMeans聚类，KMeans原理，参数详解 - Baby-Lily</title>
<link>http://www.cnblogs.com/baby-lily/p/10680617.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/baby-lily/p/10680617.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;0.聚类&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;聚类就是对大量的未知标注的数据集，按数据的内在相似性将数据集划分为多个类别，使类别内的数据相似度较大而类别间的数据相似度较小，聚类属于无监督的学习方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.内在相似性的度量&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;聚类是根据数据的内在的相似性进行的，那么我们应该怎么定义数据的内在的相似性呢？比较常见的方法是根据数据的相似度或者距离来定义的，比较常见的有：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;闵可夫斯基距离/欧式距离&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1636554/201904/1636554-20190409214154208-400803339.png&quot; alt=&quot;&quot; width=&quot;186&quot; height=&quot;60&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　上述距离公式中，当p=2时，就是欧式距离，当p=1时，就是绝对值的和，当p=正无穷时，这个距离变成了维度差最大的那个值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1636554/201904/1636554-20190409215345258-767533328.png&quot; alt=&quot;&quot; width=&quot;500&quot; height=&quot;175&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;杰卡德相似系数&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1636554/201904/1636554-20190409215511592-1817485801.png&quot; alt=&quot;&quot; width=&quot;182&quot; height=&quot;71&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;　一般是度量集合之间的相似性。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;余弦相似度&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1636554/201904/1636554-20190409215654709-513545051.png&quot; alt=&quot;&quot; width=&quot;125&quot; height=&quot;63&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;Pearson相似系数&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1636554/201904/1636554-20190409215826948-1536653766.png&quot; alt=&quot;&quot; width=&quot;417&quot; height=&quot;86&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　对于n维向量的夹角，根据余弦定理，可到：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1636554/201904/1636554-20190409220220406-2013527767.png&quot; alt=&quot;&quot; width=&quot;256&quot; height=&quot;87&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　又由相关系数的计算公式，可得：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1636554/201904/1636554-20190409220414527-828246643.png&quot; alt=&quot;&quot; width=&quot;484&quot; height=&quot;90&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;不难发现，相关系数就是将x，y坐标向量各自平移到原点后的夹角余弦。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;相对熵（K-L距离）&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1636554/201904/1636554-20190409220013069-155074314.png&quot; alt=&quot;&quot; width=&quot;343&quot; height=&quot;62&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.聚类的基本思想&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1.给定一个有N个对象的数据集，构造数据的K个簇，k&amp;lt;=n，并且满足下列条件：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　每一个簇至少包含一个对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　每一个对象属于且仅属于一个簇。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　将满足上述条件的K个簇称作一个合理划分。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 　　2.基本思想：对于给定的类别K，首先给定初始的划分，通过迭代改变样本和簇的隶属关系，使得每一次改进之后的划分方案都较前一次好。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.K-Means算法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;K-means算法，也被称为K-平均或K-均值，是一种广泛使用的聚类算法，或者成为其他聚类算法的基础。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　假定输入样本为S=x1, x2, ......, xm，则算法步骤为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　选择初始的k个类别中心，u1, u2, ......, uk。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　对于每个样本的xi，将其中标记为距离类别中心最近的类别，即：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1636554/201904/1636554-20190409221820526-353345690.png&quot; alt=&quot;&quot; width=&quot;277&quot; height=&quot;63&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　将每个类别中心更新为隶属该类别的所有样本的均值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1636554/201904/1636554-20190409221939211-964097120.png&quot; alt=&quot;&quot; width=&quot;209&quot; height=&quot;62&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　重复后面的两步，直到类别中心变化小于某阈值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;终止条件：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　迭代次数，簇中心变化率，最小平方误差MSE。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.K-Means的公式化解释&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　记K个簇中心为u1,u2,......,uk，每个簇的样本数目为N1,N2,......，Nk。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　使用平方误差作为目标函数：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1636554/201904/1636554-20190409222445883-1361041829.png&quot; alt=&quot;&quot; width=&quot;311&quot; height=&quot;61&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　该函数为关于u1,u2,......,uk的凸函数，计算其驻点，得：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1636554/201904/1636554-20190409222737592-680433178.png&quot; alt=&quot;&quot; width=&quot;404&quot; height=&quot;79&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;5.K-Means聚类方法总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;优点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;一种经典算法，简单，快速的聚类算法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　对于大数据集，该算法保持可伸缩性和高效率。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　当簇近似为高斯分布时，它的效果较好。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;缺点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;在簇的平均值可被定义的情况下才能使用，可能不适用某些情况。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　必须实现给出K(聚类的簇数目)，而且是初值敏感的，对于不同的初始值，可能会导致不同的结果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　不适合于发现非凸型的簇或者大小差别很大的簇。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　对噪声和孤立点数据敏感。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在很多情况下，可以作为其他聚类的基础算法，比如谱聚类。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;6.代码示例&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;79&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     N = 400
&lt;span&gt; 3&lt;/span&gt;     centers = 4
&lt;span&gt; 4&lt;/span&gt;     data1, y1 = make_blobs(n_samples=N, n_features=2, centers= centers, random_state=2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     data2, y2 = make_blobs(n_samples=N, n_features=2, centers=centers, cluster_std=(1, 2.5, 0.5, 2), random_state=2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    plt.figure()
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     plt.plot(data1[:, 0], data1[:, 1], &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ro&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, data2[:, 0], data2[:, 1], &lt;span&gt;'&lt;/span&gt;&lt;span&gt;g*&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    plt.show()
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     data = np.vstack((data1[y1 == 0][:], data1[y1 == 1][:50], data1[y1 == 2][:20], data1[y1 == 3][:5&lt;span&gt;]))
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     y = np.array([0] * 100 + [1] * 50 + [2] * 20 + [3] * 5&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(data)&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(y)&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; plt.figure()&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; plt.plot(data[:100, 0], data[:100, 1], 'ro',&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;          data[100:150, 0], data[100:150, 1], 'g*',&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;          data[150:170, 0], data[150:170, 1], 'b*',&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;          data[170:175, 0], data[170:175, 1], 'k*')&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; plt.show()&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;     cls = KMeans(n_clusters=4, init=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;k-means++&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     y1_hat =&lt;span&gt; cls.fit_predict(data1)
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     y2_hat =&lt;span&gt; cls.fit_predict(data2)
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     y_hat =&lt;span&gt; cls.fit_predict(data)
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(y1_hat)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;KMeans函数的参数详解：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;n_clusters&lt;/strong&gt;：整型，缺省值=8 ，生成的聚类数。&lt;br/&gt;　　&lt;strong&gt;max_iter&lt;/strong&gt;：整型，缺省值=300 。&lt;br/&gt;　　　　执行一次k-means算法所进行的最大迭代数。&lt;br/&gt;　　&lt;strong&gt;n_init&lt;/strong&gt;：整型，缺省值=10 。&lt;br/&gt;　　　　　 用不同的聚类中心初始化值运行算法的次数，最终解是在inertia意义下选出的最优结果。&lt;br/&gt;　　&lt;strong&gt;init&lt;/strong&gt;：有三个可选值：’k-means++’， ‘random’，或者传递一个ndarray向量。&lt;br/&gt;　　　　 此参数指定初始化方法，默认值为 ‘k-means++’。&lt;br/&gt;　　　　（１）‘k-means++’ 用一种特殊的方法选定初始聚类中发，可加速迭代过程的收敛。&lt;br/&gt;　　　　（２）‘random’ 随机从训练数据中选取初始质心。&lt;br/&gt;　　　　（３）如果传递的是一个ndarray，则应该形如 (n_clusters, n_features) 并给出初始质心。&lt;br/&gt;　　&lt;strong&gt;precompute_distances&lt;/strong&gt;：三个可选值，‘auto’，True 或者 False。&lt;br/&gt;　　　　预计算距离，计算速度更快但占用更多内存。&lt;br/&gt;　　　　（１）‘auto’：如果 样本数乘以聚类数大于 12million 的话则不预计算距离。&lt;br/&gt;　　　　（２）True：总是预先计算距离。&lt;br/&gt;　　　　（３）False：永远不预先计算距离。&lt;br/&gt;　　&lt;strong&gt;tol&lt;/strong&gt;：float类型，默认值= 1e-4　与inertia结合来确定收敛条件。&lt;br/&gt;　　&lt;strong&gt;n_jobs&lt;/strong&gt;：整形数。　指定计算所用的进程数。内部原理是同时进行n_init指定次数的计算。&lt;br/&gt;　　　　（１）若值为 -1，则用所有的CPU进行运算。若值为1，则不进行并行运算。&lt;br/&gt;　　　　（２）若值小于-1，则用到的CPU数为(n_cpus + 1 + n_jobs)。因此如果 n_jobs值为-2，则用到的CPU数为总CPU数减1。&lt;br/&gt;　　&lt;strong&gt;random_state&lt;/strong&gt;：整型或 numpy.RandomState 类型，可选&lt;br/&gt;　　　　　用于初始化质心的生成器（generator）。如果值为一个整数，则确定一个seed。此参数默认值为numpy的随机数生成器。&lt;br/&gt;　　&lt;strong&gt;copy_x&lt;/strong&gt;：布尔型，默认值=True 　　&lt;br/&gt;　　　　　　 当我们precomputing distances时，将数据中心化会得到更准确的结果。如果把此参数值设为True，则原始数据不会被改变。如果是False，则会直接在原始数据&lt;br/&gt;　　　　　　上做修改并在函数返回值时将其还原。但是在计算过程中由于有对数据均值的加减运算，所以数据返回后，原始数据和计算前可能会有细小差别。&lt;br/&gt;聚类结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1636554/201904/1636554-20190409231853190-746838104.png&quot; alt=&quot;&quot; width=&quot;725&quot; height=&quot;201&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在聚类的过程中，我们发现，如果对数据进行一定的变化，得到的聚类结果可能有所不同，比如旋转。&lt;/p&gt;

</description>
<pubDate>Tue, 09 Apr 2019 15:36:00 +0000</pubDate>
<dc:creator>Baby-Lily</dc:creator>
<og:description>0.聚类 聚类就是对大量的未知标注的数据集，按数据的内在相似性将数据集划分为多个类别，使类别内的数据相似度较大而类别间的数据相似度较小，聚类属于无监督的学习方法。 1.内在相似性的度量 聚类是根据数据</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/baby-lily/p/10680617.html</dc:identifier>
</item>
<item>
<title>（三）neo4j的安装配置 - 一般的斑鸠</title>
<link>http://www.cnblogs.com/zhanglf4498/p/10680611.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhanglf4498/p/10680611.html</guid>
<description>&lt;p&gt;&lt;strong&gt;（一）neo4j安装&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;neo4j有社区版本和企业版，社区版本是免费的，企业版本是收费的。在linux上安装如下步骤：&lt;/p&gt;
&lt;p&gt;1、将下载的neo4j-enterprise-3.4.0-unix.tar.gz包上传到linux服务器，并解压。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;2、设置$NEO4J_HOME也就是解压图数据库安装包所在的目录到~/.bash_profile文件中&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;3、neo4j用户的文件句柄数：vim /etc/security/limits.conf&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;neo4j   soft    nofile  40000&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;neo4j   hard    nofile  40000&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;4、修改conf图数据库配置文件，设置远程可访问。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;dbms.connectors.default_listen_address=0.0.0.0&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;5、修改conf图数据库配置文件，修改数据库http端口和bolt端口,这里端口自己确定&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;dbms.connector.http.listen_address=ip&lt;strong&gt;:21003&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;dbms.connector.bolt.listen_address=ip&lt;strong&gt;:21002&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;6、修改文件/etc/pam.d/su&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;session    required   pam_limits.so&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;7、启动neo4j&lt;/p&gt;
&lt;p&gt;到$NEO4J_HOME的bin目录下执行以下命令启动图数据库：&lt;/p&gt;
&lt;p&gt;sh neo4j.sh start&lt;/p&gt;
&lt;p&gt;启动完成结构如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/571282/201904/571282-20190409232830137-1744176229.png&quot; alt=&quot;&quot; width=&quot;667&quot; height=&quot;209&quot;/&gt;&lt;/p&gt;

&lt;p&gt;8、验证是否启动，在浏览器中输入http://ip:21003/browser&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/571282/201904/571282-20190409232705332-580785925.png&quot; alt=&quot;&quot; width=&quot;723&quot; height=&quot;288&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 完！！！&lt;/p&gt;

</description>
<pubDate>Tue, 09 Apr 2019 15:30:00 +0000</pubDate>
<dc:creator>一般的斑鸠</dc:creator>
<og:description>（一）neo4j安装 neo4j有社区版本和企业版，社区版本是免费的，企业版本是收费的。在linux上安装如下步骤： 1、将下载的neo4j-enterprise-3.4.0-unix.tar.gz包</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhanglf4498/p/10680611.html</dc:identifier>
</item>
</channel>
</rss>