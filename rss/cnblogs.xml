<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>2021-2-18：请你说说MySQL的字符集与排序规则对开发有哪些影响？ - 干货满满张哈希</title>
<link>http://www.cnblogs.com/zhxdick/p/14410495.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhxdick/p/14410495.html</guid>
<description>&lt;p&gt;任何计算机存储数据，都需要&lt;strong&gt;字符集&lt;/strong&gt;，因为计算机存储的数据其实都是二进制编码，将一个个字符，映射到对应的二进制编码的这个映射就是字符编码（字符集）。这些字符如何排序呢？决定字符排序的规则就是&lt;strong&gt;排序规则&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;通过&lt;code&gt;show charset;&lt;/code&gt;命令，可以查看所有的字符集。&lt;br/&gt;以下仅展示了我们常用的字符集：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;+----------+---------------------------------+---------------------+--------+
| Charset  | Description                     | Default collation   | Maxlen |
+----------+---------------------------------+---------------------+--------+
| latin1   | cp1252 West European            | latin1_swedish_ci   |      1 |
| ascii    | US ASCII                        | ascii_general_ci    |      1 |
| gb2312   | GB2312 Simplified Chinese       | gb2312_chinese_ci   |      2 |
| cp1250   | Windows Central European        | cp1250_general_ci   |      1 |
| gbk      | GBK Simplified Chinese          | gbk_chinese_ci      |      2 |
| utf8     | UTF-8 Unicode                   | utf8_general_ci     |      3 |
| utf8mb4  | UTF-8 Unicode                   | utf8mb4_general_ci  |      4 |
| utf16    | UTF-16 Unicode                  | utf16_general_ci    |      4 |
| utf32    | UTF-32 Unicode                  | utf32_general_ci    |      4 |
+----------+---------------------------------+---------------------+--------+
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;ascii&lt;/code&gt;：共收录128个字符，包括空格、标点符号、数字、大小写字母和一些不可见字符。由于总共才128个字符，所以可以使用1个字节来进行编码&lt;/li&gt;
&lt;li&gt;&lt;code&gt;latin1&lt;/code&gt;：共收录256个字符，是在ASCII字符集的基础上又扩充了128个西欧常用字符(包括德法两国的字母)，也可以使用1个字节来进行编码。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gb2312&lt;/code&gt;: 收录了汉字以及拉丁字母、希腊字母、日文平假名及片假名字母、俄语西里尔字母。其中收录汉字6763个，其他文字符号682个，&lt;strong&gt;兼容ASCII字符集&lt;/strong&gt;。这是一个变长字符集，如果该字符在&lt;code&gt;ascii&lt;/code&gt;字符集中，则采用1字节编码，否则采用两字节。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gbk&lt;/code&gt;: GBK是在&lt;code&gt;gb2312&lt;/code&gt;基础上扩容后的标准。收录了所有的中文字符。同样的，这是一个变长字符集，如果该字符在&lt;code&gt;ascii&lt;/code&gt;字符集中，则采用1字节编码，否则采用两字节。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;utf8&lt;/code&gt;和&lt;code&gt;utf8mb4&lt;/code&gt;: 收录地球上能想到的所有字符，而且还在不断扩充。这种字符集兼容ASCII字符集，采用变长编码方式，编码一个字符需要使用1～4个字节。&lt;code&gt;MySQL&lt;/code&gt;为了节省空间，其中的&lt;code&gt;utf8&lt;/code&gt;是标准 UTF8 阉割后的，只有1~3字节编码的字符集，基本包含了所有常用的字符。如果还要使用 enoji 表情，那么需要使用&lt;code&gt;utf8mb4&lt;/code&gt;，这个是完整的 UTF8 字符集。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;utf16&lt;/code&gt;: 不同于&lt;code&gt;utf8&lt;/code&gt;，&lt;code&gt;utf16&lt;/code&gt;用两个字节或者四个字节编码字符，可以理解为&lt;code&gt;utf8&lt;/code&gt;的不节省空间的一种形式&lt;/li&gt;
&lt;li&gt;&lt;code&gt;utf32&lt;/code&gt;: 固定用四个字节编码字符，可以理解为&lt;code&gt;utf8&lt;/code&gt;的不节省空间的一种形式&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;通过查看&lt;code&gt;information_schema.character_sets&lt;/code&gt;表，也可以看到所有的字符集：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; select * from information_schema.character_sets where character_set_name = &quot;utf8&quot;;
+--------------------+----------------------+---------------+--------+
| CHARACTER_SET_NAME | DEFAULT_COLLATE_NAME | DESCRIPTION   | MAXLEN |
+--------------------+----------------------+---------------+--------+
| utf8               | utf8_general_ci      | UTF-8 Unicode |      3 |
+--------------------+----------------------+---------------+--------+
1 row in set (0.06 sec)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过&lt;code&gt;show collation;&lt;/code&gt;命令，可以查看所有的字符集，我们这里来查看&lt;code&gt;utf8mb4&lt;/code&gt;的排序规则：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; show collation like 'utf8mb4%';
+------------------------+---------+-----+---------+----------+---------+
| Collation              | Charset | Id  | Default | Compiled | Sortlen |
+------------------------+---------+-----+---------+----------+---------+
| utf8mb4_general_ci     | utf8mb4 |  45 | Yes     | Yes      |       1 |
| utf8mb4_bin            | utf8mb4 |  46 |         | Yes      |       1 |
| utf8mb4_unicode_ci     | utf8mb4 | 224 |         | Yes      |       8 |
| utf8mb4_icelandic_ci   | utf8mb4 | 225 |         | Yes      |       8 |
| utf8mb4_latvian_ci     | utf8mb4 | 226 |         | Yes      |       8 |
| utf8mb4_romanian_ci    | utf8mb4 | 227 |         | Yes      |       8 |
| utf8mb4_slovenian_ci   | utf8mb4 | 228 |         | Yes      |       8 |
| utf8mb4_polish_ci      | utf8mb4 | 229 |         | Yes      |       8 |
| utf8mb4_estonian_ci    | utf8mb4 | 230 |         | Yes      |       8 |
| utf8mb4_spanish_ci     | utf8mb4 | 231 |         | Yes      |       8 |
| utf8mb4_swedish_ci     | utf8mb4 | 232 |         | Yes      |       8 |
| utf8mb4_turkish_ci     | utf8mb4 | 233 |         | Yes      |       8 |
| utf8mb4_czech_ci       | utf8mb4 | 234 |         | Yes      |       8 |
| utf8mb4_danish_ci      | utf8mb4 | 235 |         | Yes      |       8 |
| utf8mb4_lithuanian_ci  | utf8mb4 | 236 |         | Yes      |       8 |
| utf8mb4_slovak_ci      | utf8mb4 | 237 |         | Yes      |       8 |
| utf8mb4_spanish2_ci    | utf8mb4 | 238 |         | Yes      |       8 |
| utf8mb4_roman_ci       | utf8mb4 | 239 |         | Yes      |       8 |
| utf8mb4_persian_ci     | utf8mb4 | 240 |         | Yes      |       8 |
| utf8mb4_esperanto_ci   | utf8mb4 | 241 |         | Yes      |       8 |
| utf8mb4_hungarian_ci   | utf8mb4 | 242 |         | Yes      |       8 |
| utf8mb4_sinhala_ci     | utf8mb4 | 243 |         | Yes      |       8 |
| utf8mb4_german2_ci     | utf8mb4 | 244 |         | Yes      |       8 |
| utf8mb4_croatian_ci    | utf8mb4 | 245 |         | Yes      |       8 |
| utf8mb4_unicode_520_ci | utf8mb4 | 246 |         | Yes      |       8 |
| utf8mb4_vietnamese_ci  | utf8mb4 | 247 |         | Yes      |       8 |
+------------------------+---------+-----+---------+----------+---------+
26 rows in set (0.13 sec)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同样的，通过查询&lt;code&gt;information_schema.collations&lt;/code&gt;也可以：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; select * from information_schema.collations where character_set_name = &quot;utf8mb4&quot;;
+------------------------+--------------------+-----+------------+-------------+---------+
| COLLATION_NAME         | CHARACTER_SET_NAME | ID  | IS_DEFAULT | IS_COMPILED | SORTLEN |
+------------------------+--------------------+-----+------------+-------------+---------+
| utf8mb4_general_ci     | utf8mb4            |  45 | Yes        | Yes         |       1 |
| utf8mb4_bin            | utf8mb4            |  46 |            | Yes         |       1 |
| utf8mb4_unicode_ci     | utf8mb4            | 224 |            | Yes         |       8 |
| utf8mb4_icelandic_ci   | utf8mb4            | 225 |            | Yes         |       8 |
| utf8mb4_latvian_ci     | utf8mb4            | 226 |            | Yes         |       8 |
| utf8mb4_romanian_ci    | utf8mb4            | 227 |            | Yes         |       8 |
| utf8mb4_slovenian_ci   | utf8mb4            | 228 |            | Yes         |       8 |
| utf8mb4_polish_ci      | utf8mb4            | 229 |            | Yes         |       8 |
| utf8mb4_estonian_ci    | utf8mb4            | 230 |            | Yes         |       8 |
| utf8mb4_spanish_ci     | utf8mb4            | 231 |            | Yes         |       8 |
| utf8mb4_swedish_ci     | utf8mb4            | 232 |            | Yes         |       8 |
| utf8mb4_turkish_ci     | utf8mb4            | 233 |            | Yes         |       8 |
| utf8mb4_czech_ci       | utf8mb4            | 234 |            | Yes         |       8 |
| utf8mb4_danish_ci      | utf8mb4            | 235 |            | Yes         |       8 |
| utf8mb4_lithuanian_ci  | utf8mb4            | 236 |            | Yes         |       8 |
| utf8mb4_slovak_ci      | utf8mb4            | 237 |            | Yes         |       8 |
| utf8mb4_spanish2_ci    | utf8mb4            | 238 |            | Yes         |       8 |
| utf8mb4_roman_ci       | utf8mb4            | 239 |            | Yes         |       8 |
| utf8mb4_persian_ci     | utf8mb4            | 240 |            | Yes         |       8 |
| utf8mb4_esperanto_ci   | utf8mb4            | 241 |            | Yes         |       8 |
| utf8mb4_hungarian_ci   | utf8mb4            | 242 |            | Yes         |       8 |
| utf8mb4_sinhala_ci     | utf8mb4            | 243 |            | Yes         |       8 |
| utf8mb4_german2_ci     | utf8mb4            | 244 |            | Yes         |       8 |
| utf8mb4_croatian_ci    | utf8mb4            | 245 |            | Yes         |       8 |
| utf8mb4_unicode_520_ci | utf8mb4            | 246 |            | Yes         |       8 |
| utf8mb4_vietnamese_ci  | utf8mb4            | 247 |            | Yes         |       8 |
+------------------------+--------------------+-----+------------+-------------+---------+
26 rows in set (0.11 sec)
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;每个字符集都有一个默认的排序规则：IS_DEFAULT 为 Yes。&lt;/li&gt;
&lt;li&gt;比较规则名称以与其关联的字符集的名称开头，可以用通过这个开头查询所有的字符集，也可以查询&lt;code&gt;information_schema.collations&lt;/code&gt;精确指定字符集&lt;/li&gt;
&lt;li&gt;字符集后面跟着的是语言编码，因为&lt;code&gt;utf8mb4&lt;/code&gt;包含了所有字符，不同国家的文字语言排序肯定不一样。&lt;/li&gt;
&lt;li&gt;最后末尾的&lt;code&gt;ci&lt;/code&gt;代表&lt;code&gt;case insensitive&lt;/code&gt;，大小写不敏感，所有可能的后缀如下所示：
&lt;ul&gt;&lt;li&gt;ai: accent insensitive 不区分重音&lt;/li&gt;
&lt;li&gt;as: accent sensitive 区分重音&lt;/li&gt;
&lt;li&gt;ci: case insensitive 不区分大小写&lt;/li&gt;
&lt;li&gt;cs: case sensitive 区分大小写&lt;/li&gt;
&lt;li&gt;bin: binary 以二进制方式比较&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;字符集与比较规则配置有四个级别：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;MySQL实例级别&lt;/li&gt;
&lt;li&gt;库级别&lt;/li&gt;
&lt;li&gt;表级别&lt;/li&gt;
&lt;li&gt;字段级别&lt;br/&gt;&lt;strong&gt;指定的级别粒度越小，则以粒度越小的字符集还有比较规则优先&lt;/strong&gt;。例如指定MySQL实例级别字符集是&lt;code&gt;utf8mb4&lt;/code&gt;，指定某个表字符集是&lt;code&gt;latin1&lt;/code&gt;，那么这个表的所有字段如果不指定的话，编码就是&lt;code&gt;latin1&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;由于字符集和比较规则是互相有联系的，如果我们只修改了字符集，比较规则也会跟着变化，如果只修改了比较规则，字符集也会跟着变化，具体规则如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;只修改字符集，则比较规则将变为修改后的字符集默认的比较规则。&lt;/li&gt;
&lt;li&gt;只修改比较规则，则字符集将变为修改后的比较规则对应的字符集。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;实例级别&quot;&gt;实例级别&lt;/h2&gt;
&lt;p&gt;通过两个系统变量来指定实例级别的字符集与排序规则。&lt;/p&gt;
&lt;p&gt;配置文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[server]
character_set_server=utf8mb4
collation_server=utf8mb4_general_ci
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动之后，可以查看并修改这两个变量。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt;  show variables like 'character_set_server';
+----------------------+---------+
| Variable_name        | Value   |
+----------------------+---------+
| character_set_server | utf8mb4 |
+----------------------+---------+
1 row in set (0.06 sec)

mysql&amp;gt; show variables like 'collation_server';
+------------------+--------------------+
| Variable_name    | Value              |
+------------------+--------------------+
| collation_server | utf8mb4_general_ci |
+------------------+--------------------+
1 row in set (0.05 sec)

mysql&amp;gt; set character_set_server = 'utf8mb4';
Query OK, 0 rows affected (0.00 sec)

mysql&amp;gt; set collation_server = 'utf8mb4_general_ci';
Query OK, 0 rows affected (0.00 sec)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;库级别&quot;&gt;库级别&lt;/h2&gt;
&lt;p&gt;创建数据库的时候，可以指定字符集还有排序规则。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; create database test_db character set utf8mb4 collate utf8mb4_general_ci;
Query OK, 1 row affected (0.01 sec)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不指定的话，就用实例级别的字符集还有排序规则。&lt;/p&gt;
&lt;p&gt;查看当前数据库的字符集还有排序规则则是通过&lt;code&gt;use&lt;/code&gt;命令指定数据库之后，查看&lt;code&gt;character_set_database&lt;/code&gt;变量以及&lt;code&gt;collation_database&lt;/code&gt; 来实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; show variables like 'character_set_database';
+------------------------+---------+
| Variable_name          | Value   |
+------------------------+---------+
| character_set_database | utf8mb4 |
+------------------------+---------+
1 row in set (0.07 sec)

mysql&amp;gt; show variables like 'collation_database';
+--------------------+--------------------+
| Variable_name      | Value              |
+--------------------+--------------------+
| collation_database | utf8mb4_general_ci |
+--------------------+--------------------+
1 row in set (0.09 sec)

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;就算设置这两个变量，也是无效的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; set character_set_database = 'utf8';
Query OK, 0 rows affected (0.00 sec)

mysql&amp;gt; show variables like 'character_set_database';
+------------------------+---------+
| Variable_name          | Value   |
+------------------------+---------+
| character_set_database | utf8mb4 |
+------------------------+---------+
1 row in set (0.09 sec)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改数据库的字符集还有排序规则的方式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; alter database test_db character set = 'utf8';
Query OK, 1 row affected (0.01 sec)

mysql&amp;gt; show variables like 'character_set_database';
+------------------------+-------+
| Variable_name          | Value |
+------------------------+-------+
| character_set_database | utf8  |
+------------------------+-------+
1 row in set (0.08 sec)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个更新只会对新建的表如果没指定字符集和排序规则的生效，并不会更新老表的字符集还有排序规则。&lt;/p&gt;
&lt;h2 id=&quot;表级别&quot;&gt;表级别&lt;/h2&gt;
&lt;p&gt;可以在创建时指定字符集合排序规则，不指定的话，用数据库的字符集还有排序规则，也可以修改字符集和排序规则。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
mysql&amp;gt; create table test (name varchar(32)) character set utf8mb4 collate utf8mb4_bin; 
Query OK, 0 rows affected (0.04 sec)

mysql&amp;gt; show create table test;
+-------+---------------------------------------------------------------------------------------------------------------------------------------+
| Table | Create Table                                                                                                                          |
+-------+---------------------------------------------------------------------------------------------------------------------------------------+
| test  | CREATE TABLE `test` (
  `name` varchar(32) COLLATE utf8mb4_bin DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin |
+-------+---------------------------------------------------------------------------------------------------------------------------------------+
1 row in set (0.09 sec)

mysql&amp;gt; alter table test character set = 'utf8';
Query OK, 0 rows affected (0.02 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql&amp;gt; show create table test;
+-------+--------------------------------------------------------------------------------------------------------------------------------------+
| Table | Create Table                                                                                                                         |
+-------+--------------------------------------------------------------------------------------------------------------------------------------+
| test  | CREATE TABLE `test` (
  `name` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8 |
+-------+--------------------------------------------------------------------------------------------------------------------------------------+
1 row in set (0.06 sec)

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看出，仅仅是表的字符集还有排序规则变了，对于已有字段，并没有改变编码和排序规则。&lt;/p&gt;
&lt;h2 id=&quot;列级别&quot;&gt;列级别&lt;/h2&gt;
&lt;p&gt;可以在创建表的时候，指定不同的列有不同的字符集和排序规则，也可以修改列的字符集和排序规则：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; create table test (name varchar(32) character set utf8 collate utf8_bin) character set utf8mb4 collate utf8mb4_bin; 
Query OK, 0 rows affected (0.03 sec)

mysql&amp;gt; show create table test;
+-------+-------------------------------------------------------------------------------------------------------------------------------------------------------+
| Table | Create Table                                                                                                                                          |
+-------+-------------------------------------------------------------------------------------------------------------------------------------------------------+
| test  | CREATE TABLE `test` (
  `name` varchar(32) CHARACTER SET utf8 COLLATE utf8_bin DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin |
+-------+-------------------------------------------------------------------------------------------------------------------------------------------------------+
1 row in set (0.09 sec)

mysql&amp;gt; alter table test modify column name  varchar(32) COLLATE latin1_bin;
Query OK, 0 rows affected (0.09 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql&amp;gt; show create table test;
+-------+-----------------------------------------------------------------------------------------------------------------------------------------------------------+
| Table | Create Table                                                                                                                                              |
+-------+-----------------------------------------------------------------------------------------------------------------------------------------------------------+
| test  | CREATE TABLE `test` (
  `name` varchar(32) CHARACTER SET latin1 COLLATE latin1_bin DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin |
+-------+-----------------------------------------------------------------------------------------------------------------------------------------------------------+
1 row in set (0.09 sec)
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;有时候，我们会遇到字符编码不一致导致的程序问题。例如我们的 Java 程序，使用 jdbc 链接。读取的数据，打印出来是乱码。或者是，MySQL 无法识别我们客户端发来的命令。这涉及到字符编码问题。&lt;strong&gt;我们需要保持 Java 程序的字符编码与 JDBC 链接指定的字符编码一致，这样才不会有乱码的问题。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;指定 Java 程序编码&lt;/strong&gt;：通过启动参数：&lt;code&gt;-Dfile.encoding=UTF-8&lt;/code&gt; 设置默认的字符编码（&lt;code&gt;java.nio.charset.Charset.defaultCharset();&lt;/code&gt;）是&lt;code&gt;utf-8&lt;/code&gt;（对应 MySQL 的&lt;code&gt;utf8&lt;/code&gt;还有&lt;code&gt;utf8mb4&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;指定 JDBC 链接编码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;jdbc:mysql://127.0.0.1:3306/test?characterEncoding=utf8
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;mysql客户端命令行指定字符集&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql -h 127.0.0.1 -P 3306 -u root  --default-character-set=utf8mb4  -p
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;之后查看有关编码的环境变量，都是和设置的这个字符集一样。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; SHOW VARIABLES LIKE 'character_set_client';
+----------------------+---------+
| Variable_name        | Value   |
+----------------------+---------+
| character_set_client | utf8mb4 |
+----------------------+---------+
1 row in set, 1 warning (0.00 sec)

mysql&amp;gt; SHOW VARIABLES LIKE 'character_set_connection';
+--------------------------+---------+
| Variable_name            | Value   |
+--------------------------+---------+
| character_set_connection | utf8mb4 |
+--------------------------+---------+
1 row in set, 1 warning (0.00 sec)

mysql&amp;gt; SHOW VARIABLES LIKE 'character_set_results';
+-----------------------+---------+
| Variable_name         | Value   |
+-----------------------+---------+
| character_set_results | utf8mb4 |
+-----------------------+---------+
1 row in set, 1 warning (0.00 sec)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;character_set_client&lt;/code&gt;: 服务器解码请求时使用的字符集&lt;/li&gt;
&lt;li&gt;&lt;code&gt;character_set_connection&lt;/code&gt;：服务器处理请求时将字符集转换成这个字符集处理。操作具体列时，在转换为具体列的编码。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;character_set_results&lt;/code&gt;:服务器向客户端返回数据时使用的字符集&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;MySQL 设计这三个编码的时候，出于以下考虑：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一个 MySQL，可能有多种不同语言和操作系统或者国家的客户端，所以通过设置&lt;code&gt;character_set_client&lt;/code&gt;还有&lt;code&gt;character_set_results&lt;/code&gt;进行兼容。&lt;/li&gt;
&lt;li&gt;由于操作具体列数据的时候需要编码转换，如果&lt;code&gt;character_set_connection&lt;/code&gt;和字段一致的话，就不用转换了，所以设置&lt;code&gt;character_set_connection&lt;/code&gt;可以让 MySQL 用一种编码理解命令统一处理，同时设置&lt;code&gt;character_set_connection&lt;/code&gt;为最常用的可以减少转换。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;一般情况下，保持这三个一致就好。我们就设置好连接使用的字符集就行了。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;微信搜索“我的编程喵”关注公众号，每日一刷，轻松提升技术，斩获各种offer&lt;/strong&gt;：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://zhxhash-blog.oss-cn-beijing.aliyuncs.com/qr-code.jpg&quot; alt=&quot;image&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 18 Feb 2021 00:25:00 +0000</pubDate>
<dc:creator>干货满满张哈希</dc:creator>
<og:description>任何计算机存储数据，都需要字符集，因为计算机存储的数据其实都是二进制编码，将一个个字符，映射到对应的二进制编码的这个映射就是字符编码（字符集）。这些字符如何排序呢？决定字符排序的规则就是排序规则。 查</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhxdick/p/14410495.html</dc:identifier>
</item>
<item>
<title>RT-Thread学习笔记2-互斥量与信号量 - CrazyCatJack</title>
<link>http://www.cnblogs.com/CrazyCatJack/p/14408842.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CrazyCatJack/p/14408842.html</guid>
<description>&lt;hr/&gt;&lt;h2 id=&quot;1-临界区保护&quot;&gt;1. 临界区保护&lt;/h2&gt;
&lt;p&gt;临界区是仅允许一个线程访问的共享资源。它可以是一个具体的硬件设备，也可以是一个变量、一个缓冲区。多个线程必须互斥的对他们进行访问&lt;/p&gt;
&lt;h3 id=&quot;11-方法一：关闭系统调度保护临界区&quot;&gt;1.1 方法一：关闭系统调度保护临界区&lt;/h3&gt;
&lt;p&gt;禁止调度&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/* 调度器商锁，上锁后不再切换到其他线程，仅响应中断 */
rt_enter_critical();
/* 临界操作 */
rt_exit_critical();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关闭中断：因为所有的线程的调度都是建立在中断的基础上的，所以当关闭中断后系统将不能再进行调度，线程自身也自然不会被其他线程抢占了&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;rt_base_t level;
/* 关闭中断 */
level = rt_hw_interrupt_disable();
/* 临界操作 */
rt_hw_interrupt_enable(level);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;12-方法二：互斥特性保护临界区&quot;&gt;1.2 方法二：互斥特性保护临界区&lt;/h3&gt;
&lt;p&gt;信号量、互斥量&lt;/p&gt;
&lt;h2 id=&quot;2-信号量&quot;&gt;2. 信号量&lt;/h2&gt;
&lt;p&gt;嵌入式系统运行的代码主要包括线程和ISR，在它们的运行过程中，它们的运行步骤有时需要同步（按照预定的先后次序运行），有时访问的资源需要互斥（一个时刻只允许一个线程访问资源），有时也需要比本次交换数据。这些机制成为进程间通信IPC。RT-Thread中的IPC机制包括信号量、互斥量、事件、邮箱、消息队列。通过IPC，可以协调多个线程（包括ISR）默契的工作。信号量是一种轻型的用于解决线程间同步问题的内核对象，线程可以获取或释放它，从而达到同步或互斥的目的。每个信号量对象都有一个信号量值和一个线程等待队列。信号量的值对应信号量对象的实例数目（资源数目），如果信号量值N，则表示有N个信号量实例（资源）可被使用。当值为0时，再请求该信号量的的线程，就会被挂起在该信号量的等待队列上。&lt;/p&gt;
&lt;h3 id=&quot;21-信号量的定义&quot;&gt;2.1 信号量的定义&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;struct rt_semaphore
{
    struct rt_ipc_object parent; /* IPC对象继承而来 */
    rt_uint16_t value; /* 信号量的值 */
}

静态信号量：struct rt_semaphore static_sem
动态信号量：rt_sem_t dynamic_sem

typedef struct rt_semaphore *rt_sem_t;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;22-信号量的操作&quot;&gt;2.2 信号量的操作&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;初始化与脱离&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;静态信号量：
rt_err_t rt_sem_init(rt_sem_t sem, const char *name, rt_uint32_t value, rt_uint8_t flag)
rt_err_t rt_sem_detach(rt_sem_t sem) //将不用的静态信号量从系统中脱离
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;创建与删除&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;判断一下返回值是不是RT_NULL
动态信号量：
rt_sem_t rt_sem_create(const char *name, rt_uint32_t value, rt_uint8_t flag) //等待队列中的线程，当有资源的时候： RT_IPC_FLAG_FIFO先来先服务，先后顺序排列 RT_IPC_FLAG_PRIO按照线程优先级排列
rt_err_t rt_sem_delete(rt_sem_t sem)//释放系统资源
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;获取信号量&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;rt_err_t rt_sem_take(rt_sem_t sem, rt_int32_t time) //RT_WAITING_FOREVER = -1, 以系统滴答时钟为单位。即100HZ，等待10ms的倍数。如果超时则返回-RT_ETIMEOUT.切忌该函数不可在中断中调用，因为它会导致线程被挂起。只能在线程调用
rt_err_t rt_sem_trytake(rt_sem_t sem) //时间参数为0，一秒钟都不等待
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;释放信号量&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;rt_err_t rt_sem_release(rt_sem_t sem) // 既可以在线程，也可以在中断中调用。因为它不会导致线程被挂起
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;3-生产者、消费者问题&quot;&gt;3. 生产者、消费者问题&lt;/h2&gt;
&lt;p&gt;两个线程，一个生产者线程和一个消费者线程，两个线程共享一个初始为空、固定大小为n的缓存区。生产者的工作是生产一段数据，只有缓冲区没满时，生产者才能把消息放入到缓冲区，否则必须等待，如此反复。只有缓冲区非空时，消费者才能从中取出数据，一次消费一段数据，否则必须等待。问题的核心是：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;保证不让生产者在缓存还是满的时候仍然要向内写数据&lt;/li&gt;
&lt;li&gt;不让消费者试图从空的缓存中取出数据&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;解决生产者消费者问题实际上是要解决线程间互斥关系和同步关系问题。由于缓冲区是临界资源，一个时刻只允许&lt;mark&gt;一个生产者放入消息，或者一个消费者从中取出消息&lt;/mark&gt;。这里需要解决一个互斥访问的问题。同时生产者和消费者又是一个相互协作的关系，只有生产者生产之后，消费者才能消费，所以还需要解决一个同步的问题&lt;br/&gt;&lt;a href=&quot;https://imgchr.com/i/BballV&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/11/09/BballV.png&quot; alt=&quot;BballV.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/* 生成者线程入口 */
void producer_thread_entry(void* parameter)
{
    int cnt = 0;

    /* 运行100次 */
    while( cnt &amp;lt; 100)
    {
        /* 获取一个空位 */
        rt_sem_take(&amp;amp;sem_empty, RT_WAITING_FOREVER);

        /* 修改array内容，上锁 */
        rt_sem_take(&amp;amp;sem_lock, RT_WAITING_FOREVER);
        array[set%MAXSEM] = cnt + 1;
        rt_kprintf(&quot;the producer generates a number: %d\n&quot;, array[set%MAXSEM]);
        set++;
        rt_sem_release(&amp;amp;sem_lock);

        /* 发布一个满位 */
        rt_sem_release(&amp;amp;sem_full);
        cnt++;

        /* 暂停一段时间 */
        rt_thread_delay(50);
    }

    rt_kprintf(&quot;the producer exit!\n&quot;);
}

/* 消费者线程入口 */
void consumer_thread_entry(void* parameter)
{
    rt_uint32_t no;
    rt_uint32_t sum;

    /* 第n个线程，由入口参数传进来 */
    no = (rt_uint32_t)parameter;

    sum = 0;
    while(1)
    {
        /* 获取一个满位 */
        rt_sem_take(&amp;amp;sem_full, RT_WAITING_FOREVER);

        /* 临界区，上锁进行操作 */
        rt_sem_take(&amp;amp;sem_lock, RT_WAITING_FOREVER);
        sum += array[get%MAXSEM];
        rt_kprintf(&quot;the consumer[%d] get a number: %d\n&quot;, no, array[get%MAXSEM] );
        get++;
        rt_sem_release(&amp;amp;sem_lock);

        /* 释放一个空位 */
        rt_sem_release(&amp;amp;sem_empty);

        /* 生产者生产到100个数目，停止，消费者线程相应停止 */
        if (get == 100) break;

        /* 暂停一小会时间 */
        rt_thread_delay(10);
    }

    rt_kprintf(&quot;the consumer[%d] sum is %d \n &quot;, no, sum);
    rt_kprintf(&quot;the consumer[%d] exit!\n&quot;);
}

int semaphore_producer_consumer_init()
{
    /* 初始化3个信号量 */
    rt_sem_init(&amp;amp;sem_lock , &quot;lock&quot;,     1,      RT_IPC_FLAG_FIFO);
    rt_sem_init(&amp;amp;sem_empty, &quot;empty&quot;,    MAXSEM, RT_IPC_FLAG_FIFO);
    rt_sem_init(&amp;amp;sem_full , &quot;full&quot;,     0,      RT_IPC_FLAG_FIFO);

    /* 创建线程1 */
    producer_tid = rt_thread_create(&quot;producer&quot;,
                                    producer_thread_entry, RT_NULL, /* 线程入口是producer_thread_entry, 入口参数是RT_NULL */
                                    THREAD_STACK_SIZE, THREAD_PRIORITY - 1, THREAD_TIMESLICE);
    if (producer_tid != RT_NULL)
        rt_thread_startup(producer_tid);
    else
        tc_stat(TC_STAT_END | TC_STAT_FAILED);

    /* 创建线程2 */
    consumer_tid = rt_thread_create(&quot;consumer&quot;,
                                    consumer_thread_entry, RT_NULL, /* 线程入口是consumer_thread_entry, 入口参数是RT_NULL */
                                    THREAD_STACK_SIZE, THREAD_PRIORITY + 1, THREAD_TIMESLICE);
    if (consumer_tid != RT_NULL)
        rt_thread_startup(consumer_tid);
    else
        tc_stat(TC_STAT_END | TC_STAT_FAILED);

    return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;4-互斥量&quot;&gt;4. 互斥量&lt;/h2&gt;
&lt;p&gt;互斥量控制块是操作系统用于管理互斥量的一个数据结构。&lt;/p&gt;
&lt;h3 id=&quot;41-互斥量控制块&quot;&gt;4.1 互斥量控制块&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;struct rt_mutex
{
    struct rt_ipc_object parent; /* IPC对象继承而来 */
    rt_uint16_t value; /* 只有LOCK和UNLOCK两种值 */
    rt_uint8_t original_priority; /* 上一次获得该锁的线程的优先级 */
    rt_uint8_t hold; /* 该线程获取了多少次该互斥锁 */
    struct rt_thread *owner; /* 当前拥有该锁的线程句柄 */
}

静态互斥量：struct rt_mutex static_mutex;
动态互斥量：rt_mutex_t dynamic_mutex;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;42-互斥量的操作&quot;&gt;4.2 互斥量的操作&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;初始化与脱离&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;静态互斥量
rt_err_t rt_mutex_init(rt_mutex_t mutex, const char *name, rt_uint8_t flag); //RT_IPC_FIFO RT_IPC_FLAG_PRIO
rt_err_t rt_mutex_detach(rt_mutex_t mutex);
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;创建与删除&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;动态互斥量
rt_mutex rt_mutex_create(const char *name, rt_uint8_t flag);
rt_err_t rt_mutex_delete(rt_mutex_t mutex);
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;获取互斥量&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;只能在线程中调用，且同一个线程能够take多次同一个互斥量，其成员hold+1
rt_err_t rt_mutex_take(rt_mutex_t mutex, rt_int32_t time) // RT_WAITING_FOREVER = -1
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;释放互斥量&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;只能在线程中调用，不能在中断中调用。必须同一个线程获取的同一个互斥量，才能在该线程释放该互斥量
rt_err_t rt_mutex_release(rt_mutex_t mutex)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;43-互斥量和信号量的差别&quot;&gt;4.3 互斥量和信号量的差别&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;信号量可以由任何线程（以及中断）释放，它用于同步的时候就像交通灯，线程只有在获得许可的时候，才能运行，强调的是运行步骤；互斥量只能由持有它的线程释放，即只有锁上它的哪个线程，才有钥匙打开它，强调的是许可和权限&lt;/li&gt;
&lt;li&gt;使用信号量可能导致优先级反转，互斥量可通过优先级集成的方法解决优先级反转问题&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;5-线程优先级翻转&quot;&gt;5. 线程优先级翻转&lt;/h2&gt;
&lt;p&gt;当一个高优先级线程试图通过某种互斥IPC对象机制访问共享资源时，如果该IPC对象已经被一个低优先级的线程所持有，而且这个低优先级线程运行过程中可能又被其他一些中等优先级的线程抢占，因此造成高优先级线程被许多具有较低优先级的线程阻塞的情况。导致高优先级的实时性得不到保证&lt;/p&gt;
&lt;h3 id=&quot;51-优先级继承&quot;&gt;5.1 优先级继承&lt;/h3&gt;
&lt;p&gt;在RT-Thread中，通过互斥量的优先级继承算法，可有有效解决优先级翻转问题。优先级继承是指提高某个占有某种共享资源的低优先级线程优先级，使之与&lt;mark&gt;所有等待该资源的线程中优先级最高的那个线程的优先级相等&lt;/mark&gt;，从而得到更快地执行然后释放共享资源，当这个低优先级线程释放该资源时，优先级重新回到初始设定值。继承优先级的线程，避免了系统共享资源被任何中间优先级的线程抢占&lt;/p&gt;
&lt;p&gt;优先级翻转线向提醒编程人员对共享资源进行互斥访问的代码段应&lt;mark&gt;尽量短&lt;/mark&gt;。让低优先级线程尽快完成工作，释放共享资源&lt;/p&gt;
&lt;h2 id=&quot;参考文献&quot;&gt;参考文献&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.rt-thread.org/page/video.html&quot; target=&quot;_blank&quot;&gt;RT-Thread视频中心内核入门&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.rt-thread.org/document/site/tutorial/quick-start/introduction/introduction/&quot; target=&quot;_blank&quot;&gt;RT-Thread文档中心&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;本文作者:&lt;/strong&gt; CrazyCatJack&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文链接:&lt;/strong&gt; &lt;a href=&quot;https://www.cnblogs.com/CrazyCatJack/p/14408842.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/CrazyCatJack/p/14408842.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;版权声明:&lt;/strong&gt;本博客所有文章除特别声明外，均采用 &lt;a href=&quot;https://creativecommons.org/licenses/by-nc-nd/4.0/&quot; target=&quot;_blank&quot;&gt;BY-NC-SA&lt;/a&gt; 许可协议。转载请注明出处！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关注博主:&lt;/strong&gt;如果您觉得该文章对您有帮助，可以点击文章右下角&lt;strong&gt;推荐&lt;/strong&gt;一下，您的支持将成为我最大的动力！&lt;/p&gt;
&lt;hr/&gt;</description>
<pubDate>Thu, 18 Feb 2021 00:19:00 +0000</pubDate>
<dc:creator>CrazyCatJack</dc:creator>
<og:description>1. 临界区保护 临界区是仅允许一个线程访问的共享资源。它可以是一个具体的硬件设备，也可以是一个变量、一个缓冲区。多个线程必须互斥的对他们进行访问 1.1 方法一：关闭系统调度保护临界区 禁止调度 /</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/CrazyCatJack/p/14408842.html</dc:identifier>
</item>
<item>
<title>JavaScript 的 7 种设计模式 - 削微寒</title>
<link>http://www.cnblogs.com/xueweihan/p/14410490.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xueweihan/p/14410490.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202102/759200-20210218081936873-1637260070.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;4.5&quot;&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;https://blog.bitsrc.io/understanding-design-patterns-in-javascript-13345223f2dd&quot; target=&quot;_blank&quot;&gt;Understanding Design Patterns in JavaScript&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原文作者：&lt;a href=&quot;https://medium.com/@Sukhjinder&quot; target=&quot;_blank&quot;&gt;Sukhjinder Arora&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：HelloGitHub-Robert&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当启动一个新的项目时候，我们不应该马上开始编程。而是首先应该定义项目的目的和范围，然后列出其功能或规格。如果你已经开始编程或者正在从事一个复杂的项目，则应该选择一个最适合你项目的设计模式。&lt;/p&gt;
&lt;h2 id=&quot;什么是设计模式？&quot;&gt;什么是设计模式？&lt;/h2&gt;
&lt;p&gt;在软件工程中，设计模式是针对软件设计中常见问题的可重用解决方案。设计模式也是经验丰富的开发人员针对特定问题的最佳实践。它可以被当作编程的模板。&lt;/p&gt;
&lt;h3 id=&quot;为什么要使用设计模式？&quot;&gt;为什么要使用设计模式？&lt;/h3&gt;
&lt;p&gt;许多工程师要么认为设计模式浪费时间，要么不知道如何恰当的使用设计模式。但如果能正确使用设计模式，则可以帮助你写出更好的可读性更高的代码，并且代码更容易被维护和理解。&lt;/p&gt;
&lt;p&gt;最重要的是，设计模式为软件开发人员提供了通用的词汇表。它们能让学习你代码的人很快了解代码的意图。例如，如果你的项目中使用了装饰器模式，那么新的开发可以很快就知道这段代码的作用，从而他们可以将更多精力放在解决业务问题上，而不是试图理解代码在做什么。&lt;/p&gt;
&lt;p&gt;我们已经知道了什么是设计模式和它的重要性，下面我们深入研究一下 JavaScript 中的 7 种设计模式。&lt;/p&gt;
&lt;h2 id=&quot;一、模块模式&quot;&gt;一、模块模式&lt;/h2&gt;
&lt;p&gt;模块是一段独立的代码，因此我们可以更新模块而不会影响代码的其它部分。模块还允许我们通过为变量创建单独的作用域来避免命名空间污染。当它们与其它代码解耦时，我们还可以在其它项目中重用模块。&lt;/p&gt;
&lt;p&gt;模块是任何现代 JavaScript 应用程序不可或缺的一部分，有助于保持代码干净，独立和有条理。在 JavaScript 中有许多方法可以创建模块，其中一种是模块模式。&lt;/p&gt;
&lt;p&gt;与其它编程语言不同，JavaScript 没有访问修饰符，也就是说，你不能将变量声明为私有的或公共的。因此，模块模式也可用来模拟封装的概念。&lt;/p&gt;
&lt;p&gt;模块模式使用 IIFE（立即调用的函数表达式），闭包和函数作用域来模拟封装的概念。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;const myModule = (function() {  
  const privateVariable = 'Hello World';  
  function privateMethod() {
    console.log(privateVariable);
  }
  return {
    publicMethod: function() {
      privateMethod();
    }
  }
})();
myModule.publicMethod();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于是 IIFE 因此代码会被立即执行，并将返回对象赋值给了 &lt;code&gt;myModule&lt;/code&gt; 变量。由于闭包，即使在 IIFE 完成后，返回的对象仍可以访问 IIFE 内部定义的函数和变量。&lt;/p&gt;
&lt;p&gt;因此，IIFE 内部定义的变量和函数对外部是看不见的，从而使其成为 &lt;code&gt;myModule&lt;/code&gt; 模块的私有成员。&lt;/p&gt;
&lt;p&gt;执行代码后，myModule 变量看起来像下面所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;const myModule = {
  publicMethod: function() {
    privateMethod();
  }};
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因此当我们调用 &lt;code&gt;publicMethod()&lt;/code&gt; 时候，它将调用 &lt;code&gt;privateMethod()&lt;/code&gt; 例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;// Prints 'Hello World'
module.publicMethod();
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;二、揭示模块模式&quot;&gt;二、揭示模块模式&lt;/h2&gt;
&lt;p&gt;揭示模块模式是 Christian Heilmann 对模块模式的略微改进。模块模式的问题在于，我们必须创建新的公共函数才能调用私有函数和变量。&lt;/p&gt;
&lt;p&gt;在这种模式下，我们将返回的对象的属性映射到要公开暴露的私有函数上。这就是为什么将其称为揭示模块模式。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;const myRevealingModule = (function() {  
  let privateVar = 'Peter';
  const publicVar  = 'Hello World';
  function privateFunction() {
    console.log('Name: '+ privateVar);
  }
  
  function publicSetName(name) {
    privateVar = name;
  }
  function publicGetName() {
    privateFunction();
  }
  /** reveal methods and variables by assigning them to object     properties */
return {
    setName: publicSetName,
    greeting: publicVar,
    getName: publicGetName
  };
})();
myRevealingModule.setName('Mark');
// prints Name: Mark
myRevealingModule.getName();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种模式让我们更容易知道哪些函数和变量是公共的，无形中提高了代码的可读性。执行代码后 &lt;code&gt;myRevealingModule&lt;/code&gt; 看起来像下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;const myRevealingModule = {
  setName: publicSetName,
  greeting: publicVar,
  getName: publicGetName
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当我们调用 &lt;code&gt;myRevealingModule.setName('Mark')&lt;/code&gt; 时，实际调用了内部的 &lt;code&gt;publicSetName&lt;/code&gt;。当调用 &lt;code&gt;myRevealingModule.getName()&lt;/code&gt; 时，实际调用了内部的 &lt;code&gt;publicGetName&lt;/code&gt; 例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;myRevealingModule.setName('Mark');
// prints Name: Mark
myRevealingModule.getName();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;与模块模式相比，揭示模块模式的优势有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通过修改 return 语句中的一行，我们可以将成员从公共变为为私人，反之亦然。&lt;/li&gt;
&lt;li&gt;返回的对象不包含任何函数定义，所有右侧表达式都在 IIFE 中定义，从而使代码清晰易读。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;三、es6-模块&quot;&gt;三、ES6 模块&lt;/h2&gt;
&lt;p&gt;在 ES6 之前，JavaScript 没有内置模块，因此开发人员必须依靠第三方库或模块模式来实现模块。但是自从 ES6，JavaScript 内置了模块。&lt;/p&gt;
&lt;p&gt;ES6 的模块是以文件形式存储的。每个文件只能有一个模块。默认情况下，模块内的所有内容都是私有的。通过使用 &lt;code&gt;export&lt;/code&gt; 关键字来暴露函数、变量和类。模块内的代码始终在严格模式下运行。&lt;/p&gt;
&lt;h3 id=&quot;31-导出模块&quot;&gt;3.1 导出模块&lt;/h3&gt;
&lt;p&gt;有两种方法可以导出函数和变量声明：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在函数和变量声明的前面添加 &lt;code&gt;export&lt;/code&gt; 关键字。例如：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;// utils.js
export const greeting = 'Hello World';
export function sum(num1, num2) {
  console.log('Sum:', num1, num2);
  return num1 + num2;
}
export function subtract(num1, num2) {
  console.log('Subtract:', num1, num2);
  return num1 - num2;
}
// This is a private function
function privateLog() {
  console.log('Private Function');
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;在代码的最后添加 &lt;code&gt;export&lt;/code&gt; 关键字来暴露函数和变量。例如：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;// utils.js
function multiply(num1, num2) {
  console.log('Multiply:', num1, num2);
  return num1 * num2;
}
function divide(num1, num2) {
  console.log('Divide:', num1, num2);
  return num1 / num2;
}
// This is a private function
function privateLog() {
  console.log('Private Function');
}
export {multiply, divide};
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;32-导入模块&quot;&gt;3.2 导入模块&lt;/h3&gt;
&lt;p&gt;与导出模块相似，有两种使用 &lt;code&gt;import&lt;/code&gt; 关键字导入模块的方法。例如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;一次导入多个项目&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;// main.js
// importing multiple items
import { sum, multiply } from './utils.js';
console.log(sum(3, 7));
console.log(multiply(3, 7));
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;导入所有模块&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;// main.js
// importing all of module
import * as utils from './utils.js';
console.log(utils.sum(3, 7));
console.log(utils.multiply(3, 7));
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;33-导入导出中使用别名&quot;&gt;3.3 导入导出中使用别名&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;重命名导出&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;// utils.js
function sum(num1, num2) {
  console.log('Sum:', num1, num2);
  return num1 + num2;
}
function multiply(num1, num2) {
  console.log('Multiply:', num1, num2);
  return num1 * num2;
}
export {sum as add, multiply};
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;重命名导入&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;// main.js
import { add, multiply as mult } from './utils.js';
console.log(add(3, 7));
console.log(mult(3, 7));
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;四、单例模式&quot;&gt;四、单例模式&lt;/h2&gt;
&lt;p&gt;一个单例对象是只能实例化一次的对象。如果不存在，则单例模式将创建类的新实例。如果存在实例，则仅返回对该对象的引用。重复调用构造函数将始终获取同一对象。&lt;/p&gt;
&lt;p&gt;JavaScript 是一直内置单例的语言。我们只是不称它们为单例，我们称它们为对象字面量。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;const user = {
  name: 'Peter',
  age: 25,
  job: 'Teacher',
  greet: function() {
    console.log('Hello!');
  }
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为 JavaScript 中的每个对象都占用一个唯一的内存位置，并且当我们调用该 &lt;code&gt;user&lt;/code&gt; 对象时，实际上是在返回该对象的引用。&lt;/p&gt;
&lt;p&gt;如果我们尝试将 &lt;code&gt;user&lt;/code&gt; 变量复制到另一个变量并修改该变量。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;const user1 = user;
user1.name = 'Mark';
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们将看到两个对象都被修改，因为 JavaScript 中的对象是通过引用而不是通过值传递的。因此，内存中只有一个对象。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;// prints 'Mark'
console.log(user.name);
// prints 'Mark'
console.log(user1.name);
// prints true
console.log(user === user1);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以使用构造函数来实现单例模式。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;let instance = null;

function User() {
  if(instance) {
    return instance;
  }
  instance = this;
  this.name = 'Peter';
  this.age = 25;
  
  return instance;
}
const user1 = new User();
const user2 = new User();
// prints true
console.log(user1 === user2);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用此构造函数时，它将检查 &lt;code&gt;instance&lt;/code&gt; 对象是否存在。如果对象不存在，则将 &lt;code&gt;this&lt;/code&gt; 变量分配给 &lt;code&gt;instance&lt;/code&gt; 变量。如果该对象存在，则只返回该对象。&lt;/p&gt;
&lt;p&gt;单例也可以使用模块模式来实现。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;const singleton = (function() {
  let instance;
  
  function init() {
    return {
      name: 'Peter',
      age: 24,
    };
  }
  return {
    getInstance: function() {
      if(!instance) {
        instance = init();
      }
      
      return instance;
    }
  }
})();
const instanceA = singleton.getInstance();
const instanceB = singleton.getInstance();
// prints true
console.log(instanceA === instanceB);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上面的代码中，我们通过调用 &lt;code&gt;singleton.getInstance&lt;/code&gt; 方法来创建一个新实例。如果实例已经存在，则此方法仅返回该实例。如果该实例不存在，则通过调用该 &lt;code&gt;init()&lt;/code&gt; 函数创建一个新实例。&lt;/p&gt;
&lt;h2 id=&quot;五、工厂模式&quot;&gt;五、工厂模式&lt;/h2&gt;
&lt;p&gt;工厂模式使用工厂方法创建对象而不需要指定具体的类或构造函数的模式。&lt;/p&gt;
&lt;p&gt;工厂模式用于创建对象而不需要暴露实例化的逻辑。当我们需要根据特定条件生成不同的对象时，可以使用此模式。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;class Car{
  constructor(options) {
    this.doors = options.doors || 4;
    this.state = options.state || 'brand new';
    this.color = options.color || 'white';
  }
}
class Truck {
  constructor(options) {
    this.doors = options.doors || 4;
    this.state = options.state || 'used';
    this.color = options.color || 'black';
  }
}
class VehicleFactory {
  createVehicle(options) {
    if(options.vehicleType === 'car') {
      return new Car(options);
    } else if(options.vehicleType === 'truck') {
      return new Truck(options);
      }
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里，创建了一个 &lt;code&gt;Car&lt;/code&gt; 和一个 &lt;code&gt;Truck&lt;/code&gt; 类（具有一些默认值），该类用于创建新的 &lt;code&gt;car&lt;/code&gt; 和 &lt;code&gt;truck&lt;/code&gt; 对象。而且定义了一个&lt;code&gt;VehicleFactory&lt;/code&gt; 类，用来根据 &lt;code&gt;options&lt;/code&gt; 对象中的 &lt;code&gt;vehicleType&lt;/code&gt; 属性来创建和返回新的对象。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;const factory = new VehicleFactory();
const car = factory.createVehicle({
  vehicleType: 'car',
  doors: 4,
  color: 'silver',
  state: 'Brand New'
});
const truck= factory.createVehicle({
  vehicleType: 'truck',
  doors: 2,
  color: 'white',
  state: 'used'
});
// Prints Car {doors: 4, state: &quot;Brand New&quot;, color: &quot;silver&quot;}
console.log(car);
// Prints Truck {doors: 2, state: &quot;used&quot;, color: &quot;white&quot;}
console.log(truck);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我为类 &lt;code&gt;VehicleFactory&lt;/code&gt; 创建了一个新的 &lt;code&gt;factory&lt;/code&gt; 对象。然后，我们通过调用 &lt;code&gt;factory.createVehicle&lt;/code&gt; 方法并且传递 &lt;code&gt;options&lt;/code&gt; 对象，其 &lt;code&gt;vehicleType&lt;/code&gt; 属性可能为 &lt;code&gt;car&lt;/code&gt; 或者 &lt;code&gt;truck&lt;/code&gt; 来创建新 &lt;code&gt;Car&lt;/code&gt; 或 &lt;code&gt;Truck&lt;/code&gt; 对象。&lt;/p&gt;
&lt;h2 id=&quot;六、装饰器模式&quot;&gt;六、装饰器模式&lt;/h2&gt;
&lt;p&gt;装饰器模式用于扩展对象的功能，而无需修改现有的类或构造函数。此模式可用于将特征添加到对象中，而无需修改底层的代码。&lt;/p&gt;
&lt;p&gt;此模式的一个简单示例为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;function Car(name) {
  this.name = name;
  // Default values
  this.color = 'White';
}
// Creating a new Object to decorate
const tesla= new Car('Tesla Model 3');
// Decorating the object with new functionality
tesla.setColor = function(color) {
  this.color = color;
}
tesla.setPrice = function(price) {
  this.price = price;
}
tesla.setColor('black');
tesla.setPrice(49000);
// prints black
console.log(tesla.color);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种模式的一个更实际的例子是：&lt;/p&gt;
&lt;p&gt;假设汽车的成本取决于其功能的数量。如果没有装饰器模式，我们将不得不为不同的功能组合创建不同的类，每个类都有一个 &lt;code&gt;cost&lt;/code&gt; 方法来计算成本。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;class Car() {
}

class CarWithAC() {
}

class CarWithAutoTransmission {
}

class CarWithPowerLocks {
}

class CarWithACandPowerLocks {
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是，通过装饰器模式，我们可以创建一个基类 &lt;code&gt;car&lt;/code&gt; 并且通过装饰器函数给不同的对象添加对应的成本逻辑。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;class Car {
  constructor() {
  // Default Cost
  this.cost = function() {
  return 20000;
  }
}
}
// Decorator function
function carWithAC(car) {
  car.hasAC = true;
  const prevCost = car.cost();
  car.cost = function() {
    return prevCost + 500;
  }
}
// Decorator function
function carWithAutoTransmission(car) {
  car.hasAutoTransmission = true;
   const prevCost = car.cost();
  car.cost = function() {
    return prevCost + 2000;
  }
}
// Decorator function
function carWithPowerLocks(car) {
  car.hasPowerLocks = true;
  const prevCost = car.cost();
  car.cost = function() {
    return prevCost + 500;
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先，我们创建了小轿车的基类 &lt;code&gt;Car&lt;/code&gt;。然后针对要添加的特性创建了装饰器并且此装饰器以 &lt;code&gt;Car&lt;/code&gt; 对象为参数。然后通过返回更新后的小汽车成本来覆盖对象的成本函数，且添加了一个用来标识某个特性是否已经被添加的属性。&lt;/p&gt;
&lt;p&gt;要添加新的功能，我们只需要像下面一样就可以：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;const car = new Car();
console.log(car.cost());
carWithAC(car);
carWithAutoTransmission(car);
carWithPowerLocks(car);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后，我们可以像这样计算汽车的成本：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;// Calculating total cost of the car
console.log(car.cost());
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;结论&quot;&gt;结论&lt;/h2&gt;
&lt;p&gt;我们已经了解了 JavaScript 中使用的各种设计模式，但是这里没有涉及到可以用 JavaScript 实现的设计模式。&lt;/p&gt;
&lt;p&gt;尽管了解各种设计模式很重要，但不要过度使用它们也同样重要。在使用设计模式之前，你应该仔细考虑你的问题是否适合该设计模式。要知道某个模式是否适合你的问题，应该好好研究该设计模式以及它的应用。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;关注 &lt;strong&gt;HelloGitHub 公众号&lt;/strong&gt; 收到第一时间的更新。&lt;/p&gt;
&lt;p&gt;还有更多开源项目的介绍和宝藏项目等待你的发掘。&lt;/p&gt;
</description>
<pubDate>Thu, 18 Feb 2021 00:18:00 +0000</pubDate>
<dc:creator>削微寒</dc:creator>
<og:description>原文地址：Understanding Design Patterns in JavaScript 原文作者：Sukhjinder Arora 译者：HelloGitHub-Robert 当启动一个新的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xueweihan/p/14410490.html</dc:identifier>
</item>
<item>
<title>计量经济学导论13：虚拟变量与双重差分 - 李旭东东东东东阿东</title>
<link>http://www.cnblogs.com/lixddd/p/14410421.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lixddd/p/14410421.html</guid>
<description>&lt;p&gt;这一章笔记围绕虚拟变量问题展开，主要介绍虚拟变量的引入形式和分析方法，重点介绍双重差分模型的应用方法。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;150.05363506771&quot;&gt;


&lt;h2 id=&quot;虚拟变量的模型设定&quot;&gt;虚拟变量的模型设定&lt;/h2&gt;
&lt;p&gt;首先我们先对解释变量中的定性因素和定量因素作以下阐述：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;定量因素：可直接测度、数值性的因素；&lt;/li&gt;
&lt;li&gt;定性因素：属性因素，表征某种属性存在与否的非数值性的因素。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在实际建模中，如何对定性因素进行回归分析？采用“虚拟变量”对定性变量进行量化是最常用的一种思路。其基本思想为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;直接在回归模型中加入定性因素存在诸多的困难；&lt;/li&gt;
&lt;li&gt;可将这些定性因素进行量化，以达到定性因素能与定量因素有着相同作用之目的；&lt;/li&gt;
&lt;li&gt;有些定量因素也可以采取分组的方式来研究。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;虚拟变量设置的时候需要考虑以下的基本规则：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;总原则为：设置能够区分所有属性的最少虚拟变量。&lt;/li&gt;
&lt;li&gt;虚拟变量取“1”或“0”的原则，应从分析问题的目的出发予以界定。从理论上讲，虚拟变量取“0”值通常代表比较的基础类型；而虚拟变量取“1”值通常代表被比较的类型。&lt;/li&gt;
&lt;li&gt;如果定性因素具有 &lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt; 个相互排斥属性，当模型中含有截距项时，则只能引入 &lt;span class=&quot;math inline&quot;&gt;\(m-1\)&lt;/span&gt; 个虚拟变量；当模型中没有截距项时，则可以引入 &lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt; 个虚拟变量，否则就会陷入“虚拟变量陷阱”。&lt;/li&gt;
&lt;li&gt;“虚拟变量陷阱”的实质：完全共线性。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;虚拟变量的回归分析&quot;&gt;虚拟变量的回归分析&lt;/h2&gt;
&lt;p&gt;在计量经济学中，通常引入虚拟变量的方式分为加法方式和乘法方式两种。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;加法方式：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;\[Y_i=\alpha_0+\beta_1X_i+u_i+\alpha_1 D_i \ . \]&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;乘法方式：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;\[Y_i=\alpha_0+\beta_1X_i+u_i+\beta_2X_iD_i \ . \]&lt;/p&gt;
&lt;p&gt;实质上，加法方式引入虚拟变量改变的是截距，乘法方式引入虚拟变量改变的是斜率。&lt;/p&gt;
&lt;p&gt;含有虚拟变量的模型的分析手段：条件期望。&lt;/p&gt;
&lt;p&gt;以加法方式引入虚拟变量时，主要考虑的问题是定性因素的属性和引入虚拟变量的个数。主要有四种情况：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;解释变量只有一个定性变量而无定量变量，而且定性变量为两种相互排斥的属性；&lt;/li&gt;
&lt;li&gt;解释变量分别为一个两种属性的定性变量和一个定量变量；&lt;/li&gt;
&lt;li&gt;解释变量分别为一个定性变量（两种以上属性）和一个定量解释变量；&lt;/li&gt;
&lt;li&gt;解释变量分别为两个定性变量（各自分别是两种属性）和一个定量解释变量。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以乘法方式引入虚拟变量时，是在所设立的模型中，将虚拟变量与其它解释变量的乘积，作为新的解释变量出现在模型中，以达到其调整设定模型斜率系数的目的。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;截距不变的情形：&lt;span class=&quot;math inline&quot;&gt;\(Y_i=f(X_i,\,D_iX_i)+u_i\)&lt;/span&gt; ；&lt;/li&gt;
&lt;li&gt;截距和斜率均发生变化的情形：&lt;span class=&quot;math inline&quot;&gt;\(Y_i=f(X_i,\,D_i,\,D_iX_i)+u_i\)&lt;/span&gt; 。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;虚拟变量的综合应用&quot;&gt;虚拟变量的综合应用&lt;/h2&gt;
&lt;p&gt;所谓虚拟变量的综合应用是指将引入虚拟解释变量的加法方式、乘法方式进行综合使用。基本分析方式仍然是条件期望分析。&lt;/p&gt;
&lt;h3 id=&quot;结构变化分析&quot;&gt;结构变化分析&lt;/h3&gt;
&lt;p&gt;结构变化的实质是检验所设定的模型在样本期内是否为同一模型。显然，平行回归、共点回归、不同的回归三个模型均不是同一模型。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;平行回归模型的假定是斜率保持不变（加法类型，包括方差分析）；&lt;/li&gt;
&lt;li&gt;共点回归模型的假定是截距保持不变（乘法类型，又被称为协方差分析）；&lt;/li&gt;
&lt;li&gt;不同的回归的模型的假定是截距、斜率均为变动的（加法、乘法类型的组合）。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;18&quot;&gt;
&lt;p&gt;例：比较改革开放前后我国居民平均“储蓄—收入”总量关系是否发生变化？&lt;/p&gt;
&lt;p&gt;模型设定为 ：&lt;/p&gt;
&lt;p&gt;\[Y_t=\alpha_1+\alpha_2D_t+\beta_1X_t+\beta_2(D_tX_t)+u_t \]&lt;/p&gt;
&lt;p&gt;其中：&lt;span class=&quot;math inline&quot;&gt;\(Y_t\)&lt;/span&gt; 为储蓄总额，&lt;span class=&quot;math inline&quot;&gt;\(X_t\)&lt;/span&gt; 为收入总额。&lt;/p&gt;
&lt;p&gt;\[D=\left\{\begin{array}{cl} 1 \ \ , &amp;amp; \text{改革开放前} \\ 0 \ \ , &amp;amp; \text{改革开放后} \end{array}\right. \ . \]&lt;/p&gt;
&lt;p&gt;条件期望分析：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;改革开放后：&lt;span class=&quot;math inline&quot;&gt;\({\rm E}(Y_t|X_t,\,D_t=1)=\alpha_1+\alpha_2+(\beta_1+\beta_2)X_t\)&lt;/span&gt; ；&lt;/li&gt;
&lt;li&gt;改革开放前：&lt;span class=&quot;math inline&quot;&gt;\({\rm E}(Y_t|X_t,\,D_t=0)=\alpha_1+\beta_1X_t\)&lt;/span&gt; 。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;只要 &lt;span class=&quot;math inline&quot;&gt;\(\alpha_2\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(\beta_2\)&lt;/span&gt; 不同时为零，上述模型就能刻画改革开放前后我国居民平均“储蓄—收入”模型结构是否发生变化。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;交互效应分析&quot;&gt;交互效应分析&lt;/h3&gt;
&lt;p&gt;交互作用：一个解释变量的边际效应有时可能要依赖于另一个解释变量。&lt;/p&gt;
&lt;blockquote readability=&quot;25&quot;&gt;
&lt;p&gt;例：研究人群的个人收入 &lt;span class=&quot;math inline&quot;&gt;\(Y\)&lt;/span&gt; 与其教育水平 &lt;span class=&quot;math inline&quot;&gt;\(E\)&lt;/span&gt; 和所在地区 &lt;span class=&quot;math inline&quot;&gt;\(D\)&lt;/span&gt; 的关系。&lt;/p&gt;
&lt;p&gt;模型设定为：&lt;/p&gt;
&lt;p&gt;\[Y=\alpha_0+\alpha_1D_1+\alpha_2D_2+\alpha_3E+\alpha_4D_1E+\alpha_5D_2E+u \ , \]&lt;/p&gt;
&lt;p&gt;其中&lt;/p&gt;
&lt;p&gt;\[D_1=\left\{\begin{array}{cl} 1 \ \ , &amp;amp; \text{中部} \\ 0 \ \ , &amp;amp; \text{其他} \end{array}\right. \ , \ \ \ \ D_2=\left\{\begin{array}{cl} 1 \ \ , &amp;amp; \text{东部} \\ 0 \ \ , &amp;amp; \text{其他} \end{array}\right. \ , \ \ \ \ E=\left\{\begin{array}{cl} 1 \ \ , &amp;amp; \text{高等} \\ 0 \ \ , &amp;amp; \text{中等} \end{array}\right. \ . \]&lt;/p&gt;
&lt;p&gt;各类人员的收入表如下：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th&gt;西部 &lt;span class=&quot;math inline&quot;&gt;\((0,\,0)\)&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;中部 &lt;span class=&quot;math inline&quot;&gt;\((1,\,0)\)&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;东部 &lt;span class=&quot;math inline&quot;&gt;\((0,\,1)\)&lt;/span&gt;&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr&gt;&lt;td&gt;中等 &lt;span class=&quot;math inline&quot;&gt;\(E=0\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(\alpha_0\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(\alpha_0+\alpha_1\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(\alpha_0+\alpha_2\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;高等 &lt;span class=&quot;math inline&quot;&gt;\(E=1\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(\alpha_0+\alpha_3\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(\alpha_0+\alpha_1+\alpha_3+\alpha_4\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(\alpha_0+\alpha_2+\alpha_3+\alpha_5\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;差异性描述：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th&gt;中部与西部差&lt;/th&gt;
&lt;th&gt;东部与西部差&lt;/th&gt;
&lt;th&gt;东部与中部差&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;中等 &lt;span class=&quot;math inline&quot;&gt;\(E=0\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(\alpha_1\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(\alpha_2\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(\alpha_2-\alpha_1\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;高等 &lt;span class=&quot;math inline&quot;&gt;\(E=1\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(\alpha_1+\alpha_4\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(\alpha_2+\alpha_5\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(\alpha_2-\alpha_1+\alpha_5-\alpha_4\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;各类人员的收入表如下：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th&gt;西部 &lt;span class=&quot;math inline&quot;&gt;\((0,\,0)\)&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;中部 &lt;span class=&quot;math inline&quot;&gt;\((1,\,0)\)&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;东部 &lt;span class=&quot;math inline&quot;&gt;\((0,\,1)\)&lt;/span&gt;&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;高等与中等差&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(\alpha_3\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(\alpha_3+\alpha_4\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(\alpha_3+\alpha_5\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/blockquote&gt;
&lt;h2 id=&quot;双重差分模型&quot;&gt;双重差分模型&lt;/h2&gt;
&lt;p&gt;双重差分法，Differences-in-Differences，基本思想就是通过对政策实施前后对照组和实验组之间差异的比较构造出反映政策效果的双重差分统计量。首先强调一点，一般而言 DID 仅适用于面板数据模型，但并没有严格意义上面板数据模型所需要的过多的假设，通过引入虚拟变量并通过最小二乘法即可实现参数估计。因此我们在讨论面板数据之前，先讨论双重差分模型的应用。&lt;/p&gt;
&lt;p&gt;前提假设：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;平行趋势假设：如果实验组的事件没有发生，对照组和实验组的变化趋势相同。&lt;/li&gt;
&lt;li&gt;检验方法：比较实验组和对照组样本的 &lt;span class=&quot;math inline&quot;&gt;\(Y\)&lt;/span&gt; 随 &lt;span class=&quot;math inline&quot;&gt;\(t\)&lt;/span&gt; 的增长率在实验前有无显著差异。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;模型设定：&lt;/p&gt;
&lt;p&gt;\[Y_{it}=\alpha+\alpha_1d_{it}+\alpha_2T_{it}+\beta d_{it}T_{it}+\varepsilon_{it} \]&lt;/p&gt;
&lt;p&gt;其中，&lt;span class=&quot;math inline&quot;&gt;\(Y_{it}\)&lt;/span&gt; 为个体 &lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt; 在 &lt;span class=&quot;math inline&quot;&gt;\(t\)&lt;/span&gt; 期的结果值，&lt;/p&gt;
&lt;p&gt;\[d_{it}=\left\{ \begin{array}{ll} 1 \ \ , &amp;amp; i\,\text{为实验组} \\ 0 \ \ , &amp;amp; i\,\text{为对照组} \\ \end{array} \right. \]&lt;/p&gt;
&lt;p&gt;\[T_{it}=\left\{ \begin{array}{ll} 1 \ \ , &amp;amp; \text{表示实验后} \\ 0 \ \ , &amp;amp; \text{表示实验前} \\ \end{array} \right. \]&lt;/p&gt;
&lt;p&gt;对 DID 模型取数学期望：&lt;/p&gt;
&lt;p&gt;对照组+实验前&lt;/p&gt;
&lt;p&gt;\[{\rm E}(Y_{it}|d_{it}=0,\,T_{it}=0)=\alpha \]&lt;/p&gt;
&lt;p&gt;对照组+实验后&lt;/p&gt;
&lt;p&gt;\[{\rm E}(Y_{it}|d_{it}=0,\,T_{it}=1)=\alpha+\alpha_2 \]&lt;/p&gt;
&lt;p&gt;实验组+实验前&lt;/p&gt;
&lt;p&gt;\[{\rm E}(Y_{it}|d_{it}=1,\,T_{it}=0)=\alpha+\alpha_1 \]&lt;/p&gt;
&lt;p&gt;对照组+实验前&lt;/p&gt;
&lt;p&gt;\[{\rm E}(Y_{it}|d_{it}=1,\,T_{it}=1)=\alpha+\alpha_1+\alpha_2+\beta \]&lt;/p&gt;
&lt;p&gt;为了方便对比参数设定的意义，我们用如下的表格：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th&gt;对照组&lt;/th&gt;
&lt;th&gt;实验组&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;实验前&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(\alpha\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(\alpha+\alpha_1\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;实验后&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(\alpha+\alpha_2\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(\alpha+\alpha_1+\alpha_2+\beta\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Difference&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(\alpha_2\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(\alpha_2+\beta\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;将双重差分的思想与上表的内容结合，我们可以得到政策的净效应：&lt;/p&gt;
&lt;p&gt;\[{\rm DID}=\alpha_2+\beta-\alpha_2=\beta \ . \]&lt;/p&gt;
&lt;p&gt;关键：检验交叉项系数 &lt;span class=&quot;math inline&quot;&gt;\(\hat\beta\)&lt;/span&gt; 是否显著。&lt;/p&gt;
&lt;h2 id=&quot;双重差分模型的优点&quot;&gt;双重差分模型的优点&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;可以很大程度上避免内生性问题的困扰：政策相对于微观经济主体而言一般是外生的，因而不存在逆向因果问题。此外，使用固定效应估计一定程度上也缓解了遗漏变量偏误问题。&lt;/li&gt;
&lt;li&gt;传统方法下评估政策效应，主要是通过设置一个政策发生与否的虚拟变量然后进行回归，相较而言，双重差分法的模型设置更加科学，能更加准确地估计出政策效应。&lt;/li&gt;
&lt;li&gt;双重差分法的原理和模型设置很简单，容易理解和运用，并不像空间计量等方法一样让人望而生畏。&lt;/li&gt;
&lt;li&gt;尽管双重差分法估计的本质就是面板数据固定效应估计，但是 DID 听上去或多或少也要比 OLS、FE 之流更加“时尚高端”，因而 DID 的使用一定程度上可以满足“虚荣心”。&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;</description>
<pubDate>Wed, 17 Feb 2021 18:17:00 +0000</pubDate>
<dc:creator>李旭东东东东东阿东</dc:creator>
<og:description>这一章笔记围绕虚拟变量问题展开，主要介绍虚拟变量的引入形式和分析方法，重点介绍双重差分模型的应用方法。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lixddd/p/14410421.html</dc:identifier>
</item>
<item>
<title>云原生系列4 批量定时更新本地代码库 - 李福春</title>
<link>http://www.cnblogs.com/snidget/p/14410324.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/snidget/p/14410324.html</guid>
<description>[unable to retrieve full-text content]图中是一个自动化的机械流水线。 作为一名程序员，每天一定有非常多工作是每天必须重复的， 如何消除重复性的工作？也让自己日常重复工作自动化呢？ 背景和需求 开发人员入职一家新公司，一般会使用git来进行代码的版本管理和协作， 负责的代码库随着时间的推移会慢慢增加，最后可能会有1-20个代码工程， 有些</description>
<pubDate>Wed, 17 Feb 2021 16:12:00 +0000</pubDate>
<dc:creator>李福春</dc:creator>
<dc:identifier>https://www.cnblogs.com/snidget/p/14410324.html</dc:identifier>
</item>
<item>
<title>【数据结构】带权并查集 - HinanawiTenshi</title>
<link>http://www.cnblogs.com/Tenshi/p/14410263.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Tenshi/p/14410263.html</guid>
<description>&lt;ul&gt;&lt;li&gt;简介&lt;/li&gt;
&lt;li&gt;详细介绍&lt;/li&gt;
&lt;li&gt;例题&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;顾名思义，就是在维护集合关系的树中添加边权的并查集，这样做可以维护更多的信息。&lt;/p&gt;
&lt;p&gt;引入题目：&lt;a href=&quot;https://www.luogu.com.cn/problem/P2024&quot; target=&quot;_blank&quot;&gt;https://www.luogu.com.cn/problem/P2024&lt;/a&gt;&lt;br/&gt;比如这道题，如果使用普通的并查集则无法处理，因为普通的并查集只能够刻画两个物品是否属于同一个集合。因此这时候就要使用能够记录更多信息的&lt;strong&gt;带权并查集&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;在阅读前，需要先掌握&lt;strong&gt;并查集&lt;/strong&gt;的知识。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;详细介绍&quot;&gt;详细介绍&lt;/h2&gt;
&lt;p&gt;结合题目讲解：&lt;a href=&quot;https://www.luogu.com.cn/problem/P2024&quot; target=&quot;_blank&quot;&gt;https://www.luogu.com.cn/problem/P2024&lt;/a&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2185228/202102/2185228-20210217222142134-320848444.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于一个物种（一类动物），如果存在它吃另一个物种的关系，则让它的度数比另一个物种多 &lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt; 。更严格地说，我们记该物种为 &lt;code&gt;a&lt;/code&gt; （并非题意中的&lt;code&gt;A&lt;/code&gt;），另一个物种是 &lt;code&gt;b&lt;/code&gt;，它们对应的度数为&lt;code&gt;d[]&lt;/code&gt;，那么有 &lt;span class=&quot;math inline&quot;&gt;\(d[a]=d[b]+1\)&lt;/span&gt; 。如图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2185228/202102/2185228-20210217223008323-2035607542.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么有了这样的规定，便有如下性质：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;d[a]%3==d[b]%3&lt;/code&gt; 时，&lt;code&gt;a&lt;/code&gt;，&lt;code&gt;b&lt;/code&gt;是同一个物种。（操作1）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;((d[a]-d[b])%3+3)%3==1&lt;/code&gt; 时，存在&lt;code&gt;a&lt;/code&gt;吃&lt;code&gt;b&lt;/code&gt;的关系。（这里多次取模是为了保证左边的值只可能为 &lt;span class=&quot;math inline&quot;&gt;\(0,1,2\)&lt;/span&gt; ）（操作2）&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;从上面的性质可以看出，两个物种的关系与它们的模数（这题是 &lt;span class=&quot;math inline&quot;&gt;\(mod3\)&lt;/span&gt; ）余多少关系密切相关，因此接下来我们也会着重考察两个数之间的这种关系。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;利用度数以及并查集，即可将各种动物之间的关系刻画清楚：&lt;/p&gt;
&lt;p&gt;这里依然对&lt;code&gt;a&lt;/code&gt;，&lt;code&gt;b&lt;/code&gt;进行讨论，为了方便，我们记&lt;code&gt;a&lt;/code&gt;的祖宗（根节点）为&lt;code&gt;pa&lt;/code&gt;，&lt;code&gt;b&lt;/code&gt;的祖宗（根节点）为&lt;code&gt;pb&lt;/code&gt;。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2185228/202102/2185228-20210217224410185-2017022993.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;若&lt;code&gt;pa&lt;/code&gt;，&lt;code&gt;pb&lt;/code&gt;不在同一个集合中：&lt;br/&gt;就进行并查集的&lt;strong&gt;合并&lt;/strong&gt;操作，让&lt;code&gt;f[pa]=pb&lt;/code&gt;。可以看出，在合并的时候，仍然作为根节点的&lt;code&gt;pb&lt;/code&gt;的度数还是 &lt;span class=&quot;math inline&quot;&gt;\(0\)&lt;/span&gt;，&lt;strong&gt;但是&lt;code&gt;pa&lt;/code&gt;的度数需要作出调整&lt;/strong&gt;，才能够保证结点之间关系的正确。&lt;br/&gt;① 如果&lt;code&gt;a&lt;/code&gt;和&lt;code&gt;b&lt;/code&gt;是同一个物种（操作1）：则有 &lt;code&gt;d[pa]+d[a]=d[b]&lt;/code&gt;&lt;br/&gt;② 如果&lt;code&gt;a&lt;/code&gt;吃&lt;code&gt;b&lt;/code&gt;（操作2）：则有 &lt;code&gt;d[pa]+d[a]-d[b]=1&lt;/code&gt;（当然，右式等于 &lt;span class=&quot;math inline&quot;&gt;\(4,7,10\)&lt;/span&gt; 这样的数也是可以的，我们只需找到 &lt;span class=&quot;math inline&quot;&gt;\(mod 3余1\)&lt;/span&gt;的数 ）&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2185228/202102/2185228-20210217225624070-943305788.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;若&lt;code&gt;pa&lt;/code&gt;，&lt;code&gt;pb&lt;/code&gt;在同一个集合中：&lt;br/&gt;类似于上面的讨论，&lt;br/&gt;① 如果&lt;code&gt;a&lt;/code&gt;和&lt;code&gt;b&lt;/code&gt;是同一个物种（操作1）：如果 &lt;code&gt;((d[a]-d[b])%3+3)%3!=0&lt;/code&gt;，则矛盾，这句话便是谎言。&lt;br/&gt;② 如果&lt;code&gt;a&lt;/code&gt;吃&lt;code&gt;b&lt;/code&gt;（操作2）：如果 &lt;code&gt;((d[a]-d[b])%3+3)%3!=1&lt;/code&gt;，则矛盾，这句话便是谎言。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;综上，我们的讨论将所有情况覆盖了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;路径压缩：&lt;/strong&gt;&lt;br/&gt;根据并查集的性质，如果不进行路径压缩，时间复杂度将会退化到 &lt;span class=&quot;math inline&quot;&gt;\(O(N)\)&lt;/span&gt; 。因此带权并查集也要进行路径压缩，那么主要问题就是解决如何维护&lt;code&gt;d[]&lt;/code&gt;（度数）的问题：&lt;br/&gt;概括地说，就是在查询到某个点的时候，在搜索它的祖宗时递归地求出路上所有结点的度数，那么它的度数就是&lt;code&gt;d[x]+=d[f[x]]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2185228/202102/2185228-20210217232151218-1548099975.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;如上图，&lt;code&gt;pa&lt;/code&gt;在一次操作中并入了&lt;code&gt;pb&lt;/code&gt;。&lt;br/&gt;而在另一次操作中，对&lt;code&gt;a&lt;/code&gt;的进行了查询（求祖宗），便有如下路径压缩的并更新&lt;code&gt;d[]&lt;/code&gt;的过程：&lt;br/&gt;递归地找出祖宗&lt;code&gt;pb&lt;/code&gt;。&lt;br/&gt;&lt;code&gt;pa&lt;/code&gt;的祖宗就是&lt;code&gt;pb&lt;/code&gt;，度数在合并的时候已经求出来了，所以更新 &lt;span class=&quot;math inline&quot;&gt;\(0\)&lt;/span&gt;。&lt;br/&gt;&lt;code&gt;c&lt;/code&gt;的父亲节点是&lt;code&gt;pa&lt;/code&gt;，合并的时候并没有更新（因此记录的是距离&lt;code&gt;pa&lt;/code&gt;的度数），度数需要加上 &lt;span class=&quot;math inline&quot;&gt;\(d[pa]\)&lt;/span&gt;，然后进行路径压缩。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2185228/202102/2185228-20210217233433590-208134830.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;a&lt;/code&gt;的父亲节点是&lt;code&gt;c&lt;/code&gt;，在上一步更新了，所以度数加上 &lt;span class=&quot;math inline&quot;&gt;\(d[c]\)&lt;/span&gt; 即可，类似的，进行路径压缩。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2185228/202102/2185228-20210217233600925-924993944.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（这里可能有点难理解，不过只要记住：所谓的&lt;code&gt;d[x]&lt;/code&gt;指的是节点&lt;code&gt;x&lt;/code&gt;相对于它父节点的度数即可）&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;不理解的地方可以结合代码理解&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;放上代码：（&lt;s&gt;很短的&lt;/s&gt;）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

const int N=5e4+5;

int f[N],d[N];

int find(int x){
    if(x!=f[x]){
        int root=find(f[x]);
        d[x]+=d[f[x]];
        f[x]=root;
    }   
    return f[x];
}

int main(){
    int n,m;
    cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m;
    
    for(int i=1;i&amp;lt;N;i++) f[i]=i;
    
    int cnt=0;
    while(m--){
        int op,a,b;
        cin&amp;gt;&amp;gt;op&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b;
        
        //2,3 judge
        if(a&amp;gt;n || b&amp;gt;n){
            cnt++;
            continue;
        }
        if(a==b &amp;amp;&amp;amp; op==2){
            cnt++;
            continue;
        }
        
        int pa=find(a),pb=find(b);
        
        int t= op==2;
        if(pa==pb){
            if(((d[a]-d[b])%3+3)%3!=t) cnt++;
        }else{
            f[pa]=pb;
            d[pa]=t+d[b]-d[a];
        }
    }
    
    cout&amp;lt;&amp;lt;cnt&amp;lt;&amp;lt;endl;
    
    return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;例题&quot;&gt;例题&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.acwing.com/problem/content/241/&quot; target=&quot;_blank&quot;&gt;https://www.acwing.com/problem/content/241/&lt;/a&gt;&lt;br/&gt;分析：思路完全类似于食物链那题。&lt;/p&gt;
&lt;details readability=&quot;16&quot;&gt;代码 #includeusing namespace std;
&lt;p&gt;const int N=2e4+5;&lt;/p&gt;
&lt;p&gt;unordered_map&amp;lt;int,int&amp;gt; h;&lt;br/&gt;int n,m;&lt;br/&gt;int f[N];&lt;br/&gt;int d[N];&lt;/p&gt;
&lt;p&gt;int get(int x){&lt;br/&gt;if(h.count(x)==0) h[x]=++n;&lt;br/&gt;return h[x];&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;int find(int x){&lt;br/&gt;if(f[x]!=x){&lt;br/&gt;int root=find(f[x]);&lt;br/&gt;d[x]^=d[f[x]];&lt;br/&gt;f[x]=root;&lt;br/&gt;}&lt;br/&gt;return f[x];&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;int main(){&lt;br/&gt;cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m;&lt;br/&gt;n=0;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//init
for(int i=1;i&amp;lt;N;i++) f[i]=i;

int ans=m;
for(int i=1;i&amp;lt;=m;i++){
    int a,b;
    string op;
    
    cin&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b&amp;gt;&amp;gt;op;
    a=get(a-1); b=get(b);
    
    int t= op==&quot;odd&quot;;
    
    int pa=find(a),pb=find(b);
    
    if(pa==pb){
        if(abs(d[a]-d[b])!=t){
            ans=i-1;
            break;
        }
    }else{
        //merge
        f[pa]=pb;
        d[pa]=d[a]^d[b]^t;
    }
}

cout&amp;lt;&amp;lt;ans&amp;lt;&amp;lt;endl;

return 0;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;}&lt;br/&gt;&lt;/p&gt;
&lt;/details&gt;</description>
<pubDate>Wed, 17 Feb 2021 15:40:00 +0000</pubDate>
<dc:creator>HinanawiTenshi</dc:creator>
<og:description>目录 简介 详细介绍 例题 简介 顾名思义，就是在维护集合关系的树中添加边权的并查集，这样做可以维护更多的信息。 引入题目：https://www.luogu.com.cn/problem/P2024</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Tenshi/p/14410263.html</dc:identifier>
</item>
<item>
<title>这是我做的博客园皮肤！就叫他sakebowUI了！ - sakebow</title>
<link>http://www.cnblogs.com/sakebow/p/14410204.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sakebow/p/14410204.html</guid>
<description>&lt;div id=&quot;cnblogs_post_description&quot; readability=&quot;35&quot;&gt;&lt;img src=&quot;https://sakebow.gitee.io/images/emoji/%E6%94%BE%E5%BC%83%E6%80%9D%E8%80%83.jpg&quot; class=&quot;desc_img&quot;/&gt;我的博客也有自己做的新皮肤了！好耶！好吧。其实这款皮肤并没有做完。从大年三十做到正月初六，这七天已经是尽全力了。开年了还有别的任务，所以只能暂时放一下了。给大家道个歉（鞠躬），也祝各位新年快乐（再鞠躬）&lt;/div&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;84.717098445596&quot;&gt;

&lt;p&gt;那当然是因为sakebow是我的&lt;a href=&quot;https://github.com/sakebow&quot; target=&quot;_blank&quot;&gt;GitHub&lt;/a&gt;名称啦！（叉会腰）&lt;/p&gt;
&lt;p&gt;虽然这么厚脸皮的叫了，由于还是借鉴了很多前人的经验，在这里还是要老老实实的表示感谢。感谢&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/vvjiang&quot; target=&quot;_blank&quot;&gt;韩子卢&lt;/a&gt;的&lt;a href=&quot;https://gitee.com/vvjiang/cnblogs-skin&quot; target=&quot;_blank&quot;&gt;脚手架&lt;/a&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/bndong/&quot; target=&quot;_blank&quot;&gt;BNDong&lt;/a&gt;的&lt;a href=&quot;https://bndong.github.io/Cnblogs-Theme-SimpleMemory/v1.1/#/&quot; target=&quot;_blank&quot;&gt;Silence&lt;/a&gt;里面各种钩子的设计理念&lt;/strong&gt;（&lt;s&gt;虽然没看懂，就照着葫芦画了瓢&lt;/s&gt;），以及各种各样身怀绝技的大佬们的贴心教程。&lt;/p&gt;
&lt;p&gt;总之，谢谢各位大佬开源的各种工具。&lt;/p&gt;
&lt;h2 id=&quot;小插曲&quot;&gt;小插曲&lt;/h2&gt;
&lt;p&gt;由于是我自己根据&lt;a href=&quot;http://c.biancheng.net/view/5826.html&quot; target=&quot;_blank&quot;&gt;这位还没找到名字的大佬的教程&lt;/a&gt;弄得一个类似&lt;code&gt;jQuery&lt;/code&gt;的框架，所以不熟悉&lt;code&gt;webpack&lt;/code&gt;的我直接蒙圈了，韩子卢的手脚架虽然好用，但是我这个框架到最后整合的时候塞不进去了（哭）。&lt;/p&gt;
&lt;p&gt;于是就丢掉了。现在就觉得自己是个脱离时代的バガ...（燃尽了.jpg）&lt;/p&gt;

&lt;p&gt;从大年三十那天开始的，到今天（2021年2月17日，正月初六），一共正好一周时间。当然！！&lt;strong&gt;还没做完&lt;/strong&gt;...因为现在有别的任务了，所以这个皮肤可能要搁置一下下。不过呢，对于&lt;span class=&quot;math inline&quot;&gt;\(1280\)&lt;/span&gt;px以上的电脑浏览器来说应该是做完了。剩下的就看将来有没有一丢丢时间把&lt;strong&gt;小窗口端&lt;/strong&gt;和&lt;strong&gt;移动端&lt;/strong&gt;适配给做了。如果各位有什么想法和建议的话请多多评论！我会一一记录下来的！&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;首当其冲的就是一开始的&lt;code&gt;loading&lt;/code&gt;界面。大家看我之前的随笔也看到了，花了三天做了个寂寞，很懊恼。最后突然开窍了，给做出来了。&lt;s&gt;感谢&lt;code&gt;CCTV&lt;/code&gt;&lt;/s&gt;。&lt;/li&gt;
&lt;li&gt;然后就是整个界面几乎是重构了。这些琐碎的东西花了些时间调整。但不得不吐槽，这特么什么鬼判定点啊，&lt;code&gt;a&lt;/code&gt;标签歪到天上去了，&lt;code&gt;cursor&lt;/code&gt;属性也歪天上去了。&lt;s&gt;建议把前端拉出来当着所有人的面改需求&lt;/s&gt;&lt;/li&gt;
&lt;li&gt;我基本上没有什么配色的天赋，和寺田てら太太完全是相反的呢（强颜欢笑）。所以，我这次想一点点尝试，使用&lt;code&gt;VOCALOID&lt;/code&gt;的各种颜色配了一下，包括日本的和中国的。不知道配得怎么样，但是我自己很开心（强颜欢笑）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;emmm因为在这里打字太难受了，所以我会去&lt;code&gt;CSDN&lt;/code&gt;贴出来。但我最好还是&lt;strong&gt;建议不要急着用&lt;/strong&gt;，因为&lt;strong&gt;还有很多东西都没完善&lt;/strong&gt;。感兴趣的可以去我在gitee的&lt;a href=&quot;https://gitee.com/sakebow/cnblogs&quot; target=&quot;_blank&quot;&gt;临时存档点&lt;/a&gt;看看，里面暂时只有一些压缩过的&lt;code&gt;js&lt;/code&gt;和&lt;code&gt;css&lt;/code&gt;。等下个版本更新之后（那个时候最起码应该是可以全平台兼容的时候）我会放出源码公开给大家。抱歉了各位！（抱拳）&lt;/p&gt;

&lt;p&gt;基本上就是这些了。最后小小的吐槽一下：这编辑器也太反人类了……我虽然花了这么多精力搞皮肤，但我可能还是会回&lt;code&gt;CSDN&lt;/code&gt;...（&lt;s&gt;怀疑人生&lt;/s&gt;）&lt;/p&gt;
&lt;p&gt;不多说了，欢迎大家来我的博客玩！有什么修改意见也请多多评论！我在&lt;code&gt;CSDN&lt;/code&gt;更多一点，可以去找&lt;a href=&quot;https://blog.csdn.net/ordinary_brony&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;ordinary_brony&lt;/code&gt;&lt;/a&gt;，这也是我。&lt;/p&gt;
&lt;p&gt;最后的最后，新年快乐！&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Wed, 17 Feb 2021 15:21:00 +0000</pubDate>
<dc:creator>sakebow</dc:creator>
<og:description>为什么是sakebowUI 那当然是因为sakebow是我的GitHub名称啦！（叉会腰） 虽然这么厚脸皮的叫了，由于还是借鉴了很多前人的经验，在这里还是要老老实实的表示感谢。感谢**韩子卢的脚手架、</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sakebow/p/14410204.html</dc:identifier>
</item>
<item>
<title>Virtualbox 安装centos7虚拟机 - 清减几分</title>
<link>http://www.cnblogs.com/qjjfzmx/p/14410201.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qjjfzmx/p/14410201.html</guid>
<description>&lt;p&gt;Virtualbox 安装centos7虚拟机&lt;br/&gt;一，下载centos7&lt;br/&gt;下载地址：&lt;a href=&quot;https://mirrors.tuna.tsinghua.edu.cn/centos/7.9.2009/isos/x86_64/&quot; target=&quot;_blank&quot;&gt;https://mirrors.tuna.tsinghua.edu.cn/centos/7.9.2009/isos/x86_64/&lt;/a&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2040890/202102/2040890-20210217223929117-836126143.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个地址为清华的源，下载速度比官网快，推荐用这个下载。&lt;br/&gt;进入后有三个版本可以选择：&lt;br/&gt;1、DVD ISO 标准安装版&lt;br/&gt;2、Everything ISO 对完整版安装盘的软件进行补充，集成所有软件！&lt;br/&gt;3、Minimal ISO 一个非常基本的CentOS 系统，只需要最少的软件包即可拥有一个功能系统（软件比较少，大部分需要自己去装）&lt;br/&gt;4、CentOS-6.9-i386-netinstall.iso 网络安装版&lt;/p&gt;
&lt;p&gt;二、创建虚拟机&lt;br/&gt;1.打开virtualbox,点击新建，如下图，类型选择Linux,版本因为选项中没有centos7,所以选other linux。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2040890/202102/2040890-20210217224337928-330426038.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击下一步，为虚拟机分内存，推荐1G~2G,我这里只是做示范，所以直接默认了。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2040890/202102/2040890-20210217224418921-809084716.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;虚拟机可以看成一个独立的电脑，需要cpu,内存，磁盘。这里直接选默认，点击下一步。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2040890/202102/2040890-20210217224450038-554039672.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择硬盘大小（硬盘的极限值），因人而异，电脑磁盘大点就选大点，推荐选大点。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2040890/202102/2040890-20210217224508801-1064666197.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击创建，虚拟机便创建成功。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2040890/202102/2040890-20210217224557041-1916368026.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;网络设置，选择网络地址转换（NAT）&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2040890/202102/2040890-20210217224733619-1251498631.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来便可以启动虚拟机，虽然我们已经创建好了虚拟机，但这个不过是一个空壳，我们真正需要的centos7还没装上呢，所以首次进入，我们要选择下载的centos7镜像文件启动，安装系统。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2040890/202102/2040890-20210217224752383-1120420737.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里要选择语言，推荐选择英文。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2040890/202102/2040890-20210217224846407-1237917165.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;时间选择上海时间，点击done,来到下一步。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2040890/202102/2040890-20210217224903959-923979741.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;点击有黄色三角形的地方，选择安装位置，默认便好。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2040890/202102/2040890-20210217224921988-1593990271.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;漫长的等待时间，我们来创建两个账号，一个root账号，一个普通用户。（切记要记住自己的root密码，待会需要用）&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2040890/202102/2040890-20210217224937838-1969322995.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2040890/202102/2040890-20210217224953193-1946310624.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;安装完成，重启。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2040890/202102/2040890-20210217225048683-1744979614.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里需要登录账号，我们直接输入root,然后回车。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2040890/202102/2040890-20210217225106001-234245729.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输入密码时，命令行是不会出现密码占位符的，输入时一定细心，下图中，我便是一不小心就输错了。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2040890/202102/2040890-20210217225128981-763009737.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到这里centos7已经安装完成。不过这台虚拟机还没有联网，许多丰富的功能我们还用不到，当务之急，自然是先联网。&lt;br/&gt;先ping了一下百度，网络是未连接的。&lt;br/&gt;ip addr&lt;br/&gt;查看网卡名称，接下来修改网络配置文件需要用到。如图所见，我这里是enp0s3。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2040890/202102/2040890-20210217225344827-333627970.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;用vi编辑网络配置文件，vi后要有一个空格，再接具体地址。最后的那个enp03s根据ip addr 的地址，换成自己的地址就好。&lt;br/&gt;vi /etc/sysconfig/network-scripts/ifcfg-enp0s3&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2040890/202102/2040890-20210217230200379-1115691500.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2040890/202102/2040890-20210217231339587-1217202349.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;只要把ONBOOT=no，修改为ONBOOT=yes就好。vim编辑，按i可以进入insert模式，按方向键移动光标，修改完后，esc退出insert模式，:wq保存并退出。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2040890/202102/2040890-20210217230132692-1841130207.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;保存后，需要重启，网络配置文件才会生效，输入reboot命令。&lt;br/&gt;重启后，再ping一下www.baidu.com ,发现网络现在已经连上了，ctrl+C 中断ping,不然会一直ping。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2040890/202102/2040890-20210217231055662-585513628.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 17 Feb 2021 15:20:00 +0000</pubDate>
<dc:creator>清减几分</dc:creator>
<og:description>Virtualbox 安装centos7虚拟机 一，下载centos7 下载地址：https://mirrors.tuna.tsinghua.edu.cn/centos/7.9.2009/isos/x</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qjjfzmx/p/14410201.html</dc:identifier>
</item>
<item>
<title>5分钟学Go 基础01：初识 Go - 伍工</title>
<link>http://www.cnblogs.com/wucode/p/14410151.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wucode/p/14410151.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;本文首发于公众号「5分钟学Go」，一个让你每次花 5 分钟就能掌握一个技能点的公众号。目前在博主连更 5 分钟学Go系列，大家可以关注下，第一时间掌握Go技能。如果想要加群交流，可以在公众号后台回复「加群」，回复「gogogo」，还有博主精心整理的一份Go语言从入门、进阶到高阶的学习宝典。欢迎你的关注。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最近几年，随着云计算、区块链等技术的发展，有一门语言逐渐成为大家热衷讨论的对象，成为了继 Python 之后的另一块香饽饽，那就是 Go 语言。&lt;/p&gt;
&lt;p&gt;其实如果要追溯历史的话，Go 语言诞生于 Google，从 2007 年便开始设计，并于 2009 年 11 月 10 日正式发布第一版，此后便开始在 Google 内部使用。&lt;/p&gt;
&lt;p&gt;正如 Python 借助 AI 的东风大火一样，Go 语言大范围的使用和普及也是借助了云计算、区块链等技术的东风，特别是云计算，以 Google 开源的 Kubernetes 为代表，Go 逐渐成为了云计算领域的第一首选语言，目前还没有竞争对手。&lt;/p&gt;
&lt;p&gt;国内最早全面使用 Go 语言的公司要属七牛云了，其创始人许式伟说过一句话：“Go 语言是互联网时代的 C 语言”。可想它如今的地位是不言而喻的。&lt;/p&gt;
&lt;p&gt;下图是 2020 StackOverflow 的调查，左边是最流行的语言排行榜，右边是最热门的语言。流行看的是历史地位和应用程度，而热门更多看的是近来的关注程度。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;最流行的语言&lt;/th&gt;
&lt;th&gt;最热门的语言&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;https://gitee.com/bakari/mypicture/raw/master/2021-2-16/1613468659952-gopop.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;https://gitee.com/bakari/mypicture/raw/master/2021-2-16/1613468701286-gotop.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;可以看到，Go 语言应用范围具有一定的局限性，所以流行程度并不高，但关注程度是相对较高的，特别是对比前几年的数据你会发现，它是一直增长的。&lt;/p&gt;
&lt;p&gt;接下来再来看下大家比较关心的一个问题：哪种语言的薪资较高？毕竟程序员这个行业，回归到现实，都是“面对薪资编程”。如下图所示，左边是 2019 年的数据，右边是 2020 年的数据。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;2019编程语言薪水排名&lt;/th&gt;
&lt;th&gt;2020编程语言薪水排名&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;https://gitee.com/bakari/mypicture/raw/master/2021-2-16/1613468756011-gosalaries2019.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;https://gitee.com/bakari/mypicture/raw/master/2021-2-16/1613468756012-gosalaries2020.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;可以看到，Go 语言的薪水排名都稳居前三甲。所以，综合来看，Go 语言是今后最值得学的一门语言。&lt;/p&gt;
&lt;p&gt;那 Go 语言到底有哪些优势呢？为何能成为云计算领域的第一大语言？下面简单说说，更多内容在后面的文章中我们会逐一展开。&lt;/p&gt;
&lt;p&gt;首先它是一种静态、强一致类型、编译型的系统级编程语言。这几个关键字可能不那么好理解，但是看完下面这幅图相信你能理解个大概：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/bakari/mypicture/raw/master/2021-2-16/1613468808216-langtype.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从类型来看，Go 语言和 Java 语言同处于第一象限，但它编译型、系统级的特性又让它具备 C/C++ 语言的高性能的特性。&lt;/p&gt;
&lt;p&gt;其次一个比较重要的优势是 Go 天然支持高并发，小白也能轻松写出高并发代码。&lt;/p&gt;
&lt;p&gt;最后值得一提的是 Go 语言的语法简单，学习曲线平坦，开发效率可以和 Python 媲美。&lt;/p&gt;
&lt;p&gt;此外，还有很多的优秀特性，后面会带大家逐一领略（大家可以关注下公众号，每天第一时间收到推送，花 5 分钟就可以掌握一个 Go 技能点）。&lt;/p&gt;
&lt;p&gt;看到这里大家一定很好奇，有哪些开源项目是使用 Go 语言开发的？&lt;/p&gt;
&lt;p&gt;Go 生态系统有众多明星开源软件：Docker、Kubernetes、Rancher、istio、Drone、Lantern、Hyperledger、Caddy、Prometheus、InfluxDB、etcd、CockroachDB、TiDB、Gogs ...&lt;/p&gt;
&lt;p&gt;（这里有一份开源的关于 Go 优秀的软件、库和框架：&lt;a href=&quot;https://github.com/avelino/awesome-go&quot; title=&quot;Awesome Go&quot; target=&quot;_blank&quot;&gt;Awesome Go&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;极客时间的郝林在他的专栏里也整理过一张使用 Go 语言开发的开源项目大图，非常全。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://static001.geekbang.org/resource/image/29/f8/29c794731d9fb43f9fd37cc4d91994f8.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;OK，今天就到这里，本文是 5 分钟学 Go 语言的第一篇，先让大家对 Go 有个大概的印象，后面会展开更多的内容，没关注的朋友可以关注下，一起抱团学习。就像一句话说的：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;学习 Go 语言，最好的时间是 10 年前，其次是现在。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/bakari/mypicture/raw/master/2021-2-17/1613573093482-gobottomnoma.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 17 Feb 2021 15:00:00 +0000</pubDate>
<dc:creator>伍工</dc:creator>
<og:description>本文首发于公众号「5分钟学Go」，一个让你每次花 5 分钟就能掌握一个技能点的公众号。目前在博主连更 5 分钟学Go系列，大家可以关注下，第一时间掌握Go技能。如果想要加群交流，可以在公众号后台回复「</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wucode/p/14410151.html</dc:identifier>
</item>
<item>
<title>docker部署LNMP架构 - 林奋斗的成长之路</title>
<link>http://www.cnblogs.com/lin-strive/p/14409080.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lin-strive/p/14409080.html</guid>
<description>&lt;p&gt;&lt;strong&gt;环境要求：&lt;/strong&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;IP　&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;hostname&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;192.168.1.1&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;node1&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;项目规划：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;strong&gt;容器网段：172.16.10.0/24&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NGINX：172.16.10.10&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MySQL：172.16.10.20&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PHP：172.16.10.20&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;网站根目录:/www&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;nginx配置文件：/conf&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;mysql持久化目录：/var/lib/mysql&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;提前准备服务配置文件：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;nginx&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
&lt;strong&gt;docker run -itd --name  test nginx             #运行test容器     
docker cp test:/etc/nginx /conf　　　　　　#copy主配置文件
ls /conf/
conf.d          koi-win     nginx.conf    win-utf
fastcgi_params  mime.types  scgi_params
koi-utf         modules     uwsgi_params
docker cp test:/usr/share/nginx/html /www     #copy网站目录
ls /www/
50x.html  index.html         &lt;/strong&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt; mysql&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
&lt;strong&gt;[root@node1 ~]# docker rm -f test 
test
[root@node1 ~]#  docker run -itd --name test -e MYSQL_ROOT_PASSWORD=pwd123 mysql:5.7 
6b8d73ecd541d454f121302963a85d53131286d3118a968525a24ad2315b047b
[root@node1 ~]# docker exec  -it test sh
# mysql -uroot -ppwd123 -h127.0.0.1
..........
mysql&amp;gt; create database test;
Query OK, 1 row affected (0.00 sec)

mysql&amp;gt; show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sys                |
| test               |
+--------------------+
5 rows in set (0.00 sec)

mysql&amp;gt; exit
Bye
# exit
[root@node1 ~]# docker cp test:/var/lib/mysql /var/lib/mysql
&lt;/strong&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;  1、配置lnmp虚拟网卡，网段172.16.10.0/24，网关172.16.10.254&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
&lt;strong&gt;docker network  create  -d bridge  --subnet  172.16.10.0/24 --gateway 172.16.10.254 lnmp
&lt;/strong&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　&lt;strong&gt;2、创建nginx容器测试访问　&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node1 ~]#  docker run -itd --name nginx -p 80:80 -v /www/:/usr/share/nginx/html -v /conf:/etc/nginx --network lnmp --ip 172.16.10.10  nginx:latest 
e6e8824abd10ec4f8cb610fdd3bb77bd5919cce94c50a86732e8fd2138b8091b
[root@node1 ~]#  echo  hello &amp;gt; /www/index.html 
[root@node1 ~]# curl  192.168.1.1
hello
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;　3、运行MySQL容器　&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
&lt;strong&gt;#创建mysql挂载数据目录、开发端口、指定IP
[root@node1 ~]# docker run -itd --name mysql -p 3306:3306 -v /var/lib/mysql:/var/lib/mysql --network lnmp --ip 172.16.10.20 mysql:5.7
448227483a9c3141c2155d2c7b027aec263bfcfe4ebc49371b6817c17565ff81
#查看运行状态
[root@node1 ~]# docker ps
CONTAINER ID   IMAGE          COMMAND                  CREATED          STATUS         PORTS                               NAMES
448227483a9c   mysql:5.7      &quot;docker-entrypoint.s…&quot;   10 seconds ago   Up 9 seconds   0.0.0.0:3306-&amp;gt;3306/tcp, 33060/tcp   mysql
4d1e99a06972   nginx:latest   &quot;/docker-entrypoint.…&quot;   3 minutes ago    Up 3 minutes   0.0.0.0:80-&amp;gt;80/tcp                  nginx
6b8d73ecd541   mysql:5.7      &quot;docker-entrypoint.s…&quot;   9 minutes ago    Up 9 minutes   3306/tcp, 33060/tcp                 test
#测试登录
[root@node1 ~]# yum -y install  mariadb
[root@node1 ~]# mysql -uroot -ppwd123 -h127.0.0.1
Welcome to the MariaDB monitor.  Commands end with ; or \g.
Your MySQL connection id is 2
Server version: 5.7.33 MySQL Community Server (GPL)

Copyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

MySQL [(none)]&amp;gt; Bye
&lt;/strong&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;　4、创建php-fpm容器&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
&lt;strong&gt;[root@node1 www]# docker run -itd --name  php-fpm -p 9000:9000 -v /www:/usr/share/nginx/html --network lnmp --ip 172.16.10.30 php:7.2-fpm  
ae09213d7c8c84299b1522ca474fccf7f26e27973cd02563891c37d51799b766
[root@node1 www]# docker ps
CONTAINER ID   IMAGE          COMMAND                  CREATED          STATUS          PORTS                               NAMES
ae09213d7c8c   php:7.2-fpm    &quot;docker-php-entrypoi…&quot;   7 seconds ago    Up 6 seconds    0.0.0.0:9000-&amp;gt;9000/tcp              php-fpm&lt;/strong&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;　5、nginx和PHP的连接　&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
&lt;strong&gt;[root@node1 ~]# vim /conf/conf.d/default.conf 
&lt;/strong&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2133896/202102/2133896-20210217170611543-2051126400.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/2133896/202102/2133896-20210217170619597-1740879024.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; 5.1、添加nginx静态的测试界面&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
&lt;strong&gt;[root@node1 ~]# echo  Hello LNMP! &amp;gt; /www/index.html 
[root@node1 ~]# cat /www/index.html 
Hello LNMP!
[root@node1 ~]# curl  192.168.1.1
Hello LNMP!
&lt;/strong&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;5.2、添加PHP测试页面　&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
&lt;strong&gt;[root@node1 ~]# cd /www
[root@node1 www]# vim test.php
[root@node1 www]# cat test.php 
&amp;lt;?php
phpinfo();
?&amp;gt;
[root@node1 www]#  docker restart nginx 
nginx
[root@node1 www]# pwd
/www
[root@node1 www]# ls
50x.html  index.html  test.php
&lt;/strong&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2133896/202102/2133896-20210217172206305-563821005.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;能够访问到以上两个界面，说明nginx和php的连接，没有问题，接下来是 php和mysql的连接。在这里我们使用一个phpMyAdmin的数据库管理工 具。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt; 6、测试PHP容器与Mysql容器的协调性、工具phpMyadmin&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node1 www]# pwd
/www
[root@node1 www]# unzip phpMyAdmin-4.9.0.1-all-languages.zip
[root@node1 www]# mv phpMyAdmin-4.9.0.1-all-languages phpMyAdmin
[root@node1 www]# rm -rf phpMyAdmin　　
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;6.1、更新nginx配置文件　&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node1 www]# cd /conf/conf.d/
[root@node1 conf.d]# vim default.conf 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　&lt;img src=&quot;https://img2020.cnblogs.com/blog/2133896/202102/2133896-20210217220023647-1026060669.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt; 内容如下：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
 location /phpmyadmin {
     root   /usr/share/nginx/html;
     index  index.php index.html index.htm;
 }
 location ~ /phpmyadmin/(?&amp;lt;after_ali&amp;gt;(.*)\.(php|php5)?$) {
     root           /usr/share/nginx/html;
     fastcgi_pass   172.16.10.30:9000;
     fastcgi_index  index.php;
     fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;
     include        fastcgi_params;
 }　　
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;测试访问：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2133896/202102/2133896-20210217220203204-1439708738.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt; 其实这主要是php镜像不支持连接mysql，我们要重新写一个。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;7、解决php不关联mysql&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node1 /]# cd /file/
[root@node1 file]# ls
Dockerfile
[root@node1 file]# cat Dockerfile 
&lt;span&gt;FROM php:7.2-fpm
RUN apt-get update &amp;amp;&amp;amp; apt-get install -y \
libfreetype6-dev \
libjpeg62-turbo-dev \
libpng-dev \
&amp;amp;&amp;amp; docker-php-ext-install -j$(nproc) iconv \
&amp;amp;&amp;amp; docker-php-ext-configure gd --with-freetypedir=/usr/include/ --with-jpeg-dir=/usr/include/ \
&amp;amp;&amp;amp; docker-php-ext-install -j$(nproc) gd \
&amp;amp;&amp;amp; docker-php-ext-install mysqli pdo pdo_mysql&lt;/span&gt;
[root@node1 file]#&lt;span&gt; docker build -t php_mysql .&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
#删除php容器
[root@node1 /]# docker rm php-fpm -f
php-fpm
#运行phpmysql容器
[root@node1 /]# docker run -itd --name phpfpm -p 9000:9000 -v /www:/usr/share/nginx/html --network lnmp --ip 172.16.10.30 phpmysql:latest 
c4e943880fd51f947cba64ba0006abd26a923439a3e39a0350ca2561b42b8026
[root@node1 /]# docker ps
CONTAINER ID   IMAGE             COMMAND                  CREATED          STATUS          PORTS                               NAMES
c4e943880fd5   phpmysql:latest   &quot;docker-php-entrypoi…&quot;   14 seconds ago   Up 13 seconds   0.0.0.0:9000-&amp;gt;9000/tcp              phpfpm
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;7.1、phpmysql配置指向mysql地址&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node1 www]# cd /www/phpmyadmin/
[root@node1 phpmyadmin]# mv config.sample.inc.php config.inc.php 
[root@node1 phpmyadmin]# vim config.inc.php
[root@node1 phpmyadmin]# docker restart phpfpm 
phpfpm
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;8、访问测试　　&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2133896/202102/2133896-20210217222648982-1418224379.png&quot; alt=&quot;&quot; width=&quot;1011&quot; height=&quot;600&quot; loading=&quot;lazy&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2133896/202102/2133896-20210217222648982-1418224379.png&quot; alt=&quot;&quot; width=&quot;1011&quot; height=&quot;600&quot; loading=&quot;lazy&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2133896/202102/2133896-20210217222821123-1673578853.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt; 9、趁热打铁，在发布一个dz论坛&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;dz论坛链接地址：http://down.chinaz.com/soft/41403.htm&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
#上传
[root@node1 /]# ls
bin       Discuz_X3.4_SC_UTF8_20210119.zip
#移动到/www网页目录下
mv upload/ /www/dz
chmod  777 /www/dz&lt;br/&gt;#保证数据库有dz库&lt;br/&gt;#授权一个dz库的管理员&lt;br/&gt;#注意安装是IP为数据库的IP不要写错&lt;br/&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2133896/202102/2133896-20210217223615306-1002926156.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;



&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/2133896/202102/2133896-20210217224410510-280769151.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 17 Feb 2021 14:55:00 +0000</pubDate>
<dc:creator>林奋斗的成长之路</dc:creator>
<og:description>环境要求： IP hostname 192.168.1.1 node1 项目规划： 容器网段：172.16.10.0/24 NGINX：172.16.10.10 MySQL：172.16.10.20</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lin-strive/p/14409080.html</dc:identifier>
</item>
</channel>
</rss>