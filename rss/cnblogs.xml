<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>JS事件流 - 一只菜鸟攻城狮啊</title>
<link>http://www.cnblogs.com/suihang/p/13599887.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/suihang/p/13599887.html</guid>
<description>&lt;h2 id=&quot;6jMvP&quot; data-lake-id=&quot;eb699692be4b58c5cf2c5f893bdd8e30&quot;&gt;事件&lt;/h2&gt;
&lt;p data-lake-id=&quot;559bc747df529e0aa8cc5164e98c1142&quot;&gt;HTML中与javascript交互是通过事件驱动来实现的，例如鼠标点击事件、页面的滚动事件onscroll等等，可以向文档或者文档中的元素添加事件侦听器来预订事件。想要知道这些事件是在什么时候进行调用的，就需要了解一下“事件流”的概念。&lt;/p&gt;
&lt;h2 id=&quot;ELrqK&quot; data-lake-id=&quot;2b19810a40442410dd2c778cf36574a7&quot;&gt;事件流&lt;/h2&gt;
&lt;p data-lake-id=&quot;8aa6a1d9362c000eb58b87f0b3cfdbcc&quot;&gt;事件流描述的就是从页面中接收事件的顺序。而早期的IE和Netscape提出了完全相反的事件流概念，IE事件流是事件冒泡，而Netscape的事件流就是事件捕获。&lt;/p&gt;
&lt;h2 id=&quot;s0Y2L&quot; data-lake-id=&quot;756c9c4aba0a68730b18071a72f4572f&quot;&gt;事件流类别&lt;/h2&gt;
&lt;h3 id=&quot;pHfdY&quot; data-lake-id=&quot;e9ccb179e4d28f2b134fc1575b1118c1&quot;&gt;事件冒泡&lt;/h3&gt;
&lt;p data-lake-id=&quot;e2888daf2ada9e1c9ed70d888f16ef3c&quot;&gt;即从下至上，从目标触发的元素逐级向上传播，直到window对象。&lt;/p&gt;
&lt;p data-lake-id=&quot;d5a503446d79328817de539107d2c06a&quot;&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/305942/1599001925501-eeec244d-baaf-4055-a8e7-c14fc3f597bd.png&quot; alt=&quot;image.png&quot; width=&quot;524&quot; height=&quot;367&quot; class=&quot;image lake-drag-image&quot; title=&quot;image.png&quot; data-role=&quot;image&quot; data-raw-src=&quot;&quot; data-height=&quot;341px&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;OeKut&quot; data-lake-id=&quot;32efdd23a7d0ea075745fe5fbaf6acd9&quot;&gt;事件捕获&lt;/h3&gt;
&lt;p data-lake-id=&quot;ab7219325a30c8269673da458f2866e7&quot;&gt;即从上至下，从document逐级向下传播到目标元素。&lt;/p&gt;
&lt;p data-lake-id=&quot;6db3c790b1b9d2c2e592255ddfd6fba6&quot;&gt;     &lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/305942/1599002040917-67ab7fd6-d145-40d0-a096-315f5434704a.png&quot; alt=&quot;image.png&quot; width=&quot;446&quot; height=&quot;328&quot; class=&quot;image lake-drag-image&quot; title=&quot;image.png&quot; data-role=&quot;image&quot; data-raw-src=&quot;&quot; data-height=&quot;334px&quot;/&gt;&lt;/p&gt;
&lt;p data-lake-id=&quot;e7c6946fadcde2a006c07082b2ddcff6&quot;&gt;后来ECMAScript在DOM2中对事件流进行了进一步规范，基本上就是上述二者的结合。&lt;/p&gt;
&lt;p data-lake-id=&quot;2d013ff51981817cb9680f975c4db3bc&quot;&gt;DOM2级事件规定的事件流包括三个阶段：&lt;/p&gt;
&lt;ol start=&quot;1&quot; data-lake-id=&quot;0e242377462eb6a7dbdc7f662b8d14ed&quot;&gt;&lt;li data-lake-id=&quot;54360753871fa91ba4043c34e440a02a&quot;&gt;事件捕获阶段&lt;/li&gt;
&lt;li data-lake-id=&quot;4b140ae0cf31bb7e4de6b8e2f6715795&quot;&gt;处于目标阶段&lt;/li&gt;
&lt;li data-lake-id=&quot;673dac738cf4e909dcfe120e6852b7f2&quot;&gt;事件冒泡阶段&lt;/li&gt;
&lt;/ol&gt;&lt;p data-lake-id=&quot;ac5bcccd67902eb9912d9a62c6c24fc2&quot;&gt;注意⚠️：先捕获后冒泡，但是在目标节点上谁写在前面谁先执行。但是在目标元素上不区分冒泡还是捕获，按绑定的顺序来执行。&lt;/p&gt;
&lt;p data-lake-id=&quot;4e8ef887ed07c278295c89e535bda179&quot;&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/305942/1599003038289-bd8d6cd5-356f-4910-9a03-a12e1a028915.png?x-oss-process=image%2Fresize%2Cw_1500&quot; alt=&quot;image.png&quot; width=&quot;559&quot; height=&quot;312&quot; class=&quot;image lake-drag-image&quot; title=&quot;image.png&quot; data-role=&quot;image&quot; data-raw-src=&quot;&quot; data-height=&quot;448px&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;KC0Q3&quot; data-lake-id=&quot;7cda76bb9b12de98836cddd1d9af087e&quot;&gt;DOM事件级别&lt;/h2&gt;
&lt;p data-lake-id=&quot;70890bf1df9088d3be48f91851ea211c&quot;&gt;分为四个级别&lt;/p&gt;
&lt;div id=&quot;3Prv3&quot; class=&quot;lake-card-margin lake-selected&quot; data-card-type=&quot;block&quot; data-lake-card=&quot;mindmap&quot; data-card-value=&quot;data:%7B%22diagramData%22%3A%22x%C2%9C%7D%C2%91%C3%81N%C2%830%5Cu0018%C3%87%C3%9F%C3%A5%C3%B3%5Cn%5Cu000b-%5Di%C2%B9%C2%A9%C3%A3%C3%A0%C3%81%C3%B8%5Cu0000f%C2%87B%C2%8B%5Cu0010%5Cu0019L%C3%86%C2%8CHH%3C%C2%9A%C3%ACA%3Cx%C3%B70%C3%9F%C3%86%C3%8C%C3%AC5%C3%BC%C2%98%C3%8B%C2%94%C3%88L%2F%C3%BD%C3%9A%C3%BE%7F%C3%BD%7Dm%5Cu0003%C2%89Q%5Cu001a%C3%BC%5Cu0006%C3%AEM%C2%B9H%C2%8B%5Cu001c%7C%C2%A0%23g%C3%A4%C2%80%5Cu0005U%3D7X%C3%8E%C3%92%5C%5C%C3%8F%C3%94%5Cu001cZ%5Cu000b%C3%82B%C3%97%C3%A0_7%C2%90b%5Cu0004%C2%98%C3%B2%C2%98%C2%8Cx%C2%88G%C2%93j%C2%96%C3%A1%C3%8A%C3%A4%C3%AAr%C2%B3%5Em%C3%9E%C3%9F%C2%B6%C3%AB%C2%97%C3%8F%C3%A7%C3%97%C2%BF%5Cf%5Cu000b%C2%A2%24%C3%8Dti%C3%B2%5Cu001df%5Cu001f%C3%BBxZa%C3%92%C3%85%5Cu0010%5Cu001e%C3%88T%5D%2C%C2%AB%C3%8E%C3%A8n%C2%A9t%C2%A9r%C2%9CS%C2%BC%C2%BB*%C2%8D%5Ct%C3%B4%C2%8D%C3%A9v%5Cu0016UY%C3%9Cv%C3%9C%C2%93I%20%C3%889%C3%AF%C3%9CvJR%C3%90%C3%98%5Cu001d%5Cu0013%C3%97VLp%C2%9B%5Cu0011%C2%8F%C3%99%5C%22%C3%96c%C2%9B%5Cu0013%C3%A9%5Cu0011%C3%8E%5D%C2%AE%C2%94%C3%ACKL-x%C2%BC%C3%88%C2%B5y%5Cu0000%C3%9Fm%C2%AD%7Dg%C3%82uDHB%C3%99%C3%AB%C3%8C%C3%B9%C3%B6%5Cu001b%C3%B68%C2%A5%C3%82%5Cu000bH%C3%A71%C3%8C%C2%A6%5Cu0007%C2%B6%C3%83%C2%99D%C3%89%C2%A8%C3%87%26%C3%88%C3%86W8%C2%8A%5Cu000f%C2%98%C3%80q%5Cu001cO%5Cu000e%C3%B88b%C3%91%C2%98%C2%B2%3E%C2%9E%C3%BE%C3%BC%C3%87%20%C2%9E%C3%8B3%5Cu0012%C3%BC%C2%83w%C3%9A_%5Cu0005k%C2%A7%C3%AD%5Cu0017%5Cu0018%C3%90%C2%B6%5Cn%22%2C%22margin%22%3Atrue%2C%22id%22%3A%223Prv3%22%2C%22viewportSetting%22%3A%7B%22zoom%22%3A1%2C%22scrollLeft%22%3A488%2C%22scrollTop%22%3A138%2C%22viewBox%22%3A%5B-689.5%2C-224.5%2C1540%2C464%5D%7D%2C%22height%22%3A214%2C%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2020%2Fpng%2F305942%2F1599007051021-9a3139ee-9763-4416-904a-77f801c30587.png%22%2C%22search%22%3A%22DOM%E4%BA%8B%E4%BB%B6%E7%BA%A7%E5%88%AB%20%E2%80%8BDOM3%E7%BA%A7%20DOM0%E7%BA%A7%20DOM1%E7%BA%A7%E2%80%8B%20DOM2%E7%BA%A7%E5%88%AB%22%7D&quot;&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/305942/1599007051021-9a3139ee-9763-4416-904a-77f801c30587.png&quot; width=&quot;335&quot; height=&quot;120&quot;/&gt;&lt;/div&gt;
&lt;p data-lake-id=&quot;fc6855d7f6b8ad0d315fa1a99a1e02d5&quot;&gt;DOM0：不是W3C规范。&lt;/p&gt;
&lt;p data-lake-id=&quot;0323fd48a75308fdb47eb7f4dcf45076&quot;&gt;DOM1：开始是W3C规范。专注于HTML文档和XML文档。&lt;/p&gt;
&lt;p data-lake-id=&quot;340667a899e2766e4ea7eb67fe8d7f82&quot;&gt;DOM2：对DOM1增加了&lt;strong&gt;样式表对象模型&lt;/strong&gt;&lt;/p&gt;
&lt;p data-lake-id=&quot;2b6fc977f685705b8f0a6e2b16a11862&quot;&gt;&lt;span class=&quot;lake-fontsize-12&quot;&gt;DOM3：对DOM2增加了&lt;strong&gt;内容模型&lt;/strong&gt;&lt;span class=&quot;lake-fontsize-12&quot;&gt; (DTD 、Schemas) 和&lt;strong&gt;文档验证&lt;/strong&gt;&lt;span class=&quot;lake-fontsize-12&quot;&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;VTcjP&quot; data-lake-id=&quot;9913eb78a9b06df8085ec1c5ef4c867f&quot;&gt;DOM0级&lt;/h3&gt;
&lt;p data-lake-id=&quot;5d23bd62a8ad97b98a3a6a6f22f3659e&quot;&gt;DOM0级事件具有极好的跨浏览器优势，会以最快的速度绑定。绑定方式有如下两种&lt;/p&gt;
&lt;h4 id=&quot;5cePj&quot; data-lake-id=&quot;0b37995fc624a452ad0863b634d96d0a&quot;&gt;行内绑定（内联模型）&lt;/h4&gt;
&lt;p data-lake-id=&quot;d6531fe6bc510b000a21aa34314705f9&quot;&gt;将函数名直接作为html标签中属性的属性值。&lt;/p&gt;
&lt;div id=&quot;nz19v&quot; class=&quot;lake-card-margin lake-selected&quot; data-card-type=&quot;block&quot; data-lake-card=&quot;codeblock&quot; data-card-value=&quot;data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%3Cdiv%20onclick%3D%5C%22btnClick()%5C%22%3E%E6%8C%89%E9%92%AE%3C%2Fdiv%3E%5Cn%3Cscript%3E%5Cnfunction%20btnClick()%7B%5Cn%20%20%20%20console.log(%5C%22hello%5C%22)%3B%5Cn%7D%5Cn%3C%2Fscript%3E%22%2C%22heightLimit%22%3Atrue%2C%22margin%22%3Atrue%2C%22id%22%3A%22nz19v%22%7D&quot; data-language=&quot;javascript&quot;&gt;
&lt;div class=&quot;lake-codeblock-content&quot;&gt;
&lt;div class=&quot;CodeMirror-sizer&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;div onclick=&quot;btnClick()&quot;&amp;gt;按钮&amp;lt;/div&amp;gt;
&amp;lt;script&amp;gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; btnClick(){
    console.log(&lt;/span&gt;&quot;hello&quot;&lt;span&gt;);
}
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h4 id=&quot;YopJ0&quot; data-lake-id=&quot;9acbcd3f609ada6293a45ababbee211a&quot;&gt;动态绑定（脚本模型）&lt;/h4&gt;
&lt;p data-lake-id=&quot;db3f357b381fa164b83249912eab74f3&quot;&gt;通过在JS中选中某个节点，然后给节点添加onclick属性&lt;/p&gt;
&lt;div id=&quot;YbVew&quot; class=&quot;lake-card-margin lake-selected&quot; data-card-type=&quot;block&quot; data-lake-card=&quot;codeblock&quot; data-card-value=&quot;data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%3Cdiv%20id%3D%5C%22btn%5C%22%3E%E6%8C%89%E9%92%AE%3C%2Fdiv%3E%5Cn%3Cscript%3E%5Cnvar%20btn%20%3D%20document.getElementById(%5C%22btn%5C%22)%3B%5Cnbtn.onclick%20%3D%20function()%7B%5Cn%20%20%20%20console.log(%5C%22%E7%82%B9%E5%87%BB%5C%22)%3B%5Cn%7D%5Cn%3C%2Fscript%3E%22%2C%22heightLimit%22%3Atrue%2C%22margin%22%3Atrue%2C%22id%22%3A%22YbVew%22%7D&quot; data-language=&quot;javascript&quot;&gt;
&lt;div class=&quot;lake-codeblock-content&quot;&gt;
&lt;div class=&quot;CodeMirror-sizer&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;div id=&quot;btn&quot;&amp;gt;按钮&amp;lt;/div&amp;gt;
&amp;lt;script&amp;gt;
&lt;span&gt;var&lt;/span&gt; btn = document.getElementById(&quot;btn&quot;&lt;span&gt;);
btn.onclick &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    console.log(&lt;/span&gt;&quot;点击&quot;&lt;span&gt;);
}
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h4 id=&quot;gD4mf&quot; data-lake-id=&quot;f4cc1364e3c55362d05fcb8d11b6db39&quot;&gt;注意⚠️&lt;/h4&gt;
&lt;ul data-lake-id=&quot;416c884450417995c6565ce3235b27fd&quot;&gt;&lt;li data-lake-id=&quot;52433f6d0d51e156db86f25344012d42&quot;&gt;DOM0级同一个节点只能添加一次同类型事件，后添加的同类型事件会覆盖前面的事件&lt;/li&gt;
&lt;li data-lake-id=&quot;2ae6ede00864af002a4180e4840cd011&quot;&gt;DOM0级只支持冒泡&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;42Owt&quot; data-lake-id=&quot;2c2bf93c6f50b3db54cbcbe43225bfa9&quot;&gt;DOM1级&lt;/h3&gt;
&lt;p data-lake-id=&quot;a8d5602de7f4c87df46aa80d49eec1a9&quot;&gt;其中DOM1级事件处理标准中并没有定义事件相关的内容，所以没有所谓的DOM1事件处理&lt;/p&gt;
&lt;h3 id=&quot;0Ul0z&quot; data-lake-id=&quot;db4dd598d03fdc1a1ec601f1d47503b7&quot;&gt;DOM2级&lt;/h3&gt;
&lt;p data-lake-id=&quot;11d59dd7a0bbddb7dc1b0f8181b7eb29&quot;&gt;DOM2级定义了两个事件处理程序。（观察者模式）&lt;/p&gt;
&lt;ul data-lake-id=&quot;36da61a0c690e70f23b07ad48fa36c9d&quot;&gt;&lt;li data-lake-id=&quot;c4e921ed11c5abe4a997b2e533bd9a19&quot;&gt;addEventListener() ---添加事件侦听器&lt;/li&gt;
&lt;li data-lake-id=&quot;9d79d99fba696c3c6581bf7e671ec877&quot;&gt;removeEventListener() ---删除事件侦听器&lt;/li&gt;
&lt;/ul&gt;&lt;p data-lake-id=&quot;50544cbc07823a37a28236b4ee2b8af3&quot;&gt;函数均有3个参数， 第一个参数是要处理的事件名 第二个参数是作为事件处理程序的函数 第三个参数是一个boolean值，默认false表示使用冒泡机制，true表示捕获机制。&lt;/p&gt;
&lt;div id=&quot;2AiH7&quot; class=&quot;lake-card-margin lake-selected&quot; data-card-type=&quot;block&quot; data-lake-card=&quot;codeblock&quot; data-card-value=&quot;data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%3Cdiv%20id%3D%5C%22btn%5C%22%3E%E6%8C%89%E9%92%AE%3C%2Fdiv%3E%5Cn%3Cscript%3E%5Cnvar%20btn%3Ddocument.getElementById(%5C%22btn%5C%22)%3B%5Cnbtn.addEventListener(%5C%22click%5C%22%2Chello%2Cfalse)%3B%5Cnbtn.addEventListener(%5C%22click%5C%22%2Chelloagain%2Cfalse)%3B%5Cnfunction%20hello()%7B%5Cn%20%20%20%20console.log(%5C%22hello%5C%22)%3B%5Cn%7D%5Cnfunction%20helloagain()%7B%5Cn%20%20%20%20console.log(%5C%22hello%20again%5C%22)%3B%5Cn%7D%5Cn%3C%2Fscript%3E%5Cn%2F%2F%20%E7%82%B9%E5%87%BB%E5%90%8E%E7%BB%93%E6%9E%9C%EF%BC%9A%20%5Cn%2F%2F%20hello%5Cn%2F%2F%20hello%20again%22%2C%22heightLimit%22%3Atrue%2C%22margin%22%3Atrue%2C%22id%22%3A%222AiH7%22%7D&quot; data-language=&quot;javascript&quot;&gt;
&lt;div class=&quot;lake-codeblock-content&quot;&gt;
&lt;div class=&quot;CodeMirror-sizer&quot; readability=&quot;9.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&amp;lt;div id=&quot;btn&quot;&amp;gt;按钮&amp;lt;/div&amp;gt;
&amp;lt;script&amp;gt;
&lt;span&gt;var&lt;/span&gt; btn=document.getElementById(&quot;btn&quot;&lt;span&gt;);
btn.addEventListener(&lt;/span&gt;&quot;click&quot;,hello,&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
btn.addEventListener(&lt;/span&gt;&quot;click&quot;,helloagain,&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; hello(){
    console.log(&lt;/span&gt;&quot;hello&quot;&lt;span&gt;);
}
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; helloagain(){
    console.log(&lt;/span&gt;&quot;hello again&quot;&lt;span&gt;);
}
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 点击后结果： &lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; hello&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; hello again&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p data-lake-id=&quot;91fdcd17bd74148b1157a8db5ae65529&quot;&gt;注意⚠️&lt;/p&gt;
&lt;p data-lake-id=&quot;49da13b9df2b415a4dd6961e6c38a741&quot;&gt;如果定义了一模一样的监听方法时，是会发生覆盖的。&lt;/p&gt;
&lt;div id=&quot;Cn94s&quot; class=&quot;lake-card-margin lake-selected&quot; data-card-type=&quot;block&quot; data-lake-card=&quot;codeblock&quot; data-card-value=&quot;data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%3Cdiv%20id%3D%5C%22btn%5C%22%3E%E7%82%B9%E5%87%BB%3C%2Fdiv%3E%5Cn%5Cn%3Cscript%3E%5Cnvar%20btn%3Ddocument.getElementById(%5C%22btn%5C%22)%3B%5Cnbtn.addEventListener(%5C%22click%5C%22%2Chello%2Cfalse)%3B%5Cnbtn.addEventListener(%5C%22click%5C%22%2Chello%2Cfalse)%3B%5Cnfunction%20hello()%7B%5Cn%20%20%20%20console.log(%5C%22hello%5C%22)%3B%5Cn%7D%5Cn%3C%2Fscript%3E%5Cn%2F%2F%20%E7%82%B9%E5%87%BB%E5%90%8E%E7%BB%93%E6%9E%9C%EF%BC%9A%20%5Cn%2F%2F%20hello%22%2C%22heightLimit%22%3Atrue%2C%22margin%22%3Atrue%2C%22id%22%3A%22Cn94s%22%7D&quot; data-language=&quot;javascript&quot;&gt;
&lt;div class=&quot;lake-codeblock-content&quot;&gt;
&lt;div class=&quot;CodeMirror-sizer&quot; readability=&quot;9&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&amp;lt;div id=&quot;btn&quot;&amp;gt;点击&amp;lt;/div&amp;gt;

&amp;lt;script&amp;gt;
&lt;span&gt;var&lt;/span&gt; btn=document.getElementById(&quot;btn&quot;&lt;span&gt;);
btn.addEventListener(&lt;/span&gt;&quot;click&quot;,hello,&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
btn.addEventListener(&lt;/span&gt;&quot;click&quot;,hello,&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; hello(){
    console.log(&lt;/span&gt;&quot;hello&quot;&lt;span&gt;);
}
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 点击后结果： &lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; hello&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&quot;t1Lj4&quot; data-lake-id=&quot;ce8b866873686c5fe8348e8a4697ea9c&quot;&gt;DOM3级&lt;/h3&gt;
&lt;p data-lake-id=&quot;91259ab6545257ca05d71ff264eac87b&quot;&gt;对DOM2增加了&lt;strong&gt;内容模型 (DTD 、Schemas)&lt;/strong&gt; 和&lt;strong&gt;文档验证&lt;/strong&gt;。定义了一些新的事件，比如键盘事件，还可以自定义事件。&lt;/p&gt;
&lt;h4 id=&quot;apKq9&quot; data-lake-id=&quot;69b2f0a3205c951ac946c71ee0e67148&quot;&gt;自定义事件&lt;/h4&gt;
&lt;p data-lake-id=&quot;9b7d8beb9500379b7d4b643010f6d710&quot;&gt;自定义事件不是由DOM原生触发的，它的目的是让开发人员创建自己的事件。要创建的自定义事件可以由createEvent(&quot;CustomEvent&quot;); 返回的对象有一个initCustomEvent（）方法接收如下四个参数。&lt;/p&gt;
&lt;ul data-lake-id=&quot;39fed99d1529969e0c1ddbab34d64265&quot;&gt;&lt;li data-lake-id=&quot;4b7817a146a17780d8fac047a2c42228&quot;&gt;type：字符串，触发的事件类型，自定义。例如 “keyDown”，“selectedChange”;&lt;/li&gt;
&lt;li data-lake-id=&quot;d629dfaadd3116194fd53e5ada621bf9&quot;&gt;bubble（布尔值）：标示事件是否应该冒泡；&lt;/li&gt;
&lt;li data-lake-id=&quot;b6e782bcaf8e8a1060fe98c4959e6778&quot;&gt;cancelable(布尔值)：标示事件是否可以取消；&lt;/li&gt;
&lt;li data-lake-id=&quot;cf18a7969e6bc386576311de18b3cc73&quot;&gt;detail（对象）：任意值，保存在event对象的detail属性中；&lt;/li&gt;
&lt;/ul&gt;&lt;p data-lake-id=&quot;8f9c7f259fc944cc0b1c90a10425f6b6&quot;&gt;可以像分配其他事件一样在DOM中分派创建的自定义事件对象。如：&lt;/p&gt;
&lt;div id=&quot;35Nqi&quot; class=&quot;lake-card-margin lake-selected&quot; data-card-type=&quot;block&quot; data-lake-card=&quot;codeblock&quot; data-card-value=&quot;data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22var%20%20div%20%3D%20document.getElementById(%5C%22myDiv%5C%22)%3B%5CnEventUtil.addEventHandler(div%2C%5C%22myEvent%5C%22%2C%20function%20()%20%7B%5Cn%20%20alert(%5C%22div%20myEvent!%5C%22)%3B%5Cn%7D)%3B%5CnEventUtil.addEventHandler(document%2C%5C%22myEvent%5C%22%2Cfunction()%7B%5Cn%20%20alert(%5C%22document%20myEvent!%5C%22)%3B%5Cn%7D)%3B%5Cnif(document.implementation.hasFeature(%5C%22CustomEvents%5C%22%2C%5C%223.0%5C%22))%7B%5Cn%20%20var%20e%20%3D%20document.createEvent(%5C%22CustomEvent%5C%22)%3B%5Cn%20%20e.initCustomEvent(%5C%22myEvent%5C%22%2Ctrue%2Cfalse%2C%5C%22hello%20world!%5C%22)%3B%5Cn%20%20div.dispatchEvent(e)%3B%5Cn%7D%22%2C%22heightLimit%22%3Atrue%2C%22margin%22%3Atrue%2C%22id%22%3A%2235Nqi%22%7D&quot; data-language=&quot;javascript&quot;&gt;
&lt;div class=&quot;lake-codeblock-content&quot;&gt;
&lt;div class=&quot;CodeMirror-sizer&quot; readability=&quot;11.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt;  div = document.getElementById(&quot;myDiv&quot;&lt;span&gt;);
EventUtil.addEventHandler(div,&lt;/span&gt;&quot;myEvent&quot;, &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
  alert(&lt;/span&gt;&quot;div myEvent!&quot;&lt;span&gt;);
});
EventUtil.addEventHandler(document,&lt;/span&gt;&quot;myEvent&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
  alert(&lt;/span&gt;&quot;document myEvent!&quot;&lt;span&gt;);
});
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(document.implementation.hasFeature(&quot;CustomEvents&quot;,&quot;3.0&quot;&lt;span&gt;)){
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; e = document.createEvent(&quot;CustomEvent&quot;&lt;span&gt;);
  e.initCustomEvent(&lt;/span&gt;&quot;myEvent&quot;,&lt;span&gt;true&lt;/span&gt;,&lt;span&gt;false&lt;/span&gt;,&quot;hello world!&quot;&lt;span&gt;);
  div.dispatchEvent(e);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p data-lake-id=&quot;01f526420b4dfa888cf99175d1855379&quot;&gt;这个例子中创建了一个冒泡事件“myEvent”。而event.detail的值被设置成了一个简单的字符串，然后在div和document上侦听该事件，因为在initCustomEvent中设置了事件冒泡。所以当div激发该事件时，浏览器会将该事件冒泡到document。&lt;/p&gt;
&lt;h2 id=&quot;tmzsL&quot; data-lake-id=&quot;3b4879f74ab1e92956d32670b777e095&quot;&gt;阻止冒泡&lt;/h2&gt;
&lt;p data-lake-id=&quot;45d2a459b87b24290a8b65463360a689&quot;&gt;stopPropagation函数&lt;/p&gt;
&lt;div id=&quot;v4DAz&quot; class=&quot;lake-card-margin lake-selected&quot; data-card-type=&quot;block&quot; data-lake-card=&quot;codeblock&quot; data-card-value=&quot;data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22btn.addEventListener('click'%2Cfunction(ev)%7B%5Cn%20%20%20%20ev.stopPropagation()%3B%5Cn%20%20%20%20console.log('%E9%98%BB%E6%AD%A2%E5%86%92%E6%B3%A1')%5Cn%7D%2C%20false)%22%2C%22heightLimit%22%3Atrue%2C%22margin%22%3Atrue%2C%22id%22%3A%22v4DAz%22%7D&quot; data-language=&quot;javascript&quot;&gt;
&lt;div class=&quot;lake-codeblock-content&quot;&gt;
&lt;div class=&quot;CodeMirror-sizer&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
btn.addEventListener('click',&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(ev){
    ev.stopPropagation();
    console.log(&lt;/span&gt;'阻止冒泡'&lt;span&gt;)
}, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&quot;wJxWH&quot; data-lake-id=&quot;356af6a34e1931e59a8c3938f381c512&quot;&gt;事件委托（事件代理）&lt;/h2&gt;
&lt;h3 id=&quot;RmVz3&quot; data-lake-id=&quot;b69a9ebf24c46d11fc414c7b15aa6f0c&quot;&gt;原理&lt;/h3&gt;
&lt;p data-lake-id=&quot;b8eb733a39353a271840263e28fd5f8f&quot;&gt;如果有多个DOM节点需要监听事件的情况下，给每个DOM绑定监听函数，会极大的影响页面的性能，因为我们通过事件委托来进行优化，事件委托利用的就是冒泡的原理。&lt;/p&gt;
&lt;div id=&quot;tL1V4&quot; class=&quot;lake-card-margin lake-selected&quot; data-card-type=&quot;block&quot; data-lake-card=&quot;codeblock&quot; data-card-value=&quot;data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%3Cul%3E%5Cn%20%20%20%20%3Cli%3E1%3C%2Fli%3E%5Cn%20%20%20%20%3Cli%3E2%3C%2Fli%3E%5Cn%20%20%20%20%3Cli%3E3%3C%2Fli%3E%5Cn%20%20%20%20%3Cli%3E4%3C%2Fli%3E%5Cn%20%20%20%20%3Cli%3E5%3C%2Fli%3E%5Cn%3C%2Ful%3E%5Cn%3Cscript%3E%5Cn%20%20%20%20var%20li_list%20%3D%20document.getElementsByTagName('li')%5Cn%20%20%20%20for(let%20index%20%3D%200%3Bindex%3Cli_list.length%3Bindex%2B%2B)%7B%5Cn%20%20%20%20%20%20%20%20li_list%5Bindex%5D.addEventListener('click'%2C%20function(ev)%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20console.log(ev.currentTarget.innerHTML)%5Cn%20%20%20%20%20%20%20%20%7D)%5Cn%20%20%20%20%7D%5Cn%3C%2Fscript%3E%22%2C%22heightLimit%22%3Atrue%2C%22margin%22%3Atrue%2C%22id%22%3A%22tL1V4%22%7D&quot; data-language=&quot;javascript&quot;&gt;
&lt;div class=&quot;lake-codeblock-content&quot;&gt;
&lt;div class=&quot;CodeMirror-sizer&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;ul&amp;gt;
    &amp;lt;li&amp;gt;1&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;2&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;3&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;4&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;5&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&amp;lt;script&amp;gt;
    &lt;span&gt;var&lt;/span&gt; li_list = document.getElementsByTagName('li'&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(let index = 0;index&amp;lt;li_list.length;index++&lt;span&gt;){
        li_list[index].addEventListener(&lt;/span&gt;'click', &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(ev){
            console.log(ev.currentTarget.innerHTML)
        })
    }
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p data-lake-id=&quot;c807dc8d0804c24e209bcb5ea2b04873&quot;&gt;正常情况我们给每一个li都会绑定一个事件，但是如果这时候li是动态渲染的，数据又特别大的时候，每次渲染后（有新增的情况）我们还需要重新来绑定，又繁琐又耗性能；这时候我们可以将绑定事件委托到li的父级元素，即ul。&lt;/p&gt;
&lt;div id=&quot;xc0WN&quot; class=&quot;lake-card-margin lake-selected&quot; data-card-type=&quot;block&quot; data-lake-card=&quot;codeblock&quot; data-card-value=&quot;data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22var%20ul_dom%20%3D%20document.getElementsByTagName('ul')%5Cnul_dom%5B0%5D.addEventListener('click'%2C%20function(ev)%7B%20%20%5Cn%20%20%20%20console.log(ev.target.innerHTML)%5Cn%7D)%22%2C%22heightLimit%22%3Atrue%2C%22margin%22%3Atrue%2C%22id%22%3A%22xc0WN%22%7D&quot; data-language=&quot;javascript&quot;&gt;
&lt;div class=&quot;lake-codeblock-content&quot;&gt;
&lt;div class=&quot;CodeMirror-sizer&quot; readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; ul_dom = document.getElementsByTagName('ul'&lt;span&gt;)
ul_dom[&lt;/span&gt;0].addEventListener('click', &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(ev){  
    console.log(ev.target.innerHTML)
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p data-lake-id=&quot;14abc8acf7da41ab708ae26bbae302d7&quot;&gt;target和currentTarget区别：&lt;/p&gt;
&lt;ul data-lake-id=&quot;f4bc7af4fe5dc785cc2d1930246f6e6d&quot;&gt;&lt;li data-lake-id=&quot;aa30f446492676556eb0eb1ba9448d8e&quot;&gt;target返回触发事件的元素，不一定是绑定事件的元素&lt;/li&gt;
&lt;li data-lake-id=&quot;7e16247d7f030c68f42327e4d9ab2384&quot;&gt;currentTarget返回的是绑定事件的元素&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;meCgP&quot; data-lake-id=&quot;ea643c505b3ff961afb371c604977f7d&quot;&gt;优点&lt;/h3&gt;
&lt;ul data-lake-id=&quot;9895c2ef2aade50daa5a41af34539807&quot;&gt;&lt;li data-lake-id=&quot;099824fc05778c6da7010521df903181&quot;&gt;&lt;strong&gt;提高性能:&lt;/strong&gt; 每一个函数都会占用内存空间，只需添加一个事件处理程序代理所有事件，所占用的内存空间更少。&lt;/li&gt;
&lt;li data-lake-id=&quot;66feb49e3d66cccda3258197fe3d24e6&quot;&gt;&lt;strong&gt;动态监听:&lt;/strong&gt; 使用事件委托可以自动绑定动态添加的元素，即新增的节点不需要主动添加也可以一样具有和其他元素一样的事件。&lt;/li&gt;
&lt;/ul&gt;&lt;p data-lake-id=&quot;92d343bde6a742445f77bd009b9d3997&quot;&gt; &lt;/p&gt;
&lt;blockquote readability=&quot;2.010752688172&quot;&gt;
&lt;p data-lake-id=&quot;c93a9746b94ecce970f780a94208e509&quot;&gt;参考自&lt;/p&gt;
&lt;p data-lake-id=&quot;d87c4480de92de1969b23003cf40df47&quot;&gt;JS高级程序设计&lt;/p&gt;
&lt;p data-lake-id=&quot;3a49a53ba129c664e6aebe03c85dd697&quot;&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/114276880&quot; target=&quot;_blank&quot;&gt;https://zhuanlan.zhihu.com/p/114276880&lt;/a&gt;&lt;/p&gt;
&lt;p data-lake-id=&quot;f540d39b7123603425a0137fd113ff30&quot;&gt;&lt;a href=&quot;https://www.jianshu.com/p/7f5f4c74dde8&quot; target=&quot;_blank&quot;&gt;https://www.jianshu.com/p/7f5f4c74dde8&lt;/a&gt;&lt;/p&gt;
&lt;p data-lake-id=&quot;e0e0e530c12d9c584fe992d8caa69fc0&quot;&gt;&lt;a href=&quot;https://www.jianshu.com/p/5d2905584a2f&quot; target=&quot;_blank&quot;&gt;https://www.jianshu.com/p/5d2905584a2f&lt;/a&gt;&lt;/p&gt;
&lt;p data-lake-id=&quot;cbe205194e94f4ce231063a66ea99597&quot;&gt;&lt;a href=&quot;https://www.jianshu.com/p/394e31cc8e7f&quot; target=&quot;_blank&quot;&gt;https://www.jianshu.com/p/394e31cc8e7f&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 02 Sep 2020 00:45:00 +0000</pubDate>
<dc:creator>一只菜鸟攻城狮啊</dc:creator>
<og:description>事件 HTML中与javascript交互是通过事件驱动来实现的，例如鼠标点击事件、页面的滚动事件onscroll等等，可以向文档或者文档中的元素添加事件侦听器来预订事件。想要知道这些事件是在什么时候</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/suihang/p/13599887.html</dc:identifier>
</item>
<item>
<title>拜托！别再问我多线程的这些问题了 - 码农田小齐</title>
<link>http://www.cnblogs.com/nycsde/p/13599879.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nycsde/p/13599879.html</guid>
<description>&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多同学面对多线程的问题都很头大，因为自己做项目很难用到，但是但凡高薪的职位面试都会问到。。毕竟现在大厂里用的都是多线程高并发，所以这块内容不吃透肯定是不行的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天这篇文章，作为多线程的基础篇，先来谈谈以下问题：&lt;/p&gt;
&lt;ol data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;为什么要用多线程？&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;程序 vs 进程 vs 线程&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;创建线程的 4 种方式？&lt;/section&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;为什么要用多线程&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;任何一项技术的出现都是为了解决现有问题。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之前的互联网大多是单机服务，体量小；而现在的更多是集群服务，同一时刻有多个用户同时访问服务器，那么会有很多线程并发访问。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如在电商系统里，同一时刻比如整点抢购时，大量用户同时访问服务器，所以现在公司里开发的基本都是多线程的。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用多线程确实提高了运行的效率，但与此同时，我们也需要特别注意数据的增删改情况，这就是线程安全问题，比如之前说过的 &lt;code&gt;HashMap vs HashTable&lt;/code&gt;，&lt;code&gt;Vector vs ArrayList&lt;/code&gt;。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要保证线程安全也有很多方式，比如说加锁，但又可能会出现其他问题比如死锁，所以多线程相关问题会比较麻烦。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，我们需要理解多线程的原理和它可能会产生的问题以及如何解决问题，才能拿下高薪职位。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;进程 vs 线程&lt;/span&gt;&lt;/h2&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;&lt;strong&gt;程序&lt;/strong&gt; program&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说到进程，就不得不先说说程序。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;程序，说白了就是代码，或者说是一系列指令的集合。比如「微信.exe」这就是一个程序，这个文件最终是要拿到 CPU 里面去执行的。&lt;/p&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;进程 process&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当程序运行起来，它就是一个&lt;strong&gt;进程&lt;/strong&gt;。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以&lt;strong&gt;程序是“死”的，进程是“活”的&lt;/strong&gt;。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如在任务管理器里的就是一个个进程，就是“动起来”的应用程序。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1gibh5rt85mj30n208sgmt.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Q：这些进程是并行执行的吗？&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;单核 CPU 一个时间片里只能执行一个进程。但是因为它切换速度很快，所以我们感受不到，就造成了一种多进程的假象。（多核 CPU 那真的就是并行执行的了。）&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Q：那如果这个进程没执行完呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当进程 A 执行完一个时间片，但是还没执行完时，为了方便下次接着执行，要保存刚刚执行完的这些数据信息，叫做「保存现场」。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后等下次再抢到了资源执行的时候，先「恢复现场」，再开始继续执行。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样循环往复。。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样反复的保存啊、恢复啊，都是额外的开销，也会让程序执行变慢。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Q：有没有更高效的方式呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果两个线程归属同一个进程，就不需要保存、恢复现场了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就是 NIO 模型的思路，也是 NIO 模型比 BIO 模型效率高很多的原因，我们之后再讲。&lt;/p&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;线程 thread&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程，是一个进程里的具体的执行路径，就是真正干活的。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在一个进程里，一个时间片也只能有一个线程在执行，但因为时间片的切换速度非常快，所以看起来就好像是同时进行的。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个进程里至少有一个线程。比如主线程，就是我们平时写的 &lt;code&gt;main()&lt;/code&gt; 函数，是&lt;strong&gt;用户线程&lt;/strong&gt;；还有 &lt;code&gt;gc&lt;/code&gt; 线程是 JVM 生产的，负责垃圾回收，是&lt;strong&gt;守护线程&lt;/strong&gt;。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1gibh5qygc0j30re0ieabr.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个线程有自己的&lt;strong&gt;栈&lt;/strong&gt; &lt;code&gt;stack&lt;/code&gt;，记录该线程里面的方法相互调用的关系；&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是一个进程里的所有线程是&lt;strong&gt;共用堆&lt;/strong&gt; &lt;code&gt;heap&lt;/code&gt; 的。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么不同的进程之间是不可以互相访问内存的，每个进程有自己的&lt;strong&gt;内存空间&lt;/strong&gt; &lt;code&gt;memeory space&lt;/code&gt;，也就是&lt;strong&gt;虚拟内存&lt;/strong&gt; &lt;code&gt;virtual memory&lt;/code&gt;。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;通过这个虚拟内存，每一个进程都感觉自己拥有了整个内存空间。&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虚拟内存的机制，就是屏蔽了物理内存的限制。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Q：那如果物理内存被用完了呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用硬盘，比如 windows 系统的分页文件，就是把一部分虚拟内存放到了硬盘上。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相应的，此时程序运行会很慢，因为硬盘的读写速度比内存慢很多，是我们可以感受到的慢，这就是为什么开多了程序电脑就会变卡的原因。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Q：那这个虚拟内存是有多大呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于 64 位操作系统来说，每个程序可以用 64 个二进制位，也就是 &lt;code&gt;2^64&lt;/code&gt; 这么大的空间！&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果还不清楚二进制相关内容的，公众号内回复「二进制」获取相应的文章哦～&lt;/p&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;总结&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总结一下，在一个时间片里，一个 CPU 只能执行一个进程。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CPU 给某个进程分配资源后，这个进程开始运行；进程里的线程去抢占资源，一个时间片就只有一个线程能执行，谁先抢到就是谁的。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1gibh5l9g4uj31jo0jitgy.jpg&quot; alt=&quot;&quot;/&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;多进程 vs 多线程&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个进程是独立的，进程 A 出问题不会影响到进程 B；&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然线程也是独立运行的，但是一个进程里的线程是共用同一个堆，如果某个线程 &lt;code&gt;out of memory&lt;/code&gt;，那么这个进程里所有的线程都完了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;所以多进程能够提高系统的容错性 &lt;code&gt;fault tolerance&lt;/code&gt; ，而多线程最大的好处就是线程间的通信非常方便。&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;进程之间的通信需要借助额外的机制，比如进程间通讯 &lt;code&gt;interprocess communication&lt;/code&gt; - &lt;code&gt;IPC&lt;/code&gt;，或者网络传递等等。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;如何创建线程&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面说了一堆概念，接下来我们看具体实现。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 中是通过 &lt;code&gt;java.lang.Thread&lt;/code&gt; 这个类来实现多线程的功能的，那我们先来看看这个类。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从文档中我们可以看到，&lt;code&gt;Thread&lt;/code&gt; 类是直接继承 &lt;code&gt;Object&lt;/code&gt; 的，同时它也是实现了 &lt;code&gt;Runnable&lt;/code&gt; 接口。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;官方文档里也写明了 2 种创建线程的方式：&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一种方式是从 &lt;code&gt;Thread&lt;/code&gt; 类继承，并重写 &lt;code&gt;run()&lt;/code&gt;，&lt;code&gt;run()&lt;/code&gt; 方法里写的是这个线程要执行的代码；&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;启动时通过 &lt;code&gt;new&lt;/code&gt; 这个 &lt;code&gt;class&lt;/code&gt; 的一个实例，调用 &lt;code&gt;start()&lt;/code&gt; 方法启动线程。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1gibxy3g4z1j30j50a0t9v.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;二是实现 &lt;code&gt;Runnable&lt;/code&gt; 接口，并实现 &lt;code&gt;run()&lt;/code&gt;，&lt;code&gt;run()&lt;/code&gt; 方法里同样也写的是这个线程要执行的代码；&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;稍有不同的是启动线程，需要 &lt;code&gt;new&lt;/code&gt; 一个线程，并把刚刚创建的这个实现了 &lt;code&gt;Runnable&lt;/code&gt; 接口的类的实例传进去，再调用 &lt;code&gt;start()&lt;/code&gt;，这其实是&lt;strong&gt;代理模式&lt;/strong&gt;。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1gibxyizainj30jb0a8gmr.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果面试官问你，还有没有其他的，那还可以说：&lt;/p&gt;
&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li readability=&quot;-2&quot;&gt;
&lt;section readability=&quot;2&quot;&gt;&lt;p&gt;&lt;strong&gt;实现 &lt;code&gt;Callable&lt;/code&gt; 接口&lt;/strong&gt;；&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;
&lt;section readability=&quot;2&quot;&gt;&lt;p&gt;&lt;strong&gt;通过线程池来启动一个线程。&lt;/strong&gt;&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但其实，用线程池来启动线程时也是用的前两种方式之一创建的。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这两种方式在这里就不细说啦，我们具体来看前两种方式。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;继承 Thread 类&lt;/span&gt;&lt;/h3&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;MyThread&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Thread&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;; i++) {&lt;br/&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;小齐666：&quot;&lt;/span&gt; + i);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;MyThread myThread = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; MyThread();&lt;br/&gt;myThread.start();&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;; i++) {&lt;br/&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;主线程&quot;&lt;/span&gt; + i + &lt;span class=&quot;hljs-string&quot;&gt;&quot;：齐姐666&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这里，&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li readability=&quot;-2&quot;&gt;
&lt;section readability=&quot;2&quot;&gt;&lt;p&gt;&lt;code&gt;main&lt;/code&gt; 函数是主线程，是程序的入口，执行整个程序；&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;
&lt;li readability=&quot;-1.5&quot;&gt;
&lt;section readability=&quot;3&quot;&gt;&lt;p&gt;程序开始执行后先启动了一个新的线程 &lt;code&gt;myThread&lt;/code&gt;，在这个线程里输出“小齐”；&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;
&lt;section readability=&quot;2&quot;&gt;&lt;p&gt;主线程并行执行，并输出“主线程i：齐姐”。&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1gibxrncy7nj317g0r4af9.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;来看下结果，就是两个线程交替夸我嘛～&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1gibxemzc88j30bc0eywfr.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Q：为啥和我运行的结果不一样？&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;多线程中，每次运行的结果可能都会不一样，因为我们无法人为控制哪条线程在什么时刻先抢到资源。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然了，我们可以给线程加上优先级 &lt;code&gt;priority&lt;/code&gt;，但高优先级也无法保证这条线程一定能先被执行，只能说有更大的概率抢到资源先执行。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;实现 Runnable 接口&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方式用的更多。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;5&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;4&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;MyRunnable&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Runnable&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;; i++) {&lt;br/&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;小齐666：&quot;&lt;/span&gt; + i);&lt;br/&gt;}&lt;br/&gt;}&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Thread(&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; MyRunnable()).start();&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;; i++) {&lt;br/&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;主线程&quot;&lt;/span&gt; + i + &lt;span class=&quot;hljs-string&quot;&gt;&quot;：齐姐666&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结果也差不多：&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1gibxfj8374j30bi0fmgmz.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;像前文所说，这里线程启动的方式和刚才的稍有不同，因为新建的的这个类只是实现了 &lt;code&gt;Runnable&lt;/code&gt; 接口，所以还需要一个线程来“代理”执行它，所以需要把我们新建的这个类的实例传入到一个线程里，这里其实是&lt;strong&gt;代理模式&lt;/strong&gt;。这个设计模式之后再细讲。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;小结&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那这两种方式哪种好呢？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 Runnable 接口更好，主要原因是 Java 单继承。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外需要注意的是，在启动线程的的时候用的是 &lt;code&gt;start()&lt;/code&gt;，而不是 &lt;code&gt;run()&lt;/code&gt;。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;调用 &lt;code&gt;run()&lt;/code&gt; 仅仅是调用了这个方法，是普通的方法调用；而 &lt;code&gt;start()&lt;/code&gt; 才是启动线程，然后由 JVM 去调用该线程的 &lt;code&gt;run()&lt;/code&gt; 。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，以上就是多线程第一篇的所有内容了，这里主要是帮助大家复习一下基础概念，以及没有接触的小伙伴可以入门。想看更多关于多线程的内容的话，记得给我点赞留言哦～&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;我是小齐，终身学习者，每晚 9 点，自习室里我们不见不散 ❤️&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 02 Sep 2020 00:40:00 +0000</pubDate>
<dc:creator>码农田小齐</dc:creator>
<og:description>很多同学面对多线程的问题都很头大，因为自己做项目很难用到，但是但凡高薪的职位面试都会问到。。毕竟现在大厂里用的都是多线程高并发，所以这块内容不吃透肯定是不行的。 今天这篇文章，作为多线程的基础篇，先来</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/nycsde/p/13599879.html</dc:identifier>
</item>
<item>
<title>Python开发的入门教程(九)-列表生成式 - 谁主沉浮oo7</title>
<link>http://www.cnblogs.com/feifuzeng/p/13541173.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/feifuzeng/p/13541173.html</guid>
<description>&lt;h2 id=&quot;介绍&quot;&gt;介绍&lt;/h2&gt;
&lt;p&gt;本文主要介绍Python中&lt;strong&gt;列表生成式&lt;/strong&gt;的基本知识和使用&lt;/p&gt;
&lt;h2 id=&quot;生成列表&quot;&gt;生成列表&lt;/h2&gt;
&lt;p&gt;要生成list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]，我们可以用range(1, 11)：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; range(1, 11)
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但如果要生成[1x1, 2x2, 3x3, ..., 10x10]怎么做？方法一是循环：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; L = []
&amp;gt;&amp;gt;&amp;gt; for x in range(1, 11):
...    L.append(x * x)
... 
&amp;gt;&amp;gt;&amp;gt; L
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是循环太繁琐，而列表生成式则可以用一行语句代替循环生成上面的list：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; [x * x for x in range(1, 11)]
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种写法就是Python特有的列表生成式。利用列表生成式，可以以非常简洁的代码生成 list。&lt;/p&gt;
&lt;p&gt;写列表生成式时，把要生成的元素 x * x 放到前面，后面跟 for 循环，就可以把list创建出来，十分有用，多写几次，很快就可以熟悉这种语法。&lt;/p&gt;
&lt;h2 id=&quot;复杂表达式-todo&quot;&gt;复杂表达式 (TODO)&lt;/h2&gt;
&lt;p&gt;使用for循环的迭代不仅可以迭代普通的list，还可以迭代dict。&lt;/p&gt;
&lt;p&gt;假设有如下的dict：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;d = { 'Adam': 95, 'Lisa': 85, 'Bart': 59 }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;完全可以通过一个复杂的列表生成式把它变成一个 HTML 表格：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;tds = ['&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;%s&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;%s&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;' % (name, score) for name, score in d.iteritems()]
print '&amp;lt;table&amp;gt;'
print '&amp;lt;tr&amp;gt;&amp;lt;th&amp;gt;Name&amp;lt;/th&amp;gt;&amp;lt;th&amp;gt;Score&amp;lt;/th&amp;gt;&amp;lt;tr&amp;gt;'
print '\n'.join(tds)
print '&amp;lt;/table&amp;gt;'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注：字符串可以通过 % 进行格式化，用指定的参数替代 %s。字符串的join()方法可以把一个 list 拼接成一个字符串。&lt;/p&gt;
&lt;p&gt;把打印出来的结果保存为一个html文件，就可以在浏览器中看到效果了：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;table border=&quot;1&quot;&amp;gt;
&amp;lt;tr&amp;gt;&amp;lt;th&amp;gt;Name&amp;lt;/th&amp;gt;&amp;lt;th&amp;gt;Score&amp;lt;/th&amp;gt;&amp;lt;tr&amp;gt;
&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;Lisa&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;85&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;
&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;Adam&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;95&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;
&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;Bart&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;59&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;
&amp;lt;/table&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;条件过滤&quot;&gt;条件过滤&lt;/h2&gt;
&lt;p&gt;列表生成式的 for 循环后面还可以加上 if 判断。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; [x * x for x in range(1, 11)]
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果我们只想要偶数的平方，不改动 range()的情况下，可以加上 if 来筛选：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; [x * x for x in range(1, 11) if x % 2 == 0]
[4, 16, 36, 64, 100]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有了 if 条件，只有 if 判断为 True 的时候，才把循环的当前元素添加到列表中。&lt;/p&gt;
&lt;h2 id=&quot;多层表达式&quot;&gt;多层表达式&lt;/h2&gt;
&lt;p&gt;for循环可以嵌套，因此，在列表生成式中，也可以用多层 for 循环来生成列表。&lt;br/&gt;对于字符串 'ABC' 和 '123'，可以使用两层循环，生成全排列：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; [m + n for m in 'ABC' for n in '123']
['A1', 'A2', 'A3', 'B1', 'B2', 'B3', 'C1', 'C2', 'C3']
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;翻译成循环代码就像下面这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;L = []
for m in 'ABC':
    for n in '123':
        L.append(m + n)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;结语&quot;&gt;结语&lt;/h2&gt;
&lt;p&gt;欢迎关注微信公众号『码仔zonE』，专注于分享Java、云计算相关内容，包括SpringBoot、SpringCloud、微服务、Docker、Kubernetes、Python等领域相关技术干货，期待与您相遇！&lt;br/&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/c4sDyQ4RqeSvZzxFxWLrhb94asLZsOiagMmXhYl1MMAqkzygAR4DbuLdGQALFujG5M1kuXOc04JfS28lRqO8ZQg/0?wx_fmt=png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 02 Sep 2020 00:39:00 +0000</pubDate>
<dc:creator>谁主沉浮oo7</dc:creator>
<og:description>介绍 本文主要介绍Python中列表生成式的基本知识和使用 生成列表 要生成list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]，我们可以用range(1, 11)： &amp;amp;g</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/feifuzeng/p/13541173.html</dc:identifier>
</item>
<item>
<title>总结java中文件拷贝剪切的5种方式-JAVA IO基础总结第五篇 - 字母哥博客</title>
<link>http://www.cnblogs.com/zimug/p/13599866.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zimug/p/13599866.html</guid>
<description>[unable to retrieve full-text content]本文是Java IO总结系列篇的第5篇，前篇的访问地址如下： 总结java中创建并写文件的5种方式-JAVA IO基础总结第一篇 总结java从文件中读取数据的6种方法-JAVA IO基础总结第二篇 总结java创建文件夹的4种方法及其优缺点-JAVA IO基础总结第三篇 总结java中删除文件或文</description>
<pubDate>Wed, 02 Sep 2020 00:35:00 +0000</pubDate>
<dc:creator>字母哥博客</dc:creator>
<dc:identifier>https://www.cnblogs.com/zimug/p/13599866.html</dc:identifier>
</item>
<item>
<title>用 Java 拿下 HTML 分分钟写个小爬虫 - 削微寒</title>
<link>http://www.cnblogs.com/xueweihan/p/13595654.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xueweihan/p/13595654.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;本文适合有 Java 基础知识的人群&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202009/759200-20200901132548961-938462130.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;本文作者：HelloGitHub-&lt;strong&gt;秦人&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;HelloGitHub 推出的&lt;a href=&quot;https://github.com/HelloGitHub-Team/Article&quot;&gt;《讲解开源项目》&lt;/a&gt;系列，今天给大家带来一款开源 Java 版一款网页元素解析框架——jsoup，通过程序自动获取网页数据。&lt;/p&gt;
&lt;blockquote readability=&quot;2.1428571428571&quot;&gt;
&lt;p&gt;项目源码地址：&lt;a href=&quot;https://github.com/jhy/jsoup&quot;&gt;https://github.com/jhy/jsoup&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一、项目介绍&quot;&gt;一、项目介绍&lt;/h2&gt;
&lt;p&gt;jsoup 是一款 Java 的 HTML 解析器。可直接解析某个 URL 地址的 HTML 文本内容。它提供了一套很省力的 API，可通过 DOM、CSS 以及类似于 jQuery 选择器的操作方法来取出和操作数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;jsoup 主要功能：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;从一个 URL、文件或字符串中解析 HTML。&lt;/li&gt;
&lt;li&gt;使用 DOM 或 CSS 选择器来查找、取出数据。&lt;/li&gt;
&lt;li&gt;可操作 HTML 元素、属性、文本。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;二、使用框架&quot;&gt;二、使用框架&lt;/h2&gt;
&lt;h3 id=&quot;21-准备工作&quot;&gt;2.1 准备工作&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;掌握 HTML 语法&lt;/li&gt;
&lt;li&gt;Chrome 浏览器调试技巧&lt;/li&gt;
&lt;li&gt;掌握开发工具 idea 的基本操作&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;22-学习源码&quot;&gt;2.2 学习源码&lt;/h3&gt;
&lt;p&gt;将项目导入 idea 开发工具，会自动下载 maven 项目需要的依赖。源码的项目结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202009/759200-20200901132557457-138154238.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;快速学习源码&lt;/strong&gt;是每个程序员必备的技能，我总结了以下几点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;阅读项目 &lt;code&gt;ReadMe&lt;/code&gt; 文件，可以快速知道项目是做什么的。&lt;/li&gt;
&lt;li&gt;概览项目 &lt;code&gt;pom.xml&lt;/code&gt; 文件，了解项目引用了哪些依赖。&lt;/li&gt;
&lt;li&gt;查看项目结构、源码目录、测试用例目录，好的项目结构清晰，层次明确。&lt;/li&gt;
&lt;li&gt;运行测试用例，快速体验项目。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;23-下载项目&quot;&gt;2.3 下载项目&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;git clone https://github.com/jhy/jsoup
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;24-运行项目测试代码&quot;&gt;2.4 运行项目测试代码&lt;/h3&gt;
&lt;p&gt;通过上面的方法，我们很快可知 &lt;code&gt;example&lt;/code&gt; 目录是测试代码，那我们直接来运行。注：有些测试代码需要稍微改造一下才可以运行。&lt;/p&gt;
&lt;p&gt;例如，jsoup 的 Wikipedia 测试代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Wikipedia {
    public static void main(String[] args) throws IOException {
        Document doc = Jsoup.connect(&quot;http://en.wikipedia.org/&quot;).get();
        log(doc.title());

        Elements newsHeadlines = doc.select(&quot;#mp-itn b a&quot;);
        for (Element headline : newsHeadlines) {
            log(&quot;%s\n\t%s&quot;, headline.attr(&quot;title&quot;), headline.absUrl(&quot;href&quot;));
        }
    }

    private static void log(String msg, String... vals) {
        System.out.println(String.format(msg, vals));
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;说明：上面代码是获取页面（&lt;a href=&quot;http://en.wikipedia.org/%EF%BC%89%E5%8C%85%E5%90%AB%EF%BC%88#mp-itn&quot;&gt;http://en.wikipedia.org/）包含（#mp-itn&lt;/a&gt; b a）选择器的所有元素，并打印这些元素的 &lt;code&gt;title&lt;/code&gt; , &lt;code&gt;herf&lt;/code&gt; 属性。 &lt;code&gt;维基百科&lt;/code&gt; 国内无法访问，所以上面这段代码运行会报错。&lt;/p&gt;
&lt;p&gt;改造后可运行的代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static void main(String[] args) throws IOException {
    Document doc = Jsoup.connect(&quot;https://www.baidu.com/&quot;).get();
    Elements newsHeadlines = doc.select(&quot;a[href]&quot;);
    for (Element headline : newsHeadlines) {
        System.out.println(&quot;href: &quot; +headline.absUrl(&quot;href&quot;) );
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;三、工作原理&quot;&gt;三、工作原理&lt;/h2&gt;
&lt;p&gt;Jsoup 的工作原理，首先需要指定一个 URL，框架发送 HTTP 请求，然后获取响应页面内容，然后通过各种选择器获取页面数据。整个工作流程如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202009/759200-20200901132607662-794371287.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以上面为例：&lt;/p&gt;
&lt;h3 id=&quot;31-发请求&quot;&gt;3.1 发请求&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Document doc = Jsoup.connect(&quot;https://www.baidu.com/&quot;).get();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这行代码就是发送 HTTP 请求，并获取页面响应数据。&lt;/p&gt;
&lt;h3 id=&quot;32-数据筛选&quot;&gt;3.2 数据筛选&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Elements newsHeadlines = doc.select(&quot;a[href]&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;定义选择器，获取匹配选择器的数据。&lt;/p&gt;
&lt;h3 id=&quot;33-数据处理&quot;&gt;3.3 数据处理&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;for (Element headline : newsHeadlines) {
        System.out.println(&quot;href: &quot; +headline.absUrl(&quot;href&quot;) );
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里对数据只做了一个简单的数据打印，当然这些数据可写入文件或数据的。&lt;/p&gt;
&lt;h2 id=&quot;四、实战&quot;&gt;四、实战&lt;/h2&gt;
&lt;p&gt;获取&lt;strong&gt;豆瓣读书&lt;/strong&gt; -&amp;gt; &lt;strong&gt;新书速递&lt;/strong&gt;中每本新书的基本信息。包括：书名、书图片链接、作者、内容简介（详情页面）、作者简介（详情页面）、当当网书的价格（详情页面），最后将获取的数据保存到 Excel 文件。&lt;/p&gt;
&lt;p&gt;目标链接：&lt;code&gt;https://book.douban.com/latest?icn=index-latestbook-all&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;41-项目-pomxml-文件&quot;&gt;4.1 项目 pom.xml 文件&lt;/h3&gt;
&lt;p&gt;项目引入 jsoup、lombok、easyexcel 三个库。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

    &amp;lt;groupId&amp;gt;org.example&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;JsoupTest&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;properties&amp;gt;
        &amp;lt;maven.compiler.target&amp;gt;1.8&amp;lt;/maven.compiler.target&amp;gt;
        &amp;lt;maven.compiler.source&amp;gt;1.8&amp;lt;/maven.compiler.source&amp;gt;
    &amp;lt;/properties&amp;gt;
    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.jsoup&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;jsoup&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.13.1&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.18.12&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;easyexcel&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;2.2.6&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;
&amp;lt;/project&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;42-解析页面数据&quot;&gt;4.2 解析页面数据&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class BookInfoUtils {

    public static List&amp;lt;BookEntity&amp;gt; getBookInfoList(String url) throws IOException {
        List&amp;lt;BookEntity&amp;gt;  bookEntities=new ArrayList&amp;lt;&amp;gt;();
        Document doc = Jsoup.connect(url).get();
        Elements liDiv = doc.select(&quot;#content &amp;gt; div &amp;gt; div.article &amp;gt; ul &amp;gt; li&quot;);
        for (Element li : liDiv) {
            Elements urls = li.select(&quot;a[href]&quot;);
            Elements imgUrl = li.select(&quot;a &amp;gt; img&quot;);
            Elements bookName = li.select(&quot; div &amp;gt; h2 &amp;gt; a&quot;);
            Elements starsCount = li.select(&quot; div &amp;gt; p.rating &amp;gt; span.font-small.color-lightgray&quot;);
            Elements author = li.select(&quot;div &amp;gt; p.color-gray&quot;);
            Elements description = li.select(&quot; div &amp;gt; p.detail&quot;);

            String bookDetailUrl = urls.get(0).attr(&quot;href&quot;);
            BookDetailInfo detailInfo = getDetailInfo(bookDetailUrl);
            BookEntity bookEntity = BookEntity.builder()
                    .detailPageUrl(bookDetailUrl)
                    .bookImgUrl(imgUrl.attr(&quot;src&quot;))
                    .bookName(bookName.html())
                    .starsCount(starsCount.html())
                    .author(author.text())
                    .bookDetailInfo(detailInfo)
                    .description(description.html())
                    .build();
//            System.out.println(bookEntity);
            bookEntities.add(bookEntity);
        }
        return bookEntities;
    }
    /**
     *
     * @param detailUrl
     * @return
     * @throws IOException
     */
    public static BookDetailInfo getDetailInfo(String detailUrl)throws IOException{

        Document doc = Jsoup.connect(detailUrl).get();
        Elements content = doc.select(&quot;body&quot;);

        Elements price = content.select(&quot;#buyinfo-printed &amp;gt; ul.bs.current-version-list &amp;gt; li:nth-child(2) &amp;gt; div.cell.price-btn-wrapper &amp;gt; div.cell.impression_track_mod_buyinfo &amp;gt; div.cell.price-wrapper &amp;gt; a &amp;gt; span&quot;);
        Elements author = content.select(&quot;#info &amp;gt; span:nth-child(1) &amp;gt; a&quot;);
        BookDetailInfo bookDetailInfo = BookDetailInfo.builder()
                .author(author.html())
                .authorUrl(author.attr(&quot;href&quot;))
                .price(price.html())
                .build();
        return bookDetailInfo;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的重点是要获取网页对应元素的&lt;strong&gt;选择器&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;例如：获取 &lt;code&gt;li.select(&quot;div &amp;gt; p.color-gray&quot;)&lt;/code&gt; 中 &lt;code&gt;div &amp;gt; p.color-gray&lt;/code&gt; 是怎么知道的。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;chrome&lt;/code&gt; 的小伙伴应该都猜到了。打开 &lt;code&gt;chrome&lt;/code&gt; 浏览器 &lt;code&gt;Debug&lt;/code&gt; 模式，&lt;code&gt;Ctrl + Shift +C&lt;/code&gt; 选择一个元素,然后在 &lt;code&gt;html&lt;/code&gt; 右键选择 &lt;code&gt;Copy&lt;/code&gt; -&amp;gt;&lt;code&gt;Copy selector&lt;/code&gt;,这样就可以获取当前元素的&lt;code&gt;选择器&lt;/code&gt;。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202009/759200-20200901132619497-925313880.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;43-存储数据到-excel&quot;&gt;4.3 存储数据到 Excel&lt;/h3&gt;
&lt;p&gt;为了数据更好查看，我将通过 jsoup 抓取的数据存储的 Excel 文件，这里我使用的 easyexcel 快速生成 Excel 文件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Excel 表头信息&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Data
@Builder
public class ColumnData {

    @ExcelProperty(&quot;书名称&quot;)
    private String bookName;

    @ExcelProperty(&quot;评分&quot;)
    private String starsCount;

    @ExcelProperty(&quot;作者&quot;)
    private String author;

    @ExcelProperty(&quot;封面图片&quot;)
    private String bookImgUrl;

    @ExcelProperty(&quot;简介&quot;)
    private String description;

    @ExcelProperty(&quot;单价&quot;)
    private String price;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;生成 Excel 文件&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class EasyExcelUtils {

    public static void simpleWrite(List&amp;lt;BookEntity&amp;gt; bookEntityList) {
        String fileName = &quot;D:\\devEnv\\JsoupTest\\bookList&quot; + System.currentTimeMillis() + &quot;.xlsx&quot;;
        EasyExcel.write(fileName, ColumnData.class).sheet(&quot;书本详情&quot;).doWrite(data(bookEntityList));
        System.out.println(&quot;excel文件生成完毕...&quot;);
    }
    private static List&amp;lt;ColumnData&amp;gt; data(List&amp;lt;BookEntity&amp;gt; bookEntityList) {
        List&amp;lt;ColumnData&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        bookEntityList.forEach(b -&amp;gt; {
            ColumnData data = ColumnData.builder()
                    .bookName(b.getBookName())
                    .starsCount(b.getStarsCount())
                    .author(b.getBookDetailInfo().getAuthor())
                    .bookImgUrl(b.getBookImgUrl())
                    .description(b.getDescription())
                    .price(b.getBookDetailInfo().getPrice())
                    .build();
            list.add(data);
        });
        return list;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;44-最终展示效果&quot;&gt;4.4 最终展示效果&lt;/h3&gt;
&lt;p&gt;最终的效果如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202009/759200-20200901132627801-1288747357.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以上就是从想法到实践，我们就在实战中使用了 jsoup 的基本操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;完整代码地址：&lt;a href=&quot;https://github.com/hellowHuaairen/JsoupTest&quot;&gt;https://github.com/hellowHuaairen/JsoupTest&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;五、最后&quot;&gt;五、最后&lt;/h2&gt;
&lt;p&gt;Java HTML Parser 库：jsoup，把它当成简单的爬虫，用起来还是很方便的吧？&lt;/p&gt;
&lt;p&gt;为什么会讲爬虫？大数据，人工智能时代玩的就是数据，数据很重要。作为懂点技术的我们，也需要掌握一种获取网络数据的技能。当然也有一些工具 Fiddler、webscraper 等也可以抓取你想要的数据。&lt;/p&gt;
&lt;p&gt;教程至此，你应该也能对 jsoup 有一些感觉了吧。编程是不是也特别有意思呢？参考我上面的实战案例，有好多网站可以实践一下啦～欢迎在评论区晒你的实战。&lt;/p&gt;
&lt;h2 id=&quot;六、参考资料&quot;&gt;六、参考资料&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202008/759200-20200825184537931-2074943966.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关注 HelloGitHub 公众号&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 02 Sep 2020 00:34:00 +0000</pubDate>
<dc:creator>削微寒</dc:creator>
<og:description>本文适合有 Java 基础知识的人群 本文作者：HelloGitHub-秦人 HelloGitHub 推出的《讲解开源项目》系列，今天给大家带来一款开源 Java 版一款网页元素解析框架——jsoup</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xueweihan/p/13595654.html</dc:identifier>
</item>
<item>
<title>ent orm笔记4---Code Generation - syncd</title>
<link>http://www.cnblogs.com/zhaof/p/13599609.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhaof/p/13599609.html</guid>
<description>&lt;p&gt;在前面几篇文章中，我们经常使用的可能就是entc这个命令了，entc这个工具给带来了很多功能，这篇文章主要整理关于ent orm 中Code Generation&lt;/p&gt;
&lt;p&gt;之前的例子中有个知识点少整理了，就是关于如果我们想要看orm在执行过程中详细原生sql语句是可以开启Debug看到的，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;client, err := ent.Open(&quot;mysql&quot;, &quot;root:123456@tcp(10.211.55.3:3306)/graph_traversal?parseTime=True&quot;,ent.Debug())
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;序言&quot;&gt;序言&lt;/h2&gt;
&lt;h3 id=&quot;initialize-a-new-schema&quot;&gt;Initialize A New Schema&lt;/h3&gt;
&lt;p&gt;通过类似如下命令可以生成Schema 模板：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;entc init User Pet
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;init 将在ent/schema 目录下创建两个schema user.go 和 pet.go ,如果ent目录不存在，则会创建&lt;/p&gt;
&lt;h3 id=&quot;generate-assets&quot;&gt;Generate Assets&lt;/h3&gt;
&lt;p&gt;在添加了fields 和 edges 后，可以在项目的根目录运行entc generate 或者使用go generate 生成代码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;go generate ./ent
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Generate 命令生成以下内容：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;用于与graph 交互的Client 和Tx对象&lt;/li&gt;
&lt;li&gt;schema 的CRUD生成器&lt;/li&gt;
&lt;li&gt;每个schema类型的Entity对象&lt;/li&gt;
&lt;li&gt;用于与构建交互的常量和断言&lt;/li&gt;
&lt;li&gt;SQL方言的migrate 包&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;version-compatibility-between-entc-and-ent&quot;&gt;Version Compatibility Between &lt;code&gt;entc&lt;/code&gt; And &lt;code&gt;ent&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;这里主要是关于在项目中使用ent 的时候ent的版本要和entc的包的版本相同，并且项目中使用Go modules 进行包管理&lt;/p&gt;
&lt;h3 id=&quot;code-generation-options&quot;&gt;Code Generation Options&lt;/h3&gt;
&lt;p&gt;要了解更多关于 codegen 选项的信息，entc generate -h ：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;generate go code for the schema directory

Usage:
  entc generate [flags] path

Examples:
  entc generate ./ent/schema
  entc generate github.com/a8m/x

Flags:
      --header string                           override codegen header
  -h, --help                                    help for generate
      --idtype [int int64 uint uint64 string]   type of the id field (default int)
      --storage string                          storage driver to support in codegen (default &quot;sql&quot;)
      --target string                           target directory for codegen
      --template strings                        external templates to execute

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;storage&quot;&gt;Storage&lt;/h3&gt;
&lt;p&gt;entc 可以为 SQL 和 Gremlin 方言生成资产。&lt;/p&gt;
&lt;h3 id=&quot;external-templates&quot;&gt;External Templates&lt;/h3&gt;
&lt;p&gt;接受要执行的外部 Go 模板。如果模板名称已经由 entc 定义，它将覆盖现有的名称。否则，它将把执行输出写入与模板同名的文件。Flag 格式支持如下文件、目录和 glob:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;entc generate --template &amp;lt;dir-path&amp;gt; --template glob=&quot;path/to/*.tmpl&quot; ./ent/schema
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;更多的信息和例子可以在外部模板文档中找到&lt;/p&gt;
&lt;h3 id=&quot;use-entc-as-a-package&quot;&gt;Use &lt;code&gt;entc&lt;/code&gt; As A Package&lt;/h3&gt;
&lt;p&gt;运行 entc 的另一个选项是将其作为一个包使用，如下所示:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;package main

import (
    &quot;log&quot;

    &quot;github.com/facebook/ent/entc&quot;
    &quot;github.com/facebook/ent/entc/gen&quot;
    &quot;github.com/facebook/ent/schema/field&quot;
)

func main() {
    err := entc.Generate(&quot;./schema&quot;, &amp;amp;gen.Config{
        Header: &quot;// Your Custom Header&quot;,
        IDType: &amp;amp;field.TypeInfo{Type: field.TypeInt},
    })
    if err != nil {
        log.Fatal(&quot;running ent codegen:&quot;, err)
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;schema-description&quot;&gt;Schema Description&lt;/h3&gt;
&lt;p&gt;如果想要得到我们定义的schema的描述信息，可以通过如下命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;entc describe ./ent/schema
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以之前的例子中执行效果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;User:
        +-------+--------+--------+----------+----------+---------+---------------+-----------+-----------------------+------------+
        | Field |  Type  | Unique | Optional | Nillable | Default | UpdateDefault | Immutable |       StructTag       | Validators |
        +-------+--------+--------+----------+----------+---------+---------------+-----------+-----------------------+------------+
        | id    | &amp;lt;nil&amp;gt;  | false  | false    | false    | false   | false         | false     | json:&quot;id,omitempty&quot;   |          0 |
        | name  | string | false  | false    | false    | false   | false         | false     | json:&quot;name,omitempty&quot; |          0 |
        +-------+--------+--------+----------+----------+---------+---------------+-----------+-----------------------+------------+
        +-----------+------+---------+-----------+----------+--------+----------+
        |   Edge    | Type | Inverse |  BackRef  | Relation | Unique | Optional |
        +-----------+------+---------+-----------+----------+--------+----------+
        | followers | User | true    | following | M2M      | false  | true     |
        | following | User | false   |           | M2M      | false  | true     |
        +-----------+------+---------+-----------+----------+--------+----------+

&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;crud-api&quot;&gt;CRUD API&lt;/h2&gt;
&lt;h3 id=&quot;create-a-new-client&quot;&gt;Create A New Client&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;MySQL&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;package main

import (
    &quot;log&quot;

    &quot;&amp;lt;project&amp;gt;/ent&quot;

    _ &quot;github.com/go-sql-driver/mysql&quot;
)

func main() {
    client, err := ent.Open(&quot;mysql&quot;, &quot;&amp;lt;user&amp;gt;:&amp;lt;pass&amp;gt;@tcp(&amp;lt;host&amp;gt;:&amp;lt;port&amp;gt;)/&amp;lt;database&amp;gt;?parseTime=True&quot;)
    if err != nil {
        log.Fatal(err)
    }
    defer client.Close()
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;PostgreSQL&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;package main

import (
    &quot;log&quot;

    &quot;&amp;lt;project&amp;gt;/ent&quot;

    _ &quot;github.com/lib/pq&quot;
)

func main() {
    client, err := ent.Open(&quot;postgres&quot;,&quot;host=&amp;lt;host&amp;gt; port=&amp;lt;port&amp;gt; user=&amp;lt;user&amp;gt; dbname=&amp;lt;database&amp;gt; password=&amp;lt;pass&amp;gt;&quot;)
    if err != nil {
        log.Fatal(err)
    }
    defer client.Close()
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;SQLite&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;package main

import (
    &quot;log&quot;

    &quot;&amp;lt;project&amp;gt;/ent&quot;

    _ &quot;github.com/mattn/go-sqlite3&quot;
)

func main() {
    client, err := ent.Open(&quot;sqlite3&quot;, &quot;file:ent?mode=memory&amp;amp;cache=shared&amp;amp;_fk=1&quot;)
    if err != nil {
        log.Fatal(err)
    }
    defer client.Close()
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Gremlin (AWS Neptune)&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;package main

import (
    &quot;log&quot;

    &quot;&amp;lt;project&amp;gt;/ent&quot;
)

func main() {
    client, err := ent.Open(&quot;gremlin&quot;, &quot;http://localhost:8182&quot;)
    if err != nil {
        log.Fatal(err)
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;create-an-entity&quot;&gt;Create An Entity&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Save&lt;/strong&gt; a user.&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;a8m, err := client.User.    // UserClient.
    Create().               // User create builder.
    SetName(&quot;a8m&quot;).         // Set field value.
    SetNillableAge(age).    // Avoid nil checks.
    AddGroups(g1, g2).      // Add many edges.
    SetSpouse(nati).        // Set unique edge.
    Save(ctx)               // Create and return.
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;SaveX&lt;/strong&gt; a pet; Unlike &lt;strong&gt;Save&lt;/strong&gt;, &lt;strong&gt;SaveX&lt;/strong&gt; panics if an error occurs.&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;pedro := client.Pet.    // PetClient.
    Create().           // Pet create builder.
    SetName(&quot;pedro&quot;).   // Set field value.
    SetOwner(a8m).      // Set owner (unique edge).
    SaveX(ctx)          // Create and return.
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;create-many&quot;&gt;Create Many&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Save&lt;/strong&gt; a bulk of pets&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;names := []string{&quot;pedro&quot;, &quot;xabi&quot;, &quot;layla&quot;}
bulk := make([]*ent.PetCreate, len(names))
for i, name := range names {
    bulk[i] = client.Pet.Create().SetName(name).SetOwner(a8m)
}
pets, err := client.Pet.CreateBulk(bulk...).Save(ctx)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;update-one&quot;&gt;Update One&lt;/h3&gt;
&lt;p&gt;更新一个从数据库返回的entity&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;a8m, err = a8m.Update().    // User update builder.
    RemoveGroup(g2).        // Remove specific edge.
    ClearCard().            // Clear unique edge.
    SetAge(30).             // Set field value
    Save(ctx)               // Save and return.
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;update-by-id&quot;&gt;Update By ID&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;pedro, err := client.Pet.   // PetClient.
    UpdateOneID(id).        // Pet update builder.
    SetName(&quot;pedro&quot;).       // Set field name.
    SetOwnerID(owner).      // Set unique edge, using id.
    Save(ctx)               // Save and return.
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;update-many&quot;&gt;Update Many&lt;/h3&gt;
&lt;p&gt;以断言进行过滤&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;n, err := client.User.          // UserClient.
    Update().                   // Pet update builder.
    Where(                      //
        user.Or(                // (age &amp;gt;= 30 OR name = &quot;bar&quot;) 
            user.AgeEQ(30),     //
            user.Name(&quot;bar&quot;),   // AND
        ),                      //  
        user.HasFollowers(),    // UserHasFollowers()  
    ).                          //
    SetName(&quot;foo&quot;).             // Set field name.
    Save(ctx)                   // exec and return.
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过edge 断言进行查询&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;n, err := client.User.          // UserClient.
    Update().                   // Pet update builder.
    Where(                      // 
        user.HasFriendsWith(    // UserHasFriendsWith (
            user.Or(            //   age = 20
                user.Age(20),   //      OR
                user.Age(30),   //   age = 30
            )                   // )
        ),                      //
    ).                          //
    SetName(&quot;a8m&quot;).             // Set field name.
    Save(ctx)                   // exec and return.
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;query-the-graph&quot;&gt;Query The Graph&lt;/h3&gt;
&lt;p&gt;获取所有用户的关注者&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;users, err := client.User.      // UserClient.
    Query().                    // User query builder.
    Where(user.HasFollowers()). // filter only users with followers.
    All(ctx)                    // query and return.
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;获取特定用户的所有跟随者; 从graph中的一个节点开始遍历&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;users, err := a8m.
    QueryFollowers().
    All(ctx)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;获取所有宠物的名字&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;names, err := client.Pet.
    Query().
    Select(pet.FieldName).
    Strings(ctx)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;获取所有宠物的名字和年龄&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;var v []struct {
    Age  int    `json:&quot;age&quot;`
    Name string `json:&quot;name&quot;`
}
err := client.Pet.
    Query().
    Select(pet.FieldAge, pet.FieldName).
    Scan(ctx, &amp;amp;v)
if err != nil {
    log.Fatal(err)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;delete-one&quot;&gt;Delete One&lt;/h3&gt;
&lt;p&gt;这个用于如果我们已经通过client查询到了一个entity，然后想要删除这条记录：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;err := client.User.
    DeleteOne(a8m).
    Exec(ctx)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Delete by ID.&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;err := client.User.
    DeleteOneID(id).
    Exec(ctx)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;delete-many&quot;&gt;Delete Many&lt;/h3&gt;
&lt;p&gt;使用断言进行删除&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;err := client.File.
    Delete().
    Where(file.UpdatedAtLT(date))
    Exec(ctx)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;mutation&quot;&gt;Mutation&lt;/h3&gt;
&lt;p&gt;通过 entc init 生成的每个schema 都有自己的mutaion，例如我们通过 entc init User Pet, 在通过go generate ./ent 生成的代码中有 &lt;code&gt;ent/mutation.go&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在该文件中定义了：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;.....
// UserMutation represents an operation that mutate the Users
// nodes in the graph.
type UserMutation struct {
        config
        op            Op
        typ           string
        id            *int
        name          *string
        age           *int
        addage        *int
        clearedFields map[string]struct{}
        done          bool
        oldValue      func(context.Context) (*User, error)
}

.....

// PetMutation represents an operation that mutate the Pets
// nodes in the graph.
type PetMutation struct {
        config
        op            Op
        typ           string
        id            *int
        name          *string
        age           *int
        addage        *int
        clearedFields map[string]struct{}
        done          bool
        oldValue      func(context.Context) (*Pet, error)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例如，所有的&lt;a href=&quot;https://entgo.io/docs/crud#create-an-entity&quot;&gt;&lt;code&gt;User&lt;/code&gt; builders&lt;/a&gt;都共享相同的UserMutaion 对象，左右的builder 类型都继承通用的&lt;a href=&quot;https://pkg.go.dev/github.com/facebook/ent?tab=doc#Mutation&quot;&gt;&lt;code&gt;ent.Mutation&lt;/code&gt;&lt;/a&gt;接口.&lt;/p&gt;
&lt;p&gt;这里所说的 user builders，拿User schema来说指的是&lt;code&gt;UserCreate&lt;/code&gt;、&lt;code&gt;UserDelete&lt;/code&gt;、&lt;code&gt;UserQuery&lt;/code&gt;、&lt;code&gt;UserUpdate&lt;/code&gt; 对象，go generate 生成的代码中，我们可以到&lt;/p&gt;
&lt;p&gt;&lt;code&gt;./ent/user_create.go、./ent/user_delete.go、./ent/user_query.go、./ent/user_update.go&lt;/code&gt;文件中看到如下定义：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;// ./ent/user_create.go

// UserCreate is the builder for creating a User entity.
type UserCreate struct {
        config
        mutation *UserMutation
        hooks    []Hook
}


//./ent/user_delete.go
// UserDelete is the builder for deleting a User entity.
type UserDelete struct {
        config
        hooks      []Hook
        mutation   *UserMutation
        predicates []predicate.User
}

// ./ent/user_query.go
// UserQuery is the builder for querying User entities.
type UserQuery struct {
        config
        limit      *int
        offset     *int
        order      []OrderFunc
        unique     []string
        predicates []predicate.User
        // intermediate query (i.e. traversal path).
        sql  *sql.Selector
        path func(context.Context) (*sql.Selector, error)
}

// ./ent/user_update.go
// UserUpdate is the builder for updating User entities.
type UserUpdate struct {
        config
        hooks      []Hook
        mutation   *UserMutation
        predicates []predicate.User
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在下面的例子中，ent.UserCreate 和 ent.UserUpdate 都使用一个通用的方法对age 和name 列进行操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;package main

import (
   &quot;context&quot;
   &quot;log&quot;

   _ &quot;github.com/go-sql-driver/mysql&quot;
   &quot;github.com/peanut-cc/ent_orm_notes/aboutMutaion/ent&quot;
)

func main() {
   client, err := ent.Open(&quot;mysql&quot;, &quot;root:123456@tcp(10.211.55.3:3306)/aboutMutaion?parseTime=True&quot;)
   if err != nil {
      log.Fatal(err)
   }
   defer client.Close()
   ctx := context.Background()
   // run the auto migration tool
   if err := client.Schema.Create(ctx); err != nil {
      log.Fatalf(&quot;failed creating schema resources:%v&quot;, err)
   }
   Do(ctx, client)
}

func Do(ctx context.Context, client *ent.Client) {
   creator := client.User.Create()
   SetAgeName(creator.Mutation())
   creator.SaveX(ctx)
   updater := client.User.UpdateOneID(1)
   SetAgeName(updater.Mutation())
   updater.SaveX(ctx)
}

// SetAgeName sets the age and the name for any mutation.
func SetAgeName(m *ent.UserMutation) {
   m.SetAge(32)
   m.SetName(&quot;Ariel&quot;)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在某些情况下，你希望对多个不同的类型应用同一个方法，对于这种情况，要么使用通用的ent.Mutation 接口，或者自己实现一个接口，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;func Do2(ctx context.Context, client *ent.Client) {
   creator1 := client.User.Create().SetAge(18)
   SetName(creator1.Mutation(), &quot;a8m&quot;)
   creator1.SaveX(ctx)
   creator2 := client.Pet.Create().SetAge(16)
   SetName(creator2.Mutation(), &quot;pedro&quot;)
   creator2.SaveX(ctx)
}

// SetNamer wraps the 2 methods for getting
// and setting the &quot;name&quot; field in mutations.
type SetNamer interface {
   SetName(string)
   Name() (string, bool)
}

func SetName(m SetNamer, name string) {
   if _, exist := m.Name(); !exist {
      m.SetName(name)
   }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;graph-traversal&quot;&gt;Graph Traversal&lt;/h2&gt;
&lt;p&gt;在这个部分的例子中会使用如下的Graph&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://entgo.io/assets/er_traversal_graph.png&quot; alt=&quot;er-traversal-graph&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://entgo.io/assets/er_traversal_graph_gopher.png&quot; alt=&quot;er-traversal-graph-gopher&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面的遍历从一个 Group 实体开始，继续到它的 admin (edge) ，继续到它的朋友(edge) ，获取他们的宠物(edge) ，获取每个宠物的朋友(edge) ，并请求它们的主人&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;func Traverse(ctx context.Context, client *ent.Client) error {
    owner, err := client.Group.         // GroupClient.
        Query().                        // Query builder.
        Where(group.Name(&quot;Github&quot;)).    // Filter only Github group (only 1).
        QueryAdmin().                   // Getting Dan.
        QueryFriends().                 // Getting Dan's friends: [Ariel].
        QueryPets().                    // Their pets: [Pedro, Xabi].
        QueryFriends().                 // Pedro's friends: [Coco], Xabi's friends: [].
        QueryOwner().                   // Coco's owner: Alex.
        Only(ctx)                       // Expect only one entity to return in the query.
    if err != nil {
        return fmt.Errorf(&quot;failed querying the owner: %v&quot;, err)
    }
    fmt.Println(owner)
    // Output:
    // User(id=3, age=37, name=Alex)
    return nil
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面的遍历如何？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://entgo.io/assets/er_traversal_graph_gopher_query.png&quot; alt=&quot;er-traversal-graph-gopher-query&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们希望得到所有宠物(entities)的所有者(edge)是朋友(edge)的一些群管理员(edge)。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func Traverse2(ctx context.Context, client *ent.Client) error {
        pets, err := client.Pet.
                Query().
                Where(
                        pet.HasOwnerWith(
                                user.HasFriendsWith(
                                        user.HasManage(),
                                ),
                        ),
                ).
                All(ctx)
        if err != nil {
                return fmt.Errorf(&quot;failed querying the pets: %v&quot;, err)
        }
        fmt.Println(pets)
        // Output:
        // [Pet(id=1, name=Pedro) Pet(id=2, name=Xabi)]
        return nil
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的查询中，查询所有的宠物，条件是: 宠物要有主人，同时宠物的主人是要有朋友，同时该主人还要属于管理员&lt;/p&gt;
&lt;h2 id=&quot;eager-loading&quot;&gt;Eager Loading&lt;/h2&gt;
&lt;p&gt;ent 支持通过它们的edges 查询，并将关联的entities 添加到返回的对象中&lt;/p&gt;
&lt;p&gt;通过下面的例子理解：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://entgo.io/assets/er_user_pets_groups.png&quot; alt=&quot;er-group-users&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;查询上面关系中所有用户和它们的宠物，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;func edgerLoading(ctx context.Context, client *ent.Client) {
   users, err := client.User.Query().WithPets().All(ctx)
   if err != nil {
      log.Fatalf(&quot;user query failed:%v&quot;, err)
   }
   log.Println(users)
   for _, u := range users {
      for _, p := range u.Edges.Pets {
         log.Printf(&quot;user (%v) -- &amp;gt; Pet (%v)\n&quot;, u.Name, p.Name)
      }
   }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;完整的代码在：&lt;a href=&quot;https://github.com/peanut-cc/ent_orm_notes/graph_traversal&quot;&gt;https://github.com/peanut-cc/ent_orm_notes/graph_traversal&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;查询的结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;2020/09/01 20:09:07 [User(id=1, age=29, name=Dan) User(id=2, age=30, name=Ariel) User(id=3, age=37, name=Alex) User(id=4, age=18, name=peanut)]
2020/09/01 20:09:07 user (Ariel) -- &amp;gt; Pet (Pedro)
2020/09/01 20:09:07 user (Ariel) -- &amp;gt; Pet (Xabi)
2020/09/01 20:09:07 user (Alex) -- &amp;gt; Pet (Coco)

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;预加载允许查询多个关联，包括嵌套关联，还可以过滤，排序或限制查询结果，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;func edgerLoading2(ctx context.Context, client *ent.Client) {
   users, err := client.User.
      Query().
      Where(
         user.AgeGT(18),
      ).
      WithPets().
      WithGroups(func(q *ent.GroupQuery) {
         q.Limit(5)
         q.WithUsers().Limit(5)
      }).All(ctx)
   if err != nil {
      log.Fatalf(&quot;user query failed:%v&quot;, err)
   }
   log.Println(users)
   for _, u := range users {
      for _, p := range u.Edges.Pets {
         log.Printf(&quot;user (%v) --&amp;gt; Pet (%v)\n&quot;, u.Name, p.Name)
      }
      for _, g := range u.Edges.Groups {
         log.Printf(&quot;user (%v) -- Group (%v)\n&quot;, u.Name, g.Name)
      }
   }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;每个query-builder都有一个方法列表，其形式为 &lt;code&gt;With&amp;lt;E&amp;gt;(...func(&amp;lt;N&amp;gt;Query))&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;E&amp;gt;&lt;/code&gt;代表边缘名称(像&lt;code&gt;WithGroups&lt;/code&gt;) ，&lt;code&gt;&amp;lt; N&amp;gt;&lt;/code&gt; 代表边缘类型(像&lt;code&gt;GroupQuery&lt;/code&gt;)。&lt;/p&gt;
&lt;p&gt;注意，只有 SQL 方言支持这个特性&lt;/p&gt;
&lt;h2 id=&quot;aggregation&quot;&gt;Aggregation&lt;/h2&gt;
&lt;h3 id=&quot;group-by&quot;&gt;Group By&lt;/h3&gt;
&lt;p&gt;按所有用户的姓名和年龄字段分组，并计算其总年龄。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;package main

import (
        &quot;context&quot;
        &quot;log&quot;

        &quot;github.com/peanut-cc/ent_orm_notes/groupBy/ent/user&quot;

        _ &quot;github.com/go-sql-driver/mysql&quot;

        &quot;github.com/peanut-cc/ent_orm_notes/groupBy/ent&quot;
)

func main() {
        client, err := ent.Open(&quot;mysql&quot;, &quot;root:123456@tcp(10.211.55.3:3306)/groupBy?parseTime=True&quot;,
                ent.Debug())
        if err != nil {
                log.Fatal(err)
        }
        defer client.Close()
        ctx := context.Background()
        // run the auto migration tool
        if err := client.Schema.Create(ctx); err != nil {
                log.Fatalf(&quot;failed creating schema resources:%v&quot;, err)
        }
        GenData(ctx, client)
        Do(ctx, client)

}

func GenData(ctx context.Context, client *ent.Client) {
        client.User.Create().SetName(&quot;peanut&quot;).SetAge(18).SaveX(ctx)
        client.User.Create().SetName(&quot;jack&quot;).SetAge(20).SaveX(ctx)
        client.User.Create().SetName(&quot;steve&quot;).SetAge(22).SaveX(ctx)
        client.User.Create().SetName(&quot;peanut-cc&quot;).SetAge(18).SaveX(ctx)
        client.User.Create().SetName(&quot;jack-dd&quot;).SetAge(18).SaveX(ctx)
}

func Do(ctx context.Context, client *ent.Client) {
        var v []struct {
                Name  string `json:&quot;name&quot;`
                Age   int    `json:&quot;age&quot;`
                Sum   int    `json:&quot;sum&quot;`
                Count int    `json:&quot;count&quot;`
        }
        client.User.
                Query().
                GroupBy(
                        user.FieldName, user.FieldAge,
                ).
                Aggregate(
                        ent.Count(),
                        ent.Sum(user.FieldAge),
                ).
                ScanX(ctx, &amp;amp;v)
        log.Println(v)

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;按一个字段分组，例子如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;func Do2(ctx context.Context, client *ent.Client) {
        names := client.User.Query().GroupBy(user.FieldName).StringsX(ctx)
        log.Println(names)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;predicates&quot;&gt;Predicates&lt;/h2&gt;
&lt;h3 id=&quot;field-predicates&quot;&gt;Field Predicates&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;Bool:
&lt;/li&gt;
&lt;li&gt;Numberic:
&lt;ul&gt;&lt;li&gt;=, !=, &amp;gt;, &amp;lt;, &amp;gt;=, &amp;lt;=,&lt;/li&gt;
&lt;li&gt;IN, NOT IN&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Time:
&lt;ul&gt;&lt;li&gt;=, !=, &amp;gt;, &amp;lt;, &amp;gt;=, &amp;lt;=&lt;/li&gt;
&lt;li&gt;IN, NOT IN&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;String:
&lt;ul&gt;&lt;li&gt;=, !=, &amp;gt;, &amp;lt;, &amp;gt;=, &amp;lt;=&lt;/li&gt;
&lt;li&gt;IN, NOT IN&lt;/li&gt;
&lt;li&gt;Contains, HasPrefix, HasSuffix&lt;/li&gt;
&lt;li&gt;ContainsFold, EqualFold (&lt;strong&gt;SQL&lt;/strong&gt; specific)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Optional fields:
&lt;ul&gt;&lt;li&gt;IsNil, NotNil&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;edge-predicates&quot;&gt;Edge Predicates&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;HasEdge&lt;/strong&gt; 例如，查询所有宠物的所有者，使用:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt; client.Pet.
      Query().
      Where(pet.HasOwner()).
      All(ctx)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;HasEdgeWith&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt; client.Pet.
      Query().
      Where(pet.HasOwnerWith(user.Name(&quot;a8m&quot;))).
      All(ctx)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;negation-not&quot;&gt;Negation (NOT)&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;client.Pet.
    Query().
    Where(pet.Not(pet.NameHasPrefix(&quot;Ari&quot;))).
    All(ctx)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;disjunction-or&quot;&gt;Disjunction (OR)&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;client.Pet.
    Query().
    Where(
        pet.Or(
            pet.HasOwner(),
            pet.Not(pet.HasFriends()),
        )
    ).
    All(ctx)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;conjunction-and&quot;&gt;Conjunction (AND)&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;client.Pet.
    Query().
    Where(
        pet.And(
            pet.HasOwner(),
            pet.Not(pet.HasFriends()),
        )
    ).
    All(ctx)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;custom-predicates&quot;&gt;Custom Predicates&lt;/h3&gt;
&lt;p&gt;如果想编写自己的特定于方言的逻辑，Custom predicates可能很有用。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;pets := client.Pet.
    Query().
    Where(predicate.Pet(func(s *sql.Selector) {
        s.Where(sql.InInts(pet.OwnerColumn, 1, 2, 3))
    })).
    AllX(ctx)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;paging-and-ordering&quot;&gt;Paging And Ordering&lt;/h2&gt;
&lt;h3 id=&quot;limit&quot;&gt;Limit&lt;/h3&gt;
&lt;p&gt;将查询结果限制为 n 个实体。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;users, err := client.User.
    Query().
    Limit(n).
    All(ctx)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;offset&quot;&gt;Offset&lt;/h3&gt;
&lt;p&gt;设置从查询返回的第一个最大数量。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;users, err := client.User.
    Query().
    Offset(10).
    All(ctx)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;ordering&quot;&gt;Ordering&lt;/h3&gt;
&lt;p&gt;Order 返回按一个或多个字段的值排序的实体。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;users, err := client.User.Query().
    Order(ent.Asc(user.FieldName)).
    All(ctx)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;延伸阅读&quot;&gt;延伸阅读&lt;/h2&gt;
</description>
<pubDate>Wed, 02 Sep 2020 00:07:00 +0000</pubDate>
<dc:creator>syncd</dc:creator>
<og:description>在前面几篇文章中，我们经常使用的可能就是entc这个命令了，entc这个工具给带来了很多功能，这篇文章主要整理关于ent orm 中Code Generation 之前的例子中有个知识点少整理了，就是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhaof/p/13599609.html</dc:identifier>
</item>
<item>
<title>位运算的奇技淫巧（二） - RioTian</title>
<link>http://www.cnblogs.com/RioTian/p/13598747.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/RioTian/p/13598747.html</guid>
<description>&lt;p&gt;位运算就是基于整数的二进制表示进行的运算。由于计算机内部就是以二进制来存储数据，位运算是相当快的。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;之前有总结过位运算的技巧，但稍微对&lt;a href=&quot;https://www.cnblogs.com/RioTian/p/12371164.html&quot;&gt;以前写的文章&lt;/a&gt;不太满意，所以重新总结一下&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;常用的运算符共 6 种，分别为与（ &lt;code&gt;&amp;amp;&lt;/code&gt; ）、或（ &lt;code&gt;|&lt;/code&gt; ）、异或（ &lt;code&gt;^&lt;/code&gt; ）、取反（ &lt;code&gt;~&lt;/code&gt; ）、左移（ &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; ）和右移（ &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; ）。&lt;/p&gt;
&lt;h2 id=&quot;与、或、异或&quot;&gt;与、或、异或&lt;/h2&gt;
&lt;p&gt;与（ &lt;code&gt;&amp;amp;&lt;/code&gt; ）或（ &lt;code&gt;|&lt;/code&gt; ）和异或（ &lt;code&gt;^&lt;/code&gt; ）这三者都是两数间的运算，因此在这里一起讲解。&lt;/p&gt;
&lt;p&gt;它们都是将两个整数作为二进制数，对二进制表示中的每一位逐一运算。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;运算符&lt;/th&gt;
&lt;th&gt;解释&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;只有两个对应位都为 1 时才为 1&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;|&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;只要两个对应位中有一个 1 时就为 1&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;^&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;只有两个对应位不同时才为 1&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;异或运算的逆运算是它本身，也就是说两次异或同一个数最后结果不变，即 &lt;span class=&quot;math inline&quot;&gt;\(a \text{^} b \text{^} b = a\)&lt;/span&gt; 。&lt;/p&gt;
&lt;p&gt;举例：&lt;/p&gt;
&lt;p&gt;\[\begin{aligned} 5 &amp;amp;=(101)_2\\ 6 &amp;amp;=(110)_2\\ 5\&amp;amp;6 &amp;amp;=(100)_2 =\ 4\\ 5|6 &amp;amp;=(111)_2 =\ 7\\ 5\text{^}6 &amp;amp;=(011)_2 =\ 3\\ \end{aligned} \]&lt;/p&gt;
&lt;h2 id=&quot;取反&quot;&gt;取反&lt;/h2&gt;
&lt;p&gt;取反是对一个数 &lt;span class=&quot;math inline&quot;&gt;\(num\)&lt;/span&gt; 进行的计算，即单目运算。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;~&lt;/code&gt; 把 &lt;span class=&quot;math inline&quot;&gt;\(num\)&lt;/span&gt; 的补码中的 0 和 1 全部取反（0 变为 1，1 变为 0）。有符号整数的符号位在 &lt;code&gt;~&lt;/code&gt; 运算中同样会取反。&lt;/p&gt;
&lt;p&gt;补码：在二进制表示下，正数和 0 的补码为其本身，负数的补码是将其对应正数按位取反后加一。&lt;/p&gt;
&lt;p&gt;举例（有符号整数）：&lt;/p&gt;
&lt;p&gt;\[\begin{aligned} 5&amp;amp;=(00000101)_2\\ \text{~}5&amp;amp;=(11111010)_2=-6\\ -5\text{ 的补码}&amp;amp;=(11111011)_2\\ \text{~}(-5)&amp;amp;=(00000100)_2=4 \end{aligned} \]&lt;/p&gt;
&lt;h2 id=&quot;左移和右移&quot;&gt;左移和右移&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;num &amp;lt;&amp;lt; i&lt;/code&gt; 表示将 &lt;span class=&quot;math inline&quot;&gt;\(num\)&lt;/span&gt; 的二进制表示向左移动 &lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt; 位所得的值。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;num &amp;gt;&amp;gt; i&lt;/code&gt; 表示将 &lt;span class=&quot;math inline&quot;&gt;\(num\)&lt;/span&gt; 的二进制表示向右移动 &lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt; 位所得的值。&lt;/p&gt;
&lt;p&gt;举例：&lt;/p&gt;
&lt;p&gt;\[\begin{aligned} 11&amp;amp;=(00001011)_2\\ 11&amp;lt;&amp;lt;3&amp;amp;=(01011000)_2=88\\ 11&amp;gt;&amp;gt;2&amp;amp;=(00000010)_2=2 \end{aligned} \]&lt;/p&gt;
&lt;p&gt;在 C++ 中，右移操作中右侧多余的位将会被舍弃，而左侧较为复杂：对于无符号数，会在左侧补 0；而对于有符号数，则会用最高位的数（其实就是符号位，非负数为 0，负数为 1）补齐。左移操作总是在右侧补 0。&lt;/p&gt;
&lt;h2 id=&quot;复合赋值位运算符&quot;&gt;复合赋值位运算符&lt;/h2&gt;
&lt;p&gt;和 &lt;code&gt;+=&lt;/code&gt; , &lt;code&gt;-=&lt;/code&gt; 等运算符类似，位运算也有复合赋值运算符： &lt;code&gt;&amp;amp;=&lt;/code&gt; , &lt;code&gt;|=&lt;/code&gt; , &lt;code&gt;^=&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 。（取反是单目运算，所以没有。）&lt;/p&gt;
&lt;h2 id=&quot;关于优先级&quot;&gt;关于优先级&lt;/h2&gt;
&lt;p&gt;位运算的优先级低于算术运算符（除了取反），而按位与、按位或及异或低于比较运算符，所以使用时需多加注意，在必要时添加括号。&lt;/p&gt;
&lt;h2 id=&quot;位运算的应用&quot;&gt;位运算的应用&lt;/h2&gt;
&lt;p&gt;位运算一般有三种作用：&lt;/p&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;高效地进行某些运算，代替其它低效的方式。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-0.79545454545455&quot;&gt;
&lt;p&gt;表示集合。（常用于 &lt;a href=&quot;https://www.cnblogs.com/RioTian/p/13598747.html&quot;&gt;状压 DP&lt;/a&gt; 。）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;题目本来就要求进行位运算。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;需要注意的是，用位运算代替其它运算方式（即第一种应用）在很多时候并不能带来太大的优化，反而会使代码变得复杂，使用时需要斟酌。（但像“乘 2 的非负整数次幂”和“除以 2 的非负整数次幂”就最好使用位运算，因为此时使用位运算可以优化复杂度。）&lt;/p&gt;
&lt;h3 id=&quot;乘-2-的非负整数次幂&quot;&gt;乘 2 的非负整数次幂&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;int mulPowerOfTwo(int n, int m) {  // 计算 n*(2^m)
  return n &amp;lt;&amp;lt; m;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;除以-2-的非负整数次幂&quot;&gt;除以 2 的非负整数次幂&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;int divPowerOfTwo(int n, int m) {  // 计算 n/(2^m)
  return n &amp;gt;&amp;gt; m;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;!!! warning&lt;br/&gt;我们平常写的除法是向 0 取整，而这里的右移是向下取整（注意这里的区别），即当数大于等于 0 时两种方法等价，当数小于 0 时会有区别，如： &lt;code&gt;-1 / 2&lt;/code&gt; 的值为 &lt;span class=&quot;math inline&quot;&gt;\(0\)&lt;/span&gt; ，而 &lt;code&gt;-1 &amp;gt;&amp;gt; 1&lt;/code&gt; 的值为 &lt;span class=&quot;math inline&quot;&gt;\(-1\)&lt;/span&gt; 。&lt;/p&gt;
&lt;h3 id=&quot;判断一个数是不是-2-的正整数次幂&quot;&gt;判断一个数是不是 2 的正整数次幂&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;bool isPowerOfTwo(int n) { return n &amp;gt; 0 &amp;amp;&amp;amp; (n &amp;amp; (n - 1)) == 0; }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;对-2-的非负整数次幂取模&quot;&gt;对 2 的非负整数次幂取模&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;int modPowerOfTwo(int x, int mod) { return x &amp;amp; (mod - 1); }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;取绝对值&quot;&gt;取绝对值&lt;/h3&gt;
&lt;p&gt;在某些机器上，效率比 &lt;code&gt;n &amp;gt; 0 ? n : -n&lt;/code&gt; 高。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;int Abs(int n) {
  return (n ^ (n &amp;gt;&amp;gt; 31)) - (n &amp;gt;&amp;gt; 31);
  /* n&amp;gt;&amp;gt;31 取得 n 的符号，若 n 为正数，n&amp;gt;&amp;gt;31 等于 0，若 n 为负数，n&amp;gt;&amp;gt;31 等于 -1
     若 n 为正数 n^0=n, 数不变，若 n 为负数有 n^(-1)
     需要计算 n 和 -1 的补码，然后进行异或运算，
     结果 n 变号并且为 n 的绝对值减 1，再减去 -1 就是绝对值 */
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;取两个数的最大最小值&quot;&gt;取两个数的最大/最小值&lt;/h3&gt;
&lt;p&gt;在某些机器上，效率比 &lt;code&gt;a &amp;gt; b ? a : b&lt;/code&gt; 高。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;// 如果 a&amp;gt;=b,(a-b)&amp;gt;&amp;gt;31 为 0，否则为 -1
int max(int a, int b) { return b &amp;amp; ((a - b) &amp;gt;&amp;gt; 31) | a &amp;amp; (~(a - b) &amp;gt;&amp;gt; 31); }
int min(int a, int b) { return a &amp;amp; ((a - b) &amp;gt;&amp;gt; 31) | b &amp;amp; (~(a - b) &amp;gt;&amp;gt; 31); }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;判断符号是否相同&quot;&gt;判断符号是否相同&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;bool isSameSign(int x, int y) {  // 有 0 的情况例外
  return (x ^ y) &amp;gt;= 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;交换两个数&quot;&gt;交换两个数&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;void swap(int &amp;amp;a, int &amp;amp;b) { a ^= b ^= a ^= b; }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;获取一个数二进制的某一位&quot;&gt;获取一个数二进制的某一位&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;// 获取 a 的第 b 位，最低位编号为 0
int getBit(int a, int b) { return (a &amp;gt;&amp;gt; b) &amp;amp; 1; }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;表示集合&quot;&gt;表示集合&lt;/h3&gt;
&lt;p&gt;一个数的二进制表示可以看作是一个集合（0 表示不在集合中，1 表示在集合中）。比如集合 &lt;code&gt;{1, 3, 4, 8}&lt;/code&gt; ，可以表示成 &lt;span class=&quot;math inline&quot;&gt;\((100011010)_2\)&lt;/span&gt; 。而对应的位运算也就可以看作是对集合进行的操作。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;操作&lt;/th&gt;
&lt;th&gt;集合表示&lt;/th&gt;
&lt;th&gt;位运算语句&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;交集&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(a \cap b\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;a &amp;amp; b&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;并集&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(a \cup b\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;a|b&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;补集&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(\bar{a}\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;~a&lt;/code&gt; （全集为二进制都是 1）&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;差集&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(a \setminus b\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;a &amp;amp; (~b)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;对称差&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(a\triangle b\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;a ^ b&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;遍历某个集合的子集&quot;&gt;遍历某个集合的子集&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;// 遍历 u 的非空子集
for (int s = u; s; s = (s - 1) &amp;amp; u) {
  // s 是 u 的一个非空子集
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用这种方法可以在 &lt;span class=&quot;math inline&quot;&gt;\(O(2^{popcount(u)})\)&lt;/span&gt; （ &lt;span class=&quot;math inline&quot;&gt;\(popcount(u)\)&lt;/span&gt; 表示 &lt;span class=&quot;math inline&quot;&gt;\(u\)&lt;/span&gt; 二进制中 1 的个数）的时间复杂度内遍历 &lt;span class=&quot;math inline&quot;&gt;\(u\)&lt;/span&gt; 的子集，进而可以在 &lt;span class=&quot;math inline&quot;&gt;\(O(3^n)\)&lt;/span&gt; 的时间复杂度内遍历大小为 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 的集合的每个子集的子集。（复杂度为 &lt;span class=&quot;math inline&quot;&gt;\(O(3^n)\)&lt;/span&gt; 是因为每个元素都有 不在大子集中/只在大子集中/同时在大小子集中 三种状态。）&lt;/p&gt;
&lt;h2 id=&quot;内建函数&quot;&gt;内建函数&lt;/h2&gt;
&lt;p&gt;GCC 中还有一些用于位运算的内建函数：&lt;a href=&quot;https://www.cnblogs.com/RioTian/p/13527410.html&quot;&gt;详细文章介绍&lt;/a&gt;&lt;/p&gt;
&lt;ol readability=&quot;5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;int __builtin_ffs(int x)&lt;/code&gt; ：返回 &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt; 的二进制末尾最后一个 &lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt; 的位置，位置的编号从 &lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt; 开始（最低位编号为 &lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt; ）。当 &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt; 为 &lt;span class=&quot;math inline&quot;&gt;\(0\)&lt;/span&gt; 时返回 &lt;span class=&quot;math inline&quot;&gt;\(0\)&lt;/span&gt; 。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;int __builtin_clz(unsigned int x)&lt;/code&gt; ：返回 &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt; 的二进制的前导 &lt;span class=&quot;math inline&quot;&gt;\(0\)&lt;/span&gt; 的个数。当 &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt; 为 &lt;span class=&quot;math inline&quot;&gt;\(0\)&lt;/span&gt; 时，结果未定义。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;int __builtin_ctz(unsigned int x)&lt;/code&gt; ：返回 &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt; 的二进制末尾连续 &lt;span class=&quot;math inline&quot;&gt;\(0\)&lt;/span&gt; 的个数。当 &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt; 为 &lt;span class=&quot;math inline&quot;&gt;\(0\)&lt;/span&gt; 时，结果未定义。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;int __builtin_clrsb(int x)&lt;/code&gt; ：当 &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt; 的符号位为 &lt;span class=&quot;math inline&quot;&gt;\(0\)&lt;/span&gt; 时返回 &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt; 的二进制的前导 &lt;span class=&quot;math inline&quot;&gt;\(0\)&lt;/span&gt; 的个数减一，否则返回 &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt; 的二进制的前导 &lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt; 的个数减一。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;int __builtin_popcount(unsigned int x)&lt;/code&gt; ：返回 &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt; 的二进制中 &lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt; 的个数。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;int __builtin_parity(unsigned int x)&lt;/code&gt; ：判断 &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt; 的二进制中 &lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt; 的个数的奇偶性。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这些函数都可以在函数名末尾添加 &lt;code&gt;l&lt;/code&gt; 或 &lt;code&gt;ll&lt;/code&gt; （如 &lt;code&gt;__builtin_popcountll&lt;/code&gt; ）来使参数类型变为 ( &lt;code&gt;unsigned&lt;/code&gt; ) &lt;code&gt;long&lt;/code&gt; 或 ( &lt;code&gt;unsigned&lt;/code&gt; ) &lt;code&gt;long long&lt;/code&gt; （返回值仍然是 &lt;code&gt;int&lt;/code&gt; 类型）。&lt;br/&gt;例如，我们有时候希望求出一个数以二为底的对数，如果不考虑 &lt;code&gt;0&lt;/code&gt; 的特殊情况，就相当于这个数二进制的位数 &lt;code&gt;-1&lt;/code&gt; ，而一个数 &lt;code&gt;n&lt;/code&gt; 的二进制表示的位数可以使用 &lt;code&gt;32-__builtin_clz(n)&lt;/code&gt; 表示，因此 &lt;code&gt;31-__builtin_clz(n)&lt;/code&gt; 就可以求出 &lt;code&gt;n&lt;/code&gt; 以二为底的对数。&lt;/p&gt;
&lt;p&gt;由于这些函数是内建函数，经过了编译器的高度优化，运行速度十分快（有些甚至只需要一条指令）。&lt;/p&gt;
&lt;h2 id=&quot;更多位数&quot;&gt;更多位数&lt;/h2&gt;
&lt;p&gt;如果需要操作的集合非常大，可以使用 &lt;code&gt;bitset容器&lt;/code&gt; 。&lt;/p&gt;
&lt;h2 id=&quot;题目推荐&quot;&gt;题目推荐&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P1225&quot;&gt;Luogu P1225 黑白棋游戏&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;p&gt;位运算技巧： &lt;a href=&quot;https://graphics.stanford.edu/~seander/bithacks.html&quot;&gt;https://graphics.stanford.edu/~seander/bithacks.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Other Builtins of GCC： &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html&quot;&gt;https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;英文文档参考：&lt;a href=&quot;https://www.jjj.de/fxt/fxtbook.pdf&quot;&gt;https://www.jjj.de/fxt/fxtbook.pdf&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 02 Sep 2020 00:05:00 +0000</pubDate>
<dc:creator>RioTian</dc:creator>
<og:description>位运算就是基于整数的二进制表示进行的运算。由于计算机内部就是以二进制来存储数据，位运算是相当快的。 之前有总结过位运算的技巧，但稍微对以前写的文章不太满意，所以重新总结一下 常用的运算符共 6 种，分</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/RioTian/p/13598747.html</dc:identifier>
</item>
<item>
<title>谁告诉的你们Python是强类型语言！站出来，保证不打你！ - 银河使者</title>
<link>http://www.cnblogs.com/nokiaguy/p/13599816.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nokiaguy/p/13599816.html</guid>
<description>&lt;p&gt;最近有些学员问我，Python到底是强类型语言，还是弱类型语言。我就直接脱口而出：Python是弱类型语言。没想到有一些学员给我了一些文章，有中文的，有英文的，都说Python是强类型语言。我就很好奇，特意仔细研究了这些文章。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;274.38026557915&quot;&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/src/CCAFDA4FDEC14142937D63E012C3A844&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/32818/202009/32818-20200902075059021-2070028447.png&quot; alt=&quot;&quot; width=&quot;670&quot; height=&quot;296&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;1. 真的能用隐式类型转换作为强弱类型的判断标准吗？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;最近有些学员问我，Python到底是强类型语言，还是弱类型语言。我就直接脱口而出：Python是弱类型语言。没想到有一些学员给我了一些文章，有中文的，有英文的，都说Python是强类型语言。我就很好奇，特意仔细研究了这些文章，例如，下面就是一篇老外写的文章：&lt;/p&gt;


&lt;p&gt;其他中文的相关文章，大家可以去网上搜，一堆，这里就不一一列举了。&lt;/p&gt;

&lt;p&gt;我先不说这些结论对不对，我先总结一下这些文章的核心观点。这些文章将编程语言分为强类型、弱类型、动态类型和静态类型。这4个概念的解释如下：&lt;/p&gt;

&lt;p&gt;强类型：如果一门语言不对变量的类型做隐式转换，这种编程语言就被称为强类型语言 ；&lt;/p&gt;
&lt;p&gt;弱类型：与强类型相反，如果一门语言对变量的类型做隐式转换，那我们则称之为弱类型语言；&lt;/p&gt;
&lt;p&gt;动态类型：如果一门语言可以在运行时改变变量的类型，那我们称之为动态类型语言；&lt;/p&gt;
&lt;p&gt;静态类型：与动态类型相反，如果一门语言不可以在运行时改变变量的类型，则称之为静态类型语言；&lt;/p&gt;
&lt;div&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/32818/202009/32818-20200902075302845-1929957090.png&quot; alt=&quot;&quot; width=&quot;680&quot; height=&quot;729&quot; loading=&quot;lazy&quot;/&gt;

&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/src/A44B1BC917664E8A9821AD772B969F70&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;p&gt; 其实这些概念就涉及到编程语言的两个特性：隐式类型转换和类型固化。&lt;/p&gt;

&lt;p&gt;所谓类型固化，就是指一旦变量在初始化时被确定了某个数据类型（如整数类型），那么这个变量的数据类型将永远不会变化。&lt;/p&gt;

&lt;p&gt;关于动态类型和静态类型，在本文的后面再来讨论，这里先探讨强类型和弱类型。&lt;/p&gt;

&lt;p&gt;现在姑且认为这个结论没问题。强类型就是不允许做隐式类型转换。OK，我们看看用这个隐式类型转换来判断强类型和弱类型是否合理。&lt;/p&gt;

&lt;p&gt;在这些文章中，给出了很多例子作为证据来证实这个结论，其中最典型的例子是在Python语言中，int + string是不合法的，没错，确实不合法。如执行1 + 'abc'会抛出异常。当然，还有人给出了另一个例子：string / int也是不合法的，如执行'666' / 20会抛出异常，没错，字符串与整数的确不能直接相除。那你怎么不用乘号举例呢？如'abc' * 10，这在Python中可是合法的哦，因为这个表达式会将'abc'复制10份。为何不用我大乘号来举例，难道瞧不起我大乘号吗？ 这是运算符歧视？&lt;/p&gt;
&lt;div readability=&quot;9&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/32818/202009/32818-20200902075334017-800471177.png&quot; alt=&quot;&quot; width=&quot;405&quot; height=&quot;624&quot; loading=&quot;lazy&quot;/&gt;&lt;p&gt; PS：虽然'abc' * 10没有做类型转换，但这里说的是乘号（*），尽管目前Python不支持'abc' * '10'的操作，但已有也有可能会支持'abc' * '10'，也就是将'10'转换为10，这就发生了类型转换。&lt;/p&gt;
&lt;/div&gt;

&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/src/9784F731AAA841F0A94E076EE4A4AC2E&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;p&gt;另外，难道没听说过Python支持运算符重载吗？通过运算符重载，可以让两个类型完全不同的变量或值在一起运算，如相加，看下面的例子：&lt;/p&gt;

&lt;div id=&quot;4193-1598258477369&quot; data-theme=&quot;default&quot; data-language=&quot;javascript&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyClass1:
    def __init__(self,value):
        self.value &lt;/span&gt;=&lt;span&gt; value

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyClass2:
    def __init__(self,value):
        self.value &lt;/span&gt;=&lt;span&gt; value
my1 &lt;/span&gt;= MyClass1(20&lt;span&gt;)
my2 &lt;/span&gt;= MyClass2(30&lt;span&gt;)
print( my1 &lt;/span&gt;+ my2)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;如果执行这段代码，100%会抛出异常，因为MyClass1和MyClass2肯定不能相加，但如果按下面的方式修改代码，就没问题了。&lt;/p&gt;
&lt;div id=&quot;7388-1598258598178&quot; data-theme=&quot;default&quot; data-language=&quot;javascript&quot; readability=&quot;9&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyClass1:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self,value):
        self.value &lt;/span&gt;=&lt;span&gt; value
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__add__&lt;/span&gt;&lt;span&gt;(self,my):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; self.value +&lt;span&gt; my.value
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyClass2:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self,value):
        self.value &lt;/span&gt;=&lt;span&gt; value
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__add__&lt;/span&gt;&lt;span&gt;(self,my):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; self.value +&lt;span&gt; my.value

my1 &lt;/span&gt;= MyClass1(20&lt;span&gt;)
my2 &lt;/span&gt;= MyClass2(30&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;( my1 + my2)
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt; 这段代码对MyClass1和MyClass2进行了加法运算符重载，这样两个不同类型的变量就可以直接相加了，从表面上看，好像是发生了类型转换，但其实是运算符重载。&lt;/p&gt;

&lt;p&gt;当然，运算符重载也可能会使用显式类型转换，如下面的代码允许不同类型的值相加。&lt;/p&gt;
&lt;div readability=&quot;9.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyClass1:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self,value):
        self.value &lt;/span&gt;=&lt;span&gt; value
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__add__&lt;/span&gt;&lt;span&gt;(self,my):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; str(self.value) +&lt;span&gt; str(my.value)
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyClass2:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self,value):
        self.value &lt;/span&gt;=&lt;span&gt; value
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__add__&lt;/span&gt;&lt;span&gt;(self,my):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; str(self.value) +&lt;span&gt; str(my.value)

my1 &lt;/span&gt;= MyClass1(20&lt;span&gt;)
my2 &lt;/span&gt;= MyClass2(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xyz&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;( my1 + my2)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;其实这段代码也就相当于int + string形式了，只是用MyClass1和MyClass2包装了一层。可能有很多同学会说，这能一样吗？明显不是int + string的形式，ok，的确是不太一样。&lt;/p&gt;

&lt;p&gt;可惜目前Python还不支持内建类型（如int、str）的运算符重载，但不能保证以后不支持，如果以后Python要是支持内建类型运算符重载，那就意味着可以重载str类的__add__方法了，目前str类定义在builtins.py文件中，里面已经预定义了很多可能被重载的运算符。当然，目前Python是直接将这些运算符方法固化在解析器中了，例如，__add__方法是只读的，不能修改。如下面的Python代码相当于a + &quot;ok&quot;。&lt;/p&gt;

&lt;div id=&quot;8800-1598259936996&quot; data-theme=&quot;default&quot; data-language=&quot;javascript&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
a = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;abc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;( a.&lt;span&gt;__add__&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ok&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;))
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;但你不能用下面的代码覆盖掉str类的__add__方法。&lt;/p&gt;

&lt;div id=&quot;5871-1598260225739&quot; data-theme=&quot;default&quot; data-language=&quot;javascript&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; new_add(self, value):
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; str(self) +&lt;span&gt; str(value)
str.&lt;/span&gt;&lt;span&gt;__add__&lt;/span&gt; = new_add   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 抛出异常&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;执行这段代码会抛出如下图的异常，也就是说，目前Python的内建类型，如str，是不能动态为其添加新的成员或覆盖以前的成员的。&lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/32818/202009/32818-20200902075627791-1729632255.png&quot; alt=&quot;&quot; width=&quot;794&quot; height=&quot;160&quot; loading=&quot;lazy&quot;/&gt;
&lt;p&gt; 但现在不能，不代表以后不能。如果以后Python支持覆盖内建类型的运算符，那么int + string就可以让其合法化。不过可能还会有同学问，就算内建类型支持运算符重载，那不还需要使用显式类型转换吗？是的，没错，需要类型转换。&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;10&quot;&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/32818/202009/32818-20200902075703522-483300393.png&quot; alt=&quot;&quot; width=&quot;629&quot; height=&quot;804&quot; loading=&quot;lazy&quot;/&gt;
&lt;p&gt; 现在我们先来谈谈类型转换，先用另外一个被公认的弱类型编程语言JavaScript为例。在JS中，1 + 'abc'是合法的、'444'/20也是合法的，所以就有很多人认为js是弱类型语言，没错，js的确是弱类型语言。但弱类型确实是根据1 + 'abc'和'444'/20得出来的？&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;有很多人认为，JavaScript不做类型检查，就直接将1和'abc'相加了！你是当真的？如果不做类型检查，那么js怎么会知道如何将1和'abc'相加，为啥不将1当做1.0呢？其实不管是什么类型的编程语言，数据类型检测都是必须的，不管是js、还是Python，或是Java，内部一定会做数据类型检测，只是检测的目的不同而已。在Python中，进行数据类型检测后，发现不合规的情况，有时会自动处理（如int+float），有时干脆就抛出异常（如int + string）。而在Java中就更严格了，在编译时，发现不合规的情况，就直接抛出编译错误了。在js中，发现不合规的情况，就会按最大可能进行处理，在内部进行类型转换。对，不是不管数据类型了，而是在内部做的数据类型转换。那么这和通过Python的运算符重载在外部做类型转换有什么区别呢？只是一个由编译器（解析器）内部处理的，一个是在外部由程序员编写代码处理的！而且就算Python不会支持内建类型的运算符重载，那么也有可能直接支持int + string的形式。因为目前Python不支持，所以正确的Python代码不可能有int + string的形式。所以如果以后支持int + string的形式，也可以完全做到代码向下兼容。就算Python未来不支持int + string形式，那么我自己做一个Python解析器（例如，我们团队现在自己做的Ori语言，支持类型隐式转换，不过实际上是生成了其他的编程语言，也就是语言之间的转换，这是不是代表Ori是弱类型语言呢？），完全兼容Python的代码，只不过支持int+string形式，那么能不能说，我的这个Python版本是弱类型Python呢？这很正常，因为像C++这种语言也有很多种实现版本，Python同样也可以拥有，只不过目前没多少人做而已，但不等于没有可能。&lt;/p&gt;

&lt;p&gt;如果Python真这么做了，那么能不能说Python又从强类型语言变成了弱类型语言呢？如果大家认为一种语言的类型强弱是可以随着时间变化的，那么我无话可说！&lt;/p&gt;

&lt;p&gt;总之，需要用一种确定不会变的特性来表示强弱类型才是最合适的。通常来讲，某种语言的变量一旦数据类型确定了，就不允许变化了，这种才可以称为强类型，强大到类型一言九鼎，类型一旦确定，就不允许变了，而Python显然不是，x = 20; x = 'abc';同样是合法的，x先后分别是int和str类型。&lt;/p&gt;

&lt;p&gt;PS：这里再给大家一个表，通常编程语言中确定类型是否兼容，就是通过类似的表处理的。这个表主要用于内建类型，如果是自定义类型，需要通过接口（实现）和类（继承）类确定类型是否兼容。&lt;/p&gt;

&lt;div&gt;
&lt;table&gt;&lt;colgroup&gt;&lt;col/&gt;&lt;col/&gt;&lt;col/&gt;&lt;col/&gt;&lt;/colgroup&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td data-cell-id=&quot;3957-1598263789216-cell-0-0&quot;&gt; &lt;/td&gt;
&lt;td data-cell-id=&quot;3957-1598263789216-cell-0-1&quot;&gt;
&lt;p&gt;int&lt;/p&gt;
&lt;/td&gt;
&lt;td data-cell-id=&quot;3957-1598263789216-cell-0-2&quot;&gt;
&lt;p&gt;float&lt;/p&gt;
&lt;/td&gt;
&lt;td data-cell-id=&quot;3957-1598263789216-cell-0-3&quot;&gt;
&lt;p&gt;str&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td data-cell-id=&quot;3957-1598263789216-cell-1-0&quot;&gt;
&lt;p&gt;int&lt;/p&gt;
&lt;/td&gt;
&lt;td data-cell-id=&quot;3957-1598263789216-cell-1-1&quot;&gt;
&lt;p&gt;True&lt;/p&gt;
&lt;/td&gt;
&lt;td data-cell-id=&quot;3957-1598263789216-cell-1-2&quot;&gt;
&lt;p&gt;True&lt;/p&gt;
&lt;/td&gt;
&lt;td data-cell-id=&quot;3957-1598263789216-cell-1-3&quot;&gt;
&lt;p&gt;False&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td data-cell-id=&quot;3957-1598263789216-cell-2-0&quot;&gt;
&lt;p&gt;float&lt;/p&gt;
&lt;/td&gt;
&lt;td data-cell-id=&quot;3957-1598263789216-cell-2-1&quot;&gt;
&lt;p&gt;True&lt;/p&gt;
&lt;/td&gt;
&lt;td data-cell-id=&quot;3957-1598263789216-cell-2-2&quot;&gt;
&lt;p&gt;True&lt;/p&gt;
&lt;/td&gt;
&lt;td data-cell-id=&quot;3957-1598263789216-cell-2-3&quot;&gt;
&lt;p&gt;False&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td data-cell-id=&quot;3957-1598263789216-cell-3-0&quot;&gt;
&lt;p&gt;str&lt;/p&gt;
&lt;/td&gt;
&lt;td data-cell-id=&quot;3957-1598263789216-cell-3-1&quot;&gt;
&lt;p&gt;False&lt;/p&gt;
&lt;/td&gt;
&lt;td data-cell-id=&quot;3957-1598263789216-cell-3-2&quot;&gt;
&lt;p&gt;False&lt;/p&gt;
&lt;/td&gt;
&lt;td data-cell-id=&quot;3957-1598263789216-cell-3-3&quot;&gt;
&lt;p&gt;True&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;


&lt;p&gt;这个表只给出了3个数据类型：int、float和str。根据业务不同，这个表可以有多种用途，例如，赋值，是否可以进行运算等。这里就只考虑进行加法运算。 其中True表示允许进行加法运算，False表示不允许进行加法运算，很显然，如果是int + int形式，第1个操作数可以从第1列查找，第2个操作数可以从第1行查找，找到了（1,1）的位置，该位置是True，所以int + int是合法的，int + float，float + float、str + str的情形类似，如果遇到int + str，就会找到(1,3)或(3,1），这两个位置都是False，就表明int + str是不合法的。其实Python和JavaScript都进行到了这一步。只不过Python就直接抛出了异常，而JS则尝试进行类型转换，但都需要进行类型检测。因为类型转换需要确定数据类型的优先级，优先级低的会转换为优先级高的类型，如str的优先级比int高，所以int会转换为str类型。float比int高，所以int会转换为float类型，这就涉及到另外一个类型优先级表了。&lt;/p&gt;

&lt;p&gt;根据这个表可知，编程语言只是在遇到类型不合规的情况下处理的方式不同，这就是编译器（解析器）的业务逻辑了，这个业务逻辑随时可能变（通常不会影响程序的向下兼容），所以是不能用这一特性作为强弱语言标识的，否则强类型和弱类型语言就有可能会不断切换了，因为编程语言会不断进化的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. 为什么应该用类型固化作为强弱类型的标识&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;那么为什么可以用类型固化作为强弱类型的标识呢？因为类型固化通常是不可变的，那么为什么是不可变的呢？下面用Python来举例：&lt;/p&gt;

&lt;p&gt;下面的Python代码是合法的。x从int变成了str，类型并没有固化，所有Python是弱类型语言。&lt;/p&gt;

&lt;div&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
x = 20&lt;span&gt;
x &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;abc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
 &lt;/div&gt;
&lt;p&gt;那么有没有可能Python以后对类型进行固化呢？从技术上来说，完全没问题，但从代码兼容性问题上，将会造成严重的后果。因为类型没固化属于宽松型，一旦类型固化，属于严格型。以前已经遗留了很多宽松的代码，一旦严格，那么就意味着x = 'abc'将会抛出异常，就会造成很多程序无法正常运行。所以如果Python这么做，就相当于一种新语言了，如PythonX，而不能再称为Python了。就像人类进化，无论从远古的尼安德特人，还是智人，或是现代各个国家的人，无论怎么进化，都需要在主线上发展，例如，都有一个脑袋，两条腿，两个胳膊。当然，可能细节不同，如黑眼睛，黄头发等。你不能进化出两个头，8条腿来，当然可以这么进化，但这个就不能再称为人了，就是另外一种生物了。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/32818/202009/32818-20200902075824603-2026422557.png&quot; alt=&quot;&quot; width=&quot;469&quot; height=&quot;494&quot; loading=&quot;lazy&quot;/&gt;

&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/src/A39C2ABA0ECA4EEDB113FFE225B24850&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;p&gt; 现在再看一个相反的例子，如果一种编程语言（如Java）是强类型的，能否以后变成弱类型语言呢？&lt;/p&gt;

&lt;p&gt;看下面的Java代码：&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
int x = 20&lt;span&gt;;
x &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;200&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;;  // 出错
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt; 其实从技术上和兼容性上这么做是没问题的。但也会有很多其他问题，如编译器（或运行时）的处理方式完全不同，我们知道，类型固化的程序要比类型不固化的程序运行效率高，因为类型不固化，需要不断去考虑类型转换的问题。而且在空间分配上更麻烦，有可能会不断分配新的内存空间。例如，对于一个数组来说，js和python（就是列表）是可以动态扩容的，其实这个方式效率很低，需要用算法在合理的范围内不断分配新的内存空间，而Java不同，数组一旦分配内存空间，是不可变的，也就是空间固化（类似于类型固化），这样的运行效率非常高。&lt;/p&gt;

&lt;p&gt;所以一旦编程语言从类型固化变成类型不固化，尽管可以保证代码的兼容性，但编译器或运行时的内部实现机理将完全改变，所以从本质上说，也是另外一种编程语言了。就像人类的进化，尽管从表面上符合人类的所有特征。但内部已经变成生化人了，已经不是血肉之躯了，这也不能称为人类了。&lt;/p&gt;

&lt;p&gt;所以无论往哪个方向变化，都会形成另外一种全新的编程语言，所以用类型固化来作为强弱类型标识是完全没有问题的。&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;3. C++、Java、Kotlin是强类型语言，还是弱类型语言&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;我看到网上有很多文章将C++归为弱类型语言。其实，这我是头一次听说C++有人认为是弱类型语言，是因为C++支持string+int的写法吗？没错，C++是支持这种写法，但直接这么写，语法没问题，但不会得到我们期望的结果，如下面的代码：&lt;/p&gt;

&lt;div id=&quot;2714-1598266418971&quot; data-theme=&quot;default&quot; data-language=&quot;javascript&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
std::cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello, World!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + 3 &amp;lt;&amp;lt; std::endl; 
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;这行代码并不会输出Hello,World!3，要想输出正常的结果，需要进行显式类型转换，代码如下：&lt;/p&gt;

&lt;div id=&quot;4720-1598266884339&quot; data-theme=&quot;default&quot; data-language=&quot;javascript&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
std::cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello, World!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + std::to_string(3) &amp;lt;&amp;lt; std::endl;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;尽管C++编译器支持string+int的写法，但得不到我们期望的结果，所以C++的string和int相加需要进行转换。因此，仅仅通过string+int或类似的不同类型不能直接在一起运算来判断语言是否是强类型和弱类型的规则是站不住脚的。而且C++也支持运算符重载，也就意味着可以让&quot;abc&quot; + 4变成不合法的。&lt;/p&gt;

&lt;p&gt;那么Java是强类型还是弱类型呢？Java是强类型语言，因为很多文章给出了下面的例子（或类似）：&lt;/p&gt;

&lt;p&gt;&quot;666&quot; / 4;&lt;/p&gt;

&lt;p&gt;是的，这个表达式会出错，但你不要忘了，Java支持下面的表达式：&lt;/p&gt;

&lt;p&gt;&quot;666&quot; + 4;&lt;/p&gt;

&lt;p&gt;这行表达式输出了6664，为啥不用加号（+）举例呢？前面歧视Python的乘号，现在又歧视Java里的加号吗？其实这是因为前面描述的类型优先级问题，由于string的优先级高于int，因此4会转换为&quot;4&quot;。所以&quot;666&quot; / 4其实会也会发生隐式类型转换，变成&quot;666&quot;/&quot;4&quot;，两个字符串自然不能相除了，而&quot;666&quot; + 4会变成&quot;666&quot; + &quot;4&quot;，两个字符串当然可以相加了。这就是个语义的问题，和强弱类型有毛关系。&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/src/06C72483ADE54B25868C5B242108CB8A&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;

&lt;p&gt;所以吗？Java是强类型语言没错，但判断依据错了。&lt;/p&gt;

&lt;p&gt;Kotlin是强类型还是弱类型呢？答案是Kotlin是强类型语言。不过Kotlin支持运算符重载，看下面的代码。&lt;/p&gt;

&lt;div id=&quot;6556-1598267716024&quot; data-theme=&quot;default&quot; data-language=&quot;javascript&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyClass(var value: Int) {
    operator fun plus(other: Int): Int {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; value +&lt;span&gt; other;
    }
}
fun main() {
    var my: MyClass &lt;/span&gt;= MyClass(200&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(my + 20);  //&lt;span&gt; 输出220
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;


&lt;p&gt;我们都知道，Kotlin也是JVM上的一种编程语言（尽管可以生成js，但需要用Kotlin专有API），而Java是不支持运算符重载的，在同一个运行时（JVM）上，有的语言支持运算符重载，有的语言不支持运算符重载。从这一点就可以看出，运算符来处理两侧的操作数，只不过是个语法糖而已。想让他支持什么样的运算都可以，如，&quot;abcd&quot; / &quot;cd&quot;，其实也可以让他合法化，例如，语义就表示去掉分子以分母为后缀的子字符串，如果没有该后缀，分子保持不变，所以，&quot;abcd&quot;/&quot;cd&quot;的结果就是&quot;ab&quot;，而&quot;abcd&quot;/&quot;xy&quot;的结果还是&quot;abcd&quot;，语法糖而已，与强弱类型没有半毛钱关系。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4. 静态语言和动态语言&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;现在来说说静态语言和动态语言。 有人说可以用是否实时（在运行时）改变变量类型判别是静态语言还是动态语言，没错，变量类型的实时改变确实是动态语言的特征之一，但并不是全部。动态语言的另一些特征是可以随时随地为类【或其他类似的语法元素】（主要是指自定义的类，有一些语言可能不支持对内建类型和系统类进行扩展）添加成员（包括方法、属性等）。&lt;/p&gt;

&lt;p&gt;例如，下面的JavaScript代码动态为MyClass类添加了一个静态方法（method1）和一个成员方法（method2）。&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt; 
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyClass {

}
&lt;/span&gt;//&lt;span&gt;  动态添加静态方法
MyClass.method1 &lt;/span&gt;=&lt;span&gt; function () {
    console.log(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;static method&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
}

MyClass.method1()         
var my &lt;/span&gt;=&lt;span&gt; new MyClass();
&lt;/span&gt;//&lt;span&gt;  动态添加成员方法
my.method2 &lt;/span&gt;=&lt;span&gt; function () {
    console.log(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;common method&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
}
my.method2()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;Python动态添加成员的方式与JavaScript类似，代码如下：&lt;/p&gt;

&lt;div id=&quot;2885-1598313703409&quot; data-theme=&quot;default&quot; data-language=&quot;javascript&quot; readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyClass:
    &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;

&lt;span&gt;def&lt;/span&gt;&lt;span&gt; method1():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;static method&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 动态添加静态方法&lt;/span&gt;
MyClass.method1 =&lt;span&gt; method1

MyClass.method1()         
my &lt;/span&gt;=&lt;span&gt; MyClass()

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; method2():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;common method&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 动态添加静态方法&lt;/span&gt;
my.method2 =&lt;span&gt; method2
my.method2()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;还有就是数组的动态扩容（根据一定的算法，并不是每一次调用push方法都会增加内存空间），如JavaScript的代码：&lt;/p&gt;
&lt;div id=&quot;3020-1598313885285&quot; data-theme=&quot;default&quot; data-language=&quot;javascript&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
a =&lt;span&gt; []
a.push(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
a.push(&lt;/span&gt;20&lt;span&gt;)
a.push(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;world&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
console.log(a)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;Python的数组（列表）扩容：&lt;/p&gt;
&lt;div id=&quot;1411-1598313958278&quot; data-theme=&quot;default&quot; data-language=&quot;javascript&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
a =&lt;span&gt; []
a.append(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;world&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
a.append(&lt;/span&gt;20&lt;span&gt;)
a.append(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(a)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;当然，动态语言还有很多特性，这里就不一一介绍了。&lt;/p&gt;

&lt;p&gt;这些特性在静态语言（如Java、C++）中是无法做到的。在静态语言中，一个类一旦定义完，就不能再为类动态添加任何成员和移除任何成员，除非修改类的源代码。&lt;/p&gt;

&lt;p&gt;所以说，静态和动态其实涵盖了多个方面，如类型固化，动态扩展、数组扩容等。而强类型和弱类型的特性其实只能算静态和动态的特性之一。也就是说，说一种语言是静态语言，其实已经包含了这种语言的变量类型一旦确定不可改变的事实，也就是静态语言一定是强类型的编程语言。&lt;/p&gt;

&lt;p&gt;如果单独强调强类型，其实就相当于下面这句话：&lt;/p&gt;

&lt;p&gt;这个人是一个男人，而且是一个男演员。&lt;/p&gt;

&lt;p&gt;这句话看起来没毛病，也能看懂，但其实是有语病的。因为前面已经说了这个人是一个男人了，后面就没必要强调是男演员了，而只需要按下面说的即可：&lt;/p&gt;

&lt;p&gt;这个人是一个男人，而且是一个演员。&lt;/p&gt;

&lt;p&gt;现在来总结一下：&lt;/p&gt;

&lt;p&gt;应该用固定不变的特性来标识一种语言的特性。而语言是否支持隐式类型转换，这只是编译器或运行时的内部业务逻辑，相当于语法糖而已，是随时可以改变的。而类型固化，动态扩展、数组扩容，这些涉及到编程语言的根本，一旦改变，就变成了另外一种语言了，所以通常用这些特性标识语言的特性。通常来讲，静态语言的效率会高于动态语言。因为，这些动态特性会让程序有更大负担，如类型不固定，就意味着可能会为新的类型分配新的内存空间，动态扩展和数组扩容也意味着不断进行边界检测和分配新的内存空间（或回收旧的内存空间）。这就是为什么C++、Java、C#等编程语言的性能要高于js、Python的主要原因。&lt;/p&gt;

&lt;p&gt;其实过度强调静态、动态、强类型、弱类型，意义并不大。以为编程语言以后的发展方向是静态语言动态化，弱类型强类型化。都是互相渗透了，如果以后出现一种编程语言，同时拥有静态和动态的特性，其实并不稀奇。例如，尽管变量类型不允许改变，但允许动态为对象添加成员。就和光一样，既是光子（粒子），又是电磁波，也就是说光拥有波粒二象性！ 编程语言也一样，也会同时拥有静动态二象性！&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/32818/202009/32818-20200902080152437-1542983266.png&quot; alt=&quot;&quot; width=&quot;486&quot; height=&quot;401&quot; loading=&quot;lazy&quot;/&gt;

 &lt;/div&gt;

&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/src/164D27CF6A004F33A5F0E87EB82A1D51&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;

&lt;/div&gt;</description>
<pubDate>Wed, 02 Sep 2020 00:05:00 +0000</pubDate>
<dc:creator>银河使者</dc:creator>
<og:description>最近有些学员问我，Python到底是强类型语言，还是弱类型语言。我就直接脱口而出：Python是弱类型语言。没想到有一些学员给我了一些文章，有中文的，有英文的，都说Python是强类型语言。我就很好奇</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/nokiaguy/p/13599816.html</dc:identifier>
</item>
<item>
<title>[漫谈] 软件设计的目标和途径 - blackheart</title>
<link>http://www.cnblogs.com/linianhui/p/objective-and-approach-of-software-design.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/linianhui/p/objective-and-approach-of-software-design.html</guid>
<description>&lt;p&gt;记录一下笔者关于软件设计的一些相关认知。在开始之前，先引入两个概念&lt;code&gt;目标&lt;/code&gt;和&lt;code&gt;途径&lt;/code&gt;(这里可能会有些咬文嚼字，不过主要是为了区分主观和客观的一些细微差异)。&lt;/p&gt;

&lt;p&gt;我们在做某一件事情的时候，总是会带有一定的目的性的：比如说一日三餐，是为了给身体补充所需的能量。那么这三餐具体如何落实呢，则会有多种多样的方式。比如你可以选择吃碳水食物、蔬菜、肉类、牛奶或者蛋类等等；也可以选择通过静脉注射一些所需的葡萄糖或者蛋白质。总之，能够为身体补充能量就可以了。&lt;/p&gt;
&lt;h2 id=&quot;11-目标&quot;&gt;1.1 目标&lt;/h2&gt;
&lt;p&gt;那么在上述的小例子中，我们的&lt;code&gt;目的&lt;/code&gt;就是给身体补充能量，用以维持正常的生命活动所需。当然也可以说是我们的&lt;code&gt;目标&lt;/code&gt;，不过&lt;code&gt;目标&lt;/code&gt;侧重于过程，目的则更强调结果。&lt;/p&gt;
&lt;h2 id=&quot;12-途径&quot;&gt;1.2 途径&lt;/h2&gt;
&lt;p&gt;从上面的例子中可以看出有多种方式可以达成我们的上述&lt;code&gt;目的&lt;/code&gt;。其中每一种方式都是一条达成&lt;code&gt;目的&lt;/code&gt;的&lt;code&gt;途径&lt;/code&gt;，当然我们为了补充均衡的能量，通常会搭配组合几种不同的食物，我把这个称之为手段或者方法。&lt;code&gt;手段&lt;/code&gt;和&lt;code&gt;方法&lt;/code&gt;带有一定的主观性；而&lt;code&gt;途径&lt;/code&gt;则是在描述客观的可供选择的一种方式。&lt;/p&gt;

&lt;p&gt;在开始讨论软件设计之前先问自己一个最基本的问题：我们为什么需要软件？&lt;/p&gt;
&lt;p&gt;笔者认为是为了解决现实中某个领域的相关问题而存在的。就好比最初的计算机是用来计算导弹的弹道的。生活中常用的QQ和微信是为了满足人们的社交通信需求的，淘宝京东等是满足了人们的买买买的需求。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以，软件存在的目的就是它能解决一些领域的相关问题，这是它存在的唯一理由&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;比如在黑客帝国这部电影中，不再被使用的程序只有一个下场，那就是被删除掉。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;假如一开始就有了软件，其实要不要软件设计都不重要了。但是问题在于软件不是凭空产生的，不是从0到1没有中间过程就直接得到了想要的软件的。&lt;strong&gt;在软件从0到1的过程，就是软件设计的作用范围（所以在这里我用软件设计的目标这个概念）&lt;/strong&gt;。因为软件存在的目的在于它能解决一些领域的相关问题，那么首先对软件的最低要求就是它能用，能用来解决问题。比如一个数学上的加减乘除计算器，最低最低的要求是你要能把结果算对吧。所以软件设计的目标是什么？笔者认为就是控制这个从0到1的过程，避免其失控（一旦失控你可能就连最低最低的软件的要求都达不到了）。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://book.douban.com/subject/5344973/&quot;&gt;《领域驱动设计：软件核心复杂性应对之道》&lt;/a&gt;一书的副标题也是这个含义。它的侧重点在于如何利用面向对象的方式应对软件本身的复杂性，从而避免其失控。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;那么笔者对软件设计的目标的认知就是：避免软件的失控。为什么是目标而不是目的呢？是因为软件设计在软件的整个生命周期中都是存在着的，这是一个持续的过程，直到软件不再被使用的那一天；而非只在刚开始设计一下，后续就一成不变了&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;上面推导出软件设计的目标是&lt;strong&gt;避免软件的失控&lt;/strong&gt;。那么是什么东西导致的&lt;strong&gt;失控&lt;/strong&gt;? 你面临的业务太复杂？项目遗留的代码太烂？团队成员水平参差不齐？工期太紧张导致你无暇做设计规划？也许吧，这些或多或少都确实是已经存在的事实。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;业务太复杂难道是失控的原因吗？回想一下&lt;strong&gt;软件的目的&lt;/strong&gt;是什么？&lt;strong&gt;解决一些领域的相关问题&lt;/strong&gt;，那么我们可以让业务的复杂性会消失或者降低吗？答案是肯定的，&lt;strong&gt;不会&lt;/strong&gt;！这里就有人要说你放屁。。。你敢说我们无法降低业务复杂性，打你噢。你就是打死我复杂性也不会降低的，，，&lt;strong&gt;复杂性是业务本身存在的客观属性，是不会以人的意志来改变的，除非你不做它了&lt;/strong&gt;。就像你现在要在淘宝买一个手机，你人在北京，卖方在广州，无论你用什么快递方式，从广州到北京这段物理距离上的时间消耗是无法消除的。你说你比较着急，那好，卖方给你选择空运，很快你就收到货了。你说空运这不是降低了快递时间，和降低复杂性不是一样的吗？ 其实并不是，因为复杂性指的是&lt;strong&gt;无论你用什么快递方式，从广州到北京这段物理距离上的时间消耗是无法消除的&lt;/strong&gt;，指的是这个过程你无法消除。但是总觉得怪怪的对吗？是的，看起来是怪怪的，明明我收到货的时间缩短了，怎么复杂性没有改变呢？所以这里就引申出另外一个概念：&lt;strong&gt;业务交互方式所带来的影响&lt;/strong&gt;。这个影响非常之大，但是往往被我们所忽略，比如你选择购买发货地是北京的卖方了，是不是时间又进一步大大缩短了？&lt;strong&gt;实际业务上也是这样的，业务本身具备的复杂性，以及我们在把业务转化为软件后的交互方式所带来的影响，业务本身的复杂性我们无法降低和消除，但是后者交互方式则是可以控制的，这也是软件设计的一部分，所以其实上面我们选择空运是改变了这部分&lt;/strong&gt;。就好比你是一个B/S的应用软件，你的用户在浏览器中看到了Web页面。这背后你的Web页面从服务器到用户浏览器的过程和浏览器渲染页面的过程是无论如何也无法消除的，但是浏览器可以缓存它，当你下次再打开这个页面时，它就可以省掉上述的交互过程。&lt;/li&gt;
&lt;li&gt;项目遗留的代码太烂是失控的原因吗？其实也不是，这是失控的一种表现结果。&lt;/li&gt;
&lt;li&gt;团队成员水平参差不齐是失控的原因吗？也不是，这虽然是客观存在的事实，但是你这样把责任推到队友身上不合适吧，说不定队友也是这么看你的呢。&lt;/li&gt;
&lt;li&gt;工期太紧张导致你无暇做设计规划是失控的原因吗? 当然也不是，这个是借口。。。就像你今天起床快要迟到了，你会选择光屁股不穿衣服就出门吗？&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;除了上述的一些事实，当然还有其他的一些因素，&lt;strong&gt;看起来都不像是导致失控的罪魁祸首&lt;/strong&gt;。那么究竟是什么导致的失控？？？仔细回想一下，当我们觉得项目失控的时候通常是什么场景？&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;有个已知的bug，你改动的时候发现牵扯的东西太多了，牵一发而动全身，你不敢下手。你觉得代码无法控制了。。。&lt;/li&gt;
&lt;li&gt;有个未知的bug，你找了好久找不到，代码太乱了。你觉得一股无力感。。。&lt;/li&gt;
&lt;li&gt;有个新功能来了，你发现你要改这里那里，但是完全不知道改了会不会破坏现有的功能，也不知道新功能是不是真的可以work。你觉得你无法掌控这些代码了。。。&lt;/li&gt;
&lt;li&gt;还有一些其他的情况，总之就是你觉得你无法掌控代码的真实行为了，你不知道你的代码会产生什么样的结果，就像薛定谔的代码一样。。。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;那么还有一个场景，当你要开展一个新的项目，所有的一切都是新的，没有任何历史债务负担，这时候你是什么感觉？信心满满啊肯定是，这时候你不会觉得你会对接下来的代码失去控制，因为你现在一行代码都还没有。。。&lt;/p&gt;
&lt;p&gt;所以是什么导致的失控？&lt;strong&gt;现存的无力维护(bug、新功能都是维护)的代码导致的失控&lt;/strong&gt;，同时这也是失控的表现结果。那么你为什么会&lt;strong&gt;无力维护&lt;/strong&gt;这些代码，因为它的真实行为和你理解的行为出现了偏差，你觉得它不可控了。这时候就是真的失控了，代码烂不烂其实并不是重点，只要你还能维护，这些都不是问题。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;代码只会按照你编写的行为去执行，而不是按照你认为的行为去执行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那么如何避免失控？&lt;strong&gt;编写可维护的代码&lt;/strong&gt;。打死你噢，解释这么半天憋出这么一句废话，谁不知道要编写可维护的代码啊。。。&lt;/p&gt;
&lt;p&gt;我只能说别着急，继续慢慢往下看。。。&lt;/p&gt;

&lt;p&gt;既然我们的目标是避免失控，避免失控的途径则是&lt;strong&gt;编写可维护的代码&lt;/strong&gt;。那么我就把&lt;strong&gt;可维护性&lt;/strong&gt;作为软件设计的终极目标，而且没有之一。也称之为&lt;strong&gt;元原则&lt;/strong&gt;，就是说我们目前所接触到的各自编程原则、建议和最佳实践等等都可以通过&lt;strong&gt;可维护性&lt;/strong&gt;推导细化出来，并且不可与之相违背。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;打个比喻，就好比宪法是其他一切法律的基础，任何法律如果违背了宪法，那么就是无效的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那么根据&lt;strong&gt;可维护性&lt;/strong&gt;可推导出来3个核心的原则：&lt;strong&gt;可理解性&lt;/strong&gt;、&lt;strong&gt;可测试性&lt;/strong&gt;和&lt;strong&gt;可隔离性&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;51-可理解性&quot;&gt;5.1 可理解性&lt;/h2&gt;
&lt;p&gt;这条原则看起来很有主观性的倾向，但是其实并不是。&lt;/p&gt;
&lt;p&gt;比如说你刚写了一段代码，你觉得容易理解，他看起不容易理解；或者说代码是他写的，他看起来很容易理解，但是到你这里无法一下子理解他的思维，然后你就觉得不好理解。&lt;strong&gt;如果出现了这样的情况，那么则统统都是不可理解的&lt;/strong&gt;。这时候你要说了：你要一棍子打死双方啊。是的，正是如此。再回想一下我们的目标是什么？&lt;strong&gt;可维护性！&lt;/strong&gt; 这里的维护不单单是说你的代码你来维护，而是大家互相交叉着；你新增了一个功能，后续负责其他的事情去了，那么这时候就由你的队友来负责维护了；或者你接手维护别人的代码。&lt;/p&gt;
&lt;p&gt;所以我们需要一个客观上的&lt;strong&gt;可理解性&lt;/strong&gt;。那么到底什么才能叫客观？没法度量啊！其实也不复杂，就是看当你读到一段代码的时候，你是否需要额外的思考，额外的脑中维持一个上下文的环境才能明白这段代码的意图，如果需要，那么就是不可理解的，至少也是不易理解的。&lt;strong&gt;更简单点说就是这段代码应该让你不用思考就看的明白它的意图&lt;/strong&gt;。比如下面的一个小例子，功能是完全等价的，但是差异非常微妙。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;// 1
if(userList.isNotEmpty()){

}

// 2
if(userList.isEmpty() == false){

}

// 3
if(!userList.isEmpty()){

}

// 4
if(userList.length() != 0){

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你觉得可理解性怎么排？ 答案是肯定的吧？&lt;code&gt;1 &amp;gt; 2 &amp;gt; 3 &amp;gt; 4&lt;/code&gt;。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;1是不是你根本就不用思考，直接读下来就知道其含义？&lt;/li&gt;
&lt;li&gt;2则是有一个&lt;code&gt;==fasle&lt;/code&gt;的过程，需要你进行简单的思考。&lt;/li&gt;
&lt;li&gt;3则是接近于2，但是比2更差一点，因为取反符号在前面，但是其决定性的值则在后面，而你的阅读顺序是从左向右，所以你需要一个比2稍微更复杂一点的思考过程。&lt;/li&gt;
&lt;li&gt;前三个还都一眼能看出来是&lt;strong&gt;空&lt;/strong&gt;或者&lt;strong&gt;非空&lt;/strong&gt;的语境，但是4就更差了，4的字面意思是长度不等于0，逻辑上其实和&lt;strong&gt;非空&lt;/strong&gt;是等价的，但是你需要在脑中做这样的一个映射&lt;strong&gt;长度!=0&lt;/strong&gt;等同于&lt;strong&gt;非空&lt;/strong&gt;，这个的抽象层级明显更低了一个层级。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;不知道能否体会其中差细微差异。那么你觉得这些理解是客观的还是主观的呢?&lt;/p&gt;
&lt;h2 id=&quot;52-可测试性&quot;&gt;5.2 可测试性&lt;/h2&gt;
&lt;p&gt;可理解性可以确保你可以快速的理解现存代码的意图，但是其真实的行为呢？是不是和你所认为的行为就是一致的？上面我说过：“&lt;strong&gt;代码只会按照你编写的行为去执行，而不是按照你认为的行为去执行&lt;/strong&gt;”。&lt;/p&gt;
&lt;p&gt;那么如何确保你真实的行为和你所认为的行为是一致的？那就是&lt;strong&gt;测试&lt;/strong&gt;。把你认为的行为也写成代码，去验证你的业务代码执行的时候是不是会按照你给定的输入得到你期望的输出结果。借助自动化的CI，就可以在你每次改动代码时把现有的所有测试都运行一遍，然后你至少可以获得3点收益：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;代码真的时按照你认为的行为去执行的。&lt;/li&gt;
&lt;li&gt;确保你的改动不会破坏现有的代码行为。&lt;/li&gt;
&lt;li&gt;倒逼你的代码进行合理的分解和抽象，不然你很难编写有效的测试。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;当然你可能把测试写错了，，，这种概率就小多了吧。况且假设你真的写错了测试，时间久了，这个错误也就变成了&lt;strong&gt;feature&lt;/strong&gt;。为什么呢？也许你代码的消费方已经按照它实际的行为去处理了，这时候你贸然把这个bug修复了，结果可能时消费方反而不能正常工作了。这时候这个错误的测试其实也就变成了消费方的一种契约测试。确保你不会把它改对，，，&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;比如C#的类库中有个&lt;code&gt;DateTime&lt;/code&gt;，在处理时区问题时很多诡异的行为，这时候微软已经无法修正它了，只好再单独新增了一个&lt;code&gt;DateTimeOffset&lt;/code&gt;，两者共存，慢慢的迁移过去。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;53-可隔离性&quot;&gt;5.3 可隔离性&lt;/h2&gt;
&lt;p&gt;那么现在你可以快速的理解现存的代码了，也可以确保你的新代码不会破坏已有的功能，也确认你的代码行为是你所认为的行为了。是不是就可以愉快的合并代码并且上线发布了？是的，差不多可以了。但是，凡是总有例外，我们不能把全部希望都寄托在我们能严格落实上述两点。总是要有个备选方案对吧？&lt;/p&gt;
&lt;p&gt;可隔离性就是这样的一个备选方案，其意图就是隔离你的代码行为，哪怕它就是腐烂变质成了不可维护的代码，只要不影响其他的模块，那么就还算是可控的。就像万吨巨轮，底层的隔水舱总是一个个的独立的，一个进水了也不影响其他的，从而避免整体的失控。&lt;/p&gt;

&lt;p&gt;还记得文章开始介绍的&lt;strong&gt;目标&lt;/strong&gt;和&lt;strong&gt;途径&lt;/strong&gt;的概念吧，上述的3个原则是我们的目标，那么想要达成这样的目标有哪些途径可供使用呢？&lt;/p&gt;
&lt;h2 id=&quot;61-命名&quot;&gt;6.1 命名&lt;/h2&gt;
&lt;p&gt;曾经有这么一句话，计算机领域有两大难题：命名和缓存失效。一个好名字的重要性不必多说了吧？&lt;strong&gt;此外我还有一个心得体会：如果你觉得命名出现了困难，那么请从头审视一下你的设计，或许你走错了方向了。我认为一旦出现了命名困难的问题，那绝对就是你的设计出现了问题。也许时你的方法职责太多了，你无法用简洁的名字描述清楚，也许是你的字段所表达的含义不清，导致你无法准确的用一个简单的词语描述它&lt;/strong&gt;。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;目标&lt;/th&gt;
&lt;th&gt;效果&lt;/th&gt;
&lt;th&gt;解释&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;可理解性&lt;/td&gt;
&lt;td&gt;++&lt;/td&gt;
&lt;td&gt;增加可读性。&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;可测试性&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;无影响。&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;可隔离性&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;无影响。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;62-单一职责&quot;&gt;6.2 单一职责&lt;/h2&gt;
&lt;p&gt;几乎每个人都明白单一职责的重要性，但是却很容易就忽略它。比如下面的小例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 1
public String sum(
    final Collection&amp;lt;BigDecimal&amp;gt; bigDecimalCollection
) {
  final BigDecimal sumResult = bigDecimalCollection
      .stream()
      .reduce(BigDecimal.ZERO, BigDecimal::add);

  final DecimalFormat format = new DecimalFormat(&quot;#,##0.00&quot;);
  return format.format(sumResult);
}

// 2
public BigDecimal sum(
    final Collection&amp;lt;BigDecimal&amp;gt; bigDecimalCollection
) {  
  return bigDecimalCollection
      .stream()
      .reduce(BigDecimal.ZERO, BigDecimal::add);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;1的职责是不是有点多？&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;目标&lt;/th&gt;
&lt;th&gt;效果&lt;/th&gt;
&lt;th&gt;解释&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;可理解性&lt;/td&gt;
&lt;td&gt;++&lt;/td&gt;
&lt;td&gt;一个关注点使得代码可理解性大大的提升。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;可测试性&lt;/td&gt;
&lt;td&gt;++&lt;/td&gt;
&lt;td&gt;也使得测试更容易实施。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;可隔离性&lt;/td&gt;
&lt;td&gt;++&lt;/td&gt;
&lt;td&gt;单一单一，那不就是隔离开了吗？&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;63-数据模型匹配业务&quot;&gt;6.3 数据模型匹配业务&lt;/h2&gt;
&lt;p&gt;数据模型匹配的含义是说让你的代码真实的表达实际的业务意图，而且这个意图必须要落实到数据层面，而非代码层面。&lt;strong&gt;简而言之就是让你的数据体现你的业务，而不是你的代码体现你的业务&lt;/strong&gt;。感觉有点绕噢，什么鬼意思？我举个小例子：个税计算&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 1
(empployee.salary - 3500) * taxRate;

// 2 employee.exemption = 3500
(empployee.salary - employee.exemption) * taxRate;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你觉得哪种更合适？1就是业务被体现在了代码中，这时候2019年了，个税免征额提高到了5000，你怎么办？改代码呗，3500改成5000不就完事了。对，完事了，那么历史的数据怎么办？有人要对比一下新旧版本的差异，怎么算？没办法，你被逼着写了两个版本，2019年前一个版本的代码，2019年后的一个版本，然后混乱就开始了。&lt;/p&gt;
&lt;p&gt;所以根本问题在哪？就是因为3500这个数字看起来虽然不起眼，但是它本身是业务的一部分，结果却被安置到了代码中。这就是典型的数据模型不匹配业务。这种细节有时候一开始很难察觉到，但是一旦发现可能就已经很难挽回了，代码可以随便改，但是已经存在的历史数据怎么办? 上述的例子还好说点，你可以刷一下历史数据给补上去。但是很多时候数据一开始没有记录，后续就无论如何也无法修补了，导致你的代码被死死的捆绑住，无法再添加新功能了。&lt;/p&gt;
&lt;p&gt;笔者非常认同Linus torvalds的一句话：“烂程序员关心的是代码。好程序员关心的是数据结构和它们之间的关系。”。Git的数据结构非常之稳定，它的底层实际上是一个内容寻址文件系统，在这样的一个底层数据结构之上，十几年来Git新增了n多个功能和命令，但是却一致保持着的兼容性（你用Git早期版本初始化操作一个repo，到了现在的最新版依然是完全匹配的）。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;目标&lt;/th&gt;
&lt;th&gt;效果&lt;/th&gt;
&lt;th&gt;解释&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3.5&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;可理解性&lt;/td&gt;
&lt;td&gt;++&lt;/td&gt;
&lt;td&gt;匹配的模型可以表达真实的业务意图，没有中间转换的环节，可以让你再理解代码时没有额外的心智负担。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;可测试性&lt;/td&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;使得测试更能直观的描述真实的业务行为。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;可隔离性&lt;/td&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;合理的模型划分可以有效的减少不必要的依赖，从而保持相对独立。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;64-抽象层级&quot;&gt;6.4 抽象层级&lt;/h2&gt;
&lt;p&gt;把大象放进冰箱需要几步？&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;把冰箱门打开。&lt;/li&gt;
&lt;li&gt;把大象放进去。&lt;/li&gt;
&lt;li&gt;把冰箱门关上。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;就这么简单，这三件事都是在一个抽象的层级上的。那么再细化一些，打开冰箱门需要几步？还有现在没大象，我要去从动物园先弄过来一个，怎么办?这些细节和上述的三个步骤是不是在一个抽象层级上? 肯定不是吧！&lt;strong&gt;但是我们通常很多时候都是在干着这样的事情，比如业务代码中夹杂着如何拼接SQL语句的代码。当你读到这样的代码的时候会觉得很乱，为什么感觉乱？就是因为其涵盖了不同抽象层级的代码在一起，导致你在前脚还在想着如何把大象放进去这件事的时候，突然发现接下来的是我怎么才能从动物园弄个大象出来这些琐事&lt;/strong&gt;。还记得上面的一个判断非空的一小段代码吧？&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;// 1
if(userList.isNotEmpty()){

}

// 4
if(userList.length() != 0){

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4干的就样的事情，虽然很细微，但是就是这样一个一个细微的不同抽象层级的代码混在一块，就把你的代码搞乱了，搞的可理解性急剧下降。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;目标&lt;/th&gt;
&lt;th&gt;效果&lt;/th&gt;
&lt;th&gt;解释&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3.5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;可理解性&lt;/td&gt;
&lt;td&gt;++&lt;/td&gt;
&lt;td&gt;阅读代码时避免分心去考虑一些不必要的细节问题。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;可测试性&lt;/td&gt;
&lt;td&gt;++&lt;/td&gt;
&lt;td&gt;比如我用一个大象的毛绒玩具也可以完成第2步吧？这就大大的简化了测试的关注点和编写。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;可隔离性&lt;/td&gt;
&lt;td&gt;++&lt;/td&gt;
&lt;td&gt;屏蔽了一些底层的细节。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;65-奥卡姆剃刀&quot;&gt;6.5 奥卡姆剃刀&lt;/h2&gt;
&lt;p&gt;这又是个什么鬼？怎么剃刀都出来了，还嫌发际线不够高吗？其实不是的，这个一个关于简单行的原则，也称之为“&lt;strong&gt;如无必要，勿增实体&lt;/strong&gt;”。就是说如果有两个途径可以完成同样一件事情，那就选择更简单假设更少的那一个。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;目标&lt;/th&gt;
&lt;th&gt;效果&lt;/th&gt;
&lt;th&gt;解释&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;可理解性&lt;/td&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;选择更简单的有助于理解。&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;可测试性&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;无影响。&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;可隔离性&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;无影响。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;看到这里估计有人要忍不住要批判我了：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;可复用性呢？GoF23种设计模式都强调构建可复用性的软件，可复用性跑哪去了？被你吃了啊。&lt;/li&gt;
&lt;li&gt;可靠性呢？健壮性呢？&lt;/li&gt;
&lt;li&gt;高可用性呢？&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;等等吧，就像当年软工课程上罗列的各种指标，或者各种的模式和架构等等。其实不是说这些东西不重要，或者我不认可这些东西，我认可，也理解它们的重要性。&lt;strong&gt;但是有一点要彻底搞清楚，哪些是我们的目标？哪些是我们的途径？&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;71-可复用性只是一种现象&quot;&gt;7.1 可复用性只是一种现象&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;可复用性难道是我们追求的目标吗？我的回答是：否，我们的目标是软件的可维护性&lt;/strong&gt;！那么你说复用就会增加可维护性，其实不尽然，不合适的复用反而会降低可维护性，这是一把双刃剑，借用著哥的一句话：“&lt;strong&gt;越通用越无用&lt;/strong&gt;”。那么你说不是目标也是途径吧！那么我的回答是：也不是途径，你这条途径可能会违宪，你觉得它合适吗？也不是目标，也不是途径，那么它到底是什么？答：只是一种现象，如果你落实了上述的5条途径中的某些途径，你会发现你的代码自然而然就可以复用了。&lt;/p&gt;
&lt;h2 id=&quot;72-设计模式源自缺陷&quot;&gt;7.2 设计模式源自缺陷&lt;/h2&gt;
&lt;p&gt;首先我们看一下设计模式是什么: “是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性、程序的重用性。” 也就是说它是经过验证的一些最佳实践的经验性代码。&lt;strong&gt;那么问题来了，什么时候才需要最佳实践？&lt;/strong&gt;，当你对你所使用的工具出现迷惑的时候，不太清楚怎么处理才好的时候，你需要借鉴一下其他人总结出来的比较好的处理方案才能完成你的工作的时候。这个处理方案，就是设计模式。那么此时你想一想，GoF23的设计模式是在弥补什么的缺陷？OO的啊，人家的副标题是“&lt;strong&gt;可复用面向对象软件的基础&lt;/strong&gt;”。&lt;/p&gt;
&lt;p&gt;当然设计模式也不是OO的专有的东西，凡是通用的那些已命名的最佳实践，都可以称之为设计模式。&lt;/p&gt;
&lt;h2 id=&quot;73-oop不是目的&quot;&gt;7.3 OOP不是目的&lt;/h2&gt;
&lt;p&gt;很多时候在讨论代码的时候，看着代码觉得不舒服，一言不合就互相给对方扣上了一顶帽子，你的代码一点也不OO！这其实大可不必，OO是来解决一些问题的，但是它并不能解决全部问题，那么多static的类或者方法，它OO吗？OO只是解决我们问题的一种途径，也不是唯一的途径，千万不可把工具当目的。&lt;/p&gt;
&lt;h2 id=&quot;74-ddd带来的问题比解决的问题更多&quot;&gt;7.4 DDD带来的问题比解决的问题更多&lt;/h2&gt;
&lt;p&gt;DDD自从诞生之初就面临很多争议。DDD本身出发点非常好(&lt;strong&gt;软件核心复杂性应对之道&lt;/strong&gt;)。DDD是基于OO，在OO之上扩充了很多概念，希望借此最大程度的发挥出OO的优势。但是其扩充的概念太多了，而且千人千面，每个人心中的理解都不尽相同，而且可以说南辕北辙的都有，这就使得它&lt;strong&gt;非常难以在团队中达成理解上的共识&lt;/strong&gt;。也就导致实施落地上的种种困难，即使一开始落地了一部分，随着时间的推移，则会变得越来越难以为继，好像侧重点都跑到了我这么写到底符合DDD的思想吗？而对业务的关注的变成了二等公民，这简直是个灾难，这时候代码的可理解性就非常脆弱了。所以根据奥卡姆剃刀原则，剃掉它是最优的选择。&lt;/p&gt;

&lt;p&gt;以上是笔者关于软件设计的一些思考过程：笔者认为其目标是避免软件的失控以及相关的途径措施，以及对一些常见到的一些概念的看法。如有不妥之处，欢迎来讨论。&lt;/p&gt;

&lt;p&gt;本文首发于：&lt;a href=&quot;https://linianhui.github.io/talk/objective-and-approach-of-software-design/&quot;&gt;https://linianhui.github.io/talk/objective-and-approach-of-software-design/&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 01 Sep 2020 23:08:00 +0000</pubDate>
<dc:creator>blackheart</dc:creator>
<og:description>记录一下笔者关于软件设计的一些相关认知。在开始之前，先引入两个概念目标和途径(这里可能会有些咬文嚼字，不过主要是为了区分主观和客观的一些细微差异)。 1 目标和途径 我们在做某一件事情的时候，总是会带</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/linianhui/p/objective-and-approach-of-software-design.html</dc:identifier>
</item>
<item>
<title>【趣味设计模式系列】之【代理模式4--ASM框架解析】 - 小猪爸爸</title>
<link>http://www.cnblogs.com/father-of-little-pig/p/13594140.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/father-of-little-pig/p/13594140.html</guid>
<description>&lt;h2 id=&quot;1-简介&quot;&gt;1. 简介&lt;/h2&gt;
&lt;p&gt;ASM是assemble英文的简称，中文名为&lt;span&gt;&lt;code&gt;汇编&lt;/code&gt;&lt;/span&gt;，官方地址&lt;a href=&quot;https://asm.ow2.io/&quot;&gt;https://asm.ow2.io/&lt;/a&gt;，下面是官方的一段英文简介：&lt;/p&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;ASM is an all purpose Java bytecode manipulation and analysis framework. It can be used to modify existing classes or to dynamically generate classes, directly in binary form. ASM provides some common bytecode transformations and analysis algorithms from which custom complex transformations and code analysis tools can be built. ASM offers similar functionality as other Java bytecode frameworks, but is focused on performance. Because it was designed and implemented to be as small and as fast as possible, it is well suited for use in dynamic systems (but can of course be used in a static way too, e.g. in compilers).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;ASM is used in many projects, including:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;the OpenJDK, to generate the lambda call sites, and also in the Nashorn compiler,&lt;/li&gt;
&lt;li&gt;the Groovy compiler and the Kotlin compiler,&lt;/li&gt;
&lt;li&gt;Cobertura and Jacoco, to instrument classes in order to measure code coverage,&lt;/li&gt;
&lt;li&gt;CGLIB, to dynamically generate proxy classes (which are used in other projects such as Mockito and EasyMock),&lt;/li&gt;
&lt;li&gt;Gradle, to generate some classes at runtime.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;翻译如下：&lt;br/&gt;ASM是一个通用的Java字节码操作和分析框架。它可用于修改现有的类或直接以二进制形式动态生成类。ASM提供了一些常见的字节码转换和分析算法，从中可以构建定制的复杂转换和代码分析工具。ASM提供了与其他Java字节码框架类似的功能，但侧重于性能。因为它被设计和实现得尽可能的小和快，所以它非常适合在动态系统中使用(当然也可以以静态的方式使用，例如在编译器中)。&lt;br/&gt;主要用途:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;OpenJDK，用来生成lambda调用站点，还有在Nashorn编译器中，&lt;/li&gt;
&lt;li&gt;Groovy编译器和Kotlin编译器，&lt;/li&gt;
&lt;li&gt;Cobertura和Jacoco，用来测量代码覆盖率，&lt;/li&gt;
&lt;li&gt;CGLIB为了动态生成代理类(在其他项目中使用，如mock和EasyMock)，&lt;/li&gt;
&lt;li&gt;Gradle在运行时生成一些类。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;2-框架使用&quot;&gt;2. 框架使用&lt;/h2&gt;
&lt;p&gt;官方提供了使用手册，地址：&lt;a href=&quot;https://asm.ow2.io/asm4-guide.pdf&quot;&gt;https://asm.ow2.io/asm4-guide.pdf&lt;/a&gt;，引入依赖&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;asm&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;asm-all&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;3.3.1&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面结合例子分析&lt;/p&gt;
&lt;h3 id=&quot;21-classreader--解析一个类文件&quot;&gt;2.1 ClassReader--解析一个类文件&lt;/h3&gt;
&lt;p&gt;创建一个T1类&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.wzj.asm;

/**
 * 光标必须位于类体内，View-Show ByteCode
 */

public class T1 {
    int i = 0;
    public void m() {
        int j=1;
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在idea中的安装插件ByteCode插件&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1765702/202009/1765702-20200901160741453-2139009085.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;然后通过idea中的View菜单-&amp;gt;show bytecode看到字节码文件&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1765702/202009/1765702-20200901161159238-719327230.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1765702/202009/1765702-20200901161204634-693495269.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;下面的ClassPrinter类用来实现解析T1.Class这个类&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.wzj.asm;

import org.objectweb.asm.ClassReader;
import org.objectweb.asm.ClassVisitor;
import org.objectweb.asm.FieldVisitor;
import org.objectweb.asm.MethodVisitor;

import java.io.IOException;

import static org.objectweb.asm.Opcodes.ASM4;

/**
 * @Author: wzj
 * @Date: 2020/8/5 21:29
 * @Desc: 解析一个类
 */
public class ClassPrinter extends ClassVisitor {
    public ClassPrinter() {
        super(ASM4);
    }

    @Override
    public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {
        System.out.println(name + &quot; extends &quot; + superName + &quot;{&quot; );
    }

    @Override
    public FieldVisitor visitField(int access, String name, String descriptor, String signature, Object value) {
        System.out.println(&quot;    &quot; + name);
        return null;
    }

    @Override
    public MethodVisitor visitMethod(int access, String name, String descriptor, String signature, String[] exceptions) {
        System.out.println(&quot;    &quot; + name + &quot;()&quot;);
        return null;
    }

    @Override
    public void visitEnd() {

        System.out.println(&quot;}&quot;);
    }

    public static void main(String[] args) throws IOException {
        ClassPrinter cp = new ClassPrinter();
        ClassReader cr = new ClassReader(
                ClassPrinter.class.getClassLoader().getResourceAsStream(&quot;com/wzj/asm/T1.class&quot;));


        cr.accept(cp, 0);
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;visit方法访问类的类名、父类等信息，visitField方法访问类的属性信息，visitMethod方法访问类的方法信息，最后打印出该类的信息&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1765702/202009/1765702-20200901162507030-1939924642.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;22-classwriter--生成一个类文件&quot;&gt;2.2 ClassWriter--生成一个类文件&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;package com.wzj.asm;

import org.objectweb.asm.ClassWriter;

import java.io.File;
import java.io.FileOutputStream;

import static org.objectweb.asm.Opcodes.*;

/**
 * @Author: wzj
 * @Date: 2020/8/5 21:26
 * @Desc: 生成一个类
 */
public class ClassWriterTest {
    public static void main(String[] args) throws Exception {
        ClassWriter cw = new ClassWriter(0);
        cw.visit(V1_8, ACC_PUBLIC + ACC_ABSTRACT + ACC_INTERFACE,
                &quot;pkg/Comparable&quot;, null, &quot;java/lang/Object&quot;,
                null);
        cw.visitField(ACC_PUBLIC + ACC_FINAL + ACC_STATIC, &quot;LESS&quot;, &quot;I&quot;,
                null, -1).visitEnd();
        cw.visitField(ACC_PUBLIC + ACC_FINAL + ACC_STATIC, &quot;EQUAL&quot;, &quot;I&quot;,
                null, 0).visitEnd();
        cw.visitField(ACC_PUBLIC + ACC_FINAL + ACC_STATIC, &quot;GREATER&quot;, &quot;I&quot;,
                null, 1).visitEnd();
        cw.visitMethod(ACC_PUBLIC + ACC_ABSTRACT, &quot;compareTo&quot;,
                &quot;(Ljava/lang/Object;)I&quot;, null, null).visitEnd();
        cw.visitEnd();
        byte[] b = cw.toByteArray();

        MyClassLoader myClassLoader = new MyClassLoader();
        Class c = myClassLoader.defineClass(&quot;pkg.Comparable&quot;, b);
        System.out.println(c.getMethods()[0].getName());

        String path = (String)System.getProperties().get(&quot;user.dir&quot;);
        File f = new File(path + &quot;/com/wzj/asm/&quot;);
        f.mkdirs();
        FileOutputStream fos = new FileOutputStream(new File(path + &quot;/com/wzj/asm/Comparable.class&quot;));
        fos.write(b);
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;自定义一个类加载器&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.wzj.asm;

/**
 * @Author: wzj
 * @Date: 2020/8/5 21:26
 * @Desc: 自定义类加载器
 */
public class MyClassLoader extends ClassLoader{
    public Class defineClass(String name, byte[] b) {
        return defineClass(name, b, 0, b.length);
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;生成的类文件如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package pkg;

public interface Comparable {
    int LESS = -1;
    int EQUAL = 0;
    int GREATER = 1;

    int compareTo(Object var1);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;23-利用classvisitor对原始类方法增强功能&quot;&gt;2.3 利用ClassVisitor对原始类方法增强功能&lt;/h3&gt;
&lt;p&gt;依然使用之前代理系列的例子Apple类&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.wzj.asm;

import com.wzj.proxy.v8.Sellalbe;

import java.util.Random;

/**
 * @Author: wzj
 * @Date: 2020/8/3 10:29
 * @Desc: 待销苹果
 */
public class Apple implements Sellalbe {

    @Override
    public void secKill() {
        System.out.println(&quot;苹果正在秒杀中...&quot;);
        try {
            Thread.sleep(new Random().nextInt(3000));
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ClassTransformedTest类，内部类ClassVisitor实现父类的方法visitMethod，并在方法中判断目标方法为secKill时，对该方法增加TimeProxy.before()方法，代码如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.wzj.asm;

import org.objectweb.asm.*;

import java.io.File;
import java.io.FileOutputStream;

import static org.objectweb.asm.Opcodes.ASM4;
import static org.objectweb.asm.Opcodes.INVOKESTATIC;


/**
 * @Author: wzj
 * @Date: 2020/9/1 21:10
 * @Desc: 类方法增强
 */
public class ClassTransformedTest {
    public static void main(String[] args) throws Exception {
        ClassReader cr = new ClassReader(
                ClassPrinter.class.getClassLoader().getResourceAsStream(&quot;com/wzj/asm/Apple.class&quot;));

        ClassWriter cw = new ClassWriter(0);
        ClassVisitor cv = new ClassVisitor(ASM4, cw) {
            //增强secKill方法, 在方法里加入时间代理
            @Override
            public MethodVisitor visitMethod(int access, String name, String descriptor, String signature, String[] exceptions) {
                MethodVisitor mv = super.visitMethod(access, name, descriptor, signature, exceptions);
                return new MethodVisitor(ASM4, mv) {
                    @Override
                    public void visitCode() {
                        if(name.equals(&quot;secKill&quot;)) {
                            visitMethodInsn(INVOKESTATIC, &quot;com/wzj/asm/TimeProxy&quot;,&quot;before&quot;, &quot;()V&quot;, false);
                            super.visitCode();
                        }
                    }
                };
            }
        };


        cr.accept(cv, 0);
        byte[] b2 = cw.toByteArray();

        MyClassLoader cl = new MyClassLoader();
        Class c2 = cl.defineClass(&quot;com.wzj.asm.Apple&quot;, b2);
        c2.getConstructor().newInstance();


        String path = (String)System.getProperties().get(&quot;user.dir&quot;);
        File f = new File(path + &quot;/com/wzj/asm/&quot;);

        if(!f.exists()) {
            f.mkdirs();
        }

        FileOutputStream fos = new FileOutputStream(new File(path + &quot;/com/wzj/asm/Apple.class&quot;));
        fos.write(b2);
        fos.flush();
        fos.close();

    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最终生成的增强类如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.wzj.asm;

import com.wzj.proxy.v8.Sellalbe;
import java.util.Random;

public class Apple implements Sellalbe {
    public Apple() {
    }

    public void secKill() {
        TimeProxy.before();
        System.out.println(&quot;苹果正在秒杀中...&quot;);

        try {
            Thread.sleep((long)(new Random()).nextInt(3000));
        } catch (InterruptedException var2) {
            var2.printStackTrace();
        }

    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;3-框架剖析&quot;&gt;3. 框架剖析&lt;/h2&gt;
&lt;p&gt;ASM的核心类是ClassVisitor、MethodVisitor，通过&lt;span&gt;&lt;code&gt;访问者模式&lt;/code&gt;&lt;/span&gt;，对字节码文件类的信息、方法的信息进行增加或者修改，因为对于一个java的class类，它的结构是完全固定的，包括大致10几项，分别为Magic（魔数）、Version（版本）、Constant Pool（常量池）、Access_flag（访问标识）、This Class（本实例指针）、Super Class（父类实例指针）、Interfaces（接口）、Fields（字段）、Methods（方法）、Class attributes（类属性）等。&lt;/p&gt;
&lt;p&gt;在 ASM 中，ClassReader 类，它能正确的分析字节码，构建出抽象的树在内存中表示字节码。它会调用 accept 方法，这个方法接受一个实现了 ClassVisitor 接口的对象实例作为参数，然后依次调用 ClassVisitor 接口的各个方法。字节码空间上的偏移被转换成 visit 事件时间上调用的先后，所谓 visit 事件是指对各种不同 visit 函数的调用， ClassReader 知道如何调用各种 visit 函数。在这个过程中用户无法对操作进行干涉，所以遍历的算法是确定的，用户可以做的是提供不同的 Visitor 来对字节码树进行不同的修改。&lt;/p&gt;
&lt;p&gt;ClassVisitor 会产生一些子过程，比如 visitMethod 会返回一个实现 MethordVisitor 接口的实例， visitField 会返回一个实现 FieldVisitor 接口的实例，完成子过程后控制返回到父过程，继续访问下一节点。因此对于 ClassReader 来说，其内部顺序访问是有一定要求的。实际上用户还可以不通过 ClassReader 类，自行手工控制这个流程，只要按照一定的顺序，各个 visit 事件被先后正确的调用，最后就能生成可以被正确加载的字节码。当然获得更大灵活性的同时也加大了调整字节码的复杂度。&lt;/p&gt;
&lt;p&gt;各个 ClassVisitor 通过职责链 （Chain-of-responsibility） 模式，可以非常简单的封装对字节码的各种修改，而无须关注字节码的字节偏移，因为这些实现细节对于用户都被隐藏了，用户要做的只是覆写相应的 visit 函数。官方给出了如下图说明通过责任链修改类，分别代表简单责任链与复杂责任链下各种的应用&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1765702/202009/1765702-20200901225137694-1164167531.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1765702/202009/1765702-20200901224420304-1244011987.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ClassAdaptor 类实现了 ClassVisitor 接口所定义的所有函数，当新建一个 ClassAdaptor 对象的时候，需要传入一个实现了 ClassVisitor 接口的对象，作为职责链中的下一个访问者 （Visitor），这些函数的默认实现就是简单的把调用委派给这个对象，然后依次传递下去形成职责链。当用户需要对字节码进行调整时，只需从 ClassAdaptor 类派生出一个子类，覆写需要修改的方法，完成相应功能后再把调用传递下去。这样，用户无需考虑字节偏移，就可以很方便的控制字节码。官方也给出了一个适配器模式的图&lt;/p&gt;
&lt;p&gt;每个 ClassAdaptor 类的派生类可以仅封装单一功能，比如删除某函数、修改字段可见性等等，然后再加入到职责链中，这样耦合更小，重用的概率也更大，但代价是产生很多小对象，而且职责链的层次太长的话也会加大系统调用的开销，用户需要在低耦合和高效率之间作出权衡。&lt;/p&gt;
</description>
<pubDate>Tue, 01 Sep 2020 22:31:00 +0000</pubDate>
<dc:creator>小猪爸爸</dc:creator>
<og:description>1. 简介 ASM是assemble英文的简称，中文名为汇编，官方地址https://asm.ow2.io/，下面是官方的一段英文简介： ASM is an all purpose Java byte</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/father-of-little-pig/p/13594140.html</dc:identifier>
</item>
</channel>
</rss>