<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>python+unittest+requests+HTMLRunner编写接口自动化测试集 - kristin_n</title>
<link>http://www.cnblogs.com/kristin/p/10387970.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kristin/p/10387970.html</guid>
<description>&lt;p&gt;&lt;strong&gt;问题描述：&lt;/strong&gt;&lt;br/&gt;搭建接口测试框架，执行用例请求多个不同请求方式的接口&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;实现步骤：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;① 创建配置文件config.ini，写入部分公用参数，如接口的基本url、测试报告文件路径、测试数据文件路径等配置项&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;[DATABASE]
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; data_address = ./data/&lt;span&gt;data.xlsx
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; report_address = ./report/
&lt;span&gt;4&lt;/span&gt; driver = ./drivers/&lt;span&gt;chromedriver.exe
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; 
&lt;span&gt;6&lt;/span&gt; &lt;span&gt;[HTTP]
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; base_url = https://***.***.cn//
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;② 从配置文件中读取并返回文件中内容，或写入配置文件的方法，文件命名 readConfig.py&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; os
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; configparser
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取当前py文件地址&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; proDir = os.path.split(os.path.realpath(&lt;span&gt;__file__&lt;/span&gt;&lt;span&gt;))[0]
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 组合config文件地址&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; configPath = os.path.join(proDir,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;config.ini&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ReadConfig:
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取当前路径下的配置文件&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;         self.cf =&lt;span&gt; configparser.ConfigParser()
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        self.cf.read(configPath)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_config(self,field,key):
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取配置文件中的key值&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         result =&lt;span&gt; self.cf.get(field,key)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; result
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; set_config(self,field,key,value):
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 向配置文件中写入配置信息&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;         fb = open(configPath,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        self.cf.set(field,key,value)
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         self.cf.write(fb)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;③ 从配置文件中获取到接口的基本url后，根据不同的接口请求方式读取请求体或其他参数信息，参数信息从excel中读取，因此文件readExcel.py用于读取并返回excel文件中内容，或写入Excel的方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; xlrd
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; xlutils.copy
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; Base.readConfig &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ReadConfig
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ReadExcel:
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self,section,field,sheet):
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 打开工作表，并定位到sheet&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         data_address =&lt;span&gt; ReadConfig().get_config(section,field)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         workbook =&lt;span&gt; xlrd.open_workbook(data_address)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         self.table =&lt;span&gt; workbook.sheets()[sheet]
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_rows(self):
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取excel行数&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         rows =&lt;span&gt; self.table.nrows
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; rows
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_cell(self,row,col):
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取单元格数据&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;         cell_data =&lt;span&gt; self.table.cell(row,col).value
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; cell_data
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_col(self,col):
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取整列数据&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;         col_data =&lt;span&gt; self.table.col_value(col)
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; col_data
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WriteExcel:
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self,section,field,sheet):
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 打开工作表&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;         self.address =&lt;span&gt; ReadConfig().get_config(section,field)
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         self.workbook =&lt;span&gt; xlrd.open_workbook(self.address)
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         self.wf =&lt;span&gt; xlutils.copy.copy(self.workbook)
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         self.ws =&lt;span&gt; self.wf.get_sheet(sheet)
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; set_cell(self,row,col,value):
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置单元格数据&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt; &lt;span&gt;        self.ws.write(row,col,value)
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; 
&lt;span&gt;42&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; save_excel(self,filename,format):
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取当前时间&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt;         self.time = time.strftime(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%Y%m%d%H%M%S&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, time.localtime())
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;生成文件的文件名及格式&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt;         self.report = filename + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;_&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; +self.time +&lt;span&gt; format
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;保存文件&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt;         self.wf.save(self.report)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;④ 将获取接口的url、请求头、参数等方法封装成类并写入base.py中，用于测试框架中测试集的直接调取&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; Base.readConfig &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ReadConfig
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; Base.readExcel &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ReadExcel
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 实例化&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; readexcel = ReadExcel(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;DATABASE&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;data_address&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,0)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BasePage(object):
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, selenium_driver):
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         self.driver =&lt;span&gt; selenium_driver
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_api(self, row, col):
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取url&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;         self.base_url = ReadConfig().get_config(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;HTTP&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;base_url&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取excel中的接口地址,与url进行拼接&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;         self.url = self.base_url +&lt;span&gt; readexcel.get_cell(row, col)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(self.url)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; self.url
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_cell(self, row, col):
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取excel单元格数据,获取接口请求的参数&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;         self.cell =&lt;span&gt; readexcel.get_cell(row, col)
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; self.cell
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;⑤ 从base.py文件获取到请求地址后，需要组合不同类型的请求方式，如get请求直接将参数与地址进行拼接，或post请求以json数据格式等为请求体请求接口，然后再获取接口对象，得到接口返回的数据，此过程涉及的方法封装到request_way.py（注：该实例get请求返回数据格式为jsonp，因此需要jsonp格式数据转换为json格式的方法）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; Base.readExcel &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ReadExcel
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; base &lt;span&gt;import&lt;/span&gt;&lt;span&gt; BasePage
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; requests
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; urllib.parse
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; json
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; re
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 实例化&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; readexcel = ReadExcel(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;DATABASE&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;data_address&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,0)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; jsonp格式数据转换为json格式&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; jsonp_to_json(_jsonp):
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;      &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 解析jsonp数据格式为json&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; json.loads(re.match(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.*?({.*}).*&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, _jsonp, re.S).group(1&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;except&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;raise&lt;/span&gt; ValueError(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Invalid Input&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RequestPage(BasePage):
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; post方式请求,json格式为请求体&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; post_requests(self, url, i):
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 定义请求数据,获取excel中参数信息赋值给data,以json格式拼接好数据&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;         data_1_json = json.dumps(BasePage(self.driver).get_cell(i, 4&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         data_2_json = json.dumps(BasePage(self.driver).get_cell(i + 1, 4&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         data = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + data_1_json + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + data_2_json + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(data)
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 打开请求,获取对象&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;         response =&lt;span&gt; requests.post(url, data)
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 打印状态码&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(response)
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; response
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; get方式请求&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_request(self, url, j):
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 定义请求数据,获取excel中参数信息赋值给values&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;values = {}&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;         values = BasePage(self.driver).get_cell(j, 4&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果参数不止一个则对请求数据进行编码拼接'&amp;amp;'&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;data = urllib.parse.urlencode(values)&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将数据与url进行拼接&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt;         req = url + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;?&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; +&lt;span&gt; values
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(req)
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 打开请求,获取对象&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt;         response =&lt;span&gt; urllib.request.urlopen(req)
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 打印Http状态码&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(response.status)
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 读取服务器返回的数据,对HTTPResponse类型数据进行读取操作,bytes格式数据编译成中文编码&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt;         the_page = response.read().decode(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;unicode_escape&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将返回的bytes格式数据先转换成str,再将返回的jsonp格式数据转换成json格式&lt;/span&gt;
&lt;span&gt;50&lt;/span&gt;         the_page =&lt;span&gt; jsonp_to_json(str(the_page))
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; the_page
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;⑥ 得到接口实际返回结果后，需要与预期结果做比对，判断用例执行结果，所以封装校验类到check.py文件。校验方式其一是校验json数组内每个数值是否一致，其二是直接简单校验数组中的status值和message是否返回正确&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;75&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; base &lt;span&gt;import&lt;/span&gt;&lt;span&gt; BasePage
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; Base.readExcel &lt;span&gt;import&lt;/span&gt;&lt;span&gt; WriteExcel
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 实例化&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; writeexcel = WriteExcel(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;DATABASE&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;data_address&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,0)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CheckPage(BasePage):
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 校验json数组内每个值是否一致&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; check_value(self, i, actualresult, expectresult):
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 遍历字典的值value,并将value赋值给实际接口数据的值&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; value &lt;span&gt;in&lt;/span&gt;&lt;span&gt; actualresult.values():
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             actualresult_value =&lt;span&gt; value
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 遍历字典的值value,并将value赋值给excel中预期数据的值&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; value &lt;span&gt;in&lt;/span&gt;&lt;span&gt; expectresult.values():
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             expectresult_value =&lt;span&gt; value
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果实际接口返回的每个键值与excel中预期返回的数据的每个键值一样,则接口测试用例执行通过,如果不是则打印预期结果和实际结果,可比较差异&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; actualresult_value ==&lt;span&gt; expectresult_value:
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             writeexcel.set_cell(i, 8, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;SUCCESS&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;接口用例执行结果通过&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             writeexcel.set_cell(i, 8, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;FAILURE&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             writeexcel.set_cell(i, 7&lt;span&gt;, str(actualresult))
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;第&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, i + 1, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;行用例执行失败：预期结果是&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, expectresult, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;实际结果是&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, actualresult)
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 保存测试报告&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;         writeexcel.save_excel(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;testreport&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;.xls&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 校验json数组中的status值和message是否返回成功&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; easy_check_value(self, i, actualresult,expectresult):
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 判断实际接口值是否状态码和消息返回成功&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; actualresult[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;status&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] == 1 &lt;span&gt;and&lt;/span&gt; actualresult[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;message&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;完成&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;             writeexcel.set_cell(i, 8, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;SUCCESS&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;第&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, i+1, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;行用例执行结果正确,用例通过&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;             writeexcel.set_cell(i, 8, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;FAILURE&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;             writeexcel.set_cell(i, 7&lt;span&gt;, str(actualresult))
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;第&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, i + 1, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;行用例执行失败：预期结果是&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, expectresult, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;实际结果是&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, actualresult)
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; 
&lt;span&gt;40&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 保存测试报告&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt;         writeexcel.save_excel(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;testreport&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;.xls&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;⑦ 最后编写测试集 testcase.py，其中用例包含有执行post和get方式的请求，增加用例可直接在该文件继续添加编写&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; unittest
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; selenium &lt;span&gt;import&lt;/span&gt;&lt;span&gt; webdriver
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; Base.readConfig &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ReadConfig
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; base &lt;span&gt;import&lt;/span&gt;&lt;span&gt; BasePage
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; requests_way &lt;span&gt;import&lt;/span&gt;&lt;span&gt; RequestPage
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; check &lt;span&gt;import&lt;/span&gt;&lt;span&gt; CheckPage
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; packages.HTMLTestRunner &lt;span&gt;import&lt;/span&gt;&lt;span&gt; HTMLTestRunner
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; driver = webdriver.Chrome(ReadConfig().get_config(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;DATABASE&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;driver&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SmokeTest(unittest.TestCase):
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;初始化&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; setUp(self):
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         self.driver =&lt;span&gt; driver
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; test_case_10(self):
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;以json格式数据为请求体的post方式接口请求&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取url&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;         self.url = BasePage(self.driver).get_api(1,1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将接口实际返回数据转换为json可序列化,使用json.dumps()时需要对象相应的类型是json可序列化的&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;         i = 3
&lt;span&gt;23&lt;/span&gt;         actualresult =&lt;span&gt; RequestPage(self.driver).post_requests(self.url, i).json()
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取excel中的预期结果&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;         expectresult = eval(BasePage(self.driver).get_cell(i, 6&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 校验实际接口返回结果和用例预期结果是否一致(校验json数组内每个值是否一致)&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;        CheckPage(self.driver).check_value(i, actualresult, expectresult)
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; test_case_11(self):
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;get方式接口请求&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取url&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;         self.url = BasePage(self.driver).get_api(8, 1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取接口实际返回值与excel中的预期结果&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;         j = 8
&lt;span&gt;38&lt;/span&gt;         actualresult =&lt;span&gt; RequestPage(self.driver).get_request(self.url, j)
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         expectresult = eval(BasePage(self.driver).get_cell(j, 6&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; 
&lt;span&gt;41&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 校验实际接口返回结果和用例预期结果是否一致(校验json数组中的status值和message是否返回成功)&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt; &lt;span&gt;        CheckPage(self.driver).easy_check_value(j, actualresult, expectresult)
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; 
&lt;span&gt;44&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 释放资源&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; test_case_12(self):
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;         self.driver.quit()
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; 
&lt;span&gt;48&lt;/span&gt; 
&lt;span&gt;49&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;构造测试集合&lt;/span&gt;
&lt;span&gt;51&lt;/span&gt;     suite =&lt;span&gt; unittest.TestSuite()
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;     suite.addTest(SmokeTest(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test_case_10&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;     suite.addTest(SmokeTest(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test_case_11&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;     suite.addTest(SmokeTest(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test_case_12&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; 
&lt;span&gt;56&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建html文件&lt;/span&gt;
&lt;span&gt;57&lt;/span&gt;     filename = ReadConfig().get_config(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;DATABASE&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;report_address&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;testreport.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;58&lt;/span&gt;     fp = open(filename, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;wb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; 
&lt;span&gt;60&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;执行测试并生成html测试报告&lt;/span&gt;
&lt;span&gt;61&lt;/span&gt;     runner = HTMLTestRunner(stream=fp, description=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;接口用例执行情况：&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, title=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;接口自动化测试报告&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; &lt;span&gt;    runner.run(suite)
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; 
&lt;span&gt;64&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;关闭文件&lt;/span&gt;
&lt;span&gt;65&lt;/span&gt;     fp.close()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;⑧ 其中涉及HTMLTestRunner.py原生HTML测试报告库，是用于生成测试报告testreport.html，模块下载后直接集成到该项目&lt;/p&gt;
&lt;p&gt;模块下载地址：&lt;a href=&quot;http://tungwaiyip.info/software/HTMLTestRunner.html&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;http://tungwaiyip.info/software/HTMLTestRunner.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;⑨ 以python文件模式执行脚本才能生成测试报告&lt;/p&gt;
&lt;p&gt;参考：&lt;a href=&quot;https://www.cnblogs.com/kristin/p/10332815.html&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/kristin/p/10332815.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;以上，整体框架如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1318318/201902/1318318-20190216153735732-391643163.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;执行方式正确得到以下两种类型测试报告，excel表和html测试报告&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1318318/201902/1318318-20190216153803917-1175267998.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1318318/201902/1318318-20190216153812463-1759891685.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 16 Feb 2019 07:40:00 +0000</pubDate>
<dc:creator>kristin_n</dc:creator>
<og:description>问题描述：搭建接口测试框架，执行用例请求多个不同请求方式的接口 实现步骤： ① 创建配置文件config.ini，写入部分公用参数，如接口的基本url、测试报告文件路径、测试数据文件路径等配置项 ②</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kristin/p/10387970.html</dc:identifier>
</item>
<item>
<title>[洛谷P1731][NOI1999]生日蛋糕(dfs)(剪枝) - 6954717</title>
<link>http://www.cnblogs.com/lyp-Bird/p/10387860.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lyp-Bird/p/10387860.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;典型的深搜+剪枝策略&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;我们采用&lt;strong&gt;可行性剪枝、上下界剪枝、优化搜索顺序剪枝、最优性剪枝&lt;/strong&gt;的方面来帮助我们进行剪枝。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;也许有人还不知道剪枝，那我就弱弱地为大家补习一下吧qwq：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;&lt;span&gt;.优化搜索顺序：
在一些搜索问题中，搜索树的各个层次、各个分支之间的顺序是不固定的。不同的搜索顺序会产生不同的搜索树形态，其规模大小也相差甚远。因此，我们可以采用排序、更改等手段来优化时间或者空间上的复杂度，借此来优化我们的程序。
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;.排除等效冗余
在搜索过程中，如果我们能够判定从搜索树的当前节点沿着某几条不同的分支到达的子树是等效的，那么只需要对于其中的一条分支进行搜索。这中优化的方法应用的时候十分有效(而且只需要一个&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;qwq)。
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;.可行性剪枝
在搜索过程中，及时对当前状态进行检查，如果发现分支已经无法到达递归的边界，就执行回溯。这就好比我们在道路上行走时，远远地看到前方是一个死胡同，就应该立即折返绕路，而不是走到这个死胡同的尽头再返回。
某些题目的范围限制是一个区间，此时可行性剪枝也被称为&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;上下界剪枝&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;。
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;.最优性剪枝
在最优化问题的搜索过程中，如果当前花费的代价已经超过当前搜索到的最优解，那么无论采取多么优秀的策略到达递归边界，都不可能更新答案。此时可以停止对当前分支的搜索，执行回溯。
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;.记忆化
可以记录每个状态的搜索结果，在重复遍历一个状态时直接检索并返回。这好比我们对图进行深度优先遍历时，标记一个节点是否已经被访问过。(类似于visit[],或者像线段树懒标记之类的.我是这么理解的qwq)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;span&gt;题目背景&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;7月17日是Mr.W的生日，ACM-THU为此要制作一个体积为Nπ的M层&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;生日蛋糕，每层都是一个圆柱体。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;设从下往上数第i(1&amp;lt;=i&amp;lt;=M)层蛋糕是半径为Ri, 高度为Hi的圆柱。当i&amp;lt;M时，要求&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;R_i&amp;gt;R_{i+1}&lt;span class=&quot;katex-html&quot;&gt;&lt;span class=&quot;strut&quot;&gt;&lt;span class=&quot;strut bottom&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;mord&quot;&gt;&lt;span class=&quot;mord mathit&quot;&gt;R&lt;span class=&quot;msupsub&quot;&gt;&lt;span class=&quot;vlist-t vlist-t2&quot;&gt;&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot;&gt;&lt;span class=&quot;pstrut&quot;&gt;&lt;span class=&quot;sizing reset-size6 size3 mtight&quot;&gt;&lt;span class=&quot;mord mathit mtight&quot;&gt;i&lt;span class=&quot;vlist-s&quot;&gt;​&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot;&gt;&lt;span class=&quot;mrel&quot;&gt;&amp;gt;&lt;span class=&quot;mord&quot;&gt;&lt;span class=&quot;mord mathit&quot;&gt;R&lt;span class=&quot;msupsub&quot;&gt;&lt;span class=&quot;vlist-t vlist-t2&quot;&gt;&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot;&gt;&lt;span class=&quot;pstrut&quot;&gt;&lt;span class=&quot;sizing reset-size6 size3 mtight&quot;&gt;&lt;span class=&quot;mord mtight&quot;&gt;&lt;span class=&quot;mord mathit mtight&quot;&gt;i&lt;span class=&quot;mbin mtight&quot;&gt;+&lt;span class=&quot;mord mtight&quot;&gt;1&lt;span class=&quot;vlist-s&quot;&gt;​&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot;&gt;且&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;H_i&amp;gt;H_{i+1}&lt;span class=&quot;katex-html&quot;&gt;&lt;span class=&quot;strut&quot;&gt;&lt;span class=&quot;strut bottom&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;mord&quot;&gt;&lt;span class=&quot;mord mathit&quot;&gt;H&lt;span class=&quot;msupsub&quot;&gt;&lt;span class=&quot;vlist-t vlist-t2&quot;&gt;&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot;&gt;&lt;span class=&quot;pstrut&quot;&gt;&lt;span class=&quot;sizing reset-size6 size3 mtight&quot;&gt;&lt;span class=&quot;mord mathit mtight&quot;&gt;i&lt;span class=&quot;vlist-s&quot;&gt;​&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot;&gt;&lt;span class=&quot;mrel&quot;&gt;&amp;gt;&lt;span class=&quot;mord&quot;&gt;&lt;span class=&quot;mord mathit&quot;&gt;H&lt;span class=&quot;msupsub&quot;&gt;&lt;span class=&quot;vlist-t vlist-t2&quot;&gt;&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot;&gt;&lt;span class=&quot;pstrut&quot;&gt;&lt;span class=&quot;sizing reset-size6 size3 mtight&quot;&gt;&lt;span class=&quot;mord mtight&quot;&gt;&lt;span class=&quot;mord mathit mtight&quot;&gt;i&lt;span class=&quot;mbin mtight&quot;&gt;+&lt;span class=&quot;mord mtight&quot;&gt;1&lt;span class=&quot;vlist-s&quot;&gt;​&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot;&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由于要在蛋糕上抹奶油，为尽可能节约经费，我们希望蛋糕外表面（最下一层的下底面除外）的面积Q最小。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;令Q= Sπ&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;请编程对给出的N和M，找出蛋糕的制作方案（适当的Ri和Hi的值），使S最小。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（除Q外，以上所有数据皆为正整数）&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;题目描述&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1564195/201902/1564195-20190216143419555-724546632.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;输入输出格式&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;输入格式：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有两行，第一行为N（N&amp;lt;=20000），表示待制作的蛋糕的体积为Nπ；第二行为M(M&amp;lt;=15)，表示蛋糕的层数为M。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;输出格式：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;仅一行，是一个正整数S（若无解则S=0）。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;样例&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;输入样例：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;输出样例：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;下面我们进行一下这个问题的求解思路：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.上下界剪枝：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当我们在第dep层的时候，我们只在下面的范围枚举半径和高度即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先，枚举R∈[dep,min($\sqrt{N-v}$&lt;/span&gt;&lt;span&gt;,r[dep+1]-1)];&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其次，枚举H∈[dep,min($\sqrt{N-v}/R^2$,h[dep+1]-1)];&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;2.优化搜索顺序&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;在上面确定的范围中进行倒序枚举。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;3.可行性剪枝&lt;span&gt;(画个五角星)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;可以预处理出从上往下前i(1≤i≤M)层的最小体积和侧面积。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;显然，当第1~i层的半径分别取1,2,3···i时，有最小体积和侧面积。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;如果当前体积V加上1~dep-1层的最小体积大于N，则可以剪枝。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;4.最优性剪枝(1)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;如果当前表面积s加上1~dep-1层的最小侧面积大于已经搜到的结果，剪枝。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;5.最优性剪枝(2)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;利用h和r数组，1~dep-1层的体积可表示为n-v=∑(dep-1,k=1)h[k]*r[k]^2,1~dep层的表面积可以表示为2∑(dep-1,k=1)h[k]*r[k]。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;因为2∑(dep-1,k=1)h[k]*r[k]=2/r[dep]*∑(dep-1,k=1)h[k]*r[k]*r[dep]≥2/r[dep]*∑(dep-1,k=1)h[k]*r[k]^2≥2(n-v)/r[dep]。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;所以当2(n-v)/r[dep]+s大于已经搜到的结果时，可以剪枝。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;加上以上五个剪枝后，搜索算法就可以快速求出该问题的最优解。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;完整代码如下:&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
#include&amp;lt;iostream&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;cstdio&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;cmath&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;algorithm&amp;gt;
&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; r[&lt;span&gt;10086&lt;/span&gt;],h[&lt;span&gt;10086&lt;/span&gt;],n,m,dep,minn=&lt;span&gt;0x7fffffff&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; dfs(&lt;span&gt;int&lt;/span&gt; dep,&lt;span&gt;int&lt;/span&gt; leftdep,&lt;span&gt;int&lt;/span&gt; leftv,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; nowv)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(leftv&amp;lt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(dep&amp;gt;m+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(nowv&amp;gt;=&lt;span&gt;minn)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(leftv==&lt;span&gt;0&lt;/span&gt;&amp;amp;&amp;amp;dep==m+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
    {
        nowv&lt;/span&gt;+=r[&lt;span&gt;1&lt;/span&gt;]*r[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
        minn&lt;/span&gt;=&lt;span&gt;min(nowv,minn);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ;
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(nowv+leftdep+r[&lt;span&gt;1&lt;/span&gt;]*r[&lt;span&gt;1&lt;/span&gt;]&amp;gt;&lt;span&gt;minn)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(leftv-(r[dep-&lt;span&gt;1&lt;/span&gt;]*r[dep-&lt;span&gt;1&lt;/span&gt;]*h[dep-&lt;span&gt;1&lt;/span&gt;]*leftdep)&amp;gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=r[dep-&lt;span&gt;1&lt;/span&gt;]-&lt;span&gt;1&lt;/span&gt;;i&amp;gt;=leftdep;i--&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; j=h[dep-&lt;span&gt;1&lt;/span&gt;]-&lt;span&gt;1&lt;/span&gt;;j&amp;gt;=leftdep;j--&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(leftv-i*i*j&amp;gt;=&lt;span&gt;0&lt;/span&gt;&amp;amp;&amp;amp;dep&amp;lt;=&lt;span&gt;m)
        {
            r[dep]&lt;/span&gt;=&lt;span&gt;i;
            h[dep]&lt;/span&gt;=&lt;span&gt;j;
            dfs(dep&lt;/span&gt;+&lt;span&gt;1&lt;/span&gt;,leftdep-&lt;span&gt;1&lt;/span&gt;,leftv-i*i*j,nowv+(&lt;span&gt;2&lt;/span&gt;*i*&lt;span&gt;j));
            r[dep]&lt;/span&gt;=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            h[dep]&lt;/span&gt;=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        }
    }
}
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;n,&amp;amp;&lt;span&gt;m);
    r[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;]=&lt;span&gt;sqrt(n);
    h[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;]=&lt;span&gt;sqrt(n);
    dfs(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;,m,n,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(minn==&lt;span&gt;0x7fffffff&lt;/span&gt;&lt;span&gt;)
    {
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    }
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,minn);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;写完了长长的博文，下面来总结一下心得吧qwq：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.搜索算法面对的状态我们可以将其理解为一个岔路口的选择问题，也就是可以看作一个多元组，其中每一元都是问题状态空间中的一个&quot;维度&quot;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这其中每一个维度发生变化，都会移动状态空间中的一个&quot;点&quot;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而这些维度通常在题目中也会出现，这些便需要大家在做题的时候多留心观察一下我们所需要的条件以及我们根据这些维度的变化能够得到什么，从而得出合理的搜索框架。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.搜索过程中的剪枝，其实我们就是针对于每一个&quot;维度&quot;与其该维度的边界条件，加以缩放、推导，得出一个相应的不等式，以减少搜索树的扩张从而达到优化复杂度的目的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.为了进一步提高我们剪枝的&quot;效率&quot;以及我们的所要求的目的，我们可以除了对当前所花费的代价之外，也对该状态未来的&quot;状态&quot;进行分析，有时我们还可以跨维度进行优化分析，达到我们的要求(也就是全面优化qwq)，同时这也更容易接近我们的目的。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;手写不易，各位客官点个赞呗(花花)&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 16 Feb 2019 07:13:00 +0000</pubDate>
<dc:creator>6954717</dc:creator>
<og:description>典型的深搜+剪枝策略 我们采用可行性剪枝、上下界剪枝、优化搜索顺序剪枝、最优性剪枝的方面来帮助我们进行剪枝。 也许有人还不知道剪枝，那我就弱弱地为大家补习一下吧qwq： 题目背景 7月17日是Mr.W</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lyp-Bird/p/10387860.html</dc:identifier>
</item>
<item>
<title>SpringBoot整合JdbcTemplate连接Mysql - 凉城</title>
<link>http://www.cnblogs.com/liangblog/p/10387769.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liangblog/p/10387769.html</guid>
<description>
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.sql.DataSource;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.ignite.IgniteSystemProperties;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.boot.SpringApplication;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.boot.autoconfigure.ImportAutoConfiguration;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.boot.autoconfigure.SpringBootApplication;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Bean;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.jdbc.core.JdbcTemplate;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.jdbc.datasource.DriverManagerDataSource;


@SpringBootApplication
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Application {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
        

        SpringApplication.run(Application.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, args);
    }

    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; JdbcTemplate jdbcTemplate() {
        DriverManagerDataSource dataSource &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DriverManagerDataSource();
        dataSource.setDriverClassName(&lt;/span&gt;&quot;com.mysql.jdbc.Driver&quot;&lt;span&gt;);
        dataSource.setUrl(&lt;/span&gt;&quot;jdbc:mysql://127.0.0.1:3306/test&quot;&lt;span&gt;);
        dataSource.setUsername(&lt;/span&gt;&quot;root&quot;&lt;span&gt;);
        dataSource.setPassword(&lt;/span&gt;&quot;123456&quot;&lt;span&gt;);

        JdbcTemplate jdbcTemplate &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JdbcTemplate(dataSource);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; jdbcTemplate;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;添加依赖：&lt;/p&gt;
&lt;p&gt;apply plugin: 'org.springframework.boot'&lt;br/&gt;apply plugin: 'io.spring.dependency-management'&lt;/p&gt;
&lt;p&gt;springBoot {&lt;br/&gt;executable = true&lt;br/&gt;mainClass = 'com.test.Application'&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;dependencies {&lt;br/&gt;compile &quot;org.springframework.boot:spring-boot-starter-web:${verSpringBoot}&quot;&lt;/p&gt;
&lt;p&gt;compile &quot;mysql:mysql-connector-java:5.1.21&quot;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
</description>
<pubDate>Sat, 16 Feb 2019 06:52:00 +0000</pubDate>
<dc:creator>凉城</dc:creator>
<og:description>添加依赖： apply plugin: 'org.springframework.boot'apply plugin: 'io.spring.dependency-manage</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liangblog/p/10387769.html</dc:identifier>
</item>
<item>
<title>Webpack Tapable原理详解 - apy</title>
<link>http://www.cnblogs.com/qiqingfu/p/10387634.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qiqingfu/p/10387634.html</guid>
<description>&lt;h2 id=&quot;directory&quot;&gt;directory&lt;/h2&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;    - src
        - sim    ---- 简单的模拟实现
        - /.js$/ ---- 使用&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;detailed&quot;&gt;Detailed&lt;/h2&gt;
&lt;p&gt;Webpack 就像一条生产线, 要经过一系列的处理流程才能将源文件转换成输出结果。这条生产线上的每个流程都是单一的, 多个流程之间存在依赖关系。只能完成当前处理后才会转交到下一个流程。&lt;/p&gt;
&lt;p&gt;插件就像一个插入到生产线中的一个功能, 它会在特定的时机对生产线上的资源进行处理。&lt;/p&gt;
&lt;p&gt;这条生产线很复杂, Webpack则是通过 &lt;code&gt;tapable&lt;/code&gt; 核心库来组织这条生产线。&lt;/p&gt;
&lt;p&gt;Webpack 在运行中会通过 &lt;code&gt;tapable&lt;/code&gt; 提供的钩子进行广播事件, 插件只需要监听它关心的事件,就可以加入到这条生产线中,去改变生产线的运作。使得 Webpack整体扩展性很好。&lt;/p&gt;
&lt;h2 id=&quot;tapable-hook&quot;&gt;Tapable Hook&lt;/h2&gt;
&lt;p&gt;Tapable 提供同步(Sync)和异步(Async)钩子类。而异步又分为 &lt;code&gt;异步串行&lt;/code&gt;、&lt;code&gt;异步并行&lt;/code&gt;钩子类。&lt;/p&gt;
&lt;h2 id=&quot;右键图片在新标签中查看完整图片&quot;&gt;右键图片,在新标签中查看完整图片&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://qiqingfu.github.io/webpack-tapable/common/images/1.png&quot; alt=&quot;Tapable Hook Class&quot;/&gt;&lt;/p&gt;
&lt;p&gt;逐个分析每个钩子类的使用及其原理&lt;/p&gt;
&lt;h2 id=&quot;同步钩子类&quot;&gt;同步钩子类&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;SyncHook&lt;/li&gt;
&lt;li&gt;SyncBailHook&lt;/li&gt;
&lt;li&gt;SyncWaterfallHook&lt;/li&gt;
&lt;li&gt;SyncLoopHook&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;同步钩子类通过实例的 &lt;code&gt;tap&lt;/code&gt; 方法监听函数, 通过 &lt;code&gt;call&lt;/code&gt;发布事件&lt;/p&gt;
&lt;h3 id=&quot;synchook&quot;&gt;SyncHook&lt;/h3&gt;
&lt;p&gt;同步串行不关心订阅函数执行后的返回值是什么。其原理是将监听(订阅)的函数存放到一个数组中, 发布时遍历数组中的监听函数并且将发布时的 &lt;code&gt;arguments&lt;/code&gt;传递给监听函数&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;class SyncHook {
    constructor(options) {
        this.options = options
        this.hooks = []  //存放监听函数的数组
    }
    tap(name, callback) {
        this.hooks.push(callback)
    }
    call(...args) {
        for (let i = 0; i &amp;lt; this.hooks.length; i++) {
            this.hooks[i](...args)
        }
    }
}

const synchook = new SyncHook('name')
// 注册监听函数
synchook.tap('name', (data) =&amp;gt; {
    console.log('name', data)
})
synchook.tap('age', (data) =&amp;gt; {
    console.log('age', data)
})

// 发布事件
synchook.call('qiqingfu')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打印结果:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;name qiqingfu
age qiqingfu&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;syncbailhook&quot;&gt;SyncBailHook&lt;/h3&gt;
&lt;p&gt;同步串行, 但是如果监听函数的返回值不为 &lt;code&gt;null&lt;/code&gt;, 就终止后续的监听函数执行&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;class SyncBailHook {
        constructor(options) {
          this.options = options
          this.hooks = []
    }
    tap(name, callback) {
        this.hooks.push(callback)
    }
    call(...args) {
        let ret, i = 0
        do {
            // 将第一个函数的返回结果赋值给ret, 在while中如果结果为 true就继续执行do代码块
            ret = this.hooks[i++](...args)
        } while(!ret)
    }
}

const syncbailhook = new SyncBailHook('name')

syncbailhook.tap('name', (data) =&amp;gt; {
    console.log('name', data)
    return '我的返回值不为null'
})
syncbailhook.tap('age', (data) =&amp;gt; {
    console.log('age', data)
})

syncbailhook.call('qiqingfu')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;name qiqingfu&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;syncwaterfallhook&quot;&gt;SyncWaterfallHook&lt;/h3&gt;
&lt;p&gt;同步串行瀑布流, 瀑布流指的是第一个监听函数的返回值,做为第二个监听函数的参数。第二个函数的返回值作为第三个监听函数的参数,依次类推...&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;class SyncWaterfallHook {
    constructor(options) {
          this.options = options
          this.hooks = []
    }
    tap(name, callback) {
        this.hooks.push(callback)
    }
    call(...args) {
        let [firstHook, ...otherHooks] = this.hooks
        /**
         * 通过解构赋值先取出第一个监听函数执行
         * 并且将第一个函数的执行结果传递给第二个, 第二个传递给第三个,迭代的过程 
         */
        let ret = firstHook(...args)
        otherHooks.reduce((f,n) =&amp;gt; {
            return n(f)
        }, ret)
    }
}

const syncWaterfallHook = new SyncWaterfallHook('name')

syncWaterfallHook.tap('name', data =&amp;gt; {
    console.log('name', data)
    return 23
})
syncWaterfallHook.tap('age', data =&amp;gt; {
    console.log('age', data)
})

syncWaterfallHook.call('qiqingfu')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打印结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;name qiqingfu
age 23&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;syncloophook&quot;&gt;SyncLoopHook&lt;/h3&gt;
&lt;p&gt;同步串行, 如果监听函数的返回值为 &lt;code&gt;true&lt;/code&gt;, 则反复执行当前的监听函数,直到返回指为 &lt;code&gt;undefind&lt;/code&gt;则继续执行下面的监听函数&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;class SyncLoopHook {
  constructor(options) {
    this.options = options
    this.hooks = []
    }
    tap(name, callback) {
    this.hooks.push(callback)
    }
    call(...args) {
        for (let i = 0; i &amp;lt; this.hooks.length; i++) {
            let hook = this.hooks[i], ret
            do{
                ret = hook(...args)
            }while(ret === true &amp;amp;&amp;amp; ret !== undefined)
        }
    }
}

const syncLoopHook = new SyncLoopHook('name')

let n1 = 0
syncLoopHook.tap('name', data =&amp;gt; {
    console.log('name', data)
    return n1 &amp;lt; 2 ? true : undefined
})
syncLoopHook.tap('end', data =&amp;gt; {
    console.log('end', data)
})

syncLoopHook.call('qiqingfu')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;name qiqingfu
name qiqingfu
name qiqingfu  第三次打印的时候, n1的指为2, 返回值为 undefined则执行后面的监听函数
end qiqingfu&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;异步钩子&quot;&gt;异步钩子&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;异步并行 &lt;code&gt;(Parallel)&lt;/code&gt;
&lt;ul&gt;&lt;li&gt;AsyncParallelHook&lt;/li&gt;
&lt;li&gt;AsyncParalleBailHook&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;异步串行 &lt;code&gt;(Series)&lt;/code&gt;
&lt;ul&gt;&lt;li&gt;AsyncSeriesHook&lt;/li&gt;
&lt;li&gt;AsyncSeriesBailHook&lt;/li&gt;
&lt;li&gt;AsyncSeriesWaterfallHook&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;凡有异步,必有回调&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;同步钩子是通过 &lt;code&gt;tap&lt;/code&gt;来监听函数的, &lt;code&gt;call&lt;/code&gt;来发布的。&lt;/p&gt;
&lt;p&gt;异步钩子是通过 &lt;code&gt;tapAsync&lt;/code&gt; 或 &lt;code&gt;tapPromise&lt;/code&gt; 来监听函数,通过 &lt;code&gt;callAsync&lt;/code&gt; 或 &lt;code&gt;promise&lt;/code&gt;来发布订阅的。&lt;/p&gt;
&lt;h3 id=&quot;asyncparallelhook&quot;&gt;AsyncParallelHook&lt;/h3&gt;
&lt;p&gt;异步并行, 监听的函数会一块执行, 哪个函数先执行完就先触发。不需要关心监听函数的返回值。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;class AsyncParallelHook {
    constructor(options) {
        this.options = options
        this.asyncHooks = []
    }
    // 订阅
    tapAsync(name, callback) {
        this.asyncHooks.push(callback)
    }
    // 发布
    callAsync(...args) {
        /**
         * callAsync(arg1, arg2,..., cb)
         * 发布的时候最后一个参数可以是回调函数
         * 订阅的每一个函数的最后一个参数也是一个回调函数,所有的订阅函数执行完
         * 且都调用了最后一个函数,才会执行cb 
         */
    const finalCallback = args.pop()
        let i = 0
        // 将这个作为最后一个参数传过去,使用的时候选择性调用
        const done = () =&amp;gt; {
            ++i === this.asyncHooks.length &amp;amp;&amp;amp; finalCallback()
        }
        this.asyncHooks.forEach(hook =&amp;gt; {
            hook(...args, done)
        })
    }
}

const asyncParallelHook = new AsyncParallelHook('name')

asyncParallelHook.tapAsync('name', (data, done) =&amp;gt; {
    setTimeout(() =&amp;gt; {
    console.log('name', data)
    done()
  }, 2000)
})
asyncParallelHook.tapAsync('age', (data, done) =&amp;gt; {
    setTimeout(() =&amp;gt; {
    console.log('age', data)
    done()
  }, 3000)
})

console.time('time')
asyncParallelHook.callAsync('qiqingfu', () =&amp;gt; {
  console.log('监听函数都调用了 done')
  console.timeEnd('time')
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打印结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;name qiqingfu
age qiqingfu
监听函数都调用了 done
time: 3002.691ms&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;asyncparallebailhook&quot;&gt;AsyncParalleBailHook&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;暂时不理解&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;asyncserieshook&quot;&gt;AsyncSeriesHook&lt;/h3&gt;
&lt;p&gt;异步串行钩子类, 不关心 &lt;code&gt;callback&lt;/code&gt;的参数。异步函数一个一个的执行,但是必须调用 done函数。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;class AsyncSeriesHook {
    constructor(options) {
        this.options = options
        this.asyncHooks = []
    }
    tapAsync(name, callback) {
        this.asyncHooks.push(callback)
    }
    callAsync(...args) {
        const finalCallback = args.pop()
        
        let i = 0
        const done = () =&amp;gt; {
            let task = this.asyncHooks[i++]
            task ? task(...args, done) : finalCallback()
        }
        done()
    }
}

const asyncSeriesHook = new AsyncSeriesHook('name')

asyncSeriesHook.tapAsync('name', (data, done) =&amp;gt; {
    setTimeout(() =&amp;gt; {
        console.log('name', data)
        done()
    }, 1000)
})

asyncSeriesHook.tapAsync('age', (data, done) =&amp;gt; {
    setTimeout(() =&amp;gt; {
        console.log('age', data)
        done()
    }, 2000)
})

console.time('time')
asyncSeriesHook.callAsync('qiqingfu', () =&amp;gt; {
    console.log('end')
    console.timeEnd('time')
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;name qiqingfu
age qiqingfu
end
time: 3010.915ms&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;asyncseriesbailhook&quot;&gt;AsyncSeriesBailHook&lt;/h3&gt;
&lt;p&gt;同步串行钩子类, callback的参数如果不是 &lt;code&gt;null&lt;/code&gt;, 后面所有的异步函数都不会执行,直接执行 &lt;code&gt;callAsync&lt;/code&gt;方法的回调函数&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;class AsyncSeriesBailHook {
    constructor(options) {
        this.options = options
        this.asyncHooks = []
    }
    tapAsync(name, callback) {
        this.asyncHooks.push(callback)
    }
    callAsync(...args) {
        const finalCallback = args.pop()

        let i = 0
        const done = data =&amp;gt; {
      if (data) return finalCallback()
      let task = this.asyncHooks[i++]
      task ? task(...args, done) : finalCallback()
        }
        done()
    }
}

const asyncSeriesBailHook = new AsyncSeriesBailHook('name')

asyncSeriesBailHook.tapAsync('1', (data, done) =&amp;gt; {
    setTimeout(() =&amp;gt; {
        console.log('1', data)
        done(null)
    }, 1000)
})

asyncSeriesBailHook.tapAsync('2', (data, done) =&amp;gt; {
    setTimeout(() =&amp;gt; {
        console.log('2', data)
        done(null)
    }, 2000)
})

console.time('times')
asyncSeriesBailHook.callAsync('qiqingfu', () =&amp;gt; {
    console.log('end')
    console.timeEnd('times')
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打印结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1 qiqingfu
2 qiqingfu
end
times: 3012.060ms&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;asyncserieswaterfallhook&quot;&gt;AsyncSeriesWaterfallHook&lt;/h3&gt;
&lt;p&gt;同步串行钩子类, 上一个监听函数 callback(err, data)的第二个参数, 可以作为下一个监听函数的参数&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;class AsyncSeriesWaterfallHook {
    constructor(options) {
        this.options = options
        this.asyncHooks = []
    }
    tapAsync(name, callback) {
        this.asyncHooks.push(callback)
    }
    callAsync(...args) {
        const finalCallback = args.pop()

        let i = 0, once
        const done = (err, data) =&amp;gt; {
            let task = this.asyncHooks[i++]
            if (!task) return finalCallback()
            if (!once) {
                // 只执行一次
                task(...args, done)
                once = true
            } else {
                task(data, done)
            }
        }
        done()
    }
}

const asyncSeriesWaterfallHook = new AsyncSeriesWaterfallHook('name')

asyncSeriesWaterfallHook.tapAsync('1', (data, done) =&amp;gt; {
    setTimeout(() =&amp;gt; {
        console.log('1', data)
        done(null, '第一个callback传递的参数')
    }, 1000)
})

asyncSeriesWaterfallHook.tapAsync('2', (data, done) =&amp;gt; {
    setTimeout(() =&amp;gt; {
        console.log('2', data)
        done(null)
    }, 1000)
})

console.time('timer')
asyncSeriesWaterfallHook.callAsync('qiqingfu', () =&amp;gt; {
    console.log('end')
    console.timeEnd('timer')
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打印结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1 qiqingfu
2 第一个callback传递的参数
end
timer: 2015.445ms&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;end&quot;&gt;END&lt;/h2&gt;
&lt;p&gt;如果理解有误, 麻烦纠正!&lt;/p&gt;
&lt;h2 id=&quot;参考文章&quot;&gt;参考文章&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5abf33f16fb9a028e46ec352&quot;&gt;webpack4.0源码分析之Tapable&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.codercto.com/a/21587.html&quot;&gt;webpack 4.0 Tapable 类中的常用钩子函数源码分析&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 16 Feb 2019 06:19:00 +0000</pubDate>
<dc:creator>apy</dc:creator>
<og:description>directory Detailed Webpack 就像一条生产线, 要经过一系列的处理流程才能将源文件转换成输出结果。这条生产线上的每个流程都是单一的, 多个流程之间存在依赖关系。只能完成当前处理</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qiqingfu/p/10387634.html</dc:identifier>
</item>
<item>
<title>设计模式总结：工厂模式 - 叫我明羽</title>
<link>http://www.cnblogs.com/cmyxn/p/10387529.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cmyxn/p/10387529.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;工厂模式属于创建型设计模式，用工厂方法代替new操作，让子类去决定实例化哪个类，工厂方法将一个类的实例化延迟到子类&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;推荐访问我的个人网站，排版更好看呦：&lt;a href=&quot;https://chenmingyu.top/design-factory-method/&quot; class=&quot;uri&quot;&gt;https://chenmingyu.top/design-factory-method/&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;什么是工厂模式&quot;&gt;什么是工厂模式&lt;/h4&gt;
&lt;p&gt;定义一个创建对象的接口，由子类去决定实例化哪一个类，将实例化对象的操作延迟到子类&lt;/p&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;解耦：调用方不用负责对象的创建，只需要使用，明确各自的职责&lt;/li&gt;
&lt;li&gt;维护方便：后期如果创建对象时需要修改代码，也只需要去工厂方法中修改，易拓展&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;工厂模式细分为：简单工厂，工厂模式，抽象工厂&lt;/p&gt;
&lt;h4 id=&quot;简单工厂&quot;&gt;简单工厂&lt;/h4&gt;
&lt;p&gt;以游戏为例子，涉及四个类：GameFactory（游戏工厂类），Gameable（游戏接口），ShootGame（射击类游戏），TowerDefenceGame（塔防类游戏）&lt;/p&gt;
&lt;p&gt;比如游戏工厂，工厂方法通过出入的参数生成生成不同产品类型的游戏&lt;/p&gt;
&lt;h5 id=&quot;gameable&quot;&gt;Gameable&lt;/h5&gt;
&lt;p&gt;游戏接口，提供一个校验账户信息的接口&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * @auther: chenmingyu
 * @date: 2019/2/14 11:19
 * @description:
 */
public interface Gameable {

    /**
     * 校验账户信息
     * @param nickName
     */
    void validateAccount(String nickName);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;shootgame&quot;&gt;ShootGame&lt;/h5&gt;
&lt;p&gt;射击类游戏，实现Gameable接口&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * @auther: chenmingyu
 * @date: 2019/2/14 11:26
 * @description: 射击类游戏
 */
public class ShootGame implements Gameable{

    @Override
    public void validateAccount(String nickName) {
        System.out.println(&quot;射击游戏校验昵称：&quot;+nickName);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;towerdefencegame&quot;&gt;TowerDefenceGame&lt;/h5&gt;
&lt;p&gt;塔防类游戏，实现Gameable接口&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * @auther: chenmingyu
 * @date: 2019/2/14 11:28
 * @description: 塔防类游戏
 */
public class TowerDefenceGame implements Gameable{

    @Override
    public void validateAccount(String nickName) {
        System.out.println(&quot;塔防游戏校验昵称：&quot;+nickName);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;gamefactory&quot;&gt;GameFactory&lt;/h5&gt;
&lt;p&gt;游戏工厂，封装了创建游戏对象的过程&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * @auther: chenmingyu
 * @date: 2019/2/14 11:29
 * @description: 工厂类
 */
public class GameFactory {

    /**
     * 根据传入类型生成实例
     * @param gameType
     * @return
     */
    public static Gameable creator(String gameType){
        Gameable gameable = null;
        if(StringUtils.isEmpty(gameType)){
            return gameable;
        }
        if(&quot;shoot&quot;.equalsIgnoreCase(gameType)){
            gameable = new ShootGame();
        }else if(&quot;towerDefence&quot;.equalsIgnoreCase(gameType)){
            gameable = new TowerDefenceGame();
        }
        return gameable;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;测试&quot;&gt;测试&lt;/h5&gt;
&lt;p&gt;客户端决定实例化哪个对象&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void main(String[] args) {
    Gameable shootGame = GameFactory.creator(&quot;shoot&quot;);
    shootGame.validateAccount(&quot;明羽&quot;);
    System.out.println(&quot;... 分割线 ...&quot;);
    Gameable towerDefenceGame = GameFactory.creator(&quot;towerDefence&quot;);
    towerDefenceGame.validateAccount(&quot;明羽&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;射击游戏校验昵称：明羽
... 分割线 ...
塔防游戏校验昵称：明羽&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果要新增一个拳击类游戏的话，就需要新建一个拳击游戏类，然后修改工厂方法。&lt;/p&gt;
&lt;h4 id=&quot;工厂模式&quot;&gt;工厂模式&lt;/h4&gt;
&lt;p&gt;工厂模式跟简单工厂模式的区别在于简单工厂只有一个工厂类，提供了一个工厂方法，由入参决定生产那个产品，而工厂模式则定义一个工厂接口，不同的产品工厂实现工厂接口，生产的产品由产品工厂决定&lt;/p&gt;
&lt;p&gt;以游戏为例子，在上面四个类的基础上修改GameFactory（游戏工厂类）为接口，新增了两个类：ShootGameFactory（射击类游戏工厂），TowerDefenceGameFactory（塔防类游戏工厂）&lt;/p&gt;
&lt;h5 id=&quot;修改了的gamefactory&quot;&gt;修改了的GameFactory&lt;/h5&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * @auther: chenmingyu
 * @date: 2019/2/14 11:29
 * @description: 工厂类
 */
public interface GameFactory {

    /**
     * 生成实例
     * @return
     */
    Gameable creator();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;shootgamefactory&quot;&gt;ShootGameFactory&lt;/h5&gt;
&lt;p&gt;实现GameFactory，重写creator()&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * @auther: chenmingyu
 * @date: 2019/2/14 15:14
 * @description: 射击类游戏工厂
 */
public class ShootGameFactory implements GameFactory{

    @Override
    public Gameable creator() {
        return new ShootGame();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;towerdefencegamefactory&quot;&gt;TowerDefenceGameFactory&lt;/h5&gt;
&lt;p&gt;实现GameFactory，重写creator()&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * @auther: chenmingyu
 * @date: 2019/2/14 15:15
 * @description: 塔防类游戏工厂
 */
public class TowerDefenceGameFactory implements GameFactory{

    @Override
    public Gameable creator() {
        return new TowerDefenceGame();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;测试-1&quot;&gt;测试&lt;/h5&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * @auther: chenmingyu
 * @date: 2019/2/14 11:38
 * @description:
 */
public class FactoryTest {

    public static void main(String[] args) {

        GameFactory shootGameFactory = new ShootGameFactory();
        Gameable shootGame = shootGameFactory.creator();
        shootGame.validateAccount(&quot;明羽&quot;);
        System.out.println(&quot;... 分割线 ...&quot;);
        GameFactory towerDefenceGameFactory = new TowerDefenceGameFactory();
        Gameable towerDefenceGame = towerDefenceGameFactory.creator();
        towerDefenceGame.validateAccount(&quot;明羽&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;射击游戏校验昵称：明羽
... 分割线 ...
塔防游戏校验昵称：明羽&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;抽象工厂&quot;&gt;抽象工厂&lt;/h4&gt;
&lt;p&gt;抽象工厂比工厂模式更为抽象，工厂模式只生产一种产品族，而抽象工厂生产多个产品族&lt;/p&gt;
&lt;p&gt;&lt;em&gt;产品族是指同一工厂生产的一组不同产品结构的一组产品，比如射击游戏工厂生产单人射击游戏和双人射击游戏两款产品，这里的单人射击游戏产和双人射击游戏两款产品统称为产品族&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;以上面的游戏为例，现在有射击游戏和塔防游戏俩款游戏，现在需求变了，要求射击类游戏又细分为单人和双人两款游戏产品，塔防类游戏细分为单人和双人两款游戏产品。这时射击类游戏和塔防类游戏就是两个产品族，旗下分别有两款产品一款是单人游戏，一款是双人游戏&lt;/p&gt;
&lt;h5 id=&quot;类图&quot;&gt;类图&lt;/h5&gt;
&lt;p&gt;有点复杂，画个类图，看着清晰一些&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/16/168f4d4d4c90c7a4?w=1047&amp;amp;h=586&amp;amp;f=png&amp;amp;s=41927&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;GameFactory：抽象工厂，规定了生成单人和双人两种游戏&lt;/li&gt;
&lt;li&gt;ShootGameFactory，ShootGameFactory：具体工厂，负责生产具体的射击类和塔防类单，双人游戏&lt;/li&gt;
&lt;li&gt;Gameable是抽象产品，ShootGame和TowerDefenceGame是抽象类，继承Gameable&lt;/li&gt;
&lt;li&gt;SingleShootGame，DoubleShootGame，SingleTowerDefenceGame，DoubleTowerDefenceGame是具体产品&lt;/li&gt;
&lt;/ol&gt;&lt;h5 id=&quot;gamefactory-1&quot;&gt;GameFactory&lt;/h5&gt;
&lt;p&gt;抽象工厂，规定了生成单人和双人两种游戏&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * @auther: chenmingyu
 * @date: 2019/2/14 11:29
 * @description: 抽象工厂
 */
public interface GameFactory {

    /**
     * 生产单人游戏
     * @return
     */
    Gameable createSingleGame();

    /**
     * 生产双人游戏
     * @return
     */
    Gameable createDoubleGame();

}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;shootgamefactory-1&quot;&gt;ShootGameFactory&lt;/h5&gt;
&lt;p&gt;具体工厂，负责生产具体的射击类单人游戏和射击类双人游戏&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * @auther: chenmingyu
 * @date: 2019/2/14 18:20
 * @description: 设计游戏制造厂
 */
public class ShootGameFactory implements GameFactory{

    @Override
    public Gameable createSingleGame() {
        return new SingleShootGame();
    }

    @Override
    public Gameable createDoubleGame() {
        return new DoubleShootGame();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;towerdefencegamefactory-1&quot;&gt;TowerDefenceGameFactory&lt;/h5&gt;
&lt;p&gt;具体工厂，负责生产具体的塔防类单人游戏和塔防类双人游戏&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * @auther: chenmingyu
 * @date: 2019/2/14 18:20
 * @description: 塔防游戏制造厂
 */
public class TowerDefenceGameFactory implements GameFactory {

    @Override
    public Gameable createSingleGame() {
        return new SingleTowerDefenceGame();
    }

    @Override
    public Gameable createDoubleGame() {
        return new DoubleTowerDefenceGame();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;gameable-1&quot;&gt;Gameable&lt;/h5&gt;
&lt;p&gt;抽象产品，所有游戏产品均实现该接口&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * @auther: chenmingyu
 * @date: 2019/2/14 11:19
 * @description: 游戏接口
 */
public interface Gameable {

    /**
     * 校验账户信息
     * @param nickName
     */
    void validateAccount(String nickName);


    /**
     * 游戏人数
     */
    void getPlayerNumber();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;shootgame和towerdefencegame&quot;&gt;ShootGame和TowerDefenceGame&lt;/h5&gt;
&lt;p&gt;抽象类，实现Gameable接口&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * @auther: chenmingyu
 * @date: 2019/2/14 11:26
 * @description: 射击类游戏
 */
public abstract class ShootGame implements Gameable{

    @Override
    public void validateAccount(String nickName) {
        System.out.println(&quot;射击游戏校验昵称：&quot;+nickName);
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * @auther: chenmingyu
 * @date: 2019/2/14 11:28
 * @description: 塔防类游戏
 */
public abstract class TowerDefenceGame implements Gameable{

    @Override
    public void validateAccount(String nickName) {
        System.out.println(&quot;塔防游戏校验昵称：&quot;+nickName);
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;具体产品&quot;&gt;具体产品&lt;/h5&gt;
&lt;p&gt;共四款游戏产品：SingleShootGame，DoubleShootGame，SingleTowerDefenceGame，DoubleTowerDefenceGame&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * @auther: chenmingyu
 * @date: 2019/2/15 16:55
 * @description: 单人射击游戏
 */
public class SingleShootGame extends ShootGame {

    @Override
    public void getPlayerNumber() {
        System.out.println(&quot;这是一个单人玩的射击游戏&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * @auther: chenmingyu
 * @date: 2019/2/15 16:57
 * @description: 双人射击游戏
 */
public class DoubleShootGame extends ShootGame{

    @Override
    public void getPlayerNumber() {
        System.out.println(&quot;这是一个双人玩的射击游戏&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * @auther: chenmingyu
 * @date: 2019/2/15 17:17
 * @description: 单人塔防游戏
 */
public class SingleTowerDefenceGame extends TowerDefenceGame{

    @Override
    public void getPlayerNumber() {
        System.out.println(&quot;这是一个单人玩的塔防游戏&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * @auther: chenmingyu
 * @date: 2019/2/15 17:18
 * @description: 双人塔防游戏
 */
public class DoubleTowerDefenceGame extends TowerDefenceGame{
    @Override
    public void getPlayerNumber() {
        System.out.println(&quot;这是一个双人玩的塔防游戏&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;测试-2&quot;&gt;测试&lt;/h5&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void main(String[] args) throws Exception{

    ShootGameFactory shootGameFactory = new ShootGameFactory();
    shootGameFactory.createSingleGame().getPlayerNumber();
    shootGameFactory.createDoubleGame().getPlayerNumber();

    TowerDefenceGameFactory towerDefenceGameFactory = new TowerDefenceGameFactory();
    towerDefenceGameFactory.createSingleGame().getPlayerNumber();
    towerDefenceGameFactory.createDoubleGame().getPlayerNumber();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;这是一个单人玩的射击游戏
这是一个双人玩的射击游戏
这是一个单人玩的塔防游戏
这是一个双人玩的塔防游戏&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 16 Feb 2019 05:49:00 +0000</pubDate>
<dc:creator>叫我明羽</dc:creator>
<og:description>工厂模式属于创建型设计模式，用工厂方法代替new操作，让子类去决定实例化哪个类，工厂方法将一个类的实例化延迟到子类 推荐访问我的个人网站，排版更好看呦： 'https://chenmingyu.top</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cmyxn/p/10387529.html</dc:identifier>
</item>
<item>
<title>Spring Framework中常见的事务传播陷阱（译文） - 北斗玄机</title>
<link>http://www.cnblogs.com/huangzejun/p/10387215.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huangzejun/p/10387215.html</guid>
<description>&lt;p&gt;最近看到Medium上一篇讨论Spring Framework中事务传播的&lt;a href=&quot;https://medium.com/@safa_ertekin/common-transaction-propagation-pitfalls-in-spring-framework-2378ee7d6521&quot; target=&quot;_blank&quot;&gt;文章&lt;/a&gt;，解释了几种常见的问题，解释的不错，这里直接翻译吧（意译为主，粗体和斜体是我自己加上的）。&lt;/p&gt;


&lt;p&gt;这是我的第一篇文章，我打算给大家总结一下开发者在使用&lt;strong&gt;&lt;em&gt;Spring事务&lt;/em&gt;&lt;/strong&gt;时，常常会犯的和&lt;strong&gt;&lt;em&gt;事务传播&lt;/em&gt;&lt;/strong&gt;相关的错误。&lt;/p&gt;
&lt;p&gt;在这之前，我们先回忆一下Spring中事务是怎样传播的。&lt;/p&gt;
&lt;p&gt;我们先看下Ken Tousen做的有关事务传播注解的笔记（译注：这里指@Transactional注解的propagation属性），这会帮助我们更清楚地记忆。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/483183/201902/483183-20190216120654681-1883888879.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;1. 私有方法&lt;/h3&gt;
&lt;p&gt;当公有方法调用私有方法时，不会创建新事务。（译注：这里有点问题，见下面评论）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@Transactional
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MusicPlayerService {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    @Autowired
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    Song song;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    @Autowired
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    MusicCatalogueService musicCatalogueService;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; playSong() {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        scrobble();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        song.play();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     @Transactional(propagation =&lt;span&gt; Propagation.REQUIRES_NEW)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; scrobble() {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        musicCatalogueService.scrobble(song);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p class=&quot;graf graf--p graf-after--p&quot;&gt;上面这个例子里，如果&lt;span&gt;musicCatalogueService.scrobble(song)调用失败了，&lt;span&gt;playSong&lt;/span&gt;()也会失败。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;graf graf--p graf-after--p&quot;&gt;&lt;span&gt;因为&lt;span&gt;&lt;span&gt;playSong()&lt;/span&gt;&lt;/span&gt;和&lt;span&gt;scrobble()&lt;/span&gt;在同一个事务中。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;graf graf--p graf-after--p&quot;&gt;&lt;span&gt;所以要开启新事务，方法必须声明为public。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;graf graf--p graf-after--p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;graf graf--p graf-after--p&quot;&gt;&lt;span&gt;译注：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;graf graf--p graf-after--p&quot;&gt;&lt;span&gt;这里有点问题。即使将scrobble()声明为public，scrobble()也不会开启新事务。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;graf graf--p graf-after--p&quot;&gt;&lt;span&gt;这是因为Spring是使用AOP来进行事务管理的。而scrobble()和playSong()在一个类里，当playSong()调用scrobble()时，是直接调用scrobble()而不是调用代理方法，所以这两个方法都在同一个事务中。而musicCatalogueService.scrobble(song)是另一个对象（&lt;span&gt;musicCatalogueService）&lt;/span&gt;中的方法，这个对象由Spring注入，是可以通过AOP代理的，也就可以通过注解开启新事务（当然前提是，&lt;span&gt;&lt;span&gt;musicCatalogueService&lt;/span&gt;&lt;/span&gt;的方法有注解）。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;graf graf--p graf-after--p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;graf graf--p graf-after--p&quot;&gt;&lt;span&gt;小结：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;graf graf--p graf-after--p&quot;&gt;&lt;span&gt;（1）@Transactional注解对私有方法不起作用，只对公有方法生效。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;graf graf--p graf-after--p&quot;&gt;&lt;span&gt;（2）Spring使用AOP进行事务管理，因此同一个类中的方法互相调用，在不涉及其他类的方法时，如果第一个方法开启了事务，那么接下来所有的方法都处于同一个事务中（不论其他方法是否私有/公有、是否有注解、注解的传播级别是什么）。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;graf graf--p graf-after--p&quot;&gt;&lt;span&gt;（3）只有调用不同类的方法时，才有可能开启新事务。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;graf graf--p graf-after--p&quot;&gt; &lt;/p&gt;
&lt;h3 class=&quot;graf graf--p graf-after--p&quot;&gt;2. 同一个类中的方法调用&lt;/h3&gt;
&lt;p class=&quot;graf graf--p graf-after--p&quot;&gt;如果一个方法调用另一个方法，而这个被调用方法要开启新事务的话，它必须在另一个类中。&lt;/p&gt;
&lt;p class=&quot;graf graf--p graf-after--p&quot;&gt;不然，这两个方法在同一个事务中。&lt;/p&gt;
&lt;p class=&quot;graf graf--p graf-after--p&quot;&gt;把方法放在不同的类中来开启新事务的例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@Transactional
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MusicPlayerService {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    @Autowired
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    Song song;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    @Autowired
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    MusicCatalogueService musicCatalogueService;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; playSong() {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        musicCatalogueService.scrobble(song);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        song.play();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MusicCatalogueService {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    @Autowired
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    ScrobbleRepository scrobbleRepository;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;     @Transactional(propagation =&lt;span&gt; Propagation.REQUIRES_NEW)
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; scrobble(Song song) {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        scrobbleRepository.save(song);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 class=&quot;graf graf--p graf-after--p&quot;&gt;3. &lt;strong class=&quot;markup--strong markup--p-strong&quot;&gt;SUPPORTS和readonly结合&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;如果没有正在进行的事务，那么SUPPORTS不会创建新事务。readonly会被忽视。&lt;/p&gt;

&lt;h3 class=&quot;graf graf--p graf-after--p&quot;&gt;4. CRD操作和readonly结合&lt;/h3&gt;
&lt;p class=&quot;graf graf--p graf-after--p&quot;&gt; 如果我们使用了REQUIRED或者REQUIRES_NEW，以及readonly，然后尝试做CREATE/DELETE/UPDATE操作，那么程序会抛出只读异常。&lt;/p&gt;
&lt;p class=&quot;graf graf--p graf-after--p&quot;&gt; &lt;/p&gt;
&lt;h3 class=&quot;graf graf--p graf-after--p&quot;&gt;&lt;strong class=&quot;markup--strong markup--p-strong&quot;&gt;5. Checked Exceptions&lt;/strong&gt;&lt;/h3&gt;
&lt;p class=&quot;graf graf--p graf-after--p&quot;&gt;如果程序抛出RuntimeException，事务会回滚。这很合理。&lt;/p&gt;
&lt;p class=&quot;graf graf--p graf-after--p&quot;&gt;但是如果程序抛出的是checked exceptions呢？&lt;/p&gt;
&lt;p class=&quot;graf graf--p graf-after--p&quot;&gt;答案是：事务不会回滚。&lt;/p&gt;
&lt;p class=&quot;graf graf--p graf-after--p&quot;&gt;那怎样去处理这种情况？&lt;/p&gt;
&lt;p class=&quot;graf graf--p graf-after--p&quot;&gt;Spring提供了rollbackFor属性。通过指定要回滚的异常类型，可以确保在程序抛出checked exceptions时事务回滚。用法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
@Transactional(rollbackFor = Exception.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; rollBackActionDefinedMethod() {
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;译文完。&lt;/p&gt;


&lt;p class=&quot;graf graf--p graf-after--p&quot;&gt; &lt;/p&gt;
</description>
<pubDate>Sat, 16 Feb 2019 05:41:00 +0000</pubDate>
<dc:creator>北斗玄机</dc:creator>
<og:description>最近看到Medium上一篇讨论Spring Framework中事务传播的文章，解释了几种常见的问题，解释的不错，这里直接翻译吧（意译为主，粗体和斜体是我自己加上的）。 译文： 这是我的第一篇文章，我</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/huangzejun/p/10387215.html</dc:identifier>
</item>
<item>
<title>【最短路径】 SPFA算法 - c1714-gzr</title>
<link>http://www.cnblogs.com/TFLS-gzr/p/10387463.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/TFLS-gzr/p/10387463.html</guid>
<description>&lt;p&gt;　　上一期介绍到了SPFA算法，只是一笔带过，这一期让我们详细的介绍一下SPFA。&lt;/p&gt;
&lt;p&gt;1 SPFA原理介绍&lt;/p&gt;
&lt;p&gt;　　SPFA算法和dijkstra算法特别像，总感觉自己讲的不行，同学说我的博客很辣鸡，推荐一个视频讲解，想看点&lt;a href=&quot;https://www.bilibili.com/video/av11124486/&quot; target=&quot;_blank&quot;&gt;这里&lt;/a&gt;，算法思路如下：&lt;/p&gt;
&lt;p&gt;　　1)和dijkstra一样初始化，定义一个dis[ ]数组，除了源点赋成0之外其它点都赋成正无穷，然后定义一个队列q。&lt;/p&gt;
&lt;p&gt;　　2)把队列q的队首元素取出，标志为不在队中，将其作为中继点对这个队首元素的所有出边进行松弛操作（不知道松弛操作请看&lt;a href=&quot;https://www.cnblogs.com/TFLS-gzr/p/10381849.html&quot; target=&quot;_blank&quot;&gt;这里&lt;/a&gt;），修改完dis值后，判断每一个修改过dis值的元素是否在队列q中，如果不在，就放入队尾；然后判断这个数入队的次数，如果大于n（n为点的个数），那就说明出现了负权回路，算法结束，否则继续。&lt;/p&gt;
&lt;p&gt;　　3)不断循环，直到队列为空。&lt;/p&gt;
&lt;p&gt;2 实现过程中的一些问题&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;　　question：怎么标志出队？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　answer：可以定义一个vis[ ]数组，最开始全部为0，表示都不在队列中，每入队一个元素x，就把vis[x]赋成1，每出队一个元素就赋值成0。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;　　question：怎么判断一个数入队次数？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　answer：可以定义一个num[ ]数组，每入队一个元素x，就num[x]++；这个可以不写，因为题目一般不会出现负权回路。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;　　question：怎么判断队列为空？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　answer：最流行的写法是while(q.empty())，但是不太好理解，我一般会写成while(s.size())，和前一句意思相同。&lt;/p&gt;
&lt;p&gt;3 图解演示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1551435/201902/1551435-20190216132443844-585542813.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　//这个图解做了一上午，可能讲的不好，不喜勿喷&lt;/p&gt;
&lt;p&gt;4 代码奉上：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; SPFA()
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=n;i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     dis[i]=&lt;span&gt;inf;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     queue&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt;q;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     q.push(&lt;span&gt;1&lt;/span&gt;);vis[&lt;span&gt;1&lt;/span&gt;]=&lt;span&gt;1&lt;/span&gt;;dis[&lt;span&gt;1&lt;/span&gt;]=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;&lt;span&gt;(q.size())
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         x=q.front();q.pop();vis[x]=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=head[x];i;i=&lt;span&gt;a[i].next)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; s=&lt;span&gt;a[i].to;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(dis[s]&amp;gt;dis[x]+&lt;span&gt;a[i].cost)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                 dis[s]=dis[x]+&lt;span&gt;a[i].cost;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;(vis[s]==&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                     vis[s]=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;                    q.push(s);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sat, 16 Feb 2019 05:28:00 +0000</pubDate>
<dc:creator>c1714-gzr</dc:creator>
<og:description>上一期介绍到了SPFA算法，只是一笔带过，这一期让我们详细的介绍一下SPFA。 1 SPFA原理介绍 SPFA算法和dijkstra算法特别像，总感觉自己讲的不行，同学说我的博客很辣鸡，推荐一个视频讲</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/TFLS-gzr/p/10387463.html</dc:identifier>
</item>
<item>
<title>干货！分享一款windows下的磁盘分析神器。 - justmine</title>
<link>http://www.cnblogs.com/justmine/p/10386899.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/justmine/p/10386899.html</guid>
<description>&lt;p&gt;作为开发人员的你，肯定遇到过这样的情况，120G SSD系统盘居然满载了，到底是被哪些程序占用了，包含哪些大文件，这个时候脑袋里就开始回忆了。。。。。这对平时没有养成规范化记录安装软件好习惯的同学而言，就只能使用猜测穷举法了，把怀疑的文件夹都检查一遍，如果最终没能找出和清理掉大文件，可能就开始重装系统了。&lt;/p&gt;
&lt;p&gt;但有的同学就比较固执，比如说作者，嘿嘿，我120 G的固态硬盘啊，今天一定要找出真凶，最终，功夫不负有心人，找到了这款神器==》&lt;a href=&quot;https://www.fosshub.com/SpaceSniffer.html&quot;&gt;SpaceSniffer（磁盘空间嗅探器）&lt;/a&gt;：&lt;/p&gt;
&lt;p&gt;浏览器打开下载地址，解压：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1082769/201902/1082769-20190216094522362-1447900173.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以管理员身份运行&lt;/strong&gt;SpaceSniffer.exe：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1082769/201902/1082769-20190216095207028-577015696.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择要分析的磁盘，比如：C盘：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;如果需要分析具体文件夹，请填写Path，如：C:\Program Files。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1082769/201902/1082769-20190216100058342-771843999.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后，等待右上角的扫描进度变为ready，或者整个扫描界面基本不变动的时候，就说明扫描完成了。&lt;/p&gt;
&lt;p&gt;整个界面非常的清楚明了，直接看矩形面积的大小即可，如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;AppData 占用了32.2G&lt;/li&gt;
&lt;li&gt;Documents 占用了8.7G&lt;/li&gt;
&lt;li&gt;dotnet 占用了6.3G&lt;/li&gt;
&lt;li&gt;hiberfil.sys 占用了3.7G&lt;/li&gt;
&lt;li&gt;Roaming 占用了3.7G&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;进一步分析点击，AppData矩形（其他的同理）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1082769/201902/1082769-20190216101400419-538691512.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到这一步，就可以看到各个程序的占用情况，以及包含哪些大文件，自行选择清理即可，希望能帮到大家，如果你觉得本篇文章对您有帮助的话，感谢您的【&lt;strong&gt;推荐&lt;/strong&gt;】，也可以&lt;strong&gt;【关注我】&lt;/strong&gt;，我会定期的在博客分享我的学习心得。&lt;/p&gt;
&lt;p&gt;至此，目的达到，可以收工了，哈哈。&lt;/p&gt;
&lt;h2 id=&quot;最后&quot;&gt;最后&lt;/h2&gt;
&lt;p&gt;如果有什么疑问和见解，欢迎评论区交流。&lt;br/&gt;&lt;strong&gt;欢迎转载，请在明显位置给出出处及链接&lt;/strong&gt;。&lt;/p&gt;
</description>
<pubDate>Sat, 16 Feb 2019 05:23:00 +0000</pubDate>
<dc:creator>justmine</dc:creator>
<og:description>作为开发人员的你，肯定遇到过这样的情况，120G SSD系统盘居然满载了，到底是被哪些程序占用了，包含哪些大文件，这个时候脑袋里就开始回忆了。。。。。这对平时没有养成规范化记录安装软件好习惯的同学而言</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/justmine/p/10386899.html</dc:identifier>
</item>
<item>
<title>C# 10分钟完成百度人脸识别——入门篇 - 学习中的苦与乐</title>
<link>http://www.cnblogs.com/xiongze520/p/10387355.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiongze520/p/10387355.html</guid>
<description>&lt;p&gt;嗨咯，小编在此祝大家新年快乐财多多！&lt;/p&gt;
&lt;p&gt;今天我们来盘一盘人脸注册、人脸识别等相关操作，这是一个简单入门教程。&lt;/p&gt;
&lt;p&gt;话不多说，我们进入主题：&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;完成人脸识别所需的步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;注册百度账号api，创建自己的应用；&lt;/li&gt;
&lt;li&gt;创建vs控制台应用程序，引入动态链接库；&lt;/li&gt;
&lt;li&gt;编写代码调试，效果图查看；&lt;/li&gt;
&lt;li&gt;总结。&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、注册百度账号api，创建自己的应用&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;注册地址： https://login.bce.baidu.com/&lt;/p&gt;
&lt;p&gt;注册登录之后，在“产品服务” 菜单下找到人脸识别 ，如下图：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1093832/201902/1093832-20190216112313635-1222090550.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;点击去创建自己的应用名称，其实最主要的就是 API_key  和 Secret_key&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1093832/201902/1093832-20190216112516627-32047259.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;有了这些就可以进一步去看 百度提供的SDK 文档了。&lt;/p&gt;
&lt;p&gt;这是百度的SDK地址：http://ai.baidu.com/sdk&lt;/p&gt;
&lt;p&gt;选择自己喜欢的开发语言进行研究， 里面文档很详细， 下载中有Demo &lt;/p&gt;
&lt;p&gt;本人采用的是C# 进行研究。&lt;/p&gt;
&lt;p&gt;参考地址：http://ai.baidu.com/docs#/Face-Csharp-SDK/top&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、创建vs控制台应用程序，引入动态链接库&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;创建控制台应用程序，命名为FaceRecognition，&lt;/p&gt;
&lt;p&gt;然后引用动态链接库（安装人脸SDK），我用的是vs2017，使用的是方法一。&lt;/p&gt;
&lt;h3&gt;方法一：使用Nuget管理依赖 （推荐）&lt;/h3&gt;
&lt;p&gt;在NuGet中搜索 &lt;code&gt;Baidu.AI&lt;/code&gt;，安装最新版即可。&lt;/p&gt;
&lt;p&gt;packet地址 https://www.nuget.org/packages/Baidu.AI/&lt;/p&gt;
&lt;h3&gt;方法二：下载安装&lt;/h3&gt;
&lt;p&gt;人脸 C# SDK目录结构&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Baidu.Aip
    ├── net35
    │   ├── AipSdk.dll             // 百度AI服务 windows 动态库
    │   ├── AipSdk.xml             // 注释文件
    │   └── Newtonsoft.Json.dll    // 第三方依赖
    ├── net40
    ├── net45
    └── netstandard2.0
        ├── AipSdk.deps.json
        └── AipSdk.dll
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;如果需要在 Unity 平台使用，可引用工程源码自行编译。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;安装&lt;/p&gt;
&lt;p&gt;1.在&lt;a href=&quot;http://ai.baidu.com/sdk&quot; target=&quot;_blank&quot;&gt;官方网站&lt;/a&gt;下载C# SDK压缩工具包。&lt;/p&gt;
&lt;p&gt;2.解压后，将 &lt;code&gt;AipSdk.dll&lt;/code&gt; 和 &lt;code&gt;Newtonsoft.Json.dll&lt;/code&gt; 中添加为引用。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3、编写代码调试，效果图查看&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;注册人脸&lt;/li&gt;
&lt;li&gt;识别人脸&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;首先我们准备一张能够识别人脸的图片，放到公共平台，如果百度云盘，然后分享出去，复制图片地址。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注册人脸：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在Program.cs里面编写代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; FaceRecognition
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置APPID/AK/SK&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; API_KEY = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;XFPA49myCG7S37XP1DxjLbXF&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;;                   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;你的 Api Key&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; SECRET_KEY = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ZvZKigrixMLXNZOLmkrG6iDx9QprlGuT&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;你的 Secret Key&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; client = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Baidu.Aip.Face.Face(API_KEY, SECRET_KEY);
            client.Timeout &lt;/span&gt;= &lt;span&gt;60000&lt;/span&gt;;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 修改超时时间


            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取决于image_type参数，传入BASE64字符串或URL字符串或FACE_TOKEN字符串
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;你共享的图片路径（点击路径可直接查看图片）&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; image = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://thumbnail0.baidupcs.com/thumbnail/32f3cc8f022839a4dbf6b9f9cca76ce8?fid=3145591938-250528-218900036170682&amp;amp;time=1550282400&amp;amp;rt=sh&amp;amp;sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-sTBqvQbbBy3n5SDQfbtjNwjlSHg%3D&amp;amp;expires=8h&amp;amp;chkv=0&amp;amp;chkbd=0&amp;amp;chkpc=&amp;amp;dp-logid=1077356968076791248&amp;amp;dp-callid=0&amp;amp;size=c710_u400&amp;amp;quality=100&amp;amp;vuk=-&amp;amp;ft=video&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; imageType = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;URL&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;


            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注册人脸&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; groupId = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;group1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; userId = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用人脸注册，可能会抛出网络等异常，请使用try/catch捕获&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; result =&lt;span&gt; client.UserAdd(image, imageType, groupId, userId);
            Console.WriteLine(result);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果有可选参数&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; options = &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt;{
                        {&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user_info&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user's info&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;},
                        {&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;quality_control&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;NORMAL&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;},
                        {&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;liveness_control&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LOW&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}
                    };
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 带参数调用人脸注册&lt;/span&gt;
            result =&lt;span&gt; client.UserAdd(image, imageType, groupId, userId, options);
            Console.WriteLine(result);&lt;/span&gt;&lt;span&gt;
        }

         
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行后，控制台打印成功与否，百度api控制台查看是否注册成功。&lt;/p&gt;
&lt;p&gt;控制台效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1093832/201902/1093832-20190216122220511-1412655628.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;百度api控制台查看效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1093832/201902/1093832-20190216122401843-669335646.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 很显然，我们注册人脸成功，接下来我们进行人脸识别，我们使用注册过的图片和未注册过的图片进行验证。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;识别人脸：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;同样在Program.cs里面编写代码，我们把之前的代码注释掉就行，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; FaceRecognition
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置APPID/AK/SK&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; API_KEY = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;XFPA49myCG7S37XP1DxjLbXF&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;;                   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;你的 Api Key&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; SECRET_KEY = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ZvZKigrixMLXNZOLmkrG6iDx9QprlGuT&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;你的 Secret Key&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; client = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Baidu.Aip.Face.Face(API_KEY, SECRET_KEY);
            client.Timeout &lt;/span&gt;= &lt;span&gt;60000&lt;/span&gt;;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 修改超时时间


            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取决于image_type参数，传入BASE64字符串或URL字符串或FACE_TOKEN字符串
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;你共享的图片路径（点击路径可直接查看图片）&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; image = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://thumbnail0.baidupcs.com/thumbnail/32f3cc8f022839a4dbf6b9f9cca76ce8?fid=3145591938-250528-218900036170682&amp;amp;time=1550282400&amp;amp;rt=sh&amp;amp;sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-sTBqvQbbBy3n5SDQfbtjNwjlSHg%3D&amp;amp;expires=8h&amp;amp;chkv=0&amp;amp;chkbd=0&amp;amp;chkpc=&amp;amp;dp-logid=1077356968076791248&amp;amp;dp-callid=0&amp;amp;size=c710_u400&amp;amp;quality=100&amp;amp;vuk=-&amp;amp;ft=video&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; imageType = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;URL&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;



            &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;/注册人脸&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;var groupId = &quot;group1&quot;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;var userId = &quot;user1&quot;;&lt;/span&gt;
            &lt;span&gt;///&lt;/span&gt;&lt;span&gt;/ 调用人脸注册，可能会抛出网络等异常，请使用try/catch捕获&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;var result = client.UserAdd(image, imageType, groupId, userId);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Console.WriteLine(result);&lt;/span&gt;
            &lt;span&gt;///&lt;/span&gt;&lt;span&gt;/ 如果有可选参数&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;var options = new Dictionary&amp;lt;string, object&amp;gt;{
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            {&quot;user_info&quot;, &quot;user's info&quot;},
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            {&quot;quality_control&quot;, &quot;NORMAL&quot;},
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            {&quot;liveness_control&quot;, &quot;LOW&quot;}
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        };&lt;/span&gt;
            &lt;span&gt;///&lt;/span&gt;&lt;span&gt;/ 带参数调用人脸注册&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;result = client.UserAdd(image, imageType, groupId, userId, options);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Console.WriteLine(result);



            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;人脸识别（在注册的人脸库里面进行识别）
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用人脸检测，可能会抛出网络等异常，请使用try / catch捕获&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; result =&lt;span&gt; client.Detect(image, imageType);
            Console.WriteLine(result);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果有可选参数&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; options = &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt;{
                        {&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;face_field&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;},
                        {&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;max_face_num&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;},
                        {&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;face_type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LIVE&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}
                    };
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 带参数调用人脸检测&lt;/span&gt;
            result =&lt;span&gt; client.Detect(image, imageType, options);
            Console.WriteLine(result);

        }

         
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;控制台效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1093832/201902/1093832-20190216122814513-1287265496.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;很显然我们也人脸识别成功了。&lt;/p&gt;

&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4、总结&lt;/strong&gt;&lt;/span&gt; &lt;/p&gt;
&lt;p&gt; 我们只是使用控制台做了一个简单的注册和识别，删除和更新也是一样的，可以直接去官网拷贝即可，路径为：&lt;a href=&quot;http://ai.baidu.com/docs#/Face-Csharp-SDK/3b8dc2e8&quot; target=&quot;_blank&quot;&gt;http://ai.baidu.com/docs#/Face-Csharp-SDK/3b8dc2e8&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; 有了这个简单的demo后，我们可以结合摄像头进行注册、识别、更新等操作。&lt;/p&gt;
&lt;p&gt;关注小编不迷路，下一次我们讲调用摄像头完成注册、识别、更新、删除等操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1093832/201902/1093832-20190216123350767-2072039006.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 16 Feb 2019 04:39:00 +0000</pubDate>
<dc:creator>学习中的苦与乐</dc:creator>
<og:description>嗨咯，小编在此祝大家新年快乐财多多！ 今天我们来盘一盘人脸注册、人脸识别等相关操作，这是一个简单入门教程。 话不多说，我们进入主题： 完成人脸识别所需的步骤： 1、注册百度账号api，创建自己的应用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiongze520/p/10387355.html</dc:identifier>
</item>
<item>
<title>Mysql学习笔记整理手册 - javahih</title>
<link>http://www.cnblogs.com/mzq123/p/10387170.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mzq123/p/10387170.html</guid>
<description>&lt;p&gt;继上一篇博客&lt;a href=&quot;https://blog.csdn.net/u014427391/article/details/82317376&quot;&gt;《Oracle学习笔记整理手册》&lt;/a&gt;之后，我再写一篇Mysql版本的&lt;/p&gt;
&lt;p&gt;PS：本博客收录自己工作中遇到学到的一些mysql技能，有时间就更新整理一下&lt;/p&gt;
&lt;h3 id=&quot;str_to_date&quot;&gt;(1) str_to_date&lt;/h3&gt;
&lt;p&gt;oracle有to_date函数，Mysql的格式是str_to_date(‘2019-02-12 11:34:32’, ‘%Y-%m-%d %H:%i:%s’)&lt;/p&gt;
&lt;h3 id=&quot;递归查询&quot;&gt;(2) 递归查询&lt;/h3&gt;
&lt;p&gt;oracle实现递归查询的话，就可以使用start with … connect by，mysql并没有通过类似函数，解决方法是通过自定义函数的方法，具体可以参考我这篇博客&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/u014427391/article/details/87297884&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/u014427391/article/details/87297884&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;排序问题&quot;&gt;(3) 排序问题&lt;/h3&gt;
&lt;p&gt;oracle做数据排序的时候，有时候可以用nulls first或者nulls last将null值排在最前或者最后。&lt;br/&gt;不过迁到Mysql的话，mysql并没有提供类似函数，所以要怎么实现？下面给出解决方法：&lt;br/&gt;null值排在最后，用Mysql的IF和ISNULL函数。如果为空返回1，否返回0&lt;/p&gt;
&lt;p&gt;select * from A order by IF(ISNULL(a),1,0),a desc&lt;br/&gt;1&lt;br/&gt;null值排在最前，用Mysql的IF和ISNULL函数。如果为空返回0，否返回1&lt;/p&gt;
&lt;p&gt;select * from A order by IF(ISNULL(a),0,1),a desc&lt;br/&gt;1&lt;br/&gt;具体可以参考我写的这篇博客：&lt;a href=&quot;https://blog.csdn.net/u014427391/article/details/87297068&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/u014427391/article/details/87297068&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;条件函数&quot;&gt;(4) 条件函数&lt;/h3&gt;
&lt;p&gt;条件函数比如case..when在mysql、Oracle都是有的，除了case...when这最基本之外，Oracle有nvl、nvl2和decode函数，Mysql没有提供类似decode的函数，不过有类似Oracle的nvl和nvl2函数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Oracle&lt;/strong&gt;&lt;br/&gt;介绍一下oracle的nvl函数和nvl2函数。&lt;/p&gt;
&lt;p&gt;nvl函数&lt;br/&gt;nvl函数基本语法为nvl(E1,E2)，意思是E1为null就返回E2，不为null就返回E1。&lt;/p&gt;
&lt;p&gt;nvl2函数&lt;br/&gt;nvl2函数的是nvl函数的拓展，基本语法为nvl2(E1,E2,E3)，意思是E1为null，就返回E3，不为null就返回E2。&lt;br/&gt;nvl函数具体可以参考我这篇博客：&lt;a href=&quot;https://blog.csdn.net/u014427391/article/details/84996009&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/u014427391/article/details/84996009&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Mysql&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上面是Oracle的做法，mysql的做法可以用IFNULL(E1,E2)函数，其功能类似与Oracle的nvl函数。意思是E1为null就返回E2，不为null就返回E1。&lt;/p&gt;
&lt;p&gt;Mysql IF函数，这里可以和Oracle的nvl2函数做对比，不过差别比较大了，nvl2函数是针对数值为空的情况，IF函数是针对自定义条件的&lt;/p&gt;
&lt;p&gt;格式：IF(Condition,A,B)&lt;br/&gt;意义：当Condition为TRUE时，返回A；当Condition为FALSE时，返回B。&lt;/p&gt;
&lt;h3 id=&quot;列转行函数&quot;&gt;(5) 列转行函数&lt;/h3&gt;
&lt;p&gt;Oracle列转行函数可以用vm_comcat函数，mysql的用concat_ws函数&lt;br/&gt;使用方法：&lt;br/&gt;CONCAT_WS(separator,str1,str2,...)&lt;br/&gt;eg:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select concat_ws(',','11','22','33');&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Oracle列转行函数的可以参考我以前博客：&lt;a href=&quot;https://blog.csdn.net/u014427391/article/details/84981114&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/u014427391/article/details/84981114&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;列转行函数不兼容问题:&lt;a href=&quot;https://blog.csdn.net/u014427391/article/details/84867390&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/u014427391/article/details/84867390&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;find_int_set&quot;&gt;(6) find_int_set&lt;/h3&gt;
&lt;p&gt;Mysql有提供一个find_int_set函数，其语法为FIND_IN_SET(str,strlist)&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;str: 要查询的字符串&lt;/li&gt;
&lt;li&gt;strlist: 序列，用逗号分隔，比如(1,2,3)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这个函数只要用于查询的时候，查询字符串是否在strlist序列里，like查询只是广泛的模糊匹配&lt;/p&gt;
&lt;h3 id=&quot;类型转换函数&quot;&gt;(7) 类型转换函数&lt;/h3&gt;
&lt;p&gt;mysql的类型转换函数为cast(字段 as 类型)，&lt;br/&gt;mysql支持的类型有&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;CHAR[(N)] 字符型&lt;/li&gt;
&lt;li&gt;DATE 日期型&lt;/li&gt;
&lt;li&gt;DATETIME 日期和时间型&lt;/li&gt;
&lt;li&gt;DECIMAL float型&lt;/li&gt;
&lt;li&gt;SIGNED int&lt;/li&gt;
&lt;li&gt;TIME 时间型&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;合并更新&quot;&gt;(8) 合并更新&lt;/h3&gt;
&lt;p&gt;Oracle实现merge into实现，意思是数据表已经有数据就更新，没数据就新增&lt;br/&gt;mysql的函数是replace into，语法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
    replace into 表格(字段,...) values(数据,...)
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 16 Feb 2019 03:34:00 +0000</pubDate>
<dc:creator>javahih</dc:creator>
<og:description>[TOC] 继上一篇博客 '《Oracle学习笔记整理手册》' 之后，我再写一篇Mysql版本的 PS：本博客收录自己工作中遇到学到的一些mysql技能，有时间就更新整理一下 (1) str_to_d</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mzq123/p/10387170.html</dc:identifier>
</item>
</channel>
</rss>