<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>线性代数精华——从正交向量到正交矩阵 - TechFlow2019</title>
<link>http://www.cnblogs.com/techflow/p/12220591.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/techflow/p/12220591.html</guid>
<description>&lt;h3 id=&quot;向量内积&quot;&gt;向量内积&lt;/h3&gt;

&lt;p&gt;这个基本上是中学当中数学课本上的概念，两个向量的&lt;strong&gt;内积&lt;/strong&gt;非常简单，我们直接看公式回顾一下：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[X \cdot Y = \sum_{i=1}^n x_i*y_i\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这里X和Y都是n维的向量，两个向量能够计算内积的前提是两个向量的维度一样。从上面公式可以看出来，两个向量的内积就等于两个向量对应各个维度的分量的乘积的和。&lt;/p&gt;
&lt;p&gt;为了和矩阵乘法以及普通的乘法做区分，我们通常把两个向量的内积写成：&lt;span class=&quot;math inline&quot;&gt;\([x, y]=x^Ty\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;这里有一个很重要的性质，对于一个向量而言，我们可以用欧几里得公式计算它的长度。进一步，我们可以用向量的长度以及向量之间的夹角来表示向量的内积，如下：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[[x, y]=|x|\cdot |y|\cos\theta\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中的&lt;span class=&quot;math inline&quot;&gt;\(\theta\)&lt;/span&gt;是x和y向量之间的夹角，对于三维及以下空间内的向量，这一点非常直观。对于高维度的向量，我们很难想象它的物理意义。不过没有关系，我们一样可以认为向量之间存在一个&lt;strong&gt;广义超空间&lt;/strong&gt;内的一个夹角。在机器学习领域，我们通常用这个夹角来反应&lt;strong&gt;向量之间的相似度&lt;/strong&gt;。两个向量越相似，那么它们之间的夹角应该越小，对应的cos余弦值应该越大。所以我们可以用两个向量之间的余弦值来反应它们之间的相似度。余弦值的计算就源于此。&lt;/p&gt;

&lt;h3 id=&quot;正交向量&quot;&gt;正交向量&lt;/h3&gt;

&lt;p&gt;从上面的公式可以看出来，向量的内积等于两个向量长度乘上向量之间的夹角。对于非零向量而言，它们的长度都应该是大于0的。所以两个向量的内积的大小，就完全取决于向量之间的夹角&lt;span class=&quot;math inline&quot;&gt;\(\theta\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;如果&lt;span class=&quot;math inline&quot;&gt;\(\theta\)&lt;/span&gt;小于90°，那么&lt;span class=&quot;math inline&quot;&gt;\(\cos\theta&amp;gt;0\)&lt;/span&gt;，那么内积为正值。如果&lt;span class=&quot;math inline&quot;&gt;\(\theta\)&lt;/span&gt;大于90°，那么余弦值为负值。所以我们可以通过余弦值正负判断夹角是锐角还是钝角。既然说到夹角，自然就离不开一种特殊情况——&lt;strong&gt;垂直&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果是在二维平面当中，两个向量夹角是90°，那么显然这两个向量垂直。在高维空间当中也是一样，不过我们一般不说垂直，而是会换一个词——&lt;strong&gt;正交&lt;/strong&gt;。两个非零向量的内积为0，说明两个向量正交。&lt;/p&gt;

&lt;h3 id=&quot;正交向量组&quot;&gt;正交向量组&lt;/h3&gt;

&lt;p&gt;搞清楚了正交向量之后，正交向量组也就明确了。正交向量组是指一组&lt;strong&gt;两两正交且非零的向量组&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果n维的向量组:&lt;span class=&quot;math inline&quot;&gt;\(a_1, a_2, \cdots,a_r\)&lt;/span&gt;两两正交，那么，它们一定线性无关。也就是说不存在一组不为零的系数&lt;span class=&quot;math inline&quot;&gt;\(\lambda\)&lt;/span&gt;，使得：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\lambda_1a_1+\lambda_2a_2+\cdots + \lambda_ra_r=0\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这点很容易证明，由于向量组内向量均不为0，我们只需要在等式两边随便乘上一个向量即可，假设我们乘的是&lt;span class=&quot;math inline&quot;&gt;\(a_1\)&lt;/span&gt;。由于它与其他向量两两正交，所以其他项全为0。如果要等式成立，那么必须要：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\lambda_1a_1^Ta_1=0\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;由于&lt;span class=&quot;math inline&quot;&gt;\(a_1\)&lt;/span&gt;不为0，那么&lt;span class=&quot;math inline&quot;&gt;\(a_1^Ta_1\)&lt;/span&gt;必然不为0，要使得等式成立，只能是&lt;span class=&quot;math inline&quot;&gt;\(\lambda_1\)&lt;/span&gt;为0。&lt;/p&gt;

&lt;h3 id=&quot;规范正交基&quot;&gt;规范正交基&lt;/h3&gt;

&lt;p&gt;我们把正交向量组的概念和基的概念融合，如果向量组&lt;span class=&quot;math inline&quot;&gt;\(e_1, e_2, \cdots, e_r\)&lt;/span&gt;是向量空间V的一个基。如果它们之间&lt;strong&gt;彼此正交&lt;/strong&gt;，那么就称它们是一组规范正交基。&lt;/p&gt;
&lt;p&gt;对于向量a，我们可以很方便地求出它在规范正交基下各个维度的坐标：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\lambda_i = e_i^Ta=[a, e_i]\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;也就是说向量a，在规范正交基下某一个维度的坐标， 等于&lt;strong&gt;它和这个维度的正交基向量的内积&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果说我们已经知道向量空间V中的一组基是&lt;span class=&quot;math inline&quot;&gt;\(a_1, a_2, \cdots, a_r\)&lt;/span&gt;，我们怎么求V的规范正交基呢？&lt;/p&gt;
&lt;p&gt;这里要用到一个算法，叫做&lt;strong&gt;施密特算法&lt;/strong&gt;。通过这个算法，我们可以通过向量空间的一组基来求出它的正交基。&lt;/p&gt;
&lt;p&gt;这个算法很简单，我们可以直接写出它的公式：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{aligned} b_1 &amp;amp;= a_1 \\ b_2 &amp;amp;= a_2 - \frac{[b_1, a_2]}{[b_1, b_1]}b_1\\ \cdots\\ b_r &amp;amp;= a_r - \frac{[b_1, a_r]}{[b_1, b_1]}b_1-\frac{[b_2, a_r]}{[b_2, b_2]}b_2 - \cdots - \frac{[b_{r-1}, a_r]}{[b_{r-1}, b_{r-1}]}b_{r-1} \end{aligned} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们随便取两个b向量乘一下就知道，b向量组之中两两正交。所以，我们只要将b向量组单位化一下，就可以求出对应的规范正交基了。&lt;/p&gt;
&lt;p&gt;即：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ e_1=\frac{1}{||b_1||}b_1, \quad e_2=\frac{1}{||b_2||}b_2 \quad \cdots \quad e_r=\frac{1}{||b_r||}b_r \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这个算法虽然不难，但蛮重要。在机器学习领域中一些&lt;strong&gt;降维算法&lt;/strong&gt;，很多都与施密特正交化方法有关。&lt;/p&gt;

&lt;h3 id=&quot;正交矩阵&quot;&gt;正交矩阵&lt;/h3&gt;

&lt;p&gt;之前我们在介绍矩阵的时候，曾经说过，我们可以把一个矩阵看成是一个特定的向量组的结构。同样，我们也可以把一个规范正交基向量组看成是一个矩阵，那么这个矩阵就称为是&lt;strong&gt;正交矩阵&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;它拥有如下性质：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[A^TA=I\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中I是单位矩阵，它的充要条件是矩阵A当中的每一列都是一个单位列向量，并且两两正交。&lt;/p&gt;
&lt;p&gt;最后，我们看一下正交矩阵的性质。它的主要性质有三个：&lt;/p&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如果A是正交矩阵，那么&lt;span class=&quot;math inline&quot;&gt;\(A^{-1}=A^T\)&lt;/span&gt;，也是正交矩阵，并且&lt;span class=&quot;math inline&quot;&gt;\(|A|=\pm 1\)&lt;/span&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如果A和B都是正交矩阵，并且它们阶数一样，那么AB也是正交矩阵。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如果A是正交矩阵，向量y经过A变换之后行列式保持不变。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这三个性质都很简单，我们通过正交矩阵的性质基本上都可以直接推导得到，或者是非常直观，和我们的直觉吻合。其实怎么推导不是重点，对于算法工程师而言，更重要的是理解这些概念的意思，并且将它与算法模型当中起到的功能联系起来，这才是最重要的事情。&lt;/p&gt;
&lt;p&gt;今天关于正交向量和矩阵的内容就到这里，如果觉得有所收获，请顺手点个&lt;strong&gt;关注&lt;/strong&gt;或者转发吧，你们的支持是我最大的动力。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/1/21/16fc57ba6dedca4b?w=258&amp;amp;h=258&amp;amp;f=png&amp;amp;s=23988&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 21 Jan 2020 00:29:00 +0000</pubDate>
<dc:creator>TechFlow2019</dc:creator>
<og:description>向量内积 这个基本上是中学当中数学课本上的概念，两个向量的 内积 非常简单，我们直接看公式回顾一下： $$X \cdot Y = \sum_{i=1}^n x_i y_i$$ 这里X和Y都是n维的向量</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/techflow/p/12220591.html</dc:identifier>
</item>
<item>
<title>Go 每日一库之 fsnotify - darjun</title>
<link>http://www.cnblogs.com/darjun/p/12220546.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/darjun/p/12220546.html</guid>
<description>&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;上一篇文章&lt;a href=&quot;http://localhost:1313/2020/01/18/godailylib/viper/&quot;&gt;Go 每日一库之 viper&lt;/a&gt;中，我们介绍了 viper 可以监听文件修改进而自动重新加载。&lt;br/&gt;其内部使用的就是&lt;code&gt;fsnotify&lt;/code&gt;这个库，它是跨平台的。今天我们就来介绍一下它。&lt;/p&gt;
&lt;h2 id=&quot;快速使用&quot;&gt;快速使用&lt;/h2&gt;
&lt;p&gt;先安装：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ go get github.com/fsnotify/fsnotify&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;后使用：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;package main

import (
  &quot;log&quot;

  &quot;github.com/fsnotify/fsnotify&quot;
)

func main() {
  watcher, err := fsnotify.NewWatcher()
  if err != nil {
    log.Fatal(&quot;NewWatcher failed: &quot;, err)
  }
  defer watcher.Close()

  done := make(chan bool)
  go func() {
    defer close(done)

    for {
      select {
      case event, ok := &amp;lt;-watcher.Events:
        if !ok {
          return
        }
        log.Printf(&quot;%s %s\n&quot;, event.Name, event.Op)
      case err, ok := &amp;lt;-watcher.Errors:
        if !ok {
          return
        }
        log.Println(&quot;error:&quot;, err)
      }
    }
  }()

  err = watcher.Add(&quot;./&quot;)
  if err != nil {
    log.Fatal(&quot;Add failed:&quot;, err)
  }
  &amp;lt;-done
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;fsnotify&lt;/code&gt;的使用比较简单：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;先调用&lt;code&gt;NewWatcher&lt;/code&gt;创建一个监听器；&lt;/li&gt;
&lt;li&gt;然后调用监听器的&lt;code&gt;Add&lt;/code&gt;增加监听的文件或目录；&lt;/li&gt;
&lt;li&gt;如果目录或文件有事件产生，监听器中的通道&lt;code&gt;Events&lt;/code&gt;可以取出事件。如果出现错误，监听器中的通道&lt;code&gt;Errors&lt;/code&gt;可以取出错误信息。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上面示例中，我们在另一个 goroutine 中循环读取发生的事件及错误，然后输出它们。&lt;/p&gt;
&lt;p&gt;编译、运行程序。在当前目录创建一个&lt;code&gt;新建文本文档.txt&lt;/code&gt;，然后重命名为&lt;code&gt;file1.txt&lt;/code&gt;文件，输入内容&lt;code&gt;some test text&lt;/code&gt;，然后删除它。观察控制台输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;2020/01/20 08:41:17 新建文本文档.txt CREATE
2020/01/20 08:41:25 新建文本文档.txt RENAME
2020/01/20 08:41:25 file1.txt CREATE
2020/01/20 08:42:28 file1.txt REMOVE&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;其实，重命名时会产生两个事件，一个是原文件的&lt;code&gt;RENAME&lt;/code&gt;事件，一个是新文件的&lt;code&gt;CREATE&lt;/code&gt;事件。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;注意，&lt;code&gt;fsnotify&lt;/code&gt;使用了操作系统接口，监听器中保存了系统资源的句柄，所以使用后需要关闭。&lt;/p&gt;
&lt;h2 id=&quot;事件&quot;&gt;事件&lt;/h2&gt;
&lt;p&gt;上面示例中的事件是&lt;code&gt;fsnotify.Event&lt;/code&gt;类型：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;// fsnotify/fsnotify.go
type Event struct {
  Name string
  Op   Op
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;事件只有两个字段，&lt;code&gt;Name&lt;/code&gt;表示发生变化的文件或目录名，&lt;code&gt;Op&lt;/code&gt;表示具体的变化。&lt;code&gt;Op&lt;/code&gt;有 5 中取值：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;// fsnotify/fsnotify.go
type Op uint32

const (
  Create Op = 1 &amp;lt;&amp;lt; iota
  Write
  Remove
  Rename
  Chmod
)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在&lt;a href=&quot;https://www.cnblogs.com/darjun/p/12220546.html#快速使用&quot;&gt;快速使用&lt;/a&gt;中，我们已经演示了前 4 种事件。&lt;code&gt;Chmod&lt;/code&gt;事件在文件或目录的属性发生变化时触发，在 Linux 系统中可以通过&lt;code&gt;chmod&lt;/code&gt;命令改变文件或目录属性。&lt;/p&gt;
&lt;p&gt;事件中的&lt;code&gt;Op&lt;/code&gt;是按照位来存储的，可以存储多个，可以通过&lt;code&gt;&amp;amp;&lt;/code&gt;操作判断对应事件是不是发生了。&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;if event.Op &amp;amp; fsnotify.Write != 0 {
  fmt.Println(&quot;Op has Write&quot;)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们在代码中不需要这样判断，因为&lt;code&gt;Op&lt;/code&gt;的&lt;code&gt;String()&lt;/code&gt;方法已经帮我们处理了这种情况了：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;// fsnotify.go
func (op Op) String() string {
  // Use a buffer for efficient string concatenation
  var buffer bytes.Buffer

  if op&amp;amp;Create == Create {
    buffer.WriteString(&quot;|CREATE&quot;)
  }
  if op&amp;amp;Remove == Remove {
    buffer.WriteString(&quot;|REMOVE&quot;)
  }
  if op&amp;amp;Write == Write {
    buffer.WriteString(&quot;|WRITE&quot;)
  }
  if op&amp;amp;Rename == Rename {
    buffer.WriteString(&quot;|RENAME&quot;)
  }
  if op&amp;amp;Chmod == Chmod {
    buffer.WriteString(&quot;|CHMOD&quot;)
  }
  if buffer.Len() == 0 {
    return &quot;&quot;
  }
  return buffer.String()[1:] // Strip leading pipe
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;应用&quot;&gt;应用&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;fsnotify&lt;/code&gt;的应用非常广泛，在 godoc 上，我们可以看到哪些库导入了&lt;code&gt;fsnotify&lt;/code&gt;。只需要在&lt;code&gt;fsnotify&lt;/code&gt;文档的 URL 后加上&lt;code&gt;?imports&lt;/code&gt;即可：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://godoc.org/github.com/fsnotify/fsnotify?importers&quot; class=&quot;uri&quot;&gt;https://godoc.org/github.com/fsnotify/fsnotify?importers&lt;/a&gt;。有兴趣打开看看，要 fq。&lt;/p&gt;
&lt;p&gt;上一篇文章中，我们介绍了调用&lt;code&gt;viper.WatchConfig&lt;/code&gt;就可以监听配置修改，自动重新加载。下面我们就来看看&lt;code&gt;WatchConfig&lt;/code&gt;是怎么实现的：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;// viper/viper.go
func WatchConfig() { v.WatchConfig() }

func (v *Viper) WatchConfig() {
  initWG := sync.WaitGroup{}
  initWG.Add(1)
  go func() {
    watcher, err := fsnotify.NewWatcher()
    if err != nil {
      log.Fatal(err)
    }
    defer watcher.Close()
    // we have to watch the entire directory to pick up renames/atomic saves in a cross-platform way
    filename, err := v.getConfigFile()
    if err != nil {
      log.Printf(&quot;error: %v\n&quot;, err)
      initWG.Done()
      return
    }

    configFile := filepath.Clean(filename)
    configDir, _ := filepath.Split(configFile)
    realConfigFile, _ := filepath.EvalSymlinks(filename)

    eventsWG := sync.WaitGroup{}
    eventsWG.Add(1)
    go func() {
      for {
        select {
        case event, ok := &amp;lt;-watcher.Events:
          if !ok { // 'Events' channel is closed
            eventsWG.Done()
            return
          }
          currentConfigFile, _ := filepath.EvalSymlinks(filename)
          // we only care about the config file with the following cases:
          // 1 - if the config file was modified or created
          // 2 - if the real path to the config file changed (eg: k8s ConfigMap replacement)
          const writeOrCreateMask = fsnotify.Write | fsnotify.Create
          if (filepath.Clean(event.Name) == configFile &amp;amp;&amp;amp;
            event.Op&amp;amp;writeOrCreateMask != 0) ||
            (currentConfigFile != &quot;&quot; &amp;amp;&amp;amp; currentConfigFile != realConfigFile) {
            realConfigFile = currentConfigFile
            err := v.ReadInConfig()
            if err != nil {
              log.Printf(&quot;error reading config file: %v\n&quot;, err)
            }
            if v.onConfigChange != nil {
              v.onConfigChange(event)
            }
          } else if filepath.Clean(event.Name) == configFile &amp;amp;&amp;amp;
            event.Op&amp;amp;fsnotify.Remove&amp;amp;fsnotify.Remove != 0 {
            eventsWG.Done()
            return
          }

        case err, ok := &amp;lt;-watcher.Errors:
          if ok { // 'Errors' channel is not closed
            log.Printf(&quot;watcher error: %v\n&quot;, err)
          }
          eventsWG.Done()
          return
        }
      }
    }()
    watcher.Add(configDir)
    initWG.Done()   // done initializing the watch in this go routine, so the parent routine can move on...
    eventsWG.Wait() // now, wait for event loop to end in this go-routine...
  }()
  initWG.Wait() // make sure that the go routine above fully ended before returning
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实流程是相似的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先，调用&lt;code&gt;NewWatcher&lt;/code&gt;创建一个监听器；&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;v.getConfigFile()&lt;/code&gt;获取配置文件路径，抽出文件名、目录，配置文件如果是一个符号链接，获得链接指向的路径；&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;watcher.Add(configDir)&lt;/code&gt;监听配置文件所在目录，另起一个 goroutine 处理事件。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;WatchConfig&lt;/code&gt;不能阻塞主 goroutine，所以创建监听器也是新起 goroutine 进行的。代码中有两个&lt;code&gt;sync.WaitGroup&lt;/code&gt;变量，&lt;code&gt;initWG&lt;/code&gt;是为了保证监听器初始化，&lt;br/&gt;&lt;code&gt;eventsWG&lt;/code&gt;是在事件通道关闭，或配置被删除了，或遇到错误时退出事件处理循环。&lt;/p&gt;
&lt;p&gt;然后就是核心事件循环：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;有事件发生时，判断变化的文件是否是在 viper 中设置的配置文件，发生的是否是创建或修改事件（只处理这两个事件）；&lt;/li&gt;
&lt;li&gt;如果配置文件为符号链接，若符合链接的指向修改了，也需要重新加载配置；&lt;/li&gt;
&lt;li&gt;如果需要重新加载配置，调用&lt;code&gt;v.ReadInConfig()&lt;/code&gt;读取新的配置；&lt;/li&gt;
&lt;li&gt;如果注册了事件回调，以发生的事件为参数执行回调。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;fsnotify&lt;/code&gt;的接口非常简单直接，所有系统相关的复杂性都被封装起来了。这也是我们平时设计模块和接口时可以参考的案例。&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://docs.google.com/document/d/1-GQrFdDVrA57-ce0kbzSth4lQqfOMMRKpih3hPJmvoU/edit&quot;&gt;fsnotify API 设计&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/fsnotify/fsnotify&quot;&gt;fsnotify GitHub 仓库&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;我&quot;&gt;我&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://darjun.github.io&quot;&gt;我的博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎关注我的微信公众号【GoUpUp】，共同学习，一起进步~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1919725/202001/1919725-20200121064250325-1446418159.jpg&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;4.1509433962264&quot;&gt;
&lt;p&gt;本文由博客一文多发平台 &lt;a href=&quot;https://openwrite.cn?from=article_bottom&quot;&gt;OpenWrite&lt;/a&gt; 发布！&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 20 Jan 2020 22:43:00 +0000</pubDate>
<dc:creator>darjun</dc:creator>
<og:description>简介 上一篇文章 &amp;quot;Go 每日一库之 viper&amp;quot; 中，我们介绍了 viper 可以监听文件修改进而自动重新加载。 其内部使用的就是 这个库，它是跨平台的。今天我们就来介绍一下它。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/darjun/p/12220546.html</dc:identifier>
</item>
<item>
<title>Spring Boot 入门（十二）：报表导出，对比poi、jxl和esayExcel的效率 - 光头才能强</title>
<link>http://www.cnblogs.com/dz-boss/p/12220073.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dz-boss/p/12220073.html</guid>
<description>&lt;p&gt;本片博客是紧接着&lt;a class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/dz-boss/p/12203735.html&quot;&gt;Spring Boot 入门（十一）：集成 WebSocket, 实时显示系统日志&lt;/a&gt;写的&lt;/p&gt;
&lt;p&gt;关于poi、jxl和esayExcel的介绍自行百度。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;jxl最多支持03版excel，所以单个sheet页面最多只能导出65536条数据。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;我直接将excel导入到浏览器并打开，以下统计导出时长指将数据从数据库查询，并写入到excel的过程。不包括打开excel所消耗的时间&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;为了接近真实场景，我建了一个表，一共有32个字段，其中2个id：一个自增长、一个UUID，10个int型字段，10个String字段，10个datatime字段；导出的excel包含了32个字段&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;我每次导出一个excel后，直接将jvm的内存清空，再进行下一个excel的导出，保证导出excel不受其它线程的影响&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;我只是为了比较性能，所以没有对excel的样式进行过多的渲染&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;poi方式，我使用的是刷新硬盘的方式，数据量大于设置的值，就将内存中的数据刷新到硬盘，降低OOM的概率，同时也增加了导出效率&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下是poi、jxl和esayExcel的全部依赖&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;  &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;begin poi&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.apache.poi&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;poi&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;${poi.version}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.apache.poi&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;poi-ooxml&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;${poi.version}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;end poi&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;begin jxl&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;net.sourceforge.jexcelapi&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;jxl&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2.6.10&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;end jxl&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;begin esayExcel&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.alibaba&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;easyexcel&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.1.2-beat1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;end esayExcel&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;由于是直接将excel通过response相应的方式写入到内存，然后在浏览器端打开，所以页面部分不能用ajax请求&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;form-horizontal&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;form-group clearfix&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;button&quot;&lt;/span&gt;&lt;span&gt; onclick&lt;/span&gt;&lt;span&gt;=&quot;report_poi();&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;btn btn-sm btn-warning&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;poi导出&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;button&quot;&lt;/span&gt;&lt;span&gt; onclick&lt;/span&gt;&lt;span&gt;=&quot;report_jxl();&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;btn btn-sm btn-danger&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;jxl导出&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;button&quot;&lt;/span&gt;&lt;span&gt; onclick&lt;/span&gt;&lt;span&gt;=&quot;report_esay_excel();&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;btn btn-sm btn-primary&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;esayExcel导出&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt;             &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt; function report_poi() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;        window.location.href = &quot;/conf/report/reportPoi&quot;;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    function report_jxl() {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        window.location.href = &quot;/conf/report/reportJxl&quot;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    function report_esay_excel() {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        window.location.href = &quot;/conf/report/reportEsayExcel&quot;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在类中定义了一个常量，表示excel的表头&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 报表的title&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String[] title = {&quot;id&quot;, &quot;报表id&quot;
&lt;span&gt;3&lt;/span&gt;             , &quot;col1&quot;, &quot;col2&quot;, &quot;col3&quot;, &quot;col4&quot;, &quot;col5&quot;, &quot;col6&quot;, &quot;col7&quot;, &quot;col8&quot;, &quot;col9&quot;, &quot;col10&quot;
&lt;span&gt;4&lt;/span&gt;             , &quot;col11&quot;, &quot;col12&quot;, &quot;col13&quot;, &quot;col14&quot;, &quot;col15&quot;, &quot;col16&quot;, &quot;col17&quot;, &quot;col18&quot;, &quot;col19&quot;, &quot;col20&quot;
&lt;span&gt;5&lt;/span&gt;             , &quot;col21&quot;, &quot;col22&quot;, &quot;col23&quot;, &quot;col24&quot;, &quot;col25&quot;, &quot;col26&quot;, &quot;col27&quot;, &quot;col28&quot;, &quot;col29&quot;, &quot;col30&quot;};
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;（1）poi相关的后台代码&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;  @Log(&quot;poi导出报表&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     @RequestMapping(value = &quot;/reportPoi&quot;, method =&lt;span&gt; RequestMethod.GET)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    @ResponseBody
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; String reportPoi(HttpServletResponse response) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;excel文件名&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         log.info(&quot;poi方式开始导出数据&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         response.reset();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 清空输出流&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;         response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment;filename=poi.xlsx&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         response.setContentType(&quot;application/octet-stream;charset=UTF-8&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         response.addHeader(&quot;Pargam&quot;, &quot;no-cache&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         response.addHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;sheet页中的行数,行数数据；&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;         List&amp;lt;Report&amp;gt; list =&lt;span&gt; reportService.getAllDate();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;long&lt;/span&gt; start =&lt;span&gt; System.currentTimeMillis();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 开始导出excel&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;         SXSSFWorkbook wb = &lt;span&gt;new&lt;/span&gt; SXSSFWorkbook(1000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         SXSSFSheet sheet = wb.createSheet(&quot;poi&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         CellStyle style =&lt;span&gt; wb.createCellStyle();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         style.setWrapText(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         Row row = sheet.createRow(0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         Cell cell = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; title.length; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             cell =&lt;span&gt; row.createCell(i);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;            cell.setCellValue(title[i]);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;            cell.setCellStyle(style);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; list.size(); i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             Report report =&lt;span&gt; list.get(i);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             row = sheet.createRow(i + 1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             row.createCell(0&lt;span&gt;).setCellValue(report.getId());
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             row.createCell(1&lt;span&gt;).setCellValue(report.getReportId());
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             row.createCell(2&lt;span&gt;).setCellValue(report.getCol1());
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;             row.createCell(3&lt;span&gt;).setCellValue(report.getCol2());
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             row.createCell(4&lt;span&gt;).setCellValue(report.getCol3());
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;             row.createCell(5&lt;span&gt;).setCellValue(report.getCol4());
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;             row.createCell(6&lt;span&gt;).setCellValue(report.getCol5());
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;             row.createCell(7&lt;span&gt;).setCellValue(report.getCol6());
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;             row.createCell(8&lt;span&gt;).setCellValue(report.getCol7());
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;             row.createCell(9&lt;span&gt;).setCellValue(report.getCol8());
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;             row.createCell(10&lt;span&gt;).setCellValue(report.getCol9());
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;             row.createCell(11&lt;span&gt;).setCellValue(report.getCol10());
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;             row.createCell(12&lt;span&gt;).setCellValue(report.getCol11());
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;             row.createCell(13&lt;span&gt;).setCellValue(report.getCol12());
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;             row.createCell(14&lt;span&gt;).setCellValue(report.getCol13());
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;             row.createCell(15&lt;span&gt;).setCellValue(report.getCol14());
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;             row.createCell(16&lt;span&gt;).setCellValue(report.getCol15());
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;             row.createCell(17&lt;span&gt;).setCellValue(report.getCol16());
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;             row.createCell(18&lt;span&gt;).setCellValue(report.getCol17());
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;             row.createCell(19&lt;span&gt;).setCellValue(report.getCol18());
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;             row.createCell(20&lt;span&gt;).setCellValue(report.getCol19());
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;             row.createCell(21&lt;span&gt;).setCellValue(report.getCol20());
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;             row.createCell(22&lt;span&gt;).setCellValue(report.getCol21());
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;             row.createCell(23&lt;span&gt;).setCellValue(report.getCol22());
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;             row.createCell(24&lt;span&gt;).setCellValue(report.getCol23());
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;             row.createCell(25&lt;span&gt;).setCellValue(report.getCol24());
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;             row.createCell(26&lt;span&gt;).setCellValue(report.getCol25());
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;             row.createCell(27&lt;span&gt;).setCellValue(report.getCol26());
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;             row.createCell(28&lt;span&gt;).setCellValue(report.getCol27());
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;             row.createCell(29&lt;span&gt;).setCellValue(report.getCol28());
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;             row.createCell(30&lt;span&gt;).setCellValue(report.getCol29());
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;             row.createCell(31&lt;span&gt;).setCellValue(report.getCol30());
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; 
&lt;span&gt;63&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;         &lt;span&gt;long&lt;/span&gt; millis = System.currentTimeMillis() -&lt;span&gt; start;
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;         OutputStream os =&lt;span&gt; response.getOutputStream();
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt; &lt;span&gt;        wb.write(os);
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt; &lt;span&gt;        os.flush();
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt; &lt;span&gt;        os.close();
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt; &lt;span&gt;        wb.dispose();
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt;         log.info(&quot;POI导出报表，数据量：{},时间：{}ms&quot;&lt;span&gt;, list.size(), millis);
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &quot;&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;（2）jxl相关后台代码&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;114&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; @Log(&quot;jxl导出报表&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     @RequestMapping(value = &quot;/reportJxl&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    @ResponseBody
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; String reportJxl(HttpServletResponse response) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         log.info(&quot;jxl方式开始导出数据&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;long&lt;/span&gt; start =&lt;span&gt; System.currentTimeMillis();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             OutputStream os = response.getOutputStream();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 取得输出流&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;             response.reset();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 清空输出流&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;             response.setHeader(&quot;Content-disposition&quot;, &quot;attachment; filename=&quot; + java.net.URLEncoder.encode(&quot;jxl&quot;, &quot;UTF-8&quot;) + &quot;Excel.xlsx&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设定输出文件头&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;             response.setContentType(&quot;application/msexcel&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义输出类型&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;             WritableWorkbook workbook = jxl.Workbook.createWorkbook(os); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 建立excel文件&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;             WritableSheet sheet1 = workbook.createSheet(&quot;jxl&quot;, 0);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第一个sheet名
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过函数WritableFont（）设置字体样式
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第一个参数表示所选字体
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第二个参数表示字体大小
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第三个参数表示粗体样式，有BOLD和NORMAL两种样式
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第四个参数表示是否斜体
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第五个参数表示下划线样式
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第六个参数表示颜色样式&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;             WritableFont wf = &lt;span&gt;new&lt;/span&gt; WritableFont(WritableFont.TIMES, 16, WritableFont.BOLD, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;, UnderlineStyle.NO_UNDERLINE, Colour.BLACK);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             CellFormat cf = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; WritableCellFormat(wf);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置表头&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; title.length; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                 sheet1.addCell(&lt;span&gt;new&lt;/span&gt; Label(i, 0&lt;span&gt;, title[i], cf));
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             List&amp;lt;Report&amp;gt; list =&lt;span&gt; reportService.getAllDate();
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据内容自动设置列宽(内容为英文时)
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 生成主体内容&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; list.size(); i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                 Report report =&lt;span&gt; list.get(i);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;                 sheet1.addCell(&lt;span&gt;new&lt;/span&gt; Label(0, i + 1&lt;span&gt;, report.getId().toString()));
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                 sheet1.addCell(&lt;span&gt;new&lt;/span&gt; Label(1, i + 1&lt;span&gt;, report.getReportId()));
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;                 sheet1.addCell(&lt;span&gt;new&lt;/span&gt; Label(2, i + 1&lt;span&gt;, report.getCol1().toString()));
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                 sheet1.addCell(&lt;span&gt;new&lt;/span&gt; Label(3, i + 1&lt;span&gt;, report.getCol2().toString()));
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                 sheet1.addCell(&lt;span&gt;new&lt;/span&gt; Label(4, i + 1&lt;span&gt;, report.getCol3().toString()));
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;                 sheet1.addCell(&lt;span&gt;new&lt;/span&gt; Label(5, i + 1&lt;span&gt;, report.getCol4().toString()));
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                 sheet1.addCell(&lt;span&gt;new&lt;/span&gt; Label(6, i + 1&lt;span&gt;, report.getCol5().toString()));
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;                 sheet1.addCell(&lt;span&gt;new&lt;/span&gt; Label(7, i + 1&lt;span&gt;, report.getCol6().toString()));
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;                 sheet1.addCell(&lt;span&gt;new&lt;/span&gt; Label(8, i + 1&lt;span&gt;, report.getCol7().toString()));
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;                 sheet1.addCell(&lt;span&gt;new&lt;/span&gt; Label(9, i + 1&lt;span&gt;, report.getCol8().toString()));
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;                 sheet1.addCell(&lt;span&gt;new&lt;/span&gt; Label(10, i + 1&lt;span&gt;, report.getCol9().toString()));
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;                 sheet1.addCell(&lt;span&gt;new&lt;/span&gt; Label(11, i + 1&lt;span&gt;, report.getCol10().toString()));
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;                 sheet1.addCell(&lt;span&gt;new&lt;/span&gt; Label(12, i + 1&lt;span&gt;, report.getCol11()));
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;                 sheet1.addCell(&lt;span&gt;new&lt;/span&gt; Label(13, i + 1&lt;span&gt;, report.getCol12()));
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;                 sheet1.addCell(&lt;span&gt;new&lt;/span&gt; Label(14, i + 1&lt;span&gt;, report.getCol13()));
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;                 sheet1.addCell(&lt;span&gt;new&lt;/span&gt; Label(15, i + 1&lt;span&gt;, report.getCol14()));
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;                 sheet1.addCell(&lt;span&gt;new&lt;/span&gt; Label(16, i + 1&lt;span&gt;, report.getCol15()));
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;                 sheet1.addCell(&lt;span&gt;new&lt;/span&gt; Label(17, i + 1&lt;span&gt;, report.getCol16()));
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;                 sheet1.addCell(&lt;span&gt;new&lt;/span&gt; Label(18, i + 1&lt;span&gt;, report.getCol17()));
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;                 sheet1.addCell(&lt;span&gt;new&lt;/span&gt; Label(19, i + 1&lt;span&gt;, report.getCol18()));
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;                 sheet1.addCell(&lt;span&gt;new&lt;/span&gt; Label(20, i + 1&lt;span&gt;, report.getCol19()));
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;                 sheet1.addCell(&lt;span&gt;new&lt;/span&gt; Label(21, i + 1&lt;span&gt;, report.getCol20()));
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;                 sheet1.addCell(&lt;span&gt;new&lt;/span&gt; Label(22, i + 1&lt;span&gt;, report.getCol21().toString()));
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;                 sheet1.addCell(&lt;span&gt;new&lt;/span&gt; Label(23, i + 1&lt;span&gt;, report.getCol22().toString()));
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;                 sheet1.addCell(&lt;span&gt;new&lt;/span&gt; Label(24, i + 1&lt;span&gt;, report.getCol23().toString()));
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;                 sheet1.addCell(&lt;span&gt;new&lt;/span&gt; Label(25, i + 1&lt;span&gt;, report.getCol24().toString()));
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;                 sheet1.addCell(&lt;span&gt;new&lt;/span&gt; Label(26, i + 1&lt;span&gt;, report.getCol25().toString()));
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;                 sheet1.addCell(&lt;span&gt;new&lt;/span&gt; Label(27, i + 1&lt;span&gt;, report.getCol26().toString()));
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;                 sheet1.addCell(&lt;span&gt;new&lt;/span&gt; Label(28, i + 1&lt;span&gt;, report.getCol27().toString()));
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;                 sheet1.addCell(&lt;span&gt;new&lt;/span&gt; Label(29, i + 1&lt;span&gt;, report.getCol28().toString()));
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;                 sheet1.addCell(&lt;span&gt;new&lt;/span&gt; Label(30, i + 1&lt;span&gt;, report.getCol29().toString()));
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt;                 sheet1.addCell(&lt;span&gt;new&lt;/span&gt; Label(31, i + 1&lt;span&gt;, report.getCol30().toString()));
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;             workbook.write(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 写入文件&lt;/span&gt;
&lt;span&gt;66&lt;/span&gt; &lt;span&gt;            workbook.close();
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt;             os.close(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 关闭流&lt;/span&gt;
&lt;span&gt;68&lt;/span&gt;             &lt;span&gt;long&lt;/span&gt; millis = System.currentTimeMillis() -&lt;span&gt; start;
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt;             log.info(&quot;jxl导出报表，数据量：{},时间：{}ms&quot;&lt;span&gt;, list.size(), millis);
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt;             log.error(&quot;jxl导出报表报错&quot;&lt;span&gt;, e);
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &quot;&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;（3）esayExcel相关后台代码&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; @Log(&quot;esayExcel导出报表&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     @RequestMapping(value = &quot;/reportEsayExcel&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    @ResponseBody
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; String reportEsayExcel(HttpServletResponse response) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         log.info(&quot;esayExcel方式开始导出数据&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;long&lt;/span&gt; start =&lt;span&gt; System.currentTimeMillis();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             ExcelWriter writer = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             OutputStream outputStream =&lt;span&gt; response.getOutputStream();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加响应头信息&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;             response.setHeader(&quot;Content-disposition&quot;, &quot;attachment; filename= esayExcel.xlsx&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             response.setContentType(&quot;application/msexcel;charset=UTF-8&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置类型&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;             response.setHeader(&quot;Pragma&quot;, &quot;No-cache&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置头&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;             response.setHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置头&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;             response.setDateHeader(&quot;Expires&quot;, 0);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置日期头
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;实例化 ExcelWriter&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;             writer = &lt;span&gt;new&lt;/span&gt; ExcelWriter(outputStream, ExcelTypeEnum.XLSX, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;实例化表单&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;             Sheet sheet = &lt;span&gt;new&lt;/span&gt; Sheet(1, 0, Report.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             sheet.setSheetName(&quot;esayExcel&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取数据&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;             List&amp;lt;Report&amp;gt; list =&lt;span&gt; reportService.getAllDate();
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;            writer.write(list, sheet);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;            writer.finish();
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;            outputStream.flush();
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             &lt;span&gt;long&lt;/span&gt; millis = System.currentTimeMillis() -&lt;span&gt; start;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;             log.info(&quot;sayExcel导出报表，数据量：{},时间：{}ms&quot;&lt;span&gt;, list.size(), millis);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;             log.error(&quot;esayExcel导出excel报错&quot;&lt;span&gt;, e);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;                response.getOutputStream().close();
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;             } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;                 log.error(&quot;esayExcel关闭资源&quot;&lt;span&gt;, e);
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &quot;&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.learn.hello.system.common.listener;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.alibaba.excel.context.AnalysisContext;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.alibaba.excel.event.AnalysisEventListener;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; lombok.extern.slf4j.Slf4j;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.poi.ss.formula.functions.T;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.ArrayList;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt; * @ClassName ExcelListener
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt; * @Deccription 通过esayExcel的方式导出excel
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt; * @Author DZ
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt; * @Date 2020/1/20 22:28
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt; *&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;@Slf4j
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ExcelListener &lt;span&gt;extends&lt;/span&gt; AnalysisEventListener&amp;lt;T&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;可以通过实例获取该值&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; List&amp;lt;T&amp;gt; rows = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; invoke(T object, AnalysisContext analysisContext) {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据存储到list，供批量处理，或后续自己业务逻辑处理。&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        rows.add(object);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doAfterAllAnalysed(AnalysisContext analysisContext) {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; List&amp;lt;T&amp;gt;&lt;span&gt; getRows() {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; rows;
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
ExcelListener 这个类中还可以做很多工作，比喻在doAfterAllAnalysed中做一些销毁工作，日志记录等。在invoke中做一些业务相关的工作，或者对rows进行遍历处理&lt;p&gt;实体类:
&lt;/p&gt;&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.learn.hello.modules.entity;
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; 
&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.alibaba.excel.annotation.ExcelProperty;
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.alibaba.excel.metadata.BaseRowModel;
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; lombok.Data;
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; 
&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; javax.persistence.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Date;
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; 
&lt;span&gt; 10&lt;/span&gt; &lt;span&gt;@Data
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt; @Table(name = &quot;t_report&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Report &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; BaseRowModel {
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt;     @ExcelProperty(value = &quot;id&quot;, index = 0&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt; &lt;span&gt;    @Id
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt;     @GeneratedValue(strategy =&lt;span&gt; GenerationType.IDENTITY)
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer id;
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt; 
&lt;span&gt; 18&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 19&lt;/span&gt; &lt;span&gt;     * 报表id
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 21&lt;/span&gt;     @ExcelProperty(value = &quot;报表id&quot;, index = 1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt;     @Column(name = &quot;report_id&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String reportId;
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt; 
&lt;span&gt; 25&lt;/span&gt;     @ExcelProperty(value = &quot;col1&quot;, index = 2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer col1;
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt; 
&lt;span&gt; 28&lt;/span&gt;     @ExcelProperty(value = &quot;col2&quot;, index = 3&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer col2;
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt; 
&lt;span&gt; 31&lt;/span&gt;     @ExcelProperty(value = &quot;col3&quot;, index = 4&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer col3;
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt; 
&lt;span&gt; 34&lt;/span&gt;     @ExcelProperty(value = &quot;col4&quot;, index = 5&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer col4;
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt; 
&lt;span&gt; 37&lt;/span&gt;     @ExcelProperty(value = &quot;col5&quot;, index = 6&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer col5;
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt; 
&lt;span&gt; 40&lt;/span&gt;     @ExcelProperty(value = &quot;col6&quot;, index = 7&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer col6;
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt; 
&lt;span&gt; 43&lt;/span&gt;     @ExcelProperty(value = &quot;col7&quot;, index = 8&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer col7;
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt; 
&lt;span&gt; 46&lt;/span&gt;     @ExcelProperty(value = &quot;col8&quot;, index = 9&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer col8;
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt; 
&lt;span&gt; 49&lt;/span&gt;     @ExcelProperty(value = &quot;col9&quot;, index = 10&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer col9;
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt; 
&lt;span&gt; 52&lt;/span&gt;     @ExcelProperty(value = &quot;col10&quot;, index = 11&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer col10;
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt; 
&lt;span&gt; 55&lt;/span&gt;     @ExcelProperty(value = &quot;col11&quot;, index = 12&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String col11;
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt; 
&lt;span&gt; 58&lt;/span&gt;     @ExcelProperty(value = &quot;col12&quot;, index = 13&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String col12;
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt; 
&lt;span&gt; 61&lt;/span&gt;     @ExcelProperty(value = &quot;col13&quot;, index = 14&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String col13;
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt; 
&lt;span&gt; 64&lt;/span&gt;     @ExcelProperty(value = &quot;col14&quot;, index = 15&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String col14;
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt; 
&lt;span&gt; 67&lt;/span&gt;     @ExcelProperty(value = &quot;col15&quot;, index = 16&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String col15;
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt; 
&lt;span&gt; 70&lt;/span&gt;     @ExcelProperty(value = &quot;col16&quot;, index = 17&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String col16;
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt; 
&lt;span&gt; 73&lt;/span&gt;     @ExcelProperty(value = &quot;col17&quot;, index = 18&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String col17;
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt; 
&lt;span&gt; 76&lt;/span&gt;     @ExcelProperty(value = &quot;col18&quot;, index = 19&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String col18;
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt; 
&lt;span&gt; 79&lt;/span&gt;     @ExcelProperty(value = &quot;col19&quot;, index = 20&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String col19;
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt; 
&lt;span&gt; 82&lt;/span&gt;     @ExcelProperty(value = &quot;col20&quot;, index = 21&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String col20;
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt; 
&lt;span&gt; 85&lt;/span&gt;     @ExcelProperty(value = &quot;col21&quot;, index = 22&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Date col21;
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt; 
&lt;span&gt; 88&lt;/span&gt;     @ExcelProperty(value = &quot;col22&quot;, index = 23&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Date col22;
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt; 
&lt;span&gt; 91&lt;/span&gt;     @ExcelProperty(value = &quot;col23&quot;, index = 24&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Date col23;
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt; 
&lt;span&gt; 94&lt;/span&gt;     @ExcelProperty(value = &quot;col24&quot;, index = 25&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Date col24;
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt; 
&lt;span&gt; 97&lt;/span&gt;     @ExcelProperty(value = &quot;col25&quot;, index = 26&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Date col25;
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt; 
&lt;span&gt;100&lt;/span&gt;     @ExcelProperty(value = &quot;col26&quot;, index = 27&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Date col26;
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt; 
&lt;span&gt;103&lt;/span&gt;     @ExcelProperty(value = &quot;col27&quot;, index = 28&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Date col27;
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt; 
&lt;span&gt;106&lt;/span&gt;     @ExcelProperty(value = &quot;col28&quot;, index = 29&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Date col28;
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt; 
&lt;span&gt;109&lt;/span&gt;     @ExcelProperty(value = &quot;col29&quot;, index = 30&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Date col29;
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt; 
&lt;span&gt;112&lt;/span&gt;     @ExcelProperty(value = &quot;col30&quot;, index = 31&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Date col30;
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt; 
&lt;span&gt;115&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中@ExcelProperty(value = &quot;col30&quot;, index = 14)注解是给esayExcel'使用的，poi和jxl使用这个实体的时候，这行注解可以忽略&lt;/p&gt;


&lt;p&gt;以下是打印的日志：由于jxl最多只能导出65536条数据，所以在70W条数据导出的时候，就没有jxl的相关耗时。此外，在导出第80W条以及以后的数据的时候，&lt;strong&gt;我将jvm内存清空了，让jvm以最佳的状态导出，所以60W到80W的时候，耗时并没有增加多少&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;**************************************************idea打印出的日志************************************************&lt;/p&gt;
&lt;p&gt;POI导出报表，数据量：10001,时间：752ms&lt;br/&gt;jxl导出报表，数据量：10001,时间：993ms&lt;br/&gt;sayExcel导出报表，数据量：10001,时间：2189ms&lt;/p&gt;
&lt;p&gt;POI导出报表，数据量：20001,时间：1527ms&lt;br/&gt;jxl导出报表，数据量：20001,时间：2447ms&lt;br/&gt;sayExcel导出报表，数据量：20001,时间：3481ms&lt;/p&gt;
&lt;p&gt;POI导出报表，数据量：30001,时间：1538ms&lt;br/&gt;jxl导出报表，数据量：30001,时间：2520ms&lt;br/&gt;sayExcel导出报表，数据量：30001,时间：5102ms&lt;/p&gt;
&lt;p&gt;POI导出报表，数据量：40001,时间：1892ms&lt;br/&gt;jxl导出报表，数据量：40001,时间：3549ms&lt;br/&gt;sayExcel导出报表，数据量：40001,时间：7523ms&lt;/p&gt;
&lt;p&gt;POI导出报表，数据量：50001,时间：2395ms&lt;br/&gt;jxl导出报表，数据量：50001,时间：4714ms&lt;br/&gt;sayExcel导出报表，数据量：50001,时间：8319ms&lt;/p&gt;
&lt;p&gt;POI导出报表，数据量：60001,时间：2860ms&lt;br/&gt;jxl导出报表，数据量：60001,时间：5255ms&lt;br/&gt;sayExcel导出报表，数据量：60001,时间：10197ms&lt;/p&gt;
&lt;p&gt;POI导出报表，数据量：70001,时间：3693ms&lt;br/&gt;sayExcel导出报表，数据量：70001,时间：11595ms&lt;/p&gt;
&lt;p&gt;POI导出报表，数据量：80001,时间：3843ms&lt;br/&gt;sayExcel导出报表，数据量：80001,时间：13928ms&lt;/p&gt;
&lt;p&gt;POI导出报表，数据量：90001,时间：4319ms&lt;br/&gt;sayExcel导出报表，数据量：90001,时间：14901ms&lt;/p&gt;
&lt;p&gt;POI导出报表，数据量：100001,时间：4943ms&lt;br/&gt;sayExcel导出报表，数据量：100001,时间：15962ms&lt;/p&gt;
&lt;p&gt;POI导出报表，数据量：200011,时间：11296ms&lt;br/&gt;sayExcel导出报表，数据量：200011,时间：33037ms&lt;/p&gt;
&lt;p&gt;POI导出报表，数据量：300011,时间：14947ms&lt;br/&gt;sayExcel导出报表，数据量：300011,时间：49748ms&lt;/p&gt;
&lt;p&gt;POI导出报表，数据量：400011,时间：19626ms&lt;br/&gt;sayExcel导出报表，数据量：400011,时间：66043ms&lt;/p&gt;
&lt;p&gt;POI导出报表，数据量：600011,时间：34418ms&lt;br/&gt;sayExcel导出报表，数据量：600011,时间：101819ms&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;POI导出报表，数据量：800011,时间：38726ms&lt;br/&gt;sayExcel导出报表，数据量：800011,时间：135209ms&lt;/p&gt;
&lt;p&gt;POI导出报表，数据量：1000011,时间：47433ms&lt;br/&gt;sayExcel导出报表，数据量：1000011,时间：167676ms&lt;/p&gt;
&lt;p&gt;**************************************************idea打印出的日志************************************************&lt;/p&gt;

&lt;p&gt;对上面的数据量取整，统计图如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1147108/202001/1147108-20200121010948414-1294413037.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 第一行为数据量，从3W到100W&lt;/p&gt;
&lt;p&gt; 第二到四行为导出excel消耗的时间，单位为毫秒&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1147108/202001/1147108-20200121011327423-878459052.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 其中纵坐标为导出时间，横轴为导出数量。&lt;/p&gt;
&lt;p&gt;结论：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;从时间上：poi&amp;gt;jxl&amp;gt;esayExcel&lt;/li&gt;
&lt;li&gt;从代码简洁程度上：esayExce&amp;gt;jxl&amp;gt;poi&lt;/li&gt;
&lt;li&gt;从jvm内存消耗上，我监控的是最高峰的内存消耗量：3中方式都差不多（网上说esayExcel消耗内存很小，我真的没看出来）&lt;/li&gt;
&lt;li&gt;jxl可以直接设置excel模板，所以对于复杂表头的excel，jxl处理起来很方便（具体可以自行搜索jxl 模板 导出）&lt;/li&gt;
&lt;li&gt;esayExcel目前没有提供较复杂的api，无法导出较复杂的数据（二进制图片，音乐等）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果对于表头简单，且数据量小于10W条数据的，推荐使用esayExcel该方式代码很简洁，10W以下的导出效率还行&lt;/p&gt;
&lt;p&gt;如果小于60W条数据，表头复杂建议使用jxl；表头简单，建立使用poi&lt;/p&gt;
&lt;p&gt;如果大于60W条数据，选择poi&lt;/p&gt;
&lt;p&gt;poi方式处理代码繁琐点，性能很好，不知道如何选择，就直接使用poi，不会出错&lt;/p&gt;
&lt;p&gt;完整的项目和代码见：&lt;a href=&quot;https://gitee.com/bald_dz/SpringbootLean&quot;&gt;https://gitee.com/bald_dz/SpringbootLean&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 20 Jan 2020 17:28:00 +0000</pubDate>
<dc:creator>光头才能强</dc:creator>
<og:description>本片博客是紧接着Spring Boot 入门（十一）：集成 WebSocket, 实时显示系统日志写的 关于poi、jxl和esayExcel的介绍自行百度。 jxl最多支持03版excel，所以单个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/dz-boss/p/12220073.html</dc:identifier>
</item>
<item>
<title>Spring-cloud微服务实战【六】：接口服务feign - 悟空不败</title>
<link>http://www.cnblogs.com/wukongbubai/p/12219920.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wukongbubai/p/12219920.html</guid>
<description>&lt;p&gt;在上一篇文章中,我们使用了ribbon进行负载均衡,但是仔细思考一下,我们的请求封装和调用以及结果的返回都是我们自己编码完成的,如果需要调用的接口很多,那么无疑开发量是比较大的,那有没有比较好的方式呢?答案就是feign.让我们先通过代码来看一下feign的使用:&lt;br/&gt;首先,我们需要复制一份consumer的代码,并且重命名为dhp-micro-service-consumer-feign:&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1924225/202001/1924225-20200121002141132-427624077.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后修改代码如下:&lt;br/&gt;1.新增maven依赖:&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1924225/202001/1924225-20200121002141379-1762637679.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.修改代码:&lt;br/&gt;首先新增一个feign的接口:&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1924225/202001/1924225-20200121002141623-1026603674.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外,如果要通过Feign进行远程调用，依然需要安全服务提供方的认证问题，所幸feign里面已经集成了这块功能:&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1924225/202001/1924225-20200121002141866-1237578746.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时,准备工作已经做好了,修改controller的代码:&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1924225/202001/1924225-20200121002142104-772272042.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后启动起来试一试:&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1924225/202001/1924225-20200121002142343-583781931.jpg&quot; alt=&quot;file&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1924225/202001/1924225-20200121002142613-2133969350.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;说明feign已经继承成功,可以看到,和之前的代码量相比,使用feign之后代码已经简洁许多了,并且如果producer启动了集群,可以发现feign自带负载均衡功能,因为feign也集成了ribbon,我们用两张图来对比一下:&lt;br/&gt;在没有集成feign之前,我们是直接走ribbon:&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1924225/202001/1924225-20200121002142907-2113419098.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;集成feign之后,我们是走feign:&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1924225/202001/1924225-20200121002143154-1155850225.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以新增ribbon策略试一试:&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1924225/202001/1924225-20200121002143382-1807864106.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再次启动,会发现负载均衡规则是随机访问了.&lt;/p&gt;
&lt;h2 id=&quot;数据压缩&quot;&gt;数据压缩&lt;/h2&gt;
&lt;p&gt;我们已经知道,feign最主要的作用就是将Rest服务的信息转化为接口,这其中还有其他的一些地方应该要考虑,比如:数据的压缩.Rest协议更多的传输的是文本,JSON或者XML,如果用户发送的请求很大,这个时候有必要对数据进行压缩处理,feign本身提供了对压缩的支持:&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1924225/202001/1924225-20200121002143653-314924490.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;介绍完了feign,下一篇文章,我们会介绍服务熔断与降级hystrix,敬请期待.&lt;br/&gt;&lt;a href=&quot;https://github.com/dongheping/dhp-micro-service-chapter5&quot;&gt;本文的GitHub地址&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;4.1509433962264&quot;&gt;
&lt;p&gt;本文由博客一文多发平台 &lt;a href=&quot;https://openwrite.cn?from=article_bottom&quot;&gt;OpenWrite&lt;/a&gt; 发布！&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 20 Jan 2020 16:22:00 +0000</pubDate>
<dc:creator>悟空不败</dc:creator>
<og:description>在上一篇文章中,我们使用了ribbon进行负载均衡,但是仔细思考一下,我们的请求封装和调用以及结果的返回都是我们自己编码完成的,如果需要调用的接口很多,那么无疑开发量是比较大的,那有没有比较好的方式呢</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wukongbubai/p/12219920.html</dc:identifier>
</item>
<item>
<title>【Java并发基础】加锁机制解决原子性问题 - sakuraxx</title>
<link>http://www.cnblogs.com/myworld7/p/12219918.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/myworld7/p/12219918.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;原子性指一个或多个操作在CPU执行的过程不被中断的特性。前面提到原子性问题产生的源头是线程切换，而线程切换依赖于CPU中断。于是得出，禁用CPU中断就可以禁止线程切换从而解决原子性问题。但是这种情况只适用于单核，多核时不适用。&lt;/p&gt;
&lt;p&gt;以在 32 位 CPU 上执行 long 型变量的写操作为例来说明。&lt;br/&gt;long 型变量是 64 位，在 32 位 CPU 上执行写操作会被拆分成两次写操作（写高 32 位和写低 32 位，如下图所示，图来自【参考1】）。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1099419/202001/1099419-20200121001638914-1710837925.png&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在单核 CPU 场景下，同一时刻只有一个线程执行，禁止 CPU 中断，意味着操作系统不会重新调度线程，即禁止了线程切换，获得 CPU 使用权的线程就可以不间断地执行。所以两次写操作一定是：要么都被执行，要么都没有被执行，具有原子性。&lt;br/&gt;但是在多核场景下，同一时刻，可能有两个线程同时在执行，一个线程执行在 CPU-1 上，一个线程执行在 CPU-2 上。此时禁止 CPU 中断，只能保证 CPU 上的线程连续执行，并不能保证同一时刻只有一个线程执行。如果这两个线程同时向内存写 long 型变量高 32 位的话，那么就会造成我们写入的变量和我们读出来的是不一致的。&lt;/p&gt;
&lt;p&gt;所以解决原子性问题的重要条件还是为：&lt;strong&gt;同一时刻只能有一个线程对共享变量进行操作，即互斥&lt;/strong&gt;。如果我们能够保证对共享变量的修改是互斥的，那么，无论是单核 CPU 还是多核 CPU，就都能保证原子性。&lt;/p&gt;
&lt;p&gt;下面将介绍实现互斥访问的方案，加锁机制。&lt;/p&gt;
&lt;h2 id=&quot;锁模型&quot;&gt;锁模型&lt;/h2&gt;
&lt;p&gt;我们把一段需要互斥执行的代码称为&lt;strong&gt;临界区&lt;/strong&gt;。&lt;br/&gt;线程在进入临界区之前，首先尝试加锁 lock()，如果成功，则进入临界区，此时我们称这个线程持有锁；&lt;br/&gt;否则就等待或阻塞，直到持有锁的线程释放锁。持有锁的线程执行完临界区的代码后，执行解锁 unlock()。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;锁和锁要保护的资源是要对应的&lt;/strong&gt;。这个指的是两点：①我们要保护一个资源首先要创建一把锁；②锁要锁对资源，即锁A应该用来保护资源A，而不能用它来锁资源B。&lt;/p&gt;
&lt;p&gt;所以，最后的锁模型如下：（图来自【参考1】）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1099419/202001/1099419-20200121001605104-600176911.png&quot; width=&quot;600&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;java提供的锁技术-synchronized&quot;&gt;Java提供的锁技术: synchronized&lt;/h2&gt;
&lt;p&gt;锁是一种通用的技术方案，Java 语言提供的 &lt;code&gt;synchronized&lt;/code&gt;关键字，就是锁的一种实现。&lt;/p&gt;
&lt;p&gt;synchronized 关键字可以用来修饰方法，也可以用来修饰代码块，它的使用示例如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class X {
  // 修饰非静态方法
  synchronized void foo() {
    // 临界区
  }
    
  // 修饰静态方法
  synchronized static void bar() {
    // 临界区
  }
    
  // 修饰代码块
  Object obj = new Object()；
  void baz() {
    synchronized(obj) {
      // 临界区
    }
  }
    
}  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;与上面的锁模型比较，可以发现synchronized修饰的方法和代码块都没有显式地有加锁和释放锁操作。但是这并不代表没有这两个操作，这两个操作Java编译器会帮我们自动实现。&lt;strong&gt;Java 编译器会在 synchronized 修饰的方法或代码块前后自动加上加锁 lock() 和解锁 unlock()&lt;/strong&gt;，这样的好处在于代码更简洁，并且Java程序员也不必担心会忘记释放锁了。&lt;/p&gt;
&lt;p&gt;然后我们再观察可以发现：只有修饰代码块的时候，锁定了一个 obj 对象。那么修饰方法的时候锁了什么呢？&lt;br/&gt;这是Java的一个隐式规则：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;当修饰静态方法时，锁的是当前类的 Class 对象&lt;/strong&gt;，在上面的例子中就是 X.class；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;当修饰非静态方法时，锁定的是当前实例对象 this&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于上面的例子，synchronized 修饰静态方法相当于:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class X {
  // 修饰静态方法
  synchronized(X.class) static void bar() {
    // 临界区
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修饰非静态方法，相当于：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class X {
  // 修饰非静态方法
  synchronized(this) void foo() {
    // 临界区
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;内置锁&quot;&gt;内置锁&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;每个Java对象都可以用作一个实现同步的锁&lt;/strong&gt;，这些锁被称为&lt;strong&gt;内置锁&lt;/strong&gt;（Intrinsic Lock）或者监视器锁（Monitor Lock）。被synchronized关键字修饰的方法或者代码块，称为&lt;strong&gt;同步代码块&lt;/strong&gt;（Synchronized Block）。线程在进入同步代码块之前会自动获取锁，并且在退出同步代码块时自动释放锁，这在前面也提到过。&lt;/p&gt;
&lt;p&gt;Java的内置锁相当于一种互斥体（或互斥锁），这也就是说，最多只有一个线程能够持有这个锁。由于每次只能有一个线程执行内置锁保护的代码块，因此，&lt;strong&gt;由这个锁保护的同步代码块会以原子的方式执行&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;内置锁是可重入的&quot;&gt;内置锁是可重入的&lt;/h3&gt;
&lt;p&gt;当某个线程请求一个由其他线程所持有的锁时，发出请求的线程会被阻塞。然而，由于内置锁是可重入的，所以当某个线程试图获取一个已经由它自己所持有的锁时，这个请求就会成功。&lt;/p&gt;
&lt;p&gt;重入实现的一个方法是：为每个锁关联一个获取计数器和一个所有者线程。&lt;br/&gt;当计数器值为0时，这个锁就被认为是没有被任何线程持有的。当线程请求一个未被持有的锁时，JVM将记下锁的持有者，并且将计数器加1。如果同一个线程再次获取这个锁，计数器将加1，而当线程退出同步代码块时，计数器会相应地减1。当计数器为0时，这个锁将被释放。&lt;/p&gt;
&lt;p&gt;下面这段代码，如果内置锁是不可重入的，那么这段代码将发生死锁。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Widget{
    public synchronized void doSomething(){
        ....
    }
}
public class LoggingWidget extends Widget{
    public synchronized void doSomething(){
        System.out.println(toString() + &quot;: call doSomething&quot;);
        super.doSomething();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;使用synchronized解决count1问题&quot;&gt;使用synchronized解决count+=1问题&lt;/h2&gt;
&lt;p&gt;前面我们介绍&lt;a href=&quot;https://www.cnblogs.com/myworld7/p/12203093.html#_label2&quot;&gt;原子性问题&lt;/a&gt;时提到&lt;code&gt;count+=1&lt;/code&gt;存在原子性问题，那么现在我们使用synchronized来使count+=1成为一个原子操作。&lt;/p&gt;
&lt;p&gt;代码如下所示。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class SafeCalc {
  long value = 0L;
  long get() {
    return value;
  }
  synchronized void addOne() {
    value += 1;
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;SafeCalc 这个类有两个方法：一个是 get() 方法，用来获得 value 的值；另一个是 addOne() 方法，用来给 value 加 1，并且 addOne() 方法我们用 synchronized 修饰。下面我们分析看这个代码是否存在并发问题。&lt;/p&gt;
&lt;p&gt;addOne() 方法，被 synchronized 修饰后，无论是单核 CPU 还是多核 CPU，只有一个线程能够执行 addOne() 方法，所以一定能保证原子操作。&lt;br/&gt;那么可见性呢？是否可以保证一个线程调用addOne()使value加一的结果对另一个线程后面调用addOne()时可见？&lt;br/&gt;答案是可以的。这就需要回顾到我们上篇博客提到的&lt;a href=&quot;https://www.cnblogs.com/myworld7/p/12209222.html#_label2&quot;&gt;Happens-Before规则&lt;/a&gt;其中关于&lt;strong&gt;管程中的锁规则&lt;/strong&gt;：&lt;strong&gt;对同一个锁的解锁 Happens-Before 后续对这个锁的加锁&lt;/strong&gt;。即，&lt;span&gt;一个线程在临界区修改的共享变量（该操作在解锁之前），对后续进入临界区（该操作在加锁之后）的线程是可见的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;此时还不能掉以轻心，我们分析get()方法。执行 addOne() 方法后，value 的值对 get() 方法是可见的吗？答案是这个可见性没有保证。管程中锁的规则，是只保证后续对这个锁的加锁的可见性，而 get() 方法并没有加锁操作，所以可见性没法保证。所以，最终的解决办法为也是用synchronized修饰get()方法。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class SafeCalc {
  long value = 0L;
  synchronized long get() {
    return value;
  }
  synchronized void addOne() {
    value += 1;
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码转换成我们的锁模型为：（图来自【参考1】）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1099419/202001/1099419-20200121001520910-2071976341.png&quot; width=&quot;650&quot;/&gt;&lt;/p&gt;
&lt;p&gt;get() 方法和 addOne() 方法都需要访问 value 这个受保护的资源，这个资源用 this 这把锁来保护。线程要进入临界区 get() 和 addOne()，必须先获得 this 这把锁，这样 get() 和 addOne() 也是互斥的。&lt;/p&gt;
&lt;h2 id=&quot;锁和受保护资源的关系&quot;&gt;锁和受保护资源的关系&lt;/h2&gt;
&lt;p&gt;受保护资源和锁之间的关联关系非常重要，一个合理的关系为：&lt;strong&gt;锁和受保护资源之间的关联关系是 1:N&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;拿球赛门票管理来类比，一个座位（资源）可以用一张门票（锁）来保护，但是不可以有两张门票预定了同一个座位，不然这两个人就会fight。&lt;br/&gt;在现实中我们可以使用多把锁锁同一个资源，如果放在并发领域中，线程A获得锁1和线程B获得锁2都可以访问共享资源，那么达到互斥访问共享资源的目的。所以，在并发编程中使用多把锁锁同一个资源不可行。或许有人会想：要同时获得锁1和锁2才可以访问共享资源，这样应该是就可行的。我觉得是可以的，但是能用一个锁就可以保护资源，为什么还要加一个锁呢？&lt;br/&gt;多把锁锁一个资源不可以，但是我们可以用同一把锁来保护多个资源，这个对应到现实球赛门票就是可以用一张门票预定所有座位，即“包场”。&lt;/p&gt;
&lt;p&gt;下面举一个在并发编程中使用多把锁来保护同一个资源将会出现的并发问题：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class SafeCalc {
  static long value = 0L;
  synchronized long get() {
    return value;
  }
  synchronized static void addOne() {
    value += 1;
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;把 value 改成静态变量，把 addOne() 方法改成静态方法。&lt;br/&gt;仔细观察，就会发现改动后的代码是用两个锁保护一个资源。get()所使用的锁是this，而addOne()所使用的锁是SafeCalc.class。两把锁保护一个资源的示意图如下（图来自【参考1】）。&lt;br/&gt;由于临界区 get() 和 addOne() 是用两个锁保护的，因此这两个临界区没有互斥关系，临界区 addOne() 对 value 的修改对临界区 get() 也没有可见性保证，这就导致并发问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1099419/202001/1099419-20200121001449307-698491255.png&quot; width=&quot;650&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;Synchronized是 Java 在语言层面提供的互斥原语，Java中还有其他类型的锁。但是作为互斥锁，原理都是一样的，首先要有一个锁，然后是要锁住什么资源以及在哪里加锁就需要在设计层面考虑。&lt;br/&gt;最后一个主题提的锁和受保护资源的关系非常重要，在使用锁时一定要好好注意。&lt;/p&gt;
&lt;p&gt;参考：&lt;br/&gt;[1]极客时间专栏王宝令《Java并发编程实战》&lt;br/&gt;[2]Brian Goetz.Tim Peierls. et al.Java并发编程实战[M].北京:机械工业出版社,2016&lt;/p&gt;
</description>
<pubDate>Mon, 20 Jan 2020 16:20:00 +0000</pubDate>
<dc:creator>sakuraxx</dc:creator>
<og:description>前言 原子性指一个或多个操作在CPU执行的过程不被中断的特性。前面提到原子性问题产生的源头是线程切换，而线程切换依赖于CPU中断。于是得出，禁用CPU中断就可以禁止线程切换从而解决原子性问题。但是这种</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/myworld7/p/12219918.html</dc:identifier>
</item>
<item>
<title>算法：计算十进制数字在二进制表示1的个数 - 小林coding</title>
<link>http://www.cnblogs.com/xiaolincoding/p/12219909.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaolincoding/p/12219909.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;计算十进制数字在二进制表示 1 的个数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;举个例子:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;十进制数字为 1 时，它的二进制表示是 001，二进制表示 1 的个数为 1；&lt;/li&gt;
&lt;li&gt;十进制数字为 2 时，它的二进制表示是 010，二进制表示 1 的个数为 1；&lt;/li&gt;
&lt;li&gt;十进制数字为 3 时，它的二进制表示是 011，二进制表示 1 的个数为 2；&lt;/li&gt;
&lt;li&gt;十进制数字为 4 时，它的二进制表示是 100，二进制表示 1 的个数为 1；&lt;/li&gt;
&lt;li&gt;十进制数字为 5 时，它的二进制表示是 101，二进制表示 1 的个数为 2；&lt;/li&gt;
&lt;li&gt;十进制数字为 6 时，它的二进制表示是 110，二进制表示 1 的个数为 2；&lt;/li&gt;
&lt;li&gt;十进制数字为 7 时，它的二进制表示是 111，二进制表示 1 的个数为 3；&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;时间复杂度-ologn-的解法&quot;&gt;时间复杂度 O(logn) 的解法&lt;/h2&gt;
&lt;p&gt;对于这个题目比较容易想到的是如下代码：&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;int count = 0;

while(n != 0)
{
    if(n % 2 == 1)
    {
        count++;
    }
    
    n = n &amp;gt;&amp;gt; 1;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述代码主要做了两个步骤：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;n % 2&lt;/code&gt; 表示对数字求模运算，也就是计算&lt;strong&gt;二进制的末尾&lt;/strong&gt;是 1 还是 0，如果二进制的末尾是 1 ，则 count 自增，count 表示的是二进制表示 1 的个数；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;n = n &amp;gt;&amp;gt; 1&lt;/code&gt; 表示把二进制&lt;strong&gt;往右移走一位&lt;/strong&gt;，比如十进制数字 7 的二进制表示是 111 ，那么通过右移一位后，则变成 011。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这个解决方式虽然能计算出二进制表示 1 的个数，但是我们可以发现这个解法的时间复杂度是 O(logn)，比如当 n 为 7 时，它的二进制表示是 111，那么它将会循环 3 次，也就是非常接近 log 以 2 为底 7 的对数的值。&lt;/p&gt;
&lt;hr/&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;程序读入一个整数 n，假设 n 不会大于 1000，请输出 1 到 n 每个数字的二进制表示 1 的个数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;时间复杂度-onlogn-的解法&quot;&gt;时间复杂度 O(nlogn) 的解法&lt;/h2&gt;
&lt;p&gt;可能有的小伙伴说，这题目二还不简单？直接把上面的解法，增加个 for 循环不就得了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int main() 
{
    int i, j, n, count;
    
    scanf(&quot;%d&quot;, &amp;amp;n);
    
    for(i = 1; i &amp;lt;= n; i++)
    {
        j = i;
        count = 0;
        
        while(j != 0)
        {
            if(j % 2 == 1)
            {
                count++;
            }
    
            j = j &amp;gt;&amp;gt; 1;
        }
        
        printf(&quot;number:%d, count:%d\n&quot;, i, count);
    }

    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;假设输入 7，则输出结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;number:1, count:1
number:2, count:1
number:3, count:2
number:4, count:1
number:5, count:2
number:6, count:2
number:7, count:3
number:8, count:1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;没错，用上述的解法增加个 for 循环，确实可以解决题目二的要求，这值得鼓励，但是程序的时间复杂度是时间复杂度 O(nlogn) ，运行效率不高，所以我们必须要有种精神，就是要用时间复杂度最少的方式去解决算法的问题，这样才能一次一次的进步。&lt;/p&gt;
&lt;h2 id=&quot;时间复杂度-on-的解法&quot;&gt;时间复杂度 O(n) 的解法&lt;/h2&gt;
&lt;p&gt;请先观察下面的&lt;strong&gt;位运算&lt;/strong&gt;性质：&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;y = x &amp;amp; (x - 1)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们看到，&lt;code&gt;x&lt;/code&gt; 和与 &lt;code&gt;x -1&lt;/code&gt; 这两个数字做&lt;strong&gt;按位与&lt;/strong&gt;运算，所以我们要以二进制的角度去思考这个问题。&lt;/p&gt;
&lt;p&gt;比如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;假设 &lt;code&gt;x&lt;/code&gt; 是 3，它的二进制是 011；&lt;/li&gt;
&lt;li&gt;那么 &lt;code&gt;x - 1&lt;/code&gt; 就是 2，它的二进制是 010；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x &amp;amp; (x - 1)&lt;/code&gt; 运算后的二进制就是 010。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;那么 &lt;code&gt;x &amp;amp; (x - 1)&lt;/code&gt; 实际效果等效于去掉 &lt;code&gt;x&lt;/code&gt; 二进制表示中的&lt;strong&gt;最后一位 1&lt;/strong&gt;，从而我们发现原来 &lt;code&gt;y&lt;/code&gt; 变量与 &lt;code&gt;x&lt;/code&gt; 变量在二进制表示中，只差一个 1。&lt;/p&gt;
&lt;p&gt;如果我们用一个数组 &lt;code&gt;f&lt;/code&gt; 记录相应数字二进制表示中 1 的数量，那么 &lt;code&gt;f[i]&lt;/code&gt; 数组存放的值是 &lt;code&gt;i&lt;/code&gt; 这个数字二进制表示中 1 的数量，从而我们可以推导得到 &lt;code&gt;f[i] = f[i &amp;amp; (i - 1)] + 1&lt;/code&gt;，也就是说 &lt;code&gt;i&lt;/code&gt; 数字比 &lt;code&gt;i &amp;amp; (i - 1)&lt;/code&gt; 数字的二进制表示中的 1 的数量要多一个，这样我们通过一步计算就得到 &lt;code&gt;f[i]&lt;/code&gt; 的结果，也就是相应数字二进制表示中 1 的数量结果。&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;int main() 
{
    int n,i;
    int f[1001];
    
    f[0] = 0;
    
    scanf(&quot;%d&quot;, &amp;amp;n);

    for(i = 1; i &amp;lt;= n; i++) 
    {
        f[i] = f[i &amp;amp; (i - 1)] + 1;
    }
    
    for(i = 1; i &amp;lt;= n; i++) 
    {
        printf(&quot;%d &quot;, f[i]);
    }
    printf(&quot;\n&quot;);
    
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个程序的过程如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先先读入一个整数 &lt;code&gt;n&lt;/code&gt;，代表要求解的范围;&lt;/li&gt;
&lt;li&gt;然后循环 &lt;code&gt;n&lt;/code&gt; 次，每一次通过 &lt;code&gt;f[i] = f[i &amp;amp; (i - 1)] + 1&lt;/code&gt; 计算得到 &lt;code&gt;f[i]&lt;/code&gt; 的值，也就是数字的二进制表示 1 的个数;&lt;/li&gt;
&lt;li&gt;最后输出 1 到 &lt;code&gt;n&lt;/code&gt; 中每个数字二进制表示中 1 的个数。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;针对这个解法，程序的时间复杂度是 O(n)。&lt;/p&gt;
</description>
<pubDate>Mon, 20 Jan 2020 16:12:00 +0000</pubDate>
<dc:creator>小林coding</dc:creator>
<og:description>题目一 计算十进制数字在二进制表示 1 的个数 举个例子: 十进制数字为 1 时，它的二进制表示是 001，二进制表示 1 的个数为 1； 十进制数字为 2 时，它的二进制表示是 010，二进制表示</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiaolincoding/p/12219909.html</dc:identifier>
</item>
<item>
<title>kubernetes基础概念知多少 - luoxn28</title>
<link>http://www.cnblogs.com/luoxn28/p/12219845.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/luoxn28/p/12219845.html</guid>
<description>&lt;p&gt;kubernetes（简称k8s）是一种用于在一组主机上运行和协同容器化应用程序的管理平台，皆在提供高可用、高扩展性和可预测性的方式来管理容器应用的生命周期。通过k8s，用户可以定义程序运行方式、部署升级策略、动态伸缩容，使得用户以一种更灵活可靠的方式来管理应用程序。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;关于k8s，是一种对应用服务的打包、部署、监控等一整套生命周期的自动化管理平台，目前各大公司已在生产环境部署使用，同时k8s社区比较活跃，在未来一段时间内会越来越流行，可以说是以后服务部署的事实标准，对于Java开发者来说，你可以不直接使用它，但是不能不了解它。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;总结来看，k8s特点如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;自动装箱&lt;/strong&gt;：基于容器，结合调度策略将多种应用部署到同一节点上，提高资源利用率；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;自我修复&lt;/strong&gt;：支持故障转移/重启，具有健康检查机制；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;水平扩展&lt;/strong&gt;：通过命令手动执行扩容，可基于CPU等资源负载率来动态实现伸缩容；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;服务发现/负载均衡&lt;/strong&gt;：通过KubeDNS（或CoreDNS）为系统内置了服务发现功能，为每个service配置DNS名称，service通过iptables或ipvs内建了负载均衡机制；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;自动部署&lt;/strong&gt;：自动发布和回滚，支持灰度、增量发布等；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;配置管理&lt;/strong&gt;：ConfigMap实现了配置数据与Docker镜像解耦，为开发部署提供了良好的灵活性；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;批处理&lt;/strong&gt;：除了管理服务型应用之外，Kubernetes还支持批处理作业及CI（持续集成）。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;从k8s的角度看，它把各个待管理的资源进行了抽象，比如针对服务器（物理机或者虚拟机）抽象出Node；对于容器不直接管理而是抽象出Pod来管理容器；对于集群内的服务调用，抽象出service来表示同类型的多个Pod，同时提供负载均衡策略等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于初学者来说，k8s的一些抽象资源和基本概念可能会造成一头雾水，本文就k8s的基础概念和组件进行简单分析，让初学者更快了解k8s概念，话不多说，let‘s go~&lt;/p&gt;
&lt;h3 id=&quot;k8s基础概念&quot;&gt;k8s基础概念&lt;/h3&gt;
&lt;p&gt;k8s使用共享网络将多个物理机（或者虚拟机）汇集到一个集群中，该集群是配置k8s所有组件、功能和工作负载的物理平台。集群中一台服务器会作为master负责管理整个集群（为了master高可用一般会将master部署成多节点）。&lt;/p&gt;
&lt;p&gt;Master是集群的网关和中枢，负责诸如为用户和客户端暴露API、跟踪其他服务器的健康状态、以最优方式调度工作负载，以及编排其他组件之间的通信等任务，它是用户/客户端与集群之间的核心联络点，并负责Kubernetes系统的大多数集中式管控逻辑。单个Master节点即可完成其所有的功能，但出于冗余及负载均衡等目的，生产环境中通常需要协同部署多个此类主机。Node是Kubernetes集群的工作节点，负责接收来自Master的工作指令并根据指令相应地创建或销毁Pod对象，以及调整网络规则以合理地路由和转发流量等。理论上讲，Node可以是任何形式的计算设备，不过Master会统一将其抽象为Node对象进行管理。&lt;/p&gt;
&lt;h3 id=&quot;几种资源抽象&quot;&gt;几种资源抽象&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Pod&lt;/strong&gt;：k8s管理的最小调度单元，k8s不直接来管理容器，使用一个抽象的资源对象来封装一个或者多个容器，这个抽象即为Pod。同一Pod中的容器共享网络名称空间和存储资源，这些容器可经由本地回环接口lo直接通信，同时对于Mount、User及PID等资源也进行了隔离；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;标签资源和标签选择器&lt;/strong&gt;：标签（Label）是将资源进行分类的标识符，k8s的Pod资源选择大都是基于标签来的，一个对象可以拥有多个标签，一个标签也可以附加于多个对象（通常是同一类对象）之上。标签选择器（Selector）全称为“Label Selector”，它是一种根据Label来过滤符合条件的资源对象的机制；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Controller&lt;/strong&gt;：Pod控制器，尽管Pod是k8s的最小调度单元，但用户通常并不会直接部署及管理Pod对象，而是要借助于另一类抽象——控制器（Controller）对其进行管理，k8s的控制器包括ReplicationController、ReplicaSet、Deployment、StatefulSet、Job等，每种controller都有对应的功能（比如Deployment是最常见的无状态应用的控制器，它支持应用的扩缩容、滚动更新等操作，为容器化应用赋予了极具弹性的功能）；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Service&lt;/strong&gt;：Service是建立在一组Pod对象之上的资源抽象，它通过标签选择器选定一组Pod对象，并为这组Pod对象定义一个统一的固定访问入口（通常是一个IP地址）；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;存储卷&lt;/strong&gt;：一般是独立于容器文件系统之外的存储空间，常用于扩展容器的存储空间并为它提供持久存储能力，大体上可分为临时卷、本地卷和网络卷；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Name和Namespace&lt;/strong&gt;：名称是网络资源的唯一标识符，通常在一个命名空间内，名称标识是唯一的，名称空间通常用于实现租户或项目的资源隔离，从而形成逻辑分组；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ingress&lt;/strong&gt;：k8s中将Pod进行了网络隔离，如果需要开放一些Pod供外部使用，则需要一个配置一个流量进入k8s集群内的通道，除了Service外，Ingress也是实现策略之一。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;k8s组件&quot;&gt;k8s组件&lt;/h3&gt;
&lt;p&gt;一个典型的k8s集群由master节点、多个工作节点和ETCD组成，其中ETCD作为集群状态存储。master节点负责整个集群的管理工作，为集群提供管理API，并负责编排和监控各工作节点，各工作节点已Pod形式管理运行容器。master主要由apiserver、controller-manager和scheduler三个组件组成，同时负责与ETCD教育存储集群状态数据，而每个工作节点主要包含kubelet、kube-proxy及容器引擎（最常见的是Docker）等组件。各个组件整体如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772134/202001/772134-20200120233814140-804454021.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;master节点&quot;&gt;master节点&lt;/h4&gt;
&lt;p&gt;master包含组件如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;API server&lt;/strong&gt;：对外提供restful api，k8s集群的网关；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Controller&lt;/strong&gt;：Pod控制器，k8s通过控制器来管理Pod资源，控制器包括ReplicationController、ReplicaSet、Deployment、StatefulSet、Job等，每种controller都有对应的功能（比如Deployment是最常见的无状态应用的控制器，它支持应用的扩缩容、滚动更新等操作，为容器化应用赋予了极具弹性的功能）；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Scheduler&lt;/strong&gt;：K8s调度器，K8s管理成千上万容器资源，api server接收到请求之后就由Scheduler按照对应调度策略进行在不同Node间的请求调度操作；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ETCD&lt;/strong&gt;：k8s集群状态都是存储在etcd中（通过API Server共享给集群的各组件及客户端），通过etcd的watch机制来进行k8s各组件的协同操作，一般etcd通过集群部署方式保证高可用。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;node节点&quot;&gt;node节点&lt;/h4&gt;
&lt;p&gt;node节点接受master的管理，负责管理各个Pod资源：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;kubelet&lt;/strong&gt;：kubelet是node的守护进程，node接受master的管控，Kubelet会向api server注册当前node，定期向master会报node资源占用情况；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;容器运行环境&lt;/strong&gt;：node会提供一个容器运行环境，负责下载并运行容器，k8s目前支持的容器运行环境包括Docker、RKT、cri-o和Fraki等；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;kube-proxy&lt;/strong&gt;：每个node都需要一个kube-proxy进程，比如对service按需生成iptables或ipvs规则，控制流量访问。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;核心组件&quot;&gt;核心组件&lt;/h4&gt;
&lt;p&gt;k8s除了etcd、master、node这几个组件之外，还有一些核心组件，如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;DNS服务&lt;/strong&gt;：目前k8s使用的是coreDNS，之前使用的是KubeDNS；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Kubernetes Dashboard&lt;/strong&gt;：k8s的管理web UI；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Heapster&lt;/strong&gt;：容器和节点的性能监控与分析系统，它收集并解析多种指标数据，如资源利用率、生命周期事件等。新版本的Kubernetes中，其功能会逐渐由Prometheus结合其他组件所取代。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ingress Controller&lt;/strong&gt;:Service是一种工作于传统层的负载均衡器，而Ingress是在应用层实现的HTTP（s）负载均衡机制。不过，Ingress资源自身并不能进行“流量穿透”，它仅是一组路由规则的集合，这些规则需要通过Ingress控制器（Ingress Controller）发挥作用。目前，此类的可用项目有Nginx、Traefik、Envoy及HAProxy等。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;推荐阅读&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 20 Jan 2020 15:40:00 +0000</pubDate>
<dc:creator>luoxn28</dc:creator>
<og:description>kubernetes（简称k8s）是一种用于在一组主机上运行和协同容器化应用程序的管理平台，皆在提供高可用、高扩展性和可预测性的方式来管理容器应用的生命周期。通过k8s，用户可以定义程序运行方式、部署</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/luoxn28/p/12219845.html</dc:identifier>
</item>
<item>
<title>JavaScript(1)---绑定事件、解除绑定事件 - 雨点的名字</title>
<link>http://www.cnblogs.com/qdhxhz/p/11999941.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qdhxhz/p/11999941.html</guid>
<description>&lt;center&gt;

&lt;/center&gt;
&lt;h2 id=&quot;一事件概述&quot;&gt;&lt;span&gt;一、事件概述&lt;/span&gt;&lt;/h2&gt;
&lt;h4 id=&quot;事件的几个概念&quot;&gt;1、事件的几个概念&lt;/h4&gt;
&lt;p&gt;· &lt;code&gt;事件&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;指的是文档或者浏览器窗口中发生的一些特定交互瞬间。我们可以通过侦听器（或者处理程序）来预定事件，以便触发事件的时候执行相应的代码。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;事件处理程序&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;我们用户在页面中进行的点击动作(click)、鼠标移动动作(mousemove)等，都可以称之为事件名称。响应某个事件的函数则称为事件处理程序，或者叫做事件侦听器。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;事件类型&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;UI事件&lt;/strong&gt;： load、unload、error、resize、scroll、select，是用户与页面上的元素交互时触发的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;焦点事件&lt;/strong&gt;：blur、DOMFocusIn、DOMFocusOut、focus、focusin、focusout，在元素获得或失去焦点的时候触发，这些事件当中，最为重要的是blur和focus，&lt;/p&gt;
&lt;p&gt;有一点需要引起注意，&lt;strong&gt;这一类事件不会发生冒泡&lt;/strong&gt;！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;鼠标与滚轮事件&lt;/strong&gt;：click、dblclick、mousedown、mouseenter、mouseleave、mousemove、mouseout、mouseover、mouseup，是当用户通过鼠标在页面执行&lt;/p&gt;
&lt;p&gt;操作时所触发的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;滚轮事件&lt;/strong&gt;：mousewheel（IE6+均支持）、DOMMouseScroll（FF支持的，与mousewheel效果一样）。是使用鼠标滚轮时触发的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文本事件&lt;/strong&gt;：textInput，在文档中输入文本触发。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;键盘事件&lt;/strong&gt;：keydown、keyup、keypress，当用户通过键盘在页面中执行操作时触发。&lt;/p&gt;
&lt;h4 id=&quot;事件三要素&quot;&gt;2、事件三要素&lt;/h4&gt;
&lt;p&gt;事件有三要素 : &lt;code&gt;事件源&lt;/code&gt;、&lt;code&gt;事件&lt;/code&gt;、&lt;code&gt;监听器&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;事件源&lt;/strong&gt;：在哪个元素上发生的。比如: p标签、a标签、div标签、form表单 等等&lt;/p&gt;
&lt;p&gt;​ &lt;strong&gt;事件&lt;/strong&gt;：到底发生了什么事件。click(点击事件)、mouseover(鼠标事件)、focus(焦点事件) 等&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;监听器&lt;/strong&gt;：事件源触发事件后，如何回应发生的事件，通常以函数(funtion)的形式来出现。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;注意&lt;/code&gt; 事件不是以 on 开头的那个名称，如 onclick 不是事件，click才是事件。&lt;strong&gt;onclick引用的是一个元素对象的属性&lt;/strong&gt;，它指向click事件类型绑定的实际处理函数。&lt;/p&gt;

&lt;h2 id=&quot;二绑定事件解绑事件&quot;&gt;&lt;span&gt;二、绑定事件、解绑事件&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;常用的事件绑定的几种方式有三种：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1、直接在html元素上进行绑定事件。
2、用 on 绑定事件。
3、用 addEventListener、attachEvent 绑定事件。&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;直接在-html-元素上进行绑定&quot;&gt;1、直接在 html 元素上进行绑定&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;即以属性的方式直接写在行内&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;input id=&quot;btn&quot; type=&quot;button&quot; onclick=&quot;test();&quot; /&amp;gt; &amp;lt;!--点击按钮 触发事件--&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样有个很大的缺点就是：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HTML与js代码紧密耦合。如果要更换 事件，就要改动两个地方:HTML代码和JS代码，这就不利于后期代码的维护&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&quot;用-on-绑定&quot;&gt;2、用 on 绑定&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;兼容性&lt;/code&gt;：在IE，FF，Chrome，Safari，Mozilla，Opera下都适用。&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;body&amp;gt;
  &amp;lt;div id=&quot;id&quot;&amp;gt;on绑定事件&amp;lt;/div&amp;gt;
  &amp;lt;script&amp;gt;
    var div=document.getElementById('id');
    // 甲
    div.onclick=function(){
        console.log('甲需要红背景');
        div.setAttribute('style', 'background: #ff0000');
    };
    // 乙  
    div.onclick=function(){
        console.log('乙需要黄背景');
        div.setAttribute('style', 'background: #ffff00');
    };
    //这里最总只会输出 '乙需要黄背景' 因为用on绑定事件 同一事件下面会覆盖上面的
    div.onclick=null;  //解绑只要事件 = null 就可以了
  &amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;优点&lt;/code&gt;：它最大的优点是就是兼容性很好，所有浏览器都支持。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;缺点&lt;/code&gt;：同一个 dom 元素上，on 只能绑定一个同类型事件，后者会覆盖前者，不同类型的事件可以绑定多个。&lt;/p&gt;
&lt;p&gt;这里就有一个问题，无法允许团队不同人员对同一元素监听同一事件但做出不用的响应。&lt;/p&gt;
&lt;h4 id=&quot;addeventlistenerattachevent-绑定事件&quot;&gt;3、 addEventListener、attachEvent 绑定事件&lt;/h4&gt;
&lt;p&gt;同一个 dom 元素上，用 addEventListener、attachEvent 可以绑定多个同类型事件。&lt;/p&gt;
&lt;p&gt;但是，addEventListener 事件执行顺序按照事件绑定的先后顺序执行；attachEvent 事件执行顺序则是随机的。&lt;/p&gt;
&lt;p&gt;1）&lt;code&gt;addEventListener&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var oBox = document.getElementById(&quot;container&quot;);
//绑定事件
oBox.addEventListener(&quot;click&quot;,fn(),false);
//解绑事件
oBox.removeEventListener(&quot;click&quot;,fn(),false);
function fn(){//执行代码}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;参数说明&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;第一个参数：事件名称 比如onclick  onmouseover
第一个参数：作为事件处理程序的函数
第一个参数：若为false,函数在冒泡阶段执行;若为true,函数在捕获阶段执行。默认为false。(有关冒泡和捕获单独抽时间讲)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：removeEventListener 第二个参数要和 addEventListener 指向 &lt;strong&gt;同一个函数&lt;/strong&gt; 才能解绑成功。&lt;/p&gt;
&lt;p&gt;2）&lt;code&gt;attachEvent&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var oBox = document.getElementById(&quot;container&quot;);
//绑定
oBox.attach(&quot;click&quot;,fn());
//解绑
oBox.detach(&quot;click&quot;,fn());
function fn(){//执行函数}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3）&lt;code&gt;区别&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;总结下 addEventListener、attachEvent的区别&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt; 1)参数个数不一致
   addEventListener三个参数,attachEvent两个参数
 2)兼容问题
   addEventListener 谷歌,火狐,IE11支持,IE8不支持
   attachEvent 谷歌火狐不支持,IE11不支持,IE8支持
 3)this指向不同
   addEventListener 中的this是当前绑定事件的对象
   attachEvent中的this是window
 4)事件命名不同
   addEventListener中事件的类型(事件的名字)没有on
   attachEvent中的事件的类型(事件的名字)有on&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里再说下 addEventListener、attachEvent相对于上面两种绑定事件的优缺点&lt;/p&gt;
&lt;p&gt;&lt;code&gt;优点&lt;/code&gt; 它们可以支持 &lt;strong&gt;绑定多个同类型事件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;缺点&lt;/code&gt; 兼容性并不好,它们只兼容相对应的浏览器才有用。&lt;/p&gt;

&lt;h2 id=&quot;三事件的兼容&quot;&gt;&lt;span&gt;三、事件的兼容&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;上面说了3种绑定事件和解绑事件的方法,如果实际开发中如果只使用一种方法,那么会产生要么无法满足同一元素监听同一事件但做出不用的响应，要么系统的兼容性会有问题。&lt;/p&gt;
&lt;p&gt;所以需要一个兼容的方法。这里举一个完整的例子，包含兼容绑定事件 和 兼容解绑事件 ，也看下解绑的含义是什么。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;完整代码&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
  &amp;lt;title&amp;gt;事件绑定和解绑&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;input type=&quot;button&quot; value=&quot;绑架事件&quot; id=&quot;btn1&quot;/&amp;gt;
&amp;lt;input type=&quot;button&quot; value=&quot;解绑事件&quot; id=&quot;btn2&quot;/&amp;gt;
&amp;lt;script&amp;gt;
  //第一个按钮 同时绑定两个相同事件 执行不同方法
  addEventListener(my$(&quot;btn1&quot;),&quot;click&quot;,f1);
  addEventListener(my$(&quot;btn1&quot;),&quot;click&quot;,f2);
  //第二个按钮点击后 让第一个按钮第一个事件解绑
  my$(&quot;btn2&quot;).onclick=function () {
    removeEventListener(my$(&quot;btn1&quot;),&quot;click&quot;,f1);
  };

    function f1() {
    alert(&quot;第一个事件&quot;);
  }
   function f2() {
    alert(&quot;第二个事件&quot;);
  }

function my$(id) {
    return document.getElementById(id);
}

  //绑定事件的兼容
  function addEventListener(element,type,fn) {
    if(element.addEventListener){ //有没有用
      element.addEventListener(type,fn,false);
    }else if(element.attachEvent){ //有没有用
      element.attachEvent(&quot;on&quot;+type,fn);
    }else{ //如果都不兼容 那就用这种来绑定事件
      element[&quot;on&quot;+type]=fn;
    }
  }
  //解绑事件的兼容
  function removeEventListener(element,type,fnName) {
    if(element.removeEventListener){
      element.removeEventListener(type,fnName,false);
    }else if(element.detachEvent){
      element.detachEvent(&quot;on&quot;+type,fnName);
    }else{
      element[&quot;on&quot;+type]=null;
    }
  }

&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;运行结果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201912/1090617-20191206222709557-1141478635.gif&quot; width=&quot;“700&amp;quot;&quot; height=&quot;160&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从运行结果我们很明显可以得出的结论:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1、一开始绑定事件的按钮 绑定了两个相同的事件。并且发现并没有发生事件覆盖，都成功了。
2、当点击解绑按钮后,它解绑是绑定按钮的第一个事件。
3、此时再点击绑定事件的按钮，发现只绑定了一个事件，因为另一个事件已经被解绑了。&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;参考&quot;&gt;&lt;span&gt;参考&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;1、&lt;a href=&quot;https://blog.csdn.net/qzt1204/article/details/80503788&quot;&gt;JS中几种绑定事件的方式&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2、&lt;a href=&quot;https://www.jianshu.com/p/da466e181e33&quot;&gt;JS事件绑定的常用方式实例总结&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3、&lt;a href=&quot;https://www.jianshu.com/p/8e78cb036b69&quot;&gt;javascript 中的事件机制&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;你如果愿意有所作为，就必须有始有终。(20)&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 20 Jan 2020 14:43:00 +0000</pubDate>
<dc:creator>雨点的名字</dc:creator>
<og:description>JavaScript(1) 绑定事件、解除绑定事件 一、事件概述 1、事件的几个概念 &amp;#183; 指的是文档或者浏览器窗口中发生的一些特定交互瞬间。我们可以通过侦听器（或者处理程序）来预定事件，以便</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qdhxhz/p/11999941.html</dc:identifier>
</item>
<item>
<title>AVR单片机教程——定时器中断 - jerry_fuyi</title>
<link>http://www.cnblogs.com/jerry-fuyi/p/12207891.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jerry-fuyi/p/12207891.html</guid>
<description>&lt;p&gt;本文隶属于&lt;a href=&quot;https://www.cnblogs.com/jerry-fuyi/p/avr_tutorial.html&quot; target=&quot;_blank&quot;&gt;AVR单片机教程&lt;/a&gt;系列。&lt;/p&gt;

&lt;p&gt;中断，是单片机的精华。&lt;/p&gt;
&lt;h3 id=&quot;中断基础&quot;&gt;中断基础&lt;/h3&gt;
&lt;p&gt;当一个事件发生时，CPU会停止当前执行的代码，转而处理这个事件，这就是一个中断。&lt;strong&gt;触发&lt;/strong&gt;中断的事件成为&lt;strong&gt;中断源&lt;/strong&gt;，处理事件的函数称为&lt;strong&gt;中断服务程序&lt;/strong&gt;（ISR）。&lt;/p&gt;
&lt;p&gt;中断在单片机开发中有着举足轻重的地位——没有中断，很多功能就无法实现。比如，在程序干别的事时接受UART总线上的输入，而&lt;code&gt;uart_scan_char&lt;/code&gt;等函数只会接收调用该函数后的输入，先前的则会被忽略。利用中断，我们可以在每次接受到一个字节输入时把数据存放到缓冲区中，程序可以从缓冲区中读取已经接收的数据。&lt;/p&gt;
&lt;p&gt;AVR单片机支持多种中断，包括外部引脚中断、定时器中断、总线中断等。每一个中断被触发时，通过&lt;strong&gt;中断向量表&lt;/strong&gt;跳转到对应ISR。如果一个中断对应的ISR不存在，链接器会把复位地址放在那里，如果这个中断被响应程序就会复位（但单片机不会复位）。&lt;/p&gt;
&lt;p&gt;那么，我们以前从未写过ISR，但经常改变引脚电平，为什么没有复位呢？因为中断默认是不开启的。要启用一个中断，需要让两个位于不同寄存器中的位为&lt;code&gt;1&lt;/code&gt;，一个是中断对应的中断使能位，每个中断都有各自的位，另一个是全局中断使能位，位于寄存器&lt;code&gt;SREG&lt;/code&gt;中，不能直接存取，需要通过定义在&lt;code&gt;&amp;lt;avr/interrupt.h&amp;gt;&lt;/code&gt;头文件中的&lt;code&gt;sei()&lt;/code&gt;函数开全局中断，相对地，&lt;code&gt;cli()&lt;/code&gt;用于关全局中断。&lt;/p&gt;
&lt;p&gt;先来写第一个带中断的程序吧。从原理图中可以看到，&lt;code&gt;PB2&lt;/code&gt;旁边标明了&lt;code&gt;INT2&lt;/code&gt;，表示&lt;code&gt;PB2&lt;/code&gt;引脚可用于外部中断2。把一个按键连接到&lt;code&gt;PB2&lt;/code&gt;引脚上，即开发板最下方的7P排母的最右边。利用中断，我们实现每按一次按键就翻转LED状态的功能。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;avr/io.h&amp;gt;
#include &amp;lt;avr/interrupt.h&amp;gt;

int main()
{
    PORTB |=    1 &amp;lt;&amp;lt; PORTB2;
    EICRA |= 0b10 &amp;lt;&amp;lt; ISC20;
    EIMSK |=    1 &amp;lt;&amp;lt; INT2;
    DDRC  |=    1 &amp;lt;&amp;lt; DDC4;
    sei();
    while (1)
        ;
}

ISR(INT2_vect)
{
    PORTC ^= 1 &amp;lt;&amp;lt; PORTC4;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ISC21:0&lt;/code&gt;两位指定外部中断的类型，这里设置为下降沿，即按键按下时触发；&lt;code&gt;INT2&lt;/code&gt;位使能外部中断2；全部初始化完成后，&lt;code&gt;sei()&lt;/code&gt;启用全局中断，然后单片机就会相应按键按下的事件了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ISR(INT2_vect)&lt;/code&gt;指示这个函数是外部中断2的ISR。每个中断ISR都有自己的名字，由数据手册12章&lt;code&gt;Source&lt;/code&gt;一栏的内容加上&lt;code&gt;_vect&lt;/code&gt;组成，这个名字可以当成函数名字来使用。&lt;/p&gt;
&lt;p&gt;如果多个中断同时触发，单片机会先响应优先级高的。一些单片机支持自定义的优先级，但在AVR单片机中，只有简单的地址低的优先级高的规则。&lt;/p&gt;
&lt;p&gt;中断可以被中断吗？在AVR单片机中，执行一个中断处理函数会自动地关闭全局中断，此时程序不会被中断，但可以手动地&lt;code&gt;sei()&lt;/code&gt;使中断可以被处理。程序是否相应中断仅取决于该中断是否被启用，与其优先级无关。&lt;/p&gt;
&lt;p&gt;当然，中断不是完美的。其一，你也许已经发现上面的程序不能很好的工作，有时候明明按下了按键，灯却一闪就灭。这是因为，按键存在抖动，比单片机时钟周期长，能触发多个中断。以前把&lt;code&gt;button_down()&lt;/code&gt;放在&lt;code&gt;main&lt;/code&gt;函数的&lt;code&gt;while&lt;/code&gt;循环里时就没有这个问题，正是循环中的&lt;code&gt;delay&lt;/code&gt;滤除了这种抖动。&lt;/p&gt;
&lt;p&gt;其二，进入和退出中断，除了需要CPU几个周期来改变PC（程序计数器，当前执行指令的地址）外，还需要保护和恢复现场，包括&lt;code&gt;SREG&lt;/code&gt;寄存器与ISR中用到的通用寄存器。下面这段汇编代码可以在&lt;code&gt;Solution Explorer&lt;/code&gt;中&lt;code&gt;Output Files\xxx.lss&lt;/code&gt;中找到。&lt;/p&gt;
&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt;00000094 &amp;lt;__vector_3&amp;gt;:
#include &amp;lt;avr/io.h&amp;gt;
#include &amp;lt;avr/interrupt.h&amp;gt;
ISR(INT2_vect)
{
  94:   1f 92           push    r1
  96:   0f 92           push    r0
  98:   0f b6           in  r0, 0x3f    ; 63
  9a:   0f 92           push    r0
  9c:   11 24           eor r1, r1
  9e:   8f 93           push    r24
  a0:   9f 93           push    r25
    PORTC ^= 1 &amp;lt;&amp;lt; PORTC4;
  a2:   98 b1           in  r25, 0x08   ; 8
  a4:   80 e1           ldi r24, 0x10   ; 16
  a6:   89 27           eor r24, r25
  a8:   88 b9           out 0x08, r24   ; 8
}
  aa:   9f 91           pop r25
  ac:   8f 91           pop r24
  ae:   0f 90           pop r0
  b0:   0f be           out 0x3f, r0    ; 63
  b2:   0f 90           pop r0
  b4:   1f 90           pop r1
  b6:   18 95           reti&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码不必理解，更不用会写。&lt;code&gt;94&lt;/code&gt;到&lt;code&gt;a0&lt;/code&gt;行是保护现场，依次将寄存器&lt;code&gt;r1&lt;/code&gt;、&lt;code&gt;r0&lt;/code&gt;、&lt;code&gt;SREG&lt;/code&gt;（即&lt;code&gt;0x3f&lt;/code&gt;）、&lt;code&gt;r24&lt;/code&gt;和&lt;code&gt;r25&lt;/code&gt;push进栈，把&lt;code&gt;r1&lt;/code&gt;清零，一共用了12个周期，还要加上响应中断的4个周期；&lt;code&gt;a2&lt;/code&gt;到&lt;code&gt;a8&lt;/code&gt;是恢复现场，把这些寄存器原来的值逆序地从栈上pop出来，用了15个周期；而只有中间&lt;code&gt;aa&lt;/code&gt;到&lt;code&gt;b6&lt;/code&gt;的语句是用于执行用户代码的，在总共35个周期中只占4个周期。&lt;/p&gt;
&lt;p&gt;当然，这个比例很小是因为这个ISR过于简单。但是，ISR更复杂也意味着有更多寄存器需要push和pop，中断的响应时间更长。&lt;/p&gt;
&lt;p&gt;这个例子并没有中断效率低下的意思，而是表明不能过于频繁地依赖中断。比如接下来要讲的定时器中断，我通常设置为1ms间隔，只有一次到0.1ms，再快恐怕就起不到定时的作用了。&lt;/p&gt;
&lt;h3 id=&quot;定时器中断&quot;&gt;定时器中断&lt;/h3&gt;
&lt;p&gt;定时器，顾名思义，定时用的。之前我们在&lt;code&gt;main&lt;/code&gt;函数的&lt;code&gt;while (1)&lt;/code&gt;循环中，每个周期执行一些代码，然后延时一个固定的时长。我也曾见过根据该次周期的工作量来计算延时时长的操作，但毕竟写BASIC的人学得也basic吧，这种做法的定时仍不精确。利用定时器中断（其实不必中断），我们可以实现精确的定时，使每一周期的时间严格相同。&lt;/p&gt;
&lt;p&gt;如果对操作系统有一点了解，就会知道操作系统需要进行任务调度。然而，任务在执行时，并不知道自己该何时被调度走。实际上，是操作系统在定时器中断中打断了任务的正常执行，然后进行调度。定时器中断是操作系统的基础。&lt;/p&gt;
&lt;p&gt;在AVR单片机定时器的各种模式中，普通模式和CTC模式常用于产生定时器中断。我们仍然以定时/计数器0为例。&lt;/p&gt;
&lt;p&gt;在普通模式中，使用&lt;code&gt;TIMER0_OVF&lt;/code&gt;中断，频率为&lt;span class=&quot;math inline&quot;&gt;\(\frac {f_{CPU}} {256 \cdot N}\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(N\)&lt;/span&gt;为分频系数。这样产生的定时器中断精确但不确切，因为&lt;code&gt;N&lt;/code&gt;的取值是很离散的。如果只需要在中断中进行外设轮询的话，普通模式就足够了。&lt;/p&gt;
&lt;p&gt;如果在ISR的第一行就给&lt;code&gt;TCNT0&lt;/code&gt;赋值，或是使用&lt;code&gt;TIMER0_COMPA&lt;/code&gt;中断并在起始处写&lt;code&gt;TCNT0 = 0&lt;/code&gt;，那么可以改变中断频率，但由于有编译器插入的保护现场的代码的存在，这种定时不够精确，而CTC模式解决了这个问题。&lt;/p&gt;
&lt;p&gt;在CTC模式中，使用&lt;code&gt;TIMER0_COMPA&lt;/code&gt;中断，频率精确地为&lt;span class=&quot;math inline&quot;&gt;\(\frac {f_{CPU}} {N \cdot (OCR0A + 1)}\)&lt;/span&gt;（注意没有蜂鸣器频率公式中的&lt;span class=&quot;math inline&quot;&gt;\(2\)&lt;/span&gt;）。&lt;/p&gt;
&lt;p&gt;还需要提醒一句，如果想要中断被响应，必须保证&lt;code&gt;main&lt;/code&gt;函数不退出，因为编译器会在退出处加上一句&lt;code&gt;cli()&lt;/code&gt;。最简单的方法是在&lt;code&gt;main&lt;/code&gt;函数的最后加上一句&lt;code&gt;while (1);&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;后台动态扫描&quot;&gt;后台动态扫描&lt;/h3&gt;
&lt;p&gt;数码管的动态扫描需要每隔一段时间就换一位点亮是一件很烦人的事，尤其是在操控其他外设的程序已经比较复杂的时候。我本来想把中断完美地拖到第二期再讲，没想到自己也受不了动态扫描的折磨，在某个版本的库中就放出了&lt;code&gt;segment_auto&lt;/code&gt;函数来接管这项工作。它正是使用了定时器中断。&lt;/p&gt;
&lt;p&gt;实现思路很简单，把要显示的数据放在客户和库可以共同取用的变量中，在中断里逐位显示，只要中断够快，就可以实现动态扫描，使每一位看起来都在亮。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;avr/io.h&amp;gt;
#include &amp;lt;avr/interrupt.h&amp;gt;
#include &amp;lt;ee1/segment.h&amp;gt;

void segment_int_init()
{
    // other initializations, ex. pins
    TCCR0A = 0b10 &amp;lt;&amp;lt; WGM00; // CTC mode
    TCCR0B = 0b0 &amp;lt;&amp;lt; WGM02 | 0b100 &amp;lt;&amp;lt; CS00; // divide by 256
    OCR0A = 97; // ~1ms
    TIMSK0 = 1 &amp;lt;&amp;lt; OCIE0A; // compare match A interrupt
    sei();
}

static uint8_t segment_int_data[SEGMENT_DIGIT_COUNT];

void segment_int_display(/* ... */)
{
    // store the display pattern in segment_int_data
}

ISR(TIMER0_COMPA_vect)
{
    static uint8_t cur = 0;
    // display the cur-th digit according to segment_int_data
    if (++cur == SEGMENT_DIGIT_COUNT)
        cur = 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果你把以上代码放在可执行程序的项目中，那完全没有问题，但如果是放在一个静态库项目中，然后在可执行程序项目中引用它，那么定时器中断的ISR是不会链接进程序的。这是因为，从链接器的角度来讲，这个ISR从来没有被调用过，因此就被当成无用的函数扔掉了。为了让链接器把ISR链接进程序，我们需要在&lt;code&gt;main&lt;/code&gt;会执行的代码中调用它，最简单地：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if (0)
    TIMER0_COMPA_vect();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;放在初始化中，既达到了目的，又没有运行时的负担。&lt;/p&gt;
&lt;h3 id=&quot;作业&quot;&gt;作业&lt;/h3&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;试着写一个库，管理开发板引出的16个引脚的外部中断。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;研究定时器中断与PWM的关系。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;改进ADC一讲中最后一个例程，把&lt;code&gt;main&lt;/code&gt;函数还给客户。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Mon, 20 Jan 2020 14:36:00 +0000</pubDate>
<dc:creator>jerry_fuyi</dc:creator>
<og:description>本文隶属于AVR单片机教程系列。 中断，是单片机的精华。 中断基础 当一个事件发生时，CPU会停止当前执行的代码，转而处理这个事件，这就是一个中断。 触发 中断的事件成为 中断源 ，处理事件的函数称为</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jerry-fuyi/p/12207891.html</dc:identifier>
</item>
<item>
<title>【python系统学习06】一张图看懂列表并学会操作 - xing.org1^</title>
<link>http://www.cnblogs.com/padding1015/p/12219661.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/padding1015/p/12219661.html</guid>
<description>&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://xingorg1.github.io/xingorg1Note/backEnd/python/06-list.html&quot;&gt;点击跳转-原文地址&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;目录:&lt;/strong&gt;&lt;/p&gt;


&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一张图了解列表&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先来一个脑图，一目了然&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你看图看不懂我简写的是啥意思，可以看图下的详细信息。&lt;/p&gt;
&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/0fe57684-e5c3-4419-adfa-61cd48f5e3b9.png&quot; alt=&quot;列表知识点脑图&quot;/&gt;列表知识点脑图
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;列表是什么&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;列表是一堆元素的汇总，长得和JS中的数组一样。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它是数据类型的一种：&lt;code&gt;复杂数据类型&lt;/code&gt;— —就是各种数据类型的集合&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们通常用列表+循环的方式来遍历多个元素。学习它很重要。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;列表长啥样&lt;/span&gt;&lt;/h2&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;语法格式&lt;/span&gt;&lt;/h3&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;
列表变量名 = [ 元素&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, 元素&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, ...后边可以有多个无数个元素 ]
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;代码示例&lt;/span&gt;&lt;/h3&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;br/&gt;myName = [&lt;span class=&quot;hljs-string&quot;&gt;'小石头'&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;'xing.org1^'&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;181&lt;/span&gt;, &lt;span class=&quot;hljs-literal&quot;&gt;True&lt;/span&gt;] 
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;格式特征&lt;/span&gt;&lt;/h3&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;列表名是我自定义的，如示例中我的“myName”。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;用等号给变量赋值，等号右边的就是列表。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;列表中各元素需要用中括号包裹&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;中括号里可以包裹N多个元素&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;多个元素之间用英文逗号分割开&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;列表中的各个元素的类型可以是任何值&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;列表定义&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;定义一个列表&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;myName = [&lt;span class=&quot;hljs-string&quot;&gt;'小石头'&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;'xing.org1^'&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;181&lt;/span&gt;, &lt;span class=&quot;hljs-literal&quot;&gt;True&lt;/span&gt;]
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;列表操作 - 提取单个：偏移量&lt;/span&gt;&lt;/h2&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;什么是偏移量&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;偏移量（又叫 下标）就是每个元素的编号，从左边第一个元素开始，编号从0一直到正无穷。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我习惯叫“下标”。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;​上例中，0就是偏移量。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过偏移量来对列表进行索引（可理解为搜索定位），进而获取我们所需的元素。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;偏移量提取示例&lt;/span&gt;&lt;/h3&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;print(myName[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;])   
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;偏移量值的大小&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当偏移量的值是小于或等于“列表长度-1”的话，我们用偏移量获取列表中的元素，则返回的是列表中我们想要的这个元素。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;print(myName[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;])   
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但当偏移量大于“列表长度-1”时，将会报错&lt;code&gt;IndexError: list index out of range&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;print(myName[&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;]) 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;报错效果如下图：&lt;/p&gt;
&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/54171733-24cd-47c8-b582-275e19863459.png&quot; alt=&quot;IndexError错误&quot;/&gt;IndexError错误
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;偏移量提取的结果&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结果是列表内的一个元素，数据类型取决于提取出来的那个元素是什么类型的。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;列表操作 - 提取多个：切片&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;提取列表中的一个甚至多个元素用切片。具体切片是啥，见下边。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;切片简介&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;写法上就是一个英文冒号，有时候左右会有数字，数字表示偏移量。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用冒号来截取列表元素的操作叫作切片。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;切片示例&lt;/span&gt;&lt;/h3&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;print(myName[:]) &lt;br/&gt;print(myName[&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;:]) &lt;br/&gt;print(myName[:&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;]) &lt;br/&gt;print(myName[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;]) 
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;切片作用&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;是将列表中的一个或多个元素选中。选出来的可以是一个片段里的元素，所以会叫“切片”。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;冒号&lt;/code&gt;搭配上&lt;code&gt;列表名&lt;/code&gt;和&lt;code&gt;中括号&lt;/code&gt;，就能将元素提取出来。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;切片选中规则&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、冒号左边为空没有数字的话，就从列表的第一个元素开始截取，即偏移量从0开始取。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、冒号右边为空没有数字的话，就一直取到列表的最后一个元素。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3、对于左边的数字，切片时是包含关系。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4、而对于右边的数字，切片时不会包括，会切到右边数字的前一个。当然，如果右边没有数字，会切到最后一个。 比如说，你想切出来下标(偏移量)为2的元素，那么右边的数字就应该填3。因为他不会切3，而是切到3的前一个。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;切片提取的结果&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;提取的结果是一个列表。可以理解为拷贝了list中的一段出来，然后放到了一个新的列表里。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;列表操作 - 增加：append()&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;向列表中增加一个元素用append，append是一个函数。用法使用列表调用即可。如下：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;
列表变量名.append(参数)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;append参数&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、&lt;strong&gt;参数类型&lt;/strong&gt;：不限。可以是字符串、数字这样的单个元素，也可以是列表、字典这样的集合元素。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、&lt;strong&gt;参数个数&lt;/strong&gt;：一个，且必须填一个。如果多填或不填都会报&lt;code&gt;TypeError&lt;/code&gt;错误。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;myName.append() 

&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;append作用&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;append&lt;code&gt;会把参数追加到列表的末尾&lt;/code&gt;。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;增加内容后，列表的长度就会加一，增加的元素就会放在列表的末尾位置。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;myName.append(&lt;span class=&quot;hljs-string&quot;&gt;''&lt;/span&gt;)
print(myName) 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个空串被追加到了列表myName的末尾，成为最后一个元素。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;列表操作 - 删除：del()&lt;/span&gt;&lt;/h2&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;del参数&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;参数个数&lt;/strong&gt;：可1个，也可多个。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;删除单个：偏移量&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;写法如下&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;del&lt;/span&gt;(myName[&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;]) 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;填写你要删除元素所在列表内的偏移量到中括号中。用列表名[偏移量]的方式获取这个元素，然后当作参数传到del函数内当作参数即可将该元素从列表中删除。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上例中，偏移量3代表myName中的第四个元素“True”，用中括号+偏移量的方式提取出来后，再用del删除了。此时再打印myName发现“True”不在了。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;隔段删除(多个元素)：偏移量&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;发现了个有趣的例子，如下：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;myName.append(&lt;span class=&quot;hljs-string&quot;&gt;''&lt;/span&gt;)
print(myName)

&lt;span class=&quot;hljs-keyword&quot;&gt;del&lt;/span&gt;(myName[&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;])
print(myName)

&lt;span class=&quot;hljs-keyword&quot;&gt;del&lt;/span&gt;(myName[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;],myName[&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;])
print(myName)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;三个打印结果分别如下：&lt;/p&gt;
&lt;blockquote data-tool=&quot;mdnice编辑器&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span&gt;“&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;['小石头', 'xing.org1^', 181, True, '']&lt;/p&gt;
&lt;span&gt;”&lt;/span&gt;&lt;/blockquote&gt;
&lt;blockquote data-tool=&quot;mdnice编辑器&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;“&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;['小石头', 'xing.org1^', 181, True]&lt;/p&gt;
&lt;span&gt;”&lt;/span&gt;&lt;/blockquote&gt;
&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;p&gt;&lt;span&gt;“&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;['小石头', 181]&lt;/p&gt;
&lt;span&gt;”&lt;/span&gt;&lt;/blockquote&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一个和第二个的打印，应该没有问题，&lt;code&gt;myName.append('')&lt;/code&gt;往list后边增加了一个，空串成为偏移量为4所对应的元素。然后又&lt;code&gt;del(myName[4])&lt;/code&gt;删除了第四个元素，所以打印第二行的内容和原来没增加前的myName又一样了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是第二个del我写的是&lt;code&gt;del(myName[1],myName[2])&lt;/code&gt;，填写了两个参数，我希望删除“xing.org1^”和“181”这俩。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结果发现，删除的是“xing.org1^”和“True”。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我猜测它是先从“['小石头', 'xing.org1^', 181, True]”中删除第1个即“xing.org1^”。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之后列表变成“['小石头', 181, True]”，此时他再删除第2个，也就是“True”。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后剩下了我们看到的打印结果：“['小石头', 181]”。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;看来我们即使一次性向del中传递多个参数，他也是一个一个执行的。并且后一个参数删除是在前一个参数删除执行结果的基础上再做的工作。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;删除片段(多个元素)：切片&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/padding1015/p/12219661.html#切片选中规则&quot;&gt;切片选中规则&lt;/a&gt;见上。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;切片删除同偏移量一个原理。切片选中的片段被当作参数传递到del中，都会被删除。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以直接看三个示例如下：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;del&lt;/span&gt;(myName[:&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;]) 
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;del&lt;/span&gt;(myName([&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;:])) 
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;del&lt;/span&gt;(myName([&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;])) 
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;删除整个：切片&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用切片删除所有选中元素&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;del&lt;/span&gt;(myName[:]) 
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;删除整个：变量名&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;del参数为变量名，则删除整个list列表。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;del&lt;/span&gt;(myName) 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;⚠️myName被删除后，就不存在了，再访问就会报“&lt;a href=&quot;https://xingorg1.github.io/xingorg1Note/backEnd/python/03-errorType.html#nameerror-name-xingorg1-is-not-defined&quot;&gt;未定义&lt;/a&gt;”的错。&lt;/p&gt;
&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;em&gt;以上，就是关于列表的一些知识点，不够完善我今后继续补充，希望对看到的你我有点帮助。&lt;/em&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 20 Jan 2020 14:35:00 +0000</pubDate>
<dc:creator>xing.org1^</dc:creator>
<og:description>先来一个脑图，让你对list列表一目了然  如果你看图看不懂我简写的是啥意思，可以看图下的详细信息。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/padding1015/p/12219661.html</dc:identifier>
</item>
</channel>
</rss>