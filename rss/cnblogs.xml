<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>MySQL 查询重复数据，删除重复数据保留id最小的一条作为唯一数据 - 追逐时光</title>
<link>http://www.cnblogs.com/Can-daydayup/p/10454336.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Can-daydayup/p/10454336.html</guid>
<description>&lt;h2&gt;开发背景：&lt;/h2&gt;
&lt;p&gt;　　最近在做一个批量数据导入到MySQL数据库的功能，从批量导入就可以知道，这样的数据在插入数据库之前是不会进行重复判断的，因此只有在全部数据导入进去以后在执行一条语句进行删除，保证数据唯一性。&lt;/p&gt;
&lt;h2&gt;实战：&lt;/h2&gt;
&lt;h3&gt;表结构如下图所示：&lt;/h3&gt;
&lt;p&gt;表明：brand&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1336199/201903/1336199-20190301005259938-895643143.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;操作：&lt;/h3&gt;
&lt;h4&gt;使用SQL语句查询重复的数据有哪些：&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
SELECT * &lt;span&gt;from&lt;/span&gt;&lt;span&gt; brand WHERE brandName IN(
&lt;/span&gt;&lt;span&gt;select&lt;/span&gt; brandName &lt;span&gt;from&lt;/span&gt; brand GROUP BY brandName HAVING COUNT(brandName)&amp;gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt; #条件是数量大于1的重复数据
)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;使用SQL删除多余的重复数据，并保留Id最小的一条唯一数据：&lt;/h4&gt;
&lt;h4&gt;注意点：&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
错误SQL：DELETE FROM brand WHERE brandName IN (&lt;span&gt;select&lt;/span&gt; brandName &lt;span&gt;from&lt;/span&gt; brand GROUP BY brandName HAVING COUNT(brandName)&amp;gt;&lt;span&gt;1&lt;/span&gt;) &lt;br/&gt;AND Id NOT IN (&lt;span&gt;select&lt;/span&gt; MIN(Id) &lt;span&gt;from&lt;/span&gt; brand GROUP BY brandName HAVING COUNT(brandName)&amp;gt;&lt;span&gt;1&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;提示： You can't specify target table 'brand' for update in FROM clause   不能为FROM子句中的更新指定目标表“brand”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;原因是：不能将直接查处来的数据当做删除数据的条件，我们应该先把查出来的数据新建一个临时表，然后再把临时表作为条件进行删除功能&lt;/p&gt;
&lt;h4&gt;正确SQL写法：&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 DELETE FROM brand WHERE brandName IN (SELECT brandName FROM (SELECT brandName FROM brand GROUP BY brandName HAVING COUNT(brandName)&amp;gt;&lt;span&gt;1&lt;/span&gt;) e)&lt;br/&gt;AND Id NOT IN (SELECT Id FROM (SELECT MIN(Id) AS Id FROM brand GROUP BY brandName HAVING COUNT(brandName)&amp;gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;) t)
&lt;br/&gt;#查询显示重复的数据都是显示最前面的几条，因此不需要查询是否最小值&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;结果如下图：&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1336199/201903/1336199-20190301010940242-1791159980.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;总结：&lt;/h2&gt;
&lt;p&gt;         很多东西都是需要自己一步一步的去探究的，当然网上的建议也是非常宝贵的借鉴和资源，无论做什么开发我们都需要理解它的工作原理才能够更好的掌握它。&lt;/p&gt;

</description>
<pubDate>Thu, 28 Feb 2019 17:12:00 +0000</pubDate>
<dc:creator>追逐时光</dc:creator>
<og:description>开发背景： 最近在做一个批量数据导入到MySQL数据库的功能，从批量导入就可以知道，这样的数据在插入数据库之前是不会进行重复判断的，因此只有在全部数据导入进去以后在执行一条语句进行删除，保证数据唯一性</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Can-daydayup/p/10454336.html</dc:identifier>
</item>
<item>
<title>AOP 技术原理——代理模式全面总结 - dashuai的博客</title>
<link>http://www.cnblogs.com/kubixuesheng/p/5183782.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kubixuesheng/p/5183782.html</guid>
<description>&lt;p&gt;非常重要的一个设计模式，也很常见，很多框架都有它的影子。定义就不多说了。两点：&lt;/p&gt;
&lt;p&gt;1、为其它对象提供一个代理服务，间接控制对这个对象的访问，联想 Spring 事务机制，在合适的方法上加个 transaction 注解，就分分钟实现了事务。&lt;/p&gt;
&lt;p&gt;2、除了1，代理对象还能充当中介的角色。&lt;/p&gt;

&lt;p&gt;如果希望不给原有对象附加太多的责任（和本对象无关的冗余代码），但是还想能为其实现新功能，那么代理模式就是做这个的。还是联系 Spring 事务机制，很好的应用场景。&lt;/p&gt;
&lt;p&gt;实际生活里，可以联系租房，大家租房一般都会找中介，这个中介就是代理对象的角色，它解耦（分离）了房东的一部分责任，因为房东太忙了，或者房东不屑于做这些事情，故交给代理对象去做。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一句话：解耦合，提高扩展性&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;顾名思义，代理类被显示的指定了，即代理在代码里被写死了。实现最简单，也很少用，但是能帮助快速理解思想&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; StaticProxy {
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; dosth();
}
&lt;/span&gt;&lt;span&gt;//////////////&lt;/span&gt;&lt;span&gt;接下来是很熟悉的做法，实现这个借口&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; RealRole &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; StaticProxy {

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; dosth() {
        System.out.println(&lt;/span&gt;&quot;do sth&quot;&lt;span&gt;);
    }
}
&lt;/span&gt;&lt;span&gt;//////////&lt;/span&gt;&lt;span&gt;/然后重要的角色——代理类，联系 Spring 事务机制&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ProxyRole &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; StaticProxy {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; StaticProxy staticProxy;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ProxyRole() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.staticProxy = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RealRole();
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; dosth() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 真正业务逻辑之前的处理，比如加上事务控制&lt;/span&gt;
&lt;span&gt;        before();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.staticProxy.dosth(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 真正的业务逻辑处理，比如数据库的 crud&lt;/span&gt;
        after(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 善后处理，比如，事务提交&lt;/span&gt;
&lt;span&gt;    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; after() {
        System.out.println(&lt;/span&gt;&quot;after dosth&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; before() {
        System.out.println(&lt;/span&gt;&quot;before dosth&quot;&lt;span&gt;);
    }
}
&lt;/span&gt;&lt;span&gt;////////&lt;/span&gt;&lt;span&gt;执行&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ProxyMain {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        StaticProxy staticProxy &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ProxyRole();
        staticProxy.dosth();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印==============&lt;/p&gt;
&lt;p&gt;before dosth&lt;br/&gt;do sth&lt;br/&gt;after dosth&lt;/p&gt;
&lt;p&gt;如上就是最简单的静态代理模式的实现，很直观，就是使用委托的思想，把责任转移到被代理的对象上，代理类实现非业务相关的功能&lt;/p&gt;
&lt;h2&gt;缺陷&lt;/h2&gt;
&lt;p&gt;静态代理非常简单，但是它的缺陷也是显然的，因为静态代理的代理关系在 IDE 编译时就确定了，如果接口改变了，不仅实现类要改变，代理类也要改变，代理类和接口之间的耦合非常严重。&lt;/p&gt;

&lt;p&gt;和静态代理相反，代理类不是写死的，而是动态的创建。又分为两种实现方案：&lt;/p&gt;
&lt;h2&gt;基于 JDK实现&lt;/h2&gt;
&lt;p&gt;也很简单，就是利用 Java 的 API 来实现代理类，即我们不用自己写代理类了，也就是上面例子里的类——ProxyRole。到这里，其实也能猜出来，本质就是利用 Java 的反射机制在程序运行期动态的创建接口的实现类，并生产代理对象而已，如此一来，就能避免实现的接口——StaticProxy 改变了，导致代理类也跟着变的场景发生。下面看实现代码：&lt;/p&gt;
&lt;p&gt;首先写好需要实现的接口，和具体实现类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; DynamicProxy {
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; dosth();
}
&lt;/span&gt;&lt;span&gt;////////////
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DynamicRealRole &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; DynamicProxy {
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; dosth() {
        System.out.println(&lt;/span&gt;&quot;do sth&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后，要实现 JDK 的一个接口——InvocationHandler，Java 的动态代理机制中，有两个重要的类，一个是 InvocationHandler 接口，一个是 Proxy 类。&lt;/p&gt;
&lt;p&gt;注意，DynamicProxyRole 不是代理类，代理类我们不需要自己写，它是 JDK 动态生成给我们的（反射机制）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DynamicProxyRole &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; InvocationHandler {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Object object; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 被代理的对象&lt;/span&gt;

    &lt;span&gt;public&lt;/span&gt; DynamicProxyRole(Object object) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 构造注入&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.object =&lt;span&gt; object;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Object invoke(Object proxy, Method method, Object[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
        before();
        Object ret &lt;/span&gt;=&lt;span&gt; method.invoke(object, args);
        after();

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret;
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; after() {
        System.out.println(&lt;/span&gt;&quot;after dosth&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; before() {
        System.out.println(&lt;/span&gt;&quot;before dosth&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;InvocationHandler 接口只有一个方法 —— invoke，参数也很好理解，分别是：&lt;/p&gt;
&lt;p&gt;proxy：代理的真实对象，也就是实现类的对象&lt;/p&gt;
&lt;p&gt;method：要调用真实对象的某个方法的Method对象，也就是会调用 dosth 的方法的对象&lt;/p&gt;
&lt;p&gt;args：调用真实对象某个方法时接受的参数，没有就是空数组&lt;/p&gt;

&lt;p&gt;最后写运行类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DynamicMain {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; DynamicProxy realRole = &lt;span&gt;new&lt;/span&gt; DynamicRealRole(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 被代理的类，也就是实现类&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; DynamicProxyRole dynamicProxyRole = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DynamicProxyRole(realRole);

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过JDK动态代理获取被代理对象（实现类的对象）的代理对象，该代理类实现了指定的需要去代理的接口，也就是第2个参数&lt;/span&gt;
        DynamicProxy dynamicProxyObj =&lt;span&gt; (DynamicProxy) Proxy.newProxyInstance(
                realRole.getClass().getClassLoader(), &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 被代理的类的加载器&lt;/span&gt;
                realRole.getClass().getInterfaces(), &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 被代理的类需要实现的接口,可以有多个&lt;/span&gt;
                dynamicProxyRole &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 必须是实现了 InvocationHandler 接口的类，invoke 方法里写业务逻辑和代理方法&lt;/span&gt;
&lt;span&gt;        );
        dynamicProxyObj.dosth();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Proxy 类的作用是动态创建一个代理对象，也就是代理对象不需要我们自己写。Proxy 提供了许多的方法，用的最多的是 newProxyInstance，注释里也写了：&lt;/p&gt;
&lt;p&gt;其中第一个参数是被代理的类的加载器，传入的目的是告诉 JDK 由哪个类加载器对生成的代理进行加载。其实就是真实的类（实现类）的对象的加载器。&lt;/p&gt;
&lt;p&gt;第二个参数是代理类需要实现的接口，可以多个。其实就是接口 DynamicProxy，很好理解，在静态代理模式中，我们就需要手动实现这个接口，来实现代理类。&lt;/p&gt;
&lt;p&gt;第三个参数就是实现了InvocationHandler接口的类即可，原因是此类里有 invoke 方法，而通过 Proxy 的 newProxyInstance 方法生成的代理类去调用接口方法（dosth）时，对方法（dosth）的调用会自动委托给 InvocationHandler 接口的 invoke 方法，这样也就实现了代理模式。&lt;/p&gt;
&lt;p&gt;综上，代理对象就实现了在程序运行时产生。进一步要知道，所有的 JDK 动态代理都会继承 java.lang.reflect.Proxy，同时还会实现我们指定的接口（Proxy 的 newProxyInstance 第二个参数里的接口）。&lt;/p&gt;
&lt;p&gt;看到这里，也确定，JDK 动态代理核心就是反射思想的应用，没什么新鲜的东西。&lt;/p&gt;
&lt;h2&gt;缺陷&lt;/h2&gt;
&lt;p&gt;JDK 动态代理这种方式只能代理接口，这是其缺陷&lt;/p&gt;
&lt;h2&gt;基于 CGLib 实现&lt;/h2&gt;
&lt;p&gt;Java动态代理是基于接口实现的，如果对象没有实现接口，那么可以用 CGLIB 类库实现，它的原理是基于继承实现代理类。代码也不难&lt;/p&gt;
&lt;p&gt;首先，写一个类，其没有实现接口，此时前面的 JDK 动态代理就无法使用了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; NoInterfaceReal {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; dosth() {
        System.out.println(&lt;/span&gt;&quot;do sth&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其次，需要实现CGLIB 类库提供的接口——MethodInterceptor&lt;/p&gt;
&lt;p&gt;在这之前，先下载CGLib 包&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
        &amp;lt;!-- https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;mvnrepository.com/artifact/cglib/cglib --&amp;gt;&lt;/span&gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;cglib&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;cglib&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;3.2.10&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后实现其提供的接口——MethodInterceptor，关键方法是 intercept&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CGLibProxy &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; MethodInterceptor {
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
        before();
        Object ret &lt;/span&gt;=&lt;span&gt; proxy.invokeSuper(obj, args);
        after();

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret;
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; after() {
        System.out.println(&lt;/span&gt;&quot;after dosth&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; before() {
        System.out.println(&lt;/span&gt;&quot;before dosth&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;实现了 MethodInterceptor 接口后，后续生成的代理对象对 dosth 方法的调用会被转发到 intercept 方法，自然也就实现了代理模式。&lt;/p&gt;
&lt;p&gt;最后，通过 CGLIB 动态代理生成代理对象，就完成了代理模式，非常简单&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CGLibMain {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        CGLibProxy cgLibProxy &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CGLibProxy();
        NoInterfaceReal proxy &lt;/span&gt;= (NoInterfaceReal) Enhancer.create(NoInterfaceReal.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, cgLibProxy);
        proxy.dosth();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过CGLib 的Enhancer类 create 了一个代理对象，参数传入需要被代理的类（可以不是接口），和实现了 MethodInterceptor 接口的类的对象即可。CGLib 就会为我们自动生成继承了被代理的类的代理对象，通过代理对象调用 dosth 方法，其调用会被委托给第二个参数里的 intercept 方法。&lt;/p&gt;
&lt;p&gt;综上得知：&lt;/p&gt;
&lt;p&gt;1、CGLib 底层是利用 asm 字节码框架实现的，该框架可以在 Java 程序运行时对字节码进行修改和动态生成，故它可以代理普通类，具体细节是通过继承和重写需要被代理的类（NoInterfaceReal）来实现。&lt;/p&gt;
&lt;p&gt;2、CGLib 可以实现对方法的代理，即可以实现拦截（只代理）某个方法。&lt;/p&gt;
&lt;p&gt;3、通过CGLib 的 Enhancer 类来create 代理对象。而对这个对象所有非final方法的调用都会委托给 MethodInterceptor 接口的 intercept，我们可以在该方法内部写拦截代码，最后在通过调用MethodProxy 对象的 invokeSuper() 方法，把调用转发给真实对象&lt;/p&gt;
&lt;h2&gt;缺陷&lt;/h2&gt;
&lt;p&gt;无法对 final 类、或者 final 方法进行代理&lt;/p&gt;

&lt;p&gt;直接搬运结论：CGLib 底层基于asm 框架实现，比 Java 反射性能好，但是比 JDK 动态代理稍微慢一些&lt;/p&gt;

&lt;p&gt;主要是性能问题，什么增加系统复杂度等都不是事儿。同等条件，用代理，肯定比不用代理要慢一些。&lt;/p&gt;

&lt;p&gt;实现方式上很像，但是目标不一样，后者是为了给类（对象）增加新的功能，不改变API，前者除了这些作用，目标主要是为了使用中间人（代理角色）给本类（对象）减少负担。&lt;/p&gt;
&lt;p&gt;参见：&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/kubixuesheng/p/10344505.html&quot;&gt;对复合（协作）算法/策略的封装方法——装饰模式总结&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;非常常见了，AOP非常典型，还有各种框架的拦截器机制，数据库切换等工具。。。&lt;/p&gt;
</description>
<pubDate>Thu, 28 Feb 2019 17:04:00 +0000</pubDate>
<dc:creator>dashuai的博客</dc:creator>
<og:description>前言 非常重要的一个设计模式，也很常见，很多框架都有它的影子。定义就不多说了。两点： 1、为其它对象提供一个代理服务，间接控制对这个对象的访问，联想 Spring 事务机制，在合适的方法上加个 tra</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kubixuesheng/p/5183782.html</dc:identifier>
</item>
<item>
<title>区块链与淘宝客结合新的割韭菜方式-玩闪电鸡现身说法 - 张林-布莱恩特</title>
<link>http://www.cnblogs.com/zhangmumu/p/10454302.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangmumu/p/10454302.html</guid>
<description>&lt;h3 id=&quot;区块链思想&quot;&gt;区块链思想&lt;/h3&gt;
&lt;p&gt;区块链是当下最火的话题，但区块链真正落地的产品少之又少，更多时候炒币炒得风风火火。&lt;/p&gt;
&lt;p&gt;在笔者看来，区块链的本质是财富的再一次均分，将生产关系进行变革。&lt;/p&gt;
&lt;p&gt;通过token，也就是所谓的币，让大家再一次和项目起飞。&lt;/p&gt;
&lt;p&gt;但很多项目没有产品落地，更多是没有结合当前物理社会的赋能，给予产品更多能量。&lt;/p&gt;
&lt;p&gt;Token有两个作用：&lt;/p&gt;
&lt;p&gt;一个是传送价值，token是可以转化成现实价值的，并不只是一串数字；&lt;/p&gt;
&lt;p&gt;一个是信任传递，把企业的未来与消费者捆绑在一起。&lt;/p&gt;
&lt;p&gt;而闪电鸡正好符合这两个特征，想尝试的童鞋可以下载玩下，&lt;/p&gt;
&lt;h3 id=&quot;闪电鸡模式&quot;&gt;闪电鸡模式&lt;/h3&gt;
&lt;p&gt;闪电鸡的里面有三类用户&lt;/p&gt;
&lt;p&gt;1、消费者日常购物，付款到收货，即可收获闪电股。&lt;/p&gt;
&lt;p&gt;完全获得闪电股，则需要收货后30天，这大概也是为了防止刷单的吧，毕竟常刷常有的。&lt;/p&gt;
&lt;p&gt;2、电商平台负责搭建平台，收获平台费。商家出售商品，收获金钱。&lt;/p&gt;
&lt;p&gt;3、闪电鸡平台则负责收获一部分佣金，也就是渠道费用。&lt;/p&gt;
&lt;h3 id=&quot;韭菜属性探险鸡&quot;&gt;韭菜属性（探险鸡）：&lt;/h3&gt;
&lt;p&gt;1.一个购物返利App，居然做成了一个养鸡游戏。大家都还记得之前玩过的千米红包和农场世界吗？据说他们和闪电鸡是一个幕后团队，最后割了一波韭菜就消失了。&lt;/p&gt;
&lt;p&gt;闪电鸡，增加了探险鸡模式，送的鸡蛋相当于农场世界的虾苗，然后孵化小鸡出售得闪电，相当于养殖虾出售成好像是虾证来换人民币。总之，和农场世界的玩法差不多。而这种的基础就是千米红包。&lt;/p&gt;
&lt;p&gt;2.玩法规则很简单，有点类似于旅行青蛙的趣味性：&lt;/p&gt;
&lt;p&gt;探险鸡出去探险，一定的时间间隔会出去探险，回家的时候会带回来小鸡，小鸡可以换成钱，直接提现。大概1000只小鸡1元钱，1只探险鸡大概需要20天能够带回来3000只小鸡，也就是20天左右回本，这个到后面探险鸡的价格肯定会上涨的。&lt;/p&gt;
&lt;p&gt;这里要注意的一点是，探险鸡带回来的小鸡你要及时出售，因为这涉及到容量问题，后续也不会增加小鸡，自然也就不会多赚钱了，而平台扩容100只需要3元，小编教你一个方法，淘宝购物一次也可以增加100容量，比如充值话费，搜索1分壁纸等，这样1分钱就可以增加100容量是不是很划算。&lt;/p&gt;
&lt;p&gt;闪电鸡App是骗局！那它什么时候跑路？ 赚钱方法 借钱省钱 第2张&lt;/p&gt;
&lt;p&gt;最后有必要特别提醒下各位，千米红包开始以红包模式进行割韭菜，之后又出城主模式割韭菜，在之后闪电鸡买闪电股割韭菜，再接着农场世界买虾苗割韭菜，接着农场世界出脐橙割韭菜。现在好了，闪电鸡换探险鸡割韭菜。反正你不清醒，你就是他们的一个棋子而已。&lt;/p&gt;
&lt;h3 id=&quot;结语&quot;&gt;结语：&lt;/h3&gt;
&lt;p&gt;最终闪电鸡的价值，是可以有上升空间的，而且越早期进入越好，因为股价还很低！&lt;/p&gt;
&lt;p&gt;闪电鸡和消费者一起把这块蛋糕一起搞大，一起赚钱。有了期望，积极性就不一样。&lt;/p&gt;
&lt;p&gt;其实消费者做得也就很简单了，只需要在闪电鸡上面买买买即可，毕竟是日常刚需。&lt;/p&gt;
&lt;p&gt;未来&lt;/p&gt;
&lt;p&gt;有了现实业务的赋能，积累流量之后，产品的后续发展更容易了。做垂直电商也好，做广告也可。&lt;/p&gt;
&lt;p&gt;不得不佩服闪电鸡的PM，对区块链的理解深入透彻。&lt;/p&gt;
&lt;h3 id=&quot;闪电鸡下载微信直接扫码&quot;&gt;闪电鸡下载：微信直接扫码&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1220420/201903/1220420-20190301004451206-1011414759.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;### 闪电鸡交流群，作者微信：18872849618，备注（韭菜即可）&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1220420/201903/1220420-20190301004258357-551134747.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 28 Feb 2019 16:46:00 +0000</pubDate>
<dc:creator>张林-布莱恩特</dc:creator>
<og:description>闪电鸡和消费者一起把这块蛋糕一起搞大，一起赚钱。有了期望，积极性就不一样，然而平台最终可能会收割韭菜！</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhangmumu/p/10454302.html</dc:identifier>
</item>
<item>
<title>简述21种设计模式 - 滴水微澜</title>
<link>http://www.cnblogs.com/zhou--fei/p/10454244.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhou--fei/p/10454244.html</guid>
<description>&lt;p&gt;《Object-C编程之道》个人感觉是非常好的一本iOS设计模式书籍。&lt;/p&gt;
&lt;p&gt;里面会结合在iOS的Cocoa 框架中使用到的例子进行讲解，在学习设计模式的同时，也能对Cocoa框架中使用的设计模式有个熟悉。这一点我非常喜欢。&lt;/p&gt;

&lt;p&gt;按照设计模式的功能进行划分，可以分为八类：&lt;/p&gt;
&lt;p&gt;接口适配类，对象去耦类，对象创建类，抽象集合类，对象状态类，行为扩展类，算法封装类，性能与对象访问类。其中包含内容如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对象创建型：&lt;/strong&gt;1.原型模式；2.工厂模式；3.抽象工厂模式；4.单例模式；5.生成器&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;接口适配型：&lt;/strong&gt;1.适配器模式；2.桥接模式；3.外观模式&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对象去耦型：&lt;/strong&gt;1.中介者模式；2.观察者模式&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;抽象集合型：&lt;/strong&gt;1.组合模式；2.迭代器模式&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;行为扩展型：&lt;/strong&gt;1.访问者模式；2.装饰器模式；3.责任链模式&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;算法封装型：&lt;/strong&gt;1.模版方法模式；2.策略模式；3.命令模式&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;性能与对象访问型：&lt;/strong&gt;1.享元模式；2.代理模式&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对象状态型：&lt;/strong&gt;1.备忘录模式&lt;/p&gt;

&lt;p&gt;下面将对书中讲解到的设计模式进行简述。&lt;/p&gt;
&lt;p&gt;建议有时间的同学去通读和练习一遍。没有时间的同学就看我下面写的吧，先做到心里有个概况。等有时间了再去研究。&lt;/p&gt;
&lt;p&gt;后面计划对里面的每种设计模式进行详解（二十一种，真不少），想持续关注的要留心了。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;对象创建型&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;原型模式：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;简单的说就是复制，用同一个磨具复制出一系列的东西。&lt;/p&gt;
&lt;p&gt;使用场景有：&lt;/p&gt;
&lt;p&gt;1.创建一个实例流畅复杂，复制比较容易；&lt;/p&gt;
&lt;p&gt;2.创建一个对象子对象组合比较多，复制比较容易；&lt;/p&gt;
&lt;p&gt;应用实例：&lt;/p&gt;
&lt;p&gt;自定义对象实现NSCopy协议或者NSMutableCopy协议，实现方法copyWithZone或者mutableCopyWithZone。就是对此设计模式的体现。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;工厂模式：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;简单的说就是在一个类中根据需求，可以生产出多种类型的产品。&lt;/p&gt;
&lt;p&gt;使用场景有：&lt;/p&gt;
&lt;p&gt;类有很多具体的子类，想让返回什么样的子类局部化，由内部自行判断。&lt;/p&gt;
&lt;p&gt;应用实例：&lt;/p&gt;
&lt;p&gt;NSNumber类定义了一系列的工厂方法：&lt;/p&gt;
&lt;p&gt;根据int 生产 intNumber; 根据unsigned int 生产 unsignedNumber;&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
+ (NSNumber *)numberWithInt:(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)value;
&lt;/span&gt;+ (NSNumber *)numberWithUnsignedInt:(unsigned &lt;span&gt;int&lt;/span&gt;)value;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;抽象工厂模式：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从产品的角度看，是一种二维的思考。如水果工厂的工厂模式是生产苹果，橘子。&lt;/p&gt;
&lt;p&gt;而苹果分为北方工厂产的苹果，南方工厂产的苹果。&lt;/p&gt;
&lt;p&gt;从工厂的角度看，比较简单。抽象工厂下面两个子工厂，它们都可以生产苹果，橘子。&lt;/p&gt;
&lt;p&gt;应用实例：&lt;/p&gt;
&lt;p&gt;NSNumber抽象工厂。下面很多具体的number工厂，如：&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
+ (NSNumber *)numberWithInt:(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)value;
&lt;/span&gt;+ (NSNumber *)numberWithUnsignedInt:(unsigned &lt;span&gt;int&lt;/span&gt;)value;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;单例模式：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个类只有一个实例，并提供全局访问点。&lt;/p&gt;
&lt;p&gt;使用场景有：&lt;/p&gt;
&lt;p&gt;系统只能共享，无法复制的元素。&lt;/p&gt;
&lt;p&gt;应用实例：&lt;/p&gt;
&lt;p&gt;文件系统管理类:整个系统只有一份。&lt;/p&gt;
&lt;p&gt;UIApplication：一个App只有一个应用单例。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;生成器模式：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将一个复杂对象的构建与它的表现分离，使得同样的构建过程可以创建不一样的表现对象。&lt;/p&gt;
&lt;p&gt;使用场景：&lt;/p&gt;
&lt;p&gt;构建过程需要用不同的组合构建不同表现的对象。&lt;/p&gt;

&lt;p&gt;对于生成一个比较复杂的对象，通常使用生成器模式 里面按照角色划分有4种：&lt;/p&gt;
&lt;p&gt;客户端，提出一系列需要，需要什么样的产品。&lt;/p&gt;
&lt;p&gt;指挥者，从客户端那里接收到一系列需要，然后按照功能分割。&lt;/p&gt;
&lt;p&gt;构建者，从指挥者手中得到一个需求，并生产一个对于的产品。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;对象创建型整体宏观图如下：&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/826860/201903/826860-20190301002328122-1025422587.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;接口适配型&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;适配器模式：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对象调用接口 -&amp;gt; 适配器 -&amp;gt; 被适配接口，适配器可以使原本不兼容的接口可以一起协调工作了。&lt;/p&gt;
&lt;p&gt;使用场景：&lt;/p&gt;
&lt;p&gt;已有类的接口与需求类接口不匹配。&lt;/p&gt;
&lt;p&gt;应用实例：&lt;/p&gt;
&lt;p&gt;Delegate是CocoaTouch框架中采用适配器模式（委托）的一种实现。实现协议的具体类是个适配器。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;桥接模式：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;把抽象层次结构从实现中分离出来，使其能够独立变更。&lt;/p&gt;
&lt;p&gt;抽象层定义了供客户端使用的上层抽象接口。&lt;/p&gt;
&lt;p&gt;实现层次结构定义了供抽象层次使用的底层接口。&lt;/p&gt;

&lt;p&gt;不想在抽象与其实现之间形成固定的绑定关系；&lt;/p&gt;
&lt;p&gt;客户端抽象层引用着实现层抽象层；&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;外观模式：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为子系统中一组不同的功能接口，提供统一的外观服务接口。&lt;/p&gt;
&lt;p&gt;子系统变的越来越复杂，可以使用外观类为这个子系统提供一个简单的入口。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;接口适配型整体宏观图如下： &lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/826860/201903/826860-20190301002343495-2079460724.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;对象去耦型&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;中介者模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一句看概述：封装对象间的交互。&lt;/p&gt;
&lt;p&gt;中介者模式用于定义一个集中的场所，对象间的交互可以在一个中介者对象内处理， 从而避免其他对象间的依存关系。&lt;/p&gt;
&lt;p&gt;使用场景：&lt;/p&gt;
&lt;p&gt;对象间的交互定义明确而复杂，导致一组对象彼此互相依赖且难以理解。&lt;/p&gt;
&lt;p&gt;使用实例：&lt;/p&gt;
&lt;p&gt;组件化开发中使用的路由器，就是一个利用反射机制实现的中介者。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;观察者模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义一种一对多的关系，使一个对象状态改变，所以观察者对象都收到通知。&lt;/p&gt;
&lt;p&gt;观察者模式也叫发布-订阅机制。&lt;/p&gt;
&lt;p&gt;可以利用Observer模式，令通知中心为中介，可以做到一个自定义对象通过通知中心 去通知到其他多个对象的目的。&lt;/p&gt;
&lt;p&gt;使用场景：&lt;/p&gt;
&lt;p&gt;在MVC框架模式中，通过观察着，实现Model，View的联动。&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt; 
&lt;p&gt;&lt;strong&gt;对象去耦型整体宏观图如下： &lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/826860/201903/826860-20190301002357599-655847315.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;抽象集合型&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;组合模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;组合模式让我们把相同基类型的对象组合到树状结构中，其中父节点包含同类型的子节点。&lt;/p&gt;
&lt;p&gt;组件节点和叶子节点都是实现同一个基类接口。同一个抽象父类。&lt;/p&gt;
&lt;p&gt;对组合对象的查询，访问都是递归操作。&lt;/p&gt;
&lt;p&gt;将对象组合成树形结构，以表示“整体-部分”的层次结构，组合使得用户对单个对象和组合对象的操作具有一致性。&lt;/p&gt;
&lt;p&gt;使用实例：&lt;/p&gt;
&lt;p&gt;UIView的树形结构，包含很多子View。&lt;/p&gt;
&lt;p&gt;事件消息链，响应链传递。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;迭代器模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;迭代器提供了一种 顺序访问聚合对象（集合）中元素的方法，而无需暴露结构的底层表示和结构细节。 遍历集合元素的任务从集合 转移给了迭代器对象。&lt;/p&gt;
&lt;p&gt;使用场景：&lt;/p&gt;
&lt;p&gt;需要访问组合对象内容，而不想暴露内部表示，结构。&lt;/p&gt;
&lt;p&gt;迭代器分为内部迭代器和外部迭代器。&lt;/p&gt;
&lt;p&gt;外部迭代器允许客户端更自由的使用，同时需要熟悉组合对象的内部结构。&lt;/p&gt;
&lt;p&gt;内部迭代器被封装在集合内部，在集合外部提供接口。&lt;/p&gt;
&lt;p&gt;使用实例：&lt;/p&gt;
&lt;p&gt;集合对象（nsarray, nsdictionary）都默认提供了迭代器。&lt;/p&gt;

&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;抽象集合型整体宏观图如下： &lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/826860/201903/826860-20190301002411706-124426472.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;行为扩展型&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;访问者模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;作用于组合对象结构中的每一个元素的操作，它让我们在不改变元素类的前提下，扩展这些类的新操作。&lt;/p&gt;
&lt;p&gt;在接受访问者的接口方法中，实现将元素传给访问者，然后访问者扩展对元素的操作。&lt;/p&gt;
&lt;p&gt;使用场景：&lt;/p&gt;
&lt;p&gt;想对一个对象进行很多不相关的操作，又不想污染这个对象。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;装饰器模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;向对象添加行为而不破坏其原有的风格，因此增强了的对象是同一个类的加强版。任何“增强”均可以动态添加和删除。装饰对象可以附加到另一装饰对象，也可以附加到原始对象。&lt;/p&gt;
&lt;p&gt;使用场景：&lt;/p&gt;
&lt;p&gt;在不影响对象的情况下，动态，透明的给单个对象添加职责。&lt;/p&gt;
&lt;p&gt;使用实例：&lt;/p&gt;
&lt;p&gt;滤镜操作，可以不管滤镜顺序。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;责任链模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;让一组对象处理特定的请求，而对这个组中的成员（处理程序对象handler）增加，删除不影响组的完整性。&lt;/p&gt;
&lt;p&gt; 链中的每一个对象实现了同样的方法，处理对链中第一个对象发起的同一个请求。 如果一个对象不知道如何处理这个请求，就把请求传给下一个响应器（successor）。&lt;/p&gt;
&lt;p&gt;使用场景：&lt;/p&gt;
&lt;p&gt;向一组对象发送处理请求，而不想显示的指定是哪个对象进行处理。&lt;/p&gt;

&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;行为扩展型整体宏观图如下： &lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/826860/201903/826860-20190301002426638-1057079079.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;算法封装型&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;模版方法模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在抽象父类中定义操作架构和公共操作，具体操作延迟到子类中实现。&lt;/p&gt;
&lt;p&gt;在模版方法模式中，使子类可以重定义算法的某些特定步骤而不改变算法结构。&lt;/p&gt;
&lt;p&gt;使用场景：&lt;/p&gt;
&lt;p&gt;需要一次性将不变部分写好，将可变部分留给子类实现。&lt;/p&gt;
&lt;p&gt;使用实例：&lt;/p&gt;
&lt;p&gt;在UIView 中的方法draw:(CGRect)rect方法。&lt;/p&gt;
&lt;p&gt;这个绘图方法draw:为UIView提供的钩子函数，当用户想要自己绘图时，就可以自己扩展添加。不实现也不影响功能。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;策略模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在面向对象设计中，将不同的算法分离成不同的类，称为策略。与这种做法相关的设计模式，称为策略模式。&lt;/p&gt;
&lt;p&gt;使用场景：&lt;/p&gt;
&lt;p&gt;在平时的函数中会出现if-else或者switch-case这样的选择语句，它们的不同分支下对应的是不同的算法。 而将这些不同的算法封装成一个个不同的算法对象。实际上就是不同的策略。&lt;/p&gt;
&lt;p&gt;使用实例：&lt;/p&gt;
&lt;p&gt;控制器是视图的策略类，视图可以因为控制器不同而展示不同的信息。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;命令模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在面向对象设计中，把指令封装在各种命令对象中，命令对象可以被传递， 并且在指定时刻被不同客户的复用，从这一概念精心设计的模式被称为命令模式。&lt;/p&gt;
&lt;p&gt;使用场景：&lt;/p&gt;
&lt;p&gt;想让程序支持撤销恢复功能&lt;/p&gt;
&lt;p&gt;使用实例：&lt;/p&gt;
&lt;p&gt;NSInvocation, NSUndoManager是框架中这个模式的典型应用。&lt;/p&gt;

&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;算法封装型整体宏观图如下： &lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/826860/201903/826860-20190301002458444-118799798.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;性能与对象访问型&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;享元模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;运用共享技术，有效的控制大量细粒度的对象。&lt;/p&gt;
&lt;p&gt;使用场景：&lt;/p&gt;
&lt;p&gt;应用程序中使用大量对象时。&lt;/p&gt;
&lt;p&gt;通过共享减少了多少对象总数。&lt;/p&gt;
&lt;p&gt;使用实例：&lt;/p&gt;
&lt;p&gt;屏幕上要展示1000朵小花，利用共享可以只用10个imageData对象，1000个坐标对象。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;代理模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为其他客户端提供一种代理，来控制对真实对象的访问。&lt;/p&gt;
&lt;p&gt;远程代理：用本地对象代替远程对象。如：发送网络时的代理服务器。&lt;/p&gt;
&lt;p&gt;虚拟代理：将代理直接面向客户端，使客户端认为操作的虚拟代理就是真实对象。虚拟代理提供占位对象和重型对象。默认使用占位对象，当需要使用重型对象时才加载。&lt;/p&gt;

&lt;p&gt;使用实例：&lt;/p&gt;
&lt;p&gt;Object-C不支持多继承，如果代理对象不是NSObject的子类的话，可以考虑用NSProxy来作为占位或者替代对象。&lt;/p&gt;
&lt;p&gt;尽管NSProxy也是NSObject类型，但是NSProxy的作用就是当代理。&lt;/p&gt;

&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;性能与对象访问型整体宏观图如下： &lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/826860/201903/826860-20190301002513278-2112252574.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;对象状态型&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;备忘录模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在不破坏原有封装的前提下，捕获一个对象的内部状态，并在该对象之外保存状态。 这样，之后可将对象恢复到之前的状态。将状态封装成对象保存。&lt;/p&gt;
&lt;p&gt;使用场景：&lt;/p&gt;
&lt;p&gt;需要保存对象在某一时刻的状态（或部分状态），这样以后就可以恢复到先前的状态。&lt;/p&gt;
&lt;p&gt;使用实例：&lt;/p&gt;
&lt;p&gt;Cocoa Touch框架在归档，属性列表序列化，核心数据中采用了备忘录模式。&lt;/p&gt;

&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;对象状态型整体宏观图如下： &lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/826860/201903/826860-20190301002526903-1194486827.png&quot; alt=&quot;&quot;/&gt; &lt;/div&gt;

&lt;p&gt;完整项目地址如下：&lt;/p&gt;
&lt;p&gt;https://github.com/zhfei/Objective-C_Design_Patterns&lt;/p&gt;


</description>
<pubDate>Thu, 28 Feb 2019 16:27:00 +0000</pubDate>
<dc:creator>滴水微澜</dc:creator>
<og:description>《Object-C编程之道》个人感觉是非常好的一本iOS设计模式书籍。 里面会结合在iOS的Cocoa 框架中使用到的例子进行讲解，在学习设计模式的同时，也能对Cocoa框架中使用的设计模式有个熟悉。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhou--fei/p/10454244.html</dc:identifier>
</item>
<item>
<title>python装饰器入门 - failymao</title>
<link>http://www.cnblogs.com/failymao/p/10454247.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/failymao/p/10454247.html</guid>
<description>&lt;div id=&quot;&quot;&gt;
&lt;p&gt;&lt;strong&gt;v1&lt;/strong&gt; 将函数作为参数传递进 嵌套函数中, 返回函数本身&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def cert_decorator(func):

    def wrapTheFunction():
        user = input(&quot;pls input password:&quot;).strip()
        if user == &quot;faily&quot;:
            print(&quot;---welcome login----&quot;)
            func()
        else:
            print(&quot;----wrong password&quot;)
    return wrapper

def task():
    print(&quot;do somthing &quot;)

if __name__ == &quot;__main__&quot;:
    task = cert_decorator(task)   # 执行装饰器函数,将task作为参数传递,赋值给task变量,返回的是wrapper函数名,内部函数func并没有执行
    task()                        # 执行task,实际就是执行了wrapper(),然后执行了内部的func()函数&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;实现了不改变函数名的和内部结构的前提下, 实现了认证,但是, 但是... 用户需要多些一行重命名函数变量的方式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;&lt;div id=&quot;&quot;&gt;
&lt;p&gt;&lt;strong&gt;v2&lt;/strong&gt; python内部可以通过&lt;code&gt;@&lt;/code&gt;符号进行直接调用&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def cert_decorator(func):

    def wrapTheFunction():
        user = input(&quot;pls input password:&quot;).strip()
        if user == &quot;faily&quot;:
            print(&quot;---welcome login----&quot;)
            func()
        else:
            print(&quot;----wrong password&quot;)
    return wrapTheFunction

@cert_decorator
def task():
    print(&quot;do somthing &quot;)

if __name__ == &quot;__main__&quot;:
    task()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;※ 好像我们大功告成了... 别高兴得太早 ,如果我们运行一下这行代码 会存在一个问题&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;print(task.__name__)
#output
wrapTheFunction  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;♥ . 这并不是我们想要的！Ouput输出应该是&lt;code&gt;task&lt;/code&gt;。这里的函数被warpTheFunction替代了。它重写了我们函数的名字和注释文档(docstring), &lt;em&gt;如果我们想在被装饰的函数在执行之前去访问函数的某些属性(文档, 变量名...),显然是没办法做到的&lt;/em&gt;, &lt;strong&gt;怎么办???&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;幸运的是Python提供给我们一个简单的函数来解决这个问题，那就是&lt;code&gt;functools.wraps&lt;/code&gt;。我们修改上一个例子来使用&lt;code&gt;functools.wraps&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Thu, 28 Feb 2019 16:23:00 +0000</pubDate>
<dc:creator>failymao</dc:creator>
<og:description>[TOC] python装饰器初级 认识装饰器 概念: 简单地说： 原则 : 不修改被装饰函数的源代码 不修改被装饰函数的调用方式 优点: 有助于让我们的代码更简短，也更Pythonic（Python</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/failymao/p/10454247.html</dc:identifier>
</item>
<item>
<title>console 调试技巧 - 格子熊</title>
<link>http://www.cnblogs.com/karthuslorin/p/10448743.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/karthuslorin/p/10448743.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;如果统计一番前端最常用的方法，那么 console.log 一定位列其中。无论你写的是原生 JS 亦或者是 JQuery、Vue等等，调试之时，都离不开 console.log 方法。但是，console 对象中的方法不仅仅只有 log 方法。强大的 console 对象提供了大量控制台调试的相关方法，掌握这些方法可以大大方便你的调试，甚至做出一些炫酷的控制台字符画。&lt;/p&gt;
&lt;h2 id=&quot;基本输出&quot;&gt;基本输出&lt;/h2&gt;
&lt;p&gt;console 对象最基础的方法毫无疑问是 log，该方法会直接在控制台上输出参数，如果输入多个参数，那么输出在控制台上的参数用空格分隔，如下所示：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;console.log('Hello World');
console.log('Hello', 'World');&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打开控制台，运行结果如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1309897/201902/1309897-20190228234456309-1579510977.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;console.log 还含有类似于 Python 的占位符功能，但是，个人认为该功能可以完全被 ES6 中的字符串模板完全替代，有兴趣的可以去了解，在此不再赘述。&lt;/p&gt;
&lt;h2 id=&quot;分类输出&quot;&gt;分类输出&lt;/h2&gt;
&lt;p&gt;厌倦了 console.log 单调的输出？欢迎尝试 console 对象的分类输出功能。console 对象提供了 info、warn、error 方法分别输出提示、警告以及错误信息。&lt;/p&gt;
&lt;p&gt;我们输入下面这段代码：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;console.log('log')
console.info('info')
console.warn('warn')
console.error('error')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1309897/201902/1309897-20190228234513223-1879170375.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以发现，warn 和 error 方法分别输出了一条警告和一条错误信息。但是，为什么 log 方法和 info 方法输出是一样的呢？&lt;/p&gt;
&lt;p&gt;原因在于，我使用的是 Chrome 浏览器，在 Chrome 浏览器上，log 方法和 info 方法的表现是一样的。但是，在其他浏览器上，比如 FireFox，info 方法前面会有一个信息图标。&lt;/p&gt;
&lt;p&gt;由于 info 方法的效果不明显，并且各个浏览器中效果有差异，所以一般情况下，我们使用 log 方法代替 info 方法。&lt;/p&gt;
&lt;h2 id=&quot;断言输出&quot;&gt;断言输出&lt;/h2&gt;
&lt;p&gt;console 对象提供了类似于单元测试中的断言的方法：assert。该方法接收两个参数，第一个参数为断言条件，第二个参数代表断言信息。&lt;/p&gt;
&lt;p&gt;同单元测试断言一样，当断言条件为 true 时，assert 无输出；只有当断言条件为 false 时，assert 方法才会在控制台中输出一条断言错误信息。&lt;/p&gt;
&lt;p&gt;我们输入以下代码：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;console.assert(true, 'true')
console.assert(false, 'false')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;控制台如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1309897/201902/1309897-20190228234539305-1594831667.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以发现，控制台只输出了那一条断言条件为 false 的语句。&lt;/p&gt;
&lt;h2 id=&quot;分组输出&quot;&gt;分组输出&lt;/h2&gt;
&lt;p&gt;当你的控制台上输出了大量信息时，控制台会显得极其杂乱，你甚至不知道某一条信息是哪条代码输出的。此时，console 对象的 group 以及 groupEnd 方法可以拯救你。&lt;/p&gt;
&lt;p&gt;将部分 console 语句放入 group 与 groupEnd 之间，可以形成将这部分 console 语句划定为一组信息进行输出。其中，group 方法接收一个字符，作为分组名称，groupEnd 方法不接收参数用于结束分组。&lt;/p&gt;
&lt;p&gt;输入以下代码：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;console.group('1')
console.log('1-1')
console.warn('1-2')
console.error('1-3')
console.groupEnd()

console.group('2')
console.log('2-1')
console.warn('2-2')
console.error('2-3')
console.groupEnd()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1309897/201902/1309897-20190228234600025-934643910.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过点击分组的箭头，可以折叠分组，方便归纳整理控制台信息，避免控制台被海量信息淹没。&lt;/p&gt;
&lt;h2 id=&quot;表格输出&quot;&gt;表格输出&lt;/h2&gt;
&lt;p&gt;我们不仅可以将控制台信息分组输出，我们还可以将其以表格的形式输出。&lt;/p&gt;
&lt;p&gt;console 的 table 方法可以将一个对象以表格的形式输出，当输入的参数不是对象时，此时，table 方法相当于 log 方法。&lt;/p&gt;
&lt;p&gt;输入以下代码：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;const obj = {
    a: {
        id: 1,
        value: 1
    },
    b: {
        id: 2,
        value: 2
    }
};

console.log(obj)

console.table(obj)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;控制台如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1309897/201902/1309897-20190228234623648-1713136049.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;控制台不仅以表格形式输出了对象，还以基础输出的方式输出了对象以方便查看信息。&lt;/p&gt;
&lt;h2 id=&quot;计次输出&quot;&gt;计次输出&lt;/h2&gt;
&lt;p&gt;在日常开发中，有一个常见的调试需求——计算一段代码的执行次数。一般来说，我们会在这段代码中定义一个变量，每执行一次它就进行一次自增，并通过 console.log 方法输出该变量。&lt;/p&gt;
&lt;p&gt;可以看出，上述的方法略显麻烦，可不可以一行代码就解决这个问题呢？当然可以！count 方法，你值得拥有。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;for(let i = 0; i &amp;lt; 5; i++){
    console.count(&quot;num&quot;);
}
console.count(&quot;num&quot;);
console.count(&quot;anotherNum&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1309897/201902/1309897-20190228234640653-2143902550.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以发现，count 方法通过输入的字符串区分不同的计数语句。&lt;/p&gt;
&lt;h2 id=&quot;计时输出&quot;&gt;计时输出&lt;/h2&gt;
&lt;p&gt;当测试算法性能时，我们通常使用时间复杂度来评价算法的性能，但是，时间复杂度哪里有代码执行时间来的直观呢？&lt;/p&gt;
&lt;p&gt;在之前不了解 console 对象的时候，我们在算法的头尾分别获取时间戳，取时间戳的差值作为代码执行时间。很明显，这种方法太过繁琐。&lt;/p&gt;
&lt;p&gt;使用 console 对象的 time 以及 timeEnd 方法可以计算出代码执行时间。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;console.time('time');
let sum = 0;
for (let i = 0; i &amp;lt; 100000;i++) {
    sum += i;
}
console.timeEnd('time');&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1309897/201902/1309897-20190228234653320-595467510.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;最后&quot;&gt;最后&lt;/h3&gt;
&lt;p&gt;除了上述的方法，cnosole 方法还有很多强大的方法，比如：dir、debug、trace等，但是它们有的在 Chrome 效果不佳，有的能被 Chrome debugger 完美替代，所以，在此不再赘述。如果有兴趣，可以进一步了解。&lt;/p&gt;
</description>
<pubDate>Thu, 28 Feb 2019 15:47:00 +0000</pubDate>
<dc:creator>格子熊</dc:creator>
<og:description>前言 如果统计一番前端最常用的方法，那么 console.log 一定位列其中。无论你写的是原生 JS 亦或者是 JQuery、Vue等等，调试之时，都离不开 console.log 方法。但是，co</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/karthuslorin/p/10448743.html</dc:identifier>
</item>
<item>
<title>[翻译] Visual Studio 2019 RC版发布 - Rwing</title>
<link>http://www.cnblogs.com/Rwing/p/visual-studio-2019-release-candidate-rc-now-available.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Rwing/p/visual-studio-2019-release-candidate-rc-now-available.html</guid>
<description>&lt;p&gt;原文: &lt;a href=&quot;https://devblogs.microsoft.com/visualstudio/visual-studio-2019-release-candidate-rc-now-available/&quot;&gt;Visual Studio 2019 Release Candidate (RC) now available&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;今天，我们将分享 Visual Studio 2019 的发布候选版(RC 版) - 这是在 4 月 2 日的&lt;a href=&quot;https://launch.visualstudio.com/&quot;&gt;虚拟发布活动&lt;/a&gt;上正式发布之前的最后步骤之一。 您可以在 visualstudio.com/downloads 下载 RC 版。与往常一样，查看&lt;a href=&quot;https://docs.microsoft.com/visualstudio/releases/2019/release-notes&quot;&gt;RC 版的发行说明&lt;/a&gt;以获取更多详细信息。&lt;/p&gt;
&lt;h2 id=&quot;发布候选版的说明&quot;&gt;发布候选版的说明&lt;/h2&gt;
&lt;p&gt;在这个版本中，我们引入了两个产品“通道”：发布通道和预览通道。从今天开始，Visual Studio 2019 RC 版在发布通道 (visualstudio.com/downloads) 中可用，Visual Studio 2019 Preview 4 在预览通道 (visualstudio.com/preview) 中可用。这两个版本都可以同时安装和使用，当然在现在，两个通道是一样的。&lt;/p&gt;
&lt;p&gt;从 4 月 2 日开始，发布通道(即 RC 版)可以升级到我们的正式(GA)版，该版本可供生产使用。正如您在 Visual Studio 2017 中所习惯的那样，预览通道将继续提供对即将发布的特性的早期预览。&lt;/p&gt;
&lt;p&gt;在今天的版本中，我们鼓励您将 Visual Studio 2019 RC 版与您现有的预览版本一起安装，或者如果您还没有使用预览版本，那么就可直接使用 RC 版。和以前 RC 版本们一样，Visual Studio 2019 RC 版是一个受支持的版本，带有 go-live 许可，但请记住，我们仍在完成工作，一些工作负载的预览将持续到 4 月 2 日。如前所述，RC 版可以在 4月 2 日升级到正式版(GA)。&lt;/p&gt;
&lt;p&gt;为了帮助理解现在版本和 GA 版及以后的两个通道，我们整理了以下图表:&lt;br/&gt;&lt;img src=&quot;https://devblogs.microsoft.com/visualstudio/wp-content/uploads/sites/4/2019/02/VS_branching_diagram_1600x500-1-768x240.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;visual-studio-2019-的版本&quot;&gt;Visual Studio 2019 的版本&lt;/h2&gt;
&lt;p&gt;在 visualstudio.com 的下载或预览页面上，您会发现现在可以选择下载社区版、专业版或企业版。到目前为止，Visual Studio 2019 预览通道只有企业版。如果您拥有企业版的许可证，并希望继续使用 Visual Studio 2019 预览版，您可以在 Visual Studio 安装程序中简单地更新到Preview 4。对于其他人，您必须在预览通道（Prview 4）或发布通道（RC）中切换到您的许可版本。我们建议您首先安装许可版本，然后卸载当前的 Visual Studio 2019 预览版。&lt;/p&gt;
&lt;p&gt;Visual Studio 专业版和企业版有一些不同地方。例如，企业版拥有 IntelliTrace、实时单元测试、用于移动应用的嵌入式程序集、实时架构验证&lt;a href=&quot;https://visualstudio.microsoft.com/vs/compare/&quot;&gt;等功能&lt;/a&gt;，这些都是我们在不断完善的功能。在 Visual Studio 2019 企业版中，会有一些更厉害的特性:&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;快照调试器，使您能够以最小的中断调试 Azure 中的生产应用程序，增加对 Azure Kubernetes Service(AKS) 和 Virtual Machine Scale Sets(VMSS) 的支持。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;在 Visual Studio 2019 企业版的未来版本中，将添加与快照调试器集成的 Time Travel Debugging (TTD) 的预览版。TTD 使您能够记录进程，然后准确地重建和重放执行路径。您可以多次回放和重放每行代码，帮助您隔离和识别问题。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于 Visual Studio 2019 社区版，我们提供了 &lt;a href=&quot;https://docs.microsoft.com/visualstudio/ide/find-code-changes-and-other-history-with-codelens&quot;&gt;CodeLens&lt;/a&gt; 的“引用”、“Application Insights”和“测试”功能，这些功能以前只在 Visual Studio 专业版和企业版中提供。这意味着任何 Visual Studio 2019 用户现在都可以在代码编辑器中获得关于代码的特定见解和信息。&lt;/p&gt;
&lt;h2 id=&quot;一起奔向终点线&quot;&gt;一起奔向终点线&lt;/h2&gt;
&lt;p&gt;我们非常感谢所有自第一次预览版以来一直在尝试 Visual Studio 2019 的用户，并且每一步都向我们提供反馈。虽然我们在 4 月 2 日发布的正式版本仅标志着 Visual Studio 2019 版本的开始，但我们仍然鼓励每个人安装 Visual Studio 2019 RC 版并帮助我们发布迄今为止最好的Visual Studio。通过使用 Visual Studio 中的“&lt;a href=&quot;https://docs.microsoft.com/en-us/visualstudio/ide/how-to-report-a-problem-with-visual-studio-2017?view=vs-2017&quot;&gt;报告问题&lt;/a&gt;”工具或者转到 &lt;a href=&quot;https://developercommunity.visualstudio.com/&quot;&gt;Visual Studio 开发社区&lt;/a&gt;来跟踪您的问题或建议功能，请告诉我们您遇到的任何问题。&lt;/p&gt;
&lt;p&gt;我希望大家都能在 4 月 2 日在线收听 Visual Studio 2019 的虚拟发布会，这将是一个与您、与社区一起清楚的有趣活动。您还可以参加任意 4 月 2 日至 6 月 30 日期间举行的众多&lt;a href=&quot;https://visualstudio.microsoft.com/vs2019-launch/local-events/&quot;&gt;当地发布活动&lt;/a&gt;。我希望您在将来的版本中继续分享您的反馈，这样 Visual Studio 将继续成为您首选的开发环境。谢谢！&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://visualstudio.microsoft.com/downloads/&quot;&gt;下载 Visual Studio 2019 RC 版&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 28 Feb 2019 15:38:00 +0000</pubDate>
<dc:creator>Rwing</dc:creator>
<og:description>今天，我们将分享 Visual Studio 2019 的发布候选版(RC 版) - 这是在 4 月 2 日的[虚拟发布活动](https://launch.visualstudio.com/)上正式</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Rwing/p/visual-studio-2019-release-candidate-rc-now-available.html</dc:identifier>
</item>
<item>
<title>程序员的自我修养系列（二）：从元编程到元认知 - 敏捷的水</title>
<link>http://www.cnblogs.com/cnblogsfans/p/programmer_self_cultivation-2.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cnblogsfans/p/programmer_self_cultivation-2.html</guid>
<description>&lt;p&gt;我们通过做事，学习来获取知识，我们对周围事情、环境以及人的认知给我们带来了喜怒哀乐。&lt;/p&gt;
&lt;p&gt;我们事情没有做好，学习东西学不进去，人际关系没处理好，是我们认知不够，但是我们有没有想过为什么我们认知不够呢？&lt;/p&gt;
&lt;p&gt;我们很愤怒，我们的认知可能是来自于别人的某件事情，但是我们有没有想过我们自己的大脑为什么会产生愤怒，我们是否可以让我们的大脑不产生这种情绪呢？&lt;/p&gt;

&lt;h2 id=&quot;基本概念&quot;&gt;基本概念&lt;/h2&gt;
&lt;p&gt;今天跟大家分享一个知识，叫元认知。元认知，又称反省认知、监控认知、超认知、反审认知等，是指人对自己的认知过程的认知。学习者可以通过元认知来了解、检验、评估和调整自己的认知活动。一般认为，元认知可以由元认知知识、元认知体验和元认知监控三部分组成。&lt;/p&gt;
&lt;p&gt;元认知包括元认知知识和元认知控制。 元认知的实质是对认知活动的自我意识和自我调节。&lt;/p&gt;
&lt;h2 id=&quot;学习如何学习&quot;&gt;学习如何学习&lt;/h2&gt;
&lt;p&gt;最容易理解的元认知的例子就是“学习如何学习”，我们中国的教育体系从小缺乏这种元认知教育，我们大部分学生被灌输知识，强调学习，强调分数，缺少这种元认知，外面很多的培[瞎]训[扯]都没有帮助我们自己加强元认知的学习（也就是对元认知的认知）。所以我直到毕业十几年后才开始注意到这些问题，比如看到 《如何阅读一本书》才知道我们原来根本没有意识到我们一直在阅读，却没想过阅读一本如何阅读的书。&lt;/p&gt;
&lt;h2 id=&quot;自己既是观察者又是被观察者&quot;&gt;自己既是观察者，又是被观察者&lt;/h2&gt;
&lt;p&gt;我们一直用大脑来思考，但是我们却很少思考我们的大脑，比如思考如何让我们更有效的思考，我们要学会把大脑当作一个被思考的对象，那么我们就会考虑很多，比如让我们大脑更健康，适当休息等等，更多对大脑进行科学的认知，比如大脑随着我们一生其实都有物理的变化。可喜的是现在有一些《最强大脑》的节目，让我们认知到大脑的潜力，但可悲的是大部分看完最强大脑后觉得自己是傻逼。希望这个节目能够多普及一些科学和训练的方法，让大家知道很多东西通过学习和刻意练习是可以达到的。&lt;/p&gt;
&lt;h2 id=&quot;元认知在很多领域可以应用&quot;&gt;元认知在很多领域可以应用&lt;/h2&gt;
&lt;p&gt;在一些领域也有应用元的概念，比如在我们的软件领域，元编程也是一种，可以理解为“程序编写程序”，反射就是常用的一种元编程技术，在制造领域“机器控制机器”已经很常见了。 在生活中，也又很多可以应用的地方，生活很艰难，我们也可以“自己安慰自己”。&lt;/p&gt;

&lt;p&gt;思考是学习的一部分，如果你不思考你正在学习的是什么，那么你就没在学习。元认知，在中国很早就有很多大师做的很好，所有的思想家都有很好的元认知的能力，比如孔子的“三省吾身”。&lt;/p&gt;
&lt;p&gt;提高元认知的工具有很多，今天主要说一点简单的方法，让我们可以提高我们的元认知。&lt;br/&gt;我们做事情的时候，需要问自己的一些问题并回答。&lt;/p&gt;
&lt;h2 id=&quot;事前&quot;&gt;事前&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;我们之前有没有做过类似的事情？&lt;/li&gt;
&lt;li&gt;我们要达到什么目标？&lt;/li&gt;
&lt;li&gt;我们做的事情优先级是什么？&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;事中&quot;&gt;事中&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;我做的方向对吗？&lt;/li&gt;
&lt;li&gt;是在正常轨道上吗？&lt;/li&gt;
&lt;li&gt;按现在的进度可以达到目标吗？-&lt;/li&gt;
&lt;li&gt;遇到困难的时候，有谁可以帮我吗？&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;事后&quot;&gt;事后&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;哪些我们做的比较好？&lt;/li&gt;
&lt;li&gt;哪些我们还可以提高？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;另外，我们要经常反思。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;哪些是我们知道的？&lt;/li&gt;
&lt;li&gt;哪些是我们不知道的？&lt;/li&gt;
&lt;li&gt;哪些我们已经知道我们知道？&lt;/li&gt;
&lt;li&gt;哪些我们还不知道我们知道？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;元认知除了可以多提上面的一些问题之外，我们还需要锻炼元认知的效率，比如如何排除身体外部和内部的噪音，从而可以进行深度思考，可以进行thinking of thinking, 外部噪音比较容易，我们可以找一个比较安静的房间，带上防噪耳机，但是内心深处的噪音比较难排除，现在已经有很多的证实有效的方法，比如打坐、冥想和瑜伽。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/26781/201902/26781-20190228232805680-1280898552.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 28 Feb 2019 15:35:00 +0000</pubDate>
<dc:creator>敏捷的水</dc:creator>
<og:description>我们通过做事，学习来获取知识，我们对周围事情、环境以及人的认知给我们带来了喜怒哀乐。 我们事情没有做好，学习东西学不进去，人际关系没处理好，是我们认知不够，但是我们有没有想过为什么我们认知不够呢</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cnblogsfans/p/programmer_self_cultivation-2.html</dc:identifier>
</item>
<item>
<title>（译）删除未使用的前端代码 - mr_nan</title>
<link>http://www.cnblogs.com/mr-nan/p/remove-unused-code.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mr-nan/p/remove-unused-code.html</guid>
<description>&lt;p&gt;&lt;em&gt;注：本文翻译自 &lt;a title=&quot;remove-unused-code&quot; href=&quot;https://web.dev/fast/remove-unused-code&quot; target=&quot;_blank&quot;&gt;https://web.dev/fast/remove-unused-code&lt;/a&gt;，&lt;span class=&quot;web-author-information__written-by&quot;&gt;Written by Houssein Djirdeh&lt;/span&gt;。如有翻译错误请指正。&lt;/em&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　像 &lt;a title=&quot;关于npm&quot; href=&quot;https://docs.npmjs.com/about-npm/index.html&quot; target=&quot;_blank&quot;&gt;npm&lt;/a&gt; 这样的包管理器通过允许任何人轻松地下载和使用超过50万公共包来让JavaScript世界变得更好。但我们经常引入一些没有充分利用的库。为了解决这个问题，可以通过&lt;strong&gt;分析你的&lt;/strong&gt;bundle（即打包后得到的代码包，下文简称为包）来检测未使用的代码。然后，移除&lt;strong&gt;未使用的&lt;/strong&gt;和&lt;strong&gt;非必需的&lt;/strong&gt;库。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;分析包&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　查看网络请求大小的最简单方法是打开谷歌浏览器的开发者工具中的 &lt;strong&gt;Network&lt;/strong&gt; 面板，把 &lt;span&gt;Disable Cache&lt;/span&gt; 勾上，然后刷新页面。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1326584/201902/1326584-20190228224841083-850922941.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　开发者工具中的 &lt;strong&gt;Coverage&lt;/strong&gt; 标签页能告诉你有多少你的应用中的CSS和JS代码是未使用的。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1326584/201902/1326584-20190228225011451-1115759413.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　通过 Node CLI 配置一个完整的 Lighthouse 配置，一个“未使用的JavaScript”检查工具 &lt;strong&gt;Audits&lt;/strong&gt; 同样可以用来跟踪你的应用程序附带了多少未使用的代码。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1326584/201902/1326584-20190228225300765-539960573.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　如果你使用 &lt;a title=&quot;webpack&quot; href=&quot;https://webpack.js.org/&quot; target=&quot;_blank&quot;&gt;webpack&lt;/a&gt; 作为你的打包器，&lt;a title=&quot;webpack-bundle-analyzer&quot; href=&quot;https://github.com/webpack-contrib/webpack-bundle-analyzer&quot; target=&quot;_blank&quot;&gt;Webpack Bundle Analyzer&lt;/a&gt; 将帮助您研究是什么组成了这个包。像引入其它一些插件一样在 webpack 配置中引入这个插件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; module.exports =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;  plugins: [
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;     &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BundleAnalyzerPlugin()
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;  ]
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;　　尽管 webpack 通常用来构建单页应用，但其他打包器，例如 &lt;a title=&quot;parcel&quot; href=&quot;https://parceljs.org/&quot; target=&quot;_blank&quot;&gt;Parcel&lt;/a&gt; 和 &lt;a title=&quot;rollup&quot; href=&quot;https://rollupjs.org/guide/en&quot; target=&quot;_blank&quot;&gt;Rollup&lt;/a&gt; ，同样有可以用来分析包的可视化工具。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　引入这个插件后重新加载页面将呈现整个包的可缩放矩形树图。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1326584/201902/1326584-20190228225805897-1223110286.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　通过使用这种可视化工具，你可以查看包的哪些部分比其他部分大，并更好地了解导入的所有库。这有助于识别你是否正在使用一些未使用或不必要的库。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;删除未使用的库&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　在上面的矩形树图中，在 &lt;span&gt;@firebase&lt;/span&gt; 域中有相当多的包。如果你的网站只需要 firebase 的数据库组件，更改获取该库的 imports：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;import firebase from 'firebase';&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; import firebase from 'firebase/app'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; import 'firebase/database';
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;　　需要强调的是，对于较大的应用，这个过程要复杂得多。&lt;/p&gt;
&lt;p&gt;　　对于你非常确定没有在任何地方使用的看起来很神秘的包，请后退一步，查看哪些顶级依赖项正在使用它。试着找到一种方法，只从中导入你需要的组件。如果你没有使用一个库，则删除它。如果初始页面加载不需要这个库，则考虑是否可以 &lt;a title=&quot;lazy lodaed&quot; href=&quot;https://web.dev/fast/reduce-javascript-payloads-with-code-splitting&quot; target=&quot;_blank&quot;&gt;lazy loaded（延迟加载）&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;删除非必需的库&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　并不是所有的库都可以容易地分解为多个部分并有选择地导入。在这些场景中，考虑是否可以完全删除这个库。构建自定义解决方案或利用更轻量级的替代方案始终是值得考虑的选项。但是，在从应用程序中完全删除一个库之前，必须权衡这两种工作的复杂性和工作量。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;实战&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　了解更多，并将本指南付诸行动：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　&lt;a title=&quot;codelab-remove-unused-code&quot; href=&quot;https://web.dev/fast/remove-unused-code/codelab-remove-unused-code&quot; target=&quot;_blank&quot;&gt;https://web.dev/fast/remove-unused-code/codelab-remove-unused-code&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 28 Feb 2019 15:29:00 +0000</pubDate>
<dc:creator>mr_nan</dc:creator>
<og:description>注：本文翻译自 https://web.dev/fast/remove-unused-code，Written by Houssein Djirdeh。如有翻译错误请指正。 像 npm 这样的包管理器</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mr-nan/p/remove-unused-code.html</dc:identifier>
</item>
<item>
<title>使用FreeHttp强制登出微信公众号登陆状态（实现~原理） - lulianqi15</title>
<link>http://www.cnblogs.com/lulianqi/p/10446739.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lulianqi/p/10446739.html</guid>
<description>&lt;h2&gt;概述&lt;/h2&gt;
&lt;p&gt;我们使用的部分网站设计成一旦登录即不允许用户手动退出，现实场景中是没有问题的&lt;/p&gt;
&lt;p&gt;但如果是在测试或调试过程中就会有强制登出的需求&lt;/p&gt;
&lt;p&gt;如果当前使用的是PC浏览器，您或许可以通过调试模式清除保持登录信息的数据实现手动退出。&lt;/p&gt;
&lt;p&gt;但是如果当前使用的手机WEB浏览器，或者其他web嵌入的方式（比如微信公众号）退出是十分困难的&lt;/p&gt;
&lt;p&gt;下面以退出微信公众号下的京东到家为例，说明如何使用FreeHttp实现手动退出登录功能（FreeHttp 说明 &lt;a href=&quot;https://www.cnblogs.com/lulianqi/p/10428551.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/lulianqi/p/10428551.html&lt;/a&gt;）&lt;/p&gt;
&lt;h2&gt;准备工作&lt;/h2&gt;
&lt;p&gt;1：您需要为您的移动设备设置Fiddler代理，并安装证书（手机代理及证书的安装您可以通过百度查询到相关文章）&lt;/p&gt;
&lt;p&gt;2：FreeHttp的安装详见（&lt;a href=&quot;https://www.cnblogs.com/lulianqi/p/10428551.html#a00&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/lulianqi/p/10428551.html#a00&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;3：进入微信登录京东到家（测试中使用iphone6s移动设备）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/209007/201902/209007-20190227203534674-731770011.png&quot; alt=&quot;&quot; width=&quot;400&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;配置&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/209007/201902/209007-20190227203615654-863426738.png&quot; alt=&quot;&quot; width=&quot;1100&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图配置&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1：这里需要选择一个session，该session包含该站点的登录信息的cookies，您可以逐个查找，当然如果您正在对该站进行测试或调试，您应该很清楚哪条请求包含这些信息&lt;/li&gt;
&lt;li&gt;2：选择完session后，我们使用Quick Rule中的Remove Session Cookies快速创建规则&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/209007/201902/209007-20190227203811457-1676179214.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 当您选择Remove Session Cookies后会弹出上图对话框，询问您是否需要修改Set-Cookie的属性信息（如果不需要修改直接关闭即可），因为有时候当前URL的域可能不是浏览器中Cookie的Domian，这个时候您可能需要添加一个Domian来手动指定&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;3：填写过滤规则，因为能不是每次都需要告诉终端让他清除cookies（事实上只需要一次就可以），这个Url一般都是主页html等关键请求（提示：您可以直接拖动session到输入框中，完成url的输入）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/209007/201902/209007-20190227203756381-880777944.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;完成后您会发现『Response Modific』页Add Head加入了许多Set-Cookie（因为无法确认哪个cookie包含着登录信息，Remove Session Cookies会默认清除所有发现的cookie）&lt;br/&gt;当然大多数情况作为测试或开发人员您是知道页面哪个cookie标识的用户状态，如果是这样您不需要使用Remove Session Cookies删除页面下所有cookie，而可以直接使用delete cookie手动指定需要删除的cookie即可&lt;br/&gt;点击确认并设置规则生效&lt;/p&gt;
&lt;h2&gt;测试&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;现在您可以在微信里刷新京东到家当前页面&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/209007/201902/209007-20190227203837851-1943851745.png&quot; alt=&quot;&quot; width=&quot;1100&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在列表中可以看到规则已经被匹配到，查看报表信息可以看到修改已经完成（黄色高亮session表示给请求是一个被FreeHttp修改过的请求）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/209007/201902/209007-20190227204143107-1928570293.png&quot; alt=&quot;&quot; width=&quot;400&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;这个时候再次查看微信公众号里的页面，您会发现当前已经处于未登录状态。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt; 原理&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;因为Http本身是无状态的，如果要维护登录状态就需要应用层面实现。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;一般应用会将登录状态放在客户端Cookie中（这样浏览器会帮助管理维护cookie），也有一些服务API会将令牌放在自定义header或查询字符串等其他参数中（这一般出现在需要跨平台的服务中，因为不是所有应用环境都是在浏览器中，有些嵌入式设备根本没有浏览器）。&lt;/p&gt;
&lt;p&gt;这一点很好区分，您只需要对比登录状态下的请求与不登录状态下请求的全部即可&lt;/p&gt;
&lt;p&gt;我们这里是要清除微信公众号应用的登录状态（大部分都是通过cookie来做到的）&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;最后问题变成如何清除指定cookie&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们知道浏览器中的cookie是一般由请求返回头中的Set-Cookie指定的，浏览器接收到该返回头即会为指定站点创建Cookie信息（详细内容可以看这里 &lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Set-Cookie&quot; target=&quot;_blank&quot;&gt;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Set-Cookie&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;在有调试模式的浏览器中我们很容易实现，直接右键删除，或通过js删除，不过对于没有调试模式的手机终端前面的方法看起来行不通了。&lt;/p&gt;
&lt;p&gt;查看Set-Cookie规则，我们可以发现Max-Age属性（过期时间），那我们只要把过期时间设置的足够短不就可以骗过浏览器，让它删除我们想要删除的cookie&lt;/p&gt;
&lt;p&gt;注意这里Set-Cookie是响应头，所有必须浏览器先发起一个请求然后我们修改该请求的响应头，把带有Max-Age=1属性的Set-Cookie写入就可以了（Set-Cookie: name=delete by FreeHttp; Max-Age=1;Path=/）&lt;/p&gt;
&lt;p&gt;改响应的操作就直接通过Fiddler上的FreeHttp插件实现即可，操作即上文所述&lt;/p&gt;
&lt;p&gt;FreeHttp详细使用方法见（&lt;a href=&quot;https://www.cnblogs.com/lulianqi/p/10428551.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/lulianqi/p/10428551.html&lt;/a&gt;）&lt;/p&gt;



&lt;p&gt;不过使用TLS可以对其安全性进行加强（即https），&lt;/p&gt;
</description>
<pubDate>Thu, 28 Feb 2019 15:26:00 +0000</pubDate>
<dc:creator>lulianqi15</dc:creator>
<og:description>概述 我们使用的部分网站设计成一旦登录即不允许用户手动退出，现实场景中是没有问题的 但如果是在测试或调试过程中就会有强制登出的需求 如果当前使用的是PC浏览器，您或许可以通过调试模式清除保持登录信息的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lulianqi/p/10446739.html</dc:identifier>
</item>
</channel>
</rss>