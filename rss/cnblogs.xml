<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>CSharpGL(55)我是这样理解PBR的 - BIT祝威</title>
<link>http://www.cnblogs.com/bitzhuwei/p/csharpgl-55-How-I-understand-PBR.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bitzhuwei/p/csharpgl-55-How-I-understand-PBR.html</guid>
<description>&lt;p&gt;&lt;span&gt;CSharpGL(55)我是这样理解PBR的&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;PBR(Physically Based Rendering)，基于物理的渲染，据说是目前最先进的&lt;span&gt;实时&lt;/span&gt;渲染方法。它比Blinn-Phong方法的真实感更强，几乎是照片级的效果。&lt;/p&gt;
&lt;p&gt;下图就是PBR的一个例子，读者可在CSharpGL中找到。&lt;/p&gt;
&lt;p&gt;+BIT祝威+悄悄在此留下版了个权的信息说：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201905/383191-20190507145535589-1511517067.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201905/383191-20190507145036804-522108520.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;

&lt;p&gt;PBR虽然看起来很复杂，但仍旧是在解一个应用题，只要明确了已知条件和所求问题，就没有什么难以理解的了。&lt;/p&gt;
&lt;p&gt;已知条件如下：&lt;/p&gt;
&lt;p&gt;对于不透明的三维模型（Cube、Sphere、Teapot等等任何三维模型）上的任意一点，我们知道它的&lt;span&gt;位置&lt;/span&gt;vec3 p、&lt;span&gt;法线&lt;/span&gt;向量vec3 N和&lt;span&gt;纹理坐标&lt;/span&gt;vec2 texCoord。当&lt;span&gt;观察者&lt;/span&gt;（你，我，摄像机等等）从某个位置观察三维模型上的这个点p时，从点p到观察者的向量记作vec3 v或vec3 wo。照射到点p的每一束&lt;span&gt;光线&lt;/span&gt;vec3 Li，根据某种规则，都会被点p反射到很多方向上去。观察者看到的点p的颜色，就是所有恰好反射到v或wo方向上的光线的颜色。&lt;/p&gt;
&lt;p&gt;（注意，为论述方便，在本文中，Li是&lt;span&gt;从&lt;/span&gt;点p到入射光源的向量；v和wo是&lt;span&gt;从&lt;/span&gt;点p&lt;span&gt;到&lt;/span&gt;观察者方向的向量；所有向量的长度都是1。）&lt;/p&gt;
&lt;p&gt;+BIT祝威+悄悄在此留下版了个权的信息说：&lt;/p&gt;
&lt;p&gt; 所求问题：&lt;/p&gt;
&lt;p&gt;观察者看到的颜色是什么？（用Lo(p, wo)表示）&lt;/p&gt;
&lt;p&gt;解答：这个问题目前是不可能100%完美解决的，所以只给出各种&lt;span&gt;近似&lt;/span&gt;的计算模型，凑合着用。&lt;/p&gt;

&lt;h2&gt;Blinn-Phong模型&lt;/h2&gt;
&lt;p&gt;Blinn-Phong模型就是其中一种近似方案。&lt;/p&gt;
&lt;p&gt;（注意，这里“Blinn-Phong模型”中的“模型”与“三维模型”中的“模型”是两个不同的概念。“Blinn-Phong模型”中的“模型”是对光照现象的某种计算方法。“三维模型”中的“模型”指的是三维空间中的物体的形状。）&lt;/p&gt;
&lt;p&gt;Blinn-Phong将物体反射到每一个方向上的光，都分为漫反射diffuse和镜面反射specular这2个部分。它处理的光源，一般是平行光、点光源、聚光灯这种，从某&lt;span&gt;一个点&lt;/span&gt;发射光的光源。&lt;/p&gt;
&lt;p&gt;为什么在PBR的文章里要介绍Blinn-Phong？因为PBR可以被（我）认为是Blinn-Phong的进化版本。&lt;/p&gt;
&lt;p&gt;在Blinn-Phong中，漫反射强度由N、Li共同决定：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;float&lt;/span&gt; diffuse = dot(N, Li);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;镜面反射强度由N、Li、v共同决定：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;float&lt;/span&gt; specular = dot(N, normalize(Li + v));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（注意，这里的式子没有考虑diffuse和specular小于0的情况，这是为了突出重点。）&lt;/p&gt;
&lt;p&gt;这2种反射光加起来，配合物体的材质和光源的颜色，就得到了物体在点p处被观察者看到的颜色：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
vec3 fragColor = diffuse * material.diffuse * light.diffuse + specular * material.specular * light.specular;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然，最后还要加上个环境光（用常量表示）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
vec3 fragColor += ambientColor;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;有的Blinn-Phong实现可能与此稍有不同：有的将ambient和diffuse加在一起，有的用纹理(Texture)表示物体的材质，等等。但是思路都是一样的，不要纠结这里。&lt;/p&gt;
&lt;p&gt;+BIT祝威+悄悄在此留下版了个权的信息说：&lt;/p&gt;
&lt;h2&gt;Blinn-Phong的缺点&lt;/h2&gt;
&lt;p&gt;Blinn-Phong是个很不错的模型，但是它有一个比较明显的缺点：反射光的总量可能&lt;span&gt;大于&lt;/span&gt;入射光的总量。也就是说，有时候物体反射的光的总强度居然比入射光还要大。这是不符合物理实际的。&lt;/p&gt;
&lt;p&gt;例如，当Li、v都等于N（即入射光和观察者都与法线方向重合）时，diffuse=1，specular=1，两者相加=2&amp;gt;1。我们知道，Blinn-Phong将物体反射出来的每一个方向上的光，都分为漫反射diffuse和镜面反射specular这2个部分。即使物体能够100%反射所有的入射光，(diffuse+specular)最多也就是1而已，不可能超过1。&lt;/p&gt;
&lt;p&gt;也就是说，Blinn-Phong虽然能保证diffuse和specular各自不超过1，但是不能保证(diffuse+specular)也不超过1。&lt;/p&gt;
&lt;p&gt;PBR解决了这个问题。&lt;/p&gt;

&lt;p&gt;PBR不仅保证了 &lt;span class=&quot;cnblogs_code&quot;&gt;(diffuse+specular)&amp;lt;=&lt;span&gt;1&lt;/span&gt;&lt;/span&gt; ，还有别的优点：&lt;/p&gt;
&lt;p&gt;它能把周围环境当作一个整体的光源，这扩大了光源的范围。&lt;/p&gt;
&lt;p&gt;它以真实的物理量为参数，因而对美工更友好。&lt;/p&gt;
&lt;p&gt;它表现出照片级的真实感，且物体看起来就像本来就属于场景中一样。&lt;/p&gt;
&lt;h2&gt;PBR模型&lt;/h2&gt;
&lt;p&gt;PBR也将物体反射到每个方向上的光，都分为漫反射diffuse和镜面反射specular这2个部分。&lt;/p&gt;
&lt;p&gt;同时，它对这2种反射光的形成机制给出了自己的解释：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201905/383191-20190507145050049-877431302.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201905/383191-20190507145055837-1690606169.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 如图所示，一些入射光Li打在点p上。仔细想想，点p实际上不是数学意义上的点，而是由很多微小的平面（长度大于光的波长，小于像素，简称&lt;span&gt;微平面&lt;/span&gt;）组成的一小块“褶子”（褶皱程度就是粗糙度roughness）。入射光Li打在褶子上，一部分会被褶子直接反射，另一部分会被吸收进褶子内部。直接反射的，就是specular部分；吸收后，在褶子内部经过若干次碰撞（组成褶子的原子、分子会不断地反射或吸收剩下的光），有一些光会再次被反射出来，这就是diffuse部分。&lt;/p&gt;
&lt;p&gt;PBR模型的关键，就在于光的波长、微平面的大小、像素的大小这三者的&lt;span&gt;大小关系&lt;/span&gt;。由于光的波长远远小于微平面的尺寸，所以就不用考虑光的衍射等现象。由于微平面的尺寸远远小于一个像素，所以可以将一个个像素视为一个个“褶子”。这样一来，虽然入射光的diffuse部分，其出射位置与入射位置不完全相同，但仍旧在同一个像素范围内，所以可以视作位置相同。&lt;/p&gt;
&lt;p&gt;（有人会说，会不会有的光在褶子内部被反射的很远，最终超出了一个像素的范围呢？答案是，会。那么，这种情况如何处理呢？PBR的答案是，&lt;span&gt;忽略不计&lt;/span&gt;。）&lt;/p&gt;
&lt;p&gt;“褶子”只是一个称呼，事实上完美光滑的“褶子”，即微平面的排列完全平整，一点都不褶（光学平滑）是存在的，你可以在高端望远镜上找到。当然了，这是微平面级别的完美光滑，不是原子级别的。原子级别的完美光滑，据我所知还做不到。&lt;/p&gt;
&lt;p&gt;+BIT祝威+悄悄在此留下版了个权的信息说：&lt;/p&gt;
&lt;p&gt;PBR认为 &lt;span class=&quot;cnblogs_code&quot;&gt;(diffuse+specular)==&lt;span&gt;1&lt;/span&gt;&lt;/span&gt; 始终成立。那么，先算出其中一个，自然就得知另一个了（1-specular）。&lt;/p&gt;
&lt;h2&gt;Specular部分&lt;/h2&gt;
&lt;h3&gt;菲涅耳方程F&lt;/h3&gt;
&lt;p&gt;当你站在清澈的海边、河边、湖边，低头向下看时，能够看到水面下的沙石泥土，但平视远处的水面时，就只能看到强烈的反光，很难看到水面下的景象。这种现象被称为菲涅耳(Fresnel)效应。更多图文介绍可以参考（&lt;a href=&quot;http://blog.sina.com.cn/s/blog_798bec050100rigq.html&quot;&gt;http://blog.sina.com.cn/s/blog_798bec050100rigq.html&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201905/383191-20190507145102783-1073390569.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 这种现象说明，入射光被拆分后，specular所占的比例，与入射光Li和观察者v的方向有关。当然，它还与物质的材质有关。菲涅耳方程(Fresnel Equation)给出了一个计算specular的公式。不过那玩意计算起来比较费时，业界一般用它的一个近似版本：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201905/383191-20190507145108830-992937554.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; vec3 fresnelSchlick(&lt;span&gt;float&lt;/span&gt;&lt;span&gt; cosTheta, vec3 F0)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; F0 + (&lt;span&gt;1.0&lt;/span&gt; - F0) * pow(&lt;span&gt;1.0&lt;/span&gt; - cosTheta, &lt;span&gt;5.0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然，其他版本的F函数也是存在的。&lt;/p&gt;
&lt;p&gt;其中的cosTheta =  &lt;span class=&quot;cnblogs_code&quot;&gt;max(&lt;span&gt;0&lt;/span&gt;, dot(v, normalize(v + Li)))&lt;/span&gt; 。可见“它与入射光Li和观察者v的方向有关”，此言不虚。&lt;/p&gt;
&lt;p&gt;其中的F0就是物质的材质属性。每种材质都一个对应的F0常数。&lt;/p&gt;
&lt;p&gt;其返回结果为vec3 specular，就是说，黄金、白银、钢铁、巧克力，材质对光的RGB通道的反射能力不同。嗯这很科学。&lt;/p&gt;
&lt;p&gt;有了specular，当然就有了 &lt;span class=&quot;cnblogs_code&quot;&gt;vec3 diffuse = vec3(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;) - specular&lt;/span&gt; 。我们稍后再讨论diffuse。&lt;/p&gt;
&lt;h3&gt;几何函数G&lt;/h3&gt;
&lt;p&gt;菲涅耳公式给出的，是在入射光Li和观察者v条件下，specular所占的比例。但是，褶子是粗糙的，会遮挡住specular的一部分。&lt;/p&gt;
&lt;p&gt;+BIT祝威+悄悄在此留下版了个权的信息说：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201905/383191-20190507145113933-337794204.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 因此，需要计算出没有被遮挡的比例，这就是几何函数(Geometry Function)：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201905/383191-20190507145118589-809914796.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201905/383191-20190507145122033-124936631.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;（K&lt;sub&gt;direct&lt;/sub&gt;是指平行光、点光源、聚光灯这样的光源应采用的公式；K&lt;sub&gt;IBL&lt;/sub&gt;是将整个图片作为光源时应采用的公式。α表示表面粗糙度）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; GeometrySchlickGGX(&lt;span&gt;float&lt;/span&gt; NdotV, &lt;span&gt;float&lt;/span&gt;&lt;span&gt; roughness)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;float&lt;/span&gt; r = (roughness + &lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;float&lt;/span&gt; k = (r*r) / &lt;span&gt;8.0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;float&lt;/span&gt; nom   =&lt;span&gt; NdotV;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;float&lt;/span&gt; denom = NdotV * (&lt;span&gt;1.0&lt;/span&gt; - k) +&lt;span&gt; k;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; nom /&lt;span&gt; denom;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ----------------------------------------------------------------------------&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; GeometrySmith(vec3 N, vec3 V, vec3 L, &lt;span&gt;float&lt;/span&gt;&lt;span&gt; roughness)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;float&lt;/span&gt; NdotV = max(dot(N, V), &lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;float&lt;/span&gt; NdotL = max(dot(N, L), &lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;float&lt;/span&gt; ggx2 =&lt;span&gt; GeometrySchlickGGX(NdotV, roughness);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;float&lt;/span&gt; ggx1 =&lt;span&gt; GeometrySchlickGGX(NdotL, roughness);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; ggx1 *&lt;span&gt; ggx2;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然，其他版本的G函数也是存在的。&lt;/p&gt;
&lt;p&gt;+BIT祝威+悄悄在此留下版了个权的信息说：&lt;/p&gt;
&lt;p&gt;从参数可知，遮蔽比例与入射光方向Li、法线N、观察者方向v和粗糙度roughness都是有关的。&lt;/p&gt;
&lt;h3&gt;法线分布函数D&lt;/h3&gt;
&lt;p&gt;那么，那些没有被遮蔽的specular部分，就全部进入观察者的眼中了吗？并没有。在这些顺利逃出来的specular中，只有那些法线方向与(V+L)相同的微平面反射的光，才能进入观察者眼中。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201905/383191-20190507145129129-190021877.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;法线分布函数(Normal Distribution Function)就给出了这个比例：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201905/383191-20190507145132864-1533207121.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; （α表示表面粗糙度）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; DistributionGGX(vec3 N, vec3 H, &lt;span&gt;float&lt;/span&gt;&lt;span&gt; roughness)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;float&lt;/span&gt; a = roughness*&lt;span&gt;roughness;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;float&lt;/span&gt; a2 = a*&lt;span&gt;a;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;float&lt;/span&gt; NdotH = max(dot(N, H), &lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;float&lt;/span&gt; NdotH2 = NdotH*&lt;span&gt;NdotH;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;float&lt;/span&gt; nom   =&lt;span&gt; a2;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;float&lt;/span&gt; denom = (NdotH2 * (a2 - &lt;span&gt;1.0&lt;/span&gt;) + &lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     denom = PI * denom *&lt;span&gt; denom;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; nom /&lt;span&gt; denom;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然，其他版本的D函数也是存在的。&lt;/p&gt;
&lt;p&gt;经过FGD的层层筛选，specular部分就很接近物理真实了。&lt;/p&gt;
&lt;h2&gt;漫反射常量&lt;/h2&gt;
&lt;p&gt;diffuse部分相对简单些，用一个常数c表示材质本身的颜色，与diffuse相乘即可。当然，这也是一种近似，其他的近似函数也是存在的。&lt;/p&gt;
&lt;h2&gt;反射率方程&lt;/h2&gt;
&lt;p&gt;将上面的各种函数综合起来，再配合一些数学系数，总的PBR公式（反射率方程）就是这样：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201905/383191-20190507145140704-1839642722.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201905/383191-20190507145144522-459272765.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201905/383191-20190507145147925-1803234288.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201905/383191-20190507145151208-1403175858.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;总结一下就是：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201905/383191-20190507145154887-1946587767.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 反射率方程左侧的意思是：观察者在wo方向上观察点p，他所看到的光的颜色Lo是多少？&lt;/p&gt;
&lt;p&gt;反射率方程右侧：Kd是diffuse所占的比例，Ks是specular所占的比例（注意Kd+Ks=1）；c是材质的颜色，可以是单一的颜色vec3(r, g, b)，也可以是用一个材质贴图描述texture(texMaterial, texCoord)；π是数学常数；n是点p的法线向量；wi是某个入射光线的方向；DFG是上文所述的法线分布函数、菲涅耳函数和几何函数；Li(p, wi)是在wi方向上照射到点p的入射光的颜色；最左边那个长长的S和Ω符号，加上最右边的dwi符号，是积分的意思，Ω符号表示在法线n方向上的&lt;span&gt;半球&lt;/span&gt;范围内积分。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201905/383191-20190507145159652-553298857.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 右侧的意思是：将所有入射光Li与其约束比例相乘，再加起来，就是我们应用题的答案。&lt;/p&gt;
&lt;p&gt;本质上这仍旧是将diffuse和specular分别计算后再相加而已，只不过PBR对specular和diffuse的量都做了限制，从而保证其和不超过1。&lt;/p&gt;
&lt;p&gt;其中的fr部分就是常说的BRDF函数。可见它包含了各种玩意，对物体反射光的量进行约束。&lt;/p&gt;
&lt;p&gt;这个公式是如何推导出来的？我不知道，暂时不是解决这个问题的时候。作为工程师，我先理解它，实现它，是第一要务。之后再从理论上推导它。&lt;/p&gt;
&lt;p&gt;反射率方程是不能直接用shader来写的，因为达不到实时的性能。所以我们一步步做简化。&lt;/p&gt;
&lt;p&gt;首先，右侧可以从加法的位置上拆分为diffuse部分和specular部分：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201905/383191-20190507145204250-1727505738.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 这样，就可以分别去研究如何实现这2个部分，最后简单加起来就行了。&lt;/p&gt;
&lt;h3&gt;实现diffuse部分&lt;/h3&gt;
&lt;p&gt;首先，diffuse部分可以将一些常数提取出来：&lt;/p&gt;
&lt;p&gt;+BIT祝威+悄悄在此留下版了个权的信息说：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201905/383191-20190507145208152-888715316.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 现在，积分内部的含义是，在半球范围内，将所有方向上的入射光向量分别与法线相乘，再加起来。这个积分在shader中当然要用&lt;span&gt;离散的&lt;/span&gt;方式计算。半球嘛，立体的，所以分别在水平方向和竖直方向上进行累加比较方便。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201905/383191-20190507145212827-2022579882.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 此时，我们就可以把上述方程稍微变形下：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201905/383191-20190507145217071-1840561826.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 然后变为对应的离散的形式：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201905/383191-20190507145220787-313043935.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 从原来的积分形式变为离散形式，使用了&lt;span&gt;蒙特卡罗&lt;/span&gt;积分原理。感兴趣的同学可以自行搜索研究一下。本文中，只要知道可以这么转换就行了。&lt;/p&gt;
&lt;p&gt;在shader中表示这个离散公式的代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; #version &lt;span&gt;330&lt;/span&gt;&lt;span&gt; core
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;out&lt;/span&gt;&lt;span&gt; vec4 FragColor;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;span&gt; vec3 WorldPos;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;uniform samplerCube environmentMap;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; PI = &lt;span&gt;3.14159265359&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main()
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;{        
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     vec3 N =&lt;span&gt; normalize(WorldPos);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     vec3 irradiance = vec3(&lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;);   
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; tangent space calculation from origin point&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;     vec3 up    = vec3(&lt;span&gt;0.0&lt;/span&gt;, &lt;span&gt;1.0&lt;/span&gt;, &lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     vec3 right =&lt;span&gt; cross(up, N);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     up         =&lt;span&gt; cross(N, right);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;        
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;float&lt;/span&gt; sampleDelta = &lt;span&gt;0.025&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;float&lt;/span&gt; nrSamples = &lt;span&gt;0.0f&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;float&lt;/span&gt; phi = &lt;span&gt;0.0&lt;/span&gt;; phi &amp;lt; &lt;span&gt;2.0&lt;/span&gt; * PI; phi +=&lt;span&gt; sampleDelta)
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;float&lt;/span&gt; theta = &lt;span&gt;0.0&lt;/span&gt;; theta &amp;lt; &lt;span&gt;0.5&lt;/span&gt; * PI; theta +=&lt;span&gt; sampleDelta)
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; spherical to cartesian (in tangent space)&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;             vec3 tangentSample = vec3(sin(theta) * cos(phi),  sin(theta) *&lt;span&gt; sin(phi), cos(theta));
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; tangent space to world&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;             vec3 sampleVec = tangentSample.x * right + tangentSample.y * up + tangentSample.z *&lt;span&gt; N; 
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt;             irradiance += texture(environmentMap, sampleVec).rgb * cos(theta) *&lt;span&gt; sin(theta);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             nrSamples++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;     irradiance = PI * irradiance * (&lt;span&gt;1.0&lt;/span&gt; / &lt;span&gt;float&lt;/span&gt;&lt;span&gt;(nrSamples));
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;     
&lt;span&gt;37&lt;/span&gt;     FragColor = vec4(irradiance, &lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码中的双重for循环，就是在离散地计算积分值。最后得到的irradiance，再乘以Kd*c，就是diffuse部分的颜色值了。这个值加上接下来马上要讲解的specular部分的颜色值，就是应用题的答案。&lt;/p&gt;
&lt;p&gt;+BIT祝威+悄悄在此留下版了个权的信息说：&lt;/p&gt;
&lt;p&gt;所有Fragment Shader的计算结果都会保存到一个立方体贴图中。这个贴图叫做irradianceMap。这个计算过程叫做“卷积”。&lt;/p&gt;
&lt;p&gt;注意，计算diffuse部分的输入数据中，用到了一个立方体贴图samplerCube environmentMap，它其实就是物体所处于的环境，也叫天空盒。这里实际上就是将整个天空盒当作一个大光源来处理了。下图展示了将输入的立方体贴图（左侧）卷积后得到的irradianceMap（右侧）：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201905/383191-20190507145232447-707837660.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 另外，这里将点p选在原点(0, 0, 0)上，稍后计算specular部分时也会这样设置。读者会问，那就只能描述在原点处的光照喽？也不尽然。只要在场景中的其他关键位置上也分别执行一遍PBR公式，就可以在整个场景中安排好这种“探针”。计算光照时，将距离物体最近的那几个探针的颜色加权平均一下，就可以得到需要的颜色了。本文不讨论“探针”的问题。&lt;/p&gt;
&lt;h3&gt;实现specular部分&lt;/h3&gt;
&lt;p&gt;现在，提取出specular部分：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201905/383191-20190507145238442-1688132569.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 这个积分里有wi和wo两个变量，如果要离散地计算，就得对wi和wo的所有组合都算一遍。这是达不到实时要求的。Epic游戏公司给了一个近似公式，可以解决这个问题：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201905/383191-20190507145242888-1739069308.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 左边的积分和上文的diffuse部分很相似，不同之处是，要对不同的粗糙度分别计算结果，并依次保存到一个立方体贴图的不同mipmap层上（越高的粗糙度保存在越高（分辨率小）的mipmap层上）。这个过程也是卷积，得到的贴图是个多mipmap层的立方体贴图，叫做prefilterMap。下图展示了一个被卷积好了的prefilterMap：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201905/383191-20190507145248282-1024135148.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 右边的积分，以n与wi的乘积为参数1，以粗糙度为参数2，进行卷积，得到一个普通的二维纹理，叫做brdfLUT。下图就是：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201905/383191-20190507145253188-409443541.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;+BIT祝威+悄悄在此留下版了个权的信息说：&lt;/p&gt;
&lt;p&gt; 分别从卷积贴图里采样，再算到公式里就得到specular部分的颜色了。&lt;/p&gt;
&lt;h3&gt;贴图总结&lt;/h3&gt;
&lt;p&gt;首先，我们需要从一个*.hdr文件加载二维纹理texHDR。&lt;/p&gt;
&lt;p&gt;然后，将texHDR转换为天空盒纹理sampleCube environmentMap。&lt;/p&gt;
&lt;p&gt;然后，用environmentMap分别生成irradianceMap和多mipmap层的prefilterMap。&lt;/p&gt;
&lt;p&gt;最后，brdfLUT是独立生成的，与别的贴图无关。&lt;/p&gt;
&lt;p&gt;只需加载其他的*.hdr文件，就可以将物体置于其他天空盒下。PBR将天空盒视作光源，照射物体。这就是PBR能让物体保持融入各个场景中原因。&lt;/p&gt;
&lt;p&gt;下图是我在CSharpGL中使用的newport_loft.hdr加载后的样子：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201905/383191-20190507145300747-220295713.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 这样的样式，在头顶和脚底方向上的数据损失会多一点。不过，一般用户关注的都是平视方向，所以没问题。&lt;/p&gt;

&lt;p&gt;PBR是对Blinn-Phong的一种极大的改进。它用几个贴图帮助求解积分，所以显得难以理解，难以实现。其实也就那么回事。&lt;/p&gt;

&lt;p&gt;更新取消&lt;/p&gt;
</description>
<pubDate>Tue, 07 May 2019 07:09:00 +0000</pubDate>
<dc:creator>BIT祝威</dc:creator>
<og:description>CSharpGL(55)我是这样理解PBR的 简介 PBR(Physically Based Rendering)，基于物理的渲染，据说是目前最先进的实时渲染方法。它比Blinn-Phong方法的真实</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bitzhuwei/p/csharpgl-55-How-I-understand-PBR.html</dc:identifier>
</item>
<item>
<title>.NET 的未来：.NET 5 - hez2010</title>
<link>http://www.cnblogs.com/hez2010/p/10825492.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hez2010/p/10825492.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;不知不觉中，.NET Framework 已经更新到 4.8，.NET Core 也更新到了 3.0 版本。那么 .NET 的未来怎么样呢？&lt;/p&gt;
&lt;h2&gt;计划&lt;/h2&gt;
&lt;p&gt;2019 年 Build 大会上，微软宣布下一个 .NET 版本（继 .NET Core 3.0 和 .NET Framework 4.8 之后）将是 .NET 5，统一 .NET Framework 和 .NET Core，从此只有一个 .NET，可以用来开发Windows，Linux，macOS，iOS，Android，tvOS，watchOS 和 WebAssembly 等等。&lt;/p&gt;
&lt;p&gt;.NET 5 将基于 .NET Core 和 Mono 的最佳实践构建出一个平台，用于所有现代 .NET 平台的开发。&lt;br/&gt;&lt;img src=&quot;https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/05/dotnet5_platform.png&quot; alt=&quot;.NET 平台&quot; width=&quot;724&quot; height=&quot;386&quot;/&gt;&lt;br/&gt;.NET 5 将于 2020 年正式发布，.NET 6 将于 2021 年正式发布，以此类推。其中偶数版本号为 LTS 版本。&lt;/p&gt;
&lt;h2&gt;继承&lt;/h2&gt;
&lt;p&gt;.NET 5 将制造一个可在任何地方使用的 .NET 运行时和框架, 并具有统一的运行时行为和开发人员体验，并且通过充分利用 .NET Core、.NET Framework、Xamarin 和 Mono 来扩展 .NET 的功能，最重要的是，全部开源，官方和社区共同参与扩展和改进。&lt;/p&gt;
&lt;p&gt;.NET 5 仍然是开源的、跨平台的、高性能、支持旁加载安装模式和命令行操作等等，并与 Visual Studio、Visual Studio for Mac 和 Visual Studio Code 集成。&lt;/p&gt;
&lt;p&gt;.NET 5 是基于 .NET Core 和 Mono 出来的，也就是说不存在断代的问题，是 .NET Core 的一个升级，同时改个名字顺便统一一下生态，也就是说您现有的 .NET Core 项目届时应当可以无缝升级，就像从 .NET Core 2 升级到 .NET Core 3 那样。&lt;/p&gt;
&lt;h2&gt;创新&lt;/h2&gt;
&lt;p&gt;新的 .NET 5 中，你可以选择使用 Mono 或 CoreCLR 运行时，前者主要针对移动设备、游戏平台和 WebAssembly，后者主要针对云服务、物联网、机器学习以及 Windows Desktop 等。&lt;/p&gt;
&lt;p&gt;另外，&lt;strong&gt;.NET 5 将在所有平台上提供与 Java 的互操作性，和在多个系统上的 Objective-C 和 Swift 的互操作性&lt;/strong&gt;。&lt;/p&gt;
&lt;h2&gt;成就&lt;/h2&gt;
&lt;h3&gt;高性能、高生产力&lt;/h3&gt;
&lt;p&gt;.NET 依赖 JIT 将 IL 转化为优化的机器代码，构建了业界领先的基于 JIT 的托管运行时，具有非常高的性能，提升开发人员的体验。&lt;/p&gt;
&lt;p&gt;JIT 非常适合长期运行的云和客户端方案，它能够生成针对特定机器配置的代码，包括特定的 CPU 指令。JIT 还可以在运行时重新生成方法，可以进行快速的 JIT，并且针对频繁调用的方法生成高质量代码（即分层编译）。&lt;/p&gt;
&lt;p&gt;从 Techpower 基准测试上 &lt;a href=&quot;http://asp.net/&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;ASP.NET&lt;/a&gt; Core 运行的更快也是 JIT 的强大力量和在 CoreCLR 上投资的很好的例子。&lt;/p&gt;
&lt;p&gt;大多数 .NET 5 工作场景的默认将使用基于 JIT 的 CoreCLR 运行时。不过 iOS 和 WebAssembly 例外，因为它们都需要 AOT 执行原生编译。&lt;/p&gt;
&lt;h3&gt;启动快，占用小&lt;/h3&gt;
&lt;p&gt;Mono 项目的大部分精力都集中在移动和游戏机上。该项目的一个关键功能和结果是基于业界领先的 LLVM 编译器项目的 .NET AOT 编译器。Mono AOT 编译器允许将 .NET 代码内置到一个可以在计算机上运行的原生代码可执行文件中，就像 C++ 代码一样。AOT 编译的应用可以在资源十分有限的地方中高效运行。&lt;/p&gt;
&lt;p&gt;Blavor 项目 （WebAssembly） 已经在使用 Mono AOT，这将是最早过渡到 .NET 5 的项目之一。&lt;/p&gt;
&lt;p&gt;有两种类型的 AOT 解决方案:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;需要 100% AOT 编译的解决方案。&lt;/li&gt;
&lt;li&gt;大多数代码是 AOT 编译的解决方案, 但 JIT 或解释器可用于 AOT 不友好的代码 (比如泛型)。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Mono AOT 支持这两种情况。出于安全原因，苹果对 iOS 和一些游戏机需要第一种 AOT。第二种方法是更好的选择，因为它即具 AOT 优点同时还能避免各种缺点。&lt;/p&gt;
&lt;p&gt;.NET Native 是用于 Windows UWP 应用程序的 AOT 编译器，也是上面列出的第一种 AOT 类型的示例。在这个实现里限制了 .NET API 和可以使用的功能。微软从这一经验中了解到，AOT 解决方案需要涵盖 .NET API 和模式的所有方面。&lt;/p&gt;
&lt;p&gt;在 iOS、WebAssembly 和一些游戏里将仍然采用 AOT 编译。而对于更需要快速启动或低占用空间的应用程序，AOT 编译将成为一个可选项。&lt;/p&gt;
&lt;h2&gt;未来&lt;/h2&gt;
&lt;p&gt;.NET 5 将融合 .NET Framework、.NET Core、Mono、Xamarin 等优点构建出一个统一的 .NET 平台，开发人员可以在此平台上用 C#、&lt;a href=&quot;http://vb.net/&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;VB.NET&lt;/a&gt;、F#、XAML 语言、使用相同的 API 开发针对任何系统、任何架构、任何形态的应用程序，并且代码和库均可以通过 .NET Standard 共享。&lt;/p&gt;
&lt;h2&gt;参考资料&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://devblogs.microsoft.com/dotnet/introducing-net-5&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;https://devblogs.microsoft.com/dotnet/introducing-net-5&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 07 May 2019 06:57:00 +0000</pubDate>
<dc:creator>hez2010</dc:creator>
<og:description>前言 不知不觉中，.NET Framework 已经更新到 4.8，.NET Core 也更新到了 3.0 版本。那么 .NET 的未来怎么样呢？ 计划 2019 年 Build 大会上，微软宣布下一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hez2010/p/10825492.html</dc:identifier>
</item>
<item>
<title>Go语言调度器之创建main goroutine(13) - 爱写程序的阿波张</title>
<link>http://www.cnblogs.com/abozhang/p/10825342.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/abozhang/p/10825342.html</guid>
<description>&lt;p&gt;本文是《Go语言调度器源代码情景分析》系列的第13篇，也是第二章的第3小节。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;上一节我们分析了调度器的初始化，这一节我们来看程序中的第一个goroutine是如何创建的。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;创建main goroutine&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;接上一节，schedinit完成调度系统初始化后，返回到rt0_go函数中开始调用newproc() 创建一个新的goroutine用于执行mainPC所对应的runtime·main函数，看下面的代码：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;runtime/asm_amd64.s : 197&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# create a new goroutine to start program
MOVQ  $runtime·mainPC(SB), AX# entry，mainPC是runtime.main
# newproc的第二个参数入栈，也就是新的goroutine需要执行的函数
PUSHQ  AX         # AX = &amp;amp;funcval{runtime·main},

# newproc的第一个参数入栈，该参数表示runtime.main函数需要的参数大小，因为runtime.main没有参数，所以这里是0
PUSHQ  $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;
&lt;span&gt;CALL&lt;/span&gt;&lt;span&gt;  runtime·newproc(SB) # 创建main goroutine
POPQ  AX
POPQ  AX

# start this M
&lt;/span&gt;&lt;span&gt;CALL&lt;/span&gt;&lt;span&gt;  runtime·mstart(SB)  # 主线程进入调度循环，运行刚刚创建的goroutine

# 上面的mstart永远不应该返回的，如果返回了，一定是代码逻辑有问题，直接abort
&lt;/span&gt;&lt;span&gt;CALL&lt;/span&gt;&lt;span&gt;  runtime·abort(SB)// mstart should never return
&lt;/span&gt;&lt;span&gt;RET&lt;/span&gt;&lt;span&gt;

DATA  runtime·mainPC+&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;(SB)/&lt;span&gt;8&lt;/span&gt;&lt;span&gt;,$runtime·main(SB)
GLOB  Lruntime·mainPC(SB),RODATA,$&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在后面的分析过程中我们会看到这个runtime.main最终会调用我们写的main.main函数，在分析runtime·main之前我们先把重点放在newproc这个函数上。&lt;/p&gt;
&lt;p&gt;newproc函数用于创建新的goroutine，它有两个参数，先说第二个参数fn，新创建出来的goroutine将从fn这个函数开始执行，而这个fn函数可能也会有参数，newproc的第一个参数正是fn函数的参数以字节为单位的大小。比如有如下go代码片段：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
func start(a, b, c int64) {
   ......
}

func main() {
   go start(1, 2, 3)
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;编译器在编译上面的go语句时，就会把其替换为对newproc函数的调用，编译后的代码逻辑上等同于下面的伪代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
func main() {
    push 0x3
    push 0x2
    push 0x1
    runtime.newproc(24, start)
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;编译器编译时首先会用几条指令把start函数需要用到的3个参数压栈，然后调用newproc函数。因为start函数的3个int64类型的参数共占24个字节，所以传递给newproc的第一个参数是24，表示start函数需要24字节大小的参数。&lt;/p&gt;
&lt;p&gt;那为什么需要传递fn函数的参数大小给newproc函数呢？原因就在于newproc函数将创建一个新的goroutine来执行fn函数，而这个新创建的goroutine与当前这个goroutine会使用不同的栈，因此就需要在创建goroutine的时候把fn需要用到的参数先从当前goroutine的栈上拷贝到新的goroutine的栈上之后才能让其开始执行，而newproc函数本身并不知道需要拷贝多少数据到新创建的goroutine的栈上去，所以需要用参数的方式指定拷贝多少数据。&lt;/p&gt;
&lt;p&gt;了解完这些背景知识之后，下面我们开始分析newproc的代码。newproc函数是对newproc1的一个包装，这里最重要的准备工作有两个，一个是获取fn函数第一个参数的地址（代码中的argp），另一个是使用systemstack函数切换到g0栈，当然，对于我们这个初始化场景来说现在本来就在g0栈，所以不需要切换，然而这个函数是通用的，在用户的goroutine中也会创建goroutine，这时就需要进行栈的切换。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;runtime/proc.go : 3232&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
// Create a new g running fn with siz bytes of arguments.
// Put it on the queue of g's waiting to run.
// The compiler turns a go statement into a call to this.
// Cannot split the stack because it assumes that the arguments
// are available sequentially after &amp;amp;fn; they would not be
// copied if a stack split occurred.
//go:nosplit
func newproc(siz int32, fn *funcval) {
   //函数调用参数入栈顺序是从右向左，而且栈是从高地址向低地址增长的
    //注意：argp指向fn函数的第一个参数，而不是newproc函数的参数
   //参数fn在栈上的地址+8的位置存放的是fn函数的第一个参数
    argp := add(unsafe.Pointer(&amp;amp;fn), sys.PtrSize)
    gp:= getg()  //获取正在运行的g，初始化时是m0.g0
   
   //getcallerpc()返回一个地址，也就是调用newproc时由call指令压栈的函数返回地址，
   //对于我们现在这个场景来说，pc就是CALLruntime·newproc(SB)指令后面的POPQ AX这条指令的地址
    pc := getcallerpc()
   
   //systemstack的作用是切换到g0栈执行作为参数的函数
   //我们这个场景现在本身就在g0栈，因此什么也不做，直接调用作为参数的函数
    systemstack(func() {
        newproc1(fn, (*uint8)(argp), siz, gp, pc)
    })
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;newproc1函数的第一个参数fn是新创建的goroutine需要执行的函数，注意这个fn的类型是funcval结构体类型，其定义如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
type  funcval struct{
    fn uintptr
    // variable-size, fn-specific data here
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;newproc1的第二个参数argp是fn函数的第一个参数的地址，第三个参数是fn函数的参数以字节为单位的大小，后面两个参数我们不用关心。这里需要注意的是，newproc1是在g0的栈上执行的。该函数很长也很重要，所以我们分段来看。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;runtime/proc.go : 3248&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
// Create a new g running fn with narg bytes of arguments starting
// at argp. callerpc is the address of the go statement that created
// this. The new g is put on the queue of g's waiting to run.
func newproc1(fn *funcval, argp *uint8, narg int32, callergp *g, callerpc uintptr) {
    //因为已经切换到g0栈，所以无论什么场景都有 _g_ = g0，当然这个g0是指当前工作线程的g0
    //对于我们这个场景来说，当前工作线程是主线程，所以这里的g0 = m0.g0
    _g_ := getg() 

    ......

    _p_ := _g_.m.p.ptr() //初始化时_p_ = g0.m.p，从前面的分析可以知道其实就是allp[0]
    newg := gfget(_p_) //从p的本地缓冲里获取一个没有使用的g，初始化时没有，返回nil
    if newg == nil {
         //new一个g结构体对象，然后从堆上为其分配栈，并设置g的stack成员和两个stackgard成员
        newg = malg(_StackMin)
        casgstatus(newg, _Gidle, _Gdead) //初始化g的状态为_Gdead
         //放入全局变量allgs切片中
        allgadd(newg) // publishes with a g-&amp;gt;status of Gdead so GC scanner doesn't look at uninitialized stack.
    }
   
    ......
   
    //调整g的栈顶置针，无需关注
    totalSize := 4*sys.RegSize+uintptr(siz) +sys.MinFrameSize// extra space in case of reads slightly beyond frame
    totalSize += -totalSize&amp;amp;(sys.SpAlign-1)                  // align to spAlign
    sp := newg.stack.hi-totalSize
    spArg := sp

    ......
   
    if narg &amp;gt; 0 {
         //把参数从执行newproc函数的栈（初始化时是g0栈）拷贝到新g的栈
        memmove(unsafe.Pointer(spArg), unsafe.Pointer(argp), uintptr(narg))
        // ......
    }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这段代码主要从堆上分配一个g结构体对象并为这个newg分配一个大小为2048字节的栈，并设置好newg的stack成员，然后把newg需要执行的函数的参数从执行newproc函数的栈（初始化时是g0栈）拷贝到newg的栈，完成这些事情之后newg的状态如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1671650/201905/1671650-20190507143827853-2031962034.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;rich_pages&quot; alt=&quot;&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/31W1agpaMjyTUgwx4qR3SoK95yFVRFibJDEr3JybwMGWK8Qzzia2POfQg76slh7gLWa4Jia45Q15OHKGunibAtAeCQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以看到，经过前面的代码之后，程序中多了一个我们称之为newg的g结构体对象，该对象也已经获得了从堆上分配而来的2k大小的栈空间，newg的stack.hi和stack.lo分别指向了其栈空间的起止位置。&lt;/p&gt;
&lt;p&gt;接下来我们继续分析newproc1函数。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;runtime/proc.go : 3314&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt; &lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
//把newg.sched结构体成员的所有成员设置为0
    memclrNoHeapPointers(unsafe.Pointer(&amp;amp;newg.sched), unsafe.Sizeof(newg.sched))
   
    //设置newg的sched成员，调度器需要依靠这些字段才能把goroutine调度到CPU上运行。
    newg.sched.sp = sp //newg的栈顶
    newg.stktopsp = sp
    //newg.sched.pc表示当newg被调度起来运行时从这个地址开始执行指令
    //把pc设置成了goexit这个函数偏移1（sys.PCQuantum等于1）的位置，
    //至于为什么要这么做需要等到分析完gostartcallfn函数才知道
    newg.sched.pc = funcPC(goexit) + sys.PCQuantum// +PCQuantum so that previous instruction is in same function
    newg.sched.g = guintptr(unsafe.Pointer(newg))

    gostartcallfn(&amp;amp;newg.sched, fn)//调整sched成员和newg的栈
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这段代码首先对newg的sched成员进行了初始化，该成员包含了调度器代码在调度goroutine到CPU运行时所必须的一些信息，其中sched的sp成员表示newg被调度起来运行时应该使用的栈的栈顶，sched的pc成员表示当newg被调度起来运行时从这个地址开始执行指令，然而从上面的代码可以看到，new.sched.pc被设置成了goexit函数的第二条指令的地址而不是fn.fn，这是为什么呢？要回答这个问题，必须深入到gostartcallfn函数中做进一步分析。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
// adjust Gobuf as if it executed a call to fn
// and then did an immediate gosave.
func gostartcallfn(gobuf *gobuf, fv *funcval) {
    var fn unsafe.Pointer
    if fv != nil {
       fn = unsafe.Pointer(fv.fn) //fn: gorotine的入口地址，初始化时对应的是runtime.main
    } else {
        fn = unsafe.Pointer(funcPC(nilfunc))
    }
    gostartcall(gobuf, fn, unsafe.Pointer(fv))
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;gostartcallfn首先从参数fv中提取出函数地址（初始化时是runtime.main），然后继续调用gostartcall函数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
// adjust Gobuf as if it executed a call to fn with context ctxt
// and then did an immediate gosave.
func gostartcall(buf *gobuf, fn, ctxt unsafe.Pointer) {
    sp := buf.sp//newg的栈顶，目前newg栈上只有fn函数的参数，sp指向的是fn的第一参数
    if sys.RegSize &amp;gt; sys.PtrSize {
        sp -= sys.PtrSize
        *(*uintptr)(unsafe.Pointer(sp)) = 0
    }
    sp -= sys.PtrSize//为返回地址预留空间，
    //这里在伪装fn是被goexit函数调用的，使得fn执行完后返回到goexit继续执行，从而完成清理工作
    *(*uintptr)(unsafe.Pointer(sp)) = buf.pc//在栈上放入goexit+1的地址
    buf.sp = sp//重新设置newg的栈顶寄存器
    //这里才真正让newg的ip寄存器指向fn函数，注意，这里只是在设置newg的一些信息，newg还未执行，
   //等到newg被调度起来运行时，调度器会把buf.pc放入cpu的IP寄存器，
    //从而使newg得以在cpu上真正的运行起来
    buf.pc = uintptr(fn) 
    buf.ctxt = ctxt
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;gostartcall函数的主要作用有两个：&lt;/p&gt;
&lt;ol class=&quot;list-paddingleft-2&quot; start=&quot;&quot; readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;调整newg的栈空间，把goexit函数的第二条指令的地址入栈，伪造成goexit函数调用了fn，从而使fn执行完成后执行ret指令时返回到goexit继续执行完成最后的清理工作；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;重新设置newg.buf.pc 为需要执行的函数的地址，即fn，我们这个场景为runtime.main函数的地址。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;调整完成newg的栈和sched成员之后，返回到newproc1函数，我们继续往下看，&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;   &lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
    newg.gopc = callerpc //主要用于traceback
    newg.ancestors = saveAncestors(callergp)
    //设置newg的startpc为fn.fn，该成员主要用于函数调用栈的traceback和栈收缩
    //newg真正从哪里开始执行并不依赖于这个成员，而是sched.pc
    newg.startpc = fn.fn 

    ......
   
   //设置g的状态为_Grunnable，表示这个g代表的goroutine可以运行了
    casgstatus(newg, _Gdead, _Grunnable)

    ......
   
    //把newg放入_p_的运行队列，初始化的时候一定是p的本地运行队列，其它时候可能因为本地队列满了而放入全局队列
    runqput(_p_, newg, true)

    ......
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;newproc1函数最后这点代码比较直观，首先设置了几个与调度无关的成员变量，然后修改newg的状态为_Grunnable并把其放入了运行队列，到此程序中第一个真正意义上的goroutine已经创建完成。&lt;/p&gt;
&lt;p&gt;这时newg也就是main goroutine的状态如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1671650/201905/1671650-20190507143642924-1324368776.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个图看起来比较复杂，因为表示指针的箭头实在是太多了，这里对其稍作一下解释。&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; data-mark=&quot;-&quot; readability=&quot;3&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;首先，main goroutine对应的newg结构体对象的sched成员已经完成了初始化，图中只显示了pc和sp成员，pc成员指向了runtime.main函数的第一条指令，sp成员指向了newg的栈顶内存单元，该内存单元保存了runtime.main函数执行完成之后的返回地址，也就是runtime.goexit函数的第二条指令，预期runtime.main函数执行完返回之后就会去执行runtime.exit函数的CALL runtime.goexit1(SB)这条指令；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;其次，newg已经放入与当前主线程绑定的p结构体对象的本地运行队列，因为它是第一个真正意义上的goroutine，还没有其它goroutine，所以它被放在了本地运行队列的头部；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;最后，newg的m成员为nil，因为它还没有被调度起来运行，也就没有跟任何m进行绑定。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这一节我们分析了程序中第一个goroutine也就是main goroutine的创建，下一节我们继续分析它是怎么被主工作线程调度到CPU上去执行的。&lt;/p&gt;
</description>
<pubDate>Tue, 07 May 2019 06:41:00 +0000</pubDate>
<dc:creator>爱写程序的阿波张</dc:creator>
<og:description>这一节我们来看程序中的第一个goroutine是如何创建的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/abozhang/p/10825342.html</dc:identifier>
</item>
<item>
<title>使用 ASP.NET Core MVC 创建 Web API（六） - DotNet菜园</title>
<link>http://www.cnblogs.com/chillsrc/p/10824919.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chillsrc/p/10824919.html</guid>
<description>&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span&gt;使用 ASP.NET Core MVC 创建 Web API&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/chillsrc/p/10614598.html&quot;&gt;&lt;span&gt;使用 ASP.NET Core MVC 创建 Web API（一）&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/chillsrc/p/10649898.html&quot;&gt;&lt;span&gt;使用 ASP.NET Core MVC 创建 Web API（二）&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/chillsrc/p/10697463.html&quot;&gt;&lt;span&gt;使用 ASP.NET Core MVC 创建 Web API（三）&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/chillsrc/p/10727666.html&quot;&gt;&lt;span&gt;使用 ASP.NET Core MVC 创建 Web API（四）&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;十七、使用 jQuery 调用 API&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;    在之前的文章中我们是使用Rester来测试我们的WebAPI的。接下来，我们来创建一个实际的页面来测试之前我们写的WebAPI。我们创建一个HTML页面，并在页面使用 jQuery 来调用 Web API 。通过jQuery来调用增删除改查WebAPI接口，并用 API 接口返回的响应中的详细信息更新到页面中。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;    1) 在Visual Studio 2017的“解决方案资源管理器”中打开Startup.cs文件，并找到Configure方法，在方法中添加 app.UseStaticFiles()方法，配置应用提供静态文件并启用默认文件映射，代码如下：     &lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app, IHostingEnvironment env)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (env.IsDevelopment())
            {
                app.UseDeveloperExceptionPage();
            }
            app.UseDefaultFiles();
            app.UseStaticFiles();
            app.UseMvc();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;    2) 在Visual Studio 2017的“解决方案资源管理器”中，选中解决方案，点击鼠标右键，在弹出菜单中选择“添加—》新建文件夹”，并把“新文件夹”命名为 wwwroot。如下图。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/10343/201905/10343-20190507132735683-271255599.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      3) 在Visual Studio 2017的“解决方案资源管理器”中，选中“wwwroot”目录，点击鼠标右键，在弹出菜单中选择“添加—》新建项”，在弹出对话框中选择“HTML页”，并在名称输入框中输入“index.html”，然后点击“添加”按钮。如下图。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/10343/201905/10343-20190507133049743-1076673738.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Index.html文件的内容如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;utf-8&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;BOOK CRUD&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 最新版本的 Bootstrap 核心 CSS 文件 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;link &lt;/span&gt;&lt;span&gt;rel&lt;/span&gt;&lt;span&gt;=&quot;stylesheet&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/css/bootstrap.min.css&quot;&lt;/span&gt;&lt;span&gt; &lt;br/&gt;integrity&lt;/span&gt;&lt;span&gt;=&quot;sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u&quot;&lt;/span&gt;&lt;span&gt; crossorigin&lt;/span&gt;&lt;span&gt;=&quot;anonymous&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 最新的 Bootstrap 核心 JavaScript 文件 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/js/bootstrap.min.js&quot;&lt;br/&gt;&lt;/span&gt;&lt;span&gt; integrity&lt;/span&gt;&lt;span&gt;=&quot;sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa&quot;&lt;/span&gt;&lt;span&gt; crossorigin&lt;/span&gt;&lt;span&gt;=&quot;anonymous&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;BOOK CRUD&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;container-fluid&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;     
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;row-fluid&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;col-xs-12 col-md-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;counter&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;table &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;table table-bordered&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;th&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;ID&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;th&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;th&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Name&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;th&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;th&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;ReleaseDate&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;th&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;th&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Author&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;th&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;th&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Price&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;th&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;th&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Publishing&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;th&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;th &lt;/span&gt;&lt;span&gt;colspan&lt;/span&gt;&lt;span&gt;=&quot;2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;btn btn-default btn-xs&quot;&lt;/span&gt;&lt;span&gt; onclick&lt;/span&gt;&lt;span&gt;=&quot;getData()&quot;&lt;/span&gt;&lt;span&gt; role&lt;/span&gt;&lt;span&gt;=&quot;button&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;刷新&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;th&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tbody &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;books&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tbody&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;table&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;col-md-2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form &lt;/span&gt;&lt;span&gt;action&lt;/span&gt;&lt;span&gt;=&quot;javascript:void(0);&quot;&lt;/span&gt;&lt;span&gt; method&lt;/span&gt;&lt;span&gt;=&quot;POST&quot;&lt;/span&gt;&lt;span&gt; onsubmit&lt;/span&gt;&lt;span&gt;=&quot;addItem()&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;fieldset&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;legend&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Add&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;legend&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;asp-validation-summary&lt;/span&gt;&lt;span&gt;=&quot;ModelOnly&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;text-danger&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;form-group&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;control-label&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Name&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;AddName&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;form-control&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;form-group&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;control-label&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;ReleaseDate&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;AddReleaseDate&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;form-control&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;form-group&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;control-label&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Author&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;AddAuthor&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;form-control&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;form-group&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;control-label&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Price&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;AddPrice&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;form-control&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;form-group&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;control-label&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Publishing&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;AddPublishing&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;form-control&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;form-group&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;submit&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;Add&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;btn btn-primary&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;fieldset&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;col-md-2&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;spoiler&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;my-form&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;fieldset&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;legend&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Edit&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;legend&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;asp-validation-summary&lt;/span&gt;&lt;span&gt;=&quot;ModelOnly&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;text-danger&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;hidden&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;BookID&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;hidden&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;RowVersion&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;form-group&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;control-label&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Name&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;Name&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;form-control&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;form-group&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;control-label&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;ReleaseDate&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

                            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;ReleaseDate&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;form-control&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;form-group&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;control-label&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Author&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;Author&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;form-control&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;

                        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;form-group&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;control-label&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Price&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;Price&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;form-control&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;

                        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;form-group&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;control-label&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Publishing&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;Publishing&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;form-control&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;form-group&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;submit&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;Save&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;btn btn-default&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;onclick&lt;/span&gt;&lt;span&gt;=&quot;closeInput()&quot;&lt;/span&gt;&lt;span&gt; aria-label&lt;/span&gt;&lt;span&gt;=&quot;Close&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&amp;amp;#10006;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;fieldset&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;https://code.jquery.com/jquery-3.3.1.min.js&quot;&lt;/span&gt;&lt;span&gt;
            integrity&lt;/span&gt;&lt;span&gt;=&quot;sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=&quot;&lt;/span&gt;&lt;span&gt;
            crossorigin&lt;/span&gt;&lt;span&gt;=&quot;anonymous&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;site.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;    4) 在Visual Studio 2017的“解决方案资源管理器”中，选中“wwwroot”目录，点击鼠标右键，在弹出菜单中选择“添加—》新建项”，在弹出对话框中选择“JavaScript文件”，并在名称输入框中输入“site.js”，然后点击“添加”按钮。如下图。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/10343/201905/10343-20190507133122343-656534959.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    5) 在site.js文件中添加如下 代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;71&quot;&gt;
&lt;pre&gt;
const uri = &quot;api/book&quot;&lt;span&gt;;
let books &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; getCount(data) {
    const el &lt;/span&gt;= $(&quot;#counter&quot;&lt;span&gt;);
    let name &lt;/span&gt;= &quot;book&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (data) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (data &amp;gt; 1&lt;span&gt;) {
            name &lt;/span&gt;= &quot;book-s&quot;&lt;span&gt;;
        }

        el.text(data &lt;/span&gt;+ &quot; &quot; +&lt;span&gt; name);
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        el.text(&lt;/span&gt;&quot;No &quot; +&lt;span&gt; name);
    }
} 

$(document).ready(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    getData();

}); 

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; getData() {
    $.ajax({
        type: &lt;/span&gt;&quot;GET&quot;&lt;span&gt;,
        url: uri,
        cache: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
        success: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (data) {
            const tBody &lt;/span&gt;= $(&quot;#books&quot;&lt;span&gt;);
            $(tBody).empty();
            getCount(data.length);

            $.each(data, &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (key, item) {
                const tr &lt;/span&gt;= $(&quot;&amp;lt;tr&amp;gt;&amp;lt;/tr&amp;gt;&quot;&lt;span&gt;)
                    .append($(&lt;/span&gt;&quot;&amp;lt;td&amp;gt;&amp;lt;/td&amp;gt;&quot;&lt;span&gt;).text(item.id))
                    .append($(&lt;/span&gt;&quot;&amp;lt;td&amp;gt;&amp;lt;/td&amp;gt;&quot;&lt;span&gt;).text(item.name))
                    .append($(&lt;/span&gt;&quot;&amp;lt;td&amp;gt;&amp;lt;/td&amp;gt;&quot;&lt;span&gt;).text(item.releaseDate))
                    .append($(&lt;/span&gt;&quot;&amp;lt;td&amp;gt;&amp;lt;/td&amp;gt;&quot;&lt;span&gt;).text(item.author))
                    .append($(&lt;/span&gt;&quot;&amp;lt;td&amp;gt;&amp;lt;/td&amp;gt;&quot;&lt;span&gt;).text(item.price))
                    .append($(&lt;/span&gt;&quot;&amp;lt;td&amp;gt;&amp;lt;/td&amp;gt;&quot;&lt;span&gt;).text(item.publishing))
                    .append(
                        $(&lt;/span&gt;&quot;&amp;lt;td&amp;gt;&amp;lt;/td&amp;gt;&quot;&lt;span&gt;).append(

  $(&lt;/span&gt;&quot;&amp;lt;button class=\&quot;btn btn-default btn-sm\&quot; &amp;gt;Edit&amp;lt;/button&amp;gt;&quot;).on(&quot;click&quot;, &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {                                editItem(item.id);
                            })
                        )
                    )
                    .append(
                        $(&lt;/span&gt;&quot;&amp;lt;td&amp;gt;&amp;lt;/td&amp;gt;&quot;&lt;span&gt;).append(

$(&lt;/span&gt;&quot;&amp;lt;button class=\&quot;btn btn-default btn-sm\&quot;&amp;gt;Delete&amp;lt;/button&amp;gt;&quot;).on(&quot;click&quot;, &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {                                deleteItem(item.id);
                            })
                        )
                    );
                tr.appendTo(tBody);
            });
            books &lt;/span&gt;=&lt;span&gt; data;
        }
    });
} 

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; addItem() {
    const item &lt;/span&gt;=&lt;span&gt; {
        Name: $(&lt;/span&gt;&quot;#AddName&quot;&lt;span&gt;).val(),
        ReleaseDate: $(&lt;/span&gt;&quot;#AddReleaseDate&quot;&lt;span&gt;).val(),
        Author: $(&lt;/span&gt;&quot;#AddAuthor&quot;&lt;span&gt;).val(),
        Publishing: $(&lt;/span&gt;&quot;#AddPublishing&quot;&lt;span&gt;).val(),
        Price: $(&lt;/span&gt;&quot;#AddPrice&quot;&lt;span&gt;).val(),     

        ID: &lt;/span&gt;0&lt;span&gt;
    }; 

    $.ajax({
        type: &lt;/span&gt;&quot;POST&quot;&lt;span&gt;,
        accepts: &lt;/span&gt;&quot;application/json&quot;&lt;span&gt;,
        url: uri,
        contentType: &lt;/span&gt;&quot;application/json&quot;&lt;span&gt;,
        data: JSON.stringify(item),
        error: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (jqXHR, textStatus, errorThrown) {
            alert(&lt;/span&gt;&quot;Something went wrong!&quot;&lt;span&gt;);
        },

        success: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (result) {
            getData();
            $(&lt;/span&gt;&quot;#add-name&quot;).val(&quot;&quot;&lt;span&gt;);
        }
    });
} 

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; deleteItem(id) {
    $.ajax({
        url: uri &lt;/span&gt;+ &quot;/&quot; +&lt;span&gt; id,
        type: &lt;/span&gt;&quot;DELETE&quot;&lt;span&gt;,
        success: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (result) {
            getData();
        }
    });
} 

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; editItem(id) {
    $.each(books, &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (key, item) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (item.id ===&lt;span&gt; id) {
            $(&lt;/span&gt;&quot;#Name&quot;&lt;span&gt;).val(item.name);
            $(&lt;/span&gt;&quot;#BookID&quot;&lt;span&gt;).val(item.id);
            $(&lt;/span&gt;&quot;#ReleaseDate&quot;&lt;span&gt;).val(item.releaseDate);

            $(&lt;/span&gt;&quot;#Author&quot;&lt;span&gt;).val(item.author);
            $(&lt;/span&gt;&quot;#Publishing&quot;&lt;span&gt;).val(item.publishing);
            $(&lt;/span&gt;&quot;#Price&quot;&lt;span&gt;).val(item.price);
            $(&lt;/span&gt;&quot;#RowVersion&quot;&lt;span&gt;).val(item.rowVersion);
        }
    });
    $(&lt;/span&gt;&quot;#spoiler&quot;).css({ display: &quot;block&quot;&lt;span&gt; });
} 

$(&lt;/span&gt;&quot;.my-form&quot;).on(&quot;submit&quot;, &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    const item &lt;/span&gt;=&lt;span&gt; {
        Name: $(&lt;/span&gt;&quot;#Name&quot;&lt;span&gt;).val(),
        ReleaseDate: $(&lt;/span&gt;&quot;#ReleaseDate&quot;&lt;span&gt;).val(),
        Author: $(&lt;/span&gt;&quot;#Author&quot;&lt;span&gt;).val(),
        Publishing: $(&lt;/span&gt;&quot;#Publishing&quot;&lt;span&gt;).val(),
        Price: $(&lt;/span&gt;&quot;#Price&quot;&lt;span&gt;).val(),
        RowVersion: $(&lt;/span&gt;&quot;#RowVersion&quot;&lt;span&gt;).val(),
        ID: $(&lt;/span&gt;&quot;#BookID&quot;&lt;span&gt;).val()
    }; 

    $.ajax({
        url: uri &lt;/span&gt;+ &quot;/&quot; + $(&quot;#BookID&quot;&lt;span&gt;).val(),
        type: &lt;/span&gt;&quot;PUT&quot;&lt;span&gt;,
        accepts: &lt;/span&gt;&quot;application/json&quot;&lt;span&gt;,
        contentType: &lt;/span&gt;&quot;application/json&quot;&lt;span&gt;,
        data: JSON.stringify(item),
        success: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (result) {
            getData();
        }
    }); 

    closeInput();
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
}); 

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; closeInput() {
    $(&lt;/span&gt;&quot;#spoiler&quot;).css({ display: &quot;none&quot;&lt;span&gt; });
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;     6） 修改 ASP.NET Core 项目的启动设置，以便对 HTML 页面进行本地测试。在Visual Studio 2017中打开 Properties\launchSettings.json。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     7） 删除 &lt;code&gt;launchUrl&lt;/code&gt; 以便在项目的默认文件 index.html 强制打开应用。如下图。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/10343/201905/10343-20190507133502844-1468068439.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     此示例调用 API 的所有 CRUD 方法。 以下是 API 调用的说明。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;    一）获取书籍的列表&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;     我们写的脚本中的getData 方法是通过jQuery ajax 函数将 &lt;code&gt;GET&lt;/code&gt; 请求发送至 BookApi应用程序的GetBookItem方法，这个方法返回表示书籍数组的 JSON。 如果请求成功，则调用 &lt;code&gt;success&lt;/code&gt; 回调函数。在该回调中将书籍信息组装成表格更新到 DOM中。如下图。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/10343/201905/10343-20190507133520335-1630174952.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;     二）添加书籍信息&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;     脚本中的addItem 方法通过JQuery 的Ajax 函数发送 &lt;code&gt;POST请求&lt;/code&gt;，请求正文中包含书籍信息。 将 &lt;code&gt;accepts&lt;/code&gt; 和 &lt;code&gt;contentType&lt;/code&gt; 选项设置为 &lt;code&gt;application/json&lt;/code&gt;，以便指定接收和发送的数据类型。 书籍信息使用 JSON.stringify 转换为 JSON。 当 API 返回成功状态的代码时，将调用 &lt;code&gt;getData&lt;/code&gt; 函数来更新 HTML 表格。如下图。  &lt;img src=&quot;https://img2018.cnblogs.com/blog/10343/201905/10343-20190507133540440-1154022295.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;/span&gt; &lt;span&gt;三）  更新书籍信息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     editItem方法用来更新书籍信息，这个方法的实现与addItem类似。 &lt;code&gt;url&lt;/code&gt; 更改为添加项的唯一标识符，并且 &lt;code&gt;type&lt;/code&gt; 为 &lt;code&gt;PUT&lt;/code&gt;。如下图。我们在表格点击需要修改的书籍信息的“Edit”按钮，系统会把这条书籍信息中的数据显示到编辑文本框中，在进行修改之后，点击“Save”按钮，保存数据。 &lt;img src=&quot;https://img2018.cnblogs.com/blog/10343/201905/10343-20190507133609348-165872295.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;     四） 删除书籍&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;      deleteItem方法用来删除书籍信息，通过调用JQuery  AJAX函数发出删除请求。并把 &lt;code&gt;type&lt;/code&gt; 设为 &lt;code&gt;DELETE&lt;/code&gt; ，指定该项在 URL 中的唯一标识符。如下图中1与2，就是删除前后的情况。我们点击表格中的删除按钮，将调用脚本中的deleteItem方法，删除指定书籍。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/10343/201905/10343-20190507133630838-1716921338.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 07 May 2019 05:37:00 +0000</pubDate>
<dc:creator>DotNet菜园</dc:creator>
<og:description>在之前的文章中我们是使用Rester来测试我们的WebAPI的。接下来，我们来创建一个实际的页面来测试之前我们写的WebAPI。我们创建一个HTML页面，并在页面使用 jQuery 来调用 Web A</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chillsrc/p/10824919.html</dc:identifier>
</item>
<item>
<title>Spring MVC源码——Servlet WebApplicationContext - 胡峻峥</title>
<link>http://www.cnblogs.com/hujunzheng/p/10824788.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hujunzheng/p/10824788.html</guid>
<description>&lt;p&gt;上一篇笔记(&lt;a href=&quot;https://www.cnblogs.com/hujunzheng/p/10819473.html&quot; target=&quot;_blank&quot;&gt;Spring MVC源码——Root WebApplicationContext&lt;/a&gt;)中记录了下 Root WebApplicationContext 的初始化代码.这一篇来看 Servlet WebApplicationContext 的初始化代码&lt;/p&gt;
&lt;p&gt;&lt;code&gt;DispatcherServlet&lt;/code&gt; 是另一个需要在 &lt;code&gt;web.xml&lt;/code&gt; 中配置的类, Servlet WebApplicationContext 就由它来创建和初始化.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pics-1257963040.cos.ap-shanghai.myqcloud.com/20190505132117.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;httpservletbean&quot;&gt;HttpServletBean&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;HttpServletBean&lt;/code&gt; 简单继承了 &lt;code&gt;HttpServlet&lt;/code&gt;, 负责将 init-param 中的参数注入到当前 &lt;code&gt;Servlet&lt;/code&gt; 实例的属性中, 并且为子类提供了增加 requiredProperties 的能力. &lt;code&gt;HttpServletBean&lt;/code&gt; 并不依赖于 Spring 容器.&lt;/p&gt;
&lt;p&gt;来看一下它的 &lt;code&gt;init()&lt;/code&gt; 方法:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; init() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ServletException {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Set bean properties from init parameters.
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从 ServletConfig 中取出初始化参数到 PropertyValues。ServletConfigPropertyValues 的构造器中将会检查是否缺失了必要属性&lt;/span&gt;
    PropertyValues pvs = &lt;span&gt;new&lt;/span&gt; ServletConfigPropertyValues(getServletConfig(), &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.requiredProperties);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;pvs.isEmpty()) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将 servlet 对象包装成 BeanWrapper ，从而能够以 Spring 的方式（反射）来注入参数&lt;/span&gt;
            BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
            ResourceLoader resourceLoader &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServletContextResourceLoader(getServletContext());
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注册 PropertyEditor，遇到 Resource 类型的属性时，用 ResourceEditor 解析&lt;/span&gt;
            bw.registerCustomEditor(Resource.&lt;span&gt;class&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ResourceEditor(resourceLoader, getEnvironment()));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化 BeanWrapper，空方法&lt;/span&gt;
&lt;span&gt;            initBeanWrapper(bw);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注入属性，忽略没有 setter 的属性&lt;/span&gt;
            bw.setPropertyValues(pvs, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (BeansException ex) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isErrorEnabled()) {
                logger.error(&lt;/span&gt;&quot;Failed to set bean properties on servlet '&quot; + getServletName() + &quot;'&quot;&lt;span&gt;, ex);
            }
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; ex;
        }
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Let subclasses do whatever initialization they like.
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 由子类实现初始化逻辑&lt;/span&gt;
&lt;span&gt;    initServletBean();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ServletConfigPropertyValues &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; MutablePropertyValues {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ServletConfigPropertyValues(ServletConfig config, Set&amp;lt;String&amp;gt;&lt;span&gt; requiredProperties)
            &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ServletException {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将 requiredProperties 拷贝到新的 Set missingProps&lt;/span&gt;
        Set&amp;lt;String&amp;gt; missingProps = (!CollectionUtils.isEmpty(requiredProperties) ?
                &lt;span&gt;new&lt;/span&gt; HashSet&amp;lt;&amp;gt;(requiredProperties) : &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将 ServletConfig 中的初始化参数取出，添加到 MutablePropertyValues 中&lt;/span&gt;
        Enumeration&amp;lt;String&amp;gt; paramNames =&lt;span&gt; config.getInitParameterNames();
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (paramNames.hasMoreElements()) {
            String property &lt;/span&gt;=&lt;span&gt; paramNames.nextElement();
            Object value &lt;/span&gt;=&lt;span&gt; config.getInitParameter(property);
            addPropertyValue(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; PropertyValue(property, value));
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (missingProps != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                missingProps.remove(property);
            }
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Fail if we are still missing properties.&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;CollectionUtils.isEmpty(missingProps)) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 存在必须出现的条件没出现&lt;/span&gt;
            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServletException(
                    &lt;/span&gt;&quot;Initialization from ServletConfig for servlet '&quot; + config.getServletName() +
                    &quot;' failed; the following required properties were missing: &quot; +&lt;span&gt;
                    StringUtils.collectionToDelimitedString(missingProps, &lt;/span&gt;&quot;, &quot;&lt;span&gt;));
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;frameworkservlet&quot;&gt;FrameworkServlet&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;FrameworkServlet&lt;/code&gt; 是一个更具体的 Servlet 基类. 它有以下两个功能:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;每个 servket 管理一个 &lt;code&gt;WebApplicationContext&lt;/code&gt; 实例.&lt;/li&gt;
&lt;li&gt;无论请求是否成功, 根据请求处理发布事件.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;FrameworkServlet&lt;/code&gt; 重写了 &lt;code&gt;HttpServletBean&lt;/code&gt; 的 &lt;code&gt;initServletBean()&lt;/code&gt; 方法, 这个方法会在 所有 servlet 的属性被注入之后执行, 来看一下代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; initServletBean() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ServletException {
    getServletContext().log(&lt;/span&gt;&quot;Initializing Spring &quot; + getClass().getSimpleName() + &quot; '&quot; + getServletName() + &quot;'&quot;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isInfoEnabled()) {
        logger.info(&lt;/span&gt;&quot;Initializing Servlet '&quot; + getServletName() + &quot;'&quot;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; startTime =&lt;span&gt; System.currentTimeMillis();

    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化 webApplicationContext&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.webApplicationContext =&lt;span&gt; initWebApplicationContext();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在容器被加载后执行，由子类来实现一些必要的初始化&lt;/span&gt;
&lt;span&gt;        initFrameworkServlet();
    }
    &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt; (ServletException |&lt;span&gt; RuntimeException ex) {
        logger.error(&lt;/span&gt;&quot;Context initialization failed&quot;&lt;span&gt;, ex);
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; ex;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 略去打印日志的部分&lt;/span&gt;
    ... &lt;br/&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;initWebApplicationContext()&lt;/code&gt; 方法会初始化并返回一个容器:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; WebApplicationContext initWebApplicationContext() {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取 Root WebApplicationContext&lt;/span&gt;
    WebApplicationContext rootContext =&lt;span&gt;
            WebApplicationContextUtils.getWebApplicationContext(getServletContext());
    WebApplicationContext wac &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.webApplicationContext != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; A context instance was injected at construction time -&amp;gt; use it
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 一个上下文已经被注入进来&lt;/span&gt;
        wac = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.webApplicationContext;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (wac &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; ConfigurableWebApplicationContext) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果是 ConfigurableWebApplicationContext，&lt;/span&gt;
            ConfigurableWebApplicationContext cwac =&lt;span&gt; (ConfigurableWebApplicationContext) wac;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;cwac.isActive()) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 没有激活，设置父容器，配置并且刷新容器&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (cwac.getParent() == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    cwac.setParent(rootContext);
                }
                configureAndRefreshWebApplicationContext(cwac);
            }
        }
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (wac == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 尝试从 ServletContext 中获取一个容器&lt;/span&gt;
        wac =&lt;span&gt; findWebApplicationContext();
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (wac == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建一个新的容器并初始化&lt;/span&gt;
        wac =&lt;span&gt; createWebApplicationContext(rootContext);
    }

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.refreshEventReceived) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 没有触发过刷新时间&lt;/span&gt;
        &lt;span&gt;synchronized&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.onRefreshMonitor) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 手动触发刷新事件&lt;/span&gt;
&lt;span&gt;            onRefresh(wac);
        }
    }

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.publishContext) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Publish the context as a servlet context attribute.
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将容器发布到 ServletContext 的属性上&lt;/span&gt;
        String attrName =&lt;span&gt; getServletContextAttributeName();
        getServletContext().setAttribute(attrName, wac);
    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; wac;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;onRefresh()&lt;/code&gt; 方法供子类来重写, &lt;code&gt;DispatcherServlet&lt;/code&gt; 重写了这个方法来初始化 MVC 中的一些组件:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onRefresh(ApplicationContext context) {
    initStrategies(context);
}

&lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; initStrategies(ApplicationContext context) {
    initMultipartResolver(context);
    initLocaleResolver(context);
    initThemeResolver(context);
    initHandlerMappings(context);
    initHandlerAdapters(context);
    initHandlerExceptionResolvers(context);
    initRequestToViewNameTranslator(context);
    initViewResolvers(context);
    initFlashMapManager(context);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;initWebApplicationContext()&lt;/code&gt; 方法调用的其他方法其实和 &lt;code&gt;ContextLoader&lt;/code&gt; 中的方法比较类似, 这里就不再放上来了, 有兴趣的可以访问我的&lt;a href=&quot;https://github.com/FJHHH/spring-framework&quot;&gt;源码注释&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt; 总结&lt;/h2&gt;
&lt;p&gt;通过本篇博客以及上一篇博客，相信大家对springmvc的上下文有了明确的认识。总的来说，默认springmvc项目会有两个上下文（root webapplicationcontext 和 servlet webapplicationcontext）。接下来的博文会带大家认识一下springboot项目的上下文以及springmvc项目上下文和springboot项目上下文的异同点，敬请期待。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;转自：https://www.cnblogs.com/FJH1994/p/10813687.html&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 07 May 2019 05:16:00 +0000</pubDate>
<dc:creator>胡峻峥</dc:creator>
<og:description>上一篇笔记(Spring MVC源码——Root WebApplicationContext)中记录了下 Root WebApplicationContext 的初始化代码.这一篇来看 Servlet</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hujunzheng/p/10824788.html</dc:identifier>
</item>
<item>
<title>python接口自动化（三十）--html测试报告通过邮件发出去——中（详解） - 北京-宏哥</title>
<link>http://www.cnblogs.com/du-hong/p/10819199.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/du-hong/p/10819199.html</guid>
<description>&lt;h2&gt;简介&lt;/h2&gt;
&lt;p&gt;　　上一篇，我们虽然已经将生成的最新的测试报告发出去了，但是MIMEText 只能发送正文，无法带附件，因此我还需要继续改造我们的代码，实现可以发送带有附件的邮件。发送带附件的需要导入另外一个模块 MIMEMultipart。还有就是测&lt;/p&gt;
&lt;p&gt;试负责人不止一个人，需要将测试报告发给多个人，也就是多个收件人。这篇主要是围绕这两个主题进行讲解的。&lt;/p&gt;
&lt;h2&gt; 大致思路&lt;/h2&gt;
&lt;h3&gt;（一）带有附件发送邮件&lt;/h3&gt;
&lt;p&gt;1、导入模块 MIMEMultipart&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; email.mime.multipart import MIMEMultipart
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、先读取要发送文件的内容，file_new 是测试报告路径的参数名&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190506160752555-1355662005.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3、下图红色框框 file_name 参数是发送的附件重新命名&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190506160925958-1146815231.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4、file_new 是测试报告路径的参数名，发送邮件是将其传入&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190506161110654-1468373080.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5、运行结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190506161619508-1173696443.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;6、查看收件箱&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190506161714682-1157232280.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;（二）发送给多个收件人&lt;/h3&gt;
&lt;p&gt;上面都是发给一个收件人，那么如何一次发给多个收件人呢？其实是非常简单的，只需改两个小地方，即可，从这里就可以看出python的强大之处。&lt;br/&gt;1、源码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190506163526020-257940741.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、仿造修改&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190507124059768-1224726427.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3、运行结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190506164219402-840238446.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4、收件箱查看&lt;/p&gt;
&lt;p&gt;公司邮箱&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190506170810811-140165208.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;QQ邮箱&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190507124521965-1169634488.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;参考代码&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
# coding=utf-&lt;span&gt;8&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;.先设置编码，utf-&lt;span&gt;8可支持中英文，如上，一般放在第一行

#&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;.注释：包括记录创建时间，创建人，项目名称。
&lt;/span&gt;&lt;span&gt;'''
&lt;/span&gt;Created on &lt;span&gt;2019&lt;/span&gt;-&lt;span&gt;5&lt;/span&gt;-&lt;span&gt;7&lt;/span&gt;&lt;span&gt;
@author: 北京&lt;/span&gt;-&lt;span&gt;宏哥
Project:学习和使用将测试报告通过邮件发出去且邮件带有附件
&lt;/span&gt;&lt;span&gt;'''
&lt;/span&gt;#&lt;span&gt;3&lt;/span&gt;&lt;span&gt;.导入unittest模块
import unittest
import os
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt; email.mime.text import MIMEText
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt; email.mime.multipart import MIMEMultipart
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt; email.header import Header
import smtplib
#&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;.编写测试用例和断言
def all_case():
    # 待执行用例的目录
    #case_dir &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C:\\Users\\DELL\\PycharmProjects\\honggetest\\case&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    case_dir &lt;/span&gt;= os.path.join(os.getcwd(), &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    testcase &lt;/span&gt;=&lt;span&gt; unittest.TestSuite()
    discover &lt;/span&gt;=&lt;span&gt; unittest.defaultTestLoader.discover(case_dir,
                                                   pattern&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test*.py&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                                                   top_level_dir&lt;/span&gt;=&lt;span&gt;None)
    # #discover方法筛选出用例，循环添加到测试套件中
    # &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; test_suit &lt;span&gt;in&lt;/span&gt;&lt;span&gt; discover:
    #     &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; test_case &lt;span&gt;in&lt;/span&gt;&lt;span&gt; test_suit:
    #         #添加用力到testcase
    #         testcase.addTests(test_case)
    # print(testcase)
    testcase.addTests(discover)  # 直接加载 discover    可以兼容python2和3
    print(testcase)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; testcase
# &lt;/span&gt;==============定义发送邮件==========&lt;span&gt;
def send_mail(file_new):
    #&lt;/span&gt;-----------&lt;span&gt;1&lt;/span&gt;.跟发件相关的参数------&lt;span&gt;
    smtpserver &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;smtp.mxhichina.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;                #发件服务器
    port &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;                      #端口
    username &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;nXXX@ceXx.cn&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;  #发件箱用户名
    password &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ceXXx@@123&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;        #发件箱密码
    sender &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;XXly@cedex.cn&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;    #发件人邮箱
    receiver &lt;/span&gt;= [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hongge@com.cn&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1918991791@qq.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;] #收件人邮箱
    # &lt;/span&gt;----------&lt;span&gt;2&lt;/span&gt;.编辑邮件的内容------&lt;span&gt;
    #读文件
    f &lt;/span&gt;= open(file_new, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;rb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    mail_body &lt;/span&gt;=&lt;span&gt; f.read()
    f.close()
    # 邮件正文是MIMEText
    body &lt;/span&gt;= MIMEText(mail_body, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    # 邮件对象
    msg &lt;/span&gt;=&lt;span&gt; MIMEMultipart()
    msg[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Subject&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = Header(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;自动化测试报告&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).encode()#主题
    msg[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;From&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = Header(u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;测试机 &amp;lt;%s&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;%&lt;span&gt;sender)                #发件人
    msg[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;To&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = Header(u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;测试负责人 &amp;lt;%s&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;%&lt;span&gt;receiver)            #收件人
    msg[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;To&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.join(receiver)
    msg[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;date&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = time.strftime(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%a,%d %b %Y %H:%M:%S %z&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    msg.attach(body)
    # 附件
    att &lt;/span&gt;= MIMEText(mail_body, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;base64&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    att[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Content-Type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;application/octet-stream&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    att[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Content-Disposition&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;attachment; filename=&quot;test_report.html&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    msg.attach(att)
    # &lt;/span&gt;----------&lt;span&gt;3&lt;/span&gt;.发送邮件------
    &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
        smtp &lt;/span&gt;=&lt;span&gt; smtplib.SMTP()
        smtp.connect(smtpserver)  # 连服务器
        smtp.login(sender, password)
    except:
        smtp &lt;/span&gt;=&lt;span&gt; smtplib.SMTP_SSL(smtpserver, port)
        smtp.login(sender, password)  # 登录
    smtp.sendmail(sender, receiver, msg.as_string())  # 发送
    smtp.quit()
    # #发送邮件
    # smtp &lt;/span&gt;=&lt;span&gt; smtplib.SMTP()
    # smtp.connect(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;smtp.mxhichina.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)  # 邮箱服务器
    # smtp.login(username, password)  # 登录邮箱
    # smtp.sendmail(sender, receiver, msg.as_string())  # 发送者和接收者
    # smtp.quit()
    print(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;邮件已发出！注意查收。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
# &lt;/span&gt;======查找测试目录，找到最新生成的测试报告文件======&lt;span&gt;
def new_report(test_report):
    lists &lt;/span&gt;=&lt;span&gt; os.listdir(test_report)  # 列出目录的下所有文件和文件夹保存到lists
    lists.sort(key&lt;/span&gt;=lambda fn: os.path.getmtime(test_report + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\\&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; fn))  # 按时间排序
    file_new &lt;/span&gt;= os.path.join(test_report, lists[-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;])  # 获取最新的文件保存到file_new
    print(file_new)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; file_new
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; __name__ == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
    # 返回实例
    runner &lt;/span&gt;=&lt;span&gt; unittest.TextTestRunner()
    #导入第三方模块HTMLTestRunner
    import HTMLTestReportCN
    import time
    # 获取当前时间，这样便于下面的使用。
    now &lt;/span&gt;= time.strftime(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%Y-%m-%M-%H_%M_%S&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, time.localtime(time.time()))
    #保存生成报告的路径
    report_path &lt;/span&gt;=  &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C:\\Users\\DELL\\PycharmProjects\\honggetest\\report\\&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+now+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_result.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    fp &lt;/span&gt;= open(report_path,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;wb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    runner &lt;/span&gt;= HTMLTestReportCN.HTMLTestRunner(stream=&lt;span&gt;fp,
                                           title&lt;/span&gt;=u&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;这是我的自动化测试用例&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                                           description&lt;/span&gt;=u&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;用例执行情况&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                                           verbosity &lt;/span&gt;= &lt;span&gt;2&lt;/span&gt;&lt;span&gt;
                                           )
    # run 所有用例
    runner.run(all_case())
    #关闭文件，记住用open()打开文件后一定要记得关闭它，否则会占用系统的可打开文件句柄数。
    fp.close()
    #测试报告文件夹
    test_path &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C:\\Users\\DELL\\PycharmProjects\\honggetest\\report\\&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    new_report &lt;/span&gt;=&lt;span&gt; new_report(test_path)
    send_mail(new_report)  # 发送测试报告&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;小结&lt;/h2&gt;
&lt;p&gt; 1、第二处我注释掉也可以发出去，两个收件人可以收到邮件，但是如果这样的话，公司邮箱收件人只显示一个收件人，QQ邮箱显示两个收件人。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190507124116012-62533984.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;公司邮箱    PS：如果将红色框上边的注释掉，下边的不注释，就可以看到两个收件人的邮箱&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190507124353004-2044140686.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 以下是个人愚见，如果不对请指出&lt;/p&gt;
&lt;div readability=&quot;33&quot;&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;from email.mime.text import MIMEText&lt;/p&gt;
&lt;p&gt;from email.mime.multipart import MIMEMultipart&lt;/p&gt;
&lt;p&gt;import smtplib&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以上是导入的包，通过email和smtplib实现发邮件。&lt;/p&gt;
&lt;p&gt;折腾好久，发现是这样：email中收件人和sendmail中的收件人是没啥联系的。&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;strong&gt;mail_to = ['test1@exp.com','test2@exp.com']&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;server = smtplib.SMTP()&lt;/p&gt;
&lt;p&gt;server.connect()&lt;/p&gt;
&lt;p&gt;server.sendmail(mail_from, &lt;strong&gt;mail_to&lt;/strong&gt;, msg.as_string())&lt;/p&gt;
&lt;p&gt;server.quit()&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;14&quot;&gt;
&lt;p&gt;&lt;strong&gt;mail_to = 'test1@exp.com,test2@exp.com'&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;msg = MIMEMultipart('related') ##采用related定义内嵌资源的邮件体&lt;/p&gt;
&lt;p&gt;msgtext = MIMEText(content,_subtype='html',_charset='utf-8') ##_subtype有plain,html等格式，避免使用错误&lt;/p&gt;
&lt;p&gt;msg['Subject'] = subject&lt;/p&gt;
&lt;p&gt;msg['From'] = mail_from&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;msg['To']&lt;/strong&gt; =mail_to&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;sendmail中收件人，它的格式应该为list。这个为实际的收件人地址。&lt;/p&gt;
&lt;p&gt;而msg['To'] 格式是字符串(str)。这个只是为了邮件中打印出来而已。&lt;/p&gt;
&lt;p&gt;sendmail查源码，python/lib/smtplib.py大概690行左右，或者搜索tolist。&lt;/p&gt;
&lt;p&gt;2、在使用python添加附件发送时报错：Cannot attach additional subparts to non-multipart/* &lt;/p&gt;
&lt;p&gt;查询得知，错误的原因在于缺少这行代码：&lt;/p&gt;
&lt;p&gt;msg = MIMEMultipart() &lt;/p&gt;
&lt;p&gt;将这行加上：msg = MIMEMultipart() 即可&lt;/p&gt;
&lt;/div&gt;
&lt;h3&gt; 邮件收不到的几种原因&lt;/h3&gt;
&lt;p&gt;1、Subject 和正文内容不要用 hello、hehe、test 等单词&lt;/p&gt;
&lt;p&gt;2、from(发件人)和 to(收件人)不要为空，（要不然会被认为是垃圾邮件）&lt;/p&gt;
&lt;p&gt;3、找不到的话，先看下垃圾信箱，是不是跑到垃圾箱了&lt;/p&gt;
&lt;p&gt;4、如果前几次可以收到，后来收不到了，需改下 subject 内容（因为每次都是一个 subject，系统也会拒收的，把 subject 内容设置为动态的是最好的）&lt;/p&gt;
&lt;p&gt;5、部分邮箱是 ssl 加密了的，所以无法发送，如:qq 邮箱（用授权码去登录）&lt;/p&gt;
&lt;p&gt;6、要是按照上面的步骤来报错了，说明代码抄错了，多检查几次。&lt;/p&gt;
</description>
<pubDate>Tue, 07 May 2019 04:01:00 +0000</pubDate>
<dc:creator>北京-宏哥</dc:creator>
<og:description>简介 上一篇，我们虽然已经将生成的最新的测试报告发出去了，但是MIMEText 只能发送正文，无法带附件，因此我还需要继续改造我们的代码，实现可以发送带有附件的邮件。发送带附件的需要导入另外一个模块</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/du-hong/p/10819199.html</dc:identifier>
</item>
<item>
<title>Java 中的多态，一次讲个够之继承关系中的多态 - 夏天里的Jasmine</title>
<link>http://www.cnblogs.com/qianjinyan/p/10824576.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qianjinyan/p/10824576.html</guid>
<description>&lt;pre readability=&quot;5&quot;&gt;
&lt;span&gt;多态是继封装、继承之后，面向对象的第三大特性。
现实事物经常会体现出多种形态，如学生，学生是人的一种，则一个具体的同学张三既是学生也是人，即出现两种形态。   
Java作为面向对象的语言，同样可以描述一个事物的多种形态。如Student类继承了Person类，一个Student的对象便既是Student，又是Person。
Java中多态的代码体现在一个子类对象(实现类对象)既可以给这个子类(实现类对象)引用变量赋值，又可以给这个子类(实现类对象)的父类(接口)变量赋值。
如Student类可以为Person类的子类。那么一个Student对象既可以赋值给一个Student类型的引用，也可以赋值给一个Person类型的引用。
最终多态体现为父类引用变量可以指向子类对象。
&lt;/span&gt;&lt;br/&gt;&lt;span readability=&quot;4&quot;&gt;&lt;span&gt;多态的前提是必须有&lt;strong&gt;子父类关系&lt;/strong&gt;或者&lt;strong&gt;类实现接口关系&lt;/strong&gt;，否则无法完成多态。&lt;/span&gt;
在使用多态后的父类引用变量调用方法时，会调用子类重写后的方法。&lt;p&gt;文字再怎么讲，都不够生动，直接用代码来体现&lt;/p&gt;&lt;p&gt;老爸要喝酒，那今天喝什么酒呢，&lt;br/&gt;&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Wine {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; drinkWine(){
        System.out.println(&lt;/span&gt;&quot;===今天我要喝什么酒呢====&quot;&lt;span&gt;);
        Wine();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Wine(){
        System.out.println(&lt;/span&gt;&quot;===看看俺今天能喝啥子哟====&quot;&lt;span&gt;);
    }
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; JNC &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Wine {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * @desc 子类重载父类方法
     *        父类中不存在该方法，向上转型后，父类是不能引用该方法的
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; a
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; void
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; drinkWine(String a){
        System.out.println(&lt;/span&gt;&quot;======今天我要喝剑南春====&quot;&lt;span&gt;);
        Wine();
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 子类重写父类方法
     * 指向子类的父类引用调用Wine时，必定是调用该方法
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Wine(){
        System.out.println(&lt;/span&gt;&quot;=====剑南春喝上啦，好开森=====&quot;&lt;span&gt;);
    }
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        Wine a &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JNC();
        a.drinkWine();
        a.Wine();

        Wine b &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Wine();
        b.drinkWine();
        b.Wine();

        JNC c&lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JNC();
        c.drinkWine(&lt;/span&gt;&quot;qq&quot;&lt;span&gt;);
    }
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1064427/201905/1064427-20190507101555162-1973686560.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;先来看看这一段，&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;Wine a = new JNC();&lt;/span&gt;&lt;br/&gt;&lt;span&gt;a.drinkWine();&lt;/span&gt;&lt;br/&gt;&lt;span&gt;a.Wine();&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;子类剑南春中的drinkWine带有参数，而父类中的drinkWine不带有参数，即父类不存在这个方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;运行的时候，调用的是父类的drinkWine，先输出了 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;===今天我要喝什么酒呢====&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;之后继续调用Wine方法，这个时候是去了子类中，指向子类的父类引用调用Wine时，必定是调用子类中的方法，于是输出了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;=====剑南春喝上啦，好开森=====&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;上面的Wine和JNC中的方法，都没有带Static，如果加上Static呢，看一下代码和运行的结果&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Wine {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; drinkWine() {
        System.out.println(&lt;/span&gt;&quot;===今天我要喝什么酒呢====&quot;&lt;span&gt;);
        Wine();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Wine() {
        System.out.println(&lt;/span&gt;&quot;===看看俺今天能喝啥子哟====&quot;&lt;span&gt;);
    }
}


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; JNC &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Wine {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; drinkWine(String a) {
        System.out.println(&lt;/span&gt;&quot;======今天我要喝剑南春====&quot;&lt;span&gt;);
        Wine();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Wine() {
        System.out.println(&lt;/span&gt;&quot;=====剑南春喝上啦，好开森=====&quot;&lt;span&gt;);
    }
}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        Wine a &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JNC();
        a.drinkWine();
        a.Wine();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到，静态方法，即使向上转型，也只能调用自己的方法啦&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1064427/201905/1064427-20190507103535850-559365038.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;上面比较的是子类和父类的方法，在非静态方法和静态方法，父类引用子类的方法，非静态方法下可以调用子类同名的构造函数方法，不能调用不一样的构造方法&lt;/p&gt;
&lt;p&gt;静态方法中，子类向上转型后，父类引用都不能进行调用子类的方法&lt;/p&gt;
&lt;p&gt;下面来给父类和子类一些变量，以及一些方法，方法都是非静态的&lt;/p&gt;
&lt;p&gt;父类，定义了一些姓名，年龄，兴趣爱好等的变量&lt;/p&gt;
&lt;p&gt;和一些say和hobby的方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Father {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String fathername;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; fatherage;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String fahterhobby;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; say() {
        System.out.println(&lt;/span&gt;&quot;==我是你爸爸真伟大,养你这么大==&quot;&lt;span&gt;);
        myhobby();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; myhobby() {
        System.out.println(&lt;/span&gt;&quot;==我是你爸爸真伟大，只要你妈妈==&quot;&lt;span&gt;);
    }


    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Father() {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;();
    }


    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Father(String fathername, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; fatherage, String fahterhobby) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.fathername =&lt;span&gt; fathername;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.fatherage =&lt;span&gt; fatherage;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.fahterhobby =&lt;span&gt; fahterhobby;
    }


&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;省略getters and setters&lt;/span&gt;
&lt;span&gt;    
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;Father{&quot; +
                &quot;fathername='&quot; + fathername + '\'' +
                &quot;, fatherage=&quot; + fatherage +
                &quot;, fahterhobby='&quot; + fahterhobby + '\'' +
                '}'&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String toString(String fathername, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; fatherage, String fahterhobby) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;Father{&quot; +
                &quot;fathername='&quot; + fathername + '\'' +
                &quot;, fatherage=&quot; + fatherage +
                &quot;, fahterhobby='&quot; + fahterhobby + '\'' +
                '}'&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;子类和父类差不多，其实不应该定义一样的变量，虽然名称改了一下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Son &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Father {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; say(){
        System.out.println(&lt;/span&gt;&quot;==爸爸我要出去玩===&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; say(String s){
        System.out.println(&lt;/span&gt;&quot;==爸爸我要出去玩===&quot; +&lt;span&gt;s);
    }


    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; myhobby(String aaa){
        System.out.println(&lt;/span&gt;&quot;==爸爸给我买这个玩具： &quot; +&lt;span&gt; aaa);
    }


    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String sonname;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; sonage;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String sonhobby;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Son(String sonname, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; sonage, String sonhobby) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sonname =&lt;span&gt; sonname;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sonage =&lt;span&gt; sonage;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sonhobby =&lt;span&gt; sonhobby;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Son(String fathername, &lt;span&gt;int&lt;/span&gt; fatherage, String fahterhobby, String sonname, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; sonage, String sonhobby) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(fathername, fatherage, fahterhobby);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sonname =&lt;span&gt; sonname;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sonage =&lt;span&gt; sonage;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sonhobby =&lt;span&gt; sonhobby;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;省略getters and setters&lt;/span&gt;
&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String toString(String sonname, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; sonage, String sonhobby) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;Son{&quot; +
                &quot;sonname='&quot; + sonname + '\'' +
                &quot;, sonage=&quot; + sonage +
                &quot;, sonhobby='&quot; + sonhobby + '\'' +
                '}'&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试：&lt;/p&gt;
&lt;p&gt;主要测试如下：&lt;/p&gt;
&lt;p&gt;子类中，对say()无参数的方法进行了改写，输出内容不一致了，且有自己新创建的say（String s）带有入参的方法&lt;/p&gt;
&lt;p&gt;子类对myhobby也新增了，有了入参&lt;/p&gt;
&lt;p&gt;子类中对toString方法也带有入参的&lt;/p&gt;
&lt;p&gt;实例化子类对象，父类引用，即向上转型了，调用say(),这个方法子类中有； 调用myhobby(), 子类中没有myhobby(), 只有myhobby(String aaa) 然后还要调用toString()， 有参数和无参数的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; test {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        Father father &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Son(&quot;张三&quot;,35,&quot;LOL&quot;,&quot;张四&quot;,5,&quot;Learn&quot;&lt;span&gt;);
        System.out.println(&lt;/span&gt;&quot;实例化一个Son对象，用父亲接收&quot;&lt;span&gt;);
        father.say();
        father.myhobby();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;代码报错
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; father.myhobby(&quot;LOL惊奇娃娃&quot;);&lt;/span&gt;
&lt;span&gt;        System.out.println(father.toString());
        System.out.println(father.toString(&lt;/span&gt;&quot;张三&quot;,35,&quot;LOL&quot;&lt;span&gt;));

        System.out.println(&lt;/span&gt;&quot;\n&quot;&lt;span&gt;);


        Son son &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Son(&quot;张四&quot;,5,&quot;Learn&quot;&lt;span&gt;);
        System.out.println(&lt;/span&gt;&quot;实例化一个Son对象，用Son接收&quot;&lt;span&gt;);
        son.say();
        son.say(&lt;/span&gt;&quot;上海迪士尼&quot;&lt;span&gt;);
        son.myhobby();
        son.myhobby(&lt;/span&gt;&quot;LOL惊奇娃娃&quot;&lt;span&gt;);
        System.out.println(son.toString(&lt;/span&gt;&quot;张四&quot;,5,&quot;Learn&quot;&lt;span&gt;));

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 运行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1064427/201905/1064427-20190507111714738-1781477211.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1. 父类引用调用say()， 由于子类中有这个方法，调用的是子类的这个方法；&lt;/p&gt;
&lt;p&gt;调用myhobby();， 由于子类中没有这个方法，调用的是父类的这个方法；&lt;/p&gt;
&lt;p&gt;调用子类中带有参数的方法，father.myhobby(&quot;LOL惊奇娃娃&quot;);代码直接报错了&lt;/p&gt;
&lt;p&gt;调用toString()，分别是无参数和有参数，因为子类中只有三个有参数的，没有无参数的，就无参数返回的是父类的，有参数返回的是子类的&lt;/p&gt;

&lt;p&gt;2. 子类引用指向子类对象，调用say()无参数的和有参数的，由于子类中都有，都是子类自己的方法进行返回&lt;/p&gt;
&lt;p&gt;调用myobby()无参数的和有参数的，由于子类中没有无参数的，就去爸爸那儿找了找，返回了爸爸的爱好，子类中有带参数的，就返回了子类自己的&lt;/p&gt;
&lt;p&gt;调用toString(3个参数略),就返回了自己的方法，如果调用不带参数的toString(),就是返回一个父亲中的方法了。。。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;总结： 父类引用指向子类，调用返回的时候，看看自己家有没有啊，有啊，哦，不管了，先去儿子家找找，儿子有啊，儿子用你家的，儿子没有啊，回家用自己的方法吧&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;子类引用指向子类，调用返回的时候，先去自己(即儿子)方法中看看，我自己没有呀，去父亲方法中看看吧&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;上面看的继承中的父子关系是，爸爸有，儿子有，儿子有新的&lt;/p&gt;
&lt;p&gt;下面继续看继承，论父子之间的关系之，爸爸没有，儿子有；&lt;/p&gt;
&lt;p&gt;员工对象，只有一个mailCheck()方法，定义了一些变量&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Employee {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String address;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; number;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Employee(String name, String address, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; number) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;System.out.println(&quot;Employee 构造函数&quot;);&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.address =&lt;span&gt; address;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.number =&lt;span&gt; number;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; mailCheck() {
        System.out.println(&lt;/span&gt;&quot;邮寄支票给： &quot; + &lt;span&gt;this&lt;/span&gt;.name + &quot; &quot; + &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.address);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;Employee{&quot; +
                &quot;name='&quot; + name + '\'' +
                &quot;, address='&quot; + address + '\'' +
                &quot;, number=&quot; + number +
                '}'&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;省略getters and setters&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
Salary对象继承了父类
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Salary &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Employee{

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; yearsalary; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 全年工资&lt;/span&gt;

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; getSalary() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; yearsalary;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setSalary(&lt;span&gt;double&lt;/span&gt;&lt;span&gt; salary) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(salary &amp;gt;= 0.0&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.yearsalary =&lt;span&gt; salary;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; computePay() {
        System.out.println(&lt;/span&gt;&quot;计算工资，付给：&quot; +&lt;span&gt; getName());
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; yearsalary/12&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Salary(String name, String address, &lt;span&gt;int&lt;/span&gt; number, &lt;span&gt;double&lt;/span&gt;&lt;span&gt; yearsalary) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(name, address, number);
        setSalary(yearsalary);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; mailCheck() {
        System.out.println(&lt;/span&gt;&quot;Salary 类的 mailCheck 方法 &quot;&lt;span&gt;);
        System.out.println(&lt;/span&gt;&quot;邮寄支票给：&quot; + getName()+ &quot; ，工资为：&quot; +&lt;span&gt; yearsalary);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Demo {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String [] args) {
        Salary s &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Salary(&quot;员工 A&quot;, &quot;北京&quot;, 3, 360000.00&lt;span&gt;);
        s.mailCheck();
        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; sa =&lt;span&gt; s.computePay();
        System.out.println(sa);

        System.out.println(&lt;/span&gt;&quot;\n&quot;&lt;span&gt;);

        Employee e &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Salary(&quot;员工 B&quot;, &quot;上海&quot;, 2, 240000.00&lt;span&gt;);
        e.mailCheck();
        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; salary =&lt;span&gt; ((Salary) e).computePay();
        System.out.println(salary);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1064427/201905/1064427-20190507115503283-2129020611.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;必要要强转 &lt;strong&gt; ((Salary) e).computePay(); 即必须向下转型，父亲引用转化为子类的，再去调用子类的方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;即回答：论父子之间的关系之，爸爸没有，儿子有；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本来是爸爸类型的引用，将爸爸类型的引用向下转型，然后调用&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;问题来啦，我是父亲，我有两个儿子或者多个儿子呢，闹啥啊， 爸爸没有这个方法，儿子们都有呢，咋办咧&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Animal {

    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; eat() {
        System.out.println(&lt;/span&gt;&quot;Animal&quot;&lt;span&gt;);
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Cat &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Animal {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; eat() {
        System.out.println(&lt;/span&gt;&quot;===我是猫咪我要吃鱼&quot;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; work() {
        System.out.println(&lt;/span&gt;&quot;===我是猫咪我负责抓老鼠&quot;&lt;span&gt;);
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Dog &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Animal {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; eat() {
        System.out.println(&lt;/span&gt;&quot;====我是小狗我要吃骨头&quot;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; work() {
        System.out.println(&lt;/span&gt;&quot;====我是小狗我负责看家&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        show(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Cat());  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 以 Cat 对象调用 show 方法&lt;/span&gt;
        System.out.println(&quot;\n&quot;&lt;span&gt;);
        show(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Dog());  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 以 Dog 对象调用 show 方法&lt;/span&gt;
        System.out.println(&quot;\n&quot;&lt;span&gt;);


        Animal a &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Cat();  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 向上转型&lt;/span&gt;
        a.eat();               &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用的是 Cat 的 eat&lt;/span&gt;
        Cat c = (Cat)a;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 向下转型&lt;/span&gt;
        c.work();        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用的是 Cat 的 work&lt;/span&gt;
&lt;span&gt;    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; show(Animal animal)  {
        animal.eat();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 类型判断&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (animal &lt;span&gt;instanceof&lt;/span&gt; Cat)  {  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 猫做的事情&lt;/span&gt;
            Cat c =&lt;span&gt; (Cat)animal;
            c.work();
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (animal &lt;span&gt;instanceof&lt;/span&gt; Dog) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 狗做的事情&lt;/span&gt;
            Dog c =&lt;span&gt; (Dog)animal;
            c.work();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1064427/201905/1064427-20190507120656613-181831971.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 不如咱直接将动物类改成抽象类吧，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Animal {

    &lt;/span&gt;&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; eat() ;

}


&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Cat &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Animal {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; eat() {
        System.out.println(&lt;/span&gt;&quot;===我是猫咪我要吃鱼&quot;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; work() {
        System.out.println(&lt;/span&gt;&quot;===我是猫咪我负责抓老鼠&quot;&lt;span&gt;);
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Dog &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Animal {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; eat() {
        System.out.println(&lt;/span&gt;&quot;====我是小狗我要吃骨头&quot;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; work() {
        System.out.println(&lt;/span&gt;&quot;====我是小狗我负责看家&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;欢迎继续关注下一篇，在接口实现中的实现多态&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 07 May 2019 03:57:00 +0000</pubDate>
<dc:creator>夏天里的Jasmine</dc:creator>
<og:description>先来看看这一段， 子类剑南春中的drinkWine带有参数，而父类中的drinkWine不带有参数，即父类不存在这个方法 运行的时候，调用的是父类的drinkWine，先输出了 今天我要喝什么酒呢 之</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qianjinyan/p/10824576.html</dc:identifier>
</item>
<item>
<title>BERT解析及文本分类应用 - xlturing</title>
<link>http://www.cnblogs.com/xlturing/p/10824400.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xlturing/p/10824400.html</guid>
<description>&lt;p&gt;在18年末时，NLP各大公众号、新闻媒体都被BERT（《BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding》）刷屏了，刷新了自然语言处理11项纪录，也被称为了2018年最强自然语言处理模型。&lt;/p&gt;
&lt;p&gt;笔者很早便完整看了这篇论文，迟迟没有动手，一方面是因为自己懒，各种事情耽搁了，另一方面还是想通过在具体的任务中进行了确切的实践后再与大家分享交流。废话不多说，下面我们进入正题，2018最强自然语言处理模型BERT（注意修饰语2018，因为最近冒出来的OpenAI的研究人员训练的超大规模15亿参数模型已经进一步打破了记录，并开源了一个117M的小模型和代码：&lt;a href=&quot;https://github.com/openai/gpt-2%EF%BC%8C%E6%84%9F%E5%85%B4%E8%B6%A3%E7%9A%84%E8%AF%BB%E8%80%85%E5%8F%AF%E4%BB%A5%E7%9C%8B%E7%9C%8B&quot; class=&quot;uri&quot;&gt;https://github.com/openai/gpt-2，感兴趣的读者可以看看&lt;/a&gt;）&lt;/p&gt;

&lt;p&gt;了解BERT模型我们需要先回顾谷歌在早前发表的一些观点和paper，我们首先来简单回顾下seq2seq，之后说说attention引出的transformer模型，最后看看BERT模型的细节以及创新点。&lt;/p&gt;
&lt;h2 id=&quot;seq2seq&quot;&gt;Seq2Seq&lt;/h2&gt;
&lt;p&gt;关于Seq2Seq的模型抽象，笔者之前在浅谈分词算法系列博文中也有反复提及（&lt;a href=&quot;https://www.cnblogs.com/xlturing/p/10230728.html&quot;&gt;浅谈分词算法（5）基于字的分词方法（bi-LSTM）&lt;/a&gt;），在分词或者词性标注的NLP任务中，我们将文本序列映射到另一个结果序列，如词性tag，分词的BEMS标记tag等。&lt;/p&gt;
&lt;p&gt;而在另一类NLP任务，即机器翻译（MT）中，也可以抽象成一种序列到序列的模型，在谷歌2014年的论文&lt;a href=&quot;https://arxiv.org/abs/1409.3215&quot;&gt;Sequence to Sequence Learning with Neural Networks&lt;/a&gt;中，提出了端到端的序列到序列的映射模型，利用了LSTM分别做编码和解码（encoder-decoder）操作，并在英文与法文的互相翻译上取得了很棒的效果。比较经典的模型了，网上资料一大把，我们来简单说说这个模型，详细的读者可以翻论文和各种资料。&lt;/p&gt;
&lt;p&gt;Seq2Seq即序列到序列的模型，将输入序列&lt;span class=&quot;math inline&quot;&gt;\((x_1,x_2,...,x_T)\)&lt;/span&gt;映射到输出序列&lt;span class=&quot;math inline&quot;&gt;\((y_1,y_2,...,y_{T'})\)&lt;/span&gt;，其中每个&lt;span class=&quot;math inline&quot;&gt;\(y_t\)&lt;/span&gt;依赖于之前的输出值&lt;span class=&quot;math inline&quot;&gt;\(y_1,y_2,...,y_{t-1}\)&lt;/span&gt;，另外值得注意的是，在大多数应用场景中输入序列和输出序列的长度是不相等的&lt;span class=&quot;math inline&quot;&gt;\((T\neq T')\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;NMT是典型的Seq2Seq应用场景，将输入序列的一种语言翻译为输出序列的另一种语言，基于条件概率：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[p(y_1,y_2,...,y_{T'}|x_1,x_2,...,X_T)\]&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[h_t=encoder(h_{t-1},x_t)\]&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[s_t=decoder(s_{t-1},y_{t-1},c_t)\]&lt;/span&gt;&lt;br/&gt;其中&lt;span class=&quot;math inline&quot;&gt;\(c_t\)&lt;/span&gt;表示通过注意力机制（Attention）计算的上下文信息：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[c_t=attention(s_{t-1},\mathbf{h})\]&lt;/span&gt;&lt;br/&gt;条件概率可以通过以下公式进行计算：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[p(y_1,...,y_{T'}|x_1,...,x_T)=\prod_{t=1}^{T'}p(y_t|y_{&amp;lt;t},x)\]&lt;/span&gt;&lt;br/&gt;其中&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[p(y_t|y_{&amp;lt;t},x)=softmax(f(s_t))\]&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(f(\cdot)\)&lt;/span&gt;是一个全连接层，对于机器翻译任务而言，softmax函数用于计算词典中每个词的概率。&lt;/p&gt;
&lt;p&gt;encoder-decoder的这种框架在深度模型中是非常常用的，很多实际的NLP问题可以抽象到这个框架上来进行建模，比如NMT（机器翻译）、TTS（语音合成）、ASR（语音识别）等。&lt;/p&gt;
&lt;h2 id=&quot;attention&quot;&gt;Attention&lt;/h2&gt;
&lt;p&gt;我们了解了Seq2Seq模型后，再来一起看看对其增加Attention后的模型。在Neural Machine Translation by Jointly Learning to Align and Translate这篇论文中，Bahdanau等人在原有Seq2Seq框架的基础上新增了attention（注意力机制），其基于的主要先验感知是：基本的encoder-decoder框架在达到瓶颈后，作者希望通过将源句中与目标句对应部分的关联程度，由模型来自动查找（soft search），而不是硬性的切分。换句好理解的，源句中的每个词在翻译到目标词汇时起到的作用是不一样的，作者希望模型能够学出这种关联强度。举个例子：&lt;/p&gt;
&lt;p&gt;我/想/买/苹果/手机。&lt;/p&gt;
&lt;p&gt;I want to buy iPhone.&lt;/p&gt;
&lt;p&gt;比如在翻译苹果这个词的step时，这时候会有一个明显的歧义，是吃的苹果呢，还是商标品牌呢，那么源句中苹果的上下文对翻译时产生的影响是不一样的，我/想/买，仅凭这三个词我们并不能解决这个苹果的歧义问题，但是看到苹果后面跟着手机这个词，歧义马上消除，苹果指品牌。那么在这个过程中，很明显手机这个词所起到的作用是远远大于我/想/买三个词的。&lt;/p&gt;
&lt;p&gt;这只是一个非常直观上的感知，为什么Attention会起作用，当然模型内部的逻辑不会这么具化。下面我们一起看下具体的模型定义：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/524764/201903/524764-20190302185014090-123375859.png&quot; alt=&quot;attention模型图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图中我们可以看到大的还是一个encoder-decoder的框架，但是在decoder的过程中，不是将final-state直接作为输入给到，而是在每个step解码时，都考虑encoder过程中对每个词的编码，并以一个权重的形式加权后作为当前step预测的输入，我们来具体看下模型定义：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;模型输入为：&lt;span class=&quot;math inline&quot;&gt;\(X=(x_0,x_1,x_2,...,x_T)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;模型输出为：&lt;span class=&quot;math inline&quot;&gt;\(Y=(y_0,y_1,y_2,....,y_T)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;encoder层隐层状态：&lt;span class=&quot;math inline&quot;&gt;\(H=(h_0,h_1,h_2,...,h_T)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;decoder层上一时刻隐层状态：&lt;span class=&quot;math inline&quot;&gt;\(s_{t-1}\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;decoder层上一时刻的输出：&lt;span class=&quot;math inline&quot;&gt;\(y_{t-1}\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;当前decoder step的上下文：&lt;span class=&quot;math inline&quot;&gt;\(c_t\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;图中整个attention的流程是：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;根据输入X，利用双向LSTM得到两组隐向量，直接concat后得到最终的H；&lt;/li&gt;
&lt;li&gt;根据encoder层得到的H，对于第t时刻的步骤，当前时刻的上下文&lt;span class=&quot;math inline&quot;&gt;\(c_t\)&lt;/span&gt;由以下方法计算：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[c_i=\sum_{j=1}^{T_x} \alpha_{ij}h_j\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;span class=&quot;math inline&quot;&gt;\(\alpha_{ij}\)&lt;/span&gt;是权重，又称为alignment；h是当前时刻step的encoder所有隐变量，又叫做value或者memory； i代表decoder层的时刻step， j代表encoder层的时刻step。&lt;/p&gt;
&lt;p&gt;而&lt;span class=&quot;math inline&quot;&gt;\(\alpha_{ij}\)&lt;/span&gt;的计算方式如下：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\alpha_{ij}=\frac {exp(e_{ij})} {\sum_{k=1}^{T_x}exp(e_{ik})}\]&lt;/span&gt;&lt;br/&gt;其中&lt;span class=&quot;math inline&quot;&gt;\(e_{ij}=a(s_{i-1},h_j)\)&lt;/span&gt;，我们来解释下这波公式：本质上&lt;span class=&quot;math inline&quot;&gt;\(\alpha\)&lt;/span&gt;就是一个softmax，其作用就是用一个概率和为1的分布，来刻画encoder不同时刻得到的隐变量的权重，从而衡量其对decoder的重要性；而&lt;span class=&quot;math inline&quot;&gt;\(e_{ij}\)&lt;/span&gt;其实是通过a，一种线性表达式来度量&lt;span class=&quot;math inline&quot;&gt;\(s_{i-1},h_j\)&lt;/span&gt;之间的相关程度。细化下a（在论文中称为 alignment mode）的计算方式：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;对&lt;span class=&quot;math inline&quot;&gt;\(s_{i-1}\)&lt;/span&gt;做线性映射，得到的向量起名为query，记为&lt;span class=&quot;math inline&quot;&gt;\(q_i\)&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;同样对&lt;span class=&quot;math inline&quot;&gt;\(h_j\)&lt;/span&gt;做线性映射，得到的向量起名为key，记为&lt;span class=&quot;math inline&quot;&gt;\(k_j\)&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;最终&lt;span class=&quot;math inline&quot;&gt;\(e_{ij}=v^T\cdot (q_i+k_j)\)&lt;/span&gt;，其中&lt;span class=&quot;math inline&quot;&gt;\(q_i k_j\)&lt;/span&gt;维度一致记为d，v的维度为d*1。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;上面在做alignment时采用了query和key相加的方式，如果换成相乘，那么就是乘性attention，还有一些其他变种，大家可以找找相关论文根据具体任务和x、y的向量空间具体分析。&lt;/p&gt;
&lt;p&gt;总结下，attention在原有的encoder-decoder框架的基础上，通过query和key的相关程度，之后通过类似softmax的归一化操作得到权重，利用权重、隐状态进行加权和得到上下文context向量，作为decoder层的输入。直观上attention使得与decoder层的状态s相关度越大的h，权重会越高，从而在context中占比更多，对y的输出影响更大，这也是直观的先验解释，为什么attention会这么有效。&lt;/p&gt;
&lt;p&gt;注意：这里记住query、key和value的由来，没啥为什么，就起了个别名，在transfomer中它们还将发挥更多的作用。&lt;/p&gt;
&lt;h2 id=&quot;transformer&quot;&gt;Transformer&lt;/h2&gt;
&lt;p&gt;在聊完Attention机制后，我们来聊一聊更加激进的一个模型，Transformer，该框架是谷歌于2017年发表的一篇paper：Attention is all you need[3]。为什么说其激进呢，因为传统意义上的attention框架是构建在RNN或者CNN的基础上，而在该篇论文中，整个框架完全是基于attention的思路建立的，所以也就起名为Attetion is all you need（名字有点嚣张...），下面我们一起来看看transformer模型，先上图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/524764/201903/524764-20190326105900624-388721810.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这张图是论文中模型架构图，从主体上看，模型还是遵照了encoder-decoder的框架，左半部分为编码部分，右半部分为解码部分，我们一步步拆解开说下。&lt;/p&gt;
&lt;p&gt;图中在Encoder和Decoder两边有Nx的标志，原文中也解释了Encoder部分叠加了6个完全一样的层，同样Decoder层也包含6个相同的层，不过值得注意的是模型中每一层之间都用到了残差连接。&lt;/p&gt;
&lt;p&gt;对于每层Encoder的内部，首先会通过一个self-attention层，之后跟一层全连接前馈神经网络；而对于每层Decoder的内部，首先通过一个self-attention，之后会多跟一个attention层用于单词聚焦（类似之前RNN中加入的attention作用），之后同样会跟一层全连接前馈神经网络。&lt;/p&gt;
&lt;h3 id=&quot;encoder部分&quot;&gt;encoder部分&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;（1）self-attention&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上文中Transformer的整体结构我们明白了，我们首先来阐述下self-attention。关于Attention我们在前文中已有详细阐述，只不过之前的attention层依托于RNN之上，而在transformer中使用的self-attention其核心思想来源于attention，不过是独立的一层模型，我们首先直观的理解下self-attention的原理：&lt;/p&gt;
&lt;p&gt;例句：因为小狗太累了，所以它没有穿过街区。&lt;/p&gt;
&lt;p&gt;我们在理解这句话中的“它”时，很容易关联到“小狗”，那计算机在用向量表征“它”这个词时，如何做到兼顾上下文呢？并且更多的关注到“小狗”这个词，而不是“因为”或者“街区”这些词呢？&lt;/p&gt;
&lt;p&gt;我们先回顾一下RNN中计算步骤t的词&lt;span class=&quot;math inline&quot;&gt;\(w_t\)&lt;/span&gt;的hidden-state时是怎么做的？输入当前词的embedding，并且接收来自t-1的状态向量，根据遗忘门控制接收程度，这样在计算当前词的hidden-state向量时，就考虑了之前的序列（上文），那么如果也想考虑当前词之后的序列（下文）怎么办呢？那就正反各来一遍RNN，即bi-RNN。&lt;/p&gt;
&lt;p&gt;现在回到self-attention模型，如果要计算当前词的向量表征，那么我们需要关注上下文其它词，并且每个词对当前词的影响不同，即注意力不同，下面我们进一步细剖析原理。&lt;/p&gt;
&lt;p&gt;简单回顾下上文attention时提到的query、key和value的概念（笔者专门让大家注意），通过对s做映射得到query，对h做映射得到key，而h也即是value，之后通过query和key计算关联度之后，利用加权和的方式获得最终的编码向量。&lt;/p&gt;
&lt;p&gt;那么在self-attention中，所谓self就都是它自己，没有所谓encoder和decoder的区分，对于经过embedding后的文本向量，通过三个不同的权重向量，分别映射成为query、key以及value，之后通过下图的步骤得到最终的编码向量：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/524764/201904/524764-20190411201744644-169435637.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以看到除了映射成为query、key、value时的过程与attention不同外，后续的计算流程self-attention与attention是基本一致的，计算过程如下：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[Attention(Q,K,V)=softmax(\frac{QK^T}{\sqrt{d_k}})V\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在阅读原论文时，我们会发现论文中在self-attention的基础上，有一个Multi-Head Attention，即多头注意力机制，就是字面意思，将文本embedding通过多个self-attention得到不同的编码结果，然后拼接起来进入下一层，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/524764/201904/524764-20190411202806002-1999017291.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样做的主要目的是从不同的语义空间投射原文本，能够从更多的角度表征，并且能够拓展模型对不同位置的关注能力。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(2)输入编码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;包括CNN、LSTM，我们在进入模型前，需要先将自然语言通过embedding的方式进行编码，从而将高维语义空间的自然语言转化到低维的向量空间，这基本上成了目前NLP的通用模式。那么在Transformer中为什么我们要单独再来说说embedding的问题呢？&lt;/p&gt;
&lt;p&gt;熟悉LSTM的可以回忆下，我们将每个词或者字符编码成embedding后，会按照正序或者逆序进入LSTM，在这个过程中，序列中词的位置信息是得到保存的；其实Text-CNN也可以通过不同大小的filter，捕捉到句子中词序的信息。&lt;/p&gt;
&lt;p&gt;但是在Transformer中，我们发现序列编码好的矩阵，进入模型，分别通过三个不同的权重矩阵变成了Q、K、V，这个过程当中词序的信息是丢失了的，为了解决这个问题，Transformer在Embedding的基础上，加上了位置编码（Position Encoding），没错就是两者直接相加。原文中在对位置进行编码时，用了一种神奇的规则，利用sine和cosine，正余弦函数来编码，论文中解释了也使用了可学习的位置编码方式，但发现效果差不多，最后选择了正余弦编码方式，因为这种编码方式能够将位置编码扩展到看不见长度的序列优点（比如推断过程中出现的序列比训练样本中任何文本都长）。也比较玄学，感觉作者也是做了很多实验对比选择了一个较优方案吧，编码方式如下：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[PE_{(pos,2i)}=sin(pos/10000^{2i/d_model})\]&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[PE_{(pos,2i+1)=cos(pos/10000^{2i/d_model})}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中pos是位置，i是维度。也就是说，位置编码的每个维度波长形成从2π到10000·2π的几何级数。而作者提到选择此功能是因为其假设它可以让模型轻松学会理解相对位置，因为对于任何固定偏移k，PEpos + k可以表示为一个线性的PEpos。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(3)残差和FFN&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;还有两个细节我们没有提到，就是Transformer中的残差和FFN部分。在FFN的部分，模型使用了ReLU作为激活函数，公式如下：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[FFN(x)=max(0,xW_1+b_1)W_2+b_2\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;每一层会使用不同的参数，可以将其理解为两个Kernel size为1的卷积。&lt;/p&gt;
&lt;p&gt;另外一点是在模型结构中，每层都会间隔一层Add &amp;amp; Norm即layer-normalization，这里深度残差网络的特性，将前一层和前前一层的输出进行求和正则后，作为下一层的输入，该思想成名于图像领域的ResNet，当时在imageNet的结果超过了之前的VGG等模型，感兴趣的读者可以瞅瞅。正则化时，文中提到了dropout设置为0.1。&lt;/p&gt;
&lt;h3 id=&quot;decoder部分&quot;&gt;Decoder部分&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;（1）结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;逐层理清模型中Encoder的部分，我们来看看Decoder部分。Decoder部分整体与Encoder是一致的，不过从模型图的右边我们可以看出其多了一个子层Multi-Head Attention，在Decoder时，会先进入第一个子层self-attention，得到Q，之后中间层的atention并不是self-attention，其K、V来自Encoder层，结合前一个Q，进入该子层，有这么几点需要注意下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第i个位置的Encoder输出简单变化作为K、V与i-1位置的Decoder第一个子层的输出作为Q；&lt;/li&gt;
&lt;li&gt;Encoder在编码时可以将输入序列作为一个整体，以矩阵的形式一次性编码，但Decoder时当前位置的输出需要依赖上一个位置的输出，所以是按顺序解码的；&lt;/li&gt;
&lt;li&gt;在Decoder的第一个子层self attention做了mask，保证当前位置i的预测只依赖小于i位置的输出，避免利用未来的信息；&lt;/li&gt;
&lt;li&gt;Decoder层在预测到类似的结束符时便会停止预测。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;（2）Linear和Softmax&lt;/strong&gt;&lt;br/&gt;Decoder经过两个attention子层和一个FFN子层后的输出，其解码向量经过一个线性映射WX+b，将其映射到整个字典空间，然后经过softmax规整成字典词汇的概率分布，即每个词的分数，之后选取分数最高的词作为输出即可。&lt;/p&gt;
&lt;h2 id=&quot;bert&quot;&gt;BERT&lt;/h2&gt;
&lt;p&gt;BERT全称是Bidirectional Encoder Representations from Transformers，取了核心单词的首字母而得名，从名字我们能看出该模型两个核心特质：依赖于Transformer以及双向，下面来看论文中的一结构对比图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/524764/201905/524764-20190506102302208-1284142757.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;论文在最一开始就与另外两个pretrain模型：ELMo和OpenAI GPT做了对比，从结构上我们可以看出ELMo的基础是使用了LSTM，而OpenAI GPT和BERT使用了Transformer作为基本模型。注意BERT一些核心的创新点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;相较于OpenAI GPT模型而言，其为双向Transformer；&lt;/li&gt;
&lt;li&gt;而同是双向，ELMo由于是基于LSTM，BERT基于Transformer，并且核心的是两者的目标函数是不一致的：&lt;br/&gt;OpenAI GPT：&lt;span class=&quot;math display&quot;&gt;\[P(w_i|w_1,...,w_{i-1})\]&lt;/span&gt;&lt;br/&gt;ELMo：&lt;span class=&quot;math display&quot;&gt;\[P(w_i|w_1,...,w_{i-1})和P(w_i|w_{i+1},...,w_n)\]&lt;/span&gt;&lt;br/&gt;BERT：&lt;span class=&quot;math display&quot;&gt;\[P(w_i|w_1,...,w_{i-1},w_{i+1},...,w_n)\]&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;即传统意义双向类似ELMo模型，根据上下文，每个词会得到left-to-right和right-to-left两种表示，我们可以将两者concat在一起作为该词的表示，再进行下游的任务操作。而直觉上，如果我们能有一个更加深入的双向模型，直接能够给出词的上下文表示。遗憾的是，不可能训练像普通LM一样的深度双向模型，因为这会产生一些循环，在这些循环中，单词可以间接地“看到自己”，并且预测变得微不足道（其实这点有待进一步商榷）。&lt;/p&gt;
&lt;p&gt;所以BERT采用了一些非常简单的trick来实现，&lt;br/&gt;利用自编码器，从输入中掩盖了一部分的单词并且必须从上下文重构这些单词。即所谓Masked LM，其实就是通常意义上的“完形填空”。&lt;/p&gt;
&lt;p&gt;关于双向的设计思路，BERT作者在https://www.reddit.com/r/MachineLearning/comments/9nfqxz/r_bert_pretraining_of_deep_bidirectional/进行过详细论述，感兴趣读者可以移步看看。&lt;/p&gt;
&lt;h3 id=&quot;embedding&quot;&gt;Embedding&lt;/h3&gt;
&lt;p&gt;在前文Transformer我们已经详细阐述过了一句话进入模型的Embedding过程，BERT除了token embedding和position embedding，由于还需要以两个句子作为输入，还添加了segment embedding，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/524764/201905/524764-20190507101009267-1272939109.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Token Embeddings是词向量（中文进入就是字符向量），第一个单词是CLS标志，可以用于之后的分类任务&lt;/li&gt;
&lt;li&gt;Segment Embeddings用来区别两种句子，因为预训练不光做LM还要做以两个句子为输入的分类任务&lt;/li&gt;
&lt;li&gt;Position Embeddings和之前文章中的Transformer不一样，不是三角函数而是学习出来的&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;预训练&quot;&gt;预训练&lt;/h3&gt;
&lt;p&gt;BERT为了能够在大规模语料上进行无监督学习，非常巧妙的设计了两个预训练任务：一个是随机遮蔽（mask）掉一个句子中的词，利用上下文进行预测；另一个是预测下一个句子（类似QA场景）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(1) Task #1: Masked LM&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Input:
the man [MASK1] to [MASK2] store
Label:
[MASK1] = went; [MASK2] = store&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该任务就是BERT为了做到双向深度上下文表示设计的预训练trick任务，而在mask单词的时候，作者也采用了一些技巧，随机mask掉15%的token，最终的损失函数只计算mask掉的token。而对于被mask掉的词也并非简单粗暴的将全部替换成[MASK]标签完事，会遵循如下步骤：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;80%即大部分情况下，被mask掉的词会被[MASK]标签代替；&lt;/li&gt;
&lt;li&gt;10%的情况下，将该词用一个随机的词替换掉；&lt;/li&gt;
&lt;li&gt;10%的情况下，保留该词在原位置。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这样做的目的是偏向代表实际观察到的词。另外模型在预训练时，Transformer编码器并不知道哪些词被mask掉了，所以模型对每个词都会关注。同时，因为随机替换仅发生在所有词的1.5％（即15％*10％），对模型的语言理解能力影响很小。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(2) Task #2: Next Sentence Prediction&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Input:
the man went to the store [SEP] he bought a gallon of milk
Label:
IsNext

Input:
the man went to the store [SEP] penguins are flightless birds
Label:
NotNext&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于在LM的下游任务还会涉及到问答（Question Answering (QA) ）和推理（ Natural Language Inference (NLI)）的任务，这需要LM有理解句子间关系的能力，所以作者新增了一个预训练任务，输入句子A和B，预测B是否为A的下一个句子，以50%的概率配对A和B，即50%B是真的，50%B是随机选取的一个句子。&lt;/p&gt;
&lt;p&gt;所以作者提示在选取预训练语料时，要尽可能选取document-level的语料而非segment-level混合在一起的语料。&lt;/p&gt;
&lt;h3 id=&quot;文本分类试验&quot;&gt;文本分类试验&lt;/h3&gt;
&lt;p&gt;利用BERT我在文本分类任务上进行了尝试，语料集是用户评论内容，目标是预测用户评论内容的情感极性，分为正中负三类。&lt;br/&gt;BERT源码拉下来后需要进行一些简单调整，比如将TPUEstimator换成普通的estimator，改变一些模型指标计算方式等。&lt;/p&gt;
&lt;p&gt;笔者首先利用1000W左右的评论语料对BERT的中文预训练模型进行了迁移学习，之后通过500W语料分别在text-cnn、lstm concat cnn以及lstm concat cnn with bert上进行了训练对比。（注：这里lstm concat cnn是笔者在该任务上试验后选取的效果较好的模型结构）&lt;/p&gt;
&lt;p&gt;指标情况如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Text_cnn
Avg acc: 0.8802
sentence num:13530, tags all num:13530, neg num:5539, neu num:1398, pos num:6593
             precision    recall  f1-score   support
          0       0.88      0.96      0.92      5539
          1       0.54      0.22      0.31      1398
          2       0.91      0.95      0.93      6593
avg / total       0.86      0.88      0.86     13530

LSTM concat CNN
precision    recall  f1-score   support
          0       0.92      0.96      0.94      5539
          1       0.60      0.43      0.50      1398
          2       0.93      0.95      0.94      6593
avg / total       0.89      0.90      0.89     13530
0.8997782705099778
3.9ms/条

LSTM concat CNN with BERT
precision    recall  f1-score   support
          0       0.92      0.96      0.94      5539
          1       0.67      0.35      0.46      1398
          2       0.90      0.97      0.94      6593
avg / total       0.89      0.90      0.89     13530
0.9000739098300073
29.365628ms/条&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;笔者在实验过程中发现的几点需要注意：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;直接用BERT进行fine-tune的效果，在中文语料上效果一般，因为中文是以字作为embedding来考虑的，丢失了太多的词语信息；&lt;/li&gt;
&lt;li&gt;将BERT作为辅助上下文，添加在别的模型中，效果会有所提升，但效果有限；&lt;/li&gt;
&lt;li&gt;添加BERT后，CPU做inference速度较慢，需要考虑计算成本&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;鉴于第3点，笔者尝试了将BERT中的字向量完全抽出来，作为辅助输入到模型中，但是这种方式的效果不是很好，直觉上BERT需要依赖上下文来求得当前token的embedding，单独抽出来失去了其双向深度编码的优势。&lt;/p&gt;
&lt;p&gt;后续笔者准备尝试下百度的https://github.com/PaddlePaddle/LARK/tree/develop/ERNIE，其考虑了中文的词语信息，更适合中文场景，BERT只能进行纯字的embedding在中文场景效果提升有限。&lt;/p&gt;
&lt;p&gt;另外还有更好的想法欢迎大家留言一起讨论~&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;Sutskever I, Vinyals O, Le Q V. Sequence to sequence learning with neural networks[C]//Advances in neural information processing systems. 2014: 3104-3112.&lt;/li&gt;
&lt;li&gt;Bahdanau D, Cho K, Bengio Y. Neural machine translation by jointly learning to align and translate[J]. arXiv preprint arXiv:1409.0473, 2014.&lt;/li&gt;
&lt;li&gt;Vaswani A, Shazeer N, Parmar N, et al. Attention is all you need[J]. Advances in Neural Information Processing Systems, 2017: 5998-6008.&lt;/li&gt;
&lt;li&gt;Devlin J, Chang M W, Lee K, et al. Bert: Pre-training of deep bidirectional transformers for language understanding[J]. arXiv preprint arXiv:1810.04805, 2018.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/google-research/bert&quot; class=&quot;uri&quot;&gt;https://github.com/google-research/bert&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Tue, 07 May 2019 03:34:00 +0000</pubDate>
<dc:creator>xlturing</dc:creator>
<og:description>[TOC] 前言 在18年末时，NLP各大公众号、新闻媒体都被BERT（《BERT: Pre training of Deep Bidirectional Transformers for Langu</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xlturing/p/10824400.html</dc:identifier>
</item>
<item>
<title>asp.net core系列 62 CQRS架构下Equinox开源项目分析 - 花阴偷移</title>
<link>http://www.cnblogs.com/MrHSR/p/10820545.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MrHSR/p/10820545.html</guid>
<description>&lt;h3&gt;一.DDD分层架构介绍&lt;/h3&gt;
&lt;p&gt;　　本篇分析CQRS架构下的Equinox开源项目。该项目在github上star占有2.4k。便决定分析Equinox项目来学习下CQRS架构。再讲CQRS架构时，先简述下DDD风格，在DDD分层架构中，一般包含表现层、应用程序层(应用服务层)、领域层(领域服务层)、基础设施层。在DDD中讲到服务这个术语时，比如领域服务,应用层服务等，这个服务是指业务逻辑，而不是指任何技术如wcf,web服务。&lt;/p&gt;
&lt;p&gt;　　下图是从经典三层构架演变为DDD下的分层架构图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201905/151560-20190507101500702-333042048.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;　　1.表现层&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　表现层前端往后端post的数据称&quot;输入模型(InputModel)&quot;，后端控制器传给前端要显示的数据称&quot;视图模型(ViewModel)&quot;，大多时候视图模型与输入模型是重合的,所在在下面要介绍的开源项目中，作者在应用服务层只定义了ViewModels文件夹。例如在MVC中，控制器里只是编排任务，调用应用程序层。&lt;span&gt;在控制器中代码块应该尽可能轻薄，主要作用是找出层与层之间的分离，控制器只是业务逻辑占位符&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　　　在表现层中与运行环境密切相连，表现层需要关注的是http上下文、会话状态等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201905/151560-20190507101636929-570975447.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;2. 应用服务层&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　可以在应用服务层引用领域层和基础设施层，是在领域层之上编排业务用例的服务。该层对业务规则一无所知，不会包含任何与业务有关的状态信息。该层关键特点：&lt;/p&gt;
&lt;p&gt;　　　　(1) 该层是针对不同的前端。该层与表现层有关,是为表现层服务。不同的表现层(移动，webapi, web)都有自己的应用服务层。&lt;span&gt;该层与表现层属于系统的前端&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　　　(2) 应用服务层可能是有状态的，至少就UI任务进度而言。&lt;/p&gt;
&lt;p&gt;　　　　(3) 它从表现层获取输入模型，然后把视图模型返回去。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;3. 领域层&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　&lt;/strong&gt;领域层是最重要和最复杂的一层。在DDD的领域模型架构下。该层包含了所有针对一个或多个用例业务逻辑，领域层包含一个领域模型和一组可能的服务。&lt;/p&gt;
&lt;p&gt;　　　　领域模型大多时候是一个实体关系模型，可以由方法组成。是拥有数据和行为。如果缺少重要行为，那就是一个数据结构，称为贫血模型。领域模型是实现统一语言和表达业务流程所需的操作。&lt;/p&gt;
&lt;p&gt;　　　　领域层包含的服务是领域服务，是涉及多个领域模型而无法放个单个领域模型中的领域逻辑。领域服务是一个类，包含了多个领域模型实体的行为。领域服务通常也需要访问基础设施层。&lt;/p&gt;
&lt;p&gt;　　　　在DDD的CQRS架构下，使用二个不同的领域层，而不是一个(&lt;span&gt;&lt;strong&gt;在Equinox项目中混合成一个&lt;/strong&gt;&lt;/span&gt;)。这种分离把查询操作放在一层(查询领域层)，把命令操作放在另一层(命令领域层)。在CQRS里，查询栈仅仅基于SQL查询，可以完全没有模型、应用程序层和领域层。查询领域层只需要贫血模型类DTO来做传输对象。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;　　4. 基础设施层&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　&lt;/strong&gt;这层使用具体技术有关的任何东西：O/RM工具的数据访问持久层、IOC容器的实现(Unity)、以及很多其它横切关注点的实现,如安全(Oauth2)、日志记录、跟踪、缓存等。&lt;span&gt;最突出的组件是持久层。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;二.CQRS概述&lt;/h3&gt;
&lt;p&gt;　&lt;strong&gt;　1.简介&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　&lt;/strong&gt;CQRS是DDD开发风格下对领域模型架构的一种简化改进。任何业务系统基本都是查询与写入，对应CQRS是指命令/查询责任分离，&lt;span&gt;查询不以任何方式修改系统状态，只返回数据。另一方面，命令(写入)则修改系统的的状态，但不返回数据，除了状态代码或确认信息&lt;/span&gt;。在CQRS里，查询栈仅基于sql查询，可以完全没有模型，应用程序层和领域层。CQRS方案还可以为命令栈和查询栈准备不同的数据库(读与写)。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;2.CQRS的好处&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　&lt;/strong&gt;(1)是简化设计降低复杂性，对于查询来说，可以直接读取基础设施层的仓储。&lt;/p&gt;
&lt;p&gt;　　　　(2)是增强可伸缩性的潜能。比如读取是主导操作，可以引入某种程序的缓存，极大减少访问数据库的次数。比如写入在高峰期减慢系统，可以考虑从经典的同步写入模型换到异步写入甚至命令队列。分离了查询和命令，可以完全隔离处理这两个部分的可伸缩性。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;3.CQRS实现全局图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　&lt;/strong&gt;在全局图中，右图&lt;span&gt;通过虚线表示双重分层架构，分开了命令通道和查询通道，每个通道都有独立架构&lt;/span&gt;。在命令通道里，任何来自表现层的请求都会变成一个命令，并加入到处理器队列。每个命令都携带信息。每个命令都是一个逻辑单元，可以充分地验证相关对象的状态，智能的决定执行哪些更新以及拒绝哪些更新。&lt;span&gt;处理命令可能会产生事件(事件通常是记录命令发生的事情)，这些事件会被其它注册组件处理&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201905/151560-20190507100111966-541260269.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;三. Equinox开源项目总览&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;　　1.准备环境&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　&lt;/strong&gt;　(1)  Github开源地址下载。&lt;a href=&quot;https://github.com/EduardoPires/EquinoxProject&quot; target=&quot;_blank&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;Full ASP.NET Core 2.2 application with DDD, CQRS and Event Sourcing&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　　　(2)  在sqlserver里执行sql文件GenerateDataBase.sql。&lt;/p&gt;
&lt;p&gt;　　　　(3)  修改appsettings.json中的ConnectionStrings的数据库连接地址。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201905/151560-20190506164635502-1025743435.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　&lt;strong&gt;　2.项目分层说明&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;                   表现层：Equinox.UI.Web、Equinox.Services.Api&lt;/p&gt;
&lt;p&gt;                   应用服务层: Equinox.Application&lt;/p&gt;
&lt;p&gt;                   领域层: Equinox.Domain、Equinox.Domain.Core&lt;/p&gt;
&lt;p&gt;                   基础设施层: Equinox.Infra.Data(EF持久化)&lt;/p&gt;
&lt;p&gt;                   基础设施层下的横切关注点：&lt;/p&gt;
&lt;p&gt;                   　　Equinox.Infra.CrossCutting.Bus(事件和命令总线)&lt;/p&gt;
&lt;p&gt;                   　　Equinox.Infra.CrossCutting.Identity(用户管理如登录、注册、授权)&lt;/p&gt;
&lt;p&gt;                  　　 Equinox.Infra.CrossCutting.IoC(控制反转的服务注入)&lt;/p&gt;

&lt;p&gt;　&lt;strong&gt;　3. 项目架构流程梳理图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201905/151560-20190507110414461-2056271450.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;四.表现层分析&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;　&lt;/strong&gt;　在表现层是Equinox.UI.Web和Equinox.Services.Api 服务。在Equinox.UI.Web下主要是用控制器中的CustomerController来演示CQRS框架的实现，以及AccountController和ManageController的用户登录、注册、退出和用户信息管理。&lt;/p&gt;
&lt;p&gt;　　对于AccountController和ManageController两个控制器关联着Equinox.Infra.CrossCutting.Identity项目。Identity项目包括了需要用的视图模型、对系统的授权、自定义用户表数据、用户数据同步到数据库的迁移版本管理、邮件和SMS。对于授权方案通过Equinox.Infra.CrossCutting.IoC来注入服务。如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ASP.NET Authorization Polices&lt;/span&gt;
           services.AddSingleton&amp;lt;IAuthorizationHandler, ClaimsRequirementHandler&amp;gt;();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　Equinox.Services.Api项目实现的功能与Web站点差不多，是通过暴露Web API来实现。下面是表现层的二个项目：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201905/151560-20190506165552464-370272312.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;五. 应用服务层分析&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;　&lt;/strong&gt;　Equinox.Application应用服务层包括对AutoMapper的配置管理，通过AutoMapper实现视图模型和领域模型的实体互转。定义ICustomerAppService服务接口供表现层调用，由CustomerAppService类来实现该接口。项目包含了Customer需要的视图模型。还有事件源EventSource。&lt;/p&gt;
&lt;p&gt;　　由CustomerAppService类来实现表现层的查询、命令、获取事件源。项目结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201905/151560-20190506165745306-1264887478.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;六.领域层Domain.Core分析&lt;/h3&gt;
&lt;p&gt;　　领域层是项目分层架构中，最重要的一层，也是相对复杂的一层。该层作者用了二个项目包括：&lt;span lang=&quot;EN-US&quot;&gt;Domain.Core和&lt;span lang=&quot;EN-US&quot;&gt;Domain。&lt;span lang=&quot;EN-US&quot;&gt;Domain.Core项目结构如下所示：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201905/151560-20190506165823279-1167760017.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　对于Domain.Core项目主要是定义命令和事件的基类。源头是定义的抽象类Message。对于命令和事件,任何前端都会发送消息给应用程序层, Message消息就是数据传输对象，通常消息定义为一个Message基类开始，作为数据容器。&lt;/p&gt;
&lt;p&gt;　　这里使用MediatR中间件作为命令和事件的实现。MediatR支持两种消息类型：Request/Response和Notification。先看下Message消息基类定义：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;注入服务&lt;/span&gt;
    services.AddMediatR(&lt;span&gt;typeof&lt;/span&gt;(Startup));
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Message消息 
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 放入通用属性,甚至是普通标记，没有属性
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Message : IRequest&amp;lt;&lt;span&gt;bool&lt;/span&gt;&amp;gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 消息类型：实现Message的命令或事件类型
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; MessageType { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 聚合ID
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; Guid AggregateId { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; Message()
        {
            MessageType &lt;/span&gt;=&lt;span&gt; GetType().Name;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　消息有二种：命令和事件。两种消息都包含了数据传输对象。命令和事件有些微妙差别，命令和事件都是Message派生类。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Event 领域消息
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 事件类是不可变的，它表示已经发生的事情，意味着只有私有set,没有写入方法。
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 事件存放通用属性，例如事件触发时间，触发的用户，数据版本号。
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt;&lt;strong&gt; Event&lt;/strong&gt; : Message, INotification
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DateTime Timestamp { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; Event()
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;事件时间&lt;/span&gt;
            Timestamp =&lt;span&gt; DateTime.Now;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Command领域命令(增删改)，不返回任何结果(void)，但会改变数据对象的状态。
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt;&lt;strong&gt; Command&lt;/strong&gt; : Message
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DateTime Timestamp { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;DTO绑定验证，使用Fluent API来实现&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; ValidationResult ValidationResult { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; Command()
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;命令时间&lt;/span&gt;
            Timestamp =&lt;span&gt; DateTime.Now;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现Command抽象类的DTO数据验证&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; IsValid();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　Domain.Core项目还定义了领域实体和领域值对象的基类实现。例如：在领域实体基类中实现了相等性、运算符重载、重写HashCode。对于实体和值对象主要区别是：&lt;span&gt;实体有明确的身份标识如主键ID，GUID&lt;/span&gt;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
   　　 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Entity
    　　&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ValueObject&amp;lt;T&amp;gt; &lt;span&gt;where&lt;/span&gt; T : ValueObject&amp;lt;T&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;span lang=&quot;EN-US&quot;&gt;Domain.Core项目中的&lt;span lang=&quot;EN-US&quot;&gt;Notifications消息文件夹，用来确认消息发送后的处理状态。下面是表现层发送更新命令后，&lt;span lang=&quot;EN-US&quot;&gt;IsValidOperation()确认消息处理的状态情况。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;        [HttpPost]
        [Authorize(Policy &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CanWriteCustomerData&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        [Route(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;customer-management/edit-customer/{id:guid}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        [ValidateAntiForgeryToken]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IActionResult Edit(CustomerViewModel customerViewModel)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!ModelState.IsValid) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; View(customerViewModel);

            _customerAppService.Update(customerViewModel);

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (&lt;span&gt;IsValidOperation()&lt;/span&gt;)
                ViewBag.Sucesso &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Customer Updated!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; View(customerViewModel);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;span lang=&quot;EN-US&quot;&gt;Domain.Core项目中的&lt;span lang=&quot;EN-US&quot;&gt;Bus文件夹，用来做命令总线和事件总线的发送接口，由&lt;span lang=&quot;EN-US&quot;&gt;Equinox.Infra.CrossCutting.Bus项目来实现总线接口的发送。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;七.领域层Domain分析&lt;/h3&gt;
&lt;p&gt;　　下面是&lt;span lang=&quot;EN-US&quot;&gt;Domain项目结构如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201905/151560-20190506171157203-2060279611.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在上面结构中，Commands和Events文件夹分别用来存储命令和事件的数据传输对象，是贫血的DTO类，也可以理解为领域实体。例如&lt;span lang=&quot;EN-US&quot;&gt;Commands文件夹下命令数据传输对象定义：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Customer数据转输对象抽象类，放Customer通过属性
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CustomerCommand : Command
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Guid Id { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Email { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DateTime BirthDate { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Customer注册命令消息参数
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RegisterNewCustomerCommand : CustomerCommand
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; RegisterNewCustomerCommand(&lt;span&gt;string&lt;/span&gt; name, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; email, DateTime birthDate)
        {
            Name &lt;/span&gt;=&lt;span&gt; name;
            Email &lt;/span&gt;=&lt;span&gt; email;
            BirthDate &lt;/span&gt;=&lt;span&gt; birthDate;
        }

           &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 命令信息参数验证
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; IsValid()
        {
            ValidationResult &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; RegisterNewCustomerCommandValidation().Validate(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ValidationResult.IsValid;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　当在应用服务层发送命令(&lt;span lang=&quot;EN-US&quot;&gt;Bus.SendCommand)后，由领域层的&lt;span lang=&quot;EN-US&quot;&gt;CommandHandlers文件夹下的类来处理命令，再调用&lt;span lang=&quot;EN-US&quot;&gt;EF持久层来改变实体状态。下面梳理下命令的执行流程，由表现层开始一个&lt;span lang=&quot;EN-US&quot;&gt;customer新增如下所示&lt;span lang=&quot;EN-US&quot;&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201905/151560-20190506172629336-482185139.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　当在表现层点击Create后，调用应用服务层Register方法，触发一个新增事件，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 新增
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;customerViewModel&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;视图模型&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Register(CustomerViewModel customerViewModel)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将视图模型 映射到  RegisterNewCustomerCommand 新增命令实体&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; registerCommand = _mapper.Map&amp;lt;RegisterNewCustomerCommand&amp;gt;&lt;span&gt;(customerViewModel);
            Bus.SendCommand(registerCommand);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　 当SendCommand发送命令后，由领域层CustomerCommandHandler类中的Handle来处理该命令，如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Customer注册命令处理
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;message&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;cancellationToken&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; Task&amp;lt;&lt;span&gt;bool&lt;/span&gt;&amp;gt;&lt;span&gt; Handle(RegisterNewCustomerCommand message, CancellationToken cancellationToken)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对实体属性进行验证&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;message.IsValid())
            {
                NotifyValidationErrors(message);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Task.FromResult(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将命令消息转成领域实体&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; customer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Customer(Guid.NewGuid(), message.Name, message.Email, message.BirthDate);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果注册用户邮件已存在,发起一个事件&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (_customerRepository.GetByEmail(customer.Email) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                Bus.RaiseEvent(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; DomainNotification(message.MessageType, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;The customer e-mail has already been taken.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Task.FromResult(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;由Equinox.Infra.Data.Repository来实现数据持久化。事件是过去在系统中发生的事情。该事件通常是命令的结果.&lt;/span&gt;
&lt;span&gt;            _customerRepository.Add(customer);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;新增成功后，使用事件记录这次命令。&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Commit())
            {
                Bus.RaiseEvent(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; CustomerRegisteredEvent(customer.Id, customer.Name, customer.Email, customer.BirthDate));
            }

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Task.FromResult(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        } &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　　　下面是注册&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;customer&lt;/span&gt;&lt;span&gt;的信息，以及&lt;/span&gt;&lt;span&gt;注册产生的事件数据，如下所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201905/151560-20190507095347648-1843576832.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201905/151560-20190507105638368-426115188.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　在领域层的Interfaces文件夹中，最重要的包括IRepository&amp;lt;TEntity&amp;gt;接口，是通过Equinox.Infra.Data.Repository来实现接口，来进行数据持久化。下面是领域层仓储接口：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 领域层仓储接口，定义了通用的方法
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;TEntity&quot;&amp;gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; IRepository&amp;lt;TEntity&amp;gt; : IDisposable &lt;span&gt;where&lt;/span&gt; TEntity : &lt;span&gt;class&lt;/span&gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; Add(TEntity obj);
        TEntity GetById(Guid id);
        IQueryable&lt;/span&gt;&amp;lt;TEntity&amp;gt;&lt;span&gt; GetAll();
        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; Update(TEntity obj);
        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; Remove(Guid id);
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; SaveChanges();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Customer仓储接口，在基数仓储上扩展
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; ICustomerRepository : IRepository&amp;lt;Customer&amp;gt;&lt;span&gt;
    {
        Customer GetByEmail(&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt; email);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　Interfaces文件夹中还定义了IUser和IUnitOfWork接口类，也是需要Equinox.Infra.Data.Repository来实现。&lt;/p&gt;

&lt;h3&gt;八. 基础设施层分析&lt;/h3&gt;
&lt;p&gt; 　　Equinox.Infra.Data项目是EF用来持久化命令和事件，以及查询数据的仓储，结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201905/151560-20190506173203574-1146514893.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　其中UoW文件夹下的UnitOfWork类用来实现领域层的IUnitOfWork，使用Commit保存数据。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
      &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; Commit()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; _context.&lt;span&gt;SaveChanges&lt;/span&gt;() &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　Repository文件夹下的类用来实现领域层的IRepository接口，使用EF的DbSet来操作EF TEntity对象，再调用Commit提交到数据库。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
      &lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Add(TEntity obj)
        {
            DbSet.Add(obj);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　Repository文件夹下还包含EventSourcing事件源，存储到StoredEvent表中。&lt;/p&gt;

&lt;h3&gt;九.命令总线分析&lt;/h3&gt;
&lt;p&gt;　　Equinox.Infra.CrossCutting.Bus项目中使用了中间件MediatR，定义了InMemoryBus类来实现领域层的IMediatorHandler命令总线接口发送,使用SendCommand (T)和RaiseEvent (T)方法发送命令和事件。&lt;/p&gt;
&lt;p&gt;　　MediatR是用于消息发送和消息处理的解耦，MediatR是一种进程内消息传递机制。 支持以同步或异步的形式进行请求/响应，命令，查询，通知和事件的消息传递，并通过C#泛型支持消息的智能调度。 其中IRequest和INotification分别对应单播和多播消息的抽象。&lt;/p&gt;
&lt;p&gt;　　例如：在领域层中，Message消息实现IRequest，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Message消息 
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 放入通用属性,甚至是普通标记，没有属性。IRequest&lt;/span&gt;&lt;span&gt;&amp;lt;T&amp;gt;&lt;/span&gt;&lt;span&gt; - 有返回值
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Message : IRequest&amp;lt;&lt;span&gt;bool&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　最后&lt;span lang=&quot;EN-US&quot;&gt;Equinox.Infra.CrossCutting.Identity主要做用户管理，授权，迁移管理。&lt;span lang=&quot;EN-US&quot;&gt;Equinox.Infra.CrossCutting.IoC做整个解决方案下项目需要的服务注入。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;参考文献：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;　　&lt;a href=&quot;https://www.codeproject.com/Articles/555855/Introduction-to-CQRS&quot; target=&quot;_blank&quot;&gt;Introduction-to-CQRS&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　Microsoft.NET企业级应用架构设计 第二版&lt;/p&gt;

</description>
<pubDate>Tue, 07 May 2019 03:09:00 +0000</pubDate>
<dc:creator>花阴偷移</dc:creator>
<og:description>一.DDD分层架构介绍 本篇分析CQRS架构下的Equinox开源项目。该项目在github上star占有2.4k。便决定分析Equinox项目来学习下CQRS架构。再讲CQRS架构时，先简述下DDD</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/MrHSR/p/10820545.html</dc:identifier>
</item>
<item>
<title>dubbo系列--集群容错 - lawt</title>
<link>http://www.cnblogs.com/lawt/p/10824177.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lawt/p/10824177.html</guid>
<description>&lt;p&gt;作为一个程序员，咱们在开发的时候不仅仅是完成某个功能，更要考虑其异常情况程序如何设计，比如说：dubbo的消费端调用服务方异常的情况，要不要处理？如何处理？&lt;/p&gt;
&lt;p&gt;dubbo提供了多种集群容错机制，默认是failover，也就是失败后重试。可以自行扩展集群容错策略，参见：dubbo官网&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1563965/201905/1563965-20190507105639415-1906658316.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;图中各节点关系：&lt;/p&gt;
&lt;p&gt;这里的 Invoker 是 Provider 的一个可调用 Service 的抽象，Invoker 封装了 Provider 地址及 Service 接口信息&lt;/p&gt;
&lt;p&gt;Directory 代表多个 Invoker，可以把它看成 List&amp;lt;Invoker&amp;gt; ，但与 List 不同的是，它的值可能是动态变化的，比如注册中心推送变更&lt;/p&gt;
&lt;p&gt;Cluster 将 Directory 中的多个 Invoker 伪装成一个 Invoker，对上层透明，伪装过程包含了容错逻辑，调用失败后，重试另一个&lt;/p&gt;
&lt;p&gt;Router 负责从多个 Invoker 中按路由规则选出子集，比如读写分离，应用隔离等&lt;/p&gt;
&lt;p&gt;LoadBalance 负责从多个 Invoker 中选出具体的一个用于本次调用，选的过程包含了负载均衡算法，调用失败后，需要重选&lt;/p&gt;
&lt;p&gt;先来了解一下dubbo提供的六种集群容错机制。&lt;/p&gt;
&lt;p&gt;failover ：失败自动切换，当出现失败，重试其他服务器，通常用于查询操作，但重试会带来更长的延迟，可以通过以下配置&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1563965/201905/1563965-20190507105702696-780308129.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;来设置重试次数，不包含第一次 ，调用次数=1+重试次数，通常用与读操作或者具有幂等的写操作&lt;/p&gt;
&lt;p&gt;failfast ：快速失败，只发起一次调用，失败就报错，通常用于新增记录的操作，通常用于非幂等性的写操作&lt;/p&gt;
&lt;p&gt;failsafe ：失败安全，出现异常直接忽略，也就是对数据的完整性要求不高，通常用于写入审计日志等操作 &lt;/p&gt;
&lt;p&gt;failback ：失败自动恢复，失败后后台记录失败的请求，定时重发，通常用于实时性要求不高的通知类操作 ，通常用于消息通知操作&lt;/p&gt;
&lt;p&gt;forking ：并行调用，同时调用多个服务器，只要有一个返回成功即可，通常用于实时性要求高的查询操作，但是对资源的浪费更大，具体并行几个可以根据forks=n设置 &lt;/p&gt;
&lt;p&gt;broadcast ：广播调用所有提供者，逐个调用，有一台报错就报错，通常用于更新所有提供者缓存或者日志等本地资源信息，用的机会较少，并且更新失败的话对系统影响很小的资源&lt;/p&gt;
&lt;p&gt;集群模式配置&lt;br/&gt;按照以下示例在服务提供方和消费方配置集群模式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dubbo:service &lt;/span&gt;&lt;span&gt;cluster&lt;/span&gt;&lt;span&gt;=&quot;failsafe&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dubbo:reference &lt;/span&gt;&lt;span&gt;cluster&lt;/span&gt;&lt;span&gt;=&quot;failsafe&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于默认是failover，所以我们在这里分析一下dubbo源码中是怎么设计的。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1563965/201905/1563965-20190507105820258-685153239.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1563965/201905/1563965-20190507105832959-1685000282.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从 url 参数里面获取设置的重试次数，如果用户没有设置则取默认的值，默认是重试2，这里需要注意的是获取配置重试次数又+1了。这说明总共调用次数=重试次数+1（1是正常调用）。&lt;/p&gt;
&lt;p&gt;循环重试调用，如果第一次调用成功则直接跳出循环返回，否则循环重试。如果第一次调用出现异常，则会循环，这时候i=1，所以会检查是否有线程调用了当前 ReferenceConfig 的 destroy() 方法，销毁了当前消费者。如果当前消费者实例已经被消费，那么重试就没意义了，所以会抛出 RpcException 异常。&lt;/p&gt;
&lt;p&gt;如果当前消费者实例没被销毁，则重新获取当前服务提供者列表，这是因为从第一次调开始到线程可能提供者列表已经变化了，获取列表后，然后又一次进行了校验。校验通过则选择负责均衡策略，根据负载均衡策略选择一个服务提供者，再次尝试调用。&lt;br/&gt; &lt;/p&gt;
</description>
<pubDate>Tue, 07 May 2019 02:59:00 +0000</pubDate>
<dc:creator>lawt</dc:creator>
<og:description>dubbo系列--集群容错</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lawt/p/10824177.html</dc:identifier>
</item>
</channel>
</rss>