<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>用户级线程和内核级线程，你分得清吗？ - tobe的呓语</title>
<link>http://www.cnblogs.com/tobe98/p/11664779.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tobe98/p/11664779.html</guid>
<description>&lt;p&gt;&lt;em&gt;这篇文章是上一篇博客的补充，旨在把没有讲清楚的「用户级线程和内核级线程」补充完整。希望读者能对线程有更进一步的了解。&lt;/em&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;小白最近在学习多线程编程。&lt;/p&gt;
&lt;p&gt;网上关于多线程的资料很多，小白很快就把线程的基本概念弄懂了，但关于「用户级线程和内核级线程」的概念，她却怎么也搞不清楚，只好向操作系统基础扎实的小明请教。&lt;/p&gt;
&lt;p&gt;对于小白的问题，小明总会耐心解答：“线程里面这两个概念确实比较难理解，我先给你讲用户级线程吧。”&lt;/p&gt;
&lt;h3 id=&quot;用户级线程&quot;&gt;用户级线程&lt;/h3&gt;
&lt;p&gt;“既然你说你已经看过线程的基本概念，那我就直接跳过这一部分了。&lt;/p&gt;
&lt;p&gt;很久很久之前，线程的概念是出现了，但操作系统厂商可不能直接就去修改操作系统的内核，因为对他们来说，&lt;strong&gt;稳定性&lt;/strong&gt;是最重要的。贸然把未经验证的东西加入内核，出问题了怎么办？所以想要验证线程的可用性，得另想办法。”&lt;/p&gt;
&lt;p&gt;“我知道我知道，那些研究人员就编写了一个关于线程的函数库，&lt;strong&gt;用函数库来实现线程&lt;/strong&gt;！”小白得意的说：“这个我刚刚在网上看到了。”&lt;/p&gt;
&lt;p&gt;“是的，他们把&lt;strong&gt;创建线程&lt;/strong&gt;、&lt;strong&gt;终止线程&lt;/strong&gt;等功能放在了这个&lt;strong&gt;线程库&lt;/strong&gt;内，用户就可以通过调用这些函数来实现所需要的功能。”小明找了张纸，写上了几个函数：&lt;code&gt;pthread_creat&lt;/code&gt; ，&lt;code&gt;pthread_exit&lt;/code&gt; ，&lt;code&gt;pthread_join&lt;/code&gt; ，&lt;code&gt;pthread_yield&lt;/code&gt; ，接着说：“这是几个重要的函数，你应该能大概猜出这些函数的功能吧？”&lt;/p&gt;
&lt;p&gt;“emmmm，让我想想，&lt;code&gt;pthread_creat&lt;/code&gt; 是创建一个新线程，&lt;code&gt;pthread_exit&lt;/code&gt; 是结束线程，&lt;code&gt;pthread_join&lt;/code&gt; 嘛，我猜是准备运行某一个线程，然后把它加进&lt;strong&gt;就绪队列&lt;/strong&gt;。最后一个函数我就不知道了。”&lt;/p&gt;
&lt;p&gt;“不知道也没关系，一会你就清楚了。”小明接着讲：“要知道，刚刚我们说的线程库，是位于用户空间的，&lt;strong&gt;操作系统内核对这个库一无所知&lt;/strong&gt;，所以从内核的角度看，它还是按正常的方式管理。”&lt;/p&gt;
&lt;p&gt;小白问道：“也就是说&lt;strong&gt;操作系统眼里还是只有进程&lt;/strong&gt;喽？那我用线程库写的一个多线程进程，只能一次在&lt;strong&gt;一个 CPU 核心&lt;/strong&gt;上运行？”&lt;/p&gt;
&lt;p&gt;小明点点头，说：“你说的没错，这其实是用户级线程的一个缺点，这些线程只能占用一个核，所以做不到&lt;strong&gt;并行加速&lt;/strong&gt;，而且由于用户线程的&lt;strong&gt;透明性&lt;/strong&gt;，&lt;strong&gt;操作系统是不能主动切换线程的&lt;/strong&gt;，换句话讲，如果 A，B 是同一个进程的两个线程的话， A 正在运行的时候，线程 B 想要运行的话，只能等待 A &lt;strong&gt;主动放弃&lt;/strong&gt; CPU，也就是主动调用 &lt;code&gt;pthread_yield&lt;/code&gt; 函数。”&lt;/p&gt;
&lt;p&gt;&lt;em&gt;tobe 注：对操作系统来说，用户级线程具有&lt;strong&gt;不可见性&lt;/strong&gt;，也称&lt;strong&gt;透明性&lt;/strong&gt;。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;“停一下，让我想一想，”小白飞速思考着小明的话，“是不是说，即使有线程库，用户级线程也做不到像进程那样的&lt;strong&gt;轮转调度&lt;/strong&gt;？”&lt;/p&gt;
&lt;p&gt;“非常正确！看来你对进程的概念很清楚嘛。不过呢，虽然不能做到轮转调度，但用户级线程也有他自己的好处——你可以&lt;strong&gt;为你的应用程序定制调度算法&lt;/strong&gt;，毕竟什么时候退出线程你自己说了算。刚刚说了，因为操作系统只能看到进程的存在，那如果&lt;strong&gt;某一个线程阻塞&lt;/strong&gt;了，你觉得会发生什么？”&lt;/p&gt;
&lt;p&gt;“在操作系统眼里，是进程阻塞了，那么整个进程就会进入&lt;strong&gt;阻塞态&lt;/strong&gt;，在阻塞操作结束前，这个进程都无法得到 CPU 资源。那就相当于，&lt;strong&gt;所有的线程都被阻塞&lt;/strong&gt;了。”小白得意的回答。&lt;/p&gt;
&lt;p&gt;“没错，所以如果任由线程进行阻塞操作，进程的效率将受到很大的影响，所以在这个过程中，出现了一个替代方案——&lt;strong&gt;jacket&lt;/strong&gt;。所谓 jacket，就是把一个产生阻塞的系统调用转化成一个非阻塞的系统调用。”&lt;/p&gt;
&lt;p&gt;小白惊讶地问：“这怎么做得到？该阻塞的调用，还能变得不阻塞？”&lt;/p&gt;
&lt;p&gt;小明答道：“我来举个例子吧，不是直接调用一个系统 I/O 例程，而是调用一个应用级别的 I/O jacket 例程，这个 jacket 例程中的代码会检查并且确定 I/O 设备是不是正忙，如果忙的话，就在&lt;strong&gt;用户态&lt;/strong&gt;下将该线程阻塞，然后把控制权交给另一个线程。隔一段时间后再次检查 I/O 设备。就像你说的，最后还是会执行阻塞调用，但使用 jacket 可以缩短被阻塞的时间。不过有些情况下是可以不被阻塞的，取决于具体的实现。”&lt;/p&gt;
&lt;p&gt;小明停顿了一会，说：“用户级线程的概念大概就这么多，我们接下来讲内核级线程吧。”&lt;/p&gt;
&lt;h3 id=&quot;内核级线程&quot;&gt;内核级线程&lt;/h3&gt;
&lt;p&gt;“有了用户级线程的铺垫，内核级线程就好讲多了。现在我们知道，许多操作系统都已经支持内核级线程了。为了实现线程，内核里就需要有用来记录系统里所有线程的线程表。当需要创建一个新线程的时候，就需要进行一个&lt;strong&gt;系统调用&lt;/strong&gt;，然后由&lt;strong&gt;操作系统&lt;/strong&gt;进行线程表的更新。当然了，传统的进程表也还是有的。你想想看，如果操作系统「看得见」线程，有什么好处？“&lt;/p&gt;
&lt;p&gt;小白自信的回答：“操作系统内核如果知道线程的存在，就可以像调度多个进程一样，把这些线程放在好几个 CPU 核心上，就能做到实际上的&lt;strong&gt;并行&lt;/strong&gt;了。”&lt;/p&gt;
&lt;p&gt;“还有一点你没有说到，如果线程可见，那么&lt;strong&gt;假如线程 A 阻塞了，与他同属一个进程的线程也不会被阻塞&lt;/strong&gt;。这是内核级线程的绝对优势。”&lt;/p&gt;
&lt;p&gt;“那内核级线程就没有什么缺点吗？”&lt;/p&gt;
&lt;p&gt;“缺点当然是有的，你想想看，让操作系统进行线程调度，那意味着每次切换线程，就需要「&lt;strong&gt;陷入&lt;/strong&gt;」内核态，而操作系统从&lt;strong&gt;用户态到内核态&lt;/strong&gt;的转变是有开销的，所以说&lt;strong&gt;内核级线程切换的代价要比用户级线程大&lt;/strong&gt;。还有很重要的一点——线程表是存放在操作系统固定的&lt;strong&gt;表格空间&lt;/strong&gt;或者&lt;strong&gt;堆栈空间&lt;/strong&gt;里，所以内核级线程的数量是有限的，扩展性比不上用户级线程。”&lt;/p&gt;
&lt;p&gt;&quot;内核级线程就这么点东西，我最后给你留一张图，你要是能看得懂，就说明你理解今天的概念了。&quot;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1780031/201910/1780031-20191013084019048-559447731.jpg&quot; alt=&quot;两个线程模型&quot;/&gt;&lt;/p&gt;
&lt;p&gt;小白得意地说：“我当然看得懂了，谢谢小明！”&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;希望你在看完我的文章之后有所收获。&lt;/p&gt;
&lt;p&gt;感谢你的阅读，我们后会有期！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;声明：原创文章，未经授权，禁止转载&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 13 Oct 2019 00:40:00 +0000</pubDate>
<dc:creator>tobe的呓语</dc:creator>
<og:description>这篇文章是上一篇博客的补充，旨在把没有讲清楚的「用户级线程和内核级线程」补充完整。希望读者能对线程有更进一步的了解。 小白最近在学习多线程编程。 网上关于多线程的资料很多，小白很快就把线程的基本概念弄</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tobe98/p/11664779.html</dc:identifier>
</item>
<item>
<title>[ASP.NET Core 3框架揭秘] 跨平台开发体验: Linux - Artech</title>
<link>http://www.cnblogs.com/artech/p/inside-asp-net-core-01-05.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/artech/p/inside-asp-net-core-01-05.html</guid>
<description>&lt;p&gt;如果想体验Linux环境下开发.NET Core应用，我们有多种选择。一种就是在一台物理机上安装原生的Linux，我们可以根据自身的喜好选择某种Linux Distribution，目前来说像RHEL、Ubuntu、Debian、Fedora、CentOS和SUSE这些主流的Distribution都是支持的。如果读者朋友们觉得这种方式比较麻烦，我们也可以采用虚拟机的形式安装相应的Linux Distribution，比如我经常使用的都是安装在VirtualBox上的Ubuntu。对于X64 Windows 10的用户来说，我们有了第三种更为方便快捷的选择，那就是使用Windows 10提供的Linux子系统（WSL：Windows Subsystem for Linux），目前最新版本为WSL 2。&lt;/p&gt;

&lt;p&gt;WSL 2要求操作系统必须是“Windows 10 build 18917 ”或者更高的版本。在Windows 10上启用WSL 2只需要将“&lt;strong&gt;Virtual Machine Platform&lt;/strong&gt;” 和“&lt;strong&gt;Windows Subsystem for Linux&lt;/strong&gt;”这两个特性开启就可以了。我们可以采用两种方式来启用这两个特性，第一种在PowerShell中以如下的方式执行Enable-WindowsOptionalFeature命令（该命令需要以&lt;strong&gt;管理员&lt;/strong&gt;身份执行）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Enable-WindowsOptionalFeature -Online -FeatureName VirtualMachinePlatform
Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们也可以采用可视化的方式来开启这两个特性。具体来说，我们可以通过“控制面板（Control Panel）”&amp;gt;“程序与功能（Programs and Features）”打开如下图所示的“程序与功能”对话框，并选择“Turn Windows features on or off）”打开“Windows Features”对话框。在勾选了“Virtual Machine Platform”和“Windows Subsytem for Linux”选项并确定并重启机器之后，针对Linux的Windows子系统就被启用了。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/201910/19327-20191013081654124-908802529.png&quot;&gt;&lt;img width=&quot;453&quot; height=&quot;344&quot; title=&quot;1-17&quot; alt=&quot;1-17&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/201910/19327-20191013081654461-1774987907.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在启用WSL之后，我们可以根据需要安装对应的Linux Distribution。最方便的方式就是直接在Microsoft Store中下载并安装对应的Linux Distribution，比如Microsoft Store为我们提供了如下图所示的免费版Ubuntu 18.04 LTS。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/201910/19327-20191013081655233-1806695439.png&quot;&gt;&lt;img width=&quot;445&quot; height=&quot;354&quot; title=&quot;1-18&quot; alt=&quot;1-18&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/201910/19327-20191013081656158-1179853662.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果Microsoft Store不可用（比如我的操作系统就是没有Microsoft Store的Windows 10 Enterprise LTSC版本），我们可以直接利用curl.exe or the Invoke-WebRequest以命令行的方式下载Linux安装包。下面列出了几种常用的Linux Distribution的下载地址。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Ubuntu 18.04: https://aka.ms/wsl-ubuntu-1804&lt;/li&gt;
&lt;li&gt;Ubuntu 18.04 ARM: https://aka.ms/wsl-ubuntu-1804-arm&lt;/li&gt;
&lt;li&gt;Ubuntu 16.04: https://aka.ms/wsl-ubuntu-1604&lt;/li&gt;
&lt;li&gt;Debian GNU/Linux: https://aka.ms/wsl-debian-gnulinux&lt;/li&gt;
&lt;li&gt;Kali Linux: https://aka.ms/wsl-kali-linux&lt;/li&gt;
&lt;li&gt;OpenSUSE: https://aka.ms/wsl-opensuse-42&lt;/li&gt;
&lt;li&gt;SLES: https://aka.ms/wsl-sles-12&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当Linux被成功安装之后，我们可以在CMD命令行中执行&lt;strong&gt;bash&lt;/strong&gt;命令进入Linux Bash Shell。如下图所示，我们在CMD命令行中执行bash命令之后会自动进入Linux Bash Shell。我们在Bash Shell中执行“&lt;strong&gt;lsb_release -a&lt;/strong&gt;”命令输出当前安装的Linux Distribution的版本信息。如果想恢复到CMD命令行模式，我们只需要执行exit命令退出Bash Shell即可。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/201910/19327-20191013081656435-874209395.png&quot;&gt;&lt;img width=&quot;461&quot; height=&quot;252&quot; title=&quot;1-19&quot; alt=&quot;1-19&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/201910/19327-20191013081656698-46494885.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作为主系统的Windows和Linux子系统可以共享网络系统和文件系统。Windows下的文件系统直接挂载到“&lt;strong&gt;/mnt&lt;/strong&gt;”目录下，所以Windows下的文件或者目录路径加上“/mnt”前缀就变成了基于Linux子系统下的路径。如上图所示，CMD命令行环境下的当前工作目录为“c:\Users\jinnan”，当我们切换到Bash Shell后，当前工作目录其实并没有发生变化，只是路径变成了“/&lt;strong&gt;mnt/c/Users/jinnan&lt;/strong&gt;”而已。&lt;/p&gt;

&lt;p&gt;如果我们想在Linux下运行.NET Core应用，我们也只需要安装.NET Core SDK就可以了。针对不同的Linux Distribution，.NET Core SDK的安装略有不同。对于主流的Linux发行版本（RHEL、Ubuntu、Debian、Fedora、CentOS和SUSE等）， .NET Core官方站点上给出了安装.NET Core SDK的详细教程。对于我们安装的Ubuntu 18.04 LTS，.NET Core 3.0 SDK可以执行如下的命令进行安装。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;~$ sudo apt-get update
~$ sudo apt-get install apt-transport-https
~$ sudo apt-get install dotnet-sdk-&lt;/span&gt;3.0
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;安装完成之后，我们可以执行dotnet --info命令查看当前.NET Core SDK的基本信息，如果得到如下图所示的输出结果，那就证明.NET Core SDK 3.0被成功安装。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/201910/19327-20191013081657098-25149535.png&quot;&gt;&lt;img width=&quot;446&quot; height=&quot;305&quot; title=&quot;1-20&quot; alt=&quot;1-20&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/201910/19327-20191013081657513-1986108480.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;.NET Core SDK同样为Linux提供了dotnet这个重要的命令行工具，这意味着我们同样可以利用它提供的脚手架模板创建相应的.NET Core应用。这次我们直接创建一个空的ASP.NET Core 应用，为此我们在执行&lt;strong&gt;dotnet new&lt;/strong&gt;命令的时候将模板名称指定为“web”。如下图所示，我们在执行dotnet new命令时的当前工作目录为“/mnt/c/helloworld”，也就是主系统Windows下的“c:\helloworld”，我们列出了该目录下的所有文件和子目录。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/201910/19327-20191013081657811-1941024937.png&quot;&gt;&lt;img width=&quot;471&quot; height=&quot;306&quot; title=&quot;1-21&quot; alt=&quot;1-21&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/201910/19327-20191013081658121-654461179.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;和在Windows和Mac OS X下利用脚手架命令创建的应用一样，我们在Linux下同样可以在无需对它们作任何更改的情况下直接运行它们，为此我们只需要在当前应用所在的目录下执行&lt;strong&gt;dotnet run&lt;/strong&gt;命令即可。如下图所示，启动后的ASP .NET Core应用默认会绑定在5000（HTTP）和5001（HTTPS）端口进行请求监听，由于Linux是当前Windows的子系统而非虚拟机，所以主子系统可以共享网络，因此我们利用浏览器请求地址“http://localhost:5000”可以访问这个应用的主页。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/201910/19327-20191013081658475-498740560.png&quot;&gt;&lt;img width=&quot;458&quot; height=&quot;296&quot; title=&quot;1-22&quot; alt=&quot;1-22&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/201910/19327-20191013081658847-1435886643.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-01-01.html&quot;&gt;[ASP.NET Core 3框架揭秘] 跨平台开发体验: Windows [上篇]&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-01-02.html&quot;&gt;[ASP.NET Core 3框架揭秘] 跨平台开发体验: Windows [中篇]&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-01-03.html&quot;&gt;[ASP.NET Core 3框架揭秘] 跨平台开发体验: Windows [下篇]&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-01-04.html&quot;&gt;[ASP.NET Core 3框架揭秘] 跨平台开发体验: Mac OS&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-01-05.html&quot;&gt;[ASP.NET Core 3框架揭秘] 跨平台开发体验: Linux&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-061.html&quot;&gt;[ASP.NET Core 3框架揭秘] 跨平台开发体验: Docker&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 13 Oct 2019 00:17:00 +0000</pubDate>
<dc:creator>Artech</dc:creator>
<og:description>如果想体验Linux环境下开发.NET Core应用，我们有多种选择。一种就是在一台物理机上安装原生的Linux，我们可以根据自身的喜好选择某种Linux Distribution，目前来说像RHEL</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/artech/p/inside-asp-net-core-01-05.html</dc:identifier>
</item>
<item>
<title>一文教你安全的关闭线程池 - good_andyxu</title>
<link>http://www.cnblogs.com/goodAndyxublog/p/11664742.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/goodAndyxublog/p/11664742.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1419561/201910/1419561-20191013074227785-2110660954.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上篇文章 &lt;a href=&quot;https://studyidea.cn/articles/2019/09/03/1567504427330.html&quot;&gt;ShutdownHook- Java 优雅停机解决方案&lt;/a&gt; 提到应用停机时需要释放资源，关闭连接。对于一些定时任务或者网络请求服务将会使用线程池，当应用停机时需要正确安全的关闭线程池，如果处理不当，可能造成数据丢失，业务请求结果不正确等问题。&lt;/p&gt;
&lt;p&gt;关闭线程池我们可以选择什么都不做，JVM 关闭时自然的会清除线程池对象。当然这么做，存在很大的弊端，线程池中正在执行执行的线程以及队列中还未执行任务将会变得极不可控。所以我们需要想办法控制到这些未执行的任务以及正在执行的线程。&lt;/p&gt;
&lt;p&gt;线程池 API 提供两个主动关闭的方法 &lt;code&gt;ThreadPoolExecutor#shutdownNow&lt;/code&gt; 与 &lt;code&gt;ThreadPoolExecutor#shutdown&lt;/code&gt;，这两个方法都可以用于关闭线程池，但是具体效果却不太一样。&lt;/p&gt;
&lt;h2 id=&quot;线程池的状态&quot;&gt;线程池的状态&lt;/h2&gt;
&lt;p&gt;在说线程池关闭方法之前，我们先了解线程池状态。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;线程池状态关系图如下：&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1419561/201910/1419561-20191013074229123-952392180.png&quot; alt=&quot;线程池状态.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上图我们看到线程池总共存在 5 种状态，分别为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;RUNNING&lt;/strong&gt;：线程池创建之后的初始状态，这种状态下可以执行任务。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SHUTDOWN&lt;/strong&gt;:该状态下线程池不再接受新任务，但是会将工作队列中的任务执行结束。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;STOP&lt;/strong&gt;: 该状态下线程池不再接受新任务，但是不会处理工作队列中的任务，并且将会中断线程。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TIDYING&lt;/strong&gt;：该状态下所有任务都已终止，将会执行 &lt;code&gt;terminated()&lt;/code&gt; 钩子方法。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TERMINATED&lt;/strong&gt;：执行完 &lt;code&gt;terminated()&lt;/code&gt; 钩子方法之后。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当我们执行 &lt;code&gt;ThreadPoolExecutor#shutdown&lt;/code&gt; 方法将会使线程池状态从 &lt;strong&gt;RUNNING&lt;/strong&gt; 转变为 &lt;strong&gt;SHUTDOWN&lt;/strong&gt;。而调用 &lt;code&gt;ThreadPoolExecutor#shutdownNow&lt;/code&gt; 之后线程池状态将会从 &lt;strong&gt;RUNNING&lt;/strong&gt; 转变为 &lt;strong&gt;STOP&lt;/strong&gt;。从上面的图上还可以看到，当线程池处于 &lt;strong&gt;SHUTDOWN&lt;/strong&gt;，我们还是可以继续调用 &lt;code&gt;ThreadPoolExecutor#shutdownNow&lt;/code&gt; 方法，将其状态转变为 &lt;strong&gt;STOP&lt;/strong&gt; 。&lt;/p&gt;
&lt;h2 id=&quot;threadpoolexecutorshutdown&quot;&gt;ThreadPoolExecutor#shutdown&lt;/h2&gt;
&lt;p&gt;上面我们知道线程池状态，这里先说说 &lt;code&gt;shutdown&lt;/code&gt; 方法。&lt;code&gt;shutdown&lt;/code&gt; 方法源码比较简单，能比较直观理解其调用逻辑。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;code&gt;shutdown&lt;/code&gt; 方法源码：&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    public void shutdown() {
        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
       // 检查权限
            checkShutdownAccess();
            // 设置线程池状态
        advanceRunState(SHUTDOWN);
       // 中断空闲线程
            interruptIdleWorkers();
            // 钩子函数，主要用于清理一些资源
            onShutdown(); 
        } finally {
            mainLock.unlock();
        }
        tryTerminate();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;shutdown&lt;/code&gt; 方法首先加锁，其次先检查系统安装状态。接着就会将线程池状态变为 &lt;strong&gt;SHUTDOWN&lt;/strong&gt;，在这之后线程池不再接受提交的新任务。此时如果还继续往线程池提交任务，将会使用线程池拒绝策略响应，默认情况下将会使用 &lt;code&gt;ThreadPoolExecutor.AbortPolicy&lt;/code&gt;，抛出 &lt;code&gt;RejectedExecutionException&lt;/code&gt; 异常。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;interruptIdleWorkers&lt;/code&gt; 方法只会中断空闲的线程，不会中断正在执行任务的的线程。空闲的线程将会阻塞在线程池的阻塞队列上。&lt;/p&gt;
&lt;p&gt;线程池构造参数需要指定 &lt;strong&gt;coreSize&lt;/strong&gt;（核心线程池数量），&lt;strong&gt;maximumPoolSize&lt;/strong&gt;（最大的线程池数量），&lt;strong&gt;keepAliveTime&lt;/strong&gt;（多余空闲线程等待时间），&lt;strong&gt;unit&lt;/strong&gt;（时间单位），&lt;strong&gt;workQueue&lt;/strong&gt;（阻塞队列）。&lt;/p&gt;
&lt;p&gt;当调用线程池的 &lt;code&gt;execute&lt;/code&gt; 方法，线程池工作流程如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如果此时线程池中线程数量小于 &lt;strong&gt;coreSize&lt;/strong&gt;，将会新建线程执行提交的任务。&lt;/li&gt;
&lt;li&gt;如果此时线程池线程数量已经大于 &lt;strong&gt;coreSize&lt;/strong&gt;，将会直接把任务加入到队列中。线程将会从工作队列中获取任务执行。&lt;/li&gt;
&lt;li&gt;如果工作队列已满，将会继续新建线程。&lt;/li&gt;
&lt;li&gt;如果工作队列已满，且线程数等于 &lt;strong&gt;maximumPoolSize&lt;/strong&gt;，此时将会使用拒绝策略拒绝任务。&lt;/li&gt;
&lt;li&gt;超过 &lt;strong&gt;coreSize&lt;/strong&gt; 数量那部分线程，如果空闲了 &lt;strong&gt;keepAliveTime&lt;/strong&gt; ，线程将会终止。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;em&gt;工作流程图如下：&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1419561/201910/1419561-20191013074230121-304502678.png&quot; alt=&quot;线程池执行流程图.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当线程池处于第二步时，线程将会使用 &lt;code&gt;workQueue#take&lt;/code&gt; 获取队头的任务，然后完成任务。如果工作队列一直没任务，由于队列为阻塞队列，&lt;code&gt;workQueue#take&lt;/code&gt; 将会阻塞线程。&lt;/p&gt;
&lt;h2 id=&quot;threadpoolexecutorshutdownnow&quot;&gt;ThreadPoolExecutor#shutdownNow&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;&lt;code&gt;ThreadPoolExecutor#shutdownNow&lt;/code&gt; 源码如下：&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    public List&amp;lt;Runnable&amp;gt; shutdownNow() {
        List&amp;lt;Runnable&amp;gt; tasks;
        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
        // 检查状态
            checkShutdownAccess();
        // 将线程池状态变为 STOP
            advanceRunState(STOP);
            // 中断所有线程，包括工作线程以及空闲线程
        interruptWorkers();
        // 丢弃工作队列中存量任务
            tasks = drainQueue();
        } finally {
            mainLock.unlock();
        }
        tryTerminate();
        return tasks;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;shutdownNow&lt;/code&gt; 方法将会把线程池状态设置为 &lt;strong&gt;STOP&lt;/strong&gt;，然后中断所有线程，最后取出工作队列中所有未完成的任务返回给调用者。&lt;/p&gt;
&lt;p&gt;对比 &lt;code&gt;shutdown&lt;/code&gt; 方法，&lt;code&gt;shutdownNow&lt;/code&gt; 方法比较粗暴，直接中断工作线程。不过这里需要注意，中断线程并不代表线程立刻结束。这里需要线程主动配合线程中断响应。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;线程中断机制：&lt;br/&gt;&lt;code&gt;thread#interrupt&lt;/code&gt; 只是设置一个中断标志，不会立即中断正常的线程。如果想让中断立即生效，必须在线程 内调用 &lt;code&gt;Thread.interrupted()&lt;/code&gt; 判断线程的中断状态。&lt;br/&gt;对于阻塞的线程，调用中断时，线程将会立刻退出阻塞状态并抛出 &lt;code&gt;InterruptedException&lt;/code&gt; 异常。所以对于阻塞线程需要正确处理 &lt;code&gt;InterruptedException&lt;/code&gt; 异常。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;awaittermination&quot;&gt;awaitTermination&lt;/h2&gt;
&lt;p&gt;线程池 &lt;code&gt;shutdown&lt;/code&gt; 与 &lt;code&gt;shutdownNow&lt;/code&gt; 方法都不会主动等待执行任务的结束，如果需要等到线程池任务执行结束，需要调用 &lt;code&gt;awaitTermination&lt;/code&gt; 主动等待任务调用结束。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;调用方法如下：&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;        threadPool.shutdown();
        try {
            while (!threadPool.awaitTermination(60,TimeUnit.SECONDS)){
                System.out.println(&quot;线程池任务还未执行结束&quot;);
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果线程池任务执行结束，&lt;code&gt;awaitTermination&lt;/code&gt; 方法将会返回 &lt;code&gt;true&lt;/code&gt;，否则当等待时间超过指定时间后将会返回 &lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果需要使用这种进制，建议在上面的基础上增加一定&lt;strong&gt;重试次数&lt;/strong&gt;。这个真的很重要！！！&lt;/p&gt;
&lt;h2 id=&quot;优雅关闭线程池&quot;&gt;优雅关闭线程池&lt;/h2&gt;
&lt;p&gt;回顾上面线程池状态关系图，我们可以知道处于 &lt;strong&gt;SHUTDOWN&lt;/strong&gt; 的状态下的线程池依旧可以调用 &lt;code&gt;shutdownNow&lt;/code&gt;。所以我们可以结合 &lt;code&gt;shutdown&lt;/code&gt; ， &lt;code&gt;shutdownNow&lt;/code&gt;，&lt;code&gt;awaitTermination&lt;/code&gt; ，更加优雅关闭线程池。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;        threadPool.shutdown(); // Disable new tasks from being submitted
        // 设定最大重试次数
        try {
            // 等待 60 s
            if (!threadPool.awaitTermination(60, TimeUnit.SECONDS)) {
                // 调用 shutdownNow 取消正在执行的任务
                threadPool.shutdownNow();
                // 再次等待 60 s，如果还未结束，可以再次尝试，或则直接放弃
                if (!threadPool.awaitTermination(60, TimeUnit.SECONDS))
                    System.err.println(&quot;线程池任务未正常执行结束&quot;);
            }
        } catch (InterruptedException ie) {
            // 重新调用 shutdownNow
            threadPool.shutdownNow();
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;文章首发于 &lt;a href=&quot;https://studyidea.cn/articles/2019/09/08/1567940077280.html&quot;&gt;studyidea.cn/close..&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5.5384615384615&quot;&gt;
&lt;p&gt;欢迎关注我的公众号：程序通事，获得日常干货推送。如果您对我的专题内容感兴趣，也可以关注我的博客：&lt;a href=&quot;https://studyidea.cn&quot;&gt;studyidea.cn&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1419561/201910/1419561-20191013074232045-1488674648.png&quot; alt=&quot;其他平台.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 12 Oct 2019 23:43:00 +0000</pubDate>
<dc:creator>good_andyxu</dc:creator>
<og:description>上篇文章 'ShutdownHook Java 优雅停机解决方案' 提到应用停机时需要释放资源，关闭连接。对于一些定时任务或者网络请求服务将会使用线程池，当应用停机时需要正确安全的关闭线程池，如果处理</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/goodAndyxublog/p/11664742.html</dc:identifier>
</item>
<item>
<title>谁的大学不迷茫——寻求解救之道 - 泰斗贤若如</title>
<link>http://www.cnblogs.com/zyx110/p/11664377.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zyx110/p/11664377.html</guid>
<description>&lt;h3&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;大学前的准备&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;2017年，令我难忘的一年，当时的我正在补习班为第二次高考备战着。我们补习班的墙上粘着一道横幅格外显眼——“加油，我们一起上大学”。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1640688/201910/1640688-20191012225201312-1293006280.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;应届班的高三同学们听着张杰的“年轻的战场”给自己打气，而身处补习班的我哼着杰哥的“逆战”，为高考逆战，暴风少年肩负着来自学校内外部、家庭内外部以及内心深处等方面的层层压力，用破釜沉舟的勇气和“真的不想再复读”的信念迎战高考。苍天不负我，“塞翁失马，焉知非福”的经典在我身上本色出演——逆境中苦苦挣扎的我终于C位出道了。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;高考前，大学如“水中月，镜中花”，一切不过是心中的幻象。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p md-focus&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;高考后，大学如“雾里看花”，虚虚实实，真真假假，你的想象力有多丰富，大学就有多美好，对自由和未来充满无限的憧憬和向往。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p md-focus&quot;&gt; &lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-p md-focus&quot;&gt;上大学了&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;真的上大学了，我不说经历，我用一张图片描述一下上大学的感想&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1640688/201910/1640688-20191012225537752-902836459.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面我来分享几张我觉得既真实又搞笑的图片，看看大学版的理想和现实(🤭)&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p md-focus&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1640688/201910/1640688-20191012225631312-322830771.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p md-focus&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;怎么样，是不是很真实，可不要问我图从哪来，哈哈，一笑而过。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;现在我也大三了，从大一到现在我经历了很多，大道理也总结了一整套。成长是有代价的，其中的辛酸只有自己知道。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;你聪明有人会说你心机重，你靠的是努力有人会说你运气好，你说自己天生乐观有人会说你虚假。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;有时候，你明明就是一杯白水，却被人硬生生逼成了满肚子憋屈的碳酸饮料。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;人一生要遇见太多人，即使有些话字字诛心，也没必要活在他们的眼神里，只要内心澄明，就永远不用讨好一个不懂你的人。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;幸运的是我一直在坚持做我自己，我有用自己的原则选择钟意的朋友，也有狠下决心做我喜欢的事，也曾为了弥补内心的一丝遗憾默默给学弟学妹付出，尽管很少有人理解我为何要这样做，但我始终在坚持，可能这就是我在大学存在的价值。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;此篇名为谁的大学不迷茫，其实谁都会迷茫，我觉得我的大学一直很迷茫，每个阶段都会有不同的迷茫，但重要的是，我没有在迷茫中迷失自己，我做了很多尝试，不断跳出自己的舒适区，寻找适合自己的方向，虽然到现在我依旧不知道我真的想要什么，但是通过不断尝试我至少知道自己不想要什么，即使在我的人生选项中做排除法，我也知道我的人生是我试错试出来的，我无怨无悔。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;你可以不够强大，但是不能没有梦想。有梦想的人，才能掌握自己人生的主动权！&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;你是否思考过，你的兴趣和优势是什么？你的目标和梦想时什么？你的未来的道路该怎么走？如果你没有梦想，找不到精神的归属，那么将来你就只能为别人的梦想打工。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;知乎上有一个热门话题：人在迷茫时该干什么？最高赞的回答很简单，也很精辟：做两件事，收和放。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;收，是停掉所有不是必须要做的事，把时间和精力收回来。迷茫不是无事可做，而是所做的事没有意义，没有意义就停掉。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;放，是放开视野，放下包袱，去尝试新事物，认识新的人。走出舒适区，让自己看到更多的可能。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p md-focus&quot;&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;我几个月之前写了关于自己的几篇博客，想从中找到自己的初心，认清自我：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;《&lt;a href=&quot;https://www.cnblogs.com/zyx110/p/11005868.html&quot; target=&quot;_blank&quot;&gt;塞翁失马焉知非福&lt;/a&gt;》&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;《&lt;a href=&quot;https://www.cnblogs.com/zyx110/p/11008888.html&quot; target=&quot;_blank&quot;&gt;大学再努力，培训机构做兄弟&lt;/a&gt;》&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;《&lt;a href=&quot;https://www.cnblogs.com/zyx110/p/11609493.html&quot; target=&quot;_blank&quot;&gt;大学已过半，敢问路在何方&lt;/a&gt;》&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;不同的阶段，不同的迷茫，不同的改变，这就是我，那么你呢？&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;你在迷茫时是用消极的生活混吃等死还是我命由我不由天，试图改变呢？&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;&lt;strong&gt;让自己走出迷茫期&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;如何走出迷茫期？在这里给大家了走出迷茫的三个关键问题，以及走出迷茫的十六字方针。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span&gt;&lt;strong&gt;第一问：我为什么读大学？问到最终目标为止，问到清晰为止！（问目标）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;做任何事情，我们首先要问为什么做？问问题特别关键。当自己没有动力时问问自己，为什么没有动力？注意力不集中时问问自己，为什么会这样？问自己为什么，然后去解答，问题的答案就在我们身上。这是给大家的一个平时内省的小方法。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;问问自己为什么要读大学，读大学的目的是什么？很多人跟我询问大学规划时，我都会问他们这个问题。一切以目标为导向，知道了目标才知道你要做什么，怎么做。目标是做一切事情的前提。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;当问这个问题时，&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;你可能会说：为了以后更好的发展。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;好的，那么什么才算是更好的发展呢？你可以描述一下吗？&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;这时你可能会说：月工资多少？可以支持每年出去旅行？去国企，或者去世界五百强。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;就像这样一直问到自己目标特别清晰为止。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;再比如你可能会说要考研，注意了，这是过程，考研读研都是一个短期的学习目标，不是最终的结果，甚至有可能考研都不是你想要的，而是其他人给你的一个目标。一定再接着问自己，为什么要考研，之后要做什么？也就是问到自己的最终目标为止。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;问清楚后再进行下一步：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span&gt;&lt;strong&gt;第二问：实现我的目标需要达到什么标准？（清晰目标）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;这就像你高三考大学时，你明确下来要考北大，那么你需要考多少分，“多少分”就是实现目标的标准。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;还有像学软件编程的，你是要去BAT还是小公司，如果去BAT，BAT的标准是什么，你能否达到它们的标准。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span&gt;&lt;strong&gt;第三问：我应该如何做？（如何实现目标）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;送给大家十六字方针：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span&gt;&lt;strong&gt;明确目标&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span&gt;&lt;strong&gt;立即行动&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span&gt;&lt;strong&gt;不找借口&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span&gt;&lt;strong&gt;创造成就&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;em&gt;明确目标：&lt;/em&gt;&lt;/strong&gt;&lt;span class=&quot;md-plain&quot;&gt;我们要明确长远目标，也要明确阶段性目标。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;em&gt;立即行动：&lt;/em&gt;&lt;/strong&gt;&lt;span class=&quot;md-plain&quot;&gt;行动中只想着目标，其他的都是障碍。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span&gt;&lt;strong&gt;不找借口：&lt;/strong&gt;&lt;span class=&quot;md-plain&quot;&gt;爱恩有一句话就是：成功和借口永远不在同一个屋檐下，所以想要成功就不要有借口。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span&gt;&lt;strong&gt;创造成就：&lt;/strong&gt;&lt;span class=&quot;md-plain&quot;&gt;完成阶段性的目标就是在创造成就的过程。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p md-focus&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;我当时也给学弟学妹写过一篇博客叫《&lt;a href=&quot;https://www.cnblogs.com/zyx110/p/10617265.html&quot; target=&quot;_blank&quot;&gt;在你迷茫时不如学好一门语言&lt;/a&gt;》&lt;span class=&quot;md-link&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;，总之迷茫是正常的，但千万不要因为迷茫而迷茫，耽误了自己，到头来竹篮打水一场空。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;正如《肖生克的救赎》中的一句话，解救之道就在其中&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;md-plain&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1640688/201910/1640688-20191012230128194-2145860094.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-image md-img-loaded md-expand&quot; data-src=&quot;assets/2.png&quot;&gt;&lt;img src=&quot;file://c/Users/Lenovo/Desktop/assets/2.png?lastModify=1570892603&quot; alt=&quot;&quot; data-local-refresh=&quot;true&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;尽人事听天命，坚持才是王道&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;md-plain&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1640688/201910/1640688-20191012230138387-1013019363.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-plain&quot;&gt;&lt;strong&gt;【尊重原创】&lt;/strong&gt;&lt;span class=&quot;md-plain&quot;&gt;：本文出自博客园&lt;span class=&quot;md-link md-expand&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/zyx110/&quot;&gt;https://www.cnblogs.com/zyx110/&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 12 Oct 2019 22:12:00 +0000</pubDate>
<dc:creator>泰斗贤若如</dc:creator>
<og:description>谁的大学不迷茫 大学前的准备 2017年，令我难忘的一年，当时的我正在补习班为第二次高考备战着。我们补习班的墙上粘着一道横幅格外显眼——“加油，我们一起上大学”。 应届班的高三同学们听着张杰的“年轻的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zyx110/p/11664377.html</dc:identifier>
</item>
<item>
<title>Spring系列（六）：Spring事务源码解析 - toby.xu</title>
<link>http://www.cnblogs.com/toby-xu/p/11645162.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/toby-xu/p/11645162.html</guid>
<description>&lt;h2&gt;一、事务概述&lt;/h2&gt;
&lt;h3&gt;　　1.1 什么是事务&lt;/h3&gt;
&lt;p&gt;　　事务是一组原子性的SQL查询，或者说是一个独立的工作单元。要么全部执行，要么全部不执行。&lt;/p&gt;
&lt;h3&gt;　　1.2 事务的特性(ACID)&lt;/h3&gt;
&lt;p&gt;　　&lt;strong&gt;①原子性（&lt;/strong&gt;atomicity）&lt;/p&gt;
&lt;p&gt; 　　一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部回滚，对于一个事务来说，不可能只执行其中的一部分操作&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;②一致性（consistency）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　数据库总是从一个一致性的状态转换到另外一个一致性的状态。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;③隔离性（isolation）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　一个事务所做的修改在最终提交以前，对其他事务是不可见的。也就是说多个并发事务之间要相互隔离。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;④持久性（durability）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　一旦事务提交，则其所做的修改就会永久的保存在数据库中，接下来即使数据库系统崩溃了，修改的数据也不会丢失&lt;/p&gt;
&lt;h3&gt;　　1.3 事务的隔离级别&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;　　①读未提交（READ UNCOMMITTED）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 　　事务中的修改，即使没有提交，对其他事务也是可见的，也就是说事务可以读取到未提交的数据，这也被称为脏读。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;②&lt;/strong&gt;读已提交（READ COMMITTED）&lt;/p&gt;
&lt;p&gt;　　一个事务从开始到提交之前，所做的任何修改对其他事务都是不可见的，这个级别有时候也叫不可重复读，因为两次执行同样的查询，可能会得到不一样的结果。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;③可重复读（REPEATABLE READ）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　该隔离级别保证了在同一个事务中多次读取同样的记录的结果是一致的，但是无法解决另外一个幻读的问题，所谓的幻读就是指当某个事务在读取某个范围内的记录是，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时就会产生幻行。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;④可串行化（SERIALIZABLE）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　SERIALIZABLE是最高的隔离级别，通过强制事务的串行执行，避免了前面说的幻读问题，简单来说，SERIALIZABLE会在读取的每一行数据上加上锁。&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;二、Spring事务关键接口&lt;/h2&gt;
&lt;h3&gt;　　1 PlatformTransactionManager 事务管理器&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; PlatformTransactionManager {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获取事务
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    TransactionStatus getTransaction(TransactionDefinition definition) &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; TransactionException;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 提交
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; commit(TransactionStatus status) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; TransactionException;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 回滚
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; rollback(TransactionStatus status) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; TransactionException;

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　2 TransactionDefinition 事务定义信息&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; TransactionDefinition {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Support a current transaction; create a new one if none exists. 支持当前事物，若当前没有事物就创建一个事物
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; PROPAGATION_REQUIRED = 0&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Support a current transaction; execute non-transactionally if none exists. 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式运行
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; PROPAGATION_SUPPORTS = 1&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Support a current transaction; throw an exception if no current transaction exists. 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; PROPAGATION_MANDATORY = 2&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Create a new transaction, suspending the current transaction if one exists.创建一个新的事务，如果当前存在事务，则把当前事务挂起
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; PROPAGATION_REQUIRES_NEW = 3&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Do not support a current transaction; rather always execute non-transactionally.以非事务方式运行，如果当前存在事务，则把当前事务挂起
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; PROPAGATION_NOT_SUPPORTED = 4&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Do not support a current transaction; throw an exception if a current transaction exists. 以非事务方式运行，如果当前存在事务，则抛出异常
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; PROPAGATION_NEVER = 5&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Execute within a nested transaction if a current transaction exists.如果外层存在事务，就以嵌套事务运行，被嵌套的事务可以独立于外层事务进行提交或者回滚(保存点)，
如果外层不存在事务,行为跟PROPAGATION_REQUIRES_NEW
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; PROPAGATION_NESTED = 6&lt;span&gt;;


    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Use the default isolation level of the underlying datastore. 使用数据库默认的隔离级别&lt;br/&gt;　　　&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; ISOLATION_DEFAULT = -1&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 读未提交&lt;br/&gt;　　　&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; ISOLATION_READ_UNCOMMITTED =&lt;span&gt; Connection.TRANSACTION_READ_UNCOMMITTED;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 读已提交&lt;br/&gt;　　  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; ISOLATION_READ_COMMITTED =&lt;span&gt; Connection.TRANSACTION_READ_COMMITTED;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 可重复读&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; ISOLATION_REPEATABLE_READ =&lt;span&gt; Connection.TRANSACTION_REPEATABLE_READ;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 可串行化&lt;br/&gt;　　　&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; ISOLATION_SERIALIZABLE =&lt;span&gt; Connection.TRANSACTION_SERIALIZABLE;


    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 使用默认的超时时间
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; TIMEOUT_DEFAULT = -1&lt;span&gt;;


    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获取事物的传播行为&lt;br/&gt;&lt;/span&gt;&lt;span&gt;     */&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getPropagationBehavior();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获取事物的隔离级别&lt;br/&gt;　　　&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getIsolationLevel();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获取事物的超时时间&lt;br/&gt;　　  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getTimeout();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 是否为只读事物&lt;br/&gt;&lt;/span&gt;&lt;span&gt;     */&lt;/span&gt;
    &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isReadOnly();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获取当前事物的名称&lt;br/&gt;&lt;/span&gt;&lt;span&gt;　　　*/&lt;/span&gt;&lt;span&gt;
    String getName();

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　3 TransactionStatus 事务运行状态&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; TransactionStatus &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; SavepointManager, Flushable {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 是否为新事务
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isNewTransaction();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 是否有保存点&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; hasSavepoint();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 设置为只回滚&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setRollbackOnly();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 是否为只回滚
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isRollbackOnly();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 讲会话刷新到数据库中
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; flush();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 当前事务是否已经完成&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isCompleted();

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;三、Spring事务启动过程&lt;/h2&gt;
&lt;h3&gt;　　1 @EnableTransactionManagement&lt;/h3&gt;
&lt;h4&gt;　　1.1 在主配置类中添加@EnableTransactionManagement注解，开启Spring事务的支持，配置如下：&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@EnableTransactionManagement
@ComponentScan(basePackages &lt;/span&gt;= {&quot;com.toby&quot;&lt;span&gt;})
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TransactionConfig {
    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; DataSource dataSource() {
        DruidDataSource dataSource &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DruidDataSource();
        dataSource.setUsername(&lt;/span&gt;&quot;root&quot;&lt;span&gt;);
        dataSource.setPassword(&lt;/span&gt;&quot;123qwe&quot;&lt;span&gt;);
        dataSource.setUrl(&lt;/span&gt;&quot;jdbc:mysql://localhost:3306/demo_db?useUnicode=true&amp;amp;characterEncoding=utf-8&amp;amp;useSSL=false&quot;&lt;span&gt;);
        dataSource.setDriverClassName(&lt;/span&gt;&quot;com.mysql.jdbc.Driver&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; dataSource;
    }

    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; JdbcTemplate jdbcTemplate(DataSource dataSource) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JdbcTemplate(dataSource);
    }

    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; PlatformTransactionManager transactionManager(DataSource dataSource) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DataSourceTransactionManager(dataSource);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;　　1.2 @EnableTransactionManagement 到底做了什么？&lt;/h4&gt;
&lt;p&gt;　　源码解析跟&lt;strong&gt;&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/toby-xu/p/11444288.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;Spring系列（五）：Spring AOP源码解析&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;中的@EnableAspectJAutoProxy注解一样，可以参考下。主要给Spring容器加入如下组件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1761778/201910/1761778-20191012213633172-1413922925.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt; 　　2 InfrastructureAdvisorAutoProxyCreator&lt;span&gt;（重点）&lt;/span&gt;&lt;/h3&gt;
&lt;h4&gt;　　2.1 首先看下类继承图&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1761778/201910/1761778-20191012213907676-2102553955.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt; 　　2.2 实现了InstantiationAwareBeanPostProcessor接口&lt;/h4&gt;
&lt;p&gt;　　该接口有2个方法postProcessBeforeInstantiation和postProcessAfterInstantiation，其中实例化之前会执行postProcess BeforeInstantiation方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; Object postProcessBeforeInstantiation(Class&amp;lt;?&amp;gt; beanClass, String beanName) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeansException {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;构建我们的缓存key&lt;/span&gt;
        Object cacheKey =&lt;span&gt; getCacheKey(beanClass, beanName);

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!StringUtils.hasLength(beanName) || !&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.targetSourcedBeans.contains(beanName)) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果被解析过直接返回&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.advisedBeans.containsKey(cacheKey)) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
             * 判断是不是基础的bean
             * 判断是不是应该跳过 (此处Spring Aop解析直接解析出我们的切面信息(并且把我们的切面信息进行缓存)，&lt;br/&gt;　　　　　　　　* 而事务在这里是不会解析的，为什么？原因事务的话已经把事务拦截器通过@Bean，而Aop的需要寻找)
             &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (isInfrastructureClass(beanClass) ||&lt;span&gt; shouldSkip(beanClass, beanName)) {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.advisedBeans.put(cacheKey, Boolean.FALSE);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            }
        }

        TargetSource targetSource &lt;/span&gt;=&lt;span&gt; getCustomTargetSource(beanClass, beanName);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (targetSource != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (StringUtils.hasLength(beanName)) {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.targetSourcedBeans.add(beanName);
            }
            Object[] specificInterceptors &lt;/span&gt;=&lt;span&gt; getAdvicesAndAdvisorsForBean(beanClass, beanName, targetSource);
            Object proxy &lt;/span&gt;=&lt;span&gt; createProxy(beanClass, beanName, specificInterceptors, targetSource);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.proxyTypes.put(cacheKey, proxy.getClass());
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; proxy;
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;　　
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;　　2.3 实现了BeanPostProcessor接口&lt;/h4&gt;
&lt;p&gt; 　　该接口有2个方法postProcessBeforeInitialization和postProcessAfterInitialization，其中组件初始化之后会执行postProcessAfterInitialization（该方法创建Aop和事务的代理对象）方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 在该后置方法中 我们的事务和aop的代理对象都是在这生成的
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; bean bean实例
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; beanName bean的名称
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt;
     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; BeansException
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Object postProcessAfterInitialization(@Nullable Object bean, String beanName) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeansException {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (bean != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取缓存key&lt;/span&gt;
            Object cacheKey =&lt;span&gt; getCacheKey(bean.getClass(), beanName);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.earlyProxyReferences.remove(cacheKey) !=&lt;span&gt; bean) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果有必要就代理&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt;&lt;span&gt; wrapIfNecessary(bean, beanName, cacheKey);
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; bean;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　进去wrapIfNecessary(bean, beanName, cacheKey)方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;已经被处理过&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (StringUtils.hasLength(beanName) &amp;amp;&amp;amp; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.targetSourcedBeans.contains(beanName)) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; bean;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不需要增强的&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (Boolean.FALSE.equals(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.advisedBeans.get(cacheKey))) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; bean;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是不是基础的bean 是不是需要跳过的&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (isInfrastructureClass(bean.getClass()) ||&lt;span&gt; shouldSkip(bean.getClass(), beanName)) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.advisedBeans.put(cacheKey, Boolean.FALSE);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; bean;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果有匹配的通知,就创建代理对象&lt;/span&gt;
        Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果不为空，表述需要代理&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (specificInterceptors !=&lt;span&gt; DO_NOT_PROXY) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置当前的对象已处理&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.advisedBeans.put(cacheKey, Boolean.TRUE);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建我们的真正的代理对象&lt;/span&gt;
            Object proxy =&lt;span&gt; createProxy(
                    bean.getClass(), beanName, specificInterceptors, &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SingletonTargetSource(bean));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加入到缓存&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.proxyTypes.put(cacheKey, proxy.getClass());
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; proxy;
        }

        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.advisedBeans.put(cacheKey, Boolean.FALSE);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; bean;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　进入getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null)方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; Object[] getAdvicesAndAdvisorsForBean(
            Class&lt;/span&gt;&amp;lt;?&amp;gt;&lt;span&gt; beanClass, String beanName, @Nullable TargetSource targetSource) {
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 找合适的增强器对象
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        List&lt;/span&gt;&amp;lt;Advisor&amp;gt; advisors =&lt;span&gt; findEligibleAdvisors(beanClass, beanName);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;若合适的通知器为空&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (advisors.isEmpty()) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; DO_NOT_PROXY;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; advisors.toArray();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　进入findEligibleAdvisors(beanClass, beanName)方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt; List&amp;lt;Advisor&amp;gt; findEligibleAdvisors(Class&amp;lt;?&amp;gt;&lt;span&gt; beanClass, String beanName) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;找到Spring IoC容器中所有的候选通知 包括Aop的和事务的&lt;/span&gt;
        List&amp;lt;Advisor&amp;gt; candidateAdvisors =&lt;span&gt; findCandidateAdvisors();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断找到的通知能不能作用到当前的类上&lt;/span&gt;
        List&amp;lt;Advisor&amp;gt; eligibleAdvisors =&lt;span&gt; findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);
        extendAdvisors(eligibleAdvisors);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对我们的advisor进行排序&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;eligibleAdvisors.isEmpty()) {
            eligibleAdvisors &lt;/span&gt;=&lt;span&gt; sortAdvisors(eligibleAdvisors);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; eligibleAdvisors;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;strong&gt;① 进入findCandidateAdvisors()方法，通过增强器检索器检索增强器：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1761778/201910/1761778-20191012222001817-590136552.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　进入findAdvisorBeans()方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; List&amp;lt;Advisor&amp;gt;&lt;span&gt; findAdvisorBeans() {

        &lt;/span&gt;&lt;span&gt;String[] advisorNames &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.cachedAdvisorBeanNames;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (advisorNames == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
             * 去容器中获取到实现了Advisor接口的实现类 我们的事务注解@EnableTransactionManagement导入了一个叫ProxyTransactionManagementConfiguration配置类
             * 而在这个配置类中配置了：
             * @Bean(name = TransactionManagementConfigUtils.TRANSACTION_ADVISOR_BEAN_NAME)
             * @Role(BeanDefinition.ROLE_INFRASTRUCTURE)
             * public BeanFactoryTransactionAttributeSourceAdvisor transactionAdvisor();
             * 然后把他的名字获取出来保存到 本类的属性变量cachedAdvisorBeanNames中
             &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            advisorNames &lt;/span&gt;=&lt;span&gt; BeanFactoryUtils.beanNamesForTypeIncludingAncestors(
                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.beanFactory, Advisor.&lt;span&gt;class&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.cachedAdvisorBeanNames =&lt;span&gt; advisorNames;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;若在容器中没有找到，直接返回一个空的集合&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (advisorNames.length == 0&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
        }

        List&lt;/span&gt;&amp;lt;Advisor&amp;gt; advisors = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;容器中找到了我们事务配置的BeanFactoryTransactionAttributeSourceAdvisor&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (String name : advisorNames) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断他是不是一个合适的&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isEligibleBean(name)) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;BeanFactoryTransactionAttributeSourceAdvisor是不是正在创建的Bean&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.beanFactory.isCurrentlyInCreation(name)) {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isDebugEnabled()) {
                        logger.debug(&lt;/span&gt;&quot;Skipping currently created advisor '&quot; + name + &quot;'&quot;&lt;span&gt;);
                    }
                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不是的话&lt;/span&gt;
                &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;显示的调用getBean方法方法创建我们的BeanFactoryTransactionAttributeSourceAdvisor返回去&lt;/span&gt;
                        advisors.add(&lt;span&gt;this&lt;/span&gt;.beanFactory.getBean(name, Advisor.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
                    }
                    &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (BeanCreationException ex) {
                        Throwable rootCause &lt;/span&gt;=&lt;span&gt; ex.getMostSpecificCause();
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (rootCause &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; BeanCurrentlyInCreationException) {
                            BeanCreationException bce &lt;/span&gt;=&lt;span&gt; (BeanCreationException) rootCause;
                            String bceBeanName &lt;/span&gt;=&lt;span&gt; bce.getBeanName();
                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (bceBeanName != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.beanFactory.isCurrentlyInCreation(bceBeanName)) {
                                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isDebugEnabled()) {
                                    logger.debug(&lt;/span&gt;&quot;Skipping advisor '&quot; + name +
                                            &quot;' with dependency on currently created bean: &quot; +&lt;span&gt; ex.getMessage());
                                }
                                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Ignore: indicates a reference back to the bean we're trying to advise.
                                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; We want to find advisors other than the currently created bean itself.&lt;/span&gt;
                                &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
                            }
                        }
                        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; ex;
                    }
                }
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; advisors;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　进入到isEligibleBean(name)方法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1761778/201910/1761778-20191012222848298-24636502.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　进入isEligibleAdvisorBean(beanName)方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isEligibleAdvisorBean(String beanName) {
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 容器中包含了这个Bean定义，并且Bean定义的角色为BeanDefinition.ROLE_INFRASTRUCTURE
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.beanFactory != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; &lt;span&gt;this&lt;/span&gt;.beanFactory.containsBeanDefinition(beanName) &amp;amp;&amp;amp;
                &lt;span&gt;this&lt;/span&gt;.beanFactory.getBeanDefinition(beanName).getRole() ==&lt;span&gt; BeanDefinition.ROLE_INFRASTRUCTURE);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;如果是合适的就保存在advisors中并返回；至此findCandidateAdvisors()执行完毕！！！&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h4&gt;　　② 找到的增强器是否能作用在当前的类上，findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName)方法：&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1761778/201910/1761778-20191012223847888-1398024872.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　进入到AopUtils.findAdvisorsThatCanApply(candidateAdvisors, beanClass)方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; List&amp;lt;Advisor&amp;gt; findAdvisorsThatCanApply(List&amp;lt;Advisor&amp;gt; candidateAdvisors, Class&amp;lt;?&amp;gt;&lt;span&gt; clazz) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;若候选的增强器集合为空直接返回&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (candidateAdvisors.isEmpty()) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; candidateAdvisors;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义一个合适的增强器集合对象&lt;/span&gt;
        List&amp;lt;Advisor&amp;gt; eligibleAdvisors = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;循环我们候选的增强器对象&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Advisor candidate : candidateAdvisors) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断我们的增强器对象是不是实现了IntroductionAdvisor (很明显我们事务的没有实现 所以不会走下面的逻辑)&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (candidate &lt;span&gt;instanceof&lt;/span&gt; IntroductionAdvisor &amp;amp;&amp;amp;&lt;span&gt; canApply(candidate, clazz)) {
                eligibleAdvisors.add(candidate);
            }
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不为空&lt;/span&gt;
        &lt;span&gt;boolean&lt;/span&gt; hasIntroductions = !&lt;span&gt;eligibleAdvisors.isEmpty();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Advisor candidate : candidateAdvisors) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断我们的增强器对象是不是实现了IntroductionAdvisor (很明显我们事务的没有实现 所以不会走下面的逻辑)&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (candidate &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; IntroductionAdvisor) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在上面已经处理过 ，不需要处理&lt;/span&gt;
                &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
             * 真正的判断增强器是否合适当前类
             &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (canApply(candidate, clazz, hasIntroductions)) {
                eligibleAdvisors.add(candidate);
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; eligibleAdvisors;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　真正的判断增强器是否合适当前类，canApply(candidate, clazz, hasIntroductions)方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; canApply(Advisor advisor, Class&amp;lt;?&amp;gt; targetClass, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; hasIntroductions) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断我们的增强器 IntroductionAdvisor&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (advisor &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; IntroductionAdvisor) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ((IntroductionAdvisor) advisor).getClassFilter().matches(targetClass);
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断我们事务的增强器BeanFactoryTransactionAttributeSourceAdvisor是否实现了PointcutAdvisor&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (advisor &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; PointcutAdvisor) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;转为PointcutAdvisor类型&lt;/span&gt;
            PointcutAdvisor pca =&lt;span&gt; (PointcutAdvisor) advisor;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;找到真正能用的增强器&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; canApply(pca.getPointcut(), targetClass, hasIntroductions);
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; It doesn't have a pointcut so we assume it applies.&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　找到真正能用的增强器，canApply(pca.getPointcut(), targetClass, hasIntroductions)方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; canApply(Pointcut pc, Class&amp;lt;?&amp;gt; targetClass, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; hasIntroductions) {
        Assert.notNull(pc, &lt;/span&gt;&quot;Pointcut must not be null&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;pc.getClassFilter().matches(targetClass)) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 通过切点获取到一个方法匹配器对象
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        MethodMatcher methodMatcher &lt;/span&gt;=&lt;span&gt; pc.getMethodMatcher();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (methodMatcher ==&lt;span&gt; MethodMatcher.TRUE) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; No need to iterate the methods if we're matching any method anyway...&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断匹配器是不是IntroductionAwareMethodMatcher&lt;/span&gt;
        IntroductionAwareMethodMatcher introductionAwareMethodMatcher = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (methodMatcher &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; IntroductionAwareMethodMatcher) {
            introductionAwareMethodMatcher &lt;/span&gt;=&lt;span&gt; (IntroductionAwareMethodMatcher) methodMatcher;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个集合用于保存targetClass的class对象&lt;/span&gt;
        Set&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; classes = &lt;span&gt;new&lt;/span&gt; LinkedHashSet&amp;lt;&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断当前class是不是代理的class对象&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;Proxy.isProxyClass(targetClass)) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加入到集合中去&lt;/span&gt;
&lt;span&gt;            classes.add(ClassUtils.getUserClass(targetClass));
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取到targetClass所实现的接口的class对象，然后加入到集合中&lt;/span&gt;
&lt;span&gt;        classes.addAll(ClassUtils.getAllInterfacesForClassAsSet(targetClass));

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;循环所有的class对象&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (Class&amp;lt;?&amp;gt;&lt;span&gt; clazz : classes) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过class获取到所有的方法&lt;/span&gt;
            Method[] methods =&lt;span&gt; ReflectionUtils.getAllDeclaredMethods(clazz);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;循环我们的方法&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Method method : methods) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过methodMatcher.matches来匹配我们的方法&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (introductionAwareMethodMatcher != &lt;span&gt;null&lt;/span&gt; ?&lt;span&gt;
                        introductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions) :
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过方法匹配器进行匹配&lt;/span&gt;
&lt;span&gt;                        methodMatcher.matches(method, targetClass)) {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                }
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　进入methodMatcher.matches(method, targetClass)方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; matches(Method method, @Nullable Class&amp;lt;?&amp;gt;&lt;span&gt; targetClass) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (targetClass != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; TransactionalProxy.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.isAssignableFrom(targetClass)) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 获取我们@EnableTransactionManagement注解为我们容器中导入的ProxyTransactionManagementConfiguration
         * 配置类中的TransactionAttributeSource对象
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        TransactionAttributeSource tas &lt;/span&gt;=&lt;span&gt; getTransactionAttributeSource();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;若事务属性原为null或者 解析出来的事务注解属性不为空    表示方法匹配&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; (tas == &lt;span&gt;null&lt;/span&gt; || tas.getTransactionAttribute(method, targetClass) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　进入到获取事务注解属性tas.getTransactionAttribute(method, targetClass)方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; TransactionAttribute getTransactionAttribute(Method method, @Nullable Class&amp;lt;?&amp;gt;&lt;span&gt; targetClass) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断method所在的class 是不是Object类型&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (method.getDeclaringClass() == Object.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;构建我们的缓存key&lt;/span&gt;
        Object cacheKey =&lt;span&gt; getCacheKey(method, targetClass);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;先去我们的缓存中获取&lt;/span&gt;
        TransactionAttribute cached = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.attributeCache.get(cacheKey);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;缓存中不为空&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (cached != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断缓存中的对象是不是空事务属性的对象&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (cached ==&lt;span&gt; NULL_TRANSACTION_ATTRIBUTE) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cached;
            }
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;查找我们的事务注解&lt;/span&gt;
            TransactionAttribute txAttr =&lt;span&gt; computeTransactionAttribute(method, targetClass);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;若解析出来的事务注解属性为空&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (txAttr == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;往缓存中存放空事务注解属性&lt;/span&gt;
                &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.attributeCache.put(cacheKey, NULL_TRANSACTION_ATTRIBUTE);
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;我们执行方法的描述符 包名+类名+方法名&lt;/span&gt;
                String methodIdentification =&lt;span&gt; ClassUtils.getQualifiedMethodName(method, targetClass);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;把方法描述设置到事务属性上去&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (txAttr &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; DefaultTransactionAttribute) {
                    ((DefaultTransactionAttribute) txAttr).setDescriptor(methodIdentification);
                }
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isDebugEnabled()) {
                    logger.debug(&lt;/span&gt;&quot;Adding transactional method '&quot; + methodIdentification + &quot;' with attribute: &quot; +&lt;span&gt; txAttr);
                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加入到缓存&lt;/span&gt;
                &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.attributeCache.put(cacheKey, txAttr);
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; txAttr;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　进入查找我们的事务注解，computeTransactionAttribute(method, targetClass)方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt; TransactionAttribute computeTransactionAttribute(Method method, @Nullable Class&amp;lt;?&amp;gt;&lt;span&gt; targetClass) {
        &lt;/span&gt;&lt;span&gt;//判断&lt;/span&gt;&lt;span&gt;我们的事务方法上的修饰符是不是public的&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (allowPublicMethodsOnly() &amp;amp;&amp;amp; !&lt;span&gt;Modifier.isPublic(method.getModifiers())) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; The method may be on an interface, but we need attributes from the target class.
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; If the target class is null, the method will be unchanged.&lt;/span&gt;
        Method specificMethod =&lt;span&gt; AopUtils.getMostSpecificMethod(method, targetClass);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第一：先去目标对象的方法上去找我们的事务注解&lt;/span&gt;
        TransactionAttribute txAttr =&lt;span&gt; findTransactionAttribute(specificMethod);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (txAttr != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; txAttr;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第二：去目标对象上找事务注解&lt;/span&gt;
        txAttr =&lt;span&gt; findTransactionAttribute(specificMethod.getDeclaringClass());
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (txAttr != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; ClassUtils.isUserLevelMethod(method)) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; txAttr;
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (specificMethod !=&lt;span&gt; method) {
            &lt;/span&gt;&lt;span&gt;//第三：&lt;/span&gt;&lt;span&gt;去我们的实现类的接口上的方法去找事务注解&lt;/span&gt;
            txAttr =&lt;span&gt; findTransactionAttribute(method);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (txAttr != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; txAttr;
            }
            &lt;/span&gt;&lt;span&gt;//第四：&lt;/span&gt;&lt;span&gt;去我们的实现类的接口上去找事务注解&lt;/span&gt;
            txAttr =&lt;span&gt; findTransactionAttribute(method.getDeclaringClass());
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (txAttr != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; ClassUtils.isUserLevelMethod(method)) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; txAttr;
            }
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　进入到找@Transactional注解，findTransactionAttribute(specificMethod)方法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1761778/201910/1761778-20191012225518155-1970592922.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　进入determineTransactionAttribute(method)方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; TransactionAttribute determineTransactionAttribute(AnnotatedElement element) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取我们的注解解析器&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (TransactionAnnotationParser annotationParser : &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.annotationParsers) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过注解解析器去解析我们的元素(方法或者类)上的注解&lt;/span&gt;
            TransactionAttribute attr =&lt;span&gt; annotationParser.parseTransactionAnnotation(element);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (attr != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; attr;
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　进入annotationParser.parseTransactionAnnotation(element)方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; TransactionAttribute parseTransactionAnnotation(AnnotatedElement element) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从element对象中获取@Transactional注解 然后把注解属性封装到了AnnotationAttributes&lt;/span&gt;
        AnnotationAttributes attributes =&lt;span&gt; AnnotatedElementUtils.findMergedAnnotationAttributes(
                element, Transactional.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (attributes != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;解析出真正的事务属性对象&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; parseTransactionAnnotation(attributes);
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　进入到解析出真正的事务属性对象，parseTransactionAnnotation(attributes)方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; TransactionAttribute parseTransactionAnnotation(AnnotationAttributes attributes) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个基础规则的事务属性对象&lt;/span&gt;
        RuleBasedTransactionAttribute rbta = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RuleBasedTransactionAttribute();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;解析@Transactionl上的传播行为&lt;/span&gt;
        Propagation propagation = attributes.getEnum(&quot;propagation&quot;&lt;span&gt;);
        rbta.setPropagationBehavior(propagation.value());
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;解析@Transactionl上的隔离级别&lt;/span&gt;
        Isolation isolation = attributes.getEnum(&quot;isolation&quot;&lt;span&gt;);
        rbta.setIsolationLevel(isolation.value());
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;解析@Transactionl上的事务超时事件&lt;/span&gt;
        rbta.setTimeout(attributes.getNumber(&quot;timeout&quot;&lt;span&gt;).intValue());
        rbta.setReadOnly(attributes.getBoolean(&lt;/span&gt;&quot;readOnly&quot;&lt;span&gt;));
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;解析@Transactionl上的事务管理器的名称&lt;/span&gt;
        rbta.setQualifier(attributes.getString(&quot;value&quot;&lt;span&gt;));

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;解析针对哪种异常回滚&lt;/span&gt;
        List&amp;lt;RollbackRuleAttribute&amp;gt; rollbackRules = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Class&amp;lt;?&amp;gt; rbRule : attributes.getClassArray(&quot;rollbackFor&quot;&lt;span&gt;)) {
            rollbackRules.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; RollbackRuleAttribute(rbRule));
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对哪种异常进行回滚&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (String rbRule : attributes.getStringArray(&quot;rollbackForClassName&quot;&lt;span&gt;)) {
            rollbackRules.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; RollbackRuleAttribute(rbRule));
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对哪种异常不回滚&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (Class&amp;lt;?&amp;gt; rbRule : attributes.getClassArray(&quot;noRollbackFor&quot;&lt;span&gt;)) {
            rollbackRules.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; NoRollbackRuleAttribute(rbRule));
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对哪种类型不回滚&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (String rbRule : attributes.getStringArray(&quot;noRollbackForClassName&quot;&lt;span&gt;)) {
            rollbackRules.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; NoRollbackRuleAttribute(rbRule));
        }
        rbta.setRollbackRules(rollbackRules);

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; rbta;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　&lt;strong&gt;&lt;span&gt;至此computeTransactionAttribute(method, targetClass)方法执行完毕！！！&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1761778/201910/1761778-20191012225953438-1425094167.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　然后把我们执行方法的描述符设置到TransactionAttribute事务属性中，表示该方法需要执行Spring事务，并把事务注解属性加入到缓存attributeCache中，&lt;strong&gt;&lt;span&gt;至此获取事务注解属性tas.getTransactionAttribute完毕！！！&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　如果canApply方法返回true表示找到真正能用的增强器了，然后就把合适的增强器加入到eligibleAdvisors中：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1761778/201910/1761778-20191012231359590-119867190.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;strong&gt;&lt;span&gt;至此findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName)执行完毕！！！&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1761778/201910/1761778-20191012232007018-1681254033.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;strong&gt;③ extendAdvisors(eligibleAdvisors) 扩展增强器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　 ④ sortAdvisors(eligibleAdvisors) 排序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;其中③，④ 略 具体参考&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/toby-xu/p/11444288.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;Spring系列（五）：Spring AOP源码解析&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;span&gt;，其实事务找增强器相对Aop简单很多，&lt;strong&gt;&lt;span&gt;到此findEligibleAdvisors(beanClass, beanName)执行完毕！！！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1761778/201910/1761778-20191012232934141-1966255247.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1761778/201910/1761778-20191012232822761-1941844900.png&quot; alt=&quot;&quot; width=&quot;967&quot; height=&quot;395&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;strong&gt;&lt;span&gt;到此Spring事务创建代理对象完毕！！！&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt; 四、Spring事务代理调用过程&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1761778/201910/1761778-20191012234016937-1109050985.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt; 　　第一步：执行addUser(user)方法&lt;/h3&gt;
&lt;p&gt;　　其实就是调用org.springframework.aop.framework.JdkDynamicAopProxy#invoke&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; Object invoke(Object proxy, Method method, Object[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
        Object oldProxy &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; setProxyContext = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取到我们的目标对象&lt;/span&gt;
        TargetSource targetSource = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.advised.targetSource;
        Object target &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;若是equals方法不需要代理&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;.equalsDefined &amp;amp;&amp;amp;&lt;span&gt; AopUtils.isEqualsMethod(method)) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; The target does not implement the equals(Object) method itself.&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt; equals(args[0&lt;span&gt;]);
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;若是hashCode方法不需要代理&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;.hashCodeDefined &amp;amp;&amp;amp;&lt;span&gt; AopUtils.isHashCodeMethod(method)) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; The target does not implement the hashCode() method itself.&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt;&lt;span&gt; hashCode();
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;若是DecoratingProxy也不要拦截器执行&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (method.getDeclaringClass() == DecoratingProxy.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; There is only getDecoratedClass() declared -&amp;gt; dispatch to proxy config.&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt; AopProxyUtils.ultimateTargetClass(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.advised);
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;.advised.opaque &amp;amp;&amp;amp; method.getDeclaringClass().isInterface() &amp;amp;&amp;amp;&lt;span&gt;
                    method.getDeclaringClass().isAssignableFrom(Advised.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Service invocations on ProxyConfig with the proxy config...&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt; AopUtils.invokeJoinpointUsingReflection(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.advised, method, args);
            }

            Object retVal;

            &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
             * 这个配置是暴露我们的代理对象到线程变量中，需要搭配@EnableAspectJAutoProxy(exposeProxy = true)一起使用
　　　　　　　 * 比如在目标对象方法中再次获取代理对象可以使用这个AopContext.currentProxy()
             * 还有的就是事务方法调用事务方法的时候也是用到这个
             &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.advised.exposeProxy) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;把我们的代理对象暴露到线程变量中&lt;/span&gt;
                oldProxy =&lt;span&gt; AopContext.setCurrentProxy(proxy);
                setProxyContext &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取我们的目标对象&lt;/span&gt;
            target =&lt;span&gt; targetSource.getTarget();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取我们目标对象的class&lt;/span&gt;
            Class&amp;lt;?&amp;gt; targetClass = (target != &lt;span&gt;null&lt;/span&gt; ? target.getClass() : &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;把aop的advisor转化为拦截器链&lt;/span&gt;
            List&amp;lt;Object&amp;gt; chain = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果拦截器链为空&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (chain.isEmpty()) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过反射直接调用执行&lt;/span&gt;
                Object[] argsToUse =&lt;span&gt; AopProxyUtils.adaptArgumentsIfNecessary(method, args);
                retVal &lt;/span&gt;=&lt;span&gt; AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个方法调用对象&lt;/span&gt;
                MethodInvocation invocation =
                        &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用执行&lt;/span&gt;
                retVal =&lt;span&gt; invocation.proceed();
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Massage return value if necessary.&lt;/span&gt;
            Class&amp;lt;?&amp;gt; returnType =&lt;span&gt; method.getReturnType();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (retVal != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; retVal == target &amp;amp;&amp;amp;&lt;span&gt;
                    returnType &lt;/span&gt;!= Object.&lt;span&gt;class&lt;/span&gt; &amp;amp;&amp;amp; returnType.isInstance(proxy) &amp;amp;&amp;amp;
                    !RawTargetAccess.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.isAssignableFrom(method.getDeclaringClass())) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Special case: it returned &quot;this&quot; and the return type of the method
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; is type-compatible. Note that we can't help if the target sets
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; a reference to itself in another returned object.&lt;/span&gt;
                retVal =&lt;span&gt; proxy;
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (retVal == &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; returnType != Void.TYPE &amp;amp;&amp;amp;&lt;span&gt; returnType.isPrimitive()) {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AopInvocationException(
                        &lt;/span&gt;&quot;Null return value from advice does not match primitive return type for: &quot; +&lt;span&gt; method);
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; retVal;
        }
        &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (target != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !&lt;span&gt;targetSource.isStatic()) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Must have come from TargetSource.&lt;/span&gt;
&lt;span&gt;                targetSource.releaseTarget(target);
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (setProxyContext) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Restore old proxy.&lt;/span&gt;
&lt;span&gt;                AopContext.setCurrentProxy(oldProxy);
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　 进入到invocation.proceed()方法，该方法的调用用到了递归和责任链设计模式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; Object proceed() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从-1开始,下标=拦截器的长度-1的条件满足表示执行到了最后一个拦截器的时候，此时执行目标方法&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.currentInterceptorIndex == &lt;span&gt;this&lt;/span&gt;.interceptorsAndDynamicMethodMatchers.size() - 1&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; invokeJoinpoint();
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取第一个方法拦截器使用的是前++&lt;/span&gt;
        Object interceptorOrInterceptionAdvice =
                &lt;span&gt;this&lt;/span&gt;.interceptorsAndDynamicMethodMatchers.get(++&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.currentInterceptorIndex);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (interceptorOrInterceptionAdvice &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; InterceptorAndDynamicMethodMatcher) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Evaluate dynamic method matcher here: static part will already have
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; been evaluated and found to match.&lt;/span&gt;
            InterceptorAndDynamicMethodMatcher dm =&lt;span&gt;
                    (InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (dm.methodMatcher.matches(&lt;span&gt;this&lt;/span&gt;.method, &lt;span&gt;this&lt;/span&gt;.targetClass, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.arguments)) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; dm.interceptor.invoke(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Dynamic matching failed.
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Skip this interceptor and invoke the next in the chain.&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt;&lt;span&gt; proceed();
            }
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　进入到((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(this)方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; Object invoke(MethodInvocation invocation) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取我们的代理对象的class属性&lt;/span&gt;
        Class&amp;lt;?&amp;gt; targetClass = (invocation.getThis() != &lt;span&gt;null&lt;/span&gt; ? AopUtils.getTargetClass(invocation.getThis()) : &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 以事务的方式调用目标方法
         * 在这埋了一个钩子函数 用来回调目标方法的
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; invokeWithinTransaction(invocation.getMethod(), targetClass, invocation::proceed);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　调用invokeWithinTransaction方法&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt; Object invokeWithinTransaction(Method method, @Nullable Class&amp;lt;?&amp;gt;&lt;span&gt; targetClass,
            &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; InvocationCallback invocation) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取我们的事务属源对象&lt;/span&gt;
        TransactionAttributeSource tas =&lt;span&gt; getTransactionAttributeSource();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过事务属性源对象获取到我们的事务属性信息&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; TransactionAttribute txAttr = (tas != &lt;span&gt;null&lt;/span&gt; ? tas.getTransactionAttribute(method, targetClass) : &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取我们配置的事务管理器对象&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; PlatformTransactionManager tm =&lt;span&gt; determineTransactionManager(txAttr);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从tx属性对象中获取出标注了@Transactionl的方法描述符&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; String joinpointIdentification =&lt;span&gt; methodIdentification(method, targetClass, txAttr);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;处理声明式事务&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (txAttr == &lt;span&gt;null&lt;/span&gt; || !(tm &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; CallbackPreferringPlatformTransactionManager)) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;有没有必要创建事务&lt;/span&gt;
            TransactionInfo txInfo =&lt;span&gt; createTransactionIfNecessary(tm, txAttr, joinpointIdentification);

            Object retVal;
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用钩子函数进行回调目标方法&lt;/span&gt;
                retVal =&lt;span&gt; invocation.proceedWithInvocation();
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable ex) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;抛出异常进行回滚处理&lt;/span&gt;
&lt;span&gt;                completeTransactionAfterThrowing(txInfo, ex);
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; ex;
            }
            &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;清空我们的线程变量中transactionInfo的值&lt;/span&gt;
&lt;span&gt;                cleanupTransactionInfo(txInfo);
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;提交事务&lt;/span&gt;
&lt;span&gt;            commitTransactionAfterReturning(txInfo);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; retVal;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;编程式事务&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; ThrowableHolder throwableHolder = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThrowableHolder();

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; It's a CallbackPreferringPlatformTransactionManager: pass a TransactionCallback in.&lt;/span&gt;
            &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                Object result &lt;/span&gt;= ((CallbackPreferringPlatformTransactionManager) tm).execute(txAttr, status -&amp;gt;&lt;span&gt; {
                    TransactionInfo txInfo &lt;/span&gt;=&lt;span&gt; prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);
                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; invocation.proceedWithInvocation();
                    }
                    &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable ex) {
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (txAttr.rollbackOn(ex)) {
                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; A RuntimeException: will lead to a rollback.&lt;/span&gt;
                            &lt;span&gt;if&lt;/span&gt; (ex &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; RuntimeException) {
                                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; (RuntimeException) ex;
                            }
                            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThrowableHolderException(ex);
                            }
                        }
                        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; A normal return value: will lead to a commit.&lt;/span&gt;
                            throwableHolder.throwable =&lt;span&gt; ex;
                            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                        }
                    }
                    &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                        cleanupTransactionInfo(txInfo);
                    }
                });

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Check result state: It might indicate a Throwable to rethrow.&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (throwableHolder.throwable != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; throwableHolder.throwable;
                }
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ThrowableHolderException ex) {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; ex.getCause();
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (TransactionSystemException ex2) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (throwableHolder.throwable != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    logger.error(&lt;/span&gt;&quot;Application exception overridden by commit exception&quot;&lt;span&gt;, throwableHolder.throwable);
                    ex2.initApplicationException(throwableHolder.throwable);
                }
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; ex2;
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable ex2) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (throwableHolder.throwable != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    logger.error(&lt;/span&gt;&quot;Application exception overridden by commit exception&quot;&lt;span&gt;, throwableHolder.throwable);
                }
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; ex2;
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;　　1&lt;strong&gt; createTransactionIfNecessary(tm, txAttr, joinpointIdentification)方法：&lt;/strong&gt;&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; TransactionInfo createTransactionIfNecessary(@Nullable PlatformTransactionManager tm,
            @Nullable TransactionAttribute txAttr, &lt;/span&gt;&lt;span&gt;final&lt;/span&gt;&lt;span&gt; String joinpointIdentification) {

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 把我们的方法描述符作为一个事务名称&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (txAttr != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; txAttr.getName() == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            txAttr &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DelegatingTransactionAttribute(txAttr) {
                @Override
                &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; joinpointIdentification;
                }
            };
        }

        TransactionStatus status &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (txAttr != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tm != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取一个事务状态&lt;/span&gt;
                status =&lt;span&gt; tm.getTransaction(txAttr);
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isDebugEnabled()) {
                    logger.debug(&lt;/span&gt;&quot;Skipping transactional joinpoint [&quot; + joinpointIdentification +
                            &quot;] because no transaction manager has been configured&quot;&lt;span&gt;);
                }
            }
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;把事务状态和事务属性等信息封装成一个TransactionInfo对象&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h5&gt;　　1.1 &lt;strong&gt;进入获取一个事务状态，tm.getTransaction(txAttr)方法：&lt;/strong&gt;&lt;/h5&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; TransactionStatus getTransaction(@Nullable TransactionDefinition definition) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; TransactionException {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;尝试获取一个事务对象&lt;/span&gt;
        Object transaction =&lt;span&gt; doGetTransaction();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Cache debug flag to avoid repeated checks.&lt;/span&gt;
        &lt;span&gt;boolean&lt;/span&gt; debugEnabled =&lt;span&gt; logger.isDebugEnabled();

        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 判断从上一个方法传递进来的事务属性是不是为空
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (definition == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;为空的话，执行非事务方法&lt;/span&gt;
            definition = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultTransactionDefinition();
        }

        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 判断是不是已经存在了事务对象
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isExistingTransaction(transaction)) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;处理存在的事务&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; handleExistingTransaction(definition, transaction, debugEnabled);
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;检查事务设置的超时时间&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (definition.getTimeout() &amp;lt;&lt;span&gt; TransactionDefinition.TIMEOUT_DEFAULT) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; InvalidTimeoutException(&quot;Invalid transaction timeout&quot;&lt;span&gt;, definition.getTimeout());
        }

        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 若当前的事务属性式 PROPAGATION_MANDATORY 表示必须运行在事务中，若当前没有事务就抛出异常
         * 由于isExistingTransaction(transaction)跳过了这里，说明当前是不存在事务的，那么就会抛出异常
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (definition.getPropagationBehavior() ==&lt;span&gt; TransactionDefinition.PROPAGATION_MANDATORY) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalTransactionStateException(
                    &lt;/span&gt;&quot;No existing transaction found for transaction marked with propagation 'mandatory'&quot;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * PROPAGATION_REQUIRED 当前存在事务就加入到当前的事务,没有就新开一个
         * PROPAGATION_REQUIRES_NEW:新开一个事务,若当前存在事务就挂起当前事务
         * PROPAGATION_NESTED: PROPAGATION_NESTED
            表示如果当前正有一个事务在运行中，则该方法应该运行在 一个嵌套的事务中，
            被嵌套的事务可以独立于封装事务进行提交或者回滚(保存点)，
            如果封装事务不存在,行为就像 PROPAGATION_REQUIRES_NEW
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||&lt;span&gt;
                definition.getPropagationBehavior() &lt;/span&gt;== TransactionDefinition.PROPAGATION_REQUIRES_NEW ||&lt;span&gt;
                definition.getPropagationBehavior() &lt;/span&gt;==&lt;span&gt; TransactionDefinition.PROPAGATION_NESTED) {
            &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
             * 挂起当前事务，在这里为啥传入null?
             * 因为逻辑走到这里了,经过了上面的isExistingTransaction(transaction) 判断当前是不存在事务的
             * 所有再这里是挂起当前事务传递一个null进去
             &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            SuspendedResourcesHolder suspendedResources &lt;/span&gt;= suspend(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (debugEnabled) {
                logger.debug(&lt;/span&gt;&quot;Creating new transaction with name [&quot; + definition.getName() + &quot;]: &quot; +&lt;span&gt; definition);
            }
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; newSynchronization = (getTransactionSynchronization() !=&lt;span&gt; SYNCHRONIZATION_NEVER);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;新创建一个事务状态&lt;/span&gt;
                DefaultTransactionStatus status =&lt;span&gt; newTransactionStatus(
                        definition, transaction, &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;, newSynchronization, debugEnabled, suspendedResources);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开启一个新的事物&lt;/span&gt;
&lt;span&gt;                doBegin(transaction, definition);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;把当前的事务信息绑定到线程变量去&lt;/span&gt;
&lt;span&gt;                prepareSynchronization(status, definition);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; status;
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt; (RuntimeException |&lt;span&gt; Error ex) {
                resume(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;, suspendedResources);
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; ex;
            }
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个空的事务
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Create &quot;empty&quot; transaction: no actual transaction, but potentially synchronization.&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT &amp;amp;&amp;amp;&lt;span&gt; logger.isWarnEnabled()) {
                logger.warn(&lt;/span&gt;&quot;Custom isolation level specified but no actual transaction initiated; &quot; +
                        &quot;isolation level will effectively be ignored: &quot; +&lt;span&gt; definition);
            }
            &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; newSynchronization = (getTransactionSynchronization() ==&lt;span&gt; SYNCHRONIZATION_ALWAYS);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; prepareTransactionStatus(definition, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;, newSynchronization, debugEnabled, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　① 进入到doGetTransaction()方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; Object doGetTransaction() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个数据源事务对象&lt;/span&gt;
        DataSourceTransactionObject txObject = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DataSourceTransactionObject();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否允许当前事务设置保持点&lt;/span&gt;
&lt;span&gt;        txObject.setSavepointAllowed(isNestedTransactionAllowed());
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * TransactionSynchronizationManager 事务同步管理器对象(该类中都是局部线程变量)
         * 用来保存当前事务的信息,我们第一次从这里去线程变量中获取 事务连接持有器对象 通过数据源为key去获取
         * 由于第一次进来开始事务 我们的事务同步管理器中没有被存放.所以此时获取出来的conHolder为null
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        ConnectionHolder conHolder &lt;/span&gt;=&lt;span&gt;
                (ConnectionHolder) TransactionSynchronizationManager.getResource(obtainDataSource());
        txObject.setConnectionHolder(conHolder, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回事务对象&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; txObject;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　② 进入isExistingTransaction(transaction)方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isExistingTransaction(Object transaction) {
        DataSourceTransactionObject txObject &lt;/span&gt;=&lt;span&gt; (DataSourceTransactionObject) transaction;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;若第一次进来开始事务，txObject.hasConnectionHolder() 返回的null 那么表示不存在事务&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; (txObject.hasConnectionHolder() &amp;amp;&amp;amp;&lt;span&gt; txObject.getConnectionHolder().isTransactionActive());
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　③ 由于事务传播机制是TransactionDefinition.PROPAGATION_REQUIRED，所以走下面分支&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1761778/201910/1761778-20191013002122643-8557110.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　④ 进入挂起事务，suspend(null)方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; SuspendedResourcesHolder suspend(@Nullable Object transaction) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; TransactionException {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断当前的线程变量中 有没有激活的事物,有需要清空线程变量&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (TransactionSynchronizationManager.isSynchronizationActive()) {
            List&lt;/span&gt;&amp;lt;TransactionSynchronization&amp;gt; suspendedSynchronizations =&lt;span&gt; doSuspendSynchronization();
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                Object suspendedResources &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (transaction != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    suspendedResources &lt;/span&gt;=&lt;span&gt; doSuspend(transaction);
                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取已存在的事务的名称&lt;/span&gt;
                String name =&lt;span&gt; TransactionSynchronizationManager.getCurrentTransactionName();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;清空线程变量的&lt;/span&gt;
                TransactionSynchronizationManager.setCurrentTransactionName(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取出只读事务的名称&lt;/span&gt;
                &lt;span&gt;boolean&lt;/span&gt; readOnly =&lt;span&gt; TransactionSynchronizationManager.isCurrentTransactionReadOnly();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;清空线程变量的&lt;/span&gt;
                TransactionSynchronizationManager.setCurrentTransactionReadOnly(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取已存在事务的隔离级别&lt;/span&gt;
                Integer isolationLevel =&lt;span&gt; TransactionSynchronizationManager.getCurrentTransactionIsolationLevel();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;清空隔离级别&lt;/span&gt;
                TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取激活标志&lt;/span&gt;
                &lt;span&gt;boolean&lt;/span&gt; wasActive =&lt;span&gt; TransactionSynchronizationManager.isActualTransactionActive();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;清空标记&lt;/span&gt;
                TransactionSynchronizationManager.setActualTransactionActive(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;把上诉从线程变量中获取出来的存在事务属性封装为挂起的事务属性返回出去&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SuspendedResourcesHolder(
                        suspendedResources, suspendedSynchronizations, name, readOnly, isolationLevel, wasActive);
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt; (RuntimeException |&lt;span&gt; Error ex) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; doSuspend failed - original transaction is still active...&lt;/span&gt;
&lt;span&gt;                doResumeSynchronization(suspendedSynchronizations);
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; ex;
            }
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (transaction != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Transaction active but no synchronization active.&lt;/span&gt;
            Object suspendedResources =&lt;span&gt; doSuspend(transaction);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SuspendedResourcesHolder(suspendedResources);
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Neither transaction nor synchronization active.&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　⑤ 进入到事务开始，doBegin(transaction, definition)方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doBegin(Object transaction, TransactionDefinition definition) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;强制转化事务对象&lt;/span&gt;
        DataSourceTransactionObject txObject =&lt;span&gt; (DataSourceTransactionObject) transaction;
        Connection con &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断事务对象没有数据库连接持有器&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (!txObject.hasConnectionHolder() ||&lt;span&gt;
                    txObject.getConnectionHolder().isSynchronizedWithTransaction()) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过数据源获取一个数据库连接对象&lt;/span&gt;
                Connection newCon =&lt;span&gt; obtainDataSource().getConnection();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isDebugEnabled()) {
                    logger.debug(&lt;/span&gt;&quot;Acquired Connection [&quot; + newCon + &quot;] for JDBC transaction&quot;&lt;span&gt;);
                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;把我们的数据库连接包装成一个ConnectionHolder对象 然后设置到我们的txObject对象中去&lt;/span&gt;
                txObject.setConnectionHolder(&lt;span&gt;new&lt;/span&gt; ConnectionHolder(newCon), &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;标记当前的连接是一个同步事务&lt;/span&gt;
            txObject.getConnectionHolder().setSynchronizedWithTransaction(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
            con &lt;/span&gt;=&lt;span&gt; txObject.getConnectionHolder().getConnection();

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;为当前的事务设置隔离级别&lt;/span&gt;
            Integer previousIsolationLevel =&lt;span&gt; DataSourceUtils.prepareConnectionForTransaction(con, definition);
            txObject.setPreviousIsolationLevel(previousIsolationLevel);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭自动提交&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (con.getAutoCommit()) {
                txObject.setMustRestoreAutoCommit(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isDebugEnabled()) {
                    logger.debug(&lt;/span&gt;&quot;Switching JDBC Connection [&quot; + con + &quot;] to manual commit&quot;&lt;span&gt;);
                }
                con.setAutoCommit(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断事务为只读事务&lt;/span&gt;
&lt;span&gt;            prepareTransactionalConnection(con, definition);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置事务激活&lt;/span&gt;
            txObject.getConnectionHolder().setTransactionActive(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置事务超时时间&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; timeout =&lt;span&gt; determineTimeout(definition);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (timeout !=&lt;span&gt; TransactionDefinition.TIMEOUT_DEFAULT) {
                txObject.getConnectionHolder().setTimeoutInSeconds(timeout);
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 绑定我们的数据源和连接到我们的同步管理器上   把数据源作为key,数据库连接作为value 设置到线程变量中&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (txObject.isNewConnectionHolder()) {
                TransactionSynchronizationManager.bindResource(obtainDataSource(), txObject.getConnectionHolder());
            }
        }

        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable ex) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (txObject.isNewConnectionHolder()) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;释放数据库连接&lt;/span&gt;
&lt;span&gt;                DataSourceUtils.releaseConnection(con, obtainDataSource());
                txObject.setConnectionHolder(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; CannotCreateTransactionException(&quot;Could not open JDBC Connection for transaction&quot;&lt;span&gt;, ex);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　⑥ 进入到prepareSynchronization(status, definition)方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; prepareSynchronization(DefaultTransactionStatus status, TransactionDefinition definition) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (status.isNewSynchronization()) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;绑定事务激活&lt;/span&gt;
&lt;span&gt;            TransactionSynchronizationManager.setActualTransactionActive(status.hasTransaction());
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前事务的隔离级别&lt;/span&gt;
&lt;span&gt;            TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(
                    definition.getIsolationLevel() &lt;/span&gt;!= TransactionDefinition.ISOLATION_DEFAULT ?&lt;span&gt;
                            definition.getIsolationLevel() : &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否为只读事务&lt;/span&gt;
&lt;span&gt;            TransactionSynchronizationManager.setCurrentTransactionReadOnly(definition.isReadOnly());
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;事务的名称&lt;/span&gt;
&lt;span&gt;            TransactionSynchronizationManager.setCurrentTransactionName(definition.getName());
            TransactionSynchronizationManager.initSynchronization();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h5&gt;　　1.2 把事务状态和事务属性等信息封装成一个TransactionInfo对象，prepareTransactionInfo(tm, txAttr, joinpointIdentification, status)方法：&lt;/h5&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; TransactionInfo prepareTransactionInfo(PlatformTransactionManager tm,
            TransactionAttribute txAttr, String joinpointIdentification, TransactionStatus status) {

        TransactionInfo txInfo &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TransactionInfo(tm, txAttr, joinpointIdentification);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (txAttr != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; We need a transaction for this method...&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isTraceEnabled()) {
                logger.trace(&lt;/span&gt;&quot;Getting transaction for [&quot; + txInfo.getJoinpointIdentification() + &quot;]&quot;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; The transaction manager will flag an error if an incompatible tx already exists.&lt;/span&gt;
&lt;span&gt;            txInfo.newTransactionStatus(status);
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; The TransactionInfo.hasTransaction() method will return false. We created it only
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; to preserve the integrity of the ThreadLocal stack maintained in this class.&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isTraceEnabled())
                logger.trace(&lt;/span&gt;&quot;Don't need to create transaction for [&quot; + joinpointIdentification +
                        &quot;]: This method isn't transactional.&quot;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; We always bind the TransactionInfo to the thread, even if we didn't create
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; a new transaction here. This guarantees that the TransactionInfo stack
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; will be managed correctly even if no transaction was created by this aspect.&lt;/span&gt;
&lt;span&gt;        txInfo.bindToThread();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; txInfo;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;　　2 调用钩子函数进行回调目标方法，invocation.proceedWithInvocation()方法最终会调用到目标方法里面：&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1761778/201910/1761778-20191013003540036-506778559.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt; 　　第二步：addLog(&quot;新增用户&quot;) 其中事务注解上的传播机制是propagation = Propagation.NESTED&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1761778/201910/1761778-20191013004009652-1109626673.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　执行流程参考前面的addUser流程，区别是到AbstractPlatformTransactionManager#getTransaction里面的isExistingTransaction (transaction)，这个时候是返回true的，所以执行handleExistingTransaction(definition, transaction, debugEnabled)方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;74&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt;&lt;span&gt; TransactionStatus handleExistingTransaction(
            TransactionDefinition definition, Object transaction, &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; debugEnabled)
            &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; TransactionException {

        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 判断当前的事务行为是不是PROPAGATION_NEVER的
         * 表示为不支持事务,但是当前又存在一个事务,所以抛出异常
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (definition.getPropagationBehavior() ==&lt;span&gt; TransactionDefinition.PROPAGATION_NEVER) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalTransactionStateException(
                    &lt;/span&gt;&quot;Existing transaction found for transaction marked with propagation 'never'&quot;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 判断当前的事务属性不支持事务,PROPAGATION_NOT_SUPPORTED,所以需要先挂起已经存在的事务
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (definition.getPropagationBehavior() ==&lt;span&gt; TransactionDefinition.PROPAGATION_NOT_SUPPORTED) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (debugEnabled) {
                logger.debug(&lt;/span&gt;&quot;Suspending current transaction&quot;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;挂起存在的事务&lt;/span&gt;
            Object suspendedResources =&lt;span&gt; suspend(transaction);
            &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; newSynchronization = (getTransactionSynchronization() ==&lt;span&gt; SYNCHRONIZATION_ALWAYS);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个新的非事务状态(保存了上一个存在事务状态的属性)&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; prepareTransactionStatus(
                    definition, &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;, newSynchronization, debugEnabled, suspendedResources);
        }

        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 当前的事务属性状态是PROPAGATION_REQUIRES_NEW表示需要新开启一个事务状态
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (definition.getPropagationBehavior() ==&lt;span&gt; TransactionDefinition.PROPAGATION_REQUIRES_NEW) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (debugEnabled) {
                logger.debug(&lt;/span&gt;&quot;Suspending current transaction, creating new transaction with name [&quot; +&lt;span&gt;
                        definition.getName() &lt;/span&gt;+ &quot;]&quot;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;挂起已经存在的事务&lt;/span&gt;
            SuspendedResourcesHolder suspendedResources =&lt;span&gt; suspend(transaction);
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; newSynchronization = (getTransactionSynchronization() !=&lt;span&gt; SYNCHRONIZATION_NEVER);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个新的事务状态(包含了挂起的事务的属性)&lt;/span&gt;
                DefaultTransactionStatus status =&lt;span&gt; newTransactionStatus(
                        definition, transaction, &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;, newSynchronization, debugEnabled, suspendedResources);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开启新的事务&lt;/span&gt;
&lt;span&gt;                doBegin(transaction, definition);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;把新的事务状态设置到当前的线程变量中去&lt;/span&gt;
&lt;span&gt;                prepareSynchronization(status, definition);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; status;
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt; (RuntimeException |&lt;span&gt; Error beginEx) {
                resumeAfterBeginException(transaction, suspendedResources, beginEx);
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; beginEx;
            }
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (definition.getPropagationBehavior() ==&lt;span&gt; TransactionDefinition.PROPAGATION_NESTED) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;isNestedTransactionAllowed()) {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NestedTransactionNotSupportedException(
                        &lt;/span&gt;&quot;Transaction manager does not allow nested transactions by default - &quot; +
                        &quot;specify 'nestedTransactionAllowed' property with value 'true'&quot;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (debugEnabled) {
                logger.debug(&lt;/span&gt;&quot;Creating nested transaction with name [&quot; + definition.getName() + &quot;]&quot;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;嵌套事务的处理&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (useSavepointForNestedTransaction()) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开启一个新的事务&lt;/span&gt;
                DefaultTransactionStatus status =&lt;span&gt;
                        prepareTransactionStatus(definition, transaction, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, debugEnabled, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;为事务设置一个回退点&lt;/span&gt;
&lt;span&gt;                status.createAndHoldSavepoint();
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; status;
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; {&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Nested transaction through nested begin and commit/rollback calls.
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Usually only for JTA: Spring synchronization might get activated here
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; in case of a pre-existing JTA transaction.&lt;/span&gt;
                &lt;span&gt;boolean&lt;/span&gt; newSynchronization = (getTransactionSynchronization() !=&lt;span&gt; SYNCHRONIZATION_NEVER);
                DefaultTransactionStatus status &lt;/span&gt;=&lt;span&gt; newTransactionStatus(
                        definition, transaction, &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;, newSynchronization, debugEnabled, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
                doBegin(transaction, definition);
                prepareSynchronization(status, definition);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; status;
            }
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Assumably PROPAGATION_SUPPORTS or PROPAGATION_REQUIRED.&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (debugEnabled) {
            logger.debug(&lt;/span&gt;&quot;Participating in existing transaction&quot;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isValidateExistingTransaction()) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (definition.getIsolationLevel() !=&lt;span&gt; TransactionDefinition.ISOLATION_DEFAULT) {
                Integer currentIsolationLevel &lt;/span&gt;=&lt;span&gt; TransactionSynchronizationManager.getCurrentTransactionIsolationLevel();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (currentIsolationLevel == &lt;span&gt;null&lt;/span&gt; || currentIsolationLevel !=&lt;span&gt; definition.getIsolationLevel()) {
                    Constants isoConstants &lt;/span&gt;=&lt;span&gt; DefaultTransactionDefinition.constants;
                    &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalTransactionStateException(&quot;Participating transaction with definition [&quot; +&lt;span&gt;
                            definition &lt;/span&gt;+ &quot;] specifies isolation level which is incompatible with existing transaction: &quot; +&lt;span&gt;
                            (currentIsolationLevel &lt;/span&gt;!= &lt;span&gt;null&lt;/span&gt; ?&lt;span&gt;
                                    isoConstants.toCode(currentIsolationLevel, DefaultTransactionDefinition.PREFIX_ISOLATION) :
                                    &lt;/span&gt;&quot;(unknown)&quot;&lt;span&gt;));
                }
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;definition.isReadOnly()) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (TransactionSynchronizationManager.isCurrentTransactionReadOnly()) {
                    &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalTransactionStateException(&quot;Participating transaction with definition [&quot; +&lt;span&gt;
                            definition &lt;/span&gt;+ &quot;] is not marked as read-only but existing transaction is&quot;&lt;span&gt;);
                }
            }
        }
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; newSynchronization = (getTransactionSynchronization() !=&lt;span&gt; SYNCHRONIZATION_NEVER);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; prepareTransactionStatus(definition, transaction, &lt;span&gt;false&lt;/span&gt;, newSynchronization, debugEnabled, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　由于addLog上面的事务注解的传播机制是TransactionDefinition.PROPAGATION_NESTED，所以执行下面分支&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1761778/201910/1761778-20191013004945309-1840588607.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　可以看出内嵌事务设置保存点，也就是说内嵌事务的异常回滚是回滚到该保存点的，只要外层封装事务捕获了内嵌事务的异常，内嵌事务的回滚是不会影响外层封装事务的。从demo的例子就能体现这点。接下来又回到addUser方法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1761778/201910/1761778-20191013005532299-1758768675.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　示例demo中的目标方法如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
 @Transactional(propagation = Propagation.NESTED,rollbackFor = Exception.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addLog(String operation) {
        logDao.addLog(operation);
        System.out.println(&lt;/span&gt;1/0&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　1/0会报java.lang.ArithmeticException: / by zero异常，所以被catch捕获到，从而进行回滚，此时由于前面内嵌事务设置了保存点，所以内嵌事务值回滚到保存点，对外面没有影响。内嵌事务执行完了之后，继续外层addUser的方法执行&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1761778/201910/1761778-20191013010112070-899001189.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　addUser方法捕获了logService.addLog(&quot;新增用户&quot;)异常如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
@Transactional(propagation = Propagation.REQUIRED,rollbackFor = Exception.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addUser(User user) {
        userDao.addUser(user.getName(),user.getSex(),user.getAddress());
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;演示Propagation.NESTED 内嵌事务不影响外部事务&lt;/span&gt;
        &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            logService.addLog(&lt;/span&gt;&quot;新增用户&quot;&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            e.printStackTrace();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　所以外层事务的还是能正常提交事务&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1761778/201910/1761778-20191013010328149-317274879.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;strong&gt;&lt;span&gt;至此整个addUser方法执行完毕！！！！&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 　　总结：首先通过事务概述，对事务的ACID特性，事务的隔离级别，Spring事务的传播机制有了一定的认识，然后分析了@Enable TransactionManagement注解开启Spring事务的支持功能，该注解为我们Spring容器中注册了InfrastructureAdvisorAutoProxy Creator组件，Spring事务代理创建都在这个组件中完成，然后通过一个较为复杂的嵌套事务的调用过程分析，进一步加深对Spring事务的传播机制理解。Spring系列完整代码在码云：&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;https://gitee.com/xutaowin/spring&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;spring系列&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 12 Oct 2019 17:32:00 +0000</pubDate>
<dc:creator>toby.xu</dc:creator>
<og:description>一、事务概述 1.1 什么是事务 事务是一组原子性的SQL查询，或者说是一个独立的工作单元。要么全部执行，要么全部不执行。 1.2 事务的特性(ACID) ①原子性（atomicity） 一个事务必须</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/toby-xu/p/11645162.html</dc:identifier>
</item>
<item>
<title>极大似然小结 - 飞剑客阿飞</title>
<link>http://www.cnblogs.com/moonwanderer/p/11664619.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/moonwanderer/p/11664619.html</guid>
<description>&lt;p&gt;在机器学习中，我们经常要利用极大似然法近似数据整体的分布，本篇文章通过介绍极大似然法及其一些性质，旨在深入浅出地解释清楚极大似然法。&lt;/p&gt;
&lt;h3 id=&quot;贝叶斯概率&quot;&gt;0. 贝叶斯概率&lt;/h3&gt;
&lt;p&gt;首先看一下经典的贝叶斯公式：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ p(Y|X)=\frac{p(X|Y)p(Y)}{p(X)} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中，&lt;span class=&quot;math inline&quot;&gt;\(p(Y)\)&lt;/span&gt;称为先验概率(&lt;span class=&quot;math inline&quot;&gt;\(prior\)&lt;/span&gt;)，即根据先验知识得出的关于变量&lt;span class=&quot;math inline&quot;&gt;\(Y\)&lt;/span&gt;的分布，&lt;span class=&quot;math inline&quot;&gt;\(p(X|Y)\)&lt;/span&gt;称为似然函数（&lt;span class=&quot;math inline&quot;&gt;\(likelihood\)&lt;/span&gt;），&lt;span class=&quot;math inline&quot;&gt;\(p(X)\)&lt;/span&gt;为变量&lt;span class=&quot;math inline&quot;&gt;\(X\)&lt;/span&gt;的概率，&lt;span class=&quot;math inline&quot;&gt;\(p(Y|X)\)&lt;/span&gt;称之为条件概率（给定变量&lt;span class=&quot;math inline&quot;&gt;\(X\)&lt;/span&gt;的情况下&lt;span class=&quot;math inline&quot;&gt;\(Y\)&lt;/span&gt;的概率，&lt;span class=&quot;math inline&quot;&gt;\(posterior\)&lt;/span&gt;，后验概率）。&lt;/p&gt;
&lt;h3 id=&quot;似然函数&quot;&gt;1. 似然函数&lt;/h3&gt;
&lt;p&gt;似然，即可能性；顾名思义，则似然函数就是关于可能性的函数了。在统计学中，它表示了模型参数的似然性，即作为统计模型中参数的函数。一般形式如下：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ L(\omega)=p(D | \omega) = p(x_1, x_2, \cdots ,x_n| \omega) \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中，&lt;span class=&quot;math inline&quot;&gt;\(D\)&lt;/span&gt;表示样本集&lt;span class=&quot;math inline&quot;&gt;\(\{x_1,x_2,\cdots, x_n\}\)&lt;/span&gt;,  &lt;span class=&quot;math inline&quot;&gt;\(\omega\)&lt;/span&gt;表示参数向量。&lt;/p&gt;
&lt;p&gt;似然函数表示了在不同的参数向量&lt;span class=&quot;math inline&quot;&gt;\(\omega\)&lt;/span&gt;下，观测数据出现的可能性的大小，它是参数向量&lt;span class=&quot;math inline&quot;&gt;\(\omega\)&lt;/span&gt;的函数。在某种意义上，我们可以认为其是条件概率的逆反&lt;span class=&quot;math inline&quot;&gt;\(^{[1]}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;在这里利用Wikipedia&lt;span class=&quot;math inline&quot;&gt;\(^{[1]}\)&lt;/span&gt;中的例子简要说明一下似然函数，同时也引出极大似然估计。&lt;/p&gt;
&lt;blockquote readability=&quot;31&quot;&gt;
&lt;p&gt;考虑优质一枚硬币的实验，通常来说，我们的硬币都是“公平”（质地均匀）的，即正面向上（Head）的概率&lt;span class=&quot;math inline&quot;&gt;\(p_H=0.5\)&lt;/span&gt;，由此概率我们可以知道投掷若干次后各种结果出现的可能性（概率，或然性）。&lt;/p&gt;
&lt;p&gt;例如，投掷硬币两次，两次都为上的概率为0.25，利用条件概率表示，即：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ P(HH|p_h=0.5)=0.5^2=0.25 \]&lt;/span&gt;&lt;br/&gt;如果一个硬币并非质地均匀，那么它可能是一枚“非公平”的。在统计学中，我们关注的是&lt;strong&gt;已知一系列投掷的结果时，关于硬币投掷时正面朝上的可能性的信息&lt;/strong&gt;。我们可以建立一个统计模型：假设硬币投出时会有&lt;span class=&quot;math inline&quot;&gt;\(p_H\)&lt;/span&gt;的概率正面朝上，则有&lt;span class=&quot;math inline&quot;&gt;\(1-p_H\)&lt;/span&gt;的概率反面朝上。这时通过&lt;strong&gt;观察已发生的&lt;/strong&gt;两次投掷，条件概率可以改写成似然函数：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ L(p_H)=P(HH|p_H=0.5)=0.25 \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;也就是说，对于取定的似然函数，在观测到两次投掷都是正面朝上时，&lt;span class=&quot;math inline&quot;&gt;\(p_H\)&lt;/span&gt;的&lt;strong&gt;似然性&lt;/strong&gt;是0.25。注意，反之并不成立，&lt;strong&gt;即当似然函数为0.25时，不能推论出&lt;span class=&quot;math inline&quot;&gt;\(p_H=0.25\)&lt;/span&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果考虑&lt;span class=&quot;math inline&quot;&gt;\(p_H=0.6\)&lt;/span&gt;，那似然函数也会改变：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ L(p_H)=P(HH|p_H=0.6)=0.36 \]&lt;/span&gt;&lt;br/&gt;如图所示，注意到似然函数的值变大了。这说明，如果参数&lt;span class=&quot;math inline&quot;&gt;\(p_H\)&lt;/span&gt;取值变成0.6的话，结果观测到连续两次正面朝上的概率比假设&lt;span class=&quot;math inline&quot;&gt;\(p_H=0.5\)&lt;/span&gt;时更大，也就是说，参数&lt;span class=&quot;math inline&quot;&gt;\(p_H\)&lt;/span&gt;取0.6要比取成0.5更有说服力，更为&quot;&lt;strong&gt;合理&lt;/strong&gt;&quot;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/moonwanderer/p/LikelihoodFunctionAfterHH.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;总之，&lt;strong&gt;似然函数的重要性不是它的具体取值，而是当参数变化时，函数到底变小还是变大&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对同一个似然函数，其所代表的模型中，某项参数值具有多种可能，但如果存在一个参数值，使得它的函数值最爱的话，那么这个值就是这项参数最为“合理”的参数值。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在这个例子中，&lt;span class=&quot;math inline&quot;&gt;\(p_H\)&lt;/span&gt;取1时，似然函数达到最大值。也即是，当连续观测到两次正面朝上时，假设硬币投掷时正面朝上的概率为1是最合理的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在上述引用中，我们看到了一个极端的结论，即未来所有的投掷都会是正面向上，这是频率派观点下使用广泛的一种方法，即极大似然法。在上面的观点中（频率派），&lt;span class=&quot;math inline&quot;&gt;\(\omega\)&lt;/span&gt;被认为是一个固定的参数，它的值通过&lt;strong&gt;估计&lt;/strong&gt;来确定。但是在贝叶斯派观点中，只有一个数据集&lt;span class=&quot;math inline&quot;&gt;\(D\)&lt;/span&gt;(即实际观测到的数据集)，参数的不确定性通过&lt;span class=&quot;math inline&quot;&gt;\(\omega\)&lt;/span&gt;的概率分布来表达。贝叶斯的观点是对先验概率的包含是很自然的事情，包含先验概率的贝叶斯方法将不会得到上述的极端结论。&lt;/p&gt;
&lt;p&gt;另外还有两点需要注意，第一，似然函数不是&lt;span class=&quot;math inline&quot;&gt;\(\omega\)&lt;/span&gt;的概率分布，关于&lt;span class=&quot;math inline&quot;&gt;\(\omega\)&lt;/span&gt;的积分并不一定等于1；第二，似然&lt;span class=&quot;math inline&quot;&gt;\(\ne\)&lt;/span&gt;概率，概率（或然性）用于在已知一些参数的情况下预测接下来的结果，似然性则是在已知某些结果时，对有关参数进行估值。关于第二点，举个例子，如果我有一枚硬币，如果是质地均匀的（&lt;strong&gt;已知参数&lt;/strong&gt;），那么它出现正面朝上的&lt;strong&gt;概率&lt;/strong&gt;为0.5（&lt;strong&gt;结果&lt;/strong&gt;）；同样地，如果一枚硬币，我抛了100次，正面朝上52次（结果），那么我认为硬币十有八九是质地均匀的（&lt;strong&gt;估计参数&lt;/strong&gt;）。&lt;/p&gt;
&lt;h3 id=&quot;极大似然估计maximum-likelihood-estimation-mle&quot;&gt;2. 极大似然估计（maximum likelihood estimation， MLE）&lt;/h3&gt;
&lt;p&gt;了解了似然函数，那么极大似然估计是什么就很好理解了，它是一种用来估计一个&lt;strong&gt;概率模型参数&lt;/strong&gt;的方法。根据公式（2），我们一旦获得一个数据集&lt;span class=&quot;math inline&quot;&gt;\(D\)&lt;/span&gt;，那我们就能求得一个关于&lt;span class=&quot;math inline&quot;&gt;\(\omega\)&lt;/span&gt;的估计，极大似然估计会寻找一个最可能的值（此处的可能是最可能的&lt;span class=&quot;math inline&quot;&gt;\(\omega\)&lt;/span&gt;，这个&lt;span class=&quot;math inline&quot;&gt;\(\omega\)&lt;/span&gt;可以使出现采样&lt;span class=&quot;math inline&quot;&gt;\(D\)&lt;/span&gt;的可能性最大化）。&lt;/p&gt;
&lt;p&gt;从数学上来讲，我们可以在&lt;span class=&quot;math inline&quot;&gt;\(\omega\)&lt;/span&gt;的所有取值中，寻找一个值使得似然函数达到最大值，这种估计方法称之为极大似然估计。极大似然估计是样本不变时，关于&lt;span class=&quot;math inline&quot;&gt;\(\omega\)&lt;/span&gt;的函数。极大似然估计不一定存在，也不一定唯一。&lt;/p&gt;
&lt;p&gt;在第1节中预测硬币的质地&lt;span class=&quot;math inline&quot;&gt;\(\omega\)&lt;/span&gt;，是关于极大似然估计的一个经典例子。其他例子可以查看参考文献&lt;span class=&quot;math inline&quot;&gt;\(^{[2]}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;现在我们看一下极大似然估计在正态分布中的应用：&lt;/p&gt;
&lt;p&gt;现在假定我们有一个观测的数据集&lt;span class=&quot;math inline&quot;&gt;\(\mathbf{x}=(x_1,\cdots,x_N)^T\)&lt;/span&gt;，表示标量变量&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;的N次观测。我们假定各次观测是独立地从高斯分布中抽取，分布的均值&lt;span class=&quot;math inline&quot;&gt;\(\mu\)&lt;/span&gt;和方差&lt;span class=&quot;math inline&quot;&gt;\(\sigma^2\)&lt;/span&gt;未知，我们想根据数据集来确定这些参数。两个独立事件的联合概率可以由各个事件的边缘概率的乘积得到。我们的数据集&lt;span class=&quot;math inline&quot;&gt;\(\mathbf{x}\)&lt;/span&gt;是独立同分布的，因此给定&lt;span class=&quot;math inline&quot;&gt;\(\mu\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(\sigma^2\)&lt;/span&gt;，我们可以给出高斯分布的似然函数：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ p(\mathbf{x}|\mu,\sigma^2)=\prod_{n=1}^{N}\mathcal{N}(x_n|\mu,\sigma^2) \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;为了简化分析和有助于数值运算,我们取似然函数的对数（&lt;strong&gt;最大化对数似然等价于最大化似然函数，很容易证明&lt;/strong&gt;）:&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ ln(\mathbf x|\mu,\sigma^2)=-\frac {1} {2\sigma^2} \sum_{n=1}^{N}(x_n-\mu)^2-\frac {N}{2}ln\sigma^2-\frac{N}{2}ln(2\pi) \]&lt;/span&gt;&lt;br/&gt;关于&lt;span class=&quot;math inline&quot;&gt;\(\mu\)&lt;/span&gt;，最大化对数似然函数，得到&lt;span class=&quot;math inline&quot;&gt;\(\mu\)&lt;/span&gt;的最大似然解：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \mu_{ML}=\frac {1}{N} \sum_{n=1}^{N}x_n \]&lt;/span&gt;&lt;br/&gt;可看到解为样本均值。同理，方差&lt;span class=&quot;math inline&quot;&gt;\(\sigma^2\)&lt;/span&gt;的最大似然解为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \sigma_{ML}^2=\frac {1}{N} \sum_{n=1}^{N}(x_n-\mu_{ML})^2 \]&lt;/span&gt;&lt;br/&gt;由此完成了正态分布的极大似然估计。&lt;/p&gt;
&lt;h3 id=&quot;极大似然的有偏性&quot;&gt;3. 极大似然的有偏性&lt;/h3&gt;
&lt;p&gt;极大似然估计方法求解参数有一定局限性&lt;span class=&quot;math inline&quot;&gt;\(^{[3]}\)&lt;/span&gt;，极大似然法除了会得出第1节中关于硬币的极端情况外，还会出现一种情况，&lt;strong&gt;有偏估计&lt;/strong&gt;，就是期望&lt;span class=&quot;math inline&quot;&gt;\(\ne\)&lt;/span&gt;理想值。最大似然方法会系统化地低估分布的方差。下面进行证明：&lt;/p&gt;
&lt;p&gt;均值的估计&lt;span class=&quot;math inline&quot;&gt;\(\mu_{ML}\)&lt;/span&gt;的期望&lt;span class=&quot;math inline&quot;&gt;\(E[\mu_{ML}]\)&lt;/span&gt;为:&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ E(\mu_{ML})=E(\frac{1}{N} \sum_{n=1}^{N}x_n)=\frac {1}{N}E({\sum_{n=1}^{N}x_n})=\frac{1}{N}\sum_{n=1}^{N}E(x_n)=\mu \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;方差的估计&lt;span class=&quot;math inline&quot;&gt;\(\sigma^2\)&lt;/span&gt;的期望&lt;span class=&quot;math inline&quot;&gt;\(E[\sigma_{ML}^2]\)&lt;/span&gt;为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ E[\sigma_{ML}^2]=E(\frac {1}{N} \sum_{n=1}^{N}(x_n-\mu_{ML})^2)=E(\frac{1}{N}\sum_{n=1}^{N}x_n^2-\mu_{ML}^2)=\frac {1}{N}\sum_{n=1}^{N}E(x_n^2)-E(\mu_{ML}^2) \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;然后求其后两项，正态分布的二阶矩为&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ E(x_n^2)=\mu^2+\sigma^2 \]&lt;/span&gt;&lt;br/&gt;而&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ E(\mu_{ML}^2)=E((\frac{x_1+x_2+x_3+\cdots+x_n}{n})^2)=\frac{1}{n^2}(n^2\mu^2+n\sigma^2) \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;故：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ E[\sigma_{ML}^2]=\frac{n-1}{n}\sigma^2 \]&lt;/span&gt;&lt;br/&gt;由此证明了极大似然的有偏性。其中公式（12）和公式（13）的证明可自行参考正态分布的基础知识。&lt;/p&gt;
&lt;p&gt;在这里，PRML&lt;span class=&quot;math inline&quot;&gt;\(^{[3]}\)&lt;/span&gt;给出了更直观地解释，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/moonwanderer/p/1570894486589.png&quot; alt=&quot;1570894486589&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中，绿色曲线表示真实高斯分布，数据点是根据此概率分布生成，三条红色分别拟合了三个高斯概率分布，每个数据集包含了两个蓝色数据点，对三个数据集求平均，很明显方差被低估了。&lt;strong&gt;因为它是相对样本均值进行测量的，而不是相对真实的均值进行测量&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;后记&quot;&gt;4. 后记&lt;/h3&gt;
&lt;p&gt;极大似然作为机器学习中的一种最常用方法，深刻理解其含义是非常必要且有用的，应该像这对于理解概率论和一些常见的模型有着很大的帮助。当然，极大似然法还有一些性质，如&lt;strong&gt;泛函不变性&lt;/strong&gt;，&lt;strong&gt;渐行线行为&lt;/strong&gt;，限于时间精力和个人水平，没有给出证明，读者可自行参考维基百科&lt;span class=&quot;math inline&quot;&gt;\(^{[2]}\)&lt;/span&gt;。文章中大部分内容为总结和摘抄，共勉。&lt;/p&gt;
&lt;p&gt;参考文献：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E4%BC%BC%E7%84%B6%E5%87%BD%E6%95%B0&quot;&gt;https://zh.wikipedia.org/wiki/%E4%BC%BC%E7%84%B6%E5%87%BD%E6%95%B0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%9C%80%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1&quot;&gt;https://zh.wikipedia.org/wiki/%E6%9C%80%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;《 &lt;a href=&quot;http://users.isr.ist.utl.pt/~wurmd/Livros/school/Bishop%20-%20Pattern%20Recognition%20And%20Machine%20Learning%20-%20Springer%202006.pdf&quot;&gt;Pattern Recognition and Machine Learning&lt;/a&gt; 》（即PRML）&lt;/li&gt;
&lt;li&gt;《Theory of Point Estimation》&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.zhihu.com/question/35670078&quot; class=&quot;uri&quot;&gt;https://www.zhihu.com/question/35670078&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Sat, 12 Oct 2019 17:31:00 +0000</pubDate>
<dc:creator>飞剑客阿飞</dc:creator>
<og:description>在机器学习中，我们经常要利用极大似然法近似数据整体的分布，本篇文章通过介绍极大似然法及其一些性质，旨在深入浅出地解释清楚极大似然法。 0. 贝叶斯概率 首先看一下经典的贝叶斯公式： $$ p(Y|X)</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/moonwanderer/p/11664619.html</dc:identifier>
</item>
<item>
<title>.NET斗鱼直播弹幕客户端（上） - .NET骚操作</title>
<link>http://www.cnblogs.com/sdflysha/p/20191011-douyu-barrage-with-dotnet.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sdflysha/p/20191011-douyu-barrage-with-dotnet.html</guid>
<description>&lt;p&gt;现在直播平台由于&lt;strong&gt;弹幕&lt;/strong&gt;的存在，主播与观众可以更轻松地进行互动，非常受年轻群众的欢迎。斗鱼TV就是一款非常流行的直播平台，弹幕更是非常火爆。看到有不少主播接入&lt;code&gt;弹幕语音播报器&lt;/code&gt;、&lt;code&gt;弹幕点歌&lt;/code&gt;等模块，这都需要首先连接斗鱼弹幕。&lt;/p&gt;
&lt;p&gt;经常看到其它编程语言的开发者，分享了他们斗鱼弹幕客户端的代码。&lt;code&gt;.NET&lt;/code&gt;当然也能做，还能做得更好（只是不知为何很少见人分享😂）。&lt;/p&gt;
&lt;p&gt;本文将包含以下内容：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;我将使用斗鱼TV官方公开的弹幕PDF文档，使用&lt;code&gt;Socket&lt;/code&gt;/&lt;code&gt;TcpClient&lt;/code&gt;连续斗鱼弹幕；&lt;/li&gt;
&lt;li&gt;分析如何利用&lt;code&gt;.NET&lt;/code&gt;强大的&lt;code&gt;ValueTask&lt;/code&gt;特性，在保持代码简洁的同时，轻松享受高性能异步代码的快乐；&lt;/li&gt;
&lt;li&gt;然后将使用&lt;code&gt;Reactive Extensions&lt;/code&gt;（&lt;code&gt;RX&lt;/code&gt;），演示如何将一系列复杂的弹幕接入操作，就像写&lt;code&gt;Hello World&lt;/code&gt;一般容易；&lt;/li&gt;
&lt;li&gt;用我自制的“准游戏引擎”&lt;code&gt;FlysEngine&lt;/code&gt;，只需少量代码，即可将斗鱼TV的弹幕显示左右飞过的效果；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;本文内容可能比较多，因此分上、下两篇阐述，上篇将具体聊聊第1、2点，第3、4点将在下篇进行，整篇完成后，最终效果如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/233608/201910/233608-20191013000802086-1693839442.gif&quot;/&gt;&lt;/p&gt;

&lt;p&gt;现在网上可以轻松找到&lt;code&gt;斗鱼弹幕服务器第三方接入协议v1.6.2.pdf&lt;/code&gt;（网上搜索该关键字即可找到）。&lt;br/&gt;文档提到，第三方接入弹幕服务的服务器为&lt;code&gt;openbarrage.douyutv.com:8601&lt;/code&gt;，我们可以使用&lt;code&gt;TcpClient&lt;/code&gt;来方便连接：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;using (var client = new TcpClient())
{
    client.ConnectAsync(&quot;openbarrage.douyutv.com&quot;, 8601).Wait();
    Stream stream = client.GetStream();
    // do other works
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该文档中提到所有数据包格式如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/233608/201910/233608-20191013000809744-2066118098.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意前两个4字节的消息长度是完全一样的，可以使用&lt;code&gt;Debug.Assert&lt;/code&gt;进行断言。&lt;/p&gt;
&lt;p&gt;其中所有数字都为小端整数，刚好&lt;code&gt;.NET&lt;/code&gt;的&lt;code&gt;BinaryWriter&lt;/code&gt;类默认都以小端整数进行转换。可以利用起来。&lt;/p&gt;
&lt;p&gt;因此，读取一个消息包的完整代码如下：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;using (var reader = new BinaryReader(stream, Encoding.UTF8, true))
{
    var fullMsgLength = reader.ReadInt32();
    var fullMsgLength2 = reader.ReadInt32();
    Debug.Assert(fullMsgLength == fullMsgLength2);

    var length = fullMsgLength - 1 - 4 - 4;
    var packType = reader.ReadInt16();
    Debug.Assert(packType == ServerSendToClient);
    var encrypted = reader.ReadByte();
    Debug.Assert(encrypted == Encrypted);
    var reserved = reader.ReadByte();
    Debug.Assert(reserved == Reserved);

    var bytes = reader.ReadBytes(length);
    var zero = reader.ReadByte();
    Debug.Assert(zero == ByteZero);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中&lt;code&gt;bytes&lt;/code&gt;既是数据部分，根据&lt;code&gt;pdf&lt;/code&gt;文档中的规定，该部分为&lt;code&gt;UTF-8&lt;/code&gt;编码，在&lt;code&gt;C#&lt;/code&gt;中使用&lt;code&gt;Encoding.UTF8.GetString()&lt;/code&gt;即可获取其字符串，该字符串长这样子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;type@=chatmsg/rid@=633019/ct@=1/uid@=124155/nn@=夜科扬羽/txt@=这不压个蜥蜴/cid@=602c7f1becf2419962a6520300000000/ic@=avatar@S000@S12@S41@S55_avatar/level@=21/sahf@=0/cst@=1570891500125/bnn@=賊开心/bl@=8/brid@=5789561/hc@=21ebd5b2c86c01e0565453e45f14ca5b/el@=/lk@=/urlev@=10/ &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该格式不是&lt;code&gt;JSON&lt;/code&gt;/&lt;code&gt;XML&lt;/code&gt;等，但仔细分析又确实有逻辑，有层次感，根据文档，该格式为所谓的&lt;code&gt;STT&lt;/code&gt;序列化，该格式包含键值对、数组等多种格式。相比&lt;code&gt;JSON&lt;/code&gt;可以减少大量的引号&quot;空间开销。还好协议简单，我可以通过寥寥几行代码，即可转换为&lt;code&gt;Json.NET&lt;/code&gt;的&lt;code&gt;JToken&lt;/code&gt;格式：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public static JToken DecodeStringToJObject(string str)
{
    if (str.Contains(&quot;//&quot;)) // 数组
    {
        var result = new JArray();
        foreach (var field in str.Split(new[] { &quot;//&quot; }, StringSplitOptions.RemoveEmptyEntries))
        {
            result.Add(DecodeStringToJObject(field));
        }
        return result;
    }
    if (str.Contains(&quot;@=&quot;)) // 对象
    {
        var result = new JObject();
        foreach (var field in str.Split(new[] { '/' }, StringSplitOptions.RemoveEmptyEntries))
        {
            var tokens = field.Split(new[] { &quot;@=&quot; }, StringSplitOptions.None);
            var k = tokens[0];
            var v = UnscapeSlashAt(tokens[1]);
            result[k] = DecodeStringToJObject(v);
        }
        return result;
    }
    else if (str.Contains(&quot;@A=&quot;)) // 键值对
    {
        return DecodeStringToJObject(UnscapeSlashAt(str));
    }
    else
    {
        return UnscapeSlashAt(str); // 值
    }
}

static string EscapeSlashAt(string str)
{
    return str
        .Replace(&quot;/&quot;, &quot;@S&quot;)
        .Replace(&quot;@&quot;, &quot;@A&quot;);
}

static string UnscapeSlashAt(string str)
{
    return str
        .Replace(&quot;@S&quot;, &quot;/&quot;)
        .Replace(&quot;@A&quot;, &quot;@&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样一来，即可将&lt;code&gt;STT&lt;/code&gt;格式转换为&lt;code&gt;JSON&lt;/code&gt;格式，因此只需像&lt;code&gt;JSON&lt;/code&gt;格式取出&lt;code&gt;nn&lt;/code&gt;字段和&lt;code&gt;txt&lt;/code&gt;字段即可，还有一个&lt;code&gt;col&lt;/code&gt;字段，可以用来确定弹幕颜色，我可以将其转换为&lt;code&gt;RGB&lt;/code&gt;的&lt;code&gt;int32&lt;/code&gt;值：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;Color = (x[&quot;col&quot;] ?? new JValue(0)).Value&amp;lt;int&amp;gt;() switch
{
    1 =&amp;gt; 0xff0000, // 红
    2 =&amp;gt; 0x1e87f0, // 浅蓝
    3 =&amp;gt; 0x7ac84b, // 浅绿
    4 =&amp;gt; 0xff7f00, // 橙色
    5 =&amp;gt; 0x9b39f4, // 紫色
    6 =&amp;gt; 0xff69b4, // 洋红
    _ =&amp;gt; 0xffffff, // 默认，白色
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该代码使用了&lt;code&gt;C# 8.0&lt;/code&gt;的&lt;code&gt;switch expression&lt;/code&gt;功能，可以一个表达式转成整个颜色转换，比&lt;code&gt;if/else&lt;/code&gt;和&lt;code&gt;switch/case&lt;/code&gt;语句都精简不少，可谓一气呵成。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;C# 5.0&lt;/code&gt;提供了强大的异步&lt;code&gt;API&lt;/code&gt;——&lt;code&gt;async/await&lt;/code&gt;，通过异步API，以前难以用编程实现的操作现在可以像写串行代码一样轻松完成，还能轻松加入取消任务操作。&lt;/p&gt;
&lt;p&gt;然后&lt;code&gt;C# 7.0&lt;/code&gt;发布了&lt;code&gt;ValueTask&lt;/code&gt;，&lt;code&gt;ValueTask&lt;/code&gt;是值类型，因此在频繁调用异步操作（如使用&lt;code&gt;Stream&lt;/code&gt;读取字节）时，不会因为创建过多的&lt;code&gt;Task&lt;/code&gt;而分配没必要的内存。这里，我确实是使用&lt;code&gt;TCP&lt;/code&gt;连接流读取字节，是使用&lt;code&gt;ValueTask&lt;/code&gt;的最佳时机。&lt;/p&gt;
&lt;p&gt;这里我们将尝试将代码切换为&lt;code&gt;ValueTask&lt;/code&gt;版本。&lt;/p&gt;
&lt;p&gt;首先第一个问题是&lt;code&gt;BinaryReader&lt;/code&gt;类，该类提供了便利的字节操作方式，且能确保字节端为小端，但该类不提供异步&lt;code&gt;API&lt;/code&gt;，因此需要作一些特殊处理：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public static async Task&amp;lt;string&amp;gt; RecieveAsync(Stream stream, CancellationToken cancellationToken)
{
    int fullMsgLength = await ReadInt32().ConfigureAwait(false);
    int fullMsgLength2 = await ReadInt32().ConfigureAwait(false);
    Debug.Assert(fullMsgLength == fullMsgLength2);

    int length = fullMsgLength - 1 - 4 - 4;
    short packType = await ReadInt16().ConfigureAwait(false);
    Debug.Assert(packType == ServerSendToClient);
    short encrypted = await ReadByte().ConfigureAwait(false);
    Debug.Assert(encrypted == Encrypted);
    short reserved = await ReadByte().ConfigureAwait(false);
    Debug.Assert(reserved == Reserved);

    Memory&amp;lt;byte&amp;gt; bytes = await ReadBytes(length).ConfigureAwait(false);
    byte zero = await ReadByte().ConfigureAwait(false);
    Debug.Assert(zero == ByteZero);

    return Encoding.UTF8.GetString(bytes.Span);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如代码所示，我封装了&lt;code&gt;ReadInt16()&lt;/code&gt;和&lt;code&gt;ReadInt32()&lt;/code&gt;两个方法，&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var intBuffer = new byte[4];
var int32Buffer = new Memory&amp;lt;byte&amp;gt;(intBuffer, 0, 4);

async ValueTask&amp;lt;int&amp;gt; ReadInt32()
{
    var memory = int32Buffer;
    int read = 0;
    while (read &amp;lt; 4)
    {
        read += await stream.ReadAsync(memory.Slice(read), cancellationToken).ConfigureAwait(false);
    }
    Debug.Assert(read == memory.Length);
    return 
        (intBuffer[0] &amp;lt;&amp;lt; 0) + 
        (intBuffer[1] &amp;lt;&amp;lt; 8) +
        (intBuffer[2] &amp;lt;&amp;lt; 16) + 
        (intBuffer[3] &amp;lt;&amp;lt; 24);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如图，我还使用了一个&lt;code&gt;while&lt;/code&gt;语句，因为不像&lt;code&gt;BinaryReader&lt;/code&gt;，如果一次无法读取所需的字节数（4个字节），&lt;code&gt;stream.ReadAsync()&lt;/code&gt;并不会堵塞线程。然后需要将&lt;code&gt;int32Buffer&lt;/code&gt;转换为&lt;code&gt;int&lt;/code&gt;类型。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;注意：此处我没有使用&lt;code&gt;BitConverter.ToInt32()&lt;/code&gt;，也不能使用该方法，因为该方法不像&lt;code&gt;BinaryReader&lt;/code&gt;，它在大端/小端的&lt;code&gt;CPU&lt;/code&gt;上会有不同的行为。（其中在大端&lt;code&gt;CPU&lt;/code&gt;上将有错误的行为）涉及二进制序列化需要传输的，不能使用&lt;code&gt;BitConverter&lt;/code&gt;类。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;同样的，写&lt;code&gt;TCP&lt;/code&gt;流也需要有相应的变化：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;static async Task SendAsync(Stream stream, byte[] body, CancellationToken cancellationToken)
{
    var buffer = new byte[4];
    
    await stream.WriteAsync(GetBytesI32(4 + 4 + body.Length + 1), cancellationToken).ConfigureAwait(false);
    await stream.WriteAsync(GetBytesI32(4 + 4 + body.Length + 1), cancellationToken).ConfigureAwait(false);

    await stream.WriteAsync(GetBytesI16(ClientSendToServer), cancellationToken).ConfigureAwait(false);
    await stream.WriteAsync(new byte[] { Encrypted}, cancellationToken).ConfigureAwait(false);
    await stream.WriteAsync(new byte[] { Reserved}, cancellationToken).ConfigureAwait(false);

    await stream.WriteAsync(body, cancellationToken).ConfigureAwait(false);
    await stream.WriteAsync(new byte[] { ByteZero}, cancellationToken).ConfigureAwait(false);
    
    Memory&amp;lt;byte&amp;gt; GetBytesI32(int v)
    {
        buffer[0] = (byte)v;
        buffer[1] = (byte)(v &amp;gt;&amp;gt; 8);
        buffer[2] = (byte)(v &amp;gt;&amp;gt; 16);
        buffer[3] = (byte)(v &amp;gt;&amp;gt; 24);
        return new Memory&amp;lt;byte&amp;gt;(buffer, 0, 4);
    }

    Memory&amp;lt;byte&amp;gt; GetBytesI16(short v)
    {
        buffer[0] = (byte)v;
        buffer[1] = (byte)(v &amp;gt;&amp;gt; 8);;
        return new Memory&amp;lt;byte&amp;gt;(buffer, 0, 2);
    }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;最终运行效果如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/233608/201910/233608-20191013000828693-2124088762.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这一篇文章介绍了如何使用斗鱼tv开放弹幕&lt;code&gt;API&lt;/code&gt;，下篇将会：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;共享本文所使用的所有完整的源代码；&lt;/li&gt;
&lt;li&gt;介绍如何使用&lt;code&gt;Reactive Extensions&lt;/code&gt;（&lt;code&gt;RX&lt;/code&gt;），演示这一系列操作用起来，就像写&lt;code&gt;Hello World&lt;/code&gt;一样简单；&lt;/li&gt;
&lt;li&gt;用我自制的“准游戏引擎”&lt;code&gt;FlysEngine&lt;/code&gt;，只需少量代码，即可实现桌面弹幕的效果；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;敬请期待！“刷一波666🚀🚀🚀”&lt;/p&gt;
&lt;p&gt;喜欢的朋友请关注我的微信公众号：【DotNet骚操作】&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/233608/201908/233608-20190825165420518-990227633.jpg&quot; alt=&quot;DotNet骚操作&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 12 Oct 2019 16:13:00 +0000</pubDate>
<dc:creator>.NET骚操作</dc:creator>
<og:description>.NET也能连斗鱼TV直播弹幕</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sdflysha/p/20191011-douyu-barrage-with-dotnet.html</dc:identifier>
</item>
<item>
<title>pinpoint1.8.5安装及使用指南 - luozhiyun</title>
<link>http://www.cnblogs.com/luozhiyun/p/11664534.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/luozhiyun/p/11664534.html</guid>
<description>&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;pinpoint是开源在github上的一款APM监控工具，它是用Java编写的，用于大规模分布式系统监控。它对性能的影响最小（只增加约3％资源利用率），安装agent是无侵入式的。&lt;/p&gt;
&lt;p&gt;各大APM工具，几乎都是根据google这篇经典的Dapper论文而来，一定要读一读。这里是它的源文地址：https://research.google.com/pubs/pub36356.html，感谢这位同学的翻译：http://bigbully.github.io/Dapper-translation/&lt;/p&gt;
&lt;p&gt;pinpoint提供了一些功能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;服务映射：通过可视化其组件如何互连来了解任何分布式系统的关联关系。单击节点可显示有关组件的详细信息，例如其当前状态和事务计数。&lt;/li&gt;
&lt;li&gt;实时的活跃线程数&lt;/li&gt;
&lt;li&gt;请求/响应散点图&lt;/li&gt;
&lt;li&gt;调用栈&lt;/li&gt;
&lt;li&gt;查看有关应用程序的其他详细信息，例如CPU使用率，内存/垃圾收集，TPS和JVM参数&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204119/201910/1204119-20191013000736751-1142811357.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;整个pinpoint架构分为3部分：pinpoint-collector、pinpoint-agent、pinpoint-webUI。&lt;/p&gt;
&lt;p&gt;pinpoint-agent：用来收集单个应用的信息，并将收集好的应用信息发送到pinpoint-collector中&lt;br/&gt;pinpoint-collector：用来处理pinpoint-agent发送过来的信息，并将信息收集好之后存储到HBase中&lt;br/&gt;pinpoint-webUI：查找出HBase中的数据并展示&lt;/p&gt;
&lt;p&gt;所以我这里需要准备两台机器：&lt;br/&gt;10.200.201.xxx：用于安装pinpoint-collector、pinpoint-webUI、HBase&lt;br/&gt;10.200.201.yyy：用于安装pinpoint-agent，负责收集应用的信息&lt;/p&gt;
&lt;h2 id=&quot;环境安装&quot;&gt;环境安装&lt;/h2&gt;
&lt;h3 id=&quot;安装jdk&quot;&gt;安装jdk&lt;/h3&gt;
&lt;p&gt;我这里用的是rpm包直接安装的：rpm -ivh jdk-8u171-linux-x64.rpm&lt;br/&gt;安装好后配置一下JAVA_HOME：&lt;/p&gt;
&lt;p&gt;使用vim配置一下环境变量：&lt;br/&gt;vim /etc/profile&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;export JAVA_HOME=/usr/java/jdk1.8.0_45
export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar
export PATH=$PATH:$JAVA_HOME/bin&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后加载一些profile文件：&lt;br/&gt;source /etc/profile&lt;/p&gt;
&lt;h3 id=&quot;安装hbase&quot;&gt;安装HBase&lt;/h3&gt;
&lt;p&gt;这里有个对照图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204119/201910/1204119-20191013000751382-1411442897.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由上面我们可以看到HBase我们需要安装1.2.x版本的&lt;br/&gt;下载地址：&lt;br/&gt;http://archive.apache.org/dist/hbase/&lt;br/&gt;我这里下载的是1.2.12版本的。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;将Hbse放到指定目录&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;cd /app/install
tar -zxvf hbase-1.2.12-bin.tar.gz&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;修改配置信息&lt;br/&gt;修改hbase-env.sh&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;vim /app/install/hbase-1.2.12/conf/hbase-env.sh

#加入JAVA_HOME
export JAVA_HOME=/usr/java/jdk1.8.0_45&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改hbase-site.xml&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;vim /app/install/hbase-1.2.12/conf/hbase-site.xml

&amp;lt;configuration&amp;gt;
        &amp;lt;property&amp;gt;
            &amp;lt;name&amp;gt;hbase.rootdir&amp;lt;/name&amp;gt;
            &amp;lt;value&amp;gt;file:///app/data/hbase&amp;lt;/value&amp;gt;
        &amp;lt;/property&amp;gt;
        &amp;lt;property&amp;gt;
            &amp;lt;name&amp;gt;hbase.zookeeper.property.dataDir&amp;lt;/name&amp;gt;
            &amp;lt;value&amp;gt;/app/data/zookeeper&amp;lt;/value&amp;gt;
        &amp;lt;/property&amp;gt;
        &amp;lt;property&amp;gt;
         &amp;lt;name&amp;gt;hbase.zookeeper.property.clientPort&amp;lt;/name&amp;gt;
         &amp;lt;value&amp;gt;2181&amp;lt;/value&amp;gt;
         &amp;lt;description&amp;gt;Property from ZooKeeper'sconfig zoo.cfg. The port at which the clients will connect.
         &amp;lt;/description&amp;gt;
        &amp;lt;/property&amp;gt;
        &amp;lt;!-- false是单机模式，true是分布式模式  --&amp;gt;
        &amp;lt;property&amp;gt;
         &amp;lt;name&amp;gt;hbase.cluster.distributed&amp;lt;/name&amp;gt;
         &amp;lt;value&amp;gt;false&amp;lt;/value&amp;gt;
        &amp;lt;/property&amp;gt;
&amp;lt;/configuration&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;启动HBase&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;cd /app/install/hbase-1.2.12/bin
./start-hbase.sh

# 查看Hbase是否启动成功，如果启动成功的会看到&quot;HMaster&quot;的进程
[root@localhost bin]# jps
12075 Jps
11784 HMaster&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;初始化pinpoint库&lt;br/&gt;下载脚本：https://github.com/naver/pinpoint/blob/master/hbase/scripts/hbase-create.hbase&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;#进入到hbase的bin目录中
cd /app/install/hbase-1.2.12/bin
#执行脚本
./bin/hbase shell /app/install/pinpoint/hbase/scripts/hbase-create.hbase

# 执行完了以后，进入Hbase
./hbase shell

#进入后可以看到Hbase的版本，还有一些相关的信息
2019-10-12 16:18:28,074 WARN  [main] util.NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicable
HBase Shell; enter 'help&amp;lt;RETURN&amp;gt;' for list of supported commands.
Type &quot;exit&amp;lt;RETURN&amp;gt;&quot; to leave the HBase Shell
Version 1.2.12, r91d5ec4c4dcd10ceec984c6e663ea82acf353995, Sat Apr  6 15:27:28 CDT 2019

# 输入&quot;status 'detailed'&quot;可以查看刚才初始化的表，是否存在
hbase(main):002:0&amp;gt; status 'detailed'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也可以登录web，来查看HBase的数据是否初始化成功&lt;br/&gt;http://10.200.201.xxx:16010/master-status&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204119/201910/1204119-20191013000807755-867026080.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;安装pinpoint-collector&quot;&gt;安装pinpoint-collector&lt;/h3&gt;
&lt;p&gt;制作一个tomcat容器，端口号为8081&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#将pinpoint-collector的war包丢到Tomcat的webapps目录下
cp pinpoint-collector-1.8.5.war ../apache-tomcat-8081/webapps/

#将war包名字改一下
mv pinpoint-web-1.8.5.war pp-collector.war

#启动tomcat
./bin/startup.sh

# 查看日志，是否成功启动
tail -f ../logs/catalina.out

#如果hbase安装在别的机器下需要修改一下配置
cd /app/install/apache-tomcat-8081
vim webapps/pp-collector/WEB-INF/classes/hbase.properties
#修改hbase的ip和hbase所对应的端口号
hbase.client.host=10.200.201.xxx
hbase.client.port=2181&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;安装pinpoint-web&quot;&gt;安装pinpoint-web&lt;/h3&gt;
&lt;p&gt;解压一个tomcat容器，端口号为8080&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#将pinpoint-web放到tomcat的webapps容器中
cp pinpoint-web-1.8.5.war  ../apache-tomcat-8080/webapps/

#修改一下war包名
mv pinpoint-web-1.8.5.war pp-web.war

#启动tomcat
./bin/startup.sh

# 查看日志，是否成功启动
tail -f ../logs/catalina.out

#如果hbase安装在别的机器下需要修改一下配置
cd /app/install/apache-tomcat-8080
vim webapps/pp-web/WEB-INF/classes/hbase.properties

#修改hbase的ip和hbase所对应的端口号
hbase.client.host=10.200.201.xxx
hbase.client.port=2181&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后可以在浏览器中：http://10.200.201.xxx:8080/pp-web/&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204119/201910/1204119-20191013000822492-626272947.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;部署pinpoint-agent采集监控数据&quot;&gt;部署pinpoint-agent采集监控数据&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;传入pinpoint-agent包&lt;br/&gt;首先将pinpoint-agent-1.8.5.tar.gz传入到服务器10.200.201.yyy的/app/install/pinpoint-agent/中&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;然后执行tar -zxvf pinpoint-agent-1.8.5.tar.gz解压&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;配置pp-agent采集器&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;cd /app/install/pinpoint-agent
vim pinpoint.config

# 主要修改IP，只需要指定到安装pp-col的IP就行了，安装pp-col启动后，自动就开启了9994，9995，9996的端口了。这里就不需要操心了，如果有端口需求，要去pp-col的配置文件(&quot;pp-collector/webapps/ROOT/WEB-INF/classes/pinpoint-collector.properties&quot;)中，修改这些端口
profiler.collector.ip=10.200.201.xxx&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;如果监控的是tomcat&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;# 修改测试项目下的tomcat启动文件&quot;catalina.sh&quot;，修改这个只要是为了监控测试环境的Tomcat，增加探针
vi catalina.sh

# 第一行是pp-agent的jar包位置
# 第二行是agent的ID，这个ID是唯一的，我是用pp + 今天的日期命名的，只要与其他的项目的ID不重复就好了
# 第三行是采集项目的名字，这个名字可以随便取，只要各个项目不重复就好了
CATALINA_OPTS=&quot;$CATALINA_OPTS -javaagent:$AGENT_PATH/pinpoint-bootstrap-$VERSION.jar&quot;
CATALINA_OPTS=&quot;$CATALINA_OPTS -Dpinpoint.agentId=$AGENT_ID&quot;
CATALINA_OPTS=&quot;$CATALINA_OPTS -Dpinpoint.applicationName=$APPLICATION_NAME&quot;

# 配置好了。就可以开始监控了，我们启动测试用的Tomcat的服务器
cd /data/pp-test/bin/
./startup.sh
 
# 查看启动日志，确实Tomcat启动
tail -f ../logs/catalina.out&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;springboot包部署&lt;br/&gt;如果是jar包部署，直接在启动命令加启动参数：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;nohup java -javaagent:/app/install/pinpoint-agent/pinpoint-bootstrap-1.8.5.jar -Dpinpoint.agentId=$AGENT_ID -Dpinpoint.applicationName=$APPLICATION_NAME&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;功能设置&quot;&gt;功能设置&lt;/h2&gt;
&lt;h3 id=&quot;设置监控&quot;&gt;设置监控&lt;/h3&gt;
&lt;p&gt;如果按照上面的方法安装完了之后在进行监控设置的或者用户设置的时候会报错的：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204119/201910/1204119-20191013000837145-478275099.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以需要配置一下mysql：&lt;br/&gt;首先需要跑两个sql脚本：&lt;br/&gt;https://github.com/naver/pinpoint/blob/master/web/src/main/resources/sql/CreateTableStatement-mysql.sql&lt;br/&gt;https://github.com/naver/pinpoint/blob/master/web/src/main/resources/sql/SpringBatchJobRepositorySchema-mysql.sql&lt;/p&gt;
&lt;p&gt;然后进入到pinpoint-web的war所在的tomcat的容器中，修改配置文件：WEB-INF/classes/jdbc.properties&lt;br/&gt;并设值mysql的账号密码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;jdbc.url=jdbc:mysql://localhost:13306/pinpoint?characterEncoding=UTF-8
jdbc.username=admin
jdbc.password=admin&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以在application里面给不同的应用设置不同的提醒规则，具体的提醒规则如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204119/201910/1204119-20191013000848850-1104293135.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SLOW COUNT：发送到应用程序的慢速请求数超过配置的阈值时触发

SLOW RATE
   发送到应用程序的慢速请求的百分比（％）超过配置的阈值时触发

ERROR COUNT
   发送到应用程序的失败请求数超过配置的阈值时触发。

ERROR RATE
   发送到应用程序的失败请求的百分比（％）超过配置的阈值时触发。

TOTAL COUNT
   发送到应用程序的所有请求数超过配置的阈值时触发。

SLOW COUNT TO CALLEE
   当应用程序发送的慢速请求数超过配置的阈值时触发。 您必须在配置UI的“注释...”框中指定域或地址（IP，端口）    
     例如）www.naver.com，127.0.0.1:8080

SLOW RATE TO CALLEE
   当应用程序发送的慢速请求的百分比（％）超过配置的阈值时触发。 您必须在配置UI的“注释...”框中指定域或地址（IP，端口）
   ex) www.naver.com, 127.0.0.1:8080

ERROR COUNT TO CALLEE
   当应用程序发送的失败请求数超过配置的阈值时触发。 您必须在配置UI的“注释...”框中指定域或地址（IP，端口）
   ex) www.naver.com, 127.0.0.1:8080

ERROR RATE TO CALLEE
   当应用程序发送的失败请求的百分比（％）超过配置的阈值时触发。 您必须在配置UI的“注释...”框中指定域或地址（IP，端口）
   ex) www.naver.com, 127.0.0.1:8080

TOTAL COUNT TO CALLEE
   当应用程序发送的所有请求数超过配置的阈值时触发。 您必须在配置UI的“注释...”框中指定域或地址（IP，端口）
   ex) www.naver.com, 127.0.0.1:8080

HEAP USAGE RATE
   当应用程序的堆使用率（％）超过配置的阈值时触发。

JVM CPU USAGE RATE
   当应用程序的CPU使用率（％）超过配置的阈值时触发。

SYSTEM CPU USAGE RATE
   当应用程序的CPU使用率（％）超过配置的阈值时发送警报。

DATASOURCE CONNECTION USAGE RATE
   当应用程序的数据源连接使用率（％）超过配置的阈值时触发。
   
FILE DESCRIPTOR COUNT
   当打开的文件描述符的数量超过配置的阈值时，发送警报。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后需要在webapps/pp-web/WEB-INF/classes/batch.properties里面配置一下邮件服务器的信息：&lt;/p&gt;
&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;pinpoint.url= #pinpoint-web server url
alarm.mail.server.url= #smtp server address
alarm.mail.server.port= #smtp server port
alarm.mail.server.username= #username for smtp server authentication
alarm.mail.server.password= #password for smtp server authentication
alarm.mail.sender.address= #sender's email address

#例如
pinpoint.url=http://pinpoint.com
alarm.mail.server.url=stmp.server.com
alarm.mail.server.port=583
alarm.mail.server.username=pinpoint
alarm.mail.server.password=pinpoint
alarm.mail.sender.address=pinpoint_operator@pinpoint.com&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 12 Oct 2019 16:09:00 +0000</pubDate>
<dc:creator>luozhiyun</dc:creator>
<og:description>简介 pinpoint是开源在github上的一款APM监控工具，它是用Java编写的，用于大规模分布式系统监控。它对性能的影响最小（只增加约3％资源利用率），安装agent是无侵入式的。 各大APM</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/luozhiyun/p/11664534.html</dc:identifier>
</item>
<item>
<title>基于公共子序列的轨迹聚类(c#) - 麦比乌斯皇</title>
<link>http://www.cnblogs.com/hsxian/p/11664478.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hsxian/p/11664478.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;如今的世界中，想要研究人们的出行活动，可以利用智能手机或智能手环等个人设备生成的 GPS 数据进行研究。而在众多的研究方向中，出行的热点路线或者说经常出行的路线也比较受欢迎。采用热力图的方式对其进行研究具有许多优点。热力图给使用者的感觉就是特别直观，一眼便看出来哪些路径属于热迹（我们把热点路线，也就是重复度高的路线称为热迹）。如下图所示:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1214143/201910/1214143-20191012234018795-1830294094.jpg&quot;/&gt;（图片来自网上，侵删）&lt;/p&gt;
&lt;p&gt;从图中我们一眼便能够找出两条粗壮的热迹。这表示有某种物体经常沿着两条路线运动。但对于计算机来说，要从图中找出这两条热迹，并加以区分形成两条完整的路线可不是一件容易的事。所以我们只能直接从轨迹上入手。接下来将介绍利用公共子序列进行轨迹聚类的方法。&lt;/p&gt;
&lt;p&gt;该聚类方法的核心思想是相似的轨迹在地理空间中占有的位置基本一致，轨迹越相似其共有的位置占原轨迹空间的比重越大，并且随着我们划分轨迹的精度降低而提高。&lt;/p&gt;
&lt;h2 id=&quot;数据准备&quot;&gt;数据准备&lt;/h2&gt;
&lt;h3 id=&quot;gps-数据准备&quot;&gt;Gps 数据准备&lt;/h3&gt;
&lt;p&gt;研究轨迹聚类，最基本的要求就是拥有大量的轨迹数据。幸运的，我从网上的项目中找到了公开的 Gps 数据。为什么说是幸运的？在此之前，我曾写过一个 App，以期收集自己的出行轨迹进行研究。该应用的确达到了预期，但困难的是手机要开启 Gps 才能得到比较精准的轨迹数据，这显然提高了手机电量的要求。除此之外，收集众多的轨迹需要大量时间、上班族轨迹相对固定等一系列因素导致收集自己的轨迹计划夭折。而在网上找到的数据完全满足研究要求。这些数据来自于微软亚洲研究院的项目 &lt;a href=&quot;https://www.microsoft.com/en-us/research/project/geolife-building-social-networks-using-human-location-history/?from=http%3A%2F%2Fresearch.microsoft.com%2Fen-us%2Fprojects%2Fgeolife%2Fdefault.aspx&quot;&gt;&lt;strong&gt;Geolife&lt;/strong&gt;&lt;/a&gt;，是每个人都能够获取的。该数据以 plt 为文件后缀存储，但实际上就是普通的文本文件，并且除了前六行外就是 csv 格式的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1214143/201910/1214143-20191012234101471-1608525274.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;轨迹数据模型类&quot;&gt;轨迹数据模型类&lt;/h3&gt;
&lt;p&gt;这是本项目中用到的数据类模型&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;//轨迹数据点通用模型（以接口定义）
public interface IGeoInfoModel
{
    float Latitude { get; set; }
    float Longitude { get; set; }
}

//轨迹类
public class Trajectory
{
    public Guid Id { get; }
    public Trajectory()
    {
        Id = Guid.NewGuid();
    }
    public string Name { get; set; }
    public List&amp;lt;IGeoInfoModel&amp;gt; GeoPoints { get; set; }//轨迹点集
    public List&amp;lt;string&amp;gt; GeoCodes { get; set; }//轨迹编码集
    public Trajectory Parent { get; set; }//轨迹的父亲
    //轨迹的兄弟姐妹，该集合中的轨迹与该轨迹相似度极高（线程安全集合）
    public ConcurrentBag&amp;lt;Trajectory&amp;gt; Siblings { get; } = new ConcurrentBag&amp;lt;Trajectory&amp;gt;();
    //轨迹的后辈，该集合中的轨迹与该轨迹具有一定相似性，但低于兄弟姐妹（线程安全集合）
    public ConcurrentBag&amp;lt;Trajectory&amp;gt; Children { get; } = new ConcurrentBag&amp;lt;Trajectory&amp;gt;();
    public float MinLat =&amp;gt; GeoPoints.Min(t =&amp;gt; t.Latitude);
    public float MinLon =&amp;gt; GeoPoints.Min(t =&amp;gt; t.Longitude);
    public float MaxLat =&amp;gt; GeoPoints.Max(t =&amp;gt; t.Latitude);
    public float MaxLon =&amp;gt; GeoPoints.Max(t =&amp;gt; t.Longitude);
    public int Level { get; set; }//轨迹在族谱中的代数/层数
    public string LevelTag { get; set; }//代数标签，用于打印
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;轨迹序列产生轨迹的低分辨率低精度描述&quot;&gt;轨迹序列产生（轨迹的低分辨率/低精度描述）&lt;/h2&gt;
&lt;p&gt;要找轨迹间的公共子序列，首先得有可以描述轨迹的序列的方法。该序列具有比原始轨迹低的精度，但基本可以描述一条轨迹的空间位置。下面介绍两种该项目中用到的编码方法。&lt;/p&gt;
&lt;h3 id=&quot;保留高位小数法&quot;&gt;保留高位小数法&lt;/h3&gt;
&lt;p&gt;最简单的就是仅保留经纬度的高位小数来进行编码。这种方式的产生的数据的精度调节有限，但也能满足一般需求。以坐标（1.2222，33.44444）来说保留三位小数后可得“1.222_33.444”,中间添加下划线是保留反解码的需求。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var digits = 3;
var dig = $&quot;F{digits}&quot;;
var code = $&quot;{t.Latitude.ToString(dig)}_{t.Longitude.ToString(dig)}&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;geohash-法&quot;&gt;GeoHash 法&lt;/h3&gt;
&lt;p&gt;GeoHash 是公认的计算经纬度编码的有效方法，并且精度调节能力较强。读者可以从这里进行了解&lt;a href=&quot;https://blog.csdn.net/u011497262/article/details/81210634&quot;&gt;Geohash 精度和原理&lt;/a&gt;。除此之外，GeoHash 可以得到较短的字符串，还是以坐标（1.2222，33.44444）来说，得到 7 位的字符编码“s8pycn3”。该hash码精度和直接取上面取三位小数的方式上精度接近，但字符长却缩减了 5 位。这利于高效的查找公共子序列。在 c#中我们直接 nuget 命令添加 nupkg 包&lt;a href=&quot;https://www.nuget.org/packages/NGeoHash.DotNetCore/&quot;&gt;NGeoHash.DotNetCore&lt;/a&gt;即可获得 GeoHash 的计算方法。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var code = GeoHash.Encode(1.2222,33.44444, 7);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;子序列的最终形式&quot;&gt;子序列的最终形式&lt;/h3&gt;
&lt;p&gt;上述两种方法皆可得到描述轨迹的序列。对于我们的公共子序列聚类来说，我们使用 GeoHash 得到轨迹序列能够得到较高的效率（花费时间基本为保留高位小数法的 60%）。此外需要注意的就是：1.该聚类方法并不关心轨迹点的先后顺序，也就是时间无关性；2.产生的轨迹序列会有重复值，但我们只关心轨迹是否在某一空间，而不关心在某一空间出现的次数，也就是重复无用性。基于以上两点，初步产生的轨迹序列需要去重，这对于查找公共子序列来说也是一种效率优化。&lt;/p&gt;
&lt;p&gt;这对于 c#来说是极其简单的:&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;//并行迭代轨迹获得轨迹序列
Parallel.ForEach(tracks, t =&amp;gt;
{
//   t.GeoCodes = GeoHelper.GetGeoCodes(t.GeoPoints, 3).ToList();//保留高位小数法
     t.GeoCodes = t.GeoPoints
            .Select(tt =&amp;gt; GeoHash.Encode(tt.Latitude, tt.Longitude, 7))
            .Distinct()
            .ToList();//GeoHash法
});&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;轨迹相似度的计算&quot;&gt;轨迹相似度的计算&lt;/h2&gt;
&lt;p&gt;在得到每条轨迹的序列基础上，我们可以进行轨迹的相似度计算。而轨迹相似度可以归结为轨迹序列间的公共子序列占原始序列的比率。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;//array为轨迹列表，ibf为索引1，jaf为索引2，计算GeoCodes的交集
var intersect = array[ibf].GeoCodes.Intersect(array[jaf].GeoCodes).ToList();
//公共子序列的个数转为浮点型，避免下一步计算为整形时结果直接归零
var intersectCount = (float) intersect.Count;
//公共轨迹（子序列）的与轨迹1的相似度
var rateIbf = intersectCount / array[ibf].GeoCodes.Count;
//公共轨迹（子序列）的与轨迹2的相似度
var rateJaf = intersectCount / array[jaf].GeoCodes.Count;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;轨迹族谱的生成&quot;&gt;轨迹族谱的生成&lt;/h2&gt;
&lt;p&gt;得到轨迹相似度后，我们定义了两个阈值：一个为兄弟姐妹相似度&lt;strong&gt;scaleSimilar&lt;/strong&gt;，一个为后代相似度&lt;strong&gt;scaleBlood&lt;/strong&gt;。注意，兄弟姐妹相似度总是比后代相似度的值要大。根据这两个阈值，我们可以进行轨迹族谱的生成。如果相似度&lt;code&gt;rateIbf&lt;/code&gt;和&lt;code&gt;rateJaf&lt;/code&gt;都大于&lt;code&gt;scaleSimilar&lt;/code&gt;，说明两条轨迹极为相似，被定义为兄弟姐妹。如果都大于&lt;code&gt;scaleBlood&lt;/code&gt;，并且&lt;code&gt;rateIbf&lt;/code&gt;大于&lt;code&gt;rateJaf&lt;/code&gt;，则轨迹 2 是 1 的后代，反之 1 是 2 的后代。&lt;/p&gt;
&lt;p&gt;以下是这个算法的核心：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;//构建轨迹树（族谱）
public IEnumerable&amp;lt;Trajectory&amp;gt; BuildClusterTree(IEnumerable&amp;lt;Trajectory&amp;gt; trajectories, float scaleSimilar = 0.8f,
    float scaleBlood = 0.6f)
{
    var array = trajectories.OrderByDescending(t =&amp;gt; t.GeoCodes.Count).ToArray();
    for (var ibf = 0; ibf &amp;lt; array.Length; ibf++)
    {
        Parallel.For(ibf + 1, array.Length, jaf =&amp;gt;
        {
            if (array[jaf].Level == 1) return;
            var intersect = array[ibf].GeoCodes.Intersect(array[jaf].GeoCodes).ToList();
            var intersectCount = (float) intersect.Count;
            var rateIbf = intersectCount / array[ibf].GeoCodes.Count;
            var rateJaf = intersectCount / array[jaf].GeoCodes.Count;
            if (rateIbf &amp;gt;= scaleSimilar &amp;amp;&amp;amp; rateJaf &amp;gt;= scaleSimilar)
            {
                array[jaf].Level = 1;
                array[ibf].Siblings.Add(array[jaf]);
                array[jaf].Siblings.Add(array[ibf]);
            }
            else if (rateJaf &amp;gt; rateIbf &amp;amp;&amp;amp; rateIbf &amp;gt;= scaleBlood)
            {
                array[jaf].Level = 1;
                array[jaf].Parent = array[ibf];
                array[ibf].Children.Add(array[jaf]);
            }
            else if (rateIbf &amp;gt; rateJaf &amp;amp;&amp;amp; rateJaf &amp;gt;= scaleBlood)
            {
                array[ibf].Level = 1;
                array[ibf].Parent = array[jaf];
                array[jaf].Children.Add(array[ibf]);
            }
        });
    }

    var root = array.Where(t =&amp;gt; t.Level == 0 ).ToList();
    SetClusterTreeLevelInfo(root);
    return root;
}
//设置代数及标签信息
private void SetClusterTreeLevelInfo(IEnumerable&amp;lt;Trajectory&amp;gt; tree,int level = 0, string levelTag = &quot;&quot;)
{
    Parallel.For(0, tree.Count(), i =&amp;gt;
    {
        var node = tree.ElementAt(i);
        node.Level = level;
        node.LevelTag = $&quot;{levelTag}{i}&quot;;
        for (var j = 0; j &amp;lt; node.Siblings.Count; j++)
        {
            var sib = node.Siblings.ElementAt(j);
            sib.Level = level;
            sib.LevelTag = $&quot;{node.LevelTag}__{j}_sim&quot;;
        }
        SetClusterTreeLevelInfo(node.Children, level + 1, $&quot;{node.LevelTag}_&quot;);
    });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;结果展示及说明&quot;&gt;结果展示及说明&lt;/h2&gt;
&lt;p&gt;我们直接上最终的轨迹族谱图的展示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1214143/201910/1214143-20191012234148285-1325794867.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;读者放大后应该能够看清图片的文件名，文件名是代数标签。以“3.png”和“3_0.png”来说，“3.png”是“3_0.png”的父亲。对应的，后者是前者的孩子（所有轨迹对于都是自适应固定大小的图片画的，所以缩放比例和整体偏移会导致看起来有差别。读者仔细观察能够发现 3_0 只是 3 的左下角一部分）。而对于“3_0_4_8.png”和“3_0_4_8__sim_0.png”来说则互为兄弟姐妹（缩略图与自适应的确影响了结果的查看）。&lt;/p&gt;
&lt;p&gt;此外，我们能够看出第 3 和第 6 是两个大家族。如果利用所有轨迹的数据生成热力图，那么 3 族和 6 族所经过的地方热力值相对来说要高很多。把一个大家族的所有成员轨迹叠加后可以得到我们想要的热迹。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;该算法如果不用并行计算是一个时间复杂度为：O(n^2)的算法“n（n+1）/2”。而改为并行计算后，效率有很大提升（由于直接采用并行计算，不知道提升了多少）。示例中71条轨迹生成族谱树仅需25毫秒左右，而1988条轨迹需要7.5秒左右。从效率和结果上来说都达到了令人满意的程度。另外，该项目已经上传github，访问请点击&lt;a href=&quot;https://github.com/hsxian/QianMo&quot;&gt;QianMo&lt;/a&gt;，欢迎大家提出修改意见。&lt;/p&gt;
</description>
<pubDate>Sat, 12 Oct 2019 15:44:00 +0000</pubDate>
<dc:creator>麦比乌斯皇</dc:creator>
<og:description>前言 如今的世界中，想要研究人们的出行活动，可以利用智能手机或智能手环等个人设备生成的 GPS 数据进行研究。而在众多的研究方向中，出行的热点路线或者说经常出行的路线也比较受欢迎。采用热力图的方式对其</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hsxian/p/11664478.html</dc:identifier>
</item>
<item>
<title>分享8点超级有用的Python编程建议 - samlam</title>
<link>http://www.cnblogs.com/samshare/p/11664329.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/samshare/p/11664329.html</guid>
<description>&lt;p&gt;我们在用Python进行机器学习建模项目的时候，每个人都会有自己的一套项目文件管理的习惯，我自己也有一套方法，是自己曾经踩过的坑总结出来的，现在在这里分享一下给大家，希望多少有些地方可以给大家借鉴。&lt;/p&gt;
&lt;h2 id=&quot;先睹为快&quot;&gt;🚗 先睹为快&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;项目文件事先做好归档&lt;/li&gt;
&lt;li&gt;永远不要手动修改源数据并且做好备份&lt;/li&gt;
&lt;li&gt;做好路径的正确配置&lt;/li&gt;
&lt;li&gt;代码必要的地方做好备注与说明&lt;/li&gt;
&lt;li&gt;加速你的Python循环代码&lt;/li&gt;
&lt;li&gt;可视化你的循环代码进度&lt;/li&gt;
&lt;li&gt;使用高效的异常捕获工具&lt;/li&gt;
&lt;li&gt;要多考虑代码健壮性&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;项目文件事先做好归档&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;每次开始一个新工作的时候，以前的我总是贪图方便，Code、Data、文档都集中放在一个文件夹内，看起来很乱，一度让回溯过程十分痛苦，或者是换了部电脑，文件全都运行不行了，需要自行修改路径，十分痛苦。&lt;/p&gt;
&lt;p&gt;经过自己一番探索，大家可以大致将项目分成几个子文件夹，code放在主文件夹里：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/812632/201910/812632-20191012225331657-1928999195.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;永远不要手动修改源数据并且做好备份&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;我们需要对源数据进行好备份，方便我们下一次进行回溯，可以进行下一步的操作或者是对中间步骤的修改，而且，对代码等其他文件也是需要做好备份的，以免出现意外丢失。&lt;/p&gt;
&lt;p&gt;这里来自&lt;em&gt;良许Linux&lt;/em&gt;的一篇文章，推荐了4个工具：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Git版本控制系统&lt;/li&gt;
&lt;li&gt;Rsync文件备份&lt;/li&gt;
&lt;li&gt;Dropbox云存储&lt;/li&gt;
&lt;li&gt;Time Machine时光机器&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;更多的工具介绍和使用我这边就不展开，大家可以去自行了解呗。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;做好路径的正确配置&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;很多同学在写路径的时候都很喜欢直接用绝对路径，虽然一般情况下不会有什么问题，但如果代码共享给其他人学习或者运行的时候，问题就来了，很多情况下都不能直接跑通，&lt;/p&gt;
&lt;p&gt;这里建议：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用相对路径：脚本位于主目录下，其他资源（如数据、第三方包等）在其同级或低级目录下，如 ./data/processed/test1.csv&lt;/li&gt;
&lt;li&gt;全局路径配置变量：&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 设置主目录
HOME_PATH = r'E:\ML\190615- PROJECT1'

# 读取数据
data = open(HOME_PATH+'/data/processed/test1.csv') 
data = pd.read_csv(data)
data.head()&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;代码必要的地方做好备注与说明&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;这个我相信大多数人都感同身受了，不信？拿回一个月前自己写的代码看看吧，看一下能看懂多少（如果没有做好备注说明的话）&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;加速你的Python循环代码&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;这里推荐云哥的一篇文章：24式加速你的python：&lt;/p&gt;
&lt;p&gt;https://mp.weixin.qq.com/s/8bWm4NjHAam-fIeC4a29cA&lt;/p&gt;
&lt;p&gt;收藏起来，多看多几次，养成好习惯呗，这样子你写代码才会越来越快～&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;可视化你的循环代码进度&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;这里介绍一个Python库，tqdm，先安装一下：&lt;code&gt;pip install tqdm&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这个是一个可以显示循环进度的库，有了它就可以更加运筹帷幄了。&lt;/p&gt;
&lt;p&gt;大家可以看下面的例子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/812632/201910/812632-20191012225331957-477308799.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;使用高效的异常捕获工具&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;异常bug定位，以前的我经常也是一条print()函数走到底，虽然说也没什么问题，但效率上还是会比较慢，后来发现了一个叫PySnooper的装饰器，仿佛发现了新大陆。&lt;/p&gt;
&lt;p&gt;我们一般debug，都是在我们可能觉得会有问题的地方，去打印输出，看下实际输出了什么，然后思考问题所在，这需要我们去改code，非常细致地改，相比较直接加个装饰器，是十分麻烦的。&lt;/p&gt;
&lt;p&gt;大家可以看看Example：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import pysnooper

@pysnooper.snoop('./log/file.log')
def number_to_bits(number):
    if number:
        bits = []
        while number:
            number, remainder = divmod(number, 2)
            bits.insert(0, remainder)
        return bits
    else:
        return [0]

number_to_bits(6)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们把函数每一步的输出都保存为file.log，我们可以直接去看到底哪里出了问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/812632/201910/812632-20191012225332742-868336303.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;📚 项目地址：https://github.com/cool-RR/pysnooper&lt;br/&gt;https://mp.weixin.qq.com/s/zqFPVfmPa-qsPUibzQdcjQ&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;要多考虑代码健壮性&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;何为代码的健壮性,顾名思义，就是可以抵挡得住各种异常场景的测试，异常处理工作由“捕获”和“抛出”两部分组成。“捕获”指的是使用 try ... except 包裹特定语句，妥当的完成错误流程处理。而恰当的使用 raise 主动“抛出”异常，更是优雅代码里必不可少的组成部分，下面总结几点供大家参考：&lt;/p&gt;
&lt;p&gt;1）知道要传入的参数是什么,类型,个数....(异常处理,逻辑判断)&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def add(a, b):
  if isinstance(a, int) and isinstance(b, int):
      return a+b
  else:
      return '参数类型错误'

print(add(1, 2))
print(add(1, 'a'))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2）只做最精准的异常捕获&lt;/p&gt;
&lt;p&gt;我们有的时候想着让脚本work才是王道，所以不管三七二十一就搞一个大大的try...except把整块代码包裹起来，但这样很容易把原本该被抛出的 AttibuteError 吞噬了。从而给我们的 debug 过程增加了不必要的麻烦。&lt;/p&gt;
&lt;p&gt;所以，我们永远只捕获那些可能会抛出异常的语句块，而且尽量只捕获精确的异常类型，而不是模糊的 Exception。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from requests.exceptions import RequestException

def save_website_title(url, filename):
    try:
        resp = requests.get(url)
    except RequestException as e:
        print(f'save failed: unable to get page content: {e}')
        return False
        
# 这段正则操作本身就是不应该抛出异常的，所以我们没必要使用 try 语句块
# 假如 group 被误打成了 grop 也没关系，程序马上就会通过 AttributeError 来
# 告诉我们。
    obj = re.search(r'&amp;lt;title&amp;gt;(.*)&amp;lt;/title&amp;gt;', resp.text)
    if not obj:
    print('save failed: title tag not found in page content')
    return False
    title = obj.group(1)

    try:
    with open(filename, 'w') as fp:
        fp.write(title)
    except IOError as e:
    print(f'save failed: unable to write to file {filename}: {e}')
    return False
    else:
    return True&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3）异常处理不应该喧宾夺主&lt;/p&gt;
&lt;p&gt;像上一条说到的异常捕获要精准，但如果每一个都很精准的话，其实我们的代码里就会有很多try...except语句块，以至于扰乱核心代码，代码整体阅读性。&lt;/p&gt;
&lt;p&gt;这里，我们可以利用上下文管理器来改善我们的异常处理流程，简化重复的异常处理逻辑。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class raise_api_error:
    &quot;&quot;&quot;captures specified exception and raise ApiErrorCode instead
    :raises: AttributeError if code_name is not valid
    &quot;&quot;&quot;
    def __init__(self, captures, code_name):
    self.captures = captures
    self.code = getattr(error_codes, code_name)

    def __enter__(self):
    # 该方法将在进入上下文时调用
    return self

    def __exit__(self, exc_type, exc_val, exc_tb):
    # 该方法将在退出上下文时调用
    # exc_type, exc_val, exc_tb 分别表示该上下文内抛出的
    # 异常类型、异常值、错误栈
    if exc_type is None:
        return False

    if exc_type == self.captures:
        raise self.code from exc_val
    return False&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上面的代码里，我们定义了一个名为 raise_api_error 的上下文管理器，它在进入上下文时什么也不做。但是在退出上下文时，会判断当前上下文中是否抛出了类型为 self.captures 的异常，如果有，就用 APIErrorCode 异常类替代它。&lt;/p&gt;
&lt;p&gt;使用上下文管理器后，简洁的代码如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def upload_avatar(request):
    &quot;&quot;&quot;用户上传新头像&quot;&quot;&quot;
    with raise_api_error(KeyError, 'AVATAR_FILE_NOT_PROVIDED'):
    avatar_file = request.FILES['avatar']
        
    with raise_api_error(ResizeAvatarError, 'AVATAR_FILE_INVALID'),\
        raise_api_error(FileTooLargeError, 'AVATAR_FILE_TOO_LARGE'):
      resized_avatar_file = resize_avatar(avatar_file)

    with raise_api_error(Exception, 'INTERNAL_SERVER_ERROR'):
    request.user.avatar = resized_avatar_file
    request.user.save()
    return HttpResponse({})&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;reference&quot;&gt;📖 Reference&lt;/h2&gt;
</description>
<pubDate>Sat, 12 Oct 2019 14:54:00 +0000</pubDate>
<dc:creator>samlam</dc:creator>
<og:description>我们在用Python进行机器学习建模项目的时候，每个人都会有自己的一套项目文件管理的习惯，我自己也有一套方法，是自己曾经踩过的坑总结出来的，现在在这里分享一下给大家，希望多少有些地方可以给大家借鉴。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/samshare/p/11664329.html</dc:identifier>
</item>
</channel>
</rss>