<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>恕我直言你可能真的不会java第12篇-如何使用Stream API对Map类型元素排序 - 字母哥博客</title>
<link>http://www.cnblogs.com/zimug/p/13228199.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zimug/p/13228199.html</guid>
<description>&lt;p&gt;在这篇文章中，您将学习&lt;strong&gt;如何使用Java对Map进行排序&lt;/strong&gt;。前几日有位朋友面试遇到了这个问题，看似很简单的问题，但是如果不仔细研究一下也是很容易让人懵圈的面试题。所以我决定写这样一篇文章。在Java中，有多种方法可以对Map进行排序，但是我们将重点介绍Java 8 Stream，这是实现目标的一种非常优雅的方法。&lt;/p&gt;
&lt;h2 id=&quot;一、什么是java-8-stream&quot;&gt;一、什么是Java 8 Stream&lt;/h2&gt;
&lt;p&gt;使用Java 8 Streams，我们可以按键和按值对映射进行排序。下面是它的工作原理：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202007/1815316-20200703081137218-2072132389.jpg&quot; alt=&quot;Java Stream函数式编程？用过都说好，案例图文详解送给你&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;将Map或List等集合类对象转换为Stream对象&lt;/li&gt;
&lt;li&gt;使用Streams的&lt;code&gt;sorted()&lt;/code&gt;方法对其进行排序&lt;/li&gt;
&lt;li&gt;最终将其返回为&lt;code&gt;LinkedHashMap&lt;/code&gt;（可以保留排序顺序）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;code&gt;sorted()&lt;/code&gt;方法以a&lt;code&gt;Comparator&lt;/code&gt;作为参数，从而可以按任何类型的值对Map进行排序。如果对Comparator不熟悉，可以看本号前几天的文章，有一篇文章专门介绍了使用Comparator对List进行排序。&lt;/p&gt;
&lt;h2 id=&quot;二、学习一下hashmap的merge函数&quot;&gt;二、学习一下HashMap的merge()函数&lt;/h2&gt;
&lt;p&gt;在学习Map排序之前，有必要讲一下HashMap的merge()函数，该函数应用场景就是当Key重复的时候，如何处理Map的元素值。这个函数有三个参数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;参数一：向map里面put的键&lt;/li&gt;
&lt;li&gt;参数二：向map里面put的值&lt;/li&gt;
&lt;li&gt;参数三：如果键发生重复，如何处理值。可以是一个函数，也可以写成lambda表达式。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;        String k = &quot;key&quot;;
        HashMap&amp;lt;String, Integer&amp;gt; map = new HashMap&amp;lt;String, Integer&amp;gt;() {{
            put(k, 1);
        }};
        map.merge(k, 2, (oldVal, newVal) -&amp;gt; oldVal + newVal);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看上面一段代码，我们首先创建了一个HashMap，并往里面放入了一个键值为k:1的元素。当我们调用merge函数，往map里面放入k:2键值对的时候，k键发生重复，就执行后面的lambda表达式。表达式的含义是：返回旧值oldVal加上新值newVal(1+2)，现在map里面只有一项元素那就是k:3。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;其实lambda表达式很简单：表示匿名函数，箭头左侧是参数，箭头右侧是函数体。函数的参数类型和返回值，由代码上下文来确定。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;三、按map的键排序&quot;&gt;三、按Map的键排序&lt;/h2&gt;
&lt;p&gt;下面一个例子使用Java 8 Stream按Map的键进行排序：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 创建一个Map，并填入数据
Map&amp;lt;String, Integer&amp;gt; codes = new HashMap&amp;lt;&amp;gt;();
codes.put(&quot;United States&quot;, 1);
codes.put(&quot;Germany&quot;, 49);
codes.put(&quot;France&quot;, 33);
codes.put(&quot;China&quot;, 86);
codes.put(&quot;Pakistan&quot;, 92);

// 按照Map的键进行排序
Map&amp;lt;String, Integer&amp;gt; sortedMap = codes.entrySet().stream()    
        .sorted(Map.Entry.comparingByKey())
        .collect(
                Collectors.toMap(
                    Map.Entry::getKey, 
                    Map.Entry::getValue,
                    (oldVal, newVal) -&amp;gt; oldVal,
                    LinkedHashMap::new
                )
        );

// 将排序后的Map打印
sortedMap.entrySet().forEach(System.out::println);

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看上文中第二段代码：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先使用entrySet().stream() 将Map类型转换为Stream流类型。&lt;/li&gt;
&lt;li&gt;然后使用sorted方法排序，排序的依据是Map.Entry.comparingByKey()，也就是按照Map的键排序&lt;/li&gt;
&lt;li&gt;最后用collect方法将Stream流转成LinkedHashMap。 其他参数都好说，重点看第三个参数，就是一个merge规则的lambda表达式，与merge方法的第三个参数的用法一致。由于本例中没有重复的key，所以新值旧值随便返回一个即可。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上面的程序将在控制台上打印以下内容，键（国家/地区名称）以自然字母顺序排序：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-plaintext&quot;&gt;China=86
France=33
Germany=49
Pakistan=92
United States=1
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;请注意&lt;/strong&gt;使用&lt;code&gt;LinkedHashMap&lt;/code&gt;来存储排序的结果以保持顺序。默认情况下，&lt;code&gt;Collectors.toMap()&lt;/code&gt;返回&lt;code&gt;HashMap&lt;/code&gt;。&lt;code&gt;HashMap&lt;/code&gt;不能保证元素的顺序。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果希望按照键进行逆向排序，加入下图中红色部分代码即可。&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/zimug/p/images/screenshot_1571800964528.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;四、按map的值排序&quot;&gt;四、按Map的值排序&lt;/h2&gt;
&lt;p&gt;当然，您也可以使用Stream API按其值对Map进行排序：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Map&amp;lt;String, Integer&amp;gt; sortedMap2 = codes.entrySet().stream()
        .sorted(Map.Entry.comparingByValue())
        .collect(Collectors.toMap(
                Map.Entry::getKey,
                Map.Entry::getValue,
                (oldVal, newVal) -&amp;gt; oldVal,
                LinkedHashMap::new));

sortedMap2.entrySet().forEach(System.out::println);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是显示Map按值排序的输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-plaintext&quot;&gt;United States=1
France=33
Germany=49
China=86
Pakistan=92
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;五、使用treemap按键排序&quot;&gt;五、使用TreeMap按键排序&lt;/h2&gt;
&lt;p&gt;大家可能都知道TreeMap内的元素是有顺序的，所以利用TreeMap排序也是可取的一种方法。您需要做的就是创建一个&lt;code&gt;TreeMap&lt;/code&gt;对象，并将数据从&lt;code&gt;HashMap&lt;/code&gt;put到&lt;code&gt;TreeMap&lt;/code&gt;中，非常简单：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 将 `HashMap` 转为 `TreeMap`
Map&amp;lt;String, Integer&amp;gt; sorted = new TreeMap&amp;lt;&amp;gt;(codes);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-plaintext&quot;&gt;China=86
France=33
Germany=49
Pakistan=92
United States=1
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上所示，键（国家/地区名称）以自然字母顺序排序。&lt;/p&gt;
&lt;h2 id=&quot;欢迎关注我的博客，里面有很多精品合集&quot;&gt;欢迎关注我的博客，里面有很多精品合集&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;本文转载注明出处（必须带连接，不能只转文字）：&lt;a href=&quot;http://www.zimug.com&quot;&gt;字母哥博客&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;觉得对您有帮助的话，帮我点赞、分享！您的支持是我不竭的创作动力！&lt;/strong&gt; 。另外，笔者最近一段时间输出了如下的精品内容，期待您的关注。&lt;/p&gt;
</description>
<pubDate>Fri, 03 Jul 2020 00:12:00 +0000</pubDate>
<dc:creator>字母哥博客</dc:creator>
<og:description>在这篇文章中，您将学习如何使用Java对Map进行排序。前几日有位朋友面试遇到了这个问题，看似很简单的问题，但是如果不仔细研究一下也是很容易让人懵圈的面试题。所以我决定写这样一篇文章。在Java中，有</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zimug/p/13228199.html</dc:identifier>
</item>
<item>
<title>Flutter —快速开发的IDE快捷方式 - 老孟Flutter</title>
<link>http://www.cnblogs.com/mengqd/p/13228179.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mengqd/p/13228179.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200703074336314-13431972.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6.7474048442907&quot;&gt;
&lt;p&gt;&lt;strong&gt;老孟导读&lt;/strong&gt;：这是老孟翻译的精品文章，文章所有权归原作者所有。&lt;/p&gt;
&lt;p&gt;欢迎加入老孟Flutter交流群，每周翻译2-3篇付费文章，精彩不容错过。&lt;/p&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;https://medium.com/flutter-community/flutter-ide-shortcuts-for-faster-development-2ef45c51085b&quot;&gt;https://medium.com/flutter-community/flutter-ide-shortcuts-for-faster-development-2ef45c51085b&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200703074336951-147295913.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果您是一个 Flutter 初学者，那么您一定厌恶嵌套结构，在代码中添加或删除一个小部件，或者找到一个小部件在何处结束、何处开始是多么困难。 然后，您需要花费一整天的时间来匹配左括号与右括号。 但您并不孤单，因为我们都是这么走过来的。 我们花了一些时间来找出捷径，也许您不必再找出这些捷径，因为我已经做了这些； 并且我整理了所有这些捷径，这些捷径可以在Flutter中更快，更流畅地进行开发。&lt;/p&gt;
&lt;p&gt;PS。所有这些快捷方式均适用于Windows中的Android Studio和IntelliJ。您来自iOS吗？也许&lt;a href=&quot;https://medium.com/coding-with-flutter/flutter-my-favourite-keyboard-shortcuts-63f6474afc8c&quot;&gt;这篇文章&lt;/a&gt;会有所帮助。&lt;/p&gt;
&lt;h4 id=&quot;创建一个新的stateless-or-stateful组件&quot;&gt;创建一个新的Stateless or Stateful组件&lt;/h4&gt;
&lt;p&gt;你猜怎么了？您不必手动编写窗口小部件类并覆盖构建功能。 IDE可以为您做到！&lt;/p&gt;
&lt;p&gt;只需输入stless即可创建一个无状态小部件，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200703074337536-631997724.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;或输入stful创建有状态的小部件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200703074338348-1719793274.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果您已经创建了一个无状态小部件并添加了许多子级，但是却意识到您最终将需要一个State怎么办？您是否应该制作一个新的StatefulWidget，然后手动将所有代码转移到该代码上？不用了！&lt;/p&gt;
&lt;p&gt;您可以将光标放在StatelessWidget上，按Alt + Enter并单击Convert to StatefulWidget。将自动为您创建所有样板代码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200703074339865-1746575872.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;使用alt--enter可以执行更多神奇的事情&quot;&gt;使用Alt + Enter可以执行更多神奇的事情&lt;/h4&gt;
&lt;p&gt;Alt + Enter是用于在Flutter中加快开发速度的魔杖。您可以单击任何窗口小部件，按Alt + Enter并查看该特定窗口小部件具有哪些选项。&lt;/p&gt;
&lt;h5 id=&quot;给组件添加padding&quot;&gt;给组件添加Padding&lt;/h5&gt;
&lt;p&gt;假设您有一个不是容器的窗口小部件，因此它没有padding属性。您想填充一些内容，但担心会弄乱您的小部件结构。使用我们的魔术棒，您可以添加填充而不会弄乱任何东西：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200703074340542-1557246452.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;只需在需要填充的小部件上按Alt + Enter，然后单击“add padding”即可。现在您可以将默认填充修改为所需的填充。&lt;/p&gt;
&lt;h4 id=&quot;center-组件&quot;&gt;Center 组件&lt;/h4&gt;
&lt;p&gt;这没什么特别的。它只是将小部件放在可用空间的中心。这在列或行内不起作用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200703074340854-1266303925.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;wrap-with-a-container-column-row-or-any-other-widget&quot;&gt;Wrap with a Container, Column, Row or any other Widget&lt;/h4&gt;
&lt;p&gt;您可以使用相同的方法用Container包装小部件。因此，现在，newContainer成为您的小部件的父级。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200703074341161-92111136.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;或者，您甚至可以单击一下就可以用“列”或“行”包装多个小部件！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200703074341399-1156690439.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;或使用其他任何小部件包装它们：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200703074341607-1541906729.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;你甚至使用 StreamBuilder 包裹子组件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200703074342008-640844836.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;不喜欢一个组件？删除它&quot;&gt;不喜欢一个组件？删除它&lt;/h4&gt;
&lt;p&gt;是的，删除小部件就像添加一个新部件一样容易。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200703074342402-60758165.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;轻松复制粘贴或剪切粘贴一行代码&quot;&gt;轻松复制粘贴或剪切粘贴一行代码&lt;/h4&gt;
&lt;p&gt;您可以轻松地剪切/复制一行代码，只需将光标保持在该行的末尾，然后按Ctrl + X或Ctrl + C的方式粘贴并像通常一样粘贴（Ctrl + V）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200703074342651-1964827881.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Ctrl+X&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200703074342879-898527527.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Ctrl + C&lt;/p&gt;
&lt;h4 id=&quot;查看小部件的源代码&quot;&gt;查看小部件的源代码&lt;/h4&gt;
&lt;p&gt;那是关于开源框架的最好的事情。 如果您想知道令人惊叹的小部件或类的幕后情况，只需将光标放在其上，然后按Ctrl + B即可。 该链接将充当链接，直接带您Widget的源代码，您可以在其中阅读有关它的所有内容。 Flutter还使用注释来解释其许多代码，从而提供了很好的文档。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200703074343395-619631414.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;在不离开文件或标签的情况下检查小部件的属性&quot;&gt;在不离开文件或标签的情况下检查小部件的属性&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200703074344389-731951181.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;快速选择整个小部件&quot;&gt;快速选择整个小部件&lt;/h4&gt;
&lt;p&gt;很多时候，我们需要提取/删除整个小部件，然后尝试手动选择它们：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200703074344848-2057431989.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果它是一个非常大的窗口小部件，那么弄清楚哪个窗口小括号属于哪个窗口小部件可能会造成混乱，并且我们不想弄乱我们的整个结构。&lt;/p&gt;
&lt;p&gt;在这样的时候，我喜欢使用这个超级有用的快捷方式。&lt;/p&gt;
&lt;p&gt;只需单击要提取的小部件，然后按Ctrl + W。为您选择了整个小部件，而您的光标没有移动一英寸。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200703074345466-1613776615.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;格式化代码&quot;&gt;格式化代码&lt;/h4&gt;
&lt;p&gt;有时您的代码只会一团糟。有点像这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200703074345764-1005411882.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于像我这样的人来说，有些OCD会查看没有适当缩进的代码，这可能是一场噩梦。&lt;/p&gt;
&lt;p&gt;现在，大多数IDE都具有此功能（尽管可能不是相同的组合键）。只需按Ctrl + Alt + L即可修复缩进并重新格式化代码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200703074346025-1895183576.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;查看您的ui大纲&quot;&gt;查看您的UI大纲&lt;/h4&gt;
&lt;p&gt;我们的大多数小部件的树上只有一个孩子。他们有自己的孩子的树木，还有更多的孩子。如果您的Widget的子级嵌套少至4个深度，那么仅通过滚动浏览就很难理解代码的结构。幸运的是，我们有Flutter Outline来拯救我们！&lt;/p&gt;
&lt;p&gt;您可以在IDE的最右侧找到Flutter Outline；它是垂直标签之一，位于Flutter Inspector上方。当您打开它时，它看起来像这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200703074346265-246734830.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在，您可以清楚地看到哪个窗口小部件，它们在用户界面中的排列方式以及哪些窗口小部件具有其他子窗口小部件。十分简单！&lt;/p&gt;
&lt;h4 id=&quot;将代码提取到方法中&quot;&gt;将代码提取到方法中&lt;/h4&gt;
&lt;p&gt;Flutter Outline是一个非常有用的工具。您可以使用Alt + Enter完成大多数操作，例如用Column包装和将Widget居中，但是Flutter Outline选项卡下还有更多很棒的功能！其中之一是“提取方法”按钮。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200703074346416-1495921223.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果您觉得编写的小部件太长了，可能应该是自定义小部件，那么不必手动将代码转换为方法，您可以使用此工具为您做魔术！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200703074346879-164770654.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;上下移动小部件&quot;&gt;上下移动小部件&lt;/h4&gt;
&lt;p&gt;Flutter Outline可以做的另一疯狂的事情是，如果一个小部件中有多个子代，则可以轻松地重新排列它们的顺序：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200703074347332-315495584.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;您也可以通过按Shift + Alt +向上/向下键仅向上或向下移动一行&lt;/p&gt;
&lt;h4 id=&quot;重构重命名&quot;&gt;重构重命名&lt;/h4&gt;
&lt;p&gt;这是大多数IDE都具备的非常基本的工具。这使您可以重命名方法，小部件，类或文件名，并确保也重命名了对该方法的引用。只需使用Shift + F6并输入新名称即可：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200703074347668-1643532246.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;删除未使用的导入&quot;&gt;删除未使用的导入&lt;/h4&gt;
&lt;p&gt;因此，您正在从事一个项目，并且导入了许多文件，但是随着时间的流逝，您的代码越来越得到优化。最终，您可能不再需要大量这些进口。现在您可以将代码推入生产环境，但是您需要清理它并删除所有那些未使用的导入。也许您通常是手动删除它们，但由于我是为了简化您的生活，因此这里有一个非常漂亮的键盘组合：Ctrl + Alt + O&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200703074347931-945317188.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;我什么都不记得了&quot;&gt;我什么都不记得了&lt;/h4&gt;
&lt;p&gt;如果您像这里的Filip Hracek一样有时会忘记他的快捷方式，我们将为您提供这一重要的魔术。只需按Ctrl + Shift + A并键入所需的快捷方式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200703074348334-345747021.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这就是我目前所知道的所有快捷方式。请务必经常回来查看更多提示，技巧和其他好东西！&lt;/p&gt;
&lt;p&gt;我是否错过了神话般的快捷方式？在下面发表评论！&lt;/p&gt;
&lt;p&gt;我的文章是免费的，但是您知道您可以按clap👏按钮50次吗？你走得越高，就越激励我为你写更多的东西！&lt;/p&gt;
&lt;h2 id=&quot;交流&quot;&gt;交流&lt;/h2&gt;
&lt;p&gt;老孟Flutter博客地址（330个控件用法）：&lt;a href=&quot;http://laomengit.com&quot;&gt;http://laomengit.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎加入Flutter交流群（微信：laomengit）、关注公众号【老孟Flutter】：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th/&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200703074348707-517795453.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200703074349165-1144177664.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</description>
<pubDate>Thu, 02 Jul 2020 23:44:00 +0000</pubDate>
<dc:creator>老孟Flutter</dc:creator>
<og:description>老孟导读：这是老孟翻译的精品文章，文章所有权归原作者所有。 欢迎加入老孟Flutter交流群，每周翻译2-3篇付费文章，精彩不容错过。 原文地址：https://medium.com/flutter-</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mengqd/p/13228179.html</dc:identifier>
</item>
<item>
<title>Python 3.10 的首个 PEP 诞生，内置类型 zip() 迎来新特性 - 豌豆花下猫</title>
<link>http://www.cnblogs.com/pythonista/p/13227932.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pythonista/p/13227932.html</guid>
<description>&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;译者前言：相信凡是用过 zip() 内置函数的人，都会赞同它很有用，但是，它的最大问题是可能会产生出非预期的结果。PEP-618 提出给它增加一个参数，可以有效地解决大家的痛点。&lt;/p&gt;
&lt;p&gt;这是 Python 3.10 版本正式采纳的第一个 PEP，「Python猫」一直有跟进社区最新动态的习惯，所以翻译了出来给大家尝鲜，强烈推荐一读。（PS：严格来说，zip() 是一个内置类（built-in type），而不是一个内置函数（built-in function），但我们一般都称它为一个内置函数。）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;PEP原文 ：&lt;/strong&gt; &lt;a href=&quot;https://www.python.org/dev/peps/pep-0618/&quot;&gt;https://www.python.org/dev/peps/pep-0618/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PEP标题：&lt;/strong&gt; Add Optional Length-Checking To zip&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PEP作者：&lt;/strong&gt; Brandt Bucher&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;创建日期：&lt;/strong&gt; 2020-05-01&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;合入版本：&lt;/strong&gt; 3.10&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;译者&lt;/strong&gt; ：&lt;a href=&quot;https://zhuanlan.zhihu.com/pythonCat&quot;&gt;豌豆花下猫&lt;/a&gt; @Python猫公众号&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PEP翻译计划&lt;/strong&gt; ：&lt;a href=&quot;https://github.com/chinesehuazhou/peps-cn&quot;&gt;https://github.com/chinesehuazhou/peps-cn&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;p&gt;本 PEP 建议给内置的 &lt;code&gt;zip&lt;/code&gt; 添加一个可选的 strict 布尔关键字参数。当启用时，如果其中一个参数先被用尽了，则会引发 ValueError 。&lt;/p&gt;
&lt;h2 id=&quot;动机&quot;&gt;动机&lt;/h2&gt;
&lt;p&gt;从作者的个人经验和一份&lt;a href=&quot;https://www.python.org/dev/peps/pep-0618/%23examples#examples&quot;&gt;对标准库的调查&lt;/a&gt; 来看，明显有很多（如果不是绝大多数）zip 用例要求可迭代对象必须是等长的。有时候，周围代码的上下文可以保证这点，但是要 zip 处理的数据通常是由调用者传入的、单独提供的或者以某种方式生成的。在这些情况下，zip 的默认行为意味着错误的重构或逻辑错误，很容易悄悄地导致数据丢失。这些 bug 不仅难以定位，甚至难以被觉察到。&lt;/p&gt;
&lt;p&gt;很容易想到造成这种问题的简单案例。例如，以下代码在 items 为一个序列（sequence）时可以良好地运行，但是如果调用者将 item 重构为一个可消耗的迭代器，则代码会悄悄地产生缩短的、不匹配的结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;def apply_calculations(items):
    transformed = transform(items)
    for i, t in zip(items, transformed):
        yield calculate(i, t)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;zip 还有几种常见用法。惯用的技巧性用法特别容易出问题，因为它们经常被不完全了解代码工作方式的用户使用。下面是一个示例，解包到 zip 中以转化成嵌套的可迭代对象：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; x = [[1, 2, 3], [&quot;one&quot; &quot;two&quot; &quot;three&quot;]]
&amp;gt;&amp;gt;&amp;gt; xt = list(zip(*x))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另一个例子是将数据“分块”成大小相等的组：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; n = 3
&amp;gt;&amp;gt;&amp;gt; x = range(n ** 2),
&amp;gt;&amp;gt;&amp;gt; xn = list(zip(*[iter(x)] * n))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在第一个例子中，非矩形数据通常会导致逻辑错误。在第二个例子中，长度不是 n 的倍数的数据通常也是错误。因为这两个习惯用法都会悄悄地忽略不匹配的尾部元素。&lt;/p&gt;
&lt;p&gt;最有说服力的例子来自使用了 zip 的标准库&lt;code&gt;ast&lt;/code&gt; ，它在 literal_eval 里产生过一个 bug，&lt;a href=&quot;https://bugs.python.org/issue40355&quot;&gt;会直接丢弃不匹配的节点&lt;/a&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; from ast import Constant, Dict, literal_eval
&amp;gt;&amp;gt;&amp;gt; nasty_dict = Dict(keys=[Constant(None)], values=[])
&amp;gt;&amp;gt;&amp;gt; literal_eval(nasty_dict)  # Like eval(&quot;{None: }&quot;)
{}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实际上，笔者已经在 Python 的标准库和工具中&lt;a href=&quot;https://www.python.org/dev/peps/pep-0618/%23examples#examples&quot;&gt;找出了许多调用点，&lt;/a&gt; 立即在这些位置启用此新特性是恰当的。&lt;/p&gt;
&lt;h2 id=&quot;基本原理&quot;&gt;基本原理&lt;/h2&gt;
&lt;p&gt;一些评论者声称：布尔开关常量是一种“代码坏气味（code-smell）”，或者与 Python 的设计哲学背道而驰。&lt;/p&gt;
&lt;p&gt;但是，Python 当前在内置函数上有几个布尔关键字参数的用法，它们通常使用编译期常量来调用：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;compile(..., dont_inherit=True)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;open(..., closefd=False)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;print(..., flush=True)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sorted(..., reverse=True)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;标准库中还有许多类似用法。&lt;/p&gt;
&lt;p&gt;这个新参数的想法和名称&lt;a href=&quot;https://mail.python.org/archives/list/python-ideas%40python.org/message/6GFUADSQ5JTF7W7OGWF7XF2NH2XUTUQM&quot;&gt;最初是&lt;/a&gt;由 Ram Rachum 提出的。该议题收到了 100 多个回复，而候选的“equal”也获得了相近的支持数。&lt;/p&gt;
&lt;p&gt;笔者对它们没有很强烈的偏好，尽管“equal equals” 读起来有点尴尬。它还可能（错误地）暗示了 zip 的对象是相等的：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; z = zip([2.0, 4.0, 6.0], [2, 4, 8], equal=True)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;规范&quot;&gt;规范&lt;/h2&gt;
&lt;p&gt;当用关键字参数 strict=True 调用内置类 zip 时，如果参数的长度不同，则生成的迭代器会引发 ValueError。这个异常就发生在迭代器正常停止迭代的地方。&lt;/p&gt;
&lt;h2 id=&quot;向上兼容&quot;&gt;向上兼容&lt;/h2&gt;
&lt;p&gt;此项更改是完全向上兼容的。当前的 zip 不接受关键字参数，默认省略 strict 的“非严格”用法会保持不变。&lt;/p&gt;
&lt;h2 id=&quot;参考实现&quot;&gt;参考实现&lt;/h2&gt;
&lt;p&gt;笔者设计了一个 &lt;a href=&quot;https://github.com/python/cpython/pull/20921&quot;&gt;C 实现&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;用 Python 大致翻译如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;def zip(*iterables, strict=False):
    if not iterables:
        return
    iterators = tuple(iter(iterable) for iterable in iterables)
    try:
        while True:
            items = []
            for iterator in iterators:
                items.append(next(iterator))
            yield tuple(items)
    except StopIteration:
        if not strict:
            return
    if items:
        i = len(items)
        plural = &quot; &quot; if i == 1 else &quot;s 1-&quot;
        msg = f&quot;zip() argument {i+1} is shorter than argument{plural}{i}&quot;
        raise ValueError(msg)
    sentinel = object()
    for i, iterator in enumerate(iterators[1:], 1):
        if next(iterator, sentinel) is not sentinel:
            plural = &quot; &quot; if i == 1 else &quot;s 1-&quot;
            msg = f&quot;zip() argument {i+1} is longer than argument{plural}{i}&quot;
            raise ValueError(msg)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;被拒绝的意见&quot;&gt;被拒绝的意见&lt;/h2&gt;
&lt;h3 id=&quot;（1）添加-itertoolszip_strict&quot;&gt;（1）添加 itertools.zip_strict&lt;/h3&gt;
&lt;p&gt;这是 Python-Ideas 邮件列表上获得最多支持的替代方案，因此值得在此处加以讨论。它没有任何严重的缺陷，如果本 PEP 被否绝，它是一个很好的替代。&lt;/p&gt;
&lt;p&gt;虽然考虑到这一点，但是在 zip 中添加可选参数可以用较小的更改而更好地解决诱发此 PEP 的问题。&lt;/p&gt;
&lt;h3 id=&quot;（2）依照先例&quot;&gt;（2）依照先例&lt;/h3&gt;
&lt;p&gt;itertools 中有一个 zip_longest，这似乎让人很有动机再添加一个 zip_strict。但是，zip_longest 在许多方面是一个更加复杂且特定的程序：它负责填写缺失的值，但其它函数都不需要操心这种事。&lt;/p&gt;
&lt;p&gt;如果 zip 和 zip_longest 同时放在 itertools 中，或者都作为内置函数，那么在相同的地方添加 zip_strict 就确实是一个更有效的论点。然而，新的“strict”用法在接口和行为方面，相比起 zip_longest，更接近于 zip 的概念，但又不足以成为内置对象。考虑到这个原因，令 zip 就地扩展出一个新的选项，似乎是最自然的选择。&lt;/p&gt;
&lt;h3 id=&quot;（3）易用性&quot;&gt;（3）易用性&lt;/h3&gt;
&lt;p&gt;如果 zip 能够防止此类 bug，那么用户在调用的地方启动检查，就会变得非常简单。与其编写一套繁重的逻辑来处理，不如用这个新特性来直接检查。&lt;/p&gt;
&lt;p&gt;有人还认为，在标准库中放一个新的函数，相比在一个内置函数上加关键字参数，更“容易发现（discoverable）”。笔者不同意这一论断。&lt;/p&gt;
&lt;h3 id=&quot;（4）维护成本&quot;&gt;（4）维护成本&lt;/h3&gt;
&lt;p&gt;尽管在提升易用性时，具体的实现是个次要问题，但重要的是要认识到，添加新的程序比修改原有程序复杂得多。与此 PEP 一起提供的 CPython 实现非常简单，并且对 zip 的默认行为没有显著的性能影响，而在 itertools 中添加一个全新的程序将需要：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;复制 zip 的许多现有逻辑，zip_longest 就是这么干的。&lt;/li&gt;
&lt;li&gt;大刀阔斧地重构 zip 或 zip_longest 或这两者，以便共享一个公共的或者继承性的实现（这可能会影响性能）。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;（5）添加多个模式以供切换&quot;&gt;（5）添加多个“模式”以供切换&lt;/h3&gt;
&lt;p&gt;如果预期有三个或更多模式（mode），这个建议才会比二元标志更有意义。最显而易见的三种模式是：“最短的”（当前 zip 的行为），“严格的”（本 PEP 提议的行为）和“最长的”（itertools.zip_longest 的行为）。&lt;/p&gt;
&lt;p&gt;但是，除了当前的默认值以及本提案的“strict”模式，似乎不需要再添加其它模式。最可能的是添加一个“最长的”模式，但这需要一个新的 fillvalue 参数（它对于前两种模式都没有意义），另外，itertools.zip_longest 已经完美地处理了这种模式，若在 zip 中添加该模式，将会造成重复。目前尚不清楚哪一个是“显而易见的”选择：内置 zip 上的 mode 参数，还是已经长期存在于 itertools 中的 zip_longest。&lt;/p&gt;
&lt;h3 id=&quot;（6）给-zip-添加方法或者构造函数&quot;&gt;（6）给 zip 添加方法或者构造函数&lt;/h3&gt;
&lt;p&gt;考虑以下两个被提出来的做法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; zm = zip(*iters).strict()
&amp;gt;&amp;gt;&amp;gt; zd = zip.strict(*iters)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;尚不清楚哪个更好，或者哪个更差。如果 zip.strict 作为一个方法来实现，则 zm 没问题，但是 zd 会出现几种令人困惑的情况：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;返回不包装在元组中的结果（如果 iters 仅包含一个元素，一个 zip 迭代器）。&lt;/li&gt;
&lt;li&gt;参数类型错误时抛出 TypeError（如果 iters 只包含一个元素，不是一个 zip 迭代器）。&lt;/li&gt;
&lt;li&gt;否则，参数数量不对时抛出 TypeError。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果 zip.strict 是作为 classmethod 或 staticmethod 实现，则 zd 将成功执行，而 zm 将不产生任何结果（这正是我们最初要避免的问题）。&lt;/p&gt;
&lt;p&gt;本提案还面临着更为复杂的问题，因为 CPython 中 zip 内置类的实现细节是未文档化的。这意味着若选择以上的某种行为，当前的实现就会被“锁定”（或至少要求对其进行仿真）。&lt;/p&gt;
&lt;h3 id=&quot;（7）变更-zip-的默认行为&quot;&gt;（7）变更 zip 的默认行为&lt;/h3&gt;
&lt;p&gt;zip 的默认行为没有什么“错” ，因为在许多情况下，这确实是正确处理大小不等的输入的方法。例如，在处理无限迭代器时，它非常有用。&lt;/p&gt;
&lt;p&gt;itertools.zip_longest 已经用在仍然需要“额外”尾端数据的情况。&lt;/p&gt;
&lt;h3 id=&quot;（8）使用回调来处理剩余对象&quot;&gt;（8）使用回调来处理剩余对象&lt;/h3&gt;
&lt;p&gt;尽管基本上可以执行用户需要的任何操作，但此解决方案在处理常见问题时（例如舍弃不匹配的长度），变得不必要的复杂且不直观。&lt;/p&gt;
&lt;h3 id=&quot;（9）引发一个-assertionerror&quot;&gt;（9）引发一个 AssertionError&lt;/h3&gt;
&lt;p&gt;没有内置函数或内置类的 API 会引发 AssertionError。此外，&lt;a href=&quot;https://docs.python.org/3.9/library/exceptions.html%3Fhighlight%3Dassertionerror%23AssertionError#AssertionError&quot;&gt;官方文档&lt;/a&gt; 这么写的（它的全部）：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Raised when an &lt;code&gt;assert&lt;/code&gt; statement fails.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由于此功能与 Python 的 assert 语句无关，因此不应该引发 AssertionError。用户若希望在优化模式下禁用检查（像一个 assert 语句），可以改用 strict = __debug__。&lt;/p&gt;
&lt;h3 id=&quot;（10）在-map-上添加类似的特性&quot;&gt;（10）在 map 上添加类似的特性&lt;/h3&gt;
&lt;p&gt;本 PEP 不建议对 map 作任何更改，因为很少使用带有多个可迭代参数的map。但是，本 PEP 的裁定可作为将来讨论类似特性的先例（应该出现）。&lt;/p&gt;
&lt;p&gt;如果本 PEP 被拒绝，则 map 的那种特性实际上也不值得追求。如果通过了，则对 map 的更改不需要新的 PEP（尽管像所有提案一样，都应仔细考虑其有用性）。为了保持一致性，它应遵循此处讨论的跟 zip 相同的 API 和语义。&lt;/p&gt;
&lt;h3 id=&quot;（11）什么也不做&quot;&gt;（11）什么也不做&lt;/h3&gt;
&lt;p&gt;此建议可能最没有吸引力。&lt;/p&gt;
&lt;p&gt;悄悄地将数据截断是一种特别令人讨厌的 bug，而手写一个健壮的解决方案却&lt;a href=&quot;https://stackoverflow.com/questions/32954486/zip-iterators-asserting-for-equal-length-in-python&quot;&gt;并非易事&lt;/a&gt;。Python 自己的标准库（前文提到的 ast）是有现实意义的反例，很容易就陷入本 PEP 试图避免的那种陷阱。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;推荐阅读：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、PEP中文翻译计划 (&lt;a href=&quot;https://github.com/chinesehuazhou/peps-cn&quot;&gt;https://github.com/chinesehuazhou/peps-cn&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;2、学习 Python，怎能不懂点PEP呢？ (&lt;a href=&quot;https://mp.weixin.qq.com/s/oRoBxZ2-IyuPOf_MWyKZyw&quot;&gt;https://mp.weixin.qq.com/s/oRoBxZ2-IyuPOf_MWyKZyw&lt;/a&gt;)&lt;/p&gt;
</description>
<pubDate>Thu, 02 Jul 2020 15:52:00 +0000</pubDate>
<dc:creator>豌豆花下猫</dc:creator>
<og:description>译者前言：相信凡是用过 zip() 内置函数的人，都会赞同它很有用，但是，它的最大问题是可能会产生出非预期的结果。PEP-618 提出给它增加一个参数，可以有效地解决大家的痛点。 这是 Python</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/pythonista/p/13227932.html</dc:identifier>
</item>
<item>
<title>大型Java进阶专题（六）设计模式之代理模式 - 漂泊在外的程序员老王</title>
<link>http://www.cnblogs.com/whgk/p/12917652.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/whgk/p/12917652.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;又开始我的专题了，又停滞了一段时间了，加油继续吧。都知道 SpringAOP 是用代理模式实现，到底是怎么实现的？我们来一探究竟，并且自己仿真手写还原部分细节。
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;代理模式的应用&quot;&gt;代理模式的应用&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;在生活中，我们经常见到这样的场景，如：租房中介、售票黄牛、婚介、经纪人、快递、 事务代理、非侵入式日志监听等，这些都是代理模式的实际体现。代理模式（Proxy Pattern）的定义也非常简单，是指为其他对象提供一种代理，以控制对这个对象的访问。 代理对象在客服端和目标对象之间起到中介作用，代理模式属于结构型设计模式。使用 代理模式主要有两个目的：一保护目标对象，二增强目标象。下面我们来看一下代理 模式的类结构图：
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/874710/202007/874710-20200702231632187-521437593.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Subject 是顶层接口，RealSubject 是真实对象（被代理对象），Proxy 是代理对象，代 理对象持有被代理对象的引用，客户端调用代理对象方法，同时也调用被代理对象的方 法，但是在代理对象前后增加一些处理。在代码中，我们想到代理，就会理解为是代码 增强，其实就是在原本逻辑前后增加一些逻辑，而调用者无感知。代理模式属于结构型 模式，有静态代理和动态代理。
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;静态代理&quot;&gt;静态代理&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;举个例子：人到了适婚年龄，父母总是迫不及待希望早点抱孙子。而现在社会的人在各 种压力之下，都选择晚婚晚育。于是着急的父母就开始到处为自己的子女相亲，比子女 自己还着急。这个相亲的过程，就是一种我们人人都有份的代理。来看代码实现： 

/**
 * 人很多行为，要谈恋爱
 */
public interface Person {
    void findLove();
}


/**
 * 儿子需要找对象
 */
public class Son implements Person {

    @Override
    public void findLove() {
        System.out.println(&quot;工作没时间！&quot;);
    }
}

/**
 * 父亲代理儿子 先帮物色对象
 */
public class Father{

    private Son son;

    //代理对象持有 被代理对象的应用 但没办法扩展
    private Father(Son son) {
        this.son = son;
    }

    private void findLove() {
        //before
        System.out.println(&quot;父母帮物色对象&quot;);
        son.findLove();
        //after
        System.out.println(&quot;双方同意交往！&quot;);
    }

    //测试代码
    public static void main(String[] args) {
        Son son = new Son();
        Father father = new Father(son);
        father.findLove();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;动态代理&quot;&gt;动态代理&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;动态代理和静态对比基本思路是一致的，只不过动态代理功能更加强大，随着业务的扩 展适应性更强。如果还以找对象为例，使用动态代理相当于是能够适应复杂的业务场景。 不仅仅只是父亲给儿子找对象，如果找对象这项业务发展成了一个产业，进而出现了媒 婆、婚介所等这样的形式。那么，此时用静态代理成本就更大了，需要一个更加通用的 解决方案，要满足任何单身人士找对象的需求。我们升级一下代码，先来看 JDK 实现方式：
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;jdk-实现方式&quot;&gt;JDK 实现方式&lt;/h3&gt;
&lt;p&gt;创建媒婆（婚介）JDKMeipo 类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.study;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;


public class JdkMeipo implements InvocationHandler {
        //持有被代理对象的引用
    Object target;

    public Object getInstance(Object target){
        this.target =target;
        Class&amp;lt;?&amp;gt; aClass = target.getClass();
        return Proxy.newProxyInstance(aClass.getClassLoader(),aClass.getInterfaces(),this);
    }
  
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        before();
        Object object = method.invoke(this.target,args);
        after();
        return object;
    }

    private void before() {
        System.out.println(&quot;我是婚介，帮你物色对象&quot;);
    }

    private void after() {
        System.out.println(&quot;已找到，如果合适就开始&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建单身客户&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.study;

public class Customer implements Person{

    @Override
    public void findLove() {
        System.out.println(&quot;我要找白富美&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.study;

public class DemoTest {
    public static void main(String[] args) {
        Person person = (Person) new JdkMeipo().getInstance(new Customer());
        person.findLove();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行效果&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/874710/202007/874710-20200702231650528-1433131801.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;jdk代理的原理&quot;&gt;Jdk代理的原理&lt;/h3&gt;
&lt;p&gt;不仅知其然，还得知其所以然。既然 JDK Proxy 功能如此强大，那么它是如何实现的呢？ 我们现在来探究一下原理。 我们都知道 JDK Proxy 采用字节重组，重新生的对象来替代原始的对象以达到动态代理 的目的。JDK Proxy 生成对象的步骤如下：&lt;/p&gt;
&lt;p&gt;1.拿到代理对象的应用，并获取它的所有接口，反射获取。&lt;/p&gt;
&lt;p&gt;2.通过JDK proxy 类重新生成一个新的类，同时新的类要实现被代理类所有实现的接口。&lt;/p&gt;
&lt;p&gt;3.动态生成Java代码，把新加的业务逻辑方法由一定的逻辑代码去调用（在代码中体现）。&lt;/p&gt;
&lt;p&gt;4.编译重新生成Java代码.class&lt;/p&gt;
&lt;p&gt;5.再重新加载的JVM中&lt;br/&gt;以上这个过程就叫字节重组。&lt;/p&gt;
&lt;h3 id=&quot;cglib实现方式&quot;&gt;CGLib实现方式&lt;/h3&gt;
&lt;p&gt;简单看一下 CGLib 代理的使用,还是以媒婆为例，创建 CglibMeipo 类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.study;

import org.springframework.cglib.proxy.Enhancer;
import org.springframework.cglib.proxy.MethodInterceptor;
import org.springframework.cglib.proxy.MethodProxy;

import java.lang.reflect.Method;

public class CGlibMeipo implements MethodInterceptor {
    Object target;
    public Object getInstance(Class&amp;lt;?&amp;gt; aClass){
        Enhancer enhancer = new Enhancer();
        enhancer.setSuperclass(aClass);
        enhancer.setCallback(this);
        return enhancer.create();
    }
    @Override
    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
        before();
        Object invokeSuper = methodProxy.invokeSuper(o, objects);
        after();
        return invokeSuper;
    }

    private void after() {
        System.out.println(&quot;已找到，如果合适就开始&quot;);
    }

    private void before() {
        System.out.println(&quot;我是婚介，帮你物色对象&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试调用&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.study;

public class DemoTest {
    public static void main(String[] args) {
        //Person person = (Person) new JdkMeipo().getInstance(new Customer());
        Person person = (Person) new CGlibMeipo().getInstance(Customer.class);
        person.findLove();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果：（CGLib代理的对象是不需要实现任何接口的，他是通过动态继承目标对象实现的动态代理。）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/874710/202007/874710-20200702231657682-826396795.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;CGLib 动态代理执行代理方法效率之所以比 JDK 的高是因为 Cglib 采用了 FastClass 机 制，它的原理简单来说就是：为代理类和被代理类各生成一个 Class，这个 Class 会为代 理类或被代理类的方法分配一个 index(int 类型)。这个 index 当做一个入参，FastClass 就可以直接定位要调用的方法直接进行调用，这样省去了反射调用，所以调用效率比 JDK 动态代理通过反射调用高。&lt;/p&gt;
&lt;h3 id=&quot;cglib-和-jdk-动态代理对比&quot;&gt;CGLib 和 JDK 动态代理对比&lt;/h3&gt;
&lt;p&gt;1.JDK 动态代理是实现了被代理对象的接口，CGLib 是继承了被代理对象。&lt;/p&gt;
&lt;p&gt;2.JDK 和 CGLib 都是在运行期生成字节码，JDK 是直接写 Class 字节码，CGLib 使用 ASM 框架写 Class 字节码，Cglib 代理实现更复杂，生成代理类比 JDK 效率低。&lt;/p&gt;
&lt;p&gt;3.JDK 调用代理方法，是通过反射机制调用，CGLib 是通过 FastClass 机制直接调用方法， CGLib 执行效率更高。&lt;/p&gt;
</description>
<pubDate>Thu, 02 Jul 2020 15:17:00 +0000</pubDate>
<dc:creator>漂泊在外的程序员老王</dc:creator>
<og:description>#代理模式 ##前言 又开始我的专题了，又停滞了一段时间了，加油继续吧。都知道 SpringAOP 是用代理模式实现，到底是怎么实现的？我们来一探究竟，并且自己仿真手写还原部分细节。 ##代理模式的应</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/whgk/p/12917652.html</dc:identifier>
</item>
<item>
<title>Oracle归档日志所在目录时间不对&amp;&amp;Oracle集群日志时间显示错误 - PiscesCanon</title>
<link>http://www.cnblogs.com/PiscesCanon/p/13227764.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/PiscesCanon/p/13227764.html</guid>
<description>

&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;这个问题在18年的时候遇到了，基本不注意并且集群或者数据库运行正常是很难注意到的。&lt;/p&gt;
&lt;p&gt;忘记当时怎么发现的了，最近拿出来重现一下问题。&lt;/p&gt;
&lt;p&gt;具体描述一下问题：&lt;/p&gt;
&lt;p&gt;比如当前时间是2020年07月03日0点，数据库对redo log发起归档。&lt;/p&gt;
&lt;p&gt;在OMF下，归档会按照日期进行分类归档。&lt;/p&gt;
&lt;p&gt;但是发起归档之后，新的归档文件会放在的20200702的目录中。&lt;/p&gt;
&lt;p&gt;另外，db和asm和集群的警告日志的时间也和操作系统的date时间不一致。&lt;/p&gt;

&lt;h2&gt;现象&lt;/h2&gt;
&lt;p&gt;版本：11.2.0.4.0&lt;/p&gt;
&lt;p&gt;在我的测试环境中，关闭所有节点的集群之后，更改时间：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@rac1 ~]# &lt;span&gt;date&lt;/span&gt; -s &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2020-07-03 00:00:00&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
Fri Jul  &lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt; CST &lt;span&gt;2020&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后，启动所有节点的集群，可以依次观察&lt;/p&gt;
&lt;p&gt;集群的警告日志，grid用户下，$ORACLE_HOME/log/rac1/alertrac1.log&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;2020&lt;/span&gt;-&lt;span&gt;07&lt;/span&gt;-&lt;span&gt;02&lt;/span&gt; &lt;span&gt;09&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;26.667&lt;/span&gt;&lt;span&gt;:
[ohasd(&lt;/span&gt;&lt;span&gt;24600&lt;/span&gt;)]CRS-&lt;span&gt;2112&lt;/span&gt;&lt;span&gt;:The OLR service started on node rac1.
&lt;/span&gt;&lt;span&gt;2020&lt;/span&gt;-&lt;span&gt;07&lt;/span&gt;-&lt;span&gt;02&lt;/span&gt; &lt;span&gt;09&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;26.675&lt;/span&gt;&lt;span&gt;:
[ohasd(&lt;/span&gt;&lt;span&gt;24600&lt;/span&gt;)]CRS-&lt;span&gt;1301&lt;/span&gt;&lt;span&gt;:Oracle High Availability Service started on node rac1.
&lt;/span&gt;&lt;span&gt;2020&lt;/span&gt;-&lt;span&gt;07&lt;/span&gt;-&lt;span&gt;02&lt;/span&gt; &lt;span&gt;09&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;26.676&lt;/span&gt;&lt;span&gt;:
[ohasd(&lt;/span&gt;&lt;span&gt;24600&lt;/span&gt;)]CRS-&lt;span&gt;8017&lt;/span&gt;:location: /etc/oracle/lastgasp has &lt;span&gt;2&lt;/span&gt; reboot advisory log files, &lt;span&gt;0&lt;/span&gt; were announced and &lt;span&gt;0&lt;/span&gt;&lt;span&gt; errors occurred
&lt;/span&gt;&lt;span&gt;2020&lt;/span&gt;-&lt;span&gt;07&lt;/span&gt;-&lt;span&gt;02&lt;/span&gt; &lt;span&gt;09&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;30.080&lt;/span&gt;&lt;span&gt;:
[&lt;/span&gt;/u01/app/&lt;span&gt;11.2&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;/grid/bin/orarootagent.bin(&lt;span&gt;24643&lt;/span&gt;)]CRS-&lt;span&gt;2302&lt;/span&gt;&lt;span&gt;:Cannot get GPnP profile. Error CLSGPNP_NO_DAEMON (GPNPD daemon is not running).
&lt;/span&gt;&lt;span&gt;2020&lt;/span&gt;-&lt;span&gt;07&lt;/span&gt;-&lt;span&gt;02&lt;/span&gt; &lt;span&gt;09&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;34.563&lt;/span&gt;&lt;span&gt;:
[gpnpd(&lt;/span&gt;&lt;span&gt;24737&lt;/span&gt;)]CRS-&lt;span&gt;2328&lt;/span&gt;&lt;span&gt;:GPNPD started on node rac1.
&lt;/span&gt;&lt;span&gt;2020&lt;/span&gt;-&lt;span&gt;07&lt;/span&gt;-&lt;span&gt;02&lt;/span&gt; &lt;span&gt;09&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;36.992&lt;/span&gt;&lt;span&gt;:
[cssd(&lt;/span&gt;&lt;span&gt;24806&lt;/span&gt;)]CRS-&lt;span&gt;1713&lt;/span&gt;:CSSD daemon is started &lt;span&gt;in&lt;/span&gt;&lt;span&gt; clustered mode
&lt;/span&gt;&lt;span&gt;2020&lt;/span&gt;-&lt;span&gt;07&lt;/span&gt;-&lt;span&gt;02&lt;/span&gt; &lt;span&gt;09&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;38.798&lt;/span&gt;&lt;span&gt;:
[ohasd(&lt;/span&gt;&lt;span&gt;24600&lt;/span&gt;)]CRS-&lt;span&gt;2767&lt;/span&gt;:Resource state recovery not attempted &lt;span&gt;for&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ora.diskmon&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; as its target state is OFFLINE
&lt;/span&gt;&lt;span&gt;2020&lt;/span&gt;-&lt;span&gt;07&lt;/span&gt;-&lt;span&gt;02&lt;/span&gt; &lt;span&gt;09&lt;/span&gt;:&lt;span&gt;01&lt;/span&gt;:&lt;span&gt;01.319&lt;/span&gt;&lt;span&gt;:
[cssd(&lt;/span&gt;&lt;span&gt;24806&lt;/span&gt;)]CRS-&lt;span&gt;1707&lt;/span&gt;:Lease acquisition &lt;span&gt;for&lt;/span&gt; node rac1 number &lt;span&gt;1&lt;/span&gt;&lt;span&gt; completed
&lt;/span&gt;&lt;span&gt;2020&lt;/span&gt;-&lt;span&gt;07&lt;/span&gt;-&lt;span&gt;02&lt;/span&gt; &lt;span&gt;09&lt;/span&gt;:&lt;span&gt;01&lt;/span&gt;:&lt;span&gt;02.612&lt;/span&gt;&lt;span&gt;:
[cssd(&lt;/span&gt;&lt;span&gt;24806&lt;/span&gt;)]CRS-&lt;span&gt;1605&lt;/span&gt;:CSSD voting &lt;span&gt;file&lt;/span&gt; is online: /dev/mapper/asm-ocr02; details &lt;span&gt;in&lt;/span&gt; /u01/app/&lt;span&gt;11.2&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;/grid/log/rac1/cssd/&lt;span&gt;ocssd.log.
&lt;/span&gt;&lt;span&gt;2020&lt;/span&gt;-&lt;span&gt;07&lt;/span&gt;-&lt;span&gt;02&lt;/span&gt; &lt;span&gt;09&lt;/span&gt;:&lt;span&gt;01&lt;/span&gt;:&lt;span&gt;02.620&lt;/span&gt;&lt;span&gt;:
[cssd(&lt;/span&gt;&lt;span&gt;24806&lt;/span&gt;)]CRS-&lt;span&gt;1605&lt;/span&gt;:CSSD voting &lt;span&gt;file&lt;/span&gt; is online: /dev/mapper/asm-ocr03; details &lt;span&gt;in&lt;/span&gt; /u01/app/&lt;span&gt;11.2&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;/grid/log/rac1/cssd/&lt;span&gt;ocssd.log.
&lt;/span&gt;&lt;span&gt;2020&lt;/span&gt;-&lt;span&gt;07&lt;/span&gt;-&lt;span&gt;02&lt;/span&gt; &lt;span&gt;09&lt;/span&gt;:&lt;span&gt;01&lt;/span&gt;:&lt;span&gt;02.623&lt;/span&gt;&lt;span&gt;:
[cssd(&lt;/span&gt;&lt;span&gt;24806&lt;/span&gt;)]CRS-&lt;span&gt;1605&lt;/span&gt;:CSSD voting &lt;span&gt;file&lt;/span&gt; is online: /dev/mapper/asm-ocr01; details &lt;span&gt;in&lt;/span&gt; /u01/app/&lt;span&gt;11.2&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;/grid/log/rac1/cssd/&lt;span&gt;ocssd.log.
&lt;/span&gt;&lt;span&gt;2020&lt;/span&gt;-&lt;span&gt;07&lt;/span&gt;-&lt;span&gt;02&lt;/span&gt; &lt;span&gt;09&lt;/span&gt;:&lt;span&gt;01&lt;/span&gt;:&lt;span&gt;15.917&lt;/span&gt;&lt;span&gt;:
[cssd(&lt;/span&gt;&lt;span&gt;24806&lt;/span&gt;)]CRS-&lt;span&gt;1601&lt;/span&gt;&lt;span&gt;:CSSD Reconfiguration complete. Active nodes are rac1 rac2 .
&lt;/span&gt;&lt;span&gt;2020&lt;/span&gt;-&lt;span&gt;07&lt;/span&gt;-&lt;span&gt;02&lt;/span&gt; &lt;span&gt;09&lt;/span&gt;:&lt;span&gt;01&lt;/span&gt;:&lt;span&gt;18.061&lt;/span&gt;&lt;span&gt;:
[ctssd(&lt;/span&gt;&lt;span&gt;25418&lt;/span&gt;)]CRS-&lt;span&gt;2403&lt;/span&gt;:The Cluster Time Synchronization Service on host rac1 is &lt;span&gt;in&lt;/span&gt;&lt;span&gt; observer mode.
&lt;/span&gt;&lt;span&gt;2020&lt;/span&gt;-&lt;span&gt;07&lt;/span&gt;-&lt;span&gt;02&lt;/span&gt; &lt;span&gt;09&lt;/span&gt;:&lt;span&gt;01&lt;/span&gt;:&lt;span&gt;18.421&lt;/span&gt;&lt;span&gt;:
[ctssd(&lt;/span&gt;&lt;span&gt;25418&lt;/span&gt;)]CRS-&lt;span&gt;2407&lt;/span&gt;&lt;span&gt;:The new Cluster Time Synchronization Service reference node is host rac1.
&lt;/span&gt;&lt;span&gt;2020&lt;/span&gt;-&lt;span&gt;07&lt;/span&gt;-&lt;span&gt;02&lt;/span&gt; &lt;span&gt;09&lt;/span&gt;:&lt;span&gt;01&lt;/span&gt;:&lt;span&gt;18.422&lt;/span&gt;&lt;span&gt;:
[ctssd(&lt;/span&gt;&lt;span&gt;25418&lt;/span&gt;)]CRS-&lt;span&gt;2401&lt;/span&gt;&lt;span&gt;:The Cluster Time Synchronization Service started on host rac1.
&lt;/span&gt;&lt;span&gt;2020&lt;/span&gt;-&lt;span&gt;07&lt;/span&gt;-&lt;span&gt;02&lt;/span&gt; &lt;span&gt;09&lt;/span&gt;:&lt;span&gt;01&lt;/span&gt;:&lt;span&gt;20.023&lt;/span&gt;&lt;span&gt;:
[ohasd(&lt;/span&gt;&lt;span&gt;24600&lt;/span&gt;)]CRS-&lt;span&gt;2767&lt;/span&gt;:Resource state recovery not attempted &lt;span&gt;for&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ora.diskmon&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; as its target state is OFFLINE
[client(&lt;/span&gt;&lt;span&gt;25475&lt;/span&gt;)]CRS-&lt;span&gt;10001&lt;/span&gt;:&lt;span&gt;02&lt;/span&gt;-Jul-&lt;span&gt;20&lt;/span&gt; &lt;span&gt;09&lt;/span&gt;:&lt;span&gt;01&lt;/span&gt; ACFS-&lt;span&gt;9391&lt;/span&gt;: Checking &lt;span&gt;for&lt;/span&gt; existing ADVM/&lt;span&gt;ACFS installation.
[client(&lt;/span&gt;&lt;span&gt;25480&lt;/span&gt;)]CRS-&lt;span&gt;10001&lt;/span&gt;:&lt;span&gt;02&lt;/span&gt;-Jul-&lt;span&gt;20&lt;/span&gt; &lt;span&gt;09&lt;/span&gt;:&lt;span&gt;01&lt;/span&gt; ACFS-&lt;span&gt;9392&lt;/span&gt;: Validating ADVM/ACFS installation files &lt;span&gt;for&lt;/span&gt;&lt;span&gt; operating system.
[client(&lt;/span&gt;&lt;span&gt;25482&lt;/span&gt;)]CRS-&lt;span&gt;10001&lt;/span&gt;:&lt;span&gt;02&lt;/span&gt;-Jul-&lt;span&gt;20&lt;/span&gt; &lt;span&gt;09&lt;/span&gt;:&lt;span&gt;01&lt;/span&gt; ACFS-&lt;span&gt;9393&lt;/span&gt;&lt;span&gt;: Verifying ASM Administrator setup.
[client(&lt;/span&gt;&lt;span&gt;25485&lt;/span&gt;)]CRS-&lt;span&gt;10001&lt;/span&gt;:&lt;span&gt;02&lt;/span&gt;-Jul-&lt;span&gt;20&lt;/span&gt; &lt;span&gt;09&lt;/span&gt;:&lt;span&gt;01&lt;/span&gt; ACFS-&lt;span&gt;9308&lt;/span&gt;: Loading installed ADVM/&lt;span&gt;ACFS drivers.
[client(&lt;/span&gt;&lt;span&gt;25488&lt;/span&gt;)]CRS-&lt;span&gt;10001&lt;/span&gt;:&lt;span&gt;02&lt;/span&gt;-Jul-&lt;span&gt;20&lt;/span&gt; &lt;span&gt;09&lt;/span&gt;:&lt;span&gt;01&lt;/span&gt; ACFS-&lt;span&gt;9154&lt;/span&gt;: Loading &lt;span&gt;'&lt;/span&gt;&lt;span&gt;oracleoks.ko&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; driver.
[client(&lt;/span&gt;&lt;span&gt;25521&lt;/span&gt;)]CRS-&lt;span&gt;10001&lt;/span&gt;:&lt;span&gt;02&lt;/span&gt;-Jul-&lt;span&gt;20&lt;/span&gt; &lt;span&gt;09&lt;/span&gt;:&lt;span&gt;01&lt;/span&gt; ACFS-&lt;span&gt;9154&lt;/span&gt;: Loading &lt;span&gt;'&lt;/span&gt;&lt;span&gt;oracleadvm.ko&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; driver.
[client(&lt;/span&gt;&lt;span&gt;25548&lt;/span&gt;)]CRS-&lt;span&gt;10001&lt;/span&gt;:&lt;span&gt;02&lt;/span&gt;-Jul-&lt;span&gt;20&lt;/span&gt; &lt;span&gt;09&lt;/span&gt;:&lt;span&gt;01&lt;/span&gt; ACFS-&lt;span&gt;9154&lt;/span&gt;: Loading &lt;span&gt;'&lt;/span&gt;&lt;span&gt;oracleacfs.ko&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; driver.&lt;br/&gt;........
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;ASM实例警告日志，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
Thu Jul &lt;span&gt;02&lt;/span&gt; &lt;span&gt;09&lt;/span&gt;:&lt;span&gt;01&lt;/span&gt;:&lt;span&gt;26&lt;/span&gt; &lt;span&gt;2020&lt;/span&gt;&lt;span&gt;
NOTE: No asm libraries found &lt;/span&gt;&lt;span&gt;in&lt;/span&gt;&lt;span&gt; the system
NOTE: No asm libraries found &lt;/span&gt;&lt;span&gt;in&lt;/span&gt;&lt;span&gt; the system
MEMORY_TARGET defaulting to &lt;/span&gt;&lt;span&gt;1128267776&lt;/span&gt;&lt;span&gt;.
&lt;/span&gt;* instance_number obtained from CSS = &lt;span&gt;1&lt;/span&gt;, checking &lt;span&gt;for&lt;/span&gt; the existence of node &lt;span&gt;0&lt;/span&gt;&lt;span&gt;...
&lt;/span&gt;* node &lt;span&gt;0&lt;/span&gt; does not exist. instance_number = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;
Starting ORACLE instance (normal)
WARNING: You are trying to use the MEMORY_TARGET feature. This feature requires the &lt;/span&gt;/dev/shm &lt;span&gt;file&lt;/span&gt; system to be mounted &lt;span&gt;for&lt;/span&gt; at least &lt;span&gt;1140850688&lt;/span&gt; bytes. /dev/shm is either not mounted or is mounted with available space &lt;span&gt;less&lt;/span&gt; than this size. Please fix this so that MEMORY_TARGET can work as expected. Current available is &lt;span&gt;976789504&lt;/span&gt; and used is &lt;span&gt;73728&lt;/span&gt; bytes. Ensure that the &lt;span&gt;mount&lt;/span&gt; point is /dev/shm &lt;span&gt;for&lt;/span&gt;&lt;span&gt; this directory.
LICENSE_MAX_SESSION &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
LICENSE_SESSIONS_WARNING &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
Initial number of CPU is &lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;
Number of processor cores &lt;/span&gt;&lt;span&gt;in&lt;/span&gt; the system is &lt;span&gt;4&lt;/span&gt;&lt;span&gt;
Number of processor sockets &lt;/span&gt;&lt;span&gt;in&lt;/span&gt; the system is &lt;span&gt;2&lt;/span&gt;&lt;span&gt;
Private Interface &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;eth1:1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; configured from GPnP &lt;span&gt;for&lt;/span&gt;&lt;span&gt; use as a private interconnect.
  [name&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;eth1:1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, type=&lt;span&gt;1&lt;/span&gt;, ip=&lt;span&gt;169.254&lt;/span&gt;.&lt;span&gt;146.181&lt;/span&gt;, mac=&lt;span&gt;00&lt;/span&gt;-0c-&lt;span&gt;29&lt;/span&gt;-&lt;span&gt;60&lt;/span&gt;-&lt;span&gt;50&lt;/span&gt;-8b, net=&lt;span&gt;169.254&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;/&lt;span&gt;16&lt;/span&gt;, mask=&lt;span&gt;255.255&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;, use=haip:cluster_interconnect/&lt;span&gt;62&lt;/span&gt;&lt;span&gt;]
Public Interface &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;eth0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; configured from GPnP &lt;span&gt;for&lt;/span&gt;&lt;span&gt; use as a public interface.
  [name&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;eth0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, type=&lt;span&gt;1&lt;/span&gt;, ip=&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;180.100&lt;/span&gt;, mac=&lt;span&gt;00&lt;/span&gt;-0c-&lt;span&gt;29&lt;/span&gt;-&lt;span&gt;60&lt;/span&gt;-&lt;span&gt;50&lt;/span&gt;-&lt;span&gt;81&lt;/span&gt;, net=&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;180.0&lt;/span&gt;/&lt;span&gt;24&lt;/span&gt;, mask=&lt;span&gt;255.255&lt;/span&gt;.&lt;span&gt;255.0&lt;/span&gt;, use=public/&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]
Picked latch&lt;/span&gt;-&lt;span&gt;free&lt;/span&gt; SCN scheme &lt;span&gt;3&lt;/span&gt;&lt;span&gt;
Using LOG_ARCHIVE_DEST_1 parameter default value as &lt;/span&gt;/u01/app/&lt;span&gt;11.2&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;/grid/dbs/&lt;span&gt;arch
Autotune of undo retention is turned on.
LICENSE_MAX_USERS &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
SYS auditing is disabled
NOTE: Volume support  enabled
Starting up:
Oracle Database 11g Enterprise Edition Release &lt;/span&gt;&lt;span&gt;11.2&lt;/span&gt;.&lt;span&gt;0.4&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt; -&lt;span&gt; 64bit Production
With the Real Application Clusters and Automatic Storage Management options.
ORACLE_HOME &lt;/span&gt;= /u01/app/&lt;span&gt;11.2&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;/&lt;span&gt;grid
System name:    Linux
Node name:      rac1.example.com
Release:        &lt;/span&gt;&lt;span&gt;2.6&lt;/span&gt;.&lt;span&gt;32&lt;/span&gt;-&lt;span&gt;573&lt;/span&gt;&lt;span&gt;.el6.x86_64
Version:        #&lt;/span&gt;&lt;span&gt;1&lt;/span&gt; SMP Wed Jul &lt;span&gt;1&lt;/span&gt; &lt;span&gt;18&lt;/span&gt;:&lt;span&gt;23&lt;/span&gt;:&lt;span&gt;37&lt;/span&gt; EDT &lt;span&gt;2015&lt;/span&gt;&lt;span&gt;
Machine:        x86_64
VM name:        VMWare Version: &lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;
Using parameter settings &lt;/span&gt;&lt;span&gt;in&lt;/span&gt; server-side spfile +OCR/rac-cluster/asmparameterfile/registry.&lt;span&gt;253.1034884609&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;DB的警告日志，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
Thu Jul &lt;span&gt;02&lt;/span&gt; &lt;span&gt;09&lt;/span&gt;:&lt;span&gt;02&lt;/span&gt;:&lt;span&gt;47&lt;/span&gt; &lt;span&gt;2020&lt;/span&gt;&lt;span&gt;
Adjusting the default value of parameter parallel_max_servers
from &lt;/span&gt;&lt;span&gt;160&lt;/span&gt; to &lt;span&gt;120&lt;/span&gt; due to the value of parameter processes (&lt;span&gt;150&lt;/span&gt;&lt;span&gt;)
Starting ORACLE instance (normal)
LICENSE_MAX_SESSION &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
LICENSE_SESSIONS_WARNING &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
Initial number of CPU is &lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;
Number of processor cores &lt;/span&gt;&lt;span&gt;in&lt;/span&gt; the system is &lt;span&gt;4&lt;/span&gt;&lt;span&gt;
Number of processor sockets &lt;/span&gt;&lt;span&gt;in&lt;/span&gt; the system is &lt;span&gt;2&lt;/span&gt;&lt;span&gt;
Private Interface &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;eth1:1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; configured from GPnP &lt;span&gt;for&lt;/span&gt;&lt;span&gt; use as a private interconnect.
  [name&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;eth1:1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, type=&lt;span&gt;1&lt;/span&gt;, ip=&lt;span&gt;169.254&lt;/span&gt;.&lt;span&gt;146.181&lt;/span&gt;, mac=&lt;span&gt;00&lt;/span&gt;-0c-&lt;span&gt;29&lt;/span&gt;-&lt;span&gt;60&lt;/span&gt;-&lt;span&gt;50&lt;/span&gt;-8b, net=&lt;span&gt;169.254&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;/&lt;span&gt;16&lt;/span&gt;, mask=&lt;span&gt;255.255&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;, use=haip:cluster_interconnect/&lt;span&gt;62&lt;/span&gt;&lt;span&gt;]
Public Interface &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;eth0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; configured from GPnP &lt;span&gt;for&lt;/span&gt;&lt;span&gt; use as a public interface.
  [name&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;eth0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, type=&lt;span&gt;1&lt;/span&gt;, ip=&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;180.100&lt;/span&gt;, mac=&lt;span&gt;00&lt;/span&gt;-0c-&lt;span&gt;29&lt;/span&gt;-&lt;span&gt;60&lt;/span&gt;-&lt;span&gt;50&lt;/span&gt;-&lt;span&gt;81&lt;/span&gt;, net=&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;180.0&lt;/span&gt;/&lt;span&gt;24&lt;/span&gt;, mask=&lt;span&gt;255.255&lt;/span&gt;.&lt;span&gt;255.0&lt;/span&gt;, use=public/&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]
Public Interface &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;eth0:2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; configured from GPnP &lt;span&gt;for&lt;/span&gt;&lt;span&gt; use as a public interface.
  [name&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;eth0:2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, type=&lt;span&gt;1&lt;/span&gt;, ip=&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;180.111&lt;/span&gt;, mac=&lt;span&gt;00&lt;/span&gt;-0c-&lt;span&gt;29&lt;/span&gt;-&lt;span&gt;60&lt;/span&gt;-&lt;span&gt;50&lt;/span&gt;-&lt;span&gt;81&lt;/span&gt;, net=&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;180.0&lt;/span&gt;/&lt;span&gt;24&lt;/span&gt;, mask=&lt;span&gt;255.255&lt;/span&gt;.&lt;span&gt;255.0&lt;/span&gt;, use=public/&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]
Picked latch&lt;/span&gt;-&lt;span&gt;free&lt;/span&gt; SCN scheme &lt;span&gt;3&lt;/span&gt;&lt;span&gt;
Autotune of undo retention is turned on.
LICENSE_MAX_USERS &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
SYS auditing is disabled
Starting up:
Oracle Database 11g Enterprise Edition Release &lt;/span&gt;&lt;span&gt;11.2&lt;/span&gt;.&lt;span&gt;0.4&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt; -&lt;span&gt; 64bit Production
With the Partitioning, Real Application Clusters, OLAP, Data Mining
and Real Application Testing options.
ORACLE_HOME &lt;/span&gt;= /u01/app/oracle/product/&lt;span&gt;11.2&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;/&lt;span&gt;db_1
System name:    Linux
Node name:      rac1.example.com
Release:        &lt;/span&gt;&lt;span&gt;2.6&lt;/span&gt;.&lt;span&gt;32&lt;/span&gt;-&lt;span&gt;573&lt;/span&gt;.el6.x86_64
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;可以看到，日志开头全都是2020年07月02日的9点初。&lt;/p&gt;

&lt;p&gt;我们再看看归档的情况，&lt;/p&gt;
&lt;p&gt;在此之前，先删除之前的所有归档便于观察。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[&lt;/span&gt;&lt;span&gt;oracle@rac2 ~&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;$ rman target &lt;span&gt;/&lt;/span&gt;&lt;span&gt;

Recovery Manager: Release &lt;/span&gt;&lt;span&gt;11.2&lt;/span&gt;.&lt;span&gt;0.4&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt; &lt;span&gt;-&lt;/span&gt; Production &lt;span&gt;on&lt;/span&gt; Fri Jul &lt;span&gt;3&lt;/span&gt; &lt;span&gt;00&lt;/span&gt;:&lt;span&gt;20&lt;/span&gt;:&lt;span&gt;01&lt;/span&gt; &lt;span&gt;2020&lt;/span&gt;&lt;span&gt;

Copyright (c) &lt;/span&gt;&lt;span&gt;1982&lt;/span&gt;, &lt;span&gt;2011&lt;/span&gt;, Oracle &lt;span&gt;and/or&lt;/span&gt; its affiliates.  &lt;span&gt;All&lt;/span&gt;&lt;span&gt; rights reserved.

connected &lt;/span&gt;&lt;span&gt;to&lt;/span&gt; target &lt;span&gt;database&lt;/span&gt;: ZKM (DBID&lt;span&gt;=&lt;/span&gt;&lt;span&gt;4210149549&lt;/span&gt;&lt;span&gt;)

RMAN&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;delete&lt;/span&gt; force noprompt archivelog &lt;span&gt;all&lt;/span&gt;&lt;span&gt;;

using target &lt;/span&gt;&lt;span&gt;database&lt;/span&gt; control &lt;span&gt;file&lt;/span&gt; instead &lt;span&gt;of&lt;/span&gt;&lt;span&gt; recovery catalog
allocated channel: ORA_DISK_1
channel ORA_DISK_1: SID&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;200&lt;/span&gt; instance&lt;span&gt;=&lt;/span&gt;zkm2 device type&lt;span&gt;=&lt;/span&gt;&lt;span&gt;DISK&lt;/span&gt;&lt;span&gt;
List &lt;/span&gt;&lt;span&gt;of&lt;/span&gt; Archived &lt;span&gt;Log&lt;/span&gt; Copies &lt;span&gt;for&lt;/span&gt; &lt;span&gt;database&lt;/span&gt; &lt;span&gt;with&lt;/span&gt;&lt;span&gt; db_unique_name ZKM
&lt;/span&gt;&lt;span&gt;=====================================================================&lt;/span&gt;

&lt;span&gt;Key&lt;/span&gt;&lt;span&gt;     Thrd Seq     S Low Time 
&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;----- ---- ------- - ---------&lt;/span&gt;
&lt;span&gt;91&lt;/span&gt;      &lt;span&gt;1&lt;/span&gt;    &lt;span&gt;56&lt;/span&gt;      A &lt;span&gt;02&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;JUL&lt;span&gt;-&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;
        Name: &lt;/span&gt;&lt;span&gt;+&lt;/span&gt;ARCH&lt;span&gt;/&lt;/span&gt;zkm&lt;span&gt;/&lt;/span&gt;archivelog&lt;span&gt;/&lt;/span&gt;2020_07_&lt;span&gt;03&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;thread_1_seq_56.&lt;span&gt;303.1044695873&lt;/span&gt;

&lt;span&gt;92&lt;/span&gt;      &lt;span&gt;2&lt;/span&gt;    &lt;span&gt;21&lt;/span&gt;      A &lt;span&gt;02&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;JUL&lt;span&gt;-&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;
        Name: &lt;/span&gt;&lt;span&gt;+&lt;/span&gt;ARCH&lt;span&gt;/&lt;/span&gt;zkm&lt;span&gt;/&lt;/span&gt;archivelog&lt;span&gt;/&lt;/span&gt;2020_07_&lt;span&gt;02&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;thread_2_seq_21.&lt;span&gt;299.1044695875&lt;/span&gt;&lt;span&gt;

deleted archived &lt;/span&gt;&lt;span&gt;log&lt;/span&gt;&lt;span&gt;
archived &lt;/span&gt;&lt;span&gt;log&lt;/span&gt; &lt;span&gt;file&lt;/span&gt; name&lt;span&gt;=+&lt;/span&gt;ARCH&lt;span&gt;/&lt;/span&gt;zkm&lt;span&gt;/&lt;/span&gt;archivelog&lt;span&gt;/&lt;/span&gt;2020_07_&lt;span&gt;03&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;thread_1_seq_56.&lt;span&gt;303.1044695873&lt;/span&gt; RECID&lt;span&gt;=&lt;/span&gt;&lt;span&gt;91&lt;/span&gt; STAMP&lt;span&gt;=&lt;/span&gt;&lt;span&gt;1044749873&lt;/span&gt;&lt;span&gt;
deleted archived &lt;/span&gt;&lt;span&gt;log&lt;/span&gt;&lt;span&gt;
archived &lt;/span&gt;&lt;span&gt;log&lt;/span&gt; &lt;span&gt;file&lt;/span&gt; name&lt;span&gt;=+&lt;/span&gt;ARCH&lt;span&gt;/&lt;/span&gt;zkm&lt;span&gt;/&lt;/span&gt;archivelog&lt;span&gt;/&lt;/span&gt;2020_07_&lt;span&gt;02&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;thread_2_seq_21.&lt;span&gt;299.1044695875&lt;/span&gt; RECID&lt;span&gt;=&lt;/span&gt;&lt;span&gt;92&lt;/span&gt; STAMP&lt;span&gt;=&lt;/span&gt;&lt;span&gt;1044695874&lt;/span&gt;&lt;span&gt;
Deleted &lt;/span&gt;&lt;span&gt;2&lt;/span&gt; objects
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中一个节点发出命令归档redo log，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
SYS&lt;span&gt;@zkm1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;alter&lt;/span&gt; session &lt;span&gt;set&lt;/span&gt; nls_date_format&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;yyyy-mm-dd hh24:mi:ss&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

Session altered.

SYS&lt;/span&gt;&lt;span&gt;@zkm1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt; 
SYS&lt;/span&gt;&lt;span&gt;@zkm1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;select&lt;/span&gt; sysdate &lt;span&gt;from&lt;/span&gt;&lt;span&gt; dual;

SYSDATE
&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;----------------------&lt;/span&gt;
&lt;span&gt;&lt;span&gt;2020&lt;/span&gt;-&lt;span&gt;07&lt;/span&gt;-&lt;span&gt;03&lt;/span&gt; &lt;span&gt;00&lt;/span&gt;:&lt;span&gt;20&lt;/span&gt;:&lt;span&gt;27&lt;/span&gt;&lt;/span&gt;&lt;span&gt;

SYS&lt;/span&gt;&lt;span&gt;@zkm1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;alter&lt;/span&gt; system archive &lt;span&gt;log&lt;/span&gt; &lt;span&gt;current&lt;/span&gt;&lt;span&gt;;

System altered.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;观察警告日志，显示的时间是“Thu Jul 02 09:20:32 2020”。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
Thu Jul &lt;span&gt;02&lt;/span&gt; &lt;span&gt;09&lt;/span&gt;:&lt;span&gt;20&lt;/span&gt;:&lt;span&gt;32&lt;/span&gt; &lt;span&gt;2020&lt;/span&gt;&lt;span&gt;
Thread &lt;/span&gt;&lt;span&gt;1&lt;/span&gt; advanced &lt;span&gt;to&lt;/span&gt; &lt;span&gt;log&lt;/span&gt; sequence &lt;span&gt;58&lt;/span&gt;&lt;span&gt; (LGWR switch)
  &lt;/span&gt;&lt;span&gt;Current&lt;/span&gt; &lt;span&gt;log&lt;/span&gt;# &lt;span&gt;2&lt;/span&gt; seq# &lt;span&gt;58&lt;/span&gt; mem# &lt;span&gt;0&lt;/span&gt;: &lt;span&gt;+&lt;/span&gt;DATA&lt;span&gt;/&lt;/span&gt;zkm&lt;span&gt;/&lt;/span&gt;onlinelog&lt;span&gt;/&lt;/span&gt;group_2.&lt;span&gt;258.1034889845&lt;/span&gt;
  &lt;span&gt;Current&lt;/span&gt; &lt;span&gt;log&lt;/span&gt;# &lt;span&gt;2&lt;/span&gt; seq# &lt;span&gt;58&lt;/span&gt; mem# &lt;span&gt;1&lt;/span&gt;: &lt;span&gt;+&lt;/span&gt;ARCH&lt;span&gt;/&lt;/span&gt;zkm&lt;span&gt;/&lt;/span&gt;onlinelog&lt;span&gt;/&lt;/span&gt;group_2.&lt;span&gt;258.1034889845&lt;/span&gt;&lt;span&gt;
Thu Jul &lt;/span&gt;&lt;span&gt;02&lt;/span&gt; &lt;span&gt;09&lt;/span&gt;:&lt;span&gt;20&lt;/span&gt;:&lt;span&gt;32&lt;/span&gt; &lt;span&gt;2020&lt;/span&gt;&lt;span&gt;
Archived &lt;/span&gt;&lt;span&gt;Log&lt;/span&gt; entry &lt;span&gt;93&lt;/span&gt; added &lt;span&gt;for&lt;/span&gt; thread &lt;span&gt;1&lt;/span&gt; sequence &lt;span&gt;57&lt;/span&gt; ID &lt;span&gt;0xfaf1eead&lt;/span&gt; dest &lt;span&gt;1&lt;/span&gt;:
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;进去ASM磁盘查看文件情况，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
ASMCMD&lt;span&gt;&amp;gt;&lt;/span&gt; ls &lt;span&gt;-&lt;/span&gt;&lt;span&gt;l
Type  Redund  Striped  Time             Sys  Name
                                        Y    2020_07_&lt;/span&gt;&lt;span&gt;02&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;
ASMCMD&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; ls &lt;span&gt;-&lt;/span&gt;l &lt;span&gt;*&lt;/span&gt;&lt;span&gt;
Type        Redund  Striped  Time             Sys  Name
ARCHIVELOG  UNPROT  COARSE   JUL &lt;/span&gt;&lt;span&gt;02&lt;/span&gt; &lt;span&gt;09&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;  Y    thread_1_seq_57.&lt;span&gt;299.1044696033&lt;/span&gt;&lt;span&gt;
ARCHIVELOG  UNPROT  COARSE   JUL &lt;/span&gt;&lt;span&gt;02&lt;/span&gt; &lt;span&gt;09&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;  Y    thread_2_seq_22.&lt;span&gt;303.1044696033&lt;/span&gt;&lt;span&gt;
ASMCMD&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt; pwd
&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;arch&lt;span&gt;/&lt;/span&gt;zkm&lt;span&gt;/&lt;/span&gt;ARCHIVELOG
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;至此，问题完全重现成功。&lt;/p&gt;

&lt;h2&gt;原因&lt;/h2&gt;
&lt;p&gt;不知道各位发现没有，实际上最开始启动集群（crsctl start crs）那一瞬间（大概是2020-07-03 00:00:00多，刚改完时间不到1分钟），&lt;/p&gt;
&lt;p&gt;集群的警告日志最开始出现的时间为“2020-07-02 09:00:26.667:”，基本相差15小时。&lt;/p&gt;
&lt;p&gt;因此很容易也可以猜出，是由于时区的原因。&lt;/p&gt;

&lt;p&gt;系统的时区为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[grid@rac1 ~]$ &lt;span&gt;cat&lt;/span&gt; /etc/sysconfig/&lt;span&gt;clock 
# The &lt;/span&gt;&lt;span&gt;time&lt;/span&gt; zone of the system is defined by the contents of /etc/&lt;span&gt;localtime.
# This &lt;/span&gt;&lt;span&gt;file&lt;/span&gt; is only &lt;span&gt;for&lt;/span&gt; evaluation by system-config-&lt;span&gt;date&lt;/span&gt;, &lt;span&gt;do&lt;/span&gt;&lt;span&gt; not rely on its
# contents elsewhere.
ZONE&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Asia/Shanghai&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;那么，集群应该也有自己的配置文件对应的时区，也就是集群不依赖OS的时区（-_-||）。&lt;/p&gt;
&lt;p&gt;mos可以找到这么一篇文章：&lt;strong&gt;&lt;span&gt;How To Change Timezone for Grid Infrastructure (Doc ID 1209444.1)&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因此可以发现&lt;strong&gt;Grid Infrastructure&lt;/strong&gt;的时区配置文件位置在$GRID_HOME/crs/install/s_crsconfig_&amp;lt;nodename&amp;gt;_env.txt。&lt;/p&gt;

&lt;p&gt;所以，现象的模拟其实，就是我把该文件的时区改成如下了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
[grid@rac1 ~]$ cd $ORACLE_HOME/crs/&lt;span&gt;install&lt;/span&gt;&lt;span&gt;
[grid@rac1 &lt;/span&gt;&lt;span&gt;install&lt;/span&gt;]$ &lt;span&gt;ls&lt;/span&gt;&lt;span&gt;
cmdllroot.&lt;/span&gt;&lt;span&gt;sh&lt;/span&gt;              crsconfig_lib.pm      crsdelete.pm   inittab       installRemove.excl  oracle-&lt;span&gt;ohasd.conf     paramfile.crs           rootcrs.pl  s_crsconfig_defs          s_crsconfig_rac1_env.txt.bak
crsconfig_addparams.sbs   crsconfig_params      crspatch.pm    &lt;/span&gt;&lt;span&gt;install&lt;/span&gt;.excl  onsconfig           oracle-ohasd.service  ParentDirPerm_rac1.txt  roothas.pl  s_crsconfig_lib.pm        tfa_setup.&lt;span&gt;sh&lt;/span&gt;&lt;span&gt;
crsconfig_fileperms.excl  crsconfig_params.sbs  hasdconfig.pl  &lt;/span&gt;&lt;span&gt;install&lt;/span&gt;.incl  oraacfs.pm          oracss.pm             preupdate.&lt;span&gt;sh&lt;/span&gt;            rootofs.&lt;span&gt;sh&lt;/span&gt;&lt;span&gt;  s_crsconfig_rac1_env.txt
[grid@rac1 &lt;/span&gt;&lt;span&gt;install&lt;/span&gt;]$ &lt;span&gt;cat&lt;/span&gt;&lt;span&gt; s_crsconfig_rac1_env.txt
### This &lt;/span&gt;&lt;span&gt;file&lt;/span&gt; can be used to modify the NLS_LANG environment variable, &lt;span&gt;which&lt;/span&gt; determines the charset to be used &lt;span&gt;for&lt;/span&gt;&lt;span&gt; messages.
### For example, a new charset can be configured by setting NLS_LANG&lt;/span&gt;=&lt;span&gt;JAPANESE_JAPAN.UTF8 
### Do not modify this &lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt; except to change NLS_LANG, or under the direction of Oracle Support Services

TZ&lt;/span&gt;=&lt;span&gt;&lt;strong&gt;US/&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;Pacific&lt;/strong&gt;&lt;/span&gt;
NLS_LANG&lt;/span&gt;=&lt;span&gt;AMERICAN_AMERICA.AL32UTF8
TNS_ADMIN&lt;/span&gt;=&lt;span&gt;
ORACLE_BASE&lt;/span&gt;=
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;网上找找看是不是刚好和上海时间相差15个小时。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://time.is/PT&quot; target=&quot;_blank&quot;&gt;https://time.is/PT&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1152369/202007/1152369-20200702231154571-1207241314.png&quot; width=&quot;1642&quot; height=&quot;2281&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt;得证！！！&lt;/p&gt;

</description>
<pubDate>Thu, 02 Jul 2020 15:06:00 +0000</pubDate>
<dc:creator>PiscesCanon</dc:creator>
<og:description>Oracle归档日志所在目录时间不对&amp;amp;&amp;amp;Oracle集群日志时间显示错误 前言 这个问题在18年的时候遇到了，基本不注意并且集群或者数据库运行正常是很难注意到的。 忘记当时怎么发现的了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/PiscesCanon/p/13227764.html</dc:identifier>
</item>
<item>
<title>前端JS 下载大文件解决方案 - 辉是暖阳辉</title>
<link>http://www.cnblogs.com/mrwh/p/13227709.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mrwh/p/13227709.html</guid>
<description>&lt;h2 id=&quot;问题场景&quot;&gt;问题场景&lt;/h2&gt;
&lt;p&gt;点击导出按钮，提交请求，下载excel大文件（超过500M），该文件没有预生成在后端，&lt;br/&gt;直接以文件流的形式返回给前端。&lt;/p&gt;
&lt;h2 id=&quot;解决方案&quot;&gt;解决方案&lt;/h2&gt;
&lt;p&gt;在Vue项目中常用的方式是通过axios配置请求，读取后端返回的文件流，常用代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;axios({
    method: 'post',
    url: 'api/file',
    responseType: 'blob'
}).then(res=&amp;gt; {
     if (res.data){
      filename = 'filename';
      let blob = new Blob([res.data],{type:&quot;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;charset=UTF-8&quot;});
      if (window.navigator.msSaveOrOpenBlob){
          // IE10+下载
        navigator.msSaveOrBlob(blob, filename);
      }else{
          // 非IE10+下载
        let link = document.createElement('a');
        link.href = window.URL.createObjectURL(blob);
        link.download = filename;
        document.body.appendChild(link);
        var evt = document.createEvent(&quot;MouseEvents&quot;);
        evt.initEvent(&quot;click&quot;, false, false);
        link.dispatchEvent(evt);//释放URL 对象
        document.body.removeChild(link);
      }
}).catch((error) =&amp;gt; {
  console.log(error)
})

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种方式是把文件流读取到浏览器内存中，再下载，但是今天在这种大文件场景下它不香了，&lt;br/&gt;由于内存过大，直接把网页给搞崩了，喔豁😂&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1619281/202007/1619281-20200702224045623-1391402897.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;怎么办呢，终于在Github上找到了一个大神的库，用起来真香，&lt;a href=&quot;https://github.com/eligrey/FileSaver.js&quot;&gt;Github地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;根据介绍，在chrome浏览器2G以下的文件下载可以得到很好的支持&lt;/p&gt;
&lt;h2 id=&quot;使用步骤&quot;&gt;使用步骤&lt;/h2&gt;
&lt;h3 id=&quot;1安装npm依赖&quot;&gt;1.安装npm依赖&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;npm install file-saver --save&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;2引入代码&quot;&gt;2.引入代码&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;+ import { saveAs } from 'file-saver';
...
+      saveAs(blob, fileName );

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;3完整例子&quot;&gt;3.完整例子&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;+ import { saveAs } from 'file-saver';
  axios({
    method: 'post',
    url: 'api/file',
    responseType: 'blob'
}).then(res=&amp;gt; {
     if (res.data){
       fileName = this.fileName;
      // 有文件名就用自定义的，没有就从header获取
        if (!fileName) {
          fileName = fileNameFromHeader(
            res.headers[&quot;content-disposition&quot;] || &quot;&quot;
          );
        }
        
      let blob = new Blob([res.data],{
      type:&quot;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;charset=UTF-8&quot;});
+      saveAs(blob, fileName );
      }
}).catch((error) =&amp;gt; {
  console.log(error)
})

function fileNameFromHeader(disposition) {
  let result = null;
  disposition = disposition.split(&quot;;&quot;)[1];
  if (disposition &amp;amp;&amp;amp; /filename=.*/gi.test(disposition)) {
    result = disposition.match(/filename=.*/gi);
    return decodeURIComponent((result[0].split(&quot;=&quot;)[1]).replace(/\+/g, '%20'));
  }
  return &quot;null&quot;;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;4其他问题&quot;&gt;4.其他问题&lt;/h3&gt;
&lt;p&gt;下载大文件过程中遇到的其他问题&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;axios请求超时，注意配置timeout&lt;/li&gt;
&lt;li&gt;Nginx 响应超时报504 网关超时错误，注意配置Nginx&lt;/li&gt;
&lt;li&gt;控制台报error response，浏览器请求长时间得不到响应，本地调试代理转发超时造成的，&lt;a href=&quot;https://segmentfault.com/q/1010000017751671&quot;&gt;参考&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/eligrey/FileSaver.js/issues/163&quot;&gt;文件超过2G的解决方案&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Thu, 02 Jul 2020 14:56:00 +0000</pubDate>
<dc:creator>辉是暖阳辉</dc:creator>
<og:description>问题场景 点击导出按钮，提交请求，下载excel大文件（超过500M），该文件没有预生成在后端， 直接以文件流的形式返回给前端。 解决方案 在Vue项目中常用的方式是通过axios配置请求，读取后端返</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mrwh/p/13227709.html</dc:identifier>
</item>
<item>
<title>还不会浮点数转二进制？下次有人问你，直接把这篇文章扔给他 - codevald</title>
<link>http://www.cnblogs.com/codevald/p/codevald8.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/codevald/p/codevald8.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;作为一名程序猿，假如某一天，有一个妹子拿着一个浮点数，求你教她怎么换算成二进制，如果你不能单手求出来，你都不能算一个合格的工具人.....好吧，是一个合格的程序猿(狗头保命)。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200702100810265.jpg#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;回归正题，有好多小伙伴去工作之后，早已经忘了最基本的计算机基础，今天，来讲下，在计算机中，怎么用二进制表示浮点数？下次再有人问你，就把这篇文章丢给他。&lt;/p&gt;
&lt;p&gt;作为一种数据类型，浮点数应用广泛。在处理诸如订单交易、货币计算、或者商品金额的方面，应该小心慎用浮点数。在定义浮点数变量的时候，不完全理解原理，就容易出现各种揪心的问题。&lt;/p&gt;
&lt;p&gt;那么，正题来了。&lt;/p&gt;
&lt;p&gt;浮点数在计算机中的存储方式遵循&lt;strong&gt;IEEE 754浮点数的计数标准&lt;/strong&gt;，那么，IEEE 754浮点数的计数标准怎么表示浮点数的？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;浮点数数学表示：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200702102615580.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;符号位(sign)：决定该浮点数的正负&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;尾数(significand)：二进制小数，范围在[1,2)或者[0,1)中&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;阶码(exponent)：对浮点数加权，权重为2的E次幂&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;IEEE标准754规定了三种浮点数格式：单精度、双精度、扩展精度。前两者正好对应C语言里头的float、double，限于篇幅，本文仅讨论单精度、双精度浮点格式。&lt;/p&gt;
&lt;p&gt;其实，IEEE754标准可以概括成一张图片，如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200702104235104.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTY5NTk5NQ==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;采用&lt;strong&gt;尾数+阶码&lt;/strong&gt;的编码方式。其实就是在我们学过的数学知识中，就是类似于科学计数法。即有&lt;strong&gt;效数字+指数位&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;所以，只要给出：符号（S）、尾数部分（M）、阶码部分这三种信息，就可以正确的表示一个浮点数。在C语言中，浮点数的数据类型最常用的就是float、double，那么，他们在计算机中的存储结构是怎样的呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200702113203644.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTY5NTk5NQ==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200702113346124.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTY5NTk5NQ==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;浮点数的各个部分的含义如下表格所示&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;符号部分（S）&lt;/th&gt;
&lt;th&gt;阶码部分（E）&lt;/th&gt;
&lt;th&gt;尾数部分（M）&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;4.5&quot;&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td&gt;0表示正（+），1表示负（-）&lt;/td&gt;
&lt;td&gt;阶码部分其实就是指数部分 &lt;code&gt;float&lt;/code&gt; 指数部分8位，可以表示的指数范围位-127~128 &lt;code&gt;double&lt;/code&gt; 指数部分11位，可以表示的指数范围位-1023~1024&lt;/td&gt;
&lt;td&gt;决定浮点数的精度 &lt;code&gt;float&lt;/code&gt; 尾数部分23位，换算成十进制为2&lt;sup&gt;23&lt;/sup&gt; =8388608，因此精度为6~7位 &lt;code&gt;double&lt;/code&gt; 尾数部分23位，换算成十进制为2&lt;sup&gt;52&lt;/sup&gt; =4503599627370496，因此精度为15~16位&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;结论&quot;&gt;结论&lt;/h4&gt;
&lt;p&gt;浮点数交给计算机存储的，可能会有&lt;strong&gt;精度的丢失问题&lt;/strong&gt;，出了问题的话，在大型的项目中，是很难找出问题的，因此提前做好规划与计算是有必要的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200702173133869.jpg#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;计算实例&quot;&gt;计算实例&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;第一个例子&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;把十进制小数0.475转换成二进制，具体应该怎么操作？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 将小数划分成整数+小数两部分&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 整数部分转换&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;转换采用&lt;strong&gt;除2取余法&lt;/strong&gt;，此处的&lt;code&gt;0.475&lt;/code&gt;的整数部分为0，不需要操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 小数部分转换&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;转换采用&lt;strong&gt;乘2取整法&lt;/strong&gt;。详细看下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200702202226626.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTY5NTk5NQ==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;strong&gt;3. 合并结果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;整数部分+小数部分&lt;/code&gt;，得到二进制结果为 0.101.&lt;/p&gt;
&lt;p&gt;根据IEEE754标准，即&lt;strong&gt;符号位+尾数+阶码&lt;/strong&gt;的计数方式，可以表示为&lt;/p&gt;
&lt;h4 id=&quot;101-×-2-1&quot;&gt;1.01 × 2&lt;sup&gt;-1&lt;/sup&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;符号位&lt;/strong&gt;：0&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;阶码部分&lt;/strong&gt;：以&lt;strong&gt;float&lt;/strong&gt;为例子，则为 127 + （-1）=126，所以二进制为：01111110&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;尾数部分&lt;/strong&gt;：以&lt;strong&gt;floa&lt;/strong&gt;t为例子，应为 23位，尾数补齐之后为0100000000000000000000&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;最终结果为（以float表示）&lt;/p&gt;
&lt;p&gt;0011111100100000000000000000000&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二个例子&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;把十进制小数8.26转换成二进制，具体应该怎么操作？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200702214607623.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTY5NTk5NQ==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;code&gt;整数部分+小数部分&lt;/code&gt; 得到二进制结果为&lt;strong&gt;1000.0100001 .....&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;根据IEEE754标准，即&lt;strong&gt;符号位+尾数+阶码&lt;/strong&gt;的计数方式，可以表示为&lt;/p&gt;
&lt;h4 id=&quot;10000100001-×-2-3&quot;&gt;1.0000100001 × 2 &lt;sup&gt;3&lt;/sup&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;符号位&lt;/strong&gt;：0&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;阶码部分&lt;/strong&gt;：以&lt;strong&gt;float&lt;/strong&gt;为例子，则为 127 + （3）=130，所以二进制为：10000010&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;尾数部分&lt;/strong&gt;：&lt;code&gt;0.0000100001...,&lt;/code&gt;,它本身无限不循环，但是如果以 &lt;strong&gt;floa&lt;/strong&gt;t 为例子，截取 23位，表示为00001000010100011110110&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;最终结果为（以float表示）&lt;/p&gt;
&lt;p&gt;01000001 00000100 00101000 11110110&lt;/p&gt;
&lt;p&gt;因此，对于这种无限位数的小数，用计算机去存储必然会导致&lt;strong&gt;精度的损失&lt;/strong&gt;。所以，各位在使用过程中一定要谨慎小心。&lt;/p&gt;
&lt;h4 id=&quot;结语&quot;&gt;结语&lt;/h4&gt;
&lt;p&gt;浮点数转换为二进制就讲解到这里了，觉得有用的老铁们，请点赞关注我吧，另外，关注我的老铁们可以私聊我，获取&lt;strong&gt;浮点数转换为二进制的神器&lt;/strong&gt;，这样子，再也不用自己手撕浮点数转为二进制了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200702220511951.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTY5NTk5NQ==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;如果觉得我写的不错的话，帮个忙呗&quot;&gt;如果觉得我写的不错的话，帮个忙呗&lt;/h2&gt;
&lt;h5 id=&quot;1关注我的知乎账号小丛，上面有我的文章同步，同时需要询问学习计算机经验的话，也欢迎私聊。&quot;&gt;1.关注我的知乎账号小丛，上面有我的文章同步，同时需要询问学习计算机经验的话，也欢迎私聊。&lt;/h5&gt;
&lt;h5 id=&quot;2点赞，关注我，这是对我最大的鼓励了，有了你们的鼓励，我会写出更多的优质文章。&quot;&gt;2.点赞，关注我，这是对我最大的鼓励了，有了你们的鼓励，我会写出更多的优质文章。&lt;/h5&gt;
</description>
<pubDate>Thu, 02 Jul 2020 14:11:00 +0000</pubDate>
<dc:creator>codevald</dc:creator>
<og:description>作为一名程序猿，假如某一天，有一个妹子拿着一个浮点数，求你教她怎么换算成二进制，如果你不能单手求出来，你都不能算一个合格的工具人.....好吧，是一个合格的程序猿(狗头保命)。 回归正题，有好多小伙伴</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/codevald/p/codevald8.html</dc:identifier>
</item>
<item>
<title>面向切面对象AOP - Tom最好的朋友是Jerry</title>
<link>http://www.cnblogs.com/zxd66666/p/13227403.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zxd66666/p/13227403.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　面向切面编程(思想)AOP Aspect Oriented  Programming，是面向对象基础上 更关注最终目标 而不关注中间的小目标，简而言之，就是我们的目标(例如constroller)触发了我们关注的方法，此时就执行我们的观察者行为，例如在目标的方法触发前做事，触发后做事等等。&lt;/p&gt;
&lt;p&gt;　　为了让大家更好的理解，这里把面向过程、面向对象先讲解一遍。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;面向过程编程(思想)POP&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　Procedure  Oriented  Programming，面向过程编程思想(关注事情步骤，事情本身)，将一件事情的整体看作是一个流程，我们更关注事情的流程、步骤。比如我去超市买菜，我要下楼，等红绿灯，走过几条街道，进入超市选择自己要的菜，然后排队买单。我会关注这些过程要经历的事件，步骤。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;面向对象编程(思想)OOP&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　Object  Oriented  Programming，面向对象编程思想(关注中间有几个对象参与其中)，将原有整体事情的步骤，拆分成小段，每一个小段封装成一个单独的事情(方法)，不同的方法交给不同的人来做，例如我去超市买菜，我在家里出发，最终目的是在超市买菜，中间几个环节交给不同的人(对象)来帮我做：下楼(被人背下去)，打车，选菜，排队等等都有人帮我做，我只要把这些顺序连起来，指挥不同的对象按照我要求的顺序执行便可。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;面向切面编程(思想)AOP&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　Aspect Oriented  Programming，面向切面编程思想(面向对象基础上 更关注最终目标 而不关注中间的小目标)，&lt;strong&gt;&lt;span&gt;但要注意切面本身也是对象&lt;/span&gt;&lt;/strong&gt;，比如我去超市买菜，我为起始对象，超市为目标对象，在我到超市之前所经历的事情都归纳到切面对象(下楼，打车，选菜，排队执行这些方法的人(对象)等等)，连接点(管理切面对象中的方法按顺序执行)，代理对象负责管理这些切面对象，切点为买菜(即在目标对象中触发我们关心的方法)；&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;案例&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　这里就用js模拟了，js模拟简单些，java模拟的话思路也是一样的，而且java的spring本身用xml或注解就可以了，这里主要讲思想&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 面向切面的方式&lt;/span&gt;
class agency{&lt;span&gt;//&lt;/span&gt;&lt;span&gt;可以理解为过滤器&lt;/span&gt;
&lt;span&gt;
  before(){
    console.log(&lt;/span&gt;&quot;走路去超市&quot;&lt;span&gt;);
  }
  
  main(Func){&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;代理对象&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.before();
    Func();
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.after();
  }
  
  after(){
    console.log(&lt;/span&gt;&quot;走路回家&quot;&lt;span&gt;);
  }

}

let agencyObj &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; agency();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;找代理，类似找人帮我们买菜送上门,这方式好处在于其他人还可以找代理买家具，买学习用品等等，我们生成了一次代理，然后传不同的任务进去让代理帮我们执行&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt;  main(){
  money &lt;/span&gt;-= 55&lt;span&gt;;
  console.log(&lt;/span&gt;&quot;买完菜，减去55元,还剩：&quot;+&lt;span&gt;money);
}
agencyObj.main(main);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;结果同上&lt;/span&gt;
&lt;span&gt;
money &lt;/span&gt;= 100&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;  main2(){
  money &lt;/span&gt;-= 98&lt;span&gt;;
  console.log(&lt;/span&gt;&quot;买日用品，减去98元,还剩：&quot;+&lt;span&gt;money);
}
agencyObj.main(main2);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面的before和after方法可以当成过滤器，比如我要得到的数据渲染前先解密，解密渲染后，部分数据用*替换这类场景。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;思路&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　面向切面的方式就是更注重结果而不注重中间实现的步骤，中间无论由多少个切面对象帮你做了事，都由一个代理对象来帮你管理执行，而我们需要做的就是把要做的事告诉代理对象。当然面向切面的方式是否使用要根据业务场景来定，如果发现有多个方法中间需要执行的步骤流程一致，而这些方法只需要拿到经过这些步骤之后所得到的结果，不关心中间发生了什么，就使用面向切面的方式。&lt;/p&gt;

</description>
<pubDate>Thu, 02 Jul 2020 14:00:00 +0000</pubDate>
<dc:creator>Tom最好的朋友是Jerry</dc:creator>
<og:description>前言 面向切面编程(思想)AOP Aspect Oriented Programming，是面向对象基础上 更关注最终目标 而不关注中间的小目标，简而言之，就是我们的目标(例如constroller)</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zxd66666/p/13227403.html</dc:identifier>
</item>
<item>
<title>运用设计模式告别项目中大量臃肿的if else - 我恰芙蓉王</title>
<link>http://www.cnblogs.com/-tang/p/13226887.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/-tang/p/13226887.html</guid>
<description>&lt;p&gt;以前写过的一个老项目中，有这样一个业务场景，比喻：一个外卖系统需要接入多家餐馆，在外卖系统中返回每个餐馆的菜单列表 ，每个餐馆的菜单价格都需要不同的算法计算。&lt;/p&gt;
&lt;p&gt;代码中使用了大量的if else嵌套连接，一个类中数千行代码(眼睛快看瞎...)，而且随着业务的扩展，接入的餐馆会越来越多，每接入一个餐馆都要增加一个 if else，满屏幕密密麻麻的逻辑代码，毫无可读性。然后前段时间进行了代码重构，使用了策略模式+工厂模式+反射代替了这整片的臃肿代码，瞬间神清气爽。&lt;/p&gt;


&lt;p&gt;原代码的简单模拟实现，根据传入的不同餐馆编码获取对应的餐馆类集合，每个餐馆菜单价格的算法都不同。每当需要新接入一家餐馆时，都需要在此增加一个if else，中间加入一大长串的处理逻辑，当餐馆越来越多的时候，代码就变得越来越沉重，维护成本高。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; List server(String hotelCode) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&quot;HotelA&quot;&lt;span&gt;.equals(hotelCode)) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取数据&lt;/span&gt;
        List&amp;lt;HotelA&amp;gt; hotelList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;HotelA&amp;gt;&lt;span&gt;() {
            {
                add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; HotelA(&quot;爆炒腰子&quot;, 100d, 0.8, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;));
                add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; HotelA(&quot;红烧腰子&quot;, 200d, 0.8, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;));
                add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; HotelA(&quot;腰子刺身&quot;, 300d, 0.8, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;));
            }
        };
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;逻辑计算 最终价格 = 原价 * 折扣&lt;/span&gt;
        hotelList.parallelStream().forEach(v -&amp;gt; v.setFinalPrice(v.getPrice() *&lt;span&gt; v.getDiscount()));
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; hotelList;

    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&quot;HotelB&quot;&lt;span&gt;.equals(hotelCode)) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取数据&lt;/span&gt;
        List&amp;lt;HotelB&amp;gt; hotelList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;HotelB&amp;gt;&lt;span&gt;() {
            {
                add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; HotelB(&quot;兰州拉面&quot;, 100d, 10d, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;));
                add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; HotelB(&quot;落魄后端在线炒粉&quot;, 200d, 20d, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;));
            }
        };
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;逻辑计算 最终价格 = 原价 - 优惠&lt;/span&gt;
        hotelList.parallelStream().forEach(v -&amp;gt; v.setFinalPrice(v.getPrice() -&lt;span&gt; v.getPreferential()));
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; hotelList;

    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&quot;HotelC&quot;&lt;span&gt;.equals(hotelCode)) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取数据&lt;/span&gt;
        List&amp;lt;HotelC&amp;gt; hotelList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;HotelC&amp;gt;&lt;span&gt;() {
            {
                add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; HotelC(&quot;秘制奥利给&quot;, 1000d, 0.6, 20d, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;));
                add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; HotelC(&quot;老八辣酱&quot;, 2000d, 0.6, 10d, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;));
            }
        };
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;逻辑计算 最终价格 = 原价 * 折扣 - 服务费&lt;/span&gt;
        hotelList.parallelStream().forEach(v -&amp;gt; v.setFinalPrice(v.getPrice() * v.getDiscount() -&lt;span&gt; v.getTip()));
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; hotelList;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArrayList();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Data
@NoArgsConstructor
@AllArgsConstructor
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HotelA {

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;菜品名&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String menu;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;原价&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Double price;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;折扣&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Double discount;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;最终价格 = 原价 * 折扣&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Double finalPrice;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Data
@NoArgsConstructor
@AllArgsConstructor
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HotelB {

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;菜品名&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String menu;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;原价&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Double price;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;优惠&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Double preferential;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;最终价格 = 原价 - 优惠&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Double finalPrice;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Data
@NoArgsConstructor
@AllArgsConstructor
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HotelC {

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;菜品名&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String menu;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;原价&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Double price;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;折扣&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Double discount;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;服务费&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Double tip;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;最终价格 = 原价 * 折扣 - 服务费&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Double finalPrice;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;由上述代码首先抽离出一个接口，if else中的业务逻辑最终都是返回一个列表&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 餐馆服务接口
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; HotelService {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获取餐馆菜单列表
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    List getMenuList();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;把每个分支的业务逻辑封装成实现类，实现HotelService接口&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; HotelAServiceImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; HotelService {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 逻辑计算 返回集合
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; List getMenuList() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; initList().parallelStream()
                .peek(v &lt;/span&gt;-&amp;gt; v.setFinalPrice(v.getPrice() *&lt;span&gt; v.getDiscount()))
                .collect(Collectors.toList());
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获取数据
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; List&amp;lt;HotelA&amp;gt;&lt;span&gt; initList() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;HotelA&amp;gt;&lt;span&gt;() {
            {
                add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; HotelA(&quot;爆炒腰子&quot;, 100d, 0.8, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;));
                add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; HotelA(&quot;红烧腰子&quot;, 200d, 0.8, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;));
                add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; HotelA(&quot;腰子刺身&quot;, 300d, 0.8, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;));
            }
        };
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; HotelBServiceImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; HotelService {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 逻辑计算 返回集合
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; List getMenuList() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; initList().parallelStream()
                .peek(v &lt;/span&gt;-&amp;gt; v.setFinalPrice(v.getPrice() -&lt;span&gt; v.getPreferential()))
                .collect(Collectors.toList());
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获取数据
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; List&amp;lt;HotelB&amp;gt;&lt;span&gt; initList() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;HotelB&amp;gt;&lt;span&gt;() {
            {
                add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; HotelB(&quot;兰州拉面&quot;, 100d, 10d, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;));
                add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; HotelB(&quot;落魄后端在线炒粉&quot;, 200d, 20d, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;));
            }
        };
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; HotelCServiceImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; HotelService {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 逻辑计算 返回集合
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; List getMenuList() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; initList().parallelStream()
                .peek(v &lt;/span&gt;-&amp;gt; v.setFinalPrice(v.getPrice() * v.getDiscount() -&lt;span&gt; v.getTip()))
                .collect(Collectors.toList());
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获取数据
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; List&amp;lt;HotelC&amp;gt;&lt;span&gt; initList() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;HotelC&amp;gt;&lt;span&gt;() {
            {
                add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; HotelC(&quot;秘制奥利给&quot;, 1000d, 0.6, 20d, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;));
                add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; HotelC(&quot;老八辣酱&quot;, 2000d, 0.6, 10d, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;));
            }
        };
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样就是一个简单的策略模式了，但是现在要调用不同的实现类中的getMenuList方法，好像还是离不开if else，那么现在就需要用工厂模式把所有实现类包装起来。&lt;/p&gt;
&lt;p&gt;先定义一个枚举类，里面是各餐馆的code&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; HotelEnum {

    HOTEL_A(&lt;/span&gt;&quot;HotelA&quot;&lt;span&gt;),
    HOTEL_B(&lt;/span&gt;&quot;HotelB&quot;&lt;span&gt;),
    HOTEL_C(&lt;/span&gt;&quot;HotelC&quot;&lt;span&gt;),;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String hotelCode;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 返回所有餐馆编码的集合
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; List&amp;lt;String&amp;gt;&lt;span&gt; getList() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Arrays.asList(HotelEnum.values())
                .stream()
                .map(HotelEnum::getHotelCode)
                .collect(Collectors.toList());
    }

    HotelEnum(String hotelCode) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.hotelCode =&lt;span&gt; hotelCode;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getHotelCode() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; hotelCode;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;接下来定义一个服务工厂，在静态块中利用反射机制把所有服务实现类动态加载到HOTEL_SERVER_MAP中，然后提供一个对外的获取对应服务的方法&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里有几个需要注意的地方：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.由于包名是写死的，那么所有实现HotelService的实现类都需要放在固定的包下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.类名的格式也是固定的，即枚举类中的hotelCode + &quot;ServiceImpl&quot;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 服务工厂类
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HotelServerFactory {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 类路径目录
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String CLASS_PATH = &quot;com.tactics.service.impl.&quot;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 服务实现后缀
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String GAME_SERVICE_SUFFIX = &quot;ServiceImpl&quot;&lt;span&gt;;


    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Map&amp;lt;String, HotelService&amp;gt; HOTEL_SERVER_MAP = &lt;span&gt;new&lt;/span&gt; ConcurrentHashMap&amp;lt;&amp;gt;&lt;span&gt;();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 初始化实现类到COMPANY_SERVER_MAP中
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt;&lt;span&gt; {
        HotelEnum.getList().forEach(v &lt;/span&gt;-&amp;gt;&lt;span&gt; {
            String className &lt;/span&gt;= CLASS_PATH + v +&lt;span&gt; GAME_SERVICE_SUFFIX;
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                HOTEL_SERVER_MAP.put(v, (HotelService) Class.forName(className).newInstance());
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InstantiationException e) {
                e.printStackTrace();
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IllegalAccessException e) {
                e.printStackTrace();
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ClassNotFoundException e) {
                e.printStackTrace();
            }
        });
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获取餐馆服务实现
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; hotelCode
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; HotelService getHotelServerImpl(String hotelCode)&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; HOTEL_SERVER_MAP.get(hotelCode);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;这里有一个问题，如果你的服务实现类是交给Spring容器管理的，里面有注入Mapper等等，使用反射的方式new出来的话，其中的属性是没有值的&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Spring容器就相当于是一个工厂了，可以直接从Spring上下文中获取(怎么获取Spring上下文对象这里就不细说了,有需要可以自行百度)。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 服务工厂类
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HotelServerFactory {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 类路径目录
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String CLASS_PATH = &quot;com.tactics.service.impl.&quot;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 服务实现后缀
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String GAME_SERVICE_SUFFIX = &quot;ServiceImpl&quot;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获取餐馆服务实现
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; hotelCode
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; HotelService getHotelServerImpl(String hotelCode)&lt;span&gt; {
        Class clazz &lt;/span&gt;= Class.forName(CLASS_PATH + hotelCode +&lt;span&gt; GAME_SERVICE_SUFFIX);
        String className &lt;/span&gt;= hotelCode +&lt;span&gt; GAME_SERVICE_SUFFIX;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (HotelService) ApplicationConfig.getBean(className, clazz);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;最终的调用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; List server(String hotelCode) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取对应的服务&lt;/span&gt;
    HotelService hotelService =&lt;span&gt; HotelServerFactory.getCompanyServerImpl(hotelCode);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取经过逻辑计算后返回的集合列表&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; hotelService.getMenuList();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;怎么样，是不是觉得可读性，复用性和扩展性都大大提高了，业务扩展需要新加一个餐馆的时候，只需要在枚举类中加一个hotelCode，然后定义一个实现类实现HotelService接口就好了，这个Demo也让我们知道了策略模式和工厂模式在实际项目中的应用场景。&lt;/p&gt;
</description>
<pubDate>Thu, 02 Jul 2020 13:36:00 +0000</pubDate>
<dc:creator>我恰芙蓉王</dc:creator>
<og:description>前言 以前写过的一个老项目中，有这样一个业务场景，比喻：一个外卖系统需要接入多家餐馆，在外卖系统中返回每个餐馆的菜单列表 ，每个餐馆的菜单价格都需要不同的算法计算。 代码中使用了大量的if else嵌</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/-tang/p/13226887.html</dc:identifier>
</item>
<item>
<title>【python爬虫实战】使用Selenium webdriver采集山东招考数据 - cbowen</title>
<link>http://www.cnblogs.com/cbowen/p/13227222.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cbowen/p/13227222.html</guid>
<description>&lt;h2 id=&quot;21-为什么使用webdriver&quot;&gt;2.1 为什么使用webdriver&lt;/h2&gt;
&lt;p&gt;Selenium Webdriver是通过各种浏览器的驱动（web driver）来驱动浏览器的，相遇对于使用requests库直接对网页进行解析，效率较低，本次使用webdriver库主要原因是requests库无法解析该网站&lt;/p&gt;
&lt;h2 id=&quot;22-webdriver支持浏览器&quot;&gt;2.2 webdriver支持浏览器&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Google Chrome&lt;/li&gt;
&lt;li&gt;Microsoft Internet Explorer 7，8，9，10，11 for Windows Vista，Windows 7，Windows 8，Windows 8.1.&lt;/li&gt;
&lt;li&gt;Microsoft Edge&lt;/li&gt;
&lt;li&gt;Firefox&lt;/li&gt;
&lt;li&gt;Safari&lt;/li&gt;
&lt;li&gt;Opera&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;23-配置与使用说明&quot;&gt;2.3 配置与使用说明&lt;/h2&gt;
&lt;p&gt;webdriver是通过各浏览器的驱动程序 来操作浏览器的，所以，要有各浏览器的驱动程序，浏览器驱动要与本地浏览器版本对应，常用浏览器驱动下载地址如下：&lt;/p&gt;
&lt;p&gt;本文使用谷歌的chrome浏览器，&lt;br/&gt;chrome + webdriver的具体配置和操作说明见 &lt;a href=&quot;https://www.cnblogs.com/cbowen/p/13217857.html&quot;&gt;https://www.cnblogs.com/cbowen/p/13217857.html&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;31-分析网站&quot;&gt;3.1 分析网站&lt;/h2&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;进入网页发现各省份地址相同、各高校地址相同，因此想按规律构造每个省份和每个学校的url，并用requests进行解析就无法实现了。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1845117/202007/1845117-20200702212612169-705511333.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;于是想到webdriver，来模拟人工操作，获取当前页面，再通过xpath定位到要获取的数据单元。&lt;br/&gt;先用chrome控制台获取目标数据单元的xpath&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1845117/202007/1845117-20200702212718203-1955614648.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;通过手动调整xpath，很容易发现省份xpath的规律为&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;for province_id in rang(1, 33)
    province_xpath = '//*[@id=&quot;div1&quot;]/div/div[%s]/a' % province_id
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1845117/202007/1845117-20200702212737408-357460455.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再用同样方法获取高校的xpat，这里就不贴截图了，直接上结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# sch_id为每个省份的高校id
# schid_xpath,province_xpath,schcode_xpath,school_xpath,subpage_xpath,schhome_xpath分别对应字段序号、地区、学校代码、学校名称、选考科目要求、学校主页
schid_xpath = '//*[@id=&quot;div4&quot;]/table/tbody/tr[%s]/td[1]/a' % school_id
province_xpath = '//*[@id=&quot;div4&quot;]/table/tbody/tr[%s]/td[2]/a' % school_id
schcode_xpath = '//*[@id=&quot;div4&quot;]/table/tbody/tr[%s]/td[3]/a' % school_id
school_xpath = '//*[@id=&quot;div4&quot;]/table/tbody/tr[%s]/td[4]/a' % school_id
subpage_xpath = '//*[@id=&quot;div4&quot;]/table/tbody/tr[%s]/td[5]/a' % school_id
schhome_xpath = '//*[@id=&quot;div4&quot;]/table/tbody/tr[%s]/td[6]/a' % school_id
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再用同样方法获取专业信息的xpat，直接上结果&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-py&quot;&gt;# major_id为每个高校专业序号，从1到最后一个专业序号
# i从1到4分别对应字段“序号”、“层次”、“专业名称”、“选考科目要求”
for i in range(1, 5):
    major_xpath = '//*[@id=&quot;ccc&quot;]/div/table/tbody/tr[%s]/td[%s]' % (major_id, i)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;32-遍历省份&quot;&gt;3.2 遍历省份&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;遍历省份很简单，一共32个省份，直接用rang(1,33)，省去用try来判断。&lt;/li&gt;
&lt;li&gt;在函数外启动浏览器，并传入WebDriver类wd，所有省份遍历完成后关闭浏览器&lt;/li&gt;
&lt;li&gt;后面要将数据写入mysql，所有传入了完成数据库连接的connect对象conn，并在全部数据写入后关闭conn连接。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;def traverse_province(wd, conn):
    &quot;&quot;&quot;
    循环进入省份
    :return:
    &quot;&quot;&quot;
    for province_id in range(1, 33):
        province_xpath = '//*[@id=&quot;div1&quot;]/div/div[%s]/a' % province_id
        wd.find_element_by_xpath(province_xpath).click()  # 点击进入省份
        time.sleep(1)
        traverse_school(wd, conn)  # 遍历省份内的高校
    wd.quit()
    conn.close()
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;33-遍历高校&quot;&gt;3.3 遍历高校&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;用while True循环来遍历当前页所有的高校，用try-except来判断是否成功捕捉高校信息，失败则终端while True循环。&lt;/li&gt;
&lt;li&gt;获取高校基本信息放列表school_info中，传入下层函数用于冗余保存高校+专业 完整数据。&lt;/li&gt;
&lt;li&gt;进入高校的子页面后，需要重新定位当前操作页面，wd.window_handles获取当前浏览器所有子页面句柄，wd.switch_to.window切换至指定页面。&lt;/li&gt;
&lt;li&gt;最内层函数traverse_major()会获取专业数据，并将本层获取的高校数据和专业数据写入mysql。&lt;/li&gt;
&lt;li&gt;在一个高校的全部专业数据写入完成后，提交一次。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;def traverse_school(wd, conn):
    &quot;&quot;&quot;
    遍历高校信息
    :return:
    &quot;&quot;&quot;
    school_id = 1
    while True:
        school_info = []
        try:
            # 获取高校信息
            for i in [1, 2, 3, 4, 6]:
                school_xpath = '//*[@id=&quot;div4&quot;]/table/tbody/tr[%s]/td[%s]' % (school_id, i)
                text = wd.find_element_by_xpath(school_xpath).text
                school_info.append(text)

            # 进入高校子页
            wd.find_element_by_xpath('//*[@id=&quot;div4&quot;]/table/tbody/tr[%s]/td[5]/a' % school_id).click()
            wd.switch_to.window(wd.window_handles[-1])  # 切换到最后一个页面
            traverse_major(school_info, wd, conn)  # 遍历专业
            wd.close()  # 关闭当前页
            wd.switch_to.window(wd.window_handles[-1])  # 重新定位一次页面
            school_id += 1
        except:
            break
        conn.commit()  # 每个高校份提交一次
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;34-采集专业数据&quot;&gt;3.4 采集专业数据&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;将专业信息结合上层函数传入的高校信息冗余保存。&lt;/li&gt;
&lt;li&gt;每个高校启动一次游标。&lt;/li&gt;
&lt;li&gt;本函数内仅使操作游标进行数据写入，数据库的连接在下面函数中，数据库关闭在最外层函数中。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;def traverse_major(school_info, wd, conn):
    &quot;&quot;&quot;
    遍历专业信息，最后结合高校信息一并输出
    :param school_info: 上层函数传递进来的高校信息
    :return:
    &quot;&quot;&quot;
    major_id = 1
    cursor = conn.cursor()
    while True:
        major_info = []
        try:
            for i in range(1, 5):
                major_xpath = '//*[@id=&quot;ccc&quot;]/div/table/tbody/tr[%s]/td[%s]' % (major_id, i)
                text = wd.find_element_by_xpath(major_xpath).text
                major_info.append(text)

            print(school_info + major_info)

            # 写入mysql
            insert_sql = '''
                        insert into sdzk_data
                        (school_id,province,school_code,school_name,school_home,major_id,cc,major_name,subject_ask) 
                        values('%s','%s','%s','%s','%s','%s','%s','%s','%s')   
                        ''' % (school_info[0], school_info[1], school_info[2], school_info[3], school_info[4],
                               major_info[0], major_info[1], major_info[2], major_info[3])
            cursor.execute(insert_sql)

            major_id += 1
        except:
            break
    cursor.close()  # 每个高校都重新开启一次游标
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;35-写入mysql&quot;&gt;3.5 写入mysql&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;该函数仅用于创建mysql连接，并创建表。&lt;/li&gt;
&lt;li&gt;判断表是否存在，存在则先删除再创建。&lt;/li&gt;
&lt;li&gt;函数返回connect类，用于其他函数使用。&lt;/li&gt;
&lt;li&gt;关闭连接在最外层函数中，直到所有省份数据采集结束后才关闭连接。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;def connect_mysql(config):
    &quot;&quot;&quot;
    连接数据库，并创建表，如果表已存在则先删除
    :param config: mysql数据库信息
    :return: 返回连接成功的connect对象
    &quot;&quot;&quot;

    create_sql = '''
                    CREATE table if NOT EXISTS sdzk_data
                    (school_id int(3),province varchar(20), school_code varchar(5), 
                    school_name varchar(50), school_home varchar(100), major_id int(3), 
                    cc varchar(5), major_name varchar(100), subject_ask varchar(50))
                 '''

    # 判断表是否存在，存在则删除，然后创建
    conn = pymysql.connect(**config)
    cursor = conn.cursor()
    cursor.execute('''show TABLEs like &quot;sdzk_data&quot;''')
    if cursor.fetchall():
        cursor.execute('''drop table sdzk_data''')
    cursor.execute(create_sql)
    cursor.close()

    return conn
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;源码地址：&lt;a href=&quot;https://github.com/18686622933/sdzk_data&quot;&gt;https://github.com/18686622933/sdzk_data&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 02 Jul 2020 13:28:00 +0000</pubDate>
<dc:creator>cbowen</dc:creator>
<og:description>1、目标 目标：按地区、高校 采集2020年拟在山东招生的所有专业信息 采集地址：http://xkkm.sdzk.cn/zy-manager-web/gxxx/selectAllDq# 2、Sele</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cbowen/p/13227222.html</dc:identifier>
</item>
</channel>
</rss>