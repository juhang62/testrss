<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>lua的table表去重 - 爱上游戏开发</title>
<link>http://www.cnblogs.com/shirln/p/13327870.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shirln/p/13327870.html</guid>
<description>&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;推荐阅读：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;方法一&quot;&gt;方法一&lt;/h5&gt;
&lt;p&gt;用过lua的人都知道，lua的&lt;strong&gt;table中不允许存在相同的key&lt;/strong&gt;，利用这个思想，我们可以将原始table（记作table1），用一个新的table（记作table2）来存放，存放得时候将table1的value作为table2得key，将值赋为true，最后只需要遍历table2，将其的key保存在一个新的table（记作table3）里。&lt;/p&gt;
&lt;p&gt;例如：原始table1={1，2，3，4，5，2，3}&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;  local table1={1，2，3，4，5，2，3}
  local table2={}
  for key,val in pairs(table1) do
     table2[val]=true
  end
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;  local table3={}
  for key,val in pairs(table2) do
     table.insert(table3,key)--将key插入到新的table，构成最终的结果
  end
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;方法二&quot;&gt;方法二&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;local list={1，2，3，4，5，2，3}
local temp1 = clone(list)
local temp2 = clone(list)
for k1, v1 in ipairs(temp1) do
    for k2, v2 in ipairs(temp2) do
        if v1 == v2then
            table.remove(temp1, k1)
            table.remove(temp2, k1)
        end
    end
end
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;拓展移除table中数据里具有某个相同字段的数据，例如，table如下：需移除具有相同value相同的数据&quot;&gt;拓展:移除table中数据里具有某个相同字段的数据，例如，table如下：需移除具有相同value相同的数据&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;local list={}
list[1]={id=10001,sid=1001,value=5}
list[2]={id=10002,sid=1001,value=3}
list[3]={id=10003,sid=1001,value=4}
list[4]={id=10004,sid=1001,value=5}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;利用方法二拓展本功能：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;local list={}
list[1]={id=10001,sid=1001,value=5}
list[2]={id=10002,sid=1001,value=3}
list[3]={id=10003,sid=1001,value=4}
list[4]={id=10004,sid=1001,value=5}
local temp1 = clone(list)
local temp2 = clone(list)
for k1, v1 in ipairs(temp1) do
    for k2, v2 in ipairs(temp2) do
        --同种英雄同一星级的移除
        if v1.id ~= v2.id and v1.value == v2.value and v1.sid == v2.sid then
            table.remove(temp1, k1)
            table.remove(temp2, k1)
        end
    end
end
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 17 Jul 2020 00:54:00 +0000</pubDate>
<dc:creator>爱上游戏开发</dc:creator>
<og:description>推荐阅读： 我的CSDN 我的博客园 QQ群：704621321 我的个人博客 方法一 用过lua的人都知道，lua的table中不允许存在相同的key，利用这个思想，我们可以将原始table（记作t</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/shirln/p/13327870.html</dc:identifier>
</item>
<item>
<title>springboot整合swagger。完爆前后端调试 - 烟花散尽13141</title>
<link>http://www.cnblogs.com/zhangxinhua/p/13327864.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangxinhua/p/13327864.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;web接口开发时在调试阶段最麻烦的就是参数调试，前端需要咨询后端。后端有时候自己也不是很了解。这时候就会造成调试一次接口就需要看一次代码。Swagger帮我们解决对接的麻烦&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;&lt;li&gt;springboot 引入swagger只需要引入jar包，然后配置swagger启动。并配合swagger的注解使用就可以实现文档自动生成了。我们先来看看效果&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://oytmxyuek.bkt.clouddn.com/20200717001.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;环境准备&quot;&gt;环境准备&lt;/h2&gt;
&lt;ul readability=&quot;-1.7623762376238&quot;&gt;&lt;li readability=&quot;-0.84810126582278&quot;&gt;
&lt;p&gt;代码还是基于&lt;a href=&quot;https://gitee.com/zxhTom/spring&quot;&gt;spring仓库&lt;/a&gt;开发。分支为&lt;code&gt;feature/0004/springboot-swagger&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;swagger.version=2.9.2&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;io.springfox&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;springfox-swagger2&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;${swagger.version}&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;io.springfox&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;springfox-swagger-ui&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;${swagger.version}&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;

&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;配置&quot;&gt;配置&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
@Configuration
@EnableSwagger2
public class SwaggerConfig2 {
    @Bean
    public Docket createRestApi() {

        // 添加请求参数，我们这里把token作为请求头部参数传入后端
        ParameterBuilder parameterBuilder = new ParameterBuilder();
        List&amp;lt;Parameter&amp;gt; parameters = new ArrayList&amp;lt;Parameter&amp;gt;();
        parameterBuilder.name(&quot;token&quot;).description(&quot;令牌&quot;)
                .modelRef(new ModelRef(&quot;string&quot;)).parameterType(&quot;header&quot;).required(false).build();
        parameters.add(parameterBuilder.build());

        return new Docket(DocumentationType.SWAGGER_2)
                .pathMapping(&quot;/&quot;)
                .select()
                .apis(RequestHandlerSelectors.basePackage(&quot;com&quot;))
                .paths(Predicates.not(PathSelectors.regex(&quot;/error.*&quot;)))
                .build().apiInfo(new ApiInfoBuilder()
                        .title(&quot;后端服务说明&quot;)
                        .description(&quot;SpringBoot整合Swagger，详细信息......&quot;)
                        .version(&quot;1.0&quot;)
                        .contact(new Contact(&quot;zxhtom&quot;, &quot;zxhtom.blog.csdn.net&quot;, &quot;870775401@qq.com&quot;))
                        .license(&quot;The Apache License&quot;)
                        .licenseUrl(&quot;http://zxhtom.gitee.io&quot;)
                        .build())
                .useDefaultResponseMessages(false)
                .securitySchemes(securitySchemes())
                .securityContexts(securityContexts())
                .globalOperationParameters(parameters);
    }


    private List&amp;lt;ApiKey&amp;gt; securitySchemes() {
        List&amp;lt;ApiKey&amp;gt; apiKeyList = new ArrayList();
        apiKeyList.add(new ApiKey(&quot;Authorization&quot;, &quot;token&quot;, &quot;header&quot;));
        return apiKeyList;
    }

    private List&amp;lt;SecurityContext&amp;gt; securityContexts() {
        List&amp;lt;SecurityContext&amp;gt; securityContexts = new ArrayList&amp;lt;&amp;gt;();
        securityContexts.add(
                SecurityContext.builder()
                        .securityReferences(defaultAuth())
                        .forPaths(PathSelectors.regex(&quot;^(?!auth).*$&quot;))
                        .build());
        return securityContexts;
    }

    List&amp;lt;SecurityReference&amp;gt; defaultAuth() {
        AuthorizationScope authorizationScope = new AuthorizationScope(&quot;global&quot;, &quot;accessEverything&quot;);
        AuthorizationScope[] authorizationScopes = new AuthorizationScope[1];
        authorizationScopes[0] = authorizationScope;
        List&amp;lt;SecurityReference&amp;gt; securityReferences = new ArrayList&amp;lt;&amp;gt;();
        securityReferences.add(new SecurityReference(&quot;Authorization&quot;, authorizationScopes));
        return securityReferences;
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;添加请求头&quot;&gt;添加请求头&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
securitySchemes(securitySchemes())
securityContexts(securityContexts())

&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;在上面的两端配置就是加入全局的token设置的。在swagger-ui界面显示是右上角有一把锁的标志&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://oytmxyuek.bkt.clouddn.com/20200717002.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;http://oytmxyuek.bkt.clouddn.com/20200717003.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;http://oytmxyuek.bkt.clouddn.com/20200717004.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;接口使用&quot;&gt;接口使用&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://oytmxyuek.bkt.clouddn.com/20200717005.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;http://oytmxyuek.bkt.clouddn.com/20200717006.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;http://oytmxyuek.bkt.clouddn.com/20200717007.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;注解使用&quot;&gt;注解使用&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;注解&lt;/th&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;8&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;@Api()&lt;/td&gt;
&lt;td&gt;用在请求的类上。表示该类的请求类用于文档标注&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;@ApiOperation()&lt;/td&gt;
&lt;td&gt;用于方法上。对一个http请求的具体说明，出参入参说明&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;@ApiModel()&lt;/td&gt;
&lt;td&gt;对请求实体的一个说明&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;@ApiModelProperty&lt;/td&gt;
&lt;td&gt;对实体内属性说明，也可以设置默认值&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;@ApiImpliciParams()&lt;/td&gt;
&lt;td&gt;用于请求的方法上，里面是ApiImpliciParam数组&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;@ApiImpliciParam()&lt;/td&gt;
&lt;td&gt;表示单独请求参数。可以设置form表单中参数单独设置&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;@ApiParam()&lt;/td&gt;
&lt;td&gt;对请求方法中参数的单独设置 类似ApiImpliciParam&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;@ApiResponses()&lt;/td&gt;
&lt;td&gt;对请求方法上根据响应码设置说明&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@ApiResponse&lt;/td&gt;
&lt;td&gt;单个响应码说明&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@ApiIgnore()&lt;/td&gt;
&lt;td&gt;对该请求的忽略&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;ul&gt;&lt;li&gt;具体使用可以查看源码。源码上面有给出。&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;&lt;li&gt;这里需要首先介绍下spring资源的加载顺序。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;src/main/resources/META-INF/resources&lt;br/&gt;src/main/resources/static&lt;br/&gt;src/main/resources/public&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;这三个优先级依次降低。欢句话说spring首先会在src/main/resources/META-INF/resources下寻找资源。所以这也是我们自定义swaggerUI的策略。我们只需要在META-INF下重新绘画swaggerUI的页面就行了。这里只是提供思路。不具体实现(懒)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/zhangxinhua/p/13327864.html#addMe&quot;&gt;加入战队&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;微信公众号&quot;&gt;微信公众号&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://oytmxyuek.bkt.clouddn.com/weixin.jpeg&quot; alt=&quot;微信公众号&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 17 Jul 2020 00:51:00 +0000</pubDate>
<dc:creator>烟花散尽13141</dc:creator>
<og:description>web接口开发时在调试阶段最麻烦的就是参数调试，前端需要咨询后端。后端有时候自己也不是很了解。这时候就会造成调试一次接口就需要看一次代码。Swagger帮我们解决对接的麻烦 springboot接入s</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhangxinhua/p/13327864.html</dc:identifier>
</item>
<item>
<title>010.Nginx正反代理 - 木二</title>
<link>http://www.cnblogs.com/itzgr/p/13327861.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/itzgr/p/13327861.html</guid>
<description>&lt;h2 align=&quot;left&quot;&gt;一 Nginx代理&lt;/h2&gt;
&lt;h3 align=&quot;left&quot;&gt;1.1 Nginx代理概述&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;nginx是一款自由的、开源的、高性能的HTTP服务器和反向代理服务器。同时也是一个IMAP、POP3、SMTP代理服务器。nginx可以作为一个HTTP服务器进行网站的发布处理，同时nginx可以作为反向代理进行负载均衡的实现。&lt;/span&gt;&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;1.2 Nginx代理模式&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;Nginx通常有如下三种代理模式：&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ul yne-block-type=&quot;list&quot;&gt;&lt;li&gt;&lt;span&gt;正向代理（forward proxy）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;反向代理（reverse proxy）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;透明代理&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;h3 align=&quot;left&quot;&gt;1.3 正向代理&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;正向代理（forward）是一个位于客户端和原始服务器(origin server)之间的服务器，即代理服务器。为了从原始服务器取得内容，客户端向代理服务器发送一个请求并指定目标原始服务器，然后代理服务器向原始服务器转交请求并将获得的内容返回给客户端。&lt;/span&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot; yne-bulb-block=&quot;image&quot;&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/680719/202007/680719-20200717084906553-457252477.png&quot;&gt;&lt;span&gt;&lt;img width=&quot;667&quot; height=&quot;126&quot; title=&quot;clipboard&quot; alt=&quot;clipboard&quot; src=&quot;https://img2020.cnblogs.com/blog/680719/202007/680719-20200717084906777-624546547.png&quot; border=&quot;0&quot; data-media-type=&quot;image&quot; data-attr-org-src-id=&quot;A6064A8532F545F3943520A8281EAB46&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;场景一：客户端访问本来无法访问的原始服务器的资源&lt;/span&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot; yne-bulb-block=&quot;image&quot;&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/680719/202007/680719-20200717084906952-829318789.png&quot;&gt;&lt;span&gt;&lt;img width=&quot;667&quot; height=&quot;287&quot; title=&quot;clipboard&quot; alt=&quot;clipboard&quot; src=&quot;https://img2020.cnblogs.com/blog/680719/202007/680719-20200717084907151-1983359504.png&quot; border=&quot;0&quot; data-media-type=&quot;image&quot; data-attr-org-src-id=&quot;D1C2854767484491BAD80CA789A01BC4&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;假设最初客户端要访问原始服务器需要经过R1和R2路由器这样一个路由节点，如果路由器R1或者路由器R2发生故障（或存在禁止访问的安全策略等），那么就无法访问原始服务器了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是如果客户端让代理服务器去代替自己访问原始服务器，由于代理服务器没有在路由器R1或R2节点中，而是通过其它的路由节点访问的原始服务器，那么客户端就可以得到原始服务器的数据了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;场景二：加速访问原始服务器的资源&lt;/span&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot; yne-bulb-block=&quot;image&quot;&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/680719/202007/680719-20200717084907332-623226744.png&quot;&gt;&lt;span&gt;&lt;img width=&quot;667&quot; height=&quot;287&quot; title=&quot;clipboard&quot; alt=&quot;clipboard&quot; src=&quot;https://img2020.cnblogs.com/blog/680719/202007/680719-20200717084907521-615439810.png&quot; border=&quot;0&quot; data-media-type=&quot;image&quot; data-attr-org-src-id=&quot;D794E95196C54A50809DCE292CE09C14&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;假设客户端要访问原始服务器，经过R1路由器和R2路由器，而R1到R2路由器的链路是一个低带宽链路。而客户端到代理服务器，从代理服务器到原始服务器都是高带宽链路。那么使用正向代理则可以加速访问。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;场景三：Cache作用&lt;/span&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot; yne-bulb-block=&quot;image&quot;&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/680719/202007/680719-20200717084907696-343657635.png&quot;&gt;&lt;span&gt;&lt;img width=&quot;685&quot; height=&quot;305&quot; title=&quot;clipboard&quot; alt=&quot;clipboard&quot; src=&quot;https://img2020.cnblogs.com/blog/680719/202007/680719-20200717084907869-703108534.png&quot; border=&quot;0&quot; data-media-type=&quot;image&quot; data-attr-org-src-id=&quot;8DF7DE7D946E4201ABA4B8311EF3B842&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;Cache（缓存）技术和代理服务技术是紧密联系的（不光是正向代理，反向代理也使用了Cache（缓存）技术）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如上图所示，假设客户端要访问原始服务器某数据A之前，代理服务器已经通过访问原始服务器数据A，那么代理服务器会把数据A保存一段时间，此时再次通过代理服务器访问数据A，那么代理服务器不再访问原始服务器，而把缓存的数据A直接发给客户端。这一技术在Cache中术语就叫Cache命中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;场景四：代理服务器实现授权控制&lt;/span&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot; yne-bulb-block=&quot;image&quot;&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/680719/202007/680719-20200717084908370-198028004.png&quot;&gt;&lt;span&gt;&lt;img width=&quot;819&quot; height=&quot;324&quot; title=&quot;clipboard&quot; alt=&quot;clipboard&quot; src=&quot;https://img2020.cnblogs.com/blog/680719/202007/680719-20200717084908637-784551730.png&quot; border=&quot;0&quot; data-media-type=&quot;image&quot; data-attr-org-src-id=&quot;AA387C9FB8E64D20935DEC7D63A528B7&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如上图所示，防火墙作为网关，用来过滤外网对其的访问。假设局域网内部客户端A和客户端B都设置了代理服务器。可通过代理服务器配置客户端A允许访问互联网，而客户端B不允许访问互联网，从而实现不通客户端的访问代理授权控制。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;场景五：隐藏客户端踪迹&lt;/span&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot; yne-bulb-block=&quot;image&quot;&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/680719/202007/680719-20200717084908943-1562266330.png&quot;&gt;&lt;span&gt;&lt;img width=&quot;667&quot; height=&quot;126&quot; title=&quot;clipboard&quot; alt=&quot;clipboard&quot; src=&quot;https://img2020.cnblogs.com/blog/680719/202007/680719-20200717084909159-980820518.png&quot; border=&quot;0&quot; data-media-type=&quot;image&quot; data-attr-org-src-id=&quot;B450756F6D1148BBBE24201120776B96&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如上图所示，原始服务器并不知道访问自己的实际的客户端，因为代理服务器代替客户端去直接与原始服务器进行交互，从而对于原始服务器而言，客户端的踪迹被隐藏了。&lt;/span&gt;&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;1.4 反向代理&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;反向代理正好与正向代理相反，对于客户端而言代理服务器就像是原始服务器，并且客户端不需要进行任何特别的设置。客户端向反向代理的命名空间(name-space)中的内容发送普通请求，接着反向代理将判断向何处(原始服务器)转交请求，并将获得的内容返回给客户端。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;场景一：隐藏原始服务器踪迹&lt;/span&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot; yne-bulb-block=&quot;image&quot;&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/680719/202007/680719-20200717084909341-1506932761.png&quot;&gt;&lt;span&gt;&lt;img width=&quot;709&quot; height=&quot;137&quot; title=&quot;clipboard&quot; alt=&quot;clipboard&quot; src=&quot;https://img2020.cnblogs.com/blog/680719/202007/680719-20200717084909511-1676219610.png&quot; border=&quot;0&quot; data-media-type=&quot;image&quot; data-attr-org-src-id=&quot;AA7E9EB953524B92AA39153A2618B911&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;客户端始终认为它访问的是原始服务器而不是代理服务器，但实用际上反向代理服务器接受客户端的应答，从原始资源服务器中取得客户端的需求资源，然后发送给客户端。由于防火墙的作用，只允许代理服务器访问原始资源服务器。对于此环境下，防火墙和反向代理的共同作用保护了原始资源服务器，对于客户端而言是透明的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;场景二：负载均衡器&lt;/span&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot; yne-bulb-block=&quot;image&quot;&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/680719/202007/680719-20200717084909773-975653932.png&quot;&gt;&lt;span&gt;&lt;img width=&quot;558&quot; height=&quot;397&quot; title=&quot;clipboard&quot; alt=&quot;clipboard&quot; src=&quot;https://img2020.cnblogs.com/blog/680719/202007/680719-20200717084909943-1185950853.png&quot; border=&quot;0&quot; data-media-type=&quot;image&quot; data-attr-org-src-id=&quot;6A7ED4FD1A3A41CE86B5647F07DB5ABB&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;当反向代理服务器存在多个，从而部署为集群，当多个客户端访问原始服务器（原始服务器也可以是集群）的时候，不同的代理服务器应答不同的客户端，然后发送不同的客户端所需的资源，从而实现负载均衡效果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;提示：Nginx基于反向代理实现负载均衡配置参考《012.Nginx负载均衡》。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;场景三：Cache作用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;同时反向代理服务器类似正向代理服务器一样拥有Cache的作用，可以缓存原始资源服务器的资源，而不是每次都要向原始资源服务器组请求数据，特别对于一些静态的数据，比如图片和普通文件，如果这些反向代理服务器能够做到和客户端来自同一个网络，那么客户端访问反向代理服务器，就会得到很高质量的速度。这正是CDN技术的核心。场景四：正方代理混合场景&lt;/span&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot; yne-bulb-block=&quot;image&quot;&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/680719/202007/680719-20200717084910237-1278131740.png&quot;&gt;&lt;span&gt;&lt;img width=&quot;715&quot; height=&quot;404&quot; title=&quot;clipboard&quot; alt=&quot;clipboard&quot; src=&quot;https://img2020.cnblogs.com/blog/680719/202007/680719-20200717084910399-1159482389.png&quot; border=&quot;0&quot; data-media-type=&quot;image&quot; data-attr-org-src-id=&quot;0E97EE3C99E74C64B2DC76707BCDD812&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;实际项目操作时，正向代理和反向代理很有可能会存在在一个应用场景中，正向代理代理客户端的请求去访问目标服务器，目标服务器是一个反向代理服务器，反向代理了多台真实的业务处理服务器。&lt;/span&gt;&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;1.5 透明代理&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;参考：https://www.cnblogs.com/gbq-dog/p/10653054.html。&lt;/span&gt;&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;1.6 常见代理软件&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;通常大多数开源代理软件，都能实现正反代理两种方式。开源软件中如squid，既可以做正向代理，也可以实现反向代理。MS ISA也可以用来在Windows平台下做正向代理。反向代理中最主要的实践就是WEB服务，如Nginx。&lt;/span&gt;&lt;/p&gt;
&lt;h2 align=&quot;left&quot;&gt;二 代理配置项&lt;/h2&gt;
&lt;h3 align=&quot;left&quot;&gt;2.1 配置语法&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;语法：proxy_buffering on | off;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;默认值：proxy_buffering on;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可配置段：http, server, location&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;作用：配置proxy缓冲区。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;扩展：&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ul yne-block-type=&quot;list&quot;&gt;&lt;li&gt;&lt;span&gt;proxy_buffer_size：设置缓冲区大小（内存页大小）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;proxy_buffers：设置缓冲区数量和大小（内存页数量和大小）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;proxy_busy_buffers_size：设置最大缓冲区大小&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;语法：proxy_redirect default; proxy_redirect off; proxy_redirect redirect replacement;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;默认值：proxy_redirect default;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可配置段：http, server, location&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;作用：配置proxy重定向。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;扩展：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;语法：proxy_buffering on | off;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;默认值：proxy_buffering on;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可配置段：http, server, location&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;作用：配置proxy缓冲区。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;扩展：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;语法：proxy_set_header field value;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;默认值：proxy_set_header Host $proxy_host; proxy_set_header Connection close;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可配置段：http, server, location&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;作用：配置proxy头信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;扩展：&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ul yne-block-type=&quot;list&quot;&gt;&lt;li&gt;&lt;span&gt;proxy_hide_header：设置隐藏头信息字段；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;proxy_set_body：设置请求体返回信息。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;语法：proxy_connect_timeout time;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;默认值：proxy_connect_timeout 60s;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可配置段：http, server, location&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;作用：配置proxy超时。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;扩展：&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ul yne-block-type=&quot;list&quot; start=&quot;3&quot;&gt;&lt;li&gt;&lt;span&gt;proxy_hide_header：设置隐藏头信息字段；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;proxy_set_body：设置请求体返回信息。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;h2 align=&quot;left&quot;&gt;三 配置正向代理&lt;/h2&gt;
&lt;h3 align=&quot;left&quot;&gt;3.1 正向代理配置&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@&lt;span&gt;proxy&lt;/span&gt; ~]&lt;span&gt;# vi /etc/nginx/conf.d/reverse.conf&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; server{
&lt;span&gt;  3&lt;/span&gt;     resolver 8.8.8.8;                         &lt;span&gt;#配置DNS解析IP地址&lt;/span&gt;
&lt;span&gt;  4&lt;/span&gt;     resolver_timeout 30s;                             &lt;span&gt;#超时时间（5秒）&lt;/span&gt;
&lt;span&gt;  5&lt;/span&gt;     listen 8080;
&lt;span&gt;  6&lt;/span&gt;     access_log  /var/log/nginx/reverse.access.log  main;
&lt;span&gt;  7&lt;/span&gt;     error_log   /var/log/nginx/reverse.error.log  &lt;span&gt;warn&lt;/span&gt;;
&lt;span&gt;  8&lt;/span&gt;     location / {
&lt;span&gt;  9&lt;/span&gt;         proxy_pass http://$http_host$request_uri;     &lt;span&gt;#配置正向代理参数&lt;/span&gt;
&lt;span&gt; 10&lt;/span&gt;         proxy_set_header Host $http_host;             &lt;span&gt;#解决如果URL中带&quot;.&quot;后Nginx 503错误&lt;/span&gt;
&lt;span&gt; 11&lt;/span&gt;         proxy_buffers 256 4k;                         &lt;span&gt;#配置缓存大小&lt;/span&gt;
&lt;span&gt; 12&lt;/span&gt;         proxy_max_temp_file_size 0;                   &lt;span&gt;#关闭磁盘缓存读写减少I/O&lt;/span&gt;
&lt;span&gt; 13&lt;/span&gt;         proxy_connect_timeout 30;                     &lt;span&gt;#代理连接超时时间&lt;/span&gt;
&lt;span&gt; 14&lt;/span&gt;         proxy_cache_valid 200 302 10m;
&lt;span&gt; 15&lt;/span&gt;         proxy_cache_valid 301 1h;
&lt;span&gt; 16&lt;/span&gt;         proxy_cache_valid any 1m;                     &lt;span&gt;#配置代理服务器缓存时间&lt;/span&gt;
&lt;span&gt; 17&lt;/span&gt;     }
&lt;span&gt; 18&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@&lt;span&gt;proxy&lt;/span&gt; ~]&lt;span&gt;# nginx -t -c /etc/nginx/nginx.conf      #检查配置文件&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; [root@&lt;span&gt;proxy&lt;/span&gt; ~]&lt;span&gt;# nginx -s reload                              #重载配置文件&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;配置释义：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不能有hostname。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;必须有resolver, 即dns，超时时间（30秒）可选。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;配置正向代理参数，均是由 Nginx 变量组成。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;提示：配置好后，重启nginx，以浏览器为例，若需要使用这个代理服务器，则只需将浏览器代理设置为http://+服务器ip地址+:+80即可使用了。&lt;/span&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot; yne-bulb-block=&quot;image&quot;&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/680719/202007/680719-20200717084910576-238530870.png&quot;&gt;&lt;span&gt;&lt;img width=&quot;735&quot; height=&quot;72&quot; title=&quot;clipboard&quot; alt=&quot;clipboard&quot; src=&quot;https://img2020.cnblogs.com/blog/680719/202007/680719-20200717084910750-445688736.png&quot; border=&quot;0&quot; data-media-type=&quot;image&quot; data-attr-org-src-id=&quot;0C6E3FE67AB942A8AEE48F9B45556167&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;参考文档：https://www.cnblogs.com/gbq-dog/p/10653054.html&lt;/span&gt;&lt;/p&gt;
&lt;h2 align=&quot;left&quot;&gt;四 反向代理配置&lt;/h2&gt;
&lt;h3 align=&quot;left&quot;&gt;4.1 环境预设&lt;/h3&gt;
&lt;div yne-bulb-block=&quot;table&quot;&gt;
&lt;table&gt;&lt;colgroup/&gt;&lt;colgroup&gt;&lt;col width=&quot;206&quot;/&gt;&lt;/colgroup&gt;&lt;colgroup&gt;&lt;col width=&quot;206&quot;/&gt;&lt;/colgroup&gt;&lt;colgroup&gt;&lt;col width=&quot;206&quot;/&gt;&lt;/colgroup&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td align=&quot;center&quot; data-cell-id=&quot;8277-1586533104849-cell-0-0&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;主机&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;8277-1586533104849-cell-0-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;作用&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;8277-1586533104849-cell-0-2&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;备注&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;center&quot; data-cell-id=&quot;8277-1586533104849-cell-1-0&quot;&gt;
&lt;p&gt;&lt;span&gt;proxy2.odocker.com&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;8277-1586533104849-cell-1-1&quot;&gt;
&lt;p&gt;&lt;span&gt;代理服务器&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;8277-1586533104849-cell-1-2&quot;&gt;
&lt;p&gt;&lt;span&gt;反向代理服务器&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;center&quot; data-cell-id=&quot;8277-1586533104849-cell-2-0&quot;&gt;
&lt;p&gt;&lt;span&gt;www.landiannews.com&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;8277-1586533104849-cell-2-1&quot;&gt;
&lt;p&gt;&lt;span&gt;原始服务器&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;8277-1586533104849-cell-2-2&quot;&gt;
&lt;p&gt;&lt;span&gt;模拟原始服务器&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;h3 align=&quot;left&quot;&gt;4.2 配置反向代理&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@&lt;span&gt;proxy&lt;/span&gt; ~]&lt;span&gt;# vi /etc/nginx/conf.d/forward.conf&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; server {
&lt;span&gt;  3&lt;/span&gt;     listen  80;
&lt;span&gt;  4&lt;/span&gt;     server_name  forward.linuxds.com;
&lt;span&gt;  5&lt;/span&gt;     access_log  /var/log/nginx/forward.access.log  main;
&lt;span&gt;  6&lt;/span&gt;     error_log   /var/log/nginx/forward.error.log  &lt;span&gt;warn&lt;/span&gt;;
&lt;span&gt;  7&lt;/span&gt;     location / {
&lt;span&gt;  8&lt;/span&gt;         proxy_pass https://www.landiannews.com/;
&lt;span&gt;  9&lt;/span&gt;         &lt;span&gt;index&lt;/span&gt; &lt;span&gt;index&lt;/span&gt;.html;
&lt;span&gt; 10&lt;/span&gt;         proxy_redirect     off;
&lt;span&gt; 11&lt;/span&gt; &lt;span&gt;#        proxy_set_header   Host             $host;&lt;/span&gt;
&lt;span&gt; 12&lt;/span&gt;         proxy_set_header   X-Real-IP        $remote_addr;
&lt;span&gt; 13&lt;/span&gt;         proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;
&lt;span&gt; 14&lt;/span&gt;         client_max_body_size       10m;               &lt;span&gt;#允许客户端请求的最大单文件字节数&lt;/span&gt;
&lt;span&gt; 15&lt;/span&gt;         client_body_buffer_size    128k;              &lt;span&gt;#缓冲区代理缓冲用户端请求的最大字节数&lt;/span&gt;
&lt;span&gt; 16&lt;/span&gt;         proxy_connect_timeout      300;               &lt;span&gt;#nginx跟后端服务器连接超时时间(代理连接超时)&lt;/span&gt;
&lt;span&gt; 17&lt;/span&gt;         proxy_send_timeout         300;               &lt;span&gt;#后端服务器数据回传时间(代理发送超时)&lt;/span&gt;
&lt;span&gt; 18&lt;/span&gt;         proxy_read_timeout         300;               &lt;span&gt;#连接成功后，后端服务器响应时间(代理接收超时)&lt;/span&gt;
&lt;span&gt; 19&lt;/span&gt;         proxy_buffer_size          4k;                &lt;span&gt;#设置代理服务器（nginx）保存用户头信息的缓冲区大小&lt;/span&gt;
&lt;span&gt; 20&lt;/span&gt;         proxy_buffers              4 32k;             &lt;span&gt;#proxy_buffers缓冲区，网页平均在32k以下的话，这样设置&lt;/span&gt;
&lt;span&gt; 21&lt;/span&gt;         proxy_busy_buffers_size    64k;               &lt;span&gt;#高负荷下缓冲大小（proxy_buffers*2）&lt;/span&gt;
&lt;span&gt; 22&lt;/span&gt;         proxy_temp_file_write_size 64k;               &lt;span&gt;#设定缓存文件夹大小，大于这个值，将从upstream服务器传&lt;/span&gt;
&lt;span&gt; 23&lt;/span&gt;     }
&lt;span&gt; 24&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@&lt;span&gt;proxy&lt;/span&gt; ~]&lt;span&gt;# nginx -t -c /etc/nginx/nginx.conf      #检查配置文件&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; [root@&lt;span&gt;proxy&lt;/span&gt; ~]&lt;span&gt;# nginx -s reload                              #重载配置文件&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;配置释义：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;proxy_set_header X-Real-IP $remote_addr：把源IP【$remote_addr，建立HTTP连接header里面的信息】赋值给X-Real-IP，从而通过$X-Real-IP来获取源IP；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for：在nginx作为代理服务器时，设置的IP列表，会把经过的机器ip，代理机器ip都记录下来，用【，】隔开。&lt;/span&gt;&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;4.3 测试反向代理&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;浏览器访问：http://forward.linuxds.com/&lt;/span&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot; yne-bulb-block=&quot;image&quot;&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/680719/202007/680719-20200717084910936-1640159525.png&quot;&gt;&lt;span&gt;&lt;img width=&quot;362&quot; height=&quot;95&quot; title=&quot;clipboard&quot; alt=&quot;clipboard&quot; src=&quot;https://img2020.cnblogs.com/blog/680719/202007/680719-20200717084911237-918644395.png&quot; border=&quot;0&quot; data-media-type=&quot;image&quot; data-attr-org-src-id=&quot;9B8906C393D74B51A93D0D127C9D7603&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;参考文档：https://www.runoob.com/w3cnote/nginx-proxy-balancing.html&lt;/span&gt;&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;4.4 其他代理配置语句&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;proxy_pass：设置代理服务器的地址，可以是主机名称、IP地址加端口号等形式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;proxy_pass URL&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1：当代理的是一组服务器时可以使用 upstream 指令来设置。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2：当URL中含有uri时，（例如 &quot;http://127.0.0.1:8080/&quot;、&quot;http://127.0.0.1:8080/demo.html&quot;）不管客户端访问的是地址中的uri是什么，代理服务器都会代理到URL的地址；当URL中不包含uri时（例如：&quot;http://127.0.0.1:8080&quot;），那么当客户端访问服务器时，代理服务器会根据客户端请求的uri来访问具体的URL地址。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;proxy_pass_request_body on|off：用于配置是否将客户端请求的请求体发送给代理服务器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;proxy_pass_request_headers on|off：用于配置是否将客户端请求的头信息发送给代理服务器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;proxy_set_header field value：可以更改nginx接收到的客户端请求的请求头信息，然后将新的请求头信息发送给被代理的服务器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;proxy_set_body value：ngin接收到客户端的请求后使用该指令可以修改request中的body体，然后将请求转发给代理服务器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;proxy_connect_timeout time：nginx服务器与被代理服务器之间尝试建立连接的的超时时间，默认为60s。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;proxy_read_timeot time：nginx服务器接收被代理服务器数据时最大的等待时间，默认为60s。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;proxy_send_timeout time：nginx服务器发送数据至被代理服务器的最大等待时间，例如60s内没有发出一个字节则默认断开连接，默认60s。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;proxy_http_version 1.0|1.1：nginx服务器提供代理服务的http协议版本。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;proxy_method method：nginx服务器设置请求被代理服务器时使用的请求方法，一般为POST或者GET。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;proxy_ignore_client_abort：当客户端中断网络请求时，nginx服务是否中断对代理服务器的请求，默认off。&lt;/span&gt;&lt;/p&gt;
&lt;h2 align=&quot;left&quot;&gt;五 四层代理配置&lt;/h2&gt;
&lt;h3 align=&quot;left&quot;&gt;5.1 四层代理&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;nginx-1.9.0 开始支持 TCP 代理，即4层代理，编译安装默认不会支持，需要加上 –with-stream 参数编译。&lt;/span&gt;&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;5.2 环境预设&lt;/h3&gt;
&lt;div yne-bulb-block=&quot;table&quot;&gt;
&lt;table&gt;&lt;colgroup/&gt;&lt;colgroup&gt;&lt;col width=&quot;218&quot;/&gt;&lt;/colgroup&gt;&lt;colgroup&gt;&lt;col width=&quot;221&quot;/&gt;&lt;/colgroup&gt;&lt;colgroup&gt;&lt;col width=&quot;155&quot;/&gt;&lt;/colgroup&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr&gt;&lt;td align=&quot;center&quot; data-cell-id=&quot;5716-1586863407710-cell-0-0&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;IP:端口&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;5716-1586863407710-cell-0-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;后端RS&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;5716-1586863407710-cell-0-2&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;备注&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td align=&quot;center&quot; data-cell-id=&quot;5716-1586863407710-cell-1-0&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;172.24.10.21:8888（nginx01）&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;5716-1586863407710-cell-1-1&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;172.24.10.22:81（nginx02）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;172.24.10.23:81（nginx03）&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;5716-1586863407710-cell-1-2&quot;&gt;
&lt;p&gt;&lt;span&gt;反向代理81端口Web&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td align=&quot;center&quot; data-cell-id=&quot;5716-1586863407710-cell-2-0&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;172.24.10.21:2222（nginx01）&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;5716-1586863407710-cell-2-1&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;172.24.10.24:22（nginx04）&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;5716-1586863407710-cell-2-2&quot;&gt;
&lt;p&gt;&lt;span&gt;反向代理ssh&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@nginx02 ~]&lt;span&gt;# mkdir /usr/share/nginx/rs/&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; [root@nginx02 ~]&lt;span&gt;# echo '&amp;lt;h1&amp;gt;Rs172.24.10.22-81&amp;lt;/h1&amp;gt;' &amp;gt; /usr/share/nginx/rs/index.html&lt;/span&gt;
&lt;span&gt;  3&lt;/span&gt; [root@nginx02 ~]&lt;span&gt;# cat &amp;gt; /etc/nginx/conf.d/rs.conf &amp;lt;&amp;lt;EOF&lt;/span&gt;
&lt;span&gt;  4&lt;/span&gt; server {
&lt;span&gt;  5&lt;/span&gt;     listen  81;
&lt;span&gt;  6&lt;/span&gt;     server_name 172.24.10.22;
&lt;span&gt;  7&lt;/span&gt;     location / {
&lt;span&gt;  8&lt;/span&gt;         root   /usr/share/nginx/rs;
&lt;span&gt;  9&lt;/span&gt;         &lt;span&gt;index&lt;/span&gt;  &lt;span&gt;index&lt;/span&gt;.html;
&lt;span&gt; 10&lt;/span&gt;         access_log  /var/log/nginx/rs.access.log  main;
&lt;span&gt; 11&lt;/span&gt;         error_log   /var/log/nginx/rs.error.log  &lt;span&gt;warn&lt;/span&gt;;
&lt;span&gt; 12&lt;/span&gt;     }
&lt;span&gt; 13&lt;/span&gt; }
&lt;span&gt; 14&lt;/span&gt; EOF
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@nginx02 ~]&lt;span&gt;# nginx -t -c /etc/nginx/nginx.conf        #检查配置文件&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; [root@nginx02 ~]&lt;span&gt;# nginx -s reload                        #重载配置文件&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@nginx03 ~]&lt;span&gt;# mkdir /usr/share/nginx/rs/&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; [root@nginx03 ~]&lt;span&gt;# echo '&amp;lt;h1&amp;gt;Rs172.24.10.23-81&amp;lt;/h1&amp;gt;' &amp;gt; /usr/share/nginx/rs/index.html&lt;/span&gt;
&lt;span&gt;  3&lt;/span&gt; [root@nginx03 ~]&lt;span&gt;# cat &amp;gt; /etc/nginx/conf.d/rs.conf &amp;lt;&amp;lt;EOF&lt;/span&gt;
&lt;span&gt;  4&lt;/span&gt; server {
&lt;span&gt;  5&lt;/span&gt;     listen  81;
&lt;span&gt;  6&lt;/span&gt;     server_name 172.24.10.23;
&lt;span&gt;  7&lt;/span&gt;     location / {
&lt;span&gt;  8&lt;/span&gt;         root   /usr/share/nginx/rs;
&lt;span&gt;  9&lt;/span&gt;         &lt;span&gt;index&lt;/span&gt;  &lt;span&gt;index&lt;/span&gt;.html;
&lt;span&gt; 10&lt;/span&gt;         access_log  /var/log/nginx/rs.access.log  main;
&lt;span&gt; 11&lt;/span&gt;         error_log   /var/log/nginx/rs.error.log  &lt;span&gt;warn&lt;/span&gt;;
&lt;span&gt; 12&lt;/span&gt;     }
&lt;span&gt; 13&lt;/span&gt; }
&lt;span&gt; 14&lt;/span&gt; EOF
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@nginx02 ~]&lt;span&gt;# nginx -t -c /etc/nginx/nginx.conf        #检查配置文件&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; [root@nginx02 ~]&lt;span&gt;# nginx -s reload                        #重载配置文件&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 align=&quot;left&quot;&gt;5.3 配置四层代理&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@nginx01 ~]&lt;span&gt;# cat &amp;gt;&amp;gt; /etc/nginx/nginx.conf &amp;lt;&amp;lt; EOF&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; stream {
&lt;span&gt;  3&lt;/span&gt;     upstream myweb {
&lt;span&gt;  4&lt;/span&gt;         server 172.24.10.22:81 weight=5 max_fails=1 fail_timeout=10s;
&lt;span&gt;  5&lt;/span&gt;         server 172.24.10.23:81;
&lt;span&gt;  6&lt;/span&gt;     }
&lt;span&gt;  7&lt;/span&gt;     upstream myssh {
&lt;span&gt;  8&lt;/span&gt;         hash $remote_addr consistent;
&lt;span&gt;  9&lt;/span&gt;         server 172.24.10.24:22;
&lt;span&gt; 10&lt;/span&gt;     }
&lt;span&gt; 11&lt;/span&gt; 
&lt;span&gt; 12&lt;/span&gt;     server {
&lt;span&gt; 13&lt;/span&gt;         listen  8888;
&lt;span&gt; 14&lt;/span&gt;         proxy_connect_timeout 2s;
&lt;span&gt; 15&lt;/span&gt;         proxy_timeout 900s;
&lt;span&gt; 16&lt;/span&gt;         proxy_pass myweb;
&lt;span&gt; 17&lt;/span&gt;     }
&lt;span&gt; 18&lt;/span&gt; 
&lt;span&gt; 19&lt;/span&gt;     server {
&lt;span&gt; 20&lt;/span&gt;         listen  2222;
&lt;span&gt; 21&lt;/span&gt;         proxy_connect_timeout 2s;
&lt;span&gt; 22&lt;/span&gt;         proxy_timeout 900s;
&lt;span&gt; 23&lt;/span&gt;         proxy_pass myssh;
&lt;span&gt; 24&lt;/span&gt;     }
&lt;span&gt; 25&lt;/span&gt; }
&lt;span&gt; 26&lt;/span&gt; EOF
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;提示：stream和http同等级，因此如上配置需要追加至主配置文件最后。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@&lt;span&gt;proxy&lt;/span&gt; ~]&lt;span&gt;# nginx -t -c /etc/nginx/nginx.conf      #检查配置文件&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; [root@&lt;span&gt;proxy&lt;/span&gt; ~]&lt;span&gt;# nginx -s reload                              #重载配置文件&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 align=&quot;left&quot;&gt;5.4 确认验证&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;浏览器访问：http://113.31.111.246:8888/。&lt;/span&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot; yne-bulb-block=&quot;image&quot;&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/680719/202007/680719-20200717084911424-935873660.png&quot;&gt;&lt;span&gt;&lt;img width=&quot;336&quot; height=&quot;81&quot; title=&quot;clipboard&quot; alt=&quot;clipboard&quot; src=&quot;https://img2020.cnblogs.com/blog/680719/202007/680719-20200717084911590-3528632.png&quot; border=&quot;0&quot; data-media-type=&quot;image&quot; data-attr-org-src-id=&quot;7D5A24E793F24CD2A3AE92C27071F96C&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;[root@proxy ~]# ssh -p 2222 172.24.9.247 #测试ssh&lt;/span&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot; yne-bulb-block=&quot;image&quot;&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/680719/202007/680719-20200717084911772-1790847968.png&quot;&gt;&lt;span&gt;&lt;img width=&quot;543&quot; height=&quot;83&quot; title=&quot;clipboard&quot; alt=&quot;clipboard&quot; src=&quot;https://img2020.cnblogs.com/blog/680719/202007/680719-20200717084911939-2127021580.png&quot; border=&quot;0&quot; data-media-type=&quot;image&quot; data-attr-org-src-id=&quot;EBA0219909A04EA1BFE932E22C2D283C&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;提示：更多代理模块细节，参考《附001.Nginx代理相关模块解析》。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 align=&quot;left&quot;&gt;六 按类型反向代理配置&lt;/h2&gt;
&lt;h3 align=&quot;left&quot;&gt;6.1 环境预设&lt;/h3&gt;
&lt;div yne-bulb-block=&quot;table&quot;&gt;
&lt;table&gt;&lt;colgroup/&gt;&lt;colgroup&gt;&lt;col width=&quot;206&quot;/&gt;&lt;/colgroup&gt;&lt;colgroup&gt;&lt;col width=&quot;206&quot;/&gt;&lt;/colgroup&gt;&lt;colgroup&gt;&lt;col width=&quot;206&quot;/&gt;&lt;/colgroup&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr&gt;&lt;td align=&quot;center&quot; data-cell-id=&quot;3236-1592666778822-cell-0-0&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;主机&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;3236-1592666778822-cell-0-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;IP&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;3236-1592666778822-cell-0-2&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;备注&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;center&quot; data-cell-id=&quot;3236-1592666778822-cell-1-0&quot;&gt;
&lt;p&gt;&lt;span&gt;nginx01&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;3236-1592666778822-cell-1-1&quot;&gt;
&lt;p&gt;&lt;span&gt;172.24.10.21&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;3236-1592666778822-cell-1-2&quot;&gt;
&lt;p&gt;&lt;span&gt;反向代理服务器&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td align=&quot;center&quot; data-cell-id=&quot;3236-1592666778822-cell-2-0&quot;&gt;
&lt;p&gt;&lt;span&gt;nginx02&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;3236-1592666778822-cell-2-1&quot;&gt;
&lt;p&gt;&lt;span&gt;172.24.10.22&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;3236-1592666778822-cell-2-2&quot;&gt;
&lt;p&gt;&lt;span&gt;chrmoe类型资源&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;firefox类型资源&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td align=&quot;center&quot; data-cell-id=&quot;3236-1592666778822-cell-3-0&quot;&gt;
&lt;p&gt;&lt;span&gt;nginx03&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;3236-1592666778822-cell-3-1&quot;&gt;
&lt;p&gt;&lt;span&gt;172.24.10.23&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;3236-1592666778822-cell-3-2&quot;&gt;
&lt;p&gt;&lt;span&gt;iPhone类型资源&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;android类型资源&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;center&quot; data-cell-id=&quot;3236-1592666778822-cell-4-0&quot;&gt;
&lt;p&gt;&lt;span&gt;nginx04&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;3236-1592666778822-cell-4-1&quot;&gt;
&lt;p&gt;&lt;span&gt;172.24.10.24&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;3236-1592666778822-cell-4-2&quot;&gt;
&lt;p&gt;&lt;span&gt;IE类型资源&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@nginx02 ~]&lt;span&gt;# mkdir /usr/share/nginx/basebrowser/&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; [root@nginx02 ~]&lt;span&gt;# echo '&amp;lt;h1&amp;gt;Chrmoe-172.24.10.22&amp;lt;/h1&amp;gt;' &amp;gt; /usr/share/nginx/basebrowser/index01.html&lt;/span&gt;
&lt;span&gt;  3&lt;/span&gt; [root@nginx02 ~]&lt;span&gt;# echo '&amp;lt;h1&amp;gt;Firefox-172.24.10.22&amp;lt;/h1&amp;gt;' &amp;gt; /usr/share/nginx/basebrowser/index02.html&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@nginx02 ~]&lt;span&gt;# cat &amp;gt; /etc/nginx/conf.d/basebrowser.conf &amp;lt;&amp;lt;EOF&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; server {
&lt;span&gt;  3&lt;/span&gt;     listen  88;
&lt;span&gt;  4&lt;/span&gt;     server_name 172.24.10.22;
&lt;span&gt;  5&lt;/span&gt;     location / {
&lt;span&gt;  6&lt;/span&gt;         root   /usr/share/nginx/basebrowser;
&lt;span&gt;  7&lt;/span&gt;         &lt;span&gt;index&lt;/span&gt;  &lt;span&gt;index&lt;/span&gt;01.html;
&lt;span&gt;  8&lt;/span&gt;         access_log  /var/log/nginx/chrmoebrowser.access.log  main;
&lt;span&gt;  9&lt;/span&gt;         error_log   /var/log/nginx/chrmoebrowser.error.log  &lt;span&gt;warn&lt;/span&gt;;
&lt;span&gt; 10&lt;/span&gt;     }
&lt;span&gt; 11&lt;/span&gt; }
&lt;span&gt; 12&lt;/span&gt; server {
&lt;span&gt; 13&lt;/span&gt;     listen  89;
&lt;span&gt; 14&lt;/span&gt;     server_name 172.24.10.22;
&lt;span&gt; 15&lt;/span&gt;     location / {
&lt;span&gt; 16&lt;/span&gt;         root   /usr/share/nginx/basebrowser;
&lt;span&gt; 17&lt;/span&gt;         &lt;span&gt;index&lt;/span&gt;  &lt;span&gt;index&lt;/span&gt;02.html;
&lt;span&gt; 18&lt;/span&gt;         access_log  /var/log/nginx/firefoxbrowser.access.log  main;
&lt;span&gt; 19&lt;/span&gt;         error_log   /var/log/nginx/firefoxbrowser.error.log  &lt;span&gt;warn&lt;/span&gt;;
&lt;span&gt; 20&lt;/span&gt;     }
&lt;span&gt; 21&lt;/span&gt; }
&lt;span&gt; 22&lt;/span&gt; EOF
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@nginx03 ~]&lt;span&gt;# mkdir /usr/share/nginx/cellphone/&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; [root@nginx03 ~]&lt;span&gt;# echo '&amp;lt;h1&amp;gt;iPhone-172.24.10.23&amp;lt;/h1&amp;gt;' &amp;gt; /usr/share/nginx/cellphone/index01.html&lt;/span&gt;
&lt;span&gt;  3&lt;/span&gt; [root@nginx03 ~]&lt;span&gt;# echo '&amp;lt;h1&amp;gt;Android-172.24.10.23&amp;lt;/h1&amp;gt;' &amp;gt; /usr/share/nginx/cellphone/index02.html&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@nginx03 ~]&lt;span&gt;# cat &amp;gt; /etc/nginx/conf.d/cellphone.conf &amp;lt;&amp;lt;EOF&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; server {
&lt;span&gt;  3&lt;/span&gt;     listen  88;
&lt;span&gt;  4&lt;/span&gt;     server_name 172.24.10.23;
&lt;span&gt;  5&lt;/span&gt;     location / {
&lt;span&gt;  6&lt;/span&gt;         root   /usr/share/nginx/cellphone;
&lt;span&gt;  7&lt;/span&gt;         &lt;span&gt;index&lt;/span&gt;  &lt;span&gt;index&lt;/span&gt;01.html;
&lt;span&gt;  8&lt;/span&gt;         access_log  /var/log/nginx/iphone.access.log  main;
&lt;span&gt;  9&lt;/span&gt;         error_log   /var/log/nginx/iphone.error.log  &lt;span&gt;warn&lt;/span&gt;;
&lt;span&gt; 10&lt;/span&gt;     }
&lt;span&gt; 11&lt;/span&gt; }
&lt;span&gt; 12&lt;/span&gt; server {
&lt;span&gt; 13&lt;/span&gt;     listen  89;
&lt;span&gt; 14&lt;/span&gt;     server_name 172.24.10.23;
&lt;span&gt; 15&lt;/span&gt;     location / {
&lt;span&gt; 16&lt;/span&gt;         root   /usr/share/nginx/cellphone;
&lt;span&gt; 17&lt;/span&gt;         &lt;span&gt;index&lt;/span&gt;  &lt;span&gt;index&lt;/span&gt;02.html;
&lt;span&gt; 18&lt;/span&gt;         access_log  /var/log/nginx/android.access.log  main;
&lt;span&gt; 19&lt;/span&gt;         error_log   /var/log/nginx/android.error.log  &lt;span&gt;warn&lt;/span&gt;;
&lt;span&gt; 20&lt;/span&gt;     }
&lt;span&gt; 21&lt;/span&gt; }
&lt;span&gt; 22&lt;/span&gt; EOF
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@nginx04 ~]&lt;span&gt;# mkdir /usr/share/nginx/iebrowser/&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; [root@nginx04 ~]&lt;span&gt;# echo '&amp;lt;h1&amp;gt;IE Browser-172.24.10.24&amp;lt;/h1&amp;gt;' &amp;gt; /usr/share/nginx/iebrowser/index.html&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@nginx04 ~]&lt;span&gt;# cat &amp;gt; /etc/nginx/conf.d/iebrowser.conf &amp;lt;&amp;lt;EOF&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; server {
&lt;span&gt;  3&lt;/span&gt;     listen  88;
&lt;span&gt;  4&lt;/span&gt;     server_name 172.24.10.24;
&lt;span&gt;  5&lt;/span&gt;     location / {
&lt;span&gt;  6&lt;/span&gt;         root   /usr/share/nginx/iebrowser;
&lt;span&gt;  7&lt;/span&gt;         &lt;span&gt;index&lt;/span&gt;  &lt;span&gt;index&lt;/span&gt;.html;
&lt;span&gt;  8&lt;/span&gt;         access_log  /var/log/nginx/iebrowser.access.log  main;
&lt;span&gt;  9&lt;/span&gt;         error_log   /var/log/nginx/iebrowser.error.log  &lt;span&gt;warn&lt;/span&gt;;
&lt;span&gt; 10&lt;/span&gt;     }
&lt;span&gt; 11&lt;/span&gt; }
&lt;span&gt; 12&lt;/span&gt; EOF
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@nginx02 ~]&lt;span&gt;# nginx -t -c /etc/nginx/nginx.conf        #检查配置文件&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; [root@nginx02 ~]&lt;span&gt;# nginx -s reload                        #重载配置文件&lt;/span&gt;
&lt;span&gt;  3&lt;/span&gt; [root@nginx03 ~]&lt;span&gt;# nginx -t -c /etc/nginx/nginx.conf      #检查配置文件&lt;/span&gt;
&lt;span&gt;  4&lt;/span&gt; [root@nginx03 ~]&lt;span&gt;# nginx -s reload                        #重载配置文件&lt;/span&gt;
&lt;span&gt;  5&lt;/span&gt; [root@nginx04 ~]&lt;span&gt;# nginx -t -c /etc/nginx/nginx.conf      #检查配置文件&lt;/span&gt;
&lt;span&gt;  6&lt;/span&gt; [root@nginx04 ~]&lt;span&gt;# nginx -s reload                        #重载配置文件&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@client ~]&lt;span&gt;# curl 172.24.10.22:89&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; &amp;lt;h1&amp;gt;Firefox-172.24.10.22&amp;lt;/h1&amp;gt;
&lt;span&gt;  3&lt;/span&gt; [root@client ~]&lt;span&gt;# &lt;/span&gt;
&lt;span&gt;  4&lt;/span&gt; [root@client ~]&lt;span&gt;# curl 172.24.10.22:88&lt;/span&gt;
&lt;span&gt;  5&lt;/span&gt; &amp;lt;h1&amp;gt;Chrmoe-172.24.10.22&amp;lt;/h1&amp;gt;
&lt;span&gt;  6&lt;/span&gt; [root@client ~]&lt;span&gt;# curl 172.24.10.22:89&lt;/span&gt;
&lt;span&gt;  7&lt;/span&gt; &amp;lt;h1&amp;gt;Firefox-172.24.10.22&amp;lt;/h1&amp;gt;
&lt;span&gt;  8&lt;/span&gt; [root@client ~]&lt;span&gt;# curl 172.24.10.23:88&lt;/span&gt;
&lt;span&gt;  9&lt;/span&gt; &amp;lt;h1&amp;gt;iPhone-172.24.10.23&amp;lt;/h1&amp;gt;
&lt;span&gt; 10&lt;/span&gt; [root@client ~]&lt;span&gt;# curl 172.24.10.23:89&lt;/span&gt;
&lt;span&gt; 11&lt;/span&gt; &amp;lt;h1&amp;gt;Android-172.24.10.23&amp;lt;/h1&amp;gt;
&lt;span&gt; 12&lt;/span&gt; [root@client ~]&lt;span&gt;# curl 172.24.10.24:88&lt;/span&gt;
&lt;span&gt; 13&lt;/span&gt; &amp;lt;h1&amp;gt;IE Browser-172.24.10.24&amp;lt;/h1&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 align=&quot;left&quot;&gt;6.2 反向代理配置&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@nginx01 ~]&lt;span&gt;# mkdir /usr/share/nginx/type/&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; [root@nginx01 ~]&lt;span&gt;# echo '&amp;lt;h1&amp;gt;Type-172.24.10.21&amp;lt;/h1&amp;gt;' &amp;gt; /usr/share/nginx/type/index.html&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@nginx01 ~]&lt;span&gt;# vi /etc/nginx/conf.d/type.conf&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; upstream chrome {
&lt;span&gt;  3&lt;/span&gt;     server 172.24.10.22:88;
&lt;span&gt;  4&lt;/span&gt; }
&lt;span&gt;  5&lt;/span&gt; upstream firefox {
&lt;span&gt;  6&lt;/span&gt;     server 172.24.10.22:89;
&lt;span&gt;  7&lt;/span&gt; }
&lt;span&gt;  8&lt;/span&gt; upstream iphone {
&lt;span&gt;  9&lt;/span&gt;     server 172.24.10.23:88;
&lt;span&gt; 10&lt;/span&gt; }
&lt;span&gt; 11&lt;/span&gt; upstream android {
&lt;span&gt; 12&lt;/span&gt;     server 172.24.10.23:89;
&lt;span&gt; 13&lt;/span&gt; }
&lt;span&gt; 14&lt;/span&gt; upstream iebrowser {
&lt;span&gt; 15&lt;/span&gt;     server 172.24.10.24:88;
&lt;span&gt; 16&lt;/span&gt; }
&lt;span&gt; 17&lt;/span&gt; 
&lt;span&gt; 18&lt;/span&gt; server {
&lt;span&gt; 19&lt;/span&gt;     listen  80;
&lt;span&gt; 20&lt;/span&gt;     server_name  type.linuxds.com;
&lt;span&gt; 21&lt;/span&gt;     access_log  /var/log/nginx/type.access.log  main;
&lt;span&gt; 22&lt;/span&gt;     error_log   /var/log/nginx/type.error.log  &lt;span&gt;warn&lt;/span&gt;;
&lt;span&gt; 23&lt;/span&gt;     proxy_set_header   Host             $host;
&lt;span&gt; 24&lt;/span&gt;     proxy_set_header   X-Real-IP        $remote_addr;
&lt;span&gt; 25&lt;/span&gt;     proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;
&lt;span&gt; 26&lt;/span&gt;     client_max_body_size       10m;   &lt;span&gt;#允许客户端请求的最大单文件字节数&lt;/span&gt;
&lt;span&gt; 27&lt;/span&gt;     client_body_buffer_size    128k;  &lt;span&gt;#缓冲区代理缓冲用户端请求的最大字节数&lt;/span&gt;
&lt;span&gt; 28&lt;/span&gt;     proxy_connect_timeout      300;   &lt;span&gt;#nginx跟后端服务器连接超时时间(代理连接超时)&lt;/span&gt;
&lt;span&gt; 29&lt;/span&gt;     proxy_send_timeout         300;   &lt;span&gt;#后端服务器数据回传时间(代理发送超时)&lt;/span&gt;
&lt;span&gt; 30&lt;/span&gt;     proxy_read_timeout         300;   &lt;span&gt;#连接成功后，后端服务器响应时间(代理接收超时)&lt;/span&gt;
&lt;span&gt; 31&lt;/span&gt;     proxy_buffer_size          4k;            &lt;span&gt;#设置代理服务器（nginx）保存用户头信息的缓冲区大小&lt;/span&gt;
&lt;span&gt; 32&lt;/span&gt;     proxy_buffers              4 32k; &lt;span&gt;#proxy_buffers缓冲区，网页平均在32k以下的话，这样设置&lt;/span&gt;
&lt;span&gt; 33&lt;/span&gt;     proxy_busy_buffers_size    64k;   &lt;span&gt;#高负荷下缓冲大小（proxy_buffers*2）&lt;/span&gt;
&lt;span&gt; 34&lt;/span&gt;     proxy_temp_file_write_size 64k;   &lt;span&gt;#设定缓存文件夹大小，大于这个值，将从upstream服务器传&lt;/span&gt;
&lt;span&gt; 35&lt;/span&gt;     location / {
&lt;span&gt; 36&lt;/span&gt;         root  /usr/share/nginx/type/;
&lt;span&gt; 37&lt;/span&gt;         &lt;span&gt;index&lt;/span&gt; &lt;span&gt;index&lt;/span&gt;.html;
&lt;span&gt; 38&lt;/span&gt; 
&lt;span&gt; 39&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; ($http_user_agent ~* &quot;&lt;span&gt;chrome&lt;/span&gt;&quot;){
&lt;span&gt; 40&lt;/span&gt;                 proxy_pass http://chrome;
&lt;span&gt; 41&lt;/span&gt;                 }
&lt;span&gt; 42&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; ($http_user_agent ~* &quot;&lt;span&gt;firefox&lt;/span&gt;&quot;){
&lt;span&gt; 43&lt;/span&gt;                 proxy_pass http://firefox;
&lt;span&gt; 44&lt;/span&gt;                 }
&lt;span&gt; 45&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; ($http_user_agent ~* &quot;&lt;span&gt;android&lt;/span&gt;&quot;){
&lt;span&gt; 46&lt;/span&gt;                 proxy_pass http://android;
&lt;span&gt; 47&lt;/span&gt;                 }
&lt;span&gt; 48&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; ($http_user_agent ~* &quot;&lt;span&gt;iphone&lt;/span&gt;&quot;){
&lt;span&gt; 49&lt;/span&gt;                 proxy_pass http://iphone;
&lt;span&gt; 50&lt;/span&gt;                 }
&lt;span&gt; 51&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; ($http_user_agent ~* &quot;&lt;span&gt;MSIE&lt;/span&gt;&quot;){
&lt;span&gt; 52&lt;/span&gt;                 proxy_pass http://iebrowser;
&lt;span&gt; 53&lt;/span&gt;                 }
&lt;span&gt; 54&lt;/span&gt;     }
&lt;span&gt; 55&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@nginx01 ~]&lt;span&gt;# nginx -t -c /etc/nginx/nginx.conf        #检查配置文件&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; [root@nginx01 ~]&lt;span&gt;# nginx -s reload                        #重载配置文件&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 align=&quot;left&quot;&gt;6.3 确认验证&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;不同浏览器分别访问：http://type.linuxds.com/&lt;/span&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot; yne-bulb-block=&quot;image&quot;&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/680719/202007/680719-20200717084912199-1116500013.png&quot;&gt;&lt;span&gt;&lt;img width=&quot;403&quot; height=&quot;333&quot; title=&quot;clipboard&quot; alt=&quot;clipboard&quot; src=&quot;https://img2020.cnblogs.com/blog/680719/202007/680719-20200717084912380-1495206032.png&quot; border=&quot;0&quot; data-media-type=&quot;image&quot; data-attr-org-src-id=&quot;415FEECC02304B29A5F15FBC294371C9&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/div&gt;
&lt;h2 align=&quot;left&quot;&gt;七 反向代理及缓存&lt;/h2&gt;
&lt;h3 align=&quot;left&quot;&gt;7.1 环境预设&lt;/h3&gt;
&lt;div yne-bulb-block=&quot;table&quot;&gt;
&lt;table&gt;&lt;colgroup/&gt;&lt;colgroup&gt;&lt;col width=&quot;206&quot;/&gt;&lt;/colgroup&gt;&lt;colgroup&gt;&lt;col width=&quot;206&quot;/&gt;&lt;/colgroup&gt;&lt;colgroup&gt;&lt;col width=&quot;206&quot;/&gt;&lt;/colgroup&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr&gt;&lt;td align=&quot;center&quot; data-cell-id=&quot;8460-1592922230080-cell-0-0&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;主机&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;8460-1592922230080-cell-0-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;IP&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;8460-1592922230080-cell-0-2&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;备注&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td align=&quot;center&quot; data-cell-id=&quot;8460-1592922230080-cell-1-0&quot;&gt;
&lt;p&gt;&lt;span&gt;nginx01&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;8460-1592922230080-cell-1-1&quot;&gt;
&lt;p&gt;&lt;span&gt;172.24.10.21&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;8460-1592922230080-cell-1-2&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;反向代理及缓存服务器&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;center&quot; data-cell-id=&quot;8460-1592922230080-cell-2-0&quot;&gt;
&lt;p&gt;&lt;span&gt;nginx02&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;8460-1592922230080-cell-2-1&quot;&gt;
&lt;p&gt;&lt;span&gt;172.24.10.22&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;8460-1592922230080-cell-2-2&quot;&gt;
&lt;p&gt;&lt;span&gt;后端RS01&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;center&quot; data-cell-id=&quot;8460-1592922230080-cell-3-0&quot;&gt;
&lt;p&gt;&lt;span&gt;nginx03&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;8460-1592922230080-cell-3-1&quot;&gt;
&lt;p&gt;&lt;span&gt;172.24.10.23&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;8460-1592922230080-cell-3-2&quot;&gt;
&lt;p&gt;&lt;span&gt;后端RS01&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@nginx02 ~]&lt;span&gt;# mkdir /usr/share/nginx/cache/&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; [root@nginx02 ~]&lt;span&gt;# echo '&amp;lt;h1&amp;gt;Cache-172.24.10.22&amp;lt;/h1&amp;gt;' &amp;gt; /usr/share/nginx/cache/index.html&lt;/span&gt;
&lt;span&gt;  3&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@nginx02 ~]&lt;span&gt;# cat &amp;gt; /etc/nginx/conf.d/cache.conf &amp;lt;&amp;lt;EOF&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; server {
&lt;span&gt;  3&lt;/span&gt;     listen  90;
&lt;span&gt;  4&lt;/span&gt;     server_name 172.24.10.22;
&lt;span&gt;  5&lt;/span&gt;     location / {
&lt;span&gt;  6&lt;/span&gt;         root   /usr/share/nginx/cache;
&lt;span&gt;  7&lt;/span&gt;         &lt;span&gt;index&lt;/span&gt;  &lt;span&gt;index&lt;/span&gt;.html;
&lt;span&gt;  8&lt;/span&gt;         access_log  /var/log/nginx/cache.access.log  main;
&lt;span&gt;  9&lt;/span&gt;         error_log   /var/log/nginx/cache.error.log  &lt;span&gt;warn&lt;/span&gt;;
&lt;span&gt; 10&lt;/span&gt;     }
&lt;span&gt; 11&lt;/span&gt; }
&lt;span&gt; 12&lt;/span&gt; EOF
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@nginx02 ~]&lt;span&gt;# ll /usr/share/nginx/cache&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; total 16K
&lt;span&gt;  3&lt;/span&gt; -rw-r--r-- 1 root root  28 Jun 23 22:33 &lt;span&gt;index&lt;/span&gt;.html
&lt;span&gt;  4&lt;/span&gt; -rw-r--r-- 1 root root 11K Jun 23 22:34 nginx.jpg     &lt;span&gt;#上传一张测试图片&lt;/span&gt;
&lt;span&gt;  5&lt;/span&gt; [root@nginx02 ~]&lt;span&gt;# nginx -t -c /etc/nginx/nginx.conf      #检查配置文件&lt;/span&gt;
&lt;span&gt;  6&lt;/span&gt; [root@nginx02 ~]&lt;span&gt;# nginx -s reload                        #重载配置文件&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@nginx03 ~]&lt;span&gt;# mkdir /usr/share/nginx/cache/&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; [root@nginx03 ~]&lt;span&gt;# echo '&amp;lt;h1&amp;gt;Cache-172.24.10.23&amp;lt;/h1&amp;gt;' &amp;gt; /usr/share/nginx/cache/index.html&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@nginx03 ~]&lt;span&gt;# cat &amp;gt; /etc/nginx/conf.d/cache.conf &amp;lt;&amp;lt;EOF&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; server {
&lt;span&gt;  3&lt;/span&gt;     listen  90;
&lt;span&gt;  4&lt;/span&gt;     server_name 172.24.10.23;
&lt;span&gt;  5&lt;/span&gt;     location / {
&lt;span&gt;  6&lt;/span&gt;         root   /usr/share/nginx/cache;
&lt;span&gt;  7&lt;/span&gt;         &lt;span&gt;index&lt;/span&gt;  &lt;span&gt;index&lt;/span&gt;.html;
&lt;span&gt;  8&lt;/span&gt;         access_log  /var/log/nginx/cache.access.log  main;
&lt;span&gt;  9&lt;/span&gt;         error_log   /var/log/nginx/cache.error.log  &lt;span&gt;warn&lt;/span&gt;;
&lt;span&gt; 10&lt;/span&gt;     }
&lt;span&gt; 11&lt;/span&gt; }
&lt;span&gt; 12&lt;/span&gt; EOF
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@nginx03 ~]&lt;span&gt;# ll /usr/share/nginx/cache&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; total 16K
&lt;span&gt;  3&lt;/span&gt; -rw-r--r-- 1 root root  28 Jun 23 22:33 &lt;span&gt;index&lt;/span&gt;.html
&lt;span&gt;  4&lt;/span&gt; -rw-r--r-- 1 root root 11K Jun 23 22:34 nginx.jpg     &lt;span&gt;#上传一张测试图片&lt;/span&gt;
&lt;span&gt;  5&lt;/span&gt; [root@nginx03 ~]&lt;span&gt;# nginx -t -c /etc/nginx/nginx.conf      #检查配置文件&lt;/span&gt;
&lt;span&gt;  6&lt;/span&gt; [root@nginx03 ~]&lt;span&gt;# nginx -s reload                        #重载配置文件&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 align=&quot;left&quot;&gt;7.2 配置代理及缓存&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@nginx01 ~]&lt;span&gt;# mkdir -p /data/cache                     #创建缓存目录&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; [root@nginx01 ~]&lt;span&gt;# mkdir -p /data/cache_temp              #创建缓存临时目录&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@nginx01 ~]&lt;span&gt;# vi /etc/nginx/nginx.conf         #追加如下代码日志记录&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; ……
&lt;span&gt;  3&lt;/span&gt; log_format  main  '[$remote_addr]-[$remote_user]-[$time_local]-[&quot;&lt;span&gt;$request&lt;/span&gt;&quot;]'
&lt;span&gt;  4&lt;/span&gt;                       '[$status]-[$body_bytes_sent]-[&quot;&lt;span&gt;$http_referer&lt;/span&gt;&quot;]'
&lt;span&gt;  5&lt;/span&gt;                       '[&quot;&lt;span&gt;$http_user_agent&lt;/span&gt;&quot;]-[&quot;&lt;span&gt;$http_x_forwarded_for&lt;/span&gt;&quot;]';
&lt;span&gt;  6&lt;/span&gt;                       '[$upstream_addr]-[$upstream_status]-[$request_time]-[$upstream_response_time]'
&lt;span&gt;  7&lt;/span&gt; ……
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@nginx01 ~]&lt;span&gt;# vi /etc/nginx/conf.d/cache.conf&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; upstream cache {
&lt;span&gt;  3&lt;/span&gt; server 172.24.10.22:90;
&lt;span&gt;  4&lt;/span&gt; server 172.24.10.23:90;
&lt;span&gt;  5&lt;/span&gt;     }
&lt;span&gt;  6&lt;/span&gt; 
&lt;span&gt;  7&lt;/span&gt; proxy_temp_path /&lt;span&gt;data&lt;/span&gt;/cache_temp;
&lt;span&gt;  8&lt;/span&gt; proxy_cache_path /&lt;span&gt;data&lt;/span&gt;/cache levels=1:2 keys_zone=mycache:20m max_size=10g inactive=60m use_temp_path=off;
&lt;span&gt;  9&lt;/span&gt; 
&lt;span&gt; 10&lt;/span&gt; server {
&lt;span&gt; 11&lt;/span&gt;     listen          80;
&lt;span&gt; 12&lt;/span&gt;     server_name     cache.linuxds.com;
&lt;span&gt; 13&lt;/span&gt;     access_log  /var/log/nginx/cache.access.log  main;
&lt;span&gt; 14&lt;/span&gt;     error_log   /var/log/nginx/cache.error.log  &lt;span&gt;warn&lt;/span&gt;;
&lt;span&gt; 15&lt;/span&gt; 
&lt;span&gt; 16&lt;/span&gt;     location / {
&lt;span&gt; 17&lt;/span&gt;         expires 3d;
&lt;span&gt; 18&lt;/span&gt;         add_header  Nginx-Cache &quot;&lt;span&gt;$upstream_cache_status&lt;/span&gt;&quot;; &lt;span&gt;#增加一个头信息&lt;/span&gt;
&lt;span&gt; 19&lt;/span&gt; 
&lt;span&gt; 20&lt;/span&gt;         proxy_cache mycache;                          &lt;span&gt;#调用定义的cache zone&lt;/span&gt;
&lt;span&gt; 21&lt;/span&gt;         proxy_pass  http://cache;                             &lt;span&gt;#配置反向代理&lt;/span&gt;
&lt;span&gt; 22&lt;/span&gt;         proxy_set_header  Host      $host;
&lt;span&gt; 23&lt;/span&gt;         proxy_set_header  X-Real-IP $remote_addr;
&lt;span&gt; 24&lt;/span&gt;         proxy_set_header  X-Forwarded-For $proxy_add_x_forwarded_for;
&lt;span&gt; 25&lt;/span&gt; 
&lt;span&gt; 26&lt;/span&gt;         proxy_cache_valid  200 302 304 2h;                   &lt;span&gt;#200和302及304头信息过期时间为2小时&lt;/span&gt;
&lt;span&gt; 27&lt;/span&gt;         proxy_cache_valid  any 10m;                          &lt;span&gt;#其他过期时间10分钟&lt;/span&gt;
&lt;span&gt; 28&lt;/span&gt;         proxy_cache_key    $host$request_uri$uri$is_args$args;        &lt;span&gt;#定义缓存的key&lt;/span&gt;
&lt;span&gt; 29&lt;/span&gt;         proxy_cache_bypass $cookie_nocache $arg_comment;              &lt;span&gt;#配置不缓存&lt;/span&gt;
&lt;span&gt; 30&lt;/span&gt;         proxy_no_cache $arg_nocache;                          &lt;span&gt;#配置不缓存&lt;/span&gt;
&lt;span&gt; 31&lt;/span&gt;         proxy_cache_lock on;
&lt;span&gt; 32&lt;/span&gt;         proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504; &lt;span&gt;#一个服务报错请求下一个&lt;/span&gt;
&lt;span&gt; 33&lt;/span&gt;     }
&lt;span&gt; 34&lt;/span&gt;     location ~ /purge(/.*) {
&lt;span&gt; 35&lt;/span&gt;         allow       127.0.0.1;
&lt;span&gt; 36&lt;/span&gt;         allow       172.24.10.0/24;
&lt;span&gt; 37&lt;/span&gt;         deny        all;
&lt;span&gt; 38&lt;/span&gt;         proxy_cache_purge mycache $1$is_args$args;
&lt;span&gt; 39&lt;/span&gt;     }
&lt;span&gt; 40&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@nginx01 ~]&lt;span&gt;# nginx -t -c /etc/nginx/nginx.conf        #检查配置文件&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; [root@nginx01 ~]&lt;span&gt;# nginx -s reload                        #重载配置文件&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;配置释义：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;proxy_cache_path：配置缓存目录，文件目录层级2级，空间名字20m大小，目录最大大小10g(超过启动nginx自己的淘汰规则)，在60分钟的时间内没有被访问就会被清理，并且不使用临时目录。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;proxy_no_cache：部分不设置缓存，cookie_nocache上面配置的参数,cookie_nocache不为0或者空，那么是不会进行缓存的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;proxy_cache_lock on：如果多个客户端请求的文件不在缓存（MISS），只有第一个这些请求是通过原始服务器的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;提示：proxy_no_cache和proxy_cache_bypass类似，其差异是proxy_no_cache用于控制什么情况下响应不被缓存。比如配置“proxy_no_cache$args_nocache”，如果带的nocache参数值至少有一个不为空或者为0，则响应将不被缓存。而proxy_cache_bypass，控制什么情况不使用缓存的内容，而是直接到后端获取最新的内容。如果命中，则$upstream_cache_status为BYPASS。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;延伸：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;upstream_cache_status状态如下：&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ul yne-block-type=&quot;list&quot;&gt;&lt;li&gt;&lt;span&gt;MISS：未命中缓存，即在缓存中找不到响应，因此从原始服务器获取响应。然后缓存响应；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;HIT：命中缓存，响应将直接来自有效的缓存；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;EXPIRED：缓存已经过期，响应包含来自原始服务器的新内容；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;STALE：命中了陈旧的缓存，因为源服务器未正确响应但proxy_cache_use_stale已配置。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;UPDATING：内容陈旧，因为条目当前正在更新以响应先前的请求，并且proxy_cache_use_stale updating已配置；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;REVALIDATED：Nginx验证了陈旧的内容依然有效；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;BYPASS：响应是从原始服务器获得。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意：使用proxy_cache_purge清除缓存，必须提前安装ngx_cache_purge模块，安装模块必须基于编译安装的Nginx。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;7.3 确认验证&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;客户端访问测试：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@client ~]&lt;span&gt;# curl -I http://cache.linuxds.com/nginx.jpg&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div align=&quot;center&quot; yne-bulb-block=&quot;image&quot;&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/680719/202007/680719-20200717084912556-340488004.png&quot;&gt;&lt;span&gt;&lt;img width=&quot;604&quot; height=&quot;545&quot; title=&quot;clipboard&quot; alt=&quot;clipboard&quot; src=&quot;https://img2020.cnblogs.com/blog/680719/202007/680719-20200717084912783-1147369332.png&quot; border=&quot;0&quot; data-media-type=&quot;image&quot; data-attr-org-src-id=&quot;059D438381EE4B3AA08A890307648D31&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;结论：第一次访问会出现MISS，没有命中缓存，第二次访问即可直接命中缓存。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;参考文档：https://blog.csdn.net/h13140995776/article/details/101174283。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 17 Jul 2020 00:49:00 +0000</pubDate>
<dc:creator>木二</dc:creator>
<og:description>一	Nginx代理 1.1	Nginx代理概述 nginx是一款自由的、开源的、高性能的HTTP服务器和反向代理服务器。同时也是一个IMAP、POP3、SMTP代理服务器。nginx可以作为一个HTT</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/itzgr/p/13327861.html</dc:identifier>
</item>
<item>
<title>一口气说出 4 种分布式一致性 Session 实现方式，面试杠杠的~ - 楼下小黑哥</title>
<link>http://www.cnblogs.com/goodAndyxublog/p/13327412.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/goodAndyxublog/p/13327412.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;公司有一个 Web 管理系统，使用 Tomcat 进行部署。由于是后台管理系统，所有的网页都需要登录授权之后才能进行相应的操作。&lt;/p&gt;
&lt;p&gt;起初这个系统的用的人也不多，为了节省资源，这个系统仅仅只是单机部署。后来随着用的人越来越多，单机已经有点扛不住了，于是我决定再部署了一台机器。&lt;/p&gt;
&lt;p&gt;这时后端系统有两台服务，于是我们使用 Nginx 作为反向代理，整体架构图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202007/1419561-20200717084116839-1387896943.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个架构图想必大家应该比较熟悉，现在主流的 Web 系统应该都是这么部署。&lt;/p&gt;
&lt;p&gt;经过一些调试之后，在一个夜深人静的晚上，将这套系统部署到了生产。本以为没有什么事的，很稳的交给测试小姐姐开始测试。&lt;/p&gt;
&lt;p&gt;这一测，出了大问题！测试小姐姐反馈，登录过后，没过一会又需要登录，操作好几次都是这样。&lt;/p&gt;
&lt;p&gt;检查了一下，系统应用，配置什么也没问题，那到底哪里出了问题？&lt;/p&gt;
&lt;p&gt;这个时候组长刚准备下班，看到我们这里有问题，于是过来了看了一下。简单了解的一下基本情况，很快就找到了问题的原因，然后在 Nginx 端修改了下配置，重启解决了问题。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;先点后赞，养成习惯~关注公号『程序通事』，快来呀！！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;分布式一致性-session&quot;&gt;分布式一致性 Session&lt;/h2&gt;
&lt;p&gt;解决完问题，组长坐下解释了问题原因：&lt;strong&gt;分布式一致性 Session&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;原先我们登录之后将会把用户登录信息放在 &lt;strong&gt;Session&lt;/strong&gt; 中，用户每次操作首先先校验 &lt;strong&gt;Session&lt;/strong&gt; 是否存在用户信息，如果不存在将会强制让用户先去登录。&lt;/p&gt;
&lt;p&gt;原先架构的中我们只有一台应用系统，所有操作都在一台 Tomcat 上，这当然没有什么问题。&lt;/p&gt;
&lt;p&gt;但是现在我们部署了两台系统，由于 Nginx 使用默认负载均衡策略（&lt;strong&gt;轮询&lt;/strong&gt;），请求将会按照时间顺序逐一分发到后端应用上。&lt;/p&gt;
&lt;p&gt;也就是说刚开始我们在 Tomcat1 登录之后，用户信息放在 Tomcat1 的 &lt;strong&gt;Session&lt;/strong&gt; 里。过了一会，请求又被 Nginx 分发到了 Tomcat2 上，这时 Tomcat2 上 &lt;strong&gt;Session&lt;/strong&gt; 里还没有用户信息，于是又要登录。&lt;/p&gt;
&lt;p&gt;另外由于我们系统采用单点登录的方式，Tomcat2 登录之后会将 Tomcat1 登录信息失效，于是乎等到 Nginx 再把流量分发到 Tomcat1 时，Session 中用户登录信息已经失效，又要重新登录。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202007/1419561-20200717084117007-1955841271.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;知道了问题，当然想知道解决办法了，于是组长教了下分布式一致性 Session 四种解决办法，小黑哥给大家整理了一下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202007/1419561-20200717084117187-1365291817.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面小黑哥将会以跟组长对话的形式，讲解分布式一致性 &lt;strong&gt;Session&lt;/strong&gt; 解决办法。&lt;/p&gt;
&lt;h2 id=&quot;session-复制&quot;&gt;Session 复制&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;组长：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果此时 Tomcat1 &lt;strong&gt;Session&lt;/strong&gt; 存在用户信息，而 Tomcat2 上没有存在。&lt;/p&gt;
&lt;p&gt;这时如果我们将 Tomcat1 的 &lt;strong&gt;Session&lt;/strong&gt; 复制到 Tomcat2 上，后面 Nginx 将请求转发到 Tomcat2 上，由于 Tomcat2 存在 &lt;strong&gt;Session&lt;/strong&gt; ，这时就不需要再重新登录了。&lt;/p&gt;
&lt;p&gt;架构图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202007/1419561-20200717084117449-444541995.jpg&quot; alt=&quot;一致性 Session-Session 复制&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Tomcat 的 &lt;strong&gt;Session&lt;/strong&gt; 复制的配置，网上有比较多的例子，这里小黑就不再贴了，感兴趣的同学可以自行搜索一下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;小黑：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对的，这种方式挺好啊。Tomcat 就支持这种方式，我们只需要修改 Tomcat 配置就好，我们应用代码都不用修改了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;组长：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;说的对，但是这种方式还是有很多缺点。&lt;/p&gt;
&lt;p&gt;第一，Session 复制传输需要占用内网带宽。&lt;/p&gt;
&lt;p&gt;第二，我们的例子就只有两台机器，这个复制性能还可以。但是假设我们有 &lt;strong&gt;N&lt;/strong&gt; 台机器，那么每次复制都要复制给 &lt;strong&gt;N-1&lt;/strong&gt; 台机器，如果机器很多，可能会形成网络风暴，复制性能也会呈指数级下降。&lt;/p&gt;
&lt;p&gt;第三， Tomcat 需要保存所有的 &lt;strong&gt;Session&lt;/strong&gt; 数据，这个方案的 &lt;strong&gt;Session&lt;/strong&gt; 存储在内存中，容易受到机器的总内存的限制。我们没办法通过加机器的方式&lt;strong&gt;水平扩展&lt;/strong&gt;，我们能做的方式就是加大机器内存。但是机器内存越大，价格真的很贵！！！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以不推荐使用这种方案。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;session-前端存储&quot;&gt;Session 前端存储&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;小黑：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;恩，这个方案确实有点不靠谱~&lt;/p&gt;
&lt;p&gt;哎，有了！我们的 Session 里面其实就是存了用户的信息，那我现在不存 Tomcat &lt;strong&gt;Session&lt;/strong&gt; 里，我把信息拿出来，存到浏览器的 &lt;strong&gt;Cookie&lt;/strong&gt; 中。&lt;/p&gt;
&lt;p&gt;这样，每个用户浏览器存储自己的 &lt;strong&gt;Cookie&lt;/strong&gt; 信息，服务端就不需要存储，这就解决了 Session 复制方案的缺陷了。&lt;/p&gt;
&lt;p&gt;接下来用户每次请求都把这个 &lt;strong&gt;Cookie&lt;/strong&gt; 给我发过来，我判断 &lt;strong&gt;Cookie&lt;/strong&gt; 里面用户信息不就好了。&lt;/p&gt;
&lt;p&gt;架构图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202007/1419561-20200717084117597-794450588.jpg&quot; alt=&quot;一致性 Session-Session 前端存储&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;组长，欣赏看了一下我：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对，你这个方案确实可行。&lt;/p&gt;
&lt;p&gt;不过么，如果用这种方案，首先你要想好加密方案。&lt;/p&gt;
&lt;p&gt;用户信息可是我们的敏感数据，不能让别人轻易的窃取或者篡改数据了。&lt;/p&gt;
&lt;p&gt;除了这个，这个方案每次请求都要携带 &lt;strong&gt;Cookie&lt;/strong&gt; 传输，这会占用外网的带宽，如果 &lt;strong&gt;Cookie&lt;/strong&gt; 过大，会增大网络的开销。&lt;/p&gt;
&lt;p&gt;另外，我们存储的数据大小，容易受到 &lt;strong&gt;Cookie&lt;/strong&gt; 限制。&lt;/p&gt;
&lt;p&gt;所以这种还是不怎么常用，不过也是一种思路。&lt;/p&gt;
&lt;p&gt;我比较推荐下面两种方案。&lt;/p&gt;
&lt;h2 id=&quot;session--粘滞（sticky-sessions）&quot;&gt;Session 粘滞（Sticky Sessions）&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;组长：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;刚才应该看到了，我只是对 Nginx 的配置做了一些修改，然后这个问题就解决了吧。&lt;/p&gt;
&lt;p&gt;其实这是因为我修改 Nginx 默认的负载均衡策略，使用 IP Hash 的方式。&lt;/p&gt;
&lt;p&gt;Nginx 会使用请求者的 IP 来做 Hash，然后分发到一台机器上，这样可以保证同一 IP 的请求都落在同一台 Tomcat 上。&lt;/p&gt;
&lt;p&gt;架构图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202007/1419561-20200717084117712-899171894.jpg&quot; alt=&quot;Session 粘滞-IP Hash&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面这种方式我们使用 Nginx 四层负载均衡方式，其实 Nginx 还可以做到七层负载均衡方式，也就是使用 Http 协议中的一些&lt;strong&gt;业务属性&lt;/strong&gt;来做 Hash，常见的有 &lt;em&gt;userId&lt;/em&gt;,&lt;em&gt;loginId&lt;/em&gt;等等。&lt;/p&gt;
&lt;p&gt;架构图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202007/1419561-20200717084117822-1862175924.jpg&quot; alt=&quot;一致性 Session-Session 粘滞-七层&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;小黑：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这种方案看起来挺简单的，我们只需要修改 Nginx 配置就好了，应用端配置无需改动。&lt;/p&gt;
&lt;p&gt;只要请求来源 IP &lt;strong&gt;足够的随机&lt;/strong&gt;，那么 IP HASH 之后两台应用上的流量将会足够随机。&lt;/p&gt;
&lt;p&gt;另外后面如果两台机器扛不住，我们还可以水平扩展，再加机器，只要修改 Nginx 配置即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;组长：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;你说的这几点都很正确！&lt;/p&gt;
&lt;p&gt;不过你有没有想过，像我们公司这种情况，所有人的出口的 IP 都是一个。那么我们公司的所有请求只会到一台机器上，那我们这种情况等于又变成单点了。&lt;/p&gt;
&lt;p&gt;另外如果 Tomcat 重启，&lt;strong&gt;Session&lt;/strong&gt; 由于是放置在内存内存中，这一部分的 &lt;strong&gt;Session&lt;/strong&gt; 将会丢失，这就导致这部分用户将会重新登录。&lt;/p&gt;
&lt;p&gt;最后，如果我们临时再加机器，修改完 Nginx 配置，重新启动之后，Nginx 将会重新计算 Hash 分发请求。&lt;/p&gt;
&lt;p&gt;这种情况就会导致有一部分用户重新路由到一台新机器上，由于没有 &lt;strong&gt;Session&lt;/strong&gt;，又需要重新登录了。&lt;/p&gt;
&lt;p&gt;不过么，Tomcat 重启或者新加机器次数不会很多，所以这个问题也不大，用户体验稍差点。&lt;/p&gt;
&lt;p&gt;今天的我们这个问题解决方案就先使用这个。&lt;/p&gt;
&lt;p&gt;不过后面我们还是改成下面这种方式。&lt;/p&gt;
&lt;h2 id=&quot;后端集中存储&quot;&gt;后端集中存储&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;组长：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上面几种的方式我们都是把 &lt;strong&gt;Session&lt;/strong&gt; 存储在应用内存上，应用机器只要重启，&lt;strong&gt;Session&lt;/strong&gt; 就会丢失。&lt;/p&gt;
&lt;p&gt;为了这个解决这个问题，我们将 &lt;strong&gt;Session&lt;/strong&gt; 单独存起来，保存到 Redis 或者 MySQL 中。&lt;/p&gt;
&lt;p&gt;不过由于 &lt;strong&gt;Session&lt;/strong&gt; 需要过期失效的特性，不需要持久化保存，所以这里我建议使用 Redis 来保存。&lt;/p&gt;
&lt;p&gt;这样架构就变成下方这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202007/1419561-20200717084117952-20947315.jpg&quot; alt=&quot;一致性 Session-Session 后端存储&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们使用这种方案，上没有 &lt;strong&gt;Session&lt;/strong&gt; 丢失的风险，当然前提是 Redis 不能宕机。&lt;/p&gt;
&lt;p&gt;另外后期如果应用可以直接水平扩展。&lt;/p&gt;
&lt;p&gt;如果后面应用的请求量很大，一台 Redis 扛不住了，那我们可以其实可以做集群扩展，根据缓存 Key 做路由。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;小黑：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对对，这种方式好~&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;组长：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;你不要高兴的太早，我们使用这个方案需要付出一定的代价的。&lt;/p&gt;
&lt;p&gt;首先我们每次请求都需要调用一次 Redis ，这就增加一次网络的开销。&lt;/p&gt;
&lt;p&gt;另外，引入 Redis，我们需要对相应的代码做出修改，这样复杂度就变高。&lt;/p&gt;
&lt;p&gt;所以说，这个方案有利也有弊，当然对于我们的场景来说，利大于弊。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;小黑：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;恩，好像是这样的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;组长:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;好了，这么晚了，问题解决了，我们去撸个串，我请客！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;小黑：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;老大，🐂！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;组长拍了拍小黑的脑袋：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我这一顿不是白吃哦，下个星期你把现在方式修改一下，修改成 Session 集中存储的方式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202007/1419561-20200717084118082-1522776624.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;给你一个小提示，可以使用 &lt;strong&gt;spring-session&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;小黑：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;好吧，吃人嘴短，下周我研究下。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;最后总结一下，当我们后端 Web 应用扩展到多台后，我们就会碰到分布式一致性 Session 的问题，主流解决方案有四种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Session 复制：利用 Tomcat 等 Web 容器同步复制&lt;/li&gt;
&lt;li&gt;Session 前端存储：利用用户浏览器中 Cookie 保存 Session 信息&lt;/li&gt;
&lt;li&gt;Session 粘滞方案：利用 Nginx 可以做四层 Hash 或七层 Hash 的特性，保证用户的请求都落在同一台机器上&lt;/li&gt;
&lt;li&gt;Session 后端集中存储方案：利用 Redis 集中存储 Session，Web 应用重启或扩容，Session 也无需丢失。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上面四种方案，优先推荐第四种。&lt;/p&gt;
&lt;p&gt;当然第四种方案需要一定的开发工作量，前期还没改造的过程可以选择 第三种方案中间过渡。&lt;/p&gt;
&lt;p&gt;好了，后面就要使用 Session 后端存储方案改造这个工程了，后面小黑哥再跟大家分享一下 &lt;strong&gt;spring-session&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;帮助&quot;&gt;帮助&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;架构师之路-session一致性架构设计实践&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;5.5384615384615&quot;&gt;
&lt;p&gt;欢迎关注我的公众号：程序通事，获得日常干货推送。如果您对我的专题内容感兴趣，也可以关注我的博客：&lt;a href=&quot;https://studyidea.cn&quot;&gt;studyidea.cn&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 17 Jul 2020 00:41:00 +0000</pubDate>
<dc:creator>楼下小黑哥</dc:creator>
<og:description>前言 公司有一个 Web 管理系统，使用 Tomcat 进行部署。由于是后台管理系统，所有的网页都需要登录授权之后才能进行相应的操作。 起初这个系统的用的人也不多，为了节省资源，这个系统仅仅只是单机部</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/goodAndyxublog/p/13327412.html</dc:identifier>
</item>
<item>
<title>痞子衡嵌入式：SNVS Master Key仅在i.MXRT10xx Hab关闭时才能用于DCP加解密 - 痞子衡</title>
<link>http://www.cnblogs.com/henjay724/p/13327060.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/henjay724/p/13327060.html</guid>
<description>&lt;p&gt;i.MXRT不仅仅是处理性能超强的MCU，也是安全等级极高的MCU。如果大家用过痞子衡开发的一站式安全启动工具 NXP-MCUBootUtility，应该会从其用户手册3.3节中了解到i.MXRT支持的几种安全启动等级，其中HAB加密启动方式和BEE/OTFAD加密启动方式中都提及了一种神秘的密钥 - SNVS Master Key，今天痞子衡就跟大家聊聊这个密钥用于DCP模块的注意事项&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;151.23572003218&quot;&gt;
&lt;hr/&gt;&lt;p&gt;　　大家好，我是痞子衡，是正经搞技术的痞子。今天痞子衡给大家介绍的是&lt;strong&gt;i.MXRT系列中数据协处理器DCP使用SNVS Master Key加解密的注意事项&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　i.MXRT不仅仅是处理性能超强的MCU，也是安全等级极高的MCU。如果大家用过痞子衡开发的一站式安全启动工具 &lt;a href=&quot;https://github.com/JayHeng/NXP-MCUBootUtility&quot;&gt;NXP-MCUBootUtility&lt;/a&gt;，应该会从其 &lt;a href=&quot;https://www.cnblogs.com/henjay724/p/10047071.html&quot;&gt;用户手册&lt;/a&gt; 3.3节中了解到i.MXRT支持的几种安全启动等级，其中HAB加密启动方式和BEE/OTFAD加密启动方式中都提及了一种神秘的密钥 - SNVS Master Key，今天痞子衡就跟大家聊聊这个密钥用于DCP模块的注意事项（文中仅以i.MXRT1060为例，其他RT10xx型号或许有微小差别）。&lt;/p&gt;
&lt;h3 id=&quot;一、dcp模块简介&quot;&gt;一、DCP模块简介&lt;/h3&gt;
&lt;p&gt;　　先来给大家科普下DCP模块，DCP是Data Co-Processor的简称，从名字上看是个通用数据协处理器。在i.MXRT1060 Security Reference Manual中有一张系统整体安全架构简图，这个简图中标出了DCP模块的主要功能 ：CRC-32算法、AES算法、Hash算法、类DMA数据搬移。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/cnblogs/i.MXRT10xx_DCP_security_subsystem.PNG&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　看到DCP支持的功能，你就能明白其模块命名的由来了。本质上它就是一个数据处理加速器，如果说CRC-32/Hash算法只是算出一个结果（下图中Mode3），而AES算法则是明文数据到密文数据的转换（存在数据迁移，下图中Mode2），DMA式数据搬移则更明显了（下图中Mode1），DCP内部集成了memcopy功能，可以实现比普通DMA方式效率更高的内存到内存数据块搬移，memcopy功能还支持blit模式，支持传输矩形数据块到frame buffer用于LCD显示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/cnblogs/i.MXRT10xx_DCP_block_diagram.PNG&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　我们今天主要是聊DCP的AES加解密功能，其支持AES-128算法，包含Electronic Code Book (ECB)和Cipher Block Chaining (CBC)模式，算法标准符合 &lt;a href=&quot;https://www.nist.gov/&quot;&gt;NIST&lt;/a&gt; US FIPS PUB 197 (2001)规范，AES运算的最小单元是16字节。&lt;/p&gt;
&lt;h3 id=&quot;二、dcp-aes密钥来源&quot;&gt;二、DCP-AES密钥来源&lt;/h3&gt;
&lt;p&gt;　　对于加解密而言，一个很重要的特性就是密钥管理。DCP的AES密钥（长度均为128bits）来源很丰富，按性质可分成四类：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;SRAM-based keys: 用户自定义的存放于SRAM中的密钥，最终会被写入DCP的KEY_DATA寄存器中，最多四组。&lt;/li&gt;
&lt;li&gt;Payload key: 用户自定义的跟加解密数据放一起的密钥，操作时DCP直接解析。&lt;/li&gt;
&lt;li&gt;eFuse SW_GP2 key: 用户烧录到eFuse SW_GP2区域的密钥，可锁定住让软件无法访问，但DCP可通过内置专用途径获取到。&lt;/li&gt;
&lt;li&gt;SNVS Master key: 芯片出厂时预存的唯一密钥，密钥值无法获知，DCP可通过内置专用途径获取到。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/cnblogs/i.MXRT10xx_DCP_aes_key_sources.PNG&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　选用SRAM-based keys和Payload key仅需要在DCP模块内部配置即可，而选用eFuse SW_GP2 key和SNVS Master key则要在如下IOMUXC_GPR寄存器中额外设置。&lt;/p&gt;
&lt;p&gt;　　IOMUXC_GPR_GPR10寄存器用于选择Key是来自eFuse SW_GP2还是SNVS Master Key：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/cnblogs/i.MXRT10xx_DCP_IOMUXC_GPR10.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　IOMUXC_GPR_GPR3寄存器用于选择Key是来自SNVS Master Key（总256bits）的低128bit还是高128bit（注意此寄存器对eFuse SW_GP2其实不生效，因为SW_GP2仅128bits）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/cnblogs/i.MXRT10xx_DCP_IOMUXC_GPR3.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;三、什么是snvs-master-key？&quot;&gt;三、什么是SNVS Master Key？&lt;/h3&gt;
&lt;p&gt;　　SNVS全称Secure Non-Volatile Storage，它既是DCP的配套模块，也是芯片系统的安全事务监测中心。它能够提供一个独特的Master Key给DCP模块，这个Master Key可有三种产生方式（在SNVS_LPMKCR中设置）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/cnblogs/i.MXRT10xx_DCP_SNVS_LPMKCR.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;OTPMK：这种就是直接使用eFuse里出厂预烧录的OTPMK（256bits），这个OTPMK是每个芯片唯一的，并且被锁住了软件不可访问。&lt;/li&gt;
&lt;li&gt;ZMK：这种是利用存在SNVS_LP ZMKRx寄存器组中的密钥，该秘钥可由用户写入，此密钥在芯片主电源断掉时会继续保留（因为在LP域可由纽扣电池供电），在芯片受到安全攻击时密钥会被自动擦除。&lt;/li&gt;
&lt;li&gt;CMK：前两者组合后的Key，即OTPMK和ZMK的异或结果。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;　　一般来说，使用最多的SNVS Master Key就是默认的OTPMK。&lt;/p&gt;
&lt;h3 id=&quot;四、两种dcp驱动&quot;&gt;四、两种DCP驱动&lt;/h3&gt;
&lt;p&gt;　　关于DCP模块的驱动，在下载的芯片SDK包里有两种：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;ROM版本：\SDK_2.x.x_EVK-MIMXRT1060\devices\MIMXRT1062\drivers\fsl_dcp.c&lt;/li&gt;
&lt;li&gt;SDK版本：\SDK_2.x.x_EVK-MIMXRT1060\middleware\mcu-boot\src\drivers\dcp\fsl_dcp.c&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;　　middleware里的DCP驱动是ROM team负责的，他们是在芯片Tapeout之前写的，属于早期驱动；device包里的DCP驱动才是SDK team负责的，是芯片Tapeout之后写的，是正式版本。&lt;/p&gt;
&lt;p&gt;　　两版驱动都实现了AES加解密，不过代码风格不同。比如ROM版本驱动的dcp_aes_ecb_crypt()函数同时支持加密和解密模式，而在SDK版本驱动里则分成两个函数：DCP_AES_EncryptEcb() - 加密 、DCP_AES_DecryptEcb() - 解密。&lt;/p&gt;
&lt;h3 id=&quot;五、dcp正确获取snvs-master-key&quot;&gt;五、DCP正确获取SNVS Master Key&lt;/h3&gt;
&lt;p&gt;　　前面铺垫了那么多，终于来到正题了。DCP模块如何拿到正确的SNVS Master Key？让我们以\SDK_2.x.x_EVK-MIMXRT1060\boards\evkmimxrt1060\driver_examples\dcp 例程来做个测试。&lt;/p&gt;
&lt;p&gt;　　这个dcp例程演示了五种DCP工作模式，我们就测试第一种TestAesEcb()，将宏DCP_TEST_USE_OTP_KEY改为1，即使用OTPMK低128bits作为DCP的密钥：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C&quot;&gt;#define DCP_TEST_USE_OTP_KEY 1 /* Set to 1 to select OTP key for AES encryption/decryption. */

int main(void)
{
    dcp_config_t dcpConfig;

    // ...

    /* Initialize DCP */
    DCP_GetDefaultConfig(&amp;amp;dcpConfig);

#if DCP_TEST_USE_OTP_KEY
    /* Set OTP key type in IOMUX registers before initializing DCP. */
    /* Software reset of DCP must be issued after changing the OTP key type. */
    DCP_OTPKeySelect(kDCP_OTPMKKeyLow);
#endif

    /* Reset and initialize DCP */
    DCP_Init(DCP, &amp;amp;dcpConfig);

    /* Call DCP APIs */
    TestAesEcb();

    // ...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　在初始芯片状态（Hab Open）下，使用J-Link下载工程进RAM直接单步调试看一看，在执行完DCP_AES_EncryptEcb()函数后查看cipher[]数组，可以看到其值为0xCF, 0x2E, 0xA3...，好吧我们根本不知道SNVS Master Key到底是多少，所以这个密文是否正确也无从知晓。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/cnblogs/i.MXRT10xx_DCP_aes_ecb_snvs_low_hab_open.PNG&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　既然无法得知SNVS Master Key，那我们做个小实验，使用SRAM-based keys来做一次加密，密钥姑且设个全0吧，再看一下结果，你发现了什么，cipher[]的值是不是很熟悉？跟之前SNVS Master Key加密的结果一致，难道这颗芯片的SNVS Master Key是全0？想想不可能，肯定是流程哪里出了问题！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/cnblogs/i.MXRT10xx_DCP_aes_ecb_key_slot0_0x00s.PNG&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　现在让我们再回忆 MCUBootUtility 用户手册里关于测试HAB加密以及BEE/OTFAD加密使用SNVS Master Key的前提条件，是的，芯片状态需要先设置为Hab Close，好，让我们现在在eFuse里将SEC_CONFIG[1:0]设为2'b10（Hab Close），然后再次使用J-Link调试进去看一看，怎么回事？cipher[]值依旧是0xCF, 0x2E, 0xA3...&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/cnblogs/i.MXRT10xx_DCP_aes_ecb_snvs_low_hab_close_debug.PNG&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　上面的测试对TestAesEcb()函数做了一个简单的修改，将cipher[]值通过串口打印出来，那我们就将程序通过NXP-MCUBootUtility下载到Flash里由ROM来启动运行吧（退出调试状态），我们再来看串口打印，哈哈，终于值变了，这意味着DCP终于拿到了正确的SNVS Master Key(非0)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/cnblogs/i.MXRT10xx_DCP_aes_ecb_snvs_low_hab_close_terminal.PNG&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　总结一下，SNVS Master Key仅在芯片Hab状态是Close并且非调试状态下才能被DCP正常获取，否则DCP获取到的是全0的假Key。&lt;/p&gt;
&lt;p&gt;　　至此，i.MXRT系列中数据协处理器DCP使用SNVS Master Key加解密的注意事项痞子衡便介绍完毕了，掌声在哪里~~~&lt;/p&gt;
&lt;h3 id=&quot;欢迎订阅&quot;&gt;欢迎订阅&lt;/h3&gt;
&lt;p&gt;文章会同时发布到我的 &lt;a href=&quot;https://www.cnblogs.com/henjay724/&quot;&gt;博客园主页&lt;/a&gt;、&lt;a href=&quot;https://blog.csdn.net/henjay724&quot;&gt;CSDN主页&lt;/a&gt;、&lt;a href=&quot;https://www.zhihu.com/people/henjay724&quot;&gt;知乎主页&lt;/a&gt;、&lt;a href=&quot;http://weixin.sogou.com/weixin?type=1&amp;amp;query=%E7%97%9E%E5%AD%90%E8%A1%A1%E5%B5%8C%E5%85%A5%E5%BC%8F&quot;&gt;微信公众号&lt;/a&gt; 平台上。&lt;/p&gt;
&lt;p&gt;微信搜索&quot;&lt;strong&gt;痞子衡嵌入式&lt;/strong&gt;&quot;或者扫描下面二维码，就可以在手机上第一时间看了哦。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/github/pzhMcu_qrcode_258x258.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Fri, 17 Jul 2020 00:38:00 +0000</pubDate>
<dc:creator>痞子衡</dc:creator>
<og:description>i.MXRT不仅仅是处理性能超强的MCU，也是安全等级极高的MCU。如果大家用过痞子衡开发的一站式安全启动工具 NXP-MCUBootUtility，应该会从其用户手册3.3节中了解到i.MXRT支持</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/henjay724/p/13327060.html</dc:identifier>
</item>
<item>
<title>小书MybatisPlus第5篇-Active Record模式精讲 - 字母哥博客</title>
<link>http://www.cnblogs.com/zimug/p/13327061.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zimug/p/13327061.html</guid>
<description>&lt;p&gt;本文为一个系列中的第五节，前四节访问如下地址：&lt;/p&gt;
&lt;p&gt;Active Record 适合非常简单的领域需求，尤其在领域模型和数据库模型十分相似的情况下。如果遇到更加复杂的领域模型结构（例如用到继承、策略的领域模型），往往需要使用分离数据源的领域模型，结合 Data Mapper （数据映射器）使用。&lt;/p&gt;
&lt;p&gt;具体到使用层面，我们之前章节讲过使用Data Mapper 做数据的持久层操作。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;User user = new User();
user.setName(&quot;字母哥&quot;);
user.setAge(18);

userMapper.insert(user);   //Mybatis Mapper模式
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在我们使用ActiveRecord模式，用法如下，注意二者的区别&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;User user = new User();
user.setName(&quot;zimug&quot;);
user.setAge(18);

user.insert();  //ActiveRecord模式
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;一、使activerecord模式生效&quot;&gt;一、使ActiveRecord模式生效&lt;/h2&gt;
&lt;p&gt;首先：需要让数据库表对应的数据持久层实体类。集成自Model，并实现序列化接口。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Data   //lombok注解
@EqualsAndHashCode(callSuper = true)
public class User extends Model&amp;lt;User&amp;gt; implements Serializable {
    private static final long serialVersionUID = 6401942840459021558L;
    private Long id;
    private String name;
    private Integer age;
    private String email;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实定义一个Mapper继承自&lt;code&gt;BaseMapper&amp;lt;T&amp;gt;&lt;/code&gt;，T代表数据持久层实体类。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public interface UserMapper extends BaseMapper&amp;lt;User&amp;gt; {
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样Mybatis Plus的ActiveRecord模式就生效了，默认的帮我们实现了如下的一些数据持久层方法。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202007/1815316-20200717083804032-1614988823.png&quot; alt=&quot;Mybatis Plus的ActiveRecord模式方法&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;二、增删该查的实现&quot;&gt;二、增删该查的实现&lt;/h2&gt;
&lt;p&gt;增加：向持久层实体类User对应的数据库表user，插入一条数据。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Test
public void testInsert() {
  User user = new User();
  user.setName(&quot;zimug&quot;);
  user.setAge(18);
  user.setEmail(&quot;hadoopcn2@163.com&quot;);

  boolean success = user.insert();
  System.out.println(&quot;是否插入成功：&quot;+success);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查询：从数据库表user查询所有数据&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
@Test
public void testSelect() {
  User user = new User();
  List&amp;lt;User&amp;gt; users = user.selectAll();
  users.forEach(System.out::println);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;添加或更新：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;未设置ID，被视为insert操作，向数据库插入数据&lt;/li&gt;
&lt;li&gt;如果设置ID，则先查询是否有此id的记录，如果有此id记录，则视为update,如果没有则视为insert&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;@Test
public void testUpdate() {
  User user = new User();
  user.setId(1283915378849751041L);
  user.setAge(25);

  boolean success = user.insertOrUpdate();
  System.out.println(&quot;是否添加或更新成功（更新）：&quot;+success);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据id在数据库表user中删除一条记录&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Test
public void testDelete() {
  User user = new User();
  user.setId(1283915378849751041L);

  boolean success = user.deleteById();
  System.out.println(&quot;是否删除成功：&quot;+success);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;欢迎关注我的博客，里面有很多精品合集&quot;&gt;欢迎关注我的博客，里面有很多精品合集&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;本文转载注明出处（必须带连接，不能只转文字）：&lt;a href=&quot;http://www.zimug.com&quot;&gt;字母哥博客&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;觉得对您有帮助的话，帮我点赞、分享！您的支持是我不竭的创作动力！&lt;/strong&gt; 。另外，笔者最近一段时间输出了如下的精品内容，期待您的关注。&lt;/p&gt;
</description>
<pubDate>Fri, 17 Jul 2020 00:38:00 +0000</pubDate>
<dc:creator>字母哥博客</dc:creator>
<og:description>本文为一个系列中的第五节，前四节访问如下地址： 小书MybatisPlus第1篇-整合SpringBoot快速开始增删改查 小书MybatisPlus第2篇-条件构造器的应用及总结 小书Mybatis</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zimug/p/13327061.html</dc:identifier>
</item>
<item>
<title>Python3 生成器解析 - 测试工匠麻辣烫</title>
<link>http://www.cnblogs.com/infuture/p/13305773.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/infuture/p/13305773.html</guid>
<description>&lt;ul&gt;&lt;li&gt;6.1 函数的定义和调用&lt;/li&gt;
&lt;li&gt;6.2 参数传递&lt;/li&gt;
&lt;li&gt;6.3 函数返回值&lt;/li&gt;
&lt;li&gt;6.4 变量作用域&lt;/li&gt;
&lt;li&gt;6.5 匿名函数(lambda)&lt;/li&gt;
&lt;li&gt;6.6 递归函数&lt;/li&gt;
&lt;li&gt;6.7 迭代器&lt;/li&gt;
&lt;li&gt;6.8 生成器&lt;/li&gt;
&lt;li&gt;6.9 装饰器&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;68-生成器&quot;&gt;6.8 生成器&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;看看廖雪峰大神的解释：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。&lt;br/&gt;而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。&lt;br/&gt;所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？&lt;br/&gt;这样就不必创建完整的list，从而节省大量的空间。&lt;/p&gt;
&lt;p&gt;在Python中，这种一边循环一边计算的机制，称为&lt;strong&gt;生成器（Generator）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;生成器generator&lt;/strong&gt;，&lt;strong&gt;也是一种迭代器&lt;/strong&gt;，但是你只能对其迭代一次。这是因为它们并没有把所有的值存在内存中，而是&lt;strong&gt;在运行时生成值&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;生成器generator对象是一种特殊的迭代器iterator函数，它会在执行过程中保存执行的上下文环境，并在下次循环中从yield语句后继续执行，生成器的标志就是&lt;strong&gt;yield&lt;/strong&gt;关键字。&lt;/p&gt;
&lt;p&gt;generator不需要抛出StopIteration异常（你可以看做yield已经在内部实现了StopIteration跳出循环），函数并没有将序列项一次生成，所以generator在实现上可以有无穷个元素，而不需要无穷的存储空间，这在内存优化方面很有用处。&lt;/p&gt;
&lt;p&gt;使用isinstance(实体名,Generator)可判断是否为生成器。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 验证下一个列表是否为可迭代对象Iterable、迭代器Iterator、生成器Generator
from collections.abc import Iterator, Iterable, Generator
province = ['Guangdong', 'HuNan', 'JiangSu', 'HeNan', 'HeBei']
print(isinstance(province, Iterator), isinstance(province, Iterable), isinstance(province, Generator))
output:
False True False
# 从结果来看，一个列表是可迭代对象但不是迭代器，也不是生成器
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你通过遍历来使用它们，要么用一个&lt;em&gt;for&lt;/em&gt;循环，要么将它们传递给任意可以进行迭代的函数和结构。&lt;strong&gt;大多数时候生成器是以函数来实现的&lt;/strong&gt;。然而，它们并不返回一个值，而是&lt;em&gt;yield&lt;/em&gt;(暂且译作“生出”)一个值。&lt;/p&gt;
&lt;p&gt;生成器的创建办法有两种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通过函数创建，称作生成器函数generator function&lt;/li&gt;
&lt;li&gt;通过推导式创建，例如g=(x*2 for x in range(10))，称作生成器表达式generator expression&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;每次对生成器调用 &lt;em&gt;next()&lt;/em&gt; 时，它会从上次离开位置恢复执行（它会记住上次执行语句时的所有数据值）。显示如何非常容易地创建生成器的示例如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;def reverse(data):
    for index in range(len(data)-1, -1, -1):
        yield data[index]

&amp;gt;&amp;gt;&amp;gt; for char in reverse('golf'):
...     print(char)
...
f
l
o
g
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以用生成器来完成的操作同样可以用前一节所描述的基于类的迭代器来完成。但生成器的写法更为紧凑，因为它会自动创建 &lt;em&gt;&lt;strong&gt;iter&lt;/strong&gt;()&lt;/em&gt; 和 &lt;em&gt;&lt;strong&gt;next&lt;/strong&gt;()&lt;/em&gt;方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;生成器表达式generator expression&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;生成器不一定要用复杂的函数表示，python提供了简洁的生成器表达式。&lt;/p&gt;
&lt;p&gt;从形式上来看，生成器表达式和列表推导式很像，仅仅是将列表推导式中的[]替换为()，但是两者差别挺大，生成器表达式可以说组合了迭代功能和列表解析功能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;生成器表达式可以认为是一种特殊的生成器函数&lt;/strong&gt;，类似于lambda表达式和普通函数。但是和生成器一样，生成器表达式也是返回生成器generator对象，&lt;strong&gt;一次只返回一个值&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 生成器表达式
g = (x*2 for x in range(4))
print(type(g))
print(next(g))
print(next(g))
print(next(g))
print(next(g))

f = (i*i for i in range(10))
print(type(f))
print(next(f))
print(next(f))
print(next(f))
print(next(f))
output:
&amp;lt;class 'generator'&amp;gt;
0
2
4
6
&amp;lt;class 'generator'&amp;gt;
0
1
4
9
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 17 Jul 2020 00:19:00 +0000</pubDate>
<dc:creator>测试工匠麻辣烫</dc:creator>
<og:description>第6章 函数 6.1 函数的定义和调用 6.2 参数传递 6.3 函数返回值 6.4 变量作用域 6.5 匿名函数(lambda) 6.6 递归函数 6.7 迭代器 6.8 生成器 6.9 装饰器 6</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/infuture/p/13305773.html</dc:identifier>
</item>
<item>
<title>为什么编译原理被称为龙书？ - 程序员cxuan</title>
<link>http://www.cnblogs.com/cxuanBlog/p/13327003.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cxuanBlog/p/13327003.html</guid>
<description>&lt;h2 id=&quot;碎碎念&quot;&gt;碎碎念&lt;/h2&gt;
&lt;p&gt;为什么这本书叫做 &lt;code&gt;龙书(Dragon book)&lt;/code&gt;？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202007/1515111-20200717073420941-475695105.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这本书很有意思，它的书名是 &lt;code&gt;《Compilers: Principles, Techniques, and Tools》&lt;/code&gt;，也就是&lt;strong&gt;编译器的原则、技术和工具&lt;/strong&gt;。但它却画出了一个恐龙和骑士，恐龙身上写的是 &lt;code&gt;Complexity of Compiler Design&lt;/code&gt;，也就是&lt;code&gt;复杂的编译器设计&lt;/code&gt;，骑士的盾上写的是 &lt;code&gt;Syntax Directed Granslation&lt;/code&gt;，也就是语法翻译。骑士的剑上看的不是很清楚，我猜测应该是优秀的编译器的意思。这是征服复杂性的隐喻。优秀的编译器会直接征服复杂的编译，复杂的编译设计永远无法攻破语法翻译。&lt;/p&gt;
&lt;h2 id=&quot;什么是编译原理&quot;&gt;什么是编译原理&lt;/h2&gt;
&lt;p&gt;计算机是只认识二进制的，但是我们平常开发中根本不会使用二进制进行开发，我们使用的都是 Java、C 这类的高级语言，每种语言都会经过一系列的转换才能被计算机识别，那么到底是谁做的这项工作呢？一个被称为 &lt;code&gt;编译器(compiler)&lt;/code&gt; 的大佬出场了。&lt;/p&gt;
&lt;h3 id=&quot;语言处理器&quot;&gt;语言处理器&lt;/h3&gt;
&lt;p&gt;首先考虑一下一个例子，你如何才能和老外对话？你是不是需要学英语？我们有一些同学可能认为英语难学，经常会在英语书上做一些汉语标记方便理解。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202007/1515111-20200717073458208-2066045228.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么，谁做了由英语到&lt;code&gt;方便记忆&lt;/code&gt; 的英语之间的转换呢？答案是你的大脑。所以，我们可以归纳一下这个过程。&lt;/p&gt;
&lt;p&gt;因为我们懂汉语（自己的一套语法规则），我们把英语（需要学习的语言）转换为我们便于理解的汉语（大脑翻译规则），我们才能学会英语和老外对话（转换为目标语言）。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;这里我说一点：昨天晚上外出遛狗有个老黑和中国女生对话，中国女生竟然讲英文？？？？？？这可是中国本土好么，为什么外国人来到中国不讲汉语偏要中国人讲英文？？？你去外国旅游你会讲中文吗？？？这是一个基本认知问题，别怪我偏执。我认为外国人要来我们国家最基本的一点就是：你要学中文。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;回到正题，我们上面举出的这个学英语的例子，其实就是一个由原程序经过某种机制转换，把它变成目标语言的过程。也就是&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202007/1515111-20200717073505050-1293307943.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;编译器就是一个翻译官的角色，它负责把源程序的语法翻译成目标程序能够理解的语法。&lt;/p&gt;
&lt;p&gt;回到计算机中，我们肯定需要目标程序来做一些事情的。&lt;/p&gt;
&lt;p&gt;也就是，我们通过某个渠道获得的输入信息，会经过编译器的转换，变为输出信息进行展示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202007/1515111-20200717073511981-1259256629.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;除了编译器之外，还有一种称为 &lt;code&gt;解释器(interpreter)&lt;/code&gt; 的语言处理器，它不是做翻译工作的，而是把用户提供的输入执行源程序中指定的操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202007/1515111-20200717073518381-1783822687.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们熟知的 Java 语言，就结合了编译和解释的过程，我们写的 Java 源文件首先被编译成 &lt;code&gt;字节码(bytecode)&lt;/code&gt;，字节码是一种中间码，它通常被看成是可执行的二进制文件。然后再由 Java 虚拟机对字节码解释执行。这样，在一台机器上编译的字节码就能够在其他机器上解释执行，这种体现了 Java 语言的&lt;code&gt;平台无关性&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202007/1515111-20200717073525834-626649249.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了提高编译速度，Java 中有一种 &lt;code&gt;just-in-time,JIT&lt;/code&gt; 即时编译器会一边编译一边执行。&lt;/p&gt;
&lt;p&gt;一个源文件程序可能被划分为多个模块，并存放在多个文件中，还需要把文件链接在一起，所以，除了编译器之外，还需要一种能链接文件的部件参与，&lt;code&gt;预处理器(preprossor)&lt;/code&gt; 是做这件事情的。如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202007/1515111-20200717073534277-301263997.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;预处理器经过预处理后会作为输入传递给编译器，编译器对源程序进行编译，编译完成后生成汇编代码，作为汇编器的输入传递给汇编器，汇编器进行汇编处理转换为机器代码，注意这个时候还不是目标代码，还要经过链接器与系统库函数进行链接，最后由加载器把目标代码加载到内存中执行&lt;/p&gt;
&lt;h3 id=&quot;编译器的结构&quot;&gt;编译器的结构&lt;/h3&gt;
&lt;p&gt;我们上面大概了解了一下语言的处理过程，下面我们就来了解一下编译器的内部结构，编译器内部其实具有两种结构：&lt;code&gt;分析(analysis)&lt;/code&gt;部分和 &lt;code&gt;整合(synthesis)&lt;/code&gt; 部分。&lt;/p&gt;
&lt;p&gt;分析过程相当于是把源程序分成多个结构，每个结构都有特定的语法格式进行校验，在经由每个校验后，如果不满足指定的语法格式则进行提醒，使用户进行修改。分析部分还会收集有关源程序的信息，会把收集到的信息存放在一个被称为 &lt;code&gt;符号表(symbol table)&lt;/code&gt; 的数据结构中。符号表和中间表示形式一起传给&lt;code&gt;整合&lt;/code&gt;部分。&lt;/p&gt;
&lt;p&gt;整合过程是根据分析过程传递的信息来构造用户期待的目标程序。分析和整合统称为 &lt;code&gt;前端(front end)&lt;/code&gt; 和 &lt;code&gt;后端(back end)&lt;/code&gt; ，哈哈哈哈。&lt;/p&gt;
&lt;p&gt;这里你需要知道&lt;code&gt;符号表(Symbol Table)&lt;/code&gt; 的概念：符号表是编译器使用和维护的数据结构，由标识符和类型组成。符号表的主要作用是帮助编译器快速定位。&lt;/p&gt;
&lt;p&gt;下面是一个编译器的典型结构&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202007/1515111-20200717073545354-2076563027.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面我们就针对编译器结构的每一层进行描述和讨论&lt;/p&gt;
&lt;h3 id=&quot;词法分析&quot;&gt;词法分析&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;词法分析(Lexical Analyzer)&lt;/code&gt;是编译器的第一个步骤，它也被称为 &lt;code&gt;扫描(scanning)&lt;/code&gt;。词法分析器通过读入外部的字符流对其进行扫描，并且把它们组成有意义的&lt;code&gt;词素(lexeme)&lt;/code&gt;序列，对于每个词素，词法分析器都会产生&lt;code&gt;词法单元(token)&lt;/code&gt; 作为输出。这个词法单元会传递给下一个步骤，也就是语法分析。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这里需要解释一下 Token 、词素和词法分析器的概念&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们常用的编程语言就是具有词素的单词和符号的集合，比如 C 语言中有 ()，-&amp;gt; 等等。关键字 if...while...，变量或函数名称以及数字和字符串常量也被视为词素。并不是所有的自负都属于词素，例如空格和注释就不属于。&lt;/p&gt;
&lt;p&gt;词法分析器用来分析词素有两个规则&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;跳过不能以字母开头的字符&lt;/li&gt;
&lt;li&gt;然后找到剩余的最长前缀，也就是词素&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这两句话比较抽象，举个例子来说明一下&lt;/p&gt;
&lt;p&gt;比如 C 语言中有这么一个语句&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;ifx = 20*30;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么第一个词素就是 ifx，为什么不是 if 呢？因为 if 不是最长的前缀。然后后面的词素依次是 =，20，*，30和；。&lt;/p&gt;
&lt;p&gt;词素、词法分析器、token 的关系如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202007/1515111-20200717073555036-1833922374.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;词素是 Token 的实例，词法分析器的主要任务就是从源程序中读取字符并产生 token。token 也是有结构的，一般结构如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202007/1515111-20200717073601913-1075704121.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在词法分析生成的 &lt;code&gt;token&lt;/code&gt; 中，第一个词 token-name 是语法分析期间使用的抽象符号，第二个词 attribute-value 指向的是符号表中关于这个词法单元的条目数。&lt;/p&gt;
&lt;p&gt;我们举个例子来看一下词法分析的拆解过程。&lt;/p&gt;
&lt;p&gt;比如现在源程序中有一个赋值语句&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;income = mainjob + sideline // 收入 = 主业 + 副业
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个赋值语句中的字符可以组合成如下词素，并转换成为 token，并传递给语法分析阶段。&lt;/p&gt;
&lt;ul readability=&quot;5.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;首先，income 是一个词素，它会被映射为 &amp;lt;id,1&amp;gt;，其中 id 是表示的 &lt;code&gt;标识符(identifier)&lt;/code&gt; 的抽象符号，而 1 指的是符号表中 income 在符号表中的条数。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;然后是赋值符号 = ，它也是一个词素，被映射称为 token 中的 &amp;lt; = &amp;gt;。这个 token 不需要属性值，所以没有第二个词。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;mainjob 是一个词素，它被映射成为 token 中的 &amp;lt;id,2&amp;gt;，2 是 mainjob 对应的符号表条目&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;+也是一个词素，它被映射称为 &amp;lt; + &amp;gt;，没有条目数&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;sideline 是一个词素，它被映射称为 token 中的 &amp;lt;id,3&amp;gt;，3 是 sideline 对应的符号表条目&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以，经过词法分析后，上面的源程序会变为&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;&amp;lt;id,1&amp;gt; &amp;lt; = &amp;gt; &amp;lt;id,2&amp;gt; &amp;lt; + &amp;gt; &amp;lt;id,3&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上面的表达式中， = 和 + 分别表示赋值和加法运算符的抽象符号。用图来表示的话就是&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202007/1515111-20200717073611288-1657823479.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;语法分析&quot;&gt;语法分析&lt;/h3&gt;
&lt;p&gt;编译器的第二个步骤是 &lt;code&gt;语法分析(syntax analysis)&lt;/code&gt; 或者称为 &lt;code&gt;解析(parsing)&lt;/code&gt;。语法分析器使用由词法分析器生成的各个词法单元的第一个分量来创建树形的中间表示。常用的方法就是 &lt;code&gt;语法树(syntax tree)&lt;/code&gt;。编译器的后续步骤都会使用这个语法结构来帮助分析源程序，并声称目标程序。&lt;/p&gt;
&lt;h3 id=&quot;语义分析&quot;&gt;语义分析&lt;/h3&gt;
&lt;p&gt;语义分析是由 &lt;code&gt;语义分析器(semantic analyzer)&lt;/code&gt; 完成的，它使用语法树和符号表中的信息来检查源程序是否和语言定义的语义一致。语义分析器也收集类型信息，并把这些信息放在语法树或者符号表中，以便后续的中间代码生成器使用。&lt;/p&gt;
&lt;p&gt;语义分析会进行&lt;code&gt;类型检查(type checking)&lt;/code&gt;，这是语义分析器的一个最重要的功能。编译器会检查每个运算符是否具有匹配的运算分量。举个例子比如设计语言要求一个数组的下标是整数，如果你用浮点数座位下标，编译器就会出错。&lt;/p&gt;
&lt;p&gt;某些程序设计语言比如 Java 会允许&lt;code&gt;自动类型转换(coercion)&lt;/code&gt;。如果整数和浮点数进行运算，编译器会把整数转换为浮点数。&lt;/p&gt;
&lt;h3 id=&quot;中间代码生成&quot;&gt;中间代码生成&lt;/h3&gt;
&lt;p&gt;在源程序的语法分析和语义分析完成后，很多编译器生成一个明确的低级类机器语言的中间表示。我们可以把中间表示形式看作是抽象，中间形式的代码应该具有两个重要的性质：易于生成，并且能够轻松的被翻译。一般常用的一种是 &lt;code&gt;三地址指令(three-address instructions)&lt;/code&gt;的中间表示形式。我们后面会细说。&lt;/p&gt;
&lt;h3 id=&quot;代码优化&quot;&gt;代码优化&lt;/h3&gt;
&lt;p&gt;代码优化会试图改进代码以便生成更好的目标代码。&lt;code&gt;更好&lt;/code&gt;通常情况下意味着更快，但是也可能会有其他目标，比如更短或能耗更低的目标代码。&lt;/p&gt;
&lt;h3 id=&quot;代码生成&quot;&gt;代码生成&lt;/h3&gt;
&lt;p&gt;代码生成通过中间代码作为输入，并把它映射为目标语言。如果目标语言是机器代码的话，那么必须要为每个变量分配寄存器或内存位置。解释一下上面的运行结果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202007/1515111-20200717073619946-1362700435.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每个指令的第一个运算分量指定了一个目标地址，各个指令中的 F 告诉我们它处理的是 &lt;code&gt;浮点数&lt;/code&gt;, 上面代码首先把 id3 装载进 R2 寄存器中，然后把 id2 装载进 R1 寄存器中，再对 R1 目标进行 R1 和 R2 寄存器相加的操作。最后把寄存器 R1 的值存放到 id1 的地址中。&lt;/p&gt;
&lt;h3 id=&quot;符号表管理&quot;&gt;符号表管理&lt;/h3&gt;
&lt;p&gt;我们上面提到了符号表的概念，它是一个编译器很重要的功能。符号表能够记录源程序中使用变量的名称，并收集和每个名称相关的属性信息。它相当于一个秘书的作用。符号表还记录了每个变量名字的条目。后面我们会详细的介绍符号表。&lt;/p&gt;
&lt;h3 id=&quot;编译器构造工具&quot;&gt;编译器构造工具&lt;/h3&gt;
&lt;p&gt;和软件开发一样，写编译器的人可以充分利用现代的软件开发环境进行开发。通常也有 &lt;strong&gt;语言编辑器、调试工具、版本管理、测试工具&lt;/strong&gt;等。除此之外，还需要一些更专业的工具来实现编辑器不同阶段的代码生成。&lt;/p&gt;
&lt;p&gt;一些常用的编译器构造工具有&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;语法分析器生成器：可以根据程序设计语言的语法描述自动生成语法分析器&lt;/li&gt;
&lt;li&gt;扫描器生成器：可以根据一个语言的语法单元的正则描述生成词法分析器&lt;/li&gt;
&lt;li&gt;语法制导的翻译引擎：用于生成一组遍历分析树并声称中间代码&lt;/li&gt;
&lt;li&gt;代码生成器：用于把中间代码转换为目标代码&lt;/li&gt;
&lt;li&gt;数据流分析引擎：用于分析输入是如何传递到另一部分的&lt;/li&gt;
&lt;li&gt;编译器构造工具：提供用于构造编译器不同阶段的例程&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;程序设计语言的发展历程&quot;&gt;程序设计语言的发展历程&lt;/h2&gt;
&lt;p&gt;计算机从 20 世纪 40 年代创建至今都只能理解二进制语言，亘古不变。这个 0 、 1 组成的序列能够告诉计算机以什么样的顺序执行怎样的运算。运算本身是很底层的：比如把一个数据从一个位置进行移动；把两个寄存器的内容进行相加、比较两个值，为了避免如此枯燥的运算，我们开发了各种各样的编程语言，但是计算机底层的计算方式一直没变，所以学习哪个技术性价比高，明白了吗？下面我们就来一起认识一下程序设计语言的历程。&lt;/p&gt;
&lt;h3 id=&quot;高级设计语言&quot;&gt;高级设计语言&lt;/h3&gt;
&lt;p&gt;首先被开发出来的是 20 世纪 50 年代的&lt;code&gt;汇编语言&lt;/code&gt;，5 年后发生了重要的进步，用于科学计算的 &lt;code&gt;Fortran&lt;/code&gt; 被开发出来，用于商业处理的 &lt;code&gt;Cobol&lt;/code&gt; 语言和用于符号计算的 &lt;code&gt;Lisp&lt;/code&gt; 语言被开发出来；然后接下来的时间，慢慢很多编程语言被开发出来，比如 C、C++、Java、JavaScript、Python 等。后面还有用于数据处理的 SQL 语言。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202007/1515111-20200717073627292-659327584.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;语言分类&quot;&gt;语言分类&lt;/h3&gt;
&lt;p&gt;说到给这些编程语言分类，那可是有太多了，不过我们专注一下高频的分类。&lt;/p&gt;
&lt;p&gt;如何完成计算任务的语言称为 &lt;code&gt;强制式(imperative)&lt;/code&gt;语言，而把程序中指明要进行哪些计算的语言称为 &lt;code&gt;声明式(declarative)&lt;/code&gt;语言。 C、C++、Java 这些都是强制式语言，它们能够改变程序的状态；声明式比如 HTML Prolog 等。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;冯·诺伊曼&lt;/code&gt; 语言指的是以冯·诺伊曼计算机体系为基础的编程语言，今天很多编程语言都是冯·诺伊曼语言&lt;/p&gt;
&lt;p&gt;&lt;code&gt;面向对象语言(object-oriented language)&lt;/code&gt; 是一种描述对象的语言，比如 C、C++、Java&lt;/p&gt;
&lt;p&gt;&lt;code&gt;脚本语言(scripting language)&lt;/code&gt; 是具有高层次的解释型语言，它通常把多个过程&lt;code&gt;粘&lt;/code&gt;在一起，比如 JavaScript、Perl、PHP、Python 等。&lt;/p&gt;
&lt;h2 id=&quot;程序设计语言基础&quot;&gt;程序设计语言基础&lt;/h2&gt;
&lt;p&gt;下面我们主要探讨程序设计语言的研究中最重要的术语和它们的区别，假设读者已经了解过 C、C++、C#、Java 中任意一种语言。&lt;/p&gt;
&lt;h3 id=&quot;静态和动态的区别&quot;&gt;静态和动态的区别&lt;/h3&gt;
&lt;p&gt;编译器需要能够对程序作出判定，如果语言能够让编译器静态（非运行）时候决定某个问题，那么我们说这个语言使用了一种 &lt;code&gt;静态(static)&lt;/code&gt; 策略，或者说能够在 &lt;code&gt;编译时刻(compile time)&lt;/code&gt; 决定。如果让编译器在运行时决定某个策略，那么就是&lt;code&gt;动态策略(dynamic policy)&lt;/code&gt;，或者被认为是 &lt;code&gt;运行时决定(run time)&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;还有一个问题是声明的&lt;code&gt;作用域(scope)&lt;/code&gt;，如果能够通过阅读程序就能确定一个声明的作用域，那么这个语言就是&lt;code&gt;静态作用域(static scope)&lt;/code&gt;，或者说是 &lt;code&gt;词法作用域(lexical scope)&lt;/code&gt;。否则这个语言使用的是 &lt;code&gt;动态作用域(dynamic scope)&lt;/code&gt;。动态作用域的指向对象是几个声明中的一个，并不惟一。&lt;/p&gt;
&lt;p&gt;C 和 Java 都使用了静态作用域，比如 Java 中的 &lt;code&gt;static&lt;/code&gt; 关键字，下面是一段代码示例&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static int x;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码在创建完成后就能够确定它的作用域，因为 static 声明的变量是类变量，类变量的实例能确保只有一个个（不太清楚的小伙伴可以参考我的这篇文章 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI0ODk2NDIyMQ==&amp;amp;mid=2247484206&amp;amp;idx=1&amp;amp;sn=9cd72aa73376e16edcb4a6e6c0cae267&amp;amp;chksm=e999f63cdeee7f2a0dfe565554395be9a2de2a77c6beb4f85a80aea5bd54b9bd6d47fe319ba3&amp;amp;token=448212407&amp;amp;lang=zh_CN#rd&quot;&gt;都说变量有七八种，到底谁是 Java 的亲儿子&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;如果你去掉了 static ，那么这个变量的作用域和在内存中的分配就无法确定，编译器无法在运行之前确定所有这些位置。&lt;/p&gt;
&lt;h3 id=&quot;静态绑定和动态绑定&quot;&gt;静态绑定和动态绑定&lt;/h3&gt;
&lt;p&gt;同样的，名字到位置也区分静态绑定和动态绑定，如果能在非运行条件下唯一确定名字到位置，那么就是静态绑定，如果要在程序运行时才能确定名字和位置的绑定，那么就是动态绑定。&lt;/p&gt;
&lt;h3 id=&quot;静态作用域和块结构&quot;&gt;静态作用域和块结构&lt;/h3&gt;
&lt;p&gt;大多数编程语言都提供了作用域这么一个结构，比如 Java 中的 &lt;code&gt;private,protected,public&lt;/code&gt; 等关键字的使用，提供了有效的作用域控制。&lt;/p&gt;
&lt;p&gt;块结构也是一种作用域，使用块结构表示的含义是在&lt;code&gt;块内部(block)&lt;/code&gt; 作用范围有效，块使用 &lt;code&gt;{}&lt;/code&gt; 来界定一个块。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;这种语法允许在任意函数或者方法的内部嵌入一个块，这种嵌套结构也被称为 &lt;code&gt;块结构(block structure)&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;参数传递机制&quot;&gt;参数传递机制&lt;/h3&gt;
&lt;p&gt;参数传递机制主要描述的是形式参数和实际参数的关联。大多数编程语言都支持两种调用：&lt;code&gt;值传递&lt;/code&gt;和 &lt;code&gt;引用传递&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;值传递&quot;&gt;值传递&lt;/h4&gt;
&lt;p&gt;在&lt;code&gt;值传递(call-by-value)&lt;/code&gt; 中，会对实参求值或拷贝，这些值被放在属于被调用的形式参数的内存位置上，这种调用方式在 C 和 Java 中都会使用，值调用的结果是，实参本身不会改变。但是在 C 中，我们可以传递一个指针，使得变量的值能够被修改。&lt;/p&gt;
&lt;h4 id=&quot;引用传递&quot;&gt;引用传递&lt;/h4&gt;
&lt;p&gt;在 &lt;code&gt;引用传递(call-by-reference)&lt;/code&gt; 中，实际参数的地址作为相应的形式参数的值被传递给调用者。在被调用者的代码中使用形式参数，实现方法是沿着这个指针找到调用者指明的内存位置。因此，改变实际参数相当于改变了形式参数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202007/1515111-20200717073716955-1811727313.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 16 Jul 2020 23:37:00 +0000</pubDate>
<dc:creator>程序员cxuan</dc:creator>
<og:description>碎碎念 为什么这本书叫做 龙书(Dragon book)？ 这本书很有意思，它的书名是 《Compilers: Principles, Techniques, and Tools》，也就是编译器的原则</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cxuanBlog/p/13327003.html</dc:identifier>
</item>
<item>
<title>Harbor打怪升级 - Captain_Li</title>
<link>http://www.cnblogs.com/lemon-le/p/13326846.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lemon-le/p/13326846.html</guid>
<description>&lt;p&gt;&lt;span&gt;一、目标&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;二、V1.4升级至V1.6&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;三、V1.6升级至V1.9&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;四、V1.9升级至V2.0&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;五、写在最后&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Harbor V1.4版本升级至V2.0&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/746846/202007/746846-20200716233315097-1090479742.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;&lt;span&gt;注：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Harbor升级需要注意的是，不是一口吃成胖子，需要迭代升级（如图），不能直接从V1.4升级到V2.0，需要先从V1.4--V1.6--V1.9--V2.0；这里涉及到大版本与小版本；&lt;/p&gt;
&lt;p&gt;大版本升级：大版本升级涉及到数据库结构之类的改变，需要迭代升级&lt;/p&gt;
&lt;p&gt;小版本升级：只需下载对应的版本，把旧版本的配置文件转换成新版本的格式，再启动即可&lt;/p&gt;


&lt;p&gt;1、V1.4到V1.6版本，最大的改变就是数据库从Mariadb到postgrepsql；&lt;/p&gt;
&lt;p&gt;2、大版本有数据库结构改变的，需要升级数据库；没有数据库升级的，只需转换配置文件；&lt;/p&gt;
&lt;p&gt;3、备份、备份、备份&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;步骤：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1）停止容器&lt;/p&gt;
&lt;div readability=&quot;37.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
docker-compose down -v
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2）备份&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;mkdir&lt;/span&gt; /&lt;span&gt;backup_bak    # 创建备份目录
&lt;/span&gt;&lt;span&gt;cp&lt;/span&gt; -r harbor /backup_bak/harbor_v1.&lt;span&gt;4&lt;/span&gt;&lt;span&gt;   # 备份配置文件目录
&lt;/span&gt;&lt;span&gt;cp&lt;/span&gt; -r /data/database /harbor_bak/database1.&lt;span&gt;4&lt;/span&gt;  # 备份数据库文件
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;3）另一种数据库备份&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
docker run -it --&lt;span&gt;rm&lt;/span&gt; -e DB_USR=user -e DB_PWD=password -v /data/database/:/var/lib/mysql -v /harbor_bak/harbor1.&lt;span&gt;4&lt;/span&gt;/harbor.cfg:/harbor-migration/harbor-cfg/harbor.cfg -v /harbor_bak/&lt;span&gt;1&lt;/span&gt;.4_bak:/harbor-migration/backup goharbor/harbor-db-migrator:&lt;span&gt;1.4&lt;/span&gt; backup
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;DB_USER：数据库登录名（可从配置文件里获取）&lt;/p&gt;
&lt;p&gt;DB_PWD：数据库密码（可从配置文件里获取）&lt;/p&gt;
&lt;p&gt;第一个-v：&lt;span&gt;/data/database/&lt;/span&gt;:/var/lib/mysql 前面为数据库文件，具体根据自己的配置文件里设置的数据目录下，后面不变；&lt;/p&gt;
&lt;p&gt;第二个-v：&lt;span&gt;/harbor_bak/harbor1.4/harbor.cfg&lt;/span&gt;:/harbor-migration/harbor-cfg/harbor.cfg 前面为harbor1.4的配置文件，后面不变；&lt;/p&gt;
&lt;p&gt;第三个-v：&lt;span&gt;/harbor_bak/1.4_bak&lt;/span&gt;:/harbor-migration/backup 前面为备份到的哪个目录，后面不变；&lt;/p&gt;

&lt;p&gt;4）升级数据库&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
docker run -it --&lt;span&gt;rm&lt;/span&gt; -e DB_USR=user -e DB_PWD=password -v /data/database/:/var/lib/mysql -v /harbor_bak/harbor1.&lt;span&gt;4&lt;/span&gt;/harbor.cfg:/harbor-migration/harbor-cfg/harbor.cfg -v /harbor_bak/&lt;span&gt;1&lt;/span&gt;.6_database:/harbor-migration/backup goharbor/harbor-migrator:v1.&lt;span&gt;6.0&lt;/span&gt; up
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;DB_USER：数据库登录名（可从配置文件里获取）&lt;/p&gt;
&lt;p&gt;DB_PWD：数据库密码（可从配置文件里获取）&lt;/p&gt;
&lt;p&gt;第一个-v：&lt;span&gt;/data/database/&lt;/span&gt;:/var/lib/mysql 前面为1.4版本的数据库文件，后面不变；&lt;/p&gt;
&lt;p&gt;第二个-v：&lt;span&gt;/harbor_bak/harbor1.4/harbor.cfg&lt;/span&gt;:/harbor-migration/harbor-cfg/harbor.cfg 前面为1.4版本的配置文件，后面不变；&lt;/p&gt;
&lt;p&gt;第三个-v：&lt;span&gt;/harbor_bak/1.6_database&lt;/span&gt;:/harbor-migration/backup 前面为升级后的数据库文件，后面不变；&lt;/p&gt;

5）配置文件转换&lt;/div&gt;
&lt;div readability=&quot;44&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
 docker run -it --&lt;span&gt;rm&lt;/span&gt; -v /harbor_bak/harbor_1.&lt;span&gt;4&lt;/span&gt;/harbor.cfg:/harbor-migration/harbor-cfg/harbor.cfg -v harbor/harbor.cfg:/harbor-migration/harbor-cfg-out/harbor.cfg goharbor/harbor-migrator:v1.&lt;span&gt;6.0&lt;/span&gt; --cfg up
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第一个-v：&lt;span&gt;/harbor_bak/harbor_1.4/harbor.cfg&lt;/span&gt;:/harbor-migration/harbor-cfg/harbor.cfg 现有1.4版本的配置文件，后面不变；&lt;/p&gt;
第二个-v：&lt;span&gt;harbor/harbor.cfg&lt;/span&gt;:/harbor-migration/harbor-cfg-out/harbor.cfg 前面为转换后的1.6版本的配置文件，后面不变；
&lt;p&gt;&lt;strong&gt;&lt;span&gt;注：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将1.4版本的配置文件转换成1.6版本，新的配置文件将会输出至harbor/harbor.cfg，注意检查里面的配置文件，密码是否对应的转换过来了，没有的话，需手动改。&lt;/p&gt;


&lt;p&gt;V1.6升级V1.9比较大的变化是配置文件由cfg形式变成yml文件，整体上只需转换配置文件即可；步骤如下&lt;/p&gt;

&lt;p&gt;1）停止容器&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
docker-compose down -v
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2）备份&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;cp&lt;/span&gt; -r harbor /backup_bak/harbor_v1.&lt;span&gt;6&lt;/span&gt;&lt;span&gt;   # 备份配置文件目录
&lt;/span&gt;&lt;span&gt;cp&lt;/span&gt; -r /data/database /harbor_bak/database1.&lt;span&gt;6&lt;/span&gt;  # 备份数据库文件
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;3）V1.6版本的配置文件转换成V1.9版本的配置文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
docker run -it --&lt;span&gt;rm&lt;/span&gt; -v /harbor_bak/harbor_1.&lt;span&gt;6&lt;/span&gt;/harbor.cfg:/harbor-migration/harbor-cfg/harbor.cfg -v /harbor.yml:/harbor-migration/harbor-cfg-out/harbor.yml goharbor/harbor-migrator:v1.&lt;span&gt;9.3&lt;/span&gt; --cfg up
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第一个-v：&lt;span&gt;/harbor_bak/harbor_1.6/harbor.cfg&lt;/span&gt;:/harbor-migration/harbor-cfg/harbor.cfg 前面为harbor1.6版本的harbor.cfg配置文件，后面为固定的&lt;/p&gt;
&lt;p&gt;第二个-v：&lt;span&gt;/harbor.yml&lt;/span&gt;:/harbor-migration/harbor-cfg-out/harbor.yml 前面为将被转换成1.9版本配置文件的目录及文件，根据自己的实际情况指定，后面为固定的&lt;/p&gt;

&lt;p&gt;4）下载harbor1.9&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;wget&lt;/span&gt; https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;github.com/goharbor/harbor/releases/download/v1.9.3/harbor-online-installer-v1.9.3.tgz&lt;/span&gt;
&lt;span&gt;tar&lt;/span&gt; -xvf harbor-online-installer-v1.&lt;span&gt;9.3&lt;/span&gt;.tgz
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;5）拷贝转换好的V1.9版本配置文件放置harbor1.9，并启动&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;cp&lt;/span&gt; /harbor.yml harbor1.&lt;span&gt;9&lt;/span&gt;/  &lt;span&gt;#拷贝第三步中由1.6版本转换成1.9版本的配置文件&lt;/span&gt;到harbor1.9的安装目录&lt;span&gt;
cd harbor1.&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;/&lt;span&gt;
.&lt;/span&gt;/&lt;span&gt;install&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;V1.9升级V2.0只需转换配置文件，步骤如下：&lt;/p&gt;

&lt;p&gt;1）停止容器&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
docker-compose down -v
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2）备份&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;cp&lt;/span&gt; -r harbor /backup_bak/harbor_v1.&lt;span&gt;9&lt;/span&gt;&lt;span&gt;   # 备份配置文件目录
&lt;/span&gt;&lt;span&gt;cp&lt;/span&gt; -r /data/database /harbor_bak/database1.&lt;span&gt;9&lt;/span&gt;  # 备份数据库文件
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;3）1.9版本的配置文件harbor.yml转换成2.0版本的配置文件harbor.yml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
# 拉取goharbor/prepare:v2.&lt;span&gt;0&lt;/span&gt;&lt;span&gt;.0镜像
docker pull goharbor&lt;/span&gt;/prepare:v2.&lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;

# 这里先拷贝一份原来的配置文件到一个目录下，这里我的是&lt;/span&gt;/usr/local/leee/&lt;span&gt;harbor.yml
# 不指定输出文件的话，默认到当前目录下，如果输入文件与输出文件在同一个目录，那么新版本的配置文件将会覆盖旧版本的配置文件，一定要做好备份
docker run &lt;/span&gt;-it --&lt;span&gt;rm&lt;/span&gt; -v /:/hostfs goharbor/prepare:v2.&lt;span&gt;0.0&lt;/span&gt; migrate -i /usr/local/leee/&lt;span&gt;harbor.yml&lt;br/&gt;# 也可以写成&lt;br/&gt;docker run &lt;/span&gt;-it --&lt;span&gt;rm&lt;/span&gt; -v /:/hostfs goharbor/prepare:v2.&lt;span&gt;0.0&lt;/span&gt; migrate -i /usr/local/leee/harbor.yml -o /usr/local/leee/harbor_v2.yml -t &lt;span&gt;2.0&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;17&quot;&gt;

&lt;p&gt;拉取goharbor/prepare:v2.0.0镜像，这个镜像一共有3个作用&lt;strong&gt;&lt;span&gt;prepare、gencert、migrate&lt;/span&gt;&lt;/strong&gt;，其中migrate就是转换配置文件的；&lt;/p&gt;
&lt;p&gt;migrate一个三个参数：&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt;&lt;span&gt;    -i ：指定被转换的配置文件，在这里就是1.9版本的harbor.yml&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;      -o：转换到哪一个文件，默认是当前目录下的harbor.yml&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;      -t：转换到那个版本，这里我的prepare镜像是2.0.0版本，因此默认是将配置文件转换成2.0版本格式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/746846/202007/746846-20200717010450226-2107706226.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;
&lt;/div&gt;
&lt;p&gt;4）下载2.0版本的Harbor包&lt;/p&gt;

&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;wget&lt;/span&gt; https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;github.com/goharbor/harbor/releases/download/v2.0.0/harbor-online-installer-v2.0.0.tgz&lt;/span&gt;
&lt;span&gt;tar&lt;/span&gt; -xvf harbor-online-installer-v2.&lt;span&gt;0.0&lt;/span&gt;.tgz
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;5、拷贝已转换的配置文件到2.0版本的harbor包下，并启动&lt;/p&gt;


&lt;p&gt;在平凡中坚持前行，总有一天会遇见不一样的自己。&lt;/p&gt;

&lt;p&gt;写博客记录、思考、总结，趟过的坑不趟第二遍。&lt;/p&gt;

&lt;p&gt;所有的文章，皆同步在公众号“运维汪”，可关注；也可加入“不扯淡，专注于技术”的QQ群：753512236；&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/746846/202007/746846-20200717005038101-807082493.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/div&gt;

</description>
<pubDate>Thu, 16 Jul 2020 18:17:00 +0000</pubDate>
<dc:creator>Captain_Li</dc:creator>
<og:description>目录 一、目标 二、V1.4升级至V1.6 三、V1.6升级至V1.9 四、V1.9升级至V2.0 五、写在最后 一、目标 Harbor V1.4版本升级至V2.0 注： Harbor升级需要注意的是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lemon-le/p/13326846.html</dc:identifier>
</item>
<item>
<title>简单的电脑使用维护方法（肝货一） - 余月七</title>
<link>http://www.cnblogs.com/unleashed/p/13326786.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/unleashed/p/13326786.html</guid>
<description>&lt;p&gt;来简单的总结并且分享一下我进入计算机世界一年间所了解和收获到的知识&lt;/p&gt;
&lt;p&gt;&lt;em&gt;恩。。。。就是突然想到一些以前看到的和现在正在使用的电脑使用方法，想写出来做个大体的记录，可能对初学者有用，也就是刚开始使用电脑的人。至于学计算机专业的人就没必要看了，毕竟是一些入门的简单知识。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;打算是写两篇内容，下一篇主要想着是围绕Windows系统和命令做介绍。&lt;/em&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;ul&gt;&lt;li&gt;首先我们从外观上来看，就是笔记本和台式电脑（这里不说大型计算机）&lt;/li&gt;
&lt;li&gt;无非都是CPU、内存、硬盘、键盘、显示器。（这里是举例，不提专业用词&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;em&gt;以上简单的介绍说明，电脑基本构造是一模一样的。那么就有人有问题了，“为什么我的电脑问题那么多”；可能会有人说“电脑配置不一样，肯定配置低的问题也多啊”，这种说法也不能说是错误的，但是对于现在这个时代，5000~6000元价位的电脑都应该差不多吧，并不是差之千里。所以换个角度来讲，电脑的使用好坏其实与个人也有很大的一部分关系。那至此的话，我就直接开说了。&lt;/em&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;hr/&gt;

&lt;h2 id=&quot;第一点：cpu&quot;&gt;第一点：&lt;em&gt;CPU&lt;/em&gt;&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;        *CPU*可以说是电脑的“心脏”，当它（*cpu*）从电脑启动那一刻起就不停地运作，所以它的重要性自然是不言而喻的，因此我们对它的“保养”显得尤为重要。

        在*CPU*的保养中散热肯定是最为关键的；虽然*CPU*有风扇在保护，但随着我们的使用，耗用电流的增加所产生的热量也随之增加，从而*CPU*的温度也将随之上升；高温容易使*CPU*内部线路发生电子迁移，这样的话容易导致电脑经常性**死机**，而且也会缩短***CPU***的寿命，若是高电压，那就更加的危险，很容易**烧毁**你的***CPU***；所以说我们要选择电脑时，不光要看电脑的好坏，还要选择质量好的散热风扇。

        ** 那么怎么选怎么维护呢？**
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;散热片的底层以厚的为佳，这样有利于储热，从而易于风扇主动散热；然后平常要注意隔一段时间要除一下灰尘，不能让灰尘积聚在CPU的表面上，以免造成短路，烧毁CPU；&lt;/li&gt;
&lt;li&gt;涂硅脂的话，要涂于CPU表面内核上，薄薄一层就可以，过量会有可能渗到CPU表面和插槽，造成CPU的毁坏。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;另外要说的是，现在主流的CPU频率达1GHz以上了，这时超频的意义已经不大了。（而且2GHz的也不在少数）所以我们更多的应该考虑的是延长CPU寿命。如确实有需要超频，可考虑降电压超频。切忌通过提高内核电压来帮助超频，因为这是得不偿失的。高温高压很容易造成CPU内存发生电子迁移，甚至击穿烧坏CPU的线路。而厂家对这种人为的损坏是不负任何责任的。谁都不想为了体验一下一点点的提速而过把瘾就死吧。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;h2 id=&quot;第二点：主板&quot;&gt;第二点：主板&lt;/h2&gt;
&lt;p&gt;现在的电脑主板大多数都是四层板，六层板，而且使用的元件和布线都非常精密；既然精密的话，就不能乱搞，所以当&lt;strong&gt;灰尘在主板积累过多&lt;/strong&gt;时，主板会吸收空气中的水份，此时灰尘就会呈现一定的导电性，可能把主板上的不同信号进行连接或者把&lt;strong&gt;电阻，电容短路&lt;/strong&gt;，致使信号传输错误或者工作点变化而导致主机工作不稳或不启动；&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    实际中，我们使用电脑中遇到的**主机频繁死机、重启**、找不到键盘鼠标、开机报警等情况多数都是由于主板上积累了大量灰尘而导致的，这时只要**清扫机箱内的灰尘**后，故障就会不治自愈。 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;主板上给CPU、内存等提供供电的是大大小小的电容，电容最怕高温，温度过高很容易就会造成电容击穿而影响正常使用；在很多情况下，主板上的电解电容鼓泡或漏液，失容并非是因为产品质量有问题，而是因为主板的工作环境过差造成的；一般鼓泡，漏液，失容的电容多数都是出现在CPU的周围，内存条边上，AGP 插槽旁边，这是因为上述几个部件都是计算机中的发热量大户，在长时间的高温烘烤中，铝电解电容就可能会出现上述故障。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;了解了以上的情况，你在购机的时候就要有意识地选择宽敞、通风的机箱。另外，定期开机箱除尘也是必不可少的一项工作，一般是用毛刷轻轻刷去主板上的灰尘。由于主板上一些插卡、芯片采用插脚形式，常会因为引脚氧化而接触不良，可用橡皮擦去表面氧化层并重新插接。当然有条件时你可以用挥发性能好的三氯乙烷来清洗主板。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;h2 id=&quot;第三点：硬盘&quot;&gt;第三点：硬盘&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;     硬盘—是计算机中**最重要的存储介质**，但是在显示当中很多人是忽视了对硬盘的维护保养，一打开电脑就会让硬盘满负荷运转：看高清的DVD影片、进行不间断的BT下载、频繁的使用Windows的系统还原功能，这使得硬盘总是处于一种**满负荷**运转的状况。 
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;BT下载&lt;/strong&gt;之所以速度快，是由于每个用户的下载和上传几乎是同时进行，也就是你在下载的同时，也要上传数据给其它用户；而且BT下载时是将下载的&lt;strong&gt;数据&lt;/strong&gt;直接写进硬盘，因此对&lt;strong&gt;硬盘的损耗&lt;/strong&gt;也很大；如果你经常使用BT下载，就要加大一些Cache（高速缓冲存储器）应该可以减少硬盘读写，提高性能；一般设在8-16MB，内存大的最好设为 32MB。另外要注意的是不要一次性开太多的下载或上传的窗口，1到3个就行了。还有在BT运行时，最好调出任务管理器把它的优先权调到低于标准。 &lt;br/&gt;    容易造成硬盘异常的，还有硬盘保护软件；比如“还原精灵”，由于很多人不注意在重装系统或是重新分区前将它正常卸载，往往会发生系统无法完全安装等情况。此时再想安装并卸载“还原精灵”，却又提示软件已经安装，无法继续，&lt;strong&gt;陷入死循环&lt;/strong&gt;中。这种故障是由于 “还原精灵”接管了INT13中断，在操作系统之前就控制了硬盘的引导，用FDISK/MBR指令也无法解决；本来这只是软件的问题，但很多人&lt;strong&gt;经验不足&lt;/strong&gt;，出了问题会找各种分区工具“试验”，甚至&lt;strong&gt;轻率地低级格式化&lt;/strong&gt;，在这样的折腾之下，硬盘很可能提前夭折！建议用户在遇到自己不懂的硬盘故障时，要&lt;strong&gt;多向身边的高手请教&lt;/strong&gt;。如果周围没有这样的人，&lt;strong&gt;切忌不要&lt;/strong&gt;动不动就用各种工具低级格式化，这样会给给硬盘造成致命的损害。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;最后要注意的是千万不要在硬盘的使用过程中移动或震动硬盘。因为硬盘是复杂的机械装置，大的震动会让磁头组件碰到盘片上，引起硬盘读写头划破盘表面，这样可能损坏磁盘面，潜在地破坏存在的硬盘上数据（你的心血哟！），更严重的还可能损坏读写头，永久的使硬盘无法使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;第四点：显示器&quot;&gt;第四点：显示器&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;现在，很多人都用上了液晶显示器，用液晶显示器最大的禁忌在于触摸液晶面板。液晶面板表面有专门的涂层，这层涂层可以防止反光，增加观看效果。而很多人不知道这点，总是习惯于用手去摸液晶屏幕，殊不知人手上有一定的腐蚀性油脂，会轻微的腐蚀面板的涂层，时间长了会造成面板永久性的损害。这种被损坏的面板在使用中会有斑驳陆离的感觉。另外，有些人喜欢用手去压面板，觉得很有意思。这绝对是个恶劣的习惯，这样做会导致坏点和暗斑，这可是永久性的损害，绝不可修复的！ &lt;br/&gt;   对液晶显示器的清洁是很必要的，但千万不要用酒精来擦拭，因为酒精会腐蚀涂层，对你的液晶屏幕造成永久的损害。真正科学的做法是买一本擦镜头专用的镜头纸，撕下一张折叠以后稍微沾一点饮用纯净水即可，镜头纸纤维比较长，不易产生绒毛，所以擦拭显示器很理想。面板上哪里脏了就擦那里，原则上不要扩大擦拭的范围，擦完以后用干的镜头纸轻轻拭一遍，把水印去掉就可以了。 &lt;br/&gt;   其它要注意的事项还有最好不要在使用电脑的时候吸烟，香烟中的某些成份可能损害面板表面的涂层，再说香烟的烟雾会附着在显示器的外壳上，时间长了就成了黄色的，显得非常难看。还有，跟其他的配件相似，灰尘对显示器内部电子器件的损害也比较大，最好在不用电脑时给显示器戴一个防尘套。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;hr/&gt;&lt;p&gt;&lt;em&gt;从上面这几点看得话，都是硬件上的东西，而且这对一些人是有困难的，所以下面我来说一下关于软件上，也就是我们可以简单明了看见的东西。&lt;/em&gt;&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;&lt;em&gt;软件上的东西其实说多也不多，简单的来说存在三个问题：如何获取软件？如何安装卸载软件？如何正确的使用系统工具？&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;第一点：如何获取软件&quot;&gt;第一点：如何获取软件&lt;/h2&gt;
&lt;p&gt;“获取软件”，怎么获取，无非就是浏览器中下载，或者是所谓的“软件管家”中下载；但是我这里的建议是使用浏览器，进入官网下载，这样下载下来的东西也比较安全、并且软件本身也不会出现问题。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1. **浏览器：首推谷歌，其次火狐，最后使用微软新版Edge。**
2. **下载途径：官网、百度网盘**
&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h2 id=&quot;&quot;/&gt;
&lt;h2 id=&quot;第二点：如何安装卸载软件&quot;&gt;第二点：如何安装卸载软件&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;安装软件需注意：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1. **软件的下载目录尽量不要设置在C盘（也就是系统盘）**
2. **软件下载完成后，进行安装，安装目录也是尽量不要设置在C盘，并且安装过程切忌不要奔流倾泻，一股脑的next下去。**
3. **软件安装成功后，启动软件，建议把软件的默认缓存设置一下，尽量也不要是C盘。**
4. **使用软件快捷操作时，一定要进行 右击软件—发送到—桌面快捷方式，千万不要拖动了，只能简单的给你说，有些软件是不支持这种方式，导致你点击快捷方式后无法使用。**
&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;在这里推荐两款软件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一款：ThrottleStop&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;常用的关闭睿频的操作，可以使电脑温度下降一点，关闭风扇&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.techpowerup.com/download/techpowerup-throttlestop/&quot;&gt;https://www.techpowerup.com/download/techpowerup-throttlestop/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2031154/202007/2031154-20200717003902144-1316127714.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二款：CoreTemp&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;检测电脑的cpu温度和内存等等状态&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.alcpu.com/CoreTemp/&quot;&gt;https://www.alcpu.com/CoreTemp/&lt;/a&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2031154/202007/2031154-20200717003918864-1938369643.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第三款：Aida64&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.aida64.com.cn/&quot;&gt;http://www.aida64.com.cn/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;最简单的图形化工具帮你实现电脑最直观的查看与分析&lt;/strong&gt;&lt;/em&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2031154/202007/2031154-20200717004033484-1297020795.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第四款：Dism++&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.chuyu.me/zh-Hans/&quot;&gt;https://www.chuyu.me/zh-Hans/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;简单轻量级系统优化工具&lt;/strong&gt;&lt;/em&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2031154/202007/2031154-20200717004048134-785128940.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;卸载软件需注意：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1. **这时候就到了熟悉的“杀毒软件”登场了，比如360卫士、腾讯电脑管家、金山毒霸、金山卫士等等。（这里我可没说推荐你们使用这些软件）。**
2. **首先，我们可选系统中找到 控制面板 选项，在那里面进行卸载软件，虽然有多出来的步骤；因为当你在控制面板中卸载完之后，你还需要提前找好软件的安装目录，把整个安装软件的文件给清除了。而且还需要我们自己去找注册表中的东西，这就算上对一些人不太友好了！**
&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;推荐卸载软件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、UninstallTool&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://crystalidea.com/uninstall-tool&quot;&gt;https://crystalidea.com/uninstall-tool&lt;/a&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2031154/202007/2031154-20200717004059668-1203917890.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、RevoUninstall&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://download.cnet.com/Revo-Uninstaller/3000-2096_4-10687648.html&quot;&gt;https://download.cnet.com/Revo-Uninstaller/3000-2096_4-10687648.html&lt;/a&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2031154/202007/2031154-20200717004112794-729969915.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三、Total Uninstall&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.martau.com/zh-CN/&quot;&gt;https://www.martau.com/zh-CN/&lt;/a&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2031154/202007/2031154-20200717004121914-2078269535.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;四、火绒安全软件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果是非专业人员还是比较推荐的，因为360全家桶对新手不是很友好，而且广告也有点多。至于学这个计算机专业的人，其实我觉得暂且不需要安装杀毒软件，因为你要试着看出病毒并且去处理它。而且大多数初学计算机专业的人用的也都是pojie版软件而并非用钱买的正版，所以其中的东西这里就不多说了，有时候连个微软自带的Defender就自己直接把一些“危险文件”直接处理了，所以我的处理是直接关了Defender，有点好笑了。。。。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.huorong.cn/&quot;&gt;https://www.huorong.cn/&lt;/a&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2031154/202007/2031154-20200717004412064-921384249.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;第三点：如何正确的使用系统工具&quot;&gt;第三点：如何正确的使用系统工具&lt;/h2&gt;
&lt;p&gt;可以简单的说，&lt;strong&gt;控制面板&lt;/strong&gt;给了你最容易使用系统工具的方式！&lt;/p&gt;
&lt;p&gt;&lt;em&gt;如果要详谈的话，就又得涉及很多，那我就留给将要写的第二篇文章吧！&lt;/em&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;em&gt;题目呢，就是&lt;/em&gt; &lt;em&gt;&lt;strong&gt;电脑的使用技巧（肝货二）&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 16 Jul 2020 16:57:00 +0000</pubDate>
<dc:creator>余月七</dc:creator>
<og:description>前言 来简单的总结并且分享一下我进入计算机世界一年间所了解和收获到的知识 恩。。。。就是突然想到一些以前看到的和现在正在使用的电脑使用方法，想写出来做个大体的记录，可能对初学者有用，也就是刚开始使用电</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/unleashed/p/13326786.html</dc:identifier>
</item>
</channel>
</rss>