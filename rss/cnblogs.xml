<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>据说比Spring快44倍的web开发框架，不妨试试 - 字母哥博客</title>
<link>http://www.cnblogs.com/zimug/p/13320730.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zimug/p/13320730.html</guid>
<description>&lt;p&gt;该框架称为：**light-4j **。官方网站简介：A fast, lightweight and more productive microservices framework。很简单，翻译过来就是：一个快速、轻量级和更高效的微服务框架.&lt;/p&gt;
&lt;p&gt;为什么叫light-4j？全称应该是：Light for Java，意味着轻量级，并以闪电般的速度来进行 Java 编程.&lt;/p&gt;
&lt;h2 id=&quot;用这个框架有什么好处？&quot;&gt;用这个框架有什么好处？&lt;/h2&gt;
&lt;h3 id=&quot;1-降低成本&quot;&gt;1. 降低成本&lt;/h3&gt;
&lt;p&gt;为什么说它能降低成本，因为它速度非常快，占用内存也非常小.&lt;/p&gt;
&lt;p&gt;重点来了，它比类似 Spring Boot 这种内嵌 Tomcat 式的主流微服务框架平台要快 44 倍，并且只需要用其 1/5 内存，听起来是不是很牛逼，确实是节约了不少内存空间.&lt;/p&gt;
&lt;p&gt;这是一个基准测试报告，与Spring Boot和其他微服务平台进行了比较：&lt;/p&gt;
&lt;p&gt;详细报告：&lt;a href=&quot;https://github.com/networknt/microservices-framework-benchmark&quot;&gt;https://github.com/networknt/microservices-framework-benchmark&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;很强大，性能与 Go 语言并肩，并且拥有更低的平均延迟.&lt;/p&gt;
&lt;p&gt;这也是与其他Web框架的比较：&lt;/p&gt;
&lt;p&gt;详细报告：&lt;a href=&quot;https://www.techempower.com/benchmarks/#section=data-r15&amp;amp;hw=ph&amp;amp;test=plaintext&quot;&gt;https://www.techempower.com/benchmarks/#section=data-r15&amp;amp;hw=ph&amp;amp;test=plaintext&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;2丰富的功能&quot;&gt;2.丰富的功能&lt;/h3&gt;
&lt;ul readability=&quot;14&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;具有启动/关闭挂钩和各种中间件的插件架构&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;分布式OAuth2 JWT安全验证作为框架的一部分&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;基于OpenAPI规范的请求和响应验证&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;收集测量指标以及支持服务和控制台上显示的客户&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;全局运行时异常处理，例如API异常和其他检查的异常&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在日志输出之前对敏感数据进行加密，例如信用卡，SIN号等。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;清除请求参数，请求标头和正文的跨站点攻击脚本&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;审核重要信息或整个请求/响应&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;请求主体支持各种类型的内容类型&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;配置标准化的响应代码和响应消息&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;支持外部配置的Docker环境的所有模块&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;来自其他域名的跨域处理&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;支持限速处理外部提供的服务&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;服务发现和注册支持直接连接，领事和Zookeeper&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;客户端发现和负载平衡，消除了代理层&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;与Light-OAuth2紧密集成并支持可追溯性&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;首先在这里介绍，每个有兴趣的人都可以去Github修补一下...&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Github地址：&lt;a href=&quot;https://github.com/networknt/light-4j&quot;&gt;https://github.com/networknt/light-4j&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;最后&quot;&gt;最后&lt;/h2&gt;
&lt;p&gt;阅读完之后，您可能会问，目前有在广泛的使用吗？这个我目前没有可靠数据，但这个框架的性能表现和内存消耗真的非常惊人，以及它的各种功能特性都值得借鉴。&lt;/p&gt;
&lt;p&gt;比 Spring Boot 框架要快 44 倍，但是我觉得这个大家也不用太纠结，Spring 发展到今天，经过国外各种大神的打磨，可以说是非常精湛.Spring 日益宠大的同时，其内部依赖集成了太多东西，在性能这方面没其他框架强，确实能够理解，但 Spring 的生态圈是没有任何框架可以比拟的。在追求生态完整性的同时，它肯定也会牺牲很多东西，所以，我觉得一个生态繁荣的技术平台比追求性能更重要.&lt;/p&gt;
&lt;h2 id=&quot;欢迎关注我的博客，里面有很多精品合集&quot;&gt;欢迎关注我的博客，里面有很多精品合集&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;本文转载注明出处（必须带连接，不能只转文字）：&lt;a href=&quot;http://www.zimug.com&quot;&gt;字母哥博客&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;觉得对您有帮助的话，帮我点赞、分享！您的支持是我不竭的创作动力！&lt;/strong&gt; 。另外，笔者最近一段时间输出了如下的精品内容，期待您的关注。&lt;/p&gt;
</description>
<pubDate>Thu, 16 Jul 2020 00:48:00 +0000</pubDate>
<dc:creator>字母哥博客</dc:creator>
<og:description>该框架称为：**light-4j **。官方网站简介：A fast, lightweight and more productive microservices framework。很简单，翻译过来就</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zimug/p/13320730.html</dc:identifier>
</item>
<item>
<title>.NET 开源项目 StreamJsonRpc 介绍[下篇] - 精致码农</title>
<link>http://www.cnblogs.com/willick/p/13320711.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/willick/p/13320711.html</guid>
<description>&lt;p&gt;阅读本文大概需要 9 分钟。&lt;/p&gt;
&lt;p&gt;大家好，这是 .NET 开源项目 StreamJsonRpc 介绍的最后一篇。&lt;a href=&quot;https://mp.weixin.qq.com/s/3V4mCdFvNzUzqkqKm-rzpw&quot;&gt;上篇&lt;/a&gt;介绍了一些预备知识，包括 JSON-RPC 协议介绍，StreamJsonRpc 是一个实现了 JSON-RPC 协议的库，它基于 Stream、WebSocket 和自定义的全双工管道传输。&lt;a href=&quot;https://mp.weixin.qq.com/s/NgifmBGV7ipxNMCyDmG0FA&quot;&gt;中篇&lt;/a&gt;通过示例讲解了 StreamJsonRpc 如何使用全双工的 Stream 作为传输管道实现 RPC 通讯。本篇（下篇）将继续通过示例讲解如何基于 WebSocket 传输管道实现 RPC 通讯。&lt;/p&gt;
&lt;h2 id=&quot;准备工作&quot;&gt;准备工作&lt;/h2&gt;
&lt;p&gt;为了示例的完整性，本文示例继续在&lt;a href=&quot;https://mp.weixin.qq.com/s/NgifmBGV7ipxNMCyDmG0FA&quot;&gt;中篇&lt;/a&gt;创建的示例基础上进行。该示例的 GitHub 地址为：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/liamwang/StreamJsonRpcSamples&quot;&gt;github.com/liamwang/StreamJsonRpcSamples&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我们继续添加三个项目，一个是名为 WebSocketSample.Client 的 Console 应用，一个是名为 WebSocketSample.Server 的 ASP.NET Core 应用，还有一个名为 Contract 的契约类库（和 gRPC 类似）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/191097/202007/191097-20200715201442433-108032433.png&quot; alt=&quot; &quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;你可以直接复制并执行下面的命令一键完成大部分准备工作：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;dotnet new console -n WebSocketSample.Client # 建新客户端应用
dotnet new webapi -n WebSocketSample.Server # 新建服务端应用
dotnet new classlib -n Contract # 新建契约类库
dotnet sln add WebSocketSample.Client WebSocketSample.Server Contract # 将项目添加到解决方案
dotnet add WebSocketSample.Client package StreamJsonRpc # 为客户端安装 StreamJsonRpc 包
dotnet add WebSocketSample.Server package StreamJsonRpc # 为服务端安装 StreamJsonRpc 包
dotnet add WebSocketSample.Client reference Contract # 添加客户端引用 Common 引用
dotnet add WebSocketSample.Server reference Contract # 添加服务端引用 Common 引用
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了把重点放在实现上，这次我们依然以一个简单的功能作为示例。该示例实现客户端向服务端发送一个问候数据，然后服务端响应一个消息。为了更贴合实际的场景，这次使用强类型进行操作。为此，我们在 Contract 项目中添加三个类用来约定客户端和服务端通讯的数据结构和接口。&lt;/p&gt;
&lt;p&gt;用于客户端发送的数据的 HelloRequest 类：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;public class HelloRequest
{
    public string Name { get; set; }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用于服务端响应的数据的 HelloResponse 类：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;public class HelloResponse
{
    public string Message { get; set; }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用于约定服务端和客户端行为的 IGreeter 接口：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;public interface IGreeter
{
    Task&amp;lt;HelloResponse&amp;gt; SayHelloAsync(HelloRequest request);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来和中篇一样，通过建立连接、发送请求、接收请求、断开连接这四个步骤演示和讲解一个完整的基于 WebSocket 的 RPC 通讯示例。&lt;/p&gt;
&lt;h2 id=&quot;建立连接&quot;&gt;建立连接&lt;/h2&gt;
&lt;p&gt;上一篇讲到要实现 JSON-RPC 协议的通讯，要求传输管道必须是全双工的。而 WebSocket 就是标准的全双工通讯，所以自然可以用来实现 JSON-RPC 协议的通讯。.NET 本身就有现成的 WebSocket 实现，所以在建立连接阶段和 StreamJsonRpc 没有关系。我们只需要把 WebSocket 通讯管道架设好，然后再使用 StreamJsonRpc 来发送和接收请求即可。&lt;/p&gt;
&lt;p&gt;客户端使用 WebSocket 建立连接比较简单，使用 &lt;code&gt;ClientWebSocket&lt;/code&gt; 来实现，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;using (var webSocket = new ClientWebSocket())
{
    Console.WriteLine(&quot;正在与服务端建立连接...&quot;);
    var uri = new Uri(&quot;ws://localhost:5000/rpc/greeter&quot;);
    await webSocket.ConnectAsync(uri, CancellationToken.None);
    Console.WriteLine(&quot;已建立连接&quot;);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;服务端建立 WebSocket 连接最简单的方法就是使用 ASP.NET Core，借助 Kestrel 和 ASP.NET Core 的中间件机制可以轻松搭建基于 WebSocket 的 RPC 服务。只要简单的封装还可以实现同一套代码同时提供 RPC 服务和 Web API 服务。&lt;/p&gt;
&lt;p&gt;首先在服务端项目的 Startup.cs 类的 &lt;code&gt;Configure&lt;/code&gt; 方法中引入 WebSocket 中间件：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
{
    app.UseRouting();

    app.UseWebSockets(); // 增加此行，引入 WebSocket 中间件

    app.UseEndpoints(endpoints =&amp;gt;
    {
        endpoints.MapControllers();
    });
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再新建一个 Controller 并定义一个 Action 用来路由映射 WebSocket 请求：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;public class RpcController : ControllerBase
{
    ...
    [Route(&quot;/rpc/greeter&quot;)]
    public async Task&amp;lt;IActionResult&amp;gt; Greeter()
    {
        if (!HttpContext.WebSockets.IsWebSocketRequest)
        {
            return new BadRequestResult();
        }

        var socket = await HttpContext.WebSockets.AcceptWebSocketAsync();

        ...
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的 Greeter 提供的服务既能接收 HTTP 请求也能接收 WebSocket 请求。&lt;code&gt;HttpContext&lt;/code&gt; 中的 &lt;code&gt;WebSockets&lt;/code&gt; 属性是一个 &lt;code&gt;WebSocketManager&lt;/code&gt; 对象，它可以用来判断当前请求是否为一个 WebSocket 请求，也可以用来等待和接收 WebSocket 连接，即上面代码中的 &lt;code&gt;AcceptWebSocketAsync&lt;/code&gt; 方法。另外客户端的 WebSocket 的 Uri 路径需要与 Router 指定的路径对应。&lt;/p&gt;
&lt;p&gt;连接已经建立，现在到了 StreamJsonRpc 发挥作用的时候了。&lt;/p&gt;
&lt;h2 id=&quot;发送请求&quot;&gt;发送请求&lt;/h2&gt;
&lt;p&gt;客户端通过 WebSocket 发送请求的方式和前一篇讲的 Stream 方式是一样的。还记得前一篇讲到的 JsonRpc 类的 Attach 静态方法吗？它告诉 StreamJsonRpc 如何传输数据，并返回一个用于调用 RPC 的客户端，它除了可以接收 Stream 参数外还有多个重载方法。比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;public static T Attach&amp;lt;T&amp;gt;(Stream stream);
public static T Attach&amp;lt;T&amp;gt;(IJsonRpcMessageHandler handler);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第二个重载方法可以实现更灵活的 Attach 方式，你可以 Attach 一个交由 WebSocket 传输数据的管道，也可以 Attach 给一个自定义实现的 TCP 全双工传输管道（此方式本文不讲，但文末会直接给出示例）。现在我们需要一个实现了 &lt;code&gt;IJsonRpcMessageHandler&lt;/code&gt; 接口的处理程序，StreamJsonRpc 已经实现好了，它是 &lt;code&gt;WebSocketMessageHandler&lt;/code&gt; 类。通过 Attach 该实例，可以拿到一个用于调用 RPC 服务的对象。代码示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;Console.WriteLine(&quot;开始向服务端发送消息...&quot;);
var messageHandler = new WebSocketMessageHandler(webSocket);
var greeterClient = JsonRpc.Attach&amp;lt;IGreeter&amp;gt;(messageHandler);
var request = new HelloRequest { Name = &quot;精致码农&quot; };
var response = await greeterClient.SayHelloAsync(request);
Console.WriteLine($&quot;收到来自服务端的响应：{response.Message}&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你会发现，定义客户端和服务端契约的好处是可以实现强类型编程。接下来看服务端如何接收并处理客户端发送的消息。&lt;/p&gt;
&lt;h2 id=&quot;接收请求&quot;&gt;接收请求&lt;/h2&gt;
&lt;p&gt;和前一篇一样，我们先定义一个 GreeterServer 类用来处理接收到的客户端消息。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;public class GreeterServer : IGreeter
{
    private readonly ILogger&amp;lt;GreeterServer&amp;gt; _logger;
    public GreeterServer(ILogger&amp;lt;GreeterServer&amp;gt; logger)
    {
        _logger = logger;
    }

    public Task&amp;lt;HelloResponse&amp;gt; SayHelloAsync(HelloRequest request)
    {
        _logger.LogInformation(&quot;收到并回复了客户端消息&quot;);
        return Task.FromResult(new HelloResponse
        {
            Message = $&quot;您好， {request.Name}！&quot;
        });
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同样，WebSocket 服务端也需要使用 Attach 来告诉 StreamJsonRpc 数据如何通讯，而且使用的也是 &lt;code&gt;WebSocketMessageHandler&lt;/code&gt; 类，方法与客户端类似。在前一篇中，我们 Attach 一个 Stream 调用的方法是：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;public static JsonRpc Attach(Stream stream, object? target = null);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同理，我们推测应该也有一个这样的静态重载方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;public static JsonRpc Attach(IJsonRpcMessageHandler handler, object? target = null);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可惜，StreamJsonRpc 并没有提供这个静态方法。既然 Attach 方法返回的是一个 JsonRpc 对象，那我们是否可以直接实例化该对象呢？查看该类的定义，我们发现是可以的，而且有我们需要的构造函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;public JsonRpc(IJsonRpcMessageHandler messageHandler, object? target);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来就简单了，一切和前一篇的 Stream 示例都差不多。在 RpcController 的 Greeter Action 中实例化一个 JsonRpc，然后开启消息监听。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;public class RpcController : ControllerBase
{
    private readonly ILogger&amp;lt;RpcController&amp;gt; _logger;
    private readonly GreeterServer _greeterServer;

    public RpcController(ILogger&amp;lt;RpcController&amp;gt; logger, GreeterServer greeterServer)
    {
        _logger = logger;
        _greeterServer = greeterServer;
    }

    [Route(&quot;/rpc/greeter&quot;)]
    public async Task&amp;lt;IActionResult&amp;gt; Greeter()
    {
        if (!HttpContext.WebSockets.IsWebSocketRequest)
        {
            return new BadRequestResult();
        }

        _logger.LogInformation(&quot;等待客户端连接...&quot;);
        var socket = await HttpContext.WebSockets.AcceptWebSocketAsync();
        _logger.LogInformation(&quot;已与客户端建立连接&quot;);

        var handler = new WebSocketMessageHandler(socket);

        using (var jsonRpc = new JsonRpc(handler, _greeterServer))
        {
            _logger.LogInformation(&quot;开始监听客户端消息...&quot;);
            jsonRpc.StartListening();
            await jsonRpc.Completion;
            _logger.LogInformation(&quot;客户端断开了连接&quot;);
        }

        return new EmptyResult();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看起来和我们平时写 Web API 差不多，区别仅仅是对请求的处理方式。但需要注意的是，WebSocket 是长连接，如果客户端没有事情可以处理了，最好主动断开与服务端的连接。如果客户客户没有断开连接，执行的上下文就会停在 &lt;code&gt;await jsonRpc.Completion&lt;/code&gt; 处。&lt;/p&gt;
&lt;h2 id=&quot;断开连接&quot;&gt;断开连接&lt;/h2&gt;
&lt;p&gt;通常断开连接是由客户端主动发起的，所以服务端不需要做什么处理。服务端响应完消息后，只需使用 &lt;code&gt;jsonRpc.Completion&lt;/code&gt; 等待客户端断开连接即可，上一节的代码示例中已经包含了这部分代码，就不再累述了。如果特殊情况下服务端需要断开连接，调用 JsonRpc 对象的 Dispose 方法即可。&lt;/p&gt;
&lt;p&gt;不管是 Stream 还是 WebSocket，其客户端对象都提供了 Close 或 Dispose 方法，连接会随着对象的释放自动断开。但最好还是主动调用 Close 方法断开连接，以确保服务端收到断开的请求。对于 ClientWebSocket，需要调用 CloseAsync 方法。客户端完整示例代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;static async Task Main(string[] args)
{
    using (var webSocket = new ClientWebSocket())
    {
        Console.WriteLine(&quot;正在与服务端建立连接...&quot;);
        var uri = new Uri(&quot;ws://localhost:5000/rpc/greeter&quot;);
        await webSocket.ConnectAsync(uri, CancellationToken.None);
        Console.WriteLine(&quot;已建立连接&quot;);

        Console.WriteLine(&quot;开始向服务端发送消息...&quot;);
        var messageHandler = new WebSocketMessageHandler(webSocket);
        var greeterClient = JsonRpc.Attach&amp;lt;IGreeter&amp;gt;(messageHandler);
        var request = new HelloRequest { Name = &quot;精致码农&quot; };
        var response = await greeterClient.SayHelloAsync(request);
        Console.WriteLine($&quot;收到来自服务端的响应：{response.Message}&quot;);

        Console.WriteLine(&quot;正在断开连接...&quot;);
        await webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, &quot;断开连接&quot;, CancellationToken.None);
        Console.WriteLine(&quot;已断开连接&quot;);
    }

    Console.ReadKey();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在实际项目中可能还需要因异常而断开连接的情况做处理，比如网络不稳定可能导致连接中断，这种情况可能需要加入重试机制。&lt;/p&gt;
&lt;h2 id=&quot;运行示例&quot;&gt;运行示例&lt;/h2&gt;
&lt;p&gt;由于服务端使用的是 ASP.NET Core 模板，VS 默认使用 IIS Express 启动，启动后会自动打开网页，这样看不到 Console 的日志信息。所以需要把服务端项目 WebSocketSample.Server 的启动方式改成自启动。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/191097/202007/191097-20200715203513168-761745528.png&quot; alt=&quot; &quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外，为了更方便地同时运行客户端和服务端应用，可以把解决方案设置成多启动。右键解决方案，选择“Properties”，把对应的项目设置“Start”即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/191097/202007/191097-20200715202446183-1806619492.png&quot; alt=&quot; &quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果你用的是 VS Code，也是支持多启动调试的，具体方法你自行 Google。如果你用的是 &lt;code&gt;dotnet run&lt;/code&gt; 命令运行项目可忽略以上设置。&lt;/p&gt;
&lt;p&gt;项目运行后的截图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/191097/202007/191097-20200715224827257-1003905483.png&quot; alt=&quot; &quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;你也可以自定义实现 TCP 全双工通讯管道，但比较复杂而且也很少这么做，所以就略过不讲了。但我在 GitHub 的示例代码也放了一个自定义全双工管道实现的示例，感兴趣的话你可以克隆下来研究一下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/191097/202007/191097-20200715224142892-442190843.png&quot; alt=&quot; &quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;该示例运行截图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/191097/202007/191097-20200715223542031-1422704591.png&quot; alt=&quot; &quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;本篇总结&quot;&gt;本篇总结&lt;/h2&gt;
&lt;p&gt;本文通过示例演示了如何使用 StreamJsonRpc 基于 WebSocket 数据传输实现 JSON-RPC 协议的 RPC 通讯。其中客户端和服务端有共同的契约部分，实现了强类型编程。通过示例我们也清楚了 StreamJsonRpc 这个库为了实现 RPC 通讯做了哪些工作，其实它就是在现有传输管道（Stream、WebSocket 和 自定义 TCP 连接）上进行数据通讯。正如前一篇所说，由于 StreamJsonRpc 把大部分我们不必要知道的细节做了封装，所以在示例中感觉不到 JSON-RPC 协议带来的统一规范，也没看到具体的 JSON 格式的数据。其实只要遵循了 JSON-RPC 协议实现的客户端或服务端，不管是用什么语言实现，都是可以互相通讯的。&lt;/p&gt;
&lt;p&gt;希望这三篇关于 StreamJsonRpc 的介绍能让你有所收获，如果你在工作中计划使用 StreamJsonRpc，这几篇文章包括示例代码应该有值得参考的地方。&lt;/p&gt;
</description>
<pubDate>Thu, 16 Jul 2020 00:40:00 +0000</pubDate>
<dc:creator>精致码农</dc:creator>
<og:description>阅读本文大概需要 9 分钟。 大家好，这是 .NET 开源项目 StreamJsonRpc 介绍的最后一篇。上篇介绍了一些预备知识，包括 JSON-RPC 协议介绍，StreamJsonRpc 是一个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/willick/p/13320711.html</dc:identifier>
</item>
<item>
<title>[译]使用DOT语言和GraphvizOnline来可视化你的ASP.NETCore3.0终结点01 - 依乐祝</title>
<link>http://www.cnblogs.com/yilezhu/p/13301981.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yilezhu/p/13301981.html</guid>
<description>&lt;p&gt;这是系列文章中的第一篇：使用GraphvizOnline可视化ASP.NETCore3.0终结点。.&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;第1部分-使用DOT语言来可视化你的ASP.NETCore3.0终结点(本文)&lt;/li&gt;
&lt;li&gt;第2部分-向ASP.NET Core应用程序添加终结点图&lt;/li&gt;
&lt;li&gt;第3部分-使用ImpromptuInterface创建一个自定义的DfaGraphWriter，以便于反射&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;1.2324324324324&quot;&gt;
&lt;p&gt;作者：依乐祝&lt;br/&gt;原文：&lt;a href=&quot;https://andrewlock.net/visualizing-asp-net-core-endpoints-using-graphvizonline-and-the-dot-language/&quot;&gt;https://andrewlock.net/visualizing-asp-net-core-endpoints-using-graphvizonline-and-the-dot-language/&lt;/a&gt;&lt;br/&gt;译文：&lt;a href=&quot;https://www.cnblogs.com/yilezhu/p/13301981.html&quot;&gt;https://www.cnblogs.com/yilezhu/p/13301981.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在这篇文章中，我将展示如何在ASP.NETCore3.0应用程序中使用&lt;a href=&quot;https://dreampuf.github.io/GraphvizOnline&quot;&gt;GraphvizOnline&lt;/a&gt;服务。这使您可以创建如下所示的图表，这些图表描述了应用程序中的所有端点：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1377250/202007/1377250-20200714214912871-1523655150.png&quot; alt=&quot;An example endpoint routing graph&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;用graphvizonline和dot语言绘制图形&quot;&gt;用GraphvizOnline和DOT语言绘制图形&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://dreampuf.github.io/GraphvizOnline&quot;&gt;GraphvizOnline&lt;/a&gt;是一个GitHub上的&lt;a href=&quot;https://github.com/dreampuf/GraphvizOnline&quot;&gt;开源项目&lt;/a&gt;，它为&lt;a href=&quot;https://en.wikipedia.org/wiki/DOT_(graph_description_language)&quot;&gt;DOT图形描述语言&lt;/a&gt; 提供了一个在线可视化工具。这是一种简单的语言，它允许您定义各种类型的图形，它将节点与边连接起来。&lt;/p&gt;
&lt;p&gt;例如，一个基本的&lt;em&gt;无向图&lt;/em&gt;可以定义为&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;graph MyGraph {
  a -- b -- c;
  b -- d;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它描述了以下图表：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1377250/202007/1377250-20200714214913827-1107720432.png&quot; alt=&quot;A simple undirected graph&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每个节点都有一个名称(&lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;, &lt;code&gt;d&lt;/code&gt;)，并且&lt;code&gt;--&lt;/code&gt;定义节点之间的边缘。边定义节点之间的连接，但它们没有方向(因此名称，&lt;em&gt;无向【undirected】&lt;/em&gt;).&lt;/p&gt;
&lt;p&gt;当然，你也可以定义一个&lt;em&gt;有向&lt;/em&gt;图，其中边是有方向的。对于有向边，使用&lt;code&gt;-&amp;gt;&lt;/code&gt;而不是&lt;code&gt;--&lt;/code&gt;。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;digraph MyGraph {
  a -&amp;gt; b -&amp;gt; c;
  d -&amp;gt; b;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它描述了以下图表：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1377250/202007/1377250-20200714214913617-645854220.png&quot; alt=&quot;A simple directed graph&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;您可以自定义节点和边缘以多种方式显示的方式。例如，可以标记节点和边缘：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;digraph MySimpleGraph {
   // The label attribute can be used to change the label of a node...
   a [label=&quot;Foo&quot;];
   b [label=&quot;Bar&quot;];
   // ... or an edge
   a -&amp;gt; b [label=&quot;Baz&quot;];
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1377250/202007/1377250-20200714214913386-1984742219.png&quot; alt=&quot;A labelled graph&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;你可以使用&lt;a href=&quot;https://en.wikipedia.org/wiki/DOT_(graph_description_language)&quot;&gt;DOT图形描述语言&lt;/a&gt;做&lt;a href=&quot;https://www.graphviz.org/doc/info/attrs.html&quot;&gt;更多&lt;/a&gt;的事情，这正是我们现在所需要的。那么，这如何应用于ASP.NET Core应用程序呢？&lt;/p&gt;
&lt;h2 id=&quot;使用有向图来可视化aspnet-core终结点&quot;&gt;使用有向图来可视化ASP.NET Core终结点&lt;/h2&gt;
&lt;p&gt;ASP.NETCore中的终结点路由系统通过创建端点URL段的有向图来有效地工作。然后将传入的请求与图进行匹配（一次一个段），以确定要执行的终结点。&lt;/p&gt;
&lt;p&gt;例如，以下简单有向图表示ASP.NET Core3.0 RazorPages 默认应用程序模板中的终结点(&lt;code&gt;dotnet new webapp&lt;/code&gt;)，其中包含三个Razor页面：&lt;em&gt;Index.cshtml&lt;/em&gt;, &lt;em&gt;Error.cshtml&lt;/em&gt;和&lt;em&gt;Privacy.cshtml&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;digraph DFA {
  1 [label=&quot;/Error/&quot;]
  2 [label=&quot;/Index/&quot;]
  3 [label=&quot;/Privacy/&quot;]
  4 -&amp;gt; 1 [label=&quot;/Error&quot;]
  4 -&amp;gt; 2 [label=&quot;/Index&quot;]
  4 -&amp;gt; 3 [label=&quot;/Privacy&quot;]
  4 [label=&quot;/&quot;]
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中描述为如下图表：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1377250/202007/1377250-20200714214913129-2133100582.png&quot; alt=&quot;A basic Razor Pages application&quot; loading=&quot;lazy&quot;/&gt;.&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;在上面的DOT文件中，节点被赋予顺序的整数名，&lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, &lt;code&gt;3&lt;/code&gt;等，并使用端点名称进行标记。这是ASP.NET Core用于表示终结点图的格式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于Razor页面，路由非常简单，所以图非常明显。ASP.NET Core WebAPI应用程序生成了一个更有趣的图表。例如，下面显示的ASP.NET Core 2.0默认模板中包含的&lt;code&gt;ValuesController&lt;/code&gt;。它使用多个HTTP谓词，以及稍微复杂的URL结构：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;[Route(&quot;api/[controller]&quot;)]
[ApiController]
public class ValuesController : ControllerBase
{
    // GET api/values
    [HttpGet]
    public ActionResult&amp;lt;IEnumerable&amp;lt;string&amp;gt;&amp;gt; Get() =&amp;gt; new string[] { &quot;value1&quot;, &quot;value2&quot; };

    // GET api/values/5
    [HttpGet(&quot;{id}&quot;)]
    public ActionResult&amp;lt;string&amp;gt; Get(int id) =&amp;gt; &quot;value&quot;;

    // POST api/values
    [HttpPost]
    public void Post([FromBody] string value) { }

    // PUT api/values/5
    [HttpPut(&quot;{id}&quot;)]
    public void Put(int id, [FromBody] string value) { }

    // DELETE api/values/5
    [HttpDelete(&quot;{id}&quot;)]
    public void Delete(int id) { }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了更好地度量，我还添加了一个基本的健康检查端点。&lt;code&gt;UseEndpoints()&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;app.UseEndpoints(endpoints =&amp;gt;
{
    endpoints.MapHealthChecks(&quot;/healthz&quot;);
    endpoints.MapControllers();
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此应用程序生成以下图表：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;digraph DFA {
  1 [label=&quot;/healthz/&quot;] 
  2 [label=&quot;/api/Values/{...}/ HTTP: GET&quot;] 
  3 [label=&quot;/api/Values/{...}/ HTTP: PUT&quot;] 
  4 [label=&quot;/api/Values/{...}/ HTTP: DELETE&quot;] 
  5 [label=&quot;/api/Values/{...}/ HTTP: *&quot;] 
  6 -&amp;gt; 2 [label=&quot;HTTP: GET&quot;]
  6 -&amp;gt; 3 [label=&quot;HTTP: PUT&quot;]
  6 -&amp;gt; 4 [label=&quot;HTTP: DELETE&quot;]
  6 -&amp;gt; 5 [label=&quot;HTTP: *&quot;]
  6 [label=&quot;/api/Values/{...}/&quot;] 
  7 [label=&quot;/api/Values/ HTTP: GET&quot;] 
  8 [label=&quot;/api/Values/ HTTP: POST&quot;] 
  9 [label=&quot;/api/Values/ HTTP: *&quot;] 
  10 -&amp;gt; 6 [label=&quot;/*&quot;]
  10 -&amp;gt; 7 [label=&quot;HTTP: GET&quot;]
  10 -&amp;gt; 8 [label=&quot;HTTP: POST&quot;]
  10 -&amp;gt; 9 [label=&quot;HTTP: *&quot;]
  10 [label=&quot;/api/Values/&quot;] 
  11 -&amp;gt; 10 [label=&quot;/Values&quot;]
  11 [label=&quot;/api/&quot;] 
  12 -&amp;gt; 1 [label=&quot;/healthz&quot;]
  12 -&amp;gt; 11 [label=&quot;/api&quot;]
  12 [label=&quot;/&quot;] 
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;表现为如下图表：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1377250/202007/1377250-20200714214912871-1523655150.png&quot; alt=&quot;A ValuesController endpoint routing application&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这个图中还有很多事情要做，因为我们现在有了可变的路由参数值(路由模板中的&lt;code&gt;{id}&lt;/code&gt;，在图中显示为&lt;code&gt;{...}&lt;/code&gt;)和HTTP动词约束(&lt;code&gt;GET&lt;/code&gt;/&lt;code&gt;PUT&lt;/code&gt;/&lt;code&gt;POST&lt;/code&gt;等等)&lt;/p&gt;
&lt;p&gt;当我第一次看到这个图表时，我很难理解它。每个节点都是终结点吗？当然不是，如&lt;code&gt;/api/&lt;/code&gt;不应该产生响应。那这个呢？至于&lt;code&gt;HTTP: *&lt;/code&gt;端点呢，它们会产生响应吗？&lt;/p&gt;
&lt;blockquote readability=&quot;5.3448275862069&quot;&gt;
&lt;p&gt;为了进一步了解，我查阅了&lt;a href=&quot;https://github.com/dotnet/aspnetcore/blob/master/src/Http/Routing/src/Matching/DfaMatcherBuilder.cs&quot;&gt;可以生成这些图的ASP.NET Core中的代码&lt;/a&gt;，但它有点复杂，不幸的是，由于大量使用&lt;code&gt;internal&lt;/code&gt;类。我将在稍后的文章中探讨这些代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为了更好地理解端点图，我们需要了解并非所有的节点都是相同的。在下一节中，我们将深入研究这个简单图中的不同类型的节点，然后研究一个更好的图形表示（至少在我看来！）&lt;/p&gt;
&lt;h2 id=&quot;了解不同类型的节点。&quot;&gt;了解不同类型的节点。&lt;/h2&gt;
&lt;p&gt;图中的每个节点都与给定的“深度”相关联。这是应该已经匹配的URL段数。例如，&lt;code&gt;/api/Values/&lt;/code&gt;节点的深度为2-它要求空段&lt;code&gt;/&lt;/code&gt;和&lt;code&gt;/api&lt;/code&gt;段已经匹配。&lt;/p&gt;
&lt;p&gt;当请求到达&lt;code&gt;EndpointRoutingMiddleware&lt;/code&gt;(由&lt;code&gt;UseRouting()&lt;/code&gt;添加)时，将传入的请求URL与此图进行比较。试图从树梢的根节点开始，通过图表找到一条路径。URL段与图中的边进行增量匹配，并在图中遍历一条路径，直到整个请求URL匹配为止。&lt;/p&gt;
&lt;p&gt;每个节点(由&lt;a href=&quot;https://github.com/dotnet/aspnetcore/blob/cc3d47f5501cdfae3e5b5be509ef2c0fb8cca069/src/Http/Routing/src/Matching/DfaNode.cs&quot;&gt;在ASP.NET Core中的&lt;code&gt;DfaNode&lt;/code&gt;中&lt;/a&gt;)有几个属性。我们目前感兴趣的属性是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Matches&lt;/code&gt;*这是与该节点相关联的&lt;code&gt;Endpoint&lt;/code&gt;(S)。如果通过路由匹配此节点，则这是将被选择用于执行的&lt;code&gt;Endpoint&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Literals&lt;/code&gt;这些是连接节点的边缘。如果&lt;code&gt;DfaNode&lt;/code&gt;有&lt;code&gt;Literals&lt;/code&gt;，它具有可以进一步遍历以到达其他节点的文字段。例如，&lt;code&gt;/api/&lt;/code&gt;节点包含一个有&lt;code&gt;/Values&lt;/code&gt;值的&lt;code&gt;Literal&lt;/code&gt;，则指向&lt;code&gt;/api/Values&lt;/code&gt;节点。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PolicyEdges&lt;/code&gt;这些边缘是基于URL以外的约束进行匹配的。例如，图中基于动词的边，如&lt;code&gt;HTTP: GET&lt;/code&gt;，是策略的边缘，指的是不同的&lt;code&gt;DfaNode&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Parameters&lt;/code&gt;如果节点具有支持路由参数的边缘(例如，&lt;code&gt;{id}&lt;/code&gt;), &lt;code&gt;Parameters&lt;/code&gt;指向处理匹配参数的节点。这在图中是用&lt;code&gt;/*&lt;/code&gt;边表示的。.&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;还有一个附加的属性，&lt;code&gt;CatchAll&lt;/code&gt;，这在某些图形中是相关的，但我现在将忽略它，因为我们的API图并不需要它。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;基于这些特性，我们可以通过使用&lt;a href=&quot;https://www.graphviz.org/doc/info/attrs.html&quot;&gt;DOT语言的其他特性&lt;/a&gt;，如形状、颜色、线型和箭头：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1377250/202007/1377250-20200714214912405-1570561611.png&quot; alt=&quot;A ValuesController endpoint routing application with different styling&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图中添加了以下内容：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;没有任何关联的节点&lt;code&gt;Endpoint&lt;/code&gt;都以默认样式显示，即黑色气泡。&lt;/li&gt;
&lt;li&gt;有&lt;code&gt;Matches&lt;/code&gt;的显示为填充的棕色盒子。这些节点具有&lt;code&gt;Endpoint&lt;/code&gt;，这可以产生响应。对于上面的API示例，这适用于已选择谓词的节点以及健康检查端点。&lt;/li&gt;
&lt;li&gt;文字段边缘显示为默认的黑色边缘，带有一个填充箭头。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Parameters&lt;/code&gt;边缘(&lt;code&gt;/*&lt;/code&gt;)以蓝色显示，使用菱形箭头。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PolicyEdges&lt;/code&gt;以红色显示，带有虚线和空三角形箭头。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;现在，我承认我的设计技巧很烂，但是我认为您可以同意这个图表显示的信息比默认的要多！🙂--这是生成上面的图形的定义，请记住，您可以使用&lt;a href=&quot;https://dreampuf.github.io/GraphvizOnline/&quot;&gt;在线编辑&lt;/a&gt;来可视化和播放显示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;digraph DFA {
  1 [label=&quot;/healthz/&quot; shape=box style=filled color=&quot;brown&quot; fontcolor=&quot;white&quot;]
  2 [label=&quot;/api/Values/{...}/ HTTP: GET&quot; shape=box style=filled color=&quot;brown&quot; fontcolor=&quot;white&quot;]
  3 [label=&quot;/api/Values/{...}/ HTTP: PUT&quot; shape=box style=filled color=&quot;brown&quot; fontcolor=&quot;white&quot;]
  4 [label=&quot;/api/Values/{...}/ HTTP: DELETE&quot; shape=box style=filled color=&quot;brown&quot;  fontcolor=&quot;white&quot;]
  5 [label=&quot;/api/Values/{...}/ HTTP: *&quot; shape=box style=filled color=&quot;brown&quot; fontcolor=&quot;white&quot;]
  6 -&amp;gt; 2 [label=&quot;HTTP: GET&quot; color=&quot;red&quot; style=dashed arrowhead=open]
  6 -&amp;gt; 3 [label=&quot;HTTP: PUT&quot; color=&quot;red&quot; style=dashed arrowhead=open]
  6 -&amp;gt; 4 [label=&quot;HTTP: DELETE&quot; color=&quot;red&quot; style=dashed arrowhead=open]
  6 -&amp;gt; 5 [label=&quot;HTTP: *&quot; color=&quot;red&quot; style=dashed arrowhead=open]
  6 [label=&quot;/api/Values/{...}/&quot;]
  7 [label=&quot;/api/Values/ HTTP: GET&quot; shape=box style=filled color=&quot;brown&quot; fontcolor=&quot;white&quot;]
  8 [label=&quot;/api/Values/ HTTP: POST&quot; shape=box style=filled color=&quot;brown&quot; fontcolor=&quot;white&quot;]
  9 [label=&quot;/api/Values/ HTTP: *&quot; shape=box style=filled color=&quot;brown&quot; fontcolor=&quot;white&quot;]
  10 -&amp;gt; 6 [label=&quot;/*&quot; arrowhead=diamond color=&quot;blue&quot;]
  10 -&amp;gt; 7 [label=&quot;HTTP: GET&quot; color=&quot;red&quot; style=dashed arrowhead=open]
  10 -&amp;gt; 8 [label=&quot;HTTP: POST&quot; color=&quot;red&quot; style=dashed arrowhead=open]
  10 -&amp;gt; 9 [label=&quot;HTTP: *&quot; color=&quot;red&quot; style=dashed arrowhead=open]
  10 [label=&quot;/api/Values/&quot;]
  11 -&amp;gt; 10 [label=&quot;/Values&quot;]
  11 [label=&quot;/api/&quot;]
  12 -&amp;gt; 1 [label=&quot;/healthz&quot;]
  12 -&amp;gt; 11 [label=&quot;/api&quot;]
  12 [label=&quot;/&quot;]
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意&lt;code&gt;&quot;HTTP: *&quot;&lt;/code&gt;节点与端点关联，即使您可能不期望它，因为它们返回&lt;code&gt;405 Method Not Allowed&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在下一篇文章中，我将展示如何自动为自己的ASP.NET Core应用程序生成端点图。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;在这篇文章中，我介绍了用于描述图形的DOT语言，并展示了如何使用&lt;a href=&quot;https://dreampuf.github.io/GraphvizOnline&quot;&gt;在线编辑&lt;/a&gt;从图表中创建图像。然后，我展示了如何将ASP.NETCore 3.x应用程序中的端点路由表示为有向图。我描述了端点图中不同节点和边缘之间的差异，并调整了图形的显示以更好地表示这些差异。在后面的文章中，我将展示如何为应用程序生成自己的端点图，如何自定义显示，以及如何做的不仅仅是查看图形。&lt;/p&gt;
</description>
<pubDate>Thu, 16 Jul 2020 00:30:00 +0000</pubDate>
<dc:creator>依乐祝</dc:creator>
<og:description>这是系列文章中的第一篇：使用GraphvizOnline可视化ASP.NETCore3.0终结点。. 第1部分-使用DOT语言来可视化你的ASP.NETCore3.0终结点(本文) 第2部分-向ASP</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yilezhu/p/13301981.html</dc:identifier>
</item>
<item>
<title>.Net Core微服务入门全纪录（完结）——Ocelot与Swagger - xhznl</title>
<link>http://www.cnblogs.com/xhznl/p/13305767.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xhznl/p/13305767.html</guid>
<description>&lt;p&gt;Tips：本篇已加入&lt;a href=&quot;https://www.cnblogs.com/xhznl/p/13259036.html&quot; target=&quot;_blank&quot;&gt;系列文章阅读目录&lt;/a&gt;，可点击查看更多相关文章。&lt;/p&gt;

&lt;p&gt;上一篇【&lt;a href=&quot;https://www.cnblogs.com/xhznl/p/13268940.html&quot;&gt;.Net Core微服务入门全纪录（八）——Docker Compose与容器网络&lt;/a&gt;】完成了docker-compose.yml文件的编写，最后使用docker compose的一个up指令即可在docker中运行整个复杂的环境。本篇简单介绍一下Ocelot与Swagger的集成，方便在网关项目中统一查看各个服务的api文档。&lt;/p&gt;

&lt;p&gt;首先，网关项目，服务项目 NuGet安装&lt;code&gt;Swashbuckle.AspNetCore&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202007/610959-20200715101033247-1995013261.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;服务项目&quot;&gt;服务项目&lt;/h2&gt;
&lt;p&gt;Order.API项目Startup：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public void ConfigureServices(IServiceCollection services)
{
    services.AddSwaggerGen(c =&amp;gt;
    {
        c.SwaggerDoc(&quot;v1&quot;, new OpenApiInfo { Title = &quot;Order API&quot;, Version = &quot;v1&quot;, Description = &quot;# order service api...&quot; });
        // Set the comments path for the Swagger JSON and UI.
        var xmlFile = $&quot;{Assembly.GetExecutingAssembly().GetName().Name}.xml&quot;;
        var xmlPath = Path.Combine(AppContext.BaseDirectory, xmlFile);
        c.IncludeXmlComments(xmlPath);
        c.AddSecurityDefinition(&quot;Bearer&quot;, new OpenApiSecurityScheme()
        {
            Description = &quot;在下框中输入请求头中需要添加Jwt授权Token：Bearer Token&quot;,
            Name = &quot;Authorization&quot;,
            In = ParameterLocation.Header,
            Type = SecuritySchemeType.ApiKey,
            BearerFormat = &quot;JWT&quot;,
            Scheme = &quot;Bearer&quot;
        });

        c.AddSecurityRequirement(new OpenApiSecurityRequirement
        {
            {
                new OpenApiSecurityScheme{
                    Reference = new OpenApiReference {
                        Type = ReferenceType.SecurityScheme,
                        Id = &quot;Bearer&quot;}
                },new string[] { }
            }
        });
    });

    services.AddControllers();

    ......
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public void Configure(IApplicationBuilder app, IWebHostEnvironment env, IHostApplicationLifetime lifetime, OrderContext orderContext)
{
    ......

    app.UseSwagger();
    app.UseSwaggerUI(c =&amp;gt;
    {
        c.SwaggerEndpoint(&quot;/swagger/v1/swagger.json&quot;, &quot;Order API V1&quot;);
    });

    app.UseRouting();

    ......
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打开项目文件Order.API.csproj，添加生成文档的配置，swagger要用到：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;GenerateDocumentationFile&amp;gt;true&amp;lt;/GenerateDocumentationFile&amp;gt;
&amp;lt;NoWarn&amp;gt;$(NoWarn);1591&amp;lt;/NoWarn&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202007/610959-20200715140427198-1895302198.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Product.API项目也是类似的修改，就不贴了。&lt;/p&gt;
&lt;h2 id=&quot;网关项目&quot;&gt;网关项目&lt;/h2&gt;
&lt;p&gt;然后是Ocelot网关项目的Startup：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public void ConfigureServices(IServiceCollection services)
{
    services.AddSwaggerGen(c =&amp;gt;
    {
        c.SwaggerDoc(&quot;v1&quot;,
            new OpenApiInfo {Title = &quot;Gateway API&quot;, Version = &quot;v1&quot;, Description = &quot;# gateway api...&quot;});
    });

    services.AddControllers();

    ......
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
{
    app.UseSwagger();
    app.UseSwaggerUI(c =&amp;gt;
    {
        c.SwaggerEndpoint(&quot;/order/swagger/v1/swagger.json&quot;, &quot;Order API V1&quot;);
        c.SwaggerEndpoint(&quot;/product/swagger/v1/swagger.json&quot;, &quot;Product API V1&quot;);
    });

    //设置Ocelot中间件
    app.UseOcelot().Wait();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ocelot.json配置文件，Routes节点下增加2个路由配置，不做授权，限流，熔断等限制：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;{
  &quot;DownstreamPathTemplate&quot;: &quot;/swagger/v1/swagger.json&quot;,
  &quot;DownstreamScheme&quot;: &quot;http&quot;,
  &quot;UpstreamPathTemplate&quot;: &quot;/product/swagger/v1/swagger.json&quot;,
  &quot;UpstreamHttpMethod&quot;: [ &quot;Get&quot; ],
  &quot;ServiceName&quot;: &quot;ProductService&quot;,
  &quot;LoadBalancerOptions&quot;: {
    &quot;Type&quot;: &quot;RoundRobin&quot;
  }
},
{
  &quot;DownstreamPathTemplate&quot;: &quot;/swagger/v1/swagger.json&quot;,
  &quot;DownstreamScheme&quot;: &quot;http&quot;,
  &quot;UpstreamPathTemplate&quot;: &quot;/order/swagger/v1/swagger.json&quot;,
  &quot;UpstreamHttpMethod&quot;: [ &quot;Get&quot; ],
  &quot;ServiceName&quot;: &quot;OrderService&quot;,
  &quot;LoadBalancerOptions&quot;: {
    &quot;Type&quot;: &quot;RoundRobin&quot;
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;运行测试&quot;&gt;运行测试&lt;/h2&gt;
&lt;p&gt;使用docker-compose build：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202007/610959-20200715141738081-807649742.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;build完成后启动：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202007/610959-20200715141812247-907876642.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;浏览器访问网关项目：&lt;a href=&quot;http://localhost:9070/swagger&quot;&gt;http://localhost:9070/swagger&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202007/610959-20200715142132398-1619949664.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接口测试：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202007/610959-20200715142446759-641899842.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时因为没有授权所以返回401，为了方便获取token，我在IDS4.AuthCenter项目增加了一个客户端配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;new Client
{
    ClientId = &quot;postman client&quot;,
    ClientName = &quot;Postman Client&quot;,

    AllowedGrantTypes = GrantTypes.ClientCredentials,
    ClientSecrets = { new Secret(&quot;postman client secret&quot;.Sha256()) },

    AllowedScopes = new [] {&quot;orderApiScope&quot;, &quot;productApiScope&quot;},
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用postman获取token：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202007/610959-20200715143128615-939765931.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;拿到token填入文本框，格式是Bearer xxxxxx，注意空格。这里的提示文字乱码了，应该是在docker中运行的原因，这个不影响先不管他。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202007/610959-20200715143328545-1483362985.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;填入token后再次请求接口，就可以正常返回了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202007/610959-20200715143813223-1885532782.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，Ocelot与Swagger的集成就完成了。本篇内容比较简单，swagger应该大部分人都用过。&lt;/p&gt;

&lt;p&gt;这个系列博客就到此结束了，本来也就是入门级别的。再往后可能就是更深入的服务治理，比如日志、监控、链路追踪等；服务的持续集成、持续部署；容器编排（k8s）；服务网格（Service Mesh）等等。。。这些都不属于入门的范围了。&lt;/p&gt;
&lt;p&gt;当然，不是每个公司都适合k8s，也不是每个项目都要做微服务。为了盲目推崇某个技术而去使用它时，它便失去了原本的价值。技术本不分高低，适合自己的就是最好的。感谢关注我的小伙伴们。。。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;推荐几个学习入口：&lt;br/&gt;&lt;a href=&quot;https://space.bilibili.com/361469957/&quot;&gt;https://space.bilibili.com/361469957/&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://space.bilibili.com/431596483/&quot;&gt;https://space.bilibili.com/431596483/&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://github.com/dotnet-architecture/eShopOnContainers&quot;&gt;https://github.com/dotnet-architecture/eShopOnContainers&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://docs.microsoft.com/&quot;&gt;https://docs.microsoft.com/&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 16 Jul 2020 00:20:00 +0000</pubDate>
<dc:creator>xhznl</dc:creator>
<og:description>Tips：本篇已加入系列文章阅读目录，可点击查看更多相关文章。 前言 上一篇【.Net Core微服务入门全纪录（八）——Docker Compose与容器网络】完成了docker-compose.y</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xhznl/p/13305767.html</dc:identifier>
</item>
<item>
<title>Flutter 快捷开发 Mac Android Studio 篇 - 老孟Flutter</title>
<link>http://www.cnblogs.com/mengqd/p/13320641.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mengqd/p/13320641.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200716072416321-1369196971.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;4.280487804878&quot;&gt;
&lt;p&gt;老孟导读：此快捷方式适用于Mac下的 Android Studio 。Windows 下的快捷方式请参考这篇文章：&lt;a href=&quot;https://juejin.im/post/5efe71365188252e7d7fd0ca&quot;&gt;https://juejin.im/post/5efe71365188252e7d7fd0ca&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;快速创建一个新的stateless-or-stateful组件&quot;&gt;快速创建一个新的Stateless or Stateful组件&lt;/h3&gt;
&lt;p&gt;创建新的 Stateless 组件，输入stless，回车：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200716072416794-1158056129.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;创建新的 Stateful 组件，输入 stful，回车：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200716072417154-1587405525.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;创建新的 动画组件，输入 stanim，回车：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200716072417461-358360686.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还有其他的一些快捷方式，这里不一一介绍，这些快捷方式在 &lt;strong&gt;Preferences&lt;/strong&gt; 中可以找到，路径：Preferences -&amp;gt; Editor -&amp;gt; Live Templates:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200716072417835-756910151.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Dart 和 Flutter 下就是快捷方式，也可以进行修改，上面我的快捷方式直接导入包和注释，是自己加的，默认是没有的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200716072418596-1141512837.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;自定义快捷键，选中 Flutter，点击右上角的 &lt;strong&gt;+&lt;/strong&gt; 号，选择 Live Template，然后输入名称和生成的代码，点击 &lt;strong&gt;OK&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200716072418921-1844245099.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最低部会出现警告，选中 Dart ，点击 OK。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200716072419222-1592800041.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用的方法是一样的，输入 test，回车即可。&lt;/p&gt;
&lt;h3 id=&quot;file-and-code-templates&quot;&gt;File And Code Templates&lt;/h3&gt;
&lt;p&gt;创建 Dart 文件时，生成默认代码，打开 Preferences -&amp;gt; Editor -&amp;gt; File And Code Templates，选中右侧的 Files 标签，默认里面是空的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200716072419445-1973265751.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;加入自动生成代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;import 'package:flutter/material.dart';

///
/// des:
///
class ${NAME} extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Container();
  }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200716072419675-569298730.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;创建一个 home_page 的 dart 文件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200716072419955-1655326514.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;新创建的 dart 文件自动生成了预置的代码。&lt;/p&gt;
&lt;h3 id=&quot;格式化代码&quot;&gt;格式化代码&lt;/h3&gt;
&lt;p&gt;快捷键：option + command + L（字母 L 键）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200716072420227-144247190.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;清除无用引用&quot;&gt;清除无用引用&lt;/h3&gt;
&lt;p&gt;快捷键：control + option + O（字母 O 键）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200716072420473-1868397000.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;前进后退光标的位置&quot;&gt;前进/后退光标的位置&lt;/h3&gt;
&lt;p&gt;当跟踪代码的时候，经常跳转到其他类，后退快捷键：option+command+方向左键，前进快捷键：option+command+方向右键，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200716072421258-138501585.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;查看当前类的继承关系&quot;&gt;查看当前类的继承关系&lt;/h3&gt;
&lt;p&gt;快捷键： control + H&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200716072421674-49898877.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：选中 build 中 Container ，按快捷键无效，必须进入 Container 源代码，选中 Container 类名，才可以。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;注释&quot;&gt;注释&lt;/h3&gt;
&lt;p&gt;单行注释：command + / 。&lt;/p&gt;
&lt;p&gt;多行注释/**/：option + command + / 或者选中多行 ：command + /&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200716072422342-1115250399.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;查找引用&quot;&gt;查找引用&lt;/h3&gt;
&lt;p&gt;选中要查找的类或者方法，按下快捷键：command + G，底部弹出引用列表。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200716072422743-60109253.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;自动引入包&quot;&gt;自动引入包&lt;/h3&gt;
&lt;p&gt;快捷键：option + 回车，选择正确的包。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200716072423004-1120885309.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;自动定位&quot;&gt;自动定位&lt;/h3&gt;
&lt;p&gt;右侧进入一个代码文件时，左侧自定定位到此文件，在 project 标签 设置中勾选 Autoscroll to source 和 Autoscroll from source。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200716072423202-1068119381.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意左侧 project 标签变化。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200716072423533-375781048.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;当前文件搜索&quot;&gt;当前文件搜索&lt;/h3&gt;
&lt;p&gt;快捷键： command + F&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200716072423765-1661274111.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;全局搜索&quot;&gt;全局搜索&lt;/h3&gt;
&lt;p&gt;快捷键：command + shift + F&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200716072423925-159500341.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;搜索文件：&quot;&gt;搜索文件：&lt;/h3&gt;
&lt;p&gt;快捷键：点击2次 shift&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200716072424142-140318151.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;自动生成构造函数：&quot;&gt;自动生成构造函数：&lt;/h3&gt;
&lt;p&gt;选中 final 参数，快捷键：option + 回车&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200716072424511-237765495.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;添加父组件、变为子组件、删除子组件&quot;&gt;添加父组件、变为子组件、删除子组件&lt;/h3&gt;
&lt;p&gt;快捷键： option+回车&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200716072429272-1676272846.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以给当前组件添加 &lt;strong&gt;Center&lt;/strong&gt;、 &lt;strong&gt;Padding&lt;/strong&gt;、&lt;strong&gt;Column&lt;/strong&gt; 等父组件。&lt;/p&gt;
&lt;p&gt;也可以选择组件进行删除、移动组件。&lt;/p&gt;
&lt;h3 id=&quot;查看ui大纲&quot;&gt;查看UI大纲&lt;/h3&gt;
&lt;p&gt;打开 &lt;strong&gt;Flutter Outline&lt;/strong&gt; 标签&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200716072429622-506375342.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以清楚的看清 UI 结构。&lt;/p&gt;
&lt;h3 id=&quot;将代码提取到方法中&quot;&gt;将代码提取到方法中&lt;/h3&gt;
&lt;p&gt;打开 &lt;strong&gt;Flutter Outline&lt;/strong&gt; 标签，点击向右箭头的图标：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200716072430234-1727585758.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;flutter-资源网站&quot;&gt;Flutter 资源网站&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;官网：&lt;a href=&quot;https://flutter.dev/&quot;&gt;https://flutter.dev/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;中文网：&lt;a href=&quot;https://flutterchina.club/&quot;&gt;https://flutterchina.club/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Flutter 中文社区资源：&lt;a href=&quot;https://flutter-io.cn/&quot;&gt;https://flutter-io.cn/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;pub(国内)：&lt;a href=&quot;https://pub.flutter-io.cn/&quot;&gt;https://pub.flutter-io.cn/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;pub：&lt;a href=&quot;https://pub.dev/&quot;&gt;https://pub.dev/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;DartPad：&lt;a href=&quot;https://dartpad.dartlang.org/&quot;&gt;https://dartpad.dartlang.org/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Dart 官网：&lt;a href=&quot;https://dart.dev/&quot;&gt;https://dart.dev/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;CodePen：&lt;a href=&quot;https://codepen.io/&quot;&gt;https://codepen.io/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Json 转实体类：&lt;a href=&quot;https://javiercbk.github.io/json_to_dart/&quot;&gt;https://javiercbk.github.io/json_to_dart/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;最后隆重推荐一下我的博客：&lt;a href=&quot;http://laomengit.com/flutter/widgets/widgets_structure.html&quot;&gt;http://laomengit.com/flutter/widgets/widgets_structure.html&lt;/a&gt;，包含了 330 个组件详细用法和 Flutter 实战系列文章。&lt;/p&gt;
&lt;h2 id=&quot;交流&quot;&gt;交流&lt;/h2&gt;
&lt;p&gt;老孟Flutter博客地址（330个控件用法）：&lt;a href=&quot;http://laomengit.com&quot;&gt;http://laomengit.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎加入Flutter交流群（微信：laomengit）、关注公众号【老孟Flutter】：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th/&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200716072430976-1013436672.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200716072431887-1440468136.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</description>
<pubDate>Wed, 15 Jul 2020 23:25:00 +0000</pubDate>
<dc:creator>老孟Flutter</dc:creator>
<og:description>老孟导读：此快捷方式适用于Mac下的 Android Studio 。Windows 下的快捷方式请参考这篇文章：https://juejin.im/post/5efe71365188252e7d7f</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mengqd/p/13320641.html</dc:identifier>
</item>
<item>
<title>Babel：下一代Javascript语法编译器 - 丰臣正一</title>
<link>http://www.cnblogs.com/cnroadbridge/p/13311360.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cnroadbridge/p/13311360.html</guid>
<description>&lt;h2 id=&quot;定义&quot;&gt;定义&lt;/h2&gt;
&lt;p&gt;Babel是一个Javascript的编译器，通过它你可以将一些新版本的ECMAScript语法转换成低版本的语法。以便能够在低版本的浏览器或者其它环境平稳运行。&lt;/p&gt;
&lt;p&gt;截至目前笔者写这篇文章的时候，babel的版本是7.10.0&lt;/p&gt;
&lt;h2 id=&quot;实践&quot;&gt;实践&lt;/h2&gt;
&lt;h3 id=&quot;第一步：创建项目&quot;&gt;第一步：创建项目&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;mkdir babel-study &amp;amp;&amp;amp; cd babel-study&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;第二步：初始化项目，并安装相关依赖包&quot;&gt;第二步：初始化项目，并安装相关依赖包&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;npm init -y&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;npm i @babel/cli @babel/core @babel/preset-env --save-dev&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;相关依赖包说明：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;@babel/cli: hello，你好，我是脚手架工具，我可以通过一些命令将源文件编译成目标代码。&lt;/p&gt;
&lt;p&gt;@babel/core: hello，你好，我是一个代码分析选手，我负责将代码分析称ast，方便其他插件进行相关处理。&lt;/p&gt;
&lt;p&gt;@babel/preset-env: hello，你好，我是一个语法转义器，我负责的内容是将JS的相关语法进行编译，关于转义新增的API和全局对象这个我不负责的。&lt;/p&gt;
&lt;h3 id=&quot;第三步：配置babelrc&quot;&gt;第三步：配置.babelrc&lt;/h3&gt;
&lt;p&gt;楼下这几位就是常用的babel配置参数了，这里做简要介绍&lt;/p&gt;
&lt;h4 id=&quot;presets预设&quot;&gt;presets(预设)&lt;/h4&gt;
&lt;p&gt;早期的版本其实是引入类似&lt;code&gt;babel-preset-x&lt;/code&gt;,这种形式的包，现在官方推荐统一用&lt;code&gt;@babel/preset-env&lt;/code&gt;,这个包来做语法转义器这部分的工作。&lt;/p&gt;
&lt;h4 id=&quot;plugins插件&quot;&gt;plugins(插件)&lt;/h4&gt;
&lt;p&gt;弥补babel本身上的功能不足，比如转义新增的API和全局对象可能就需要用到一些新的插件来做这部分工作，我们称之为补丁转义器。&lt;/p&gt;
&lt;h4 id=&quot;ignore忽略&quot;&gt;ignore(忽略)&lt;/h4&gt;
&lt;p&gt;把不需要babel编译的文件写配置到这个参数里面，是一个数组的形式。&lt;/p&gt;
&lt;h4 id=&quot;minified（压缩）&quot;&gt;minified（压缩）&lt;/h4&gt;
&lt;p&gt;Boolean类型的，将其设置为true后，编译后的文件会被压缩。&lt;/p&gt;

&lt;p&gt;Boolean类型的，将其设置为true后，编译后的文件会有注释（你项目开发中写的注释）。&lt;/p&gt;
&lt;h4 id=&quot;env环境变量&quot;&gt;env(环境变量)&lt;/h4&gt;
&lt;p&gt;babel运行的环境变量，如果设置了&lt;code&gt;BABEL_ENV&lt;/code&gt;则使用它，如果没有设置，它会去找有没有&lt;code&gt;NODE_ENV&lt;/code&gt;，如果还是没有，那就是走默认&lt;code&gt;development&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这里附上一份我调研后的配置文件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
  &quot;presets&quot;: [[
    &quot;@babel/preset-env&quot;, {
      // &quot;modules&quot;: false,
      &quot;corejs&quot;: &quot;3&quot;, 
      &quot;useBuiltIns&quot;: &quot;usage&quot;,
      &quot;targets&quot;: {
        &quot;node&quot;: &quot;4&quot;
        // &quot;browsers&quot;: [&quot;last 2 versions&quot;]
      }
    }
  ]],
  &quot;plugins&quot;: [&quot;@babel/plugin-transform-runtime&quot;],
  &quot;env&quot;: {
    &quot;test&quot;: {
      &quot;presets&quot;: [[
        &quot;@babel/preset-env&quot;, {
          &quot;modules&quot;: false,
          &quot;targets&quot;: {
            &quot;node&quot;: &quot;current&quot;,
            // &quot;chrome&quot;: &quot;83&quot;,
            // &quot;edge&quot;: &quot;17&quot;,
            // &quot;firefox&quot;: &quot;68&quot;,
            // &quot;ie&quot;: &quot;11&quot;,
            // &quot;ios&quot;: &quot;11.3&quot;,
            // &quot;safari&quot;: &quot;5.1&quot;,
            // &quot;samsung&quot;: &quot;9.2&quot;,
            &quot;browsers&quot;: [&quot;last 2 versions&quot;]
          }
        }
      ]],
      &quot;minified&quot;: true,  
      &quot;comments&quot;: true,
      &quot;ignore&quot;: [&quot;./src/test.js&quot;]
    },
    &quot;development&quot;: {
      &quot;presets&quot;: [[
        &quot;@babel/preset-env&quot;, {
          &quot;targets&quot;: {
            &quot;browsers&quot;: [&quot;last 2 versions&quot;, &quot;safari 7&quot;]
          }
        }
      ]]
    },
    &quot;production&quot;: {
      &quot;presets&quot;: [[
        &quot;@babel/preset-env&quot;, {
          &quot;targets&quot;: {
            &quot;browsers&quot;: [&quot;&amp;gt; 1%&quot;, &quot;last 2 versions&quot;, &quot;not ie &amp;lt;= 8&quot;]
          }
        }
      ]],
      &quot;plugins&quot;: [&quot;@babel/runtime&quot;],
      &quot;minified&quot;: true,  
      &quot;comments&quot;: true
    }
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里简要说明下，modules默认为true的，在node的环境下（支持COMMONJS），如果使用ES Module的语法（import、export），然后将其设置为false，你会发现入口文件没有被编译，所有这里把它去掉了。然后targets下面你可以单独设置相关环境的支持版本，browsers的优先级高于其他的。babel7.4.0以后，废弃了polyfill，需要单独安装core-js&lt;/p&gt;
&lt;h3 id=&quot;第四步：编写相关测试代码&quot;&gt;第四步：编写相关测试代码&lt;/h3&gt;
&lt;p&gt;这里我们测试下ES Module写法，然后一些新的API的转义情况,比如数组的include，箭头函数、模板字符串、Promise等，这里我们不考虑相关的写法是不是冗余，单纯地就是为了测试下编译效果。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;animal.js&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Animal {
  constructor(name) {
    this.name = name;
  }

  eat() {
    console.log(`${this.name} is eating!`);
  }
}

export default Animal;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;person.js&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import Animal from './animal';

class Person extends Animal {
  constructor(name, sex) {
    super(name);
    this.name = name;
    this.sex = sex;
    this.sexMap = new Map([[1, '男'], [0, '女']]);
  }

  sing() {
    console.log(`${this.name} is singing!`);
  }

  getSex() {
    if (![0, 1].includes(this.sex)) {
      return false;
    } else {
      return this.sexMap.get(this.sex);
    }
  }

  testArr(arr) {
    return arr.map(item =&amp;gt; item * 2);
  }

  testPromise() {
    return new Promise((resolve, reject) =&amp;gt; {
      setTimeout(() =&amp;gt; {
        resolve(2020);
      }, 2000);
    });
  }
}

export default Person;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;index.js&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import Person from './person';
// 我就是试试
let ataola = new Person('ataola', 1);
ataola.eat();
ataola.sing();
const sex = ataola.getSex();
console.log(sex);
let testArr = ataola.testArr([0, 1, 2]);
console.log(testArr);
ataola.testPromise().then(res =&amp;gt; {
  console.log(res);
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;第五步：babel-cli的使用&quot;&gt;第五步：babel-cli的使用&lt;/h3&gt;
&lt;h4 id=&quot;编译项目文件&quot;&gt;编译项目文件&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;# 单纯执行, 它会在控制台打出编译后的信息
babel index.js

# 完整写法
babel index.js --out-file bundle.js
# 简写形式
babel index.js -o bundle.js
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;编译项目文件夹&quot;&gt;编译项目文件夹&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;# 完整写法
babel src -out-dir dist
# 简写形式
babel src -d dist
# 生成sourc map文件
babel src -d dist -s
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;babel-node&quot;&gt;babel-node&lt;/h4&gt;
&lt;p&gt;babel-cli天然自带了一个babel-node的命令，拆分一下也就是babel + node，提供了一个支持ES6的REPL环境，你可以这么玩。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 直接进到这个环境
babel-node

# 直接执行这个文件的代码
babel-node index.js
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后附上我的测试脚本&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; ...
 &quot;scripts&quot;: {
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;amp;&amp;amp; exit 1&quot;,
    &quot;build:dir&quot;: &quot;babel src -d dist&quot;,
    &quot;build:dir:prod&quot;: &quot;cross-env BABEL_ENV=production babel src -d dist&quot;,
    &quot;build:dir:dev&quot;: &quot;cross-env BABEL_ENV=development babel src -d dist&quot;,
    &quot;build:dir:test&quot;: &quot;cross-env BABEL_ENV=test babel src -d dist&quot;,
    &quot;build:dir:s&quot;: &quot;babel src -d dist -s&quot;,
    &quot;build:file&quot;: &quot;babel ./test/babel_core.test.js -o bundle.js&quot;
  },
  ...
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;项目地址：&lt;/strong&gt; &lt;a href=&quot;https://github.com/ataola/JavaScript-Tsukuki/tree/master/code/babel-study&quot;&gt;https://github.com/ataola/JavaScript-Tsukuki/tree/master/code/babel-study&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;问题思考&quot;&gt;问题思考&lt;/h2&gt;
&lt;h3 id=&quot;在项目中使用babel，它的作用是什么？或者这么说它的意义何在？&quot;&gt;在项目中使用Babel，它的作用是什么？或者这么说它的意义何在？&lt;/h3&gt;
&lt;p&gt;将高版本的JS语法转换成低版本的JS语法，可兼容不同版本的浏览器或者运行环境，划重点，解决了代码在不同版本的浏览器的兼容性问题。人的脑容量都是有限的，兼容的事情就愉快地交给它吧。&lt;/p&gt;
&lt;h3 id=&quot;使用babel后，把源代码编译成更复杂更难懂一坨坨的东西，我为什么要去用它？&quot;&gt;使用Babel后，把源代码编译成更复杂更难懂一坨坨的东西，我为什么要去用它？&lt;/h3&gt;
&lt;p&gt;首先，这绝对不是为了装逼，也不是为了混淆代码。我们先思考下使用高版本的语法它有什么用？有一些其实是低版本的语法糖，使用了这些我们可以减少代码量，然后减轻维护成本。但是ECMAScript它是一个语法标准，不同的JS引擎以及浏览器对它的实现和支持又不大一样，所有我们不能够保证使用高版本的语法它能够完美在各平台运行，这也就是babel的作用体现。&lt;/p&gt;
&lt;h3 id=&quot;es的语法有那么多版本，babel的配置有那么多个版本，我该怎么去选择呢？&quot;&gt;ES的语法有那么多版本，Babel的配置有那么多个版本，我该怎么去选择呢？&lt;/h3&gt;
&lt;p&gt;早期地预设有babel-preset-es2015、babel-preset-stage-x之类的啥的，现在官方推荐统一@babel/preset-env,脚手架统一@babel/cli,对，不成文地规定就是@babel打头基本是对的，polyfill除外。&lt;/p&gt;
&lt;h3 id=&quot;babelxxx和-babel-xxx的，为什么会有两种，该用哪个？&quot;&gt;@babel/xxx和 babel-xxx的，为什么会有两种，该用哪个？&lt;/h3&gt;
&lt;p&gt;先说结论，用前者@babel/xxx, @xxx就相当于注册了一个命名空间，特指这个是xxx下的某包，它是一个范围，是一种组织的体现形式，例如@ataola/zjt,&lt;/p&gt;
&lt;h3 id=&quot;babelrc文件我不写行不行，能运行吗？&quot;&gt;.babelrc文件我不写行不行，能运行吗？&lt;/h3&gt;
&lt;p&gt;如果只是创建一个.babelrc里面什么都不写，会报错，因为babel会读取里面的格式，加个&lt;code&gt;{}&lt;/code&gt;，这个是可以运行的，里面什么都不写。这里思考下babel的默认行为是什么？只是转换了Javascript的语法，而不对新的API进行转换，新的还是要用插件的。&lt;/p&gt;
&lt;h3 id=&quot;什么是语法转义器，什么是补丁转义器？&quot;&gt;什么是语法转义器，什么是补丁转义器？&lt;/h3&gt;
&lt;p&gt;在presets里的形如@babel/preset-env就是语法转义器，在plugins下的插件包就是补丁转义器，它们的分工不同，前者是将相关语法进行编译，后者弥补了前者的一些不足，故称之为补丁。&lt;/p&gt;
&lt;h3 id=&quot;targets里设置browsers的优先级高，还是直接设置浏览器的优先级高？&quot;&gt;targets里设置browsers的优先级高，还是直接设置浏览器的优先级高？&lt;/h3&gt;
&lt;p&gt;设置browsers的优先级高于直接设置浏览器的，会覆盖后者。&lt;/p&gt;
&lt;h3 id=&quot;为什么将modules设置成false，是否还有其他设置方案？&quot;&gt;为什么将modules设置成false，是否还有其他设置方案？&lt;/h3&gt;
&lt;p&gt;说明其默认为true，默认都是支持commonjs规范的。还可以设置成amd、umd之类的。&lt;/p&gt;
&lt;h3 id=&quot;transform-runtime解决了一个什么问题？&quot;&gt;transform-runtime解决了一个什么问题？&lt;/h3&gt;
&lt;p&gt;解决了es6语法中全局对象或者全局对象方法编译不足的情况。&lt;/p&gt;
&lt;h3 id=&quot;既然transform-runtime只是解决es6，那我要是用es7、es8、es9甚至更高怎么办呢？&quot;&gt;既然transform-runtime只是解决es6，那我要是用es7、es8、es9甚至更高怎么办呢？&lt;/h3&gt;
&lt;p&gt;&lt;s&gt;babel-polyfill&lt;/s&gt; , core-js、regenerator-runtime&lt;/p&gt;
&lt;h3 id=&quot;为什么不推荐全局安装脚手架？&quot;&gt;为什么不推荐全局安装脚手架？&lt;/h3&gt;
&lt;p&gt;版本更新迭代太快了，安装在项目本地易升级。&lt;/p&gt;
&lt;h3 id=&quot;babel_env或者node_env的设置方式&quot;&gt;BABEL_ENV或者NODE_ENV的设置方式&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;# osx|linux
export NODE_ENV=production

#window
SET NODE_ENV=production
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;babel的默认行为是什么？&quot;&gt;Babel的默认行为是什么？&lt;/h3&gt;
&lt;p&gt;转换了形如let、箭头函数之类的语法， 如果要完全的ES6语法支持需要安装plugin-transform-runtime插件，如果需要更高版本的话，那就需要安装polyfill插件。&lt;/p&gt;
&lt;h2 id=&quot;参考文献&quot;&gt;参考文献&lt;/h2&gt;
&lt;p&gt;babel官网：&lt;a href=&quot;https://babeljs.io/&quot;&gt;https://babeljs.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;@babel/preset-env文档：&lt;a href=&quot;https://babeljs.io/docs/en/babel-preset-env/&quot;&gt;https://babeljs.io/docs/en/babel-preset-env/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;@babel/plugin-transform-runtime:&lt;a href=&quot;https://babeljs.io/docs/en/next/babel-plugin-transform-runtime.html&quot;&gt;https://babeljs.io/docs/en/next/babel-plugin-transform-runtime.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;@babel/cli文档：&lt;a href=&quot;https://babeljs.io/docs/en/babel-cli&quot;&gt;https://babeljs.io/docs/en/babel-cli&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;babel配置文件：&lt;a href=&quot;https://babeljs.io/docs/en/config-files#file-relative-configuration&quot;&gt;https://babeljs.io/docs/en/config-files#file-relative-configuration&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;babel环境变量配置：&lt;a href=&quot;https://babeljs.io/docs/en/options#envname&quot;&gt;https://babeljs.io/docs/en/options#envname&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;@xxx npm包的解释 About Scope: &lt;a href=&quot;https://docs.npmjs.com/about-scopes&quot;&gt;https://docs.npmjs.com/about-scopes&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by-nc-sa/4.0/&quot;&gt;&lt;img alt=&quot;知识共享许可协议&quot; src=&quot;https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png&quot;/&gt;&lt;/a&gt;&lt;br/&gt;本作品采用&lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by-nc-sa/4.0/&quot;&gt;知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议&lt;/a&gt;进行许可。&lt;/p&gt;
</description>
<pubDate>Wed, 15 Jul 2020 16:28:00 +0000</pubDate>
<dc:creator>丰臣正一</dc:creator>
<og:description>定义 Babel是一个Javascript的编译器，通过它你可以将一些新版本的ECMAScript语法转换成低版本的语法。以便能够在低版本的浏览器或者其它环境平稳运行。 截至目前笔者写这篇文章的时候，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cnroadbridge/p/13311360.html</dc:identifier>
</item>
<item>
<title>上亿数据怎么玩深度分页？兼容MySQL + ES + MongoDB - Super-Kerwin</title>
<link>http://www.cnblogs.com/kkzhilu/p/13311250.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kkzhilu/p/13311250.html</guid>
<description>&lt;h2 id=&quot;面试题--真实经历&quot;&gt;面试题 &amp;amp; 真实经历&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;面试题：&lt;/strong&gt;&lt;/em&gt;在数据量很大的情况下，怎么实现深度分页？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;大家在面试时，或者准备面试中可能会遇到上述的问题，大多的回答基本上是&lt;code&gt;分库分表建索引&lt;/code&gt;，这是一种很&lt;code&gt;标准的正确回答&lt;/code&gt;，但现实总是很骨感，所以面试官一般会追问你一句，&lt;span&gt;现在工期不足，人员不足，该怎么实现深度分页？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这个时候没有实际经验的同学基本麻爪，So，请听我娓娓道来。&lt;/p&gt;
&lt;h2 id=&quot;惨痛的教训&quot;&gt;惨痛的教训&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;首先必须明确一点：&lt;/strong&gt;&lt;/em&gt;深度分页可以做，但是&lt;span&gt;深度随机跳页绝对需要禁止。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;上一张图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC83LzE1LzE3MzRlNDA4MzAxMzA5NWY?x-oss-process=image/format,png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;你们猜，我点一下第&lt;code&gt;142360&lt;/code&gt;页，服务会不会爆炸？&lt;/p&gt;
&lt;p&gt;像&lt;code&gt;MySQL&lt;/code&gt;，&lt;code&gt;MongoDB&lt;/code&gt;数据库还好，本身就是专业的数据库，处理的不好，最多就是慢，但如果涉及到&lt;code&gt;ES&lt;/code&gt;，性质就不一样了，我们不得不利用 &lt;code&gt;SearchAfter&lt;/code&gt; Api，去循环获取数据，这就牵扯到内存占用的问题，如果当时代码写的不优雅，直接就可能导致内存溢出。&lt;/p&gt;
&lt;h2 id=&quot;为什么不能允许随机深度跳页&quot;&gt;为什么不能允许随机深度跳页&lt;/h2&gt;
&lt;p&gt;从技术的角度浅显的聊一聊为什么不能允许随机深度跳页，或者说为什么不建议深度分页&lt;/p&gt;
&lt;h3 id=&quot;mysql&quot;&gt;MySQL&lt;/h3&gt;
&lt;p&gt;分页的基本原理：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;SELECT * FROM test ORDER BY id DESC LIMIT 10000, 20;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;LIMIT 10000 , 20的意思扫描满足条件的10020行，扔掉前面的10000行，返回最后的20行。如果是LIMIT 1000000 , 100，需要扫描1000100 行，在一个高并发的应用里，每次查询需要扫描超过100W行，不炸才怪。&lt;/p&gt;
&lt;h3 id=&quot;mongodb&quot;&gt;MongoDB&lt;/h3&gt;
&lt;p&gt;分页的基本原理：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;db.t_data.find().limit(5).skip(5);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同样的，随着页码的增大，skip 跳过的条目也会随之变大，而这个操作是通过 cursor 的迭代器来实现的，对于cpu的消耗会非常明显，当页码非常大时且频繁时，必然爆炸。&lt;/p&gt;
&lt;h3 id=&quot;elasticsearch&quot;&gt;ElasticSearch&lt;/h3&gt;
&lt;p&gt;从业务的角度来说，&lt;code&gt;ElasticSearch&lt;/code&gt;不是典型的数据库，它是一个搜索引擎，如果在筛选条件下没有搜索出想要的数据，继续深度分页也不会找到想要的数据，退一步讲，假如我们把&lt;code&gt;ES&lt;/code&gt;作为数据库来使用进行查询，在进行分页的时候一定会遇到&lt;code&gt;max_result_window&lt;/code&gt; 的限制，看到没，官方都告诉你最大偏移量限制是一万。&lt;/p&gt;
&lt;p&gt;查询流程：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如查询第501页，每页10条，客户端发送请求到某节点&lt;/li&gt;
&lt;li&gt;此节点将数据广播到各个分片，各分片各自查询前 5010 条数据&lt;/li&gt;
&lt;li&gt;查询结果返回至该节点，然后对数据进行整合，取出前 5010 条数据&lt;/li&gt;
&lt;li&gt;返回给客户端&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;由此可以看出为什么要限制偏移量，另外，如果使用 &lt;code&gt;Search After&lt;/code&gt; 这种滚动式API进行深度跳页查询，也是一样需要每次滚动几千条，可能一共需要滚动上百万，千万条数据，就为了最后的20条数据，效率可想而知。&lt;/p&gt;
&lt;h2 id=&quot;再次和产品对线&quot;&gt;再次和产品对线&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;俗话说的好，技术解决不了的问题，就由业务来解决！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在实习的时候信了产品的邪，必须实现深度分页 + 跳页，如今必须&lt;code&gt;拨乱反正&lt;/code&gt;，业务上必须有如下更改：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;尽可能的增加默认的筛选条件，如：时间周期&lt;/span&gt;，目的是为了减少数据量的展示&lt;/li&gt;
&lt;li&gt;&lt;span&gt;修改跳页的展现方式，改为滚动显示，或小范围跳页&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;滚动显示参考图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC83LzE1LzE3MzRlNDBjNWIyMTNmMTc?x-oss-process=image/format,png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;小规模跳页参考图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC83LzE1LzE3MzRlNDBlY2M2MzQ1NzA?x-oss-process=image/format,png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;通用解决方案&quot;&gt;通用解决方案&lt;/h2&gt;
&lt;p&gt;短时间内快速解决的方案主要是以下几点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;必备：对排序字段，筛选条件务必设置好索引&lt;/li&gt;
&lt;li&gt;核心：&lt;span&gt;利用小范围页码的已知数据，或者滚动加载的已知数据，减少偏移量&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;额外：如果遇到不好处理的情况，也可以获取多余的数据，进行一定的截取，性能影响并不大&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;mysql-2&quot;&gt;MySQL&lt;/h3&gt;
&lt;p&gt;原分页SQL：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;# 第一页
SELECT * FROM `year_score` where `year` = 2017 ORDER BY id limit 0, 20;

# 第N页
SELECT * FROM `year_score` where `year` = 2017 ORDER BY id limit (N - 1) * 20, 20; 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过上下文关系，改写为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;# XXXX 代表已知的数据
SELECT * FROM `year_score` where `year` = 2017 and id &amp;gt; XXXX ORDER BY id limit 20;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 &lt;a href=&quot;https://juejin.im/post/5ea16dede51d45470b4ffc5b#heading-9&quot;&gt;没内鬼，来点干货！SQL优化和诊断&lt;/a&gt; 一文中提到过，LIMIT会在满足条件下停止查询，因此该方案的扫描总量会急剧减少，效率提升Max！&lt;/p&gt;
&lt;h3 id=&quot;es&quot;&gt;ES&lt;/h3&gt;
&lt;p&gt;方案和&lt;code&gt;MySQL&lt;/code&gt;相同，此时我们就可以随用所欲的使用 &lt;code&gt;FROM-TO&lt;/code&gt; Api，而且不用考虑最大限制的问题。&lt;/p&gt;
&lt;h3 id=&quot;mongodb-2&quot;&gt;MongoDB&lt;/h3&gt;
&lt;p&gt;方案基本类似，基本代码如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC83LzE1LzE3MzRlNDExOWVhNjcxMDU?x-oss-process=image/format,png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;相关性能测试：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC83LzE1LzE3MzRlNDEzOGUwMTQ2YjE?x-oss-process=image/format,png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;如果非要深度随机跳页&quot;&gt;如果非要深度随机跳页&lt;/h2&gt;
&lt;p&gt;如果你没有杠过产品经理，又该怎么办呢，没关系，还有一丝丝的机会。&lt;/p&gt;
&lt;p&gt;在 &lt;a href=&quot;https://juejin.im/post/5ea16dede51d45470b4ffc5b#heading-8&quot;&gt;SQL优化&lt;/a&gt; 一文中还提到过&lt;code&gt;MySQL&lt;/code&gt;深度分页的处理技巧，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;# 反例（耗时129.570s）
select * from task_result LIMIT 20000000, 10;

# 正例（耗时5.114s）
SELECT a.* FROM task_result a, (select id from task_result LIMIT 20000000, 10) b where a.id = b.id;

# 说明
# task_result表为生产环境的一个表，总数据量为3400万，id为主键，偏移量达到2000万
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该方案的核心逻辑即基于&lt;code&gt;聚簇索引&lt;/code&gt;，在不通过&lt;code&gt;回表&lt;/code&gt;的情况下，快速拿到指定偏移量数据的主键ID，然后利用&lt;code&gt;聚簇索引&lt;/code&gt;进行回表查询，此时总量仅为10条，效率很高。&lt;/p&gt;
&lt;p&gt;因此我们在处理&lt;code&gt;MySQL&lt;/code&gt;，&lt;code&gt;ES&lt;/code&gt;，&lt;code&gt;MongoDB&lt;/code&gt;时，也可以采用一样的办法：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;限制获取的字段，只通过筛选条件，深度分页获取主键ID&lt;/li&gt;
&lt;li&gt;通过主键ID定向查询需要的数据&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;瑕疵：当偏移量非常大时，耗时较长，如文中的 5s&lt;/p&gt;
&lt;h2 id=&quot;最后&quot;&gt;最后&lt;/h2&gt;
&lt;p&gt;参考文章：&lt;a href=&quot;https://mongoing.com/archives/25469&quot;&gt;MongoDB中文社区&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;感谢 @程大设计师 为我倾情设计的二维码😜&lt;/p&gt;
&lt;p&gt;如果觉得对你有用的话，不要忘记点个赞啊~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC83LzE1LzE3MzRlNDE2YTRkMDRjZTQ?x-oss-process=image/format,png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 15 Jul 2020 15:59:00 +0000</pubDate>
<dc:creator>Super-Kerwin</dc:creator>
<og:description>面试题 &amp;amp;amp; 真实经历 ***面试题：***在数据量很大的情况下，怎么实现深度分页？ 大家在面试时，或者准备面试中可能会遇到上述的问题，大多的回答基本上是分库分表建索引，这是一种很标准的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kkzhilu/p/13311250.html</dc:identifier>
</item>
<item>
<title>原型模式 - 丁可乐</title>
<link>http://www.cnblogs.com/dwlovelife/p/13311211.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dwlovelife/p/13311211.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;序言：今天我们来聊一下原型模式，我个人认为原型模式的命名不太好理解，称呼其为克隆模式会更妥当一点。原型模式的目的是通过复制一个现有的对象来生成一个新的对象，而不是通过实例化的方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;原型模式的基本介绍&quot;&gt;原型模式的基本介绍&lt;/h2&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;用已经创建的实例对象作为原型，通过复制对象来创建一个和原型相同的对象或相似的新对象&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;原型模式属于创建型模式，主要通过 &lt;code&gt;Cloneable&lt;/code&gt; 接口去完成 对象的复制&lt;/p&gt;

&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1348730/202007/1348730-20200715234540482-1998230981.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在原型模式结构图中，会有这么几个角色&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;抽象原型角色（Prototype）：是声明克隆方法的接口，是所有原型类的公共父类&lt;/li&gt;
&lt;li&gt;具体原型角色（Realizetype）：它实现在抽象原型类中所声明的克隆方法，在克隆方法中返回一个克隆对象&lt;/li&gt;
&lt;li&gt;访问角色（PrototypeTest）： 使用具体原型类中的 clone() 方法来复制新的对象&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;需要注意的点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 Java 中 能够克隆的 Java类 务必得 实现 &lt;code&gt;Cloneable&lt;/code&gt; 接口，表示这个 类 能够被 “复制”，至于这个 复制的效果 则与我们的实现有关，通常 clone()方法满足以下的条件：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对任何的对象x，都有：x.clone()!=x 。换言之，克隆对象与元对象不是一个对象&lt;/li&gt;
&lt;li&gt;对任何的对象x，都有：x.clone().getClass==x.getClass()，换言之，克隆对象与元对象的类型一样&lt;/li&gt;
&lt;li&gt;对任何的对象x，如果 equals() 方法编写得当的话， 那么x.clone().equals(x)应该是成立的&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在正式开始原型模式之前，我们先了解两个概念 &lt;strong&gt;浅克隆和深克隆&lt;/strong&gt;，&lt;strong&gt;浅克隆和深克隆的主要区别在于是否支持引用类型的成员变量的复制&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;原型模式（浅克隆）&quot;&gt;原型模式（浅克隆）&lt;/h2&gt;
&lt;p&gt;在浅克隆中，如果原型对象的成员变量是值类型，将复制一份给克隆对象；如果原型对象的成员变量是引用类型，则将引用对象的地址 复制 一份给克隆对象，也就是说原型对象和克隆对象的成员变量指向 相同 的内存地址&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;下面我们以 花园和花 为案例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设我们有一个花园，我们在花园里种植上好的牡丹花，有一天突然想照着牡丹园再建一个一模一样的园子，只是在花园中改种玫瑰&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * 花园 
 */
@Data
@AllArgsConstructor
public class Garden implements Cloneable {
        
        //面积
        private double area;
        private Flower flower;
        
        @Override
        protected Garden clone() {
                Garden garden = null;
                try {
                        garden = (Garden) super.clone();
                } catch (Exception e) {
                        e.printStackTrace();
                }
                return garden;
        }
        
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Data
@AllArgsConstructor
public class Flower {
        
        private String name;
        private String color;
        
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;下面来测试一下原型模式（浅克隆）&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Client {
        public static void main(String[] args) {
                // 牡丹花
                Flower peony = new Flower(&quot;牡丹&quot;, &quot;blue&quot;);
                // 牡丹园
                Garden peonyGarden = new Garden(1000, peony);
                System.out.println(&quot;初始的牡丹园:&quot; + peonyGarden);
                // 牡丹园的复制建造 但是花改成玫瑰 改名玫瑰园
                Garden roseGarden = peonyGarden.clone();
                //浅复制只会复制引用地址，并没有重新复制一个对象
                System.out.println(peonyGarden.getFlower() == roseGarden.getFlower());
                // 改为种植玫瑰花
                roseGarden.getFlower().setName(&quot;玫瑰&quot;);
                roseGarden.getFlower().setColor(&quot;red&quot;);
                System.out.println(&quot;玫瑰园：&quot; + roseGarden);
                System.out.println(&quot;牡丹园：&quot; + peonyGarden);
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1348730/202007/1348730-20200715234554393-417887192.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;我们发现，我们想在新开拓的花园中改种玫瑰后，会影响原花园的花卉的品种，这显然不是我们想要的效果&lt;/p&gt;
&lt;p&gt;从这里我们也看出来了，&lt;strong&gt;浅克隆 在克隆一个对象的 引用类型的成员变量时 只是复制其地址值，并没有复制该对象&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;原型模式（深克隆）&quot;&gt;原型模式（深克隆）&lt;/h2&gt;
&lt;p&gt;在深克隆中，无论原型对象的成员变量是值类型还是引用类型，都将复制一份给克隆对象，深克隆将原型对象的所有引用对象也复制一份给克隆对象。简单来说，在深克隆中，除了对象本身被复制外，对象所包含的所有成员变量也将复制。&lt;br/&gt; &lt;br/&gt;在 Java 中想实现 &lt;strong&gt;深克隆&lt;/strong&gt;，通常有 &lt;strong&gt;两种方式&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对于克隆对象的 引用类型，逐层克隆&lt;/li&gt;
&lt;li&gt;使用序列化方式&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;逐层克隆&quot;&gt;逐层克隆&lt;/h3&gt;
&lt;p&gt;逐层克隆意味着，如果我们要拷贝一个对象，该对象中 若有多个引用类型的成员变量，它们都要实现克隆方法，若嵌套多层引用类型的成员变量，则逐层 实现 &lt;code&gt;Cloneable&lt;/code&gt; 接口&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;**
 * 花园 
 */
@Data
@AllArgsConstructor
public class Garden implements Cloneable {
        
        //面积
        private double area;
        private Flower flower;
        
        @Override
        protected Garden clone() {
                Garden garden = null;
                try {
                        garden = (Garden) super.clone();
                        garden.flower = garden.flower.clone();
                } catch (Exception e) {
                        e.printStackTrace();
                }
                return garden;
        }
        
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Data
@AllArgsConstructor
public class Flower implements Cloneable {

        private String name;
        private String color;
        
        @Override
        protected Flower clone() {
                Flower flower = null;
                try {
                        flower = (Flower) super.clone();
                } catch (Exception e) {
                        e.printStackTrace();
                }
                return flower;
        }
        
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;下面我们测试一下，使用逐层实现 &lt;code&gt;Cloneable&lt;/code&gt; 接口 而完成的深克隆&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Client {
        public static void main(String[] args) {
                // 牡丹花
                Flower peony = new Flower(&quot;牡丹&quot;, &quot;blue&quot;);
                // 牡丹园
                Garden peonyGarden = new Garden(1000, peony);
                // 牡丹园的复制建造 但是花改成玫瑰 改名玫瑰园
                Garden roseGarden = peonyGarden.clone();
                // 深克隆 面对引用类型的成员变量 也重新复制了一个对象
                System.out.println(peonyGarden.getFlower() == roseGarden.getFlower());
                // 改为种植玫瑰花
                roseGarden.getFlower().setName(&quot;玫瑰&quot;);
                roseGarden.getFlower().setColor(&quot;red&quot;);
                System.out.println(&quot;玫瑰园：&quot; + roseGarden);
                System.out.println(&quot;牡丹园：&quot; + peonyGarden);
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1348730/202007/1348730-20200715234608577-191322028.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h3 id=&quot;序列化&quot;&gt;序列化&lt;/h3&gt;
&lt;p&gt;深克隆模式，采取序列化这种方式可能更简单一些，所以的引用类型 成员变量，都实现序列化接口，原型对象 自实现 &lt;code&gt;deepClone&lt;/code&gt; 方法即可&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * 花园 
 */
@Data
@AllArgsConstructor
public class Garden implements Serializable {
        
        private static final long serialVersionUID = 2231850409918603998L;
        //面积
        private double area;
        private Flower flower;
        
        //深拷贝-方式2 使用序列化方式
        public Garden deepClone(){
                //创建流对象
                ByteArrayOutputStream bos = null;
                ObjectOutputStream oos = null;
                ByteArrayInputStream bis = null;
                ObjectInputStream ois = null;
                Garden garden = null;
                try {
                        //序列化
                        bos = new ByteArrayOutputStream();
                        oos = new ObjectOutputStream(bos);
                        oos.writeObject(this); //当前这个对象以对象的方式输出
                        
                        //反序列化
                        bis = new ByteArrayInputStream(bos.toByteArray());
                        ois = new ObjectInputStream(bis);
                        garden = (Garden) ois.readObject();
                } catch (Exception e) {
                        e.printStackTrace();
                }
                return garden;
        }
        
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Data
@AllArgsConstructor
public class Flower implements Serializable {

        private static final long serialVersionUID = 126839939664064143L;
        
        private String name;
        private String color;
        
        @Override
        protected Flower clone() {
                Flower flower = null;
                try {
                        flower = (Flower) super.clone();
                } catch (Exception e) {
                        e.printStackTrace();
                }
                return flower;
        }
        
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;下面我们进行序列化深克隆的测试&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Client {
        public static void main(String[] args) {
                // 牡丹花
                Flower peony = new Flower(&quot;牡丹&quot;, &quot;blue&quot;);
                // 牡丹园
                Garden peonyGarden = new Garden(1000, peony);
                // 牡丹园的复制建造 但是花改成玫瑰 改名玫瑰园
                Garden roseGarden = peonyGarden.deepClone();
                // 深克隆 面对引用类型的成员变量 也重新复制了一个对象
                System.out.println(peonyGarden.getFlower() == roseGarden.getFlower());
                // 改为种植玫瑰花
                roseGarden.getFlower().setName(&quot;玫瑰&quot;);
                roseGarden.getFlower().setColor(&quot;red&quot;);
                System.out.println(&quot;玫瑰园：&quot; + roseGarden);
                System.out.println(&quot;牡丹园：&quot; + peonyGarden);
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1348730/202007/1348730-20200715234623031-640254673.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;从上述我们可以看出，&lt;strong&gt;深克隆不仅在堆内存上开辟了空间以存储复制出的对象，甚至连对象中的引用类型的属性所指向的对象也得以复制，重新开辟了堆空间存储。&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 15 Jul 2020 15:55:00 +0000</pubDate>
<dc:creator>丁可乐</dc:creator>
<og:description>序言：今天我们来聊一下原型模式，我个人认为原型模式的命名不太好理解，称呼其为克隆模式会更妥当一点。原型模式的目的是通过复制一个现有的对象来生成一个新的对象，而不是通过实例化的方法。 原型模式的基本介绍</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/dwlovelife/p/13311211.html</dc:identifier>
</item>
<item>
<title>深入理解JVM（③）再谈线程安全 - 纪莫</title>
<link>http://www.cnblogs.com/jimoer/p/13308699.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jimoer/p/13308699.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;我们在编写程序的时候，一般是有个顺序的，就是先实现再优化，并不是所有的牛P程序都是一次就写出来的，肯定都是不断的优化完善来持续实现的。因此我们在考虑实现高并发程序的时候，要先保证并发的正确性，然后在此基础上来实现高效。所以&lt;strong&gt;线程安全&lt;/strong&gt;是高并发程序首先需要保证的。&lt;/p&gt;
&lt;h2 id=&quot;线程安全定义&quot;&gt;线程安全定义&lt;/h2&gt;
&lt;p&gt;对于线程安全的定义可以理解为：&lt;mark&gt;&lt;strong&gt;当多个线程同时访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那就称这个对象是线程安全的&lt;/strong&gt;&lt;/mark&gt;。&lt;br/&gt;这个定义是很严谨且有可操作性，它要求线程安全的代码都必须具备一个共同特征：代码本身封装了所有必要的正确性保障手段（互斥、同步等），令调用者无须关心多线程下的调用问题，更无须自己实现任何措施来保证多线程环境下的正确调用。&lt;/p&gt;
&lt;h2 id=&quot;java中的线程安全&quot;&gt;Java中的线程安全&lt;/h2&gt;
&lt;p&gt;要讨论Java中的线程安全，我们要以多个线程之间存在共享数据访问为前提。我们可以不把线程安全当作一个非真即假的二元排他选项来看待，而是按照线程安全的“安全程度”由强至弱来排序，将Java中各操作共享的数据分为以下五类：&lt;mark&gt;&lt;strong&gt;不可变、绝对线程安全、相对相对安全、线程兼容和线程对立&lt;/strong&gt;&lt;/mark&gt;。&lt;/p&gt;
&lt;h3 id=&quot;不可变&quot;&gt;不可变&lt;/h3&gt;
&lt;p&gt;Java内存模型中，不可变的对象一定是线程安全的，无论对象的方法实现还是方法的调用者，都不需要再进行任何线程安全保障措施。在&lt;a href=&quot;https://blog.csdn.net/qq_35165000/article/details/107073028&quot;&gt;学习Java内存模型&lt;/a&gt;这一篇文章中我们在介绍Java内存模型的三个特性的可见性的时候说到，&lt;strong&gt;被final修饰的字段在构造器中一旦被初始化完成，并且构造器没有吧“this”的引用传递出去，那么在其他线程中就能看见final字段的值&lt;/strong&gt;。并且外部可见状态永远都不会改变，永远都不会看到它在多个线程之中处于不一致的状态。“不可变”带来的安全性是最直接、最纯粹的。&lt;/p&gt;
&lt;p&gt;在Java中如果共享数据是一个基本类型，那么在定义时使用final修饰它就可以保证它是不可变的。如果共享数据是一个对象，那就需要对象自行保证其行为不会对其状态产生任何影响才行。例如&lt;code&gt;java.lang.String&lt;/code&gt;类的对象实例，它的substring()、replace()、concat()这些方法都不会影响它原来的值，只会返回一个新构造的字符串对象。&lt;br/&gt;保证对象行为不影响自己状态的途径有很多种，最简单的一种就是把对象里面带有状态的变量都声明为final，这样在构造函数结束后，他就是不可变的。&lt;br/&gt;例如&lt;code&gt;java.lang.Integer&lt;/code&gt;构造函数。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * The value of the {@code Integer}.
 *
 * @serial
 */
private final int value;

/**
 * Constructs a newly allocated {@code Integer} object that
 * represents the specified {@code int} value.
 *
 * @param   value   the value to be represented by the
 *                  {@code Integer} object.
 */
public Integer(int value) {
    this.value = value;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;除了String之外，还有枚举类型以及&lt;code&gt;java.lang.Number&lt;/code&gt;的部分子类，如&lt;code&gt;Long&lt;/code&gt;和&lt;code&gt;Double&lt;/code&gt;等数值包装类型、&lt;code&gt;BigInteger&lt;/code&gt;和&lt;code&gt;BigDecimal&lt;/code&gt;等大数据类型。&lt;/p&gt;
&lt;h3 id=&quot;绝对线程安全&quot;&gt;绝对线程安全&lt;/h3&gt;
&lt;p&gt;绝对线程安全是能够完全满足上面的线程安全的定义，这个绝对线程安全的定义是很严格的：“不管运行时环境如何，调用者都不需要任何额外的同步措施”。Java的API中标注自己是线程安全的类，大多数都不是绝对的线程安全。&lt;br/&gt;例如&lt;code&gt;java.util.Vector&lt;/code&gt;是一个线程安全的容器，相信所有的Java程序员对此都不会有异议，因为它的add()、get()、和size()等方法都被&lt;code&gt;synhronized&lt;/code&gt;修饰。但是这样并不意味着调用它的时候，就永远不再需要同步手段了。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class VectorTest {

    private static Vector&amp;lt;Integer&amp;gt; vector = new Vector&amp;lt;Integer&amp;gt;();

    public static void main(String[] args){
        while (true){
            for (int i=0;i&amp;lt;10;i++){
                vector.add(i);
            }

            Thread removeThread = new Thread(new Runnable() {
                @Override
                public void run() {
                    for (int i=0;i&amp;lt;vector.size();i++){
                        vector.remove(i);
                    }
                }
            });

            Thread printThread = new Thread(new Runnable() {
                @Override
                public void run() {
                    for(int i=0;i&amp;lt;vector.size();i++){
                        System.out.println(vector.get(i));
                    }
                }
            });

            removeThread.start();
            printThread.start();

            while (Thread.activeCount() &amp;gt; 20);
        }
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Exception in thread &quot;Thread-653&quot; java.lang.ArrayIndexOutOfBoundsException: Array index out of range: 18
        at java.util.Vector.get(Vector.java:748)
        at com.eurekaclient2.test.jvm3.VectorTest$2.run(VectorTest.java:33)
        at java.lang.Thread.run(Thread.java:748)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过上述代码的例子，就可以看出来，尽管Vector的get()、remove()和size()方法都是同步的，但是在多线程的环境中，如果调用端不做额外的同步措施，使用这段代码仍然是不安全的。因为在并发运行中，如果提前删除了一个元素，而后面还要去打印它，就会抛出数组越界的异常。&lt;br/&gt;如果非要这段代码正确执行下去，就必须把&lt;code&gt;removeThread&lt;/code&gt;和&lt;code&gt;printThread&lt;/code&gt;进行加锁操作。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Thread removeThread = new Thread(new Runnable() {
    @Override
    public void run() {
        synchronized (vector){
            for (int i=0;i&amp;lt;vector.size();i++){
                vector.remove(i);
            }
        }
    }
});

Thread printThread = new Thread(new Runnable() {
    @Override
    public void run() {
        synchronized (vector){
            for(int i=0;i&amp;lt;vector.size();i++){
                System.out.println(vector.get(i));
            }
        }
    }
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;相对线程安全&quot;&gt;相对线程安全&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;相对线程安全就是我们通常意义上所讲的线程安全，它需要保证对这个对象单词的操作时线程安全的，我们在调用的时候不需要进行额外的保证措施，但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性&lt;/strong&gt;。上面的代码例子就是相对线程安全的案例。&lt;/p&gt;
&lt;h3 id=&quot;线程兼容&quot;&gt;线程兼容&lt;/h3&gt;
&lt;p&gt;线程兼容是指对象本身并不线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用。Java类库API中大部分的类都是线程兼容的，如&lt;code&gt;ArrayList&lt;/code&gt;、&lt;code&gt;HashMap&lt;/code&gt;等。&lt;/p&gt;
&lt;h3 id=&quot;线程对立&quot;&gt;线程对立&lt;/h3&gt;
&lt;p&gt;线程对立是指不管调用端是否采用了同步措施，都无法在多线程环境中并发是使用代码。由于Java语言天生就支持多线程的特性，此案从对立这种排斥多线程的代码时很少出现的，而且通常都是有害的，应当尽量避免。&lt;/p&gt;
&lt;h2 id=&quot;线程安全的实现方法&quot;&gt;线程安全的实现方法&lt;/h2&gt;
&lt;p&gt;Java虚拟机为实现线程安全，提供了同步和锁机制，在了解了Java虚拟机线程安全措施的原理与运作过程，再去用代码实现线程安全就不是一件困难的事情了。&lt;/p&gt;
&lt;h3 id=&quot;互斥同步&quot;&gt;互斥同步&lt;/h3&gt;
&lt;p&gt;&lt;mark&gt;互斥同步&lt;/mark&gt;（Mutual Exclusion &amp;amp; Synchronization）是一种常见也是最主要的并发正确性保障手段。&lt;br/&gt;&lt;mark&gt;同步&lt;/mark&gt;是指多&lt;strong&gt;个线程并发访问共享数据时，保证共享数据在同一时刻只被一条线程使用&lt;/strong&gt;。&lt;br/&gt;&lt;mark&gt;互斥&lt;/mark&gt;是指&lt;strong&gt;实现同步的一种手段，临界区（Critical Section）、互斥量（Mutex）和信号量（Semaphore）都是常见的互斥实现方式&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在Java里，最基本的互斥同步手段就是&lt;code&gt;synchronized&lt;/code&gt;关键字，这是一种块结构的同步语法。在Java代码里如果&lt;code&gt;synchronized&lt;/code&gt;明确指定了对象参数，那就以这个对象的引用作为&lt;code&gt;reference&lt;/code&gt;；如果没有明确指定，那将根据&lt;code&gt;synchronized&lt;/code&gt;修饰的方法类型（如实例方法或类方法），来决定是取代码所在的对象实例还是取类型对应的Class对象来作为线程要持有的锁。&lt;/p&gt;
&lt;p&gt;在使用&lt;code&gt;sychronized&lt;/code&gt;时需要特别注意的两点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;mark&gt;被&lt;code&gt;synchronized&lt;/code&gt;修饰的同步块对同一条线程来说是可重入的&lt;/mark&gt;。这意味着同一线程反复进入同步块也不会出现自己把自己锁死的情况。&lt;/li&gt;
&lt;li&gt;&lt;mark&gt;被&lt;code&gt;synchronized&lt;/code&gt;修饰的同步块在持有锁的线程执行完毕并释放锁之前，会无条件地阻塞后面其他线程的进入&lt;/mark&gt;。这意味着无法像处理某些数据库中的锁那样，强制已获取锁的线程释放锁；也无法强制正在等待锁的线程中断等待或超时退出。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;除了&lt;code&gt;synchronized&lt;/code&gt;关键字以外，自JDK5起，Java类库中新提供了&lt;code&gt;java.util.concurrent&lt;/code&gt;包（J.U.C包），其中&lt;code&gt;java.util.concurrent.locks.Lock&lt;/code&gt;接口便成了Java的另一种全新的互斥同步手段。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;重入锁（ReentrantLock）&lt;/strong&gt;是Lock接口最常见的一种实现，它与&lt;code&gt;synchronized&lt;/code&gt;一样是可重入的。在基本用法是，&lt;code&gt;ReentrantLock&lt;/code&gt;与&lt;code&gt;synchronized&lt;/code&gt;很相似，只是代码写法上稍有区别而已。&lt;br/&gt;但是&lt;code&gt;ReentrantLock&lt;/code&gt;与&lt;code&gt;synchronized&lt;/code&gt;相比增加了一些高级特性，主要有以下三项：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;mark&gt;&lt;strong&gt;等待可中断&lt;/strong&gt;&lt;/mark&gt;：是指当持有锁的线程长期不释放的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。可中断特性对处理执行时间非常长的同步很有帮助。&lt;/li&gt;
&lt;li&gt;&lt;mark&gt;&lt;strong&gt;公平锁&lt;/strong&gt;&lt;/mark&gt;：是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁；而非公平锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。&lt;br/&gt;&lt;code&gt;synchronized&lt;/code&gt;是非公平锁，ReentrantLock在默认情况系也是非公平锁，但可以通过构造函数的参数设置成公平锁，不过一旦设置了公平锁，ReentrantLock性能急剧下降，会明显影响性能。&lt;/li&gt;
&lt;li&gt;&lt;mark&gt;&lt;strong&gt;锁绑定多个条件&lt;/strong&gt;&lt;/mark&gt;：是指一个ReentrantLock对象可以同时绑定多个Condition对象。在&lt;code&gt;synchronized&lt;/code&gt;中，锁对象的wait()跟它的notify()或者notifyAll()方法配合可以实现一个隐含条件，如果要和多于一个的条件关联的时候，就不得不额外添加一个锁；而ReentrantLock则无须这样做，多次调用newCondition()方法即可。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;虽然说ReentrantLock比&lt;code&gt;synchronized&lt;/code&gt;增加了一些高级特性，但是从JDK6对&lt;code&gt;synchronized&lt;/code&gt;做了很多的优化后，他俩的性能其实几乎相差无几了。并且在以下的几种情况下虽然&lt;code&gt;synchronized&lt;/code&gt;和ReentrantLock都可以满足需求时，建议优先使用&lt;code&gt;synchronized&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;synchronized&lt;/code&gt;是在Java语法层面的同步，清晰简单。并且被广泛熟知，但J.U.C中的Lock接口并非如此。因此在只需要基础的同步功能时，更推荐&lt;code&gt;synchronized&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;Lock应该确保在finally块中释放锁，否则一旦受同步保护的代码块中抛出异常，则有可能永远不释放持有的锁。&lt;/li&gt;
&lt;li&gt;尽管在JDK5时代ReentrantLock曾经在性能上领先过&lt;code&gt;synchronized&lt;/code&gt;，但这已经是十多年之前的胜利。从长远看，Java虚拟机更容易针对&lt;code&gt;synchronized&lt;/code&gt;来进行优化，因为Java虚拟机可以在线程和对象的元数据中记录&lt;code&gt;synchronized&lt;/code&gt;中锁的相关信息。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;非同步阻塞&quot;&gt;非同步阻塞&lt;/h3&gt;
&lt;p&gt;&lt;mark&gt;互斥同步&lt;/mark&gt;面临的主要问题时进行线程阻塞和唤醒所带来的性能开销，因此这种同步也被称为&lt;mark&gt;阻塞同步（Blocking Synchronized）&lt;/mark&gt;。从解决问题的角度来看，互斥同步是一种悲观的并发策略，无论共享的数据是否真的会出现竞争，都会进行加锁。&lt;br/&gt;随着硬件指令集的发展，出现了另一种选择，基于冲突检测的乐观并发策略，通俗地说就是不管风险，先进行操作，发生了冲突，在进行补偿，最常用的补偿就是不断重试，直到出现没有竞争的数据为止。使用这种乐观并发策略不再需要线程阻塞挂起，因此这种同步操作被称为&lt;mark&gt;非阻塞同步（Non-Blocking Synchronized）&lt;/mark&gt;。&lt;/p&gt;
&lt;p&gt;在进行操作和冲突检测时这个步骤要保证原子性，硬件可以只通过一条处理器指令就能完成，这类指令常用的有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;测试并设置（Test and Set）&lt;/strong&gt;;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;获取并增加（Fetch and Increment）&lt;/strong&gt;;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;交换（Swap）&lt;/strong&gt;;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;比较并交换（Compare adn Swap，简称&lt;mark&gt;CAS&lt;/mark&gt;)&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;加载链接/条件存储（Load-Linked/Store-Conditional，简称LL/SC）&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;mark&gt;Java类库从JDK5之后才开始使用CAS操作，并且该操作有sun.misc.Unsafe类里面的compareAndSwapInt()和compareAndSwapLong()等几个方法包装提供。但是Unsafe的限制了不提供给用户调用，因此在JDK9之前只有Java类库可以使用CAS，譬如J.U.C包里面的整数原子类，其中的compareAndSet()和getAndIncrement()等方法都使用了Unsafe类的CAS操作来实现。直到JDK9，Java类库才在VarHandle类里开放了面向用户程序使用的CAS操作&lt;/mark&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;下面来看一个例子&lt;/strong&gt;：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200715214836483.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,size_30,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;这是之前的一个例子在验证volatile变量不一定完全具备原子性的时候的代码。20个线程自增10000次的操作最终的结果一直不会得到200000。如果按之前的理解就会把race++操作或increase()方法用同步块包起来。&lt;/p&gt;
&lt;p&gt;但是如果改成下面的代码，效率将会提高许多。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class AtomicTest {

    public static AtomicInteger race = new AtomicInteger(0);

    public static void increase(){
        race.incrementAndGet();
    }

    private static final int THREADS_COUNT = 20;
    
    public static void main(String[] args) throws Exception{
        Thread[] threads = new Thread[THREADS_COUNT];
        for (int i = 0;i&amp;lt;THREADS_COUNT;i++){
            threads[i] = new Thread(() -&amp;gt; {
                for(int i1 = 0; i1 &amp;lt;10000; i1++){
                    increase();
                }
            });

            threads[i].start();
        }

        while (Thread.activeCount() &amp;gt; 2){
            Thread.yield();
        }

        System.out.println(race);
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行效果：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;200000
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用哦AtomicInteger代替int后，得到了正确结果，主要归功于incrementAndGet()方法的原子性，incrementAndGet()使用的就是CAS，在此方法内部有一个无限循环中，不断尝试讲一个比当前值大一的新值赋值给自己。如果失败了，那说明在执行CAS操作的时候，旧值已经发生改变，于是再次循环进行下一次操作，直到设置成功为止。&lt;/p&gt;
&lt;h3 id=&quot;无同步方案&quot;&gt;无同步方案&lt;/h3&gt;
&lt;p&gt;要保证线程安全，也不一定非要用同步，线程安全与同步没有必然关系，如果能让一个方法本来就不涉及共享数据，那它自然就不需要任何同步措施去保证正确性，因此有一些代码天生就是线程安全的，主要有这两类：&lt;br/&gt;&lt;mark&gt;&lt;strong&gt;可重入代码&lt;/strong&gt;&lt;/mark&gt;：是指可以在代码执行的任何时刻中断它，然后去执行另外一段代码，而控制权返回后，原来的程序不会出现任何错误，也不会对结果有所影响。&lt;br/&gt;可重入代码有一些共同特征：&lt;br/&gt;&lt;strong&gt;不依赖全局变量、存储在堆上的数据和公用的系统资源，用到的状态量都由参数传入，不调用非可重入的方法等&lt;/strong&gt;。&lt;br/&gt;简单来说就是一个原则：&lt;mark&gt;如果一个方法的返回结果是可以预测的，只要输入了相同的数据，就能返回相同的结果，那它就满足可重入性的要求，当然也就是线程安全的&lt;/mark&gt;。&lt;br/&gt;&lt;mark&gt;&lt;strong&gt;线程本地存储（Thread Local Storage）&lt;/strong&gt;&lt;/mark&gt;：&lt;strong&gt;如果一段代码中所需的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能，就可以把共享数据的可见范围限制在同一个线程内，这样无须同步也能保证线程之间不出现数据争用的问题&lt;/strong&gt;。&lt;br/&gt;如大部分使用消费队列的架构模式，都会将产品的消费过程限制在一个线程中消费完，最经典一个实例就是Web交互模式中的“一个请求对应一个服务器线程”的处理方式，这种处理方式的广泛应用使得很多Web服务端应用都可以使用线程本地存储来解决线程安全问题。&lt;/p&gt;
&lt;p&gt;.&lt;/p&gt;
</description>
<pubDate>Wed, 15 Jul 2020 15:48:00 +0000</pubDate>
<dc:creator>纪莫</dc:creator>
<og:description>前言 我们在编写程序的时候，一般是有个顺序的，就是先实现再优化，并不是所有的牛P程序都是一次就写出来的，肯定都是不断的优化完善来持续实现的。因此我们在考虑实现高并发程序的时候，要先保证并发的正确性，然</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jimoer/p/13308699.html</dc:identifier>
</item>
<item>
<title>理解Spring（一）：Spring 与 IoC - 张永恒</title>
<link>http://www.cnblogs.com/yonghengzh/p/13311192.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yonghengzh/p/13311192.html</guid>
<description>&lt;h2 id=&quot;什么是-spring&quot;&gt;什么是 Spring&lt;/h2&gt;
&lt;p&gt;Spring 是一个轻量级的企业级应用开发框架，它于2004年发布第一个版本，其目的是用于简化企业级应用程序的开发。&lt;/p&gt;
&lt;p&gt;在传统应用程序开发中，一个完整的应用是由一组相互协作的对象组成，开发一个应用除了要开发业务逻辑之外，更多的是关注如何使这些对象协作来完成所需功能，而且要高内聚，低耦合。虽然一些设计模式可以帮我们达到这个目的，可是这又徒增了我们的负担。如果能通过配置的方式来创建对象，管理对象之间依赖关系，那么就能够减少许多工作，提高开发效率。Spring 框架主要就是来完成这个功能的。&lt;/p&gt;
&lt;p&gt;Spring 框架除了帮我们管理对象及其依赖关系之外，还提供了面向切面编程的能力，在此基础上，允许我们对一些通用任务如日志记录、安全控制、异常处理等进行集中式管理，还能帮我们管理最头疼的数据库事务。此外，它还提供了粘合其他框架的能力，使我们可以方便地与各种第三方框架进行集成，而且不管是 Java SE 应用程序还是 JavaEE 应用程序都可以使用这个平台进行开发。&lt;/p&gt;
&lt;p&gt;Spring 是基于 &lt;strong&gt;IoC&lt;/strong&gt; 和 &lt;strong&gt;AOP&lt;/strong&gt; 两大思想理论衍生而来的，可以说，Spring是一个同时实现了 IoC 和 AOP 的框架。&lt;/p&gt;
&lt;h2 id=&quot;spring-的整体架构&quot;&gt;Spring 的整体架构&lt;/h2&gt;
&lt;p&gt;Spring 的整体架构如图所示：&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/1555451/202007/1555451-20200715233519469-2015600342.png&quot; width=&quot;500&quot; height=&quot;350&quot; align=&quot;bottom&quot;/&gt;&lt;p&gt;核心模块只有3个：Beans、Core、和 Context ，它们构建起了整个 Spring 的骨架，没有它们就不可能有 AOP、Web 等上层的特性功能。如果在它们3个中选出一个最核心的模块的话，那就非 Beans 模块莫属了，其实 Spring 就是面向 Bean 的编程（BOP, Bean Oriented Programming），Bean 在 Spring 中才是真正的主角。关于 Bean 的观念，会在后面进行介绍。&lt;/p&gt;
&lt;h2 id=&quot;什么是-ioc&quot;&gt;什么是 IoC&lt;/h2&gt;
&lt;p&gt;IoC（Inverse Of Control，控制反转）是一种设计思想，目标是实现解耦。所谓控制反转，是指对资源的控制方式反转了。这里说的资源主要指我们的业务对象，对象之间往往会存在某种依赖关系，当一个对象依赖另一个对象时，传统的做法是在它内部直接 new 一个出来，即由对象自己负责创建并管理它所依赖的资源，这是传统的对资源的控制方式。IoC 就是将其颠倒过来，对象由主动控制所需资源变成了被动接受，由第三方（IoC 容器）对资源进行集中管理，对象需要什么资源就从IoC容器中取，或者让容器主动将所需资源注入进来。&lt;/p&gt;
&lt;p&gt;IoC 之后，对象与所需资源之间不再具有强耦合性，资源可以被直接替换，而无需改动需求方的代码。举个例子，董事长需要一个秘书，传统的做法是，董事长自己去指定一个秘书，控制权在他自己手上，但是这会导致他与秘书之间的耦合性较强，一旦想换秘书了，就得修改自己的代码。IoC 的做法是，董事长声明自己需要一个秘书，由IoC 容器为他指定一个秘书，至于是哪个秘书，男的还是女的，一切由容器说了算，如果要换秘书，也是修改容器的配置文件，与董事长无关，这样就实现了两者间的解耦。&lt;/p&gt;
&lt;p&gt;IoC 的两种实现方式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;DI（Dependency Injection，依赖注入）。所谓依赖注入，是指对象所依赖的资源通过被动注入的方式得到，换言之，容器会主动地根据预先配置的依赖关系将资源注入进来。&lt;/li&gt;
&lt;li&gt;DL（Dependency Lookup，依赖查找）。依赖查找是早先的一种 IoC 实现方式，现已过时。对象需要调用容器的API查找它所依赖的资源。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;bean-的概念&quot;&gt;Bean 的概念&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;在 Java 中，“Bean”是对用Java语言编写的“可重用组件”的惯用叫法。可以从字面意思去理解，Java 原本指爪哇咖啡，bean 指咖啡豆，而咖啡的“可重用组件”就是咖啡豆嘛。官方并没有说明所谓的“组件”具体指的是什么，因为“组件”本身就是一个抽象的概念，是对软件组成部分的抽象，因此，Bean作为可重用组件的代称，既可指类，也可指对象。&lt;/li&gt;
&lt;li&gt;在 Spring 中，Bean 的概念同上，有时也称 Component。 由 Spring 的 IoC容器所管理的 Bean 称作 Spring Bean。&lt;/li&gt;
&lt;li readability=&quot;0.5&quot;&gt;扩展：
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;em&gt;Java Bean&lt;/em&gt; 的概念不同于 &lt;em&gt;Bean&lt;/em&gt;，Java Bean 是指符合 &lt;em&gt;JavaBeans&lt;/em&gt; 规范的一种特殊的 Bean，即：所有属性均为 private，提供 getter 和 setter，提供默认构造方法。JavaBean 也可以认为是遵循特定约定的POJO。&lt;/p&gt;
&lt;p&gt;POJO（Plain Ordinary Java Object）是指简单和普通的 Java 对象。严格来说，它不继承类，不实现接口，不处理业务逻辑，仅用于封装数据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;spring-的基本使用&quot;&gt;Spring 的基本使用&lt;/h2&gt;
&lt;p&gt;首先配置 Bean 信息，向 Spring 的 IoC 容器（或简称 Spring 容器）中注册 Bean。以 XML 方式为例，如下配置了两个 Bean，其中第一个依赖第二个：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;bean id=&quot;John&quot; class=&quot;Person&quot;&amp;gt;
        &amp;lt;property name=&quot;lover&quot;&amp;gt;
                &amp;lt;ref bean=&quot;Mary&quot;/&amp;gt;
        &amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;
&amp;lt;bean id=&quot;Mary&quot; class=&quot;Person&quot;/&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后创建 Spring 容器，同时绑定配置文件。如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;ApplicationContext container = new ClassPathXmlApplicationContext(&quot;bean-config.xml&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后通过容器的 getBean 方法即可得到我们在配置文件中所配置的 Bean 的实例。如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Person John = container.getBean(&quot;John&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;spring-的两种-ioc-容器&quot;&gt;Spring 的两种 IoC 容器&lt;/h2&gt;
&lt;p&gt;Spring 提供了两种 IoC 容器： BeanFactory 和 ApplicationContext 。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;BeanFactory 提供基本的 IoC 服务支持。&lt;/li&gt;
&lt;li&gt;ApplicationContext 对 BeanFactory 进行了扩展与增强，除了拥有 BeanFactory 的所有能力外，还提供了许多高级特性，如事件发布、资源加载、国际化消息等。ApplicationContext 接口继承了 BeanFactory 接口，它的实现类中也是直接复用了 BeanFactory，因此可以说，ApplicationContext 是 BeanFactory 的增强版。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;两者在核心功能上的区别主要是默认的加载策略不同，这点区别几乎可以忽略不计，通常情况下，我们总是使用更为强大的 ApplicationContext，很少会直接使用 BeanFactory。&lt;/p&gt;
&lt;p&gt;以下是几个最常用的 ApplicationContext 实现类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ClassPathXmlApplicationContext&lt;/li&gt;
&lt;li&gt;AnnotationConfigApplicationContext&lt;/li&gt;
&lt;li&gt;AnnotationConfigWebApplicationContext&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;spring-容器的基本工作原理&quot;&gt;Spring 容器的基本工作原理&lt;/h2&gt;
&lt;p&gt;既然是容器，那它最底层肯定是一个数据结构。通过跟踪 getBean 方法，我们发现它是从一个叫作 &lt;em&gt;singletonObjects&lt;/em&gt; 的 Map 集合中获取 Bean 实例的。&lt;em&gt;singletonObjects&lt;/em&gt; 的定义如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1555451/202007/1555451-20200715233448720-414347563.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以断定，它就是 Spring 容器的核心，凡是作用域为单例的 Bean 的实例都保存在该 Map 集合中，我把它称之为&lt;strong&gt;单例池&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;那么 getBean 方法做了哪些事情呢？&lt;/p&gt;
&lt;p&gt;getBean 方法首先会从单例池中获取 Bean 实例，如果取到了就直接返回，否则，如果有父容器，尝试从父容器中获取，如果也没获取到，则创建实例。创建实例之前先确保该 Bean 所依赖的 Bean 全部初始化，然后，如果是原型 Bean，创建好实例后直接返回，如果是单例 Bean，创建好实例后将其放进单例池，然后再从单例池中获取并返回。&lt;/p&gt;
&lt;p&gt;当 Spring 容器被创建时，它又是如何完成初始化的呢？&lt;/p&gt;
&lt;p&gt;以 &lt;code&gt;ClassPathXmlApplicationContext&lt;/code&gt;为例，它的构造方法主要做的事情就是调用 refresh() 方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void refresh() throws BeansException, IllegalStateException {
    synchronized (this.startupShutdownMonitor) {
        // 准备好自己
        prepareRefresh();
        // 创建并初始化BeanFactory
        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();
        // 准备好要使用的BeanFactory
        prepareBeanFactory(beanFactory);
        try {
            // 对BeanFactory进行后置处理
            postProcessBeanFactory(beanFactory);
            // 调用BeanFactory的后置处理器
            invokeBeanFactoryPostProcessors(beanFactory);
            // 注册Bean的后置处理器
            registerBeanPostProcessors(beanFactory);
            // 初始化消息源
            initMessageSource();
            // 初始化事件多播器
            initApplicationEventMulticaster();
            // 初始化其他特殊的bean
            onRefresh();
            // 检测并注册监听器Bean
            registerListeners();
            // 实例化其余所有（非懒加载）的单例Bean
            finishBeanFactoryInitialization(beanFactory);
            // 最后一步：发布相应的事件
            finishRefresh();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;refresh() 方法的主要执行流程：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;调用 &lt;code&gt;refreshBeanFactory()&lt;/code&gt; 方法，该方法会首先新建或重建 BeanFactory 对象，然后使用相应的&lt;code&gt;BeanDefinitionReader&lt;/code&gt; 读取并解析 Bean 定义信息，将每个 Bean 定义信息依次封装成 &lt;code&gt;BeanDefinition&lt;/code&gt; 对象，并将这些 &lt;code&gt;BeanDefinition&lt;/code&gt; 对象注册到 &lt;code&gt;BeanDefinitionRegistery&lt;/code&gt;。这一步，完成了 BeanFactory 的创建，以及 Bean 定义信息的加载。&lt;/li&gt;
&lt;li&gt;配置 BeanFactory，对 BeanFactory 做一些后置处理，注册 Bean 的后置处理器，初始化消息源和事件多播器，注册监听器等。这一步，完成了 Spring 容器的配置工作。&lt;/li&gt;
&lt;li&gt;调用 &lt;code&gt;finishBeanFactoryInitialization()&lt;/code&gt; 方法，该方法会遍历之前注册到 &lt;code&gt;BeanDefinitionRegistery&lt;/code&gt; 中的所有 &lt;code&gt;BeanDefinition&lt;/code&gt; ，依次实例化那些非抽象非懒加载的单例 Bean，并将其加入单例池。这一步，完成了 Bean 的实例化。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Spring 容器的几个核心类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;DefaultListableBeanFactory&lt;/code&gt;&lt;/strong&gt; 是一个通用的 &lt;code&gt;BeanFactory&lt;/code&gt; 实现类，它还同时实现了&lt;code&gt;BeanDefinitionRegistry&lt;/code&gt; 接口。从 ApplicationContext 实现类的源码中可以看到，在它内部维护着一个 &lt;code&gt;DefaultListableBeanFactory&lt;/code&gt; 的实例，所有的 IoC 服务都委托给该 BeanFactory 实例来执行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;BeanDefinitionRegistry&lt;/code&gt;&lt;/strong&gt; 负责维护 &lt;code&gt;BeanDefinition&lt;/code&gt; 实例，该接口主要定义了&lt;code&gt;registerBeanDefinition()&lt;/code&gt;、&lt;code&gt;getBeanDefinition()&lt;/code&gt; 等方法，用于注册和获取 Bean 信息。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;BeanDefinition&lt;/code&gt;&lt;/strong&gt; 用于封装 Bean 的信息，包括类名、是否是单例Bean、构造方法参数等信息。每一个 Spring Bean 都会有一个 &lt;code&gt;BeanDefinition&lt;/code&gt; 的实例与之相对应。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;BeanDefinitionReader&lt;/code&gt;&lt;/strong&gt; 负责读取相应配置文件中的内容并将其映射到 &lt;code&gt;BeanDefinition&lt;/code&gt; ，然后将映射后的 &lt;code&gt;BeanDefinition&lt;/code&gt; 实例注册到 &lt;code&gt;BeanDefinitionRegistry&lt;/code&gt;，由 &lt;code&gt;BeanDefinitionRegistry&lt;/code&gt; 来保管它们。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;spring-bean-的注册与装配&quot;&gt;Spring Bean 的注册与装配&lt;/h2&gt;
&lt;p&gt;个人理解，注册与装配是不同的两个过程。注册指的是将 Bean 纳入 IoC 容器。装配指的是建立 Bean 之间的依赖关系。&lt;/p&gt;
&lt;p&gt;Bean 的注册方式有以下三种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在 XML文件中配置&lt;/li&gt;
&lt;li&gt;在 JavaConfig 中配置&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;@ComponentScan&lt;/code&gt;、&lt;code&gt;@Component&lt;/code&gt;等注解进行配置&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Bean 的装配分为手动装配和自动装配。&lt;/p&gt;
&lt;p&gt;手动装配同样有三种方式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在 XML文件 中配置&lt;/li&gt;
&lt;li&gt;在 JavaConfig 中配置&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;@Resource&lt;/code&gt; 等注解来配置。
&lt;ul&gt;&lt;li&gt;这种方式既可以算作手动装配，也可以算作自动装配。当我们在 @Resource 注解中明确指定注入哪一个 Bean 时，我们称这是手动装配，而当我们不进行指定时，则算作自动装配。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;自动装配也称自动注入，有两种开启方式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;开启粗粒度的自动装配，即开启 Bean 的默认自动装配。在&lt;code&gt;&amp;lt;bean&amp;gt;&lt;/code&gt;标签中配置&lt;code&gt;default-autowire&lt;/code&gt;属性，或在&lt;code&gt;@Bean&lt;/code&gt;注解中配置&lt;code&gt;autowire&lt;/code&gt;属性。开启了默认自动装配的 Bean，Spring 会对它的全部属性都尝试注入值，这种方式不安全，因此很少使用。&lt;/li&gt;
&lt;li&gt;开启细粒度的自动装配，即在组件类中使用&lt;code&gt;@Autowired&lt;/code&gt;等注解对单个属性开启自动装配。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Spring 支持以下四种用于自动装配的注解：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Spring 自带的 &lt;code&gt;@Autowired&lt;/code&gt; 注解&lt;/li&gt;
&lt;li&gt;JSR-330 的 &lt;code&gt;@Inject&lt;/code&gt; 注解&lt;/li&gt;
&lt;li&gt;JSR-250 的 &lt;code&gt;@Resource&lt;/code&gt; 注解&lt;/li&gt;
&lt;li&gt;Spring 新增的 &lt;code&gt;@Value&lt;/code&gt; 注解，用于装配 String 和基本类型的值。&lt;code&gt;@Value&lt;/code&gt;注解经常配合 SpEL 表达式一起使用。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;SpEL 表达式的主要语法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;${}&lt;/code&gt;，表示从 Properties 文件中读取相应属性的值。通常需要同&lt;code&gt;@PropertySource&lt;/code&gt;注解配合使用，该注解用于指定从哪个 Properties 文件中读取属性。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#{}&lt;/code&gt;，表示从 Spring Bean 中读取相应属性的值。如，#{user1.name}表示从名称为 user1 的 Bean 中 读取 name 属性值。&lt;/li&gt;
&lt;li&gt;冒号&lt;code&gt;:&lt;/code&gt;用于指定默认值，如${server.port:80}。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;spring-bean-的作用域与生命周期&quot;&gt;Spring Bean 的作用域与生命周期&lt;/h2&gt;
&lt;p&gt;未完待续&lt;/p&gt;
</description>
<pubDate>Wed, 15 Jul 2020 15:46:00 +0000</pubDate>
<dc:creator>张永恒</dc:creator>
<og:description>什么是 Spring Spring 是一个轻量级的企业级应用开发框架，它于2004年发布第一个版本，其目的是用于简化企业级应用程序的开发。 在传统应用程序开发中，一个完整的应用是由一组相互协作的对象组</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yonghengzh/p/13311192.html</dc:identifier>
</item>
</channel>
</rss>