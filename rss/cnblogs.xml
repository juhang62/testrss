<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>docker（3）容器管理命令 - 乐途</title>
<link>http://www.cnblogs.com/szlblog/p/10612280.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/szlblog/p/10612280.html</guid>
<description>&lt;p&gt;接着上一篇，今天说一下Docker 有关容器的常用命令。算是比较详细了吧。&lt;/p&gt;
&lt;h2&gt;docker run  命令：&lt;/h2&gt;
&lt;p&gt;注：此命令作用是使用一个镜像运行启动一个容器。 在启动运行的时候 会检查docker 中是否包含了该镜像 如果没有包含 ，docker 会自动的在 docker 的仓库中下载你想使用的镜像。也就是说有时候咱们可以省略：Doker  pull 命令。&lt;/p&gt;
&lt;p&gt;Docker run 命令常用的参数&lt;/p&gt;
&lt;p&gt;　　1：--name 【镜像名】 ：&lt;/p&gt;
&lt;p&gt;　　--name 给启动的容器 起一个名字，如果不使用 –name   docker的守护进程会自动给你的容器命名，这里建议使用此参数，docker进程起的名太难记了&lt;/p&gt;
&lt;p&gt;　　2：-d &lt;/p&gt;
&lt;p&gt;       如果想启动一个在后台运行的容器的时候执行以下命令：可以启动一个容器并且后台运行 可以创建一个守护式容器。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1027558/201903/1027558-20190327231816464-889910646.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　可以对比一下名字&lt;/p&gt;
&lt;p&gt;　　3：-t docker 会 分配一个伪终端并绑定到容器的标准输入上,&lt;/p&gt;
&lt;p&gt;　　4：-i则让容器的标准输入保持打开，使用的时候可以两个结合为&lt;/p&gt;
&lt;p&gt;　　5：– it 上面两个的结合&lt;/p&gt;
&lt;p&gt;　　演示一下使用不使用 &lt;strong&gt;– it&lt;/strong&gt; 作用：&lt;/p&gt;
&lt;p&gt;　　Docker run – name centos    centos /bin/bash&lt;/p&gt;
&lt;p&gt;　　Docker run – name centos -it   centos /bin/bash&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1027558/201903/1027558-20190327231920987-1840003675.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　注：一个运行后直接闪退了，并且不会保持与运行，加上-it 后运行我们会直接进入容器中，但是会在退出容器后停止容器。&lt;/p&gt;
&lt;p&gt;　　有关docker run 的参数就先说这几个，在后续文会继续增加。&lt;/p&gt;
&lt;h2&gt; 查看容器命令&lt;/h2&gt;
&lt;p&gt;　　1：Docker ps    查看运行中的容器&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1027558/201903/1027558-20190327232154796-1934407755.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　我们可以看到 容器的ID，名称，运行时间 端口等信息&lt;/p&gt;
&lt;p&gt;　　2：Docker ps -a  查看所有运行中的和为运行的&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1027558/201903/1027558-20190327232229524-971789058.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　3：Docker ps -l       可以查看你最后一个运行的容器&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1027558/201903/1027558-20190327232244787-87712954.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;容器的删除命令&lt;/h2&gt;
&lt;p&gt;　　1：Docker rm&lt;/p&gt;
&lt;p&gt;　　删除 ID/名称 为某某的容器 （未运行的）&lt;/p&gt;
&lt;p&gt;　　2：Docker rm  `docker ps -a -q`&lt;/p&gt;
&lt;p&gt;　　批量删除未运行的容器&lt;/p&gt;
&lt;p&gt;　　3：Docker rm -f                     &lt;/p&gt;
&lt;p&gt;　　&lt;code&gt;强制删除运行中的容器&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;　　4：Docker rm -f `docker ps -a -q`&lt;/p&gt;
&lt;p&gt;　　批量强制删除运行中的容器&lt;/p&gt;
&lt;p&gt;      删除就不演示了，但是后面的两个坚决不推荐使用（就怕删错了谨慎为上）&lt;/p&gt;
&lt;h2&gt;容器的启动/停止命令：&lt;/h2&gt;
&lt;p&gt;　　1：停止命令&lt;/p&gt;
&lt;p&gt;　　 &lt;strong&gt;Docker stop&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        &lt;strong&gt;Docker kill&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　这两个都可以停止容器&lt;/p&gt;
&lt;p&gt;　　区别：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　stop&lt;/strong&gt; 发送一个命令等待容器停止： 有等待时间&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　Kill&lt;/strong&gt;   直接停止容器：没等待时间&lt;/p&gt;
&lt;p&gt;　　2：启动命令&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;Docker start&lt;/strong&gt;    ID/名称  启动一个未运行(已停止)的容器&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;Docker start -i&lt;/strong&gt;  ID/名称  以交互的方式启动容器(直接会进入容器)&lt;/p&gt;
&lt;p&gt;　　这个就不演示了，在使用-I 的时候不是每次都会成功的会卡住。这点注意了&lt;/p&gt;
&lt;h2&gt;容器的退出命令&lt;/h2&gt;
&lt;p&gt;　　1：exit&lt;/p&gt;
&lt;p&gt;　　2：ctrl+d        退出和exit 效果一样。&lt;/p&gt;
&lt;p&gt;　　3：ctrl+p ctrl+q  这种组合的退出方式只适用与交互式容器&lt;/p&gt;
&lt;p&gt; 　　以上三个命令是在容器中使用的&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1027558/201903/1027558-20190327232926523-1009738117.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;正确的进入容器&lt;/h2&gt;
&lt;p&gt;　　1：Docker attach  ID/名称  &lt;strong&gt; 注：退出后会停止容器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　可以进入一个正在运行的容器中。需要注意的是 Docker attach  这个命令是由缺陷的，很早就有了，有时候我们想进入一个容器中的时候 卡住了，但不是没次都会卡主有时候会有时候不会&lt;/p&gt;
&lt;p&gt;　　比如：运行一个consul镜像&lt;/p&gt;
&lt;p&gt;　　docker run  -d -P  --name consul   docker.io/consul agent -server -ui -bootstrap-expect=1 -data-dir=/tmp/consul -client=0.0.0.0   -datacenter=dc1&lt;/p&gt;
&lt;p&gt;　　查看结果：确保容器运行中&lt;/p&gt;
&lt;p&gt;　　进入容器结果：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1027558/201903/1027558-20190327233210349-499161847.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　卡在这了不会动了，取消之后还会 停止正在运行的容器尴尬不。&lt;/p&gt;
&lt;p&gt;　　2：启动时进入容器。 在docker run 已经使用   &lt;strong&gt;注：退出后会停止容器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;   &lt;img src=&quot;https://img2018.cnblogs.com/blog/1027558/201903/1027558-20190327233246426-1016634371.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　3：第三种是生产的时候推荐使用的  （&lt;strong&gt;退出后容器不会登出）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;我们使用PID进入容器查看容器的PID 两种方法&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;docker inspect -f {{.State.Pid}}  nginx&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　docker top nginx&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       结果：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1027558/201903/1027558-20190327233442867-479212035.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　进入容器：使用nsenter  我的centos 自带此命令，没有的可以安装一下。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;nsenter --target 10692  --uts --ipc --net --pid&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1027558/201903/1027558-20190327233517914-222562731.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 　　推出容器： Ctrl +d&lt;/p&gt;
&lt;p&gt;       查看容器的运行状态：docker ps&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1027558/201903/1027558-20190327233536046-2019632199.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　退出后容器不会登出，这种方式生产建议使用：&lt;/p&gt;
&lt;h2&gt; 查看容器的日志&lt;/h2&gt;
&lt;p&gt;　　docker logs   id/名称&lt;/p&gt;
&lt;p&gt;　　Logs 选项大致分为三个：&lt;/p&gt;
&lt;p&gt;                     &lt;strong&gt;-t&lt;/strong&gt;           　　　　显示容器的日志信息&lt;/p&gt;
&lt;p&gt;                     &lt;strong&gt;-f &lt;/strong&gt;          　　　　显示容器的日志信息并带上时间&lt;/p&gt;
&lt;p&gt;                     &lt;strong&gt;--tail  数字参数&lt;/strong&gt;    显示容器的所有日志信息&lt;/p&gt;
&lt;p&gt;　　比如：我们运行一个centos 的容器 并循环输出 hello word&lt;/p&gt;
&lt;p&gt;　　如下图：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1027558/201903/1027558-20190327233830709-1827219207.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　查看日志：&lt;strong&gt;docker logs contos2&lt;/strong&gt; 或者 &lt;strong&gt;ocker logs -f contos2  手残centos&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1027558/201903/1027558-20190327233926098-597685081.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1027558/201903/1027558-20190327233932874-1627153783.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　使用命令：docker logs -t contos2 或者 docker logs -ft contos2&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1027558/201903/1027558-20190327234025992-2135771737.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;     &lt;img src=&quot;https://img2018.cnblogs.com/blog/1027558/201903/1027558-20190327234036424-272717117.png&quot; alt=&quot;&quot;/&gt;　　&lt;/p&gt;
&lt;p&gt;　　使用命令：docker logs  --tail 3  contos2 或者 docker logs -t  --tail 3  contos2&lt;/p&gt;
&lt;p&gt;    &lt;img src=&quot;https://img2018.cnblogs.com/blog/1027558/201903/1027558-20190327234117215-1820401469.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　注：以上命令只是示范可随意组合使用：&lt;/p&gt;
&lt;h2&gt;在容器中启动新的进程&lt;/h2&gt;
&lt;p&gt;　　注：docker 理念一个容器运行一个进程,但是保不齐我们需要对该容器 维护监控等操作。&lt;/p&gt;
&lt;p&gt;　　新创建一个容器：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1027558/201903/1027558-20190327234651622-278899739.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　查看容器的进程数量&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1027558/201903/1027558-20190327234809835-1884790831.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　新建并查看进程：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;docker exec -it -d centos4 /bin/bash&lt;/strong&gt;&lt;br/&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1027558/201903/1027558-20190327234934907-334533334.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这里显示了新的进程信息。&lt;/p&gt;
&lt;p&gt; 下一篇记录一下 docker 的网络。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;有不足之处&lt;/strong&gt; &lt;span&gt;&lt;strong&gt;希望大家指出相互学习，&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;            本文&lt;span&gt;&lt;strong&gt;原创：&lt;/strong&gt;转载请注明出处 谢谢！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;



</description>
<pubDate>Wed, 27 Mar 2019 15:53:00 +0000</pubDate>
<dc:creator>乐途</dc:creator>
<og:description>接着上一篇，今天说一下Docker 有关容器的常用命令。算是比较详细了吧。 docker run 命令： 注：此命令作用是使用一个镜像运行启动一个容器。 在启动运行的时候 会检查docker 中是否包</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/szlblog/p/10612280.html</dc:identifier>
</item>
<item>
<title>第692期 | 人的道德是如何下降的 （背离现实世界的严重危害） - honkerzh</title>
<link>http://www.cnblogs.com/honkerzh/p/10612269.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/honkerzh/p/10612269.html</guid>
<description>&lt;p&gt;“路怒症”，开车路上容易发怒的那种病症。你想啊，好好一个人，一开车，就容易发火，容易拍方向盘，容易骂骂咧咧，攻击性上升。这不就是道德水准明显下降吗？而下车之后呢，又跟好人一样。你看，就在这上车下车的转瞬之间，一个人的道德水准发生了巨大波动。&lt;/p&gt;
&lt;p&gt;“路怒症”的一种比较好的解释是：人进了车，就是钻进了一个壳。人和世界的互动关系就发生了一次质变。在车外的时候，你是用全部身体和感官来和这个世界互动，一旦进了车呢？身体立即有了安全感，钻进了一个属于你自己的空间。车一开动，你和整个世界的信息通道被大量阻断了。首先，双向的对话功能肯定是关闭了。你说话，外面听不到。外面的话，你也不太容易听到。而且，人类最重要的几个感官，比如听觉，嗅觉，触觉，也被屏蔽了。最后只剩下一个视觉。但其实，即使视觉，这个时候交流能力也是大大下降的。你只能通过车窗去看前面的车和路，通过后视镜去看后面的路况。那这个时候会发生什么？当然就是我们和世界之间的认知失调。&lt;/p&gt;
&lt;p&gt;我们的行为举止要想符合社会的道德规范是有前提的，前提就是，我们和真实世界信息交互要非常充分。&lt;br/&gt;就好像孔子说过的慎独，即使一个人时候也能表现出应有的道德水平。在个人修养这个层次，就是说，一个人孤独待着的时候，最考验一个人的道德水平。有句话叫：衾影无惭,屋漏不愧。什么意思？衾，就是被子。一个人盖着被子睡觉的时候想的事情，也能够不羞惭。屋漏不愧。就是你一个人待着的房间，突然漏了，墙倒了，外面假设全是围观者，你在屋里正在干的事情，也能不羞愧。做到这一点是在太难了。为什么难？还是那个原因，你和世界的信息交互切断了嘛。保持道德水准就难。&lt;/p&gt;
&lt;p&gt;这个原理可以解释很多现象。为什么在互联网时代，会出现那么多键盘侠？天天在网上骂人。如果你在日常生活中遇到他，没准你会觉得，他是一个人格健全，心智正常的人。但是为什么在网络环境里，当他只通过屏幕和键盘和世界交流的时候，他的认知能力就会剧烈下降。说出来的话，道德水准也就不怎么样呢。就是这个原因。在人类整体上也是这样。一直有一个悬疑。现代社会，人类的整体道德水准提高那么多，但是战争的残酷性愈演愈烈呢？还是这个问题：在现代战争中，对战双方的信息交互通道越来越少。&lt;/p&gt;
&lt;p&gt;一个人要想维持自己的道德水准，不仅是要修身养性，更重要的是，不把自己抽离出真实的世界。所以，防止自己距离现实越来越远，防止自己关闭和真实世界的信息交互，这不仅是在防范道德风险，也是在防范人生风险。&lt;/p&gt;
&lt;p&gt;想到这儿，我才理解查理芒格的做法。他很有钱，可以说是巨富，公司也有私人飞机。但是他那么大年纪，身体又胖。他出行，还是坚持坐商务飞机，而且是经济舱。为什么呢？他的回答是，“我一辈子想要的就是融入生活，而不希望自己被孤立。”&lt;/p&gt;
&lt;p&gt;对，被现实隔离，不仅是危险的源头，也可能是个人变得不道德的原因。&lt;/p&gt;
&lt;p&gt;总结：1.提高自身道德水平两种方法，第一：读孔孟之道，严于律己宽以待人，修生养性。第二：不能背离现实，相反更好融入到现实中去，作为领导更应该融入小团体的生活中去。&lt;br/&gt;2.做决策、提建议 一定注意不要背离了现实。&lt;/p&gt;
&lt;p&gt;注意：本文为得到app学习笔记，欢迎下载得到APP和罗胖一起学习。&lt;/p&gt;
</description>
<pubDate>Wed, 27 Mar 2019 15:50:00 +0000</pubDate>
<dc:creator>honkerzh</dc:creator>
<og:description>“路怒症”，开车路上容易发怒的那种病症。你想啊，好好一个人，一开车，就容易发火，容易拍方向盘，容易骂骂咧咧，攻击性上升。这不就是道德水准明显下降吗？而下车之后呢，又跟好人一样。你看，就在这上车下车的转</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/honkerzh/p/10612269.html</dc:identifier>
</item>
<item>
<title>常用正则表达式 - 陈本布衣</title>
<link>http://www.cnblogs.com/chenbenbuyi/p/10612062.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenbenbuyi/p/10612062.html</guid>
<description>&lt;p&gt;　　该文持续性的收集工作中常用到的正则表达式，基本都是拿来即用，如有纰漏，烦请指出。&lt;/p&gt;
&lt;h2&gt;一  字符类&lt;/h2&gt;
&lt;p&gt;1  &lt;strong&gt;用户名&lt;/strong&gt;：3-16位，允许大小写字母、数字、下划线&lt;/p&gt;
&lt;p&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;^[a-zA-Z0-9_]{&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;16&lt;/span&gt;}$&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;2 &lt;strong&gt;密码&lt;/strong&gt;：8~20位，包含大、小写字母、数字、特殊字符3种或3种以上的组合&lt;/p&gt;
&lt;p&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;^(?![a-zA-Z]+$)(?![A-Z0-&lt;span&gt;9&lt;/span&gt;]+$)(?![A-Z\W_]+$)(?![a-z0-&lt;span&gt;9&lt;/span&gt;]+$)(?![a-z\W_]+$)(?![&lt;span&gt;0&lt;/span&gt;-&lt;span&gt;9&lt;/span&gt;\W_]+$)[a-zA-Z0-&lt;span&gt;9&lt;/span&gt;\W_]{&lt;span&gt;8&lt;/span&gt;,&lt;span&gt;20&lt;/span&gt;}$&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;3  26位大小写英文字母&lt;/p&gt;
&lt;p&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;^[A-Za-z]+$&lt;/span&gt; &lt;/p&gt;

&lt;h2&gt;二  数字类&lt;/h2&gt;
&lt;p&gt;1 数字&lt;/p&gt;
&lt;p&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;^[0-9]*$&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;2 整数&lt;/p&gt;
&lt;p&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;^\d+$&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;3 负整数&lt;/p&gt;
&lt;p&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;^-[1-9]\d*$&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;4 小数&lt;/p&gt;
&lt;p&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;^(-?\d+)(\.\d+)?$ 或 ^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;5 整数  范围【1，100】&lt;/p&gt;
&lt;p&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;^(?:0|[1-9][0-9]?|100)$&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;6 64位十六进制表示&lt;/p&gt;
&lt;p&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;^[A-Fa-f0-9]{64}$&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;7 手机号&lt;/p&gt;
&lt;p&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d{8}$&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;8 身份证号码（15或18位）&lt;/p&gt;
&lt;p&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;(^[1-9]\d{5}(18|19|([23]\d))\d{2}((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\d{3}[0-9Xx]$)|(^[1-9]\d{5}\d{2}((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\d{2}[0-9Xx]$)&lt;/span&gt; &lt;/p&gt;

&lt;h2&gt;三  网络通信类&lt;/h2&gt;
&lt;p&gt;1 IPV4地址&lt;/p&gt;
&lt;p&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;^((?:(?:25[0-5]|2[0-4]\d|((1\d{2})|([1-9]?\d)))\.){3}(?:25[0-5]|2[0-4]\d|((1\d{2})|([1-9]?\d))))$&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;2 主机物理地址（MAC地址）&lt;/p&gt;
&lt;p&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;^[A-Fa-f0-9]{2}:[A-Fa-f0-9]{2}:[A-Fa-f0-9]{2}:[A-Fa-f0-9]{2}:[A-Fa-f0-9]{2}:[A-Fa-f0-9]{2}$&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;3 端口号 [0~65535]&lt;/p&gt;
&lt;p&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;^[0-9]$|(^[1-9][0-9]$)|(^[1-9][0-9]{2}$)|(^[1-9][0-9]{3}$)|(^[1-5][0-9]{4}$)|(^6[0-4][0-9]{3}$)|(^65[0-4][0-9]{2}$)|(^655[0-2][0-9]$)|(^6553[0-5]$)&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;4 子网掩码&lt;/p&gt;
&lt;p&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;^((?:(?:25[0-5]|2[0-4]\d|((1\d{2})|([1-9]?\d)))\.){3}(?:25[0-5]|2[0-4]\d|((1\d{2})|([1-9]?\d))))$&lt;/span&gt; &lt;/p&gt;

&lt;h2&gt;四  其它&lt;/h2&gt;
&lt;p&gt;1 Email 地址&lt;/p&gt;
&lt;p&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;^w+[-+.]w+)*@w+([-.]w+)*.w+([-.]w+)*$&lt;/span&gt; &lt;/p&gt;

&lt;p&gt; 正则在线测试：&lt;a href=&quot;http://tool.oschina.net/regex/&quot; target=&quot;_blank&quot;&gt;http://tool.oschina.net/regex/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; 参考链接：&lt;a href=&quot;http://www.cnblogs.com/fozero/p/7868687.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/fozero/p/7868687.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 27 Mar 2019 15:50:00 +0000</pubDate>
<dc:creator>陈本布衣</dc:creator>
<og:description>该文持续性的收集工作中常用到的正则表达式，基本都是拿来即用，如有纰漏，烦请指出。 一 字符类 1 用户名：3-16位，允许大小写字母、数字、下划线 ^[a-zA-Z0-9_]{3,16}$ 2 密码：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenbenbuyi/p/10612062.html</dc:identifier>
</item>
<item>
<title>golang中接口interface和struct结构类的分析 - 在左手</title>
<link>http://www.cnblogs.com/zhangdewang/p/10612089.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangdewang/p/10612089.html</guid>
<description>&lt;p&gt;再golang中，我们要充分理解interface和struct这两种数据类型。为此，我们需要优先理解type的作用。&lt;/p&gt;
&lt;p&gt;type是golang语言中定义数据类型的唯一关键字。对于type中的匿名成员和指针成员，这里先不讲，重点讲解interface和struct这两种特殊的数据类型。&lt;/p&gt;
&lt;p&gt;interface和struct也是数据类型，特殊在于interface作为万能的接口类型，而struct作为常用的自定义数据类型的关键字。说到这里相比大家已经明白interface的侧重点在于接口的定义（方法），而struct侧重点在于数据结构的定义。使用struct定义了数据结构，可以直接使用func方法定义数据结构中使用的方法。&lt;span&gt;但是为了解耦，为了扩展，一般在真正设置功能性函数时，除了内置的数据类型外，都推荐使用接口的方法来传递相关方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;既然推荐使用接口的方法来作为参数，那么具体结构中的数据成员又如何访问呢？golang提供了非常方便的类型查询和类型转换方法。&lt;span&gt;名称.(type)用于类型查询,名称.(具体类型)用于类型转换&lt;/span&gt;。因此，使用接口作为函数参数是很有价值的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;另外，我们还需要明白对象和对象指针在golang中的微妙处理，golang可以自动将对数据类型定义的方法抓转换成对数据类型指针定义的方法。但不能自动的将对数据类型指针的方法转换为对数据类型定义的方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以下是我们的测试程序，注释已经注明了相关说明。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package main

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fmt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

//&lt;span&gt;定义一个接口
type Stryc interface {
    Int() int
}

&lt;/span&gt;//&lt;span&gt;定义一个自定义数据类型
type myCls struct {
    value int
}
&lt;/span&gt;//&lt;span&gt;使用数据类型指针绑定方法（在调用方法时，数据类型在golang中会默认转换为数据类型指针进行使用）
func(a &lt;/span&gt;*&lt;span&gt; myCls) Int() int{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; a.value
}
&lt;/span&gt;//&lt;span&gt;定义一个函数，参数为一个自定义的数据类型
func printTheValueByStruct(arg myCls){
    fmt.Printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;the value is %d \n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,arg.Int())
}
&lt;/span&gt;//&lt;span&gt;定义一个函数，参数为一个接口
func printTheValue(arg Stryc) int{
    fmt.Printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;the value is %d \n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,arg.Int()/*使用接口调用接口的方法*/&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; arg.Int()
}

&lt;/span&gt;//&lt;span&gt;定义一个函数，参数为动态个数的接口类型参数
func printAnyValue(args ...interface{}){
    &lt;/span&gt;//&lt;span&gt;使用for range方法获取每一个接口
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; _,arg :=&lt;span&gt; range args{
        &lt;/span&gt;//&lt;span&gt;使用.(type)方法查询接口的数据类型
        switch arg.(type) {
        case int:
            fmt.Println(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;the type is int&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        case string:
            fmt.Println(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;the type is string&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        case myCls:&lt;/span&gt;/*是自定义数据类型*/
            //&lt;span&gt;使用.(数据类型)进行强转
            var b myCls &lt;/span&gt;=&lt;span&gt; arg.(myCls)
            fmt.Println(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;the type is myCls, the function value is &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, b.Int()/*d调用数据类型的方法，golang会转换为数据指针类型调用*/,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;the struct value is &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, b.value/*调用数据结构的数据*/&lt;span&gt;)
        case Stryc:&lt;/span&gt;/*是定义的接口数据类型*/&lt;span&gt;
            fmt.Println(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;the type is Stryc interface, the function value is &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, arg.(Stryc).Int()/*将接口强转到指定接口，并调用方法*/&lt;span&gt;)
        }
    }
}

func main(){
    var    V1 &lt;/span&gt;*myCls = new(myCls) //&lt;span&gt;创建一个对象指针
    V1.value &lt;/span&gt;= 1111111 //&lt;span&gt;给对象赋值
    var V2 myCls &lt;/span&gt;= myCls{222222222} //&lt;span&gt;创建一个对象，给对象赋值
    var a interface {}&lt;/span&gt;=myCls{33333} //&lt;span&gt;创建一个对象，将对象赋值后传给一个万能类型接口
    var a1 interface{}&lt;/span&gt;=&amp;amp;myCls{444444}//&lt;span&gt;创建一个对象，将对象指针传给一个万能类型接口
    fmt.Println(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello world!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

    printTheValue(V1) &lt;/span&gt;//&lt;span&gt;V1会转换为Stryc接口被调用其中的方法
    printTheValue(a1.(Stryc)) &lt;/span&gt;//&lt;span&gt;万能接口a1中放置的对象指针被强制转为Stryc接口调用
    printTheValueByStruct(&lt;/span&gt;*V1) //强制将V1的对象使用*&lt;span&gt;显示传入函数，因为参数是对象
    printTheValueByStruct(a.(myCls))&lt;/span&gt;//&lt;span&gt;强制将万能接口a中放置的对象转换为对象传入函数，因为参数是对象

    printTheValue(&lt;/span&gt;&amp;amp;V2) //&lt;span&gt;将对象的指针传入函数，golang将其转换为Stryc接口
    printAnyValue(V1&lt;/span&gt;/*传入一个指针，会同Stryc接口数据类型匹配*/&lt;span&gt;,
                  V2&lt;/span&gt;/*传入一个对象，会同myCls数据类型匹配*/&lt;span&gt;,
                  &lt;/span&gt;*V1/*将指针显示为对象传入，会同myCls数据类型匹配*/&lt;span&gt;,
                  &lt;/span&gt;&amp;amp;V2/*将对象的指针传入，会同Stryc接口数据类型匹配*/&lt;span&gt;)
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以下是执行结果&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;hello world!
the value &lt;/span&gt;&lt;span&gt;is&lt;/span&gt; &lt;span&gt;1111111&lt;/span&gt;&lt;span&gt; 
the value &lt;/span&gt;&lt;span&gt;is&lt;/span&gt; &lt;span&gt;444444&lt;/span&gt;&lt;span&gt; 
the value &lt;/span&gt;&lt;span&gt;is&lt;/span&gt; &lt;span&gt;1111111&lt;/span&gt;&lt;span&gt; 
the value &lt;/span&gt;&lt;span&gt;is&lt;/span&gt; &lt;span&gt;33333&lt;/span&gt;&lt;span&gt; 
the value &lt;/span&gt;&lt;span&gt;is&lt;/span&gt; &lt;span&gt;222222222&lt;/span&gt;&lt;span&gt; 
the type &lt;/span&gt;&lt;span&gt;is&lt;/span&gt; Stryc &lt;span&gt;interface&lt;/span&gt;, the &lt;span&gt;function&lt;/span&gt; value &lt;span&gt;is&lt;/span&gt;  &lt;span&gt;1111111&lt;/span&gt;&lt;span&gt;
the type &lt;/span&gt;&lt;span&gt;is&lt;/span&gt; myCls, the &lt;span&gt;function&lt;/span&gt; value &lt;span&gt;is&lt;/span&gt;  &lt;span&gt;222222222&lt;/span&gt; the struct value &lt;span&gt;is&lt;/span&gt;  &lt;span&gt;222222222&lt;/span&gt;&lt;span&gt;
the type &lt;/span&gt;&lt;span&gt;is&lt;/span&gt; myCls, the &lt;span&gt;function&lt;/span&gt; value &lt;span&gt;is&lt;/span&gt;  &lt;span&gt;1111111&lt;/span&gt; the struct value &lt;span&gt;is&lt;/span&gt;  &lt;span&gt;1111111&lt;/span&gt;&lt;span&gt;
the type &lt;/span&gt;&lt;span&gt;is&lt;/span&gt; Stryc &lt;span&gt;interface&lt;/span&gt;, the &lt;span&gt;function&lt;/span&gt; value &lt;span&gt;is&lt;/span&gt;  &lt;span&gt;222222222&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Wed, 27 Mar 2019 15:42:00 +0000</pubDate>
<dc:creator>在左手</dc:creator>
<og:description>再golang中，我们要充分理解interface和struct这两种数据类型。为此，我们需要优先理解type的作用。 type是golang语言中定义数据类型的唯一关键字。对于type中的匿名成员和</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhangdewang/p/10612089.html</dc:identifier>
</item>
<item>
<title>AtCoder Beginner Contest 121 题解 - Bil369</title>
<link>http://www.cnblogs.com/Bil369/p/10612082.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Bil369/p/10612082.html</guid>
<description>&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; #include &amp;lt;iostream&amp;gt;
&lt;span&gt; 2&lt;/span&gt; #include &amp;lt;cstdio&amp;gt;
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n, m, c;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d %d %d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &amp;amp;n, &amp;amp;m, &amp;amp;&lt;span&gt;c);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; b[&lt;span&gt;25&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; m; ++&lt;span&gt;i)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &amp;amp;&lt;span&gt;b[i]);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; ans = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; n; ++&lt;span&gt;i)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; tmp, sum = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; m; ++&lt;span&gt;j)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &amp;amp;&lt;span&gt;tmp);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             sum += tmp *&lt;span&gt; b[j];
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(sum + c &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             ++&lt;span&gt;ans;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, ans);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; }
&lt;/pre&gt;</description>
<pubDate>Wed, 27 Mar 2019 15:37:00 +0000</pubDate>
<dc:creator>Bil369</dc:creator>
<og:description>题目链接：https://atcoder.jp/contests/abc121 A White Cells 分析：题目数据规模很小，直接暴力修改都可以。或者可以推出公式. 代码： 1 #include</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Bil369/p/10612082.html</dc:identifier>
</item>
<item>
<title>【效率工具】SSH一键登录脚本（可一键从跳板机登录线上服务器） - 弗兰克的猫</title>
<link>http://www.cnblogs.com/mfrank/p/10612076.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mfrank/p/10612076.html</guid>
<description>&lt;h2 id=&quot;说明&quot;&gt;说明&lt;/h2&gt;
&lt;p&gt;前阵子上线，一次性上了十个服务，一直上到凌晨才完事，期间每个服务都要先输入跳板机的登录信息来登录跳板机，然后再输入线上服务器的信息来登录线上服务器，实在是太过于麻烦，而且有些服务还有好几台服务器，检查问题的时候，服务器跳来跳去的，简直苦不堪言。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/03/27/5c9b91a70e5ca.png&quot; alt=&quot;20190327230716.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;于是，便萌发了用shell脚本的方式来一键跳转的想法，先上github上搜了搜现成的轮子，发现都不太好用，要不就是没说明，要不就是只能登一台服务器，不能满足从跳板机A跳转到线上服务器B的需求。&lt;/p&gt;
&lt;p&gt;所以，还是自己动手，丰衣足食。&lt;/p&gt;
&lt;h2 id=&quot;shell脚本&quot;&gt;Shell脚本&lt;/h2&gt;
&lt;p&gt;Shell脚本已经发布到了&lt;code&gt;github&lt;/code&gt;上，链接在此：&lt;a href=&quot;https://github.com/MFrank2016/GotoSSH&quot; class=&quot;uri&quot;&gt;https://github.com/MFrank2016/GotoSSH&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个脚本借鉴了&lt;code&gt;AutoSSH&lt;/code&gt;的脚本，并将其进行了修改，使得能够支持从跳板机直接跳转登录服务器。&lt;/p&gt;
&lt;h2 id=&quot;使用说明&quot;&gt;使用说明&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;GotoSSH&lt;/code&gt;是一个一键登录SSH的脚本，可直接从跳板机登录到线上服务器，致力于帮助你提高工作效率。&lt;/p&gt;
&lt;h2 id=&quot;安装依赖&quot;&gt;安装依赖&lt;/h2&gt;
&lt;p&gt;CentOS :&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ sudo yum install -y expect&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Ubuntu :&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ sudo apt-get install tcl tk expect&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Mac :&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ sudo brew install expect&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;安装-gotossh&quot;&gt;安装 GotoSSH&lt;/h2&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ git clone https://github.com/MFrank2016/GotoSSH.git
$ cd GotoSSH
$ chmod a+x gotossh
$ sudo cp gotossh /usr/local/bin/&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;配置&quot;&gt;配置&lt;/h2&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ vim ~/.gotossh_config
server_name|ip|username|password|port|rely_server_no&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后一列是代表该服务器依赖于哪个服务器，如果该列的值设置为0，代表不依赖于其他服务器，否则代表需要先登录其他服务器后才能登录该服务器，目前暂时只能从A跳转到B，不支持多跳转，感觉没有必要，如果有需要，把脚本稍微改改就行了。&lt;/p&gt;
&lt;h2 id=&quot;举个栗子&quot;&gt;举个栗子&lt;/h2&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ vim ~/.gotossh_config
test_server|192.168.0.1|root|password|22|0
online_server|192.168.2.2|root|password|22|1&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;使用说明-1&quot;&gt;使用说明&lt;/h2&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ gotossh
######################################################################################
#                                  [GOTO SSH]                                        #
#                                                                                    #
#                                                                                    #
# [1] test_server - 192.168.0.1:root                                                 #
# [2] online_server - 192.168.2.2:root                                               #
#                                                                                    #
#                                                                                    #
######################################################################################
Server Number:(Input Server Number Here)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;OR&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;gotossh 1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;OR&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;gotossh 2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为配置文件里设置了服务器2依赖于服务器1，所以会先登录服务器1，然后再登录服务器2。&lt;/p&gt;
&lt;p&gt;这样，只需要小手一点，就能直接登录线上服务器，岂不是美滋滋。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/03/27/5c9b93b7d1c8a.png&quot; alt=&quot;20190327231606.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;虽然只是一个简单的脚本，奈何道法太浅，硬生生折腾了大半天才调试完成，但也算是了却了一桩心愿。&lt;/p&gt;
&lt;p&gt;独乐了不如众乐乐，特此分享给大家，希望能对大家有所帮助。&lt;/p&gt;
&lt;p&gt;如果觉得还不错，别忘了加个star✨也欢迎关注我的公众号留言交流。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/03/14/5c8a58ba229ca.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 27 Mar 2019 15:35:00 +0000</pubDate>
<dc:creator>弗兰克的猫</dc:creator>
<og:description>说明 前阵子上线，一次性上了十个服务，一直上到凌晨才完事，期间每个服务都要先输入跳板机的登录信息来登录跳板机，然后再输入线上服务器的信息来登录线上服务器，实在是太过于麻烦，而且有些服务还有好几台服务器</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mfrank/p/10612076.html</dc:identifier>
</item>
<item>
<title>数据结构学习之双链表基本操作 - xq17</title>
<link>http://www.cnblogs.com/xq17dog/p/10612070.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xq17dog/p/10612070.html</guid>
<description>&lt;h2 id=&quot;x1-前言&quot;&gt;0x1 前言&lt;/h2&gt;
&lt;p&gt;今天实验课,学习了下双链表的写法,这里记录下。&lt;/p&gt;
&lt;h2 id=&quot;x2-正文&quot;&gt;0x2 正文&lt;/h2&gt;
&lt;p&gt;题目要求如下:&lt;br/&gt;本实验的双链链表元素的类型为char，完成如下实验要求：&lt;/p&gt;
&lt;p&gt;（1）初始化单链表h&lt;/p&gt;
&lt;p&gt;（2）采用尾插法依次插入a、b、c、d、e&lt;/p&gt;
&lt;p&gt;（3）输出单链表h&lt;/p&gt;
&lt;p&gt;（4）输出单链表h的长度&lt;/p&gt;
&lt;p&gt;（5）判断单链表h是否为空&lt;/p&gt;
&lt;p&gt;（6）输出单链表h的第3个元素&lt;/p&gt;
&lt;p&gt;（7）输出元素a的逻辑位置&lt;/p&gt;
&lt;p&gt;（8）在第4个元素位置上插入元素f&lt;/p&gt;
&lt;p&gt;（9）输出单链表h&lt;/p&gt;
&lt;p&gt;（10）删除单链表h的第3个元素&lt;/p&gt;
&lt;p&gt;（11）输出单链表h&lt;/p&gt;
&lt;p&gt;（12）释放单链表h&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;cstdlib&amp;gt;

using namespace std;

typedef char Elemtype;

typedef struct DNode
{
    Elemtype data; //存放元素值
    struct DNode * prior; //指向前驱结点
    struct DNode * next; //指向后继结点
}DLinkNode;

// 初始化双链表
void InitList(DLinkNode *&amp;amp;h)
{
    h=(DLinkNode *)malloc(sizeof(DLinkNode));
    h-&amp;gt;prior=h-&amp;gt;next=NULL; //前后指针域置为空
}

// 尾插法插入
void InsertListR(DLinkNode *&amp;amp;h,Elemtype a[],int n)
{
    DLinkNode *s,*r;
    r=h;
    for(int i=0;i&amp;lt;n;i++)
    {
        s=(DLinkNode *)malloc(sizeof(DLinkNode));
        s-&amp;gt;data=a[i];
        r-&amp;gt;next=s;
        s-&amp;gt;prior=r;
        r=s;
    }
    r-&amp;gt;next=NULL;
}

//输出双链表
void DispList(DLinkNode *h)
{
    DLinkNode *p;
    p=h-&amp;gt;next;
    while(p!=NULL)
    {
        printf(&quot;%c &quot;,p-&amp;gt;data);
        p=p-&amp;gt;next;
    }
    printf(&quot;\n&quot;);
}

//输出双链表h的长度
int ListLength(DLinkNode *h)
{
    int n=0;
    DLinkNode *p=h-&amp;gt;next;
    while(p!=NULL)
    {
        n++;
        p=p-&amp;gt;next;
    }
    return(n);
}

//判断线性表是否为空表
bool ListEmpty(DLinkNode *h)
{
    return(h-&amp;gt;next==NULL);
}

//输出指定下标的元素
char LocateElemByIndex(DLinkNode *h,int i)
{
    DLinkNode *p=h;
    while(p-&amp;gt;next!=NULL&amp;amp;&amp;amp;i)
    {
        i--;
        p=p-&amp;gt;next;
    }
    if(p-&amp;gt;next==NULL)
    {
        return(false);
    }
    else
        return(p-&amp;gt;data);
}

// 输出指定元素的位置
int LocateElem(DLinkNode *h,Elemtype e)
{
    int n=1;
    DLinkNode *p=h-&amp;gt;next;
    while(p!=NULL&amp;amp;&amp;amp;p-&amp;gt;data!=e)
    {
        n++;
        p=p-&amp;gt;next;
    }
    if(p==NULL)
    {
        return(0);
    }else
        return(n);
}

//在指定位置插入指定的元素
bool ListInsert(DLinkNode *&amp;amp;h,int i,Elemtype e)
{
    DLinkNode *p=h,*s;
    int j=0;
    if(i&amp;lt;=0) return(false);
    while(j&amp;lt;i-1&amp;amp;&amp;amp;p!=NULL)
    {
        j++;
        p=p-&amp;gt;next;
    }
    if(p==NULL)
    {
        return false;
    }
    s=(DLinkNode *)malloc(sizeof(DLinkNode));
    s-&amp;gt;data=e;
    s-&amp;gt;prior=p;
    s-&amp;gt;next=p-&amp;gt;next;
    if(p-&amp;gt;next!=NULL)
        p-&amp;gt;next-&amp;gt;prior=s;
    p-&amp;gt;next=s;
    return(true);
}

//删除指定下标元素
bool ListDelete(DLinkNode *&amp;amp;h,int i,Elemtype &amp;amp;e)
{
    DLinkNode *p=h,*q;
    int j=0;
    if(i&amp;lt;=0) return(false);
    while(j&amp;lt;i-1&amp;amp;&amp;amp;p!=NULL)
    {
        j++;
        p=p-&amp;gt;next;
    }
    if(p==NULL)
    {
        return(false);
    }else
    {
        q=p-&amp;gt;next;
        if(q==NULL)
            return(false);
        e=q-&amp;gt;data;
        p-&amp;gt;next=q-&amp;gt;next;
        if(p-&amp;gt;next!=NULL)
            q-&amp;gt;prior=p;
        free(q);
        return(true);
    }
}

//释放循环链表
void DestroyList(DLinkNode *&amp;amp;h)
{
    DLinkNode *pre=h,*p=h-&amp;gt;next;
    while(p!=NULL)
    {
        free(pre);
        pre=p;
        p=p-&amp;gt;next;
    }
    free(pre);
    cout&amp;lt;&amp;lt; &quot;List has been destroyed!&quot; &amp;lt;&amp;lt;endl;
}
int main()
{
    DLinkNode *h;
    char e;
    InitList(h);
    char a[5]={'a','b','c','d','e'};
    InsertListR(h,a,5);
    DispList(h);
    cout&amp;lt;&amp;lt; ListLength(h) &amp;lt;&amp;lt;endl;
    if(ListEmpty(h))
    {
        cout&amp;lt;&amp;lt; &quot;List is Empty!&quot;&amp;lt;&amp;lt;endl;
    }else
    {
        cout&amp;lt;&amp;lt;&quot;List isn't Empty!&quot;&amp;lt;&amp;lt;endl;
    };
    cout&amp;lt;&amp;lt; LocateElemByIndex(h,3)&amp;lt;&amp;lt;endl;
    cout&amp;lt;&amp;lt; LocateElem(h,'a')&amp;lt;&amp;lt;endl;
    ListInsert(h,4,'f');
    DispList(h);
    ListDelete(h,3,e);
    DispList(h);
    DestroyList(h);
    return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果如下图:&lt;br/&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/006tKfTcgy1g1fhjhb2pbj30pq0f6jsj.jpg&quot; alt=&quot;image-20190326000315437&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;x3-总结&quot;&gt;0x3 总结&lt;/h2&gt;
&lt;p&gt;感觉和单链表不是很大区别,主要是在插入或者删除的时候注意处理下前继指针,比如判断后继是否存在,然后修改后继的前继指针。&lt;/p&gt;
</description>
<pubDate>Wed, 27 Mar 2019 15:34:00 +0000</pubDate>
<dc:creator>xq17</dc:creator>
<og:description>数据结构学习之双链表基本操作 0x1 前言 今天实验课,学习了下双链表的写法,这里记录下。 0x2 正文 题目要求如下: 本实验的双链链表元素的类型为char，完成如下实验要求： （1）初始化单链表h</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xq17dog/p/10612070.html</dc:identifier>
</item>
<item>
<title>java并发编程（一） - 正先生</title>
<link>http://www.cnblogs.com/zhxiansheng/p/10611994.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhxiansheng/p/10611994.html</guid>
<description>&lt;h3 id=&quot;引言&quot;&gt;引言&lt;/h3&gt;
&lt;p&gt;多线程的知识点是一个庞大的体现，对此也是一知半解。一直想系统的深入的学习多线程的知识，奈何一直没有找到机会，好吧，其实就是懒。最近在项目中接触到一个多并发的项目，在项目中踩了无数的坑。在此下定决心做一个并发的学习笔记。&lt;/p&gt;
&lt;h3 id=&quot;为什么并发会有安全问题&quot;&gt;为什么并发会有安全问题&lt;/h3&gt;
&lt;p&gt;当两个线程同时对一个共享可变变量进行操作时，例如：&lt;br/&gt;两个线程对变量i=1同时执行i++操作。执行完毕后i可能并不等于3而是等于2。因为i++不是&lt;strong&gt;原子性&lt;/strong&gt;的操作,i++实际上是有三个步骤&lt;br/&gt;第一步：读取，从主内存中将i=1读取到本地内存中。&lt;br/&gt;第二步：修改，i自增。&lt;br/&gt;第三部：写入，将i=2写会到缓存中。&lt;br/&gt;所以当两个线程同时将i读取到工作内存中，并分别将变量i赋值为2。&lt;/p&gt;
&lt;h3 id=&quot;原子性&quot;&gt;原子性&lt;/h3&gt;
&lt;p&gt;原子性是指一个操作是不可中断的，要么全部执行成功要么全部执行失败，有着“同生共死”的感觉。及时在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程所干扰。&lt;/p&gt;
&lt;h3 id=&quot;可见性&quot;&gt;可见性&lt;/h3&gt;
&lt;p&gt;可见性是指当一个线程修改了共享变量后，其他线程能够立即得知这个修改。为什么要这样说？难道一个线程修改了共享变量其他线程不一定会立即得知这个变量的修改？没错事实确实如此。&lt;br/&gt;简单的举一个例子。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190327224853558.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F6czE1NDkxMTA3Mw==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;数据 i 是存储在主内存中的，当一个线程执行 i++ 操作的时候首先将 i 从主内存读取到自己线程的工作内存中（也就是&lt;strong&gt;缓冲行&lt;/strong&gt;），然后将工作内存的 i 执行+1操作。如果是单线程程序，在没有其他写入操作的情况下读取这个值，首先会读取缓冲行，缓存命中。那么总能得到 +1 操作之后的值。&lt;br/&gt;但是多线程环境结果则会违背我们的直觉。&lt;br/&gt;由于操作系统的执行，我们并不知道工作内存中的值何时才能被写入到主内存中（理由很简单，我们不可能每次修改了缓存，操作系统就会将值瞬间刷入到主内存吧？这样效率会多低呀）。所以如果这之前另一个线程从主内存读取 i 的值到本地工作内存中。那么他可能并不会感知到另一个线程其实已经修改了 i 的值。&lt;br/&gt;为什么synchronized和volatile可以实现可见性我们在后续会继续介绍。&lt;/p&gt;
&lt;h3 id=&quot;如何避免并发问题&quot;&gt;如何避免并发问题&lt;/h3&gt;
&lt;p&gt;1.不在线程之间共享该状态变量。&lt;br/&gt;2.将状态变量修改为不可变的变量。&lt;br/&gt;3.在访问状态变量时使用同步。&lt;/p&gt;
&lt;h3 id=&quot;synchronized&quot;&gt;Synchronized&lt;/h3&gt;
&lt;p&gt;在多线程并发中synchronized一直是元老级别的角色。利用synchronized来实现同步具体有一下三种表现形式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对于普通的同步方法，锁是当前实例对象。&lt;/li&gt;
&lt;li&gt;对于静态同步方法，锁是当前类的class对象。&lt;/li&gt;
&lt;li&gt;对于同步方法块，锁是synchronized括号里配置的对象。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当一个代码，方法或者类被synchronized修饰以后。当一个线程试图访问同步代码块的时候，它首先必须得到锁，退出或抛出异常的时候必须释放锁。那么这样做有什么好处呢？&lt;br/&gt;它主要确保多个线程在同一时刻，只能有一个线程处于方法或者同步块中，它保证了线程对变量的&lt;strong&gt;可见性&lt;/strong&gt;和&lt;strong&gt;排他性&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int i = 1;
public sychronized void increment(){
i++;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在前面介绍过i++并不是原子操作，所有当多个线程同时操作i++的时候可能会出现多线程并发问题。而上诉代码块中i++是在synchronized修饰的方法中。其中一个线程进入该方法首先获得当前实例对象的锁，当另一个线程试图执行该方法的时候，由于前一个线程并没有执行完毕释放掉锁，所以该线程挂起等待锁的释放。&lt;br/&gt;通过加锁的方式我们实现了将i++非原子操作的方法变成了原子操作的方法。从而实现了&lt;strong&gt;排他性&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如下图所示，一个普通的方法会有一个左右摆动的开关，可以连接到任意一个线程，如果该方法不是原子性的，那么可能方法并没有执行完毕就会链接到另一个方法。而被synchronized修饰的方法，链接到一个线程后，除非这个线程将方法执行完毕或者抛出异常，开关才会链接至别的线程。就这样将一个并行的操作变了穿行&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190327220345127.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F6czE1NDkxMTA3Mw==,size_16,color_FFFFFF,t_70&quot; alt=&quot;帮你买吧&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;无论synchronized关键字加在方法上还是对象上，如果它作用的对象是非静态的，则它取得的锁是对象；如果synchronized作用的对象是一个静态方法或一个类，则它取得的锁是对类，该类所有的对象同一把锁。&lt;/li&gt;
&lt;li&gt;每个对象只有一个锁（lock）与之相关联，谁拿到这个锁谁就可以运行它所控制的那段代码。&lt;/li&gt;
&lt;li&gt;实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;synchronized的原理&quot;&gt;Synchronized的原理&lt;/h3&gt;
&lt;p&gt;synchronized用的锁是存在java对象头里的。&lt;br/&gt;锁一共有4个状态，级别从低到高依次是：无所状态、偏向锁状态、轻量级锁状态和重量级锁状态。对于这四种状态《java并发编程艺术》讲解的特别好，有兴趣可以看看这本书的介绍。&lt;br/&gt;总体来说，通过对象头存储的记录指针，互斥指正，标志位等信息来说明当前是对象是被某个线程所使用的，此时别的线程想要获取这把锁要么cas自旋要么线程阻塞。&lt;/p&gt;
</description>
<pubDate>Wed, 27 Mar 2019 15:20:00 +0000</pubDate>
<dc:creator>正先生</dc:creator>
<og:description>引言 多线程的知识点是一个庞大的体现，对此也是一知半解。一直想系统的深入的学习多线程的知识，奈何一直没有找到机会，好吧，其实就是懒。最近在项目中接触到一个多并发的项目，在项目中踩了无数的坑。在此下定决</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhxiansheng/p/10611994.html</dc:identifier>
</item>
<item>
<title>利用好浏览器的空闲时间 --- requestIdleCallback - 刘哇勇</title>
<link>http://www.cnblogs.com/Wayou/p/requestIdleCallback.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Wayou/p/requestIdleCallback.html</guid>
<description>&lt;h3&gt;页面流畅与 FPS&lt;/h3&gt;
&lt;p&gt;页面是一帧一帧绘制出来的，当每秒绘制的帧数（FPS）达到 60 时，页面是流畅的，小于这个值时，用户会感觉到卡顿。&lt;/p&gt;
&lt;p&gt;1s 60帧，所以每一帧分到的时间是 1000/60 ≈ 16 ms。所以我们书写代码时力求不让一帧的工作量超过 16ms。&lt;/p&gt;
&lt;h3&gt;Frame&lt;/h3&gt;
&lt;p&gt;那么浏览器每一帧都需要完成哪些工作？&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://user-images.githubusercontent.com/3783096/51423451-4a5f1f80-1bfb-11e9-8c0a-597f0d52f4c0.png&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/3783096/51423451-4a5f1f80-1bfb-11e9-8c0a-597f0d52f4c0.png&quot; alt=&quot;image&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;em&gt;浏览器一帧内的工作&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;通过上图可看到，一帧内需要完成如下六个步骤的任务：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;处理用户的交互&lt;/li&gt;
&lt;li&gt;JS 解析执行&lt;/li&gt;
&lt;li&gt;帧开始。窗口尺寸变更，页面滚去等的处理&lt;/li&gt;
&lt;li&gt;rAF&lt;/li&gt;
&lt;li&gt;布局&lt;/li&gt;
&lt;li&gt;绘制&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;requestIdleCallback&lt;/h3&gt;
&lt;p&gt;上面六个步骤完成后没超过 16 ms，说明时间有富余，此时就会执行 &lt;code&gt;requestIdleCallback&lt;/code&gt; 里注册的任务。&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://user-images.githubusercontent.com/3783096/51231779-9b72d780-199f-11e9-8e65-eb9df90921ce.png&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/3783096/51231779-9b72d780-199f-11e9-8e65-eb9df90921ce.png&quot; alt=&quot;image&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;em&gt;&lt;code&gt;requestIdleCallback&lt;/code&gt; 在浏览器一帧内的位置示意&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;从上图也可看出，和 &lt;code&gt;requestAnimationFrame&lt;/code&gt; 每一帧必定会执行不同，&lt;code&gt;requestIdleCallback&lt;/code&gt; 是捡浏览器空闲来执行任务。&lt;/p&gt;
&lt;p&gt;如此一来，假如浏览器一直处于非常忙碌的状态，&lt;code&gt;requestIdleCallback&lt;/code&gt; 注册的任务有可能永远不会执行。此时可通过设置 &lt;code&gt;timeout&lt;/code&gt; （见下面 API 介绍）来保证执行。&lt;/p&gt;
&lt;h4&gt;API&lt;/h4&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; handle &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;window&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;requestIdleCallback&lt;/span&gt;(callback[, options])
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;callback: ()&lt;/code&gt;：回调即空闲时需要执行的任务，接收一个 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/IdleDeadline&quot; rel=&quot;nofollow&quot;&gt;&lt;code&gt;IdleDeadline&lt;/code&gt;&lt;/a&gt; 对象作为入参。其中 &lt;code&gt;IdleDeadline&lt;/code&gt; 对象包含：
&lt;ul&gt;&lt;li&gt;&lt;code&gt;didTimeout&lt;/code&gt;，布尔值，表示任务是否超时，结合 &lt;code&gt;timeRemaining&lt;/code&gt; 使用。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;timeRemaining()&lt;/code&gt;，表示当前帧剩余的时间，也可理解为留给任务的时间还有多少。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;options&lt;/code&gt;：目前 options 只有一个参数
&lt;ul&gt;&lt;li&gt;&lt;code&gt;timeout&lt;/code&gt; 。表示超过这个时间后，如果任务还没执行，则强制执行，不必等待空闲。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;示例&lt;/h4&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;11&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-en&quot;&gt;requestIdleCallback&lt;/span&gt;(myNonEssentialWork, { timeout&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;2000&lt;/span&gt; });

&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;myNonEssentialWork&lt;/span&gt; (&lt;span class=&quot;pl-smi&quot;&gt;deadline&lt;/span&gt;) {

  &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; 如果帧内有富余的时间，或者超时&lt;/span&gt;
  &lt;span class=&quot;pl-k&quot;&gt;while&lt;/span&gt; ((&lt;span class=&quot;pl-smi&quot;&gt;deadline&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;timeRemaining&lt;/span&gt;() &lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;deadline&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;didTimeout&lt;/span&gt;) &lt;span class=&quot;pl-k&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
         &lt;span class=&quot;pl-smi&quot;&gt;tasks&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;)
    &lt;span class=&quot;pl-en&quot;&gt;doWorkIfNeeded&lt;/span&gt;();

  &lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;pl-smi&quot;&gt;tasks&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;)
    &lt;span class=&quot;pl-en&quot;&gt;requestIdleCallback&lt;/span&gt;(myNonEssentialWork);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;超时的情况，其实就是浏览器很忙，没有空闲时间，此时会等待指定的 &lt;code&gt;timeout&lt;/code&gt; 那么久再执行，通过入参 &lt;code&gt;dealine&lt;/code&gt; 拿到的 &lt;code&gt;didTmieout&lt;/code&gt; 会为 &lt;code&gt;true&lt;/code&gt;，同时 &lt;code&gt;timeRemaining ()&lt;/code&gt; 返回的也是 0。超时的情况下如果选择继续执行的话，肯定会出现卡顿的，因为必然会将一帧的时间拉长。&lt;/p&gt;
&lt;h4&gt;cancelIdleCallback&lt;/h4&gt;
&lt;p&gt;与 &lt;code&gt;setTimeout&lt;/code&gt; 类似，返回一个唯一 id，可通过 &lt;code&gt;cancelIdleCallback&lt;/code&gt; 来取消任务。&lt;/p&gt;
&lt;h3&gt;总结&lt;/h3&gt;
&lt;p&gt;一些低优先级的任务可使用 &lt;code&gt;requestIdleCallback&lt;/code&gt; 等浏览器不忙的时候来执行，同时因为时间有限，它所执行的任务应该尽量是能够量化，细分的微任务（micro task）。&lt;/p&gt;
&lt;p&gt;因为它发生在一帧的最后，此时页面布局已经完成，所以不建议在 &lt;code&gt;requestIdleCallback&lt;/code&gt; 里再操作 DOM，这样会导致页面再次重绘。DOM 操作建议在 rAF 中进行。同时，操作 DOM 所需要的耗时是不确定的，因为会导致重新计算布局和视图的绘制，所以这类操作不具备可预测性。&lt;/p&gt;
&lt;p&gt;Promise 也不建议在这里面进行，因为 Promise 的回调属性 Event loop 中优先级较高的一种微任务，会在 &lt;code&gt;requestIdleCallback&lt;/code&gt; 结束时立即执行，不管此时是否还有富余的时间，这样有很大可能会让一帧超过 16 ms。&lt;/p&gt;
&lt;h3&gt;参考&lt;/h3&gt;
</description>
<pubDate>Wed, 27 Mar 2019 15:20:00 +0000</pubDate>
<dc:creator>刘哇勇</dc:creator>
<og:description>页面流畅与 FPS 页面是一帧一帧绘制出来的，当每秒绘制的帧数（FPS）达到 60 时，页面是流畅的，小于这个值时，用户会感觉到卡顿。 1s 60帧，所以每一帧分到的时间是 1000/60 ≈ 16</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Wayou/p/requestIdleCallback.html</dc:identifier>
</item>
<item>
<title>Hadoop系列-HDFS基础 - zeem0ny</title>
<link>http://www.cnblogs.com/zeem0ny/p/10611952.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zeem0ny/p/10611952.html</guid>
<description>&lt;ol class=&quot;ol-list&quot; start=&quot;&quot; readability=&quot;1&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;5&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;基本原理&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;HDFS（Hadoop Distributed File System）是Hadoop的一个基础的分布式文件系统，这个分布式的概念主要体现在两个地方：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;针对于以上的分布式存储概念，HDFS采用了master/slave的主从结构来构建整个存储系统。之所以可以通过分散的机器组成一个整体式的系统，这其中机器之间的相互通讯必不可少。对于一个程序在不同机器上的通讯，主要是通过远程系统调用RPC（remote procedure call）实现，不同的语言有不同的实现方式，而HDFS是运行于JVM基础上的，那么这里的通讯就是指不同机器的JVM进程之间的通讯。当然，底层的网络通讯主要是socket协议，在实际的工业场景中使用对socket进一步封装的netty实现。接下来，进一步针对数据块、namenode、datanode等进行说明。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;ol class=&quot;ol-list&quot; start=&quot;2&quot; readability=&quot;4&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;2&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;数据块&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;每个计算机的磁盘都有一个默认的数据块（block）大小，这是进行数据读写的最小单位，文件系统通过管理磁盘上的数据块来管理文件。HDFS的block默认大小为128MB，但是于一般单一的磁盘文件系统不同的是，HDFS中小于一个块大小的文件不会占用整个block空间。例如：一个大小为1MB的文件存储在HDFS中时，在默认数据块是128MB的情况下还是只占用1MB，而不是128MB。决定数据传输速度的因素主要是磁盘驱动器的传输速率和文件寻址效率，如果数据块设置的足够大，那么文件寻址的效率就会变高，但也不是无限大，具体block的大小还需要根据具体的业务逻辑进行考虑。对文件进行块抽象的一个明显优点就是文件的大小不受限于任何一台单独的主机的磁盘容量限制，也就使得HDFS更适合数据量比较大的大数据场景。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;namenode&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;整个HDFS集群有管理节点（namenode）和工作节点（datanode）。namenode主要维持两层关系：&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;*&quot; readability=&quot;2&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;第一层：整个集群的目录树结构以及文件的数据块列表；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;5&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;第二层：数据块与各个datanode的映射关系，也包括datanode的一些主机名、磁盘大小等数据。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;/Users/yuzhemin/Desktop/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-03-27%20%E4%B8%8B%E5%8D%889.09.32.png&quot;&gt;&lt;img src=&quot;file:///Users/yuzhemin/Desktop/屏幕快照%202019-03-27%20下午9.09.32.png?lastModify=1553699334&quot; alt=&quot;&quot; data-local-refresh=&quot;true&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1633059/201903/1633059-20190327230924739-973001713.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p class=&quot;md-end-block md-p md-focus&quot;&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;上图展示了namenode维持的两层关系，为了使客户端访问的速度最快，以上的信息会保存在namenode主机的内存中。对于在内存中保存的数据，在断电后就会消失，这显然是不允许的，因此以上信息除了在内存中保存之外还需要在硬盘中保存一份，具体在硬盘中的保存形式为：&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;1&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;secondarynamenode&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;secondarynamenode主要是不定时的观察EditsLog、FSImage的情况，超过一定的阈值情况下对EditsLog和FSImage进行合并，形成新的FSImage文件。这样可以尽量减少namenode本身的负载。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;datanode&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;&lt;span&gt;datanode是主要的数据存储节点，这其中涉及了datanode与namenode的通讯情况。&lt;/span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1633059/201903/1633059-20190327230945430-687513932.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;/Users/yuzhemin/Desktop/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-03-27%20%E4%B8%8B%E5%8D%889.52.12.png&quot;&gt;&lt;img src=&quot;file:///Users/yuzhemin/Desktop/屏幕快照%202019-03-27%20下午9.52.12.png?lastModify=1553699334&quot; alt=&quot;&quot; data-local-refresh=&quot;true&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;*&quot; readability=&quot;0&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;register：将datanode所在主机的信息（如主机名、内存、硬盘）告诉namenode，nemenode通过check相应的信息允许其称为集群中的一员；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;block report：传输block信息给namenode，便于namenode可以维护数据块和数据节点之间的映射关系；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;send heartbeat：&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;ol class=&quot;ol-list&quot; start=&quot;6&quot; readability=&quot;2&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;7&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;federation&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;上文提到，namenode为了尽可能的使客户端的访问效率变高，会将所有的文件系统和数据块的引用信息保存在内存中，如果集群存储的文件量足够多，namenode内存的大小将限制集群的整个性能和可扩展能力。为此，在hadoop2.x中引入了federation机制，通过添加namenode实现扩展。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;federation环境下，每隔namenode维护一个命名空间卷（namespace volume）由命名空间的元数据和数据块池组成，命名空间之间相互独立，互不通信。在这种情况下datanode被用作通用的数据存储设备，每个datanode要向集群中所有的namenode注册，且周期性的向所有namenode发送心跳和报告，并执行来自所有namenode的命令。但是，每个namenode只管理各自的block信息，如果一个namenode挂掉，虽然不会影响到其他的namenode，但是这个namenode管理的数据就不可访问，还是会存在SPOF（single point of failure，即单点故障问题）。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span class=&quot;md-plain&quot;&gt;　　　　以上主要是个人对HDFS的一些基本概念的初步理解，如有错误还请各位大大们指正。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 27 Mar 2019 15:11:00 +0000</pubDate>
<dc:creator>zeem0ny</dc:creator>
<og:description>基本原理 HDFS（Hadoop Distributed File System）是Hadoop的一个基础的分布式文件系统，这个分布式的概念主要体现在两个地方： 数据分块存储在多台主机 数据块采取冗余</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zeem0ny/p/10611952.html</dc:identifier>
</item>
</channel>
</rss>