<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>RN开发中的报错以及告警 - 旭i丿</title>
<link>http://www.cnblogs.com/nixu/p/10071300.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nixu/p/10071300.html</guid>
<description>
&lt;p&gt;&lt;span&gt;报错一:&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Attempted to transition from state `RESPONDER_INACTIVE_PRESS_IN` to `RESPONDER_ACTIVE_LONG_PRESS_IN`, which is not supported. This is most likely due to `Touchable.longPressDelayTimeout` not being cancelled.&lt;/p&gt;

&lt;p&gt;产生原因:&lt;/p&gt;

&lt;p&gt;可能是在Touchablexxx在这组组件中调用onPress方法使产生&lt;/p&gt;

&lt;p&gt;解决方法:&lt;/p&gt;

&lt;p&gt;关闭debug报错就不会产生,不会影响的项目的开发&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;告警一&lt;/span&gt;:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Warning: Can only update a mounted or mounting component. This usually means you called setState, replaceState, or forceUpdate on an unmounted component. This is a no-op.&lt;/p&gt;
&lt;p&gt;Please check the code for the WindProfile component.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;产生的原因&lt;/span&gt;:&lt;/p&gt;
&lt;p&gt;在&lt;span&gt;组&lt;/span&gt;&lt;span&gt;件进行切换是调用的&lt;/span&gt;this.setState&lt;span&gt;未能释放&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;已经销毁&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;而造成的告警&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解决方法&lt;/span&gt;:&lt;/p&gt;
&lt;p class=&quot;pre&quot;&gt;componentWillUnmount() {&lt;br/&gt;    &lt;strong&gt;this&lt;/strong&gt;.setState = (state, callback) =&amp;gt; {&lt;br/&gt;        &lt;strong&gt;return&lt;/strong&gt;;&lt;br/&gt;    };&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;告警二&lt;/span&gt;:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Warning: In next release empty section headers will be rendered. In this release you can use 'enableEmptySections' flag to render empty section headers.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;产生原因&lt;/span&gt;:&lt;/p&gt;
&lt;p&gt;页面中存在空的数据&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解决方法&lt;/span&gt;:&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在&lt;/span&gt;listView&lt;span&gt;中添加&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;pre&quot;&gt;enableEmptySections={&lt;strong&gt;true&lt;/strong&gt;}&lt;/p&gt;

</description>
<pubDate>Wed, 05 Dec 2018 07:40:00 +0000</pubDate>
<dc:creator>旭i丿</dc:creator>
<og:description>报错一: Attempted to transition from state `RESPONDER_INACTIVE_PRESS_IN` to `RESPONDER_ACTIVE_LONG_PRES</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nixu/p/10071300.html</dc:identifier>
</item>
<item>
<title>微信小程序手势滑动卡片案例 - RanceLotus</title>
<link>http://www.cnblogs.com/rancelotus/p/10071286.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rancelotus/p/10071286.html</guid>
<description>&lt;p&gt;最近工作中有项目要使用微信小程序技术进行开发，其中一项功能困扰了我很久，卡片滑动动效以及手势识别。经过一番研究和参考，现在把成果展示。记录自己踩到的坑，如果大家有需要，也可以帮助到大家。&lt;/p&gt;
&lt;p&gt;效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1474434/201812/1474434-20181205153414880-1728020821.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先是卡片布局的实现：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1474434/201812/1474434-20181205144403178-1792454158.png&quot; alt=&quot;&quot; width=&quot;298&quot; height=&quot;503&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　图片（一）&lt;/p&gt;
&lt;p&gt;如图所示，我采用绝对定位absolute的方式，辅助index，可以实现卡片的层叠效果。注意：三张卡片一定都是相同的定位，否则index可能不起作用。&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;101&quot;&gt;
&lt;pre&gt;
//设置position: absolute; left：50%；后，再 margin-left:负(一半的width)；可以实现水平居中&lt;br/&gt;//同理，设置top：50%；margin-top：负（一半height）;可以实现垂直居中
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;.body-swiper &lt;/span&gt;{&lt;span&gt;
  width&lt;/span&gt;:&lt;span&gt; 680rpx&lt;/span&gt;;//rpx是为了适应屏幕&lt;span&gt;
  height&lt;/span&gt;:&lt;span&gt; 900rpx&lt;/span&gt;;&lt;span&gt;
  left&lt;/span&gt;:&lt;span&gt; 50%&lt;/span&gt;;&lt;span&gt;
  position&lt;/span&gt;:&lt;span&gt; absolute&lt;/span&gt;;&lt;span&gt;
  margin-left&lt;/span&gt;:&lt;span&gt; -340rpx&lt;/span&gt;;&lt;span&gt;
  z-index&lt;/span&gt;:&lt;span&gt; 3&lt;/span&gt;;&lt;span&gt;
  box-sizing&lt;/span&gt;:&lt;span&gt; border-box&lt;/span&gt;;&lt;span&gt;
  -webkit-box-shadow&lt;/span&gt;:&lt;span&gt; 0 1px 4px rgba(0, 0, 0, 0.62), 0 0 60px rgba(0, 0, 0, 0.06) inset&lt;/span&gt;;&lt;span&gt;
  -moz-box-shadow&lt;/span&gt;:&lt;span&gt; 0 1px 4px rgba(0, 0, 0, 0.62), 0 0 40px rgba(0, 0, 0, 0.06) inset&lt;/span&gt;;&lt;span&gt;
  box-shadow&lt;/span&gt;:&lt;span&gt; 0 1px 4px rgba(0, 0, 0, 0.62), 0 0 40px rgba(0, 0, 0, 0.06) inset&lt;/span&gt;;&lt;span&gt;
  border-radius&lt;/span&gt;:&lt;span&gt; 12px&lt;/span&gt;;
}&lt;span&gt;

.body-swiper2 &lt;/span&gt;{&lt;span&gt;
  width&lt;/span&gt;:&lt;span&gt; 640rpx&lt;/span&gt;;&lt;span&gt;
  height&lt;/span&gt;:&lt;span&gt; 900rpx&lt;/span&gt;;&lt;span&gt;
  left&lt;/span&gt;:&lt;span&gt; 50%&lt;/span&gt;;&lt;span&gt;
  position&lt;/span&gt;:&lt;span&gt; absolute&lt;/span&gt;;&lt;span&gt;
  margin-left&lt;/span&gt;:&lt;span&gt; -320rpx&lt;/span&gt;;&lt;span&gt;
  z-index&lt;/span&gt;:&lt;span&gt; 2&lt;/span&gt;;&lt;span&gt;
  box-sizing&lt;/span&gt;:&lt;span&gt; border-box&lt;/span&gt;;&lt;span&gt;
  -webkit-box-shadow&lt;/span&gt;:&lt;span&gt; 0 1px 4px rgba(0, 0, 0, 0.62), 0 0 60px rgba(0, 0, 0, 0.06) inset&lt;/span&gt;;&lt;span&gt;
  -moz-box-shadow&lt;/span&gt;:&lt;span&gt; 0 1px 4px rgba(0, 0, 0, 0.62), 0 0 40px rgba(0, 0, 0, 0.06) inset&lt;/span&gt;;&lt;span&gt;
  box-shadow&lt;/span&gt;:&lt;span&gt; 0 1px 4px rgba(0, 0, 0, 0.62), 0 0 40px rgba(0, 0, 0, 0.06) inset&lt;/span&gt;;&lt;span&gt;
  border-radius&lt;/span&gt;:&lt;span&gt; 12px&lt;/span&gt;;
}&lt;span&gt;

.body-swiper3 &lt;/span&gt;{&lt;span&gt;
  width&lt;/span&gt;:&lt;span&gt; 605rpx&lt;/span&gt;;&lt;span&gt;
  height&lt;/span&gt;:&lt;span&gt; 900rpx&lt;/span&gt;;&lt;span&gt;
  left&lt;/span&gt;:&lt;span&gt; 50%&lt;/span&gt;;&lt;span&gt;
  position&lt;/span&gt;:&lt;span&gt; absolute&lt;/span&gt;;&lt;span&gt;
  margin-left&lt;/span&gt;:&lt;span&gt; -302.5rpx&lt;/span&gt;;&lt;span&gt;
  z-index&lt;/span&gt;:&lt;span&gt; 1&lt;/span&gt;;&lt;span&gt;
  box-sizing&lt;/span&gt;:&lt;span&gt; border-box&lt;/span&gt;;&lt;span&gt;
  -webkit-box-shadow&lt;/span&gt;:&lt;span&gt; 0 1px 4px rgba(0, 0, 0, 0.62), 0 0 60px rgba(0, 0, 0, 0.06) inset&lt;/span&gt;;&lt;span&gt;
  -moz-box-shadow&lt;/span&gt;:&lt;span&gt; 0 1px 4px rgba(0, 0, 0, 0.62), 0 0 40px rgba(0, 0, 0, 0.06) inset&lt;/span&gt;;&lt;span&gt;
  box-shadow&lt;/span&gt;:&lt;span&gt; 0 1px 4px rgba(0, 0, 0, 0.62), 0 0 40px rgba(0, 0, 0, 0.06) inset&lt;/span&gt;;&lt;span&gt;
  border-radius&lt;/span&gt;:&lt;span&gt; 12px&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来，是卡片手势的实现；&lt;/p&gt;
&lt;p&gt;上代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
   *  卡片1手势
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  touchstart1: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (event) {
    touchDotX &lt;/span&gt;= event.touches[0].pageX; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取触摸时的原点&lt;/span&gt;
    touchDotY = event.touches[0&lt;span&gt;].pageY;
    console.log(&lt;/span&gt;&quot;起始点的坐标X:&quot; +&lt;span&gt; touchDotX);
    console.log(&lt;/span&gt;&quot;起始点的坐标Y:&quot; +&lt;span&gt; touchDotY);
  },
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 移动结束处理动画&lt;/span&gt;
  touchend1: &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (event) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 手指离开屏幕时记录的坐标&lt;/span&gt;
    let touchMoveX = event.changedTouches[0&lt;span&gt;].pageX;
    let touchMoveY &lt;/span&gt;= event.changedTouches[0&lt;span&gt;].pageY;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 起始点的坐标(x0,y0)和手指离开时的坐标(x1,y1)之差&lt;/span&gt;
    let tmX = touchMoveX -&lt;span&gt; touchDotX;
    let tmY &lt;/span&gt;= touchMoveY -&lt;span&gt; touchDotY;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 两点横纵坐标差的绝对值&lt;/span&gt;
    let absX =&lt;span&gt; Math.abs(tmX);
    let absY &lt;/span&gt;=&lt;span&gt; Math.abs(tmY);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;起始点的坐标(x0,y0)和手指离开时的坐标(x1,y1)之间的距离&lt;/span&gt;
    let delta = Math.sqrt(absX * absX + absY *&lt;span&gt; absY);
    console.log(&lt;/span&gt;'起始点和离开点距离:' + delta + 'px'&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果delta超过60px（可以视情况自己微调）,判定为手势触发&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (delta &amp;gt;= 60&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果 |x0-x1|&amp;gt;|y0-y1|,即absX&amp;gt;abxY,判定为左右滑动&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt; (absX &amp;gt;&lt;span&gt; absY) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如更tmX&amp;lt;0，即(离开点的X)-(起始点X)小于0 ，判定为左滑&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (tmX &amp;lt; 0&lt;span&gt;) {
          console.log(&lt;/span&gt;&quot;左滑=====&quot;&lt;span&gt;);
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行左滑动画&lt;/span&gt;
          &lt;span&gt;this&lt;/span&gt;.Animation1(-500&lt;span&gt;);
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如更tmX&amp;gt;0，即(离开点的X)-(起始点X)大于0 ，判定为右滑&lt;/span&gt;
        } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
          console.log(&lt;/span&gt;&quot;右滑=====&quot;&lt;span&gt;);
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行右滑动画&lt;/span&gt;
          &lt;span&gt;this&lt;/span&gt;.Animation1(500&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果 |x0-x1|&amp;lt;|y0-y1|,即absX&amp;lt;abxY,判定为上下滑动&lt;/span&gt;
      } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如更tmY&amp;lt;0，即(离开点的Y)-(起始点Y)小于0 ，判定为上滑&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (tmY &amp;lt; 0&lt;span&gt;) {
          console.log(&lt;/span&gt;&quot;上滑动=====&quot;&lt;span&gt;);
          &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setData({
            isFront1: &lt;/span&gt;!&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.data.isFront1
          });
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如更tmY&amp;gt;0，即(离开点的Y)-(起始点Y)大于0 ，判定为下滑&lt;/span&gt;
        } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
          console.log(&lt;/span&gt;&quot;下滑动=====&quot;&lt;span&gt;);
          &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setData({
            isFront1: &lt;/span&gt;!&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.data.isFront1
          });
        }
      }
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      console.log(&lt;/span&gt;&quot;手势未触发=====&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 让上一张卡片展现正面（如果之前翻转过的话）&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setData({
      isFront3: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
    });
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为了更直观的看到手势触发的条件，我画了一张图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1474434/201812/1474434-20181205151243140-786784697.png&quot; alt=&quot;&quot; width=&quot;506&quot; height=&quot;395&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　　　图片（二）&lt;/p&gt;
&lt;p&gt;最后是动画的编写；&lt;/p&gt;
&lt;p&gt;上代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
   * 卡片1:
   * 左滑动右滑动动画
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  Animation1: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (translateXX) {
    let animation &lt;/span&gt;=&lt;span&gt; wx.createAnimation({
      duration: &lt;/span&gt;680&lt;span&gt;,
      timingFunction: &lt;/span&gt;&quot;ease&quot;&lt;span&gt;,
    });
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.animation =&lt;span&gt; animation;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果大于0，判定是右滑动画，否则左滑&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (translateXX &amp;gt; 0&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.animation.translateY(0).rotate(20).translateX(translateXX).opacity(0&lt;span&gt;).step();
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.animation.translateY(0).rotate(-20).translateX(translateXX).opacity(0&lt;span&gt;).step();
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置10ms，视觉欺骗，直接归位到原来位置&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.animation.translateY(0).translateX(0).opacity(1).rotate(0&lt;span&gt;).step({
      duration: &lt;/span&gt;10&lt;span&gt;
    });

    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setData({
      animationData1: &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.animation.export(),
    });
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 动画结束后重拍三张卡片&lt;/span&gt;
    setTimeout(() =&amp;gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setData({
        ballTop1: &lt;/span&gt;220&lt;span&gt;,
        ballLeft1: &lt;/span&gt;-302.5&lt;span&gt;,
        ballWidth1: &lt;/span&gt;605&lt;span&gt;,
        index1: &lt;/span&gt;1&lt;span&gt;,

        ballTop2: &lt;/span&gt;240&lt;span&gt;,
        ballLeft2: &lt;/span&gt;-340&lt;span&gt;,
        ballWidth2: &lt;/span&gt;680&lt;span&gt;,
        index2: &lt;/span&gt;3&lt;span&gt;,

        ballTop3: &lt;/span&gt;230&lt;span&gt;,
        ballLeft3: &lt;/span&gt;-320&lt;span&gt;,
        ballWidth3: &lt;/span&gt;640&lt;span&gt;,
        index3: &lt;/span&gt;2&lt;span&gt;,
      })
    }, &lt;/span&gt;500&lt;span&gt;);
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如此一来，大功告成，我自己测试了几次，暂时没有发现什么大问题。如果你有更好的实现方法，欢迎留言。&lt;/p&gt;
&lt;p&gt;代码已上传到github:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/RanceLotusLee/card_test.git&quot; target=&quot;_blank&quot;&gt;https://github.com/RanceLotusLee/card_test.git&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 05 Dec 2018 07:39:00 +0000</pubDate>
<dc:creator>RanceLotus</dc:creator>
<og:description>最近工作中有项目要使用微信小程序技术进行开发，其中一项功能困扰了我很久，卡片滑动动效以及手势识别。经过一番研究和参考，现在把成果展示。记录自己踩到的坑，如果大家有需要，也可以帮助到大家。 效果图： 首</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/rancelotus/p/10071286.html</dc:identifier>
</item>
<item>
<title>美图DPOS以太坊教程（Docker版） - 简玄冰</title>
<link>http://www.cnblogs.com/jianxuanbing/p/10071238.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jianxuanbing/p/10071238.html</guid>
<description>&lt;p&gt;最近，需要接触区块链项目的主链开发，在&lt;code&gt;EOS&lt;/code&gt;、&lt;code&gt;BTC&lt;/code&gt;、&lt;code&gt;ethereum&lt;/code&gt;、&lt;code&gt;超级账本&lt;/code&gt;这几种区块链技术当中，相互对比后，最终还是以&lt;code&gt;go-ethereum&lt;/code&gt;为解决方案。&lt;br/&gt;以&lt;code&gt;ethereum&lt;/code&gt;为基准去找解决方案，最终找到了2个符合自己要求的方案，分别如下：&lt;a href=&quot;https://github.com/meitu/go-ethereum&quot;&gt;美图&lt;/a&gt;、&lt;a href=&quot;https://github.com/TTCECO/gttc&quot;&gt;gttc&lt;/a&gt;。本来是想用&lt;code&gt;gttc&lt;/code&gt;的这个解决方案的，但是它是基于&lt;code&gt;go-ethereum&lt;/code&gt;最新源码来进行二次开发的，相对不稳定，因此还是用&lt;code&gt;美图&lt;/code&gt;的解决方案了，毕竟这公司大一点，没那么多坑。&lt;/p&gt;

&lt;p&gt;为了方便测试，我们需要将节点最大验证器数修改一下，这样便于我们进行简单测试&lt;br/&gt;修改&lt;code&gt;consensus/dpos/dpos.go&lt;/code&gt;文件的&lt;code&gt;maxValidator&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;// 新值
maxValidatorSize = 21
// 旧值
maxValidatorSize = 3&lt;/code&gt;
&lt;/pre&gt;

&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;# 进入源码根目录
docker build . -t meitugeth&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：构建过程中会用到&lt;code&gt;build\env.sh&lt;/code&gt;文件，会提示无权限，因此你需要给该文件赋予执行权限。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;sudo chmod 777 build\env.sh&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;创建节点数据目录&quot;&gt;1. 创建节点数据目录&lt;/h2&gt;
&lt;p&gt;最好事先创建好相应的目录，否则运行后，动态创建目录，会有权限的问题，当然也可以通过命令进行设置目录的权限。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;mkdir ~/data
mkdir ~/data/meitu
mkdir ~/data/meitu/node1
mkdir ~/data/meitu/node2
mkdir ~/data/meitu/node3&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;编写docker-compose.yml文件&quot;&gt;2. 编写docker-compose.yml文件&lt;/h2&gt;
&lt;pre class=&quot;docker&quot;&gt;
&lt;code&gt;version: '3'
services: 
  meitu_node_1:
    image: meitugeth
    container_name: meitu_node_1
    build: 
      context: .
    command: --ipcpath &quot;/root/.ethereum/geth.ipc&quot; --port 30303
    ports: 
      - 15450:8545
      - 15460:8546
      - 10303:30303
      - 10303:30303/udp
      - 10304:30304/udp
    volumes: 
      - /etc/localtime:/etc/localtime
      - ~/data/meitu/node1/:/root/.ethereum/
    environment: 
      TZ: Asia/Shanghai

  meitu_node_2:
    image: meitugeth
    container_name: meitu_node_2
    build: 
      context: .
    command: --ipcpath &quot;/root/.ethereum/geth.ipc&quot; --port 30303
    depends_on: 
      - meitu_node_1
    ports: 
      - 25450:8545
      - 25460:8546
      - 20303:30303
      - 20303:30303/udp
      - 20304:30304/udp
    volumes: 
      - /etc/localtime:/etc/localtime
      - ~/data/meitu/node2/:/root/.ethereum/
    environment: 
      TZ: Asia/Shanghai

  meitu_node_3:
    image: meitugeth
    container_name: meitu_node_3
    build: 
      context: .
    command: --ipcpath &quot;/root/.ethereum/geth.ipc&quot; --port 30303
    depends_on: 
      - meitu_node_1
    ports: 
      - 45450:8545
      - 45460:8546
      - 40303:30303
      - 40303:30303/udp
      - 40304:30304/udp
    volumes: 
      - /etc/localtime:/etc/localtime
      - ~/data/meitu/node3/:/root/.ethereum/
    environment: 
      TZ: Asia/Shanghai&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;启动节点&quot;&gt;3. 启动节点&lt;/h2&gt;
&lt;p&gt;在根目录下启动3个以太坊节点&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;docker-compose up --build -d&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;启动思路&quot;&gt;4. 启动思路&lt;/h2&gt;
&lt;p&gt;美图以太坊这块有2种启动网络：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在创世块里配置好第一验证节点，然后启动&lt;/li&gt;
&lt;li&gt;混合POW和DPOS，用POW进行投票，产生第一批验证节点，并自动切换到DPOS&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;首次启动&quot;&gt;5. 首次启动&lt;/h2&gt;
&lt;h3 id=&quot;进入容器&quot;&gt;1. 进入容器&lt;/h3&gt;
&lt;p&gt;进入容器命令如下：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;# 模板
docker exec -it [容器名|容器ID] /bin/sh
# 例子
docker exec -it meitu_node_1 /bin/sh
docker exec -it meitu_node_2 /bin/sh
docker exec -it meitu_node_3 /bin/sh&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;进入geth-javascript控制台&quot;&gt;2. 进入geth JavaScript控制台&lt;/h3&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;# 方式一
geth attach ipc:/root/.ethereum/geth.ipc
# 方式二
docker exec -it meitu_node_1 geth attach ipc:/root/.ethereum/geth.ipc
# 方式三：使用别名
alias geth=&quot;docker exec -it meitu_node_1 geth attach ipc:/root/.ethereum/geth.ipc&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;创建账户&quot;&gt;3. 创建账户&lt;/h3&gt;
&lt;p&gt;进入geth JavaScript 控制台后，需哟啊创建账户，命令如下;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 模板
personal.newAccount('名称')
# 例子
personal.newAccount('test001')
&quot;0x849f9442198282fb21539351edb0378463e4c251&quot;
personal.newAccount('test002')
&quot;0x2c08f54d5b324c0175ea53b997f5ce1f61a7e4ed&quot;
personal.newAccount('test003')
&quot;0xc4118320f3d3c37a2ca8dad5c2f2a40f2a23ba02&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建成功后，需要将返回的地址记录起来&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;loop：重复1-3步骤，在node1、node2、node3分别创建账户&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;编写创世块配置文件&quot;&gt;4. 编写创世块配置文件&lt;/h3&gt;
&lt;p&gt;将上一步操作生成的地址写入到创世块文件中，三个节点的地址分别为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;0x849f9442198282fb21539351edb0378463e4c251
0x2c08f54d5b324c0175ea53b997f5ce1f61a7e4ed
0xc4118320f3d3c37a2ca8dad5c2f2a40f2a23ba02&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将3个节点地址列入第一批验证人列表&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
    &quot;config&quot;: {
        &quot;chainId&quot;: 7777,
        &quot;eip155Block&quot;: 0,
        &quot;eip158Block&quot;: 0,
        &quot;byzantiumBlock&quot;:0,
        &quot;dpos&quot;:{
            &quot;validators&quot;:[
                &quot;0x849f9442198282fb21539351edb0378463e4c251&quot;,
                &quot;0x2c08f54d5b324c0175ea53b997f5ce1f61a7e4ed&quot;,
                &quot;0xc4118320f3d3c37a2ca8dad5c2f2a40f2a23ba02&quot;
            ]
        }
    },
    &quot;nonce&quot;: &quot;0x0000000000000042&quot;,
    &quot;difficulty&quot;: &quot;0x020000&quot;,
    &quot;mixHash&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;,
    &quot;coinbase&quot;: &quot;0x0000000000000000000000000000000000000000&quot;,
    &quot;timestamp&quot;: &quot;0x00&quot;,
    &quot;parentHash&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;,
    &quot;extraData&quot;: &quot;0x11bbe8db4e347b4e8c937c1c8370e4b5ed33adb3db69cbdb7a38e1e50b1b82fa&quot;,
    &quot;gasLimit&quot;: &quot;0x500000&quot;,
    &quot;alloc&quot;: {}
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创世配置参数说明：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;nonce：64位随机数，用于挖矿&lt;/li&gt;
&lt;li&gt;timestamp：创世块的时间戳&lt;/li&gt;
&lt;li&gt;parentHash：上一个区块的&lt;code&gt;hash&lt;/code&gt;值，因为是创世块，所以这个值是0&lt;/li&gt;
&lt;li&gt;mixHash：与&lt;code&gt;nonce&lt;/code&gt;配合用于挖矿，由上一个区块的一部分生成&lt;code&gt;hash&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;extraData：附加信息，任意填写&lt;/li&gt;
&lt;li&gt;gasLimit：对&lt;code&gt;GAS&lt;/code&gt;的消耗总量限制，用来限制区块能包含的交易信息总和&lt;/li&gt;
&lt;li&gt;difficulty：难度值，越大越难&lt;/li&gt;
&lt;li&gt;coinbase：矿工账号，第一个区块挖出后将给这个矿工账号发送奖励的以太币&lt;/li&gt;
&lt;li&gt;alloc：预设账号以及账号的以太币数量，测试链挖矿比较容易可以不配置&lt;/li&gt;
&lt;li&gt;chainId：指定了独立的区块链网络ID，不同ID网络的节点无法互相连接&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;初始化创世目录&quot;&gt;5. 初始化创世目录&lt;/h3&gt;
&lt;h4 id=&quot;删除每个节点下geth目录保留keystore&quot;&gt;1. 删除每个节点下&lt;code&gt;geth&lt;/code&gt;目录，保留&lt;code&gt;keystore&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;移除&lt;code&gt;geth&lt;/code&gt;目录，便于移除旧的无效数据，因为节点刚启动的时候，使用的是默认创世配置，而自定义的又不一样，因此需要移除。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;sudo rm -rf ~/data/meitu/node1/geth
sudo rm -rf ~/data/meitu/node2/geth
sudo rm -rf ~/data/meitu/node3/geth&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;拷贝创世配置到数据目录&quot;&gt;2. 拷贝创世配置到数据目录&lt;/h4&gt;
&lt;p&gt;将创世配置拷贝到数据目录中，便于容器内能访问，至于这个目录跟&lt;code&gt;docker-compose.yml&lt;/code&gt;映射的目录有关。&lt;br/&gt;因此，命令也要相应的变更。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;cp genesis.json ~/data/meitu/node1
cp genesis.json ~/data/meitu/node2
cp genesis.json ~/data/meitu/node3&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;初始化创世配置&quot;&gt;3. 初始化创世配置&lt;/h4&gt;
&lt;p&gt;进入容器，并执行初始化命令。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;# 节点1
docker exec -it meitu_node_1 /bin/sh
geth init /root/.ethereum/genesis.json
# 节点2
docker exec -it meitu_node_2 /bin/sh
geth init /root/.ethereum/genesis.json
# 节点3
docker exec -it meitu_node_3 /bin/sh
geth init /root/.ethereum/genesis.json&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;**loop：重复在node2、node3上分别执行init&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;重启节点网络&quot;&gt;6. 重启节点网络&lt;/h3&gt;
&lt;p&gt;以下命令需要在&lt;code&gt;docker-compose.yml&lt;/code&gt;文件的当前目录方可运行。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;# 移除容器
docker-compose down
# 启动容器
docker-compose up -d&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;查看验证人是否设置成功&quot;&gt;7. 查看验证人是否设置成功&lt;/h3&gt;
&lt;h4 id=&quot;进入容器-1&quot;&gt;1. 进入容器&lt;/h4&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;docker exec -it meitu_node_3 /bin/sh&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;进入geth-javascript控制台-1&quot;&gt;2. 进入geth JavaScript控制台&lt;/h4&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;geth attach ipc:/root/.ethereum/geth.ipc&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;执行获取验证人列表命令&quot;&gt;3. 执行获取验证人列表命令&lt;/h4&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;dpos.getValidators()
[&quot;0x849f9442198282fb21539351edb0378463e4c251&quot;, &quot;0x2c08f54d5b324c0175ea53b997f5ce1f61a7e4ed&quot;, &quot;0xc4118320f3d3c37a2ca8dad5c2f2a40f2a23ba02&quot;]&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;节点互联&quot;&gt;8. 节点互联&lt;/h3&gt;
&lt;h4 id=&quot;查看节点是否互联&quot;&gt;1. 查看节点是否互联&lt;/h4&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;admin.peers
[]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回的数据为&lt;code&gt;[]&lt;/code&gt;，说明节点之间没有互相发现。&lt;/p&gt;
&lt;h4 id=&quot;设置节点互联&quot;&gt;2. 设置节点互联&lt;/h4&gt;
&lt;h5 id=&quot;查看每个节点信息&quot;&gt;1. 查看每个节点信息&lt;/h5&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;admin.nodeInfo&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;确认：enode都不一样，protocols都一样。&lt;/strong&gt;&lt;br/&gt;记下三个enode&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&quot;enode://7f2f1a5818b4bb7e756036ab08834386534807bbf5c5a305ddcbefa1ff9ea99028feb00cb78322ac39340501d5b7c6147e169aadbb028daf20f8d73dbdfea98e@[::]:30303&quot;
&quot;enode://6ab4f74058b9c1e43d2d0c6f55f538ea7f2f366dd9f8f560024f14603333f017d3404b9c9711538289fa76504fecf33cf0e36cce7b0414604f673abe93012413@[::]:30303&quot;
&quot;enode://e82fecab04e5e902a9e4ea491527ea958d2cdeb83383dfa36562e32a51eedb204a541e00ef0b497704ec0e91017799a73283e53f6dffdeef492a4230626b10b6@[::]:30303&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;查看docker容器网络信息&quot;&gt;2. 查看docker容器网络信息&lt;/h5&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;# 显示docker所有网络信息
docker network ls
# 查看具体网络信息
docker network inspect [网络名称]
# 例子
docker network inspect docker_default&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行查看网络信息命令后，会返回一下内容&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;[
    {
        &quot;Name&quot;: &quot;docker_default&quot;,
        &quot;Id&quot;: &quot;984fabf7e51b07c1984114720f98f305cc61cc26546cf9da4bcbbbc36a591351&quot;,
        &quot;Created&quot;: &quot;2018-12-05T06:06:13.435067024Z&quot;,
        &quot;Scope&quot;: &quot;local&quot;,
        &quot;Driver&quot;: &quot;bridge&quot;,
        &quot;EnableIPv6&quot;: false,
        &quot;IPAM&quot;: {
            &quot;Driver&quot;: &quot;default&quot;,
            &quot;Options&quot;: null,
            &quot;Config&quot;: [
                {
                    &quot;Subnet&quot;: &quot;172.20.0.0/16&quot;,
                    &quot;Gateway&quot;: &quot;172.20.0.1&quot;
                }
            ]
        },
        &quot;Internal&quot;: false,
        &quot;Attachable&quot;: true,
        &quot;Ingress&quot;: false,
        &quot;ConfigFrom&quot;: {
            &quot;Network&quot;: &quot;&quot;
        },
        &quot;ConfigOnly&quot;: false,
        &quot;Containers&quot;: {
            &quot;263f1553108cc8ea00b76598adb6d66649287943c7d0f50d0be02963863ff45c&quot;: {
                &quot;Name&quot;: &quot;meitu_node_2&quot;,
                &quot;EndpointID&quot;: &quot;9f4114a81133bd490b501ac45fd50fe512309f9096b5468054bd074bad45a07d&quot;,
                &quot;MacAddress&quot;: &quot;02:42:ac:14:00:03&quot;,
                &quot;IPv4Address&quot;: &quot;172.20.0.3/16&quot;,
                &quot;IPv6Address&quot;: &quot;&quot;
            },
            &quot;3acd943c8e0759dc241d7cc623b1a1ca45096480dcd2fd0daa8b951407eb40bf&quot;: {
                &quot;Name&quot;: &quot;meitu_node_3&quot;,
                &quot;EndpointID&quot;: &quot;0480296c4e8217862358143a084da2d1563cd4f60105e6020434f222320681a5&quot;,
                &quot;MacAddress&quot;: &quot;02:42:ac:14:00:04&quot;,
                &quot;IPv4Address&quot;: &quot;172.20.0.4/16&quot;,
                &quot;IPv6Address&quot;: &quot;&quot;
            },
            &quot;416fe5eb074c24f032d5bd49a6be68cf293a30af17780133b9fa63663e4b7097&quot;: {
                &quot;Name&quot;: &quot;meitu_node_1&quot;,
                &quot;EndpointID&quot;: &quot;0dc00e9c6f63f844502525b34e87baf62f4de852ac46907951d4b689dd89635f&quot;,
                &quot;MacAddress&quot;: &quot;02:42:ac:14:00:02&quot;,
                &quot;IPv4Address&quot;: &quot;172.20.0.2/16&quot;,
                &quot;IPv6Address&quot;: &quot;&quot;
            }
        },
        &quot;Options&quot;: {},
        &quot;Labels&quot;: {
            &quot;com.docker.compose.network&quot;: &quot;default&quot;,
            &quot;com.docker.compose.project&quot;: &quot;docker&quot;,
            &quot;com.docker.compose.version&quot;: &quot;1.23.1&quot;
        }
    }
]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;找到不同容器中，相应的IP地址。&lt;br/&gt;记录下每个节点的IP，也可以用&lt;code&gt;127.0.0.1&lt;/code&gt;加节点映射到本机的不同网络端口。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;meitu_node_1 172.20.0.2
meitu_node_2 172.20.0.3
meitu_node_3 172.20.0.4&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;添加监视器&quot;&gt;3. 添加监视器&lt;/h5&gt;
&lt;p&gt;进入&lt;code&gt;节点1&lt;/code&gt; geth JavaScript 控制台后，执行以下命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 添加节点2的监视器
admin.addPeer(&quot;enode://6ab4f74058b9c1e43d2d0c6f55f538ea7f2f366dd9f8f560024f14603333f017d3404b9c9711538289fa76504fecf33cf0e36cce7b0414604f673abe93012413@[172.20.0.3]:30303&quot;)
# 添加节点3的监视器
admin.addPeer(&quot;enode://e82fecab04e5e902a9e4ea491527ea958d2cdeb83383dfa36562e32a51eedb204a541e00ef0b497704ec0e91017799a73283e53f6dffdeef492a4230626b10b6@[172.20.0.4]:30303&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;查看节点网络&quot;&gt;4.查看节点网络&lt;/h5&gt;
&lt;p&gt;在执行完添加监视器后，执行&lt;code&gt;admin.peers&lt;/code&gt;即可看到节点已经互联起来。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;admin.peers
[{
    caps: [&quot;eth/62&quot;, &quot;eth/63&quot;],
    id: &quot;6ab4f74058b9c1e43d2d0c6f55f538ea7f2f366dd9f8f560024f14603333f017d3404b9c9711538289fa76504fecf33cf0e36cce7b0414604f673abe93012413&quot;,
    name: &quot;Geth/v1.7.4-stable-a487fc95/linux-amd64/go1.9.7&quot;,
    network: {
      localAddress: &quot;172.20.0.2:60018&quot;,
      remoteAddress: &quot;172.20.0.3:30303&quot;
    },
    protocols: {
      eth: {
        difficulty: 131189,
        head: &quot;0xa00badd4041033da53c0a34cce5aa59885d7f638e00e1e307b04c02ee640df19&quot;,
        version: 63
      }
    }
}, {
    caps: [&quot;eth/62&quot;, &quot;eth/63&quot;],
    id: &quot;e82fecab04e5e902a9e4ea491527ea958d2cdeb83383dfa36562e32a51eedb204a541e00ef0b497704ec0e91017799a73283e53f6dffdeef492a4230626b10b6&quot;,
    name: &quot;Geth/v1.7.4-stable-a487fc95/linux-amd64/go1.9.7&quot;,
    network: {
      localAddress: &quot;172.20.0.2:36700&quot;,
      remoteAddress: &quot;172.20.0.4:30303&quot;
    },
    protocols: {
      eth: {
        difficulty: 131076,
        head: &quot;0xe30ff3a8d1ae16384369c45d106841ef44e83c12eae2e2c66dce1bdccc9ba4d6&quot;,
        version: 63
      }
    }
}]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意：这一步完成了，仅仅是临时的，每次重启docker之后admin.peers会重新为空。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;配置永久互联&quot;&gt;9. 配置永久互联&lt;/h3&gt;
&lt;p&gt;临时互联不方便，可以将&lt;code&gt;bootnodes&lt;/code&gt;配置到启动文件中。&lt;br/&gt;修改&lt;code&gt;docker-compose.yml&lt;/code&gt;文件，将&lt;code&gt;节点1&lt;/code&gt;的连接配置进去。&lt;/p&gt;
&lt;pre class=&quot;yml&quot;&gt;
&lt;code&gt;version: '3'
services: 
  meitu_node_1:
    image: meitugeth
    container_name: meitu_node_1
    build: 
      context: ..
    command: --ipcpath &quot;/root/.ethereum/geth.ipc&quot; --port 30303
    ports: 
      - 15450:8545
      - 15460:8546
      - 10303:30303
      - 10303:30303/udp
      - 10304:30304/udp
    volumes: 
      - /etc/localtime:/etc/localtime
      - ~/data/meitu/node1/:/root/.ethereum/
    environment: 
      TZ: Asia/Shanghai

  meitu_node_2:
    image: meitugeth
    container_name: meitu_node_2
    build: 
      context: ..
    command: --ipcpath &quot;/root/.ethereum/geth.ipc&quot; --port 30303 --bootnodes enode://7f2f1a5818b4bb7e756036ab08834386534807bbf5c5a305ddcbefa1ff9ea99028feb00cb78322ac39340501d5b7c6147e169aadbb028daf20f8d73dbdfea98e@[172.20.0.2]:30303
    depends_on: 
      - meitu_node_1
    ports: 
      - 25450:8545
      - 25460:8546
      - 20303:30303
      - 20303:30303/udp
      - 20304:30304/udp
    volumes: 
      - /etc/localtime:/etc/localtime
      - ~/data/meitu/node2/:/root/.ethereum/
    environment: 
      TZ: Asia/Shanghai

  meitu_node_3:
    image: meitugeth
    container_name: meitu_node_3
    build: 
      context: ..
    command: --ipcpath &quot;/root/.ethereum/geth.ipc&quot; --port 30303 --bootnodes enode://7f2f1a5818b4bb7e756036ab08834386534807bbf5c5a305ddcbefa1ff9ea99028feb00cb78322ac39340501d5b7c6147e169aadbb028daf20f8d73dbdfea98e@[172.20.0.2]:30303
    depends_on: 
      - meitu_node_1
    ports: 
      - 45450:8545
      - 45460:8546
      - 40303:30303
      - 40303:30303/udp
      - 40304:30304/udp
    volumes: 
      - /etc/localtime:/etc/localtime
      - ~/data/meitu/node3/:/root/.ethereum/
    environment: 
      TZ: Asia/Shanghai&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;这个时候，“主网”启动成功了！！！&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;解锁账户&quot;&gt;1. 解锁账户&lt;/h2&gt;
&lt;p&gt;分别在3个节点上把&lt;code&gt;validator&lt;/code&gt;无限期解锁，谁不解锁谁别出块、跳过你。&lt;br/&gt;这里源码默认10秒1块。&lt;br/&gt;进入&lt;code&gt;geth JavaScript&lt;/code&gt;控制台后，执行以下命令：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;# 模板
personal.unlockAccount(eth.validator,'名称',0)
# 例子
personal.unlockAccount(eth.validator,'jce001',0)
personal.unlockAccount(eth.validator,'jce002',0)
personal.unlockAccount(eth.validator,'jce003',0)&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;根据美图解释，这里&lt;code&gt;validator&lt;/code&gt;和&lt;code&gt;coinbase&lt;/code&gt;的区别：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;coinbase：收取挖矿奖励&lt;/li&gt;
&lt;li&gt;validator：可以设置为其他地址，但默认和coinbase一样。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;启动挖矿&quot;&gt;2. 启动挖矿&lt;/h2&gt;
&lt;p&gt;进入&lt;code&gt;geth JavaScript&lt;/code&gt;控制台后，执行以下命令：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;miner.start()&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;获取区块信息&quot;&gt;3. 获取区块信息&lt;/h2&gt;
&lt;p&gt;进入&lt;code&gt;geth JavaScript&lt;/code&gt;控制台后，执行以下命令：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;# 模板
eth.getBlock(区块编号)
# 例子
eth.getBlock(1)
# 结果
{
  coinbase: &quot;0x849f9442198282fb21539351edb0378463e4c251&quot;,
  difficulty: 1,
  extraData: &quot;0xd783010704846765746887676f312e392e37856c696e7578000000000000000084c3b20f15eb99c19bb8567d3a27a52947efb816f647cbc4491540ee5de685d54f4126d236f031d33312dfab1a5d7a895bbd4d154afd366b30918a9af6868ab300&quot;,
  gasLimit: 5237761,
  gasUsed: 0,
  hash: &quot;0x30964585add8b4ef65529f38ebe00bb6581fc9ae7323327f7dfd666754de883b&quot;,
  logsBloom: &quot;0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000&quot;,
  mixHash: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;,
  nonce: &quot;0x0000000000000000&quot;,
  number: 1,
  parentHash: &quot;0x9390ffeae9812417704193667a0e106c8cd9e701217deb054737dab0325191d3&quot;,
  receiptsRoot: &quot;0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421&quot;,
  sha3Uncles: &quot;0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347&quot;,
  size: 794,
  stateRoot: &quot;0xc5a87ecb7262f6c507f488f5f93efa27df81550f1e7691c1ab2093a4218d2ca0&quot;,
  timestamp: 1543990290,
  totalDifficulty: 131073,
  transactions: [],
  transactionsRoot: &quot;0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421&quot;,
  uncles: [],
  validator: &quot;0x849f9442198282fb21539351edb0378463e4c251&quot;
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;获取账户余额&quot;&gt;1. 获取账户余额&lt;/h2&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;# 获取账户
eth.accounts

# 获取余额
eth.getBalance(账户地址)

# 格式化长度
web3.fromWei(数值)

# 获取格式化后的余额，默认取第一个账户
web3.fromWei(eth.getBalacne(eth.accounts[0]))

# 获取指定账户余额
web3.fromWei(eth.getBalance(&quot;0x849f9442198282fb21539351edb0378463e4c251&quot;))&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;交易&quot;&gt;2. 交易&lt;/h2&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;# 模板
eth.sendTransaction({from: &quot;发送者&quot;, to: &quot;接受者&quot;, value: 数量})
# 例子
eth.sendTransaction({from: &quot;0x849f9442198282fb21539351edb0378463e4c251&quot;, to: &quot;0xc4118320f3d3c37a2ca8dad5c2f2a40f2a23ba02&quot;, value: 1000000000000000000})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过获取余额判断是否转账成功，也可通过返回的交易编号查询情况。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;web3.eth.getTransactionReceipt('0x8a4104da45c736c7a671ff7974b9b9a1848ff4c001f3cbcd4eb427aab50d604f')&lt;/code&gt;
&lt;/pre&gt;

</description>
<pubDate>Wed, 05 Dec 2018 07:35:00 +0000</pubDate>
<dc:creator>简玄冰</dc:creator>
<og:description>一、前言 最近，需要接触区块链项目的主链开发，在 、`BTC ethereum 超级账本 go ethereum`为解决方案。 以 为基准去找解决方案，最终找到了2个符合自己要求的方案，分别如下：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jianxuanbing/p/10071238.html</dc:identifier>
</item>
<item>
<title>理解OpenShift（3）：网络之 SDN - SammyLiu</title>
<link>http://www.cnblogs.com/sammyliu/p/10064450.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sammyliu/p/10064450.html</guid>
<description>&lt;p&gt;&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl01_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/sammyliu/p/10013461.html&quot;&gt;理解OpenShift（1）：网络之 Router 和 Route&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/sammyliu/p/10056035.html%20&quot; target=&quot;_blank&quot;&gt;理解OpenShift（2）：网络之 DNS（域名服务）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/sammyliu/p/10064450.html%20&quot; target=&quot;_blank&quot;&gt;理解OpenShift（3）：网络之 SDN&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;1. 概况&lt;/h2&gt;
&lt;p&gt; OpenShift SDN 实现了符合Kubernetes CNI 要求的 OpenShift 集群中 pod 之间的网络通信。当前OpenShift 支持两种SDN网络插件：ovs-subnet 和 ovs-multitenant。ovs-subnet 未实现租户之间的网络隔离，这意味着所有租户之间的pod 都可以互访，这使得该实现无法用于绝大多数的生产环境。本文中的说明都是针对 ovs-multitenant，它基于 OVS 和 VxLAN 等技术实现了基于项目（project）之间的网络隔离。当使用 ansible 部署 OpenShift 时，默认会启用ovs-subnet，但是可以在部署完成后修改为 ovs-multitenant。&lt;/p&gt;
&lt;h3&gt;1.1 OpenShift 集群的网络设计&lt;/h3&gt;
&lt;p&gt;要部署一个OpenShift 生产环境，主要的网络规划和设计如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/697113/201812/697113-20181205152330340-1078763939.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;节点角色：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Master 节点：只承担 Master 角色，不承担Node 角色。主要运行 API 服务、controller manager 服务、etcd 服务、web console 服务等。&lt;/li&gt;
&lt;li&gt;Infra 节点：作为 Node 角色，并设置节点标签，只用于部署系统基础服务，包括Registry、Router、Prometheus 以及 EFK 等。&lt;/li&gt;
&lt;li&gt;Node 节点：作为 Node 角色，用于运行用户业务系统的Pod/容器。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;网络类型：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;外部网络：用于外部访问。和该网络连接的服务器或组件需要被分配公网IP地址。&lt;/li&gt;
&lt;li&gt;管理网络：这是一个内部网络，用于集群内部 API 访问。&lt;/li&gt;
&lt;li&gt;IPMI网络：这是一个内部网络，用于管理物理服务器。&lt;/li&gt;
&lt;li&gt;SDN网络：这是一个内部网络，用于集群内部Pod 之间的通信，承载 VxLAN Overlay 流量。&lt;/li&gt;
&lt;li&gt;存储网络：这是一个内部网络，用于各节点访问IP存储服务器。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在PoC 或开发测试环境中，管理/SDN/存储网络可以合并为一个网络。&lt;/p&gt;
&lt;h3&gt;1.2 Node节点中的网络&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/697113/201812/697113-20181205153545787-517230639.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;节点上的主要网络设备：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;br0 - OpenShift 创建和管理的 Open vSwitch 网桥, 它会使用 OpenFlow 规则来实现网络隔离&lt;/li&gt;
&lt;li&gt;vethXXXXX - veth 对，它负责将 pod 的网络名字空间连接到 br0 网桥&lt;/li&gt;
&lt;li&gt;tun0 - 一个 OVS 内部端口，它会被分配本机的 pod 子网的网关IP 地址，用于与集群外部的通信。iptables 的 NAT 规则会作用于tun0。&lt;/li&gt;
&lt;li&gt;docker0 - Docker 管理和使用的 linux bridge 网桥，通过 veth 对将不受 OpenShift 管理的Docker 容器的网络地址空间连接到 docker0 上。&lt;/li&gt;
&lt;li&gt;vovsbr/vlinuxbr - 将 docker0 和 br0 连接起来的 veth 对，使得Docker 容器能和 OpenShift pod 通信，以及通过 tun0 访问外部网络&lt;/li&gt;
&lt;li&gt;vxlan0 - 一个 OVS VXLAN 隧道端点，用于集群内部 pod 之间的网络通信。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;2. 实现&lt;/h2&gt;
&lt;h3&gt;2.1 pod 网络总体设置流程&lt;/h3&gt;
&lt;p&gt;Pod 网络总体设置流程如下（来源：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzA3MDg4Nzc2NQ==&amp;amp;mid=2652137188&amp;amp;idx=1&amp;amp;sn=98608470be8014acf8cfa1bacb219bfb&amp;amp;scene=21#wechat_redirect&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;OpenShift源码简析之pod网络配置(上）&lt;/a&gt;）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/697113/201812/697113-20181204151726524-1466041316.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;简单说明：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;OpenShift 使用运行在每个节点上的 kubelet 来负责pod 的创建和管理，其中就包括网络配置部分。&lt;/li&gt;
&lt;li&gt;当 kubelet 接受到 pod 创建请求时，会首先调用docker client 来创建容器，然后再调用 docker api接口启动上一步中创建成功的容器。kubelet 在创建 pod 时是先创建一个 infra 容器，配置好该容器的网络，然后创建真正用于业务的应用容器，最后再把业务容器的网络加到infra容器的网络命名空间中，相当于业务容器共享infra容器的网络命名空间。业务应用容器和infra容器共同组成一个pod。&lt;/li&gt;
&lt;li&gt;kubelet 使用 CNI 来创建和管理Pod网络（openshift在启动kubelet时传递的参数是--netowrk-plugin=cni）。OpenShift 实现了 CNI 插件（由 /etc/cni/net.d/80-openshift-network.conf 文件指定），其二进制文件是 /opt/cni/bin/openshift-sdn 。因此，kubelet 通过 CNI 接口来调用 openshift sdn 插件，然后具体做两部分事情：一是通过 IPAM 获取 IP 地址，二是设置 OVS（其中，一是通过调用 ovs-vsctl 将 infra 容器的主机端虚拟网卡加入 br0，二是调用 ovs-ofctl 命令来设置规则）。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;2.2 OVS 网桥 br0 中的规则&lt;/h3&gt;
&lt;p&gt;本部分内容主要引用自 &lt;a href=&quot;https://medoc.readthedocs.io/en/latest/docs/ovs/sharing/cloud_usage.html&quot; target=&quot;_blank&quot;&gt;OVS 在云项目中的使用&lt;/a&gt;：&lt;/p&gt;
&lt;p&gt;流量规则表：&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;table 0: 根据输入端口（in_port）做入口分流，来自VXLAN隧道的流量转到表10并将其VXLAN VNI 保存到 OVS 中供后续使用，从tun0过阿里的（来自本节点或进本节点来做转发的）流量分流到表30，将剩下的即本节点的容器（来自veth***）发出的流量转到表20；&lt;/li&gt;
&lt;li&gt;table 10: 做入口合法性检查，如果隧道的远端IP（tun_src）是某集群节点的IP，就认为是合法，继续转到table 30去处理;&lt;/li&gt;
&lt;li&gt;table 20: 做入口合法性检查，如果数据包的源IP（nw_src）与来源端口（in_port）相符，就认为是合法的，设置源项目标记，继续转到table 30去处理；如果不一致，即可能存在ARP/IP欺诈，则认为这样的的数据包是非法的;&lt;/li&gt;
&lt;li&gt;table 30: 数据包的目的（目的IP或ARP请求的IP）做转发分流，分别转到table 40~70 去处理;&lt;/li&gt;
&lt;li&gt;table 40: 本地ARP的转发处理，根据ARP请求的IP地址，从对应的端口（veth）发出;&lt;/li&gt;
&lt;li&gt;table 50: 远端ARP的转发处理，根据ARP请求的IP地址，设置VXLAN隧道远端IP，并从隧道发出;&lt;/li&gt;
&lt;li&gt;table 60: Service的转发处理，根据目标Service，设置目标项目标记和转发出口标记，转发到table 80去处理;&lt;/li&gt;
&lt;li&gt;table 70: 对访问本地容器的包，做本地IP的转发处理，根据目标IP，设置目标项目标记和转发出口标记，转发到table 80去处理;&lt;/li&gt;
&lt;li&gt;table 80: 做本地的IP包转出合法性检查，检查源项目标记和目标项目标记是否匹配，或者目标项目是否是公开的，如果满足则转发;（这里实现了 OpenShift 网络层面的多租户隔离机制，实际上是根据项目/project 进行隔离，因为每个项目都会被分配一个 VXLAN VNI，table 80 只有在网络包的VNI和端口的VNI tag 相同才会对网络包进行转发）&lt;/li&gt;
&lt;li&gt;table 90: 对访问远端容器的包，做远端IP包转发“寻址”，根据目标IP，设置VXLAN隧道远端IP，并从隧道发出;&lt;/li&gt;
&lt;li&gt;table 100: 做出外网的转出处理，将数据包从tun0发出。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/697113/201812/697113-20181204153117532-1626127838.png&quot; alt=&quot;&quot; width=&quot;813&quot; height=&quot;469&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;3. 流程&lt;/h2&gt;
&lt;h3&gt;3.1 同一个节点上的两个pod 之间的互访&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/697113/201812/697113-20181205111950827-605834224.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;访问：pod 1 （ip：10.131.1.150）访问 pod2（10.131.1.152）&lt;/p&gt;
&lt;p&gt;网络路径：：pod1的eth0 → veth12 → br0 → veth34 → pod2的eth0。 &lt;/p&gt;
&lt;p&gt;OVS 流表：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;69&quot;&gt;
&lt;pre&gt;
table=&lt;span&gt;0&lt;/span&gt;, n_packets=&lt;span&gt;14631632&lt;/span&gt;, n_bytes=&lt;span&gt;1604917617&lt;/span&gt;, priority=&lt;span&gt;100&lt;/span&gt;,ip actions=goto_table:&lt;span&gt;20&lt;/span&gt;&lt;span&gt;
table&lt;/span&gt;=&lt;span&gt;20&lt;/span&gt;, n_packets=&lt;span&gt;166585&lt;/span&gt;, n_bytes=&lt;span&gt;12366463&lt;/span&gt;, priority=&lt;span&gt;100&lt;/span&gt;,ip,&lt;span&gt;in_port&lt;/span&gt;=&lt;span&gt;96&lt;/span&gt;,&lt;span&gt;nw_src&lt;/span&gt;=&lt;span&gt;10.131&lt;/span&gt;.&lt;span&gt;1.152&lt;/span&gt; &lt;span&gt;actions=load:0xbe3127-&amp;gt;NXM_NX_REG0[]&lt;/span&gt;,goto_table:&lt;span&gt;21&lt;/span&gt;&lt;span&gt;
table&lt;/span&gt;=&lt;span&gt;21&lt;/span&gt;, n_packets=&lt;span&gt;14671413&lt;/span&gt;, n_bytes=&lt;span&gt;1606835395&lt;/span&gt;, priority=&lt;span&gt;0&lt;/span&gt; actions=goto_table:&lt;span&gt;30&lt;/span&gt;&lt;span&gt;
table&lt;/span&gt;=&lt;span&gt;30&lt;/span&gt;, n_packets=&lt;span&gt;8585493&lt;/span&gt;, n_bytes=&lt;span&gt;898571869&lt;/span&gt;, priority=&lt;span&gt;200&lt;/span&gt;,ip,nw_dst=&lt;span&gt;10.131&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;/&lt;span&gt;23&lt;/span&gt; actions=goto_table:&lt;span&gt;70&lt;/span&gt;&lt;span&gt;
table&lt;/span&gt;=&lt;span&gt;70&lt;/span&gt;, n_packets=&lt;span&gt;249967&lt;/span&gt;, n_bytes=&lt;span&gt;16177300&lt;/span&gt;, priority=&lt;span&gt;100&lt;/span&gt;,ip,nw_dst=&lt;span&gt;10.131&lt;/span&gt;.&lt;span&gt;1.152&lt;/span&gt; &lt;span&gt;actions=load:0xbe3127-&amp;gt;NXM_NX_REG1[]&lt;/span&gt;,&lt;span&gt;load:0x60-&amp;gt;NXM_NX_REG2[]&lt;/span&gt;,goto_table:&lt;span&gt;80&lt;/span&gt;&lt;span&gt;&lt;br/&gt;table=80, n_packets=0, n_bytes=0, priority=100,reg0=0xbe3127,reg1=0xbe3127 actions=output:NXM_NX_REG2[]&lt;br/&gt;table=80, n_packets=0, n_bytes=0, priority=0 actions=drop #不合法的包会被丢弃&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;表 20 会判断包类型（IP）、来源地址（nw_src）、进来的端口ID（96），将其 VNI ID（这里是 0xbe3127）保存在 REG0 中。&lt;/p&gt;
&lt;p&gt;表 70 会根据目的地址，也就是目的 pod 的地址，设置网络包的目的出口标记（REG2）为 0x60，即其ID为 96，同时设置其项目的 VNI ID 到 REG1.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;96&lt;/span&gt;(veth0612e07f): addr:&lt;span&gt;66&lt;/span&gt;&lt;span&gt;:d0:c3:e3:be:cf
     config:     &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
     state:      &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
     current:    10GB&lt;/span&gt;-&lt;span&gt;FD COPPER
     speed: &lt;/span&gt;&lt;span&gt;10000&lt;/span&gt; Mbps now, &lt;span&gt;0&lt;/span&gt; Mbps max
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们来查找其对应的容器中的网卡。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
[root@node1 cloud-user]# ip link  | &lt;span&gt;grep&lt;/span&gt;&lt;span&gt; veth0612e07f
&lt;/span&gt;&lt;span&gt;443&lt;/span&gt;: veth0612e07f@if3: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu &lt;span&gt;1400&lt;/span&gt; qdisc noqueue master ovs-system state UP mode DEFAULT 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这与pod2容器中的 eth0 正好吻合：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;3&lt;/span&gt;: eth0@if443: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu &lt;span&gt;1400&lt;/span&gt;&lt;span&gt; qdisc noqueue state UP 
    link&lt;/span&gt;/ether 0a:&lt;span&gt;58&lt;/span&gt;:0a:&lt;span&gt;83&lt;/span&gt;:&lt;span&gt;01&lt;/span&gt;:&lt;span&gt;98&lt;/span&gt; brd ff:ff:ff:ff:ff:ff link-netnsid &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
    inet &lt;/span&gt;&lt;span&gt;10.131&lt;/span&gt;.&lt;span&gt;1.152&lt;/span&gt;/&lt;span&gt;23&lt;/span&gt; brd &lt;span&gt;10.131&lt;/span&gt;.&lt;span&gt;1.255&lt;/span&gt;&lt;span&gt; scope global eth0
       valid_lft forever preferred_lft forever&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;表80 会检查报的来源 VNI ID （REG0）和目的端口的 VNI ID （REG1），将合法的包转发到表70 设置的出口而已。&lt;/p&gt;
&lt;h3&gt;3.2 不同节点上的两个pod 之间的互访&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/697113/201812/697113-20181205113117714-1152909601.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;网络路径：节点1上的Pod1的eth0→veth1→br0→vxlan0→ 节点1的eth0网卡→ 节点2的eth0网卡→vxlan0→br0→veth1→ Pod3的eth0流表：&lt;/p&gt;
&lt;p&gt;发送端（node1）的OVS 流表：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
table=0, n_packets=14703186, n_bytes=1612904326, priority=100,&lt;span&gt;ip&lt;/span&gt; actions=goto_table:20&lt;br/&gt;table=20, n_packets=167428, n_bytes=12428845, priority=100,ip,in_port=96,nw_src=10.131.1.152 &lt;span&gt;actions=load:0xbe3127-&amp;gt;NXM_NX_REG0[]&lt;/span&gt;,goto_table:21&lt;br/&gt;table=21, n_packets=14736461, n_bytes=1613954556, priority=0 actions=goto_table:30&lt;br/&gt;table=&lt;span&gt;30&lt;/span&gt;, n_packets=&lt;span&gt;1143761&lt;/span&gt;, n_bytes=&lt;span&gt;1424533777&lt;/span&gt;, priority=&lt;span&gt;100&lt;/span&gt;,ip,&lt;span&gt;nw_dst=10.128.0.0/14&lt;/span&gt; actions=goto_table:&lt;span&gt;90&lt;br/&gt;table=90, n_packets=0, n_bytes=0, priority=100,ip,nw_dst=10.128.2.0/23 actions=move:NXM_NX_REG0[]-&amp;gt;NXM_NX_TUN_ID[0..31],set_field:172.22.122.9-&amp;gt;tun_dst,output:1&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;表20 同样是将源pod 的 VNI ID 保存在 REG0 中。&lt;/li&gt;
&lt;li&gt;表30 会判断目的地址是不是集群的大的 pod 的 IP CIDR。&lt;/li&gt;
&lt;li&gt;表90会设置 VNI ID 为之前保存在 REG0 中的值，然后根据目的地址的网段（这里是 10.128.2.0/23），计算出其所在的节点的IP 地址（这里是 172.22.122.9）并设置为tun_dst，然后发到 vxlan0.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;接收端（node2）的OVS 流表： &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
table=&lt;span&gt;0&lt;/span&gt;, n_packets=&lt;span&gt;1980863&lt;/span&gt;, n_bytes=&lt;span&gt;1369174876&lt;/span&gt;, priority=&lt;span&gt;200&lt;/span&gt;,ip,in_port=&lt;span&gt;1&lt;/span&gt;,nw_src=&lt;span&gt;10.128&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;/&lt;span&gt;14&lt;/span&gt; &lt;span&gt;actions=move:NXM_NX_TUN_ID[0..31]-&amp;gt;NXM_NX_REG0[]&lt;/span&gt;,goto_table:&lt;span&gt;10&lt;/span&gt;&lt;span&gt;
table&lt;/span&gt;=&lt;span&gt;10&lt;/span&gt;, n_packets=&lt;span&gt;0&lt;/span&gt;, n_bytes=&lt;span&gt;0&lt;/span&gt;, priority=&lt;span&gt;100&lt;/span&gt;,&lt;span&gt;tun_src=172.22.122.8&lt;/span&gt; actions=goto_table:&lt;span&gt;30&lt;/span&gt;&lt;span&gt;&lt;br/&gt;table=30, n_packets=16055284, n_bytes=1616511267, priority=200,ip,&lt;span&gt;nw_dst=10.128.2.0/23&lt;/span&gt; actions=goto_table:70&lt;br/&gt;table=70, n_packets=248860, n_bytes=16158751, priority=100,ip,&lt;span&gt;nw_dst=10.128.2.128&lt;/span&gt; actions=load:0xbe3127-&amp;gt;NXM_NX_REG1[],load:0x32-&amp;gt;NXM_NX_REG2[],goto_table:80&lt;br/&gt;table=80, n_packets=0, n_bytes=0, priority=100,reg0=0xbe3127,reg1=0xbe3127 actions=output:NXM_NX_REG2[]&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;表0 会将发送到保存在 NXM_NX_TUN_ID[0..31] 中的源 VNI ID 取出来保存到 REG0.&lt;/li&gt;
&lt;li&gt;表10 会检查包的来源节点的地址。&lt;/li&gt;
&lt;li&gt;表30 会检查包的目的地址是不是本机上 pod 的网段。&lt;/li&gt;
&lt;li&gt;表70 会根据目的地址，将目的 VNI ID 保存到 REG1，将目的端口 ID 保存到 REG2&lt;/li&gt;
&lt;li&gt;表80 会检查目的 VNI ID 和源 VNI ID，如果相符的话，则将包转发到保存在 REG2 中的目的端口ID 指定的端口。然后包就会通过 veth 管道进入目的 pod。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;3.3 pod 内访问外网&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/697113/201812/697113-20181205103548248-717807297.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;网络路径：PodA的eth0 → vethA → br0 → tun0 → 通过iptables实现SNAT → 物理节点的 eth0  → 互联网&lt;/p&gt;
&lt;p&gt;NAT：将容器发出的IP包的源IP地址修改为宿主机的 eth0 网卡的IP 地址。&lt;/p&gt;
&lt;p&gt;OVS 流表：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
table=&lt;span&gt;0&lt;/span&gt;, n_packets=&lt;span&gt;14618128&lt;/span&gt;, n_bytes=&lt;span&gt;1603472372&lt;/span&gt;, priority=&lt;span&gt;100&lt;/span&gt;,ip actions=goto_table:&lt;span&gt;20&lt;/span&gt;&lt;span&gt;
table&lt;/span&gt;=&lt;span&gt;20&lt;/span&gt;, n_packets=&lt;span&gt;0&lt;/span&gt;, n_bytes=&lt;span&gt;0&lt;/span&gt;, priority=&lt;span&gt;100&lt;/span&gt;,ip,&lt;span&gt;in_port=17,nw_src=10.131.1.73&lt;/span&gt; actions=load:&lt;span&gt;0xfa9a3&lt;/span&gt;-&amp;gt;NXM_NX_REG0[],goto_table:&lt;span&gt;21&lt;/span&gt;&lt;span&gt;
table&lt;/span&gt;=&lt;span&gt;21&lt;/span&gt;, n_packets=&lt;span&gt;14656675&lt;/span&gt;, n_bytes=&lt;span&gt;1605262241&lt;/span&gt;, priority=&lt;span&gt;0&lt;/span&gt; actions=goto_table:&lt;span&gt;30&lt;/span&gt;&lt;span&gt;
table&lt;/span&gt;=&lt;span&gt;30&lt;/span&gt;, n_packets=&lt;span&gt;73508&lt;/span&gt;, n_bytes=&lt;span&gt;6820206&lt;/span&gt;, priority=&lt;span&gt;0&lt;/span&gt;,ip actions=goto_table:&lt;span&gt;100&lt;/span&gt;&lt;span&gt;
table&lt;/span&gt;=&lt;span&gt;100&lt;/span&gt;, n_packets=&lt;span&gt;44056&lt;/span&gt;, n_bytes=&lt;span&gt;3938540&lt;/span&gt;, priority=&lt;span&gt;0&lt;/span&gt; actions=goto_table:&lt;span&gt;101&lt;/span&gt;&lt;span&gt;
table&lt;/span&gt;=&lt;span&gt;101&lt;/span&gt;, n_packets=&lt;span&gt;44056&lt;/span&gt;, n_bytes=&lt;span&gt;3938540&lt;/span&gt;, priority=&lt;span&gt;0&lt;/span&gt; actions=output:&lt;span&gt;2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;表20 会检查 IP 包的来源端口和IP 地址，并将源项目的 VNI ID 保存到 REG0.&lt;/p&gt;
&lt;p&gt;表101 会将包发送到端口2 即 tun0. 然后被 iptables 做 NAT 然后发送到 eth0.&lt;/p&gt;
&lt;h3&gt;3.4 外网访问 pod&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/697113/201812/697113-20181205095643961-1177124901.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为 Infra 节点上的 HAproxy 容器采用了 host-network 模式，因此它是直接使用宿主机的 eth0 网卡的。&lt;/p&gt;
&lt;p&gt;下面是宿主机的路由表：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@infra-node1 /]# route -&lt;span&gt;n
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
&lt;/span&gt;&lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;         &lt;span&gt;172.22&lt;/span&gt;.&lt;span&gt;122.1&lt;/span&gt;    &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;         UG    &lt;span&gt;100&lt;/span&gt;    &lt;span&gt;0&lt;/span&gt;        &lt;span&gt;0&lt;/span&gt;&lt;span&gt; eth0
&lt;/span&gt;&lt;span&gt;10.128.0.0      0.0.0.0         255.252.0.0     U     0      0        0 tun0
&lt;/span&gt;&lt;span&gt;169.254&lt;/span&gt;.&lt;span&gt;169.254&lt;/span&gt; &lt;span&gt;172.22&lt;/span&gt;.&lt;span&gt;122.1&lt;/span&gt;    &lt;span&gt;255.255&lt;/span&gt;.&lt;span&gt;255.255&lt;/span&gt; UGH   &lt;span&gt;100&lt;/span&gt;    &lt;span&gt;0&lt;/span&gt;        &lt;span&gt;0&lt;/span&gt;&lt;span&gt; eth0
&lt;/span&gt;&lt;span&gt;172.17&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;      &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;         &lt;span&gt;255.255&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;     U     &lt;span&gt;0&lt;/span&gt;      &lt;span&gt;0&lt;/span&gt;        &lt;span&gt;0&lt;/span&gt;&lt;span&gt; docker0
&lt;/span&gt;&lt;span&gt;172.22&lt;/span&gt;.&lt;span&gt;122.0&lt;/span&gt;    &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;         &lt;span&gt;255.255&lt;/span&gt;.&lt;span&gt;255.0&lt;/span&gt;   U     &lt;span&gt;100&lt;/span&gt;    &lt;span&gt;0&lt;/span&gt;        &lt;span&gt;0&lt;/span&gt;&lt;span&gt; eth0
&lt;/span&gt;&lt;span&gt;172.30&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;      &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;         &lt;span&gt;255.255&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;     U     &lt;span&gt;0&lt;/span&gt;      &lt;span&gt;0&lt;/span&gt;        &lt;span&gt;0&lt;/span&gt; tun0
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从 HAProxy 容器内出来目的地址为业务pod（ip：10.128.2.128）的网络包，根据上面的路由表，其下一跳是 tun0，也就是说它又进入了 OVS 网桥 br0. 对应的 OVS 流表规则为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
ip,in_port=2 actions=goto_table:30&lt;br/&gt;ip,nw_dst=10.128.0.0/14 actions=goto_table:90&lt;br/&gt;ip,nw_dst=10.128.2.0/23 actions=move:NXM_NX_REG0[]-&amp;gt;NXM_NX_TUN_ID[0..31],set_field:172.22.122.9-&amp;gt;tun_dst,output:1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可见它最终又被发到了端口1 即 vxlan0，它会负责做 vxlan 封包，并通过 eth0 网卡发出去。 &lt;/p&gt;
&lt;h3&gt;3.5 汇总&lt;/h3&gt;
&lt;p&gt;总体来说，OVS 中的流表根据网络包的目的地址将其分为四类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;到本地pod的，直接在 br0 中转发。&lt;/li&gt;
&lt;li&gt;到本集群pod 的，经过 br0 后发到 vxlan0，封装为 vxlan udp 包经物理网卡发到对方节点。&lt;/li&gt;
&lt;li&gt;到本地不受OpenShift SDN管理的docker容器的，还未研究。&lt;/li&gt;
&lt;li&gt;到集群外的，经过 br0 后发到 tun0，做 SNAT，然后经物理网卡发出。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/697113/201812/697113-20181205102910310-595609870.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;4. 项目（project）级别的网络隔离&lt;/h2&gt;
&lt;h3&gt;4.1 原理&lt;/h3&gt;
&lt;p&gt;OpenShift 中的网络隔离是在项目（project）级别实现的。OpenShfit 默认的项目 『default』的 VNID （Virtual Network ID ）为0，表明它是一个特权项目，因为它可以发动网络包到其它所有项目，也能接受其它所有项目的pod发来的网络包。这从 table 80 的规则上可以看出来，如果来源项目的 VNID （reg0）或目标项目的 VNID（reg1）为0，都会允许包转发。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
table=&lt;span&gt;80&lt;/span&gt;, n_packets=&lt;span&gt;8244506&lt;/span&gt;, n_bytes=&lt;span&gt;870316191&lt;/span&gt;, priority=&lt;span&gt;200&lt;/span&gt;,&lt;span&gt;reg0=0&lt;/span&gt; actions=&lt;span&gt;output:NXM_NX_REG2[]
&lt;/span&gt;table=&lt;span&gt;80&lt;/span&gt;, n_packets=&lt;span&gt;13576848&lt;/span&gt;, n_bytes=&lt;span&gt;1164951315&lt;/span&gt;, priority=&lt;span&gt;200&lt;/span&gt;,&lt;span&gt;reg1=0&lt;/span&gt; actions=output:NXM_NX_REG2[]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其它所有项目都会有一个非0的 VNID。在 OpenShift ovs-multitenant 实现中，非0 VNID 的项目之间的网络是不通的。&lt;/p&gt;
&lt;p&gt;从一个本地 pod 发出的所有网络流量，在它进入 OVS 网桥时，都会被打上它所通过的 OVS 端口ID相对应的 VNID。port:VNID 映射会在pod 创建时通过查询master 上的 etcd 来确定。从其它节点通过 VXLAN发过来的网络包都会带有发出它的pod 所在项目的 VNID。&lt;/p&gt;
&lt;p&gt;根据上面的分析，OVS 网桥中的 OpenFlow 规则会阻止带有与目标端口上的 VNID 不同的网络包的投递（VNID 0 除外）。这就保证了项目之间的网络流量是互相隔离的。&lt;/p&gt;
&lt;h3&gt;4.2 实验&lt;/h3&gt;
&lt;p&gt;下图显示了两个项目之间的三种网络状态：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;左图显示的是默认状态：SIT 项目和 Dev 项目之间的 pod 无法访问。根据前面对 OVS 流表的分析，表80 会检查IP 包的来源Pod的项目 VNI ID 和目标Pod的项目 VNI ID。如果两者不符合，这些IP网络包就会被丢弃。&lt;/li&gt;
&lt;li&gt;中间图显示的是打通这两个项目的网络：通过运行 oc adm pod-network join-projects 命令，将两个项目连接在一起，结果就是 DEV 项目的 VNI ID 变成了 SIT 项目的 VNI ID。这时候两个项目中的 pod 网络就通了。&lt;/li&gt;
&lt;li&gt;右图显示的是分离这两个项目的网络：通过运行 oc adm pod-network isolate-projects 命令，将两个项目分离，其结果是 DEV 项目被分配了新的 VNI ID。此时两个项目中的pod 又不能互通了。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/697113/201812/697113-20181205151252036-631359737.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;参考文档：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;感谢您的阅读，欢迎关注我的微信公众号：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/697113/201811/697113-20181126152157602-744511459.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 05 Dec 2018 07:27:00 +0000</pubDate>
<dc:creator>SammyLiu</dc:creator>
<og:description>理解OpenShift（1）：网络之 Router 和 Route 理解OpenShift（2）：网络之 DNS（域名服务） 理解OpenShift（3）：网络之 SDN 1. 概况 1.1 Open</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sammyliu/p/10064450.html</dc:identifier>
</item>
<item>
<title>基于vue-simple-uploader封装文件分片上传、秒传及断点续传的全局上传插件 - 夏大师</title>
<link>http://www.cnblogs.com/xiahj/p/vue-simple-uploader.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiahj/p/vue-simple-uploader.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;1. 前言&lt;/h2&gt;
&lt;p&gt;之前公司要在管理系统中做一个全局上传插件，即切换各个页面的时候，上传界面还在并且上传不会受到影响，这在vue这种spa框架面前并不是什么难题。然而后端大佬说我们要实现&lt;strong&gt;分片上传&lt;/strong&gt;、&lt;strong&gt;秒传&lt;/strong&gt;以及&lt;strong&gt;断点续传&lt;/strong&gt;的功能，听起来头都大了。&lt;/p&gt;
&lt;p&gt;很久之前我写了一篇webuploader的文章，结果使用起来发现问题很多，且官方团队不再维护这个插件了， 经过多天调研及踩雷，最终决定基于&lt;code&gt;vue-simple-uploader&lt;/code&gt;插件实现该功能，在项目中使用起来无痛且稳定。&lt;/p&gt;
&lt;p&gt;如果你只是想实现基本的（非定制化的）上传功能，直接使用&lt;code&gt;vue-simple-uploader&lt;/code&gt;，多读一下它的文档，不需要更多的二次封装。&lt;br/&gt;如果你只是想实现全局上传插件，也可以参照一下我的实现。&lt;br/&gt;如果你用到了分片上传、秒传及断点续传这些复杂的功能，恭喜你，这篇文章的重点就在于此。&lt;/p&gt;
&lt;p&gt;本文源码在此：&lt;a href=&quot;https://github.com/shady-xia/Blog/tree/master/vue-simple-uploader&quot; class=&quot;uri&quot;&gt;https://github.com/shady-xia/Blog/tree/master/vue-simple-uploader&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1294929/201812/1294929-20181205144202486-1422913409.gif&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;关于vue-simple-uploader&quot;&gt;2. 关于vue-simple-uploader&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;vue-simple-uploader&lt;/code&gt;是基于 &lt;code&gt;simple-uploader.js&lt;/code&gt; 封装的vue上传插件。它的优点包括且不限于以下几种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;支持文件、多文件、文件夹上传；支持拖拽文件、文件夹上传&lt;/li&gt;
&lt;li&gt;可暂停、继续上传&lt;/li&gt;
&lt;li&gt;错误处理&lt;/li&gt;
&lt;li&gt;支持“秒传”，通过文件判断服务端是否已存在从而实现“秒传”&lt;/li&gt;
&lt;li&gt;分块上传&lt;/li&gt;
&lt;li&gt;支持进度、预估剩余时间、出错自动重试、重传等操作&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;读这篇文章之前，建议先读一遍&lt;code&gt;simple-uploader.js&lt;/code&gt;的文档，然后再读一下&lt;code&gt;vue-simple-uploader&lt;/code&gt;的文档，了解一下各个参数的作用是什么，我在这里假定大家已经比较熟悉了。。&lt;br/&gt;&lt;a href=&quot;https://github.com/simple-uploader/vue-uploader/blob/master/README_zh-CN.md&quot;&gt;vue-simple-uploader文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/simple-uploader/Uploader/blob/develop/README_zh-CN.md&quot;&gt;simple-uploader.js文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;安装&lt;/strong&gt;：&lt;code&gt;npm install vue-simple-uploader --save&lt;/code&gt;&lt;br/&gt;&lt;strong&gt;使用&lt;/strong&gt;：在main.js中：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import uploader from 'vue-simple-uploader'
Vue.use(uploader)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;基于vue-simple-uploader封装全局上传组件&quot;&gt;3. 基于vue-simple-uploader封装全局上传组件&lt;/h2&gt;
&lt;p&gt;引入&lt;code&gt;vue-simple-uploader&lt;/code&gt;后，我们开始封装全局的上传组件&lt;code&gt;globalUploader.vue&lt;/code&gt;，代码比较长，就不整个放出来了，源码放到github上了，这里一步一步地讲解。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;template部分&lt;/strong&gt;如下，本人自定义了模板和样式，所以html部分比较长，css部分暂时不列出，大家可以根据自己的ui去更改，主要关注一下&lt;code&gt;uploader&lt;/code&gt;这个组件的&lt;code&gt;options&lt;/code&gt;参数及文件&lt;code&gt;added&lt;/code&gt;、&lt;code&gt;success&lt;/code&gt;、&lt;code&gt;progress&lt;/code&gt;、&lt;code&gt;error&lt;/code&gt;几个事件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;template&amp;gt;
    &amp;lt;div id=&quot;global-uploader&quot;&amp;gt;

        &amp;lt;!-- 上传 --&amp;gt;
        &amp;lt;uploader
                ref=&quot;uploader&quot;
                :options=&quot;options&quot;
                :autoStart=&quot;false&quot;
                @file-added=&quot;onFileAdded&quot;
                @file-success=&quot;onFileSuccess&quot;
                @file-progress=&quot;onFileProgress&quot;
                @file-error=&quot;onFileError&quot;
                class=&quot;uploader-app&quot;&amp;gt;
            &amp;lt;uploader-unsupport&amp;gt;&amp;lt;/uploader-unsupport&amp;gt;

            &amp;lt;uploader-btn id=&quot;global-uploader-btn&quot; :attrs=&quot;attrs&quot; ref=&quot;uploadBtn&quot;&amp;gt;选择文件&amp;lt;/uploader-btn&amp;gt;

            &amp;lt;uploader-list v-show=&quot;panelShow&quot;&amp;gt;
                &amp;lt;div class=&quot;file-panel&quot; slot-scope=&quot;props&quot; :class=&quot;{'collapse': collapse}&quot;&amp;gt;
                    &amp;lt;div class=&quot;file-title&quot;&amp;gt;
                        &amp;lt;h2&amp;gt;文件列表&amp;lt;/h2&amp;gt;
                        &amp;lt;div class=&quot;operate&quot;&amp;gt;
                            &amp;lt;el-button @click=&quot;fileListShow&quot; type=&quot;text&quot; :title=&quot;collapse ? '展开':'折叠' &quot;&amp;gt;
                                &amp;lt;i class=&quot;iconfont&quot; :class=&quot;collapse ? 'icon-fullscreen': 'icon-minus-round'&quot;&amp;gt;&amp;lt;/i&amp;gt;
                            &amp;lt;/el-button&amp;gt;
                            &amp;lt;el-button @click=&quot;close&quot; type=&quot;text&quot; title=&quot;关闭&quot;&amp;gt;
                                &amp;lt;i class=&quot;iconfont icon-close&quot;&amp;gt;&amp;lt;/i&amp;gt;
                            &amp;lt;/el-button&amp;gt;
                        &amp;lt;/div&amp;gt;
                    &amp;lt;/div&amp;gt;

                    &amp;lt;ul class=&quot;file-list&quot;&amp;gt;
                        &amp;lt;li v-for=&quot;file in props.fileList&quot; :key=&quot;file.id&quot;&amp;gt;
                            &amp;lt;uploader-file :class=&quot;'file_' + file.id&quot; ref=&quot;files&quot; :file=&quot;file&quot; :list=&quot;true&quot;&amp;gt;&amp;lt;/uploader-file&amp;gt;
                        &amp;lt;/li&amp;gt;
                        &amp;lt;div class=&quot;no-file&quot; v-if=&quot;!props.fileList.length&quot;&amp;gt;&amp;lt;i class=&quot;nucfont inuc-empty-file&quot;&amp;gt;&amp;lt;/i&amp;gt; 暂无待上传文件&amp;lt;/div&amp;gt;
                    &amp;lt;/ul&amp;gt;
                &amp;lt;/div&amp;gt;
            &amp;lt;/uploader-list&amp;gt;

        &amp;lt;/uploader&amp;gt;

    &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;组件中的data部分&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;data() {
    return {
        options: {
            target: 'http://xxxxx/xx', // 目标上传 URL
            chunkSize: '2048000',   //分块大小
            fileParameterName: 'file', //上传文件时文件的参数名，默认file
            testChunks: true,     //是否开启秒传
            maxChunkRetries: 3,  //最大自动失败重试上传次数
            // 服务器分片校验，断点续传基础
            checkChunkUploadedByResponse: function (chunk, message) {
                let objMessage = JSON.parse(message);
                if (objMessage.skipUpload) {
                    return true;
                }

                return (objMessage.uploaded || []).indexOf(chunk.offset + 1) &amp;gt;= 0
            },
            headers: {
          // 在header中添加的验证，请根据实际业务来
                Authorization: &quot;Bearer &quot; + Ticket.get().access_token
            },
        },
        attrs: {
         // 接受的文件类型，形如['.png', '.jpg', '.jpeg', '.gif', '.bmp'...] 这里我封装了一下
            accept: ACCEPT_CONFIG.getAll()
        },
        panelShow: false,   //选择文件后，展示上传panel
    }
},&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;全局引用：&lt;/strong&gt;&lt;br/&gt;在&lt;code&gt;app.vue&lt;/code&gt;中引用，即作为全局的组件&lt;strong&gt;一直存在&lt;/strong&gt;，只不过在不使用的时候把上传界面隐藏了&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;global-uploader&amp;gt;&amp;lt;/global-uploader&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;文件上传流程概览&quot;&gt;4. 文件上传流程概览&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1. 点击按钮，触发文件上传操作：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（如果你做的不是全局上传的功能，而是直接点击上传，忽略这一步。）&lt;/p&gt;
&lt;p&gt;因为我做的是全局上传的插件，要先把上传的窗口隐藏起来，在点击某个上传按钮的时候，用Bus发送一个&lt;code&gt;openUploader&lt;/code&gt;的事件，在&lt;code&gt;globalUploader.vue&lt;/code&gt;中接收该事件，trigger我们&lt;code&gt;uploader-btn&lt;/code&gt;的click事件。&lt;/p&gt;
&lt;p&gt;在某个页面中，点击上传按钮，同时把要给后台的参数带过来（如果有的话），这里组件之间传值我用的&lt;code&gt;event bus&lt;/code&gt;，当然用&lt;code&gt;vuex&lt;/code&gt;会更好：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Bus.$emit('openUploader', {
   superiorID: this.superiorID
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在&lt;code&gt;globalUploader.vue&lt;/code&gt;中接收该事件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Bus.$on('openUploader', query =&amp;gt; {
    this.params = query || {};

    if (this.$refs.uploadBtn) {
        // 这样就打开了选择文件的操作窗口
        $('#global-uploader-btn').click();
    }
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2. 选择文件后，将上传的窗口展示出来，开始md5的计算工作&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;onFileAdded(file) {
    this.panelShow = true;
    
    // 计算MD5，下文会提到
    this.computeMD5(file);
},&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里有个前提，我在&lt;code&gt;uploader&lt;/code&gt;中将&lt;code&gt;autoStart&lt;/code&gt;设为了&lt;code&gt;false&lt;/code&gt;，为什么要这么做？&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;在选择文件之后，我要计算MD5，以此来实现断点续传及秒传的功能，所以选择文件后直接开始上传肯定不行，要等MD5计算完毕之后，再开始文件上传的操作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;具体的MD5计算方法，会在下面讲，这里先简单引出。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上传过程中，会不断触发file-progress上传进度的回调&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 文件进度的回调
onFileProgress(rootFile, file, chunk) {
    console.log(`上传中 ${file.name}，chunk：${chunk.startByte / 1024 / 1024} ~ ${chunk.endByte / 1024 / 1024}`)
},&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3. 文件上传成功后&lt;/strong&gt;&lt;br/&gt;文件上传成功后，在“上传完成”的回调中，通过服务端返回的&lt;code&gt;needMerge&lt;/code&gt;字段，来判断是否需要再发送合并分片的请求，&lt;br/&gt;如果这个字段为true，则需要给后台发一个请求合并的ajax请求，否则直接上传成功。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：这里的&lt;code&gt;needMerge&lt;/code&gt;是我和后台商议决定的字段名&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;onFileSuccess(rootFile, file, response, chunk) {
    let res = JSON.parse(response);

    // 服务器自定义的错误，这种错误是Uploader无法拦截的
    if (!res.result) {
        this.$message({ message: res.message, type: 'error' });
        return
    }
    
    // 如果服务端返回需要合并
    if (res.needMerge) {
        api.mergeSimpleUpload({
            tempName: res.tempName,
            fileName: file.name,
            ...this.params,
        }).then(data =&amp;gt; {
            // 文件合并成功
            Bus.$emit('fileSuccess', data);
        }).catch(e =&amp;gt; {});
    // 不需要合并    
    } else {
        Bus.$emit('fileSuccess', res);
        console.log('上传成功');
    }
},

onFileError(rootFile, file, response, chunk) {
    console.log(error)
},&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;文件分片&quot;&gt;5. 文件分片&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;vue-simple-uploader&lt;/code&gt;自动将文件进行分片，在&lt;code&gt;options&lt;/code&gt;的&lt;code&gt;chunkSize&lt;/code&gt;中可以设置每个分片的大小。&lt;/p&gt;
&lt;p&gt;如图：对于大文件来说，会发送多个请求，下面的第一个请求是get请求，用于和服务端分片校验，后面的每一个请求都是上传分片的post请求&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1294929/201812/1294929-20181205144810603-787085344.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看一下发送给服务端的参数，其中&lt;code&gt;chunkNumber&lt;/code&gt;表示当前是第几个分片，&lt;code&gt;totalChunks&lt;/code&gt;代表所有的分片数，这两个参数都是都是插件根据你设置的&lt;code&gt;chunkSize&lt;/code&gt;来计算的。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1294929/201812/1294929-20181205144818639-1985721220.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;需要注意的就是在最后文件上传成功的事件中，通过后台返回的字段，来判断是否要再给后台发送一个文件合并的请求。&lt;/p&gt;
&lt;h2 id=&quot;md5的计算过程&quot;&gt;6. MD5的计算过程&lt;/h2&gt;
&lt;p&gt;断点续传及秒传的基础是要计算文件的&lt;code&gt;MD5&lt;/code&gt;，这是文件的唯一标识，然后服务器根据&lt;code&gt;MD5&lt;/code&gt;进行判断，是进行秒传还是断点续传。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;file-added&lt;/code&gt;事件之后，就计算&lt;code&gt;MD5&lt;/code&gt;，我们最终的目的是&lt;strong&gt;将计算出来的&lt;code&gt;MD5&lt;/code&gt;加到参数里传给后台&lt;/strong&gt;，然后&lt;strong&gt;继续文件上传&lt;/strong&gt;的操作，详细的思路步骤是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;把uploader组件的&lt;code&gt;autoStart&lt;/code&gt;设为&lt;code&gt;false&lt;/code&gt;，即选择文件后不会自动开始上传&lt;/li&gt;
&lt;li&gt;先通过 &lt;code&gt;file.pause()&lt;/code&gt;暂停文件，然后通过H5的&lt;code&gt;FileReader&lt;/code&gt;接口读取文件&lt;/li&gt;
&lt;li&gt;将异步读取文件的结果进行&lt;code&gt;MD5&lt;/code&gt;，这里我用的加密工具是&lt;code&gt;spark-md5&lt;/code&gt;，你可以通过&lt;code&gt;npm install spark-md5 --save&lt;/code&gt;来安装，也可以使用其他MD5加密工具。&lt;/li&gt;
&lt;li&gt;file有个属性是&lt;code&gt;uniqueIdentifier&lt;/code&gt;，代表文件唯一标示，我们把计算出来的MD5赋值给这个属性 &lt;code&gt;file.uniqueIdentifier = md5&lt;/code&gt;，这就实现了我们最终的目的。&lt;/li&gt;
&lt;li&gt;通过&lt;code&gt;file.resume()&lt;/code&gt;开始/继续文件上传。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;/**
* 计算md5，实现断点续传及秒传
* @param file
*/
computeMD5(file) {
    let fileReader = new FileReader();
    let time = new Date().getTime();
    let md5 = '';

    file.pause();

    fileReader.readAsArrayBuffer(file.file);

    fileReader.onload = (e =&amp;gt; {
        if (file.size != e.target.result.byteLength) {
            this.error('Browser reported success but could not read the file until the end.');
            return
        }

        md5 = SparkMD5.ArrayBuffer.hash(e.target.result);

        // 添加额外的参数
        this.uploader.opts.query = {
            ...this.params
        }

        console.log(`MD5计算完毕：${file.id} ${file.name} MD5：${md5} 用时：${new Date().getTime() - time} ms`);

        file.uniqueIdentifier = md5;
        file.resume();
    });

    fileReader.onerror = function () {
        this.error('FileReader onerror was triggered, maybe the browser aborted due to high memory usage.');
    };
},&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;秒传及断点续传&quot;&gt;7. 秒传及断点续传&lt;/h2&gt;
&lt;p&gt;在计算完&lt;code&gt;MD5&lt;/code&gt;后，我们就能谈断点续传及秒传的概念了。&lt;/p&gt;
&lt;p&gt;服务器根据前端传过来的&lt;code&gt;MD5&lt;/code&gt;去判断是否可以进行秒传或断点续传：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;a. 服务器发现文件已经完全上传成功，则直接返回&lt;strong&gt;秒传&lt;/strong&gt;的标识。&lt;/li&gt;
&lt;li&gt;b. 服务器发现文件上传过分片信息，则返回这些分片信息，告诉前端继续上传，即&lt;strong&gt;断点续传&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;对于前端来说&quot;&gt;7.1 对于前端来说&lt;/h3&gt;
&lt;p&gt;在每次上传过程的最开始，&lt;code&gt;vue-simple-uploader&lt;/code&gt;会发送一个get请求，来问服务器我哪些分片已经上传过了，&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1294929/201812/1294929-20181205144831614-604581292.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个请求返回的结果也有几种可能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;a. 如果是&lt;strong&gt;秒传&lt;/strong&gt;，在请求结果中会有相应的标识，比如我这里是&lt;code&gt;skipUpload&lt;/code&gt;为&lt;code&gt;true&lt;/code&gt;，且返回了&lt;code&gt;url&lt;/code&gt;，代表服务器告诉我们这个文件已经有了，我直接把&lt;code&gt;url&lt;/code&gt;给你，你不用再传了，这就是&lt;strong&gt;秒传&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;图a1：秒传情况下后台返回值&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1294929/201812/1294929-20181205144856723-1634888086.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图a2：秒传gif&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1294929/201812/1294929-20181205144240125-1096993697.gif&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;b. 如果后台返回了分片信息，这是&lt;strong&gt;断点续传&lt;/strong&gt;。如图，返回的数据中有个&lt;code&gt;uploaded&lt;/code&gt;的字段，代表这些分片是已经上传过的了，插件会自动跳过这些分片的上传。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;图b1：断点续传情况下后台返回值&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1294929/201812/1294929-20181205144903900-1724308708.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图b2：断点续传gif&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1294929/201812/1294929-20181205144251872-315232482.gif&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;c. 可能什么都不会返回，那这就是个全新的文件了，走完整的分片上传逻辑&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;前端做分片检验checkchunkuploadedbyresponse&quot;&gt;7.2 前端做分片检验：&lt;code&gt;checkChunkUploadedByResponse&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;前面讲的是概念，现在说一说前端在拿到这些返回值之后怎么处理。&lt;br/&gt;插件自己是不会判断哪个需要跳过的，在代码中由&lt;code&gt;options&lt;/code&gt;中的&lt;code&gt;checkChunkUploadedByResponse&lt;/code&gt;控制，它会根据 XHR 响应内容检测每个块是否上传成功了，成功的分片直接跳过上传&lt;br/&gt;你要在这个函数中进行处理，可以跳过的情况下返回true即可。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;checkChunkUploadedByResponse: function (chunk, message) {
     let objMessage = JSON.parse(message);
     if (objMessage.skipUpload) {
         return true;
     }

     return (objMessage.uploaded || []).indexOf(chunk.offset + 1) &amp;gt;= 0
},&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注：&lt;code&gt;skipUpload&lt;/code&gt; 和 &lt;code&gt;uploaded&lt;/code&gt; 是我和后台商议的字段，你要按照后台实际返回的字段名来。&lt;/p&gt;
&lt;h2 id=&quot;源码及后记&quot;&gt;8. 源码及后记&lt;/h2&gt;
&lt;p&gt;总共几个文件，&lt;code&gt;app.vue&lt;/code&gt;，封装的全局上传组件&lt;code&gt;globalUploader.vue&lt;/code&gt;，调用组件的&lt;code&gt;demo.vue&lt;/code&gt;，源码放到github上了：&lt;a href=&quot;https://github.com/shady-xia/Blog/tree/master/vue-simple-uploader&quot; class=&quot;uri&quot;&gt;https://github.com/shady-xia/Blog/tree/master/vue-simple-uploader&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;globalUploader&lt;/code&gt;源码中的&lt;code&gt;ticket&lt;/code&gt;和&lt;code&gt;api&lt;/code&gt;都是自己用的， 一个是accesstoken，一个是基于axios封装的请求库，请根据你的业务需求替代之。另外上传界面的展开和收起用到了&lt;code&gt;jquery&lt;/code&gt;，通知用到了Element的组件，请忽略之。&lt;/p&gt;
&lt;p&gt;本人水平有限，更多的是提供一个思路，供大家参考。&lt;/p&gt;
&lt;p&gt;封装完这个插件后，再加上开发文件资源库，我发现已经基本实现了一个简易的百度网盘了，一个管理系统，功能搞的这么复杂，坑爹啊！&lt;/p&gt;
</description>
<pubDate>Wed, 05 Dec 2018 07:22:00 +0000</pubDate>
<dc:creator>夏大师</dc:creator>
<og:description>[TOC] 1. 前言 之前公司要在管理系统中做一个全局上传插件，即切换各个页面的时候，上传界面还在并且上传不会受到影响，这在vue这种spa框架面前并不是什么难题。然而后端大佬说我们要实现 分片上传</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiahj/p/vue-simple-uploader.html</dc:identifier>
</item>
<item>
<title>一分钟读懂兼容测试报告（一）：概况篇 - 腾讯WeTest</title>
<link>http://www.cnblogs.com/wetest/p/10071125.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wetest/p/10071125.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;WeTest 导读&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在&lt;span&gt;WeTest深度兼容&lt;span&gt;测试&lt;span&gt;上线之后，为&lt;span&gt;大量手游&lt;span&gt;及应用&lt;span&gt;挖掘了兼容问题&lt;span&gt;，为测试开发同学提供了极大的便利。&lt;span&gt;为了&lt;span&gt;能够让测试&lt;span&gt;开发&lt;span&gt;同学能够&lt;span&gt;迅速&lt;span&gt;的了解测试后的&lt;span&gt;结果&lt;span&gt;，您是否真的读懂了WeTest的兼容报告？是否&lt;span&gt;了解&lt;span&gt;具体问题的准确定位？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;
&lt;p&gt;&lt;span&gt; &lt;span&gt;WeTest&lt;span&gt;兼容&lt;span&gt;测试&lt;span&gt;报告总共分&lt;span&gt;五&lt;span&gt;大块&lt;span&gt;：&lt;span&gt;测试概况、问题列表、设备详情、性能报告和重测&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;测试&lt;span&gt;概况&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;提交测试&lt;span&gt;后，一般等待&lt;span&gt;1-4小时后&lt;span&gt;，&lt;span&gt;&lt;span&gt;可在“&lt;span&gt;我的报告&lt;span&gt;”中&lt;span&gt;查看测试报告，最&lt;span&gt;先&lt;span&gt;看到的是&lt;span&gt;测试&lt;span&gt;概况。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/992994/201812/992994-20181205151200388-986281654.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过&lt;span&gt;测试概况可以看到&lt;span&gt;：&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. &lt;strong&gt;&lt;span&gt;测试&lt;span&gt;通过率&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;span&gt;&lt;span&gt;通过的机型数/测试的机型总数&lt;span&gt;；描述的是应用在数百部机型上，通过机型数占比，是衡量应用质量最直接的指标。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2. &lt;span&gt;覆盖用户数&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;测试的每款机型对应的使用人数之和。WeTest根据各款机型的销量情况&lt;span&gt;及第三方统计数据，得出每款机型对应的使用人群数量。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3. &lt;strong&gt;&lt;span&gt;问题&lt;span&gt;概述&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;span&gt;本次&lt;span&gt;测试总共&lt;span&gt;发现&lt;span&gt;问题次数，&lt;strong&gt;&lt;span&gt;问题概述会重点显示用户最需要关注的问题，一般是严重级别和致命级别的问题。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/992994/201812/992994-20181205151207145-1640142087.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4. &lt;strong&gt;&lt;span&gt;问题分布&lt;span&gt;情况&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;span&gt;问题级别&lt;span&gt;分为四类，根据问题对用户使用影响分为四类，影响从高到低分为四级，分别是&lt;strong&gt;&lt;span&gt;致命&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;、&lt;strong&gt;&lt;span&gt;严重&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;、&lt;strong&gt;&lt;span&gt;一般&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;、&lt;strong&gt;&lt;span&gt;提示&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;（提示级别的问题，不会影响测试通过率）。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5. &lt;strong&gt;&lt;span&gt;问题机型聚类&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：问题机型聚类这部分旨在帮助用户高效定位问题发生的规律和原因。报告将某一特定问题如&lt;span&gt;UI异常、App Crash&lt;span&gt;，按&lt;strong&gt;&lt;span&gt;品牌&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;、&lt;strong&gt;&lt;span&gt;系统&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;、&lt;strong&gt;&lt;span&gt;分辨率&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;三个维度进行聚类分析，帮助用户就某一特定问题进行机型锁定。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/992994/201812/992994-20181205151213378-875559067.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;T&lt;span&gt;ips&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;:底部&lt;span&gt;可以&lt;strong&gt;&lt;span&gt;添加&lt;span&gt;附件&lt;span&gt;和备注&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;信息&lt;span&gt;，主要用于用户上传&lt;span&gt;/&lt;span&gt;&lt;span&gt;填写反馈意见，包括使用困难、产品功能预期等，以便于报告流转过程中，进行信息沟通，以不断优化We&lt;span&gt;Test&lt;span&gt;产品。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;问题&lt;span&gt;列表&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;问题&lt;span&gt;列表一栏&lt;span&gt;提供&lt;span&gt;了&lt;strong&gt;&lt;span&gt;本次&lt;span&gt;测试中所有&lt;span&gt;出现&lt;span&gt;的&lt;span&gt;问题&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，用户可以根据需求，对问题进行级别和类别的筛选。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/992994/201812/992994-20181205151223261-722106445.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;右侧&lt;span&gt;查看一栏可以&lt;span&gt;跳转&lt;span&gt;到相应设备的测试详情页面&lt;span&gt;，包含本次&lt;span&gt;测试设备的&lt;span&gt;问题原因、问题现场&lt;span&gt;、截图、日志&lt;span&gt;信息&lt;span&gt;和&lt;span&gt;性能&lt;span&gt;数据&lt;span&gt;。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;问题原因&lt;span&gt;：&lt;span&gt;直&lt;span&gt;观看到&lt;span&gt;设备出现的问题概述。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/992994/201812/992994-20181205151230223-1323114529.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;定位&lt;span&gt;问题&lt;span&gt;：可按时间轴点击&lt;span&gt;直接跳转&lt;span&gt;到&lt;span&gt;问题所在，结合下方&lt;span&gt;操作&lt;span&gt;过程截图&lt;span&gt;和&lt;span&gt;实时日志信息&lt;span&gt;，帮助&lt;span&gt;用户更好定位问题。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/992994/201812/992994-20181205151236904-1028520757.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/992994/201812/992994-20181205151242464-1059783696.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;设备&lt;span&gt;详情&lt;span&gt;页&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;设备&lt;span&gt;详情&lt;span&gt;页可查看每台&lt;span&gt;设备的测试情况&lt;span&gt;，可&lt;span&gt;通过不同维度的筛选功能，定位具体设备&lt;span&gt;的&lt;span&gt;测试结果。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;点击“调试”可以跳转&lt;span&gt;到云真机&lt;span&gt;，&lt;span&gt;进行远程&lt;span&gt;真机&lt;span&gt;调试。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/992994/201812/992994-20181205151251725-1229651911.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;查看&lt;span&gt;设备详情页&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从&lt;span&gt;列表中&lt;span&gt;点击&lt;span&gt;设备详情页面，可以查看&lt;span&gt;详细测试&lt;span&gt;情况&lt;span&gt;，&lt;strong&gt;&lt;span&gt;主要包括&lt;span&gt;测试&lt;span&gt;结果&lt;span&gt;、&lt;span&gt;测试数据&lt;span&gt;、数据&lt;span&gt;和截图三大块&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;测试&lt;span&gt;结果&lt;span&gt;可以查看&lt;span&gt;测试出现&lt;span&gt;的问题&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/992994/201812/992994-20181205151304701-1200151463.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;测试&lt;span&gt;数据&lt;span&gt;包括&lt;span&gt;安装时间&lt;span&gt;、&lt;span&gt;&lt;span&gt;拉起时间、cpu占用、平均内存占用、流量消耗、平均&lt;span&gt;FPS、&lt;span&gt;测试耗时情况&lt;span&gt;。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/992994/201812/992994-20181205151310387-1742585070.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;数据&lt;span&gt;和截图&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以&lt;span&gt;查看&lt;span&gt;每次&lt;span&gt;操作的截图情况，&lt;span&gt;浏览&lt;span&gt;全部&lt;span&gt;测试&lt;span&gt;操作，方便用户更好定位问题。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/992994/201812/992994-20181205151613341-26145967.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;性能&lt;span&gt;数据&lt;span&gt;包括&lt;span&gt;测试中&lt;span&gt;&lt;span&gt;实时CPU数据&lt;span&gt;、&lt;span&gt;内存、流量&lt;span&gt;、&lt;span&gt;FPS数据情况。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/992994/201812/992994-20181205151622640-1652084004.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;日志&lt;span&gt;信息&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以&lt;span&gt;查看本次&lt;span&gt;设备&lt;span&gt;测试的日志情况，更精准定位问题出现原因。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/992994/201812/992994-20181205151630855-1968344364.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;性能&lt;span&gt;报告&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;性能报告由两部分内容组成，一是每款机型的性能数据，二是本次测试覆盖机型性能的区间分布及性能最差5款机型的情况。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;性能&lt;span&gt;测试&lt;span&gt;数据&lt;span&gt;包括&lt;span&gt;：安装&lt;span&gt;耗时、启动耗时、&lt;span&gt;CPU占用&lt;span&gt;、内存占用&lt;span&gt;、&lt;span&gt;流量消耗和&lt;span&gt;FPS数据&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/992994/201812/992994-20181205151636953-785058090.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;性能总览包括&lt;span&gt;：&lt;span&gt;安装&lt;span&gt;耗时&lt;span&gt;分布&lt;span&gt;、启动耗时&lt;span&gt;分布、&lt;span&gt;平均内存分布占用、&lt;span&gt;内存&lt;span&gt;峰值占用&lt;span&gt;、&lt;span&gt;流量消耗&lt;span&gt;分布&lt;span&gt;情况&lt;span&gt;。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/992994/201812/992994-20181205151643070-564372570.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;hr/&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;“深度兼容测试”现已对外，腾讯专家为您定制自动化测试脚本，覆盖应用核心场景，对上百款主流机型进行适配兼容测试，提供详细测试报告&lt;strong&gt;。&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;strong&gt;点击：&lt;a href=&quot;http://wetest.qq.com/cloud/deepcompatibilitytesting#/?from=content_cnblogs&quot; target=&quot;_blank&quot;&gt;http://wetest.qq.com/cloud/deepcompatibilitytesting#/&lt;/a&gt; 即可体验。&lt;/strong&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;如果使用当中有任何疑问，欢迎联系腾讯WeTest企业QQ：2852350015&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 05 Dec 2018 07:20:00 +0000</pubDate>
<dc:creator>腾讯WeTest</dc:creator>
<og:description>WeTest 导读 在WeTest深度兼容测试上线之后，为大量手游及应用挖掘了兼容问题，为测试开发同学提供了极大的便利。为了能够让测试开发同学能够迅速的了解测试后的结果，您是否真的读懂了WeTest的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wetest/p/10071125.html</dc:identifier>
</item>
<item>
<title>MySQL数据库优化小结 - lgp20151222</title>
<link>http://www.cnblogs.com/ydymz/p/10070184.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ydymz/p/10070184.html</guid>
<description>&lt;p&gt;有什么错漏，说一下，数据库这些都是经验之谈，总有错过的。&lt;/p&gt;


&lt;p&gt;以前都说三大范式，具体应该叫数据库范式&lt;/p&gt;
&lt;p&gt;第一范式-表的数据不重复，&lt;span&gt;数据是唯一的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;第二范式-表的数据有主键，&lt;span&gt;数据是有主属性可查的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;第三范式-表的其他普通数据不依赖其他普通数据，就是依赖的数据记得给索引。&lt;span&gt;要用其他属性做查询条件记得用索引&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;巴斯-科德范式(我称为三个半范式)-表的数据与其他表的数据（子集）的关系，表的其他普通数据 不依赖 其他表的数据，外键。&lt;span&gt;其他表的数据（子集）不该有表的冗杂数据，表不该有其他表的数据（子集）的冗杂数据，而且还要有他的主键或者索引（外键）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;以上基本面试可能问到，三个半范式答出来算加分项。后面的范式就到了基本这时候就到了代码设计事务逻辑这层次了。&lt;/p&gt;

&lt;p&gt;第四范式-表插入、删除、修改数据时，不传递未修改的数据。&lt;span&gt;其他表（子集）修改数据设计到表依赖的索引时要传递修改&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;
&lt;span&gt;sql.update(dto)；

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
Dto &lt;span&gt;new&lt;/span&gt; =&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Dto();
&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt;.setChangeData(dto.getChangeData());
sql.update(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;)；
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第五范式（完美范式）-表的数据仅含有其他表的数据（子集）的主键。&lt;span&gt;查询相关数据时要连表查询，表基本变成索引表（字典表）&lt;/span&gt;。ps.每次新增要新增其他子集表！！&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;TABLE{
TNO,
USERNO,
CARNO
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;实际上&lt;/p&gt;
&lt;p&gt;因为需求的多变性，除非一些大型的不思进取的项目，基本都不会整个项目符合第五范式，顶多某一部分用了字典表。而每次新增都要新增其他子集表，给数据库带来极大压力。&lt;/p&gt;
&lt;p&gt;故第五范式淘汰。&lt;span&gt;总结，字典表可小功能实现，不要求到整个项目。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;因为表插入、删除、修改数据时，不传递未修改的数据可以用代码控制，而其他表（子集）修改数据（表依赖的索引）时要传递修改到表，则同样给数据库带来一部分压力，而且为什么不借鉴第六范式，外键为其主键，规定其不可修改，那么就不存在传递修改到表。&lt;/p&gt;
&lt;p&gt;故第四范式扑街。&lt;span&gt;总结，用代码控制插入修改删除的传递，外键通过不可变和数据一致性来取消使用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;因为现在过量设计的原因，能冗杂就冗杂，例如一个用户表一个文章表，文章必显示用户昵称头像，难道还要再查一次用户数据？&lt;/p&gt;
&lt;p&gt;故第三个半范式牺牲。&lt;span&gt;总结，过量设计，适当冗杂。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;因为涉及到时间排序查询时，给时间做索引基本不会起作用，依然是全表查询，所以整条数据都依赖时间的时候，不给时间加索引。&lt;/p&gt;
&lt;p&gt;故第三范式死不瞑目。&lt;span&gt;总结，索引设计要合理。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;也就是说我们设计数据库，符合第一第二范式就是一个合格的基本设计了。&lt;span&gt;给表加主键&lt;/span&gt;！而其他的地方都是我们优化的点！&lt;/p&gt;


&lt;p&gt;字段固定长度，尽可能短。&lt;/p&gt;
&lt;p&gt;可确定值设计为enum性，如男女省份等（快是快了，但是要改的话就麻烦了，所以不建议）&lt;/p&gt;
&lt;p&gt;使用not null（null，empty并不是不存数据，null存了null数据，empty则存相应类型的默认值，那设置为null还要在程序做个判断多麻烦啊）ps.mybatis返回自动过滤null，所以java接触到这情况很少。但是其他语言有啊。&lt;/p&gt;
&lt;p&gt;水平划分。&lt;/p&gt;
&lt;p&gt;垂直划分。&lt;/p&gt;
&lt;p&gt;大数据保存地址。&lt;/p&gt;
&lt;p&gt;不使用Distinct，用Group By，exist 代替&lt;/p&gt;
&lt;p&gt;批量操作，不是存储过程那种批量操作。（查询返回list，插入参数list）&lt;/p&gt;
&lt;p&gt;查询不用select*&lt;/p&gt;
&lt;p&gt;查询一个时，使用limit 1.&lt;/p&gt;
&lt;p&gt;查询条件先索引再让容易过滤的过滤。&lt;/p&gt;
&lt;p&gt;时间的比较，远比时间转为毫秒比较慢。&lt;/p&gt;
&lt;p&gt;多表查询用join不用子查询&lt;/p&gt;
&lt;p&gt;不用order by rand()（这个是全查完在重排，正常是边查边重排）&lt;/p&gt;
&lt;p&gt;启动慢查询日志。&lt;/p&gt;
&lt;p&gt;启动查询缓存&lt;/p&gt;
&lt;p&gt;更换数据库引擎。（到了这步，还不如重新设计）&lt;/p&gt;
&lt;p&gt;读写服务分离。&lt;/p&gt;


&lt;p&gt;如何建立索引一定会用到&lt;span&gt;explain&lt;/span&gt;命令，查询性能分析，以前写过，现在就不说了。&lt;/p&gt;
&lt;p&gt;https://www.cnblogs.com/ydymz/p/9167734.html&lt;/p&gt;
&lt;p&gt;https://www.cnblogs.com/ydymz/p/9167637.html&lt;/p&gt;

&lt;p&gt;&lt;span&gt;而索引的设计只要绕开索引失效的情况，而索引失效的情况explain的返回就有&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;例如&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;MyISAM的索引长度超过1000就大幅降低性能，最好在500左右。（这个是真网上看来，自己试都没试）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;建有索引的字段上尽量不要使用函数进行操作，除非做了函数索引&lt;/span&gt;。（不是所有数据库支持）&lt;/p&gt;
&lt;p&gt;索引表应该小于数据表。查询索引表时间长于数据表，那还不如全表查询。这个时候说明你要重新设计表或者索引了（水平垂直划分，前缀索引）。&lt;/p&gt;
&lt;p&gt;比较用了强制类型转换，索引不生效。&lt;/p&gt;
&lt;p&gt;使用模糊查询，索引不生效。&lt;/p&gt;
&lt;p&gt;使用&amp;lt;&amp;gt;,!=，not in，not exist等运算，索引不生效。&lt;/p&gt;
&lt;p&gt;查询得到的结果太大，接近总量的30%（接近总量的1%都很恐怖了）&lt;/p&gt;
&lt;p&gt;单独引用复合索引里非第一位置的索引列。&lt;/p&gt;
</description>
<pubDate>Wed, 05 Dec 2018 07:18:00 +0000</pubDate>
<dc:creator>lgp20151222</dc:creator>
<og:description>有什么错漏，说一下，数据库这些都是经验之谈，总有错过的。 一 数据库设计 以前都说三大范式，具体应该叫数据库范式 第一范式-表的数据不重复，数据是唯一的 第二范式-表的数据有主键，数据是有主属性可查的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ydymz/p/10070184.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core2实现静默获取微信公众号的用户OpenId - Andre-Hub</title>
<link>http://www.cnblogs.com/Andre/p/10071022.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Andre/p/10071022.html</guid>
<description>&lt;p&gt;最近在做个微信公众号的项目，需要将入口放置在公众号二级菜单内，通过点击该菜单链接后进入到该项目中去，进入到项目后程序会自动通过微信公众号的API完成用户的OpenId获取。需求很简单，实现起来也不复杂，于是在一番折腾后需求实现了。为此，写下此文仅为初次接触的朋友提供个小小的帮助。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;准备&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;老规矩，在开始动手前，咱们先简单介绍下实现的组成部分，如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;微信公众号静默获取用户OpenId：&lt;/strong&gt;要实现该功能，可以通过微信公众号提供的“网页授权”接口完成（官网描述：以snsapi_base为scope发起的网页授权，是用来获取进入页面的用户的openid的，并且是静默授权并自动跳转到回调页的。用户感知的就是直接进入了回调页（往往是业务页面）），具体说明在此：&lt;a title=&quot;https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;amp;id=mp1421140842&quot; href=&quot;https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;amp;id=mp1421140842&quot; target=&quot;_blank&quot;&gt;https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;amp;id=mp1421140842&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Lezhima.Site：&lt;/strong&gt;是一个基于ASP.NET Core2的Web Mvc带视图的程序，用来模拟接受微信公众号菜单链接的请求，并自动获取用户的OpenId。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;准备&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如上面所述，我们已经清楚了整个实现思路，那么下面就来看看Lezhima.Site项目内的代码实现吧：&lt;/p&gt;
&lt;p&gt;1、首先我们先创建一个名为“BasicController”的业务基类，并继承“Controller”类。其作用有两个，一是将验证是否正确获取OpenId的业务封装成基类，二是方便其它业务控制器使用OpenId。具体代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;/// &amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;/// 业务基类&lt;/span&gt;
&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;/// &amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BasicController:Controller
&lt;span&gt;  5&lt;/span&gt; {
&lt;span&gt;  6&lt;/span&gt;        &lt;span&gt;//当前用户openId&lt;/span&gt;
&lt;span&gt;  7&lt;/span&gt;        &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; CurrentUserOpenId { &lt;span&gt;set&lt;/span&gt;; &lt;span&gt;get&lt;/span&gt;; }
&lt;span&gt;  8&lt;/span&gt; 
&lt;span&gt;  9&lt;/span&gt;        &lt;span&gt;public&lt;/span&gt; BasicController()
&lt;span&gt; 10&lt;/span&gt;        {
&lt;span&gt; 11&lt;/span&gt;                &lt;span&gt;//从Cookie中获取当前用户的openId&lt;/span&gt;
&lt;span&gt; 12&lt;/span&gt;                var cookie = Cookies.GetCookieByUser();
&lt;span&gt; 13&lt;/span&gt;                &lt;span&gt;//如果没有，则导航到指定提示页，需要用户关闭后重新进入&lt;/span&gt;
&lt;span&gt; 14&lt;/span&gt;                &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;.IsNullOrEmpty(cookie))
&lt;span&gt; 15&lt;/span&gt;                {
&lt;span&gt; 16&lt;/span&gt;                        System.Web.HttpContext.Current.Response.Redirect(&quot;&lt;span&gt;/VxinWeb/Index&lt;/span&gt;&quot;);
&lt;span&gt; 17&lt;/span&gt;                        &lt;span&gt;return&lt;/span&gt;;
&lt;span&gt; 18&lt;/span&gt;                }
&lt;span&gt; 19&lt;/span&gt; 
&lt;span&gt; 20&lt;/span&gt;                CurrentUserOpenId = cookie;
&lt;span&gt; 21&lt;/span&gt;        }
&lt;span&gt; 22&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2、再创建一个名为“VxinWebController”的控制器与View视图。其作用是用来接受来自微信公众号菜单内的链接入口，并自动完成获取用户OpenId。代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;/// &amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;/// 此页面用于对外微信菜单地址，用于获取用户openId&lt;/span&gt;
&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;/// 这是本系统网页的入口&lt;/span&gt;
&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;/// &amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; VxinWebController : Controller
&lt;span&gt;  6&lt;/span&gt; {
&lt;span&gt;  7&lt;/span&gt;        &lt;span&gt;public&lt;/span&gt; ActionResult Index()
&lt;span&gt;  8&lt;/span&gt;        {
&lt;span&gt;  9&lt;/span&gt;                &lt;span&gt;//获取当前进到本系统的微信用户的openid&lt;/span&gt;
&lt;span&gt; 10&lt;/span&gt;                &lt;span&gt;//该请求从微信那边过来&lt;/span&gt;
&lt;span&gt; 11&lt;/span&gt;                &lt;span&gt;if&lt;/span&gt; (Request.QueryString[&quot;&lt;span&gt;code&lt;/span&gt;&quot;] != &lt;span&gt;null&lt;/span&gt;)
&lt;span&gt; 12&lt;/span&gt;                {
&lt;span&gt; 13&lt;/span&gt;                        var code = Request.QueryString[&quot;&lt;span&gt;code&lt;/span&gt;&quot;].ToString();
&lt;span&gt; 14&lt;/span&gt;                        var openId = VxinUtils.GetOpenID(code);
&lt;span&gt; 15&lt;/span&gt;                        &lt;span&gt;if&lt;/span&gt; (openId == &lt;span&gt;null&lt;/span&gt;)&lt;span&gt;//没有获取到openId&lt;/span&gt;
&lt;span&gt; 16&lt;/span&gt;                        {
&lt;span&gt; 17&lt;/span&gt;                                &lt;span&gt;//返回当前视图，需要提示用户关闭窗口，尝试重新进入&lt;/span&gt;
&lt;span&gt; 18&lt;/span&gt;                                &lt;span&gt;return&lt;/span&gt; View();
&lt;span&gt; 19&lt;/span&gt;                        }
&lt;span&gt; 20&lt;/span&gt;                        &lt;span&gt;//将openId放入cookie，放到cookie之前需将openId进行加密，取出来后再解密&lt;/span&gt;
&lt;span&gt; 21&lt;/span&gt;                        Cookies.SetUserToCookie(openId);
&lt;span&gt; 22&lt;/span&gt;                        &lt;span&gt;return&lt;/span&gt; RedirectToAction(&quot;&lt;span&gt;Index&lt;/span&gt;&quot;, &quot;&lt;span&gt;Home&lt;/span&gt;&quot;);
&lt;span&gt; 23&lt;/span&gt;                }
&lt;span&gt; 24&lt;/span&gt;                &lt;span&gt;return&lt;/span&gt; View();
&lt;span&gt; 25&lt;/span&gt;        }
&lt;span&gt; 26&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;3、在第二步时，我们发现有个VxinUtils类，该类封装了对微信公众号API的操作，具体代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;/// &amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;/// 微信公众号工具类&lt;/span&gt;
&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;/// &amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; VxinUtils
&lt;span&gt;  5&lt;/span&gt; {
&lt;span&gt;  6&lt;/span&gt; 
&lt;span&gt;  7&lt;/span&gt;        &lt;span&gt;/// &amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;  8&lt;/span&gt;        &lt;span&gt;/// 微信token&lt;/span&gt;
&lt;span&gt;  9&lt;/span&gt;        &lt;span&gt;/// &amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 10&lt;/span&gt;        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; WeiXinToken { &lt;span&gt;get&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt; ConfigurationManager.AppSettings[&quot;&lt;span&gt;WeiXinToken&lt;/span&gt;&quot;].ToString(); } }
&lt;span&gt; 11&lt;/span&gt; 
&lt;span&gt; 12&lt;/span&gt;        &lt;span&gt;/// &amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 13&lt;/span&gt;        &lt;span&gt;/// 微信appID&lt;/span&gt;
&lt;span&gt; 14&lt;/span&gt;        &lt;span&gt;/// &amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 15&lt;/span&gt;        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; AppID { &lt;span&gt;get&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt; ConfigurationManager.AppSettings[&quot;&lt;span&gt;AppID&lt;/span&gt;&quot;].ToString(); } }
&lt;span&gt; 16&lt;/span&gt; 
&lt;span&gt; 17&lt;/span&gt; 
&lt;span&gt; 18&lt;/span&gt;        &lt;span&gt;/// &amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 19&lt;/span&gt;        &lt;span&gt;/// 微信Aappsecret&lt;/span&gt;
&lt;span&gt; 20&lt;/span&gt;        &lt;span&gt;/// &amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 21&lt;/span&gt;        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Appsecret { &lt;span&gt;get&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt; ConfigurationManager.AppSettings[&quot;&lt;span&gt;Appsecret&lt;/span&gt;&quot;].ToString(); } }
&lt;span&gt; 22&lt;/span&gt; 
&lt;span&gt; 23&lt;/span&gt; 
&lt;span&gt; 24&lt;/span&gt;        &lt;span&gt;/// &amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 25&lt;/span&gt;        &lt;span&gt;/// 获得access_token地址&lt;/span&gt;
&lt;span&gt; 26&lt;/span&gt;        &lt;span&gt;/// &amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 27&lt;/span&gt;        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Access_token_URL { &lt;span&gt;get&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;.Format(&quot;&lt;span&gt;https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;amp;appid={0}&amp;amp;secret={1}&lt;/span&gt;&quot;, AppID, Appsecret); } }
&lt;span&gt; 28&lt;/span&gt; 
&lt;span&gt; 29&lt;/span&gt;        &lt;span&gt;/// &amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 30&lt;/span&gt;        &lt;span&gt;/// 通过code换取网页授权access_token地址&lt;/span&gt;
&lt;span&gt; 31&lt;/span&gt;        &lt;span&gt;/// &amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 32&lt;/span&gt;        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Web_Access_token_URL { &lt;span&gt;get&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;.Format(&quot;&lt;span&gt;https://api.weixin.qq.com/sns/oauth2/access_token?appid={0}&amp;amp;secret={1}&amp;amp;grant_type=authorization_code&amp;amp;code=&lt;/span&gt;&quot;, AppID, Appsecret); } }
&lt;span&gt; 33&lt;/span&gt; 
&lt;span&gt; 34&lt;/span&gt; 
&lt;span&gt; 35&lt;/span&gt;        &lt;span&gt;/// &amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 36&lt;/span&gt;        &lt;span&gt;/// 微信菜单创建提交地址&lt;/span&gt;
&lt;span&gt; 37&lt;/span&gt;        &lt;span&gt;/// &amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 38&lt;/span&gt;        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; MENU_POST_URL { &lt;span&gt;get&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt; &quot;&lt;span&gt;https://api.weixin.qq.com/cgi-bin/menu/create?access_token=&lt;/span&gt;&quot;; } }
&lt;span&gt; 39&lt;/span&gt; 
&lt;span&gt; 40&lt;/span&gt; 
&lt;span&gt; 41&lt;/span&gt;        &lt;span&gt;/// &amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 42&lt;/span&gt;        &lt;span&gt;/// 微信获取用户分组地址&lt;/span&gt;
&lt;span&gt; 43&lt;/span&gt;        &lt;span&gt;/// &amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 44&lt;/span&gt;        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Group_Get_Url { &lt;span&gt;get&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt; &quot;&lt;span&gt;https://api.weixin.qq.com/cgi-bin/groups/get?access_token=&lt;/span&gt;&quot;; } }
&lt;span&gt; 45&lt;/span&gt; 
&lt;span&gt; 46&lt;/span&gt; 
&lt;span&gt; 47&lt;/span&gt;        &lt;span&gt;/// &amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 48&lt;/span&gt;        &lt;span&gt;/// 微信修改用户分组地址&lt;/span&gt;
&lt;span&gt; 49&lt;/span&gt;        &lt;span&gt;/// &amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 50&lt;/span&gt;        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Group_Update_Url { &lt;span&gt;get&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt; &quot;&lt;span&gt;https://api.weixin.qq.com/cgi-bin/groups/members/update?access_token=&lt;/span&gt;&quot;; } }
&lt;span&gt; 51&lt;/span&gt; 
&lt;span&gt; 52&lt;/span&gt; 
&lt;span&gt; 53&lt;/span&gt; 
&lt;span&gt; 54&lt;/span&gt;        &lt;span&gt;/// &amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 55&lt;/span&gt;        &lt;span&gt;/// 微信获取用户所属分组地址&lt;/span&gt;
&lt;span&gt; 56&lt;/span&gt;        &lt;span&gt;/// &amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 57&lt;/span&gt;        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Group_GetUserGroup_Url { &lt;span&gt;get&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt; &quot;&lt;span&gt;https://api.weixin.qq.com/cgi-bin/groups/getid?access_token=&lt;/span&gt;&quot;; } }
&lt;span&gt; 58&lt;/span&gt; 
&lt;span&gt; 59&lt;/span&gt;        &lt;span&gt;/// &amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 60&lt;/span&gt;        &lt;span&gt;/// 拉取用户信息(需scope为 snsapi_userinfo)&lt;/span&gt;
&lt;span&gt; 61&lt;/span&gt;        &lt;span&gt;/// 如果网页授权作用域为snsapi_userinfo，则此时开发者可以通过access_token和openid拉取用户信息了。&lt;/span&gt;
&lt;span&gt; 62&lt;/span&gt;        &lt;span&gt;/// https://api.weixin.qq.com/sns/userinfo?access_token=ACCESS_TOKEN&amp;amp;openid=OPENID&amp;amp;lang=zh_CN&lt;/span&gt;
&lt;span&gt; 63&lt;/span&gt;        &lt;span&gt;/// &amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 64&lt;/span&gt;        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; GetUserUserinfo_Url { &lt;span&gt;get&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt; &quot;&lt;span&gt;https://api.weixin.qq.com/sns/userinfo?lang=zh_CN&amp;amp;access_token=&lt;/span&gt;&quot;; } }
&lt;span&gt; 65&lt;/span&gt; 
&lt;span&gt; 66&lt;/span&gt; 
&lt;span&gt; 67&lt;/span&gt;        &lt;span&gt;/// &amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 68&lt;/span&gt;        &lt;span&gt;/// 获取用户的OpenId&lt;/span&gt;
&lt;span&gt; 69&lt;/span&gt;        &lt;span&gt;/// &amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 70&lt;/span&gt;        &lt;span&gt;/// &amp;lt;param name=&quot;code&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 71&lt;/span&gt;        &lt;span&gt;/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt; 72&lt;/span&gt;        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; GetOpenID(&lt;span&gt;string&lt;/span&gt; code)
&lt;span&gt; 73&lt;/span&gt;        {
&lt;span&gt; 74&lt;/span&gt;                var openid = &quot;&quot;;
&lt;span&gt; 75&lt;/span&gt;                &lt;span&gt;using&lt;/span&gt; (var wl = &lt;span&gt;new&lt;/span&gt; WebClient())
&lt;span&gt; 76&lt;/span&gt;                {
&lt;span&gt; 77&lt;/span&gt;                        wl.Headers.Add(HttpRequestHeader.Accept, &quot;&lt;span&gt;json&lt;/span&gt;&quot;);
&lt;span&gt; 78&lt;/span&gt;                        wl.Headers.Add(HttpRequestHeader.ContentType, &quot;&lt;span&gt;application/json;charset=UTF-8&lt;/span&gt;&quot;);
&lt;span&gt; 79&lt;/span&gt;                        wl.Headers.Add(HttpRequestHeader.UserAgent, &quot;&lt;span&gt;Mozilla/4.0&lt;/span&gt;&quot;);
&lt;span&gt; 80&lt;/span&gt;                        wl.Encoding = Encoding.UTF8;
&lt;span&gt; 81&lt;/span&gt;                        openid = wl.DownloadString(Web_Access_token_URL + code);
&lt;span&gt; 82&lt;/span&gt;                }
&lt;span&gt; 83&lt;/span&gt;                &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;string&lt;/span&gt;.IsNullOrEmpty(openid))
&lt;span&gt; 84&lt;/span&gt;                {
&lt;span&gt; 85&lt;/span&gt;                        var token = JObject.Parse(openid).SelectToken(&quot;&lt;span&gt;openid&lt;/span&gt;&quot;);
&lt;span&gt; 86&lt;/span&gt;                        &lt;span&gt;if&lt;/span&gt; (token != &lt;span&gt;null&lt;/span&gt;)
&lt;span&gt; 87&lt;/span&gt;                                openid = token.ToString();
&lt;span&gt; 88&lt;/span&gt;                }
&lt;span&gt; 89&lt;/span&gt;                &lt;span&gt;return&lt;/span&gt; openid;
&lt;span&gt; 90&lt;/span&gt;        }
&lt;span&gt; 91&lt;/span&gt; 
&lt;span&gt; 92&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、基于“snsapi_base为scope发起的网页授权”的微信公众号方案，可以很方便的实现用户静默授权及获取用户的OpenId。&lt;/p&gt;
&lt;p&gt;2、通过将获取到的OpenId写入在Cookie中，并封装一个业务基类完成Cookie的读取与判断，可以使其它业务类很方便的使用OpenId。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;声明&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本文为作者原创，转载请备注出处与保留原文地址，谢谢。如文章能给您带来帮助，请点下推荐或关注，感谢您的支持！&lt;/p&gt;

</description>
<pubDate>Wed, 05 Dec 2018 07:11:00 +0000</pubDate>
<dc:creator>Andre-Hub</dc:creator>
<og:description>最近在做个微信公众号的项目，需要将入口放置在公众号二级菜单内，通过点击该菜单链接后进入到该项目中去，进入到项目后程序会自动通过微信公众号的API完成用户的OpenId获取。需求很简单，实现起来也不复杂</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Andre/p/10071022.html</dc:identifier>
</item>
<item>
<title>Python操作redis数据库 - 马一特</title>
<link>http://www.cnblogs.com/mayite/p/10071020.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mayite/p/10071020.html</guid>
<description>&lt;h2&gt;一 redis介绍&lt;/h2&gt;
&lt;p&gt;　　redis是一个key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set --有序集合)和hash（哈希类型）。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，redis支持各种不同方式的排序。与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。&lt;/p&gt;
&lt;p&gt;　　Redis 是一个高性能的key-value数据库。 redis的出现，很大程度补偿了memcached这类key/value存储的不足，在部 分场合可以对关系数据库起到很好的补充作用。它提供了Python，Ruby，Erlang，PHP客户端，使用很方便,Redis支持主从同步。数据可以从主服务器向任意数量的从服务器上同步，从服务器可以是关联其他从服务器的主服务器。这使得Redis可执行单层树复制。从盘可以有意无意的对数据进行写操作。由于完全实现了发布/订阅机制，使得从数据库在任何地方同步树时，可订阅一个频道并接收主服务器完整的消息发布记录。&lt;/p&gt;
&lt;h2&gt;二 redis连接&lt;/h2&gt;
&lt;h3&gt;普通连接&lt;/h3&gt;
&lt;p&gt;redis-py提供两个类Redis和StrictRedis用于实现Redis的命令，StrictRedis用于实现大部分官方的命令，并使用官方的语法和命令，Redis是StrictRedis的子类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/usr/bin/env python&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; -*- coding:utf-8 -*-&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; redis

r &lt;/span&gt;= redis.Redis(host=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, port=6379&lt;span&gt;)
r.set(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;albert&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;添加&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt; (r.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;))   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;连接池&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;redis-py使用connection pool来管理对一个redis server的所有连接，避免每次建立、释放连接的开销。默认，每个Redis实例都会维护一个自己的连接池。可以直接建立一个连接池，然后作为参数Redis，这样就可以实现多个Redis实例共享一个连接池&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/usr/bin/env python&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; -*- coding:utf-8 -*-&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; redis

pool &lt;/span&gt;= redis.ConnectionPool(host=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;192.168.0.110&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, port=6379&lt;span&gt;)
r &lt;/span&gt;= redis.Redis(connection_pool=&lt;span&gt;pool)
r.set(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;albert&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;添加&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt; (r.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;))   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;三 redis数据操作&lt;/h2&gt;
&lt;h3&gt;1、String 操作&lt;/h3&gt;
&lt;p&gt;　　redis中的String在在内存中按照一个name对应一个value来存储&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;在Redis中设置值，默认不存在则创建，存在则修改&lt;/span&gt;
r.set(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;zhangsan&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;参数：
     set(name, value, ex=None, px=None, nx=False, xx=False)
     ex，过期时间（秒）
     px，过期时间（毫秒）
     nx，如果设置为True，则只有name不存在时，当前set操作才执行,同setnx(name, value)
     xx，如果设置为True，则只有name存在时，当前set操作才执行&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
setex(name, value, time)
#设置过期时间（秒）

psetex(name, time_ms, value)
#设置过期时间（豪秒）
&lt;/pre&gt;
&lt;p&gt;mset()&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
#批量设置值
r.mset(name1='zhangsan', name2='lisi')
#或
r.mget({&quot;name1&quot;:'zhangsan', &quot;name2&quot;:'lisi'})
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;get(name)&lt;/p&gt;
&lt;p&gt;　　获取值&lt;/p&gt;
&lt;p&gt;mget(keys, *args)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
#批量获取
print(r.mget(&quot;name1&quot;,&quot;name2&quot;))
#或
li=[&quot;name1&quot;,&quot;name2&quot;]
print(r.mget(li))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;getset(name, value)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
#设置新值，打印原值
print(r.getset(&quot;name1&quot;,&quot;wangwu&quot;)) #输出:zhangsan
print(r.get(&quot;name1&quot;)) #输出:wangwu
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;getrange(key, start, end)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
#根据字节获取子序列
r.set(&quot;name&quot;,&quot;zhangsan&quot;)
print(r.getrange(&quot;name&quot;,0,3))#输出:zhan
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;setrange(name, offset, value)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;修改字符串内容，从指定字符串索引开始向后替换，如果新值太长时，则向后添加&lt;/span&gt;
r.set(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;zhangsan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
r.setrange(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,1,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;z&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(r.get(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;输出:zzangsan&lt;/span&gt;
r.setrange(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,6,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;zzzzzzz&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(r.get(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;输出:zzangszzzzzzz&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;setbit(name, offset, value)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;对二进制表示位进行操作&lt;/span&gt;
&lt;span&gt;'''&lt;/span&gt;&lt;span&gt; name:redis的name
    offset，位的索引（将值对应的ASCII码变换成二进制后再进行索引）
    value，值只能是 1 或 0 &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;

str&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;345&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
r.set(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,str)
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; str:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(i,ord(i),bin(ord(i)))&lt;span&gt;#&lt;/span&gt;&lt;span&gt;输出 值、ASCII码中对应的值、对应值转换的二进制&lt;/span&gt;
&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
输出:
51 0b110011
52 0b110100
53 0b110101&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;

r.setbit(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,6,0)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;把第7位改为0，也就是3对应的变成了0b110001&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(r.get(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;))&lt;span&gt;#&lt;/span&gt;&lt;span&gt;输出：145&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;getbit(name, offset)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
#获取name对应值的二进制中某位的值(0或1)
r.set(&quot;name&quot;,&quot;3&quot;) # 对应的二进制0b110011
print(r.getbit(&quot;name&quot;,5))   #输出:0
print(r.getbit(&quot;name&quot;,6))   #输出:1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;bitcount(key, start=None, end=None)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取对应二进制中1的个数&lt;/span&gt;
r.set(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;345&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;0b110011 0b110100 0b110101&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(r.bitcount(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,start=0,end=1)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;输出:7&lt;/span&gt;
&lt;span&gt;'''&lt;/span&gt;&lt;span&gt; key:Redis的name
    start:字节起始位置
    end:字节结束位置&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;strlen(name)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
#返回name对应值的字节长度（一个汉字3个字节）
r.set(&quot;name&quot;,&quot;zhangsan&quot;)
print(r.strlen(&quot;name&quot;)) #输出:8
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;incr(self, name, amount=1)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;自增mount对应的值，当mount不存在时，则创建mount＝amount，否则，则自增,amount为自增数(整数)&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(r.incr(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mount&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,amount=2))&lt;span&gt;#&lt;/span&gt;&lt;span&gt;输出:2&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(r.incr(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mount&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;))&lt;span&gt;#&lt;/span&gt;&lt;span&gt;输出:3&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(r.incr(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mount&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,amount=3))&lt;span&gt;#&lt;/span&gt;&lt;span&gt;输出:6&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(r.incr(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mount&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,amount=6))&lt;span&gt;#&lt;/span&gt;&lt;span&gt;输出:12&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(r.get(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mount&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;输出:12&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;incrbyfloat(self, name, amount=1.0)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
#类似 incr() 自增,amount为自增数(浮点数)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;decr(self, name, amount=1)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
#自减name对应的值,当name不存在时,则创建name＝amount，否则，则自减，amount为自增数(整数)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;append(name, value)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
#在name对应的值后面追加内容
r.set(&quot;name&quot;,&quot;zhangsan&quot;)
print(r.get(&quot;name&quot;))    #输出:'zhangsan
r.append(&quot;name&quot;,&quot;lisi&quot;)
print(r.get(&quot;name&quot;))    #输出:zhangsanlisi
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2、Hash 操作&lt;/h3&gt;
&lt;p&gt;redis中的Hash 在内存中类似于一个name对应一个dic来存储 &lt;/p&gt;
&lt;p&gt; hset(name, key, value)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
#name对应的hash中设置一个键值对（不存在，则创建，否则，修改）
r.hset(&quot;dic_name&quot;,&quot;a1&quot;,&quot;aa&quot;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;hget(name,key)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
r.hset(&quot;dic_name&quot;,&quot;a1&quot;,&quot;aa&quot;)
#在name对应的hash中根据key获取value
print(r.hget(&quot;dic_name&quot;,&quot;a1&quot;))#输出:aa
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;hgetall(name)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
#获取name对应hash的所有键值
print(r.hgetall(&quot;dic_name&quot;))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;hmset(name, mapping)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
#在name对应的hash中批量设置键值对,mapping:字典
dic={&quot;a1&quot;:&quot;aa&quot;,&quot;b1&quot;:&quot;bb&quot;}
r.hmset(&quot;dic_name&quot;,dic)
print(r.hget(&quot;dic_name&quot;,&quot;b1&quot;))#输出:bb
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;hmget(name, keys, *args)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
# 在name对应的hash中获取多个key的值
li=[&quot;a1&quot;,&quot;b1&quot;]
print(r.hmget(&quot;dic_name&quot;,li))
print(r.hmget(&quot;dic_name&quot;,&quot;a1&quot;,&quot;b1&quot;))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;hlen(name)、hkeys(name)、hvals(name)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
dic={&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;aa&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;b1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}
r.hmset(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dic_name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,dic)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;hlen(name) 获取hash中键值对的个数&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(r.hlen(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dic_name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;hkeys(name) 获取hash中所有的key的值&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(r.hkeys(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dic_name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;hvals(name) 获取hash中所有的value的值&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(r.hvals(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dic_name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;hexists(name, key)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
#检查name对应的hash是否存在当前传入的key
print(r.hexists(&quot;dic_name&quot;,&quot;a1&quot;))#输出:True
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;hdel(name,*keys)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
#删除指定name对应的key所在的键值对
r.hdel(&quot;dic_name&quot;,&quot;a1&quot;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;hincrby(name, key, amount=1)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
#自增hash中key对应的值，不存在则创建key=amount(amount为整数)
print(r.hincrby(&quot;demo&quot;,&quot;a&quot;,amount=2))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;hincrbyfloat(name, key, amount=1.0)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
#自增hash中key对应的值，不存在则创建key=amount(amount为浮点数)
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3、List 操作&lt;/h3&gt;
&lt;p&gt;redis中的List在在内存中按照一个name对应一个List来存储 &lt;/p&gt;
&lt;p&gt;lpush(name,values)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
# 在name对应的list中添加元素，每个新的元素都添加到列表的最左边
r.lpush(&quot;list_name&quot;,2)
r.lpush(&quot;list_name&quot;,3,4,5)#保存在列表中的顺序为5，4，3，2
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;rpush(name,values)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
#同lpush，但每个新的元素都添加到列表的最右边
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;lpushx(name,value)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
#在name对应的list中添加元素，只有name已经存在时，值添加到列表的最左边
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;rpushx(name,value)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
#在name对应的list中添加元素，只有name已经存在时，值添加到列表的最右边
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;llen(name)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# name对应的list元素的个数
print(r.llen(&quot;list_name&quot;))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;linsert(name, where, refvalue, value))&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 在name对应的列表的某一个值前或后插入一个新值&lt;/span&gt;
r.linsert(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;list_name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BEFORE&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SS&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;在列表内找到第一个元素2，在它前面插入SS&lt;/span&gt;

&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;参数：
     name: redis的name
     where: BEFORE（前）或AFTER（后）
     refvalue: 列表内的值
     value: 要插入的数据&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;r.lset(name, index, value)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
#对list中的某一个索引位置重新赋值
r.lset(&quot;list_name&quot;,0,&quot;bbb&quot;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;r.lrem(name, value, num)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;删除name对应的list中的指定值&lt;/span&gt;
r.lrem(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;list_name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SS&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,num=&lt;span&gt;0)

&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt; 参数：
    name:  redis的name
    value: 要删除的值
    num:   num=0 删除列表中所有的指定值；
           num=2 从前到后，删除2个；
           num=-2 从后向前，删除2个&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;lpop(name)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
#移除列表的左侧第一个元素，返回值则是第一个元素
print(r.lpop(&quot;list_name&quot;))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;lindex(name, index)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
#根据索引获取列表内元素
print(r.lindex(&quot;list_name&quot;,1))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;lrange(name, start, end)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
#分片获取元素
print(r.lrange(&quot;list_name&quot;,0,-1))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ltrim(name, start, end)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
#移除列表内没有在该索引之内的值
r.ltrim(&quot;list_name&quot;,0,2)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;rpoplpush(src, dst)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
# 从一个列表取出最右边的元素，同时将其添加至另一个列表的最左边
#src 要取数据的列表
#dst 要添加数据的列表
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;brpoplpush(src, dst, timeout=0)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
#同rpoplpush，多了个timeout, timeout：取数据的列表没元素后的阻塞时间，0为一直阻塞
r.brpoplpush(&quot;list_name&quot;,&quot;list_name1&quot;,timeout=0)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;blpop(keys, timeout)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;将多个列表排列,按照从左到右去移除各个列表内的元素&lt;/span&gt;
r.lpush(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;list_name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,3,4,5&lt;span&gt;)
r.lpush(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;list_name1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,3,4,5&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(r.blpop([&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;list_name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;list_name1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;],timeout=&lt;span&gt;0))
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(r.lrange(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;list_name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,0,-1),r.lrange(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;list_name1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,0,-1&lt;span&gt;))

&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;keys: redis的name的集合
   timeout: 超时时间，获取完所有列表的元素之后，阻塞等待列表内有数据的时间（秒）, 0 表示永远阻塞&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;r.brpop(keys, timeout)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
#同blpop，将多个列表排列,按照从右像左去移除各个列表内的元素
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;4、Set 操作&lt;/h3&gt;
&lt;p&gt;Set集合就是不允许重复的列表&lt;/p&gt;
&lt;p&gt;sadd(name,values)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
#给name对应的集合中添加元素
r.sadd(&quot;set_name&quot;,&quot;aa&quot;)
r.sadd(&quot;set_name&quot;,&quot;aa&quot;,&quot;bb&quot;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;smembers(name)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
#获取name对应的集合的所有成员
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;scard(name)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
#获取name对应的集合中的元素个数
r.scard(&quot;set_name&quot;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;sdiff(keys, *args)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;在第一个name对应的集合中且不在其他name对应的集合的元素集合&lt;/span&gt;
r.sadd(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;set_name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;aa&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
r.sadd(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;set_name1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
r.sadd(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;set_name2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(r.sdiff(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;set_name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;set_name1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;set_name2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;))&lt;span&gt;#&lt;/span&gt;&lt;span&gt;输出:｛aa｝&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;sdiffstore(dest, keys, *args)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
#相当于把sdiff获取的值加入到dest对应的集合中
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;sinter(keys, *args)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取多个name对应集合的并集&lt;/span&gt;
r.sadd(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;set_name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;aa&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
r.sadd(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;set_name1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
r.sadd(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;set_name2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(r.sinter(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;set_name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;set_name1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;set_name2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;))&lt;span&gt;#&lt;/span&gt;&lt;span&gt;输出:｛bb｝&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;sinterstore(dest, keys, *args)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
#获取多个name对应集合的并集，再讲其加入到dest对应的集合中
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;sismember(name, value)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
#检查value是否是name对应的集合内的元素
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;smove(src, dst, value)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
#将某个元素从一个集合中移动到另外一个集合
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;spop(name)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
#从集合的右侧移除一个元素，并将其返回
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;srandmember(name, numbers)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
# 从name对应的集合中随机获取numbers个元素
print(r.srandmember(&quot;set_name2&quot;,2))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;srem(name, values)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
#删除name对应的集合中的某些值
print(r.srem(&quot;set_name2&quot;,&quot;bb&quot;,&quot;dd&quot;))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;sunion(keys, *args)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
#获取多个name对应的集合的并集
r.sunion(&quot;set_name&quot;,&quot;set_name1&quot;,&quot;set_name2&quot;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;sunionstore(dest,keys, *args)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
#获取多个name对应的集合的并集，并将结果保存到dest对应的集合中
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;5 zset有序集合操作&lt;/h3&gt;
&lt;p&gt;　　在集合的基础上，为每元素排序，元素的排序需要根据另外一个值来进行比较，所以，对于有序集合，每一个元素有两个值，即：值和分数，分数专门用来做排序。&lt;/p&gt;
&lt;p&gt;zadd(name, *args, **kwargs)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
# 在name对应的有序集合中添加元素
r.zadd(&quot;zset_name&quot;, &quot;a1&quot;, 6, &quot;a2&quot;, 2,&quot;a3&quot;,5)
#或
r.zadd('zset_name1', b1=10, b2=5)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;zcard(name)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
#获取有序集合内元素的数量
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;zcount(name, min, max)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
#获取有序集合中分数在[min,max]之间的个数
print(r.zcount(&quot;zset_name&quot;,1,5))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;zincrby(name, value, amount)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
#自增有序集合内value对应的分数
r.zincrby(&quot;zset_name&quot;,&quot;a1&quot;,amount=2)#自增zset_name对应的有序集合里a1对应的分数
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;zrange( name, start, end, desc=False, withscores=False, score_cast_func=float)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 按照索引范围获取name对应的有序集合的元素&lt;/span&gt;
aa=r.zrange(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;zset_name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,0,1,desc=False,withscores=True,score_cast_func=&lt;span&gt;int)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(aa)
&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;参数：
    name    redis的name
    start   有序集合索引起始位置
    end     有序集合索引结束位置
    desc    排序规则，默认按照分数从小到大排序
    withscores  是否获取元素的分数，默认只获取元素的值
    score_cast_func 对分数进行数据转换的函数&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;zrevrange(name, start, end, withscores=False, score_cast_func=float)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
#同zrange，集合是从大到小排序的
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;zrank(name, value)、zrevrank(name, value)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
#获取value值在name对应的有序集合中的排行位置（从0开始）
print(r.zrank(&quot;zset_name&quot;, &quot;a2&quot;))

print(r.zrevrank(&quot;zset_name&quot;, &quot;a2&quot;))#从大到小排序
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;zscore(name, value)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
#获取name对应有序集合中 value 对应的分数
print(r.zscore(&quot;zset_name&quot;,&quot;a1&quot;))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;zrem(name, values)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
#删除name对应的有序集合中值是values的成员
r.zrem(&quot;zset_name&quot;,&quot;a1&quot;,&quot;a2&quot;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;zremrangebyrank(name, min, max)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
#根据排行范围删除
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;zremrangebyscore(name, min, max)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
#根据分数范围删除
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;zinterstore(dest, keys, aggregate=None)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
r.zadd(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;zset_name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, 6, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, 2,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,5&lt;span&gt;)
r.zadd(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;zset_name1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, a1=7,b1=10, b2=5&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取两个有序集合的交集并放入dest集合，如果遇到相同值不同分数，则按照aggregate进行操作&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; aggregate的值为: SUM  MIN  MAX&lt;/span&gt;
r.zinterstore(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;zset_name2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;zset_name1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;zset_name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;),aggregate=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MAX&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(r.zscan(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;zset_name2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;zunionstore(dest, keys, aggregate=None)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
#获取两个有序集合的并集并放入dest集合，其他同zinterstore，
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其他常用操作&lt;/p&gt;
&lt;p&gt;delete(*names)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
#根据name删除redis中的任意数据类型
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;exists(name)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
#检测redis的name是否存在
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;keys(pattern='*')&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
#根据* ？等通配符匹配获取redis的name
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;expire(name ,time)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# 为某个name设置超时时间
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;rename(src, dst)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
# 重命名
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;move(name, db))&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# 将redis的某个值移动到指定的db下
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;randomkey()&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
#随机获取一个redis的name（不删除）
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;type(name)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# 获取name对应值的类型
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;strong&gt;四 redis管道&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　redis-py默认在执行每次请求都会创建（连接池申请连接）和断开（归还连接池）一次连接操作，如果想要在一次请求中指定多个命令，则可以使用pipline实现一次请求指定多个命令，并且默认情况下一次pipline 是原子性操作。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/usr/bin/env python&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; -*- coding:utf-8 -*-&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; redis
pool &lt;/span&gt;= redis.ConnectionPool(host=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;192.168.0.110&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, port=6379&lt;span&gt;)
r &lt;/span&gt;= redis.Redis(connection_pool=&lt;span&gt;pool)

pipe &lt;/span&gt;= r.pipeline(transaction=&lt;span&gt;True)

r.set(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;zhangsan&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
r.set(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;lisi&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

pipe.execute()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;strong&gt;五 发布和订阅&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;首先定义一个RedisHelper类，连接Redis，定义频道为monitor，定义发布(publish)及订阅(subscribe)方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/usr/bin/env python&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;-*- coding:utf-8 -*-&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; redis

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; RedisHelper(object):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        self.&lt;/span&gt;&lt;span&gt;__conn&lt;/span&gt; = redis.Redis(host=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;192.168.0.110&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,port=6379)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;连接Redis&lt;/span&gt;
        self.channel = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;monitor&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义名称&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt; publish(self,msg):&lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义发布方法&lt;/span&gt;
        self.&lt;span&gt;__conn&lt;/span&gt;&lt;span&gt;.publish(self.channel,msg)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; True

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; subscribe(self):&lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义订阅方法&lt;/span&gt;
        pub = self.&lt;span&gt;__conn&lt;/span&gt;&lt;span&gt;.pubsub()
        pub.subscribe(self.channel)
        pub.parse_response()
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; pub
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;发布者&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/usr/bin/env python&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; -*- coding:utf-8 -*-&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;发布&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; RedisHelper &lt;span&gt;import&lt;/span&gt;&lt;span&gt; RedisHelper

obj &lt;/span&gt;=&lt;span&gt; RedisHelper()
obj.publish(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;发布&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;订阅者&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/usr/bin/env python&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; -*- coding:utf-8 -*-&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;订阅&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; RedisHelper &lt;span&gt;import&lt;/span&gt;&lt;span&gt; RedisHelper

obj &lt;/span&gt;=&lt;span&gt; RedisHelper()
redis_sub &lt;/span&gt;= obj.subscribe()&lt;span&gt;#&lt;/span&gt;&lt;span&gt;调用订阅方法&lt;/span&gt;

&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
    msg&lt;/span&gt;=&lt;span&gt; redis_sub.parse_response()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; (msg)
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Wed, 05 Dec 2018 07:08:00 +0000</pubDate>
<dc:creator>马一特</dc:creator>
<og:description>一 redis介绍 redis是一个key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(s</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mayite/p/10071020.html</dc:identifier>
</item>
<item>
<title>Python并发编程之常用概念剖析：并行 串行 并发 同步 异步 阻塞 非阻塞 进程 线程 协程 - 奥辰</title>
<link>http://www.cnblogs.com/chenhuabin/p/10070996.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenhuabin/p/10070996.html</guid>
<description>&lt;p&gt;　　并发、并行、串行、同步、异步、阻塞、非阻塞、进程、线程、协程是并发编程中的常见概念，相似却也有却不尽相同，令人头痛，这一篇博文中我们来区分一下这些概念。&lt;/p&gt;

&lt;p&gt;　　在解释并发与并行之前，我们必须先明确：&lt;strong&gt;单个处理器（一个单核CPU）在某一个时刻只能处理一个线程&lt;/strong&gt;。&lt;br/&gt;　　并发是指在同一个处理器上通过时间片轮转的方式在多个线程之间频繁切换，由于切换速度极快，所以看似多个线程似乎被同时执行，但实际上每一个时刻都只有一个线程被执行，其他的线程出于阻塞状态。&lt;br/&gt;　　并行是指多个处理器在同一时刻同时处理了多个不同的线程，这才是真正意义的同时被执行。&lt;br/&gt;　　如下图所示，线程A与线程B同在一个CPU内执行，且任一t时刻内，都只有一个线程（A或者B）被执行，所以线程A与线程B是并发执行的。线程C和线程D分别在两个CPU内执行，且在某一个t时刻内同时都在执行，所以线程C和线程D是并行的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1539768/201812/1539768-20181205150249183-1088930850.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　上面已经说到，并行是指多个任务同时执行，而&lt;strong&gt;串行&lt;/strong&gt;是指多个任务时，各个任务按顺序执行，完成一个之后才能进行下一个。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1539768/201812/1539768-20181205150204829-1470656300.png&quot; alt=&quot;&quot;/&gt;　　所以，并发与并行是在某一时刻是否都在执行的区别。并行与串行是同时进行或一个结束才进行下一个的区别。&lt;/p&gt;

&lt;p&gt;　　同步与异步的概念与消息的通知机制有关：&lt;br/&gt;　　&lt;strong&gt;同步&lt;/strong&gt;是指线程在访问某一资源时，获得了资源的返回结果之后才会执行其他操作，否则主动继续获取这一资源；&lt;br/&gt;　　&lt;strong&gt;异步&lt;/strong&gt;与同步相对，是指线程在访问某一资源时，无论是否取得返回结果，都进行下一步操作；当有了资源返回结果时，系统自会通知线程。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
用一个比喻来说明：10多前的银行是没有业务取号的，我们去办理业务时，如果有很多人，那就先排队，然后关注着什么时候轮到自己，这就是同步；现在去银行，得先取一张小纸条，上面写着你的&lt;br/&gt;业务号，轮到你的时候，银行会喊你，这就是异步。异步机制往往注册一个回调机制,在所等待的事件被触发时由触发机制(银行柜台业务员)通过某种机制(业务办理号码)找到等待该事件的人。
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　阻塞是与非阻塞都是程序的一种运行状态。&lt;br/&gt;　　线程在等待某个操作完成期间，自身无法继续执行别的操作，则称该线程在该操作上是&lt;strong&gt;阻塞&lt;/strong&gt;的。&lt;br/&gt;　　线程在等待某个操作完成期间，自身可执行别的操作，则称该线程在该操作上是&lt;strong&gt;非阻塞&lt;/strong&gt;的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
继续上面银行办理业务的例子，无论是10多年前的排队办理业务，还是现在的业务号办理业务，如果在我们在等待过程中，什么也不能做，那就是阻塞的；如果在等待过程中，可以做其他事情（看书&lt;br/&gt;、玩手游），那就是非阻塞的。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　同步和异步是个线程处理方式或手段，阻塞和非阻塞是线程的一种状态，两者并不相同也并不冲突。&lt;/p&gt;
&lt;p&gt;　　同步、异步与阻塞非阻塞可以产生不同的组合：同步阻塞、同步非阻塞、异步阻塞、异步非阻塞。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
还是银行办理业务的例子：如果排着队，且只能傻傻的排着队，看着什么时候到自己，那就是同步阻塞；如果排着队还能玩玩手机，偶尔抬头看看什么时候到自己，那就是同步非阻塞。如果是现在的&lt;br/&gt;取票按业务号办理业务，拿到号码后就陷入懵逼状态，啥也不能做，直到银行根据业务号通知自己，那就是异步阻塞；如果拿到业务号之后，自己爱干嘛干嘛，那就是异步非阻塞。
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;6.1 基本概念&lt;/h2&gt;
&lt;p&gt;　　&lt;strong&gt;进程&lt;/strong&gt;是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位，是资源（内存）分配的最小单位。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。&lt;br/&gt;　　&lt;strong&gt;线程&lt;/strong&gt;是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。&lt;br/&gt;　　&lt;strong&gt;协程&lt;/strong&gt;是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。&lt;/p&gt;
&lt;h2&gt;6.2 进程与线程&lt;/h2&gt;
&lt;p&gt;　　线程是指进程内的一个执行单元,也是进程内的可调度实体。线程与进程的区别:&lt;br/&gt;　　1) 地址空间:线程是进程内的一个执行单元，进程内至少有一个线程，它们共享进程的地址空间，而进程有自己独立的地址空间；&lt;br/&gt;　　2) 资源拥有:进程是资源分配和拥有的单位,同一个进程内的线程共享进程的资源；&lt;br/&gt;　　3) 线程是处理器调度的基本单位,但进程不是；&lt;br/&gt;　　4) 二者均可并发执行&lt;br/&gt;　　5) 每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口，但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。&lt;/p&gt;
&lt;h2&gt;6.3 协程多与线程进行比较&lt;/h2&gt;
&lt;p&gt;　　1) 一个线程可以多个协程，一个进程也可以单独拥有多个协程，这样python中则能使用多核CPU。&lt;br/&gt;　　2) 线程进程都是同步机制，而协程则是异步&lt;br/&gt;　　3) 协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态。&lt;/p&gt;
&lt;p&gt;　　参考资料：&lt;br/&gt;　　https://www.cnblogs.com/lxmhhy/p/6041001.html&lt;br/&gt;　　https://www.jianshu.com/p/3308311fb90c&lt;/p&gt;
</description>
<pubDate>Wed, 05 Dec 2018 07:04:00 +0000</pubDate>
<dc:creator>奥辰</dc:creator>
<og:description>1 引言 并发、并行、串行、同步、异步、阻塞、非阻塞、进程、线程、协程是并发编程中的常见概念，相似却也有却不尽相同，令人头痛，这一篇博文中我们来区分一下这些概念。 2 并发与并行 在解释并发与并行之前</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenhuabin/p/10070996.html</dc:identifier>
</item>
</channel>
</rss>