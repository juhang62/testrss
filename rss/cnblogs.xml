<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Go语言goroutine调度器初始化(12) - 爱写程序的阿波张</title>
<link>http://www.cnblogs.com/abozhang/p/10813229.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/abozhang/p/10813229.html</guid>
<description>&lt;p&gt;本文是《Go语言调度器源代码情景分析》系列的第12篇，也是第二章的第2小节。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;本章将以下面这个简单的Hello World程序为例，通过跟踪其从启动到退出这一完整的运行流程来分析Go语言调度器的初始化、goroutine的创建与退出、工作线程的调度循环以及goroutine的切换等重要内容。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
package main

import &quot;fmt&quot;

func main() {
    fmt.Println(&quot;Hello World!&quot;)
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;首先我们从程序启动开始分析调度器的初始化。&lt;/p&gt;
&lt;p&gt;在分析程序的启动过程之前，我们首先来看看程序在执行第一条指令之前其栈的初始状态。&lt;/p&gt;
&lt;p&gt;任何一个由编译型语言（不管是C，C++，go还是汇编语言）所编写的程序在被操作系统加载起来运行时都会顺序经过如下几个阶段：&lt;/p&gt;
&lt;ol class=&quot;list-paddingleft-2&quot; start=&quot;&quot; readability=&quot;2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;从磁盘上把可执行程序读入内存；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;创建进程和主线程；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;为主线程分配栈空间；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;把由用户在命令行输入的参数拷贝到主线程的栈；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;把主线程放入操作系统的运行队列等待被调度执起来运行。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在主线程第一次被调度起来执行第一条指令之前，主线程的函数栈如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1671650/201905/1671650-20190505150509150-1438928909.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;了解了程序的初始状态之后，下面我们正式开始。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;程序入口&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在Linux命令行用 go build 编译hello.go，得到可执行程序hello，然后使用gdb调试，在gdb中我们首先使用 info files 命令找到程序入口（Entry point）地址为0x452270，然后用 b *0x452270 在0x452270地址处下个断点，gdb告诉我们这个入口对应的源代码为 runtime/rt0_linux_amd64.s 文件的第8行。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
bobo@ubuntu:~/study/&lt;span&gt;go$ gobuild hello.go 
bobo@ubuntu:&lt;/span&gt;~/study/&lt;span&gt;go$ gdbhello
GNU gdb (GDB) &lt;/span&gt;&lt;span&gt;8.0&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
(gdb) &lt;/span&gt;&lt;span&gt;info&lt;/span&gt;&lt;span&gt; files
Symbols from &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/home/bobo/study/go/main&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.
Local exec &lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt;:
`&lt;/span&gt;/home/bobo/study/go/main&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, file type elf64-x86-64.&lt;/span&gt;
Entry point: &lt;span&gt;0x452270&lt;/span&gt;
&lt;span&gt;0x0000000000401000&lt;/span&gt; -&lt;span&gt;0x0000000000486aac&lt;/span&gt;&lt;span&gt; is .text
&lt;/span&gt;&lt;span&gt;0x0000000000487000&lt;/span&gt; -&lt;span&gt;0x00000000004d1a73&lt;/span&gt;&lt;span&gt; is .rodata
&lt;/span&gt;&lt;span&gt;0x00000000004d1c20&lt;/span&gt; -&lt;span&gt;0x00000000004d27f0&lt;/span&gt;&lt;span&gt; is .typelink
&lt;/span&gt;&lt;span&gt;0x00000000004d27f0&lt;/span&gt; -&lt;span&gt;0x00000000004d2838&lt;/span&gt;&lt;span&gt; is .itablink
&lt;/span&gt;&lt;span&gt;0x00000000004d2838&lt;/span&gt; -&lt;span&gt;0x00000000004d2838&lt;/span&gt;&lt;span&gt; is .gosymtab
&lt;/span&gt;&lt;span&gt;0x00000000004d2840&lt;/span&gt; -&lt;span&gt;0x00000000005426d9&lt;/span&gt;&lt;span&gt; is .gopclntab
&lt;/span&gt;&lt;span&gt;0x0000000000543000&lt;/span&gt; -&lt;span&gt;0x000000000054fa9c&lt;/span&gt;&lt;span&gt; is .noptrdata
&lt;/span&gt;&lt;span&gt;0x000000000054faa0&lt;/span&gt; -&lt;span&gt;0x0000000000556790&lt;/span&gt;&lt;span&gt; is .data
&lt;/span&gt;&lt;span&gt;0x00000000005567a0&lt;/span&gt; -&lt;span&gt;0x0000000000571ef0&lt;/span&gt;&lt;span&gt; is .bss
&lt;/span&gt;&lt;span&gt;0x0000000000571f00&lt;/span&gt; -&lt;span&gt;0x0000000000574658&lt;/span&gt;&lt;span&gt; is .noptrbss
&lt;/span&gt;&lt;span&gt;0x0000000000400f9c&lt;/span&gt; -&lt;span&gt;0x0000000000401000&lt;/span&gt;&lt;span&gt; is .note.go.buildid
(gdb) b &lt;/span&gt;*&lt;span&gt;0x452270&lt;/span&gt;&lt;span&gt;
Breakpoint 1at &lt;/span&gt;&lt;span&gt;0x452270&lt;/span&gt;: &lt;span&gt;file&lt;/span&gt; /usr/local/go/src/runtime/rt0_linux_amd64.s, line &lt;span&gt;8&lt;/span&gt;.
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;打开代码编辑器，找到 runtime/rt0_linx_amd64.s 文件，该文件是用go汇编语言编写而成的源代码文件，我们已经在本书的第一部分讨论过其格式。现在看看第8行：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;runtime/rt0_linx_amd64.s : 8&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
TEXT _rt0_amd64_linux(SB),NOSPLIT,$-&lt;span&gt;8&lt;/span&gt;&lt;span&gt;
    JMP _rt0_amd64(SB)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上面第一行代码定义了_rt0_amd64_linux这个符号，并不是真正的CPU指令，第二行的JMP指令才是主线程的第一条指令，这条指令简单的跳转到（相当于go语言或c中的goto）_rt0_amd64 这个符号处继续执行，_rt0_amd64 这个符号的定义在runtime/asm_amd64.s 文件中：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;runtime/asm_amd64.s : 14&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
TEXT _rt0_amd64(SB),NOSPLIT,$-&lt;span&gt;8&lt;/span&gt;&lt;span&gt;
    MOVQ  &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;(SP), DI// argc 
    LEAQ   &lt;/span&gt;&lt;span&gt;8&lt;/span&gt;&lt;span&gt;(SP), SI// argv
    &lt;/span&gt;&lt;span&gt;JMP&lt;/span&gt;     runtime·rt0_go(SB)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;前两行指令把操作系统内核传递过来的参数argc和argv数组的地址分别放在DI和SI寄存器中，第三行指令跳转到 rt0_go 去执行。&lt;/p&gt;
&lt;p&gt;rt0_go函数完成了go程序启动时的所有初始化工作，因此这个函数比较长，也比较繁杂，但这里我们只关注与调度器相关的一些初始化，下面我们分段来看：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;runtime/asm_amd64.s : 87&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
TEXT runtime·rt0_go(SB),NOSPLIT,$&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
    // copy arguments forward on an even stack
    MOVQ DI, AX # AX=argc
    MOVQ SI, BX # BX=argv
    SUBQ $(&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;*&lt;span&gt;8&lt;/span&gt;+&lt;span&gt;7&lt;/span&gt;&lt;span&gt;), SP # 2args 2auto
    ANDQ $~&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;&lt;span&gt;, SP    #调整栈顶寄存器使其按16字节对齐
    MOVQ AX, &lt;/span&gt;&lt;span&gt;16&lt;/span&gt;&lt;span&gt;(SP) #argc放在SP+ 16字节处
    MOVQ BX, &lt;/span&gt;&lt;span&gt;24&lt;/span&gt;(SP) #argv放在SP+ 24字节处
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上面的第4条指令用于调整栈顶寄存器的值使其按16字节对齐，也就是让栈顶寄存器SP指向的内存的地址为16的倍数，&lt;strong&gt;之所以要按16字节对齐，是因为CPU有一组SSE指令，这些指令中出现的内存地址必须是16的倍数&lt;/strong&gt;，最后两条指令把argc和argv搬到新的位置。这段代码的其它部分已经做了比较详细的注释，所以这里就不做过多的解释了。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;初始化g0&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;继续看后面的代码，下面开始初始化全局变量g0，前面我们说过，g0的主要作用是提供一个栈供runtime代码执行，因此这里主要对g0的几个与栈有关的成员进行了初始化，从这里可以看出g0的栈大约有64K，地址范围为 SP - 64*1024 + 104 ～ SP。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;runtime/asm_amd64.s : 96&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
// create istack &lt;span&gt;out&lt;/span&gt;&lt;span&gt; of the given (operating system) stack.
// _cgo_initmay update stackguard.
//下面这段代码从系统线程的栈空分出一部分当作g0的栈，然后初始化g0的栈信息和stackgard
MOVQ $runtime·g0(SB), DI      //g0的地址放入DI寄存器
LEAQ (-&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;*&lt;span&gt;1024&lt;/span&gt;+&lt;span&gt;104&lt;/span&gt;)(SP), BX//BX=SP- &lt;span&gt;64&lt;/span&gt;*&lt;span&gt;1024&lt;/span&gt; + &lt;span&gt;104&lt;/span&gt;&lt;span&gt;
MOVQ BX, g_stackguard0(DI) //g0.stackguard0 =SP- &lt;/span&gt;&lt;span&gt;64&lt;/span&gt;*&lt;span&gt;1024&lt;/span&gt; + &lt;span&gt;104&lt;/span&gt;&lt;span&gt;
MOVQ BX, g_stackguard1(DI) //g0.stackguard1 =SP- &lt;/span&gt;&lt;span&gt;64&lt;/span&gt;*&lt;span&gt;1024&lt;/span&gt; + &lt;span&gt;104&lt;/span&gt;&lt;span&gt;
MOVQ BX, (g_stack+stack_lo)(DI) //g0.stack.lo =SP- &lt;/span&gt;&lt;span&gt;64&lt;/span&gt;*&lt;span&gt;1024&lt;/span&gt; + &lt;span&gt;104&lt;/span&gt;&lt;span&gt;
MOVQ SP, (g_stack+stack_hi)(DI) //g0.stack.hi =SP&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;运行完上面这几行指令后g0与栈之间的关系如下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1671650/201905/1671650-20190505150839489-2018959187.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;主线程与m0绑定&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;设置好g0栈之后，我们跳过CPU型号检查以及cgo初始化相关的代码，直接从164行继续分析。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;runtime/asm_amd64.s : 164&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//下面开始初始化tls(thread local storage,线程本地存储)
LEAQ runtime·m0+m_tls(SB), DI//DI=&amp;amp;m0.tls，取m0的tls成员的地址到DI寄存器
&lt;/span&gt;&lt;span&gt;CALL&lt;/span&gt;&lt;span&gt; runtime·settls(SB) //调用settls设置线程本地存储，settls函数的参数在DI寄存器中

// store through it, to make sure it works
//验证settls是否可以正常工作，如果有问题则abort退出程序
get_tls(BX) //获取fs段基地址并放入BX寄存器，其实就是m0.tls[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]的地址，get_tls的代码由编译器生成
MOVQ $0x123, g(BX) //把整型常量0x123拷贝到fs段基地址偏移-8的内存位置，也就是m0.tls[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;] =0x123
MOVQ runtime·m0+m_tls(SB), AX//AX=m0.tls[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]
CMPQ AX, $0x123 //检查m0.tls[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]的值是否是通过线程本地存储存入的0x123来验证tls功能是否正常
JEQ &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;(PC)
&lt;/span&gt;&lt;span&gt;CALL&lt;/span&gt; runtime·abort(SB) //如果线程本地存储不能正常工作，退出程序
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这段代码首先调用settls函数初始化主线程的线程本地存储(TLS)，目的是把m0与主线程关联在一起，至于为什么要把m和工作线程绑定在一起，我们已经在上一节介绍过了，这里就不再重复。设置了线程本地存储之后接下来的几条指令在于验证TLS功能是否正常，如果不正常则直接abort退出程序。&lt;/p&gt;
&lt;p&gt;下面我们详细来详细看一下settls函数是如何实现线程私有全局变量的。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;runtime/sys_linx_amd64.s : 606&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;// set tls base to DI
TEXT runtime·settls(SB),NOSPLIT,$&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;&lt;span&gt;
//......
//DI寄存器中存放的是m.tls[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]的地址，m的tls成员是一个数组，读者如果忘记了可以回头看一下m结构体的定义
//下面这一句代码把DI寄存器中的地址加8，为什么要+8呢，主要跟ELF可执行文件格式中的TLS实现的机制有关
//执行下面这句指令之后DI寄存器中的存放的就是m.tls[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]的地址了
ADDQ $&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;, DI// ELF wants to use -&lt;span&gt;8&lt;/span&gt;&lt;span&gt;(FS)

  //下面通过arch_prctl系统调用设置FS段基址
MOVQ DI, SI//SI存放arch_prctl系统调用的第二个参数
MOVQ $0x1002, DI// ARCH_SET_FS //arch_prctl的第一个参数
MOVQ $SYS_arch_prctl, AX//系统调用编号
&lt;/span&gt;&lt;span&gt;SYSCALL&lt;/span&gt;&lt;span&gt;
CMPQ AX, $0xfffffffffffff001
JLS &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;(PC)
MOVL $0xf1, 0xf1 // crash //系统调用失败直接crash
&lt;/span&gt;&lt;span&gt;RET&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;从代码可以看到，这里通过arch_prctl系统调用把m0.tls[1]的地址设置成了fs段的段基址。CPU中有个叫fs的段寄存器与之对应，而每个线程都有自己的一组CPU寄存器值，操作系统在把线程调离CPU运行时会帮我们把所有寄存器中的值保存在内存中，调度线程起来运行时又会从内存中把这些寄存器的值恢复到CPU，这样，在此之后，工作线程代码就可以通过fs寄存器来找到m.tls，读者可以参考上面初始化tls之后对tls功能验证的代码来理解这一过程。&lt;/p&gt;
&lt;p&gt;下面继续分析rt0_go，&lt;/p&gt;
&lt;p&gt;&lt;em&gt;runtime/asm_amd64.s : 174&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;ok:&lt;/span&gt;&lt;span&gt;
// set the per-goroutine &lt;/span&gt;&lt;span&gt;and&lt;/span&gt; per-mach &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;registers&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
get_tls(BX) //获取fs段基址到BX寄存器
LEAQ runtime·g0(SB), CX//CX=g0的地址
MOVQ CX, g(BX) //把g0的地址保存在线程本地存储里面，也就是m0.tls[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]=&amp;amp;g0
LEAQ runtime·m0(SB), AX//AX=m0的地址

//把m0和g0关联起来m0-&amp;gt;g0 =g0，g0-&amp;gt;m =m0
// save m-&amp;gt;g0 =g0
MOVQ CX, m_g0(AX) //m0.g0 =g0
// save m0 to g0-&amp;gt;m 
MOVQ AX, g_m(CX) //g0.m =m0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上面的代码首先把g0的地址放入主线程的线程本地存储中，然后通过&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
m0.g0 = &amp;amp;g0
g0.m = &amp;amp;m0
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;把m0和g0绑定在一起，这样，之后在主线程中通过get_tls可以获取到g0，通过g0的m成员又可以找到m0，于是这里就实现了m0和g0与主线程之间的关联。从这里还可以看到，保存在主线程本地存储中的值是g0的地址，也就是说工作线程的私有全局变量其实是一个指向g的指针而不是指向m的指针，目前这个指针指向g0，表示代码正运行在g0栈。此时，主线程，m0，g0以及g0的栈之间的关系如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1671650/201905/1671650-20190505151059612-501648903.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;初始化m0&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;下面代码开始处理命令行参数，这部分我们不关心，所以跳过。命令行参数处理完成后调用osinit函数获取CPU核的数量并保存在全局变量ncpu之中，调度器初始化时需要知道当前系统有多少个CPU核。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;runtime/asm_amd64.s : 189&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//准备调用args函数，前面四条指令把参数放在栈上
MOVL &lt;/span&gt;&lt;span&gt;16&lt;/span&gt;&lt;span&gt;(SP), AX// AX = argc
MOVL AX, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;(SP)       // argc放在栈顶
MOVQ &lt;/span&gt;&lt;span&gt;24&lt;/span&gt;&lt;span&gt;(SP), AX// AX = argv
MOVQ AX, &lt;/span&gt;&lt;span&gt;8&lt;/span&gt;&lt;span&gt;(SP)       // argv放在SP + 8的位置
&lt;/span&gt;&lt;span&gt;CALL&lt;/span&gt;&lt;span&gt; runtime·args(SB)  //处理操作系统传递过来的参数和env，不需要关心

//对于linx来说，osinit唯一功能就是获取CPU的核数并放在global变量ncpu中，
//调度器初始化时需要知道当前系统有多少CPU核
&lt;/span&gt;&lt;span&gt;CALL&lt;/span&gt;&lt;span&gt; runtime·osinit(SB)  //执行的结果是全局变量 ncpu = CPU核数
&lt;/span&gt;&lt;span&gt;CALL&lt;/span&gt; runtime·schedinit(SB) //调度系统初始化
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;接下来继续看调度器是如何初始化的。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;runtime/proc.go : 526&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:false;&quot;&gt;
func schedinit() {
　　// raceinit must be the first call to race detector.
　　// In particular, it must be done before mallocinit below calls racemapshadow.
   
   //getg函数在源代码中没有对应的定义，由编译器插入类似下面两行代码
   //get_tls(CX) 
    //MOVQ g(CX), BX; BX存器里面现在放的是当前g结构体对象的地址
    _g_ := getg() // _g_ = &amp;amp;g0

    ......

   //设置最多启动10000个操作系统线程，也是最多10000个M
    sched.maxmcount=10000

    ......
   
    mcommoninit(_g_.m) //初始化m0，因为从前面的代码我们知道g0-&amp;gt;m = &amp;amp;m0

    ......

    sched.lastpoll = uint64(nanotime())
    procs := ncpu //系统中有多少核，就创建和初始化多少个p结构体对象
    if n, ok: = atoi32(gogetenv(&quot;GOMAXPROCS&quot;)); ok &amp;amp;&amp;amp; n &amp;gt; 0 {
        procs = n//如果环境变量指定了GOMAXPROCS，则创建指定数量的p
    }
    if procresize(procs) != nil {//创建和初始化全局变量allp
        throw(&quot;unknown runnable goroutine during bootstrap&quot;)
    }

    ......
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;前面我们已经看到，g0的地址已经被设置到了线程本地存储之中，schedinit通过getg函数（getg函数是编译器实现的，我们在源代码中是找不到其定义的）从线程本地存储中获取当前正在运行的g，这里获取出来的是g0，然后调用mcommoninit函数对m0(g0.m)进行必要的初始化，对m0初始化完成之后调用procresize初始化系统需要用到的p结构体对象，按照go语言官方的说法，p就是processor的意思，它的数量决定了最多可以有都少个goroutine同时并行运行。schedinit函数除了初始化m0和p，还设置了全局变量sched的maxmcount成员为10000，限制最多可以创建10000个操作系统线程出来工作。&lt;/p&gt;
&lt;p&gt;这里我们需要重点关注一下mcommoninit如何初始化m0以及procresize函数如何创建和初始化p结构体对象。首先我们深入到mcommoninit函数中一探究竟。这里需要注意的是不只是初始化的时候会执行该函数，在程序运行过程中如果创建了工作线程，也会执行它，所以我们会在函数中看到加锁和检查线程数量是否已经超过最大值等相关的代码。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;runtime/proc.go : 596&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
func mcommoninit(mp*m) {
    _g_ := getg() //初始化过程中_g_ = g0

    // g0 stack won't make sense for user (and is not necessary unwindable).
    if _g_ != _g_.m.g0 {  //函数调用栈traceback，不需要关心
        callers(1, mp.createstack[:])
    }

    lock(&amp;amp;sched.lock)
    if sched.mnext + 1 &amp;lt; sched.mnext {
        throw(&quot;runtime: thread ID overflow&quot;)
    }
    mp.id = sched.mnext
    sched.mnext++
    checkmcount() //检查已创建系统线程是否超过了数量限制（10000）

    //random初始化
    mp.fastrand[0] = 1597334677*uint32(mp.id)
    mp.fastrand[1] = uint32(cputicks())
    if mp.fastrand[0]|mp.fastrand[1] ==0{
        mp.fastrand[1] =1
    }

   //创建用于信号处理的gsignal，只是简单的从堆上分配一个g结构体对象,然后把栈设置好就返回了
    mpreinit(mp)
    if mp.gsignal!=nil {
        mp.gsignal.stackguard1=mp.gsignal.stack.lo+_StackGuard
    }

   //把m挂入全局链表allm之中
    // Add to allm so garbage collector doesn't free g-&amp;gt;m
    // when it is just in a register or thread-local storage.
    mp.alllink = allm

    // NumCgoCall() iterates over allm w/o schedlock,
    // so we need to publish it safely.
    atomicstorep(unsafe.Pointer(&amp;amp;allm), unsafe.Pointer(mp))
    unlock(&amp;amp;sched.lock)

    // Allocate memory to hold a cgo traceback if the cgo call crashes.
    if iscgo || GOOS == &quot;solaris&quot; || GOOS == &quot;windows&quot; {
        mp.cgoCallers = new(cgoCallers)
    }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;从这个函数的源代码可以看出，这里并未对m0做什么关于调度相关的初始化，所以可以简单的认为这个函数只是把m0放入全局链表allm之中就返回了。&lt;/p&gt;
&lt;p&gt;m0完成基本的初始化后，继续调用procresize创建和初始化p结构体对象，在这个函数里面会创建指定个数（根据cpu核数或环境变量确定）的p结构体对象放在全变量allp里, 并把m0和allp[0]绑定在一起，因此当这个函数执行完成之后就有&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
m0.p = allp[0]
allp[0].m = &amp;amp;m0
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;到此m0, g0, 和m需要的p完全关联在一起了。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;初始化allp&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;下面我们来看procresize函数，考虑到初始化完成之后用户代码还可以通过 GOMAXPROCS()函数调用它重新创建和初始化p结构体对象，而在运行过程中再动态的调整p牵涉到的问题比较多，所以这个函数的处理比较复杂，但如果只考虑初始化，相对来说要简单很多，所以这里只保留了初始化时会执行的代码：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;runtime/proc.go : 3902&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
func procresize(nprocsint32) *p {
    old := gomaxprocs//系统初始化时 gomaxprocs = 0

    ......

    // Grow allp if necessary.
   if nprocs &amp;gt; int32(len(allp)) { //初始化时 len(allp) == 0
        // Synchronize with retake, which could be running
        // concurrently since it doesn't run on a P.
        lock(&amp;amp;allpLock)
        if nprocs &amp;lt;= int32(cap(allp)) {
            allp = allp[:nprocs]
        } else { //初始化时进入此分支，创建allp 切片
            nallp:=make([]*p, nprocs)
            // Copy everything up to allp's cap so we
            // never lose old allocated Ps.
            copy(nallp, allp[:cap(allp)])
            allp=nallp
        }
        unlock(&amp;amp;allpLock)
    }

    // initialize new P's
   //循环创建nprocs个p并完成基本初始化
    for i := int32(0); i&amp;lt;nprocs; i++{
        pp := allp[i]
        if pp == nil{
            pp=new(p)//调用内存分配器从堆上分配一个struct p
            pp.id=i
            pp.status=_Pgcstop
            ......
            atomicstorep(unsafe.Pointer(&amp;amp;allp[i]), unsafe.Pointer(pp))
        }

       ......
    }

    ......

    _g_:=getg()  // _g_ = g0
    if _g_.m.p != 0 &amp;amp;&amp;amp; _g_.m.p.ptr().id &amp;lt; nprocs {//初始化时m0-&amp;gt;p还未初始化，所以不会执行这个分支
        // continue to use the current P
        _g_.m.p.ptr().status=_Prunning
        _g_.m.p.ptr().mcache.prepareForSweep()
    } else {//初始化时执行这个分支
        // release the current P and acquire allp[0]
        if _g_.m.p != 0 {//初始化时这里不执行
            _g_.m.p.ptr().m=0
        }
        _g_.m.p=0
        _g_.m.mcache = nil
        p := allp[0]
        p.m = 0
        p.status = _Pidle
        acquirep(p) //把p和m0关联起来，其实是这两个strct的成员相互赋值
        if trace.enabled {
            traceGoStart()
        }
    }
   
   //下面这个for 循环把所有空闲的p放入空闲链表
    var runnablePs *p
    for i := nprocs-1; i &amp;gt;= 0; i-- {
        p := allp[i]
        if _g_.m.p.ptr() == p {//allp[0]跟m0关联了，所以是不能放任
            continue
        }
        p.status = _Pidle
        if runqempty(p) {//初始化时除了allp[0]其它p全部执行这个分支，放入空闲链表
            pidleput(p)
        } else {
            ......
        }
    }

    ......
   
    return runnablePs
} 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这个函数代码比较长，但并不复杂，这里总结一下这个函数的主要流程：&lt;/p&gt;
&lt;ol class=&quot;list-paddingleft-2&quot; start=&quot;&quot; readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;使用make([]*p, nprocs)初始化全局变量allp，即allp = make([]*p, nprocs)&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;循环创建并初始化nprocs个p结构体对象并依次保存在allp切片之中&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;把m0和allp[0]绑定在一起，即m0.p = allp[0], allp[0].m = m0&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;把除了allp[0]之外的所有p放入到全局变量sched的pidle空闲队列之中&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;procresize函数执行完后，调度器相关的初始化工作就基本结束了，这时整个调度器相关的各组成部分之间的联系如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1671650/201905/1671650-20190505151740171-1449618483.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;分析完调度器的基本初始化后，下一节我们来看程序中的第一个goroutine是如何创建的。&lt;/p&gt;
</description>
<pubDate>Sun, 05 May 2019 07:19:00 +0000</pubDate>
<dc:creator>爱写程序的阿波张</dc:creator>
<og:description>本章将以一个简单的Hello World程序为例，通过跟踪其从启动到退出这一完整的运行流程来分析Go语言调度器的初始化、goroutine的创建与退出、工作线程的调度循环以及goroutine的切换等</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/abozhang/p/10813229.html</dc:identifier>
</item>
<item>
<title>scoket 网络编程 - 嘿嘿赵康</title>
<link>http://www.cnblogs.com/ZKPython/p/10813174.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ZKPython/p/10813174.html</guid>
<description>&lt;p&gt;如果这两个程序之间想要传递一个数据，你要怎么做呢？&lt;/p&gt;
&lt;p&gt;创建一个文件，把a.py想要传递的内容写到文件中，然后b.py从这个文件中读取内容就可以了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1597381/201905/1597381-20190505145523203-867913027.png&quot; alt=&quot;&quot; width=&quot;510&quot; height=&quot;142&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是当你的a.py和b.py分别在不同电脑上的时候，你要怎么办呢？&lt;/p&gt;
&lt;p&gt;类似的机制有计算机网盘，qq等等。我们可以在我们的电脑上和别人聊天，可以在自己的电脑上向网盘中上传、下载内容。这些都是两个程序在通信。&lt;/p&gt;

&lt;p&gt;我们了解的涉及到两个程序之间通讯的应用大致可以分为两种：&lt;/p&gt;
&lt;p&gt;第一种是应用类：qq、微信、网盘、优酷这一类是属于需要安装的桌面应用&lt;/p&gt;
&lt;p&gt;第二种是web类：比如百度、知乎、博客园等使用浏览器访问就可以直接使用的应用&lt;/p&gt;
&lt;p&gt;这些应用的本质其实都是两个程序之间的通讯。而这两个分类又对应了两个软件开发的架构～&lt;/p&gt;
&lt;h2 id=&quot;autoid-0-0-0&quot;&gt;1.C/S架构&lt;/h2&gt;
&lt;p&gt;C/S即：Client与Server ，中文意思：客户端与服务器端架构，这种架构也是从用户层面（也可以是物理层面）来划分的。&lt;/p&gt;
&lt;p&gt;这里的客户端一般泛指客户端应用程序EXE，程序需要先安装后，才能运行在用户的电脑上，对用户的电脑操作系统环境依赖较大。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1597381/201905/1597381-20190505145606820-1355646628.png&quot; alt=&quot;&quot; width=&quot;467&quot; height=&quot;260&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;autoid-0-0-0&quot;&gt;2.B/S架构&lt;/h2&gt;
&lt;p&gt;B/S即：Browser与Server,中文意思：浏览器端与服务器端架构，这种架构是从用户层面来划分的。&lt;/p&gt;
&lt;p&gt;Browser浏览器，其实也是一种Client客户端，只是这个客户端不需要大家去安装什么应用程序，只需在浏览器上通过HTTP请求服务器端相关的资源（网页资源），客户端Browser浏览器就能进行增删改查。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1597381/201905/1597381-20190505145640070-1080851790.png&quot; alt=&quot;&quot; width=&quot;465&quot; height=&quot;312&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;autoid-0-0-0&quot;&gt;1.一个程序如何在网络上找到另一个程序？&lt;/h2&gt;
&lt;p&gt;首先，程序必须要启动，其次，必须有这台机器的地址，我们都知道我们人的地址大概就是国家\省\市\区\街道\楼\门牌号这样字。那么每一台联网的机器在网络上也有自己的地址，它的地址是怎么表示的呢？&lt;/p&gt;
&lt;p&gt;就是使用一串数字来表示的，例如：100.4.5.6&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('ee379c1b-dc12-4fc9-bdf8-42a10f6397cf')&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_ee379c1b-dc12-4fc9-bdf8-42a10f6397cf&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_ee379c1b-dc12-4fc9-bdf8-42a10f6397cf&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('ee379c1b-dc12-4fc9-bdf8-42a10f6397cf',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_ee379c1b-dc12-4fc9-bdf8-42a10f6397cf&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;IP地址是指互联网协议地址（英语：Internet Protocol Address，又译为网际协议地址），是IP Address的缩写。IP地址是IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。

IP地址是一个32位的二进制数，通常被分割为4个“8位二进制数”（也就是4个字节）。IP地址通常用“点分十进制”表示成（a.b.c.d）的形式，其中，a,b,c,d都是0&lt;/span&gt;~255之间的十进制整数。例：点分十进IP地址（100.4.5.6），实际上是32位二进制数（01100100.00000100.00000101.00000110）。
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;IP地址&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('9c2e4b13-b0a1-4602-861d-a19df4ba686b')&quot; readability=&quot;31&quot;&gt;&lt;img id=&quot;code_img_closed_9c2e4b13-b0a1-4602-861d-a19df4ba686b&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_9c2e4b13-b0a1-4602-861d-a19df4ba686b&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('9c2e4b13-b0a1-4602-861d-a19df4ba686b',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_9c2e4b13-b0a1-4602-861d-a19df4ba686b&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;端口&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;是英文port的意译，可以认为是设备与外界通讯交流的出口。
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;端口&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;因此ip地址精确到具体的一台电脑，而端口精确到具体的程序。&lt;/p&gt;
&lt;h2 id=&quot;autoid-0-0-0&quot;&gt;2.osi七层模型&lt;/h2&gt;
&lt;h3 id=&quot;autoid-0-0-0&quot;&gt;&lt;strong&gt;引子&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;须知一个完整的计算机系统是由硬件、操作系统、应用软件三者组成,具备了这三个条件，一台计算机系统就可以自己跟自己玩了（打个单机游戏，玩个扫雷啥的）&lt;/p&gt;
&lt;p&gt;如果你要跟别人一起玩，那你就需要上网了，什么是互联网？&lt;/p&gt;
&lt;p&gt;互联网的核心就是由一堆协议组成，协议就是标准，比如全世界人通信的标准是英语，如果把计算机比作人，互联网协议就是计算机界的英语。所有的计算机都学会了互联网协议，那所有的计算机都就可以按照统一的标准去收发信息从而完成通信了。&lt;/p&gt;
&lt;h3 id=&quot;autoid-1-0-0&quot;&gt;osi七层模型&lt;/h3&gt;
&lt;p&gt;人们按照分工不同把互联网协议从逻辑上划分了层级：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1597381/201905/1597381-20190505145938023-1415549190.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;autoid-2-0-0&quot;&gt;3.socket概念&lt;/h2&gt;
&lt;h3 id=&quot;autoid-2-0-0&quot;&gt;socket层&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1597381/201905/1597381-20190505145955636-666582616.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;autoid-3-0-0&quot;&gt;理解socket&lt;/h3&gt;
&lt;p&gt;Socket是应用层与&lt;span lang=&quot;EN-US&quot;&gt;TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，&lt;span lang=&quot;EN-US&quot;&gt;Socket其实就是一个门面模式，它把复杂的&lt;span lang=&quot;EN-US&quot;&gt;TCP/IP协议族隐藏在&lt;span lang=&quot;EN-US&quot;&gt;Socket接口后面，对用户来说，一组简单的接口就是全部，让&lt;span lang=&quot;EN-US&quot;&gt;Socket去组织数据，以符合指定的协议。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;autoid-4-0-0&quot;&gt;3.套接字（socket）的发展史&lt;/h2&gt;
&lt;p&gt;套接字起源于 20 世纪 70 年代加利福尼亚大学伯克利分校版本的 Unix,即人们所说的 BSD Unix。 因此,有时人们也把套接字称为“伯克利套接字”或“BSD 套接字”。一开始,套接字被设计用在同 一台主机上多个应用程序之间的通讯。这也被称进程间通讯,或 IPC。套接字有两种（或者称为有两个种族）,分别是基于文件型的和基于网络型的。 &lt;/p&gt;
&lt;h3 id=&quot;autoid-4-0-0&quot;&gt;&lt;em&gt;&lt;strong&gt;基于文件类型的套接字家族&lt;/strong&gt;&lt;/em&gt;&lt;/h3&gt;
&lt;p&gt;套接字家族的名字：AF_UNIX&lt;/p&gt;
&lt;p&gt;unix一切皆文件，基于文件的套接字调用的就是底层的文件系统来取数据，两个套接字进程运行在同一机器，可以通过访问同一个文件系统间接完成通信&lt;/p&gt;
&lt;h3 id=&quot;autoid-5-0-0&quot;&gt;&lt;em&gt;&lt;strong&gt;基于网络类型的套接字家族&lt;/strong&gt;&lt;/em&gt;&lt;/h3&gt;
&lt;p&gt;套接字家族的名字：AF_INET&lt;/p&gt;
&lt;p&gt;(还有AF_INET6被用于ipv6，还有一些其他的地址家族，不过，他们要么是只用于某个平台，要么就是已经被废弃，或者是很少被使用，或者是根本没有实现，所有地址家族中，AF_INET是使用最广泛的一个，python支持很多种地址家族，但是由于我们只关心网络编程，所以大部分时候我么只使用AF_INET)&lt;/p&gt;
&lt;h2 id=&quot;autoid-6-0-0&quot;&gt;4.tcp协议和udp协议&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;TCP&lt;/strong&gt;（Transmission Control Protocol）可靠的、面向连接的协议（eg:打电话）、传输效率低全双工通信（发送缓存&amp;amp;接收缓存）、面向字节流。使用TCP的应用：Web浏览器；电子邮件、文件传输程序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;UDP&lt;/strong&gt;（User Datagram Protocol）不可靠的、无连接的服务，传输效率高（发送前时延小），一对一、一对多、多对一、多对多、面向报文，尽最大努力服务，无拥塞控制。使用UDP的应用：域名系统 (DNS)；视频流；IP语音(VoIP)。&lt;/p&gt;
&lt;p&gt;我知道说这些你们也不懂，直接上图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1597381/201905/1597381-20190505150110715-1200371322.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;autoid-6-0-0&quot;&gt;基于TCP协议的socket&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;tcp是基于链接的，必须先启动服务端，然后再启动客户端去链接服务端&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;server端&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
import socket
sk = socket.socket()
sk.bind(('127.0.0.1',8898))  #把地址绑定到套接字
sk.listen()          #监听链接
conn,addr = sk.accept() #接受客户端链接
ret = conn.recv(1024)  #接收客户端信息
print(ret)       #打印客户端信息
conn.send(b'hi')        #向客户端发送信息
conn.close()       #关闭客户端套接字
sk.close()        #关闭服务器套接字(可选)
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;autoid-7-0-0&quot;&gt;client端&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
import socket
sk = socket.socket()           # 创建客户套接字
sk.connect(('127.0.0.1',8898))    # 尝试连接服务器
sk.send(b'hello!')
ret = sk.recv(1024)         # 对话(发送/接收)
print(ret)
sk.close()            # 关闭客户套接字
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;autoid-8-0-0&quot;&gt;问题：在重启服务端时可能会遇到&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1597381/201905/1597381-20190505150255816-633931916.png&quot; alt=&quot;&quot; width=&quot;932&quot; height=&quot;195&quot;/&gt;&lt;/p&gt;
&lt;p&gt;解决方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
#加入一条socket配置，重用ip和端口
import socket
from socket import SOL_SOCKET,SO_REUSEADDR
sk = socket.socket()
sk.setsockopt(SOL_SOCKET,SO_REUSEADDR,1) #就是它，在bind前加
sk.bind(('127.0.0.1',8898))  #把地址绑定到套接字
sk.listen()          #监听链接
conn,addr = sk.accept() #接受客户端链接
ret = conn.recv(1024)   #接收客户端信息
print(ret)              #打印客户端信息
conn.send(b'hi')        #向客户端发送信息
conn.close()       #关闭客户端套接字
sk.close()        #关闭服务器套接字(可选)
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;autoid-9-0-0&quot;&gt;基于UDP协议的socket&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;udp是无链接的，启动服务之后可以直接接受消息&lt;/strong&gt;，不需要提前建立链接&lt;/p&gt;
&lt;h4 id=&quot;autoid-10-0-0&quot;&gt;server端&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
import socket
udp_sk = socket.socket(type=socket.SOCK_DGRAM)   #创建一个服务器的套接字
udp_sk.bind(('127.0.0.1',9000))        #绑定服务器套接字
msg,addr = udp_sk.recvfrom(1024)
print(msg)
udp_sk.sendto(b'hi',addr)                 # 对话(接收与发送)
udp_sk.close()                         # 关闭服务器套接字
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;autoid-10-1-0&quot;&gt;client端&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
import socket
ip_port=('127.0.0.1',9000)
udp_sk=socket.socket(type=socket.SOCK_DGRAM)
udp_sk.sendto(b'hello',ip_port)
back_msg,addr=udp_sk.recvfrom(1024)
print(back_msg.decode('utf-8'),addr)
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;autoid-10-2-0&quot;&gt; qq聊天&lt;/h3&gt;
&lt;h4 id=&quot;autoid-10-0-0&quot;&gt;server端&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
#_*_coding:utf-8_*_
import socket
ip_port=('127.0.0.1',8081)
udp_server_sock=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)
udp_server_sock.bind(ip_port)

while True:
    qq_msg,addr=udp_server_sock.recvfrom(1024)
    print('来自[%s:%s]的一条消息:\033[1;44m%s\033[0m' %(addr[0],addr[1],qq_msg.decode('utf-8')))
    back_msg=input('回复消息: ').strip()

    udp_server_sock.sendto(back_msg.encode('utf-8'),addr)
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;autoid-10-1-0&quot;&gt;client端&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;50&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
#_*_coding:utf-8_*_
import socket
BUFSIZE=1024
udp_client_socket=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)

qq_name_dic={
    '金老板':('127.0.0.1',8081),
    '哪吒':('127.0.0.1',8081),
    'egg':('127.0.0.1',8081),
    'yuan':('127.0.0.1',8081),
}


while True:
    qq_name=input('请选择聊天对象: ').strip()
    while True:
        msg=input('请输入消息,回车发送,输入q结束和他的聊天: ').strip()
        if msg == 'q':break
        if not msg or not qq_name or qq_name not in qq_name_dic:continue
        udp_client_socket.sendto(msg.encode('utf-8'),qq_name_dic[qq_name])

        back_msg,addr=udp_client_socket.recvfrom(BUFSIZE)
        print('来自[%s:%s]的一条消息:\033[1;44m%s\033[0m' %(addr[0],addr[1],back_msg.decode('utf-8')))

udp_client_socket.close()
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;autoid-12-0-0&quot;&gt;socket参数的详解&lt;/h2&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
socket.socket(family=AF_INET,type=SOCK_STREAM,proto=0,fileno=None)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　&lt;strong&gt;创建&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;socket对象的参数说明：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1597381/201905/1597381-20190505150933449-64508360.png&quot; alt=&quot;&quot;/&gt;、&lt;/p&gt;

&lt;h2 id=&quot;autoid-12-0-0&quot;&gt;黏包现象&lt;/h2&gt;
&lt;h3 id=&quot;autoid-12-0-0&quot;&gt;基于tcp协议实现的黏包&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;45&quot;&gt;
&lt;pre class=&quot;brush:python;collapse:true;;gutter:true;&quot;&gt;
#_*_coding:utf-8_*_
from socket import *
import subprocess

ip_port=('127.0.0.1',8888)
BUFSIZE=1024

tcp_socket_server=socket(AF_INET,SOCK_STREAM)
tcp_socket_server.setsockopt(SOL_SOCKET,SO_REUSEADDR,1)
tcp_socket_server.bind(ip_port)
tcp_socket_server.listen(5)

while True:
    conn,addr=tcp_socket_server.accept()
    print('客户端',addr)

    while True:
        cmd=conn.recv(BUFSIZE)
        if len(cmd) == 0:break

        res=subprocess.Popen(cmd.decode('utf-8'),shell=True,
                         stdout=subprocess.PIPE,
                         stdin=subprocess.PIPE,
                         stderr=subprocess.PIPE)

        stderr=res.stderr.read()
        stdout=res.stdout.read()
        conn.send(stderr)
        conn.send(stdout)
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:python;collapse:true;;gutter:true;&quot;&gt;
#_*_coding:utf-8_*_
import socket
BUFSIZE=1024
ip_port=('127.0.0.1',8888)

s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
res=s.connect_ex(ip_port)

while True:
    msg=input('&amp;gt;&amp;gt;: ').strip()
    if len(msg) == 0:continue
    if msg == 'quit':break

    s.send(msg.encode('utf-8'))
    act_res=s.recv(BUFSIZE)

    print(act_res.decode('utf-8'),end='')
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;autoid-13-0-0&quot;&gt;基于udp协议实现的黏包&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;47&quot;&gt;
&lt;pre class=&quot;brush:python;collapse:true;;gutter:true;&quot;&gt;
#_*_coding:utf-8_*_
from socket import *
import subprocess

ip_port=('127.0.0.1',9000)
bufsize=1024

udp_server=socket(AF_INET,SOCK_DGRAM)
udp_server.setsockopt(SOL_SOCKET,SO_REUSEADDR,1)
udp_server.bind(ip_port)

while True:
    #收消息
    cmd,addr=udp_server.recvfrom(bufsize)
    print('用户命令-----&amp;gt;',cmd)

    #逻辑处理
    res=subprocess.Popen(cmd.decode('utf-8'),shell=True,stderr=subprocess.PIPE,stdin=subprocess.PIPE,stdout=subprocess.PIPE)
    stderr=res.stderr.read()
    stdout=res.stdout.read()

    #发消息
    udp_server.sendto(stderr,addr)
    udp_server.sendto(stdout,addr)
udp_server.close()
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;brush:python;collapse:true;;gutter:true;&quot;&gt;
from socket import *
ip_port=('127.0.0.1',9000)
bufsize=1024

udp_client=socket(AF_INET,SOCK_DGRAM)


while True:
    msg=input('&amp;gt;&amp;gt;: ').strip()
    udp_client.sendto(msg.encode('utf-8'),ip_port)
    err,addr=udp_client.recvfrom(bufsize)
    out,addr=udp_client.recvfrom(bufsize)
    if err:
        print('error : %s'%err.decode('utf-8'),end='')
    if out:
        print(out.decode('utf-8'), end='')
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;注意：只有TCP有粘包现象，UDP永远不会粘包&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;autoid-18-0-0&quot;&gt;黏包的解决方案&lt;/h2&gt;
&lt;h3 id=&quot;autoid-18-0-0&quot;&gt;解决方案一&lt;/h3&gt;
&lt;p&gt;问题的根源在于，接收端不知道发送端将要传送的字节流的长度，所以解决粘包的方法就是围绕，如何让发送端在发送数据前，把自己将要发送的字节流总大小让接收端知晓，然后接收端来一个死循环接收完所有数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1597381/201905/1597381-20190505151355887-1352275375.png&quot; alt=&quot;&quot; width=&quot;470&quot; height=&quot;284&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;autoid-10-0-0&quot;&gt;server端&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;46&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
#_*_coding:utf-8_*_
import socket,subprocess
ip_port=('127.0.0.1',8080)
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

s.bind(ip_port)
s.listen(5)

while True:
    conn,addr=s.accept()
    print('客户端',addr)
    while True:
        msg=conn.recv(1024)
        if not msg:break
        res=subprocess.Popen(msg.decode('utf-8'),shell=True,\
                            stdin=subprocess.PIPE,\
                         stderr=subprocess.PIPE,\
                         stdout=subprocess.PIPE)
        err=res.stderr.read()
        if err:
            ret=err
        else:
            ret=res.stdout.read()
        data_length=len(ret)
        conn.send(str(data_length).encode('utf-8'))
        data=conn.recv(1024).decode('utf-8')
        if data == 'recv_ready':
            conn.sendall(ret)
    conn.close()
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;autoid-10-0-0&quot;&gt; client端&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
#_*_coding:utf-8_*_
import socket,time
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
res=s.connect_ex(('127.0.0.1',8080))

while True:
    msg=input('&amp;gt;&amp;gt;: ').strip()
    if len(msg) == 0:continue
    if msg == 'quit':break

    s.send(msg.encode('utf-8'))
    length=int(s.recv(1024).decode('utf-8'))
    s.send('recv_ready'.encode('utf-8'))
    send_size=0
    recv_size=0
    data=b''
    while recv_size &amp;lt; length:
        data+=s.recv(1024)
        recv_size+=len(data)


    print(data.decode('utf-8'))
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
存在的问题：
程序的运行速度远快于网络传输速度，所以在发送一段字节前，先用send去发送该字节流长度，这种方式会放大网络延迟带来的性能损耗
&lt;/pre&gt;
&lt;h3 id=&quot;autoid-19-0-0&quot;&gt;解决方案进阶&lt;/h3&gt;
&lt;p&gt;刚刚的方法，问题在于我们我们在发送&lt;/p&gt;
&lt;p&gt;我们可以借助一个模块，这个模块可以把要发送的数据长度转换成固定长度的字节。这样客户端每次接收消息之前只要先接受这个固定长度字节的内容看一看接下来要接收的信息大小，那么最终接受的数据只要达到这个值就停止，就能刚好不多不少的接收完整的数据了。&lt;/p&gt;
&lt;h4 id=&quot;autoid-20-0-0&quot;&gt;struct模块&lt;/h4&gt;
&lt;h4 id=&quot;autoid-20-0-0&quot;&gt;struct模块&lt;/h4&gt;
&lt;p&gt;该模块可以把一个类型，如数字，转成固定长度的bytes&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
&amp;gt;&amp;gt;&amp;gt; struct.pack('i',1111111111111)

struct.error: 'i' format requires -2147483648 &amp;lt;= number &amp;lt;= 2147483647 #这个是范围
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1597381/201905/1597381-20190505151622781-888787832.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;51&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
import json,struct
#假设通过客户端上传1T:1073741824000的文件a.txt

#为避免粘包,必须自定制报头
header={'file_size':1073741824000,'file_name':'/a/b/c/d/e/a.txt','md5':'8f6fbf8347faa4924a76856701edb0f3'} #1T数据,文件路径和md5值

#为了该报头能传送,需要序列化并且转为bytes
head_bytes=bytes(json.dumps(header),encoding='utf-8') #序列化并转成bytes,用于传输

#为了让客户端知道报头的长度,用struck将报头长度这个数字转成固定长度:4个字节
head_len_bytes=struct.pack('i',len(head_bytes)) #这4个字节里只包含了一个数字,该数字是报头的长度

#客户端开始发送
conn.send(head_len_bytes) #先发报头的长度,4个bytes
conn.send(head_bytes) #再发报头的字节格式
conn.sendall(文件内容) #然后发真实内容的字节格式

#服务端开始接收
head_len_bytes=s.recv(4) #先收报头4个bytes,得到报头长度的字节格式
x=struct.unpack('i',head_len_bytes)[0] #提取报头的长度

head_bytes=s.recv(x) #按照报头长度x,收取报头的bytes格式
header=json.loads(json.dumps(header)) #提取报头

#最后根据报头的内容提取真实的数据,比如
real_data_len=s.recv(header['file_size'])
s.recv(real_data_len)
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;52&quot;&gt;
&lt;pre class=&quot;brush:python;collapse:true;;gutter:true;&quot;&gt;
#_*_coding:utf-8_*_
#http://www.cnblogs.com/coser/archive/2011/12/17/2291160.html
__author__ = 'Linhaifeng'
import struct
import binascii
import ctypes

values1 = (1, 'abc'.encode('utf-8'), 2.7)
values2 = ('defg'.encode('utf-8'),101)
s1 = struct.Struct('I3sf')
s2 = struct.Struct('4sI')

print(s1.size,s2.size)
prebuffer=ctypes.create_string_buffer(s1.size+s2.size)
print('Before : ',binascii.hexlify(prebuffer))
# t=binascii.hexlify('asdfaf'.encode('utf-8'))
# print(t)


s1.pack_into(prebuffer,0,*values1)
s2.pack_into(prebuffer,s1.size,*values2)

print('After pack',binascii.hexlify(prebuffer))
print(s1.unpack_from(prebuffer,0))
print(s2.unpack_from(prebuffer,s1.size))

s3=struct.Struct('ii')
s3.pack_into(prebuffer,0,123,123)
print('After pack',binascii.hexlify(prebuffer))
print(s3.unpack_from(prebuffer,0))
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;autoid-20-1-0&quot;&gt;使用struct解决黏包 &lt;/h4&gt;
&lt;p&gt;借助struct模块，我们知道长度数字可以被转换成一个标准大小的4字节数字。因此可以利用这个特点来预先发送数据长度。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1597381/201905/1597381-20190505151815474-1054772558.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;autoid-20-1-0&quot;&gt;服务端自制报头&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;46&quot;&gt;
&lt;pre class=&quot;brush:python;collapse:true;;gutter:true;&quot;&gt;
import socket,struct,json
import subprocess
phone=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
phone.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1) #就是它，在bind前加

phone.bind(('127.0.0.1',8080))

phone.listen(5)

while True:
    conn,addr=phone.accept()
    while True:
        cmd=conn.recv(1024)
        if not cmd:break
        print('cmd: %s' %cmd)

        res=subprocess.Popen(cmd.decode('utf-8'),
                             shell=True,
                             stdout=subprocess.PIPE,
                             stderr=subprocess.PIPE)
        err=res.stderr.read()
        print(err)
        if err:
            back_msg=err
        else:
            back_msg=res.stdout.read()


        conn.send(struct.pack('i',len(back_msg))) #先发back_msg的长度
        conn.sendall(back_msg) #在发真实的内容

    conn.close()
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;brush:python;collapse:true;;gutter:true;&quot;&gt;
#_*_coding:utf-8_*_
import socket,time,struct

s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
res=s.connect_ex(('127.0.0.1',8080))

while True:
    msg=input('&amp;gt;&amp;gt;: ').strip()
    if len(msg) == 0:continue
    if msg == 'quit':break

    s.send(msg.encode('utf-8'))



    l=s.recv(4)
    x=struct.unpack('i',l)[0]
    print(type(x),x)
    # print(struct.unpack('I',l))
    r_s=0
    data=b''
    while r_s &amp;lt; x:
        r_d=s.recv(1024)
        data+=r_d
        r_s+=len(r_d)

    # print(data.decode('utf-8'))
    print(data.decode('gbk')) #windows默认gbk编码
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我们还可以把报头做成字典，字典里包含将要发送的真实数据的详细信息，然后json序列化，然后用struck将序列化后的数据长度打包成4个字节（4个自己足够用了）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1597381/201905/1597381-20190505152022616-370815230.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;autoid-20-1-0&quot;&gt;服务端&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;47&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
import socket,struct,json
import subprocess
phone=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
phone.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1) #就是它，在bind前加

phone.bind(('127.0.0.1',8080))

phone.listen(5)

while True:
    conn,addr=phone.accept()
    while True:
        cmd=conn.recv(1024)
        if not cmd:break
        print('cmd: %s' %cmd)

        res=subprocess.Popen(cmd.decode('utf-8'),
                             shell=True,
                             stdout=subprocess.PIPE,
                             stderr=subprocess.PIPE)
        err=res.stderr.read()
        print(err)
        if err:
            back_msg=err
        else:
            back_msg=res.stdout.read()

        headers={'data_size':len(back_msg)}
        head_json=json.dumps(headers)
        head_json_bytes=bytes(head_json,encoding='utf-8')

        conn.send(struct.pack('i',len(head_json_bytes))) #先发报头的长度
        conn.send(head_json_bytes) #再发报头
        conn.sendall(back_msg) #在发真实的内容

    conn.close()
&lt;/pre&gt;&lt;/div&gt;

&lt;h4 id=&quot;autoid-20-1-0&quot;&gt;客户端&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
from socket import *
import struct,json

ip_port=('127.0.0.1',8080)
client=socket(AF_INET,SOCK_STREAM)
client.connect(ip_port)

while True:
    cmd=input('&amp;gt;&amp;gt;: ')
    if not cmd:continue
    client.send(bytes(cmd,encoding='utf-8'))

    head=client.recv(4)
    head_json_len=struct.unpack('i',head)[0]
    head_json=json.loads(client.recv(head_json_len).decode('utf-8'))
    data_len=head_json['data_size']

    recv_size=0
    recv_data=b''
    while recv_size &amp;lt; data_len:
        recv_data+=client.recv(1024)
        recv_size+=len(recv_data)

    print(recv_data.decode('utf-8'))
    #print(recv_data.decode('gbk')) #windows默认gbk编码
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Sun, 05 May 2019 07:11:00 +0000</pubDate>
<dc:creator>嘿嘿赵康</dc:creator>
<og:description>一.楔子 如果这两个程序之间想要传递一个数据，你要怎么做呢？ 创建一个文件，把a.py想要传递的内容写到文件中，然后b.py从这个文件中读取内容就可以了。 但是当你的a.py和b.py分别在不同电脑上</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ZKPython/p/10813174.html</dc:identifier>
</item>
<item>
<title>dotnet core2.2 通过虚拟机发布到CentOS上 - 小白的逆袭之路</title>
<link>http://www.cnblogs.com/roubaozidd/p/10775959.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/roubaozidd/p/10775959.html</guid>
<description>&lt;p&gt;自从.net core出现的时候,就知道c#的代码居然能后运行到Linux上面,以前都没想过居然这么牛逼,所以很早就想学习怎样部署上去,直到现在.net core都出现2.2了,才花时间去接触,说实话,第一次接触,太多的坑在这个上边了,途中还走了很多弯路...现在把最后总结的流程简单的记录下来&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;一 丶下载vmware Workstation (我的虚拟机用的VM所以这里就只讲了VM)  &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;点&lt;a href=&quot;https://my.vmware.com/web/vmware/downloads&quot; target=&quot;_blank&quot;&gt;这里&lt;/a&gt;下载,这个是官网,下载需要注册,尽量不要再其他地方下载,可能会附带一些不可描述的东西&lt;/p&gt;
&lt;p&gt;(安装过程就省略了,你们这么聪明,肯定不需要了)&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;二丶下载一个centos 7.0镜像文件(版本看你心情),并且安装在虚拟机上面&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;点&lt;a href=&quot;https://www.centos.org/download/&quot; target=&quot;_blank&quot;&gt;这里&lt;/a&gt;下载,官网有时候很卡,耐心等一下,这里有&lt;/p&gt;
&lt;p&gt;CentOS-7-DVD版本：DVD是标准安装盘&lt;/p&gt;
&lt;p&gt;CentOS-7-Everything版本：对完整版安装盘的软件进行补充，集成所有软件&lt;/p&gt;
&lt;p&gt;CentOS-7-Minimal版本：迷你精简版&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1422864/201904/1422864-20190426173655780-1848339205.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;如果只是为了发布.net core的话,我们用迷你版就行了,比较小,功能也能够满足,下载保存到固定的文件夹&lt;/p&gt;
&lt;p&gt;接下来就是在VM上面装centos了(你们这么聪明,那我就把简单的步骤省略,还剩重要位置的几张图)&lt;/p&gt;
&lt;p&gt;新建一个&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1422864/201904/1422864-20190426174316820-1800638669.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1422864/201904/1422864-20190426174505410-846217439.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1422864/201904/1422864-20190426174528350-1732021071.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1422864/201904/1422864-20190426174736263-1208648742.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个磁盘大小选个30G应该够用了 ...&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1422864/201904/1422864-20190426175315626-160442319.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;记得在这里配置磁盘大小,点下一步还有root密码&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1422864/201904/1422864-20190426175555396-1505642499.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;成功安装之后,使用root登录  (输入密码时是隐藏的)&lt;/p&gt;
&lt;p&gt;由于装的迷你版本的,里面应该不存在网卡驱动,可以用ping baidu.com和ifconfig两个命令测试一下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1422864/201904/1422864-20190426180036548-337934186.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里要安装一下&lt;/p&gt;
&lt;p&gt;1.进入网卡地址   cd  /etc/sysconfig/network-scripts   &lt;/p&gt;
&lt;p&gt;2. 编辑   vi ifcfg-ens33 将ONBOOT改为yes, 然后退出保存(esc+:wq)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1422864/201904/1422864-20190426180822659-297238724.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3. 退出之后重启网卡 service network restart&lt;/p&gt;
&lt;p&gt;4.安装包 sudo yum install net-tools  ,中途记得输入y确认&lt;/p&gt;
&lt;p&gt;现在ok了,这个是你的IP&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1422864/201904/1422864-20190426181513932-1118052638.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;三丶 下载putty,下载filezilla(都去官网)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;可以不用putty,但是这个比虚拟机操作更方便,最主要是可以复制粘贴&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1422864/201904/1422864-20190426181754733-2092532310.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下载filezilla,filezilla就是一个免费开源的ftp软件,便于我们把.net core发布文件上传到Centos中,直接用centos的ip还有root账号连接,端口用22,之后就可以上传文件了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1422864/201904/1422864-20190426182103946-1034915058.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;四 安装dotnet core和nginx环境 ,配置nignx,在centos 运行.net core&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;根据官网进行安装: https://dotnet.microsoft.com/download/linux-package-manager/centos/sdk-current,记得linux选择centos版本&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1422864/201905/1422864-20190505104634284-290057630.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 安装成功后随便用一个命令检测是否安装成功,例如: dotnet --version&lt;/p&gt;
&lt;p&gt;接着继续安装nginx反向代理服务器,用于映射端口方便我们访问&lt;/p&gt;
&lt;p&gt;1. 添加nginx存储库:   sudo yum &lt;span class=&quot;hljs-keyword&quot;&gt;install epel-&lt;span class=&quot;hljs-keyword&quot;&gt;release&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;2. 安装ngingx:    sudo yum &lt;span class=&quot;hljs-keyword&quot;&gt;install nginx&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3. 启动nginx:  sudo systemctl &lt;span class=&quot;hljs-keyword&quot;&gt;start nginx&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;4. 启动防火墙允许http后台https访问&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;sudo firewall-cmd --permanent --zone=public --add-service=http&lt;br/&gt;sudo firewall-cmd --permanent --zone=public --add-service=https&lt;br/&gt;sudo firewall-cmd --reload&lt;/p&gt;
&lt;p&gt;(如果想在系统启动时运行nginx,运行命令:sudo systemctl &lt;span class=&quot;hljs-built_in&quot;&gt;enable nginx&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;直接在本机访问我们上面虚拟机80端口的地址,这里是192.168.64.128,就可以看见nginx界面了&lt;/p&gt;

&lt;p&gt; vs创建一个.net core例子,记得在program.cs里面指定路由地址&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1422864/201904/1422864-20190426182410755-1844728272.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;接着发布到指定文件夹,使用FileZilla上传到centos指定位置,我这里上传到/home/hello里面的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1422864/201905/1422864-20190505114135089-1854243349.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在centos查看一下文件是否存在&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1422864/201905/1422864-20190505114246107-1162221253.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到文件已经过来了,接下来运行起来 dotenet Test.dll&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1422864/201905/1422864-20190505114355368-933030975.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;运行成功后,不能按Ctrl+z,否则进程会被暂停,外部访问会出现&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1422864/201904/1422864-20190426182714575-527420380.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这里,我们重新打开一个putty,用root账号连接上centos&lt;/p&gt;
&lt;p&gt;进入nginx配置的默认菜单:cd /etc/nginx&lt;/p&gt;
&lt;p&gt;编辑nginx.conf文件,屏蔽所有默认的80端口反向代理&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1422864/201905/1422864-20190505140359436-1512620210.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1422864/201905/1422864-20190505140443566-1414010664.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 并且加入自己的反向代理用80端口指向5000&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1422864/201905/1422864-20190505140554000-1960521048.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;重新加载并且重启nginx&lt;/p&gt;
&lt;p&gt;nginx -s reload&lt;/p&gt;
&lt;p&gt;systemctl restart nginx&lt;/p&gt;
&lt;p&gt;好了现在就可以在本机访问了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1422864/201905/1422864-20190505141324151-1517103978.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;PS:&lt;/p&gt;
&lt;p&gt;1. 如果出现502&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1422864/201904/1422864-20190426182700337-974184989.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;原因：SELinux配置问题。 &lt;br/&gt;解决：关闭SELinux。 &lt;br/&gt;输入：&lt;code&gt;sestatus&lt;/code&gt;,如果&lt;code&gt;SELinux status: enabled&lt;/code&gt; ，表示开启，输入&lt;code&gt;vi /etc/selinux/config&lt;/code&gt; 修改配置：SELINUX=disabled。 &lt;/p&gt;
&lt;p&gt; 然后重启CentOS&lt;/p&gt;

&lt;p&gt; 2. 如果出现&lt;/p&gt;

&lt;p&gt;出现这个错误则是default.conf或nginx.conf文件，查看是否少写了一个分号,确实不行就卸载nginx再重装&lt;/p&gt;

&lt;p&gt;可能会需要用到的一些命令:&lt;/p&gt;
&lt;p&gt;nginx停止:   &lt;/p&gt;
&lt;p&gt;ps -ef|grep nginx 查看所有进程&lt;/p&gt;
&lt;p&gt;kill -9 PID 杀死进程&lt;br/&gt;nginx重启: &lt;/p&gt;
&lt;p&gt;sudo service nginx restart&lt;/p&gt;
&lt;p&gt;nginx卸载:&lt;/p&gt;
&lt;p&gt; yum remove nginx   记得删除nginx相关的所有文件&lt;/p&gt;
&lt;p&gt;看下是否删除成功  which nginx&lt;/p&gt;
&lt;p&gt;查看某个端口的进程&lt;/p&gt;
&lt;p&gt;netstat   -anp   |   grep  端口号&lt;/p&gt;
&lt;p&gt;杀掉进程: kill -9 PID&lt;/p&gt;
&lt;p&gt; 访问网址:  curl  网址  (curl http://192.168.64.128)&lt;/p&gt;
</description>
<pubDate>Sun, 05 May 2019 06:54:00 +0000</pubDate>
<dc:creator>小白的逆袭之路</dc:creator>
<og:description>自从.net core出现的时候,就知道c#的代码居然能后运行到Linux上面,以前都没想过居然这么牛逼,所以很早就想学习怎样部署上去,直到现在.net core都出现2.2了,才花时间去接触,说实话</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/roubaozidd/p/10775959.html</dc:identifier>
</item>
<item>
<title>门面模式 - 不该相遇在秋天</title>
<link>http://www.cnblogs.com/fengyumeng/p/10812964.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fengyumeng/p/10812964.html</guid>
<description>&lt;h3&gt;老王的股票&lt;/h3&gt;
&lt;p&gt;　　大家好，我是小赵，目前任职藏剑山庄高级铸剑师，在山庄里和我玩的比较好的有老王和老刘他们几个，都是组长级别的二货们，经常混在一起打牌。&lt;/p&gt;
&lt;p&gt;　　今天上午闲得蛋疼晃悠晃悠的晃到的老王的地盘，看到老王在埋头写程序：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        Stock1 stock1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Stock1();
        stock1.buy();

        Stock2 stock2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Stock2();
        stock2.sell();

        Stock3 stock3 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Stock3();
        stock3.buy();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;省略八百行差不多的代码.....&lt;/span&gt;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这老王似乎在炒股票，好专业的样子。&lt;/p&gt;
&lt;p&gt;　　于是我伸手拍了拍老王的肩膀：“干啥呢？”。&lt;/p&gt;
&lt;p&gt;　　老王一下子打了个哆嗦，回头看到是我，才松了一口气，说道：“搞毛线，今天的情况有点复杂，我这些股票感觉要死一大片，得抓紧时间调整战术”。&lt;/p&gt;

&lt;p&gt;　　我仔细看了一下老王的程序：&lt;/p&gt;
&lt;p&gt;股票1：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Stock1 {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; sell(){
        System.out.println(&lt;/span&gt;&quot;卖出股票1&quot;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; buy(){
        System.out.println(&lt;/span&gt;&quot;买入股票1&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;股票2：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Stock2 {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; sell(){
        System.out.println(&lt;/span&gt;&quot;卖出股票2&quot;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; buy(){
        System.out.println(&lt;/span&gt;&quot;买入股票2&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;股票3：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Stock3 {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; sell(){
        System.out.println(&lt;/span&gt;&quot;卖出股票3&quot;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; buy(){
        System.out.println(&lt;/span&gt;&quot;买入股票3&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;省略其他股票。。。。。&lt;/p&gt;

&lt;p&gt;　　看到这里，我脑海中立刻浮现出一张缩略图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1181622/201905/1181622-20190505143819498-1387975808.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　“我草！，老王，你牛逼啊，这么多股票，你一个一个操作，得搞死多少脑细胞啊？小心精尽人亡。”&lt;/p&gt;
&lt;p&gt;　　“老赵，你有好办法？”&lt;/p&gt;

&lt;h3&gt;马爸爸的余额宝&lt;/h3&gt;
&lt;p&gt;　　下班后，老王来我家里取经，我给他看了个产品，余额宝：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; YuEBao {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; in(){
        System.out.println(&lt;/span&gt;&quot;存钱&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; select(){
        System.out.println(&lt;/span&gt;&quot;查询余额&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; out(){
        System.out.println(&lt;/span&gt;&quot;取钱&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; execute(){
        Stock1 stock1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Stock1();
        stock1.buy();

        Stock2 stock2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Stock2();
        stock2.sell();

        Stock3 stock3 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Stock3();
        stock3.buy();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　“老赵，你这玩意儿怎么用？”&lt;/p&gt;
&lt;p&gt;　　“这个叫余额宝，我只需要往里存钱，然后就每天收钱就行，啥都不需要管，至于操作各种股票的execute方法由余额宝自己去搞，人家有一批专业的投资专家团队帮你操作资金”&lt;/p&gt;
&lt;p&gt;　　“这样我就不用自己去直接操作几十只股票了？”&lt;/p&gt;
&lt;p&gt;　　“是的，只是如果赚的话可能没你自己操作赚的多，但是非常稳定。市场上还有很多基金也是一样的道理，都是封装了各种股票操作的细节，只给我们提供最简单的投入、取现等大众化接口。”&lt;/p&gt;
&lt;p&gt;用图来表达就是这样子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1181622/201905/1181622-20190505144006893-2101775312.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;门面模式&lt;/h3&gt;
&lt;p&gt;　　门面模式（Facade Pattern），也叫做外观模式，为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。&lt;/p&gt;
&lt;p&gt;　　余额宝这个类，其实就是一个门面 Facade，它封装了子系统操作各种股票的逻辑，减少了外部系统与内部系统的依赖，使得所有依赖都是针对门面对象，无论子系统中的股票如何变化，都不影响到外部系统。&lt;/p&gt;

&lt;p&gt;　　当然，如果代码表现出的门面模式引起了你的争议，那么你也可以这么写：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; YuEBao {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; stock1Buy(){
        Stock1 stock1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Stock1();
        stock1.buy();
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; stock1Sell(){
        Stock1 stock1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Stock1();
        stock1.sell();
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; stock2Buy(){
        Stock2 stock2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Stock2();
        stock2.buy();
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; stock1Sel2(){
        Stock2 stock2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Stock2();
        stock2.sell();
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; stock3Buy(){
        Stock3 stock3 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Stock3();
        stock3.buy();
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; stock1Sel3(){
        Stock3 stock3 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Stock3();
        stock3.sell();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　门面模式是一种常用的封装方式，可能大家在开发中会经常使用到，实际上，门面对象中并没有什么实际的业务逻辑，它只是一个委托类。&lt;/p&gt;
</description>
<pubDate>Sun, 05 May 2019 06:41:00 +0000</pubDate>
<dc:creator>不该相遇在秋天</dc:creator>
<og:description>老王的股票 大家好，我是小赵，目前任职藏剑山庄高级铸剑师，在山庄里和我玩的比较好的有老王和老刘他们几个，都是组长级别的二货们，经常混在一起打牌。 今天上午闲得蛋疼晃悠晃悠的晃到的老王的地盘，看到老王在</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fengyumeng/p/10812964.html</dc:identifier>
</item>
<item>
<title>git 入门教程之 git bash 竟然不支持 tree 命令 - 雪之梦技术驿站</title>
<link>http://www.cnblogs.com/snowdreams1006/p/10812861.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/snowdreams1006/p/10812861.html</guid>
<description>&lt;h2 id=&quot;开门见山&quot;&gt;开门见山&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;git bash&lt;/code&gt; 是 &lt;code&gt;Windows&lt;/code&gt; 用户安装 &lt;code&gt;git&lt;/code&gt; 时默认安装的命令行工具,不仅界面漂亮功能也不错,大多数情况下可以替代 &lt;code&gt;Windows&lt;/code&gt; 原生的 &lt;code&gt;cmd&lt;/code&gt; 命令行.&lt;/p&gt;
&lt;p&gt;然而,&lt;code&gt;git bash&lt;/code&gt; 命令行不是万金油,并不能完全替代 &lt;code&gt;cmd&lt;/code&gt; ,详情请参考 &lt;code&gt;mintty&lt;/code&gt; 官网的&lt;a href=&quot;https://mintty.github.io/#Compatibility&quot;&gt;相关说明&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-4352c182bfb5a875.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;git-bash-tree-mintty.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;mintty is not a full replacement for the Windows Console window&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;git bash&lt;/code&gt; 命令行默认使用 &lt;code&gt;mintty&lt;/code&gt; 作为终端模拟器,而 &lt;code&gt;mintty&lt;/code&gt; 官宣表示自己不能完全替代 &lt;code&gt;cmd&lt;/code&gt;,也就是说 &lt;code&gt;git bash&lt;/code&gt; 可能不具备某些 &lt;code&gt;cmd&lt;/code&gt; 命令.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-2a98f33d495ea346.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;git-bash-setup-terminal.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;举个简单的例子,如果想要查看当前目录的文件结构,最好是以目录树的形式展现,聪明的你获取已经猜到了&lt;code&gt;tree&lt;/code&gt; 命令.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git bash&lt;/code&gt; 命令行中输入 &lt;code&gt;tree&lt;/code&gt; 命令发现并无此命令.&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;snowdreams1006@home MINGW64 /g/sublime/test
$ tree
bash: tree: command not found&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了验证,确实没有 &lt;code&gt;tree&lt;/code&gt; 命令,我们直接打开 &lt;code&gt;git bash&lt;/code&gt; 支持的命令文件目录,查看到底有没有 &lt;code&gt;tree.exe&lt;/code&gt; 文件.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-a5242044c06b9f48.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;git-bash-bin.gif&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;在 &lt;code&gt;git bash&lt;/code&gt; 桌面快捷方式&lt;strong&gt;右键&lt;/strong&gt;,选择&lt;strong&gt;打开文件位置&lt;/strong&gt;,当前正处于 &lt;code&gt;git&lt;/code&gt; 的安装目录,进入&lt;code&gt;.\usr\bin&lt;/code&gt; 文件夹.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;经过验证,&lt;code&gt;git bash&lt;/code&gt; 支持的命令文件确实没有发现 &lt;code&gt;tree.exe&lt;/code&gt; 文件,因此真的不支持 &lt;code&gt;tree&lt;/code&gt; 命令.&lt;/p&gt;
&lt;p&gt;然而,&lt;code&gt;cmd&lt;/code&gt; 自带的命令行中输入 &lt;code&gt;tree&lt;/code&gt; 中竟然发现能够输出目录树,原来 &lt;code&gt;cmd&lt;/code&gt; 支持 &lt;code&gt;tree&lt;/code&gt; 命令.&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;G:\sublime\test&amp;gt;tree
卷 工作 的文件夹 PATH 列表
卷序列号为 00000081 CC3C:50D0
G:.
├─cmd
└─git&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-9e623211edd7da68.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;git-bash-tree-cmd.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;tree&lt;/code&gt; 命令其实调用的是 &lt;code&gt;tree.com&lt;/code&gt; 并不是常见的 &lt;code&gt;tree.exe&lt;/code&gt; 格式.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;科普时间&quot;&gt;科普时间&lt;/h2&gt;
&lt;p&gt;现在我们已经知道 &lt;code&gt;git bash&lt;/code&gt; 提供的终端模拟器不支持某些 &lt;code&gt;linux&lt;/code&gt; 命令,但是为什么不支持以及如何才能支持这些命令呢?&lt;/p&gt;
&lt;p&gt;这些问题必须等我们弄清楚 &lt;code&gt;mintty&lt;/code&gt; 的朋友圈关系才能更好地解决上述问题,接下来简单科普下 &lt;code&gt;mintty&lt;/code&gt; 的朋友圈.&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;关于科普知识的来源,请参考上一篇文章: &amp;lt;&amp;gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;mintty-是什么&quot;&gt;&lt;code&gt;mintty&lt;/code&gt; 是什么&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;code&gt;Mintty&lt;/code&gt; 是 &lt;code&gt;Cygwin&lt;/code&gt;，&lt;code&gt;MSYS&lt;/code&gt; 或 &lt;code&gt;Msys2&lt;/code&gt; 的终端模拟器,派生项目和 &lt;code&gt;WSL&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;mintty&lt;/code&gt; 开源终端模拟器,基于 &lt;code&gt;putty&lt;/code&gt; 的终端仿真和 &lt;code&gt;Windows&lt;/code&gt; 前端页面.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-187f47d572263752.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;git-bash-tree-mintty-homepage.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mintty&lt;/code&gt; 作为一款优秀的终端模拟器,不仅是其他系统上默认的终端,也是 &lt;code&gt;git bash&lt;/code&gt; 的默认终端.&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ mintty --help
Usage: mintty [OPTION]... [ PROGRAM [ARG]... | - ]

Start a new terminal session running the specified program or the user's shell.
If a dash is given instead of a program, invoke the shell as a login shell.

Options:
  -c, --config FILE     Load specified config file
  -e, --exec            Treat remaining arguments as the command to execute
  -h, --hold never|start|error|always  Keep window open after command finishes
  -i, --icon FILE[,IX]  Load window icon from file, optionally with index
  -l, --log FILE|-      Log output to file or stdout
  -o, --option OPT=VAL  Override config file option with given value
  -p, --position X,Y    Open window at specified coordinates
  -s, --size COLS,ROWS  Set screen size in characters
  -t, --title TITLE     Set window title (default: the invoked command)
  -u, --utmp            Create a utmp entry
  -w, --window normal|min|max|full|hide  Set initial window state
      --class CLASS     Set window class name (default: mintty)
  -H, --help            Display help and exit
  -V, --version         Print version information and exit&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果想要自定义 &lt;code&gt;mintty&lt;/code&gt; 终端,在 &lt;code&gt;git bash&lt;/code&gt; 命令行界面右键选择选项设置即可打开设置页面.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-17023cdd4aa4dca4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;git-bash-tree-options.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;mingw-是什么&quot;&gt;&lt;code&gt;mingw&lt;/code&gt; 是什么&lt;/h3&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;code&gt;mingw&lt;/code&gt; 是 &lt;code&gt;Minimalist GNU for Windows&lt;/code&gt; 的缩写,是 &lt;code&gt;Microsoft Windows&lt;/code&gt; 应用程序的极简主义开发环境.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-31b867d0ee2858e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;git-bash-tree-mingw.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;msys-是什么&quot;&gt;&lt;code&gt;msys&lt;/code&gt; 是什么&lt;/h3&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;&lt;code&gt;MSYS&lt;/code&gt; 是 &lt;code&gt;Minimal SYStem&lt;/code&gt; 的缩写,是 &lt;code&gt;Bourne Shell&lt;/code&gt; 命令行解释器系统.作为 &lt;code&gt;Microsoft&lt;/code&gt; 的 &lt;code&gt;cmd.exe&lt;/code&gt; 的替代品,它提供了一个通用的命令行环境,特别适合与 &lt;code&gt;MinGW&lt;/code&gt; 一起使用,用于将许多开源应用程序移植到 &lt;code&gt;MS-Windows&lt;/code&gt;平台; 它是 &lt;code&gt;Cygwin-1.3&lt;/code&gt; 的轻量级分支，它包含一小部分 &lt;code&gt;Unix&lt;/code&gt; 工具,可以帮助实现这一目标.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-272572262444b930.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;git-bash-tree-msys.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;cygwin-是什么&quot;&gt;&lt;code&gt;cygwin&lt;/code&gt; 是什么&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;大量 &lt;code&gt;GNU&lt;/code&gt; 和开源工具,提供类似于 &lt;code&gt;Windows&lt;/code&gt; 上的 &lt;code&gt;Linux&lt;/code&gt; 发行版的功能.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-5178d4a1db9fca87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;git-bash-tree-cygwin.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;gnu-是什么&quot;&gt;&lt;code&gt;gnu&lt;/code&gt; 是什么&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;code&gt;GNU&lt;/code&gt; 是 &lt;code&gt;GNU's Not Unix&lt;/code&gt; 的递归缩写,是自由软件操作系统.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-247c42d34fb89f0e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;git-bash-tree-gnu.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;朋友圈关系梳理&quot;&gt;朋友圈关系梳理&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;git bash&lt;/code&gt; 采用 &lt;code&gt;mintty&lt;/code&gt; 作为终端模拟器,而 &lt;code&gt;mintty&lt;/code&gt; 终端是 &lt;code&gt;mingw&lt;/code&gt; ,&lt;code&gt;msys2&lt;/code&gt; 和 &lt;code&gt;cygwin&lt;/code&gt;的默认终端,这些&quot;操作系统&quot;或多或少都是 &lt;code&gt;GNU&lt;/code&gt; 的一部分.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;GNU&lt;/code&gt; 是自由软件运动的成果,提出自由软件以及自由软件操作系统概念,源码开源发布.&lt;/p&gt;
&lt;p&gt;正因如此,江山代有才人出,前人栽树后人乘凉,&lt;code&gt;Cygwin&lt;/code&gt; 作为 &lt;code&gt;GNU&lt;/code&gt; 一员,提出了要在 &lt;code&gt;Windows&lt;/code&gt; 打造出 &lt;code&gt;Linux&lt;/code&gt; 的感觉,开发出一套完整的解决方案.&lt;/p&gt;
&lt;p&gt;或许由于这套方案太完整,功能齐全因而软件包体积庞大,因此 &lt;code&gt;MinGW&lt;/code&gt; 和 &lt;code&gt;MSYS&lt;/code&gt; 分别在其基于上进行精简重构,保留最简功能,发展出&quot;极简主义的GNU&quot;.&lt;/p&gt;
&lt;p&gt;开源的力量是可持续的,慢慢的,这些操作系统的内置终端功能也被单独提取出来,&lt;code&gt;mintty&lt;/code&gt; 作为他们的默认终端也逐渐独立提供终端模拟器服务,轻松和各个系统进行安装集成.&lt;/p&gt;
&lt;p&gt;说到开源,自然是少不了 &lt;code&gt;git&lt;/code&gt; 的身影,分布式版本控制系统这种优秀工具应该造福全人类,然而 &lt;code&gt;git&lt;/code&gt; 本身仅支持类 &lt;code&gt;Unix&lt;/code&gt; 系统,并不提供 &lt;code&gt;WIndows&lt;/code&gt; 系统的支持.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Git For Windows&lt;/code&gt; 组织出手增加了 &lt;code&gt;git&lt;/code&gt; 对 &lt;code&gt;Windows&lt;/code&gt; 系统的支持,背后的技术多半离不开上述介绍的 &lt;code&gt;GNU&lt;/code&gt; 操作系统.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Git Bash Here&lt;/code&gt; 则是 &lt;code&gt;Git For Windows&lt;/code&gt; 的命令行工具,使用的终端模拟器就是明星模拟器 &lt;code&gt;mintty&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-f8f8672d71169262.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;git-bash-mintty-summary.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;回到正题&quot;&gt;回到正题&lt;/h2&gt;
&lt;p&gt;弄清楚事情的来龙去脉后,对我们解决问题有什么帮助呢?&lt;/p&gt;
&lt;p&gt;帮助可大了去了,刨根问题找到了源头,问题自然迎刃而解!&lt;/p&gt;
&lt;h3 id=&quot;我劝少年放弃吧&quot;&gt;我劝少年放弃吧&lt;/h3&gt;
&lt;p&gt;你确定不是在逗我?让我直接放弃?&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-9ad567b609352ea6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;git-bash-tree-abandon.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;亲,真的抱歉呢,放弃是解决问题的最快途径!&lt;/p&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;p&gt;谈一谈为什么要放弃?&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git bash&lt;/code&gt; 命令行使用的是 &lt;code&gt;mintty&lt;/code&gt; 终端,而 &lt;code&gt;mintty&lt;/code&gt; 终端并不能完全替代 &lt;code&gt;cmd&lt;/code&gt; ,也没有提供包管理工具供我们扩展第三方命令.&lt;/p&gt;
&lt;p&gt;所以默认情况下,如果没有提供某些命令,那我们只好放弃在 &lt;code&gt;git bash&lt;/code&gt; 命令行中使用这些命令.&lt;/p&gt;
&lt;p&gt;此路不通,自然会寻求其他解决途径,比如可以借助 &lt;code&gt;cmd&lt;/code&gt; 命令行或者其他第三方软件等,没必要非要坚持使用&lt;code&gt;git bash&lt;/code&gt;!&lt;/p&gt;
&lt;p&gt;既然本文是 &lt;code&gt;tree&lt;/code&gt; 命令引发的讨论,那就谈点和主题有关的技能点,不然岂不是跑题了?&lt;/p&gt;
&lt;p&gt;&lt;code&gt;tree&lt;/code&gt; 命令虽然 &lt;code&gt;git bash&lt;/code&gt; 不提供,但是 &lt;code&gt;cmd&lt;/code&gt; 却已经内置了.&lt;/p&gt;
&lt;p&gt;值得注意的是,&lt;code&gt;cmd&lt;/code&gt; 提供的 &lt;code&gt;tree&lt;/code&gt; 命令比较特殊,并不是常见的 &lt;code&gt;.exe&lt;/code&gt; 结尾文件,而是 &lt;code&gt;.com&lt;/code&gt; 结尾的文件.&lt;/p&gt;
&lt;p&gt;所以 &lt;code&gt;git bash&lt;/code&gt; 中输入 &lt;code&gt;tree&lt;/code&gt; 命令时,自身 &lt;code&gt;/usr/bin&lt;/code&gt; 中没有 &lt;code&gt;tree.exe&lt;/code&gt; 文件,而系统中也没有 &lt;code&gt;tree.exe&lt;/code&gt; 命令,那么就会提示找不到命令了啊!&lt;/p&gt;
&lt;h4 id=&quot;手动补全命令&quot;&gt;手动补全命令&lt;/h4&gt;
&lt;p&gt;那么第一种调用方法便是补全后缀名,这样自然能够调用 &lt;code&gt;cmd&lt;/code&gt; 的 &lt;code&gt;tree.com&lt;/code&gt; 命令.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-3ccfb13ded7997a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;git-bash-tree-cmd.com.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;code&gt;git bash&lt;/code&gt; 并不识别 &lt;code&gt;.com&lt;/code&gt; 后缀的命令,输入 &lt;code&gt;tree&lt;/code&gt; 命令时以为是 &lt;code&gt;tree.exe&lt;/code&gt; ,实际上 &lt;code&gt;tree&lt;/code&gt; 命令应该是 &lt;code&gt;tree.com&lt;/code&gt; 的简写.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我擦,竟然出现乱码,根据我多年的开发经验来看,乱码问题多半是编码问题导致的,那么修改下终端的编码设置应该就能解决问题.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-887986855f28a1b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;git-bash-tree-encoding-utf8.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;在命令行窗口内右键弹出 &lt;code&gt;mintty&lt;/code&gt; 终端的设置页面,选择文本(&lt;code&gt;Text&lt;/code&gt;)中本地化(&lt;code&gt;Locale&lt;/code&gt;)配置,选择中文简体(&lt;code&gt;zh_CN&lt;/code&gt;),字符集(&lt;code&gt;Character set&lt;/code&gt;)设置为&lt;code&gt;UTF-8&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-4330cfcb50abb3e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;git-bash-tree-encoding-fail.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;瞬间被打脸,无论是原来的&lt;code&gt;git bash&lt;/code&gt; 命令行窗口还是新开的命令行窗口,仍然还是乱码!&lt;/p&gt;
&lt;p&gt;然而,我是不会承认被打脸的,世人皆醉我独醒,肯定是 &lt;code&gt;bug&lt;/code&gt;,哈哈!&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;其实,中文乱码真的是 &lt;code&gt;bug&lt;/code&gt; ,还是官方认可的 &lt;code&gt;bug&lt;/code&gt; 哟,我并没有被打脸呢,后续会介绍.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;调用-cmd-程序&quot;&gt;调用 &lt;code&gt;cmd&lt;/code&gt; 程序&lt;/h4&gt;
&lt;p&gt;既然&lt;code&gt;git bash&lt;/code&gt; 没有提供 &lt;code&gt;tree&lt;/code&gt; 命令,而恰巧 &lt;code&gt;cmd&lt;/code&gt; 提供了 &lt;code&gt;tree&lt;/code&gt; 命令,那为何不假借他人之手实现自己的目的呢?&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;cmd&lt;/code&gt; 中使用 &lt;code&gt;tree&lt;/code&gt; 命令直接输入即可得到目录树结构,但是现在需要在 &lt;code&gt;git bash&lt;/code&gt; 中调用 &lt;code&gt;cmd&lt;/code&gt; 中的 &lt;code&gt;tree&lt;/code&gt; 命令.&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;# 直接输入 `tree` 命令,正确响应并且无中文乱码.
G:\sublime\test&amp;gt;tree
卷 工作 的文件夹 PATH 列表
卷序列号为 00000093 CC3C:50D0
G:.
├─cmd
└─git

# 输入 `cmd tree` 命令,虽无报错,但也没有正确响应.
G:\sublime\test&amp;gt;cmd tree
Microsoft Windows [版本 6.3.9600]
(c) 2013 Microsoft Corporation。保留所有权利。&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;code&gt;cmd&lt;/code&gt; 中直接输入 &lt;code&gt;tree&lt;/code&gt; 命令即可,无需通过 &lt;code&gt;cmd tree&lt;/code&gt; 这种方式,还以为你要调用 &lt;code&gt;cmd&lt;/code&gt; 命令呢!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因此,我们需要告诉&lt;code&gt;git bash&lt;/code&gt; 要通过 &lt;code&gt;cmd&lt;/code&gt; 去调用下 &lt;code&gt;tree&lt;/code&gt; 命令.&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;# 注意看前缀是 `snowdreams1006@home MINGW64` 表明当前处于 `git bash` 环境
snowdreams1006@home MINGW64 /g/sublime/test
# 输入 `cmd tree` 命令,虽无报错,但也没有正确响应,并且仍然有中文乱码.
$ cmd tree
Microsoft Windows [▒汾 6.3.9600]
(c) 2013 Microsoft Corporation▒▒▒▒▒▒▒▒▒▒Ȩ▒▒▒▒
# 输出 `tree` 命令,正确响应但有中文乱码.此时命令行前缀已经更改为 `G:\sublime\test&amp;gt;` 表明当前不再处于`git bash` 环境!
G:\sublime\test&amp;gt;tree
tree
▒▒ ▒▒▒▒ ▒▒▒ļ▒▒▒ PATH ▒б▒
▒▒▒▒▒к▒Ϊ 0000006B CC3C:50D0
G:.
▒▒▒▒cmd
▒▒▒▒git&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过上述操作结果来看,不难发现以下问题.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;cmd tree&lt;/code&gt; 命令切换到 &lt;code&gt;cmd&lt;/code&gt; 环境,并且&lt;code&gt;tree&lt;/code&gt; 命令并没有执行.&lt;br/&gt;换句话说,&lt;code&gt;cmd tree&lt;/code&gt; 和 &lt;code&gt;cmd dir&lt;/code&gt; 或者 &lt;code&gt;cmd&lt;/code&gt; 的作用相同,都是切换了当前 &lt;code&gt;bash&lt;/code&gt; 环境.&lt;/li&gt;
&lt;li&gt;进入 &lt;code&gt;cmd&lt;/code&gt; 命令行运行 &lt;code&gt;tree&lt;/code&gt; 能够得到正确响应,但存在中文乱码.&lt;/li&gt;
&lt;li&gt;想要退出 &lt;code&gt;cmd&lt;/code&gt; 环境,&lt;code&gt;Ctrl + C&lt;/code&gt; 组合即可重新回到 &lt;code&gt;git bash&lt;/code&gt; 环境.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;由此可见,不加任何参数冒昧进入到 &lt;code&gt;cmd&lt;/code&gt; 环境还是比较麻烦的,因此下面提供带参数的命令帮助我们阅后即焚.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cmd //c tree&lt;/code&gt; 命令,阅后即焚,表示执行完立即退出.&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;snowdreams1006@home MINGW64 /g/sublime/test
$ cmd //c tree
▒▒ ▒▒▒▒ ▒▒▒ļ▒▒▒ PATH ▒б▒
▒▒▒▒▒к▒Ϊ 00000008 CC3C:50D0
G:.
▒▒▒▒cmd
▒▒▒▒git
snowdreams1006@home MINGW64 /g/sublime/test
$&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;执行命令前后我们都在 &lt;code&gt;git bash&lt;/code&gt; 环境并且在 &lt;code&gt;cmd&lt;/code&gt; 中得到正确响应结果,唯一的区别就是多加了 &lt;code&gt;//c&lt;/code&gt; 参数,表示执行完命令立即退出 &lt;code&gt;cmd&lt;/code&gt; 环境.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;优雅调用-cmd&quot;&gt;优雅调用 &lt;code&gt;cmd&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;简单总结下,如何在 &lt;code&gt;git bash&lt;/code&gt; 中借助 &lt;code&gt;cmd&lt;/code&gt; 实现 &lt;code&gt;tree&lt;/code&gt; 命令.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;tree.com&lt;/code&gt; : 补全调用命令后缀名,直接调用系统命令.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cmd //c tree&lt;/code&gt; : 借助 &lt;code&gt;cmd&lt;/code&gt; 运行 &lt;code&gt;tree&lt;/code&gt; 命令,从而实现调用 &lt;code&gt;tree&lt;/code&gt; 的目的.&lt;/li&gt;
&lt;li&gt;这两种方式都存在中文乱码问题,即使设置了终端的编码方式也没有解决乱码.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;调用 &lt;code&gt;tree&lt;/code&gt; 命令的目的已经达到,没有解决的问题是中文乱码.&lt;/p&gt;
&lt;p&gt;解决问题最快速的方式是百度一下或者从官网寻求帮助,这次我选择后者,因为百度一下人人都会,不用我再讲了吧!&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-be1fe39d9ff02767.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;git-bash-tree-mintty-winpty.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;简单解释下这段话的意思:&lt;/p&gt;
&lt;p&gt;如果在 &lt;code&gt;mintty&lt;/code&gt; 终端调用原生 &lt;code&gt;cmd&lt;/code&gt; 程序,简单的输出指令没有什么问题,交互指令可能存在问题.&lt;br/&gt;因此建议使用 &lt;code&gt;winpty&lt;/code&gt; 进行包装再调用原生 &lt;code&gt;cmd&lt;/code&gt; 程序.&lt;/p&gt;
&lt;blockquote readability=&quot;3.8571428571429&quot;&gt;
&lt;p&gt;&lt;code&gt;winpty&lt;/code&gt; 是一种提供与&lt;code&gt;cmd&lt;/code&gt; 通信的软件包,详情请参考&lt;a href=&quot;https://github.com/rprichard/winpty&quot; class=&quot;uri&quot;&gt;https://github.com/rprichard/winpty&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-a142732ffd65096b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;git-bash-tree-winpty-github.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有什么神奇之处?不妨加上 &lt;code&gt;winpty&lt;/code&gt; 试试看!&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;snowdreams1006@home MINGW64 /g/sublime/test
# `winpty` + `tree.com` : 正常输出且无中文乱码 
$ winpty tree.com
卷 工作 的文件夹 PATH 列表
卷序列号为 00000074 CC3C:50D0
G:.
├─cmd
└─git

snowdreams1006@home MINGW64 /g/sublime/test
# `winpty` + `cmd //c tree` : 正常输出且无中文乱码
$ winpty cmd //c tree
卷 工作 的文件夹 PATH 列表
卷序列号为 000000B3 CC3C:50D0
G:.
├─cmd
└─git

snowdreams1006@home MINGW64 /g/sublime/test
$&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;果然是神药,一下子就治好了我多年的老寒腿啊!&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;winpty tree.com&lt;/code&gt; : 不叫小名而叫全称,直接调用系统命令&lt;/li&gt;
&lt;li&gt;&lt;code&gt;winpty cmd //c tree&lt;/code&gt; : 假借他人之手,变相调用系统命令&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;上文中说设置文件编码应该能够解决中文乱码问题结果仍然有乱码,猜测是 &lt;code&gt;bug&lt;/code&gt; ,现在没有打脸吧?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;既然已经提供了解决方案,那文章是不是应该到此为止了呢?&lt;/p&gt;
&lt;p&gt;不不不,远远还没结束,这只是开胃小菜,好戏还在后头呢.&lt;/p&gt;
&lt;p&gt;更何况这命令也忒长了,记不住啊!&lt;/p&gt;
&lt;p&gt;很简单,可以设置别名啊,把常用命令设置成别名,这样就记住啦!&lt;/p&gt;
&lt;p&gt;输入 &lt;code&gt;alias&lt;/code&gt; 命令没有报错,说明目前环境是支持设置别名的.&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;snowdreams1006@home MINGW64 /g/sublime/test
$ alias
alias ll='ls -l'
alias ls='ls -F --color=auto --show-control-chars'
alias node='winpty node.exe'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;按照 &lt;code&gt;linux&lt;/code&gt; 的操作习惯,命令行设置的一般都是临时性的,想要永久生效,都要写入到文件中,别名这种当然要一劳永逸设置成永久文件.&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;snowdreams1006@home MINGW64 /g/sublime/test
$ cat /etc/bashrc
cat: /etc/bashrc: No such file or directory

snowdreams1006@home MINGW64 /g/sublime/test
$ cat ~/.bashrc
cat: /c/Users/snowdreams1006/.bashrc: No such file or directory&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;竟然配置文件都不存在?&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-77b73ad13001cec9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;git-bash-tree-winpty-github.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然不存在了啊!快醒醒,你是在 &lt;code&gt;Windows&lt;/code&gt; 系统上并不是 &lt;code&gt;Linux&lt;/code&gt; 系统,上哪给你弄这些配置文件去?&lt;/p&gt;
&lt;p&gt;脑海中迅速闪现哲学基本问题: 我是谁,我在那,我在干什么?&lt;/p&gt;
&lt;p&gt;我是 &lt;code&gt;Windows&lt;/code&gt; 系统用户,正在 &lt;code&gt;git bash&lt;/code&gt; 命令行中试图设置别名,没有找到类似于 &lt;code&gt;linux&lt;/code&gt; 配置文件.&lt;/p&gt;
&lt;p&gt;既然你明白你何出来,那你去那里看看有没有什么发现?&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;snowdreams1006@home MINGW64 /g/sublime/test
$ cd /e/git
snowdreams1006@home MINGW64 /e/git
$ winpty tree.com
卷 软件 的文件夹 PATH 列表
卷序列号为 00000063 223E:7300
E:.
├─bin
├─cmd
├─dev
│  ├─mqueue
│  └─shm
├─etc
│  ├─pkcs11
│  ├─pki
│  │  └─ca-trust
│  │      ├─extracted
│  │      │  ├─java
│  │      │  ├─openssl
│  │      │  └─pem
│  │      └─source
│  │          └─anchors
│  ├─profile.d
│  └─ssh
├─mingw64
│  ├─bin
│  ├─doc
│  │  └─git-credential-manager
│  ├─etc
│  │  ├─pkcs11
│  │  └─pki
│  │      └─ca-trust
│  │          └─extracted
│  │              ├─java
│  │              ├─openssl
│  │              └─pem
│  ├─lib
│  │  ├─dde1.4
│  │  ├─engines
│  │  ├─itcl4.0.4
│  │  ├─p11-kit
│  │  ├─pkcs11
│  │  ├─reg1.3
│  │  ├─sqlite3.11.0
│  │  ├─tcl8
│  │  │  ├─8.4
│  │  │  │  └─platform
│  │  │  ├─8.5
│  │  │  └─8.6
│  │  │      └─tdbc
│  │  ├─tcl8.6
│  │  │  ├─encoding
│  │  │  ├─http1.0
│  │  │  ├─msgs
│  │  │  ├─opt0.4
│  │  │  └─tzdata
│  │  │      ├─Africa
│  │  │      ├─America
│  │  │      │  ├─Argentina
│  │  │      │  ├─Indiana
│  │  │      │  ├─Kentucky
│  │  │      │  └─North_Dakota
│  │  │      ├─Antarctica
│  │  │      ├─Arctic
│  │  │      ├─Asia
│  │  │      ├─Atlantic
│  │  │      ├─Australia
│  │  │      ├─Brazil
│  │  │      ├─Canada
│  │  │      ├─Chile
│  │  │      ├─Etc
│  │  │      ├─Europe
│  │  │      ├─Indian
│  │  │      ├─Mexico
│  │  │      ├─Pacific
│  │  │      ├─SystemV
│  │  │      └─US
│  │  ├─thread2.7.3
│  │  └─tk8.6
│  │      ├─demos
│  │      │  └─images
│  │      ├─images
│  │      ├─msgs
│  │      └─ttk
│  ├─libexec
│  │  └─git-core
│  │      └─mergetools
│  ├─share
│  │  ├─antiword
│  │  ├─doc
│  │  │  ├─connect
│  │  │  ├─git-doc
│  │  │  │  ├─howto
│  │  │  │  └─technical
│  │  │  └─nghttp2
│  │  ├─gettext-0.19.7
│  │  │  └─its
│  │  ├─git
│  │  │  ├─bindimage.txt
│  │  │  └─completion
│  │  ├─git-core
│  │  │  └─templates
│  │  │      ├─hooks
│  │  │      └─info
│  │  ├─git-gui
│  │  │  └─lib
│  │  ├─gitweb
│  │  │  └─static
│  │  ├─licenses
│  │  │  ├─bzip2
│  │  │  ├─expat
│  │  │  ├─gcc-libs
│  │  │  ├─gettext
│  │  │  │  ├─gettext-runtime
│  │  │  │  │  ├─intl
│  │  │  │  │  └─libasprintf
│  │  │  │  ├─gettext-tools
│  │  │  │  │  └─gnulib-lib
│  │  │  │  │      └─libxml
│  │  │  │  └─gnulib-local
│  │  │  │      └─lib
│  │  │  │          └─libxml
│  │  │  ├─libffi
│  │  │  ├─libiconv
│  │  │  │  └─libcharset
│  │  │  ├─libssh2
│  │  │  ├─libsystre
│  │  │  ├─libtasn1
│  │  │  ├─libtre
│  │  │  ├─libwinpthread
│  │  │  │  └─mingw-w64-libraries
│  │  │  │      └─winpthreads
│  │  │  ├─openssl
│  │  │  ├─wineditline
│  │  │  └─zlib
│  │  ├─nghttp2
│  │  ├─p11-kit
│  │  │  └─modules
│  │  ├─perl5
│  │  │  └─site_perl
│  │  │      └─Git
│  │  │          └─SVN
│  │  │              └─Memoize
│  │  └─pki
│  │      └─ca-trust-source
│  └─ssl
│      └─certs
├─tmp
└─usr
    ├─bin
    │  ├─core_perl
    │  └─vendor_perl
    ├─lib
    │  ├─awk
    │  ├─coreutils
    │  ├─gawk
    │  ├─gnupg
    │  │  └─gnupg
    │  ├─openssl
    │  │  └─engines
    │  ├─p11-kit
    │  ├─perl5
    │  │  ├─core_perl
    │  │  │  ├─auto
    │  │  │  │  ├─arybase
    │  │  │  │  ├─attributes
    │  │  │  │  ├─B
    │  │  │  │  ├─Compress
    │  │  │  │  │  └─Raw
    │  │  │  │  │      ├─Bzip2
    │  │  │  │  │      └─Zlib
    │  │  │  │  ├─Cwd
    │  │  │  │  ├─Data
    │  │  │  │  │  └─Dumper
    │  │  │  │  ├─DB_File
    │  │  │  │  ├─Devel
    │  │  │  │  │  ├─Peek
    │  │  │  │  │  └─PPPort
    │  │  │  │  ├─Digest
    │  │  │  │  │  ├─MD5
    │  │  │  │  │  └─SHA
    │  │  │  │  ├─Encode
    │  │  │  │  │  ├─Byte
    │  │  │  │  │  ├─CN
    │  │  │  │  │  ├─EBCDIC
    │  │  │  │  │  ├─JP
    │  │  │  │  │  ├─KR
    │  │  │  │  │  ├─Symbol
    │  │  │  │  │  ├─TW
    │  │  │  │  │  └─Unicode
    │  │  │  │  ├─Fcntl
    │  │  │  │  ├─File
    │  │  │  │  │  ├─DosGlob
    │  │  │  │  │  └─Glob
    │  │  │  │  ├─Filter
    │  │  │  │  │  └─Util
    │  │  │  │  │      └─Call
    │  │  │  │  ├─GDBM_File
    │  │  │  │  ├─Hash
    │  │  │  │  │  └─Util
    │  │  │  │  │      └─FieldHash
    │  │  │  │  ├─I18N
    │  │  │  │  │  └─Langinfo
    │  │  │  │  ├─IO
    │  │  │  │  ├─IPC
    │  │  │  │  │  └─SysV
    │  │  │  │  ├─List
    │  │  │  │  │  └─Util
    │  │  │  │  ├─Math
    │  │  │  │  │  └─BigInt
    │  │  │  │  │      └─FastCalc
    │  │  │  │  ├─MIME
    │  │  │  │  │  └─Base64
    │  │  │  │  ├─mro
    │  │  │  │  ├─NDBM_File
    │  │  │  │  ├─ODBM_File
    │  │  │  │  ├─Opcode
    │  │  │  │  ├─PerlIO
    │  │  │  │  │  ├─encoding
    │  │  │  │  │  ├─mmap
    │  │  │  │  │  ├─scalar
    │  │  │  │  │  └─via
    │  │  │  │  ├─POSIX
    │  │  │  │  ├─re
    │  │  │  │  ├─SDBM_File
    │  │  │  │  ├─Socket
    │  │  │  │  ├─Storable
    │  │  │  │  ├─Sys
    │  │  │  │  │  ├─Hostname
    │  │  │  │  │  └─Syslog
    │  │  │  │  ├─threads
    │  │  │  │  │  └─shared
    │  │  │  │  ├─Tie
    │  │  │  │  │  └─Hash
    │  │  │  │  │      └─NamedCapture
    │  │  │  │  ├─Time
    │  │  │  │  │  ├─HiRes
    │  │  │  │  │  └─Piece
    │  │  │  │  ├─Unicode
    │  │  │  │  │  └─Collate
    │  │  │  │  ├─Win32
    │  │  │  │  ├─Win32API
    │  │  │  │  │  └─File
    │  │  │  │  └─Win32CORE
    │  │  │  ├─B
    │  │  │  ├─Compress
    │  │  │  │  └─Raw
    │  │  │  ├─CORE
    │  │  │  ├─Data
    │  │  │  ├─Devel
    │  │  │  ├─Digest
    │  │  │  ├─Encode
    │  │  │  │  ├─CN
    │  │  │  │  ├─JP
    │  │  │  │  ├─KR
    │  │  │  │  ├─MIME
    │  │  │  │  │  └─Header
    │  │  │  │  └─Unicode
    │  │  │  ├─File
    │  │  │  │  └─Spec
    │  │  │  ├─Filter
    │  │  │  │  └─Util
    │  │  │  ├─Hash
    │  │  │  │  └─Util
    │  │  │  ├─I18N
    │  │  │  ├─IO
    │  │  │  │  └─Socket
    │  │  │  ├─IPC
    │  │  │  ├─List
    │  │  │  │  └─Util
    │  │  │  ├─Math
    │  │  │  │  └─BigInt
    │  │  │  ├─MIME
    │  │  │  ├─PerlIO
    │  │  │  ├─Scalar
    │  │  │  ├─Sub
    │  │  │  ├─Sys
    │  │  │  ├─threads
    │  │  │  ├─Tie
    │  │  │  │  └─Hash
    │  │  │  ├─Time
    │  │  │  ├─Unicode
    │  │  │  │  └─Collate
    │  │  │  └─Win32API
    │  │  └─vendor_perl
    │  │      ├─auto
    │  │      │  ├─HTML
    │  │      │  │  └─Parser
    │  │      │  ├─Net
    │  │      │  │  └─SSLeay
    │  │      │  ├─SVN
    │  │      │  │  ├─_Client
    │  │      │  │  ├─_Core
    │  │      │  │  ├─_Delta
    │  │      │  │  ├─_Fs
    │  │      │  │  ├─_Ra
    │  │      │  │  ├─_Repos
    │  │      │  │  └─_Wc
    │  │      │  └─Term
    │  │      │      └─ReadKey
    │  │      ├─HTML
    │  │      ├─Net
    │  │      │  └─SSLeay
    │  │      ├─SVN
    │  │      └─Term
    │  ├─pkcs11
    │  ├─sasl2
    │  ├─ssh
    │  ├─tar
    │  └─terminfo
    │      ├─63
    │      ├─64
    │      └─78
    ├─libexec
    ├─share
    │  ├─bash-completion
    │  │  └─completions
    │  ├─cygwin
    │  ├─git
    │  ├─gnupg
    │  ├─licenses
    │  │  ├─curl
    │  │  ├─dos2unix
    │  │  ├─expat
    │  │  ├─file
    │  │  ├─gcc-libs
    │  │  ├─libffi
    │  │  ├─libsasl
    │  │  ├─libsqlite
    │  │  ├─libssh2
    │  │  ├─mintty
    │  │  ├─ncurses
    │  │  ├─openssh
    │  │  ├─openssl
    │  │  ├─p11-kit
    │  │  ├─perl-Net-SSLeay
    │  │  ├─perl-TermReadKey
    │  │  ├─unzip
    │  │  ├─vim
    │  │  └─zlib
    │  ├─misc
    │  ├─p11-kit
    │  │  └─modules
    │  ├─perl5
    │  │  ├─core_perl
    │  │  │  ├─App
    │  │  │  │  └─Prove
    │  │  │  │      └─State
    │  │  │  │          └─Result
    │  │  │  ├─Archive
    │  │  │  │  └─Tar
    │  │  │  ├─Attribute
    │  │  │  ├─autodie
    │  │  │  │  ├─exception
    │  │  │  │  └─Scope
    │  │  │  ├─B
    │  │  │  ├─Carp
    │  │  │  ├─Class
    │  │  │  ├─Compress
    │  │  │  ├─Config
    │  │  │  │  └─Perl
    │  │  │  ├─CPAN
    │  │  │  │  ├─Exception
    │  │  │  │  ├─FTP
    │  │  │  │  ├─HTTP
    │  │  │  │  ├─Kwalify
    │  │  │  │  ├─LWP
    │  │  │  │  ├─Meta
    │  │  │  │  └─Plugin
    │  │  │  ├─DBM_Filter
    │  │  │  ├─Devel
    │  │  │  ├─Digest
    │  │  │  ├─Encode
    │  │  │  ├─encoding
    │  │  │  ├─Exporter
    │  │  │  ├─ExtUtils
    │  │  │  │  ├─CBuilder
    │  │  │  │  │  └─Platform
    │  │  │  │  │      └─Windows
    │  │  │  │  ├─Command
    │  │  │  │  ├─Constant
    │  │  │  │  ├─Liblist
    │  │  │  │  ├─MakeMaker
    │  │  │  │  │  └─version
    │  │  │  │  ├─ParseXS
    │  │  │  │  └─Typemaps
    │  │  │  ├─File
    │  │  │  ├─Filter
    │  │  │  ├─Getopt
    │  │  │  ├─HTTP
    │  │  │  ├─I18N
    │  │  │  │  └─LangTags
    │  │  │  ├─IO
    │  │  │  │  ├─Compress
    │  │  │  │  │  ├─Adapter
    │  │  │  │  │  ├─Base
    │  │  │  │  │  ├─Gzip
    │  │  │  │  │  ├─Zip
    │  │  │  │  │  └─Zlib
    │  │  │  │  ├─Socket
    │  │  │  │  └─Uncompress
    │  │  │  │      └─Adapter
    │  │  │  ├─IPC
    │  │  │  ├─JSON
    │  │  │  │  └─PP
    │  │  │  ├─Locale
    │  │  │  │  ├─Codes
    │  │  │  │  └─Maketext
    │  │  │  ├─Math
    │  │  │  │  ├─BigFloat
    │  │  │  │  └─BigInt
    │  │  │  ├─Memoize
    │  │  │  ├─Module
    │  │  │  │  ├─CoreList
    │  │  │  │  └─Load
    │  │  │  ├─Net
    │  │  │  │  └─FTP
    │  │  │  ├─overload
    │  │  │  ├─Params
    │  │  │  ├─Parse
    │  │  │  │  └─CPAN
    │  │  │  ├─Perl
    │  │  │  ├─PerlIO
    │  │  │  │  └─via
    │  │  │  ├─Pod
    │  │  │  │  ├─Perldoc
    │  │  │  │  ├─Simple
    │  │  │  │  └─Text
    │  │  │  ├─Search
    │  │  │  ├─TAP
    │  │  │  │  ├─Formatter
    │  │  │  │  │  ├─Console
    │  │  │  │  │  └─File
    │  │  │  │  ├─Harness
    │  │  │  │  └─Parser
    │  │  │  │      ├─Iterator
    │  │  │  │      ├─Result
    │  │  │  │      ├─Scheduler
    │  │  │  │      ├─SourceHandler
    │  │  │  │      └─YAMLish
    │  │  │  ├─Term
    │  │  │  ├─Test
    │  │  │  │  ├─Builder
    │  │  │  │  │  ├─IO
    │  │  │  │  │  └─Tester
    │  │  │  │  ├─Tester
    │  │  │  │  └─use
    │  │  │  ├─Text
    │  │  │  ├─Thread
    │  │  │  ├─Tie
    │  │  │  ├─Time
    │  │  │  ├─Unicode
    │  │  │  │  └─Collate
    │  │  │  │      └─CJK
    │  │  │  ├─unicore
    │  │  │  │  ├─lib
    │  │  │  │  │  ├─Age
    │  │  │  │  │  ├─Alpha
    │  │  │  │  │  ├─Bc
    │  │  │  │  │  ├─BidiC
    │  │  │  │  │  ├─BidiM
    │  │  │  │  │  ├─Blk
    │  │  │  │  │  ├─Bpt
    │  │  │  │  │  ├─Cased
    │  │  │  │  │  ├─Ccc
    │  │  │  │  │  ├─CE
    │  │  │  │  │  ├─CI
    │  │  │  │  │  ├─CompEx
    │  │  │  │  │  ├─CWCF
    │  │  │  │  │  ├─CWCM
    │  │  │  │  │  ├─CWKCF
    │  │  │  │  │  ├─CWL
    │  │  │  │  │  ├─CWT
    │  │  │  │  │  ├─CWU
    │  │  │  │  │  ├─Dash
    │  │  │  │  │  ├─Dep
    │  │  │  │  │  ├─DI
    │  │  │  │  │  ├─Dia
    │  │  │  │  │  ├─Dt
    │  │  │  │  │  ├─Ea
    │  │  │  │  │  ├─Ext
    │  │  │  │  │  ├─Gc
    │  │  │  │  │  ├─GCB
    │  │  │  │  │  ├─GrBase
    │  │  │  │  │  ├─Hex
    │  │  │  │  │  ├─Hst
    │  │  │  │  │  ├─Hyphen
    │  │  │  │  │  ├─IDC
    │  │  │  │  │  ├─Ideo
    │  │  │  │  │  ├─IDS
    │  │  │  │  │  ├─In
    │  │  │  │  │  ├─Jg
    │  │  │  │  │  ├─Jt
    │  │  │  │  │  ├─Lb
    │  │  │  │  │  ├─LOE
    │  │  │  │  │  ├─Lower
    │  │  │  │  │  ├─Math
    │  │  │  │  │  ├─NChar
    │  │  │  │  │  ├─NFCQC
    │  │  │  │  │  ├─NFDQC
    │  │  │  │  │  ├─NFKCQC
    │  │  │  │  │  ├─NFKDQC
    │  │  │  │  │  ├─Nt
    │  │  │  │  │  ├─Nv
    │  │  │  │  │  ├─PatSyn
    │  │  │  │  │  ├─PatWS
    │  │  │  │  │  ├─Perl
    │  │  │  │  │  ├─QMark
    │  │  │  │  │  ├─SB
    │  │  │  │  │  ├─Sc
    │  │  │  │  │  ├─Scx
    │  │  │  │  │  ├─SD
    │  │  │  │  │  ├─STerm
    │  │  │  │  │  ├─Term
    │  │  │  │  │  ├─UIdeo
    │  │  │  │  │  ├─Upper
    │  │  │  │  │  ├─WB
    │  │  │  │  │  ├─XIDC
    │  │  │  │  │  └─XIDS
    │  │  │  │  └─To
    │  │  │  ├─User
    │  │  │  ├─version
    │  │  │  ├─warnings
    │  │  │  └─Win32API
    │  │  │      └─File
    │  │  └─vendor_perl
    │  │      ├─Authen
    │  │      │  └─SASL
    │  │      │      └─Perl
    │  │      ├─Convert
    │  │      ├─Date
    │  │      │  └─Language
    │  │      ├─Encode
    │  │      ├─Error
    │  │      ├─File
    │  │      ├─HTML
    │  │      ├─HTTP
    │  │      │  ├─Cookies
    │  │      │  ├─Headers
    │  │      │  └─Request
    │  │      ├─IO
    │  │      │  └─Socket
    │  │      │      └─SSL
    │  │      ├─LWP
    │  │      │  ├─Authen
    │  │      │  └─Protocol
    │  │      ├─Mail
    │  │      │  ├─Field
    │  │      │  └─Mailer
    │  │      ├─MIME
    │  │      │  ├─Decoder
    │  │      │  ├─Field
    │  │      │  └─Parser
    │  │      ├─Net
    │  │      │  ├─HTTP
    │  │      │  └─SMTP
    │  │      ├─Time
    │  │      ├─URI
    │  │      │  ├─file
    │  │      │  └─urn
    │  │      └─WWW
    │  │          └─RobotRules
    │  ├─pki
    │  │  └─ca-trust-source
    │  ├─tabset
    │  ├─terminfo
    │  │  ├─63
    │  │  ├─64
    │  │  └─78
    │  └─vim
    │      └─vim74
    │          ├─autoload
    │          │  └─xml
    │          ├─colors
    │          ├─compiler
    │          ├─doc
    │          ├─ftplugin
    │          ├─indent
    │          ├─keymap
    │          ├─macros
    │          │  ├─hanoi
    │          │  ├─life
    │          │  ├─maze
    │          │  └─urm
    │          ├─pack
    │          │  └─dist
    │          │      └─opt
    │          │          ├─dvorak
    │          │          │  ├─dvorak
    │          │          │  └─plugin
    │          │          ├─editexisting
    │          │          │  └─plugin
    │          │          ├─justify
    │          │          │  └─plugin
    │          │          ├─matchit
    │          │          │  ├─doc
    │          │          │  └─plugin
    │          │          ├─shellmenu
    │          │          │  └─plugin
    │          │          └─swapmouse
    │          │              └─plugin
    │          ├─plugin
    │          ├─print
    │          ├─spell
    │          ├─syntax
    │          ├─tools
    │          └─tutor
    └─ssl
        ├─certs
        └─misc
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看到熟悉的 &lt;code&gt;./etc/bash.bashrc&lt;/code&gt; 文件,顿时亲切不少,设置一下别名再说.&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;snowdreams1006@home MINGW64 /e/git
$ echo &quot;# Set alias for tree command&quot; &amp;gt;&amp;gt; ./etc/bash.bashrc
snowdreams1006@home MINGW64 /e/git
$ echo &quot;alias tree='winpty tree.com'&quot; &amp;gt;&amp;gt; ./etc/bash.bashrc
snowdreams1006@home MINGW64 /e/git
$ source ./etc/bash.bashrc&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在测试一下能否正确打印出目录树:&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;snowdreams1006@home MINGW64 /e/git
$ cd /g/sublime/test

snowdreams1006@home MINGW64 /g/sublime/test
$ tree
卷 工作 的文件夹 PATH 列表
卷序列号为 000000A3 CC3C:50D0
G:.
├─cmd
└─git&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;亲测有效,通过设置别名的方式可以简化命令,从而实现在 &lt;code&gt;git bash&lt;/code&gt; 中优雅调用 &lt;code&gt;tree&lt;/code&gt; 命令.&lt;/p&gt;
&lt;h3 id=&quot;固执少年一意孤行&quot;&gt;固执少年一意孤行&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;少年既然不听劝,那我只好和你一起一意孤行.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;git bash&lt;/code&gt; 不支持 &lt;code&gt;tree&lt;/code&gt; 命令,意味着 &lt;code&gt;mintty&lt;/code&gt; 终端不支持 &lt;code&gt;tree&lt;/code&gt; 命令,但 &lt;code&gt;mintty&lt;/code&gt; 既然作为一款优秀的终端模拟器不可能不支持 &lt;code&gt;tree&lt;/code&gt; 命令,否则 &lt;code&gt;cygwin&lt;/code&gt; ,&lt;code&gt;msys2&lt;/code&gt; 和 &lt;code&gt;mingw&lt;/code&gt; 等系统不可能将其作为默认终端.&lt;/p&gt;
&lt;p&gt;回想起 &lt;code&gt;linux&lt;/code&gt; 系统,最小化安装版也不支持 &lt;code&gt;tree&lt;/code&gt; 命令,通过包管理工具自行扩展即可支持 &lt;code&gt;tree&lt;/code&gt; 命令.&lt;/p&gt;
&lt;p&gt;因此,思路有两种,像 &lt;code&gt;linux&lt;/code&gt; 那样通过包管理工具安装 &lt;code&gt;tree&lt;/code&gt; 命令,或者通过源码编译方式扩展 &lt;code&gt;tree&lt;/code&gt; 命令.&lt;/p&gt;
&lt;p&gt;第一种需要包管理工具,而&lt;code&gt;git bash&lt;/code&gt; 使用的是 &lt;code&gt;mintty&lt;/code&gt; 终端,并没有提供相应的包管理工具.&lt;br/&gt;所以想要通过包管理工具进行安装 &lt;code&gt;tree&lt;/code&gt; 命令也是无路可走.&lt;/p&gt;
&lt;h4 id=&quot;包管理工具安装&quot;&gt;包管理工具安装&lt;/h4&gt;
&lt;p&gt;如果能够提供包管理工具,那么我们就可以像 &lt;code&gt;linux&lt;/code&gt; 系统那样安装第三方命令一样,安装 &lt;code&gt;tree&lt;/code&gt; 命令了.&lt;/p&gt;
&lt;p&gt;首先想到的是 &lt;code&gt;mintty&lt;/code&gt; 官网有没有相关说明,遗憾的是,&lt;code&gt;mintty&lt;/code&gt; 本身一般是通过包管理工具安装的,单独的终端并没有包管理的环境,因此无法调用相关命令.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-229f83ddb0f8dd6f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;git-bash-tree-winpty-github.png&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;Administrator@snowdreams1006 MINGW64 /f/workspace/test
$ mingw-get
bash: mingw-get: command not found

Administrator@snowdreams1006 MINGW64 /f/workspace/test
$ pacman
bash: pacman: command not found&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然而,小小的挫折是不会轻易放弃的,既然 &lt;code&gt;mintty&lt;/code&gt; 官网不能提供有效的帮助,那我们回到最初安装 &lt;code&gt;git&lt;/code&gt; 的地方,看一下 &lt;code&gt;git&lt;/code&gt; 能否提供相关的包管理工具.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-6d1de17b8175ec37.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;git-bash-tree-download-gitforwindows.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;频繁出现 &lt;code&gt;Git For Windows&lt;/code&gt; 名词,根据软件的命令规则,&lt;code&gt;Git for Windows&lt;/code&gt; 可能是独立的软件,更何况 &lt;code&gt;git bash&lt;/code&gt; 集成的终端也不是自身研发的终端而是第三方的 &lt;code&gt;mintty&lt;/code&gt; 终端.&lt;/p&gt;
&lt;p&gt;所以,我们有理由相信 &lt;code&gt;Git for Windows&lt;/code&gt; 是另外的团队在维护,而不是 &lt;code&gt;Git&lt;/code&gt; 团队.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-9b31c65beacd45b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;git-bash-tree-download-gitforwindows.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;2.4&quot;&gt;
&lt;p&gt;&lt;code&gt;git-for-windows&lt;/code&gt; 官网: &lt;a href=&quot;https://gitforwindows.org/&quot; class=&quot;uri&quot;&gt;https://gitforwindows.org/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-3d13501c1a67fa9c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;git-bash-tree-gitforwindows-build-extra.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;根据官方说明,安装后正在下载相关依赖,下载速度比较慢的话,请自行解决.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-f43c268c5c078132.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;git-bash-tree-gitforwindows-build-extra.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下载完成后,原来的 &lt;code&gt;cmd&lt;/code&gt; 窗口会自动关闭并且打开新的 &lt;code&gt;git bash&lt;/code&gt; 窗口.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-66e4db2af3abe7fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;git-bash-gitbash-install.png&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;Administrator@snowdreams1006 MINGW64 / (master)
$ sdk help
The 'sdk' shell function helps you to get up and running
with the Git for Windows SDK. The available subcommands are:

create-desktop-icon: install a desktop icon that starts the Git for
    Windows SDK Bash.

cd &amp;lt;project&amp;gt;: initialize/update a worktree and cd into it. Known projects:
        git git-extra msys2-runtime installer build-extra
        MINGW-packages MSYS2-packages mingw-w64-busybox mingw-w64-curl
        mingw-w64-cv2pdb mingw-w64-git mingw-w64-git-credential-manager
        mingw-w64-git-lfs mingw-w64-git-sizer mingw-w64-wintoast bash
        curl gawk git-flow gnupg heimdal mintty nodejs openssh openssl
        perl perl-HTML-Parser perl-Locale-Gettext perl-Net-SSLeay
        perl-TermReadKey perl-XML-Parser perl-YAML-Syck subversion tig

init &amp;lt;project&amp;gt;: initialize and/or update a worktree. Known projects
    are the same as for the 'cd' command.

build &amp;lt;project&amp;gt;: builds one of the following:
        git-and-installer git git-extra msys2-runtime installer
        mingw-w64-busybox mingw-w64-curl mingw-w64-cv2pdb mingw-w64-git
        mingw-w64-git-credential-manager mingw-w64-git-lfs
        mingw-w64-git-sizer mingw-w64-wintoast bash curl gawk
        git-flow gnupg heimdal mintty nodejs openssh openssl
        perl perl-HTML-Parser perl-Locale-Gettext perl-Net-SSLeay
        perl-TermReadKey perl-XML-Parser perl-YAML-Syck subversion tig

edit &amp;lt;file&amp;gt;: edit a well-known file. Well-known files are:
        git-sdk.sh sdk.completion ReleaseNotes.md install.iss

reload: reload the 'sdk' function.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在安装完成后,我们再次打开 &lt;code&gt;Git for Windows&lt;/code&gt; 的开发文档简介,从中不难发现该项目使用了 &lt;code&gt;MSYS2&lt;/code&gt; 项目,那么问题迎刃而解.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-101e40d5f45f0bf2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;git-bash-tree-gitforwindows-msys2.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;根据科普知识,我们知道 &lt;code&gt;MSYS2&lt;/code&gt; 和 &lt;code&gt;MinGW&lt;/code&gt; 都是操作系统,而 &lt;code&gt;Git For Windows&lt;/code&gt; 将两者结合在一起,默认使用 &lt;code&gt;MSYS2&lt;/code&gt; 的包管理工具.&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;Administrator@snowdreams1006 MINGW64 / (master)
$ Pacman -h
用法:  Pacman &amp;lt;操作&amp;gt; [...]
操作:
    Pacman {-h --help}
    Pacman {-V --version}
    Pacman {-D --database} &amp;lt;选项&amp;gt; &amp;lt;软件包&amp;gt;
    Pacman {-F --files}    [选项] [软件包]
    Pacman {-Q --query}    [选项] [软件包]
    Pacman {-R --remove}   [选项] &amp;lt;软件包&amp;gt;
    Pacman {-S --sync}     [选项] [软件包]
    Pacman {-T --deptest}  [选项] [软件包]
    Pacman {-U --upgrade}  [选项] &amp;lt;文件&amp;gt;

使用 'Pacman {-h --help}' 及某个操作以查看可用选项&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;激动人心的时刻就要来临,在正式使用 &lt;code&gt;Pacman&lt;/code&gt; 安装 &lt;code&gt;tree&lt;/code&gt; 命令外,我们再次检查当前系统环境以确保没有 &lt;code&gt;git bash&lt;/code&gt; 无法调用 &lt;code&gt;tree&lt;/code&gt; 命令.&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;Administrator@snowdreams1006 MINGW64 / (master)
$ tree
bash: tree: 未找到命令&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用 &lt;code&gt;Pacman -S tree&lt;/code&gt; 命令安装 &lt;code&gt;tree&lt;/code&gt; 命令.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Administrator@snowdreams1006 MINGW64 / (master)
$ Pacman -S tree
正在解析依赖关系...
正在查找软件包冲突...

软件包 (1) tree-1.8.0-1

下载大小:   0.05 MiB
全部安装大小：  0.07 MiB

:: 进行安装吗？ [Y/n] y
警告：没有 /var/cache/pacman/pkg/ 缓存存在，正在创建...
:: 正在获取软件包......
 tree-1.8.0-1-x86_64       51.1 KiB   211K/s 00:00 [#####################] 100%
(1/1) 正在检查密钥环里的密钥                       [#####################] 100%
(1/1) 正在检查软件包完整性                         [#####################] 100%
(1/1) 正在加载软件包文件                           [#####################] 100%
(1/1) 正在检查文件冲突                             [#####################] 100%
(1/1) 正在检查可用存储空间                         [#####################] 100%
:: 正在处理软件包的变化...
(1/1) 正在安装 tree      &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;验证安装成功,切换到测试目录调用 &lt;code&gt;tree&lt;/code&gt; 命令真的打印出了目录树结构.&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;Administrator@snowdreams1006 MINGW64 / (master)
$ pwd
/

Administrator@snowdreams1006 MINGW64 / (master)
$ cd /f/workspace/test

Administrator@snowdreams1006 MINGW64 /f/workspace/test
$ tree
.
├── cmd
└── gitbash

2 directories, 0 files&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;tree.exe&lt;/code&gt; 文件确实已经存在,通过这样方式当然可以安装任意第三方命令了呢!&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;Administrator@snowdreams1006 MINGW64 / (master)
$ pwd
/

Administrator@snowdreams1006 MINGW64 / (master)
$ ls usr/bin/tree.exe
usr/bin/tree.exe*

Administrator@snowdreams1006 MINGW64 / (master)
$ ls usr/bin/tree.exe
usr/bin/tree.exe*&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然而,事情还没有结束,虽然打印当前路径显示的是在 &lt;code&gt;/&lt;/code&gt; ,但是如果从普通的 &lt;code&gt;git bash&lt;/code&gt; 命令行窗口进入 &lt;code&gt;/&lt;/code&gt;,发现他们并不一致!&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-4967baee0513c8d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;git-bash-tree-gitbash-diff.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;开发版左上角文字: &lt;code&gt;SDK-64&lt;/code&gt;,普通版左上角: &lt;code&gt;MinGW64&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;事情应该不至于这么复杂,我猜测如果进入到 &lt;code&gt;git sdk&lt;/code&gt; 的安装目录,应该是一样的!&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-10783e2ec0fd5162.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;git-bash-tree-gitbash-in.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;源码编译安装&quot;&gt;源码编译安装&lt;/h4&gt;
&lt;p&gt;还有一种源码编译安装方式,可以猜想到的是将会比较麻烦,不仅要安装 &lt;code&gt;c&lt;/code&gt; 编译环境,还可能会面临如何移植到 &lt;code&gt;Windows&lt;/code&gt; 环境的问题.&lt;/p&gt;
&lt;p&gt;恕再下先行一步,告辞!&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-fc2453c081bdc8ef.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;git-bash-tree-bye.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是老司机怎么能收走就走,不是说好一起闯天下得嘛?&lt;/p&gt;
&lt;p&gt;然而,心有余而力不足,编译安装再到测试确实是不少挑战,最重要的是,电脑太卡了等不了.&lt;/p&gt;
&lt;p&gt;所以,收集到了一些资料方便有条件的小伙伴去研究吧!&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-2b288f27fd221ac5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;git-bash-tree-homepage.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;1.1111111111111&quot;&gt;
&lt;p&gt;下载链接: &lt;a href=&quot;ftp://mama.indstate.edu/linux/tree/tree-1.8.0.tgz&quot; class=&quot;uri&quot;&gt;ftp://mama.indstate.edu/linux/tree/tree-1.8.0.tgz&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;在 &lt;code&gt;mingw&lt;/code&gt; ,&lt;code&gt;msys2&lt;/code&gt; 或者 &lt;code&gt;cygwin&lt;/code&gt; 系统上编译安装 &lt;code&gt;tree&lt;/code&gt; 的 &lt;code&gt;c&lt;/code&gt; 文件,最终生成 &lt;code&gt;tree.exe&lt;/code&gt; 可执行文件.&lt;/li&gt;
&lt;li&gt;独立安装 &lt;code&gt;c&lt;/code&gt; 编译环境,生成的 &lt;code&gt;tree.exe&lt;/code&gt; 可执行文件再想办法兼容到 &lt;code&gt;git bash&lt;/code&gt; 所支持的 &lt;code&gt;.exe&lt;/code&gt; 类型,或许也不用转换.&lt;/li&gt;
&lt;li&gt;请参考 &lt;code&gt;linux&lt;/code&gt; 系统的 &lt;code&gt;tree&lt;/code&gt; 命令源码: &lt;a href=&quot;http://mama.indstate.edu/users/ice/tree/&quot; class=&quot;uri&quot;&gt;http://mama.indstate.edu/users/ice/tree/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我觉得我还可以再坚持一会,虽然不能从头开始编译生成 &lt;code&gt;tree.exe&lt;/code&gt; 可执行文件,但是研究了这么多朋友圈关系,足够我找到解决方案了.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;tree&lt;/code&gt; 命令的源码文件编译成 &lt;code&gt;tree.exe&lt;/code&gt; 可执行文件比较费劲,但是可以找到已经编译好的文件啊.&lt;/p&gt;
&lt;p&gt;说道这里,不得不提一下神奇的 &lt;a href=&quot;https://sourceforge.net/&quot;&gt;sourceforge&lt;/a&gt; 网站,提供源码和下载网站.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-4a82f529ad6889d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;git-bash-tree-sourceforge-homepage.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;前面我们一直在说 &lt;code&gt;mintty&lt;/code&gt; 终端模拟器也好,或者 &lt;code&gt;mingw&lt;/code&gt; ,&lt;code&gt;msys2&lt;/code&gt; 和 &lt;code&gt;cygwin&lt;/code&gt; 操作系统也罢,他们或多或少和 &lt;code&gt;GNU&lt;/code&gt; 有一些联系,而 &lt;code&gt;GNU&lt;/code&gt; 是自由软件操作系统,源码会随程序一同发布.&lt;/p&gt;
&lt;p&gt;所以我们应该可以从 &lt;code&gt;sourceforge&lt;/code&gt; 网站上找到些蛛丝马迹,说不定还有打包好的可执行文件呢,如果那样的话就不用我们手动编译安装了!&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-c1f4d075bb8a5c0e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;git-bash-tree-sourceforge-search.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;功夫不负有心人,竟然真的找到了,搜索 &lt;code&gt;GNU&lt;/code&gt; 发现了 &lt;code&gt;gnuwin32&lt;/code&gt; 项目,完整提供了原生命令,其中就有我们需要的 &lt;code&gt;tree&lt;/code&gt; 命令.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-f41d7726ee069c45.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;git-bash-tree-sourceforge-search.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;0.80769230769231&quot;&gt;
&lt;p&gt;下载链接: &lt;a href=&quot;https://sourceforge.net/projects/gnuwin32/files/tree/1.5.2.2/tree-1.5.2.2-bin.zip/download&quot; class=&quot;uri&quot;&gt;https://sourceforge.net/projects/gnuwin32/files/tree/1.5.2.2/tree-1.5.2.2-bin.zip/download&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;于是下载二进制文件找到其中的 &lt;code&gt;/bin/tree.exe&lt;/code&gt; 并将其复制到 &lt;code&gt;/git/usr/bin&lt;/code&gt; 目录下,这样 &lt;code&gt;git bash&lt;/code&gt; 本身就支持 &lt;code&gt;tree&lt;/code&gt; 命令了.&lt;/p&gt;
&lt;p&gt;首先清除掉上一步设置的别名,防止干扰以确保此二进制文件真实有效.&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;snowdreams1006@home MINGW64 /g/sublime/test
# 切换到 `git` 安装目录
$ cd /e/git

snowdreams1006@home MINGW64 /e/git
# 编辑 `bash.bashrc` 配置文件,移除别名
$ vim ./etc/bash.bashrc

snowdreams1006@home MINGW64 /e/git
# 查看配置文件内容,别名设置已移除
$ tail ./etc/bash.bashrc
[[ &quot;$-&quot; != *i* ]] &amp;amp;&amp;amp; return

# Set a default prompt of: user@host, MSYSTEM variable, and current_directory
#PS1='\[\e]0;\w\a\]\n\[\e[32m\]\u@\h \[\e[35m\]$MSYSTEM\[\e[0m\] \[\e[33m\]\w\[\e[0m\]\n\$ '

# Uncomment to use the terminal colours set in DIR_COLORS
# eval &quot;$(dircolors -b /etc/DIR_COLORS)&quot;

# Fixup git-bash in non login env
shopt -q login_shell || . /etc/profile.d/git-prompt.sh

snowdreams1006@home MINGW64 /e/git
# 刷新配置文件,使其立即生效
$ source ./etc/bash.bashrc

snowdreams1006@home MINGW64 /e/git
# 移除 `tree` 别名,适用于命令行方式设置而不是文件设置
$ unalias tree

snowdreams1006@home MINGW64 /e/git
# 运行 `tree` 命令,确保已经无法通过别名方式调用系统的 `tree.com` 命令
$ tree
bash: tree: command not found&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-60ca555c0aa568e9.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;git-bash-tree-bin.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;真的成功添加了 &lt;code&gt;tree.exe&lt;/code&gt; 命令,明显和 &lt;code&gt;cmd&lt;/code&gt; 自带的 &lt;code&gt;tree.com&lt;/code&gt; 命令不一致.&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;snowdreams1006@home MINGW64 /e/git
$ cd /g/sublime/test

snowdreams1006@home MINGW64 /g/sublime/test
# 扩展命令 `tree` 帮助信息
$ tree.exe --help
usage: tree [-adfghilnpqrstuvxACDFNS] [-H baseHREF] [-T title ] [-L level [-R]]
        [-P pattern] [-I pattern] [-o filename] [--version] [--help] [--inodes]
        [--device] [--noreport] [--nolinks] [--dirsfirst] [--charset charset]
        [--filelimit #] [&amp;lt;directory list&amp;gt;]
  -a            All files are listed.
  -d            List directories only.
  -l            Follow symbolic links like directories.
  -f            Print the full path prefix for each file.
  -i            Don't print indentation lines.
  -q            Print non-printable characters as '?'.
  -N            Print non-printable characters as is.
  -p            Print the protections for each file.
  -u            Displays file owner or UID number.
  -g            Displays file group owner or GID number.
  -s            Print the size in bytes of each file.
  -h            Print the size in a more human readable way.
  -D            Print the date of last modification.
  -F            Appends '/', '=', '*', or '|' as per ls -F.
  -v            Sort files alphanumerically by version.
  -r            Sort files in reverse alphanumeric order.
  -t            Sort files by last modification time.
  -x            Stay on current filesystem only.
  -L level      Descend only level directories deep.
  -A            Print ANSI lines graphic indentation lines.
  -S            Print with ASCII graphics indentation lines.
  -n            Turn colorization off always (-C overrides).
  -C            Turn colorization on always.
  -P pattern    List only those files that match the pattern given.
  -I pattern    Do not list files that match the given pattern.
  -H baseHREF   Prints out HTML format with baseHREF as top directory.
  -T string     Replace the default HTML title and H1 header with string.
  -R            Rerun tree when max dir level reached.
  -o file       Output to file instead of stdout.
  --inodes      Print inode number of each file.
  --device      Print device ID number to which each file belongs.
  --noreport    Turn off file/directory count at end of tree listing.
  --nolinks     Turn off hyperlinks in HTML output.
  --dirsfirst   List directories before files.
  --charset X   Use charset X for HTML and indentation line output.
  --filelimit # Do not descend dirs with more than # files in them.

snowdreams1006@home MINGW64 /g/sublime/test
# 原生 `tree.com` 帮助信息
$ winpty tree.com /?
卷 软件 的文件夹 PATH 列表
卷序列号为 000000CA 223E:7300
E:\GIT\?
无效的路径 - \GIT\?
没有子文件夹  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;虽然原生 &lt;code&gt;cmd&lt;/code&gt; 自带的 &lt;code&gt;tree.com&lt;/code&gt; 命令也能打印出目录结构树,但是和扩展的第三方 &lt;code&gt;tree.exe&lt;/code&gt; 命令相比,可配置的选项实在太少,难怪固执少年会执意扩展 &lt;code&gt;tree&lt;/code&gt; 命令.&lt;/p&gt;
&lt;h2 id=&quot;懒人直达&quot;&gt;懒人直达&lt;/h2&gt;
&lt;p&gt;如果想要在 &lt;code&gt;git bash&lt;/code&gt; 命令行中调用 &lt;code&gt;tree&lt;/code&gt; 命令,总结了下列几种方法.&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意: 从上到下逐渐复杂,根据自己的情况自行选择.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;winpty tree.com&lt;/code&gt; : 直接调用 &lt;code&gt;cmd&lt;/code&gt; 内置 &lt;code&gt;tree.com&lt;/code&gt; 命令.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;winpty cmd //c tree&lt;/code&gt; : 通知 &lt;code&gt;cmd&lt;/code&gt; 调用 &lt;code&gt;tree&lt;/code&gt; 命令.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/git-for-windows/build-extra/releases/download/git-sdk-1.0.7/git-sdk-installer-1.0.7-64.7z.exe&quot;&gt;安装&lt;/a&gt; &lt;code&gt;Git For Windows&lt;/code&gt; 开发版,&lt;code&gt;Pacman -S tree&lt;/code&gt; 安装 &lt;code&gt;tree&lt;/code&gt; 命令,然后执行 &lt;code&gt;tree&lt;/code&gt; 调用.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://sourceforge.net/projects/gnuwin32/files/tree/1.5.2.2/tree-1.5.2.2-bin.zip/download&quot;&gt;下载&lt;/a&gt; 已编译好的 &lt;code&gt;tree.exe&lt;/code&gt; 文件到 &lt;code&gt;git bash&lt;/code&gt; 安装目录下的 &lt;code&gt;/usr/bin&lt;/code&gt; 目录,然后执行 &lt;code&gt;tree&lt;/code&gt; 命令.&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;回顾总结&quot;&gt;回顾总结&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Git&lt;/code&gt; 本身并不支持 &lt;code&gt;Windows&lt;/code&gt; 系统,&lt;code&gt;Git For Windows&lt;/code&gt; 团队为了移植到 &lt;code&gt;Windows&lt;/code&gt; 平台,付出了很多努力,最直观的感受就是提供了 &lt;code&gt;Git For Windows&lt;/code&gt; 软件.&lt;/p&gt;
&lt;p&gt;由于 &lt;code&gt;Git for Windows&lt;/code&gt; 的出色工作得到 &lt;code&gt;Git&lt;/code&gt; 的官方认可,现在默认下载的 &lt;code&gt;Git&lt;/code&gt; 就是来源于 &lt;code&gt;Git for Windows&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;但 &lt;code&gt;Git&lt;/code&gt; 底层是运行在类 &lt;code&gt;linux&lt;/code&gt; 系统的,这种差异必然需要 &lt;code&gt;Windows&lt;/code&gt; 到 &lt;code&gt;Linux&lt;/code&gt; 的中间处理层进行转换.&lt;/p&gt;
&lt;p&gt;因此,&lt;code&gt;Git for Window&lt;/code&gt; 背后的技术中涉及到大量的 &lt;code&gt;GNU&lt;/code&gt; 自由软件操作系统和 &lt;code&gt;WSL&lt;/code&gt; (&lt;code&gt;Windows Subsystem for Linux&lt;/code&gt;) 的相关代码.&lt;/p&gt;
&lt;p&gt;正是由于背后千丝万缕的联系,为我们扩展 &lt;code&gt;git bash&lt;/code&gt; 命令行提供了一些思路.&lt;/p&gt;
&lt;p&gt;基于 &lt;code&gt;Cygwin&lt;/code&gt; 系统进行扩展,安装完整的操作系统,模拟出 &lt;code&gt;linux&lt;/code&gt; 运行环境,在 &lt;code&gt;Windows&lt;/code&gt; 上也能找到 &lt;code&gt;linux&lt;/code&gt; 的感觉.&lt;/p&gt;
&lt;p&gt;当然,&lt;code&gt;Cygwin&lt;/code&gt; 由于比较完整,体积也相当大,所以在此衍生出 &lt;code&gt;MSYS2&lt;/code&gt; 和 &lt;code&gt;MinGW&lt;/code&gt; 操作系统.&lt;/p&gt;
&lt;p&gt;殊途同归,他们的底层架构有些不同,但目的是一致的,都是在 &lt;code&gt;Windows&lt;/code&gt; 上找到 &lt;code&gt;Linux&lt;/code&gt; 的感觉,并且他们的终端命令行几乎都是 &lt;code&gt;mintty&lt;/code&gt; .&lt;/p&gt;
&lt;p&gt;在终端中调用各自的包管理工具即可轻松扩展第三方命令,此外,由于他们大多数都有 &lt;code&gt;c&lt;/code&gt; 编译环境,因此也可以选择重新编译安装.&lt;/p&gt;
&lt;p&gt;所以 &lt;code&gt;git bash&lt;/code&gt; 命令行看起来下像是 &lt;code&gt;git&lt;/code&gt; 官方支持,其实却是由 &lt;code&gt;Git for Windows&lt;/code&gt; 组织独立维护的开源项目.&lt;/p&gt;
&lt;p&gt;默认 &lt;code&gt;Git for Windows&lt;/code&gt; 没有提供包管理工具,开发版却默认集成了 &lt;code&gt;MSYS2&lt;/code&gt; 环境.也就是说我们可以用 &lt;code&gt;Pacman&lt;/code&gt; 来安装 &lt;code&gt;tree&lt;/code&gt; 命令.&lt;/p&gt;
&lt;p&gt;最后稍微总结本文知识要点:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;git bash&lt;/code&gt; 命令行并不能完全替代 &lt;code&gt;cmd&lt;/code&gt; 命令,两者互补才能相得益彰.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git bash&lt;/code&gt; 命令行中调用 &lt;code&gt;cmd&lt;/code&gt; 程序需要通过 &lt;code&gt;winpty&lt;/code&gt; 调用,比如 &lt;code&gt;winpty tree.com&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git bash&lt;/code&gt; 默认安装程序无包管理工具等高级功能,如需扩展自定义命令应该下载&lt;code&gt;Git for Windows SDK&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git bash&lt;/code&gt; 环境兼容 &lt;code&gt;MSYS2&lt;/code&gt; ,&lt;code&gt;MinGW&lt;/code&gt; ,&lt;code&gt;Cygwin&lt;/code&gt; 等系列自由软件,其他类似系统的 &lt;code&gt;tree.exe&lt;/code&gt; 可能并不支持.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;好了,说了这么多,小伙伴们 get 到如何在 &lt;code&gt;git bash&lt;/code&gt; 使用(扩展) &lt;code&gt;tree&lt;/code&gt; 命令了吗?&lt;/p&gt;
&lt;p&gt;如有疑问,欢迎留言告诉我!&lt;/p&gt;
</description>
<pubDate>Sun, 05 May 2019 06:28:00 +0000</pubDate>
<dc:creator>雪之梦技术驿站</dc:creator>
<og:description>开门见山 是 用户安装 时默认安装的命令行工具,不仅界面漂亮功能也不错,大多数情况下可以替代 原生的 命令行. 然而, 命令行不是万金油,并不能完全替代 ,详情请参考 官网的 '相关说明' . min</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/snowdreams1006/p/10812861.html</dc:identifier>
</item>
<item>
<title>基于STM32之UART串口通信协议（二）发送 - LLLIN000</title>
<link>http://www.cnblogs.com/ChurF-Lin/p/10798193.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ChurF-Lin/p/10798193.html</guid>
<description>&lt;h2&gt;1、简介&lt;/h2&gt;
&lt;p&gt;　　在上一篇&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/ChurF-Lin/p/10793111.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;UART详解&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;中，已经有了关于UART的详细介绍了，也有关于如何使用STM32CubeMX来配置UART的操作了，而在该篇博客，主要会讲解一下如何实现UART串口的发送功能。&lt;/p&gt;
&lt;h2&gt;2、UART简介&lt;/h2&gt;
&lt;p&gt;　　嵌入式开发中，UART串口通信协议是我们常用的通信协议之一，全称叫做通用异步收发传输器（Universal Asynchronous Receiver/Transmitter）。&lt;/p&gt;
&lt;h2&gt;3、准备工作&lt;/h2&gt;
&lt;p&gt;　　在&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/ChurF-Lin/p/10793111.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;UART详解&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;中已经有了详细的说明，在这里就不说明了。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;h3&gt;注：&lt;/h3&gt;
&lt;p&gt;　　建议每次编写好一个相关功能且测试功能成功使用后，保存并压缩成一份Demo例程，方便日后有需要的时候可以直接使用。&lt;/p&gt;
&lt;p&gt;　　例如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1545553/201905/1545553-20190504194858976-1632526241.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;


&lt;blockquote readability=&quot;7.9772727272727&quot;&gt;
&lt;h3&gt;&lt;strong&gt;说明：&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;这篇用到的配置跟&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/ChurF-Lin/p/10793111.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;UART详解&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;里的配置都相同，可以按照&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/ChurF-Lin/p/10793111.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;UART详解&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;来配置好时钟、UART即可。&lt;/p&gt;
&lt;p&gt;　　所以在进行下一步之前，先确保已经按照&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/ChurF-Lin/p/10793111.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;UART详解&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;的配置步骤配置好了，然后再进行后面的操作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;1、CubeMx配置&lt;/h2&gt;
&lt;p&gt;　　按照上一篇&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/ChurF-Lin/p/10793111.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;UART详解&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;来配置&lt;/p&gt;
&lt;h2&gt;2、函数说明&lt;/h2&gt;
&lt;h3&gt;1）CubeMX生成的UART初始化（在usart.c中）&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('facf003f-3254-42c4-b08c-8405454598c4')&quot; readability=&quot;33.5&quot;&gt;&lt;span&gt;　　&lt;img id=&quot;code_img_closed_facf003f-3254-42c4-b08c-8405454598c4&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_facf003f-3254-42c4-b08c-8405454598c4&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('facf003f-3254-42c4-b08c-8405454598c4',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;
&lt;div id=&quot;cnblogs_code_open_facf003f-3254-42c4-b08c-8405454598c4&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1 UART_HandleTypeDef huart1;
 2 
 3 /* USART1 init function */
 4 
 5 void MX_USART1_UART_Init(void)
 6 {
 7 
 8   huart1.Instance = USART1;
 9   huart1.Init.BaudRate = 115200;
10   huart1.Init.WordLength = UART_WORDLENGTH_8B;
11   huart1.Init.StopBits = UART_STOPBITS_1;
12   huart1.Init.Parity = UART_PARITY_NONE;
13   huart1.Init.Mode = UART_MODE_TX_RX;
14   huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
15   huart1.Init.OverSampling = UART_OVERSAMPLING_16;
16   if (HAL_UART_Init(&amp;amp;huart1) != HAL_OK)
17   {
18     Error_Handler();
19   }
20 
21 }
22 
23 void HAL_UART_MspInit(UART_HandleTypeDef* uartHandle)
24 {
25 
26   GPIO_InitTypeDef GPIO_InitStruct = {0};
27   if(uartHandle-&amp;gt;Instance==USART1)
28   {
29   /* USER CODE BEGIN USART1_MspInit 0 */
30 
31   /* USER CODE END USART1_MspInit 0 */
32     /* USART1 clock enable */
33     __HAL_RCC_USART1_CLK_ENABLE();
34   
35     __HAL_RCC_GPIOA_CLK_ENABLE();
36     /**USART1 GPIO Configuration    
37     PA9     ------&amp;gt; USART1_TX
38     PA10     ------&amp;gt; USART1_RX 
39     */
40     GPIO_InitStruct.Pin = GPIO_PIN_9|GPIO_PIN_10;
41     GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
42     GPIO_InitStruct.Pull = GPIO_PULLUP;
43     GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
44     GPIO_InitStruct.Alternate = GPIO_AF7_USART1;
45     HAL_GPIO_Init(GPIOA, &amp;amp;GPIO_InitStruct);
46 
47   /* USER CODE BEGIN USART1_MspInit 1 */
48 
49   /* USER CODE END USART1_MspInit 1 */
50   }
51 }
52 
53 void HAL_UART_MspDeInit(UART_HandleTypeDef* uartHandle)
54 {
55 
56   if(uartHandle-&amp;gt;Instance==USART1)
57   {
58   /* USER CODE BEGIN USART1_MspDeInit 0 */
59 
60   /* USER CODE END USART1_MspDeInit 0 */
61     /* Peripheral clock disable */
62     __HAL_RCC_USART1_CLK_DISABLE();
63   
64     /**USART1 GPIO Configuration    
65     PA9     ------&amp;gt; USART1_TX
66     PA10     ------&amp;gt; USART1_RX 
67     */
68     HAL_GPIO_DeInit(GPIOA, GPIO_PIN_9|GPIO_PIN_10);
69 
70   /* USER CODE BEGIN USART1_MspDeInit 1 */
71 
72   /* USER CODE END USART1_MspDeInit 1 */
73   }
74 } &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;USART init&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;2）HAL库函数HAL_UART_Transmit（在stm32f4xx_hal_uart.c中）&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;h3&gt;&lt;strong&gt;说明：&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　该函数能够通过huart串口发送Size位pData数据。&lt;/p&gt;
&lt;h3&gt;参数说明：&lt;/h3&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;huart    ：选择用来发送的UART串口&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;pData   ：指向将要发送的数据的指针&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Size      ：发送数据的大小&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Timeout：超时时间&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('3525e861-cbb2-432f-9a44-76aa2e158503')&quot; readability=&quot;40.5&quot;&gt;&lt;span&gt;　　&lt;img id=&quot;code_img_closed_3525e861-cbb2-432f-9a44-76aa2e158503&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_3525e861-cbb2-432f-9a44-76aa2e158503&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('3525e861-cbb2-432f-9a44-76aa2e158503',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;
&lt;div id=&quot;cnblogs_code_open_3525e861-cbb2-432f-9a44-76aa2e158503&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;76&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1 /**
 2   * @brief  Sends an amount of data in blocking mode.
 3   * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
 4   *                the configuration information for the specified UART module.
 5   * @param  pData Pointer to data buffer
 6   * @param  Size Amount of data to be sent
 7   * @param  Timeout Timeout duration
 8   * @retval HAL status
 9   */
10 HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
11 {
12   uint16_t *tmp;
13   uint32_t tickstart = 0U;
14 
15   /* Check that a Tx process is not already ongoing */
16   if (huart-&amp;gt;gState == HAL_UART_STATE_READY)
17   {
18     if ((pData == NULL) || (Size == 0U))
19     {
20       return  HAL_ERROR;
21     }
22 
23     /* Process Locked */
24     __HAL_LOCK(huart);
25 
26     huart-&amp;gt;ErrorCode = HAL_UART_ERROR_NONE;
27     huart-&amp;gt;gState = HAL_UART_STATE_BUSY_TX;
28 
29     /* Init tickstart for timeout managment */
30     tickstart = HAL_GetTick();
31 
32     huart-&amp;gt;TxXferSize = Size;
33     huart-&amp;gt;TxXferCount = Size;
34     while (huart-&amp;gt;TxXferCount &amp;gt; 0U)
35     {
36       huart-&amp;gt;TxXferCount--;
37       if (huart-&amp;gt;Init.WordLength == UART_WORDLENGTH_9B)
38       {
39         if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
40         {
41           return HAL_TIMEOUT;
42         }
43         tmp = (uint16_t *) pData;
44         huart-&amp;gt;Instance-&amp;gt;DR = (*tmp &amp;amp; (uint16_t)0x01FF);
45         if (huart-&amp;gt;Init.Parity == UART_PARITY_NONE)
46         {
47           pData += 2U;
48         }
49         else
50         {
51           pData += 1U;
52         }
53       }
54       else
55       {
56         if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
57         {
58           return HAL_TIMEOUT;
59         }
60         huart-&amp;gt;Instance-&amp;gt;DR = (*pData++ &amp;amp; (uint8_t)0xFF);
61       }
62     }
63 
64     if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
65     {
66       return HAL_TIMEOUT;
67     }
68 
69     /* At end of Tx process, restore huart-&amp;gt;gState to Ready */
70     huart-&amp;gt;gState = HAL_UART_STATE_READY;
71 
72     /* Process Unlocked */
73     __HAL_UNLOCK(huart);
74 
75     return HAL_OK;
76   }
77   else
78   {
79     return HAL_BUSY;
80   }
81 }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;HAL_UART_Transmit&lt;/span&gt;&lt;/div&gt;


&lt;h2&gt;1、直接发送&lt;/h2&gt;
&lt;h3&gt;1）在main主函数中定义一个数组&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; USER CODE BEGIN 1 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;     unsigned &lt;span&gt;char&lt;/span&gt; uTx_Data[&lt;span&gt;5&lt;/span&gt;] = {&lt;span&gt;0x41&lt;/span&gt;, &lt;span&gt;0x42&lt;/span&gt;, &lt;span&gt;0x43&lt;/span&gt;, &lt;span&gt;0x44&lt;/span&gt;, &lt;span&gt;0x45&lt;/span&gt;};    &lt;span&gt;//数组内十六进制代表“&lt;/span&gt;&lt;span&gt;ABCDE”&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; USER CODE END 1 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2）在main主函数中的while循环中调用HAL库UART发送函数&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Infinite loop &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; USER CODE BEGIN WHILE &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
  &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
  {
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; UART发送 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
      HAL_UART_Transmit(&lt;/span&gt;&amp;amp;huart1, uTx_Data, &lt;span&gt;sizeof&lt;/span&gt;(uTx_Data), &lt;span&gt;0xffff&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 延迟1s &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        HAL_Delay(&lt;/span&gt;&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; USER CODE END WHILE &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; USER CODE BEGIN 3 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  }
  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; USER CODE END 3 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;整个main函数如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; USER CODE BEGIN 1 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     unsigned &lt;span&gt;char&lt;/span&gt; uTx_Data[&lt;span&gt;5&lt;/span&gt;] = {&lt;span&gt;0x41&lt;/span&gt;, &lt;span&gt;0x42&lt;/span&gt;, &lt;span&gt;0x43&lt;/span&gt;, &lt;span&gt;0x44&lt;/span&gt;, &lt;span&gt;0x45&lt;/span&gt;};    &lt;span&gt;//数组内十六进制代表“&lt;/span&gt;&lt;span&gt;ABCDE”&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; USER CODE END 1 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;   
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; MCU Configuration--------------------------------------------------------&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Reset of all peripherals, Initializes the Flash interface and the Systick. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;  HAL_Init();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; USER CODE BEGIN Init &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; USER CODE END Init &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Configure the system clock &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;  SystemClock_Config();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; USER CODE BEGIN SysInit &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; USER CODE END SysInit &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Initialize all configured peripherals &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;  MX_GPIO_Init();
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;  MX_USART1_UART_Init();
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; USER CODE BEGIN 2 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt;   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; USER CODE END 2 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt;   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Infinite loop &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; USER CODE BEGIN WHILE &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;   &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;  {
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; UART发送 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;       HAL_UART_Transmit(&amp;amp;huart1, uTx_Data, &lt;span&gt;sizeof&lt;/span&gt;(uTx_Data), &lt;span&gt;0xffff&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 延迟1s &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;         HAL_Delay(&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; USER CODE END WHILE &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt; 
&lt;span&gt;41&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; USER CODE BEGIN 3 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; USER CODE END 3 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3）编译、下载烧写&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1545553/201905/1545553-20190504151731374-2096019658.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;4）实现效果（在PC端串口助手中显示发送成功）&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1545553/201905/1545553-20190504131625498-497093576.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;2、字符串发送&lt;/h2&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;h3&gt;说明：&lt;/h3&gt;
&lt;p&gt;　　前面的发送方式，不仅要传入句柄参数，还有数组、长度、超时时间参数。&lt;/p&gt;
&lt;p&gt;　　为了简便发送，我们可以专门写一个字符串发送函数，可以直接传入一个数组即可发送，可以更简便地实现字符串发送。&lt;/p&gt;
&lt;p&gt;　　优点是，发送数据更简便，能够一次性发送很长的数据数组。&lt;/p&gt;
&lt;p&gt;　　但缺点就是不能控制发送的长度，会将整个数据数组发出。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;1）在Uart.c中添加vUser_UART_SendString函数&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; USER CODE BEGIN 1 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; vUser_UART_SendString(UART_HandleTypeDef* uartHandle, unsigned &lt;span&gt;char&lt;/span&gt; *&lt;span&gt; uData)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; -1- 判断数据是否发送完毕 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(*uData)        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;若为空即发送完毕，若不为空则还有数据&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; -2- 发送1Byte &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;         HAL_UART_Transmit(uartHandle, uData, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;0xffff&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; -3- 移至下1Byte &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         uData++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; USER CODE END 1 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2）在Uart.h中声明一下vUser_UART_SendString函数（声明后就可以在别的地方调用该函数）&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; USER CODE BEGIN Prototypes &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;extern&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; vUser_UART_SendString(UART_HandleTypeDef* uartHandle, unsigned &lt;span&gt;char&lt;/span&gt; *&lt;span&gt; uData);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; USER CODE END Prototypes &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3）在main主函数中定义一个数组&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; USER CODE BEGIN 1 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;     unsigned &lt;span&gt;char&lt;/span&gt; uTx_Data[] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n Hallo World！ 你好，世界！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; USER CODE END 1 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;4）在main主函数的while循环中调用字符串发送函数&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Infinite loop &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; USER CODE BEGIN WHILE &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;   &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;  {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 字符串发送 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;       vUser_UART_SendString(&amp;amp;&lt;span&gt;huart1, uTx_Data);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 延迟1s &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;         HAL_Delay(&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; USER CODE END WHILE &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; USER CODE BEGIN 3 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; USER CODE END 3 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;整个main函数如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; USER CODE BEGIN 1 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     unsigned &lt;span&gt;char&lt;/span&gt; uTx_Data[] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n Hallo World！ 你好，世界！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; USER CODE END 1 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;   
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; MCU Configuration--------------------------------------------------------&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Reset of all peripherals, Initializes the Flash interface and the Systick. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;  HAL_Init();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; USER CODE BEGIN Init &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; USER CODE END Init &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Configure the system clock &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;  SystemClock_Config();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; USER CODE BEGIN SysInit &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; USER CODE END SysInit &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Initialize all configured peripherals &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;  MX_GPIO_Init();
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;  MX_USART1_UART_Init();
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; USER CODE BEGIN 2 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt;   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; USER CODE END 2 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt;   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Infinite loop &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; USER CODE BEGIN WHILE &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;   &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;  {
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; UART发送 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;       vUser_UART_SendString(&amp;amp;&lt;span&gt;huart1, uTx_Data);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 延迟1s &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;         HAL_Delay(&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; USER CODE END WHILE &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt; 
&lt;span&gt;41&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; USER CODE BEGIN 3 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; USER CODE END 3 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;5）编译、下载烧写&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1545553/201905/1545553-20190504151713884-129590728.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;6）实现效果（在PC端串口助手显示发送成功）&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1545553/201905/1545553-20190504142702188-754784395.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;3、printf发送&lt;/h2&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;h3&gt;说明：&lt;/h3&gt;
&lt;p&gt;　　这种发送方式就是相当于编写c语言的时候，在小黑框中打印自己想要打印的东西，我们也可以在串口助手上实现一样的功能。&lt;/p&gt;
&lt;p&gt;　　由于篇幅长度有限，可能需要后续有空再补上这一发送方式，在这里先不讲解了。&lt;/p&gt;
&lt;/blockquote&gt;


&lt;h2&gt;1、总结&lt;/h2&gt;
&lt;p&gt;　　这篇博客主要是以上一篇&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/ChurF-Lin/p/10793111.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;UART详解&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;为基础，来实现使用UART来实现发送功能，在这里简单讲解了两种发送方式，而在后续如果有机会还会补上第三种printf发送方式的。&lt;/p&gt;
&lt;p&gt;　　如果大家还不清楚UART串口通信协议的，可以阅读一下上一篇&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/ChurF-Lin/p/10793111.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;UART详解&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。若还有对于此篇博客不懂之处，可在下方留言评论，我会尽快回复。&lt;/p&gt;
&lt;h2&gt;2、回顾&lt;/h2&gt;
&lt;h2&gt;3、后续&lt;/h2&gt;
&lt;p&gt;~&lt;/p&gt;
&lt;p&gt;~&lt;/p&gt;
&lt;p&gt;~&lt;/p&gt;
&lt;p&gt;~&lt;/p&gt;
&lt;p&gt;&lt;span&gt;感谢阅读～&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 欢迎大家关注&lt;span&gt;&lt;a title=&quot;木木_Lin的博客&quot; href=&quot;https://www.cnblogs.com/ChurF-Lin/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;我的博客&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;，一起分享嵌入式知识～&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 05 May 2019 06:23:00 +0000</pubDate>
<dc:creator>LLLIN000</dc:creator>
<og:description>一、前言 1、简介 在上一篇UART详解中，已经有了关于UART的详细介绍了，也有关于如何使用STM32CubeMX来配置UART的操作了，而在该篇博客，主要会讲解一下如何实现UART串口的发送功能。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ChurF-Lin/p/10798193.html</dc:identifier>
</item>
<item>
<title>微服务技术选型之路 - 无涯Ⅱ</title>
<link>http://www.cnblogs.com/wlandwl/p/micrsoft_server.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wlandwl/p/micrsoft_server.html</guid>
<description>&lt;p&gt;    本文以笔者个人经历讲述关于微服务方面的技术选型和相关知识点。微服务模式的项目从初建到上线部署应用，每一个环节都会涉及到相当多的技术细节（上线后的性能调优更需要）。本文着重介绍一套微服务搭建流程中面临的一些技术选型，战略性的技术方案及相关技术的简要介绍，不做每一项技术的深入说明。&lt;/p&gt;
&lt;h2&gt; 微服务简介&lt;/h2&gt;
&lt;p&gt;    微服务是指开发一个单个小型的但有业务功能的服务，每个服务都有自己的处理和轻量通讯机制，可以部署在单个或多个服务器上。微服务也指一种种松耦合的、有一定的有界上下文的面向服务架构。&lt;/p&gt;
&lt;p&gt;    微服务是系统架构上的一种设计风格，主旨是将一个原本独立的系统拆分成多个小型服务，这些小型服务都在各自独立的进程中运行，服务之间通过基于HTTP/HTTPS协议的RESTful API进行通信协作，也可以通过RPC协议进行通信协作。被拆分成的每一个小型服务都围绕着系统中一些耦合度较高的业务功能进行构建，并且每个服务都维护着自身的数据存储，业务开发，自动化测试案例以及独立部署机制。由于有了轻量级的通信协作基础，所以这些微服务可以使用不同的语言来编写。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;微服务的优点&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;每个微服务都很小，这样能够聚焦一个指定的业务功能或业务需求。&lt;/li&gt;
&lt;li&gt;微服务能够被小团队单独开发，这个小团队是2到5人的开发人员组成。&lt;/li&gt;
&lt;li&gt;微服务是松耦合的，是有功能意义的服务，无论是在开发阶段或部署阶段都是独立的。&lt;/li&gt;
&lt;li&gt;微服务能使用不同的语言开发，如Java、Python、PHP、C#等。&lt;/li&gt;
&lt;li&gt;微服务允许容易且灵活的方式集成自动部署，通过持续集成工具，如Jenkins, Travis CI等工具。&lt;/li&gt;
&lt;li&gt;一个团队的新成员能够更快投入生产。&lt;/li&gt;
&lt;li&gt;微服务易于被一个开发人员理解，修改和维护，这样小团队能够更关注自己的工作成果。无需通过合作才能体现价值。&lt;/li&gt;
&lt;li&gt;微服务方便融合最新技术。&lt;/li&gt;
&lt;li&gt;微服务只是业务逻辑的代码，不会和HTML,CSS 或其他界面组件混合。&lt;/li&gt;
&lt;li&gt;微服务能够即时被要求扩展。&lt;/li&gt;
&lt;li&gt;微服务能部署中低端配置的服务器上。&lt;/li&gt;
&lt;li&gt;易于和第三方应用系统集成。&lt;/li&gt;
&lt;li&gt;每个微服务都有自己的存储能力，可以有自己的数据库，也可以有统一数据库。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt; 微服务技术选型&lt;/h2&gt;
&lt;p&gt;     前几年较为火的微服务技术有阿里的Dubbo方案。后面又出现了Spring体系下的微服务方案。本文主要介绍Spring体系下的微服务技术选型方案。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/626790/201905/626790-20190505140009748-35890328.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;     构建一套微服务最基本的是需要搭建网关，注册中心，开发具体实现业务功能的服务。对于各个微服务之间的通信，可通过Feign方案处理。具体搭建一套微服务技术选型可参考如下方案：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/626790/201905/626790-20190505140319377-2109766129.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    不同的技术选择应用的场景不同：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;网关：若整个公司业务都基于java开发，可以直接使用Spring Gateway做网关。若还存在其他的开发语言，也可选择kong网关模式。&lt;/li&gt;
&lt;li&gt;注册中心：基于java开发，Spring体系下可直接用 Spring Eureka。若还存在其他语言编写的服务，可使用Consul。&lt;/li&gt;
&lt;li&gt;微服务搭建：各自语言都可以搭建。若采用java开发，可参考Spring boot方案搭建微服务。&lt;/li&gt;
&lt;li&gt;持续集成的方案，三种都可以。若基于java开发，第一种最为传统，运维人员或开发人员工作更多，需编写启动脚本，使用jdk命令启动java程序。建议使用第二种方案。第三种方案操作更为简便，但需用阿里云的产品。&lt;/li&gt;
&lt;li&gt;Spring Boot 项目构建：采用Spring Boot模式搭建微服务项目时，对于Maven项目pom.xml配置文件的使用需注意pom文件配置单项目模式和项目聚合模式的区别。对于网关，注册中心可采用单项目模式。但在搭建真正业务的服务时，建议采用父子级项目聚合的方式。笔者最初做微服务开发时，采用了单项目的模式，当开发了多个业务的微服务后，单项目模式在引用依赖项目版本，管理项目时极为不便。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;微服务相关知识点&lt;/h2&gt;
&lt;p&gt;    本文针对Spring体系下微服务常用的几个知识点做简要说明，具体细节，原理，如何应用可通过关键词搜索详细了解。&lt;/p&gt;
&lt;h3&gt;Spring Boot&lt;/h3&gt;
&lt;p&gt;    Spring Boot是由 Pivotal团队提供的全新框架,其设计目的是用来简化新 Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置,从而使开发人员不再需要定义样板化的配置。&lt;/p&gt;
&lt;p&gt;Spring Boot的核心思想就是约定大于配置,一切自动完成。采用 Spring Boot可以大大的简化开发模式,通过组件的模式集成常用的框架。&lt;/p&gt;
&lt;h3&gt;Spring Cloud&lt;/h3&gt;
&lt;p&gt;    Spring Cloud是一系列框架的有序集合。它利用 Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发,如服务发现注册、配置中心、消息总线线、负载均衠、断路器、数据监控等,都可以用 Spring Boot的开发风格做到一键启动和部署。 Spring并没有重复制造轮子,它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组台起来,通过 Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理,最终给开发者留出了一套简单易懂、易部署和易维护的分布式系統开发工具包。&lt;/p&gt;
&lt;p&gt;     微服务是可以独立部署、水平扩展、独立访问(或者有独立的数据库)的服务单元, Spring Cloud就是这些微服务的大管家,采用了微服务这种架构之后,项目的数量会非常多, Spring Cloud做为大管家就需要提供各种方案来维护整个生态。&lt;/p&gt;
&lt;p&gt;    Spring Cloud就是一套分布式服务治理的框架,既然它是一套服务治理的框架,那么它本身不会提供具体功能性的操作,更专注于服务之间的通讯、熔断、监控等。因此就需要很多的组件来支持一套功能。&lt;/p&gt;
&lt;p&gt;    Spring Cloud的子项目，大致可分成两类，一类是对现有成熟框架”Spring Boot化”的封装和抽象，也是数量最多的项目；第二类是开发了一部分分布式系统的基础设施的实现，如Spring Cloud Stream扮演的就是kafka, ActiveMQ这样的角色。&lt;/p&gt;
&lt;h3&gt; Spring Cloud Eureka&lt;/h3&gt;
&lt;p&gt;    Spring Cloud Eureka是Spring Cloud Netflix项目下的服务治理模块。而Spring Cloud Netflix项目是Spring Cloud的子项目之一，主要内容是对Netflix公司一系列开源产品的包装，它为Spring Boot应用提供了自配置的Netflix OSS整合。通过一些简单的注解，开发者就可以快速的在应用中配置一下常用模块并构建庞大的分布式系统。它主要提供的模块包括：服务发现（Eureka），断路器（Hystrix），智能路由（Zuul），客户端负载均衡（Ribbon）等。&lt;/p&gt;
&lt;h3&gt;Spring Cloud Gateway&lt;/h3&gt;
&lt;p&gt;    Spring Cloud Gateway是Spring官方基于Spring 5.0，Spring Boot 2.0和Project Reactor等技术开发的网关，Spring Cloud Gateway旨在为微服务架构提供一种简单而有效的统一的API路由管理方式。Spring Cloud Gateway作为Spring Cloud生态系中的网关，目标是替代Netflix ZUUL，其不仅提供统一的路由方式，并且基于Filter链的方式提供了网关基本的功能，例如：安全，监控/埋点，和限流等。&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;&lt;strong&gt;Spring Cloud Feign&lt;/strong&gt;&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;    Feign是一个伪客户端，即它不做任何的请求处理。Feign通过处理注解生成request，从而实现简化HTTP API开发的目的，即开发人员可以使用注解的方式定制request api模板，在发送http request请求之前，feign通过处理注解的方式替换掉request模板中的参数，这种实现方式显得更为直接、可理解。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;    Feign&lt;/strong&gt;&lt;strong&gt;封装了Http调用流程，更适合面向接口化的编程习惯&lt;/strong&gt;。在服务调用的场景中，我们经常调用基于Http协议的服务，而我们经常使用到的框架可能有HttpURLConnection、Apache HttpComponnets、OkHttp3 、Netty等等，这些框架在基于自身的专注点提供了自身特性。而从角色划分上来看，他们的职能是一致的提供Http调用服务。&lt;/p&gt;

</description>
<pubDate>Sun, 05 May 2019 06:10:00 +0000</pubDate>
<dc:creator>无涯Ⅱ</dc:creator>
<og:description>本文以笔者个人经历讲述关于微服务方面的技术选型和相关知识点。微服务模式的项目从初建到上线部署应用，每一个环节都会涉及到相当多的技术细节（上线后的性能调优更需要）。本文着重介绍一套微服务搭建流程中面临的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wlandwl/p/micrsoft_server.html</dc:identifier>
</item>
<item>
<title>python接口自动化（二十八）--html测试 报告——下（详解） - 北京-宏哥</title>
<link>http://www.cnblogs.com/du-hong/p/10794684.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/du-hong/p/10794684.html</guid>
<description>&lt;h2&gt;简介&lt;/h2&gt;
&lt;p&gt;　　五一小长假已经结束了，想必大家都吃饱喝足玩好了，那就继续学习吧。一天不学习，自己知道；两天不学习，对手知道；三天不学习，大家知道；一周不学习，智商输给猪。好了开个玩笑都逗大家一乐，但是想想还是有道理的。那就进&lt;/p&gt;
&lt;p&gt;入正题：上一篇我们批量执行完用例后，已经生成的测试报告是生成 HTML 格式的。但是我们可以看出那个官方的测试报告既不美观也不大方，我们这里需要优化一下，优化的让人赏心悦目，就和看到一个美女一样看了一眼，忍不住回头再多&lt;/p&gt;
&lt;p&gt;看一眼  - _ - 并且把上一篇遇到的问题列举解决一下。&lt;/p&gt;
&lt;h2&gt;python3如何改动下载的HTMLTestRunner&lt;/h2&gt;
&lt;h3&gt;HTMLTestRunner.py 的python3 版本&lt;/h3&gt;
&lt;p&gt;由于 HTMLTestRunner.py 原本就是python2版本，目前还没找到python3版本，所以需要我们自己修改 HTMLTestRunner.py 文件。&lt;/p&gt;
&lt;h4&gt;1. 修改的地方&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;问题一&lt;/span&gt;：No module named StringIO&lt;/p&gt;
&lt;p&gt;原因：python 3 中 没有 StringIO 这个模块。这里我们需要使用io 这个模块来代替。&lt;/p&gt;
&lt;p&gt;解决方法：&lt;/p&gt;
&lt;p&gt;第94行引入的名称要改，从 import StringIO 改成import io。&lt;/p&gt;
&lt;p&gt;相应的，539行 self.outputBuffer = StringIO.StringIO() 要改成self.outputBuffer = io.BytesIO()&lt;/p&gt;
&lt;p&gt;&lt;span&gt;问题二&lt;/span&gt;：AttributeError: 'dict' object has no attribute 'has_key'&lt;/p&gt;
&lt;p&gt;原因：python 3 字典类型的object 已经不支持 has_key函数，我们需要使用in 来进行遍历。&lt;/p&gt;
&lt;p&gt;解决方法：&lt;/p&gt;
&lt;p&gt;定位到642行，if not rmap.has_key(cls): 需要换成 if not cls in rmap:&lt;/p&gt;
&lt;p&gt;&lt;span&gt;问题三&lt;/span&gt;：'str' object has no attribute 'decode'&lt;/p&gt;
&lt;p&gt;原因：python3 里面对字符的操作中，decode已经拿掉了。&lt;/p&gt;
&lt;p&gt;解决方法：&lt;/p&gt;
&lt;p&gt;定位到772行，把 ue = e.decode('latin-1') 直接改成 ue = e 。&lt;/p&gt;
&lt;p&gt;另外766还有类似的uo = o.decode('latin-1')，改成 uo=o ；&lt;/p&gt;
&lt;p&gt;&lt;span&gt;问题四&lt;/span&gt; ：TypeError: can't concat bytes to str&lt;/p&gt;
&lt;p&gt;原因：定位一下，报在了778行的内容escape(uo+ue) 。这是因为我们上面给uo赋值的时候，走的是else流程，uo被赋值的是bytes类型的值。 而bytes类型不能直接转化为str类型。所以我们需要在前面给uo赋值的时候先将bytes类型转换为 str类型。&lt;/p&gt;
&lt;p&gt;解决方法：&lt;/p&gt;
&lt;p&gt;修改768行的 uo = o ，直接改成 uo = o.decode('utf-8') 。&lt;/p&gt;
&lt;p&gt;另外 774还有类似的  ue = e， 改成 ue = e.decode('utf-8')。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;问题五&lt;/span&gt;：TypeError: unsupported operand type(s) for &amp;gt;&amp;gt;: 'builtin_function_or_method' and 'RPCProxy'&lt;/p&gt;
&lt;p&gt;原因： python3  不支持 print &amp;gt;&amp;gt; sys.stderr 这种写法，这里定义输出流的话，采用print(&quot;This is print str&quot;,file=sys.stderr) 这种方式。&lt;/p&gt;
&lt;p&gt;解决方法：&lt;/p&gt;
&lt;p&gt;定位到631行，把print的语句修改掉，原来是print &amp;gt;&amp;gt;sys.stderr, '\nTime Elapsed: %s' % (self.stopTime-self.startTime)， 可改成 print('\nTime Elapsed: %s' % (self.stopTime-self.startTime),file=sys.stderr)&lt;/p&gt;
&lt;p&gt;&lt;span&gt;问题六&lt;/span&gt;：TypeError: 'str' does not support the buffer interface&lt;/p&gt;
&lt;p&gt;原因：定位一下，问题出在118行，这里s是str类型，我们需要把传过来的s转化为bytes类型。&lt;/p&gt;
&lt;p&gt;解决方法：&lt;/p&gt;
&lt;p&gt;定位到118行，把 self.fp.write(s) 修改为 self.fp.write(bytes(s,'UTF-8')) 即可。&lt;/p&gt;
&lt;h4&gt;2. 保存&lt;/h4&gt;
&lt;p&gt;修改后对HTMLTestRunner.py 保存一下。&lt;/p&gt;
&lt;h4&gt;3. 调用语句更改&lt;/h4&gt;
&lt;p&gt;python3 里面打开文件使用 open，不要再去用file了。&lt;/p&gt;
&lt;p&gt;即 fp = file(filename,'wb')替换成 fp = open(filename,'wb')；&lt;/p&gt;
&lt;p&gt;关闭该文件可用fp.close()&lt;/p&gt;
&lt;p&gt;备注： 改动之后，中文也不会乱码。&lt;/p&gt;
&lt;h2&gt;中文乱码&lt;/h2&gt;
&lt;p&gt;1、测试报告中，msg 自定义异常内容有中文情况会出现乱码，如图所示：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201904/1232840-20190430135233864-848932277.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、找到 HTMLTestRunner.py 文件，搜索:uo =&lt;/p&gt;
&lt;p&gt;3、找到红色区域设置编码的两个地方&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201904/1232840-20190430134430216-1843435441.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4、注释掉红色区域这两个设置，重新添加编码格式为：uo = o.decode('utf-8') ue = e.decode('utf-8')，或者在此基础上直接修给成uo = o.decode('utf-8') ue = e.decode('utf-8')，建议初学者还是用第一种方法。这样出错了，可以很快还原，否则&lt;/p&gt;
&lt;p&gt;在碰到更复杂的代码直接修改就可能会遇到问题&lt;/p&gt;
&lt;p&gt;5、修改好之后记得保存，重新运行，乱码问题就解决了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201904/1232840-20190430135508632-850240072.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt; python3 报告问题&lt;/h2&gt;
&lt;p&gt;1、各位小伙伴可以按照我前边的方法进行自己修改，或者找我要也是可以，注意在修改的时候空格和Tab的问题，否则运行会报这样的错误&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201904/1232840-20190430135930506-1946234772.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;报告问题样式优化&lt;/h2&gt;
&lt;p&gt;1、优化是一些前端和CSS知识，在这里就不做详细介绍了，有兴趣的可以找我探讨一下，也可以和我要一下那个优化后的报告文件，优化后报告展示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201904/1232840-20190430140451648-1262963364.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt; 小结&lt;/h2&gt;
&lt;p&gt;1、关于生成报告，优化报告就是这么简单，小伙伴们练起来吧！&lt;/p&gt;
&lt;p&gt;2、为了新的报告不会覆盖掉老的测试报告，可以按图中的红色部分圈起来的方法实现&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201904/1232840-20190430141802039-838368915.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 3、参考代码（增加一行代码，测试报告的路径修改一下）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;# 获取当前时间，这样便于下面的使用。
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; now = time.strftime(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%Y-%m-%M-%H_%M_%S&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, time.localtime(time.time()))
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;#保存生成报告的路径
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; report_path =  &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C:\\Users\\DELL\\PycharmProjects\\honggetest\\report\\result&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+now+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sun, 05 May 2019 05:30:00 +0000</pubDate>
<dc:creator>北京-宏哥</dc:creator>
<og:description>简介 五一小长假已经结束了，想必大家都吃饱喝足玩好了，那就继续学习吧。一天不学习，自己知道；两天不学习，对手知道；三天不学习，大家知道；一周不学习，智商输给猪。好了开个玩笑都逗大家一乐，但是想想还是有</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/du-hong/p/10794684.html</dc:identifier>
</item>
<item>
<title>算法4：合并排序的套路 | 重用 | 分治 - 广州小程</title>
<link>http://www.cnblogs.com/freeself/p/10812375.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/freeself/p/10812375.html</guid>
<description>&lt;p&gt;“重用与增量有序”的设计套路，前文已经介绍，&lt;strong&gt;这次介绍另一个招数--重用与分治的设计思想&lt;/strong&gt;，这个套路在合并排序的算法设计中有所体现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;重用已经是一种被广泛使用的套路&lt;/strong&gt;，小程之前介绍了重用的含义，而合并排序的重用，体现在对自身的反复调用。首先，认定合并排序算法就是让数列有序的，只要经过它处理，就一定会变得有序，这个信念很重要，做人要信。然后，把数列分为两部分，分别重用合并排序，重用完，这两部分就变得有序了。最后，把有序的两部分数列，合并起来，就解决了排序的问题。&lt;/p&gt;
&lt;p&gt;也就是，合并排序本身就是一个标准作业，可以反复被重用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;选定标准作业，是很重要的，它会演化出不同的算法&lt;/strong&gt;。比如，插入排序是不能以自身作为标准作业的，因为如果这样设计，它就不叫“插入排序”了，很可能变成了合并排序。&lt;/p&gt;
&lt;p&gt;以上介绍了重用套路在合并排序算法中的体现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;另一个经典的套路，是分治。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;分治，就是分而治之，你应该经常听到这样的说法：“没有什么是搞不定的！只要你把它分解得足够小，就能解决！”，换一个说法就是：&lt;strong&gt;没有什么是退一步不能解决的，如果有，那就退两步。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;分是第一步，分出来解决后，还要把结果组合起来。&lt;/p&gt;
&lt;p&gt;合并排序的分治套路，表现很明显：把数列分为两部分，重用自己令这两部分有序后，再组合起来。&lt;/p&gt;
&lt;p&gt;而且，合并排序的分治，是很简单的分治，从中间分开再处理就可以了。当分到只有一个元素时，就不能再分，此时这一个元素是有序的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://free-picture1.oss-cn-shenzhen.aliyuncs.com/%E7%AE%97%E6%B3%95/%E5%90%88%E5%B9%B6%E6%8E%92%E5%BA%8F/mergesort1.png&quot; alt=&quot;分而治之 - 网络图片&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，合并排序的两个重要的套路（重用与分治）就差不多介绍完毕了。&lt;/p&gt;
&lt;p&gt;为了让读者更清晰地感受这两个套路，小程接下来从具体的排序实例来详细介绍。&lt;/p&gt;
&lt;p&gt;合并排序，先是要分（一分为二），分到只有一个元素为止（一个元素时就是有序的）。然后是合，先是两个元素合在一起，之后是多个元素合在一起。&lt;/p&gt;
&lt;p&gt;参考以下这个演示图，可以更好地理解合排的设计与实现：&lt;br/&gt;&lt;img src=&quot;https://free-picture1.oss-cn-shenzhen.aliyuncs.com/%E7%AE%97%E6%B3%95/%E5%90%88%E5%B9%B6%E6%8E%92%E5%BA%8F/%E5%90%88%E5%B9%B6-%E6%BC%94%E7%A4%BA%E5%9B%BE.png&quot; alt=&quot;合并排序演示图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面这个图，注意不同颜色框的变化（分与合的变化）。&lt;/p&gt;
&lt;p&gt;再参考另一个演示图（来自网络）：&lt;br/&gt;&lt;img src=&quot;https://free-picture1.oss-cn-shenzhen.aliyuncs.com/%E7%AE%97%E6%B3%95/%E5%90%88%E5%B9%B6%E6%8E%92%E5%BA%8F/mergesort2.png&quot; alt=&quot;合并排序演示 - 网络图片&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以上是算法套路，接下是代码实现，这两者是两个话题，之前已经解释过。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;

void merge(int* arr, int f, int m, int l, int* tmparr) {
    int i=f, j=m+1;
    int k=0;
    while (i&amp;lt;=m &amp;amp;&amp;amp; j&amp;lt;=l) {
        if (arr[i] &amp;gt; arr[j]) {
            tmparr[k++]=arr[j++];
        }
        else {
            tmparr[k++]=arr[i++];
        }
    }
    while (i&amp;lt;=m) {
        tmparr[k++]=arr[i++];
    }
    while (j&amp;lt;=l) {
        tmparr[k++]=arr[j++];
    }
    for (i=0; i&amp;lt;k; i++) {
        arr[f++]=tmparr[i];
    }
}

void _sort_merge(int* arr, int f, int l, int* tmparr) {
    if (f &amp;lt; l) {
        int m=(f+l)&amp;gt;&amp;gt;1;
        _sort_merge(arr, f, m, tmparr);
        _sort_merge(arr, m+1, l, tmparr);
        merge(arr, f, m, l, tmparr);
    }
}

void sort_merge(int* arr, int size) {
    int* tmparr=(int*)malloc(sizeof(int) * size);
    _sort_merge(arr, 0, size-1, tmparr);
    free(tmparr);
}

int main(int argc, char *argv[])
{
    int arr[] = {4, 2, 5, 1, 6, 6, 8, 9, 8, 3};
    int size=sizeof arr/sizeof *arr;
    for (int i = 0; i &amp;lt; size; i ++) {
        printf(&quot;%d, &quot;, arr[i]);
    }
    sort_merge(arr, size);
    printf(&quot;\nafter_sort:\n&quot;);
    for (int i = 0; i &amp;lt; size; i ++) {
        printf(&quot;%d, &quot;, arr[i]);
    }
    printf(&quot;\n&quot;);
    return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另外，在分治的套路中，可以混搭增量有序的套路，也就是，合并排序在划分到数量较小时，可以使用插入排序来完成排序（因为在数量较小时，插入排序更快一些），这种套路混搭，打出来的就是&lt;strong&gt;组合拳&lt;/strong&gt;。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;以下这部分，介绍了合排与快排的对比，你可以忽略掉，因为时间复杂度或速度方面，跟套路并无直接关系。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;小白：只要分成两部分，再递归调用自己来排好序，再合并在一起即可。小程，你之前讲的递归又发挥作用了！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;小程：不要把递归实现跟设计思想混在一起。设计上，是一直分下去，再合起来。但实现时，不一定要用递归，比如可以把分出来的部分，用数组保存起来，再对这个数组内的部分作细分...，用迭代也能实现。只不过，递归是很自然的实现选择，而且简洁。但是，你要有“空手套白狼”的勇气才敢于用上递归实现。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;小白：就是先假设我的函数已经实现排序了，再在函数里面调用自己，对某部分作排序了。东风吹战鼓擂，这个世界谁怕谁？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;合并排序的分（O(lgn)）与合（O(n)），整体的时间复杂度是O(nlgn)，而且是稳定排序。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;小白：那岂不是比快排还要快，因为快排有可能变为n的平方？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;小程：不是。快排有可能变成n的平方，这种极端的情况是低概率的，而且，可以先打乱再来快排，从而避免去到O(n^2)，或者去到极低概率。在都为O(nlogn)时，快排的系数比合排更小，所以速度更快。另外，合排需要额外的空间来保存合并的结果，而快排不需要。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;小白：这个...，看来quicksort是实至名归！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在工程中，快排的效果比合排更优，但注意高层次的设计思想，也就是套路，是一样的。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;总结一下，本文介绍了合并排序的套路，即重用与分治，这两种思想都是经典的套路，重用能简化问题的思考，而分治能把问题变小，能熟练掌握这两种套路就具备了很厉害的功力。&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://free-picture1.oss-cn-shenzhen.aliyuncs.com/%E9%80%BB%E8%BE%91%E9%A2%98/%E9%80%BB21.png&quot; alt=&quot;hello&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 05 May 2019 04:58:00 +0000</pubDate>
<dc:creator>广州小程</dc:creator>
<og:description>“重用与增量有序”的设计套路，前文已经介绍， 这次介绍另一个招数 重用与分治的设计思想 ，这个套路在合并排序的算法设计中有所体现。 重用已经是一种被广泛使用的套路 ，小程之前介绍了重用的含义，而合并排</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/freeself/p/10812375.html</dc:identifier>
</item>
<item>
<title>从GopherChina 2019看当前的go语言 - 猿界汪汪队</title>
<link>http://www.cnblogs.com/donlianli/p/10812327.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/donlianli/p/10812327.html</guid>
<description>&lt;p&gt;GopherChina 2019大会4月底刚刚结束，大会上使用的PPT也放了出来（大会情况及PPT在&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MjM5OTcxMzE0MQ==&amp;amp;mid=2653372473&amp;amp;idx=1&amp;amp;sn=cfa0e327d6909f28eefad27e707f5d78&amp;amp;scene=21#wechat_redirect&quot; data-cke-saved-href=&quot;https://mp.weixin.qq.com/s?__biz=MjM5OTcxMzE0MQ==&amp;amp;mid=2653372473&amp;amp;idx=1&amp;amp;sn=cfa0e327d6909f28eefad27e707f5d78&amp;amp;scene=21#wechat_redirect&quot;&gt;https://mp.weixin.qq.com/s/_oVpIcBMVIKVzQn6YrkAJw&lt;/a&gt;）。趁着五一假期，对大会的PPT做了一个简要分析；&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;滴滴&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;大会的第一场压轴嘉宾是滴滴杜欢。从PPT透漏出的go语言的应用规模，我觉得滴滴在这方面投入确实不小；分享的这个架构，应该很牛B。先进的微服务理念，完善的服务治理，动态扩容，问题定位，性能压测，监控。其中还有比较暴力的协议拦截，防雪崩等；总之就是一个框架很完善，业务隔离的很彻底，零故障的微服务大型框架；我有几个前同事，现在在滴滴，从侧面也打听了一下，滴滴确实有大规模使用go语言，但是最近几年，也在使用Java作为一个补充语言；总之，滴滴在go生态方面，算是走了大厂的前面。据我了解，阿里，百度和腾讯都还没有把go语言如此大规模地应用；&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;1&quot;&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190505122802270.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RvbmxpYW4=,size_16,color_FFFFFF,t_70&quot; alt=&quot;&quot; width=&quot;1024&quot; data-cke-saved-src=&quot;https://img-blog.csdnimg.cn/20190505122802270.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RvbmxpYW4=,size_16,color_FFFFFF,t_70&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://img-blog.csdnimg.cn/20190505122802270.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RvbmxpYW4=,size_16,color_FFFFFF,t_70&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;grab&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第二个嘉宾是grab公司，看描述是一个主要市场在东南亚的超级APP公司（类似美团？），主要分享了用go语言进行路径规划的案例。对这个公司不是很感兴趣，可能这个公司的核心应用也是go语言，所以放到了第二个；&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;pingCAP&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第三个是pingCAP公司，主要分享内容为如何构建一个稳定的数据库产品，在go语言方面的一些优化技巧。据我了解，这是一家创业公司，核心业务就是TiDB,一个非常容易扩展的database，兼容Mysql协议，目前我们公司就使用了TiDB。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其实后面的分享就没有什么特别大的参考价值，除非你真的在使用go语言。总结起来有三点，&lt;/p&gt;
&lt;p&gt;1、从这些分享主题可以看出，一些大的公司，如BAT，都已经开始小范围试水golang。&lt;/p&gt;
&lt;p&gt;2、一些新兴的公司，如B站（主要源于前段时间代码泄漏得出的结论，这次分享并没有B站，但是在2017年有哔哩哔哩的 Go 微服务实战），探探，pingCAP都已经在核心业务大规模采用go语言；这里面还有小米使用go语言构建了一个db中间件的分享，但从我同学那边了解到，小米的核心语言还是Java;&lt;/p&gt;
&lt;p&gt;3、golang依然任重道远，在构建企业生态方面还有很长的路，这个从这些分享中就可以看出，因为大部分人都在分享造轮子，踩坑，优化和实践等主题；&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;个人观点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我本人虽然是Java开发者，但其实一直对go语言情有独钟；首先是因为他是google出品，技术质量有保证；其次，它诞生的比较晚，大概在2009年；其实，你对语言了解的越深刻，你越发现，为了兼容，很多语言背负的历史包袱越重，而新的语言，通常会吸取前车之鉴，有更好的设计理念以及运行起来更好的性能。但是golang诞生之后，并没有出现大家期望的火爆场面，反而后来变的不温不火，这也让我多少有些失望；&lt;/p&gt;

&lt;p&gt;关注我的公众号了解更多类似分析；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/544558/201905/544558-20190505123846760-634925935.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 05 May 2019 04:40:00 +0000</pubDate>
<dc:creator>猿界汪汪队</dc:creator>
<og:description>GopherChina 2019大会4月底刚刚结束，大会上使用的PPT也放了出来（大会情况及PPT在https://mp.weixin.qq.com/s/_oVpIcBMVIKVzQn6YrkAJw）</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/donlianli/p/10812327.html</dc:identifier>
</item>
</channel>
</rss>