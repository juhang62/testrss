<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Scala XML - afewnotes</title>
<link>http://www.cnblogs.com/yuanzam/p/11629320.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuanzam/p/11629320.html</guid>
<description>&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;直接在代码中使用 XML 字面量&lt;/p&gt;
&lt;pre class=&quot;scala&quot;&gt;
&lt;code&gt;val doc: Elem = &amp;lt;html&amp;gt;&amp;lt;head&amp;gt;&amp;lt;title&amp;gt;Test&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt;test&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;
val items: NodeBuffer = &amp;lt;li&amp;gt;item1&amp;lt;/li&amp;gt;&amp;lt;li&amp;gt;item2&amp;lt;/li&amp;gt;&amp;lt;li&amp;gt;item1&amp;lt;/li&amp;gt;&amp;lt;li&amp;gt;item2&amp;lt;/li&amp;gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;Scala&lt;/code&gt; 中的 &lt;code&gt;Node&lt;/code&gt; 与 &lt;code&gt;DOM&lt;/code&gt; 不同，不包含父节点信息&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;层级&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/127263/201910/127263-20191007083916774-1129507719.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;操作&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/127263/201910/127263-20191007083916978-1004902439.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;scala&quot;&gt;
&lt;code&gt;// 类 XPath
val list = &amp;lt;dl&amp;gt;&amp;lt;dt&amp;gt;Java&amp;lt;/dt&amp;gt;&amp;lt;dd&amp;gt;Gosling&amp;lt;/dd&amp;gt;&amp;lt;dt&amp;gt;Scala&amp;lt;/dt&amp;gt;&amp;lt;dd&amp;gt;Odersky&amp;lt;/dd&amp;gt;&amp;lt;/dl&amp;gt;
val languages = list \ &quot;dt&quot;

// 修改元素
val list = &amp;lt;ul&amp;gt;&amp;lt;li&amp;gt;Fred&amp;lt;/li&amp;gt;&amp;lt;li&amp;gt;Wilma&amp;lt;/li&amp;gt;&amp;lt;/ul&amp;gt;
val list2 = list.copy(label = &quot;ol&quot;)
// 增加子元素
list.copy(child = list.child ++ &amp;lt;li&amp;gt;Another item&amp;lt;/li&amp;gt;)
// 增加属性
val image = &amp;lt;img src=&quot;hamster.jpg&quot;/&amp;gt;
val image2 = image % Attribute(null, &quot;alt&quot;, &quot;An image of a hamster&quot;, Null)&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;内嵌表达式，在XML中直接写 Scala 代码块&lt;/p&gt;
&lt;pre class=&quot;scala&quot;&gt;
&lt;code&gt;&amp;lt;ul&amp;gt;&amp;lt;li&amp;gt;{items(0)}&amp;lt;/li&amp;gt;&amp;lt;li&amp;gt;{items(1)}&amp;lt;/li&amp;gt;&amp;lt;/ul&amp;gt;
&amp;lt;ul&amp;gt;{for (i &amp;lt;- items) yield &amp;lt;li&amp;gt;{i}&amp;lt;/li&amp;gt;}&amp;lt;/ul&amp;gt;
&amp;lt;img src={makeURL(fileName)}/&amp;gt; // 注意不需要双引号
// 非常规类型
val js = &amp;lt;script&amp;gt;&amp;lt;![CDATA[if (temp &amp;lt; 0) alert(&quot;Cold!&quot;)]]&amp;gt;&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;模式匹配&lt;/p&gt;
&lt;pre class=&quot;scala&quot;&gt;
&lt;code&gt;case &amp;lt;li&amp;gt;{Text(item)}&amp;lt;/li&amp;gt; =&amp;gt; item
case &amp;lt;li&amp;gt;{children @ _*}&amp;lt;/li&amp;gt; =&amp;gt; for (c &amp;lt;- children) yield c&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;只能使用单个 &lt;code&gt;Node&lt;/code&gt; 进行匹配&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;加载、保存文件&lt;/p&gt;
&lt;pre class=&quot;scala&quot;&gt;
&lt;code&gt;import scala.xml.XML
val root = XML.loadFile(&quot;myfile.xml&quot;)
val root2 = XML.load(new FileInputStream(&quot;myfile.xml&quot;))
val root3 = XML.load(new InputStreamReader(
new FileInputStream(&quot;myfile.xml&quot;), &quot;UTF-8&quot;))
val root4 = XML.load(new URL(&quot;http://horstmann.com/index.html&quot;))

XML.save(&quot;myfile.xml&quot;, root)&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
</description>
<pubDate>Mon, 07 Oct 2019 00:39:00 +0000</pubDate>
<dc:creator>afewnotes</dc:creator>
<og:description>XML 直接在代码中使用 XML 字面量 中的 与 不同，不包含父节点信息 层级 操作 内嵌表达式，在XML中直接写 Scala 代码块 模式匹配 scala case {Text(item)} =</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yuanzam/p/11629320.html</dc:identifier>
</item>
<item>
<title>.Net Core 商城微服务项目系列（十五）: 构建定时任务调度和消息队列管理系统 - 名字都被注册了</title>
<link>http://www.cnblogs.com/weiBlog/p/11628912.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/weiBlog/p/11628912.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;一.系统描述&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;嗨，好久不见各位老哥，最近有点懒，技术博客写的太少了，因为最近在写小说，写的顺利的话说不定就转行了，哈哈哈哈哈哈哈哈哈。&lt;/p&gt;
&lt;p&gt;今天要介绍的是基于.Net Core的定时任务调度和消息队列管理系统。相信大家对这两个肯定都已经很熟悉了，在开发过程中，这两个组件扮演了不可或缺的角色：&lt;/p&gt;
&lt;p&gt;消息队列帮助我们进行 ”解耦“、”异步“、”削峰“&lt;/p&gt;
&lt;p&gt;定时任务帮助我们进行 &quot;后台&quot;、”监控&quot;、“补偿&quot;&lt;/p&gt;
&lt;p&gt;定时任务调度系统大家都介绍过很多次了，园子里的很多文章我也都拜读过，我相信大家实际的工作中肯定也都在频繁的使用它。目前主流的组件有 Quartz和Hangfire两种，在两者的选择上来说建议大家熟悉哪个用哪个就可以，Hangfire是自带UI管理界面的，所以如果想直接接入系统并且不想再进行二次开发做UI，可以直接选择Hangfire。&lt;/p&gt;
&lt;p&gt;因为我对于Quartz更熟悉，所以本系统的定时任务调度基于Quartz开发，消息队列基于RabbitMQ，同时有一套UI，用于可视化操作定时任务调度和管理消息队列配置。&lt;/p&gt;
&lt;p&gt;本系统是开发自用的，原型是公司工作中使用的系统，私下里重写了一套后台代码，但是UI还是公司的那一套，因为是自用，所以无法达到直接开箱即用的效果，写这篇的目的只是希望分享两者的使用方式和场景，帮助各位在遇到相同应用场景的问题时能够有更多解决思路。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;二.功能介绍&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1.MQ界面化动态配置，对代码几乎无入侵。（当然你还是需要引用nuget用来Publish消息的）&lt;/p&gt;
&lt;p&gt;2.提供定时任务调度功能。（基于Quartz，可以精确到秒，执行方式包括接口、sql脚本、elk）&lt;/p&gt;
&lt;p&gt;3.基于数据库脚本的异常数据监控。（通过定时任务调度系统执行监控的sql脚本）&lt;/p&gt;
&lt;p&gt;3.自动补偿。（当异常数据通过sql脚本监控出来后，发送MQ到指定消费接口进行数据处理）&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、系统架构介绍&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;整个系统包括六部分：&lt;/p&gt;
&lt;p&gt;1. MI.MessageQueue：消息队列基础组件，就是我们用来操作RabbitMQ的一系列方法。&lt;/p&gt;
&lt;p&gt;2.MI.MQStationServer：消息队列管理服务，提供包括消息队列的增删改查接口，消费MQ消息。&lt;/p&gt;
&lt;p&gt;3.MI.Service.Blade：定时任务调度管理服务，提供定时任务相关的一系列操作接口。&lt;/p&gt;
&lt;p&gt;4.MI.Biz.MQStation：消息队列windows服务，用于消费MQ，主要是建立相关的消息消费者，并转发消息到消息队列管理服务。&lt;/p&gt;
&lt;p&gt;5.MI.Biz.Blade：定时任务windows服务，用于创建及转发相应的任务，真正的执行在MI.Service.Blade服务。&lt;/p&gt;
&lt;p&gt;6.MI.Monitor.Web：UI管理界面，以上两者所有的增删改查都在这里。&lt;/p&gt;

&lt;p&gt;以下是定时任务调度系统间的交互：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1036828/201910/1036828-20191006232850257-1762898349.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;简单描述一下，用户在MI.Monitor.Web系统中通过界面化的操作创建定时任务，其会调用API接口也就是MI.Service.Blade服务，将操作的数据写入数据库，对于增删改，数据库写入完成后会发送一条MQ消息，Windows服务MI.Biz.Blade收到MQ消息后，根据消息中的数据添加或更改Quartz配置信息，对于定时任务Quartz完全基于代码动态化创建和删除。这样交互的好处一方面是解耦，这个比较明显，这里解耦带来的一个好处是异常隔离，本身三者之间的分工不同，对于发生问题的一方只在内部消化；第二点好处是方便横向扩展，无论是Windows服务还是API都可以根据自身的负载动态加减机器。当然，对于WIndows服务我们要做集群，通过Zookeeper可以实现，防止单点故障。&lt;/p&gt;

&lt;p&gt;以下是消息队列系统的交互：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1036828/201910/1036828-20191006234310904-278291615.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 看起来和上面的定时任务调度交互好像差不多，不过这个地方的麻烦点其实在于基础组件的编写，就是MI.MessageQueue里面的一系列RabbitMQ操作，目前支持单消息、批量消息、延时消息，延时消费需要借助RabbitMQ官方提供的 ”rabbitmq_delayed_message_exchange“插件，有需要的话可以去了解以下，官方的API支持该操作。&lt;/p&gt;
&lt;p&gt;还是照例描述一下消息队列的数据交互流程，用户在MI.Monitor.Web系统中通过界面化的操作创建或者更新消息队列，其会调用API接口也就是MI.MQStationServer服务，将操作的数据写入数据库，写入完成后会创建交换器（Exchange），然后发送MQ消息，Windows服务MI.Biz.MQStation收到消息后，将队列和RouteKey绑定到对应的交换器，同时创建消费者，绑定监听回调，该回调只是当作一个转发，收到消息后会通过接口将数据发送到MI.MQStationServer服务，根据在UI中配置的RouteKey和要消费的接口进行消费处理。&lt;/p&gt;

&lt;p&gt;消息队列这样设计的好处之一是解耦，同时异常隔离，这个就不说了，大家都明白；当然最重要的好处就是可以动态扩展，消费压力大，多启动几个windows服务和API服务，就是多加些消费者，这个理解起来也比较简单。&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;&lt;span&gt;四、优化和展示&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于消息队列系统目前还在开发中的功能是消息的数量统计，该系统是支持查看每个队列未消费的消息量，但是还没开发完成，这边博文会一直更新的。&lt;/p&gt;
&lt;p&gt;下面是系统的部分界面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1036828/201910/1036828-20191007000346979-1993143695.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1036828/201910/1036828-20191007000515998-222066616.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1036828/201910/1036828-20191007000533272-493546682.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;定时任务界面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1036828/201910/1036828-20191007000602870-1351010348.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1036828/201910/1036828-20191007000620812-1013769421.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1036828/201910/1036828-20191007000644885-45387441.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 06 Oct 2019 16:09:00 +0000</pubDate>
<dc:creator>名字都被注册了</dc:creator>
<og:description>一.系统描述 嗨，好久不见各位老哥，最近有点懒，技术博客写的太少了，因为最近在写小说，写的顺利的话说不定就转行了，哈哈哈哈哈哈哈哈哈。 今天要介绍的是基于.Net Core的定时任务调度和消息队列管理</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/weiBlog/p/11628912.html</dc:identifier>
</item>
<item>
<title>迭代器模式 - 纳兰小依</title>
<link>http://www.cnblogs.com/NaLanZiYi-LinEr/p/11629069.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/NaLanZiYi-LinEr/p/11629069.html</guid>
<description>&lt;p&gt;      迭代器模式提供了一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部实现。&lt;/p&gt;
&lt;p&gt;      有过Java编程经验的人对这种模式应该比较熟悉，因为Java内置的许多集合类型：List、Set、Map等都提供了迭代器接口，可以使用统一的方式遍历集合中的元素。下面将通过一个例子说明迭代器的使用场景，并了解一下迭代器模式的原理。&lt;/p&gt;
&lt;p&gt;      包子店卖的有包子和饮品，对于包子和饮品的每一个条目，我们用Item来表示，Item只包含name和price两个字段：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Item {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;   &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;   &lt;span&gt;private&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; price;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;   &lt;span&gt;public&lt;/span&gt; Item(String name, &lt;span&gt;double&lt;/span&gt;&lt;span&gt; price){
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.price =&lt;span&gt; price;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; getters and setters ...&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;      由于包子会不定期更新，所以用一个ArrayList来存储目前所有的包子类别：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Bun {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;   ArrayList&amp;lt;Item&amp;gt;&lt;span&gt; buns;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;   &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Bun(){
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     buns = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     addBun(&quot;鲜肉包子&quot;, 1.5&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     addBun(&quot;香菇青菜包子&quot;,  1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     addBun(&quot;鱼香肉丝包子&quot;,  1.5&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;   &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; addBun(String name, &lt;span&gt;double&lt;/span&gt;&lt;span&gt; price){
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     Item item = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Item(name, price);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    buns.add(item);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;   &lt;span&gt;public&lt;/span&gt; ArrayList&amp;lt;Item&amp;gt;&lt;span&gt; getBuns(){
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; buns;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;      而饮品则比较固定，一般不会增加新的类型，所以就假设固定成5种好了，对于这种需求，或许我们会选择使用数组来实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Drink {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;  Item[] drinks;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;   &lt;span&gt;int&lt;/span&gt;&lt;span&gt; position;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;   &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; MAX_SIZE = 5&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;   &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Drink(){
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     drinks = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Item[MAX_SIZE];
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     position = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     addDrink(&quot;豆浆&quot;, 2&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     addDrink(&quot;八宝粥&quot;, 2&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     addDrink(&quot;牛奶&quot;, 2.5&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     addDrink(&quot;银耳汤&quot;, 3&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     addDrink(&quot;豆腐脑&quot;, 2&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;   &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; addDrink(String name, &lt;span&gt;double&lt;/span&gt;&lt;span&gt; price){
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     Item item = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Item(name, price);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(position &amp;gt;=&lt;span&gt; MAX_SIZE){
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;       System.err.println(&quot;饮品已经满了。。。&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     }&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;       drinks[position++] =&lt;span&gt; item;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;   &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Item[] getDrinks(){
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; drinks;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;      那么，当我们需要输出早餐店里的所有包子和饮品的时候，需要怎么写呢？我们发现包子和饮品的底层存储不一样，或许都改成ArrayList会简单很多，但是由于代码已经写好了，其他很多地方都会使用上面的代码，所以冒险修改不是一个好选择，只能麻烦一些，针对两种情况分别处理：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;   &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; printItems(){
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     Bun bun = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Bun();
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     Drink drink = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Drink();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     ArrayList&amp;lt;Item&amp;gt; buns =&lt;span&gt; bun.getBuns();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     Item[] drinks =&lt;span&gt; drink.getDrinks();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出包子&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0; i&amp;lt;buns.size(); i++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;       Item item =&lt;span&gt; buns.get(i);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;       System.out.println(item.getName() + &quot;, &quot; +&lt;span&gt; item.getPrice());
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出饮品&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0; i&amp;lt;drinks.length; i++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;       System.out.println(drinks[i].getName() + &quot;, &quot; +&lt;span&gt; drinks[i].getPrice());
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;   }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;      输出如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
鲜肉包子, 1.5&lt;span&gt;
香菇青菜包子, &lt;/span&gt;1.0&lt;span&gt;
鱼香肉丝包子, &lt;/span&gt;1.5&lt;span&gt;
豆浆, &lt;/span&gt;2.0&lt;span&gt;
八宝粥, &lt;/span&gt;2.0&lt;span&gt;
牛奶, &lt;/span&gt;2.5&lt;span&gt;
银耳汤, &lt;/span&gt;3.0&lt;span&gt;
豆腐脑, &lt;/span&gt;2.0
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;      这里的打印逻辑的实现有几个问题：①打印方法需要知道包子和饮品的底层实现细节，这不满足封装的要求；②打印的逻辑不能扩展，如果包子店增加了馒头类型，而某位程序员打算使用Set来存储所有的馒头，那么打印方法必须要同步修改。因此，我们要做的就是隐藏底层的逻辑，对外提供统一的遍历接口，不管底层采用什么实现，对外保持一致就行。&lt;/p&gt;
&lt;p&gt;      为了保持遍历接口的简单性，我们不打算加入太多的逻辑，具体做法是定义一个迭代器接口，包含next()和hasNext()两个方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Iterator {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;   &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; hasNext();
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;  Item next();
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;      为包子和饮品分别定义对应的迭代器：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BunIterator &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Iterator{
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;   ArrayList&amp;lt;Item&amp;gt;&lt;span&gt; items;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;   &lt;span&gt;int&lt;/span&gt;&lt;span&gt; position;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;   &lt;span&gt;public&lt;/span&gt; BunIterator(ArrayList&amp;lt;Item&amp;gt;&lt;span&gt; items){
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.items =&lt;span&gt; items;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     position = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;  @Override
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;   &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; hasNext() {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(items == &lt;span&gt;null&lt;/span&gt; || position &amp;gt;=&lt;span&gt; items.size()){
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;       &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     }&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;       &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;  @Override
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;   &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Item next() {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; items.get(position++&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DrinkIterator &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Iterator{
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;  Item[] items;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;   &lt;span&gt;int&lt;/span&gt;&lt;span&gt; position;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt;   &lt;span&gt;public&lt;/span&gt;&lt;span&gt; DrinkIterator(Item[] items){
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.items =&lt;span&gt; items;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     position = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt; &lt;span&gt;  @Override
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;   &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; hasNext() {
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(position &amp;gt;= items.length || items[position] == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;       &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;     }&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;       &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; 
&lt;span&gt;43&lt;/span&gt; &lt;span&gt;  @Override
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;   &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Item next() {
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; items[position++&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;      修改包子和饮品类，只对外提供creatorIterator方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Bun{
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;   ArrayList&amp;lt;Item&amp;gt;&lt;span&gt; buns;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;   &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Bun(){
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     buns = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     addBun(&quot;鲜肉包子&quot;, 1.5&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     addBun(&quot;香菇青菜包子&quot;,  1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     addBun(&quot;鱼香肉丝包子&quot;,  1.5&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;   &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; addBun(String name, &lt;span&gt;double&lt;/span&gt;&lt;span&gt; price){
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     Item item = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Item(name, price);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    buns.add(item);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;   &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Iterator creatorIterator(){
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BunIterator(buns);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Drink {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;  Item[] drinks;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;   &lt;span&gt;int&lt;/span&gt;&lt;span&gt; position;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;   &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; MAX_SIZE = 5&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt;   &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Drink(){
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     drinks = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Item[MAX_SIZE];
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     position = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt;     addDrink(&quot;豆浆&quot;, 2&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;     addDrink(&quot;八宝粥&quot;, 2&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;     addDrink(&quot;牛奶&quot;, 2.5&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;     addDrink(&quot;银耳汤&quot;, 3&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;     addDrink(&quot;豆腐脑&quot;, 2&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; 
&lt;span&gt;39&lt;/span&gt;   &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; addDrink(String name, &lt;span&gt;double&lt;/span&gt;&lt;span&gt; price){
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;     Item item = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Item(name, price);
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(position &amp;gt;=&lt;span&gt; MAX_SIZE){
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;       System.err.println(&quot;饮品已经满了。。。&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;     }&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;       drinks[position++] =&lt;span&gt; item;
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; 
&lt;span&gt;48&lt;/span&gt;   &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Iterator creatorIterator(){
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DrinkIterator(drinks);
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;      接下来使用迭代器写一个新的打印方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestIterator {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;   &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     TestIterator test = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TestIterator();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    test.printItemsWithIterator();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;   &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; printItemsWithIterator(){
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     Bun bun = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Bun();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     Drink drink = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Drink();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     Iterator bunIterator =&lt;span&gt; bun.creatorIterator();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     Iterator drinkIterator =&lt;span&gt; drink.creatorIterator();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    printItemsWithIterator(bunIterator);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    printItemsWithIterator(drinkIterator);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;   &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; printItemsWithIterator(Iterator iterator){
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;&lt;span&gt;(iterator.hasNext()){
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;       Item item =&lt;span&gt; iterator.next();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;       System.out.println(item.getName() + &quot;, &quot; +&lt;span&gt; item.getPrice());
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;      输出如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
鲜肉包子, 1.5&lt;span&gt;
香菇青菜包子, &lt;/span&gt;1.0&lt;span&gt;
鱼香肉丝包子, &lt;/span&gt;1.5&lt;span&gt;
豆浆, &lt;/span&gt;2.0&lt;span&gt;
八宝粥, &lt;/span&gt;2.0&lt;span&gt;
牛奶, &lt;/span&gt;2.5&lt;span&gt;
银耳汤, &lt;/span&gt;3.0&lt;span&gt;
豆腐脑, &lt;/span&gt;2.0
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;      仍然能够完成打印任务，而且使用迭代器模式使得代码简洁了许多，也更容易维护。&lt;/p&gt;
&lt;p&gt;      以上简介了迭代器模式的用法，实际上有了Java内部的迭代器实现后，我们不再需要编写自己的迭代器，这里是为了展示迭代器的原理才自己实现。&lt;/p&gt;
</description>
<pubDate>Sun, 06 Oct 2019 15:57:00 +0000</pubDate>
<dc:creator>纳兰小依</dc:creator>
<og:description>迭代器模式提供了一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部实现。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/NaLanZiYi-LinEr/p/11629069.html</dc:identifier>
</item>
<item>
<title>Spring IOC（1）----容器刷新（refresh()）之前 - 白露非霜</title>
<link>http://www.cnblogs.com/nijunyang/p/11628954.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nijunyang/p/11628954.html</guid>
<description>&lt;p&gt;首先本次分析是基于注解形式的，想来xml格式的原理都是类似的。&lt;/p&gt;
&lt;p&gt;首先说一下什么是Bean定义（beandefinition）：bean定义并不是实例化的bean，而是bean对象的一些信息，根据这些定义的信息最后来初始化bean。比方说就是一些类的信息，还有我们配置的该实例的信息（是否懒加载，单例还是多例，作用域等等信息）。&lt;/p&gt;
&lt;p&gt;进入正题：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1216484/201910/1216484-20191006230453792-1343011723.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;AnnotationConfigApplicationContext构造方法传入一个主配置类，那么就从该构造方法进去。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1216484/201910/1216484-20191006230513849-1370463404.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;一、我们先来看在容器刷新（refresh()）之前，都干了什么&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;1.&lt;span&gt;&lt;strong&gt;this()&lt;/strong&gt;&lt;/span&gt;首先会调用无参构造，进而调用父类的无参构造，初始化beanFactory（DefaultListableBeanFactory），再者初始化注解模式下的bean定义读取器，classPath类型的bean定义扫描器；&lt;/p&gt;

&lt;p&gt;2&lt;strong&gt;&lt;span&gt;.register(annotatedClasses)&lt;/span&gt;&lt;/strong&gt;，基于上面初始化的bean定义读取器去解析注册我们自己的配置类信息到容器中。&lt;/p&gt;

&lt;p&gt;具体的流程图如下：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1216484/201910/1216484-20191006225004249-1423579743.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;完成了这些准备工作。refresh()里面就会实例化具体的bean了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、两个个扩展点&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1. BeanDefinitionRegistryPostProcessor&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Bean定义处理器，在注册bean定义的时候调用，可以自己注册新的bean定义&lt;/p&gt;
&lt;p&gt;先直接通过上下文对象获取一个student，会报错，没有对应的bean定义&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1216484/201910/1216484-20191006225338465-482371513.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;实现自己的Bean定义处理器&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;MyBeanDefinitionRegistryPostProcessor&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
package com.nijunyang.spring;

import com.nijunyang.spring.model.Student;
import org.springframework.beans.BeansException;
import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;
import org.springframework.beans.factory.support.BeanDefinitionRegistry;
import org.springframework.beans.factory.support.BeanDefinitionRegistryPostProcessor;
import org.springframework.beans.factory.support.RootBeanDefinition;
import org.springframework.stereotype.Component;

/**
 * @author: create by nijunyang
 * @date:2019/10/6
 */
@Component
public class MyBeanDefinitionRegistryPostProcessor implements BeanDefinitionRegistryPostProcessor {
    //bean定义注册处理器，在注册bean定义的时候调用，可以自己注册新的bean定义，比如Student
    @Override
    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException {
        System.out.println(&quot;bean定义的数据量:&quot;+registry.getBeanDefinitionCount());
        RootBeanDefinition rootBeanDefinition = new RootBeanDefinition(Student.class);
        //注册一个名为student的bean定义进去
        registry.registerBeanDefinition(&quot;student&quot;, rootBeanDefinition);
        System.out.println(&quot;bean定义的数据量:&quot;+registry.getBeanDefinitionCount());
    }

    @Override
    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {

    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 注意需要加上@Component，并且主配置指定扫描的包将自己定义的类加载进去&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;MainConfig&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
package com.nijunyang.spring;

import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;

/**
 * @author: create by nijunyang
 * @date:2019/10/6
 */
@Configuration
@ComponentScan(basePackages = &quot;com.nijunyang.spring&quot;)
public class MainConfig {
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1216484/201910/1216484-20191006225914803-1926497004.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 正常获取bean。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.BeanFactoryPostProcessor&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;BeanFactory后置处理器，注册了bean定义之后调用，可以修改bean定义，比如实现一个自己的BeanFactory后置处理器，把某个bean设置成懒加载。&lt;/p&gt;
&lt;p&gt; 断点运行1步骤中的代码，发现student不是懒加载的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1216484/201910/1216484-20191006230116405-432326484.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 实现自己的BeanFactory后置处理器，将student设置成懒加载&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;MyBeanFactoryPostProcessor&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
package com.nijunyang.spring;

import org.springframework.beans.BeansException;
import org.springframework.beans.factory.config.BeanDefinition;
import org.springframework.beans.factory.config.BeanFactoryPostProcessor;
import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;
import org.springframework.stereotype.Component;

/**
 * @author: create by nijunyang
 * @date:2019/10/6
 */
@Component
public class MyBeanFactoryPostProcessor implements BeanFactoryPostProcessor {
    //注册了bean定义之后调用，可以修改bean定义，比如把student设置成懒加载
    @Override
    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
        for(String name : beanFactory.getBeanDefinitionNames()) {
            if(&quot;student&quot;.equals(name)) {
                BeanDefinition beanDefinition = beanFactory.getBeanDefinition(name);
                beanDefinition.setLazyInit(true);
            }

        }
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 同样断点运行，发现student不会马上被初始化了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1216484/201910/1216484-20191006230339165-976659068.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 06 Oct 2019 15:10:00 +0000</pubDate>
<dc:creator>白露非霜</dc:creator>
<og:description>首先本次分析是基于注解形式的，想来xml格式的原理都是类似的。 首先说一下什么是Bean定义（beandefinition）：bean定义并不是实例化的bean，而是bean对象的一些信息，根据这些定</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/nijunyang/p/11628954.html</dc:identifier>
</item>
<item>
<title>F#周报2019年第40期 - Ken.W</title>
<link>http://www.cnblogs.com/kenwoo/p/11628926.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kenwoo/p/11628926.html</guid>
<description>[unable to retrieve full-text content]新闻 &quot;将项目成熟度重新考虑为一个社区过程&quot; &quot;介绍.NET Core Windows Form设计器预览1&quot; &quot;F 4.7可以预览新语言特性与语法&quot; 视频及幻灯片 &quot;DotnetConf2019展示&quot; &quot;.NET设计审查：GitHub快速审查&quot; 博客 &quot;.NET Core 3本地工具&quot; &quot;使用F </description>
<pubDate>Sun, 06 Oct 2019 15:05:00 +0000</pubDate>
<dc:creator>Ken.W</dc:creator>
<og:description>新闻 '将项目成熟度重新考虑为一个社区过程' '介绍.NET Core Windows Form设计器预览1' 'F 4.7可以预览新语言特性与语法' 视频及幻灯片 'DotnetConf2019展示</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kenwoo/p/11628926.html</dc:identifier>
</item>
<item>
<title>【Unity与Android】02-在Unity导出的Android工程中接入Google AdMob广告 - 子非鱼`</title>
<link>http://www.cnblogs.com/imteach/p/11628838.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/imteach/p/11628838.html</guid>
<description>&lt;blockquote readability=&quot;6.6048387096774&quot;&gt;
&lt;p&gt;我在上一篇文章 &lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/imteach/p/11567481.html&quot;&gt;【Unity与Android】01-Unity与Android交互通信的简易实现&lt;/a&gt;) 中介绍了Unity与Android通讯的基本方法。&lt;/p&gt;
&lt;p&gt;这一篇开始进入应用阶段，这次要介绍的是如何在Android工程中接入Google的AdMob。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;关于AdMob&lt;/h2&gt;
&lt;blockquote readability=&quot;19.443313953488&quot;&gt;
&lt;p&gt;AdMob是Google的一个广告平台，现在市面上（国外）的大部分免费游戏都是靠接入AdMob广告赚钱。&lt;/p&gt;
&lt;p&gt;AdMob提供了iOS,Android,Unity以及Cocos四大平台的SDK。&lt;/p&gt;
&lt;p&gt;如果想在Unity游戏中接入AdMob，最快的方法是使用Google提供的GoogleMobileAdsPlugin.unitypackage。这个插件可以在Unity Assets Store中找到，也可以去github上下载，地址&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/googleads/googleads-mobile-unity&quot;&gt;https://github.com/googleads/googleads-mobile-unity&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;鉴于Unity制作的移动端游戏最终还是会被转换为Android应用和iOS应用，所以为Unity游戏接入广告也可以在Android端和iOS端进行。&lt;/p&gt;
&lt;p&gt;本文要介绍的就是如何在Android端为Unity游戏接入AdMob广告。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;广告类型&lt;/h2&gt;
&lt;blockquote readability=&quot;24&quot;&gt;
&lt;p&gt;AdMob提供的广告有四种类型：横幅广告（Banner Ads）、插页式广告（Interstitial Ads）、激励广告（Rewarded Video Ads）和原生广告（Native Ads）。&lt;/p&gt;
&lt;h3&gt;横幅广告：&lt;/h3&gt;
&lt;p&gt;横幅广告是在应用布局中占据一处位置的矩形图片或文字广告。用户与应用互动时，这类广告会停留在屏幕上，并且可在一段时间后自动刷新。&lt;/p&gt;
&lt;h3&gt;插页式广告：&lt;/h3&gt;
&lt;p&gt;插页式广告是全屏广告，它会覆盖其托管应用的整个界面。这些广告通常会在应用流程的自然过渡点（例如活动之间或游戏关卡之间的暂停时段）展示。当应用展示插页式广告时，用户可以选择点按广告，访问其目标网址，也可以将其关闭，返回应用。&lt;/p&gt;
&lt;h3&gt;激励广告：&lt;/h3&gt;
&lt;p&gt;激励广告是全屏视频广告，用户选择观看视频，以换取应用内奖励。&lt;/p&gt;
&lt;h3&gt;原生广告：&lt;/h3&gt;
&lt;p&gt;原生广告是通过平台原生的UI组件呈现给用户的广告，比如微博、JD等软件启动时显示的广告。&lt;/p&gt;

&lt;p&gt;这几种类型的广告，横幅、插页、激励广告在游戏中都比较常用。&lt;/p&gt;
&lt;p&gt;下面将一一介绍这几种广告的接法（原生广告通常用的较少，且制作有点复杂，这里就不细述了，有需要的可以去AdMob的网站查看相关教程）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;一、准备工作&lt;/h2&gt;
&lt;blockquote readability=&quot;14&quot;&gt;
&lt;p&gt; 1、创建一个Unity项目。&lt;/p&gt;
&lt;p&gt;该项目上只设一个场景，场景中放三个按钮，用于发起对广告的调用。如下图&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/634826/201910/634826-20191006182215451-732693152.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2、将上述项目导出为Android的Gradle工程。（Unity中暂时不写任何代码，以后的文章里会补充）&lt;/p&gt;
&lt;p&gt;3、在Android Studio中打开上述工程。我这里这个工程的名称为AdMobProject，后文的操作都在这个工程中进行。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;二、导入AdMob SDK并初始化&lt;/h2&gt;
&lt;blockquote readability=&quot;53&quot;&gt;
&lt;h3&gt;1、导入SDK&lt;/h3&gt;
&lt;p&gt;将工程切换到Project视图，在工程目录下找到build.gradle文件并打开，在 &lt;strong&gt;buildscript { repositories {&lt;/strong&gt; 后添加google()，如果已经存在， 则不用重复添加。添加完成的代码块如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
//&lt;span&gt; GENERATED BY UNITY. REMOVE THIS COMMENT TO PREVENT OVERWRITING WHEN EXPORTING AGAIN

buildscript {
    repositories {
        &lt;span&gt;&lt;strong&gt;google()&lt;/strong&gt;&lt;/span&gt;
        jcenter()
    }

    dependencies {
        classpath &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;com.android.tools.build:gradle:3.2.0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在与buildscript平级的dependencies里添加 &lt;strong&gt;&lt;span class=&quot;pln&quot;&gt;implementation &lt;span class=&quot;str&quot;&gt;'com.google.android.gms:play-services-ads:18.2.0'&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　添加完成的代码块如下：　　&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/634826/201910/634826-20191006193348604-1263171093.png&quot; alt=&quot;&quot; width=&quot;735&quot; height=&quot;425&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　修改完成后，IDE会提示Gradle files have changed...，点击 Sync Now进行同步。&lt;/p&gt;
&lt;p&gt;　　这个同步操作，会将AdMob SDK以及其依赖库下载下来。同步结束后，打开External Libraries能看到相应的库文件。&lt;/p&gt;

&lt;h3&gt;2、SDK初始化&lt;/h3&gt;
&lt;p&gt;　　在src目录下找到UnityPlayerActivity.java文件，在UnityPlayerActivity类中有一个onCreate方法，这个就是游戏app的入口。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;初始化的方法1：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　在onCreate方法的 mUnityPlayer.requestFocus(); 语句之后，用 MobileAds.initialize进行初始化。代码如下：　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; MobileAds初始化的方法1，有监听，无法设置appId ；appId可以在AndroidManifest.xml中设置
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; AdMob Init&lt;/span&gt;
        MobileAds.initialize(&lt;span&gt;this&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; OnInitializationCompleteListener() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onInitializationComplete(InitializationStatus initializationStatus) {
                Log.i(&lt;/span&gt;&quot;AdMob&quot;, &quot;-----Admob初始化完成&quot;&lt;span&gt;);
            }
        });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这是一个带监听的初始化方法，但是不包含广告对应的appId,如果使用这种方法，需要在AndroidManifest.xml文件中指明appid。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;初始化的方法2：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　还是在同样的位置添加MobileAds.initialize调用，区别在于参数不一样。这个方法的第二个参数为appid，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;MobileAds初始化的方法2，可以指定appId；当AndroidManifest中也设置了appId时，以AndroidManifest为准
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Sample AdMob App ID: ca-app-pub-3940256099942544~3347511713&lt;/span&gt;
        MobileAds.initialize(&lt;span&gt;this&lt;/span&gt;, &quot;ca-app-pub-3940256099942544~3347511713&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;测试用的AppId&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;&lt;em&gt;如果使用此种方法初始化，而在AndroidManifest.xml也指明了appid，则以xml文件中的为准（根据使用其它插件的经验推测的，未验证。不放心就只使用一种方式即可）&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　这里的&quot;ca-app-pub-3940256099942544~3347511713&quot;是Google提供的用于测试一个样例appId。&lt;/p&gt;
&lt;p&gt;　　以上两种初始化的方法，选择一个即可。&lt;/p&gt;
&lt;p&gt;　　我这里选择方法2，以下是添加完成后的图：&lt;/p&gt;
&lt;p&gt;    &lt;img src=&quot;https://img2018.cnblogs.com/blog/634826/201910/634826-20191006212823766-207109731.png&quot; alt=&quot;&quot; width=&quot;887&quot; height=&quot;269&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;


&lt;h2&gt;三、接入横幅广告（Banner Ads）&lt;/h2&gt;
&lt;blockquote readability=&quot;30.5&quot;&gt;
&lt;p&gt;上一步的初始化完成之后，就能进行banner广告的接入了。&lt;/p&gt;
&lt;p&gt;1、 在UnityPlayerActivity类中添加一个初始化banner广告的方法bannerAdInit。代码如下：　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * banner广告初始化
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; adUnitId  广告id
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; size 广告尺寸
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;  &lt;span&gt;void&lt;/span&gt;&lt;span&gt; bannerAdInit (String adUnitId, AdSize size) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建广告视图&lt;/span&gt;
        AdView bannerAdView = &lt;span&gt;new&lt;/span&gt; AdView(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置广告尺寸&lt;/span&gt;
&lt;span&gt;        bannerAdView.setAdSize(size);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置广告ID&lt;/span&gt;
&lt;span&gt;        bannerAdView.setAdUnitId(adUnitId);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;请求广告&lt;/span&gt;
        AdRequest adRequest = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AdRequest.Builder().build();
        bannerAdView.loadAd(adRequest);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加监听&lt;/span&gt;
        bannerAdView.setAdListener(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; AdListener() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onAdLoaded() {
                Log.i(&lt;/span&gt;&quot;BannerAd&quot;, &quot;banner广告加载完成&quot;&lt;span&gt;);
            }

            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; onAdFailedToLoad(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; errCode) {
                Log.i(&lt;/span&gt;&quot;BannerAd&quot;, &quot;banner广告加载失败, err_code:&quot; +&lt;span&gt; errCode);
            }

            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onAdOpened() {
                Log.i(&lt;/span&gt;&quot;BannerAd&quot;, &quot;banner广告被打开&quot;&lt;span&gt;);
            }
        });

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明一个布局参数（MATCH_PARENT为填充父级,WRAP_CONTENT为包裹内容）&lt;/span&gt;
        FrameLayout.LayoutParams fllp = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FrameLayout.LayoutParams(
                LinearLayout.LayoutParams.MATCH_PARENT,
                LinearLayout.LayoutParams.WRAP_CONTENT);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置布局对齐方式为：垂直对齐到底，水平居中&lt;/span&gt;
        fllp.gravity = Gravity.BOTTOM|&lt;span&gt;Gravity.CENTER_HORIZONTAL;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加到View&lt;/span&gt;
&lt;span&gt;        addContentView(bannerAdView, fllp);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    关于代码的说明，直接看注释即可。&lt;/p&gt;
&lt;p&gt;2、在onCreate方法中添加对bannerAdInit的调用，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;横幅（banner）广告初始化
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Sample AdMob banner ad id: ca-app-pub-3940256099942544/6300978111&lt;/span&gt;
        bannerAdInit(&quot;ca-app-pub-3940256099942544/6300978111&quot;, AdSize.BANNER);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　这条语句位于初始化语句之后即可。&lt;span&gt;&quot;ca-app-pub-3940256099942544/6300978111&quot;是Google提供的banner广告单元id样例，可以直接使用，直到你申请了正式的广告id。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、测试&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;bannerAdInit添加完成之后，配置一下Android Studio的SDK以及模拟器。&lt;/p&gt;
&lt;p&gt;　　然后运行app，app安装到模拟器之后，能看到，在屏幕下方出现了测试用的Banner广告。见下图：&lt;/p&gt;
&lt;p&gt;    &lt;img src=&quot;https://img2018.cnblogs.com/blog/634826/201910/634826-20191006214622794-1158802639.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; Banner广告的接入就算实现了，接下来看插页广告的接法。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;四、接入插页广告（Interstitial Ads）&lt;/h2&gt;
&lt;blockquote readability=&quot;27.5&quot;&gt;
&lt;p&gt;1、 在UnityPlayerActivity类中添加一个初始化插页广告的方法interstitialAdInit。代码如下： &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 插页广告初始化
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; adUnitId 广告id
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; interstitialAdInit (String adUnitId) {
        InterstitialAd interstitialAd &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; InterstitialAd(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);

        interstitialAd.setAdUnitId(adUnitId);

        interstitialAd.loadAd(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; AdRequest.Builder().build());

        Log.i(&lt;/span&gt;&quot;interstitalAd&quot;, &quot;is Loaded:&quot; +&lt;span&gt; interstitialAd.isLoaded());

        interstitialAd.setAdListener(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; AdListener() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onAdClosed() {
                &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onAdClosed();
                Log.i(&lt;/span&gt;&quot;interstitalAd&quot;, &quot;插页广告被关闭&quot;&lt;span&gt;);

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Load the next interstitial.插页广告被关闭时预加载下一次的广告
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;interstitialAd.loadAd(new AdRequest.Builder().build());&lt;/span&gt;
&lt;span&gt;           }
&lt;br/&gt;@Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onAdLoaded() {
                &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onAdLoaded();
                Log.i(&lt;/span&gt;&quot;interstitalAd&quot;, &quot;插页广告加载完成&quot;&lt;span&gt;);
　　　　　　　　　　//广告加载完成之后直接显示
                interstitialAd.show();
            }
        });
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、依照banner广告，在onCreate方法中添加对interstitialAdInit的调用，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;插页（interstitial）广告初始化
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Sample AdMob interstitial ad id: ca-app-pub-3940256099942544/1033173712&lt;/span&gt;
        interstitialAdInit(&quot;ca-app-pub-3940256099942544/1033173712&quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　代码位置在AdMob初始化之后即可。参数同样为一个测试用的插页广告id。&lt;/p&gt;
&lt;p&gt;3、重新运行app，等待app启动后，能看到一个插页广告被显示出来。如下图：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/634826/201910/634826-20191006215653444-1339815805.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　要注意的是，我这是为了测试，直接让app启动后就进行广告初始化，并在广告加载完成后立即显示出来。这是不太符合正常的使用场景的。在游戏中，广告初始化和加载可以提前进行，但显示应该是可控的。&lt;/p&gt;
&lt;p&gt;　　插页广告的显示方法，应该提出来，由外部（游戏逻辑）调用。&lt;/p&gt;
&lt;p&gt;　　插页广告接入完成。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;五、接入激励广告（Rewarded Video Ads）&lt;/h2&gt;
&lt;blockquote readability=&quot;57.5&quot;&gt;
&lt;p&gt;激励广告的接入比之前两上要复杂一些，步骤如下：&lt;/p&gt;
&lt;p&gt;1、在UnityPlayerActivity类中声明两个成员变量rewardedVideoAd(&lt;strong&gt;RewardedVideoAd&lt;/strong&gt;类型)和rewardVidewAdUnitId(&lt;strong&gt;String&lt;/strong&gt;类型)，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;激励视频广告&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; RewardedVideoAd rewardedVideoAd;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;激励视频广告Id&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;  String rewardVidewAdUnitId;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2、在UnityPlayerActivity类中添加一个&lt;strong&gt;初始化激励广告&lt;/strong&gt;的方法&lt;strong&gt;rewardedVideoAdInit &lt;/strong&gt;。代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 激励视频（Rewarded Video）广告初始化
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; rewardedVideoAdInit (String adUnitId) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Use an activity context to get the rewarded video instance.&lt;/span&gt;
        rewardedVideoAd = MobileAds.getRewardedVideoAdInstance(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);

        rewardedVideoAd.setRewardedVideoAdListener(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);

        rewardVidewAdUnitId &lt;/span&gt;=&lt;span&gt; adUnitId;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3、在UnityPlayerActivity类中添加一个&lt;strong&gt;加载激励视频&lt;/strong&gt;的方法&lt;strong&gt;loadRewardedVideoAd&lt;/strong&gt;。代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;加载激励视频&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; loadRewardedVideoAd() {
        rewardedVideoAd.loadAd(rewardVidewAdUnitId, &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; AdRequest.Builder().build());
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4、在UnityPlayerActivity类中添加一个&lt;strong&gt;显示激励视频&lt;/strong&gt;的方法&lt;strong&gt;showRewardedVideoAd&lt;/strong&gt;。代码如下：　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;显示激励视频&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; showRewardedVideoAd() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (rewardedVideoAd.isLoaded()) {
            rewardedVideoAd.show();
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            Toast.makeText(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;, &quot;video is not ready.&quot;&lt;span&gt;, Toast.LENGTH_SHORT);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;5、在第1步的&lt;strong&gt;interstitialAdInit&lt;/strong&gt;方法写完之后，IDE会报红，提未本类无法成为激励视频广告的监听。&lt;/p&gt;
&lt;p&gt;解决办法是让UnityPlayerActivity 类实现RewardedVideoAdListener接口。&lt;/p&gt;
&lt;p&gt;　　1)在extends Activity后添加 implements RewardedVideoAdListener，如下：　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; UnityPlayerActivity &lt;span&gt;extends&lt;/span&gt; Activity &lt;span&gt;implements&lt;/span&gt; RewardedVideoAdListener
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2)根据提示，在本类中实现RewardedVideoAdListener对应的方法，代码如下：　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('5a76a706-26e2-4ff3-8ff4-4b4ef6f83250')&quot; readability=&quot;40.5&quot;&gt;&lt;img id=&quot;code_img_closed_5a76a706-26e2-4ff3-8ff4-4b4ef6f83250&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_5a76a706-26e2-4ff3-8ff4-4b4ef6f83250&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('5a76a706-26e2-4ff3-8ff4-4b4ef6f83250',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_5a76a706-26e2-4ff3-8ff4-4b4ef6f83250&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;76&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;---------------激励视频监听实现 begin-------------------&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onRewardedVideoAdLoaded() {
        Toast.makeText(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;, &quot;onRewardedVideoAdLoaded&quot;&lt;span&gt;, Toast.LENGTH_SHORT).show();
        showRewardedVideoAd();
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onRewardedVideoAdOpened() {
        Toast.makeText(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;, &quot;onRewardedVideoAdOpened&quot;&lt;span&gt;, Toast.LENGTH_SHORT).show();
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onRewardedVideoStarted() {
        Toast.makeText(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;, &quot;onRewardedVideoStarted&quot;&lt;span&gt;, Toast.LENGTH_SHORT).show();
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onRewardedVideoAdClosed() {
        Toast.makeText(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;, &quot;onRewardedVideoAdClosed&quot;&lt;span&gt;, Toast.LENGTH_SHORT).show();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Load the next rewarded video ad.&lt;/span&gt;
&lt;span&gt;        loadRewardedVideoAd();
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onRewarded(RewardItem reward) {
        Toast.makeText(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;, &quot;onRewarded! currency: &quot; + reward.getType() + &quot;  amount: &quot; +&lt;span&gt;
                reward.getAmount(), Toast.LENGTH_SHORT).show();
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onRewardedVideoAdLeftApplication() {
        Toast.makeText(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;, &quot;onRewardedVideoAdLeftApplication&quot;&lt;span&gt;,
                Toast.LENGTH_SHORT).show();
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; onRewardedVideoAdFailedToLoad(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i) {
        Toast.makeText(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;, &quot;onRewardedVideoAdFailedToLoad&quot;&lt;span&gt;, Toast.LENGTH_SHORT).show();
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onRewardedVideoCompleted() {
        Toast.makeText(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;, &quot;onRewardedVideoCompleted&quot;&lt;span&gt;, Toast.LENGTH_SHORT).show();
    }
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;---------------激励视频监听实现 end-------------------&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;激励视频监听实现的代码&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;其中，我在广告加载完成后进行了对&lt;strong&gt;showRewardedVideoAd&lt;/strong&gt;的调用以显示广告。并在视频广告关闭后进行了重新加载。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6、依照banner和插页广告的做法，在onCreate方法中添加对rewardedVideoAdInit&lt;/span&gt;&lt;span&gt;的调用，代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;激励视频（Rewarded Video）广告初始化
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Sample AdMob interstitial ad id: ca-app-pub-3940256099942544/5224354917&lt;/span&gt;
        rewardedVideoAdInit(&quot;ca-app-pub-3940256099942544/5224354917&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;预加载视频&lt;/span&gt;
        loadRewardedVideoAd();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在rewardedVideoAdInit之后还需要调用loadRewardedVideoAd以便让广告视频可以提前加载。&lt;/p&gt;
&lt;p&gt;7、测试。&lt;/p&gt;
&lt;p&gt;重新运行项目，等待模拟器上app启动后，能看到一个7秒的视频广告显示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/634826/201910/634826-20191006222308788-1279922342.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 关闭视频广告后，等几秒又会重新加载一个视频出来（前边的代码有说明，在关闭后重新加载了）。&lt;/p&gt;
&lt;p&gt;和插页广告一样，视频广告的显示应该是由外部（游戏逻辑）调用的。这里为了测试，是直接在加载后就是显示。&lt;/p&gt;
&lt;p&gt;激励广告的接入也完成。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;总结&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;AdMob的接入，总的来看，还是比较简单的，且官方也提供了详细的文档和案例，基本照着做就能会。唯一的问题是，看这些文档需要会翻墙。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;后续&lt;/h2&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;由于UnityPlayerActivity类是由Unity导出Android工程时自动生成的，我们在此类中实现SDK的接入，对于项目的更新及其不方便。总不能每次打包，都要倒腾一回UnityPlayerActivity.java吧。&lt;/p&gt;
&lt;p&gt;后续计划就是用前一篇文章提到的方法，将接入AdMob SDK相关的逻辑都放放到一个jar包里，直接在Unity里调用。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;下篇再见。&lt;/p&gt;

&lt;p&gt;UnityPlayerActivity.java的完整代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('c334913e-9991-40ac-83b7-60559228e940')&quot; readability=&quot;51&quot;&gt;&lt;img id=&quot;code_img_closed_c334913e-9991-40ac-83b7-60559228e940&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_c334913e-9991-40ac-83b7-60559228e940&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('c334913e-9991-40ac-83b7-60559228e940',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c334913e-9991-40ac-83b7-60559228e940&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;97&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.tan.admob;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.google.android.gms.ads.AdListener;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.google.android.gms.ads.AdRequest;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.google.android.gms.ads.AdSize;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.google.android.gms.ads.AdView;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.google.android.gms.ads.InterstitialAd;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.google.android.gms.ads.MobileAds;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.google.android.gms.ads.initialization.InitializationStatus;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.google.android.gms.ads.initialization.OnInitializationCompleteListener;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.google.android.gms.ads.reward.RewardItem;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.google.android.gms.ads.reward.RewardedVideoAd;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.google.android.gms.ads.reward.RewardedVideoAdListener;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; com.unity3d.player.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.app.Activity;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.content.Intent;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.content.res.Configuration;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.graphics.Color;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.graphics.PixelFormat;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.os.Bundle;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.print.PrintAttributes;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.util.Log;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.view.Gravity;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.view.KeyEvent;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.view.MotionEvent;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.view.View;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.view.ViewGroup;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.view.Window;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.view.WindowManager;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.widget.FrameLayout;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.widget.LinearLayout;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.widget.RelativeLayout;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.widget.TextView;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.widget.Toast;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; UnityPlayerActivity &lt;span&gt;extends&lt;/span&gt; Activity &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; RewardedVideoAdListener {
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; UnityPlayer mUnityPlayer; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; don't change the name of this variable; referenced from native code

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;激励视频广告&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; RewardedVideoAd rewardedVideoAd;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;激励视频广告Id&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt;  String rewardVidewAdUnitId;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Setup activity layout&lt;/span&gt;
    @Override &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onCreate(Bundle savedInstanceState)
    {
        requestWindowFeature(Window.FEATURE_NO_TITLE);
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onCreate(savedInstanceState);

        mUnityPlayer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; UnityPlayer(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        setContentView(mUnityPlayer);
        mUnityPlayer.requestFocus();

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
        // MobileAds初始化的方法1，有监听，无法设置appId ；appId可以在AndroidManifest.xml中设置
        // AdMob Init
        MobileAds.initialize(this, new OnInitializationCompleteListener() {
            @Override
            public void onInitializationComplete(InitializationStatus initializationStatus) {
                Log.i(&quot;AdMob&quot;, &quot;-----Admob初始化完成&quot;);
            }
        });
        &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;MobileAds初始化的方法2，可以指定appId；当AndroidManifest中也设置了appId时，以AndroidManifest为准
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Sample AdMob App ID: ca-app-pub-3940256099942544~3347511713&lt;/span&gt;
        MobileAds.initialize(&lt;span&gt;this&lt;/span&gt;, &quot;ca-app-pub-3940256099942544~3347511713&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;测试用的AppId

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;横幅（banner）广告初始化
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Sample AdMob banner ad id: ca-app-pub-3940256099942544/6300978111&lt;/span&gt;
        bannerAdInit(&quot;ca-app-pub-3940256099942544/6300978111&quot;&lt;span&gt;, AdSize.BANNER);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;插页（interstitial）广告初始化
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Sample AdMob interstitial ad id: ca-app-pub-3940256099942544/1033173712&lt;/span&gt;
        interstitialAdInit(&quot;ca-app-pub-3940256099942544/1033173712&quot;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;激励视频（Rewarded Video）广告初始化
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Sample AdMob interstitial ad id: ca-app-pub-3940256099942544/5224354917&lt;/span&gt;
        rewardedVideoAdInit(&quot;ca-app-pub-3940256099942544/5224354917&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;预加载视频&lt;/span&gt;
&lt;span&gt;        loadRewardedVideoAd();
    }


    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * banner广告初始化
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; adUnitId  广告id
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; size 广告尺寸
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;  &lt;span&gt;void&lt;/span&gt;&lt;span&gt; bannerAdInit (String adUnitId, AdSize size) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建广告视图&lt;/span&gt;
        AdView bannerAdView = &lt;span&gt;new&lt;/span&gt; AdView(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置广告尺寸&lt;/span&gt;
&lt;span&gt;        bannerAdView.setAdSize(size);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置广告ID&lt;/span&gt;
&lt;span&gt;        bannerAdView.setAdUnitId(adUnitId);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;请求广告&lt;/span&gt;
        AdRequest adRequest = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AdRequest.Builder().build();
        bannerAdView.loadAd(adRequest);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加监听&lt;/span&gt;
        bannerAdView.setAdListener(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; AdListener() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onAdLoaded() {
                Log.i(&lt;/span&gt;&quot;BannerAd&quot;, &quot;banner广告加载完成&quot;&lt;span&gt;);
            }

            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; onAdFailedToLoad(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; errCode) {
                Log.i(&lt;/span&gt;&quot;BannerAd&quot;, &quot;banner广告加载失败, err_code:&quot; +&lt;span&gt; errCode);
            }

            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onAdOpened() {
                Log.i(&lt;/span&gt;&quot;BannerAd&quot;, &quot;banner广告被打开&quot;&lt;span&gt;);
            }
        });

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明一个布局参数（MATCH_PARENT为填充父级,WRAP_CONTENT为包裹内容）&lt;/span&gt;
        FrameLayout.LayoutParams fllp = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FrameLayout.LayoutParams(
                LinearLayout.LayoutParams.MATCH_PARENT,
                LinearLayout.LayoutParams.WRAP_CONTENT);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置布局对齐方式为：垂直对齐到底，水平居中&lt;/span&gt;
        fllp.gravity = Gravity.BOTTOM|&lt;span&gt;Gravity.CENTER_HORIZONTAL;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加到View&lt;/span&gt;
&lt;span&gt;        addContentView(bannerAdView, fllp);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 插页广告初始化
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; adUnitId 广告id
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; interstitialAdInit (String adUnitId) {
        InterstitialAd interstitialAd &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; InterstitialAd(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);

        interstitialAd.setAdUnitId(adUnitId);

        interstitialAd.loadAd(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; AdRequest.Builder().build());

        Log.i(&lt;/span&gt;&quot;interstitalAd&quot;, &quot;is Loaded:&quot; +&lt;span&gt; interstitialAd.isLoaded());

        interstitialAd.setAdListener(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; AdListener() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onAdClosed() {
                &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onAdClosed();
                Log.i(&lt;/span&gt;&quot;interstitalAd&quot;, &quot;插页广告被关闭&quot;&lt;span&gt;);

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Load the next interstitial.
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;interstitialAd.loadAd(new AdRequest.Builder().build());&lt;/span&gt;
&lt;span&gt;           }

            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onAdLoaded() {
                &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onAdLoaded();
                Log.i(&lt;/span&gt;&quot;interstitalAd&quot;, &quot;插页广告加载完成&quot;&lt;span&gt;);

                interstitialAd.show();
            }
        });
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 激励视频（Rewarded Video）广告初始化
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; rewardedVideoAdInit (String adUnitId) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Use an activity context to get the rewarded video instance.&lt;/span&gt;
        rewardedVideoAd = MobileAds.getRewardedVideoAdInstance(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);

        rewardedVideoAd.setRewardedVideoAdListener(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);

        rewardVidewAdUnitId &lt;/span&gt;=&lt;span&gt; adUnitId;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加载激励视频&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; loadRewardedVideoAd() {
        rewardedVideoAd.loadAd(rewardVidewAdUnitId, &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; AdRequest.Builder().build());
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;显示激励视频&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; showRewardedVideoAd() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (rewardedVideoAd.isLoaded()) {
            rewardedVideoAd.show();
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            Toast.makeText(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;, &quot;video is not ready.&quot;&lt;span&gt;, Toast.LENGTH_SHORT);
        }
    }

    @Override &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onNewIntent(Intent intent)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; To support deep linking, we need to make sure that the client can get access to
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; the last sent intent. The clients access this through a JNI api that allows them
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; to get the intent set on launch. To update that after launch we have to manually
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; replace the intent with the one caught here.&lt;/span&gt;
&lt;span&gt;        setIntent(intent);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Quit Unity&lt;/span&gt;
    @Override &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onDestroy ()
    {
        mUnityPlayer.destroy();
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onDestroy();
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Pause Unity&lt;/span&gt;
    @Override &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onPause()
    {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onPause();
        mUnityPlayer.pause();
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Resume Unity&lt;/span&gt;
    @Override &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onResume()
    {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onResume();
        mUnityPlayer.resume();
    }

    @Override &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onStart()
    {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onStart();
        mUnityPlayer.start();
    }

    @Override &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onStop()
    {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onStop();
        mUnityPlayer.stop();
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Low Memory Unity&lt;/span&gt;
    @Override &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onLowMemory()
    {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onLowMemory();
        mUnityPlayer.lowMemory();
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Trim Memory Unity&lt;/span&gt;
    @Override &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; onTrimMemory(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; level)
    {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onTrimMemory(level);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (level ==&lt;span&gt; TRIM_MEMORY_RUNNING_CRITICAL)
        {
            mUnityPlayer.lowMemory();
        }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; This ensures the layout will be correct.&lt;/span&gt;
    @Override &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onConfigurationChanged(Configuration newConfig)
    {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onConfigurationChanged(newConfig);
        mUnityPlayer.configurationChanged(newConfig);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Notify Unity of the focus change.&lt;/span&gt;
    @Override &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; onWindowFocusChanged(&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; hasFocus)
    {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onWindowFocusChanged(hasFocus);
        mUnityPlayer.windowFocusChanged(hasFocus);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; For some reason the multiple keyevent type is not supported by the ndk.
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Force event injection by overriding dispatchKeyEvent().&lt;/span&gt;
    @Override &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; dispatchKeyEvent(KeyEvent event)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (event.getAction() ==&lt;span&gt; KeyEvent.ACTION_MULTIPLE)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; mUnityPlayer.injectEvent(event);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.dispatchKeyEvent(event);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Pass any events not handled by (unfocused) views straight to UnityPlayer&lt;/span&gt;
    @Override &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; onKeyUp(&lt;span&gt;int&lt;/span&gt; keyCode, KeyEvent event)     { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; mUnityPlayer.injectEvent(event); }
    @Override &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; onKeyDown(&lt;span&gt;int&lt;/span&gt; keyCode, KeyEvent event)   { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; mUnityPlayer.injectEvent(event); }
    @Override &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; onTouchEvent(MotionEvent event)          { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; mUnityPlayer.injectEvent(event); }
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;API12&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; onGenericMotionEvent(MotionEvent event)  { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; mUnityPlayer.injectEvent(event); }


    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;---------------激励视频监听实现 begin-------------------&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onRewardedVideoAdLoaded() {
        Toast.makeText(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;, &quot;onRewardedVideoAdLoaded&quot;&lt;span&gt;, Toast.LENGTH_SHORT).show();
        showRewardedVideoAd();
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onRewardedVideoAdOpened() {
        Toast.makeText(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;, &quot;onRewardedVideoAdOpened&quot;&lt;span&gt;, Toast.LENGTH_SHORT).show();
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onRewardedVideoStarted() {
        Toast.makeText(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;, &quot;onRewardedVideoStarted&quot;&lt;span&gt;, Toast.LENGTH_SHORT).show();
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onRewardedVideoAdClosed() {
        Toast.makeText(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;, &quot;onRewardedVideoAdClosed&quot;&lt;span&gt;, Toast.LENGTH_SHORT).show();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Load the next rewarded video ad.&lt;/span&gt;
&lt;span&gt;        loadRewardedVideoAd();
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onRewarded(RewardItem reward) {
        Toast.makeText(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;, &quot;onRewarded! currency: &quot; + reward.getType() + &quot;  amount: &quot; +&lt;span&gt;
                reward.getAmount(), Toast.LENGTH_SHORT).show();
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onRewardedVideoAdLeftApplication() {
        Toast.makeText(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;, &quot;onRewardedVideoAdLeftApplication&quot;&lt;span&gt;,
                Toast.LENGTH_SHORT).show();
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; onRewardedVideoAdFailedToLoad(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i) {
        Toast.makeText(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;, &quot;onRewardedVideoAdFailedToLoad&quot;&lt;span&gt;, Toast.LENGTH_SHORT).show();
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onRewardedVideoCompleted() {
        Toast.makeText(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;, &quot;onRewardedVideoCompleted&quot;&lt;span&gt;, Toast.LENGTH_SHORT).show();
    }
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;---------------激励视频监听实现 end-------------------&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;build.gradle&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('54b18b33-b2b6-40aa-8b6d-8ef93ed42b2c')&quot; readability=&quot;36&quot;&gt;&lt;img id=&quot;code_img_closed_54b18b33-b2b6-40aa-8b6d-8ef93ed42b2c&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_54b18b33-b2b6-40aa-8b6d-8ef93ed42b2c&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('54b18b33-b2b6-40aa-8b6d-8ef93ed42b2c',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_54b18b33-b2b6-40aa-8b6d-8ef93ed42b2c&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
//&lt;span&gt; GENERATED BY UNITY. REMOVE THIS COMMENT TO PREVENT OVERWRITING WHEN EXPORTING AGAIN

buildscript {
    repositories {
        google()
        jcenter()
    }

    dependencies {
        classpath &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;com.android.tools.build:gradle:3.2.0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
}
}

allprojects {
    repositories {
        google()
        jcenter()
        flatDir {
            dirs &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;libs&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        }
    }
}

apply plugin: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;com.android.application&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;


dependencies {
    implementation fileTree(dir: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;libs&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, include: [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;*.jar&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
    implementation &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;com.google.android.gms:play-services-ads:18.2.0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
}

android {
    compileSdkVersion &lt;/span&gt;&lt;span&gt;29&lt;/span&gt;&lt;span&gt;
    buildToolsVersion &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;29.0.2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
    }

    defaultConfig {
        minSdkVersion &lt;/span&gt;&lt;span&gt;16&lt;/span&gt;&lt;span&gt;
        targetSdkVersion &lt;/span&gt;&lt;span&gt;29&lt;/span&gt;&lt;span&gt;
        applicationId &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;com.tan.admob&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        ndk {
            abiFilters &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;armeabi-v7a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;x86&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        }
        versionCode &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
        versionName &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    }

    lintOptions {
        abortOnError &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
    }

    aaptOptions {
        noCompress &lt;/span&gt;= [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.unity3d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;.ress&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;.resource&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;.obb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
    }

    buildTypes {
        debug {
            minifyEnabled &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
            useProguard &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
            proguardFiles getDefaultProguardFile(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;proguard-android.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;), &lt;span&gt;'&lt;/span&gt;&lt;span&gt;proguard-unity.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
            jniDebuggable &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
        }
        release {
            minifyEnabled &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
            useProguard &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
            proguardFiles getDefaultProguardFile(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;proguard-android.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;), &lt;span&gt;'&lt;/span&gt;&lt;span&gt;proguard-unity.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
            signingConfig signingConfigs.debug
        }
    }

    packagingOptions {
        doNotStrip &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;*/armeabi-v7a/*.so&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        doNotStrip &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;*/x86/*.so&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    }

    bundle {
        language {
            enableSplit &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;
        }
        density {
            enableSplit &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;
        }
        abi {
            enableSplit &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;AndroidManifest.xml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('5601e876-1f63-48bf-8b91-b83012604b56')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_5601e876-1f63-48bf-8b91-b83012604b56&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_5601e876-1f63-48bf-8b91-b83012604b56&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('5601e876-1f63-48bf-8b91-b83012604b56',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_5601e876-1f63-48bf-8b91-b83012604b56&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;manifest &lt;/span&gt;&lt;span&gt;xmlns:android&lt;/span&gt;&lt;span&gt;=&quot;http://schemas.android.com/apk/res/android&quot;&lt;/span&gt;&lt;span&gt; package&lt;/span&gt;&lt;span&gt;=&quot;com.tan.admob&quot;&lt;/span&gt;&lt;span&gt; xmlns:tools&lt;/span&gt;&lt;span&gt;=&quot;http://schemas.android.com/tools&quot;&lt;/span&gt;&lt;span&gt; android:installLocation&lt;/span&gt;&lt;span&gt;=&quot;preferExternal&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;supports-screens &lt;/span&gt;&lt;span&gt;android:smallScreens&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt; android:normalScreens&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt; android:largeScreens&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt; android:xlargeScreens&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt; android:anyDensity&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;application &lt;/span&gt;&lt;span&gt;android:theme&lt;/span&gt;&lt;span&gt;=&quot;@style/UnityThemeSelector&quot;&lt;/span&gt;&lt;span&gt; android:icon&lt;/span&gt;&lt;span&gt;=&quot;@mipmap/app_icon&quot;&lt;/span&gt;&lt;span&gt; android:label&lt;/span&gt;&lt;span&gt;=&quot;@string/app_name&quot;&lt;/span&gt;&lt;span&gt; android:isGame&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt; android:banner&lt;/span&gt;&lt;span&gt;=&quot;@drawable/app_banner&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;activity &lt;/span&gt;&lt;span&gt;android:label&lt;/span&gt;&lt;span&gt;=&quot;@string/app_name&quot;&lt;/span&gt;&lt;span&gt; android:screenOrientation&lt;/span&gt;&lt;span&gt;=&quot;fullSensor&quot;&lt;/span&gt;&lt;span&gt; android:launchMode&lt;/span&gt;&lt;span&gt;=&quot;singleTask&quot;&lt;/span&gt;&lt;span&gt; android:configChanges&lt;/span&gt;&lt;span&gt;=&quot;mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale|layoutDirection|density&quot;&lt;/span&gt;&lt;span&gt; android:hardwareAccelerated&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt;&lt;span&gt; android:name&lt;/span&gt;&lt;span&gt;=&quot;com.tan.admob.UnityPlayerActivity&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;intent-filter&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;action &lt;/span&gt;&lt;span&gt;android:name&lt;/span&gt;&lt;span&gt;=&quot;android.intent.action.MAIN&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;category &lt;/span&gt;&lt;span&gt;android:name&lt;/span&gt;&lt;span&gt;=&quot;android.intent.category.LAUNCHER&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;category &lt;/span&gt;&lt;span&gt;android:name&lt;/span&gt;&lt;span&gt;=&quot;android.intent.category.LEANBACK_LAUNCHER&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;intent-filter&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta-data &lt;/span&gt;&lt;span&gt;android:name&lt;/span&gt;&lt;span&gt;=&quot;unityplayer.UnityActivity&quot;&lt;/span&gt;&lt;span&gt; android:value&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;activity&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta-data &lt;/span&gt;&lt;span&gt;android:name&lt;/span&gt;&lt;span&gt;=&quot;unity.build-id&quot;&lt;/span&gt;&lt;span&gt; android:value&lt;/span&gt;&lt;span&gt;=&quot;fea8e2f2-427d-4c46-a8ec-f06bef433231&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta-data &lt;/span&gt;&lt;span&gt;android:name&lt;/span&gt;&lt;span&gt;=&quot;unity.splash-mode&quot;&lt;/span&gt;&lt;span&gt; android:value&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta-data &lt;/span&gt;&lt;span&gt;android:name&lt;/span&gt;&lt;span&gt;=&quot;unity.splash-enable&quot;&lt;/span&gt;&lt;span&gt; android:value&lt;/span&gt;&lt;span&gt;=&quot;True&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; Sample AdMob App ID: ca-app-pub-3940256099942544~3347511713 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta-data
        &lt;/span&gt;&lt;span&gt;android:name&lt;/span&gt;&lt;span&gt;=&quot;com.google.android.gms.ads.APPLICATION_ID&quot;&lt;/span&gt;&lt;span&gt;
        android:value&lt;/span&gt;&lt;span&gt;=&quot;ca-app-pub-3940256099942544~3347511713&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;

  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;application&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;uses-feature &lt;/span&gt;&lt;span&gt;android:glEsVersion&lt;/span&gt;&lt;span&gt;=&quot;0x00020000&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;uses-permission &lt;/span&gt;&lt;span&gt;android:name&lt;/span&gt;&lt;span&gt;=&quot;android.permission.INTERNET&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;uses-feature &lt;/span&gt;&lt;span&gt;android:name&lt;/span&gt;&lt;span&gt;=&quot;android.hardware.touchscreen&quot;&lt;/span&gt;&lt;span&gt; android:required&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;uses-feature &lt;/span&gt;&lt;span&gt;android:name&lt;/span&gt;&lt;span&gt;=&quot;android.hardware.touchscreen.multitouch&quot;&lt;/span&gt;&lt;span&gt; android:required&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;uses-feature &lt;/span&gt;&lt;span&gt;android:name&lt;/span&gt;&lt;span&gt;=&quot;android.hardware.touchscreen.multitouch.distinct&quot;&lt;/span&gt;&lt;span&gt; android:required&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;manifest&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

</description>
<pubDate>Sun, 06 Oct 2019 14:42:00 +0000</pubDate>
<dc:creator>子非鱼`</dc:creator>
<og:description>我在上一篇文章&amp;#160;【Unity与Android】01-Unity与Android交互通信的简易实现) 中介绍了Unity与Android通讯的基本方法。 这一篇开始进入应用阶段，这次要介绍的是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/imteach/p/11628838.html</dc:identifier>
</item>
<item>
<title>EF Core 实现读写分离的最佳方案 - KiraYoshikage</title>
<link>http://www.cnblogs.com/KiraYoshikage/p/11628781.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/KiraYoshikage/p/11628781.html</guid>
<description>&lt;h4 id=&quot;前言&quot;&gt;前言&lt;/h4&gt;
&lt;p&gt;公司之前使用Ado.net和Dapper进行数据访问层的操作, 进行读写分离也比较简单, 只要使用对应的数据库连接字符串即可. 而最近要迁移到新系统中,新系统使用.net core和EF Core进行数据访问. 所以趁着国庆假期拿出一两天时间研究了一下如何EF Core进行读写分离.&lt;/p&gt;
&lt;h4 id=&quot;思路&quot;&gt;思路&lt;/h4&gt;
&lt;p&gt;根据园子里的Jeffcky大神的博客, 参考&lt;br/&gt;&lt;a href=&quot;%22https://www.cnblogs.com/CreateMyself/p/9241523.html%22&quot;&gt;EntityFramework Core进行读写分离最佳实践方式，了解一下（一）？&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;%22https://www.cnblogs.com/CreateMyself/p/9261435.html%22&quot;&gt;EntityFramework Core进行读写分离最佳实践方式，了解一下（二）？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最简单的思路就是使用手动切换EF Core上下文的连接, 即context.Database.GetDbConnection().ConnectionString = &quot;xxx&quot;, 但必须要先创建上下文, 再关闭之前的连接, 才能进行切换&lt;br/&gt;另一种方式是通过监听Diagnostic来将进行查询的sql切换到从库执行, 这种方式虽然可以实现无感知的切换操作, 但不能满足公司的业务需求. 在后台管理或其他对数据实时性要求比较高的项目里,查询操作也都应该走主库,而这种方式却会切换到从库去. 另一方面就是假若公司的库比较多,每种业务都对应了一个库, 每个库都对应了一种DbContext, 这种情况下, 要实现自动切换就变得很复杂了.&lt;/p&gt;
&lt;p&gt;上面的两种方式都是从切换数据库连接入手,但是频繁的切换数据库连接势必会对性能造成影响. 我认为最理想的方式是要避免数据库连接的切换, 且能够适应多DbContext的情况, 在创建上下文实例时,就指定好是访问主库还是从库, 而不是在后期再进行数据库切换. 因此, 在上下文实例化时,就传入相应的数据库连接字符串, 这样一来DbContext的创建就需要交由我们自己来进行, 就不是由DI容器进行创建了. 同时仓储应该区分为只读和可读可写两种,以防止其他人对从库进行写操作.&lt;/p&gt;
&lt;h4 id=&quot;实现&quot;&gt;实现&lt;/h4&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;    public interface IReadOnlyRepository&amp;lt;TEntity, TKey&amp;gt;
        where TEntity : class, IEntity&amp;lt;TKey&amp;gt;
        where TKey : IEquatable&amp;lt;TKey&amp;gt;
    {}

    public interface IRepository&amp;lt;TEntity, TKey&amp;gt; : IReadOnlyRepository&amp;lt;TEntity, TKey&amp;gt;
    where TEntity : class, IEntity&amp;lt;TKey&amp;gt;
    where TKey : IEquatable&amp;lt;TKey&amp;gt;
    {}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;IReadOnlyRepository接口是只读仓储接口,提供查询相关方法,IRepository接口是可读可写仓储接口,提供增删查改等方法, 接口的实现就那些东西这里就省略了.&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;    public interface IRepositoryFactory
    {
        IRepository&amp;lt;TEntity, TKey&amp;gt; GetRepository&amp;lt;TEntity, TKey&amp;gt;(IUnitOfWork unitOfWork)
            where TEntity : class, IEntity&amp;lt;TKey&amp;gt;
            where TKey : IEquatable&amp;lt;TKey&amp;gt;;
         IReadOnlyRepository&amp;lt;TEntity, TKey&amp;gt; GetReadOnlyRepository&amp;lt;TEntity, TKey&amp;gt;(IUnitOfWork unitOfWork)
                where TEntity : class, IEntity&amp;lt;TKey&amp;gt;
                where TKey : IEquatable&amp;lt;TKey&amp;gt;;
    }
    public class RepositoryFactory : IRepositoryFactory
    {
        public RepositoryFactory()
        {
        }

        public IRepository&amp;lt;TEntity, TKey&amp;gt; GetRepository&amp;lt;TEntity, TKey&amp;gt;(IUnitOfWork unitOfWork)
            where TEntity : class, IEntity&amp;lt;TKey&amp;gt;
            where TKey : IEquatable&amp;lt;TKey&amp;gt;
        {
            return new Repository&amp;lt;TEntity, TKey&amp;gt;(unitOfWork);
        }

        public IReadOnlyRepository&amp;lt;TEntity, TKey&amp;gt; GetReadOnlyRepository&amp;lt;TEntity, TKey&amp;gt;(IUnitOfWork unitOfWork)
            where TEntity : class, IEntity&amp;lt;TKey&amp;gt;
            where TKey : IEquatable&amp;lt;TKey&amp;gt;
        {
            return new ReadOnlyRepository&amp;lt;TEntity, TKey&amp;gt;(unitOfWork);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;RepositoryFactory提供仓储对象的实例化&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;    public interface IUnitOfWork : IDisposable
    {
        public DbContext DbContext { get; }

        /// &amp;lt;summary&amp;gt;
        /// 获取只读仓储对象
        /// &amp;lt;/summary&amp;gt;
        IReadOnlyRepository&amp;lt;TEntity, TKey&amp;gt; GetReadOnlyRepository&amp;lt;TEntity, TKey&amp;gt;()
            where TEntity : class, IEntity&amp;lt;TKey&amp;gt;
            where TKey : IEquatable&amp;lt;TKey&amp;gt;;

        /// &amp;lt;summary&amp;gt;
        /// 获取仓储对象
        /// &amp;lt;/summary&amp;gt;
        IRepository&amp;lt;TEntity, TKey&amp;gt; GetRepository&amp;lt;TEntity, TKey&amp;gt;()
            where TEntity : class, IEntity&amp;lt;TKey&amp;gt;
            where TKey : IEquatable&amp;lt;TKey&amp;gt;;
        int SaveChanges();
        Task&amp;lt;int&amp;gt; SaveChangesAsync(CancellationToken cancelToken = default);
    }
    
    public class UnitOfWork : IUnitOfWork
    {
        private readonly IServiceProvider _serviceProvider;
        private readonly DbContext _dbContext;
        private readonly IRepositoryFactory _repositoryFactory;
        private bool _disposed;

        public UnitOfWork(IServiceProvider serviceProvider, DbContext context)
        {
            Check.NotNull(serviceProvider, nameof(serviceProvider));
            _serviceProvider = serviceProvider;
            _dbContext = context;
            _repositoryFactory = serviceProvider.GetRequiredService&amp;lt;IRepositoryFactory&amp;gt;();
        }
        public DbContext DbContext { get =&amp;gt; _dbContext; }
        public IReadOnlyRepository&amp;lt;TEntity, TKey&amp;gt; GetReadOnlyRepository&amp;lt;TEntity, TKey&amp;gt;()
            where TEntity : class, IEntity&amp;lt;TKey&amp;gt;
            where TKey : IEquatable&amp;lt;TKey&amp;gt;
        {
            return _repositoryFactory.GetReadOnlyRepository&amp;lt;TEntity, TKey&amp;gt;(this);
        }

        public IRepository&amp;lt;TEntity, TKey&amp;gt; GetRepository&amp;lt;TEntity, TKey&amp;gt;()
            where TEntity : class, IEntity&amp;lt;TKey&amp;gt;
            where TKey : IEquatable&amp;lt;TKey&amp;gt;
        {
            return _repositoryFactory.GetRepository&amp;lt;TEntity, TKey&amp;gt;(this);
        }
        
        public void Dispose()
        {
            if (_disposed)
            {
                return;
            }

            _dbContext?.Dispose();
            _disposed = true;
        }
        
        // 其他略
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;    /// &amp;lt;summary&amp;gt;
    /// 数据库提供者接口
    /// &amp;lt;/summary&amp;gt;
    public interface IDbProvider : IDisposable
    {
        /// &amp;lt;summary&amp;gt;
        /// 根据上下文类型及数据库名称获取UnitOfWork对象, dbName为null时默认为第一个数据库名称
        /// &amp;lt;/summary&amp;gt;
        IUnitOfWork GetUnitOfWork(Type dbContextType, string dbName = null);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;IDbProvider 接口, 根据上下文类型和配置文件中的数据库连接字符串名称创建IUnitOfWork, 在DI中的生命周期是Scoped,在销毁的同时会销毁数据库上下文对象, 下面是它的实现, 为了提高性能使用了Expression来代替反射.&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class DbProvider : IDbProvider
    {
        private readonly IServiceProvider _serviceProvider;
        private readonly ConcurrentDictionary&amp;lt;string, IUnitOfWork&amp;gt; _works = new ConcurrentDictionary&amp;lt;string, IUnitOfWork&amp;gt;();
        private static ConcurrentDictionary&amp;lt;Type, Func&amp;lt;IServiceProvider, DbContextOptions, DbContext&amp;gt;&amp;gt; _expressionFactoryDict =
            new ConcurrentDictionary&amp;lt;Type, Func&amp;lt;IServiceProvider, DbContextOptions, DbContext&amp;gt;&amp;gt;();

        public DbProvider(IServiceProvider serviceProvider)
        {
            _serviceProvider = serviceProvider;
        }

        public IUnitOfWork GetUnitOfWork(Type dbContextType, string dbName = null)
        {
            var key = string.Format(&quot;{0}${1}$&quot;, dbName, dbContextType.FullName);
            IUnitOfWork unitOfWork;
            if (_works.TryGetValue(key, out unitOfWork))
            {
                return unitOfWork;
            }
            else
            {
                DbContext dbContext;
                var dbConnectionOptionsMap = _serviceProvider.GetRequiredService&amp;lt;IOptions&amp;lt;FxOptions&amp;gt;&amp;gt;().Value.DbConnections;
                if (dbConnectionOptionsMap == null || dbConnectionOptionsMap.Count &amp;lt;= 0)
                {
                    throw new Exception(&quot;无法获取数据库配置&quot;);
                }

                DbConnectionOptions dbConnectionOptions = dbName == null ? dbConnectionOptionsMap.First().Value : dbConnectionOptionsMap[dbName];

                var builderOptions = _serviceProvider.GetServices&amp;lt;DbContextOptionsBuilderOptions&amp;gt;()
                     ?.Where(d =&amp;gt; (d.DbName == null || d.DbName == dbName) &amp;amp;&amp;amp; (d.DbContextType == null || d.DbContextType == dbContextType))
                     ?.OrderByDescending(d =&amp;gt; d.DbName)
                     ?.OrderByDescending(d =&amp;gt; d.DbContextType);
                if (builderOptions == null || !builderOptions.Any())
                {
                    throw new Exception(&quot;无法获取匹配的DbContextOptionsBuilder&quot;);
                }

                var dbUser = _serviceProvider.GetServices&amp;lt;IDbContextOptionsBuilderUser&amp;gt;()?.FirstOrDefault(u =&amp;gt; u.Type == dbConnectionOptions.DatabaseType);
                if (dbUser == null)
                {
                    throw new Exception($&quot;无法解析类型为“{dbConnectionOptions.DatabaseType}”的 {typeof(IDbContextOptionsBuilderUser).FullName} 实例&quot;);
                }
                
                var dbContextOptions = dbUser.Use(builderOptions.First().Builder, dbConnectionOptions.ConnectionString).Options;
                if (_expressionFactoryDict.TryGetValue(dbContextType, out Func&amp;lt;IServiceProvider, DbContextOptions, DbContext&amp;gt; factory))
                {
                    dbContext = factory(_serviceProvider, dbContextOptions);
                }
                else
                {
                    // 使用Expression创建DbContext
                    var constructorMethod = dbContextType.GetConstructors()
                        .Where(c =&amp;gt; c.IsPublic &amp;amp;&amp;amp; !c.IsAbstract &amp;amp;&amp;amp; !c.IsStatic)
                        .OrderByDescending(c =&amp;gt; c.GetParameters().Length)
                        .FirstOrDefault();
                    if (constructorMethod == null)
                    {
                        throw new Exception(&quot;无法获取有效的上下文构造器&quot;);
                    }

                    var dbContextOptionsBuilderType = typeof(DbContextOptionsBuilder&amp;lt;&amp;gt;);
                    var dbContextOptionsType = typeof(DbContextOptions);
                    var dbContextOptionsGenericType = typeof(DbContextOptions&amp;lt;&amp;gt;);
                    var serviceProviderType = typeof(IServiceProvider);
                    var getServiceMethod = serviceProviderType.GetMethod(&quot;GetService&quot;);
                    var lambdaParameterExpressions = new ParameterExpression[2];
                    lambdaParameterExpressions[0] = (Expression.Parameter(serviceProviderType, &quot;serviceProvider&quot;));
                    lambdaParameterExpressions[1] = (Expression.Parameter(dbContextOptionsType, &quot;dbContextOptions&quot;));
                    var paramTypes = constructorMethod.GetParameters();
                    var argumentExpressions = new Expression[paramTypes.Length];
                    for (int i = 0; i &amp;lt; paramTypes.Length; i++)
                    {
                        var pType = paramTypes[i];
                        if (pType.ParameterType == dbContextOptionsType ||
                            (pType.ParameterType.IsGenericType &amp;amp;&amp;amp; pType.ParameterType.GetGenericTypeDefinition() == dbContextOptionsGenericType))
                        {
                            argumentExpressions[i] = Expression.Convert(lambdaParameterExpressions[1], pType.ParameterType);
                        }
                        else if (pType.ParameterType == serviceProviderType)
                        {
                            argumentExpressions[i] = lambdaParameterExpressions[0];
                        }
                        else
                        {
                            argumentExpressions[i] = Expression.Call(lambdaParameterExpressions[0], getServiceMethod);
                        }
                    }

                    factory = Expression
                        .Lambda&amp;lt;Func&amp;lt;IServiceProvider, DbContextOptions, DbContext&amp;gt;&amp;gt;(
                            Expression.Convert(Expression.New(constructorMethod, argumentExpressions), typeof(DbContext)), lambdaParameterExpressions.AsEnumerable())
                        .Compile();
                    _expressionFactoryDict.TryAdd(dbContextType, factory);

                    dbContext = factory(_serviceProvider, dbContextOptions);
                }

                var unitOfWorkFactory = _serviceProvider.GetRequiredService&amp;lt;IUnitOfWorkFactory&amp;gt;();
                unitOfWork = unitOfWorkFactory.GetUnitOfWork(_serviceProvider, dbContext);
                _works.TryAdd(key, unitOfWork);
                return unitOfWork;
            }
        }

        public void Dispose()
        {
            if (_works != null &amp;amp;&amp;amp; _works.Count &amp;gt; 0)
            {
                foreach (var unitOfWork in _works.Values)
                    unitOfWork.Dispose();
                _works.Clear();
            }
        }
    }
    
    public static class DbProviderExtensions
    {
        public static IUnitOfWork GetUnitOfWork&amp;lt;TDbContext&amp;gt;(this IDbProvider provider, string dbName = null)
        {
            if (provider == null)
                return null;
            return provider.GetUnitOfWork(typeof(TDbContext), dbName);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;    /// &amp;lt;summary&amp;gt;
    /// 业务系统配置选项
    /// &amp;lt;/summary&amp;gt;
    public class FxOptions
    {
        public FxOptions()
        {
        }

        /// &amp;lt;summary&amp;gt;
        /// 默认数据库类型
        /// &amp;lt;/summary&amp;gt;
        public DatabaseType DefaultDatabaseType { get; set; } = DatabaseType.SqlServer;

        /// &amp;lt;summary&amp;gt;
        /// 数据库连接配置
        /// &amp;lt;/summary&amp;gt;
        public IDictionary&amp;lt;string, DbConnectionOptions&amp;gt; DbConnections { get; set; }

    }
    
    public class FxOptionsSetup: IConfigureOptions&amp;lt;FxOptions&amp;gt;
    {
        private readonly IConfiguration _configuration;

        public FxOptionsSetup(IConfiguration configuration)
        {
            _configuration = configuration;
        }

        /// &amp;lt;summary&amp;gt;
        /// 配置options各属性信息
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;options&quot;&amp;gt;&amp;lt;/param&amp;gt;
        public void Configure(FxOptions options)
        {
            SetDbConnectionsOptions(options);
            // ...
        }

        private void SetDbConnectionsOptions(FxOptions options)
        {
            var dbConnectionMap = new Dictionary&amp;lt;string, DbConnectionOptions&amp;gt;();
            options.DbConnections = dbConnectionMap;
            IConfiguration section = _configuration.GetSection(&quot;FxCore:DbConnections&quot;);
            Dictionary&amp;lt;string, DbConnectionOptions&amp;gt; dict = section.Get&amp;lt;Dictionary&amp;lt;string, DbConnectionOptions&amp;gt;&amp;gt;();
            if (dict == null || dict.Count == 0)
            {
                string connectionString = _configuration[&quot;ConnectionStrings:DefaultDbContext&quot;];
                if (connectionString == null)
                {
                    return;
                }
                dbConnectionMap.Add(&quot;DefaultDb&quot;, new DbConnectionOptions
                {
                    ConnectionString = connectionString,
                    DatabaseType = options.DefaultDatabaseType
                });

                return;
            }

            var ambiguous = dict.Keys.GroupBy(d =&amp;gt; d).FirstOrDefault(d =&amp;gt; d.Count() &amp;gt; 1);
            if (ambiguous != null)
            {
                throw new Exception($&quot;数据上下文配置中存在多个配置节点拥有同一个数据库连接名称，存在二义性：{ambiguous.First()}&quot;);
            }
            foreach (var db in dict)
            {
                dbConnectionMap.Add(db.Key, db.Value);
            }
        }
    }
    
    /// &amp;lt;summary&amp;gt;
    /// DbContextOptionsBuilder配置选项
    /// &amp;lt;/summary&amp;gt;
    public class DbContextOptionsBuilderOptions
    {
        /// &amp;lt;summary&amp;gt;
        /// 配置DbContextOptionsBuilder, dbName指定数据库名称, 为null时表示所有数据库,默认为null
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;build&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;dbName&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;dbContextType&quot;&amp;gt;&amp;lt;/param&amp;gt;
        public DbContextOptionsBuilderOptions(DbContextOptionsBuilder build, string dbName = null, Type dbContextType = null)
        {
            Builder = build;
            DbName = dbName;
            DbContextType = dbContextType;
        }

        public DbContextOptionsBuilder Builder { get; }
        public string DbName { get; }
        public Type DbContextType { get; }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;FxOptions是业务系统的配置选项(随便取得), 在通过service.GetService&amp;lt;IOptions&amp;gt;()时会调用IConfigureOptions完成FxOptions的初始化. DbContextOptionsBuilderOptions用来提供DbContextOptionsBuilder的相关配置&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;    public interface IDbContextOptionsBuilderUser
    {
        /// &amp;lt;summary&amp;gt;
        /// 获取 数据库类型名称，如 SQLSERVER，MYSQL，SQLITE等
        /// &amp;lt;/summary&amp;gt;
        DatabaseType Type { get; }

        /// &amp;lt;summary&amp;gt;
        /// 使用数据库
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;builder&quot;&amp;gt;创建器&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;connectionString&quot;&amp;gt;连接字符串&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        DbContextOptionsBuilder Use(DbContextOptionsBuilder builder, string connectionString);
    }
    
    public class SqlServerDbContextOptionsBuilderUser : IDbContextOptionsBuilderUser
    {
        public DatabaseType Type =&amp;gt; DatabaseType.SqlServer;

        public DbContextOptionsBuilder Use(DbContextOptionsBuilder builder, string connectionString)
        {
            return builder.UseSqlServer(connectionString);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;IDbContextOptionsBuilderUser接口用来适配不同的数据库来源&lt;/p&gt;
&lt;h4 id=&quot;使用&quot;&gt;使用&lt;/h4&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
    &quot;FxCore&quot;: {
        &quot;DbConnections&quot;: {
            &quot;TestDb&quot;: {
                &quot;ConnectionString&quot;: &quot;xxx&quot;,
                &quot;DatabaseType&quot;: &quot;SqlServer&quot;
            },
            &quot;TestDb_Read&quot;: {
                &quot;ConnectionString&quot;: &quot;xxx&quot;,
                &quot;DatabaseType&quot;: &quot;SqlServer&quot;
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;    class Program
    {
        static void Main(string[] args)
        {
            var config = new ConfigurationBuilder()
                 .AddJsonFile(&quot;appsettings.json&quot;)
                 .Build();
            var services = new ServiceCollection()
                .AddSingleton&amp;lt;IConfiguration&amp;gt;(config)
                .AddOptions()
                .AddSingleton&amp;lt;IConfigureOptions&amp;lt;FxOptions&amp;gt;, FxOptionsSetup&amp;gt;()
                .AddScoped&amp;lt;IDbProvider, DbProvider&amp;gt;()
                .AddSingleton&amp;lt;IUnitOfWorkFactory, UnitOfWorkFactory&amp;gt;()
                .AddSingleton&amp;lt;IRepositoryFactory, RepositoryFactory&amp;gt;()
                .AddSingleton&amp;lt;IDbContextOptionsBuilderUser, SqlServerDbContextOptionsBuilderUser&amp;gt;()
                .AddSingleton&amp;lt;DbContextOptionsBuilderOptions&amp;gt;(new DbContextOptionsBuilderOptions(new DbContextOptionsBuilder&amp;lt;TestDbContext&amp;gt;(), null, typeof(TestDbContext)));

            var serviceProvider = services.BuildServiceProvider();

            var dbProvider = serviceProvider.GetRequiredService&amp;lt;IDbProvider&amp;gt;();
            var uow = dbProvider.GetUnitOfWork&amp;lt;TestDbContext&amp;gt;(&quot;TestDb&quot;); // 访问主库

            var repoDbTest = uow.GetRepository&amp;lt;DbTest, int&amp;gt;();
            var obj = new DbTest { Name = &quot;123&quot;, Date = DateTime.Now.Date };
            repoDbTest.Insert(obj);
            uow.SaveChanges();
            
            Console.ReadKey();
            
            var uow2 = dbProvider.GetUnitOfWork&amp;lt;TestDbContext&amp;gt;(&quot;TestDb_Read&quot;);

             var uow2 = dbProvider.GetUnitOfWork&amp;lt;TestDbContext&amp;gt;(&quot;TestDb_Read&quot;); // 访问从库
            var repoDbTest2 = uow2.GetReadOnlyRepository&amp;lt;DbTest, int&amp;gt;();
            var data2 = repoDbTest2.GetFirstOrDefault();
            Console.WriteLine($&quot;id: {data2.Id} name: {data2.Name}&quot;);
            Console.ReadKey();
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里直接用控制台来做一个例子,中间多了一个Console.ReadKey()是因为我本地没有配置主从模式,所以实际上我是先插入数据,然后复制到另一个数据库里,再进行读取的.&lt;/p&gt;
&lt;h4 id=&quot;总结&quot;&gt;总结&lt;/h4&gt;
&lt;p&gt;本文给出的解决方案适用于系统中存在多个不同的上下文,能够适应复杂的业务场景.但对已有代码的侵入性比较大,不知道有没有更好的方案,欢迎一起探讨.&lt;/p&gt;
</description>
<pubDate>Sun, 06 Oct 2019 14:26:00 +0000</pubDate>
<dc:creator>KiraYoshikage</dc:creator>
<og:description>前言 公司之前使用Ado.net和Dapper进行数据访问层的操作, 进行读写分离也比较简单, 只要使用对应的数据库连接字符串即可. 而最近要迁移到新系统中,新系统使用.net core和EF Cor</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/KiraYoshikage/p/11628781.html</dc:identifier>
</item>
<item>
<title>WebGL简易教程(七)：绘制一个矩形体 - charlee44</title>
<link>http://www.cnblogs.com/charlee44/p/11628462.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/charlee44/p/11628462.html</guid>
<description>&lt;p&gt;在上一篇教程&lt;a href=&quot;https://www.cnblogs.com/charlee44/p/11625869.html&quot;&gt;《WebGL简易教程(六)：第一个三维示例(使用模型视图投影变换)》&lt;/a&gt;中，通过使用模型视图投影变换，绘制了一组由远及近的三角形。但是这个示例还是太简单了，这几个三角形的坐标仍然是-1到1之间的坐标，无论如何都是很容易设置参数的，可能并不能很深入的理解模型视图投影变换。&lt;/p&gt;
&lt;p&gt;在这篇教程就更一步，绘制一个稍微复杂一点的实体——矩形体。矩形体很多时候可以用来做三维物体的包围盒，包围盒在很多情况下特别有用，特别是进行UI交互的时候，只要能设置参数让包围盒看见，其三维物体也必定是能被看见的。为了更好的理解模型视图投影变换，特意设置矩形体的坐标为比较大的浮点数。&lt;/p&gt;

&lt;p&gt;改进上一篇教程的JS代码，得到新的代码如下：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// 顶点着色器程序
var VSHADER_SOURCE =
  'attribute vec4 a_Position;\n' + // attribute variable
  'attribute vec4 a_Color;\n' +
  'uniform mat4 u_MvpMatrix;\n' +
  'varying vec4 v_Color;\n' +
  'void main() {\n' +
  '  gl_Position = u_MvpMatrix * a_Position;\n' + // Set the vertex coordinates of the point
  '  v_Color = a_Color;\n' +
  '}\n';

// 片元着色器程序
var FSHADER_SOURCE =
  'precision mediump float;\n' +
  'varying vec4 v_Color;\n' +
  'void main() {\n' +
  '  gl_FragColor = v_Color;\n' +
  '}\n';

//定义一个矩形体：混合构造函数原型模式
function Cuboid(minX, maxX, minY, maxY, minZ, maxZ) {
  this.minX = minX;
  this.maxX = maxX;
  this.minY = minY;
  this.maxY = maxY;
  this.minZ = minZ;
  this.maxZ = maxZ;
}

Cuboid.prototype = {
  constructor: Cuboid,
  CenterX: function () {
    return (this.minX + this.maxX) / 2.0;
  },
  CenterY: function () {
    return (this.minY + this.maxY) / 2.0;
  },
  CenterZ: function () {
    return (this.minZ + this.maxZ) / 2.0;
  },
  LengthX: function () {
    return (this.maxX - this.minX);
  },
  LengthY: function () {
    return (this.maxY - this.minY);
  }
}

var currentAngle = [35.0, 30.0]; // 绕X轴Y轴的旋转角度 ([x-axis, y-axis])
var curScale = 1.0;   //当前的缩放比例

function main() {
  // 获取 &amp;lt;canvas&amp;gt; 元素
  var canvas = document.getElementById('webgl');

  // 获取WebGL渲染上下文
  var gl = getWebGLContext(canvas);
  if (!gl) {
    console.log('Failed to get the rendering context for WebGL');
    return;
  }

  // 初始化着色器
  if (!initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE)) {
    console.log('Failed to intialize shaders.');
    return;
  }

  // 设置顶点位置
  var cuboid = new Cuboid(399589.072, 400469.072, 3995118.062, 3997558.062, 732, 1268);
  var n = initVertexBuffers(gl, cuboid);
  if (n &amp;lt; 0) {
    console.log('Failed to set the positions of the vertices');
    return;
  }

  // 指定清空&amp;lt;canvas&amp;gt;的颜色
  gl.clearColor(0.0, 0.0, 0.0, 1.0);

  // 开启深度测试
  gl.enable(gl.DEPTH_TEST);

  //绘制函数
  var tick = function () {
    //设置MVP矩阵
    setMVPMatrix(gl, canvas, cuboid);

    //清空颜色和深度缓冲区
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    //绘制矩形体
    gl.drawElements(gl.TRIANGLES, n, gl.UNSIGNED_BYTE, 0);

    //请求浏览器调用tick
    requestAnimationFrame(tick);  
  };

  //开始绘制
  tick();

  // 绘制矩形体
  gl.drawElements(gl.TRIANGLES, n, gl.UNSIGNED_BYTE, 0);
}

//设置MVP矩阵
function setMVPMatrix(gl, canvas, cuboid) {
  // Get the storage location of u_MvpMatrix
  var u_MvpMatrix = gl.getUniformLocation(gl.program, 'u_MvpMatrix');
  if (!u_MvpMatrix) {
    console.log('Failed to get the storage location of u_MvpMatrix');
    return;
  }

  //模型矩阵
  var modelMatrix = new Matrix4();
  modelMatrix.scale(curScale, curScale, curScale);
  modelMatrix.rotate(currentAngle[0], 1.0, 0.0, 0.0); // Rotation around x-axis 
  modelMatrix.rotate(currentAngle[1], 0.0, 1.0, 0.0); // Rotation around y-axis 
  modelMatrix.translate(-cuboid.CenterX(), -cuboid.CenterY(), -cuboid.CenterZ());

  //投影矩阵
  var fovy = 60;
  var near = 1;
  var projMatrix = new Matrix4();
  projMatrix.setPerspective(fovy, canvas.width / canvas.height, 1, 10000);

  //计算lookAt()函数初始视点的高度
  var angle = fovy / 2 * Math.PI / 180.0;  
  var eyeHight = (cuboid.LengthY() * 1.2) / 2.0 / angle;

  //视图矩阵  
  var viewMatrix = new Matrix4();  // View matrix   
  viewMatrix.lookAt(0, 0, eyeHight, 0, 0, 0, 0, 1, 0);

  //MVP矩阵
  var mvpMatrix = new Matrix4();
  mvpMatrix.set(projMatrix).multiply(viewMatrix).multiply(modelMatrix);

  //将MVP矩阵传输到着色器的uniform变量u_MvpMatrix
  gl.uniformMatrix4fv(u_MvpMatrix, false, mvpMatrix.elements);
}

//
function initVertexBuffers(gl, cuboid) {
  // Create a cube
  //    v6----- v5
  //   /|      /|
  //  v1------v0|
  //  | |     | |
  //  | |v7---|-|v4
  //  |/      |/
  //  v2------v3
  // 顶点坐标和颜色
  var verticesColors = new Float32Array([
    cuboid.maxX, cuboid.maxY, cuboid.maxZ, 1.0, 1.0, 1.0,  // v0 White
    cuboid.minX, cuboid.maxY, cuboid.maxZ, 1.0, 0.0, 1.0,  // v1 Magenta
    cuboid.minX, cuboid.minY, cuboid.maxZ, 1.0, 0.0, 0.0,  // v2 Red
    cuboid.maxX, cuboid.minY, cuboid.maxZ, 1.0, 1.0, 0.0,  // v3 Yellow
    cuboid.maxX, cuboid.minY, cuboid.minZ, 0.0, 1.0, 0.0,  // v4 Green
    cuboid.maxX, cuboid.maxY, cuboid.minZ, 0.0, 1.0, 1.0,  // v5 Cyan
    cuboid.minX, cuboid.maxY, cuboid.minZ, 0.0, 0.0, 1.0,  // v6 Blue
    cuboid.minX, cuboid.minY, cuboid.minZ, 1.0, 0.0, 1.0   // v7 Black
  ]);

  //顶点索引
  var indices = new Uint8Array([
    0, 1, 2, 0, 2, 3,    // 前
    0, 3, 4, 0, 4, 5,    // 右
    0, 5, 6, 0, 6, 1,    // 上
    1, 6, 7, 1, 7, 2,    // 左
    7, 4, 3, 7, 3, 2,    // 下
    4, 7, 6, 4, 6, 5     // 后
  ]);

  //
  var FSIZE = verticesColors.BYTES_PER_ELEMENT;   //数组中每个元素的字节数

  // 创建缓冲区对象
  var vertexColorBuffer = gl.createBuffer();
  var indexBuffer = gl.createBuffer();
  if (!vertexColorBuffer || !indexBuffer) {
    console.log('Failed to create the buffer object');
    return -1;
  }

  // 将缓冲区对象绑定到目标
  gl.bindBuffer(gl.ARRAY_BUFFER, vertexColorBuffer);
  // 向缓冲区对象写入数据
  gl.bufferData(gl.ARRAY_BUFFER, verticesColors, gl.STATIC_DRAW);

  //获取着色器中attribute变量a_Position的地址 
  var a_Position = gl.getAttribLocation(gl.program, 'a_Position');
  if (a_Position &amp;lt; 0) {
    console.log('Failed to get the storage location of a_Position');
    return -1;
  }
  // 将缓冲区对象分配给a_Position变量
  gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, FSIZE * 6, 0);

  // 连接a_Position变量与分配给它的缓冲区对象
  gl.enableVertexAttribArray(a_Position);

  //获取着色器中attribute变量a_Color的地址 
  var a_Color = gl.getAttribLocation(gl.program, 'a_Color');
  if (a_Color &amp;lt; 0) {
    console.log('Failed to get the storage location of a_Color');
    return -1;
  }
  // 将缓冲区对象分配给a_Color变量
  gl.vertexAttribPointer(a_Color, 3, gl.FLOAT, false, FSIZE * 6, FSIZE * 3);
  // 连接a_Color变量与分配给它的缓冲区对象
  gl.enableVertexAttribArray(a_Color);

  // 将顶点索引写入到缓冲区对象
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

  return indices.length;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码的流程与上一篇的JS代码基本一致，着色器部分也基本没有变化。应该关注的主要有两点：通过顶点索引绘制物体和MVP矩阵的设置。&lt;/p&gt;
&lt;h2 id=&quot;顶点索引绘制&quot;&gt;2.1. 顶点索引绘制&lt;/h2&gt;
&lt;p&gt;如果通过前面的知识进行绘制一个矩形体，一个矩形有6个面，每个面有2个三角形，每个三角形有3个点，也就意味着需要定义36个顶点。但是我们知道一个矩形体只需要有8个顶点就可以了，定义36个顶点意味着内存和显存的浪费。为了解决这个问题，WebGL提供了通过顶点索引进行绘制的方法：gl.drawElements()。其函数的定义如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1000410/201910/1000410-20191006210519246-761533703.png&quot; alt=&quot;1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在本示例中，首先定义了一个描述矩形体的对象,并且根据其参数，定义了其顶点数组，包含了XYZ信息和颜色信息。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;//定义一个矩形体：混合构造函数原型模式
function Cuboid(minX, maxX, minY, maxY, minZ, maxZ) {
  this.minX = minX;
  this.maxX = maxX;
  this.minY = minY;
  this.maxY = maxY;
  this.minZ = minZ;
  this.maxZ = maxZ;
}

Cuboid.prototype = {
  constructor: Cuboid,
  CenterX: function () {
    return (this.minX + this.maxX) / 2.0;
  },
  CenterY: function () {
    return (this.minY + this.maxY) / 2.0;
  },
  CenterZ: function () {
    return (this.minZ + this.maxZ) / 2.0;
  },
  LengthX: function () {
    return (this.maxX - this.minX);
  },
  LengthY: function () {
    return (this.maxY - this.minY);
  }
}

//...

// 顶点坐标和颜色
var verticesColors = new Float32Array([
  cuboid.maxX, cuboid.maxY, cuboid.maxZ, 1.0, 1.0, 1.0,  // v0 White
  cuboid.minX, cuboid.maxY, cuboid.maxZ, 1.0, 0.0, 1.0,  // v1 Magenta
  cuboid.minX, cuboid.minY, cuboid.maxZ, 1.0, 0.0, 0.0,  // v2 Red
  cuboid.maxX, cuboid.minY, cuboid.maxZ, 1.0, 1.0, 0.0,  // v3 Yellow
  cuboid.maxX, cuboid.minY, cuboid.minZ, 0.0, 1.0, 0.0,  // v4 Green
  cuboid.maxX, cuboid.maxY, cuboid.minZ, 0.0, 1.0, 1.0,  // v5 Cyan
  cuboid.minX, cuboid.maxY, cuboid.minZ, 0.0, 0.0, 1.0,  // v6 Blue
  cuboid.minX, cuboid.minY, cuboid.minZ, 1.0, 0.0, 1.0   // v7 Black
]);

//...
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如之前的代码一样，顶点和颜色数组都传递给顶点缓冲器对象。不同的是这里还定义了一个顶点索引数组：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;//顶点索引
var indices = new Uint8Array([
  0, 1, 2, 0, 2, 3,    // 前
  0, 3, 4, 0, 4, 5,    // 右
  0, 5, 6, 0, 6, 1,    // 上
  1, 6, 7, 1, 7, 2,    // 左
  7, 4, 3, 7, 3, 2,    // 下
  4, 7, 6, 4, 6, 5     // 后
]);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个数组才真正定义了矩形体中三角形的绘制顺序，每个三角形的顶点都由在顶点数组的索引值来代替，交给WebGL去识别，如图所示：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1000410/201910/1000410-20191006210537894-753029909.png&quot; alt=&quot;2&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同样的，这个顶点索引数组也应该传递到缓冲区对象。只不过不绑定到gl.ARRAY_BUFFER上而绑定到gl.ELEMENT_ARRAY_BUFFER上。这个参数表示，该缓冲区的内容是顶点的索引值数据。相关代码如下：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// 创建缓冲区对象
var indexBuffer = gl.createBuffer();

//...

// 将顶点索引写入到缓冲区对象
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后，通过上述的gl.drawElements()函数绘制出来：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// 绘制矩形体
gl.drawElements(gl.TRIANGLES, n, gl.UNSIGNED_BYTE, 0);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过顶点索引的方式绘制三维物体，能够很明显的节约内存和显存的开销，三维物体的共点情况越多，越应该采用这种方式。&lt;/p&gt;
&lt;h2 id=&quot;mvp矩阵设置&quot;&gt;2.2. MVP矩阵设置&lt;/h2&gt;
&lt;p&gt;MVP矩阵的设置同样放置在setMVPMatrix()函数中。&lt;/p&gt;
&lt;h3 id=&quot;模型矩阵&quot;&gt;2.2.1. 模型矩阵&lt;/h3&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var currentAngle = [35.0, 30.0]; // 绕X轴Y轴的旋转角度 ([x-axis, y-axis])
var curScale = 1.0;   //当前的缩放比例

//...

//模型矩阵
var modelMatrix = new Matrix4();
modelMatrix.scale(curScale, curScale, curScale);
modelMatrix.rotate(currentAngle[0], 1.0, 0.0, 0.0); // Rotation around x-axis 
modelMatrix.rotate(currentAngle[1], 0.0, 1.0, 0.0); // Rotation around y-axis 
modelMatrix.translate(-cuboid.CenterX(), -cuboid.CenterY(), -cuboid.CenterZ());&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在模型矩阵中，先将矩形体的中心平移到坐标系的原点，然后绕X轴旋转35度，绕Y轴旋转30度，最后保持缩放比例不变。&lt;/p&gt;
&lt;h3 id=&quot;投影矩阵&quot;&gt;2.2.2. 投影矩阵&lt;/h3&gt;
&lt;p&gt;一般来说，透视投影矩阵的参数是不太容易设置，一般可以设定为经验值固定不变（不绝对）。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;//投影矩阵
var fovy = 60;
var near = 1;
var projMatrix = new Matrix4();
projMatrix.setPerspective(fovy, canvas.width / canvas.height, 1, 10000);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;视图矩阵&quot;&gt;2.2.3. 视图矩阵&lt;/h3&gt;
&lt;p&gt;然后通过前面的参数，设置视图矩阵，让视图中正好可以显示该矩形体：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;//计算lookAt()函数初始视点的高度
var angle = fovy / 2 * Math.PI / 180.0;  
var eyeHight = (cuboid.LengthY() * 1.2) / 2.0 / angle;

//视图矩阵  
var viewMatrix = new Matrix4();  // View matrix   
viewMatrix.lookAt(0, 0, eyeHight, 0, 0, 0, 0, 1, 0);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对lookat()函数来说，观察点是已经坐标系的原点，也就是矩形体的中心位置（矩形体已经被平移了）;上方向一般都是默认的经验值(0,1,0);那么关键就是求视点的位置，进一步来说就是视高的位置。&lt;/p&gt;
&lt;p&gt;那么根据透视投影设置的垂直张角，可以求得视高，如图所示：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1000410/201902/1000410-20190217231117876-1480964252.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;很明显的看出，当光线射到包围盒的中心，包围盒Y方向长度的一半，除以视点高，就是fovy一半的正切值。这就是以上代码中求得eyeHight的由来。&lt;/p&gt;
&lt;h3 id=&quot;mvp矩阵&quot;&gt;2.2.4. MVP矩阵&lt;/h3&gt;
&lt;p&gt;将模型矩阵、视图矩阵、投影矩阵级联起来，得到MVP矩阵：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;//MVP矩阵
var mvpMatrix = new Matrix4();
mvpMatrix.set(projMatrix).multiply(viewMatrix).multiply(modelMatrix);&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;在浏览器中打开对应的HTML，可以看见一个彩色的矩形体。运行结果如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1000410/201910/1000410-20191006210554810-1743671112.png&quot; alt=&quot;3&quot;/&gt;&lt;/p&gt;

&lt;p&gt;本来部分代码和插图来自《WebGL编程指南》，源代码链接：&lt;a href=&quot;https://github.com/fafa1899/WebGLTutorial&quot;&gt;地址&lt;/a&gt; 。会在此共享目录中持续更新后续的内容。&lt;/p&gt;
</description>
<pubDate>Sun, 06 Oct 2019 13:09:00 +0000</pubDate>
<dc:creator>charlee44</dc:creator>
<og:description>通过一个绘制矩形包围盒的实例，进一步理解了模型视图投影变换。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/charlee44/p/11628462.html</dc:identifier>
</item>
<item>
<title>梯度下降法gradient descent的发展历史与各版本 - dynmi</title>
<link>http://www.cnblogs.com/dynmi/p/11627292.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dynmi/p/11627292.html</guid>
<description>&lt;p&gt;　　梯度下降法作为一种反向传播算法最早在上世纪由geoffrey hinton等人提出并被广泛接受。最早GD由很多研究团队各自发表，可他们大多无人问津，而hinton做的研究完整表述了GD方法，同时hinton为自己的研究多次走动人际关系使得其论文出现在了当时的《nature》上，从此GD开始得到业界的关注。这为后面各种改进版GD的出现与21世纪深度学习的大爆发奠定了最重要的基础。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;PART1：original版的梯度下降法&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　首先已经有了 对weights和bias初始化过的神经网络计算图，也有一套训练集。&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;22&quot;&gt;
&lt;div readability=&quot;39&quot;&gt;　　接下来，代入x(i)后，y^(i)即表示为weights和bias 的函数，然后根据公式，cost function J(w,b,.......)=1/m * （全部Loss(y^(i),y(i))求和）+正则化项，这时我的cost fuction便已表示为全部weights和bias的函数。接下来对每个weight和bias求偏导，再利用梯度下降法与链式法则去优化我的参数（附一个我自己写的伪码）&lt;br/&gt;&lt;img src=&quot;http://a2.qpic.cn/psb?/V129o2Zf3HBiX4/e4TjdfGff.HPnTt7KDhGaLnom8VtGWk33kuwiLmb2SI!/b/dIUBAAAAAAAA&amp;amp;ek=1&amp;amp;kp=1&amp;amp;pt=0&amp;amp;bo=xAJOAcQCTgEDByI!&amp;amp;tl=1&amp;amp;su=0226414577&amp;amp;tm=1570338000&amp;amp;sce=0-12-12&amp;amp;rf=2-9&quot; alt=&quot;图片&quot; data-albumpriv=&quot;undefined&quot; data-from=&quot;web&quot; data-img-idx=&quot;0&quot; data-src=&quot;http://a2.qpic.cn/psb?/V129o2Zf3HBiX4/e4TjdfGff.HPnTt7KDhGaLnom8VtGWk33kuwiLmb2SI!/b/dIUBAAAAAAAA&amp;amp;ek=1&amp;amp;kp=1&amp;amp;pt=0&amp;amp;bo=xAJOAcQCTgEDByI!&amp;amp;tl=1&amp;amp;su=0226414577&amp;amp;tm=1570338000&amp;amp;sce=0-12-12&amp;amp;rf=2-9&quot;/&gt;&lt;br/&gt;然后补充一下 具体training set 是如何投进去的：&lt;br/&gt;如果我们训练集总共就几千个或者说不到几千个样本，那直接把它喂给神经网络就行（让m等于training set总样本数）。&lt;br/&gt;但往往training set样本数是几万上百万的，这时一口气全部喂进去就太累了，我们往往采取分batch的方法投放数据集，即把数据集分成一撮撮（类比分治算法，类比一大堆草要剁，我把草分成一捆捆放到铡刀上）：&lt;br/&gt;记每堆数据有m个样本，training set总样本数为M&lt;br/&gt;    当m=1时，也就是一次GD训练走一个样本，有点奢侈哈哈哈，称为随机(stochastic)梯度下降法。&lt;br/&gt;此时cost function J(w,b,.......)=LOSS(y^,y)+正则化项&lt;br/&gt;    当m=M时，也就是一次GD训练走全部样本，称为batch梯度下降法。&lt;br/&gt;此时cost function J(w,b,.......)=1/M * (全部Loss(y^(i),y(i))求和)+正则化项&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;     当m介于两者之间时，称为minibatch梯度下降法。&lt;/p&gt;&lt;p&gt;　　这三种方法是最基础的梯度下降法，随机GD缺点是会失去向量化带来的加速，导致整体下来速度慢(当然它是单次训练最快的哈哈哈)，而且会跳上来跳下去的，不太喜欢它，在训练接近尾声时，它的结果并非完全收敛，而是波动的，这一点可通过动态增大减小learningrate来调节，另外随机GD可以用作在线学习，这算一个特色吧。batchGD缺点是训练总样本大时单次迭代时间太长导致整个训练过程耗时久，机子卡死，坑爹啊。所以一般我们都用minibatch法来跑GD，这样可以手动(也有自动调每个batch的m大小的，我就不在这写了)控制我们的GD。&lt;/p&gt;
&lt;p&gt;　　可阅读1986年的经典之作：&lt;a class=&quot;gsc_a_at&quot; href=&quot;https://apps.dtic.mil/dtic/tr/fulltext/u2/a164453.pdf&quot; data-href=&quot;/citations?view_op=view_citation&amp;amp;hl=zh-CN&amp;amp;user=JicYPdAAAAAJ&amp;amp;citation_for_view=JicYPdAAAAAJ:GFxP56DSvIMC&quot;&gt;Learning internal representations by error-propagation， by David Rumelhart，GeoffreyHinton&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;PART2：进阶版GD--momentum动量梯度下降法&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////&lt;/p&gt;
&lt;p&gt;　　在正式讲它之前，我们先介绍一种表示平均值的数学概念------滑动平均，也叫指数加权移动平均（Exponentially Weighted Moving Average）&lt;/p&gt;
&lt;p&gt;　　现在有一组数据，需要找一个数来代表这组数据的平均水平，那么大多数人肯定想都不用想，所有数加起来然后除以数的个数,也可以叫做求期望。但是这种方法在计算机中并不友好。首先它需要一定的存储空间来保存这组数据，另外还要进行一次运算来算得平均数，如果数据量很大那么计算也会略有延时。为了克服这些问题，我们采用了一种新方法来表示一组数据的平均水平，即指数加权移动平均。&lt;/p&gt;
&lt;p&gt;　　这里引入了一个新变量v与人设参数β。核心公式为  &lt;strong&gt;v&lt;sub&gt;t&lt;/sub&gt;=β * v&lt;sub&gt;t-1&lt;/sub&gt; + (1-β) * θ &lt;/strong&gt;&lt;sub&gt;&lt;strong&gt;t &lt;/strong&gt;  &lt;/sub&gt;，θ &lt;sub&gt;t&lt;/sub&gt; 是当前第t个原始数据，以v&lt;sub&gt;t&lt;/sub&gt;代表前t个数据的平均水平，v&lt;sub&gt;t-1&lt;/sub&gt; 表示前t-1个数据的平均水平，β为更新参数，由人为指定。当β趋于1时v的走势趋于直线，跟原始数据的相关性弱；当β趋于0时v的走势趋于原始数据走势，跟原始数据的相关性强。如果有看过吴恩达cousera深度学习课程的同学肯定见过他举的气温变化例子的折线图，这里就不列出来了。 一般v&lt;sub&gt;0&lt;/sub&gt;设置为0。&lt;/p&gt;
&lt;p&gt;　　这一概念不仅在反向传播中有应用，RL领域中MC方法和TD方法更新Q(s,a)和V(s)的公式也是以EMA为基础提出的。可以说EMA在CS中应用广泛。&lt;/p&gt;
&lt;p&gt;////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////&lt;/p&gt;
&lt;p&gt;　　使用PART1中的梯度下降法，必然会遇到一个问题：迭代的时候老是震荡，不能尽快收敛到最优点（如下图）。然而通过更改学习率a不能很好的解决这个问题。为了找到更牛逼的反向传播方法，开始有人把EMA用到GD迭代上，从而诞生了GD的改进版本---动量梯度下降法。&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1705789/201910/1705789-20191006143302109-1976911670.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　下面是momentumGD的参数更新方法：&lt;/p&gt;
&lt;p&gt;　　v&lt;sub&gt;t&lt;/sub&gt;  = β * v&lt;sub&gt;t-1&lt;/sub&gt; + (1-β) * dw&lt;sub&gt;t &lt;/sub&gt;&lt;/p&gt;
&lt;p&gt;　　v&lt;sub&gt;t&lt;/sub&gt;  = β * v&lt;sub&gt;t-1&lt;/sub&gt; + (1-β) * db&lt;sub&gt;t &lt;/sub&gt;&lt;/p&gt;
&lt;p&gt;　　w = w - a * v&lt;sub&gt;t&lt;/sub&gt;  &lt;sub&gt; &lt;/sub&gt;&lt;/p&gt;
&lt;p&gt;　　b = b - a * v&lt;sub&gt;t &lt;/sub&gt;&lt;/p&gt;
&lt;p&gt;　　这样通过引入动量v来预示最优点和当前位置的相对方向，便有效地遏制了之前更新过程中的震动，降低了整体优化耗时。（见下图）&lt;/p&gt;
&lt;p&gt;　　温馨提示：momentum与SGD搭配使用更酸爽哦&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1705789/201910/1705789-20191006143308993-786635013.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;PART3：momentum的改进版---NAG(Nesterov accelerated gradient)&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　这名字听起来逼格很高有没有。其实也没啥厉害的，就是在momentum基础上改动了一下，但是它确实加速了收敛。&lt;/p&gt;
&lt;p&gt;　　下面是NAG的迭代公式：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1705789/201910/1705789-20191006151038444-1898420824.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　进一步推导，得到：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1705789/201910/1705789-20191006151801527-1463854960.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　（其中d相当于momentum的v，θ则是要更新的参数，a是学习率）&lt;/p&gt;
&lt;p&gt;　　从等价形式看，NAG在momentum基础上多了一个 &lt;strong&gt;β [ g(θ&lt;sub&gt;i-1&lt;/sub&gt;) - g(θ &lt;sub&gt;i-2 &lt;/sub&gt;) ]&lt;/strong&gt; 。意义已经很明显了：如果这次梯度比上次梯度变大了，那么有理由相信它会继续大下去，如果这次梯度比上次梯度变小了，那么有理由相信它会继续小下去。是不是想起来了牛顿法？？没错，用的都是二阶导的思想。通过这一改动无疑成功加速了收敛。&lt;/p&gt;
&lt;p&gt;　　下面这张图来自hinton的课程ppt，可以帮助理解，其中蓝线是momentum，绿线是NAG。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1705789/201910/1705789-20191006152550135-1459488887.png&quot; alt=&quot;&quot; width=&quot;871&quot; height=&quot;251&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　从全局收敛的视角对比momentum和NAG：（上面为momentum，下面为NAG）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1705789/201910/1705789-20191006152805763-346307141.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1705789/201910/1705789-20191006152912901-1444150314.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;PART4：Adagrad与Adadelta&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　前面两个算法是在梯度更新上做了改动，下面要说的Adagrad与Adadelta则是在学习率上做了改动。Adagrad能自适应地为各个参数分配不同学习率，解决了不同参数应该使用不同更新速率的问题。&lt;/p&gt;
&lt;p&gt;　　下面是Adagrad的更新公式：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1705789/201910/1705789-20191006155335713-822462457.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　其中θ &lt;sub&gt;i,t &lt;/sub&gt; 表示第i个参数第t次迭代时的值，η是人设学习率，G&lt;sub&gt;i,t &lt;/sub&gt;是第i个参数到第t次迭代时的梯度累加量，G&lt;sub&gt;i,t &lt;/sub&gt;=G&lt;sub&gt;i,t-1 &lt;/sub&gt;+ h * h&lt;sup&gt;T  &lt;/sup&gt;(其中h为当前参数的梯度向量)。ε是人为设定的辅助值，用来防止G为0时程序报错。&lt;/p&gt;
&lt;p&gt;　　通过用&lt;img src=&quot;https://img2018.cnblogs.com/blog/1705789/201910/1705789-20191006160229423-610248889.png&quot; alt=&quot;&quot; width=&quot;60&quot; height=&quot;35&quot;/&gt;来代替之前静态的学习率a，我们达到了随迭代次数增加学习率减小的效果。Adagrad 在数据分布稀疏的场景能更好利用稀疏梯度的信息，相比 SGD能更有效地收敛。而它的缺点也十分明显，随着时间的增加，它的分母项越来越大，最终导致学习率收缩到太小无法进行有效更新。&lt;/p&gt;
&lt;p&gt;　　在Adagra基础上，google的研究人员做了一些改进从而得到了Adadelta。&lt;/p&gt;
&lt;p&gt;　　其对参数的更新方法如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1705789/201910/1705789-20191006161544248-888943173.png&quot; alt=&quot;&quot; width=&quot;688&quot; height=&quot;356&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　下图是四种方法在mnist数据集上的对比图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1705789/201910/1705789-20191006162830427-1667662167.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　如果想进一步了解adadelta，可在此处查看原作：&lt;a href=&quot;https://arxiv.org/pdf/1212.5701.pdf&quot; target=&quot;_blank&quot;&gt;ADADELTA: An Adaptive Learning Rate Method&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;PART5：均方根传播(RMSprop)&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　RMSprop是hinton在他的课程中讲述的一种方法，跟上面说的Adadelta基本相似，&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　每次迭代中，针对待优化参数θ：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　1、计算其梯度dθ ；&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　2、计算S&lt;sub&gt;dθ&lt;/sub&gt; =β * S&lt;sub&gt;dθ&lt;/sub&gt; + (1-β) * dθ&lt;sup&gt;2 &lt;/sup&gt;；&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　3、进行优化&lt;img src=&quot;https://img2018.cnblogs.com/blog/1705789/201910/1705789-20191006165345807-1586830505.jpg&quot; alt=&quot;&quot; width=&quot;174&quot; height=&quot;54&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　通过使用梯度平方的指数衰减学习率，RMSprop也对不同参数采用了不同更新速率。Hinton本人建议设置β为0.9，设置起始学习率a为0.001。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;PART6：Adam&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;　　把RMSprop和momentum结合到一起，便得到了强大的‘、目前最常用的Adam优化方法。该方法由OpenAI 的 Diederik Kingma 和多伦多大学的 Jimmy Ba 在2015年提交到ICLR的论文&lt;a href=&quot;https://arxiv.org/pdf/1412.6980v8.pdf&quot; target=&quot;_blank&quot;&gt;Adam：a method for stochastic optimation&lt;/a&gt; 提出，相较于以上其他算法，该方法还有着很好的稀疏梯度和噪声问题处理能力。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　算法实现步骤：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1705789/201910/1705789-20191006180926378-167569192.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Adam 的默认超参数配置：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;Adam的一大优点就是不怎么需要调参，此处只是对超参作一个简单说明和推荐设置。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;a：学习率或步长，它控制了权重的更新比率（如 0.001）。较大的值（如 0.3）在学习率更新前会有更快的初始学习，而较小的值（如 1.0E-5）会令训练收敛到更好的性能。&lt;/li&gt;
&lt;li&gt;β&lt;sub&gt;1&lt;/sub&gt;：一阶矩估计的指数衰减率（如 0.9）。&lt;/li&gt;
&lt;li&gt;β&lt;sub&gt;2&lt;/sub&gt;：二阶矩估计的指数衰减率（如 0.999）。该超参数在稀疏梯度（如在 NLP 或计算机视觉任务中）中应该设置为接近 1 的数。&lt;/li&gt;
&lt;li&gt;ε：最不重要但也不可或缺的超参数，其为了防止在实现中除以零（如 10E-8）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;在CIFAR10数据集上，Adam和其他算法的表现：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1705789/201910/1705789-20191006181703557-205543116.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;PART7：AdaMAX&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　这是Adam的拓展版本。&lt;/p&gt;
&lt;p&gt;　　在Adam中，单个参数的更新规则是将其梯度与当前和过去梯度的L2范数成反比例缩放。把这里的L2范数泛化到Lp范数也不是不可，尽管这里的变体会因为p值的变大而在数值上变得不稳定，但在特例中令p趋于无穷便得到了一个稳定又简单的算法。此时时间 t 时的步长和 v&lt;sub&gt;t&lt;/sub&gt;^(1/p) 成反比例变化。&lt;/p&gt;
&lt;p&gt;　　算法实现步骤：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1705789/201910/1705789-20191006183046130-1400480604.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　AdaMax 参数更新的量级要比 Adam 更简单，|∆t| ≤ α。&lt;/p&gt;
&lt;p&gt; =============================================================================================================&lt;/p&gt;
&lt;p&gt; =============================================================================================================&lt;/p&gt;

&lt;p&gt;最后放一个十分直观的汇总比较，该图像由Sebastian Ruder制作：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1705789/201910/1705789-20191006154127879-1831045304.gif&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1705789/201910/1705789-20191006154136479-1205400237.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;两幅图片来自&lt;a href=&quot;http://ruder.io/optimizing-gradient-descent/index.html&quot; target=&quot;_blank&quot;&gt;Sebastian RuderAn overview of gradient descent optimization algorithms&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 06 Oct 2019 10:33:00 +0000</pubDate>
<dc:creator>dynmi</dc:creator>
<og:description>梯度下降法作为一种反向传播算法最早在上世纪由geoffrey hinton等人提出并被广泛接受。最早GD由很多研究团队各自发表，可他们大多无人问津，而hinton做的研究完整表述了GD方法，同时hin</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/dynmi/p/11627292.html</dc:identifier>
</item>
<item>
<title>深入了解String，StringBuffer和StringBuilder三个类的异同 - 小菜两碟</title>
<link>http://www.cnblogs.com/airnew/p/11628017.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/airnew/p/11628017.html</guid>
<description>&lt;p&gt;Java提供了三个类，用于处理字符串，分别是String、StringBuffer和StringBuilder。其中StringBuilder是jdk1.5才引入的。&lt;/p&gt;
&lt;p&gt;这三个类有什么区别呢？他们的使用场景分别是什么呢？&lt;/p&gt;
&lt;p&gt;本文的代码是在jdk12上运行的，jdk12和jdk5,jdk8有很大的区别，特别是String、StringBuffer和StringBuilder的实现。&lt;/p&gt;
&lt;p&gt;jdk5和jdk8中String类的value类型是char[]，到了jdk12，value类型变为byte[]。&lt;/p&gt;
&lt;p&gt;jdk5、JDK6中的常量池是放在永久代的，永久代和Java堆是两个完全分开的区域。&lt;/p&gt;
&lt;p&gt;到了jdk7及以后的版本，&lt;/p&gt;
&lt;p&gt;我们先来看看这三个类的源码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;String类部分源码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public final class String
    implements java.io.Serializable, Comparable&amp;lt;String&amp;gt;, CharSequence,
               Constable, ConstantDesc {

    @Stable
    private final byte[] value;
    
    public String(String original) {
        this.value = original.value;
        this.coder = original.coder;
        this.hash = original.hash;
    }
    public native String intern();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;String类由final修饰符修饰，所以String类是不可变的，对象一旦创建，不能改变。&lt;/p&gt;
&lt;p&gt;String类中有个value的字节数组成员 变量，这个变量用于存储字符串的内容，也是用final修饰，一旦初始化，不可改变。&lt;/p&gt;
&lt;p&gt;java提供了两种主要方式创建字符串：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//方式1
String str = &quot;123&quot;;
//方式2
String str = new String(&quot;123&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;java虚拟机规范中定义字符串都是存储在字符串常量池中，不管是用方式1还是方式2创建字符串，都会从去字符串常量池中查找，如果已经存在，直接返回，否则创建后返回。&lt;/p&gt;
&lt;p&gt;java编译器在编译java类时，遇到“abc”，“hello”这样的字符串常量，会将这些常量放入类的常量区，类在加载时，会将字符串常量加入到字符串常量池中。&lt;/p&gt;
&lt;p&gt;含有表达式的字符串常量，不会在编译时放入常量区，例如，String str = &quot;abc&quot; + a&lt;/p&gt;
&lt;p&gt;常量池的最大作用是共享使用，提高程序执行效率。&lt;/p&gt;
&lt;p&gt;看看下面几个案例。&lt;/p&gt;
&lt;p&gt;案例1：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;1  String str1 = &quot;123&quot;;
2  String str2 = &quot;123&quot;;
3  System.out.println(str1 == str2);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面代码运行的结果为true。&lt;/p&gt;
&lt;p&gt;运行第1行代码时，现在常量池中创建字符串123对象，然后赋值给str1变量。&lt;/p&gt;
&lt;p&gt;运行第2行代码时，发现常量池已经存在123对象，则直接将123对象的地址返回给变量str2。&lt;/p&gt;
&lt;p&gt;str1和str2变量指向的地址一样，他们是同一个对象，因此运行的结果为true。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/110616/201910/110616-20191006181455457-1592660607.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从图中可以看出，str1使用””引号（也是平时所说的字面量）创建字符串，在编译期的时候就对常量池进行判断是否存在该字符串，如果存在则不创建直接返回对象的引用；如果不存在，则先在常量池中创建该字符串实例再返回实例的引用给str1。&lt;/p&gt;
&lt;p&gt;案例2：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;1  String str1 = new String(&quot;123&quot;);  
2  String str2 = new String(&quot;123&quot;);
3  String str3 = new String(str2);
4  System.out.println((str1==str2));  
5  System.out.println((str1==str3));

6  System.out.println((str3==str2));  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面代码运行的结果是&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;false
false
false&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/110616/201910/110616-20191006181513976-555577261.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上图可以看出，执行第1行代码时，创建了两个对象，一个存放在字符串常量池中，一个存在与堆中,还有一个对象引用str1存放在栈中。&lt;/p&gt;
&lt;p&gt;执行第2行代码时，字符串常量池中已经存在“123”对象，所以只在堆中创建了一个字符串对象，并且这个对象的地址指向常量池中“123”对象的地址，同时在栈中创建一个对象引用str2，引用地址指向堆中创建的对象。&lt;/p&gt;
&lt;p&gt;执行第3行代码时，在堆中创建一个字符串对象，这个对象的内存地址指向变量str2所执向的内存地址。&lt;/p&gt;
&lt;p&gt;通过new方式创建的字符串对象，都会在堆中开辟一个新内存空间，用于存储常量池中的字符串对象。&lt;/p&gt;
&lt;p&gt;对于对象而言，==操作是用于比较两个独享的内存地址是否一致，所以上面的代码执行的结果都是false。&lt;/p&gt;
&lt;p&gt;案例3：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//这行代码编译后的效果等同于String str1 = &quot;abcd&quot;;
String str1 = &quot;ab&quot; + &quot;cd&quot;;  
String str2 = &quot;abcd&quot;;   
System.out.println((str1 == str2)); &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面代码执行的结果：true。&lt;/p&gt;
&lt;p&gt;使用包含常量的字符串连接创建的也是常量，编译期就能确定了，类加载的时候直接进入字符串常量池，当然同样需要判断字符串常量池中是否已经存在该字符串。&lt;/p&gt;
&lt;p&gt;案例4：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;String str2 = &quot;ab&quot;;  //1个对象  
String str3 = &quot;cd&quot;;  //1个对象                                         
String str4 = str2 + str3 + “1”;                                        
String str5 = &quot;abcd1&quot;;    
System.out.println((str4==str5)); &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面代码执行的结果：false。&lt;/p&gt;
&lt;p&gt;当使用“+”连接字符串中含有变量时，由于变量的值是在运行时才能确定。&lt;/p&gt;
&lt;p&gt;如果使用的jdk8以前版本的虚拟机，在拼接字符串时，会在jvm堆中生成StringBuilder对象，调用append方法拼接字符串，最后调用StringBuilder的toString方法在jvm堆中生成最终的字符串对象。&lt;/p&gt;
&lt;p&gt;通过查看字节码就可以知道jdk8之前版本的&quot;+&quot;拼接字符串时通过StringBuilder实现的。通过查看字节码就可以知道，如下图所示：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/110616/201910/110616-20191006181534757-1873416746.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而如果使用的是jdk9以后版本的虚拟机，则是调用虚拟机自带的InvokeDynamic拼接字符串，并且保存在堆中。字节码如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/110616/201910/110616-20191006181545887-540560637.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;str4的对象在字符串常量池中，str5的对象在堆中，所以他们的不是同一个对象，所以返回的结果是false。&lt;/p&gt;
&lt;p&gt;案例5：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;String s5 = new String(“2”) + new String(“3”);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;和案例4一样，因为new String(&quot;2&quot;)创建字符串，也是在运行时才能确定对象内存地址，和案例4一样。&lt;/p&gt;
&lt;p&gt;案例6：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;final String str1 = &quot;b&quot;;  
String str2 = &quot;a&quot; + str1;  
String str3 = &quot;ab&quot;;  
System.out.println((str2 == str3)); &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面代码执行的结果为true。&lt;/p&gt;
&lt;p&gt;str1是常量变量，在编译期就确定，直接放入到字符串常量池中，上面的代码效果等同于：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;String str2 = &quot;a&quot; + &quot;b&quot;;
String str3 = &quot;ab&quot;;
System.out.println((str2 == str3));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用String类的intern()方法，会将堆中的字符串实例放入到字符串常量池中。&lt;/p&gt;
&lt;p&gt;案例7：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;String str2 = &quot;ab&quot;;
String str3 = &quot;cd&quot;;
String str4 = str2 + str3 + &quot;1&quot;;
str4.intern();
String str5 = &quot;abcd1&quot;;
System.out.println((str4==str5));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面代码执行的结果：true。调用了str4.intern()方法后，将str4放入到字符串常量池中，和str5是同一个实例。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;StringBuffer部分源码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; public final class StringBuffer
    extends AbstractStringBuilder
    implements java.io.Serializable, Comparable&amp;lt;StringBuffer&amp;gt;, CharSequence
{&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;StringBuilder部分源码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public final class StringBuilder
    extends AbstractStringBuilder
    implements java.io.Serializable, Comparable&amp;lt;StringBuilder&amp;gt;, CharSequence
{&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可见StringBuffer和StringBuilder都继承了AbstractStringBuilder类。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AbstractStringBuilder类源码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;abstract class AbstractStringBuilder implements Appendable, CharSequence {
    /**
     * The value is used for character storage.
     */
    byte[] value;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;AbstractStringBuilder也有一个字节数组的成员变量value，这个变量用于存储字符串的值，这个变量不是用final修饰，所以是可以改变的，这个是和String的最大区别。&lt;/p&gt;
&lt;p&gt;在调用append方法的时候，会动态增加字节数组变量value的大小。&lt;/p&gt;
&lt;p&gt;StringBuffer和StringBuilder功能是一样的，都是为了提高java中字符串连接的效率，因为直接使用+进行字符串连接的话，jvm会创建多个String对象，因此造成一定的开销。AbstractStringBuilder中采用一个byte数组来保存需要append的字符串，byte数组有一个初始大小，当append的字符串长度超过当前char数组容量时，则对byte数组进行动态扩展，也即重新申请一段更大的内存空间，然后将当前bute数组拷贝到新的位置，因为重新分配内存并拷贝的开销比较大，所以每次重新申请内存空间都是采用申请大于当前需要的内存空间的方式，这里是2倍。&lt;/p&gt;
&lt;p&gt;StringBuffer和StringBuilder最大的区别是StringBuffer是线程安全，而StringBuilder是非线程安全的，从它们两个类的源码就可以知道，StringBuffer类的方法前面都是synchronized修饰符。&lt;/p&gt;
&lt;p&gt;String一旦赋值或实例化后就不可更改，如果赋予新值将会重新开辟内存地址进行存储。&lt;/p&gt;
&lt;p&gt;而StringBuffer和StringBuilder类使用append和insert等方法改变字符串值时只是在原有对象存储的内存地址上进行连续操作，减少了资源的开销。&lt;/p&gt;
&lt;p&gt;总结：&lt;br/&gt;1、频繁使用“+”操作拼接字符时，换成StringBuffer和StringBuilder类的append方法实现。&lt;/p&gt;
&lt;p&gt;2、多线程环境下进行大量的拼接字符串操作使用StringBuffer，StringBuffer是线程安全的；&lt;/p&gt;
&lt;p&gt;3、单线程环境下进行大量的拼接字符串操作使用StringBuilder，StringBuilder是线程不安全的。&lt;/p&gt;
</description>
<pubDate>Sun, 06 Oct 2019 10:19:00 +0000</pubDate>
<dc:creator>小菜两碟</dc:creator>
<og:description>Java提供了三个类，用于处理字符串，分别是String、StringBuffer和StringBuilder。其中StringBuilder是jdk1.5才引入的。 这三个类有什么区别呢？他们的使用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/airnew/p/11628017.html</dc:identifier>
</item>
</channel>
</rss>