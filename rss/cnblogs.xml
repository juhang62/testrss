<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>【Java并发基础】安全性、活跃性与性能问题 - sakuraxx</title>
<link>http://www.cnblogs.com/myworld7/p/12237270.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/myworld7/p/12237270.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;Java的多线程是一把双刃剑，使用好它可以使我们的程序更高效，但是出现并发问题时，我们的程序将会变得非常糟糕。并发编程中需要注意三方面的问题，分别是安全性、活跃性和性能问题。&lt;/p&gt;
&lt;h2 id=&quot;安全性问题&quot;&gt;安全性问题&lt;/h2&gt;
&lt;p&gt;我们经常说这个方法是线程安全的、这个类是线程安全的，那么到底该怎么理解线程安全呢？&lt;/p&gt;
&lt;p&gt;要给线程安全性定一个非常明确的定义是比较复杂的。越正式的定义越复杂，也就越难理解。但是不管怎样，在线程安全性定义中，最核心的概念还是&lt;strong&gt;正确性&lt;/strong&gt;，可以简单的理解为&lt;strong&gt;程序按照我们期望的执行&lt;/strong&gt;。&lt;br/&gt;正确性的含义是：某个类的行为与其规范完全一致。线程的安全性就可以理解为：当多个线程访问某个类时，这个类始终都能表现出&lt;strong&gt;正确&lt;/strong&gt;的行为，那么就称这个类是线程安全的。&lt;/p&gt;
&lt;p&gt;我们要想编写出线程安全的程序，就需要避免出现并发问题的三个主要源头：原子性问题、可见性问题和有序性问题。（前面的文章介绍了规避这三个问题的方法）当然也不是所有的代码都需要分析这三个问题，只有&lt;strong&gt;存在共享数据并且该数据会发生变化，即有多个线程会同时读写同一个数据&lt;/strong&gt;时，我们才需要&lt;strong&gt;同步&lt;/strong&gt;对共享变量的操作以保证线程安全性。&lt;/p&gt;
&lt;p&gt;这也暗示了，如果&lt;strong&gt;不共享数据&lt;/strong&gt;或者&lt;strong&gt;共享数据状态不发生变化&lt;/strong&gt;，那么也可以保证线程安全性。&lt;/p&gt;
&lt;p&gt;综上，我们可以总结出设计线程安全的程序可以从以下三个方面入手：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;不在线程之间共享变量。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;将共享变量设置为不可变的。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;在访问共享变量时使用同步。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我们前面介绍过使用Java中主要的同步机制synchronized关键字来协同线程对变量的访问，&lt;span&gt;synchronized提供的是一种独占的加锁方式。同步机制除了synchronized内置锁方案，还包括volatile类型变量，显式锁（Explicit Lock）以及原子变量&lt;/span&gt;。而基于一二点的技术方案有&lt;strong&gt;线程本地存储&lt;/strong&gt;（Thread Local Storage, LTS）、&lt;strong&gt;不变模型&lt;/strong&gt;等（后面会介绍）。&lt;/p&gt;
&lt;h3 id=&quot;数据竞争&quot;&gt;数据竞争&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;当多个线程同时访问一个数据，并且至少有一个线程会写这个数据时，如果我们不采用任何 同步机制协同这些线程对变量的访问，那么就会导致并发问题&lt;/span&gt;。这种情况我们叫做&lt;strong&gt;数据竞争&lt;/strong&gt;（&lt;strong&gt;Data Race&lt;/strong&gt;）。&lt;/p&gt;
&lt;p&gt;例如下面的例子就会发生数据竞争。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Test {
    private long count = 0;
    void add10K() {
        int idx = 0;
        while(idx++ &amp;lt; 10000) {
            count += 1;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当多个线程调用&lt;code&gt;add10K()&lt;/code&gt;时，就会发生数据竞争。但是我们下面使用synchronized同步机制就可以来防止数据竞争。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Test {
    private long count = 0;
    synchronized long get(){
        return count；
    }
    synchronized void set(long v){
        count = v;
    }
    void add10K() {
        int idx = 0;
        while(idx++ &amp;lt; 10000) {
            set(get()+1);      
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;竞态条件&quot;&gt;竞态条件&lt;/h3&gt;
&lt;p&gt;但是此时的&lt;code&gt;add10K()&lt;/code&gt;方法并不是线程安全的。&lt;br/&gt;假设count=0, 当两个线程&lt;strong&gt;同时&lt;/strong&gt;执行get()方法后，get()方法会返回相同的值0，两个线程执行get()+1操作，结果都是1，之后两个线程再将结果1写入了内存。本来期望的是2，但是结果却是1。（至于为什么会同时？我当初脑袋被“阻塞”好一会儿才反应过来，哈哈，╮(～▽～)╭，看来不能熬夜写博客。因为如果实参需要计算那么会先被计算，然后作为函数调用的参数传入。这里get()会先被调用，等其返回了才会调用set()，所以一个线程调用完了get()后，另一个线程可以马上获取锁调用get()。这也就会造成两个线程会得到相同的值。）&lt;/p&gt;
&lt;p&gt;这种情况，我们称为&lt;strong&gt;竞态条件&lt;/strong&gt;（&lt;strong&gt;Race Condition&lt;/strong&gt;）。&lt;span&gt;竞态条件，是指程序的执行结果依赖线程执行的顺序&lt;/span&gt; 。&lt;br/&gt;上面的例子中，如果两个线程完全同时执行，那么结果是1；如果两个线程是前后执行，那么结果就是2。在并发环境里，线程的执行顺序是不确定的，如果程序存在竞态条件问题，那么就意味着程序执行的结果是不确定的，而执行结果不确定就是一个大问题。&lt;/p&gt;
&lt;p&gt;我们前面讲并发bug源头时，也介绍过&lt;a href=&quot;https://www.cnblogs.com/myworld7/p/12203093.html#_label2_0&quot;&gt;竞态条件&lt;/a&gt;。由于不恰当的执行时序而导致的不正确的结果。要避免竞态条件问题，就必须在某个线程修改该变量时，通过某种方式防止其他线程使用这个变量，从而&lt;strong&gt;确保其他线程只能在修改操作完成之前或者之后读取和修改状态，而不是在修改状态的过程中&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;解决这个例子的竞态条件问题，我们可以介绍过的&lt;strong&gt;加锁机制&lt;/strong&gt;来保证：其他线程只能在修改操作完成之前或者之后读取和修改状态，而不是在修改状态的过程中。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Test {
    private long count = 0;
    synchronized long get(){
        return count；
    }
    synchronized void set(long v){
        count = v;
    }
    void add10K() {
        int idx = 0;
        while(idx++ &amp;lt; 10000) {
            synchronized(this){
                set(get()+1);    
            }  
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;所以面对数据竞争和竞态条件我们可以使用加锁机制来保证线程的安全性！&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;活跃性问题&quot;&gt;活跃性问题&lt;/h2&gt;
&lt;p&gt;安全性的含义是“永远不发生糟糕的事情”，而活跃性则关注另外一个目标，即“某件正确的事情最终会发生”。 &lt;span&gt;当某个操作无法继续执行下去时，就会发生活跃性问题。&lt;/span&gt;&lt;br/&gt;在串行程序中，活跃性问题的形式之一便是无意中造成的无限循环。从而使循环之后的代码无法被执行。而线程将会带来其他的一些活跃性问题，例如我们前面所讲的&lt;a href=&quot;https://www.cnblogs.com/myworld7/p/12230010.html&quot;&gt;死锁&lt;/a&gt;，以及我们下面将要介绍的饥饿和活锁。&lt;/p&gt;
&lt;h3 id=&quot;饥饿&quot;&gt;饥饿&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;饥饿（Starvation）指的是线程无法访问到所需要的资源而无法执行下去的情况。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;引发饥饿最常见的资源便是CPU时钟周期。如果Java应用程序中&lt;strong&gt;对线程的优先级使用不当&lt;/strong&gt;，或者在持有锁时执行一些无法结束的结构（例如无限循环或者无限制地等待某个资源），那么也可能导致饥饿，因为其他需要这个锁的线程无法得到它。&lt;/p&gt;
&lt;p&gt;通常，&lt;strong&gt;我们尽量不要改变线程的优先级&lt;/strong&gt;，在大部分并发应用程序中，可以使用默认的线程优先级。只要改变了线程的优先级，程序的行为就将与平台相关，并且可能导致发生饥饿问题的风险（例如优先级高的线程会一直获取资源，而低优先级的线程则将一直无法获取到资源）。&lt;br/&gt;当某个程序会在一些奇怪的地方调用&lt;code&gt;Thread.sleep&lt;/code&gt;或&lt;code&gt;Thread.yield&lt;/code&gt;，那是这个程序在试图克服优先级调整问题或响应性问题，并试图让低优先级的线程执行更多的时间。&lt;/p&gt;
&lt;p&gt;饥饿问题的实质可以用孔子老人家说过的一句话来总结：&lt;strong&gt;不患寡而患不均&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;解决饥饿问题，有以下三种方案：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;保证资源充足。&lt;/li&gt;
&lt;li&gt;公平地分配资源。&lt;/li&gt;
&lt;li&gt;避免持有锁的线程长时间执行。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这三个方案中，方案一和方案三的适用场景比较有限，因为很多场景下，资源的稀缺性是没办法解决的，持有锁的线程执行的时间也很难缩短。所以，方案二的适用场景会多一点。在并发编程里，我们可以使用&lt;strong&gt;公平锁&lt;/strong&gt;来公平的分配资源。所谓公平锁，是一种FIFO方案，线程的等待是有顺序的，排在等待队列前面的线程会优先获得资源。&lt;/p&gt;
&lt;h3 id=&quot;活锁&quot;&gt;活锁&lt;/h3&gt;
&lt;p&gt;活锁（Livelock）是另一种形式的活跃性问题，它和死锁很相似，但是它却不会阻塞线程。&lt;span&gt;活锁尽管不会阻塞线程，但也不能继续执行，因为线程将不断重复执行相同的操作，而且总会失败。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;活锁通常发生在处理事务消息的应用程序中：如何不能成功地处理某个消息，那么消息处理机制将回滚整个事务，并将它重新放置到队列的开头。如果消息处理器在处理某种特定的消息时存在错误并导致它失败，那么每当这个消息从队列中取出并传递到存在错误的处理器时，都会发生事务回滚。由于这个消息又被放到队列开头，因此处理器将被反复调用，并返回相同的处理结果。（有时候也被称为毒药消息，Poison Message。）虽然处理消息的线程没有被阻塞，但也无法执行下去。这种形式的活锁，通常由过度的错误恢复代码造成，因为它错误地将不可修复的错误作为可修复的错误。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当多个相互协作的线程都对彼此进行响应从而修改各自的状态，并使得任何一个线程都无法继续执行时，就发生了活锁。&lt;/span&gt; 这就好比两个过于礼貌的人在半路上相遇，为了不相撞，他们彼此都给对方让路，结果导致他们又相撞。他们如此反复下一，便造成了活锁问题。&lt;/p&gt;
&lt;p&gt;解决这种活锁问题，我们在重试机制中引入&lt;strong&gt;随机性&lt;/strong&gt;。即，让他们在谦让时尝试等待一个随机的时间。如此，他们便不会相撞而顺序通行。我们在以太网协议的二进制指数退避算法中，也可以看到引入随机性降低冲突和反复失败的好处。&lt;span&gt;在并发应用程序中，通过等待随机长度的时间和回退可以有效避免活锁的发生。&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;性能问题&quot;&gt;性能问题&lt;/h2&gt;
&lt;p&gt;与活跃性问题密切相关的是性能问题。活跃性意味着某件正确的事情最终会发生，但却不够好，因为我们通常希望正确事情尽快发生。性能问题包括多个方面，例如服务时间过长，响应不灵敏，吞吐量过低，资源消耗过高，或者可伸缩性降低等。与活跃性和安全性一样，在多线程程序中不仅存在与单线程程序相同的性能问题，而且还存在由于实现线程而引入的其他性能问题。&lt;/p&gt;
&lt;p&gt;我们使用多线程的目的是提升程序的整体性能，但是与单线程的方法相比，使用多个线程总会引入一些&lt;strong&gt;额外的性能开销&lt;/strong&gt;。&lt;span&gt;造成这些开销的操作包括：线程之间的协调（如加锁、内存同步等），增加上下文切换，线程的创建和销毁，以及线程的调度等&lt;/span&gt;。如果我们多度地使用线程，那么这些开销可能超过由于提高吞吐量、响应性或者计算能力所带来的性能提升。另一方面，一个并发设计很糟糕的程序，其性能甚至比完成相同功能的串行程序性能还要低。&lt;br/&gt;想要通过并发来获得更好的性能就需要做到：更有效地利用现有处理资源，以及在出现新的处理资源时使程序尽可能地利用这些新资源。&lt;/p&gt;
&lt;p&gt;下面我们将介绍如何评估性能、分析多线程带来的额外开销以及如何减少这些开销。&lt;/p&gt;
&lt;h3 id=&quot;性能和可伸缩性&quot;&gt;性能和可伸缩性&lt;/h3&gt;
&lt;p&gt;应用程序的性能可以采用多个指标来衡量，例如服务时间、延迟时间、吞吐量、效率、可伸缩性以及容量等。其中一些指标（服务时间、等待时间）用于衡量程序的“运行速度”，即某个指定的任务单元需要“多快”才能处理完成。另一些指标（生产量、吞吐量）用于程序的“处理能力”，即在计算资源一定的情况下，能完成“多少”工作。&lt;/p&gt;
&lt;p&gt;可伸缩性指的是：当增加计算资源（例如CPU、内存、存储容量或者I/O带宽）时，程序的吞吐量或者处理能力相应地增加。在对可伸缩性调优时，目的是将设法将问题的计算并行化，从而能够利用更多的计算资源来完成更多的任务。而我们传统的对性能调优，目的是用更小的代价完成相同的工作，例如通过缓存来重用之前的计算结果。&lt;/p&gt;
&lt;h3 id=&quot;amdahl定律&quot;&gt;Amdahl定律&lt;/h3&gt;
&lt;p&gt;大多数的并发程序都是由一系列的并行工作和串行工作组成。&lt;br/&gt;&lt;span&gt;Amdahl定律描述的是：在增加计算资源的情况下，程序在理论上能够实现最高加速比，这个值取决于程序中可并行组件与串行组件所占比重。简单点说，Amdahl定律代表了处理器并行运算之后效率提升的能力。&lt;/span&gt;&lt;br/&gt;假定&lt;strong&gt;F是必须被串行执行的部分&lt;/strong&gt;，那么根据Amdahl定律，在包含&lt;strong&gt;N个处理器&lt;/strong&gt;的机器中，最高加速比为：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[Speedup &amp;lt;= \frac{1}{F+\frac{(1-F)}{N}}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;当N趋近于无穷大时，最高加速比趋近于&lt;span class=&quot;math inline&quot;&gt;\(\frac{1}{F}\)&lt;/span&gt; 。因此，如果程序有50%的计算需要串行执行，那么最高加速比只能是2，而不管有多个线程可用。无论我们采用什么技术，最高也就只能提升2倍的性能。&lt;br/&gt;&lt;strong&gt;Amdahl定律量化了串行化的效率开销&lt;/strong&gt;。在拥有10个处理器的系统中，如果程序中有10%的部分需要串行执行，那么最高加速比为5.3（53%的使用率），在拥有100个处理器的系统中，加速比可以达到9.2（92%的使用率）。但是拥有无限多的处理器，加速比也不会到达10。&lt;/p&gt;
&lt;p&gt;如果能准确估计出执行过程中穿行部分所占的比例，那么Amdahl定律就可以量化当有更多计算资源可用时的加速比。&lt;/p&gt;
&lt;h3 id=&quot;线程引入的开销&quot;&gt;线程引入的开销&lt;/h3&gt;
&lt;p&gt;在多个线程的调度和协调过程中都需要一定的性能开销。所以我们要保证，并行带来的性能提升必须超过并发导致的开销，不然这就是一个失败的并发设计。下面介绍并发带来的开销。&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;上下文切换&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;如果主线程是唯一的线程，那么它基本上不会被调度出去。如果可运行的线程数目大于CPU的数量，那么操作系统最终会将某个正在运行的线程调度出来，从而使其他线程能够使用CPU。这将导致一次上下文切换，在这个过程中，将保存当前运行线程的执行上下文，并将新调度进来的线程的执行上下文设置为当前上下文。&lt;/p&gt;
&lt;p&gt;切换上下文需要一定的开销，而在线程调度过程中需要访问由操作系统和JVM共享的数据结构。上下文切换的开销不止包含JVM和操作系统的开销。当一个新的线程被切换进来时，它所需要的数据可能不在当前处理器的本地缓存中，因此上下文切换将导致一些&lt;strong&gt;缓存缺失&lt;/strong&gt;（丢失局部性），因而线程在首次调度运行时会更加缓慢。&lt;br/&gt;调度器会为每个可运行的线程分配一个最小执行时间，即使有许多其他的线程正在等待执行：这是为了将上下文切换的开销分摊到更多不会中断的执行时间上，从而提高整体的吞吐量（以损失响应性为代价）。&lt;/p&gt;
&lt;p&gt;当线程被频繁的阻塞时，也可能会导致上下文切换，从而增加调度开销，降低吞吐量。因为，当线程由于没有竞争到锁而被阻塞时，JVM通常会将这个线程挂起，并允许它被交换出去。&lt;/p&gt;
&lt;p&gt;上下文切换的实际开销会随着平台的不同而变化，按照经验来看：在大多数通用的处理器上，上下文切换的开销相当于5000～10000个时钟周期，也就是几微秒。&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;内存同步&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;同步操作的性能开销包括多个方面。在synchronized和volatile提供的可见性保证中可能会使用一些特殊指令，即&lt;strong&gt;内存栅栏&lt;/strong&gt;（也就是我们前面文章介绍过的&lt;a href=&quot;https://www.cnblogs.com/myworld7/p/12209222.html#_label4_1&quot;&gt;内存屏障&lt;/a&gt;）。&lt;span&gt;内存栅栏可以刷新缓存，使缓存无效，刷新硬件的写缓冲，以及停止执行管道。内存栅栏可能同样会对性能带来间接的影响，因为它们将抑制一些编译器优化操作&lt;/span&gt;。在内存栅栏中，大多数的操作都是不能被重排序的。&lt;/p&gt;
&lt;p&gt;在评估同步操作带来的性能影响时，需要区分有竞争的同步和无竞争的同步。现代的JVM可以优化一些不会发生竞争的锁，从而减少不必要的同步开销。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;synchronized(new Object()){...}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;JVM会通过逃逸分析优化掉以上的加锁。&lt;br/&gt;所以，&lt;span&gt;我们应该将优化重点放在那些发生锁竞争的地方。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;某个线程的同步可能会影响其他线程的性能&lt;/span&gt;。同步会增加共享内存总线上的通信量，总线的带宽是有限的，并且所有的处理器都将共享这条总线。如果有多个线程竞争同步带宽，那么所有使用了同步的线程都会受到影响。&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;阻塞&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;非竞争的同步可以完全在JVM中处理，而竞争的同步可能需要操作系统的介入，从而增加系统的开销。在锁上发生竞争时，竞争失败的线程会被阻塞。JVM在实现阻塞行为时，可以采用&lt;strong&gt;自旋等待&lt;/strong&gt;（Spin-Waitiin，指通过循环不断地尝试获取锁，直到成功）或者通过&lt;strong&gt;操作系统挂起被阻塞的线程&lt;/strong&gt;。这两种方式的效率高低，取决于上下文切换的开销以及在成功获取锁之前需要等待的时间。如果等待时间短，就采用自旋等待方式；如果等待时间长，则适合采用线程挂起的方式。JVM会分析历史等待时间做选择，不过，大多数JVM在等待锁时都只是将线程挂起。&lt;/p&gt;
&lt;p&gt;线程被阻塞挂起时，会包含两次的上下文切换，以及所有必要的操作系统操作和缓存操作。&lt;/p&gt;
&lt;h3 id=&quot;减少锁的竞争&quot;&gt;减少锁的竞争&lt;/h3&gt;
&lt;p&gt;串行操作会降低可伸缩性，并且上下文切换也会降低性能。当在锁上发生竞争时会同时导致这两种问题，因此&lt;strong&gt;减少锁的竞争能够提高性能和可伸缩性&lt;/strong&gt;。&lt;br/&gt;在对某个独占锁保护的资源进行访问时，将采用串行方式——每次只有一个线程能访问它。如果在锁上发生竞争，那么将限制代码的可伸缩性。&lt;br/&gt;在并发程序中，对可伸缩性的最主要的威胁就是独占方式的资源锁。&lt;/p&gt;
&lt;p&gt;有两个因素将影响在锁上发生竞争的可能性：锁的请求频率和每次持有该锁的时间。（&lt;a href=&quot;https://baike.baidu.com/item/Little%E5%AE%9A%E5%BE%8B/15590754?fr=aladdin&quot;&gt;Little定律&lt;/a&gt;）&lt;br/&gt;如果二者的乘积很小，那么大多数获取锁的操作都不会发生竞争，因此在该锁上的竞争不会对可伸缩性造成严重影响。&lt;/p&gt;
&lt;p&gt;下面介绍降低锁的竞争程度的方案。&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;缩小锁的范围&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;降低发生竞争的可能性的一种有效方式就是尽可能缩短锁的持有时间。例如，可以将一些与锁无关的代码移除代码块，尤其是那些开销较大的操作，以及可能被阻塞的操作（I/O操作）。&lt;br/&gt;尽管缩小同步代码块能提高可伸缩性，但同步代码块也不能太小，因为会有一些复合操作需要以原子操作的方式进行，这时就必须在同一同步块中。&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;减小锁的粒度&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;另一种减少锁的持有时间的方式便是降低线程请求锁的频率（从而减小发生竞争的可能性）。这可以通过&lt;strong&gt;锁分解&lt;/strong&gt;和&lt;strong&gt;锁分段&lt;/strong&gt;等技术来实现，&lt;span&gt;这些技术中将采用多个相互独立的锁来保护相互独立的状态变量，从而改变这些变量在之前由单个锁来保护的情况&lt;/span&gt;。这些技术能缩小锁操作的粒度，并能实现更高的可伸缩性。但是需要注意，使用的锁越多，也就越容易发生死锁。&lt;/p&gt;
&lt;h3 id=&quot;锁分解&quot;&gt;锁分解&lt;/h3&gt;
&lt;p&gt;如果一个锁需要保护多个&lt;strong&gt;相互独立&lt;/strong&gt;的状态变量，那么可以将这个锁分解为多个锁，并且每个锁只保护一个变量，从而提高可伸缩性，并最终降低每个锁被请求的频率。&lt;/p&gt;
&lt;p&gt;例如，如下的程序我们便可以进行锁分解。（例子来自《Java并发编程实践》）&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@ThreadSafe   // 该注解表示该类是线程安全的
public class ServerStatus {
    // @GuardedBy(xxx)表示该状态变量是由xxx锁保护
    @GuardedBy(&quot;this&quot;) public final Set&amp;lt;String&amp;gt; users;
    @GuardedBy(&quot;this&quot;) public final Set&amp;lt;String&amp;gt; queries;

    public ServerStatusBeforeSplit() {
        users = new HashSet&amp;lt;String&amp;gt;();
        queries = new HashSet&amp;lt;String&amp;gt;();
    }

    public synchronized void addUser(String u) {
        users.add(u);
    }

    public synchronized void addQuery(String q) {
        queries.add(q);
    }

    public synchronized void removeUser(String u) {
        users.remove(u);
    }

    public synchronized void removeQuery(String q) {
        queries.remove(q);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上程序表示的是某个数据库服务器的部分监视接口，该数据库维护了当前已经登录的用户以及正在执行的请求。当一个用户登录、注销、开始查询或者结束查询时，都会调用相应的add或者remove方法来更新ServerStatus对象。这两种类型信息是完全独立的，因此，我们可以尝试用锁分解来提升该程序的性能。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@ThreadSafe
public class ServerStatus{
    @GuardedBy(&quot;users&quot;) public final Set&amp;lt;String&amp;gt; users;
    @GuardedBy(&quot;queries&quot;) public final Set&amp;lt;String&amp;gt; queries;

    public ServerStatusAfterSplit() {
        users = new HashSet&amp;lt;String&amp;gt;();
        queries = new HashSet&amp;lt;String&amp;gt;();
    }

    public void addUser(String u) {
        synchronized (users) {
            users.add(u);
        }
    }

    public void addQuery(String q) {
        synchronized (queries) {
            queries.add(q);
        }
    }

    public void removeUser(String u) {
        synchronized (users) {
            users.remove(u);
        }
    }

    public void removeQuery(String q) {
        synchronized (users) {
            queries.remove(q);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们将原来的ServerStatus分解，使用新的细粒度锁来同步对状态变量的维护。减少了锁的竞争，提升了性能。&lt;/p&gt;
&lt;h3 id=&quot;锁分段&quot;&gt;锁分段&lt;/h3&gt;
&lt;p&gt;把一个竞争激烈的锁分解为两个锁时，这两个锁可能都存在激烈的竞争。在上面的锁分解例子中，并不能进一步对锁进行分解。&lt;/p&gt;
&lt;p&gt;在某些情况下，可以将锁分解技术进一步扩展为对一组独立对象上的锁进行分解，这种情况被称为&lt;strong&gt;锁分段&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;例如，&lt;code&gt;ConcurrentHashMap&lt;/code&gt;的实现中使用了一个包含16个锁的数组，每个锁保护所有散列桶的&lt;span class=&quot;math inline&quot;&gt;\(\frac{1}{16}\)&lt;/span&gt; ，其中第N个散列桶由第（N mod 16）个锁来保护。&lt;br/&gt;假设散列函数具有合理的分布性，并且关键字能够实现均匀分布，那么这大约能把对于锁的请求减少到原来的&lt;span class=&quot;math inline&quot;&gt;\(\frac{1}{16}\)&lt;/span&gt; 。正是因为这项技术，使用ConcurrentHashMap可以支持多大16个并发的写入器。&lt;/p&gt;
&lt;p&gt;锁分段的一个劣势在于：需要获取多个锁来实现独占访问将更加困难且开销更高。例如当ConcurrentHashMap需要扩展映射范围，以及重新计算键值的散列值需要分不到更大的桶集合中时，就需要获取所有分段锁。&lt;/p&gt;
&lt;p&gt;下面的代码展示了在基于散列的Map中使用锁分段的技术。它拥有N_LOCKS个锁，并且每个锁保护散列桶的一个子集。大多数方法都只需要获得一个锁，如get()，而有些方法则需要获取到所有的锁，但不要求同时获得，如clear()。（例子来自《Java并发编程实践》）&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@ThreadSafe
public class StripedMap {
    // Synchronization policy: buckets[n] guarded by locks[n%N_LOCKS]
    private static final int N_LOCKS = 16;
    private final Node[] buckets;
    private final Object[] locks;

    private static class Node {
        Node next;
        Object key;
        Object value;
    }

    public StripedMap(int numBuckets) {
        buckets = new Node[numBuckets];
        locks = new Object[N_LOCKS];
        for (int i = 0; i &amp;lt; N_LOCKS; i++)
            locks[i] = new Object();
    }

    private final int hash(Object key) {
        return Math.abs(key.hashCode() % buckets.length);
    }

    public Object get(Object key) {
        int hash = hash(key);
        synchronized (locks[hash % N_LOCKS]) {
            for (Node m = buckets[hash]; m != null; m = m.next)
                if (m.key.equals(key))
                    return m.value;
        }
        return null;
    }

    public void clear() {
        for (int i = 0; i &amp;lt; buckets.length; i++) {
            synchronized (locks[i % N_LOCKS]) {
                buckets[i] = null;
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;一些代替独占锁的方法&quot;&gt;一些代替独占锁的方法&lt;/h3&gt;
&lt;p&gt;除了&lt;strong&gt;缩小锁的范围&lt;/strong&gt;、&lt;strong&gt;减少请求锁的粒度&lt;/strong&gt;，还有第三种降低锁的影响的技术就是放弃使用独占锁。&lt;br/&gt;&lt;span&gt;使用一些无锁的算法或者数据结构来管理共享状态。例如，使用并发容器、读-写锁、不可变对象以及原子变量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;后面也会陆续介绍这些方案。&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;结合我们前面讲的并发知识，我们现在可以从微观和宏观来理解并发编程。在微观上，设计并发程序时我们要考虑到原子性、可见性和有序性问题。跳出微观，从宏观上来看，我们设计程序，要考虑到到线程的安全性、活跃性以及性能问题。我们在做性能优化的前提是要保证线程安全性，如果会优化后出现并发问题，那么结果将会与我们的预期背道而驰。&lt;/p&gt;
&lt;p&gt;参考:&lt;br/&gt;[1]极客时间专栏王宝令《Java并发编程实战》&lt;br/&gt;[2]Brian Goetz.Tim Peierls. et al.Java并发编程实战[M].北京:机械工业出版社,2016&lt;/p&gt;
</description>
<pubDate>Mon, 27 Jan 2020 15:51:00 +0000</pubDate>
<dc:creator>sakuraxx</dc:creator>
<og:description>前言 Java的多线程是一把双刃剑，使用好它可以使我们的程序更高效，但是出现并发问题时，我们的程序将会变得非常糟糕。并发编程中需要注意三方面的问题，分别是安全性、活跃性和性能问题。 安全性问题 我们经</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/myworld7/p/12237270.html</dc:identifier>
</item>
<item>
<title>SuperSocket Code解析 - 杜金锋</title>
<link>http://www.cnblogs.com/lovexinyi/p/12237245.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lovexinyi/p/12237245.html</guid>
<description>&lt;h2 id=&quot;normal-socket&quot;&gt;Normal Socket&lt;/h2&gt;
&lt;p&gt;System.Net.Sockets.dll程序集中使用socket类：&lt;/p&gt;
&lt;p&gt;服务器：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;创建socket&lt;/strong&gt;:&lt;code&gt;_socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;创建IP&lt;/strong&gt;：&lt;code&gt;IPAddress _ip = IPAddress.Parse(ip);_endPoint = new IPEndPoint(_ip, port);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;绑定IP地址：&lt;/strong&gt; &lt;code&gt;_socket.Bind(_endPoint);&lt;/code&gt; //绑定端口&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;服务开启监听：&lt;/strong&gt;&lt;code&gt;_socket.Listen(BACKLOG);&lt;/code&gt; //开启监听，backlog是监听的最大数列&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;开启监听线程&lt;/strong&gt;：创建新的监听线程，在监听线程中while调用&lt;code&gt;Socket acceptSocket = _socket.Accept();&lt;/code&gt;
&lt;ol&gt;&lt;li&gt;一旦acceptSocket 不为空，说明有客户端连接成功，保存客户端socket，并查看该socket的isConnected属性是否连接&lt;code&gt;socket.RemoteEndPoint.ToString();&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;一旦连接创建接收线程，并启动线程，在该线程中创建while&lt;code&gt;while (sInfo.isConnected){sInfo.socket.BeginReceive(sInfo.buffer, 0, sInfo.buffer.Length, SocketFlags.None, ReceiveCallBack, sInfo.socket.RemoteEndPoint);}&lt;/code&gt;来接收客户端传来的消息。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;BeginReceive()&lt;/strong&gt;有一个回调函数ReceiveCallBack()通过读取byte[]buffer&lt;/li&gt;
&lt;li&gt;向客户端发送信息&lt;code&gt;socket.Send(Encoding.ASCII.GetBytes(text));&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;receivebuffer默认值8192&lt;/p&gt;
&lt;h2 id=&quot;socketasynceventargs&quot;&gt;SocketAsyncEventArgs&lt;/h2&gt;
&lt;p&gt;异步套接字操作&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;创建IPEndPoint&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;创建socket&lt;/strong&gt;&lt;code&gt;ListenerSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;绑定IP地址&lt;/strong&gt;&lt;code&gt;ListenerSocket.Bind(e);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;开始监听&lt;/strong&gt;&lt;code&gt;ListenerSocket.Listen(10);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;创建异步套接字,并绑定异步完成事件&lt;/strong&gt;&lt;code&gt;Args = new SocketAsyncEventArgs();Args.Completed += new EventHandler&amp;lt;SocketAsyncEventArgs&amp;gt;(ProcessAccept);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;调用socket的AcceptAsync(Args)方法&lt;/strong&gt;&lt;code&gt;ListenerSocket.AcceptAsync(Args);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;在异步套接字完成事件的回调函数中&lt;/strong&gt;，创建新的异步套接字用于接收客户端传入消息的异步操作。&lt;code&gt;var args = new SocketAsyncEventArgs();args.Completed += new EventHandler&amp;lt;SocketAsyncEventArgs&amp;gt;(OnIOCompleted);args.AcceptSocket = s;s.ReceiveAsync(args)&lt;/code&gt;s.&lt;strong&gt;ReceiveAsync&lt;/strong&gt;(args)，s接收的socket的，新建一个异步套接字，并传入ReceiveAsync()方法。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;switch (e.LastOperation)case SocketAsyncOperation.Receive:&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Socket.AcceptAsync(SocketAsyncEventArgs) 方法&lt;/p&gt;
&lt;p&gt;返回：如果 I/O 操作挂起，则为 &lt;code&gt;true&lt;/code&gt;。 操作完成时，将引发 &lt;a href=&quot;https://docs.microsoft.com/zh-cn/dotnet/api/system.net.sockets.socketasynceventargs.completed?view=netframework-4.8&quot;&gt;Completed&lt;/a&gt; 参数的 &lt;code&gt;e&lt;/code&gt; 事件。&lt;/p&gt;
&lt;p&gt;如果 I/O 操作同步完成，则为 &lt;code&gt;false&lt;/code&gt;。 将不会引发 &lt;a href=&quot;https://docs.microsoft.com/zh-cn/dotnet/api/system.net.sockets.socketasynceventargs.completed?view=netframework-4.8&quot;&gt;Completed&lt;/a&gt; 参数的 &lt;code&gt;e&lt;/code&gt; 事件，并且可能在方法调用返回后立即检查作为参数传递的 &lt;code&gt;e&lt;/code&gt; 对象以检索操作的结果。&lt;/p&gt;
&lt;h2 id=&quot;supersocket-architecture&quot;&gt;SuperSocket Architecture&lt;/h2&gt;
&lt;h4 id=&quot;supersocket-层次示意图&quot;&gt;SuperSocket 层次示意图&lt;/h4&gt;
&lt;p&gt;![# SuperSocket1.6Code解析&lt;/p&gt;
&lt;h2 id=&quot;normal-socket-1&quot;&gt;Normal Socket&lt;/h2&gt;
&lt;p&gt;System.Net.Sockets.dll程序集中使用socket类：&lt;/p&gt;
&lt;p&gt;服务器：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;创建socket&lt;/strong&gt;:&lt;code&gt;_socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;创建IP&lt;/strong&gt;：&lt;code&gt;IPAddress _ip = IPAddress.Parse(ip);_endPoint = new IPEndPoint(_ip, port);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;绑定IP地址：&lt;/strong&gt; &lt;code&gt;_socket.Bind(_endPoint);&lt;/code&gt; //绑定端口&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;服务开启监听：&lt;/strong&gt;&lt;code&gt;_socket.Listen(BACKLOG);&lt;/code&gt; //开启监听，backlog是监听的最大数列&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;开启监听线程&lt;/strong&gt;：创建新的监听线程，在监听线程中while调用&lt;code&gt;Socket acceptSocket = _socket.Accept();&lt;/code&gt;
&lt;ol&gt;&lt;li&gt;一旦acceptSocket 不为空，说明有客户端连接成功，保存客户端socket，并查看该socket的isConnected属性是否连接&lt;code&gt;socket.RemoteEndPoint.ToString();&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;一旦连接创建接收线程，并启动线程，在该线程中创建while&lt;code&gt;while (sInfo.isConnected){sInfo.socket.BeginReceive(sInfo.buffer, 0, sInfo.buffer.Length, SocketFlags.None, ReceiveCallBack, sInfo.socket.RemoteEndPoint);}&lt;/code&gt;来接收客户端传来的消息。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;BeginReceive()&lt;/strong&gt;有一个回调函数ReceiveCallBack()通过读取byte[]buffer&lt;/li&gt;
&lt;li&gt;向客户端发送信息&lt;code&gt;socket.Send(Encoding.ASCII.GetBytes(text));&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;receivebuffer默认值8192&lt;/p&gt;
&lt;h2 id=&quot;socketasynceventargs-1&quot;&gt;SocketAsyncEventArgs&lt;/h2&gt;
&lt;p&gt;异步套接字操作&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;创建IPEndPoint&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;创建socket&lt;/strong&gt;&lt;code&gt;ListenerSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;绑定IP地址&lt;/strong&gt;&lt;code&gt;ListenerSocket.Bind(e);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;开始监听&lt;/strong&gt;&lt;code&gt;ListenerSocket.Listen(10);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;创建异步套接字,并绑定异步完成事件&lt;/strong&gt;&lt;code&gt;Args = new SocketAsyncEventArgs();Args.Completed += new EventHandler&amp;lt;SocketAsyncEventArgs&amp;gt;(ProcessAccept);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;调用socket的AcceptAsync(Args)方法&lt;/strong&gt;&lt;code&gt;ListenerSocket.AcceptAsync(Args);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;在异步套接字完成事件的回调函数中&lt;/strong&gt;，创建新的异步套接字用于接收客户端传入消息的异步操作。&lt;code&gt;var args = new SocketAsyncEventArgs();args.Completed += new EventHandler&amp;lt;SocketAsyncEventArgs&amp;gt;(OnIOCompleted);args.AcceptSocket = s;s.ReceiveAsync(args)&lt;/code&gt;s.&lt;strong&gt;ReceiveAsync&lt;/strong&gt;(args)，s接收的socket的，新建一个异步套接字，并传入ReceiveAsync()方法。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;switch (e.LastOperation)case SocketAsyncOperation.Receive:&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Socket.AcceptAsync(SocketAsyncEventArgs) 方法&lt;/p&gt;
&lt;p&gt;返回：如果 I/O 操作挂起，则为 &lt;code&gt;true&lt;/code&gt;。 操作完成时，将引发 &lt;a href=&quot;https://docs.microsoft.com/zh-cn/dotnet/api/system.net.sockets.socketasynceventargs.completed?view=netframework-4.8&quot;&gt;Completed&lt;/a&gt; 参数的 &lt;code&gt;e&lt;/code&gt; 事件。&lt;/p&gt;
&lt;p&gt;如果 I/O 操作同步完成，则为 &lt;code&gt;false&lt;/code&gt;。 将不会引发 &lt;a href=&quot;https://docs.microsoft.com/zh-cn/dotnet/api/system.net.sockets.socketasynceventargs.completed?view=netframework-4.8&quot;&gt;Completed&lt;/a&gt; 参数的 &lt;code&gt;e&lt;/code&gt; 事件，并且可能在方法调用返回后立即检查作为参数传递的 &lt;code&gt;e&lt;/code&gt; 对象以检索操作的结果。&lt;/p&gt;
&lt;h2 id=&quot;supersocket-architecture-1&quot;&gt;SuperSocket Architecture&lt;/h2&gt;
&lt;h4 id=&quot;supersocket-层次示意图-1&quot;&gt;SuperSocket 层次示意图&lt;/h4&gt;
&lt;p&gt;![# SuperSocket1.6Code解析&lt;/p&gt;
&lt;h2 id=&quot;normal-socket-2&quot;&gt;Normal Socket&lt;/h2&gt;
&lt;p&gt;System.Net.Sockets.dll程序集中使用socket类：&lt;/p&gt;
&lt;p&gt;服务器：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;创建socket&lt;/strong&gt;:&lt;code&gt;_socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;创建IP&lt;/strong&gt;：&lt;code&gt;IPAddress _ip = IPAddress.Parse(ip);_endPoint = new IPEndPoint(_ip, port);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;绑定IP地址：&lt;/strong&gt; &lt;code&gt;_socket.Bind(_endPoint);&lt;/code&gt; //绑定端口&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;服务开启监听：&lt;/strong&gt;&lt;code&gt;_socket.Listen(BACKLOG);&lt;/code&gt; //开启监听，backlog是监听的最大数列&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;开启监听线程&lt;/strong&gt;：创建新的监听线程，在监听线程中while调用&lt;code&gt;Socket acceptSocket = _socket.Accept();&lt;/code&gt;
&lt;ol&gt;&lt;li&gt;一旦acceptSocket 不为空，说明有客户端连接成功，保存客户端socket，并查看该socket的isConnected属性是否连接&lt;code&gt;socket.RemoteEndPoint.ToString();&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;一旦连接创建接收线程，并启动线程，在该线程中创建while&lt;code&gt;while (sInfo.isConnected){sInfo.socket.BeginReceive(sInfo.buffer, 0, sInfo.buffer.Length, SocketFlags.None, ReceiveCallBack, sInfo.socket.RemoteEndPoint);}&lt;/code&gt;来接收客户端传来的消息。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;BeginReceive()&lt;/strong&gt;有一个回调函数ReceiveCallBack()通过读取byte[]buffer&lt;/li&gt;
&lt;li&gt;向客户端发送信息&lt;code&gt;socket.Send(Encoding.ASCII.GetBytes(text));&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;receivebuffer默认值8192&lt;/p&gt;
&lt;h2 id=&quot;socketasynceventargs-2&quot;&gt;SocketAsyncEventArgs&lt;/h2&gt;
&lt;p&gt;异步套接字操作&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;创建IPEndPoint&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;创建socket&lt;/strong&gt;&lt;code&gt;ListenerSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;绑定IP地址&lt;/strong&gt;&lt;code&gt;ListenerSocket.Bind(e);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;开始监听&lt;/strong&gt;&lt;code&gt;ListenerSocket.Listen(10);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;创建异步套接字,并绑定异步完成事件&lt;/strong&gt;&lt;code&gt;Args = new SocketAsyncEventArgs();Args.Completed += new EventHandler&amp;lt;SocketAsyncEventArgs&amp;gt;(ProcessAccept);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;调用socket的AcceptAsync(Args)方法&lt;/strong&gt;&lt;code&gt;ListenerSocket.AcceptAsync(Args);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;在异步套接字完成事件的回调函数中&lt;/strong&gt;，创建新的异步套接字用于接收客户端传入消息的异步操作。&lt;code&gt;var args = new SocketAsyncEventArgs();args.Completed += new EventHandler&amp;lt;SocketAsyncEventArgs&amp;gt;(OnIOCompleted);args.AcceptSocket = s;s.ReceiveAsync(args)&lt;/code&gt;s.&lt;strong&gt;ReceiveAsync&lt;/strong&gt;(args)，s接收的socket的，新建一个异步套接字，并传入ReceiveAsync()方法。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;switch (e.LastOperation)case SocketAsyncOperation.Receive:&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Socket.AcceptAsync(SocketAsyncEventArgs) 方法&lt;/p&gt;
&lt;p&gt;返回：如果 I/O 操作挂起，则为 &lt;code&gt;true&lt;/code&gt;。 操作完成时，将引发 &lt;a href=&quot;https://docs.microsoft.com/zh-cn/dotnet/api/system.net.sockets.socketasynceventargs.completed?view=netframework-4.8&quot;&gt;Completed&lt;/a&gt; 参数的 &lt;code&gt;e&lt;/code&gt; 事件。&lt;/p&gt;
&lt;p&gt;如果 I/O 操作同步完成，则为 &lt;code&gt;false&lt;/code&gt;。 将不会引发 &lt;a href=&quot;https://docs.microsoft.com/zh-cn/dotnet/api/system.net.sockets.socketasynceventargs.completed?view=netframework-4.8&quot;&gt;Completed&lt;/a&gt; 参数的 &lt;code&gt;e&lt;/code&gt; 事件，并且可能在方法调用返回后立即检查作为参数传递的 &lt;code&gt;e&lt;/code&gt; 对象以检索操作的结果。&lt;/p&gt;
&lt;h2 id=&quot;supersocket-architecture-2&quot;&gt;SuperSocket Architecture&lt;/h2&gt;
&lt;h4 id=&quot;supersocket-层次示意图-2&quot;&gt;SuperSocket 层次示意图&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/lovexinyi/p/LearnSuperSocket.assets/1579317752168.jpg&quot; alt=&quot;SuperSocket Layers&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Reusable IO Buffer Pool：BufferManager类&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;supersocket-对象模型图示意图&quot;&gt;SuperSocket 对象模型图示意图&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/lovexinyi/p/LearnSuperSocket.assets/objectmodel.jpg&quot; alt=&quot;SuperSocket Object Model&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;supersocket-请求处理模型示意图&quot;&gt;SuperSocket 请求处理模型示意图&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/lovexinyi/p/LearnSuperSocket.assets/requesthandlingmodel.jpg&quot; alt=&quot;SuperSocket Request Handling Model&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;supersocket-隔离模型示意图&quot;&gt;SuperSocket 隔离模型示意图&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/lovexinyi/p/LearnSuperSocket.assets/isolationmodel.jpg&quot; alt=&quot;SuperSocket Isolation Model&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;config&quot;&gt;Config&lt;/h3&gt;
&lt;h3 id=&quot;command-filters&quot;&gt;Command Filters&lt;/h3&gt;
&lt;h3 id=&quot;loglogfactory&quot;&gt;Log/LogFactory&lt;/h3&gt;
&lt;h3 id=&quot;command-loaders&quot;&gt;Command Loaders&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234228377-1402980669.png&quot; alt=&quot;1579856396698&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;receivefilterfactory&quot;&gt;ReceiveFilterFactory&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234228394-1902973809.png&quot; alt=&quot;1579855102888&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;receivefilter&quot;&gt;ReceiveFilter&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234228446-1765796322.png&quot; alt=&quot;1579855469740&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;connection-filters&quot;&gt;Connection Filters&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234228464-1877437433.png&quot; alt=&quot;1579856311644&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;socketbase.dll&quot;&gt;SocketBase.dll&lt;/h2&gt;
&lt;h3 id=&quot;isessionbase&quot;&gt;ISessionBase&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234228489-787249969.png&quot; alt=&quot;1579318554194&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;appsession&quot;&gt;AppSession&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234228529-373784699.png&quot; alt=&quot;1580125323588&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234228609-1460432228.png&quot; alt=&quot;1579319140513&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对AppServer和SocketSession的包装&lt;/p&gt;
&lt;h3 id=&quot;serverconfig&quot;&gt;ServerConfig&lt;/h3&gt;
&lt;p&gt;服务参数配置,在serverbase基类SetUp中创建&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// Setups with the specified ip and port.
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;ip&quot;&amp;gt;The ip.&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&quot;port&quot;&amp;gt;The port.&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&quot;socketServerFactory&quot;&amp;gt;The socket server factory.&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&quot;receiveFilterFactory&quot;&amp;gt;The Receive filter factory.&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&quot;logFactory&quot;&amp;gt;The log factory.&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&quot;connectionFilters&quot;&amp;gt;The connection filters.&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&quot;commandLoaders&quot;&amp;gt;The command loaders.&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;return setup result&amp;lt;/returns&amp;gt;
public bool Setup(string ip, int port, ISocketServerFactory socketServerFactory = null, IReceiveFilterFactory&amp;lt;TRequestInfo&amp;gt; receiveFilterFactory = null, ILogFactory logFactory = null, IEnumerable&amp;lt;IConnectionFilter&amp;gt; connectionFilters = null, IEnumerable&amp;lt;ICommandLoader&amp;lt;ICommand&amp;lt;TAppSession, TRequestInfo&amp;gt;&amp;gt;&amp;gt; commandLoaders = null)
{
    return Setup(new ServerConfig
                    {
                        Ip = ip,
                        Port = port
                    },
                    socketServerFactory,
                    receiveFilterFactory,
                    logFactory,
                    connectionFilters,
                    commandLoaders);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234228696-260144280.png&quot; alt=&quot;1578468089417&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;rootconfig&quot;&gt;RootConfig&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234228755-356754254.png&quot; alt=&quot;1578469017093&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;MaxWorkingThreads：最大工作线程数量&lt;/li&gt;
&lt;li&gt;MaxCompletionPortThreads：线程池中异步 I/O 线程的最大数目。&lt;/li&gt;
&lt;li&gt;PerformanceDataCollectInterval：性能数据收集间隔&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;requestinfo&quot;&gt;RequestInfo&lt;/h3&gt;
&lt;p&gt;类图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234228805-939600257.png&quot; alt=&quot;1578446037999&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;基类是RequestInfo，提供了两个方法Key和Body,Body是模板，由子类确定具体类型&lt;/li&gt;
&lt;li&gt;StringRequestInfo,在父类基础上提供了一个参数，String[] Parameters&lt;/li&gt;
&lt;li&gt;RequestInfo&amp;lt;TRequestHeader, TRequestBody&amp;gt;:提供了请求头和请求体类型的模板。&lt;/li&gt;
&lt;li&gt;三个接口，key属性，body属性，heater属性&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;listenerinfo&quot;&gt;ListenerInfo&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234228823-1612469659.png&quot; alt=&quot;1579947882373&quot;/&gt;&lt;/p&gt;
&lt;p&gt;监听节点&lt;/p&gt;
&lt;h3 id=&quot;listenerconfig&quot;&gt;ListenerConfig&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234228833-437869264.png&quot; alt=&quot;1578474012112&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;reflectcommandloader&quot;&gt;ReflectCommandLoader&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234228899-1931720001.png&quot; alt=&quot;1578472566238&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ReflectCommandLoader:通过TryLoadCommands方法反射出程序集中的所有命令&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// Tries to load commands.
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;commands&quot;&amp;gt;The commands.&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
public override bool TryLoadCommands(out IEnumerable&amp;lt;TCommand&amp;gt; commands)
{
    commands = null;
    var commandAssemblies = new List&amp;lt;Assembly&amp;gt;();
    if (m_AppServer.GetType().Assembly != this.GetType().Assembly)
        commandAssemblies.Add(m_AppServer.GetType().Assembly);
    string commandAssembly = m_AppServer.Config.Options.GetValue(&quot;commandAssembly&quot;);
    if (!string.IsNullOrEmpty(commandAssembly))
    {
        OnError(&quot;The configuration attribute 'commandAssembly' is not in used, please try to use the child node 'commandAssemblies' instead!&quot;);
        return false;
    }
    if (m_AppServer.Config.CommandAssemblies != null &amp;amp;&amp;amp; m_AppServer.Config.CommandAssemblies.Any())
    {
        try
        {
            var definedAssemblies = AssemblyUtil.GetAssembliesFromStrings(m_AppServer.Config.CommandAssemblies.Select(a =&amp;gt; a.Assembly).ToArray());

            if (definedAssemblies.Any())
                commandAssemblies.AddRange(definedAssemblies);
        }
        catch (Exception e)
        {
            OnError(new Exception(&quot;Failed to load defined command assemblies!&quot;, e));
            return false;
        }
    }
    if (!commandAssemblies.Any())
    {
        commandAssemblies.Add(Assembly.GetEntryAssembly());
    }
    var outputCommands = new List&amp;lt;TCommand&amp;gt;();
    foreach (var assembly in commandAssemblies)
    {
        try
        {
            outputCommands.AddRange(assembly.GetImplementedObjectsByInterface&amp;lt;TCommand&amp;gt;());
        }
        catch (Exception exc)
        {
            OnError(new Exception(string.Format(&quot;Failed to get commands from the assembly {0}!&quot;, assembly.FullName), exc));
            return false;
        }
    }
    commands = outputCommands;
    return true;
}
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;statusinfocollection&quot;&gt;StatusInfoCollection&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234228926-2100272932.png&quot; alt=&quot;1578475314305&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;appserverbase&quot;&gt;AppServerBase&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234229000-632485068.png&quot; alt=&quot;1580125365801&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234229610-1823485838.png&quot; alt=&quot;1578487267303&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;appseverbasetappsessiontrequestinfo&quot;&gt;AppSeverBase&amp;lt;TAppSession,TRequestInfo&amp;gt;&lt;/h3&gt;
&lt;p&gt;m_CommandContainer：命令容器&lt;/p&gt;
&lt;p&gt;m_CommandLoaders&lt;/p&gt;
&lt;p&gt;m_ConnectionFilters&lt;/p&gt;
&lt;p&gt;m_GlobalCommandFilters&lt;/p&gt;
&lt;p&gt;m_Listeners&lt;/p&gt;
&lt;p&gt;m_SocketServerFactory：在SetupBas&lt;/p&gt;
&lt;h2 id=&quot;facility.dll&quot;&gt;Facility.dll&lt;/h2&gt;
&lt;h3 id=&quot;policyreceivefilterfactory&quot;&gt;PolicyReceiveFilterFactory&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234229107-261949866.png&quot; alt=&quot;1579780070988&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;policyrecievefilter&quot;&gt;PolicyRecieveFilter&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234229643-1943377532.png&quot; alt=&quot;1579780715003&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;protocol&quot;&gt;Protocol&lt;/h3&gt;
&lt;p&gt;ReceiveFilterBase&lt;/p&gt;
&lt;p&gt;类图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234231184-1848815571.png&quot; alt=&quot;1578464691790&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234231485-1817935148.png&quot; alt=&quot;1578464252406&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234231474-701737354.png&quot; alt=&quot;1578466885687&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在SuperSocket.SocketBase.Protocol程序集中&lt;/li&gt;
&lt;li&gt;IReceiveFilter&amp;lt;TRequestInfo&amp;gt;接口，接收解析接口
&lt;ul&gt;&lt;li&gt;Filter方法，解析会话请求的信息，参数包括，读取缓冲，偏移量，长度，是否copy，没有被解析的长度&lt;/li&gt;
&lt;li&gt;LeftBufferSize属性：空余的缓冲区长度&lt;/li&gt;
&lt;li&gt;NextReceiveFilter属性，下一个接收解析器&lt;/li&gt;
&lt;li&gt;Reset方法，恢复初始化&lt;/li&gt;
&lt;li&gt;State:解析器状态，正常和错误状态&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ArraySegmentEx&amp;lt;T&amp;gt;数段类
&lt;ul&gt;&lt;li&gt;T为数组模板&lt;/li&gt;
&lt;li&gt;Array数组，count:数量，Offset偏移量，From从，To到&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ArraySegmentList&amp;lt;T&amp;gt;数段列表
&lt;ul&gt;&lt;li&gt;实现了一个数组段列表&lt;/li&gt;
&lt;li&gt;m_PrevSegment：当前的数段&lt;/li&gt;
&lt;li&gt;m_PrevSegmentIndex，数段所在的index&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ReceiveFilterBase&amp;lt;TRequestInfo&amp;gt;
&lt;ul&gt;&lt;li&gt;BufferSegments属性&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;socketengine.dll&quot;&gt;SocketEngine.dll&lt;/h2&gt;
&lt;h3 id=&quot;performancemonitor&quot;&gt;PerformanceMonitor&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234231652-1001510969.png&quot; alt=&quot;1580126841482&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;socketsession&quot;&gt;SocketSession&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234231972-1906688917.png&quot; alt=&quot;1579319465778&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在初始化里对AppSession产生依赖，同时维护Socket和SmartPool(SendingQueue[])，因为维护着socket所以发送接收数据都是通过这个类。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;设置状态：AddStateFlag（）TryAddStateFlag（）RemoveStateFlag（）,AddStateFlag：自旋设置m_State状态，线程安全的&lt;/li&gt;
&lt;li&gt;m_Client:Socket&lt;/li&gt;
&lt;li&gt;SessionID:new guid&lt;/li&gt;
&lt;li&gt;LocalEndPoint:本地Id端&lt;/li&gt;
&lt;li&gt;RemoteEndPoint：远程终结点&lt;/li&gt;
&lt;li&gt;m_SendingQueuePool：实际是SmartPool类的实例，该实例维护者sendingQueue数组&lt;/li&gt;
&lt;li&gt;m_SendingQueue：从SmarlPool中获取一个SendingQueue实例。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;方法&lt;/p&gt;
&lt;p&gt;Initialize()方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;初始化m_SendingQueuePool和m_SendingQueue&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;TrySend()方法：参数：IList&amp;lt;ArraySegment&amp;lt;byte&amp;gt;&amp;gt; segments：将segments压入sendingqueue队列并调用StartSend最终是调用&lt;strong&gt;SendAsync&lt;/strong&gt;或&lt;strong&gt;SendSync&lt;/strong&gt;，这个是由子类实现。&lt;/p&gt;
&lt;h3 id=&quot;asyncsocketsession&quot;&gt;AsyncSocketSession&lt;/h3&gt;
&lt;p&gt;在子类中维护SocketAsyncEventArgs&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;SocketAsyncProxy：维护着SocketAsyncEventArgs&lt;/li&gt;
&lt;li&gt;m_SocketEventArgSend：发送的SocketAsyncEventArgs实例&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在初始化中如果同步发送就使用m_SocketEventArgSend，并OnSendingCompleted方法绑定其Completed事件&lt;/p&gt;
&lt;p&gt;在SendAsync()方法中将SendingQueue实例给m_SocketEventArgSend的UserToken属性，并调用m_SocketEventArgSend的&lt;strong&gt;SetBuffer&lt;/strong&gt;和&lt;strong&gt;SendAsync&lt;/strong&gt;方法，发送失败也调用OnSendingCompleted&lt;/p&gt;
&lt;p&gt;SocketAsyncProxy中的Completed事件中调用ProcessReceive方法，再调用&lt;code&gt;this.AppSession.ProcessRequest(e.Buffer, e.Offset, e.BytesTransferred, true);&lt;/code&gt;方法&lt;/p&gt;
&lt;h3 id=&quot;asyncstreamsocketsession&quot;&gt;AsyncStreamSocketSession&lt;/h3&gt;
&lt;h3 id=&quot;socketfactory&quot;&gt;SocketFactory&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234231678-972215445.png&quot; alt=&quot;1578467105778&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// Creates the socket server.
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;typeparam name=&quot;TRequestInfo&quot;&amp;gt;The type of the request info.&amp;lt;/typeparam&amp;gt;
/// &amp;lt;param name=&quot;appServer&quot;&amp;gt;The app server.&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&quot;listeners&quot;&amp;gt;The listeners.&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&quot;config&quot;&amp;gt;The config.&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
public ISocketServer CreateSocketServer&amp;lt;TRequestInfo&amp;gt;(IAppServer appServer, ListenerInfo[] listeners, IServerConfig config)
    where TRequestInfo : IRequestInfo
{
    if (appServer == null)
        throw new ArgumentNullException(&quot;appServer&quot;);
    if (listeners == null)
        throw new ArgumentNullException(&quot;listeners&quot;);
    if (config == null)
        throw new ArgumentNullException(&quot;config&quot;);
    switch(config.Mode)
    {
        case(SocketMode.Tcp):
            return new AsyncSocketServer(appServer, listeners);
        case(SocketMode.Udp):
            return new UdpSocketServer&amp;lt;TRequestInfo&amp;gt;(appServer, listeners);
        default:
            throw new NotSupportedException(&quot;Unsupported SocketMode:&quot; + config.Mode);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;socketservers&quot;&gt;SocketServers&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234232045-1962009783.png&quot; alt=&quot;1578487919018&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;asyncsocketserver&quot;&gt;AsyncSocketServer&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;缓存管理器m_BufferManager&lt;/li&gt;
&lt;li&gt;线程安全的SocketAsyncEventArgsProxy栈&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;构造函数，父类&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public TcpSocketServerBase(IAppServer appServer, ListenerInfo[] listeners)
    : base(appServer, listeners)
{
    var config = appServer.Config;

    uint dummy = 0;
    m_KeepAliveOptionValues = new byte[Marshal.SizeOf(dummy) * 3];
    m_KeepAliveOptionOutValues = new byte[m_KeepAliveOptionValues.Length];
    //whether enable KeepAlive
    BitConverter.GetBytes((uint)1).CopyTo(m_KeepAliveOptionValues, 0);
    //how long will start first keep alive
    BitConverter.GetBytes((uint)(config.KeepAliveTime * 1000)).CopyTo(m_KeepAliveOptionValues, Marshal.SizeOf(dummy));
    //keep alive interval
    BitConverter.GetBytes((uint)(config.KeepAliveInterval * 1000)).CopyTo(m_KeepAliveOptionValues, Marshal.SizeOf(dummy) * 2);

    m_SendTimeOut = config.SendTimeOut;
    m_ReceiveBufferSize = config.ReceiveBufferSize;
    m_SendBufferSize = config.SendBufferSize;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public override bool Start()
{
    try
    {
        int bufferSize = AppServer.Config.ReceiveBufferSize;

        if (bufferSize &amp;lt;= 0)
            bufferSize = 1024 * 4;

        m_BufferManager = new BufferManager(bufferSize * AppServer.Config.MaxConnectionNumber, bufferSize);

        try
        {
            m_BufferManager.InitBuffer();
        }
        catch (Exception e)
        {
            AppServer.Logger.Error(&quot;Failed to allocate buffer for async socket communication, may because there is no enough memory, please decrease maxConnectionNumber in configuration!&quot;, e);
            return false;
        }

        // preallocate pool of SocketAsyncEventArgs objects
        SocketAsyncEventArgs socketEventArg;

        var socketArgsProxyList = new List&amp;lt;SocketAsyncEventArgsProxy&amp;gt;(AppServer.Config.MaxConnectionNumber);

        for (int i = 0; i &amp;lt; AppServer.Config.MaxConnectionNumber; i++)
        {
            //Pre-allocate a set of reusable SocketAsyncEventArgs
            socketEventArg = new SocketAsyncEventArgs();
            m_BufferManager.SetBuffer(socketEventArg);

            socketArgsProxyList.Add(new SocketAsyncEventArgsProxy(socketEventArg));
        }

        m_ReadWritePool = new ConcurrentStack&amp;lt;SocketAsyncEventArgsProxy&amp;gt;(socketArgsProxyList);

        if (!base.Start())
            return false;

        IsRunning = true;
        return true;
    }
    catch (Exception e)
    {
        AppServer.Logger.Error(e);
        return false;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;socketasynceventargsproxy&quot;&gt;SocketAsyncEventArgsProxy&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234231970-1753901927.png&quot; alt=&quot;1579316308225&quot;/&gt;&lt;/p&gt;
&lt;p&gt;SocketAsyncEventArgs的代理&lt;/p&gt;
&lt;p&gt;维护着一个SocketAsyncEventArgs对象，并订阅了该对象的Completed事件(异步完成事件)&lt;/p&gt;
&lt;p&gt;IsRecyclable：是否可以循环使用&lt;/p&gt;
&lt;p&gt;OrigOffset：原始偏移量&lt;/p&gt;
&lt;p&gt;每当异步完成的时候调用SocketAsyncEventArgs实例中的&lt;strong&gt;UserToken属性&lt;/strong&gt;，该&lt;strong&gt;属性实际上保存着SocketSession&lt;/strong&gt;实例，并调用SocketSession的&lt;strong&gt;ProcessReceive()&lt;/strong&gt;和&lt;strong&gt;AsyncRun()&lt;/strong&gt;方法；&lt;strong&gt;socketSession.AsyncRun(() =&amp;gt; socketSession.ProcessReceive(e));&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;UserToken属性是在SocketAsyncEventArgsProxy的&lt;strong&gt;初始化方法中定义的&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public void Initialize(IAsyncSocketSession socketSession)
{
    SocketEventArgs.UserToken = socketSession;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代理模式&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234232041-1953854437.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;bootstrapfactory&quot;&gt;BootstrapFactory&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234232043-341201526.png&quot; alt=&quot;1580106366845&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;defaultbootstrap&quot;&gt;DefaultBootStrap&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234232082-1769330464.png&quot; alt=&quot;1579403530245&quot;/&gt;&lt;/p&gt;
&lt;p&gt;引导配置文件并通过配置实例化各个server和factory,在CreateWorkItemInstance方法通过Activator.CreateInstance(serviceType)实例化&lt;/p&gt;
&lt;h3 id=&quot;configurationwatcher&quot;&gt;ConfigurationWatcher&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234232111-1438038824.png&quot; alt=&quot;1580108736600&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;socketlistenerbase&quot;&gt;SocketListenerBase&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234232137-1384587934.png&quot; alt=&quot;1579439987190&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;tcpasyncsocketlistener&quot;&gt;TcpAsyncSocketListener&lt;/h3&gt;
&lt;p&gt;监听类，由三个事件：监听错误，监听停止，新的客户端连接&lt;/p&gt;
&lt;p&gt;m_ListrnSocket：监听Socket&lt;/p&gt;
&lt;h3 id=&quot;workitemfactoryinfoloader&quot;&gt;WorkItemFactoryInfoLoader&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234232157-817809570.png&quot; alt=&quot;1580119613894&quot;/&gt;&lt;/p&gt;
&lt;p&gt;配置文件载入 LoadResult,载入配置的connectionFilter,logfactory,commandloaderfactory，将appserver转化成IworkItem接口，&lt;/p&gt;
&lt;h2 id=&quot;common.dll&quot;&gt;Common.dll&lt;/h2&gt;
&lt;h3 id=&quot;buffermanager&quot;&gt;BufferManager&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234232170-1419927419.png&quot; alt=&quot;1578487794792&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此类创建一个大缓冲区，该缓冲区可以分配给每个套接字I / O操作使用，并分配给SocketAsyncEventArgs对象。 这使得bufffer可以轻松地重用，并且可以&lt;strong&gt;防止堆内存碎片化&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;BufferManager类上公开的操作不是线程安全的。我觉得这个类不需要线程安全，因为每个socket获得数据基本不会并发执行。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;m_buffer:所有的字节缓存&lt;/li&gt;
&lt;li&gt;m_bufferSize:单个片段的缓存大小&lt;/li&gt;
&lt;li&gt;m_currentIndex：当前字节在总缓存中的索引&lt;/li&gt;
&lt;li&gt;m_freeIndexPool:空闲索引池&lt;/li&gt;
&lt;li&gt;m_numBytes：缓存片段的数目&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;主要提供两个方法：一个是SetBuffer和FreeBuffer&lt;/p&gt;
&lt;p&gt;SetBuffer：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;检查空闲索引栈中是否有值，有值就直接使用空闲索引栈中的值，并将其值从栈中推出，&lt;/li&gt;
&lt;li&gt;如果没有空闲栈的值就先检查剩余的缓存是否有一个片段大小，有的化就设置并改变m_currentIndex索引，没有返回false&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;FreeBuffer：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;将当前索引添加到空闲索引栈中，并释放SocketAsyncEventArgs中用的缓存片段。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;arraysegmentlist&quot;&gt;ArraySegmentList&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234232174-591979444.png&quot; alt=&quot;1579323401012&quot;/&gt;&lt;/p&gt;
&lt;p&gt;方法：&lt;/p&gt;
&lt;p&gt;IndexOf：T在所有缓存中的索引&lt;/p&gt;
&lt;h3 id=&quot;arraysegmentex&quot;&gt;ArraySegmentEx&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;数组，是保存着所有缓存，T[]&lt;/li&gt;
&lt;li&gt;偏移，该片段在缓存中的位置&lt;/li&gt;
&lt;li&gt;数量，该片段的长度&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;sendingqueue&quot;&gt;SendingQueue&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234232190-1808236810.png&quot; alt=&quot;1579329295160&quot;/&gt;&lt;/p&gt;
&lt;p&gt;维护ArraySegment&amp;lt;byte&amp;gt;[] globalQueue， globalQueue中包含着所有所有缓存&lt;/p&gt;
&lt;p&gt;入栈，出战，开始入栈，开始出栈。&lt;/p&gt;
&lt;p&gt;所有的发送队列内存片组成一个大的arraysegment，由SendingQueueSourceCreator创建，并由SmartPool维护&lt;/p&gt;
&lt;h3 id=&quot;sendingqueuesourcecreator&quot;&gt;SendingQueueSourceCreator&lt;/h3&gt;
&lt;p&gt;实际就是SmartPoolSourceCreator,发送队列&lt;strong&gt;创建者&lt;/strong&gt;，默认有5个发送队列，其实每个连接一个发送队列，这边的所有sendingQueue组数是由SmartPool维护的&lt;/p&gt;
&lt;p&gt;m_SendingQueueSize：发送队列大小，默认为5&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// Creates the specified size.
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;size&quot;&amp;gt;The size.&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&quot;poolItems&quot;&amp;gt;The pool items.&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
public ISmartPoolSource Create(int size, out SendingQueue[] poolItems)
{
    var source = new ArraySegment&amp;lt;byte&amp;gt;[size * m_SendingQueueSize];//256*5
    poolItems = new SendingQueue[size];//size=256
    for (var i = 0; i &amp;lt; size; i++)
    {
        poolItems[i] = new SendingQueue(source, i * m_SendingQueueSize, m_SendingQueueSize);//SendingQueue中的source是所有的队列缓存，发送队列偏移量和发送队列容量
    }
    return new SmartPoolSource(source, size);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;smartpool&quot;&gt;SmartPool&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234232207-73893.png&quot; alt=&quot;1579327943978&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中维护了一个T（实际是SendingQueue）线程安全栈(m_GlobalStack)。由此看出SmartPool就是SendingQueue的池&lt;/p&gt;
&lt;p&gt;m_MinPoolSize：Math.Max(config.MaxConnectionNumber / 6, 256)&lt;/p&gt;
&lt;p&gt;m_MaxPoolSize：Math.Max(config.MaxConnectionNumber * 2, 256)&lt;/p&gt;
&lt;p&gt;m_SourceCreator：new SendingQueueSourceCreator(config.SendingQueueSize)&lt;/p&gt;
&lt;p&gt;m_ItemsSource：保存着SmartPoolSource[]对象,该对象实际上是所有的sendingqueue缓存。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;m_GlobalStack&lt;/strong&gt;：保存着单个SendingQueuep对象的数组&lt;/p&gt;
&lt;p&gt;Initialize()：初始化函数，初始化上面的变量&lt;/p&gt;
&lt;h3 id=&quot;smartpoolsource&quot;&gt;SmartPoolSource&lt;/h3&gt;
&lt;p&gt;维护所有的发送队列缓存，并保存sendingQueue的个数&lt;/p&gt;
&lt;p&gt;Source：是object类型，实际上是ArraySegment&amp;lt;byte&amp;gt;[]，实际上是所有的sendingqueue的缓存，大小为&lt;code&gt;size*sendingqueuesize=256*5&lt;/code&gt;，&lt;/p&gt;
&lt;p&gt;Count:为默认值5&lt;/p&gt;
&lt;h2 id=&quot;other.dll&quot;&gt;Other.dll&lt;/h2&gt;
&lt;h3 id=&quot;socketasynceventargs-类&quot;&gt;&lt;a href=&quot;https://docs.microsoft.com/zh-cn/dotnet/api/system.net.sockets.socketasynceventargs?f1url=https%3A%2F%2Fmsdn.microsoft.com%2Fquery%2Fdev15.query%3FappId%3DDev15IDEF1%26l%3DZH-CN%26k%3Dk(System.Net.Sockets.SocketAsyncEventArgs);k(TargetFrameworkMoniker-.NETFramework,Version%3Dv4.5);k(DevLang-csharp)%26rd%3Dtrue&amp;amp;view=netframework-4.8&quot;&gt;SocketAsyncEventArgs&lt;/a&gt; 类&lt;/h3&gt;
&lt;p&gt;表示异步套接字操作。&lt;/p&gt;
&lt;h2 id=&quot;设置ip和port调用流程&quot;&gt;设置IP和Port调用流程&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;创建ServerConfig实例，RootConfig实例&lt;/li&gt;
&lt;li&gt;设置m_State状态，线程安全的，通过Interlocked.CompareExchange方法设置&lt;/li&gt;
&lt;li&gt;在setbasic中设置RootConfig,m_Name,Config，设置currentculture,设置线程池参数，设置m_socketfactory,设置textencoding,&lt;/li&gt;
&lt;li&gt;设置logfactory&lt;/li&gt;
&lt;li&gt;在setMedium中设置&lt;strong&gt;ReceiveFilterFactory&lt;/strong&gt;，m_ConnectionFilters，m_CommandLoaders（add &lt;strong&gt;ReflectCommandLoader&lt;/strong&gt;）&lt;/li&gt;
&lt;li&gt;在SetupAdvanced中设置BaseSecurity和Certificate，设置&lt;strong&gt;listners(ListenerInfo)&lt;/strong&gt; 设置CommandFilterAttribute，遍历m_CommandLoaders，订阅Error,Updated事件，调用Initialize方法，通过TryLoadCommands方法获取命令集合commands，遍历命令集合添加命令到discoveredCommands集合中&lt;/li&gt;
&lt;li&gt;遍历discoveredCommands集合，将其添加到命令容器 m_CommandContainer中，使用Interlocked.Exchange方法保证线程安全&lt;/li&gt;
&lt;li&gt;在SetupFinal中设置ReceiveFilterFactory=new CommandLineReceiveFilterFactory(TextEncoding)，设置m_ServerStatus,通过socketfactory获得serverfactory。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;start调用流程&quot;&gt;start调用流程&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;调用SuperSocket.SocketBase.AppServer中start()方法，调用基类AppServerBase的start()方法，该方法中调用socketserver的start方法&lt;/li&gt;
&lt;li&gt;在socketserver的start方法中设置BufferManager,创建&lt;strong&gt;SocketAsyncEventArg&lt;/strong&gt;,并通过buffermanager设置其buffer,并创建&lt;strong&gt;SocketAsyncEventArgProxys&lt;/strong&gt;, &lt;strong&gt;SocketAsyncEventArgProxys&lt;/strong&gt;集合赋值给&lt;strong&gt;m_ReadWritePool&lt;/strong&gt;。调用SocketServer基类中的start&lt;/li&gt;
&lt;li&gt;在socketserver基类的start中创建&lt;strong&gt;SendingQueuePool&lt;/strong&gt;并初始化,实际是初始化队列池中的sendingqueue队列；通过遍历ListenerInfo集合创建TcpAsyncSocketListener监听者，订阅监听者的&lt;strong&gt;stop，error,NewClientAccepted&lt;/strong&gt;事件，并开始监听Listener.Start,也添加到容器中。&lt;/li&gt;
&lt;li&gt;Listener.Start中创建一个监听Listen_socket和&lt;strong&gt;new异步套接字SocketAsyncEventArgs&lt;/strong&gt;,并订阅Compeleted事件，启用socket监听，并调用AcceptAsync方法，异步完成触发compeleted事件，调用ProcessAccept方法，原来的方法异步已经触发&lt;strong&gt;重新调用一下AcceptAsync方法，通过函数递归实现while&lt;/strong&gt;，判定acceptsocket是否正常，触发NewClientAccepted事件，&lt;/li&gt;
&lt;li&gt;事件触发AsyncSocketServer 类中的ProcessNewClient方法，从m_ReadWritePool池中取一个空闲的SocketAsyncEventArgProxy，并通过代理，socket创建AsyncSocketSession，并通过socketsession创建Appsession，在创建过程中做连接过滤，初始化app'session，通过receivefactory创建receivefilter，同时初始化socketsession,主要是订阅SocketAsyncEventArgProxy中的compeleted事件。调用socketsession的start方法&lt;/li&gt;
&lt;li&gt;在socketsession中调用&lt;strong&gt;startreceive&lt;/strong&gt;方法,中调用socket.ReceiveAsync方法，当异步完成时调用socketProxy的SocketEventArgs_Completed方法，该方法调用SocketSession的ProcessReceive方法，在该方法中执行过滤FilterRequest,执行命令，再一次&lt;strong&gt;调用startReceive方法，如此不停通过异步直接实现接收循环&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;send调用流程&quot;&gt;send调用流程&lt;/h2&gt;
&lt;p&gt;在订阅了NewRequestReceived事件之后，该事件会有两个参数，一个是appsession，一个是requestinfo,&lt;/p&gt;
&lt;p&gt;appsession和socketsession完成，&lt;/p&gt;
&lt;p&gt;在appsession的InteralSend函数中对sendtimeout进行限制。&lt;/p&gt;
&lt;p&gt;在socketsession中将消息压入消息栈对消息进行校验，最终是通过socket.send和socket.sendasync两个方法将消息发送。&lt;/p&gt;
&lt;h2 id=&quot;stop调用流程&quot;&gt;Stop调用流程&lt;/h2&gt;
&lt;p&gt;先调用stop再调用close&lt;/p&gt;
&lt;p&gt;socketserver的stop，释放m_ReadWritePool中所有SocketAsyncEventArgs，所有listener的stop，释放其SocketAsyncEventArgs&lt;/p&gt;
&lt;p&gt;socket'session的closed，回收所有sendingqqueue到pool中.SuperSocket Layers](LearnSuperSocket.assets/layermodel-1579317752168.jpg)&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Reusable IO Buffer Pool：BufferManager类&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;supersocket-对象模型图示意图-1&quot;&gt;SuperSocket 对象模型图示意图&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/lovexinyi/p/LearnSuperSocket.assets/objectmodel.jpg&quot; alt=&quot;SuperSocket Object Model&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;supersocket-请求处理模型示意图-1&quot;&gt;SuperSocket 请求处理模型示意图&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/lovexinyi/p/LearnSuperSocket.assets/requesthandlingmodel.jpg&quot; alt=&quot;SuperSocket Request Handling Model&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;supersocket-隔离模型示意图-1&quot;&gt;SuperSocket 隔离模型示意图&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/lovexinyi/p/LearnSuperSocket.assets/isolationmodel.jpg&quot; alt=&quot;SuperSocket Isolation Model&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;config-1&quot;&gt;Config&lt;/h3&gt;
&lt;h3 id=&quot;command-filters-1&quot;&gt;Command Filters&lt;/h3&gt;
&lt;h3 id=&quot;loglogfactory-1&quot;&gt;Log/LogFactory&lt;/h3&gt;
&lt;h3 id=&quot;command-loaders-1&quot;&gt;Command Loaders&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234232221-1399409994.png&quot; alt=&quot;1579856396698&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;receivefilterfactory-1&quot;&gt;ReceiveFilterFactory&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234232233-1955938098.png&quot; alt=&quot;1579855102888&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;receivefilter-1&quot;&gt;ReceiveFilter&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234232244-292024629.png&quot; alt=&quot;1579855469740&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;connection-filters-1&quot;&gt;Connection Filters&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234232270-2080905051.png&quot; alt=&quot;1579856311644&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;socketbase.dll-1&quot;&gt;SocketBase.dll&lt;/h2&gt;
&lt;h3 id=&quot;isessionbase-1&quot;&gt;ISessionBase&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234233784-968329155.png&quot; alt=&quot;1579318554194&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;appsession-1&quot;&gt;AppSession&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234233802-1757373593.png&quot; alt=&quot;1580125323588&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234234740-1987875917.png&quot; alt=&quot;1579319140513&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对AppServer和SocketSession的包装&lt;/p&gt;
&lt;h3 id=&quot;serverconfig-1&quot;&gt;ServerConfig&lt;/h3&gt;
&lt;p&gt;服务参数配置,在serverbase基类SetUp中创建&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// Setups with the specified ip and port.
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;ip&quot;&amp;gt;The ip.&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&quot;port&quot;&amp;gt;The port.&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&quot;socketServerFactory&quot;&amp;gt;The socket server factory.&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&quot;receiveFilterFactory&quot;&amp;gt;The Receive filter factory.&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&quot;logFactory&quot;&amp;gt;The log factory.&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&quot;connectionFilters&quot;&amp;gt;The connection filters.&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&quot;commandLoaders&quot;&amp;gt;The command loaders.&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;return setup result&amp;lt;/returns&amp;gt;
public bool Setup(string ip, int port, ISocketServerFactory socketServerFactory = null, IReceiveFilterFactory&amp;lt;TRequestInfo&amp;gt; receiveFilterFactory = null, ILogFactory logFactory = null, IEnumerable&amp;lt;IConnectionFilter&amp;gt; connectionFilters = null, IEnumerable&amp;lt;ICommandLoader&amp;lt;ICommand&amp;lt;TAppSession, TRequestInfo&amp;gt;&amp;gt;&amp;gt; commandLoaders = null)
{
    return Setup(new ServerConfig
                    {
                        Ip = ip,
                        Port = port
                    },
                    socketServerFactory,
                    receiveFilterFactory,
                    logFactory,
                    connectionFilters,
                    commandLoaders);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234234995-572270797.png&quot; alt=&quot;1578468089417&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;rootconfig-1&quot;&gt;RootConfig&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234234358-873568325.png&quot; alt=&quot;1578469017093&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;MaxWorkingThreads：最大工作线程数量&lt;/li&gt;
&lt;li&gt;MaxCompletionPortThreads：线程池中异步 I/O 线程的最大数目。&lt;/li&gt;
&lt;li&gt;PerformanceDataCollectInterval：性能数据收集间隔&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;requestinfo-1&quot;&gt;RequestInfo&lt;/h3&gt;
&lt;p&gt;类图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234234215-2079964986.png&quot; alt=&quot;1578446037999&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;基类是RequestInfo，提供了两个方法Key和Body,Body是模板，由子类确定具体类型&lt;/li&gt;
&lt;li&gt;StringRequestInfo,在父类基础上提供了一个参数，String[] Parameters&lt;/li&gt;
&lt;li&gt;RequestInfo&amp;lt;TRequestHeader, TRequestBody&amp;gt;:提供了请求头和请求体类型的模板。&lt;/li&gt;
&lt;li&gt;三个接口，key属性，body属性，heater属性&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;listenerinfo-1&quot;&gt;ListenerInfo&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234232243-1921196964.png&quot; alt=&quot;1579947882373&quot;/&gt;&lt;/p&gt;
&lt;p&gt;监听节点&lt;/p&gt;
&lt;h3 id=&quot;listenerconfig-1&quot;&gt;ListenerConfig&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234232279-239577993.png&quot; alt=&quot;1578474012112&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;reflectcommandloader-1&quot;&gt;ReflectCommandLoader&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234234647-1807472130.png&quot; alt=&quot;1578472566238&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ReflectCommandLoader:通过TryLoadCommands方法反射出程序集中的所有命令&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// Tries to load commands.
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;commands&quot;&amp;gt;The commands.&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
public override bool TryLoadCommands(out IEnumerable&amp;lt;TCommand&amp;gt; commands)
{
    commands = null;
    var commandAssemblies = new List&amp;lt;Assembly&amp;gt;();
    if (m_AppServer.GetType().Assembly != this.GetType().Assembly)
        commandAssemblies.Add(m_AppServer.GetType().Assembly);
    string commandAssembly = m_AppServer.Config.Options.GetValue(&quot;commandAssembly&quot;);
    if (!string.IsNullOrEmpty(commandAssembly))
    {
        OnError(&quot;The configuration attribute 'commandAssembly' is not in used, please try to use the child node 'commandAssemblies' instead!&quot;);
        return false;
    }
    if (m_AppServer.Config.CommandAssemblies != null &amp;amp;&amp;amp; m_AppServer.Config.CommandAssemblies.Any())
    {
        try
        {
            var definedAssemblies = AssemblyUtil.GetAssembliesFromStrings(m_AppServer.Config.CommandAssemblies.Select(a =&amp;gt; a.Assembly).ToArray());

            if (definedAssemblies.Any())
                commandAssemblies.AddRange(definedAssemblies);
        }
        catch (Exception e)
        {
            OnError(new Exception(&quot;Failed to load defined command assemblies!&quot;, e));
            return false;
        }
    }
    if (!commandAssemblies.Any())
    {
        commandAssemblies.Add(Assembly.GetEntryAssembly());
    }
    var outputCommands = new List&amp;lt;TCommand&amp;gt;();
    foreach (var assembly in commandAssemblies)
    {
        try
        {
            outputCommands.AddRange(assembly.GetImplementedObjectsByInterface&amp;lt;TCommand&amp;gt;());
        }
        catch (Exception exc)
        {
            OnError(new Exception(string.Format(&quot;Failed to get commands from the assembly {0}!&quot;, assembly.FullName), exc));
            return false;
        }
    }
    commands = outputCommands;
    return true;
}
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;statusinfocollection-1&quot;&gt;StatusInfoCollection&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234232288-1971081133.png&quot; alt=&quot;1578475314305&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;appserverbase-1&quot;&gt;AppServerBase&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234235036-1353549858.png&quot; alt=&quot;1580125365801&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234235715-1597745842.png&quot; alt=&quot;1578487267303&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;appseverbasetappsessiontrequestinfo-1&quot;&gt;AppSeverBase&amp;lt;TAppSession,TRequestInfo&amp;gt;&lt;/h3&gt;
&lt;p&gt;m_CommandContainer：命令容器&lt;/p&gt;
&lt;p&gt;m_CommandLoaders&lt;/p&gt;
&lt;p&gt;m_ConnectionFilters&lt;/p&gt;
&lt;p&gt;m_GlobalCommandFilters&lt;/p&gt;
&lt;p&gt;m_Listeners&lt;/p&gt;
&lt;p&gt;m_SocketServerFactory：在SetupBas&lt;/p&gt;
&lt;h2 id=&quot;facility.dll-1&quot;&gt;Facility.dll&lt;/h2&gt;
&lt;h3 id=&quot;policyreceivefilterfactory-1&quot;&gt;PolicyReceiveFilterFactory&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234232499-623862725.png&quot; alt=&quot;1579780070988&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;policyrecievefilter-1&quot;&gt;PolicyRecieveFilter&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234234170-863192716.png&quot; alt=&quot;1579780715003&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;protocol-1&quot;&gt;Protocol&lt;/h3&gt;
&lt;p&gt;ReceiveFilterBase&lt;/p&gt;
&lt;p&gt;类图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234234400-96760615.png&quot; alt=&quot;1578464691790&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234235354-190631870.png&quot; alt=&quot;1578464252406&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234233398-870416969.png&quot; alt=&quot;1578466885687&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在SuperSocket.SocketBase.Protocol程序集中&lt;/li&gt;
&lt;li&gt;IReceiveFilter&amp;lt;TRequestInfo&amp;gt;接口，接收解析接口
&lt;ul&gt;&lt;li&gt;Filter方法，解析会话请求的信息，参数包括，读取缓冲，偏移量，长度，是否copy，没有被解析的长度&lt;/li&gt;
&lt;li&gt;LeftBufferSize属性：空余的缓冲区长度&lt;/li&gt;
&lt;li&gt;NextReceiveFilter属性，下一个接收解析器&lt;/li&gt;
&lt;li&gt;Reset方法，恢复初始化&lt;/li&gt;
&lt;li&gt;State:解析器状态，正常和错误状态&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ArraySegmentEx&amp;lt;T&amp;gt;数段类
&lt;ul&gt;&lt;li&gt;T为数组模板&lt;/li&gt;
&lt;li&gt;Array数组，count:数量，Offset偏移量，From从，To到&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ArraySegmentList&amp;lt;T&amp;gt;数段列表
&lt;ul&gt;&lt;li&gt;实现了一个数组段列表&lt;/li&gt;
&lt;li&gt;m_PrevSegment：当前的数段&lt;/li&gt;
&lt;li&gt;m_PrevSegmentIndex，数段所在的index&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ReceiveFilterBase&amp;lt;TRequestInfo&amp;gt;
&lt;ul&gt;&lt;li&gt;BufferSegments属性&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;socketengine.dll-1&quot;&gt;SocketEngine.dll&lt;/h2&gt;
&lt;h3 id=&quot;performancemonitor-1&quot;&gt;PerformanceMonitor&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234233822-1930389035.png&quot; alt=&quot;1580126841482&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;socketsession-1&quot;&gt;SocketSession&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234235545-2085838074.png&quot; alt=&quot;1579319465778&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在初始化里对AppSession产生依赖，同时维护Socket和SmartPool(SendingQueue[])，因为维护着socket所以发送接收数据都是通过这个类。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;设置状态：AddStateFlag（）TryAddStateFlag（）RemoveStateFlag（）,AddStateFlag：自旋设置m_State状态，线程安全的&lt;/li&gt;
&lt;li&gt;m_Client:Socket&lt;/li&gt;
&lt;li&gt;SessionID:new guid&lt;/li&gt;
&lt;li&gt;LocalEndPoint:本地Id端&lt;/li&gt;
&lt;li&gt;RemoteEndPoint：远程终结点&lt;/li&gt;
&lt;li&gt;m_SendingQueuePool：实际是SmartPool类的实例，该实例维护者sendingQueue数组&lt;/li&gt;
&lt;li&gt;m_SendingQueue：从SmarlPool中获取一个SendingQueue实例。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;方法&lt;/p&gt;
&lt;p&gt;Initialize()方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;初始化m_SendingQueuePool和m_SendingQueue&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;TrySend()方法：参数：IList&amp;lt;ArraySegment&amp;lt;byte&amp;gt;&amp;gt; segments：将segments压入sendingqueue队列并调用StartSend最终是调用&lt;strong&gt;SendAsync&lt;/strong&gt;或&lt;strong&gt;SendSync&lt;/strong&gt;，这个是由子类实现。&lt;/p&gt;
&lt;h3 id=&quot;asyncsocketsession-1&quot;&gt;AsyncSocketSession&lt;/h3&gt;
&lt;p&gt;在子类中维护SocketAsyncEventArgs&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;SocketAsyncProxy：维护着SocketAsyncEventArgs&lt;/li&gt;
&lt;li&gt;m_SocketEventArgSend：发送的SocketAsyncEventArgs实例&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在初始化中如果同步发送就使用m_SocketEventArgSend，并OnSendingCompleted方法绑定其Completed事件&lt;/p&gt;
&lt;p&gt;在SendAsync()方法中将SendingQueue实例给m_SocketEventArgSend的UserToken属性，并调用m_SocketEventArgSend的&lt;strong&gt;SetBuffer&lt;/strong&gt;和&lt;strong&gt;SendAsync&lt;/strong&gt;方法，发送失败也调用OnSendingCompleted&lt;/p&gt;
&lt;p&gt;SocketAsyncProxy中的Completed事件中调用ProcessReceive方法，再调用&lt;code&gt;this.AppSession.ProcessRequest(e.Buffer, e.Offset, e.BytesTransferred, true);&lt;/code&gt;方法&lt;/p&gt;
&lt;h3 id=&quot;asyncstreamsocketsession-1&quot;&gt;AsyncStreamSocketSession&lt;/h3&gt;
&lt;h3 id=&quot;socketfactory-1&quot;&gt;SocketFactory&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234233204-627006337.png&quot; alt=&quot;1578467105778&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// Creates the socket server.
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;typeparam name=&quot;TRequestInfo&quot;&amp;gt;The type of the request info.&amp;lt;/typeparam&amp;gt;
/// &amp;lt;param name=&quot;appServer&quot;&amp;gt;The app server.&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&quot;listeners&quot;&amp;gt;The listeners.&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&quot;config&quot;&amp;gt;The config.&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
public ISocketServer CreateSocketServer&amp;lt;TRequestInfo&amp;gt;(IAppServer appServer, ListenerInfo[] listeners, IServerConfig config)
    where TRequestInfo : IRequestInfo
{
    if (appServer == null)
        throw new ArgumentNullException(&quot;appServer&quot;);
    if (listeners == null)
        throw new ArgumentNullException(&quot;listeners&quot;);
    if (config == null)
        throw new ArgumentNullException(&quot;config&quot;);
    switch(config.Mode)
    {
        case(SocketMode.Tcp):
            return new AsyncSocketServer(appServer, listeners);
        case(SocketMode.Udp):
            return new UdpSocketServer&amp;lt;TRequestInfo&amp;gt;(appServer, listeners);
        default:
            throw new NotSupportedException(&quot;Unsupported SocketMode:&quot; + config.Mode);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;socketservers-1&quot;&gt;SocketServers&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234235178-880063320.png&quot; alt=&quot;1578487919018&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;asyncsocketserver-1&quot;&gt;AsyncSocketServer&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;缓存管理器m_BufferManager&lt;/li&gt;
&lt;li&gt;线程安全的SocketAsyncEventArgsProxy栈&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;构造函数，父类&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public TcpSocketServerBase(IAppServer appServer, ListenerInfo[] listeners)
    : base(appServer, listeners)
{
    var config = appServer.Config;

    uint dummy = 0;
    m_KeepAliveOptionValues = new byte[Marshal.SizeOf(dummy) * 3];
    m_KeepAliveOptionOutValues = new byte[m_KeepAliveOptionValues.Length];
    //whether enable KeepAlive
    BitConverter.GetBytes((uint)1).CopyTo(m_KeepAliveOptionValues, 0);
    //how long will start first keep alive
    BitConverter.GetBytes((uint)(config.KeepAliveTime * 1000)).CopyTo(m_KeepAliveOptionValues, Marshal.SizeOf(dummy));
    //keep alive interval
    BitConverter.GetBytes((uint)(config.KeepAliveInterval * 1000)).CopyTo(m_KeepAliveOptionValues, Marshal.SizeOf(dummy) * 2);

    m_SendTimeOut = config.SendTimeOut;
    m_ReceiveBufferSize = config.ReceiveBufferSize;
    m_SendBufferSize = config.SendBufferSize;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public override bool Start()
{
    try
    {
        int bufferSize = AppServer.Config.ReceiveBufferSize;

        if (bufferSize &amp;lt;= 0)
            bufferSize = 1024 * 4;

        m_BufferManager = new BufferManager(bufferSize * AppServer.Config.MaxConnectionNumber, bufferSize);

        try
        {
            m_BufferManager.InitBuffer();
        }
        catch (Exception e)
        {
            AppServer.Logger.Error(&quot;Failed to allocate buffer for async socket communication, may because there is no enough memory, please decrease maxConnectionNumber in configuration!&quot;, e);
            return false;
        }

        // preallocate pool of SocketAsyncEventArgs objects
        SocketAsyncEventArgs socketEventArg;

        var socketArgsProxyList = new List&amp;lt;SocketAsyncEventArgsProxy&amp;gt;(AppServer.Config.MaxConnectionNumber);

        for (int i = 0; i &amp;lt; AppServer.Config.MaxConnectionNumber; i++)
        {
            //Pre-allocate a set of reusable SocketAsyncEventArgs
            socketEventArg = new SocketAsyncEventArgs();
            m_BufferManager.SetBuffer(socketEventArg);

            socketArgsProxyList.Add(new SocketAsyncEventArgsProxy(socketEventArg));
        }

        m_ReadWritePool = new ConcurrentStack&amp;lt;SocketAsyncEventArgsProxy&amp;gt;(socketArgsProxyList);

        if (!base.Start())
            return false;

        IsRunning = true;
        return true;
    }
    catch (Exception e)
    {
        AppServer.Logger.Error(e);
        return false;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;socketasynceventargsproxy-1&quot;&gt;SocketAsyncEventArgsProxy&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234233208-1446409821.png&quot; alt=&quot;1579316308225&quot;/&gt;&lt;/p&gt;
&lt;p&gt;SocketAsyncEventArgs的代理&lt;/p&gt;
&lt;p&gt;维护着一个SocketAsyncEventArgs对象，并订阅了该对象的Completed事件(异步完成事件)&lt;/p&gt;
&lt;p&gt;IsRecyclable：是否可以循环使用&lt;/p&gt;
&lt;p&gt;OrigOffset：原始偏移量&lt;/p&gt;
&lt;p&gt;每当异步完成的时候调用SocketAsyncEventArgs实例中的&lt;strong&gt;UserToken属性&lt;/strong&gt;，该&lt;strong&gt;属性实际上保存着SocketSession&lt;/strong&gt;实例，并调用SocketSession的&lt;strong&gt;ProcessReceive()&lt;/strong&gt;和&lt;strong&gt;AsyncRun()&lt;/strong&gt;方法；&lt;strong&gt;socketSession.AsyncRun(() =&amp;gt; socketSession.ProcessReceive(e));&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;UserToken属性是在SocketAsyncEventArgsProxy的&lt;strong&gt;初始化方法中定义的&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public void Initialize(IAsyncSocketSession socketSession)
{
    SocketEventArgs.UserToken = socketSession;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代理模式&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234233328-1320440775.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;bootstrapfactory-1&quot;&gt;BootstrapFactory&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234233202-584465515.png&quot; alt=&quot;1580106366845&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;defaultbootstrap-1&quot;&gt;DefaultBootStrap&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234234963-1699338104.png&quot; alt=&quot;1579403530245&quot;/&gt;&lt;/p&gt;
&lt;p&gt;引导配置文件并通过配置实例化各个server和factory,在CreateWorkItemInstance方法通过Activator.CreateInstance(serviceType)实例化&lt;/p&gt;
&lt;h3 id=&quot;configurationwatcher-1&quot;&gt;ConfigurationWatcher&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234233210-1843036326.png&quot; alt=&quot;1580108736600&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;socketlistenerbase-1&quot;&gt;SocketListenerBase&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234234464-1408620243.png&quot; alt=&quot;1579439987190&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;tcpasyncsocketlistener-1&quot;&gt;TcpAsyncSocketListener&lt;/h3&gt;
&lt;p&gt;监听类，由三个事件：监听错误，监听停止，新的客户端连接&lt;/p&gt;
&lt;p&gt;m_ListrnSocket：监听Socket&lt;/p&gt;
&lt;h3 id=&quot;workitemfactoryinfoloader-1&quot;&gt;WorkItemFactoryInfoLoader&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234234122-861992285.png&quot; alt=&quot;1580119613894&quot;/&gt;&lt;/p&gt;
&lt;p&gt;配置文件载入 LoadResult,载入配置的connectionFilter,logfactory,commandloaderfactory，将appserver转化成IworkItem接口，&lt;/p&gt;
&lt;h2 id=&quot;common.dll-1&quot;&gt;Common.dll&lt;/h2&gt;
&lt;h3 id=&quot;buffermanager-1&quot;&gt;BufferManager&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234233207-580530302.png&quot; alt=&quot;1578487794792&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此类创建一个大缓冲区，该缓冲区可以分配给每个套接字I / O操作使用，并分配给SocketAsyncEventArgs对象。 这使得bufffer可以轻松地重用，并且可以&lt;strong&gt;防止堆内存碎片化&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;BufferManager类上公开的操作不是线程安全的。我觉得这个类不需要线程安全，因为每个socket获得数据基本不会并发执行。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;m_buffer:所有的字节缓存&lt;/li&gt;
&lt;li&gt;m_bufferSize:单个片段的缓存大小&lt;/li&gt;
&lt;li&gt;m_currentIndex：当前字节在总缓存中的索引&lt;/li&gt;
&lt;li&gt;m_freeIndexPool:空闲索引池&lt;/li&gt;
&lt;li&gt;m_numBytes：缓存片段的数目&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;主要提供两个方法：一个是SetBuffer和FreeBuffer&lt;/p&gt;
&lt;p&gt;SetBuffer：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;检查空闲索引栈中是否有值，有值就直接使用空闲索引栈中的值，并将其值从栈中推出，&lt;/li&gt;
&lt;li&gt;如果没有空闲栈的值就先检查剩余的缓存是否有一个片段大小，有的化就设置并改变m_currentIndex索引，没有返回false&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;FreeBuffer：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;将当前索引添加到空闲索引栈中，并释放SocketAsyncEventArgs中用的缓存片段。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;arraysegmentlist-1&quot;&gt;ArraySegmentList&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234234481-435260542.png&quot; alt=&quot;1579323401012&quot;/&gt;&lt;/p&gt;
&lt;p&gt;方法：&lt;/p&gt;
&lt;p&gt;IndexOf：T在所有缓存中的索引&lt;/p&gt;
&lt;h3 id=&quot;arraysegmentex-1&quot;&gt;ArraySegmentEx&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;数组，是保存着所有缓存，T[]&lt;/li&gt;
&lt;li&gt;偏移，该片段在缓存中的位置&lt;/li&gt;
&lt;li&gt;数量，该片段的长度&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;sendingqueue-1&quot;&gt;SendingQueue&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234234504-340509582.png&quot; alt=&quot;1579329295160&quot;/&gt;&lt;/p&gt;
&lt;p&gt;维护ArraySegment&amp;lt;byte&amp;gt;[] globalQueue， globalQueue中包含着所有所有缓存&lt;/p&gt;
&lt;p&gt;入栈，出战，开始入栈，开始出栈。&lt;/p&gt;
&lt;p&gt;所有的发送队列内存片组成一个大的arraysegment，由SendingQueueSourceCreator创建，并由SmartPool维护&lt;/p&gt;
&lt;h3 id=&quot;sendingqueuesourcecreator-1&quot;&gt;SendingQueueSourceCreator&lt;/h3&gt;
&lt;p&gt;实际就是SmartPoolSourceCreator,发送队列&lt;strong&gt;创建者&lt;/strong&gt;，默认有5个发送队列，其实每个连接一个发送队列，这边的所有sendingQueue组数是由SmartPool维护的&lt;/p&gt;
&lt;p&gt;m_SendingQueueSize：发送队列大小，默认为5&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// Creates the specified size.
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;size&quot;&amp;gt;The size.&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&quot;poolItems&quot;&amp;gt;The pool items.&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
public ISmartPoolSource Create(int size, out SendingQueue[] poolItems)
{
    var source = new ArraySegment&amp;lt;byte&amp;gt;[size * m_SendingQueueSize];//256*5
    poolItems = new SendingQueue[size];//size=256
    for (var i = 0; i &amp;lt; size; i++)
    {
        poolItems[i] = new SendingQueue(source, i * m_SendingQueueSize, m_SendingQueueSize);//SendingQueue中的source是所有的队列缓存，发送队列偏移量和发送队列容量
    }
    return new SmartPoolSource(source, size);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;smartpool-1&quot;&gt;SmartPool&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234234304-110842696.png&quot; alt=&quot;1579327943978&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中维护了一个T（实际是SendingQueue）线程安全栈(m_GlobalStack)。由此看出SmartPool就是SendingQueue的池&lt;/p&gt;
&lt;p&gt;m_MinPoolSize：Math.Max(config.MaxConnectionNumber / 6, 256)&lt;/p&gt;
&lt;p&gt;m_MaxPoolSize：Math.Max(config.MaxConnectionNumber * 2, 256)&lt;/p&gt;
&lt;p&gt;m_SourceCreator：new SendingQueueSourceCreator(config.SendingQueueSize)&lt;/p&gt;
&lt;p&gt;m_ItemsSource：保存着SmartPoolSource[]对象,该对象实际上是所有的sendingqueue缓存。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;m_GlobalStack&lt;/strong&gt;：保存着单个SendingQueuep对象的数组&lt;/p&gt;
&lt;p&gt;Initialize()：初始化函数，初始化上面的变量&lt;/p&gt;
&lt;h3 id=&quot;smartpoolsource-1&quot;&gt;SmartPoolSource&lt;/h3&gt;
&lt;p&gt;维护所有的发送队列缓存，并保存sendingQueue的个数&lt;/p&gt;
&lt;p&gt;Source：是object类型，实际上是ArraySegment&amp;lt;byte&amp;gt;[]，实际上是所有的sendingqueue的缓存，大小为&lt;code&gt;size*sendingqueuesize=256*5&lt;/code&gt;，&lt;/p&gt;
&lt;p&gt;Count:为默认值5&lt;/p&gt;
&lt;h2 id=&quot;other.dll-1&quot;&gt;Other.dll&lt;/h2&gt;
&lt;h3 id=&quot;socketasynceventargs-类-1&quot;&gt;&lt;a href=&quot;https://docs.microsoft.com/zh-cn/dotnet/api/system.net.sockets.socketasynceventargs?f1url=https%3A%2F%2Fmsdn.microsoft.com%2Fquery%2Fdev15.query%3FappId%3DDev15IDEF1%26l%3DZH-CN%26k%3Dk(System.Net.Sockets.SocketAsyncEventArgs);k(TargetFrameworkMoniker-.NETFramework,Version%3Dv4.5);k(DevLang-csharp)%26rd%3Dtrue&amp;amp;view=netframework-4.8&quot;&gt;SocketAsyncEventArgs&lt;/a&gt; 类&lt;/h3&gt;
&lt;p&gt;表示异步套接字操作。&lt;/p&gt;
&lt;h2 id=&quot;设置ip和port调用流程-1&quot;&gt;设置IP和Port调用流程&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;创建ServerConfig实例，RootConfig实例&lt;/li&gt;
&lt;li&gt;设置m_State状态，线程安全的，通过Interlocked.CompareExchange方法设置&lt;/li&gt;
&lt;li&gt;在setbasic中设置RootConfig,m_Name,Config，设置currentculture,设置线程池参数，设置m_socketfactory,设置textencoding,&lt;/li&gt;
&lt;li&gt;设置logfactory&lt;/li&gt;
&lt;li&gt;在setMedium中设置&lt;strong&gt;ReceiveFilterFactory&lt;/strong&gt;，m_ConnectionFilters，m_CommandLoaders（add &lt;strong&gt;ReflectCommandLoader&lt;/strong&gt;）&lt;/li&gt;
&lt;li&gt;在SetupAdvanced中设置BaseSecurity和Certificate，设置&lt;strong&gt;listners(ListenerInfo)&lt;/strong&gt; 设置CommandFilterAttribute，遍历m_CommandLoaders，订阅Error,Updated事件，调用Initialize方法，通过TryLoadCommands方法获取命令集合commands，遍历命令集合添加命令到discoveredCommands集合中&lt;/li&gt;
&lt;li&gt;遍历discoveredCommands集合，将其添加到命令容器 m_CommandContainer中，使用Interlocked.Exchange方法保证线程安全&lt;/li&gt;
&lt;li&gt;在SetupFinal中设置ReceiveFilterFactory=new CommandLineReceiveFilterFactory(TextEncoding)，设置m_ServerStatus,通过socketfactory获得serverfactory。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;start调用流程-1&quot;&gt;start调用流程&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;调用SuperSocket.SocketBase.AppServer中start()方法，调用基类AppServerBase的start()方法，该方法中调用socketserver的start方法&lt;/li&gt;
&lt;li&gt;在socketserver的start方法中设置BufferManager,创建&lt;strong&gt;SocketAsyncEventArg&lt;/strong&gt;,并通过buffermanager设置其buffer,并创建&lt;strong&gt;SocketAsyncEventArgProxys&lt;/strong&gt;, &lt;strong&gt;SocketAsyncEventArgProxys&lt;/strong&gt;集合赋值给&lt;strong&gt;m_ReadWritePool&lt;/strong&gt;。调用SocketServer基类中的start&lt;/li&gt;
&lt;li&gt;在socketserver基类的start中创建&lt;strong&gt;SendingQueuePool&lt;/strong&gt;并初始化,实际是初始化队列池中的sendingqueue队列；通过遍历ListenerInfo集合创建TcpAsyncSocketListener监听者，订阅监听者的&lt;strong&gt;stop，error,NewClientAccepted&lt;/strong&gt;事件，并开始监听Listener.Start,也添加到容器中。&lt;/li&gt;
&lt;li&gt;Listener.Start中创建一个监听Listen_socket和&lt;strong&gt;new异步套接字SocketAsyncEventArgs&lt;/strong&gt;,并订阅Compeleted事件，启用socket监听，并调用AcceptAsync方法，异步完成触发compeleted事件，调用ProcessAccept方法，原来的方法异步已经触发&lt;strong&gt;重新调用一下AcceptAsync方法，通过函数递归实现while&lt;/strong&gt;，判定acceptsocket是否正常，触发NewClientAccepted事件，&lt;/li&gt;
&lt;li&gt;事件触发AsyncSocketServer 类中的ProcessNewClient方法，从m_ReadWritePool池中取一个空闲的SocketAsyncEventArgProxy，并通过代理，socket创建AsyncSocketSession，并通过socketsession创建Appsession，在创建过程中做连接过滤，初始化app'session，通过receivefactory创建receivefilter，同时初始化socketsession,主要是订阅SocketAsyncEventArgProxy中的compeleted事件。调用socketsession的start方法&lt;/li&gt;
&lt;li&gt;在socketsession中调用&lt;strong&gt;startreceive&lt;/strong&gt;方法,中调用socket.ReceiveAsync方法，当异步完成时调用socketProxy的SocketEventArgs_Completed方法，该方法调用SocketSession的ProcessReceive方法，在该方法中执行过滤FilterRequest,执行命令，再一次&lt;strong&gt;调用startReceive方法，如此不停通过异步直接实现接收循环&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;send调用流程-1&quot;&gt;send调用流程&lt;/h2&gt;
&lt;p&gt;在订阅了NewRequestReceived事件之后，该事件会有两个参数，一个是appsession，一个是requestinfo,&lt;/p&gt;
&lt;p&gt;appsession和socketsession完成，&lt;/p&gt;
&lt;p&gt;在appsession的InteralSend函数中对sendtimeout进行限制。&lt;/p&gt;
&lt;p&gt;在socketsession中将消息压入消息栈对消息进行校验，最终是通过socket.send和socket.sendasync两个方法将消息发送。&lt;/p&gt;
&lt;h2 id=&quot;stop调用流程-1&quot;&gt;Stop调用流程&lt;/h2&gt;
&lt;p&gt;先调用stop再调用close&lt;/p&gt;
&lt;p&gt;socketserver的stop，释放m_ReadWritePool中所有SocketAsyncEventArgs，所有listener的stop，释放其SocketAsyncEventArgs&lt;/p&gt;
&lt;p&gt;socket'session的closed，回收所有sendingqqueue到pool中.SuperSocket Layers](LearnSuperSocket.assets/layermodel-1579317752168.jpg)&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Reusable IO Buffer Pool：BufferManager类&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;supersocket-对象模型图示意图-2&quot;&gt;SuperSocket 对象模型图示意图&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/lovexinyi/p/LearnSuperSocket.assets/objectmodel.jpg&quot; alt=&quot;SuperSocket Object Model&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;supersocket-请求处理模型示意图-2&quot;&gt;SuperSocket 请求处理模型示意图&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/lovexinyi/p/LearnSuperSocket.assets/requesthandlingmodel.jpg&quot; alt=&quot;SuperSocket Request Handling Model&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;supersocket-隔离模型示意图-2&quot;&gt;SuperSocket 隔离模型示意图&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/lovexinyi/p/LearnSuperSocket.assets/isolationmodel.jpg&quot; alt=&quot;SuperSocket Isolation Model&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;config-2&quot;&gt;Config&lt;/h3&gt;
&lt;h3 id=&quot;command-filters-2&quot;&gt;Command Filters&lt;/h3&gt;
&lt;h3 id=&quot;loglogfactory-2&quot;&gt;Log/LogFactory&lt;/h3&gt;
&lt;h3 id=&quot;command-loaders-2&quot;&gt;Command Loaders&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234234187-1520220820.png&quot; alt=&quot;1579856396698&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;receivefilterfactory-2&quot;&gt;ReceiveFilterFactory&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234233393-1203599998.png&quot; alt=&quot;1579855102888&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;receivefilter-2&quot;&gt;ReceiveFilter&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234234529-1786800554.png&quot; alt=&quot;1579855469740&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;connection-filters-2&quot;&gt;Connection Filters&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234232535-552134620.png&quot; alt=&quot;1579856311644&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;socketbase.dll-2&quot;&gt;SocketBase.dll&lt;/h2&gt;
&lt;h3 id=&quot;isessionbase-2&quot;&gt;ISessionBase&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234234262-202833901.png&quot; alt=&quot;1579318554194&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;appsession-2&quot;&gt;AppSession&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234234276-934735826.png&quot; alt=&quot;1580125323588&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234234933-1203183653.png&quot; alt=&quot;1579319140513&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对AppServer和SocketSession的包装&lt;/p&gt;
&lt;h3 id=&quot;serverconfig-2&quot;&gt;ServerConfig&lt;/h3&gt;
&lt;p&gt;服务参数配置,在serverbase基类SetUp中创建&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// Setups with the specified ip and port.
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;ip&quot;&amp;gt;The ip.&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&quot;port&quot;&amp;gt;The port.&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&quot;socketServerFactory&quot;&amp;gt;The socket server factory.&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&quot;receiveFilterFactory&quot;&amp;gt;The Receive filter factory.&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&quot;logFactory&quot;&amp;gt;The log factory.&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&quot;connectionFilters&quot;&amp;gt;The connection filters.&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&quot;commandLoaders&quot;&amp;gt;The command loaders.&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;return setup result&amp;lt;/returns&amp;gt;
public bool Setup(string ip, int port, ISocketServerFactory socketServerFactory = null, IReceiveFilterFactory&amp;lt;TRequestInfo&amp;gt; receiveFilterFactory = null, ILogFactory logFactory = null, IEnumerable&amp;lt;IConnectionFilter&amp;gt; connectionFilters = null, IEnumerable&amp;lt;ICommandLoader&amp;lt;ICommand&amp;lt;TAppSession, TRequestInfo&amp;gt;&amp;gt;&amp;gt; commandLoaders = null)
{
    return Setup(new ServerConfig
                    {
                        Ip = ip,
                        Port = port
                    },
                    socketServerFactory,
                    receiveFilterFactory,
                    logFactory,
                    connectionFilters,
                    commandLoaders);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234235103-2117060187.png&quot; alt=&quot;1578468089417&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;rootconfig-2&quot;&gt;RootConfig&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234234686-1070162785.png&quot; alt=&quot;1578469017093&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;MaxWorkingThreads：最大工作线程数量&lt;/li&gt;
&lt;li&gt;MaxCompletionPortThreads：线程池中异步 I/O 线程的最大数目。&lt;/li&gt;
&lt;li&gt;PerformanceDataCollectInterval：性能数据收集间隔&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;requestinfo-2&quot;&gt;RequestInfo&lt;/h3&gt;
&lt;p&gt;类图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234234623-825152601.png&quot; alt=&quot;1578446037999&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;基类是RequestInfo，提供了两个方法Key和Body,Body是模板，由子类确定具体类型&lt;/li&gt;
&lt;li&gt;StringRequestInfo,在父类基础上提供了一个参数，String[] Parameters&lt;/li&gt;
&lt;li&gt;RequestInfo&amp;lt;TRequestHeader, TRequestBody&amp;gt;:提供了请求头和请求体类型的模板。&lt;/li&gt;
&lt;li&gt;三个接口，key属性，body属性，heater属性&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;listenerinfo-2&quot;&gt;ListenerInfo&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234232473-276769760.png&quot; alt=&quot;1579947882373&quot;/&gt;&lt;/p&gt;
&lt;p&gt;监听节点&lt;/p&gt;
&lt;h3 id=&quot;listenerconfig-2&quot;&gt;ListenerConfig&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234233247-1762597446.png&quot; alt=&quot;1578474012112&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;reflectcommandloader-2&quot;&gt;ReflectCommandLoader&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234234828-1094790338.png&quot; alt=&quot;1578472566238&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ReflectCommandLoader:通过TryLoadCommands方法反射出程序集中的所有命令&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// Tries to load commands.
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;commands&quot;&amp;gt;The commands.&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
public override bool TryLoadCommands(out IEnumerable&amp;lt;TCommand&amp;gt; commands)
{
    commands = null;
    var commandAssemblies = new List&amp;lt;Assembly&amp;gt;();
    if (m_AppServer.GetType().Assembly != this.GetType().Assembly)
        commandAssemblies.Add(m_AppServer.GetType().Assembly);
    string commandAssembly = m_AppServer.Config.Options.GetValue(&quot;commandAssembly&quot;);
    if (!string.IsNullOrEmpty(commandAssembly))
    {
        OnError(&quot;The configuration attribute 'commandAssembly' is not in used, please try to use the child node 'commandAssemblies' instead!&quot;);
        return false;
    }
    if (m_AppServer.Config.CommandAssemblies != null &amp;amp;&amp;amp; m_AppServer.Config.CommandAssemblies.Any())
    {
        try
        {
            var definedAssemblies = AssemblyUtil.GetAssembliesFromStrings(m_AppServer.Config.CommandAssemblies.Select(a =&amp;gt; a.Assembly).ToArray());

            if (definedAssemblies.Any())
                commandAssemblies.AddRange(definedAssemblies);
        }
        catch (Exception e)
        {
            OnError(new Exception(&quot;Failed to load defined command assemblies!&quot;, e));
            return false;
        }
    }
    if (!commandAssemblies.Any())
    {
        commandAssemblies.Add(Assembly.GetEntryAssembly());
    }
    var outputCommands = new List&amp;lt;TCommand&amp;gt;();
    foreach (var assembly in commandAssemblies)
    {
        try
        {
            outputCommands.AddRange(assembly.GetImplementedObjectsByInterface&amp;lt;TCommand&amp;gt;());
        }
        catch (Exception exc)
        {
            OnError(new Exception(string.Format(&quot;Failed to get commands from the assembly {0}!&quot;, assembly.FullName), exc));
            return false;
        }
    }
    commands = outputCommands;
    return true;
}
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;statusinfocollection-2&quot;&gt;StatusInfoCollection&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234233368-520891959.png&quot; alt=&quot;1578475314305&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;appserverbase-2&quot;&gt;AppServerBase&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234235137-999606833.png&quot; alt=&quot;1580125365801&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234235830-1310390164.png&quot; alt=&quot;1578487267303&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;appseverbasetappsessiontrequestinfo-2&quot;&gt;AppSeverBase&amp;lt;TAppSession,TRequestInfo&amp;gt;&lt;/h3&gt;
&lt;p&gt;m_CommandContainer：命令容器&lt;/p&gt;
&lt;p&gt;m_CommandLoaders&lt;/p&gt;
&lt;p&gt;m_ConnectionFilters&lt;/p&gt;
&lt;p&gt;m_GlobalCommandFilters&lt;/p&gt;
&lt;p&gt;m_Listeners&lt;/p&gt;
&lt;p&gt;m_SocketServerFactory：在SetupBas&lt;/p&gt;
&lt;h2 id=&quot;facility.dll-2&quot;&gt;Facility.dll&lt;/h2&gt;
&lt;h3 id=&quot;policyreceivefilterfactory-2&quot;&gt;PolicyReceiveFilterFactory&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234233387-581875788.png&quot; alt=&quot;1579780070988&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;policyrecievefilter-2&quot;&gt;PolicyRecieveFilter&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234234549-1937190260.png&quot; alt=&quot;1579780715003&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;protocol-2&quot;&gt;Protocol&lt;/h3&gt;
&lt;p&gt;ReceiveFilterBase&lt;/p&gt;
&lt;p&gt;类图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234234439-52198112.png&quot; alt=&quot;1578464691790&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234235415-1925695982.png&quot; alt=&quot;1578464252406&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234233460-659310558.png&quot; alt=&quot;1578466885687&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在SuperSocket.SocketBase.Protocol程序集中&lt;/li&gt;
&lt;li&gt;IReceiveFilter&amp;lt;TRequestInfo&amp;gt;接口，接收解析接口
&lt;ul&gt;&lt;li&gt;Filter方法，解析会话请求的信息，参数包括，读取缓冲，偏移量，长度，是否copy，没有被解析的长度&lt;/li&gt;
&lt;li&gt;LeftBufferSize属性：空余的缓冲区长度&lt;/li&gt;
&lt;li&gt;NextReceiveFilter属性，下一个接收解析器&lt;/li&gt;
&lt;li&gt;Reset方法，恢复初始化&lt;/li&gt;
&lt;li&gt;State:解析器状态，正常和错误状态&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ArraySegmentEx&amp;lt;T&amp;gt;数段类
&lt;ul&gt;&lt;li&gt;T为数组模板&lt;/li&gt;
&lt;li&gt;Array数组，count:数量，Offset偏移量，From从，To到&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ArraySegmentList&amp;lt;T&amp;gt;数段列表
&lt;ul&gt;&lt;li&gt;实现了一个数组段列表&lt;/li&gt;
&lt;li&gt;m_PrevSegment：当前的数段&lt;/li&gt;
&lt;li&gt;m_PrevSegmentIndex，数段所在的index&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ReceiveFilterBase&amp;lt;TRequestInfo&amp;gt;
&lt;ul&gt;&lt;li&gt;BufferSegments属性&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;socketengine.dll-2&quot;&gt;SocketEngine.dll&lt;/h2&gt;
&lt;h3 id=&quot;performancemonitor-2&quot;&gt;PerformanceMonitor&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234234076-1145956077.png&quot; alt=&quot;1580126841482&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;socketsession-2&quot;&gt;SocketSession&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234235620-576851060.png&quot; alt=&quot;1579319465778&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在初始化里对AppSession产生依赖，同时维护Socket和SmartPool(SendingQueue[])，因为维护着socket所以发送接收数据都是通过这个类。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;设置状态：AddStateFlag（）TryAddStateFlag（）RemoveStateFlag（）,AddStateFlag：自旋设置m_State状态，线程安全的&lt;/li&gt;
&lt;li&gt;m_Client:Socket&lt;/li&gt;
&lt;li&gt;SessionID:new guid&lt;/li&gt;
&lt;li&gt;LocalEndPoint:本地Id端&lt;/li&gt;
&lt;li&gt;RemoteEndPoint：远程终结点&lt;/li&gt;
&lt;li&gt;m_SendingQueuePool：实际是SmartPool类的实例，该实例维护者sendingQueue数组&lt;/li&gt;
&lt;li&gt;m_SendingQueue：从SmarlPool中获取一个SendingQueue实例。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;方法&lt;/p&gt;
&lt;p&gt;Initialize()方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;初始化m_SendingQueuePool和m_SendingQueue&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;TrySend()方法：参数：IList&amp;lt;ArraySegment&amp;lt;byte&amp;gt;&amp;gt; segments：将segments压入sendingqueue队列并调用StartSend最终是调用&lt;strong&gt;SendAsync&lt;/strong&gt;或&lt;strong&gt;SendSync&lt;/strong&gt;，这个是由子类实现。&lt;/p&gt;
&lt;h3 id=&quot;asyncsocketsession-2&quot;&gt;AsyncSocketSession&lt;/h3&gt;
&lt;p&gt;在子类中维护SocketAsyncEventArgs&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;SocketAsyncProxy：维护着SocketAsyncEventArgs&lt;/li&gt;
&lt;li&gt;m_SocketEventArgSend：发送的SocketAsyncEventArgs实例&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在初始化中如果同步发送就使用m_SocketEventArgSend，并OnSendingCompleted方法绑定其Completed事件&lt;/p&gt;
&lt;p&gt;在SendAsync()方法中将SendingQueue实例给m_SocketEventArgSend的UserToken属性，并调用m_SocketEventArgSend的&lt;strong&gt;SetBuffer&lt;/strong&gt;和&lt;strong&gt;SendAsync&lt;/strong&gt;方法，发送失败也调用OnSendingCompleted&lt;/p&gt;
&lt;p&gt;SocketAsyncProxy中的Completed事件中调用ProcessReceive方法，再调用&lt;code&gt;this.AppSession.ProcessRequest(e.Buffer, e.Offset, e.BytesTransferred, true);&lt;/code&gt;方法&lt;/p&gt;
&lt;h3 id=&quot;asyncstreamsocketsession-2&quot;&gt;AsyncStreamSocketSession&lt;/h3&gt;
&lt;h3 id=&quot;socketfactory-2&quot;&gt;SocketFactory&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234233205-1420351870.png&quot; alt=&quot;1578467105778&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// Creates the socket server.
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;typeparam name=&quot;TRequestInfo&quot;&amp;gt;The type of the request info.&amp;lt;/typeparam&amp;gt;
/// &amp;lt;param name=&quot;appServer&quot;&amp;gt;The app server.&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&quot;listeners&quot;&amp;gt;The listeners.&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&quot;config&quot;&amp;gt;The config.&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
public ISocketServer CreateSocketServer&amp;lt;TRequestInfo&amp;gt;(IAppServer appServer, ListenerInfo[] listeners, IServerConfig config)
    where TRequestInfo : IRequestInfo
{
    if (appServer == null)
        throw new ArgumentNullException(&quot;appServer&quot;);
    if (listeners == null)
        throw new ArgumentNullException(&quot;listeners&quot;);
    if (config == null)
        throw new ArgumentNullException(&quot;config&quot;);
    switch(config.Mode)
    {
        case(SocketMode.Tcp):
            return new AsyncSocketServer(appServer, listeners);
        case(SocketMode.Udp):
            return new UdpSocketServer&amp;lt;TRequestInfo&amp;gt;(appServer, listeners);
        default:
            throw new NotSupportedException(&quot;Unsupported SocketMode:&quot; + config.Mode);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;socketservers-2&quot;&gt;SocketServers&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234235214-387632985.png&quot; alt=&quot;1578487919018&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;asyncsocketserver-2&quot;&gt;AsyncSocketServer&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;缓存管理器m_BufferManager&lt;/li&gt;
&lt;li&gt;线程安全的SocketAsyncEventArgsProxy栈&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;构造函数，父类&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public TcpSocketServerBase(IAppServer appServer, ListenerInfo[] listeners)
    : base(appServer, listeners)
{
    var config = appServer.Config;

    uint dummy = 0;
    m_KeepAliveOptionValues = new byte[Marshal.SizeOf(dummy) * 3];
    m_KeepAliveOptionOutValues = new byte[m_KeepAliveOptionValues.Length];
    //whether enable KeepAlive
    BitConverter.GetBytes((uint)1).CopyTo(m_KeepAliveOptionValues, 0);
    //how long will start first keep alive
    BitConverter.GetBytes((uint)(config.KeepAliveTime * 1000)).CopyTo(m_KeepAliveOptionValues, Marshal.SizeOf(dummy));
    //keep alive interval
    BitConverter.GetBytes((uint)(config.KeepAliveInterval * 1000)).CopyTo(m_KeepAliveOptionValues, Marshal.SizeOf(dummy) * 2);

    m_SendTimeOut = config.SendTimeOut;
    m_ReceiveBufferSize = config.ReceiveBufferSize;
    m_SendBufferSize = config.SendBufferSize;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public override bool Start()
{
    try
    {
        int bufferSize = AppServer.Config.ReceiveBufferSize;

        if (bufferSize &amp;lt;= 0)
            bufferSize = 1024 * 4;

        m_BufferManager = new BufferManager(bufferSize * AppServer.Config.MaxConnectionNumber, bufferSize);

        try
        {
            m_BufferManager.InitBuffer();
        }
        catch (Exception e)
        {
            AppServer.Logger.Error(&quot;Failed to allocate buffer for async socket communication, may because there is no enough memory, please decrease maxConnectionNumber in configuration!&quot;, e);
            return false;
        }

        // preallocate pool of SocketAsyncEventArgs objects
        SocketAsyncEventArgs socketEventArg;

        var socketArgsProxyList = new List&amp;lt;SocketAsyncEventArgsProxy&amp;gt;(AppServer.Config.MaxConnectionNumber);

        for (int i = 0; i &amp;lt; AppServer.Config.MaxConnectionNumber; i++)
        {
            //Pre-allocate a set of reusable SocketAsyncEventArgs
            socketEventArg = new SocketAsyncEventArgs();
            m_BufferManager.SetBuffer(socketEventArg);

            socketArgsProxyList.Add(new SocketAsyncEventArgsProxy(socketEventArg));
        }

        m_ReadWritePool = new ConcurrentStack&amp;lt;SocketAsyncEventArgsProxy&amp;gt;(socketArgsProxyList);

        if (!base.Start())
            return false;

        IsRunning = true;
        return true;
    }
    catch (Exception e)
    {
        AppServer.Logger.Error(e);
        return false;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;socketasynceventargsproxy-2&quot;&gt;SocketAsyncEventArgsProxy&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234233286-1789709451.png&quot; alt=&quot;1579316308225&quot;/&gt;&lt;/p&gt;
&lt;p&gt;SocketAsyncEventArgs的代理&lt;/p&gt;
&lt;p&gt;维护着一个SocketAsyncEventArgs对象，并订阅了该对象的Completed事件(异步完成事件)&lt;/p&gt;
&lt;p&gt;IsRecyclable：是否可以循环使用&lt;/p&gt;
&lt;p&gt;OrigOffset：原始偏移量&lt;/p&gt;
&lt;p&gt;每当异步完成的时候调用SocketAsyncEventArgs实例中的&lt;strong&gt;UserToken属性&lt;/strong&gt;，该&lt;strong&gt;属性实际上保存着SocketSession&lt;/strong&gt;实例，并调用SocketSession的&lt;strong&gt;ProcessReceive()&lt;/strong&gt;和&lt;strong&gt;AsyncRun()&lt;/strong&gt;方法；&lt;strong&gt;socketSession.AsyncRun(() =&amp;gt; socketSession.ProcessReceive(e));&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;UserToken属性是在SocketAsyncEventArgsProxy的&lt;strong&gt;初始化方法中定义的&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public void Initialize(IAsyncSocketSession socketSession)
{
    SocketEventArgs.UserToken = socketSession;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代理模式&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234233364-1062683177.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;bootstrapfactory-2&quot;&gt;BootstrapFactory&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234233203-1331706969.png&quot; alt=&quot;1580106366845&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;defaultbootstrap-2&quot;&gt;DefaultBootStrap&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234235070-41600570.png&quot; alt=&quot;1579403530245&quot;/&gt;&lt;/p&gt;
&lt;p&gt;引导配置文件并通过配置实例化各个server和factory,在CreateWorkItemInstance方法通过Activator.CreateInstance(serviceType)实例化&lt;/p&gt;
&lt;h3 id=&quot;configurationwatcher-2&quot;&gt;ConfigurationWatcher&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234233374-1637697760.png&quot; alt=&quot;1580108736600&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;socketlistenerbase-2&quot;&gt;SocketListenerBase&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234234569-1479022462.png&quot; alt=&quot;1579439987190&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;tcpasyncsocketlistener-2&quot;&gt;TcpAsyncSocketListener&lt;/h3&gt;
&lt;p&gt;监听类，由三个事件：监听错误，监听停止，新的客户端连接&lt;/p&gt;
&lt;p&gt;m_ListrnSocket：监听Socket&lt;/p&gt;
&lt;h3 id=&quot;workitemfactoryinfoloader-2&quot;&gt;WorkItemFactoryInfoLoader&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234234202-1973499478.png&quot; alt=&quot;1580119613894&quot;/&gt;&lt;/p&gt;
&lt;p&gt;配置文件载入 LoadResult,载入配置的connectionFilter,logfactory,commandloaderfactory，将appserver转化成IworkItem接口，&lt;/p&gt;
&lt;h2 id=&quot;common.dll-2&quot;&gt;Common.dll&lt;/h2&gt;
&lt;h3 id=&quot;buffermanager-2&quot;&gt;BufferManager&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234233366-1872687617.png&quot; alt=&quot;1578487794792&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此类创建一个大缓冲区，该缓冲区可以分配给每个套接字I / O操作使用，并分配给SocketAsyncEventArgs对象。 这使得bufffer可以轻松地重用，并且可以&lt;strong&gt;防止堆内存碎片化&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;BufferManager类上公开的操作不是线程安全的。我觉得这个类不需要线程安全，因为每个socket获得数据基本不会并发执行。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;m_buffer:所有的字节缓存&lt;/li&gt;
&lt;li&gt;m_bufferSize:单个片段的缓存大小&lt;/li&gt;
&lt;li&gt;m_currentIndex：当前字节在总缓存中的索引&lt;/li&gt;
&lt;li&gt;m_freeIndexPool:空闲索引池&lt;/li&gt;
&lt;li&gt;m_numBytes：缓存片段的数目&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;主要提供两个方法：一个是SetBuffer和FreeBuffer&lt;/p&gt;
&lt;p&gt;SetBuffer：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;检查空闲索引栈中是否有值，有值就直接使用空闲索引栈中的值，并将其值从栈中推出，&lt;/li&gt;
&lt;li&gt;如果没有空闲栈的值就先检查剩余的缓存是否有一个片段大小，有的化就设置并改变m_currentIndex索引，没有返回false&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;FreeBuffer：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;将当前索引添加到空闲索引栈中，并释放SocketAsyncEventArgs中用的缓存片段。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;arraysegmentlist-2&quot;&gt;ArraySegmentList&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234234586-2112600749.png&quot; alt=&quot;1579323401012&quot;/&gt;&lt;/p&gt;
&lt;p&gt;方法：&lt;/p&gt;
&lt;p&gt;IndexOf：T在所有缓存中的索引&lt;/p&gt;
&lt;h3 id=&quot;arraysegmentex-2&quot;&gt;ArraySegmentEx&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;数组，是保存着所有缓存，T[]&lt;/li&gt;
&lt;li&gt;偏移，该片段在缓存中的位置&lt;/li&gt;
&lt;li&gt;数量，该片段的长度&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;sendingqueue-2&quot;&gt;SendingQueue&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234234606-1659707852.png&quot; alt=&quot;1579329295160&quot;/&gt;&lt;/p&gt;
&lt;p&gt;维护ArraySegment&amp;lt;byte&amp;gt;[] globalQueue， globalQueue中包含着所有所有缓存&lt;/p&gt;
&lt;p&gt;入栈，出战，开始入栈，开始出栈。&lt;/p&gt;
&lt;p&gt;所有的发送队列内存片组成一个大的arraysegment，由SendingQueueSourceCreator创建，并由SmartPool维护&lt;/p&gt;
&lt;h3 id=&quot;sendingqueuesourcecreator-2&quot;&gt;SendingQueueSourceCreator&lt;/h3&gt;
&lt;p&gt;实际就是SmartPoolSourceCreator,发送队列&lt;strong&gt;创建者&lt;/strong&gt;，默认有5个发送队列，其实每个连接一个发送队列，这边的所有sendingQueue组数是由SmartPool维护的&lt;/p&gt;
&lt;p&gt;m_SendingQueueSize：发送队列大小，默认为5&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// Creates the specified size.
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;size&quot;&amp;gt;The size.&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&quot;poolItems&quot;&amp;gt;The pool items.&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
public ISmartPoolSource Create(int size, out SendingQueue[] poolItems)
{
    var source = new ArraySegment&amp;lt;byte&amp;gt;[size * m_SendingQueueSize];//256*5
    poolItems = new SendingQueue[size];//size=256
    for (var i = 0; i &amp;lt; size; i++)
    {
        poolItems[i] = new SendingQueue(source, i * m_SendingQueueSize, m_SendingQueueSize);//SendingQueue中的source是所有的队列缓存，发送队列偏移量和发送队列容量
    }
    return new SmartPoolSource(source, size);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;smartpool-2&quot;&gt;SmartPool&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1078802/202001/1078802-20200127234234423-848698051.png&quot; alt=&quot;1579327943978&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中维护了一个T（实际是SendingQueue）线程安全栈(m_GlobalStack)。由此看出SmartPool就是SendingQueue的池&lt;/p&gt;
&lt;p&gt;m_MinPoolSize：Math.Max(config.MaxConnectionNumber / 6, 256)&lt;/p&gt;
&lt;p&gt;m_MaxPoolSize：Math.Max(config.MaxConnectionNumber * 2, 256)&lt;/p&gt;
&lt;p&gt;m_SourceCreator：new SendingQueueSourceCreator(config.SendingQueueSize)&lt;/p&gt;
&lt;p&gt;m_ItemsSource：保存着SmartPoolSource[]对象,该对象实际上是所有的sendingqueue缓存。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;m_GlobalStack&lt;/strong&gt;：保存着单个SendingQueuep对象的数组&lt;/p&gt;
&lt;p&gt;Initialize()：初始化函数，初始化上面的变量&lt;/p&gt;
&lt;h3 id=&quot;smartpoolsource-2&quot;&gt;SmartPoolSource&lt;/h3&gt;
&lt;p&gt;维护所有的发送队列缓存，并保存sendingQueue的个数&lt;/p&gt;
&lt;p&gt;Source：是object类型，实际上是ArraySegment&amp;lt;byte&amp;gt;[]，实际上是所有的sendingqueue的缓存，大小为&lt;code&gt;size*sendingqueuesize=256*5&lt;/code&gt;，&lt;/p&gt;
&lt;p&gt;Count:为默认值5&lt;/p&gt;
&lt;h2 id=&quot;other.dll-2&quot;&gt;Other.dll&lt;/h2&gt;
&lt;h3 id=&quot;socketasynceventargs-类-2&quot;&gt;&lt;a href=&quot;https://docs.microsoft.com/zh-cn/dotnet/api/system.net.sockets.socketasynceventargs?f1url=https%3A%2F%2Fmsdn.microsoft.com%2Fquery%2Fdev15.query%3FappId%3DDev15IDEF1%26l%3DZH-CN%26k%3Dk(System.Net.Sockets.SocketAsyncEventArgs);k(TargetFrameworkMoniker-.NETFramework,Version%3Dv4.5);k(DevLang-csharp)%26rd%3Dtrue&amp;amp;view=netframework-4.8&quot;&gt;SocketAsyncEventArgs&lt;/a&gt; 类&lt;/h3&gt;
&lt;p&gt;表示异步套接字操作。&lt;/p&gt;
&lt;h2 id=&quot;设置ip和port调用流程-2&quot;&gt;设置IP和Port调用流程&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;创建ServerConfig实例，RootConfig实例&lt;/li&gt;
&lt;li&gt;设置m_State状态，线程安全的，通过Interlocked.CompareExchange方法设置&lt;/li&gt;
&lt;li&gt;在setbasic中设置RootConfig,m_Name,Config，设置currentculture,设置线程池参数，设置m_socketfactory,设置textencoding,&lt;/li&gt;
&lt;li&gt;设置logfactory&lt;/li&gt;
&lt;li&gt;在setMedium中设置&lt;strong&gt;ReceiveFilterFactory&lt;/strong&gt;，m_ConnectionFilters，m_CommandLoaders（add &lt;strong&gt;ReflectCommandLoader&lt;/strong&gt;）&lt;/li&gt;
&lt;li&gt;在SetupAdvanced中设置BaseSecurity和Certificate，设置&lt;strong&gt;listners(ListenerInfo)&lt;/strong&gt; 设置CommandFilterAttribute，遍历m_CommandLoaders，订阅Error,Updated事件，调用Initialize方法，通过TryLoadCommands方法获取命令集合commands，遍历命令集合添加命令到discoveredCommands集合中&lt;/li&gt;
&lt;li&gt;遍历discoveredCommands集合，将其添加到命令容器 m_CommandContainer中，使用Interlocked.Exchange方法保证线程安全&lt;/li&gt;
&lt;li&gt;在SetupFinal中设置ReceiveFilterFactory=new CommandLineReceiveFilterFactory(TextEncoding)，设置m_ServerStatus,通过socketfactory获得serverfactory。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;start调用流程-2&quot;&gt;start调用流程&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;调用SuperSocket.SocketBase.AppServer中start()方法，调用基类AppServerBase的start()方法，该方法中调用socketserver的start方法&lt;/li&gt;
&lt;li&gt;在socketserver的start方法中设置BufferManager,创建&lt;strong&gt;SocketAsyncEventArg&lt;/strong&gt;,并通过buffermanager设置其buffer,并创建&lt;strong&gt;SocketAsyncEventArgProxys&lt;/strong&gt;, &lt;strong&gt;SocketAsyncEventArgProxys&lt;/strong&gt;集合赋值给&lt;strong&gt;m_ReadWritePool&lt;/strong&gt;。调用SocketServer基类中的start&lt;/li&gt;
&lt;li&gt;在socketserver基类的start中创建&lt;strong&gt;SendingQueuePool&lt;/strong&gt;并初始化,实际是初始化队列池中的sendingqueue队列；通过遍历ListenerInfo集合创建TcpAsyncSocketListener监听者，订阅监听者的&lt;strong&gt;stop，error,NewClientAccepted&lt;/strong&gt;事件，并开始监听Listener.Start,也添加到容器中。&lt;/li&gt;
&lt;li&gt;Listener.Start中创建一个监听Listen_socket和&lt;strong&gt;new异步套接字SocketAsyncEventArgs&lt;/strong&gt;,并订阅Compeleted事件，启用socket监听，并调用AcceptAsync方法，异步完成触发compeleted事件，调用ProcessAccept方法，原来的方法异步已经触发&lt;strong&gt;重新调用一下AcceptAsync方法，通过函数递归实现while&lt;/strong&gt;，判定acceptsocket是否正常，触发NewClientAccepted事件，&lt;/li&gt;
&lt;li&gt;事件触发AsyncSocketServer 类中的ProcessNewClient方法，从m_ReadWritePool池中取一个空闲的SocketAsyncEventArgProxy，并通过代理，socket创建AsyncSocketSession，并通过socketsession创建Appsession，在创建过程中做连接过滤，初始化app'session，通过receivefactory创建receivefilter，同时初始化socketsession,主要是订阅SocketAsyncEventArgProxy中的compeleted事件。调用socketsession的start方法&lt;/li&gt;
&lt;li&gt;在socketsession中调用&lt;strong&gt;startreceive&lt;/strong&gt;方法,中调用socket.ReceiveAsync方法，当异步完成时调用socketProxy的SocketEventArgs_Completed方法，该方法调用SocketSession的ProcessReceive方法，在该方法中执行过滤FilterRequest,执行命令，再一次&lt;strong&gt;调用startReceive方法，如此不停通过异步直接实现接收循环&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;send调用流程-2&quot;&gt;send调用流程&lt;/h2&gt;
&lt;p&gt;在订阅了NewRequestReceived事件之后，该事件会有两个参数，一个是appsession，一个是requestinfo,&lt;/p&gt;
&lt;p&gt;appsession和socketsession完成，&lt;/p&gt;
&lt;p&gt;在appsession的InteralSend函数中对sendtimeout进行限制。&lt;/p&gt;
&lt;p&gt;在socketsession中将消息压入消息栈对消息进行校验，最终是通过socket.send和socket.sendasync两个方法将消息发送。&lt;/p&gt;
&lt;h2 id=&quot;stop调用流程-2&quot;&gt;Stop调用流程&lt;/h2&gt;
&lt;p&gt;先调用stop再调用close&lt;/p&gt;
&lt;p&gt;socketserver的stop，释放m_ReadWritePool中所有SocketAsyncEventArgs，所有listener的stop，释放其SocketAsyncEventArgs&lt;/p&gt;
&lt;p&gt;socket'session的closed，回收所有sendingqqueue到pool中.&lt;/p&gt;
</description>
<pubDate>Mon, 27 Jan 2020 15:36:00 +0000</pubDate>
<dc:creator>杜金锋</dc:creator>
<og:description>SuperSocket1.6Code解析 Normal Socket System.Net.Sockets.dll程序集中使用socket类： 服务器： 1. 创建socket : 2. 创建IP ：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lovexinyi/p/12237245.html</dc:identifier>
</item>
<item>
<title>MySQL数据库之xtrabackup物理备份(一) - blue_boy</title>
<link>http://www.cnblogs.com/summer-time/p/12237232.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/summer-time/p/12237232.html</guid>
<description>&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;：说到数据库备份，我们知道可以用来对数据库进行备份的工具有mysqldump、mydumer、mysqlpump等等，实际工作中，机器上的数据库不大的话，都是用mysqldump工具来备份，这些备份工具各有优缺点，这里不详细介绍，今天分享另一个数据库备份工具，叫XtraBackup。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、Xtrabackup介绍&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1.官网说明&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Percona XtraBackup可以在不阻止用户查询的情况下实现MySQL备份，因此非常适合拥有大数据集和无法承受长时间停机的关键任务应用程序的公司。作为开源解决方案免费提供，Percona XtraBackup降低了备份成本，同时为MySQL备份提供了独特的功能。&lt;/span&gt;&lt;/p&gt;

&lt;div readability=&quot;14&quot;&gt;
&lt;p&gt;2.Xtrabackup优点&lt;/p&gt;
&lt;p&gt;快速可靠地完成备份&lt;/p&gt;
&lt;p&gt;备份期间不间断的事务处理&lt;/p&gt;
&lt;p&gt;节省磁盘空间和网络带宽&lt;/p&gt;
&lt;p&gt;自动备份验证&lt;/p&gt;
&lt;p&gt;更快的恢复时间可延长正常运行时间&lt;br/&gt;支持InnoDB，XtraDB和HailDB 存储引擎的完全非阻塞备份&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span&gt;3.Xtrabackup备份的过程&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;103&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1102058/202001/1102058-20200127213238077-418064133.png&quot; alt=&quot;&quot; width=&quot;739&quot; height=&quot;478&quot;/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;

&lt;p&gt;(1)备份开始时会开启一个后台检测进程，实时检测mysql redo(已提交的事务)的变化，一旦发现redo中有新日志写入，立刻将日志记入后台日志文件xtrabackup_log中，&lt;/p&gt;
&lt;p&gt;(2)复制InnoDB的数据文件和系统表空间文件ibdata1，&lt;/p&gt;
&lt;p&gt;(3)待复制结束后，执行flush tables with read lock操作，复制.frm、.MYI、.MY等文件&lt;/p&gt;
&lt;p&gt;(4)执行flush tables with read lock的目的是为了防止数据表发生DML操作，并且在这一时刻获得binlog的位置，&lt;/p&gt;
&lt;p&gt;(5)最后会发出unlock tables，把表设置为可读写状态，&lt;/p&gt;
&lt;div readability=&quot;9&quot;&gt;(6)最终停止xtrabackup_log。&lt;p&gt;4.为什么要用XtraBackup&lt;/p&gt;&lt;/div&gt;
&lt;p&gt;因为当数据库超过100G的话，用mysqldump就没有XtraBackup有优势，工作中mysqldump备份大的数据还会出现卡住，断开的可能性，XtraBackup支持完整备份，增量备份，完整恢复，增量恢复，对于innodb引擎备份时不锁表进行热备份。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、XtraBackup安装&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1.xtrabackup官网有很多个版本，有1.6、2.0-2.4和8.0，每个版本都有不同，根据自己需要下载安装，如：&lt;br/&gt;xtrabackup1.6版本支持MySQL 5.0、5.1和5.5。&lt;br/&gt;xtrabackup2.2和2.3版本支持备份MySQL 5.1 、5.5和5.6。&lt;br/&gt;xtrabackup2.4版本支持MySQL 5.1、5.5、5.6和5.7。&lt;br/&gt;xtrabackup8.0版本只支持MySQL8.0，不支持8.0之前的。&lt;br/&gt;本文章使用xtrabackup2.3。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;2.下载安装&lt;/p&gt;
&lt;p&gt;官网有源码包下载，二进制包、还有存储库，官网推荐存储库下载，我这里环境用Centos7，所以用yum安装,这里选择安装yum install -y percona-xtrabackup.x86_64&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;yum&lt;/span&gt; &lt;span&gt;install&lt;/span&gt; http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.percona.com/downloads/percona-release/redhat/0.1-4/percona-release-0.1-4.noarch.rpm&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;yum&lt;/span&gt; list | &lt;span&gt;grep&lt;/span&gt;&lt;span&gt; percona
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; percona-xtrabackup.x86_64                 &lt;span&gt;2.3&lt;/span&gt;.&lt;span&gt;10&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;.el7                 percona-release-&lt;span&gt;x86_64
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; percona-xtrabackup-&lt;span&gt;22&lt;/span&gt;.x86_64              &lt;span&gt;2.2&lt;/span&gt;.&lt;span&gt;13&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;.el7                 percona-release-&lt;span&gt;x86_64
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; percona-xtrabackup-&lt;span&gt;22&lt;/span&gt;-debuginfo.x86_64    &lt;span&gt;2.2&lt;/span&gt;.&lt;span&gt;13&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;.el7                 percona-release-&lt;span&gt;x86_64
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; percona-xtrabackup-&lt;span&gt;24&lt;/span&gt;.x86_64              &lt;span&gt;2.4&lt;/span&gt;.&lt;span&gt;18&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;.el7                 percona-release-&lt;span&gt;x86_64
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; percona-xtrabackup-&lt;span&gt;24&lt;/span&gt;-debuginfo.x86_64    &lt;span&gt;2.4&lt;/span&gt;.&lt;span&gt;18&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;.el7                 percona-release-&lt;span&gt;x86_64
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; percona-xtrabackup-&lt;span&gt;80&lt;/span&gt;.x86_64              &lt;span&gt;8.0&lt;/span&gt;.&lt;span&gt;9&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;.el7                  percona-release-&lt;span&gt;x86_64
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; percona-xtrabackup-&lt;span&gt;80&lt;/span&gt;-debuginfo.x86_64    &lt;span&gt;8.0&lt;/span&gt;.&lt;span&gt;9&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;.el7                  percona-release-&lt;span&gt;x86_64
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; percona-xtrabackup-debuginfo.x86_64       &lt;span&gt;2.3&lt;/span&gt;.&lt;span&gt;10&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;.el7                 percona-release-&lt;span&gt;x86_64
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; percona-xtrabackup-test.x86_64            &lt;span&gt;2.3&lt;/span&gt;.&lt;span&gt;10&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;.el7                 percona-release-&lt;span&gt;x86_64
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; percona-xtrabackup-test-&lt;span&gt;22&lt;/span&gt;.x86_64         &lt;span&gt;2.2&lt;/span&gt;.&lt;span&gt;13&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;.el7                 percona-release-&lt;span&gt;x86_64
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; percona-xtrabackup-test-&lt;span&gt;24&lt;/span&gt;.x86_64         &lt;span&gt;2.4&lt;/span&gt;.&lt;span&gt;18&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;.el7                 percona-release-&lt;span&gt;x86_64
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; percona-xtrabackup-test-&lt;span&gt;80&lt;/span&gt;.x86_64         &lt;span&gt;8.0&lt;/span&gt;.&lt;span&gt;9&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;.el7                  percona-release-x86_64
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;安装之后，可以检查xtrabackup版本，我本地的数据库版本是5.6&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; xtrabackup --&lt;span&gt;version
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; xtrabackup version &lt;span&gt;2.3&lt;/span&gt;.&lt;span&gt;6&lt;/span&gt; based on MySQL server &lt;span&gt;5.6&lt;/span&gt;.&lt;span&gt;24&lt;/span&gt; Linux (x86_64) (revision &lt;span&gt;id&lt;/span&gt;: )
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.工具介绍&lt;/p&gt;
&lt;p&gt;Xtrabackup安装完成后有4个可执行文件，其中2个比较重要的备份工具是innobackupex、xtrabackup&lt;/p&gt;
&lt;p&gt;innobackupex&lt;br/&gt;innobackupex是一个封装xtrabackup的Perl脚本。。&lt;br/&gt;xtrabackup&lt;br/&gt;编译后的C二进制文件，提供了使用MyISAM，InnoDB和XtraDB表备份整个MySQL数据库实例的功能。&lt;br/&gt;xbcrypt加密&lt;br/&gt;用于加密和解密备份文件的实用程序。&lt;br/&gt;xbstream&lt;br/&gt;允许以流的形式从xbstream格式提取文件，类似tar。&lt;br/&gt;xbcloud&lt;br/&gt;用于从云中下载xbstream归档的全部或部分或将其上传到云。&lt;/p&gt;
&lt;p&gt;官网说明：innobackupex仍然像2.2版本一样支持所有功能和语法，但是现在已弃用，并且将在下一个主要版本中删除，Percona XtraBackup 2.3版本的推荐方式采取的备份是使用xtrabackup脚本，这篇文章介绍innobackupex脚本，差别不大。&lt;/p&gt;&lt;p&gt;4.innobackupex命令参数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
--user=&lt;span&gt;     　　　　　　　　#指定数据库备份用户

&lt;/span&gt;--password=&lt;span&gt;  　　　　　　　 #指定数据库备份用户密码

&lt;/span&gt;--port=&lt;span&gt;     　　　　　　　　#指定数据库端口

&lt;/span&gt;--host=&lt;span&gt;     　　　　　　　　#指定备份主机

&lt;/span&gt;--socket=&lt;span&gt;    　　　　　　　 #指定socket文件路径

&lt;/span&gt;--databases=  　　　　　　　#备份指定数据库,多个空格隔开，如--databases=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dbname1 dbname2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,不加备份所有库

&lt;/span&gt;--defaults-&lt;span&gt;file&lt;/span&gt;=&lt;span&gt;       　 #指定my.cnf配置文件

&lt;/span&gt;--apply-&lt;span&gt;log         　　　 #日志回滚

&lt;/span&gt;--incremental=&lt;span&gt;            #增量备份，后跟增量备份路径

&lt;/span&gt;--incremental-basedir=&lt;span&gt;    #增量备份，指上次增量备份路径

&lt;/span&gt;--redo-&lt;span&gt;only         　　　 #合并全备和增量备份数据文件

&lt;/span&gt;--copy-&lt;span&gt;back         　　　 #将备份数据复制到数据库，数据库目录要为空

&lt;/span&gt;--no-&lt;span&gt;timestamp            #生成备份文件不以时间戳为目录名

&lt;/span&gt;--stream=             　　#指定流的格式做备份,--stream=&lt;span&gt;tar&lt;/span&gt;,将备份文件归档，--stream=&lt;span&gt;xbstream

&lt;/span&gt;--remote-host=&lt;span&gt;user@ip DST_DIR #备份到远程主机
                      
&lt;/span&gt;--use-memory=&lt;span&gt;     　　　　 #该参数在prepare的时候使用，控制prepare时innodb实例使用的内存量
             
&lt;/span&gt;--parallel     　　　　　　 #用于复制数据文件的线程数。配合-stream=&lt;span&gt;xbstream
                      
&lt;/span&gt;--compress     　　　　　　 #压缩功能，配合-stream=&lt;span&gt;xbstream
 
&lt;/span&gt;--compress-threads=&lt;span&gt;4&lt;/span&gt; 　　　#用于并行数据压缩的线程数。此选项的默认值为1。配合-stream=&lt;span&gt;xbstream
                      
&lt;/span&gt;--throttle= 　　　　　　　  #限制innobackupex读写InnoDB数据的速率
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、用innobackupex进行完整备份&lt;br/&gt;&lt;/strong&gt;1.执行完整备份命令&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;p&gt;innobackupex --defaults-file=/usr/local/mysql/my.cnf --user=root --password=&quot;123456&quot; --socket=/tmp/mysql.sock --no-timestamp /data/backup/$(date +%F)/full&lt;br/&gt;最后输出下面信息表示成功备份&lt;br/&gt;xtrabackup: Transaction log of lsn (42677124128) to (42677124128) was copied.&lt;br/&gt;200127 13:21:18 completed OK!&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;在/data/backup目录下面生成一个当前日期命名的目录，时间目录下面的full目录里面存放着备份出来的文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; [root@devops &lt;span&gt;13&lt;/span&gt;:&lt;span&gt;17&lt;/span&gt;:&lt;span&gt;24&lt;/span&gt;/data/backup/&lt;span&gt;]# ll 
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; total &lt;span&gt;2535576&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; drwx------ &lt;span&gt;3&lt;/span&gt; root root       &lt;span&gt;4096&lt;/span&gt; Jan &lt;span&gt;27&lt;/span&gt; &lt;span&gt;13&lt;/span&gt;:&lt;span&gt;17&lt;/span&gt; &lt;span&gt;2020&lt;/span&gt;-&lt;span&gt;01&lt;/span&gt;-&lt;span&gt;27&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;介绍一下目录的文件信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; [root@devops &lt;span&gt;13&lt;/span&gt;:&lt;span&gt;21&lt;/span&gt;:&lt;span&gt;18&lt;/span&gt;/data/backup/]# ll &lt;span&gt;2020&lt;/span&gt;-&lt;span&gt;01&lt;/span&gt;-&lt;span&gt;27&lt;/span&gt;/full/
&lt;span&gt; 2&lt;/span&gt; total &lt;span&gt;141364&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; -rw-r----- &lt;span&gt;1&lt;/span&gt; root root       &lt;span&gt;388&lt;/span&gt; Jan &lt;span&gt;27&lt;/span&gt; &lt;span&gt;13&lt;/span&gt;:&lt;span&gt;21&lt;/span&gt; backup-&lt;span&gt;my.cnf   #备份命令用到的配置信息
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; -rw-r----- &lt;span&gt;1&lt;/span&gt; root root &lt;span&gt;144703488&lt;/span&gt; Jan &lt;span&gt;27&lt;/span&gt; &lt;span&gt;13&lt;/span&gt;:&lt;span&gt;17&lt;/span&gt;&lt;span&gt; ibdata1　　　　　 #&lt;span class=&quot;Apple-converted-space&quot;&gt;备份的表空间的文件 &lt;/span&gt;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; drwx------ &lt;span&gt;2&lt;/span&gt; root root      &lt;span&gt;4096&lt;/span&gt; Jan &lt;span&gt;27&lt;/span&gt; &lt;span&gt;13&lt;/span&gt;:&lt;span&gt;21&lt;/span&gt;&lt;span&gt; mysql            #备份出来的mysql、performance_schema、test数据库
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; drwx------ &lt;span&gt;2&lt;/span&gt; root root      &lt;span&gt;4096&lt;/span&gt; Jan &lt;span&gt;27&lt;/span&gt; &lt;span&gt;13&lt;/span&gt;:&lt;span&gt;21&lt;/span&gt;&lt;span&gt; performance_schema
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; drwx------ &lt;span&gt;2&lt;/span&gt; root root      &lt;span&gt;4096&lt;/span&gt; Jan &lt;span&gt;27&lt;/span&gt; &lt;span&gt;13&lt;/span&gt;:&lt;span&gt;21&lt;/span&gt;&lt;span&gt; test
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; -rw-r----- &lt;span&gt;1&lt;/span&gt; root root        &lt;span&gt;21&lt;/span&gt; Jan &lt;span&gt;27&lt;/span&gt; &lt;span&gt;13&lt;/span&gt;:&lt;span&gt;21&lt;/span&gt;&lt;span&gt; xtrabackup_binlog_info      #binlog日志信息
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; -rw-r----- &lt;span&gt;1&lt;/span&gt; root root       &lt;span&gt;121&lt;/span&gt; Jan &lt;span&gt;27&lt;/span&gt; &lt;span&gt;13&lt;/span&gt;:&lt;span&gt;21&lt;/span&gt;&lt;span&gt; xtrabackup_checkpoints      #这个比较重要，里面存放着lsn(日志序列号)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; -rw-r----- &lt;span&gt;1&lt;/span&gt; root root       &lt;span&gt;602&lt;/span&gt; Jan &lt;span&gt;27&lt;/span&gt; &lt;span&gt;13&lt;/span&gt;:&lt;span&gt;21&lt;/span&gt;&lt;span&gt; xtrabackup_info             #存放一些工具版本、数据库版本、执行开始结束时间等信息
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; -rw-r----- &lt;span&gt;1&lt;/span&gt; root root      &lt;span&gt;2560&lt;/span&gt; Jan &lt;span&gt;27&lt;/span&gt; &lt;span&gt;13&lt;/span&gt;:&lt;span&gt;21&lt;/span&gt; xtrabackup_logfile          #重做日志文件
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.模拟删除整个数据目录&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;cd /data/ &amp;amp;&amp;amp; rm&lt;/span&gt; -rf mysqldata
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.kill掉mysql进程&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
pgrep mysql | &lt;span&gt;xargs&lt;/span&gt; &lt;span&gt;kill&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4.准备&lt;/p&gt;
&lt;p&gt;准备(prepare)一个完全备份&lt;br/&gt;一般情况下，在备份完成后，数据尚且不能用于恢复操作，因为备份的数据中可能会包含尚未提交的事务或已经提交但尚未同步至数据文件中的事务。因此，此时数据文件仍处理不一致状态。“准备”的主要作用正是通过回滚未提交的事务及同步已经提交的事务至数据文件也使得数据文件处于一致性状态。&lt;br/&gt;innobackupex命令的-apply-log选项可用于实现上述功能&lt;br/&gt;不建议在准备时中断xtrabackup过程，因为这可能会导致数据文件损坏并且备份将变得不可用。如果准备过程中断，则不能保证备份的有效性。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
innobackupex --apply /data/backup/&lt;span&gt;2020&lt;/span&gt;-&lt;span&gt;01&lt;/span&gt;-&lt;span&gt;27&lt;/span&gt;/full/
&lt;/pre&gt;
&lt;p&gt;  最后输出：200127 13:44:47 completed OK!&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;5.查看xtrabackup_checkpoints文件　　　　&lt;/p&gt;
&lt;p&gt;查看合并后的 checkpoints 其中的类型变为 full-prepared 即为可恢复。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
backup_type = full-prepared
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;6.执行恢复之前要在my.cnf指定数据目录&lt;/p&gt;
&lt;p&gt;恢复备份之前，datadir必须为空。要注意在执行还原之前需要关闭MySQL服务器。不能还原到正在运行的mysqld实例的数据目录(导入部分备份时除外)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;cat&lt;/span&gt; /usr/local/mysql/my.cnf  | &lt;span&gt;grep&lt;/span&gt;&lt;span&gt; datadir
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; datadir         = /data/mysqldata
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;7.执行恢复命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
innobackupex --defaults-&lt;span&gt;file&lt;/span&gt;=/usr/local/mysql/my.cnf --copy-back /data/backup/&lt;span&gt;2020&lt;/span&gt;-&lt;span&gt;01&lt;/span&gt;-&lt;span&gt;27&lt;/span&gt;/full
&lt;/pre&gt;
&lt;pre&gt;
200127 13:56:37 completed OK!      
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果恢复最后输出OK就没问题&lt;/p&gt;&lt;p&gt;8.修改权限&lt;/p&gt;
&lt;p&gt;由于将保留文件的属性，因此在大多数情况下，mysql在启动数据库服务器之前，需要将文件的所有权更改为mysql&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;chown&lt;/span&gt; -R mysql.mysql /data/mysqldata
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;9.启动&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
service mysqld start
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;10.检查数据&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/span&gt;：这篇文章介绍xtrabackup完整备份和还原，后面还会继续写，如果那里写得不好，请多多指教，谢谢&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Mon, 27 Jan 2020 15:30:00 +0000</pubDate>
<dc:creator>blue_boy</dc:creator>
<og:description>前言：说到数据库备份，我们知道可以用来对数据库进行备份的工具有mysqldump、mydumer、mysqlpump等等，实际工作中，机器上的数据库不大的话，都是用mysqldump工具来备份，这些备</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/summer-time/p/12237232.html</dc:identifier>
</item>
<item>
<title>NIO&amp;AIO编程模型 - 赐我白日梦</title>
<link>http://www.cnblogs.com/ZhuChangwu/p/12237223.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ZhuChangwu/p/12237223.html</guid>
<description>&lt;h3 id=&quot;nio线程模型&quot;&gt;NIO线程模型&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1496926/202001/1496926-20200127231716195-1940481194.png&quot; alt=&quot;nio&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;什么是nio线程模型&quot;&gt;什么是NIO线程模型?&lt;/h4&gt;
&lt;p&gt;上图是NIO的线程模型,  基于select实现,   这种线程模型的特点:  多条channel通过一个选择器和单挑线程绑定, 并且在这种编程模型中, Channel中相关业务逻辑不允许存在耗时的任务 , 如果一定会有耗时的逻辑, 请将它们放置到线程池中去运行,  因为这种模型虽然做到了非阻塞, 但是他并不是真正的异步编程, 任何channel上的任何耗时的操作, 都会拖垮这个选择器, 进而拖垮整条线程 , 这也是为啥它会被称为 同步非阻塞&lt;/p&gt;
&lt;h4 id=&quot;什么是同步&quot;&gt;　什么是同步?&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;其一: 因为当channel中出现了耗时的操作时, 其他的channel不得不同步等待&lt;/li&gt;
&lt;li&gt;其二: 从编码上看: NIO编程中 服务端的&lt;code&gt;select()&lt;/code&gt; 会同步等待选择器感兴趣的事件发生&lt;/li&gt;
&lt;li&gt;其三: 从操作系统的角度上看, 程序使用的数据来自 网卡 -&amp;gt; 操作系统的内核缓冲区 -&amp;gt; 用户区, 当数据进入用户区后java程序便可以对其进行读写操作, 所谓同步就是: 数据进入用户区的过程中,NIO编程模型需要同步并不停的询问&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;nio线程模型的优点&quot;&gt;NIO线程模型的优点&lt;/h4&gt;
&lt;p&gt;NIO线程线程模型相对于传统的BIO来说, 最大的优势就是在于 NIO线程模型中单条线程可同时为N个用户(Channel)服务, 而BIO编程模型让人诟病的地方就是, 任何一个新连接接入, 服务器都得为他开启不止一条新的线程去运行它, 这种BIO系统中, 并发肯定不会很高&lt;/p&gt;
&lt;h4 id=&quot;nio适用场景&quot;&gt;NIO适用场景:&lt;/h4&gt;
&lt;p&gt;NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持&lt;/p&gt;
&lt;h3 id=&quot;aio-asynchronous-inputoutput-模型&quot;&gt;AIO (Asynchronous Input/Output )模型&lt;/h3&gt;
&lt;h4 id=&quot;什么是aio&quot;&gt;什么是AIO?&lt;/h4&gt;
&lt;p&gt;AIO是(jdk1.7) 发行的 异步IO编程模型, 真正实现了异步IO, 基于Linux系统的 Epoll 机制实现&lt;/p&gt;
&lt;p&gt;无论是NIO, 还是AIO底层都没有改变网络通信的基本步骤, 而是在这个基础上进行了一系列的升级&lt;/p&gt;
&lt;p&gt;AIO的底层实现是由操作系统完成的, 数据在&lt;strong&gt;内核空间&amp;amp;用户空间&lt;/strong&gt;的迁移, 我们在编写代码时也是这样, 只需要调用 &lt;code&gt;AIO.read()&lt;/code&gt; 或者是 &lt;code&gt;AIO.write()&lt;/code&gt; 即可, 换句话说, 我们的&lt;strong&gt;业务逻辑就成了 回调&lt;/strong&gt;, 原来在操作系统处理数据的这个过程中, 我们的程序需要阻塞等待着, 亦或者放在线程池中运行, 而在AIO编程中这段等待时间差被省去了, 因为当操作系统认为数据还有没准备完时, 它是不会打扰我们的程序的, 这时我们的程序可以去处理其他的逻辑, 而一旦操作系统认为数据齐全了, 他就会回调我们的提供的回调函数&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对应操作系统来说, 当有流数据可读时, 操作系统会将流传入到read方法的缓冲区, 然后回调相关的 CompletionHandler&lt;/li&gt;
&lt;li&gt;对于写操作而言, 操作系统会将程序中Buffer里面数据写入到从用户空间写入到系统空间 再写入到网卡中, 写入完毕, 同样会回调相关的回调函数&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;aio编程server端的示例&quot;&gt;AIO编程Server端的示例&lt;/h4&gt;
&lt;p&gt;下面贴出来一个AIO编程Server端的实例:&lt;/p&gt;
&lt;p&gt;像下面的 read() write() accept() 全是异步的, 一经调用即刻返回, 不一样的地方是我们会提供一个回调对象, 留给操作系统, 当操作系统认为读写数据都到位了, 就会去回调这些函数&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class AIOServer {
    private ExecutorService executorService;

    // 服务端的Channel
    private AsynchronousServerSocketChannel asynchronousServerSocketChannel;

    private AIOServer(int port) {
        init(port);
    }

    // 初始化
    private void init(int port) {
        System.out.println(&quot;aio server start with port &quot; + port);

        executorService = Executors.newFixedThreadPool(5);

        try {
            // 开启服务端的通道
            asynchronousServerSocketChannel = AsynchronousServerSocketChannel.open();
            // 绑定端口
            asynchronousServerSocketChannel.bind(new InetSocketAddress(port));
            System.out.println(&quot;server start ... &quot;);

            /**
             *  方法会异步的去接收一个请求, accept()同样是
             *  参数1 : this , 暂时理解成任意类型的
             *  参数2 : CompleteHandler -- 当请求到来后,会交付给 AIOServerHandler进行处理
             *
             * todo 在 AIO中的监听并不是while(true), 而是类似递归的操作, 每次监听到客户端的请求后, 都需要在处理逻辑中开启下一次的监听
             */
            asynchronousServerSocketChannel.accept(this, new AIOServerHandler());
            System.out.println(&quot;------------------------------&quot;);
            // 阻塞程序
            try {
                TimeUnit.SECONDS.sleep(60);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public AsynchronousServerSocketChannel getAsynchronousServerSocketChannel() {
       return this.asynchronousServerSocketChannel;
    }

    public static void main(String[] args) {
        AIOServer aioServer = new AIOServer(9999);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;aio的适用场景&quot;&gt;AIO的适用场景&lt;/h4&gt;
&lt;p&gt;AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;我是bloger 赐我白日梦, 欢迎关注我 --武汉加油&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 27 Jan 2020 15:26:00 +0000</pubDate>
<dc:creator>赐我白日梦</dc:creator>
<og:description>NIO线程模型 什么是NIO线程模型? 上图是NIO的线程模型, 基于select实现, 这种线程模型的特点: 多条channel通过一个选择器和单挑线程绑定, 并且在这种编程模型中, Channel</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ZhuChangwu/p/12237223.html</dc:identifier>
</item>
<item>
<title>Spring Cloud学习之-什么是Spring Cloud？ - 后青春期的Keats</title>
<link>http://www.cnblogs.com/keatsCoder/p/12237078.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/keatsCoder/p/12237078.html</guid>
<description>&lt;h2 id=&quot;springcloud&quot;&gt;SpringCloud&lt;/h2&gt;
&lt;h3 id=&quot;什么是微服务&quot;&gt;什么是微服务？&lt;/h3&gt;
&lt;p&gt;要想学习微服务，首先需要知道什么是微服务？为什么会有微服务？相信看完架构的发展史读者就会明白&lt;/p&gt;
&lt;h4 id=&quot;架构发展史&quot;&gt;架构发展史&lt;/h4&gt;
&lt;h5 id=&quot;单体应用架构&quot;&gt;单体应用架构&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1654189/202001/1654189-20200127222345332-1302066525.png&quot; alt=&quot;1580046416056&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如图所示：将所有的模块，所有内容(页面、Dao、Service、Controller)全部写入一个项目中，放在一个Tomcat容器中启动&lt;strong&gt;适用于小型项目&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;优点：开发速度快，可以利用代码生成工具快速的开发一个项目&lt;/p&gt;
&lt;p&gt;缺点：不易扩展，代码耦合度高，且不容错(当某部分出错后整个服务就会停止运行)&lt;/p&gt;
&lt;h5 id=&quot;垂直架构&quot;&gt;垂直架构&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1654189/202001/1654189-20200127222344991-362022535.png&quot; alt=&quot;1580046801449&quot;/&gt;&lt;/p&gt;
&lt;p&gt;既然原来单体架构中代码耦合度高，不利于维护和运行，人们自然就想到将不同的内容分开。最简单合理的方式就是将系统按照功能划分成不同的模块，然后将各模块独立放入不同的Web容器中，这就形成了垂直架构&lt;/p&gt;
&lt;p&gt;优点：代码耦合度降低，且不同模块之间可以独立运行。一旦某个模块压力过大，可以针对性的搭集群&lt;/p&gt;
&lt;p&gt;缺点：模块之间有可能不是那么完全独立，导致实体类或者其他层代码不能复用，需要多出粘贴，不方便日后维护。如果直接通过HTTP调用又不是很合理。&lt;/p&gt;
&lt;h5 id=&quot;分布式架构分布式soa架构&quot;&gt;分布式架构/分布式SOA架构&lt;/h5&gt;
&lt;p&gt;分布式架构顾名思义就是分散部署在不同的机器上的服务，一个服务可能负责几个功能，是一种面向SOA架构的，服务之间也是通过rpc来交互或者是webservice来交互的架构。从开发的角度看就是Controller层(服务消费者)和Service层(服务提供者)分成不同的项目，部署在不同的服务器上，通过RPC(远程方法调用)来实现交互。阿里巴巴著名的Dubbo框架就是作为分布式架构的框架。一般推荐使用Zookeeper作为服务的注册中心，负责注册和发现服务的提供者，并供服务的消费者消费&lt;/p&gt;
&lt;h5 id=&quot;微服务&quot;&gt;微服务&lt;/h5&gt;
&lt;p&gt;微服务的提出者&lt;a href=&quot;https://martinfowler.com/&quot;&gt;马丁·福勒&lt;/a&gt;关于微服务的论文&lt;a href=&quot;http://blog.cuicc.com/blog/2015/07/22/microservices/&quot;&gt;中文翻译版&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;单体架构和微服务的比较图示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1654189/202001/1654189-20200127222344583-1463672113.png&quot; alt=&quot;1580103548314&quot;/&gt;&lt;/p&gt;
&lt;p&gt;微服务的核心就是将传统的一站式应用，根据业务拆分成一个个原子应用。彻底地去耦合，一个服务只做一件事情，从技术角度讲就是一个服务就是一个进程，可以单独启动或销毁，拥有独立的数据库。并且通过配置中心可以方便的切换数据库等。&lt;/p&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;每个服务足够内聚，足够小，代码容易理解，一个服务可能就是专一的只干一件事。开发简单、开发效率提高&lt;/li&gt;
&lt;li&gt;微服务能够被小团队单独开发，这个小团队可以是由2到5人的开发人员组成&lt;/li&gt;
&lt;li&gt;微服务能使用不同的语言开发。易于和第三方集成，微服务允许容易且灵活的方式集成自动部署，通过持续集成工具，如Jenkins, Hudson, bamboo 。微服务允许你利用融合最新技术。&lt;/li&gt;
&lt;li&gt;微服务易于被一个开发人员理解，修改和维护，这样小团队能够更关注自己的工作成果。无需通过合作才能体现价值。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;开发人员要处理分布式系统的复杂性，会面临分布式事务、分布式一致性等问题&lt;/li&gt;
&lt;li&gt;多服务运维难度，随着服务的增加，运维的压力也在增大&lt;/li&gt;
&lt;li&gt;服务间通信成本变高&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;微服务的技术栈&quot;&gt;微服务的技术栈&lt;/h4&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;11.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;服务开发&lt;/td&gt;
&lt;td&gt;Springboot、Spring、SpringMVC&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;服务配置与管理&lt;/td&gt;
&lt;td&gt;Netflix公司的Archaius、阿里的Diamond等&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;服务注册与发现&lt;/td&gt;
&lt;td&gt;Eureka、Consul、Zookeeper等&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;服务调用&lt;/td&gt;
&lt;td&gt;Rest、RPC、gRPC&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;服务熔断器&lt;/td&gt;
&lt;td&gt;Hystrix、Envoy等&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;负载均衡&lt;/td&gt;
&lt;td&gt;Ribbon、Nginx等&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;服务接口调用(客户端调用服务的简化工具)&lt;/td&gt;
&lt;td&gt;Feign等&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;消息队列&lt;/td&gt;
&lt;td&gt;Kafka、RabbitMQ、ActiveMQ等&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;服务配置中心管理&lt;/td&gt;
&lt;td&gt;SpringCloudConfig、Chef等&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;服务路由（API网关）&lt;/td&gt;
&lt;td&gt;Zuul等&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;服务监控&lt;/td&gt;
&lt;td&gt;Zabbix、Nagios、Metrics、Spectator等&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;全链路追踪&lt;/td&gt;
&lt;td&gt;Zipkin，Brave、Dapper等&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;服务部署&lt;/td&gt;
&lt;td&gt;Docker、OpenStack、Kubernetes等&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;数据流操作开发包&lt;/td&gt;
&lt;td&gt;SpringCloud Stream（封装与Redis,Rabbit、Kafka等发送接收消息）&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;事件消息总线&lt;/td&gt;
&lt;td&gt;Spring Cloud Bus&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;什么是spring-cloud&quot;&gt;什么是Spring Cloud&lt;/h3&gt;
&lt;p&gt;Spring Cloud 是实现微服务思想落地开发的一整套技术的集合&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1654189/202001/1654189-20200127222344107-1562581352.png&quot; alt=&quot;1580132941867&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;spring-cloud和dubbo的区别图解&quot;&gt;Spring Cloud和Dubbo的区别图解&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1654189/202001/1654189-20200127222343299-1071763521.png&quot; alt=&quot;1580133791055&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Spring Cloud开发者文档中文版：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://springcloud.cc/spring-cloud-dalston.html&quot; class=&quot;uri&quot;&gt;https://springcloud.cc/spring-cloud-dalston.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Spring Cloud中国社区&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://springcloud.cn/&quot; class=&quot;uri&quot;&gt;http://springcloud.cn/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Spring Cloud中文网&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://springcloud.cc/&quot; class=&quot;uri&quot;&gt;https://springcloud.cc/&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 27 Jan 2020 14:29:00 +0000</pubDate>
<dc:creator>后青春期的Keats</dc:creator>
<og:description>SpringCloud 什么是微服务？ 要想学习微服务，首先需要知道什么是微服务？为什么会有微服务？相信看完架构的发展史读者就会明白 架构发展史 单体应用架构 如图所示：将所有的模块，所有内容(页面、</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/keatsCoder/p/12237078.html</dc:identifier>
</item>
<item>
<title>C++ 引用分析 - 小胖西瓜</title>
<link>http://www.cnblogs.com/shuqin/p/12237009.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shuqin/p/12237009.html</guid>
<description>&lt;ul&gt;&lt;li&gt;左值引用，建立既存对象的别名&lt;/li&gt;
&lt;li&gt;右值引用，可用于为临时对象延长生命周期&lt;/li&gt;
&lt;li&gt;转发引用，保持函数实参的类别&lt;/li&gt;
&lt;li&gt;悬置引用，对象生命周期已经结束的引用，访问改引用为未定义行为&lt;/li&gt;
&lt;li&gt;值类别，左值，纯右值，亡值&lt;/li&gt;
&lt;li&gt;std::move, std::forward&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;类型推导&quot;&gt;类型推导&lt;/h2&gt;
&lt;h3 id=&quot;引用塌缩折叠&quot;&gt;&lt;span id=&quot;ref_collapsing&quot;&gt;引用塌缩（折叠）&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;可以通过模板或者 typedef 中的类型操作构成引用的引用，但是C++不认识多个&lt;code&gt;&amp;amp;&lt;/code&gt; 的，所以就产生一个规则，左值引用 &lt;code&gt;&amp;amp;&lt;/code&gt;， 右值引用 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;，在结合的时候，可以把左值引用看作是显性基因，只要有左值引用，那么结合就折叠成左值引用，要两个都是隐形基因（&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;）的情况，才不会进行折叠。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;typedef int&amp;amp;  lref;
typedef int&amp;amp;&amp;amp; rref;
int n;
lref&amp;amp;  r1 = n; // r1 的类型是 int&amp;amp;
lref&amp;amp;&amp;amp; r2 = n; // r2 的类型是 int&amp;amp;
rref&amp;amp;  r3 = n; // r3 的类型是 int&amp;amp;
rref&amp;amp;&amp;amp; r4 = 1; // r4 的类型是 int&amp;amp;&amp;amp;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;右值引用作为函数实参-的类型推导&quot;&gt;右值引用作为函数实参 的类型推导&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;左值引用 (模板参数为右值引用).&lt;/li&gt;
&lt;li&gt;左值（普通函数调用）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;写个小例子就可以看出效果了，普通函数的情况如下，模板的示例见 &lt;a href=&quot;https://www.cnblogs.com/shuqin/p/12237009.html#forward&quot;&gt;std::forward 分析&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;int foo(int &amp;amp;&amp;amp;arg) { std::cout &amp;lt;&amp;lt; &quot;int &amp;amp;&amp;amp;\n&quot;; }  // 不会被调用

int foo(int &amp;amp;arg) {std::cout &amp;lt;&amp;lt; &quot;int &amp;amp;\n&quot;;}   // 两个函数只能存在一个
// int foo(int arg) { std::cout &amp;lt;&amp;lt; &quot;int\n&quot;; }

int main() {
    int &amp;amp;&amp;amp;rref = 1;
    foo(rref);  // int 或者 int &amp;amp;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;指针与引用的联系与区别&quot;&gt;指针与引用的联系与区别&lt;/h2&gt;
&lt;p&gt;指针和引用经常会一起出现，个人的理解&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;指针，存储地址的变量，能够存储任何的地址，自身也需要分配内存，比如 nullptr，并且能够任意修改（无cv限定情况）。&lt;/li&gt;
&lt;li&gt;引用，对象或者函数的别名，必须初始化且不能修改，语义上不分配内存，故指针不能指向引用，反之，引用可以绑定指针（指针自身是具名对象）。&lt;em&gt;但在实现上（gcc）还是会分配内存&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;通过一个例子就可以看的很清楚，两者都是 &lt;strong&gt;访问地址&lt;/strong&gt; 来实现的，但由于历史原因我们一说到地址就会想到指针。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void ref() {
    int value = 13;
    int &amp;amp;lref = value;
    lref = 9;

    int *p = nullptr;
    p = &amp;amp;value;
    *p = 21;
}

_Z3refv:
.LFB0:
    .cfi_startproc
    pushq   %rbp
    .cfi_def_cfa_offset 16
    .cfi_offset 6, -16
    movq    %rsp, %rbp
    .cfi_def_cfa_register 6
    movl    $13, -20(%rbp)
    leaq    -20(%rbp), %rax  # 取 value 的地址 &amp;amp;value
    movq    %rax, -8(%rbp)   # 将 value 的地址转移，这两步可以不需要的
    movq    -8(%rbp), %rax
    movl    $9, (%rax)       # 赋值 lref = 9
    movq    $0, -16(%rbp)    # 指针初始化
    leaq    -20(%rbp), %rax  # 同上，取地址
    movq    %rax, -16(%rbp)
    movq    -16(%rbp), %rax
    movl    $21, (%rax)      # 赋值 *p = 21
    nop
    popq    %rbp
    .cfi_def_cfa 7, 8
    ret
    .cfi_endproc&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在使用上来说，引用优于指针的地方在于，引用避免了空指针的判断，并且在使用上和值语义相近。&lt;br/&gt;google 的 coding style 上也有针对引用和指针参数的规范，入参如果不能够被改变的话，使用 &lt;code&gt;const T &amp;amp;&lt;/code&gt;，如果是需要使用指针或者参数可变的情况下使用指针入参。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// 形式如下
void do_something(const std::string&amp;amp; in, char *out);&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;左值引用和悬置引用&quot;&gt;左值引用和悬置引用&lt;/h2&gt;
&lt;p&gt;左值引用的定义清晰，就是既存对象的别名，当作披着地址的皮来使用就可以，并且也能延长生命周期（&lt;code&gt;const T &amp;amp;&lt;/code&gt; 接收），见延长&lt;a href=&quot;https://www.cnblogs.com/shuqin/p/12237009.html#rref&quot;&gt;右值引用分析&lt;/a&gt;。&lt;br/&gt;悬置引用在使用不当的时候可能出现，如下&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;struct Foo {
    Foo() : value(13) {}
    ~Foo() { value = -1; }
    int value;
};

Foo &amp;amp;get_foo() {
    Foo f;
    return f;
}

int main() { Foo &amp;amp;f = get_foo(); }

// 反汇编，只截取 get_foo()
    .cfi_startproc
    pushq   %rbp
    .cfi_def_cfa_offset 16
    .cfi_offset 6, -16
    movq    %rsp, %rbp
    .cfi_def_cfa_register 6
    pushq   %rbx
    subq    $24, %rsp
    .cfi_offset 3, -24
    leaq    -20(%rbp), %rax  // 对象 f 的地址
    movq    %rax, %rdi       // 构造函数的隐藏参数
    call    _ZN3FooC1Ev      // 调用构造函数
    movl    $0, %ebx
    leaq    -20(%rbp), %rax
    movq    %rax, %rdi
    call    _ZN3FooD1Ev      // 析构函数
    movq    %rbx, %rax       // 最后返回的是 rax（rax = rbx），但是这个 rbx 是没有来源的，访问直接段错误
    addq    $24, %rsp
    popq    %rbx
    popq    %rbp
    .cfi_def_cfa 7, 8
    ret
    .cfi_endproc&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当出现这种悬置引用的时候，再去访问就不知道是什么错误了，好消息是编译器可以识别这个问题并且发出警告的。&lt;/p&gt;
&lt;h2 id=&quot;右值引用&quot;&gt;&lt;span id=&quot;rref&quot;&gt;右值引用&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;右值引用就是为了延长生命周期而生的，这里再扯一下，左值引用也是可以做到这一点的，但是不能够通过左值引用修改。&lt;br/&gt;拿一下 cppreference 中的例子，右值引用是通过 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 使得编译器指令重排而延长生命周期的，而左值引用是 &lt;code&gt;const T &amp;amp;&lt;/code&gt; 进行py交易的，&lt;/p&gt;
&lt;p&gt;在以上函数增加一个友元函数，重载 &lt;code&gt;+&lt;/code&gt; 操作符。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;friend Foo operator+(const Foo &amp;amp;lhs, const Foo &amp;amp;rhs) {
    Foo foo;
    foo.value = lhs.value + rhs.value;
    return foo;
}

int main() {
    Foo f1;
    const Foo &amp;amp;lref = f1 + f1;
    // rf.value = 1;

    Foo &amp;amp;&amp;amp;rref = f1 + f1;  // 临时变量 f1 + f2 的引用
    rref.value = 4;        // 相同
}

// 反汇编取重载函数和main函数代码
_ZplRK3FooS1_:
.LFB6:
    .cfi_startproc
    pushq   %rbp
    .cfi_def_cfa_offset 16
    .cfi_offset 6, -16
    movq    %rsp, %rbp
    .cfi_def_cfa_register 6
    subq    $32, %rsp
    movq    %rdi, -8(%rbp)  // rdi 是构造函数的第一个参数，当函数返回对象时，就是这样做的
    movq    %rsi, -16(%rbp) // lhs
    movq    %rdx, -24(%rbp) // rhs
    movq    -8(%rbp), %rax
    movq    %rax, %rdi
    call    _ZN3FooC1Ev     // 调用构造函数
    movq    -16(%rbp), %rax
    movl    (%rax), %edx    // lhs.value
    movq    -24(%rbp), %rax
    movl    (%rax), %eax    // rhs.value
    addl    %eax, %edx      // edx = lhs.value + rhs.value
    movq    -8(%rbp), %rax
    movl    %edx, (%rax)    // foo.value = edx
    nop
    movq    -8(%rbp), %rax  // return foo
    leave
    .cfi_def_cfa 7, 8
    ret
    .cfi_endproc

main:
.LFB8:
    .cfi_startproc
    pushq   %rbp
    .cfi_def_cfa_offset 16
    .cfi_offset 6, -16
    movq    %rsp, %rbp
    .cfi_def_cfa_register 6
    subq    $32, %rsp
    leaq    -28(%rbp), %rax   // 取 f1 的地址
    movq    %rax, %rdi
    call    _ZN3FooC1Ev       // Foo f1;
    leaq    -24(%rbp), %rax   // 重载函数内的 临时对象，当重载函数返回对象时，编译器便把对象指针传进去
    leaq    -28(%rbp), %rdx   // rhs,f1
    leaq    -28(%rbp), %rcx
    movq    %rcx, %rsi        // lhs,f1
    movq    %rax, %rdi
    call    _ZplRK3FooS1_     // 调用重载函数
    leaq    -24(%rbp), %rax
    movq    %rax, -8(%rbp)
    leaq    -20(%rbp), %rax   // 第二次调用的重载函数内的 临时对象指针
    leaq    -28(%rbp), %rdx   // rhs,f1
    leaq    -28(%rbp), %rcx
    movq    %rcx, %rsi        // lhs,f1
    movq    %rax, %rdi
    call    _ZplRK3FooS1_     // 第二次调用重载函数
    leaq    -20(%rbp), %rax   // 这两个值是相等的，也就是返回的临时对象指针
    movq    %rax, -16(%rbp)
    movq    -16(%rbp), %rax
    movl    $4, (%rax)        // rref.value = 4;
    leaq    -20(%rbp), %rax
    movq    %rax, %rdi
    call    _ZN3FooD1Ev       // 析构函数被移动到作用域之外也就是main函数里面了
    leaq    -24(%rbp), %rax
    movq    %rax, %rdi
    call    _ZN3FooD1Ev
    leaq    -28(%rbp), %rax
    movq    %rax, %rdi
    call    _ZN3FooD1Ev
    movl    $0, %eax
    leave
    .cfi_def_cfa 7, 8
    ret
    .cfi_endproc&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 和 &lt;code&gt;const T &amp;amp;&lt;/code&gt; 产生的汇编代码几乎是一样的，两者都提供了常量引用的语义，是编译器的实现也在函数返回对象的情况下模糊了这两者的区别（生成汇编代码），所以在有些情况下，在未提供 &lt;code&gt;f(T &amp;amp;&amp;amp;)&lt;/code&gt; 重载则会调用 &lt;code&gt;f(const T &amp;amp;)&lt;/code&gt;。但是区别在于常量左值引用是不可修改的。&lt;/p&gt;
&lt;p&gt;一些函数提供了两个引用的重载版本，如 &lt;code&gt;std::vector::push_back()&lt;/code&gt;，允许自动选择copy构造函数和移动构造函数。&lt;/p&gt;
&lt;h3 id=&quot;值类别&quot;&gt;值类别&lt;/h3&gt;
&lt;ol readability=&quot;2&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;左值&lt;br/&gt;简单粗暴的理解就是在操作符的左边的表达式，但是C++的概念比较的多，例如，++i 这个是左值，i++ 就是纯右值了，字符串常量也没有想到是左值吧，因为不能修改，所以不能存在于表达式的左边。&lt;br/&gt;cppreference 中的概念陈述的非常多，简单而言就是有分配内存的对象就是左值，只有这种情况才能够用于初始话左值引用（字符串常量，&lt;code&gt;const char *&lt;/code&gt;）。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;纯右值&lt;br/&gt;取不到地址的表达式，如内建类型值，this指针，lambda&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;亡值&lt;br/&gt;差不多可以理解为，作为一个临时量，内存中存在数据，如果不延长生命周期的话，该对象就会被销毁。std::move 产生的就是亡值。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;然后上面的种类繁多，又有混合类别产生：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;泛左值，左值和亡值，也就是内存有数据的对象&lt;/li&gt;
&lt;li&gt;右值，纯右值和亡值，不能被左值引用绑定的对象&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;stdmove-stdforward&quot;&gt;std::move std::forward&lt;/h2&gt;
&lt;h3 id=&quot;stdmove&quot;&gt;std::move&lt;/h3&gt;
&lt;p&gt;右值引用变量的名称是左值，而若要绑定到接受 &lt;strong&gt;右值引用参数的重载，就必须转换到亡值&lt;/strong&gt;，这是移动构造函数与移动赋值运算符典型地使用 std::move 的原因。&lt;br/&gt;函数名称和目的相关，但内部实现没有什么移动的操作，就一个转换类型，见 libstdcxx 源码。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;template&amp;lt;typename _Tp&amp;gt;
  constexpr typename std::remove_reference&amp;lt;_Tp&amp;gt;::type&amp;amp;&amp;amp;
  move(_Tp&amp;amp;&amp;amp; __t) noexcept
  { return static_cast&amp;lt;typename std::remove_reference&amp;lt;_Tp&amp;gt;::type&amp;amp;&amp;amp;&amp;gt;(__t); }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;stdforward&quot;&gt;&lt;span id=&quot;forward&quot;&gt;std::forward&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;转发引用利用 &lt;code&gt;std::forward&lt;/code&gt; 保持实参值类型进行完美转发，完美转发详细的说一下，它的实现也不是很复杂，有两个重载函数，实际上都是类型转换，&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// 转发左值为左值或右值，依赖于 T
template &amp;lt;typename _Tp&amp;gt;
constexpr _Tp &amp;amp;&amp;amp;
forward(typename std::remove_reference&amp;lt;_Tp&amp;gt;::type &amp;amp;__t) noexcept {
    return static_cast&amp;lt;_Tp &amp;amp;&amp;amp;&amp;gt;(__t);
}

// 转发右值为右值并禁止右值的转发为左值
template &amp;lt;typename _Tp&amp;gt;
constexpr _Tp &amp;amp;&amp;amp;
forward(typename std::remove_reference&amp;lt;_Tp&amp;gt;::type &amp;amp;&amp;amp;__t) noexcept {
    static_assert(!std::is_lvalue_reference&amp;lt;_Tp&amp;gt;::value,
                  &quot;template argument substituting _Tp is an lvalue reference type&quot;);
    return static_cast&amp;lt;_Tp &amp;amp;&amp;amp;&amp;gt;(__t);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参考上面的 &lt;a href=&quot;https://www.cnblogs.com/shuqin/p/12237009.html#ref_collapsing&quot;&gt;&lt;em&gt;引用折叠&lt;/em&gt;&lt;/a&gt; ，以下给定例子的参数类型推导：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;template &amp;lt;typename T&amp;gt; void foo(const T &amp;amp;arg) { std::cout &amp;lt;&amp;lt; &quot;const T &amp;amp;\n&quot;; }
template &amp;lt;typename T&amp;gt; void foo(T &amp;amp;arg) { std::cout &amp;lt;&amp;lt; &quot;T &amp;amp;\n&quot;; }
template &amp;lt;typename T&amp;gt; void foo(T &amp;amp;&amp;amp;arg) { std::cout &amp;lt;&amp;lt; &quot;T &amp;amp;&amp;amp;\n&quot;; }

template &amp;lt;typename T&amp;gt; void wrapper(T &amp;amp;&amp;amp;arg) { foo(std::forward&amp;lt;T&amp;gt;(arg)); }

int main() {
    Foo f1;
    const Foo f2;
    wrapper(f1);      // T &amp;amp;
    wrapper(f1 + f1); // T &amp;amp;&amp;amp;
    wrapper(f2);      // const T &amp;amp;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;若 wrapper 调用的入参为右值，则 T 被推导为 &lt;code&gt;Foo&lt;/code&gt;, 这样 &lt;code&gt;std::forward&lt;/code&gt; 就把右值引用转发给 foo&lt;/li&gt;
&lt;li&gt;若 wrapper 调用的入参为&lt;code&gt;const&lt;/code&gt;限定左值，则推导 T 为 &lt;code&gt;const Foo &amp;amp;&lt;/code&gt;，在引用折叠下 &lt;code&gt;std::forward&lt;/code&gt; 将 const 左值引用传递给 foo&lt;/li&gt;
&lt;li&gt;若 wrapper 掉用的入参为非const左值，则推到 T 为 &lt;code&gt;Foo &amp;amp;&lt;/code&gt;，在引用折叠下 &lt;code&gt;std::forward&lt;/code&gt; 将非 const 左值引用传递给 foo&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;另外，对类型的推导过程都是在编译期完成的，不同的限定或者引用类型的c++代码生成的汇编代码没有区别，为了编译期匹配到正确的函数调用。&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://zh.cppreference.com/w/cpp/language/reference&quot;&gt;引用声明&lt;/a&gt;，cppreference 引用声明。&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Mon, 27 Jan 2020 13:57:00 +0000</pubDate>
<dc:creator>小胖西瓜</dc:creator>
<og:description>引用 左值引用，建立既存对象的别名 右值引用，可用于为临时对象延长生命周期 转发引用，保持函数实参的类别 悬置引用，对象生命周期已经结束的引用，访问改引用为未定义行为 值类别，左值，纯右值，亡值 st</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/shuqin/p/12237009.html</dc:identifier>
</item>
<item>
<title>Redis系列-存储hash主要操作命令 - PassZhang</title>
<link>http://www.cnblogs.com/passzhang/p/12236917.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/passzhang/p/12236917.html</guid>
<description>&lt;p&gt;hash是一些列key value（field value）的映射表。常常用其存储一些对象实例。相对于把一个对象的各个字段存储为string，存储为hash会占用更少的内存。为什么会更省内存呢？需要搞清楚两个配置（hash-max-zipmap-entries和hash-max-zipmap-value）的含义，配置的详细介绍，我打算放在最后的配置优化环节讲。&lt;/p&gt;
&lt;h2 id=&quot;新增&quot;&gt;1）新增&lt;/h2&gt;
&lt;h3 id=&quot;ahset&quot;&gt;a）hset&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;语法：hset key field value&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;解释：设置hash表key中的field的值。如果hash表不存在，则创建，并执行设置field的值，如果hash表存在，值field的值覆盖或新增&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;[root@localhost ~]# redis-cli 
redis 127.0.0.1:6379&amp;gt; hset user.1 name lisi    #设置key user.1 name域 的值
(integer) 1
redis 127.0.0.1:6379&amp;gt; hset user.1 age 45 #设置age域
(integer) 1
redis 127.0.0.1:6379&amp;gt; hset user.1 tech lisi
(integer) 1&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;bhmset&quot;&gt;b）hmset&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;语法：hash key field value[key value]
解释：批量设置hash表key的域
redis 127.0.0.1:6379&amp;gt; hmset user.2 name niuer age 34 #同时设置name 和age域
OK&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;chsetnx&quot;&gt;c）hsetnx&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;语法：hsetnx key field value
解释：仅仅当field域不存在时，设置hash表field的值
redis 127.0.0.1:6379&amp;gt; hsetnx user.1 name lisi  #由于name域已经设置过，所以返回0
(integer) 0
redis 127.0.0.1:6379&amp;gt; hsetnx user.1 fri 5  
(integer) 1   #fri域没有设置过，所以hset并返回1&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;查询&quot;&gt;2）查询&lt;/h2&gt;
&lt;h3 id=&quot;ahget&quot;&gt;a）hget&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;语法：hget key field

解释：获取哈希表key的field值

redis 127.0.0.1:6379&amp;gt; hget user.1 name  #存在的hash表及域
&quot;lisi&quot;
redis 127.0.0.1:6379&amp;gt; hget user.3 name  #不存在的hash表
(nil)
redis 127.0.0.1:6379&amp;gt; hget user.1 bb  #不存在的域
(nil)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;bhmget&quot;&gt;b）hmget&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;语法：hmget key field[field]

解释：批量获取hash表的filed

redis 127.0.0.1:6379&amp;gt; hmget user.1 name age fri tech
1) &quot;lisi&quot;
2) &quot;45&quot;
3) &quot;5&quot;
4) &quot;lisi&quot;
redis 127.0.0.1:6379&amp;gt; hmget user.1 name age fri tech nofield #存在hash表中包含不存在的域nofield
1) &quot;lisi&quot;
2) &quot;45&quot;
3) &quot;5&quot;
4) &quot;lisi&quot;
5) (nil)
redis 127.0.0.1:6379&amp;gt; hmget user.3 name age fri #不存在的hash表
1) (nil)
2) (nil)
3) (nil)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;chgetall&quot;&gt;c）hgetall&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;语法：hgetall key

解释：获取hash表的所有域值

redis 127.0.0.1:6379&amp;gt; hgetall user.2  #存在的hash表
1) &quot;name&quot;   #域
2) &quot;niuer&quot;  #域name的值
3) &quot;age&quot;    #域
4) &quot;34&quot;     #域age的值
redis 127.0.0.1:6379&amp;gt; hgetall user.3  #不存在的hansh表
(empty list or set)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;dhexists&quot;&gt;d）hexists&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;语法：hexists key field

解释：判断hash表中是否存在某个域

redis 127.0.0.1:6379&amp;gt; hexists user.1 name  #存在
(integer) 1
redis 127.0.0.1:6379&amp;gt; hexists user.1 nofield  #不存在
(integer) 0
redis 127.0.0.1:6379&amp;gt; hexists use1 nofield #hash表不存在
(integer) 0&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;ehkeys&quot;&gt;e）hkeys&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;语法：hkeys key

解释：获取hash表的所有域

redis 127.0.0.1:6379&amp;gt; hkeys user.1  #存在的hash表
1) &quot;name&quot;
2) &quot;age&quot;
3) &quot;tech&quot;
4) &quot;fri&quot;
redis 127.0.0.1:6379&amp;gt; hkeys user.4 #不存在的hash
(empty list or set)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;fhvals&quot;&gt;f）hvals&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;语法：hvals key

解释：获取hash表的所有域值

redis 127.0.0.1:6379&amp;gt; hvals user.1  #存在hash
1) &quot;lisi&quot;
2) &quot;45&quot;
3) &quot;lisi&quot;
4) &quot;5&quot; 
redis 127.0.0.1:6379&amp;gt; hvals user.4 #不存在
(empty list or set)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;修改&quot;&gt;3）修改&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;语法：hincrby key field increment

解释：hash表field域的数值增加步长increment，如果increment是负值，则是递减。如果域不存在，初始值视为0

redis 127.0.0.1:6379&amp;gt; hincrby user.1 age 2  #增加2
(integer) 47
redis 127.0.0.1:6379&amp;gt; hincrby user.1 age -3  #减少3
(integer) 44
redis 127.0.0.1:6379&amp;gt; hincrby user.1 age2 -3 #域不能存在，初始值是0
(integer) -3&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;删除&quot;&gt;4）删除&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;语法：hdel key field[field]

解释：删除hash的域，如果指定多个field，则删除多个

redis 127.0.0.1:6379&amp;gt; hkeys user.1
1) &quot;name&quot;
2) &quot;age&quot;
3) &quot;tech&quot;
4) &quot;fri&quot;
5) &quot;age2&quot;
redis 127.0.0.1:6379&amp;gt; hdel user.1 age2  #删除一个域
(integer) 1
redis 127.0.0.1:6379&amp;gt; hkeys user.1
1) &quot;name&quot;
2) &quot;age&quot;
3) &quot;tech&quot;
4) &quot;fri&quot;
redis 127.0.0.1:6379&amp;gt; hdel user.1 fri tech #删除2个域
(integer) 2
redis 127.0.0.1:6379&amp;gt; hkeys user.1
1) &quot;name&quot;
2) &quot;age&quot;
redis 127.0.0.1:6379&amp;gt; hdel user.1 bb #删除一个不存在的域 
(integer) 0 #返回0&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;其他&quot;&gt;5）其他&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;语法：hlen key

解释：获取hash的域数量

redis 127.0.0.1:6379&amp;gt; hkeys user.1
1) &quot;name&quot;
2) &quot;age&quot;
redis 127.0.0.1:6379&amp;gt; hlen user.1 #存在2个域
(integer) 2
redis 127.0.0.1:6379&amp;gt; hlen user.4  #不存在的hash
(integer) 0&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;关于hash的更多详细用法，请参阅：http://redis.io/commands#hash&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 27 Jan 2020 13:22:00 +0000</pubDate>
<dc:creator>PassZhang</dc:creator>
<og:description>Redis系列 存储篇hash主要操作函数小结 hash是一些列key value（field value）的映射表。常常用其存储一些对象实例。相对于把一个对象的各个字段存储为string，存储为ha</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/passzhang/p/12236917.html</dc:identifier>
</item>
<item>
<title>【JDK1.8】 Java小白的源码学习系列：HashMap - 天乔巴夏丶</title>
<link>http://www.cnblogs.com/summerday152/p/12236816.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/summerday152/p/12236816.html</guid>
<description>&lt;p&gt;春节拜年取消，在家花了好多天时间啃一啃HashMap的源码，同样是找了很多很多的资料，有JDK1.7的，也有JDK1.8的，当然本文基于JDK1.8。将所学到的东西进行整理，希望回过头再看的时候，有更深刻的见解。&lt;/p&gt;
&lt;h2 id=&quot;官方文档解读&quot;&gt;官方文档解读&lt;/h2&gt;
&lt;p&gt;先来看看史诗级长屏之官方介绍&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1771072/202001/1771072-20200127204613690-627459685.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;基本数据结构&quot;&gt;基本数据结构&lt;/h2&gt;
&lt;p&gt;实际上，在JDK1.8中，HashMap底层是依据&lt;strong&gt;数组+单链表+红黑树&lt;/strong&gt;的结构存储数据的。具体是怎么样的呢？&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1771072/202001/1771072-20200127204634398-729081159.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;HashMap实现了Map接口，维护的是一组组&lt;strong&gt;键值对&lt;/strong&gt;，以便于我们根据键就能立刻获取其对应值。另外，HashMap用了特殊的手法，优化了它的性能，我们本篇来具体学习并总结一下。&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li&gt;我们知道，数组的结构利于查询，HashMap依据&lt;strong&gt;哈希函数&lt;/strong&gt;，将元素以某种方式映射到数组的某个位置上，就可以依据数组结构查询快的特点迅速锁定目标。&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;但是，哈希函数并不是万能的，两个不同的元素完全有可能算出相同的哈希值，这个时候就产生了&lt;strong&gt;哈希碰撞&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;HashMap是如何解决的呢？上面已经提到，采用的是&lt;strong&gt;链地址法&lt;/strong&gt;，就是&lt;u&gt;将每个元素看成单链表中的节点，都有指向下一个节点的指针。&lt;/u&gt;这是一个不错的办法，能够减少重哈希的概率。&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;但，又有一个问题，要是真的出现了极端的情况：有大量的元素通过哈希函数求得的值聚集在同一个链表上，这时想要找到这个元素，需要花费大量的时间。JDK1.8中，运用了红黑树结构，&lt;strong&gt;链表中的节点数&amp;gt;TREEIFY_THRESHOLD&lt;/strong&gt;时，链表结构将会转化为树形结构，将查找元素的时间复杂度从O(n)降为O(logn)，大大提高了效率。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;基本源码解读&quot;&gt;基本源码解读&lt;/h2&gt;
&lt;h3 id=&quot;基本成员变量&quot;&gt;基本成员变量&lt;/h3&gt;
&lt;p&gt;再看看HashMap中定义的一些&lt;strong&gt;常量&lt;/strong&gt;：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    //序列号
    private static final long serialVersionUID = 362498820763181265L;
    //默认的初始容量为16（必须为2的幂）
    static final int DEFAULT_INITIAL_CAPACITY = 1 &amp;lt;&amp;lt; 4; // aka 16
    //允许的最大容量2的30次幂
    static final int MAXIMUM_CAPACITY = 1 &amp;lt;&amp;lt; 30;
    //没有指定负载因子时，默认为0.75f
    static final float DEFAULT_LOAD_FACTOR = 0.75f;
    //链表转化为红黑树的阈值
    static final int TREEIFY_THRESHOLD = 8;
    //红黑树退化为链表的阈值
    static final int UNTREEIFY_THRESHOLD = 6;
    //数组的容量大于64时，桶才有可能转化为树形结构
    static final int MIN_TREEIFY_CAPACITY = 64;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还有一些&lt;strong&gt;成员变量&lt;/strong&gt;：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    //存储的元素的数组，数组容量一定时2的幂次
    transient Node&amp;lt;K,V&amp;gt;[] table;    
    //存放具体元素的集
    transient Set&amp;lt;Map.Entry&amp;lt;K,V&amp;gt;&amp;gt; entrySet;
    //存放元素的个数
    transient int size;
    //每次更改结构的计数器
    transient int modCount;
    //阈值，还没有分配数组时，阈值为默认容量或指定容量，之后该值等于容量*负载因子
    int threshold;
    //负载因子
    final float loadFactor;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;构造器&quot;&gt;构造器&lt;/h3&gt;
&lt;p&gt;我们根据源码，来看看在JDK1.8中，这些到底是如何实现的，以及为什么要这样考虑。&lt;br/&gt;还是先看看其中三个&lt;strong&gt;构造器&lt;/strong&gt;（暂时先忽略最后一个）：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    //无参构造器
    public HashMap() {
        this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted
    }
    //指定容量的构造器
    public HashMap(int initialCapacity) {
        this(initialCapacity, DEFAULT_LOAD_FACTOR);
    }
    //两参构造器
    public HashMap(int initialCapacity, float loadFactor) {
        if (initialCapacity &amp;lt; 0)
            throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +
                                               initialCapacity);
        if (initialCapacity &amp;gt; MAXIMUM_CAPACITY)
            initialCapacity = MAXIMUM_CAPACITY;
        if (loadFactor &amp;lt;= 0 || Float.isNaN(loadFactor))
            throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +
                                               loadFactor);
        this.loadFactor = loadFactor;
        this.threshold = tableSizeFor(initialCapacity);
    }
    //传入映射集的构造器
    public HashMap(Map&amp;lt;? extends K, ? extends V&amp;gt; m) {
        this.loadFactor = DEFAULT_LOAD_FACTOR;
        putMapEntries(m, false);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这就是HashMap中提供的四个构造器，我们从中可以察觉出一些端倪。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;如果没有指定负载因子，默认为0.75&lt;/strong&gt;，且指定的负载因子需要大于0。&lt;/li&gt;
&lt;li&gt;初始容量并没有在构造器中直接指定，我们暂时保留疑惑。&lt;/li&gt;
&lt;li&gt;通过两个参数的构造器，我们发现通过&lt;code&gt;tableSizeFor&lt;/code&gt;对我们传入的初始容量进行计算，并为阈值赋值。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;巧妙的tablesizefor&quot;&gt;巧妙的tableSizeFor&lt;/h3&gt;
&lt;p&gt;说到这，我们来看看这个巧妙的&lt;code&gt;tableSizeFor&lt;/code&gt;，我们通过注解可以知道，这个方法返回的是大于等于传入值的最小2的幂次方（传入1时，为1）。它到底是怎么实现的呢，我们来看看具体的源码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    static final int tableSizeFor(int cap) {
        int n = cap - 1;
        n |= n &amp;gt;&amp;gt;&amp;gt; 1;
        n |= n &amp;gt;&amp;gt;&amp;gt; 2;
        n |= n &amp;gt;&amp;gt;&amp;gt; 4;
        n |= n &amp;gt;&amp;gt;&amp;gt; 8;
        n |= n &amp;gt;&amp;gt;&amp;gt; 16;
        return (n &amp;lt; 0) ? 1 : (n &amp;gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;说实话，我再看到这个方法具体实现之后，感叹了一句，数学好牛！我通过代入具体数字，翻阅了许多关于这部分的文章与视频，通过简单的例子，来做一下总结。&lt;/p&gt;
&lt;p&gt;讲到这里，我知道了为什么数组的容量总是2的幂次数了：是因为运算规定,但是这基本不算是原因，选择2的幂次方数一定有出于便利的方面的原因，这部分我们待会再说。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;我们在分析成员变量的时候说过，&lt;code&gt;threshold&lt;/code&gt;是用来表示一个阈值，表示数组容量和负载因子的乘积。但是我们发现，还没分配数组的时候，其实是我们不小于指定容量的二次幂。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那么，&lt;strong&gt;数组什么时候才进行初始化呢&lt;/strong&gt;？脑瓜子转一下，应该就知道，是&lt;strong&gt;往里面存元素&lt;/strong&gt;的时候。我们来看一看HashMap里面存储元素的方法。&lt;/p&gt;
&lt;h3 id=&quot;put方法&quot;&gt;put方法&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    //联系指定的键Key和值Value，如果在这之前map包含相同的key，返回旧key对应的value
    public V put(K key, V value) {
        return putVal(hash(key), key, value, false, true);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;巧妙的hash方法&quot;&gt;巧妙的hash方法&lt;/h3&gt;
&lt;p&gt;其中调用了hash方法，对传入的键key进行哈希计算，具体计算细节如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &amp;gt;&amp;gt;&amp;gt; 16);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们着重了解一下，key不为null的情况下hash函数的实现，具体为啥要这样设计，我们之后再总结：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;h存储的是传入key的哈希值，这个方法继承于Object类，产生一个int值。&lt;/li&gt;
&lt;li&gt;将上面这个老哈希值和无符号右移16位（将原高16位向低位移动，原高位全部以0填充）之后的新哈希值进行亦或运算，相同为0，不同为1。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;有效地将高低位二进制特征混合，防止由高位的细微区别产生的频繁哈希碰撞，具体可以看一下文末的参考链接。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;jdk1.8的putval方法&quot;&gt;JDK1.8的putVal方法&lt;/h2&gt;
&lt;p&gt;下面是一个及其关键的方法putVal。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
        Node&amp;lt;K,V&amp;gt;[] tab; Node&amp;lt;K,V&amp;gt; p; int n, i;
        //如果数组未初始化或者长度为0，则调用resize()初始化数组
        if ((tab = table) == null || (n = tab.length) == 0)
            n = (tab = resize()).length;
        //根据hash值计算数组中的桶位，如果为null，则在该桶位上新建节点
        if ((p = tab[i = (n - 1) &amp;amp; hash]) == null)
            tab[i] = newNode(hash, key, value, null);
        else {
            Node&amp;lt;K,V&amp;gt; e; K k;
            //hash值相同，落入同一个桶中，且key相同
            if (p.hash == hash &amp;amp;&amp;amp;
                ((k = p.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
                e = p;
            //判断是否为树形节点
            else if (p instanceof TreeNode)
                e = ((TreeNode&amp;lt;K,V&amp;gt;)p).putTreeVal(this, tab, hash, key, value);
            else {
                //在节点后面插入新节点，桶中链表最多有8个节点，再加就变成了树
                for (int binCount = 0; ; ++binCount) {
                    if ((e = p.next) == null) {
                        p.next = newNode(hash, key, value, null);
                        //超过阈值，转为树形
                        if (binCount &amp;gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                            treeifyBin(tab, hash);
                        break;
                    }
                    //判断后面节点是否存在key相同的情况
                    if (e.hash == hash &amp;amp;&amp;amp;
                        ((k = e.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
                        break;
                    //e=p.next;p=e;这两步完成遍历
                    p = e;
                }
            }
            //如果存在相同key值相同，新值替换旧值
            if (e != null) { // existing mapping for key
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;
                afterNodeAccess(e);
                return oldValue;
            }
        }
        ++modCount;
        //容量大于阈值，resize();
        if (++size &amp;gt; threshold)
            resize();
        afterNodeInsertion(evict);
        return null;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在没了解resize方法之前，我们暂且将他定义成&lt;strong&gt;扩容和重哈希&lt;/strong&gt;的重要方法，我们先就putVal方法进行一些总结：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;我们看到，在没有添加键值对的时候，数组并没有初始化；在调用put方法之后，&lt;strong&gt;putVal中将会调用resize()真正对数组进行初始化&lt;/strong&gt;，至于如何实现，我们待会分析resize。&lt;/li&gt;
&lt;li&gt;我们还说过，HashMap主要利用了哈希函数对传入的key值进行哈希运算，然后利用特殊的方法将求得的哈希值正确放入数组中的每个桶中。这个特殊的方法即:&lt;code&gt;p = tab[i = (n - 1) &amp;amp; hash]&lt;/code&gt;，n为数组的长度，它是2的幂次方，我们很容易能够明白，&lt;strong&gt;通过(n-1)&amp;amp;hash产生的索引值必然落在0~n-1的范围内&lt;/strong&gt;，相当于&lt;code&gt;i=hash%n&lt;/code&gt;,但是位运算的效率更高。这就是容量设置为2的幂次方数的另外原因。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(k = p.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k)))&lt;/code&gt;,这一步两边分别表示key是否为null的情况。&lt;/li&gt;
&lt;li&gt;我们知道，&lt;code&gt;TREEIFY_THRESHOLD&lt;/code&gt;为8，是链表结构转换为树形结构的阙值，通过源码我们可以知道，链表结构最多只能存储8个节点，如果要存第9个，就需要调用&lt;code&gt;treeifyBin(tab, hash);&lt;/code&gt;，转换为树。&lt;/li&gt;
&lt;li&gt;通过遍历的结构，我们可以发现，JDK1.8中，&lt;strong&gt;添加的操作会在链表的尾部执行&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;遍历之后，节点e不为null，说明确实找到了key相同的节点，这时替换value值，返回旧值。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;++size &amp;gt; threshold)&lt;/code&gt;,从这部分我们可以看出，除了初始化的时候是先resize再插入，其他的时候都是先插入，再判断是否需要扩容。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;jdk1.8的resize方法&quot;&gt;JDK1.8的resize方法&lt;/h2&gt;
&lt;p&gt;那么接下来，终于轮到resize方法了，我们先看一下代码的实现部分，哇这部分可是花了我好多的功夫，如果还有理解不正确的地方，还希望评论区批评指正：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    final Node&amp;lt;K,V&amp;gt;[] resize() {
        //oldTab存储的是扩容前的数组
        Node&amp;lt;K,V&amp;gt;[] oldTab = table;
        //oldCap存储的是扩容前的数组容量
        int oldCap = (oldTab == null) ? 0 : oldTab.length;
        //oldThr存储的是扩容前的阈值
        int oldThr = threshold;
        //newCap新数组容量，newThr新数组阈值
        int newCap, newThr = 0;
        if (oldCap &amp;gt; 0) {
            if (oldCap &amp;gt;= MAXIMUM_CAPACITY) {
                //如果老数组容量比数组最大容量还大，阈值变为Integer的最大值，返回老数组
                threshold = Integer.MAX_VALUE;
                return oldTab;
            }
            //新数组容量变为老数组容量的两倍
            else if ((newCap = oldCap &amp;lt;&amp;lt; 1) &amp;lt; MAXIMUM_CAPACITY &amp;amp;&amp;amp;
                     oldCap &amp;gt;= DEFAULT_INITIAL_CAPACITY)
                //新阈值变为两倍需要上面的条件都成立（1、扩容两倍之后的数组容量小于最大容量2、老容量大于等于16）
                newThr = oldThr &amp;lt;&amp;lt; 1; // double threshold
        }
        
        else if (oldThr &amp;gt; 0) // initial capacity was placed in threshold
            //使用带有初始容量构造器，让新容量变为通过initial capacity求得的threshold
            newCap = oldThr;
        else {               // zero initial threshold signifies using defaults
            //使用默认构造器，初始化容量为16
            newCap = DEFAULT_INITIAL_CAPACITY;
            //新容量变为16，新阈值变为0.75*16 = 12
            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
        }
        //使用带有初始容量的构造器进行扩容
        if (newThr == 0) {
            //新阈值 = 新容量 * 指定的负载因子
            float ft = (float)newCap * loadFactor;
            newThr = (newCap &amp;lt; MAXIMUM_CAPACITY &amp;amp;&amp;amp; ft &amp;lt; (float)MAXIMUM_CAPACITY ?
                      (int)ft : Integer.MAX_VALUE);
        }
        //将newThr赋值给threshold表示阈值
        threshold = newThr;
        @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;})
        Node&amp;lt;K,V&amp;gt;[] newTab = (Node&amp;lt;K,V&amp;gt;[])new Node[newCap];
        table = newTab;
        //数组如果进行初始化的步骤，不用进入下面的代码段
        //判断老数组是否为空
        if (oldTab != null) {
            for (int j = 0; j &amp;lt; oldCap; ++j) {
                //创建临时节点存储老数组oldTab上的元素
                Node&amp;lt;K,V&amp;gt; e;
                //如果老数组上索引j的位置不为null
                if ((e = oldTab[j]) != null) {
                    //将该位置置空
                    oldTab[j] = null;
                    //判断下一位是否还有元素
                    if (e.next == null)
                        //下一位为空，则表明该桶位只有一个元素，搬移至新数组
                        newTab[e.hash &amp;amp; (newCap - 1)] = e;
                    //判断是否为树形节点
                    else if (e instanceof TreeNode)
                        ((TreeNode&amp;lt;K,V&amp;gt;)e).split(this, newTab, j, oldCap);
                    //下一位不为空且为链表节点
                    else { // preserve order
                        
                        Node&amp;lt;K,V&amp;gt; loHead = null, loTail = null;
                        Node&amp;lt;K,V&amp;gt; hiHead = null, hiTail = null;
                        Node&amp;lt;K,V&amp;gt; next;
                        do {
                            next = e.next;
                            //在原来索引位置新建链表
                            if ((e.hash &amp;amp; oldCap) == 0) {
                                //尾节点为空时
                                if (loTail == null)
                                    //头节点指向原头节点，不再变化
                                    loHead = e;
                                else
                                    //在尾部接上老数组中的当前节点
                                    loTail.next = e;
                                //尾节点指向当前节点
                                loTail = e;
                            }
                            //在原来索引位置+老数组容量的位置新建链表
                            else {
                                //与上述相同
                                if (hiTail == null)
                                    hiHead = e;
                                else
                                    hiTail.next = e;
                                hiTail = e;
                            }
                            //while循环保证从到到尾遍历链表
                        } while ((e = next) != null);
                        //如果尾节点不为空，就让它的next指向空，链表完整
                        if (loTail != null) {
                            loTail.next = null;
                            //新数组的原索引位置指向链表头节点
                            newTab[j] = loHead;
                        }
                        if (hiTail != null) {
                            hiTail.next = null;
                            //新数组的原索引加老数组容量的索引位置指向链表头节点
                            newTab[j + oldCap] = hiHead;
                        }
                    }
                }
            }
        }
        return newTab;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;初始化部分&quot;&gt;初始化部分&lt;/h3&gt;
&lt;p&gt;我们先谈一谈数组的初始化部分：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;结合之前的putVal方法，我们知道当我们通过默认构造器创建HashMap，初始化为空的数组，threshold = 0。&lt;strong&gt;当第一次添加元素时进行扩容，此时数组容量为16，threshold为12。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;当我们指定指定&lt;code&gt;initialCapacity&lt;/code&gt;的时候，threshold一开始表示的是大于等于initialCapacity最小的2的幂次方数，直到第一次添加元素时进行扩容，&lt;strong&gt;数组容量为threshold的值，而threshold此时为指定负载因子与数组容量的乘积&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;若数组已经初始化，即数组容量&amp;gt;0时，再扩容，&lt;strong&gt;新容量变为原容量的两倍&lt;/strong&gt;，如果新容量小于最大容量，并且老容量&amp;gt;=16,此时threshold也变为原来的两倍，否则threshold不变。&lt;/li&gt;
&lt;li&gt;如果老数组的容量比最大容量还要大的话，&lt;strong&gt;阈值变为Integer的最大值，原数组不变。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;数组搬移部分&quot;&gt;数组搬移部分&lt;/h3&gt;
&lt;p&gt;我们重点谈一谈数组的搬移的基础部分：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;可以看到，通过for循环，通过j的改变，遍历数组中的每个桶的位置。&lt;/li&gt;
&lt;li&gt;如果桶位上只有一个节点，搬移操作很简单：&lt;code&gt;newTab[e.hash &amp;amp; (newCap - 1)] = e;&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;如果桶位上为树形节点，就按树形操作来：&lt;code&gt;((TreeNode&amp;lt;K,V&amp;gt;)e).split(this, newTab, j, oldCap);&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;最难的是，&lt;strong&gt;发生哈希碰撞&lt;/strong&gt;时，数组的搬移是如何实现的呢？我们可以发现，源码中对&lt;code&gt;e.hash &amp;amp; oldCap&lt;/code&gt;的值是0还是1进行了分类判断，为啥要这样做呢？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;我们知道，获取数组中的桶的位置，可以通过数组容量-1&amp;amp;hash求得。&lt;/li&gt;
&lt;li&gt;也就是说假如旧容量为16时，哈希值10和26和15进行与运算之后，&lt;strong&gt;都会保留二进制后四位的数&lt;/strong&gt;，也就是都为10,其实这就是哈希碰撞产生的原因嘛。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们首先必须明确，同样的哈希值，扩容前后的区别只是在于被截取的那一位，就拿26而言（0001 1010），以16为容量时，它的有效索引位置为1010，而以32为容量时，它的有效索引则是11010，刚好差了10000，即oldCap，如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1771072/202001/1771072-20200127204849355-154431382.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;e.hash&amp;amp;oldCap&lt;/code&gt;为0，节点在新数组中的&lt;strong&gt;索引不变&lt;/strong&gt;，newTab[j]。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;e.hash&amp;amp;oldCap&lt;/code&gt;为1，节点在新数组中的&lt;strong&gt;索引值 = 老数组容量+原索引值&lt;/strong&gt;，newTab[j + oldCap]。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;了解完这个，我们对其中哈希碰撞时节点搬移的代码的分析开始！&lt;br/&gt;关于其中针对&lt;code&gt;e.hash &amp;amp; oldCap&lt;/code&gt;不同而定义的一对作用相同的节点，我们暂且将他们单独拎出来，研究loHead和loTail，另外一对其实同理即可。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;我们知道，单链表的组成由存储的值和指向下一节点的指针next组成。&lt;/li&gt;
&lt;li&gt;通过do……while循环从链表的头节点向后，一直向尾节点进行遍历，直到其为空。&lt;/li&gt;
&lt;li&gt;建立临时节点e指向老链表的头节点，拥有相同的地址，其实就是&lt;strong&gt;拥有了与老链表相同的结构&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;其实链表的遍历的操作我们之前的文章已经分析过，这边是通过下面的语句完成的。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//do……while循环
do{
    next = e.next;
}while((e = next)!=null);&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;第一次进入循环时，loHead和loTail同时指向e，我在图中用灰色表示loHead，用白色表示loTail。&lt;/li&gt;
&lt;li&gt;后面每次进入循环，都会利用loTail节点向后移动，并将老链表的节点赋给新链表，一直串在头节点之后。&lt;/li&gt;
&lt;li&gt;直到遍历至老链表的最后一个节点，退出循环。&lt;/li&gt;
&lt;li&gt;如果新链表的尾节点不为null，将它的next指向null，此时一个完整的新链表就已经诞生。&lt;code&gt;loTail.next = null;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;将原数组的索引位置指向这个新链表的头节点。&lt;code&gt;newTab[j] = loHead;&lt;/code&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1771072/202001/1771072-20200127204805836-1192079826.png&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;p&gt;最后的最后，本文还有许多方面需要完善或者修改，之后会陆续将新体会上传，还望评论区批评指正。&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/zxporz/p/11204233.html&quot;&gt;HashMap中的hash算法中的几个疑问&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/zhengwang/p/8136164.html&quot;&gt;HashMap中的hash函数&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/u010890358/article/details/80496144&quot;&gt;jdk1.8 HashMap工作原理和扩容机制(源码解析)&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/u013494765/article/details/77837338&quot;&gt;Java 1.8中HashMap的resize()方法扩容部分的理解&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 27 Jan 2020 12:50:00 +0000</pubDate>
<dc:creator>天乔巴夏丶</dc:creator>
<og:description>[toc] Java小白的源码学习系列：HashMap 春节拜年取消，在家花了好多天时间啃一啃HashMap的源码，同样是找了很多很多的资料，有JDK1.7的，也有JDK1.8的，当然本文基于JDK1</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/summerday152/p/12236816.html</dc:identifier>
</item>
<item>
<title>【WPF学习】第十五章  WPF事件 - Peter.Luo</title>
<link>http://www.cnblogs.com/Peter-Luo/p/12236807.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Peter-Luo/p/12236807.html</guid>
<description>&lt;p&gt;　　前两章学习了WPF事件的工作原理，现在分析一下在代码中可以处理的各类事件。尽管每个元素都提供了许多事件，但最重要的事件通常包括以下5类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;　　&lt;strong&gt;生命周期事件&lt;/strong&gt;：在元素被初始化、加载或卸载时发生这些事件。&lt;/li&gt;
&lt;li&gt;　　&lt;strong&gt;鼠标事件&lt;/strong&gt;：这些事件是鼠标动作的结果。&lt;/li&gt;
&lt;li&gt;　　&lt;strong&gt;键盘事件&lt;/strong&gt;：这些事件是键盘动作（如按下键盘上的键）的结果。&lt;/li&gt;
&lt;li&gt;　　&lt;strong&gt;手写笔事件&lt;/strong&gt;：这些事件是使用类似钢笔的手写笔的结果。在平板电脑上用手写笔代替鼠标。&lt;/li&gt;
&lt;li&gt;　　&lt;strong&gt;多点触控事件&lt;/strong&gt;：这些事件是一根或多根手指在多点触控屏上触摸的结果。尽在Windows7中支持这些事件。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;一、生命周期事件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　当首次创建以及释放所有元素时都会引发事件，可使用这些事件初始化窗口。表1-1列出了这些事件，他们是在FrameworkElement类中定义的。&lt;/p&gt;
&lt;p&gt;表1-1 所有元素的生命周期事件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/263728/202001/263728-20200127180008968-1079471042.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　为了弄清Initialized事件和Loaded事件之间的关系，分析一下呈现过程是有帮助的。FrameworkElement类实现了ISupportInitialize接口，该接口提供了两个用于控制初始化过程的方法。第一个方法是BeginInit()，在实例化元素后立即调用该方法。调用BeginInit()方法后，XAML解析器设置所有元素的属性（并添加内容）。第二个方法是EndInit()，完成初始化后，将调用该方法，此时引发Initialized事件。&lt;/p&gt;
&lt;p&gt;　　当创建窗口时，会自下而上地初始化每个元素分支。这意味着，位于深层的嵌套元素在他们的容器之前被初始化。当引发初始化事件时，可确保元素树中当前元素以下的元素已经全部完成了初始化。但是，包含当前元素的元素可能还没有初始化，并且不能假定窗口的任何其他部分已经初始化。&lt;/p&gt;
&lt;p&gt;　　在每个元素都完成初始化后，还需要在他们的容器中进行布局、应用样式。如果需要的话，还会绑定到数据源。当引发窗口的Initialized事件后，就可以进入下一阶段了。&lt;/p&gt;
&lt;p&gt;　　一旦完成初始化过程，就会引发Loaded事件。Loaded事件和Initialized事件的发生过程相反——换句话说，包含其他所有元素的窗口首先引发Loaded事件，然后才是更深层的嵌套元素。为所有元素都引发了Loaded事件后，窗口就变得可见了，并且元素都已被呈现。&lt;/p&gt;
&lt;p&gt;　　窗口还有它自己更特殊的生命周期事件，表1-2列出了这些事件。&lt;/p&gt;
&lt;p&gt;表1-2 Windows类的生命周期事件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/263728/202001/263728-20200127211138107-792922636.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　如果只对执行控件的第一次初始化感兴趣，完成这项任务的最好时机是在触发Loaded事件时。通常可在同一位置进行所有初始化，这个位置一般是Window.Load事件的事件处理程序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、输入事件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　输入事件是当用户使用某些种类的外设硬件进行交互时发生的事件，例如鼠标、键盘、手写笔或多点触控屏。输入事件可通过继承自InputEventArgs的自定义事件参数类传递额外的信息。如下图所示，显示了继承层次。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/263728/202001/263728-20200127203933660-540169213.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图 输入事件的EventArgs类&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;　　InputEventArgs类只增加了两个属性：Timestamp和Device。Timestamp属性提供了一个整数，指示事件何时发生的毫秒数（它所代表的实际事件并不重要，但可比较不同的时间戳值以确定哪个事件先发生。事件戳值大的事件是在更近发生的）。Device属性返回一个对象，该对象提供与触发事件的设备相关的更多信息，设备可以是鼠标、键盘或手写笔。这三种可能的设备由不同的类表示，所有这些类都继承自抽象类System.Windows.Input.InputDevice.&lt;/p&gt;
&lt;p&gt;　　接下来章节将进一步分析在WPF应用程序中如何处理鼠标、键盘以及多点触控动作。&lt;/p&gt;
</description>
<pubDate>Mon, 27 Jan 2020 12:48:00 +0000</pubDate>
<dc:creator>Peter.Luo</dc:creator>
<og:description>前两章学习了WPF事件的工作原理，现在分析一下在代码中可以处理的各类事件。尽管每个元素都提供了许多事件，但最重要的事件通常包括以下5类： 生命周期事件：在元素被初始化、加载或卸载时发生这些事件。 鼠标</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Peter-Luo/p/12236807.html</dc:identifier>
</item>
<item>
<title>单例模式作用特点及常见的单例模式分析（6种单例模式分析） - 意必固我</title>
<link>http://www.cnblogs.com/liruilong/p/12236742.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liruilong/p/12236742.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;单例模式：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;即在整个生命周期中，对于该对象的生产始终都是一个，不曾变化。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;保证了一个类仅有一个实例，并提供一个访问它的全局访问点。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;作用：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;在要求线程安全的情况下，保证了类实例的唯一性，线程安全。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;在不需要多实例存在时，保证了类实例的单一性。不浪费内存。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;特点：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;公有的方法获取实例，&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;私有的构造方法，&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;私有的成员变量。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;一，饿汉式&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;* @Description 饿汉式单例&lt;/span&gt;&lt;br/&gt;&lt;span&gt;     * 饿汉式单例关键在于singleton作为类变量并且直接得到了初始化，即类中所有的变量都会被初始化&lt;/span&gt;&lt;br/&gt;&lt;span&gt;     * singleton作为类变量在初始化的过程中会被收集进&amp;lt;clinit&amp;gt;()方法中，该方法能够百分之百的保证同步，&lt;/span&gt;&lt;br/&gt;&lt;span&gt;     * 但是因为不是懒加载，singleton被加载后可能很长一段时间不被使用，即实例所开辟的空间会存在很长时间&lt;/span&gt;&lt;br/&gt;&lt;span&gt;     * 虽然可以实现多线程的唯一实例，但无法进行懒加载；&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.liruilong.singleton;
 
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * @Author: Liruilong
 * @Date: 2019/7/20 17:55
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
 
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; final 不允许被继承&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Singleton {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 实例变量&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] bate = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[1024&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 私有的构造函数，即不允许外部 new&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Singleton(){ }&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;  &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Singleton singleton1 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Singleton();
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt;  Singleton getInstance1(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; singleton1;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;%E4%BA%8C%EF%BC%8C%E6%87%92%E6%B1%89%E5%BC%8F&quot;&gt;&lt;strong&gt;&lt;span&gt;二，懒汉式&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;* @Description 懒汉式单例模式&lt;/span&gt;&lt;br/&gt;&lt;span&gt;     * 可以保证懒加载，但是线程不安全&lt;/span&gt;&lt;br/&gt;&lt;span&gt;     * 当有两个线程访问时，不能保证单例的唯一性&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.liruilong.singleton;
 
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * @Author: Liruilong
 * @Date: 2019/7/20 17:55
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
 
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; final 不允许被继承&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Singleton {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 实例变量&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] bate = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[1024&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 私有的构造函数，即不允许外部 new&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Singleton(){ }
 &lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;  Singleton singleton =&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt;  Singleton getInstance(){
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (singleton == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                singleton &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Singleton();
            }
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; singleton;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;三，懒汉式加同步方法&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;* @Description 懒汉式+同步方法单例模式&lt;/span&gt;&lt;br/&gt;&lt;span&gt;     * 即能保证懒加载，又可以保证singleton实例的唯一性，但是synchronizeed关键字的排他性导致&lt;/span&gt;&lt;br/&gt;&lt;span&gt;     * getInstance0()方法只能在同一时间被一个线程访问。性能低下。&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.liruilong.singleton;
 
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * @Author: Liruilong
 * @Date: 2019/7/20 17:55
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
 
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; final 不允许被继承&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Singleton {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 实例变量&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] bate = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[1024&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 私有的构造函数，即不允许外部 new&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Singleton(){ }
&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;  Singleton singleton =&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; Singleton getInstance0(){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (singleton == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            singleton &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Singleton();
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; singleton;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;四，双重效验锁单例&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;* @Description 双重校验锁单例(Double-Check)+Volatile&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;     *  对懒汉-同步方法的改进，当有两个线程发现singleton为null时，只有一个线程可以进入到同步代码块里。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;     *  即满足了懒加载，又保证了线程的唯一性&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;     *  不加volition的缺点，有时候可能会报NPE，（JVM运行指令重排序）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;     *  有可能实例对象的变量未完成实例化其他线程去获取到singleton变量。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;     *  未完成初始化的实例调用其方法会抛出空指针异常。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.liruilong.singleton;
 
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * @Author: Liruilong
 * @Date: 2019/7/20 17:55
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
 
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; final 不允许被继承&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Singleton {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 实例变量&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] bate = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[1024&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 私有的构造函数，即不允许外部 new&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Singleton(){ }&lt;/span&gt;
 
    &lt;span&gt;private&lt;/span&gt;  &lt;span&gt;static&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; Singleton singleton2 = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Singleton getInstance4() {
 
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (singleton2 == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt; (Singleton.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;){
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (singleton2 ==&lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                    singleton2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Singleton();
                }
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; singleton2;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;五，静态内部类单例&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt; * @Description 静态内部类的单例模式&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;     * 在Singleton类初始化并不会创建Singleton实例，在静态内部类中定义了singleton实例。&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;     * 当给静态内部类被主动创建时则会创建Singleton静态变量，是最好的单例模式之一&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;   &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.liruilong.singleton;
 
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * @Author: Liruilong
 * @Date: 2019/7/20 17:55
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
 
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; final 不允许被继承&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Singleton {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 实例变量&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] bate = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[1024&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 私有的构造函数，即不允许外部 new&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Singleton(){ }&lt;/span&gt;
 
    &lt;span&gt;private&lt;/span&gt;  &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Singtetons{&lt;br/&gt;&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;  Singleton SINGLETON = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Singleton();
       &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; static {
             final Singleton SINGLETON = new Singleton();
        }&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
 
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt;  Singleton getInstance2(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Singtetons.SINGLETON;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;%E5%85%AD%EF%BC%8C%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%8D%95%E4%BE%8B%C2%A0&quot;&gt;&lt;span&gt;六，枚举类单例 &lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt; * @Description 基于枚举类线程安全&lt;/span&gt;&lt;br/&gt;&lt;span&gt;     * 枚举类型不允许被继承，同样线程安全的，且只能被实例化一次。&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.liruilong.singleton;
 
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * @Author: Liruilong
 * @Date: 2019/7/20 17:55
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
 
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; final 不允许被继承&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Singleton {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 实例变量&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] bate = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[1024&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 私有的构造函数，即不允许外部 new&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Singleton(){ }
&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; Singtetonss {
        SINGTETONSS; &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实例必须第一行，默认 public final static修饰&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Singleton singleton;
 
        Singtetonss() { &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;构造器。默认私有&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.singleton = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Singleton();
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Singleton getInstance() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; SINGTETONSS.singleton;
        }
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt;  Singleton getInstance3(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Singtetonss.getInstance();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;原本是我笔记里的，摘了出来，面试的时候看，&lt;/p&gt;


</description>
<pubDate>Mon, 27 Jan 2020 12:18:00 +0000</pubDate>
<dc:creator>意必固我</dc:creator>
<og:description>单例模式： 即在整个生命周期中，对于该对象的生产始终都是一个，不曾变化。 保证了一个类仅有一个实例，并提供一个访问它的全局访问点。 作用： 在要求线程安全的情况下，保证了类实例的唯一性，线程安全。 在</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/liruilong/p/12236742.html</dc:identifier>
</item>
</channel>
</rss>