<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>搞事情？Spring Boot今天一口气发布三个版本 - YourBatman</title>
<link>http://www.cnblogs.com/yourbatman/p/13379177.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yourbatman/p/13379177.html</guid>
<description>&lt;blockquote readability=&quot;6.3&quot;&gt;
&lt;p&gt;学无止境？本文已被 &lt;a href=&quot;https://www.yourbatman.cn&quot;&gt;&lt;strong&gt;https://www.yourbatman.cn&lt;/strong&gt;&lt;/a&gt; 收录，里面一并有Spring技术栈、MyBatis、JVM、中间件等小而美的&lt;strong&gt;专栏&lt;/strong&gt;供以免费学习。关注公众号【&lt;strong&gt;BAT的乌托邦&lt;/strong&gt;】逐个击破，深入掌握，拒绝浅尝辄止。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200725232718273.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;各位好，我是A哥(YourBatman)。今天是2020-07-25，上午我正从&lt;strong&gt;&lt;a href=&quot;https://start.spring.io&quot;&gt;https://start.spring.io&lt;/a&gt;&lt;/strong&gt;准备down一个工程下来的时候，打开页面发现默认选中的Spring Boot版本号是&lt;code&gt;2.3.2&lt;/code&gt;：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200725213616518.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;并非我刻意的去找到这个变化，而是由于我&lt;strong&gt;昨天&lt;/strong&gt; down下来的工程使用的Spring Boot版本是&lt;strong&gt;2.3.1&lt;/strong&gt;，印象还在，所以今天一下子就发现了差异。&lt;/p&gt;
&lt;p&gt;既然升级了（虽然是小版本号），那就去官方楼一眼呗。不看不知道，一看还真让发现些内容：&lt;strong&gt;Spring Boot在同一天（2020-07-25）一口气发布了三个版本，这是要搞事情啊？&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200725233253231.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;小贴士：本文所有时间若未做特殊说明，指的均是&lt;strong&gt;北京时间&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Spring Boot目前还处于&lt;strong&gt;Active&lt;/strong&gt;活跃的分支共有三个：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200725215806663.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;因此就在今天，&lt;strong&gt;同一天&lt;/strong&gt;里Spring Boot对它的这三条线做了更新：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Spring Boot 2.3.1 -&amp;gt; &lt;strong&gt;Spring Boot 2.3.2&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Spring Boot 2.2.8 -&amp;gt; &lt;strong&gt;Spring Boot 2.2.9&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Spring Boot 2.1.15 -&amp;gt; &lt;strong&gt;Spring Boot 2.1.16&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200725221151805.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;此次发版，距离上次&lt;strong&gt;正式&lt;/strong&gt;发版（不区分分支）已足足有&lt;strong&gt;44天&lt;/strong&gt;之久。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200725220629806.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;有哪些升级？&quot;&gt;有哪些升级？&lt;/h2&gt;
&lt;p&gt;参考github上的Release详情，三个分支&lt;strong&gt;都&lt;/strong&gt;有如下三方面的改进：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;🐞 修复bug&lt;/li&gt;
&lt;li&gt;📔 文档同步&lt;/li&gt;
&lt;li&gt;🔨 升级依赖&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;-修复bug&quot;&gt;🐞 修复bug&lt;/h3&gt;
&lt;p&gt;小版本号的升级，最重要的使命就是&lt;strong&gt;修复bug&lt;/strong&gt;，这是它存在的意义。针对这三个版本，各自的bug修复总数如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;2.3.2&lt;/strong&gt;：34个。遥遥领先&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;2.2.9&lt;/strong&gt;：10个。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;2.1.16&lt;/strong&gt;：1个。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;能发现规律吧，&lt;strong&gt;版本越新，bug越多&lt;/strong&gt;，这是符合常理的。另外，从小版本号里能知道：2.1.x版本都修复16次bug了，而2.3.x才第2次修复，正处于bug井喷阶段呢。所以一味的追新的话，还需谨慎哈。&lt;/p&gt;
&lt;p&gt;也许你会吐槽，Spring Boot这啥编码水平，咋这么多bug？其实非也，个数虽多（其实也还好），但每一个都是&lt;strong&gt;非严重bug&lt;/strong&gt;，影响甚微，无需大惊小怪。&lt;/p&gt;
&lt;p&gt;另外，从bug的原因上来看，不少bug是各个版本都有的共性问题。比如2.1.x版本那个唯一的bug，其它两个版本均有：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200725224007874.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;-文档同步&quot;&gt;📔 文档同步&lt;/h3&gt;
&lt;p&gt;此part用于对文档上的改变做出一些说明，比如文字描述错误、排班不正确等等。举例本次的一个修复：&lt;/p&gt;
&lt;p&gt;修复前：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200725224446430.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;修复后：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200725224517894.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;不得不说，这老外还挺较真（挺仔细）的。&lt;/p&gt;
&lt;h3 id=&quot;-升级依赖&quot;&gt;🔨 升级依赖&lt;/h3&gt;
&lt;p&gt;由于是小版本的升级，因此对应的依赖也是小版本升级。举例：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Tomcat升级到9.0.37&lt;/li&gt;
&lt;li&gt;Spring Framework升级到5.2.8（此版本4天前发布）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;值得注意的是，拿&lt;code&gt;Spring Framework&lt;/code&gt;的升级举例：Spring Boot的2.2.x和2.3.x都是升级到了5.2.8版本，而Spring Boot的2.1.x分支依赖的是&lt;code&gt;Spring Framework 5.1.17&lt;/code&gt;版本哦。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;除此之外&lt;/strong&gt;，Spring Boot它的最新版本，也就是2.3.2里还新增了3个新特性，了解一下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;改进 Kubernates Liveness/Readiness 健康指标和探针配置&lt;/li&gt;
&lt;li&gt;添加运行镜像选项用于Docker镜像构建&lt;/li&gt;
&lt;li&gt;增加对reactive Elasticsearch的健康检查&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;小贴士：小版本号的升级是可以新增这种很小的功能点的，但不允许新增大功能&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;三个版本核心依赖的区别&quot;&gt;三个版本核心依赖的区别&lt;/h2&gt;
&lt;p&gt;Spring Boot目前活跃的分支有3个，也就是这三个&lt;strong&gt;主线版本&lt;/strong&gt;。那么他们三在核心依赖上有啥区别呢？A哥特意翻资料帮你整理了一下，绘制如下表：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;说明：因为表格兼容性不太好，所以我以图片方式展示&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200725230447674.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;关于15x和20x版本&quot;&gt;关于1.5.x和2.0.x版本&lt;/h2&gt;
&lt;p&gt;这两个分支已经是古董分支了：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200725230905400.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;stale中文意思：不新鲜的，老掉牙的，没有新意的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;它们&lt;strong&gt;早已&lt;/strong&gt;寿终正寝，最后一个版本和发布时间为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1.5.22.RELEASE，2019.08&lt;/li&gt;
&lt;li&gt;2.0.9.RELEASE，2019.04&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;有意思的是，&lt;strong&gt;2.0.x&lt;/strong&gt;版本的生命周期非常的短暂，几乎刚好一年（2018.3 - 2019.4）。但是不可否认2.0.x版本是具有划时代意义的，在1.5.x的基础上垮了一大步，上了一个大台阶。&lt;/p&gt;
&lt;p&gt;所以如果你的项目还在使用这两个版本，特别是1.5.x，那么尽快升级吧。官方推荐的是使用最新的2.3.x分支，这也是当前最为活跃的分支。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;小贴士：1.5.x升级到2.x.x属于阻断式升级，需要十分谨慎&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Spring Boot作为微服务、云原生开发的基础设施，每个Java开发者都应该理解它、跟上它、学习它，才得以保证自己不掉队，不被&lt;strong&gt;后浪&lt;/strong&gt;拍死。&lt;/p&gt;
&lt;p&gt;但是，如此之快的更新速度，Spring官方是认真的，但你能认真起来吗？歪果仁，这是周末唉，你们不用休息的吗？疫情期间在家办公就这么任性？&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200725231628798.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;相关推荐：&quot;&gt;相关推荐：&lt;/h5&gt;
</description>
<pubDate>Sun, 26 Jul 2020 00:44:00 +0000</pubDate>
<dc:creator>YourBatman</dc:creator>
<og:description>你，还学得动吗？</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yourbatman/p/13379177.html</dc:identifier>
</item>
<item>
<title>使用java实现希表的基础功能 - seizedays</title>
<link>http://www.cnblogs.com/seizedays/p/13379171.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/seizedays/p/13379171.html</guid>
<description>&lt;p&gt;用java代码完成哈希表数据结构的简单实现， 以公司雇员的添加修改作为模拟实例 具体代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt; com.seizedays.hashtable;

&lt;span&gt;import&lt;/span&gt; java.util.Scanner;

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; HashTableDemo {
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) {
        &lt;span&gt;//创建一个哈希表&lt;/span&gt;
        HashTable hashTable = &lt;span&gt;new&lt;/span&gt; HashTable(7);

        String key = &quot;&quot;;
        Scanner scanner = &lt;span&gt;new&lt;/span&gt; Scanner(System.in);
        &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;) {
            System.out.println();
            System.out.println(&quot;&lt;span&gt;add: 添加雇员&lt;/span&gt;&quot;);
            System.out.println(&quot;&lt;span&gt;list: 显示雇员&lt;/span&gt;&quot;);
            System.out.println(&quot;&lt;span&gt;find: 查找雇员&lt;/span&gt;&quot;);
            System.out.println(&quot;&lt;span&gt;exit: 退出系统&lt;/span&gt;&quot;);
            key = scanner.next();

            &lt;span&gt;switch&lt;/span&gt; (key) {
                &lt;span&gt;case&lt;/span&gt; &quot;&lt;span&gt;add&lt;/span&gt;&quot;:
                    System.out.println(&quot;&lt;span&gt;输入id&lt;/span&gt;&quot;);
                    &lt;span&gt;int&lt;/span&gt; id = scanner.nextInt();
                    System.out.println(&quot;&lt;span&gt;输入名字&lt;/span&gt;&quot;);
                    String name = scanner.next();
                    Emp emp = &lt;span&gt;new&lt;/span&gt; Emp(id, name);
                    hashTable.add(emp);
                    &lt;span&gt;break&lt;/span&gt;;
                &lt;span&gt;case&lt;/span&gt; &quot;&lt;span&gt;list&lt;/span&gt;&quot;:
                    hashTable.list();
                    &lt;span&gt;break&lt;/span&gt;;

                &lt;span&gt;case&lt;/span&gt; &quot;&lt;span&gt;find&lt;/span&gt;&quot;:
                    System.out.println(&quot;&lt;span&gt;请输入雇员id&lt;/span&gt;&quot;);
                    &lt;span&gt;int&lt;/span&gt; id2 = scanner.nextInt();
                    hashTable.findEmpById(id2);
                    &lt;span&gt;break&lt;/span&gt;;

                &lt;span&gt;case&lt;/span&gt; &quot;&lt;span&gt;exit&lt;/span&gt;&quot;:
                    scanner.close();
                    System.exit(0);
                &lt;span&gt;default&lt;/span&gt;:
                    &lt;span&gt;break&lt;/span&gt;;
            }
        }


    }
}

&lt;span&gt;//雇员类&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt; Emp {
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; id;
    &lt;span&gt;public&lt;/span&gt; String name;
    &lt;span&gt;public&lt;/span&gt; Emp next; &lt;span&gt;//默认为空&lt;/span&gt;

    &lt;span&gt;public&lt;/span&gt; Emp(&lt;span&gt;int&lt;/span&gt; id, String name) {
        &lt;span&gt;super&lt;/span&gt;();
        &lt;span&gt;this&lt;/span&gt;.id = id;
        &lt;span&gt;this&lt;/span&gt;.name = name;
    }
}

&lt;span&gt;//创建Has他Table 管理链表&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt; HashTable {
    &lt;span&gt;private&lt;/span&gt; EmpLinkedList[] empLinkedListArray;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; size;

    &lt;span&gt;public&lt;/span&gt; HashTable(&lt;span&gt;int&lt;/span&gt; size) {
        &lt;span&gt;// 初始化链表&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.size = size;
        empLinkedListArray = &lt;span&gt;new&lt;/span&gt; EmpLinkedList[size];

        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; size; i++) {
            empLinkedListArray[i] = &lt;span&gt;new&lt;/span&gt; EmpLinkedList();
        }
    }

    &lt;span&gt;//添加新员工&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; add(Emp emp) {
        &lt;span&gt;//根据员工的id 得到该员工应该添加到哪个链表&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; empLinkListNo = hashFun(emp.id);

        &lt;span&gt;//将Emp添加到对应的链表中&lt;/span&gt;
        empLinkedListArray[empLinkListNo].add(emp);

    }
    &lt;span&gt;//编写一个散列函数 使用一个简单的取模法来处理&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; hashFun(&lt;span&gt;int&lt;/span&gt; id) {
        &lt;span&gt;return&lt;/span&gt; id % size;
    }

    &lt;span&gt;//遍历所有的链表&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; list() {
        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; size; i++) {
            empLinkedListArray[i].list(i);

        }
    }

    &lt;span&gt;//根据输入的id 查找雇员&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; findEmpById(&lt;span&gt;int&lt;/span&gt; id){
        &lt;span&gt;int&lt;/span&gt; no = hashFun(id);
        Emp emp = empLinkedListArray[no].findEmpById(id);
        &lt;span&gt;if&lt;/span&gt; (emp != &lt;span&gt;null&lt;/span&gt;) {
            System.out.printf(&quot;&lt;span&gt;在第%d条链表中找到该雇员， 雇员id = %d&lt;/span&gt;&quot;, no + 1, id);
        }&lt;span&gt;else&lt;/span&gt; {
            System.out.println(&quot;&lt;span&gt;在hash表中没有找到该雇员&lt;/span&gt;&quot;);
        }
    }

}

&lt;span&gt;// 创建一个EmpLinkedList&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt; EmpLinkedList {
    &lt;span&gt;// 头指针 执行第一个Emp 因此我们的链表的head是指向第一个雇员的&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; Emp head; &lt;span&gt;//默认为空&lt;/span&gt;

    &lt;span&gt;//添加雇员 假定雇员添加到链表的最后位置&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; add(Emp emp) {
        &lt;span&gt;//如果添加的是第一个雇员&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (head == &lt;span&gt;null&lt;/span&gt;) {
            head = emp;
            &lt;span&gt;return&lt;/span&gt;;
        }
        &lt;span&gt;//如果不是第一个雇员 则使用辅助指针帮助定位到最后&lt;/span&gt;
        Emp curEmp = head;
        &lt;span&gt;while&lt;/span&gt; (curEmp.next != &lt;span&gt;null&lt;/span&gt;) {
            curEmp = curEmp.next;
        }

        &lt;span&gt;//退出时 直接将Emp加入链表&lt;/span&gt;
        curEmp.next = emp;

    }

    &lt;span&gt;//遍历链表的雇员信息&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; list(&lt;span&gt;int&lt;/span&gt; no) {
        &lt;span&gt;if&lt;/span&gt; (head == &lt;span&gt;null&lt;/span&gt;) {
            System.out.printf(&quot;&lt;span&gt;\n第&lt;/span&gt;&quot; + (no + 1) + &quot;&lt;span&gt;个链表为空&lt;/span&gt;&quot;);
            &lt;span&gt;return&lt;/span&gt;;
        }
        System.out.print(&quot;&lt;span&gt;\n第&lt;/span&gt;&quot; + (no + 1) + &quot;&lt;span&gt;个链表信息为:&lt;/span&gt;&quot;);
        Emp curEmp = head;
        &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;) {
            System.out.printf(&quot;&lt;span&gt;=&amp;gt; id = %d name = %s \t&lt;/span&gt;&quot;, curEmp.id, curEmp.name);
            &lt;span&gt;if&lt;/span&gt; (curEmp.next == &lt;span&gt;null&lt;/span&gt;) {
                &lt;span&gt;break&lt;/span&gt;;
            }
            curEmp = curEmp.next;
        }
    }

    &lt;span&gt;//根据id查找雇员&lt;/span&gt;
    &lt;span&gt;// 查找到 则返回Emp  没有找到 返回null&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; Emp findEmpById(&lt;span&gt;int&lt;/span&gt; id){
        &lt;span&gt;if&lt;/span&gt; (head == &lt;span&gt;null&lt;/span&gt;) {
            System.out.println(&quot;&lt;span&gt;链表为空&lt;/span&gt;&quot;);
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;
        }

        Emp curEmp = head;
        &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;){
            &lt;span&gt;if&lt;/span&gt; (curEmp.id == id){
                &lt;span&gt;break&lt;/span&gt;;
            }

            &lt;span&gt;if&lt;/span&gt; (curEmp.next == &lt;span&gt;null&lt;/span&gt;) {
                curEmp = &lt;span&gt;null&lt;/span&gt;;
                &lt;span&gt;break&lt;/span&gt;;
            }
            curEmp = curEmp.next;
        }

        &lt;span&gt;return&lt;/span&gt; curEmp;
    }

}

&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Sun, 26 Jul 2020 00:42:00 +0000</pubDate>
<dc:creator>seizedays</dc:creator>
<og:description>用java代码完成哈希表数据结构的简单实现， 以公司雇员的添加修改作为模拟实例 具体代码如下：package com.seizedays.hashtable; import java.util.Sca</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/seizedays/p/13379171.html</dc:identifier>
</item>
<item>
<title>LevelDB，你好~ - 一纸微言</title>
<link>http://www.cnblogs.com/yizhiweiyan/p/13378783.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yizhiweiyan/p/13378783.html</guid>
<description>&lt;p&gt;LevelDB存储文件有哪些？底层日志格式是怎么实现的？SSTable又是啥格式？小伙伴们，你们不好奇吗？好奇就赶快来瞅一眼，非常详细呦~&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;384.70570942998&quot;&gt;

&lt;p&gt;上篇文章&lt;a href=&quot;https://www.cnblogs.com/yizhiweiyan/p/13303056.html&quot;&gt;初识：LevelDB&lt;/a&gt;介绍了啥是LevelDB，LevelDB有啥特性，以及Linux环境下编译，使用及调试方法。&lt;/p&gt;
&lt;p&gt;这篇文章的话，算是LevelDB源码学习的开端吧，主要讲下LevelDB的源码结构及LevelDB官方给出一些帮助文档内容，对于我个人来说，我感觉搞懂一门技术，不能直接陷到最层源码实现，而是先了解其设计原理，然后对照学习底层源码时才不会头昏脑胀~&lt;/p&gt;
&lt;h2 id=&quot;leveldb源码结构&quot;&gt;LevelDB源码结构&lt;/h2&gt;
&lt;p&gt;LevelDB源码下载地址：&lt;a href=&quot;https://github.com/google/leveldb.git%E3%80%82&quot;&gt;https://github.com/google/leveldb.git。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2065693/202007/2065693-20200725232111616-1813663539.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;leveldb-1.22
        - cmake 
        - db  LevelDB底层核心代码目录，诸如跳表，版本，MemTable等实现都在该目录下
        - doc LevelDB的帮助文档
        - helpers 
        - include LevelDB使用时需要引入的头文件
        - issues 
        - port LevelDB底层是接入不同的文件系统的，这个目录主要是为了配置不同的文件系统平台的
        - table LevelDB底层MemTable相关的诸如合并，遍历，布隆过滤器等相关实现源码
        - util LevelDB底层实现中的一些工具类，例如hash，status等
        - ...
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面对LevelDB源码的目录结构做了基本介绍，源码嘛，先不着急看，我们先来看看LevelDB官方给出了哪些帮助文档。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;doc&lt;/code&gt;目录下是LevelDB提供给我们的一些帮助文档，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2065693/202007/2065693-20200725232131485-341150498.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;leveldb-1.22
        - doc
                - bench
                - benchmark.html # 这两个文件呢，是LevelDB与SQLite等KV存储的性能对比，有兴趣的自己去看吧
                - impl.md # 这个文件主要讲LevelDB底层实现原理，磁盘上存储的文件及大合并设计原理等
                - index.md # 这个文件主要讲LevelDB基本API的使用方法
                - log_format.md # 这个文件主要讲LevelDB的日志文件格式
                - table_format.md # 这个文件主要讲LevelDB底层排序表的格式
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来四部分内容依次对应&lt;code&gt;doc&lt;/code&gt;目录中后四部分，第一部分性能对比有兴趣自己看吧~&lt;/p&gt;
&lt;h2 id=&quot;leveldb实现原理&quot;&gt;LevelDB实现原理&lt;/h2&gt;
&lt;p&gt;​ LevelDB基本上是高度复刻了BigTable中的Tablet的，具体Tablet是啥样子，可以参考&lt;a href=&quot;https://www.cnblogs.com/yizhiweiyan/p/13246558.html&quot;&gt;初识：BigTable&lt;/a&gt;，里面挺详细的，不清楚的小伙伴可以先去看下这篇文章。&lt;/p&gt;
&lt;p&gt;​ 尽管LevelDB高度复刻了Tablet的设计，然而，在底层文件组织中，还是与Tablet存在一些不同的。&lt;/p&gt;
&lt;p&gt;​ 对于数据库管理系统来说，每个数据库最终都是与某个目录下的一组文件对应的，对于LevelDB来说，每个数据库文件目录下的文件大致分为日志(Log)文件，排序表(Sorted Table)文件，Manifest文件，Current文件等等。&lt;/p&gt;
&lt;h3 id=&quot;日志log文件&quot;&gt;日志(Log)文件&lt;/h3&gt;
&lt;p&gt;日志(Log)文件中存储一系列顺序的更新操作，每次更新操作都会被追加到当前日志文件中。&lt;/p&gt;
&lt;p&gt;当日志文件大小达到预定的大小(默认配置为4MB)时，日志文件会被转换为排序表(Sorted Table)，同时创建新的日志文件，后续的更新操作会追加到新的日志文件中。&lt;/p&gt;
&lt;p&gt;当前日志(Log)文件的拷贝会在内存中以跳表的数据结构形式(称为MemTable)保存，每次读取操作都会先查询该内存中的MemTable，以便所有的读操作都拿到的是最新更新的数据。&lt;/p&gt;
&lt;h3 id=&quot;排序表sorted-table&quot;&gt;排序表(Sorted Table)&lt;/h3&gt;
&lt;p&gt;LevelDB中，每个排序表都存储一组按Key排序的KV键值对。每个键值对中要么存储的是Key的Value，要么存储的是Key的删除标记(删除标记主要用来隐藏之前旧的排序表中的过期Key)。&lt;/p&gt;
&lt;p&gt;排序表(Sorted Tables)以一系列层级(Level)形式组织，由日志(Log)生成的排序表(Sorted Table)会被放在一个特殊的&lt;strong&gt;年轻(young)&lt;/strong&gt;层级(&lt;strong&gt;Level 0&lt;/strong&gt;)，&lt;strong&gt;年轻(young)&lt;/strong&gt;层级的文件数量超过某个阈值(&lt;strong&gt;默认为4个&lt;/strong&gt;)时，所有&lt;strong&gt;年轻(young)&lt;/strong&gt;层级的文件与&lt;strong&gt;Level 1层级&lt;/strong&gt;重叠的所有文件合并在一起，生成一系列新的&lt;strong&gt;Level 1层级&lt;/strong&gt;文件(默认情况下，我们将每2MB的数据生成一个新的&lt;strong&gt;Level 1&lt;/strong&gt;层级的文件)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;年轻层级(Level 0)&lt;/strong&gt;的文件可能存在重叠的Key，但是，其他级别的每个文件的Key范围都是非重叠的。&lt;/p&gt;
&lt;p&gt;对于&lt;strong&gt;Level L(L&amp;gt;=1)&lt;/strong&gt;层级的文件，当&lt;strong&gt;L层级&lt;/strong&gt;的合并文件大小超过&lt;strong&gt;10^LMB(即Level为10MB, Level2为100MB...&lt;/strong&gt;时进行合并。&lt;/p&gt;
&lt;p&gt;将&lt;strong&gt;Level L&lt;/strong&gt;层的一个文件&lt;strong&gt;file{L}&lt;/strong&gt;与&lt;strong&gt;Level L+1&lt;/strong&gt;层中所有与文件&lt;strong&gt;file{L}&lt;/strong&gt;存在冲得的文件合并为&lt;strong&gt;Level L+1&lt;/strong&gt;层级的一组新文件，这些&lt;strong&gt;合并过程&lt;/strong&gt;会组件将最近的&lt;strong&gt;key&lt;/strong&gt;更新操作与层级最高的文件通过批量读写的方式进行，优点在于，这种方式可以最大程度地减少昂贵的磁盘寻道操作。&lt;/p&gt;
&lt;h3 id=&quot;清单列表manifest文件&quot;&gt;清单/列表(Manifest)文件&lt;/h3&gt;
&lt;p&gt;单词&lt;code&gt;Manifest&lt;/code&gt;本意是指&lt;strong&gt;清单，文件列表&lt;/strong&gt;的意思，这里指的是每个Level中包含哪些排序表文件清单。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Manifest&lt;/strong&gt;文件会列出当前LevelDB数据库中每个&lt;strong&gt;Level&lt;/strong&gt;包含哪些&lt;strong&gt;排序表(Sorted Table)&lt;/strong&gt;，以及每个&lt;strong&gt;排序表&lt;/strong&gt;文件包含的Key的范围以及其他重要的元数据。&lt;/p&gt;
&lt;p&gt;只要重新打开LevelDB数据库，就回自动重新创建一个新的Manifest文件(文件名后缀使用新的编号)。&lt;/p&gt;
&lt;p&gt;注意：&lt;strong&gt;Manifest&lt;/strong&gt;会被格式化为log文件，LevelDB底层文件发生改变(添加/新建文件)时会自动追加到该log中。&lt;/p&gt;
&lt;h3 id=&quot;当前current文件&quot;&gt;当前(Current)文件&lt;/h3&gt;
&lt;p&gt;当前(&lt;strong&gt;CURRENT&lt;/strong&gt;)文件是一个文本文件，改文件中只有一个文件名(最近生成的&lt;strong&gt;Manifest&lt;/strong&gt;的文件名)。&lt;/p&gt;
&lt;h3 id=&quot;info-logs文件&quot;&gt;Info Logs文件&lt;/h3&gt;
&lt;p&gt;Informational messages are printed to files named LOG and LOG.old.&lt;/p&gt;
&lt;h3 id=&quot;其他文件&quot;&gt;其他文件&lt;/h3&gt;
&lt;p&gt;在某些特定场景下，LevelDB也会创建一些特定的文件(例如，LOCK, *.dbtmp等)。&lt;/p&gt;
&lt;h3 id=&quot;level-0层级&quot;&gt;Level 0层级&lt;/h3&gt;
&lt;p&gt;当日志(Log)文件大小增加到特定值(默认为4MB)时，LevelDB会创建新的MemTable和日志(Log)文件，并且后续用户写入的数据及更新操作都会直接写到新的MemTable和Log中。&lt;/p&gt;
&lt;p&gt;后台主要完成的工作：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;将之前内存中的MemTable写入到SSTable中&lt;/li&gt;
&lt;li&gt;丢弃掉旧的MemTable&lt;/li&gt;
&lt;li&gt;删除旧的日志(Log)文件和MemTable&lt;/li&gt;
&lt;li&gt;添加新的SSTable到&lt;strong&gt;年轻(Level 0)层级&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;合并基本原理&quot;&gt;合并基本原理&lt;/h3&gt;
&lt;p&gt;当&lt;strong&gt;Level L&lt;/strong&gt;层级的大小超过限制时，LevelDB会在后台进行大合并。&lt;/p&gt;
&lt;p&gt;大合并会从&lt;strong&gt;Level L&lt;/strong&gt;选择一个文件&lt;strong&gt;file{L}&lt;/strong&gt;，假设文件&lt;strong&gt;file{L}&lt;/strong&gt;的key范围为&lt;strong&gt;[keyMin, keyMax]&lt;/strong&gt;，LevelDB会从&lt;strong&gt;Level L+1&lt;/strong&gt;层级选择在文件&lt;strong&gt;file{L}&lt;/strong&gt;的key范围内的所有文件&lt;strong&gt;files{L+1}&lt;/strong&gt;与文件&lt;strong&gt;file{L}&lt;/strong&gt;进行合并。&lt;/p&gt;
&lt;p&gt;注意：如果&lt;strong&gt;Level L&lt;/strong&gt;层级中文件&lt;strong&gt;file{L}&lt;/strong&gt;仅仅与&lt;strong&gt;Level L+1&lt;/strong&gt;层中某个文件的一部分key范围重叠，则需要将&lt;strong&gt;L+1&lt;/strong&gt;层级中的整个文件作为合并的输入文件之一进行合并，并在合并之后丢弃该文件。&lt;/p&gt;
&lt;p&gt;注意：&lt;strong&gt;Level 0&lt;/strong&gt;层级是特殊的，原因在于，&lt;strong&gt;Level 0&lt;/strong&gt;层级中的不同文件的范围可能是重叠的，这种场景下，如果&lt;strong&gt;0&lt;/strong&gt;层级的文件需要合并时，则需要选择多个文件，以避免出现部分文件重叠的问题。&lt;/p&gt;
&lt;p&gt;大合并操作会对前面选择的所有文件进行合并，并生成一系列&lt;strong&gt;L+1&lt;/strong&gt;层级的文件，当输出的文件达到指定大小(默认大小为2MB)时，会切换到新的&lt;strong&gt;L+1&lt;/strong&gt;层级的文件中；另外，当当前输出文件的key范围可以覆盖到&lt;strong&gt;L+2&lt;/strong&gt;层级中10个以上的文件时，也会自动切换到新的文件中；最后这条规则可以确保以后在压缩&lt;strong&gt;L+1&lt;/strong&gt;层级的文件时不会从&lt;strong&gt;L+2&lt;/strong&gt;层级中选择过多的文件，避免一次大合并的数据量过大。&lt;/p&gt;
&lt;p&gt;大合并结束后，旧的文件(&lt;strong&gt;排序表SSTable&lt;/strong&gt;)会被丢弃掉，新文件则会继续对外提供服务。&lt;/p&gt;
&lt;p&gt;其实，LevelDB自己有一个版本控制系统，即使在合并过程中，也可以正常对外提供服务的。&lt;/p&gt;
&lt;p&gt;特定特定层级的大合并过程会在该层级key范围内进行轮转，更直白点说，就是针对每个层级，会自动记录该层级最后一次压缩时最大的key值，下次该层级压缩时，会选择该key之后的第一个文件进行压缩，如果没有这样的文件，则自动回到该层级的key最小的文件进行压缩，压缩在该层级是轮转的，而不是总是选第一个文件。&lt;/p&gt;
&lt;p&gt;对于制定key，大合并时会删除覆盖的值；如果当前合并的层级中，该key存在删除标记，如果在更高的层级中不存在该key，则同时会删除该key及该key的删除标记，相当于该key从数据库中彻底删除了！！！&lt;/p&gt;
&lt;h3 id=&quot;合并耗时分析&quot;&gt;合并耗时分析&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Level 0&lt;/strong&gt;层级合并时，最多读取该层级所有文件(默认4个，每个1MB)，最多读取&lt;strong&gt;Level 1&lt;/strong&gt;层级所有文件(默认10个，每个大小约1MB)，则对于&lt;strong&gt;Level 0&lt;/strong&gt;层级合并来说，最多读取14MB，写入14MB。&lt;/p&gt;
&lt;p&gt;除了特殊的&lt;strong&gt;Level 0&lt;/strong&gt;层级大合并之外，其余的大合并会从&lt;strong&gt;L&lt;/strong&gt;层级选择一个2MB的文件，最坏的情况下，需要从&lt;strong&gt;L+1&lt;/strong&gt;层级中选择12个文件(选择10个文件是因为&lt;strong&gt;L+1&lt;/strong&gt;层级文件总大小约是&lt;strong&gt;L&lt;/strong&gt;层的10倍，另外两个文件则是边界范围，因为层级&lt;strong&gt;L&lt;/strong&gt;的文件中key范围通常不会与层级&lt;strong&gt;L+1&lt;/strong&gt;的对齐)，总的来说，这些大合并最多读取26MB，写入26MB。&lt;/p&gt;
&lt;p&gt;假设磁盘IO速率为100MB(现代磁盘驱动器的大致范围)，最差的场景下，一次大合并需要约0.5秒。&lt;/p&gt;
&lt;p&gt;假设我们将后台磁盘写入速度限制在较小的范围内，比如10MB/s，则大合并大约需要5秒，假设用户以10MB/s的速度写入，则我们可能会建立大量的&lt;strong&gt;Level 0&lt;/strong&gt;级文件(约50个来容纳5*10MB文件)，由于每次读取时需要合并更多的文件，则数据读取成本会大大增加。&lt;/p&gt;
&lt;p&gt;解决方案一：为了解决这个问题，在&lt;strong&gt;Level 0&lt;/strong&gt;级文件数量过多时，考虑增加&lt;strong&gt;Log&lt;/strong&gt;文件切换阈值，这个解决方案的缺点在于，日志(Log)文件阈值越大，保存相应MemTable所需的内存就越大。&lt;/p&gt;
&lt;p&gt;解决方案二：当&lt;strong&gt;Level 0&lt;/strong&gt;级文件数量增加时，需要人为地降低写入速度。&lt;/p&gt;
&lt;p&gt;解决方案三：致力于降低非常广泛的合并的成本，将大多数&lt;strong&gt;Level 0&lt;/strong&gt;级文件的数据块以不压缩的方式放在内存中即可，只需要考虑合并的迭代复杂度为O(N)即可。&lt;/p&gt;
&lt;p&gt;总的来说，方案一和方案三合起来应该就可以满足大多数场景了。&lt;/p&gt;
&lt;p&gt;LevelDB生成的文件大小是可配置的，配置更大的生成文件大小，可以减少总的文件数量，不过，这种方式可能会导致较多的突发性大合并。&lt;/p&gt;
&lt;p&gt;2011年2月4号，在ext3文件系统上进行的一个实验结果显示，单个文件目录下不同文件数量时，执行100k次文件打开平均耗费时间结果如下：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;目录下文件数量&lt;/th&gt;
&lt;th&gt;打开单个文件平均耗时时间&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;1000&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;10000&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;100000&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;从上面的结果来看，单个目录下，文件数量小于10000时，打开文件平均耗时差不多的，尽量控制单个目录下文件数量不要超过1w。&lt;/p&gt;
&lt;h3 id=&quot;leveldb数据库重启流程&quot;&gt;LevelDB数据库重启流程&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;读取&lt;strong&gt;CURRENT&lt;/strong&gt;文件中存储的最近提交的&lt;strong&gt;MANIFEST&lt;/strong&gt;文件名称&lt;/li&gt;
&lt;li&gt;读取&lt;strong&gt;MANIFEST&lt;/strong&gt;文件&lt;/li&gt;
&lt;li&gt;清理过期文件&lt;/li&gt;
&lt;li&gt;这一步可以打开所有SSTable，不过，最好使用懒加载，避免内存占用过高&lt;/li&gt;
&lt;li&gt;将日志文件转换为&lt;strong&gt;Level 0&lt;/strong&gt;级的SSTable&lt;/li&gt;
&lt;li&gt;开始新的写入请求重定向到新的日志文件中&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;文件垃圾回收&quot;&gt;文件垃圾回收&lt;/h3&gt;
&lt;p&gt;在每次执行完大合并以及数据库恢复后，会调用&lt;code&gt;DeleteObsoleteFiles()&lt;/code&gt;方法，该方法会检索数据库，获取数据库中中所有的文件名称，自动删除所有不是CURRENT文件中的日志(Log)文件，另外，该方法也会删除所有未被某个层级引用的，且不是某个大合并待输出的日志文件。&lt;/p&gt;
&lt;h2 id=&quot;leveldb日志log格式&quot;&gt;LevelDB日志(Log)格式&lt;/h2&gt;
&lt;p&gt;LevelDB日志文件是由一系列32KB文件块(&lt;strong&gt;Block&lt;/strong&gt;)构成的，唯一例外的是日志文件中最后一个Block大小可能小于32KB。&lt;/p&gt;
&lt;p&gt;每个文件块(&lt;strong&gt;Block&lt;/strong&gt;)是由一系列记录(&lt;strong&gt;Record&lt;/strong&gt;)组成的，具体格式如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;block := record* trailer? // 每个Block由一系列Record组成
record :=
        checksum: uint32 // type和data[]的crc32校验码；小端模式存储
    length: uint16 // 小端模式存储
    type: uint8 // Record的类型，FULL, FIRST, MIDDLE, LAST
    data: uint8[length] 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：如果当前&lt;strong&gt;Block&lt;/strong&gt;仅剩余6字节空间，则不会存储新的Record，因为每个Record至少需要6字节存储校验及长度信息，对于这些剩余的字节，会使用全零进行填充，作为当前&lt;strong&gt;Block&lt;/strong&gt;的尾巴。&lt;/p&gt;
&lt;p&gt;注意：如果当前&lt;strong&gt;Block&lt;/strong&gt;剩余7字节，且用户追加了一个数据(&lt;code&gt;data&lt;/code&gt;)长度非零的&lt;strong&gt;Record&lt;/strong&gt;，该&lt;strong&gt;Block&lt;/strong&gt;会添加类型为&lt;strong&gt;FIRST&lt;/strong&gt;的&lt;strong&gt;Record&lt;/strong&gt;来填充剩余的7个字节，并在后续的&lt;strong&gt;Block&lt;/strong&gt;中写入用户数据。&lt;/p&gt;
&lt;h3 id=&quot;record格式详解&quot;&gt;Record格式详解&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Record&lt;/strong&gt;目前只有四种类型，分别用数字标识，后续会新增其他类型，例如，使用特定数字标识需要跳过的&lt;strong&gt;Record&lt;/strong&gt;数据。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;FULL == 1
FIRST == 2
MIDDLE == 3
LAST == 4
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;FULL&lt;/strong&gt;类型&lt;strong&gt;Record&lt;/strong&gt;标识该记录包含用户的整个数据记录。&lt;/p&gt;
&lt;p&gt;用户记录在&lt;strong&gt;Block&lt;/strong&gt;边界处存储时，为了明确记录是否被分割，使用&lt;strong&gt;FIRST&lt;/strong&gt;，&lt;strong&gt;MIDDLE&lt;/strong&gt;，&lt;strong&gt;LAST&lt;/strong&gt;进行标识。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;FIRST&lt;/strong&gt;类型&lt;strong&gt;Record&lt;/strong&gt;用来标识用户数据记录被切分的第一个&lt;strong&gt;Record&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LAST&lt;/strong&gt;类型&lt;strong&gt;Record&lt;/strong&gt;用来标识用户数据记录被切分的最后一个&lt;strong&gt;Record&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MIDDLE&lt;/strong&gt;则用来标识用户数据记录被切分的中间&lt;strong&gt;Record&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;例如，假设用户写入三条数据记录，长度分别如下：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Record 1 Length&lt;/th&gt;
&lt;th&gt;Record 2 Length&lt;/th&gt;
&lt;th&gt;Record 3 Length&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;1000&lt;/td&gt;
&lt;td&gt;97270&lt;/td&gt;
&lt;td&gt;8000&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;Record 1&lt;/strong&gt;将会以&lt;strong&gt;FULL&lt;/strong&gt;类型存储在第一个&lt;strong&gt;Block&lt;/strong&gt;中；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Record 2&lt;/strong&gt;的第一部分数据长度为31754字节以&lt;strong&gt;FIRST&lt;/strong&gt;类型存储在第一个&lt;strong&gt;Block&lt;/strong&gt;中，第二部分数据以长度为32761字节的&lt;strong&gt;MIDDLE&lt;/strong&gt;类型存储在第二个&lt;strong&gt;Block&lt;/strong&gt;中，最易一个长度为32761字节数据以&lt;strong&gt;LAST&lt;/strong&gt;类型存储在第三个&lt;strong&gt;Block&lt;/strong&gt;中；&lt;/p&gt;
&lt;p&gt;第三个&lt;strong&gt;Block&lt;/strong&gt;中剩余的7个字节以全零方式进行填充；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Record 3&lt;/strong&gt;则将以&lt;strong&gt;Full&lt;/strong&gt;类型存储在第三个&lt;strong&gt;Block&lt;/strong&gt;的开头；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2065693/202007/2065693-20200725232221243-837566907.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;block格式详解&quot;&gt;Block格式详解&lt;/h3&gt;
&lt;p&gt;上述可以说是把&lt;strong&gt;Record&lt;/strong&gt;格式的老底掀了个底掉，下面给出&lt;strong&gt;Block&lt;/strong&gt;的数据格式到底是啥样，小伙伴们不好奇嘛？赶快一起瞅一眼吧&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2065693/202007/2065693-20200725232315738-1784605042.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过上图可以清晰的看到&lt;strong&gt;Block&lt;/strong&gt;与&lt;strong&gt;Record&lt;/strong&gt;之间的关系到底是啥样？&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;LevelDB的日志文件将用户数据切分称连续的大小为32KB的Block块；&lt;/li&gt;
&lt;li&gt;每个Block由连续的Log Record构成；&lt;/li&gt;
&lt;li&gt;每个Log Record由CRC32，Length，Type，Content总共4部分构成；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;level日志格式优缺点&quot;&gt;Level日志格式优缺点&lt;/h3&gt;
&lt;p&gt;人间事，十有八九不如意；人间情，难有白头不相离。&lt;/p&gt;
&lt;p&gt;LevelDB这种日志格式也不可能完美咯，让我们一起来掰扯掰扯其优缺点吧~&lt;/p&gt;
&lt;h4 id=&quot;leveldb日志格式优点&quot;&gt;LevelDB日志格式优点&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;在日志数据重新同步时，只需要转到下一个&lt;strong&gt;Block&lt;/strong&gt;继续扫描即可，如果&lt;strong&gt;Block&lt;/strong&gt;存在有损坏，直接跳到下个&lt;strong&gt;Block&lt;/strong&gt;处理即可。&lt;/li&gt;
&lt;li&gt;当一个日志文件的部分内容作为记录嵌入到另一个日志文件中时，不需要特殊处理即可使用。&lt;/li&gt;
&lt;li&gt;对于需要在&lt;strong&gt;Block&lt;/strong&gt;边缘处进行拆分的应用程序（例如，MapReduce），处理时很简单：找到下个&lt;strong&gt;Block&lt;/strong&gt;边界并跳过非&lt;strong&gt;FIRST/FULL&lt;/strong&gt;类型记录，直到找到&lt;strong&gt;FULL&lt;/strong&gt;或&lt;strong&gt;FIRST&lt;/strong&gt;类型记录为止。&lt;/li&gt;
&lt;li&gt;对于较大的记录，不需要额外的缓冲区即可处理。&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;leveldb日志格式缺点&quot;&gt;LevelDB日志格式缺点&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;对于小的&lt;strong&gt;Record&lt;/strong&gt;数据没有进行打包处理，不过，这个问题可以通过添加&lt;strong&gt;Record&lt;/strong&gt;类型进行处理。&lt;/li&gt;
&lt;li&gt;数据没有进行压缩，不过，这个问题同样可以通过添加&lt;strong&gt;Record&lt;/strong&gt;类型进行处理。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;额(⊙o⊙)…看起来，好像没有啥缺点，O(∩_∩)O哈哈~&lt;/p&gt;
&lt;p&gt;个人感觉哈，对于日志来说，LevelDB的这种格式问题不大，毕竟，日志(例如，WAL)等通常存在磁盘上，一般情况下，也会做定期清理，对系统来说，压力不会太大，也还行，问题不大。&lt;/p&gt;
&lt;h2 id=&quot;leveldb-table-format&quot;&gt;LevelDB Table Format&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;SSTable&lt;/strong&gt;全称&lt;code&gt;Sorted String Table&lt;/code&gt;，是BigTable，LevelDB及其衍生KV存储系统的底层数据存储格式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SSTable&lt;/strong&gt;存储一系列有序的Key/Value键值对，Key/Value是任意长度的字符串。Key/Value键值对根据给定的比较规则写入文件，文件内部由一系列&lt;strong&gt;DataBlock&lt;/strong&gt;构成，默认情况下，每个&lt;strong&gt;DataBlock&lt;/strong&gt;大小为4KB，通常会配置为64KB，同时，SSTable存储会必要的索引信息。&lt;/p&gt;
&lt;p&gt;每个SSTable的格式大概是下面下面这个样子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;&amp;lt;beginning_of_file&amp;gt;
[data block 1]
[data block 1]
... ...
[data block N]
[meta block 1]
... ...
[meta block K] ===&amp;gt; 元数据块
[metaindex block] ===&amp;gt; 元数据索引块
[index block] ==&amp;gt; 索引块
[Footer] ===&amp;gt; (固定大小，起始位置start_offset = filesize - sizeof(Footer))
&amp;lt;end_of_file&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;SSTable&lt;/strong&gt;文件中包含文件内部指针，每个文件内部指针在LevelDB源码中称为&lt;strong&gt;BlockHandle&lt;/strong&gt;，包含以下信息：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;offset: varint64
size: varint64 # 注意，varint64是可变长64位整数，这里，暂时不详细描述该类型数据的实现方式，后续再说
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;SSTable&lt;/strong&gt;中的key/value键值对在底层文件中以有序的方式存储在一系列DataBlock中，这些DataBlock在文件开头处顺序存储，每个数据块的实现格式对应LevelDB源码中的&lt;code&gt;block_builder.cc&lt;/code&gt;文件，每个数据块可以以压缩方式存储&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DataBlock&lt;/strong&gt;后面存储了一系列元数据块(&lt;strong&gt;MetaBlock&lt;/strong&gt;)，元数据块格式化方式与&lt;strong&gt;DataBlock&lt;/strong&gt;一致&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;MetaIndex&lt;/strong&gt;索引块(MetaBlockIndex)，该索引块中每项对应一个元数据块的信息，包括元数据块名称及元数据块在文件中的存储位置信息(即前面提到的&lt;strong&gt;BlockHandle&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DataIndex&lt;/strong&gt;索引块(DataBlockIndex)，该索引块中每项(&lt;strong&gt;Entry&lt;/strong&gt;)对应一个数据块信息，每项信息中包含一个大于等于&lt;strong&gt;DataBlock&lt;/strong&gt;中最大的Key且小于后续&lt;strong&gt;DataBlock&lt;/strong&gt;中第一个Key的字符串以及该&lt;strong&gt;DataBlock&lt;/strong&gt;的&lt;strong&gt;BlockHandle&lt;/strong&gt;信息&lt;/li&gt;
&lt;li&gt;每个&lt;strong&gt;SSTable&lt;/strong&gt;文件的尾部都是一个固定大小的&lt;strong&gt;Footer&lt;/strong&gt;，该&lt;strong&gt;Footer&lt;/strong&gt;包含&lt;strong&gt;MetaBlockIndex&lt;/strong&gt;及&lt;strong&gt;DataBlockIndex&lt;/strong&gt;的&lt;strong&gt;BlockHandle&lt;/strong&gt;信息以及尾部魔数，中间空余字节使用全零字节进行填充&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Footer&lt;/strong&gt;的格式大概是下面这个样子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;metaindex_handle: char[p]; // MetaDataIndex的BlockHanlde信息
index_handle: char[q]; // DataBlockIndex的BlockHandle信息
padding: char[40-q-p]; // 全零字节填充
                                           // (40==2*BlockHandle::kMaxEncodedLength)
magic: fixed64; // == 0xdb4775248b80fb57 (little-endian)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：metaindex_handle和index_handle最大占用空间为40字节，本质上就是varint64最大占用字节导致，后续，抽时间将varint64时再给大家好好掰扯掰扯~&lt;/p&gt;
&lt;h3 id=&quot;sstable格式图文详解&quot;&gt;SSTable格式图文详解&lt;/h3&gt;
&lt;p&gt;上面全是文字描述，有点不是特别好懂，这里呢，给大家看下我画的一张图，可以说是非常的清晰明了~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2065693/202007/2065693-20200725232344696-1398703625.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每个SSTable文件包含多个DataBlock，多个MetaBlock，一个MetaBlockIndex，一个DataBlockIndex，Footer。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Footer详解&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;Footer长度固定，48个字节，位于SSTable尾部；&lt;/p&gt;
&lt;p&gt;MetaBlockIndex的OffSet和Size及DataBlockIndex的OffSet和Size分别组成BlockHandle类型，用于在文件中寻址MetaBlockIndex与DataBlockIndex，为了节省磁盘空间，使用varint64编码，OffSet与Size分别最少占用1个字节，最多占用10个字节，两个BlockHandle占用的字节数量少于40时使用全零字节进行填充，最后8个字节放置SSTable魔数。&lt;/p&gt;
&lt;p&gt;例如，DataBlockIndex.offset==64, DataBlockIndex.size=216，表示DataBlockIndex位于SSTable的第64字节到第280字节。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DataBlock详解&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;每个DataBlock默认配置4KB大小，通常推荐配置64KB大小。&lt;/p&gt;
&lt;p&gt;每个DataBlock由多个RestartGroup，RestartOffSet集合及RestartOffSet总数，Type，CRC构成。&lt;/p&gt;
&lt;p&gt;每个RestartGroup由K个RestartEntry组成，K可以通过options配置，默认值为16，每16个Key/Value键值对构成一个RestartGroup；&lt;/p&gt;
&lt;p&gt;每个RestartEntry由共享字节数，非共享字节数，Value字节数，Key非共享字节数组，Value字节数组构成；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DataBlockIndex详解&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;DataBlockIndex包含DataBlock索引信息，用于快速定位到给定Key所在的DataBlock；&lt;/p&gt;
&lt;p&gt;DataBlockIndex包含Key/Value，Type，CRC校验三部分，Type标识是否使用压缩算法，CRC是Key/Value及Type的校验信息；Key的取值是大于等于其索引DataBlock的最大Key且小于下一个DataBlock的最小Key，Value是BlockHandle类型，由变长的OffSet和Size组成。&lt;/p&gt;
&lt;h3 id=&quot;两个有意思的问题&quot;&gt;两个有意思的问题&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;为什么DataBlockIndex中Key不采用其索引的DataBlock的最大Key？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;主要是为了节省存储空间，假设该Key其索引的DataBlock的最大Key是&quot;acknowledge&quot;，下一个block最小的key为&quot;apple&quot;，如果DataBlockIndex的key采用其索引block的最大key，占用长度为len(&quot;acknowledge&quot;)；采用后一种方式，key值可以为&quot;ad&quot;（&quot;acknowledge&quot; &amp;lt; &quot;ad&quot; &amp;lt; &quot;apple&quot;），长度仅为2，且检索效果是一样的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么BlockHandle的offset和size的单位是字节数而不是DataBlock？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SSTable中的DataBlock大小是不固定的，尽管option中可以指定block_size参数，但SSTable中存储数据时，并未严格按照block_size对齐，所以offset和size指的是偏移字节数和长度字节数；这与Innodb中的B+树索引block偏移有区别。主要有两个原因：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;LevelDB可以存储任意长度的key和任意长度的value(&lt;strong&gt;不同于Innodb，限制每行数据的大小为16384个字节&lt;/strong&gt;)，而同一个key/value键值对是不能跨DataBlock存储的，极端情况下，比如我们的单 个 value 就很大，已经超过了 block_size，那么这种情况，SSTable就无法进行存储了。所以，通常情况下，实际的DataBlock的大小都是要略微大于options中配置的block_size的；&lt;/li&gt;
&lt;li&gt;如果严格按照block_size对齐存储数据，必然有很多DataBlock需要通过补0的方式进行对齐，肯定会浪费存储空间；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;sstable检索逻辑&quot;&gt;SSTable检索逻辑&lt;/h3&gt;
&lt;p&gt;基于以上实现逻辑，SSTable中的每个DataBlock主要支持两种方式读取存储的Key/Value键值对：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;支持顺序读取DataBlock中所有Key/Value键值对&lt;/li&gt;
&lt;li&gt;支持给定Key定位其所在的DataBlock，从而实现提高检索效率。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;给定Key，SSTable检索流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2065693/202007/2065693-20200725232404329-698988104.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;遗留问题&quot;&gt;遗留问题&lt;/h2&gt;
&lt;p&gt;不行了，再写下去，这篇文章字数又要破万了，写不动了，下篇文章再说吧、先打个Log，暂时有些问题还没讲清楚，如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;varint64到底是怎么实现的？&lt;/li&gt;
&lt;li&gt;SSTable中的DataBlock到底是怎么回事？&lt;/li&gt;
&lt;li&gt;LevelDB提供了哪些基础的API？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上面这些问题下篇文章再说，另外，我的每篇文章都是自己亲手敲滴，图也是自己画的，不允许转载的呦，有问题请私信呦~&lt;/p&gt;
&lt;p&gt;其实，感觉LevelDB里面每个设计细节都可以好好学习学习的，欢迎各位小伙伴私信，一起讨论呀~&lt;/p&gt;
&lt;p&gt;另外，希望大家关注我的个人公众号，更多高质量的技术文章等你来&lt;strong&gt;白嫖&lt;/strong&gt;呦~~~&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2065693/202007/2065693-20200725232444473-1012420834.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Sat, 25 Jul 2020 15:28:00 +0000</pubDate>
<dc:creator>一纸微言</dc:creator>
<og:description>LevelDB存储文件有哪些？底层日志格式是怎么实现的？SSTable又是啥格式？小伙伴们，你们不好奇吗？好奇就赶快来瞅一眼，非常详细呦~</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yizhiweiyan/p/13378783.html</dc:identifier>
</item>
<item>
<title>没想到 Hash 冲突还能这么玩，你的服务中招了吗？ - 程序猿石头</title>
<link>http://www.cnblogs.com/leitang/p/13378768.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/leitang/p/13378768.html</guid>
<description>&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;背景&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实这个问题我之前也看到过，刚好在前几天，洪教授在某个群里分享的一个《一些有意思的攻击手段.pdf》，我觉得这个话题还是有不少人不清楚的，今天我就准备来“实战”一把，还请各位看官轻拍。&lt;/p&gt;
&lt;blockquote data-tool=&quot;mdnice编辑器&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;洪强宁（洪教授），爱因互动创始人兼 CTO，曾任豆瓣首席架构师，为中国 Python 用户组（CPUG）的创立者之一。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/e9ffb949-b65f-4e92-a10a-1381b989f47c.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这才是真大佬，原来洪教授在宜信的时候，就有分享过这个内容，可惜当初不知道没参加。看了之后才知道原来我上一篇的文章中讲的 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI3OTUzMzcwNw==&amp;amp;mid=2247485939&amp;amp;idx=1&amp;amp;sn=cad3cf49aa345783a93ce5d9b631ba1d&amp;amp;chksm=eb470817dc308101c95aff74fa63d530f02bef50f91ba18d4ff25b8715933a404bd03ffc8b7b&amp;amp;token=1092973705&amp;amp;lang=zh_CN#rd&quot;&gt;计时攻击（Timing Attack）&lt;/a&gt; 也是其中的内容之一。哈哈，后面有空再研究研究继续讲其他内容。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;prefix&quot;&gt;&lt;span class=&quot;content&quot;&gt;Hash 冲突&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;啥叫 Hash 冲突？我们从 Hash 表（或者散列表）讲起，我们知道在一个 hash 表的查找一个元素，期望的时间复杂度为 &lt;code&gt;O(1)&lt;/code&gt;，怎么做到的呢？其实就是 &lt;code&gt;hash()&lt;/code&gt; 函数在起作用。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;初略来讲，hash 表内部实际存储还是跟数组类似，用连续的内存空间存储元素，只要通过某种方法将将要存储的元素映射为数组的下标，即可像数组一样通过下标去读取对应的元素，这也是为什么能做到 &lt;code&gt;O(1)&lt;/code&gt; 的原因。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/0428e75d-df3e-4bab-ae9e-782746b5b128.png&quot; alt=&quot;Hash 示例&quot;/&gt;Hash 示例&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上图为例，假设是我设计的一个 hash 函数，恰好满足如下条件：&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;&lt;code&gt;hash(&quot;hello&quot;)=0&lt;/code&gt;：字符串 &quot;hello&quot; 就存储数组下标为 0 的地方；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hash(&quot;world&quot;)=2&lt;/code&gt;： &quot;world&quot; 存储数组下标为 2 的地方；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hash(&quot;tangleithu&quot;)=5&lt;/code&gt;：&quot;tangleithu&quot; 存储数组下标为 5 的地方；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/1235ce2a-3e54-440b-9360-8f5df6756d46.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前来看一切好像很完美，但这终归是假设，我不能假设这个 hash 都很完美的将不同的字符串都映射到了不同的下标处。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外来了个字符串，&lt;code&gt;hash(&quot;石头&quot;) = 2&lt;/code&gt;，怎么办？这就是所谓的 “Hash 冲突”，最常见 Hash 冲突的解决方案其实就是“开链”法，其实还有比如线性试探、平方试探等等。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类似讲解 HashMap 的文章满大街都是，一搜一大把，本文就不详述了。为了方便读者理解，就简单来个例子。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/8c9a982c-7946-42e6-b55c-85189258c978.png&quot; alt=&quot;Hash冲突开链法&quot;/&gt;Hash冲突开链法&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开链法如上图所示，我们存储元素的时候，存储形式为一个链表，当冲突的时候，就在链表末尾直接加冲突的元素。上图示例恰好运气比较差，字符串 &lt;code&gt;shitou&lt;/code&gt;，&lt;code&gt;stone&lt;/code&gt; 算出来的下标都为 2。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样一来，问题大了。原本我们期望 &lt;code&gt;O(1)&lt;/code&gt; 的时间复杂度查找元素，现在变成在链表中线性查找了，而如果这个时候插入 &lt;span class=&quot;span-inline-equation&quot;&gt;&lt;img alt=&quot;N&quot; class=&quot;Formula-image&quot; data-eeimg=&quot;true&quot;/&gt; 个数据，最坏的情况下的时间复杂度就是 &lt;span class=&quot;span-inline-equation&quot;&gt;&lt;img alt=&quot;O(N^2)&quot; class=&quot;Formula-image&quot; data-eeimg=&quot;true&quot;/&gt; 了。（这里就&lt;strong&gt;不讨论链表转树&lt;/strong&gt;的情形）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/1eeadbe9-fcb9-4410-97b0-eefbd8b875cc.png&quot; alt=&quot;坏人乘机侵入&quot;/&gt;坏人乘机侵入&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就又给坏人留下了想象空间。只要坏人精心设计一组要放进 hash 表的字符串，且让这些字符串的 hashcode 都一样，这就会导致 hash 冲突，结果会导致 cpu 要花费大量的时间来处理 hash 冲突，造成 DoS（Denial of Service）攻击。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而用 hash 表存储的情形太常见了。在 Web 服务中，一般表单的处理都是用 hash 表来保存的（后端往往要知道通过某个具体的参数 key 获取对应的参数 value）。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;prefix&quot;&gt;&lt;span class=&quot;content&quot;&gt;实战&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文石头哥将以 Java SpringBoot 为例，尝试进行一次攻击。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过别以为这种 “Hash 冲突 DoS” 以为只有 Java 才有哦，什么 Python，Apache Tomcat/Jetty，PHP 之类都会有这个问题的。其实早在 2011 年年末的时候就被大量爆出了，有的框架陆陆续续有一些改进和修复。详细情况可以看这篇文章：&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里，咱们给列举其中一个 Apatch Tomcat，来自 &lt;/p&gt;
&lt;blockquote data-tool=&quot;mdnice编辑器&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;Apache Tomcat before 5.5.35, 6.x before 6.0.35, and 7.x before 7.0.23 computes hash values for form parameters without restricting the ability to trigger hash collisions predictably, which allows remote attackers to cause a denial of service (CPU consumption) by sending many crafted parameters.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面截图来自洪教授的 PPT，但内容的具体来源不详了（尝试找了下，没找到），大家参考参考就好。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/b2d396f1-75e9-4e33-b80a-5d306a322fb0.png&quot; alt=&quot;实现 hash 冲突 DoS 攻击所须带宽&quot;/&gt;实现 hash 冲突 DoS 攻击所须带宽&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;左边表示用不同的语言（框架）实现这种攻击所需要的带宽，右边是攻击的 cpu 目标。可以看出，实施这种攻击成本其实挺低的（后文石头的试验也佐证了这一点）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/d468a655-6464-4e35-b2c2-5942130f8e39.png&quot; alt=&quot;PHP是世界上最好的语言1&quot;/&gt;PHP是世界上最好的语言1&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不得不说 “PHP 是世界上最好的编程语言”（大家别打架），还是有一定道理的，哈哈哈哈哈哈 😝（一张图还不够，再加一张）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/1516213c-0497-40d1-ab1c-837df58f2569.png&quot; alt=&quot;PHP是世界上最好的语言2&quot;/&gt;PHP是世界上最好的语言2&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的语言排序，不一定对，大家参考一下即可，不用纠结具体的准确性。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实要验证，方法当然也相对简单，只要找出产生冲突的不同字符串即可，具体语言可能不一样。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;prefix&quot;&gt;&lt;span class=&quot;content&quot;&gt;talk is cheap&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“talk is cheap”，现在跟着我来尝试进行一次攻击吧，本人用自己的笔记本进行试验（配置：MBP 13-inch，2.5 GHz Intel Core i7，16 GB 2133 MHz LPDDR3）。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先构造一把 hash 冲突的字符串，下面代码是 hash 冲突的字符串对的实例，后面的其实可以通过前面排列组合生成。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Aa&quot;.hashCode());&lt;br/&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;BB&quot;.hashCode());&lt;br/&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;BBBBBBBBBBBBBBBBBBBBBBBBAaBBBBAa&quot;.hashCode());&lt;br/&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;BBBBBBBBBBBBBBBBBBBBBBBBAaBBBBBB&quot;.hashCode());&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体生成过程本文不详述了，感兴趣可以看看 StackOverflow 上的这篇文章 &lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后我启用一个 SpringBoot（2.2.2.RELEASE） 的 Web 服务，JDK 1.8（其实用 1.7 效果更明显）。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@RequestMapping(&lt;span class=&quot;hljs-string&quot;&gt;&quot;/hash&quot;)&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public String &lt;span class=&quot;hljs-title&quot;&gt;hash&lt;span class=&quot;hljs-params&quot;&gt;(HttpServletRequest request) {&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先试水一把（如下图），看看基本功能正常，用 curl 发送请求即可，然后将 post 的字段放在文件里面（太长也只能放文件中）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/7db1afd0-f389-4ea7-b818-89c947234762.png&quot; alt=&quot;curl 实验结果&quot;/&gt;curl 实验结果&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;生成的字符串不够的话，还可以增加并发请求，可以借用类似 “Apache Benchmarking” 压测的工具发送请求，我之前也有一篇文章介绍了这个命令 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI3OTUzMzcwNw==&amp;amp;mid=2247485113&amp;amp;idx=2&amp;amp;sn=9a85da7a595cbad2960952fd47b89e0a&amp;amp;chksm=eb47075ddc308e4b9137c4e045510afcb8bb65e83a21cae6558150ca2c8be74105ce7bc22725&amp;amp;token=1092973705&amp;amp;lang=zh_CN#rd&quot;&gt;性能测试工具 - ab 简单应用&lt;/a&gt;，感兴趣的可以参考一下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/a971b5aa-ff65-4b86-a36e-6825059aaf48.png&quot; alt=&quot;冲突的 hashcode 一样&quot;/&gt;冲突的 hashcode 一样&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;打个断点看看效果，如上图所示，确实所有的 hash 值都是一样的。不过一次请求好像并没有影响我电脑 cpu 的明显变化。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我测试的字符串已经是 &lt;code&gt;29859&lt;/code&gt; 个了，正准备生成更多的冲突的字符串进行尝试时，结果仔细一看才发现请求被截断了，请求返回的参数 size 大小为 10000。原来 SpringBoot 内置的 tomcat 给做了手脚，看下图，因为默认的请求的参数个数大小被限制成 10000 了。&lt;/p&gt;
&lt;blockquote data-tool=&quot;mdnice编辑器&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;More than the maximum number of request parameters (GET plus POST) for a single request ([10,000]) were detected. Any parameters beyond this limit have been ignored. To change this limit, set the maxParameterCount attribute on the Connector.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/5f0ee44d-dfb7-467f-b745-a54ccbcfe0d5.png&quot; alt=&quot;post参数数量被限制&quot;/&gt;post参数数量被限制&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一种方法当然是去修改这个请求参数个数的限制。另外其实可以尝试用 JDK 1.7 去验证，应该效果会更好（原因，聪明的读者你肯定知道吧？）。这里石头哥就懒得去折腾了，直接尝试以量来取胜，用前文说的 ab 进行并发提交请求，然后观察效果。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是我用如下参数跑的压测结果：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;ab -c 200 -n 100000 -p req.txt &lt;span class=&quot;hljs-string&quot;&gt;'localhost:8080/hash'&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;压测的结果如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/cb709622-eb79-4324-bdb8-1fff6f205943.png&quot; alt=&quot;ab 压测 hash 冲突结果&quot;/&gt;ab 压测 hash 冲突结果&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后我们来看看 CPU 的变化情况，特意录屏做了个动图，可以看出还是相对比较明显的。从基本不占用 cpu 到 39.6%，然后突然就涨到 158% 了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际试验中这个过程没有一直持续（上面是重试过程中抓到的其中一次），一方面因为本人用的 JDK 1.8，本来冲突后的查找过程已经优化了，可能效果并不明显，另外也猜测可能会有一些 cache 之类的优化吧，另外对于 10000 的量也还不够？具体我也没有深究了，感兴趣的读者可以去尝试一下玩玩。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/c53a1f75-f9f8-4d56-979c-916a12f18d45.gif&quot; alt=&quot;hash-collision-demo动图&quot;/&gt;hash-collision-demo动图&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实验算成功了吧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/589781c0-de08-4bdc-8560-c1cd770e2502.png&quot; alt=&quot;实验成功就是拽&quot;/&gt;实验成功就是拽&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我这还是单机，要是多搞几个 client，不分分钟把 Web 服务搞死啊。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;prefix&quot;&gt;&lt;span class=&quot;content&quot;&gt;防御方法&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面实验算是成功了，那么防御方法呢？其实就是：&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;改 hash 算法算一种了；例如像有的用随机算法作为 hash 函数的情况，可以用不同的随机种子尝试生成；但其实没有完美的 hash 算法的。&lt;/li&gt;
&lt;li&gt;本文实验中的也遇到这个了，就是要限制请求的参数个数，以及请求长度。在不影响业务的情况下，限制尽可能更小；&lt;/li&gt;
&lt;li&gt;上 WAF（Web Application Firewall），用专业的防火墙清洗流量。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;prefix&quot;&gt;&lt;span class=&quot;content&quot;&gt;最后&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文只供学习交流使用，请大家不要轻易尝试线上服务，不要轻易尝试线上服务，不要轻易尝试线上服务。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本人才疏学浅，如果有不对的地方，还望大家指出。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原创真心不易，希望你能帮我个小忙呗，如果本文内容你觉得有所启发，有所收获，请帮忙点个“在看”呗（若不好意思暴露，你起码点个赞嘛😝），转发分享就更好啦，这将是我继续输出更多优质文章的最强动力。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;公众号后台回复“模拟题”获取算法笔试模拟题精解合集（也可以直接到阿里云开发者社区下载），该书籍为阿里云开发电子书系列之一，涵盖 70+算法题目，近 30 种大厂笔试常考知识点。希望在你“面试战场”上能够助你一臂之力。 &lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/2d6ed587-a82e-4c20-aa63-bd284b3e0f4f.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;blockquote data-tool=&quot;mdnice编辑器&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;关于作者：程序猿石头(ID: tangleithu)，现任阿里巴巴技术专家，清华学渣，前大疆后端 Leader。用不同的视角分享高质量技术文章，以每篇文章都让人有收获为目的，欢迎关注，交流和指导！&lt;/p&gt;
&lt;/blockquote&gt;


&lt;p&gt;oCERT-2011-003 multiple implementations denial-of-service via hash algorithm collision: &lt;em&gt;http://ocert.org/advisories/ocert-2011-003.html&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;CVE-2011-4858: &lt;em&gt;https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2011-4858&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Application vulnerability due to Non Random Hash Functions: &lt;em&gt;https://stackoverflow.com/questions/8669946/application-vulnerability-due-to-non-random-hash-functions&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Hash Collision DoS 问题: &lt;em&gt;https://coolshell.cn/articles/6424.html&lt;/em&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 25 Jul 2020 15:21:00 +0000</pubDate>
<dc:creator>程序猿石头</dc:creator>
<og:description>背景 其实这个问题我之前也看到过，刚好在前几天，洪教授在某个群里分享的一个《一些有意思的攻击手段.pdf》，我觉得这个话题还是有不少人不清楚的，今天我就准备来“实战”一把，还请各位看官轻拍。 洪强宁（</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/leitang/p/13378768.html</dc:identifier>
</item>
<item>
<title>前端程序员学好算法系列（一）数组 - 科比net</title>
<link>http://www.cnblogs.com/kbnet/p/13378754.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kbnet/p/13378754.html</guid>
<description>&lt;p&gt;前端程序员怎么才能学好算法呢？目前算法优秀的视频集中在c++，java，python，本人通过几个月专心看c++的视频掌握了算法的基本思路，都翻译成前端代码一一写出来，从真题到思维全面提升算法思维&lt;br/&gt;面对算法面试，不畏惧&lt;/p&gt;
&lt;p&gt;二分查找法O（logn）&lt;br/&gt;寻找数组中的最大/最小值O(N)&lt;br/&gt;归并排序算法 O（nlogn）&lt;br/&gt;选择排序算法O(n^2)&lt;/p&gt;
&lt;p&gt;第一题.数组 704.二分查找法&lt;/p&gt;
&lt;p&gt;给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。&lt;br/&gt;示例 1:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
输入: nums = [-&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;9&lt;/span&gt;,&lt;span&gt;12&lt;/span&gt;], target = &lt;span&gt;9&lt;/span&gt;&lt;span&gt;
输出: &lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;
解释: &lt;/span&gt;&lt;span&gt;9&lt;/span&gt; 出现在 nums 中并且下标为 &lt;span&gt;4&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;解题：&lt;/p&gt;
&lt;p&gt;1.在左边界0 和右边界arr.length -1 中进行寻找，&lt;/p&gt;
&lt;p&gt;2.每次取最中间的元素mid，如果当前寻找的元素就是当前元素直接返回，&lt;/p&gt;
&lt;p&gt;3.否则当前元素小于target左边界等于mid+1 否则右边界等于mid -1，如果没有找到返回-1&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; function binarySearch(arr,target) {
       let l &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
       let r &lt;/span&gt;= arr.length - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;
       let mid
       &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(l&amp;lt;=&lt;span&gt;r){
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; mid = Math.floor((l + r)/2) 
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 下面的代码解决l+r 整数溢出的问题&lt;/span&gt;
          mid = Math.floor(l + (r-l)/&lt;span&gt;2&lt;/span&gt;&lt;span&gt;) 
          
          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(arr[mid]===&lt;span&gt;target){
             &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; mid
          }
          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(arr[mid] &amp;lt;&lt;span&gt; target){
            l &lt;/span&gt;= mid + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;
          } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            r &lt;/span&gt;= mid - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;
          }
       }
       &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
     }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第二题283. 移动零&lt;/p&gt;
&lt;p&gt;给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。&lt;br/&gt;示例:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
输入: [&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;12&lt;/span&gt;&lt;span&gt;]
输出: [&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;12&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;说明:&lt;/p&gt;
&lt;p&gt;必须在原数组上操作，不能拷贝额外的数组。&lt;br/&gt;尽量减少操作次数。&lt;/p&gt;
&lt;p&gt;解题：&lt;/p&gt;
&lt;p&gt;1.我们定义一个k指针默认为0&lt;br/&gt;2.循环数组当数组值为0时交换数组k和当前索引的值k++&lt;br/&gt;3.如果 i!=k 这步针对特殊用力优化&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; moveZeroes =&lt;span&gt; function(nums) {
        let k &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;(let i =&lt;span&gt;0&lt;/span&gt;;i&amp;lt;nums.length;i++&lt;span&gt;){
          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(nums[i]){
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(i!=&lt;span&gt;k){
              swap(nums,k,i)
              k&lt;/span&gt;++&lt;span&gt;
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
              k&lt;/span&gt;++&lt;span&gt;
            }
          }
        }
        function swap(arr,i,j){
          let tmp &lt;/span&gt;=&lt;span&gt; arr[i]
          arr[i] &lt;/span&gt;=&lt;span&gt; arr[j]
          arr[j] &lt;/span&gt;=&lt;span&gt; tmp
        }
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第三题 27.移动元素&lt;/p&gt;
&lt;p&gt;给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。&lt;/p&gt;
&lt;p&gt;不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。&lt;/p&gt;
&lt;p&gt;元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
给定 nums = [&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;], val = &lt;span&gt;3&lt;/span&gt;&lt;span&gt;,

函数应该返回新的长度 &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;, 并且 nums 中的前两个元素均为 &lt;span&gt;2&lt;/span&gt;&lt;span&gt;。

你不需要考虑数组中超出新长度后面的元素。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;解题：此题原理与上题相同&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; removeElement =&lt;span&gt; function(nums, val) {
    let j &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
    let arr &lt;/span&gt;=&lt;span&gt;[]
     &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(let i =&lt;span&gt;0&lt;/span&gt;,len=nums.length;i&amp;lt;len;i++&lt;span&gt;){
         &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(nums[i]!==&lt;span&gt;val){ 
             nums[j] &lt;/span&gt;=&lt;span&gt; nums[i]
             j&lt;/span&gt;++&lt;span&gt;
         } 
     }
     &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; j
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第四题 75. 颜色分类&lt;/p&gt;
&lt;p&gt;给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。&lt;/p&gt;
&lt;p&gt;此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。&lt;/p&gt;
&lt;p&gt;注意:&lt;br/&gt;不能使用代码库中的排序函数来解决这道题。&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
输入: [&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]
输出: [&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;解题一&lt;br/&gt;暴力解法：&lt;br/&gt;1.本题只有三种颜色所以我们可以给统计每个元素出现的次数保存起来然后在按数量值依次排列，代码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; sortColors =&lt;span&gt; function(nums) {
    let obj &lt;/span&gt;=&lt;span&gt; {}
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(let i =&lt;span&gt;0&lt;/span&gt;;i&amp;lt;nums.length;i++&lt;span&gt;){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;obj[nums[i]]){
            obj[nums[i]] &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            obj[nums[i]] &lt;/span&gt;= obj[nums[i]] + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;
        }
    }
    let index &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt;(let i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;obj[&lt;span&gt;0&lt;/span&gt;];i++&lt;span&gt;){
        nums[index&lt;/span&gt;++] = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
    }
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(let i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;obj[&lt;span&gt;1&lt;/span&gt;];i++&lt;span&gt;){
        nums[index&lt;/span&gt;++] = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;
    }
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(let i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;obj[&lt;span&gt;2&lt;/span&gt;];i++&lt;span&gt;){
        nums[index&lt;/span&gt;++] = &lt;span&gt;2&lt;/span&gt;&lt;span&gt;
    }
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;br/&gt;解法二&lt;br/&gt;1.三路快排，定义前边界l为-1，l前面存0所在的值，后边界n为nums.length，从n开始往后的存2的值  ， i部分存1的值&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; sortColors =&lt;span&gt; function(nums) {
    let l &lt;/span&gt;= -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    let n &lt;/span&gt;=&lt;span&gt; nums.length
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(let i =&lt;span&gt;0&lt;/span&gt;;i&amp;lt;&lt;span&gt;n;){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(nums[i]==&lt;span&gt;0&lt;/span&gt;&lt;span&gt;){
            l&lt;/span&gt;++&lt;span&gt;
            swap(l,i)
            i&lt;/span&gt;++&lt;span&gt;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(nums[i]===&lt;span&gt;1&lt;/span&gt;&lt;span&gt;){
            i&lt;/span&gt;++&lt;span&gt;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            n&lt;/span&gt;--&lt;span&gt;
            swap(i,n)
        }
    }
    function swap(m,n){
       let pre &lt;/span&gt;=&lt;span&gt; nums[m]
       nums[m] &lt;/span&gt;=&lt;span&gt; nums[n]
       nums[n] &lt;/span&gt;=&lt;span&gt; pre
    }   

};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;算法数组入门占时就先写到这里&lt;/p&gt;


</description>
<pubDate>Sat, 25 Jul 2020 15:15:00 +0000</pubDate>
<dc:creator>科比net</dc:creator>
<og:description>前端程序员怎么才能学好算法呢？目前算法优秀的视频集中在c++，java，python，本人通过几个月专心看c++的视频掌握了算法的基本思路，都翻译成前端代码一一写出来，从真题到思维全面提升算法思维面对</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kbnet/p/13378754.html</dc:identifier>
</item>
<item>
<title>【Nginx】如何实现Nginx的高可用负载均衡？看完我也会了！！ - 冰河团队</title>
<link>http://www.cnblogs.com/binghe001/p/13378305.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/binghe001/p/13378305.html</guid>
<description>&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;不得不说，最近小伙伴们的学习热情是越来越高，不断向冰河提出新的想学习的技术。这不，又有小伙伴问我：冰河，你在【Nginx专题】写的文章基本上都是Nginx单机版的，能不能写一篇关于Nginx的高可用的文章呢？我：没问题，安排上！这不，就有了这篇文章！！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;keepalived-简要介绍&quot;&gt;Keepalived 简要介绍&lt;/h2&gt;
&lt;p&gt;Keepalived 是一种高性能的服务器高可用或热备解决方案， Keepalived 可以用来防止服务器单点故障的发生，通过配合 Nginx 可以实现 web 前端服务的高可用。&lt;/p&gt;
&lt;p&gt;Keepalived 以 VRRP 协议为实现基础，用 VRRP 协议来实现高可用性(HA)。 VRRP(Virtual RouterRedundancy Protocol)协议是用于实现路由器冗余的协议， VRRP 协议将两台或多台路由器设备虚拟成一个设备，对外提供虚拟路由器 IP(一个或多个)，而在路由器组内部，如果实际拥有这个对外 IP 的路由器如果工作正常的话就是 MASTER，或者是通过算法选举产生， MASTER 实现针对虚拟路由器 IP 的各种网络功能，如 ARP 请求， ICMP，以及数据的转发等；其他设备不拥有该虚拟 IP，状态是 BACKUP，除了接收 MASTER 的VRRP 状态通告信息外，不执行对外的网络功能。&lt;/p&gt;
&lt;p&gt;当主机失效时， BACKUP 将接管原先 MASTER 的网络功能。VRRP 协议使用多播数据来传输 VRRP 数据， VRRP 数据使用特殊的虚拟源 MAC 地址发送数据而不是自身网卡的 MAC 地址， VRRP 运行时只有 MASTER 路由器定时发送 VRRP 通告信息，表示 MASTER 工作正常以及虚拟路由器 IP(组)， BACKUP 只接收 VRRP 数据，不发送数据，如果一定时间内没有接收到 MASTER 的通告信息，各 BACKUP 将宣告自己成为 MASTER，发送通告信息，重新进行 MASTER 选举状态。&lt;/p&gt;
&lt;h2 id=&quot;方案规划&quot;&gt;方案规划&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200725211553575.png#pic_center&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;strong&gt;操作系统与安装软件如下：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;CentOS 6.8 x64&lt;/li&gt;
&lt;li&gt;keepalived-1.2.18.tar.gz&lt;/li&gt;
&lt;li&gt;nginx-1.19.1.tar.gz&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;安装nginx&quot;&gt;安装Nginx&lt;/h2&gt;
&lt;h3 id=&quot;1安装依赖环境&quot;&gt;1.安装依赖环境&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;yum -y install wget gcc-c++ ncurses ncurses-devel cmake make perl bison openssl openssl-devel gcc* libxml2 libxml2-devel curl-devel libjpeg* libpng* freetype* autoconf automake zlib* fiex* libxml* libmcrypt* libtool-ltdl-devel* libaio libaio-devel  bzr libtool
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;2安装openssl&quot;&gt;2.安装openssl&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;wget https://www.openssl.org/source/openssl-1.0.2s.tar.gz
tar -zxvf openssl-1.0.2s.tar.gz
cd /usr/local/src/openssl-1.0.2s
./config --prefix=/usr/local/openssl-1.0.2s
make
make install
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;3安装pcre&quot;&gt;3.安装pcre&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;wget https://ftp.pcre.org/pub/pcre/pcre-8.43.tar.gz
tar -zxvf pcre-8.43.tar.gz
cd /usr/local/src/pcre-8.43
./configure --prefix=/usr/local/pcre-8.43
make
make install
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;4安装zlib&quot;&gt;4.安装zlib&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;wget https://sourceforge.net/projects/libpng/files/zlib/1.2.11/zlib-1.2.11.tar.gz
tar -zxvf zlib-1.2.11.tar.gz
cd /usr/local/src/zlib-1.2.11
./configure --prefix=/usr/local/zlib-1.2.11
make
make
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;5下载nginx-rtmp-module&quot;&gt;5.下载nginx-rtmp-module&lt;/h3&gt;
&lt;p&gt;nginx-rtmp-module的官方github地址：&lt;a href=&quot;https://github.com/arut/nginx-rtmp-module&quot;&gt;https://github.com/arut/nginx-rtmp-module&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;git clone https://github.com/arut/nginx-rtmp-module.git  
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;6安装nginx&quot;&gt;6.安装Nginx&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;wget http://nginx.org/download/nginx-1.19.1.tar.gz
tar -zxvf nginx-1.19.1.tar.gz
cd /usr/local/src/nginx-1.19.1
./configure --prefix=/usr/local/nginx-1.19.1 --with-openssl=/usr/local/src/openssl-1.0.2s --with-pcre=/usr/local/src/pcre-8.43 --with-zlib=/usr/local/src/zlib-1.2.11 --add-module=/usr/local/src/nginx-rtmp-module --with-http_ssl_module
make
make install
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;这里需要注意的是：安装Nginx时，指定的是openssl、pcre和zlib的源码解压目录，安装完成后Nginx配置文件的完整路径为：/usr/local/nginx-1.19.1/conf/nginx.conf。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;配置nginx&quot;&gt;配置Nginx&lt;/h2&gt;
&lt;p&gt;在命令行输入如下命令编辑Nginx的nginx.conf文件，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# vim /usr/local/nginx-1.19.1/conf/nginx.conf
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;编辑后的文件内容如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;user root;
worker_processes 1;
#error_log logs/error.log;
#error_log logs/error.log notice;
#error_log logs/error.log info;
#pid logs/nginx.pid;
events {
        worker_connections 1024;
}
http {
        include mime.types;
        default_type application/octet-stream;
        #log_format main '$remote_addr - $remote_user [$time_local] &quot;$request&quot; '
        # '$status $body_bytes_sent &quot;$http_referer&quot; '
        # '&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;';
        #access_log logs/access.log main;
        sendfile on;
        #tcp_nopush on;
        #keepalive_timeout 0;
        keepalive_timeout 65;
        #gzip on;
        server {
                listen 88;
                server_name localhost;
                #charset koi8-r;
                #access_log logs/host.access.log main;
                location / {
                        root html;
                        index index.html index.htm;
                }
                #error_page 404 /404.html;
                # redirect server error pages to the static page /50x.html
                error_page 500 502 503 504 /50x.html;
                location = /50x.html {
                        root html;
                }
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改 Nginx 欢迎首页内容（用于后面测试， 用于区分两个节点的 Nginx）：&lt;/p&gt;
&lt;p&gt;在binghe133服务器上执行如下操作。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# vim /usr/local/nginx-1.19.1/html/index.html
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在文件title节点下添加如下代码。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;h1&amp;gt;Welcome to nginx! 1&amp;lt;/h1&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在binghe134服务器上执行如下操作。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# vim /usr/local/nginx-1.19.1/html/index.html
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在文件title节点下添加如下代码。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;h1&amp;gt;Welcome to nginx! 2&amp;lt;/h1&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;开放端口&quot;&gt;开放端口&lt;/h2&gt;
&lt;p&gt;在服务器的防火墙中开放88端口，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;vim /etc/sysconfig/iptables
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;添加如下配置。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;-A INPUT -m state --state NEW -m tcp -p tcp --dport 88 -j ACCEPT
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来，输入如下命令重启防火墙。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;service iptables restart
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;测试nginx&quot;&gt;测试Nginx&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;测试Nginx是否安装成功&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# /usr/local/nginx-1.19.1/sbin/nginx -t
nginx: the configuration file /usr/local/nginx-1.19.1/conf/nginx.conf syntax is ok
nginx: configuration file /usr/local/nginx-1.19.1/conf/nginx.conf test is successful
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;启动Nginx&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# /usr/local/nginx-1.19.1/sbin/nginx
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;重启 Nginx&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# /usr/local/nginx-1.19.1/sbin/nginx -s reload
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;设置Nginx开机自启动&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# vim /etc/rc.local
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;加入如下一行配置。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;/usr/local/nginx-1.19.1/sbin/nginx
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来，分别访问两台服务器上Nginx，如下所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200725211621763.png#pic_center&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200725211640990.png#pic_center&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;安装-keepalived&quot;&gt;安装 Keepalived&lt;/h2&gt;
&lt;p&gt;官方下载链接为：&lt;a href=&quot;http://www.keepalived.org/download.html&quot;&gt;http://www.keepalived.org/download.html&lt;/a&gt; 。&lt;/p&gt;
&lt;h3 id=&quot;上传或下载-keepalived&quot;&gt;上传或下载 keepalived&lt;/h3&gt;
&lt;p&gt;上传或下载 keepalived（keepalived-1.2.18.tar.gz） 到 /usr/local/src 目录&lt;/p&gt;
&lt;h3 id=&quot;解压安装&quot;&gt;解压安装&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# cd /usr/local/src
# tar -zxvf keepalived-1.2.18.tar.gz
# cd keepalived-1.2.18
# ./configure --prefix=/usr/local/keepalived
# make &amp;amp;&amp;amp; make install
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;将-keepalived-安装成-linux-系统服务&quot;&gt;将 keepalived 安装成 Linux 系统服务&lt;/h3&gt;
&lt;p&gt;因为没有使用 keepalived 的默认路径安装（默认是/usr/local） ,安装完成之后，需要做一些工作复制默认配置文件到默认路径&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# mkdir /etc/keepalived
# cp /usr/local/keepalived/etc/keepalived/keepalived.conf /etc/keepalived/
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;复制 keepalived 服务脚本到默认的地址&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# cp /usr/local/keepalived/etc/rc.d/init.d/keepalived /etc/init.d/
# cp /usr/local/keepalived/etc/sysconfig/keepalived /etc/sysconfig/
# ln -s /usr/local/sbin/keepalived /usr/sbin/
# ln -s /usr/local/keepalived/sbin/keepalived /sbin/
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;设置 keepalived 服务开机启动。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# chkconfig keepalived on
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;修改-keepalived-配置文件&quot;&gt;修改 Keepalived 配置文件&lt;/h3&gt;
&lt;h3 id=&quot;master-节点配置文件（19216850133）&quot;&gt;MASTER 节点配置文件（192.168.50.133）&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# vim /etc/keepalived/keepalived.conf

! Configuration File for keepalived
global_defs {
        ## keepalived 自带的邮件提醒需要开启 sendmail 服务。 建议用独立的监控或第三方 SMTP
        router_id binghe133 ## 标识本节点的字条串，通常为 hostname
} 
## keepalived 会定时执行脚本并对脚本执行的结果进行分析，动态调整 vrrp_instance 的优先级。如果脚本执行结果为 0，并且 weight 配置的值大于 0，则优先级相应的增加。如果脚本执行结果非 0，并且 weight配置的值小于 0，则优先级相应的减少。其他情况，维持原本配置的优先级，即配置文件中 priority 对应的值。
vrrp_script chk_nginx {
        script &quot;/etc/keepalived/nginx_check.sh&quot; ## 检测 nginx 状态的脚本路径
        interval 2 ## 检测时间间隔
        weight -20 ## 如果条件成立，权重-20
}
## 定义虚拟路由， VI_1 为虚拟路由的标示符，自己定义名称
vrrp_instance VI_1 {
        state MASTER ## 主节点为 MASTER， 对应的备份节点为 BACKUP
        interface eth0 ## 绑定虚拟 IP 的网络接口，与本机 IP 地址所在的网络接口相同， 我的是 eth0
        virtual_router_id 33 ## 虚拟路由的 ID 号， 两个节点设置必须一样， 可选 IP 最后一段使用, 相同的 VRID 为一个组，他将决定多播的 MAC 地址
        mcast_src_ip 192.168.50.133 ## 本机 IP 地址
        priority 100 ## 节点优先级， 值范围 0-254， MASTER 要比 BACKUP 高
        nopreempt ## 优先级高的设置 nopreempt 解决异常恢复后再次抢占的问题
        advert_int 1 ## 组播信息发送间隔，两个节点设置必须一样， 默认 1s
        ## 设置验证信息，两个节点必须一致
        authentication {
                auth_type PASS
                auth_pass 1111 ## 真实生产，按需求对应该过来
        }
        ## 将 track_script 块加入 instance 配置块
        track_script {
                chk_nginx ## 执行 Nginx 监控的服务
        } #
        # 虚拟 IP 池, 两个节点设置必须一样
        virtual_ipaddress {
                192.168.50.130 ## 虚拟 ip，可以定义多个
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;backup-节点配置文件（19216850134）&quot;&gt;BACKUP 节点配置文件（192.168.50.134）&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# vim /etc/keepalived/keepalived.conf

! Configuration File for keepalived
global_defs {
        router_id binghe134
}
vrrp_script chk_nginx {
        script &quot;/etc/keepalived/nginx_check.sh&quot;
        interval 2
        weight -20
}
vrrp_instance VI_1 {
        state BACKUP
        interface eth1
        virtual_router_id 33
        mcast_src_ip 192.168.50.134
        priority 90
        advert_int 1
        authentication {
                auth_type PASS
                auth_pass 1111
        }
        track_script {
                chk_nginx
        }
        virtual_ipaddress {
                192.168.50.130
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;编写-nginx-状态检测脚本&quot;&gt;编写 Nginx 状态检测脚本&lt;/h3&gt;
&lt;p&gt;编写 Nginx 状态检测脚本 /etc/keepalived/nginx_check.sh (已在 keepalived.conf 中配置)脚本要求：如果 nginx 停止运行，尝试启动，如果无法启动则杀死本机的 keepalived 进程， keepalied将虚拟 ip 绑定到 BACKUP 机器上。 内容如下。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# vim /etc/keepalived/nginx_check.sh

#!/bin/bash
A=`ps -C nginx –no-header |wc -l`
if [ $A -eq 0 ];then
/usr/local/nginx/sbin/nginx
sleep 2
if [ `ps -C nginx --no-header |wc -l` -eq 0 ];then
        killall keepalived
fi
fi
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;保存后，给脚本赋执行权限：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# chmod +x /etc/keepalived/nginx_check.sh
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;启动-keepalived&quot;&gt;启动 Keepalived&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# service keepalived start
Starting keepalived: [ OK ]
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;keepalivednginx-的高可用测试&quot;&gt;Keepalived+Nginx 的高可用测试&lt;/h2&gt;
&lt;p&gt;同时启动192.168.50.133和192.168.50.134上的Nginx和Keepalived，我们通过VIP(192.168.50.130)来访问Nginx，如下所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200725211700449.png#pic_center&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们关闭192.168.50.133上的Keepalived和Nginx，在192.168.50.133执行如下命令。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;service keepalived stop
/usr/local/nginx-1.19.1/sbin/nginx -s stop
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时，再通过VIP(192.168.50.130)来访问Nginx，如下所示。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200725211710421.png#pic_center&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们再开启192.168.50.133上的Keepalived和Nginx，在192.168.50.133执行如下命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;/usr/local/nginx-1.19.1/sbin/nginx
service keepalived start
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者只执行&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;service keepalived start
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为我们写了脚本nginx_check.sh，这个脚本会为我们自动自动Nginx。&lt;/p&gt;
&lt;p&gt;此时，我们再通过VIP(192.168.50.130)来访问Nginx，如下所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020072521172891.png#pic_center&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，Keepalived + Nginx 实现高可用 Web 负载均衡搭建完毕。&lt;/p&gt;
&lt;h2 id=&quot;温馨提示&quot;&gt;温馨提示&lt;/h2&gt;
&lt;p&gt;小伙伴们可以到下面的链接下载Keepalived + Nginx 实现高可用 Web 负载均衡的配置文件。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://download.csdn.net/detail/l1028386804/9855362&quot;&gt;http://download.csdn.net/detail/l1028386804/9855362&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;重磅福利&quot;&gt;重磅福利&lt;/h2&gt;
&lt;p&gt;关注「 &lt;strong&gt;冰河技术&lt;/strong&gt; 」微信公众号，后台回复 “设计模式” 关键字领取《深入浅出Java 23种设计模式》PDF文档。回复“Java8”关键字领取《Java8新特性教程》PDF文档。两本PDF均是由冰河原创并整理的超硬核教程，面试必备！！&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;好了，今天就聊到这儿吧！别忘了点个赞，给个在看和转发，让更多的人看到，一起学习，一起进步！！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;写在最后&quot;&gt;写在最后&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;如果你觉得冰河写的还不错，请微信搜索并关注「 &lt;strong&gt;冰河技术&lt;/strong&gt; 」微信公众号，跟冰河学习高并发、分布式、微服务、大数据、互联网和云原生技术，「 &lt;strong&gt;冰河技术&lt;/strong&gt; 」微信公众号更新了大量技术专题，每一篇技术文章干货满满！不少读者已经通过阅读「 &lt;strong&gt;冰河技术&lt;/strong&gt; 」微信公众号文章，吊打面试官，成功跳槽到大厂；也有不少读者实现了技术上的飞跃，成为公司的技术骨干！如果你也想像他们一样提升自己的能力，实现技术能力的飞跃，进大厂，升职加薪，那就关注「 &lt;strong&gt;冰河技术&lt;/strong&gt; 」微信公众号吧，每天更新超硬核技术干货，让你对如何提升技术能力不再迷茫！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200716220443647.png#pic_center&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 25 Jul 2020 13:23:00 +0000</pubDate>
<dc:creator>冰河团队</dc:creator>
<og:description>写在前面 不得不说，最近小伙伴们的学习热情是越来越高，不断向冰河提出新的想学习的技术。这不，又有小伙伴问我：冰河，你在【Nginx专题】写的文章基本上都是Nginx单机版的，能不能写一篇关于Nginx</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/binghe001/p/13378305.html</dc:identifier>
</item>
<item>
<title>通俗易懂 | 拉格朗日乘子法 - 忽逢桃林</title>
<link>http://www.cnblogs.com/PythonLearner/p/13358420.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/PythonLearner/p/13358420.html</guid>
<description>&lt;p&gt;在SVM中，将约束问题转化成非约束问题采用到了拉格朗日乘子法。这个文章就讲一下拉格朗日乘子法与KKT约束是怎么回事。本人不是数学科班出身，但是也只能硬着头皮讲一讲了。&lt;/p&gt;

&lt;p&gt;现在我们要解决这样一个问题：&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(x^2y=3\)&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;这个函数距离原点最近的距离是多少。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;先画出函数图像：&lt;br/&gt;&lt;img src=&quot;http://helloworld2020.net/wp-content/uploads/2020/07/wp_editor_md_61decd8bc847ae960c57c554417fca12.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后想求出最短距离：&lt;br/&gt;&lt;img src=&quot;http://helloworld2020.net/wp-content/uploads/2020/07/20180801104757795.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里的思路就是，做一个以原点为中心的圆形：&lt;br/&gt;&lt;img src=&quot;http://helloworld2020.net/wp-content/uploads/2020/07/20180801104757887.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不断扩大圆形的半径，直到圆与蓝色的曲线相切：&lt;br/&gt;&lt;img src=&quot;http://helloworld2020.net/wp-content/uploads/2020/07/20180801104757971.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在。第一次与&lt;span class=&quot;math inline&quot;&gt;\(x^2y=3\)&lt;/span&gt;相交的点就是距离原点最近的那个点：&lt;br/&gt;&lt;img src=&quot;http://helloworld2020.net/wp-content/uploads/2020/07/wp_editor_md_89449ed1114eb8065b98fae15a08229b.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个，圆形与曲线相切，且切线既是圆形的切线，也是曲线的相切。&lt;br/&gt;&lt;img src=&quot;http://helloworld2020.net/wp-content/uploads/2020/07/wp_editor_md_e4bad146a7b937e7ea2068618982f6dc.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这时候，这个切线的垂线其实也就是我们所说的&lt;strong&gt;梯度&lt;/strong&gt;，也叫做&lt;strong&gt;等高线的法线&lt;/strong&gt;，看下面两个图可能会好理解一些：&lt;br/&gt;&lt;img src=&quot;http://helloworld2020.net/wp-content/uploads/2020/07/wp_editor_md_c46aaf66f41e4fef138cb9006f20d493.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;http://helloworld2020.net/wp-content/uploads/2020/07/wp_editor_md_426f3fb9f7c0bd283d01add99977b48e.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么这个&lt;strong&gt;梯度&lt;/strong&gt;怎么计算呢？先看圆形&lt;span class=&quot;math inline&quot;&gt;\(f(x,y)=x^2+y^2\)&lt;/span&gt;的梯度：&lt;br/&gt;&lt;img src=&quot;http://helloworld2020.net/wp-content/uploads/2020/07/wp_editor_md_7c6f24c2fffcdc129afe03de0a5b1ee5.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再看曲线的梯度计算&lt;span class=&quot;math inline&quot;&gt;\(g(x,y)=x^2y\)&lt;/span&gt;的梯度：&lt;br/&gt;&lt;img src=&quot;http://helloworld2020.net/wp-content/uploads/2020/07/wp_editor_md_30467397351171801a7821d0a298df46.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在相切的时候，两者的梯度方向都在同一条直线上，可以称之为，&lt;strong&gt;成比例&lt;/strong&gt;，这里用比例系数&lt;span class=&quot;math inline&quot;&gt;\(\lambda\)&lt;/span&gt;来表示：&lt;br/&gt;&lt;img src=&quot;http://helloworld2020.net/wp-content/uploads/2020/07/wp_editor_md_dcad4360b54df3aaa62917e1dca7e94d.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以我们汇总一下所有的已知信息，得到下面的方程组：&lt;br/&gt;&lt;img src=&quot;http://helloworld2020.net/wp-content/uploads/2020/07/wp_editor_md_fa0bfa872daba7d7b78fd7ba7e34123e.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以求解得到：&lt;br/&gt;&lt;img src=&quot;http://helloworld2020.net/wp-content/uploads/2020/07/wp_editor_md_ead0fac4ff11b404075c330bc41531e9.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个就是拉格朗日乘子法的直观理解。&lt;/p&gt;

&lt;p&gt;我们要解决的问题：&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\min {x^2+y^2}\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(s.t. x^2y=3\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们会将约束问题通过拉格朗日乘子法转换成非约束问题：&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\min F(x,y)={x^2+y^2+\lambda(x^2y-3)}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【为什么可以这样呢？】&lt;/strong&gt;&lt;br/&gt;如果求极值，偏导数为0。先对上面的公式进行求偏导数：&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\frac{\partial F(x,y)}{\partial x}=2x+\lambda 2xy=0\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\frac{\partial F(x,y)}{\partial y}=2y+\lambda x^2=0\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这两个等式与这个等价，唯一的不同就是&lt;span class=&quot;math inline&quot;&gt;\(\lambda\)&lt;/span&gt;一个是正数一个是负数:&lt;br/&gt;&lt;img src=&quot;http://helloworld2020.net/wp-content/uploads/2020/07/wp_editor_md_cf6cb83c33ae9d35533ed9998afc808a.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然，对于&lt;span class=&quot;math inline&quot;&gt;\(x^2y-3=0\)&lt;/span&gt;这个条件，我们也可以写成&lt;span class=&quot;math inline&quot;&gt;\(\frac{\partial F(x,y,\lambda)}{\partial \lambda}\)&lt;/span&gt;，所以，可以得到这样的一个方程组：&lt;br/&gt;&lt;img src=&quot;http://helloworld2020.net/wp-content/uploads/2020/07/wp_editor_md_8987c88772be08274b468cfe79012af4.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;KKT的英文全称：Karush-Kuhn-Tucker&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;之前的拉格朗日的约束条件是等值的，&lt;strong&gt;现在可以通过KKT条件推广到不等式。因为限制条件往往是不大于，小于这样的不等式，所以KKT才是拉格朗日化约束问题为非约束问题的关键。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于不等式问题，就是有两种情况：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;可行解在g(x)&amp;lt;0；&lt;/li&gt;
&lt;li&gt;可行解在g(x)=0。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;可行解在g(x)&amp;lt;0，就表示这个约束条件并没有起到约束效果，有根没有事一个效果（下图中的左图）；可行解g(x)=0,就表示这个约束条件起到作用了，这就表示g(x)与f(x)相切，也就是下图中右边的图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://helloworld2020.net/wp-content/uploads/2020/07/wp_editor_md_89362dde7ad142d88a7566606386ab3b.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【g(x)&amp;lt;0的情况】&lt;/strong&gt;&lt;br/&gt;这种情况下，就是没有限制条件下的情况，其实就是没有约束条件的限制，也就是&lt;span class=&quot;math inline&quot;&gt;\(\lambda=0\)&lt;/span&gt;的情况，所以我们的等式就是直接求解：&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\Delta f(x)=0\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【g(x)=0的情况】&lt;/strong&gt;&lt;br/&gt;如果是g(x)=0的情况，那也就是约束条件起到作用了，也就意味着&lt;span class=&quot;math inline&quot;&gt;\(\lambda&amp;gt;0\)&lt;/span&gt;。在这种情况下，存在着:&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\Delta f(x) = -\lambda \Delta g(x)\)&lt;/span&gt;&lt;br/&gt;并且两个函数的扩张的方向相反，所以表明两个g(x)和f(x)的梯度一个是正数，一个是负数。所以这个表示&lt;span class=&quot;math inline&quot;&gt;\(\lambda&amp;gt;0\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;所以综上所述，在这种情况下，我们所有的条件综合起来可以得到，其中&lt;span class=&quot;math inline&quot;&gt;\(x^\*\)&lt;/span&gt;就是最优解：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(\lambda &amp;gt;=0\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(\lambda g(x^*)=0\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;$ g(x^*) &amp;lt;= 0$&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这三个就是KKT条件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cDovL2hlbGxvd29ybGQyMDIwLm5ldC93cC1jb250ZW50L3VwbG9hZHMvMjAyMC8wNy8lRTklQkIlOTglRTglQUUlQTQlRTYlQTAlODclRTklQTIlOThfJUU1JThBJUE4JUU2JTgwJTgxJUU1JTg4JTg2JUU1JTg5JUIyJUU3JUJBJUJGXzIwMjAtMDctMjAtMC5naWY&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cDovL2hlbGxvd29ybGQyMDIwLm5ldC93cC1jb250ZW50L3VwbG9hZHMvMjAyMC8wNy93cF9lZGl0b3JfbWRfMzEyZGQyZDliYmNmZmNiZDk0Y2YwODlkYTE4YzVjNGEuanBn?x-oss-process=image/format,png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cDovL2hlbGxvd29ybGQyMDIwLm5ldC93cC1jb250ZW50L3VwbG9hZHMvMjAyMC8wNy8lRTklQkIlOTglRTglQUUlQTQlRTYlOTYlODclRTQlQkIlQjYxNTk1MjUxNjIxMTEyLnBuZw?x-oss-process=image/format,png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 25 Jul 2020 12:45:00 +0000</pubDate>
<dc:creator>忽逢桃林</dc:creator>
<og:description>在SVM中，将约束问题转化成非约束问题采用到了拉格朗日乘子法。这个文章就讲一下拉格朗日乘子法与KKT约束是怎么回事。本人不是数学科班出身，但是也只能硬着头皮讲一讲了。 从零理解 现在我们要解决这样一个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/PythonLearner/p/13358420.html</dc:identifier>
</item>
<item>
<title>花了一个月的时间在一个oj网站只刷了这些题，从此入门了绝大多数算法 - 玄之不玄</title>
<link>http://www.cnblogs.com/wbcdmn/p/13377914.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wbcdmn/p/13377914.html</guid>
<description>&lt;p&gt;如果你想入门算法，那么我这篇文章也许可以帮到你。&lt;br/&gt;oj网站有这么多，当然还有其他的。我当初是在hdu上面刷的，不要问我为什么，问就是当时我也是一个新手，懵懵懂懂就刷起来了。点这里可以进入这个网站https://vjudge.net/&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/7/25/17385b60f0f423b4?w=720&amp;amp;h=583&amp;amp;f=png&amp;amp;s=460952&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;我只在hdu上刷其他的没刷过。让我建议的话也是建议你刷hdu，差不多真的。&lt;/p&gt;
&lt;p&gt;先给大家看一下我oj网站上的记录，这是杭电刷题网站，我不是杭电的，我是一个非常非常普通的本科生。链接在这http://acm.hdu.edu.cn/&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/7/25/17385b655286535b?w=720&amp;amp;h=248&amp;amp;f=png&amp;amp;s=143358&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;很水的数据提交错误(WA)的次数太多，但我确确实实是凭借它比大多数人都快速的入门了算法。这里题目不多而且很多是水题，刷水题也有不少好处能让你在学算法题的路上没那么枯燥。 大概有哪些算法呢？这里列出一些我当时做的题（有些不在上面）。题目都是非常非常基础的题目属于入门级别的基本上没有什么变形，可以说相当于模板了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/7/25/17385b6ccbb37419?w=298&amp;amp;h=702&amp;amp;f=png&amp;amp;s=48040&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来分享一下当时我是怎么刷这些题的（下面的一些数字要是看着比较烦的话可以不用太关注），我没看任何人的推荐路线去刷这些题（那时候我也不知道还有刷题路线这些东西啊，纯新手对一切一无所知）。登陆进去hdu一般情况下是在第11页开始的（现在好像又从第一页开始了，从哪里开始不要紧），也就是题号是2000，当时懵懵懂懂从2000一直刷到了2058。越到后面感觉有些题目难度就上来了（当然这是对我来说的）。有些题即使是看了很多的题解我还是不会，无奈只能跳过。&lt;br/&gt;一路刷到2058题后，我发现题号是从1000开始的，前面还有好多题没有刷就跳去第一页刷题。所以后面我就从1000开始刷了。不过这次我学聪明了，我没有全部都刷。我只刷一些比较多人刷的题目，这里强烈推荐提交量超过30000的记住是提交量不是通过量。刷这些提交量通过三万的理由如下，这些提交量三万以上的题目基本上道道是算法精品，是非常基础的算法题，可以当作模板。我一路从1000刷到了2000左右（后面就没怎么刷了）。基本上所有的30000通过量以上的题目都给刷了一遍。刷完感觉自己好像变强了，最主要的是自己的思维逻辑提升上来了&lt;sup&gt;_&lt;/sup&gt;。&lt;br/&gt;其实刷20000提交量以上也是可以的，那些应该也是一些算法题，有实力的可以这样子做。&lt;br/&gt;如果你问我没有基础去刷这些题会不会困难，额确实是比较难，不过难也就难一个月左右吧。我刷hdu大概刷了一个月（期间痛苦并快乐着），就刷完上面所列的那些题目了。刷这些题的时候我才刚刚开始知道算法大概是个什么东西。我的基础只有大一刷的一些基础C语言题目，期间思维的转变很关键。开始基本上很多题目都是找百度的。每道题目看了好多个人的题解，大多数时候看的一脸懵逼，不过还是慢慢坚持下来并且适应了。&lt;br/&gt;如果你问我一个月够了吗的话。一个月是真的够了，只要你吧一天的主任务放在刷题上真的可以入门这些非常有用的算法，从此飞黄腾达（其实是掉进了坑哈哈，不过为了钱一切都值得）。如果你再肝一点半个月估计也可以搞定。&lt;br/&gt;这里再分享一下我看题解的一些小技巧。开始刷到算法题（那时候并不知道这些题是算法题）是真的痛不欲生，百度题解一脸懵逼，看了好多题解还是不太懂这道题，不过看多一点题解就是我要分享给你的小技巧。刚学的算法题，随便找一些自己认为比较好的（推荐代码简洁的），然后就去认真的看，看不懂没关系一遍很难看懂的（对未知感到恐惧很正常，但心态放平不要畏难真的很重要，这不是鸡汤，不少人应该亲生经历过），可以不用继续看他的题解，去看其他人的题解，认真看个几个人的题解，慢慢的你就会对这个算法有一个大概的了解，看着看着你就会豁然开朗，感觉看的题解差不多的时候，就从中挑一个自己认为比较简洁的代码去看（记得多问几个为什么），一定要每一个细节都搞明白，为什么这里是这样子，那里是那样子。多动手在纸上模拟（这样子不容易开小差）。&lt;br/&gt;曾国藩说过这样一句话“大处着眼，小处着手；群居守口，独居守心”。我的刷题方法似乎在一定程度上吻合了“大处着眼，小处着手”这八字真言哈哈。这八个字放在哪其实都是可以的。不赞一波吗，喜欢的可以关注一下我的公众号&lt;strong&gt;玩编程地码农&lt;/strong&gt;啊。&lt;br/&gt;如果你问我现在开始学的话晚了吗？你能看到我这篇文章，那就说明不晚，至少你正在找一个让自己变优秀的理由。我没有理由给你，但我用我的实际行动告诉你，只要你坚持一个月，你一定会变得更优秀。相信你学完这些算法会找到让自己变优秀的理由（哪怕是为了钱也好）。&lt;br/&gt;如果你不喜欢刷题，想快速入门算法我觉得是不太可能的，学算法一个比较好的办法就是持之以恒的刷题。&lt;br/&gt;这些题量多吗？真心不多，坚持一个月，即使是你没有任何的算法基础，只要你会一门语言，就ok啦。当时我是大一第一学期学了C语言，寒假边学C++边刷hdu的。&lt;br/&gt;这篇文章也是一时心血来潮，想着把自己的经历让大家看见，希望大家能少走点弯路。&lt;br/&gt;最后再谈一下我学了这些算法之后的一些成效，这些算法学完之后不久，我就陆陆续续去学习其他数据结构与算法了，例如什么红黑树啊，B树啊，跳表啊之类的。新的数据结构与算法难度变大了，但是我花的时间却不多，很多知识都能够不费太多精力就看懂，这可能是我刷题之后思维的提升和能力的提升的一种表现。相信我花一个月去刷刷题目，刷完之后你会有意向不大的收获。&lt;br/&gt;逼迫一下自己，一切都是从这里开始。&lt;br/&gt;如果觉得有收获，不妨花个几秒钟点歌赞，欢迎关注我的公众号&lt;strong&gt;玩编程地码农&lt;/strong&gt;，目前专注写数据结构于算法相关知识。&lt;/p&gt;
</description>
<pubDate>Sat, 25 Jul 2020 11:29:00 +0000</pubDate>
<dc:creator>玄之不玄</dc:creator>
<og:description>如果你想入门算法，那么我这篇文章也许可以帮到你。 oj网站有这么多，当然还有其他的。我当初是在hdu上面刷的，不要问我为什么，问就是当时我也是一个新手，懵懵懂懂就刷起来了。点这里可以进入这个网站htt</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wbcdmn/p/13377914.html</dc:identifier>
</item>
<item>
<title>设计模式：如何优雅地使用责任链模式 - James_Shangguan</title>
<link>http://www.cnblogs.com/sgh1023/p/13369619.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sgh1023/p/13369619.html</guid>
<description>&lt;p&gt;责任链模式（Chain of Responsibility Pattern）在《Head First设计模式》一书中被称为“剩下的模式”，其实使用也是蛮多的。最近在学习Netty的过程中用到了责任链模式，在此反过头来重温一下责任链模式。本文教你如何优雅地使用责任链模式。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;172&quot;&gt;
&lt;p&gt;责任链模式（Chain of Responsibility Pattern）在《Head First设计模式》一书中被称为“剩下的模式”，其实使用也是蛮多的。最近在学习Netty的过程中用到了责任链模式，在此反过头来重温一下责任链模式。&lt;/p&gt;
&lt;p&gt;当你想要让一个以上的对象有机会能够处理某个请求的时候，就使用责任链模式。&lt;/p&gt;

&lt;p&gt;借用《Head First设计模式》书中的典型场景：需要处理四种类型的电子邮件，第一种类型是粉丝寄来的信，表示他们喜欢新推出的游戏；第二种类型是父母寄来的信，他们抱怨孩子总是沉迷游戏而忘记做作业；第三种类型是店家希望在其他地方也摆放糖果机；第四种类型是垃圾邮件。现在已经可以根据邮件内容确定收到的邮件属于哪种类型，需要设计一个程序来处理这些邮件。&lt;/p&gt;
&lt;p&gt;Talk is cheap. Show me the code.直接用代码来说话吧。&lt;/p&gt;
&lt;p&gt;用枚举来定义四种类型的邮件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public enum EmailEnum {
    SPAM_EMAIL(1, &quot;Spam_Email&quot;),
    FAN_EMAIL(2, &quot;Fan_Email&quot;),
    COMPLAINT_EMAIL(3, &quot;Complaint_Email&quot;),
    NEW_LOC_EMAIL(4, &quot;New_Loc_Email&quot;);

    private Integer code;
    private String desc;

    EmailEnum(Integer code, String desc) {
        this.code = code;
        this.desc = desc;
    }

    public Integer getCode() {
        return code;
    }

    public String getDesc() {
        return desc;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;假设邮件有两个属性：邮件类型和邮件内容，定义邮件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Email {
    int type;
    String content;

    public Email(int type, String content) {
        this.type = type;
        this.content = content;
    }

    public int getType() {
        return type;
    }

    public String getContent() {
        return content;
    }
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;如果不采用责任链模式？使用EmailHandler这个类来统一处理上述四种邮件，程序是这样子的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class EmailHandler {

    public void handleEmai(Email email) {
        if (EmailEnum.SPAM_EMAIL.getCode().equals(email.getType())) {
            // 处理垃圾邮件
            handleSpamEmail(email);
        } else if (EmailEnum.FAN_EMAIL.getCode().equals(email.getType())) {
            // 处理粉丝邮件
            handleFanEmail(email);
        } else if (EmailEnum.COMPLAINT_EMAIL.getCode().equals(email.getType())) {
            // 处理抱怨邮件
            handleComplaintEmail(email);
        } else {
            // 处理新增邮件
            handleNewLocEmail(email);
        }
    }

    private void handleNewLocEmail(Email email) {
        System.out.println(&quot;handleNewLocEmail...&quot;);
        // 处理代码省略
    }

    private void handleComplaintEmail(Email email) {
        System.out.println(&quot;handleComplaintEmail...&quot;);
        // 处理代码省略
    }

    private void handleFanEmail(Email email) {
        System.out.println(&quot;handleFanEmail...&quot;);
        // 处理代码省略
    }

    public void handleSpamEmail(Email email) {
        System.out.println(&quot;handleSpamEmail...&quot;);
        // 处理代码省略
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个类虽然强大，但是是不够优雅的：&lt;/p&gt;
&lt;p&gt;(1)EmailHandler类较为庞大，各种类型邮件的处理都集中在一个类中，违反了“单一职责原则”。&lt;/p&gt;
&lt;p&gt;(2)如果之后增加新的邮件类型、删除某一种邮件类型，或者有其他新功能的拓展，都必须修改源代码并进行严格测试，违反了“开闭原则”。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;开放-关闭原则：类应该对扩展开放，对修改关闭。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如何进行改进呢？那就是使用责任链模式，为某个请求创建一个对象链。每个对象按照顺序检查这个请求，并对其处理，或者将它传递给链中的下一个对象。在本例中，当收到电子邮件的时候，先进入第一个处理器SpamHandler，如果SpamHandler无法处理，就将它传给FanHandler，以此类推...&lt;/p&gt;
&lt;p&gt;本例使用责任链模式的结构图如图所示：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1538609/202007/1538609-20200725173221783-1119796022.png&quot; alt=&quot;UML 类图&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Handler是一个抽象的处理器，是一个抽象类。抽象类中定义了一个抽象处理器的对象successor，通过该引用，可以形成一条责任链。抽象类中还定义了抽象处理请求的的方法handleRequest()。代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public abstract class Handler {
    protected Handler successor;

    public void setSuccessor(Handler successor) {
        this.successor = successor;
    }

    public abstract void handleRequest(Email email);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;SpamHandler、FanHandler、ComplaintHandler和NewLocHandler是具体的处理器，继承抽象类Handler，用来处理具体的邮件请求。处理细节：处理之前要进行类型的判断，看是否能够处理该请求，如果可以处理就处理，否则就转发给后继的处理器去处理。代码如下：&lt;/p&gt;
&lt;p&gt;SpamHandler&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class SpamHandler extends Handler{
    @Override
    public void handleRequest(Email email) {
        if (EmailEnum.SPAM_EMAIL.getCode().equals(email.getType())) {
            //处理请求
            System.out.println(&quot;SpamHandler handleRequest...&quot;);
        }
        else {
            this.successor.handleRequest(email);  //转发请求
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;FanHandler&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class FanHandler extends Handler{
    @Override
    public void handleRequest(Email email) {
        if (EmailEnum.FAN_EMAIL.getCode().equals(email.getType())) {
            //处理请求
            System.out.println(&quot;FanHandler handleRequest...&quot;);
        }
        else {
            this.successor.handleRequest(email);  //转发请求
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ComplaintHandler&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class ComplaintHandler extends Handler{
    @Override
    public void handleRequest(Email email) {
        if (EmailEnum.COMPLAINT_EMAIL.getCode().equals(email.getType())) {
            //处理请求
            System.out.println(&quot;ComplaintHandler handleRequest...&quot;);
        }
        else {
            this.successor.handleRequest(email);  //转发请求
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;NewLocHandler&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class NewLocHandler extends Handler{
    @Override
    public void handleRequest(Email email) {
        if (EmailEnum.NEW_LOC_EMAIL.getCode().equals(email.getType())) {
            //处理请求
            System.out.println(&quot;NewLocHandler handleRequest...&quot;);
        }
        else {
            this.successor.handleRequest(email);  //转发请求
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要注意的是，责任链模式并不创建责任链，责任链的创建工作必须由系统的其他部分来完成，一般是在使用该责任链的客户端中创建责任链。责任链模式降低了请求的发送端和接收端之间的耦合，使多个对象都有机会处理这个请求。下面编写测试类进行测试：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Test {
    public static void main(String[] args) {
        // 创建邮件处理请求
        Email email1 = new Email(1,&quot;aaa&quot;);
        Email email2 = new Email(2,&quot;bbb&quot;);
        Email email3 = new Email(3,&quot;ccc&quot;);
        Email email4 = new Email(4,&quot;ddd&quot;);
        // 创建Handler
        SpamHandler handler1 = new SpamHandler();
        FanHandler handler2 = new FanHandler();
        ComplaintHandler handler3 = new ComplaintHandler();
        NewLocHandler handler4 = new NewLocHandler();
        // 创建责任链
        handler1.setSuccessor(handler2);
        handler2.setSuccessor(handler3);
        handler3.setSuccessor(handler4);
        // 处理请求
        handler1.handleRequest(email1);
        handler1.handleRequest(email2);
        handler1.handleRequest(email3);
        handler1.handleRequest(email4);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在代码中创建四种类型的邮件用于处理，创建了四种不同的处理器（SpamHandler、FanHandler、ComplaintHandler、NewLocHandler），形成“handler1 -&amp;gt; handler2 -&amp;gt; handler3 -&amp;gt; handler4”的责任链，使用这条责任链处理四种类型的邮件。运行结构如下：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1538609/202007/1538609-20200725182848747-1530036669.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样处理之后，明显使得请求发送者和接受者解耦；每个实现类都有自己明确且独一无二的职责；如果增加一个类型，只需要再增加一个具体类去继承Handler，书写自己的处理逻辑，在责任链中进行添加；如果删除某种类型的，只需要在构建责任链的时候，把它删除就可以了，实现动态增加或者删除责任，符合设计模式的原则。&lt;/p&gt;

&lt;p&gt;责任链模式通过建立一条链来组织请求的处理者，请求将沿着链进行传递，请求发送者无须知道请求在何时、何处以及如何被处理，实现了请求发送者与处理者的解耦。在软件开发中，如果遇到有多个对象可以处理同一请求时可以应用责任链模式，例如在Web应用开发中创建一个过滤器链来对请求数据进行过滤，在工作流系统中实现公文的分级审批等等，使用责任链模式可以较好地解决此类问题。&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Sat, 25 Jul 2020 11:16:00 +0000</pubDate>
<dc:creator>James_Shangguan</dc:creator>
<og:description>责任链模式（Chain of Responsibility Pattern）在《Head First设计模式》一书中被称为“剩下的模式”，其实使用也是蛮多的。最近在学习Netty的过程中用到了责任链模</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sgh1023/p/13369619.html</dc:identifier>
</item>
<item>
<title>微服务安全认证架构是如何演进而来的？ - EdisonZhou</title>
<link>http://www.cnblogs.com/edisonchou/p/the_development_of_microservice_security_authentication.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/edisonchou/p/the_development_of_microservice_security_authentication.html</guid>
<description>&lt;p&gt;之前有同事问为何要用基于JWT令牌的认证架构，然后近期又有童鞋在后台留言问微服务安全认证架构的实践，因此我决定花两篇推文来解答一下。为了答好这个话题，我们先来看看微服务的安全认证架构是如何演进而来的，从而更好地理解。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/381412/202007/381412-20200725112853351-1272187615.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;首先，我们有必要再次了解下认证和授权这两个基本概念：&lt;/p&gt;
&lt;p&gt;认证，Authentication，识别你是谁。即在网站上用来识别某个用户是否是注册过的合法用户。&lt;/p&gt;
&lt;p&gt;授权，Authorization，识别你能做什么。即在网站上用来识别某个用户是否有某方面的权限。&lt;/p&gt;
&lt;p&gt;然后，这里还是引用我在波波老师的《Spring Boot与K8s云原生应用开发》课程中学到的一个案例，来学习网站安全架构的演进。&lt;/p&gt;
&lt;p&gt;假设我们把时间倒退回2006年，我们有一个叫做MyShop的网站，它的安全架构大概是下面这个样子，我们暂且称之为v1版本：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://wx4.sinaimg.cn/large/7b43aa3dly4gh04mwmuy2j20u00h879r.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;MyShop v1版本的认证操作&lt;/p&gt;
&lt;p&gt;可以看到，这个v1版本的传统安全认证架构，使用到了我们十分熟悉的Session + Cookie的模式来实现用户的认证。即当一个注册用户通过登录操作请求后，Web服务器通过向数据库进行校验用户名和密码，通过后就会向Session中添加一条记录，然后返回给浏览器。在返回给浏览器的报文中，会将sessionId放在Cookie里头。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://wx3.sinaimg.cn/large/7b43aa3dly4gh04mwotbpj20u00h879k.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;MyShop v1版本的访问操作&lt;/p&gt;
&lt;p&gt;这样一来，用户在登录之后再访问网站的时候，就会将带有sessionId的Cookie传给Web服务器，而Web服务器就可以通过Cookie中的sessionId去Session记录中检查，如果没有过时就认为其是认证的活跃用户。&lt;/p&gt;
&lt;p&gt;在ASP.NET Core中，提供了一个管理Session的中间件，我们可以在StartUp中注册和使用这个中间件即可用来管理会话状态。&lt;/p&gt;
&lt;blockquote readability=&quot;4.4642857142857&quot;&gt;
&lt;p&gt;&lt;strong&gt;参考资料：&lt;/strong&gt;有关ASP.NET Core中的会话和状态管理，这里是&lt;a href=&quot;https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/app-state?view=aspnetcore-3.1&quot; target=&quot;_blank&quot;&gt;传送门&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;v1版本上线测试之后，测试人员发现存在一个问题：登录用户会间歇性地退出登录，而且会话还没有超时。经过分析后发现，原来的Session记录只会在登录过的那台Web服务器上存在，而MyShop是以集群方式来部署的，由前置的Nginx代理服务器进行负载均衡地请求转发。&lt;br/&gt;针对这个问题，MyShop设计了下图所示的v1.1版本的认证架构，又称为黏性Session架构。也就是说，不管哪一次请求，Nginx都会将对应的sessionId发给对应的Web服务器进行处理，而不是均衡地轮流转发。换句话说，Nginx服务器将会维护sessionId与各个Web服务器的Session之间的关联，以保证在会话期间的Session绑定。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://wx2.sinaimg.cn/large/7b43aa3dly4gh04mwn14uj20u00gvgq4.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;MyShop v1.1版本-黏性会话&lt;/p&gt;
&lt;p&gt;就这样，一晃两三年又过了，MyShop v1.1的认证架构支持了它早期的快速发展。但是，随着业务和用户量的不断扩展，它也逐渐暴露出稳定性和扩展性方面的问题。这些问题，归根结底还是由黏性会话所造成的。&lt;/p&gt;
&lt;p&gt;（1）稳定性：黏性会话会将用户会话绑定到某个服务器上，如果我们要对这个服务器进行一些升级或改造又或服务器延迟或宕机，那么此服务器上的一波认证用户信息就会瞬间消失，用户必须重新登录。&lt;/p&gt;
&lt;p&gt;（2）扩展性：黏性会话使得Web服务器和Nginx负载均衡服务器上都保存了状态，整体上属于一个有状态架构。随着流量的增长，这些状态同时给Web服务器和负载均衡器都会带来较大的压力。和无状态的应用架构比起来，这种有状态的应用架构比较难以扩展。&lt;/p&gt;
&lt;p&gt;一般来说，常见的解决黏性会话的解决方案有以下几种：&lt;/p&gt;
&lt;p&gt;（1）会话同步复制：即各个Web服务器之间同步Session，但是会引入复杂性，整体的性能较低。&lt;br/&gt;（2）无状态会话：即Session数据不存在服务器端，而是存在浏览器端，但是存在数据泄露风险，且浏览器端对于Cookie的大小有限制（4KB）。&lt;/p&gt;
&lt;p&gt;（3）集中状态会话：即将Session集中存储在某个存储中，比如Memcached或Redis这种高性能缓存中。&lt;/p&gt;
&lt;p&gt;因此，MyShop选择了集中状态会话的方式演进出了v1.5安全认证架构，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://wx2.sinaimg.cn/large/7b43aa3dly4gh04mwoe1cj20u00gxgql.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;MyShop v1.5版本-集中状态会话&lt;/p&gt;
&lt;p&gt;在v1.5版本中，Web服务器和Nginx服务器不再存储会话状态，转而交由Redis进行统一存储，从而提高了稳定性和扩展性。对于Redis来说，也可以采用高可用集群方案，业界也有很多可扩展的实践案例。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;画外音：虽然是单块时代发展出来的技术，但是无状态会话和集中状态会话却是微服务安全认证架构的基础。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;时光飞逝，时间来到了2015年，这期间MyShop的业务量也迅速的飞涨，期间互联网的技术也发生了大变化。微服务架构、无线应用、SPA应用雨后春笋般的出现，MyShop的技术团队也准备陆续应用实践，进一步丰富和扩展业务渠道，赋能业务端。但是，微服务架构的安全认证授权也存在着一些挑战：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://wx4.sinaimg.cn/large/7b43aa3dly4gh04mwulh8j20u00h7tcg.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;微服务认证授权挑战&lt;/p&gt;
&lt;p&gt;（1）后台应用和服务众多，如何对每一个服务进行认证和鉴权？传统的用户名&amp;amp;密码以及Session/Cookie的方式还能够适用吗？&lt;br/&gt;（2）前端的用户入口众多，如果每个入口都搞一套登录认证，显然成本高且难以扩展。有没有一种SSO单点登录的方案？经过MyShop技术团队的分析，传统的用户名&amp;amp;密码+Session/Cookie的方式无法直接套用在微服务架构上，但是可以借鉴之前的思路，他们提出了面向微服务架构的v2.0安全认证体系，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://wx1.sinaimg.cn/large/7b43aa3dly4gh04mwwvntj20u00hln2q.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;MyShop v2.0版本-基于Token的认证&lt;/p&gt;
&lt;p&gt;v2.0安全认证体系最大的变化就在于，将登陆认证抽取为一个独立的API微服务AuthService，拥有一个独立的UserDB。这个服务统一承担登陆认证、用户校验、令牌颁发等职责。此外，v2.0版本还引入了Token作为服务调用认证鉴权的主要凭证。这里的话，v2.0采用的是一个透明令牌（也称为引用令牌），即它是一个无意义的随机字符串。这个令牌跟Auth Service上的一次登陆会话相关联，后续也可以通过API去校验这个令牌的合法性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;画外音：其实这个Token令牌，就相当于一个SessionId。每个微服务拿到令牌，都可以去AuthService进行认证鉴权。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;总结下来，v2.0的安全认证体系的步骤如下：&lt;/p&gt;
&lt;p&gt;Step1.用户通过某种客户端（Web/SPA/H5/App等）进行登陆，AuthService通过比对用户数据库进行校验；&lt;/p&gt;
&lt;p&gt;Step2.AuthService校验通过后会建立一个用户会话Session（此Session和之前版本的类似，存在一个过期时间，可以存储在AuthService所在的服务器上也可以存在Redis中），然后颁发一个Token给客户端；&lt;/p&gt;
&lt;p&gt;Step3.客户端向后台微服务发请求，会带上刚刚得到的Token；&lt;/p&gt;
&lt;p&gt;Step4.微服务接收到用户请求时，首先会向AuthService发出一个请求对这个Token进行合法性校验；&lt;/p&gt;
&lt;p&gt;Step5.AuthService校验Token通过后会返回该用户的详情信息（如果微服务需要的话，可以拿到用户的一些比如角色之类的信息）；&lt;br/&gt;Step6.微服务进行自己的逻辑处理，最终返回数据给客户端；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;画外音：v2.0版本可以看做是v1.5的一个升级改造，专门针对微服务架构的场景进行了扩展，可以应对微服务架构存在的挑战。它把登录认证、令牌颁发等工作封装在了AuthService中，其他微服务统一共用AuthService，经过扩展还可以实现SSO单点登录。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;v2.0认证架构虽然可以解决问题，但是又引发了另外的问题：首先，每个微服务都需要实现&lt;strong&gt;部分&lt;/strong&gt;认证鉴权的逻辑，使得微服务开发方无法聚焦于业务逻辑的开发。其次，认证鉴权逻辑分散在每个微服务当中，一方面会带来不规范容易出错的问题，另一方面也会有潜在的安全风险（比如某些开发人员可能会忘记校验令牌）。为了解决上面提到的问题，同时考虑到微服务拆分后引入微服务API网关，MyShop技术团队设计了下图所示的v2.5认证架构：&lt;strong&gt;Token+Gateway结合方式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://wx2.sinaimg.cn/large/7b43aa3dly4gh04mwzv2rj20u00hndlj.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;MyShop v2.5版本-基于Token+Gateway的认证&lt;/p&gt;
&lt;p&gt;从上图可以看出，该架构将每个微服务都要进行的部分认证鉴权的逻辑从微服务转移到了网关中。即网关处负责拿到令牌向AuthService进行鉴权，通过后再将请求转发到后端的微服务，微服务不再包含任何认证鉴权的逻辑。总体上，通过引入网关进行令牌的鉴权之后，大大减少了后端微服务开发方的职责，使得他们更专注于微服务的业务逻辑的开发。此外，引入网关之后，网关可以统一处理登录客户端的校验，也便于实现SSO单点登录，也为MyShop后续的微服务化和业务成长提供了基础。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;画外音：v2.5版本应该是目前大多数团队所采用的一种认证架构了。对，我司也是，不过Token类型使用的是JWT。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;本文通过一个MyShop的案例的演化介绍了微服务的安全认证架构是如何演进而来的，但是v2.5版本（Token+Gateway方式）总体上还是比较重，每个请求都还是需要到AuthService上去做认证鉴权的操作，这对于AuthService来说算是压力比较大。针对这个问题，业界广泛采用JWT这种轻量级的解决方案来重构安全认证架构。那么问题来了，JWT是什么？原理？实现方式？下一期骚年快答，为你解答这几个问题。&lt;/p&gt;

&lt;p&gt;杨波，《Spring Boot与K8s云原生应用开发》（极客时间课程，推荐学习）&lt;/p&gt;
&lt;p&gt;杨波，《微服务架构160讲》（极客时间课程，推荐学习）&lt;/p&gt;
&lt;p&gt;Microsoft，《&lt;a href=&quot;https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/app-state?view=aspnetcore-3.1&quot; target=&quot;_blank&quot;&gt;ASP.NET Core中的会话状态管理&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;晓晨，《&lt;a href=&quot;https://www.cnblogs.com/stulzq/p/8119928.html&quot; target=&quot;_blank&quot;&gt;IdentityServer4 中文文档与实战&lt;/a&gt;》&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://wx2.sinaimg.cn/large/7b43aa3dly4ggis81gfm4j20p00anjtj.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div id=&quot;Copyright&quot; readability=&quot;8.1860465116279&quot;&gt;
&lt;p&gt;作者：&lt;a title=&quot;author&quot; href=&quot;https://edisonchou.cnblogs.com&quot; target=&quot;_blank&quot;&gt;周旭龙&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;出处：&lt;a title=&quot;from&quot; href=&quot;https://edisonchou.cnblogs.com&quot; target=&quot;_blank&quot;&gt;https://edisonchou.cnblogs.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接。&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Sat, 25 Jul 2020 10:04:00 +0000</pubDate>
<dc:creator>EdisonZhou</dc:creator>
<og:description>之前有同事问为何要用基于JWT令牌的认证架构，然后近期又有童鞋在后台留言问微服务安全认证架构的实践，因此我决定花两篇推文来解答一下。为了答好这个话题，我们先来看看微服务的安全认证架构是如何演进而来的，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/edisonchou/p/the_development_of_microservice_security_authentication.html</dc:identifier>
</item>
</channel>
</rss>