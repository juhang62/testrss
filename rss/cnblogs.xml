<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>算法分析中常用的几种渐进符号 - 十八岁</title>
<link>http://www.cnblogs.com/l199616j/p/10163896.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/l199616j/p/10163896.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;在算法分析中，经常会遇到以下几种渐进符号&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;渐近精确界记号：&lt;span id=&quot;MathJax-Element-134-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#x398;&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-1&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-2&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-3&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-4&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-5&quot; class=&quot;mo&quot;&gt;Θ&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;Θ（big-theta）&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;渐近上界记号 ：&lt;span id=&quot;MathJax-Element-135-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mi&amp;gt;O&amp;lt;/mi&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-6&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-7&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-8&quot; class=&quot;mi&quot;&gt;O&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;O(big-oh)&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;渐近下界记号 ：&lt;span id=&quot;MathJax-Element-136-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#x3A9;&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-9&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-10&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-11&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-12&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-13&quot; class=&quot;mo&quot;&gt;Ω&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;Ω(big-omege)&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;非渐近紧确上界：o(小-oh)&lt;/li&gt;
&lt;li&gt;非渐近紧确下界：ω(小-omege)&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;下面对渐进符号进行详解：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;大写O符号&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;f(n)=O(g(n))，这里f(n)是分析出来算法的执行次数的函数，&lt;br/&gt;&lt;strong&gt;O的定义:   &lt;/strong&gt;当且仅当存在正的常数c和n0，使得对于所有的n&amp;gt;=n0，有f(n)&amp;lt;=cg(n)。&lt;br/&gt;这里cg(n)就是函数f(n)的上限。讲到这是不是很迷糊，我刚开始也这样，不着急，看下面例子，你就会恍然大悟啦。&lt;/p&gt;
&lt;p&gt;几种函数的例子:&lt;br/&gt;&lt;strong&gt;1.线性函数&lt;/strong&gt;&lt;br/&gt;f(n)=3n+2，当n&amp;gt;=2时，3n+2&amp;lt;=3n+n=4n。&lt;/p&gt;
&lt;p&gt;所以f(n)=O(n)，这里c = 4，n0 = 2，g(n) = n, 那么cg(n) 也就是4n 就是f(n) 的上界&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;2.平方函数&lt;/strong&gt;&lt;br/&gt;f(n)=2n^2+3n+3，当n&amp;gt;=3时，3n+3&amp;lt;=4n，当n&amp;gt;=4时，4n&amp;lt;n^2，f(n)=2n^2+n^2=3n^2。&lt;br/&gt;f(n)=O(n^2)，这里c = 3，n0 = 4， g(n) = n^2 ,那么cg(n) 也就是3n^2 就是f(n) 的上界&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;3.指数函数&lt;/strong&gt;&lt;br/&gt;f(n)=6*2^n+n^2，当n&amp;gt;=4时，n^2&amp;lt;=2^n，所以当n&amp;gt;=4，有f(n)&amp;lt;=6*2^n+2^n=7*2^n。&lt;br/&gt;这里c是7，n0=4，f(n)=O(2^n)。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;4.常数阶&lt;/strong&gt;&lt;br/&gt;f(n)=9，这里就直接记为O(1)，c为9，n0为0就可以了，f(n)=9&amp;lt;=9*1。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;Ω符号&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;定义：&lt;/strong&gt;f(n)=Ω(g(n))，当且仅当存在正的常数c和n0，使得对于所有n&amp;gt;=n0，有f(n)&amp;gt;=cg(n)。&lt;br/&gt;Ω符号是给函数的下限。&lt;br/&gt;&lt;strong&gt;例子:&lt;/strong&gt;&lt;br/&gt;对于所有的n，有f(n)=3n+2&amp;gt;3n，所以f(n)=Ω(n)，这里c=3，n0=0。这里也可以这样f(n)=Ω(1)，&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;Θ符号&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;定义：&lt;/strong&gt;对于存在大于0的常数c1、c2和非负的整数n0，以及足够大的n，对于所有的n≥n0来说，有c1g(n)&amp;lt;=f &lt;br/&gt;(n)&amp;lt;=c2g(n)。&lt;br/&gt;&lt;strong&gt;例子：&lt;/strong&gt;3n+2=Θ(n)，当c1=3,c2=4，n&amp;gt;=n0=2时，3n&amp;lt;=3n+2&amp;lt;=4n。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;小写o符号&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;定义: &lt;/strong&gt;f(n)=o(g(n))，当且仅当f(n)=O(g(n))  且f(n)!=Ω(g(n))。&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;渐近记号Θ、Ο、o、Ω、ω关系&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1258817/201812/1258817-20181223153303850-2081594458.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1258817/201812/1258817-20181223153142817-17861085.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 23 Dec 2018 07:37:00 +0000</pubDate>
<dc:creator>十八岁</dc:creator>
<og:description>在算法分析中，经常会遇到以下几种渐进符号 下面对渐进符号进行详解： 大写O符号f(n)=O(g(n))，这里f(n)是分析出来算法的执行次数的函数，O的定义: 当且仅当存在正的常数c和n0，使得对于所</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/l199616j/p/10163896.html</dc:identifier>
</item>
<item>
<title>javascript：用原生js模拟贪吃蛇游戏练习 - xhysns</title>
<link>http://www.cnblogs.com/xhysns/p/10164418.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xhysns/p/10164418.html</guid>
<description>&lt;p&gt;&lt;strong&gt;本次练习所有的代码：可以直接复制全部然后运行看效果~&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;57&quot;&gt;&lt;img id=&quot;code_img_closed_2fa62e39-3195-40aa-b701-f69e43d53da2&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_2fa62e39-3195-40aa-b701-f69e43d53da2&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_2fa62e39-3195-40aa-b701-f69e43d53da2&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;109&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;  4&lt;/span&gt;   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;  5&lt;/span&gt;   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;title&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;  6&lt;/span&gt;   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;    .map &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;
&lt;span&gt;  8&lt;/span&gt; &lt;span&gt;      width&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 800px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;  9&lt;/span&gt; &lt;span&gt;      height&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 600px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt; 10&lt;/span&gt; &lt;span&gt;      background-color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; #CCC&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt; 11&lt;/span&gt; &lt;span&gt;      position&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; relative&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt; 12&lt;/span&gt;     &lt;span&gt;}&lt;/span&gt;
&lt;span&gt; 13&lt;/span&gt;   &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 14&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 15&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 16&lt;/span&gt; &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;画出地图,设置样式&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt; 17&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;map&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 18&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 19&lt;/span&gt; 
&lt;span&gt; 20&lt;/span&gt; 
&lt;span&gt; 21&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;自调用函数----食物的&lt;/span&gt;
&lt;span&gt; 22&lt;/span&gt; &lt;span&gt;  (&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt;&lt;span&gt; elements &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; [];&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用来保存每个小方块食物的&lt;/span&gt;
&lt;span&gt; 24&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;食物就是一个对象,有宽,有高,有颜色,有横纵坐标,先定义构造函数,然后创建对象&lt;/span&gt;
&lt;span&gt; 25&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; Food(x, y, width, height, color) {
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;横纵坐标&lt;/span&gt;
&lt;span&gt; 27&lt;/span&gt;       &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.x &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; x &lt;/span&gt;&lt;span&gt;||&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt;       &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.y &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; y &lt;/span&gt;&lt;span&gt;||&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;宽和高&lt;/span&gt;
&lt;span&gt; 30&lt;/span&gt;       &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.width &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; width &lt;/span&gt;&lt;span&gt;||&lt;/span&gt; &lt;span&gt;20&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt;       &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.height &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; height &lt;/span&gt;&lt;span&gt;||&lt;/span&gt; &lt;span&gt;20&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;背景颜色&lt;/span&gt;
&lt;span&gt; 33&lt;/span&gt;       &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.color &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; color &lt;/span&gt;&lt;span&gt;||&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;green&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt; 
&lt;span&gt; 36&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;为原型添加初始化的方法(作用：在页面上显示这个食物)&lt;/span&gt;
&lt;span&gt; 37&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;因为食物要在地图上显示,所以,需要地图的这个参数(map---就是页面上的.class=map的这个div)&lt;/span&gt;
&lt;span&gt; 38&lt;/span&gt; &lt;span&gt;    Food.prototype.init &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (map) {
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;先删除这个小食物&lt;/span&gt;
&lt;span&gt; 40&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;外部无法访问的函数&lt;/span&gt;
&lt;span&gt; 41&lt;/span&gt; &lt;span&gt;      remove();
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt; 
&lt;span&gt; 43&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建div&lt;/span&gt;
&lt;span&gt; 44&lt;/span&gt;       &lt;span&gt;var&lt;/span&gt;&lt;span&gt; div &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; document.createElement(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;把div加到map中&lt;/span&gt;
&lt;span&gt; 46&lt;/span&gt; &lt;span&gt;      map.appendChild(div);
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置div的样式&lt;/span&gt;
&lt;span&gt; 48&lt;/span&gt; &lt;span&gt;      div.style.width &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.width &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;px&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt; &lt;span&gt;      div.style.height &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.height &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;px&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt; &lt;span&gt;      div.style.backgroundColor &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.color;
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;先脱离文档流&lt;/span&gt;
&lt;span&gt; 52&lt;/span&gt; &lt;span&gt;      div.style.position &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;absolute&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;随机横纵坐标&lt;/span&gt;
&lt;span&gt; 54&lt;/span&gt;       &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.x &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; parseInt(Math.random() &lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt; (map.offsetWidth &lt;/span&gt;&lt;span&gt;/&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.width)) &lt;/span&gt;&lt;span&gt;*&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.width;
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt;       &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.y &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; parseInt(Math.random() &lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt; (map.offsetHeight &lt;/span&gt;&lt;span&gt;/&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.height)) &lt;/span&gt;&lt;span&gt;*&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.height;
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt; &lt;span&gt;      div.style.left &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.x &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;px&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt; &lt;span&gt;      div.style.top &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.y &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;px&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt; 
&lt;span&gt; 59&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;把div加入到数组elements中&lt;/span&gt;
&lt;span&gt; 60&lt;/span&gt; &lt;span&gt;      elements.push(div);
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt; &lt;span&gt;    };
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt; 
&lt;span&gt; 63&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;私有的函数---删除食物的&lt;/span&gt;
&lt;span&gt; 64&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; remove() {
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;elements数组中有这个食物&lt;/span&gt;
&lt;span&gt; 66&lt;/span&gt;       &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (&lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; i &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;; i &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt; elements.length; i&lt;/span&gt;&lt;span&gt;++&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt;&lt;span&gt; ele &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; elements[i];
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;找到这个子元素的父级元素,然后删除这个子元素&lt;/span&gt;
&lt;span&gt; 69&lt;/span&gt; &lt;span&gt;        ele.parentNode.removeChild(ele);
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;再次把elements中的这个子元素也要删除&lt;/span&gt;
&lt;span&gt; 71&lt;/span&gt; &lt;span&gt;        elements.splice(i, &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt; 
&lt;span&gt; 75&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;把Food暴露给Window,外部可以使用&lt;/span&gt;
&lt;span&gt; 76&lt;/span&gt; &lt;span&gt;    window.Food &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; Food;
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt; &lt;span&gt;  }());
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt; 
&lt;span&gt; 79&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;自调用函数---小蛇&lt;/span&gt;
&lt;span&gt; 80&lt;/span&gt; &lt;span&gt;  (&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt;&lt;span&gt; elements &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; [];&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;存放小蛇的每个身体部分&lt;/span&gt;
&lt;span&gt; 82&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;小蛇的构造函数&lt;/span&gt;
&lt;span&gt; 83&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; Snake(width, height, direction) {
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;小蛇的每个部分的宽&lt;/span&gt;
&lt;span&gt; 85&lt;/span&gt;       &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.width &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; width &lt;/span&gt;&lt;span&gt;||&lt;/span&gt; &lt;span&gt;20&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;       &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.height &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; height &lt;/span&gt;&lt;span&gt;||&lt;/span&gt; &lt;span&gt;20&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;小蛇的身体&lt;/span&gt;
&lt;span&gt; 88&lt;/span&gt;       &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.body &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; [
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt; &lt;span&gt;        {x: &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;, y: &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;, color: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;red&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;},&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;头&lt;/span&gt;
&lt;span&gt; 90&lt;/span&gt; &lt;span&gt;        {x: &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;, y: &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;, color: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;orange&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;},&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;身体&lt;/span&gt;
&lt;span&gt; 91&lt;/span&gt; &lt;span&gt;        {x: &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;, y: &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;, color: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;orange&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;身体&lt;/span&gt;
&lt;span&gt; 92&lt;/span&gt; &lt;span&gt;      ];
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;方向&lt;/span&gt;
&lt;span&gt; 94&lt;/span&gt;       &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.direction &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; direction &lt;/span&gt;&lt;span&gt;||&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;right&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt; 
&lt;span&gt; 97&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;为原型添加方法--小蛇初始化的方法&lt;/span&gt;
&lt;span&gt; 98&lt;/span&gt; &lt;span&gt;    Snake.prototype.init &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (map) {
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;先删除之前的小蛇&lt;/span&gt;
&lt;span&gt;100&lt;/span&gt; &lt;span&gt;      remove();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;===========================================&lt;/span&gt;
&lt;span&gt;101&lt;/span&gt; 
&lt;span&gt;102&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;循环遍历创建div&lt;/span&gt;
&lt;span&gt;103&lt;/span&gt;       &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (&lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; i &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;; i &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.body.length; i&lt;/span&gt;&lt;span&gt;++&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;数组中的每个数组元素都是一个对象&lt;/span&gt;
&lt;span&gt;105&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt;&lt;span&gt; obj &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.body[i];
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建div&lt;/span&gt;
&lt;span&gt;107&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt;&lt;span&gt; div &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; document.createElement(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;把div加入到map地图中&lt;/span&gt;
&lt;span&gt;109&lt;/span&gt; &lt;span&gt;        map.appendChild(div);
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置div的样式&lt;/span&gt;
&lt;span&gt;111&lt;/span&gt; &lt;span&gt;        div.style.position &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;absolute&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt; &lt;span&gt;        div.style.width &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.width &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;px&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt; &lt;span&gt;        div.style.height &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.height &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;px&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;横纵坐标&lt;/span&gt;
&lt;span&gt;115&lt;/span&gt; &lt;span&gt;        div.style.left &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; obj.x &lt;/span&gt;&lt;span&gt;*&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.width &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;px&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt; &lt;span&gt;        div.style.top &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; obj.y &lt;/span&gt;&lt;span&gt;*&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.height &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;px&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;背景颜色&lt;/span&gt;
&lt;span&gt;118&lt;/span&gt; &lt;span&gt;        div.style.backgroundColor &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; obj.color;
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;方向暂时不定&lt;/span&gt;
&lt;span&gt;120&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;把div加入到elements数组中----目的是为了删除&lt;/span&gt;
&lt;span&gt;121&lt;/span&gt; &lt;span&gt;        elements.push(div);
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt; &lt;span&gt;    };
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt; 
&lt;span&gt;125&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;为原型添加方法---小蛇动起来&lt;/span&gt;
&lt;span&gt;126&lt;/span&gt; &lt;span&gt;    Snake.prototype.move &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (food, map) {
&lt;/span&gt;&lt;span&gt;127&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;改变小蛇的身体的坐标位置&lt;/span&gt;
&lt;span&gt;128&lt;/span&gt;       &lt;span&gt;var&lt;/span&gt;&lt;span&gt; i &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.body.length &lt;/span&gt;&lt;span&gt;-&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;
&lt;span&gt;129&lt;/span&gt;       &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (; i &lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;; i&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.body[i].x &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.body[i &lt;/span&gt;&lt;span&gt;-&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;].x;
&lt;/span&gt;&lt;span&gt;131&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.body[i].y &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.body[i &lt;/span&gt;&lt;span&gt;-&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;].y;
&lt;/span&gt;&lt;span&gt;132&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断方向---改变小蛇的头的坐标位置&lt;/span&gt;
&lt;span&gt;134&lt;/span&gt;       &lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.direction) {
&lt;/span&gt;&lt;span&gt;135&lt;/span&gt;         &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;right&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;136&lt;/span&gt;           &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.body[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;].x &lt;/span&gt;&lt;span&gt;+=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;137&lt;/span&gt;           &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;138&lt;/span&gt;         &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;left&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;139&lt;/span&gt;           &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.body[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;].x &lt;/span&gt;&lt;span&gt;-=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;140&lt;/span&gt;           &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;141&lt;/span&gt;         &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;top&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;142&lt;/span&gt;           &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.body[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;].y &lt;/span&gt;&lt;span&gt;-=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;143&lt;/span&gt;           &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;144&lt;/span&gt;         &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bottom&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;145&lt;/span&gt;           &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.body[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;].y &lt;/span&gt;&lt;span&gt;+=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;146&lt;/span&gt;           &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;147&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;148&lt;/span&gt; 
&lt;span&gt;149&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断有没有吃到食物&lt;/span&gt;
&lt;span&gt;150&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;小蛇的头的坐标和食物的坐标一致&lt;/span&gt;
&lt;span&gt;151&lt;/span&gt;       &lt;span&gt;var&lt;/span&gt;&lt;span&gt; headX&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.body[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;].x&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.width;
&lt;/span&gt;&lt;span&gt;152&lt;/span&gt;       &lt;span&gt;var&lt;/span&gt;&lt;span&gt; headY&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.body[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;].y&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.height;
&lt;/span&gt;&lt;span&gt;153&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断小蛇的头的坐标和食物的坐标是否相同&lt;/span&gt;
&lt;span&gt;154&lt;/span&gt;       &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(headX&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;food.x&lt;/span&gt;&lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span&gt;headY&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;food.y){
&lt;/span&gt;&lt;span&gt;155&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取小蛇的最后-的尾巴&lt;/span&gt;
&lt;span&gt;156&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt;&lt;span&gt; last&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.body[&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.body.length&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;157&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;把最后的蛇尾复制一个,重新的加入到小蛇的body中&lt;/span&gt;
&lt;span&gt;158&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.body.push({
&lt;/span&gt;&lt;span&gt;159&lt;/span&gt; &lt;span&gt;          x:last.x,
&lt;/span&gt;&lt;span&gt;160&lt;/span&gt; &lt;span&gt;          y:last.y,
&lt;/span&gt;&lt;span&gt;161&lt;/span&gt; &lt;span&gt;          color:last.color
&lt;/span&gt;&lt;span&gt;162&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt;163&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;把食物删除,重新初始化食物&lt;/span&gt;
&lt;span&gt;164&lt;/span&gt; &lt;span&gt;        food.init(map);
&lt;/span&gt;&lt;span&gt;165&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;166&lt;/span&gt; &lt;span&gt;    };
&lt;/span&gt;&lt;span&gt;167&lt;/span&gt; 
&lt;span&gt;168&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除小蛇的私有的函数=============================================================================&lt;/span&gt;
&lt;span&gt;169&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; remove() {
&lt;/span&gt;&lt;span&gt;170&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除map中的小蛇的每个div,同时删除elements数组中的每个元素,从蛇尾向蛇头方向删除div&lt;/span&gt;
&lt;span&gt;171&lt;/span&gt;       &lt;span&gt;var&lt;/span&gt;&lt;span&gt; i &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; elements.length &lt;/span&gt;&lt;span&gt;-&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;172&lt;/span&gt;       &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (; i &lt;/span&gt;&lt;span&gt;&amp;gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;; i&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;173&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;先从当前的子元素中找到该子元素的父级元素,然后再弄死这个子元素&lt;/span&gt;
&lt;span&gt;174&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt;&lt;span&gt; ele &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; elements[i];
&lt;/span&gt;&lt;span&gt;175&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;从map地图上删除这个子元素div&lt;/span&gt;
&lt;span&gt;176&lt;/span&gt; &lt;span&gt;        ele.parentNode.removeChild(ele);
&lt;/span&gt;&lt;span&gt;177&lt;/span&gt; &lt;span&gt;        elements.splice(i, &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;178&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;179&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;180&lt;/span&gt; 
&lt;span&gt;181&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;把Snake暴露给window,外部可以访问&lt;/span&gt;
&lt;span&gt;182&lt;/span&gt; &lt;span&gt;    window.Snake &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; Snake;
&lt;/span&gt;&lt;span&gt;183&lt;/span&gt; &lt;span&gt;  }());
&lt;/span&gt;&lt;span&gt;184&lt;/span&gt; 
&lt;span&gt;185&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;自调用函数---游戏对象================================================&lt;/span&gt;
&lt;span&gt;186&lt;/span&gt; &lt;span&gt;  (&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt;187&lt;/span&gt; 
&lt;span&gt;188&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt;&lt;span&gt; that &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;该变量的目的就是为了保存游戏Game的实例对象-------&lt;/span&gt;
&lt;span&gt;189&lt;/span&gt; 
&lt;span&gt;190&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;游戏的构造函数&lt;/span&gt;
&lt;span&gt;191&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; Game(map) {
&lt;/span&gt;&lt;span&gt;192&lt;/span&gt;       &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.food &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Food();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;食物对象&lt;/span&gt;
&lt;span&gt;193&lt;/span&gt;       &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.snake &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Snake();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;小蛇对象&lt;/span&gt;
&lt;span&gt;194&lt;/span&gt;       &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.map &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; map;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;地图&lt;/span&gt;
&lt;span&gt;195&lt;/span&gt; &lt;span&gt;      that &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存当前的实例对象到that变量中-----------------此时that就是this&lt;/span&gt;
&lt;span&gt;196&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;197&lt;/span&gt; 
&lt;span&gt;198&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化游戏-----可以设置小蛇和食物显示出来&lt;/span&gt;
&lt;span&gt;199&lt;/span&gt; &lt;span&gt;    Game.prototype.init &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt;200&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化游戏&lt;/span&gt;
&lt;span&gt;201&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;食物初始化&lt;/span&gt;
&lt;span&gt;202&lt;/span&gt;       &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.food.init(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.map);
&lt;/span&gt;&lt;span&gt;203&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;小蛇初始化&lt;/span&gt;
&lt;span&gt;204&lt;/span&gt;       &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.snake.init(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.map);
&lt;/span&gt;&lt;span&gt;205&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用自动移动小蛇的方法========================||调用了小蛇自动移动的方法&lt;/span&gt;
&lt;span&gt;206&lt;/span&gt;       &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.runSnake(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.food, &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.map);
&lt;/span&gt;&lt;span&gt;207&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用按键的方法&lt;/span&gt;
&lt;span&gt;208&lt;/span&gt;       &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.bindKey();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;========================================&lt;/span&gt;
&lt;span&gt;209&lt;/span&gt; &lt;span&gt;    };
&lt;/span&gt;&lt;span&gt;210&lt;/span&gt; 
&lt;span&gt;211&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加原型方法---设置小蛇可以自动的跑起来&lt;/span&gt;
&lt;span&gt;212&lt;/span&gt; &lt;span&gt;    Game.prototype.runSnake &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (food, map) {
&lt;/span&gt;&lt;span&gt;213&lt;/span&gt; 
&lt;span&gt;214&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;自动的去移动&lt;/span&gt;
&lt;span&gt;215&lt;/span&gt;       &lt;span&gt;var&lt;/span&gt;&lt;span&gt; timeId &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; setInterval(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt;216&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;此时的this是window&lt;/span&gt;
&lt;span&gt;217&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;移动小蛇&lt;/span&gt;
&lt;span&gt;218&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.snake.move(food, map);
&lt;/span&gt;&lt;span&gt;219&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化小蛇&lt;/span&gt;
&lt;span&gt;220&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.snake.init(map);
&lt;/span&gt;&lt;span&gt;221&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;横坐标的最大值&lt;/span&gt;
&lt;span&gt;222&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt;&lt;span&gt; maxX &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; map.offsetWidth &lt;/span&gt;&lt;span&gt;/&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.snake.width;
&lt;/span&gt;&lt;span&gt;223&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;纵坐标的最大值&lt;/span&gt;
&lt;span&gt;224&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt;&lt;span&gt; maxY &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; map.offsetHeight &lt;/span&gt;&lt;span&gt;/&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.snake.height;
&lt;/span&gt;&lt;span&gt;225&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;小蛇的头的坐标&lt;/span&gt;
&lt;span&gt;226&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt;&lt;span&gt; headX &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.snake.body[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;].x;
&lt;/span&gt;&lt;span&gt;227&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt;&lt;span&gt; headY &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.snake.body[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;].y;
&lt;/span&gt;&lt;span&gt;228&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;横坐标&lt;/span&gt;
&lt;span&gt;229&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (headX &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;||&lt;/span&gt;&lt;span&gt; headX &lt;/span&gt;&lt;span&gt;&amp;gt;=&lt;/span&gt;&lt;span&gt; maxX) {
&lt;/span&gt;&lt;span&gt;230&lt;/span&gt;           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;撞墙了,停止定时器&lt;/span&gt;
&lt;span&gt;231&lt;/span&gt; &lt;span&gt;          clearInterval(timeId);
&lt;/span&gt;&lt;span&gt;232&lt;/span&gt; &lt;span&gt;          alert(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;游戏结束&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;233&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;234&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;纵坐标&lt;/span&gt;
&lt;span&gt;235&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (headY &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;||&lt;/span&gt;&lt;span&gt; headY &lt;/span&gt;&lt;span&gt;&amp;gt;=&lt;/span&gt;&lt;span&gt; maxY) {
&lt;/span&gt;&lt;span&gt;236&lt;/span&gt;           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;撞墙了,停止定时器&lt;/span&gt;
&lt;span&gt;237&lt;/span&gt; &lt;span&gt;          clearInterval(timeId);
&lt;/span&gt;&lt;span&gt;238&lt;/span&gt; &lt;span&gt;          alert(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;游戏结束&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;239&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;240&lt;/span&gt; &lt;span&gt;      }.bind(that), &lt;/span&gt;&lt;span&gt;150&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;241&lt;/span&gt; &lt;span&gt;    };
&lt;/span&gt;&lt;span&gt;242&lt;/span&gt; 
&lt;span&gt;243&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加原型方法---设置用户按键,改变小蛇移动的方向&lt;/span&gt;
&lt;span&gt;244&lt;/span&gt; &lt;span&gt;    Game.prototype.bindKey&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt;245&lt;/span&gt; 
&lt;span&gt;246&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取用户的按键,改变小蛇的方向&lt;/span&gt;
&lt;span&gt;247&lt;/span&gt; &lt;span&gt;      document.addEventListener(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;keydown&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (e) {
&lt;/span&gt;&lt;span&gt;248&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里的this应该是触发keydown的事件的对象---document,&lt;/span&gt;
&lt;span&gt;249&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;所以,这里的this就是document&lt;/span&gt;
&lt;span&gt;250&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取按键的值&lt;/span&gt;
&lt;span&gt;251&lt;/span&gt;         &lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (e.keyCode){
&lt;/span&gt;&lt;span&gt;252&lt;/span&gt;           &lt;span&gt;case&lt;/span&gt; &lt;span&gt;37&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.snake.direction&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;left&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;253&lt;/span&gt;           &lt;span&gt;case&lt;/span&gt; &lt;span&gt;38&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.snake.direction&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;top&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;254&lt;/span&gt;           &lt;span&gt;case&lt;/span&gt; &lt;span&gt;39&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.snake.direction&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;right&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;255&lt;/span&gt;           &lt;span&gt;case&lt;/span&gt; &lt;span&gt;40&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.snake.direction&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bottom&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;256&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;257&lt;/span&gt; &lt;span&gt;      }.bind(that),&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;258&lt;/span&gt; &lt;span&gt;    };
&lt;/span&gt;&lt;span&gt;259&lt;/span&gt; 
&lt;span&gt;260&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;把Game暴露给window,外部就可以访问Game对象了&lt;/span&gt;
&lt;span&gt;261&lt;/span&gt; &lt;span&gt;    window.Game &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; Game;
&lt;/span&gt;&lt;span&gt;262&lt;/span&gt; &lt;span&gt;  }());
&lt;/span&gt;&lt;span&gt;263&lt;/span&gt; 
&lt;span&gt;264&lt;/span&gt; 
&lt;span&gt;265&lt;/span&gt; 
&lt;span&gt;266&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化游戏对象&lt;/span&gt;
&lt;span&gt;267&lt;/span&gt;   &lt;span&gt;var&lt;/span&gt;&lt;span&gt; gm &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Game(document.querySelector(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.map&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;268&lt;/span&gt; 
&lt;span&gt;269&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化游戏---开始游戏&lt;/span&gt;
&lt;span&gt;270&lt;/span&gt; &lt;span&gt;  gm.init();
&lt;/span&gt;&lt;span&gt;271&lt;/span&gt; 
&lt;span&gt;272&lt;/span&gt; 
&lt;span&gt;273&lt;/span&gt;  
&lt;span&gt;274&lt;/span&gt; 
&lt;span&gt;275&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;276&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;277&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;如下图：单个方块表示食物，三个方块连接一起表示小蛇，其中紫色方块是蛇头，虽然看起来简单，做起来也需要不少的步骤，我们先分析一下思路~&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1535212/201812/1535212-20181223132821503-1898544085.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;首先，创建一个地图~然后坐标随机显示食物方块，每次食物被小蛇“吃掉”的时候重新初始化；&lt;/p&gt;
&lt;p&gt;然后，设置固定位置显示小蛇方块，设置定时器，让小蛇动起来，判断小蛇是否“吃掉”食物，是则初始化食物，复制蛇身最后一个方块加到小蛇身体最后~判断小蛇是否“撞墙”，是则提示游戏提示。&lt;/p&gt;
&lt;p&gt;那么具体步骤现在开始~&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;设置食物方块的自调用函数&lt;/span&gt;&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;设置方块的构造函数，同时设置一个变量准备存储每个小方块食物：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code _mce_tagged_br&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;(function () {
    var elements = [];
   
    function Food(x, y, width, height, color) {
      this.x = x || 0;
      this.y = y || 0;
      this.width = width || 20;
      this.height = height || 20;
      this.color = color || &quot;green&quot;;
    }&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
//把Food暴露给window,外部可以访问&lt;br/&gt;window.Food = Food;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;}());&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;初始化食物，赋值并且在地图上显示出来，注意：记得把食物加到一开始设置的变量中 &lt;span&gt;var elements = [ ];&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Food.prototype.init = function (map) {
      remove();

      var div = document.createElement(&quot;div&quot;);
      map.appendChild(div);
      div.style.width = this.width + &quot;px&quot;;
      div.style.height = this.height + &quot;px&quot;;
      div.style.backgroundColor = this.color;
      div.style.position = &quot;absolute&quot;;
      this.x = parseInt(Math.random() * (map.offsetWidth / this.width)) * this.width;
      this.y = parseInt(Math.random() * (map.offsetHeight / this.height)) * this.height;
      div.style.left = this.x + &quot;px&quot;;
      div.style.top = this.y + &quot;px&quot;;

      //把div加入到数组elements中
      elements.push(div);
    };&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;设置初始化食物的第一个步骤，先在地图上删除这个食物：&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code _mce_tagged_br&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; function remove() {
      for (var i = 0; i &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt; elements&lt;/span&gt;&lt;span&gt;.length; i++) {
        var ele &lt;/span&gt;&lt;span&gt;= elements[i];
        &lt;/span&gt;&lt;span&gt;ele.parentNode.removeChild(ele);
        elements.splice(i, 1);
      }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;设置小蛇的自调用函数&lt;/span&gt;&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;设置方块的构造函数，同时设置一个变量准备存储每个小蛇的单个身体：&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;(function () {
    var elements = [];
 function Snake(width, height, direction) {
      this.width = width || 20;
      this.height = height || 20;
      this.body = [
        {x: 3, y: 2, color: &quot;red&quot;},//头
        {x: 2, y: 2, color: &quot;orange&quot;},//身体
        {x: 1, y: 2, color: &quot;orange&quot;}//身体
      ];
      //方向
      this.direction = direction || &quot;right&quot;;
    }&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
//把Snake暴露给window,外部可以访问&lt;br/&gt;window.Snake = Snake;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;}());&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;设置小蛇初始化的函数&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code _mce_tagged_br&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; Snake.prototype.init = function (map) {
      //先删除之前的小蛇
      remove();
      for (var i = 0; i &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt; this&lt;/span&gt;&lt;span&gt;.body.length; i++) {
        var obj &lt;/span&gt;&lt;span&gt;= this.body[i];
        &lt;/span&gt;&lt;span&gt;var div &lt;/span&gt;&lt;span&gt;= document.createElement(&quot;div&quot;);
        &lt;/span&gt;&lt;span&gt;map.appendChild(div);
        div.style.position &lt;/span&gt;&lt;span&gt;= &quot;absolute&quot;&lt;/span&gt;&lt;span&gt;;
        div.style.width &lt;/span&gt;&lt;span&gt;= this.width &lt;/span&gt;&lt;span&gt;+ &quot;px&quot;;
        div.style.height &lt;/span&gt;&lt;span&gt;= this.height &lt;/span&gt;&lt;span&gt;+ &quot;px&quot;;
        div.style.left &lt;/span&gt;&lt;span&gt;= obj.x &lt;/span&gt;&lt;span&gt;* this.width + &quot;px&quot;;
        div.style.top &lt;/span&gt;&lt;span&gt;= obj.y &lt;/span&gt;&lt;span&gt;* this.height + &quot;px&quot;;
        div.style.backgroundColor &lt;/span&gt;&lt;span&gt;= obj.color
        &lt;/span&gt;&lt;span&gt;//把div加入到elements数组中----目的是为了删除
        elements.push(div);
      }
    };&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;设置小蛇动起来的函数：
&lt;ul&gt;&lt;li&gt;让小蛇动起来相当于是改变了小蛇的坐标&lt;/li&gt;
&lt;li&gt;判断小蛇动起来的方向，然后坐标对应处理&lt;/li&gt;
&lt;li&gt;判断小蛇是否“吃到”了食物，是则初始化食物，并且把蛇身最后一个部分复制一分加到蛇身最后&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Snake.prototype.move = function (food, map) {
      //改变小蛇的身体的坐标位置
      var i = this.body.length - 1;//2
      for (; i &amp;gt; 0; i--) {
        this.body[i].x = this.body[i - 1].x;
        this.body[i].y = this.body[i - 1].y;
      }
      
      switch (this.direction) {
        case &quot;right&quot;:
          this.body[0].x += 1;
          break;
        case &quot;left&quot;:
          this.body[0].x -= 1;
          break;
        case &quot;top&quot;:
          this.body[0].y -= 1;
          break;
        case &quot;bottom&quot;:
          this.body[0].y += 1;
          break;
      }

      var headX=this.body[0].x*this.width;
      var headY=this.body[0].y*this.height;
     
      if(headX==food.x&amp;amp;&lt;/span&gt;&lt;span&gt;&amp;amp;headY&lt;/span&gt;&lt;span&gt;==food.y){
      
        var last=this.body[this.body.length-1];
        
        this.body.push({
          x:last.x,
          y:last.y,
          color:last.color
        });
        //把食物删除,重新初始化食物
        food.init(map);
      }
    };&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;不要忘记设置初始化小蛇的第一个步骤，在地图上删除这个小蛇：&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; function remove() {
      var i = elements.length - 1;
      for (; i &amp;gt;= 0; i--) {
        var ele = elements[i];
        ele.parentNode.removeChild(ele);
        elements.splice(i, 1);
      }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;&lt;span&gt;设置游戏的自调用函数：&lt;/span&gt;&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;设置游戏的构造函数，同时设置一个变量准备存储游戏Game的实例对象：&lt;span&gt;var that=this；&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; (function () {
    var that = null;//该变量的目的就是为了保存游戏Game的实例对象------
    function Game(map) {
      this.food = new Food();//食物对象
      this.snake = new Snake();//小蛇对象
      this.map = map;//地图
      that = this;//保存当前的实例对象到that变量中------此时that就是this
    }

    //把Game暴露给window,外部就可以访问Game对象了
    window.Game = Game;
  }());&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;初始化游戏：可以设置小蛇和食物显示出来&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; Game.prototype.init = function () {
      
      this.food.init(this.map);
     
      this.snake.init(this.map);
     
      this.runSnake(this.food, this.map);
     
      this.bindKey();
    };&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;设置小蛇可以自动的跑起来&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Game.prototype.runSnake = function (food, map) {

      var timeId = setInterval(function () {
        
        this.snake.move(food, map);
        this.snake.init(map);
        
        var maxX = map.offsetWidth / this.snake.width;
        var maxY = map.offsetHeight / this.snake.height;
     
        var headX = this.snake.body[0].x;
        var headY = this.snake.body[0].y;
        
        if (headX &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt; 0 &lt;/span&gt;&lt;span&gt;|| headX &lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;= maxX) {
          //撞墙了,停止定时器
          clearInterval(timeId);
          alert(&quot;游戏结束&quot;);
        }
        
        if (headY &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt; 0 &lt;/span&gt;&lt;span&gt;|| headY &lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;= maxY) {
          //撞墙了,停止定时器
          clearInterval(timeId);
          alert(&quot;游戏结束&quot;);
        }
      }.bind(that), 150);
    };&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;设置用户按键,改变小蛇移动的方向&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code _mce_tagged_br&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; Game.prototype.bindKey=function () {

      document.addEventListener(&quot;keydown&quot;,function (e) {
         switch (e.keyCode){
          case 37:this.snake.direction=&quot;left&quot;;break;
          case 38:this.snake.direction=&quot;top&quot;;break;
          case 39:this.snake.direction=&quot;right&quot;;break;
          case 40:this.snake.direction=&quot;bottom&quot;;break;
        }
      }.bind(that),false);
    };&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;初始化游戏对象，开始游戏&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var gm = new Game(document.querySelector(&quot;.map&quot;));
gm.init();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;好的，到这里结束啦~&lt;/p&gt;
&lt;p&gt;另外如果有前端学习者想要寻找伙伴一起合作项目，可以来我这个群~群内还有大神等你哈哈哈~&lt;/p&gt;
&lt;p&gt;&lt;span&gt;前端学习交流群 883726280 &lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 23 Dec 2018 07:19:00 +0000</pubDate>
<dc:creator>xhysns</dc:creator>
<og:description>本次练习所有的代码：可以直接复制全部然后运行看效果~ 1 &lt;!DOCTYPE html&gt; 2 &lt;html lang=&quot;en&quot;&gt; 3 &lt;head&gt;</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xhysns/p/10164418.html</dc:identifier>
</item>
<item>
<title>synchronized底层实现学习 - 木瓜芒果</title>
<link>http://www.cnblogs.com/volcano-liu/p/10136272.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/volcano-liu/p/10136272.html</guid>
<description>&lt;p&gt;　　&lt;a href=&quot;https://www.cnblogs.com/volcano-liu/p/10131149.html&quot; target=&quot;_blank&quot;&gt;上文&lt;/a&gt;我们总结了 synchronized 关键字的基本用法以及作用，并未涉及 synchronized 底层是如何实现的，所谓刨根问底，本文我们就开始 synchronized 原理的探索之旅吧(*&amp;gt;﹏&amp;lt;*)。&lt;/p&gt;

&lt;h2&gt;1. 对象锁是什么&lt;/h2&gt;
&lt;p&gt; 　　不同于ReentrantLock的显式加锁，synchronized 的加锁方式属于隐式加锁，从代码中看我们只知道当线程执行到被synchronized包围的代码块时会获取锁，那这把锁到底是什么？如何获取？其实在前面的学习中，我们可以有个直观的感觉，这把锁是一个对象(类的当前实例对象、类的class对象或者指定的某个任意对象)，但是是这样吗？&lt;/p&gt;
&lt;p&gt;　　既然锁和对象有很大关系，那我们不妨考虑一下对象，什么是Java对象？&lt;/p&gt;
&lt;p&gt;　　我的回答是存在于虚拟机堆上的一系列字节，我觉可以从这个层面来解释。在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头(Header)、实例数据(Instance Data)、对其填充(Padding)。其中，对象头包括两部分(有关这部分的详细内容总结见--&lt;a href=&quot;https://www.cnblogs.com/volcano-liu/p/9363049.html&quot; target=&quot;_blank&quot;&gt;Java读书笔记之内存管理&lt;/a&gt;)：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一部分用于存储对象自身的运行时数据，如哈希码、GC分代年龄、&lt;strong&gt;锁状态标志&lt;/strong&gt;、&lt;strong&gt;线程持有的锁&lt;/strong&gt;、偏向线程ID、偏向时间戳等；&lt;/li&gt;
&lt;li&gt;第二部分是类型指针，指向该对象的类的元数据的指针；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　看到了吗，锁相关的信息其实是存储在对象头中，在对象处于各种状态下(未锁定、轻量级锁定、重量级锁定、GC标记、偏斜锁)对象头中存储的内容见下表：&lt;/p&gt;
&lt;table border=&quot;0&quot; align=&quot;center&quot;&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;存储内容&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;标志位&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;状态&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;对象哈希码、对象分代年龄&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;01 &lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;未锁定 &lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;指向锁记录的指针 &lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;00 &lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;轻量级锁定 &lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;strong&gt;&lt;span&gt;指向重量级锁的指针 &lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;10 &lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;膨胀(重量级锁定) &lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;空，不需要记录信息 &lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;11 &lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;GC标记 &lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;偏向线程ID、偏向时间戳、对象分代年龄 &lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;01 &lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;可偏向 &lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;　　当对象处于重量级锁定时(为了简单起见，我们暂且考虑这一种情况，后文有更详细论述不同级别的锁)对象头中存储的内容是指向重量级锁的指针(我们暂且先忽略重量级)，也就是说，对象头中存有一个指针，指向一把锁，这把锁也就是synchronized的对象锁，这其实是一个monitor对象(C++实现)，里面会记录获取锁的线程以及竞争线程的一些相关信息，我们可以大致了解一下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;ObjectMonitor(){
   _&lt;/span&gt;&lt;span&gt;count&lt;/span&gt;         &lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
   _owner         &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;;
   _WaitSet       &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;;
   _WaitSetLock   &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
   _EntryList     &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;;  
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在HotSpot中，monitor是由ObjectMonitor实现的，如上是其中的几个关键属性，当多个线程访问同一段同步代码时，会将其先存放到_EntryList队列中，当某个线程获取到对象的monitor后会将_owner变量设置为指向持有ObjectMonitor对象的线程也就是当前线程，同时_count会加1，如果线程调用wait()则会释放持有的monitor，_owner会被置为null，_count减1，并且该线程进入_WaitSet队列中，等待下一次被唤醒。若当前执行完毕，也将释放monitor，同时_ownner置空，_count减1，线程退出。&lt;/p&gt;

&lt;h2&gt;2. 如何加锁&lt;/h2&gt;
&lt;p&gt; 　　现在我们知道synchronized所使用的对象锁是什么东西了(虽然monitor是基于C++实现的，而本文并没有深入到C++源码级别来探讨monitor的实现原理O__O&quot;)，至少有了一个更直观上的认识，我们可以从字节码层面来看一下加了synchronized关键字后多了什么操作。&lt;/p&gt;
&lt;p&gt; 　　这里先写一个小demo：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; class STest {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; static void main(String&lt;span&gt;[]&lt;/span&gt;&lt;span&gt; args) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i &lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        synchronized(STest.class) {
            i&lt;/span&gt;&lt;span&gt;++&lt;/span&gt;&lt;span&gt;;
        }
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; synchronized void testMethod() {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i &lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        i &lt;/span&gt;&lt;span&gt;++&lt;/span&gt;&lt;span&gt; ;
    }   
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　然后进入cmd命令窗口，在对应class文件所在目录下输入:javap -verbose STest，输出字节码文件如下(这里只截取了部分)：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;public&lt;/span&gt; static void main(java.lang.String&lt;span&gt;[]&lt;/span&gt;&lt;span&gt;);
    descriptor: (&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=3, args_size=1
         0: iconst_0
         1: istore_1
         2: ldc           #1                  // class testPackage/STest
         4: dup
         5: astore_2
         6: monitorenter
         7: iinc          1, 1
        10: aload_2
        11: monitorexit
        12: goto          18
        15: aload_2
        16: monitorexit
        17: athrow
        18: return
      Exception table:
         from    to  target type
         。。。
        
  public synchronized void testMethod();
    descriptor: ()V
    flags: ACC_PUBLIC, ACC_SYNCHRONIZED
    Code:
      stack=1, locals=2, args_size=1
         0: iconst_0
         1: istore_1
         2: iinc          1, 1
         5: return
      LineNumberTable:
        line 12: 0
        。。。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在main方法中有一个同步代码块，里面完成了一个自增操作，对应的字节码是第6行的monitorenter和第11以及16行的monitorexit这两个指令，所以被同步块包围的代码在生成字节码时会被monitorenter、monitorexit这对指令包围，我们可以理解为线程执行到monitorenter时会获取锁，执到monitorexit时则会释放锁。&lt;strong&gt;JVM会保证每一个monitorenter指令都有一个monitorexit指令与之相对应&lt;/strong&gt;，即只要获取锁就有释放锁操作与之对应。&lt;/p&gt;
&lt;p&gt; 　　而对于方法testMethod()，字节码中并没有出现monitorenter和monitorexit这对指令，对于被synchronized修饰的方法，JVM是通过标识符ACC_SYNCHRONIZED该方法是一个同步方法，从而执行如上类似的操作。&lt;/p&gt;

&lt;h2&gt;3. synchronized如何保证线程安全&lt;/h2&gt;
&lt;p&gt;　　好了，现在我们清楚了synchronized使用的锁是什么以及虚拟机在字节码层面是如何实现加锁以及释放锁的，我们再来理解synchronized是如何保证原子性、可见性以及有序性就更容易了。&lt;/p&gt;
&lt;h3&gt;原子性&lt;/h3&gt;
&lt;p&gt;　　当一个线程获取一把锁(执行monitorenter指令)后，其他线程如果尝试获取同一把锁则会阻塞，直到锁被释放(执行monitorexit并且_count值减为0)才会重新获取锁，获取锁成功的线程则会开始执行同步代码，这就保证了同一时刻只有一个线程在执行一段代码，并且从线程获取锁到释放锁这个过程中，该线程是不会被其他线程打断的，这也就保证了线程在执行这段代码时的原子性。&lt;/p&gt;
&lt;h3&gt;可见性&lt;/h3&gt;
&lt;p&gt; 　　同步块保证可见性主要是通过：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;线程获取锁时，JVM会把该线程对应的被同步块保护的共享变量在本地的副本置为无效，并从主存中读取；&lt;/li&gt;
&lt;li&gt;线程释放锁时，JVM会把该线程对应的被同步块保护的共享变量从本地内存中更新到主内存中；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　这就使得程序进入同步块时，从主存中获取共享变量最新数据至线程本地副本，退出同步块时将共享变量本地副本更新至主存中，从而保证可见性。&lt;/p&gt;
&lt;h3&gt;有序性&lt;/h3&gt;
&lt;p&gt; 　　关于有序性，synchronized的实现方式和volatile关键字是不一样的，前者是关键字本身就有禁止指令重排序的语义，而synchronized是靠“一个变量同一时刻只允许一条线程对其进行lock操作”这条规则来保证线程操作之间的有序性，可以理解为持有同一把锁的两个同步块只能串行地进入。我们先举一个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;线程1:
context &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; loadContext();   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;语句1
inited &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; true;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;语句2
 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;线程2:
&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt;(!inited ){
  sleep();
}
doSomethingwithconfig(context);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面代码中，由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此时线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，但此时context可能并没有初始化完成，就会导致程序出错。&lt;/p&gt;
&lt;p&gt;　　这里如果给变量inited添加volatile关键字修饰，就可以解决问题，但是如果用synchronized怎么解决呢？我的理解是对inited的赋值操作通过同步块来保护，因为在线程获取synchronized锁时会强制将本地的变量更新回主存中，对应如上代码就是会将context更新回内存中，这代表context已经载入了，当退出synchronized时会把inited更新回主存中，所以线程2监控到inited为true的时候context已经初始化完毕了，再执行doSomethingwithconfig就没有问题了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;线程1:
context &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; loadContext();   　　　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;语句1
synchronized(Object.class){
     inited &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; true;              &lt;span&gt;//&lt;/span&gt;&lt;span&gt;语句2
}
 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;线程2:
&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt;(!inited ){
  sleep();
}
doSomethingwithconfig(context);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;4. synchronized优化&lt;/h2&gt;
&lt;p&gt;　　前面我们我到synchronized经过编译之后，会在同步块的前后分别形成monitorenter和monitorexit这两个字节码指令，在执行monitorenter时，会尝试获取对象的锁，如果成功就执行同步块中的代码，在锁被释放前，其他试图获取锁的线程将阻塞。而Java的线程是映射到操作系统的原生线程之上的，如果要阻塞或唤醒一个线程，都需要操作系统来帮忙，这需要从用户态转换到核心态中，这会耗费很多的处理器时间，是一个重量级操作，所以JDK1.5以后，JVM对此进行了大刀阔斧的改进，如自旋锁(Adaptive Spinning)、锁消除(Lock Elimination)、锁粗化(Lock Coarsening)、偏斜锁(Biased Locking)、轻量级锁(Lightweight Locking)等。这些技术都是为了在线程间更高效地共享数据，以及解决竞争问题，从而提高程序的执行效率。&lt;/p&gt;
&lt;h3&gt;自旋锁&lt;/h3&gt;
&lt;p&gt; 　　在利用synchronized进行线程间互斥同步时，阻塞的实现是一个很耗性能的操作，这会给系统的并发性能带来很大压力。并且在许多应用上，共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和恢复线程并不值得。如果物理机器有一个以上的处理器，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程“稍等一下”，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只需让线程执行一个忙循环(自旋)，这项技术就是所谓的自旋。&lt;/p&gt;
&lt;p&gt;　　自旋等待本身虽然避免了线程切换的开销，但是它是要占用CPU时间的，如果锁被占用的时间很长，那只会白白消耗处理器资源，反而会带来性能上的浪费，因此自旋等待的时间必须要有一定的限度，超过一定次数就应该使用传统方式来挂起线程，默认值是10次，可以使用参数-XX:PreBlockSpin来更改。&lt;/p&gt;
&lt;h3&gt;轻量级锁&lt;/h3&gt;
&lt;p&gt; 　　轻量级锁是JDK1.6之中加入的新型锁机制，它名字中的“轻量级“是相对于使用操作系统互斥量来实现的传统锁而言的(即我们马上要介绍的重量级锁)。&lt;/p&gt;
&lt;p&gt;　　要理解轻量级锁，以及后面会讲到的偏斜锁的原理和运作过程，必须了解虚拟机的对象(对象头部分)的内存布局，前面我们有提到。 对象头中包含用于存储对象自身的运行时数据，如哈希码(HashCode)、GC分代年龄(Generational GC Age)等，官方称它为“Mark Word”，它是实现偏斜锁和轻量级锁的关键。&lt;/p&gt;
&lt;p&gt;　　对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，Mark Word被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。例如，在32位的HotSpot虚拟机中对象未被锁定的状态下， Mark Word的32bit空间中的25bit用于存储对象哈希码(HashCode)，4bit用于存储对象分代年龄，2bit用于存储锁标志位，1bit固定为0，在其他状态下的详细存储内容见下表：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1335887/201812/1335887-20181223123058042-2071054723.jpg&quot; alt=&quot;&quot; width=&quot;500&quot; height=&quot;172&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　简单介绍完对象的内存布局后，我们再回到轻量级锁的执行过程上。在代码进入同步块的时候，如果此同步对象没有被锁定(锁标志位为“01”状态)，虚拟机首先将在当前线程的栈帧中建立一个名为锁记录(Lock Record)的空间，用于存储锁对象目前的Mark Word的拷贝(官方把这份拷贝加了一个Displaced前缀，即Displaced Mark Word)，这时候线程堆栈与对象头的状态如下图左侧所示：&lt;/p&gt;
&lt;p&gt;　　然后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针。如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位(Mark Word的最后2bit)将转变为“00”，即表示此对象处于轻量级锁定状态，这时候线程堆栈与对象头的状态如下图右侧所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1335887/201812/1335887-20181223120454809-358914515.jpg&quot; alt=&quot;&quot; width=&quot;900&quot; height=&quot;302&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　如果这个更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是，说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程抢占了。&lt;/p&gt;
&lt;p&gt;　　上面描述的是轻量级锁的加锁过程，它的解锁过程也是通过CAS操作来进行的，如果对象的Mark Word任然指向着线程的锁记录，那就用CAS操作将对象当前的Mark Word替换为获取锁时保存在线程栈帧中的Displaced Mark Word，如果替换成功，整个同步过程就完成了。如果替换失败，说明有其他线程尝试过获取该锁，那就要在释放锁的同时，唤醒被挂起的线程。&lt;/p&gt;
&lt;h3&gt;偏斜锁&lt;/h3&gt;
&lt;p&gt;　　偏斜锁是JDK1.6中引入的一项锁优化，它的目的是消除数据在无竞争情况下的同步原语，提高程序的运行性能。&lt;/p&gt;
&lt;p&gt;　　偏斜锁，顾名思义，就是这个锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏斜锁的线程将永远不需要再进行同步。&lt;/p&gt;
&lt;p&gt;　　假设当前虚拟机启用了偏斜锁(启用参数-xx:+Use Biased Locking，这是JDK1.6的默认值)，那么，当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设为“01”，即偏斜模式。同时使用CAS操作把获取到这个锁的线程的ID记录在对象的Mark Word之中，如果CAS操作成功，持有偏斜锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作(例如Locking、 Unlocking及对Mark Word的Update等)。&lt;br/&gt;　　当有另外一个线程去尝试获取这个锁时偏斜模式就宣告结束。根据锁对象目前是否处于被锁定的状态，撤销偏斜(Revoke Bias)后恢复到未锁定(标志位为“01”)或轻量级锁定(标志位为“00”)的状态，后续的同步操作就如上面介绍的轻量级锁那样执行。偏向锁、轻量级锁的状态转化及对象 Mark Word的关系如下图所示。&lt;/p&gt;
&lt;h3&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1335887/201812/1335887-20181223143105149-151095266.jpg&quot; alt=&quot;&quot; width=&quot;900&quot; height=&quot;395&quot;/&gt;&lt;/h3&gt;
&lt;h3&gt;重量级锁&lt;/h3&gt;
&lt;p&gt; 　　如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁，锁标志的状态值变为“10”，Mark Word中存储的就是指向重量级锁(互斥量)的指针，后面等待锁的线程也要进入阻塞状态。这里的重量级锁就是本开开头所说的monitor对象，早期的虚拟机中，synchronized的获取锁操作仅此一种，因为比较消耗性能，所以称为重量级锁，其获取过程上文有论述。&lt;/p&gt;

&lt;p&gt;　　综上，整个获取锁的过程可以总结如下(此处为个人理解，如有不对，欢迎指正^_^)：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如果虚拟机开启偏斜锁，会先获取偏斜锁，如果没有则会直接获取轻量级锁；&lt;/li&gt;
&lt;li&gt;这时如果有另一个线程尝试获取锁，首先它会自旋一定次数，如果自旋结束锁依旧没有释放，则它会尝试获取锁；&lt;/li&gt;
&lt;li&gt;这时步骤1中如果是获取的偏斜锁，则会升级成为轻量级锁，如果这是依然存在竞争，则会升级成为重量级锁；&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;5. 总结&lt;/h2&gt;
&lt;p&gt;　　本文我们学习了synchronized是如何实现的，有什么作用， 以及现代JVM对synchronized所做的优化。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;synchronized可以实现原子性、可见性、有序性；&lt;/li&gt;
&lt;li&gt;synchronized获取monitor是发生在进入同步块时执行monitorenter指令时；&lt;/li&gt;
&lt;li&gt;现代JVM对synchronized进行了大量优化，提供了三种不同的monitor实现：偏斜锁、轻量级锁、重量级锁；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　轻量级锁能提升程序同步性能的依据是“对于绝大部分的锁，在整个同步周期内都是不存在竞争的”，这是一个经验数据。如果没有竞争，轻量级锁使用CAS操作避免了使用互斥量的开销，但如果存在锁竞争，除了互斥量的开销外，还额外发生了CAS操作，因此在有竞争的情况下，轻量级锁会比传统的重量级锁更慢。&lt;/p&gt;
&lt;p&gt;　　轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。 &lt;/p&gt;
&lt;p&gt;　　如果说轻量级锁是在无竞争的情况下使用CAS操作去消除同步使用的互斥量，那偏斜锁就是在无竞争的情况下把整个同步都消除掉，连CAS操作都不做了。&lt;/p&gt;

&lt;h2&gt;参考文献：&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.hollischuang.com/archives/2030&quot; target=&quot;_blank&quot;&gt;Moniter的实现原理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;&amp;lt;深入理解Java虚拟机：JVM高级特性与最佳实践&amp;gt;&amp;gt;--周志明&lt;/p&gt;
</description>
<pubDate>Sun, 23 Dec 2018 07:18:00 +0000</pubDate>
<dc:creator>木瓜芒果</dc:creator>
<og:description>synchronized底层实现原理学习</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/volcano-liu/p/10136272.html</dc:identifier>
</item>
<item>
<title>iOS weak底层实现原理 - 国孩</title>
<link>http://www.cnblogs.com/guohai-stronger/p/10161870.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/guohai-stronger/p/10161870.html</guid>
<description>&lt;p&gt;今年年底做了很多决定，离开工作三年的深圳，来到了上海，发现深圳和上海在苹果这方面还是差距有点大的，上海的市场8成使用swift编程，而深圳8成的使用OC，这点还是比较让准备来上海打拼的苹果工程师有点小压力的。毕竟以后苹果还是swift使用的多，现在已经swift4.x了，所以早点接触，还是有优势的，不过。咱们闲话少说，今天我们将继续讲述OC修饰属性的一个Weak修饰符的底层实现，有时间我会花时间讲述swift4.x。&lt;/p&gt;

&lt;h2&gt;一、weak基本用法&lt;/h2&gt;
&lt;p&gt;weak是弱引用，用weak来修饰、描述所引用对象的计数器并不会加1，而且weak会在引用对象被释放的时候自动置为nil，这也就避免了野指针访问坏内存而引起奔溃的情况，另外weak也可以解决循环引用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;拓展：为什么修饰代理使用weak而不是用assign？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;assign可用来修饰基本数据类型，也可修饰OC的对象，但如果用assign修饰对象类型指向的是一个强指针，当指向的这个指针释放之后，它仍指向这块内存，必须要手动给置为nil，否则会产生野指针，如果还通过此指针操作那块内存，会导致EXC_BAD_ACCESS错误，调用了已经被释放的内存空间；而weak只能用来修饰OC对象，而且相比assign比较安全，如果指向的对象消失了，那么它会自动置为nil，不会导致野指针。&lt;/p&gt;

&lt;h2&gt;二、weak原理概括&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;weak表其实是一个哈希表，key是所指对象的指针，value是weak指针的地址数组。（value是数组的原因是：因为一个对象可能被多个弱引用指针指向）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Runtime维护了一张weak表，用来存储某个对象的所有的weak指针。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;weak原理实现过程三步骤&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;初始化开始时，会调用objc_initWeak函数，初始化新的weak指针指向对象的地址&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1305302/201812/1305302-20181223142049203-1519099878.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2.紧接着，&lt;strong&gt;objc_initWeak函数里面会调用objc_storeWeak() 函数，objc_storeWeak() 函数的作用是用来更新指针的指向，创建弱引用表。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1305302/201812/1305302-20181223142432744-402838496.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　3.&lt;strong&gt;在最后会调用clearDeallocating函数。而clearDeallocating函数首先根据对象的地址获取weak指针地址的数组，然后紧接着遍历这个数组，将其中的数组开始置为nil，把这个entry从weak表中删除，最后一步清理对象的记录。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;拓展：详细步骤&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;初始化开始时，会调用objc_initWeak函数，初始化新的weak指针指向对象的地址&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;当我们初始化weak变量时，runtime会调用NSObject.mm中的objc_initWeak，而objc_initWeak函数里面的实现如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;id&lt;/span&gt; objc_initWeak(&lt;span&gt;id&lt;/span&gt; *location, &lt;span&gt;id&lt;/span&gt;&lt;span&gt; newObj) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 查看对象实例是否有效,无效对象直接导致指针释放&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;newObj) {
        &lt;/span&gt;*location =&lt;span&gt; nil;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; nil;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里传递了三个 bool 数值
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用 template 进行常量参数传递是为了优化性能&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; storeWeakfalse&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;old&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;crash&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&amp;gt;&lt;span&gt;
    (location, (objc_object&lt;/span&gt;*&lt;span&gt;)newObj);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过上面代码可以看出，objc_initWeak（）函数首先判断指针指向的类对象是否有效，无效，直接返回；否则通过storeWeak（）被注册为一个指向value的_weak对象&lt;/p&gt;
&lt;p&gt;　　2. objc_initWeak函数里面会调用objc_storeWeak() 函数，objc_storeWeak() 函数的作用是用来更新指针的指向，创建弱引用表。&lt;/p&gt;
&lt;p&gt;　　3..在最后会调用clearDeallocating函数。而clearDeallocating函数首先根据对象的地址获取weak指针地址的数组，然后紧接着遍历这个数组，将其中的数组开始置为nil，把这个entry从weak表中删除，最后一步清理对象的记录。&lt;/p&gt;

&lt;p&gt;问：&lt;span&gt;当weak指向的对象被释放时，如何让weak指针置为nil的呢？&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;&lt;span&gt;、调用objc_release
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;、因为对象的引用计数为0，所以执行dealloc
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;、在dealloc中，调用了_objc_rootDealloc函数
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;、在_objc_rootDealloc中，调用了object_dispose函数
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;、调用objc_destructInstance
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;、最后调用objc_clear_deallocating,详细过程如下：
   a. 从weak表中获取废弃对象的地址为键值的记录
   b. 将包含在记录中的所有附有 weak修饰符变量的地址，赋值为   nil
   c. 将weak表中该记录删除
   d. 从引用计数表中删除废弃对象的地址为键值的记录&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;本文讲述了weak底层实现原理，也是面试经常被问到的一点，希望对大家有所帮助，谢谢！&lt;/p&gt;
</description>
<pubDate>Sun, 23 Dec 2018 07:01:00 +0000</pubDate>
<dc:creator>国孩</dc:creator>
<og:description>今年年底做了很多决定，离开工作三年的深圳，来到了上海，发现深圳和上海在苹果这方面还是差距有点大的，上海的市场8成使用swift编程，而深圳8成的使用OC，这点还是比较让准备来上海打拼的苹果工程师有点小</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/guohai-stronger/p/10161870.html</dc:identifier>
</item>
<item>
<title>JavaScript知识点 - 灵魂代碼</title>
<link>http://www.cnblogs.com/dlc1996/p/9610810.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dlc1996/p/9610810.html</guid>
<description>&lt;p&gt;&lt;span&gt;一、JavaScript特点&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;解释性语言——不需要编译代码，可以跨平台，像php、js、jsp都是解释性语言。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;单线程——js是单线程的语言，同时只能执行一件事情&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;ECMA标准——为了统一js的规则，推出了ECMA标准，因此js也称为ECMAScript。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h4&gt;&lt;span&gt;二、JavaScript三大部分：（ECMAScript、DOM、BOM）&lt;/span&gt;&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;ECMAScript是符合ECMA标准的基本javascript。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;DOM是Document Object Model文档对象模型，可以操作页面的代码，可以操作html和css部分。DOM是非常非常重要的部分。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;BOM是Browser Object Model浏览器对象模型，操作浏览器shell的。因为每一个浏览器厂家的不同，导致我们在每一个浏览器操作BOM都不一样。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h4&gt;&lt;span&gt;&lt;span&gt;三、JavaScript的基本语法&lt;/span&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;
&lt;p&gt;&lt;span&gt;变量声明&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;Js是一种弱数据类型的语言，任何类型的变量都用关键字Var来声明。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; arr = [1,2,3&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; num = 123&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; steing = &quot;abc&quot;;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;赋值可以在声明的的同时赋值，也可以在后面赋值。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; num = 123&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;var&lt;/span&gt;&lt;span&gt; num;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; num = 123;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;这两种方法是一样的。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;同时有一种单一Var模式。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; num1 = 123&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     num2 = 234&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     num3 = 456;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;变量名上下对齐，这样结构更清晰，也能节省很多代码。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;2.变量命名规则&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;以英文字母开头或者_和$符开头。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;变量名可以包含数字。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;不可以使用系统自带的关键字，保留字。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;3.数据类型（值类型）&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;不可改变的原始值。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;主要有 Number String Boolean undefined null 堆数据。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;引用值 数组Array 对象Object 函数function 栈数据。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;&lt;span&gt;四、JavaScript语句的基本规则&lt;/span&gt;&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;语句后面要用英文“ &lt;span&gt;；&lt;/span&gt;”结束。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;js语法错误会引发后续代码的终止，但不会影响其他的js代码块，这里仅限于逻辑错误和低级语法错误会导致代码全部执行不了。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;书写规范（不同公司有不同要求）。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h4&gt;&lt;span&gt;五、JavaScript运算符&lt;/span&gt;&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;“ + ”数学上相加的功能和字符串拼接“- * / % ”数学运算。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;相同的还有“++ == -- += -= &amp;gt; &amp;lt; ...”等等。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;逻辑运算符 &amp;amp;&amp;amp; || ！&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;&amp;amp;&amp;amp; 的作用是结果是true的时候才会继续执行，第一个就错了第二个不会执行，如果都是true的话返回最后一个。&lt;/li&gt;
&lt;li&gt;|| 的作用是结果只要有一个表达式是true的，后面的就不走了，并且返回的结果是这个正确的表达式的结果，全是false表达式返回的结果就是false。&lt;/li&gt;
&lt;li&gt;&amp;amp;&amp;amp; 可以当做一种短路语言使用；|| 可以当做赋初值的使用。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;4&lt;span&gt;.默认为false的值&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;unedfined； null； &quot; &quot;； NaN； 0； false 。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;&lt;span&gt;六、类型转换&lt;/span&gt;&lt;/h4&gt;
&lt;h5&gt;&lt;span&gt;（一）显示类型转换&lt;/span&gt;&lt;/h5&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;用 typeof 可以检测数据的类型。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; console.log(&lt;span&gt;typeof&lt;/span&gt;(123)); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Number&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;typeof 返回的结果有六种：number string boolear undefined object function 。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;数组和 null 都属于object。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;NaN 属于number ，虽然是非数，但也属于数字。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;typeof 返回结果是字符串。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;2.Number（mix）[混合]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;这个方法是可以把其他类型的数据转换成数字类型的数据。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;3.parseInt（string,radix）[基数]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;这个方法是将字符串转换成整型类型数字的。其中第二个参数radix基底是可以选择的参数。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;当radix为空的时候，这个函数的作用仅仅是将字符串转换成number类型。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;当参数string里面既包括数字字符串又包括其他字符串的时候，它会将看到其他字符串就停止了，不会继续转换后面的数字型字符串了。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; parseInt('123abc123') &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 123;&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; parseInt('abc123')    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; NaN;&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; parseInt('123')       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 123;&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; parseInt('true')      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; NaN;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;当radix不为空的时候这个函数可以用作进制转换，把第一个参数的数字当成几进制的数字转换成十进制。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;radix参考范围是2--36，&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; demo = 10&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; parseInt(demo,16) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;4.parseFloat(radix)&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;这个方法和parseInt类似，是将字符串转换成浮点类型的数字，碰到第一个非数字类型停止。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;只能识别第一个小数点及后面的数字，第二个小数点不能识别。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; parseFloat('123.2.3')  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 123.2&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; parseFloat('132.2abc') &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 123.2&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; parseFloat('123.abc1') &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 123&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;5.toString(radix)&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;这个方法和前面的不同，它是对象上的方法，任何数据类型都可以使用，转换成字符串类型，涉及到包装类。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;同样是radix基地可选参数，为空仅仅将数据转换成字符串。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; demo = 123&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;typeof&lt;/span&gt; demo.toString(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; string123;&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;typeof&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;.toString(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; stringtrue;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;当写了radix时代表要将这个数字转换成几进制的数字型字符串。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; dome = 10&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; demo.toString(16) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; A&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;undefined和null没有toString方法&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;6.String(mix)&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;和Number类似把任何类型转换成字符串&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;7.Boolean(mix)&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;和Number类似把任何类型转换为Boolean&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h5&gt;&lt;span&gt;（二）隐式类型转换&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;&lt;span&gt;1.isNaN()&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;这个方法可以检测是不是非数类型，调用的Number方法。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;2.算数运算符&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;++就是将现有数据调用Number之后，自身加一。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;+ - * / 执行之前都会先进行类型转换，换成数字在运算。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;3.逻辑运算符&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&amp;amp;&amp;amp; || ! 都会调用Boolean转换成布尔值看看结果是ture还是false，返回结果还是本身表达式的结果。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;// !abc; // false&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;4.不发生类型转换的比较运算符&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;===严格等于 !==严格不等于&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;&lt;span&gt;七、预编译【precompile】&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;函数声明提升：函数声明提升是一种整体提升，他、它会把函数声明和函数体一起提到前面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;变量声明提升：变量声明提升是一种局部提升，它仅仅将变量的声明提前了，但是并没有将赋值一起提升。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 1.js运行三部曲&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;语法分析&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;预编译&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;解析执行&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;2.预编译前奏&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;imply global&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;暗示全局变量，如果任何变量未经声明就赋值使用，此变量归window所有，并且成为window对象的一个属性。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;一切声明的全局变量，都是window属性。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;未经声明的全局变量可以用delete操作来删除。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;函数在执行的前一刻一个执行上下文，Activeaction Object对象。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;这个对象是空的，但是里面有着一些看不见的隐式属性:this:window属性和arguments[];属性。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;3.预编译四步&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;创建AO对象&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;寻找形参和变量声明并当做属性名添加到AO对象中，值为undefined。//函数声明不叫变量。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;将实参形参相统一&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;在函数体里寻找函数声明，将函数名当做属性名，值为这个函数的函数体。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;  &lt;span&gt;function&lt;/span&gt;&lt;span&gt; test (a,b) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;     console.log(a)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;      &lt;span&gt;function&lt;/span&gt;&lt;span&gt; a () {}
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;      a = 222&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;     console.log(a)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;      &lt;span&gt;function&lt;/span&gt;&lt;span&gt; b () {};
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;     console.log(b)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;      &lt;span&gt;var&lt;/span&gt; b = 111&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;      &lt;span&gt;var&lt;/span&gt;&lt;span&gt; a;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt; } 
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;  test(1);
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;var b = function () {} 这种不叫函数声明，这个函数是给b赋值的，b变量是声明。&lt;/li&gt;
&lt;li&gt;在第四步寻找函数声明并不会把赋值成function(){},执行到这一行的时候才会赋值成这个函数。&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;&lt;span&gt;十、函数与作用域与闭包&lt;/span&gt;&lt;/h4&gt;
&lt;h5&gt;&lt;span&gt;（一）函数部分&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;1.函数声明有3种方式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; demo = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {}; 函数表达式
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; demo () {}; 函数声明
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; demo = &lt;span&gt;function&lt;/span&gt; xxx () {};命名函数表达式   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;没用&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;每一个函数里面都有一个类数组属性arguments，这个属性里面存的就是实参。&lt;/li&gt;
&lt;li&gt;每一个函数有一个length属性，这个属性存的是形参的数量。&lt;/li&gt;
&lt;li&gt;每一个函数都会有一个return，如果不写的话函数会自动加一个return。&lt;/li&gt;
&lt;li&gt;return的功能有两个：返回这个函数的执行结果、终止函数的执行。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; test(a,b) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     console.log(a +&lt;span&gt; b);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     console.log('hello'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; test(1,2);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;  打印结果3   不会打印hello&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h5&gt;&lt;span&gt;（二）作用域&lt;/span&gt;&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;定义：变量（变量作用域又称为上下文）和函数生效（能被访问）的区域。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;JavaScript的函数是可以产生作用域的。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;es5中的作用域只有全局作用域函数作用域两种，es6新添加的块级作用域。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; demo = 123;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 全局变量&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; test () {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; 　　&lt;span&gt;var&lt;/span&gt; demo = 234; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 局部变量&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; 　　&lt;span&gt;console.log(demo);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; 　　&lt;span&gt;var&lt;/span&gt; demo1 = 'hello'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;   &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; test(demo);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打印234    就近打印局部变量，没有局部变量打印全局变量&lt;/span&gt;
&lt;span&gt;8&lt;/span&gt; console.log(demo1); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 报错 我们的全局作用域无法访问局部作用域&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;函数作用域就好像一个屋子，里面的可以拿外面的东西，外面的不能拿里面的东西。&lt;/li&gt;
&lt;li&gt;在函数作用域里声明变量没有用var的话，那么就生成了一个全局变量。&lt;/li&gt;
&lt;li&gt;两个不同的作用域（除了全局作用域）是不能互访问的。&lt;/li&gt;
&lt;/ul&gt;&lt;h5&gt;&lt;span&gt;（三）作用域链（scope chain）&lt;/span&gt;&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;既然函数存在作用域，函数有可以嵌套，那么作用域就会产生嵌套关系，这个时候就产生作用域链。&lt;/li&gt;
&lt;li&gt;当代码在一个环境中执行时，会创建变量的作用域链来保证对执行环境有权访问的变量和函数的有序访问。&lt;/li&gt;
&lt;li&gt;作用域链第一个对象始终是当前执行代码所在环境的变量对象。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;  &lt;span&gt;function&lt;/span&gt;&lt;span&gt; demo () {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; dome_a = 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; test () {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; demo_a = 2&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;        console.log(demo_a);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;    test();
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt; }
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;  demo();
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;本着对执行环境的有权和有序访问，每个函数的自身作用域总在作用域链的最顶层，下一层就是这个函数的父级函数作用域，直到全局作用域。&lt;/li&gt;
&lt;li&gt;因此test执行的时候打印的demo_a是本身作用域中的是‘2’而不是‘1’，如果自身作用域没有demo_a的话系统就会沿着作用域链向下找demo_a。&lt;/li&gt;
&lt;/ul&gt;&lt;h5&gt;&lt;span&gt;（四）闭包【closure】&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;1.什么是闭包&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;闭包就是能够读取其它函数内部变量的函数。&lt;/li&gt;
&lt;li&gt;不同的作用有之间不能互相访问，但是如果在一个函数内部再定义一个函数与外部的变量有所关联，那么就可以返回这个函数来访问外部函数里面的变量，所以在本质上闭包就是将函数内部与函数外部连接起来的桥梁。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;  &lt;span&gt;function&lt;/span&gt;&lt;span&gt; a (){
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; dome1 = 123&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     add = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         demo1 ++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        console.log(demo1);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    };
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt; }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; demo =&lt;span&gt; a ();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; demo();    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 123&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;add();   
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; demo();    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 124&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;当函数执行完函数的执行上下文就会被销毁，自然就无法访问里面的变量了，但是我们这个函数返回了一个依赖于这个函数的新函数，也就是说这个没有被销毁的新函数的作用域链中存在着原本函数作用域的引用，就导致原本函数的上下文不会被销毁，返回的新函数是原本函数的闭包函数。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;2.使用闭包的注意点&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;闭包会使函数的变量都保存在内存中，内存消耗很大，不能滥用闭包，否则会造成网页的性能问题，IE会造成内存泄漏。解决的方法就是退出函数时，将不使用的局部变量全部删除。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;闭包会在父函数外部改变父函数内部的值，如果把闭包当对象使用，那么就把闭包当做它的公用方法，把内部变量当做它的稀有属性。（不要随便改变函数内部变量的值）&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; name = 'global'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; obj =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;       name:'obj'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;       getName:&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                  console.log(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name);&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;                }&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;           }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }  
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; obj.getName() ();      
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;累加器的例子：&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;  &lt;span&gt;function&lt;/span&gt;&lt;span&gt; a () {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;      &lt;span&gt;var&lt;/span&gt; num = 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;      &lt;span&gt;function&lt;/span&gt;&lt;span&gt; addNum () {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;          num ++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;         console.log(num);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;     }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;      &lt;span&gt;return&lt;/span&gt;&lt;span&gt; addNum;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt; }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;  &lt;span&gt;var&lt;/span&gt; demo =&lt;span&gt; a ();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt; demo();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt; demo();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;  &lt;span&gt;var&lt;/span&gt; demo1 =&lt;span&gt; a();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt; demo1();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;  demo1();
&lt;/pre&gt;&lt;/div&gt;
&lt;h5&gt;&lt;span&gt;（五）立即执行函数&lt;/span&gt;&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;立即执行函数是解闭包的一个重要方法，但是注意闭包是没有办法解除的，只能通过一个新的闭包来消除上一个闭包的影响。&lt;/li&gt;
&lt;li&gt;立即执行函数不需要被定义，直接执行，执行完释放，经常作用作初始化。&lt;/li&gt;
&lt;li&gt;函数声明不能被执行，但是函数表达式可以&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;  (&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (){}())
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;  &lt;span&gt;function&lt;/span&gt;&lt;span&gt; returnB() {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;      &lt;span&gt;var&lt;/span&gt; arr =&lt;span&gt; [];
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;      &lt;span&gt;for&lt;/span&gt;(i = 0; i &amp;lt; 10; i ++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;          arr[i] = (&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;             console.log(i);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;         }())
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;     }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;      &lt;span&gt;return&lt;/span&gt;&lt;span&gt; arr;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt; }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;  &lt;span&gt;var&lt;/span&gt; save =&lt;span&gt; returnB();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt; console.log(save);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;  &lt;span&gt;for&lt;/span&gt;(j = 0; j &amp;lt; 10; j ++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;     save[j];
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;  }
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;&lt;span&gt;十一、对象、构造函数与包装类&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;1&lt;span&gt;.对象的创建方式有三点&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;对象字面量。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; obj ={};
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;这样的方式是最简单最常用的方法。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;对象里面有属性，属性之间用逗号相隔，每条属性都有属性名和值，属性名和属性值用分号相隔。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;2.构造函数【constructor】&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;构造函数也分为两种，系统自带的构造函数和自定义的构造函数。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;创建对象的构造函数Object()&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; object = &lt;span&gt;new&lt;/span&gt; object();
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;通过这条语句就创建了一个空对象，它的作用和 var obj = {}; 的作用一样。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;系统自带的构造函数还有Number();String();Boolean();Array() 。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;3.自定义构造函数&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;自定义的构造函数是最常见的一种构造函数。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;  &lt;span&gt;var&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; Person () {};
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;  &lt;span&gt;var&lt;/span&gt; operson = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Person ();
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;  &lt;span&gt;typeof&lt;/span&gt; operson  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; object&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;用new操作符创造出来的对象，尽管使用的是一个构造函数，但是之间没有联系。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;  &lt;span&gt;function&lt;/span&gt;&lt;span&gt; Person (name,age) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;      &lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;      &lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt; }
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;  &lt;span&gt;var&lt;/span&gt; person = &lt;span&gt;new&lt;/span&gt; Person('zhangsan',18&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;  console.log(person.name);
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;创建对象的时候只有new才会有this。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;重点：为什么可以用new操作符创建出相互独立的对象呢？&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;用new操作符的时候，这个new在构造函数里面隐式的创建了一个this对象，并且最后返回了这个this对象。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; Person (name) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; &lt;span&gt;this&lt;/span&gt; =&lt;span&gt; {};
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;   }
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;如果在构造函数首行手动创建一个对象，比如that对象，然后返回that，那么里面的this就没有了，属性值就用that了。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;  &lt;span&gt;function&lt;/span&gt;&lt;span&gt; Person (name) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;      &lt;span&gt;var&lt;/span&gt; that =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;          name: 'lisi'
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;     };
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;      that.name =&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;      &lt;span&gt;return&lt;/span&gt;&lt;span&gt; that;
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt; }
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;  &lt;span&gt;var&lt;/span&gt; person = &lt;span&gt;new&lt;/span&gt; Person ('demo'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;  console.log(person.name)
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;如果最后返回的是对象，那么this就失效，但是如果显示返回的是原始值那么this还是有效的。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;4.属性的增删改查&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;增：可以通过对象名+点属性名的方法来给对象添加新的属性并且赋值。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1 var obj = {};&lt;br/&gt;2 obj.name = 'xiaoming'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;改：修改的操作增加是一样的，只要调用相同的属性名然后赋一个新值就可以了。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;  &lt;span&gt;var&lt;/span&gt; obj =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;    name:'demo'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt; }
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;  obj.name = 'tan';
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;查：查看属性的功能console.log（xxx）。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;删：删除属性需要借助delete操作符。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;  &lt;span&gt;var&lt;/span&gt; obj =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;      name = 'scerlett'
&lt;span&gt;3&lt;/span&gt; &lt;span&gt; }
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;  obj.name;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; scerlett&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;  &lt;span&gt;delete&lt;/span&gt;&lt;span&gt; obj.name;
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;  obj.name;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; undefined&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;&lt;span&gt;十二、原型与原型链&lt;/span&gt;&lt;/h4&gt;
&lt;h5&gt;&lt;span&gt;（一）原型：prototype&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;&lt;span&gt;1.原型的定义：原型是function对象的一个属性，它定义了构造函数制造出来的对象的公有祖先，通过该构造函数产生的对象，可以继承原型的属性和方法，原型也是对象。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1 &lt;/span&gt;&lt;span&gt;function&lt;/span&gt; Person () {}
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;定义一个构造函数，Person.prototype这个属性就是这个构造函数的原理，这个属性天生就有的，并且这个属性的值也是一个对象。&lt;/li&gt;
&lt;li&gt;可以在person.prototype上面添加属性和方法，每一构造出来的对象都可以继承这些属性和方法。&lt;/li&gt;
&lt;li&gt;虽然每一个对象都是独立的，但是它们都有共同的祖先，当访问这个对象属性的时候，如果它没有这个属性，就会向上查找，找到它原型，然后在原型上访问这个属性。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;2.利用原型特点概念，可以提取公有属性&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;可以把每一个对象都有的公有属性不写在构造函数里面，而是提取到原型上，这样当构造函数构造大量的对象的时候就不需要走多次构造里面的赋值语句了，而只需走一遍，每个对象调用属性的时候直接上原型上查找就可以了。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;3.对象如何查看原型&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;用构造函数构造对象的时候，就会隐式创建一个this对象，这个this对象里面有一个默认的属性叫做proto属性，这个属性的值就是指向对象的原型。&lt;/li&gt;
&lt;li&gt;当查找的属性是自身没有的属性的时候，就会查找proto这个属性，然后这个属性指向原型，所以就到原型上查找属性了。&lt;/li&gt;
&lt;li&gt;注意：prototype是函数的属性，proto是对象的属性。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;4.如何查看构造自身的构造函数&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在prototype里面，有一个隐式的属性叫做constructor，这个属性记录的就是对象的构造器，里面存的就是构造函数。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; console.log(person.constructor); //person();
&lt;/pre&gt;&lt;/div&gt;
&lt;h5&gt;&lt;span&gt;（二）原型链&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;&lt;span&gt;1.有了原型，原型还是一个对象，那么这个名为原型的对象自然还有自己的原型，这样的原型上还有原型的结构就成了原型链。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;  Gra.prototype.firsName = 'scarlett'
&lt;span&gt; 2&lt;/span&gt;  &lt;span&gt;function&lt;/span&gt;&lt;span&gt; Gra () {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;      &lt;span&gt;this&lt;/span&gt;.name = 'grandfather'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;      &lt;span&gt;this&lt;/span&gt;.sex = 'male'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt; }
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;  &lt;span&gt;var&lt;/span&gt; grandfoo = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Gra();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;  garndfoo.word = 'hello'
&lt;span&gt; 8&lt;/span&gt;  Foo.prototype =&lt;span&gt; grandfoo;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;  &lt;span&gt;function&lt;/span&gt;&lt;span&gt; Foo () {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;      &lt;span&gt;this&lt;/span&gt;.age = '18'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;      &lt;span&gt;this&lt;/span&gt;.money = '100'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt; }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;  &lt;span&gt;var&lt;/span&gt; father = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Foo();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;  &lt;span&gt;function&lt;/span&gt;&lt;span&gt; Son () {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;      &lt;span&gt;this&lt;/span&gt;.name = 'son'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt; }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;  Son.prototype =&lt;span&gt; father;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;  &lt;span&gt;var&lt;/span&gt; son = &lt;span&gt;new&lt;/span&gt; Son();
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;Foo创造出来的每一个对象都继承来自grandfoo对象，son的每一对象都继承来自father这个由Foo创造出来的对象，这样的son就可以继承上面Foo和Gra的所有属性。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;这种链式的查询结构就叫做原型，最终的尽头是Object.prototype这个对象。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果没有规定原型的对象，它的原型就是Object.prototype。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;2.但是并不是所有的对象都有原型，比如使用Object.create方法。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;Object.create()方法需要写一个参数，这个参数就是对象的原型，如果要构造一个var obj = {};一样的对象，就需要写：&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; obj = Object.create(Object.prototype);
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;也可以写一个自定义的属性，让它成为原型。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;3.原型链上的增删改查&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; Person.prototype.arr[1,2,3&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; person1 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Person();
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; person2 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Person();
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; person1.arr.push(4&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; console.log(person2);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1 2 3 4 &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;删：删除属性需要借助delete操作符，对象不能删除原型上的属性。&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;&lt;span&gt; 十三、继承、this&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;1.this的一些问题：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;函数内部的this默认指向window，可以使用call / apply来改变this的指向，区别：后面传参形式不同。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; person () {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 　　&lt;span&gt;this&lt;/span&gt;.name = 'scarlett'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; 　　console.log(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; 　　&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; 　　person();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;现在this指向window，name属性自然就是window上的全局属性&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; obj =&lt;span&gt; {}；

person。call（object）&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Object.{name:'scarlett'}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;如果这个函数还有参数的话，只要把实参的值写在call后面并且用逗号隔开&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;function&lt;/span&gt;&lt;span&gt; person(name,age){
     &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
     &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
 }
 &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; obj =&lt;span&gt; {};
 person.call(obj,&lt;/span&gt;'scarlett',18&lt;span&gt;);
 console.log(obj.name);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;apply和call基本没什么区别，唯一的区别就是call后面的参数是一个一个传的，而apply后面的参数是放在数组里&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
person.apply(obj['scarlett',18]);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.继承【inherit】&lt;/p&gt;
&lt;p&gt;　　圣杯模式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; inherit(Target, Origin) {
    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; F() {};
    F.prototype &lt;/span&gt;=&lt;span&gt; Origin.prototype;
    Target.prototype &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; F();
    Target.prototype.constuctor &lt;/span&gt;= Target;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;让constuctor指向自己的&lt;/span&gt;
    Target.prototype.uber = Origin.prototype; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;超类，知道自己继承的是谁&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　yahu封装方法:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; var inherit = (function (){&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     var F = function () {};&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     return function (Target, Origin){&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;         F.prototype = Origin.prototype;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;         Target.prototype = new F();&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;         Target.prototype.constuctor = Target;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;         Target.prototype.uber = Origin.prototype;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     }&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; }());&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;//&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;         for (var i = 0; i &amp;lt; 5; i ++) {&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;             var btn = document.createElement('button');&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;             btn.appendChild(document.createTextNode('Button' + i));&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;             btn.addEventListener('click', function(){console.log(i); });&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;             document.body.appendChild(btn);&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;         }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　对象的枚举与this&lt;/p&gt;
&lt;p&gt;1.对象的枚举&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;查看对象的属性可以用obj.name查看，也可以用obj['name']类数组方式查看，但事实上是数组模仿了对象的查看方式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2.for-in操作符&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;要枚举一个数组的所有属性只需用一个for循环从头到尾遍历一遍就可以了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　但是对象并不能用for循环来遍历属性，所有就要用到for-in操作了&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; var obj = {&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     name: 'scarlett',&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     age: 18,&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     sex: 'female'&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; }&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; for(var prop in obj){&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     console.log(prop + ':' + obj[prop]);&lt;/span&gt;
&lt;span&gt;8&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;for-in循环会按照属性的顺序取出属性名然后赋给prop，所有打印prop都是属性名，obj【prop】则是性对应的属性的值&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;注意：这里不能写成obj.prop方式，因为在系统底层会转化成obj【‘prop’】的形式，但是并没有prop属性，它只是一个变量，所以会打印　　undefined，这里必须使用obj['prop']。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;在非严格模式中，for-in循环都会把原型里面的一些属性一起打印出来，但es5的严格模式不会。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;2.三种操作符&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;hasOwnProperty这个操作符的作用是查看当前这个属性是不是对象自身的属性，在原型链上的属性会被过滤掉，自身的ture&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; function Person() {&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;     this.name = 'scarlett'&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; }&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; Person.prototype = {&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;     age:18&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; }&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; var oPerson = new Person();&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; for (var prop in oPerson) {&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;     if (oPerson.hasOwnProperty(prop)){&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;         console.log(oPerson[prop]);&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;     }&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　&lt;span&gt;　这样for-in循环就只会打印自身的属性，而不是打印原型上的属性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　in操作符：这个操作符的作用是查看一个属性是不是在这个对象或者它原型里面。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 'name' in oPerson;    //ture&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 'sex' in oPerson;   //False&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;instanceof操作符：作用是查看前面对象是不是后面的构造函数构造出来的，和constructor很像&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; oPerson intanceof object;    // ture&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; {} instanceof oPerson;  // false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.this&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;预编译过程中this执行window&lt;/li&gt;
&lt;li&gt;全局作用域里的this指向window&lt;/li&gt;
&lt;li&gt;call / apply可以改变this指向&lt;/li&gt;
&lt;li&gt;obj.func()func()里的this指向Obj&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; var obj = {&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     height:190,&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     eat:function () {&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;         this.height ++;  // eat在没有执行之前，谁也不知道this指向谁&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     }&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; }&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; obj.eat(); // 谁调用this，this指向谁&lt;/span&gt;
&lt;span&gt;8&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; eat.call(obj); // eat里面的this指向obj&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　&lt;span&gt;　如果能理解下面的这段代码的this指向问题，那么就掌握的this的所有知识点了&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; var name = '222'&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; var a = {&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     name:'111',&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     say:function () {&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;         console.log(this.name);&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     }&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; }&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; var fun = a.say;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; fun();   // 此处其实就是把a.say这个函数体赋给fun这个函数，相当于在全局空间写下了一个fun函数，此时this指向window，打印'222'&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; a.say();  // 按照谁调用指向谁的说法，这里打印'111'&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; var b = {&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     name:'333',&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     say:function (fun) {&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;         fun();&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     }&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; }&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; b.say(a.say); // 其实和在全局调用a.say的函数体方法差不多，打印'222'&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; b.say = a.say;&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; b.say(); // this指向B 所以打印'333'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;&lt;span&gt;十五、克隆与数组&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;1.argument.callee&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这个方法是指代函数本身，当在一些匿名函数或者立即执行函数里面进行递归调用函数本身的时候，由于没有名字，就用这种方式调用；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　一般当需要通过计算机进行初始化的时候，写一个立即执行函数，当这个立即执行函数还需要递归调用自身的时候，就用这种方式调用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.function.caller&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; function test () {&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;     console.log(test.caller);&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; }&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; function demo () {&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;     test()&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; }&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; demo();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这是函数本身自带的一个属性，可以指出当前函数的ude运行环境的函数引用，就是这个函数在哪个函数里面执行的……&lt;/p&gt;
&lt;p&gt;3.克隆【clone】&lt;/p&gt;
&lt;p&gt;　　克隆和继承有一些区别，克隆是复制出来一模一样的目标对象又分为浅度克隆和深度克隆&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; function clone (src,tar) {&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;     var tar = tar || {};&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;     for (var prop in src) {&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;         if (src.hasOwnProperty(prop)){&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;             tar[prop] = src[prop];&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;         }&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;     }&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;     return tar;&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　当有一个属性是引用值（数组、对象）时按照这种克隆模式，只是把这个引用值的指向赋给了新的目标对象，一旦改变了原对象或者目标对象的引用属性另一个也跟着变，这一点就是浅度克隆的缺点；&lt;/p&gt;
&lt;p&gt;　　深度克隆的原理很简单，只要不克隆引用值的引用而是把引用值也当做一个原对象，把里面的值一个个克隆岛目标对象里面，就解决了二者相同指向的问题；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; function deepCopy (src,tar) {&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;     var tar = tar || {};&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;     for (var prop in src) {&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;         if(typeof(src[prop] == 'object')){&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;             tar[prop] = (src[prop].constructor === Array) ? [] : {};&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;         }else{&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;             tar[prop] = src[prop];&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;         }&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;     }&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;     return tar;&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这个时候目标对象和原对象的引用值就没有关系了，都是独立值可以进行修改。&lt;/p&gt;
&lt;p&gt;4.数组【array】&lt;/p&gt;

</description>
<pubDate>Sun, 23 Dec 2018 06:53:00 +0000</pubDate>
<dc:creator>灵魂代碼</dc:creator>
<og:description>一、JavaScript特点 二、JavaScript三大部分：（ECMAScript、DOM、BOM） 三、JavaScript的基本语法 变量声明 Js是一种弱数据类型的语言，任何类型的变量都用关</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dlc1996/p/9610810.html</dc:identifier>
</item>
<item>
<title>似然与概率的通俗理解 - Bo_hemian</title>
<link>http://www.cnblogs.com/wkang/p/10069780.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wkang/p/10069780.html</guid>
<description>&lt;h2&gt;1. 极大似然估计&lt;/h2&gt;
&lt;p&gt;假设有一枚硬币，我们想确定这枚硬币是否质地均匀。即想知道抛这枚硬币，正反面出现的概率各是多少？于是我们将这枚硬币抛了10次，得到的数据x0是：&lt;span&gt;反&lt;/span&gt;正正正正&lt;span&gt;反&lt;/span&gt;正正正&lt;span&gt;反&lt;/span&gt;。我们想求的正面概率θ是模型参数，而抛硬币模型可以假设服从二项分布。&lt;/p&gt;
&lt;p&gt;那么，出现实验结果x0（&lt;span&gt;反&lt;/span&gt;正正正正&lt;span&gt;反&lt;/span&gt;正正正&lt;span&gt;反&lt;/span&gt;）的似然函数是多少呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1473228/201812/1473228-20181213193910794-2100376260.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而极大似然估计，顾名思义，就是要最大化这个函数。&lt;/p&gt;

&lt;p&gt;我们可以画出f(θ)的图像：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1473228/201812/1473228-20181213193448864-388525630.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从图像中可以观察到，θ=0.7时，函数取值最大。也就是说，我们通过最大化似然函数后，得到了模型参数的值，相应的，正反面出现的概率也就求出了。  &lt;/p&gt;
&lt;p&gt;极大似然估计需要保证所有的采样都是独立同分布的。&lt;/p&gt;
&lt;h2&gt;2. 容易混淆的概念 &lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;极大似然估计就是最大似然估计。&lt;/li&gt;
&lt;li&gt;极大似然概率这个名词描述是不准确的，笔者查阅了整个英文互联网，都没有找到  ‘Maximum likelihood probability’这个词。所以，&lt;strong&gt;不存在“极大似然概率”&lt;/strong&gt;这个说法。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;3. 最大后验概率  &lt;/h2&gt;
&lt;p&gt;与极大似然估计相比，使用最大后验概率估计θ时，首先认为θ本身存在一个分布，即θ有先验分布。&lt;/p&gt;
&lt;p&gt;还是以判断一枚硬币是否质地均匀为例。假设正面概率θ满足均值为0.5，方差为1的先验分布，即：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1473228/201812/1473228-20181223140814963-316913484.png&quot; alt=&quot;&quot; width=&quot;130&quot; height=&quot;31&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么，将这枚硬币抛了10次，得到的数据x0是：&lt;span&gt;反&lt;/span&gt;正正正正&lt;span&gt;反&lt;/span&gt;正正正&lt;span&gt;反&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;因为考虑了先验分布，所以实验结果x0的函数可以表示为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1473228/201812/1473228-20181223140315806-264996980.png&quot; alt=&quot;&quot; width=&quot;311&quot; height=&quot;36&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 因此，我们可以通过最大化这个后验概率函数求得θ，我们可以画出f(θ)的图像：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1473228/201812/1473228-20181223144218279-1241682598.png&quot; alt=&quot;&quot; width=&quot;450&quot; height=&quot;266&quot;/&gt;&lt;/p&gt;
&lt;p&gt;计算得到θ = 0.696。也就是说，采用最大后验概率计算得到硬币正面朝上的概率为0.696。&lt;/p&gt;
&lt;h2&gt;4. 似然与概率分别指的什么&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;似然：&lt;/strong&gt; 英文单词为likelihood，有道翻译的翻译结果为：十有八九。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;概率：&lt;/span&gt;&lt;/strong&gt; 如果我有一枚质地均匀的硬币，那么它出现正面朝上的概率是0.5。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;似然：&lt;/span&gt;&lt;/strong&gt; 如果我抛一枚硬币100次，正面朝上52次，那么它十有八九是质地均匀的。&lt;/p&gt;

&lt;p&gt;再举一个例子加深理解。 假设有人向我挑战一个“有利可图的赌博游戏”。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;概率：&lt;/strong&gt;&lt;/span&gt; 帮助我们计算预期的收益和损失(平均值、众数、中值、方差、信息比率、风险值、赌徒破产等等)。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;似然：&lt;/strong&gt;&lt;/span&gt; 帮助我们量化是否首先应该相信那些概率。&lt;/p&gt;
&lt;p&gt;实际上，似然几乎可以等价于置信度。&lt;/p&gt;

</description>
<pubDate>Sun, 23 Dec 2018 06:52:00 +0000</pubDate>
<dc:creator>Bo_hemian</dc:creator>
<og:description>1. 极大似然估计 假设有一枚硬币，我们想确定这枚硬币是否质地均匀。即想知道抛这枚硬币，正反面出现的概率各是多少？于是我们将这枚硬币抛了10次，得到的数据x0是：反正正正正反正正正反。我们想求的正面概</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wkang/p/10069780.html</dc:identifier>
</item>
<item>
<title>03_Git讲义之Eclipse的Git使用 - 黑泽君</title>
<link>http://www.cnblogs.com/chenmingjun/p/10164296.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenmingjun/p/10164296.html</guid>
<description>&lt;h2 id=&quot;h1git&quot;&gt;&lt;span&gt;&lt;strong&gt;1、Git的历史&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;  同生活中的许多伟大事件一样，Git 诞生于一个极富纷争大举创新的年代。Linux 内核开源项目有着为数众广的参与者。绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上（1991－2002年间）。到 2002 年，整个项目组开始启用分布式版本控制系统 BitKeeper 来管理和维护代码。&lt;br/&gt;  到 2005 年的时候，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了免费使用 BitKeeper 的权力。这就迫使 Linux 开源社区（特别是 Linux的缔造者 Linus Torvalds ）不得不吸取教训，只有开发一套属于自己的版本控制系统才不至于重蹈覆辙。他们对新的系统订了若干r如下目标：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;速度&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;简单的设计&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;对非线性开发模式的强力支持（允许上千个并行开发的分支）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;完全分布式&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;有能力高效管理类似 Linux 内核一样的超大规模项目（速度和数据量）&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;1.6666666666667&quot;&gt;
&lt;p&gt;下载地址：&lt;br/&gt;  &lt;a href=&quot;https://www.kernel.org/pub/software/scm/git/&quot; target=&quot;_blank&quot;&gt;https://www.kernel.org/pub/software/scm/git/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;h2gitsvn&quot;&gt;&lt;span&gt;&lt;strong&gt;2、Git与Svn对比&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;h21svn&quot;&gt;&lt;span&gt;&lt;strong&gt;2.1、Svn原理分析&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;  svn属于集中式版本管理控制系统，系统中保存了所有文件的修订版本，而协同工作人员通过连接svn服务器，提取出最新的文件，获取提交更新。&lt;/p&gt;
&lt;p&gt;  下图就是标准的集中式版本控制工具管理方式：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/23/5WYq49.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;  集中管理方式在一定程度上看到其他开发人员在干什么，而管理员也可以很轻松掌握每个人的开发权限。&lt;/p&gt;
&lt;p&gt;  但是相较于其优点而言，集中式版本控制工具缺点很明显：&lt;br/&gt;&lt;strong&gt;    1、服务器单点故障&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;    2、容错性差&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;h22git&quot;&gt;&lt;span&gt;&lt;strong&gt;2.2、Git原理分析&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h4 id=&quot;h221svn&quot;&gt;&lt;span&gt;&lt;strong&gt;2.2.1、Svn记录具体差异&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;  Git 和其他版本控制系统的主要差别在于，Git 只关心文件数据的整体是否发生变化，而大多数其他系统则只关心&lt;code&gt;文件内容的具体差异&lt;/code&gt;。这类系统（CVS，Subversion，Perforce，Bazaar等等）每次记录有哪些文件作了更新，以及都更新了哪些行的什么内容，请看下图：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/23/5W053O.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h222git&quot;&gt;&lt;span&gt;&lt;strong&gt;2.2.2、Git记录整体变化&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;  Git 并不保存这些前后变化的差异数据。实际上，Git 更像是把变化的文件作快照后，记录在一个微型的文件系统中。每次提交更新时，它会纵览一遍所有文件的指纹信息并对文件作一快照，然后保存一个指向这次&lt;code&gt;快照的索引&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;  为提高性能，若文件没有变化，Git 不会再次保存，而只对上次保存的快照作一连接。Git 的工作方式就像下图所示：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/23/5WYwtA.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;  这是 Git 同其他系统的重要区别。它完全颠覆了传统版本控制的套路，并对各个环节的实现方式作了新的设计。Git 更像是个小型的文件系统，但它同时还提供了许多以此为基础的超强工具，而不只是一个简单的 CVS。&lt;/p&gt;
&lt;h4 id=&quot;h223&quot;&gt;&lt;span&gt;&lt;strong&gt;2.2.3、操作本地执行&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;  Git 不用跑到外面的服务器上去取数据回来，而直接从本地数据库读取后展示给你看。所以任何时候你都可以马上翻阅，无需等待。&lt;/p&gt;
&lt;p&gt;  如果想要看当前版本的文件和一个月前的版本之间有何差异，Git 会取出一个月前的快照和当前文件作一次&lt;code&gt;差异运算&lt;/code&gt;，而不用请求远程服务器来做这件事，或是把老版本的文件拉到本地来作比较。&lt;/p&gt;
&lt;h4 id=&quot;h224&quot;&gt;&lt;span&gt;&lt;strong&gt;2.2.4、数据完整性&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;  在保存到 Git 之前，所有数据都要&lt;code&gt;进行内容的校验和（checksum）计算&lt;/code&gt;，并将此结果作为数据的&lt;code&gt;唯一标识和索引&lt;/code&gt;。换句话说，不可能在你修改了文件或目录之后，Git 一无所知。&lt;/p&gt;
&lt;p&gt;  这项特性作为 Git 的设计哲学，建在整体架构的最底层。所以如果文件在传输时变得不完整，或者磁盘损坏导致文件数据缺失，Git 都能立即察觉。&lt;/p&gt;
&lt;p&gt;  Git 使用 &lt;code&gt;SHA-1 算法&lt;/code&gt;计算数据的校验和，通过对文件的内容或目录的结构计算出一个&lt;code&gt;SHA-1 哈希值&lt;/code&gt;，作为&lt;code&gt;指纹字符串&lt;/code&gt;。该字串由 40 个十六进制字符（0-9 及 a-f）组成，看起来就像是：&lt;br/&gt;  &lt;strong&gt;24b9da6552252987aa493b52f8696cd6d3b00373&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  Git 的工作完全依赖于这类指纹字串，所以你会经常看到这样的哈希值。实际上，所有保存在 Git 数据库中的东西都是用此哈希值来作索引的，而不是靠文件名。&lt;/p&gt;
&lt;h4 id=&quot;h225&quot;&gt;&lt;span&gt;&lt;strong&gt;2.2.5、三种状态&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;  现在请注意，接下来要讲的概念非常重要。&lt;/p&gt;
&lt;p&gt;  对于任何一个文件，在 Git 内都只有三种状态：&lt;code&gt;已提交（committed）&lt;/code&gt;、&lt;code&gt;已修改（modified）&lt;/code&gt;和&lt;code&gt;已暂存（staged）&lt;/code&gt;。已提交表示该文件已经被安全地保存在本地数据库中了；已修改表示修改了某个文件，但还没有提交保存；已暂存表示把已修改的文件放在下次提交时要保存的清单中。&lt;/p&gt;
&lt;p&gt;  由此我们看到 Git 管理项目时，文件流转的三个工作区域：Git 的本地数据目录，工作目录以及暂存区域。&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/23/5W09Gq.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;  1）如果是 git 目录中保存着的特定版本文件，就属于已提交状态；&lt;br/&gt;  2）如果作了修改并已放入暂存区域，就属于已暂存状态；&lt;br/&gt;  3）如果自上次取出后，作了修改但还没有放到暂存区域，就是已修改状态。
&lt;h2 id=&quot;h3git&quot;&gt;&lt;span&gt;&lt;strong&gt;3、Git远程服务器搭建&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;  Git远程服务器可以搭建在windows，也可以搭建在Linux中，由于windows中copssh登录git服务器软件已经收费，免费版本有很多缺点。因此把Git远程服务器(仓库)搭建在Linux中。&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt;注意&lt;/strong&gt;：&lt;code&gt;一个Git远程服务器可以有多个远程仓库。很多时候，一个远程服务器只有一个远程仓库。即一般而言：一个远程服务器 == 一个远程仓库&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;h31&quot;&gt;&lt;span&gt;&lt;strong&gt;3.1、依赖环境&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;Git需要很多依赖环境：因此安装git需要先安装下列软件：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs coffeescript&quot;&gt;[root@itcast&lt;span class=&quot;hljs-number&quot;&gt;-01&lt;/span&gt; ~]&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h32git&quot;&gt;&lt;span&gt;&lt;strong&gt;3.2、安装git&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs coffeescript&quot;&gt;上传git安装包：&lt;br/&gt;安装包：git&lt;span class=&quot;hljs-number&quot;&gt;-2.9&lt;/span&gt;&lt;span class=&quot;hljs-number&quot;&gt;.3&lt;/span&gt;.tar.gz&lt;br/&gt;解压缩：tar -xvf git&lt;span class=&quot;hljs-number&quot;&gt;-2.9&lt;/span&gt;&lt;span class=&quot;hljs-number&quot;&gt;.3&lt;/span&gt;.tar.gz&lt;br/&gt;安装命令：(进入git解压目录)&lt;br/&gt;[root@itcast&lt;span class=&quot;hljs-number&quot;&gt;-01&lt;/span&gt; git&lt;span class=&quot;hljs-number&quot;&gt;-2.9&lt;/span&gt;&lt;span class=&quot;hljs-number&quot;&gt;.3&lt;/span&gt;]&lt;br/&gt;[root@itcast&lt;span class=&quot;hljs-number&quot;&gt;-01&lt;/span&gt; git&lt;span class=&quot;hljs-number&quot;&gt;-2.9&lt;/span&gt;&lt;span class=&quot;hljs-number&quot;&gt;.3&lt;/span&gt;]&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h33git&quot;&gt;&lt;span&gt;&lt;strong&gt;3.3、创建git用户&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;pre readability=&quot;5&quot;&gt;
&lt;code class=&quot;hljs coffeescript&quot; readability=&quot;4&quot;&gt;添加Linux的用户，用户名为git的用户：&lt;br/&gt;[root@itcast&lt;span class=&quot;hljs-number&quot;&gt;-01&lt;/span&gt; ~]&lt;p&gt;设置git用户的密码&lt;br/&gt;[root@itcast&lt;span class=&quot;hljs-number&quot;&gt;-01&lt;/span&gt; ~]&lt;/p&gt;&lt;p&gt;切换到git用户&lt;br/&gt;[root@itcast&lt;span class=&quot;hljs-number&quot;&gt;-01&lt;/span&gt; ~]&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h34&quot;&gt;&lt;span&gt;&lt;strong&gt;3.4、初始化仓库&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;pre readability=&quot;5.5&quot;&gt;
&lt;code class=&quot;hljs ruby&quot; readability=&quot;5&quot;&gt;初始化仓库，设置仓库名为taotao.git：&lt;br/&gt;[git@itcast-&lt;span class=&quot;hljs-number&quot;&gt;01&lt;/span&gt; root]$ cd&lt;br/&gt;[git@itcast-&lt;span class=&quot;hljs-number&quot;&gt;01&lt;/span&gt; ~]$ git init --bare taotao.git&lt;br/&gt;始化空的 Git 仓库于 /home/git/taotao.git/&lt;p&gt;“git init --bare”方法创建一个所谓的裸仓库，之所以叫裸仓库是因为这个仓库只保存git历史提交的版本信息，而不允许用户在上面进行各种git操作，如果你硬要操作的话，只会得到下面的错误（”This operation must be run &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; a work tree”）这个就是最好把远端仓库初始化成bare仓库的原因。&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;h4eclipsegit&quot;&gt;&lt;span&gt;&lt;strong&gt;4、Eclipse的Git使用&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;h41&quot;&gt;&lt;span&gt;&lt;strong&gt;4.1、检入代码&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h4 id=&quot;h411git&quot;&gt;&lt;span&gt;&lt;strong&gt;4.1.1、设置使用Git&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：本文档中我们新建一个java工程（对应视频中是新建一个maven工程）二者差不多。&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/23/5W0DLe.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;选择Git&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/23/5W0BRd.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h412git&quot;&gt;&lt;span&gt;&lt;strong&gt;4.1.2、设置Git本地仓库文件存放路径&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/23/5W0TPr.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;选择要上传的项目&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/23/5W0HYR.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h413&quot;&gt;&lt;span&gt;&lt;strong&gt;4.1.3、设置忽略的文件&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/23/5W0XSY.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;如下图，加入检入时需要忽略的文件&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/23/5W0zHi.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h414&quot;&gt;&lt;span&gt;&lt;strong&gt;4.1.4、提交代码到本地暂存区&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;回到java视图&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/23/5W0V4y.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;把本地工作区代码关联到git的本地暂存区&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/23/5W0Y6X.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;提交代码到本地暂存区&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/23/5W0Q3l.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;下图中Author、Committer可以自己设置，步骤：Windows --&amp;gt; Preferences --&amp;gt; Team --&amp;gt; Git --&amp;gt; Configuration --&amp;gt; And Entry… --&amp;gt; 在Key中输入&lt;strong&gt;user.name&lt;/strong&gt;，在Value输入“&lt;strong&gt;邮箱用户名(任意)&lt;/strong&gt;”--&amp;gt; 再次点击And Entry… --&amp;gt; 在Key中输入&lt;strong&gt;user.email&lt;/strong&gt;，在Value输入“&lt;strong&gt;邮箱地址&lt;/strong&gt;”，这么做的目的是：Git远程服务器有什么问题会发到我们的邮箱中去。&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/23/5W0deB.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h415git&quot;&gt;&lt;span&gt;&lt;strong&gt;4.1.5、提交代码到Git远程服务器&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;好习惯&lt;/strong&gt;：push之前先pull。&lt;br/&gt;　　由于是第一次提交push本地暂存区代码到git远程服务器，git远程服务器中啥都没有呢，所以不需要先pull了。&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/23/5W0WMJ.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;设置git远程服务器地址：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/23/5W0jR6.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;选择分支&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/23/5W0M0p.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;点击完成&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/23/5W0Oa3.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;提交git远程服务器成功后，我们查看git远程服务器taotao.git仓库中的文件，如下：&lt;br/&gt;&lt;strong&gt;注意&lt;/strong&gt;：下面的两张图是以演示新建maven工程为例的。&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/23/5W0u4n.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;上传过来的对象都被保存在一个一个文件夹中。例如我们查看03文件夹中的对象命令：git show 03fe 如下图：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/23/5W0sTG.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h416git&quot;&gt;&lt;span&gt;&lt;strong&gt;4.1.6、检入检出Git远程服务器操作&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;当第一次检入到git远程服务器后，后续的代码检入检出git远程服务器的操作如下图即可。&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/23/5W0bSK.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;strong&gt;好习惯&lt;/strong&gt;：push前先pull。&lt;br/&gt;&lt;strong&gt;注意&lt;/strong&gt;：&lt;br/&gt;  Commit的作用是把本地工作区的代码提交到本地暂存区。&lt;br/&gt;  Push的作用是把本地暂存区的代码提交到git远程服务器。&lt;br/&gt;  Pull的作用是将git远程服务器的代码拉到本地暂存区。
&lt;p&gt;本地仓库包括本地工作区。一般我们不怎么使用本地仓库，而是使用本地仓库中文件，即&lt;br/&gt;本地仓库 == 本地工作区，他们两是一个意思。&lt;/p&gt;
&lt;h3 id=&quot;h42&quot;&gt;&lt;span&gt;&lt;strong&gt;4.2、检出代码&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h4 id=&quot;h421git&quot;&gt;&lt;span&gt;&lt;strong&gt;4.2.1、克隆git远程仓库到本地仓库&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/23/5W046E.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;输入远程仓库地址&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/23/5W0Z5Q.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;选择分支&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/23/5W0vea.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h422git&quot;&gt;&lt;span&gt;&lt;strong&gt;4.2.2、设置git本地仓库文件存放路径&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/23/5W0hM2.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h423&quot;&gt;&lt;span&gt;&lt;strong&gt;4.2.3、导出(检出)工程&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：我们只是导出本地仓库中的工程，而不是导出整个本地仓库。&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/23/5W0ygz.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;如下图所示选择：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/23/5W0a0S.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;填写工程名（建议此处的工程名和远程仓库的工程名一致，当然我们也可以改为其他的）&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/23/5W0cah.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;转换检出的工程为对应的类型&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/23/5W0rfH.png&quot; alt=&quot;&quot;/&gt;&lt;h3 id=&quot;h43&quot;&gt;&lt;span&gt;&lt;strong&gt;4.3、解决冲突&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;好习惯&lt;/strong&gt;：push前先pull。&lt;br/&gt;&lt;strong&gt;注意&lt;/strong&gt;：&lt;br/&gt;  Commit的作用是把本地工作区的代码提交到本地暂存区。&lt;br/&gt;  Push的作用是把本地暂存区的代码提交到git远程服务器。&lt;br/&gt;  Pull的作用是将git远程服务器的代码拉到本地暂存区。&lt;/p&gt;
&lt;p&gt;本地仓库包括本地工作区。一般我们不怎么使用本地仓库，而是使用本地仓库中文件，即&lt;br/&gt;本地仓库 == 本地工作区，他们两是一个意思。&lt;/p&gt;
&lt;h4 id=&quot;h431&quot;&gt;&lt;span&gt;&lt;strong&gt;4.3.1、解决代码冲突&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/23/5W0ETN.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;当我们本地修改的内容，其他同事也修改了同一内容，并且先于我们自己提交，即说明远程仓库发生改变了，此时如果我们本地push代码就会产生代码冲突，我们本地需要解决冲突（冲突一般都是相同行数修改引起的），此时我们就要看看到底怎么修改冲突才合理（最好和同事商量，看看他修改了哪些内容，目的是啥，避免修改冲突时去掉同事的代码），即如果合并之后检测到文件有冲突，是会提示Command Failed失败的，并且Git Gui是会获取到冲突文件，对于冲突文件的解决，可以右键选择使用远程版本的还是本地版本的，并且本地已经被打开的话，是会提示是否overwritten，按照此方法挨个解决下冲突文件即可。&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/23/5W0LJu.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h432&quot;&gt;&lt;span&gt;&lt;strong&gt;4.3.2、提交解决冲突后的代码&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;把解决冲突后的代码执行Add to Index（即把本地工作区代码关联到git的本地暂存区）&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/23/5W0eI9.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;先把本地工作区的代码提交到本地暂存区。&lt;br/&gt;再把本地暂存区的代码提交到git远程服务器。&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/23/5W0K5A.png&quot; alt=&quot;&quot;/&gt;</description>
<pubDate>Sun, 23 Dec 2018 06:44:00 +0000</pubDate>
<dc:creator>黑泽君</dc:creator>
<og:description>1、Git的历史 同生活中的许多伟大事件一样，Git 诞生于一个极富纷争大举创新的年代。Linux 内核开源项目有着为数众广的参与者。绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenmingjun/p/10164296.html</dc:identifier>
</item>
<item>
<title>基于TensorFlow的深度学习系列教程 1——Hello World! - xingoo</title>
<link>http://www.cnblogs.com/xing901022/p/10164264.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xing901022/p/10164264.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;最近看到一份不错的深度学习资源——Stanford中的CS20SI：《TensorFlow for Deep Learning Research》，正好跟着学习一下TensorFlow的基础，还是收获颇丰，随手整理成博客随时翻阅。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;自从12年AlexNet获得ImageNet大赛的冠军后，深度学习开始流行起来，也因为硬件的快速发展GPU并行计算配合易用的API，让深度学习以及神经网络大放光彩。&lt;/p&gt;
&lt;p&gt;深度学习的框架其实有很多，目前来说最火的还要数Pytorch、TensorFlow以及Keras。其中Pytorch比较适合学术研究，自己搞着玩，如果工业实践就不太适合了。TensorFlow由于时间比较久，学起来比较困难，不过有完整的开发、部署方案，还有大量的github项目可供参考。Keras则是TensorFlow的一个高级API，同类的还有TensorFlow的TFLearn等等。&lt;/p&gt;
&lt;p&gt;总结来说，如果你是学生，只是为了论文或者学习，那么推荐Pytorch；如果你是公司的开发者，想要在业务中使用深度学习，推荐直接使用TensorFlow，如果使用最新的1.12，那么官方的示例里面就已经是Keras了；如果你是从github上面下载了源码想要学习，那就得去学习对应版本的TensorFlow API了。&lt;/p&gt;
&lt;p&gt;在总结一下Tensoflow的优点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;易用性：有对应Python的API&lt;/li&gt;
&lt;li&gt;可移植性：一套代码就可以适应单个或者多个CPU、GPU、移动设备等&lt;/li&gt;
&lt;li&gt;灵活性：可以部署在树莓派、安卓、windows、ios、linux等上&lt;/li&gt;
&lt;li&gt;可视化：有tensorboard提供开发的可视化界面，方便跟踪调参&lt;/li&gt;
&lt;li&gt;检查点：可以通过检查点记录保存实验数据&lt;/li&gt;
&lt;li&gt;这个不理解什么意思：Auto-differentiation autodiff (no more taking derivatives by hand. Yay)&lt;/li&gt;
&lt;li&gt;庞大的社区：一年内拥有10000+的开发者，3000+的项目&lt;/li&gt;
&lt;li&gt;大量基于TensorFlow的项目代码&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;使用TensorFlow的公司包括：Google，OpenAI，DeepMind，SnapChat，Airbus，eBay等&lt;/p&gt;
&lt;p&gt;基于TensorFlow可以做很多事情，比如图像CV、自然语言处理NLP、语音识别等等。&lt;/p&gt;

&lt;h2 id=&quot;简化的api&quot;&gt;1. 简化的API&lt;/h2&gt;
&lt;p&gt;下面就来学习下TensorFlow的基础知识，TensorFlow不仅提供了基础的语法，还提供了一些简化的API：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;TF Learn，tf.contrib.learn，基于scikit-learn风格的API&lt;/li&gt;
&lt;li&gt;TF Slim，tf.contrib.slim，轻量级的tf构建API，可以自动配置默认值，简化使用&lt;/li&gt;
&lt;li&gt;Keras，更高级更抽象的API，使用Keras之后，就像叠积木一样创建模型，不过对于背后的原理隐藏的太深太深...&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;数据流图&quot;&gt;2. 数据流图&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/xing901022/1187174/o_Jietu20181223-140817.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果做过大数据或者接触过java8的流计算，对这种数据流图应该比较了解。就是我们在程序执行前，先构建好计算的流程框架，然后执行的时候现去读取数据分配资源执行计算。这样一方面把构建与计算分离，另一方面也可以代码自己做更深的优化。&lt;/p&gt;
&lt;p&gt;比如上面的数据流图中，事先定义好整个网络的结构，然后计算的时候直接传入5和3，就能得到结果23了。&lt;/p&gt;
&lt;h2 id=&quot;tensor张量&quot;&gt;3. Tensor张量&lt;/h2&gt;
&lt;p&gt;张量，不是张亮，更不是麻辣烫，它是一种高维数据的统称。比如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;0维的张量，我们也叫做标量scalar或者数字，&lt;/li&gt;
&lt;li&gt;1维的张量，叫做向量vector&lt;/li&gt;
&lt;li&gt;2维的张量，叫做矩阵matrix&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;因此TensorFlow，可以理解为Tensor+Flow，即张量的数据流。&lt;/p&gt;
&lt;h2 id=&quot;数据流图的例子&quot;&gt;4. 数据流图的例子&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;import tensorflow as tf

# 第一个例子，计算两个数的加法
a = tf.constant(2)
b = tf.constant(3)
x = tf.add(a, b)
with tf.Session() as sess:
    print(sess.run(x))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上面的代码中，就构建了一个最基本的数据流图的计算例子。&lt;/p&gt;
&lt;p&gt;其中&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;a = tf.constant(2)
b = tf.constant(3)
x = tf.add(a, b)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;就是在构建图。而想要拿到x的值，就必须新建一个session（这个时候才会分配资源），执行run方法（这个时候才会执行）。&lt;/p&gt;
&lt;h2 id=&quot;tensorboard的使用&quot;&gt;5. tensorboard的使用&lt;/h2&gt;
&lt;p&gt;为了方便查看构建图，需要学会怎么使用TensorBoard。在上面的代码中，只需要增加Tensorboard的声明即可：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import tensorflow as tf

# 第一个例子，计算两个数的加法
a = tf.constant(2)
b = tf.constant(3)
x = tf.add(a, b)

with tf.Session() as sess:
    writer = tf.summary.FileWriter('./graphs', sess.graph)
    print(sess.run(x))

writer.close()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在命令行中输入&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;tensorboard --logdir=/Users/xingoo/PycharmProjects/xxx/graphs&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;登录&lt;code&gt;localhost:6006&lt;/code&gt;就可以看到下面的内容。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/xing901022/1187174/o_Jietu20181223-142045.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到左边有描述每个节点的意思，点击add后，可以到关于add节点的描述。由于构建的图很简单，就是两个数相加，因此整个图只有三个圈圈。并且按照默认的操作进行了命名。&lt;/p&gt;
&lt;h2 id=&quot;更复杂点的例子&quot;&gt;6. 更复杂点的例子&lt;/h2&gt;
&lt;p&gt;增加以下图的复杂度，并且同时对两个结果计算：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import tensorflow as tf

# tf.constant(value, dtype=None, shape=None, name='Const', verify_shape=False)

a = tf.constant([1, 3], name=&quot;a&quot;)
b = tf.constant([[0, 1], [2, 3]], name=&quot;b&quot;)

x = tf.add(a, b, name=&quot;add&quot;)
y = tf.multiply(a, b, name=&quot;mul&quot;)

with tf.Session() as sess:
    writer = tf.summary.FileWriter('./graphs', sess.graph)
    x, y = sess.run([x, y])
    print(x)
    print(y)
    writer.close()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于x、y是独立运算没有什么交集，因此在图中，他们是独立的两个操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/xing901022/1187174/o_Jietu20181223-142324.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;关于图&quot;&gt;7. 关于图&lt;/h2&gt;
&lt;p&gt;回头再来看看tensorFlow中的图到底是什么呢？当使用第5部分中的代码构建graph时，可以直接输出graph的定义：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import tensorflow as tf

a = tf.constant(2)
b = tf.constant(3)
x = tf.add(a, b)

with tf.Session() as sess:
    print(sess.graph.as_graph_def())&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;得到如下的内容：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;node {
  name: &quot;Const&quot;
  op: &quot;Const&quot;
  attr {
    key: &quot;dtype&quot;
    value {
      type: DT_INT32
    }
  }
  attr {
    key: &quot;value&quot;
    value {
      tensor {
        dtype: DT_INT32
        tensor_shape {
        }
        int_val: 2
      }
    }
  }
}
node {
  name: &quot;Const_1&quot;
  op: &quot;Const&quot;
  attr {
    key: &quot;dtype&quot;
    value {
      type: DT_INT32
    }
  }
  attr {
    key: &quot;value&quot;
    value {
      tensor {
        dtype: DT_INT32
        tensor_shape {
        }
        int_val: 3
      }
    }
  }
}
node {
  name: &quot;Add&quot;
  op: &quot;Add&quot;
  input: &quot;Const&quot;
  input: &quot;Const_1&quot;
  attr {
    key: &quot;T&quot;
    value {
      type: DT_INT32
    }
  }
}
versions {
  producer: 26
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;每个node基本都包含下面你的内容：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
    name：我们自己起的名字，如果没有则是op+自增的数,
    op：操作
    attr: 类型
    attr：值 {
        形状、初始值
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过上面的json，就能完美的组合出web中看到的图了。&lt;/p&gt;
&lt;p&gt;至于graph到底怎么用，就看后面一节课的内容吧。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://web.stanford.edu/class/cs20si/2017/&quot;&gt;CS 20SI: Tensorflow for Deep Learning Research&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 23 Dec 2018 06:37:00 +0000</pubDate>
<dc:creator>xingoo</dc:creator>
<og:description>最近看到一份不错的深度学习资源——Stanford中的CS20SI：《TensorFlow for Deep Learning Research》，正好跟着学习一下TensorFlow的基础，还是收获</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xing901022/p/10164264.html</dc:identifier>
</item>
<item>
<title>webgl绘制粗线段 - ccentry</title>
<link>http://www.cnblogs.com/ccentry/p/10164123.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ccentry/p/10164123.html</guid>
<description>&lt;p&gt;　　webgl1不支持设置线段宽度，这就只好通过shader来实现了，参考了踏得网的例子，引用地址：http://wow.techbrood.com/fiddle/43140。先在此感谢踏得网创始人之一 Ryan.chen 陈晓峰。介绍一下踏得网，这是一个推广交流webgl的网站，同学们可以去学习交流。由于本文代码完全抄用踏得网的例子，所以本文不是案例原创，但本文会将对借鉴代码的理解详细分析。&lt;/p&gt;
&lt;p&gt;　　我们先贴出shader着色器代码，来看一下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&amp;lt;script id=&quot;vertex&quot; type=&quot;x-shader&quot;&amp;gt;&lt;span&gt; 
            attribute vec2 aVertexPosition;
            
            &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main() {
                gl_Position &lt;/span&gt;= vec4(aVertexPosition, 0.0, 1.0&lt;span&gt;);
            }            
        &lt;/span&gt;&amp;lt;/script&amp;gt; 
        
        &amp;lt;script id=&quot;fragment&quot; type=&quot;x-shader&quot;&amp;gt;&lt;span&gt;
            #ifdef GL_ES
            precision highp &lt;/span&gt;&lt;span&gt;float&lt;/span&gt;&lt;span&gt;;
            #endif
            
            uniform vec4 uColor;
            
            &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main() {
                gl_FragColor &lt;/span&gt;=&lt;span&gt; uColor;
            }
        &lt;/span&gt;&amp;lt;/script&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;首先我们来分析一下顶点着色器vertex，只有一个attribute参数，是vec2类型的参数 aVertexPosition，线段的两个顶点坐标。接下来看片段着色器fragment，也只有一个参数，uniform参数，参数类型vec4，是传入的线段颜色参数。顶点着色器的主函数只是将gl_Position设置为线段的顶点坐标，片段着色器的主函数也仅仅是将gl_FragColor设置成参数传入的线段颜色。就是说线段上每一个position的顶点像素的颜色都是参数传入的线段颜色。&lt;br/&gt;　　接下来我们来看js代码。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;75&quot;&gt;
&lt;pre&gt;
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
            &lt;span&gt;function&lt;/span&gt;&lt;span&gt; init(){
                canvas &lt;/span&gt;= document.getElementById(&quot;mycanvas&quot;&lt;span&gt;);
                gl &lt;/span&gt;= canvas.getContext(&quot;experimental-webgl&quot;&lt;span&gt;);

                gl.viewport(&lt;/span&gt;0, 0&lt;span&gt;, canvas.width, canvas.height);    
                gl.clearColor(&lt;/span&gt;0, 0.5, 0, 1&lt;span&gt;);
                gl.clear(gl.COLOR_BUFFER_BIT);

                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; v = document.getElementById(&quot;vertex&quot;&lt;span&gt;).firstChild.nodeValue;
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; f = document.getElementById(&quot;fragment&quot;&lt;span&gt;).firstChild.nodeValue;
                
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; vs =&lt;span&gt; gl.createShader(gl.VERTEX_SHADER);
                gl.shaderSource(vs, v);
                gl.compileShader(vs);
                
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; fs =&lt;span&gt; gl.createShader(gl.FRAGMENT_SHADER);
                gl.shaderSource(fs, f);
                gl.compileShader(fs);

                program &lt;/span&gt;=&lt;span&gt; gl.createProgram();
                gl.attachShader(program, vs);
                gl.attachShader(program, fs);
                gl.linkProgram(program);
                
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;gl.getShaderParameter(vs, gl.COMPILE_STATUS)) 
                    console.log(gl.getShaderInfoLog(vs));
                    
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;gl.getShaderParameter(fs, gl.COMPILE_STATUS)) 
                    console.log(gl.getShaderInfoLog(fs));
                
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;gl.getProgramParameter(program, gl.LINK_STATUS)) 
                    console.log(gl.getProgramInfoLog(program));
                    
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; aspect = canvas.width /&lt;span&gt; canvas.height;
                
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; vertices = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Float32Array([
                    &lt;/span&gt;-0.5, 0.1*aspect, 0.5, 0.1*aspect, 0.5,0.11*&lt;span&gt;aspect,
                    &lt;/span&gt;-0.5, 0.1*aspect, 0.5, 0.11*aspect, -0.5,0.11*&lt;span&gt;aspect
                    ]);
                
                vbuffer &lt;/span&gt;=&lt;span&gt; gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, vbuffer);                    
                gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
                
                itemSize &lt;/span&gt;= 2&lt;span&gt;;
                numItems &lt;/span&gt;= vertices.length /&lt;span&gt; itemSize;

                gl.useProgram(program); 

                program.uColor &lt;/span&gt;= gl.getUniformLocation(program, &quot;uColor&quot;&lt;span&gt;);
                gl.uniform4fv(program.uColor, [&lt;/span&gt;1.0, 1.0, 0.0, 1.0&lt;span&gt;]);

                program.aVertexPosition &lt;/span&gt;= gl.getAttribLocation(program, &quot;aVertexPosition&quot;&lt;span&gt;);
                gl.enableVertexAttribArray(program.aVertexPosition);
                gl.vertexAttribPointer(program.aVertexPosition, itemSize, gl.FLOAT, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;, 0, 0&lt;span&gt;);

                gl.drawArrays(gl.TRIANGLES, &lt;/span&gt;0&lt;span&gt;, numItems);
            }
        &lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们看到，线段的顶点是vertices，其中有6组顶点，线段的颜色是黄色，就是这段代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
program.uColor = gl.getUniformLocation(program, &quot;uColor&quot;&lt;span&gt;);
                gl.uniform4fv(program.uColor, [&lt;/span&gt;1.0, 1.0, 0.0, 1.0]);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们可以看一下结果，如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1445864/201812/1445864-20181223134056919-1803553889.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们看到，这条线段是2D的矩形，并不是3D意义上的粗线段，还有一种思路，可以画一个圆柱代替线段。&lt;/p&gt;
&lt;p&gt;　　以上就是踏得网的粗线段的例子。&lt;/p&gt;

</description>
<pubDate>Sun, 23 Dec 2018 05:52:00 +0000</pubDate>
<dc:creator>ccentry</dc:creator>
<og:description>webgl1不支持设置线段宽度，这就只好通过shader来实现了，参考了踏得网的例子，引用地址：http://wow.techbrood.com/fiddle/43140。先在此感谢踏得网创始人之一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ccentry/p/10164123.html</dc:identifier>
</item>
<item>
<title>写给那些想要自学成才的java程序员 - codecarver</title>
<link>http://www.cnblogs.com/1314xf/p/10164055.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/1314xf/p/10164055.html</guid>
<description>&lt;p&gt;一：我的大学：第一年泡在图书馆看杂七杂八的书，跟学习毫无关系。第二年疯狂打LOL，从白银打到黄铜（黄铜守门员）。第三年上半年，被某人点醒，学习了整套C#知识体系，某马。下半年又决定转行，又开始了为期半年的自学java路程。所以我的经历可能适用一些正在学校的孩子或者准备转行做java的。&lt;/p&gt;
&lt;p&gt;二：如果你还是在校生，或者准备转行做java，你必须要学会下面的：&lt;/p&gt;
&lt;p&gt;2.1：java基础，不得不提，重中之重！你需要把每个知识点都记录下来，通过实战去强化，可以借助外来的视频资料，但是记住视频为辅（一般都不是很深入），看完对应的都必须要看一本书：&quot;java编程思想或者java核心技术&quot;，建议都看，十分经典，可以在你的笔记基础之上再次提升文章等级。&lt;/p&gt;
&lt;p&gt;2.2 ：对于有了java基础的小伙伴来说，那么不得不提的就是算法与数据结构以及设计模式这两大块内容，重中之重！依然是结合视频，你需要了解常用的数据结构，知道他们的使用场景以及性能分析，需要具备一定的算法能力，常用的排序算法等等之类，可以去leetcode网站去找一些算法题目去练练，java语言也可以在这个阶段再一次提高，你要注意你写的代码的逻辑性和美观性以及性能。设计模式不得不提，随处可见，23种设计模式都必须了解并知道之间的区别以及常用的场景，比如抽象工厂与建造者模式的区别，常用的单例模式，门面模式，等等。headfirst设计模式和算法4不错，可以在有了基础后再去看看。&lt;/p&gt;
&lt;p&gt;2.3 ：java、算法与数据结构、设计模式都必须学好，必须。会为你以后解决业务场景，看源码等等起到很关键的作用。&lt;/p&gt;
&lt;p&gt;2.4 ：学习了这些之后你可以尝试去学web开发相关的一些内容了，主要包括了Html/css/js,J2EE ,mysql相关的一些知识，对于如果以后专门要做java后端的小伙伴，前端相关知识可以稍微的花一些时间，因为不需要很久，可以入门。J2EE相关的你都必须掌握，servlet的运行原理等等很关键，mysql同样是你必须要非常深入的去学的内容，你必须要能熟练的写出SQL语句，业务的关键就在于此。你不仅仅要会写SQL，更要配合业务写出可重用，性能高的sql,建议深入的看一下高性能mysql，你不能仅仅停留在简单的增删改查，如果连数据库的设计都不会，性能优化都不了解，那么真的需要再逼一下自己，让自己懂的更多。&lt;/p&gt;
&lt;p&gt;2.5：到了这个地步，你应该可以试着开发一个完整的网站出来了，你可以在搜寻项目资料，自己去练，至少要有两个完整的，不管是跟着做还是自己做的，你能在这里面遇到很多bug,也能解决很多bug.这是你必须要迈过的门槛。&lt;/p&gt;
&lt;p&gt;2.6：现在你已经能靠着自己做出一个很一般的网站了，但是工作上用的远远不止这些，你可能还不能找到比较好的工作，当然若是你前面我说的那几个都非常优秀，尤其是算法和数据结构，那另当别论。如果前面掌握的很一般，那么你还需要学习一些常用的web框架，比如spring,springboot ,springmvc,mybatis,什么hibernate还有structs2就不要再碰了，你必须熟练掌握这些框架的基本用法，要能明白常用的一些配置，有兴趣的可以进入里面看看源码，记着：研究源码是你做这份工作不能停下来的事。spring重中之重，不断的探索，不断的去研究源码。顺便再学一下maven如何管理项目，还有git的一些pull,push ,merge,rebase等用法，公司很常用，不要仅仅停留在svn，很多公司都是用git的。&lt;/p&gt;
&lt;p&gt;2.7：当你学会了上述那些知识，有了自己的知识框架，也可以去找点工作干干了，还没毕业就赶紧找实习，攒工作经验，毕了业的就要继续下面的学习内容，不能停下来。&lt;/p&gt;
&lt;p&gt;三：工作一年经验内的小伙伴&lt;/p&gt;
&lt;p&gt;应该尝试了不少crud的滋味了吧，也接触到了复杂业务的情景了吧，加班成了平常事了吧，是不是开始又觉得漫无目的了。可能在开发中你会接触到新的知识，比如，springboot ,springcloud ,dubbo,zookeeper,linux,rabbitmq,redis,mongdb,kafka,elasticsearch等等，你需要学会去用好这些工具。&lt;/p&gt;
&lt;p&gt;四：工作1-3年的小伙伴&lt;/p&gt;
&lt;p&gt;可能你不再需要写简单的crud了，但是你能否自己搭建框架，能否写出可复用的模块代码，是否能写出优雅的代码，如果不能，还得继续学，必须重新拾起设计模式，要能对业务封装，对工具类封装，要能重构代码，要把设计模式运用到项目中去，你需要去看《重构 改善既有代码的设计》、《effective java》，久而久之，你可以写出比较出色又优雅的代码。但这还不够，你必须要对java虚拟机有深入的理解，要能解决项目中遇到的内存溢出异常等等，这部分内容比较枯燥，但是你必须要啃下去，还要会模拟场景去制造异常，因为很多异常你真的不知道从何下手，只能从日志里去看堆栈的打印信息，去看虚拟机的日志信息，去分析，你才能解决问题。所以必须学好，必须死磕这方面的内容。与此同时你还需要研究jdk的源码，就跟着你一开始学java基础的来，从集合开始，去深入的看源码，这时候你会发现java基础和数据结构和设计模式有多重要。还需要去学习并发相关的知识，要对Java并发包java.concurrent有深刻的认识，这些内容需要你摒弃浮躁的心，慢慢看，不能急，急你也看不出什么效果。&lt;/p&gt;
&lt;p&gt;五：3年及以上&lt;/p&gt;
&lt;p&gt;可能在这个阶段的小伙伴提升已经很难了，你可能已经接触过很多分布式相关的技术了，分布式缓存，分布式消息队列，分布式计算，负载均衡，大数据等等，你可能都已经用过了，所以现在的你既有了基础知识的架构支撑，也还没到退休年龄（哈哈），建议你深入的去研究一门技术，是很深入，不要既搞分布式计算，又搞分布式缓存，又研究大数据等等，说自己懂的那么多，花里胡哨的，真正懂得基本都能拿下你。所以你必须开始确定自己的研究方向，专门的去研究某个内容，让这一块成为你的优势和强项，这也是为了避免大龄被淘汰的法门。你应该朝着某个领域的专家去努力。&lt;/p&gt;
&lt;p&gt;六：提高自己的影响力&lt;/p&gt;
&lt;p&gt;有了自己深入研究的方向，你应该去帮助更多的人，去发表更多的优质文章，也可以去打造属于自己的开源项目，做出对别人，对自己有价值的东西。所以这个阶段的你应该提高自己的影响力，帮助更多的人，更多想学习的人。因为你老了。&lt;/p&gt;
&lt;p&gt;七：最后希望你们能入了门，成为自己想成为的人，如果有想要资料的，留下邮箱或者加微信号：codecarver&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/708226/201812/708226-20181223133409785-72236480.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 23 Dec 2018 05:35:00 +0000</pubDate>
<dc:creator>codecarver</dc:creator>
<og:description>一：我的大学：第一年泡在图书馆看杂七杂八的书，跟学习毫无关系。第二年疯狂打LOL，从白银打到黄铜（黄铜守门员）。第三年上半年，被某人点醒，学习了整套C 知识体系，某马。下半年又决定转行，又开始了为期半</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/1314xf/p/10164055.html</dc:identifier>
</item>
</channel>
</rss>