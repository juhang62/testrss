<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>android:layout_weight属性详解 - 知亦行</title>
<link>http://www.cnblogs.com/wonker/p/10642995.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wonker/p/10642995.html</guid>
<description>&lt;p&gt;&lt;span&gt;weight：重量、权重。&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　当我们给一个view设置了android:layout_weight属性，意味着赋予它话语权，常规思维就是谁的weight大，谁说了算（空间占比大）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1585858/201904/1585858-20190402152947127-1617361870.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　下面我们来看下具体的代码：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36.5&quot;&gt;
&lt;pre readability=&quot;6&quot;&gt;
&amp;lt;LinearLayout&lt;br/&gt;android:layout_width=&quot;match_parent&quot;&lt;br/&gt;android:layout_height=&quot;wrap_content&quot;&amp;gt;&lt;br/&gt;&amp;lt;Button&lt;br/&gt;android:text=&quot;我的weight是2&quot;&lt;br/&gt;android:layout_weight=&quot;2&quot;&lt;br/&gt;android:layout_width=&quot;wrap_content&quot;&lt;br/&gt;android:layout_height=&quot;wrap_content&quot; /&amp;gt;&lt;p&gt;&amp;lt;Button&lt;br/&gt;android:layout_width=&quot;wrap_content&quot;&lt;br/&gt;android:layout_height=&quot;wrap_content&quot;&lt;br/&gt;android:text=&quot;我的weight是1&quot;&lt;br/&gt;android:layout_weight=&quot;1&quot;/&amp;gt;&lt;/p&gt;&lt;p&gt;&amp;lt;/LinearLayout&amp;gt;
&lt;/p&gt;&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;两个Button的宽度设置的是&lt;span&gt;wrap_content&lt;span&gt;，此时weight属性使LinearLayout给内部的两个Button按&lt;span&gt;2:1&lt;/span&gt;的权重分配了所有宽度空间。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;官方推荐使用weight按比例分配宽度空间时，将LinearLayout内View的宽度设置为0。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 02 Apr 2019 07:41:00 +0000</pubDate>
<dc:creator>知亦行</dc:creator>
<og:description>weight：重量、权重。 当我们给一个view设置了android:layout_weight属性，意味着赋予它话语权，常规思维就是谁的weight大，谁说了算（空间占比大）。 下面我们来看下具体的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wonker/p/10642995.html</dc:identifier>
</item>
<item>
<title>C# 填充Excel图表、图例背景色 - E-iceblue</title>
<link>http://www.cnblogs.com/Yesi/p/10642362.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Yesi/p/10642362.html</guid>
<description>&lt;p&gt;填充背景色，一般可以选择多种不同样式来填充背景，包括填充为纯色背景、渐变背景、图片背景或者纹理背景等。下面的内容将分别介绍通过C#来设置Excel中图表背景色、以及图表中的图例背景色的方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用工具&lt;/strong&gt;：&lt;a href=&quot;https://www.e-iceblue.cn/Downloads/Spire-XLS-NET.html&quot;&gt;Spire.XLS for .NET&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;dll引用：下载安装后，注意在程序中添加引用Spire.Xls.dll（dll文件在安装路径下的bin文件夹中获取）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/706090/201904/706090-20190402135213958-1774280036.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;【示例1】填充图表背景色&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;测试文档如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/706090/201904/706090-20190402135400009-1330580529.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Step1：加载文档&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实例化Workbook类的对象&lt;/span&gt;
Workbook workbook = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Workbook();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加载测试文档&lt;/span&gt;
workbook.LoadFromFile(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sample.xlsx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Step2：获取图表&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取第一个工作表中的第一个图表&lt;/span&gt;
Worksheet ws = workbook.Worksheets[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
Chart chart &lt;/span&gt;= ws.Charts[&lt;span&gt;0&lt;/span&gt;];
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Step3：填充图表背景色（纯色）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置图表的背景填充色（纯色）&lt;/span&gt;
 chart.ChartArea.Fill.ForeColor =&lt;span&gt; Color.LightSkyBlue;
 &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;/设置图表绘图区域的背景填充色（纯色）
 &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;chart.PlotArea.ForeGroundColor =System.Drawing.Color.LightYellow;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Step4:加载图片填充图表背景&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 加载图片，填充整个图表区域&lt;/span&gt;
chart.ChartArea.Fill.CustomPicture(Image.FromFile(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tp.png&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;), &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;None&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置绘图区域的图片填充的透明度&lt;/span&gt;
chart.PlotArea.Fill.Transparency = &lt;span&gt;0.8&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;/加载图片，仅填充图表中的绘图区域&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;chart.PlotArea.Fill.CustomPicture(Image.FromFile(&quot;tp.png&quot;), &quot;None&quot;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Step5:保存文档&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
workbook.SaveToFile(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;result.xlsx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, ExcelVersion.Version2010);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;纯色背景色设置效果：&lt;/p&gt;
&lt;p&gt;1.填充整个图表&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/706090/201904/706090-20190402140246985-2131017584.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.填充图表中的绘图区域&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/706090/201904/706090-20190402140319028-1234504179.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图片填充效果：&lt;/p&gt;
&lt;p&gt;1.填充整个图表&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/706090/201904/706090-20190402140333897-127536607.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.填充图表中的绘图区域&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/706090/201904/706090-20190402140349299-752795473.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;全部代码：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_4c8f59bb-c665-44c2-a45f-335de624f8f1&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_4c8f59bb-c665-44c2-a45f-335de624f8f1&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_4c8f59bb-c665-44c2-a45f-335de624f8f1&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Spire.Xls;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Spire.Xls.Core.Spreadsheet.Charts;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Drawing;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; FillChartWithImg_XLS
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实例化Workbook类的对象&lt;/span&gt;
            Workbook workbook = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Workbook();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加载测试文档&lt;/span&gt;
            workbook.LoadFromFile(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sample.xlsx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取第一个工作表中的第一个图表&lt;/span&gt;
            Worksheet ws = workbook.Worksheets[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
            Chart chart &lt;/span&gt;= ws.Charts[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置图表的背景填充色（纯色）&lt;/span&gt;
            chart.ChartArea.Fill.ForeColor =&lt;span&gt; Color.LightSkyBlue;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置图表绘图区域的背景填充色（纯色）
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;chart.PlotArea.ForeGroundColor = System.Drawing.Color.LightYellow;&lt;/span&gt;


            &lt;span&gt;///&lt;/span&gt;&lt;span&gt;/ 加载图片，填充整个图表区域&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;chart.ChartArea.Fill.CustomPicture(Image.FromFile(&quot;tp.png&quot;), &quot;None&quot;);&lt;/span&gt;
            &lt;span&gt;///&lt;/span&gt;&lt;span&gt;/设置绘图区域的图片填充的透明度&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;chart.PlotArea.Fill.Transparency = 0.8;&lt;/span&gt;

            &lt;span&gt;///&lt;/span&gt;&lt;span&gt;/加载图片，仅填充图表中的绘图区域&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;chart.PlotArea.Fill.CustomPicture(Image.FromFile(&quot;tp.png&quot;), &quot;None&quot;);            

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存文档&lt;/span&gt;
            workbook.SaveToFile(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;result3.xlsx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, ExcelVersion.Version2010);
            System.Diagnostics.Process.Start(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;result3.xlsx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);           
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;【示例2】填充图表中的图例背景色&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;测试图表：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/706090/201904/706090-20190402140557498-853374511.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Step1：加载文档&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实例化Workbook类的对象，并加载测试文档&lt;/span&gt;
Workbook workbook = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Workbook();
workbook.LoadFromFile(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test.xlsx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Step2：获取图表&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取工作表中的第一个图表&lt;/span&gt;
Worksheet ws = workbook.Worksheets[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];
Spire.Xls.Chart chart &lt;/span&gt;= ws.Charts[&lt;span&gt;0&lt;/span&gt;];
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Step3：单色填充图例背景&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;填充图例背景色&lt;/span&gt;
XlsChartFrameFormat x = chart.Legend.FrameFormat &lt;span&gt;as&lt;/span&gt;&lt;span&gt; XlsChartFrameFormat;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;单色填充&lt;/span&gt;
x.Fill.FillType =&lt;span&gt; ShapeFillType.SolidColor;
x.ForeGroundColor &lt;/span&gt;= Color.Gainsboro;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Step4：渐变色填充图例背景&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;渐变色填充&lt;/span&gt;
x.Fill.FillType =&lt;span&gt; ShapeFillType.Gradient;
x.ForeGroundColor &lt;/span&gt;=&lt;span&gt; Color.AliceBlue;
x.BackGroundColor &lt;/span&gt;= Color.Bisque;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Step5：纹理填充图例背景&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;纹理填充&lt;/span&gt;
x.Fill.FillType =&lt;span&gt; ShapeFillType.Texture;
x.Fill.Texture &lt;/span&gt;= GradientTextureType.Bouquet;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Step6：加载图片填充图例背景&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;图片填充&lt;/span&gt;
x.Fill.CustomPicture(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;img.png&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Step7：保存文档&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
workbook.SaveToFile(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;output.xlsx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, ExcelVersion.Version2010);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;图例背景色填充效果：&lt;/p&gt;
&lt;p&gt;1.单色填充效果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/706090/201904/706090-20190402141209079-1348287076.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.渐变填充效果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/706090/201904/706090-20190402141220991-492979489.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.纹理填充效果&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/706090/201904/706090-20190402141235289-1479879614.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.图片填充效果&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/706090/201904/706090-20190402141252483-1997268146.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;全部代码：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_f7e05657-e388-45da-bd89-8ee3e0db02b8&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_f7e05657-e388-45da-bd89-8ee3e0db02b8&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_f7e05657-e388-45da-bd89-8ee3e0db02b8&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Spire.Xls;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Spire.Xls.Charts;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Spire.Xls.Core.Spreadsheet.Charts;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Drawing;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; SetFontOfLegendInChart_XLS
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实例化Workbook类的对象，并加载测试文档&lt;/span&gt;
            Workbook workbook = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Workbook();
            workbook.LoadFromFile(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test.xlsx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取工作表中的第一个图表&lt;/span&gt;
            Worksheet ws = workbook.Worksheets[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];
            Spire.Xls.Chart chart &lt;/span&gt;= ws.Charts[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;填充图例背景色&lt;/span&gt;
            XlsChartFrameFormat x = chart.Legend.FrameFormat &lt;span&gt;as&lt;/span&gt;&lt;span&gt; XlsChartFrameFormat;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;单色填充&lt;/span&gt;
            x.Fill.FillType =&lt;span&gt; ShapeFillType.SolidColor;
            x.ForeGroundColor &lt;/span&gt;=&lt;span&gt; Color.Gainsboro;

            &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;/渐变色填充&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;x.Fill.FillType = ShapeFillType.Gradient;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;x.ForeGroundColor = Color.AliceBlue;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;x.BackGroundColor = Color.Bisque;&lt;/span&gt;

            &lt;span&gt;///&lt;/span&gt;&lt;span&gt;/纹理填充&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;x.Fill.FillType = ShapeFillType.Texture;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;x.Fill.Texture = GradientTextureType.Bouquet;&lt;/span&gt;

            &lt;span&gt;///&lt;/span&gt;&lt;span&gt;/图片填充&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;x.Fill.CustomPicture(&quot;img.png&quot;);

             &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存文档&lt;/span&gt;
            workbook.SaveToFile(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;output.xlsx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, ExcelVersion.Version2010);
            System.Diagnostics.Process.Start(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;output.xlsx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;更多Excel背景色填充的方法，可参考以下文章：&lt;/p&gt;
&lt;p&gt;1. &lt;a href=&quot;https://www.cnblogs.com/Yesi/p/7569580.html&quot;&gt;C# 设置Excel单元格背景色&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2. &lt;a href=&quot;https://www.cnblogs.com/Yesi/p/5337989.html&quot;&gt;C# 设置Excel表格图片背景&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;（本文完）&lt;/p&gt;
&lt;p&gt;转载请注明出处！&lt;/p&gt;
</description>
<pubDate>Tue, 02 Apr 2019 06:19:00 +0000</pubDate>
<dc:creator>E-iceblue</dc:creator>
<og:description>填充背景色，一般可以选择多种不同样式来填充背景，包括填充为纯色背景、渐变背景、图片背景或者纹理背景等。下面的内容将分别介绍通过C#来设置Excel中图表背景色、以及图表中的图例背景色的方法。 使用工具</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Yesi/p/10642362.html</dc:identifier>
</item>
<item>
<title>品阿里 Java 开发手册有感 - www.bysocket.com</title>
<link>http://www.cnblogs.com/Alandre/p/10642327.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Alandre/p/10642327.html</guid>
<description>&lt;p&gt;摘要: 原创出处 https://www.bysocket.com 「公众号：泥瓦匠BYSocket 」欢迎关注和转载，保留摘要，谢谢！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://springforall.ufile.ucloud.com.cn/static/img/5a13bfdf006a9ffeed991a13833f7df61542084&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一个优秀的工程师和一个普通的工程师的区别，不是满天飞的架构图，他的功底体现在所写的每一行代码上。&lt;br/&gt;-- 毕玄&lt;/p&gt;
&lt;h2&gt;1. 命名风格&lt;/h2&gt;
&lt;p&gt;【书摘】类名用 UpperCamelCase 风格，比如 DO/BO/VO/PO&lt;/p&gt;
&lt;p&gt;【书摘】方法用 lowerCamelCase 风格，尽量是动词&lt;/p&gt;
&lt;p&gt;小思考：例如常用的&lt;br/&gt;- 获取单个对象，getUserById&lt;br/&gt;- 获取对象累不，listUserByGroupId&lt;br/&gt;- 统计对象数量，countUserByClassId&lt;br/&gt;- 新增、删除，insert,delete,update 等&lt;/p&gt;
&lt;h2&gt;2. 常量定义&lt;/h2&gt;
&lt;p&gt;【书摘】如果变量值仅在一个范围变化，则用 enum 类型&lt;/p&gt;
&lt;p&gt;小思考：例如电商中订单状态，用手指也能列出来。所以一般定义个 OrderSatausEnum 搞定，伪代码如下：&lt;/p&gt;
&lt;pre class=&quot;line-numbers prism-highlight&quot; data-start=&quot;1&quot;&gt;
&lt;code class=&quot;language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;enum OrderSatausEnum {
    TO_PAY(&lt;span class=&quot;hljs-number&quot;&gt;1,&lt;span class=&quot;hljs-string&quot;&gt;&quot;代付款&quot;), PAID(&lt;span class=&quot;hljs-number&quot;&gt;2,&lt;span class=&quot;hljs-string&quot;&gt;&quot;已付款&quot;) ...;

    &lt;span class=&quot;hljs-keyword&quot;&gt;private Integer orderStatus;
    &lt;span class=&quot;hljs-keyword&quot;&gt;private String orderSatausDes;

    OrderSatausEnum(Integer orderStatus,String orderSatausDes) {
        &lt;span class=&quot;hljs-keyword&quot;&gt;this.orderStatus = orderStatus;
        &lt;span class=&quot;hljs-keyword&quot;&gt;this.orderSatausDes = orderSatausDes;
    }

    &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;进一步，如果订单某天要加个“待拼团”状态咋办？所以这些配置化的东西，可以上配置中心。比如携程出的 apollo 等&lt;/p&gt;
&lt;h2&gt;3. OOP 规则&lt;/h2&gt;
&lt;p&gt;【书摘】Object 的 equals 方法容易抛空指针异常，应使用常量或者确定优质的对象来调用 equals 。&lt;/p&gt;
&lt;p&gt;比如：“TO_PAY”.equals(order.getOrderStatus())。反着写就不对了，因为 order.getOrderStatus() 可能为 null。&lt;/p&gt;
&lt;p&gt;自然，更加推荐 java.util.Objects#equals 工具类。&lt;/p&gt;
&lt;p&gt;【书摘】所有相同类型的包装类对象之间的值比较，全部使用 equals 方法。&lt;/p&gt;
&lt;p&gt;小思考：别用 == 了。equals 也要注意些事情，比如 Byte 类型的 status 对象值，用 equals 要注意如下：&lt;/p&gt;
&lt;pre class=&quot;line-numbers prism-highlight&quot; data-start=&quot;1&quot;&gt;
&lt;code class=&quot;language-java hljs&quot;&gt;getStatus().equals(&lt;span class=&quot;hljs-number&quot;&gt;0) &lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还有， == 比如 Integer 在 -128 到 127 范围比较正常，超过就不正常。原因是 -128 到 127 范围的对象在 IntegerCache.cache 中产生，会复用对象。所以所以，切记切记，别用 == 了，用 equals 去比较。&lt;/p&gt;
&lt;h2&gt;4. 集合处理&lt;/h2&gt;
&lt;p&gt;【书摘】不要在 for 循环中进行元素的 remove/add 操作。remove 请使用 Iterator 方法，如果有并发操作，则对 Iterator 对象加锁。&lt;/p&gt;
&lt;p&gt;具体 Iterator 怎么操作集合，百度下即可。这还是典型的 迭代器设计模式，可以深入源码看看人家的简单实现原理，又能学到一发高级知识。&lt;/p&gt;
&lt;h2&gt;5. 并发处理&lt;/h2&gt;
&lt;p&gt;【书摘】第一，线程必须通过线程池来提供，不允许显式创建线程。第二，线程池不允许用 Executors 创建，应使用 ThreadPoolExecutor 去创建。因为&lt;br/&gt;Executors 创建的几种 ThreadPool 会有弊端：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;FixedThreadPool 和 SingleThreadPool 允许请求队列长度为 Integer.MAX_VALUE ，大量请求，会导致 OOM&lt;/li&gt;
&lt;li&gt;CachedThreadPool 和 ScheduledThreadPool 允许创建最大的线程数为 Integer.MAX_VALUE，大量创建线程，会导致 OOM&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以，使用 ThreadPoolExecutor 的原因是能更好地理解线程池的运行规则，规避资源耗尽，更好地贴合某个业务场景，去创建更适合的线程池。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;【书摘】在高并发场景中，同步调用应该考虑锁的性能损耗。能用无锁数据结构，就不要用锁；能锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁。即，加锁的粒度越小，性能损耗越小。并且避免锁的代码块中调用了 RPC 方法。&lt;/p&gt;
&lt;p&gt;另外，同时对多个资源加锁的时候，需要保持一致的加锁顺序。否则，一个线程加锁顺序为 ABC,另一个加锁顺序为 ACB 或 BAC 等，会造成死锁。如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://springforall.ufile.ucloud.com.cn/static/img/6102204b542b053f561efd6cfaff0bf31542247&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;【书摘】金融资金相关信息，使用悲观锁。比如更新某个用户的钱包余额字段。&lt;/p&gt;
&lt;p&gt;小思考：我以前做 P2P 的时候，就很简单地使用了 MySQL 的行锁。&lt;/p&gt;
&lt;pre class=&quot;line-numbers prism-highlight&quot; data-start=&quot;1&quot;&gt;
&lt;code class=&quot;language-sql hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;SELECT * &lt;span class=&quot;hljs-keyword&quot;&gt;FROM xx WHREER xx.&lt;span class=&quot;hljs-keyword&quot;&gt;id=&lt;span class=&quot;hljs-number&quot;&gt;888 &lt;span class=&quot;hljs-keyword&quot;&gt;FOR &lt;span class=&quot;hljs-keyword&quot;&gt;UPDATE
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体行锁，表锁大家可以自行百度了解。&lt;/p&gt;
&lt;h2&gt;6. 控制语句&lt;/h2&gt;
&lt;p&gt;【书摘】高并发场景，比如秒杀场景，商品扣库存，库存的判断不要用“等于”来判断商品库存已售罄的条件。应使用大于或者小于的条件来代替。&lt;/p&gt;
&lt;p&gt;小思考：这是典型的超卖场景。有人会问也会存在超卖几件的问题吧？答案是是的。但如果用 等于 来判断，超卖的件数会很多很多，比如达到 1 万件。但超卖 1 万件和超卖 1 件是不一样等级的故障。或者是一个故障和一个不是故障的区别。&lt;/p&gt;
&lt;h2&gt;7.异常处理&lt;/h2&gt;
&lt;p&gt;【书摘】异常不要用来做流程控制，条件控制&lt;/p&gt;
&lt;p&gt;小思考：昨天京东小哥问我，这个能这么搞降级吗？如下代码：&lt;/p&gt;
&lt;pre class=&quot;line-numbers prism-highlight&quot; data-start=&quot;1&quot;&gt;
&lt;code class=&quot;language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;try {
    searchFromES()
}&lt;span class=&quot;hljs-keyword&quot;&gt;catch(){
    searchFromDB()
}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这不算降级，这也不能这么搞。第一，代码这也写就不对，异常不要用来做流程控制，条件控制。第二，这个只要实现 ES 读取有问题，读取不到就读 DB。可以考虑责任链设计模式去实现。伪代码如下：&lt;/p&gt;
&lt;pre class=&quot;line-numbers prism-highlight&quot; data-start=&quot;1&quot;&gt;
&lt;code class=&quot;language-java hljs&quot;&gt;&lt;br/&gt;ESHandle {
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;handle&lt;span class=&quot;hljs-params&quot;&gt;() {
        &lt;span class=&quot;hljs-keyword&quot;&gt;try {
            searchFromES()
        }&lt;span class=&quot;hljs-keyword&quot;&gt;catch(){
        }
    }
}

DBHandle {
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;handle&lt;span class=&quot;hljs-params&quot;&gt;() {
        &lt;span class=&quot;hljs-keyword&quot;&gt;try {
            searchFromES()
        }&lt;span class=&quot;hljs-keyword&quot;&gt;catch(){
        }
    }
}

&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;8. 建表规约 、SQL 语句&lt;/h2&gt;
&lt;p&gt;【书摘】当单表行数超过 500 万行或者单表容量超过 2 GB时，才推荐进行分库分表。&lt;/p&gt;
&lt;p&gt;如果预计三年后的数量级无法达到这个级别，请不要在创建表时就分库分表。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;【书摘】不要使用 count(列名) 或者 count(常量) 来替代 count(*)。 因为它是 SQL92 定义的标准统计行数的预发。它会统计 NULL 的行。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;【书摘】where 条件下里面的 in 能避免就避免，要注意 in 里面的集合数量，控制在 1000 个之内。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;【书摘】在代码中写分页查询，如果 count 为 0 ，直接返回 空列表。避免执行下面的分页语句。&lt;/p&gt;
&lt;h2&gt;9.服务器&lt;/h2&gt;
&lt;p&gt;【书摘】高并发服务器建议调小 TCP 协议的 time_wait 超时时间。Linux 修改 /etc/sysctl.conf 文件，代码如下：&lt;/p&gt;
&lt;pre class=&quot;line-numbers prism-highlight&quot; data-start=&quot;1&quot;&gt;
&lt;code class=&quot;language-null&quot;&gt;net.ipv4.tcp_fin_timeout = 30
&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;【书摘】JVM 设置参数 -XX:+HeapDumpOnOutOfMemoryError。让 JVM 碰到 OOM 的时候，输出 dump 信息。&lt;/p&gt;
&lt;p&gt;小思考：这个很重要。二者得保留事故服务器现场。比如 OOM 了某个服务器，则在 VIP 或者啥摘到该机器，让该机器不再有请求进入。然后去查看 dump 信息，去排查 OOM 问题。&lt;/p&gt;
&lt;h2&gt;最后&lt;/h2&gt;
&lt;p&gt;感谢小册子《阿里巴巴 Java 开发手册》，感觉不错。至少其中有几点，有目共睹的。&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;&lt;img src=&quot;http://www.bysocket.com/wp-content/uploads/2017/01/qrcode_for_gh_cd421e7eb7d6_430.jpg&quot; alt=&quot;&quot; width=&quot;224&quot; height=&quot;224&quot;/&gt; &lt;br/&gt;（关注微信公众号，领取 Java 精选干货学习资料）&lt;/div&gt;
</description>
<pubDate>Tue, 02 Apr 2019 06:14:00 +0000</pubDate>
<dc:creator>www.bysocket.com</dc:creator>
<og:description>摘要: 原创出处 https://www.bysocket.com 「公众号：泥瓦匠BYSocket 」欢迎关注和转载，保留摘要，谢谢！ 一个优秀的工程师和一个普通的工程师的区别，不是满天飞的架构图，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Alandre/p/10642327.html</dc:identifier>
</item>
<item>
<title>996：只要能活着就好，不管活得多么糟糕 - 沉默王二</title>
<link>http://www.cnblogs.com/qing-gee/p/10642292.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qing-gee/p/10642292.html</guid>
<description>&lt;p&gt;划重点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;996 是指每天早上 9 点上班，晚上 9 点下班，每周上 6 天班&lt;/li&gt;
&lt;li&gt;至于剩下的那天能不能休息，全靠天意&lt;/li&gt;
&lt;li&gt;没有家，即使有，也只是个补充睡眠的窝&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;h01&quot;&gt;01、&lt;/h3&gt;
&lt;p&gt;最近，&lt;a href=&quot;https://mp.weixin.qq.com/s/feoOINGSyivBO8Z1gaQVOA&quot;&gt;我&lt;/a&gt; 这个程序员所在的圈子里发生了一件天大的事。有个“胆大包天”的家伙在 GitHub 上发起了一个名为“996.ICU”（工作 996，生病 ICU）的项目，号召被压榨的程序员们联合起来抵制互联网公司的996工作制。&lt;/p&gt;
&lt;p&gt;多说一句，GitHub 虽然是代码托管平台，但这个项目和代码没有半点关系，但绝对和写代码的程序员有天大的关系；甚至和程序员的家庭也有很大的关系。&lt;/p&gt;
&lt;p&gt;这个项目之所以会火，我想原因是这样的：&lt;/p&gt;
&lt;p&gt;海明威在《钟为谁鸣》说过这么一个意思：&lt;strong&gt;所有人是一个整体，别人的不幸就是你的不幸&lt;/strong&gt;。所以，不要问丧钟是为谁而鸣——它就是为你而鸣。&lt;/p&gt;
&lt;p&gt;王小波在他的杂文里也表达过这个意思：在德国的纳粹时期，有一个德国牧师，他说，那些人抓犹太人，我不说话，因为我是雅利安人；后来他们抓天主教徒，我不说话，因为我是新教徒……最后他们来抓我，已经没人能为我说话了。&lt;/p&gt;
&lt;p&gt;我虽然是“沉默王二”，也不在 996 的行列里，但对于这件事，我并不打算保持沉默。&lt;/p&gt;
&lt;h3 id=&quot;h02&quot;&gt;02、&lt;/h3&gt;
&lt;p&gt;我老婆是一名画建筑图纸的工程师。但她的情况似乎比 996 要糟糕得多，为什么这么说呢？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;公司规定，早上上班的时间是 8 点 20，迟到 10 分钟扣 50 块钱。&lt;/li&gt;
&lt;li&gt;公司规定，晚上下班的时间是 6 点，但因为工作量太大，几乎要加班到 9 点以后，没有加班费。&lt;/li&gt;
&lt;li&gt;公司规定，周末至少上半天班，但因为工作量太大，几乎周末两天都要加班，没有加班费。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;工作占据了她绝大多数的时间。幸好我们家离她公司不远，不然真的是：“&lt;strong&gt;进公司的时候太阳刚刚升起，走的时候月亮高高挂起&lt;/strong&gt;。”&lt;/p&gt;
&lt;p&gt;我时常劝她学聪明点：干活不要那么积极，该休息的时候适当休息一下，毕竟身体是自己的。&lt;/p&gt;
&lt;p&gt;她表示非常无辜：领导天天盯着你的进度，你怎么休息，有时候催得我一天连水都喝不上一口。况且，我如果不拼命干的话，发年终奖的时候肯定少很多。我们家这么穷，以后还要赡养四个老人，我们还有一个娃娃要养。&lt;/p&gt;
&lt;p&gt;我记得有一次，老婆加班到很晚，半夜一点多还没有回家，打手机没人接，发 QQ 没人回，打公司电话也没有人接。那一刻，我真担心她猝死了。实在是联系不上她，我只好抱着熟睡的女儿，开车去了她的公司，一路上担惊受怕。最后发现她和几个同事还在加班，领导就站在旁边盯着。&lt;/p&gt;
&lt;p&gt;同事和领导见到我后，笑她有一个好老公。而我，看到她安然无恙，终于松了一口气。&lt;/p&gt;
&lt;p&gt;后来，她给自己买了一份保险。她怕自己真的会猝死！&lt;/p&gt;
&lt;h3 id=&quot;h03&quot;&gt;03、&lt;/h3&gt;
&lt;p&gt;程序员世界里的大佬曹政说：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;996 是市场选择，不是某个企业家或者某个企业决定的，没有谁可以只手遮天。给他们底气的，是那些排队等 offer 的应聘者。这很不正确，但这是事实，事实经常不正确。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;出于对曹大佬的尊重，我极不情愿地没有送上一句脏话。但这样的言论，真是够气人的！曹大佬一定很有钱了，也财务自由了，也时间自由了——所以他并不能饱尝 996 背后的辛酸。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们人，并不像风和水那样浑然无觉，不知疲倦&lt;/strong&gt;。如果 996 真的是市场选择的话，那我们干脆回到“吃大苦、耐大劳”的时代吧。我们为什么要发展经济？为什么要解放生产力呢？我们程序员编写的程序难道不是为了让这个世界变得更美好、更智能、更幸福吗？&lt;/p&gt;
&lt;p&gt;再说，给“他们”（应该是它们）底气的，根本不是那些排队等 offer 的应聘者，而是资本的贪婪。也许，曹大佬的本意并不是这样的，他也想体恤广大的程序员朋友们，他也恨 996，但为了让文章吸引更多人的眼球，引来更多的批评，他便靠着自己的雄辩站在了对立面。&lt;/p&gt;
&lt;p&gt;记得我刚参加工作的那会，项目忙的时候也经常加班。差不多每天至少要加班到晚上 10 点多，周末也没有休息天，非常的累。但公司是不强制加班的，也有加班费。项目如果不忙的话，晚上 6 点下班就走也是可以的。我没有遇到过项目非常忙但就是不加班的程序员，大多数的程序员都是敬业爱岗的。&lt;/p&gt;
&lt;p&gt;但如果公司非要强制 996，逼迫员工加班，那就是雇主在仗势欺人了——我们是人，不是机器，每周工作 5 天，每天工作 8 小时是我们拼尽全力争取到的权利（为数不多）；我们除了工作，还要生活。&lt;/p&gt;
&lt;p&gt;托马斯·杰佛逊（美国第三任总统）曾说过：“&lt;strong&gt;我生命中最幸福的时刻就是在家庭的温暖怀抱中度过的那些时光&lt;/strong&gt;。”但我从没听过有人说，我生命中最幸福的时候就是在公司的 996 工作制中度过的那些时光。&lt;/p&gt;
&lt;h3 id=&quot;h04&quot;&gt;04、&lt;/h3&gt;
&lt;p&gt;有人在知乎上问：“除了利用 GitHub 发起抗议，还有哪些巧妙的方案来抵制 996 ？”&lt;/p&gt;
&lt;p&gt;安晓辉前辈给出了一个我不敢苟同的答案：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;确认自己不需要通过 996 拿更多薪水过更丰裕的日子。&lt;/li&gt;
&lt;li&gt;从今天起抵制 996，挺起来，不加班。&lt;/li&gt;
&lt;li&gt;如果因为抵制 996 和公司闹得水火不容，那就果断离开。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;我不敢苟同的原因是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;拿更多薪水过更丰裕的日子和 996 有什么必然关系吗？&lt;/li&gt;
&lt;li&gt;如果不加班能解决问题的话，还需要利用 GitHub 发起抗议吗？&lt;/li&gt;
&lt;li&gt;为什么雇员被欺负了，还要委屈地承担后果，而不是雇主呢？&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;在我看来，利用 GitHub 发起抗议是程序员力所能及的最巧妙的方案——139947 个 star 中我贡献了一个——&lt;strong&gt;我相信，我们善意的举动一定会带来一些积极的变化&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;h05&quot;&gt;05、&lt;/h3&gt;
&lt;p&gt;有人说：服务人员比程序员更惨，他们没有一丁点儿的休息时间。他们都没吭声，你们程序员到叫起苦来了。&lt;/p&gt;
&lt;p&gt;我反对！&lt;strong&gt;我们来到这个世界上，难道是为了比谁过得更惨吗？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;特斯拉 CEO 埃隆·马斯克说：要想“改变世界”，人们每周需要工作大约 80 到 100 个小时。我自己是每周工作 120 个小时，所以特斯拉人每周至少也要工作 100 个小时。&lt;/p&gt;
&lt;p&gt;我反对！不是每个特斯拉人都热衷于移民火星的，也不是每个特斯拉人都能拿马斯克那么多股份的。&lt;/p&gt;
&lt;p&gt;任正非说：伟大的背后，皆是苦难。&lt;/p&gt;
&lt;p&gt;我反对！也许在我们的文化里，只认为生命是好的，却没有把快乐啦、幸福啦、生存状态之类的事定义在内；所以就想当然的认为，&lt;strong&gt;只要大家都能活着就好，不管他们活得多么糟糕&lt;/strong&gt;。&lt;/p&gt;
</description>
<pubDate>Tue, 02 Apr 2019 06:08:00 +0000</pubDate>
<dc:creator>沉默王二</dc:creator>
<og:description>划重点： 996 是指每天早上 9 点上班，晚上 9 点下班，每周上 6 天班 至于剩下的那天能不能休息，全靠天意 没有家，即使有，也只是个补充睡眠的窝 01、 最近，我 这个程序员所在的圈子里发生了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qing-gee/p/10642292.html</dc:identifier>
</item>
<item>
<title>我可能不懂Array.prototype.sort - nobody-junior</title>
<link>http://www.cnblogs.com/imgss/p/sort.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/imgss/p/sort.html</guid>
<description>&lt;p&gt;今天 fix 我们后台系统的一些 bug。系统是基于 beego 和模板开发的，各种前后端代码揉作一团，没有格式，没有 eslint，全局变量满天飞，连 js 代码都有后端的插值，读起来非常 &lt;strong&gt;酸爽&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我耐着性子看了半天，陆陆续续改了几个 bug，顺便整理一下代码，总算完成的差不多了。只剩下最后一个小问题，乐观估计可以十分钟内搞定。想到这里，我不禁激动地哼起了小曲儿，马上要从酸爽的代码中抽身了。然而，十分钟过去了，半个小时过去了。。&lt;/p&gt;
&lt;p&gt;&lt;img width=&quot;30%&quot; src=&quot;https://ws2.sinaimg.cn/bmiddle/9150e4e5ly1ful5zsspt4j205i05iwed.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这事还真没那么简单，事情要从我自以为‘熟悉’的 &lt;code&gt;Array.prototype.sort&lt;/code&gt; 这个方法说起。&lt;/p&gt;
&lt;p&gt;根据 MDN 的文档，这个方法接收一个可选的 compareFunction。而这个 compareFunction 接收两个数组元素，并返回一个值决定这两个元素是否需要调换位置，规则如下：&lt;/p&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;如果 compareFunction(a, b) 小于 0 ，那么 a 会被排列到 b 之前；&lt;br/&gt;如果 compareFunction(a, b) 等于 0 ， a 和 b 的相对位置不变。备注： ECMAScript 标准并不保证这一行为，而且也不是所有浏览器都会遵守（例如 Mozilla 在 2003 年之前的版本）；&lt;br/&gt;如果 compareFunction(a, b) 大于 0 ， b 会被排列到 a 之前。&lt;br/&gt;compareFunction(a, b) 必须总是对相同的输入返回相同的比较结果，否则排序的结果将是不确定的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;知道这个规则之后，我们就可以愉快的对数组按自己规则来进行排序了，普通的升序或者降序自然没的说，然而我面对的是这么一个自定义规则：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;有一个数组，由一位数，两位数和 3 位数构成；现在需要排序后的数组按整体从小到大排列，但是两位数的元素要放到最后。举个例子：&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;function compare(a,b){
 // TODO
}

let arr = [1, 8, 3, 11, 100, 15, 201]

arr.sort(compare)

arr //[1, 3, 8, 100, 201, 11, 15]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到了这里，大家可以先尝试写一下这个 compare 函数；如果能成功输出正确的结果，那么这篇文章对你也就没什么用了。在说答案之前，先说一个我之前理解存在的误区：&lt;/p&gt;
&lt;p&gt;compare 函数接收到的两个元素在数组中的位置是不是一定 a 在前面，b 在后面？其实不是。在 compare 函数中打印出 a 和 b 就可以发现这一点。&lt;/p&gt;
&lt;h3 id=&quot;自定义排序&quot;&gt;自定义排序&lt;/h3&gt;
&lt;p&gt;知道 a 和 b 是无序的之后，我们就可以尝试写一下这个比较函数了，传入的元素可以分为以下 3 种情况：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;a,b 都是两位数时，按从小到大排序&lt;/li&gt;
&lt;li&gt;a,b 中有一个两位数，两位数放到后边&lt;/li&gt;
&lt;li&gt;a,b 都不是两位数，按从小到大排序&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;所以，代码如下：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;function isdoubleDigit(num){ return num &amp;gt;= 10 &amp;amp;&amp;amp; num &amp;lt;= 99 }
function compare(a, b){
    // 都是两位数
    if(isdoubleDigit(a) &amp;amp;&amp;amp; isdoubleDigit(b)) {
      return a - b
    }
    
    // a是两位数，b不是，a应该被放到最后
    if(isdoubleDigit(a) &amp;amp;&amp;amp; !isdoubleDigit(b)) {
      return 1
    }
    
    // b是两位数，a不是，b应该被放到最后
    if(!isdoubleDigit(a) &amp;amp;&amp;amp; isdoubleDigit(b)) {
      return -1
    }
    // 都不是两位数，正常排序
    return a - b
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里说一下我原先理解中的第二个误区，那就是以为， compareFunction是用来交换a,b元素在数组中的位置的，像冒泡排序那样。其实这种看法是错误的，看下面的截图可以看出，compareFunction只是在决定排序后的数组中a,b的相对顺序，而不是对a,b的位置直接进行交换。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1016471/201904/1016471-20190402134156109-1048012249.png&quot; alt=&quot;paixu.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如MDN中所说，sort方法是用&lt;a href=&quot;https://en.wikipedia.org/wiki/In-place_algorithm&quot;&gt;原地算法&lt;/a&gt;实现的,有兴趣的朋友可以去研究一下，本文完。&lt;/p&gt;
</description>
<pubDate>Tue, 02 Apr 2019 05:47:00 +0000</pubDate>
<dc:creator>nobody-junior</dc:creator>
<og:description>今天 fix 我们后台系统的一些 bug。系统是基于 beego 和模板开发的，各种前后端代码揉作一团，没有格式，没有 eslint，全局变量满天飞，连 js 代码都有后端的插值，读起来非常 酸爽 。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/imgss/p/sort.html</dc:identifier>
</item>
<item>
<title>OpenLayers学习笔记（十）— 动态加载JSON数据模拟航迹线 - 狐狸家的鱼</title>
<link>http://www.cnblogs.com/suRimn/p/10642108.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/suRimn/p/10642108.html</guid>
<description>&lt;p&gt;需要以JSON数据动态加载绘制飞机轨迹线，飞机图标以加载的坐标为当前实时位置，经过的坐标追加到轨迹线上，标牌始终跟随飞机移动。&lt;/p&gt;&lt;p&gt;因为要加载本地&lt;strong&gt;JSON&lt;/strong&gt;文件，可能会存在跨域问题，所以在本地搭建一个服务器来加载数据，会更加方便。&lt;/p&gt;&lt;div readability=&quot;32&quot;&gt;
&lt;pre&gt;
npm &lt;span&gt;install&lt;/span&gt; http-server -g
&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这是题外话，只是为了打开方便，在右键菜单中加入”在此处打开命令窗口“&lt;/p&gt;&lt;div readability=&quot;35&quot;&gt;
&lt;pre&gt;
Windows Registry Editor Version 5.00&lt;span&gt;

[HKEY_CLASSES_ROOT\Directory\shell\OpenCmdHere]
@&lt;/span&gt;=&quot;在此处打开命令窗口&quot;
&quot;Icon&quot;=&quot;cmd.exe&quot;&lt;span&gt;

[HKEY_CLASSES_ROOT\Directory\shell\OpenCmdHere\command]
@&lt;/span&gt;=&quot;cmd.exe /s /k pushd &quot;%V&quot;&quot;&lt;span&gt;

[HKEY_CLASSES_ROOT\Directory\Background\shell\OpenCmdHere]
@&lt;/span&gt;=&quot;在此处打开命令窗口&quot;
&quot;Icon&quot;=&quot;cmd.exe&quot;&lt;span&gt;

[HKEY_CLASSES_ROOT\Directory\Background\shell\OpenCmdHere\command]
@&lt;/span&gt;=&quot;cmd.exe /s /k pushd \&quot;%V\&quot;&quot;&lt;span&gt;

[HKEY_CLASSES_ROOT\Drive\shell\OpenCmdHere]
@&lt;/span&gt;=&quot;在此处打开命令窗口&quot;
&quot;Icon&quot;=&quot;cmd.exe&quot;&lt;span&gt;

[HKEY_CLASSES_ROOT\Drive\shell\OpenCmdHere\command]
@&lt;/span&gt;=&quot;cmd.exe /s /k pushd \&quot;%V\&quot;&quot;&lt;span&gt;

[HKEY_CLASSES_ROOT\LibraryFolder\background\shell\OpenCmdHere]
@&lt;/span&gt;=&quot;在此处打开命令窗口&quot;
&quot;Icon&quot;=&quot;cmd.exe&quot;&lt;span&gt;

[HKEY_CLASSES_ROOT\LibraryFolder\background\shell\OpenCmdHere\command]
@&lt;/span&gt;=&quot;cmd.exe /s /k pushd \&quot;%V\&quot;&quot;
&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;服务器就启动了，文件夹里的所有数据都可以加载了。在浏览器里输入&lt;strong&gt;http://192.168.1.126:8080&lt;/strong&gt;或者&lt;strong&gt;http://127.0.0.1:8080&lt;/strong&gt;都可以加载。&lt;/p&gt;&lt;div readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * @name: 相关样式和图层：点 航迹线 飞机  标牌
         * @msg: 
         * @param {type} 
         * @return: 
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;样式&lt;/span&gt;
        let route_style = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ol.style.Style({
            stroke:&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ol.style.Stroke({
                width:&lt;/span&gt;2&lt;span&gt;,
                color: &lt;/span&gt;'#007cbf'&lt;span&gt;
            }),
            zIndex:&lt;/span&gt;2&lt;span&gt;
        });
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建轨迹线&lt;/span&gt;
        let trackLine = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ol.geom.LineString([]);   
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;矢量图层层&lt;/span&gt;
        let aircfaftLayer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ol.layer.Vector({
            source:&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ol.source.Vector(),
        })
        let flightTrackLayer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ol.layer.Vector({
            source:&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ol.source.Vector({
                features:[
                    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ol.Feature({
                        geometry:trackLine
                    })
                ]
            }),
            style:route_style,
            updateWhileInteracting: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;拖拽时自动更新位置 顺滑拖拽&lt;/span&gt;
&lt;span&gt;        });
       &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
         * @name: 初始化地图
         * @description: 
         * @param {type} none
         * @return: 
           
        &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
       const center &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ol.proj.fromLonLat([104.06250000000001, 30.65681556429287&lt;span&gt;]);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;地图&lt;/span&gt;
        let map = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ol.Map({
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;图层顺序自下而上&lt;/span&gt;
&lt;span&gt;            layers: [
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ol.layer.Tile({
                    source: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ol.source.OSM({ })
                }),flightTrackLayer,aircfaftLayer,
            ],
            renderer: &lt;/span&gt;'canvas'&lt;span&gt;,
            target: &lt;/span&gt;'map'&lt;span&gt;,
            view: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ol.View({
                center: center,
                zoom: &lt;/span&gt;6&lt;span&gt;
            })
        });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;&lt;div readability=&quot;45&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * @name: 飞机 标牌 航迹
         * @description: 
         * @param {type} none
         * @return: 
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;标牌叠加层&lt;/span&gt;
        let markerEl = document.getElementById('geo-marker'&lt;span&gt;);
        let marker &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ol.Overlay({
            positioning: &lt;/span&gt;'bottom-center'&lt;span&gt;,
            stopEvent: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
            dragging: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
            offset: [&lt;/span&gt;0, 0&lt;span&gt;],
            element: markerEl,
            stopEvent: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
        });
        map.addOverlay(marker);
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;飞机图标样式&lt;/span&gt;
        &lt;span&gt;function&lt;/span&gt;&lt;span&gt; createGoodStyle(aircraftNum) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ol.style.Style({
                image:&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ol.style.Circle({
                    radius:&lt;/span&gt;4&lt;span&gt;,
                    snapToPixel:&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
                    fill:&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ol.style.Fill({
                        color:&lt;/span&gt;'yellow'&lt;span&gt;
                    }),
                    stroke:&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ol.style.Stroke({
                        color:&lt;/span&gt;&quot;#333&quot;&lt;span&gt;,
                        width:&lt;/span&gt;2&lt;span&gt;
                    })
                })
            });
        }&lt;/span&gt;&lt;span&gt;        //&lt;/span&gt;&lt;span&gt;设置地图中心&lt;/span&gt;
        let centerAir = val =&amp;gt;&lt;span&gt; {
            map.getView().setCenter(val);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;&lt;div readability=&quot;44&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * @name: 加载数据
         * @description: 
         * @param {type} none
         * @return: 
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加飞机 + 更新位置&lt;/span&gt;
        let coords, intervalId, interval = 1000, i = 0&lt;span&gt;;
        const url &lt;/span&gt;= './data/flight.json'&lt;span&gt;;
        let theAirplane &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ol.Feature([]);
        $(&lt;/span&gt;'.startAnimate').click(() =&amp;gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加载坐标数据&lt;/span&gt;
&lt;span&gt;            $.ajax({
                url: url,
                dataType: &lt;/span&gt;'json'&lt;span&gt;,
                success: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (response) {
                    console.log(response);
                    coords &lt;/span&gt;=&lt;span&gt; response.coordinates;
                    label &lt;/span&gt;=&lt;span&gt; response.aircraftNum;
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 飞机&lt;/span&gt;
                    let position = ol.proj.fromLonLat(coords[0&lt;span&gt;]);
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;飞机&lt;/span&gt;&lt;span&gt;
                    theAirplane.setId(response.aircraftNum);
                    theAirplane.set(&lt;/span&gt;&quot;speed&quot;&lt;span&gt;, response.speed);
                    theAirplane.setStyle(createGoodStyle(response.aircraftNum));
                    theAirplane.getStyle().getImage().setRotation(response.rotation);
                    aircfaftLayer.getSource().addFeature(theAirplane);
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;航迹线和标牌&lt;/span&gt;
                    intervalId = setInterval(() =&amp;gt;&lt;span&gt; {
                        position &lt;/span&gt;=&lt;span&gt; ol.proj.fromLonLat(coords[i]);
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;标牌&lt;/span&gt;
&lt;span&gt;                        marker.setPosition(position);
                        markerEl.innerHTML &lt;/span&gt;= response.aircraftNum;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;简标牌&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;航迹&lt;/span&gt;
                        let point = &lt;span&gt;new&lt;/span&gt; ol.proj.transform(coords[i], 'EPSG:4326', 'EPSG:3857'&lt;span&gt;);
                        trackLine.appendCoordinate(point);
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;以当前位置为地图中心&lt;/span&gt;
&lt;span&gt;                        centerAir(position);
                        i&lt;/span&gt;++&lt;span&gt;;
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(i ===&lt;span&gt; coords.length) {
                            clearInterval(intervalId);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;停止循环&lt;/span&gt;
&lt;span&gt;                        }
                    }, interval);&lt;/span&gt;&lt;span&gt;
                }
            })
        })&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;&lt;div readability=&quot;238&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{           
            
    &quot;ID&quot;:&quot;1&quot;,
    &quot;aircraftNum&quot;: &quot;B000&quot;,
    &quot;speed&quot;:&quot;25&quot;,
    &quot;rotation&quot;:&quot;114&quot;,
    &quot;coordinates&quot;: [
        [104.06250000000001, 30.65681556429287],
        [104.23659653944907, 30.67396833485058],
        [104.4107544999246, 30.690888911014596],
        [104.58497310591778, 30.70757705503652],
        [104.75925157857333, 30.724032532190993],
        [104.93358913572729, 30.740255110788784],
        [105.10798499194534, 30.75624456218971],
        [105.28243835856125, 30.772000660815337],
        [105.45694844371592, 30.787523184161603],
        [105.63151445239656, 30.80281191281125],
        [105.80613558647657, 30.817866630446186],
        [105.98081104475536, 30.8326871238596],
        [106.15554002299895, 30.847273182967992],
        [106.33032171398055, 30.861624600823],
        [106.50515530752187, 30.875741173623137],
        [106.68003999053437, 30.889622700725297],
        [106.85497494706121, 30.90326898465615],
        [107.02995935831927, 30.916679831123393],
        [107.20499240274177, 30.929855049026738],
        [107.38007325602092, 30.942794450468945],
        [107.55520109115115, 30.95549785076639],
        [107.73037507847249, 30.967965068459744],
        [107.90559438571445, 30.98019592532436],
        [108.08085817803996, 30.992190246380456],
        [108.25616561808987, 31.003947859903253],
        [108.43151586602752, 31.01546859743276],
        [108.60690807958395, 31.026752293783623],
        [108.7823414141029, 31.0377987870545],
        [108.9578150225866, 31.0486079186376],
        [109.13332805574153, 31.059179533227734],
        [109.30887966202457, 31.069513478831404],
        [109.48446898768944, 31.079609606775563],
        [109.66009517683327, 31.089467771716325],
        [109.83575737144373, 31.099087831647413],
        [110.011454711446, 31.108469647908397],
        [110.18718633475038, 31.11761308519283],
        [110.36295137729994, 31.126518011556165],
        [110.53874897311843, 31.135184298423425],
        [110.7145782543585, 31.14361182059676],
        [110.89043835135004, 31.151800456262833],
        [111.06632839264884, 31.1597500869999],
        [111.24224750508553, 31.16746059778481],
        [111.4181948138144, 31.17493187699975],
        [111.5941694423629, 31.182163816438862],
        [111.77017051268102, 31.18915631131456],
        [111.94619714519094, 31.195909260263747],
        [112.1222484588369, 31.202422565353807],
        [112.29832357113521, 31.208696132088367],
        [112.47442159822452, 31.21472986941292],
        [112.65054165491617, 31.220523689720157],
        [112.82668285474469, 31.226077508855244],
        [113.00284431001862, 31.231391246120737],
        [113.17902513187131, 31.236464824281384],
        [113.35522443031194, 31.241298169568736],
        [113.53144131427662, 31.245891211685535],
        [113.70767489167979, 31.250243883809823],
        [113.88392426946552, 31.254356122599024],
        [114.0601885536591, 31.258227868193615],
        [114.23646684941869, 31.26185906422076],
        [114.41275826108706, 31.265249657797618],
        [114.58906189224348, 31.268399599534526],
        [114.76537684575561, 31.271308843537938],
        [114.94170222383167, 31.27397734741316],
        [115.11803712807243, 31.276405072266883],
        [115.2943806595235, 31.27859198270948],
        [115.47073191872758, 31.28053804685718],
        [115.64709000577683, 31.282243236333912],
        [115.82345402036526, 31.28370752627301],
        [115.99982306184107, 31.284930895318737],
        [116.17619622925929, 31.285913325627515],
        [116.35257262143426, 31.28665480286904],
        [116.52895133699217, 31.28715531622708],
        [116.70533147442355, 31.28741485840016],
        [116.8817121321361, 31.28743342560202],
        [117.0580924085071, 31.28721101756178],
        [117.23447140193603, 31.286747637524012],
        [117.41084821089731, 31.286043292248515],
        [117.58722193399282, 31.285097992009906],
        [117.76359167000443, 31.283911750597046],
        [117.93995651794664, 31.282484585312172],
        [118.11631557711907, 31.280816516969885],
        [118.29266794715906, 31.278907569895903],
        [118.46901272809394, 31.276757771925578],
        [118.64534902039362, 31.27436715440231],
        [118.82167592502275, 31.271735752175562],
        [118.99799254349321, 31.268863603598895],
        [119.17429797791613, 31.26575075052759],
        [119.35059133105422, 31.262397238316204],
        [119.52687170637368, 31.258803115815805],
        [119.70313820809623, 31.254968435371172],
        [119.87938994125103, 31.250893252817523],
        [120.05562601172639, 31.2465776274773],
        [120.2318455263214, 31.242021622156606],
        [120.40804759279759, 31.237225303141468],
        [120.58423131993031, 31.232188740193873],
        [120.76039581756008, 31.226912006547636],
        [120.93654019664363, 31.221395178904057],
        [121.11266356930511, 31.215638337427364],
        [121.28876504888679, 31.20964156573994],
        [121.46484375, 31.203404950917395]
    ]
        
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;后续要完成的就是以飞机当前速度和航线预测未来5分钟所在的坐标位置，以及拖拽标注信息叠加层&lt;/p&gt;</description>
<pubDate>Tue, 02 Apr 2019 05:32:00 +0000</pubDate>
<dc:creator>狐狸家的鱼</dc:creator>
<og:description>在openlayers 3 上，加载本地json数据，动态绘制航迹线，以飞机当前位置为地图中心，此例子是模拟DEMO 本文链接：动态加载JSON数据模拟航迹线 作者：狐狸家的鱼 GitHub：八至 前</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/suRimn/p/10642108.html</dc:identifier>
</item>
<item>
<title>微服务架构 - 搭建docker本地镜像仓库并提供权限校验及UI界面 - 架构与我</title>
<link>http://www.cnblogs.com/atcloud/p/10642078.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/atcloud/p/10642078.html</guid>
<description>&lt;p&gt;docker本地镜像仓库的作用跟maven私服差不多，特别是公司级或者是小组级开发好的docker仓库可以上传到本地镜像仓库中，需要用时，直接从本地镜像仓库中拉取镜像即可，因为镜像仓库在自己公司，可以做到安全可控了。下面介绍搭建本地镜像仓库的过程。&lt;/p&gt;
&lt;h2 id=&quot;环境准备&quot;&gt;1、环境准备&lt;/h2&gt;
&lt;p&gt;docker本地镜像仓库本身也是一个docker镜像，为此如果需要搭建本地镜像仓库，则首先要搭建docker的环境，具体搭建docker环境的步骤，大家可以之前的一篇文章：&lt;a href=&quot;https://www.toutiao.com/i6660002521202819596/&quot;&gt;《CentOS7离线部署docker》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;镜像仓库的镜像为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;registry           2.4.1               8ff6a4aae657        2 years ago         172MB&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同时需要为本地镜像仓库提供UI界面，则UI界面的镜像为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;hyper/docker-registry-web   latest       0db5683824d8        2 years ago        599MB&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;配置本地仓库&quot;&gt;2、配置本地仓库&lt;/h2&gt;
&lt;p&gt;（1）、创建目录用于本地仓库所需的，即：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mkdir /opt/docker_reg&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（2）、创建自定义证书的目录，即：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mkdir /opt/docker_reg/certs&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后进入&lt;strong&gt;/opt/docker_reg/certs&lt;/strong&gt;目录，进行如下操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;openssl req \
    -new \
    -newkey rsa:4096 \
    -days 365 \
    -subj &quot;/CN=192.168.208.141&quot; \
    -nodes \
    -x509 \
    -keyout auth.key \
    -out auth.cert&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（3）、创建本地仓库的配置文件目录，即：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mkdir /opt/docker_reg/config&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;并在该目录下创建registry.yml配置文件，配置信息为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;version: 0.1

storage:
  filesystem:
    rootdirectory: /registry
  delete:
    enabled: true

http:
  addr: 0.0.0.0:5000

auth:
  token:
    realm: http://192.168.208.141:8080/api/auth
    service: 192.168.208.141:5000
    issuer: test
    rootcertbundle: /etc/docker/registry/auth.cert

log:
  level: info

notifications:
  endpoints:
    - name: listener
      url: http://192.168.208.141:8080/api/notification
      timeout: 500ms
      threshold: 5
      backoff: 1s&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（4）、创建本地仓库所需要的文件目录，即：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mkdir /opt/docker_reg/reg&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;配置ui界面&quot;&gt;3、配置UI界面&lt;/h2&gt;
&lt;p&gt;（1）、创建UI界面所面的配置文件路径，即：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mkdir -p /opt/docker_reg/ui/config&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在该目录下创建配置文件registry-ui.yml，配置内容为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;registry:
   url: http://registry:5000/v2
   name: 192.168.208.141:5000
   readonly: false
   auth:
     enabled: true
     key: /conf/auth.key
     issuer: test&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;registry.name的配置内容要与上面registry.yml配置文件中的auth.token.service的值一样&lt;/li&gt;
&lt;li&gt;registry.auth.issuer的配置内容要与上面registry.yml配置文件中的auth.token.issuer的值一样&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;docker-compose部署容器&quot;&gt;4、docker-compose部署容器&lt;/h2&gt;
&lt;p&gt;利用docker-compose来部署仓库以及UI界面容器，如果没有安装docker-compose的话，请执行如下命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;curl -L &quot;https://github.com/docker/compose/releases/download/1.23.2/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;chmod +x /usr/local/bin/docker-compose&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;如果运行环境不能直接联外网，则可以先下载二进制包，然后手动放置到相应目录，并授权即可。&lt;/p&gt;
&lt;p&gt;在/opt/docker_reg目录下创建docker-compose.yml文件，内容如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;version: '2'
services:
  registry-ui:
    image: hyper/docker-registry-web:latest
    ports:
      - 8080:8080
    volumes:
       - ./ui/config/registry-ui.yml:/conf/config.yml:ro
       - ./certs/auth.key:/conf/auth.key:ro
       - ./ui/db:/data
    networks:
      - registry-net
    depends_on:
       - registry
  registry:
    image: registry:2.4.1
    ports:
      - 5000:5000
    volumes:
      - ./config/registry.yml:/etc/docker/registry/config.yml:ro
      - ./certs/auth.cert:/etc/docker/registry/auth.cert:ro
      - ./reg:/var/lib/registry
    networks:
      - registry-net

networks:
  registry-net:&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;编辑好配置文件后，即可创建容器，即在/opt/docker_reg目录执行：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker-compose up -d&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行成功后，通过浏览器访问&lt;a href=&quot;http://192.168.208.141:8080/&quot;&gt;http://192.168.208.141:8080&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/840503/201904/840503-20190402132444819-335216715.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有一个默认管理员账号，即用户名为admin，密码为admin&lt;/p&gt;
&lt;h2 id=&quot;测试仓库&quot;&gt;5、测试仓库&lt;/h2&gt;
&lt;p&gt;通过UI界面，用admin用户，创建一个具有pull和push权限的用户:&lt;/p&gt;
&lt;p&gt;（1）、admin登录后，点击“Users”，即：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/840503/201904/840503-20190402132435145-302728834.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）、创建jgyw用户，密码为jgyw123，即：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/840503/201904/840503-20190402132427813-1057723652.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（3）、授与jgyw用户write-all、UI_USER角色，write-all角色即是有pull和push权限，UI_USER角色即可以查看UI界面，即：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/840503/201904/840503-20190402132345345-795416669.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;用户创建好后，用jgyw用户将镜像push到仓库中，例如将如下镜像push到仓库中：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;openzipkin/zipkin          2.12.1         cf8d9aacddc0     5 weeks ago         144MB&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（1）、首先利用tag命令，即：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker  tag openzipkin/zipkin:2.12.1 192.168.208.141:5000/jgyw/zipkin:2.12.1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（2）、然后利用jgyw用户登录本地仓库，即：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker login 192.168.208.141:5000&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后输入用户名和密码，即可登录。&lt;/p&gt;
&lt;p&gt;如果在登录本地仓库时报：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Error response from daemon: Get https://192.168.208.141:5000/v1/users/: http: server gave HTTP response to HTTPS client&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;则需要将/usr/lib/systemd/system/docker.service文件中ExecStart值修改为如下形式，即：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ExecStart=/usr/bin/dockerd --insecure-registry 192.168.208.141:5000&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后重启服务，即：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;systemctl daemon-reload
systemctl restart docker&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（3）、push镜像到本地仓库，即：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker push 192.168.208.141:5000/jgyw/zipkin:2.12.1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;成功之后，通过jgyw用户登录UI界面，就可以看到相应的镜像了，即：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/840503/201904/840503-20190402132329633-1366829941.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（4）、测试pull镜像&lt;/p&gt;
&lt;p&gt;首先先将原来的192.168.208.141:5000/jgyw/zipkin:2.12.1删除掉，即：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker rmi -f 192.168.208.141:5000/jgyw/zipkin:2.12.1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后从本地仓库中pull镜像下来，即：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker pull 192.168.208.141:5000/jgyw/zipkin:2.12.1&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;关注我&quot;&gt;关注我&lt;/h2&gt;
&lt;p&gt;以你最方便的方式关注我：&lt;br/&gt;微信公众号：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/840503/201904/840503-20190402132316046-228841715.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 02 Apr 2019 05:25:00 +0000</pubDate>
<dc:creator>架构与我</dc:creator>
<og:description>搭建docker本地镜像仓库并提供权限校验及UI界面 docker本地镜像仓库的作用跟maven私服差不多，特别是公司级或者是小组级开发好的docker仓库可以上传到本地镜像仓库中，需要用时，直接从本</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/atcloud/p/10642078.html</dc:identifier>
</item>
<item>
<title>.NET和PHP程序员如何通过技术快速变现 - 师傅-伞下的雨</title>
<link>http://www.cnblogs.com/shifubug/p/10627349.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shifubug/p/10627349.html</guid>
<description>&lt;p&gt;刚开始写博客不足之处望大家多多指点，少一些质疑多一些帮助，我们就能成为朋友。&lt;/p&gt;

&lt;p&gt;上一篇：《&lt;a href=&quot;https://www.cnblogs.com/shifubug/p/10621972.html&quot; target=&quot;_blank&quot;&gt;.NET程序员我是如何通过一个产品在2年内买车买房&lt;/a&gt;》有很多同为程序员的小伙伴们给我留言，从整体的留言中我能看到有很多迷茫的小伙伴活在上班拿工资的夹缝中，首先能挣到外快固然是好，如没有挣到还是努力把自己的事做好，成功并非都是顺理成章而是偶然，能通过从事技术这份工作抓住机会才是你职场中应该学的，比如：你的每一任老板都是一个商机，他是怎么做的你也可以这样做，为什么不能，应该是执行力不够，上一篇我也讲到过我通过自媒体平台连续每天发文长达2-3个月，其中这个过程就是一个漫长而又头疼的事，首先每天的文章该怎么写就单单这一件事都足以让你放弃100次。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; 本文大纲：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;1.我热衷技术但我更倾向于技术变现&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;strong&gt;2.代码可以copy发现商机的方式也可以copy&lt;/strong&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;3.具体执行细节&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;4.我的第二款产品现在正在这样做，不信你搜搜看&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;1.我热衷技术但我更倾向于技术变现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;要想技术变现就必须广而告之，你做的再好没人知道，卖不出去也是一堆废代码，因为没有价值（钱），这里并非否认技术没价值，而是要让技术变的更有价值，让自己更有动力去学习技术，然后通过技术变现，通过技术在遇到实际情况的时候去解决，让问题去驱动学习，而不是学而不用，最后沦落成为纸上谈兵。&lt;/p&gt;

&lt;p&gt;以下是我在解决投票系统&lt;strong&gt;慢、卡&lt;/strong&gt;上面关于数据库的一些优化，有可能你并没有遇到过该问题，但是我遇到了并且总结成经验告诉你，这就叫经验分享，我把他整理成测试案例使你更能看明白。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一：引擎的选择&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li&gt;为自己创造问题环境并去解决。如需要测试&lt;span&gt;&lt;strong&gt;MySql&lt;/strong&gt;&lt;/span&gt;表大数据量情况下如何优化，首先第一步你会说我这里没有这么多数据如何去优化，我可以告诉你如何快速生成百万千万数据量的最简单方法。&lt;/li&gt;
&lt;li readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; `&lt;span&gt;user&lt;/span&gt;`(phone,`name`,headimg,sex,addtime) &lt;span&gt;select&lt;/span&gt; phone,`name`,headimg,sex,now() &lt;span&gt;from&lt;/span&gt; `&lt;span&gt;user&lt;/span&gt;`
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上sql语句是快速复制插入表数据，意思是从user表中查询数据并插入到user表中（也可以是另外一张表如user2）。如数据表中起始只有1条数据的话，那么执行17次13万多数据、19次52多万数据、20次100多万数据、21次200多万数据、22次400多万数据，每执行一次就在上一次基础上翻倍。以上sql语句是最简单不过的一条语句，不用写（来给自己增加能让你放弃创造问题环境难度的语句）什么循环之类的语句，你只用按鼠标左键执行个10几次即可。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-0.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;substring&lt;/span&gt;(MD5(&lt;span&gt;RAND&lt;/span&gt;()),&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;20&lt;/span&gt;&lt;span&gt;);#随机生成20位字符串
&lt;/span&gt;&lt;span&gt;select&lt;/span&gt; CEIL(&lt;span&gt;RAND&lt;/span&gt;()&lt;span&gt;*&lt;/span&gt;&lt;span&gt;100000000000&lt;/span&gt;);#随机生成最多11位数字
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;以上查询小技巧奉上，可能你会用到&lt;/li&gt;
&lt;li&gt;其中数据库表引擎是：&lt;span&gt;MyISAM&lt;/span&gt; 和 &lt;span&gt;InnoDB&lt;/span&gt; 查询对比，user（MyISAM引擎）和user3（InnoDB引擎）表数据都是400多万，且数据都是一模一样&lt;/li&gt;
&lt;li readability=&quot;9.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&lt;strong&gt;1.使用count(*)方式查询差距对比&lt;/strong&gt;&lt;/span&gt;&lt;p&gt;#引擎是：InnoDB
&lt;/p&gt;&lt;/span&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;count&lt;/span&gt;(&lt;span&gt;*&lt;/span&gt;) &lt;span&gt;from&lt;/span&gt;&lt;span&gt; `user3`;
平均查询时间：&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;.6秒 &lt;span&gt;~&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;.8秒

#引擎是：MyISAM
&lt;/span&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;count&lt;/span&gt;(&lt;span&gt;*&lt;/span&gt;) &lt;span&gt;from&lt;/span&gt; `&lt;span&gt;user&lt;/span&gt;&lt;span&gt;`;
平均查询时间：&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;.000秒 &lt;span&gt;~&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;.001秒
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&lt;strong&gt;2.使用count(*) 和 count(id)方式查询差距对比&lt;/strong&gt;&lt;/span&gt;&lt;p&gt;#引擎是：InnoDB
&lt;/p&gt;&lt;/span&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;COUNT&lt;/span&gt;(&lt;span&gt;*&lt;/span&gt;) &lt;span&gt;from&lt;/span&gt;&lt;span&gt; `user3`;
&lt;/span&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;COUNT&lt;/span&gt;(id) &lt;span&gt;from&lt;/span&gt;&lt;span&gt; `user3`;
#其中count(&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;)的方式要快于count(id)差不多0.1秒 &lt;span&gt;~&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;.5秒


#引擎是：MyISAM
&lt;/span&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;COUNT&lt;/span&gt;(&lt;span&gt;*&lt;/span&gt;) &lt;span&gt;from&lt;/span&gt; `&lt;span&gt;user&lt;/span&gt;&lt;span&gt;`;
&lt;/span&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;COUNT&lt;/span&gt;(id) &lt;span&gt;from&lt;/span&gt; `&lt;span&gt;user&lt;/span&gt;&lt;span&gt;`;
#其中count(&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;)和count(id)差距在0.000秒 &lt;span&gt;~&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;.001秒
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;3.使用like方式查询差距对比&lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;#引擎是：InnoDB
&lt;/span&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; `user3` &lt;span&gt;WHERE&lt;/span&gt; `name` &lt;span&gt;like&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;b981%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
#平均查询时间：&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;.8秒 &lt;span&gt;~&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;.068秒

#引擎是：MyISAM
&lt;/span&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; `&lt;span&gt;user&lt;/span&gt;` &lt;span&gt;WHERE&lt;/span&gt; `name` &lt;span&gt;like&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;b981%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
#平均查询时间：&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;.959秒
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;&lt;span&gt;4.使用带分页方式查询差距对比&lt;/span&gt;&lt;/strong&gt;&lt;p&gt;#引擎是：InnoDB
&lt;/p&gt;&lt;/span&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; `user3` &lt;span&gt;WHERE&lt;/span&gt; `name` &lt;span&gt;like&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;b981%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; limit &lt;span&gt;1&lt;/span&gt;,&lt;span&gt;10&lt;/span&gt;&lt;span&gt;;
#平均查询时间：&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;.5秒

#引擎是：MyISAM
&lt;/span&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; `&lt;span&gt;user&lt;/span&gt;` &lt;span&gt;WHERE&lt;/span&gt; `name` &lt;span&gt;like&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;b981%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; limit &lt;span&gt;1&lt;/span&gt;,&lt;span&gt;10&lt;/span&gt;&lt;span&gt;;
#平均查询时间：&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;.1秒
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;以下是InnoDB和MyISAM引擎的使用场景说明&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;InnoDB存储（默认引擎）：对事务要求高，保存的数据都是重要数据，可以考虑使用InnoDB引擎，比如订单表，账号表&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;MyISAM存储：如表对事务要求不高，同时以查询和添加为主，可以考虑使用MyISAM引擎&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;二：数据表分区&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;知识点说明：投票系统使用的HASH方式进行分区的，使用HASH方式好处：当插入数据时，根据id把数据平均散到各个分区上，由于文件小，效率高，更新操作变得更快。&lt;/p&gt;
&lt;p&gt;其他更多的分区可以查看&lt;a href=&quot;http://tool.oschina.net/uploads/apidocs/mysql-5.1-zh/partitioning.html#partitioning-types&quot; target=&quot;_blank&quot;&gt;http://tool.oschina.net/uploads/apidocs/mysql-5.1-zh/partitioning.html#partitioning-types&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&lt;strong&gt;1.创建带有分区的表，最后一句代码就是创建HASH分区：&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;PARTITION BY HASH (id) PARTITIONS 10
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt; `user4` (
  `id` &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt; AUTO_INCREMENT,
  `phone` &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;PRIMARY&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt;&lt;span&gt; (`id`)
) ENGINE&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;MyISAM AUTO_INCREMENT&lt;span&gt;=&lt;/span&gt;&lt;span&gt;1&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; CHARSET&lt;span&gt;=&lt;/span&gt;&lt;span&gt;utf8
PARTITION &lt;/span&gt;&lt;span&gt;BY&lt;/span&gt; HASH (id) PARTITIONS &lt;span&gt;10&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;重点：&lt;/strong&gt;要使用分区表必须要在创建表的时候就设置好&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;问题：&lt;/strong&gt;但是表最开始没有创建分区该怎么办？第一步：将表结构代码导出，在最后加上分区代码&lt;span&gt;PARTITION BY HASH (id) PARTITIONS 10&lt;/span&gt;，创建一个新临时表。第二步：使用查询并插入的语句进行同步数据到新表，同步完成将临时表表名改成正式表名，将原来表删除或者换一个新名字。当你在插入数据的时候就自动给你进行了分区。分区表建立好之后下面我们就进行查询分析对比。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&lt;strong&gt;将数据同步到分区表（user4）&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; `user4`(phone,`name`,headimg,sex,addtime) &lt;span&gt;select&lt;/span&gt; phone,`name`,headimg,sex,now() &lt;span&gt;from&lt;/span&gt; `&lt;span&gt;user&lt;/span&gt;`&lt;br/&gt;#执行插入时间只有12.526秒，如果未分区插入需要30多秒
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;1.使用count(*)方式查询差距对比，加了HASH分区直接秒杀前两者&lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;br/&gt;#引擎是：InnoDB
&lt;/span&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;count&lt;/span&gt;(&lt;span&gt;*&lt;/span&gt;) &lt;span&gt;from&lt;/span&gt;&lt;span&gt; `user3`;
#平均查询时间：&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;.6秒 &lt;span&gt;~&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;.8秒

#引擎是：MyISAM
&lt;/span&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;count&lt;/span&gt;(&lt;span&gt;*&lt;/span&gt;) &lt;span&gt;from&lt;/span&gt; `&lt;span&gt;user&lt;/span&gt;&lt;span&gt;`;
#平均查询时间：&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;.000秒 &lt;span&gt;~&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;.001秒

#引擎是：MyISAM&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;HASH分区
&lt;/span&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;COUNT&lt;/span&gt;(&lt;span&gt;*&lt;/span&gt;) &lt;span&gt;from&lt;/span&gt;&lt;span&gt; `user4`
#平均查询时间：&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;.000秒
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;2.使用count(*) 和 count(id)方式查询差距对比&lt;/strong&gt;&lt;strong&gt;，加了HASH分区直接秒杀前两者&lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;br/&gt;#引擎是：MyISAM&lt;span&gt;+&lt;/span&gt;&lt;span&gt;HASH分区
&lt;/span&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;COUNT&lt;/span&gt;(&lt;span&gt;*&lt;/span&gt;) &lt;span&gt;from&lt;/span&gt;&lt;span&gt; `user4`;
&lt;/span&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;COUNT&lt;/span&gt;(id) &lt;span&gt;from&lt;/span&gt;&lt;span&gt; `user4`;
#平均查询时间：&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;.000秒
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;3.&lt;/strong&gt;&lt;strong&gt;使用like方式查询差距对比，没有加HASH分区的表要快加了HASH分区表那么一丢丢，你知道为什么吗，留言回复？&lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;br/&gt;#引擎是：MyISAM
&lt;/span&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; `&lt;span&gt;user&lt;/span&gt;` &lt;span&gt;WHERE&lt;/span&gt; `name` &lt;span&gt;like&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;b981%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
#平均查询时间：0.827&lt;/span&gt;&lt;span&gt;秒

#引擎是：MyISAM&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;HASH分区
&lt;/span&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; `user4` &lt;span&gt;WHERE&lt;/span&gt; `name` &lt;span&gt;like&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;b981%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
#平均查询时间：0.976&lt;/span&gt;秒
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 以上两个知识点解决了投票系统很大一部分慢卡的问题，其实也没有什么高大上，还是那一句话：&lt;strong&gt;适合自己的才是最好的&lt;/strong&gt;。当系统更流畅客户用的更顺心你向他要点钱都是分分钟的事。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.代码可以copy发现商机的方式也可以copy&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先你要弄清楚你所做的产品卖点在哪里？如何找到卖点（商机）？&lt;/p&gt;
&lt;p&gt;方式一：我是通过做定制开发，找我开发同一个产品的人多，就代表这个事有价值。&lt;/p&gt;
&lt;p&gt;方式二：你所任职的公司在做什么事，你们公司所做的这款产品就是卖点（这里不说大厂如BAT），把公司这款产品翻版一份min版本调整价格，通过在网上发软文（你完全可以去网上找，上一篇文章也说过怎么找），起码至少2-3个月的软文努力才有效果，如果没有这个毅力那么最开始就不要想着去翻版。&lt;/p&gt;
&lt;p&gt;方式三：例如：微擎的应用商店、猪八戒的排名前几的服务商点进去看他们什么产品卖的好，这些都是商机，挑选一个在你能力范围内的产品进行翻版。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.具体执行细节&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通过以上方式找准商机然后就开始开发产品&lt;/li&gt;
&lt;li&gt;建立产品宣传的官网让你的产品更正式，官网主要用于宣传产品的卖点和介绍产品的使用。&lt;/li&gt;
&lt;li&gt;搜集友商的软文进行修改，主要修改成自己的产品信息，然后每天定时发送&lt;/li&gt;
&lt;li&gt;每天将新闻发布到：官网、搜狐自媒体平台（推荐）、豆瓣、简书、贴吧&lt;/li&gt;
&lt;li&gt;每天在友商软文下进行&lt;strong&gt;软留言&lt;/strong&gt;（带有自己产品的关键字）&lt;/li&gt;
&lt;li&gt;如有客户找上门要有一套说法，每次将客户单独拉入一个群聊，群内最好除了客户之外要有2人（你+售前也可以自己多个号），你想想只有2个人的不叫群聊那叫尬聊&lt;/li&gt;
&lt;li&gt;准备好合同，如入住了平台，平台方则担任担保。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;4.我的第二款产品现在正在这样做，不信你搜搜看&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;你可以试着搜一搜：玩具租赁，就第一页里面的内容（除了头部百度的广告外）你都点进去要么是我的产品宣传官网，要么是友商的软文（底下肯定有我的产品留言）。&lt;/p&gt;
</description>
<pubDate>Tue, 02 Apr 2019 05:19:00 +0000</pubDate>
<dc:creator>师傅-伞下的雨</dc:creator>
<og:description>刚开始写博客不足之处望大家多多指点，少一些质疑多一些帮助，我们就能成为朋友。 上一篇：《.NET程序员我是如何通过一个产品在2年内买车买房》有很多同为程序员的小伙伴们给我留言，从整体的留言中我能看到有</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shifubug/p/10627349.html</dc:identifier>
</item>
<item>
<title>《C#并发编程经典实例》学习笔记—2.6 任务完成时的处理 - repeatedly</title>
<link>http://www.cnblogs.com/AlienXu/p/10641903.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/AlienXu/p/10641903.html</guid>
<description>&lt;h2 id=&quot;问题&quot;&gt;问题&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;正在 await 一批任务，希望在每个任务完成时对它做一些处理。另外，希望在任务一完成就立即进行处理，而不需要等待其他任务。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;问题的重点在于希望任务完成之后立即进行处理，而不去等待其他任务。&lt;br/&gt;这里还沿用文中的例子。&lt;br/&gt;等待几秒钟之后返回等待的秒数，之后立即打印任务等待的秒数。&lt;br/&gt;等待的函数如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;static async Task&amp;lt;int&amp;gt; DelayAndReturnAsync(int val)
{
      await Task.Delay(TimeSpan.FromSeconds(val));
      return val;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以下方法执行之后的打印结果是“2”, “3”, “1”。想得到结果“1”, “2”, “3”应该如何实现。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;static async Task ProcessTasksAsync()
{
    // 创建任务队列。
    Task&amp;lt;int&amp;gt; taskA = DelayAndReturnAsync(2);
    Task&amp;lt;int&amp;gt; taskB = DelayAndReturnAsync(3);
    Task&amp;lt;int&amp;gt; taskC = DelayAndReturnAsync(1);
    var tasks = new[] { taskA, taskB, taskC };
    // 按顺序 await 每个任务。
    foreach (var task in tasks)
    {
        var result = await task;
        Trace.WriteLine(result);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;文中给了两种解决方案。一种是抽出更高级的async方法，一种是借助作者的nuget拓展。作者还推荐了另外两个博客文章。&lt;br/&gt;&lt;a href=&quot;https://devblogs.microsoft.com/pfxteam/processing-tasks-as-they-complete/&quot;&gt;Processing tasks as they complete&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://codeblog.jonskeet.uk/2012/01/16/eduasync-part-19-ordering-by-completion-ahead-of-time/&quot;&gt;ORDERING BY COMPLETION, AHEAD OF TIME&lt;/a&gt;&lt;br/&gt;这两篇文章介绍了更多处理方法。&lt;/p&gt;
&lt;h3 id=&quot;抽象方法并发执行&quot;&gt;抽象方法，并发执行&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;static async Task AwaitAndProcessAsync(Task&amp;lt;int&amp;gt; task)
{
    var result = await task;
    Trace.WriteLine(result);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将执行和处理抽象出来，借助Task.WhenAll和LINQ并发执行。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var processingTasks = (from t in tasks
select AwaitAndProcessAsync(t)).ToArray();
// 等待全部处理过程的完成。
await Task.WhenAll(processingTasks);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var processingTasks = tasks.Select(async t =&amp;gt;
{
var result = await t;
Trace.WriteLine(result);
}).ToArray();
// 等待全部处理过程的完成。
await Task.WhenAll(processingTasks);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;借助nuget拓展nito.asyncex&quot;&gt;借助nuget拓展：Nito.AsyncEx&lt;/h3&gt;
&lt;p&gt;推荐预发布版本：&lt;a href=&quot;https://www.nuget.org/packages/Nito.AsyncEx/5.0.0-pre-06&quot; class=&quot;uri&quot;&gt;https://www.nuget.org/packages/Nito.AsyncEx/5.0.0-pre-06&lt;/a&gt;&lt;br/&gt;需要添加引用&lt;code&gt;using Nito.AsyncEx;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;static async Task UseOrderByCompletionAsync()
{
      // 创建任务队列。
      Task&amp;lt;int&amp;gt; taskA = DelayAndReturnAsync(2);
      Task&amp;lt;int&amp;gt; taskB = DelayAndReturnAsync(3);
      Task&amp;lt;int&amp;gt; taskC = DelayAndReturnAsync(1);
      var tasks = new[] { taskA, taskB, taskC };
      // 等待每一个任务完成。
      foreach (var task in tasks.OrderByCompletion())
      {
           var result = await task;
           Trace.WriteLine(result);
      }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;串行执行&quot;&gt;串行执行&lt;/h3&gt;
&lt;p&gt;使用ConcurrentExclusiveSchedulerPair，使任务串行执行，结果是“2”, “3”, “1”。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var scheduler = new ConcurrentExclusiveSchedulerPair().ExclusiveScheduler;
foreach (var t in tasks)
{
    await t.ContinueWith(completed =&amp;gt;
    {
             switch (completed.Status)
             {
                   case TaskStatus.RanToCompletion:
                   Trace.WriteLine(completed.Result);
                   //Process(completed.Result);
                   break;
                   case TaskStatus.Faulted:
                   //Handle(completed.Exception.InnerException);
                   break;
               }
     }, scheduler);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上篇文章中提到了使用Task.WhenAny处理已完成的任务：&lt;a href=&quot;https://www.cnblogs.com/AlienXu/p/10609253.html#idx_2&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/AlienXu/p/10609253.html#idx_2&lt;/a&gt;&lt;br/&gt;文中的例子从算法层面是不推荐使用的，作者推荐了他自己的拓展&lt;code&gt;Nito.AsyncEx&lt;/code&gt;，源码地址：&lt;a href=&quot;https://github.com/StephenCleary/AsyncEx/blob/master/src/Nito.AsyncEx.Tasks/TaskExtensions.cs&quot; class=&quot;uri&quot;&gt;https://github.com/StephenCleary/AsyncEx/blob/master/src/Nito.AsyncEx.Tasks/TaskExtensions.cs&lt;/a&gt;。&lt;br/&gt;另外两种实现的实现方法差不多，都是借助&lt;code&gt;TaskCompletionSource&amp;lt;T&amp;gt;&lt;/code&gt;和Interlocked.Incrementa处理Task。&lt;br/&gt;这里只列出&lt;a href=&quot;https://codeblog.jonskeet.uk/2012/01/16/eduasync-part-19-ordering-by-completion-ahead-of-time/&quot;&gt;ORDERING BY COMPLETION, AHEAD OF TIME&lt;/a&gt;的解决方案。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt; 
/// 返回一系列任务，这些任务的输入类型相同和返回结果类型一致
/// 返回的任务将以完成顺序返回
/// &amp;lt;/summary&amp;gt; 
private static IEnumerable&amp;lt;Task&amp;lt;T&amp;gt;&amp;gt; OrderByCompletion&amp;lt;T&amp;gt;(IEnumerable&amp;lt;Task&amp;lt;T&amp;gt;&amp;gt; inputTasks) 
{ 
    // 复制输入，以下的处理将不需要考虑是否会对输入有影响
    var inputTaskList = inputTasks.ToList();
    var completionSourceList = new List&amp;lt;TaskCompletionSource&amp;lt;T&amp;gt;&amp;gt;(inputTaskList.Count); 
    for (int i = 0; i &amp;lt; inputTaskList.Count; i++) 
    { 
        completionSourceList.Add(new TaskCompletionSource&amp;lt;T&amp;gt;()); 
    }

    // 索引
    // 索引最好是从0开始，但是 Interlocked.Increment 返回的是递增之后的值，所以这里应该赋值-1
    int prevIndex = -1;

    // 可以不用再循环之外处理Action，这样会让代码更清晰。现在有C#7.0的新特性本地方法可以使用
     /* //本地方法
     void continuation(Task&amp;lt;T&amp;gt; completedTask)
     {
          int index = Interlocked.Increment(ref prevIndex);
          var source = completionSourceList[index];
          PropagateResult(completedTask, source);
     }*/ 
   
    Action&amp;lt;Task&amp;lt;T&amp;gt;&amp;gt; continuation = completedTask =&amp;gt; 
    { 
        int index = Interlocked.Increment(ref prevIndex); 
        var source = completionSourceList[index]; 
        PropagateResult(completedTask, source); 
    };

    foreach (var inputTask in inputTaskList) 
    {  
        inputTask.ContinueWith(continuation, 
                               CancellationToken.None, 
                               TaskContinuationOptions.ExecuteSynchronously, 
                               TaskScheduler.Default); 
    }

    return completionSourceList.Select(source =&amp;gt; source.Task); 
}

/// &amp;lt;summary&amp;gt; 
/// 对 TaskCompletionSource 进行处理
/// &amp;lt;/summary&amp;gt; 
private static void PropagateResult&amp;lt;T&amp;gt;(Task&amp;lt;T&amp;gt; completedTask, 
    TaskCompletionSource&amp;lt;T&amp;gt; completionSource) 
{ 
    switch (completedTask.Status) 
    { 
        case TaskStatus.Canceled: 
            completionSource.TrySetCanceled(); 
            break; 
        case TaskStatus.Faulted: 
            completionSource.TrySetException(completedTask.Exception.InnerExceptions); 
            break; 
        case TaskStatus.RanToCompletion: 
            completionSource.TrySetResult(completedTask.Result); 
            break; 
        default: 
            throw new ArgumentException(&quot;Task was not completed&quot;); 
    } 
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 02 Apr 2019 04:27:00 +0000</pubDate>
<dc:creator>repeatedly</dc:creator>
<og:description>问题 正在 await 一批任务，希望在每个任务完成时对它做一些处理。另外，希望在任务一完成就立即进行处理，而不需要等待其他任务。 问题的重点在于希望任务完成之后立即进行处理，而不去等待其他任务。 这</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/AlienXu/p/10641903.html</dc:identifier>
</item>
<item>
<title>以最简单的方式了解--Github - speanut</title>
<link>http://www.cnblogs.com/speanut/p/10641895.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/speanut/p/10641895.html</guid>
<description>&lt;div id=&quot;output_wrapper_id&quot; class=&quot;output_wrapper&quot; readability=&quot;54.52539155197&quot;&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;　　大概是从寒假的时候开始正式的赚取github，从github上面学习一些开源的文档，我记得我注册github账号到现在已经9个月了，但只有最近的2个月才发现github这个新世界，写这篇文章是为了刚入门且毫无方向的程序员(若是大神，这篇文章可能不适合你)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;h1github&quot;&gt;&lt;span&gt;1.如何赚取github的学习资料&lt;/span&gt;&lt;/h2&gt;
&lt;h2 id=&quot;h2github&quot;&gt;&lt;span&gt;2.了解github的两种工作流&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;h11github&quot;&gt;&lt;span&gt;1-1直接从github赚赚赚&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　如果你将来打算从事软件开发这个行业的话，没有一个github账号，是说不过去的，所以说赶紧注册(若不懂，请自寻搜索)吧！！&lt;br/&gt;首先打开&lt;strong&gt;github&lt;/strong&gt;会发现导航栏有以下内容&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://user-gold-cdn.xitu.io/2019/4/2/169dbddf16061ade?w=1898&amp;amp;h=82&amp;amp;f=png&amp;amp;s=16155&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;左边的搜索栏就不说了（其实你只要会英文都懂或者浏览器一键翻译…）,对于刚入门的同学来说&lt;strong&gt;Explore&lt;/strong&gt;是最有用的(也是本小结的&lt;strong&gt;重点&lt;/strong&gt;)，其他三个简单的叙述一下

&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Pull requsets&lt;/strong&gt;会在下面的&lt;strong&gt;工作流&lt;/strong&gt;有所提及&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Issues&lt;/strong&gt;我自己没有用过[捂脸]，这里稍微解释一下(每个仓库都有一个&lt;strong&gt;Issues&lt;/strong&gt;，是为了给使用者提问或者讨论的地方，因为我自己没有参加过话题，所以&lt;strong&gt;可惜&lt;/strong&gt;…)，&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Markeplace&lt;/strong&gt;我粗略的看了一下，大概是为了方便开发者在&lt;strong&gt;github&lt;/strong&gt;的一些简单的APP(提高生产力)，感兴趣的可以了解了解&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;img title=&quot;&quot; src=&quot;https://user-gold-cdn.xitu.io/2019/4/2/169dbfbd99699a79?w=452&amp;amp;h=500&amp;amp;f=png&amp;amp;s=40311&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;这个在侧边栏，github会根据相关的算法，然后给你推送一些你感兴趣的东西，下面就开始讲述从&lt;strong&gt;Explore&lt;/strong&gt;赚取相关的学习资料,进入&lt;strong&gt;Explore&lt;/strong&gt;界面

&lt;img title=&quot;&quot; src=&quot;https://user-gold-cdn.xitu.io/2019/4/2/169dbffcc44b278e?w=1685&amp;amp;h=422&amp;amp;f=png&amp;amp;s=81068&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;这里也是基于你的兴趣所推送给你的&lt;strong&gt;仓库&lt;/strong&gt;，下面的就不用我说了吧(英语四级过了的都懂)，然后你可以进入&lt;a href=&quot;https://github.com/topics&quot;&gt;话题&lt;/a&gt;界面(你可以拉下面的滚动条到底就可以发现相关的界面)&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://user-gold-cdn.xitu.io/2019/4/2/169dc022ce156353?w=1544&amp;amp;h=828&amp;amp;f=png&amp;amp;s=125631&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;你会发现一个新大陆，里面有很多关于计算机这一个体系的话题(这里的宝藏让你们自己探索吧..)&lt;br/&gt;最后推荐一下按照&lt;strong&gt;点星数量&lt;/strong&gt;来看&lt;strong&gt;仓库&lt;/strong&gt;，但也有一些好的文章星比较少的，这需要你自己去探索，和从各大平台去探索(&lt;strong&gt;好奇心很重要&lt;/strong&gt;)

&lt;img title=&quot;&quot; src=&quot;https://user-gold-cdn.xitu.io/2019/4/2/169dc0745e6dbcd4?w=453&amp;amp;h=471&amp;amp;f=png&amp;amp;s=26609&quot; alt=&quot;&quot;/&gt;&lt;p&gt;想想你们在逛淘宝的时候也不是按照销量来看的吗(可能只有我)[滑稽]，讲到这里我就说完啦，这仅仅是从github自身去发掘，对于入门很久的大神来说可能早就发现了…，所以只对少部分人来讲，最后推荐一个github的&lt;a href=&quot;https://github.com/topics/awesome&quot;&gt;awesome&lt;/a&gt;系列(&lt;strong&gt;让你血赚&lt;/strong&gt;)，虽然里面大多数都是英文版的仓库，但你可以试着从各个平台或在搜索引擎去找一下中文版或者机器翻译(&lt;strong&gt;建议看英文版&lt;/strong&gt;，因为有些单词是有语境含义的)&lt;/p&gt;
&lt;h3 id=&quot;h12github&quot;&gt;&lt;span&gt;1-2从各个平台赚取github&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;其实有很多平台的文章都会附上一个github的链接，我在这里就推荐刚入门的&lt;strong&gt;hacker&lt;/strong&gt;们几个好点的平台&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://juejin.im/timeline&quot;&gt;掘金&lt;/a&gt;(寒假基本都是赚这里的资料)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.zhihu.com/&quot;&gt;知乎&lt;/a&gt;，因为知乎并不专门为&lt;strong&gt;hacker&lt;/strong&gt;的一个平台，但是也有很多优质文章&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://segmentfault.com/&quot;&gt;思否&lt;/a&gt;，我个人觉的像是国内版的&lt;a href=&quot;https://stackoverflow.com/&quot;&gt;Stackoverflow(赚)&lt;/a&gt;，思否里面大神也是很多&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/&quot;&gt;博客园&lt;/a&gt;，学习C#算是国内最好的平台吧(个人认为)，其他的系列也有很多大神&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.jianshu.com/&quot;&gt;简书&lt;/a&gt;，同知乎并不专门为&lt;strong&gt;hacker&lt;/strong&gt;的一个平台，但是也有很多优质文章(但也有一个老鼠屎直接复制粘贴别人的文章还不修改和原作者链接)&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;p&gt;还有&lt;a href=&quot;https://blog.csdn.net/&quot;&gt;CSDN&lt;/a&gt;，但总有一些老鼠屎是干着复制粘贴的活(毫无改动的那种)，为了吸引流量，而发表一些对&lt;strong&gt;hacker&lt;/strong&gt;无用的东西浪费大家的时间，可能是某搜索引擎比较&lt;strong&gt;可惜&lt;/strong&gt;吧。&lt;br/&gt;最后说一下，github真的是一个很好的&lt;strong&gt;hacker&lt;/strong&gt;，你可以在上面，发现一些你想不到的事情，我觉的只要和计算机有关的，大部分都是有的(我所想学的上面都有)&lt;/p&gt;
&lt;h3 id=&quot;h21gitworkflow&quot;&gt;&lt;span&gt;2-1简单了解git-workflow&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;github实际上是代码托管仓库，里面有者各种各样的开源软件，同时也可以在上面进行团队协作开发和一个开源项目大家一起来开发，我本来是想用github一个大佬的文章，然后通过自己以一种简单方式来表达，但是…，还是轮子太好了，我个小菜鸡没必要在浓缩了，而且上面图文并茂…，如有大家对git工作流感兴趣的话可以查看这个&lt;a href=&quot;https://github.com/oldratlee/translations/tree/master/git-workflows-and-tutorials&quot;&gt;链接&lt;/a&gt;，git对与团队协作开发真的太有用了，刚入门的同学可以简单的了解一下，以后在工作中再去具体的使用。&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Tue, 02 Apr 2019 04:22:00 +0000</pubDate>
<dc:creator>speanut</dc:creator>
<og:description>大概是从寒假的时候开始正式的赚取github，从github上面学习一些开源的文档，我记得我注册github账号到现在已经9个月了，但只有最近的2个月才发现github这个新世界，写这篇文章是为了刚入</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/speanut/p/10641895.html</dc:identifier>
</item>
</channel>
</rss>