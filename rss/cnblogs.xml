<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>SLAM+语音机器人DIY系列：（五）树莓派3开发环境搭建——1.安装系统ubuntu_mate_16.04 - 小虎哥哥爱学习</title>
<link>http://www.cnblogs.com/hiram-zhang/p/10409925.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hiram-zhang/p/10409925.html</guid>
<description>&lt;p&gt;&lt;span&gt;通过前面一系列的铺垫，相信大家对整个miiboo机器人的DIY有了一个清晰整体的认识。接下来就正式进入&lt;span&gt;机器人大脑&lt;/span&gt;（嵌入式主板：树莓派3）的开发。本章将从&lt;span&gt;树莓派3&lt;/span&gt;的开发环境搭建入手，为后续ros开发、slam导航及语音交互算法做准备。本章内容：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/hiram-zhang/p/10409925.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;1.安装系统ubuntu_mate_16.04&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/hiram-zhang/p/10410093.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;2.安装ros-kinetic&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/hiram-zhang/p/10410163.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;3.装机后一些实用软件安装和系统设置&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/hiram-zhang/p/10410168.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;4.PC端与robot端ROS网络通信&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/hiram-zhang/p/10410171.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;5.Android手机端与robot端ROS网络通信&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/hiram-zhang/p/10410175.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;6.树莓派USB与tty串口号绑定&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/hiram-zhang/p/10410177.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;7.开机自启动ROS节点&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;安装前先准备好需要用到的材料，在树莓派&lt;/span&gt;3&lt;span&gt;上安装&lt;/span&gt;&lt;span&gt;ubuntu_mate_16.04&lt;/span&gt;&lt;span&gt;需要用到的工具和材料，如图&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190220233159547-932874588.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（图&lt;/span&gt;1&lt;span&gt;）材料准备&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;1.1.&lt;span&gt;格式化&lt;/span&gt;&lt;span&gt;microSD&lt;/span&gt;&lt;span&gt;卡             &lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;在向&lt;/span&gt;microSD&lt;span&gt;卡烧入系统之前，需要先格式化好&lt;/span&gt;&lt;span&gt;microSD&lt;/span&gt;&lt;span&gt;卡。我这里使用&lt;/span&gt;&lt;span&gt;DiskGenius&lt;/span&gt;&lt;span&gt;工具将卡格式化为&lt;/span&gt;&lt;span&gt;FAT32&lt;/span&gt;&lt;span&gt;文件系统。&lt;/span&gt;&lt;span&gt;DiskGenius&lt;/span&gt;&lt;span&gt;下载地址：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.diskgenius.cn/download.php&quot;&gt;&lt;span&gt;http://www.diskgenius.cn/download.php&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;1.2.&lt;span&gt;下载&lt;/span&gt;&lt;span&gt;ubuntu-mate-16.04&lt;/span&gt;&lt;span&gt;系统镜像   &lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;直接前往&lt;/span&gt;ubuntu-mate&lt;span&gt;的官网&lt;/span&gt;&lt;a href=&quot;https://ubuntu-mate.org/download/&quot;&gt;&lt;span&gt;https://ubuntu-mate.org/download/&lt;/span&gt;&lt;/a&gt;&lt;span&gt;。选择如图&lt;/span&gt;2所示的版本进行下载就行了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190220233609974-1037065552.png&quot; alt=&quot;&quot; width=&quot;700&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（图&lt;/span&gt;2&lt;span&gt;）&lt;/span&gt;&lt;span&gt;ubuntu-mate-16.04&lt;/span&gt;&lt;span&gt;下载页面&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt; 1.3.&lt;span&gt;系统烧录               &lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;将下载好的系统镜像文件&lt;/span&gt;ubuntu-mate-16.04.2-desktop-armhf-raspberry-pi.img.xz&lt;span&gt;解压得到&lt;/span&gt;&lt;span&gt;ubuntu-mate-16.04.2-desktop-armhf-raspberry-pi.img&lt;/span&gt;&lt;span&gt;，该文件应存放在英文路径下。然后用&lt;/span&gt;&lt;span&gt;Win32 Disk Imager&lt;/span&gt;&lt;span&gt;工具将&lt;/span&gt;&lt;span&gt;ubuntu-mate-16.04.2-desktop-armhf-raspberry-pi.img&lt;/span&gt;&lt;span&gt;烧录到&lt;/span&gt;&lt;span&gt;microSD&lt;/span&gt;&lt;span&gt;卡，&lt;/span&gt;&lt;span&gt;Win32 Disk Imager&lt;/span&gt;&lt;span&gt;工具下载地址&lt;/span&gt;&lt;a href=&quot;https://win32-disk-imager.en.lo4d.com/download&quot;&gt;&lt;span&gt;https://win32-disk-imager.en.lo4d.com/download&lt;/span&gt;&lt;/a&gt;&lt;span&gt;。烧录过程很简单，打开&lt;/span&gt;Win32 Disk Imager&lt;span&gt;工具，在&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;映像文件&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;栏中填入待烧录的镜像文件路径，在&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;设备&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;栏中填入要烧录的&lt;/span&gt;&lt;span&gt;microSD&lt;/span&gt;&lt;span&gt;卡，最后点击&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;写入&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;等待烧录进度完成就行了，如图&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190220235000853-490161828.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（图&lt;/span&gt;3&lt;span&gt;）系统烧录&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;1.4.&lt;span&gt;上电开机               &lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;给树莓派&lt;/span&gt;3&lt;span&gt;主板连接上&lt;/span&gt;&lt;span&gt;HDMI&lt;/span&gt;&lt;span&gt;显示器、鼠标、键盘，并插入刚刚烧录好系统的&lt;/span&gt;&lt;span&gt;microSD&lt;/span&gt;&lt;span&gt;卡，就可以上电了，如图&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190220235130478-406517630.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（图&lt;/span&gt;4&lt;span&gt;）上电开机&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一次开机，系统需要用户填写一些必要的设置项，首先是系统语言设置，选择默认的语言&lt;/span&gt;English&lt;span&gt;就行了，如图&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190220235217567-1007218196.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（图&lt;/span&gt;5&lt;span&gt;）语言设置&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后是&lt;/span&gt;wifi&lt;span&gt;连接设置，这里选择先不联网，这样系统配置速度会快很多，等后面我们再进行联网，如图&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190221000125981-1807603359.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（图&lt;/span&gt;6&lt;span&gt;）&lt;/span&gt;wifi&lt;span&gt;连接设置&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;然后是时区设置，我们在中国，说以用鼠标点击地图中的中国区域，会自动锁定到&lt;/span&gt;Shanghai&lt;span&gt;时区，如图&lt;/span&gt;7&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190221000238445-1052886919.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（图&lt;/span&gt;7&lt;span&gt;）时区设置&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后是键盘设置，直接默认就行了，如图&lt;/span&gt;8&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190221000328478-1200105413.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（图&lt;/span&gt;8&lt;span&gt;）键盘设置&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后是用户名和密码设置，为了方便记忆，我将用户名和密码都设置成了&lt;/span&gt;ubuntu&lt;span&gt;；&lt;/span&gt;&lt;span&gt;&lt;span&gt;这里需要特别注意，由于我们的系统用于机器人的开发，为了让机器人上电就能自动进入系统，我们需要勾选&lt;/span&gt;[Log in automatically]&lt;/span&gt;&lt;span&gt;&lt;span&gt;选项，也就是让系统开机自动登录&lt;/span&gt;。&lt;/span&gt;&lt;span&gt;如图&lt;/span&gt;9&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190221000703211-1048822157.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（图&lt;/span&gt;9&lt;span&gt;）用户名、密码、开机自动登录设置&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后就进入系统配置过程了，耐心等待配置进度条完成，如图&lt;/span&gt;10&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190221000817537-112015640.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（图&lt;/span&gt;10&lt;span&gt;）系统配置过程&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;耐心等待，所有配置完成后，系统会自动重启一次，重启完成后，就可以看到&lt;/span&gt;ubuntu-mate-16.04&lt;span&gt;系统的真容了，如图&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;&lt;span&gt;。如果我们不想每次开机都看到这个欢迎界面，可以去掉勾选框中的勾，关闭就行了，下次就不会出现了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190221001047679-1677263883.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（图&lt;/span&gt;11&lt;span&gt;）欢迎界面&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最后，就可以见到&lt;/span&gt;ubuntu-mate-16.04&lt;span&gt;系统的真容了，如图&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;2&lt;span&gt;，到这里系统安装就成功了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190221001349209-743182981.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（图&lt;/span&gt;12&lt;span&gt;）&lt;/span&gt;ubuntu-mate-16.04&lt;span&gt;系统桌面&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果大家对博文的相关类容感兴趣，或有什么技术疑问，欢迎加入下面的《SLAM+语音机器人DIY》QQ技术交流群，一起讨论学习^_^&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190221001529491-1305336530.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 20 Feb 2019 16:19:00 +0000</pubDate>
<dc:creator>小虎哥哥爱学习</dc:creator>
<og:description>摘要 通过前面一系列的铺垫，相信大家对整个miiboo机器人的DIY有了一个清晰整体的认识。接下来就正式进入机器人大脑（嵌入式主板：树莓派3）的开发。本章将从树莓派3的开发环境搭建入手，为后续ros开</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hiram-zhang/p/10409925.html</dc:identifier>
</item>
<item>
<title>python之循序渐进学习装饰器 - Conner&amp;sun</title>
<link>http://www.cnblogs.com/ssj0723/p/10408271.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ssj0723/p/10408271.html</guid>
<description>&lt;p&gt;&lt;strong&gt;python装饰器的定义&lt;/strong&gt;：在代码运行期间在不改变原函数定义的基础上，动态给该函数增加功能的方式称之为装饰器（Decorator）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;装饰器的优点和用途：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1. 抽离出大量函数中与函数功能本身无关的的雷同代码并继续重用。&lt;br/&gt;2. 使用装饰器可以将函数“修饰”为完全不同的行为，可以有效的将业务逻辑正交分解，如用于将权限与身份验证从业务中独立出来。&lt;br/&gt;3. 如果一个函数需要一个功能，且这个功能可以被使用在很多函数上，或是函数并不是自己实现，那可以写个装饰器来实现这些功能。&lt;br/&gt;概况来说，装饰器的作用就是为已经存在的对象添加一些额外的功能。&lt;/p&gt;
&lt;p&gt;在学习如何运用装饰器前我们先来学习以下几个知识点：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.变量的作用域：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  在python中，函数会创建一个自己的作用域或称之为命名空间，结合以下示例来展示函数命名空间的作用域。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
示例代码1：&lt;br/&gt;#coding=utf-&lt;span&gt;8&lt;/span&gt;&lt;span&gt;
outerVar &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;this is a global variable&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
def test() :
     innerVar &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;this is a Local variable&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
     print (&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;local variables :&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
     print (locals()) &lt;span&gt;#locals函数返回的是函数test()内部本地作用域中的可用的变量名称的字典（变量名：值）
&lt;/span&gt; 
test()
print (&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;global variables :&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
print (globals())  &lt;span&gt;#globals函数返回的是python程序中的可用的变量名称的字典（变量名：值）&lt;/span&gt;
  
#执行结果：
local variables :
{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;innerVar&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;this is a Local variable&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;global&lt;/span&gt;&lt;span&gt; variables :
{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;__name__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__doc__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: None, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__package__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: None, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;__loader__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &amp;lt;_frozen_importlib_external.SourceFileLoader &lt;span&gt;object&lt;/span&gt; at &lt;span&gt;0x0000015848FE87F0&lt;/span&gt;&amp;gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;__spec__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: None, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__annotations__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: {}, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__builtins__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &amp;lt;module &lt;span&gt;'&lt;/span&gt;&lt;span&gt;builtins&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; (built-&lt;span&gt;in&lt;/span&gt;)&amp;gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;__file__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;test.py&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__cached__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: None,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;outerVar&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;this is a global variable&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, 
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &amp;lt;function test at &lt;span&gt;0x0000015848E11E18&lt;/span&gt;&amp;gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2.变量解析规则：&lt;/strong&gt;&lt;br/&gt;在python的作用域规则里面，创建变量时一定会在当前作用域里创建同样的变量，但访问或修改变量时，会在当前作用域中查找该变量，如果没找到匹配的变量，就会依次向上在闭合作用域中进行查找，所以也可以在函数中直接访问全局变量。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;示例代码2：
#coding&lt;/span&gt;=utf-&lt;span&gt;8&lt;/span&gt;&lt;span&gt;
outerVar &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;this is a global variable&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
def test() :
 innerVar &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;this is a Local variable&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
 print (outerVar) #获取全局变量outerVar值
 print (n)        #获取全局变量n的值
 
n &lt;/span&gt;= &lt;span&gt;33&lt;/span&gt;&lt;span&gt;
test()    

#执行结果：
&lt;/span&gt;&lt;span&gt;this&lt;/span&gt; &lt;span&gt;is&lt;/span&gt; a &lt;span&gt;global&lt;/span&gt;&lt;span&gt; variable
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;3.变量的生存空间：&lt;/strong&gt;&lt;br/&gt;   变量不仅仅是存在于一个个的命名空间中，它们还都有自己的生存周期，全局变量的生存周期是在整个程序执行期间有效，而局部变量的生存周期只在当前作用域中有效，一旦这个作用域不存在了，比如函数执行退出了，变量的生存周期就结束了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;示例代码3：
#coding&lt;/span&gt;=utf-&lt;span&gt;8&lt;/span&gt;&lt;span&gt;
outerVar &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;this is a global variable&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
def test() :
 innerVar &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;this is a Local variable&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
test()
print (innerVar)  &lt;span&gt;#test函数执行结束后，innerVar变量已释放，再访问函数内部变量就会报NameError&lt;/span&gt;

执行结果：
Traceback (most recent call last):
  File &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test.py&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, line &lt;span&gt;56&lt;/span&gt;, &lt;span&gt;in&lt;/span&gt; &amp;lt;module&amp;gt;&lt;span&gt;
    print (innerVar)
NameError: name &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;innerVar&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;is&lt;/span&gt; not defined
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;4.嵌套函数：&lt;/strong&gt;&lt;br/&gt;  定义：嵌套函数就是在函数里面定义函数，而且现有的作用域和变量生存周期依旧不变。&lt;/p&gt;
&lt;p&gt;  说明：在python里，函数就是对象，它也只是一些普通的值而已。也就是说你可以把函数像参数一样传递给其他的函数或者说从函数了里面返回函数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;示例代码4：
#coding&lt;/span&gt;=utf-&lt;span&gt;8&lt;/span&gt;&lt;span&gt;
def outer() :
 name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;python&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
 def inner() : &lt;br/&gt;&lt;span&gt; #获取name变量值时，python解析器默认会先在函数内部查找,查找失败后，继续往上一层函数作用域查找。&lt;/span&gt;
     print(name) &lt;br/&gt;#&lt;span&gt;python解释器会优先在outer的作用域里面查找变量名为inner的变量。把作为函数标识符的变量inner作为返回值返回。&lt;br/&gt;每次函数outer被调用的时候，函数inner都会被重新定义，如果它不被当做变量返回的话，每次执行过后它将不复存在。&lt;/span&gt;
 &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; inner()  &lt;br/&gt;print (outer())

结果：
python
None   &lt;span&gt;#inner函数默认返回值为None&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;嵌套函数返回函数不加()表示返回函数对象，如下示例5所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
示例代码5：&lt;br/&gt;#coding=utf-&lt;span&gt;8&lt;/span&gt;&lt;span&gt;
def outer() :
 name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;python&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
 def inner() :
     print( name)
 &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; inner   #表示返回函数对象
 
print (outer())

执行结果：&lt;br/&gt;&lt;/span&gt;&amp;lt;function outer.&amp;lt;locals&amp;gt;.inner at &lt;span&gt;0x0000027446B6A9D8&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;5.函数作为变量：&lt;/strong&gt;&lt;br/&gt;  python中函数可以作为参数来传递&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;示例代码6：
#coding&lt;/span&gt;=utf-&lt;span&gt;8&lt;/span&gt;&lt;span&gt;          
def add(x, y):         
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; x +&lt;span&gt; y          
def sub(x, y):         
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; x -&lt;span&gt; y          
def apply(func, x, y): 
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; func(x, y) 
     
print (apply(add, &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)) #add函数作为apply函数的参数传递
print (apply(sub, &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)) 

执行结果：
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;
&lt;span&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;6.闭包：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  定义：如果一个函数定义在另一个函数的作用域内，并且引用了外层函数的变量，则该函数称为闭包。&lt;/p&gt;
&lt;p&gt;  一个函数返回的函数对象，这个函数对象执行需要依赖外部函数的变量值，这个时候函数返回的实际内容如下：&lt;br/&gt;    1.函数对象&lt;br/&gt;    2.函数对象执行需要使用的外部变量和变量值。&lt;br/&gt;简而言之：闭包就是返回一个函数和一个函数执行所需要的外部变量。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
示例代码7：&lt;br/&gt;#coding=utf-&lt;span&gt;8&lt;/span&gt;&lt;span&gt;  
def outer():
    name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;python&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    def inner() :
       print (name) &lt;span&gt;#函数使用了外部的name变量
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; inner    &lt;span&gt;#返回函数对象&lt;/span&gt;
   
res &lt;/span&gt;=&lt;span&gt; outer()    &lt;span&gt;#调用outer()方法，返回inner函数对象&lt;/span&gt;       
res()            &lt;span&gt;#inner函数的对象&lt;/span&gt;&lt;/span&gt;&lt;span&gt;+()=&lt;/span&gt;&lt;span&gt;&lt;span&gt;调用函数inner()    &lt;/span&gt; 
print (res.func_closure&lt;span&gt;)# 查看函数包含哪些外部变量&lt;/span&gt; 
#print (res()) &lt;span&gt;#注意使用print打印返回结果为name值+inner函数默认返回值None

&lt;/span&gt;执行结果：
python
(&lt;/span&gt;&amp;lt;cell at &lt;span&gt;0x0000000002706CD8&lt;/span&gt;: str &lt;span&gt;object&lt;/span&gt; at &lt;span&gt;0x0000000002708738&lt;/span&gt;&amp;gt;&lt;span&gt;,) &lt;span&gt;#外部变量是一个str类型 &lt;/span&gt; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上例中的inner()函数就是一个闭包，它本身也是一个函数，而且还可以访问本身之外的变量。&lt;/p&gt;
&lt;p&gt;每次函数outer被调用时，inner函数都会被重新定义，示例代码7每次返回的函数inner结果都一样，因为name没变。如下例所示，我们将函数稍微改动&lt;br/&gt;一下，结果就不一样了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
示例代码8：&lt;br/&gt;#coding=utf-&lt;span&gt;8&lt;/span&gt;&lt;span&gt;
def outer(name) :
 def inner() :
   print (name)
 &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; inner
 
res1 &lt;/span&gt;= outer(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;python&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
res2 &lt;/span&gt;= outer(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;java&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
res1()
res2()

执行结果：
python
java&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;学习了以上6个小知识点，下面开始学习装饰器。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;装饰器的定义：&lt;/strong&gt;&lt;br/&gt;  装饰器其实就是一个闭包，把一个函数当做参数后返回一个替代版函数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 装饰器分类：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 装饰器分为无参数decorator和有参数decorator&lt;br/&gt;无参数decorator：生成一个新的装饰器函数&lt;br/&gt;有参数decorator：装饰函数先处理参数，再生成一个新的装饰器函数，然后对函数进行装饰。&lt;br/&gt;&lt;strong&gt;装饰器的具体定义：&lt;/strong&gt;&lt;br/&gt;1、把要装饰的方法作为输入参数；&lt;br/&gt;2、在函数体内可以进行任意的操作；&lt;br/&gt;3、只要确保最后返回一个可执行的函数即可（可以是原来的输入参数函数，也可以是一个新函数）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;装饰器学习七步法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一步：最简单的函数，准备附加额外功能&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
# -*- coding:utf-&lt;span&gt;8&lt;/span&gt; -*-&lt;br/&gt;#最简单的函数，表示调用了两次函数&lt;span&gt;
def myfunc():
  print &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;myfunc() called.&lt;/span&gt;&lt;span&gt;&quot;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;
myfunc()
myfunc()

执行结果：
myfunc() called.
myfunc() called.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;第二步：使用装饰函数在函数执行前和执行后分别附加额外功能&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
# -*- coding:utf-&lt;span&gt;8&lt;/span&gt; -*-
&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;示例2: 替换函数(装饰) ，&lt;/span&gt;&lt;span&gt;装饰函数的参数是被装饰的函数对象，返回原函数对象。装饰的实质语句: myfunc &lt;/span&gt;= deco(myfunc)&lt;span&gt;'''
&lt;/span&gt;&lt;span&gt;def deco(func):
 print (&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;before myfunc() called.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)  #在func()函数执行前附加功能，打印一句话
 func() #被执行函数
 print (&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;after myfunc() called.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)  #在func()函数执行后附加功能，打印一句话 
 &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; func
 
def myfunc():
 print (&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;myfunc()called.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
 
new_myfunc &lt;/span&gt;=&lt;span&gt; deco(myfunc) #表示调用参数为myfunc函数对象的deco()函数，结果返回func函数对象并赋值给myfunc
new_myfunc() #表示调用myfunc函数
new_myfunc() #表示调用myfunc函数

结果：
before myfunc() called.
myfunc()called.
after myfunc() called.
myfunc()called.
myfunc()called.
解析：
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;.myfunc =&lt;span&gt; deco(myfunc)执行结果： 
 before myfunc() called.
 myfunc()called.
 after myfunc() called.
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;.第一次调用myfunc()执行结果：
  myfunc()called.
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;.第二次调用myfunc()执行结果：
  myfunc()called. 
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 从第2和第3次调用myfunc函数来看，并没有实现每次调用都返回第1次调用的效果，那么我们要实现每次调用都带有附加功能的效果，我们后面会=逐步实现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第三步：使用@符号来装饰函数&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# -*- coding:utf-&lt;span&gt;8 -*-&lt;/span&gt;&lt;br/&gt;&lt;span&gt;'''示例3：使用@符号装饰函数，&lt;span&gt;相当于&quot;myfunc = deco(myfunc)&quot;,但发现新函数只在第一次被调用，且原函数多调用了一次。等价于第二步程序&lt;/span&gt; '''&lt;/span&gt;&lt;br/&gt;def deco(func):
     print (&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;before myfunc() called.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)  
     func() 
     print (&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;after myfunc() called.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)   
     &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; func
     
@deco
def myfunc():
     print (&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;myfunc()called.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
 
myfunc() 
myfunc() 

#执行结果：
before myfunc() called.
myfunc()called.
after myfunc() called.
myfunc()called.
myfunc()called.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第四步：使用内嵌包装函数来确保每次新函数都被调用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
# -*- coding:utf-8 -*-
&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;示例4: 使用内嵌包装函数来确保每次新函数都被调用，&lt;/span&gt;&lt;span&gt;内嵌包装函数的形参和返回值与原函数相同，装饰函数返回内嵌包装函数对象&lt;/span&gt;&lt;span&gt;'''
&lt;/span&gt;&lt;span&gt;def deco(func):
 def _deco():
     print (&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;before myfunc() called.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
     func()
     print (&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;after myfunc() called.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
 # 不需要返回func，实际上应返回原函数的返回值
 &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; _deco
 
@deco
def myfunc():
 print (&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;myfunc() called.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
 &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ok&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
 
myfunc()
myfunc() &lt;br/&gt;执行结果：&lt;br/&gt;&lt;span&gt;before myfunc() called.&lt;br/&gt;myfunc() called.&lt;br/&gt;after myfunc() called.&lt;br/&gt;before myfunc() called.&lt;br/&gt;myfunc() called.&lt;br/&gt;after myfunc() called.&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面是实现了1个函数使用装饰器的例子，下面演示2个函数分别使用装饰器的实例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;# -*- coding:utf-8 -*-&lt;/span&gt;&lt;br/&gt;'''增加打印函数执行时间功能，分别统计两个函数的执行效率 '''&lt;/span&gt;&lt;span&gt;
import time
def deco(func):
 def _deco():
     start_time&lt;/span&gt;=&lt;span&gt;time.time()
     func() 
     end_time&lt;/span&gt;=&lt;span&gt;time.time()
     print(&lt;/span&gt;&lt;span&gt;&quot;执行&lt;/span&gt;&lt;span&gt;总耗时：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,end_time-&lt;span&gt;start_time)
 &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; _deco
 
@deco
def myfunc(): 
 print (&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; myfunc() called.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
 time.sleep(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
 &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;  

@deco
def youyfunc():
 print (&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; youyfunc() called.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
 time.sleep(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;)
 &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
 
myfunc()      
print (&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;*&lt;span&gt;20&lt;/span&gt;&lt;span&gt;)
youyfunc() 

#结果：
#myfunc() called.
#执行总耗时： &lt;/span&gt;&lt;span&gt;1.0080790519714355&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;********************&lt;span&gt;
# youyfunc() called.
#执行总耗时： &lt;/span&gt;&lt;span&gt;2.0119848251342773&lt;/span&gt;&lt;span&gt;

#执行过程解析：&lt;br/&gt;执行myfunc()等价于执行deco(myfunc)()
#首先myfunc函数作为参数传递给了deco()函数，形参func被替换为实参myfunc,deco()函数开始顺序执行_deco()函数，
#先调用了myfunc()函数，开始执行myfunc函数,打印执行总耗时，最后返回_deco()函数对象。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span&gt;说明：使用装饰器的函数之间变量不会互相影响，等于每次调用都会重新生成一个_deco函数。&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;第五步：实现对带参数的函数进行装饰&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&lt;span&gt;# -*- coding:utf-8 -*-&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;'''  &lt;span&gt;内嵌包装函数的形参和返回值与原函数相同，装饰函数返回内嵌包装函数对象&lt;/span&gt; '''&lt;/span&gt;&lt;br/&gt;def deco(func):                                  
  def _deco(a, b):                                
         print (&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;before myfunc() called.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)               
         ret &lt;/span&gt;=&lt;span&gt; func(a, b)                                                                         
         print (&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;after myfunc() called. result: %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; ret)
         &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret                                      
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; _deco  
                                   
@deco                                            
def myfunc(a, b):                                
  print (&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;myfunc(%s,%s) called.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;(a, b))         
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; a +&lt;span&gt; b 
                                     
myfunc(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;)  &lt;span&gt;#使用print (myfunc(1, 2&lt;/span&gt;&lt;span&gt;&lt;span&gt;)) 查看return ret 的结果&lt;/span&gt;                                
myfunc(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;&lt;span&gt;)   

执行结果：
before myfunc() called.
 myfunc(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;&lt;span&gt;) called.
after myfunc() called. result: &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;
before myfunc() called.
 myfunc(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;&lt;span&gt;) called.
after myfunc() called. result: &lt;/span&gt;&lt;span&gt;7&lt;/span&gt;    
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;第六步：对参数数量不确定的函数进行装饰&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
# -*- coding:utf-&lt;span&gt;8&lt;/span&gt; -*-
&lt;span&gt;'''&lt;/span&gt;参数用(*args, **kwargs)，自动适应变参和命名参数&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
def deco(func):
     def _deco(&lt;/span&gt;*args, **&lt;span&gt;kwargs):
         print (&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;before %s called.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; func.__name__)
         ret &lt;/span&gt;= func(*args, **&lt;span&gt;kwargs)
         print (&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; after %s called. result: %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; (func.__name__, ret))
         &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret
     &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; _deco
     
@deco
def myfunc1(a, b):
     print (&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; myfunc(%s,%s) called.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; (a, b))
     &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; a+&lt;span&gt;b
     
@deco
def myfunc2(a, b, c):
     print (&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; myfunc2(%s,%s,%s) called.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; (a, b, c))
     &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; a+b+&lt;span&gt;c
     
myfunc1(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)
myfunc1(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;&lt;span&gt;)
myfunc2(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;&lt;span&gt;)
myfunc2(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;&lt;span&gt;)

#结果
before myfunc1 called.
 myfunc(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;&lt;span&gt;) called.
 after myfunc1 called. result: &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;
before myfunc1 called.
 myfunc(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;&lt;span&gt;) called.
 after myfunc1 called. result: &lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;
before myfunc2 called.
 myfunc2(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;&lt;span&gt;) called.
 after myfunc2 called. result: &lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;
before myfunc2 called.
 myfunc2(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;&lt;span&gt;) called.
 after myfunc2 called. result: &lt;/span&gt;&lt;span&gt;12&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第七步：装饰器带可变参数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
# -*- coding:utf-&lt;span&gt;8&lt;/span&gt; -*-
&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;在装饰器第四步4的基础上，让装饰器带参数&lt;span&gt;，&lt;/span&gt;&lt;/span&gt;&lt;span&gt;和上一示例相比在外层多了一层包装。装饰函数名实际上应更有意义些'''
&lt;/span&gt;def deco(arg): &lt;br/&gt;&lt;span&gt;     def _deco(func):
         def __deco():
             print (&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;before %s called [%s].&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; (func.__name__, arg))
             func()
             print (&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;after %s called [%s].&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; (func.__name__, arg))
         &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; __deco
     &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; _deco
         
@deco(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mymodule1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)  &lt;span&gt;#装饰器参数是一个字符串，本身没有含义
&lt;/span&gt;def myfunc():
 print (&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; myfunc() called.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

@deco(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mymodule2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
def myfunc2():
 print (&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; myfunc2() called.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

myfunc()   &lt;span&gt;#调用过程等价于：deco(&quot;mymodule1&quot;)()()--&amp;gt;_deco()()--&amp;gt;__deco() &lt;/span&gt;  
myfunc2()
&lt;/span&gt;&lt;span&gt;
#解析三组闭包：
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;. deco(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mymodule1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)()()+arg--&amp;gt;&lt;span&gt;返回_deco函数对象
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;. _deco()()+arg+func --&amp;gt;&lt;span&gt;返回__deco函数对象
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;. __deco()+arg+func  --&lt;span&gt;返回函数最终执行结果


执行结果：
before myfunc called [mymodule1].
 myfunc() called.
after myfunc called [mymodule1].
before myfunc2 called [mymodule2].
 myfunc2() called.
after myfunc2 called [mymodule2].&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;装饰器顺序：&lt;/strong&gt;&lt;br/&gt;当同时对一个函数使用多个不同的装饰器进行装饰时，这个时候装饰器的顺序就很重要了。&lt;br/&gt;代码示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@A
@B
@C
def f():
   pass
等价于：
f &lt;/span&gt;= A(B(C(f)))
&lt;/pre&gt;&lt;/div&gt;








&lt;p&gt;&lt;br/&gt; &lt;/p&gt;







</description>
<pubDate>Wed, 20 Feb 2019 15:48:00 +0000</pubDate>
<dc:creator>Conner&amp;sun</dc:creator>
<og:description>python 装饰器学习总结</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ssj0723/p/10408271.html</dc:identifier>
</item>
<item>
<title>Java——接口 - SakuraOne</title>
<link>http://www.cnblogs.com/myworld7/p/10409934.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/myworld7/p/10409934.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;在Java中，&lt;strong&gt;接口和抽象类为我们提供了一种将类的对外接口与实现分离的更加结构化的方法&lt;/strong&gt;。下面将介绍抽象类，它是普通的类与接口之间的一种中庸之道。然后再介绍接口。&lt;/p&gt;
&lt;h2 id=&quot;抽象类和抽象方法&quot;&gt;抽象类和抽象方法&lt;/h2&gt;
&lt;p&gt;当我们仅是希望有&lt;strong&gt;一个基类可以提供统一的接口去控制它导出的所有子类，并且该基类没有被实例化的必要&lt;/strong&gt;时，我们就可以使用&lt;code&gt;抽象类&lt;/code&gt;去创建这个基类。为了使抽象类不被实例化，我们就需要使用某种机制来限制。于是，Java中提供一种叫做&lt;code&gt;抽象方法&lt;/code&gt;的机制（相当于C++中的纯虚函数），这种方法是不完整的：仅有声明而没有方法体。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;abstract void fun();    //抽象方法声明语法&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;抽象类如果包含抽象方法，那么抽象类就是不完整的，试图产生该类的对象的时候，编译器就会抛出错误信息。&lt;/p&gt;
&lt;p&gt;所以，我们就将&lt;strong&gt;包含抽象方法的类叫做抽象类&lt;/strong&gt;。当然，如果一个类包含一个或者多个抽象方法，该类就必须被限定为抽象的。并且使用关键字&lt;code&gt;abstract&lt;/code&gt;来限定。&lt;/p&gt;
&lt;p&gt;需要注意，Java中的抽象类中除了包含抽象方法也可以包含具体的数据和具体的方法，但是为了程序的清晰度，抽象类中方法最好还是全是抽象方法。如果子类继承自某一个抽象类，并且想创建子类的对象，那么抽象类中的所有抽象方法在子类中都要被实现。否则，子类仍旧是一个抽象类，无法被实例化。&lt;/p&gt;
&lt;p&gt;一个抽象类举例：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public abstract Animal{
    private String name;
    public abstract void eat();
    public String toString { return name;}
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;接口&quot;&gt;接口&lt;/h2&gt;
&lt;p&gt;如果说abstract关键字使得可以在类中创建一个或多个没有方法体的方法给类提供了抽象的概念，那么&lt;code&gt;interface&lt;/code&gt;关键字就使得类的抽象更前一步。使用&lt;strong&gt;interface关键字产生的类是一个完全抽象的类，其中的方法没有任何具体实现&lt;/strong&gt;。即，只允许创建者确定类中的方法名、参数列表和返回类型，但是没有任何方法体。&lt;/p&gt;
&lt;p&gt;一个类如果使用了某个接口那么就必须得实现该接口中规定的所有方法，这倒像是“要干什么事，就必须遵守某种协议”一样。&lt;/p&gt;
&lt;p&gt;接口是为支持运行时动态方法解决而设计的。通常，为使一个方法可以在类间调用，两个类都必须出现在编译时间里，以便Java编译器可以检查以确保方法特殊是兼容的。这个需求导致了一个静态的不可扩展的类环境。在一个系统中不可避免会出现这种状况，函数在类层次中越堆越高以致该机制可以为越来越多的子类可用。接口的设计避免了这个问题。它们把方法或方法系列的定义从类层次中分开。&lt;strong&gt;&lt;span&gt;因为接口是在和类不同的层次中，与类层次无关的类实现相同的接口是可行的&lt;/span&gt;&lt;/strong&gt;。这是实现接口的真正原因所在。接口可以使代码之间的耦合性解除，这是它的又一大好处。后面会介绍。&lt;/p&gt;
&lt;h3 id=&quot;接口的定义和实现&quot;&gt;接口的定义和实现&lt;/h3&gt;
&lt;p&gt;接口的创建同类创建一样，只需将class关键字替换为interface关键字，里面的方法只用声明不用实现即可。接口中也可以包含域，但是这些域都是隐式地为static和final的。要让某个类遵循某个接口（或者是一组接口）就需要使用&lt;code&gt;implements&lt;/code&gt;关键字。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;接口的定义&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface USB{
    String name = &quot;USB&quot;;
    public String getName();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;访问权限修饰符可以为public也可以不写。接口中的方法不能设置成private的，让使用该接口的类不能够实现该方法，所以，都是默认地为public。接口中的域使用static和final的所以要初始化。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;接口的实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一旦接口被定义，一个或多个类便可以实现该接口。为实现该接口，在类定义中包括implement子句，然后创建接口定义的方法。&lt;strong&gt;可以使用接口引用指向实现了接口的类对象&lt;/strong&gt;，就类似于使用基类的引用指向子类对象，于是就可以实现多态功能。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Mouse implements USB{
    //实现接口中定义的方法
    public String getName(){ return &quot;Mouse USB&quot;;}
    public static void main(String args[]){
        USB usb = new Mouse();  //使用接口引用指向实现了接口的类对象
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;接口的局部实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果一个类不完全实现一个接口中的方法那么该类就必须使用abstract修饰。&lt;/p&gt;
&lt;h2 id=&quot;完全解耦&quot;&gt;完全解耦&lt;/h2&gt;
&lt;p&gt;只要一个方法操纵的是类而非接口，那么你就只能在这个类或其子类上使用这个方法。即，只能操纵有继承关系的类。如果你将此方法应用于非此继承结构中的类，那么就会出问题。但是，&lt;strong&gt;若这个方法是接口中的，那么该方法便可以应用在实现了该接口的类对象上，不需要考虑类之间是否有继承性&lt;/strong&gt;。这样，就可以写出复用性更好的代码！&lt;/p&gt;
&lt;p&gt;使用《Java编程思想》中的代码说明：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class Processor{
    public String name() {
        return getClass().getSimpleName();
    }
    Object process(Object input) { 
        return input; 
    }
}

class Upcase extends Processor{
    @Override
    String process(Object input) {
        return ((String)input).toUpperCase();
    }
}

class DownCase extends Processor{
    @Override
    String process(Object input) {
        return ((String)input).toLowerCase();
    }
}

public class Apply {    
    //使用基类引用统一控制子类对象
    public static void process(Processor p, Object s) {
        System.out.println(&quot;Using Processor &quot; + p.name());
        System.out.println(p.process(s));
    }
    
    public static void main(String[] args) {
        String s = &quot;This Road Is Long.&quot;;
        process(new Upcase(), s);
        process(new DownCase(), s);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Apply.process()方法使用基类引用去同一控制对象。在本例中，&lt;strong&gt;创建一个能够根据所传参数对象不同而具有不同行为方法，被称为&lt;/strong&gt;&lt;span&gt;&lt;code&gt;策略设计模式&lt;/code&gt;&lt;/span&gt;。这类方法包含所要执行的算法中不变的部分，而“策略”包含变化的部分。策略就是传递进去的参数对象，它包含要执行的代码。这里，Processor对象就是一个策略，在main()中有两种不同类型的策略应用到了String类型的s对象上。&lt;/p&gt;
&lt;p&gt;现在有一组电子滤波器，它们的代码可能适用于Apply.process()方法。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class Waveform{
    private static long counter;
    private final long id = counter++;
    public String toString() { return &quot;Waveform:&quot; + id;} 
}

class Filter{
    public String name() { return getClass().getSimpleName();}  
    public Waveform process(Waveform input) { return input;}
}

class LowPass extends Filter{
    private double cutoff;
    public LowPass(double cutoff) { this.cutoff = cutoff;}
    
    @Override
    public Waveform process(Waveform input) { return input;}
}

class HighPass extends Filter{
    private double cutoff;
    public HighPass(double cutoff) { this.cutoff = cutoff;}
    
    @Override
    public Waveform process(Waveform input) { return input;}
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Filter和Processor具有相同的接口，但是因为Filter不是继承自Processor的，所以不能将Filter应用于Apply.process()方法。Filter不能使用Apply.process()方法的主要原因在于：Apply.process()方法和Processor之间的耦合性过于紧密，导致复用Apply.process()代码时被禁止。&lt;/p&gt;
&lt;p&gt;但是，如果将Processor换成是一个接口，那么这些限制便会松动，也就可以复用Apply.process()方法。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface Processor{
    String name();
    Object process(Object input);
}   &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;复用代码的第一种方式就是客户端程序员遵循接口来编写类。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public abstract class StringProcessor implements Processor{
    @Override
    public String name() {
        return getClass().getSimpleName();
    }
    public abstract String process(Object input);
    
    public static void main(String[] args) {
        String s = &quot;This Road is Long.&quot;;
        Apply.process(new Upcase(), s);
        Apply.process(new Downcase(), s);
    }
}

class Upcase extends StringProcessor{
    @Override
    public String process(Object input) { return ((String)input).toUpperCase(); }
}

class Downcase extends StringProcessor{
    @Override
    public String process(Object input) { return ((String)input).toLowerCase(); }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有时候就会遇见无法修改到类，在这种情况下，就可以使用&lt;span&gt;&lt;code&gt;适配器设计模式&lt;/code&gt;&lt;/span&gt;。适配器中的代码将接受你所拥有的接口，并产生你所需要的接口。比如，修改电子滤波器使其可以使用Apply.process()。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class FilterAdapter implements Processor{
    Filter filter;
    public FilterAdapter(Filter filter) {
        this.filter = filter;
    }
    
    public String name() { return filter.name();}
    public Waveform process(Object input) {
        return filter.process((Waveform)input);
    }
}

public class FilterProcessor {
    public static void main(String[] args) {
        Waveform w = new Waveform();
        
        Apply.process(new FilterAdapter(new LowPass(1.0)), w);
        Apply.process(new FilterAdapter(new HighPass(2.0)), w);
    }
}
/*
output:
Using Processor LowPass
Waveform:0
Using Processor HighPass
Waveform:0
*/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这种使用适配器的方式中，FilterAdapter的构造器接受Filter的所有接口，然后生成需要的Processor接口对象。&lt;br/&gt;&lt;strong&gt;将接口从具体实现中解耦使得接口可以应用于多种不同的具体实现，因此代码也就更具可复用性。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;java中的多重继承&quot;&gt;Java中的多重继承&lt;/h2&gt;
&lt;p&gt;接口是没有任何具体实现的，即没有任何与接口相关的存储。因此，多个接口便可以组合使用。&lt;/p&gt;
&lt;p&gt;使用具体类和多个接口的例子：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;interface CanFight{
    void fight();
}
interface CanSwim{
    void swim();
}
interface CanFly{
    void fly();
}
class ActionCharacter{
    public void fight();    //与CanFight具有相同的方法特征签名
}
class Hero extends ActionCharacter implements CanFight, CanSwim, CanFly{
    public void swim(){}
    public void fly(){}
}
public class Adventure{
    public static void fi(CanFight x){ x.fight(); }
    public static void sw(CanSwim x){ x.swim(); }
    public static void fl(CanFly x){ x.fly();}
    public static void ac(AcionCharacter x){ x.fight();}
    
    public static void main(String args[]){
        Hero h = new Hero();
        fi(h);
        sw(h);
        fl(h);
        ac(h);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;前面说过一个类要使用一个接口就要实现该接口中的全部方法，但是很明显Hero没有显式实现CanFight中的fight()方法。仔细观察可以发现，Hero继承的具体类ActionCharacter中有实现了的fight()方法。这样，Hero也相当于实现了fight()方法。需要注意，继承的具体类要写在前面。&lt;/p&gt;
&lt;h3 id=&quot;使用接口的核心原因&quot;&gt;使用接口的核心原因&lt;/h3&gt;
&lt;p&gt;上面的例子展示了使用接口的核心原因：为了能够向上转型为多个基类型。第二个原因则是与抽象基类相同：防止客户端程序员创建该类的对象，并确保这仅仅是一个接口。&lt;/p&gt;
&lt;h2 id=&quot;使用继承来扩展接口&quot;&gt;使用继承来扩展接口&lt;/h2&gt;
&lt;p&gt;我们可以通过继承一个接口并添加新的方法声明以生成新的接口，或者通过继承多个接口以实现新的接口。这两种方法都是扩展接口的主要方法。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;interface Monster{
    void menace();
}
//继承并添加新的方法以生成新的接口
interface DangerousMonster extends Monster{
    void destroy();
}
//继承多个接口，组合成一个新接口
interface Lethal{
    void kill();
}
interface Vampire extends DangerousMonster, Lethal{
    void drinkBlood();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;组合接口时的名字冲突&quot;&gt;组合接口时的名字冲突&lt;/h3&gt;
&lt;p&gt;在前面多重继承中，遇到CanFight和ActionCharacter都有一个相同的方法void fight()，但是这并没有导致什么问题。但是，如果在组合多个接口时出现两个签名不一样或者返回类型不同的方法时，会不会出现问题呢？&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;interface I1{ void f(); }
interface I2{ int f(int i);}
interface I3{ int f();}
class C { public int f(){ return 1;}}

class C2 implements I1, I2{
    //两个方法重载
    public void f(){}
    public int f(int i){ return i;}
}

class C3 extends C implements I2{
    public int f(int i){ return i;} //重载
}

class C4 extends C implements I3{
    //同CanFight和ActionCharacter一样
}

//以下两种方式不行！！！
//class C5 extends C implements I1{}
//interface I4 extends I1, I3{}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重载仅依靠返回类型时无法区分的。在打算组合不同接口中使用相同的方法名通常会造成代码可读性的混乱，这是需要避免的。&lt;/p&gt;
&lt;h2 id=&quot;接口与工厂&quot;&gt;接口与工厂&lt;/h2&gt;
&lt;p&gt;接口是实现多重继承的途径，而生成遵循某个接口的对象的典型方式就是&lt;span&gt;&lt;code&gt;工厂方法设计模式&lt;/code&gt;&lt;/span&gt;。与直接调用构造器不同，我们在工厂对象上调用的是创建方法，为该工厂对象将直接生成接口的某个实现的对象。理论上，通过这种方式，我们的代码将完全与接口的实现分离，这就使得我们可以透明地将某个实现替换为另一个实现。下面的实例展示了工厂方法的结构：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;interface Service{
    void method1();
    void method2();
}

interface ServiceFactory{
    Service getService();
}

class Implementation1 implements Service{
    Implementation1(){}
    public void method1(){System.out.println(&quot;Implementation1 method1&quot;);}
    public void method2(){System.out.println(&quot;Implementation1 method1&quot;);}
}

class Implementation1Factory implements ServiceFactory{
    public Service getService(){ return new Implementation1(); }
}

class Implementation2 implements Service{
    Implementation2(){}
    public void method1(){System.out.println(&quot;Implementation2 method1&quot;);}
    public void method2(){System.out.println(&quot;Implementation2 method1&quot;);}
}

class Implementation2Factory implements ServiceFactory{
    public Service getService(){ return new Implementation2(); }
}

public class Factories{
    public static void serviceConsumer(ServiceFactory fact){
        Service s = fact.getService();
        s.method1();
        s.method2();
    }
    
    public static void main(String args[]){
        serviceConsumer(new Implementation1Factory());
        serviceConsumer(new Implementation2Factory());
    }
}
/*
output:
Implementation1 method1
Implementation1 method1
Implementation2 method1
Implementation2 method1
*/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用这种模式的一个常见原因便是创建框架。&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;Java中接口的最大意义就在于对外接口与实现分离，一个接口可以有不同的实现，减少了代码中的耦合性。在本篇博文中还提到了三种设计模式：策略模式、适配器模式以及工厂模式，对三种设计模式介绍地比较简单。在看《Java编程思想》时，也是首次学习，会存在不少疏忽之处，望各位看官指出。最后，在Java8中，接口是有新的特性的，可以拥有方法实体，但是要声明为default。对于接口的新特性后面再补充。&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;《Java编程思想》第四版&lt;/p&gt;
</description>
<pubDate>Wed, 20 Feb 2019 15:38:00 +0000</pubDate>
<dc:creator>SakuraOne</dc:creator>
<og:description>前言 在Java中， 接口和抽象类为我们提供了一种将类的对外接口与实现分离的更加结构化的方法 。下面将介绍抽象类，它是普通的类与接口之间的一种中庸之道。然后再介绍接口。 抽象类和抽象方法 当我们仅是希</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/myworld7/p/10409934.html</dc:identifier>
</item>
<item>
<title>解决 Vue 动态生成 el-checkbox 点击无法赋值问题 - 筱月</title>
<link>http://www.cnblogs.com/ainyi/p/10409942.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ainyi/p/10409942.html</guid>
<description>&lt;p&gt;博客地址：&lt;a href=&quot;https://ainyi.com/#/68&quot; class=&quot;uri&quot;&gt;https://ainyi.com/#/68&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近遇到一个问题，在一个页面需要动态渲染页面内的表单，其中包括 checkbox 表单类型，并且使用 Element 组件 UI 时，此时 v-model 绑定的数据也是动态生成的&lt;/p&gt;
&lt;p&gt;例如：&lt;br/&gt;定义的 data 的 form 里面是空对象，需要动态生成里面的 key&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;export default {
  data() {
    return {
      form: {}
    }
  },
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从后端接口得到 checkList，这个就是动态生成的表单数据&lt;/p&gt;
&lt;p&gt;v-for 循环 checkList，得到 key，然后直接 v-model=&quot;form.key&quot; 动态生成 form 里面的 key&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;el-form-item :label=&quot;item1.name+`：`&quot; v-for=&quot;item1 in checkList&quot; :key=&quot;item1.id&quot;&amp;gt;
  &amp;lt;el-checkbox-group v-model=&quot;form[`${item1.code}`]&quot;&amp;gt;
    &amp;lt;el-checkbox
      :label=&quot;item2.id&quot;
      v-for=&quot;item2 in item1.values&quot;
      :key=&quot;item2.id&quot;&amp;gt;
      {{ item2.value }}
    &amp;lt;/el-checkbox&amp;gt;
  &amp;lt;/el-checkbox-group&amp;gt;
&amp;lt;/el-form-item&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;问题来了&quot;&gt;问题来了&lt;/h2&gt;
&lt;p&gt;当页面点击动态生成的 CheckBox 方框，会出现全选的情况，查看 vue 数据，显示如下：&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Krryxa/WORK-LEARNING/master/images/po_1.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;正常的情况 CheckBox 的绑定数据类型是数组形式&lt;/p&gt;
&lt;p&gt;那我在动态生成的时候，就它置为数组格式：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;this.checkList.forEach(item =&amp;gt; {
  let key = item.code
  this.form[key] = []
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但还是没用，会发现点击任何 CheckBox 都无法勾选&lt;/p&gt;
&lt;h2 id=&quot;解决&quot;&gt;解决&lt;/h2&gt;
&lt;p&gt;这是 vue 的深入响应式原理，官方说法和解决方法：&lt;/p&gt;
&lt;p&gt;Vue 不允许在已经创建的实例上动态添加新的根级响应式属性 (root-level reactive property)&lt;br/&gt;然而它可以使用 Vue.set(object, key, value) 方法将响应属性添加到嵌套的对象上&lt;/p&gt;
&lt;p&gt;现在明白了，可以使用 Vue.set 方法解决这个==深入式响应原理==&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;this.checkList.forEach(item =&amp;gt; {
  let key = item.code
  this.$set(this.form, key, [])
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;完美解决~&lt;/p&gt;
&lt;p&gt;博客地址：&lt;a href=&quot;https://ainyi.com/#/68&quot; class=&quot;uri&quot;&gt;https://ainyi.com/#/68&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 20 Feb 2019 15:36:00 +0000</pubDate>
<dc:creator>筱月</dc:creator>
<og:description>博客地址： 'https://ainyi.com/ /68' 最近遇到一个问题，在一个页面需要动态渲染页面内的表单，其中包括 checkbox 表单类型，并且使用 Element 组件 UI 时，此时</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ainyi/p/10409942.html</dc:identifier>
</item>
<item>
<title>Python中最好用的命令行解析工具：argparse - 站在两个世界的边缘</title>
<link>http://www.cnblogs.com/wongbingming/p/10409919.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wongbingming/p/10409919.html</guid>
<description>&lt;p&gt;Python 做为一个脚本语言，可以很方便地写各种工具。当你在服务端要运行一个工具或服务时，输入参数似乎是一种硬需（当然你也可以通过配置文件来实现）。&lt;/p&gt;
&lt;p&gt;如果要以命令行执行，那你需要解析一个命令行参数解析的模块来帮你做这个苦力活。&lt;/p&gt;
&lt;p&gt;Python 本身就提供了三个命令行参数解析模块，我这里罗列一下它们的大致情况供你了解。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;getopt&lt;/code&gt;，只能简单的处理命令行参数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;optparse&lt;/code&gt;，功能强大，易于使用，可以方便地生成标准的、符合Unix/Posix 规范的命令行说明。（Python2.7以后弃用，不会继续发展）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;argparse&lt;/code&gt;，使其更加容易的编写用户友好的命令行接口。它所需的程序进程了参数定义，argparse将更好的解析sys.argv。同时argparse模块还能自动生成帮助及用户输入错误参数时的提示信息。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;很多初学者可能会使用&lt;code&gt;getopt&lt;/code&gt;，上手简单功能也简单。比如说&lt;code&gt;optget&lt;/code&gt;无法解析一个参数多个值的情况，如 &lt;code&gt;--file file1 file2 file3&lt;/code&gt;，而 &lt;code&gt;optparse&lt;/code&gt; 实际上我没有用过，但是考虑到它在Python2.7后已经不再维护，我们通常也不会使用它。&lt;/p&gt;
&lt;p&gt;接下来只剩下 &lt;code&gt;argparse&lt;/code&gt; 这一神器，它几乎能满足我对命令解析器的所有需求。它支持解析一参数多值，可以自动生成help命令和帮助文档，支持子解析器，支持限制参数取值范围等等功能。&lt;/p&gt;
&lt;h3 id=&quot;h0helloworld&quot;&gt;&lt;span&gt;0. HelloWorld&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;不管学习什么东西，首先第一步都应该是掌握它的大体框架。&lt;/p&gt;
&lt;p&gt;而 使用 argparse 前，框架很简单，你只需要记住这三行。&lt;/p&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;code class=&quot;python language-python hljs&quot; readability=&quot;2&quot;&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; argparse&lt;br/&gt;parser = argparse.ArgumentParser(description=&lt;span class=&quot;hljs-string&quot;&gt;&quot;used for test&quot;&lt;/span&gt;)&lt;p&gt;args = parser.parse_args()&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在可以尝试一下&lt;/p&gt;
&lt;pre readability=&quot;5&quot;&gt;
&lt;code class=&quot;python language-python hljs&quot; readability=&quot;4&quot;&gt;[root@localhost ~]&lt;br/&gt;usage: mytest.py [-h]&lt;p&gt;used &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; test&lt;/p&gt;&lt;p&gt;optional arguments:&lt;br/&gt;-h, --help  show this help message &lt;span class=&quot;hljs-keyword&quot;&gt;and&lt;/span&gt; exit&lt;br/&gt;[root@localhost ~]&lt;br/&gt;[root@localhost ~]&lt;br/&gt;[root@localhost ~]&lt;br/&gt;[root@localhost ~]&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;已经可以使用了。&lt;/p&gt;
&lt;h3 id=&quot;h1&quot;&gt;&lt;span&gt;1. 入门配置&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;这里先讲一下，比较常用的参数配置。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;调试：debug&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;版本号：version&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre readability=&quot;10.5&quot;&gt;
&lt;code class=&quot;python language-python hljs&quot; readability=&quot;15&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; argparse&lt;br/&gt;parser = argparse.ArgumentParser()&lt;p&gt;parser.add_argument(&lt;span class=&quot;hljs-string&quot;&gt;'--version'&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;'-v'&lt;/span&gt;, action=&lt;span class=&quot;hljs-string&quot;&gt;'version'&lt;/span&gt;,&lt;br/&gt;version=&lt;span class=&quot;hljs-string&quot;&gt;'%(prog)s version : v 0.01'&lt;/span&gt;, help=&lt;span class=&quot;hljs-string&quot;&gt;'show the version'&lt;/span&gt;)&lt;/p&gt;&lt;p&gt;parser.add_argument(&lt;span class=&quot;hljs-string&quot;&gt;'--debug'&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;'-d'&lt;/span&gt;, action=&lt;span class=&quot;hljs-string&quot;&gt;'store_true'&lt;/span&gt;,&lt;br/&gt;help=&lt;span class=&quot;hljs-string&quot;&gt;'show the version'&lt;/span&gt;,&lt;br/&gt;default=&lt;span class=&quot;hljs-keyword&quot;&gt;False&lt;/span&gt;)&lt;/p&gt;&lt;p&gt;args = parser.parse_args()&lt;br/&gt;print(&lt;span class=&quot;hljs-string&quot;&gt;&quot;=== end ===&quot;&lt;/span&gt;)&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面debug处的配置，需要讲一下的是 &lt;code&gt;action='store_true'&lt;/code&gt; 和 &lt;code&gt;default = False&lt;/code&gt; 的作用和区别&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;store_true&lt;/code&gt;：一旦指定了 -d 或者 --debug ，其值就为 True，store_false则相反&lt;/li&gt;
&lt;li&gt;&lt;code&gt;default=False&lt;/code&gt;：未指定 -d 或者 --debug，其值就默认为False&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当我们执行 &lt;code&gt;python mytest.py -v&lt;/code&gt;，就会打印 version 里的内容。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;python language-python hljs&quot;&gt;[root@localhost ~]&lt;br/&gt;mytest.py version : v &lt;span class=&quot;hljs-number&quot;&gt;0.01&lt;/span&gt;&lt;br/&gt;[root@localhost ~]&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一旦执行时，指定了参数 -v ，执行到 parser.parse_args() 就会退出程序，不会打印最后的 &lt;code&gt;=== end ===&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;h2&quot;&gt;&lt;span&gt;2. 参数种类&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;参数可分为 必选参数（positional arguments） 和 可选参数（optional arguments）。&lt;/p&gt;
&lt;p&gt;在argsparse 里如何实现呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;必选参数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用单词做参数，默认就为必选参数&lt;/p&gt;
&lt;pre readability=&quot;5&quot;&gt;
&lt;code class=&quot;python language-python hljs&quot; readability=&quot;4&quot;&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; argparse&lt;p&gt;parser = argparse.ArgumentParser()&lt;br/&gt;parser.add_argument(&lt;span class=&quot;hljs-string&quot;&gt;&quot;name&quot;&lt;/span&gt;)&lt;/p&gt;&lt;p&gt;args = parser.parse_args()&lt;/p&gt;&lt;p&gt;print(args.name)&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不指定name参数运行一下：&lt;code&gt;python mytest.py&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;python language-python hljs&quot;&gt;[root@localhost ~]&lt;br/&gt;usage: mytest.py [-h] name&lt;br/&gt;mytest.py: error: too few arguments&lt;br/&gt;[root@localhost ~]&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如预期一样，报错了，说缺少参数。那我们指定一下：&lt;code&gt;python mytest.py name wangbm&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;python language-python hljs&quot;&gt;[root@localhost ~]&lt;br/&gt;wangbm&lt;br/&gt;[root@localhost ~]&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;可选参数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有两种方式：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;单下划线 - 来指定的短参数，如&lt;code&gt;-h&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;双下划线 &lt;code&gt;--&lt;/code&gt; 来指定的长参数，如&lt;code&gt;--help&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;pre readability=&quot;7.5&quot;&gt;
&lt;code class=&quot;python language-python hljs&quot; readability=&quot;9&quot;&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; argparse&lt;p&gt;parser = argparse.ArgumentParser()&lt;br/&gt;parser.add_argument(&lt;span class=&quot;hljs-string&quot;&gt;&quot;-v&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;--verbosity&quot;&lt;/span&gt;, help=&lt;span class=&quot;hljs-string&quot;&gt;&quot;increase output verbosity&quot;&lt;/span&gt;)&lt;/p&gt;&lt;p&gt;args = parser.parse_args()&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; args.verbosity:&lt;br/&gt;print(&lt;span class=&quot;hljs-string&quot;&gt;&quot;verbosity turned on&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;:&lt;br/&gt;print(&lt;span class=&quot;hljs-string&quot;&gt;&quot;verbosity turned off&quot;&lt;/span&gt;)&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;试着运行一下 &lt;code&gt;python mytest.py&lt;/code&gt;，不会报错。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;python language-python hljs&quot;&gt;[root@localhost ~]&lt;br/&gt;verbosity turned off&lt;br/&gt;[root@localhost ~]&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h3&quot;&gt;&lt;span&gt;3. 参数类型&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;有的参数，是字符串，有的参数，是数值。&lt;/p&gt;
&lt;p&gt;为了对命令行中的参数进行有效的约束，我们可以事先对参数的类型进行声明。argparse 会对参数进行校验，不通过时，会直接抛出错误。&lt;/p&gt;
&lt;pre readability=&quot;6.5&quot;&gt;
&lt;code class=&quot;python language-python hljs&quot; readability=&quot;7&quot;&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; argparse&lt;p&gt;parser = argparse.ArgumentParser()&lt;br/&gt;parser.add_argument(&lt;span class=&quot;hljs-string&quot;&gt;&quot;name&quot;&lt;/span&gt;)&lt;br/&gt;parser.add_argument(&lt;span class=&quot;hljs-string&quot;&gt;&quot;age&quot;&lt;/span&gt;, type=int)&lt;/p&gt;&lt;p&gt;args = parser.parse_args()&lt;/p&gt;&lt;p&gt;print(args.name)&lt;br/&gt;print(args.age)&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试一下唄。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;python language-python hljs&quot;&gt;[root@localhost ~]&lt;br/&gt;usage: mytest.py [-h] name age&lt;br/&gt;mytest.py: error: argument age: invalid int value: &lt;span class=&quot;hljs-string&quot;&gt;'eighteen'&lt;/span&gt;&lt;br/&gt;[root@localhost ~]&lt;br/&gt;[root@localhost ~]&lt;br/&gt;wangbm&lt;br/&gt;&lt;span class=&quot;hljs-number&quot;&gt;18&lt;/span&gt;&lt;br/&gt;[root@localhost ~]&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你看，写 &lt;code&gt;eighteen&lt;/code&gt; 就不行，提示类型不合法，只有写 &lt;code&gt;18&lt;/code&gt; 才行。&lt;/p&gt;
&lt;h3 id=&quot;h4&quot;&gt;&lt;span&gt;4. 互斥参数&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;有些参数，是互斥的，有你无我。比如，性别。&lt;/p&gt;
&lt;p&gt;在 argparse 中如何实现？&lt;/p&gt;
&lt;pre readability=&quot;7&quot;&gt;
&lt;code class=&quot;python language-python hljs&quot; readability=&quot;8&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; argparse&lt;p&gt;parser = argparse.ArgumentParser()&lt;br/&gt;group = parser.add_mutually_exclusive_group()&lt;br/&gt;group.add_argument(&lt;span class=&quot;hljs-string&quot;&gt;&quot;-m&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;--male&quot;&lt;/span&gt;, action=&lt;span class=&quot;hljs-string&quot;&gt;&quot;store_true&quot;&lt;/span&gt;)&lt;br/&gt;group.add_argument(&lt;span class=&quot;hljs-string&quot;&gt;&quot;-f&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;--female&quot;&lt;/span&gt;, action=&lt;span class=&quot;hljs-string&quot;&gt;&quot;store_true&quot;&lt;/span&gt;)&lt;br/&gt;args = parser.parse_args()&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果同时指定了这两个参数，就会报错。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;python language-python hljs&quot;&gt;[root@localhost ~]&lt;br/&gt;[root@localhost ~]&lt;br/&gt;[root@localhost ~]&lt;br/&gt;usage: mytest.py [-h] [-m | -f]&lt;br/&gt;mytest.py: error: argument -f/--female: &lt;span class=&quot;hljs-keyword&quot;&gt;not&lt;/span&gt; allowed &lt;span class=&quot;hljs-keyword&quot;&gt;with&lt;/span&gt; argument -m/--male&lt;br/&gt;[root@localhost ~]&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h5&quot;&gt;&lt;span&gt;5. 可选值&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;如果是性别，可以像上面那样放在两个参数里然后用互斥组来约束，也可以放在一个参数里，在argparse里限制再在外层做判断。&lt;/p&gt;
&lt;pre readability=&quot;7.5&quot;&gt;
&lt;code class=&quot;python language-python hljs&quot; readability=&quot;9&quot;&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; argparse&lt;p&gt;parser = argparse.ArgumentParser()&lt;br/&gt;parser.add_argument(&lt;span class=&quot;hljs-string&quot;&gt;&quot;-g&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;--gender&quot;&lt;/span&gt;, default=&lt;span class=&quot;hljs-string&quot;&gt;'male'&lt;/span&gt;,&lt;br/&gt;choices=[&lt;span class=&quot;hljs-string&quot;&gt;'male'&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;'female'&lt;/span&gt;])&lt;/p&gt;&lt;p&gt;args = parser.parse_args()&lt;br/&gt;print(args.gender)&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;试着执行一下，发现性别只能是男或女，不能为人妖。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;python language-python hljs&quot;&gt;[root@localhost ~]&lt;br/&gt;male&lt;br/&gt;[root@localhost ~]&lt;br/&gt;female&lt;br/&gt;[root@localhost ~]&lt;br/&gt;[root@localhost ~]&lt;br/&gt;[root@localhost ~]&lt;br/&gt;usage: mytest.py [-h] [-g {male,female}]&lt;br/&gt;mytest.py: error: argument -g/--gender: invalid choice: &lt;span class=&quot;hljs-string&quot;&gt;'other'&lt;/span&gt; (choose &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;'male'&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;'female'&lt;/span&gt;)&lt;br/&gt;[root@localhost ~]&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h6&quot;&gt;&lt;span&gt;6. 指定文件&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;经常会有那种要在脚本中指定配置文件或者其他文件的需求。可以使用下面的配置&lt;/p&gt;
&lt;pre readability=&quot;8&quot;&gt;
&lt;code class=&quot;python language-python hljs&quot; readability=&quot;10&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; argparse&lt;br/&gt;parser = argparse.ArgumentParser()&lt;p&gt;parser.add_argument(&lt;span class=&quot;hljs-string&quot;&gt;'--file'&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;'-f'&lt;/span&gt;, action=&lt;span class=&quot;hljs-string&quot;&gt;'append'&lt;/span&gt;,&lt;br/&gt;dest=&lt;span class=&quot;hljs-string&quot;&gt;'files'&lt;/span&gt;,&lt;br/&gt;help=(&lt;span class=&quot;hljs-string&quot;&gt;'additional yaml configuration files to use'&lt;/span&gt;),&lt;br/&gt;type=argparse.FileType(&lt;span class=&quot;hljs-string&quot;&gt;'rb'&lt;/span&gt;))&lt;/p&gt;&lt;p&gt;args = parser.parse_args()&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;dest=files&lt;/code&gt;，是说将命令行中，&lt;code&gt;--file&lt;/code&gt; 的参数值赋值给变量files，你可以用args.files访问。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;action=append&lt;/code&gt;，由于我们会有指定多个文件的需求，那就指定多次&lt;code&gt;--file&lt;/code&gt; ，argparse会将其放在一个list里。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;type=argparse.FileType('rb')&lt;/code&gt;，既然是指定文件，那么参数应该为路径，并指定打开模式为rb，如果如果要取得文件内容，可以用 &lt;code&gt;args.files[0].read()&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;h7&quot;&gt;&lt;span&gt;7. 子解析器&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;如果你对命令行，有过足够多的接触，就会知道有些情况下会有子解析器。&lt;/p&gt;
&lt;p&gt;这里我以自己工作中，碰到的例子来举个例子。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs sql&quot;&gt;cloud-init &lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中 single 后面是一个子解析器。&lt;/p&gt;
&lt;pre readability=&quot;16&quot;&gt;
&lt;code class=&quot;python language-python hljs&quot; readability=&quot;26&quot;&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main_single&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(name, args)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;print(&lt;span class=&quot;hljs-string&quot;&gt;&quot;name: &quot;&lt;/span&gt;, name)&lt;br/&gt;print(&lt;span class=&quot;hljs-string&quot;&gt;&quot;args: &quot;&lt;/span&gt;, args)&lt;br/&gt;print(&lt;span class=&quot;hljs-string&quot;&gt;&quot;I am main_single&quot;&lt;/span&gt;)&lt;/p&gt;&lt;p&gt;&lt;br/&gt;subparsers = parser.add_subparsers()&lt;/p&gt;&lt;p&gt;parser_single = subparsers.add_parser(&lt;span class=&quot;hljs-string&quot;&gt;'single'&lt;/span&gt;,help=&lt;span class=&quot;hljs-string&quot;&gt;'run a single module'&lt;/span&gt;)&lt;/p&gt;&lt;p&gt;&lt;br/&gt;parser_single.set_defaults(action=(&lt;span class=&quot;hljs-string&quot;&gt;'single'&lt;/span&gt;, main_single))&lt;/p&gt;&lt;p&gt;&lt;br/&gt;parser_single.add_argument(&lt;span class=&quot;hljs-string&quot;&gt;&quot;--name&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;'-n'&lt;/span&gt;, action=&lt;span class=&quot;hljs-string&quot;&gt;&quot;store&quot;&lt;/span&gt;,&lt;br/&gt;help=&lt;span class=&quot;hljs-string&quot;&gt;&quot;module name to run&quot;&lt;/span&gt;,&lt;br/&gt;required=&lt;span class=&quot;hljs-keyword&quot;&gt;True&lt;/span&gt;)&lt;/p&gt;&lt;p&gt;args = parser.parse_args()&lt;/p&gt;&lt;p&gt;(name, functor) = args.action&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; name &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; [&lt;span class=&quot;hljs-string&quot;&gt;&quot;single&quot;&lt;/span&gt;]:&lt;br/&gt;functor(name, args)&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行命令&lt;code&gt;cloud-init single -name mymodule&lt;/code&gt;，输出如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;python language-python hljs&quot;&gt;name:  single&lt;br/&gt;args:  Namespace(action=(&lt;span class=&quot;hljs-string&quot;&gt;'single'&lt;/span&gt;, &amp;lt;function main_single at &lt;span class=&quot;hljs-number&quot;&gt;0x0000000003F161E0&lt;/span&gt;&amp;gt;), debug=&lt;span class=&quot;hljs-keyword&quot;&gt;False&lt;/span&gt;, file=&lt;span class=&quot;hljs-keyword&quot;&gt;None&lt;/span&gt;, name=&lt;span class=&quot;hljs-string&quot;&gt;'mymodule'&lt;/span&gt;)&lt;br/&gt;I am main_single&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/8f640247gy1fyi60fxos4j20u00a8tdz.jpg&quot; alt=&quot;关注公众号，获取最新干货！&quot; title=&quot;关注公众号，获取最新干货！&quot;/&gt;关注公众号，获取最新干货！</description>
<pubDate>Wed, 20 Feb 2019 15:28:00 +0000</pubDate>
<dc:creator>站在两个世界的边缘</dc:creator>
<og:description>Python 做为一个脚本语言，可以很方便地写各种工具。当你在服务端要运行一个工具或服务时，输入参数似乎是一种硬需（当然你也可以通过配置文件来实现）。 如果要以命令行执行，那你需要解析一个命令行参数解</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wongbingming/p/10409919.html</dc:identifier>
</item>
<item>
<title>进程-线程-多线程 - 胖胖滴加菲猫</title>
<link>http://www.cnblogs.com/loverwangshan/p/10409755.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/loverwangshan/p/10409755.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;什么是进程？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当一个程序开始运行时，它就是一个进程，进程包括运行中的程序和程序所使用到的内存和系统资源。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而一个进程又是由多个线程所组成的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;什么是线程？&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;线程是程序中的一个执行流，每个线程都有自己的专有寄存器&lt;/span&gt;(&lt;span&gt;栈指针、程序计数器等&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;，但代码区是共享的，即不同的线程可以执行同样的函数。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;线程和进程的关系？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个进程会包含多个线程：线程是隶属于某个进程，进程销毁，线程则消失&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;什么是多线程？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;多线程是指程序中包含多个执行流，即在一个程序中可以同时运行多个不同的线程来执行不同的任务，也就是说允许单个程序创建多个并行执行的线程来完成各自的任务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;多线程的好处：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以提高&lt;/span&gt;CPU&lt;span&gt;的利用率。在多线程程序中，一个线程必须等待的时候，&lt;/span&gt;&lt;span&gt;CPU&lt;/span&gt;&lt;span&gt;可以运行其它的线程而不是等待，这样就大大提高了程序的效率。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;多线程的不利方面：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;线程也是程序，所以线程需要占用内存，线程越多占用内存也越多；&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;多线程需要协调和管理，所以需要&lt;/span&gt;CPU&lt;span&gt;时间跟踪线程；&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;线程之间对共享资源的访问会相互影响，必须解决竞用共享资源的问题；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;线程太多会导致控制太复杂，最终可能造成很多&lt;/span&gt;Bug&lt;span&gt;；&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;p&quot;&gt;&lt;span&gt;&lt;strong&gt;  &lt;span&gt;何时使用多线程&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;    &lt;span&gt;多线程程序一般被用来在后台执行耗时的任务。主线程保持运行，并且工作线程做它的后台工作。对于&lt;/span&gt;&lt;span&gt;Windows Forms&lt;/span&gt;&lt;span&gt;程序来说，如果主线程试图执行冗长的操作，键盘和鼠标的操作会变的迟钝，程序也会失去响应。由于这个原因，应该在工作线程中运行一个耗时任务时添加一个工作线程，即使在主线程上有一个有好的提示&lt;/span&gt;&lt;span&gt;“&lt;/span&gt;&lt;span&gt;处理中&lt;/span&gt;&lt;span&gt;...”&lt;/span&gt;&lt;span&gt;，以防止工作无法继续。这就避免了程序出现由操作系统提示的&lt;/span&gt;&lt;span&gt;“&lt;/span&gt;&lt;span&gt;没有相应&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;span&gt;，来诱使用户强制结束程序的进程而导致错误。模式对话框还允许实现&lt;/span&gt;&lt;span&gt;“&lt;/span&gt;&lt;span&gt;取消&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;span&gt;功能，允许继续接收事件，而实际的任务已被工作线程完成。&lt;/span&gt;&lt;em&gt;BackgroundWorker&lt;/em&gt;&lt;span&gt;恰好可以辅助完成这一功能。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;   &lt;span&gt;在没有用户界面的程序里，比如说&lt;/span&gt;&lt;span&gt;Windows Service&lt;/span&gt;&lt;span&gt;， 多线程在当一个任务有潜在的耗时，因为它在等待另台电脑的响应（比如一个应用服务器，数据库服务器，或者一个客户端）的实现特别有意义。用工作线程完成任务意味着主线程可以立即做其它的事情。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;   &lt;span&gt;另一个多线程的用途是在方法中完成一个复杂的计算工作。这个方法会在多核的电脑上运行的更快，如果工作量被多个线程分开的话（使用&lt;/span&gt;&lt;span&gt;Environment.ProcessorCount&lt;/span&gt;&lt;span&gt;属性来侦测处理芯片的数量）。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;   &lt;span&gt;一个&lt;/span&gt;&lt;span&gt;C#&lt;/span&gt;&lt;span&gt;程序称为多线程的可以通过&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;种方式：明确地创建和运行多线程，或者使用&lt;/span&gt;&lt;span&gt;.NET framework&lt;/span&gt;&lt;span&gt;的暗中使用了多线程的特性&lt;/span&gt;&lt;span&gt;——&lt;/span&gt;&lt;span&gt;比如&lt;/span&gt;&lt;em&gt;BackgroundWorker&lt;/em&gt;&lt;span&gt;类&lt;/span&gt;, &lt;em&gt;&lt;span&gt;线程池&lt;/span&gt;&lt;/em&gt;&lt;span&gt;，&lt;/span&gt;&lt;em&gt;threading timer&lt;/em&gt;&lt;span&gt;，远程服务器，或&lt;/span&gt;Web Services&lt;span&gt;或&lt;/span&gt;&lt;span&gt;ASP.NET&lt;/span&gt;&lt;span&gt;程序。在后面的情况，人们别无选择，必须使用多线程；一个单线程的&lt;/span&gt;&lt;span&gt;ASP.NET web server&lt;/span&gt;&lt;span&gt;不是太酷，即使有这样的事情；幸运的是，应用服务器中多线程是相当普遍的；唯一值得关心的是提供适当锁机制的静态变量问题。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;&lt;strong&gt;  &lt;span&gt;何时不要使用多线程&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;    &lt;span&gt;多线程也同样会带来缺点，最大的问题是它使程序变的过于复杂，拥有多线程本身并不复杂，复杂是的线程的交互作用，这带来了无论是否交互是否是有意的，都会带来较长的开发周期，以及带来间歇性和非重复性的&lt;/span&gt;&lt;span&gt;bugs&lt;/span&gt;&lt;span&gt;。因此，要么多线程的交互设计简单一些，要么就根本不使用多线程。除非你有强烈的重写和调试欲望。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;当用户频繁地分配和切换线程时，多线程会带来增加资源和&lt;/span&gt;CPU&lt;span&gt;的开销。在某些情况下，太多的&lt;/span&gt;&lt;span&gt;I/O&lt;/span&gt;&lt;span&gt;操作是非常棘手的，当只有一个或两个工作线程要比有众多的线程在相同时间执行任务块的多。稍后我们将实现生产者&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;耗费者 队列，它提供了上述功能。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 20 Feb 2019 14:46:00 +0000</pubDate>
<dc:creator>胖胖滴加菲猫</dc:creator>
<og:description>进程-线程-多线程</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/loverwangshan/p/10409755.html</dc:identifier>
</item>
<item>
<title>一些可以让你装逼的算法技巧总结 - 帅地</title>
<link>http://www.cnblogs.com/kubidemanong/p/10409712.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kubidemanong/p/10409712.html</guid>
<description>&lt;p&gt;今天和大家讲讲，在做算法题时常用的一些技巧。对于平时没用过这些技巧的人，或许你可以考虑试着去看看在实践中能否用的上这些技巧来优化问题的解。&lt;/p&gt;
&lt;h3 id=&quot;巧用数组下标&quot;&gt;1. 巧用数组下标&lt;/h3&gt;
&lt;p&gt;数组的下标是一个隐含的很有用的数组，特别是在统计一些数字，或者判断一些整型数是否出现过的时候。例如，给你一串字母，让你判断这些字母出现的次数时，我们就可以把这些字母作为下标，在遍历的时候，如果字母a遍历到，则arr[a]就可以加1了，即 arr[a]++;&lt;/p&gt;
&lt;p&gt;通过这种巧用下标的方法，我们不需要逐个字母去判断。&lt;/p&gt;
&lt;p&gt;我再举个例子：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;问题：给你n个无序的int整型数组arr，并且这些整数的取值范围都在0-20之间，要你在 O(n) 的时间复杂度中把这 n 个数按照从小到大的顺序打印出来。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于这道题，如果你是先把这 n 个数先排序，再打印，是不可能O(n)的时间打印出来的。但是数值范围在 0-20。我们就可以巧用数组下标了。把对应的数值作为数组下标，如果这个数出现过，则对应的数组加1。&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void f(int arr[]) {

       int[] temp = new int[21];
       for (int i = 0; i &amp;lt; arr.length; i++) {
           temp[arr[i]]++;
       }
       //顺序打印
       for (int i = 0; i &amp;lt; 21; i++) {
           for (int j = 0; j &amp;lt; temp[i]; j++) {
               System.out.println(i);
           }
       }
   }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;利用数组下标的应用还有很多，大家以后在遇到某些题的时候可以考虑是否可以巧用数组下标来优化。&lt;/p&gt;
&lt;h3 id=&quot;巧用取余&quot;&gt;2. 巧用取余&lt;/h3&gt;
&lt;p&gt;有时候我们在遍历数组的时候，会进行越界判断，如果下标差不多要越界了，我们就把它置为0重新遍历。特别是在一些环形的数组中，例如用数组实现的队列。往往会写出这样的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;for (int i = 0; i &amp;lt; N; i++) {
       if (pos &amp;lt; N) {
        //没有越界
        // 使用数组arr[pos]
        else {
          pos = 0;//置为0再使用数组
          //使用arr[pos]
         }
        pos++;
   }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实际上我们可以通过取余的方法来简化代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;for (int i = 0; i &amp;lt; N; i++) {
  //使用数组arr[pos]   (我们假设刚开始的时候pos &amp;lt; N)
  pos = (pos + 1) % N;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;巧用双指针&quot;&gt;3. 巧用双指针&lt;/h3&gt;
&lt;p&gt;对于双指针，在做关于单链表的题是特别有用，比如“判断单链表是否有环”、“如何一次遍历就找到链表中间位置节点”、“单链表中倒数第 k 个节点”等问题。对于这种问题，我们就可以使用双指针了，会方便很多。我顺便说下这三个问题怎么用双指针解决吧。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;例如对于第一个问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们就可以设置一个慢指针和一个快指针来遍历这个链表。慢指针一次移动一个节点，而快指针一次移动两个节点，如果该链表没有环，则快指针会先遍历完这个表，如果有环，则快指针会在第二次遍历时和慢指针相遇。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对于第二个问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一样是设置一个快指针和慢指针。慢的一次移动一个节点，而快的两个。在遍历链表的时候，当快指针遍历完成时，慢指针刚好达到中点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对于第三个问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;设置两个指针，其中一个指针先移动k个节点。之后两个指针以相同速度移动。当那个先移动的指针遍历完成的时候，第二个指针正好处于倒数第k个节点。&lt;/p&gt;
&lt;p&gt;你看，采用双指针方便多了吧。所以以后在处理与链表相关的一些问题的时候，可以考虑双指针哦。&lt;/p&gt;
&lt;h3 id=&quot;巧用移位运算&quot;&gt;4. 巧用移位运算。&lt;/h3&gt;
&lt;p&gt;有时候我们在进行除数或乘数运算的时候，例如n / 2，n / 4, n / 8这些运算的时候，我们就可以用移位的方法来运算了，这样会快很多。&lt;/p&gt;
&lt;p&gt;例如:&lt;/p&gt;
&lt;p&gt;n / 2 等价于 n &amp;gt;&amp;gt; 1&lt;/p&gt;
&lt;p&gt;n / 4 等价于 n &amp;gt;&amp;gt; 2&lt;/p&gt;
&lt;p&gt;n / 8 等价于 n &amp;gt;&amp;gt; 3。&lt;/p&gt;
&lt;p&gt;这样通过移位的运算在执行速度上是会比较快的，也可以显的你很厉害的样子，哈哈。&lt;/p&gt;
&lt;p&gt;还有一些 &amp;amp;(与)、|(或)的运算，也可以加快运算的速度。例如判断一个数是否是奇数，你可能会这样做&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if(n % 2 == 1){
 dosomething();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不过我们用与或运算的话会快很多。例如判断是否是奇数，我们就可以把n和1相与了，如果结果为1，则是奇数，否则就不会。即&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if(n &amp;amp; 1 == 1){
 dosomething();
)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体的一些运算技巧，还得需要你们多在实践中尝试着去使用，这样用久后就会比较熟练了。&lt;/p&gt;
&lt;h3 id=&quot;设置哨兵位&quot;&gt;5. 设置哨兵位&lt;/h3&gt;
&lt;p&gt;在链表的相关问题中，我们经常会设置一个头指针，而且这个头指针是不存任何有效数据的，只是为了操作方便，这个头指针我们就可以称之为哨兵位了。&lt;/p&gt;
&lt;p&gt;例如我们要删除头第一个节点是时候，如果没有设置一个哨兵位，那么在操作上，它会与删除第二个节点的操作有所不同。但是我们设置了哨兵，那么删除第一个节点和删除第二个节点那么在操作上就一样了，不用做额外的判断。当然，插入节点的时候也一样。&lt;/p&gt;
&lt;p&gt;有时候我们在操作数组的时候，也是可以设置一个哨兵的，把arr[0]作为哨兵。例如，要判断两个相邻的元素是否相等时，设置了哨兵就不怕越界等问题了，可以直接arr[i] == arr[i-1]?了。不用怕i = 0时出现越界。&lt;/p&gt;
&lt;p&gt;当然我这只是举一个例子，具体的应用还有很多，例如插入排序，环形链表等。&lt;/p&gt;
&lt;h3 id=&quot;与递归有关的一些优化&quot;&gt;6. 与递归有关的一些优化&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;（1）.对于可以递归的问题考虑状态保存&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当我们使用递归来解决一个问题的时候，容易产生重复去算同一个子问题，这个时候我们要考虑状态保存以防止重复计算。例如我随便举一个之前举过的问题&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;问题：一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个问题用递归很好解决。假设 f(n) 表示n级台阶的总跳数法，则有&lt;/p&gt;
&lt;p&gt;f(n) = f(n-1) + f(n - 2)。&lt;/p&gt;
&lt;p&gt;递归的结束条件是当0 &amp;lt;= n &amp;lt;= 2时, f(n) = n。因此我们可以很容易写出递归的代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
    public int f(int n) {
       if (n &amp;lt;= 2) {
           return n;
       } else {
           return f(n - 1) + f(n - 2);
       }
   }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不过对于可以使用递归解决的问题，我们一定要考虑是否有很多重复计算。显然对于 f(n) = f(n-1) + f(n-2) 的递归，是有很多重复计算的。如&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/20/1690b503f8fe40b2?w=729&amp;amp;h=444&amp;amp;f=png&amp;amp;s=25472&quot;/&gt;&lt;/p&gt;
&lt;p&gt;就有很多重复计算了。这个时候我们要考虑状态保存。例如用hashMap来进行保存，当然用一个数组也是可以的，这个时候就像我们上面说的巧用数组下标了。可以当arr[n] = 0时，表示n还没计算过，当arr[n] != 0时，表示f(n)已经计算过，这时就可以把计算过的值直接返回回去了。因此我们考虑用状态保存的做法代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//数组的大小根据具体情况来，由于int数组元素的的默认值是0
   //因此我们不用初始化
   int[] arr = new int[1000];
   public int f(int n) {
       if (n &amp;lt;= 2) {
           return n;
       } else {
           if (arr[n] != 0) {
               return arr[n];//已经计算过，直接返回
           } else {
               arr[n] = f(n-1) + f(n-2);
               return arr[n];
           }
       }
   }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样，可以极大着提高算法的效率。也有人把这种状态保存称之为备忘录法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(2).考虑自底向上&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于递归的问题，我们一般都是从上往下递归的，直到递归到最底，再一层一层着把值返回。&lt;/p&gt;
&lt;p&gt;不过，有时候当n比较大的时候，例如当 n = 10000时，那么必须要往下递归10000层直到 n &amp;lt;=2 才将结果慢慢返回，如果n太大的话，可能栈空间会不够用。&lt;/p&gt;
&lt;p&gt;对于这种情况，其实我们是可以考虑自底向上的做法的。例如我知道&lt;/p&gt;
&lt;p&gt;f(1) = 1;&lt;/p&gt;
&lt;p&gt;f(2) = 2;&lt;/p&gt;
&lt;p&gt;那么我们就可以推出 f(3) = f(2) + f(1) = 3。从而可以推出f(4),f(5)等直到f(n)。因此，我们可以考虑使用自底向上的方法来做。&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public int f(int n) {
       if(n &amp;lt;= 2)
           return n;

       int f1 = 1;
       int f2 = 2;
       int sum = 0;

       for (int i = 3; i &amp;lt;= n; i++) {
           sum = f1 + f2;
           f1 = f2;
           f2 = sum;
       }
       return sum;
   }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们也把这种自底向上的做法称之为递推。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结一下&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当你在使用递归解决问题的时候，要考虑以下两个问题&lt;/p&gt;
&lt;p&gt;(1). 是否有状态重复计算的，可不可以使用备忘录法来优化。&lt;/p&gt;
&lt;p&gt;(2). 是否可以采取递推的方法来自底向上做，减少一味递归的开销。&lt;/p&gt;
&lt;p&gt;最后推广下我的公众号：&lt;strong&gt;苦逼的码农&lt;/strong&gt;，文章都会首发于我的公众号，期待各路英雄的关注交流。&lt;/p&gt;
</description>
<pubDate>Wed, 20 Feb 2019 14:33:00 +0000</pubDate>
<dc:creator>帅地</dc:creator>
<og:description>今天和大家讲讲，在做算法题时常用的一些技巧。对于平时没用过这些技巧的人，或许你可以考虑试着去看看在实践中能否用的上这些技巧来优化问题的解。 1. 巧用数组下标 数组的下标是一个隐含的很有用的数组，特别</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kubidemanong/p/10409712.html</dc:identifier>
</item>
<item>
<title>由dubbo服务禁用system.gc而引起的思考 - mantu</title>
<link>http://www.cnblogs.com/mantu/p/10409637.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mantu/p/10409637.html</guid>
<description>&lt;p&gt;我一直都有一个疑问，丰巢业务服务的生产环境jvm参数设置是禁止system.gc的，也就是开启设置：-XX:+DisableExplicitGC，但是生产环境却从来没有出现过堆外内存溢出的情况。说明一下，丰巢使用了阿里开源的dubbo，而dubbo底层通信默认情况下使用了3.2.5.Final版本的netty，而我们对于netty的常规认知里，netty一定是使用了堆外内存，并且堆外内存在禁止了system.gc这个函数调用的话，在服务没有主动回收分配的堆外内存的情况下，一定会出现堆外内存的泄露。带着这个问题，刚好前天晚上有些时间，研究了一下3.2.5版本的netty源码，又是在科兴科兴园等馒头妈妈时候，发现了秘密之所在，我只能说，科兴科学园真是我的宝地啊。&lt;/p&gt;

&lt;p&gt;涉及到的netty类：NioWorker、HeapChannelBufferFactory、BigEndianHeapChannelBuffer、SocketReceiveBufferPool&lt;/p&gt;

&lt;p&gt;核心的秘密在SocketReceiveBufferPool中&lt;/p&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SocketReceiveBufferPool {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; POOL_SIZE = 8&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     @SuppressWarnings(&quot;unchecked&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; SoftReference&amp;lt;ByteBuffer&amp;gt;[] pool = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SoftReference[POOL_SIZE];
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    SocketReceiveBufferPool() {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;super&lt;/span&gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;final&lt;/span&gt; ByteBuffer acquire(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; size) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt; SoftReference&amp;lt;ByteBuffer&amp;gt;[] pool = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.pool;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; POOL_SIZE; i ++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             SoftReference&amp;lt;ByteBuffer&amp;gt; ref =&lt;span&gt; pool[i];
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (ref == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                 &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;             ByteBuffer buf =&lt;span&gt; ref.get();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (buf == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                 pool[i] = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                 &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (buf.capacity() &amp;lt;&lt;span&gt; size) {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                 &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt;             pool[i] = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt; &lt;span&gt;            buf.clear();
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; buf;
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt;         ByteBuffer buf =&lt;span&gt; ByteBuffer.allocateDirect(normalizeCapacity(size));
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;        buf.clear();
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; buf;
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; 
&lt;span&gt;41&lt;/span&gt;     &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; release(ByteBuffer buffer) {
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt; SoftReference&amp;lt;ByteBuffer&amp;gt;[] pool = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.pool;
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; POOL_SIZE; i ++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;             SoftReference&amp;lt;ByteBuffer&amp;gt; ref =&lt;span&gt; pool[i];
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (ref == &lt;span&gt;null&lt;/span&gt; || ref.get() == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;                 pool[i] = &lt;span&gt;new&lt;/span&gt; SoftReference&amp;lt;ByteBuffer&amp;gt;&lt;span&gt;(buffer);
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; 
&lt;span&gt;51&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; pool is full - replace one&lt;/span&gt;
&lt;span&gt;52&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; capacity =&lt;span&gt; buffer.capacity();
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i&amp;lt; POOL_SIZE; i ++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;             SoftReference&amp;lt;ByteBuffer&amp;gt; ref =&lt;span&gt; pool[i];
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;             ByteBuffer pooled =&lt;span&gt; ref.get();
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (pooled == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;                 pool[i] = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;                 &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; 
&lt;span&gt;61&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (pooled.capacity() &amp;lt;&lt;span&gt; capacity) {
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;                 pool[i] = &lt;span&gt;new&lt;/span&gt; SoftReference&amp;lt;ByteBuffer&amp;gt;&lt;span&gt;(buffer);
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt; 
&lt;span&gt;68&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; normalizeCapacity(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; capacity) {
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Normalize to multiple of 1024&lt;/span&gt;
&lt;span&gt;70&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; q = capacity &amp;gt;&amp;gt;&amp;gt; 10&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; r = capacity &amp;amp; 1023&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (r != 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt;             q ++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; q &amp;lt;&amp;lt; 10&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;SocketReceiveBufferPool中维护了一个SoftReference&amp;lt;ByteBuffer&amp;gt;类型的数组，关于java的SoftReference，大家可以自行搜索。其实就是在此类中维护了一个directbuffer的内存池，此部分的内存是可以重复利用的。那么问题来了，如果我们把netty用于接收网络信息的directbuffer直接传给dubbo的业务代码，那么这个内存池的作用是什么呢，内存如何被release回内存池？带着这个疑问，继续分析调用了SocketReceiveBufferPool的NioWorker代码。&lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; read(SelectionKey k) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt; SocketChannel ch =&lt;span&gt; (SocketChannel) k.channel();
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt; NioSocketChannel channel =&lt;span&gt; (NioSocketChannel) k.attachment();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt; ReceiveBufferSizePredictor predictor =
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;            channel.getConfig().getReceiveBufferSizePredictor();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; predictedRecvBufSize =&lt;span&gt; predictor.nextReceiveBufferSize();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; ret = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; readBytes = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;boolean&lt;/span&gt; failure = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;         ByteBuffer bb =&lt;span&gt; recvBufferPool.acquire(predictedRecvBufSize);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;15&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;while&lt;/span&gt; ((ret = ch.read(bb)) &amp;gt; 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                 readBytes +=&lt;span&gt; ret;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;bb.hasRemaining()) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             failure = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ClosedChannelException e) {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Can happen, and does not need a user attention.&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable t) {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;            fireExceptionCaught(channel, t);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (readBytes &amp;gt; 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;            bb.flip();
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt;             &lt;span&gt;final&lt;/span&gt; ChannelBufferFactory bufferFactory =
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;                channel.getConfig().getBufferFactory();
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             &lt;span&gt;final&lt;/span&gt; ChannelBuffer buffer =&lt;span&gt; bufferFactory.getBuffer(readBytes);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;             buffer.setBytes(0&lt;span&gt;, bb);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;            buffer.writerIndex(readBytes);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;             //&lt;span&gt;if&lt;/span&gt;(buffer &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; BigEndianHeapChannelBuffer){
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;             //    logger2.info(&quot;buffer instanceof BigEndianHeapChannelBuffer.&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;            //}
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;            recvBufferPool.release(bb);
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; 
&lt;span&gt;42&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Update the predi||\\|||||&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt; &lt;span&gt;            predictor.previousReceiveBufferSize(readBytes);
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; 
&lt;span&gt;45&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Fire the event.&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt; &lt;span&gt;            fireMessageReceived(channel, buffer);
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;            recvBufferPool.release(bb);
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; 
&lt;span&gt;51&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (ret &amp;lt; 0 ||&lt;span&gt; failure) {
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;             k.cancel(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Some JDK implementations run into an infinite loop without this.&lt;/span&gt;
&lt;span&gt;53&lt;/span&gt; &lt;span&gt;            close(channel, succeededFuture(channel));
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; 
&lt;span&gt;57&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;在代码里发现了netty会再创造一个chanelbuffer对象，然后将directbuffer里的内容复制到chanelbuffer里面，而这个chanelbuffer对象实际上是一个堆内内存，然后netty会真对这块内存进行解码及返回给上层调用服务等，也就是说没有直接将directbuffer返回给dubbo服务，这样也就解释了，我们在提供dubbo服务的jvm里，禁止掉了system.gc的情况下，没有发生过堆外内存泄漏的原因。后面我会找时间详细的分析一下netty4和kafka使用directbuffer的情况。&lt;/p&gt;
</description>
<pubDate>Wed, 20 Feb 2019 14:18:00 +0000</pubDate>
<dc:creator>mantu</dc:creator>
<og:description>我一直都有一个疑问，丰巢业务服务的生产环境jvm参数设置是禁止system.gc的，也就是开启设置：-XX:+DisableExplicitGC，但是生产环境却从来没有出现过堆外内存溢出的情况。说明一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mantu/p/10409637.html</dc:identifier>
</item>
<item>
<title>selinux学习 - 番茄汁汁</title>
<link>http://www.cnblogs.com/likaiming/p/10360104.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/likaiming/p/10360104.html</guid>
<description>&lt;h2&gt;1、TE模型的安全上下文&lt;/h2&gt;
&lt;p&gt;所有的操作系统访问控制都基于主体、客体，以及与他们相关的访问控制属性。&lt;/p&gt;
&lt;p&gt;在selinux中，访问控制属性叫做&lt;strong&gt;安全上下文。&lt;/strong&gt;所有对象(文件、进程间通信通道、套接字、网络主机等)和主体(进程)都有一个与之关联的安全上下文。&lt;/p&gt;
&lt;p&gt;一个安全上下文包含三个元素：用户（user）、角色（role）和类型标识符（type identifiers）&lt;/p&gt;
&lt;p&gt;安全上下文的形式如下：user：role：type&lt;/p&gt;
&lt;p&gt;对进程来说：分别表示用户、角色、类型标识符也被称为域&lt;/p&gt;
&lt;p&gt;对客体来说：前两项基本没有实际用途，role通常为object_r，user通常位创建这个对象的进程的user，对访问控制没有影响&lt;/p&gt;
&lt;h3&gt;显示安全上下文&lt;/h3&gt;
&lt;p&gt;加上-Z能显示主体、客体的上下文&lt;/p&gt;
&lt;p&gt;ls -Z能显示文件系统的安全上下文&lt;/p&gt;
&lt;p&gt;ps -Z能显示进程的安全上下文&lt;/p&gt;
&lt;p&gt;id -Z能显示shell的安全上下文：joe：usr_r：usr_t&lt;/p&gt;
&lt;h2&gt;2、TE访问控制&lt;/h2&gt;
&lt;p&gt; 在SELinux中，默认时没有允许规则的，也没有超级用户。被允许的访问必须由规则给出。&lt;/p&gt;
&lt;p&gt;一条规则如下：&lt;/p&gt;
&lt;p&gt;allow Source type(s) Target type(s): Object class(es) Permission(s)&lt;/p&gt;
&lt;p&gt;比如这样的访问规则：&lt;/p&gt;
&lt;p&gt;allow user_t bin_t : file {read execute getattr};&lt;/p&gt;
&lt;p&gt;表示允许域为user_t的进程对type为bin_t的文件具有读、执行、得到属性的操作&lt;/p&gt;
&lt;h2&gt;3、角色的作用&lt;/h2&gt;
&lt;p&gt;SELinux也提供基于角色的访问控制&lt;/p&gt;
&lt;p&gt;通过以下语句指定role的type：&lt;/p&gt;
&lt;p&gt;role  user_r  type  passwd_t;&lt;/p&gt;
&lt;p&gt;如果没有以上这条语句，则：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;安全上下文joe：user_r：passwd_t则不能被创建&lt;/li&gt;
&lt;li&gt;exec调用则失败，即便策略允许&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;1、内核架构&lt;/h2&gt;
&lt;p&gt;基于LSM（linux security module），为所有的内核的资源提供强制访问控制&lt;/p&gt;
&lt;p&gt;LSM提供了一系列的钩子函数&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1184911/201902/1184911-20190210205417583-2109206667.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果访问被DAC拒绝，则会影响审计结果&lt;/p&gt;
&lt;p&gt;SELinux的架构如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1184911/201902/1184911-20190210211444894-1824790990.png&quot; alt=&quot;&quot; width=&quot;638&quot; height=&quot;391&quot;/&gt;&lt;/p&gt;
&lt;p&gt;策略决定包含在安全服务器中，与具体架构无关，便于移植&lt;/p&gt;
&lt;p&gt;对象管理者时各对象的管理者，在LSM架构中，是一系列的LSM钩子，遍布在内核的子系统中。&lt;/p&gt;
&lt;h2&gt; 2、用户空间的对象管理器&lt;/h2&gt;
&lt;p&gt;SELinux支持将对象管理器放到用户态，使用内核的对象管理策略服务器来管理用户态的对象&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1184911/201902/1184911-20190212141611991-503518246.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然而，支持用户空间的对象管理器有一些弱点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对于TE模型，还需要定义class&lt;/li&gt;
&lt;li&gt;对于对象管理器的管理策略不再内核之中&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;策略服务架构如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1184911/201902/1184911-20190212161124593-771859527.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;AVC表示各种缓存&lt;/p&gt;

&lt;p&gt;SELinux的客体除了有type，还有class，进一步对客体的类型进行划分&lt;/p&gt;
&lt;p&gt;SELinux中几个常用的客体类别（class），及其权限&lt;/p&gt;
&lt;p&gt;file：read、write、execute、getattr、create&lt;/p&gt;
&lt;p&gt;dir：read、write、search、rmdir&lt;/p&gt;
&lt;p&gt;process：signal、transition（域的转换）、fork、getattr&lt;/p&gt;
&lt;p&gt;socket：bind、listen、connect、accept&lt;/p&gt;
&lt;p&gt;filesystem：mount、unmount&lt;/p&gt;

&lt;p&gt;在TE模型中，主体通常是正在运行的进程，而不是用户。客体可以是文件、进程、socket等。&lt;/p&gt;
&lt;p&gt;TE模型定义了一系列的规则来表示访问是否允许，如果没有规则，则所有的访问都是不被允许的。&lt;/p&gt;
&lt;p&gt;TE规则主要分为两大类：access vector（AV）和type rules，AV允许审计，而type rules决定控制策略&lt;/p&gt;
&lt;h2&gt; 1、类型(type)、属性(attributes)、别名(aliases)&lt;/h2&gt;
&lt;p&gt;type：在selinux中，将对资源的访问抽象为主体对客体的访问，主体分为多个type，也叫做域，客体也分为多个type，每个type里还能更加细分出class，selinux的访问规则就是基于type建立的规则，所以叫TE模型。&lt;/p&gt;
&lt;p&gt;attributes：用来引用一组具有相同标识符的一组类型&lt;/p&gt;
&lt;p&gt;alases：对于策略而言，别名标准符和类型标识符是一致的&lt;/p&gt;
&lt;p&gt;一个type申明语句的格式如下，中括号中代表的是可选项：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;type type_name [alias alias_set] [, attribute_set]&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;例子：type httpd_user_content_t ，file_type&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;例子：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;举一个例子说明属性的作用&lt;/p&gt;
&lt;p&gt;假设现在新建了一个type为backup_t：&lt;/p&gt;
&lt;p&gt;type backup_t；&lt;/p&gt;
&lt;p&gt;需要对backup_t赋予所有文件的读权限，如果系统中有shadow_t文件和httpd_user_content_t类型的文件，那么需要以下两条的规则来赋予文件读权限&lt;/p&gt;
&lt;p&gt;allow backup_t httpd_user_content_t ：file read&lt;/p&gt;
&lt;p&gt;allow backup_t shadow_t：file read&lt;/p&gt;
&lt;p&gt;假设现在多了一个类型的文件，那么就需要重新为backup_t新增一条规则，这样不仅麻烦而且错误率很高&lt;/p&gt;
&lt;p&gt;现在有了一个属性file_type&lt;/p&gt;
&lt;p&gt;attribute file_type;&lt;/p&gt;
&lt;p&gt;然后将所有具有file_type属性的文件的读权限赋予backup_t&lt;/p&gt;
&lt;p&gt;allow backup_t file_type：file read；&lt;/p&gt;
&lt;p&gt;这样，以后每次有新的文件type出现，只需要将新文件的type域file_type属性关联起来就行，backup_t会自动获得读权限&lt;/p&gt;

&lt;p&gt;以上的例子简单说明了属性的使用，一个type可以关联到多个属性，将type和attribute关联起来可以使用typeattribute，格式为：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;typeattribute type_name attrib_name&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;别名用来保证兼容性，使用typealias来关联，格式如下：&lt;/p&gt;
&lt;p&gt;typealias type_name alias alias_names;&lt;/p&gt;
&lt;h2&gt;2、AV（access rules）规则&lt;/h2&gt;
&lt;p&gt;AV规则有四类&lt;/p&gt;
&lt;p&gt;allow：允许两个类型之间的具体访问&lt;/p&gt;
&lt;p&gt;dontaudit：指定不记录拒绝访问的信息&lt;/p&gt;
&lt;p&gt;auditallow：允许事件被记录&lt;/p&gt;
&lt;p&gt;neverallow：指定规则永远不会被赋予访问权限&lt;/p&gt;
&lt;h3&gt;alow规则&lt;/h3&gt;
&lt;p&gt;格式：&lt;/p&gt;
&lt;p&gt;allow source_type target_type ：objectclass{permission}&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;p&gt;allow user_d bin_t : file{read、execute、getattr}&lt;/p&gt;
&lt;p&gt;允许user_d域的进程对bin_t类型的普通文件进行读、写、取属性操作&lt;/p&gt;
&lt;h3&gt;AV规则通用语法&lt;/h3&gt;
&lt;p&gt;所有的AV规则的语法都同于上述的allow规则&lt;/p&gt;
&lt;h3&gt;在AV规则中使用属性&lt;/h3&gt;
&lt;p&gt;以allow的例子为例，定义了file_type的属性之后，可以将规则写为：&lt;/p&gt;
&lt;p&gt;allow user_d file_type: file{read、execute、getattr}&lt;/p&gt;
&lt;p&gt;如果定义了主体的的type，则规则可以写为：&lt;/p&gt;
&lt;p&gt;allow domain file_type: file{read、execute、getattr}&lt;/p&gt;
&lt;h3&gt;多个type和attribute&lt;/h3&gt;
&lt;p&gt;如果有多个type和attribute存在，则可以用括号表示多个，并且type的attribute可以混用&lt;/p&gt;
&lt;p&gt;allow {domain user_t} {file_type bin_t}: file{read、execute、getattr}&lt;/p&gt;
&lt;h3&gt;self&lt;/h3&gt;
&lt;p&gt;规则中可以出现self字样，以下两条规则等价&lt;/p&gt;
&lt;p&gt;allow user_t user_t : process signal;&lt;/p&gt;
&lt;p&gt;allow user_t self: process signal;&lt;/p&gt;
&lt;h3&gt;类型否定&lt;/h3&gt;
&lt;p&gt;类型否定用来在一系列的type中减去某个type，比如以下规则从exec_type中减去sbin_t&lt;/p&gt;
&lt;p&gt;allow domain (exec_type -sbin_t): file{read、execute、getattr}&lt;/p&gt;
&lt;h3&gt;class的权限&lt;/h3&gt;
&lt;p&gt;allow user_t bin_t : {file dir} {read getattr}&lt;/p&gt;
&lt;p&gt;等价于：&lt;/p&gt;
&lt;p&gt;allow user_t bin_t : file {read getattr}&lt;/p&gt;
&lt;p&gt;allow user_t bin_t : dir {read getattr}&lt;/p&gt;
&lt;h3&gt;通配符&lt;/h3&gt;
&lt;p&gt;allow user_t bin_t : dir *&lt;/p&gt;
&lt;p&gt;表示赋予所有权限&lt;/p&gt;
&lt;h3&gt;取反操作符&lt;/h3&gt;
&lt;p&gt;allow user_t bin_t : file ~{read getattr}&lt;/p&gt;
&lt;p&gt;表示除了read和getattr之外的权限全部赋予&lt;/p&gt;
&lt;h3&gt;审计规则&lt;/h3&gt;
&lt;p&gt;默认情况下，允许的访问时不被记录的，而不允许的访问会被记录下，比如以下的两个指令&lt;/p&gt;
&lt;p&gt;dontaudit：指定不记录拒绝访问的信息&lt;/p&gt;
&lt;p&gt;auditallow：允许事件被记录&lt;/p&gt;
&lt;h3&gt;从不允许&lt;/h3&gt;
&lt;p&gt;neverallow：指定规则永远不会被赋予访问权限&lt;/p&gt;
&lt;h2&gt;3、策略规则&lt;/h2&gt;
&lt;p&gt;策略规则中有两类&lt;/p&gt;
&lt;p&gt;type_transition：&lt;/p&gt;
&lt;p&gt;type_change：&lt;/p&gt;
&lt;h3&gt;通用规则语义&lt;/h3&gt;
&lt;p&gt;rule_name　　source_type　　target_type　　object_class　　defult_type&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;p&gt;type_transition  user_t   passwd_exec_t : process passwd_t;&lt;/p&gt;
&lt;p&gt;以上规则表示，当一个user_t域的进程执行类型为passwd_exec_t的文件时，进程的type默认转移到passwd_t&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：在以上的语法中，处了default_type不能使用集合，其他都能使用集合&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;type转移&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;进程在fork的时候继承父进程的type，而文件在在创建时继承自容器的type，例如目录&lt;/p&gt;
&lt;p&gt;假设有如下规则：&lt;/p&gt;
&lt;p&gt;type_transition  user_t   passwd_exec_t : process passwd_t;‘&lt;/p&gt;
&lt;p&gt;在上述例子中，defult_type就是默认要转移的type&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;但是需要完成一个完整的转移不仅仅需要上述的一条规则，总共需要3条。’&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;p&gt;type为init_t的进程fork一个子进程，然后执行type为appache_exec_t的文件，同时进程的域需要转移到apache_t&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1184911/201902/1184911-20190219201148063-687153840.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一共需要3条规则&lt;/p&gt;
&lt;p&gt;1、原域必须对目标类型有执行权限（init_t对appache_exec_t有执行权限）&lt;/p&gt;
&lt;p&gt;2、原域必须对目标域有转移权限（init_t对apache_t有转移权限）&lt;/p&gt;
&lt;p&gt;3、目标域必须对目标文件类型有entrypoint权限（apache_t对appache_exec_t有entrypoint权限）&lt;/p&gt;

&lt;h3&gt;object转移&lt;/h3&gt;
&lt;p&gt;type_transition passwd_t tmp_t : file passwd_tmp_t;&lt;/p&gt;
&lt;p&gt;以上例子表示当一个passwd_t进程在tmp_t 目录下创建一个文件时，文件的类型为passwd_tmp_t&lt;/p&gt;
&lt;p&gt;需要的规则包括&lt;/p&gt;
&lt;p&gt;1、tmp_t的增加名字，写，搜索权限&lt;/p&gt;
&lt;p&gt;2、passwd_tmp_t的写和创建权限&lt;/p&gt;

&lt;h3&gt;type改变，type_change&lt;/h3&gt;
&lt;p&gt;type改变时用来指明重新执行时的默认类型，像type_transition一样，指明默认但是不允许，&lt;/p&gt;
&lt;p&gt;type_change   sysadm_t  tty_device_t : chr_file   sysadm_tty_device_t;&lt;/p&gt;
&lt;p&gt;这个type_change规则声明，当代表sysadm_t重新标记tty_device_t类型的字符文件时，应该使用sysadm_tty_device_t类型。&lt;/p&gt;
&lt;p&gt; 这个规则是type_change规则最常用的一个例子，即在用户登录时重新标记终端设备。&lt;/p&gt;
&lt;p&gt;登录程序将通过SELinux模块的内核接口查询策略，传入类型sysadm_t和tty_device_t，并接收类型sysadm_tty_device_t作为用于relabel更改的类型。&lt;/p&gt;
&lt;p&gt;这种机制允许登录过程在新的登录会话期间代表用户对tty设备进行标记，同时将类型的细节封装在策略中，而不是硬编码在应用程序中。&lt;/p&gt;

&lt;p&gt;SELinux中的角色和用户是其RBAC特性的基础。大多数其他主流操作系统的安全特性主要集中于授予用户访问权限，或者直接授予用户访问权限，或者通过某种形式的组或角色机制授予用户访问权限。在SELinux中，通过TE allow规则将访问权限授予类型。&lt;/p&gt;
&lt;p&gt;角色充当类型强制的支持特性，并与用户一起提供一种方法，将基于类型的访问控制与Linux用户及其允许运行的程序绑定在一起。SELinux中的RBAC通过定义域类型和用户之间的关系来控制Linux用户的特权和访问权限，从而进一步限制了类型强制。&lt;/p&gt;
&lt;p&gt;Linux和SELinux有不同的用户标识符,有时是相关的。Linux用户是指/etc/passwd中定义的用户帐户SELinux用户是指安全上下文中在SELinux策略中定义的用户标识符。&lt;/p&gt;
&lt;p&gt;通过将域类型与一个或多个角色关联，我们间接地向用户授予特权。RBAC策略语句不授予访问权限。相反，RBAC通过控制安全上下文中域类型、角色和用户的关联来进一步约束TE策略SELinux 没有直接给“用户”授权。SELinux的安全策略定义了一个用户可以跟哪些角色关联一个角色可以跟哪些域类型关联&lt;/p&gt;
&lt;p&gt;最终定义了一个用户可以跟哪些域类型关联，用户关联的域类型才可以执行该域类型的程序，才具有该域类型的权限。一个用户要执行一个可执行程序时，会产生域切换；SELinux控制一个角色可以切换到哪些角色；SELinux控制角色与域类型的关联进而控制角色可以可以运行的程序角色的切换和角色与域类型的关联控制了用户的权限。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1184911/201902/1184911-20190219211536057-735771895.png&quot; alt=&quot;&quot; width=&quot;548&quot; height=&quot;230&quot;/&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt; 域从域类型为user_t的bash shell进程转换为运行域类型为passwd_t的密码程序的进程。我们为流程安全上下文添加了用户和角色部分的安全上下文joe: user_r: user_t joe: user_r: passwd_t&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1184911/201902/1184911-20190219211821716-584009853.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1184911/201902/1184911-20190219212048565-1312096272.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1184911/201902/1184911-20190219212306956-461586109.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个例子演示了两种RBAC策略语句:一个用户声明语句(user)和两个角色声明语句(role)。用户语句“user joe roles {user_r}”将SELinux用户joe与角色user_r关联起来。该语句告诉SELinux，允许用户joe和角色user_r在安全上下文中共存。如果没有这条语句，图中的user joe和role user_r进程安全上下文将无效，SELinux将拒绝创建它们，从而拒绝域转换尝试。&lt;/p&gt;
&lt;p&gt;这两个角色语句将角色user_r与域类型user_t和passwd_t关联起来。要使流程安全上下文有效，角色语句是必需的。如果没有关联类型passwd_t的role语句，即使TE策略允许，这个域转换也会失败。如果我们不希望user_r角色运行密码程序，那么只需删除这个角色语句，即使TE规则允许访问，内核也永远不会创建安全上下文。&lt;/p&gt;
&lt;h2&gt;1、role语句&lt;/h2&gt;
&lt;p&gt;除了object_r之外，SELinux没有任何内置角色。与类型一样，角色也是在策略中声明的，并通过一致的使用赋予其意义。&lt;/p&gt;
&lt;p&gt;role有四个相关联的语句：&lt;/p&gt;
&lt;p&gt;1、role声明语句&lt;/p&gt;
&lt;p&gt;2、role允许语句&lt;/p&gt;
&lt;p&gt;3、role转移语句&lt;/p&gt;
&lt;p&gt;4、role支配语句&lt;/p&gt;
&lt;h3&gt;角色声明语句&lt;/h3&gt;
&lt;p&gt;格式为：&lt;/p&gt;
&lt;p&gt;role   role_name   [types  type_set];&lt;/p&gt;
&lt;p&gt;角色声明语句声明角色标识符并将类型与角色关联起来。类型必须与角色关联，以便与角色在安全上下文中共存。给定角色标识符的第一个角色语句除了关联列出的类型外，还将声明该角色。所有后续角色语句都关联其他类型。单个角色的多个角色语句通常用于将角色语句放置在与其关联的类型的声明附近&lt;/p&gt;
&lt;h3&gt;角色允许语句&lt;/h3&gt;
&lt;p&gt;格式为：&lt;/p&gt;
&lt;p&gt;allow    role_set    role_set;&lt;/p&gt;
&lt;p&gt;SELinux提供了一种通过execve()系统调用在程序执行期间更改角色的方法。这个特性在本质上类似于域转换，这会导致域类型的更改。角色允许规则(allow)通过指定允许哪些角色更改为其他角色来控制在程序执行时可能发生的角色更改。&lt;/p&gt;
&lt;h3&gt;角色转移规则&lt;/h3&gt;
&lt;p&gt;因为角色可以在程序执行时以类似于类型的方式进行更改，所以我们需要一种方法在策略语言中自动完成这种转换。对于类型，我们使用type_transition规则来指定自动的默认类型转换。对于角色，我们有角色转换规则(role_transition)。这个规则在目的和语法上与type_transition规则类似，只是它指定了在执行文件时发生的默认角色更改。&lt;/p&gt;
&lt;p&gt;格式为：&lt;/p&gt;
&lt;p&gt;role_transition      role_set    type_set     role;&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;p&gt;role_transition   sysadm_r   http_exec_t  system_r;&lt;/p&gt;
&lt;p&gt;此规则声明，除非另有要求，否则当角色为sysadm_r的进程执行类型为http_exec_t的文件时，SELinux应该尝试将角色更改为system_r。&lt;/p&gt;
&lt;h3&gt;角色支配语句&lt;/h3&gt;
&lt;p&gt;格式为：&lt;br/&gt;dominance { role role_name { role_set} }&lt;/p&gt;
&lt;p&gt;角色优势语句指定角色之间的层次关系。角色继承它们所控制的角色的所有类型关联。&lt;/p&gt;
&lt;p&gt;表单角色“role_name”中指定的一个或多个角色;使用空格分隔的列表指定多个角色(例如，{role staff_r;sysadm_r作用;})&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;p&gt;dominance { role a_r { role b_r; role c_r { role d_r; } } }&lt;/p&gt;
&lt;p&gt;d_r关联的角色只有它自己的类型&lt;/p&gt;
&lt;p&gt;c_r它的类型和d_r的类型&lt;/p&gt;
&lt;p&gt;d_r关联的角色只有它自己的类型&lt;/p&gt;
&lt;p&gt;a_r它自己的类型以及b_r、c_r和d_r中的所有类型&lt;/p&gt;
&lt;h2&gt;2、用户和用户语句&lt;/h2&gt;
&lt;p&gt;Linux和SELinux用户标识符是不同的，通常是不相关的。在SELinux中，Linux用户标识符和给定进程的SELinux用户标识符可能不同。SELinux使用不同的用户标识符(而不是共享Linux的标识符)的设计决策的动机是希望创建不可变的SELinux用户标识符。在标准Linux中，用户标识符的变化反映权限的变化(例如，更改为root)。在许多情况下，实际的和有效的用户标识符都会发生变化。这使得跟踪哪个用户登录进行审计、身份验证和其他使用变得困难。分离Linux和SELinux用户标识符允许Linux用户标识符在不影响SELinux的情况下根据需要进行更改。&lt;/p&gt;
&lt;p&gt;user声明语句(user)在策略中声明一个用户标识符，并将其与一个或多个角色关联。user语句是与SELinux用户相关的惟一策略语句。用户语句必须在所有类型和角色语句之后以及约束之前&lt;/p&gt;
&lt;p&gt;格式如下：&lt;/p&gt;
&lt;p&gt;user user_name roles role_set;&lt;/p&gt;
&lt;p&gt;假设有如下规则：&lt;/p&gt;
&lt;p&gt;user joe roles { user_r };&lt;/p&gt;
&lt;p&gt;如果策略中尚未声明用户joe，则该语句声明该用户joe，并将角色user_r与该用户关联起来。&lt;/p&gt;
&lt;h3&gt;将SELinux的用户和linux用户关联&lt;/h3&gt;
&lt;p&gt;登录程序(例如，login, sshd)负责将Linux用户映射到SELinux用户。登录时，如果有一个与Linux用户标识符完全相同的SELinux用户标识符，则匹配的SELinux用户标识符将成为初始shell进程的安全上下文中的用户标识符。&lt;/p&gt;
&lt;p&gt;在许多情况下，不希望在策略中定义每个普通用户。对于SELinux(即user_r角色和user_t初始用户域类型)，普通用户通常具有相同的特权。为了解决这个问题，SELinux有一个特殊的用户标识user_u，称为泛型用户。如果策略中定义了通用用户user_u，那么如果策略中没有匹配的SELinux用户，那么所有Linux用户都将映射到它。&lt;/p&gt;
&lt;p&gt;对于语句：&lt;/p&gt;
&lt;p&gt;user   user_u   roles   { user_r };&lt;/p&gt;
&lt;p&gt;这个语句定义了通用用户user_u，并将其授权给角色user_r，就像我们前面为joe所做的那样。&lt;/p&gt;
&lt;p&gt;如果在策略中定义user_u，则将策略中未显式定义的所有Linux用户映射到user_u。例如，如果jane是一个Linux用户标识符，但是SELinux策略中没有定义用户jane，那么当Linux用户jane登录时，初始shell进程安全上下文中的用户标识符将是user_u。因为joe是在策略中定义的，所以该用户的初始SELinux用户标识符将是joe，即使user_u也是在策略中定义的。&lt;/p&gt;
&lt;p&gt;如果在策略中没有定义泛型用户user_u，那么在SELinux策略中没有显式定义的任何Linux用户标识符都将无法登录，即使在许可模式下也是如此。&lt;/p&gt;
&lt;p&gt;登录时，初始shell进程必须具有有效的安全上下文，包括用户标识符。如果策略中既没有定义user_u，也没有定义Linux用户标识符，则登录过程无法创建有效的安全上下文(因为没有用户标识符可供使用)。因此，如果您的策略中没有包含user_u(这对于许多配置是有意义的)，那么您必须显式地将所有Linux用户添加到SELinux策略中。&lt;/p&gt;
&lt;p&gt;SELinux还有第二个特殊用户，系统用户system_u，它通常用于init等所有系统进程，以及由init启动的守护进程。从技术上讲，用户system_u没有特殊含义，在策略语言中没有以任何方式进行异常处理。但是，大多数现有的策略都包含这个用户，并且系统通常在配置时希望这个SELinux用户用于系统资源。通常，在策略中始终包含system_u是一个好主意&lt;/p&gt;
&lt;p&gt;永远不要使用标识符system_u创建Linux用户帐户。如果这样做，该Linux用户将能够使用系统用户标识符登录，系统用户标识符通常具有很高的特权(尽管仍然比普通Linux系统上的root权限小得多)。&lt;/p&gt;

&lt;p&gt;SELinux提供了一种约束机制来进一步限制策略允许的访问，而不管策略允许规则是什么。&lt;/p&gt;
&lt;p&gt;为了理解约束的目的，让我们重新看看SELinux Linux安全模块(LSM)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1184911/201902/1184911-20190220140745498-1922689116.png&quot; alt=&quot;&quot; width=&quot;671&quot; height=&quot;361&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们希望进一步了解访问决策逻辑在安全服务器中的工作方式。访问向量缓存(AVC)由源安全标识符(SID)、目标SID和对象类三部分组成。SID是安全上下文的内部参考&lt;/p&gt;
&lt;h2&gt;1、安全上下文和SID&lt;/h2&gt;
&lt;p&gt;SELinux实现了Flask安全体系结构，该体系结构提供了实现增强访问控制的框架，但仍然保持安全策略中立。这意味着AVC及其与LSM挂钩的接口没有专门绑定到类型强制(TE)和SELinux实现的其他安全策略。就AVC而言，安全标识符是对一组安全凭据的不透明惟一引用。AVC缓存由源和目标sid以及对象类标识符索引决定。&lt;/p&gt;
&lt;p&gt;SELinux安全服务器在内部将安全上下文与SIDs联系起来，因此，SELinux可以使用sid查找类型、用户和角色标识符，而AVC和LSM钩子接口可以忽略这些细节。当SELinux LSM钩子请求访问决策时，它们提供主题(源)和对象(目标)以及对象类的sid。AVC使用SID-SID-class三元组查找被允许的访问，该访问被存储为位掩码。当缓存丢失发生时，AVC调用安全服务器函数security_compute_av()来确定允许的访问。&lt;/p&gt;
&lt;p&gt;该函数的访问决策逻辑有两个基本步骤:&lt;/p&gt;
&lt;p&gt;1)为type-type-class三元组创建一个表示根据TE allow规则允许的对象权限的掩码;&lt;/p&gt;
&lt;p&gt;2)从允许掩码中删除任何约束不允许的权限。&lt;/p&gt;
&lt;p&gt;第二个步骤允许将约束作为限制策略所允许的权限的一种方法。因此，正如您所看到的，约束进一步限制了SELinux策略中允许的访问。&lt;/p&gt;
&lt;p&gt;SELinux有两种类型的约束。&lt;/p&gt;
&lt;p&gt;constraint语句是最常见的约束，允许您根据源和目标安全上下文的用户、角色和/或类型进一步限制访问。validatetrans语句是SELinux中最新添加的，它使您能够基于旧的、新的和流程安全上下文进一步限制对安全上下文更改事件的访问。&lt;/p&gt;
&lt;h2&gt;2、约束语句&lt;/h2&gt;
&lt;p&gt;约束语句有三个元素:约束应用到的对象类的集合、被约束类的权限集和约束的布尔表达式。约束由对象类组织并存储在策略中。constraint语句允许您根据源和目标安全上下文之间的关系定义约束，从而限制指定对象类的指定权限。约束语句的完整语法如下所示：&lt;/p&gt;
&lt;p&gt;constrain   class_set   perm_set    expression ;&lt;/p&gt;
&lt;p&gt;class_set一个或多个对象类。&lt;/p&gt;
&lt;p&gt;perm_set一个或多个权限。所有权限必须对&lt;/p&gt;
&lt;p&gt;class_set中的所有对象类有效。表达式约束的布尔表达式。&lt;/p&gt;

&lt;p&gt;布尔表达式语法支持以下关键字:&lt;/p&gt;
&lt;p&gt;t1, r1, u1 Source type, role, and user&lt;br/&gt;t2, r2, u2 Target type, role, and user&lt;/p&gt;
&lt;p&gt;约束表达式语法还支持以下操作符:&lt;/p&gt;
&lt;p&gt;= =集合成员的或等价的&lt;/p&gt;
&lt;p&gt;=设置不属于或不等于&lt;/p&gt;
&lt;p&gt;eq (Role关键字)的等价&lt;/p&gt;
&lt;p&gt;dom (Role关键字)支配由&lt;/p&gt;
&lt;p&gt;incomp (Role关键字)支配的&lt;/p&gt;
&lt;p&gt;domby (Role关键字)不可比较&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;例子：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;constrain process transition (u1 == u2) ;&lt;/p&gt;
&lt;p&gt;首先，注意它只应用于流程对象类，并且只限制流程的转换权限。回想一下，允许域转换需要转换权限;实际上，这个约束进一步限制了域转换。现在让我们看看约束表达式(u1 == u2)。我们看到，它要求所有域转换的源用户标识符和目标用户标识符保持相同。allow rule 限制了域类型的切换； constrain 进一步限制 process类型在域切换时：安全上下文中的用户不能改变。&lt;/p&gt;
&lt;p&gt;回想一下前面对访问算法的描述。当流程请求转换权限时，AVC调用安全服务器以确定允许对三重源目标类的访问时，前面的约束将变得有效(对于流程对象类)，并将检查源和目标安全上下文中的用户标识符。如果用户标识符不相同，则在将授予的访问掩码返回AVC之前，掩码中表示转换权限的位将被删除。constraint语句允许您对安全上下文的三个元素(用户、角色和类型)的任意组合表示约束。约束表达式将源(主题)流程和目标(对象)的上下文相互比较，并/或使用显式名称(例如类型或角色标识符)进行比较。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;例子：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;constrain process transition (r1 == r2) ;&lt;/p&gt;
&lt;p&gt;这个约束类似于前面的语句，只是它约束的是角色标识符而不是用户标识符。关键字r1和r2分别表示源角色标识符和目标角色标识符。这个约束要求角色标识符不能在域转换上更改。&lt;/p&gt;
&lt;p&gt;因为这两个约束与相同的对象类和权限相关，约束表达式语法允许我们将它们组合成一个布尔表达式:&lt;/p&gt;
&lt;p&gt;constrain process transition (u1 == u2 and r1 == r2) ;&lt;/p&gt;

&lt;p&gt;让我们进一步看看我们的例子。在某些情况下，我们希望允许在域转换上更改用户和/或角色标识符。例如，登录过程需要将用户和角色标识符更改为登录用户的标识符。登录的SC:system_u:system_r:local_login_t当前SC:user_u:user_r:user_t。另一个例子是允许您更改角色的程序，该程序必须能够在域转换期间更改角色标识符。一般来说，这些程序是受信任的进程，我们需要一种方法来允许它们更改用户/角色标识符，同时确保约束对所有其他程序都是活动的。为了实现这个目标，让我们首先定义一种方法来识别那些受信任可以更改用户和角色标识符的域类型。特别地，让我们假设策略中定义了两个属性:privuser和privrole。前者与允许更改用户标识符的所有类型相关联，后者与允许更改角色标识符的类型相关联。通过这些属性，我们可以改变约束如下:&lt;/p&gt;
&lt;p&gt;constrain process transition (u1 == u2 or t1 == privuser) ;&lt;br/&gt;constrain process transition (r1 == r2 or t1 == privrole) ;&lt;/p&gt;
&lt;p&gt;在这两个语句中，t1都表示源类型。第一个语句只允许在源类型具有privuser属性的情况下在域转换中更改用户标识符。同样，如果源类型具有privrole属性，则可以更改角色&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对于约束表达式，所有操作符的左侧必须是允许的关键字之一(例如，u1或u2)，并且可能永远不是类型、属性、角色或用户标识符(或标识符列表)。运算符的右侧可以是一个关键字或一个或多个标识符名称。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1184911/201902/1184911-20190220145801329-1982133807.png&quot; alt=&quot;&quot; width=&quot;738&quot; height=&quot;324&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1184911/201902/1184911-20190220145816395-1379681029.png&quot; alt=&quot;&quot; width=&quot;738&quot; height=&quot;324&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1184911/201902/1184911-20190220145840786-114027620.png&quot; alt=&quot;&quot; width=&quot;734&quot; height=&quot;283&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;3、标签转换约束&lt;/h2&gt;
&lt;p&gt;SELinux支持第二条约束语句validatetrans。该语句是作为修改后的多级安全特性的一部分添加的，我们将在下一章中进行讨论。通过validatetrans语句，我们可以进一步控制更改受支持对象的安全上下文的能力。&lt;/p&gt;
&lt;p&gt;与constraint语句不同，validatetrans语句允许您将对象的新旧安全上下文相互关联，并/或与第三个安全上下文(试图重新标记对象的进程的安全上下文)关联起来。因此，为该语句添加了新的关键字，特别是t3、r3和u3，分别表示流程安全上下文的类型、角色和用户。*1关键字表示旧的安全上下文，*2关键字表示新的安全上下文&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意不要混淆约束和validatetrans语句之间的关键字关联。对于约束语句，t1表示源(或调用流程)类型，t2表示目标(对象)类型。然而，在validatetrans语句中，t3现在是源流程类型，t1是“旧”类型，t2是“新”类型。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;validatetrans语句通过与新旧安全上下文和流程的安全上下文定义基于约束的关系来限制更改指定受支持对象的安全上下文的能力。validatetrans语句的完整语法如下:&lt;/p&gt;
&lt;p&gt;validatetrans    class_set   expression ;&lt;/p&gt;

&lt;p&gt;布尔表达式语法支持以下关键字:&lt;/p&gt;
&lt;p&gt;t1, r1, u1 Old type, role, and user&lt;br/&gt;t2, r2, u2 New type, role, and user&lt;br/&gt;t3, r3, u3 Process type, role, and user&lt;/p&gt;
&lt;p&gt;约束表达式语法还支持以下操作符:&lt;/p&gt;
&lt;p&gt;==集合成员的或等价的&lt;/p&gt;
&lt;p&gt;=设置不属于或不等于&lt;/p&gt;
&lt;p&gt;eq(仅限Role关键字)的等价&lt;/p&gt;
&lt;p&gt;dom(仅限Role关键字)支配&lt;/p&gt;
&lt;p&gt;domby(仅限Role关键字)不受支配&lt;/p&gt;
&lt;p&gt;incomp(仅限Role关键字)不可比较&lt;/p&gt;

&lt;p&gt;假设我们有一个user_tmp_t类型，在我们的策略中，我们将其用作普通不受信任用户程序的临时文件的类型。我们可能希望确保具有更改所有文件标签权限的域不会意外地将user_tmp_t作为其类型的文件重新标记为某些非常关键的类型(输入shadow_t类型，这是/etc/shadow文件的类型)。这是我们的约束条件它提供了这样的约束:&lt;/p&gt;
&lt;p&gt; validatetrans {file lnk_file} ( t2 != shadow_t or t1 != user_tmp_t );&lt;/p&gt;
&lt;p&gt;注意这个约束的几个特性。我们同时包含普通文件和符号链接(lnk_file)，因为我们不希望有人使用链接代替文件。该约束表示，要允许文件和符号链接对象更改安全上下文，只有在旧类型不是user_tmp_t的情况下，新类型才可能是shadow_t。如果旧类型是user_tmp_t，则新类型可能不是shadow_t。换句话说，任何域类型都不能被授权将用户临时文件重新标记为影子密码文件的类型。&lt;/p&gt;
&lt;p&gt;要扩展这个示例，假设有一个域类型子集，我们希望允许它将user_tmp_t重新标记为shadow_t。现在，我们创建一个属性relabel_any，并将其分配给我们希望授予此特权的那些域类型。&lt;/p&gt;
&lt;p&gt;validatetrans {file lnk_file}&lt;br/&gt;(&lt;br/&gt;　　( t3 == relabel_any) or&lt;br/&gt;　　( t2 != shadow_t or t1 != user_tmp_t )&lt;br/&gt;);&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1184911/201902/1184911-20190220152015922-1624410828.png&quot; alt=&quot;&quot; width=&quot;841&quot; height=&quot;550&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1184911/201902/1184911-20190220152032497-1051979466.png&quot; alt=&quot;&quot; width=&quot;847&quot; height=&quot;533&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1184911/201902/1184911-20190220152051146-637575547.png&quot; alt=&quot;&quot; width=&quot;857&quot; height=&quot;357&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在最近对SELinux的增强中，约束特性得到了扩展，以实现可选的多级安全(MLS)策略。MLS是另一种形式的强制访问控制，它构建在类型强制(TE)之上。在本章中，我们将探讨可选的MLS策略特性。MLS是另一种强制访问控制形式，适用于一些安全问题，特别是与政府机密数据控制相关的安全问题。在SELinux中，MLS是类型强制的可选扩展;没有它，MLS特性就无法实现。&lt;/p&gt;
&lt;h2&gt;7.1 安全上下文和多级安全&lt;/h2&gt;
&lt;p&gt;启用MLS时，将使用两个附加字段扩展安全上下文:低安全级别和高安全级别。安全级别本身有两个字段:敏感（sensitivity）性和一组类别（categories）。敏感性是严格分层的，反映了一个有序的数据敏感性模型，如政府分类控制中的绝密、机密和非机密。类别是无序的，反映了数据划分的需要。基本思想是，您既需要足够高的灵敏度间隙，又需要正确的类别来访问数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不要混淆安全级别和敏感性。安全级别是单个敏感性和一组(零或多个)类别的组合。安全级别不是分层的，使用优势关系(dom、domby、eq、incomp)进行比较&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;7.2 定义安全等级&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;使用灵敏度语句定义灵敏度，如下所示：&lt;/p&gt;
&lt;p&gt;sensitivity s0;&lt;br/&gt;sensitivity s1;&lt;br/&gt;sensitivity s2;&lt;br/&gt;sensitivity s3;&lt;/p&gt;
&lt;p&gt;这些名称是SELinux中典型的通用敏感命名约定。&lt;/p&gt;
&lt;p&gt;敏感性语句还支持将附加别名与敏感性关联的能力，敏感性将被视为与核心敏感性名称相同的名称。例如：&lt;/p&gt;
&lt;p&gt;sensitivity s1 alias unclassified;&lt;/p&gt;
&lt;p&gt;这些名称是SELinux中典型的通用敏感命名约定。&lt;/p&gt;
&lt;p&gt;由于敏感性必须是层次性相关的，我们必须在政策中使用支配性语句指定敏感性的层次性，如下所示:&lt;/p&gt;
&lt;p&gt;dominance { s0 s1 s2 s3 } &lt;/p&gt;
&lt;p&gt;优势语句按照从低到高的顺序列出敏感性名称。因此，在我们的例子中，s0小于s1, s1小于s2，以此类推。&lt;/p&gt;
&lt;p&gt;类别的定义类似于使用类别语句定义敏感性。类别也可以有别名。下列语句是类别语句的例子:&lt;/p&gt;
&lt;p&gt;category c0 alias blue;&lt;br/&gt;category c1 alias red;&lt;br/&gt;category c2 alias green;&lt;br/&gt;category c3 alias orange;&lt;br/&gt;category c4 alias white;&lt;/p&gt;
&lt;p&gt;在策略语言中定义安全级别的最后一步是使用level语句定义允许的安全级别组合。level语句规定了如何将类别与敏感性联系起来。&lt;strong&gt;请记住，单个敏感性和一组类别的组合构成一个安全级别&lt;/strong&gt;。下面是level语句的一些例子:&lt;/p&gt;
&lt;p&gt;level s0:c0.c4;&lt;br/&gt;level s1:c0.c4;&lt;br/&gt;level s2:c0.c4;&lt;br/&gt;level s3:c0.c4;&lt;/p&gt;

&lt;p&gt;例子：&lt;br/&gt;level s0:c0.c2;&lt;br/&gt;level s1:c0.c2，c4;&lt;/p&gt;
&lt;p&gt;在本例中，s0可能只与类别c0、c1和c2相关联;s1有c0 c1 c2 c4(但不是c3)现在，您应该已经注意到，点(.)表示类别的一个包含范围，逗号(，)表示类别的一个非连续列表。level语句定义了哪些敏感性和类别的组合构成SELinux策略中MLS部分可接受的安全级别&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;仅仅因为类别的范围是使用范围运算符(.)指定的，这并不意味着类别是分层相关的。相反，range操作符只是一种方便地引用一组类别的方法。范围操作符的类别顺序只是声明它们的顺序，与它们的名称隐含的任何内在顺序无关。&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;7.3 安全上下文的MLS拓展&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;格式如下：&lt;/p&gt;
&lt;p&gt;user:role:type:sensitivity[:category,...][ - sensitivity[:category,...]]&lt;/p&gt;
&lt;p&gt;对于MLS SELinux系统，安全上下文被扩展为包括两个安全级别:低级别或当前安全级别和高级别或清除安全级别。通常，低级别反映了流程的当前安全级别或对象中包含的数据的敏感性。高级别反映上下文中用户标识符的清除级别(从而确定任何安全上下文的当前级别所允许的最高安全级别)或某些所谓的多级别对象所允许的最大数据范围。&lt;/p&gt;
&lt;p&gt;要使安全上下文有效，高级别必须始终控制低级别。此外，与敏感性相关的类别必须根据策略中的级别声明有效。&lt;/p&gt;

&lt;p&gt;例子：&lt;/p&gt;
&lt;p&gt;level s0:c0.c2;&lt;br/&gt;level s1:c0.c2,c4;&lt;/p&gt;
&lt;p&gt;user_u、user_r和user_t是有效的用户、角色和类型标识符，以下安全上下文无效:&lt;/p&gt;
&lt;p&gt;user_u:user_r:user_t:s0 -s0:c2,c4 (c4 is invalid for s0)&lt;br/&gt;user_u:user_r:user_t:s0:c0 -s0:c2 (high does not dominate the low)&lt;/p&gt;

&lt;p&gt;这里，我们将探讨通过策略语句创建的条件策略，这些策略允许我们根据环境定义启用或禁用的规则。&lt;/p&gt;
&lt;h2&gt;8.1 概述&lt;/h2&gt;
&lt;p&gt;条件策略语句使我们能够定义仅在条件表达式定义的情况下启用的策略规则集，条件表达式是使用定义的变量和逻辑运算符构造的逻辑表达式。让我们看一个虚构的例子。&lt;/p&gt;
&lt;p&gt;假设我们有一台移动计算机，并且希望定义策略规则，使其能够访问特定程序的域类型(例如，myprog_t)，以便在计算机停靠时仅访问有线以太网网络接口，在计算机未停靠时仅访问无线网络接口。&lt;/p&gt;
&lt;p&gt;为了达到这个目的，我们可以写一个条件句，如:&lt;/p&gt;
&lt;p&gt;bool docked true;&lt;br/&gt;if (docked) {&lt;br/&gt;　　# rules to allow my_prog_t access to wired Ethernet device&lt;br/&gt;} else {&lt;br/&gt;　　# rules to allow my_prog_t access to wireless device&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;我们所要做的就是在停靠/取消停靠设备时更改布尔值(例如，正在运行的服务可能会监视此状态并相应地设置布尔值)，以启用适当的策略规则集。&lt;/p&gt;
&lt;h2&gt;8.2 布尔变量&lt;/h2&gt;
&lt;p&gt;编写条件策略的第一步是创建布尔变量。例如，假设我们想要配置策略，以便普通用户使用ping程序的能力能够被打开和关闭。我们需要定义一个布尔变量user_ping，我们将在条件表达式中使用它。&lt;/p&gt;
&lt;p&gt;bool  user_ping  false；&lt;/p&gt;
&lt;p&gt;我们使用bool语句来定义布尔变量。bool语句有两个参数，布尔值(user_ping)的名称及其默认值，可以为真，也可以为假。在这种情况下，默认值(false)意味着普通用户在默认情况下不能使用ping，bool语句定义了条件布尔值及其默认值。&lt;/p&gt;
&lt;p&gt;bool    bool_name    default_value;&lt;/p&gt;
&lt;p&gt;内核通过selinux伪文件系统公开布尔值。这个伪文件系统是用户空间和内核中的SELinux Linux安全模块(LSM)之间的主要接口。文件系统通常安装在/selinux/上。当前策略中定义的所有布尔变量将显示为这个伪文件系统的布尔目录中的文件。例如，您可以将上面定义的布尔值看作一个路径名为/selinux/ boolies /user_ping的文件。&lt;/p&gt;
&lt;p&gt;在运行的系统中更改布尔变量值的能力使我们能够更改条件表达式的值，从而提供条件策略。因此，SELinux内核必须使布尔变量可用于运行更改的进程。这与策略的任何其他组件不同，后者一旦加载到内核中，在加载新的整个策略之前都是静态的。布尔值在运行的系统上可以单独访问和更改。&lt;/p&gt;
&lt;p&gt;我们使用selinux文件系统中的布尔文件来查询和设置布尔变量的当前值。如果您查看布尔文件的内容，您总是会看到一对数字(0或1表示false或true)，如下所示:&lt;/p&gt;
&lt;p&gt;# cat /selinux/booleans/user_ping&lt;br/&gt;1 1&lt;/p&gt;
&lt;p&gt;第一个数字表示布尔变量的当前值;在这种情况下，1为真。第二个数字表示布尔变量的挂起值。当前值是内核用于布尔值和确定条件表达式值的实际值。挂起是布尔值的当前值在提交布尔值更改时将被更改的值。&lt;strong&gt;我们通过更改布尔的挂起值，然后将更改提交给内核，来更改布尔的当前值。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们通过向布尔文件写入1或0来更改挂起的值，如下所示:&lt;/p&gt;
&lt;p&gt;# cat /selinux/booleans/user_ping&lt;br/&gt;1 1&lt;br/&gt;# echo 0 &amp;gt; /selinux/booleans/user_ping&lt;br/&gt;# cat /selinux/booleans/user_ping&lt;br/&gt;1 0&lt;/p&gt;
&lt;p&gt;挂起的值现在变为0，当前值保持不变。这意味着，即使将布尔user_ping的挂起值更改为false(0)，它的值仍然为true(1)。&lt;/p&gt;
&lt;p&gt;原因是更改布尔值需要两个步骤的提交过程。首先，更改想要更改的布尔值的挂起值，然后将挂起值提交到当前值。这允许您更改多个布尔值，然后在一步中提交所有更改。文件/selinux/commit_pending_bools是将所有布尔值的挂起值提交为当前值的接口。通过向该文件写入1，可以实现提交，如下所示:&lt;/p&gt;
&lt;p&gt;# echo 1 &amp;gt; /selinux/commit_pending_bools&lt;br/&gt;# commit all pending values&lt;br/&gt;# cat /selinux/booleans/user_ping&lt;br/&gt;0 0&lt;/p&gt;
&lt;p&gt;SELinux为查询和更改布尔值提供了方便的命令，而无需记住它们的文件位置。getsebool命令将布尔值的状态显示为活动(TRue)或非活动(false)。例如:&lt;/p&gt;
&lt;p&gt;# getsebool -a&lt;br/&gt;docked &amp;gt; inactive&lt;br/&gt;user_ping &amp;gt; active&lt;br/&gt;...&lt;/p&gt;
&lt;p&gt;我们还可以使用setsebool命令更改布尔值&lt;/p&gt;
&lt;p&gt;# getsebool user_ping （* show current state *）&lt;br/&gt;user_ping &amp;gt; active&lt;br/&gt;# setsebool user_ping false （* change and commit current state*）&lt;br/&gt;# getsebool user_ping （* show changed stated *）&lt;br/&gt;user_ping &amp;gt; inactive&lt;/p&gt;
&lt;p&gt;我们还可以使用setsebool命令，使用参数的另一种格式在一个事务中更改多个布尔值，如下所示:&lt;/p&gt;
&lt;p&gt;# getsebool user_ping docked&lt;br/&gt;user_ping &amp;gt; active&lt;br/&gt;docked &amp;gt; inactive&lt;br/&gt;# setsebool user_ping=0 docked=1&lt;br/&gt;# getsebool user_ping docked&lt;br/&gt;user_ping &amp;gt; inactive&lt;br/&gt;docked &amp;gt; active&lt;/p&gt;
&lt;p&gt;在策略文件中定义了布尔变量及其默认状态。在SELinux策略语言中包含布尔值之后，出现了一个问题，即如何在不重新创建策略的情况下更改布尔值的默认状态。因此引入了持久值的概念。SELinux实用程序使用的标准库提供了一种方法，通过使用布尔值来维护文件，从而对布尔值进行持久更改。init进程使用此文件在系统初始化期间覆盖策略默认值。通过这种方式，我们可以更改在重新引导期间持续存在的布尔值的当前值，而不必修改静态SELinux策略。&lt;/p&gt;
&lt;h2&gt;8.3 条件语句&lt;/h2&gt;
&lt;p&gt;if (cond_expression)&lt;/p&gt;
&lt;p&gt;{true_list}&lt;/p&gt;
&lt;p&gt;[else {false_list}]&lt;/p&gt;
&lt;p&gt;cond_expression&lt;/p&gt;
&lt;p&gt;是一个条件表达式，由一个或多个布尔变量和逻辑运算符组成。表9-1列出了受支持的逻辑运算符。布尔变量必须使用bool语句定义。根据条件表达式的值有条件地启用或禁用的规则列表。当条件列表为真时，将启用规则的真列表(禁用false)。反之亦然。false列表是可选的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1184911/201902/1184911-20190220165212285-1940871353.png&quot; alt=&quot;&quot; width=&quot;669&quot; height=&quot;451&quot;/&gt;&lt;/p&gt;

&lt;p&gt;要使SELinux策略发挥作用，所有对象实例都必须使用安全上下文进行标记。在本节中，我们将讨论将安全上下文应用于对象实例的各种方法，包括在创建对象时如何分配安全上下文，以及稍后如何修改这些标签(称为重标号)。&lt;/p&gt;
&lt;h2&gt;9.1 基本含义&lt;/h2&gt;
&lt;p&gt;SELinux中的所有对象从创建到销毁都有一个相关的安全上下文。此属性对于SELinux执行访问控制的能力至关重要。让我们看看文件/etc/shadow的安全上下文&lt;/p&gt;
&lt;p&gt;# ls -Z /etc/shadow&lt;br/&gt;-r------- root root system_u:object_r:shadow_t shadow&lt;/p&gt;
&lt;p&gt;这个例子演示了为文件/etc/shadow显示安全上下文的程序ls。与对象关联的安全上下文(在本例中是system_u:object_r:shadow_t)是SELinux在访问控制决策中使用的唯一属性。从根本上说，这一点以及为所有对象分配正确的安全上下文非常重要。&lt;/p&gt;
&lt;p&gt;SELinux策略语言包含一些特性，这些特性使标记决策自动化并在很大程度上透明。文件和域转换的类型转换规则，有时，标签成为我们需要关注的问题。在系统管理、策略开发、系统安装期间。作为政策制定者，我们必须仔细制定标签政策声明，以便在运行时简化标签管理。&lt;/p&gt;
&lt;p&gt;对象在SELinux系统上的标记有四种基本方式:&lt;/p&gt;
&lt;p&gt;1、策略语句：SELinux策略语言包含一些特性，比如type_transition规则，它们为对象标记指定行为&lt;/p&gt;
&lt;p&gt;2、硬编码的默认：大多数对象类都在对象管理器中编码了某种类型的默认标记行为。例如，默认情况下，当进程创建新套接字时，新套接字具有与其创建进程相同的安全上下文。&lt;/p&gt;
&lt;p&gt;3、程序需要的标记：对于一些对象类，SELinux提供了各种应用程序编程接口(api)，允许程序显式地请求标签，包括新对象实例和现有对象实例&lt;/p&gt;
&lt;p&gt;4、出事SID：SELinux有一组初始安全标识符(初始sid)，用于标记一些对象，并在对象缺少或无效标签时用作故障安全标签&lt;/p&gt;


&lt;p&gt;未完待续。。。&lt;/p&gt;
</description>
<pubDate>Wed, 20 Feb 2019 14:13:00 +0000</pubDate>
<dc:creator>番茄汁汁</dc:creator>
<og:description>一、基本概念 1、TE模型的安全上下文 所有的操作系统访问控制都基于主体、客体，以及与他们相关的访问控制属性。 在selinux中，访问控制属性叫做安全上下文。所有对象(文件、进程间通信通道、套接字、</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/likaiming/p/10360104.html</dc:identifier>
</item>
<item>
<title>不迈出第一步，不去尝试，你永远不知道能否成功 - 依乐祝</title>
<link>http://www.cnblogs.com/yilezhu/p/10409499.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yilezhu/p/10409499.html</guid>
<description>&lt;p&gt;成功的故事固然荡气回肠，失败的故事也能千回百转，但是如果你连第一步都不愿迈出，不去追求与偿试，那么你永完不会知道成功或者失败的原因是什么，人生一辈子也就三万多天，如果每天糊里糊涂的过去了，若干年后可能连故事都没得讲。&lt;/p&gt;
&lt;p&gt;年前的时候广州.net俱乐部主席叶老师就曾微信找我私聊，说你可以在合肥组织一个合肥.net俱乐部啊！刚收到叶老师的消息，其实我还是满心欢喜的，这证明有人认可我，认为我能做成这件事情！可是转念一想：虽然自己有着六七年的.net软件开发经验,最近也出了一个.NET Core的系列实战教程，可是毕竟自己能力有限，知识储备也有限，也没有大公司就职的经验，只是从去年才开始在博客园活跃，分享技术文章，这样的我能担此大任吗？&lt;/p&gt;
&lt;p&gt;因此我犹豫了，再加上最近比较忙所以这件事情一直搁置了，但是今天，2019年2月20日的今天看着一个个新的微软地方.NET俱乐部的筹备，重燃了我内心的那种狂热，再加上苏州.net俱乐部主席潘老师说的一些鼓励人心的话，因此我决定试着迈出这一步，准备为合肥微软.NET俱乐部的成立贡献自己的一份力，由于我知道自己的能力有限，所以我拉上了最近在博客园同样活跃而且同在合肥的“&lt;a href=&quot;https://www.cnblogs.com/jackcao/&quot;&gt;金焰的世界&lt;/a&gt;”一起牵这个头，来组织一下属于我们霸都合肥的微软.NET技术俱乐部，让我们霸都合肥的.NETer们不再孤军奋战。同时，待合肥的.net小伙伴都聚集在一起后我们再组织线下聚会，那时候我们再另选有能力的人来担此大任。&lt;/p&gt;
&lt;p&gt;既然我们准备成立属于我们霸都合肥的微软.NET技术俱乐部，那么就得有个微信群或者QQ群来进行沟通交流吧！目前大家可以加入我的.NET Core实战项目交流群跟大伙沟通，当然也可以先加我的微信：jkingzhu,备注下“合肥”，我会在文章结尾的时候贴出我的微信二维码，然后我再建立一个微信群方便大伙的交流！在写这篇文章的时候我心里是没底的，不知道能够团结多少合肥的微软技术爱好者，但我还是会为此尽自己的绵薄之力，这也是为了让自己不留遗憾吧。&lt;/p&gt;
&lt;p&gt;下面再跟大伙说说微软技术俱乐部是干吗的呢？它是由全国各地微软技术爱好者及发烧友自发形成的民间组织。在这里大家关注微软的前沿技术，探讨交流各种技术问题，会员充分表达自己的思想。这是一个成长性组织，一个能让我们学习、成长的平台，是一个属于程序员自己的大家庭，所以大伙赶快加入吧。&lt;/p&gt;
&lt;p&gt;最后我想说一句，不管结果如何，至少我迈出了这一步，不管这个属于我们霸都合肥的微软.NET俱乐部成立的结果如何，至少我已经尽力了！最后感谢大家的阅读！&lt;br/&gt;另附上本人的微信二维码，备注“合肥”拉你进入微信群，当然你也可以加入我们的.NET Core实战项目交流群跟大伙交流！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201902/1377250-20190220214925083-1877998274.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 20 Feb 2019 13:52:00 +0000</pubDate>
<dc:creator>依乐祝</dc:creator>
<og:description>成功的故事固然荡气回肠，失败的故事也能千回百转，但是如果你连第一步都不愿迈出，不去追求与偿试，那么你永完不会知道成功或者失败的原因是什么，人生一辈子也就三万多天，如果每天糊里糊涂的过去了，若干年后可能</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yilezhu/p/10409499.html</dc:identifier>
</item>
</channel>
</rss>