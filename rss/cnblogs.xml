<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>死磕 java原子类之终结篇（面试题） - 彤哥读源码</title>
<link>http://www.cnblogs.com/tong-yuan/p/Atomic.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tong-yuan/p/Atomic.html</guid>
<description>&lt;h2 id=&quot;概览&quot;&gt;概览&lt;/h2&gt;
&lt;p&gt;原子操作是指不会被线程调度机制打断的操作，这种操作一旦开始，就一直运行到结束，中间不会有任何线程上下文切换。&lt;/p&gt;
&lt;p&gt;原子操作可以是一个步骤，也可以是多个操作步骤，但是其顺序不可以被打乱，也不可以被切割而只执行其中的一部分，将整个操作视作一个整体是原子性的核心特征。&lt;/p&gt;
&lt;p&gt;在java中提供了很多原子类，笔者在此主要把这些原子类分成四大类。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/alan-tang-tt/yuan/raw/master/%E6%AD%BB%E7%A3%95%20java%E5%B9%B6%E5%8F%91%E5%8C%85/resource/atomic1.png&quot; alt=&quot;atomic&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;原子更新基本类型或引用类型&quot;&gt;原子更新基本类型或引用类型&lt;/h2&gt;
&lt;p&gt;如果是基本类型，则替换其值，如果是引用，则替换其引用地址，这些类主要有：&lt;/p&gt;
&lt;p&gt;（1）AtomicBoolean&lt;/p&gt;
&lt;p&gt;原子更新布尔类型，内部使用int类型的value存储1和0表示true和false，底层也是对int类型的原子操作。&lt;/p&gt;
&lt;p&gt;（2）AtomicInteger&lt;/p&gt;
&lt;p&gt;原子更新int类型。&lt;/p&gt;
&lt;p&gt;（3）AtomicLong&lt;/p&gt;
&lt;p&gt;原子更新long类型。&lt;/p&gt;
&lt;p&gt;（4）AtomicReference&lt;/p&gt;
&lt;p&gt;原子更新引用类型，通过泛型指定要操作的类。&lt;/p&gt;
&lt;p&gt;（5）AtomicMarkableReference&lt;/p&gt;
&lt;p&gt;原子更新引用类型，内部使用Pair承载引用对象及是否被更新过的标记，避免了ABA问题。&lt;/p&gt;
&lt;p&gt;（6）AtomicStampedReference&lt;/p&gt;
&lt;p&gt;原子更新引用类型，内部使用Pair承载引用对象及更新的邮戳，避免了ABA问题。&lt;/p&gt;
&lt;p&gt;这几个类的操作基本类似，底层都是调用Unsafe的compareAndSwapXxx()来实现，基本用法如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private static void testAtomicReference() {
    AtomicInteger atomicInteger = new AtomicInteger(1);
    atomicInteger.incrementAndGet();
    atomicInteger.getAndIncrement();
    atomicInteger.compareAndSet(3, 666);
    System.out.println(atomicInteger.get());

    AtomicStampedReference&amp;lt;Integer&amp;gt; atomicStampedReference = new AtomicStampedReference&amp;lt;&amp;gt;(1, 1);
    atomicStampedReference.compareAndSet(1, 2, 1, 3);
    atomicStampedReference.compareAndSet(2, 666, 3, 5);
    System.out.println(atomicStampedReference.getReference());
    System.out.println(atomicStampedReference.getStamp());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;原子更新数组中的元素&quot;&gt;原子更新数组中的元素&lt;/h2&gt;
&lt;p&gt;原子更新数组中的元素，可以更新数组中指定索引位置的元素，这些类主要有：&lt;/p&gt;
&lt;p&gt;（1）AtomicIntegerArray&lt;/p&gt;
&lt;p&gt;原子更新int数组中的元素。&lt;/p&gt;
&lt;p&gt;（2）AtomicLongArray&lt;/p&gt;
&lt;p&gt;原子更新long数组中的元素。&lt;/p&gt;
&lt;p&gt;（3）AtomicReferenceArray&lt;/p&gt;
&lt;p&gt;原子更新Object数组中的元素。&lt;/p&gt;
&lt;p&gt;这几个类的操作基本类似，更新元素时都要指定在数组中的索引位置，基本用法如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private static void testAtomicReferenceArray() {
    AtomicIntegerArray atomicIntegerArray = new AtomicIntegerArray(10);
    atomicIntegerArray.getAndIncrement(0);
    atomicIntegerArray.getAndAdd(1, 666);
    atomicIntegerArray.incrementAndGet(2);
    atomicIntegerArray.addAndGet(3, 666);
    atomicIntegerArray.compareAndSet(4, 0, 666);
    
    System.out.println(atomicIntegerArray.get(0));
    System.out.println(atomicIntegerArray.get(1));
    System.out.println(atomicIntegerArray.get(2));
    System.out.println(atomicIntegerArray.get(3));
    System.out.println(atomicIntegerArray.get(4));
    System.out.println(atomicIntegerArray.get(5));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;原子更新对象中的字段&quot;&gt;原子更新对象中的字段&lt;/h2&gt;
&lt;p&gt;原子更新对象中的字段，可以更新对象中指定字段名称的字段，这些类主要有：&lt;/p&gt;
&lt;p&gt;（1）AtomicIntegerFieldUpdater&lt;/p&gt;
&lt;p&gt;原子更新对象中的int类型字段。&lt;/p&gt;
&lt;p&gt;（2）AtomicLongFieldUpdater&lt;/p&gt;
&lt;p&gt;原子更新对象中的long类型字段。&lt;/p&gt;
&lt;p&gt;（3）AtomicReferenceFieldUpdater&lt;/p&gt;
&lt;p&gt;原子更新对象中的引用类型字段。&lt;/p&gt;
&lt;p&gt;这几个类的操作基本类似，都需要传入要更新的字段名称，基本用法如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private static void testAtomicReferenceField() {
    AtomicReferenceFieldUpdater&amp;lt;User, String&amp;gt; updateName = AtomicReferenceFieldUpdater.newUpdater(User.class, String.class,&quot;name&quot;);
    AtomicIntegerFieldUpdater&amp;lt;User&amp;gt; updateAge = AtomicIntegerFieldUpdater.newUpdater(User.class, &quot;age&quot;);

    User user = new User(&quot;tong ge&quot;, 21);
    updateName.compareAndSet(user, &quot;tong ge&quot;, &quot;read source code&quot;);
    updateAge.compareAndSet(user, 21, 25);
    updateAge.incrementAndGet(user);
    
    System.out.println(user);
}

private static class User {
    volatile String name;
    volatile int age;

    public User(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public String toString() {
        return &quot;name: &quot; + name + &quot;, age: &quot; + age;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;高性能原子类&quot;&gt;高性能原子类&lt;/h2&gt;
&lt;p&gt;高性能原子类，是java8中增加的原子类，它们使用分段的思想，把不同的线程hash到不同的段上去更新，最后再把这些段的值相加得到最终的值，这些类主要有：&lt;/p&gt;
&lt;p&gt;（1）Striped64&lt;/p&gt;
&lt;p&gt;下面四个类的父类。&lt;/p&gt;
&lt;p&gt;（2）LongAccumulator&lt;/p&gt;
&lt;p&gt;long类型的聚合器，需要传入一个long类型的二元操作，可以用来计算各种聚合操作，包括加乘等。&lt;/p&gt;
&lt;p&gt;（3）LongAdder&lt;/p&gt;
&lt;p&gt;long类型的累加器，LongAccumulator的特例，只能用来计算加法，且从0开始计算。&lt;/p&gt;
&lt;p&gt;（4）DoubleAccumulator&lt;/p&gt;
&lt;p&gt;double类型的聚合器，需要传入一个double类型的二元操作，可以用来计算各种聚合操作，包括加乘等。&lt;/p&gt;
&lt;p&gt;（5）DoubleAdder&lt;/p&gt;
&lt;p&gt;double类型的累加器，DoubleAccumulator的特例，只能用来计算加法，且从0开始计算。&lt;/p&gt;
&lt;p&gt;这几个类的操作基本类似，其中DoubleAccumulator和DoubleAdder底层其实也是用long来实现的，基本用法如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private static void testNewAtomic() {
    LongAdder longAdder = new LongAdder();
    longAdder.increment();
    longAdder.add(666);
    System.out.println(longAdder.sum());

    LongAccumulator longAccumulator = new LongAccumulator((left, right)-&amp;gt;left + right * 2, 666);
    longAccumulator.accumulate(1);
    longAccumulator.accumulate(3);
    longAccumulator.accumulate(-4);
    System.out.println(longAccumulator.get());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;问题&quot;&gt;问题&lt;/h2&gt;
&lt;p&gt;关于原子类的问题，笔者整理了大概有以下这些：&lt;/p&gt;
&lt;p&gt;（1）Unsafe是什么？&lt;/p&gt;
&lt;p&gt;（3）Unsafe为什么是不安全的？&lt;/p&gt;
&lt;p&gt;（4）Unsafe的实例怎么获取？&lt;/p&gt;
&lt;p&gt;（5）Unsafe的CAS操作？&lt;/p&gt;
&lt;p&gt;（6）Unsafe的阻塞/唤醒操作？&lt;/p&gt;
&lt;p&gt;（7）Unsafe实例化一个类？&lt;/p&gt;
&lt;p&gt;（8）实例化类的六种方式？&lt;/p&gt;
&lt;p&gt;（9）原子操作是什么？&lt;/p&gt;
&lt;p&gt;（10）原子操作与数据库ACID中A的关系？&lt;/p&gt;
&lt;p&gt;（11）AtomicInteger怎么实现原子操作的？&lt;/p&gt;
&lt;p&gt;（12）AtomicInteger主要解决了什么问题？&lt;/p&gt;
&lt;p&gt;（13）AtomicInteger有哪些缺点？&lt;/p&gt;
&lt;p&gt;（14）ABA是什么？&lt;/p&gt;
&lt;p&gt;（15）ABA的危害？&lt;/p&gt;
&lt;p&gt;（16）ABA的解决方法？&lt;/p&gt;
&lt;p&gt;（17）AtomicStampedReference是怎么解决ABA的？&lt;/p&gt;
&lt;p&gt;（18）实际工作中遇到过ABA问题吗？&lt;/p&gt;
&lt;p&gt;（19）CPU的缓存架构是怎样的？&lt;/p&gt;
&lt;p&gt;（20）CPU的缓存行是什么？&lt;/p&gt;
&lt;p&gt;（21）内存屏障又是什么？&lt;/p&gt;
&lt;p&gt;（22）伪共享是什么原因导致的？&lt;/p&gt;
&lt;p&gt;（23）怎么避免伪共享？&lt;/p&gt;
&lt;p&gt;（24）消除伪共享在java中的应用？&lt;/p&gt;
&lt;p&gt;（25）LongAdder的实现方式？&lt;/p&gt;
&lt;p&gt;（26）LongAdder是怎么消除伪共享的？&lt;/p&gt;
&lt;p&gt;（27）LongAdder与AtomicLong的性能对比？&lt;/p&gt;
&lt;p&gt;（28）LongAdder中的cells数组是无限扩容的吗？&lt;/p&gt;
&lt;p&gt;关于原子类的问题差不多就这么多，都能回答上来吗？点击下面的链接可以直接到相应的章节查看：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/0s-u-MysppIaIHVrshp9fA&quot;&gt;死磕 java魔法类之Unsafe解析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/DdwSC5bYgFCWwnb0jxkspg&quot;&gt;死磕 java原子类之AtomicInteger源码分析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/7pY1jKNVB_dvadZRIzmD1Q&quot;&gt;死磕 java原子类之AtomicStampedReference源码分析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/rd13SOSxhLA6TT13N9ni8Q&quot;&gt;杂谈 什么是伪共享（false sharing）？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/_-z1Bz2iMiK1tQnaDD4N6Q&quot;&gt;死磕 java原子类之LongAdder源码分析&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;彩蛋&quot;&gt;彩蛋&lt;/h2&gt;
&lt;p&gt;原子类系列源码分析到此就结束了，虽然分析的类比较少，但是牵涉的内容非常多，特别是操作系统底层的知识，比如CPU指令、CPU缓存架构、内存屏障等。&lt;/p&gt;
&lt;p&gt;下一章，我们将进入“同步系列”，同步最常见的就是各种锁了，这里会着重分析java中的各种锁、各种同步器以及分布式锁相关的内容。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;欢迎关注我的公众号“彤哥读源码”，查看更多源码系列文章, 与彤哥一起畅游源码的海洋。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/alan-tang-tt/yuan/raw/master/%E6%AD%BB%E7%A3%95%20java%E9%9B%86%E5%90%88%E7%B3%BB%E5%88%97/resource/qrcode_ss.jpg&quot; alt=&quot;qrcode&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 13 May 2019 15:33:00 +0000</pubDate>
<dc:creator>彤哥读源码</dc:creator>
<og:description>原子类底层的实现方式？ 原子类的种类？ 原子类的面试题？</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tong-yuan/p/Atomic.html</dc:identifier>
</item>
<item>
<title>【转载】jyupter notebook入门指南 - JackPot</title>
<link>http://www.cnblogs.com/Jack-X1/p/10859742.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Jack-X1/p/10859742.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180529192314271&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;翻译 | 张建军&lt;/p&gt;
&lt;p&gt;出品 | 人工智能头条（公众号ID：AI_Thinker）&lt;/p&gt;

&lt;p&gt;【人工智能头条导读】Jupyter Notebook 是一个 Web 应用程序，便于创建和共享文学化程序文档，支持实时代码、数学方程、可视化和 Markdown，其用途包括数据清理和转换、数值模拟、统计建模、机器学习等等。目前，数据挖掘领域中最热门的比赛 Kaggle 里的资料都是 Jupyter 格式。对于机器学习新手来说，学会使用 Jupyter Notebook 非常重要。&lt;/p&gt;

&lt;p&gt;下面这篇 Jupyter Notebook 入门指南由 Pranav Dar 撰写。当你读完这篇文章时，你将会了解，为什么你应该利用它来搭建你的机器学习项目，以及为什么 Jupyter Notebook 比这个领域的其他标准工具更好！&lt;/p&gt;

&lt;h2 class=&quot;ql-long-584640&quot;&gt; &lt;/h2&gt;
&lt;p&gt;&lt;span&gt;▌&lt;strong&gt;什么是 Jupyter Notebook？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Jupyter Notebook 是一款开放源代码的 Web 应用程序，可让我们创建并共享代码和文档。&lt;/p&gt;

&lt;p&gt;它提供了一个环境，你可以在其中记录代码，运行代码，查看结果，可视化数据并在查看输出结果。这些特性使其成为一款执行端到端数据科学工作流程的便捷工具 ，可以用于数据清理，统计建模，构建和训练机器学习模型，可视化数据以及许多其他用途。&lt;/p&gt;

&lt;p&gt;当你还在构建项目原型时，Jupyter Notebooks 真的特别好用，因为你的代码是被写入独立的单元中并被单独执行的。这允许用户测试项目中的特定代码块，而无需从脚本的开始执行代码。许多其他的 IDE 环境（Integrated Development Environment， 集成开发环境）（如 RStudio ）也以其他几种方式做到这一点，但我发现 Jupyter 的单个单元结构是最好的。&lt;/p&gt;

&lt;p&gt;正如你在本文中将会看到的，这些 Notebooks 是数据科学家手中非常灵活、可交互和强大的工具。他们甚至允许你运行除 Python 以外的其他语言，比如 R 、SQL 等。由于它们比 IDE 平台更具交互性，因此它们被广泛地应用于教学场景。&lt;/p&gt;

&lt;h2 class=&quot;ql-long-584640&quot;&gt; &lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;▌如何安装 Jupyter Notebook？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;首先你需要在机器上安装 Python，Python 2.7或Python 3.3（或更高版本）都可以。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;Anaconda&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;新用户可以使用 Anaconda 发行版来同时安装 Python 和 Jupyter Notebooks。&lt;/p&gt;

&lt;p&gt;Anaconda 安装了这两种工具，并包含了数据科学和机器学习社区中常用的很多软件包。你可以从这里下载最新版本的Anaconda 。&lt;/p&gt;

&lt;p&gt;下载地址：https://jupyter.readthedocs.io/en/latest/install.html&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;pip 安装方法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;如果出于某种原因，你决定不使用 Anaconda，那么你需要确保你的机器正在运行最新版本的 pip。 怎么做？如果你已经安装了 Python，那么 pip 已经安装好了。要升级到最新的版本，请参照下面的代码：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;Linux and OSX  &lt;/span&gt;
pip install -&lt;span&gt;U pip setuptools 

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;Windows &lt;/span&gt;
python -m pip install -U pip setuptools&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;一旦 pip 安装完毕，你可以继续安装 Jupyter：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;For Python2 &lt;/span&gt;
&lt;span&gt;pip install jupyter

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;For Python3 &lt;/span&gt;
pip3 install jupyter&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;你可以在这里（地址：&lt;a href=&quot;https://jupyter.readthedocs.io/en/latest/install.html&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;https://jupyter.readthedocs.io/en/latest/install.html&lt;/a&gt;）查看官方的 Jupyter 安装文档。&lt;/p&gt;

&lt;h2 class=&quot;ql-long-584640&quot;&gt; &lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;▌开始！&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;现在我们已经了解了 Notebooks 是什么，以及如何在自己的机器上安装和设置 Notebooks。是时候开始动动手了！&lt;/p&gt;

&lt;p&gt;要运行 Jupyter Notebooks，只需输入以下命令就可开始使用！&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;jupyter notebook&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如图：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1623928/201905/1623928-20190513232640439-603074815.png&quot; alt=&quot;&quot; width=&quot;871&quot; height=&quot;34&quot;/&gt;&lt;/p&gt;



&lt;p&gt;执行上面命令之后， Jupyter Notebook 将在你的默认浏览器中打开，网址为：http://localhost:8888/tree&lt;/p&gt;

&lt;p&gt;在某些情况下，它可能无法自动打开。这种情况下，你的终端或者命令提示符中将会生成一个带有令牌密钥（ token key ）的网址。要打开 Notebook，你需要将整个 URL（包括令牌密钥）复制粘贴到浏览器中。&lt;/p&gt;

&lt;p&gt;Notebook 打开后，你会在顶部看到三个选项卡：Files（文件），Running（运行）和 Clusters（集群）。Files 基本上列出了所有的文件，Running 显示你当前已经打开的终端和Notebooks，Clusters 由 IPython parallel 包提供，用于并行计算。&lt;/p&gt;

&lt;p&gt;要打开一个新的 Jupyter Notebook，请单击页面右侧的“New”选项卡。在这里，你有四个选项可供选择：&lt;/p&gt;

&lt;p&gt;⦁ Python 3&lt;/p&gt;
&lt;p&gt;⦁ Text File (文本文件)&lt;/p&gt;
&lt;p&gt;⦁ Folder (文件夹)&lt;/p&gt;
&lt;p&gt;⦁ Terminal (终端)&lt;/p&gt;

&lt;p&gt;在 &quot;Text File&quot; 选项中，你会得到一个空白的文档。输入你喜欢的任何字母，单词和数字。它基本上是一个文本编辑器（类似于 Ubuntu 上的应用程序）。你也可以选择一种语言（支持非常多的语言），然后用该语言来写一个脚本。你还可以查找和替换文件中的单词。&lt;/p&gt;

&lt;p&gt;在 &quot;Folder&quot; 选项中， 顾名思义它的功能就是创建文件夹。你可以创建一个新文件夹来放入文件，重新命名或者删除它。&lt;/p&gt;

&lt;p&gt;&quot;Terminal&quot; 的工作方式与你的 Mac 电脑或 Linux 电脑上的终端完全相同（或者 Windows 上的 cmd ）。它在你的Web浏览器中支持终端会话。在这个终端中输入 python ，瞧！现在你已经可以开始写 python 脚本了。&lt;/p&gt;

&lt;p&gt;但在本文中，我们将重点介绍 Notebooks，因此我们将从“New”选项中选择 &quot;Python 3&quot; 选项。你会看到如下的截图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180529192359638&quot; alt=&quot;&quot; width=&quot;1038&quot; height=&quot;200&quot;/&gt;&lt;/p&gt;

&lt;p&gt;然后，你可以导入最常见的 Python 库——pandas 和 numpy——来开始你的项目。代码上方的菜单栏提供了操作单元格的各种选项：insert (添加)，edit (编辑)，cut (剪切)，move cell up/down (上下移动单元格)，run cells(在单元格中运行代码)，interupt (停止代码)，save (保存工作)，以及 restart (重新启动内核)。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180529192410909&quot; alt=&quot;&quot; width=&quot;1034&quot; height=&quot;282&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在下拉菜单中（如上所示），你有四个选项：&lt;/p&gt;

&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;3&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Code - 这是你输入代码的地方&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Markdown - 这是你输入文本的地方。你可以在运行代码后添加结论，添加注释等。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Raw NBConvert - 这是一个命令行工具，可将你的笔记本转换为另一种格式（如 HTML）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;Heading - 你可以将标题添加到单独的小节并使你的 Notebook 看起来干净整洁。这个选项现在已经集成到 Markdown 选项中。添加一个“##”，以确保在你之后输入的内容将被视为标题&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 class=&quot;ql-long-584640&quot;&gt; &lt;/h2&gt;
&lt;p&gt;&lt;span&gt;▌&lt;strong&gt;使用 Magic Functions&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;开发人员已经插入了预定义的 magic functions，使你的工作更方便和更具交互性。你可以运行以下命令来查看这些函数的列表（注意：通常不需要输入“％”，因为通常 Automagic 是默认打开的）：&lt;/p&gt;




&lt;p&gt;你会看到许多选项，你甚至可能认识其中的 ％clear， ％autosave， ％debug 和 ％mkdir 等函数。magic command 有两种运行方式：&lt;/p&gt;


&lt;p&gt;顾名思义， Line-wise 是当你想要执行一个单行命令的时候使用，而 Cell-wise 是你想要执行的命令不仅仅是一行，而是整个单元格中的整个代码块时使用。&lt;/p&gt;

&lt;p&gt;在逐行运行模式中，所有给定的命令都必须以 ％ 字符开始，而在逐块运行模式下，所有命令都必须以 %% 开头。让我们看看下面的例子来更好的理解：&lt;/p&gt;

&lt;p&gt;逐行模式：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;%time a = range(10)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;逐块模式：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;%%timeit a = range (10&lt;span&gt;)

min(a)&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我建议你运行这些命令，看看其中的区别！&lt;/p&gt;

&lt;h2 class=&quot;ql-long-584640&quot;&gt; &lt;/h2&gt;
&lt;p&gt;&lt;span&gt;▌&lt;strong&gt;不仅限于 Python - 在 Notebooks 中使用 R，Julia 和JavaScript&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Notebooks 的魔术并不止于此。你甚至可以在 Notebooks 中使用其他语言，如 R，Julia，JavaScrip t等。我个人喜欢 R 中的 ggplot2 软件包，因此使用 Notebooks 来进行探索性数据分析非常方便。&lt;/p&gt;

&lt;p&gt;要在 Jupyter 中启用 R，你需要 GitHub上提供的 IRKernel（ R 的专用内核）。这里有一份详细的指南（地址：https://discuss.analyticsvidhya.com/t/how-to-run-r-on-jupyter-ipython-notebooks/5512），总共需要八个步骤，还有截图来引导你一步一步进行操作。&lt;/p&gt;

&lt;p&gt;如果你是 Julia 用户，你也可以在 Jupyter Notebooks 中使用它！查看这篇详尽的文章（地址：地址：https://discuss.analyticsvidhya.com/t/how-to-run-r-on-jupyter-ipython-notebooks/5512），它重点介绍了 Julia 用户如何学习数据科学，并包括了一章节介绍如何在 Jupyter 环境中使用 Julia。&lt;/p&gt;

&lt;p&gt;如果你更喜欢使用 JavaScript，我推荐使用 IJavascript 内核。查看这个 GitHub 库（地址：https://github.com/n-riesco/ijavascript），它会引导你在不同操作系统上安装此内核。 请注意，你需要先安装 Node.js 和 npm 才能使用它。&lt;/p&gt;

&lt;h2 class=&quot;ql-long-584640&quot;&gt; &lt;/h2&gt;
&lt;p&gt;&lt;span&gt;▌&lt;/span&gt;&lt;span&gt;&lt;strong&gt;Jupyter Notebooks 中的交互式命令板&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;在开始添加小插件（widget）之前，你需要导入 widgets 包：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; ipywidgets &lt;span&gt;import&lt;/span&gt; widgets
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;小插件的基本类型是典型的文本输入框和按钮。请参阅以下来自Dominodatalab 的示例，了解一下交互式小插件是怎么使用的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180529192433657&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;你可以在这里（地址：https://blog.dominodatalab.com/interactive-dashboards-in-jupyter/）查看详尽的开发指南。&lt;/p&gt;

&lt;h2 class=&quot;ql-long-584640&quot;&gt; &lt;/h2&gt;
&lt;p&gt;&lt;span&gt;▌&lt;strong&gt;键盘快捷键——节省时间并提高效率！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;快捷键是 Jupyter Notebooks 最好用的功能之一。当你想运行任何代码块时，你只需要按下Ctrl + Enter 即可。Jupyter Notebooks 提供的键盘快捷键非常多，为我们节省了大量时间。&lt;/p&gt;

&lt;p&gt;以下是我们挑选的一些快捷键，你在开始使用 Notebooks 时会经常用到这些快捷键。我强烈建议你阅读这些内容的时候一个一个地尝试一下这些快捷键。&lt;/p&gt;

&lt;p&gt;Jupyter Notebook 提供了两种不同的键盘输入模式 - 命令和编辑。命令模式将键盘与 Notebook 命令绑定，并由具有蓝色左边距的带有灰色单元格边框来表示。编辑模式允许你将文本（或代码）输入活动单元格，并以绿色单元格边框表示。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;使用 Esc 和 Enter 在命令和编辑模式之间跳转。现在就试试吧！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;一旦进入命令模式（即没有活动单元格），就可以尝试以下快捷键：&lt;/p&gt;

&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;4&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;A 键将在选中单元格上方插入新单元格，B 键将在选中单元格下方插入一个单元格&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;要删除单元格，请连续按两次 D 键&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;要撤消已删除的单元格，请按 Z 键&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Y 键将当前的选中单元格变成代码单元格&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;按住 Shift + 向上或向下箭头键可以选择多个单元格。在多选模式下，按 Shift + M 会合并选中的单元格&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;F 键会弹出 “查找和替换” 菜单&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;处于编辑模式时（在命令模式下按 Enter 键进入编辑模式），你会发现以下快捷键非常好用：&lt;/p&gt;

&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Ctrl + Home 转到单元格的开头&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Ctrl + S 会保存你的工作&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;和上面提过的一样，Ctrl + Enter 将运行你的整个单元格&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Alt + Enter 不仅会运行你的单元格，它还会在下方添加一个新的单元格&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Ctrl + Shift + F 打开命令选项板&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;要查看整个键盘快捷键列表，请在命令模式下按 H 或转到 Help 菜单栏下的 Keyboard shortcuts。请经常检查这些内容，因为经常会有新的快捷键被加进来。&lt;/p&gt;

&lt;h2 class=&quot;ql-long-584640&quot;&gt; &lt;/h2&gt;
&lt;p&gt;&lt;span&gt;▌&lt;strong&gt;有用的 Jupyter Notebooks 扩展&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;扩展可以有效提高你的 Jupyter Notebooks 的生产力。安装和使用扩展的最佳工具之一是 Nbextensions。它需要两个简单的步骤来安装（也有其他方法，但我发现这是最方便的）：&lt;/p&gt;

&lt;p&gt;第1步：用 pip 来安装它：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
pip install jupyter_contrib_nbextensions
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1623928/201905/1623928-20190513232517931-27141277.png&quot; alt=&quot;&quot; width=&quot;761&quot; height=&quot;27&quot;/&gt;&lt;/p&gt;


&lt;p&gt;第2步：安装关联的 JavaScript 和 CSS 文件：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
jupyter contrib nbextension install --user
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1623928/201905/1623928-20190513232548680-233506782.png&quot; alt=&quot;&quot; width=&quot;765&quot; height=&quot;31&quot;/&gt;&lt;/p&gt;



&lt;p&gt;完成此操作后，你会在 Jupyter Notebook 主页顶部看到一个 Nbextensions 选项卡。这里面有很多非常棒的扩展供你使用。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180529192622512&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;要启用一个扩展，只需点击它来激活。我在下面提到了4个我认为最有用的扩展：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180529192637494&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;2&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Printview：这个扩展添加了一个工具栏按钮来调用当前 Notebook 的 jupyter nbconvert，并可选择在新的浏览器标签中显示转换后的文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;Scratchpad：这个扩展增加一个便捷单元格，它可以让你运行你的代码而不必修改你的 Notebook。这是一个非常方便的扩展，特别是当你想要测试你的代码，但不想在你的活动Notebook上做这件事。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Table of Contents (2)：这个扩展可以收集你的 Notebook 中的所有标题，并将它们显示在一个浮动窗口中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些只是你可以使用的其中一些扩展。我强烈建议查看整个扩展列表并对它们进行测试。&lt;/p&gt;

&lt;h2 class=&quot;ql-long-584640&quot;&gt; &lt;/h2&gt;
&lt;p&gt;&lt;span&gt;▌&lt;strong&gt;保存和共享你的 Notebook&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这是 Jupyter Notebook 中最重要和最棒的功能之一。当我需要写博客文章，但我的代码和注释都保存在 Jupyter 文件中时，我需要先将它们转换为另一种格式。请记住，这些 Notebooks 采用 json 格式，在共享它时这并不是很有帮助。我无法在电子邮件或博客上发布不同的单元格或代码块，对吧？&lt;/p&gt;

&lt;p&gt;进入 Files 菜单，你会看到一个 Download As 选项：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180529192649457&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;你可以将你的 Notebook 保存为 7 个选项中的任何一个。最常用的是 .ipynb 文件，这样其他人就可以在自己的机器上复制代码；或者保存为 .html 文件， 这样会打开一个网页（当你想要保存嵌入在 Notebook 中的图像时，这会派上用场）。&lt;/p&gt;

&lt;p&gt;你也可以使用 nbconvert 选项手动将你的 Notebook 转换为不同的格式，如 HTML 或 PDF。&lt;/p&gt;

&lt;p&gt;你还可以使用 jupyterhub，它允许你在其服务器上托管 Notebooks 并与多个用户共享。许多顶尖的研究项目都使用这个功能用于协作。&lt;/p&gt;

&lt;h2 class=&quot;ql-long-584640&quot;&gt; &lt;/h2&gt;
&lt;p&gt;&lt;span&gt;▌&lt;strong&gt;JupyterLab&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;JupyterLab 于今年 2 月推出，它允许以更灵活和更强大的方式处理项目，但使用的是和 Jupyter Notebooks 相同的组件。JupyterLab 环境与 Jupyter Notebooks 完全相同，但用户会有更高效的体验。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180529192703307&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在 JupyterLab 中，你只需一个窗口即可安排 Notebook 的工作区域、终端、文本文件和输出！你要做的仅仅是将单元格拖放到你想要的位置。你还可以通过实时预览功能来编辑常用文件格式，如 Markdown、CSV 和 JSON，以便在实际文件中实时查看所发生的变化。&lt;/p&gt;

&lt;p&gt;如果你想在你的机器上试用它，你可以在这里查看安装说明（地址：http://jupyterlab.readthedocs.io/en/stable/getting_started/installation.html）。 开发人员的目标是  JupyterLab 最终可以取代 Jupyter Notebooks。但是，要做到这一点还要花点时间。&lt;/p&gt;

&lt;h2 class=&quot;ql-long-584640&quot;&gt; &lt;/h2&gt;
&lt;p&gt;&lt;span&gt;▌&lt;strong&gt;最佳实践&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;虽然单独工作可能很有趣， 但大多数时候你会发现自己是在一个团队中工作。在这种情况下，遵循指导方针和最佳实践非常重要，这样可以确保你的代码和 Jupyter Notebooks 被正确标注，以便与你的团队成员保持一致。下面我列出了一些最佳实践指南，你在 Jupyter Notebooks 上工作时一定要遵循以下指南：&lt;/p&gt;

&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;7.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;对于任何程序员来说最重要的事情之一：始终确保为代码添加合适的注释！&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;确保你有代码所需的文档。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;考虑一个命名方案，并坚持在所有代码中使用以确保一致性。这样其他人更容易读懂你的代码。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;无论你需要什么库，在 Notebooks 开始时导入它们（并在它们旁边添加注释，说明导入它们的目的）。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;确保代码中行与行之间有适当间隔，不要把循环和函数放在同一行中。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;有时候你会发现你的文件变得非常繁重。看看有没有方法隐藏你认为对于以后参考不太重要的代码。 Notebooks 看起来整洁干净， 让人赏心悦目也非常重要。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;Matplotlib 可以很漂亮整洁地展示你的 Notebook，看看怎么使用它！&lt;/p&gt;
&lt;p&gt;地址：http://nbviewer.jupyter.org/github/jrjohansson/scientific-python-lectures/blob/master/Lecture-4-Matplotlib.ipynb&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另一个提示！ 当你想创建演示文稿时，首先想到的工具是 PowerPoint 和 Google Slides。其实你的 Jupyter Notebooks 也可以创建幻灯片！还记得我说它超级灵活吗？ 我一点都没有夸大。&lt;/p&gt;

&lt;p&gt;要将你的 Notebooks 转换为幻灯片，请转到  View -&amp;gt; Cell Toolbar，然后单击 Slideshow。看！现在，每个代码块都在右侧显示一个 Slide Type 的下拉选项。它提供了以下 5 个选项：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180529192711735&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;好好试一试每一个选项以更好地理解它，它会改变你呈现你的代码的方式！&lt;/p&gt;

&lt;h2 class=&quot;ql-long-584640&quot;&gt; &lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;▌结语&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;请注意，这篇文章并没有详尽列出 Jupyter Notebooks 提供的所有功能。还有更多的功能等着你在使用中挖掘。和其他很多事情一样，关键在于实践。&lt;/p&gt;

&lt;p&gt;最后分享一个 GitHub 库（地址：https://github.com/jupyter/jupyter/wiki/A-gallery-of-interesting-Jupyter-Notebooks），里面有很多有用的内容。&lt;/p&gt;

</description>
<pubDate>Mon, 13 May 2019 15:28:00 +0000</pubDate>
<dc:creator>JackPot</dc:creator>
<og:description>机器学习新手必看：Jupyter Notebook入门指南 翻译 | 张建军 出品 | 人工智能头条（公众号ID：AI_Thinker） 【人工智能头条导读】Jupyter Not</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Jack-X1/p/10859742.html</dc:identifier>
</item>
<item>
<title>线程池原理初探 - 木瓜芒果</title>
<link>http://www.cnblogs.com/volcano-liu/p/10783008.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/volcano-liu/p/10783008.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　在Java中，我们如果想同时做多件事情，则需要将不同事情以任务的形式抽象出来(即实现了Runnable接口的类)，将不同的任务交给线程来驱动，以完成同时执行多件事情的效果。创建任务很容易，new一个类就可以了，但是要跑起来还需要线程啊，线程可是稀缺资源啊，怎么获取呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　前面在&lt;a href=&quot;https://www.cnblogs.com/volcano-liu/p/10765247.html&quot; target=&quot;_blank&quot;&gt;Java线程机制&lt;/a&gt;一文中我们简单介绍了线程创建的几种方法，但这只是作为学习使用的，在生产环境中一般是不会直接通过新建线程来获取线程资源的。因为Java中的线程是和操作系统底层的线程挂钩的，创建线程是一个很消耗时间和资源的事情，如果频繁创建和销毁线程就可能会导致资源耗尽；而且如果创建了大量线程，也会导致线程之间的频繁切换，这也是很耗时间的操作。因此，JDK中提供了线程池来帮助我们获取和管理线程资源。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　有了线程池，我们无需直接创建线程，只需将需要执行的任务交给线程池就好了，线程池会帮我们分配线程来执行任务。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　使用线程池，有如下好处：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;线程池帮我们管理线程，使得我们无需关心这些细节，可以更专注于任务的实现，解耦；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;线程池通过统一管理创建的线程，实现线程的复用，避免线程的频繁创建和销毁，减少了在创建和销毁线程上所花的时间以及系统资源的开销，资源利用率更高；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;当需要执行大量的异步任务时，由线程池统一管理和调配线程资源，可以获得更好的性能；&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　&lt;span&gt;本文我们会从如下几个方面来进行总结：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;a href=&quot;http://www.cnblogs.com/volcano-liu/p/10783008.html#a&quot;&gt;Executor框架&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;a href=&quot;http://www.cnblogs.com/volcano-liu/p/10783008.html#b&quot;&gt;线程池使用&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;a href=&quot;http://www.cnblogs.com/volcano-liu/p/10783008.html#c&quot;&gt;线程池结构及状态&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;a href=&quot;http://www.cnblogs.com/volcano-liu/p/10783008.html#d&quot;&gt;总结&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;1. Executor框架&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;既然线程池这么好，我们就来看看JDK中提供了哪些线程池供我们使用吧。Java中提供线程池工具的是Executor框架，如下是其类图，我们看一下其基本组成：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1335887/201905/1335887-20190510214700767-1692093186.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;1.1 Eecutor&lt;/h3&gt;
&lt;p&gt;　　&lt;span&gt;处于最顶部的是Executor，这是一个基础接口，只定义了一个唯一方法execute()，用于提交任务：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; execute(Runnable command);
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;1.2 ExecutorService&lt;/h3&gt;
&lt;p&gt;　　&lt;span&gt;ExecutorService则提供了更多功能，包括service的管理功能如shutdown等方法，还包括不同于execute的更全面的提交任务机制，如返回Future的submit方法。因为Runnable是执行工作的独立任务，但是它不返回任何值，如果希望任务在完成时能够返回一个值，那么可以让任务实现Callable接口而不是Runnable接口，并且必须使用ExecutorService.submit()方法提交任务，看一个demo吧：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;// 定义一个带返回值的任务，实现Callable接口&lt;br/&gt;class&lt;/span&gt; TaskWithResult &lt;span&gt;implements&lt;/span&gt; Callable&amp;lt;String&amp;gt;&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; id;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; TaskWithResult(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.id =&lt;span&gt; id;
    }&lt;br/&gt;　　 // 这个就是提供返回值的方法，当获取返回值时实际会调用这个方法
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String call(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;result of TaskWithResult &quot; +&lt;span&gt; id;
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CallableDemo{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
        ExecutorService exec &lt;/span&gt;=&lt;span&gt; Executors.newCachedThreadPool();
        ArrayList&lt;/span&gt;&amp;lt;Futrue&amp;lt;String&amp;gt;&amp;gt; results = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Future&amp;lt;String&amp;gt;&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = 0; i&amp;lt;10 ; i++&lt;span&gt;){&lt;br/&gt;　　　　　　  // 提交任务之后会返回一个Future，可以通过它的get方法获取任务计算返回的结果
            results.add(exec.submit(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; TaskWithResult(i)));
        }
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(Future&amp;lt;String&amp;gt;&lt;span&gt; fs : results){
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用get()方法时必要的话(计算任务未完成)会阻塞&lt;/span&gt;
&lt;span&gt;                System.out.println(fs.get());
            }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(InterruptedException e){
                System.out.println(e);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(ExecutionExecution e){
                System.out.println(e);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;{
                exec.shutdown();
            }
        }
    }
}
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; output:
result of TaskWithResult 0
result of TaskWithResult 1
...
result of TaskWithResult 9
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;1.3 线程池实现&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　JDK提供了几种线程池基础实现，分别是ThreadPoolExecutor、ScheduledThreadPoolExecutor、ForkJoinPool。通过不同的构造参数，我们可以产生多种不同特性的线程池以满足复杂多变的实际应用场景。后面我们会进一步分析其构造函数部分源码，来剖析这个灵活性的源头。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;1.4 Executors　　&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　借助Executors提供的静态工厂方法，我们可以方便地创建出不同配置的线程池，Executors目前主要提供了如下几种不同的线程池创建方式：&lt;/span&gt;&lt;/p&gt;
&lt;ul data-source-line=&quot;22&quot; readability=&quot;8.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;span&gt;newCachedThreadPool()，它是一种用来处理大量短时间工作任务的线程池，它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程；如果线程闲置的时间超过60秒，则被终止并移出缓存；长时间闲置时，这种线程池，不会消耗什么资源。其内部使用 SynchronousQueue作为工作队列。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;span&gt;newFixedThreadPool(int nThreads)，重用指定数目(nThreads)的线程，其底层使用的是无界的工作队列，任何时候最多有nThreads个工作线程是活动的。这意味着，如果任务数量超过了活动队列数目，将在工作队列中等待空闲线程出现；如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数目 nThreads。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;span&gt;newSingleThreadExecutor()，它的特点在于工作线程数目被限制为1，操作一个无界的工作队列，所以它保证了所有任务的都是被顺序执行，最多会有一个任务处于活动状态，并且不允许使用者改动线程池实例，因此可以避免其改变线程数目。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;newSingleThreadScheduledExecutor()和newScheduledThreadPool(int corePoolSize)，创建的是一个ScheduledExecutorService，可以进行定时或周期性的工作调度，区别在于单一工作线程还是多个工作线程。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;newWorkStealingPool(int parallelism)，这是一个经常被人忽略的线程池，java8才加入这个创建方法，其内部会构建ForkJoin Pool，利用Work-Stealing算法，并行地处理任务，不保证处理顺序。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;2. 线程池使用&lt;/h2&gt;
&lt;p&gt; 　　&lt;span&gt;利用这些工厂方法，常见的线程池创建方式如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
ExecutorService threadPool1 =&lt;span&gt; Executors.newCachedThreadPool();
ExecutorService threadPool2 &lt;/span&gt;= Executors.newFixedThreadPool(10&lt;span&gt;);
ExecutorService threadPool3 &lt;/span&gt;=&lt;span&gt; Executors.newSingleThreadExecutor();
ExecutorService threadPool4 &lt;/span&gt;= Executors.newScheduledThreadPool(10&lt;span&gt;);
ExecutorService threadPool5 &lt;/span&gt;= Executors.newWorkStealingPool();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;在大多数应用场景下，使用Executors提供的静态工厂方法就足够了，但是仍然可能需要直接利用ThreadPoolExecutor等构造函数线程池创建(其实如上5种方式除了newWorkStealingPool之外，其余都是通过ThreadPoolExecutor类的构造函数来实现的)，比如：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
ExecutorService service = &lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor(1,1&lt;span&gt;,
                &lt;/span&gt;60L&lt;span&gt;,TimeUnit.SECONDS,
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; ArrayBlockingQueue&amp;lt;Runnable&amp;gt;(10));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　为什么需要这样做呢？因为这样做可以根据我们的实际使用场景灵活调整线程池参数。这需要对线程池构造方式有进一步的了解，需要明白线程池的设计和结构。因为大部分线程池的构造函数都是调用的ThreadPoolExecutor的构造器，所以在本文以及后面的原理分析的文章中我们都是针对ThreadPoolExecutor，JDK为1.8，我们先来看一下ThreadPoolExecutor的构造函数：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; ThreadPoolExecutor(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; corePoolSize,
                              &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; maximumPoolSize,
                              &lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt; keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue&lt;/span&gt;&amp;lt;Runnable&amp;gt;&lt;span&gt; workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (corePoolSize &amp;lt; 0 ||&lt;span&gt;
        maximumPoolSize &lt;/span&gt;&amp;lt;= 0 ||&lt;span&gt;
        maximumPoolSize &lt;/span&gt;&amp;lt; corePoolSize ||&lt;span&gt;
        keepAliveTime &lt;/span&gt;&amp;lt; 0&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalArgumentException();
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (workQueue == &lt;span&gt;null&lt;/span&gt; || threadFactory == &lt;span&gt;null&lt;/span&gt; || handler == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NullPointerException();
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.corePoolSize =&lt;span&gt; corePoolSize;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.maximumPoolSize =&lt;span&gt; maximumPoolSize;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.workQueue =&lt;span&gt; workQueue;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.keepAliveTime =&lt;span&gt; unit.toNanos(keepAliveTime);
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.threadFactory =&lt;span&gt; threadFactory;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.handler =&lt;span&gt; handler;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;当然ThreadPoolExecutor还有很多构造函数，但是底层也都是调用的这个构造函数，只是传的参数是默认参数而已，这里就不一一列出了，占空间。线程池的构造函数有一堆的参数，这个还是有必要看一下的：&lt;/span&gt;&lt;/p&gt;
&lt;ul data-source-line=&quot;99&quot; readability=&quot;6.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;corePoolSize：核心线程数量，常驻线程数量，包括空闲线程；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;maximumPoolSize：最大的线程数量，常驻+临时线程数量；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;workQueue：多余任务等待队列，此队列仅保持由 execute方法提交的 Runnable任务，必须是BlockingQueue；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;keepAliveTime：非核心线程空闲时间，即当线程数大于核心数时，多余的空闲线程等待新任务的最长时间；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;unit：keepAliveTime 参数的时间单位；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;threadFactory：执行程序创建新线程时使用的工厂，这里用到了抽象工厂模式，Executors提供了一个默认的线程工厂实现DefaultThreadFactory；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;handler：线程池拒绝策略，当任务实在是太多，没有空闲线程，等待队列也满了，如果还有任务怎么办？默认是不处理，抛出异常告诉任务提交者，我这忙不过来了，你提交了也处理不了；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　&lt;span&gt;通过配置不同的参数，我们就可以创建出行为特性各异的线程池，而这，就是线程池高度灵活性的基石。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;3. 线程池结构及状态&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;到这里我们知道线程的优点，学习了怎样创建线程池以及通过构造器部分的源码我们知道了线程池灵活性的根源，是时候再进一步了。我们可以把线程池理解成为一个容器，帮我们创建线程，接受我们提交给它的任务，并帮我们执行任务。那我们就有必要详细来看一下线程池内部是如何保存我们的任务以及线程，并通过什么方式来表征线程池自身的状态的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我们进入源码，首先映入眼帘的便是如下这一堆代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; AtomicInteger ctl = &lt;span&gt;new&lt;/span&gt; AtomicInteger(ctlOf(RUNNING, 0&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; COUNT_BITS = Integer.SIZE - 3&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 工作线程的理论上限，大约5亿多个线程&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; CAPACITY   = (1 &amp;lt;&amp;lt; COUNT_BITS) - 1&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; runState is stored in the high-order bits&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; RUNNING    = -1 &amp;lt;&amp;lt; COUNT_BITS; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;11100000000000000000000000000000&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; SHUTDOWN   =  0 &amp;lt;&amp;lt; COUNT_BITS; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; STOP       =  1 &amp;lt;&amp;lt; COUNT_BITS; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;00100000000000000000000000000000&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; TIDYING    =  2 &amp;lt;&amp;lt; COUNT_BITS; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;01000000000000000000000000000000&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; TERMINATED =  3 &amp;lt;&amp;lt; COUNT_BITS; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;01100000000000000000000000000000

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Packing and unpacking ctl&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; runStateOf(&lt;span&gt;int&lt;/span&gt; c)     { &lt;span&gt;return&lt;/span&gt; c &amp;amp; ~&lt;span&gt;CAPACITY; }
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; workerCountOf(&lt;span&gt;int&lt;/span&gt; c)  { &lt;span&gt;return&lt;/span&gt; c &amp;amp;&lt;span&gt; CAPACITY; }
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; ctlOf(&lt;span&gt;int&lt;/span&gt; rs, &lt;span&gt;int&lt;/span&gt; wc) { &lt;span&gt;return&lt;/span&gt; rs | wc; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　ctl，即线程池的控制状态，这是一个原子类，在这个整型数中封装了两层意思(限于表达能力，只能这样表达)：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;workerCount，即有效线程数量(也可以说是worker的数量)；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;runState，你线程池的运行状态；&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　我们来看一下Doug Lea大神是如何在一个整型变量中表达两层含义的呢？&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;3.1 线程数量&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　我们知道Java中的int型整数是32位的，在线程池中利用整型的高3位来表征线程池的运行状态，用剩下的低29位来表达有效线程数量，2的29次方是什么数量级，大概5亿吧，在目前以及未来很长一段时间，单机上是很难达到这个级别的线程数量的(即便未来存在问题，也可以通过Long类型来解决)，所以线程数量问题就满足了，多出来的高三位就可以用来表达线程池运行状态了。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;3.2 线程池状态&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　对照代码来看，上面COUNT_BITS实际为29，CAPACITY表示最大有效线程数量，大概是2的29次方。线程的状态和其对应的位的值如下：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;RUNNING：高三位为111，运行状态，可以接受任务执行队列里的任务；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;SHUTDOWN：高三位为000，指调用了 shutdown() 方法，不再接受新任务了，但是队列里的任务得执行完毕；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;STOP：高三位为001，指调用了 shutdownNow() 方法，不再接受新任务，同时抛弃阻塞队列里的所有任务并中断所有正在执行任务；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;TIDYING：高三位为010，所有任务都执行完毕，在调用 shutdown()/shutdownNow() 中都会尝试更新为这个状态；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;TERMINATED：高三位为011，终止状态，当执行 terminated() 后会更新为这个状态；&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　这些状态之间是会互相转变的，它们之间的转换时间如下：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;RUNNING -&amp;gt; SHUTDOWN，&lt;/span&gt;&lt;span&gt;调用线程池的shutdown()方法；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;(RUNNING or SHUTDOWN) -&amp;gt; STOP，&lt;/span&gt;&lt;span&gt;调用线程池的shutdownNow()方法时；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;SHUTDOWN -&amp;gt; TIDYING，&lt;/span&gt;&lt;span&gt;当任务队列和线程池(保存线程的一个hashSet)都为空时；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;STOP -&amp;gt; TIDYING，&lt;/span&gt;&lt;span&gt;当任务队列为空时；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;TIDYING -&amp;gt; TERMINATED，&lt;/span&gt;&lt;span&gt;调用线程池的terminated()方法并执行完毕之后；&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　说了这么多，还是上张图吧：&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1335887/201905/1335887-20190511113441853-1801685705.png&quot; alt=&quot;&quot;/&gt;&lt;/h2&gt;
&lt;h3&gt;3.3 为什么这么设计&lt;/h3&gt;
&lt;p&gt;　　&lt;span&gt;但是看上面那堆代码，因为一个整型变量表示两种含义，每次要使用的时候都要通过一些位运算来将需要的信息提取出来，为什么不直接用两个变量来表示？难道是节约空间？嗯，起先我也是这样认为的，后来才发现是自己too young了。。。一个整型总共才占用4个字节，两个才多了4个字节，为了这4个字节需要这么大费周章吗！后来才知道这是因为在多线程环境下，运行状态和有效线程数量往往需要保证统一，不能出现一个改而另一个没有改动的情况，如果将他们放在同一个AtmocInteger中，利用AtomicInteger的原子操作，就可以保证这两个值始终是统一的，嗯，对Doug大神并发的理解真是出神入化。后面我们在源码分析中可以有更直观的体会。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;3.4 线程池核心数据结构&lt;/h3&gt;
&lt;p&gt;　　&lt;span&gt;我们接着看源码，主要有两个地方需要注意：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;// 保存任务的阻塞队列&lt;br/&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; BlockingQueue&amp;lt;Runnable&amp;gt;&lt;span&gt; workQueue;
&lt;br/&gt;// 保存工作线程的set，即真正的池
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; HashSet&amp;lt;Worker&amp;gt; workers = &lt;span&gt;new&lt;/span&gt; HashSet&amp;lt;Worker&amp;gt;();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;对于这里，比较简单：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;工作队列负责存储用户提交的任务，容量可以指定，必须为BlockingQueue&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;这个works才是真正的“线程池”，用来保存工作线程的集合，原来所谓的线程池中的线程都是保存在一个HashSet中。线程池的工作线程被抽象为静态内部类Worker，是基于AQS实现，后面会详细分析其原理。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;4. 总结&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;1. 使用线程池有很多好处：&lt;/span&gt;&lt;/p&gt;
&lt;ul data-source-line=&quot;11&quot; readability=&quot;2&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;span&gt;解耦，用户不用关心线程的创建，只需提交任务即可；&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;2. JDK中Executor框架提供如ThreadPoolExecutor、ScheduledThreadPoolExecutor、ForkJoinPool等线程池的基本实现，可以通过Executors提供的静态工厂方法创建多种线程池，也可使用ThreadPoolExecutor提供的构造函数定制化符合业务需求的线程池；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3. 线程通过一个整型变量ctl表示存活线程数量和线程池运行状态；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4. 用户提交的任务是保存在一个阻塞队列中，线程池创建的工作线程是保存在一个HashSet中；&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　在本文中我们从线程池优点开始，再到了解整个Executor框架，通过一些加单demo了解了线程池的基本使用，再结合源码初步分析了线程池的内部数据结构以及状态表征，关于线程池进一步的运行原理，有兴趣的同学可以关注后面的文章。总结不易，觉得有帮助就点个赞吧^_^&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 13 May 2019 13:41:00 +0000</pubDate>
<dc:creator>木瓜芒果</dc:creator>
<og:description>Java线程池学习即原理初探</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/volcano-liu/p/10783008.html</dc:identifier>
</item>
<item>
<title>收到一个神盾局的offer，怎么样？ - mindwind</title>
<link>http://www.cnblogs.com/mindwind/p/10859102.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mindwind/p/10859102.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/815275/201905/815275-20190512190840936-1278687233.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;漫威十一年系列总结性的电影《复联4》正在热映，而衍生出的一部和漫威宇宙关联的美剧《神盾局特工》，今年我也在陆陆续续地看。一开始预期的是一部特工加一些科幻或魔幻元素的剧集，就图看得爽快，但实际制作水平和电影还是差距很大，一度差点弃剧。&lt;/p&gt;
&lt;p&gt;但慢慢看下来，吸引我的元素反而是另外一些东西，感觉更像一部职场剧。这个职场就是——神盾局（S.H.I.E.L.D=Strategic Homeland Intervention, Enforcement and Logistics Division 国土战略防御攻击与后勤保障局），故事就是围绕它的核心团队展开的。&lt;/p&gt;
&lt;p&gt;这么一想，神盾局算是一个国家事业单位吧，假如像剧中一些角色一样收到一个神盾局核心团队的 offer 邀约，怎么样？你会想加入吗？&lt;/p&gt;
&lt;h2 id=&quot;信念为什么来这里工作&quot;&gt;信念：为什么来这里工作？&lt;/h2&gt;
&lt;p&gt;首先在剧中，这个核心团队为神盾局工作的每一个成员，都有自己的基本信念，而且都还能和神盾局这个组织存在的意义有所关联。&lt;/p&gt;
&lt;p&gt;神盾局这份工作的目的有点保卫世界，拯救人类的意思，有一个很宏大的意义。核心团队成员，没人仅仅是来打一份工的，他们经历、能力和性格各异，但都会围绕在一个信念之下去协同战斗（他们的工作内容用“战斗”来描述是准确的，而非比喻了）。没有这份信念，这种战斗性和代价高昂的工作，可能很难干得下去。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;每一份工作，要做到最好，也许都要有超越工作本身之外的信念。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;架构组织是怎么运转和协作的&quot;&gt;架构：组织是怎么运转和协作的？&lt;/h2&gt;
&lt;p&gt;神盾局算是大单位（平台）了，采用了小团队+大平台的架构。&lt;/p&gt;
&lt;p&gt;剧中是一个 10 人左右的核心团队，团队中每个人都有自己的专业领域——一线特工、生物医疗专家、电子工程专家、软件黑客、机械工程师；当然还有漫威的特色：超能力英雄。所有角色背后组织都提供了最强有力的培养、支撑和保障，让他们在各自的专业领域中发挥到最好水平。&lt;/p&gt;
&lt;p&gt;组织提供的大平台就有点现在互联网流行的 “中台” 感觉了。提供各种平台能力，其中有执行任务需要的 “硬” 能力：各种飞行器，安全屋，弹药武器，卫星网络系统，紧急backup支援等等；也有 “软” 能力：信息处理、情报分析，甚至协调其他机构（军方、CIA等）协同支持的能力。而这个核心的小团队就依赖这样的平台支持去完成各种各样困难且艰险的任务。&lt;/p&gt;
&lt;p&gt;大组织的价值在于平台，平台的能力输出水平决定了组织中各个任务团队的起跑线，甚至也在一定程度上决定了他们所能达到的极限。&lt;/p&gt;
&lt;h2 id=&quot;变化这份工作稳定吗&quot;&gt;变化：这份工作稳定吗？&lt;/h2&gt;
&lt;p&gt;任何组织都可能会面临危机与变化，神盾局这么厉害的组织也差点因为死对头 “九头蛇” 这个恐怖组织的渗透而崩溃倒闭。&lt;/p&gt;
&lt;p&gt;这次巨变的剧情在漫威电影《美队2》中有所体现，经历灾难，困境反转，组织重建后，剧中原团队负责人也因此被质疑和降职，并派回一线去做外勤特工。原有团队成员也被打散，分配到不同的项目或任务中去了。&lt;/p&gt;
&lt;p&gt;团队中的成员也在变化，有些人在任务中牺牲了，也有人遭受重大打击，最后选择了离开。有人离开，也有新人加入。比如，正好收到 offer 的你，可能正在考虑是否要加入？需要去理解和适应这种变化，没有任何一份工作是所谓稳定的，不变的。&lt;/p&gt;
&lt;p&gt;学会接受变化，理解变化，在变化中可能告别，也可能继续前行，作为个体或团队都会是在演变中发展。&lt;/p&gt;
&lt;h2 id=&quot;形式日常都做些什么我该怎么工作&quot;&gt;形式：日常都做些什么，我该怎么工作？&lt;/h2&gt;
&lt;p&gt;与工作 offer 判断有关的一件重要内容是每日日常都在干嘛？&lt;/p&gt;
&lt;p&gt;剧中不会演日常，只会演非日常的紧急高光时刻。但既然团队中每个人都有自己的领域，日常我想都是在储备和磨练能力，是为每一次出任务时准备的。而每一次任务，大多数都是局长牵头负责的（毕竟是主演😂），而剧中的局长是寇森，就是电影《美队2》中被洛基一刀捅死的配角特工。而在剧中通过外星黑科技复活，并升职代理局长。&lt;/p&gt;
&lt;p&gt;局长大部分时候是中场指挥，远程命令，最重要的作用是全局把握，判断每位任务中的成员该做什么，分配不同特长的队员匹配不同特性的任务。而每位队员都站在全局任务中的一个局部点位上，可能会因为信息差而质疑局长的命令，总是会提出质疑，但局长只有两种应答：要么提供信息让对方理解；要么说这是保密信息（对方级别还不够，暂时不能知道）。&lt;/p&gt;
&lt;p&gt;队员会理解自己掌握的信息差异，并保留疑问但接受命令，坚决执行。而一线外勤的特工，因为临场变化很快，会有更多的自我决策空间，在协议（任务之前会为可能发生的情况做设计预案，预定预案在剧中叫协议：Protocol）框架范围内灵活选择合适的执行方式。&lt;/p&gt;
&lt;p&gt;在复杂任务中，决策有时会集中，有时会分散；一开始集中决策好任务的执行框架，而实际的执行中，更多是分散的，它们同时发生，同时变化，这就是一个智能的知识工作者需要面临的大部分日常。&lt;/p&gt;
&lt;h2 id=&quot;决断我该接受这个-offer吗&quot;&gt;决断：我该接受这个 offer吗？&lt;/h2&gt;
&lt;p&gt;到了这里，是到决断的时候了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;神盾局&lt;/strong&gt;&lt;br/&gt;知名全球化事业单位；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;待遇&lt;/strong&gt;&lt;br/&gt;薪酬不详；核心团队都在 “玩命”，感觉都不差钱的样子，组织福利超乎想象；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;办公环境&lt;/strong&gt;&lt;br/&gt;主要办公区为超大型空中指挥机，上班通勤主要是小型喷气机；&lt;br/&gt;提供全球免费旅行，小型飞机还带有火箭喷射发动机，偶尔也会去太空办公或公费旅行；&lt;br/&gt;所有飞机都自带隐身功能，非常注重隐私保护。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其他福利&lt;/strong&gt;&lt;br/&gt;能最早或唯一接触外星文明的机构；&lt;br/&gt;对于技术岗位，这里的 “黑科技” 数不胜数；&lt;br/&gt;重要岗位的核心成员，若因公殉职，死亡时间不长，提供一次复活重生机会（稀缺资源）；&lt;/p&gt;
&lt;p&gt;哈哈，以上看上去都挺吸引你的，但更重要的是：它提供的是独一无二的生命（人生）体验，但遗憾的是这只是一份假想的 offer 和虚构的组织，而真实的职业选择，也不妨可以这样来考虑考虑。&lt;/p&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;p&gt;《神盾局》这个剧拍了好几季了，还没看完，有空就会看上几集，陆续看了好几个月了。看过不少美剧后，发现有个编剧架构模式，一般都会有一条或明或暗的主线贯穿全剧，但中间经常游离出来讲一些主线之外的独立故事。&lt;/p&gt;
&lt;p&gt;这个模式就和人生道路非常类似了，人生如剧集，自己就是编剧兼主演，不要忘记自己的主线。如果我们的人生只有一些游离的独立故事组合，那么这样的剧看起来也没什么意思，剧的吸引力就在于有一条贯穿始终的主线。&lt;/p&gt;
&lt;p&gt;这条线的质量，决定了整部剧的吸引力。有时我们确实会因为各种原因，被迫要去 “演” 一些独立的故事，但别忘了我们自己的主线。人生的结局都是一样的，但过程是可以努力去选择的。&lt;/p&gt;
&lt;p&gt;神盾局的 offer，我也想收一个呀:)&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;写点文字，画点画儿，记录成长瞬间。&lt;br/&gt;微信公众号「瞬息之间」，既然遇见，不如同行。&lt;br/&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/815275/201602/815275-20160216164606173-1251141402.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 13 May 2019 13:23:00 +0000</pubDate>
<dc:creator>mindwind</dc:creator>
<og:description>漫威十一年系列总结性的电影《复联4》正在热映，而衍生出的一部和漫威宇宙关联的美剧《神盾局特工》，今年我也在陆陆续续地看。一开始预期的是一部特工加一些科幻或魔幻元素的剧集，就图看得爽快，但实际制作水平和</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mindwind/p/10859102.html</dc:identifier>
</item>
<item>
<title>ES(Elastic Search)update操作设置无 docment时进行insert - LinkLee</title>
<link>http://www.cnblogs.com/sunlightlee/p/10858556.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sunlightlee/p/10858556.html</guid>
<description>&lt;p&gt;&lt;span&gt;今日阅读公司一套数据加工中间工具的源码，查看es操作中的update操作。其中方法命名为updateOrInsert。但是没见到代码中有ES的insert方法调用。于是仔细分析了代码逻辑。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;经过一路追溯，直至ES java客户端请求发送代码。没找到insert相关内容。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;于是到官网查看究竟，可官网对 java Client相关说明比较少。查看不到具体api的说明。于是回到代码调用处：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;String jsonText =&lt;span&gt; jsonBuild.endObject().string();
                UpdateRequest request &lt;/span&gt;= (UpdateRequest)esClient.prepareUpdate(xxx.getDatabase(), xxx.getTable(), docId).setDoc(jsonText).&lt;span&gt;setDetectNoop&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;).&lt;span&gt;setDocAsUpsert&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;).setRetryOnConflict(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.retryOnConflict).request();
                esClient.update(request).get();&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;代码中属于链式调用，由于太长没有换行，竟然没看到后边的setDetectNoop,setDocAsUpsert参数的调用，于是思考，javaClient不就是封装和转换了调用请求么，于是再回到官网查看&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/2.1/docs.html&quot;&gt;Document APIs&lt;/a&gt;，找到update操作的说明，就有了下边关于 Detecting Noop Updates 以及 Upserts说明：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;h3&gt;&lt;span&gt;Detecting noop updatesedit&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;If &lt;code class=&quot;literal&quot;&gt;doc&lt;/code&gt; is specified its value is merged with the existing &lt;code class=&quot;literal&quot;&gt;_source&lt;/code&gt;. By default the document is only reindexed if the new &lt;code class=&quot;literal&quot;&gt;_source&lt;/code&gt; field differs from the old. Setting &lt;code class=&quot;literal&quot;&gt;detect_noop&lt;/code&gt; to &lt;code class=&quot;literal&quot;&gt;false&lt;/code&gt; will cause Elasticsearch to always update the document even if it hasn’t changed. For example:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;pre_wrapper&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;programlisting prettyprint lang-js&quot;&gt;
&lt;span&gt;curl -XPOST 'localhost:9200/test/type1/1/_update' -d '{
    &quot;doc&quot; : {
        &quot;name&quot; : &quot;new_name&quot;
    },
    &quot;detect_noop&quot;: false
}'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;上边这段的意思是当更新的文档发生变化时进行更新，如果为fasle,则始终更新。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;25&quot;&gt;
&lt;h3&gt;&lt;span&gt;Upsertsedit&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;If the document does not already exist, the contents of the &lt;code class=&quot;literal&quot;&gt;upsert&lt;/code&gt; element will be inserted as a new document. If the document does exist, then the &lt;code class=&quot;literal&quot;&gt;script&lt;/code&gt; will be executed instead:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;pre_wrapper&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;programlisting prettyprint lang-js&quot;&gt;
&lt;span&gt;curl -XPOST 'localhost:9200/test/type1/1/_update' -d '{
    &quot;script&quot; : {
        &quot;inline&quot;: &quot;ctx._source.counter += count&quot;,
        &quot;params&quot; : {
            &quot;count&quot; : 4
        }
    },
    &quot;upsert&quot; : {
        &quot;counter&quot; : 1
    }
}'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;&lt;span&gt;&lt;code class=&quot;literal&quot;&gt;scripted_upsert&lt;/code&gt;edit&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;If you would like your script to run regardless of whether the document exists or not — i.e. the script handles initializing the document instead of the &lt;code class=&quot;literal&quot;&gt;upsert&lt;/code&gt; element — then set &lt;code class=&quot;literal&quot;&gt;scripted_upsert&lt;/code&gt; to &lt;code class=&quot;literal&quot;&gt;true&lt;/code&gt;:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;pre_wrapper&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;programlisting prettyprint lang-js&quot;&gt;
&lt;span&gt;curl -XPOST 'localhost:9200/sessions/session/dh3sgudg8gsrgl/_update' -d '{
    &quot;scripted_upsert&quot;:true,
    &quot;script&quot; : {
        &quot;id&quot;: &quot;my_web_session_summariser&quot;,
        &quot;params&quot; : {
            &quot;pageViewEvent&quot; : {
                &quot;url&quot;:&quot;foo.com/bar&quot;,
                &quot;response&quot;:404,
                &quot;time&quot;:&quot;2014-01-01 12:32&quot;
            }
        }
    },
    &quot;upsert&quot; : {}
}'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;&lt;span&gt;&lt;strong&gt;&lt;code class=&quot;literal&quot;&gt;doc_as_upsert&lt;/code&gt;edit&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Instead of sending a partial &lt;code class=&quot;literal&quot;&gt;doc&lt;/code&gt; plus an &lt;code class=&quot;literal&quot;&gt;upsert&lt;/code&gt; doc, setting &lt;code class=&quot;literal&quot;&gt;doc_as_upsert&lt;/code&gt; to &lt;code class=&quot;literal&quot;&gt;true&lt;/code&gt; will use the contents of &lt;code class=&quot;literal&quot;&gt;doc&lt;/code&gt; as the &lt;code class=&quot;literal&quot;&gt;upsert&lt;/code&gt; value:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;pre_wrapper&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;programlisting prettyprint lang-js&quot;&gt;
&lt;span&gt;&lt;strong&gt;curl -XPOST 'localhost:9200/test/type1/1/_update' -d '{
    &quot;doc&quot; : {
        &quot;name&quot; : &quot;new_name&quot;
    },
    &quot;doc_as_upsert&quot; : true
}'&lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;　　上边描述：upsert参数的使用，有三种方式：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;指定upsert内容&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;指定打开脚本upsert开关使用脚本处理upsert&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;使用文档内容做为upsert参数，则打开 doc_as_upsert。显然我们上边所说的javaClient调用中就是使用的 doc_as_upsert，这样当文档不存在时候，就会将传递过来的文档内容insert进去。达到update or Insert 目的。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;　　因此对于ES java Clent使用不熟的完全可以参照 api命名查找官网的 api说明，java客户端只不过是用java语言进行了封装。一看便知道调用代码逻辑的含义了。仅此记录，为不熟悉ES的其他使用者 引个路子。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;官网内容链接：&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/2.1/docs-update.html#upserts&quot;&gt;https://www.elastic.co/guide/en/elasticsearch/reference/2.1/docs-update.html#upserts&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以根据自己使用的ES版本进行切换查看。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 13 May 2019 11:33:00 +0000</pubDate>
<dc:creator>LinkLee</dc:creator>
<og:description>今日阅读公司一套数据加工中间工具的源码，查看es操作中的update操作。其中方法命名为updateOrInsert。但是没见到代码中有ES的insert方法调用。于是仔细分析了代码逻辑。 经过一路追</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sunlightlee/p/10858556.html</dc:identifier>
</item>
<item>
<title>SmartSql使用教程（1）——初探，建立一个简单的CURD接口服务 - Noah.Ji</title>
<link>http://www.cnblogs.com/noahji/p/10846215.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/noahji/p/10846215.html</guid>
<description>&lt;p&gt;&lt;span&gt;最近SmartSql被正式引入到了NCC，借着这个契机写一个使用教程系列&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;&lt;strong&gt;1. SmartSql是什么？&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;SmartSql = MyBatis + Cache(Memory | Redis) + R/W Splitting +Dynamic Repository + Diagnostics ......&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;2. SmartSql的特性&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;简洁、高效、高性能、扩展性、监控、渐进式开发！&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;3. 她是如何工作的？&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　SmartSql 借鉴了 MyBatis 的思想，使用 XML 来管理 SQL ，并且提供了若干个筛选器标签来消除代码层面的各种 if/else 的判断分支。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　SmartSql将管理你的 SQL ，并且通过筛选标签来维护本来你在代码层面的各种条件判断，使你的代码更加优美。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;4. 为什么选择SmartSql？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　DotNet 体系下大都是 Linq 系的 ORM，Linq 很好，消除了开发人员对 SQL 的依赖。 但却忽视了一点，SQL 本身并不复杂，而且在复杂查询场景当中开发人员很难通过编写Linq来生成良好性能的SQL，相信使用过EF的同学一定有这样的体验：“我想好了Sql怎么写，然后再来写Linq,完了可能还要再查看一下Linq输出的Sql是什么样的“。这是非常糟糕的体验。要想对Sql做绝对的优化，那么开发者必须对Sql有绝对的控制权。另外Sql本身很简单，为何要增加一层翻译器呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　知道了SmartSql是什么，那接下来我们开始创建一个项目从0开始使用SmartSql写一个简单的CURD接口服务。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　先上一个项目结构，然后我们一一分析他们的作用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/572600/201905/572600-20190510191648766-1323281581.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;1. 创建DB&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　这里我用的DB是MSSql，直接贴脚本了。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('bdf5e69b-fd41-4487-b7af-b178075e7012')&quot; readability=&quot;36&quot;&gt;&lt;span&gt;&lt;img id=&quot;code_img_closed_bdf5e69b-fd41-4487-b7af-b178075e7012&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_bdf5e69b-fd41-4487-b7af-b178075e7012&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('bdf5e69b-fd41-4487-b7af-b178075e7012',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;
&lt;div id=&quot;cnblogs_code_open_bdf5e69b-fd41-4487-b7af-b178075e7012&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;Create&lt;/span&gt; &lt;span&gt;Database&lt;/span&gt;&lt;span&gt; SmartSqlSample
&lt;/span&gt;&lt;span&gt;GO&lt;/span&gt;
&lt;span&gt;Use&lt;/span&gt;&lt;span&gt; SmartSqlSample
&lt;/span&gt;&lt;span&gt;GO&lt;/span&gt;
&lt;span&gt;Create&lt;/span&gt; &lt;span&gt;Table&lt;/span&gt;&lt;span&gt; T_Article (
    Id &lt;/span&gt;&lt;span&gt;bigint&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; &lt;span&gt;null&lt;/span&gt; &lt;span&gt;primary&lt;/span&gt; &lt;span&gt;key&lt;/span&gt; &lt;span&gt;identity&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;&lt;span&gt;),
    Title &lt;/span&gt;&lt;span&gt;nvarchar&lt;/span&gt;(&lt;span&gt;255&lt;/span&gt;) &lt;span&gt;not&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;,
    Content &lt;/span&gt;&lt;span&gt;nvarchar&lt;/span&gt;(&lt;span&gt;max&lt;/span&gt;) &lt;span&gt;null&lt;/span&gt;&lt;span&gt;,
    Author &lt;/span&gt;&lt;span&gt;nvarchar&lt;/span&gt;(&lt;span&gt;255&lt;/span&gt;) &lt;span&gt;null&lt;/span&gt;&lt;span&gt;,
    Status &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;,
    CreateTime &lt;/span&gt;&lt;span&gt;datetime&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; &lt;span&gt;null&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; &lt;span&gt;getdate&lt;/span&gt;&lt;span&gt;(),
    ModifiedTime &lt;/span&gt;&lt;span&gt;datetime&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; &lt;span&gt;null&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; &lt;span&gt;getdate&lt;/span&gt;&lt;span&gt;()
)&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;Init脚本&lt;/span&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;2. SmartSql 基础配置&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;2.1 添加Nuget依赖&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　SmartSql的库可以直接在Nuget上找到，但因为.NetCoreMVC的项目现在自带了DI依赖注入的关系，我们只需要直接引用SmartSql.DI.Extension就可以了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　项目的依赖性包括了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1. AspNetCore基础库&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2. SmartSql.DI.Extension（我们的主角）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3. Swashbuckle.AspNetCore（方便我们接口测试）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/572600/201905/572600-20190510192412317-1064447078.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2.2 添加SmartSql配置文件&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　SmartSql是一个基于Xml配置的ORM。这点和Mybatis没有什么不同。如果你熟悉Mybatis，相信你很快就能适应SmartSql。如果你以前没接触过类似的ORM。那请跟着这个教程，一步一步了解SmartSql的强大。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;&lt;strong&gt;SmartSqlMapConfig.xml，SmartSql的起点。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; &lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;&amp;lt;!--&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;//*******************************
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;// Create By Noah.Ji
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;// Date 2019-05-10
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;// Github : https://github.com/noahjzc/SmartSqlSample
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;//*******************************&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;SmartSqlMapConfig &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://SmartSql.net/schemas/SmartSqlMapConfig.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;   &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 允许使用缓存（以后章节细讲） &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Settings &lt;/span&gt;&lt;span&gt;IsCacheEnabled&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;   &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 属性、特性配置节点，这里只配置一个连接字符串 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Properties&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Property &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;ConnectionString&quot;&lt;/span&gt;&lt;span&gt; Value&lt;/span&gt;&lt;span&gt;=&quot;Data Source=localhost;database=SmartSqlSample;uid=sa;pwd=123456&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Property &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;ReadOneConnectionString&quot;&lt;/span&gt;&lt;span&gt; Value&lt;/span&gt;&lt;span&gt;=&quot;Data Source=123.123.123.123;database=SmartSqlSample;uid=sa;pwd=123456&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;   &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Properties&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;   &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 数据库配置 Start &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Database&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;DbProvider &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;SqlServer&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Write &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;Sample-Write&quot;&lt;/span&gt;&lt;span&gt; ConnectionString&lt;/span&gt;&lt;span&gt;=&quot;${ConnectionString}&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 多读节点配置 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;&amp;lt;!--&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    &amp;lt;Read Name=&quot;Sample-Node-1&quot; ConnectionString=&quot;${ReadOneConnectionString}&quot; Weight=&quot;60&quot;/&amp;gt;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    &amp;lt;Read Name=&quot;Sample-Node-2&quot; ConnectionString=&quot;Data Source=456.456.456.456;database=SmartSqlSample;uid=sa;pwd=123456&quot; Weight=&quot;40&quot;/&amp;gt;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;   &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Database&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;   &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 数据库配置 End &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;   &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 数据Map配置 Start &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;SmartSqlMaps&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 文件夹 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;SmartSqlMap &lt;/span&gt;&lt;span&gt;Path&lt;/span&gt;&lt;span&gt;=&quot;Maps&quot;&lt;/span&gt;&lt;span&gt; Type&lt;/span&gt;&lt;span&gt;=&quot;Directory&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;SmartSqlMap&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 文件夹及子集（递归获取文件夹下所有Map文件） &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;&amp;lt;SmartSqlMap Path=&quot;Maps&quot; Type=&quot;DirectoryWithAllSub&quot;&amp;gt;&amp;lt;/SmartSqlMap&amp;gt;&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt;     &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 单个文件 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;&amp;lt;SmartSqlMap Path=&quot;Maps/T_Article.xml&quot; Type=&quot;File&quot;&amp;gt;&amp;lt;/SmartSqlMap&amp;gt;&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt;     &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 嵌入式资源 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;     &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;&amp;lt;SmartSqlMap Path=&quot;SmartSqlSampleChapterOne.Maps.T_Article.xml, SmartSqlSampleChapterOne&quot; Type=&quot;Embedded&quot;&amp;gt;&amp;lt;/SmartSqlMap&amp;gt;&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt; 
&lt;span&gt;41&lt;/span&gt;     &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; http资源 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt;     &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;&amp;lt;SmartSqlMap Type=&quot;Uri&quot; Path=&quot;https://smartsql.net/Maps/T_Article.xml&quot; /&amp;gt;&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt;   &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;SmartSqlMaps&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt;   &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 数据Map配置 End &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;SmartSqlMapConfig&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;2.3 表Map配置&lt;/span&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;span&gt;2.3.1 Root节点&lt;/span&gt;&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;1&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;SmartSqlMap &lt;/span&gt;&lt;span&gt;Scope&lt;/span&gt;&lt;span&gt;=&quot;Article&quot;&lt;/span&gt;&lt;span&gt; xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://SmartSql.net/schemas/SmartSqlMap.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;...
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;SmartSqlMap&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这里的关键在于Scope，这个属性是用于定位Map的。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;2.3.2 CUD配置&lt;/span&gt;&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('89000931-3016-4ead-8784-22bc717ec879')&quot; readability=&quot;40&quot;&gt;&lt;span&gt;&lt;img id=&quot;code_img_closed_89000931-3016-4ead-8784-22bc717ec879&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_89000931-3016-4ead-8784-22bc717ec879&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('89000931-3016-4ead-8784-22bc717ec879',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;
&lt;div id=&quot;cnblogs_code_open_89000931-3016-4ead-8784-22bc717ec879&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;75&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;新增&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Statement &lt;/span&gt;&lt;span&gt;Id&lt;/span&gt;&lt;span&gt;=&quot;Insert&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  INSERT INTO T_Article
  (Title
  ,Content
  ,Author
  ,Status
  ,CreateTime
  ,ModifiedTime
  )
  VALUES
  (@Title
  ,@Content
  ,@Author
  ,@Status
  ,@CreateTime
  ,GetDate()
  );
  SELECT Scope_Identity();
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Statement&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;删除&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Statement &lt;/span&gt;&lt;span&gt;Id&lt;/span&gt;&lt;span&gt;=&quot;Delete&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  DELETE T_Article WHERE Id = @Id
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Statement&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;更新&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Statement &lt;/span&gt;&lt;span&gt;Id&lt;/span&gt;&lt;span&gt;=&quot;Update&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  UPDATE T_Article
  &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Set&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    ModifiedTime = GetDate()
    &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;IsProperty &lt;/span&gt;&lt;span&gt;Prepend&lt;/span&gt;&lt;span&gt;=&quot;,&quot;&lt;/span&gt;&lt;span&gt; Property&lt;/span&gt;&lt;span&gt;=&quot;Title&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
      Title = @Title
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;IsProperty&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;IsProperty &lt;/span&gt;&lt;span&gt;Prepend&lt;/span&gt;&lt;span&gt;=&quot;,&quot;&lt;/span&gt;&lt;span&gt; Property&lt;/span&gt;&lt;span&gt;=&quot;Content&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
      Content = @Content
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;IsProperty&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;IsProperty &lt;/span&gt;&lt;span&gt;Prepend&lt;/span&gt;&lt;span&gt;=&quot;,&quot;&lt;/span&gt;&lt;span&gt; Property&lt;/span&gt;&lt;span&gt;=&quot;Author&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
      Author = @Author
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;IsProperty&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;IsProperty &lt;/span&gt;&lt;span&gt;Prepend&lt;/span&gt;&lt;span&gt;=&quot;,&quot;&lt;/span&gt;&lt;span&gt; Property&lt;/span&gt;&lt;span&gt;=&quot;Status&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
      Status = @Status
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;IsProperty&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;IsProperty &lt;/span&gt;&lt;span&gt;Prepend&lt;/span&gt;&lt;span&gt;=&quot;,&quot;&lt;/span&gt;&lt;span&gt; Property&lt;/span&gt;&lt;span&gt;=&quot;CreateTime&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
      CreateTime = @CreateTime
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;IsProperty&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Set&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  Where id=@Id
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Statement&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;CUD配置&lt;/span&gt;&lt;/div&gt;
&lt;h4&gt;&lt;span&gt;2.3.3 通用查询节点&lt;/span&gt;&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('26ba8fdc-a6ee-4028-b732-8c24c6630c16')&quot; readability=&quot;32.5&quot;&gt;&lt;span&gt;&lt;img id=&quot;code_img_closed_26ba8fdc-a6ee-4028-b732-8c24c6630c16&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_26ba8fdc-a6ee-4028-b732-8c24c6630c16&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('26ba8fdc-a6ee-4028-b732-8c24c6630c16',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;
&lt;div id=&quot;cnblogs_code_open_26ba8fdc-a6ee-4028-b732-8c24c6630c16&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Statement &lt;/span&gt;&lt;span&gt;Id&lt;/span&gt;&lt;span&gt;=&quot;QueryParams&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Where&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;IsGreaterEqual &lt;/span&gt;&lt;span&gt;Prepend&lt;/span&gt;&lt;span&gt;=&quot;And&quot;&lt;/span&gt;&lt;span&gt; Property&lt;/span&gt;&lt;span&gt;=&quot;Id&quot;&lt;/span&gt;&lt;span&gt; CompareValue&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
      T.Id = @Id
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;IsGreaterEqual&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;IsNotEmpty &lt;/span&gt;&lt;span&gt;Prepend&lt;/span&gt;&lt;span&gt;=&quot;And&quot;&lt;/span&gt;&lt;span&gt; Property&lt;/span&gt;&lt;span&gt;=&quot;Title&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
      T.Title Like '%'+@Title+'%'
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;IsNotEmpty&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;IsNotEmpty &lt;/span&gt;&lt;span&gt;Prepend&lt;/span&gt;&lt;span&gt;=&quot;And&quot;&lt;/span&gt;&lt;span&gt; Property&lt;/span&gt;&lt;span&gt;=&quot;Ids&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
      T.Id IN @Ids
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;IsNotEmpty&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Where&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Statement&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;通用查询节点&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这个Statement节点其实和别的节点没什么区别。SmartSql允许Statement的嵌套。使用规则如下面这段配置&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('3558b164-01a3-4a8c-93b4-70b8d1148d1e')&quot; readability=&quot;32&quot;&gt;&lt;span&gt;&lt;img id=&quot;code_img_closed_3558b164-01a3-4a8c-93b4-70b8d1148d1e&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_3558b164-01a3-4a8c-93b4-70b8d1148d1e&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('3558b164-01a3-4a8c-93b4-70b8d1148d1e',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;
&lt;div id=&quot;cnblogs_code_open_3558b164-01a3-4a8c-93b4-70b8d1148d1e&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Statement &lt;/span&gt;&lt;span&gt;Id&lt;/span&gt;&lt;span&gt;=&quot;Query&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  SELECT T.* FROM T_Article T
  &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Include &lt;/span&gt;&lt;span&gt;RefId&lt;/span&gt;&lt;span&gt;=&quot;QueryParams&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Switch &lt;/span&gt;&lt;span&gt;Prepend&lt;/span&gt;&lt;span&gt;=&quot;Order By&quot;&lt;/span&gt;&lt;span&gt; Property&lt;/span&gt;&lt;span&gt;=&quot;OrderBy&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Default&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
      T.id Desc
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Default&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Switch&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;IsNotEmpty &lt;/span&gt;&lt;span&gt;Prepend&lt;/span&gt;&lt;span&gt;=&quot;Limit&quot;&lt;/span&gt;&lt;span&gt; Property&lt;/span&gt;&lt;span&gt;=&quot;Taken&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;@Taken&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;IsNotEmpty&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Statement&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;Query&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;在这段Query配置中。我们使用了Include标签来引入上面定义好的Id为QueryParams的Statement，这样就做到了查询配置的通用性。例如我还可以将QueryParams配置到分页和查询结果数的配置中。如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('2bfc1a6d-d3f7-4832-9267-010115cd3389')&quot; readability=&quot;32.5&quot;&gt;&lt;span&gt;&lt;img id=&quot;code_img_closed_2bfc1a6d-d3f7-4832-9267-010115cd3389&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_2bfc1a6d-d3f7-4832-9267-010115cd3389&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('2bfc1a6d-d3f7-4832-9267-010115cd3389',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;
&lt;div id=&quot;cnblogs_code_open_2bfc1a6d-d3f7-4832-9267-010115cd3389&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;获取分页数据&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Statement &lt;/span&gt;&lt;span&gt;Id&lt;/span&gt;&lt;span&gt;=&quot;QueryByPage&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  SELECT T.* FROM T_Article As T
  &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Include &lt;/span&gt;&lt;span&gt;RefId&lt;/span&gt;&lt;span&gt;=&quot;QueryParams&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Switch &lt;/span&gt;&lt;span&gt;Prepend&lt;/span&gt;&lt;span&gt;=&quot;Order By&quot;&lt;/span&gt;&lt;span&gt; Property&lt;/span&gt;&lt;span&gt;=&quot;OrderBy&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Default&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
      T.Id Desc
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Default&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Switch&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  Offset ((@PageIndex-1)*@PageSize) Rows Fetch Next @PageSize Rows Only;
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Statement&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;获取记录数&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Statement &lt;/span&gt;&lt;span&gt;Id&lt;/span&gt;&lt;span&gt;=&quot;GetRecord&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  SELECT Count(1) FROM T_Article T
  &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Include &lt;/span&gt;&lt;span&gt;RefId&lt;/span&gt;&lt;span&gt;=&quot;QueryParams&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Statement&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;分页及结果数查询&lt;/span&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;2.4 Startup&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;注入SmartSql&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; register smartsql&lt;/span&gt;
services.AddSmartSql(builder =&amp;gt;&lt;span&gt;
{
    builder.UseAlias(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SmartSqlSampleChapterOne&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义实例别名，在多库场景下适用。
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;.UseXmlConfig(ResourceType.File,&quot;MyConfig.xml&quot;);&lt;/span&gt;
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;在2.2中我们把基础配置文件命名为SmartSqlMapConfig。这个是默认文件名，我们也可以像上面的注释代码一样。自定义配置文件的名称。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;3. 让配置工作起来&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;其实到了这一步一切都顺其自然了。我感觉没有什么可以多讲了。直接上代码了！&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('430ee561-0c5a-453a-827e-ebcc1094fc0c')&quot; readability=&quot;40.5&quot;&gt;&lt;span&gt;&lt;img id=&quot;code_img_closed_430ee561-0c5a-453a-827e-ebcc1094fc0c&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_430ee561-0c5a-453a-827e-ebcc1094fc0c&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('430ee561-0c5a-453a-827e-ebcc1094fc0c',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;
&lt;div id=&quot;cnblogs_code_open_430ee561-0c5a-453a-827e-ebcc1094fc0c&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;76&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.DependencyInjection;
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; SmartSql;
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; SmartSqlSampleChapterOne.Entity;
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; 
&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; SmartSqlSampleChapterOne.DataAccess
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 10&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; 
&lt;span&gt; 11&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 12&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ArticleDataAccess
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; ISqlMapper _sqlMapper;
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt; 
&lt;span&gt; 16&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 17&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; 
&lt;span&gt; 18&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 19&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;sp&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 20&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ArticleDataAccess(IServiceProvider sp)
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt;             _sqlMapper = sp.GetSmartSql(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SmartSqlSampleChapterOne&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).SqlMapper;
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt; 
&lt;span&gt; 25&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 26&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Insert
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 28&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;article&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 29&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt; 30&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; Insert(T_Article article)
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; _sqlMapper.ExecuteScalar&amp;lt;&lt;span&gt;long&lt;/span&gt;&amp;gt;(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; RequestContext
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt;                 Scope = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Article&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt;                 SqlId = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Insert&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt;                 Request =&lt;span&gt; article
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt; &lt;span&gt;            });
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt; 
&lt;span&gt; 40&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 41&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Update
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 43&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;article&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 44&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt; 45&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; Update(T_Article article)
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; _sqlMapper.Execute(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; RequestContext
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt;                 Scope = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Article&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt;                 SqlId = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Update&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt;                 Request =&lt;span&gt; article
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt; &lt;span&gt;            });
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt; 
&lt;span&gt; 55&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 56&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; DyUpdate
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 58&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;updateObj&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 59&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt; 60&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DyUpdate(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; updateObj)
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; _sqlMapper.Execute(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; RequestContext
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt;                 Scope = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Article&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt;                 SqlId = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Update&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt;                 Request =&lt;span&gt; updateObj
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt; &lt;span&gt;            });
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt; 
&lt;span&gt; 70&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 71&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Delete
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 73&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;id&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 74&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt; 75&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Delete(&lt;span&gt;long&lt;/span&gt;&lt;span&gt; id)
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; _sqlMapper.Execute(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; RequestContext
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt;                 Scope = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Article&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt;                 SqlId = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Delete&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt;                 Request = &lt;span&gt;new&lt;/span&gt; { Id =&lt;span&gt; id }
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt; &lt;span&gt;            });
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt; 
&lt;span&gt; 85&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 86&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; GetById
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 88&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;id&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 89&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt; 90&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; T_Article GetById(&lt;span&gt;long&lt;/span&gt;&lt;span&gt; id)
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; _sqlMapper.QuerySingle&amp;lt;T_Article&amp;gt;(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; RequestContext
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt;                 Scope = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Article&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt;                 SqlId = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GetEntity&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt;                 Request = &lt;span&gt;new&lt;/span&gt; { Id =&lt;span&gt; id }
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt; &lt;span&gt;            });
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt; 
&lt;span&gt;100&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;101&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Query
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;103&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;queryParams&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;104&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;105&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; IEnumerable&amp;lt;T_Article&amp;gt; Query(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; queryParams)
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; _sqlMapper.Query&amp;lt;T_Article&amp;gt;(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; RequestContext
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt;                 Scope = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Article&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt;                 SqlId = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Query&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;                 Request =&lt;span&gt; queryParams
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt; &lt;span&gt;            });
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt; 
&lt;span&gt;115&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;116&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; GetRecord
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;118&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;queryParams&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;119&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;120&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; GetRecord(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; queryParams)
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; _sqlMapper.ExecuteScalar&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; RequestContext
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt;                 Scope = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Article&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt;                 SqlId = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GetRecord&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;126&lt;/span&gt;                 Request =&lt;span&gt; queryParams
&lt;/span&gt;&lt;span&gt;127&lt;/span&gt; &lt;span&gt;            });
&lt;/span&gt;&lt;span&gt;128&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;129&lt;/span&gt; 
&lt;span&gt;130&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;131&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; IsExist
&lt;/span&gt;&lt;span&gt;132&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;133&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;queryParams&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;134&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;135&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; IsExist(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; queryParams)
&lt;/span&gt;&lt;span&gt;136&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;137&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; _sqlMapper.QuerySingle&amp;lt;&lt;span&gt;bool&lt;/span&gt;&amp;gt;(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; RequestContext
&lt;/span&gt;&lt;span&gt;138&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;139&lt;/span&gt;                 Scope = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Article&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;140&lt;/span&gt;                 SqlId = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;IsExist&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;141&lt;/span&gt;                 Request =&lt;span&gt; queryParams
&lt;/span&gt;&lt;span&gt;142&lt;/span&gt; &lt;span&gt;            });
&lt;/span&gt;&lt;span&gt;143&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;144&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;145&lt;/span&gt; }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;ArticleDataAccess&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;4. 最后一步&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;4.1 ArticleController&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;有了DataAccess我们可以轻松的操作数据库了。最后一步我们建立一个Controller，对外暴露一些接口吧。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('30b5aaef-829b-4d44-973d-0d623d421a74')&quot; readability=&quot;33.5&quot;&gt;&lt;span&gt;&lt;img id=&quot;code_img_closed_30b5aaef-829b-4d44-973d-0d623d421a74&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_30b5aaef-829b-4d44-973d-0d623d421a74&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('30b5aaef-829b-4d44-973d-0d623d421a74',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;
&lt;div id=&quot;cnblogs_code_open_30b5aaef-829b-4d44-973d-0d623d421a74&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Mvc;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; SmartSqlSampleChapterOne.DataAccess;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; SmartSqlSampleChapterOne.Entity;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; SmartSqlSampleChapterOne.Controllers
{
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; 
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    [Route(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[controller]/[action]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ArticleController : Controller
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; ArticleDataAccess _articleDataAccess;

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; constructor
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;articleDataAccess&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ArticleController(ArticleDataAccess articleDataAccess)
        {
            _articleDataAccess &lt;/span&gt;=&lt;span&gt; articleDataAccess;
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; 
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;article&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;        [HttpPost]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; T_Article Add([FromBody] T_Article article)
        {
            article.Id &lt;/span&gt;=&lt;span&gt; _articleDataAccess.Insert(article);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; article;
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; 
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;id&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;        [HttpGet]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; T_Article Get([FromQuery] &lt;span&gt;long&lt;/span&gt;&lt;span&gt; id)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; _articleDataAccess.GetById(id);
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; 
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;article&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;        [HttpPost]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; Update([FromBody] T_Article article)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; _articleDataAccess.Update(article) &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; 
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;id&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;status&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;        [HttpPost]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; UpdateStatus([FromQuery] &lt;span&gt;long&lt;/span&gt; id, [FromQuery] &lt;span&gt;int&lt;/span&gt;&lt;span&gt; status)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; _articleDataAccess.DyUpdate(&lt;span&gt;new&lt;/span&gt;&lt;span&gt;
            {
                Id &lt;/span&gt;=&lt;span&gt; id,
                Status &lt;/span&gt;=&lt;span&gt; status
            }) &lt;/span&gt;&amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; 
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;id&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;        [HttpGet]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; IsExist([FromQuery] &lt;span&gt;long&lt;/span&gt;&lt;span&gt; id)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; _articleDataAccess.IsExist(&lt;span&gt;new&lt;/span&gt;&lt;span&gt;
            {
                Id &lt;/span&gt;=&lt;span&gt; id
            });
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; 
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;key&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;        [HttpGet]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IEnumerable&amp;lt;T_Article&amp;gt; Query([FromQuery] &lt;span&gt;string&lt;/span&gt; key = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; _articleDataAccess.Query(&lt;span&gt;new&lt;/span&gt;&lt;span&gt;
            {
                Title &lt;/span&gt;=&lt;span&gt; key
            });
        }
    }
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;ArticleController&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;4.2 Startup&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;前面我们已经把SmartSql注入到了DI。现在我们再完善一下它，把Mvc和Swagger也注入进去。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('49e74240-e107-4fa3-bc1a-6fd2fbc3c066')&quot; readability=&quot;36.5&quot;&gt;&lt;span&gt;&lt;img id=&quot;code_img_closed_49e74240-e107-4fa3-bc1a-6fd2fbc3c066&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_49e74240-e107-4fa3-bc1a-6fd2fbc3c066&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('49e74240-e107-4fa3-bc1a-6fd2fbc3c066',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;
&lt;div id=&quot;cnblogs_code_open_49e74240-e107-4fa3-bc1a-6fd2fbc3c066&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;68&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Builder;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Hosting;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.Configuration;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.DependencyInjection;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.Logging;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; Swashbuckle.AspNetCore.Swagger;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.IO;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; SmartSql.ConfigBuilder;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; SmartSqlSampleChapterOne.DataAccess;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; SmartSqlSampleChapterOne
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Startup
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Startup(IConfiguration configuration)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             Configuration =&lt;span&gt; configuration;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; IConfiguration Configuration { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; This method gets called by the runtime. Use this method to add services to the container.
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; For more information on how to configure your application, visit &lt;/span&gt;&lt;span&gt;https://go.microsoft.com/fwlink/?LinkID=398940&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;            services.AddMvc();
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt;             services.AddLogging(logging =&amp;gt;
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;                logging.SetMinimumLevel(LogLevel.Trace);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;                logging.AddConsole();
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;            });
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; register smartsql&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;             services.AddSmartSql(builder =&amp;gt;
&lt;span&gt;36&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;                 builder.UseAlias(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SmartSqlSampleChapterOne&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义实例别名，在多库场景下适用。
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;.UseXmlConfig(ResourceType.File,&quot;MyConfig.xml&quot;);&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt; &lt;span&gt;            });
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; 
&lt;span&gt;41&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; register data access&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt;             services.AddSingleton&amp;lt;ArticleDataAccess&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; 
&lt;span&gt;44&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; register swagger&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt;             services.AddSwaggerGen(c =&amp;gt;
&lt;span&gt;46&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;                 c.SwaggerDoc(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SmartSqlSampleChapterOne&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Info
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;                     Title = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SmartSqlSample.ChapterOne&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;                     Version = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;v1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;                     Description = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SmartSqlSample.ChapterOne&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;52&lt;/span&gt; &lt;span&gt;                });
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; filePath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SmartSqlSampleChapterOne.xml&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (File.Exists(filePath)) c.IncludeXmlComments(filePath);
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;            });
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; 
&lt;span&gt;57&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; 
&lt;span&gt;59&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; This method gets called by the runtime. Use this method to configure the HTTP request pipeline.&lt;/span&gt;
&lt;span&gt;60&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app, IHostingEnvironment env)
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (env.IsDevelopment()) app.UseDeveloperExceptionPage();
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; &lt;span&gt;            app.UseMvc();
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; 
&lt;span&gt;65&lt;/span&gt;             app.UseSwagger(c =&amp;gt;&lt;span&gt; { });
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;             app.UseSwaggerUI(c =&amp;gt; { c.SwaggerEndpoint(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/swagger/SmartSqlSampleChapterOne/swagger.json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SmartSqlSampleChapterOne&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;); });
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt; }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;Startup&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;好了！至此项目的大部分元素都做了一个简单介绍。我们来看看最终的运行结果吧。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;5. 接口演示&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;接口预览&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/572600/201905/572600-20190513190716931-1752413102.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;添加接口&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/572600/201905/572600-20190513190741938-357594157.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;获取接口&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/572600/201905/572600-20190513190751428-1030734086.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;查询接口&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/572600/201905/572600-20190513190804801-2049487822.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;6. 结语&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;本篇文章简单介绍了一下如何使用SmartSql从无到有，完成一个单表的CURD接口实现。但其实SmartSql是一个非常强大的CRM，它还有许多特性没有展开。再接下来的系列文章中。我会一一为大家介绍。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a title=&quot;Deme Code&quot; href=&quot;https://github.com/noahjzc/SmartSqlSample&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;&lt;strong&gt;示例代码链接在这里&lt;/strong&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;下期预告：使用动态代理实现CURD&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 13 May 2019 11:17:00 +0000</pubDate>
<dc:creator>Noah.Ji</dc:creator>
<og:description>SmartSql = MyBatis + Cache(Memory | Redis) + R/W Splitting +Dynamic Repository + Diagnostics ......</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/noahji/p/10846215.html</dc:identifier>
</item>
<item>
<title>Spring Boot自动配置原理与实践（一） - JJian</title>
<link>http://www.cnblogs.com/jian0110/p/10855863.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jian0110/p/10855863.html</guid>
<description>&lt;blockquote readability=&quot;16&quot;&gt;
&lt;p&gt;　　Spring Boot众所周知是为了简化Spring的配置，&lt;span&gt;&lt;strong&gt;省去XML的复杂化配置（虽然Spring官方推荐也使用Java配置）采用Java+Annotation方式配置&lt;/strong&gt;&lt;/span&gt;。如下几个问题是我刚开始接触Spring Boot的时候经常遇到的一些疑问，现在总结出来希望能帮助到更多的人理解Spring Boot，当然这只是个人的理解，稍微显得肤浅但易懂！当时我明白了以下几个问题后，觉得Spring Boot也不过如此，没有啥花里胡哨的，希望能帮到大家！&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;本博文主要由两个部分组成：第一篇通过源码等形式介绍自动配置的原理与组成部分，第二篇通过实现自定义的starter实现自动配置加深对自动配置的理解。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　注：创作不易啊，虽然写只写了5个小时左右，但是整个准备过程很早就开始了，当然这样的记录方式主要是督促自己对Spring Boot要深入理解，顺带希望能帮到更多人&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　&lt;strong&gt;　问题一：那么Spring Boot是靠什么样的手段简化配置呢？&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;　　从广义上讲，从软件设计范式来说。Spring Boot提供一种“&lt;strong&gt;&lt;span&gt;约定优于配置”来简化配置&lt;/span&gt;&lt;/strong&gt;；减少开发人员去开发没必要的配置模块时间，采用约定，并且对不符合约定的部分采用灵活配置满足即可！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　&lt;strong&gt;　问题二：那么什么叫约定优于配置呢？&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;　　比如：我们知道Spring Boot都是内嵌Tomcat、Jetty等服务器的，其中默认的Tomcat服务器，相应的监听端口也默认绑定，&lt;span&gt;&lt;strong&gt;这些默认即为约定&lt;/strong&gt;&lt;/span&gt;。&lt;span&gt;&lt;strong&gt;大部分情况下我们都会使用默认默认的Spring Boot自带的内嵌的默认自动配置约定，不会大量去自定义配置，即这就是我理解的约定优于配置&lt;/strong&gt;&lt;/span&gt;。那么问题三来了。当我们觉得不符合我们实际生产环境的时候才会去改变默认配置，那么需要很麻烦的手段吗？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　&lt;strong&gt;　问题三：更改默认的端口或者服务器（即上述提到的约定）需要很麻烦的代码编写吗？甚至需要更改源码吗？&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;答案肯定是否定的，&lt;span&gt;&lt;strong&gt;只需要更改application.yml/properties（application-*.yml/properties）配置文件即可&lt;/strong&gt;&lt;/span&gt;。当然也可以从源头上开始重新创建自己需要的模块（准确来说可以是starter），需要的注册的配置类Bean。从而达到灵活的自动配置目的，这就是本篇要介绍的Spring Boot的自动配置。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;　&lt;/strong&gt;　明白以上三个问题后，&lt;span&gt;&lt;strong&gt;其实就能理解为什么Spring Boot相对于Spring更加灵活，方便，简单的原因了========&amp;gt;&lt;/strong&gt;&lt;strong&gt;无非就是大量使用默认自动配置+灵活的自动配置&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;


&lt;hr/&gt;


&lt;p&gt;&lt;strong&gt;　　&lt;span&gt;主要从spring boot是如何启动后自动检测自动配置与spring boot如何灵活处理自动配置两个方面讲解，前者主要分析源码，从简单的注解入手到最后的读取spring.facoties文件。后者主要举例RedisAutoConfiguration自动配置来说明spring boot对于相关的配置类bean的通过注解的灵活处理。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;1、Spring Boot是如何发现自动配置的？&lt;/h2&gt;
&lt;p&gt;都知道Spring Boot程序入口处（xxxApplication.java）都会有 &lt;span class=&quot;cnblogs_code&quot;&gt;@SpringBootApplication&lt;/span&gt; 的注解。这个注解表明该程序是主程序入口，也是SpringBoot应用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@SpringBootApplication
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DemoApplication {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        SpringApplication.run(DemoApplication.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, args);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看 &lt;span class=&quot;cnblogs_code&quot;&gt;@SpringBootApplication&lt;/span&gt; 注解，不难发现是一个组合注解，包括了 &lt;span class=&quot;cnblogs_code&quot;&gt;@SpringBootConfiguration @EnableAutoConfiguration @ComponentScan&lt;/span&gt; 。换句话说这三个注解可以替代 &lt;span class=&quot;cnblogs_code&quot;&gt;@SpringBootApplication&lt;/span&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
&lt;span&gt;@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan&lt;/span&gt;(
    excludeFilters &lt;/span&gt;=&lt;span&gt; {@Filter(
    type &lt;/span&gt;=&lt;span&gt; FilterType.CUSTOM,
    classes &lt;/span&gt;= {TypeExcludeFilter.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;}
), @Filter(
    type &lt;/span&gt;=&lt;span&gt; FilterType.CUSTOM,
    classes &lt;/span&gt;= {AutoConfigurationExcludeFilter.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;}
)}
)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中注解  &lt;span class=&quot;cnblogs_code&quot;&gt;@EnableAutoConfiguration&lt;/span&gt;  就是实现SpringBoot自动配置的关键所在，值得注意的是@EnableXXXX注解并不是SpringBoot特有，在Spring 3.x中就已经引出，比如：@EnableWebMvc用来启用Spring MVC而不需要XML配置，@EnableTransactionManagement注释用来声明事务管理而不需要XML配置。如此可见，&lt;span&gt;&lt;strong&gt;@EnableXXXX是用来开启某一个特定的功能，从而使用Java来配置，省去XML配置&lt;/strong&gt;&lt;/span&gt;。在SpringBoot中自动配置的开启就是依靠注解  &lt;span class=&quot;cnblogs_code&quot;&gt;@EnableAutoConfiguration&lt;/span&gt;  ，继续查看注解接口 &lt;span class=&quot;cnblogs_code&quot;&gt;@EnableAutoConfiguration&lt;/span&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@AutoConfigurationPackage
&lt;span&gt;@Import({AutoConfigurationImportSelector.&lt;/span&gt;&lt;/span&gt;&lt;span&gt;class})
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; EnableAutoConfiguration {
    String ENABLED_OVERRIDE_PROPERTY &lt;/span&gt;= &quot;spring.boot.enableautoconfiguration&quot;&lt;span&gt;;

    Class&lt;/span&gt;&amp;lt;?&amp;gt;[] exclude() &lt;span&gt;default&lt;/span&gt;&lt;span&gt; {};

    String[] excludeName() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {};
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中关键是 &lt;span class=&quot;cnblogs_code&quot;&gt;@Import({AutoConfigurationImportSelector.&lt;span&gt;class&lt;/span&gt;})&lt;/span&gt; ，表示选择所有SpringBoot的自动配置。废话不多说，还得继续看该选择器源码，其中最主要的方法是 &lt;span class=&quot;cnblogs_code&quot;&gt;getAutoConfiguationEntry&lt;/span&gt; 方法，该方法的主要功能是：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;获得自动配置----&amp;gt;删除重复自动配置-----&amp;gt;删除排除掉的自动配置----&amp;gt;删除过滤掉的自动配置------&amp;gt;最终的自动配置&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1352849/201905/1352849-20190513141609929-1288250121.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里我们主要关注如何获取自动配置，即图中红圈部分，即 &lt;span class=&quot;cnblogs_code&quot;&gt;getCandidateConfigurations&lt;/span&gt; 方法，&lt;span&gt;&lt;strong&gt;该方法通过SpringFactoresLoader.loadFactoryNames方法读取某个classpath下的文件获取所有的configurations&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1352849/201905/1352849-20190513142437775-1633332991.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意到： &lt;span class=&quot;cnblogs_code&quot;&gt;No auto configuration classes found in META-INF/spring.factories.....&lt;/span&gt; ，它应该是从META-INF/spring.factories文件中下读取configurations，我们再往下查看方法 &lt;span class=&quot;cnblogs_code&quot;&gt;SpringFactoresLoader.loadFactoryNames&lt;/span&gt; ，&lt;span&gt;&lt;strong&gt;该方法果然是读取META-INF/spring.factories文件的，从中获取自动配置键值对。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1352849/201905/1352849-20190513143028699-89906065.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后，我们找到META-INF/spring.factories文件（位于spring-boot-autoconfigure下）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1352849/201905/1352849-20190513143554509-2090406718.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;查看其内容：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt;...
# Auto Configure
org.springframework.boot.autoconfigure.EnableAutoConfiguration&lt;/span&gt;=&lt;span&gt;\
org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\
org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\
org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\
org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\
org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\
org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\
org.springframework.boot.autoconfigure.cloud.CloudServiceConnectorsAutoConfiguration,\
org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\
org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\
org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\
org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\
org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\
org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\
org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveDataAutoConfiguration,\
org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\
...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 这时候才恍然大悟，原来如此。简单总结起来就是，当SpringBoot应用启动读取自动配置之后，从上到下的相关调用栈（文字简单描述）&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;@EnableAutoConfiguration开启启动配置功能&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;通过@Import导入AutoConfigurationImportSelector选择器发现（注册）自动配置&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;getAutoConfigurationEntry方法获取并处理所有的自动配置&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;SpringFactoriesLoader.loadFactoryNames读取spring.factories文件并加载自动配置键值对。&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt; 2、Spring Boot是如何灵活处理自动配置的？&lt;/h2&gt;

&lt;p&gt;　　从spring.factories文件中我们选取RedisAutoConfiguration举例说明，至于为什么选这个呢？这是因为之前我有写过关于Spring Boot整合Redis的相关博文。所以好入手！&lt;/p&gt;
&lt;p&gt;首先，还是一样进入RedisAutoConfiguration（Idea大法好，点击进入即可查看代码）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1352849/201905/1352849-20190513155457713-510556007.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;源码如下，主要关注以下几个注解：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）@ConditionalOnClass&lt;/strong&gt;：&lt;strong&gt;在当前classpath下是否存在指定类，若是则将当前的配置注册到spring容器。&lt;/strong&gt;&lt;/span&gt;可见其灵活性。相关的@ConditionalXXX注解是spring 4.x推出的灵活注册bean的注解，称之为“条件注解”。有如下一系列条件注解：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;@ConditionalOnMissingBean： 当spring容器中不存在指定的bean时，才会注册该Bean。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;@ConditionalOnMissingClass：当不存在指定的类时，才会注册该bean。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;@ConditionalOnProperty：根据配置文件中某个属性来决定是否注册该Bean，相对于其它条件注解较为复杂。主要有以下两种情况应用：&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　一种是@ConditionalOnProperty(prefix = “mysql”, name = “enable”, havingValue = “true”)表示以为mysql为前缀的mysql.enable属性如果为空或者不是true时不会注册指定Bean，只有mysql.enable属性为true时候才会注册该指定Bean&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　   一种是@ConditionalOnProperty(prefix = “mysql”, name = “enable”, havingValue = “true”, matchIfMissing = true)matchIfMissing表示如果没有以mysql为前缀的enable属性，则为true表示符合条件，可以注册该指定Bean，默认为false。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;@ConditionalOnJava：是否是Java应用&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;@ConditionalOnWebApplication：是否是Web应用&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;@ConditionalOnExpression：根据表达式判断是否注册Bean&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　...........剩下的还有很多，在autoconfigure.condition包下...........&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1352849/201905/1352849-20190513163032819-356306795.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）@EnableConfigurationProperties&lt;/strong&gt;：&lt;strong&gt;让 @ConfigurationProperties 注解的properties类生效并使用。&lt;/strong&gt;&lt;/span&gt;如让RedisProperties生效并注册到Spring容器中，并且使用！&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3）@ConditionalOnMissingBean&lt;/strong&gt;：&lt;strong&gt;当前Spring容器中没有该bean(name或者class指定)，则注册该bean到spring容器。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Configuration
@ConditionalOnClass({RedisOperations.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;})
@EnableConfigurationProperties({RedisProperties.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;})
@Import({LettuceConnectionConfiguration.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;, JedisConnectionConfiguration.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;})
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RedisAutoConfiguration {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; RedisAutoConfiguration() {
    }

    @Bean
    @ConditionalOnMissingBean(
        name &lt;/span&gt;= {&quot;redisTemplate&quot;&lt;span&gt;}
    )
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; RedisTemplate&amp;lt;Object, Object&amp;gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; UnknownHostException {
        RedisTemplate&lt;/span&gt;&amp;lt;Object, Object&amp;gt; template = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RedisTemplate();
        template.setConnectionFactory(redisConnectionFactory);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; template;
    }

    @Bean
    @ConditionalOnMissingBean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; UnknownHostException {
        StringRedisTemplate template &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringRedisTemplate();
        template.setConnectionFactory(redisConnectionFactory);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; template;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 由此可见Spring Boot对于自动配置的灵活性，可以传递给我们一种信息，&lt;strong&gt;Spring Boot是如何灵活处理自动配置的？&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;往大了说，就是你可以选择约定使用大量默认配置简化开发过程，你也可以自定义开发过程中需要的自动配置。往细了说，就是通过各式各样的条件注解注册需要的Bean来实现灵活配置。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那么实现一个自动配置有哪些重要的环节呢?&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;继续往下看第二部分！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;



&lt;p&gt;　　上面只是对自动配置中几个重要的注解做了简单介绍，但是并没有介绍要开发一个简单的自动配置需要哪些环节（部分），同样地我们还是以RedisAutoConfiguration与RabbitAutoConfiguration为例，主要查看注解头：&lt;/p&gt;
&lt;p&gt;RedisAutoConfiguration：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Configuration
@ConditionalOnClass({RedisOperations.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;})
@EnableConfigurationProperties({RedisProperties.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;})
@Import({LettuceConnectionConfiguration.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;, JedisConnectionConfiguration.&lt;span&gt;class&lt;/span&gt;})
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;RabbitAutoConfiguration：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Configuration
@ConditionalOnClass({RabbitTemplate.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;, Channel.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;})
@EnableConfigurationProperties({RabbitProperties.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;})
@Import({RabbitAnnotationDrivenConfiguration.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;})
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;你会发现通常的一般的AutoConfiguration都有&lt;span class=&quot;cnblogs_code&quot;&gt;@Configuration，@ConditionalOnClass，@EnableConfigurationProperties，@Import&lt;/span&gt; 注解：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;@Configuration：自然不必多说，表示是配置类，是必须存在的！&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;@ConditionalOnClass：表示该配置依赖于某些Class是否在ClassPath中，如果不存在那么这个配置类是毫无意义的。也可以说是该class在配置类中充当重要的角色，是必须存在的！。在后面的自定义spring boot starter中我们可以简单统称为服务类&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;@EnableConfigurationProperties：读取配置文件，需要让相关的Properties生效，每个自动配置都离不开properties属性，是必须存在的！&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;@Import：导入配置类中需要用到的bean，通常是一些配置类。表示此时的自动配置类需要基于一些配置类而实现自动配置功能。当然不是必须的，有些是没有这个注解的，是不需要基于某些配置类的！&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;那么，可以简单总结得到一个自动配置类主要有以下几部分组成（单纯是根据个人理解总结出来的，没有官方说明）&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;properties bean配置属性：用来读取spring配置文件中的属性，@EnableConfigurationProperties与@ConfigurationProperties结合使用，具体请看下一篇实践stater例子。&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;该配置类依赖的一些Class，使用@ConditionalClass判断；&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;该配置类依赖的一些配置Bean，使用@Import导入。&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;可能还有加载顺序的控制，如&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;@&lt;/strong&gt;&lt;strong&gt;AutoConfigureAfter，@AutoConfigureOrder等&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;一些Bean的加载，往往通过方法返回Object，加@Bean以及一些条件注解来实现&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;========================================未完待续（下一篇补充自定义starter会涉及自动配置组成部分）==========================================&lt;/p&gt;

</description>
<pubDate>Mon, 13 May 2019 09:35:00 +0000</pubDate>
<dc:creator>JJian</dc:creator>
<og:description>前言 Spring Boot众所周知是为了简化Spring的配置，省去XML的复杂化配置（虽然Spring官方推荐也使用Java配置）采用Java+Annotation方式配置。如下几个问题是我刚开始</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jian0110/p/10855863.html</dc:identifier>
</item>
<item>
<title>浅析libuv源码-node事件轮询解析(4) - 书生小龙</title>
<link>http://www.cnblogs.com/QH-Jimmy/p/10857886.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/QH-Jimmy/p/10857886.html</guid>
<description>&lt;p&gt;　　这篇应该能结，简图如下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/858904/201905/858904-20190513172909799-867394017.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　上一篇讲到了uv__work_submit方法，接着写了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; uv__work_submit(uv_loop_t*&lt;span&gt; loop,
                     &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; uv__work*&lt;span&gt; w,
                     &lt;/span&gt;&lt;span&gt;enum&lt;/span&gt;&lt;span&gt; uv__work_kind kind,
                     &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; (*work)(&lt;span&gt;struct&lt;/span&gt; uv__work*&lt;span&gt; w),
                     &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; (*done)(&lt;span&gt;struct&lt;/span&gt; uv__work* w, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; status)) {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 上篇主要讲的这里 初始化线程池等&lt;/span&gt;
  uv_once(&amp;amp;&lt;span&gt;once, init_once);
  w&lt;/span&gt;-&amp;gt;loop =&lt;span&gt; loop;
  w&lt;/span&gt;-&amp;gt;work =&lt;span&gt; work;
  w&lt;/span&gt;-&amp;gt;done =&lt;span&gt; done;
  post(&lt;/span&gt;&amp;amp;w-&amp;gt;&lt;span&gt;wq, kind);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　从post开始。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; post(QUEUE* q, &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; uv__work_kind kind) {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 因为存在队列插入操作 需要加锁&lt;/span&gt;
  uv_mutex_lock(&amp;amp;&lt;span&gt;mutex);
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (kind ==&lt;span&gt; UV__WORK_SLOW_IO) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;跳...&lt;/span&gt;
&lt;span&gt;  }

  QUEUE_INSERT_TAIL(&lt;/span&gt;&amp;amp;&lt;span&gt;wq, q);
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果有空闲线程 唤醒&lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt; (idle_threads &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
    uv_cond_signal(&lt;/span&gt;&amp;amp;&lt;span&gt;cond);
  uv_mutex_unlock(&lt;/span&gt;&amp;amp;&lt;span&gt;mutex);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　wq就是上一篇讲的线程都会用到的那个队列，这里负责插入任务，worker中取出任务。&lt;/p&gt;
&lt;p&gt;　　没想到post到这里没了，这点东西并到上一篇就好了。以后写这种系列博客还是先规划一下，不能边看源码边写……&lt;/p&gt;
&lt;p&gt;　　函数到这里就断了，看似没有线索，实际上在上一节的worker方法中，还漏了一个地方。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; worker(&lt;span&gt;void&lt;/span&gt;*&lt;span&gt; arg) {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
  &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里调用内部fs方法处理任务&lt;/span&gt;
    w = QUEUE_DATA(q, &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; uv__work, wq);
    w&lt;/span&gt;-&amp;gt;&lt;span&gt;work(w);

    uv_mutex_lock(&lt;/span&gt;&amp;amp;w-&amp;gt;loop-&amp;gt;&lt;span&gt;wq_mutex);
    w&lt;/span&gt;-&amp;gt;work =&lt;span&gt; NULL; 
    QUEUE_INSERT_TAIL(&lt;/span&gt;&amp;amp;w-&amp;gt;loop-&amp;gt;wq, &amp;amp;w-&amp;gt;&lt;span&gt;wq);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这个是漏了的关键&lt;/span&gt;
    uv_async_send(&amp;amp;w-&amp;gt;loop-&amp;gt;&lt;span&gt;wq_async);
    uv_mutex_unlock(&lt;/span&gt;&amp;amp;w-&amp;gt;loop-&amp;gt;&lt;span&gt;wq_mutex);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　每一条线程在每次处理完一条事务并将其插入工作队列wq后，都会调用一下这个uv_async_send方法，上一篇没讲这个。&lt;/p&gt;
&lt;p&gt;　　这里的wq_async是一个在loop上面的变量，在轮询初始化的时候出现过，这里先不看。&lt;/p&gt;
&lt;p&gt;　　uv_async_send这个方法又涉及到另外一个大模块，如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; uv_async_send(uv_async_t*&lt;span&gt; handle) {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 错误处理...&lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt; (!uv__atomic_exchange_set(&amp;amp;handle-&amp;gt;&lt;span&gt;async_sent)) {
    POST_COMPLETION_FOR_REQ(loop, &lt;/span&gt;&amp;amp;handle-&amp;gt;&lt;span&gt;async_req);
  }

  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将操作结果推到iocp上面&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; POST_COMPLETION_FOR_REQ(loop, req)                              \
  &lt;span&gt;if&lt;/span&gt; (!PostQueuedCompletionStatus((loop)-&amp;gt;&lt;span&gt;iocp,                         \
                                  &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,                                    \
                                  &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,                                    \
                                  &lt;/span&gt;&amp;amp;((req)-&amp;gt;&lt;span&gt;u.io.overlapped))) {         \
    uv_fatal_error(GetLastError(), &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;PostQueuedCompletionStatus&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);       \
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;strong&gt;这个地方说实话我并不是明白windows底层API的操作原理，IOCP这部分我没有去研究，只能从字面上去理解。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　关于PostXXX方法官网解释如下：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Posts an I/O completion packet to an I/O completion port.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　将一个I/O完成的数据打包到I/O完成的端口，翻译过来就是这样，个人理解上的话大概是把一个async_req丢到IOCP那里保存起来。&lt;/p&gt;

&lt;p&gt;　　接下来终于可以回到事件轮询部分，点题了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; uv_run(uv_loop_t *&lt;span&gt;loop, uv_run_mode mode) {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;

  &lt;span&gt;while&lt;/span&gt; (r != &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; loop-&amp;gt;stop_flag == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; call pending callbacks&lt;/span&gt;
    ran_pending =&lt;span&gt; uv_process_reqs(loop);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; poll for I/O&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (pGetQueuedCompletionStatusEx)
      uv__poll(loop, timeout);
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
      uv__poll_wine(loop, timeout);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;  }
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　截取了剩下的poll for I/O、call pending callback，也就是剩下的两部分了。if判断不用管，只是一个方法兼容，最终的目的是一样的。&lt;/p&gt;
&lt;p&gt;　　所以只看uv__poll部分。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; uv__poll(uv_loop_t*&lt;span&gt; loop, DWORD timeout) {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设定阻塞时间&lt;/span&gt;
&lt;span&gt;  uint64_t timeout_time;
  timeout_time &lt;/span&gt;= loop-&amp;gt;time +&lt;span&gt; timeout;

  &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (repeat = &lt;span&gt;0&lt;/span&gt;; ; repeat++&lt;span&gt;) {
    success &lt;/span&gt;= GetQueuedCompletionStatusEx(loop-&amp;gt;&lt;span&gt;iocp,
                                          overlappeds,
                                          ARRAY_SIZE(overlappeds),
                                          &lt;/span&gt;&amp;amp;&lt;span&gt;count,
                                          timeout,
                                          FALSE);

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (success) {
      &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; count; i++&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (overlappeds[i].lpOverlapped) {
          req &lt;/span&gt;=&lt;span&gt; uv_overlapped_to_req(overlappeds[i].lpOverlapped);
          uv_insert_pending_req(loop, req);
        }
      }
      uv_update_time(loop);
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (GetLastError() !=&lt;span&gt; WAIT_TIMEOUT) {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
    } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (timeout &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 超时处理...&lt;/span&gt;
&lt;span&gt;    }
    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里的GetQueueXXX方法与之前的PostQueueXXX正好是一对方法，都是基于IOCP，一个是存储，一个是取出。&lt;/p&gt;
&lt;p&gt;　　遍历操作就很容易懂了，取出数据后，一个个的塞到pending callback的队列中。&lt;/p&gt;
&lt;p&gt;　　把uv_insert_pending_req、uv_process_reqs两个方法结合起来看。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
INLINE &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; uv_insert_pending_req(uv_loop_t* loop, uv_req_t*&lt;span&gt; req) {
  req&lt;/span&gt;-&amp;gt;next_req =&lt;span&gt; NULL;
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 插入到pending_reqs_tail上&lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt; (loop-&amp;gt;&lt;span&gt;pending_reqs_tail) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; DEBUG...&lt;/span&gt;
&lt;span&gt;
    req&lt;/span&gt;-&amp;gt;next_req = loop-&amp;gt;pending_reqs_tail-&amp;gt;&lt;span&gt;next_req;
    loop&lt;/span&gt;-&amp;gt;pending_reqs_tail-&amp;gt;next_req =&lt;span&gt; req;
    loop&lt;/span&gt;-&amp;gt;pending_reqs_tail =&lt;span&gt; req;
  } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
    req&lt;/span&gt;-&amp;gt;next_req =&lt;span&gt; req;
    loop&lt;/span&gt;-&amp;gt;pending_reqs_tail =&lt;span&gt; req;
  }
}

INLINE &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; uv_process_reqs(uv_loop_t*&lt;span&gt; loop) {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 处理pending_reqs_tail&lt;/span&gt;
  first = loop-&amp;gt;pending_reqs_tail-&amp;gt;&lt;span&gt;next_req;
  next &lt;/span&gt;=&lt;span&gt; first;
  loop&lt;/span&gt;-&amp;gt;pending_reqs_tail =&lt;span&gt; NULL;

  &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (next !=&lt;span&gt; NULL) {
    req &lt;/span&gt;=&lt;span&gt; next;
    next &lt;/span&gt;= req-&amp;gt;next_req != first ? req-&amp;gt;&lt;span&gt;next_req : NULL;

    &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt; (req-&amp;gt;&lt;span&gt;type) {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; handle各类req...&lt;/span&gt;
&lt;span&gt;    }
  }

  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　就这样，完美的把poll for I/O与call pending callback两块内容连接到了一起，也同时理解了一个异步I/O操作是如何在node内部被处理的。&lt;/p&gt;

&lt;p&gt;　　最后还是剩一个尾巴，就是丢到IOCP的那个async_req怎么回事？这个变量在轮询的初始化方法中出现，如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
typedef &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; uv_loop_s uv_loop_t;

&lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; uv_loop_s {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;  UV_LOOP_PRIVATE_FIELDS
};

&lt;/span&gt;&lt;span&gt;#define&lt;/span&gt; UV_LOOP_PRIVATE_FIELDS                                                \
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 其余变量&lt;/span&gt;
&lt;span&gt;  uv_async_t wq_async;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; uv__word_done是这个handle的回调函数&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; uv_loop_init(uv_loop_t*&lt;span&gt; loop) {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
  err = uv_async_init(loop, &amp;amp;loop-&amp;gt;&lt;span&gt;wq_async, uv__work_done);
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第一篇中演示过handle的初始化和运行 很常规的init、start两步&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; uv_async_init(uv_loop_t* loop, uv_async_t*&lt;span&gt; handle, uv_async_cb async_cb) {
  uv_req_t&lt;/span&gt;*&lt;span&gt; req;

  uv__handle_init(loop, (uv_handle_t&lt;/span&gt;*&lt;span&gt;) handle, UV_ASYNC);
  handle&lt;/span&gt;-&amp;gt;async_sent = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
  handle&lt;/span&gt;-&amp;gt;async_cb =&lt;span&gt; async_cb;

  req &lt;/span&gt;= &amp;amp;handle-&amp;gt;&lt;span&gt;async_req;
  UV_REQ_INIT(req, UV_WAKEUP);
  req&lt;/span&gt;-&amp;gt;data =&lt;span&gt; handle;

  uv__handle_start(handle);

  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}

# define UV_REQ_INIT(req, typ)                                                \
  &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt; {                                                                        \
    (req)&lt;/span&gt;-&amp;gt;type =&lt;span&gt; (typ);                                                      \
  }                                                                           \
  &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;0&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　从代码里面可以知道，loop上本身带有一个uv_async_t的变量wq_async，初始化后有四个属性。其中需要注意，这个类型的type被设置为UV_WAKEUP。&lt;/p&gt;
&lt;p&gt;　　再回到uv_process_reqs中，处理从IOCP取出的req那块。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
INLINE &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; uv_process_reqs(uv_loop_t*&lt;span&gt; loop) {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;

  &lt;span&gt;while&lt;/span&gt; (next !=&lt;span&gt; NULL) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
    &lt;span&gt;switch&lt;/span&gt; (req-&amp;gt;&lt;span&gt;type) {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
      &lt;span&gt;case&lt;/span&gt;&lt;span&gt; UV_WAKEUP:
        uv_process_async_wakeup_req(loop, (uv_async_t&lt;/span&gt;*) req-&amp;gt;&lt;span&gt;data, req);
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;    }
  }

  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我们找到了处理UV_WAKEUP的case，参数参考上面那个初始化的代码也很容易得知，req-&amp;gt;data就是loop初始化的那个handle，req是那个async_req。&lt;/p&gt;
&lt;p&gt;　　方法代码如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; uv_process_async_wakeup_req(uv_loop_t* loop, uv_async_t* handle, uv_req_t*&lt;span&gt; req) {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 丢进IOCP的时候被设置为1了 具体在uv_async_send的uv__atomic_exchange_set方法中&lt;/span&gt;
  handle-&amp;gt;async_sent = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (handle-&amp;gt;flags &amp;amp;&lt;span&gt; UV_HANDLE_CLOSING) {
    uv_want_endgame(loop, (uv_handle_t&lt;/span&gt;*&lt;span&gt;)handle);
  } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (handle-&amp;gt;async_cb !=&lt;span&gt; NULL) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 进的else分支&lt;/span&gt;
    handle-&amp;gt;&lt;span&gt;async_cb(handle);
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里的async_cb也是初始化就定义了，实际函数名是uv__work_done。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; uv__work_done(uv_async_t*&lt;span&gt; handle) {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;
  loop &lt;/span&gt;=&lt;span&gt; container_of(handle, uv_loop_t, wq_async);
  uv_mutex_lock(&lt;/span&gt;&amp;amp;loop-&amp;gt;&lt;span&gt;wq_mutex);
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 还是那个熟悉的队列&lt;/span&gt;
  QUEUE_MOVE(&amp;amp;loop-&amp;gt;wq, &amp;amp;&lt;span&gt;wq);
  uv_mutex_unlock(&lt;/span&gt;&amp;amp;loop-&amp;gt;&lt;span&gt;wq_mutex);

  &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (!QUEUE_EMPTY(&amp;amp;&lt;span&gt;wq)) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
    w-&amp;gt;&lt;span&gt;done(w, err);
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这个done，就是用户从JS传过去的callback……&lt;/p&gt;
&lt;p&gt;　　也就是说call pending callback实际上是调用用户传过来的callback，第二篇的图其实是有问题的，系列完结撒花！&lt;/p&gt;
</description>
<pubDate>Mon, 13 May 2019 09:30:00 +0000</pubDate>
<dc:creator>书生小龙</dc:creator>
<og:description>这篇应该能结，简图如下。 上一篇讲到了uv__work_submit方法，接着写了。 从post开始。 wq就是上一篇讲的线程都会用到的那个队列，这里负责插入任务，worker中取出任务。 没想到po</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/QH-Jimmy/p/10857886.html</dc:identifier>
</item>
<item>
<title>如何构建多模块的SpringBoot项目 - 屌丝扎卡维</title>
<link>http://www.cnblogs.com/zkm1992/p/10857859.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zkm1992/p/10857859.html</guid>
<description>&lt;p&gt;  &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;通过阅读本文你将了解到：如何将已有SpringBoot项目改成多模块 &amp;amp; 如何新构建多模块SpringBoot项目 以下示例基于我正在使用的order(订单服务)进行演示，无论你用的是什么项目，原理都是一样的，这里不要纠结使用的是什么服务。&lt;/span&gt;&lt;/span&gt; &lt;/p&gt;

&lt;p&gt;最外层pom文件是用来管理其他子模块的父级pom，重点将&amp;lt;packaging&amp;gt;节点修改为pom，修改前&amp;lt;packaging&amp;gt;可能是jar或war&lt;/p&gt;
&lt;p&gt;这里修改成pom是因为打包时，父pom是依赖于子pom进行打包的，父pom会通过&amp;lt;modules&amp;gt;节点将所有的子pom模块引入并且进行管理&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/846381/201905/846381-20190513163236179-989932508.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;packaging&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;pom&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;packaging&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;假设你已经设计好子模块的拆分原则，这里开始基于你自己的设计进行子模块的创建&lt;/p&gt;
&lt;p&gt;例如：我将order项目拆分成三个不通的子模块，即common、client、server，每个模块负责的事情是不同的&lt;/p&gt;
&lt;p&gt;第一步：右键项目名称，选择New-&amp;gt;Module&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/846381/201905/846381-20190513164020986-1262940184.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第二步：在弹出的New Module窗口选择Maven&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/846381/201905/846381-20190513164213432-1667199325.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第三步：点击Next，并输入子模块的ArtifactId，如：common、client、server等，然后点击Next&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/846381/201905/846381-20190513164455905-2085282317.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第四步：检查并确认子模块名称及路径是否正确，如果正确则点击Finish&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/846381/201905/846381-20190513164620992-518864767.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，common模块就创建成功了，你会发现order根目录下多了一个common子模块&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/846381/201905/846381-20190513164847858-1804848604.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;创建了common模块后，如果有需要移动至common子模块下的代码，则根据原来的代码目录结构，在common-src-main-java下创建相同的目录结构即可&lt;/p&gt;
&lt;p&gt;例如：我项将ProductInfoOutput移动到common子模块下，原来ProductInfoOutput的保路经为com.imooc.order.common，那么我需要在common-src-main-java下创建com.imooc.order.common包，并将ProductInfoOutput拽进去&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/846381/201905/846381-20190513165300450-456531994.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;补充说明：我在创建com.imooc.order.common包时遇到了一个问题，就是右键java文件夹然后选New-&amp;gt;Package并创建com.imooc.order.common时，创建出来的包路径时没有层次结构的，也就是说IDEA单纯的为我创建了一个名为com.imooc.order.common的文件夹&lt;/p&gt;
&lt;p&gt;经研究发现，是视图的问题，将左上角的Project改成Project Files，然后按照上面的方式创建即可&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/846381/201905/846381-20190513165205239-1119632779.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 在转移test目录下的代码时，同样需要注意test目录下的包结构要与转移前的结构一致，这里以server模块为例，因为common下的test目录没有代码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/846381/201905/846381-20190513165914969-987984172.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 当我们创建好多有的子模块后，观察最外层的父级pom文件内容，发现父级pom已经将我们创建的子模块作为modules引入进来了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/846381/201905/846381-20190513170159624-951497339.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;当我们创建好多个子模块后，子模块间可能会存在依赖关系，例如我的server模块会依赖common模块下的ProductInfoOutput类&lt;/p&gt;
&lt;p&gt;那么我需要在server模块的pom文件中将common模块引入&lt;/p&gt;
&lt;p&gt;其他模块间的依赖引用同理&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/846381/201905/846381-20190513170415217-1386143339.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;修改完子pom的依赖关系后，一定要刷新pom文件，不然依赖不会生效&lt;/p&gt;

&lt;p&gt;SpringBoot项目一般都会打成jar包部署，所以需要在pom中引入spring-boot-maven-plugin的maven插件&lt;/p&gt;
&lt;p&gt;例如：我现在要打包order项目，此时我的SpringBoot运行主类在server模块下，那么我就需要以server模块为主要的打包对象&lt;/p&gt;
&lt;p&gt;因为打包时，maven插件会去找SpringBoot的启动类，如果没有启动类会打包失败&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/846381/201905/846381-20190513171010124-1206769132.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么，此时我就需要在server模块的pom中增加spring-boot-maven-plugin的相关配置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/846381/201905/846381-20190513171104284-293519907.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;build&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;plugins&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;plugin&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-maven-plugin&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;plugin&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;plugins&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;build&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 注意：在最外层的父级pom中如果同样存在spring-boot-maven-plugin的配置，记得一定要删除掉&lt;/p&gt;

&lt;p&gt;在maven窗口一次执行Lifecycle下的clean和install（如果你会maven命令，也可以用命令操作）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/846381/201905/846381-20190513172205777-385795309.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，这几个模块都是SUCCESS，说明构建成功了&lt;/p&gt;
&lt;p&gt;那我们要的可以运行的jar文件在server模块的target目录下，我们找到它&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/846381/201905/846381-20190513172346560-2000187710.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后放到服务器上运行这个jar包&lt;/p&gt;
&lt;p&gt;使用命令：nohuo java -jar order-server-0.0.1-SNAPSHOT.jar &amp;gt; order.log 2&amp;gt;&amp;amp;1 &amp;amp;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/846381/201905/846381-20190513172518707-1718823265.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，项目已经成功启动了，端口号为默认的8080&lt;/p&gt;
&lt;p&gt;至此，构建多模块的SpringBoot项目就已经告一段落了&lt;/p&gt;

</description>
<pubDate>Mon, 13 May 2019 09:27:00 +0000</pubDate>
<dc:creator>屌丝扎卡维</dc:creator>
<og:description>通过阅读本文你将了解到：如何将已有SpringBoot项目改成多模块 &amp; 如何新构建多模块SpringBoot项目 以下示例基于我正在使用的order(订单服务)进行演示，无论你用的是什么项目</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zkm1992/p/10857859.html</dc:identifier>
</item>
<item>
<title>一起来学Spring Cloud | 第四章：服务消费者 ( Feign ) - young码农</title>
<link>http://www.cnblogs.com/haly/p/10857752.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/haly/p/10857752.html</guid>
<description>&lt;p&gt;上一章节，讲解了SpringCloud如何通过RestTemplate+Ribbon去负载均衡消费服务，本章主要讲述如何通过Feign去消费服务。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、Feign 简介：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Feign是一个便利的rest框架，在Ribbon的基础上进行了一次改进，采用接口的方式，将需要调用的其他服务的方法定义成抽象方法，不需要自己构建http请求，简化了调用。但是最后的原理还是通过ribbon在注册服务器中找到服务实例，然后对请求进行分配。&lt;/p&gt;
&lt;p&gt;在工作中，我们基本上都是使用Feign来进行服务调用，因为Feign使用起来就像是调用自身本地的方法一样，而感觉不到是调用远程方法，相当舒服，它主要有3个优点。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1. feign本身里面就包含有了ribbon，具有负载均衡的能力&lt;/li&gt;
&lt;li&gt;2. fegin是一个采用基于接口的注解的编程方式，更加简便&lt;/li&gt;
&lt;li&gt;3. fegin整合了Hystrix，具有熔断的能力&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;二、 准备工作：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;对于springcloud-eureka-client工程不清楚了，可以参考：&lt;a id=&quot;cb_post_title_url&quot; href=&quot;https://www.cnblogs.com/haly/p/10756742.html&quot;&gt;&lt;span&gt;一起来学Spring Cloud | 第二章：服务注册和发现组件 (Eureka)&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;1. 启动eureka-server 工程，eureka注册中心就启动了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2. 启动springcloud-eureka-client工程，springcloud-eureka-client工程的端口为9300。&lt;/p&gt;
&lt;p&gt;3. 将springcloud-eureka-client工程的application.properties文件中端口改成9400，然后再启动springcloud-eureka-client。&lt;/p&gt;
&lt;p&gt;通过上面步骤，我们就启动了端口9300，9400两个一样的springcloud-eureka-client服务模块（为了测试feign的负载均衡能力）。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、新建一个feign服务：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 新建一个spring-boot工程，取名为springcloud-feign-client，修改pox文件如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
        &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

        &lt;span&gt;&amp;lt;parent&amp;gt;
                &amp;lt;groupId&amp;gt;com.haly&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;springcloud&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
        &amp;lt;/parent&amp;gt;
&lt;/span&gt;
        &amp;lt;groupId&amp;gt;com.haly&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;springcloud-feign-client&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
        &amp;lt;name&amp;gt;springcloud-ribbon-client&amp;lt;/name&amp;gt;
        &amp;lt;description&amp;gt;新建一个springcloud项目&amp;lt;/description&amp;gt;

        &amp;lt;dependencies&amp;gt;
                &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-client&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
           &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-cloud-starter-openfeign&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;/dependencies&amp;gt;

        &amp;lt;build&amp;gt;
                &amp;lt;plugins&amp;gt;
                        &amp;lt;plugin&amp;gt;
                                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                                &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
                        &amp;lt;/plugin&amp;gt;
                &amp;lt;/plugins&amp;gt;
        &amp;lt;/build&amp;gt;


&amp;lt;/project&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;如果有同学对上面配置pom文件中的parent标签引入的父pom有疑问，可以参考一下 &lt;a id=&quot;cb_post_title_url&quot; href=&quot;https://www.cnblogs.com/haly/p/10756742.html&quot;&gt;一起来学Spring Cloud | 第二章：服务注册和发现组件 (Eureka)&lt;/a&gt; ， 讲解了自己定义一个父pom的作用 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;如果有同学不想从头搭建模块，也可以在parant标签中直接引入springboot的配置，但是注意本章节所使用的依赖包兼容的版本号为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;springboot ：&lt;span data-mce-=&quot;&quot;&gt;2.1&lt;code class=&quot;java plain&quot;&gt;.&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;4&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;.RELEASE&lt;/code&gt; ,     &lt;/span&gt;&lt;/span&gt; &lt;span data-mce-=&quot;&quot;&gt;springcloud：Finchley.RELEASE&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 2. 修改application.properties文件如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
server.port=9600
spring.application.name=springcloud-feign-client
eureka.client.serviceUrl.defaultZone=http://localhost:8761/eureka/
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;3. 模块启动类需要增加注解@EnableFeignClients，表示开启Feign的功能&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
package com.haly.springcloud;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;
import org.springframework.cloud.openfeign.EnableFeignClients;

@SpringBootApplication
@EnableFeignClients
@EnableDiscoveryClient
public class SpringcloudFeignClientApplication {

        public static void main(String[] args) {
                SpringApplication.run(SpringcloudFeignClientApplication.class, args);
        }

}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4. 定义一个feign接口，通过@FeignClient（“服务名”），来指定调用哪个服务。本章案例中调用了springcloud-eureka-client服务的“/hello”接口&lt;/p&gt;
&lt;p&gt;springcloud-eureka-client模块中的hello接口，在第二章已经实现，具体实现可以参考：&lt;a id=&quot;cb_post_title_url&quot; href=&quot;https://www.cnblogs.com/haly/p/10756742.html&quot;&gt;一起来学Spring Cloud | 第二章：服务注册和发现组件 (Eureka)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ps：抽象方法的注解、方法名、参数要和服务提供方保持一致（这里是与&lt;em id=&quot;__mceDel&quot;&gt;springcloud-eureka-client模块中的 /hello方法保持一致）&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
package com.haly.springcloud.romote;

import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;

@FeignClient(value = &quot;springcloud-eureka-client&quot;)
public interface FeignRemoteService {

    @RequestMapping(value = &quot;/hello&quot;,method = RequestMethod.GET)
    public String hello(@RequestParam(value = &quot;name&quot;) String name);
    
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;5. controller层，对外暴露一个&quot;/getHello&quot;的API接口，给页面测试，通过上面定义的Feign客户端FeignRemoteService来消费服务。代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
package com.haly.springcloud.controller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import com.haly.springcloud.romote.FeignRemoteService;

@RestController
public class FeignController {
        
    @Autowired
    FeignRemoteService feignRemoteService;

    @GetMapping(value = &quot;/getHello&quot;)
    public String getHello(@RequestParam String name) {
        return feignRemoteService.hello(name);
    }

}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;6. 启动各个服务模块，服务注册结果如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1663312/201905/1663312-20190513163053956-1165099264.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 访问地址 http://localhost:9600/getHello?name=young码农  ， 多次轮流访问页面，出现9300，9400服务接口返回结果，证明feign是整合了负载均衡功能&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1663312/201905/1663312-20190513163236368-1978953898.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1663312/201905/1663312-20190513163259461-1796342362.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;四、总结：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;加上本章节代码后，代码目录结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1663312/201905/1663312-20190513163500117-263710396.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 13 May 2019 09:26:00 +0000</pubDate>
<dc:creator>young码农</dc:creator>
<og:description>上一章节，讲解了SpringCloud如何通过RestTemplate+Ribbon去负载均衡消费服务，本章主要讲述如何通过Feign去消费服务。 一、Feign 简介： Feign是一个便利的res</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/haly/p/10857752.html</dc:identifier>
</item>
</channel>
</rss>