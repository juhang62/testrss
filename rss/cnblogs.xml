<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>APS审核经验+审核资料汇总——计算机科学与技术专业上海德语审核 - Rest探路者</title>
<link>http://www.cnblogs.com/Java-Starter/p/10385600.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Java-Starter/p/10385600.html</guid>
<description>&lt;h2&gt;1.APS是什么&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;德国驻华使馆文化处留德人员审核部&lt;/strong&gt;（简称APS）成立于2001年7月，是由德国驻华使馆文化处和德意志学术交流中心（DAAD）在北京共同合作成立的服务机构。&lt;/p&gt;
&lt;p&gt;APS是中国学生前往德国留学的大门，它的主要职责是对有意赴德留学的中国学生（不包含来自香港、澳门和台湾的学历）进行资格审核。&lt;/p&gt;
&lt;p&gt;申请德国留学的申请人在获得APS证书和德国大学的录取通知书后，可通过APS递交签证申请&lt;/p&gt;

&lt;p&gt;简单地说，通过APS审核后，即半只脚踏入了德国，获得了攻读德国硕士的前提条件&lt;/p&gt;
&lt;p&gt;APS审核一生只有三次机会，请君慎重&lt;/p&gt;
&lt;h2&gt;2.APS审核资料汇总&lt;/h2&gt;
&lt;p&gt;本科期间学习了68门课程，我集中整理了20门课程（包括毕业设计）以应对APS审核，德语专业词汇均在维基百科上查阅，实在没查到的专业词汇我则用英语代替。&lt;/p&gt;
&lt;p&gt;我以专业课（计算机专业课程）和基础课程（大物、高数、线代和概率论等）为主，选修课舍弃之&lt;/p&gt;
&lt;h3&gt;2.1 德语审核资料&lt;/h3&gt;
&lt;p&gt;配两张思维导图（中文版和德文版）&lt;/p&gt;
&lt;p&gt;我按照20篇博客列举的课程大纲，黄色的星代表次优先级的科目，绿色虚线表示学科间交叉关系&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201453/201902/1201453-20190215200136361-3145545.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201453/201902/1201453-20190215200229869-1834184661.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;CategoryEntryList1_EntryStoryList_ctl00_Entries_TitleUrl_0&quot; class=&quot;entrylistItemTitle&quot; href=&quot;https://www.cnblogs.com/Java-Starter/p/9800875.html&quot;&gt;Entwurfsmuster&lt;/a&gt;&lt;span class=&quot;entrylistItemTitle&quot;&gt;（设计模式）&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;a id=&quot;CategoryEntryList1_EntryStoryList_ctl00_Entries_TitleUrl_1&quot; class=&quot;entrylistItemTitle&quot; href=&quot;https://www.cnblogs.com/Java-Starter/p/9800864.html&quot;&gt;WEB Front-end Development Technology&lt;/a&gt;（WEB前端开发技术）&lt;/p&gt;

&lt;p&gt;&lt;a id=&quot;CategoryEntryList1_EntryStoryList_ctl00_Entries_TitleUrl_2&quot; class=&quot;entrylistItemTitle&quot; href=&quot;https://www.cnblogs.com/Java-Starter/p/9800811.html&quot;&gt;Objekt Orientierte Programmierung C++&lt;/a&gt;&lt;span class=&quot;entrylistItemTitle&quot;&gt;（面向对象编程C++）&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;a id=&quot;CategoryEntryList1_EntryStoryList_ctl00_Entries_TitleUrl_3&quot; class=&quot;entrylistItemTitle&quot; href=&quot;https://www.cnblogs.com/Java-Starter/p/9779368.html&quot;&gt;Datenbanksystem&lt;/a&gt;&lt;span class=&quot;entrylistItemTitle&quot;&gt;（数据库系统）&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;a id=&quot;CategoryEntryList1_EntryStoryList_ctl00_Entries_TitleUrl_4&quot; class=&quot;entrylistItemTitle&quot; href=&quot;https://www.cnblogs.com/Java-Starter/p/9772448.html&quot;&gt;Rechnernetz&lt;/a&gt;（计算机网络）&lt;/p&gt;

&lt;p&gt;&lt;a id=&quot;CategoryEntryList1_EntryStoryList_ctl00_Entries_TitleUrl_5&quot; class=&quot;entrylistItemTitle&quot; href=&quot;https://www.cnblogs.com/Java-Starter/p/9759617.html&quot;&gt;Diskrete Mathematik&lt;/a&gt;&lt;span class=&quot;entrylistItemTitle&quot;&gt;（离散数学）&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;a id=&quot;CategoryEntryList1_EntryStoryList_ctl00_Entries_TitleUrl_6&quot; class=&quot;entrylistItemTitle&quot; href=&quot;https://www.cnblogs.com/Java-Starter/p/9753645.html&quot;&gt;Digitale Logik&lt;/a&gt;（数字逻辑）&lt;/p&gt;

&lt;p&gt;&lt;a id=&quot;CategoryEntryList1_EntryStoryList_ctl00_Entries_TitleUrl_7&quot; class=&quot;entrylistItemTitle&quot; href=&quot;https://www.cnblogs.com/Java-Starter/p/9748101.html&quot;&gt;Physik&lt;/a&gt;&lt;span class=&quot;entrylistItemTitle&quot;&gt;（大学物理）&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;a id=&quot;CategoryEntryList1_EntryStoryList_ctl00_Entries_TitleUrl_8&quot; class=&quot;entrylistItemTitle&quot; href=&quot;https://www.cnblogs.com/Java-Starter/p/9741833.html&quot;&gt;Betriebssystem&lt;/a&gt;（操作系统）&lt;/p&gt;

&lt;p&gt;&lt;a id=&quot;CategoryEntryList1_EntryStoryList_ctl00_Entries_TitleUrl_9&quot; class=&quot;entrylistItemTitle&quot; href=&quot;https://www.cnblogs.com/Java-Starter/p/9734416.html&quot;&gt;Abschlussarbeit:Konstruktion und Implementierung von Dota2 Datenbank Intelligent Verwaltungsplatfom&lt;/a&gt;&lt;span class=&quot;entrylistItemTitle&quot;&gt;（毕业设计：Dota2资料库智能管理平台）&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;a id=&quot;CategoryEntryList1_EntryStoryList_ctl00_Entries_TitleUrl_10&quot; class=&quot;entrylistItemTitle&quot; href=&quot;https://www.cnblogs.com/Java-Starter/p/9722358.html&quot;&gt;Softwaretechnik&lt;/a&gt;&lt;span class=&quot;entrylistItemTitle&quot;&gt;（软件工程）&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;a id=&quot;CategoryEntryList1_EntryStoryList_ctl00_Entries_TitleUrl_11&quot; class=&quot;entrylistItemTitle&quot; href=&quot;https://www.cnblogs.com/Java-Starter/p/9720296.html&quot;&gt;Android Anwendungsprogramm Entwicklung&lt;/a&gt;&lt;span class=&quot;entrylistItemTitle&quot;&gt;（安卓应用开发）&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;a id=&quot;CategoryEntryList1_EntryStoryList_ctl00_Entries_TitleUrl_12&quot; class=&quot;entrylistItemTitle&quot; href=&quot;https://www.cnblogs.com/Java-Starter/p/9700821.html&quot;&gt;Prinzipien der Computer Zusammensetzung&lt;/a&gt;（计算机组成原理）&lt;/p&gt;

&lt;p&gt;&lt;a id=&quot;CategoryEntryList1_EntryStoryList_ctl00_Entries_TitleUrl_13&quot; class=&quot;entrylistItemTitle&quot; href=&quot;https://www.cnblogs.com/Java-Starter/p/9693404.html&quot;&gt;Wahrscheinlichkeitstheorie und mathematische Statistik&lt;/a&gt;（概率论与数理统计）&lt;/p&gt;

&lt;p&gt;&lt;a id=&quot;CategoryEntryList1_EntryStoryList_ctl00_Entries_TitleUrl_14&quot; class=&quot;entrylistItemTitle&quot; href=&quot;https://www.cnblogs.com/Java-Starter/p/9688559.html&quot;&gt;Training Logisches Denken&lt;/a&gt;&lt;span class=&quot;entrylistItemTitle&quot;&gt;（逻辑思维训练）&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;a id=&quot;CategoryEntryList1_EntryStoryList_ctl00_Entries_TitleUrl_15&quot; class=&quot;entrylistItemTitle&quot; href=&quot;https://www.cnblogs.com/Java-Starter/p/9687626.html&quot;&gt;An Introduction to Computer Thinking&lt;/a&gt;&lt;span class=&quot;entrylistItemTitle&quot;&gt;（计算机思维导论）&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;a id=&quot;CategoryEntryList1_EntryStoryList_ctl00_Entries_TitleUrl_16&quot; class=&quot;entrylistItemTitle&quot; href=&quot;https://www.cnblogs.com/Java-Starter/p/9660847.html&quot;&gt;Compiler Principle&lt;/a&gt;（编译原理）&lt;/p&gt;

&lt;p&gt;&lt;a id=&quot;CategoryEntryList1_EntryStoryList_ctl00_Entries_TitleUrl_17&quot; class=&quot;entrylistItemTitle&quot; href=&quot;https://www.cnblogs.com/Java-Starter/p/9645565.html&quot;&gt;Lineare Algebra&lt;/a&gt;（线性代数）&lt;/p&gt;

&lt;p&gt;&lt;a id=&quot;CategoryEntryList1_EntryStoryList_ctl00_Entries_TitleUrl_18&quot; class=&quot;entrylistItemTitle&quot; href=&quot;https://www.cnblogs.com/Java-Starter/p/9634662.html&quot;&gt;Mathematik&lt;/a&gt;（高等数学）&lt;/p&gt;

&lt;p&gt;&lt;a id=&quot;CategoryEntryList1_EntryStoryList_ctl00_Entries_TitleUrl_19&quot; class=&quot;entrylistItemTitle&quot; href=&quot;https://www.cnblogs.com/Java-Starter/p/9617494.html&quot;&gt;Datenstruktur und Algorithmus（&lt;/a&gt;&lt;span class=&quot;entrylistItemTitle&quot;&gt;数据结构与算法）&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span class=&quot;entrylistItemTitle&quot;&gt;2.2 附录&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;C++语法基础和数据结构：&lt;a href=&quot;https://github.com/cjy513203427/C_Program_Base&quot; target=&quot;_blank&quot;&gt;https://github.com/cjy513203427/C_Program_Base&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;毕业设计源码已开源：&lt;a href=&quot;https://github.com/cjy513203427/Dota2_Databank&quot; target=&quot;_blank&quot;&gt;https://github.com/cjy513203427/Dota2_Databank&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;3.APS审核复习流程&lt;/h2&gt;
&lt;h3&gt;3.1 个人背景&lt;/h3&gt;
&lt;h4&gt;2.1 学习情况&lt;/h4&gt;
&lt;p&gt;国内双非本科计算机科学与技术专业，绩点2.84（大学贪玩，挂过一些科目，导致绩点不高），2018年6月毕业&lt;/p&gt;
&lt;h4&gt;2.2 家庭情况&lt;/h4&gt;
&lt;p&gt;末流二线城市中产阶级，我个人想去美国读CS，可惜家里经济条件不允许，所以我选择了性价比高的德国教育&lt;/p&gt;
&lt;h3&gt;3.2 审核进度概要&lt;/h3&gt;
&lt;p&gt;2018.9.10 提交材料&lt;/p&gt;
&lt;p&gt;2018.9.25 出审核号&lt;/p&gt;
&lt;p&gt;2019.01.08 审核部打电话通知我去审核&lt;/p&gt;
&lt;p&gt;2019.02.11下午一点审核&lt;/p&gt;
&lt;h3&gt;3.3 复习技巧&lt;/h3&gt;
&lt;p&gt;我负责任的告诉即将审核的同学和计划提交材料审核的同学，APS的准备时间至少是&lt;span&gt;两个月&lt;span&gt;，这两个月是集中准备时间，保证高强度，一天至少花六个小时在APS上面，准备时间一定程度上因人而异，如本科期间很认真，绩点很高，复习起来就快；像我这样挂过不少科的，就要一天花至少六个小时。请不要听信有些审核过的同学说一个星期或者几天就可以准备APS，这是不负责任的，如果你相信这些说法，准备个两三天去审核，很大可能挂掉。接下来你要等待三个月才能提交补审申请，准备二审。因为，语言的磨合就至少需要一个月的时间，翻看几十门专业课程需要更多的时间，APS和考研最大的不同就是没有考试范围，每一门课都有可能被问到。对于审核语言，大多数同学选择走英审，求稳，有语言基础，专业词汇方便查阅；如果你的德语达到了B2水平，大可去尝试德语审核，通过用审核官的母语与审核官交流，给审核官留下好印象。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我本科毕业后没有找工作，我从2018八月份下旬开始集中复习（处于探索阶段），前期我用中文总结APS科目，然后再翻译成德语，后来我发现这么做效率低下，不利于记忆，会导致我用中文思维思考问题，要利用好维基百科，维基百科是我获取德语资料的利器&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201453/201902/1201453-20190215205002143-1282823473.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到了九月份开始递交材料，并用德语在博客园上做APS的课程总结。到了十月份我把二十门课程总结完毕，进入了复习瓶颈期，自我感觉良好，随时能去审核，但是审核部迟迟没有动静。后来我在家实在呆不下去，十月份去找了工作，利用晚上的时间去图书馆花半小时背诵APS，在图书馆我也会看些专业课方面的书籍，这期间我自学了8086汇编语言、又刷了数据结构和机器学习相关的内容。总结地来说，&lt;span&gt;八九月份我是在集中高强度复习，从2018十月份下旬开始到2019二月份是放养式复习&lt;/span&gt;，反复地背诵。我总结出博客之后，为了背诵方便，我将博客的内容放到Word，打印成两本资料，周一到周五晚上花半小时温习背诵之。偶尔我遇到知识点不熟，我会拿出手机搜索自己的博客查缺补漏，放在互联网上的好处就是，随处可查。&lt;/p&gt;
&lt;p&gt;复习科目以专业课为主，基础课为辅，将课程梳理出目录和框架，层层递进，不要求你对这门课每个章节每个具体的知识点都知道，因为APS面谈时间只有二十分钟，你不可能说得完，你要做的是，把这门课经典的知识点总结出来，什么叫“经典的知识点”？，就是你学过这门课必会的知识点，即用两三个知识点证明你学过这门课程。审核官的目的审核你的成绩单上面的成绩是否真实可信，并非是对这门学科严格的测试，所以你不需要知识点面面俱到。&lt;/p&gt;
&lt;p&gt;以下摘自APS官网&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;请注意：&lt;/strong&gt;审核部请您理解，一般来说审核部的面谈时间不能更改！特殊情况可以更改面谈时间，但是必须出具相应的书面证明。申请人必须在约定的面谈时间到来之前跟审核部取得联系，提供相应证明。面谈语言为英语或者德语，或者德英双语。申请人自由选择面谈的语言。申请人提供的语言证明可以帮助考官判断申请人的语言能力。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;审核面谈将检查申请人是否真的具有专业知识，是否真的学过成绩单上出具的课程。从这个角度来讲，审核面谈&lt;span&gt;既不是专业考核，也不是语言考试&lt;/span&gt;。面谈涉及申请人所学的专业和具体课程。申请人不必将学过的知识全部忆述出来，但仍需要证明所学习过的课程，能描述具体的专业课内容，会运用或者将所学展示出来。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;我以计算机网络课程为例，要准备五层协议、三次握手等知识点；&lt;/p&gt;
&lt;p&gt;再以操作系统课程为例，进程状态转换、死锁的形成和预防、CPU调度等知识点；&lt;/p&gt;
&lt;p&gt;其余课程可以参考我分享的德审资料。&lt;/p&gt;

&lt;p&gt;当我把所有课程准备完毕，我列举了思维导图，我推荐使用Xmind，画思维导图可以加深你对学科的理解和学科间的相互关系，极大提高了我的复习效率，我可以通过思维导图去列举一个学科的知识点，复习起来也很方便，复习的时候，先在大脑里回忆知识点，再详细叙述知识点，一个知识点准备至少一个例子，把书从厚读薄就是这个道理。当你在审核的时候说到学科间相互联系，审核官会对你刮目相看，审核官想在最短的时间挖你老底，看你到底学了什么，你通过一个知识点一下子说了两个学科，审核官会认为，你对专业的理解非常深刻。比如离散数学的图论和数据结构与算法的图放在一起说，最小生成树、单源最短路径，DFS，BFS，克鲁斯卡尔和普里姆算法放在一起比较着叙述；再如计算机组成原理的总线异步通信的全互锁和计算机网络运输层TCP三次握手相关联。&lt;/p&gt;

&lt;p&gt;以下摘自APS官网&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;em&gt;复习一遍成绩单提到的科目，着重复习其中最重要的内容。您不需要为了审核面谈再学习任何专业知识，您也不用回忆起所学的全部课程内容！针对审核面谈的准备班尤其&lt;span&gt;没有意义&lt;/span&gt;。&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;请您确保您已了解以您申请的审核语言进行翻译的所有课程名称。&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;您可以在审核面谈中用德语或英语，又或者用两种语言陈述您所学过的大学课程。但不能用汉语！您的德语或英语水平应该达到能够理解考官的问题，回答考官的问题，并且能够简短的介绍自己所学的科目。&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;仔细听考官的问题，并回答他的问题，如果您没有听懂他的话，可以请求他重复一遍问题或解释一下问题。&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;尽量只回答提出的问题。请记住，您只有20分钟的时间来展示自己。&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;请您具体的讲述您在课上都做了些什么和都学了些什么。举出例子。您可以用&lt;span&gt;绘画，图表，表格，公式和方程式&lt;/span&gt;表述您的课程。您只是不该沉默！&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;请您千万不要只给出泛泛的定义和&lt;span&gt;不要背诵&lt;/span&gt;您之前准备的知识，而您本身并不理解它。&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;4.APS审核经历&lt;/h2&gt;
&lt;p&gt;2019年1月8号，我提前预定了德国中心附近的如家酒店，2月10日入住。离德国中心有七百多米的路程。&lt;/p&gt;
&lt;p&gt;2月10号上午九点多从合肥出发，和高中同学一起去上海，他去上海上班。中午十二点到达上海虹桥。下午我本来打算去德国中心熟悉下环境，耐不住高中同学的盛情款待，下午三点和他一起吃了肯德基，去他租住的地方参观，然后打了四五把星际争霸2天梯，到六点我从他那里坐地铁到张江高科。下地铁，入住酒店。由于下午三点吃饭不饿，我在如家酒店周围转了转，慢条斯理地走到德国中心，下图是德国中心夜景&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201453/201902/1201453-20190215222318247-222066600.jpg&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;
&lt;p&gt;回来的路上，在全家超市购买了方便面和第二天（二月十一号）的早饭，因为二月十号是初六，好多店面没有开门，晚上回去吃了泡面。回酒店百无聊赖，于是和德国朋友在微信上练习口语一个小时，熟悉语言环境。大概晚上九点钟就没事情做了，我把SpringMVC的流程图默写了一遍，又看了下思维导图，此时我发现，再看具体的知识点已经力不从心，内容太多，只能根据思维导图的目录来回忆。十点钟我开始刷头条、看B站游戏视频，因为第二天下午一点才审核，可以睡个懒觉，我到晚上十二点半才睡觉。&lt;/p&gt;
&lt;p&gt;第二天睡到九点醒，我拿出思维导图，在默默地回忆学科的知识点和学科交叉关系，于是又看B站视频了，上午十一点五十退房。慢慢悠悠地走到审核部。&lt;/p&gt;
&lt;p&gt;审核部外景图如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201453/201902/1201453-20190215223030197-44363829.jpg&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201453/201902/1201453-20190215223052734-596366492.jpg&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;
&lt;p&gt;进入德国中心，审核教室在619-620室，我发现我是第一个到的，在室内闲逛&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201453/201902/1201453-20190215223338728-2027109775.jpg&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我发现我是第一个来的，等到十二点半，陆续来了一起审核的小伙伴，加上我四个人，和他们闲聊，一位是同济计算机专业的帅哥，走英审、一位是上交计算机专业的帅哥，走英审，和我一样，都是2018年毕业的，还有一位同济德语专业大四的小妹妹，走德审。我们互相鼓励，相谈盛欢，互相加了微信。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201453/201902/1201453-20190215231826779-1875646518.jpg&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下图是审核教室，我来早了，还没开门&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201453/201902/1201453-20190215225939778-1667519669.jpg&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到了一点半，我们进入了审核教室，先拿着身份证去拍照，作为身份认证。后来办公人员（中国人）让我们签保密协议，就是讲审核内容不可以对外界泄露。先是同济帅哥被审核官叫去审核，第二位就到我了。审核官问我用什么语言审核，我说用德语，审核官说&quot;Sehr gut&quot;，主审让我把包和衣服寄存起来，通信设备全部上交。审核官把我带进了小黑屋去做笔试题，我犯了失误，用“du”称呼了审核官，审核官提醒我用&quot;Sie&quot;，还好没酿成大错。笔试时间二十分钟。接着主审核官带我进入了审核教室。审核教室坐着俩人，左边是副审，负责记笔记，右边是主审，负责盘问我，两位都是德国老爷爷。主审笑着怼我，问了我一些专业课问题和一门基础课。面谈时间过得好快，二十分钟就这么结束了。&lt;/p&gt;
&lt;p&gt;由于签了保密协议，我不方便泄露审核具体内容。我可以说说大致方向，我看了主审老爷爷用荧光笔圈了我的几门课，都是我&lt;span&gt;挂过的课和取得高分的课&lt;/span&gt;。&lt;/p&gt;

&lt;p&gt;2019年2月14日，我在APS官网查到了结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201453/201902/1201453-20190215232227126-1995676920.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;4.参考&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://baike.baidu.com/item/APS/19680714?fr=aladdin&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://baike.baidu.com/item/APS/19680714?fr=aladdin&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://www.aps.org.cn/zh/verfahren-und-services-deutschland/chinaverfahren/interview&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://www.aps.org.cn/zh/verfahren-und-services-deutschland/chinaverfahren/interview&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 15 Feb 2019 15:45:00 +0000</pubDate>
<dc:creator>Rest探路者</dc:creator>
<og:description>1.APS是什么 德国驻华使馆文化处留德人员审核部（简称APS）成立于2001年7月，是由德国驻华使馆文化处和德意志学术交流中心（DAAD）在北京共同合作成立的服务机构。 APS是中国学生前往德国留学</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Java-Starter/p/10385600.html</dc:identifier>
</item>
<item>
<title>【模板】康托展开 - Fugtemypt</title>
<link>http://www.cnblogs.com/YSFAC/p/10386201.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/YSFAC/p/10386201.html</guid>
<description>&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;strong&gt;本文所有的排名均是从第0名开始。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;康托展开：&lt;/p&gt;
&lt;p&gt;已知一个$1—n$的排列$A=\{a_1,a_2,\cdots,a_n\}$，求它在所有排列中的字典序排名。&lt;/p&gt;
&lt;p&gt;常用于将$n$个全排列映射到$n!$个自然数中。&lt;/p&gt;

&lt;p&gt;求解这个问题的思路大概是下面这样的：&lt;/p&gt;
&lt;p&gt;$(1)$ $A$的排名=字典序小于$A$的排列个数。所以只需要知道有多少个排列比$A$小就好了w&lt;/p&gt;
&lt;p&gt;$(2)$ 我们按位考虑，第一位小于$a_1$的所有排列肯定比$A$小，这部分有$(a_{1}-1)\times (n-1)!$个。&lt;/p&gt;
&lt;p&gt;$(3)$ 在第一个数等于$a_1$的所有排列中，第二位小于$a_2$的所有排列也肯定比$A$小。&lt;/p&gt;
&lt;p&gt;　   那么这部分有$(a_{2}-1)\times (n-2)!$个对不对？&lt;/p&gt;
&lt;p&gt;　   但是这个时候出现了一个问题：&lt;/p&gt;
&lt;p&gt;　   如果$a_{1}&amp;lt;a_{2}$，那么第二位就不能再用$a_1$这个数了（因为是排列）。&lt;/p&gt;
&lt;p&gt;　   所以应该有$(a_{2}-2)\times (n-2)!$个。&lt;/p&gt;
&lt;p&gt;　   当然如果$a_{1}&amp;gt;a_{2}$就不需要额外$-1$了w&lt;/p&gt;
&lt;p&gt;$(4)$ 现在我们把$(3)$的结论推广，&lt;/p&gt;
&lt;p&gt;　   前$i-1$位与$A$相同且第$i$位小于$A$的排列，共有$(a_{i}-cnt_{i}-1)\times (n-i)!$个。&lt;/p&gt;
&lt;p&gt;　   其中$cnt_i$表示$\{a_{1},a_{2},\cdots ,a_{i-1}\}$中小于$a_i$的个数。&lt;/p&gt;
&lt;p&gt;　   显然所有这样的排列加起来就是比$A$小的排列总数（有序统计）。&lt;/p&gt;
&lt;p&gt;$(5)$ 注意到$a_{i}-cnt_{i}-1$还等于后$\{a_{i},a_{i+1},\cdots ,a_{n}\}$中小于$a_i$的个数（因为是排列……）。&lt;/p&gt;
&lt;p&gt;　   所以我们就得到了康托展开公式：&lt;/p&gt;
&lt;p&gt;　   $Rank_{A}=b_{n}\times (n-1)!+b_{n-1}\times (n-2)!+\cdots +b_1 \times 0!$&lt;/p&gt;
&lt;p&gt;　   其中$b_{i}$表示$a_i$在当前未出现的$a$中排在第几个。&lt;/p&gt;

&lt;p&gt;关于实现，只需要按定义模拟即可。&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
inline &lt;span&gt;int&lt;/span&gt;&lt;span&gt; Cantor(){
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; rank=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=N;i++&lt;span&gt;){
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; s=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; j=i+&lt;span&gt;1&lt;/span&gt;;j&amp;lt;=N;j++&lt;span&gt;)
            s&lt;/span&gt;+=(A[j]&amp;lt;&lt;span&gt;A[i]);
        rank&lt;/span&gt;+=s*jc[N-&lt;span&gt;i];
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; rank;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;hr/&gt;
&lt;p&gt;逆康托展开：&lt;/p&gt;
&lt;p&gt;和上面相反，已知某排列的排名$x$，求这个排列。&lt;/p&gt;

&lt;p&gt;解决思路基本没区别（说是相反也行）：&lt;/p&gt;
&lt;p&gt;假设我们现在要求$a_i$的值，首先可以得到$b_i=x\div (n-i)!$。&lt;/p&gt;
&lt;p&gt;那么也就是知道了$a_i$在当前未出现过的$a$中的排名。&lt;/p&gt;
&lt;p&gt;但仅仅知道这个不能直接计算，所以我们还要记录一下前$i-1$位出现过的$a$。&lt;/p&gt;
&lt;p&gt;然后$O(n)$枚举求出答案。&lt;/p&gt;

&lt;p&gt;下面是一个例子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/966171/201902/966171-20190215233708767-213118793.png&quot; alt=&quot;&quot; width=&quot;330&quot; height=&quot;72&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时$n=8,i=4$，前$3$位出现了$1,4,6$。&lt;/p&gt;
&lt;p&gt;假设$b_i=3$，那么$a_i$在未出现的数里排名第$3$。&lt;/p&gt;
&lt;p&gt;由于排名是从$0$开始的，$a_i$就是灰色的第$4$个数$7$。&lt;/p&gt;

&lt;p&gt;代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
inline &lt;span&gt;void&lt;/span&gt; inv_Cantor(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; x){
    memset(vis,&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(vis));
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=N;i++&lt;span&gt;){
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; tp=x/jc[N-&lt;span&gt;i];
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; j=&lt;span&gt;1&lt;/span&gt;;j&amp;lt;=N;j++&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(vis[j]) &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
             &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(tp==&lt;span&gt;0&lt;/span&gt;&lt;span&gt;){
                 vis[j]&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;,A[i]=&lt;span&gt;j;
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            } tp&lt;/span&gt;--&lt;span&gt;;
        }
        x&lt;/span&gt;=x%jc[N-&lt;span&gt;i];
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;hr/&gt;
&lt;p&gt;模板题目：&lt;a href=&quot;https://loj.ac/problem/10027&quot; target=&quot;_blank&quot;&gt;loj10027&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码：（&lt;strong&gt;这题的排名是从1开始的&lt;/strong&gt;）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
#include&amp;lt;algorithm&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;iostream&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;cstring&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;cstdio&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;queue&amp;gt;

&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt;#define&lt;/span&gt; MAXN 10
&lt;span&gt;#define&lt;/span&gt; MAXM 1000005
&lt;span&gt;#define&lt;/span&gt; INF 0x7fffffff
&lt;span&gt;#define&lt;/span&gt; ll long long&lt;span&gt;

inline &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; read(){
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; x=&lt;span&gt;0&lt;/span&gt;,f=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; c=&lt;span&gt;getchar();
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(;!isdigit(c);c=&lt;span&gt;getchar())
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(c==&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
            f&lt;/span&gt;=-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(;isdigit(c);c=&lt;span&gt;getchar())
        x&lt;/span&gt;=x*&lt;span&gt;10&lt;/span&gt;+c-&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; x*&lt;span&gt;f;
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; N=&lt;span&gt;8&lt;/span&gt;&lt;span&gt;,dis[MAXM],com[MAXM];
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; jc[MAXN],A[MAXN],last[MAXM];
&lt;/span&gt;&lt;span&gt;bool&lt;/span&gt;&lt;span&gt; vis[MAXM],vvis[MAXN];

inline &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; Cantor(){
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; rank=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=N;i++&lt;span&gt;){
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; s=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; j=i+&lt;span&gt;1&lt;/span&gt;;j&amp;lt;=N;j++&lt;span&gt;)
            s&lt;/span&gt;+=(A[j]&amp;lt;&lt;span&gt;A[i]);
        rank&lt;/span&gt;+=s*jc[N-&lt;span&gt;i];
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; rank+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
}

inline &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; inv_Cantor(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; x){
    x&lt;/span&gt;-=&lt;span&gt;1&lt;/span&gt;; memset(vvis,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(vvis));
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=N;i++&lt;span&gt;){
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; tp=x/jc[N-&lt;span&gt;i];
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; j=&lt;span&gt;1&lt;/span&gt;;j&amp;lt;=N;j++&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(vvis[j]) &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
             &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(tp==&lt;span&gt;0&lt;/span&gt;&lt;span&gt;){
                 vvis[j]&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;,A[i]=&lt;span&gt;j;
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            } tp&lt;/span&gt;--&lt;span&gt;;
        }
        x&lt;/span&gt;=x%jc[N-&lt;span&gt;i];
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
}

inline &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; get1(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; x){
    inv_Cantor(x);
    swap(A[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;],A[&lt;span&gt;8&lt;/span&gt;&lt;span&gt;]);
    swap(A[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;],A[&lt;span&gt;7&lt;/span&gt;&lt;span&gt;]);
    swap(A[&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;],A[&lt;span&gt;6&lt;/span&gt;&lt;span&gt;]);
    swap(A[&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;],A[&lt;span&gt;5&lt;/span&gt;&lt;span&gt;]);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Cantor();
}

inline &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; get2(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; x){
    inv_Cantor(x);
    swap(A[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;],A[&lt;span&gt;4&lt;/span&gt;&lt;span&gt;]);
    swap(A[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;],A[&lt;span&gt;4&lt;/span&gt;&lt;span&gt;]);
    swap(A[&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;],A[&lt;span&gt;4&lt;/span&gt;&lt;span&gt;]);
    swap(A[&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;],A[&lt;span&gt;8&lt;/span&gt;&lt;span&gt;]);
    swap(A[&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;],A[&lt;span&gt;6&lt;/span&gt;&lt;span&gt;]);
    swap(A[&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;],A[&lt;span&gt;7&lt;/span&gt;&lt;span&gt;]);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Cantor();
}

inline &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; get3(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; x){
    inv_Cantor(x);
    swap(A[&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;],A[&lt;span&gt;7&lt;/span&gt;&lt;span&gt;]);
    swap(A[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;],A[&lt;span&gt;3&lt;/span&gt;&lt;span&gt;]);
    swap(A[&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;],A[&lt;span&gt;7&lt;/span&gt;&lt;span&gt;]);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Cantor();
}

inline &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; init(){
    jc[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;]=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=N;i++&lt;span&gt;) 
        jc[i]&lt;/span&gt;=jc[i-&lt;span&gt;1&lt;/span&gt;]*&lt;span&gt;i;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
}

inline &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; print(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; u){
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(u==&lt;span&gt;1&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    print(com[u]);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(last[u]==&lt;span&gt;1&lt;/span&gt;) printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(last[u]==&lt;span&gt;2&lt;/span&gt;) printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(last[u]==&lt;span&gt;3&lt;/span&gt;) printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; BFS(){
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; end=&lt;span&gt;Cantor();
    queue&lt;/span&gt;&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; q; q.push(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    dis[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;]=&lt;span&gt;0&lt;/span&gt;,vis[&lt;span&gt;1&lt;/span&gt;]=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(!&lt;span&gt;q.empty()){
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; u=&lt;span&gt;q.front(); q.pop();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(u==&lt;span&gt;end){
            printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,dis[u]);
            print(u);
            printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; t1=get1(u),t2=get2(u),t3=&lt;span&gt;get3(u);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;vis[t1]){
            dis[t1]&lt;/span&gt;=dis[u]+&lt;span&gt;1&lt;/span&gt;,vis[t1]=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
            last[t1]&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;,com[t1]=&lt;span&gt;u;
            q.push(t1);    
        }    
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;vis[t2]){
            dis[t2]&lt;/span&gt;=dis[u]+&lt;span&gt;1&lt;/span&gt;,vis[t2]=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
            last[t2]&lt;/span&gt;=&lt;span&gt;2&lt;/span&gt;,com[t2]=&lt;span&gt;u;
            q.push(t2);
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;vis[t3]){
            dis[t3]&lt;/span&gt;=dis[u]+&lt;span&gt;1&lt;/span&gt;,vis[t3]=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
            last[t3]&lt;/span&gt;=&lt;span&gt;3&lt;/span&gt;,com[t3]=&lt;span&gt;u;
            q.push(t3);
        }
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main(){
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=N;i++&lt;span&gt;) 
        A[i]&lt;/span&gt;=&lt;span&gt;read();
    init(); BFS();
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Fri, 15 Feb 2019 15:45:00 +0000</pubDate>
<dc:creator>Fugtemypt</dc:creator>
<og:description>注意：本文所有的排名均是从第0名开始。 康托展开： 已知一个$1—n$的排列$A=\{a_1,a_2,\cdots,a_n\}$，求它在所有排列中的字典序排名。 常用于将$n$个全排列映射到$n!$个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/YSFAC/p/10386201.html</dc:identifier>
</item>
<item>
<title>Springboot+JdbcTemplate +thymeleaf 页面  做迷你版的bug系统 - 夏天里的Jasmine</title>
<link>http://www.cnblogs.com/qianjinyan/p/10097451.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qianjinyan/p/10097451.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/qianjinyan/p/10065160.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/qianjinyan/p/10065160.html&lt;/a&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在我上一篇随笔中介绍了关于要做的系统的数据结构，连接如上&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;今天实现连接mssql server，查询出所有buglist的效果，CRUD&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;实现方法极其简单，如下图&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1064427/201812/1064427-20181221101645218-749977777.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　Bug类对象中列出字段&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;59&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
package com.jasmine.demo.bean;

public class Bug {

    private long id;
    private String pname;
    private String crname;
    private String crnum;
    private String tasknum;
    private String oname;
    private String description;
    private String rca;
    private String solution;
    private String developer;
    private String tester;
    private String creationdt;
    private String updatedt;

    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    public String getPname() {
        return pname;
    }

    public void setPname(String pname) {
        this.pname = pname;
    }

    public String getCrname() {
        return crname;
    }

    public void setCrname(String crname) {
        this.crname = crname;
    }

    public String getCrnum() {
        return crnum;
    }

    public void setCrnum(String crnum) {
        this.crnum = crnum;
    }

    public String getTasknum() {
        return tasknum;
    }

    public void setTasknum(String tasknum) {
        this.tasknum = tasknum;
    }

    public String getOname() {
        return oname;
    }

    public void setOname(String oname) {
        this.oname = oname;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public String getRca() {
        return rca;
    }

    public void setRca(String rca) {
        this.rca = rca;
    }

    public String getSolution() {
        return solution;
    }

    public void setSolution(String solution) {
        this.solution = solution;
    }

    public String getDeveloper() {
        return developer;
    }

    public void setDeveloper(String developer) {
        this.developer = developer;
    }

    public String getTester() {
        return tester;
    }

    public void setTester(String tester) {
        this.tester = tester;
    }

    public String getCreationdt() {
        return creationdt;
    }

    public void setCreationdt(String creationdt) {
        this.creationdt = creationdt;
    }

    public String getUpdatedt() {
        return updatedt;
    }

    public void setUpdatedt(String updatedt) {
        this.updatedt = updatedt;
    }

    @Override
    public String toString() {
        return &quot;Bug{&quot; +
                &quot;id=&quot; + id +
                &quot;, pname='&quot; + pname + '\'' +
                &quot;, crname='&quot; + crname + '\'' +
                &quot;, crnum='&quot; + crnum + '\'' +
                &quot;, tasknum='&quot; + tasknum + '\'' +
                &quot;, oname='&quot; + oname + '\'' +
                &quot;, description='&quot; + description + '\'' +
                &quot;, rca='&quot; + rca + '\'' +
                &quot;, solution='&quot; + solution + '\'' +
                &quot;, developer='&quot; + developer + '\'' +
                &quot;, tester='&quot; + tester + '\'' +
                &quot;, creationdt='&quot; + creationdt + '\'' +
                &quot;, updatedt='&quot; + updatedt + '\'' +
                '}';
    }

    public Bug() {
        super();
    }

    public Bug(long id, String pname, String crname, String crnum, String tasknum, String oname, String description, String rca, String solution, String developer, String tester, String creationdt, String updatedt) {
        this.id = id;
        this.pname = pname;
        this.crname = crname;
        this.crnum = crnum;
        this.tasknum = tasknum;
        this.oname = oname;
        this.description = description;
        this.rca = rca;
        this.solution = solution;
        this.developer = developer;
        this.tester = tester;
        this.creationdt = creationdt;
        this.updatedt = updatedt;
    }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;pre&gt;
BugService 接口中定义了增删查改等方法&lt;br/&gt;具体实现是在对应的impl中
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;52&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
package com.jasmine.demo.service;

import com.jasmine.demo.bean.Bug;

import java.util.List;

public interface BugService {

    List&amp;lt;Bug&amp;gt; findAll();

    Bug findById(int id);

    int create(String pname,String crname,String crnum, String tasknum, String oname, String description, String rca, String solution, String developer, String tester);

    int update(long id, String crnum, String tasknum, String oname, String description, String rca, String solution, String developer, String tester);

    int deleteByID(int id);


}
&lt;/pre&gt;&lt;/div&gt;


&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;131&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
package com.jasmine.demo.service.impl;

import com.jasmine.demo.bean.Bug;
import com.jasmine.demo.jdbc.BugRowMapper;
import com.jasmine.demo.service.BugService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
public class BugServiceImpl implements BugService {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    @Override
    public List&amp;lt;Bug&amp;gt; findAll() {

        String sql = &quot;SELECT BUG_ID,PROJECT_NAME,CR_NAME,BUG_CR_NUM,BUG_TASK_NUM,OBJECT_NAME,BUG_DESCRIPTION\n&quot; +
                &quot;,BUG_RCA,BUG_SOLUTION,B.EMPLOY_NAME DEVELOPER,A.EMPLOY_NAME TESTER,QA_CREATIONDT,QA_UPDATEDT,BUG_DELETED_FLAG\n&quot; +
                &quot;FROM QA_BUGLIST\n&quot; +
                &quot;JOIN QA_PROJECT ON BUG_PROJECT_ID = PROJECT_ID\n&quot; +
                &quot;JOIN QA_CRTYPE ON CR_ID = BUG_CR_TYPE_ID\n&quot; +
                &quot;JOIN QA_RTYPE ON OBJECT_ID = QA_TYPE_ID\n&quot; +
                &quot;JOIN QA_EMPLOY A ON A.[EMPLOY_ID] = QA_TESTER_ID AND A.[EMPLOY_GROUP] = 1 ---表示测试\n&quot; +
                &quot;JOIN QA_EMPLOY B ON B.[EMPLOY_ID] = QA_ASSIGNEE_ID AND B.[EMPLOY_GROUP] = 2 ---表示开发人员\n&quot; +
                &quot;WHERE BUG_DELETED_FLAG =0 order by 1 desc&quot;;
        List&amp;lt;Bug&amp;gt; bugs = jdbcTemplate.query(sql,new BugRowMapper() );
        return bugs;

    }

    @Override
    public Bug findById(int id) {
        String sql = &quot;SELECT BUG_ID,PROJECT_NAME,CR_NAME,isnull(BUG_CR_NUM,'') as BUG_CR_NUM,isnull(BUG_TASK_NUM,'') as BUG_TASK_NUM,OBJECT_NAME,isnull(BUG_DESCRIPTION,'') as BUG_DESCRIPTION\n&quot; +
                &quot;,isnull(BUG_RCA,'') as BUG_RCA,isnull(BUG_SOLUTION,'') as BUG_SOLUTION,B.EMPLOY_NAME DEVELOPER,A.EMPLOY_NAME TESTER,QA_CREATIONDT,QA_UPDATEDT,BUG_DELETED_FLAG\n&quot; +
                &quot;FROM QA_BUGLIST\n&quot; +
                &quot;JOIN QA_PROJECT ON BUG_PROJECT_ID = PROJECT_ID\n&quot; +
                &quot;JOIN QA_CRTYPE ON CR_ID = BUG_CR_TYPE_ID\n&quot; +
                &quot;JOIN QA_RTYPE ON OBJECT_ID = QA_TYPE_ID\n&quot; +
                &quot;JOIN QA_EMPLOY A ON A.[EMPLOY_ID] = QA_TESTER_ID AND A.[EMPLOY_GROUP] = 1 ---表示测试\n&quot; +
                &quot;JOIN QA_EMPLOY B ON B.[EMPLOY_ID] = QA_ASSIGNEE_ID AND B.[EMPLOY_GROUP] = 2 ---表示开发人员\n&quot; +
                &quot;WHERE BUG_DELETED_FLAG =0 and BUG_ID = ?&quot;;
        Bug bug = jdbcTemplate.queryForObject(sql,new BugRowMapper(),id);
        return bug;
    }

    @Override
    public int create(String pname,String crname,String crnum, String tasknum, String oname, String description, String rca, String solution, String developer, String tester) {
        String sql =&quot;INSERT QA_BUGLIST(BUG_PROJECT_ID,BUG_CR_TYPE_ID,BUG_CR_NUM,BUG_TASK_NUM,QA_TYPE_ID,BUG_DESCRIPTION,BUG_RCA,BUG_SOLUTION,QA_ASSIGNEE_ID,QA_TESTER_ID,QA_CREATIONDT,QA_UPDATEDT)\n&quot; +
                &quot;VALUES(?,?,?,?,?,?,?,?,?,?,GETDATE(),GETDATE())&quot;;
        return jdbcTemplate.update(sql,pname,crname,crnum,tasknum,oname,description,rca,solution,developer,tester);
    }

    @Override
    public int update(long id, String crnum, String tasknum,  String description, String rca, String solution, String developer, String tester,String oname){
        String sql = &quot;update QA_BUGLIST set BUG_CR_NUM =?,BUG_TASK_NUM =?,BUG_DESCRIPTION=?,BUG_RCA=?,BUG_SOLUTION= ?,QA_UPDATEDT =getdate() where BUG_ID = ?&quot;;
        System.out.println(sql);
        return jdbcTemplate.update(sql,crnum,tasknum,description,rca,solution,id);
    }

    @Override
    public int deleteByID(int id) {
        String sql = &quot;update QA_BUGLIST set BUG_DELETED_FLAG = 1,  BUG_DELETED_COMMENT = '逻辑删除' where BUG_ID = ?&quot;;
        System.out.println(sql);
         int count = jdbcTemplate.update(sql,id);
        return count;
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;span readability=&quot;2&quot;&gt;&lt;p&gt;DB的配置写在application.xml中&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1064427/201812/1064427-20181210165352406-1012878386.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;启动类之后，跳转的所有页面，写在controller中，&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;启动后，打开连接，看到自己的数据&lt;/span&gt;&lt;/pre&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接下来要做的就是让页面好看一点，这样的数据看不清楚&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;JdbcTemplate&lt;/p&gt;
&lt;p&gt;thymeleaf&lt;/p&gt;

&lt;p&gt;页面跳转等等，页面比较丑，还没做分页，搜寻条件也没有添加&lt;/p&gt;
&lt;p&gt;1. 查看所有bug&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1064427/201812/1064427-20181221102132717-1972310388.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2. 查看指定bug的详细信息&lt;/p&gt;
&lt;p&gt;点击查看按钮后显示单个bug的信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1064427/201812/1064427-20181221102236035-1042425021.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3. 删除单列bug信息，点击单个bug信息后面的删除按钮即可删除，删除之前最好有确定按钮用来提示，以免误删&lt;/p&gt;
&lt;p&gt;4. 更新，我这边做在查看单个详细列表页面中，如上图，有信息更新按钮，点击后带入原先的参数跳转到更新页面，在新的页面进行更新，然后保存&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1064427/201812/1064427-20181221102524596-816702562.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;5. 新增bug页面，在查看所有bug页面有新增按钮，点击进入如下页面，保存进行新增操作&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1064427/201812/1064427-20181221102617004-117888436.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 源代码提交在github地址如下：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://github.com/JasmineQian/SpringbootDemoDay03&quot; target=&quot;_blank&quot;&gt; https://github.com/JasmineQian/SpringbootDemoDay03&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/JasmineQian/SpringDemoDay03&quot; target=&quot;_blank&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 15 Feb 2019 15:44:00 +0000</pubDate>
<dc:creator>夏天里的Jasmine</dc:creator>
<og:description>https://www.cnblogs.com/qianjinyan/p/10065160.html 在我上一篇随笔中介绍了关于要做的系统的数据结构，连接如上 今天实现连接mssql server，查</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qianjinyan/p/10097451.html</dc:identifier>
</item>
<item>
<title>结构体 - 巫师笔记</title>
<link>http://www.cnblogs.com/lvfengkun/p/10385690.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lvfengkun/p/10385690.html</guid>
<description>&lt;p&gt;1、结构体变量的初始化&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
#include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;StdAfx.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;stdio.h&amp;gt;


&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; 
    {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; num;
        &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *&lt;span&gt;name;
        &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt; sex;
        &lt;/span&gt;&lt;span&gt;float&lt;/span&gt;&lt;span&gt; score;
    }boy1,boy2&lt;/span&gt;={&lt;span&gt;102&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Jane&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;M&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;98.5&lt;/span&gt;&lt;span&gt;};
    boy1&lt;/span&gt;=&lt;span&gt;boy2;
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;number=%d\nname=%s\nscore=%f\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,boy1.num,boy1.name,boy1.score);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;number=%d\nname=%s\nscore=%f\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,boy2.num,boy2.name,boy2.score);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、结构体数组&lt;/p&gt;
&lt;p&gt;一个结构体变量中可以存放一组数据（如一个学生的学号，姓名，成绩等数据）。若有10个学生的数据需要参加运算，显然应用数组，这就是结构体数组。结构体数组与数值型数组不同之处在于每一个数组元素都是一个结构体类型的数据，它们都分别包括各个成员项。&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
#include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;StdAfx.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;stdlib.h&amp;gt;
&lt;span&gt;#define&lt;/span&gt; NUM 3
&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; person
{
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; name[&lt;span&gt;20&lt;/span&gt;&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; phone[&lt;span&gt;10&lt;/span&gt;&lt;span&gt;];
};
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; person man[NUM];
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;NUM;i++&lt;span&gt;)
    {
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;input name:\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        gets(man[i].name);
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;input phone:\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        gets(man[i].phone);
    }
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\tname\t\t\tphone\n\n\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;NUM;i++&lt;span&gt;)
    {
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%10s\t\t%10s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,man[i].name,man[i].phone);
    }
    system(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pause&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;定义结构体数组&lt;/p&gt;
&lt;p&gt;与其他类型数组一样，对结构体数组也可以初始化。&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; student
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; num;
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; name[&lt;span&gt;20&lt;/span&gt;&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt; sex;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; age;
    &lt;/span&gt;&lt;span&gt;float&lt;/span&gt;&lt;span&gt; score;
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; addr[&lt;span&gt;30&lt;/span&gt;&lt;span&gt;];
}stu[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;] =&lt;span&gt; {
    {&lt;/span&gt;&lt;span&gt;101&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LILIN&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;m&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;18&lt;/span&gt;,&lt;span&gt;97.5&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;beijing&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;},
    {&lt;/span&gt;&lt;span&gt;102&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;zhang&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;f&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;17&lt;/span&gt;,&lt;span&gt;99&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;shanghai&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也可用如下形式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; student
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; num;
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; name[&lt;span&gt;20&lt;/span&gt;&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt; sex;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; age;
    &lt;/span&gt;&lt;span&gt;float&lt;/span&gt;&lt;span&gt; score;
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; addr[&lt;span&gt;30&lt;/span&gt;&lt;span&gt;];
};
&lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; student str[&lt;span&gt;2&lt;/span&gt;] =&lt;span&gt; {
    {&lt;/span&gt;&lt;span&gt;101&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LILIN&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;m&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;18&lt;/span&gt;,&lt;span&gt;97.5&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;beijing&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;},
    {&lt;/span&gt;&lt;span&gt;102&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;zhang&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;f&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;17&lt;/span&gt;,&lt;span&gt;99&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;shanghai&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;即先声明结构体类型，然后定义数组为该结构体类型，在定义数组是初始化。&lt;/p&gt;
&lt;p&gt;3、指向结构i数据类型的指针&lt;/p&gt;
&lt;p&gt;一个结构体变量的指针就是该结构体变量所占据的内存段的起始地址。&lt;/p&gt;
&lt;p&gt;可以设一个指针变量，用来指向一个结构体变量，此时该指针变量的值是结构体变量的起始地址。&lt;/p&gt;
&lt;p&gt;指针变量也可以用来指向结构体数组中的元素。&lt;/p&gt;
&lt;p&gt;说明的一般形式：struct 结构名 *结构指针变量名&lt;/p&gt;
&lt;p&gt;例：已说明一个指向stu的指针变量pstu，struct stu*pstu;也可在定义stu结构的同时说明pstu。&lt;/p&gt;
&lt;p&gt;与之前讨论的各类指针变量相同，结构指针变量也必须先赋值，然后才能使用。&lt;/p&gt;
&lt;p&gt;赋值是把结构变量的首地址赋予该指针变量，不能把结构名赋予该指针变量。&lt;/p&gt;
&lt;p&gt;例：若boy是被说明为stu类型的结构变量，则：pstu=&amp;amp;boy是正确的，而pstu=&amp;amp;stu是错误的。&lt;/p&gt;
&lt;p&gt;原因：结构名和结构变量是两个不同的概念，结构名只能表示一个结构形式，系统并不能为其分配内存空间，只有当某个变量被说明为这种类型的结构时，才能对变量分配内存空间。&lt;/p&gt;
&lt;p&gt;调用的一般形式为：（*结构指针变量）.成员名或为：结构指针变量→成员名&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
#include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;StdAfx.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;stdio.h&amp;gt;
&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; stu
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; num;
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *&lt;span&gt;name;
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt; sex;
    &lt;/span&gt;&lt;span&gt;float&lt;/span&gt;&lt;span&gt; score;
}boy1&lt;/span&gt;={&lt;span&gt;102&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;kun&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;m&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;98.5&lt;/span&gt;&lt;span&gt;};
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; stu *&lt;span&gt;pstu;
    pstu&lt;/span&gt;=&amp;amp;&lt;span&gt;boy1;
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;number=%d\nname=%s\nsex=%c\nscore=%f\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,boy1.num,boy1.name,boy1.sex,boy1.score);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;number=%d\nname=%s\nsex=%c\nscore=%f\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,(*pstu).num,(*pstu).name,(*pstu).sex,(*&lt;span&gt;pstu).score);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Fri, 15 Feb 2019 15:30:00 +0000</pubDate>
<dc:creator>巫师笔记</dc:creator>
<og:description>1、结构体变量的初始化 例： 2、结构体数组 一个结构体变量中可以存放一组数据（如一个学生的学号，姓名，成绩等数据）。若有10个学生的数据需要参加运算，显然应用数组，这就是结构体数组。结构体数组与数值</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lvfengkun/p/10385690.html</dc:identifier>
</item>
<item>
<title>三目运算及选择结构的练习😊 - 唐T</title>
<link>http://www.cnblogs.com/www520/p/10386463.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/www520/p/10386463.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;span&gt;★&lt;/span&gt;三目运算和选择结构的练习&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.)三目运算(也称三元运算)：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  a&amp;gt;b?a:b(a代表true，b为false)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;span&gt;a&amp;gt;b?(a&amp;gt;c?a:c):(b&amp;gt;c?b:c)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在几个数字的比较中作判断（例：判断三个值的大小）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.)选择结构：if（x）、if...else 、if...else if...、&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;*&lt;/span&gt;注意x中代表的是boolean值或者Boolean类型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;3.)案例练习&lt;/span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1600354/201902/1600354-20190215231446682-1364939436.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1600354/201902/1600354-20190215231504306-2086086343.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt; &lt;span&gt; 注意：&lt;span lang=&quot;EN-US&quot;&gt;if后面的&lt;span lang=&quot;EN-US&quot;&gt;{}可以省略的，没有&lt;span lang=&quot;EN-US&quot;&gt;{}它只管一行代码&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;键盘录入的方式：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1600354/201902/1600354-20190215232559966-8973738.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 15 Feb 2019 15:30:00 +0000</pubDate>
<dc:creator>唐T</dc:creator>
<og:description>★三目运算和选择结构的练习 1.)三目运算(也称三元运算)： a&gt;b?a:b(a代表true，b为false) a&gt;b?(a&gt;c?a:c):(b&gt;c?b:c) 在几个数字的比较</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/www520/p/10386463.html</dc:identifier>
</item>
<item>
<title>大数据技术之_05_Hadoop学习_02_MapReduce_MapReduce框架原理+InputFormat数据输入+MapReduce工作流程(面试重点)+Shuffle机制(面试重点) - 黑泽君</title>
<link>http://www.cnblogs.com/chenmingjun/p/10386461.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenmingjun/p/10386461.html</guid>
<description>&lt;p id=&quot;tocid_0&quot; class=&quot;toc&quot;&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10386461.html#h3mapreduce&quot;&gt;第3章 MapReduce框架原理&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10386461.html#h31inputformat&quot;&gt;3.1 InputFormat数据输入&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10386461.html#h311maptask&quot;&gt;3.1.1 切片与MapTask并行度决定机制&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10386461.html#h312job&quot;&gt;3.1.2 Job提交流程源码和切片源码详解&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10386461.html#h313fileinputformat&quot;&gt;3.1.3 FileInputFormat切片机制&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10386461.html#h314combinetextinputformat&quot;&gt;3.1.4 CombineTextInputFormat切片机制&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10386461.html#h315combinetextinputformat&quot;&gt;3.1.5 CombineTextInputFormat案例实操&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10386461.html#h316fileinputformat&quot;&gt;3.1.6 FileInputFormat实现类&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10386461.html#h317keyvaluetextinputformat&quot;&gt;3.1.7 KeyValueTextInputFormat使用案例&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10386461.html#h318nlineinputformat&quot;&gt;3.1.8 NLineInputFormat使用案例&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10386461.html#h319inputformat&quot;&gt;3.1.9 自定义InputFormat&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10386461.html#h3110inputformat&quot;&gt;3.1.10 自定义InputFormat案例实操&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10386461.html#h32mapreduce&quot;&gt;3.2 MapReduce工作流程（面试重点）&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10386461.html#h33shuffle&quot;&gt;3.3 Shuffle机制（面试重点）&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10386461.html#h331shuffle&quot;&gt;3.3.1 Shuffle机制&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10386461.html#h332partition&quot;&gt;3.3.2 Partition分区&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10386461.html#h333partition&quot;&gt;3.3.3 Partition分区案例实操&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;h3mapreduce&quot;&gt;&lt;span&gt;&lt;strong&gt;第3章 MapReduce框架原理&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;h31inputformat&quot;&gt;&lt;span&gt;&lt;strong&gt;3.1 InputFormat数据输入&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h4 id=&quot;h311maptask&quot;&gt;&lt;span&gt;&lt;strong&gt;3.1.1 切片与MapTask并行度决定机制&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;1、问题引出&lt;br/&gt;  MapTask的并行度决定Map阶段的任务处理并发度，进而影响到整个Job的处理速度。&lt;br/&gt;  &lt;code&gt;思考：&lt;/code&gt;1G的数据，启动8个MapTask，可以提高集群的并发处理能力。那么1K的数据，也启动8个MapTask，会提高集群性能吗？MapTask并行任务是否越多越好呢？哪些因素影响了MapTask并行度？&lt;/p&gt;
&lt;p&gt;2、MapTask并行度决定机制&lt;br/&gt;  &lt;strong&gt;数据块：&lt;/strong&gt; Block是HDFS物理上把数据分成一块一块的。&lt;br/&gt;  &lt;strong&gt;数据切片：&lt;/strong&gt; 数据切片只是在逻辑上对输入进行分片，并不会在磁盘上将其切分成片进行存储。&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/02/15/kryyon.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h312job&quot;&gt;&lt;span&gt;&lt;strong&gt;3.1.2 Job提交流程源码和切片源码详解&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;1、Job提交流程源码详解，如下图所示：&lt;/p&gt;
&lt;pre readability=&quot;15.5&quot;&gt;
&lt;code class=&quot;hljs cs&quot; readability=&quot;25&quot;&gt;boolean result = job.waitForCompletion(&lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;);&lt;p&gt;submit();&lt;/p&gt;&lt;p&gt;&lt;br/&gt;connect();    &lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Cluster(getConfiguration());&lt;br/&gt;initialize(jobTrackAddr, conf); &lt;/p&gt;&lt;p&gt;&lt;br/&gt;submitter.submitJobInternal(Job.&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;, cluster)&lt;br/&gt;Path jobStagingArea = JobSubmissionFiles.getStagingDir(cluster, conf);&lt;/p&gt;&lt;p&gt;&lt;br/&gt;JobID jobId = submitClient.getNewJobID();&lt;/p&gt;&lt;p&gt;&lt;br/&gt;copyAndConfigureFiles(job, submitJobDir);    &lt;br/&gt;rUploader.uploadFiles(job, jobSubmitDir);&lt;/p&gt;&lt;p&gt;&lt;br/&gt;writeSplits(job, submitJobDir);&lt;br/&gt;maps = writeNewSplits(job, jobSubmitDir);&lt;br/&gt;input.getSplits(job);&lt;/p&gt;&lt;p&gt;&lt;br/&gt;writeConf(conf, submitJobFile);&lt;br/&gt;conf.writeXml(&lt;span class=&quot;hljs-keyword&quot;&gt;out&lt;/span&gt;);&lt;/p&gt;&lt;p&gt;&lt;br/&gt;status = submitClient.submitJob(jobId, submitJobDir.toString(), job.getCredentials());&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如下图所示：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/02/15/kryhyF.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;2、FileInputFormat切片源码解析(input.getSplits(job))&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/02/15/kry2WV.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h313fileinputformat&quot;&gt;&lt;span&gt;&lt;strong&gt;3.1.3 FileInputFormat切片机制&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;FileInputFormat切片机制&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/02/15/krysds.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;FileInputFormat切片大小的参数配置&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/02/15/kryrZj.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h314combinetextinputformat&quot;&gt;&lt;span&gt;&lt;strong&gt;3.1.4 CombineTextInputFormat切片机制&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;  框架默认的TextInputFormat切片机制是对任务按文件规划切片，&lt;code&gt;不管文件多小，都会是一个单独的切片&lt;/code&gt;，都会交给一个MapTask，这样如果有大量小文件，就&lt;code&gt;会产生大量的MapTask&lt;/code&gt;，处理效率极其低下。之前处理小文件(har文件)使用的方法是归档。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1、应用场景：&lt;br/&gt;  CombineTextInputFormat用于小文件过多的场景，它可以将多个小文件从逻辑上规划到一个切片中，这样，多个小文件就可以交给一个MapTask处理。&lt;/li&gt;
&lt;li&gt;2、虚拟存储切片最大值设置&lt;br/&gt;  CombineTextInputFormat.setMaxInputSplitSize(job, 4194304); // 4m&lt;br/&gt;  &lt;code&gt;注意：&lt;/code&gt;虚拟存储切片最大值设置最好根据实际的小文件大小情况来设置具体的值。&lt;/li&gt;
&lt;li&gt;3、切片机制&lt;br/&gt;  生成切片过程包括：虚拟存储过程和切片过程二部分。&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/02/15/kryciq.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;（1）虚拟存储过程：&lt;br/&gt;  将输入目录下所有文件大小，依次和设置的setMaxInputSplitSize值比较，如果不大于设置的最大值，逻辑上划分一个块。如果输入文件大于设置的最大值且大于两倍，那么以最大值切割一块；当剩余数据大小超过设置的最大值且不大于最大值2倍，此时将文件均分成2个虚拟存储块（防止出现太小切片）。&lt;br/&gt;  例如setMaxInputSplitSize值为4M，输入文件大小为8.02M，则先逻辑上分成一个4M。剩余的大小为4.02M，如果按照4M逻辑划分，就会出现0.02M的小的虚拟存储文件，所以将剩余的4.02M文件切分成（2.01M和2.01M）两个文件。&lt;br/&gt;（2）切片过程：&lt;br/&gt;  （a）判断虚拟存储的文件大小是否大于setMaxInputSplitSize值，大于等于则单独形成一个切片。&lt;br/&gt;  （b）如果不大于则跟下一个虚拟存储文件进行合并，共同形成一个切片。&lt;br/&gt;  （c）测试举例：有4个小文件大小分别为1.7M、5.1M、3.4M以及6.8M这四个小文件，则虚拟存储之后形成6个文件块，大小分别为：&lt;br/&gt;  1.7M，（2.55M、2.55M），3.4M以及（3.4M、3.4M）&lt;br/&gt;  最终会形成3个切片，大小分别为：&lt;br/&gt;  （1.7+2.55）M，（2.55+3.4）M，（3.4+3.4）M&lt;/p&gt;
&lt;h4 id=&quot;h315combinetextinputformat&quot;&gt;&lt;span&gt;&lt;strong&gt;3.1.5 CombineTextInputFormat案例实操&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;1、需求&lt;br/&gt;  将输入的大量小文件合并成一个切片统一处理。&lt;br/&gt;（1）输入数据&lt;br/&gt;  准备4个小文件&lt;br/&gt;（2）期望&lt;br/&gt;  期望一个切片处理4个文件&lt;br/&gt;2、实现过程&lt;br/&gt;&lt;strong&gt;（1）不做任何处理，运行1.6节的WordCount案例程序，观察切片个数为4。&lt;/strong&gt;&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/02/15/krygJ0.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;strong&gt;（2）在WordcountDriver中增加如下代码，运行程序，并观察运行的切片个数为3。&lt;/strong&gt;&lt;br/&gt;（a）驱动类中添加代码如下：
&lt;pre readability=&quot;4.5&quot;&gt;
&lt;code class=&quot;hljs dart&quot; readability=&quot;3&quot;&gt;&lt;br/&gt;job.setInputFormatClass(CombineTextInputFormat.&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt;);&lt;p&gt;&lt;br/&gt;CombineTextInputFormat.setMaxInputSplitSize(job, &lt;span class=&quot;hljs-number&quot;&gt;4194304&lt;/span&gt;);&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（b）运行如果为3个切片。&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/02/15/kryRzT.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;strong&gt;（3）在WordcountDriver中增加如下代码，运行程序，并观察运行的切片个数为1。&lt;/strong&gt;&lt;br/&gt;（a）驱动中添加代码如下：
&lt;pre readability=&quot;4.5&quot;&gt;
&lt;code class=&quot;hljs dart&quot; readability=&quot;3&quot;&gt;&lt;br/&gt;job.setInputFormatClass(CombineTextInputFormat.&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt;);&lt;p&gt;&lt;br/&gt;CombineTextInputFormat.setMaxInputSplitSize(job, &lt;span class=&quot;hljs-number&quot;&gt;20971520&lt;/span&gt;);&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（b）运行如果为1个切片。&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/02/15/kryOSK.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h316fileinputformat&quot;&gt;&lt;span&gt;&lt;strong&gt;3.1.6 FileInputFormat实现类&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/02/15/kryToR.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;Ctrl + t 可得：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/02/15/kryfQU.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;1、TextInputFormat&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/02/15/kryIeJ.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;2、KeyValueTextInputFormat&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/02/15/kry4L4.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;3、NLineInputFormat&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/02/15/kryow9.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h317keyvaluetextinputformat&quot;&gt;&lt;span&gt;&lt;strong&gt;3.1.7 KeyValueTextInputFormat使用案例&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;1、需求&lt;br/&gt;统计输入文件中每一行的第一个单词相同的行数。&lt;br/&gt;（1）输入数据&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs nginx&quot;&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;banzhang&lt;/span&gt; ni hao&lt;br/&gt;xihuan hadoop banzhang&lt;br/&gt;banzhang ni hao&lt;br/&gt;xihuan hadoop banzhang&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（2）期望结果数据&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs nginx&quot;&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;banzhang&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;&lt;br/&gt;xihuan    &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、需求分析&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/02/15/kr6pTA.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;3、代码实现&lt;br/&gt;（1）编写Mapper类
&lt;pre readability=&quot;12.5&quot;&gt;
&lt;code class=&quot;hljs java&quot; readability=&quot;19&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;package&lt;/span&gt; com.atguigu.mr.kv;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; java.io.IOException;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.io.LongWritable;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.io.Text;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.mapreduce.Mapper;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;KVTextMapper&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Mapper&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;Text&lt;/span&gt;, &lt;span class=&quot;hljs-title&quot;&gt;Text&lt;/span&gt;, &lt;span class=&quot;hljs-title&quot;&gt;Text&lt;/span&gt;, &lt;span class=&quot;hljs-title&quot;&gt;LongWritable&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;/p&gt;&lt;p&gt;&lt;br/&gt;LongWritable v = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; LongWritable(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;);&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Text key, Text value, Context context)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;throws&lt;/span&gt; IOException, InterruptedException &lt;/span&gt;{&lt;br/&gt;context.write(key, v);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（2）编写Reducer类&lt;/p&gt;
&lt;pre readability=&quot;14.5&quot;&gt;
&lt;code class=&quot;hljs java&quot; readability=&quot;23&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;package&lt;/span&gt; com.atguigu.mr.kv;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; java.io.IOException;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.io.LongWritable;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.io.Text;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.mapreduce.Reducer;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;KVTextReducer&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Reducer&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;Text&lt;/span&gt;, &lt;span class=&quot;hljs-title&quot;&gt;LongWritable&lt;/span&gt;, &lt;span class=&quot;hljs-title&quot;&gt;Text&lt;/span&gt;, &lt;span class=&quot;hljs-title&quot;&gt;LongWritable&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;/p&gt;&lt;p&gt;LongWritable v = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; LongWritable();&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;reduce&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Text key, Iterable&amp;lt;LongWritable&amp;gt; values, &lt;br/&gt;Context context)&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;throws&lt;/span&gt; IOException, InterruptedException &lt;/span&gt;{&lt;/p&gt;&lt;p&gt;Long sum = &lt;span class=&quot;hljs-number&quot;&gt;0L&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (LongWritable value : values) {&lt;br/&gt;sum += value.get();&lt;br/&gt;}&lt;br/&gt;v.set(sum);&lt;/p&gt;&lt;p&gt;&lt;br/&gt;context.write(key, v);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（3）编写Driver类&lt;/p&gt;
&lt;pre readability=&quot;24&quot;&gt;
&lt;code class=&quot;hljs dart&quot; readability=&quot;42&quot;&gt;package com.atguigu.mr.kv;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; java.io.IOException;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.conf.Configuration;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.fs.Path;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.io.LongWritable;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.io.Text;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.mapreduce.Job;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.mapreduce.lib.input.FileInputFormat;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.mapreduce.lib.input.KeyValueLineRecordReader;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.mapreduce.lib.input.KeyValueTextInputFormat;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;&lt;/p&gt;&lt;p&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;KVTextDriver&lt;/span&gt; &lt;/span&gt;{&lt;/p&gt;&lt;p&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; main(&lt;span class=&quot;hljs-built_in&quot;&gt;String&lt;/span&gt;[] args) throws IOException, ClassNotFoundException, InterruptedException {&lt;/p&gt;&lt;p&gt;&lt;br/&gt;args = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;String&lt;/span&gt;[] { &lt;span class=&quot;hljs-string&quot;&gt;&quot;d:/temp/atguigu/0529/input/inputkv&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;d:/temp/atguigu/0529/output5&quot;&lt;/span&gt; };&lt;/p&gt;&lt;p&gt;Configuration configuration = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Configuration();&lt;/p&gt;&lt;p&gt;&lt;br/&gt;configuration.&lt;span class=&quot;hljs-keyword&quot;&gt;set&lt;/span&gt;(KeyValueLineRecordReader.KEY_VALUE_SEPERATOR, &lt;span class=&quot;hljs-string&quot;&gt;&quot; &quot;&lt;/span&gt;);&lt;/p&gt;&lt;p&gt;&lt;br/&gt;Job job = Job.getInstance(configuration);&lt;/p&gt;&lt;p&gt;&lt;br/&gt;job.setJarByClass(KVTextDriver.&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt;);&lt;/p&gt;&lt;p&gt;&lt;br/&gt;job.setMapperClass(KVTextMapper.&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt;);&lt;br/&gt;job.setReducerClass(KVTextReducer.&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt;);&lt;/p&gt;&lt;p&gt;&lt;br/&gt;job.setMapOutputKeyClass(Text.&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt;);&lt;br/&gt;job.setMapOutputValueClass(LongWritable.&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt;);&lt;/p&gt;&lt;p&gt;&lt;br/&gt;job.setOutputKeyClass(Text.&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt;);&lt;br/&gt;job.setOutputValueClass(LongWritable.&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt;);&lt;/p&gt;&lt;p&gt;&lt;br/&gt;FileInputFormat.setInputPaths(job, &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Path(args[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]));&lt;/p&gt;&lt;p&gt;&lt;br/&gt;job.setInputFormatClass(KeyValueTextInputFormat.&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt;);&lt;/p&gt;&lt;p&gt;FileOutputFormat.setOutputPath(job, &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Path(args[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]));&lt;/p&gt;&lt;p&gt;&lt;br/&gt;boolean result = job.waitForCompletion(&lt;span class=&quot;hljs-keyword&quot;&gt;true&lt;/span&gt;);&lt;br/&gt;System.exit(result ? &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; : &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;h318nlineinputformat&quot;&gt;&lt;span&gt;&lt;strong&gt;3.1.8 NLineInputFormat使用案例&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;1、需求&lt;br/&gt;  对每个单词进行个数统计，要求根据每个输入文件的行数来规定输出多少个切片。此案例要求每三行放入一个切片中。&lt;br/&gt;（1）输入数据&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs nginx&quot;&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;banzhang&lt;/span&gt; ni hao&lt;br/&gt;xihuan hadoop banzhang&lt;br/&gt;banzhang ni hao&lt;br/&gt;xihuan hadoop banzhang&lt;br/&gt;banzhang ni hao&lt;br/&gt;xihuan hadoop banzhang&lt;br/&gt;banzhang ni hao&lt;br/&gt;xihuan hadoop banzhang&lt;br/&gt;banzhang ni hao&lt;br/&gt;xihuan hadoop banzhang banzhang ni hao&lt;br/&gt;xihuan hadoop banzhang&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（2）期望输出数据&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs javascript&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;Number&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;of&lt;/span&gt; splits:&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、需求分析&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/02/15/krybJx.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;3、代码实现&lt;br/&gt;（1）编写Mapper类
&lt;pre readability=&quot;14.5&quot;&gt;
&lt;code class=&quot;hljs java&quot; readability=&quot;23&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;package&lt;/span&gt; com.atguigu.mr.nline;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; java.io.IOException;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.io.LongWritable;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.io.Text;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.mapreduce.Mapper;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;NLineMapper&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Mapper&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;LongWritable&lt;/span&gt;, &lt;span class=&quot;hljs-title&quot;&gt;Text&lt;/span&gt;, &lt;span class=&quot;hljs-title&quot;&gt;Text&lt;/span&gt;, &lt;span class=&quot;hljs-title&quot;&gt;LongWritable&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; Text k = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Text();&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; LongWritable v = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; LongWritable(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;);&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(LongWritable key, Text value, Context context)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;throws&lt;/span&gt; IOException, InterruptedException &lt;/span&gt;{&lt;br/&gt;String line = value.toString();&lt;/p&gt;&lt;p&gt;&lt;br/&gt;String[] splited = line.split(&lt;span class=&quot;hljs-string&quot;&gt;&quot; &quot;&lt;/span&gt;);&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (String string : splited) {&lt;br/&gt;k.set(string);&lt;br/&gt;context.write(k, v);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（2）编写Reducer类&lt;/p&gt;
&lt;pre readability=&quot;13&quot;&gt;
&lt;code class=&quot;hljs java&quot; readability=&quot;20&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;package&lt;/span&gt; com.atguigu.mr.nline;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; java.io.IOException;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.io.LongWritable;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.io.Text;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.mapreduce.Reducer;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;NLineReducer&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Reducer&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;Text&lt;/span&gt;, &lt;span class=&quot;hljs-title&quot;&gt;LongWritable&lt;/span&gt;, &lt;span class=&quot;hljs-title&quot;&gt;Text&lt;/span&gt;, &lt;span class=&quot;hljs-title&quot;&gt;LongWritable&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;/p&gt;&lt;p&gt;LongWritable v = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; LongWritable();&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;reduce&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Text k, Iterable&amp;lt;LongWritable&amp;gt; values, Context context)&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;throws&lt;/span&gt; IOException, InterruptedException &lt;/span&gt;{&lt;/p&gt;&lt;p&gt;Long sum = &lt;span class=&quot;hljs-number&quot;&gt;0L&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (LongWritable value : values) {&lt;br/&gt;sum += value.get();&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;v.set(sum);&lt;/p&gt;&lt;p&gt;&lt;br/&gt;context.write(k, v);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（3）编写Driver类&lt;/p&gt;
&lt;pre readability=&quot;21&quot;&gt;
&lt;code class=&quot;hljs dart&quot; readability=&quot;36&quot;&gt;package com.atguigu.mr.nline;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; java.io.IOException;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.conf.Configuration;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.fs.Path;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.io.LongWritable;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.io.Text;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.mapreduce.Job;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.mapreduce.lib.input.FileInputFormat;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.mapreduce.lib.input.NLineInputFormat;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;&lt;/p&gt;&lt;p&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;NLineDriver&lt;/span&gt; &lt;/span&gt;{&lt;/p&gt;&lt;p&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; main(&lt;span class=&quot;hljs-built_in&quot;&gt;String&lt;/span&gt;[] args) throws IOException, ClassNotFoundException, InterruptedException {&lt;br/&gt;args = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;String&lt;/span&gt;[] { &lt;span class=&quot;hljs-string&quot;&gt;&quot;d:/temp/atguigu/0529/input/inputnline&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;d:/temp/atguigu/0529/output6&quot;&lt;/span&gt; };&lt;/p&gt;&lt;p&gt;Configuration configuration = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Configuration();&lt;br/&gt;Job job = Job.getInstance(configuration);&lt;/p&gt;&lt;p&gt;&lt;br/&gt;NLineInputFormat.setNumLinesPerSplit(job, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;);&lt;br/&gt;job.setInputFormatClass(NLineInputFormat.&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt;);  &lt;/p&gt;&lt;p&gt;&lt;br/&gt;job.setJarByClass(NLineDriver.&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt;);&lt;/p&gt;&lt;p&gt;&lt;br/&gt;job.setMapperClass(NLineMapper.&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt;);&lt;br/&gt;job.setReducerClass(NLineReducer.&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt;);&lt;/p&gt;&lt;p&gt;&lt;br/&gt;job.setMapOutputKeyClass(Text.&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt;);&lt;br/&gt;job.setMapOutputValueClass(LongWritable.&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt;);&lt;/p&gt;&lt;p&gt;&lt;br/&gt;job.setOutputKeyClass(Text.&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt;);&lt;br/&gt;job.setOutputValueClass(LongWritable.&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt;);&lt;/p&gt;&lt;p&gt;&lt;br/&gt;FileInputFormat.setInputPaths(job, &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Path(args[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]));&lt;br/&gt;FileOutputFormat.setOutputPath(job, &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Path(args[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]));&lt;/p&gt;&lt;p&gt;&lt;br/&gt;boolean result = job.waitForCompletion(&lt;span class=&quot;hljs-keyword&quot;&gt;true&lt;/span&gt;);&lt;br/&gt;System.exit(result ? &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; : &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4．测试&lt;br/&gt;（1）输入数据&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs nginx&quot;&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;banzhang&lt;/span&gt; ni hao&lt;br/&gt;xihuan hadoop banzhang&lt;br/&gt;banzhang ni hao&lt;br/&gt;xihuan hadoop banzhang&lt;br/&gt;banzhang ni hao&lt;br/&gt;xihuan hadoop banzhang&lt;br/&gt;banzhang ni hao&lt;br/&gt;xihuan hadoop banzhang&lt;br/&gt;banzhang ni hao&lt;br/&gt;xihuan hadoop banzhang banzhang ni hao&lt;br/&gt;xihuan hadoop banzhang&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（2）输出结果的切片数，如下图所示：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/02/15/kryzeH.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h319inputformat&quot;&gt;&lt;span&gt;&lt;strong&gt;3.1.9 自定义InputFormat&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/02/15/kryjyD.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h3110inputformat&quot;&gt;&lt;span&gt;&lt;strong&gt;3.1.10 自定义InputFormat案例实操&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;  无论HDFS还是MapReduce，在&lt;code&gt;处理小文件&lt;/code&gt;时效率都非常低，但又难免面临处理大量小文件的场景，此时，就需要有相应解决方案。可以自定义InputFormat实现小文件的合并。&lt;br/&gt;1、需求&lt;br/&gt;  将多个小文件合并成一个SequenceFile文件（SequenceFile文件是Hadoop用来存储二进制形式的key-value对的文件格式），SequenceFile里面存储着多个文件，存储的形式为&lt;code&gt;文件路径+名称为key&lt;/code&gt;，&lt;code&gt;文件内容为value&lt;/code&gt;。&lt;br/&gt;（1）输入数据&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/02/15/kr6kSf.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;（2）期望输出文件格式&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/02/15/kr6PYt.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;2、需求分析&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/02/15/kr6emQ.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;3．程序实现&lt;br/&gt;（1）自定义InputFromat
&lt;pre readability=&quot;13.5&quot;&gt;
&lt;code class=&quot;hljs java&quot; readability=&quot;21&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;package&lt;/span&gt; com.atguigu.mr.inputformat;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; java.io.IOException;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.fs.Path;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.io.BytesWritable;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.io.Text;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.mapreduce.InputSplit;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.mapreduce.JobContext;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.mapreduce.RecordReader;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.mapreduce.TaskAttemptContext;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.mapreduce.lib.input.FileInputFormat;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;WholeFileInputformat&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;FileInputFormat&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;Text&lt;/span&gt;, &lt;span class=&quot;hljs-title&quot;&gt;BytesWritable&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;isSplitable&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(JobContext context, Path filename)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;false&lt;/span&gt;;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; RecordReader&amp;lt;Text, BytesWritable&amp;gt; &lt;span class=&quot;hljs-title&quot;&gt;createRecordReader&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(InputSplit split, TaskAttemptContext context)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;throws&lt;/span&gt; IOException, InterruptedException &lt;/span&gt;{&lt;br/&gt;WholeRecordReader recordReader = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; WholeRecordReader();&lt;br/&gt;recordReader.initialize(split, context);&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; recordReader;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（2）自定义RecordReader类&lt;/p&gt;
&lt;pre readability=&quot;27&quot;&gt;
&lt;code class=&quot;hljs java&quot; readability=&quot;48&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;package&lt;/span&gt; com.atguigu.mr.inputformat;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; java.io.IOException;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.conf.Configuration;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.fs.FSDataInputStream;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.fs.FileSystem;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.fs.Path;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.io.BytesWritable;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.io.IOUtils;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.io.Text;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.mapreduce.InputSplit;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.mapreduce.RecordReader;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.mapreduce.TaskAttemptContext;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.mapreduce.lib.input.FileSplit;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;WholeRecordReader&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;RecordReader&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;Text&lt;/span&gt;, &lt;span class=&quot;hljs-title&quot;&gt;BytesWritable&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; FileSplit split;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; Configuration configuration;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; Text k = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Text();&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; BytesWritable v = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; BytesWritable();&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;boolean&lt;/span&gt; isProgress = &lt;span class=&quot;hljs-keyword&quot;&gt;true&lt;/span&gt;;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;initialize&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(InputSplit split, TaskAttemptContext context)&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;throws&lt;/span&gt; IOException, InterruptedException &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.split = (FileSplit) split;&lt;br/&gt;configuration = context.getConfiguration();&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;nextKeyValue&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;throws&lt;/span&gt; IOException, InterruptedException &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (isProgress) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;byte&lt;/span&gt;[] buf = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;byte&lt;/span&gt;[(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;) split.getLength()];&lt;/p&gt;&lt;p&gt;FileSystem fs = &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;;&lt;br/&gt;FSDataInputStream fis = &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt; {&lt;br/&gt;Path path = split.getPath();&lt;br/&gt;fs = path.getFileSystem(configuration);&lt;/p&gt;&lt;p&gt;&lt;br/&gt;fis = fs.open(path);&lt;/p&gt;&lt;p&gt;&lt;br/&gt;IOUtils.readFully(fis, buf, &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, buf.length);&lt;/p&gt;&lt;p&gt;&lt;br/&gt;v.set(buf, &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, buf.length);&lt;/p&gt;&lt;p&gt;&lt;br/&gt;k.set(path.toString());&lt;/p&gt;&lt;p&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;finally&lt;/span&gt; {&lt;br/&gt;IOUtils.closeStream(fis);&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;isProgress = &lt;span class=&quot;hljs-keyword&quot;&gt;false&lt;/span&gt;;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;true&lt;/span&gt;;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;false&lt;/span&gt;;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; Text &lt;span class=&quot;hljs-title&quot;&gt;getCurrentKey&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;throws&lt;/span&gt; IOException, InterruptedException &lt;/span&gt;{&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; k;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; BytesWritable &lt;span class=&quot;hljs-title&quot;&gt;getCurrentValue&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;throws&lt;/span&gt; IOException, InterruptedException &lt;/span&gt;{&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; v;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;getProgress&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;throws&lt;/span&gt; IOException, InterruptedException &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;throws&lt;/span&gt; IOException &lt;/span&gt;{&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（3）编写SequenceFileMapper类处理流程&lt;/p&gt;
&lt;pre readability=&quot;12.5&quot;&gt;
&lt;code class=&quot;hljs java&quot; readability=&quot;19&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;package&lt;/span&gt; com.atguigu.mr.inputformat;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; java.io.IOException;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.io.BytesWritable;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.io.Text;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.mapreduce.Mapper;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;SequenceFileMapper&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Mapper&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;Text&lt;/span&gt;, &lt;span class=&quot;hljs-title&quot;&gt;BytesWritable&lt;/span&gt;, &lt;span class=&quot;hljs-title&quot;&gt;Text&lt;/span&gt;, &lt;span class=&quot;hljs-title&quot;&gt;BytesWritable&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Text key, BytesWritable value, Context context)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;throws&lt;/span&gt; IOException, InterruptedException &lt;/span&gt;{&lt;/p&gt;&lt;p&gt;context.write(key, value);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（4）编写SequenceFileReducer类处理流程&lt;/p&gt;
&lt;pre readability=&quot;12.5&quot;&gt;
&lt;code class=&quot;hljs java&quot; readability=&quot;19&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;package&lt;/span&gt; com.atguigu.mr.inputformat;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; java.io.IOException;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.io.BytesWritable;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.io.Text;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.mapreduce.Reducer;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;SequenceFileReducer&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Reducer&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;Text&lt;/span&gt;, &lt;span class=&quot;hljs-title&quot;&gt;BytesWritable&lt;/span&gt;, &lt;span class=&quot;hljs-title&quot;&gt;Text&lt;/span&gt;, &lt;span class=&quot;hljs-title&quot;&gt;BytesWritable&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;reduce&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Text key, Iterable&amp;lt;BytesWritable&amp;gt; values,&lt;br/&gt;Context context)&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;throws&lt;/span&gt; IOException, InterruptedException &lt;/span&gt;{&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (BytesWritable value : values) {&lt;br/&gt;context.write(key, value);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（5）编写SequenceFileDriver类处理流程&lt;/p&gt;
&lt;pre readability=&quot;20.5&quot;&gt;
&lt;code class=&quot;hljs dart&quot; readability=&quot;35&quot;&gt;package com.atguigu.mr.inputformat;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; java.io.IOException;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.conf.Configuration;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.fs.Path;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.io.BytesWritable;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.io.Text;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.mapreduce.Job;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.mapreduce.lib.input.FileInputFormat;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.mapreduce.lib.output.SequenceFileOutputFormat;&lt;/p&gt;&lt;p&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;SequenceFileDriver&lt;/span&gt; &lt;/span&gt;{&lt;/p&gt;&lt;p&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; main(&lt;span class=&quot;hljs-built_in&quot;&gt;String&lt;/span&gt;[] args) throws IOException, Exception {&lt;br/&gt;args = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;String&lt;/span&gt;[] { &lt;span class=&quot;hljs-string&quot;&gt;&quot;d:/temp/atguigu/0529/input/inputself&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;d:/temp/atguigu/0529/output7&quot;&lt;/span&gt; };&lt;/p&gt;&lt;p&gt;&lt;br/&gt;Configuration conf = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Configuration();&lt;br/&gt;Job job = Job.getInstance(conf);&lt;/p&gt;&lt;p&gt;&lt;br/&gt;job.setJarByClass(SequenceFileDriver.&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt;);&lt;br/&gt;job.setMapperClass(SequenceFileMapper.&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt;);&lt;br/&gt;job.setReducerClass(SequenceFileReducer.&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt;);&lt;/p&gt;&lt;p&gt;&lt;br/&gt;job.setInputFormatClass(WholeFileInputformat.&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt;);&lt;br/&gt;job.setOutputFormatClass(SequenceFileOutputFormat.&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt;);&lt;/p&gt;&lt;p&gt;&lt;br/&gt;job.setMapOutputKeyClass(Text.&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt;);&lt;br/&gt;job.setMapOutputValueClass(BytesWritable.&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt;);&lt;/p&gt;&lt;p&gt;&lt;br/&gt;job.setOutputKeyClass(Text.&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt;);&lt;br/&gt;job.setOutputValueClass(BytesWritable.&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt;);&lt;/p&gt;&lt;p&gt;&lt;br/&gt;FileInputFormat.setInputPaths(job, &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Path(args[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]));&lt;br/&gt;FileOutputFormat.setOutputPath(job, &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Path(args[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]));&lt;/p&gt;&lt;p&gt;&lt;br/&gt;boolean result = job.waitForCompletion(&lt;span class=&quot;hljs-keyword&quot;&gt;true&lt;/span&gt;);&lt;/p&gt;&lt;p&gt;System.exit(result ? &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; : &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h32mapreduce&quot;&gt;&lt;span&gt;&lt;strong&gt;3.2 MapReduce工作流程（面试重点）&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;1、流程示意图，如下图所示：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/02/15/kr6nTs.png&quot; alt=&quot;&quot;/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/02/15/kr6E6S.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;2、流程详解&lt;br/&gt;  上面的流程是整个MapReduce最全工作流程，但是Shuffle过程只是从第7步开始到第16步结束，具体Shuffle过程详解，如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;1）MapTask收集我们的map()方法输出的kv对，放到内存缓冲区中。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;2）从内存缓冲区不断溢出本地磁盘文件，可能会溢出多个文件。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;3）多个溢出文件会被合并成大的溢出文件。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;4）在溢出过程及合并的过程中，都要调用Partitioner进行分区和针对key进行排序。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;5）ReduceTask根据自己的分区号，去各个MapTask机器上取相应的结果分区数据。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;6）ReduceTask会取到同一个分区的来自不同MapTask的结果文件，ReduceTask会将这些文件再进行合并（归并排序）。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;7）合并成大文件后，Shuffle的过程也就结束了，后面进入ReduceTask的逻辑运算过程（从文件中取出一个一个的键值对Group，调用用户自定义的reduce()方法）。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;3、注意&lt;br/&gt;  Shuffle中的缓冲区大小会影响到MapReduce程序的执行效率，原则上说，缓冲区越大，磁盘io的次数越少，执行速度就越快。&lt;br/&gt;  缓冲区的大小可以通过参数调整，参数：io.sort.mb默认100M。&lt;br/&gt;4、源码解析流程&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs css&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.write&lt;/span&gt;(&lt;span class=&quot;hljs-selector-tag&quot;&gt;k&lt;/span&gt;, &lt;span class=&quot;hljs-selector-tag&quot;&gt;NullWritable&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.get&lt;/span&gt;());&lt;br/&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;output&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.write&lt;/span&gt;(&lt;span class=&quot;hljs-selector-tag&quot;&gt;key&lt;/span&gt;, &lt;span class=&quot;hljs-selector-tag&quot;&gt;value&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;collector&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.collect&lt;/span&gt;(&lt;span class=&quot;hljs-selector-tag&quot;&gt;key&lt;/span&gt;, &lt;span class=&quot;hljs-selector-tag&quot;&gt;value&lt;/span&gt;, &lt;span class=&quot;hljs-selector-tag&quot;&gt;partitioner&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.getPartition&lt;/span&gt;(&lt;span class=&quot;hljs-selector-tag&quot;&gt;key&lt;/span&gt;, &lt;span class=&quot;hljs-selector-tag&quot;&gt;value&lt;/span&gt;, &lt;span class=&quot;hljs-selector-tag&quot;&gt;partitions&lt;/span&gt;));&lt;br/&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;HashPartitioner&lt;/span&gt;();&lt;br/&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;collect&lt;/span&gt;()&lt;br/&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;close&lt;/span&gt;()&lt;br/&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;collect&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.flush&lt;/span&gt;()&lt;br/&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;sortAndSpill&lt;/span&gt;()&lt;br/&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;sort&lt;/span&gt;()   &lt;span class=&quot;hljs-selector-tag&quot;&gt;QuickSort&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;mergeParts&lt;/span&gt;();&lt;br/&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.out&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.out&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.index&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;collector&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.close&lt;/span&gt;();&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h33shuffle&quot;&gt;&lt;span&gt;&lt;strong&gt;3.3 Shuffle机制（面试重点）&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h4 id=&quot;h331shuffle&quot;&gt;&lt;span&gt;&lt;strong&gt;3.3.1 Shuffle机制&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;Map方法之后，Reduce方法之前的数据处理过程称之为Shuffle。如下图所示。&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/02/15/kr686U.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h332partition&quot;&gt;&lt;span&gt;&lt;strong&gt;3.3.2 Partition分区&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/02/15/kr6Ym4.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;自定义Partitioner分区步骤：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/02/15/kr6MYq.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;分区总结：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/02/15/krckNR.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h333partition&quot;&gt;&lt;span&gt;&lt;strong&gt;3.3.3 Partition分区案例实操&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;1、需求&lt;br/&gt;  将统计结果按照手机归属地不同省份输出到不同文件中（分区）&lt;br/&gt;（1）输入数据&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs css&quot;&gt;1    13736230513 192&lt;span class=&quot;hljs-selector-class&quot;&gt;.196&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.100&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.1&lt;/span&gt;   &lt;span class=&quot;hljs-selector-tag&quot;&gt;www&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.atguigu&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.com&lt;/span&gt; 2481    24681   200&lt;br/&gt;2    13846544121 192&lt;span class=&quot;hljs-selector-class&quot;&gt;.196&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.100&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.2&lt;/span&gt;                   264     0       200&lt;br/&gt;3     13956435636 192&lt;span class=&quot;hljs-selector-class&quot;&gt;.196&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.100&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.3&lt;/span&gt;                   132     1512    200&lt;br/&gt;4     13966251146 192&lt;span class=&quot;hljs-selector-class&quot;&gt;.168&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.100&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.1&lt;/span&gt;                   240     0       404&lt;br/&gt;5     18271575951 192&lt;span class=&quot;hljs-selector-class&quot;&gt;.168&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.100&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.2&lt;/span&gt;   &lt;span class=&quot;hljs-selector-tag&quot;&gt;www&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.atguigu&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.com&lt;/span&gt; 1527    2106    200&lt;br/&gt;6     84188413    192&lt;span class=&quot;hljs-selector-class&quot;&gt;.168&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.100&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.3&lt;/span&gt;   &lt;span class=&quot;hljs-selector-tag&quot;&gt;www&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.atguigu&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.com&lt;/span&gt; 4116    1432    200&lt;br/&gt;7     13590439668 192&lt;span class=&quot;hljs-selector-class&quot;&gt;.168&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.100&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.4&lt;/span&gt;                   1116    954     200&lt;br/&gt;8     15910133277 192&lt;span class=&quot;hljs-selector-class&quot;&gt;.168&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.100&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.5&lt;/span&gt;   &lt;span class=&quot;hljs-selector-tag&quot;&gt;www&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.hao123&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.com&lt;/span&gt;  3156    2936    200&lt;br/&gt;9     13729199489 192&lt;span class=&quot;hljs-selector-class&quot;&gt;.168&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.100&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.6&lt;/span&gt;                   240     0       200&lt;br/&gt;10     13630577991 192&lt;span class=&quot;hljs-selector-class&quot;&gt;.168&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.100&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.7&lt;/span&gt;   &lt;span class=&quot;hljs-selector-tag&quot;&gt;www&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.shouhu&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.com&lt;/span&gt;  6960    690     200&lt;br/&gt;11     15043685818 192&lt;span class=&quot;hljs-selector-class&quot;&gt;.168&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.100&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.8&lt;/span&gt;   &lt;span class=&quot;hljs-selector-tag&quot;&gt;www&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.baidu&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.com&lt;/span&gt;   3659    3538    200&lt;br/&gt;12     15959002129 192&lt;span class=&quot;hljs-selector-class&quot;&gt;.168&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.100&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.9&lt;/span&gt;   &lt;span class=&quot;hljs-selector-tag&quot;&gt;www&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.atguigu&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.com&lt;/span&gt; 1938    180     500&lt;br/&gt;13     13560439638 192&lt;span class=&quot;hljs-selector-class&quot;&gt;.168&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.100&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.10&lt;/span&gt;                  918     4938    200&lt;br/&gt;14     13470253144 192&lt;span class=&quot;hljs-selector-class&quot;&gt;.168&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.100&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.11&lt;/span&gt;                  180     180     200&lt;br/&gt;15     13682846555 192&lt;span class=&quot;hljs-selector-class&quot;&gt;.168&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.100&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.12&lt;/span&gt;  &lt;span class=&quot;hljs-selector-tag&quot;&gt;www&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.qq&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.com&lt;/span&gt;      1938    2910    200&lt;br/&gt;16     13992314666 192&lt;span class=&quot;hljs-selector-class&quot;&gt;.168&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.100&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.13&lt;/span&gt;  &lt;span class=&quot;hljs-selector-tag&quot;&gt;www&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.gaga&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.com&lt;/span&gt;    3008    3720    200&lt;br/&gt;17     13509468723 192&lt;span class=&quot;hljs-selector-class&quot;&gt;.168&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.100&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.14&lt;/span&gt;  &lt;span class=&quot;hljs-selector-tag&quot;&gt;www&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.qinghua&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.com&lt;/span&gt; 7335    110349  404&lt;br/&gt;18     18390173782 192&lt;span class=&quot;hljs-selector-class&quot;&gt;.168&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.100&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.15&lt;/span&gt;  &lt;span class=&quot;hljs-selector-tag&quot;&gt;www&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.sogou&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.com&lt;/span&gt;   9531    2412    200&lt;br/&gt;19     13975057813 192&lt;span class=&quot;hljs-selector-class&quot;&gt;.168&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.100&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.16&lt;/span&gt;  &lt;span class=&quot;hljs-selector-tag&quot;&gt;www&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.baidu&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.com&lt;/span&gt;   11058   48243   200&lt;br/&gt;20     13768778790 192&lt;span class=&quot;hljs-selector-class&quot;&gt;.168&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.100&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.17&lt;/span&gt;                  120     120     200&lt;br/&gt;21     13568436656 192&lt;span class=&quot;hljs-selector-class&quot;&gt;.168&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.100&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.18&lt;/span&gt;  &lt;span class=&quot;hljs-selector-tag&quot;&gt;www&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.alibaba&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.com&lt;/span&gt; 2481    24681   200&lt;br/&gt;22     13568436656 192&lt;span class=&quot;hljs-selector-class&quot;&gt;.168&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.100&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.19&lt;/span&gt;                  1116    954     200&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（2）期望输出数据&lt;br/&gt;  手机号136、137、138、139开头都分别放到一个独立的4个文件中，其他开头的放到一个文件中。&lt;br/&gt;2、需求分析&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/02/15/krcFE9.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;3、在案例2.4的基础上，增加一个分区类
&lt;pre readability=&quot;9.5&quot;&gt;
&lt;code class=&quot;hljs java&quot; readability=&quot;13&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;package&lt;/span&gt; com.atguigu.mr.flowsum;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.io.Text;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.mapreduce.Partitioner;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;ProvincePartitioner&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Partitioner&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;Text&lt;/span&gt;, &lt;span class=&quot;hljs-title&quot;&gt;FlowBean&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;getPartition&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Text key, FlowBean value, &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; numPartitions)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;String prePhoneNum = key.toString().substring(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; partition = &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;hljs-string&quot;&gt;&quot;136&quot;&lt;/span&gt;.equals(prePhoneNum)) {&lt;br/&gt;partition = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;hljs-string&quot;&gt;&quot;137&quot;&lt;/span&gt;.equals(prePhoneNum)) {&lt;br/&gt;partition = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;hljs-string&quot;&gt;&quot;138&quot;&lt;/span&gt;.equals(prePhoneNum)) {&lt;br/&gt;partition = &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;;&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;hljs-string&quot;&gt;&quot;139&quot;&lt;/span&gt;.equals(prePhoneNum)) {&lt;br/&gt;partition = &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; partition;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4、在驱动函数中增加自定义数据分区设置和ReduceTask设置&lt;/p&gt;
&lt;pre readability=&quot;21.5&quot;&gt;
&lt;code class=&quot;hljs dart&quot; readability=&quot;37&quot;&gt;package com.atguigu.mr.flowsum;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; java.io.IOException;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.conf.Configuration;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.fs.Path;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.io.Text;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.mapreduce.Job;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.mapreduce.lib.input.FileInputFormat;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;&lt;/p&gt;&lt;p&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;FlowsumDriver&lt;/span&gt; &lt;/span&gt;{&lt;/p&gt;&lt;p&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; main(&lt;span class=&quot;hljs-built_in&quot;&gt;String&lt;/span&gt;[] args) throws IOException, ClassNotFoundException, InterruptedException {&lt;/p&gt;&lt;p&gt;&lt;br/&gt;args = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;String&lt;/span&gt;[] { &lt;span class=&quot;hljs-string&quot;&gt;&quot;d:/temp/atguigu/0529/input/inputflow&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;d:/temp/atguigu/0529/output2&quot;&lt;/span&gt; };&lt;/p&gt;&lt;p&gt;&lt;br/&gt;Configuration configuration = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Configuration();&lt;br/&gt;Job job = Job.getInstance(configuration);&lt;/p&gt;&lt;p&gt;&lt;br/&gt;job.setJarByClass(FlowsumDriver.&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt;);&lt;/p&gt;&lt;p&gt;&lt;br/&gt;job.setMapperClass(FlowCountMapper.&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt;);&lt;br/&gt;job.setReducerClass(FlowCountReducer.&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt;);&lt;/p&gt;&lt;p&gt;&lt;br/&gt;job.setMapOutputKeyClass(Text.&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt;);&lt;br/&gt;job.setMapOutputValueClass(FlowBean.&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt;);&lt;/p&gt;&lt;p&gt;&lt;br/&gt;job.setOutputKeyClass(Text.&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt;);&lt;br/&gt;job.setOutputValueClass(FlowBean.&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt;);&lt;/p&gt;&lt;p&gt;&lt;br/&gt;job.setPartitionerClass(ProvincePartitioner.&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt;);&lt;br/&gt;job.setNumReduceTasks(&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;);&lt;/p&gt;&lt;p&gt;&lt;br/&gt;FileInputFormat.setInputPaths(job, &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Path(args[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]));&lt;br/&gt;FileOutputFormat.setOutputPath(job, &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Path(args[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]));&lt;/p&gt;&lt;p&gt;&lt;br/&gt;boolean result = job.waitForCompletion(&lt;span class=&quot;hljs-keyword&quot;&gt;true&lt;/span&gt;);&lt;/p&gt;&lt;p&gt;System.exit(result ? &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; : &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 15 Feb 2019 15:29:00 +0000</pubDate>
<dc:creator>黑泽君</dc:creator>
<og:description>第3章 MapReduce框架原理3.1 InputFormat数据输入3.1.1 切片与MapTask并行度决定机制3.1.2 Job提交流程源码和切片源码详解3.1.3 FileInputForm</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenmingjun/p/10386461.html</dc:identifier>
</item>
<item>
<title>Perl信号处理 - 骏马金龙</title>
<link>http://www.cnblogs.com/f-ck-need-u/p/10386248.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/f-ck-need-u/p/10386248.html</guid>
<description>&lt;p&gt;操作系统可以通过信号(signal)处理机制来实现一些功能：程序注册好待监视的信号处理机制，在程序运行过程中如果产生了对应的信号，则会按照注册好的处理方式进行处理。&lt;/p&gt;
&lt;h2 id=&quot;signal基础&quot;&gt;signal基础&lt;/h2&gt;
&lt;p&gt;每个进程都记录了一个信号(signal)索引表，并注册了各种信号的处理方式，每当收到信号的时候，会立即停止执行操作并处理对应的信号。&lt;/p&gt;
&lt;p&gt;绝大多数信号都有默认处理机制，但Perl支持用户自己重新定义接收到信号时的处理方式。在Perl中，信号处理的方式注册在一个hash变量&lt;code&gt;%SIG&lt;/code&gt;中，key为信号的名称，value有几种可能的值：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;DEFAULT或undef&lt;/strong&gt;：表示采取所接收信号的默认处理方式&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;IGNORE&lt;/strong&gt;：表示忽略接收到的该信号&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;子程序引用&lt;/strong&gt;：如&lt;code&gt;\&amp;amp;subref&lt;/code&gt;或匿名子程序&lt;code&gt;sub { codeblock }&lt;/code&gt;，表示接收到该信号时，执行该子程序&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;子程序：强烈建议不使用该类值&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;要想查看支持的信号，可以遍历一下&lt;code&gt;%SIG&lt;/code&gt;，或者直接在Linux下使用&lt;code&gt;kill -l&lt;/code&gt;命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ perl -le 'print join qq/ /, sort keys %SIG'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;要查看信号对应的数值，可以去Config的sig_name里查找：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#!/usr/bin/perl
use strict;
use warnings;

use Config;
my @signals = split ' ', $Config{sig_name};
for (0..$#signals){
    print &quot;$_ $signals \n&quot; unless $signals[$_] =~ /^NUM/;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;记住几个常见的即可(数值|KEY|NAME)：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;0 | ZERO | SIGZERO&lt;/code&gt;：检查进程是否存在&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1 | HUP | SIGHUP&lt;/code&gt;：发送HUP信号给终端来终止终端上的所有进程(终端的子进程)，对daemon类程序还常重新定义该信号用来重新加载配置文件并reload服务&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;2 | INT | SIGINT&lt;/code&gt;：中断进程，可被捕捉和忽略，几乎等同于sigterm，所以也会尽可能的释放执行clean-up，释放资源，保存状态等(CTRL+C)&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;3 | QUIT | SIGQUIT&lt;/code&gt;：从键盘发出杀死(终止)进程的信号，优先级较高，可能还会发出core dump行为&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;9 | KILL | SIGKILL&lt;/code&gt;：强制终止进程，该信号不可被捕捉。该信号是人为强制终止，而不是让操作系统内核去终止进程，所以进程收到该信号后不会执行任何clean-up行为，所以资源不会释放，状态不会保存&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;10 | USR1 | SIGUSR1&lt;/code&gt;：用户自定义信号1&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;12 | USR2 | SIGUSR2&lt;/code&gt;：用户自定义信号2&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;13 | PIPE | SIGPIPE&lt;/code&gt;：已关闭的管道。当正在读的、或正在写入的管道已被对方关闭时，将触发该信号&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;14 | ALRM | SIGALRM&lt;/code&gt;：alarm信号，当当前进程的alarm计时器(alarm定时器即一个定时器)到期了，将触发该信号。在Microsoft系统上未实现该信号&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;15 | TERM | SIGTERM&lt;/code&gt;：杀死(终止)进程，可被捕捉和忽略，几乎等同于sigint信号，会尽可能的释放执行clean-up，释放资源，保存状态等，优先级高于INT，但低于QUIT和KILL&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;17 | CHLD | SIGCHLD&lt;/code&gt;：当子进程中断或退出时，发送该信号告知父进程自己已完成，父进程收到信号将告知内核清理进程列表。所以该信号可以解除僵尸进程，也可以让非正常退出的进程工作得以正常的clean-up，释放资源，保存状态等&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;18 | CONT | SIGCONT&lt;/code&gt;：发送此信号使得stopped进程进入running，该信号主要用于jobs，例如bg &amp;amp; fg 都会发送该信号。可以直接发送此信号给stopped进程使其运行起来&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;19 | STOP | SIGSTOP&lt;/code&gt;：该信号是不可被捕捉和忽略的进程停止信息，收到信号后会进入stopped状态，直到接收到CONT信号后才继续运行&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;20 | TSTP | SIGTSTP&lt;/code&gt;：该信号是可被忽略的进程停止信号(CTRL+Z)&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;28 | WINCH | SIGWINCH&lt;/code&gt;：进程所在的控制终端或控制窗口大小发生了改变(例如拉大拉小图形界面程序的框框)会发送该信号。对于后台进程，由于没有窗口的概念，常常重新定义该信号用来实现graceful stop&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;29 | IO | SIGIO&lt;/code&gt;：异步IO事件。如果文件句柄设置为异步IO(即O_ASYNC)，当该文件句柄中产生了任何事件(例如可写事件)时都会发送该信号&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;安全的信号&quot;&gt;安全的信号&lt;/h2&gt;
&lt;p&gt;需要注意的是，&lt;strong&gt;对于具有安全信号处理机制的语言(不止是Perl)，需要保证在运行一条语句(严格地说是opcode)的时候不会被操作系统的信号处理机制中断，只有在当前正在处理的语句结束后，才会中断&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;例如，在Perl进行IO的时候，信号不会终止正在进行的IO操作，而是在这次IO完成后再终止。再例如，正在执行排序操作的时候，不会在排序的过程中终止，而是当前排序过程完成后再终止。&lt;/p&gt;
&lt;p&gt;安全的信号机制优点很明显，它可以让程序更加健壮。但是缺点也很明显，因为有些操作可能会花费比较长的时间，然后才终止进程。当然，大多数时候这个缺点并不是什么大问题，但是有些情况下对时间长短的控制要求非常精确(比如反导弹系统，必须在一个很短的时间内计算出一些数据，这种程序很可能会直接定制操作系统实现特殊的功能)，这样的情况就不适合使用这种安全的信号处理机制。&lt;/p&gt;
&lt;p&gt;从Perl 5.8开始，Perl就默认使用safe模式的信号处理机制。如果想要在Perl上使用非安全的信号处理机制，需要设置环境变量&lt;code&gt;PERL_SIGNALS=unsafe&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;信号处理-1&quot;&gt;信号处理&lt;/h2&gt;
&lt;p&gt;前面说过，要想定制信号处理方式，只需在&lt;code&gt;%SIG&lt;/code&gt;中注册对应的value即可。其中value有几种可能的值：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;DEFAULT或undef&lt;/strong&gt;：表示采取所接收信号的默认处理方式&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;IGNORE&lt;/strong&gt;：表示忽略接收到的该信号&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;子程序引用&lt;/strong&gt;：如&lt;code&gt;\&amp;amp;subref&lt;/code&gt;或匿名子程序&lt;code&gt;sub { codeblock }&lt;/code&gt;，表示接收到该信号时，执行该子程序&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;子程序：强烈建议不使用该类值&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;注意，自定义信号处理方式，对于无法捕获的信号无影响，如SIGKILL信号是不可被捕捉的信号。&lt;/p&gt;
&lt;p&gt;例如，忽略INT信号，使得CTRL+C无效：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$SIG{INT}='IGNORE';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以下是一个完整的perl示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#!/usr/bin/env perl
use strict;
use warnings;

$SIG{INT} = 'IGNORE';

for (1..3){
        print &quot;hello $_\n&quot;;
        sleep 2;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行这个perl程序的时候，按下ctrl + c将无法终止程序，而是正常运行完。&lt;/p&gt;
&lt;p&gt;再例如，设置alarm信号为默认值'DEFAULT'，alarm信号的默认处理机制是终止调用alarm的进程。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$SIG{ALRM} = 'DEFAULT';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;设置信号的处理方式为一个自定义的子程序：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$SIG{USR1} = \&amp;amp;usr1handler;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意&lt;strong&gt;使用的是子程序引用，不要直接使用子程序&lt;/strong&gt;。实际上，如果&lt;code&gt;%SIG&lt;/code&gt;的value部分，如果不是子程序引用，也不是'DEFAULT'或&lt;code&gt;IGNORE&lt;/code&gt;，其它字符串都表示以main包(不是当前包)的该子程序作为信号处理方式。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$SIG{USR1} = 'DEFLT';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;等价于：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$SIG{USR1} = \&amp;amp;main::DEFLT;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而很多时候，这个子程序是不存在的。所以，请注意value部分的拼写。&lt;/p&gt;
&lt;p&gt;还可以直接定义一个匿名子程序作为信号处理的值。例如，收到INT信号时，清理一些临时文件(如pid文件)：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$SIG{INT} = sub {
    warn &quot;received SIGINT, removing PID file and exiting.\n&quot;;
    unlink &quot;/var/run/perlapp.pid&quot;;
    exit 0;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;正常的&lt;code&gt;%SIG&lt;/code&gt;写法注册信号时，一次只能注册一个信号：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$SIG{INT} = \&amp;amp;handler;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但可以&lt;strong&gt;通过下面的方式一次性注册多个信号处理方式&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;%SIG = (%SIG, INT =&amp;gt; IGNORE, PIPE =&amp;gt; \&amp;amp;handler, HUP =&amp;gt; \&amp;amp;handler);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;之所以能这么展开，是因为Perl在列表上下文会将列表、数组、hash（它们本质上都是列表）压扁展开，所以括号中的&lt;code&gt;%SIG&lt;/code&gt;会展开成一个列表，然后重新定义了INT、PIPE、HUP信号的值，由于hash类型的key必须是唯一的，所以重新定义的key的值会覆盖已有的值。&lt;/p&gt;
&lt;h2 id=&quot;die和warn的信号处理&quot;&gt;die和warn的信号处理&lt;/h2&gt;
&lt;p&gt;Perl除了支持信号处理机制，还支持错误处理，特别是die和warn这两个行为(以及Carp模块中对应的crap和croak)。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$SIG{__WARN__} = \&amp;amp;yoursub;
$SIG{__DIE__} = \&amp;amp;yoursub;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这些并不是真的信号，而是伪信号，Perl提供伪信号处理机制让我们定制一些事件的处理方式。在&lt;code&gt;%SIG&lt;/code&gt;中并没有为这些伪信号设置默认值，所以如果需要设置伪信号的事件处理，需要手动设置，正如上面设置的方式。&lt;/p&gt;
&lt;p&gt;上面的前缀和后缀双下划线是可选的，只是为了让伪信号和真信号进行区分。当然，Perl并不允许我们在&lt;code&gt;%SIG&lt;/code&gt;中随意创建信号名。&lt;/p&gt;
&lt;h2 id=&quot;写一个信号处理子程序&quot;&gt;写一个信号处理子程序&lt;/h2&gt;
&lt;p&gt;如果某个信号的所注册的是一个子程序引用，那么在接收到这个信号的时候，会调用这个子程序，并传递信号的名称作为参数给子程序。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#!/usr/bin/perl 
use strict;
use warnings;

sub handler {
    my $sig = shift;
    print &quot;Caught SIGNAL: $sig\n&quot;;
}

$SIG{INT} = \&amp;amp;handler;

for (1..3){
    sleep 2;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有些操作系统(特别是BSD系统)会在调用一次子程序后注销信号处理子程序，所以要想继续注册该信号的处理方式，可以在子程序中的开头（在开头加是为了避免信号触发后子程序调用过程中有新的信号进来）加上重新安装子程序的语句：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;sub handler{
    $sig = shift;
    # reinstall handler
    $SIG{$sig} = \&amp;amp;handler;
    ...
    ...其它代码...
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;很多时候，并不希望正在处理某个信号的时候再次接收该信号(因为这个时候接收同样的信号是多余的行为)，这时可以在子程序的开头将信号处理设置为&quot;IGNORE&quot;来忽略可能的新信号，再在子程序的结尾设置回原来的信号处理方式。&lt;/p&gt;
&lt;p&gt;下面的代码展示了这种处理逻辑：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;sub handler {
    $SIG{$_[0]} = 'IGNORE';
    ... do something ...
    $SIG{$_[0]} = \&amp;amp;handler;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者，更简便的方式是使用&lt;code&gt;local&lt;/code&gt;关键字来修饰&lt;code&gt;%SIG&lt;/code&gt;中对应的信号：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;sub handler {
    local $SIG{$_[0]} = 'IGNORE';
    ... do something ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;local关键字是在局部范围内操作全局变量，在退出范围时恢复全局变量。所以，上面的代码中，只有在handler函数内部临时设置了信号处理方式为&quot;IGNORE&quot;，退出子程序后又恢复原来的信号处理方式。&lt;/p&gt;
&lt;h2 id=&quot;糟糕的信号处理子程序&quot;&gt;糟糕的信号处理子程序&lt;/h2&gt;
&lt;p&gt;其实信号处理机制中隐含了一个关键点：&lt;strong&gt;强烈建议不要在信号处理程序中分配新内存&lt;/strong&gt;。例如，新建一个变量保存某个值。&lt;/p&gt;
&lt;p&gt;例如，下面的示例中，就在每次信号处理的过程中，新建一个元素空间保存每个被触发的信号计数器的值：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;my %sigcount;
sub allocatinghandler {
    $sigcount{$_[0]}++;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面是不太好的编程方式，而下面修改后的代码则更好，因为在第一次调用子程序的时候，就分配好了一些空间（每个信号默认值都为0），在每次自增计数器计数的时候不会再新分配内存：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;%sigcount = map { $_ =&amp;gt; 0 } keys %SIG;

sub nonallocatinghandler {
    $sigcount{$_[0]}++;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;发送信号解释hup信号和0信号&quot;&gt;发送信号(解释HUP信号和0信号)&lt;/h2&gt;
&lt;p&gt;在Unix系统中，使用&lt;code&gt;kill&lt;/code&gt;命令发送信号。在Perl中，也可以使用kill函数来发送信号。&lt;/p&gt;
&lt;p&gt;Perl kill函数至少两个参数，第一个参数是要发送的信号名，第二个或者后面的参数是待发送信号的PID。&lt;strong&gt;Perl kill的返回值为成功交付信号的进程数量&lt;/strong&gt;(因为有些信号忽略的进程没必要计算是否接收了信号，所以忽略的信号不计数)：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 发送INT信号给多个进程
kill 'INT', @mychildren;

# 更易读的方式
kill INT =&amp;gt; @mychildren, $grandpatoo;

# 进程自杀
kill KILL =&amp;gt; $$;
kill (9, $$);     # 使用数值格式的信号

# 发送信号给父进程
kill USR1 =&amp;gt; getppid;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中getppid函数用来获取父进程的PID。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;向一个负数的PID发送信号，表示将信号发送给该PID所在进程组&lt;/strong&gt;(包括子进程、兄弟进程，甚至可能会包括父进程)。例如，下面的语句表示发送HUP信号给当前进程自身所在的进程组：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;kill HUP =&amp;gt; -$$;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;HUP信号经常会发送给父进程，然后父进程会发送给其所有子进程来终止它们，并重新初始化它们。例如apache httpd可以发送一个HUP信号给main进程，来重新fork子进程。当然，在这过程中，父进程自身可能并不希望被HUP终止，所以这时常为父进程设置信号忽略。如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;sub huphandler{
    local $SIG{HUP} = 'IGNORE';
    kill HUP =&amp;gt; -$$;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;信号0是特殊的信号，它不会有任何操作，仅仅用来检查进程是否存在&lt;/strong&gt;。因为kill返回值是正确接收信号的进程数量，如果进程存在，0信号就会被接收但却不会做任何处理，但kill的返回值却为1。例如，检查某个子进程是否存在：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;kill (0 =&amp;gt; $child) or warn &quot;Child $child is dead!&quot;;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;sigalrm信号alarm&quot;&gt;SIGALRM信号：ALARM&lt;/h2&gt;
&lt;p&gt;alarm常用来做一个计时器，计时到了就发送ALRM信号来终止计时器所在进程。&lt;/p&gt;
&lt;p&gt;可以通过alarm函数设置一个计时器，它的参数是0或正数，正数表示计时多少秒，0表示取消当前已有的计时器。每个进程只能有一个alarm计时器。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 30秒的计时器
alarm 30;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;计时器计时到了，就会立即发送ALRM信号，该信号默认行为是终止当前进程，除非设置了ALRM信号的处理方式。例如，下面定义了一个2秒的计时器，后面还睡眠5秒：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ perl -le 'alarm 2;sleep 5;'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在睡眠5秒的过程中，大概在第二秒后就直接终止进程了，而不是等到5秒都睡眠完。&lt;/p&gt;
&lt;p&gt;需要注意的是，前面说过安全的信号处理机制会等待当前正在执行的opcode执行完再处理信号，所以alarm定义的计时器可能并不那么精确，出现一点点的误差是经常性的。&lt;/p&gt;
&lt;p&gt;重新设置计时器会覆盖之前已有的计时器。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;alarm 30;   # 30秒的计时器
... do something ...
alarm 5;    # 覆盖前面的定时器，重新定义一个5秒的计时器&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;alarm函数的参数设置为0表示取消已有的alarm计时器，但注意取消计时器不会发送SIGALRM信号。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;alarm 0;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;计时器有时候非常好用，它是非阻塞模式的sleep，可以让我们回到交互模式下并计时。例如，下面的示例中要求在5秒内输入一个字符，如果没输入就一直提示&quot;Hurry UP:&quot;，并继续设置5秒的计时器等待输入，由于ReadKey是阻塞的，只要一输入就不再阻塞，于是进入后续语句并很快到达程序的尾部并正常结束。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#!/usr/bin/perl
use strict;
use warnings;
use Term::ReadKey;

# Make read blocking until a key is pressed, and turn on autoflushing (no
# buffered IO)
ReadMode 'cbreak';
$| = 1;

sub alarmhandler {
    print &quot;\nHurry up!: &quot;;
    alarm 5;
}

$SIG{ALRM} = \&amp;amp;alarmhandler;

alarm 5;
print &quot;Hit a key: &quot;;
my $key = ReadKey 0;
print &quot;\n You typed '$key' \n&quot;;

# cancel alarm
alarm 0;

# reset readmode
ReadMode 'restore';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的alarm 0其实是多余的，因为只要输入了字符后，基本上立即就到达了程序的结尾而正常结束，所以不需要alarm 0来取消计时器。但在稍微大一点的程序中，取消计时器是很有必要的，因为我们不知道什么时候程序结束。&lt;/p&gt;
</description>
<pubDate>Fri, 15 Feb 2019 14:27:00 +0000</pubDate>
<dc:creator>骏马金龙</dc:creator>
<og:description>信号处理 操作系统可以通过信号(signal)处理机制来实现一些功能：程序注册好待监视的信号处理机制，在程序运行过程中如果产生了对应的信号，则会按照注册好的处理方式进行处理。 signal基础 每个进</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/f-ck-need-u/p/10386248.html</dc:identifier>
</item>
<item>
<title>算法xio讲堂#2--线段树 - chhokmah</title>
<link>http://www.cnblogs.com/chhokmah/p/10383367.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chhokmah/p/10383367.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/02/15/krp8AJ.jpg&quot;/&gt;&lt;/p&gt;

&lt;p&gt;（来自TRTTG大佬的供图）&lt;br/&gt;线段树个人理解和运用时，认为这个是一个比较实用的优化算法。&lt;br/&gt;这个东西和区间树有点相似，是一棵二叉搜索树，也就是查找节点和节点所带值的一种算法。&lt;br/&gt;使用线段树可以快速的查找某一个节点在若干条线段中出现的次数，时间复杂度为O(logN)，这个时间复杂度非常的理想，但是空间复杂度在应用时是开4N的。&lt;br/&gt;所以这个算法有优势，也有劣势。&lt;/p&gt;
&lt;h2 id=&quot;我们提出一个问题&quot;&gt;我们提出一个问题&lt;/h2&gt;
&lt;p&gt;如果当前有一个区间，需要你在给定区间内做以下操作：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;l,z 在l上加上z&lt;/li&gt;
&lt;li&gt;l 查询l的值&lt;/li&gt;
&lt;li&gt;l,r,z 在[l,r]区间所有数都+z&lt;/li&gt;
&lt;li&gt;l,r, 查询l到r之间的和&lt;br/&gt;你是不是在想，暴力解决一切问题，但是如果给你的数据是极大的，暴力完全做不了。&lt;br/&gt;那么我们就需要使用线段树了。&lt;br/&gt;我们就以这个问题为例来对线段树进行讲解。&lt;br/&gt;先提供一下这个题目的AC代码&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
const int maxn=10010;
struct segment_tree{
    int l,r,sum,lazy;
}tree[maxn&amp;lt;&amp;lt;2];
int a[maxn];
int n,m;
void pushup(int nod) {
    tree[nod].sum=tree[nod&amp;lt;&amp;lt;1].sum+tree[(nod&amp;lt;&amp;lt;1)+1].sum;
}
void pushdown(int nod,int l,int r) {
    int mid=(l+r)&amp;gt;&amp;gt;1;
    tree[nod&amp;lt;&amp;lt;1].sum+=(mid-l+1)*tree[nod].lazy;
    tree[(nod&amp;lt;&amp;lt;1)+1].sum+=(r-mid)*tree[nod].lazy;
    tree[nod&amp;lt;&amp;lt;1].lazy+=tree[nod].lazy;
    tree[(nod&amp;lt;&amp;lt;1)+1].lazy+=tree[nod].lazy;
    tree[nod].lazy=0;
}
void build(int l,int r,int nod) {
    if (l==r) {
        tree[nod].sum=a[l];
        tree[nod].l=l;
        tree[nod].r=r;
        tree[nod].lazy=0;
        return;
    }
    int mid=(l+r)&amp;gt;&amp;gt;1;
    build(l,mid,nod&amp;lt;&amp;lt;1);
    build(mid+1,r,(nod&amp;lt;&amp;lt;1)+1);
    pushup(nod);
}
void update1(int l,int r,int k,int value,int nod) {
    if (l==r) {
        tree[nod].sum+=value;
        return ;
    }
    int mid=(l+r)&amp;gt;&amp;gt;1;
    pushdown(nod,l,r);
    if (k&amp;lt;=mid) update1(l,mid,k,value,nod&amp;lt;&amp;lt;1);
    else update1(mid+1,r,k,value,(nod&amp;lt;&amp;lt;1)+1);
    pushup(nod);
}
int query1(int l,int r,int nod,int k) {
    if (l==r) return tree[nod].sum;
    int mid=(l+r)&amp;gt;&amp;gt;1;
    pushdown(nod,l,r);
    if (k&amp;lt;=mid) return query1(l,mid,nod&amp;lt;&amp;lt;1,k);
    else return query1(mid+1,r,(nod&amp;lt;&amp;lt;1)+1,k);
}
void update2(int l,int r,int ll,int rr,int nod,int value) {
    if (l==ll&amp;amp;&amp;amp;r==rr) {
        tree[nod].sum+=(r-l+1)*value;
        tree[nod].lazy+=value;
        return;
    }
    pushdown(nod,l,r);
    int mid=(l+r)&amp;gt;&amp;gt;1;
    if (rr&amp;lt;=mid) update2(l,mid,ll,rr,nod&amp;lt;&amp;lt;1,value);
    else if (ll&amp;gt;mid) update2(mid+1,r,ll,rr,(nod&amp;lt;&amp;lt;1)+1,value);
    else {
        update2(l,mid,ll,mid,nod&amp;lt;&amp;lt;1,value);
        update2(mid+1,r,mid+1,rr,(nod&amp;lt;&amp;lt;1)+1,value);
    }
    pushup(nod);
}
int query2(int l,int r,int ll,int rr,int nod) {
    if (l==ll&amp;amp;r==rr) {
        return tree[nod].sum;
    }
    pushdown(nod,l,r);
    int mid=(l+r)&amp;gt;&amp;gt;1;
    if (rr&amp;lt;=mid) return query2(l,mid,ll,rr,nod&amp;lt;&amp;lt;1);
    else if (ll&amp;gt;mid) return query2(mid+1,r,ll,rr,(nod&amp;lt;&amp;lt;1)+1);
    else return query2(l,mid,ll,mid,nod&amp;lt;&amp;lt;1)+query2(mid+1,r,mid+1,rr,(nod&amp;lt;&amp;lt;1)+1);
}
int main()
{
    scanf(&quot;%d%d&quot;,&amp;amp;n,&amp;amp;m);
    for (int i=1;i&amp;lt;=n;i++) scanf(&quot;%d&quot;,&amp;amp;a[i]);
    build(1,n,1);
    while (m--) {
        int c,x,y,z;
        scanf(&quot;%d&quot;,&amp;amp;c);
        if (c==1) {
            scanf(&quot;%d%d&quot;,&amp;amp;x,&amp;amp;y);
            update1(1,n,x,y,1);
        }
        if (c==2) {
            scanf(&quot;%d&quot;,&amp;amp;x);
            printf(&quot;%d\n&quot;,query1(1,n,1,x));
        } 
        if (c==3) {
            scanf(&quot;%d%d%d&quot;,&amp;amp;x,&amp;amp;y,&amp;amp;z);
            update2(1,n,x,y,1,z);
        }
        if (c==4) {
            scanf(&quot;%d%d&quot;,&amp;amp;x,&amp;amp;y);
            printf(&quot;%d\n&quot;,query2(1,n,x,y,1));
        }
    }
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;线段树的一些基本操作&quot;&gt;线段树的一些基本操作&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;建树&lt;/li&gt;
&lt;li&gt;单点修改&lt;/li&gt;
&lt;li&gt;单点查找&lt;/li&gt;
&lt;li&gt;区间修改&lt;/li&gt;
&lt;li&gt;区间查找&lt;/li&gt;
&lt;li&gt;pushup（儿子把信息传给父亲）&lt;/li&gt;
&lt;li&gt;pushdown（父亲把信息传给儿子）&lt;br/&gt;（其他的应该都是这些基本操作的变形）&lt;br/&gt;以下我们来逐一讲解一下&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;结构体&quot;&gt;结构体&lt;/h2&gt;
&lt;p&gt;作为一课非常正经的树，我们还是要给它开一个结构体。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;    struct segment_tree{
        int l,r,sum;
    }tree[maxn];&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;关于线段树的一些小提醒&quot;&gt;关于线段树的一些小提醒&lt;/h2&gt;
&lt;p&gt;我们写线段树，应该先知道当前节点nod的左右儿子的编号是多少，答案是(nod&lt;em&gt;2)和(nod&lt;/em&gt;2+1)&lt;br/&gt;为什么？我们写的线段树应该是一棵满二叉树，所以根据满二叉树节点的特点，我们就可以知道了他的儿子就是以上的答案。&lt;/p&gt;
&lt;h2 id=&quot;建树&quot;&gt;建树&lt;/h2&gt;
&lt;p&gt;由于是二叉搜索树，也就是一个二叉树，需要做搜索操作。那么我们就是以树状结构来存储数据。&lt;br/&gt;我们来了解一下线段树：&lt;br/&gt;我们设当前的线段树的节点是&lt;span class=&quot;math display&quot;&gt;\[ tree.l\ tree.r \]&lt;/span&gt;，也就是当前这段区间的左右l和r。（其实我们在写代码的时候一般是不写这个l和r的）&lt;br/&gt;其次我们还需要当前节点&lt;span class=&quot;math display&quot;&gt;\[ tree.sum \]&lt;/span&gt;，表示当前节点所带的值。&lt;br/&gt;在后面我们会讲到&lt;span class=&quot;math display&quot;&gt;\[ tree.lazy \]&lt;/span&gt;，表示当前节点的懒标记，来方便我们进行区间修改的一个东西，我们现在先不讲&lt;br/&gt;线段树的基本思想：二分。&lt;br/&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/1056834/201701/1056834-20170105203630800-980605038.jpg&quot;/&gt;&lt;br/&gt;那么就可以得到线段树的建树的程序&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void build(int l,int r,int nod) {
    if (l==r) {
        tree[nod].sum=a[l];
        tree[nod].l=l;
        tree[nod].r=r;
        return;
    }
    int mid=(l+r)&amp;gt;&amp;gt;1;
    build(l,mid,nod&amp;lt;&amp;lt;1);
    build(mid+1,r,(nod&amp;lt;&amp;lt;1)+1);
    pushup(nod);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有人在问这个pushup是什么东西？&lt;/p&gt;
&lt;h2 id=&quot;pushup&quot;&gt;pushup&lt;/h2&gt;
&lt;p&gt;pushup就是把儿子的信息上传给自己的父亲节点&lt;br/&gt;以当前问题为例，那么这个pushup的过程就是以下程序&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void pushup(int nod) {
    tree[nod].sum=tree[nod&amp;lt;&amp;lt;1].sum+tree[(nod&amp;lt;&amp;lt;1)+1].sum;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实也就是把和上传给父亲，非常简单，其他的pushup都是这个道理&lt;/p&gt;
&lt;h2 id=&quot;单点修改&quot;&gt;单点修改&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/1056834/201701/1056834-20170105214338878-2092313389.jpg&quot;/&gt;&lt;br/&gt;我们单点修改只需要直接在原节点上修改就可以了。&lt;br/&gt;那么我们废话不多说，直接上代码更好理解&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void update(int l,int r,int k,int value,int nod){
    if(l==r) {
        tree[nod].sum+=value;
        return;
    }
    int mid=(l+r)/2;
    if(k&amp;lt;=mid)update(l,mid,k,value,nod*2);
    else update(mid+1,r,k,value,nod*2+1);
    pushup(nod);
    return;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段程序也就是左右查找当前节点，k是我们需要寻找的节点，如果在左区间，那么就在左区间查找，有区间也是这个意思。&lt;/p&gt;
&lt;h2 id=&quot;单点查找&quot;&gt;单点查找&lt;/h2&gt;
&lt;p&gt;方法与二分查询基本一致，如果当前枚举的点左右端点相等，即叶子节点，就是目标节点。如果不是，因为这是二分法,所以设查询位置为x，当前结点区间范围为了l，r，中点为mid，则如果x&amp;lt;=mid，则递归它的左孩子，否则递归它的右孩子。&lt;br/&gt;直接上代码&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;int query(int l,int r,int ll,int rr,int nod){
    if(l==ll&amp;amp;&amp;amp;r==rr)return tree[nod].sum;
    int mid=(l+r)/2;
    if(rr&amp;lt;=mid)return query(l,mid,ll,rr,nod*2);
    else if(ll&amp;gt;mid)return query(mid+1,r,ll,rr,nod*2+1);
    else return query(l,mid,ll,mid,nod*2)+query(mid+1,r,mid+1,rr,nod*2+1);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;非常的简单我们就不多说了&lt;/p&gt;
&lt;h2 id=&quot;区间修改&quot;&gt;区间修改&lt;/h2&gt;
&lt;p&gt;我们思考一个问题，如果我们只是像单点修改那样子，用一个循环语句，把要修改区间内的所有点都进行单点修改，那么这个的复杂度应该是O(NlogN)，那么这就无法发挥出线段树的优势了。&lt;br/&gt;那么我们应该怎么做呢？&lt;br/&gt;这个时候我们就需要引入一个叫做懒标记的东西。&lt;br/&gt;顾名思义，这个就是一个非常懒的标记，这个就是在我们要的区间内的节点上所加的标记，这个标记也就只有我们要对父亲区间内的数进行修改或者附其他值的时候才会用到的一个东西。&lt;br/&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/1056834/201701/1056834-20170107082253862-1637203209.jpg&quot;/&gt;&lt;br/&gt;这个标记比较难理解，所以我们稍微讲的详细一点？&lt;br/&gt;首先如果要对一个区间内的节点进行修改，那么就只需要在所需的区间内进行修改，也就只是放在那里，让他不要动。&lt;br/&gt;当你要对接下来的区间内的数进行询问时，我们就需要进行pushdown的操作，这个操作就是要把父亲的懒标记上所拥有的全部信息全部给自己的儿子。&lt;br/&gt;再传给儿子后，我们的父亲就要删除自己的懒标记，因为自己的懒标记已经传给了自己的儿子了，为了不产生错误，我们就要删除父亲的懒标记。&lt;br/&gt;还是与我们这个例题为例，我们的区间修改的应该是这样写的：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void update2(int l,int r,int ll,int rr,int nod,int value) {
    if (l==ll&amp;amp;&amp;amp;r==rr) {
        tree[nod].sum+=(r-l+1)*value;
        tree[nod].lazy+=value;
        return;
    }
    pushdown(nod,l,r);
    int mid=(l+r)&amp;gt;&amp;gt;1;
    if (rr&amp;lt;=mid) update2(l,mid,ll,rr,nod&amp;lt;&amp;lt;1,value);
    else if (l&amp;gt;mid) update2(mid+1,r,ll,rr,(nod&amp;lt;&amp;lt;1)+1,value);
    else {
        update2(l,mid,ll,mid,nod&amp;lt;&amp;lt;1,value);
        update2(mid+1,r,mid+1,rr,(nod&amp;lt;&amp;lt;1)+1,value);
    }
    pushup(nod);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们再回到这个问题，为什么会有这么多的if语句，我们现在来讲解一下&lt;br/&gt;ll，rr是需要修改的区间。&lt;br/&gt;当你的区间的rr也就是最右边在mid的左边，那么说明我们整个区间就在l和mid之间，就是以下的情况&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/09/20/inpqlq.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好了右区间也是一样，其他的情况就是当前的区间分布在mid的左右，那么就分成两部分修改就可以了&lt;br/&gt;那么最后因为儿子可能被改变了，所以我们就要pushup一下。&lt;/p&gt;
&lt;h3 id=&quot;小提醒&quot;&gt;小提醒&lt;/h3&gt;
&lt;p&gt;如果你实在不知道什么时候要pushup或者是pushdown，那么多多益善，这样只是会增高你的时间复杂度，而不会影响正确率。&lt;/p&gt;
&lt;h2 id=&quot;pushdown&quot;&gt;pushdown&lt;/h2&gt;
&lt;p&gt;这个操作在上文已经讲过是把父亲的lazy下传给儿子的过程。&lt;br/&gt;直接上代码&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void pushdown(int nod,int l,int r) {
    int mid=(l+r)&amp;gt;&amp;gt;1;
    tree[nod&amp;lt;&amp;lt;1].sum+=(mid-l+1)*tree[nod].lazy;
    tree[(nod&amp;lt;&amp;lt;1)+1].sum+=(r-mid)*tree[nod].lazy;
    tree[nod&amp;lt;&amp;lt;1].lazy+=tree[nod].lazy;
    tree[(nod&amp;lt;&amp;lt;1)+1].lazy+=tree[nod].lazy;
    tree[nod].lazy=0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;区间查询&quot;&gt;区间查询&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1056834/201712/1056834-20171203210412804-1934571165.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1056834/201712/1056834-20171203210856882-1912849394.png&quot;/&gt;&lt;br/&gt;这个道理和区间修改差不多，还更简单一点。&lt;br/&gt;也不多讲了，直接上代码&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;int query2(int l,int r,int ll,int rr,int nod) {
    if (l==ll&amp;amp;r==rr) {
        return tree[nod].sum;
    }
    pushdown(nod,l,r);
    int mid=(l+r)&amp;gt;&amp;gt;1;
    if (rr&amp;lt;=mid) return query2(l,mid,ll,rr,nod&amp;lt;&amp;lt;1);
    else if (ll&amp;gt;mid) return query2(mid+1,r,ll,rr,(nod&amp;lt;&amp;lt;1)+1);
    else return query2(l,mid,ll,mid,nod&amp;lt;&amp;lt;1)+query2(mid+1,r,mid+1,rr,(nod&amp;lt;&amp;lt;1)+1);
}&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;codevs线段树练习&quot;&gt;&lt;a href=&quot;http://codevs.cn/problem/1080/&quot; title=&quot;codevs&quot;&gt;codevs线段树练习&lt;/a&gt;&lt;/h3&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
const int N=100000;
int tree[N*4+10],s[N];
 
void build(int l,int r,int nod)
{
    if(l==r){tree[nod]=s[l];return;}
    int mid=(l+r)/2;
    build(l,mid,2*nod); 
    build(mid+1,r,nod*2+1);
    tree[nod]=tree[nod*2]+tree[nod*2+1];
    return;
}
 
void update(int l,int r,int k,int value,int nod){
    if(l==r){tree[nod]+=value;return;}
    int mid=(l+r)/2;
    if(k&amp;lt;=mid)update(l,mid,k,value,nod*2);
    else update(mid+1,r,k,value,nod*2+1);
    tree[nod]=tree[nod*2]+tree[nod*2+1];
    return;
}
 
int query(int l,int r,int ll,int rr,int nod){
    if(l==ll&amp;amp;&amp;amp;r==rr)return tree[nod];
    int mid=(l+r)/2;
    if(rr&amp;lt;=mid)return query(l,mid,ll,rr,nod*2);
    else if(ll&amp;gt;mid)return query(mid+1,r,ll,rr,nod*2+1);
    else return query(l,mid,ll,mid,nod*2)+query(mid+1,r,mid+1,rr,nod*2+1);
}
 
int main()
{
    int n,m;
    scanf(&quot;%d&quot;,&amp;amp;n);
    for(int i=1;i&amp;lt;=n;i++)scanf(&quot;%d&quot;,&amp;amp;s[i]);
    build(1,n,1);
    scanf(&quot;%d&quot;,&amp;amp;m);
    while(m--){
        int x,y,z;
        scanf(&quot;%d%d%d&quot;,&amp;amp;x,&amp;amp;y,&amp;amp;z);
        if(x==1)update(1,n,y,z,1);
        else printf(&quot;%d\n&quot;,query(1,n,y,z,1));
    }
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;codevs线段树练习2&quot;&gt;&lt;a href=&quot;http://codevs.cn/problem/1081/&quot;&gt;codevs线段树练习2&lt;/a&gt;&lt;/h3&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
const int N=1000000;
int tree[N*4+10],a[N];
 
void update(int nod,int l,int r,int ll,int rr,int value){
    if(l==ll&amp;amp;&amp;amp;r==rr){tree[nod]+=value;return;}
    int mid=(l+r)/2;
    if(rr&amp;lt;=mid)update(2*nod,l,mid,ll,rr,value);
    else if(ll&amp;gt;mid)update(nod*2+1,mid+1,r,ll,rr,value);
    else{
        update(2*nod,l,mid,ll,mid,value);
        update(2*nod+1,mid+1,r,mid+1,rr,value);
    }
    return;
}
 
void pushdown(int nod){
    tree[nod*2+1]+=tree[nod];
    tree[nod*2]+=tree[nod];
    tree[nod]=0;
    return;
}
 
int query(int nod,int l,int r,int k){
    if(l==r)return a[l]+tree[nod];
    int mid=(l+r)/2;
    pushdown(nod);
    if(k&amp;lt;=mid)return query(2*nod,l,mid,k);
    else return query(2*nod+1,mid+1,r,k);
}
 
int main()
{
    int n,m;
    scanf(&quot;%d&quot;,&amp;amp;n);
    for(int i=1;i&amp;lt;=n;i++)scanf(&quot;%d&quot;,&amp;amp;a[i]);
    scanf(&quot;%d&quot;,&amp;amp;m);
    while(m--){
        int x,y,z,k;
        scanf(&quot;%d&quot;,&amp;amp;x);
        if(x==1){
            scanf(&quot;%d%d%d&quot;,&amp;amp;y,&amp;amp;z,&amp;amp;k);
            update(1,1,n,y,z,k);
        }
        else{
            scanf(&quot;%d&quot;,&amp;amp;y);
            printf(&quot;%d\n&quot;,query(1,1,n,y));
        }
    }
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;codevs线段树练习4&quot;&gt;&lt;a href=&quot;http://codevs.cn/problem/1082/&quot;&gt;codevs线段树练习4&lt;/a&gt;&lt;/h3&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
const int N(200000);
struct node{
    long long sum,add;
}tree[4*N+10];
int a[N+10];
 
inline void pushdown(long long nod,long long l,long long r){
    long long mid((l+r)&amp;gt;&amp;gt;1);
    tree[nod&amp;lt;&amp;lt;1].sum+=(mid-l+1)*tree[nod].add;
    tree[(nod&amp;lt;&amp;lt;1)+1].sum+=(r-mid)*tree[nod].add;
    tree[nod&amp;lt;&amp;lt;1].add+=tree[nod].add;
    tree[(nod&amp;lt;&amp;lt;1)+1].add+=tree[nod].add;
    tree[nod].add=0;
    return;
}
 
inline long long read(){    
    long long x(0);
    char ch=getchar();    
    while(ch&amp;lt;'0'||ch&amp;gt;'9')ch=getchar();    
    while(ch&amp;gt;='0'&amp;amp;&amp;amp;ch&amp;lt;='9'){x=x*10+ch-'0';ch=getchar();}    
    return x;    
}   
 
void pushup(long long nod){
    tree[nod].sum=tree[nod&amp;lt;&amp;lt;1].sum+tree[(nod&amp;lt;&amp;lt;1)+1].sum;
    return;
}
 
void build(long long l,long long r,long long nod){
    tree[nod].add=0;
    if(l==r){
        tree[nod].sum=a[l];
        return;
    }
    long long mid((l+r)&amp;gt;&amp;gt;1);
    build(l,mid,nod&amp;lt;&amp;lt;1); 
    build(mid+1,r,(nod&amp;lt;&amp;lt;1)+1);
    tree[nod].sum=tree[nod&amp;lt;&amp;lt;1].sum+tree[(nod&amp;lt;&amp;lt;1)+1].sum;
    return;
}
 
void update(long long l,long long r,long long ll,long long rr,long long value,long long nod){
    if(l==ll&amp;amp;&amp;amp;r==rr){
        tree[nod].sum+=(r-l+1)*value;
        tree[nod].add+=value;
        return;
    }   
    pushdown(nod,l,r);
    long long mid((l+r)&amp;gt;&amp;gt;1);
    if(rr&amp;lt;=mid)update(l,mid,ll,rr,value,nod&amp;lt;&amp;lt;1);
    else if(ll&amp;gt;mid)update(mid+1,r,ll,rr,value,(nod&amp;lt;&amp;lt;1)+1);
    else{
        update(l,mid,ll,mid,value,nod&amp;lt;&amp;lt;1);
        update(mid+1,r,mid+1,rr,value,(nod&amp;lt;&amp;lt;1)+1);
    }
    pushup(nod);
    return;
}
  
long long query(long long l,long long r,long long ll,long long rr,long long nod){
    if(l==ll&amp;amp;&amp;amp;r==rr)return tree[nod].sum;
    pushdown(nod,l,r);
    long long mid=(l+r)&amp;gt;&amp;gt;1;
    if(rr&amp;lt;=mid)return query(l,mid,ll,rr,nod&amp;lt;&amp;lt;1);
    else if(ll&amp;gt;mid)return query(mid+1,r,ll,rr,(nod&amp;lt;&amp;lt;1)+1);
    else return query(l,mid,ll,mid,nod*2)+query(mid+1,r,mid+1,rr,(nod&amp;lt;&amp;lt;1)+1);
}
  
int main()
{
    long long m;
    register long long n;
    m=read();
    for(long long i=1;i&amp;lt;=m;++i)a[i]=read();
    build(1,m,1);
    n=read();
    while(n--){
        long long t,x,y,z;
        t=read();
        if(t==1){
            x=read(); y=read(); z=read();
            update(1,m,x,y,z,1);
        }
        else{
            x=read(); y=read();
            printf(&quot;%lld\n&quot;,query(1,m,x,y,1));
        }
    }
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;codevs线段树练习4-1&quot;&gt;&lt;a href=&quot;http://codevs.cn/problem/4919/&quot;&gt;codevs线段树练习4&lt;/a&gt;&lt;/h3&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cmath&amp;gt;
using namespace std;
const int N=1000000;
int add[N],sum[N*4+10][7],a[N];
 
inline int read(){    
    int x(0);
    char ch=getchar();    
    while(ch&amp;lt;'0'||ch&amp;gt;'9')ch=getchar();    
    while(ch&amp;gt;='0'&amp;amp;&amp;amp;ch&amp;lt;='9'){x=x*10+ch-'0';ch=getchar();}    
    return x;    
}
 
void pushup(int nod){
    for(int i=0;i&amp;lt;7;i++)
        sum[nod][i]=sum[nod&amp;lt;&amp;lt;1][i]+sum[(nod&amp;lt;&amp;lt;1)+1][i];
    return;
}
 
void build(int l,int r,int nod){
    if(l==r){
        sum[nod][a[l]%7]++;
        return;
    }
    int mid((l+r)&amp;gt;&amp;gt;1);
    build(l,mid,nod&amp;lt;&amp;lt;1);
    build(mid+1,r,(nod&amp;lt;&amp;lt;1)+1);
    pushup(nod);
    return;
}
 
void modify(int nod,int v){
    int t[7];
    for(int i=0;i&amp;lt;7;i++)
        t[(i+v)%7]=sum[nod][i];
    for(int i=0;i&amp;lt;7;i++)
        sum[nod][i]=t[i];
    add[nod]=(add[nod]+v)%7;
    return; 
}
 
void pushdown(int nod){
    modify(nod&amp;lt;&amp;lt;1,add[nod]);
    modify((nod&amp;lt;&amp;lt;1)+1,add[nod]);
    add[nod]=0;
    return;
}
 
int query(int l,int r,int ll,int rr,int nod){
    if(l==ll&amp;amp;&amp;amp;r==rr)
        return sum[nod][0];
    int mid((l+r)&amp;gt;&amp;gt;1);
    pushdown(nod);
    if(rr&amp;lt;=mid)query(l,mid,ll,rr,nod&amp;lt;&amp;lt;1);
    else if(ll&amp;gt;mid)query(mid+1,r,ll,rr,(nod&amp;lt;&amp;lt;1)+1);
    else return query(l,mid,ll,mid,nod&amp;lt;&amp;lt;1)+query(mid+1,r,mid+1,rr,(nod&amp;lt;&amp;lt;1)+1);
}
 
void update(int l,int r,int ll,int rr,int value,int nod){
    if(l==ll&amp;amp;&amp;amp;r==rr){
        modify(nod,value);
        return;
    }
    int mid((l+r)&amp;gt;&amp;gt;1);
    pushdown(nod);
    if(rr&amp;lt;=mid)update(l,mid,ll,rr,value,nod&amp;lt;&amp;lt;1);
    else if(ll&amp;gt;mid)update(mid+1,r,ll,rr,value,(nod&amp;lt;&amp;lt;1)+1);
    else{
        update(l,mid,ll,mid,value,nod&amp;lt;&amp;lt;1);
        update(mid+1,r,mid+1,rr,value,(nod&amp;lt;&amp;lt;1)+1);
    }
    pushup(nod);
    return; 
}
 
int main()
{
    int n;
    n=read();
    for(int i=1;i&amp;lt;=n;i++)scanf(&quot;%d&quot;,&amp;amp;a[i]);
    build(1,n,1);
    int q;
    q=read();
    while(q--){
        char s[10];
        scanf(&quot;%s&quot;,s);
        if(s[0]=='c'){
            int x,y;
            x=read();
            y=read();
            printf(&quot;%d\n&quot;,query(1,n,x,y,1));
        }
        else{
            int x,y,z;
            x=read();
            y=read();
            z=read();
            update(1,n,x,y,z,1);
        }
    }
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 15 Feb 2019 13:48:00 +0000</pubDate>
<dc:creator>chhokmah</dc:creator>
<og:description>浅谈线段树 （来自TRTTG大佬的供图） 线段树个人理解和运用时，认为这个是一个比较实用的优化算法。 这个东西和区间树有点相似，是一棵二叉搜索树，也就是查找节点和节点所带值的一种算法。 使用线段树可以</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chhokmah/p/10383367.html</dc:identifier>
</item>
<item>
<title>强化学习(十七) 基于模型的强化学习与Dyna算法框架 - 刘建平Pinard</title>
<link>http://www.cnblogs.com/pinard/p/10384424.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pinard/p/10384424.html</guid>
<description>&lt;p&gt;　　　　在前面我们讨论了基于价值的强化学习(Value Based RL)和基于策略的强化学习模型(Policy Based RL)，本篇我们讨论最后一种强化学习流派，基于模型的强化学习(Model Based RL)，以及基于模型的强化学习算法框架Dyna。&lt;/p&gt;
&lt;p&gt;　　　　本篇主要参考了UCL强化学习课程的第8讲和Dyna-2的&lt;a href=&quot;http://www0.cs.ucl.ac.uk/staff/D.Silver/web/Applications_files/dyna2.pdf&quot; target=&quot;_blank&quot;&gt;论文&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;　　　　基于价值的强化学习模型和基于策略的强化学习模型都不是基于模型的，它们从价值函数，策略函数中直接去学习，不用学习环境的状态转化概率模型，即在状态$s$下采取动作$a$,转到下一个状态$s'$的概率$P_{ss'}^a$。&lt;/p&gt;
&lt;p&gt;　　　　而基于模型的强化学习则会尝试从环境的模型去学习，一般是下面两个相互独立的模型：一个是状态转化预测模型，输入当前状态$s$和动作$a$，预测下一个状态$s'$。另一个是奖励预测模型，输入当前状态$s$和动作$a$，预测环境的奖励$r$。即模型可以描述为下面两个式子：$$S_{t+1} \sim P(S_{t+1}|S_t,A_t)$$$$R_{t+1} \sim R(R_{t+1}|S_t,A_t)$$&lt;/p&gt;
&lt;p&gt;　　　　如果模型$P,R$可以准确的描述真正的环境的转化模型，那么我们就可以基于模型来预测，当有一个新的状态$S$和动作$A$到来时，我们可以直接基于模型预测得到新的状态和动作奖励，不需要和环境交互。当然如果我们的模型不好，那么基于模型预测的新状态和动作奖励可能错的离谱。&lt;/p&gt;
&lt;p&gt;　　　　从上面的描述我们可以看出基于模型的强化学习和不基于模型的强化学习的主要区别：即基于模型的强化学习是从模型中学习，而不基于模型的强化学习是从和环境交互的经历去学习。&lt;/p&gt;
&lt;p&gt;　　　　下面这张图描述了基于模型的强化学习的思路：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1042406/201902/1042406-20190215171535580-166719567.png&quot; alt=&quot;&quot; width=&quot;383&quot; height=&quot;260&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　　　这里我们看看基于模型的强化学习算法训练流程，其流程和我们监督学习算法是非常类似的。&lt;/p&gt;
&lt;p&gt;　　　　假设训练数据是若干组这样的经历：$$S_1,A_1,R_2,S_2,A_2,R_2,...,S_T$$&lt;/p&gt;
&lt;p&gt;　　　　对于每组经历，我们可以将其转化为$T-1$组训练样本，即：$$S_1,A_1 \to S_2,\;S_1,A_1 \to R_2$$$$S_2,A_2 \to S_3,\;S_2,A_2 \to R_3$$$$......$$$$S_{T-1},A_{T-1} \to S_T,\;S_{T_1},A_{T-1} \to R_T$$&lt;/p&gt;
&lt;p&gt;　　　　右边的训练样本一起组成了一个分类模型或密度估计模型，输入状态和动作，输出下一个状态。 右边的训练样本一起组成了一个回归模型训练集，输入状态和动作，输出动作奖励值。&lt;/p&gt;
&lt;p&gt;　　　　至此我们的强化学习求解过程和传统的监督学习算法没有太多区别了，可以使用传统的监督学习算法来求解这两个模型。&lt;/p&gt;
&lt;p&gt;　　　　当然还可以更简单，即通过对训练样本进行查表法进行统计，直接得到$P(S_{t+1}|S_t,A_t)$的概率和$R(R_{t+1}|S_t,A_t)$的平均值，这样就可以直接预测。比使用模型更简单。&lt;/p&gt;
&lt;p&gt;　　　　此外，还有其他的方法可以用来得到$P(S_{t+1}|S_t,A_t)$和$R(R_{t+1}|S_t,A_t)$，这个我们后面再讲。&lt;/p&gt;
&lt;p&gt;　　　　虽然基于模型的强化学习思路很清晰，而且还有不要和环境持续交互优化的优点，但是用于实际产品还是有很多差距的。主要是我们的模型绝大多数时候不能准确的描述真正的环境的转化模型，那么使用基于模型的强化学习算法得到的解大多数时候也不是很实用。那么是不是基于模型的强化学习就不能用了呢？也不是，我们可以将基于模型的强化学习和不基于模型的强化学习集合起来，取长补短，这样做最常见的就是Dyna算法框架。&lt;/p&gt;

&lt;p&gt;　　　　Dyna算法框架并不是一个具体的强化学习算法，而是一类算法框架的总称。Dyna将基于模型的强化学习和不基于模型的强化学习集合起来，既从模型中学习，也从和环境交互的经历去学习，从而更新价值函数和（或）策略函数。如果用和第一节类似的图，可以表示如下图，和第一节的图相比，多了一个“Direct RL“的箭头，这正是不基于模型的强化学习的思路。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1042406/201902/1042406-20190215182247817-703974446.png&quot; alt=&quot;&quot; width=&quot;457&quot; height=&quot;310&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　　　Dyna算法框架和不同的具体的不基于模型的强化学习一起，可以得到具体的不同算法。如果我们使用基于价值函数的Q-Learning，那么我们就得到了Dyna-Q算法。我们基于Dyna-Q来看看Dyna算法框架的一般流程.&lt;/p&gt;

&lt;p&gt;　　　　这里我们给出基于价值函数的Dyna-Q算法的概要流程。假设模型使用的是查表法。&lt;/p&gt;
&lt;p&gt;　　　　1.  初始化任意一个状态$s$,和任意一个动作$a$对应的状态价值$Q(s,a)$, 初始化奖励模型$R(s,a)$和状态模型$P(s,a)$&lt;/p&gt;
&lt;p&gt;　　　　2. for i=1 to 最大迭代次数T：&lt;/p&gt;
&lt;p&gt;　　　　　　a) S $\gets$ current state&lt;/p&gt;
&lt;p&gt;　　　　　　b) A $\gets$ $\epsilon-greedy(S,Q)$&lt;/p&gt;
&lt;p&gt;　　　　　　c) 执行动作$A$,得到新状态$S'$和奖励$R$&lt;/p&gt;
&lt;p&gt;　　　　　　d) 使用Q-Learning更新价值函数：$Q(S,A) =Q(S,A) + \alpha[R +\gamma\max_aQ(S',a) -Q(S,A)]$&lt;/p&gt;
&lt;p&gt;　　　　　　e) 使用$S,A,S'$更新状态模型$P(s,a)$，使用$S,A,R$更新状态模型$R(s,a)$&lt;/p&gt;
&lt;p&gt;　　　　　　f)  for j=1 to 最大次数n：&lt;/p&gt;
&lt;p&gt;　　　　　　　　i)  随机选择一个之前出现过的状态$S$, 在状态$S$上出现过的动作中随机选择一个动作$A$&lt;/p&gt;
&lt;p&gt;　　　　　　　　ii) 基于模型$P(S,A)$得到$S'$, 基于模型$R(S,A)$得到$R$&lt;/p&gt;
&lt;p&gt;　　　　　　　　iii) 使用Q-Learning更新价值函数：$Q(S,A) =Q(S,A) + \alpha[R +\gamma\max_aQ(S',a) -Q(S,A)]$&lt;/p&gt;

&lt;p&gt;　　　　从上面的流程可以看出，Dyna框架在每个迭代轮中，会先和环境交互，并更新价值函数和（或）策略函数，接着进行n次模型的预测，同样更新价值函数和（或）策略函数。这样同时利用上了和环境交互的经历以及模型的预测。&lt;/p&gt;

&lt;p&gt;　　　　在Dyna算法框架的基础上后来又发展出了Dyna-2算法框架。和Dyna相比，Dyna-2将和和环境交互的经历以及模型的预测这两部分使用进行了分离。还是以Q函数为例，Dyna-2将记忆分为永久性记忆（permanent memory）和瞬时记忆（transient memory）, 其中永久性记忆利用实际的经验来更新，瞬时记忆利用模型模拟经验来更新。&lt;/p&gt;
&lt;p&gt;　　　　永久性记忆的Q函数定义为：$$Q(S,A) = \phi(S,A)^T\theta$$&lt;/p&gt;
&lt;p&gt;　　　　瞬时记忆的Q函数定义为：$$Q'(S,A) = \overline{\phi}(S,A)^T\overline{\theta }$$&lt;/p&gt;
&lt;p&gt;　　　　组合起来后记忆的Q函数定义为：$$\overline{Q}(S,A) = \phi(S,A)^T\theta + \overline{\phi}(S,A)^T\overline{\theta }$$&lt;/p&gt;
&lt;p&gt;　　　　Dyna-2的基本思想是在选择实际的执行动作前，智能体先执行一遍从当前状态开始的基于模型的模拟，该模拟将仿真完整的轨迹，以便评估当前的动作值函数。智能体会根据模拟得到的动作值函数加上实际经验得到的值函数共同选择实际要执行的动作。价值函数的更新方式类似于$SARSA(\lambda)$&lt;/p&gt;
&lt;p&gt;　　　　以下是Dyna-2的算法流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1042406/201902/1042406-20190215195520956-916105819.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　　　基于模型的强化学习一般不单独使用，而是和不基于模型的强化学习结合起来，因此使用Dyna算法框架是常用的做法。对于模型部分，我们可以用查表法和监督学习法等方法，预测或者采样得到模拟的经历。而对于非模型部分，使用前面的Q-Learning系列的价值函数近似，或者基于Actor-Critic的策略函数的近似都是可以的。&lt;/p&gt;
&lt;p&gt;　　　　除了Dyna算法框架，我们还可以使用基于模拟的搜索(simulation-based search)来结合基于模型的强化学习和不基于模型的强化学习,并求解问题。这部分我们在后面再讨论。&lt;/p&gt;
&lt;p&gt;（欢迎转载，转载请注明出处。欢迎沟通交流： liujianping-ok@163.com） &lt;/p&gt;
</description>
<pubDate>Fri, 15 Feb 2019 12:22:00 +0000</pubDate>
<dc:creator>刘建平Pinard</dc:creator>
<og:description>在前面我们讨论了基于价值的强化学习(Value Based RL)和基于策略的强化学习模型(Policy Based RL)，本篇我们讨论最后一种强化学习流派，基于模型的强化学习(Model Base</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pinard/p/10384424.html</dc:identifier>
</item>
<item>
<title>CSS Grid 布局完全指南(图解 Grid 详细教程) - 消逝的风i</title>
<link>http://www.cnblogs.com/abc-x/p/10258695.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/abc-x/p/10258695.html</guid>
<description>
&lt;p&gt;CSS Grid 布局是 CSS 中最强大的布局系统。与 flexbox 的一维布局系统不同，CSS Grid 布局是一个二维布局系统，也就意味着它可以同时处理列和行。通过将 CSS 规则应用于 &lt;strong&gt;父元素&lt;/strong&gt; (成为 Grid Container 网格容器)和其 子元素（成为 Grid Items 网格项），你就可以轻松使用 Grid(网格) 布局。&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;CSS Grid(网格) 布局（又称为 “Grid(网格)” ），是一个二维的基于网格的布局系统，它的目标是完全改变我们基于网格的用户界面的布局方式。&lt;/p&gt;
&lt;p&gt;CSS 一直用来布局我们的网页，但一直以来都存在这样或那样的问题。&lt;/p&gt;
&lt;p&gt;一开始我们用表格（table），然后是浮动（float），再是定位（postion）和内嵌块（inline-block），但是所有这些方法本质上都是只是 hack 而已，并且遗漏了很多重要的功能（例如垂直居中）。&lt;/p&gt;
&lt;p&gt;Flexbox 的出现很大程度上改善了我们的布局方式，但它的目的是为了解决更简单的一维布局，而不是复杂的二维布局（实际上 Flexbox 和 Grid 能协同工作，而且配合得非常好）。&lt;/p&gt;
&lt;p&gt;Grid(网格) 布局是第一个专门为解决布局问题而创建的 CSS 模块，只要我们一直在制作网站，我们就一直要讨论这些问题。&lt;/p&gt;
&lt;p&gt;有两个主要因素激发了我创建本指南的灵感。第一个是 Rachel Andrew 出色的书籍 为 CSS Grid 布局做好准备。&lt;/p&gt;
&lt;p&gt;这本书对 Grid 布局做了全面，清晰的介绍 ，也是本指南的基础。我强烈建议你购买并阅读。&lt;/p&gt;
&lt;p&gt;另一个灵感来自 Chris Coyier 的 Flexbox 布局完整指南，这也是我学习 flexbox 首选的资源。&lt;/p&gt;
&lt;p&gt;这篇文章是帮助了很多人，这点从 Google “flexbox” 排名第一就可以看出来。你会发现那篇文章和我的文章有很多相似之处，为什么不跟随最好的文章呢？&lt;/p&gt;
&lt;p&gt;本指南的目的是介绍存在于最新版本的规范中 Grid(网格) 概念。所以我不会覆盖过时的 IE 语法，而且随着规范的逐渐成熟，我会尽我最大的努力去更新这个指南。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;基础知识和浏览器支持&lt;/strong&gt;&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;首先，你必须使用 &lt;code&gt;display: grid&lt;/code&gt; 将容器元素定义为一个 grid(网格) 布局，使用 &lt;code&gt;grid-template-columns&lt;/code&gt;和 &lt;code&gt;grid-template-rows&lt;/code&gt; 设置 列 和 行 的尺寸大小，然后通过 &lt;code&gt;grid-column&lt;/code&gt; 和 &lt;code&gt;grid-row&lt;/code&gt; 将其子元素放入这个 grid(网格) 中。&lt;/p&gt;
&lt;p&gt;与 flexbox 类似，网格项（grid items）的源(HTML结构)顺序无关紧要。你的 CSS 可以以任何顺序放置它们，这使得使用 媒体查询（media queries）重新排列网格变得非常容易。&lt;/p&gt;
&lt;p&gt;定义整个页面的布局，然后完全重新排列布局以适应不同的屏幕宽度，这些都只需要几行 CSS ，想象一下就让人兴奋。Grid(网格) 布局是有史以来最强大的 CSS 模块之一。&lt;/p&gt;
&lt;p&gt;截至2017年3月，许多浏览器都提供了对 CSS Grid 的原生支持，而且无需加浏览器前缀：Chrome（包括 Android ），Firefox，Edge，Safari（包括iOS）和 Opera 。 另一方面，Internet Explorer 10和11支持它，但是是一个过时的语法实现。 现在是时候使用 Grid 布局网页了！&lt;/p&gt;
&lt;p&gt;这个浏览器支持 CSS Grid 的数据，来自 Caniuse ，你可以查看更多的细节。 数字表示支持以上功能的浏览器版本号。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;桌面(Desktop) 浏览器&lt;/strong&gt;&lt;/h3&gt;

&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Chrome&lt;/th&gt;
&lt;th&gt;Opera&lt;/th&gt;
&lt;th&gt;Firefox&lt;/th&gt;
&lt;th&gt;IE&lt;/th&gt;
&lt;th&gt;Edge&lt;/th&gt;
&lt;th&gt;Safari&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;57&lt;/td&gt;
&lt;td&gt;44&lt;/td&gt;
&lt;td&gt;52&lt;/td&gt;
&lt;td&gt;11*(旧语法)&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;10.1&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3&gt;手机(Mobile) / 平板(Tablet)浏览器&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;iOS Safari&lt;/th&gt;
&lt;th&gt;Opera Mobile&lt;/th&gt;
&lt;th&gt;Opera Mini&lt;/th&gt;
&lt;th&gt;Android&lt;/th&gt;
&lt;th&gt;Android Chrome&lt;/th&gt;
&lt;th&gt;Android Firefox&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;10.3&lt;/td&gt;
&lt;td&gt;46&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;td&gt;67&lt;/td&gt;
&lt;td&gt;70&lt;/td&gt;
&lt;td&gt;63&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;除了微软之外，浏览器厂商似乎还没有对 Grid(网格) 搞自己的一套实现（比如加前缀），直到规范完全成熟。这是一件好事，因为这意味着我们不必担心学习多个语法。&lt;/p&gt;
&lt;p&gt;在生产中使用 Grid 只是时间问题。 但现在是学习的时候了。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;重要术语&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;在深入了解 Grid 的概念之前，理解术语是很重要的。由于这里涉及的术语在概念上都很相似，如果不先记住 Grid 规范定义的含义，很容易混淆它们。但是别担心，术语并不多。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;网格容器(Grid Container)&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;应用 &lt;code&gt;display: grid&lt;/code&gt; 的元素。这是所有 网格项（grid item）的直接父级元素。在这个例子中，&lt;code&gt;container&lt;/code&gt;就是 网格容器(Grid Container)。&lt;/p&gt;
&lt;p&gt;HTML 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;container&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;item item-1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;item item-2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;item item-3&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;strong&gt;网格项(Grid Item)&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;网格容器（Grid Container）的子元素（例如直接子元素）。这里 &lt;code&gt;item&lt;/code&gt; 元素就是网格项(Grid Item)，但是 &lt;code&gt;sub-item&lt;/code&gt; 不是。&lt;/p&gt;
&lt;p&gt;HTML 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;container&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;item&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;item&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;sub-item&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;item&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;strong&gt;网格线(Grid Line)&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;构成网格结构的分界线。它们既可以是垂直的（“列网格线(column grid lines)”），也可以是水平的（“行网格线(row grid lines)”），并位于行或列的任一侧。例如，这里的黄线就是一条列网格线。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1398770/201901/1398770-20190112094256094-940738302.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;网格轨道(Grid Track)&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;两条相邻网格线之间的空间。你可以把它们想象成网格的列或行。下图是第二条和第三条 行网格线 之间的 网格轨道(Grid Track)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1398770/201901/1398770-20190112094347983-1600699786.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;网格单元格(Grid Cell)&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;两个相邻的行和两个相邻的列网格线之间的空间。这是 Grid(网格) 系统的一个“单元”。下图是第 1 至第 2 条 行网格线 和第 2 至第 3 条 列网格线 交汇构成的 网格单元格(Grid Cell)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1398770/201901/1398770-20190112094431669-1943297651.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;网格区域(Grid Area)&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;4条网格线包围的总空间。一个 网格区域(Grid Area) 可以由任意数量的 网格单元格(Grid Cell) 组成。下图是 行网格线1和3，以及列网格线1和3 之间的网格区域。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1398770/201901/1398770-20190112095124867-1749287225.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;Grid(网格) 属性目录&lt;/strong&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;strong&gt;网格容器(Grid Container) 属性&lt;/strong&gt;&lt;/h4&gt;
&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;
&lt;p&gt;display&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;grid-template-columns&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;grid-template-rows&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;grid-template-areas&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;grid-template&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;grid-column-gap&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;grid-row-gap&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;grid-gap&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;justify-items&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;align-items&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;place-items&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;justify-content&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;align-content&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;place-content&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;grid-auto-columns&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;grid-auto-rows&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;grid-auto-flow&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;grid&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;&lt;strong&gt;网格项(Grid Items) 属性&lt;/strong&gt;&lt;/h4&gt;
&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;
&lt;p&gt;grid-column-start&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;grid-column-end&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;grid-row-start&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;grid-row-end&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;grid-column&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;grid-row&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;grid-area&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;justify-self&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;align-self&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;place-self&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;&lt;strong&gt;父元素 网格容器(Grid Container) 属性&lt;/strong&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;strong&gt;display&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;将元素定义为网格容器，并为其内容建立新的 &lt;em&gt;网格格式上下文&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;值：&lt;/p&gt;
&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.container &lt;/span&gt;{&lt;span&gt;
  display&lt;/span&gt;:&lt;span&gt; grid | inline-grid&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意：通过嵌套元素（也称为子网格，即 subgrid ）向下传递网格参数的能力已移至 CSS Grid 规范的 Level 2 版本。这里有 一个快速解释。&lt;/p&gt;
&lt;h4&gt;grid-template-columns / grid-template-rows&lt;/h4&gt;
&lt;p&gt;使用空格分隔的值列表，用来定义网格的列和行。这些值表示 网格轨道(Grid Track) 大小，它们之间的空格表示网格线。&lt;/p&gt;
&lt;p&gt;值：&lt;br/&gt;– &lt;code&gt;&amp;lt;track-size&amp;gt;&lt;/code&gt;： 可以是长度值，百分比，或者等份网格容器中可用空间（使用 &lt;code&gt;fr&lt;/code&gt; 单位）&lt;br/&gt;– &lt;code&gt;&amp;lt;line-name&amp;gt;&lt;/code&gt;：你可以选择的任意名称&lt;/p&gt;
&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.container &lt;/span&gt;{&lt;span&gt;
  grid-template-columns&lt;/span&gt;:&lt;span&gt; &amp;lt;track-size&amp;gt; ... | 
&amp;lt;line-name&amp;gt; &amp;lt;track-size&amp;gt; ...&lt;/span&gt;;&lt;span&gt;
  grid-template-rows&lt;/span&gt;:&lt;span&gt; &amp;lt;track-size&amp;gt; ... | 
&amp;lt;line-name&amp;gt; &amp;lt;track-size&amp;gt; ...&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;当你在 网格轨道(Grid Track) 值之间留出空格时，网格线会自动分配正数和负数名称：&lt;/p&gt;
&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.container &lt;/span&gt;{&lt;span&gt;
  grid-template-columns&lt;/span&gt;:&lt;span&gt; 40px 50px auto 50px 40px&lt;/span&gt;;&lt;span&gt;
  grid-template-rows&lt;/span&gt;:&lt;span&gt; 25% 100px auto&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1398770/201902/1398770-20190215182927643-1261833670.jpg&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是你可以明确的指定网格线(Grid Line)名称，例如 &amp;lt;line-name&amp;gt; 值。请注意网格线名称的括号语法：&lt;/p&gt;
&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.container &lt;/span&gt;{&lt;span&gt;
  grid-template-columns&lt;/span&gt;:&lt;span&gt; [first] 40px [line2] 50px 
 [line3] auto [col4-start] 50px [five] 40px [end]&lt;/span&gt;;&lt;span&gt;
  grid-template-rows&lt;/span&gt;:&lt;span&gt; [row1-start] 25% [row1-end] 100px 
 [third-line] auto [last-line]&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1398770/201902/1398770-20190215183126248-1525980520.jpg&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;请注意，一条网格线(Grid Line)可以有多个名称。例如，这里的第二条 行网格线(row grid lines) 将有两个名字：row1-end 和 row2-start ：&lt;/p&gt;
&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.container &lt;/span&gt;{&lt;span&gt;
  grid-template-rows&lt;/span&gt;:&lt;span&gt; [row1-start] 25% [row1-end row2-start] 25% [row2-end]&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果你的定义包含多个重复值，则可以使用 &lt;code&gt;repeat()&lt;/code&gt; 表示法来简化定义：&lt;/p&gt;
&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.container &lt;/span&gt;{&lt;span&gt;
  grid-template-columns&lt;/span&gt;:&lt;span&gt; repeat(3, 20px [col-start])&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的代码等价于：&lt;/p&gt;
&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.container &lt;/span&gt;{&lt;span&gt;
  grid-template-columns&lt;/span&gt;:&lt;span&gt; 20px [col-start] 20px [col-start] 20px [col-start]&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果多行共享相同的名称，则可以通过其网格线名称和计数来引用它们。&lt;/p&gt;
&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.item &lt;/span&gt;{&lt;span&gt;
  grid-column-start&lt;/span&gt;:&lt;span&gt; col-start 2&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;fr&lt;/code&gt; 单元允许你用等分网格容器剩余可用空间来设置 网格轨道(Grid Track) 的大小 。例如，下面的代码会将每个网格项设置为网格容器宽度的三分之一：&lt;/p&gt;
&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.container &lt;/span&gt;{&lt;span&gt;
  grid-template-columns&lt;/span&gt;:&lt;span&gt; 1fr 1fr 1fr&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;剩余可用空间是除去所有非灵活网格项 之后 计算得到的。在这个例子中，可用空间总量减去 50px 后，再给 &lt;code&gt;fr&lt;/code&gt; 单元的值 3 等分：&lt;/p&gt;
&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.container &lt;/span&gt;{&lt;span&gt;
  grid-template-columns&lt;/span&gt;:&lt;span&gt; 1fr 50px 1fr 1fr&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;grid-template-areas&lt;/h4&gt;
&lt;p&gt;通过引用 &lt;code&gt;grid-area&lt;/code&gt; 属性指定的 网格区域(Grid Area) 名称来定义网格模板。重复网格区域的名称导致内容跨越这些单元格。一个点号（&lt;code&gt;.&lt;/code&gt;）代表一个空单元格。这个语法本身可视作网格的可视化结构。&lt;/p&gt;
&lt;p&gt;值：&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;grid-area-name&amp;gt;&lt;/code&gt;：由网格项的 &lt;code&gt;grid-area&lt;/code&gt; 指定的网格区域名称&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;.&lt;/code&gt;（点号） ：代表一个空的网格单元&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;none&lt;/code&gt;：不定义网格区域&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.container &lt;/span&gt;{&lt;span&gt;
  grid-template-areas&lt;/span&gt;:&lt;span&gt; 
    &quot;&amp;lt;grid-area-name&amp;gt; | . | none | ...&quot;
    &quot;...&quot;&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.item-a &lt;/span&gt;{&lt;span&gt;
  grid-area&lt;/span&gt;:&lt;span&gt; header&lt;/span&gt;;
}&lt;span&gt;
.item-b &lt;/span&gt;{&lt;span&gt;
  grid-area&lt;/span&gt;:&lt;span&gt; main&lt;/span&gt;;
}&lt;span&gt;
.item-c &lt;/span&gt;{&lt;span&gt;
  grid-area&lt;/span&gt;:&lt;span&gt; sidebar&lt;/span&gt;;
}&lt;span&gt;
.item-d &lt;/span&gt;{&lt;span&gt;
  grid-area&lt;/span&gt;:&lt;span&gt; footer&lt;/span&gt;;
}&lt;span&gt;
 
.container &lt;/span&gt;{&lt;span&gt;
  grid-template-columns&lt;/span&gt;:&lt;span&gt; 50px 50px 50px 50px&lt;/span&gt;;&lt;span&gt;
  grid-template-rows&lt;/span&gt;:&lt;span&gt; auto&lt;/span&gt;;&lt;span&gt;
  grid-template-areas&lt;/span&gt;:&lt;span&gt; 
    &quot;header header header header&quot;
    &quot;main main . sidebar&quot;
    &quot;footer footer footer footer&quot;&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的代码将创建一个 4 列宽 3 行高的网格。整个顶行将由 header 区域组成。中间一排将由两个 main 区域，一个是空单元格，一个 sidebar 区域组成。最后一行全是 footer 区域组成。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1398770/201902/1398770-20190215183709764-1456789001.jpg&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;你的声明中的每一行都需要有相同数量的单元格。&lt;/p&gt;
&lt;p&gt;你可以使用任意数量的相邻的 点&lt;code&gt;.&lt;/code&gt; 来声明单个空单元格。 只要这些点&lt;code&gt;.&lt;/code&gt;之间没有空隙隔开，他们就代表一个单独的单元格。&lt;/p&gt;
&lt;p&gt;注意你 不能 用这个语法来命名网格线，只是命名 网格区域 。当你使用这种语法时，区域两端的网格线实际上会自动命名。如果你的网格区域的名字是 foo，该区域的起始行网格线 和 起始列网格线 的名称将为 foo-start，而最后一条行网格线 和 最后一条列网格线 的名称将为 foo-end。这意味着某些网格线可能有多个名字，如上例中最左边的网格线，它将有三个名称：header-start，main-start 和 footer-start 。&lt;/p&gt;
&lt;h4&gt;grid-template&lt;/h4&gt;
&lt;p&gt;用于定义 &lt;code&gt;grid-template-rows&lt;/code&gt; ，&lt;code&gt;grid-template-columns&lt;/code&gt; ，&lt;code&gt;grid-template-areas&lt;/code&gt; 简写属性。&lt;/p&gt;
&lt;p&gt;值：&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;none&lt;/code&gt;：将所有三个属性设置为其初始值&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;grid-template-rows&amp;gt; / &amp;lt;grid-template-columns&amp;gt;&lt;/code&gt;：将 &lt;code&gt;grid-template-columns&lt;/code&gt; 和 &lt;code&gt;grid-template-rows&lt;/code&gt; 设置为相应地特定的值，并且设置&lt;code&gt;grid-template-areas&lt;/code&gt;为&lt;code&gt;none&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.container &lt;/span&gt;{&lt;span&gt;
  grid-template&lt;/span&gt;:&lt;span&gt; none | &amp;lt;grid-template-rows&amp;gt; / &amp;lt;grid-template-columns&amp;gt;&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个属性也接受一个更复杂但非常方便的语法来指定三个上诉属性。这里有一个例子：&lt;/p&gt;
&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.container &lt;/span&gt;{&lt;span&gt;
  grid-template&lt;/span&gt;:&lt;span&gt;
    [row1-start] &quot;header header header&quot; 25px [row1-end]
    [row2-start] &quot;footer footer footer&quot; 25px [row2-end]
    / auto 50px auto&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;等价于：&lt;/p&gt;
&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.container &lt;/span&gt;{&lt;span&gt;
  grid-template-rows&lt;/span&gt;:&lt;span&gt; [row1-start] 25px [row1-end row2-start] 25px [row2-end]&lt;/span&gt;;&lt;span&gt;
  grid-template-columns&lt;/span&gt;:&lt;span&gt; auto 50px auto&lt;/span&gt;;&lt;span&gt;
  grid-template-areas&lt;/span&gt;:&lt;span&gt; 
    &quot;header header header&quot; 
    &quot;footer footer footer&quot;&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于 &lt;code&gt;grid-template&lt;/code&gt; 不会重置 &lt;em&gt;隐式&lt;/em&gt; 网格属性（&lt;code&gt;grid-auto-columns&lt;/code&gt;， &lt;code&gt;grid-auto-rows&lt;/code&gt;， 和 &lt;code&gt;grid-auto-flow&lt;/code&gt;），这可能是你想在大多数情况下做的，建议使用 &lt;code&gt;grid&lt;/code&gt; 属性而不是 &lt;code&gt;grid-template&lt;/code&gt;。&lt;/p&gt;
&lt;h4&gt;grid-column-gap / grid-row-gap&lt;/h4&gt;
&lt;p&gt;指定网格线(grid lines)的大小。你可以把它想象为设置列/行之间间距的宽度。&lt;/p&gt;
&lt;p&gt;值：&lt;/p&gt;
&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.container &lt;/span&gt;{&lt;span&gt;
  grid-column-gap&lt;/span&gt;:&lt;span&gt; &amp;lt;line-size&amp;gt;&lt;/span&gt;;&lt;span&gt;
  grid-row-gap&lt;/span&gt;:&lt;span&gt; &amp;lt;line-size&amp;gt;&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.container &lt;/span&gt;{&lt;span&gt;
  grid-template-columns&lt;/span&gt;:&lt;span&gt; 100px 50px 100px&lt;/span&gt;;&lt;span&gt;
  grid-template-rows&lt;/span&gt;:&lt;span&gt; 80px auto 80px&lt;/span&gt;;&lt;span&gt; 
  grid-column-gap&lt;/span&gt;:&lt;span&gt; 10px&lt;/span&gt;;&lt;span&gt;
  grid-row-gap&lt;/span&gt;:&lt;span&gt; 15px&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1398770/201902/1398770-20190215184149157-1947475213.jpg&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;只能在 列/行 之间创建间距，网格外部边缘不会有这个间距。&lt;/p&gt;
&lt;p&gt;注意：这两个属性将删除 &lt;code&gt;grid-&lt;/code&gt; 前缀，就是将 &lt;code&gt;grid-column-gap&lt;/code&gt; 和 &lt;code&gt;grid-row-gap&lt;/code&gt;重命名为 &lt;code&gt;column-gap&lt;/code&gt;和 &lt;code&gt;row-gap&lt;/code&gt;。 Chrome 68+，Safari 11.2 Release 50+ 和Opera 54+ 已经支持无前缀的属性。&lt;/p&gt;
&lt;h4&gt;grid-gap&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;grid-column-gap&lt;/code&gt; 和 &lt;code&gt;grid-row-gap&lt;/code&gt; 的简写语法&lt;/p&gt;
&lt;p&gt;值：&lt;/p&gt;
&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.container &lt;/span&gt;{&lt;span&gt;
  grid-gap&lt;/span&gt;:&lt;span&gt; &amp;lt;grid-row-gap&amp;gt; &amp;lt;grid-column-gap&amp;gt;&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.container &lt;/span&gt;{&lt;span&gt;
  grid-template-columns&lt;/span&gt;:&lt;span&gt; 100px 50px 100px&lt;/span&gt;;&lt;span&gt;
  grid-template-rows&lt;/span&gt;:&lt;span&gt; 80px auto 80px&lt;/span&gt;;&lt;span&gt; 
  grid-gap&lt;/span&gt;:&lt;span&gt; 15px 10px&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果&lt;code&gt;grid-row-gap&lt;/code&gt;没有定义，那么就会被设置为等同于 &lt;code&gt;grid-column-gap&lt;/code&gt; 的值。例如下面的代码是等价的：&lt;/p&gt;
&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.container&lt;/span&gt;{
  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 设置 grid-column-gap 和 grid-row-gap &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;  
  grid-column-gap&lt;/span&gt;:&lt;span&gt; 10px&lt;/span&gt;;&lt;span&gt;
  grid-row-gap&lt;/span&gt;:&lt;span&gt; 10px&lt;/span&gt;; 
 
  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 等价于 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;  
  grid-gap&lt;/span&gt;:&lt;span&gt; 10px 10px&lt;/span&gt;;
 
  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 等价于 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;  
  grid-gap&lt;/span&gt;:&lt;span&gt; 10px&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意：这个属性将删除 &lt;code&gt;grid-&lt;/code&gt; 前缀，就是将 &lt;code&gt;grid-gap&lt;/code&gt; 重命名为 &lt;code&gt;gap&lt;/code&gt;。 Chrome 68+，Safari 11.2 Release 50+ 和Opera 54+ 已经支持无前缀的属性。&lt;/p&gt;
&lt;h3&gt;justify-items&lt;/h3&gt;
&lt;p&gt;沿着 &lt;em&gt;inline&lt;/em&gt;（行）轴线对齐网格项(grid items)（相反的属性是 &lt;code&gt;align-items&lt;/code&gt; 沿着 &lt;em&gt;block&lt;/em&gt;（列）轴线对齐）。此值适用于容器内的所有网格项。&lt;/p&gt;
&lt;p&gt;值：&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;start&lt;/code&gt;：将网格项对齐到其单元格的左侧起始边缘（左侧对齐）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;end&lt;/code&gt;：将网格项对齐到其单元格的右侧结束边缘（右侧对齐）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;center&lt;/code&gt;：将网格项对齐到其单元格的水平中间位置（水平居中对齐）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;stretch&lt;/code&gt;：填满单元格的宽度（默认值）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.container &lt;/span&gt;{&lt;span&gt;
  justify-items&lt;/span&gt;:&lt;span&gt; start | end | center | stretch&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.container &lt;/span&gt;{&lt;span&gt;
  justify-items&lt;/span&gt;:&lt;span&gt; start&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1398770/201902/1398770-20190215184341613-1133607212.jpg&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.container&lt;/span&gt;{&lt;span&gt;
  justify-items&lt;/span&gt;:&lt;span&gt; end&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1398770/201902/1398770-20190215184520002-1263451569.jpg&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.container&lt;/span&gt;{&lt;span&gt;
  justify-items&lt;/span&gt;:&lt;span&gt; center&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1398770/201902/1398770-20190215184619126-998306979.jpg&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.container&lt;/span&gt;{&lt;span&gt;
  justify-items&lt;/span&gt;:&lt;span&gt; stretch&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1398770/201902/1398770-20190215191804590-1206810091.jpg&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这些行为也可以通过每个单独网格项(grid items) 的 &lt;code&gt;justify-self&lt;/code&gt; 属性设置。&lt;/p&gt;
&lt;h4&gt;align-items&lt;/h4&gt;
&lt;p&gt;沿着 &lt;em&gt;block&lt;/em&gt;（列）轴线对齐网格项(grid items)（相反的属性是 &lt;code&gt;justify-items&lt;/code&gt; 沿着 &lt;em&gt;inline&lt;/em&gt;（行）轴线对齐）。此值适用于容器内的所有网格项。&lt;/p&gt;
&lt;p&gt;值：&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;start&lt;/code&gt;：将网格项对齐到其单元格的顶部起始边缘（顶部对齐）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;end&lt;/code&gt;：将网格项对齐到其单元格的底部结束边缘（底部对齐）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;center&lt;/code&gt;：将网格项对齐到其单元格的垂直中间位置（垂直居中对齐）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;stretch&lt;/code&gt;：填满单元格的高度（默认值）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.container &lt;/span&gt;{&lt;span&gt;
  align-items&lt;/span&gt;:&lt;span&gt; start | end | center | stretch&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.container &lt;/span&gt;{&lt;span&gt;
  align-items&lt;/span&gt;:&lt;span&gt; start&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1398770/201902/1398770-20190215192558028-1648074690.jpg&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.container &lt;/span&gt;{&lt;span&gt;
  align-items&lt;/span&gt;:&lt;span&gt; end&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1398770/201902/1398770-20190215192635799-1552458625.jpg&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.container &lt;/span&gt;{&lt;span&gt;
  align-items&lt;/span&gt;:&lt;span&gt; center&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1398770/201902/1398770-20190215192718341-1208774488.jpg&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.container &lt;/span&gt;{&lt;span&gt;
  align-items&lt;/span&gt;:&lt;span&gt; stretch&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1398770/201902/1398770-20190215192754148-1315820777.jpg&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这些行为也可以通过每个单独网格项(grid items) 的 &lt;code&gt;align-self&lt;/code&gt; 属性设置。&lt;/p&gt;
&lt;h4&gt;place-items&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;place-items&lt;/code&gt; 是设置 &lt;code&gt;align-items&lt;/code&gt; 和 &lt;code&gt;justify-items&lt;/code&gt; 的简写形式。&lt;/p&gt;
&lt;p&gt;值：&lt;/p&gt;
&lt;p&gt;除 Edge 之外的所有主要浏览器都支持 &lt;code&gt;place-items&lt;/code&gt; 简写属性。&lt;/p&gt;
&lt;p&gt;有关更多详细信息，请参阅&lt;code&gt;align-items&lt;/code&gt; 和 &lt;code&gt;justify-items&lt;/code&gt;。&lt;/p&gt;
&lt;h4&gt;justify-content&lt;/h4&gt;
&lt;p&gt;有时，你的网格合计大小可能小于其 网格容器(grid container) 大小。 如果你的所有 网格项(grid items) 都使用像 &lt;code&gt;px&lt;/code&gt; 这样的非灵活单位设置大小，就可能出现这种情况。&lt;/p&gt;
&lt;p&gt;在这种情况下，您可以设置网格容器内的网格的对齐方式。 此属性沿着 &lt;em&gt;inline&lt;/em&gt;（行）轴线对齐网格（相反的属性是 &lt;code&gt;align-content&lt;/code&gt; ，沿着 &lt;em&gt;block&lt;/em&gt;（列）轴线对齐网格）。&lt;/p&gt;
&lt;p&gt;值：&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;5.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;start&lt;/code&gt;：将网格对齐到 网格容器(grid container) 的左侧起始边缘（左侧对齐）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;end&lt;/code&gt;：将网格对齐到 网格容器 的右侧结束边缘（右侧对齐）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;center&lt;/code&gt;：将网格对齐到 网格容器 的水平中间位置（水平居中对齐）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;stretch&lt;/code&gt;：调整 网格项(grid items) 的宽度，允许该网格填充满整个 网格容器 的宽度&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;space-around&lt;/code&gt;：在每个网格项之间放置一个均匀的空间，左右两端放置一半的空间&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;space-between&lt;/code&gt;：在每个网格项之间放置一个均匀的空间，左右两端没有空间&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;space-evenly&lt;/code&gt;：在每个网格项目之间放置一个均匀的空间，左右两端放置一个均匀的空间&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.container &lt;/span&gt;{&lt;span&gt;
  justify-content&lt;/span&gt;:&lt;span&gt; start | end | center | stretch | space-around | space-between | space-evenly&lt;/span&gt;;    
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.container &lt;/span&gt;{&lt;span&gt;
  justify-content&lt;/span&gt;:&lt;span&gt; start&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1398770/201902/1398770-20190215193018599-894140702.jpg&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.container &lt;/span&gt;{&lt;span&gt;
  justify-content&lt;/span&gt;:&lt;span&gt; end&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1398770/201902/1398770-20190215193054179-106197133.jpg&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.container &lt;/span&gt;{&lt;span&gt;
  justify-content&lt;/span&gt;:&lt;span&gt; center&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1398770/201902/1398770-20190215193133104-1566552152.jpg&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.container &lt;/span&gt;{&lt;span&gt;
  justify-content&lt;/span&gt;:&lt;span&gt; stretch&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1398770/201902/1398770-20190215193209727-466748864.jpg&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.container &lt;/span&gt;{&lt;span&gt;
  justify-content&lt;/span&gt;:&lt;span&gt; space-around&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1398770/201902/1398770-20190215193242792-1649446477.jpg&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.container &lt;/span&gt;{&lt;span&gt;
  justify-content&lt;/span&gt;:&lt;span&gt; space-between&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1398770/201902/1398770-20190215193332775-1818461281.jpg&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.container &lt;/span&gt;{&lt;span&gt;
  justify-content&lt;/span&gt;:&lt;span&gt; space-evenly&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1398770/201902/1398770-20190215193414669-1838790535.jpg&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;align-content&lt;/h3&gt;
&lt;p&gt;有时，你的网格合计大小可能小于其 网格容器(grid container) 大小。 如果你的所有 网格项(grid items) 都使用像 &lt;code&gt;px&lt;/code&gt; 这样的非灵活单位设置大小，就可能出现这种情况。&lt;/p&gt;
&lt;p&gt;在这种情况下，您可以设置网格容器内的网格的对齐方式。 此属性沿着 &lt;em&gt;block&lt;/em&gt;（列）轴线对齐网格（相反的属性是 &lt;code&gt;justify-content&lt;/code&gt; ，沿着 &lt;em&gt;inline&lt;/em&gt;（行）轴线对齐网格）。&lt;/p&gt;
&lt;p&gt;值：&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;5.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;start&lt;/code&gt;：将网格对齐到 网格容器(grid container) 的顶部起始边缘（顶部对齐）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;end&lt;/code&gt;：将网格对齐到 网格容器 的底部结束边缘（底部对齐）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;center&lt;/code&gt;：将网格对齐到 网格容器 的垂直中间位置（垂直居中对齐）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;stretch&lt;/code&gt;：调整 网格项(grid items) 的高度，允许该网格填充满整个 网格容器 的高度&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;space-around&lt;/code&gt;：在每个网格项之间放置一个均匀的空间，上下两端放置一半的空间&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;space-between&lt;/code&gt;：在每个网格项之间放置一个均匀的空间，上下两端没有空间&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;space-evenly&lt;/code&gt;：在每个网格项目之间放置一个均匀的空间，上下两端放置一个均匀的空间&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.container &lt;/span&gt;{&lt;span&gt;
  align-content&lt;/span&gt;:&lt;span&gt; start | end | center | stretch | space-around | space-between | space-evenly&lt;/span&gt;;  
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.container &lt;/span&gt;{&lt;span&gt;
  align-content&lt;/span&gt;:&lt;span&gt; start&lt;/span&gt;; 
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1398770/201902/1398770-20190215193701161-1888817261.jpg&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.container &lt;/span&gt;{&lt;span&gt;
  align-content&lt;/span&gt;:&lt;span&gt; end&lt;/span&gt;;   
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1398770/201902/1398770-20190215193729292-515268719.jpg&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.container &lt;/span&gt;{&lt;span&gt;
  align-content&lt;/span&gt;:&lt;span&gt; center&lt;/span&gt;;    
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1398770/201902/1398770-20190215193807131-1346015309.jpg&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.container &lt;/span&gt;{&lt;span&gt;
  align-content&lt;/span&gt;:&lt;span&gt; stretch&lt;/span&gt;;   
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1398770/201902/1398770-20190215193944202-835999536.jpg&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.container &lt;/span&gt;{&lt;span&gt;
  align-content&lt;/span&gt;:&lt;span&gt; space-around&lt;/span&gt;;  
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1398770/201902/1398770-20190215194019334-833738132.jpg&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.container &lt;/span&gt;{&lt;span&gt;
  align-content&lt;/span&gt;:&lt;span&gt; space-between&lt;/span&gt;; 
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1398770/201902/1398770-20190215194108477-554950560.jpg&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.container &lt;/span&gt;{&lt;span&gt;
  align-content&lt;/span&gt;:&lt;span&gt; space-evenly&lt;/span&gt;;  
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1398770/201902/1398770-20190215194210555-481300308.jpg&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;place-content&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;place-content&lt;/code&gt; 是设置 &lt;code&gt;align-content&lt;/code&gt; 和 &lt;code&gt;justify-content&lt;/code&gt; 的简写形式。&lt;/p&gt;
&lt;p&gt;值：&lt;/p&gt;
&lt;p&gt;除 Edge 之外的所有主要浏览器都支持 &lt;code&gt;place-content&lt;/code&gt; 简写属性。&lt;/p&gt;
&lt;p&gt;有关更多详细信息，请参阅&lt;code&gt;align-content&lt;/code&gt; 和 &lt;code&gt;justify-content&lt;/code&gt;。&lt;/p&gt;
&lt;h4&gt;grid-auto-columns / grid-auto-rows&lt;/h4&gt;
&lt;p&gt;指定任何自动生成的网格轨道(grid tracks)（又名隐式网格轨道）的大小。当网格中的网格项多于单元格时，或者当网格项位于显式网格之外时，就会创建隐式轨道。（参见显式网格和隐式网格之间的区别）&lt;/p&gt;
&lt;p&gt;值：&lt;/p&gt;
&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.container &lt;/span&gt;{&lt;span&gt;
  grid-auto-columns&lt;/span&gt;:&lt;span&gt; &amp;lt;track-size&amp;gt; ...&lt;/span&gt;;&lt;span&gt;
  grid-auto-rows&lt;/span&gt;:&lt;span&gt; &amp;lt;track-size&amp;gt; ...&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为了说明如何创建隐式网格轨道，请考虑一下以下的代码：&lt;/p&gt;
&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.container &lt;/span&gt;{&lt;span&gt;
  grid-template-columns&lt;/span&gt;:&lt;span&gt; 60px 60px&lt;/span&gt;;&lt;span&gt;
  grid-template-rows&lt;/span&gt;:&lt;span&gt; 90px 90px
&lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1398770/201902/1398770-20190215194317705-394462395.jpg&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这将生成了一个 2×2 的网格。&lt;/p&gt;
&lt;p&gt;但现在想象一下，你使用 &lt;code&gt;grid-column&lt;/code&gt; 和 &lt;code&gt;grid-row&lt;/code&gt; 来定位你的网格项，像这样：&lt;/p&gt;
&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.item-a &lt;/span&gt;{&lt;span&gt;
  grid-column&lt;/span&gt;:&lt;span&gt; 1 / 2&lt;/span&gt;;&lt;span&gt;
  grid-row&lt;/span&gt;:&lt;span&gt; 2 / 3&lt;/span&gt;;
}&lt;span&gt;
.item-b &lt;/span&gt;{&lt;span&gt;
  grid-column&lt;/span&gt;:&lt;span&gt; 5 / 6&lt;/span&gt;;&lt;span&gt;
  grid-row&lt;/span&gt;:&lt;span&gt; 2 / 3&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1398770/201902/1398770-20190215194410998-1620062699.jpg&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们告诉 &lt;code&gt;.item-b&lt;/code&gt; 从第 5 条列网格线开始到第 6 条列网格线结束，&lt;em&gt;但我们从来没有定义过 第5 或 第6 列网格线&lt;/em&gt;。&lt;br/&gt;因为我们引用的网格线不存在，所以创建宽度为 0 的隐式网格轨道以填补空缺。我们可以使用 &lt;code&gt;grid-auto-columns&lt;/code&gt; 和 &lt;code&gt;grid-auto-rows&lt;/code&gt; 来指定这些隐式轨道的大小：&lt;/p&gt;
&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.container &lt;/span&gt;{&lt;span&gt;
  grid-auto-columns&lt;/span&gt;:&lt;span&gt; 60px&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1398770/201902/1398770-20190215194504963-71508683.jpg&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;grid-auto-flow&lt;/h4&gt;
&lt;p&gt;如果你有一些没有明确放置在网格上的网格项(grid items)，自动放置算法 会自动放置这些网格项。该属性控制自动布局算法如何工作。&lt;/p&gt;
&lt;p&gt;值：&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;row&lt;/code&gt;：告诉自动布局算法依次填充每行，根据需要添加新行 （默认）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;column&lt;/code&gt;：告诉自动布局算法依次填入每列，根据需要添加新列&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;dense&lt;/code&gt;：告诉自动布局算法在稍后出现较小的网格项时，尝试填充网格中较早的空缺&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.container &lt;/span&gt;{&lt;span&gt;
  grid-auto-flow&lt;/span&gt;:&lt;span&gt; row | column | row dense | column dense
&lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;请注意，&lt;code&gt;dense&lt;/code&gt; 只会更改网格项的可视顺序，并可能导致它们出现乱序，这对可访问性不利。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;考虑以下 HTML :&lt;/p&gt;
&lt;p&gt;HTML 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;section &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;container&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;item-a&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;item-a&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;item-b&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;item-b&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;item-c&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;item-c&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;item-d&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;item-d&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;item-e&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;item-e&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;section&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;你定义一个有 5 列和 2 行的网格，并将 &lt;code&gt;grid-auto-flow&lt;/code&gt; 设置为 &lt;code&gt;row&lt;/code&gt;（也就是默认值）：&lt;/p&gt;
&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.container &lt;/span&gt;{&lt;span&gt;
  display&lt;/span&gt;:&lt;span&gt; grid&lt;/span&gt;;&lt;span&gt;
  grid-template-columns&lt;/span&gt;:&lt;span&gt; 60px 60px 60px 60px 60px&lt;/span&gt;;&lt;span&gt;
  grid-template-rows&lt;/span&gt;:&lt;span&gt; 30px 30px&lt;/span&gt;;&lt;span&gt;
  grid-auto-flow&lt;/span&gt;:&lt;span&gt; row&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将网格项放在网格上时，只能为其中的两个指定位置：&lt;/p&gt;
&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.item-a &lt;/span&gt;{&lt;span&gt;
  grid-column&lt;/span&gt;:&lt;span&gt; 1&lt;/span&gt;;&lt;span&gt;
  grid-row&lt;/span&gt;:&lt;span&gt; 1 / 3&lt;/span&gt;;
}&lt;span&gt;
.item-e &lt;/span&gt;{&lt;span&gt;
  grid-column&lt;/span&gt;:&lt;span&gt; 5&lt;/span&gt;;&lt;span&gt;
  grid-row&lt;/span&gt;:&lt;span&gt; 1 / 3&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为我们把 &lt;code&gt;grid-auto-flow&lt;/code&gt; 设成了 &lt;code&gt;row&lt;/code&gt; ，所以我们的网格看起来会是这样。注意 我们没有进行定位的网格项（&lt;code&gt;item-b&lt;/code&gt;，&lt;code&gt;item-c&lt;/code&gt;，&lt;code&gt;item-d&lt;/code&gt;）会这样排列在可用的行中：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1398770/201902/1398770-20190215194705206-2097711591.jpg&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;相反地，如果我们把 &lt;code&gt;grid-auto-flow&lt;/code&gt; 设成了 &lt;code&gt;column&lt;/code&gt; ，那么 &lt;code&gt;item-b&lt;/code&gt;，&lt;code&gt;item-c&lt;/code&gt;，&lt;code&gt;item-d&lt;/code&gt; 会沿着列向下排列：&lt;/p&gt;
&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.container &lt;/span&gt;{&lt;span&gt;
  display&lt;/span&gt;:&lt;span&gt; grid&lt;/span&gt;;&lt;span&gt;
  grid-template-columns&lt;/span&gt;:&lt;span&gt; 60px 60px 60px 60px 60px&lt;/span&gt;;&lt;span&gt;
  grid-template-rows&lt;/span&gt;:&lt;span&gt; 30px 30px&lt;/span&gt;;&lt;span&gt;
  grid-auto-flow&lt;/span&gt;:&lt;span&gt; column&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1398770/201902/1398770-20190215194735588-1030838488.jpg&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;grid&lt;/h2&gt;
&lt;p&gt;在一个声明中设置所有以下属性的简写： &lt;code&gt;grid-template-rows&lt;/code&gt;, &lt;code&gt;grid-template-columns&lt;/code&gt;, &lt;code&gt;grid-template-areas&lt;/code&gt;, &lt;code&gt;grid-auto-rows&lt;/code&gt;, &lt;code&gt;grid-auto-columns&lt;/code&gt;, 和 &lt;code&gt;grid-auto-flow&lt;/code&gt; 。（注意：您只能在单个网格声明中指定显式或隐式网格属性）。&lt;/p&gt;
&lt;p&gt;值：&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;4&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;none&lt;/code&gt;：将所有子属性设置为其初始值。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;grid-template&amp;gt;&lt;/code&gt;：与&lt;code&gt;grid-template&lt;/code&gt; 简写的工作方式相同。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;grid-template-rows&amp;gt; / [ auto-flow &amp;amp;&amp;amp; dense? ] &amp;lt;grid-auto-columns&amp;gt;? &lt;/code&gt;：将&lt;code&gt;grid-template-rows&lt;/code&gt;设置为指定的值。 如果 &lt;code&gt;auto-flow&lt;/code&gt; 关键字位于斜杠的右侧，则会将 &lt;code&gt;grid-auto-flow&lt;/code&gt; 设置为 &lt;code&gt;column&lt;/code&gt;。 如果另外指定了 &lt;code&gt;dense&lt;/code&gt; 关键字，则自动放置算法使用 “dense” 算法。 如果省略 &lt;code&gt;grid-auto-columns&lt;/code&gt;，则将其设置为 &lt;code&gt;auto&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;code&gt;[ auto-flow &amp;amp;&amp;amp; dense? ] &amp;lt;grid-auto-rows&amp;gt;? / &amp;lt;grid-template-columns&amp;gt;&lt;/code&gt;：将 &lt;code&gt;grid-template-columns&lt;/code&gt; 设置为指定值。 如果 &lt;code&gt;auto-flow&lt;/code&gt; 关键字位于斜杠的左侧，则会将&lt;code&gt;grid-auto-flow&lt;/code&gt; 设置为 &lt;code&gt;row&lt;/code&gt; 。 如果另外指定了 &lt;code&gt;dense&lt;/code&gt; 关键字，则自动放置算法使用 “dense” 打包算法。 如果省略 &lt;code&gt;grid-auto-rows&lt;/code&gt; ，则将其设置为 &lt;code&gt;auto&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;例子：&lt;/p&gt;
&lt;p&gt;以下两个代码块是等效的：&lt;/p&gt;
&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.container &lt;/span&gt;{&lt;span&gt;
  grid&lt;/span&gt;:&lt;span&gt; 100px 300px / 3fr 1fr&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.container &lt;/span&gt;{&lt;span&gt;
  grid-template-rows&lt;/span&gt;:&lt;span&gt; 100px 300px&lt;/span&gt;;&lt;span&gt;
  grid-template-columns&lt;/span&gt;:&lt;span&gt; 3fr 1fr&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以下两个代码块是等效的：&lt;/p&gt;
&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.container &lt;/span&gt;{&lt;span&gt;
  grid&lt;/span&gt;:&lt;span&gt; auto-flow / 200px 1fr&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.container &lt;/span&gt;{&lt;span&gt;
  grid-auto-flow&lt;/span&gt;:&lt;span&gt; row&lt;/span&gt;;&lt;span&gt;
  grid-template-columns&lt;/span&gt;:&lt;span&gt; 200px 1fr&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以下两个代码块是等效的：&lt;/p&gt;
&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.container &lt;/span&gt;{&lt;span&gt;
  grid&lt;/span&gt;:&lt;span&gt; auto-flow dense 100px / 1fr 2fr&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.container &lt;/span&gt;{&lt;span&gt;
  grid-auto-flow&lt;/span&gt;:&lt;span&gt; row dense&lt;/span&gt;;&lt;span&gt;
  grid-auto-rows&lt;/span&gt;:&lt;span&gt; 100px&lt;/span&gt;;&lt;span&gt;
  grid-template-columns&lt;/span&gt;:&lt;span&gt; 1fr 2fr&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以下两个代码块是等效的：&lt;/p&gt;
&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.container &lt;/span&gt;{&lt;span&gt;
  grid&lt;/span&gt;:&lt;span&gt; 100px 300px / auto-flow 200px&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.container &lt;/span&gt;{&lt;span&gt;
  grid-template-rows&lt;/span&gt;:&lt;span&gt; 100px 300px&lt;/span&gt;;&lt;span&gt;
  grid-auto-flow&lt;/span&gt;:&lt;span&gt; column&lt;/span&gt;;&lt;span&gt;
  grid-auto-columns&lt;/span&gt;:&lt;span&gt; 200px&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它也接受一个更复杂但相当方便的语法来一次设置所有内容。您可以指定 &lt;code&gt;grid-template-areas&lt;/code&gt;，&lt;code&gt;grid-template-rows&lt;/code&gt;和&lt;code&gt;grid-template-columns&lt;/code&gt;，并所有其他的子属性都被设置为它们的初始值。这么做可以在它们网格区域内相应地指定网格线名字和网格轨道的大小。用最简单的例子来描述：&lt;/p&gt;
&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.container &lt;/span&gt;{&lt;span&gt;
  grid&lt;/span&gt;:&lt;span&gt; [row1-start] &quot;header header header&quot; 1fr [row1-end]
        [row2-start] &quot;footer footer footer&quot; 25px [row2-end]
        / auto 50px auto&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;等价于：&lt;/p&gt;
&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.container &lt;/span&gt;{&lt;span&gt;
  grid-template-areas&lt;/span&gt;:&lt;span&gt; 
    &quot;header header header&quot;
    &quot;footer footer footer&quot;&lt;/span&gt;;&lt;span&gt;
  grid-template-rows&lt;/span&gt;:&lt;span&gt; [row1-start] 1fr [row1-end row2-start] 25px [row2-end]&lt;/span&gt;;&lt;span&gt;
  grid-template-columns&lt;/span&gt;:&lt;span&gt; auto 50px auto&lt;/span&gt;;    
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;子元素 网格项(Grid Items) 属性&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：&lt;code&gt;float&lt;/code&gt;，&lt;code&gt;display: inline-block&lt;/code&gt;，&lt;code&gt;display: table-cell&lt;/code&gt;，&lt;code&gt;vertical-align&lt;/code&gt; 和 &lt;code&gt;column-*&lt;/code&gt; 属性对网格项无效。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;grid-column-start / grid-column-end / grid-row-start / grid-row-end&lt;/h3&gt;
&lt;p&gt;通过引用特定网格线(grid lines) 来确定 网格项(grid item) 在网格内的位置。 &lt;code&gt;grid-column-start&lt;/code&gt; / &lt;code&gt;grid-row-start&lt;/code&gt; 是网格项开始的网格线，&lt;code&gt;grid-column-end&lt;/code&gt; / &lt;code&gt;grid-row-end&lt;/code&gt; 是网格项结束的网格线。&lt;/p&gt;
&lt;p&gt;值：&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;line&amp;gt;&lt;/code&gt; ：可以是一个数字引用一个编号的网格线，或者一个名字来引用一个命名的网格线&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;span &amp;lt;number&amp;gt;&lt;/code&gt; ：该网格项将跨越所提供的网格轨道数量&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;span &amp;lt;name&amp;gt;&lt;/code&gt; ：该网格项将跨越到它与提供的名称位置&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;auto&lt;/code&gt;：表示自动放置，自动跨度，默认会扩展一个网格轨道的宽度或者高度&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.item &lt;/span&gt;{&lt;span&gt;
  grid-column-start&lt;/span&gt;:&lt;span&gt; &amp;lt;number&amp;gt; | &amp;lt;name&amp;gt; | span &amp;lt;number&amp;gt; | span &amp;lt;name&amp;gt; | auto
  grid-column-end: &amp;lt;number&amp;gt; | &amp;lt;name&amp;gt; | span &amp;lt;number&amp;gt; | span &amp;lt;name&amp;gt; | auto
  grid-row-start: &amp;lt;number&amp;gt; | &amp;lt;name&amp;gt; | span &amp;lt;number&amp;gt; | span &amp;lt;name&amp;gt; | auto
  grid-row-end: &amp;lt;number&amp;gt; | &amp;lt;name&amp;gt; | span &amp;lt;number&amp;gt; | span &amp;lt;name&amp;gt; | auto
&lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.item-a &lt;/span&gt;{&lt;span&gt;
  grid-column-start&lt;/span&gt;:&lt;span&gt; 2&lt;/span&gt;;&lt;span&gt;
  grid-column-end&lt;/span&gt;:&lt;span&gt; five&lt;/span&gt;;&lt;span&gt;
  grid-row-start&lt;/span&gt;:&lt;span&gt; row1-start
  grid-row-end: 3&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1398770/201902/1398770-20190215195115797-1525505496.jpg&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.item-b &lt;/span&gt;{&lt;span&gt;
  grid-column-start&lt;/span&gt;:&lt;span&gt; 1&lt;/span&gt;;&lt;span&gt;
  grid-column-end&lt;/span&gt;:&lt;span&gt; span col4-start&lt;/span&gt;;&lt;span&gt;
  grid-row-start&lt;/span&gt;:&lt;span&gt; 2
  grid-row-end: span 2
&lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1398770/201902/1398770-20190215195146438-1389605720.jpg&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果没有声明指定 &lt;code&gt;grid-column-end&lt;/code&gt; / &lt;code&gt;grid-row-end&lt;/code&gt;，默认情况下，该网格项将占据 1 个轨道。&lt;/p&gt;
&lt;p&gt;项目可以相互重叠。您可以使用 &lt;code&gt;z-index&lt;/code&gt; 来控制它们的重叠顺序。&lt;/p&gt;
&lt;h3&gt;grid-column / grid-row&lt;/h3&gt;
&lt;p&gt;分别为 &lt;code&gt;grid-column-start&lt;/code&gt; + &lt;code&gt;grid-column-end&lt;/code&gt; 和 &lt;code&gt;grid-row-start&lt;/code&gt; + &lt;code&gt;grid-row-end&lt;/code&gt; 的简写形式。&lt;/p&gt;
&lt;p&gt;值：&lt;/p&gt;
&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.item &lt;/span&gt;{&lt;span&gt;
  grid-column&lt;/span&gt;:&lt;span&gt; &amp;lt;start-line&amp;gt; / &amp;lt;end-line&amp;gt; | &amp;lt;start-line&amp;gt; / span &amp;lt;value&amp;gt;&lt;/span&gt;;&lt;span&gt;
  grid-row&lt;/span&gt;:&lt;span&gt; &amp;lt;start-line&amp;gt; / &amp;lt;end-line&amp;gt; | &amp;lt;start-line&amp;gt; / span &amp;lt;value&amp;gt;&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.item-c &lt;/span&gt;{&lt;span&gt;
  grid-column&lt;/span&gt;:&lt;span&gt; 3 / span 2&lt;/span&gt;;&lt;span&gt;
  grid-row&lt;/span&gt;:&lt;span&gt; third-line / 4&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1398770/201902/1398770-20190215195235222-1655156354.jpg&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果没有声明分隔线结束位置，则该网格项默认占据 1 个网格轨道。&lt;/p&gt;
&lt;h3&gt;grid-area&lt;/h3&gt;
&lt;p&gt;为网格项提供一个名称，以便可以 被使用网格容器 &lt;code&gt;grid-template-areas&lt;/code&gt; 属性创建的模板进行引用。 另外，这个属性可以用作&lt;code&gt;grid-row-start&lt;/code&gt; + &lt;code&gt;grid-column-start&lt;/code&gt; + &lt;code&gt;grid-row-end&lt;/code&gt; + &lt;code&gt;grid-column-end&lt;/code&gt; 的简写。&lt;/p&gt;
&lt;p&gt;值：&lt;/p&gt;
&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.item &lt;/span&gt;{&lt;span&gt;
  grid-area&lt;/span&gt;:&lt;span&gt; &amp;lt;name&amp;gt; | &amp;lt;row-start&amp;gt; / &amp;lt;column-start&amp;gt; / &amp;lt;row-end&amp;gt; / &amp;lt;column-end&amp;gt;&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;作为为网格项分配名称的一种方法：&lt;/p&gt;
&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.item-d &lt;/span&gt;{&lt;span&gt;
  grid-area&lt;/span&gt;:&lt;span&gt; header
&lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;作为&lt;code&gt;grid-row-start&lt;/code&gt; + &lt;code&gt;grid-column-start&lt;/code&gt; + &lt;code&gt;grid-row-end&lt;/code&gt; + &lt;code&gt;grid-column-end&lt;/code&gt; 属性的简写形式&lt;/p&gt;
&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.item-d &lt;/span&gt;{&lt;span&gt;
    grid-area&lt;/span&gt;:&lt;span&gt; 1 / col4-start / last-line / 6
&lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1398770/201902/1398770-20190215195344363-327865884.jpg&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;justify-self&lt;/h3&gt;
&lt;p&gt;沿着 &lt;em&gt;inline&lt;/em&gt;（行）轴线对齐网格项（ 相反的属性是 &lt;code&gt;align-self&lt;/code&gt; ，沿着 &lt;em&gt;block&lt;/em&gt;（列）轴线对齐）。此值适用于单个网格项内的内容。&lt;/p&gt;
&lt;p&gt;值：&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;start&lt;/code&gt;：将网格项对齐到其单元格的左侧起始边缘（左侧对齐）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;end&lt;/code&gt;：将网格项对齐到其单元格的右侧结束边缘（右侧对齐）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;center&lt;/code&gt;：将网格项对齐到其单元格的水平中间位置（水平居中对齐）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;stretch&lt;/code&gt;：填满单元格的宽度（默认值）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.item &lt;/span&gt;{&lt;span&gt;
  justify-self&lt;/span&gt;:&lt;span&gt; start | end | center | stretch&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.item-a &lt;/span&gt;{&lt;span&gt;
  justify-self&lt;/span&gt;:&lt;span&gt; start&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1398770/201902/1398770-20190215195432089-518644411.jpg&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.item-a &lt;/span&gt;{&lt;span&gt;
  justify-self&lt;/span&gt;:&lt;span&gt; end&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1398770/201902/1398770-20190215195502852-450443443.jpg&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.item-a &lt;/span&gt;{&lt;span&gt;
  justify-self&lt;/span&gt;:&lt;span&gt; center&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1398770/201902/1398770-20190215195536983-1675749566.jpg&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.item-a &lt;/span&gt;{&lt;span&gt;
  justify-self&lt;/span&gt;:&lt;span&gt; stretch&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1398770/201902/1398770-20190215195622483-1234518279.jpg&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;要为网格中的所有网格项设置 行轴线(row axis) 线上对齐方式，也可以在 网格容器 上设置 &lt;code&gt;justify-items&lt;/code&gt;属性。&lt;/p&gt;
&lt;h3&gt;align-self&lt;/h3&gt;
&lt;p&gt;沿着 &lt;em&gt;block&lt;/em&gt;（列）轴线对齐网格项(grid items)（ 相反的属性是 &lt;code&gt;justify-self&lt;/code&gt; ，沿着 &lt;em&gt;inline&lt;/em&gt;（行）轴线对齐）。此值适用于单个网格项内的内容。&lt;/p&gt;
&lt;p&gt;值：&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;start&lt;/code&gt;：将网格项对齐到其单元格的顶部起始边缘（顶部对齐）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;end&lt;/code&gt;：将网格项对齐到其单元格的底部结束边缘（底部对齐）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;center&lt;/code&gt;：将网格项对齐到其单元格的垂直中间位置（垂直居中对齐）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;stretch&lt;/code&gt;：填满单元格的高度（默认值）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.item&lt;/span&gt;{&lt;span&gt;
  align-self&lt;/span&gt;:&lt;span&gt; start | end | center | stretch&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.item-a &lt;/span&gt;{&lt;span&gt;
    align-self&lt;/span&gt;:&lt;span&gt; start&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1398770/201902/1398770-20190215195713721-321133935.jpg&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.item-a &lt;/span&gt;{&lt;span&gt;
  align-self&lt;/span&gt;:&lt;span&gt; end&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1398770/201902/1398770-20190215195744299-1575292842.jpg&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.item-a &lt;/span&gt;{&lt;span&gt;
    align-self&lt;/span&gt;:&lt;span&gt; center&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1398770/201902/1398770-20190215200050123-626302316.jpg&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.item-a &lt;/span&gt;{&lt;span&gt;
    align-self&lt;/span&gt;:&lt;span&gt; stretch&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1398770/201902/1398770-20190215200017864-1415490923.jpg&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;要为网格中的所有网格项设置 列轴线(column axis) 上的对齐方式，也可以在 网格容器 上设置 &lt;code&gt;align-items&lt;/code&gt;属性。&lt;/p&gt;
&lt;h3&gt;place-self&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;place-self&lt;/code&gt; 是设置 &lt;code&gt;align-self&lt;/code&gt; 和 &lt;code&gt;justify-self&lt;/code&gt; 的简写形式。&lt;/p&gt;
&lt;p&gt;值：&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;auto&lt;/code&gt; – 布局模式的 “默认” 对齐方式。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;align-self&amp;gt; &amp;lt;justify-self&amp;gt;&lt;/code&gt;：第一个值设置 &lt;code&gt;align-self&lt;/code&gt; 属性，第二个值设置 &lt;code&gt;justify-self&lt;/code&gt; 属性。如果省略第二个值，则将第一个值同时分配给这两个属性。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.item-a &lt;/span&gt;{&lt;span&gt;
  place-self&lt;/span&gt;:&lt;span&gt; center&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1398770/201902/1398770-20190215200222895-370676152.jpg&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;CSS 代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.item-a &lt;/span&gt;{&lt;span&gt;
  place-self&lt;/span&gt;:&lt;span&gt; center stretch&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1398770/201902/1398770-20190215200250789-1857276423.jpg&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;除 Edge 之外的所有主要浏览器都支持 &lt;code&gt;place-self&lt;/code&gt; 简写属性。&lt;/p&gt;
&lt;h2&gt;动画（Animation）&lt;/h2&gt;
&lt;p&gt;根据 CSS Grid 布局模块 Level 1 规范，有 5 个可应用动画的网格属性：&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;grid-gap&lt;/code&gt;， &lt;code&gt;grid-row-gap&lt;/code&gt;，&lt;code&gt;grid-column-gap&lt;/code&gt; 作为长度，百分比或 calc。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;grid-template-columns&lt;/code&gt;，&lt;code&gt;grid-template-rows&lt;/code&gt; 作为长度，百分比或 calc 的简单列表，只要列表中长度、百分比或calc组件的值不同即可。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;浏览器支持CSS网格属性&lt;/h3&gt;
&lt;p&gt;截至（2018年5月7日），在测试的几个浏览器中仅实现 &lt;code&gt;(grid-)gap&lt;/code&gt;，&lt;code&gt;(grid-)row-gap&lt;/code&gt;，&lt;code&gt;(grid-)column-gap&lt;/code&gt; 的动画。&lt;/p&gt;
&lt;p&gt;浏览器支持可设置动画的网格属性：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;浏览器&lt;/th&gt;
&lt;th&gt;(grid-)gap, (grid-)row-gap, (grid-)column-gap&lt;/th&gt;
&lt;th&gt;grid-template-columns&lt;/th&gt;
&lt;th&gt;grid-template-rows&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;Firefox 55+, Firefox 53+ Mobile&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;td&gt;❌&lt;/td&gt;
&lt;td&gt;❌&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Safari 11.0.2&lt;/td&gt;
&lt;td&gt;❌&lt;/td&gt;
&lt;td&gt;❌&lt;/td&gt;
&lt;td&gt;❌&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Chrome 66+&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;td&gt;❌&lt;/td&gt;
&lt;td&gt;❌&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;Chrome for Android 66+, Opera Mini 33+&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;td&gt;❌&lt;/td&gt;
&lt;td&gt;❌&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Edge 16+&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;td&gt;❌&lt;/td&gt;
&lt;td&gt;❌&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</description>
<pubDate>Fri, 15 Feb 2019 12:08:00 +0000</pubDate>
<dc:creator>消逝的风i</dc:creator>
<og:description>CSS Grid 布局是 CSS 中最强大的布局系统。与 flexbox 的一维布局系统不同，CSS Grid 布局是一个二维布局系统，也就意味着它可以同时处理列和行。通过将 CSS 规则应用于</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/abc-x/p/10258695.html</dc:identifier>
</item>
</channel>
</rss>