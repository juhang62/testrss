<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>位操作的个人总结 - 红城客栈蓝精灵</title>
<link>http://www.cnblogs.com/phillee/p/10540512.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/phillee/p/10540512.html</guid>
<description>&lt;p&gt;在计算机中所有数据都是以二进制形式进行存储，而位运算就是直接对内存中的二进制数据进行操作，因此处理速度非常快。&lt;/p&gt;
&lt;p&gt;1. 基本操作&lt;/p&gt;
&lt;table border=&quot;0&quot; frame=&quot;border&quot; rules=&quot;all&quot; align=&quot;center&quot;&gt;&lt;tbody readability=&quot;6.5&quot;&gt;&lt;tr&gt;&lt;td&gt;运算符&lt;/td&gt;
&lt;td&gt;用法示例&lt;/td&gt;
&lt;td&gt;运算规则&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;按位与 AND&lt;/td&gt;
&lt;td&gt;a &amp;amp; b&lt;/td&gt;
&lt;td&gt;只有两个操作数相应的比特位都为1时，结果才为1，否则为0&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;按位或 OR&lt;/td&gt;
&lt;td&gt;a | b&lt;/td&gt;
&lt;td&gt;只有两个操作数相应的比特位都为0时，结果才为0，否则为1&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;按位异或 XOR&lt;/td&gt;
&lt;td&gt;a ^ b&lt;/td&gt;
&lt;td&gt;两个操作数相应比特位不相同时，结果为1，否则为0&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;按位取反 NOT&lt;/td&gt;
&lt;td&gt;~a&lt;/td&gt;
&lt;td&gt;操作数相应比特位取反，0变为1, 1变为0&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;左移&lt;/td&gt;
&lt;td&gt;a &amp;lt;&amp;lt; b&lt;/td&gt;
&lt;td&gt;将a的二进制形式向左移b个bit，右侧填充0&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;右移&lt;/td&gt;
&lt;td&gt;a &amp;gt;&amp;gt; b&lt;/td&gt;
&lt;td&gt;将a的二进制形式向右移b个bit，有符号数逻辑移位，无符号数算术移位&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;C/C++中移位运算包含逻辑移位（Logical shift）和算术移位（Arithmetic shift）两种，其中逻辑移位的意思是，移出去的位直接舍弃，空缺位用0填充；算术移位的意思是，移出去的位直接舍弃，空缺位用符号位填充。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对于无符号数，无论是左移还是右移都是逻辑移位，如0011 0110 左移两位结果为1101 1000，右移两位结果为0000 1101。&lt;/li&gt;
&lt;li&gt;对于有符号数，左移仍然是逻辑移位，右移则略有不同，进行的是算术移位，如1011 0110 左移两位结果为1101 1000，右移两位结果为1110 1101(前面两位填充的是符号位1)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2. 常见应用&lt;/p&gt;
&lt;p&gt;对n的指定位进行操作，其它位保持不变。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; n &amp;amp;= ~(&lt;span&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;5&lt;/span&gt;)；    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1左移5位得到 0010 0000， 按位取反得 1101 1111，与n按位与使其第6位被清零，其它位不变&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; n |= (&lt;span&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;5&lt;/span&gt;)；     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1左移5位得到 0010 0000， 与n按位或使其第6位被置1，其它位不变&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; n ^= (&lt;span&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;5&lt;/span&gt;)；     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将n第6位取反，其它位不变&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;判断给定正整数n的奇偶&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; flag = a &amp;amp; &lt;span&gt;1&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; a对应二进制数末位为0则为偶数，否则为奇数。相比 bool flag = (a % 2 == 0); 运算速度快了很多。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;判断n是否为2的正整数次幂&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;/*=&lt;/span&gt;&lt;span&gt;==============================================================================================
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt; * 将2的次幂写成二进制容易发现，二进制中只有一个1，后面跟了n个0。
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt; * 如果将这个数减1，仅有的一个1变成了0，后面的n个0变成了1。时间复杂度O(1)。
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt; *===============================================================================================&lt;br/&gt;&lt;/span&gt;&lt;span&gt;   */&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; isPowerOfTwo(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n) {
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; (n &amp;amp; (n - &lt;span&gt;1&lt;/span&gt;)  == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;); 
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;==============================================================================================
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * 常规思路：利用循环判断n是否能被2整除，如果是除以2，继续循环。
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt; * 最终结果若为1则表明其是2的正整数次幂，否则不是。时间复杂度O(log n)。
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; *==============================================================================================
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; isPowerOfTwo(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt; (n % &lt;span&gt;2&lt;/span&gt; ==&lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         n /= &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; (n == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);  
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;统计给定正整数的二进制中1的个数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;==============================================================================================
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * 与上述判断n是否为2的正整数次幂时相似，n&amp;amp;(n -1) 作用是将n的二进制中最右边的1置为0，如此循环以统计n中1的个数
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt; *==============================================================================================
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; count1Bit(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; countOneBit  = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;&lt;span&gt; (n) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         countOneBit ++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         n &amp;amp;= n -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;　　　　　　　　
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; countOneBit;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;==============================================================================================
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * 另一种四步分组法，以34520(1000011011011000)为例
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt; * 第一步：每2位为一组，组内高低位相加。
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; * 10 00 01 10 11 01 10 00 -&amp;gt; 01 00 01 01 10 01 01 00
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt; * (10高位为1，低位为0，相加得01；11高位为1，低位也为1，相加得10……)。
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt; * 第二步：将第一步得到的结果每4位分为一组，组内高低位相加。
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt; * 0100 0101 1001 0100 -&amp;gt; 0001 0010 0011 0001
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt; * (0100高位为01低位为00，相加得01；1001高位为10低位为01，相加得11……)。
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt; * 第三步：将第二步得到的结果每8位分为一组，组内高低位相加。
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt; * 00010010 00110001 -&amp;gt; 00000011 00000100。
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt; * 第四步：将第三步得到的结果每16位分为一组，组内高低位相加。
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt; * 0000001100000100 -&amp;gt; 00000111。
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt; * 这样最后得到的结果7即为给定整数中1的个数。
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt; *==============================================================================================
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; count1Bit(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     n = ((n &amp;amp; &lt;span&gt;0xAAAA&lt;/span&gt;) &amp;gt;&amp;gt; &lt;span&gt;1&lt;/span&gt;) + (n &amp;amp; &lt;span&gt;0x5555&lt;/span&gt;&lt;span&gt;);　　　　　　　　　　　　　　　　　　　　　
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     n = ((n &amp;amp; &lt;span&gt;0xCCCC&lt;/span&gt;) &amp;gt;&amp;gt; &lt;span&gt;2&lt;/span&gt;) + (n &amp;amp; &lt;span&gt;0x3333&lt;/span&gt;&lt;span&gt;);　　　　　　　　　　　　　　　　　　　　　 
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     n = ((n &amp;amp; &lt;span&gt;0xF0F0&lt;/span&gt;) &amp;gt;&amp;gt; &lt;span&gt;4&lt;/span&gt;) + (n &amp;amp; &lt;span&gt;0x0F0F&lt;/span&gt;&lt;span&gt;);　　　　　　　　　　　　　　　　　　　　　 
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     n = ((n &amp;amp; &lt;span&gt;0xFF00&lt;/span&gt;) &amp;gt;&amp;gt; &lt;span&gt;8&lt;/span&gt;) + (n &amp;amp; &lt;span&gt;0x00FF&lt;/span&gt;&lt;span&gt;);　　　　　　　　　　　　　　　　　　　　
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; n;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;不需要额外变量交换两个整数的值&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Swap(&lt;span&gt;int&lt;/span&gt; &amp;amp;m, &lt;span&gt;int&lt;/span&gt; &amp;amp;&lt;span&gt;n) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; ( m !=&lt;span&gt; n ) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         m ^= n;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; m = (m ^ n)&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;         n ^= m;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; n = n ^ (m ^ n) = n ^ m ^ n = n ^ n ^ m =m, 一个数和自身异或结果为0，一个数和0异或结果为其自身&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;         m ^= n;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; m = m ^ n = m ^ n ^ m = n&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Swap(&lt;span&gt;int&lt;/span&gt; &amp;amp;m, &lt;span&gt;int&lt;/span&gt; &amp;amp;&lt;span&gt;n) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; ( m !=&lt;span&gt; n ) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; temp = a;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 常规思路：借由中间变量实现交换。&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;         a =&lt;span&gt; b;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         b =&lt;span&gt; temp;
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;16位无符号整型数高低位交换&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;=========================================================================================
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt; * 对于16位无符号整型数据，分为高8位和低8位，高八位右移时高位填充0，低八位左移时末位填充0，将两者相加即可。
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt; *=========================================================================================
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; unsigned &lt;span&gt;int&lt;/span&gt; lowHighExchange(unsigned &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n) {
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; ((a &amp;gt;&amp;gt; &lt;span&gt;8&lt;/span&gt;) + (a &amp;lt;&amp;lt; &lt;span&gt;8&lt;/span&gt;&lt;span&gt;)); 
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;二进制逆序操作&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;========================================================================================
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * 通过四步分组法得到16位整型数据的二进制逆序。以34520（1000 0110 1101 1000）为例，
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt; * 第一步：每2位为一组，组内高低位交换。
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; * 10 00 01 10 11 01 10 00-&amp;gt;01 00 10 01 11 10 01 00。
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt; * 第二步：每4位为一组，组内高低位交换。0100 1001 1110 0100 -&amp;gt; 0001 0110 1011 0001。
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt; * 第三步：每8位为一组，组内高低位交换。00010110 10110001 -&amp;gt; 01100001 00011011。
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt; * 第四步：每16位为一组，组内高低位交换。0110000100011011 -&amp;gt; 00011011 01100001。
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt; * 改进：对第一步先分别取原数据的奇数位和偶数位
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt; * 空位以下划线表示：1_0_0_1_1_0_1_0_, _0_0_1_0_1_1_0_0, 
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt; * 将下划线填充0得原数 1000 0110 1101 1000
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt; * 奇数位 1000 0010 1000 1000, 偶数位 0000 0100 0101 0000
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt; * 再将奇数位右移一位，偶数位左移一位，将移位后的两数按位或可使奇偶位数据交换。
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt; * 原数 1000 0110 1101 1000， 奇数位右移一位 0100 0001 0100 0100
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt; * 偶数位左移一位 0000 1000 1010 0000，按位或得 0100 1001 1110 0111
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt; *=======================================================================================
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; binaryReverse( &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n ) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     n = ((n &amp;amp; &lt;span&gt;0xAAAA&lt;/span&gt;) &amp;gt;&amp;gt; &lt;span&gt;1&lt;/span&gt;) | ((a &amp;amp; &lt;span&gt;0x5555&lt;/span&gt;) &amp;lt;&amp;lt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     n = ((n &amp;amp; &lt;span&gt;0xCCCC&lt;/span&gt;) &amp;gt;&amp;gt; &lt;span&gt;2&lt;/span&gt;) | ((a &amp;amp; &lt;span&gt;0x3333&lt;/span&gt;) &amp;lt;&amp;lt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);　　　　　　　　　　　　　　　　　　　　　　　　　　　　　
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     n = ((n &amp;amp; &lt;span&gt;0xF0F0&lt;/span&gt;) &amp;gt;&amp;gt; &lt;span&gt;4&lt;/span&gt;) | ((a &amp;amp; &lt;span&gt;0x0F0F&lt;/span&gt;) &amp;lt;&amp;lt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; (((n &amp;amp; &lt;span&gt;0xFF00&lt;/span&gt;) &amp;gt;&amp;gt; &lt;span&gt;8&lt;/span&gt;) | ((a &amp;amp; &lt;span&gt;0x00FF&lt;/span&gt;) &amp;lt;&amp;lt; &lt;span&gt;8&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;3. 拓展应用&lt;/p&gt;
&lt;p&gt;题目：不使用加减乘除四则运算实现两个正整数相加。&lt;/p&gt;
&lt;p&gt;解析：首先理解十进制加法工作原理，主要分为三步，以4+9为例：1）相加相应位的值，不算进位，得3；2）计算进位值，得10，如果进位值为0则第一步得到的就是最终结果；3）把前两步的结果相加，重复此过程得结果13。&lt;/p&gt;
&lt;p&gt;再来看二进制相加过程。1）相加相应位的值，不算进位，100 + 1001，得1101；2）计算进位值，得0000，如果进位为0则第一步得到的就是最终结果；3）把前两步的结果相加，重复此过程的结果1101。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;==================================================================================================
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt; * 相加相应位的值可按位异或，因为如果不考虑进位的和，只有0+1或者1+0才是1, 刚好符合异或的性质：0100 ^ 1001 = 1101
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt; * 计算进位可使用按位与，因为只有1+1才会发生进位并需要将这个进位左移1位： (0100 &amp;amp; 1001) &amp;lt;&amp;lt; 1 = 0000
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt; * 然后一直循环直到进位为0，此时的结果就是输入两数之和了。
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt; *==================================================================================================
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Add(&lt;span&gt;int&lt;/span&gt; num1, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; num2) {
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; num2 ? Add(num1 ^ num2, (num1 &amp;amp; num2)&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;) : num1;    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;题目：给定一个非空整数数组，其中有一个元素只出现一次，其它元素均出现两次，请找出只出现一次的元素。（要求实现算法具有线性时间复杂度，并且不实用额外空间）&lt;/p&gt;
&lt;p&gt;示例：输入[2, 2, 1]，输出1。输入[3, 1, 2, 3, 1]，输出2。&lt;/p&gt;
&lt;p&gt;解析：由于要求时间复杂度O(n)，空间复杂度O(1)，不能用排序，也不能使用map。考虑使用位操作运算求解。因为任何数与自身异或结果为0，任何数与0异或结果为其自身，将所有元素做异或运算，即a[1]⊕a[2]⊕...⊕a[n]，那么结果就是只出现一次的元素，时间复杂度O(n)。过程如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1619325/201903/1619325-20190316014811118-104759960.gif&quot; alt=&quot;&quot; width=&quot;524&quot; height=&quot;293&quot;/&gt;&lt;/p&gt;
&lt;p&gt;题目：给定一个非空整数数组，其中有两个元素只出现一次，其它元素均出现两次，请找出只出现一次的两个元素。（要求实现算法具有线性时间复杂度，而且只能开辟固定大小的内存空间，即与n无关）&lt;/p&gt;
&lt;p&gt;示例：输入[1, 2, 2, 1, 3, 4]，输出[3, 4]。&lt;/p&gt;
&lt;p&gt;解析：根据前面找一个不同数的思路，如果这里再把所有元素异或，得到的结果是只出现一次的两个元素异或得到的值。然后由于这两个只出现一次的元素一定不相同，那么这两个元素的二进制形式肯定至少有一位不同，即1个为0，另一个为1，先在需要找出这一位。根据异或的性质：任何数与自身异或结果为0，得到这个数字二进制形式中任意一个为1的位都是我们要找的。之后以这一位是0还是1为标准，将数组的n个元素分成两部分。将这一位为0的所有元素异或得到的结果就是只出现一次的两个元素中的一个。将这一位为1的所有元素异或得到的结果就是只出现一次的两个元素中的另一个。如果忽略寻找不同位的过程，公遍历数组两次，时间复杂度O(n)。过程如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1619325/201903/1619325-20190316014658070-1176611111.gif&quot; alt=&quot;&quot; width=&quot;526&quot; height=&quot;294&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt; Reference: &lt;/p&gt;
&lt;p&gt;[1] https://www.cnblogs.com/zhoug2020/p/4978822.html&lt;/p&gt;
&lt;p&gt;[2] https://blog.csdn.net/qq_16137569/article/details/82790378&lt;/p&gt;
&lt;p&gt;[3] https://www.cnblogs.com/thrillerz/p/4530108.html&lt;/p&gt;
&lt;p&gt;[4] https://www.cnblogs.com/fivestudy/p/10275446.html&lt;/p&gt;
&lt;p&gt;[5] https://www.nowcoder.com/practice/59ac416b4b944300b617d4f7f111b215?tpId=13&amp;amp;tqId=11201&amp;amp;tPage=3&amp;amp;rp=3&amp;amp;ru=/ta/coding-interviews&amp;amp;qru=/ta/coding-interviews/question-ranking&lt;/p&gt;
</description>
<pubDate>Fri, 15 Mar 2019 19:59:00 +0000</pubDate>
<dc:creator>红城客栈蓝精灵</dc:creator>
<og:description>在计算机中所有数据都是以二进制形式进行存储，而位运算就是直接对内存中的二进制数据进行操作，因此处理速度非常快。 1. 基本操作 C/C++中移位运算包含逻辑移位（Logical shift）和算术移位</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/phillee/p/10540512.html</dc:identifier>
</item>
<item>
<title>RIP 实验 - Pretty_girll</title>
<link>http://www.cnblogs.com/prettygirll/p/10540441.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/prettygirll/p/10540441.html</guid>
<description>&lt;p&gt;&lt;strong&gt;一、环境准备&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1. 软件：GNS3&lt;/p&gt;
&lt;p&gt;2. 路由：c7200&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、实验操作&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;WordSection1&quot;&gt;
&lt;p&gt;&lt;strong&gt;实验要求：&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;1、 理解 RIP 协议的工作原理&lt;/p&gt;
&lt;p&gt;2、 理解 RIPv1、RIPv2 的特性&lt;/p&gt;
&lt;p&gt;3、 掌握 RIP 协议的基本配置方法&lt;/p&gt;
&lt;p&gt;4、 掌握 RIP 自动汇总和手动汇总的方法&lt;/p&gt;
&lt;p&gt;5、 掌握 RIP 配置默认路由的方法&lt;/p&gt;
&lt;p&gt;6、 掌握 RIP 认证的基本配置&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实验拓扑：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/201903/1594459-20190316003613886-1050660790.png&quot; alt=&quot;&quot; width=&quot;577&quot; height=&quot;273&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实验过程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、根据实验拓扑，对路由器各接口配置 IP 地址，配置清单如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;R1 配置：

hostname R1

interface Loopback0

ip address 10.33.33.1 255.255.255.0 secondary

ip address 10.33.34.1 255.255.255.0 secondary

ip address 10.33.35.1 255.255.255.0 secondary

ip address 10.33.36.1 255.255.255.0

interface Loopback1

ip address 192.168.3.1 255.255.255.0

interface FastEthernet0/0

ip address 192.168.1.1 255.255.255.0

R2 配置：

hostname R2

interface Loopback0

ip address 192.168.4.1 255.255.255.0

interface FastEthernet0/0

ip address 192.168.1.2 255.255.255.0

interface FastEthernet0/1

ip address 192.168.2.1 255.255.255.0

R3 配置：

hostname R3

interface Loopback0

ip address 10.33.57.1 255.255.255.0 secondary

ip address 10.33.58.1 255.255.255.0 secondary

ip address 10.33.59.1 255.255.255.0 secondary

ip address 10.33.60.1 255.255.255.0

interface Loopback1

ip address 192.168.4.1 255.255.255.0

interface Loopback2

ip address 211.67.188.1 255.255.255.252

interface FastEthernet0/1

ip address 192.168.2.2 255.255.255.0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2、在路由器中配置 RIP 协议（注，根据步骤 1 所配置的 IP 地址配置 RIP 协议）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;R1 配置：

router rip

network 10.0.0.0     注 2

network 192.168.1.0

network 192.168.3.0

R2 配置：

router rip             注 3

network 192.168.1.0

network 192.168.4.0

R3 配置：

router rip             注 4

network 10.0.0.0

network 192.168.2.0

network 192.168.5.0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;注2：&lt;/strong&gt;network 用来添加网络，在 RIP 中只需添加网络号即可。该命令的作用主要有两个：一是声明 RIP 转发哪些网络的路由表；二是声明在路由器的哪些接口上启用 RIP 协议。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注 3：&lt;/strong&gt;注意这里没有添加192.168.2.0，所以接口 f0/0 不会发送和接收 RIP 报文&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注 4：&lt;/strong&gt;这里没有添加 211.68.188.0，这是因为 211.67.188.0 连接 Internet，内部路由不能转发到外网，同时内部的网络也不需要知道外网的情况。&lt;/p&gt;

&lt;p&gt;问题 1：配置后在每个路由器上查看路由表，在路由器 R1 和 R2 中能看到 192.168.5.0 吗？在路由器 R3 中能看到路由器 R1 和 R2 中的路由吗？&lt;/p&gt;
&lt;p&gt;答：在路由器 R1 和 R2 中不能看到 192.168.5.0。&lt;/p&gt;
&lt;p&gt;在路由器 R3 中不能看到路由器 R1 和 R2 中的路由。&lt;/p&gt;
&lt;p&gt;R1路由表&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/201903/1594459-20190316004045701-828451918.png&quot; alt=&quot;&quot; width=&quot;419&quot; height=&quot;214&quot;/&gt;&lt;/p&gt;
&lt;p&gt;R2路由表&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/201903/1594459-20190316004153033-1886340399.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;R3路由表&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/201903/1594459-20190316004252642-520754630.png&quot; alt=&quot;&quot; width=&quot;414&quot; height=&quot;242&quot;/&gt;&lt;/p&gt;

&lt;p&gt;问题 2：现在在路由器 R2 中添加 192.168.2.0，再查看每个路由器的路由表，看有什么变化？&lt;/p&gt;
&lt;p&gt;答：每一个路由器都包含其它路由器的路由信息。&lt;/p&gt;
&lt;p&gt;R1路由表&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/201903/1594459-20190316004539875-1202386811.png&quot; alt=&quot;&quot; width=&quot;415&quot; height=&quot;239&quot;/&gt;&lt;/p&gt;
&lt;p&gt;R2路由表&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/201903/1594459-20190316004559807-1664624018.png&quot; alt=&quot;&quot; width=&quot;415&quot; height=&quot;181&quot;/&gt;&lt;/p&gt;
&lt;p&gt;R3路由表&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/201903/1594459-20190316004613967-1086411678.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;问题 3：这时在路由器 R3 中 ping 10.33.34.1看能否 ping 通，为什么？提示：看路由表&lt;/p&gt;
&lt;p&gt;答：路由器 R3 ping 10.33.34.1 不能ping通。因为R3路由表中没有到达10.33.34.1IP网络的路由条目。&lt;/p&gt;
&lt;p&gt;R3路由表&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/201903/1594459-20190316004652139-1637742660.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;3、测试不同版本 RIP 协议之间的数据传递，在路由器 R1 中启用 RIPv2，然后在每个路由器中删除当前路由表，重新生成路由表后，查看各路由器中路由表变化。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;启用 RIPv2 命令：

R1(config)#router rip

R1(config-router)#version 2

删除路由表命令：

R1#clear ip route *&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;R1 路由表&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/201903/1594459-20190316004739427-2144785381.png&quot; alt=&quot;&quot; width=&quot;415&quot; height=&quot;222&quot;/&gt; &lt;/p&gt;
&lt;p&gt;R2 路由表&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/201903/1594459-20190316004800177-2012739276.png&quot; alt=&quot;&quot; width=&quot;418&quot; height=&quot;267&quot;/&gt;&lt;/p&gt;
&lt;p&gt;R3 路由表&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/201903/1594459-20190316004823706-387581422.png&quot; alt=&quot;&quot; width=&quot;414&quot; height=&quot;271&quot;/&gt;&lt;/p&gt;

&lt;p&gt;问题 4：在 R1 中能否看到 R2 和 R3 中的路由？在 R2 中能否看到 R1 的路由。&lt;/p&gt;
&lt;p&gt;答：1. 在 R1 中不能看到 R2 和 R3 中的路由。因为R1接收的是RIP2的报文信息，而R2、R3发送的是RIP1报文信息，所以R1没法更新自己的路由表。&lt;/p&gt;

&lt;p&gt;2. 在 R2 中能看到 R1 的路由。因为R2可以接收来自R1使用RIP2发送的路由报文信息。&lt;/p&gt;
&lt;p&gt;R1使用的路由协议 //只能Rec2的路由报文信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/201903/1594459-20190316004912996-159967500.png&quot; alt=&quot;&quot; width=&quot;409&quot; height=&quot;313&quot;/&gt;&lt;/p&gt;
&lt;p&gt;R2使用的路由协议  //可以Rec1、2的路由报文信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/201903/1594459-20190316004928044-1818312085.png&quot; alt=&quot;&quot; width=&quot;406&quot; height=&quot;295&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4、配置手动汇总，解决“问题 3”中无法通信问题。&lt;/p&gt;
&lt;p&gt;（1）首先，在 R2 和 R3 中也启用 RIPv2，命令参考 R1 中启用 RIPv2 命令。&lt;/p&gt;
&lt;p&gt;（2）在每个路由器中关闭自动汇总，关闭自动汇总参考命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
R1(config-router)#no auto-summary
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（3）在路由器 R1 的接口 f0/0 、R3 的接口 f0/1中配置手动汇总：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;R1(config-if)#interface f0/0

R1(config-if)#ip summary-address rip 10.33.32.0 255.255.248.0  注 5

R3(config-if)#interface f0/1

R3(config-if)#ip summary-address rip 10.33.56.0 255.255.248.0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;R1 路由表&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/201903/1594459-20190316005011574-804027148.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;R2 路由表&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/201903/1594459-20190316005025682-641377944.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;R3 路由表&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/201903/1594459-20190316005044098-156120750.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注 5：该命令格式为 ip summary-address rip  网络地址   子网掩码，命令的作用是在该接口上向外发送路由更新时把多个网络汇总成一个路由条目。&lt;/p&gt;

&lt;p&gt;问题 5：此时在路由器 R3 上 ping 10.33.34.1，能否 ping 通？&lt;/p&gt;
&lt;p&gt;答：路由器 R3 ping 10.33.34.1 能ping通。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/201903/1594459-20190316005107570-1821085653.png&quot; alt=&quot;&quot; width=&quot;422&quot; height=&quot;69&quot;/&gt;&lt;/p&gt;

&lt;p&gt;5、在路由器 R3 上启用默认路由，让内部网络可以访问 Internet。在路由器 R3 上配置静态默认路由&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
R3(config)#ip route 0.0.0.0 0.0.0.0 211.33.188.2   
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在路由器 R3 中配置向其他路由器注入默认路由&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;R3(config)#router rip

R3(config-router)#default-information originate&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;问题 6：在 R1 和 R2 中查看路由表，有什么变化？此时在 R1 中 ping 211.67.188.1，能否 ping通？&lt;/p&gt;
&lt;p&gt;答：变化：R1中没有默认路由条目，R2中有默认路由条目。&lt;/p&gt;
&lt;p&gt;在 R1 中 ping 211.67.188.1，不能ping通。而R2能ping通。因为R1没有到达211.67.188.0网络的默认路由。&lt;/p&gt;
&lt;p&gt;R1 路由表&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/201903/1594459-20190316005139881-154188638.png&quot; alt=&quot;&quot; width=&quot;415&quot; height=&quot;216&quot;/&gt;&lt;/p&gt;
&lt;p&gt;R2 路由表&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/201903/1594459-20190316005156069-650536655.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;7、 在路由器 R1 和 R2 之间实现认证。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;R1 中的配置命令：

R1(config)#key chain J

R1(config-keychain)#key 1

R1(config-keychain-key)#key-string 5005170033

R1(config)#interface f0/0

R1(config-if)#ip rip authentication key-chain J 

R1(config-if)#ip rip authentication mode md5&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;问题 7：在 R1 中配置之后，删除 R1 和 R2 的当前路由表，重新生成，在 R1 中能否看到其他路由器上的路由？&lt;/p&gt;
&lt;p&gt;答：在 R1 中不能看到其他路由器上的路由。因为需要认证。&lt;/p&gt;

&lt;p&gt;8、 参考 R1 的配置，在 R2 中做同样的认证配置，然后更新路由表，在 R1 中能否看到其他路由器上的路由？注意，R2 中应该在接口 f0/0 中启用认证。&lt;/p&gt;

&lt;p&gt;9、 修改路由器 R3 发送出去的路由信息的度量值，参考命令如下：&lt;/p&gt;
&lt;p&gt;创建访问控制列表 ACL，配置需要修改 metric 的路由条目&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;R3(config)#access-list 33 permit 192.168.5.0 0.0.0.255  

R3(config)#router rip

R3(config-router)#offset-list 33 out 2 f0/1  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;问题 8：修改后查看路由器 R1 上关于 192.168.5.0 的路由，距离是多少？修改前的距离是多少？&lt;/p&gt;
&lt;p&gt;答：修改后：4、修改前：2&lt;/p&gt;

&lt;p&gt;10、做完所有配置后注意保存，保存命令如下：&lt;/p&gt;
&lt;p&gt;R1#write      或者&lt;/p&gt;
&lt;p&gt;R1#copy running-config startup-config&lt;/p&gt;

</description>
<pubDate>Fri, 15 Mar 2019 17:04:00 +0000</pubDate>
<dc:creator>Pretty_girll</dc:creator>
<og:description>一、环境准备 1. 软件：GNS3 2. 路由：c7200 二、实验操作 实验要求： 实验要求： 1、 理解 RIP 协议的工作原理 2、 理解 RIPv1、RIPv2 的特性 3、 掌握 RIP 协</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/prettygirll/p/10540441.html</dc:identifier>
</item>
<item>
<title>supervisor管理nginx+tomcat容器 - lin666</title>
<link>http://www.cnblogs.com/lin666-/p/10540402.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lin666-/p/10540402.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;需求：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;      使用docker来启动nginx + tomcat 双进程，实际应用中，多进程还是比较常见的。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;1: 创建dockerfile目录&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
mkdir -p /docker/web
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;


&lt;p&gt;&lt;span&gt;2: 编写dockerfile: /docker/web/Dockerfile&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
FROM centos7
MAINTAINER lin test@163.com
COPY CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo
COPY nginx_install.sh /tmp/nginx_install.sh
RUN sh /tmp/nginx_install.sh; \rm -rf /usr/local/src/*
RUN sed -i -e '/worker_processes/a daemon off;' /usr/local/nginx/conf/nginx.conf;

COPY jdk-8u162-linux-x64.tar.gz /usr/local/src/jdk-8u162-linux-x64.tar.gz
COPY tomcat_install.sh /tmp/tomcat_install.sh
RUN sh /tmp/tomcat_install.sh; \rm -rf /usr/local/src/*

COPY supervisor_install.sh /tmp/supervisor_install.sh
COPY supervisord.conf /etc/supervisord.conf
COPY start_tomcat.sh /usr/local/tomcat/bin/mystart.sh
RUN sh /tmp/supervisor_install.sh; \rm -rf /tmp/*.sh
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;3: dockerfile集成的配置文件及安装文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.1  默认源下载较慢，更换yum源，以下CentOS-Base.repo配置文件拷贝到容器里更换&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
&lt;span&gt;COPY CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo&lt;/span&gt;&lt;/pre&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@docker web]# cat CentOS-Base.repo 
[base]
name=CentOS-$releasever - Base
baseurl=http://mirrors.163.com/centos/$releasever/os/$basearch/
gpgcheck=1
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7

#released updates
[updates]
name=CentOS-$releasever - Updates
baseurl=http://mirrors.163.com/centos/$releasever/updates/$basearch/
gpgcheck=1
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7

#additional packages that may be useful
[extras]
name=CentOS-$releasever - Extras
baseurl=http://mirrors.163.com/centos/$releasever/extras/$basearch/
gpgcheck=1
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7

#additional packages that extend functionality of existing packages
[centosplus]
name=CentOS-$releasever - Plus
baseurl=http://mirrors.163.com/centos/$releasever/centosplus/$basearch/
gpgcheck=1
enabled=0
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;3.2nginx安装脚本　&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
[root@docker web]# cat nginx_install.sh 
yum install -y wget tar gcc gcc-c++ make pcre pcre-devel zlib zlib-devel openssl openssl-devel

cd /usr/local/src
wget 'http://nginx.org/download/nginx-1.12.2.tar.gz'
tar -zxvf nginx-1.12.2.tar.gz
cd nginx-1.12.2
./configure --prefix=/usr/local/nginx --with-http_ssl_module --with-stream --with-stream_ssl_module
make
make install
exit 0
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;3.3tomcat安装脚本&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
[root@docker web]# cat tomcat_install.sh 
yum install -y wget tar
cd /usr/local/src/
tar -zxvf jdk-8u162-linux-x64.tar.gz
mv jdk1.8.0_162 /usr/local/
#/usr/local/jdk1.8.0_162/bin/java -version

#配置java环境变量
echo 'JAVA_HOME=/usr/local/jdk1.8.0_162/' &amp;gt;&amp;gt;/etc/profile
echo 'PATH=$PATH:$JAVA_HOME/bin' &amp;gt;&amp;gt;/etc/profile
echo 'CLASSPATH=.:$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jar:$CLASSPATH' &amp;gt;&amp;gt;/etc/profile
source /etc/profile

wget https://mirrors.tuna.tsinghua.edu.cn/apache/tomcat/tomcat-8/v8.5.38/bin/apache-tomcat-8.5.38.tar.gz
tar -zxvf apache-tomcat-8.5.38.tar.gz
mv apache-tomcat-8.5.38 /usr/local/tomcat
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;3.4dockerfile文件中涉及到的配置文件、脚本、安装包如下&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
[root@docker web]# ll
total 185384
-rw-r--r-- 1 root root 835 Mar 9 01:12 CentOS-Base.repo
-rw-r--r-- 1 root root 669 Mar 9 01:11 Dockerfile
-rw-r--r-- 1 root root 189815615 Mar 9 01:15 jdk-8u162-linux-x64.tar.gz
-rw-r--r-- 1 root root 340 Mar 9 01:13 nginx_install.sh
-rw-r--r-- 1 root root 581 Mar 9 01:17 tomcat_install.sh
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;4: 一键安装supervisor: /docker/web/supervisor_install.sh&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
yum -y install epel-release
yum -y install python2-pip
pip install supervisor
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;5: supervisor配置文件: /docker/web/supervisord.conf&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
[unix_http_server]
file=/tmp/supervisor.sock ; the path to the socket file

[supervisord]
logfile=/tmp/supervisord.log ; 日志
logfile_maxbytes=50MB ; 最大50M日志
logfile_backups=10 ; 轮循日志备份10个
loglevel=info ; 日志等级记录info的
pidfile=/tmp/supervisord.pid ;pid
nodaemon=true ;在前台启动
minfds=102400 ; 文件描述符限制
minprocs=2000 ; 进程数

[rpcinterface:supervisor]
supervisor.rpcinterface_factory = supervisor.rpcinterface:make_main_rpcinterface

[supervisorctl]
serverurl=unix:///tmp/supervisor.sock ; use a unix:// URL for a unix socket

[program:nginx]
command=/usr/local/nginx/sbin/nginx ; 前台启动nginx
autostart=true ; 随着supervisor自动启动
startsecs=10 ; 启动10s后算正常启动
autorestart=true ; 程序退出后自动重启
startretries=3 ; 启动失败自动重试次数
stdout_logfile_maxbytes=20MB ;stdout 日志文件大小最大20Mb
stdout_logfile=/usr/local/nginx/logs/out.log

[program:tomcat]
command=sh /usr/local/tomcat/bin/mystart.sh ; 前台启动tomcat
autostart=true ; 随着supervisor自动启动
startsecs=10 ; 启动10s后算正常启动
autorestart=true ; 程序退出后自动重启
startretries=3 ; 启动失败自动重试次数
stdout_logfile_maxbytes=20MB ;stdout 日志文件大小最大20Mb
stdout_logfile=/usr/local/tomcat/logs/catalina.out
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;6: tomcat的启动脚本/docker/web/start_tomcat.sh&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
#由于supervisor无法使用source，需要编写个脚本来启动
source /etc/profile
/usr/local/tomcat/bin/catalina.sh run
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;7: 构建镜像&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
cd /docker/web
docker build -t shijiange_web .


[root@docker web]# docker images
REPOSITORY TAG IMAGE ID CREATED SIZE
shijiange_web latest bc06a9974252 7 seconds ago 1.33 GB
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;8: 启动容器测试&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
[root@docker web]# docker run -d shijiange_web /bin/bash -c 'supervisord -c /etc/supervisord.conf'
76782ab71c3b1d2f818ad76214d6336ae11a524eeb9d211f154fe4ad5226015d
[root@docker web]# 
[root@docker web]# docker ps
CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES
76782ab71c3b shijiange_web &quot;container-entrypo...&quot; 12 seconds ago Up 12 seconds happy_jones
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;9.测试验证：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
[root@docker web]# docker exec -it 76782ab /bin/bash
bash-4.2# ifconfig
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1524676/201903/1524676-20190316002214653-310152621.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;10.容器验证：curl nginx&lt;/span&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1524676/201903/1524676-20190316002710482-1046932358.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;11.容器验证：curl tomcat&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1524676/201903/1524676-20190316002801451-1413601581.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 15 Mar 2019 16:33:00 +0000</pubDate>
<dc:creator>lin666</dc:creator>
<og:description>需求： 使用docker来启动nginx + tomcat 双进程，实际应用中，多进程还是比较常见的。 1: 创建dockerfile目录 2: 编写dockerfile: /docker/web/D</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lin666-/p/10540402.html</dc:identifier>
</item>
<item>
<title>搞懂Mysql InnoDB B+树索引 - GrimMjx</title>
<link>http://www.cnblogs.com/GrimMjx/p/10540263.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/GrimMjx/p/10540263.html</guid>
<description>&lt;h2&gt;一.InnoDB索引&lt;/h2&gt;
&lt;p&gt;　　InnoDB支持以下几种索引：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;B+树索引&lt;/li&gt;
&lt;li&gt;全文索引&lt;/li&gt;
&lt;li&gt;哈希索引&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　本文将着重介绍B+树索引。其他两个全文索引和哈希索引只是做简单介绍一笔带过。&lt;/p&gt;
&lt;p&gt;　　哈希索引是自适应的，也就是说这个&lt;span&gt;不能人为干预&lt;/span&gt;在一张表生成哈希索引，&lt;span&gt;InnoDB会根据这张表的使用情况来自动生成。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　全文索引是将存在数据库的整本书的任意内容信息查找出来的技术，InnoDB从1.2.x版本支持。每张表只能有一个全文检索的索引。&lt;/p&gt;
&lt;p&gt;　　B+树索引是传统意义上的索引，&lt;span&gt;B+树索引并不能根据键值找到具体的行数据，B+树索引只能找到行数据锁在的页，然后通过把页读到内存，再在内存中查找到行数据。&lt;/span&gt;&lt;span&gt;B+树索引也是最常用的最为频繁使用的索引。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;二.什么是B+树&lt;/h2&gt;
&lt;h3&gt;概念&lt;/h3&gt;
&lt;p&gt;　　B+树是一种平衡查找树，其实先想想看为什么要用平衡查找树，不用二叉树？普通的二叉树可能因为插入的数据&lt;span&gt;最后变成一个很长的链表&lt;/span&gt;，怎么能提高搜索的速度呢？你可以想想，为什么HashMap和ConcurrentHashMap在JDK8的时候，当链表大于8的时候把链表转成红黑树（红黑树也是平衡查找树）。技术思维是想通的，那么答案无非是加快速度，性能咯。&lt;/p&gt;
&lt;p&gt;　　一个B+树有以下特征：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;有n个子树的中间节点包含n个元素，每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。&lt;/li&gt;
&lt;li&gt;所有叶子节点包含元素的信息以及指向记录的指针，且叶子节点按关键字自小到大顺序链接。&lt;/li&gt;
&lt;li&gt;所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　那么我们先来看一个B+树的图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1465200/201903/1465200-20190315225328622-646596543.png&quot; alt=&quot;&quot; width=&quot;586&quot; height=&quot;285&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　所有的数据都在叶子节点，且每一个叶子节点都带有指向下一个节点的指针，形成了一个有序的链表。为什么要有序呢？其实是为了范围查询。比如说select * from Table where id &amp;gt; 1 and id &amp;lt; 100; &lt;span&gt;当找到1后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提到了区间查询效率。&lt;/span&gt;是不是范围查询的话hash就搞不定这个事情了？以下为B+树的优势：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;单一节点存储更多元素，减少IO&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;所有查询都要找到叶子节点，查询稳定&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;所有叶子节点形成有序链表，方便范围查询&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　一般性情况，数据库的B+树的高度一般在2~4层，这就是说找到某一键值的行记录最多需要2到4次逻辑IO，相当于0.02到0.04s。&lt;/p&gt;

&lt;h2&gt;三.聚集索引和辅助索引&lt;/h2&gt;
&lt;h3&gt;聚集索引&lt;/h3&gt;
&lt;p&gt;　　聚集索引是按表的主键构造的B+树，叶子节点存放的为整张表的行记录数据，&lt;span&gt;每张表只能有一个聚集索引&lt;/span&gt;。优化器更倾向采用聚集索引。因为直接就能获取行数据。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;请选择自增id来做主键，不要非空UK列。避免大量分页碎片。&lt;/span&gt;下面来看一个聚集索引的图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1465200/201903/1465200-20190315231158642-295021427.png&quot; alt=&quot;&quot; width=&quot;646&quot; height=&quot;276&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　那么很简单了，&lt;span&gt;每个叶子节点，都存有完整的行记录。对于主键的查找速度那是相当的快&lt;/span&gt;，美滋滋。&lt;/p&gt;
&lt;h3&gt;辅助索引&lt;/h3&gt;
&lt;p&gt;　　辅助索引也叫非聚集索引，叶子节点除了键值以外还包含了一个bookmark，用来告诉InnoDB在哪里可以找到对应的行数据，InnoDB的辅助索引的bookmark就是相对应行数据的聚集索引键。&lt;span&gt;也就是先获取指向主键索引的主键，然后通过主键索引来找到一个完整的行&lt;/span&gt;。如果辅助索引的树和聚集索引的树的高度都是3，如果不是走主键索引走辅助索引的话，那么需要6次逻辑IO访问得到最终的数据页。辅助索引和聚集索引的概念关系图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1465200/201903/1465200-20190315231929719-147092273.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;四.索引实战&lt;/h2&gt;
&lt;h3&gt;设计索引&lt;/h3&gt;
&lt;p&gt;　　设计索引的时候，无论是组合索引还是普通索引等。一般经验是，&lt;span&gt;选择经常被用来过滤记录的字段，高选择性，高区分性。&lt;/span&gt;别把性别字段设计索引，性别属于低选择性的。你可以选择名字嘛，你好我大名叫苗嘉杏：）&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;知道加索引快，但是也别乱加索引&lt;/span&gt;，插入以及更新索引的操作InnoDB都会维护B+树的，多加很多索引只会导致效率降低！&lt;/p&gt;
&lt;p&gt;　　不要用重复的索引，比如有个联合索引是a，b，你又整个a列的普通索引。那不是搞事么？&lt;/p&gt;
&lt;p&gt;　　不要在索引上用函数和like&lt;/p&gt;
&lt;h3&gt;一颗聚集索引B+树可以放多少行数据？&lt;/h3&gt;
&lt;p&gt;　　这里我们先假设B+树高为2，即存在一个根节点和若干个叶子节点，那么这棵B+树的存放总记录数为：根节点指针数*单个叶子节点记录行数。假设一行记录的数据大小为1k，那么单个叶子节点（页）中的记录数=16K/1K=16。&lt;/p&gt;
&lt;p&gt;　　那么现在我们需要计算出非叶子节点能存放多少指针，我们假设主键ID为bigint类型，长度为8字节，而指针大小在InnoDB源码中设置为6字节，这样一共14字节，我们一个页中能存放多少这样的单元，其实就代表有多少指针，即16kb/14b=1170。那么可以算出一棵高度为2的B+树，大概能存放1170*16=18720条这样的数据记录。&lt;/p&gt;
&lt;p&gt;　　根据同样的原理我们可以算出一个高度为3的B+树大概可以存放：1170*1170*16=21902400行数据。所以在InnoDB中B+树高度一般为1-3层，它就能满足千万级的数据存储。在查找数据时一次页的查找代表一次IO，所以通过主键索引查询通常只需要1-3次逻辑IO操作即可查找到数据。&lt;/p&gt;
&lt;h3&gt;Cardinality值&lt;/h3&gt;
&lt;p&gt;　　如何判断一个索引建立的是否好呢？可以用show index from指令查看Cardinality值，这个值是一个&lt;span&gt;预估值&lt;/span&gt;，而不是一个准确值。每次对Cardinality值的统计都是随机取8个叶子节点得到的。&lt;/p&gt;
&lt;p&gt;　　对于innodb来说，达到以下2点就会重新计算cardinality&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果表中1/16的数据发生变化 &lt;/li&gt;
&lt;li&gt;如果stat_modified_counter&amp;gt;200 000 0000&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　实际应用中，（Cardinality/行数）应该尽量接近1。如果非常小则要考虑是否需要此索引。实战一下，比如有一张表，我们来show index一下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
mysql&lt;span&gt;&amp;gt;&lt;/span&gt; show &lt;span&gt;index&lt;/span&gt; &lt;span&gt;from&lt;/span&gt;&lt;span&gt; Order;
&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-------+------------+------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; &lt;span&gt;Table&lt;/span&gt;   &lt;span&gt;|&lt;/span&gt; Non_unique &lt;span&gt;|&lt;/span&gt; Key_name         &lt;span&gt;|&lt;/span&gt; Seq_in_index &lt;span&gt;|&lt;/span&gt; Column_name &lt;span&gt;|&lt;/span&gt; Collation &lt;span&gt;|&lt;/span&gt; Cardinality &lt;span&gt;|&lt;/span&gt; Sub_part &lt;span&gt;|&lt;/span&gt; Packed &lt;span&gt;|&lt;/span&gt; &lt;span&gt;Null&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Index_type &lt;span&gt;|&lt;/span&gt; Comment &lt;span&gt;|&lt;/span&gt; Index_comment &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-------+------------+------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; Order   &lt;span&gt;|&lt;/span&gt;          &lt;span&gt;0&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;PRIMARY&lt;/span&gt;          &lt;span&gt;|&lt;/span&gt;            &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; id          &lt;span&gt;|&lt;/span&gt; A         &lt;span&gt;|&lt;/span&gt;       &lt;span&gt;99552&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;     &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;   &lt;span&gt;|&lt;/span&gt;      &lt;span&gt;|&lt;/span&gt; BTREE      &lt;span&gt;|&lt;/span&gt;         &lt;span&gt;|&lt;/span&gt;               &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; Order   &lt;span&gt;|&lt;/span&gt;          1 &lt;span&gt;|&lt;/span&gt; IDX_orderId      &lt;span&gt;|&lt;/span&gt;            &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; orderId     &lt;span&gt;|&lt;/span&gt; A         &lt;span&gt;|&lt;/span&gt;       &lt;span&gt;96697&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;     &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;   &lt;span&gt;|&lt;/span&gt;      &lt;span&gt;|&lt;/span&gt; BTREE      &lt;span&gt;|&lt;/span&gt;         &lt;span&gt;|&lt;/span&gt;               &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; Order   &lt;span&gt;|&lt;/span&gt;          1 &lt;span&gt;|&lt;/span&gt; IDX_productId    &lt;span&gt;|&lt;/span&gt;            &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; productId   &lt;span&gt;|&lt;/span&gt; A         &lt;span&gt;|&lt;/span&gt;          &lt;span&gt;52&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;     &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;   &lt;span&gt;|&lt;/span&gt;      &lt;span&gt;|&lt;/span&gt; BTREE      &lt;span&gt;|&lt;/span&gt;         &lt;span&gt;|&lt;/span&gt;               &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-------+------------+------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; rows &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.00&lt;/span&gt; sec)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　那么可以看到IDX_productId这个索引的Cardinality比较低。　&lt;/p&gt;
&lt;p&gt;　　需要强制刷新Cardinality值的话可以用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
analyze local &lt;span&gt;table&lt;/span&gt; xxx;
&lt;/pre&gt;&lt;/div&gt;





&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;MySQL5.1参考手册 - &lt;a title=&quot;http://dev.mysql.com/doc/refman/5.1/zh/index.html&quot; href=&quot;http://dev.mysql.com/doc/refman/5.1/zh/index.html&quot;&gt;http://dev.mysql.com/doc/refman/5.1/zh/index.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;《MySQL技术内幕》&lt;/p&gt;
&lt;p&gt;《小灰漫画》&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/leefreeman/p/8315844.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/leefreeman/p/8315844.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.codinglabs.org/articles/theory-of-mysql-index.html&quot; target=&quot;_blank&quot;&gt;http://blog.codinglabs.org/articles/theory-of-mysql-index.html&lt;/a&gt;&lt;/p&gt;




</description>
<pubDate>Fri, 15 Mar 2019 16:19:00 +0000</pubDate>
<dc:creator>GrimMjx</dc:creator>
<og:description>一.InnoDB索引 InnoDB支持以下几种索引： B+树索引 全文索引 哈希索引 本文将着重介绍B+树索引。其他两个全文索引和哈希索引只是做简单介绍一笔带过。 哈希索引是自适应的，也就是说这个不能</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/GrimMjx/p/10540263.html</dc:identifier>
</item>
<item>
<title>MFC图片操作 - 孵化_Mr</title>
<link>http://www.cnblogs.com/YongKang-Guo/p/10540293.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/YongKang-Guo/p/10540293.html</guid>
<description>&lt;p class=&quot;md-end-block&quot;&gt;&lt;strong&gt;&lt;span&gt;根据MFC要操作图片的来源，可分为以下两类：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;strong&gt;&lt;span class=&quot;md-expand&quot;&gt;&lt;span class=&quot;md-softbreak&quot;&gt;　　一、非动态显示图片（即图片先通过资源管理器载入，有一个固定ID）&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;strong&gt;&lt;span class=&quot;md-expand&quot;&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span class=&quot;md-softbreak&quot;&gt;　　二、动态载入图片（即只需要在程序中指定图片的路径即可载入）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;hr/&gt;&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;strong&gt;&lt;span&gt;一、非动态显示图片&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;strong&gt;&lt;span&gt;　　1.传送位图函数&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
    CDC memDC;
    memDC.CreateCompatibleDC(pDC);

    CBitmap NewBitmap, * pOldBitmap;
    NewBitmap.LoadBitmap(IDB_BITMAP1);//从资源中导入位图
    BITMAP bmpInfo;//声明BITMAP结构体
    NewBitmap.GetBitmap(&amp;amp;bmpInfo);//获取位图信息
    pOldBitmap = memDC.SelectObject(&amp;amp;NewBitmap);//将位图选入内存DC

    pDC-&amp;gt;BitBlt(0, 0, 0, 0, &amp;amp;memDC, 0, 0, SRCCOPY);//将内存DC中的位图复制到设备DC
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;strong&gt;&lt;span class=&quot;md-tab&quot;&gt;　　2.创建位图画刷&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
　　　CBitmap NewBitmap;
　　　NewBitmap.LoadBitmap(IDB_BITMAP1);&lt;br/&gt;　　　CBrush NewBrush, *pOldBrush;
　　　NewBrush.CreatePatternBrush(&amp;amp;NewBitmap);
　　　pOldBrush = pDC-&amp;gt;SelectObject(&amp;amp;NewBrush);&lt;br/&gt;　　　pDC-&amp;gt;FillRect(CRect(0,0, nScrHalfWidth * 2, nScrHalfHeight * 2), &amp;amp;NewBrush);&lt;br/&gt;　　　pDC-&amp;gt;SelectObject(pOldBrush);
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;hr/&gt;&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;strong&gt;&lt;span&gt;二、动态载入图片&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;　　&lt;strong&gt;1.CImage&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;　　　　CImage 支持的图片格式有很多，像通常用的jpg，png，bmp，gif等。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
　　　HDC hDC;
　　　hDC = pDC-&amp;gt;GetSafeHdc();
　　　CImage img;
　　　img.Load(L&quot;res/texture.bmp&quot;);
　　　img.Draw(hDC, 0, 0, 100, 100);
&lt;/pre&gt;&lt;/div&gt;

&lt;hr/&gt;&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;补充：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;　　GDI（图形设备接口（Graphics Device Interface）） &lt;span class=&quot;md-softbreak&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;主要任务是负责系统与绘图程序之间的信息交换。在Windows操作系统下，绝大多数具备图形界面的应用程序都离不开GDI。GDI的出现使程序员无需要关心硬件设备及设备正常驱动，就可以将应用程序的输出转化为硬件设备上的输出和构成，实现了程序开发者与硬件设备的隔离，大大方便了开发工作。&lt;span class=&quot;md-softbreak&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-link&quot;&gt;　　GDI绘图工具的基类，一般不能直接使用。其中CBitmap、CBrush、CFont、CPalette、CPen、CRgn等。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-link&quot;&gt;　　在使用GDI对象进行绘图时，需要遵循一下步骤：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-link&quot;&gt;　　　（1）绘图开始前，创建一个新的GDI对象，并选入当前设备上下文，同时保存原GDI对象指针。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-link&quot;&gt;　　　（2）使用新GDI对象绘图。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-link&quot;&gt;　　　（3）绘图结束后，使用已保存的原GDI对象指针将设备上下文回复原状。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　希望本文章能够帮助到您。&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;如果文章中有错误或不足之处，希望您可以在评论区纠正，方便大家交流学习。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;[1]孔令德. 计算机图形学基础教程.清华大学出版社，2008.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 15 Mar 2019 16:07:00 +0000</pubDate>
<dc:creator>孵化_Mr</dc:creator>
<og:description>根据MFC要操作图片的来源，可分为以下两类： 一、非动态显示图片（即图片先通过资源管理器载入，有一个固定ID） 二、动态载入图片（即只需要在程序中指定图片的路径即可载入） 一、非动态显示图片 1.传送</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/YongKang-Guo/p/10540293.html</dc:identifier>
</item>
<item>
<title>Python档案袋（ Sys 与 Import 模块) - 东小东</title>
<link>http://www.cnblogs.com/dongxiaodong/p/10423600.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dongxiaodong/p/10423600.html</guid>
<description>&lt;h2&gt;Sys模块：&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;获取Python有关的环境变量：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt;  sys
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;得到Python的一些相关路径，环境变量&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;其中site-packages目录存放的是一些第三方库&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;其中lib目录存放的是一些标准库&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(sys.path)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;命令行传递参数&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt;  sys
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;整体以数组打印:sys.argv&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;参数个数：len(sys.argv)&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;脚本名：sys.argv[0]&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;第一个参数：sys.argv[1]&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;如 Python3 ww.py x1 x2 x3&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(sys.argv) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;输出：['ww.py', 'x1', 'x2', 'x3']&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(len(sys.argv)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;输出：4&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(sys.argv[1])  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;输出：x1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;利用flush模拟进度条：&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485202/201902/1485202-20190223174717957-9660916.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; sys,time
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(50&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     sys.stdout.write(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#-&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;标准输出&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;     sys.stdout.flush() &lt;span&gt;#&lt;/span&gt;&lt;span&gt;强制写出，不等待缓冲区满&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;     time.sleep(0.2) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;延时0.2s&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;其他：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(sys.version) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;得到Python的版本信息&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(sys.platform) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;返回操作系统的名称，win32&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(sys.exit(0)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;退出程序&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Import导入模块：&lt;/h2&gt;
&lt;p&gt;导入模块时会在当前路径下和环境变量（lib或者site-packages目录）里寻找&lt;/p&gt;
&lt;p&gt;简单的导入模块&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;import&lt;/strong&gt;&lt;strong&gt;的使用：&lt;/strong&gt;&lt;br/&gt;将模块解释并把内容赋值到一个变量中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;jmodel为为自定义文件模板&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; jmodel
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;一次性导入多个&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;import imodel,time&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;使用变量和方法时需要使用模块名&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(jmodel.jva)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;from...inport....&lt;/strong&gt;&lt;strong&gt;的使用:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;直接将内容复制到导入处，并执行一次&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;直接导入模块里的所有变量和方法&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;from jmodel import  *&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;指定导入某个变量或方法&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; jmodel &lt;span&gt;import&lt;/span&gt;&lt;span&gt;  jva
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;导入并重命名&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;from jmodel import  jva as mmjva&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;使用是直接写变量名&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(jva)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;__import__&lt;/strong&gt;&lt;strong&gt;的使用：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;import time #直接导入&lt;/span&gt;
time=&lt;span&gt;__import__&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;time&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;使用字符串做参数导入&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(time.time()) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;输出当前时间戳&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;列：本地模板引用：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485202/201902/1485202-20190223175422659-411254487.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;必须输出内容&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;---- this pydong/modelx ---------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;函数&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; modelxfun():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;***** *modelxfun to *****&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;导入时使用方法一：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; pydong &lt;span&gt;import&lt;/span&gt;&lt;span&gt; modelx as modeldong
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;调用函数&lt;/span&gt;
modeldong.modelxfun()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;导入使用方法二：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;此处的modeldong相当于pydong&lt;/span&gt;
modeldong=&lt;span&gt;__import__&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pydong.modelx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;调用函数&lt;/span&gt;
modeldong.modelx.modelxfun()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;导入使用方法三：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt;  importlib
modeldong&lt;/span&gt;=importlib.import_module(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pydong.modelx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;调用函数&lt;/span&gt;
modeldong.modelxfun()
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;包的引用：&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;导入包时会自动寻找到__init__.py，并执行&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1485202/201902/1485202-20190223175613688-1629506659.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;__init__.py:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;------- init  ---------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义变量&lt;/span&gt;
jva=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;112233&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;导入当前包下的其他模块，执行方法需加模块名&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; . &lt;span&gt;import&lt;/span&gt;  modelx
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;modelx.py&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义函数&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; modelfun():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;******  modelfun  *****&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;main.py&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;导入目录模块&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;输出：------- init  ---------&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; pydong
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(pydong.jva) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;输出：112233&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;执行模块modelx下的modelfun()方法&lt;/span&gt;
pydong.modelx.modelfun()
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Fri, 15 Mar 2019 15:27:00 +0000</pubDate>
<dc:creator>东小东</dc:creator>
<og:description>Sys模块： 获取Python有关的环境变量： 命令行传递参数 利用flush模拟进度条： 其他： Import导入模块： 导入模块时会在当前路径下和环境变量（lib或者site-packages目录</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dongxiaodong/p/10423600.html</dc:identifier>
</item>
<item>
<title>Django实战(一)-----用户登录与注册系统7（邮件确认） - 秦广王</title>
<link>http://www.cnblogs.com/jinyuanliu/p/10540083.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jinyuanliu/p/10540083.html</guid>
<description>&lt;p&gt;通常而言，我们在用户注册成功，实际登陆之前，会发送一封电子邮件到对方的注册邮箱中，表示欢迎。进一步的还可能要求用户点击邮件中的链接，进行注册确认。&lt;/p&gt;
&lt;p&gt;下面就让我们先看看如何在Django中发送邮件吧。&lt;/p&gt;
&lt;h2 id=&quot;django&quot;&gt;一、在Django中发送邮件&lt;/h2&gt;
&lt;p&gt;其实在Python中已经内置了一个smtp邮件发送模块，Django在此基础上进行了简单地封装。&lt;/p&gt;
&lt;p&gt;首先，我们需要在项目的settings文件中配置邮件发送参数，分别如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'
EMAIL_HOST = 'smtp.sina.com'
EMAIL_PORT = 25
EMAIL_HOST_USER = 'xxx@sina.com'
EMAIL_HOST_PASSWORD = 'xxxxxxxxxxx'
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;第一行指定发送邮件的后端模块，大多数情况下照抄！&lt;/li&gt;
&lt;li&gt;第二行，不用说，发送方的smtp服务器地址，建议使用新浪家的；&lt;/li&gt;
&lt;li&gt;第三行，smtp服务端口，默认为25；&lt;/li&gt;
&lt;li&gt;第四行，你在发送服务器的用户名；&lt;/li&gt;
&lt;li&gt;第五行，对应用户的密码。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;特别说明：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;某些邮件公司可能不开放smtp服务&lt;/li&gt;
&lt;li&gt;某些公司要求使用ssl安全机制&lt;/li&gt;
&lt;li&gt;某些smtp服务对主机名格式有要求&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这些都是前人踩过的坑。&lt;/p&gt;
&lt;p&gt;配置好了参数，就可以先测试一下邮件功能了。&lt;/p&gt;
&lt;p&gt;在项目根目录下新建一个&lt;code&gt;send_mail.py&lt;/code&gt;文件，然后写入下面的内容：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:csharp;collapse:true;;gutter:true;&quot;&gt;
import os
from django.core.mail import send_mail

os.environ['DJANGO_SETTINGS_MODULE'] = 'mysite.settings'

if __name__ == '__main__':

    send_mail(
        '来自www.cnblogs.com的测试邮件',
        '欢迎访问，这里是博客园，本站专注于Python和Django技术的分享！',
        '1129719492@qq.com',
        ['1129719492@qq.com'],
    )
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于send_mail方法，第一个参数是邮件主题subject；第二个参数是邮件具体内容；第三个参数是邮件发送方，需要和你settings中的一致；第四个参数是接受方的邮件地址列表。请按你自己实际情况修改发送方和接收方的邮箱地址。&lt;/p&gt;
&lt;p&gt;另外，由于我们是单独运行&lt;code&gt;send_mail.py&lt;/code&gt;文件，所以无法使用Django环境，需要通过os模块对环境变量进行设置，也就是：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
os.environ['DJANGO_SETTINGS_MODULE'] = 'mysite.settings'
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行&lt;code&gt;send_mail.py&lt;/code&gt;文件，注意不是运行Django服务器。然后到你的目的地邮箱查看邮件是否收到。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592208/201903/1592208-20190315214107351-2103273677.png&quot; alt=&quot;&quot; width=&quot;468&quot; height=&quot;130&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;html&quot;&gt;二、发送HTML格式的邮件&lt;/h2&gt;
&lt;p&gt;通常情况下，我们发送的邮件内容都是纯文本格式。但是很多情况下，我们需要发送带有HTML格式的内容，比如说超级链接。一般情况下，为了安全考虑，很多邮件服务提供商都会禁止使用HTML内容，幸运的是对于以&lt;code&gt;http&lt;/code&gt;和&lt;code&gt;https&lt;/code&gt;开头的链接还是可以点击的。&lt;/p&gt;
&lt;p&gt;下面是发送HTML格式的邮件例子。删除&lt;code&gt;send_mail.py&lt;/code&gt;文件内原来的所有内容，添加下面的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:csharp;collapse:true;;gutter:true;&quot;&gt;
import os
from django.core.mail import EmailMultiAlternatives

os.environ['DJANGO_SETTINGS_MODULE'] = 'mysite.settings'

if __name__ == '__main__':

    subject, from_email, to = '来自www.cnblogs.com的测试邮件', '1129719492@qq.com', '1129719492@qq.com'
    text_content = '欢迎访问www.cnblogs.com，这里是刘江的博客和教程站点，专注于Python和Django技术的分享！'
    html_content = '&amp;lt;p&amp;gt;欢迎访问&amp;lt;a href=&quot;http://www.cnblogs.com&quot; target=blank&amp;gt;www.cnblogs.com&amp;lt;/a&amp;gt;，这里是博客园，专注于Python和Django技术的分享！&amp;lt;/p&amp;gt;'
    msg = EmailMultiAlternatives(subject, text_content, from_email, [to])
    msg.attach_alternative(html_content, &quot;text/html&quot;)
    msg.send()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中的&lt;code&gt;text_content&lt;/code&gt;是用于当HTML内容无效时的替代txt文本。&lt;/p&gt;
&lt;p&gt;打开测试用的接收邮箱，可以看到链接能够正常点击，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592208/201903/1592208-20190315214440003-2138602720.png&quot; alt=&quot;&quot; width=&quot;520&quot; height=&quot;149&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个&lt;code&gt;send_mail.py&lt;/code&gt;文件只是一个测试脚本，可以从项目里删除。&lt;/p&gt;
&lt;h2 id=&quot;_1&quot;&gt;三、 创建邮件确认模型&lt;/h2&gt;
&lt;p&gt;既然要区分通过和未通过邮件确认的用户，那么必须给用户添加一个是否进行过邮件确认的属性。&lt;/p&gt;
&lt;p&gt;另外，我们要创建一张新表，用于保存用户的确认码以及注册提交的时间。&lt;/p&gt;
&lt;p&gt;全新、完整的&lt;code&gt;/login/models.py&lt;/code&gt;文件如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;44&quot;&gt;
&lt;pre class=&quot;brush:csharp;collapse:true;;gutter:true;&quot;&gt;
from django.db import models

# Create your models here.

class User(models.Model):

    gender = (
        ('male', &quot;男&quot;),
        ('female', &quot;女&quot;),
    )

    name = models.CharField(max_length=128, unique=True)
    password = models.CharField(max_length=256)
    email = models.EmailField(unique=True)
    sex = models.CharField(max_length=32, choices=gender, default=&quot;男&quot;)
    c_time = models.DateTimeField(auto_now_add=True)
    has_confirmed = models.BooleanField(default=False)

    def __str__(self):
        return self.name

    class Meta:
        ordering = [&quot;-c_time&quot;]
        verbose_name = &quot;用户&quot;
        verbose_name_plural = &quot;用户&quot;


class ConfirmString(models.Model):
    code = models.CharField(max_length=256)
    user = models.OneToOneField('User',on_delete=models.CASCADE,)
    c_time = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return self.user.name + &quot;:   &quot; + self.code

    class Meta:

        ordering = [&quot;-c_time&quot;]
        verbose_name = &quot;确认码&quot;
        verbose_name_plural = &quot;确认码&quot;　
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;User模型新增了&lt;code&gt;has_confirmed&lt;/code&gt;字段，这是个布尔值，默认为False，也就是未进行邮件注册；&lt;/li&gt;
&lt;li&gt;ConfirmString模型保存了用户和注册码之间的关系，一对一的形式；&lt;/li&gt;
&lt;li&gt;code字段是哈希后的注册码；&lt;/li&gt;
&lt;li&gt;user是关联的一对一用户；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;c_time&lt;/code&gt;是注册的提交时间。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里有个问题可以讨论一下：是否需要创建ConfirmString新表，可否都放在User表里？我认为如果全都放在User中，不利于管理，查询速度慢，创建新表有利于区分已确认和未确认的用户。最终的选择可以根据你的实际情况具体分析。&lt;/p&gt;
&lt;p&gt;模型修改和创建完毕，需要执行migrate命令，一定不要忘了。&lt;/p&gt;
&lt;p&gt;顺便修改一下admin.py文件，方便我们在后台修改和观察数据。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;collapse:true;;gutter:true;&quot;&gt;
# login/admin.py

from django.contrib import admin

# Register your models here.

from . import models

admin.site.register(models.User)
admin.site.register(models.ConfirmString)
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;_2&quot;&gt;四、修改视图&lt;/h2&gt;
&lt;p&gt;首先，要修改我们的&lt;code&gt;register()&lt;/code&gt;视图的逻辑：&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;47&quot;&gt;
&lt;pre class=&quot;brush:csharp;collapse:true;;gutter:true;&quot;&gt;
def register(request):
    if request.session.get('is_login', None):
        # 登录状态不允许注册。你可以修改这条原则！
        return redirect(&quot;/index/&quot;)
    if request.method == &quot;POST&quot;:
        register_form = forms.RegisterForm(request.POST)
        message = &quot;请检查填写的内容！&quot;
        if register_form.is_valid():  # 获取数据
            username = register_form.cleaned_data['username']
            password1 = register_form.cleaned_data['password1']
            password2 = register_form.cleaned_data['password2']
            email = register_form.cleaned_data['email']
            sex = register_form.cleaned_data['sex']
            if password1 != password2:  # 判断两次密码是否相同
                message = &quot;两次输入的密码不同！&quot;
                return render(request, 'login/register.html', locals())
            else:
                same_name_user = models.User.objects.filter(name=username)
                if same_name_user:  # 用户名唯一
                    message = '用户已经存在，请重新选择用户名！'
                    return render(request, 'login/register.html', locals())
                same_email_user = models.User.objects.filter(email=email)
                if same_email_user:  # 邮箱地址唯一
                    message = '该邮箱地址已被注册，请使用别的邮箱！'
                    return render(request, 'login/register.html', locals())

                # 当一切都OK的情况下，创建新用户

                new_user = models.User()
                new_user.name = username
                new_user.password = hash_code(password1)  # 使用加密密码
                new_user.email = email
                new_user.sex = sex
                new_user.save()

                code = make_confirm_string(new_user)
                send_email(email, code)

                message = '请前往注册邮箱，进行邮件确认！'
                return render(request, 'login/confirm.html', locals())  # 跳转到等待邮件确认页面。
    register_form = forms.RegisterForm()
    return render(request, 'login/register.html', locals())
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;关键是多了下面两行：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
code = make_confirm_string(new_user)
send_email(email, code)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;make_confirm_string()&lt;/code&gt;是创建确认码对象的方法，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:csharp;collapse:true;;gutter:true;&quot;&gt;
def make_confirm_string(user):
    now = datetime.datetime.now().strftime(&quot;%Y-%m-%d %H:%M:%S&quot;)
    code = hash_code(user.name, now)
    models.ConfirmString.objects.create(code=code, user=user,)
    return code
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在文件顶部要先导入&lt;code&gt;datetime&lt;/code&gt;模块。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;make_confirm_string()&lt;/code&gt;方法接收一个用户对象作为参数。首先利用datetime模块生成一个当前时间的字符串now，再调用我们前面编写的&lt;code&gt;hash_code()&lt;/code&gt;方法以用户名为基础，now为‘盐’，生成一个独一无二的哈希值，再调用ConfirmString模型的create()方法，生成并保存一个确认码对象。最后返回这个哈希值。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;send_email(email, code)&lt;/code&gt;方法接收两个参数，分别是注册的邮箱和前面生成的哈希值，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;brush:csharp;collapse:true;;gutter:true;&quot;&gt;
def send_email(email, code):

    from django.core.mail import EmailMultiAlternatives

    subject = '来自www.cnblogs.com的注册确认邮件'

    text_content = '''感谢注册www.cnblogs.com，专注于Python和Django技术的分享！\
                    如果你看到这条消息，说明你的邮箱服务器不提供HTML链接功能，请联系管理员！'''

    html_content = '''
                    &amp;lt;p&amp;gt;感谢注册&amp;lt;a href=&quot;http://{}/confirm/?code={}&quot; target=blank&amp;gt;www.cnblogs.com&amp;lt;/a&amp;gt;，\
                    专注于Python和Django技术的分享！&amp;lt;/p&amp;gt;
                    &amp;lt;p&amp;gt;请点击站点链接完成注册确认！&amp;lt;/p&amp;gt;
                    &amp;lt;p&amp;gt;此链接有效期为{}天！&amp;lt;/p&amp;gt;
                    '''.format('127.0.0.1:8000', code, settings.CONFIRM_DAYS)

    msg = EmailMultiAlternatives(subject, text_content, settings.EMAIL_HOST_USER, [email])
    msg.attach_alternative(html_content, &quot;text/html&quot;)
    msg.send()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;首先我们需要导入settings配置文件&lt;code&gt;from django.conf import settings&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;邮件内容中的所有字符串都可以根据你的实际情况进行修改。其中关键在于&lt;code&gt;&amp;lt;a href=''&amp;gt;&lt;/code&gt;中链接地址的格式，我这里使用了硬编码的'127.0.0.1:8000'，请酌情修改，url里的参数名为&lt;code&gt;code&lt;/code&gt;，它保存了关键的注册确认码，最后的有效期天数为设置在settings中的&lt;code&gt;CONFIRM_DAYS&lt;/code&gt;。所有的这些都是可以定制的！&lt;/p&gt;
&lt;p&gt;下面是邮件相关的settings配置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;collapse:true;;gutter:true;&quot;&gt;
# 邮件配置
EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'
EMAIL_HOST = 'smtp.sina.com'
EMAIL_PORT = 25
EMAIL_HOST_USER = 'xxx@sina.com'
EMAIL_HOST_PASSWORD = 'xxxxxx'

# 注册有效期天数
CONFIRM_DAYS = 7
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;_3&quot;&gt;五、处理邮件确认请求&lt;/h2&gt;
&lt;p&gt;首先，在根目录的&lt;code&gt;urls.py&lt;/code&gt;中添加一条url：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
url(r'^confirm/$', views.user_confirm),
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其次，在&lt;code&gt;login/views.py&lt;/code&gt;中添加一个&lt;code&gt;user_confirm&lt;/code&gt;视图。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;brush:csharp;collapse:true;;gutter:true;&quot;&gt;
def user_confirm(request):
    code = request.GET.get('code', None)
    message = ''
    try:
        confirm = models.ConfirmString.objects.get(code=code)
    except:
        message = '无效的确认请求!'
        return render(request, 'login/confirm.html', locals())

    c_time = confirm.c_time
    now = datetime.datetime.now()
    if now &amp;gt; c_time + datetime.timedelta(settings.CONFIRM_DAYS):
        confirm.user.delete()
        message = '您的邮件已经过期！请重新注册!'
        return render(request, 'login/confirm.html', locals())
    else:
        confirm.user.has_confirmed = True
        confirm.user.save()
        confirm.delete()
        message = '感谢确认，请使用账户登录！'
        return render(request, 'login/confirm.html', locals())
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通过&lt;code&gt;request.GET.get('code', None)&lt;/code&gt;从请求的url地址中获取确认码;&lt;/li&gt;
&lt;li&gt;先去数据库内查询是否有对应的确认码;&lt;/li&gt;
&lt;li&gt;如果没有，返回&lt;code&gt;confirm.html&lt;/code&gt;页面，并提示;&lt;/li&gt;
&lt;li&gt;如果有，获取注册的时间&lt;code&gt;c_time&lt;/code&gt;，加上设置的过期天数，这里是7天，然后与现在时间点进行对比；&lt;/li&gt;
&lt;li&gt;如果时间已经超期，删除注册的用户，同时注册码也会一并删除，然后返回&lt;code&gt;confirm.html&lt;/code&gt;页面，并提示;&lt;/li&gt;
&lt;li&gt;如果未超期，修改用户的&lt;code&gt;has_confirmed&lt;/code&gt;字段为True，并保存，表示通过确认了。然后删除注册码，但不删除用户本身。最后返回&lt;code&gt;confirm.html&lt;/code&gt;页面，并提示。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里需要一个&lt;code&gt;confirm.html&lt;/code&gt;页面，我们将它创建在&lt;code&gt;/login/templates/login/&lt;/code&gt;下面：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;collapse:true;;gutter:true;&quot;&gt;
{% extends 'base.html' %}
{% block title %}注册确认{% endblock %}
{% block content %}
    &amp;lt;div class=&quot;row&quot;&amp;gt;
        &amp;lt;h1 class=&quot;text-center&quot;&amp;gt;{{ message }}&amp;lt;/h1&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;script&amp;gt;
        window.setTimeout(&quot;window.location='/login/'&quot;,2000);
    &amp;lt;/script&amp;gt;
{% endblock %}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;页面中通过JS代码，设置2秒后自动跳转到登录页面。&lt;/p&gt;
&lt;h2 id=&quot;_4&quot;&gt;六、修改登录规则&lt;/h2&gt;
&lt;p&gt;既然未进行邮件确认的用户不能登录，那么我们就必须修改登录规则，如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;brush:csharp;collapse:true;;gutter:true;&quot;&gt;
def login(request):
    if request.session.get('is_login', None):
        return redirect(&quot;/index/&quot;)
    if request.method == &quot;POST&quot;:
        login_form = forms.UserForm(request.POST)
        message = &quot;请检查填写的内容！&quot;
        if login_form.is_valid():
            username = login_form.cleaned_data['username']
            password = login_form.cleaned_data['password']
            try:
                user = models.User.objects.get(name=username)
                if not user.has_confirmed:
                    message = &quot;该用户还未通过邮件确认！&quot;
                    return render(request, 'login/login.html', locals())
                if user.password == hash_code(password):  # 哈希值和数据库内的值进行比对
                    request.session['is_login'] = True
                    request.session['user_id'] = user.id
                    request.session['user_name'] = user.name
                    return redirect('/index/')
                else:
                    message = &quot;密码不正确！&quot;
            except:
                message = &quot;用户不存在！&quot;
        return render(request, 'login/login.html', locals())

    login_form = forms.UserForm()
    return render(request, 'login/login.html', locals())
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;关键是下面的部分：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;collapse:true;;gutter:true;&quot;&gt;
if not user.has_confirmed:
    message = &quot;该用户还未通过邮件确认！&quot;
    return render(request, 'login/login.html', locals())
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;_5&quot;&gt;七、功能展示&lt;/h2&gt;
&lt;p&gt;首先，通过admin后台删除原来所有的用户。&lt;/p&gt;
&lt;p&gt;进入注册页面，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592208/201903/1592208-20190315224019360-611654865.png&quot; alt=&quot;&quot; width=&quot;422&quot; height=&quot;417&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击提交后，跳转到提示信息页面，2秒后再跳转到登录页面。&lt;/p&gt;
&lt;p&gt;进入admin后台，查看刚才建立的用户，可以看到其处于未确认状态，尝试登录也不通过：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1592208/201903/1592208-20190315225356403-138135277.png&quot; alt=&quot;&quot; width=&quot;357&quot; height=&quot;92&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592208/201903/1592208-20190315225437147-1620011661.png&quot; alt=&quot;&quot; width=&quot;446&quot; height=&quot;266&quot;/&gt;&lt;/p&gt;
&lt;p&gt;进入你的测试邮箱，查看注册邮件：&lt;/p&gt;
&lt;p&gt;点击确认后再进来，ok了。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1592208/201903/1592208-20190315225604370-1096457839.png&quot; alt=&quot;&quot; width=&quot;520&quot; height=&quot;275&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 15 Mar 2019 14:57:00 +0000</pubDate>
<dc:creator>秦广王</dc:creator>
<og:description>通常而言，我们在用户注册成功，实际登陆之前，会发送一封电子邮件到对方的注册邮箱中，表示欢迎。进一步的还可能要求用户点击邮件中的链接，进行注册确认。 下面就让我们先看看如何在Django中发送邮件吧。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jinyuanliu/p/10540083.html</dc:identifier>
</item>
<item>
<title>至曾经自学编程的十个月 - zhang_derek</title>
<link>http://www.cnblogs.com/derek1184405959/p/10540060.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/derek1184405959/p/10540060.html</guid>
<description>&lt;p&gt;今天星期五，下班路上没事就进自己的博客园逛了一下，发现半年没更新了。看着之前写的博客，感慨万千！&lt;/p&gt;
&lt;p&gt;很多通过我博客加我好友的人都会有这么一段聊天记录：&lt;/p&gt;
&lt;p&gt;xxx：“你是计算机专业的吗，你现在在做python开发工程师吗。”&lt;br/&gt;我：“我是机械专业，工作也跟编程毫不相干，学编程完全就是自学。”&lt;br/&gt;xxx：“自学都能学成这样，好厉害”。&lt;br/&gt;我：“没什么”&lt;br/&gt;上面的对话就当个引子，暂且放一边，先讲讲我学编程的经历吧（2017-10～2018-07）。&lt;/p&gt;
&lt;p&gt;我是一个大专生，90后，毕业了n多年，在A公司做B工作。稳定轻松，五天八小时，收入也过得去。因为做B工作也有三年多经验了，上班基本没有太大压力，每天朝九晚六，两点一线，好不自在。下班了看看电视，打打王者，周末了和朋友出去吃吃饭，看看电影，偶尔还会旅游。&lt;/p&gt;
&lt;p&gt;时间久了，开始讨厌这种无所事事的生活了？我还年轻，就这样每天得过且过吗？于是我开始给自己找麻烦了，利用业余时间自学编程。&lt;/p&gt;
&lt;p&gt;百度了很多，自学学什么语言好，现在什么语言最流行，最终决定python。在网上找了xxx的培训视频开始学习，于是走上了十个月的不归路。你永远不知道一个学机械的去自学编程有多难，除非你自己去尝试。我把我自学编程的历程分为四个阶段吧。&lt;/p&gt;
&lt;p&gt;一、放弃&lt;br/&gt;决定学编程的时候是九月底，计划国庆放假在家开始学。首先装环境，费了大半天时间，装好之后终于可以敲代码了。当屏幕出现：“hello world”的时候，别提多有成就感了。于是跟着视频往后面学，if,for,while,数据类型…。40分钟的视频学了两个小时，代码都是照着敲甚至直接复制，有的代码是什么意思都不懂，也没人问，只看到结果对就很高兴了。也许是学习新东西的初始新鲜感吧，就这样坚持了两三天。后面学到函数、面向对象那里之后，彻底蒙圈了，完全听不懂，连视频里面的代码实例也懒得跟着敲。开始怀疑自学是不可能学进去的。然后去他的，把教学视频一关，该干嘛干嘛去了。就这样一晃大半个月过去了，中间没有一天学习过编程。&lt;/p&gt;
&lt;p&gt;二、开始、放弃、开始、放弃…&lt;br/&gt;差不多到了十月月底的时候，某一天闲着无聊，又想起了学编程。于是在qq里面加了很多学python的编程群，想请教他们，正巧碰到群友C，也是自学编程的（那时候C通过自学已经学的很不错了），C跟我说了很多鼓励的话，使我信心大增。&lt;/p&gt;
&lt;p&gt;开始学吧，这次是看书（Python编程基础）加视频，果然看书再看视频效果比较好，起码能大概听得懂。就这样到了十一月中旬的样子把python基础部分的视频看完了。&lt;/p&gt;
&lt;p&gt;按照视频学习的进度，后面该到学习前端了。好吧，这又是一个全新的语言。先学html，能听懂。css大概懂，js，jq…跟不上。真烦，要学的东西那么多。于是把前端先跳过，学django项目部分去了，这个也一样跟不上。现实就是这么残酷，我越来越觉得自己不适合学编程了。中间又有半个月没摸过编程了。&lt;/p&gt;
&lt;p&gt;三、重新开始&lt;br/&gt;快到十二月中旬，这时候差不多已经自学了两个半月吧。有一天，看到qq消息，是群友C发的：&lt;br/&gt;C：“你编程自学的怎么样了”。&lt;br/&gt;我：“我觉得我不适合，放弃了”。&lt;br/&gt;C：此处省略两百字（一大堆的话）&lt;/p&gt;
&lt;p&gt;“自己真的足够努力吗？真的全力以赴了吗？”我开始反省，想一想前面学习的时候确实没有去认真的对待，敷衍了事，走马观花。我决定重新学，学完之后并写好博客。十二月中下旬到一月下旬这之间学的还算可以，主要是把前面所有学的重新再一遍，并写上博客。&lt;/p&gt;
&lt;p&gt;四、疯狂&lt;/p&gt;
&lt;p&gt;到了二月份，我开始进入了疯狂学习编程阶段。用疯狂一点都不夸张，你可以通过看二月份到六七月份的博客更新频率就可以看得出来。说下这段期间的概况吧：&lt;/p&gt;
&lt;p&gt;1.这几个月期间我最多只有三天没学习编程。&lt;br/&gt;2.平时每天晚上八点开始学，最少学到十二点。经常是到零点之后，最晚学到凌晨三点，第二天还要上班…&lt;br/&gt;3.周末从下午两点学到晚上零点，或者更晚，除去吃饭洗澡都是在学习。&lt;br/&gt;4.下班回家看视频，看完后写博客。上班的时候看电子书版编程书，整理博客，看别人的博客，看官方文档等等。&lt;br/&gt;5.看完了xxx培训班的整套视频，除了一两个项目没跟着做。看完了慕课网上大多数python教学视频，看完了网易云课堂上的几套视频。&lt;br/&gt;6.写了将近两百篇博客，建了一个学习群。&lt;/p&gt;
&lt;p&gt;五、不能说用放弃吧，我也不知道用什么词形容好&lt;/p&gt;
&lt;p&gt;有人会问为什么我后来不学编程了呢？&lt;br/&gt;1.我本来就是自学的，我的工作不是这方面。&lt;br/&gt;2.最主要的原因：&lt;strong&gt;我已经很满足了，最起码对自己交出了一个完美答卷（我不知道自己现在是什么编程水平，也不重要，对于我自己，我觉得够了）。&lt;/strong&gt;&lt;br/&gt;3.经过几个月的疯狂学习，身体也需要修养了。多花点时间去陪陪家人朋友&lt;br/&gt;4.当初确实也想过去做编程行业，投了简历发现并不可能。这个也不太重要，我觉得编程当成兴趣还是挺好的。当成工作挺累的，时时刻刻需要学习，家人第一。&lt;/p&gt;
&lt;h2 id=&quot;目标&quot;&gt;2019目标&lt;/h2&gt;
&lt;p&gt;今年我又给自己定了目标了。&lt;/p&gt;
&lt;p&gt;1.一个星期读一两本书，一年读80本书左右。&lt;br/&gt;2.读完每本书后写读书笔记（写在简书上面），不限字数，不限格式，想到什么就写什么，总之读完后有记录。&lt;br/&gt;3.每天背40个单词，一天都不能间断。&lt;/p&gt;
&lt;p&gt;我的座右铭：You got a dream, you gotta protect it. People can't do something themselves,they wanna tell you you can't do it.If you want something, go get it.&lt;/p&gt;
</description>
<pubDate>Fri, 15 Mar 2019 14:52:00 +0000</pubDate>
<dc:creator>zhang_derek</dc:creator>
<og:description>今天星期五，下班路上没事就进自己的博客园逛了一下，发现半年没更新了。看着之前写的博客，感慨万千！ 很多通过我博客加我好友的人都会有这么一段聊天记录： xxx：“你是计算机专业的吗，你现在在做pytho</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/derek1184405959/p/10540060.html</dc:identifier>
</item>
<item>
<title>开源WAF（mod_security）的搭建和分析 - yuleitest</title>
<link>http://www.cnblogs.com/yuleitest/p/10539998.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuleitest/p/10539998.html</guid>
<description>&lt;h4&gt;&lt;span&gt;背景&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;最近需要测试关于waf的工具，要知道waf是怎么回事，必须搭建waf环境，同时才能看懂关于绕过waf的一些技术。&lt;/p&gt;
&lt;p&gt;OWASP ModSecurity核心规则集（CRS）是一组用于ModSecurity或兼容的Web应用程序防火墙的通用攻击检测规则。CRS旨在保护Web应用程序免受各种攻击，包括OWASP十大攻击，并提供最少的虚假警报。&lt;/p&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/SpiderLabs/owasp-modsecurity-crs&quot;&gt;https://github.com/SpiderLabs/owasp-modsecurity-crs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;因为经常使用kali,因此环境全是在kali上面搭建，也不会再重新下载别的系统。&lt;/p&gt;
&lt;p&gt;版本&lt;/p&gt;
&lt;p&gt;~# cat /proc/version&lt;/p&gt;
&lt;p&gt;Linux version 4.19.0-kali3-amd64 (devel@kali.org) (gcc version 8.2.0 (Debian 8.2.0-16)) #1 SMP Debian 4.19.20-1kali1 (2019-02-14)&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;安装modsecurity&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;apt-get install modsecurity-crs&lt;/p&gt;
&lt;p&gt;它会自动加载相关组件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/741432/201903/741432-20190315233017023-610589858.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;配置modsecurity&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;修改/etc/modsecurity/下的modsecurity.conf&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span&gt;mv /etc/modsecurity/modsecurity.conf-recommended modsecurity.conf
&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span&gt;将文件中
&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span&gt;SecRuleEngine DetectionOnly修改为SecRuleEngine On&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/741432/201903/741432-20190315233017931-320290475.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;测试SQL注入&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;在上面的配置启用之前也就是默认是仅检测（&lt;span&gt;DetectionOnly&lt;/span&gt;），我们先来看看效果&lt;/p&gt;
&lt;p&gt;使用DVWA中sql注入测试即可，可看到存在sql注入&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/741432/201903/741432-20190315233018662-945956713.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;启用&lt;span&gt;安全规则引擎SecRuleEngine （SecRuleEngine On）之后，需重启apache2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/741432/201903/741432-20190315233019226-1498109022.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;显示403 Forbidden错误，可见waf已经生效。&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;工作原理&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;我们回过头分析下它的一个配置&lt;/p&gt;
&lt;p&gt;1.首先我们安装了modsecurity-crs，它会自动安装apache2的库&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/741432/201903/741432-20190315233019875-1991151737.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;跟进这个文件，我们看到它包含了刚才我们配置的文件，并且和它自己的安装目录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/741432/201903/741432-20190315233020549-1130260838.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;跟进安装目录，又包含了owasp-crs.load这个文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/741432/201903/741432-20190315233021042-74442556.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;继续跟进这个owasp-crs.load文件，它包含了自己目录下rules下的所有文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/741432/201903/741432-20190315233021616-2126681952.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;规则文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/741432/201903/741432-20190315233022288-1834061350.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由此可以看出： 规则文件一共有如下几类&lt;/p&gt;
&lt;p&gt;1. request 请求&lt;/p&gt;
&lt;p&gt;2. response 响应&lt;/p&gt;
&lt;p&gt;3.错误 有iis的 java的php的&lt;/p&gt;
&lt;p&gt;4.扫描类 sannner&lt;/p&gt;
&lt;p&gt;5.unix-shell类，也就是木马类&lt;/p&gt;
&lt;p&gt;我们重新梳理下刚才的逻辑，也就是调用过程：&lt;/p&gt;
&lt;p&gt;首选我们发了一个sql注入的请求给apache2 ，apach2发现库中又引用security2.conf这个配置，于是调用所有与mod-security相关的规则集。最后经过一些列处理，返回了403错误，这个mod-security就这样被调用起来了。&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;规则分析&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;我们打开apache2的日志目录，在/var/log/apach2下&lt;/p&gt;
&lt;p&gt;发现存在一个mod-security的日志，这个就是waf审计的日志，它记录了了所有攻击日志&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/741432/201903/741432-20190315233023366-1050196708.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们发起一个sql注入探测攻击之后，本应该返回给我们一个You have an error in your SQL syntax; check the manual tha…….等等的sql查询错误的，为什么返回给我们一个403呢&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/741432/201903/741432-20190315233024439-1387494080.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们跟进下面的Pattern match，意思就是，它匹配到了如下规则目录中的一些信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/741432/201903/741432-20190315233025236-1262712535.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以看到好多Pattern match，打开其中一个response的规则&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/741432/201903/741432-20190315233026199-2144555973.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;根据显示第373行，我们打开该规则文件中的373行&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/741432/201903/741432-20190315233027179-1641411843.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可见，正是匹配到了该响应，它是由多个分隔符形成的，也就是它匹配到了规则其中的一个分隔符中的数据，所以才认为这是一个攻击行为。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/741432/201903/741432-20190315233027783-877288941.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看了几个规则文件和命名之后，至此，我们大概知道了它的一个检测过程，至少分为以下3步&lt;/p&gt;
&lt;p&gt;1.它首先会去检测请求头Request-Headers&lt;/p&gt;
&lt;p&gt;2.它会去检测请求Request&lt;/p&gt;
&lt;p&gt;3.检测响应response&lt;/p&gt;
&lt;p&gt;如果以上三步都没有问题，那么会认为这是一个正常访问，而非攻击，为了消除误报，它会逐个步骤匹配相关规则，达到一定条件那么它将会返回403错误。至于这个条件是什么以后再去查找相关资料深入研究。&lt;/p&gt;
</description>
<pubDate>Fri, 15 Mar 2019 14:37:00 +0000</pubDate>
<dc:creator>yuleitest</dc:creator>
<og:description>背景 最近需要测试关于waf的工具，要知道waf是怎么回事，必须搭建waf环境，同时才能看懂关于绕过waf的一些技术。 OWASP ModSecurity核心规则集（CRS）是一组用于ModSecur</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuleitest/p/10539998.html</dc:identifier>
</item>
<item>
<title>一篇入门 — Gatling 性能测试手册 - 旻天clock</title>
<link>http://www.cnblogs.com/clockq/p/10539974.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/clockq/p/10539974.html</guid>
<description>&lt;h2 id=&quot;介绍&quot;&gt;介绍&lt;/h2&gt;
&lt;p&gt;本篇博客，旨在记录视频学习的要点，所以格式随意， 方便本人日后自考和回忆，有兴趣的朋友可以评论讨论。&lt;br/&gt;原文地址：&lt;a href=&quot;https://www.cnblogs.com/clockq/p/10539974.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/clockq/p/10539974.html&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;性能测试时什么&quot;&gt;1.1 性能测试时什么？&lt;/h2&gt;
&lt;p&gt;==性能测试时通过自动化的测试工具模拟多种&lt;strong&gt;正常&lt;/strong&gt;、&lt;strong&gt;峰值&lt;/strong&gt;、以及&lt;strong&gt;异常负载&lt;/strong&gt;条件，以此来对系统的各项性能指标进行评测。==&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;性能测试 = 负载测试 + 压力测试&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;通过负载测试，确定在各种工作负载下系统的性能，目的是测试系统的负载逐渐增加的情况下，系统的各项性能指标的变化情况。&lt;/li&gt;
&lt;li&gt;通过压力测试，确定一个系统的瓶颈或者不能接受的性能点，来获得系统所能提供的最大服务级别。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;性能测试的目的&quot;&gt;1.2 ==性能测试的目的==&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;评估系统的能力&lt;/li&gt;
&lt;li&gt;识别体系中的弱点&lt;/li&gt;
&lt;li&gt;系统调优&lt;/li&gt;
&lt;li&gt;检查软件中的问题&lt;/li&gt;
&lt;li&gt;验证系统稳定性&lt;/li&gt;
&lt;li&gt;验证系统可靠性&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;性能测试的常见观察指标&quot;&gt;1.3 性能测试的常见观察指标&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Avg Rps&lt;/strong&gt;: 平均每秒响应次数 = 总请求时间 / 秒数&lt;/li&gt;
&lt;li&gt;Avg time to last byte per terstion(mstes): 平均每秒业务脚本迭代次数&lt;/li&gt;
&lt;li&gt;Successful Rounds: 成功的请求&lt;/li&gt;
&lt;li&gt;Failed Hits: 失败的单击次数&lt;/li&gt;
&lt;li&gt;Hits Per Second: 每秒单击次数&lt;/li&gt;
&lt;li&gt;Successful Hits Per Second: 每秒成功的单击次数&lt;/li&gt;
&lt;li&gt;Failed Hist Per Second: 每秒失败的单击次数&lt;/li&gt;
&lt;li&gt;Attempted Connections: 尝试连接数&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Throughput&lt;/strong&gt;: 吞吐率&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;同时，对于服务端的CPU占有率，内存占有率，数据库连接池等也是需要观察的重点。&lt;/p&gt;
&lt;h2 id=&quot;性能测试的基本流程&quot;&gt;1.4 性能测试的基本流程&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;明确性能测试需求&lt;/li&gt;
&lt;li&gt;制定性能测试方案&lt;/li&gt;
&lt;li&gt;编写性能测试案例&lt;/li&gt;
&lt;li&gt;执行性能测试案例&lt;/li&gt;
&lt;li&gt;分析性能测试结果&lt;/li&gt;
&lt;li&gt;生成性能测试报告&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;安装gatling&quot;&gt;2.1 安装Gatling&lt;/h2&gt;
&lt;p&gt;获取安装包 &lt;a href=&quot;http://gatling.io.download/&quot; class=&quot;uri&quot;&gt;http://gatling.io.download/&lt;/a&gt;&lt;br/&gt;下载成功后解压即可 &lt;strong&gt;使用Gatling需要安装JDK&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;使用gatling&quot;&gt;2.2 使用Gatling&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;编写测试脚本（这块重点学习和讲解）或者使用自带的录制器（bin/recorder.sh)&lt;/li&gt;
&lt;li&gt;执行测试脚本(bin/gatling.sh)，在开启的窗口中选择要执行的脚本&lt;/li&gt;
&lt;li&gt;查看测试报告(报告默认在“result/”目录下)&lt;/li&gt;
&lt;li&gt;分析测试结果&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;导入依赖&quot;&gt;3.1 导入依赖&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;    &amp;lt;properties&amp;gt;
        &amp;lt;gatling.version&amp;gt;2.1.7&amp;lt;/gatling.version&amp;gt;
        &amp;lt;gatling-plugin.version&amp;gt;2.1.7&amp;lt;/gatling-plugin.version&amp;gt;
    &amp;lt;/properties&amp;gt;
    
    &amp;lt;!-- Gatling Module --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;io.gatling.highcharts&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;gatling-charts-highcharts&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;${gatling.version}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;导入插件&quot;&gt;3.2 导入插件&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;build&amp;gt;
    &amp;lt;sourceDirectory&amp;gt;src/test/scala&amp;lt;/sourceDirectory&amp;gt;
    &amp;lt;testSourceDirectory&amp;gt;src/test/scala&amp;lt;/testSourceDirectory&amp;gt;
    &amp;lt;plugins&amp;gt;
        &amp;lt;!-- Gatling Maven plugin that runs the load-simulation. --&amp;gt;
        &amp;lt;plugin&amp;gt;
            &amp;lt;groupId&amp;gt;io.gatling&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;gatling-maven-plugin&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${gatling-plugin.version}&amp;lt;/version&amp;gt;
            &amp;lt;configuration&amp;gt;
                &amp;lt;configFolder&amp;gt;src/test/resources&amp;lt;/configFolder&amp;gt;
                &amp;lt;dataFolder&amp;gt;src/test/resources/data&amp;lt;/dataFolder&amp;gt;
                &amp;lt;resultsFolder&amp;gt;target/gatling/results&amp;lt;/resultsFolder&amp;gt;
                &amp;lt;runMultipleSimulations&amp;gt;true&amp;lt;/runMultipleSimulations&amp;gt;
                &amp;lt;simulationsFolder&amp;gt;src/test/scala/com/pharbers/gatling&amp;lt;/simulationsFolder&amp;gt;

                &amp;lt;simulationClass&amp;gt;com.pharbers.gatling.scenario.getHome&amp;lt;/simulationClass&amp;gt;

                &amp;lt;!--    &amp;lt;noReports&amp;gt;false&amp;lt;/noReports&amp;gt; --&amp;gt;
                &amp;lt;!--   &amp;lt;reportsOnly&amp;gt;directoryName&amp;lt;/reportsOnly&amp;gt; --&amp;gt;
                &amp;lt;!--   &amp;lt;simulationClass&amp;gt;foo.Bar&amp;lt;/simulationClass&amp;gt; --&amp;gt;
                &amp;lt;!--   &amp;lt;jvmArgs&amp;gt; --&amp;gt;
                &amp;lt;!--     &amp;lt;jvmArg&amp;gt;-DmyExtraParam=foo&amp;lt;/jvmArg&amp;gt; --&amp;gt;
                &amp;lt;!--   &amp;lt;/jvmArgs&amp;gt; --&amp;gt;
                &amp;lt;!--    &amp;lt;fork&amp;gt;true&amp;lt;/fork&amp;gt; --&amp;gt;
                &amp;lt;!--    &amp;lt;propagateSystemProperties&amp;gt;true&amp;lt;/propagateSystemProperties&amp;gt; --&amp;gt;
                &amp;lt;!--   &amp;lt;failOnError&amp;gt;true&amp;lt;/failOnError&amp;gt; --&amp;gt;
            &amp;lt;/configuration&amp;gt;
        &amp;lt;/plugin&amp;gt;
    &amp;lt;/plugins&amp;gt;
&amp;lt;/build&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;编写脚本&quot;&gt;3.3 编写脚本&lt;/h2&gt;
&lt;p&gt;忽略&lt;br/&gt;注意： 脚本要写在 src/test/scala 下&lt;/p&gt;
&lt;h2 id=&quot;执行脚本&quot;&gt;3.4 执行脚本&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;mvn gatling:execute&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;分析报告&quot;&gt;3.5 分析报告&lt;/h2&gt;

&lt;p&gt;我们先以测试“博客园系统登录页”性能为例，讲解一次测试过程的几个步骤，和测试报告怎么分析。&lt;/p&gt;
&lt;h2 id=&quot;明确性能测试需求&quot;&gt;4.1 明确性能测试需求&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;好的开始是成功的一半&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;明确性能测试的需求是至关重要的，所以我们要先有一份测试需求实例&lt;/p&gt;
&lt;p&gt;测试需求名称： 博客园登录接口性能测试&lt;br/&gt;| 信息描述 | 描述内容 |&lt;br/&gt;| :--: | :--: |&lt;br/&gt;| 参与者 | 张三 |&lt;br/&gt;| 概述 | 测试博客园登录接口的最大并发量 |&lt;br/&gt;| 前置条件 | 博客园前端页面已经成功部署，并可以正常访问 |&lt;br/&gt;| 后置条件 | 无 |&lt;br/&gt;| 业务数据 | 测试登录账号 |&lt;br/&gt;| 不可测试原因 | 网络不可达 |&lt;br/&gt;| 流程规则 | 用户访问博客园登录页，滞留5s，之后调用登录接口 |&lt;br/&gt;| 业务规则 | 无 |&lt;br/&gt;| 页面规则 | 无 |&lt;br/&gt;| 特殊规则 | 无 |&lt;br/&gt;| 接口规则 | 无 |&lt;br/&gt;| 检查内容 | 检查当用户量达到多大时，会导致服务端阻塞，用户响应时间超过5s |&lt;/p&gt;
&lt;h2 id=&quot;编写性能测试案例&quot;&gt;4.2 编写性能测试案例&lt;/h2&gt;
&lt;p&gt;测试需求名称： 博客园登录接口性能测试&lt;br/&gt;| 测试步骤 | 步骤描述 | 预期结果 |&lt;br/&gt;| :--: | :--: | :--: |&lt;br/&gt;| 步骤 1 | 是否测试博客园登录接口最大并发量 | 确定性能测试登录接口的并发用户数量 |&lt;br/&gt;| 步骤 2 | 启动博客园的前端工程 | 前端工程启动成功 |&lt;br/&gt;| 步骤 3 | 准备性能测试脚本 | 性能测试脚本准备完成 |&lt;br/&gt;| 步骤 4 | 准备测试数据 | 无 |&lt;br/&gt;| 步骤 5 | 执行脚本，验证系统是否满足相关性能测试指标 平均响应时长&amp;lt;2s 95%响应时长&amp;lt;= 5s | 系统满足相关性能测试指标 |&lt;br/&gt;| 步骤 5 | 执行1小时压力测试 | 1. 系统满足相关性能测试指标 2. 1小时压力测试中脚本未报错 |&lt;/p&gt;
&lt;h2 id=&quot;执行性能测试案例&quot;&gt;4.3 执行性能测试案例&lt;/h2&gt;
&lt;p&gt;按照性能测试案例编写测试脚本&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.pharbers.gatling.base

import io.gatling.core.Predef._
import io.gatling.http.Predef._
import io.gatling.http.config.HttpProtocolBuilder

object phHttpProtocol {
    implicit val noneWhiteList: io.gatling.core.filter.WhiteList = WhiteList()
    implicit val noneBlackList: io.gatling.core.filter.BlackList = BlackList()
    implicit val staticBlackList: io.gatling.core.filter.BlackList = BlackList(&quot;&quot;&quot;.*\.js&quot;&quot;&quot;, &quot;&quot;&quot;.*\.css&quot;&quot;&quot;, &quot;&quot;&quot;.*\.gif&quot;&quot;&quot;, &quot;&quot;&quot;.*\.jpeg&quot;&quot;&quot;, &quot;&quot;&quot;.*\.jpg&quot;&quot;&quot;, &quot;&quot;&quot;.*\.ico&quot;&quot;&quot;, &quot;&quot;&quot;.*\.woff&quot;&quot;&quot;, &quot;&quot;&quot;.*\.(t|o)tf&quot;&quot;&quot;, &quot;&quot;&quot;.*\.png&quot;&quot;&quot;)
    implicit val staticWhiteList: io.gatling.core.filter.WhiteList = WhiteList(&quot;&quot;&quot;.*\.js&quot;&quot;&quot;, &quot;&quot;&quot;.*\.css&quot;&quot;&quot;, &quot;&quot;&quot;.*\.gif&quot;&quot;&quot;, &quot;&quot;&quot;.*\.jpeg&quot;&quot;&quot;, &quot;&quot;&quot;.*\.jpg&quot;&quot;&quot;, &quot;&quot;&quot;.*\.ico&quot;&quot;&quot;, &quot;&quot;&quot;.*\.woff&quot;&quot;&quot;, &quot;&quot;&quot;.*\.(t|o)tf&quot;&quot;&quot;, &quot;&quot;&quot;.*\.png&quot;&quot;&quot;)

    def apply(host: String)
             (implicit blackLst: io.gatling.core.filter.BlackList, whiteLst: io.gatling.core.filter.WhiteList): HttpProtocolBuilder = { http
                .baseURL(host)
                .inferHtmlResources(blackLst, whiteLst)
                .acceptHeader(&quot;application/json, text/javascript, */*; q=0.01&quot;)
                .acceptEncodingHeader(&quot;gzip, deflate&quot;)
                .acceptLanguageHeader(&quot;zh-CN,zh;q=0.9,zh-TW;q=0.8&quot;)
                .doNotTrackHeader(&quot;1&quot;)
                .userAgentHeader(&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.181 Safari/537.36&quot;)
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;package com.pharbers.gatling.base

object phHeaders {

    val headers_base = Map(
        &quot;Accept&quot; -&amp;gt; &quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8&quot;,
        &quot;Upgrade-Insecure-Requests&quot; -&amp;gt; &quot;1&quot;)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;package com.pharbers.gatling.scenario

import io.gatling.core.Predef._
import io.gatling.http.Predef._
import io.gatling.core.structure.ChainBuilder

import com.pharbers.gatling.base.phHeaders.headers_base

object getHome {
    val getHome: ChainBuilder = exec(http(&quot;home&quot;)
            .get(&quot;/&quot;)
            .headers(headers_base))
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;package com.pharbers.gatling.scenario

import io.gatling.core.Predef._
import io.gatling.http.Predef._
import io.gatling.core.structure.ChainBuilder

import com.pharbers.gatling.base.phHeaders.headers_json

object userLogin {
    val feeder = csv(&quot;loginUser.csv&quot;).random
    println(feeder)

    val login: ChainBuilder = exec(http(&quot;login&quot;)
            .get(&quot;/api/user/login&quot;)
            .headers(headers_json)
            .body(StringBody(&quot;&quot;&quot;{ &quot;condition&quot; :  { &quot;email&quot; : &quot;nhwa&quot;, &quot;password&quot; : &quot;nhwa&quot; } }&quot;&quot;&quot;)).asJSON)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;package com.pharbers.gatling.simulation

import io.gatling.core.Predef._
import scala.concurrent.duration._

import com.pharbers.gatling.scenario._
import com.pharbers.gatling.base.phHttpProtocol

class userLogin extends Simulation {
    import com.pharbers.gatling.base.phHttpProtocol.{noneBlackList, noneWhiteList}

    val httpProtocol = phHttpProtocol(&quot;http://192.168.100.141:9000&quot;)

    val scn = scenario(&quot;user_login&quot;)
        .exec(
            getHome.getHome
                    .pause(5 seconds),
            userLogin.login
                    .pause(60 seconds)
        )

    setUp(scn.inject(rampUsers(1000) over (3 seconds))).protocols(httpProtocol)

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;并执行上述脚本&lt;/p&gt;
&lt;h2 id=&quot;分析性能测试结果&quot;&gt;4.4 分析性能测试结果&lt;/h2&gt;
&lt;p&gt;看下图，可以看到67% + 8%的请求可以在1.2s内完全，同时在1000用户的并发测试下，会有用户请求不到资源，也就是加载失败。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;其实，这个地方，可以通过修改gatling.conf来改变表格的渲染区间，使结果更符合我们的测试要求&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/clockQ/FigureBed/blob/master/document/20180606/gatling%20global%20info.png?raw=true&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里，75th的总响应时间=1s，还是很快的，但95th的总响应时间&amp;gt;9s, 所以不符合我们的测试要求。&lt;br/&gt;&lt;img src=&quot;https://github.com/clockQ/FigureBed/blob/master/document/20180606/gatling%20statistics%20info.png?raw=true&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们使用递增的方式，在3s内逐渐增加用户并发量，并且用户会滞留5s + 60s,在下图中就得到了体现&lt;br/&gt;&lt;img src=&quot;https://github.com/clockQ/FigureBed/blob/master/document/20180606/gatling%20user%20along%20the%20Simulation.png?raw=true&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下图是本次测试，在每个时间点的请求情况，包含请求状态（成功，失败）和请求数量&lt;br/&gt;&lt;img src=&quot;https://github.com/clockQ/FigureBed/blob/master/document/20180606/gatling%20number%20of%20request%20per%20second.png?raw=true&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还有更多图表，就不一一展示了，我们主要就是查看前两个图表，以此判断服务器所能承受的压力。&lt;/p&gt;
&lt;p&gt;当然，如果需要考查更多标准，就需要查看其它图表，比如延迟分布图，负载分布图等等。。。。&lt;/p&gt;
&lt;h2 id=&quot;生成性能测试报告&quot;&gt;4.5 生成性能测试报告&lt;/h2&gt;
&lt;p&gt;一份合格的性能测试报告，至少应该包含如下内容:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;测试基本信息： 包含： 测试目的，报告目标读者，术语定义，参考资料&lt;/li&gt;
&lt;li&gt;测试环境描述： 包含： 服务器软硬件环境，网络环境，测试工具，测试人员&lt;/li&gt;
&lt;li&gt;性能测试案例执行分析: 需要详细描述每个测试案例的执行情况，以及对对应测试结果进行分析&lt;/li&gt;
&lt;li&gt;测试结果综合分析及建议：对本次性能测试做综合分析，并给出测试结论和改进建议&lt;/li&gt;
&lt;li&gt;测试经验总结&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;6&quot;&gt;

&lt;h2 id=&quot;测试信息&quot;&gt;测试信息&lt;/h2&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;测试人员&lt;/td&gt;
&lt;td&gt;齐钟昱&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;测试目的&lt;/td&gt;
&lt;td&gt;检查当用户量达到多大时，会导致服务端阻塞，用户响应时间超过5s&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;术语定义&lt;/td&gt;
&lt;td&gt;50th，安装递增排序后，排在50%的请求的信息&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;术语定义&lt;/td&gt;
&lt;td&gt;95th，安装递增排序后，排在95%的请求的信息&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;参考资料&lt;/td&gt;
&lt;td&gt;零成本实现Web性能测试[电子工业出版社]&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;测试环境&quot;&gt;测试环境&lt;/h2&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;服务器系统&lt;/td&gt;
&lt;td&gt;CentOS Linux release 7.4.1708 (Core)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;服务器集群数量&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;服务器内存（台）&lt;/td&gt;
&lt;td&gt;16G&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;服务器CPU核心数（台）&lt;/td&gt;
&lt;td&gt;12&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;服务器硬盘空间（台）&lt;/td&gt;
&lt;td&gt;256G SSD&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;JAVA版本&lt;/td&gt;
&lt;td&gt;1.8.121&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Scala版本&lt;/td&gt;
&lt;td&gt;2.11.8&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Play版本&lt;/td&gt;
&lt;td&gt;2.5.0-M2&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Redis版本&lt;/td&gt;
&lt;td&gt;4.0.1&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;MongoDB版本&lt;/td&gt;
&lt;td&gt;3.4.4&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Node.js&lt;/td&gt;
&lt;td&gt;8.11.2&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Ember.js&lt;/td&gt;
&lt;td&gt;2.18.2&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;网络环境&lt;/td&gt;
&lt;td&gt;公司局域网&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;测试工具&lt;/td&gt;
&lt;td&gt;Gatling 2.1.7&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;结果分析&quot;&gt;结果分析&lt;/h2&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;13.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;9&quot;&gt;&lt;td&gt;博客园系统登录页的最大访问量&lt;/td&gt;
&lt;td&gt;在当前环境下可以1000用户并发，不会造成用户请求失败&lt;/td&gt;
&lt;td&gt;在3s内逐渐提高并发量，当并发量在643时有三个资源请求失败，在并发量达到689时，有64个资源请求失败&lt;/td&gt;
&lt;td&gt;未通过，当前博客园系统登录页的最大访问量应小于643&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;6&quot;&gt;&lt;td&gt;博客园系统登录接口的最大并发量&lt;/td&gt;
&lt;td&gt;在当前环境下可以1000用户并发，不会造成用户请求失败&lt;/td&gt;
&lt;td&gt;在3s内逐渐提高并发量，当并发量达到1000时，请求资源仍全部成功&lt;/td&gt;
&lt;td&gt;通过&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;6&quot;&gt;&lt;td&gt;博客园登录页的响应时间&lt;/td&gt;
&lt;td&gt;在当前环境下用户平均响应时长&amp;lt;2s 95%响应时长&amp;lt;= 5s&lt;/td&gt;
&lt;td&gt;50th响应时间为1.6s，95th为22s&lt;/td&gt;
&lt;td&gt;未通过&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;6&quot;&gt;&lt;td&gt;博客园登录接口的响应时间&lt;/td&gt;
&lt;td&gt;在当前环境下用户平均响应时长&amp;lt;2s 95%响应时长&amp;lt;= 5s&lt;/td&gt;
&lt;td&gt;50th响应时间 &amp;lt; 1s，95th &amp;lt; 1s&lt;/td&gt;
&lt;td&gt;通过&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;测试总结&quot;&gt;测试总结&lt;/h2&gt;
&lt;p&gt;根据上述分析报告，本次性能测试为通过制定要求，博客园系统登录功能的最大并发量应小于643，为保持性能，建议并发数小于500&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;并发量控制&quot;&gt;5.1 并发量控制&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;atOnceUsers(100)&lt;/code&gt; 使用100并发量测试目标服务器&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rampUsers(100) over (10 seconds)&lt;/code&gt; 循序渐进的增大压力，在10s中内线性增加用户数达到最大压力100并发量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nothingFor(10 seconds)&lt;/code&gt; 等待10s&lt;/li&gt;
&lt;li&gt;&lt;code&gt;constantUsersPerSec(rate) during(duration)&lt;/code&gt; 在指定duration内，以固定频率注入用户，每秒注入rate个用户，默认固定间隔&lt;/li&gt;
&lt;li&gt;&lt;code&gt;constantUsersPerSec(rate) during(duration) randomized&lt;/code&gt; 与上面不同的是用户以随机间隔注入&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rampUsersPerSec(rate1) to (rate2) during(duration)&lt;/code&gt; 在指定duration内，以递增频率注入用户，每秒注入 rate1 ~ rate2 个用户&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;用户行为控制&quot;&gt;5.2 用户行为控制&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;.exec()&lt;/code&gt; 实际的用户行为&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.pause(20)&lt;/code&gt; 用户滞留20s，模拟用户思考或者浏览内容&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.pause(min: Duration, max: Duration)&lt;/code&gt; 用户随机滞留，滞留时间在min ~ max 之间&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;流程控制&quot;&gt;5.3 流程控制&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;repeat(time, counterName)&lt;/code&gt; 内置循环器&lt;/li&gt;
&lt;li&gt;&lt;code&gt;foreach(seq, elem, counterName)&lt;/code&gt; foreach循环器&lt;/li&gt;
&lt;li&gt;&lt;code&gt;csv(&quot;file&quot;).random&lt;/code&gt; 创建填充器&lt;/li&gt;
&lt;li&gt;&lt;code&gt;doIf(&quot;&quot;, &quot;&quot;)&lt;/code&gt; 判断语句&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Fri, 15 Mar 2019 14:31:00 +0000</pubDate>
<dc:creator>旻天clock</dc:creator>
<og:description>介绍 本篇博客，旨在记录视频学习的要点，所以格式随意， 方便本人日后自考和回忆，有兴趣的朋友可以评论讨论。 原文地址： 'https://www.cnblogs.com/clockq/p/105399</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/clockq/p/10539974.html</dc:identifier>
</item>
</channel>
</rss>