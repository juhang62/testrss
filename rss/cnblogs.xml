<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>机器学习——KMeans聚类，KMeans原理，参数详解 - Baby-Lily</title>
<link>http://www.cnblogs.com/baby-lily/p/10680617.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/baby-lily/p/10680617.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;0.聚类&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;聚类就是对大量的未知标注的数据集，按数据的内在相似性将数据集划分为多个类别，使类别内的数据相似度较大而类别间的数据相似度较小，聚类属于无监督的学习方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.内在相似性的度量&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;聚类是根据数据的内在的相似性进行的，那么我们应该怎么定义数据的内在的相似性呢？比较常见的方法是根据数据的相似度或者距离来定义的，比较常见的有：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;闵可夫斯基距离/欧式距离&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1636554/201904/1636554-20190409214154208-400803339.png&quot; alt=&quot;&quot; width=&quot;186&quot; height=&quot;60&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　上述距离公式中，当p=2时，就是欧式距离，当p=1时，就是绝对值的和，当p=正无穷时，这个距离变成了维度差最大的那个值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1636554/201904/1636554-20190409215345258-767533328.png&quot; alt=&quot;&quot; width=&quot;500&quot; height=&quot;175&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;杰卡德相似系数&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1636554/201904/1636554-20190409215511592-1817485801.png&quot; alt=&quot;&quot; width=&quot;182&quot; height=&quot;71&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;　一般是度量集合之间的相似性。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;余弦相似度&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1636554/201904/1636554-20190409215654709-513545051.png&quot; alt=&quot;&quot; width=&quot;125&quot; height=&quot;63&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;Pearson相似系数&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1636554/201904/1636554-20190409215826948-1536653766.png&quot; alt=&quot;&quot; width=&quot;417&quot; height=&quot;86&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　对于n维向量的夹角，根据余弦定理，可到：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1636554/201904/1636554-20190409220220406-2013527767.png&quot; alt=&quot;&quot; width=&quot;256&quot; height=&quot;87&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　又由相关系数的计算公式，可得：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1636554/201904/1636554-20190409220414527-828246643.png&quot; alt=&quot;&quot; width=&quot;484&quot; height=&quot;90&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;不难发现，相关系数就是将x，y坐标向量各自平移到原点后的夹角余弦。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;相对熵（K-L距离）&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1636554/201904/1636554-20190409220013069-155074314.png&quot; alt=&quot;&quot; width=&quot;343&quot; height=&quot;62&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.聚类的基本思想&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1.给定一个有N个对象的数据集，构造数据的K个簇，k&amp;lt;=n，并且满足下列条件：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　每一个簇至少包含一个对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　每一个对象属于且仅属于一个簇。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　将满足上述条件的K个簇称作一个合理划分。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 　　2.基本思想：对于给定的类别K，首先给定初始的划分，通过迭代改变样本和簇的隶属关系，使得每一次改进之后的划分方案都较前一次好。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.K-Means算法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;K-means算法，也被称为K-平均或K-均值，是一种广泛使用的聚类算法，或者成为其他聚类算法的基础。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　假定输入样本为S=x1, x2, ......, xm，则算法步骤为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　选择初始的k个类别中心，u1, u2, ......, uk。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　对于每个样本的xi，将其中标记为距离类别中心最近的类别，即：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1636554/201904/1636554-20190409221820526-353345690.png&quot; alt=&quot;&quot; width=&quot;277&quot; height=&quot;63&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　将每个类别中心更新为隶属该类别的所有样本的均值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1636554/201904/1636554-20190409221939211-964097120.png&quot; alt=&quot;&quot; width=&quot;209&quot; height=&quot;62&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　重复后面的两步，直到类别中心变化小于某阈值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;终止条件：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　迭代次数，簇中心变化率，最小平方误差MSE。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.K-Means的公式化解释&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　记K个簇中心为u1,u2,......,uk，每个簇的样本数目为N1,N2,......，Nk。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　使用平方误差作为目标函数：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1636554/201904/1636554-20190409222445883-1361041829.png&quot; alt=&quot;&quot; width=&quot;311&quot; height=&quot;61&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　该函数为关于u1,u2,......,uk的凸函数，计算其驻点，得：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1636554/201904/1636554-20190409222737592-680433178.png&quot; alt=&quot;&quot; width=&quot;404&quot; height=&quot;79&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;5.K-Means聚类方法总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;优点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;一种经典算法，简单，快速的聚类算法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　对于大数据集，该算法保持可伸缩性和高效率。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　当簇近似为高斯分布时，它的效果较好。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;缺点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;在簇的平均值可被定义的情况下才能使用，可能不适用某些情况。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　必须实现给出K(聚类的簇数目)，而且是初值敏感的，对于不同的初始值，可能会导致不同的结果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　不适合于发现非凸型的簇或者大小差别很大的簇。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　对噪声和孤立点数据敏感。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在很多情况下，可以作为其他聚类的基础算法，比如谱聚类。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;6.代码示例&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;79&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     N = 400
&lt;span&gt; 3&lt;/span&gt;     centers = 4
&lt;span&gt; 4&lt;/span&gt;     data1, y1 = make_blobs(n_samples=N, n_features=2, centers= centers, random_state=2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     data2, y2 = make_blobs(n_samples=N, n_features=2, centers=centers, cluster_std=(1, 2.5, 0.5, 2), random_state=2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    plt.figure()
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     plt.plot(data1[:, 0], data1[:, 1], &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ro&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, data2[:, 0], data2[:, 1], &lt;span&gt;'&lt;/span&gt;&lt;span&gt;g*&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    plt.show()
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     data = np.vstack((data1[y1 == 0][:], data1[y1 == 1][:50], data1[y1 == 2][:20], data1[y1 == 3][:5&lt;span&gt;]))
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     y = np.array([0] * 100 + [1] * 50 + [2] * 20 + [3] * 5&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(data)&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(y)&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; plt.figure()&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; plt.plot(data[:100, 0], data[:100, 1], 'ro',&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;          data[100:150, 0], data[100:150, 1], 'g*',&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;          data[150:170, 0], data[150:170, 1], 'b*',&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;          data[170:175, 0], data[170:175, 1], 'k*')&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; plt.show()&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;     cls = KMeans(n_clusters=4, init=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;k-means++&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     y1_hat =&lt;span&gt; cls.fit_predict(data1)
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     y2_hat =&lt;span&gt; cls.fit_predict(data2)
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     y_hat =&lt;span&gt; cls.fit_predict(data)
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(y1_hat)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;KMeans函数的参数详解：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;n_clusters&lt;/strong&gt;：整型，缺省值=8 ，生成的聚类数。&lt;br/&gt;　　&lt;strong&gt;max_iter&lt;/strong&gt;：整型，缺省值=300 。&lt;br/&gt;　　　　执行一次k-means算法所进行的最大迭代数。&lt;br/&gt;　　&lt;strong&gt;n_init&lt;/strong&gt;：整型，缺省值=10 。&lt;br/&gt;　　　　　 用不同的聚类中心初始化值运行算法的次数，最终解是在inertia意义下选出的最优结果。&lt;br/&gt;　　&lt;strong&gt;init&lt;/strong&gt;：有三个可选值：’k-means++’， ‘random’，或者传递一个ndarray向量。&lt;br/&gt;　　　　 此参数指定初始化方法，默认值为 ‘k-means++’。&lt;br/&gt;　　　　（１）‘k-means++’ 用一种特殊的方法选定初始聚类中发，可加速迭代过程的收敛。&lt;br/&gt;　　　　（２）‘random’ 随机从训练数据中选取初始质心。&lt;br/&gt;　　　　（３）如果传递的是一个ndarray，则应该形如 (n_clusters, n_features) 并给出初始质心。&lt;br/&gt;　　&lt;strong&gt;precompute_distances&lt;/strong&gt;：三个可选值，‘auto’，True 或者 False。&lt;br/&gt;　　　　预计算距离，计算速度更快但占用更多内存。&lt;br/&gt;　　　　（１）‘auto’：如果 样本数乘以聚类数大于 12million 的话则不预计算距离。&lt;br/&gt;　　　　（２）True：总是预先计算距离。&lt;br/&gt;　　　　（３）False：永远不预先计算距离。&lt;br/&gt;　　&lt;strong&gt;tol&lt;/strong&gt;：float类型，默认值= 1e-4　与inertia结合来确定收敛条件。&lt;br/&gt;　　&lt;strong&gt;n_jobs&lt;/strong&gt;：整形数。　指定计算所用的进程数。内部原理是同时进行n_init指定次数的计算。&lt;br/&gt;　　　　（１）若值为 -1，则用所有的CPU进行运算。若值为1，则不进行并行运算。&lt;br/&gt;　　　　（２）若值小于-1，则用到的CPU数为(n_cpus + 1 + n_jobs)。因此如果 n_jobs值为-2，则用到的CPU数为总CPU数减1。&lt;br/&gt;　　&lt;strong&gt;random_state&lt;/strong&gt;：整型或 numpy.RandomState 类型，可选&lt;br/&gt;　　　　　用于初始化质心的生成器（generator）。如果值为一个整数，则确定一个seed。此参数默认值为numpy的随机数生成器。&lt;br/&gt;　　&lt;strong&gt;copy_x&lt;/strong&gt;：布尔型，默认值=True 　　&lt;br/&gt;　　　　　　 当我们precomputing distances时，将数据中心化会得到更准确的结果。如果把此参数值设为True，则原始数据不会被改变。如果是False，则会直接在原始数据&lt;br/&gt;　　　　　　上做修改并在函数返回值时将其还原。但是在计算过程中由于有对数据均值的加减运算，所以数据返回后，原始数据和计算前可能会有细小差别。&lt;br/&gt;聚类结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1636554/201904/1636554-20190409231853190-746838104.png&quot; alt=&quot;&quot; width=&quot;725&quot; height=&quot;201&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在聚类的过程中，我们发现，如果对数据进行一定的变化，得到的聚类结果可能有所不同，比如旋转。&lt;/p&gt;

</description>
<pubDate>Tue, 09 Apr 2019 15:36:00 +0000</pubDate>
<dc:creator>Baby-Lily</dc:creator>
<og:description>0.聚类 聚类就是对大量的未知标注的数据集，按数据的内在相似性将数据集划分为多个类别，使类别内的数据相似度较大而类别间的数据相似度较小，聚类属于无监督的学习方法。 1.内在相似性的度量 聚类是根据数据</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/baby-lily/p/10680617.html</dc:identifier>
</item>
<item>
<title>（三）neo4j的安装配置 - 一般的斑鸠</title>
<link>http://www.cnblogs.com/zhanglf4498/p/10680611.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhanglf4498/p/10680611.html</guid>
<description>&lt;p&gt;&lt;strong&gt;（一）neo4j安装&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;neo4j有社区版本和企业版，社区版本是免费的，企业版本是收费的。在linux上安装如下步骤：&lt;/p&gt;
&lt;p&gt;1、将下载的neo4j-enterprise-3.4.0-unix.tar.gz包上传到linux服务器，并解压。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;2、设置$NEO4J_HOME也就是解压图数据库安装包所在的目录到~/.bash_profile文件中&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;3、neo4j用户的文件句柄数：vim /etc/security/limits.conf&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;neo4j   soft    nofile  40000&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;neo4j   hard    nofile  40000&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;4、修改conf图数据库配置文件，设置远程可访问。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;dbms.connectors.default_listen_address=0.0.0.0&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;5、修改conf图数据库配置文件，修改数据库http端口和bolt端口,这里端口自己确定&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;dbms.connector.http.listen_address=ip&lt;strong&gt;:21003&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;dbms.connector.bolt.listen_address=ip&lt;strong&gt;:21002&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;6、修改文件/etc/pam.d/su&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;session    required   pam_limits.so&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;7、启动neo4j&lt;/p&gt;
&lt;p&gt;到$NEO4J_HOME的bin目录下执行以下命令启动图数据库：&lt;/p&gt;
&lt;p&gt;sh neo4j.sh start&lt;/p&gt;
&lt;p&gt;启动完成结构如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/571282/201904/571282-20190409232830137-1744176229.png&quot; alt=&quot;&quot; width=&quot;667&quot; height=&quot;209&quot;/&gt;&lt;/p&gt;

&lt;p&gt;8、验证是否启动，在浏览器中输入http://ip:21003/browser&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/571282/201904/571282-20190409232705332-580785925.png&quot; alt=&quot;&quot; width=&quot;723&quot; height=&quot;288&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 完！！！&lt;/p&gt;

</description>
<pubDate>Tue, 09 Apr 2019 15:30:00 +0000</pubDate>
<dc:creator>一般的斑鸠</dc:creator>
<og:description>（一）neo4j安装 neo4j有社区版本和企业版，社区版本是免费的，企业版本是收费的。在linux上安装如下步骤： 1、将下载的neo4j-enterprise-3.4.0-unix.tar.gz包</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhanglf4498/p/10680611.html</dc:identifier>
</item>
<item>
<title>Egg.js 中入参的校验 - 刘哇勇</title>
<link>http://www.cnblogs.com/Wayou/p/form_validation_in_eggjs.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Wayou/p/form_validation_in_eggjs.html</guid>
<description>&lt;p&gt;日常作业中免不了频繁处理 GET/POST 的入参，你当然可以每个 action 中都重复地去做这些事情，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;从 query 或 body 取出入参，&lt;/li&gt;
&lt;li&gt;对可选的入参进行判空，&lt;/li&gt;
&lt;li&gt;处理入参的类型转换，&lt;/li&gt;
&lt;li&gt;对入参进行逻辑校验，数字是否超限，类型是否非法等...&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;但这些通用的逻辑可通过抽取到插件或服务中，避免代码冗余和重复劳动。&lt;/p&gt;
&lt;h2&gt;egg-validation&lt;/h2&gt;
&lt;p&gt;Egg.js 中可通过 &lt;a href=&quot;https://github.com/eggjs/egg-validate&quot;&gt;egg-validation&lt;/a&gt; 插件来减少这部分的工作量。通过该插件，上面大部分工作可转成简单的配置。&lt;/p&gt;
&lt;h3&gt;安装插件&lt;/h3&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot;&gt;
&lt;pre&gt;
$ yarn add egg-validate
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;配置插件&lt;/h3&gt;
&lt;p&gt;启用：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;config/plugin.ts&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;11&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt; plugin&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;EggPlugin&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; {
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; ...&lt;/span&gt;
    validate&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; {
        enable&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;true&lt;/span&gt;,
        package&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;egg-validate&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;,
    },
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; ...&lt;/span&gt;
};

&lt;span class=&quot;pl-k&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;plugin&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;配置插件：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;config/config.default.ts&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;default&lt;/span&gt; (&lt;span class=&quot;pl-smi&quot;&gt;appInfo&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;EggAppInfo&lt;/span&gt;) &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
  &lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;config&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; {} as PowerPartial&lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt;EggAppConfig&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt;;

  &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; ...&lt;/span&gt;
  &lt;span class=&quot;pl-smi&quot;&gt;config&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;validate&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; {
    convert&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;true&lt;/span&gt;,
    widelyUndefined&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;true&lt;/span&gt;
  };

  &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; ...&lt;/span&gt;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其配置项为 &lt;a href=&quot;https://github.com/node-modules/parameter&quot;&gt;node-modules/parameter&lt;/a&gt; 的所有可用配置项，因为该插件其实就是后者的 Egg.js 封装。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;convert&lt;/code&gt; 会对入参进行转换，建议开启。举个例子，使用表单中默认的 submit 类型按钮提交表单时，提交过来的往往是序列化后的字符串，那些期望是数字类型的字段就会始终验证不过。而开启此项后，会对入参按希望的类型进行转换。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;widelyUndefined&lt;/code&gt; 开启后，会把空字符串，&lt;code&gt;NaN&lt;/code&gt;,&lt;code&gt;null&lt;/code&gt; 这些转成 &lt;code&gt;undefined&lt;/code&gt;，将这些异常的数据进行了统一，方便后续处理。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;使用&lt;/h2&gt;
&lt;p&gt;插件在 &lt;code&gt;app&lt;/code&gt; 及 &lt;code&gt;context&lt;/code&gt; 上扩展了 &lt;code&gt;validator&lt;/code&gt; 对象，通过调用 &lt;code&gt;validator.validate(rules,data)&lt;/code&gt; 来进行验证。&lt;/p&gt;
&lt;p&gt;比如接收一个名为 &lt;code&gt;name&lt;/code&gt; 的字符串入参：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;app/controller/home.ts&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;errors&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;app&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;validator&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;validate&lt;/span&gt;({ name&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;string&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt; }, &lt;span class=&quot;pl-c1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;request&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;body&lt;/span&gt;);
&lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; (errors) {
    &lt;span class=&quot;pl-c1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;ctx&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;body&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; errors;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;验证规则&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;validate&lt;/code&gt; 第一个参数为规则，它是个对象。其每个字段对应同名的入参。字段的值可以是简单的字符串，指定字段的类型，也可以是对象，在这个对象里进行更加详细的规则指定。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;16&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;rules&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; {
    param1&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;string&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; 必填的字符串入参&lt;/span&gt;
    param2&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;string?&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; 可选的字符串入参&lt;/span&gt;
    param3&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; {
        type&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;int&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; 整形入参&lt;/span&gt;
        required&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;false&lt;/span&gt;, &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; 该入参可选&lt;/span&gt;
        min&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; 该入参的最小值&lt;/span&gt;
        max&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; 该入参的最大值&lt;/span&gt;
    },
};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;规则默认入参是必填的，对于可选的入参，可通过在类型后加问号，与 TypeScript 类似，也可以显式指定 &lt;code&gt;required: false&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;预设可用的参数类型参见 &lt;a href=&quot;https://github.com/node-modules/parameter#int&quot;&gt;parameter&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;针对参数的规则配置，根据参数的类型，有不同的配置顶，比如对于数字类型，可配置其最大最小值；对于枚举，可定义其候选值，一旦入参不在这些值之内，便验证不通过。每种类型可用的配置项参见 &lt;a href=&quot;https://github.com/node-modules/parameter#int&quot;&gt;parameter&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;自定义验证规则&lt;/h3&gt;
&lt;p&gt;如果上面文档中预设的这些类型无法满足需求，可通过 &lt;code&gt;validator.addRule(type,checker)&lt;/code&gt; 自定义规则来扩充。&lt;/p&gt;
&lt;p&gt;其中 &lt;code&gt;type&lt;/code&gt; 为新增规则的类型名， &lt;code&gt;checker&lt;/code&gt; 为用来校验的正则或方法。如果是个方法，其入参为规则本身及需要校验的数据，文档里没有体现其入参，可参考&lt;a href=&quot;https://github.com/node-modules/parameter/blob/master/index.js#L111&quot;&gt;源码&lt;/a&gt;。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-smi&quot;&gt;checker&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;call&lt;/span&gt;(self, rule, obj[key], obj);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;比如增加一种类型为 &lt;code&gt;jsonString&lt;/code&gt; 的验证规则，限定入参必需为合法的 JSON 数据。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;app.ts&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;default&lt;/span&gt; (&lt;span class=&quot;pl-smi&quot;&gt;app&lt;/span&gt;) &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
    &lt;span class=&quot;pl-smi&quot;&gt;app&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;validator&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;addRule&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;jsonString&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;, (&lt;span class=&quot;pl-smi&quot;&gt;_rule&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;value&lt;/span&gt;) &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
        &lt;span class=&quot;pl-k&quot;&gt;try&lt;/span&gt; {
            &lt;span class=&quot;pl-c1&quot;&gt;JSON&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;parse&lt;/span&gt;(value);
        } &lt;span class=&quot;pl-k&quot;&gt;catch&lt;/span&gt; (err) {
            &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;must be json string&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;;
        }
    });
};
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;示例代码&lt;/h2&gt;
&lt;p&gt;一个可本地运行调试，配合了预设的验证规则及自定义的规则的示例，完整代码可在 &lt;a href=&quot;https://github.com/wayou/egg-form-validation-example&quot;&gt;GitHub&lt;/a&gt; 找到。&lt;/p&gt;
&lt;h2&gt;结论&lt;/h2&gt;
&lt;p&gt;写了过多的重复的代码后，比如这种入参的校验，就应该想想如何优雅地来处理这些重复的工作，无论是自己造轮子，还是找轮子。入参的校验如此之常见，进而，甚至可以去追求一套前后台通用的校验逻辑，将浏览器端的 JavaScript 与 Node.js 的逻辑进行统一。&lt;/p&gt;
&lt;h2&gt;相关资源&lt;/h2&gt;
</description>
<pubDate>Tue, 09 Apr 2019 15:26:00 +0000</pubDate>
<dc:creator>刘哇勇</dc:creator>
<og:description>日常作业中免不了频繁处理 GET/POST 的入参，你当然可以每个 action 中都重复地去做这些事情， 从 query 或 body 取出入参， 对可选的入参进行判空， 处理入参的类型转换， 对入</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Wayou/p/form_validation_in_eggjs.html</dc:identifier>
</item>
<item>
<title>网上搜集python面试题（更新中......） - 理想何需三旬</title>
<link>http://www.cnblogs.com/n1celll/p/10680558.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/n1celll/p/10680558.html</guid>
<description>&lt;p&gt;武Sir博客拿的面试题，答案都是自己写的，多有不足，请多多指教。更新中。。。。。。&lt;/p&gt;

&lt;p&gt;1.为什么学习Python?&lt;br/&gt;　　a.写起来快，看起来明白。作为通用性的语言，除了一些对性能要求很高的场合，几乎什么都能干，常见领域：web服务器、计算科学、程序脚本、系统管理&lt;/p&gt;
&lt;p&gt;2.通过什么途径学Python?&lt;br/&gt;　　看各种教学视频，看博客。&lt;/p&gt;
&lt;p&gt;3.Python和Java、PHP、C、C#、C++等其他语言的对比?&lt;br/&gt;　　Python是一门面向对象的解释性语言，Python通过缩进来确定作用域，Python代码简洁易读。 Python拥有很多功能强大的模块可供使用。但是Python相比较于其他语言，运行效率低，不适合对运行效率要求搞的程序。&lt;/p&gt;
&lt;p&gt;4.简述解释型和编译型编程语言?&lt;br/&gt;　　计算机不能直接的理解高级语言，只能直接理解机器语言，所以必须要把高级语言翻译成机器语言，计算机才能执行高级语言的编写的程序。翻译的方式有两种，一个是编译，一个是解释。两种方式只是翻译的时间不同。&lt;br/&gt;　　解释性语言的程序不需要编译，解释性语言在程序运行的时候才需要翻译，可移植性好，只需要有解释环境，可在不同平台运行。缺点就是必须要有解释环境才能运行，需要占用更多的资源，代码效率低，解释器本身也需要占用资源，程序严重依赖于平台。&lt;br/&gt;　　编译型就是直接把程序编译成机器可以执行的文件，编译和执行是分开的，但不能跨平台，编译型语言的程序执行效率高，编译后程序不可修改，保密性好。缺点代码需要经过编译方可运行，可移植性差，只能在兼容的操作系统上运行。&lt;/p&gt;
&lt;p&gt;5.Python解释器种类以及特点?&lt;br/&gt;　　CPython&lt;br/&gt;　　使用C语言开发，使用最广泛的解释器。&lt;br/&gt;　　IPython&lt;br/&gt;　　基于CPython上的一个交互式解释器，IPython在交互方式上有所增强，但执行Python代码的功能和CPython是完全一样。&lt;br/&gt;　　PyPy&lt;br/&gt;　　PyPy采用JIT技术，对Python代码进行动态编译，可以显著提高Python代码的执行速度。&lt;br/&gt;　　JPython&lt;br/&gt;　　Jython是运行在Java平台上的Python解释器，可以直接把Python代码编译成Java字节码执行。&lt;br/&gt;　　IronPython&lt;br/&gt;　　IronPython和Jython类似，只不过IronPython是运行在微软.Net平台上的Python解释器，可以直接把Python代码编译成.Net的字节码。&lt;/p&gt;
&lt;p&gt;6.位和字节的关系？&lt;br/&gt;　　8位（bit） = 1字节（Byte）&lt;/p&gt;&lt;p&gt;7.b、B、KB、MB、GB 的关系？&lt;br/&gt;　　1024b（Byet） = 1KB&lt;br/&gt;　　1024KB（Byet） = 1MB&lt;br/&gt;　　1024MB（Byet） = 1GB&lt;br/&gt;　　1024GB（Byet） = 1TB&lt;/p&gt;
</description>
<pubDate>Tue, 09 Apr 2019 15:16:00 +0000</pubDate>
<dc:creator>理想何需三旬</dc:creator>
<og:description>武Sir博客拿的面试题，答案都是自己写的，多有不足，请多多指教。更新中。。。。。。 1.为什么学习Python? a.写起来快，看起来明白。作为通用性的语言，除了一些对性能要求很高的场合，几乎什么都能</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/n1celll/p/10680558.html</dc:identifier>
</item>
<item>
<title>js中关于赋值和内存的问题 - RiceYao</title>
<link>http://www.cnblogs.com/yaomeijuan/p/10680555.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yaomeijuan/p/10680555.html</guid>
<description>&lt;p&gt;一、var a=xxx，a内存中到底保存的是什么？&lt;/p&gt;
&lt;p&gt;　　1.xxx是数据，保存的就是这个数据。&lt;/p&gt;
&lt;p&gt;　　2.xxx是对象，保存的就是这个对象的地址值。&lt;/p&gt;
&lt;p&gt;　　3.xxx是个变量，保存的就是xxx的内容，可能是数据，也可能是地址值。&lt;/p&gt;
&lt;p&gt;二、关于引用变量赋值问题。&lt;/p&gt;
&lt;p&gt;　　1.两（n）个引用变量指向同一对象，通过其中一个引用变量修改对象内部数据，其他引用变量看到的是修改之后的数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1372215/201904/1372215-20190409214958092-951844522.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; obj1={name:'yao'&lt;span&gt;};
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; obj2=&lt;span&gt;obj1;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; obj2.name='li'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; console.log(obj1.age);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;'li'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2.两（n）个引用变量指向同一对象，让其中一个引用变量指向另一个对象，其他引用变量还是指向之前的对象。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1372215/201904/1372215-20190409220112149-1962038533.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; obj1={name:'yao'&lt;span&gt;};
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; obj2=&lt;span&gt;obj1;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; obj1={name:'li'&lt;span&gt;};
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; console.log(obj2.name);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;'yao'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;三、js调用函数传递变量参数时，是值传递还是引用传递？&lt;/p&gt;
&lt;p&gt;　　所有函数的参数都是按值传递的！！&lt;/p&gt;
&lt;p&gt;　　但是访问变量有按值和按引用两种方式！！&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; setName(obj) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     obj.name='yao'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; person=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object();
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;setName(person);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; console.log(person.name);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;'yao'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; setName(obj) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     obj.name='yao'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     obj=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object();
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     obj.name='li'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; person=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object();
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;setName(person);
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; console.log(person.name);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;'yao'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　如果person是按引用传递的，那么person会自动被修改为指向其name属性值为'li'的新对象。但是当访问person.name时，显示值仍为‘yao’。这说明即使在函数内部修改了参数的值，但原始的引用仍然保持未变。实际上，当在函数内部重写obj时，这个变量引用就是一个局部对象了。而这个局部对象会在函数执行完毕后立即被销毁。&lt;/p&gt;

</description>
<pubDate>Tue, 09 Apr 2019 15:15:00 +0000</pubDate>
<dc:creator>RiceYao</dc:creator>
<og:description>一、var a=xxx，a内存中到底保存的是什么？ 1.xxx是数据，保存的就是这个数据。 2.xxx是对象，保存的就是这个对象的地址值。 3.xxx是个变量，保存的就是xxx的内容，可能是数据，也可</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yaomeijuan/p/10680555.html</dc:identifier>
</item>
<item>
<title>带你了解数据库中事务的ACID特性 - Coder编程</title>
<link>http://www.cnblogs.com/coder-programming/p/10680490.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/coder-programming/p/10680490.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;前面我们介绍过数据库中 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIwMTg3NzYyOA==&amp;amp;mid=2247483713&amp;amp;idx=1&amp;amp;sn=d61ad0aed42dc36d64d17732db352288&amp;amp;chksm=96e67052a191f9445bbe3d5825ce547ad3171c3874b571a93b97977d0668413e37a164c3e0bc&amp;amp;token=1144933717&amp;amp;lang=zh_CN#rd&quot;&gt;带你了解数据库中JOIN的用法&lt;/a&gt; 与 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIwMTg3NzYyOA==&amp;amp;mid=2247483717&amp;amp;idx=1&amp;amp;sn=157a8a021c29043a10480d0294b39ca0&amp;amp;chksm=96e67056a191f940668812ebb092fe9984b22eb619a18339cc052e1051c659a7e9d907c48814&amp;amp;token=1144933717&amp;amp;lang=zh_CN#rd&quot;&gt;带你了解数据库中group by的用法&lt;/a&gt;的相关用法。本章节主要来介绍下数据库中一个非常重要的知识点&lt;code&gt;事务&lt;/code&gt;，也是我们项目中或面试中经常会遇到的知识点。如有错误还请大家及时指出~&lt;/p&gt;
&lt;p&gt;涉及面试题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;请讲下你对事务的理解？&lt;/li&gt;
&lt;li&gt;讲下事务有那几大特性？&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;以下都是采用mysql数据库&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;事务&quot;&gt;事务&lt;/h2&gt;
&lt;p&gt;事务(Transaction)，是我们关系型数据库中非常重要的一个概念，它要符合ACID特性。是由一组SQL语句组成的一个程序执行单元(Unit)，该执行单元要么成功Commit,要么失败Rollback。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190409223141756.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2hhZWxfSE0=,size_16,color_FFFFFF,t_70&quot; alt=&quot;事务&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;acid特性&quot;&gt;ACID特性&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Atomicity&lt;/li&gt;
&lt;li&gt;Consistency&lt;/li&gt;
&lt;li&gt;Isolation&lt;/li&gt;
&lt;li&gt;Durability&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;atomicity原子性&quot;&gt;Atomicity(原子性)&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;原子性&lt;/code&gt;：指事务是一个不可再分割的工作单元，事务中的操作要么都发生，要么都不发生。&lt;br/&gt;通俗的说：我们有一堆的事情，它要么全做，要么全都不做，不能只做一半。比如我们的银行转账。我把钱转给你，把我的钱扣掉，然后把你的钱加上去。不能只做一半，只把我的钱扣掉，你的钱没有加上去。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190409223612544.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2hhZWxfSE0=,size_16,color_FFFFFF,t_70&quot; alt=&quot;原子性&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;consistency一致性&quot;&gt;Consistency(一致性)&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;一致性&lt;/code&gt;指事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。&lt;br/&gt;通俗的说：我和你的钱加起来一共是2000，那么不管我和你之间如何转账，转几次账，事务结束后我们的钱相加起来应该还得是2000，这就是事务的一致性。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190409223903482.png&quot; alt=&quot;一致性&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;isolation隔离性&quot;&gt;Isolation(隔离性)&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;隔离性&lt;/code&gt;指多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。&lt;br/&gt;通俗的说：多个用户并发访问操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。&lt;/p&gt;
&lt;p&gt;数据库定义了4个隔离的级别：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;READ_UNCOMMITTED&lt;/li&gt;
&lt;li&gt;READ_COMMITTED&lt;/li&gt;
&lt;li&gt;REPEATABLE_READ&lt;/li&gt;
&lt;li&gt;SERIALIZABLE&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;下篇文章我们将专门介绍事务的隔离性&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;durability持久性&quot;&gt;Durability(持久性)&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;持久性&lt;/code&gt;指事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。&lt;br/&gt;通俗的说：比如我将事务做完之后，这个结果是能持久下去的并能一直存下去。不管断电还是其他情况。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190409224425827.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2hhZWxfSE0=,size_16,color_FFFFFF,t_70&quot; alt=&quot;持久性&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;关系型数据库都实现了ACID这样的一些事务特性。其中最关键的一点是Isolation(隔离性)，互相不影响。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;文末&quot;&gt;文末&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;本章节主要简单介绍了数据库中事务的ADID特性，下一章我们将详细介绍事务&lt;code&gt;隔离&lt;/code&gt;。&lt;br/&gt;欢迎关注公众号：&lt;strong&gt;Coder编程&lt;/strong&gt;&lt;br/&gt;获取最新原创技术文章和相关免费学习资料，随时随地学习技术知识！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190407231851378.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2hhZWxfSE0=,size_16,color_FFFFFF,t_70&quot; alt=&quot;微信公众号&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;推荐阅读&quot;&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIwMTg3NzYyOA==&amp;amp;mid=2247483713&amp;amp;idx=1&amp;amp;sn=d61ad0aed42dc36d64d17732db352288&amp;amp;chksm=96e67052a191f9445bbe3d5825ce547ad3171c3874b571a93b97977d0668413e37a164c3e0bc&amp;amp;token=1144933717&amp;amp;lang=zh_CN#rd&quot;&gt;带你了解数据库中JOIN的用法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIwMTg3NzYyOA==&amp;amp;mid=2247483717&amp;amp;idx=1&amp;amp;sn=157a8a021c29043a10480d0294b39ca0&amp;amp;chksm=96e67056a191f940668812ebb092fe9984b22eb619a18339cc052e1051c659a7e9d907c48814&amp;amp;token=1144933717&amp;amp;lang=zh_CN#rd&quot;&gt;带你了解数据库中group by的用法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIwMTg3NzYyOA==&amp;amp;mid=2247483706&amp;amp;idx=1&amp;amp;sn=8eed9d160013bd8ed6203ad511711553&amp;amp;chksm=96e67029a191f93fdd1543af2bf06025397d9c3bd0f0692c7fe247ab9c139cd869d69ab05498&amp;amp;token=1104592742&amp;amp;lang=zh_CN#rd&quot;&gt;一篇带你读懂TCP之“滑动窗口”协议&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/CoderMerlin/coder-programming&quot;&gt;Github个人主页目录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/573059382/coder-programming&quot;&gt;Gitee个人主页目录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;欢迎大家关注并Star~&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 09 Apr 2019 15:02:00 +0000</pubDate>
<dc:creator>Coder编程</dc:creator>
<og:description>前言 前面我们介绍过数据库中 '带你了解数据库中JOIN的用法 ' 与 ' 带你了解数据库中group by的用法 ' 的相关用法。本章节主要来介绍下数据库中一个非常重要的知识点 ，也是我们项目中或面</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/coder-programming/p/10680490.html</dc:identifier>
</item>
<item>
<title>Linux环境变量配置全攻略 - 悠悠i</title>
<link>http://www.cnblogs.com/youyoui/p/10680329.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/youyoui/p/10680329.html</guid>
<description>&lt;h2 id=&quot;linux环境变量配置&quot;&gt;Linux环境变量配置&lt;/h2&gt;
&lt;p&gt;在自定义安装软件的时候，经常需要配置环境变量，下面列举出各种对环境变量的配置方法。&lt;/p&gt;
&lt;p&gt;下面所有例子的环境说明如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;系统：Ubuntu 14.0&lt;/li&gt;
&lt;li&gt;用户名：uusama&lt;/li&gt;
&lt;li&gt;需要配置MySQL环境变量路径：/home/uusama/mysql/bin&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;linux读取环境变量&quot;&gt;Linux读取环境变量&lt;/h3&gt;
&lt;p&gt;读取环境变量的方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;export&lt;/code&gt;命令显示当前系统定义的所有环境变量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;echo $PATH&lt;/code&gt;命令输出当前的&lt;code&gt;PATH&lt;/code&gt;环境变量的值&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这两个命令执行的效果如下&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;uusama@ubuntu:~$ export
declare -x HOME=&quot;/home/uusama&quot;
declare -x LANG=&quot;en_US.UTF-8&quot;
declare -x LANGUAGE=&quot;en_US:&quot;
declare -x LESSCLOSE=&quot;/usr/bin/lesspipe %s %s&quot;
declare -x LESSOPEN=&quot;| /usr/bin/lesspipe %s&quot;
declare -x LOGNAME=&quot;uusama&quot;
declare -x MAIL=&quot;/var/mail/uusama&quot;
declare -x PATH=&quot;/home/uusama/bin:/home/uusama/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;
declare -x SSH_TTY=&quot;/dev/pts/0&quot;
declare -x TERM=&quot;xterm&quot;
declare -x USER=&quot;uusama&quot;

uusama@ubuntu:~$ echo $PATH
/home/uusama/bin:/home/uusama/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中&lt;code&gt;PATH&lt;/code&gt;变量定义了运行命令的查找路径，以冒号&lt;code&gt;:&lt;/code&gt;分割不同的路径，使用&lt;code&gt;export&lt;/code&gt;定义的时候可加双引号也可不加。&lt;/p&gt;
&lt;h3 id=&quot;linux环境变量配置方法一export-path&quot;&gt;Linux环境变量配置方法一：&lt;code&gt;export PATH&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;使用&lt;code&gt;export&lt;/code&gt;命令直接修改&lt;code&gt;PATH&lt;/code&gt;的值，配置MySQL进入环境变量的方法:&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;export PATH=/home/uusama/mysql/bin:$PATH

# 或者把PATH放在前面
export PATH=$PATH:/home/uusama/mysql/bin&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意事项：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;生效时间：立即生效&lt;/li&gt;
&lt;li&gt;生效期限：当前终端有效，窗口关闭后无效&lt;/li&gt;
&lt;li&gt;生效范围：仅对当前用户有效&lt;/li&gt;
&lt;li&gt;配置的环境变量中不要忘了加上原来的配置，即&lt;code&gt;$PATH&lt;/code&gt;部分，避免覆盖原来配置&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;linux环境变量配置方法二vim-.bashrc&quot;&gt;Linux环境变量配置方法二：&lt;code&gt;vim ~/.bashrc&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;通过修改用户目录下的&lt;code&gt;~/.bashrc&lt;/code&gt;文件进行配置：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;vim ~/.bashrc

# 在最后一行加上
export PATH=$PATH:/home/uusama/mysql/bin&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意事项：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;生效时间：使用相同的用户打开新的终端时生效，或者手动&lt;code&gt;source ~/.bashrc&lt;/code&gt;生效&lt;/li&gt;
&lt;li&gt;生效期限：永久有效&lt;/li&gt;
&lt;li&gt;生效范围：仅对当前用户有效&lt;/li&gt;
&lt;li&gt;如果有后续的环境变量加载文件覆盖了&lt;code&gt;PATH&lt;/code&gt;定义，则可能不生效&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;linux环境变量配置方法三vim-.bash_profile&quot;&gt;Linux环境变量配置方法三：&lt;code&gt;vim ~/.bash_profile&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;和修改&lt;code&gt;~/.bashrc&lt;/code&gt;文件类似，也是要在文件最后加上新的路径即可：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;vim ~/.bash_profile

# 在最后一行加上
export PATH=$PATH:/home/uusama/mysql/bin&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意事项：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;生效时间：使用相同的用户打开新的终端时生效，或者手动&lt;code&gt;source ~/.bash_profile&lt;/code&gt;生效&lt;/li&gt;
&lt;li&gt;生效期限：永久有效&lt;/li&gt;
&lt;li&gt;生效范围：仅对当前用户有效&lt;/li&gt;
&lt;li&gt;如果没有&lt;code&gt;~/.bash_profile&lt;/code&gt;文件，则可以编辑&lt;code&gt;~/.profile&lt;/code&gt;文件或者新建一个&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;linux环境变量配置方法四vim-etcbashrc&quot;&gt;Linux环境变量配置方法四：&lt;code&gt;vim /etc/bashrc&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;该方法是修改系统配置，需要管理员权限（如root）或者对该文件的写入权限：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# 如果/etc/bashrc文件不可编辑，需要修改为可编辑
chmod -v u+w /etc/bashrc

vim /etc/bashrc

# 在最后一行加上
export PATH=$PATH:/home/uusama/mysql/bin&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意事项：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;生效时间：新开终端生效，或者手动&lt;code&gt;source /etc/bashrc&lt;/code&gt;生效&lt;/li&gt;
&lt;li&gt;生效期限：永久有效&lt;/li&gt;
&lt;li&gt;生效范围：对所有用户有效&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;linux环境变量配置方法五vim-etcprofile&quot;&gt;Linux环境变量配置方法五：&lt;code&gt;vim /etc/profile&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;该方法修改系统配置，需要管理员权限或者对该文件的写入权限，和&lt;code&gt;vim /etc/bashrc&lt;/code&gt;类似：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# 如果/etc/profile文件不可编辑，需要修改为可编辑
chmod -v u+w /etc/profile

vim /etc/profile

# 在最后一行加上
export PATH=$PATH:/home/uusama/mysql/bin&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意事项：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;生效时间：新开终端生效，或者手动&lt;code&gt;source /etc/profile&lt;/code&gt;生效&lt;/li&gt;
&lt;li&gt;生效期限：永久有效&lt;/li&gt;
&lt;li&gt;生效范围：对所有用户有效&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;linux环境变量配置方法六vim-etcenvironment&quot;&gt;Linux环境变量配置方法六：&lt;code&gt;vim /etc/environment&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;该方法是修改系统环境配置文件，需要管理员权限或者对该文件的写入权限：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# 如果/etc/bashrc文件不可编辑，需要修改为可编辑
chmod -v u+w /etc/environment

vim /etc/profile

# 在最后一行加上
export PATH=$PATH:/home/uusama/mysql/bin&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意事项：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;生效时间：新开终端生效，或者手动&lt;code&gt;source /etc/environment&lt;/code&gt;生效&lt;/li&gt;
&lt;li&gt;生效期限：永久有效&lt;/li&gt;
&lt;li&gt;生效范围：对所有用户有效&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;linux环境变量加载原理解析&quot;&gt;Linux环境变量加载原理解析&lt;/h2&gt;
&lt;p&gt;上面列出了环境变量的各种配置方法，那么Linux是如何加载这些配置的呢？是以什么样的顺序加载的呢？&lt;/p&gt;
&lt;p&gt;特定的加载顺序会导致相同名称的环境变量定义被覆盖或者不生效。&lt;/p&gt;
&lt;h3 id=&quot;环境变量的分类&quot;&gt;环境变量的分类&lt;/h3&gt;
&lt;p&gt;环境变量可以简单的分成用户自定义的环境变量以及系统级别的环境变量。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;用户级别环境变量定义文件：&lt;code&gt;~/.bashrc&lt;/code&gt;、&lt;code&gt;~/.bash_profile&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;系统级别环境变量定义文件：&lt;code&gt;/etc/bashrc&lt;/code&gt;、&lt;code&gt;/etc/bash_profile&lt;/code&gt;、&lt;code&gt;/etc/environment&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;另外在用户环境变量中，系统会首先读取&lt;code&gt;~/.bash_profile&lt;/code&gt;文件，如果没有该文件则读取&lt;code&gt;~/.bash_login&lt;/code&gt;，如果也没有该文件，则读取&lt;code&gt;~/.profile&lt;/code&gt;，根据这些文件中内容再去读取&lt;code&gt;~/.bashrc&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;测试linux环境变量加载顺序的方法&quot;&gt;测试Linux环境变量加载顺序的方法&lt;/h3&gt;
&lt;p&gt;为了测试各个不同文件的环境变量加载顺序，我们在每个环境变量定义文件中的第一行都定义相同的环境变量&lt;code&gt;UU_ORDER&lt;/code&gt;，该变量的值为本身的值连接上当前文件名称。&lt;/p&gt;
&lt;p&gt;需要修改的文件如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;/etc/environment&lt;/li&gt;
&lt;li&gt;/etc/profile&lt;/li&gt;
&lt;li&gt;/etc/profile.d/test.sh，新建文件，没有文件夹可略过&lt;/li&gt;
&lt;li&gt;/etc/bashrc，或者/etc/bash.bashrc&lt;/li&gt;
&lt;li&gt;~/.bash_profile，或者~/.profile&lt;/li&gt;
&lt;li&gt;~/.bashrc&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在每个文件中的第一行都加上下面这句代码，并相应的把冒号后的内容修改为当前文件的绝对文件名。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;export UU_ORDER=&quot;$UU_ORDER:~/.bash_profile&quot;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;修改完之后保存，新开一个窗口，然后&lt;code&gt;echo $UU_ORDER&lt;/code&gt;观察变量的值：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;uusama@ubuntu:~$ echo $UU_ORDER
$UU_ORDER:/etc/environment:/etc/profile:/etc/bash.bashrc:/etc/profile.d/test.sh:~/.profile:~/.bashrc&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以推测出Linux加载环境变量的顺序如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ol&gt;&lt;li&gt;/etc/environment&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol&gt;&lt;li&gt;/etc/profile&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol&gt;&lt;li&gt;/etc/bash.bashrc&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol&gt;&lt;li&gt;/etc/profile.d/test.sh&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol&gt;&lt;li&gt;~/.profile&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol&gt;&lt;li&gt;~/.bashrc&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;linux环境变量文件加载详解&quot;&gt;Linux环境变量文件加载详解&lt;/h3&gt;
&lt;p&gt;由上面的测试可容易得出Linux加载环境变量的顺序如下，：&lt;/p&gt;
&lt;p&gt;系统环境变量 -&amp;gt; 用户自定义环境变量&lt;br/&gt;/etc/environment -&amp;gt; /etc/profile -&amp;gt; ~/.profile&lt;/p&gt;
&lt;p&gt;打开&lt;code&gt;/etc/profile&lt;/code&gt;文件你会发现，该文件的代码中会加载&lt;code&gt;/etc/bash.bashrc&lt;/code&gt;文件，然后检查&lt;code&gt;/etc/profile.d/&lt;/code&gt;目录下的&lt;code&gt;.sh&lt;/code&gt;文件并加载。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# /etc/profile: system-wide .profile file for the Bourne shell (sh(1))
# and Bourne compatible shells (bash(1), ksh(1), ash(1), ...).

if [ &quot;$PS1&quot; ]; then
  if [ &quot;$BASH&quot; ] &amp;amp;&amp;amp; [ &quot;$BASH&quot; != &quot;/bin/sh&quot; ]; then
    # The file bash.bashrc already sets the default PS1.
    # PS1='\h:\w\$ '
    if [ -f /etc/bash.bashrc ]; then
      . /etc/bash.bashrc
    fi
  else
    if [ &quot;`id -u`&quot; -eq 0 ]; then
      PS1='# '
    else
      PS1='$ '
    fi
  fi
fi

if [ -d /etc/profile.d ]; then
  for i in /etc/profile.d/*.sh; do
    if [ -r $i ]; then
      . $i
    fi
  done
  unset i
fi&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其次再打开&lt;code&gt;~/.profile&lt;/code&gt;文件，会发现该文件中加载了&lt;code&gt;~/.bashrc&lt;/code&gt;文件。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# if running bash
if [ -n &quot;$BASH_VERSION&quot; ]; then
    # include .bashrc if it exists
    if [ -f &quot;$HOME/.bashrc&quot; ]; then
    . &quot;$HOME/.bashrc&quot;
    fi
fi

# set PATH so it includes user's private bin directories
PATH=&quot;$HOME/bin:$HOME/.local/bin:$PATH&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从&lt;code&gt;~/.profile&lt;/code&gt;文件中代码不难发现，&lt;code&gt;/.profile&lt;/code&gt;文件&lt;strong&gt;只在用户登录的时候读取一次&lt;/strong&gt;，而&lt;code&gt;/.bashrc&lt;/code&gt;会在每次运行&lt;code&gt;Shell&lt;/code&gt;脚本的时候读取一次。&lt;/p&gt;
&lt;h3 id=&quot;一些小技巧&quot;&gt;一些小技巧&lt;/h3&gt;
&lt;p&gt;可以自定义一个环境变量文件，比如在某个项目下定义&lt;code&gt;uusama.profile&lt;/code&gt;，在这个文件中使用&lt;code&gt;export&lt;/code&gt;定义一系列变量，然后在&lt;code&gt;~/.profile&lt;/code&gt;文件后面加上：&lt;code&gt;sourc uusama.profile&lt;/code&gt;，这样你每次登陆都可以在Shell脚本中使用自己定义的一系列变量。&lt;/p&gt;
&lt;p&gt;也可以使用&lt;code&gt;alias&lt;/code&gt;命令定义一些命令的别名，比如&lt;code&gt;alias rm=&quot;rm -i&quot;&lt;/code&gt;（双引号必须），并把这个代码加入到&lt;code&gt;~/.profile&lt;/code&gt;中，这样你每次使用&lt;code&gt;rm&lt;/code&gt;命令的时候，都相当于使用&lt;code&gt;rm -i&lt;/code&gt;命令，非常方便。&lt;/p&gt;
</description>
<pubDate>Tue, 09 Apr 2019 14:32:00 +0000</pubDate>
<dc:creator>悠悠i</dc:creator>
<og:description>Linux系统中怎么读取环境变量很简单，但是你知道配置环境变量有哪6方法吗？不同环境变量的配置方法有什么区别？Linux加载环境变量的顺序是怎样的？本文5分钟手把手教你弄懂所有问题。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/youyoui/p/10680329.html</dc:identifier>
</item>
<item>
<title>通过DFS求解有向图（邻接表存储）中所有简单回路 - 泰阁尔</title>
<link>http://www.cnblogs.com/zhaodongge/p/10680313.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhaodongge/p/10680313.html</guid>
<description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;查阅了网上许多关于通过DFS算法对有向图中所有简单回路的查找，发现有很多关于使用DFS求解有向回路中所有简单回路的帖子，（在按照节点编号情况下）但大多数仅仅寻找了编号递增的回路。又或者未对结果去重。P.S.下述有向图中所有节点均使用数字进行编号，如节点0、节点1 &lt;span class=&quot;math inline&quot;&gt;\(\cdots\)&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;算法描述&quot;&gt;1. 算法描述&lt;/h3&gt;
&lt;p&gt;本算法基于DFS，思路与传统DFS基本类似，只不过在遍历过程中对所经过的路径通过一个栈进行保存，当找到回路时，检测此条回路是否已经在结果集中出现，若未出现，则将其放入结果集。本过程中比较关键的两步是&lt;strong&gt;DFS&lt;/strong&gt;与&lt;strong&gt;结果集去重&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;关于DFS。每当从一个新的顶点出发对其进行递归的深度遍历时，我们维护一个新的节点已访问数组&lt;code&gt;visited[]&lt;/code&gt;以及一个一维的回路栈&lt;code&gt;loopStack&lt;/code&gt;。当访问到节点v时，若v已经被访问，即&lt;code&gt;visited[v]==true&lt;/code&gt;时，扫描栈中是节点v是否已经出现过，当节点v已经在栈中出现过，则说明此时出现一条回路，我们将其加入结果集。若节点v未被访问，此时置&lt;code&gt;visited[v]=true&lt;/code&gt;并将节点v入栈，并对v的所有邻接点进行访问，重复以上操作。到最深处（即已无邻接点未遍历）进行回溯处理，即将栈顶元素退栈。&lt;/p&gt;&lt;p&gt;关于去重。当需要在结果集中加入新找到的一条回路时，需要对结果集扫描，判断此条回路是否已经出现过。但在一个有向图中很容易发现回路&lt;span class=&quot;math inline&quot;&gt;\(0\rightarrow1\rightarrow2\rightarrow3(\rightarrow0)\)&lt;/span&gt;与回路&lt;span class=&quot;math inline&quot;&gt;\(2\rightarrow3\rightarrow1\rightarrow0(\rightarrow0)\)&lt;/span&gt;是两条相同的回路，那么在结果集中我们需要对此类回路进行去重，此处我的具体做法是使用两个指针i、j对将要比较的两条回路同时进行扫描比较，&lt;code&gt;指针i&lt;/code&gt;指向第一条回路的起始位置，&lt;code&gt;指针j&lt;/code&gt;指向第二条回路中，与指针i指向位置元素相等的位置，记录两个回路中相等的元素个数count，当&lt;code&gt;count==loop.size()&lt;/code&gt;时，我们称这两条回路为同一条回路，否则将新回路加入结果集。&lt;/p&gt;
&lt;p&gt;算法具体步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;从v出发对图进行深度遍历若此节点已访问则转2，否则转3。&lt;/li&gt;
&lt;li&gt;若此节点已经在loopStack中出现，表明有回路存在，判断回路是否已经在结果集loopStacks中出现，若没出现过，则放入结果集。&lt;/li&gt;
&lt;li&gt;置Visited[v]=true，节点v入栈，对v的邻接顶点继续进行深搜。当搜索完所有邻接顶点，栈顶元素退栈。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;算法实现&quot;&gt;2. 算法实现&lt;/h3&gt;
&lt;p&gt;完整代码在github，请&lt;a href=&quot;https://github.com/geTiger/FindLoopsInGraph/blob/master/FindAllSimpleLoopsDFS.h&quot;&gt;点击这里&lt;/a&gt;&lt;br/&gt;DFS部分实现&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void DFS(int v) {
    if (visited[v] == 1) {
        int position = FindInVector(loopStack, v);
        if (position &amp;gt;=0) {
            vector&amp;lt;int&amp;gt; loop;
            //将环单独拿出并放入结果集
            for (int i = position; i &amp;lt; loopStack.size(); i++) {
                loop.push_back(loopStack[i]);
            }
            AddLoopStack(loop);
            return;
        }
        return;
    }
    visited[v] = true;
    loopStack.push_back(v);
    
    for (int j = 0; j &amp;lt; adjMatrixSize; j++) {
        if (adjMatrix[v][j] == 1)
            DFS(j);
    }
    
    loopStack.pop_back();
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;结果集去重部分&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void AddLoopStack(vector&amp;lt;int&amp;gt; loop) {
    bool haveThisLoop = false;
    int count,begin;
    if (loopStacks.size() == 0)
        loopStacks.push_back(loop);
    else {
        for (int i = 0; i &amp;lt; loopStacks.size(); i++) {//遍历结果集中的每一个回路
            count = 0;
            begin = 0;
            if (loop.size() == loopStacks[i].size()) {//若长度相等则进一步比较
                //为方便比较，找到结果集中第i条回路中与loop进行匹配的起点
                for (int k = 0; k &amp;lt; loopStacks[i].size(); k++) {
                    if (loop[0] == loopStacks[i][k])
                        begin = k;
                }
                //j指针从待添加结果集的loop数组的头部开始扫描
                //k指针从上述所找出的与loop数组比较的起点开始扫描
                for (int j =0,k=begin; j &amp;lt; loop.size(); j++, k = (k + 1) % (loopStacks[i].size())) {
                    if (loop[j] == loopStacks[i][k])
                        count++;
                }
                if (count == loop.size()) {
                    //haveThisLoop = true;
                    //break;
                    return;
                }
            }
        }//end else
        
        loopStacks.push_back(loop);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;算法复杂度分析&quot;&gt;3. 算法复杂度分析&lt;/h3&gt;
&lt;p&gt;假设存在n个顶点，考虑最坏情况下，有向图为有向完全图，那么可能的回路个数就是&lt;span class=&quot;math inline&quot;&gt;\(C_n^2+C_n^3+\cdots+C_n^n=2^n-n-1\)&lt;/span&gt;个回路，另外需要对n个顶点均需要DFS，而每条边都需要经过，加上去重的部分，所以时间复杂度为&lt;span class=&quot;math inline&quot;&gt;\(O(n^32^n)\)&lt;/span&gt;，需要保存所有回路的空间，故空间复杂度为&lt;span class=&quot;math inline&quot;&gt;\(O(2^n)\)&lt;/span&gt;。&lt;/p&gt;
&lt;hr/&gt;&lt;br/&gt;参考资料&lt;br/&gt;严蔚敏数据结构（C语言版）</description>
<pubDate>Tue, 09 Apr 2019 14:28:00 +0000</pubDate>
<dc:creator>泰阁尔</dc:creator>
<og:description>前言 查阅了网上许多关于通过DFS算法对有向图中所有简单回路的查找，发现有很多关于使用DFS求解有向回路中所有简单回路的帖子，（在按照节点编号情况下）但大多数仅仅寻找了编号递增的回路。又或者未对结果去</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhaodongge/p/10680313.html</dc:identifier>
</item>
<item>
<title>ELK(elasticsearch+kibana+logstash)搜索引擎(一)： 环境搭建 - waen</title>
<link>http://www.cnblogs.com/buggeerWang/p/10680284.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/buggeerWang/p/10680284.html</guid>
<description>&lt;p&gt;　　这里简单介绍一下elk架构中的各个组件，关于elk的详细介绍的请自行百度&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Elasticsearch是个开源分布式搜索引擎，是整个ELK架构的核心&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Logstash可以对数据进行收集、过滤，存储到ELasticsearch中&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Kibana 可以为 Logstash 和 ElasticSearch 提供的日志分析友好的 Web 界面，可以帮助您汇总、分析和搜索重要数据日志&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;　　下面是各个组件在架构中起到的作用&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594654/201904/1594654-20190409211610537-2047521725.png&quot; alt=&quot;&quot; width=&quot;894&quot; height=&quot;477&quot;/&gt;&lt;/p&gt;


&lt;p&gt;elasticsearch对版本极其敏感，所以一定要注意elk所有组件务必保持版本一致!&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;elk组件下载地址》》&lt;/span&gt;：&lt;a title=&quot;elasticsearch&quot; href=&quot;https://www.elastic.co/cn/downloads/&quot; target=&quot;_blank&quot;&gt;https://www.elastic.co/cn/downloads/&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;如果是本机使用elasticsearch基本上解压即用，只需要注意将elasticsearch配置成外网可访问，方法如下：&lt;/p&gt;
&lt;p&gt;修改elasticsearch/config目录下的elasticsearch.yml文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
network.host: 0.0.0.0
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将network.host设置为0.0.0.0即可开启外网访问，elasticsearch默认端口9200如果需要修改还是在elasticsearch.yml文件中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
http.port: 9200
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;elasticsearch设置数据存储路径以及目录存储路径&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;path.data: /path/to/data
path.logs: /path/to/logs&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;启动方式：&lt;/p&gt;
&lt;p&gt;　　windows下双击elasticsearch.bat启动&lt;/p&gt;
&lt;p&gt;　　linux下执行elasticsearch启动 -d为后台启动&lt;/p&gt;

&lt;p&gt;整个elk架构中logstash需要配置的地方最多，首先logstash起到的作用是收集数据导入至elasticsearch中，收集的方法有很多中，关系型数据库，非关系型数据库亦或者文件这里主要讲一下关系型数据库的导入&lt;/p&gt;
&lt;p&gt;先贴出笔者的配置文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;input {
    jdbc {&lt;br/&gt;　　　　 #设置数据库url
        jdbc_connection_string =&amp;gt; &quot;jdbc:mysql://localhost:3306/elk&quot;
        #账号与密码&lt;br/&gt;　　　　 jdbc_user =&amp;gt; &quot;root&quot;
        jdbc_password =&amp;gt; &quot;root&quot;
        #对应数据库的jar包位置以及jdbc类型&lt;br/&gt;　　　　 jdbc_driver_library =&amp;gt; &quot;/root/mysql-connector-java-5.1.46.jar&quot;
        jdbc_driver_class =&amp;gt; &quot;com.mysql.jdbc.Driver&quot;
        #每次启动logstash是否重新加载数据&lt;br/&gt;　　　　 clean_run =&amp;gt; false
        #编码格式&lt;br/&gt;　　　　 codec =&amp;gt; plain { charset =&amp;gt; &quot;UTF-8&quot;}
        #是否使用user_column_value 记录每次查询的值，这个必须为递增的值，在sql中可以使用:sql_last_value取出该值，如果不设置即默认该值为上次执行sql的时间&lt;br/&gt;　　　　 use_column_value =&amp;gt; false&lt;br/&gt;　　　　 #sql语句位置
        statement_filepath =&amp;gt; &quot;/root/product_list.sql&quot;
        #记录上一次执行时间的文件位置&lt;br/&gt;　　　　 last_run_metadata_path =&amp;gt; &quot;/root/product_last_run_time.txt&quot;
        #使用corn表达式定义执行周期&lt;br/&gt;　　　　 schedule =&amp;gt; &quot;*/30 * * * * *&quot;&lt;br/&gt;　　　　 #多个配置文件时定义该次查询集的名字，方便output、filter进行逻辑处理
        type =&amp;gt; &quot;test&quot;&lt;br/&gt;　　#时区
    jdbc_default_timezone =&amp;gt; &quot;Asia/Shanghai&quot;
    }
}
output {&lt;br/&gt;#使用if判断type
if [type] == &quot;test&quot;{&lt;br/&gt;#输出时的数据类型
stdout { codec =&amp;gt; json_lines }&lt;br/&gt;#输出到elasticsearch
    elasticsearch {&lt;br/&gt;　　　　 #elasticsearch地址
        hosts =&amp;gt; [&quot;localhost:9200&quot;]
        #存储到elasticsearch中的索引名&lt;br/&gt;　　　　 index =&amp;gt; &quot;test&quot;&lt;br/&gt;　　　　　#存到elasticsearch中的类型名
        document_type =&amp;gt; &quot;test&quot;&lt;br/&gt;　　　　 #存到elasticsearch中的id
        document_id =&amp;gt; &quot;%{id}&quot;&lt;br/&gt;　　     #使用模板存储到elasticsearch中
        template_name =&amp;gt; &quot;test&quot;&lt;br/&gt;　　  　　#模板位置
        template =&amp;gt; &quot;/root/logstash-ik.json&quot;
    }
}  
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在数据量大的期初导入数据可能会因为数据量太大导致jvm内存溢出，修改logstash/config下jvm.options文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;-Xms1g
-Xmx1g&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;根据机器配置去修改jvm的最大内存至8g或者更多&lt;/p&gt;
&lt;p&gt;如果这样都不能解决内存溢出的问题，笔者这里建议将logstash数据存储从内存放到本地磁盘，这样会牺牲速率但解决了期初数据量太大的问题&lt;/p&gt;
&lt;p&gt;修改logstash/config下logstash.yml文件&lt;/p&gt;
&lt;p&gt;配置如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
queue.type: persisted&lt;br/&gt;queue.max_bytes: 10240mb
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将queue.type设置为persisted，queue.max_bytes设置队列的最大存储数量&lt;/p&gt;
&lt;p&gt;还有一些关于logstash性能上的优化&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#logstash同时工作的线程数量，默认为服务器cpu核数，一般在cpu核数的四倍及以下合理&lt;br/&gt;pipeline.workers: 2&lt;br/&gt;#logstash一次操作的数据量，可以根据服务器内存来调整
pipeline.batch.size: 125&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;还有一些其他的优化可以自行参考logstash.yml文件&lt;/p&gt;

&lt;p&gt;Kibana需要修改的配置不多，需要注意如果要开启远程访问Kibana需要修改&lt;/p&gt;
&lt;p&gt;KIBANA/config/kibaba.yml下的&lt;/p&gt;
&lt;p&gt;server.host:&quot;localhost&quot;更改为&lt;/p&gt;
&lt;p&gt;server.host: &quot;0.0.0.0&quot; 就可以远程访问Kibana&lt;/p&gt;

&lt;p&gt;关于elk搜索引擎的环境搭建以及配置就到这里，要配置的地方也不多，基本上是开包即用，后面会介绍如何使用关于elasticsearch的使用以及讲解如何使用elk做一个电商平台的搜索引擎。&lt;/p&gt;


</description>
<pubDate>Tue, 09 Apr 2019 14:23:00 +0000</pubDate>
<dc:creator>waen</dc:creator>
<og:description>1.ELK简介 这里简单介绍一下elk架构中的各个组件，关于elk的详细介绍的请自行百度 Elasticsearch是个开源分布式搜索引擎，是整个ELK架构的核心 Logstash可以对数据进行收集、</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/buggeerWang/p/10680284.html</dc:identifier>
</item>
<item>
<title>从零开始学习iftop流量监控（找出服务器耗费流量最多的ip和端口） - 雪山飞猪</title>
<link>http://www.cnblogs.com/chenqionghe/p/10680075.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenqionghe/p/10680075.html</guid>
<description>&lt;p&gt;iftop是类似于top的实时流量监控工具。&lt;/p&gt;
&lt;p&gt;作用：监控网卡的实时流量（可以指定网段）、反向解析IP、显示端口信息等&lt;/p&gt;
&lt;p&gt;官网：&lt;a href=&quot;http://www.ex-parrot.com/~pdw/iftop/&quot; class=&quot;uri&quot;&gt;http://www.ex-parrot.com/~pdw/iftop/&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;=&amp;gt;代表发送数据，&amp;lt;= 代表接收数据
TX：发送流量
RX：接收流量
TOTAL：总流量
Cumm：运行iftop到目前时间的总流量
peak：流量峰值
rates：分别表示过去 2s 10s 40s 的平均流量&lt;/code&gt;
&lt;/pre&gt;

&lt;pre&gt;
&lt;code&gt;-i 指定需要检测的网卡， 如果有多个网络接口，则需要注意网络接口的选择，如：# iftop -i eth1
-B 将输出以byte为单位显示网卡流量，默认是bit
-n 将输出的主机信息都通过IP显示，不进行DNS解析 
-N 只显示连接端口号，不显示端口对应的服务名称
-F 显示特定网段的网卡进出流量  如iftop -F 192.168.85.0/24
-h 帮助，显示参数信息
-p 以混杂模式运行iftop，此时iftop可以用作网络嗅探器 ;
-P 显示主机以及端口信息
-m 设置输出界面中最上面的流量刻度最大值，流量刻度分5个大段显示  如：# iftop -m 100M
-f 使用筛选码选择数据包来计数  如iftop -f filter code
-b 不显示流量图形条
-c 指定可选的配置文件   如iftop  -c config file
-t 使用不带ncurses的文本界面，
    以下两个是只和-t一起用的：
    -s num num秒后打印一次文本输出然后退出，-t -s 60组合使用，表示取60秒网络流量输出到终端
    -L num 打印的行数
-f 参数支持tcpdump的语法，可以使用各种过滤条件。&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;一般参数&quot;&gt;一般参数：&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;P      切换暂停/继续显示
h      在交互界面/状态输出界面之间切换
b      切换是否显示平均流量图形条
B      切换显示2s 10s和40s内的平均流量
T      切换是否显示每个连接的总流量
j/k    向上或向下滚动屏幕显示当前的连接信息
f      编辑筛选码
l      打开iftop输出过滤功能 ，如输入要显示的IP按回车键后屏幕就只显示与这个IP相关的流量信息
L      切换显示流量刻度范围，刻度不同，流量图形条也会不同
q      退出iftop&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;主机参数&quot;&gt;主机参数：&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;n      使iftop输出结果以IP或主机名的方式显示
s      切换是否显示源主机信息
d      切换是否显示远端目标主机信息
t      切换输出模式,一行或多行&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;端口显示参数&quot;&gt;端口显示参数：&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;N      切换显示端口号/端口号对应服务名称
S      切换是否显示本地源主机的端口信息
D      切换是否显示远端目标主机的端口信息
p      切换是否显示端口信息&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;输出排序参数&quot;&gt;输出排序参数：&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;1/2/3  通过第一列/第二列/第三列排序
&amp;lt;      根据左边的本地主机名或IP地址进行排序
&amp;gt;      根据远端目标主机的主机名或IP地址进行排序
o      切换是否固定显示当前的连接&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;显示网卡eth0的信息主机通过ip显示&quot;&gt;1.显示网卡eth0的信息，主机通过ip显示&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;iftop -i eth0 -n&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;显示端口号添加-p参数进入界面可通过p参数关闭&quot;&gt;2.显示端口号（添加-P参数，进入界面可通过p参数关闭）&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;iftop -i eth0 -n -P&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;显示将输出以byte为单位显示网卡流量默认是bit&quot;&gt;3.显示将输出以byte为单位显示网卡流量,默认是bit&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;iftop -i eth0 -n -B&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;显示流量进度条&quot;&gt;4.显示流量进度条&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;iftop -i eth0 -n(进入界面后按下L)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;显示每个连接的总流量&quot;&gt;5.显示每个连接的总流量&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;iftop -i eth0 -n(进入界面后按下T)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;显示指定ip-172.17.1.158的流量&quot;&gt;6.显示指定ip 172.17.1.158的流量&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;iftop -i eth0 -n(进入界面后按下l,输入172.17.1.158回车)&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;网上找了一圈，全是粘贴复制的iftop命令使用，没说到点上&lt;/p&gt;
&lt;p&gt;接下，请欣赏真正的表演&lt;/p&gt;
&lt;h2 id=&quot;进入界面&quot;&gt;1.进入界面&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;iftop -i eth0 -nNB -m 10M&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;-i 指定网卡，&lt;br/&gt;-n 代表主机通过ip显示不走DNS&lt;br/&gt;-N 只显示连接端口号，不显示端口对应的服务名称(不加会显示如ssh这样的服务名称，不便于排查)&lt;br/&gt;-B 指定显示单位为Kb，默认是bit，太小！&lt;br/&gt;-m 设置输出界面中最上面的流量刻度最大值，流量刻度分5个大段显示&lt;br/&gt;进入后界面如下&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/662544/201904/662544-20190409210125203-1972088283.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;按下l显示流量刻度&quot;&gt;2.按下L显示流量刻度&lt;/h2&gt;
&lt;p&gt;L参数直接显示进度条，方便人类阅读，别说你能直接通过数字感知，小心被砍死&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/662544/201904/662544-20190409210311438-298086268.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;按下t显示总量&quot;&gt;3.按下T显示总量&lt;/h2&gt;
&lt;p&gt;总得有个总数统计，看着方便！&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/662544/201904/662544-20190409210410810-1883429367.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;按下3根据最近40s统计排序&quot;&gt;4.按下3，根据最近40s统计排序&lt;/h2&gt;
&lt;p&gt;用平均值来统计最权威点&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/662544/201904/662544-20190409210518173-21025455.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;按下t发送和接受合成一行&quot;&gt;5.按下t，发送和接受合成一行&lt;/h2&gt;
&lt;p&gt;显示两行没什么意思，一行就够了！&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/662544/201904/662544-20190409210625919-169291969.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;多按几次b查看最近2s10s40s的统计&quot;&gt;6.多按几次B，查看最近2s、10s、40s的统计&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/662544/201904/662544-20190409211010423-1486003558.png&quot;/&gt;&lt;br/&gt;没错，图中的172.17.1.158就是我们找到的流量用得最多的IP&lt;/p&gt;
&lt;h2 id=&quot;筛选指定ip-172.17.1.158&quot;&gt;7.筛选指定IP 172.17.1.158&lt;/h2&gt;
&lt;p&gt;按下l, 输入172.17.1.158，出现如下&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/662544/201904/662544-20190409211215269-1603240397.png&quot;/&gt;&lt;br/&gt;回车，生效&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/662544/201904/662544-20190409211236275-1078452279.png&quot;/&gt;&lt;br/&gt;这下就只看到这个ip的流量监控了&lt;/p&gt;
&lt;h2 id=&quot;找到这个ip哪个端口流量用得最多&quot;&gt;8.找到这个ip哪个端口流量用得最多&lt;/h2&gt;
&lt;p&gt;按下p,根据端口号显示&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/662544/201904/662544-20190409211529439-1633640505.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到这里，我们就学会了如何找出流量用得最多的ip和端口号，这么好干货你不high起来对不起哥这么用心的截图！&lt;/p&gt;
</description>
<pubDate>Tue, 09 Apr 2019 13:52:00 +0000</pubDate>
<dc:creator>雪山飞猪</dc:creator>
<og:description>一、iftop是什么 iftop是类似于top的实时流量监控工具。 作用：监控网卡的实时流量（可以指定网段）、反向解析IP、显示端口信息等 官网：http://www.ex parrot.com/~p</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenqionghe/p/10680075.html</dc:identifier>
</item>
</channel>
</rss>