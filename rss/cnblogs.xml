<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>【Go】string 也是引用类型 - 戚银</title>
<link>http://www.cnblogs.com/thinkeridea/p/10425268.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/thinkeridea/p/10425268.html</guid>
<description>&lt;p&gt;原文链接：&lt;a href=&quot;https://blog.thinkeridea.com/201902/go/string_ye_shi_yin_yong_lei_xing.html&quot; class=&quot;uri&quot;&gt;https://blog.thinkeridea.com/201902/go/string_ye_shi_yin_yong_lei_xing.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;初学 &lt;code&gt;Go&lt;/code&gt; 语言的朋友总会在传 &lt;code&gt;[]byte&lt;/code&gt; 和 &lt;code&gt;string&lt;/code&gt; 之间有着很多纠结，实际上是没有了解 &lt;code&gt;string&lt;/code&gt; 与 &lt;code&gt;slice&lt;/code&gt; 的本质，而且读了一些程序源码，也发现很多与之相关的问题，下面类似的代码估计很多初学者都写过，也充分说明了作者当时内心的纠结：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package main

import &quot;bytes&quot;

func xx(s []byte) []byte{
    ....
    
    return s
}

func main(){
    s := &quot;xxx&quot;
    
    s = string(xx([]byte(s)))
    
    s = string(bytes.Replace([]byte(s), []byte(&quot;x&quot;), []byte(&quot;&quot;), -1))
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;虽然这样的代码并不是来自真实的项目，但是确实有人这样设计，单从设计上看就很糟糕了，这样设计的原因很多人说：“&lt;code&gt;slice&lt;/code&gt; 是引用类型，传递引用类型效率高呀”，主要原因不了解两者的本质，加上文档上说 &lt;code&gt;Go&lt;/code&gt; 的引用类型有两种：&lt;code&gt;slice&lt;/code&gt; 和 &lt;code&gt;map&lt;/code&gt; ，这个在面试中也是经常遇到的吧。&lt;/p&gt;
&lt;p&gt;上面这个例子如果觉得有点基础和可爱，下面这个例子貌似并不那么容易说明其存在的问题了吧。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package main

func xx(s *string) *string{
    ....
    return s
}

func main(){
    s := &quot;xx&quot;
    
    s = *xx(&amp;amp;s)
    
    ss :=[]*string{}
    
    ss = append(ss, &amp;amp;s)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;指针效率高，我就用指针多好，可以减少内存分配呀，设计函数都接收指针变量，程序性能会有很大提升，在实际的项目中这种例子也不少见，我想通过这篇文档来帮助初学者走出误区，减少适得其反的优化技巧。&lt;/p&gt;
&lt;h2 id=&quot;slice-的定义&quot;&gt;slice 的定义&lt;/h2&gt;
&lt;p&gt;在之前 “&lt;a href=&quot;https://blog.thinkeridea.com/201901/go/shen_ru_pou_xi_slice_he_array.html&quot;&gt;【Go】深入剖析slice和array&lt;/a&gt;” 一文中说了 &lt;code&gt;slice&lt;/code&gt; 在内存中的存储模式，&lt;code&gt;slice&lt;/code&gt; 本身包含一个指向底层数组的指针，一个 &lt;code&gt;int&lt;/code&gt; 类型的长度和一个 &lt;code&gt;int&lt;/code&gt; 类型的容量， 这就是 &lt;code&gt;slice&lt;/code&gt; 的本质， &lt;code&gt;[]byte&lt;/code&gt; 本身也是一个 &lt;code&gt;slice&lt;/code&gt;，只是底层数组存储的元素是 &lt;code&gt;byte&lt;/code&gt;。下面这个图就是 &lt;code&gt;slice&lt;/code&gt; 的在内存中的状态：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1572234/201902/1572234-20190224074031812-545830588.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看一下 &lt;code&gt;reflect.SliceHeader&lt;/code&gt; 如何定义 &lt;code&gt;slice&lt;/code&gt; 在内存中的结构吧：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;type SliceHeader struct {
    Data uintptr
    Len  int
    Cap  int
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;slice&lt;/code&gt; 是引用类型是 &lt;code&gt;slice&lt;/code&gt; 本身会包含一个地址，在传递 &lt;code&gt;slice&lt;/code&gt; 时只需要分配 &lt;code&gt;SliceHeader&lt;/code&gt; 就好了， 而 &lt;code&gt;SliceHeader&lt;/code&gt; 只包含了三个 &lt;code&gt;int&lt;/code&gt; 类型，相当于传递一个 &lt;code&gt;slice&lt;/code&gt; 就只需要拷贝 &lt;code&gt;SliceHeader&lt;/code&gt;，而不用拷贝整个底层数组，所以才说 &lt;code&gt;slice&lt;/code&gt; 是引用类型的。&lt;/p&gt;
&lt;p&gt;那么字符串呢，计算机中我们处理的大多数问题都和字符串有关，难道传递字符串真的需要那么高的成本，需要借助 &lt;code&gt;slice&lt;/code&gt; 和指针来减少内存开销吗。&lt;/p&gt;
&lt;h2 id=&quot;string-的定义&quot;&gt;string 的定义&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;reflect&lt;/code&gt; 包里面也定义了一个 &lt;code&gt;StringHeader&lt;/code&gt; 看一下吧：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;type StringHeader struct {
    Data uintptr
    Len  int
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;字符串只包含了两个 &lt;code&gt;int&lt;/code&gt; 类型的数据，其中一个是指针，一个是字符串的长度，从定义上来看 &lt;code&gt;string&lt;/code&gt; 也是引用类型。&lt;/p&gt;
&lt;p&gt;借助 &lt;code&gt;unsafe&lt;/code&gt; 来分析一下情况是不是这样吧：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package main

import (
    &quot;reflect&quot;
    &quot;unsafe&quot;

    &quot;github.com/davecgh/go-spew/spew&quot;
)

func xx(s string) {
    sh := *(*reflect.StringHeader)(unsafe.Pointer(&amp;amp;s))
    spew.Dump(sh)
}

func main() {
    s := &quot;xx&quot;

    sh := *(*reflect.StringHeader)(unsafe.Pointer(&amp;amp;s))
    spew.Dump(sh)

    xx(s)
    xx(s[:1])
    xx(s[1:])
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面这段代码的输出如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;(reflect.StringHeader) {
 Data: (uintptr) 0x10f5ee0,
 Len: (int) 2
}
(reflect.StringHeader) {
 Data: (uintptr) 0x10f5ee0,
 Len: (int) 2
}
(reflect.StringHeader) {
 Data: (uintptr) 0x10f5ee0,
 Len: (int) 1
}
(reflect.StringHeader) {
 Data: (uintptr) 0x10f5ee1,
 Len: (int) 1
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以发现前三个输出的指针都是同一个地址，第四个的地址发生了一个字节的偏移，分析来看传递字符串确实没有分配新的内存，同时和 &lt;code&gt;slice&lt;/code&gt; 一样即使传递字符串的子串也不会分配新的内存空间，而是指向原字符串的中的一个位置。&lt;/p&gt;
&lt;p&gt;这样说来把 &lt;code&gt;string&lt;/code&gt; 转成 &lt;code&gt;[]byte&lt;/code&gt; 还浪费的一个 &lt;code&gt;int&lt;/code&gt; 的空间呢，需要分配更多的内存，真是适得其反呀，而且类型转换会发生内存拷贝，从 &lt;code&gt;string&lt;/code&gt; 转为 &lt;code&gt;[]byte&lt;/code&gt; 才是真的把 &lt;code&gt;string&lt;/code&gt; 底层数据全部拷贝一遍呢，真是得不偿失呀。&lt;/p&gt;
&lt;h2 id=&quot;string-的两个小特性&quot;&gt;string 的两个小特性&lt;/h2&gt;
&lt;p&gt;字符串还有两个小特性，针对字面量(就是直接写在程序中的字符串)，会创建在只读空间上，并且被复用，看一下下面的一个小例子：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package main

import (
    &quot;reflect&quot;
    &quot;unsafe&quot;

    &quot;github.com/davecgh/go-spew/spew&quot;
)

func main() {
    a := &quot;xx&quot;
    b := &quot;xx&quot;
    c := &quot;xxx&quot;
    spew.Dump(*(*reflect.StringHeader)(unsafe.Pointer(&amp;amp;a)))
    spew.Dump(*(*reflect.StringHeader)(unsafe.Pointer(&amp;amp;b)))
    spew.Dump(*(*reflect.StringHeader)(unsafe.Pointer(&amp;amp;c)))
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从输出可以了解到，相同的字面量会被复用，但是子串是不会复用空间的，这就是编译器给我们带来的福利了，可以减少字面量字符串占用的内存空间。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;(reflect.StringHeader) {
 Data: (uintptr) 0x10f5ea0,
 Len: (int) 2
}
(reflect.StringHeader) {
 Data: (uintptr) 0x10f5ea0,
 Len: (int) 2
}
(reflect.StringHeader) {
 Data: (uintptr) 0x10f5f2e,
 Len: (int) 3
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另一个小特性大家都知道，就是字符串是不能修改的，如果我们不希望调用函数修改我们的数据，最好传递字符串，高效有安全。&lt;/p&gt;
&lt;p&gt;不过有了 &lt;code&gt;unsafe&lt;/code&gt; 这个黑魔法，字符串的这一个特性也就不那么可靠了。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package main

import (
    &quot;fmt&quot;
    &quot;reflect&quot;
    &quot;strings&quot;
    &quot;unsafe&quot;
)

func main() {
    a := strings.Repeat(&quot;x&quot;, 10)

    fmt.Println(a)
    strHeader := *(*reflect.StringHeader)(unsafe.Pointer(&amp;amp;a))

    sliceHeader := reflect.SliceHeader{
        Data: strHeader.Data,
        Len:  strHeader.Len,
        Cap:  strHeader.Len,
    }

    b := *(*[]byte)(unsafe.Pointer(&amp;amp;sliceHeader))

    b[1] = 'a'

    fmt.Println(a)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从输出里面居然发现字符串被修改了, 我们没有办法直接修改字符串，但是可以利用 &lt;code&gt;slice&lt;/code&gt; 和 &lt;code&gt;string&lt;/code&gt; 本身结构的特性，创建一个 &lt;code&gt;slice&lt;/code&gt; 让它的指针指向 &lt;code&gt;string&lt;/code&gt; 的指针位置，然后借助 &lt;code&gt;unsafe&lt;/code&gt; 把这个 &lt;code&gt;SliceHeader&lt;/code&gt; 转成 &lt;code&gt;[]byte&lt;/code&gt; 来修改字符串，字符串确实被修改了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;xxxxxxxxxx
xaxxxxxxxx&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看了上面的例子是不是开始担心把字符串传给其它函数真的不会更改吗？感觉很不放心的样子，难道使用任何函数都要了解它的内部实现吗，其实这种情况极少发生，还记得之前说的那个字符串特性吗，字面量字符串会放到只读空间中，这个很重要，可以保证不是任何函数想修改我们的字符串就可以修改的。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package main

import (
    &quot;reflect&quot;
    &quot;unsafe&quot;
)

func main() {
    defer func() {
        recover()
    }()

    a := &quot;xx&quot;

    strHeader := *(*reflect.StringHeader)(unsafe.Pointer(&amp;amp;a))
    sliceHeader := reflect.SliceHeader{
        Data: strHeader.Data,
        Len:  strHeader.Len,
        Cap:  strHeader.Len,
    }
    b := *(*[]byte)(unsafe.Pointer(&amp;amp;sliceHeader))
    b[1] = 'a'
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行上面的代码发生了一个运行时不可修复的错误，就是这个特性其它函数不能确保输入字符串是否是字面量，也是不会恶意修改我们字符串的了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;unexpected fault address 0x1095dd5
fatal error: fault
[signal SIGBUS: bus error code=0x2 addr=0x1095dd5 pc=0x106c804]

goroutine 1 [running]:
runtime.throw(0x1095fde, 0x5)
    /usr/local/go/src/runtime/panic.go:608 +0x72 fp=0xc000040700 sp=0xc0000406d0 pc=0x10248d2
runtime.sigpanic()
    /usr/local/go/src/runtime/signal_unix.go:387 +0x2d7 fp=0xc000040750 sp=0xc000040700 pc=0x1037677
main.main()
    /Users/qiyin/project/go/src/github.com/yumimobi/test/a.go:22 +0x84 fp=0xc000040798 sp=0xc000040750 pc=0x106c804
runtime.main()
    /usr/local/go/src/runtime/proc.go:201 +0x207 fp=0xc0000407e0 sp=0xc000040798 pc=0x1026247
runtime.goexit()
    /usr/local/go/src/runtime/asm_amd64.s:1333 +0x1 fp=0xc0000407e8 sp=0xc0000407e0 pc=0x104da51&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;关于字符串转 &lt;code&gt;[]byte&lt;/code&gt; 在 &lt;a href=&quot;https://github.com/thinkeridea/go-extend&quot;&gt;go-extend&lt;/a&gt; 扩展包中有直接的实现，这种用法在 &lt;a href=&quot;https://github.com/thinkeridea/go-extend&quot;&gt;go-extend&lt;/a&gt; 内部方法实现中也有大量使用， 实际上因为原数据类型和处理数据的函数类型不一致，使用这种方法转换字符串和 &lt;code&gt;[]byte&lt;/code&gt; 可以极大的提升程序性能&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上面这两个函数用的好，可以极大的提升我们程序的性能，关于 &lt;code&gt;exstrings.UnsafeToBytes&lt;/code&gt; 我们转换不确定是否是字面量的字符串时就需要确保调用的函数不会修改我们的数据，这往常在调用 &lt;code&gt;bytes&lt;/code&gt; 里面的方法十分有效。&lt;/p&gt;
&lt;h2 id=&quot;传字符串和字符串指针的区别&quot;&gt;传字符串和字符串指针的区别&lt;/h2&gt;
&lt;p&gt;之前分析了传递 &lt;code&gt;slice&lt;/code&gt; 并没有 &lt;code&gt;string&lt;/code&gt; 高效，何况转换数据类型本身就会发生数据拷贝。&lt;/p&gt;
&lt;p&gt;那么在这篇文章的第二个例子，为什么说传递字符串指针也不好呢，要了解指针在底层就是一个 &lt;code&gt;int&lt;/code&gt; 类型的数据，而我们字符串只是两个 &lt;code&gt;int&lt;/code&gt; 而已，另外如果了解 &lt;code&gt;GC&lt;/code&gt; 的话，&lt;code&gt;GC&lt;/code&gt; 只处理堆上的数据，传递指针字符串会导致数据逃逸到堆上，阅读标准库的代码会有很多注释说明避免逃逸到堆上，这样会极大的增加 &lt;code&gt;GC&lt;/code&gt; 的开销，&lt;code&gt;GC&lt;/code&gt; 的成本可谓是很高的呀。&lt;/p&gt;
&lt;h2 id=&quot;疑惑&quot;&gt;疑惑&lt;/h2&gt;
&lt;p&gt;这篇文章说 “传递 &lt;code&gt;slice&lt;/code&gt; 并没有 &lt;code&gt;string&lt;/code&gt; 高效”，为什么还会有 &lt;code&gt;bytes&lt;/code&gt; 包的存在呢，其中很多函数的功能和 &lt;code&gt;strings&lt;/code&gt; 包的功能一致，只是把 &lt;code&gt;string&lt;/code&gt; 换成了 &lt;code&gt;[]byte&lt;/code&gt;， 既然传递 &lt;code&gt;[]byte&lt;/code&gt; 没有 &lt;code&gt;string&lt;/code&gt; 效率好，这个包存在的意义是什么呢。&lt;/p&gt;
&lt;p&gt;我们想一下转换数据类型是会发生数据拷贝，这个成本可是大的多呀，如果我们数据本身就是 &lt;code&gt;[]byte&lt;/code&gt; 类型，使用 &lt;code&gt;strings&lt;/code&gt; 包就需要转换数据类型了。&lt;/p&gt;
&lt;p&gt;另外我们对比两个函数来看下一下即使传递 &lt;code&gt;[]byte&lt;/code&gt; 没有 &lt;code&gt;string&lt;/code&gt; 效率好，但是标准库实现上却会导致两个函数有很大的性能差异的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;strings.Repeat&lt;/code&gt; 函数：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func Repeat(s string, count int) string {
    // Since we cannot return an error on overflow,
    // we should panic if the repeat will generate
    // an overflow.
    // See Issue golang.org/issue/16237
    if count &amp;lt; 0 {
        panic(&quot;strings: negative Repeat count&quot;)
    } else if count &amp;gt; 0 &amp;amp;&amp;amp; len(s)*count/count != len(s) {
        panic(&quot;strings: Repeat count causes overflow&quot;)
    }

    b := make([]byte, len(s)*count)
    bp := copy(b, s)
    for bp &amp;lt; len(b) {
        copy(b[bp:], b[:bp])
        bp *= 2
    }
    return string(b)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;bytes.Repeat&lt;/code&gt; 函数：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func Repeat(b []byte, count int) []byte {
    // Since we cannot return an error on overflow,
    // we should panic if the repeat will generate
    // an overflow.
    // See Issue golang.org/issue/16237.
    if count &amp;lt; 0 {
        panic(&quot;bytes: negative Repeat count&quot;)
    } else if count &amp;gt; 0 &amp;amp;&amp;amp; len(b)*count/count != len(b) {
        panic(&quot;bytes: Repeat count causes overflow&quot;)
    }

    nb := make([]byte, len(b)*count)
    bp := copy(nb, b)
    for bp &amp;lt; len(nb) {
        copy(nb[bp:], nb[:bp])
        bp *= 2
    }
    return nb
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面两个函数的实现非常相似，除了类型不同 &lt;code&gt;strings&lt;/code&gt; 包在处理完数据发生了一次类型转换，使用 &lt;code&gt;bytes&lt;/code&gt; 只有一次内存分配，而 &lt;code&gt;strings&lt;/code&gt; 是两次。&lt;/p&gt;
&lt;p&gt;我们可以借助 &lt;a href=&quot;https://godoc.org/github.com/thinkeridea/go-extend/exbytes#ToString&quot;&gt;exbytes.ToString&lt;/a&gt; 函数把 &lt;code&gt;bytes.Repeat&lt;/code&gt; 的返回没有任何成本的转换会我们需要的字符串，如果我们输入也是一个字符串的话，还可以借助 &lt;a href=&quot;https://godoc.org/github.com/thinkeridea/go-extend/exstrings#UnsafeToBytes&quot;&gt;exstrings.UnsafeToBytes&lt;/a&gt; 来转换输入的数据类型。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;s := exbytes.ToString(bytes.Repeat(exstrings.UnsafeToBytes(&quot;x&quot;), 10))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不过这样写有点太麻烦了，实际上 &lt;a href=&quot;https://godoc.org/github.com/thinkeridea/go-extend/exstrings&quot;&gt;exstrings&lt;/a&gt; 包里面正在修改 &lt;code&gt;strings&lt;/code&gt; 里面一些类似函数的问题，所有的实现基本和标准库一致，只是把其中类型转换的部分用 &lt;a href=&quot;https://godoc.org/github.com/thinkeridea/go-extend/exbytes#ToString&quot;&gt;exbytes.ToString&lt;/a&gt; 优化了一下，可以提升性能，也能提升开发效率。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/thinkeridea/go-extend/blob/master/exstrings/unsafe.go#L35&quot;&gt;exstrings.UnsafeRepeat&lt;/a&gt; 函数：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func UnsafeRepeat(s string, count int) string {
    // Since we cannot return an error on overflow,
    // we should panic if the repeat will generate
    // an overflow.
    // See Issue golang.org/issue/16237
    if count &amp;lt; 0 {
        panic(&quot;strings: negative Repeat count&quot;)
    } else if count &amp;gt; 0 &amp;amp;&amp;amp; len(s)*count/count != len(s) {
        panic(&quot;strings: Repeat count causes overflow&quot;)
    }

    b := make([]byte, len(s)*count)
    bp := copy(b, s)
    for bp &amp;lt; len(b) {
        copy(b[bp:], b[:bp])
        bp *= 2
    }
    return exbytes.ToString(b)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果用上面的函数只需要下面这样写就可以了：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;s:=exstrings.UnsafeRepeat(&quot;x&quot;, 10)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/thinkeridea/go-extend/&quot;&gt;go-extend&lt;/a&gt; 里面还收录了很多实用的方法，大家也可以多关注。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;千万不要为了使用 &lt;code&gt;[]byte&lt;/code&gt; 来优化 &lt;code&gt;string&lt;/code&gt; 传递，类型转换成本很高，且 &lt;code&gt;slice&lt;/code&gt; 本身也比 &lt;code&gt;string&lt;/code&gt; 更大一些。&lt;/li&gt;
&lt;li&gt;程序中是使用 &lt;code&gt;string&lt;/code&gt; 还是 &lt;code&gt;[]byte&lt;/code&gt; 需要根据数据来源和处理数据的函数来决定，一定要减少类型转换。&lt;/li&gt;
&lt;li&gt;关于使用 &lt;code&gt;strings&lt;/code&gt; 还是 &lt;code&gt;bytes&lt;/code&gt; 包的问题，主要关注点是数据原始类型以及想获得的数据类型来选择。&lt;/li&gt;
&lt;li&gt;减少使用字符串指针来优化字符串，这会增加 &lt;code&gt;GC&lt;/code&gt; 的开销，具体可以参考 &lt;a href=&quot;https://blog.gopheracademy.com/advent-2018/avoid-gc-overhead-large-heaps/&quot;&gt;大堆中避免大量的GC开销&lt;/a&gt; 一文。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;转载：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文作者： 戚银（&lt;a href=&quot;https://blog.thinkeridea.com/&quot;&gt;thinkeridea&lt;/a&gt;）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文链接： &lt;a href=&quot;https://blog.thinkeridea.com/201902/go/string_ye_shi_yin_yong_lei_xing.html&quot; class=&quot;uri&quot;&gt;https://blog.thinkeridea.com/201902/go/string_ye_shi_yin_yong_lei_xing.html&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;版权声明： 本博客所有文章除特别声明外，均采用 &lt;a href=&quot;http://creativecommons.org/licenses/by/4.0/deed.zh&quot;&gt;CC BY 4.0 CN协议&lt;/a&gt; 许可协议。转载请注明出处！&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 23 Feb 2019 23:41:00 +0000</pubDate>
<dc:creator>戚银</dc:creator>
<og:description>原文链接：https://blog.thinkeridea.com/201902/go/string_ye_shi_yin_yong_lei_xing.html 初学 语言的朋友总会在传 和 之间有着</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/thinkeridea/p/10425268.html</dc:identifier>
</item>
<item>
<title>前端异步技术之Promise - 蟹丸</title>
<link>http://www.cnblogs.com/ccylovehs/p/10425199.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ccylovehs/p/10425199.html</guid>
<description>&lt;pre&gt;
&lt;span&gt;从事前端的朋友或多或少的接触过Promise，当代码中回调函数层级过多你就会发现Promise异步编程的魅力，相信此文一定能帮你排忧解惑！&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;

&lt;pre&gt;
&lt;span&gt;Promise是JS异步编程中的重要概念，异步抽象处理对象，是目前比较流行Javascript异步编程解决方案之一&lt;/span&gt;&lt;br/&gt;&lt;span&gt;或许是笔者理解能力有限，对官方术语怎么也感受不到亲切，下面我来用通俗易懂的语言解释下：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Promise是一个包含三种状态的对象（pending、fulfilled、rejected），可以链式的处理异步请求（then方法）并能很好地处理异常问题，&lt;/span&gt;&lt;span&gt;是解决回调地狱的良好方案之一。&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;回调函数处理多层异步示例&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$.ajax({
    url: url1,
    success: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(rsp){
        $.ajax({
           url: url2,
           success: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(rsp){
               $.ajax({
                  url: url3,
                  success: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(rsp){
                      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;do sth&lt;/span&gt;
&lt;span&gt;                  },
                  error: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(error){
                  }
              });
           },
           error: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(error){
           }
       });
    },
    error: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(error){
    }
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;将promise封装在$.ajax中&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
$.ajax = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(config){
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Promise(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(resolve, reject){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1省略...&lt;/span&gt;
        xmlhttp.onreadystatechange = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(xmlhttp.status==200&lt;span&gt;){
                resolve(rspData);
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                reject(xmlhttp.statusText);
            }
        };
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2省略...&lt;/span&gt;
&lt;span&gt;    })
}
$.ajax({url: url1}).then(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(val){
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; $.ajax({url: val.url})
}).then(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(val){
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; $.ajax({url: val.url})
}).&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(err){
    console.log(err);
}}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;封装好的Promise处理异步可读性可维护性以及代码美观度不言而喻&lt;/span&gt;
&lt;/pre&gt;

&lt;h2&gt;'new' Promise&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;pending状态的promise&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; promise = &lt;span&gt;new&lt;/span&gt; Promise(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(resolve, reject){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;do sth&lt;/span&gt;
&lt;span&gt;})
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;fulfilled状态的promise&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; promise = Promise.resolve(1).then(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; resolve(value){console.log(value)});
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; var promise = new Promise(function(resolve){resolve(1)})&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;rejected状态的promise&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; promise = Promise.reject(&lt;span&gt;new&lt;/span&gt; Error('error')).&lt;span&gt;catch&lt;/span&gt;(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(error){console.error(error)});
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; var promise = new Promise(function(resolve,reject){resolve(new Error('error'))})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Promise.prototype.then&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Promise#then
promise.then(onFulfilled, onRejected)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;返回一个新的promise。&lt;/span&gt;&lt;span&gt;这里经常会有一个疑问：为什么不返回原来的promise，个人是这样认为的，若返回同一个promise则状态不一致，&lt;/span&gt;&lt;span&gt;promise规范说明当pending至fulfilled/rejected时状态确定后不能再改变。&lt;/span&gt;
&lt;/pre&gt;
&lt;h2&gt;Promise.prototype.catch&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Promise#&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;
promise.&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(error){
    &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Error(error);
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;注意：IE8及以下版本会出现 identifier not found 的语法错误，可将点标记法改为中括号标记法&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
promise['catch'](&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(error){
    &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Error(error);
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;rejected状态的promise抛出异常&lt;/span&gt;&lt;br/&gt;&lt;span&gt;相当于&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
promise.then(undefined, onRejected)
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;then &amp;amp; catch 结合示例&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
promise.then(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; f1(value){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;do sth 1&lt;/span&gt;
}).then(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; f2(value){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;do sth 2&lt;/span&gt;
}).then(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; f3(value){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;do sth 3&lt;/span&gt;
}).&lt;span&gt;catch&lt;/span&gt;(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(error){
    console.log(error);
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Promise.prototype.finally&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
promise.&lt;span&gt;finally&lt;/span&gt;(onFinally)
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;返回一个Promise，在promise执行结束时，无论结果是fulfilled或者是rejected，在执行then()和catch()后，都会执行&lt;/span&gt;
&lt;/pre&gt;
&lt;h2&gt;Promise.all&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
promise.all([promise1, promise2, promise3]).then(resolve);
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;示例&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; `delay`毫秒后执行resolve&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; timerPromisefy(delay) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Promise(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (resolve) {
        setTimeout(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
            resolve(delay);
        }, delay);
    });
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; startDate =&lt;span&gt; Date.now();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 所有promise变为resolve后程序退出&lt;/span&gt;
&lt;span&gt;Promise.all([
    timerPromisefy(&lt;/span&gt;1&lt;span&gt;),
    timerPromisefy(&lt;/span&gt;32&lt;span&gt;),
    timerPromisefy(&lt;/span&gt;64&lt;span&gt;),
    timerPromisefy(&lt;/span&gt;128&lt;span&gt;)
]).then(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (values) {
    console.log(Date.now() &lt;/span&gt;- startDate + 'ms'&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 约128ms&lt;/span&gt;
    console.log(values);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; [1,32,64,128]&lt;/span&gt;
});
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;在接收到所有的对象promise都变为 FulFilled 返回一个resolve(array)，或者 某一个promise对象变成Rejected 状态返回resolve(err)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;传递给 Promise.all 的promise并不是一个个的顺序执行的，而是同时开始、并行执行的。&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;h2&gt;Promise.race&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
promise.race([promise1, promise2]).then(resolve, reject)
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;示例&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; `delay`毫秒后执行resolve&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; timerPromisefy(delay) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Promise(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (resolve) {
        setTimeout(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
            resolve(delay);
        }, delay);
    });
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 任何一个promise变为resolve或reject 的话程序就停止运行&lt;/span&gt;
&lt;span&gt;Promise.race([
    timerPromisefy(&lt;/span&gt;1&lt;span&gt;),
    timerPromisefy(&lt;/span&gt;32&lt;span&gt;),
    timerPromisefy(&lt;/span&gt;64&lt;span&gt;),
    timerPromisefy(&lt;/span&gt;128&lt;span&gt;)
]).then(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (value) {
    console.log(value);    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; =&amp;gt; 1&lt;/span&gt;
});
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;只要有一个promise对象进入 FulFilled 或者 Rejected 状态的话，就会继续进行后面的处理。&lt;/span&gt;&lt;/pre&gt;

&lt;h2&gt;promise-polyfill.js&lt;/h2&gt;
&lt;pre&gt;
&lt;span&gt;学习完Promise后，必定要重写Promise，后续遇到浏览器环境不支持也可有的放矢&lt;/span&gt;&lt;br/&gt;&lt;span&gt;代码如下&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;73&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * @author chenchangyuan
 * @date 2019-02-23
 * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Promise(executor){
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;typeof&lt;/span&gt; executor !== 'function'&lt;span&gt;){
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Error('executor is not a function'&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; self = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
    self.state &lt;/span&gt;= 'pending';&lt;span&gt;//&lt;/span&gt;&lt;span&gt;pending fulfilled rejected&lt;/span&gt;
    self.value = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    self.reason &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    self.callbackResolveFn &lt;/span&gt;=&lt;span&gt; [];
    self.callbackRejectFn &lt;/span&gt;=&lt;span&gt; [];
    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; resolve(value){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(self.state === 'pending'&lt;span&gt;){
            self.state &lt;/span&gt;= 'fulfilled'&lt;span&gt;;
            self.value &lt;/span&gt;=&lt;span&gt; value;
            self.callbackResolveFn.forEach(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(fn){
                fn();
            });
        }
    }
    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; reject(reason){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(self.state === 'pending'&lt;span&gt;){
            self.state &lt;/span&gt;= 'rejected'&lt;span&gt;;
            self.reason &lt;/span&gt;=&lt;span&gt; reason;
            self.callbackRejectFn.forEach(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(fn){
                fn();
            });
        }
    }
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
        executor(resolve, reject);
    }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(err){
        reject(err);
    }
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;回溯函数&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; resolvePromise(promise, x, resolve, reject){
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(promise === x) &lt;span&gt;return&lt;/span&gt; reject(&lt;span&gt;new&lt;/span&gt; TypeError('循环引用'&lt;span&gt;));
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; flag = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(x !== &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; (&lt;span&gt;typeof&lt;/span&gt; x === 'object' || &lt;span&gt;typeof&lt;/span&gt; x === 'function'&lt;span&gt;)){
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; then =&lt;span&gt; x.then;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;typeof&lt;/span&gt; then === 'function'&lt;span&gt;){
                then.call(x, &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(val){
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(flag) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                    flag &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                    resolvePromise(promise, val, resolve, reject);
                }, &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(err){
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(flag) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                    flag &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                    reject(err);
                });
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                resolve(x);
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(err){
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(flag) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            flag &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            reject(err);
        }

    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
        resolve(x);
    }
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回一个新的promise（pending：push(fn),fulfilled:resolve(val),rejected:reject(reason)）&lt;/span&gt;
Promise.prototype.then = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(onFulfilled, onRejected){
    onFulfilled &lt;/span&gt;= &lt;span&gt;typeof&lt;/span&gt; onFulfilled === 'function' ? onFulfilled : &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(value){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; value;
    };
    onRejected &lt;/span&gt;= &lt;span&gt;typeof&lt;/span&gt; onRejected === 'function' ? onRejected : &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(err){
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Error(err);
    };
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; self = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;,
        promise2;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(self.state === 'fulfilled'&lt;span&gt;){
        promise2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Promise(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(resolve, reject){
            setTimeout(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将x处理成一个原始值&lt;/span&gt;
                    &lt;span&gt;var&lt;/span&gt; x =&lt;span&gt; onFulfilled(self.value);
                    resolvePromise(promise2, x, resolve, reject);
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(e){
                    reject(e);
                }
            })
        })
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(self.state === 'rejected'&lt;span&gt;){
        promise2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Promise(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(resolve, reject){
            setTimeout(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将x处理成一个原始值&lt;/span&gt;
                    &lt;span&gt;var&lt;/span&gt; x =&lt;span&gt; onRejected(self.reason);
                    resolvePromise(promise2, x, resolve, reject);
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(e){
                    reject(e);
                }
            })
        })
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(self.state === 'pending'&lt;span&gt;){
        promise2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Promise(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(resolve, reject){
            self.callbackResolveFn.push(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
                setTimeout(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将x处理成一个原始值&lt;/span&gt;
                        &lt;span&gt;var&lt;/span&gt; x =&lt;span&gt; onFulfilled(self.value);
                        resolvePromise(promise2, x, resolve, reject);
                    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(e){
                        reject(e);
                    }
                })
            });
            self.callbackRejectFn.push(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
                setTimeout(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将x处理成一个原始值&lt;/span&gt;
                        &lt;span&gt;var&lt;/span&gt; x =&lt;span&gt; onRejected(self.reason);
                        resolvePromise(promise2, x, resolve, reject);
                    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(e){
                        reject(e);
                    }
                })
            });
        })
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; promise2;
}
Promise.prototype[&lt;/span&gt;'catch']= &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (callback) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.then(undefined, callback)
}
Promise.all &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (promises) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Promise(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (resolve, reject) {
        let arr &lt;/span&gt;=&lt;span&gt; [];
        let i &lt;/span&gt;= 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; processData(index, y) {
            arr[index] &lt;/span&gt;=&lt;span&gt; y;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (++i ===&lt;span&gt; promises.length) {
                resolve(arr);
            }
        }
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (let i = 0; i &amp;lt; promises.length; i++&lt;span&gt;) {
            promises[i].then(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (y) {
                processData(i, y)
            }, reject)
        }
    })
}
Promise.race &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (promises) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Promise(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (resolve, reject) {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; promises.length; i++&lt;span&gt;) {
            promises[i].then(resolve,reject)
        }
    });
}
Promise.resolve &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(value){
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Promise(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(resolve,reject){
        resolve(value);
    });
}
Promise.reject &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(reason){
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Promise(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(resolve,reject){
        reject(reason);
    });
}
Promise.defer &lt;/span&gt;= Promise.deferred = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; d =&lt;span&gt; {};
    d.promise &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Promise(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (resolve, reject) {
        d.resolve &lt;/span&gt;=&lt;span&gt; resolve;
        d.reject &lt;/span&gt;=&lt;span&gt; reject;
    });
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; d
}
module.exports &lt;/span&gt;= Promise;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;promise-aplus-tests&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;由于是参（抄）考（袭）前辈的polyfill，自己编码测试时出现了两处错误，ES6 Promise 规范的2.3.1和2.3.4&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.3.1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/996357/201902/996357-20190224014114564-1790351484.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;2.3.4&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/996357/201902/996357-20190224014139697-1165203502.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;经过改正测试成功&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/996357/201902/996357-20190224014158871-1418670613.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;你们的支持是我最大的动力，熬夜码字不易，如果此文对你有帮助，请不吝star---&amp;gt;&lt;a title=&quot;github&quot; href=&quot;https://github.com/chenchangyuan/promise&quot; target=&quot;_blank&quot;&gt;https://github.com/chenchangyuan/promise&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;有兴趣加笔者好友的同学请扫描下方二维码（1.本人微信，2.微信公众号，3.技术交流微信群），愿与您成为好友共同探讨技术，畅聊生活！&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/996357/201902/996357-20190224021746542-1083274062.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;a title=&quot;Promise/A+&quot; href=&quot;https://promisesaplus.com/&quot; target=&quot;_blank&quot;&gt;https://promisesaplus.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;Promise迷你书&quot; href=&quot;http://liubin.org/promises-book&quot; target=&quot;_blank&quot;&gt;http://liubin.org/promises-book&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;掘金&quot; href=&quot;https://juejin.im/post/5ab20c58f265da23a228fe0f&quot; target=&quot;_blank&quot;&gt;https://juejin.im/post/5ab20c58f265da23a228fe0f&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 23 Feb 2019 18:26:00 +0000</pubDate>
<dc:creator>蟹丸</dc:creator>
<og:description>前言 Promise概念 Promise API 'new' Promise Promise.prototype.then Promise.prototype.catch Promis</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ccylovehs/p/10425199.html</dc:identifier>
</item>
<item>
<title>XX银行面试 - 夏天里的Jasmine</title>
<link>http://www.cnblogs.com/qianjinyan/p/10425065.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qianjinyan/p/10425065.html</guid>
<description>&lt;p&gt;&lt;span&gt;LZ在一个18线小城市做测试，近来想走出自己的舒适区，去做一点不一样的测试工作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;18线地区，测试工作并不多。最好的差不多就是LZ目前待着的公司了。遂决定去魔都闯荡几年，对一个在魔都无房无车无户口的人来讲，这意味着很累，然人无远虑必有近忧。即使有一天你的城市通地铁和高铁了，来了一群优质的互联网公司，我除了离得近，有配得上的技能嘛。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;XX银行面试&lt;/span&gt;&lt;br/&gt;&lt;span&gt;年前在BOSS直聘上投递的简历，年后约面试。我要求先电话面试一轮再去。【这里说一下有的公司招人职位要求和面试要求完全不一致，毕竟魔都里的有些远，不想浪费一次年假和自己的无奈，去验证他们的jd和面试内容。】电话里了解到他们想招Java能力好一些的测试人员，以后的工作内容是自动化测试，并且开发一些测试平台和加密解密系统。是我感兴趣的部分...不敢十拿九稳，但想试一下。于是就约了周一10点面试。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;一面&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;提前一个小时到，问了问hr是否方便过去，HR让我直接上去。我就拖着热水袋，开心地乘电梯去了10楼。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;HR将我领到会议室，填了个人信息表，调查表，一会儿之后来了一个高个子瘦瘦的面试官。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 用JAVA怎么读取文件中的内容？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Property p = new Property；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;读取输入流获取的内容&lt;/span&gt;&lt;br/&gt;&lt;span&gt;那要是多个文件，也用这个读吗？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;LZ基础太薄弱，想不出别的方法。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;你有没有想到这种读文件方式的弊端？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;LZ一脸茫然。。。【心更凉，白来了么，亏我5点多就乘着大巴冒着雨赶过来，这种面试题完全没遇到过，工作中亦未遇到过。】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.设计模式了解吗？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;饱汉模式，饿汉模式，工厂模式，spring mvc模式&lt;/span&gt;&lt;br/&gt;&lt;span&gt;不对。饱汉模式，饿汉模式不是设计模式，是单例模式中的。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;哦，是的，我记错了。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;设计模式一共有22种左右。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;嗯嗯。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;你手写个单例模式可以吗？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;拿着笔，在自己刚填内容背面，手写着，心中记着单例模式重点叫私有什么来着，&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private class a｛｝&lt;/span&gt;&lt;br/&gt;&lt;span&gt;又想着单例模式中饱汉饿汉的区别，哪一种安全，还没写完，面试官就说:&quot;我一看你写的就知道你写错了&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;没关系，有些开发也不知道。只要你愿意学，我就可以教你。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;【这是我听到的能让我坚持下继续面试的话】&lt;/span&gt;&lt;br/&gt;&lt;span&gt;【面试官】我想招个开发能力强的人，我没空去写比如加密解密的代码，需要别人来写完。框架我都搭好了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.说说你们的测试流程&lt;/span&gt;&lt;br/&gt;&lt;span&gt;我们，巴拉巴拉，接到需求后，会有一个需求文档，通过邮件的形式发给整个项目组，包括PM，开发，测试和支持。并约定一个接下来的时间，进行启动大会kick off meeting&lt;/span&gt;&lt;br/&gt;&lt;span&gt;每个人对需求文档，提出自己的问题，比如与以往的需求，是否有冲突的地方。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;比如需求实现的方式，是通过接口，还是存储过程，是通过用mq同步数据的方式，还是代码中跨数据库，那是否同一个操作要实现跨数据库的事务等等。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;然后带着这些问题，参加启动大会，项目中的每个人提出来，最后总结具体实现的方式，覆盖的范围。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;假设是接口的话，会详细到接口的字段，字段长度，必填性，字符类型等等，这边主要是测试和开发，会在会议上定好哪些代码中一定要校验，很多情况下，不定的细致，接口校验会漏掉，觉得页面UI已经有了。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;会议结束后，开发人员会将接口文档发给项目中的每个人。这个时候测试人员，要检查接口文档，检查字符长度是否和DB中长度，是否有超过DB中长度；检查异常中返回值和信息是否正确。检查最终数据流相关的字段是否准确。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;检查正常的有复杂逻辑关系的，逻辑顺序是否正确。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;不正确，提出，正确，回复邮件。之后，测试人员，编写测试用例，发给项目中的人员进行评审。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;之后，编写case并构造入参数据，断言，DB中检验，等等。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;等开发提交代码后，进行测试，有bug则提bug，之后再对全部case回归测试。balabala。。。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4. 我们这儿有个接口，有158个入参，其中有100个入参。对100个入参必填做校验。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;比我们接口中参数要多很多，目前我们有脚本，对少数的入参，只能填写变量名，长度，断言就可以一次性走完异常测试场景。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;你们100个入参，有些多，需要根据接口文档动态生成测试脚本，包括测试用例描述，测试数据，测试结构断言。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;【面试官】我的想法是100个必填入参，用java代码，依次判断，就是100个循环，单独测任何一个入参的必填；在随机个数的参数，不填，验证必填参数的异常。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;我目前在开发测试平台，创建一个对象，包含变量名称，必填性，字符类型，字符长度，范围比如是int型有的referrence表传过来的只能1-10，一个接口中的入参，将是一个list，list中每个对象，根据&lt;/span&gt;&lt;br/&gt;&lt;span&gt;必填这个属性，生成一个list。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;list中依次遍历，每次少一个对象变量名称，那测试用例依次生成未传入某某变量，测试数据，其他的变量和值依次拼接起来，map方式，map的key是字段名，value是自动生成的值，value需要在符合的长度内，值的范围也必须在。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;代码都能实现。一般一个项目的请求体的格式一致的，比如现在常用的json格式，拼接一下key value，前后大括号，等等，最终测试数据也生成。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;断言部分同理，可生成。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;这个平台我在构思和开始设计表结构，实现方式，还未成功。关于你说的再随意若干个字段不传，我一般不会有这个样的case。原因是，java代码中判断入参不传，有先后顺序，你这个随机不传，断言要怎么写。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;还是你们所有的必传入参不全，返回信息是同样的？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;【面试官开始对我有好转了】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5. 说到我上面的接口测试用例自动生成平台，我的确开始在做。索性趁热打铁，我说了下我已经完成了项目&lt;/span&gt;&lt;br/&gt;&lt;span&gt;我自己用springboot写了一个mini的bug管理平台，都增加了些什么功能呢？ 登录授权后，查看这个项目下，各个测试类型的bug。并且是基于我们公司的情况，&lt;/span&gt;&lt;br/&gt;&lt;span&gt;比如每次任务需要一个CR，没有CR是不做的，CR下来了我们公司还需要有任务编号，等等。说简单了是CRUD，说到CRUD，数据处理层使用JDBCTemplate实现的，页面用的Thymeleaf模板引擎。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;还加了定时，根据bug中的更新时间，每15分钟将更新时间距离当前时间小于等于15分钟的bug信息，逐条发送给测试人员和开发人员。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;这个和JIRA、bugtracker等不同，是个定时任务用来发邮件。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;系统出来了之后，要一下子录入原来的bug，一条一条很不方便，我创建了一个jmx脚本，其实就是一个简单的请求，以往测试人员会将测试用例，以excel大多这样的形式保存在本地，脚本中只要填写项目id等信息，可通过类似性能测试的方式，一次导入所有的bug，丰富bug系统，将以往工作中的bug全部呈现在一个平台上了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这之后又编写了测试用例管理平台，差不多的原理，这个时候数据处理改成了mybatis，因为涉及的表更多了，用mybaits方便。我们测试的内容有接口，有UI，有存储过程，测试用例格式不太一致，所有测试任务一张表，然后之后具体的测试用例是根据测试类型，分别新增到对应的3张表。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;balabala。。。后来也给大家提供了Jmeter创建的脚本，配置好项目名称等信息后，可一次性导入以往保留在本地的所有测试用例。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6. springboot中mysql是自带的，很方便？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;不是。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;mysql是自带的？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;不是，需要引入mysql驱动jar包依赖的。况且我开发的时候，本地连接的是mysql，后来导成jar包，不能用我本地数据库，我们公司用的sqlserver&lt;/span&gt;&lt;br/&gt;&lt;span&gt;我尽量保证sql一致性，分页部分无法一致，就改一两行代码。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;7. 有没有bug？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;有。【哈哈哈】&lt;/span&gt;&lt;br/&gt;&lt;span&gt;什么bug？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;小bug。bug邮件提醒部分，我们公司的邮箱是outlook，outlook是什么公司，微软，打开后bug信息的具体描述，本来是textarea格式，应当是分行显示的，但是没有分行。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;然后你用手机打开，手机一般是苹果和安卓嘛，邮箱中打开是没有问题的。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;这个也不能算bug。模板引擎不能保持兼容所有的浏览器，很多UI方便的东西，开始抛弃IE，抛弃微软了&lt;/span&gt;&lt;br/&gt;&lt;span&gt;对对对。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;有别的bug吗？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;有，我自己知道，使用者暂时还不知道，我就暂未改。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;什么bug？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;额，比如，展示所有bug页面，既有多重查询后，显示符合条件的bug，bug页面最右下角有分页。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;因为我分页用的是get请求方法，而多重查询用的是POST请求方法，目前在不输如任何查询条件的情况下，分页功能完全OK&lt;/span&gt;&lt;br/&gt;&lt;span&gt;输入查询条件，不管一个或者多个，第一个ok，接下来查的是所有bug，不再有查询条件的限制啦。【呵呵】&lt;/span&gt;&lt;br/&gt;&lt;span&gt;为什么没被发现？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;bug倒序显示，其次是查询条件限制后，查出来bug较少。所有一般不被发现。查询条件嘛，为了精准查询。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;8. 我们这边的人员分配是xx个外包，其他是JF，只有一个人是行编制，当然这个人不是我。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;你如果进来，是JF，和我一样，待遇上和行编制差不多，比外包要好一些。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;9. 你们冒烟测试怎么个流程？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;额，比如接口测试，冒烟测试是指囊括原来的所有的功能都要正常对吧，额，我们的开发将代码提交到git上，通过Jenkins自动部署到服务器上的指定的中间件之后，重启中间件，热部署有时候总有问题。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;中间件重启之后，自动运行编写好的自动化测试用例，用例包含正确的断言验证，DB数据验证，异常场景的断言验证，之后会发出一封测试报告。测试报告全部通过，则表明OK；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;【面试官】呵呵，据我了解，冒烟测试是针对修改项或者新增的功能所做的测试？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;哦，那开发会有自测并子自测成功后，将转测邮件发出，转测邮件上写着xx验证什么ok。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;但是，如果开发转测的功能，本次涉及到的自测了没问题，但是影响到了以往的接口，我依然不会开始测试的。我的自动化测试脚本在呢。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;【面试官】呵呵。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;还没轮到LZ提问，面试官说我去喊我领到来，走的时候顺便说了句，你在我这边是OK的，没问题的。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;我诚恳说了句谢谢。&lt;/span&gt;&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;&lt;span&gt;二面&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;一会儿进来了二面面试官。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1. 刚刚一面面了多久？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;LZ看了下手机，40分钟。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;你们都面了什么？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;LZ开口就说，想到什么说什么。说得比较混乱。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;那你们面的什么呢？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;LZ总结了下，JAVA,测试流程，做过的项目&lt;/span&gt;&lt;br/&gt;&lt;span&gt;面试官终于问别的了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 自我介绍一下吧&lt;/span&gt;&lt;br/&gt;&lt;span&gt;balabala。。。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;为什么要转岗到测试？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;巴拉巴拉，无非是离境数据管理条例，balabala&lt;/span&gt;&lt;br/&gt;&lt;span&gt;你们是营销型公司？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;balabala。。。。主要是通过。。。。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;薅羊毛？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;LZ一脸茫然。。后来才反应过来面试官是觉得我们公司是个薅羊毛公司。替知名企业各个行业的Top10做精准数据营销。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3. 说一说测试人员对数据库的认识？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;LZ听不懂。。。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;面试官复问&lt;/span&gt;&lt;br/&gt;&lt;span&gt;LZ答 要有数据库读的权限，产品一旦上线很长时间，每次修改，DB中数据会有一些不是我们期望的那样，比如姓名中可能存在全角字符，中英文还夹杂着数字&lt;/span&gt;&lt;br/&gt;&lt;span&gt;LZ继续答，数据库连接要注意数据库的安全，用堡垒机或者citrics进行连接&lt;/span&gt;&lt;br/&gt;&lt;span&gt;【LZ搞不清楚面试官想问我什么】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4. 你们需要写ppt吗？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;不需要。作为测试，几乎不用写。写文档倒是比较多。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;【LZ也搞不清楚这个问题是想问什么】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5. 你是不是有小孩了？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;balabal...&lt;/span&gt;&lt;br/&gt;&lt;span&gt;你不是本地的，在本地有房吗？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;balabala...&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;6. 说说你们公司薅羊毛？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;LZ应该用资本家就是赚取剩余价值来怼这句话，可惜没有勇气。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;薅羊毛，黑产才通常薅我们的羊毛呢？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;【面试官愿闻其详的样子】&lt;/span&gt;&lt;br/&gt;&lt;span&gt;我讲了一个短信验证码攻击的事件，在我随笔中有分析过验证码的安全性和有效性，【短信的横向轰炸和纵向轰炸】连接&lt;a href=&quot;https://www.cnblogs.com/qianjinyan/p/9559003.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/qianjinyan/p/9559003.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;7. 你简历上PMP证书是什么？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;项目管理&lt;/span&gt;&lt;br/&gt;&lt;span&gt;考了证书对你的工作有什么用？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;没什么用。。【LZ太任性了太2b了】&lt;/span&gt;&lt;br/&gt;&lt;span&gt;没什么用？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;考之前是这么管理的，考过之后也是这样。【当时的我是怎么了？】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;说说你的薪资期望？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;balabala&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;你目前多少？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;balabal， 但是我们公司福利很好，每个季度有季度奖金，且一年有一个月的带薪年假，15天的带薪病假，还有出国旅游。公积金缴纳的是12%。每天有不限量的免费水果，还有股票奖励等。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;8.&lt;/span&gt;&lt;/span&gt;&lt;span&gt;有没有什么问题想问我的了？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;【该知道的，工作内容，需要的技能我都知道了，接下来也该问hr了】摇头。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;就没有什么想问我的？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;我心抖，凉凉中。刚刚对于PMP的回答会影响我吗？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;面试官看了看，回答道：会。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;我带头哀思中，想着要不要恳求一个重答的机会。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;面试官说，会有影响，也是我自己问题问的不好。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;后来二面面试官走了，叫来一面面试官。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;没有HR面，一面面试官送我走了，还问我面得怎样，我语气沉重，艰难地说还行。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;一面面试官看来觉得没有问题，来问我什么时候能到岗。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;学位学历是不是可查的？我说是的。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;&lt;span&gt;后来我就撑着伞，离开了，周一面的，周五也没有收到任何通知。凉凉。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 23 Feb 2019 16:36:00 +0000</pubDate>
<dc:creator>夏天里的Jasmine</dc:creator>
<og:description>LZ在一个18线小城市做测试，近来想走出自己的舒适区，去做一点不一样的测试工作。 18线地区，测试工作并不多。最好的差不多就是LZ目前待着的公司了。遂决定去魔都闯荡几年，对一个在魔都无房无车无户口的人</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qianjinyan/p/10425065.html</dc:identifier>
</item>
<item>
<title>Neo4j入门之中国电影票房排行浅析 - jclian91</title>
<link>http://www.cnblogs.com/jclian91/p/10425058.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jclian91/p/10425058.html</guid>
<description>&lt;h3 id=&quot;什么是neo4j&quot;&gt;什么是Neo4j?&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9419034-f8cacfeb404531fe.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  Neo4j是一个高性能的NoSQL图形数据库（Graph Database），它将结构化数据存储在网络上而不是表中。它是一个嵌入式的、基于磁盘的、具备完全的事务特性的Java持久化引擎，但是它将结构化数据存储在网络(从数学角度叫做图)上而不是表中。Neo4j也可以被看作是一个高性能的图引擎，该引擎具有成熟数据库的所有特性。&lt;br/&gt;  作为图形数据库，Neo4j最让人惊喜的功能就是它可以直观地展示图，也就是节点与节点之间的关系，当然，它还有其它的优势，比如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;很容易表示连接的数据；&lt;/li&gt;
&lt;li&gt;检索/遍历/导航更多的连接数据是非常容易和快速的；&lt;/li&gt;
&lt;li&gt;能轻松地表示半结构化数据；&lt;/li&gt;
&lt;li&gt;Neo4j CQL查询语言命令类似于SQL，可读性好，容易学习；&lt;/li&gt;
&lt;li&gt;使用简单而强大的数据模型；&lt;/li&gt;
&lt;li&gt;不需要复杂的连接来检索连接的/相关的数据。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;  在本文中，笔者希望能够通过一个简单的例子来展示Neo4j的使用以及它的强大之处，这无疑更适合于初学者，因为笔者也是刚入门。&lt;br/&gt;  以下，笔者并不会过多地介绍Neo4j的操作，只是希望读者能对Neo4j的功能有直观的感受，至于教程之类的，可以参考文章最后的参考文献。&lt;br/&gt;  下面，让我们进入本次的Neo4j之旅~&lt;/p&gt;
&lt;h3 id=&quot;项目展示&quot;&gt;项目展示&lt;/h3&gt;
&lt;p&gt;  由于《流浪地球》的大热以及笔者对此的欣赏，因此，此次的项目为分析中国电影票房排行。我们的数据来自于百度百科，用&lt;code&gt;爬虫&lt;/code&gt;得到我们需要的数据，主要是电影的相关信息，如排名，票房，上映日期等，以及电影的主演。将数据储存为CSV文件，并导入至Neo4j，最后得到电影的简单分析及可视化。&lt;br/&gt;  整个项目主要是以下三步：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;数据获取：利用爬虫实现；&lt;/li&gt;
&lt;li&gt;数据导入：利用Py2neo实现；&lt;/li&gt;
&lt;li&gt;数据展示：利用Neo4j实现。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其中，Py2neo为Neo4j的Python接口。&lt;br/&gt;  整个项目的结构如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9419034-54a4bbbf1dec7837.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;电影票房项目&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  接下来，笔者将详细地介绍每一步的操作及代码，let's go ~&lt;/p&gt;
&lt;h3 id=&quot;数据获取&quot;&gt;数据获取&lt;/h3&gt;
&lt;p&gt;  数据的获取始终是一个重要的问题，好在我们有爬虫这个工具。为了能够展示中国电影票房排行中的电影信息以及演员与电影的关系，首先的重要一步就是获取我们需要的需要。&lt;br/&gt;  我们需要两份数据。第一份数据，就是中国电影票房排行数据，网址为：&lt;a href=&quot;https://baike.baidu.com/item/%E4%B8%AD%E5%9B%BD%E7%94%B5%E5%BD%B1%E7%A5%A8%E6%88%BF/4101787?fr=aladdin%EF%BC%8C%E9%A1%B5%E9%9D%A2%E5%A6%82%E4%B8%8B&quot;&gt;https://baike.baidu.com/item/%E4%B8%AD%E5%9B%BD%E7%94%B5%E5%BD%B1%E7%A5%A8%E6%88%BF/4101787?fr=aladdin，页面如下&lt;/a&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9419034-b1d00efba00cb3d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;中国电影票房_百度百科&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  我们制作爬虫，将这个表格爬取下来，并将表格的第一行（字段名称）作为电影的相关信息，然后储存为movies.csv。整个过程的Python代码（movie.py）如下：（因为这是公开数据，这个爬虫是合理的。）&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# -*- coding: utf-8 -*-

import requests
import pandas as pd
from bs4 import BeautifulSoup

url = &quot;https://baike.baidu.com/item/%E4%B8%AD%E5%9B%BD%E7%94%B5%E5%BD%B1%E7%A5%A8%E6%88%BF/4101787&quot;
# 请求头部
headers = {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.87 Safari/537.36'}
r = requests.get(url, headers=headers)
soup = BeautifulSoup(r.text.encode('ISO-8859-1'),'lxml')
table = soup.find('table')('tr')

movies = []
for line in table[1:]:
   movie = {'rank': int(line('td')[0].text),
                 'src': line('td')[1]('a')[0]['href'],
                 'name': line('td')[1].text,
                 'box_office': line('td')[2].text,
                 'avg_price': int(line('td')[3].text),
                 'avg_people': int(line('td')[4].text),
                 'begin_date': line('td')[5].text.strip(),
                 }
   # print(movie)
   movies.append(movie)

# print(movies)

df = pd.DataFrame({'rank': [movie['rank'] for movie in movies],
                  'src': [movie['src'] for movie in movies],
                  'name': [movie['name'] for movie in movies],
                  'box_office': [movie['box_office'] for movie in movies],
                  'avg_price': [movie['avg_price'] for movie in movies],
                  'avg_people': [movie['avg_people'] for movie in movies],
                  'begin_date': [movie['begin_date'] for movie in movies]
                  })
# print(df.head())
df.to_csv(r'./movies.csv', index=False)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  movies.csv中的数据如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9419034-6f856c64491c7584.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;movies.csv&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  OK，第二份数据，每部电影（共20部）的主演，以《流浪地球》为例，网址为：&lt;a href=&quot;https://baike.baidu.com/item/%E6%B5%81%E6%B5%AA%E5%9C%B0%E7%90%83/16278407%EF%BC%8C%E9%A1%B5%E9%9D%A2%E5%A6%82%E4%B8%8B&quot;&gt;https://baike.baidu.com/item/%E6%B5%81%E6%B5%AA%E5%9C%B0%E7%90%83/16278407，页面如下&lt;/a&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9419034-4ce8d7c3722f154b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;流浪地球&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们只需要爬取每部电影的主演就够了，也就是上图中的红色部分，实现的Python代码（actor.py）如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# -*- coding: utf-8 -*-

import requests
import pandas as pd
from bs4 import BeautifulSoup

def get_actors(src):
    url = &quot;https://baike.baidu.com&quot;+src
    # 请求头部
    headers = {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.87 Safari/537.36'}
    r = requests.get(url, headers=headers)
    soup = BeautifulSoup(r.text.encode('ISO-8859-1'),'lxml')
    names = soup.find_all('dt', class_=&quot;basicInfo-item name&quot;)
    values = soup.find_all('dd', class_=&quot;basicInfo-item value&quot;)

    actors = []
    for name, value in zip(names, values):
        # print(name.text)
        if '主' in name.text and '演' in name.text:
            # print(name.text.replace('    ', ''), value.text)
            actors = value.text.strip().split('，')
            actors = [actor.strip().replace('\xa0', '').replace('\n[6]', '') for actor in actors if actor]
    # print(actors)
    return '，'.join(actors)

df = pd.read_csv('./movies.csv')

actors_list = []
for name, src in zip(list(df['name']), list(df['src'])):

    actors = get_actors(src)
    # print(name, actors)
    actors_list.append(actors)

new_df = pd.DataFrame({'actors': actors_list})
new_df['name'] = df['name']
# print(new_df)
new_df.to_csv(r'./actors.csv', index=False)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  生成的actor.csv数据如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9419034-f2f3b9cc060f8b7d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;actor.csv&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  OK，数据收集的任务就到此完成了，有了爬虫，轻松搞定数据难题。&lt;/p&gt;
&lt;h3 id=&quot;导入数据&quot;&gt;导入数据&lt;/h3&gt;
&lt;p&gt;   接着，我们需要用到刚才储存的movies.csv和actor.csv，利用Py2neo来将数据导入至Neo4j中。&lt;br/&gt;   首先，需要确保你的电脑已安装好Neo4j，Py2neo，并开启了Neo4j服务，具体的安装流程可参考网址：&lt;a href=&quot;https://www.w3cschool.cn/neo4j/neo4j_features_advantages.html&quot; class=&quot;uri&quot;&gt;https://www.w3cschool.cn/neo4j/neo4j_features_advantages.html&lt;/a&gt; 。&lt;br/&gt;   利用Py2neo，我们就可以用Python轻松地实现将数据导入至Neo4j，实现的功能为：创建电影节点以及演员节点，并创建两者之间的关系，关系名称为“ACT_IN”。实现的Python代码（）如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# -*- coding: utf-8 -*-

import pandas as pd
from py2neo import Graph, Node, Relationship, NodeMatcher

# 读取csv文件
movies_df = pd.read_csv(r'./movies.csv')
actors_df = pd.read_csv(r'./actors.csv')

# 连接Neo4j服务
graph = Graph(host=&quot;localhost://7474&quot;, auth=(&quot;neo4j&quot;, &quot;jc147369&quot;))

# 创建电影节
for i in range(movies_df.shape[0]):
    rank = str(movies_df.iloc[i, :]['rank'])
    name = movies_df.iloc[i, :]['name']
    box_office = movies_df.iloc[i, :]['box_office']
    avg_price = str(movies_df.iloc[i, :]['avg_price'])
    avg_people = str(movies_df.iloc[i, :]['avg_people'])
    begin_date = movies_df.iloc[i, :]['begin_date']
    
    node = Node(&quot;Movie&quot;, 
                name=name,
                rank=rank,
                box_office=box_office,
                avg_price=avg_price,
                avg_people=avg_people,
                begin_date=begin_date
                )
    # print(movies_df.iloc[i, :]['rank'])
    graph.create(node)

print('create movie nodes successfully!')

# 创建演员节点
all_actors = set()
for i in range(actors_df.shape[0]):
    actor_list = actors_df.iloc[i, :]['actors'].split('，')
    for actor in actor_list:
        all_actors.add(actor)
 
for actor in all_actors:
    node = Node(&quot;Actor&quot;, name=actor)
    graph.create(node)

print('create actor nodes successfully!')

# 创建演员——电影关系
for i in range(actors_df.shape[0]):
    name = actors_df.iloc[i, :]['name']
    matcher = NodeMatcher(graph)
    movie_node = matcher.match(&quot;Movie&quot;, name=name).first()
    actors = actors_df.iloc[i, :]['actors'].split('，')
    # print(name, actors)
    for actor in actors:
        actor_node = matcher.match(&quot;Actor&quot;, name=actor).first()
        relationship = Relationship(actor_node, 'ACT_IN', movie_node)
        graph.create(relationship)

print('create relationships successfully!')
print('You can check Neo4j now!')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  只要你的电脑已安装好Neo4j，Py2neo，并开启了Neo4j服务，不出意外，那么你的Neo4j已经默默地储存了这些数据，而它们将会给出带来巨大的惊喜：天呐，这竟然是个数据库！&lt;br/&gt;  在浏览器中输入“localhost:7474”，并点击左上方的数据库图标，就能看到下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9419034-7f9cebedbba7d7a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;数据储存好了吗？&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  可以看到，在Neo4j中，我们创建了142个节点，分为两类：Movie和Actor，以及136对关系，关系名称为ACT_IN. 当然，这些都是枯燥的，那么我们来看看数据展示这步吧，它会给我们带来什么惊喜？&lt;/p&gt;
&lt;h3 id=&quot;数据展示&quot;&gt;数据展示&lt;/h3&gt;
&lt;p&gt;  好不容易到了数据展示这一步，之前的努力都不会白费！&lt;br/&gt;  在Neo4j的前端页面（也就是网址：&lt;a class=&quot;uri&quot;&gt;http://localhost:7474）中的命令行中输入命令&lt;/a&gt;：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;MATCH (Movie)
RETURN (Movie);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行命令后，很快就能得到整个图（包含电影节点、演员节点以及关系）的可视化展示，由于图像过大，不能看清细节，因此，就局部放大来看，同时得到一些简单的分析。&lt;br/&gt;  首先是图一，吴京主演的电影。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9419034-6c6b708d645edd6e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;图一&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在中国电影票房排行榜的前20名中，吴京主演了《战狼2》与《流浪地球》，且两者没有其他更多的相同主演。&lt;br/&gt;  接着是图二，沈腾主演的电影。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9419034-7e2267904441f3e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;图二&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在中国电影票房排行榜的前20名中，沈腾主演了《西虹市首富》、《疯狂的外星人》以及《羞羞的铁拳》，这显示了沈腾的票房号召力（他也是笔者喜欢的喜剧演员），不过开心麻花团队的其他成员在这三部电影的拍摄中应该见不到面。&lt;br/&gt;  接着是图三，《捉妖记》及《捉妖记2》。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9419034-d102867e1229d18b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;图三&quot;/&gt;&lt;/p&gt;
&lt;p&gt;捉妖记系列电影无疑是成功的，两部电影都进了票房的前20，他们的共同主演就多了，有曾志伟，吴君如，井柏然，白百何。&lt;br/&gt;  接着是图四，主要是看看Neo4j帮我们挖掘了哪些潜在的关系。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9419034-265a80be130ef11a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;图四&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从《唐人街探案2》到《捉妖记2》，这个不算长的链条给了我们一些惊喜，原来，刘昊然可以通过尚语贤再通过曾志伟认识李宇春，一个very interesting的分析。当然，这个是笔者的分析，他俩到底认不认识笔者是不知道滴~&lt;/p&gt;
&lt;p&gt;  分析到此结束，如果读者想看原图，可以参看该项目的github地址：&lt;a href=&quot;https://github.com/percent4/Neo4j_movie_demo&quot; class=&quot;uri&quot;&gt;https://github.com/percent4/Neo4j_movie_demo&lt;/a&gt; 。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;  感谢读者不厌其烦地看到了这里，看完了这篇“又臭又长”的文章，好在图比较多，应该能稍微减轻点阅读的压力。&lt;br/&gt;  再说说该项目的不足之处：那就是Neo4j的操作语法展示的比较少，约等于没有，这主要是笔者也是初入门，不熟。如果后续对Neo4j的操作语法CQL熟练了，我们就能能到更多有趣的结果，而不是这么一句简单的分析（有敷衍的嫌疑）。&lt;br/&gt;  最后，对此项目感兴趣的读者，可以移步该项目的github地址：&lt;a href=&quot;https://github.com/percent4/Neo4j_movie_demo&quot; class=&quot;uri&quot;&gt;https://github.com/percent4/Neo4j_movie_demo&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;注意：不妨了解下笔者的微信公众号： Python爬虫与算法（微信号为：easy_web_scrape）， 欢迎大家关注~&lt;/p&gt;
&lt;h3 id=&quot;参考文献&quot;&gt;参考文献&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;Neo4j_百度百科：&lt;a href=&quot;https://baike.baidu.com/item/Neo4j/9952114?fr=aladdin&quot; class=&quot;uri&quot;&gt;https://baike.baidu.com/item/Neo4j/9952114?fr=aladdin&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;neo4j教程：&lt;a href=&quot;https://www.w3cschool.cn/neo4j/neo4j_features_advantages.html&quot; class=&quot;uri&quot;&gt;https://www.w3cschool.cn/neo4j/neo4j_features_advantages.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;The Py2neo v3 Handbook&lt;/em&gt;: &lt;a href=&quot;https://py2neo.org/v3/index.html&quot; class=&quot;uri&quot;&gt;https://py2neo.org/v3/index.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Neo4j简介及Py2Neo的用法: &lt;a href=&quot;https://cuiqingcai.com/4778.html&quot; class=&quot;uri&quot;&gt;https://cuiqingcai.com/4778.html&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Sat, 23 Feb 2019 16:27:00 +0000</pubDate>
<dc:creator>jclian91</dc:creator>
<og:description>Neo4j入门之中国电影票房排行浅析</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jclian91/p/10425058.html</dc:identifier>
</item>
<item>
<title>企业IT架构转型之道，阿里巴巴中台战略思想与架构实战 - 情话布墨</title>
<link>http://www.cnblogs.com/qhbm/p/10425026.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qhbm/p/10425026.html</guid>
<description>&lt;p&gt;前言：&lt;/p&gt;
&lt;p&gt;　　晚上11点多闲来无事，打开QQ技术群，发现有关 '中心化与引擎化' 的话题，本着学习的心态向大佬咨询，大佬推荐一本书，我大概看了有四分之一的样子，对于我这种对架构迷茫的人来说，如鱼得水，于是特来此推荐一下这本书。&lt;/p&gt;

&lt;p&gt;正文：&lt;/p&gt;
&lt;p&gt;        &lt;img src=&quot;https://img2018.cnblogs.com/blog/953915/201902/953915-20190224000057456-261813984.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/953915/201902/953915-20190224000351326-1969175557.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/953915/201902/953915-20190224000409435-1495735952.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/953915/201902/953915-20190224000419728-1472773407.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;下载地址：&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;https://pan.baidu.com/s/1VlAKpQw7rA-rA5C7EqE0aw&quot; target=&quot;_blank&quot;&gt;https://pan.baidu.com/s/1VlAKpQw7rA-rA5C7EqE0aw&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 23 Feb 2019 16:10:00 +0000</pubDate>
<dc:creator>情话布墨</dc:creator>
<og:description>前言： 晚上11点多闲来无事，打开QQ技术群，发现有关 '中心化与引擎化' 的话题，本着学习的心态向大佬咨询，大佬推荐一本书，我大概看了有四分之一的样子，对于我这种对架构迷茫的人来说，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qhbm/p/10425026.html</dc:identifier>
</item>
<item>
<title>Java自增和自减操作符——++/--的那些事 - 人无名，则可专心练剑</title>
<link>http://www.cnblogs.com/yif0118/p/10425013.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yif0118/p/10425013.html</guid>
<description>&lt;h2&gt;  1. 概述&lt;/h2&gt;
&lt;p&gt;    自增操作符（++）和自减操作符（--）是对变量进行加1和减1的操作。&lt;/p&gt;
&lt;h2&gt;   2.分类说明&lt;/h2&gt;
&lt;p&gt;    ++和--是对变量进行自增1和自减1的简写操作符。许多编程任务中经常需要对变量加1或者减1，所以采用这两个操作符会方便许多。例如，下面的代码是对i自增1，而对j自减1：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; i = 3, j = 3&lt;span&gt;;
i&lt;/span&gt;++; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; i become 4&lt;/span&gt;
j--; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; j become 2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    i++读为i加加，i--读为i减减。这些操作符分别称为后置自增操作符和后置自减操作符，因为操作符++和--放在变量后面。这些操作符也可以放在变量前面，比如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; i = 3, j = 3&lt;span&gt;;
&lt;/span&gt;++i; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; i becomes 4&lt;/span&gt;
--j; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; j becomes 2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    --i将i增加1，--j将j减去1。这些操作符称为前置自增操作符和前置自减操作符。&lt;/p&gt;
&lt;p&gt;    如你所见，前面的例子中，i++和++i的效果，或者i--和--i的效果是一样的。然而，当用在表达式中不单纯只进行自增和自减时，他们就会产生不同的效果。具体如下表，描述了自增和自减操作符的不同之处，并且给出了示例：&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;10&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;66&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;操作符&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;94&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;名称&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;254&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;138&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;示例（假设i=1&lt;/strong&gt;&lt;strong&gt;）&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;66&quot;&gt;
&lt;p&gt;&lt;strong&gt;++var&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;94&quot;&gt;
&lt;p align=&quot;center&quot;&gt;前置自增&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;254&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;将var加1，在语句中使用新的var值&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;138&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;Int j = ++i; // j is 2, i is 2&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;66&quot;&gt;
&lt;p&gt;&lt;strong&gt;var++&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;94&quot;&gt;
&lt;p align=&quot;center&quot;&gt;后置自增&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;254&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;将var加1，但是在语句中使用原来的var值&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;138&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;Int j = i++; // j is 1, i is 2&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;66&quot;&gt;
&lt;p&gt;&lt;strong&gt;--var&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;94&quot;&gt;
&lt;p align=&quot;center&quot;&gt;前置自减&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;254&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;将var减1，在语句中使用新的var值&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;138&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;Int j = --i; // j is 0, i is 0&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;66&quot;&gt;
&lt;p&gt;&lt;strong&gt;var--&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;94&quot;&gt;
&lt;p align=&quot;center&quot;&gt;后置自减&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;254&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;将var减1，但是在语句中使用原来的var值&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;138&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;Int j = i--; // j is 1, i is 0&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;    下面演示前置形式的++（或者--）和后置形式的++（或者--）的补充示例。考虑以下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
int i = 10&lt;span&gt;;
int newNum = 10 * i++;    //左边等价于---》 int newNum = 10 *&lt;span&gt; i;
System.out.print(&quot;i is &quot; + i    //接上条   i = i + 1&lt;span&gt;;
   + &quot;, newNum is &quot; + newNum);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    执行输出：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
i is 11, newNum is 100
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    上述中i自增1,然后返回i原来的值来参与乘法运算。这样，newNum的值就为100。如果如下所示将i++换为++i：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; i = 10&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; newNum = 10 * (++i);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;左边等价于---》  i = i + 1;&lt;/span&gt;
System.out.print(&quot;i is &quot; + i    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;接上条  int newNum = 10 * i;&lt;/span&gt;
   + &quot;, newNum is &quot; + newNum);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    执行输出：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
i is 11, newNum is 110
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;   上述中 i自增1，然后返回i的新值，并参与乘法运算。这样，newNum的值就为110。&lt;/p&gt;
&lt;p&gt;    下面是另一个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;double&lt;/span&gt; x = 1.0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;double&lt;/span&gt; y = 5.0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;double&lt;/span&gt; z = x-- + (++y);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    在这三行程序执行完之后，y的值为6.0，z的值为7.0，而x的值为0.0。&lt;/p&gt;
&lt;p&gt;    Java中从左到右对操作数求值。在右边操作数的任何部分被求值之前，二元操作符左边的操作数先求值。这一规则的优先级高于表达式的任何其他规则。下面是一个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; i = 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; k = ++i + i * 3&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 分析可知： ++i求值后返回2。当求i*3的值时，i是2。因此k的值是8。

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;------------对比以下代码------------------&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; i = 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; k = i*3 + ++&lt;span&gt;i ;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 分析可知：从左往右，当求i*3的值时，i是1，后算++i，++i整体是2。因此k的值是5。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;  3.总结&lt;/h2&gt;
&lt;p&gt;    自增在平时的Java笔试和面试中经常作为考查程序员的基础题多次出现，也是比较容易混淆的知识点。在平时编程中使用自增操作符和自减操作符可以使表达式更加简短，但也会使他们比较复杂且难以读懂。应该避免在同一个表达式中使用这些操作符修改多个变量或多次修改同一个变量，如int k = ++i + i * 3。 &lt;/p&gt;
&lt;h2&gt;   4.说明&lt;/h2&gt;
&lt;p&gt;    本文摘自《Java语言程序设计与数据结构》（基础篇）第11版第2章2.14节内容，并由本人结合实例并补充扩展了一些实例代码，本文用于本人学习及经验总结。如需转载（非商业用途）请注明原作者（梁勇）及本文说明中涉及事项。&lt;/p&gt;

</description>
<pubDate>Sat, 23 Feb 2019 16:06:00 +0000</pubDate>
<dc:creator>人无名，则可专心练剑</dc:creator>
<og:description>1. 概述 自增操作符（++）和自减操作符（--）是对变量进行加1和减1的操作。 2.分类说明 ++和--是对变量进行自增1和自减1的简写操作符。许多编程任务中经常需要对变量加1或者减1，所以采用这两</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yif0118/p/10425013.html</dc:identifier>
</item>
<item>
<title>我们为什么要搞长沙.NET技术社区（三） - 溪源More</title>
<link>http://www.cnblogs.com/xiyuanMore/p/10424963.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiyuanMore/p/10424963.html</guid>
<description>&lt;p align=&quot;left&quot;&gt;　　万事先从饭局开始是中华民族留下来的一个优秀的传统美德。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　昨天晚餐时间，长沙 .net 技术社区的主要发起人员进行了一番小聚，同时也作为一个非正式会议，对社区发展进行了探讨。从介绍自己对于长沙IT 行业现状的认识开始，大家表达了加入社区的初衷，描绘了对于社区的美好愿景。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　在长沙.net 技术社区十多位主要发起者中，每个人都来自不同的行业，但是大体上代表了长沙的五个主流方向，分别是互联网和新技术方向、面向企业和政府的软件外包服务、医疗行业信息化、教育业信息化、和制造业信息化。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　发起者中好几位都正在或曾经在公司的关键技术岗位上待了超过三年的时间，深深的明白企业成功的偶然和必然，也深刻知晓长沙当前的行业发展现状，并期望能为社区的发展做出绵薄之力。 &lt;/p&gt;

&lt;p&gt;　　长沙技术驱动型企业非常少，大部分都是业务驱动型。尤其在以.net作为技术驱动的优秀企业，更是凤毛麟角。&lt;/p&gt;
&lt;p&gt;　　业务驱动型公司，每一位开发者的发展路线都是差不多，无外乎就是根据企业发展的需要出发，前几年主要从事软件开发岗位，后期要么往项目经理岗位、中层管理岗位转、要么转岗到业务岗位，很少有机会能够在技术上进一步研究、获得更大发展的机会。&lt;/p&gt;
&lt;p&gt;　　在这样的前提下，有的开发者往往由于无法在技术方向获得进一步的发展而感觉难受、或者无法忍受企业内部存在的一些不太合理的制度而选择离开。然而，由于长沙的整体氛围本身没有太大的区别，往往只能再寻找到另外一家类似的公司继续开始同样的循环。&lt;/p&gt;
&lt;p&gt;　　每一个开发者都渴望获得技术上更好的提升，这样既能体现自己的人生价值，更能让自己的精神层面获得无穷满足。必须承认，对于企业而言，重视业务本身也无可厚非，只有获得更高的效益才能维持住优秀的团队。然而，企业过度向业务倾斜让开发者觉得才华无处伸展并选择离去，最终的后果对于开发者和企业来说实际上是双输。&lt;/p&gt;
&lt;p&gt;　　除此之外，一段时间以来，由于缺少优秀企业也让从北上广深杭回到长沙的开发者们无法在长沙寻找到合适的工作，有的只能继续回到北上广深杭，有的或许则开始逐渐放弃了对于技术的追求，并开始了新的生活方式。&lt;/p&gt;
&lt;p&gt;　　这是一个看似无解的难题。&lt;/p&gt;
&lt;p&gt;　　优秀的人才和优秀的企业，只有相得益彰才能更好的创造更大的价值。&lt;/p&gt;
&lt;p&gt;　　必须承认，长沙依然有着优秀的企业，他们对星城是这么的不离不弃。也拥有那么多无数优秀的.NET开发者，他们究竟去哪里了？难道长沙的.NET开发行业只能在这个内卷化的怪圈中继续迷失么？&lt;/p&gt;

&lt;p&gt;　　如果说在博客园发表的第一篇博客，其实只是一种投石问路，那么随后在长沙技术圈荡起的涟漪是从来没有想到过的效果。短短两天时间就有数以百计的长沙.NET开发者加入微信群，让大家所有人都觉得有点措手不及。&lt;/p&gt;
&lt;p&gt;很多开发者进群之后说的一句话是，想不到长沙居然还有这么多.net开发者。尤其是很多公司都是整个技术部门一个部门的加入这个群，简直可以当成一种病毒式营销的范例。&lt;/p&gt;
&lt;p&gt;　　当然，这也从一个侧面反应了一个事实，即大家都深刻了解长沙.NET技术圈的现状，并期望能够有一个这样的组织能够让大家得以交流和探讨平时遇到的问题，能够更好的促进技术的增长。&lt;/p&gt;
&lt;p&gt;而大家能够相聚于一个社区两个微信群、QQ群中，既是一种缘分，也正是优秀开发者们的相互吸引。&lt;/p&gt;

&lt;p&gt;　　优秀的开发者期待社区成为一个真正的技术净土，能够在这里通过与同行们碰撞产生更多的火花。&lt;/p&gt;
&lt;p&gt;　　而那些成长中的开发者则期待有更加优秀开发者的领头羊效应，以便让他们明白当下工作的意义和未来发展的方向。 &lt;/p&gt;
&lt;p&gt; 　　对于那些好不容易发展起来的本土优秀企业，以及越来越多从北上广深杭来长沙设立研发中心的优秀企业来说，则期待能拥有更多优秀的人才，让企业获得更好的发展。（事实上，如果不是万不得已，应该没有什么人愿意抛弃眼前成熟的技术体系转投到其他开发语言生态圈的怀抱。）&lt;/p&gt;

&lt;p&gt;　　大家都清楚，要打破现状从来不靠一篇两篇文案、社区的建设也不是靠拉群才行，只有优秀的开发们拿出表率作用，热爱技术的开发者一起积极参与，才有可能带动长沙整体氛围的逐渐改观。&lt;/p&gt;
&lt;p&gt;　　例如，我们可以这么做。在大家的努力下，共同打造一个良性循环的生态圈，这里有一群努力奋斗的优秀开发者，大家都有一种积极向上的学习态度。&lt;/p&gt;
&lt;p&gt;　　我们可以先从写博客开始，然后参与开源项目，参与甚至组织技术分享，来实现技术的沉淀。只有技术，才是开发者应对未来变化、无往而不利的宝贵武器。&lt;/p&gt;
&lt;p&gt;　　未来 .net 技术圈发展的希望，不只是靠微软，也不靠个别企业，更不是依靠个别愿意带头的大佬，需要每一个开发者都能成为其他开发者的表率，这才是关键。 &lt;/p&gt;
&lt;p&gt;　　改变，从来不是一朝一夕的事，或许需要三到五年或许更久的时间。&lt;/p&gt;

</description>
<pubDate>Sat, 23 Feb 2019 15:54:00 +0000</pubDate>
<dc:creator>溪源More</dc:creator>
<og:description>我们为什么要搞长沙.NET技术社区（三） 万事先从饭局开始是中华民族留下来的一个优秀的传统美德。 昨天晚餐时间，长沙 .net 技术社区的主要发起人员进行了一番小聚，同时也作为一个非正式会议，对社区发</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiyuanMore/p/10424963.html</dc:identifier>
</item>
<item>
<title>JavaScript的事件及异常捕获 - 东小东</title>
<link>http://www.cnblogs.com/dongxiaodong/p/10420031.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dongxiaodong/p/10420031.html</guid>
<description>&lt;h2&gt;事件处理&lt;/h2&gt;
&lt;p&gt;【onClick】单击事件、【onMouseOver】鼠标经过事件、【onMouseOut】鼠标移出事件、【onChange】文本内容改变事件、【onSelect】文本被框选事件、【onFoucus】得到光标事件、【onBlur】光标失去事件、【onLoad】网页加载事件（在body标签中添加）、【onUnload】网页关闭事件（在body标签中添加或者使用window.onload=function(){}）&lt;/p&gt;
&lt;p&gt;事件注册及监听&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、&lt;/strong&gt; &lt;strong&gt;DOM0&lt;/strong&gt;&lt;strong&gt;级事件处理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在标签中添加onClick或其他事件的属性并赋值为JS的自定义方法名&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
onClick=&quot;dongfun(20)&quot;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;两种方法在事件中得到事件的标签对象：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &amp;lt;div id=&quot;divid&quot; onMouseOver=&quot;overbut(this)&quot; onMouseOut=&quot;outbut()&quot;&amp;gt;东小东&amp;lt;/div&amp;gt;
&lt;span&gt; 2&lt;/span&gt; &amp;lt;script&amp;gt;
&lt;span&gt; 3&lt;/span&gt;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过参数传递对象&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; overbut(obj){
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;        obj.innerHTML=&quot;事件触发发，鼠标在我的范围&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过ID查找到对象&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; outbut(){
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;        document.getElementById(&quot;divid&quot;).innerHTML=&quot;再见见&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;内容改变监听：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;方法一&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;onChange&lt;/span&gt;&lt;span&gt;=&quot;this.style.backgroundColor='red'&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;    
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;方法二&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;inid&quot;&lt;/span&gt;&lt;span&gt; onChange&lt;/span&gt;&lt;span&gt;=&quot;inputbut(this)&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; inputbut(obj){
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;        obj.style.backgroundColor&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;green&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;更改样式    &lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2、&lt;/strong&gt; &lt;strong&gt;DOM1&lt;/strong&gt;&lt;strong&gt;级事件处理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过标签或者ID寻找到对象，进行事件监听，一个事件只能对应一个事件处理函数，在HTML中不用进行注册&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; dongfunx(){
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         alert(&quot;东小东弹框&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;找到对象&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; h1objx=document.getElementsByTagName(&quot;h1&quot;)[0&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;注册事件&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt; h1objx.onclick=&lt;span&gt;dongfunx;
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;清除事件&lt;/span&gt;
&lt;span&gt;9&lt;/span&gt; h1objx.onclick=&lt;span&gt;null&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;3、&lt;/strong&gt; &lt;strong&gt;DOM2&lt;/strong&gt;&lt;strong&gt;级事件处理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过标签或者ID寻找到对象，进行事件监听，一个事件只能对应多个事件处理函数，在HTML中不用进行注册&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过ID找到标签对象&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; divobjx=document.getElementById(&quot;divid&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加监听事件，可以添加多个相同或者不同的事件&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;参数（事件名，处理函数名），其中事件名是普通事件中去掉“on”前缀&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; divobjx.addEventListener(&quot;click&quot;&lt;span&gt;,onck1);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; divobjx.addEventListener(&quot;click&quot;&lt;span&gt;,onck2);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;事件处理函数&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; onck1(){
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     alert(&quot;----- onck1 -----&quot;&lt;span&gt;); 
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt; }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; onck2(){
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;      alert(&quot;----- onck2 -----&quot;&lt;span&gt;); 
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;移除点击事件&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; divobjx.removeEventListener(&quot;click&quot;,onck1);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;匿名方法实现&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; divobjx=document.getElementById(&quot;divid&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; divobjx.addEventListener(&quot;click&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行操作内容&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;     alert(&quot;----------&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; });
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;补充：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;阻止HTML的默认事件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &amp;lt;a href=&quot;https://www.cnblogs.com/dongxiaodong/&quot;&amp;gt;跳转&amp;lt;/a&amp;gt;
&lt;span&gt; 2&lt;/span&gt; &amp;lt;script&amp;gt;
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; dongfunx(eventx){
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         eventx.preventDefault();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;阻止默认事件，不进行跳转&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;找到对象&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; aobjx=document.getElementsByTagName(&quot;a&quot;)[0&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;注册事件&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     aobjx.onclick=&lt;span&gt;dongfunx;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;页面加载完毕监听：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; window.onload=&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     alert(&quot;页面加载完毕&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;异常捕获&lt;/h2&gt;
&lt;p&gt;如果程序执行时遇到异常且未进行异常捕获，则程序将终止执行，如果有异常捕获，则可以继续执行异常以下的代码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;捕获所有异常：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;alert(jj);//未定义变量异常&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;throw&lt;/span&gt;(&quot;东小东异常&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;手动抛出异常，参数为异常内容&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; }&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(e){
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     alert(&quot;捕获的错误:&quot;+&lt;span&gt;e);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;   }
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;
</description>
<pubDate>Sat, 23 Feb 2019 15:53:00 +0000</pubDate>
<dc:creator>东小东</dc:creator>
<og:description>事件处理 【onClick】单击事件、【onMouseOver】鼠标经过事件、【onMouseOut】鼠标移出事件、【onChange】文本内容改变事件、【onSelect】文本被框选事件、【onFo</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dongxiaodong/p/10420031.html</dc:identifier>
</item>
<item>
<title>算法工程师想进一步提高竞争力？向TensorFlow开源社区贡献你的代码吧 - DeepLearningStack</title>
<link>http://www.cnblogs.com/deep-learning-stacks/p/10424914.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/deep-learning-stacks/p/10424914.html</guid>
<description>&lt;p&gt;[作者：&lt;a href=&quot;https://www.cnblogs.com/deep-learning-stacks&quot; target=&quot;_blank&quot;&gt;DeepLearningStack&lt;/a&gt;，阿里巴巴算法工程师，开源TensorFlow Contributor]&lt;/p&gt;
&lt;p&gt;“做算法的人要熟悉算法框架源码吗？算法工程师难道不应该会使用框架建模就可以了吗？如何成为具有一定竞争力的算法工程师？”...&lt;/p&gt;
&lt;p&gt;我经常被不同的人问类似这样的问题。坦白地说从我个人经验来看，身边算法做的不错的人对算法框架源码普遍熟悉，而且算法建模这件事在当前来看还并不能纯粹的与底层隔离，因为你会经常与计算性能，算法实现原理打交道。当然，我也见过一些比较浮躁的从业者，认为算法工程师应该只做建模不碰源码，这些人一般都只是根据网上教程跑通了个MNIST，ImageNet的例子就认为自己可以胜任算法工程师的工作了，&lt;strong&gt;这种人其实不是想做算法，而是不想写代码而已&lt;/strong&gt;。算法门槛表面上在降低，可其实是不断升高的。一方面，学术界算法创新竞争越来越激烈，主要表现在AI相关的顶会变多，accept的paper也越来越多，多到根本看不过来，你现在所想到的模型创新，没准在另一家公司或者学校已经走到实验验证阶段了；另一方面，性能优化和定制的功能开发等工程能力越来越重要。现在来看，市场上做想要算法的人非常多，但到面试通过的概率很低，这也侧面说明了竞争门槛其实是比较高的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;但这也是机会&lt;/strong&gt;。如果你是做算法的，请趁此机会提升自己的工程能力和算法领域内的影响力。How？其实很简单——为算法领域的知名开源软件贡献代码。因为我个人是TensorFlow的contributor，所以我以TensorFlow为例为大家介绍。&lt;/p&gt;

&lt;h2&gt;第一步 Fork！&lt;/h2&gt;
&lt;p&gt;首先，进入TensorFlow的GitHub页面，地址如下：&lt;a href=&quot;https://github.com/tensorflow/tensorflow&quot; target=&quot;_blank&quot;&gt;https://github.com/tensorflow/tensorflow&lt;/a&gt; ，可以看到如下页面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1437153/201902/1437153-20190223215203741-1955328077.png&quot; alt=&quot;&quot; width=&quot;819&quot; height=&quot;359&quot;/&gt;&lt;/p&gt;
&lt;p&gt;红色框内表示当前TensorFlow这个开源项目已经有1844个人贡献过代码，想要加入这个行列的coder们请努力吧，这并没有想象中那么难。因为我们无法直接对开源项目clone开发，而只能在我们自己的仓库中开发，所以我们需要点击Fork按钮，将该项目Fork到自己的GitHub仓库名下，然后我们就可以在我们自己的仓库中看到这个项目。&lt;/p&gt;
&lt;h2&gt;第二步 Clone自己的仓库&lt;/h2&gt;
&lt;p&gt;成功Fork之后，我们就可以将它Clone下来进行开发了。每次开发之前最好切出一个分支出来，避免直接在master上做修改。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1437153/201902/1437153-20190223220119488-181616471.png&quot; alt=&quot;&quot; width=&quot;743&quot; height=&quot;301&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;第三步 与Fork之前的开源master建立联系&lt;/h2&gt;
&lt;p&gt;自从我们Fork新项目起，我们自己仓库的master将不再与开源master有任何联系，也就是说我们自己仓库的master代码将不再随着开源master自动更新。那么如何及时更新自己的仓库呢？这需要为我们clone下来的项目添加upstream，即上游远程仓库。这非常简单，只需要一句命令即可搞定。我们需要将开源master的git地址复制下来然后添加到当前项目的，对于TensorFlow来说执行下面命令即可。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
git remote add upstream git@github.com:tensorflow/tensorflow.git
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样就与开源社区master建立起了联系，我们可以看到配置文件.git/config文件中确实添加了upstream。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1437153/201902/1437153-20190223221621276-534738317.png&quot; alt=&quot;&quot; width=&quot;436&quot; height=&quot;222&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;第四步 编写代码，提交到我们的仓库中&lt;/h2&gt;
&lt;p&gt;这一步比较常规，在本地切出开发分支，编写代码，提交到我们自己的仓库中。&lt;/p&gt;
&lt;h2&gt;第五步 生成Pull Request&lt;/h2&gt;
&lt;p&gt;当我们将自己的commit提交到自己的GitHub仓库之后，就可以向Fork源master提交Pull Request（简称PR）申请了。首先进入自己的GitHub仓库页面，点击New pull request按钮。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1437153/201902/1437153-20190223222241054-74265114.png&quot; alt=&quot;&quot; width=&quot;523&quot; height=&quot;338&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击后进入Comparing页面，我们选择需要往Fork源merge的分支，如下所示。由于我当前这个分支已经提交了PR，但还处于review期间，所以生成的页面不太一样。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1437153/201902/1437153-20190223222514890-2030624599.png&quot; alt=&quot;&quot; width=&quot;729&quot; height=&quot;311&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;第六步 填写代码贡献说明&lt;/h2&gt;
&lt;p&gt;这是最后一步，需要在生成的页面中填写自己要贡献这段代码的原因，然后引入相关的reviewer进行讨论。不得不说，这一部分非常关键，因为大部分reviewer只会review代码规范，而这段代码的作用本身需要大家自己解释清楚。如果你曾经在该项目中贡献过代码，那么会显示Contributor字样。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1437153/201902/1437153-20190223223141854-902934839.png&quot; alt=&quot;&quot; width=&quot;523&quot; height=&quot;239&quot;/&gt;&lt;/p&gt;
&lt;p&gt;自此，你成功的向开源社区提交了一个PR，离成为Contributor走进了一步。&lt;/p&gt;

&lt;p&gt;一般情况下，TensorFlow的reviewer响应都是比较快的，而且他们对于技术讨论非常开放，也非常愿意社区积极贡献代码。Reviewer会在你的PR上提出各种Comments，在不断的代码refine之后，代码将最终成功merge到开源master中，从状态上看你的PR将会显示紫色的Merged。如果到了这一步，那么恭喜你，成功成为了TensorFlow社区的Contributor！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1437153/201902/1437153-20190223223601609-2116110236.png&quot; alt=&quot;&quot; width=&quot;737&quot; height=&quot;376&quot;/&gt;&lt;/p&gt;

&lt;p&gt;TensorFlow社区master每天都会更新，所以建议每天做一次代码同步，非常简单，两行git命令就能搞定。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;git pull upstream master
git push origin master&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;分别是将upstream（也就是Fork源）代码更新到本地，向origin（自己的仓库远端）更新代码。&lt;/p&gt;

&lt;p&gt;因为你的贡献让TensorFlow更加完善，所以在之后的发布通告中会出现你的名字。下面的这段发布通告来自于TensorFlow 1.13.0 RC2，其实你可以从描述中看到，在1800+名Contributor中，绝大部分是Google内部的人，所以Google外部的Contributor非常少。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1437153/201902/1437153-20190223224442144-1795769662.png&quot; alt=&quot;&quot; width=&quot;488&quot; height=&quot;318&quot;/&gt;&lt;/p&gt;

&lt;p&gt;其实非常多。TensorFlow一大特点是通用性，希望能够在各种场景下均能够变得成熟。但是这个目的工程量浩大，不免存在Bug，设计不完善，性能不理想，功能不全面等情况。其实在使用TensorFlow建模时就会遇到他们，而且概率还真不小。当然你可以遇到问题选择绕开它们，但这可能也意味着你错失了一个提PR的机会。提PR的前提是你必须对源码有所了解，所以算法工程师们在读paper读累了的时候不妨换换思路，每天看一点TensorFlow源码多提升一些工程素养。&lt;/p&gt;

&lt;p&gt;TensorFlow是Google重要的算法军火库，Google围绕着TensorFlow本身还做了其他子项目，他们也非常重要。另外，也可以加入讨论组。&lt;/p&gt;
&lt;h2&gt;TensorFlow生态中的其他子项目&lt;/h2&gt;
&lt;p&gt;TensorFlow生态中子项目相当丰富，有前端TensorBoard，有易用性框架Estimator等等。这些子项目也同样需要社区贡献力量。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1437153/201902/1437153-20190223225959379-439305894.png&quot; alt=&quot;&quot; width=&quot;674&quot; height=&quot;514&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;TensorFlow 2.0的标准制定项目——Community&lt;/h2&gt;
&lt;p&gt;Community子项目其实就是TensorFlow的RFC文档，它是TensorFlow 2.0的标准，里面含有一些模块和接口的设计。为什么要关注RFC文档？这是因为TensorFlow的发展比较快，经常出现某些模块被弃用，某些新模块将要大力发展的情况。这些信息对于开发者非常重要，如果你想共享一段代码，但它与社区的发展标准背道而驰，那么将是无用功，所以RFC文档对于避免虚工是非常有用的。但一个标准的提出也需要经过社区的审核和讨论，所以如果有自己的想法，可以在Community中提出自己的comments，引入更多的人参与讨论。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1437153/201902/1437153-20190223231018820-1277909006.png&quot; alt=&quot;&quot; width=&quot;557&quot; height=&quot;296&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;扩展——与TensorFlow有关的项目&lt;/h2&gt;
&lt;p&gt;从TensorFlow项目这一个点出发，我们可以不怎么费力气地学习到更多的开源项目，而且TensorFlow架构和源码设计足够复杂，这使得我们在看其他相关项目时变得相对轻松。比如当你对TensorFlow使用单机多卡GPU通信感兴趣时，可以参考NCCL。当你对多机分布式感兴趣时，你或许可以看看Uber开源的Horovod。当你想要研究不同框架之间的差异时，你也许可以看看Pytorch，caffe2和MXNet。这种辐射式的积累会让我们学习更多的软件设计哲学。&lt;/p&gt;

&lt;p&gt;由于本人也是算法工程师，工作中不仅是TensorFlow的用户，也在自己所任职的公司参与TensorFlow的定制开发与性能优化。从我个人角度来看，算法工程师这个职位不得不说是含有大量水分的，一方面真正懂算法能够在AI顶会发一些高质量paper的人占比并不高，另一方面，在算法工程上理解较深的人也并不多，而在算法和工程两方面都比较强的人就更少了。现在属于算法领域较热的时段，这方面的油水，薪资竞争力和需求量都很大，所以市场上存在很多想要进入这个领域的人，这是好事。但是如果一个人自己跑几个模型例子就声称自己可以做算法并且十分反感写代码的话，那他在算法领域也不会有很好的发展。除非，你是一个算法造诣非常高的天才并且能够胜任&lt;strong&gt;算法科学家&lt;/strong&gt;的人。否则，请不要欺骗自己，认真培养你的&lt;strong&gt;算法能力&lt;/strong&gt;和&lt;strong&gt;工程能力，&lt;/strong&gt;毕竟你的目标还是一个合格的算法工程师。&lt;/p&gt;

</description>
<pubDate>Sat, 23 Feb 2019 15:47:00 +0000</pubDate>
<dc:creator>DeepLearningStack</dc:creator>
<og:description>算法工程师为什么也要向社区贡献代码？ [作者：DeepLearningStack，阿里巴巴算法工程师，开源TensorFlow Contributor] “做算法的人要熟悉算法框架源码吗？算法工程师难</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/deep-learning-stacks/p/10424914.html</dc:identifier>
</item>
<item>
<title>Django中CBV(Class Base Views)模型源码分析 - 伍萬磊</title>
<link>http://www.cnblogs.com/wanlei/p/10403476.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wanlei/p/10403476.html</guid>
<description>&lt;h2 id=&quot;在view文件中编写一个类并配置好路由&quot;&gt;在view文件中编写一个类，并配置好路由&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;class Test(View):
    def get(self, request, *args, **kwargs):
        return HttpResponse('cbv_get')

    def post(self, request, *args, **kwargs):
        return HttpResponse('cbv_post')&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;url(r'test/',views.Test.as_view()),&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;通过as_view进入查看源码&quot;&gt;通过as_view()进入查看源码&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1442172/201902/1442172-20190223233530795-1544475473.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;实际上views.test.as_view是存的一个内存地址加括号被调用执行了as_view方法里的view方法具体看下图&quot;&gt;实际上views.Test.as_view()是存的一个内存地址，加括号被调用，执行了as_view方法里的view方法，具体看下图：&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1442172/201902/1442172-20190223233544464-1611326783.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;核心是dispatch方法在dispatch方法中完成了分发功能&quot;&gt;核心是dispatch方法，在dispatch方法中完成了分发功能。&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1442172/201902/1442172-20190223233556545-1741343158.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;若要在test类中自定义dispatch方法代码如下&quot;&gt;若要在Test类中自定义dispatch方法，代码如下：&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;class Test(View):
    def dispatch(self, request, *args, **kwargs):
        # 加代码
        obj = super().dispatch(self, request, *args, **kwargs)
        # 加代码
        # 实现了一个类似装饰器的效果，比如post请求，如果是json，手动从request里body取出来 再转一下
        # 或者走的时候加点cookie
        return obj
    
    def get(self, request, *args, **kwargs):
        return HttpResponse('cbv_get')

    def post(self, request, *args, **kwargs):
        return HttpResponse('cbv_post')&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;流程总结&quot;&gt;流程总结：&lt;/h2&gt;
&lt;h4 id=&quot;cbv模型&quot;&gt;CBV模型&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;在views中写一个类,继承View,里面写get方法,post方法&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;在路由中配置: url(r'^test/', views.Test.as_view()),实际上第二个参数位置,放的还是一个函数内存地址&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;当请求来了,就会执行第二个参数(request,参数),本质上执行view()&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;view内部调用了dispatch()方法&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;dispatch分发方法,根据请求方式不同,执行的方法不同&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Sat, 23 Feb 2019 15:45:00 +0000</pubDate>
<dc:creator>伍萬磊</dc:creator>
<og:description>在view文件中编写一个类，并配置好路由 通过as_view()进入查看源码 实际上views.Test.as_view()是存的一个内存地址，加括号被调用，执行了as_view方法里的view方法，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wanlei/p/10403476.html</dc:identifier>
</item>
</channel>
</rss>