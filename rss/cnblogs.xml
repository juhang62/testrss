<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>同时拿到BATJMD的Offer是怎样的一种体验？ - 冰河团队</title>
<link>http://www.cnblogs.com/binghe001/p/14387548.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/binghe001/p/14387548.html</guid>
<description>&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;p&gt;又到了收割Offer的季节，你准备好了吗？曾经的我，横扫各个大厂的Offer。还是那句话：进大厂临时抱佛脚是肯定不行的，一定要注重平时的总结和积累，多思考，多积累，多总结，多复盘，将工作经历真正转化为自己的工作经验。&lt;/p&gt;
&lt;p&gt;今天，我就跟小伙伴们分享一些经典的大数据面试题，跟我一起横扫各个大厂的Offer！后续，我会给大家输出一篇我平时是如何在工作过程中总结经验的，希望能够给小伙伴们带来实质性的帮助。不多说了，开始今天的主题——面经分享。&lt;/p&gt;
&lt;h2 id=&quot;面经分享&quot;&gt;面经分享&lt;/h2&gt;
&lt;p&gt;今天给大家分享一个面试大厂的完整面经，小伙伴们可以对照下，这些面试题自己是否都会了呢？欢迎文末留言说出你的答案！如果你想提升自己的技术，或者对自己的发展比较迷茫，都可以在文末说出你感受！&lt;/p&gt;
&lt;h3 id=&quot;一轮技术面（90分钟）&quot;&gt;一轮技术面（90分钟）&lt;/h3&gt;
&lt;p&gt;1.hashmap和hashtable区别&lt;br/&gt;2.为什么产生死锁&lt;br/&gt;3.jvm类加载&lt;br/&gt;4.java反射获取私有属性，改变值&lt;br/&gt;5.反射用途&lt;br/&gt;6.所用数据库&lt;br/&gt;7.项目难点，问题&lt;br/&gt;8.如何解决项目中遇到的问题&lt;br/&gt;9.项目中遇到最自豪的地方&lt;br/&gt;10.会什么算法&lt;/p&gt;
&lt;h3 id=&quot;二轮技术面（120分钟）&quot;&gt;二轮技术面（120分钟）&lt;/h3&gt;
&lt;p&gt;1.讲项目&lt;br/&gt;2.数据库乐观锁使用&lt;br/&gt;3.状态机&lt;br/&gt;4.如何解决状态机不对问题&lt;br/&gt;5.如何分库分表&lt;br/&gt;6.MySQL极限&lt;br/&gt;7.HashMap源码&lt;br/&gt;8.设计一个线程安全的HashMap&lt;br/&gt;9.快排的实现，时间复杂度和空间复杂度&lt;br/&gt;10.会什么算法&lt;br/&gt;11.如何把项目变成SOA架构&lt;br/&gt;12.Spring源码，最深刻的模块，aop用途&lt;br/&gt;13.JVM内存模型&lt;br/&gt;14.垃圾回收机制&lt;br/&gt;15.项目中查看垃圾回收&lt;/p&gt;
&lt;h3 id=&quot;三轮技术面（150分钟）&quot;&gt;三轮技术面（150分钟）&lt;/h3&gt;
&lt;p&gt;1.ConcurrentHashMap底层原理？&lt;br/&gt;2.手写一个LRU（用LinkedHashMap）&lt;br/&gt;3.HashMap底层数据结构？&lt;br/&gt;4.JDK1.8中的HashMap为什么用红黑树不用普通的AVL树？&lt;br/&gt;5.为什么在8的时候链表变成树？&lt;br/&gt;6.为什么在6的时候从树退回链表？&lt;br/&gt;7.线程池7个参数，该怎么配置最好？&lt;br/&gt;8.说一下volatile&lt;br/&gt;9.volatile的可见性和禁止指令重排序怎么实现的？&lt;br/&gt;10.CAS是什么？PriorityQueue底层是什么，初始容量是多少，扩容方式呢？&lt;br/&gt;11.若原始大小&amp;lt;64，则扩容为原来的2倍+2，不然就扩容为原来的1.5倍&lt;br/&gt;12.HashMap的容量为什么要设置为2的次幂？&lt;br/&gt;13.你知道跳表吗，什么场景会用到？&lt;br/&gt;14.CopyOnWriteArrayList知道吗，迭代器支持fail-fast吗？&lt;br/&gt;15.innodb的底层数据结构？&lt;br/&gt;16.为什么用B+树不用B树？&lt;br/&gt;17.为什么用B+树不用红黑树？&lt;br/&gt;18.coding：无序数组怎么寻找第k大的数，写一个二叉树层次遍历&lt;br/&gt;19.不知道大小的数据流取其中100个数，怎样的取法能最随机&lt;br/&gt;20.n个物品每个物品都有一定价值，分给2个人，怎么分两个人的价值差最小&lt;/p&gt;
&lt;h3 id=&quot;四轮技术面120分钟&quot;&gt;四轮技术面(120分钟)&lt;/h3&gt;
&lt;p&gt;1.项目中的权限管理&lt;br/&gt;2.登录状态如何储存&lt;br/&gt;3.session和cookie的区别,session如何管理&lt;br/&gt;4.HashMap底层结构&lt;br/&gt;5.synchronized关键字的用法&lt;br/&gt;6.synchronized修饰类方法和普通方法的锁区别,获取类锁之后还能获取对象锁吗&lt;br/&gt;7.类加载器的双亲委派模型的作用,能重复加载某个类吗&lt;br/&gt;8.类加载器的类的缓存,key是什么&lt;br/&gt;9.介绍Redis&lt;br/&gt;10.如何将数据分布在不同的Redis&lt;br/&gt;11.有了解过取余算法?&lt;br/&gt;12.spring的apo实现&lt;br/&gt;13.字节码结构&lt;br/&gt;14.浏览器输入网址过程,结合springmvc&lt;/p&gt;
&lt;h3 id=&quot;五轮技术面120分钟&quot;&gt;五轮技术面(120分钟)&lt;/h3&gt;
&lt;p&gt;1.HashMap在大量哈希冲突该怎么处理&lt;br/&gt;2.红黑树比BST优点&lt;br/&gt;3.MySQL为什么使用B+树&lt;br/&gt;4.多个索引会有多份数据吗&lt;br/&gt;5.数据库的隔离级别和解决的问题&lt;br/&gt;6.数据库默认隔离级别,一定会产生幻读吗,怎么解决&lt;br/&gt;7.输入网址到展示的整个过程,结合springmvc来讲&lt;br/&gt;8.负载均衡的算法&lt;br/&gt;9.哈弗曼编码,如何解决译码问题&lt;br/&gt;10.实习会对工作有影响吗&lt;br/&gt;11.用英文介绍一个项目&lt;br/&gt;12.如何查看系统负载&lt;br/&gt;13.描述一个解决问题的过程&lt;br/&gt;14.如何把文件从服务器复制到本地,用什么命令&lt;/p&gt;
&lt;h3 id=&quot;六轮技术面（90分钟）&quot;&gt;六轮技术面（90分钟）&lt;/h3&gt;
&lt;p&gt;1.讲讲你所了解的JVM垃圾收集算法&lt;br/&gt;2.项目中用的哪些技术&lt;br/&gt;3.项目如何设计流程流转，如果是你的话该怎么设计&lt;br/&gt;4.MySQL使用的索引结构，查找效率&lt;br/&gt;5.MySQL查询优化&lt;br/&gt;6.MySQL慢查询开启，语句分析&lt;br/&gt;7.HashMap查找效率&lt;br/&gt;8.JVM内存模型&lt;br/&gt;9.设计模式，策略模式的使用场景&lt;br/&gt;10.如何确保单例线程安全&lt;br/&gt;11.Spring的bean的默认范围&lt;br/&gt;12.对Netty的了解&lt;br/&gt;13.未来发展规划&lt;/p&gt;
&lt;h3 id=&quot;七轮hr面（40分钟）&quot;&gt;七轮HR面（40分钟）&lt;/h3&gt;
&lt;p&gt;1.说一下发展方向&lt;br/&gt;2.说一下经验不足导致的问题&lt;br/&gt;3.说一下挑战杯的工作内容&lt;br/&gt;4.说一下你给挑战杯项目的主要贡献&lt;br/&gt;5.实习时间&lt;br/&gt;6.拿到了哪些offer，你是怎么考虑的&lt;br/&gt;7.为什么不选择腾讯&lt;br/&gt;8.腾讯技术栈和阿里技术栈的区别&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;好了，今天就到这儿吧，我是冰河，大家有啥问题可以在下方留言，也可以加我微信：sun_shine_lyz，我拉你进群，一起交流技术，一起进阶，一起牛逼~~&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 08 Feb 2021 00:43:00 +0000</pubDate>
<dc:creator>冰河团队</dc:creator>
<og:description>写在前面 又到了收割Offer的季节，你准备好了吗？曾经的我，横扫各个大厂的Offer。还是那句话：进大厂临时抱佛脚是肯定不行的，一定要注重平时的总结和积累，多思考，多积累，多总结，多复盘，将工作经历</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/binghe001/p/14387548.html</dc:identifier>
</item>
<item>
<title>jackson学习之十(终篇)：springboot整合(配置类) - 程序员欣宸</title>
<link>http://www.cnblogs.com/bolingcavalry/p/14387543.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bolingcavalry/p/14387543.html</guid>
<description>&lt;h3 id=&quot;欢迎访问我的github&quot;&gt;欢迎访问我的GitHub&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot; target=&quot;_blank&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;内容：所有原创文章分类汇总及配套源码，涉及Java、Docker、Kubernetes、DevOPS等；&lt;/p&gt;
&lt;h3 id=&quot;系列文章汇总&quot;&gt;系列文章汇总&lt;/h3&gt;
&lt;h3 id=&quot;本篇概览&quot;&gt;本篇概览&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;本文是《jackson学习》系列的终篇，经过前面的一系列实战，相信您已可以熟练使用jackson灵活的执行各种json序列化和反序列化操作，那么，本篇就以轻松的方式来完成整个系列吧；&lt;/li&gt;
&lt;li&gt;上一篇介绍的是在springboot中通过配置文件对jackson做设置，今天要聊的是另一种常用的jackson配置方式：&lt;span&gt;配置类&lt;/span&gt;，就是自己编写代码实例化和配置springboot全局使用的ObjectMapper实例；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;源码下载&quot;&gt;源码下载&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;如果您不想编码，可以在GitHub下载所有源码，地址和链接信息如下表所示(&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot; target=&quot;_blank&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;)：&lt;/li&gt;
&lt;/ol&gt;&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;这个git项目中有多个文件夹，本章的应用在&lt;span&gt;jacksondemo&lt;/span&gt;文件夹下，如下图红框所示：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202102/485422-20210208083702014-1716440407.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;&lt;span&gt;jacksondemo&lt;/span&gt;是父子结构的工程，本篇的代码在&lt;span&gt;springbootconfigbean&lt;/span&gt;子工程中，如下图：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202102/485422-20210208083702657-601770152.jpg&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;编码&quot;&gt;编码&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;在父工程jacksondemo下新增子工程springbootconfigbean，pom.xml如下：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;
    &amp;lt;parent&amp;gt;
        &amp;lt;artifactId&amp;gt;jacksondemo&amp;lt;/artifactId&amp;gt;
        &amp;lt;groupId&amp;gt;com.bolingcavalry&amp;lt;/groupId&amp;gt;
        &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
        &amp;lt;relativePath&amp;gt;../pom.xml&amp;lt;/relativePath&amp;gt;
    &amp;lt;/parent&amp;gt;
    &amp;lt;groupId&amp;gt;com.bolingcavalry&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;springbootconfigbean&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;name&amp;gt;springbootconfigbean&amp;lt;/name&amp;gt;
    &amp;lt;description&amp;gt;Demo project for Spring Boot with Jackson, configuration from config bean&amp;lt;/description&amp;gt;

    &amp;lt;properties&amp;gt;
        &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt;
    &amp;lt;/properties&amp;gt;

    &amp;lt;!--不用spring-boot-starter-parent作为parent时的配置--&amp;gt;
    &amp;lt;dependencyManagement&amp;gt;
        &amp;lt;dependencies&amp;gt;
            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-boot-dependencies&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;2.3.3.RELEASE&amp;lt;/version&amp;gt;
                &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt;
                &amp;lt;scope&amp;gt;import&amp;lt;/scope&amp;gt;
            &amp;lt;/dependency&amp;gt;
        &amp;lt;/dependencies&amp;gt;
    &amp;lt;/dependencyManagement&amp;gt;

    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
            &amp;lt;exclusions&amp;gt;
                &amp;lt;exclusion&amp;gt;
                    &amp;lt;groupId&amp;gt;org.junit.vintage&amp;lt;/groupId&amp;gt;
                    &amp;lt;artifactId&amp;gt;junit-vintage-engine&amp;lt;/artifactId&amp;gt;
                &amp;lt;/exclusion&amp;gt;
            &amp;lt;/exclusions&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;!-- swagger依赖 --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;io.springfox&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;springfox-swagger2&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!-- swagger-ui --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;io.springfox&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;springfox-swagger-ui&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;

    &amp;lt;build&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt;

&amp;lt;/project&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;本文最重要的代码是配置类&lt;span&gt;JacksonConfig.java&lt;/span&gt;，如下，需要&lt;span&gt;ConditionalOnMissingBean&lt;/span&gt;注解避免冲突，另外还给实例指定了名称customizeObjectMapper，如果应用中通过Autowired使用此实例，需要指定这个名字，避免报错&quot;There is more than one bean of 'ObjectMapper ' type&quot;：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Configuration
public class JacksonConfig {

    @Bean(&quot;customizeObjectMapper&quot;)
    @Primary
    @ConditionalOnMissingBean(ObjectMapper.class)
    public ObjectMapper getObjectMapper(Jackson2ObjectMapperBuilder builder) {
        ObjectMapper mapper = builder.build();

        // 日期格式
        mapper.setDateFormat(new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;));

        // 美化输出
        mapper.enable(SerializationFeature.INDENT_OUTPUT);

        return mapper;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;对于JacksonConfig.getObjectMapper方法内的设置，如果您想做更多设置，请参考&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/108192174&quot; target=&quot;_blank&quot;&gt;《jackson学习之三：常用API操作》&lt;/a&gt;里面的设置内容；&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;启动类依然很简单：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.bolingcavalry.springbootconfigbean;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class SpringbootConfigBeanApplication {

    public static void main(String[] args) {
        SpringApplication.run(SpringbootConfigBeanApplication.class, args);
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;swagger配置：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.bolingcavalry.springbootconfigbean;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import springfox.documentation.builders.ApiInfoBuilder;
import springfox.documentation.builders.PathSelectors;
import springfox.documentation.builders.RequestHandlerSelectors;
import springfox.documentation.service.ApiInfo;
import springfox.documentation.service.Contact;
import springfox.documentation.service.Tag;
import springfox.documentation.spi.DocumentationType;
import springfox.documentation.spring.web.plugins.Docket;
import springfox.documentation.swagger2.annotations.EnableSwagger2;

@Configuration
@EnableSwagger2
public class SwaggerConfig {

    @Bean
    public Docket createRestApi() {
        return new Docket(DocumentationType.SWAGGER_2)
                .apiInfo(apiInfo())
                .tags(new Tag(&quot;JsonPropertySerializationController&quot;, &quot;JsonProperty相关测试&quot;))
                .select()
                // 当前包路径
                .apis(RequestHandlerSelectors.basePackage(&quot;com.bolingcavalry.springbootconfigbean.controller&quot;))
                .paths(PathSelectors.any())
                .build();
    }

    //构建 api文档的详细信息函数,注意这里的注解引用的是哪个
    private ApiInfo apiInfo() {
        return new ApiInfoBuilder()
                //页面标题
                .title(&quot;SpringBoot整合Jackson(基于配置文件)&quot;)
                //创建人
                .contact(new Contact(&quot;程序员欣宸&quot;, &quot;https://github.com/zq2599/blog_demos&quot;, &quot;zq2599@gmail.com&quot;))
                //版本号
                .version(&quot;1.0&quot;)
                //描述
                .description(&quot;API 描述&quot;)
                .build();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;最后是测试用的Controller类，要注意的是在使用ObjectMapper实例的地方，用Autowired注解的时候，&lt;span&gt;记得带上Qualifier注解&lt;/span&gt;：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.bolingcavalry.springbootconfigbean.controller;

import com.bolingcavalry.springbootconfigbean.bean.Test;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping(&quot;/jsonproperty&quot;)
@Api(tags = {&quot;JsonPropertySerializationController&quot;})
public class JsonPropertySerializationController {

    private static final Logger logger = LoggerFactory.getLogger(JsonPropertySerializationController.class);

    @Qualifier(&quot;customizeObjectMapper&quot;)
    @Autowired
    ObjectMapper mapper;

    @ApiOperation(value = &quot;测试序列化&quot;, notes = &quot;测试序列化&quot;)
    @RequestMapping(value = &quot;/serialization&quot;, method = RequestMethod.GET)
    public Test serialization() throws JsonProcessingException {

        Test test = new Test();
        logger.info(mapper.writeValueAsString(test));

        return test;
    }

    @ApiOperation(value = &quot;测试反序列化&quot;, notes=&quot;测试反序列化&quot;)
    @RequestMapping(value = &quot;/deserialization&quot;,method = RequestMethod.PUT)
    public String deserialization(@RequestBody Test test) {
        return test.toString();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;验证&quot;&gt;验证&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;启动SpringbootConfigBeanApplication后，浏览器打开：&lt;a href=&quot;http://localhost:8080/swagger-ui.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;http://localhost:8080/swagger-ui.html&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;先验证序列化接口/jsonproperty/serialization：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202102/485422-20210208083705172-1073664773.jpg&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;3. 再验证反序列化接口 /jsonproperty/deserialization：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202102/485422-20210208083708051-1813161385.jpg&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;至此，整个《jackson学习》系列就全部完成了，希望这十篇内容能够给您带来一些参考，助您在编码过程中更加得心应手的使用Jackson；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;你不孤单，欣宸原创一路相伴&quot;&gt;你不孤单，欣宸原创一路相伴&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105068742&quot; target=&quot;_blank&quot;&gt;Java系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086498&quot; target=&quot;_blank&quot;&gt;Spring系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086732&quot; target=&quot;_blank&quot;&gt;Docker系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086794&quot; target=&quot;_blank&quot;&gt;kubernetes系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086850&quot; target=&quot;_blank&quot;&gt;数据库+中间件系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086920&quot; target=&quot;_blank&quot;&gt;DevOps系列&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;欢迎关注公众号：程序员欣宸&quot;&gt;欢迎关注公众号：程序员欣宸&lt;/h3&gt;
&lt;blockquote readability=&quot;4.258064516129&quot;&gt;
&lt;p&gt;微信搜索「程序员欣宸」，我是欣宸，期待与您一同畅游Java世界...&lt;br/&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot; target=&quot;_blank&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 08 Feb 2021 00:37:00 +0000</pubDate>
<dc:creator>程序员欣宸</dc:creator>
<og:description>欢迎访问我的GitHub https://github.com/zq2599/blog_demos 内容：所有原创文章分类汇总及配套源码，涉及Java、Docker、Kubernetes、DevOPS</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bolingcavalry/p/14387543.html</dc:identifier>
</item>
<item>
<title>微服务业务生命周期流程管控引擎 - KevinCC</title>
<link>http://www.cnblogs.com/osscoder/p/14093479.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/osscoder/p/14093479.html</guid>
<description>&lt;p&gt;将业务的流程管控和事件功能抽象剥离，切断事件功能方法内的链式调用，提权至流程引擎统一协调管控，事件功能作为独立处理单元嵌入业务流程之中，由流程引擎处理事件的触发与消息传递，在系统编码层级将事件内调用的”隐式导向”转变为事件外的“显式导向”。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;191.3075002312&quot;&gt;
&lt;p&gt;　　如题，这里介绍我最近开源的进行业务生命周期管控的流程引擎（&lt;a href=&quot;https://github.com/KevinWG/OSS.EventFlow&quot; target=&quot;_blank&quot;&gt;OSS.EventFlow&lt;/a&gt;），当然现在开源的工作流框架很多，无心比较异同，仅表达个人感受：&lt;/p&gt;
&lt;p&gt;　　典型的OA工作流程引擎，这也是当前很多工作流引擎的重要功能，只是OA场景对于系统来说，其业务特点比较突出，抽象归纳相对容易很多。但是这个对于很多业务场景特别是复杂场景能够触达的有限，大多复杂业务流程进度的推进是糅合在业务的具体操作代码之中，不能有效的把动作执行逻辑和业务的流动逻辑切割，如果开发人员没有较高的技术能力和一定的业务深度，新人员需要遍览系统角角落落才能拼凑出产品的概览图，甚至可能是个夹杂很多废弃逻辑的畸形流程。同样，对于新的产品业务流程开发人员又将其拆解粘合在系统中各处。&lt;/p&gt;
&lt;p&gt; 　　在另一方面，在实际的代码开发过程中，当一个模块分给开发人员之后，不管其水平高低，这个模块的质量主管基本很难有效控制，好点的团队有代码评审，但终究只能算是事后补救。这些基本带来以下三个问题，也是我在这个框架编写过程中一直思考的：&lt;/p&gt;
&lt;p&gt;　　1. 微服务的划分，在单个业务点上已经做到了独立，可是站在整个产品的流程上看，多个服务可能的交叉依赖调用，特别是复杂逻辑，产品流程如何落实到代码中进行清晰管控&lt;/p&gt;
&lt;p&gt;　　2. 业务单元的边界和衔接处理，常见的是在当前功能方法的底部，直接调用下一步的方法，又如业务之间添加消息队列的处理，都直接侵入业务代码中，当前方法的的单元化和可复用性，直接受限于实施工程师水平的高低。同时这个又直接影响开发负责人或开发主管的管控能力。&lt;/p&gt;
&lt;p&gt;　　3. 随着产品的迭代，业务流程的快速变化，如何能够不动已有业务单元代码本身的情况下，快速在当前业务流程中排除或新增业务操作单元。&lt;/p&gt;
&lt;p&gt;　  要减少以上的问题的发生，关键在于如何解决业务操作单元之间的关联性。回到现实，对于任何产品，它一定存在一个业务生命周期，在这个周期内，围绕某个对象，随着时间推进，执行一系列的动作，最终得到某个业务结果。既然存在时序性，那么就可以尝试抽象一个时序轮廓的路径图，在这个轮廓之下，再去填充具体动作实现，进度由这个时序轮廓路径图根据具体的动作结果决定如何推进，这个路径图则可以和产品流程图进行映射，形成系统里的流程管控中枢，在系统编码层级将事件内调用的”隐式导向”转变为事件外的“显式导向”。&lt;/p&gt;
&lt;p&gt;　  &lt;a href=&quot;https://github.com/KevinWG/OSS.EventFlow&quot; target=&quot;_blank&quot;&gt;OSS.EventFlow&lt;/a&gt;是以BPMN 2.0 流程管理为思路，设计的轻量级业务生命周期流程引擎基础框架，将业务领域对象的流程管控和事件功能抽象剥离，切断事件功能方法内的链式调用，提权至流程引擎统一协调管控，事件功能作为独立处理单元嵌入业务流程之中，由流程引擎处理事件的触发与消息传递，达成事件处理单元的有效隔离。由此流程的衔接变成可独立编程的部分，同时向上层提供业务动作的独立扩展，保证业务单元的绝对独立和可复用性， 目的是可以像搭积木一样来完成不同功能代码的集成，系统向真正的低代码平台过渡。&lt;/p&gt;
&lt;p&gt;　  &lt;a href=&quot;https://github.com/KevinWG/OSS.EventFlow&quot; target=&quot;_blank&quot;&gt;OSS.EventFlow&lt;/a&gt;引擎的原理是将整个业务流当做一个流程管道，结合流程流转的特性，此引擎抽象了三类核心流程的管道组件：&lt;/p&gt;
&lt;p&gt;　&lt;strong&gt;　1. 事件活动组件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　 这类组件主要是处理任务的具体内容，如发送短信，执行下单，扣减库存等实际业务操作&lt;/p&gt;
&lt;p class=&quot;_mce_tagged_br&quot;&gt;　&lt;strong&gt;　2. 网关组件&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;_mce_tagged_br&quot;&gt;　　这类组件主要负责业务流程方向性的逻辑规则处理，如分支，合并流程&lt;/p&gt;
&lt;p class=&quot;_mce_tagged_br&quot;&gt;　&lt;strong&gt;　3. 连接器组件&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;_mce_tagged_br&quot;&gt;　　这类组件主要负责其他组件之间的消息传递与转化&lt;/p&gt;

&lt;h2&gt;一. 事件活动组件&lt;/h2&gt;
&lt;p&gt;　　这个组件就是业务的动作本身，根据任务触发的特性，如关联自动执行，中断触发（如用户触发，或消息队列等），根据这两种情形，提供了两个抽象基类：&lt;/p&gt;
&lt;p&gt;　&lt;strong&gt;　1. BaseActivity - 直接执行活动组件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　常见如自动审核功能，或者支付成功后自动触发邮件发送等，最简单也是最基本的一种动作处理。 继承此基类，重写Executing方法实现活动内容，同一个流体下实现自动关联执行。 如果Executing方法返回False，则触发Block，业务流不再向后续管道传递 返回True，则流体自动流入后续管道&lt;/p&gt;
&lt;p&gt;　&lt;strong&gt;　2.BaseActionActivity&amp;lt;TContext, TResult&amp;gt; - 用户触发活动组件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　继承此基类 ，重写Executing方法（自定义返回结果类型）实现活动内容。 当业务流流入当前组件时，触发调用Notice（虚方法可重写），之后业务流动停止， 当用户触发时，显式调用 Action 方法（内部调用Executing返回自定义结果类型），流程继续向后流动执行。&lt;/p&gt;
&lt;h2&gt;二. 网关组件&lt;/h2&gt;
&lt;p&gt;　　此组件主要负责逻辑的规则处理，业务的走向逻辑无非分与合，这里给出两个基类：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;1.BaseAggregateGateway - 聚合业务分支流程活动组件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　 将多条业务分支聚合到当前网关组件下，由当前网关统一控制是否将业务流程向后传递，只需要继承此基类重写IfMatchCondition 方法即可&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;2.BaseBranchGateway - 分支网关组件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　 此组件将业务分流处理，定义流体时通过AddBranchPipe添加多个分支，至于如何分流，只需要继承此基类重写FilterNextPipes方法即可，你也可以在此之上实现BPMN中的几种网关类型（并行，排他，和包含）。&lt;/p&gt;
&lt;h2&gt;三. 连接器组件&lt;/h2&gt;
&lt;p&gt;　　此组件主要负责消息的传递和转化处理，在消息的传递过程中又支持直接传递和异步缓冲（IBufferTunnel）传递，根据是否需要转化，或者异步定义三个基类如下：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;1.BaseConnector&amp;lt;InContext, OutContext&amp;gt; - 转化连接组件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　业务流经过此组件，直接执行Convert方法（需重写），转化成对应的下个组件执行参数，自动进入下个组件。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;2.BaseBufferConnector&amp;lt;TContext&amp;gt; - 异步缓冲连接组件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　继承IBufferTunnel接口 继承此组件后，必须重写Push方法，实现异步缓冲保存的处理，业务流进入此组件后，调用Push方法保存，之后业务流动停止， 消息唤醒时，需显式调用Pop方法，业务流继续向后执行&lt;/p&gt;
&lt;p&gt;　&lt;strong&gt;　3.BaseBufferConnector&amp;lt;InContext, OutContext&amp;gt; - 异步缓冲+转化 连接组件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　 继承此组件后，必须重写Push，Convert方法，实现异步缓冲保存和转化的处理，业务流进入此组件后，同样调用Push方法保存，之后业务流动停止， 消息唤醒时，需显式调用Pop方法（内部调用Convert方法，完成参数转化），业务流继续向后执行&lt;/p&gt;
&lt;h2&gt;四. 简单示例场景&lt;/h2&gt;
&lt;p&gt;　　首先我们先假设当前有一个进货管理的场景，，需经历 进货申请，申请审批，购买支付，入库（同时邮件通知申请人） 几个环节，流程图如下： &lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/154246/202102/154246-20210208004714971-1436209758.png&quot; alt=&quot;&quot; width=&quot;466&quot; height=&quot;191&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　根据此流程图，每个环节对应一个事件活动，这里以申请活动我们定义如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
    public class ApplyActivity : BaseActivity&amp;lt;ApplyContext&amp;gt;
    {
        protected override Task&amp;lt;bool&amp;gt; Executing(ApplyContext data)
        {
            // ......
            LogHelper.Info(&quot;这里刚才发生了一个采购申请&quot;); 
            return Task.FromResult(true);
        }
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里为了方便观察，直接继承 BaseActivity，即多个活动连接后，自动运行。 相同的处理方式我们定义剩下几个环节事件，列表如下：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-cs&quot; readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
    ApplyActivity      - 申请事件    (参数：ApplyContext)
    AutoAuditActivity  - 审核事件    (参数：ApplyContext)
    PayActivity        - 购买事件    (参数：PayContext)
    StockActivity      - 入库事件    (参数：StockContext)
    EmailActivity      - 发送邮件事件    (参数：SendEmailContext)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;以上五个事件活动，其具体实现和参数完全独立，同时因为购买支付后邮件和入库是相互独立的事件，定义分支网关做分流（规则）处理，代码如下：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-cs&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
    public class PayGateway:BaseBranchGateway&amp;lt;PayContext&amp;gt;
    {
        protected override IEnumerable&amp;lt;BasePipe&amp;lt;PayContext&amp;gt;&amp;gt; FilterNextPipes(List&amp;lt;BasePipe&amp;lt;PayContext&amp;gt;&amp;gt; branchItems, PayContext context)
        {
            // ......
            LogHelper.Info(&quot;这里进行支付通过后的分流&quot;);
            return branchItems;
        }
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;这里的意思相对简单，即传入的所有的分支不用过滤，直接全部分发。&lt;/p&gt;
&lt;p&gt;同样因为五个事件的方法参数不尽相同，中间的我们添加消息连接器，作为消息的中转和转化处理（也可以在创建流体时表达式处理），以支付参数到邮件的参数转化示例：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-cs&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
    public class PayEmailConnector : BaseConnector&amp;lt;PayContext, SendEmailContext&amp;gt;
    {
        protected override SendEmailContext Convert(PayContext inContextData)
        {
            // ......
            return new SendEmailContext() { id = inContextData.id };
        }
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;通过以上，申购流程的组件定义完毕，串联使用如下（这里是单元测试类，实际业务我们可以创建一个Service处理）：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-cs&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
        public readonly ApplyActivity ApplyActivity = new ApplyActivity();
        public readonly AuditActivity AuditActivity = new AuditActivity();

        public readonly PayActivity PayActivity = new PayActivity();

        public readonly PayGateway PayGateway = new PayGateway();

        public readonly StockConnector StockConnector = new StockConnector();
        public readonly StockActivity  StockActivity  = new StockActivity();

        public readonly PayEmailConnector EmailConnector = new PayEmailConnector();
        public readonly SendEmailActivity EmailActivity  = new SendEmailActivity();

          //  构造函数内定义流体关联
        public BuyFlowTests()
        {
            ApplyActivity
            .Append(AuditActivity)
            .AppendConvert(applyContext =&amp;gt; new PayContext() {id = applyContext.id})// 表达式方式的转化器
            .Append(PayActivity)
            .Append(PayGateway);

            // 网关分支 - 发送邮件分支
            PayGateway.AddBranchPipe(EmailConnector)
            .Append(EmailActivity);

            // 网关分支- 入库分支
            PayGateway.AddBranchPipe(StockConnector)
            .Append(StockActivity);
            //.Append(后续事件)
        }


        [TestMethod]
        public async Task FlowTest()
        {
            await ApplyActivity.Start(new ApplyContext()
            {
                id = &quot;test_business_id&quot;
            });
        }
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;运行单元测试，结果如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
xxx Detail:这里刚才发生了一个采购申请

xxx Detail:管理员审核通过

xxx Detail:发起支付处理

xxx Detail:这里进行支付通过后的分流

xxx Detail:分流-1.邮件发送

xxx Detail:分流-2.库存保存
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果你已经看到这里，并且感觉还行的话可以在下方点个赞，或者也可以关注我的公众号（见二维码） &lt;/p&gt;
&lt;p&gt;_________________________________________&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/154246/201811/154246-20181130002928372-487509861.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Mon, 08 Feb 2021 00:21:00 +0000</pubDate>
<dc:creator>KevinCC</dc:creator>
<og:description>将业务的流程管控和事件功能抽象剥离，切断事件功能方法内的链式调用，提权至流程引擎统一协调管控，事件功能作为独立处理单元嵌入业务流程之中，由流程引擎处理事件的触发与消息传递，在系统编码层级将事件内调用的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/osscoder/p/14093479.html</dc:identifier>
</item>
<item>
<title>无所不能的Embedding6 - 跨入Transformer时代～模型详解&amp;代码实现 - 风雨中的小七</title>
<link>http://www.cnblogs.com/gogoSandy/p/14386998.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gogoSandy/p/14386998.html</guid>
<description>&lt;p&gt;上一章我们聊了聊quick-thought通过干掉decoder加快训练, CNN—LSTM用CNN作为Encoder并行计算来提速等方法，这一章看看抛开CNN和RNN，transformer是如何只基于attention对不定长的序列信息进行提取的。虽然Attention is All you need论文本身是针对NMT翻译任务的,但transformer作为后续USE/Bert的重要组件，放在embedding里也没啥问题。以下基于WMT英翻中的任务实现了transfromer，完整的模型代码详见&lt;a href=&quot;https://github.com/DSXiangLi/Embedding/tree/master/transformer&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;DSXiangLi-Embedding-transformer&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;模型组件&quot;&gt;模型组件&lt;/h2&gt;
&lt;p&gt;让我们先过一遍Transformer的基础组件，以文本场景为例，encoder和decoder的输入是文本序列，每个batch都pad到相同长度然后对每个词做embedding得到batch * padding_len * emb_size的输入向量&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;假设batch=1，Word Embedding维度为512，Encoder的输入是'Fox hunt rabbit at night', 经过Embedding之后得到1 * 5 * 512的向量，以下的模型组件都服务于如何从这条文本里提取出更多的信息&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;attention&quot;&gt;Attention&lt;/h3&gt;
&lt;p&gt;序列信息提取的一个要点在于如何让每个词都考虑到它所在的上下文语境&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;RNN：上下文信息靠向后/前传递，从前往后传rabbit就能考虑到fox，从后往前传rabbit就能考虑到night&lt;/li&gt;
&lt;li&gt;CNN：靠不同kernel_size定义的局部窗口来获取context信息, kernel_size&amp;gt;=3，rabbit就能考虑到所有其他token的信息&lt;/li&gt;
&lt;li&gt;Attention：通过计算词和上下文之间的相关性（广义），来决定如何把周围信息(value)融合(weighted-average)进当前信息(query），下图来源Reference5&lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://miro.medium.com/max/1400/0*zJ2NpWCzaHfsyoLH.gif&quot; width=&quot;450&quot; height=&quot;200&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Transformer在attention的基础上有两点改良， 分别是Scaled-dot product attention和multi-head attention。&lt;/p&gt;
&lt;h4 id=&quot;scaled-dot-product-attention&quot;&gt;Scaled-dot product attention&lt;/h4&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://static01.imgkr.com/temp/562c5e905c5d4884b7a83148d3560260.png&quot; width=&quot;300&quot; height=&quot;350&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Attention的输入是三要素query，key和value，通过计算query和Key的相关性，这里是广义的相关，可以通过&lt;a href=&quot;https://paperswithcode.com/method/additive-attention&quot; target=&quot;_blank&quot;&gt;加法&lt;/a&gt;/&lt;a href=&quot;https://paperswithcode.com/method/multiplicative-attention&quot; target=&quot;_blank&quot;&gt;乘法&lt;/a&gt;得到权重向量，用权重对value做加权平均作为输出。‘fox hunt rabbit at night’会计算每个词对所有词的相关性，得到[5, 5]的相似度矩阵/权重向量，来对输入[5, 512]进行加权，得到每个词在考虑上下文语义后新的向量表达[5, 512]&lt;/p&gt;
&lt;p&gt;Transformer在常规的乘法attention的基础上加入&lt;span class=&quot;math inline&quot;&gt;\(d_k\)&lt;/span&gt;维度的正则化。这里&lt;span class=&quot;math inline&quot;&gt;\(d_k\)&lt;/span&gt;是query和key的特征维度，在我们的文本场景下是embedding_size[512] 。正则化的原因是避免高维embedding的内积出现超级大的值，导致softmax的gradient非常小。&lt;/p&gt;
&lt;p&gt;直观解释，假设query和key的每个元素都独立服从&lt;span class=&quot;math inline&quot;&gt;\(\mu=0 \, \sigma^2=1\)&lt;/span&gt;的分布, 那内积&lt;span class=&quot;math inline&quot;&gt;\(\sum_{d_k}q_ik_i\)&lt;/span&gt;就服从&lt;span class=&quot;math inline&quot;&gt;\(\mu=0 \, \sigma^2=d_k\)&lt;/span&gt;的分布,因此需要用&lt;span class=&quot;math inline&quot;&gt;\(\sqrt{d_k}\)&lt;/span&gt;做正则化，保证内积依旧服从&lt;span class=&quot;math inline&quot;&gt;\(\mu=0 \, \sigma=1\)&lt;/span&gt;的分布。&lt;/p&gt;
&lt;p&gt;\[Attentino(Q, K, V) = softmax(\frac{QK^T}{\sqrt{d_k}}) \cdot V \]&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;def scaled_dot_product_attention(key, value, query, mask):
    with tf.variable_scope('scaled_dot_product_attention', reuse=tf.AUTO_REUSE):
        # scalaed weight matrix : batch_size * query_len * key_len
        dk = tf.cast(key.shape.as_list()[-1], tf.float32)# emb_size
        weight = tf.matmul(query, key, transpose_b=True)/(dk**0.5)
        # apply mask: large negative will become 0 in softmax[mask=0 ignore]
        weight += (1-mask) * (-2**32+1)
        # normalize on axis key_len so that score add up to 1
        weight = tf.nn.softmax(weight, axis=-1)
        tf.summary.image(&quot;attention&quot;, tf.expand_dims(weight[:1], -1))  # add channel dim
        add_layer_summary('attention', weight)
        # weighted value: batch_size * query_len * emb_size
        weighted_value = tf.matmul(weight, value )

        return weighted_value
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;mask&quot;&gt;Mask&lt;/h3&gt;
&lt;p&gt;上面代码中的mask是做什么的呢？mask决定了Attention对哪些特征计算权重，transformer的mask有两种【以下mask=1是保留的部分，0是drop的部分】&lt;/p&gt;
&lt;p&gt;其一是padding mask, 让attention的权重只针对真实文本计算其余为0。padding mask的dimension是[batch, 1, key_len], 1是预留给query，会在attention中被broadcast成[batch, query_len, key_len]&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;def seq_mask_gen(input_, params):
    mask = tf.sequence_mask(lengths=tf.to_int32(input_['seq_len']), maxlen=tf.shape(input_['tokens'])[1],
                            dtype=params['dtype'])
    mask = tf.expand_dims(mask, axis=1)
    return mask
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果输入文本长度分别为3，4，5，都padding到5，padding mask维度是[3,1,5] 如下&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://static01.imgkr.com/temp/ce52325523614d5aa71964b607a3d61b.png&quot; width=&quot;300&quot; height=&quot;100&quot;/&gt;&lt;/p&gt;

&lt;p&gt;其二是future mask只用于decoder，mask每个token后面的序列，保证在预测T+1的token时只会用到T及T以前的信息，如果不加future mask，预测T+1时就会用到T+1的文本本身，出现feature leakage。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;def future_mask_gen(input_, params):
    seq_mask = seq_mask_gen(input_, params) # batch_size * 1 * key_len
    mask = tf.matmul(seq_mask, seq_mask, transpose_a=True) # batch_size * key_len * key_len
    mask = tf.matrix_band_part(mask, num_lower=-1, num_upper=0)
    return mask
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还是上面的例子，future mask的维度是[3,5,5] 如下&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://static01.imgkr.com/temp/6f144fa2de274cd59a8a96f773fb1e4b.png&quot; width=&quot;300&quot; height=&quot;350&quot;/&gt;&lt;/p&gt;

&lt;h4 id=&quot;multi-head-attention&quot;&gt;multi-head attention&lt;/h4&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://imgkr2.cn-bj.ufileos.com/f2184ff1-e8cd-4375-91d0-81d4df2bacfc.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;amp;Signature=U8TNYMsZN%252Ba9URQzIf8h6%252Bga2Z0%253D&amp;amp;Expires=1612792943&quot; width=&quot;250&quot; height=&quot;300&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这些年对multi-head为啥有效的讨论有很多，下面Reference3~8都从不同方面给出了不同的Insight。最开始看multi-head的设计，第一反应是你莫不是在逗我？！你把🍊掰成8瓣再拼回来告诉我这不是一个🍊了？？？翻过来倒过去的琢磨感觉这个设计和CNN的filters似乎有些同一个配方，熟悉的味道～也没啥严谨的证明，要是跑偏了也请指正～&lt;/p&gt;
&lt;p&gt;假设&lt;span class=&quot;math inline&quot;&gt;\(d_{model}=512\)&lt;/span&gt;, &lt;span class=&quot;math inline&quot;&gt;\(head=8\)&lt;/span&gt;, &lt;span class=&quot;math inline&quot;&gt;\(d_k=d_v=d_{model}/head=64\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;multi-head attention的计算过程是，每个head都进行如下操作&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;8个head的query，key，value各自过一层线性映射从维度从512-&amp;gt;64，权重矩阵&lt;span class=&quot;math inline&quot;&gt;\(W \in R^{512*64}\)&lt;/span&gt;，这里和single-head所需的parameter数量一致，single-head是直接做512-&amp;gt;512的映射&lt;/li&gt;
&lt;li&gt;映射后的query, key, value做scaled-dot product attention，得到batch * input_len * 64的输出&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;\[head_i = Attention(QW_i^Q , K W_i^K , V W_i^V ) \]&lt;/p&gt;
&lt;p&gt;再把8个head进行拼接，得到和输入相同维度&lt;span class=&quot;math inline&quot;&gt;\(d_{model}\)&lt;/span&gt;的输出，针对输出再做一步线性映射就齐活了。&lt;/p&gt;
&lt;p&gt;\[MultiHead(Q, K, V ) = Concat(head_1, ..., head_h)\cdot W \]&lt;/p&gt;
&lt;p&gt;清楚计算方式我们来看下multi-head和single-head的差异。Single-head每个token, 会用全部512维的embedding来和其他token的embedding计算相关性。这里其实是存在bottleneck的，因为不论512维的信息多么丰富，也只能通过两两内积归一化后得到scaler来表达，多丰富的信息都会被平均，这一步是存在信息损失的。既然存在bottleneck，那何不降低&lt;span class=&quot;math inline&quot;&gt;\(d_{model}\)&lt;/span&gt;的维度，增加head呢。multi-head类似把[5,512]的输入，先reshape成[5,64,8]，这里8类似CNN的channel，通过第一步的线性映射我们可能让每个head（channel）的key，query，value都分别关注不同信息，可能有的是语法，语义，语序等等，然后用降维到64维的embedding来计算Attention。从而在不增加parameter的条件下提取更多的信息。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;def multi_head_attention(key, value, query, mask, params, mode):
    with tf.variable_scope('multi_head_attention', reuse=tf.AUTO_REUSE):
        d_model = value.shape.as_list()[-1] # emb_size
        # linear projection with dimension unchaangned
        new_key = tf.layers.dense(key, units=d_model, activation=None) # batch_size * key_len * emb_size
        new_value = tf.layers.dense(value, units=d_model, activation=None)
        new_query = tf.layers.dense(query, units=d_model, activation=None)

        # split d_model by num_head and compute attention in parallel
        # (batch_size * num_head) * key_len * (emb_size/num_head)
        new_key = tf.concat(tf.split(new_key, num_or_size_splits=params['num_head'], axis=-1), axis=0)
        new_value = tf.concat(tf.split(new_value, num_or_size_splits=params['num_head'], axis=-1), axis=0)
        new_query = tf.concat(tf.split(new_query, num_or_size_splits=params['num_head'], axis=-1), axis=0)

        # calculate dot-product attention
        weighted_val = scaled_dot_product_attention(new_key, new_value, new_query, tf.tile(mask, [params['num_head'], 1, 1]))

        # concat num_head back
        # (batch_size * num_head) * query_len * (emb_size/num_head) -&amp;gt; batch_size * query_len * emb_size
        weighted_val = tf.concat(tf.split(weighted_val, num_or_size_splits=params['num_head'], axis=0), axis=-1)

        # Linear projection
        weighted_val = tf.layers.dense(weighted_val, units=d_model, activation=None)
        # Do dropout
        weighted_val = tf.layers.dropout(weighted_val, rate=params['dropout_rate'],
                                         training=(mode == tf.estimator.ModeKeys.TRAIN))
        add_layer_summary('raw_multi_head', weighted_val)
        weighted_val = add_and_norm_layer(query, weighted_val)

    return weighted_val
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;positional-encoding&quot;&gt;positional encoding&lt;/h3&gt;
&lt;p&gt;清楚了上面的multi-head的attention会发现有一个问题，就是attention的计算并没有考虑到词的相对和绝对位置，这意味着‘fox hunt rabbit at night’和'rabbit hunt fox at night'会有完全一样的向量表达。Transformer的处理是加入了positional encoding，模型的输入变为word embedding + positional encoding，因此要求positional encoding和embedding的维度相同都是&lt;span class=&quot;math inline&quot;&gt;\(d_{model}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;举个🌰(以下句子去除停用词）&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;句1: Dog sit on chair&lt;/li&gt;
&lt;li&gt;句2: Cat is sleeping on floor&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;要想全面的表达位置信息，transformer需要满足以下4个条件&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;相对距离: on和chair，on和floor, sit 和on, sleeping和on的相对距离都是1，它们之间的相对距离相同，且和绝对位置以及句子长度无关&lt;/li&gt;
&lt;li&gt;绝对位置：dog和cat都是句子的第一个词，它们的绝对位置相同, encoding需要一致&lt;/li&gt;
&lt;li&gt;句子长度：encoding需要能够generalize到训练样本中unseen的句子长度&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如果我们用[0,句子长度]，步长为1，不满足条件3，如果测试集出现更长的句子会无法处理。如果用[0,1], 步长为1/句长，不满足条件2，因为不同长度的句子步长代表的相对距离不一致。让我们看看Transformer是如何做encoding的&lt;/p&gt;
&lt;p&gt;\[PE(pos, i)= \begin{cases} sin(pos /w_k),&amp;amp; \text{if i=2k}\\ cos(pos /w_k),&amp;amp; \text{if i=2k+1} \end{cases} \]&lt;/p&gt;
&lt;p&gt;\[w_k = 10000^{2k/d_{model}} \]&lt;/p&gt;
&lt;p&gt;因为PE不是trainable变量，所以可以在最开始算好，然后用输入的position去lookup的，实现如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;def positional_encoding(d_model, max_len, dtype):
    with tf.variable_scope('positional_encoding'):
        encoding_row = np.array([10000**((i-i%2)/d_model) for i in range(d_model)])
        encoding_matrix = np.array([i/encoding_row for i in range(max_len)])

        def sin_cos(row):
            row = [np.cos(val) if i%2 else np.sin(val) for i, val in enumerate(row)]
            return row

        encoding_matrix = np.apply_along_axis(sin_cos, 1, encoding_matrix)
        encoding_matrix = tf.cast(tf.constant(encoding_matrix), dtype)

    return encoding_matrix
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还是上面的句子，假设&lt;span class=&quot;math inline&quot;&gt;\(d_{model}=4\)&lt;/span&gt;，Dog sit on chair的&lt;span class=&quot;math inline&quot;&gt;\(PE\)&lt;/span&gt;如下&lt;/p&gt;
&lt;p&gt;\[\begin{array}{c|c} d_{model} &amp;amp; \text{Dog} &amp;amp; \text{sit} &amp;amp; \text{on} &amp;amp; \text{chair} \\ \hline 0 &amp;amp; sin(\frac{0}{10000^{0/4}}) &amp;amp; sin(\frac{1}{10000^{0/4}}) &amp;amp; sin(\frac{2}{10000^{0/4}}) &amp;amp; sin(\frac{3}{10000^{0/4}}) \\ 1 &amp;amp; cos(\frac{0}{10000^{0/4}}) &amp;amp; cos(\frac{1}{10000^{0/4}}) &amp;amp; cos(\frac{2}{10000^{0/4}}) &amp;amp; cos(\frac{3}{10000^{0/4}}) \\ 2 &amp;amp; sin(\frac{0}{10000^{2/4}}) &amp;amp; sin(\frac{1}{10000^{2/4}}) &amp;amp; sin(\frac{2}{1000^{2/4}}) &amp;amp;sin(\frac{3}{1000^{2/4}}) \\ 3 &amp;amp; cos(\frac{0}{10000^{2/4}}) &amp;amp; cos(\frac{1}{10000^{2/4}}) &amp;amp; cos(\frac{2}{10000^{2/4}}) &amp;amp; cos(\frac{3}{10000^{2/4}}) \\ \end{array} \]&lt;/p&gt;
&lt;p&gt;清楚计算方式后，不知道你是不是也有如下的困惑&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;这sin/cos的设计有何目的？肯定不是为了好看嘛&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(w_k\)&lt;/span&gt;的计算又是为了啥？encoding不能是个scaler么？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;第一个困惑要看下positional encoding的使用场景。之前提到positional encoding是直接加在word embedding上作为输出，之后会在计算attention的过程中在两两向量内积时被使用，可能会表达类似相对距离越近attention权重越高之类的信息。因此这里表达位置和距离是依赖encoding做向量乘法，而使用sin/cos的好处在于位移和绝对位置无关，也就是&lt;span class=&quot;math inline&quot;&gt;\(PE(pos+\Delta)=f(\Delta) * PE(pos)\)&lt;/span&gt;，详细推导看这里&lt;a href=&quot;https://timodenk.com/blog/linear-relationships-in-the-transformers-positional-encoding/&quot; target=&quot;_blank&quot;&gt;Timo Denk's Blog&lt;/a&gt;, 以&lt;span class=&quot;math inline&quot;&gt;\(d_{model}=2\)&lt;/span&gt;为例，线性变换如下&lt;/p&gt;
&lt;p&gt;\[\begin{bmatrix} sin(w_k, pos+\Delta) \\ cos(w_k, pos+\Delta)\\ \end{bmatrix}= \begin{bmatrix} cos(w_k,\Delta) &amp;amp; sin(w_k,\Delta) \\ -sin(w_k,\Delta) &amp;amp; cos(w_k,\Delta) \\ \end{bmatrix} \cdot \begin{bmatrix} sin(w_k, pos) \\ cos(w_k, pos)\\ \end{bmatrix} \]&lt;/p&gt;
&lt;p&gt;第二个困惑也就是&lt;span class=&quot;math inline&quot;&gt;\(w_k\)&lt;/span&gt;在embedding维度的计算。有人说是为了和embedding做向量加法，但上面的线性变换只要有一个[sin,cos]对就能做到，那我把&lt;span class=&quot;math inline&quot;&gt;\(R^2\)&lt;/span&gt; broadcast到&lt;span class=&quot;math inline&quot;&gt;\(R^{d_{model}}\)&lt;/span&gt;不成么， 毕竟PE只是个常量并不trinable。这里&lt;span class=&quot;math inline&quot;&gt;\(w_k\)&lt;/span&gt;的计算是随着k的上升降低了sin/cos的&lt;a href=&quot;https://mathbitsnotebook.com/Algebra2/TrigGraphs/TGTrigVocab.html#:~:text=The%20frequency%20of%20a%20trigonometric,the%20sine%20and%20cosine%20curves.&amp;amp;text=This%20sine%20curve,%20y%20=%20sin%20x,%20completes%201%20cycle,in%20the%20interval%20of%202%CF%80.&quot; target=&quot;_blank&quot;&gt;Frequency&lt;/a&gt;, PE在不同pos随i的变化如下图&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://imgkr2.cn-bj.ufileos.com/bbbe1f25-0800-4ad0-b557-d4ce938e8cb5.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;amp;Signature=VvDKdLVBQzmCD88gFSXvffYqwtY%253D&amp;amp;Expires=1612750306&quot; width=&quot;550&quot; height=&quot;350&quot;/&gt;&lt;/p&gt;

&lt;p&gt;看个极端case当&lt;span class=&quot;math inline&quot;&gt;\(2k \to d_{model}\)&lt;/span&gt;，PE会近似constant，其中&lt;span class=&quot;math inline&quot;&gt;\(sin(pos/k) \to 0\)&lt;/span&gt;, &lt;span class=&quot;math inline&quot;&gt;\(cos(pos/k) \to 1\)&lt;/span&gt;，和embedding结合来看，部分语义信息的提取更多依赖位置信息，自然也存和位置信息依赖较少或者无关的信息，在embedding纬度上做差异化的位置信息表达，可以帮助模型学到这一点～&lt;/p&gt;
&lt;h3 id=&quot;add--norm&quot;&gt;Add &amp;amp; Norm&lt;/h3&gt;
&lt;p&gt;Transformer 每个Block之后都会都跟一层Add &amp;amp; Norm,也就是先做residua再做Layer Norm。如果Add &amp;amp; Norm是跟在multi-head Attention之后，这一层的计算便是 Layer_norm(x + multi-head(x))。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;def layer_norm(x):
    with tf.variable_scope('layer_normalization', reuse=tf.AUTO_REUSE):
        d_model = x.shape.as_list()[-1]
        epsilon = tf.constant(np.finfo(np.float32).eps)
        mean, variance = tf.nn.moments(x, axes=-1, keep_dims=True)
        x = (x - mean)/((variance + epsilon)**0.5) # do layer norm

        kernel = tf.get_variable('norm_kernel', shape=(d_model,), initializer=tf.ones_initializer())
        bias = tf.get_variable('norm_bias', shape=(d_model,),initializer=tf.zeros_initializer())
        x= tf.multiply(kernel, x) +bias
    return x
    
def add_and_norm_layer(x, sub_layer_x):
    with tf.variable_scope('add_and_norm'):
        x = tf.add(x, sub_layer_x)
        x = layer_norm(x)
    return x
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;residual-connection&quot;&gt;Residual Connection&lt;/h4&gt;
&lt;p&gt;对于Residual Connection，还是推荐之前在CTR DeepCrossing里推荐过的一篇文章&lt;a href=&quot;https://zhuanlan.zhihu.com/p/80226180&quot; target=&quot;_blank&quot;&gt;残差网络解决了什么，为什么有效？&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;简单来说是为了解决网络退化的问题，既随着网络深度增加，网络的表现先是逐渐增加接近饱和，然后迅速下降。这里的下降并非指参数增加导致的过拟合，而是理论上如果10层便是最优解，而你的网络有20层，虽然20层包含了10层的信息，理论上后10层只要做恒等变化把第10层的结果传递出去就行，但结果却变得很差，原因更多怀疑是神经网络较难学习这种恒等变幻。&lt;/p&gt;
&lt;p&gt;放在Transformer里除了以上的作用，也有传递底层词向量和positional encoding信息的作用，我们既希望通过串联的Attention来不断抽取更抽象底层的信息，但也同时希望向前传递Bag of words信息以及positional encoding携带的相对/绝对位置信息。Anyway残差结构都带着更多pratical science的经验主义，如果有其他的观点欢迎一起讨论哟～&lt;/p&gt;
&lt;h4 id=&quot;layer-normalization&quot;&gt;Layer Normalization&lt;/h4&gt;
&lt;p&gt;LayerNorm也推荐一篇文章&lt;a href=&quot;https://zhuanlan.zhihu.com/p/33173246&quot; target=&quot;_blank&quot;&gt;详解深度学习中的Normalization，BN/LN/WN&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;LayerNorm没有BatchNorm那么常用。Batch Norm的假设是所有样本的同一个特征（神经元）服从相同的分布，因此用采样的样本（mini-batch）来估计总体在某个特征上的均值和方差来做归一化。但BatchNorm对于sequence输入并不适用，因为不同输入的序列长度同一个特征有的样本有有的没有，自然不满足同分布的假设。而LayerNorm的假设是每个样本的某一层layer是同分布的，因此是每个样本自身计算stat来做归一化。&lt;/p&gt;
&lt;p&gt;神经元有点抽象，让我们用传统ML来举个🌰～ 一个预测债券价格的模型有2个特征：历史价格和做市商报价。多数情况下的归一化都是按列进行，所有样本的历史价格，做市商报价进行归一化，对应batch=全样本的BatchNorm。而LayerNorm对应每个样本的历史价格，做市商报价自己进行归一化，多数情况下因为不同特征的量纲不同很少做行正则。但如果不同债券的类型不同，多数在100少数在30，而所有特征都是不同来源的报价，这时对行做正则可能效果更好，因为特征间分布比样本间一致性更高。&lt;/p&gt;
&lt;p&gt;回到transformer，这里的layer Norm是embedding的维度上进行正则化，也就是每个样本每个token的embedding自身做归一化。&lt;/p&gt;
&lt;h3 id=&quot;feed-forward-layer&quot;&gt;Feed Forward Layer&lt;/h3&gt;
&lt;p&gt;每个Multi-head的Attention之后都会跟一个Feed Forward Blok， 是一个两层的全联接神经网络, 中间层是relu，既帮助Attention的输出提取更抽象的信息，也通过relu过滤无效信息保留更重要的部分。&lt;/p&gt;
&lt;p&gt;\[FFN(h_i) = Relu(h_iw_1 + b_1)w_2 + b_2 \]&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;def ffn(x, params, mode):
    with tf.variable_scope('ffn', reuse=tf.AUTO_REUSE):
        d_model = x.shape.as_list()[-1]  # emb_size
        y = tf.layers.dense(x, units=params['ffn_hidden'], activation='relu')

        y = tf.layers.dense(y, units=d_model, activation=None)
        y = tf.layers.dropout(y, rate=params['dropout_rate'],
                              training=(mode == tf.estimator.ModeKeys.TRAIN))

        y = add_and_norm_layer(x, y)
    return y

&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;模型实现&quot;&gt;模型实现&lt;/h2&gt;
&lt;p&gt;愉快的拼乐高时间到，我们来按照以下的模型图来组合上面的组件，分成encoding和decoding两个部分。我选了个英文-&amp;gt;中文的翻译任务来实现transformer，完整代码详见&lt;a href=&quot;https://github.com/DSXiangLi/Embedding/tree/master/transformer&quot; target=&quot;_blank&quot;&gt;DSXiangLi-Embedding-transformer&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://imgkr2.cn-bj.ufileos.com/8e570333-d2b5-41d0-bac5-da95c9e5e9e0.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;amp;Signature=vS2SCW21vuSTYcHu6hvt5hlv4pA%253D&amp;amp;Expires=1612793005&quot; width=&quot;300&quot; height=&quot;450&quot;/&gt;&lt;/p&gt;

&lt;h3 id=&quot;encoder&quot;&gt;Encoder&lt;/h3&gt;
&lt;p&gt;Encoding的输入是padding的sequence先做词向量映射得到 batch * pad_len * emb_size的词向量矩阵, 再加上相同维度的positional encoding向量。计算部分比较简单是由6个self-attention layer串联构成。&lt;/p&gt;
&lt;p&gt;每个self-attention layer都包括, multi-head attention，encoder source自身既是query也是key和value，过Add&amp;amp;Norm层同时保留变换前和变换后的信息，再过Feed Forward层做更多的信息提取，再过Add&amp;amp;Norm。这其中需要注意的便是所有操作的dimension都是&lt;span class=&quot;math inline&quot;&gt;\(d_{model}\)&lt;/span&gt;，因此输入纬度不会被改变一直保持到Encoder输出。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;def encode(self, features, mode):
    with tf.variable_scope('encoding', reuse=tf.AUTO_REUSE):
        encoder_input = self.embedding_func(features['tokens'], mode) # batch * seq_len * emb_size
        self_mask = seq_mask_gen(features, self.params)

        for i in range(self.params['encode_attention_layers']):
            with tf.variable_scope('self_attention_layer_{}'.format(i), reuse=tf.AUTO_REUSE):
                encoder_input = multi_head_attention(key=encoder_input, query=encoder_input, value=encoder_input,
                                                     mask=self_mask, params=self.params, mode=mode)

                encoder_input = ffn(encoder_input, self.params, mode)

    return ENCODER_OUTPUT(output=encoder_input, state=encoder_input[:, -1, :])
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;decoder&quot;&gt;Decoder&lt;/h3&gt;
&lt;p&gt;Decoder和encoder一样也是6个layer串联。和Encoder相比只是在self-attention和FFN之间多了一层encoder-decoder attention，这时key和value是encoder的输出，query是decoder在self-attention之后的输出，学习的是encoder和decoder间的关联信息。&lt;/p&gt;
&lt;p&gt;Decoding部分略复杂些在于训练和预测存在差异，原因是训练会使用teacher forcing用T以前的真实token预测T+1。而预测时真实token未知，因此需要使用loop先预测T=1，拿预测[0,1]去预测T=2，再不断滚动向前预测&lt;/p&gt;
&lt;p&gt;以下是训练时使用Teacher Forcing的Demo,decoder的输入文本在source和target要做不同的处理, source第一个token加入&lt;span class=&quot;math inline&quot;&gt;\(\lt go\gt\)&lt;/span&gt;标记文本开始，如下&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://static01.imgkr.com/temp/581eb15bc4ef486dbdd11acd501b7557.png&quot; width=&quot;600&quot; height=&quot;100&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这样预测时默认从&lt;span class=&quot;math inline&quot;&gt;\(\lt go\gt\)&lt;/span&gt;开始，同时形成错位用source&amp;lt;=T的token预测T+1的token，刚好对齐target的第T个token，模型预测如下&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://imgkr2.cn-bj.ufileos.com/1dbf2fe6-ca3c-4d09-8a07-094d2bfc3751.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;amp;Signature=rYFWnSyzTlO%252Bkdji65Q0M1sj2Zw%253D&amp;amp;Expires=1612793738&quot; width=&quot;600&quot; height=&quot;100&quot;/&gt;&lt;/p&gt;

&lt;p&gt;以下是训练部分的Decoder&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;def _decode_helper(self, encoder_output, features, labels, mode):
    decoder_input = self.embedding_func(labels['tokens'], mode)  # batch * seq_len * emb

    self_mask = future_mask_gen(labels, self.params)
    encoder_mask = seq_mask_gen(features, self.params)

    for i in range(self.params['decode_attention_layers']):
        with tf.variable_scope('attention_layer_{}'.format(i), reuse=tf.AUTO_REUSE):
            with tf.variable_scope('self_attention', reuse=tf.AUTO_REUSE):
                decoder_input = multi_head_attention(key=decoder_input, value=decoder_input,
                                                     query=decoder_input, mask=self_mask,
                                                     params=self.params, mode=mode)
            with tf.variable_scope('encode_attention', reuse=tf.AUTO_REUSE):
                decoder_input = multi_head_attention(key=encoder_output.output, value=encoder_output.output,
                                                     query=decoder_input, mask=encoder_mask,
                                                     params=self.params, mode=mode)

            decoder_input = ffn(decoder_input, self.params, mode)

    # use share embedding weight for linear project from emb_size to vocab_size
    logits = tf.matmul(decoder_input, self.embedding, transpose_b=True)  # seq_len * emb_size-&amp;gt;seq_len * target_vocab_size

    return DECODER_OUTPUT(output=logits, state=decoder_input, seq_len=labels['seq_len'])
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;模型训练&quot;&gt;模型训练&lt;/h3&gt;
&lt;p&gt;论文中还有不少的训练细节，例如&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;每个layer之后都跟了drop out&lt;/li&gt;
&lt;li&gt;learning rate选取了先上升再下降的noam scheme&lt;/li&gt;
&lt;li&gt;样本按句子长度排序&lt;/li&gt;
&lt;li&gt;每个batch保证有近似的单词数，而非相同的句子数&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以及在训练中发现batch_size太小模型完全不收敛等等。考虑这些细节比较task-specific(有点玄学），感兴趣的盆友们可以去看下Martin Popel的Training Tips for the Transformer Model，里面有更多的细节。后面我们更多只用到transformer的encoder部分来提取文本信息，这里就不多说啦～&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;reference&quot;&gt;Reference&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;Attention is all you need,&lt;/li&gt;
&lt;li&gt;On Layer Normalization in the Transformer Architecture, 2020&lt;/li&gt;
&lt;li&gt;Analyzing Multi-Head Self-Attention:&lt;br/&gt;Specialized Heads Do the Heavy Lifting, the Rest Can Be Pruned, 2019&lt;/li&gt;
&lt;li&gt;Multi-Head Attention: Collaborate Instead of Concatenate, 2020&lt;/li&gt;
&lt;li&gt;What Does BERT Look At? An Analysis of BERT’s Attention, 2019&lt;/li&gt;
&lt;li&gt;ON THE RELATIONSHIP BETWEEN SELF-ATTENTION AND CONVOLUTIONAL LAYERS,2020&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/lena-voita/the-story-of-heads&quot; target=&quot;_blank&quot;&gt;https://github.com/lena-voita/the-story-of-heads&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://jbcordonnier.com/posts/attention-cnn/&quot; target=&quot;_blank&quot;&gt;http://jbcordonnier.com/posts/attention-cnn/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://towardsdatascience.com/deconstructing-bert-part-2-visualizing-the-inner-workings-of-attention-60a16d86b5c1&quot; target=&quot;_blank&quot;&gt;https://towardsdatascience.com/deconstructing-bert-part-2-visualizing-the-inner-workings-of-attention-60a16d86b5c1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://jalammar.github.io/illustrated-transformer/&quot; target=&quot;_blank&quot;&gt;http://jalammar.github.io/illustrated-transformer/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/33173246&quot; target=&quot;_blank&quot;&gt;详解深度学习中的Normalization，BN/LN/WN&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/84614490&quot; target=&quot;_blank&quot;&gt;Transformer中warm-up和LayerNorm的重要性探究&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.zhihu.com/question/341222779/answer/814111138&quot; target=&quot;_blank&quot;&gt;https://www.zhihu.com/question/341222779/answer/814111138&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Kyubyong/transformer&quot; target=&quot;_blank&quot;&gt;https://github.com/Kyubyong/transformer&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Mon, 08 Feb 2021 00:15:00 +0000</pubDate>
<dc:creator>风雨中的小七</dc:creator>
<og:description>上一章我们聊了聊quick-thought通过干掉decoder加快训练, CNN—LSTM用CNN作为Encoder并行计算来提速等方法，这一章看看抛开CNN和RNN，transformer是如何只</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/gogoSandy/p/14386998.html</dc:identifier>
</item>
<item>
<title>为何现在响应式编程在业务开发微服务开发不普及 - 干货满满张哈希</title>
<link>http://www.cnblogs.com/zhxdick/p/14387449.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhxdick/p/14387449.html</guid>
<description>&lt;p&gt;为何现在响应式编程在业务开发微服务开发不普及&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主要因为数据库 IO，不是 NIO。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不论是Java自带的Future框架，还是 Spring WebFlux，还是 Vert.x，他们都是一种非阻塞的基于Ractor模型的框架（后两个框架都是利用netty实现）。&lt;/p&gt;
&lt;p&gt;在阻塞编程模式里，任何一个请求，都需要一个线程去处理，如果io阻塞了，那么这个线程也会阻塞在那。但是在非阻塞编程里面，基于响应式的编程，线程不会被阻塞，还可以处理其他请求。举一个简单例子：假设只有一个线程池，请求来的时候，线程池处理，需要读取数据库 IO，这个 IO 是 NIO 非阻塞 IO，那么就将请求数据写入数据库连接，直接返回。之后数据库返回数据，这个链接的 Selector 会有 Read 事件准备就绪，这时候，再通过这个线程池去读取数据处理（相当于回调），这时候用的线程和之前不一定是同一个线程。这样的话，线程就不用等待数据库返回，而是直接处理其他请求。这样情况下，即使某个业务 SQL 的执行时间长，也不会影响其他业务的执行。&lt;/p&gt;
&lt;p&gt;但是，这一切的基础，是 IO 必须是非阻塞 IO，也就是 NIO（或者 AIO）。&lt;strong&gt;官方JDBC没有 NIO，只有 BIO 实现&lt;/strong&gt;。这样无法让线程将请求写入链接之后直接返回，必须等待响应。但是也就解决方案，就是通过其他线程池，专门处理数据库请求并等待返回进行回调，也就是业务线程池 A 将数据库 BIO 请求交给线程池B处理，读取完数据之后，再交给 A 执行剩下的业务逻辑。这样A也不用阻塞，可以处理其他请求。但是，这样还是有因为某个业务 SQL 的执行时间长，导致B所有线程被阻塞住队列也满了从而A的请求也被阻塞的情况，这是不完美的实现。真正完美的，需要 JDBC 实现 NIO。&lt;/p&gt;
&lt;p&gt;Java 自带的 Future 框架可以这么用JDBC：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@GetMapping
public DeferredResult&amp;lt;Result&amp;gt; get() {
DeferredResult&amp;lt;Result&amp;gt; deferredResult = new DeferredResult&amp;lt;&amp;gt;();
CompletableFuture.supplyAsync(() -&amp;gt; {
            return 阻塞数据库IO;
        //dbThreadPool用来处理阻塞的数据库IO
        }, dbThreadPool).thenComposeAsync(result -&amp;gt; {
    //spring 的 DeferredResult 来实现异步回调写入结果返回
    deferredResult.setResult(result);
});
return deferredResult;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;WebFlux 也可以使用阻塞JDBC，但是同理：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@GetMapping
public Mono&amp;lt;Result&amp;gt; get() {
return Mono.fromFuture(CompletableFuture.supplyAsync(() -&amp;gt; {
            return 阻塞数据库IO;
        //dbThreadPool用来处理阻塞的数据库IO
        }, dbThreadPool));
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Vert.x 也可以使用阻塞的JDBC，也是同理：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@GetMapping
public  DeferredResult&amp;lt;Result&amp;gt; get() {
DeferredResult&amp;lt;Result&amp;gt; deferredResult = new DeferredResult&amp;lt;&amp;gt;();
getResultFromDB().setHandler(asyncResult -&amp;gt; {
            if (asyncResult.succeeded()) {
                deferredResult.setResult(asyncResult.result());
            } else {
                deferredResult.setErrorResult(asyncResult.cause());
            }
        });
return deferredResult;
}

private WorkerExecutor dbThreadPool = vertx.createSharedWorkerExecutor(&quot;DB&quot;, 16);

private Future&amp;lt;Result&amp;gt; getResultFromDB() {
    Future&amp;lt;Result&amp;gt; result = Future.future();
    dbThreadPool.executeBlocking(future -&amp;gt; {
            return 阻塞数据库IO;
        }, false, asyncResult -&amp;gt; {
            if (asyncResult.succeeded()) {
                result.complete(asyncResult.result());
            } else {
                result.fail(asyncResult.cause());
            }
        });
    return result;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;相当于通过另外的线程池（当然也可以通过原有线程池，反正就是要用和请求不一样的线程，才能实现回调，而不是当次就阻塞等待），封装了阻塞 JDBC IO。&lt;/p&gt;
&lt;p&gt;但是，这样几乎对数据库IO主导的应用性能没有提升，还增加了线程切换，得不偿失。所以，需要使用真正实现了 NIO 的数据库客户端。目前有这些 NIO 的 JDBC 客户端，但是都不普及：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Vert.x 客户端：&lt;a href=&quot;https://vertx.io/docs/vertx-jdbc-client/java/&quot; target=&quot;_blank&quot;&gt;https://vertx.io/docs/vertx-jdbc-client/java/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;r2jdbc 客户端：&lt;a href=&quot;http://r2dbc.io/&quot; target=&quot;_blank&quot;&gt;http://r2dbc.io/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Jasync-sql 客户端：&lt;a href=&quot;https://github.com/jasync-sql/jasync-sql&quot; target=&quot;_blank&quot;&gt;https://github.com/jasync-sql/jasync-sql&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;每日一刷，轻松提升技术，斩获各种offer：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://zhxhash-blog.oss-cn-beijing.aliyuncs.com/qr-code.jpg&quot; alt=&quot;image&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 07 Feb 2021 19:22:00 +0000</pubDate>
<dc:creator>干货满满张哈希</dc:creator>
<og:description>为何现在响应式编程在业务开发微服务开发不普及 主要因为数据库 IO，不是 NIO。 不论是Java自带的Future框架，还是 Spring WebFlux，还是 Vert.x，他们都是一种非阻塞的基</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhxdick/p/14387449.html</dc:identifier>
</item>
<item>
<title>前端模块化之ES Module - RisingSunBlogs</title>
<link>http://www.cnblogs.com/zhaojian-08/p/14385312.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhaojian-08/p/14385312.html</guid>
<description>&lt;h2 id=&quot;一、概述&quot;&gt;一、概述&lt;/h2&gt;
&lt;p&gt;之前提到的几种模块化规范：CommonJS、AMD、CMD都是社区提出的。ES 2015在语言层面上实现了模块功能，且实现简单，可以替代CommonJS和AMD规范，成为在服务器和浏览器通用的解决方案&lt;/p&gt;
&lt;h2 id=&quot;二、特性&quot;&gt;二、特性&lt;/h2&gt;
&lt;h4 id=&quot;1、es-module自动启用严格模式&quot;&gt;1、ES Module自动启用严格模式&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt; &amp;lt;script type=&quot;module&quot;&amp;gt;
        console.log(this); //undefined
  &amp;lt;/script&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;2、es-module运行在单独的作用域中，与外界互不干扰&quot;&gt;2、ES Module运行在单独的作用域中，与外界互不干扰&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;    &amp;lt;script type=&quot;module&quot;&amp;gt;
        var foo = 100;
        console.log(foo);//100
    &amp;lt;/script&amp;gt;
    &amp;lt;script type=&quot;module&quot;&amp;gt;
        console.log(foo);//Uncaught ReferenceError: foo is not defined
    &amp;lt;/script&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;3、es-module是通过cors方式请求外部文件，需外部文件支持cors请求&quot;&gt;3、ES Module是通过CORS方式请求外部文件，需外部文件支持CORS请求&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt; //该文件支持CORS请求，则可以请求成功
&amp;lt;script type=&quot;module&quot; src=&quot;http://code.jquery.com/jquery-migrate-1.2.1.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;

//该文件不支持CORS请求，报跨域错误
&amp;lt;script type=&quot;module&quot; src=&quot;http://libs.baidu.com/jquery/2.0.0/jquery.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt; 
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;4、es-module引用的文件会延迟执行&quot;&gt;4、ES Module引用的文件会延迟执行&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;//index.js
alert('hello');
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;//index.html
&amp;lt;body&amp;gt;
        &amp;lt;script type=&quot;module&quot; src=&quot;./index.js&quot;&amp;gt;&amp;lt;/script&amp;gt; 等价于   &amp;lt;script defer src=&quot;./index.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
        &amp;lt;p&amp;gt;
             文本内容
        &amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;执行结果【js的加载并未影响到DOM的加载】&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/741018/202102/741018-20210207151816321-1247304482.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;三、export命令&quot;&gt;三、export命令&lt;/h2&gt;
&lt;p&gt;由于在ES Module中，每个模块都是一个单独的作用域，如果想使模块内的变量暴露出去，使用&lt;strong&gt;export&lt;/strong&gt;关键字，导入其他模块的关键字使用&lt;strong&gt;import&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&quot;1、挨个导出变量&quot;&gt;1、挨个导出变量&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;//module.js
export var name = &quot;张三&quot;;

export function add(a, b) {
    return a + b;
}

export var obj = {
    name: 'jack'
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;2、批量导出变量&quot;&gt;2、批量导出变量&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;//module.js
var name = &quot;张三&quot;;

function add(a, b) {
    return a + b;
}

var obj = {
    name: 'jack'
};

export { name, add, obj }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;优点：在脚本尾部，使用一个export统一导出，清晰简洁&lt;/p&gt;
&lt;h4 id=&quot;3、导出默认数据&quot;&gt;3、导出默认数据&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;//module.js
export default 'es module'
或者
export default function(a,b){
        return a+b;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;说完import后再说注意事项&lt;/p&gt;
&lt;h4 id=&quot;4、导出时起别名，使用as关键字&quot;&gt;4、导出时起别名，使用as关键字&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;//module.js
var name = &quot;张三&quot;;

function add(a, b) {
    return a + b;
}

var obj = {
    name: 'jack'
};

export { name as v1, add as v2, obj as v3}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;四、import命令&quot;&gt;四、import命令&lt;/h2&gt;
&lt;p&gt;要想接受其他模块通过export导出的成员时，使用import关键字&lt;/p&gt;
&lt;h4 id=&quot;1、import导入其他模块中的变量&quot;&gt;1、import导入其他模块中的变量&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;//module.js
var name = &quot;张三&quot;;

function add(a, b) {
    return a + b;
} 

export { name ,add }
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;//app.js
import { name, add as MathAdd} from &quot;./module.js&quot;
console.log(name);//张三
console.log(MathAdd(1, 1)) //2
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;h5 id=&quot;11使用相对路径-后缀名和不能省略&quot;&gt;1.1使用相对路径 后缀名和./不能省略&lt;/h5&gt;
&lt;p&gt;​ import {name} from &quot;./module.js&quot;&lt;/p&gt;
&lt;h5 id=&quot;12使用绝对路径&quot;&gt;1.2使用绝对路径&lt;/h5&gt;
&lt;p&gt;​ import {name} from &quot;/demo/module.js&quot;&lt;/p&gt;
&lt;h5 id=&quot;13使用全路径&quot;&gt;1.3使用全路径&lt;/h5&gt;
&lt;p&gt;​ import {name} from &quot;&lt;a href=&quot;http://localhost:8080/demo/module.js&quot; target=&quot;_blank&quot;&gt;http://localhost:8080/demo/module.js&lt;/a&gt;&quot;&lt;/p&gt;
&lt;h5 id=&quot;14可以在导入模块时使用as-起别名&quot;&gt;1.4可以在导入模块时使用as 起别名&lt;/h5&gt;
&lt;p&gt;​ 起别名后，as前的变量不可使用了&lt;/p&gt;
&lt;h4 id=&quot;2、使用import只执行引入文件，不提取引入文件中的成员时&quot;&gt;2、使用import只执行引入文件，不提取引入文件中的成员时&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;import {} from &quot;./module.js&quot;;&lt;/li&gt;
&lt;li&gt;import './module.js'【常用】&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;//module.js
console.log('module.js中执行')

var name = &quot;张三&quot;;

function add(a, b) {
    return a + b;
}

var obj = {
    name: 'jack'
};

export { name, add, obj }
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;//app.js
import {} from &quot;./module.js&quot;;
或者写成
import './module.js'
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;//index.html
&amp;lt;body&amp;gt;
    &amp;lt;script type=&quot;module&quot; src=&quot;./app.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    //执行结果
    //module.js中执行
&amp;lt;/body&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当多次执行同一个import语句时，只会执行一次&lt;/p&gt;
&lt;h4 id=&quot;3、模块的整体加载&quot;&gt;3、模块的整体加载&lt;/h4&gt;
&lt;p&gt;使用import除了可以加载单个值，也可以一次性加载模块导出的所有值&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;//module.js

var name = &quot;张三&quot;;

function add(a, b) {
    return a + b;
}

var obj = {
    name: 'jack'
};

export { name, add, obj }
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;//app.js
import * as all './module.js'
console.log('name:',all.name);
console.log('obj',all.obj);
console.log(add(1,1))
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;五、export-default&quot;&gt;五、export default&lt;/h2&gt;
&lt;p&gt;前面使用export导出模块内的成员时，需要指定具体的成员名称，同样加载时需要根据导出的具体名称进行加载。还有一种快捷的导出方式，使用export default 为模块指定默认导出，&lt;strong&gt;每个模块只能使用一次export default&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&quot;1、导出匿名成员时，使用任意变量接受成员&quot;&gt;1、导出匿名成员时，使用任意变量接受成员&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;//module.js
export default function(a, b) {
    return a + b;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt; //app.js
 import add from &quot;./module.js&quot;; 
 console.log(add(1,2));
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为使用export导出成员时是匿名的，所以在导入时并不知道这个成员的名字是什么，这时候就可以随意写变量去接受这个匿名成员，案例中使用add接受的匿名函数，也可以使用其他名称接收。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：export default也可以导出具名成员，但效果和导出匿名成员是一样的&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;//module.js
export default function add(a, b) {
    return a + b;
}
//或者
function add(a,b){
    return a + b;
}
export default add
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt; //app.js
 import temp from &quot;./module.js&quot;; 
 console.log(temp(1,2));
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;总结：使用export default导出成员，在外部加载时都视为匿名成员加载，可以随意起变量名接受&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;2、同时导入其他模块的默认成员和具名成员时&quot;&gt;2、同时导入其他模块的默认成员和具名成员时&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;//module.js
var name = 'jack';
var age = 19;
export { name, age } 

//导出默认成员
export default 'default export'
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;//app.js
import str,{name,age} from &quot;./module.js&quot;;
或者
import {name,age,default as str} from &quot;./module.js&quot;
console.log(str);//default export
console.log(name);//jack
console.log(age);//19
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;3、另类的默认导出&quot;&gt;3、另类的默认导出&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;//module.js
var number = 1;
export { number as default }
等同于
export default number;
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;//app.js
import { default as number} from &quot;./module.js&quot;
console.log(number); //1
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;总结：可见export default的本质就是导出一个名字叫default的成员，当导出的成员叫default时，接受这个成员可以随意命名&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;4、使用export-default来导出类&quot;&gt;4、使用export default来导出类&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;//Person.js
export default class Person(){
    ....
}


//main.js
import Person from &quot;./Person.js&quot;;
const person = new Person();
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;5、比较一下默认输出和正常输出&quot;&gt;5、比较一下默认输出和正常输出&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;//1.默认输出
export default function add(a,b){
    return a + b;
}
//接受默认输出
import temp from './module.js'

//2.具名输出
function add (a,b){
    return a + b;
}
export {add}
//接受具名输出
import {add} from './module.js'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;总结：使用默认导出时，在外部接受成员，不需要使用大括号；使用具名输出时，在外部接受成员时，import后需要使用大括号&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;六、迷惑性的点&quot;&gt;六、迷惑性的点&lt;/h2&gt;
&lt;h4 id=&quot;1、export批量导出变量时，导出的并不是对象字面量&quot;&gt;1、export批量导出变量时，导出的并不是对象字面量&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;//module.js
var name = 'jack';
var age = 19;
export { name, age } 
//export {name,age} 并不是导出的一个对象，而是export批量导出的语法
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;2、import加载多个变量时，并不是es6的解构用法&quot;&gt;2、import加载多个变量时，并不是ES6的解构用法&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;import {name,age} from &quot;./module.js&quot;
//impot后面的大括号并不是解构作用
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;3、import导入的变量都是常量，不可修改，与commonjs不同&quot;&gt;3、import导入的变量都是常量，不可修改，与CommonJS不同&lt;/h4&gt;
&lt;h2 id=&quot;七、export和import的复合用法&quot;&gt;七、export和import的复合用法&lt;/h2&gt;
&lt;p&gt;当我们在文件内import一个成员后，同时把它导出时&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;//index.js
import {Button} from './button.js'
export { Button }

可以写成

export {Button} from &quot;./button.js&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;八、import函数&quot;&gt;八、import()函数&lt;/h2&gt;
&lt;p&gt;import关键字导入其他模块成员时，必须写在最顶层作用域，不可嵌套在其他逻辑处理中。如果说我们想在某段逻辑执行完成后去动态加载某些成员，这时候可以使用import()函数加载&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;//module.js
var name = &quot;张三&quot;;

function add(a, b) {
    return a + b;
}

var obj = {
    name: 'jack'
};

export { name, add, obj }
export default function() {
    return '匿名成员'
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;//app.js
//使用setTimeout来模拟一个异步加载的过程
setTimeout(() =&amp;gt; {
    //import返回的是个promise，返回的模块内容都在回调函数的参数中（moduleResult）
    import (&quot;./module.js&quot;).then(moduleResult =&amp;gt; {
        console.log(moduleResult)
        console.log(moduleResult.add)
        console.log(moduleResult.name)
        console.log(moduleResult.default)
        console.log(moduleResult.obj)
    })
    
    //也可以直接把成员结构出来
       import (&quot;./module.js&quot;).then(({add,name,obj,default:defaultData}}) =&amp;gt; {
        console.log(moduleResult.add)
        console.log(moduleResult.name)
        console.log(moduleResult.defaultData)
        console.log(moduleResult.obj)
    })
}, 2000);
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sun, 07 Feb 2021 16:15:00 +0000</pubDate>
<dc:creator>RisingSunBlogs</dc:creator>
<og:description>一、概述 之前提到的几种模块化规范：CommonJS、AMD、CMD都是社区提出的。ES 2015在语言层面上实现了模块功能，且实现简单，可以替代CommonJS和AMD规范，成为在服务器和浏览器通用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhaojian-08/p/14385312.html</dc:identifier>
</item>
<item>
<title>使用开源量子编程框架ProjectQ进行量子计算资源估计与绘制量子线路图 - 陆言君</title>
<link>http://www.cnblogs.com/dechinphy/p/circuit.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dechinphy/p/circuit.html</guid>
<description>&lt;p&gt;通过使用开源量子计算编程框架ProjectQ，我们可以编译和生成量子线路，并将量子线路输出为字符串或者latex代码格式。根据得到的线路输出，我们还可以对相应量子算法的实现进行资源估计，对于量子算法的科学研究有重要的启发作用。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;356.01671753607&quot;&gt;

&lt;p&gt;在量子计算领域，基于量子芯片的算法设计(或简称为量子算法)是基于量子线路来设计的，类似于传统计算中使用的&lt;code&gt;与&lt;/code&gt;门和&lt;code&gt;非&lt;/code&gt;门之类的逻辑门。因此研究一个量子线路输入后的编译(可以简化为数量更少的量子门组合，或者适配硬件上可实现的量子逻辑门操作)，并且输出编译后的量子线路与量子线路图，在各种场景下都会使用到。而且，量子线路编译也能够为量子计算资源估计带来更加准确的结果预测。&lt;/p&gt;

&lt;p&gt;针对于量子计算，这里我们尽量的避免硬件上实现原理的解释，因为那是属于另外一个领域的研究课题。这里我们仅从矩阵力学的角度来理解，读者可以尝试从这篇&lt;a href=&quot;https://www.cnblogs.com/dechinphy/p/magic.html&quot; target=&quot;_blank&quot;&gt;介绍量子系统模拟的博客&lt;/a&gt;中先了解一部分量子门操作的实现。这些量子门的每一种排列组合，我们都可以将其视为一个量子线路，如下图所示是一种量子线路的图示。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2277440/202102/2277440-20210207220111569-1339908113.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;这里的&lt;span class=&quot;math inline&quot;&gt;\(H\)&lt;/span&gt;门和&lt;span class=&quot;math inline&quot;&gt;\(CNOT\)&lt;/span&gt;门作用在不同的量子比特上，相当于执行了一项如下所示的任务：&lt;/p&gt;
&lt;p&gt;\[\left|\psi_t\right&amp;gt;=U\left|\psi_0\right&amp;gt; \]&lt;/p&gt;
&lt;p&gt;这里将&lt;span class=&quot;math inline&quot;&gt;\(U\)&lt;/span&gt;作用在初始的量子态&lt;span class=&quot;math inline&quot;&gt;\(\left|\psi_0\right&amp;gt;\)&lt;/span&gt;之后得到了一个新的量子态&lt;span class=&quot;math inline&quot;&gt;\(\left|\psi_t\right&amp;gt;\)&lt;/span&gt;，当然，此时信息还被存储在量子态中。如果需要将量子态中的信息读取到经典信息，就需要对量子态进行采样，相关过程可以参考这篇&lt;a href=&quot;https://www.cnblogs.com/dechinphy/p/state.html&quot; target=&quot;_blank&quot;&gt;介绍量子态采样的博客&lt;/a&gt;，最终我们得到的信息是一系列二进制比特串的分布。&lt;/p&gt;

&lt;p&gt;我们先用ProjectQ量子编程框架写一个不会被编译优化的量子线路：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from projectq import MainEngine
from projectq.backends import CommandPrinter
from projectq.ops import H, CX, X, Z, Measure, All

circuit_backend = CommandPrinter()
eng=MainEngine(backend=circuit_backend)

qubits = eng.allocate_qureg(3)
All(H) | qubits
CX | (qubits[0], qubits[1])
CX | (qubits[1], qubits[2])
eng.flush()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个程序的基本逻辑是：使用&lt;code&gt;MainEngine&lt;/code&gt;类来执行编译优化等工作;使用&lt;code&gt;CommandPrinter&lt;/code&gt;作为后端，表示只打印量子线路而不进行计算;分配3个量子比特进行计算，最后作用一个线路在该量子系统上。这个程序的执行输出如下，是一个包含有&lt;code&gt;Allocate&lt;/code&gt;的量子线路：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;Allocate | Qureg[0]
H | Qureg[0]
Allocate | Qureg[1]
H | Qureg[1]
CX | ( Qureg[0], Qureg[1] )
Allocate | Qureg[2]
H | Qureg[2]
CX | ( Qureg[1], Qureg[2] )
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里在额外介绍几种优化操作：量子比特回收和量子线路编译。由于该分配的比特已经在内存中注册，需要手动的注销该量子系统所分配的量子比特：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from projectq import MainEngine
from projectq.backends import CommandPrinter
from projectq.ops import H, CX, X, Z, Measure, All

circuit_backend = CommandPrinter()
eng=MainEngine(backend=circuit_backend)
qubits = eng.allocate_qureg(3)

All(H) | qubits
CX | (qubits[0], qubits[1])
CX | (qubits[1], qubits[2])
eng.flush(deallocate_qubits=True)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里python代码中唯一的变化就是增加了&lt;code&gt;deallocate_qubits=True&lt;/code&gt;这个选项，最终输出的量子线路里面也就会包含有&lt;code&gt;Deallocate&lt;/code&gt;的操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;Allocate | Qureg[0]
H | Qureg[0]
Allocate | Qureg[1]
H | Qureg[1]
CX | ( Qureg[0], Qureg[1] )
Deallocate | Qureg[0]
Allocate | Qureg[2]
H | Qureg[2]
CX | ( Qureg[1], Qureg[2] )
Deallocate | Qureg[1]
Deallocate | Qureg[2]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果在线路中遇到一些可以简化的模块，比如连续作用两次&lt;code&gt;H&lt;/code&gt;门之后，相当于没有执行任何的操作，即&lt;span class=&quot;math inline&quot;&gt;\(HH=I\)&lt;/span&gt;。这里的&lt;span class=&quot;math inline&quot;&gt;\(H\)&lt;/span&gt;的矩阵形式如下所示：&lt;/p&gt;
&lt;p&gt;\[H=\left( \begin{array}{l} \frac{\sqrt{2}}{2} &amp;amp; \frac{\sqrt{2}}{2}\\ \frac{\sqrt{2}}{2} &amp;amp; -\frac{\sqrt{2}}{2} \end{array} \right) \]&lt;/p&gt;
&lt;p&gt;如下代码所示我们除了在所有量子比特上作用&lt;span class=&quot;math inline&quot;&gt;\(H\)&lt;/span&gt;门之外，在第二个量子比特上额外作用一个&lt;span class=&quot;math inline&quot;&gt;\(H\)&lt;/span&gt;门，这样理论上说两次连续作用的&lt;span class=&quot;math inline&quot;&gt;\(H\)&lt;/span&gt;门会被抵消：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from projectq import MainEngine
from projectq.backends import CommandPrinter
from projectq.ops import H, CX, X, Z, Measure, All

circuit_backend = CommandPrinter()
eng=MainEngine(backend=circuit_backend)
qubits = eng.allocate_qureg(3)

All(H) | qubits
H | qubits[1]
CX | (qubits[0], qubits[1])
CX | (qubits[1], qubits[2])
eng.flush(deallocate_qubits=True)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到相应的结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;Allocate | Qureg[0]
H | Qureg[0]
Allocate | Qureg[1]
CX | ( Qureg[0], Qureg[1] )
Deallocate | Qureg[0]
Allocate | Qureg[2]
H | Qureg[2]
CX | ( Qureg[1], Qureg[2] )
Deallocate | Qureg[1]
Deallocate | Qureg[2]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;区别于上面的两个例子我们可以发现，这里仅有2个&lt;span class=&quot;math inline&quot;&gt;\(H\)&lt;/span&gt;门而上面的例子中都有3个&lt;span class=&quot;math inline&quot;&gt;\(H\)&lt;/span&gt;门，这就说明在量子编译中两个连续的&lt;span class=&quot;math inline&quot;&gt;\(H\)&lt;/span&gt;门成功的被抵消了。&lt;/p&gt;

&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from projectq import MainEngine
from projectq.backends import CircuitDrawer
from projectq.ops import H, CX, X, Z, Measure, All

circuit_backend = CircuitDrawer()
circuit_backend.set_qubit_locations({0: 2, 1: 1, 2:0})
eng=MainEngine(backend=circuit_backend)
qubits = eng.allocate_qureg(3)

All(H) | qubits
CX | (qubits[0], qubits[1])
CX | (qubits[1], qubits[2])
All(Measure) | qubits
eng.flush()

print (circuit_backend.get_latex())
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行输出的是一串完整的LaTex格式代码，可以存储为&lt;code&gt;file_name.tex&lt;/code&gt;再进行编译。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-latex&quot;&gt;\documentclass{standalone}
\usepackage[margin=1in]{geometry}
\usepackage[hang,small,bf]{caption}
\usepackage{tikz}
\usepackage{braket}
\usetikzlibrary{backgrounds,shadows.blur,fit,decorations.pathreplacing,shapes}

\begin{document}
\begin{tikzpicture}[scale=0.8, transform shape]

\tikzstyle{basicshadow}=[blur shadow={shadow blur steps=8, shadow xshift=0.7pt, shadow yshift=-0.7pt, shadow scale=1.02}]\tikzstyle{basic}=[draw,fill=white,basicshadow]
\tikzstyle{operator}=[basic,minimum size=1.5em]
\tikzstyle{phase}=[fill=black,shape=circle,minimum size=0.1cm,inner sep=0pt,outer sep=0pt,draw=black]
\tikzstyle{none}=[inner sep=0pt,outer sep=-.5pt,minimum height=0.5cm+1pt]
\tikzstyle{measure}=[operator,inner sep=0pt,minimum height=0.5cm, minimum width=0.75cm]
\tikzstyle{xstyle}=[circle,basic,minimum height=0.35cm,minimum width=0.35cm,inner sep=-1pt,very thin]
\tikzset{
shadowed/.style={preaction={transform canvas={shift={(0.5pt,-0.5pt)}}, draw=gray, opacity=0.4}},
}
\tikzstyle{swapstyle}=[inner sep=-1pt, outer sep=-1pt, minimum width=0pt]
\tikzstyle{edgestyle}=[very thin]

\node[none] (line0_gate0) at (0.1,-0) {$\Ket{0}$};
\node[none] (line0_gate1) at (0.5,-0) {};
\node[none,minimum height=0.5cm,outer sep=0] (line0_gate2) at (0.75,-0) {};
\node[none] (line0_gate3) at (1.0,-0) {};
\draw[operator,edgestyle,outer sep=0.5cm] ([yshift=0.25cm]line0_gate1) rectangle ([yshift=-0.25cm]line0_gate3) node[pos=.5] {H};
\draw (line0_gate0) edge[edgestyle] (line0_gate1);
\node[none] (line1_gate0) at (0.1,-1) {$\Ket{0}$};
\node[none] (line1_gate1) at (0.5,-1) {};
\node[none,minimum height=0.5cm,outer sep=0] (line1_gate2) at (0.75,-1) {};
\node[none] (line1_gate3) at (1.0,-1) {};
\draw[operator,edgestyle,outer sep=0.5cm] ([yshift=0.25cm]line1_gate1) rectangle ([yshift=-0.25cm]line1_gate3) node[pos=.5] {H};
\draw (line1_gate0) edge[edgestyle] (line1_gate1);
\node[none] (line2_gate0) at (0.1,-2) {$\Ket{0}$};
\node[none] (line2_gate1) at (0.5,-2) {};
\node[none,minimum height=0.5cm,outer sep=0] (line2_gate2) at (0.75,-2) {};
\node[none] (line2_gate3) at (1.0,-2) {};
\draw[operator,edgestyle,outer sep=0.5cm] ([yshift=0.25cm]line2_gate1) rectangle ([yshift=-0.25cm]line2_gate3) node[pos=.5] {H};
\draw (line2_gate0) edge[edgestyle] (line2_gate1);
\node[xstyle] (line1_gate4) at (1.4000000000000001,-1) {};
\draw[edgestyle] (line1_gate4.north)--(line1_gate4.south);
\draw[edgestyle] (line1_gate4.west)--(line1_gate4.east);
\node[phase] (line2_gate4) at (1.4000000000000001,-2) {};
\draw (line2_gate4) edge[edgestyle] (line1_gate4);
\draw (line1_gate3) edge[edgestyle] (line1_gate4);
\draw (line2_gate3) edge[edgestyle] (line2_gate4);
\node[xstyle] (line0_gate4) at (1.9500000000000002,-0) {};
\draw[edgestyle] (line0_gate4.north)--(line0_gate4.south);
\draw[edgestyle] (line0_gate4.west)--(line0_gate4.east);
\node[phase] (line1_gate5) at (1.9500000000000002,-1) {};
\draw (line1_gate5) edge[edgestyle] (line0_gate4);
\draw (line0_gate3) edge[edgestyle] (line0_gate4);
\draw (line1_gate4) edge[edgestyle] (line1_gate5);
\node[measure,edgestyle] (line0_gate5) at (2.6000000000000005,-0) {};
\draw[edgestyle] ([yshift=-0.18cm,xshift=0.07500000000000001cm]line0_gate5.west) to [out=60,in=180] ([yshift=0.035cm]line0_gate5.center) to [out=0, in=120] ([yshift=-0.18cm,xshift=-0.07500000000000001cm]line0_gate5.east);
\draw[edgestyle] ([yshift=-0.18cm]line0_gate5.center) to ([yshift=-0.07500000000000001cm,xshift=-0.18cm]line0_gate5.north east);
\draw (line0_gate4) edge[edgestyle] (line0_gate5);
\node[measure,edgestyle] (line1_gate6) at (2.6000000000000005,-1) {};
\draw[edgestyle] ([yshift=-0.18cm,xshift=0.07500000000000001cm]line1_gate6.west) to [out=60,in=180] ([yshift=0.035cm]line1_gate6.center) to [out=0, in=120] ([yshift=-0.18cm,xshift=-0.07500000000000001cm]line1_gate6.east);
\draw[edgestyle] ([yshift=-0.18cm]line1_gate6.center) to ([yshift=-0.07500000000000001cm,xshift=-0.18cm]line1_gate6.north east);
\draw (line1_gate5) edge[edgestyle] (line1_gate6);
\node[measure,edgestyle] (line2_gate5) at (2.0500000000000003,-2) {};
\draw[edgestyle] ([yshift=-0.18cm,xshift=0.07500000000000001cm]line2_gate5.west) to [out=60,in=180] ([yshift=0.035cm]line2_gate5.center) to [out=0, in=120] ([yshift=-0.18cm,xshift=-0.07500000000000001cm]line2_gate5.east);
\draw[edgestyle] ([yshift=-0.18cm]line2_gate5.center) to ([yshift=-0.07500000000000001cm,xshift=-0.18cm]line2_gate5.north east);
\draw (line2_gate4) edge[edgestyle] (line2_gate5);

\end{tikzpicture}
\end{document}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不过这里推荐另外一种更加方便的做法，避免自己去安装众多的第三方tex包，可以直接使用&lt;a href=&quot;https://www.overleaf.com&quot; target=&quot;_blank&quot;&gt;Overleaf&lt;/a&gt;平台来执行&lt;code&gt;tex&lt;/code&gt;文件的编译操作，演示效果如下图所示：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2277440/202102/2277440-20210207231005840-2115034579.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;在Overleaf里面会自动的帮我们配置好相关的Latex环境，大大减轻我们自己的工作量。这里的量子线路图绘制时跟比特顺序本身是相关的，比如这里我们尝试切换一种量子比特的映射编号，就会得到不同的线路图(在数学和物理上是等价的)：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from projectq import MainEngine
from projectq.backends import CircuitDrawer
from projectq.ops import H, CX, X, Z, Measure, All

circuit_backend = CircuitDrawer()
circuit_backend.set_qubit_locations({0: 1, 1: 2, 2:0})
eng=MainEngine(backend=circuit_backend)
qubits = eng.allocate_qureg(3)

All(H) | qubits
CX | (qubits[0], qubits[1])
CX | (qubits[1], qubits[2])
All(Measure) | qubits
eng.flush()

print (circuit_backend.get_latex())
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;生成的latex代码这里就不做展示了，我们可以直接看下编译后输出的量子线路图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2277440/202102/2277440-20210207231457111-792105640.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;说到量子计算的资源估计，这里面就需要结合实际场景来分析，这是因为即使我们给出了一个非常精妙的线路，但是这个量子线路最终可能也很难真正在量子计算硬件上实现，这是由于不同的硬件体系本身所具备的局限性。这里我们可以考虑在给定量子门集合的条件下的资源估计，我们先还是用给定的量子门集合来编译上述的示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from projectq import MainEngine
from projectq.backends import CommandPrinter
from projectq.ops import H, CX, X, Z, Rx, Ry, Rz, Measure, All
from projectq.setups import linear

compiler_engines = linear.get_engine_list(num_qubits=16,
                                          one_qubit_gates=(Rx, Ry, Rz),
                                          two_qubit_gates=(CX, ))
circuit_backend = CommandPrinter()
eng=MainEngine(backend=circuit_backend, engine_list=compiler_engines)
qubits = eng.allocate_qureg(3)

All(H) | qubits
CX | (qubits[0], qubits[1])
CX | (qubits[1], qubits[2])
eng.flush(deallocate_qubits=True)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我们使用的是&lt;span class=&quot;math inline&quot;&gt;\(\{R_x,R_y,R_z,CX\}\)&lt;/span&gt;这个组合，而并不包含上述用例中使用到的&lt;span class=&quot;math inline&quot;&gt;\(H\)&lt;/span&gt;门，这里我们可以看下输出结果(其实就是用&lt;span class=&quot;math inline&quot;&gt;\(R_x\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(R_y\)&lt;/span&gt;的组合来构建一个&lt;span class=&quot;math inline&quot;&gt;\(H\)&lt;/span&gt;门)：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;Allocate | Qureg[1]
Ry(1.570796326795) | Qureg[1]
Rx(9.424777960769) | Qureg[1]
Allocate | Qureg[0]
Ry(1.570796326795) | Qureg[0]
Rx(9.424777960769) | Qureg[0]
CX | ( Qureg[0], Qureg[1] )
Allocate | Qureg[2]
Ry(1.570796326795) | Qureg[2]
Rx(9.424777960769) | Qureg[2]
CX | ( Qureg[1], Qureg[2] )
Deallocate | Qureg[1]
Deallocate | Qureg[2]
Deallocate | Qureg[0]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;针对于这种场景，我们切换下后端就可以实现量子计算资源的统计：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from projectq import MainEngine
from projectq.backends import ResourceCounter
from projectq.ops import H, CX, X, Z, Rx, Ry, Rz, Measure, All
from projectq.setups import linear

compiler_engines = linear.get_engine_list(num_qubits=16,
                                          one_qubit_gates=(Rx, Ry, Rz),
                                          two_qubit_gates=(CX, ))
circuit_backend = ResourceCounter()
eng=MainEngine(backend=circuit_backend, engine_list=compiler_engines)
qubits = eng.allocate_qureg(3)

All(H) | qubits
CX | (qubits[0], qubits[1])
CX | (qubits[1], qubits[2])
All(Measure) | qubits
eng.flush(deallocate_qubits=True)

print (circuit_backend)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个程序实际上就是统计上一个示例代码中输出的量子线路的门的数量，对应输出结果为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;Gate class counts:
    AllocateQubitGate : 3
    CXGate : 2
    DeallocateQubitGate : 3
    MeasureGate : 3
    Rx : 3
    Ry : 3

Gate counts:
    Allocate : 3
    CX : 2
    Deallocate : 3
    Measure : 3
    Rx(9.424777960769) : 3
    Ry(1.570796326795) : 3

Max. width (number of qubits) : 3.
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我们可以看到，统计中的&lt;span class=&quot;math inline&quot;&gt;\(R_x,R_y,CX\)&lt;/span&gt;的门的数量与上面输出的结果是保持一致的，那么我们的示例到这里就成功完成演示。&lt;/p&gt;

&lt;p&gt;这篇文章中，我们通过介绍开源量子计算编程框架ProjectQ的一些常规使用方法，来讲解了如何使用程序来编译和生成量子线路，以及将该量子线路作为字符串或者Latex格式代码输出，这同时也使得我们可以通过输出结果来统计量子计算的资源，以用于预测在大规模场景下所需要的大致的量子比特数以及门操作数量(或用量子线路深度来衡量)的量级。这种编译的手段和资源估计的方法，在工程和科学研究上都有较大的意义。&lt;/p&gt;

&lt;p&gt;本文首发链接为：&lt;a href=&quot;https://www.cnblogs.com/dechinphy/p/circuit.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/dechinphy/p/circuit.html&lt;/a&gt;&lt;br/&gt;作者ID：DechinPhy&lt;br/&gt;更多原著文章请参考：&lt;a href=&quot;https://www.cnblogs.com/dechinphy/&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/dechinphy/&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/ProjectQ-Framework/ProjectQ&quot; target=&quot;_blank&quot;&gt;https://github.com/ProjectQ-Framework/ProjectQ&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;</description>
<pubDate>Sun, 07 Feb 2021 15:21:00 +0000</pubDate>
<dc:creator>陆言君</dc:creator>
<og:description>通过使用开源量子计算编程框架ProjectQ，我们可以编译和生成量子线路，并将量子线路输出为字符串或者latex代码格式。根据得到的线路输出，我们还可以对相应量子算法的实现进行资源估计，对于量子算法的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/dechinphy/p/circuit.html</dc:identifier>
</item>
<item>
<title>QT串口助手（五）：文件操作 - zzssdd2</title>
<link>http://www.cnblogs.com/zzssdd2/p/14387107.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zzssdd2/p/14387107.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;作者：&lt;/strong&gt;zzssdd2&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;E-mail：&lt;/strong&gt;zzssdd2@foxmail.com&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;开发环境：&lt;strong&gt;Qt5.12.10 + MinGW&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;功能&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;文件的发送&lt;/li&gt;
&lt;li&gt;数据的保存&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;p&gt;知识点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;QFile&lt;/code&gt;类的使用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;QTimer&lt;/code&gt;类的使用&lt;/li&gt;
&lt;li&gt;文本的转码与编码识别&lt;/li&gt;
&lt;li&gt;&lt;code&gt;QPushButton&lt;/code&gt;、&lt;code&gt;QProgressBar&lt;/code&gt;控件的使用&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2193174/202102/2193174-20210207230758495-4911234.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;本章功能主要包含两个方面，一是通过串口发送选定的文本文件，二是将接收的数据保存为本地文本文件。最后还有对&lt;a href=&quot;https://www.cnblogs.com/zzssdd2/p/14319615.html&quot; target=&quot;_blank&quot;&gt;《QT串口助手（三）：数据接收》&lt;/a&gt;章节内容进行一个补充扩展。&lt;/p&gt;
&lt;h2 id=&quot;21、文件打开&quot;&gt;2.1、文件打开&lt;/h2&gt;
&lt;p&gt;当&lt;code&gt;选择文件&lt;/code&gt;按钮点击后，触发点击信号对应的槽函数，在槽函数中进行文件的打开与读取：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;/*选择并打开文件*/
QString curPath = QDir::currentPath();  //系统当前目录
QString dlgTitle = &quot;打开文件&quot;;  //对话框标题
QString filter = &quot;文本文件(*.txt);;二进制文件(*.bin *.dat);;所有文件(*.*)&quot;; //文件过滤器
QString filepath = QFileDialog::getOpenFileName(this,dlgTitle,curPath,filter);
QFileInfo fileinfo(filepath);

if (filepath.isEmpty())
{
    QMessageBox::warning(this,&quot;警告&quot;,&quot;文件为空&quot;);
    return;
}
//文件路径显示到发送框
ui-&amp;gt;Send_TextEdit-&amp;gt;clear();
ui-&amp;gt;Send_TextEdit-&amp;gt;appendPlainText(filepath);

QFile file(filepath);
if (!file.exists())
{
    QMessageBox::warning(this,&quot;警告&quot;,&quot;文件不存在&quot;);
    return;
}
if (!file.open(QIODevice::ReadOnly))
{
    QMessageBox::warning(this,&quot;警告&quot;,&quot;文件打开失败&quot;);
    return;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;22、编码判断&quot;&gt;2.2、编码判断&lt;/h2&gt;
&lt;p&gt;因为应用程序默认使用的编码为&lt;em&gt;UTF-8&lt;/em&gt;，如果打开&lt;em&gt;GBK&lt;/em&gt;格式编码的文件就会乱码，所以需要判断文件的编码，如果不是UTF-8则需要对文件进行编码转换。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;/* 设置应用程序的编码解码器 */
QTextCodec *codec = QTextCodec::codecForName(&quot;UTF-8&quot;);
QTextCodec::setCodecForLocale(codec);
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;ul readability=&quot;5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;[static] QTextCodec *QTextCodec::codecForName(const char *name)&lt;/p&gt;
&lt;p&gt;Searches all installed QTextCodec objects and returns the one which best matches &lt;em&gt;name&lt;/em&gt;; the match is case-insensitive. Returns 0 if no codec matching the name &lt;em&gt;name&lt;/em&gt; could be found.&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;[static] void QTextCodec::setCodecForLocale(QTextCodec **c*)&lt;/p&gt;
&lt;p&gt;Set the codec to &lt;em&gt;c&lt;/em&gt;; this will be returned by codecForLocale(). If &lt;em&gt;c&lt;/em&gt; is a null pointer, the codec is reset to the default.&lt;/p&gt;
&lt;p&gt;This might be needed for some applications that want to use their own mechanism for setting the locale.&lt;/p&gt;
&lt;p&gt;Warning: This function is not reentrant.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;/* 判断编码 */
QTextCodec::ConverterState state;
QTextCodec *codec = QTextCodec::codecForName(&quot;UTF-8&quot;);
FileText = codec-&amp;gt;toUnicode(data.constData(),data.size(),&amp;amp;state);
//若有无效字符则是GBK编码
if (state.invalidChars &amp;gt; 0) 
{
    //转码后返回
    FileText = QTextCodec::codecForName(&quot;GBK&quot;)-&amp;gt;toUnicode(data);
}
else
{
    FileText =  data;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对文件进行上述的处理后，如果是GBK编码则也能够正确的读取了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul readability=&quot;5&quot;&gt;&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;QString QTextCodec::toUnicode(const char *&lt;em&gt;input&lt;/em&gt;, int &lt;em&gt;size&lt;/em&gt;, QTextCodec::ConverterState *&lt;em&gt;state&lt;/em&gt; = nullptr) const&lt;/p&gt;
&lt;p&gt;Converts the first &lt;em&gt;size&lt;/em&gt; characters from the &lt;em&gt;input&lt;/em&gt; from the encoding of this codec to Unicode, and returns the result in a QString.&lt;/p&gt;
&lt;p&gt;The &lt;em&gt;state&lt;/em&gt; of the convertor used is updated.&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;QString QTextCodec::toUnicode(const QByteArray &amp;amp;&lt;em&gt;a&lt;/em&gt;) const&lt;/p&gt;
&lt;p&gt;Converts &lt;em&gt;a&lt;/em&gt; from the encoding of this codec to Unicode, and returns the result in a QString.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2193174/202102/2193174-20210207230717670-1399417024.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;23、文件读取&quot;&gt;2.3、文件读取&lt;/h2&gt;
&lt;p&gt;文件打开后，需要对文件类型进行判断，然后进行文件数据的读取：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;/*判断文件类型*/
int type = 0;
QMimeDatabase db;
QMimeType mime = db.mimeTypeForFile(filepath);
if (mime.name().startsWith(&quot;text/&quot;)) 
{
    type = 1;   //文本文件
} 
else if (mime.name().startsWith(&quot;application/&quot;)) 
{
    type = 2;   //二进制文件
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;14&quot;&gt;
&lt;p&gt;QMimeType QMimeDatabase::mimeTypeForFile(const QString&amp;amp;&lt;em&gt;fileName&lt;/em&gt;, QMimeDatabase::MatchMode &lt;em&gt;mode&lt;/em&gt; = MatchDefault) const&lt;/p&gt;
&lt;p&gt;Returns a MIME type for the file named &lt;em&gt;fileName&lt;/em&gt; using &lt;em&gt;mode&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;This is an overloaded function.&lt;/p&gt;
&lt;p&gt;QMimeType 类描述文件或数据的类型，由 MIME 类型字符串表示，获取到文件类型后接下来就知道应该使用什么方法读取文件内容了。常见文件类型如下：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;描述(startsWith)&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;示例&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;13.5&quot;&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;text&lt;/td&gt;
&lt;td&gt;普通文本&lt;/td&gt;
&lt;td&gt;text/plain, text/html, text/css, text/javascript&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8&quot;&gt;&lt;td&gt;image&lt;/td&gt;
&lt;td&gt;图像文件(包含动态gif)&lt;/td&gt;
&lt;td&gt;image/gif, image/png, image/jpeg, image/bmp, image/webp&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;audio&lt;/td&gt;
&lt;td&gt;音频文件&lt;/td&gt;
&lt;td&gt;audio/wav, audio/mpeg, audio/midi, audio/webm, audio/ogg&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;video&lt;/td&gt;
&lt;td&gt;视频文件&lt;/td&gt;
&lt;td&gt;video/mp4, video/x-flv, video/webm, video/ogg&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;application&lt;/td&gt;
&lt;td&gt;二进制数据&lt;/td&gt;
&lt;td&gt;application/xml, application/pdf&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;/*读取文件*/
switch(type)
{
    case 1:
    {
        //QIODevice读取普通文本
        QByteArray data = file.readAll();
        file.close();
        if (data.isEmpty())
        {
            QMessageBox::information(this, &quot;提示&quot;, &quot;文件内容空&quot;);
            return;
        }
        /* 判断编码 */
    }
    break;
    case 2:
    {
        int filelen = fileinfo.size();
        QVector&amp;lt;char&amp;gt; cBuf(filelen);//储存读出数据
        //使用QDataStream读取二进制文件
        QDataStream datain(&amp;amp;file);
        datain.readRawData(&amp;amp;cBuf[0],filelen);
        file.close();
        //char数组转QString
        FileText = QString::fromLocal8Bit(&amp;amp;cBuf[0],filelen);
    }
    break;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;ul readability=&quot;10&quot;&gt;&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;QByteArray QIODevice::readAll()&lt;/p&gt;
&lt;p&gt;Reads all remaining data from the device, and returns it as a byte array.&lt;/p&gt;
&lt;p&gt;This function has no way of reporting errors; returning an empty QByteArray can mean either that no data was currently available for reading, or that an error occurred.&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;int QDataStream::readRawData(char **s*, int &lt;em&gt;len&lt;/em&gt;)&lt;/p&gt;
&lt;p&gt;Reads at most &lt;em&gt;len&lt;/em&gt; bytes from the stream into &lt;em&gt;s&lt;/em&gt; and returns the number of bytes read. If an error occurs, this function returns -1.&lt;/p&gt;
&lt;p&gt;The buffer &lt;em&gt;s&lt;/em&gt; must be preallocated. The data is &lt;em&gt;not&lt;/em&gt; decoded.&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;关于QVector：QVector类是一个提供动态数组的模板类。QVector是Qt的通用容器类之一，它将其项存储在相邻的内存位置并提供基于索引的快速访问。例如上面代码定义了一个大小为filelen的char类型的数组用来储存读取的二进制数据（相对与普通数组而言，QVector数组项可以动态增加，能够避免访问越界等问题）。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;QT中使用QTextStream或QIODevice类读写普通文本文件，使用QDataStream类读写二进制文本文件&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;最后将读取到的文件大小信息和内容显示到接收框并标记有待发送文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;//显示文件大小信息
QString info = QString(&quot;%1%2&quot;).arg(&quot;文件大小为：&quot;).arg(FileText.length());
ui-&amp;gt;Receive_TextEdit-&amp;gt;clear();
ui-&amp;gt;Receive_TextEdit-&amp;gt;append(info);
//显示文件内容
if (ui-&amp;gt;HexDisp_checkBox-&amp;gt;isChecked()) 
{
    ui-&amp;gt;Receive_TextEdit-&amp;gt;setPlainText(FileText.toUtf8().toHex(' ').toUpper());
} 
else 
{
    ui-&amp;gt;Receive_TextEdit-&amp;gt;setPlainText(FileText);
}
//设置显示焦点在最顶部
ui-&amp;gt;Receive_TextEdit-&amp;gt;moveCursor(QTextCursor::Start,QTextCursor::MoveAnchor);

/*标记有文件发送*/
isSendFile = true;
FrameCount = 0;
ProgressBarValue = 0;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;24、文件发送&quot;&gt;2.4、文件发送&lt;/h2&gt;
&lt;p&gt;此时在标记了有文件发送的情况下，点击发送按钮则是发送文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;/*
    函   数：on_Send_Bt_clicked
    描   述：发送按键点击信号槽
    输   入：无
    输   出：无
*/
void Widget::on_Send_Bt_clicked()
{
    if (isSerialOpen != false)
    {
        if (isSendFile) //发送文件数据
        {
            if (ui-&amp;gt;Send_Bt-&amp;gt;text() == &quot;发送&quot;) 
            {
                ui-&amp;gt;Send_Bt-&amp;gt;setText(&quot;停止&quot;);
                SendFile();
            } 
            else 
            {
                ui-&amp;gt;Send_Bt-&amp;gt;setText(&quot;发送&quot;);
                FileSendTimer-&amp;gt;stop();
            }
        }
        else    //发送发送框数据
        {
            SerialSendData(SendTextEditBa);
        }
    }
    else
    {
        QMessageBox::information(this, &quot;提示&quot;, &quot;串口未打开&quot;);
    }
}

/*
    函   数：SendData
    描   述：定时器发送文件
    输   入：无
    输   出：无
*/
void Widget::SendFile(void)
{
    /*按设置参数发送*/
    FrameLen = ui-&amp;gt;PackLen_lineEdit-&amp;gt;text().toInt(); // 帧大小
    FrameGap = ui-&amp;gt;GapTim_lineEdit-&amp;gt;text().toInt();  // 帧间隔
    int textlen = Widget::FileText.size();           // 文件大小
    if (FrameGap &amp;lt;= 0 || textlen &amp;lt;= FrameLen)
    {
        //时间间隔为0 或 帧大小≥文件大小 则直接一次发送
        serial-&amp;gt;write(FileText.toUtf8());
        ui-&amp;gt;Send_Bt-&amp;gt;setText(&quot;发送&quot;);
    }
    else
    {
        //按设定时间和长度发送
        FrameNumber = textlen / FrameLen; // 包数量
        LastFrameLen = textlen % FrameLen; // 最后一包数据长度
        //进度条步进值
        if (FrameNumber &amp;gt;= 100) 
        { 
            ProgressBarStep = FrameNumber / 100;
        } 
        else 
        {
            ProgressBarStep = 100 / FrameNumber;
        }
        //设置定时器
        FileSendTimer-&amp;gt;start(FrameGap);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;设置一个定时器，将文件按照设定的&lt;code&gt;帧大小&lt;/code&gt;和&lt;code&gt;帧间隔&lt;/code&gt;来发送：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;/*文件帧发送定时器信号槽*/
FileSendTimer = new QTimer(this);
connect(FileSendTimer,SIGNAL(timeout()),this,SLOT(File_TimerSend()));

/*
    函   数：File_TimerSend
    描   述：发送文件定时器槽函数
    输   入：无
    输   出：无
*/
void Widget::File_TimerSend(void)
{
    if (FrameCount &amp;lt; FrameNumber)
    {
        serial-&amp;gt;write(FileText.mid(FrameCount * FrameLen, FrameLen).toUtf8());
        FrameCount++;
        //更新进度条
        ui-&amp;gt;progressBar-&amp;gt;setValue(ProgressBarValue += ProgressBarStep);
    }
    else
    {
        if (LastFrameLen &amp;gt; 0)
        {
            serial-&amp;gt;write(FileText.mid(FrameCount * FrameLen, LastFrameLen).toUtf8());
            ui-&amp;gt;progressBar-&amp;gt;setValue(100);
        }
        /*发送完毕*/
        FileSendTimer-&amp;gt;stop();
        FrameCount = 0;
        ProgressBarValue = 0;
        FrameNumber = 0;
        LastFrameLen = 0;
        QMessageBox::information(this, &quot;提示&quot;, &quot;发送完成&quot;);
        ui-&amp;gt;progressBar-&amp;gt;setValue(0);
        ui-&amp;gt;Send_Bt-&amp;gt;setText(&quot;发送&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;20&quot;&gt;
&lt;p&gt;QString QString::mid(int &lt;em&gt;position&lt;/em&gt;, int &lt;em&gt;n&lt;/em&gt; = -1) const&lt;/p&gt;
&lt;p&gt;Returns a string that contains &lt;em&gt;n&lt;/em&gt; characters of this string, starting at the specified &lt;em&gt;position&lt;/em&gt; index.&lt;/p&gt;
&lt;p&gt;Returns a null string if the &lt;em&gt;position&lt;/em&gt; index exceeds the length of the string. If there are less than &lt;em&gt;n&lt;/em&gt; characters available in the string starting at the given &lt;em&gt;position&lt;/em&gt;, or if &lt;em&gt;n&lt;/em&gt; is -1 (default), the function returns all characters that are available from the specified &lt;em&gt;position&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; QString x = &quot;Nine pineapples&quot;;
 QString y = x.mid(5, 4);            // y == &quot;pine&quot;
 QString z = x.mid(5);               // z == &quot;pineapples&quot;
&lt;/code&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;h2 id=&quot;25、数据保存&quot;&gt;2.5、数据保存&lt;/h2&gt;
&lt;p&gt;当&lt;code&gt;保存数据&lt;/code&gt;按钮按下时，将接收框数据按文本方式进行保存：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;/*
    函   数：on_SaveData_Button_clicked
    描   述：保存数据按钮点击槽函数
    输   入：无
    输   出：无
*/
void Widget::on_SaveData_Button_clicked()
{
    QString data = ui-&amp;gt;Receive_TextEdit-&amp;gt;toPlainText();

    if (data.isEmpty())
    {
        QMessageBox::information(this, &quot;提示&quot;, &quot;数据内容空&quot;);
        return;
    }

    QString curPath = QDir::currentPath();            //获取系统当前目录
    QString dlgTitle = &quot;保存文件&quot;;                     //对话框标题
    QString filter = &quot;文本文件(*.txt);;所有文件(*.*)&quot;;  //文件过滤器
    QString filename = QFileDialog::getSaveFileName(this,dlgTitle,curPath,filter);
    if (filename.isEmpty())
    {
        return;
    }
    QFile file(filename);
    if (!file.open(QIODevice::WriteOnly))
    {
        return;
    }

    /*保存文件*/
    QTextStream stream(&amp;amp;file);
    stream &amp;lt;&amp;lt; data;
    file.close();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;17&quot;&gt;
&lt;p&gt;QTextStream::QTextStream(FILE **fileHandle&lt;em&gt;, QIODevice::OpenMode&lt;/em&gt;openMode* = QIODevice::ReadWrite)&lt;/p&gt;
&lt;p&gt;Constructs a QTextStream that operates on &lt;em&gt;fileHandle&lt;/em&gt;, using &lt;em&gt;openMode&lt;/em&gt; to define the open mode. Internally, a QFile is created to handle the FILE pointer.&lt;/p&gt;
&lt;p&gt;This constructor is useful for working directly with the common FILE based input and output streams: stdin, stdout and stderr. Example:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; QString str;
 QTextStream in(stdin);
 in &amp;gt;&amp;gt; str;
&lt;/code&gt;
&lt;/pre&gt;&lt;/blockquote&gt;

&lt;p&gt;这里对接收模块的功能进行一个补充。上面说了应用程序默认编码是&lt;code&gt;UTF-8&lt;/code&gt;,那么如果在ascii显示模式下收到的数据是&lt;code&gt;GBK&lt;/code&gt;格式的编码就会造成显示乱码，所以需要对接收数据进行编码判断，如果是GBK编码则进行转换显示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;/*
    函   数：SerialPortReadyRead_slot
    描   述：readyRead()信号对应的数据接收槽函数
    输   入：无
    输   出：无
*/
void Widget::SerialPortReadyRead_slot()
{
    /*读取串口收到的数据*/
    QByteArray bytedata = serial-&amp;gt;readAll();
    
    //......省略
    
    if(ui-&amp;gt;HexDisp_checkBox-&amp;gt;isChecked() == false)  //ascii显示
    {
        /* 判断编码 */
        QTextCodec::ConverterState state;
        //调用utf8转unicode的方式转码，获取转换结果
        QString asciidata = QTextCodec::codecForName(&quot;UTF-8&quot;)-&amp;gt;toUnicode(bytedata.constData(),bytedata.size(),&amp;amp;state);
        //存在无效字符则是GBK，转码后返回
        if (state.invalidChars &amp;gt; 0) 
        {
            asciidata = QTextCodec::codecForName(&quot;GBK&quot;)-&amp;gt;toUnicode(bytedata);
        } 
        else 
        {
            asciidata = QString(bytedata);
        }
        
        //......省略
    }
    
    //......省略
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2193174/202102/2193174-20210207230652512-1992575581.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;本章主要讲解对文件的操作。除了需要了解在QT中对文件类的常用操作之外，个人认为还有比较重要的两个知识点：1是文本编码的判断和转码处理，2是对于二进制文本的读取。&lt;/p&gt;
</description>
<pubDate>Sun, 07 Feb 2021 15:10:00 +0000</pubDate>
<dc:creator>zzssdd2</dc:creator>
<og:description>作者：zzssdd2 E-mail：zzssdd2@foxmail.com 一、前言 开发环境：Qt5.12.10 + MinGW 功能 文件的发送 数据的保存 知识点 QFile类的使用 QTime</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zzssdd2/p/14387107.html</dc:identifier>
</item>
<item>
<title>复制表的方法 - 萌新J</title>
<link>http://www.cnblogs.com/mengxinJ/p/14387096.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mengxinJ/p/14387096.html</guid>
<description>&lt;h2&gt;1、mysqldump&lt;/h2&gt;
&lt;h3&gt;执行过程：&lt;/h3&gt;
&lt;h4&gt;&lt;span&gt;一、将数据导出为 sql 文件。&lt;/span&gt;&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
mysqldump &lt;span&gt;-&lt;/span&gt;h$host &lt;span&gt;-&lt;/span&gt;P$port &lt;span&gt;-&lt;/span&gt;u$&lt;span&gt;user&lt;/span&gt; &lt;span&gt;--&lt;/span&gt;&lt;span&gt;add-locks=0 --no-create-info --single-transaction  --set-gtid-purged=OFF db1 t --where=&quot;a&amp;gt;900&quot; --result-file=/client_tmp/t.sql&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;将数据导出为 sql 文件保存。上面几个参数的含义分别是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、–single-transaction 的作用是，在导出数据的时候不需要对表 db1.t 加表锁，而是使用 START TRANSACTION WITH CONSISTENT SNAPSHOT 的方法；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、–add-locks 设置为 0，表示在输出的文件结果里，不增加&quot; LOCK TABLES t WRITE;&quot; ；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、–no-create-info 的意思是，不需要导出表结构；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、–set-gtid-purged=off 表示的是，不输出跟 GTID 相关的信息；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5、–result-file 指定了输出文件的路径，其中 client 表示生成的文件是在客户端机器上的。&lt;/span&gt;&lt;/p&gt;

&lt;h4&gt;&lt;span&gt;二、执行文件，添加到表中&lt;/span&gt;&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
mysql &lt;span&gt;-&lt;/span&gt;h127.&lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;P13000  &lt;span&gt;-&lt;/span&gt;uroot db2 &lt;span&gt;-&lt;/span&gt;e &quot;source &lt;span&gt;/&lt;/span&gt;client_tmp&lt;span&gt;/&lt;/span&gt;t.sql&quot;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;source 并不是一条 SQL 语句，而是一个客户端命令。也就是服务器端具体执行的是文件中的一条条 sql 语句，所以 &lt;strong&gt;&lt;span&gt;binlog 记录的都是具体的 sql。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;特点&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1、生成的 sql 文件保存在客户端&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、默认保存数据方式是多个记录对，如下面格式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2012006/202102/2012006-20210207211506930-1042161540.png&quot; alt=&quot;&quot; width=&quot;822&quot; height=&quot;52&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果想要保存为一条语句只保存一条记录，那么可以加上参数–skip-extended-insert。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;2、导出 CSV 文件（最灵活）&lt;/h2&gt;
&lt;h3&gt;执行过程&lt;/h3&gt;
&lt;h4&gt;&lt;span&gt;&lt;span&gt;一、导出为 CSV 文件&lt;/span&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; db1.t &lt;span&gt;where&lt;/span&gt; a&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;900&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; outfile &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/server_tmp/t.csv&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;注意：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、into outfile 指定了文件的生成位置（/server_tmp/），这个位置必须受参数 secure_file_priv 的限制。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参数 secure_file_priv 的可选值和作用分别是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1）如果设置为 empty，表示不限制文件生成的位置，这是不安全的设置；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2）如果设置为一个表示路径的字符串，就要求生成的文件只能放在这个指定的目录，或者它的子目录；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3）如果设置为 NULL，就表示禁止在这个 MySQL 实例上执行 select … into outfile 操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、如果同一个目录下存在同名文件，就会报错&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、一般情况下一条记录就对应 CSV 文件中的一行，但是如果某个字段值中有 &quot;换行、制表符&quot; 那么文件中也会包含，并且使用 &quot;\&quot; 来转义。&lt;/span&gt;&lt;/p&gt;

&lt;h4&gt;&lt;span&gt;二、导入数据&lt;/span&gt;&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;load&lt;/span&gt; data infile &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/server_tmp/t.csv&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; db2.t;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;过程：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、打开文件 /server_tmp/t.csv，以制表符 (\t) 作为字段间的分隔符，以换行符（\n）作为记录之间的分隔符，进行数据读取；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、启动事务。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、判断每一行的字段数与表 db2.t 是否相同：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1）若不相同，则直接报错，事务回滚；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2）若相同，则构造成一行，调用 InnoDB 引擎接口，写入到表中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、重复步骤 3，直到 /server_tmp/t.csv 整个文件读入完成，提交事务。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;特点&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1、文件保存在服务器端&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;2、关于 binlog 的记录，过程如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　1）主库执行完成后，将 /server_tmp/t.csv 文件的内容直接写到 binlog 文件中。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　2）往&lt;/span&gt; &lt;span&gt;binlog&lt;/span&gt; &lt;span&gt;文件中写入语句 &lt;strong&gt;&lt;span&gt;load data local infile ‘/tmp/SQL_LOAD_MB-1-0’ INTO TABLE `db2`.`t`。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　3）把这个 binlog 日志传到备库。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　4）备库的 apply 线程在执行这个事务日志时：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　a. 先将 binlog 中 t.csv 文件的内容读出来，写入到本地临时目录 /tmp/SQL_LOAD_MB-1-0 中；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　b. 再执行 load data 语句，往备库的 db2.t 表中插入跟主库相同的数据。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2012006/202102/2012006-20210207215102645-737686823.png&quot; alt=&quot;&quot; width=&quot;376&quot; height=&quot;165&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　关于 &quot;local&quot;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　1）不加“local”，是读取服务端的文件，这个文件必须在 secure_file_priv 指定的目录或子目录下；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　2）加上“local”，读取的是客户端的文件，只要 mysql 客户端有访问这个文件的权限即可。这时候，MySQL 客户端会先把本地文件传给服务端（其他会话涉及的操作），然后执行上述的 load data 流程。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3、上面的导出操作并不会导出表结构，所以，如果向导出表结构，可以使用 mysqldump 来同时导出 CSV 和表结构&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
mysqldump &lt;span&gt;-&lt;/span&gt;h$host &lt;span&gt;-&lt;/span&gt;P$port &lt;span&gt;-&lt;/span&gt;u$&lt;span&gt;user&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;-single-transaction  --set-gtid-purged=OFF db1 t --where=&quot;a&amp;gt;900&quot; --tab=$secure_file_priv&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;会在$secure_file_priv 定义的目录下，创建一个 t.sql 文件保存建表语句，同时创建一个 t.txt 文件保存 CSV 数据。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;3、物理拷贝（最快）&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;在5.6之前，想要直接把.frm和.ibd文件拷贝到要拷贝的目录下是不行的，因为一个Innodb表除了需要这两个文件还需要在数据字典中注册。但是从 5.6 开始可以解决这一问题，在 5.6 引入了可传输空间，可以通过导出 + 导入表空间来实现拷贝&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;过程&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;假设我们现在的目标是在 db1 库下，复制一个跟表 t 相同的表 r，具体的执行步骤如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、执行 create table r like t，创建一个相同表结构的空表；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、执行 alter table r discard tablespace，这时候 r.ibd 文件会被删除；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、执行 flush table t for export，这时候 db1 目录下会生成一个 t.cfg 文件；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、在 db1 目录下执行 cp t.cfg r.cfg; cp t.ibd r.ibd；这两个命令（这里需要注意的是，拷贝得到的两个文件，MySQL 进程要有读写权限）；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5、执行 unlock tables，这时候 t.cfg 文件会被删除；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6、执行 alter table r import tablespace，将这个 r.ibd 文件作为表 r 的新的表空间，由于这个文件的数据内容和 t.ibd 是相同的，所以表 r 中就有了和表 t 相同的数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2012006/202102/2012006-20210207225625723-1059167235.png&quot; alt=&quot;&quot; width=&quot;408&quot; height=&quot;314&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;注意：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、在第 3 步执行完 flsuh table 命令之后，db1.t 整个表处于只读状态，直到执行 unlock tables 命令后才释放读锁；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、在执行 import tablespace 的时候，为了让文件里的表空间 id 和数据字典中的一致，会修改 r.ibd 的表空间 id。而这个表空间 id 存在于每一个数据页中。因此，如果是一个很大的文件（比如 TB 级别），每个数据页都需要修改，所以你会看到这个 import 语句的执行是需要一些时间的。当然，如果是相比于逻辑导入的方法，import 语句的耗时是非常短的。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;局限&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;1、必须是全表拷贝，不能条件拷贝&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、需要到服务器上拷贝数据，在用户无法登录数据库主机的场景下无法使用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、由于是通过拷贝物理文件实现的，源表和目标表都是使用 InnoDB 引擎时才能使用&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;1、前两个都是逻辑备份，也就是可以跨引擎使用，最后一个不行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、前两个可以条件拷贝，最后一个不行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、第二个功能是最灵活的，但是在集群从库接收时会比较耗时（需要先拷贝 CSV 文件数据到本地临时文件），最后一个执行效率是最高的，但是不能跨引擎，且只能进行全量拷贝。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 07 Feb 2021 15:07:00 +0000</pubDate>
<dc:creator>萌新J</dc:creator>
<og:description>1、mysqldump 执行过程： 一、将数据导出为 sql&amp;#160;文件。 mysqldump -h$host -P$port -u$user --add-locks=0 --no-create-</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mengxinJ/p/14387096.html</dc:identifier>
</item>
<item>
<title>向 3D 世界迈出一小步 - 京山游侠</title>
<link>http://www.cnblogs.com/youxia/p/cg003.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/youxia/p/cg003.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;OpenGL 的学习资料很多，一个是比较著名的 OpenGL 红宝书《OpenGL 编程指南》，可以在这里 &lt;a href=&quot;http://opengl-redbook.com/&quot; target=&quot;_blank&quot;&gt;http://opengl-redbook.com/&lt;/a&gt; 下载该书配套的源代码；另一个是网络上的在线教程&lt;a href=&quot;https://learnopengl-cn.github.io/&quot; target=&quot;_blank&quot;&gt;LearnOpenGL&lt;/a&gt;。所以，我这里就不再啰啰嗦嗦地介绍 OpenGL 的基础知识和计算机图形学的基础知识了，主要是简单阐述一些我自己的理解，以及写一些能跑起来、能看到效果的体验性的小程序。&lt;/p&gt;
&lt;p&gt;通过前一篇阐述，可以看到在 Linux 系统中学习 OpenGL 是多么的方便。使用 GLEW 和 GLFW 库，使用一行简单的 g++ 编译命令，第一个简单的 OpenGL 程序就跑起来了。而上面提到的参考资料，都有让初学者头痛的地方，比如红宝书，它用到了比较少见的 gl3w 库，还用到了 cmake 系统，即使下载了它的源代码，程序也跑不起来。网络教程&lt;a href=&quot;https://learnopengl-cn.github.io/&quot; target=&quot;_blank&quot;&gt;LearnOpenGL&lt;/a&gt;使用的是 GLAD，反正我没有使用成功过。最终，还是 GLEW 和 GLFW 搭配是最顺手的。&lt;/p&gt;
&lt;p&gt;前一篇的最后，我们跑起来了一个空的 OpenGL 程序，里面没有渲染任何内容。在这一篇中，我们将向 3D 世界迈出一小步，了解 OpenGL 渲染管线的基本知识，并绘制一些简单的 3D 内容。&lt;/p&gt;
&lt;h2 id=&quot;我所理解的简单的-3d-图形学知识&quot;&gt;我所理解的简单的 3D 图形学知识&lt;/h2&gt;
&lt;p&gt;要想描述一个 3D 世界，最简单的办法就是描述一些顶点的坐标，（当然还有其它的办法，比如通过数学公式描述的曲线曲面之类的，所以我说描述顶点坐标是最简单的办法。），然后由顶点连接成三角形，再由三角形连接成面，最后，计算机再把这些数据处理成屏幕上像素的颜色，显示成我们看到的图像。&lt;/p&gt;
&lt;p&gt;而 OpenGL 通过渲染管线完成这个操作，渲染管线由许多个阶段组成，首先，OpenGL 把我们传递给它的顶点进行坐标变换，把 3D 的坐标对应成屏幕上的点，然后，把这些顶点组装成三角形，然后，对这些三角形内部的像素进行插值，生成片元，最后，对这些片元进行计算，以生成在屏幕上显示的图像。很显然，渲染管线需要使用 GPU 进行加速。&lt;/p&gt;
&lt;p&gt;GPU 是典型的众人拾柴火焰高的并行计算架构，它可以同时对成千上万的顶点进行计算，也可以同时对成千上万的片元进行计算。我的这台 XPS 9570，使用的显卡是 GTX 1050Ti，它有 768 个 CUDA 核心，我准备等有钱了再上一个 RTX 3060 显卡的笔记本，据说有 3840 个 CUDA 核心，性能可以一下子提升 5 倍， &lt;sup&gt;_&lt;/sup&gt;。让这些核心运行什么样的任务，是由我们指定的，也就是说，我们要写一些小程序，然后把这些小程序传递给 GPU 核心执行，这些小程序就叫做 Shader。在 OpenGL 的渲染管线中，每一个阶段都对应一个 Shader。&lt;/p&gt;
&lt;p&gt;通过上面的描述，我们的工作流程呼之欲出。要想使用 OpenGL 渲染一点有用的东西，我们需要做下面这些工作：1.准备一些顶点数据；2.写一些 Shader 程序，并组装成渲染管线；3.把顶点数据传递给 Shader，让 Shader 处理。&lt;/p&gt;
&lt;p&gt;特别需要注意的还有两点：1. 顶点数据可以不仅仅只是坐标，还可以包含法线呀、颜色值呀、纹理坐标呀等数据，还可以包含其它任何我们自定义的数据；2. Shader 是并行执行的，每个 Shader 处理一个顶点的数据，不同的顶点其传入的数据是不同的，可以认为这些数据是逐顶点变量，但是，也可以给所有的 Shader 传递一些统一的值，这些值在所有的 Shader 中是相同的，称之为 Uniform 变量。&lt;/p&gt;
&lt;p&gt;这些数据，通过一系列不同的 OpenGL 函数传递给 Shader。&lt;/p&gt;
&lt;p&gt;下面开始实战。&lt;/p&gt;
&lt;h2 id=&quot;准备顶点数据&quot;&gt;准备顶点数据&lt;/h2&gt;
&lt;p&gt;顶点数据怎么来，这是一个问题。我们可以直接手写三个顶点坐标，在屏幕上渲染一个三角形，同样的方法，也可以手写八个顶点坐标及其颜色值渲染一个颜色立方体。对于一些更复杂的几何图形，比如球体、甜甜圈这样的几何体，只要会一点简单的三角函数，我们自己也可以生成出来。另外，对于一些复杂的、经典的模型，也可以找到它们的出处。比如红宝书中就有一个 armadillo 神兽的 3D 模型，可以在&lt;a href=&quot;https://github.com/openglredbook/examples&quot; target=&quot;_blank&quot;&gt;红宝书源代码的github仓库&lt;/a&gt;中找到，只不过是作者自创的 vbm 格式，需要自己动手扒一下。再比如 freeglut 中经典的茶壶模型，也可以在&lt;a href=&quot;https://github.com/dcnieho/FreeGLUT&quot; target=&quot;_blank&quot;&gt;freeglut的github仓库&lt;/a&gt;中找到，只不过它使用的是贝塞尔曲面的描述方式，这个技术含量就高了那么一点点了。&lt;/p&gt;
&lt;p&gt;对于顶点数据的每一个分量（如坐标分量、法向量分量、纹理坐标分量、颜色分量等），我们都可以使用 GLM 库中的vec2、vec3、vec4格式表示，然后组织成 struct，再然后组织成 vector，这是很自然的事情。如果使用到顶点索引，则需要再准备一个索引数组的 vector。再然后，就是 OpenGL 的那一套 API 了，创建 VAO、VBO，如果有索引，再创建 EBO，然后绑定对象，创建 Buffer，绑定 Buffer，向 Buffer 中存入数据，最后使用 DrawArrays() 进行渲染，如果使用到了顶点索引，则使用 DrawElements() 进行渲染。&lt;/p&gt;
&lt;p&gt;在这里，我先创建一个 Mesh 类用来对以上流程进行一个封装，并创建 Mesh 类的几个子类，分别生成平面、球体、甜甜圈这几种基本图形，每个顶点具有坐标、法向量、纹理坐标（只有1组纹理坐标）。我把这些结构和类都放到一个文件 mesh.hpp 中，内容如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C++&quot;&gt;#ifndef __MESH_H__
#define __MESH_H__

#include &amp;lt;glm/glm.hpp&amp;gt;
#include &amp;lt;glm/gtc/matrix_transform.hpp&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;GL/glew.h&amp;gt;

struct Vertex{
    glm::vec4 position;
    glm::vec3 normal;
    glm::vec2 texCoord;
};

class Mesh{
    protected:
        std::vector&amp;lt;Vertex&amp;gt; vertices;
        std::vector&amp;lt;GLuint&amp;gt; indices;

        GLuint VAO, VBO, EBO;
               
    public:
        void generateMesh(int iSlices);

        void setup(){
            glCreateVertexArrays(1, &amp;amp;VAO);
            glBindVertexArray(VAO);
            glCreateBuffers(1, &amp;amp;VBO);
            glBindBuffer(GL_ARRAY_BUFFER, VBO);
            glNamedBufferStorage(VBO, sizeof(Vertex)*vertices.size(), &amp;amp;vertices[0], 0);
            glGenBuffers(1, &amp;amp;EBO);
            glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);
            glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(float)*indices.size(), &amp;amp;indices[0], GL_STATIC_DRAW);
            glVertexAttribPointer(0, 4, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)0);
            glEnableVertexAttribArray(0);
            glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)offsetof(Vertex, normal));
            glEnableVertexAttribArray(1);
            glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)offsetof(Vertex, texCoord));
            glEnableVertexAttribArray(2);
        }

        void render(){
            glBindVertexArray(VAO);
            glDrawElements(GL_TRIANGLES, indices.size(), GL_UNSIGNED_INT, 0);
        }

};

class Plane: public Mesh{
    public:
        void generateMesh(int iSlices){
            int n = iSlices + 1;
            float s = 2.0f/(float)iSlices;
            Vertex temp_vertex;
            for(int i=0; i&amp;lt;n; i++){
                for(int j=0; j&amp;lt;n; j++){
                    temp_vertex.position = glm::vec4(s*j - 1.0f, s*i - 1.0f, 0.0f, 1.0f);
                    temp_vertex.normal = glm::vec3(0.0f, 0.0f, 1.0f);
                    temp_vertex.texCoord = glm::vec2(1.0f/(float)iSlices * j, 1.0f/(float)iSlices * i);
                    vertices.push_back(temp_vertex);
                }
            }
            
            for(int i=0; i&amp;lt;iSlices; i++){
                for(int j=0; j&amp;lt;iSlices; j++){
                    indices.push_back(i*n + j);
                    indices.push_back((i+1)*n + j+1);
                    indices.push_back((i+1)*n + j);

                    indices.push_back(i*n + j);
                    indices.push_back(i*n + j + 1);
                    indices.push_back((i+1)*n + j+1);
                }
            }
        }
};

class Sphere: public Mesh{
    public:
        void generateMesh(int iSlices){
            int m = iSlices/2 + 1;
            int n = iSlices+1;
            float s = 360.0f/(float)iSlices;
            glm::vec4 up(0.0f, 1.0f, 0.0f, 1.0f);
            glm::mat4 I(1.0f);
            glm::vec3 X(1.0f, 0.0f, 0.0f);
            glm::vec3 Y(0.0f, 1.0f, 0.0f);
            glm::vec3 Z(0.0f, 0.0f, 1.0f);
            Vertex temp_vertex;
            for(int i=0; i&amp;lt;m; i++){
                for(int j=0; j&amp;lt;n; j++){
                    temp_vertex.position = glm::rotate(I, glm::radians(s*j), Y) * glm::rotate(I, glm::radians(s*i), Z) * up;
                    temp_vertex.normal = temp_vertex.position;
                    temp_vertex.texCoord = glm::vec2(1.0f/(float)(n-1) * j, 1.0f/(float)(m-1) * i);
                    vertices.push_back(temp_vertex);
                }
            }
            
            for(int i=0; i&amp;lt;m-1; i++){
                for(int j=0; j&amp;lt;n-1; j++){
                    indices.push_back(i*n + j);
                    indices.push_back((i+1)*n + j);
                    indices.push_back((i+1)*n + j+1);

                    indices.push_back(i*n + j);
                    indices.push_back((i+1)*n + j+1);
                    indices.push_back(i*n + j + 1);                   
                }
            }
        }
};

class Torus: public Mesh{
    public:
        void generateMesh(int iSlices){
            int n = iSlices + 1;
            float s = -360.0f/(float)iSlices;
            glm::vec4 top(0.0f, 0.2f, 0.0f, 1.0f);
            glm::vec4 normal_up(0.0f, 1.0f, 0.0f, 1.0f);
            glm::mat4 I(1.0f);
            glm::vec3 X(1.0f, 0.0f, 0.0f);
            glm::vec3 Y(0.0f, 1.0f, 0.0f);
            glm::vec3 Z(0.0f, 0.0f, 1.0f);
            Vertex temp_vertex;
            for(int i=0; i&amp;lt;n; i++){
                for(int j=0; j&amp;lt;n; j++){
                    temp_vertex.position = glm::rotate(I, glm::radians(s*j), Z) 
                                            * glm::translate(I, glm::vec3(0.0f, 0.8f, 0.0f))
                                            * glm::rotate(I, glm::radians(s*i), X) 
                                            * top;
                    temp_vertex.normal = glm::rotate(I, glm::radians(s*j), Z) 
                                            * glm::rotate(I, glm::radians(s*i), X) 
                                            * normal_up;
                    temp_vertex.texCoord = glm::vec2(1.0f/(float)iSlices * j * 4, 1.0f/(float)iSlices * i);
                    vertices.push_back(temp_vertex);
                }

            }
            for(int i=0; i&amp;lt;iSlices; i++){
                for(int j=0; j&amp;lt;iSlices; j++){
                    indices.push_back(i*n + j);
                    indices.push_back((i+1)*n + j+1);
                    indices.push_back((i+1)*n + j);

                    indices.push_back(i*n + j);
                    indices.push_back(i*n + j + 1);
                    indices.push_back((i+1)*n + j+1);
                }
            }
        }
};

#endif
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;编译和连接-shader&quot;&gt;编译和连接 Shader&lt;/h2&gt;
&lt;p&gt;在 OpenGL 中编译和连接 Shader 的流程是固定的，也就是那几个 API，详细的知识我就不赘述了，基本所有的教材都有，对于简单的程序来说，一个 Vertex Shader 和一个 Fragment Shader 就可以了，至于几何着色器、细分着色器这样的高级知识，等用到的时候再说。关于着色器的编译连接，我也写了一个 Shader 类对它进行了封装，放到了文件 shader.hpp 中，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C++&quot;&gt;#ifndef __SHADER_HPP__
#define __SHADER_HPP__

#include &amp;lt;string&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;fstream&amp;gt;
#include &amp;lt;sstream&amp;gt;
#include &amp;lt;GL/glew.h&amp;gt;
#include &amp;lt;glm/glm.hpp&amp;gt;
#include &amp;lt;glm/gtc/type_ptr.hpp&amp;gt;

struct ShaderInfo{
        GLenum type;
        std::string filename;
        GLuint shader_id;
};

class Shader{
    private:
        GLuint program_id;
    public:
        Shader(){
            program_id = 0;
        }
        
        Shader(ShaderInfo* shaders){
            if(shaders == nullptr){
                program_id = 0;
                return;
            }

            program_id = glCreateProgram();

            ShaderInfo* entry = shaders;
            //加载并编译Shader
            while(entry-&amp;gt;type != GL_NONE){
                GLuint shader_id = glCreateShader(entry-&amp;gt;type);
                entry-&amp;gt;shader_id = shader_id;

                std::ifstream fs(entry-&amp;gt;filename);
                std::string content((std::istreambuf_iterator&amp;lt;char&amp;gt;(fs)), std::istreambuf_iterator&amp;lt;char&amp;gt;());
                               
                if(content.empty()){ //只要有一个Shader文件打不开，就删掉之前创建的所有Shader
                    std::cerr &amp;lt;&amp;lt; &quot;Unable to open file '&quot; &amp;lt;&amp;lt; entry-&amp;gt;filename &amp;lt;&amp;lt; &quot;'&quot; &amp;lt;&amp;lt; std::endl;
                    for ( entry = shaders; entry-&amp;gt;type != GL_NONE; ++entry ) {
                        glDeleteShader( entry-&amp;gt;shader_id );
                        entry-&amp;gt;shader_id = 0;
                    }
                    return;
                }
                const GLchar* source = content.c_str();
                glShaderSource( shader_id, 1, &amp;amp;source, NULL );

                glCompileShader( shader_id );

                GLint compiled;
                glGetShaderiv( shader_id, GL_COMPILE_STATUS, &amp;amp;compiled );
                if ( !compiled ) {//如果Shader编译失败，输出失败原因，便于调试
                    GLsizei len;
                    glGetShaderiv( shader_id, GL_INFO_LOG_LENGTH, &amp;amp;len );

                    GLchar* log = new GLchar[len+1];
                    glGetShaderInfoLog( shader_id, len, &amp;amp;len, log );
                    std::cerr &amp;lt;&amp;lt; entry-&amp;gt;filename &amp;lt;&amp;lt; &quot;,&quot; &amp;lt;&amp;lt; &quot;Shader compilation failed: &quot; &amp;lt;&amp;lt; log &amp;lt;&amp;lt; std::endl;
                    delete [] log;

                    //编译失败，也要删除前面创建的所有Shader
                    for ( entry = shaders; entry-&amp;gt;type != GL_NONE; ++entry ) {
                        glDeleteShader( entry-&amp;gt;shader_id );
                        entry-&amp;gt;shader_id = 0;
                    }

                    return ;
                }

                glAttachShader( program_id, shader_id );
        
                ++entry;
                
            }
            
            //进入连接阶段
            glLinkProgram( program_id );

            GLint linked;
            glGetProgramiv( program_id, GL_LINK_STATUS, &amp;amp;linked );
            if ( !linked ) {//如果连接失败，则输出调试信息，同样删除之前创建的所有Shader
                GLsizei len;
                glGetProgramiv( program_id, GL_INFO_LOG_LENGTH, &amp;amp;len );

                GLchar* log = new GLchar[len+1];
                glGetProgramInfoLog( program_id, len, &amp;amp;len, log );
                std::cerr &amp;lt;&amp;lt; &quot;Shader linking failed: &quot; &amp;lt;&amp;lt; log &amp;lt;&amp;lt; std::endl;
                delete [] log;

                for ( entry = shaders; entry-&amp;gt;type != GL_NONE; ++entry ) {
                    glDeleteShader( entry-&amp;gt;shader_id );
                    entry-&amp;gt;shader_id = 0;
                }
        
                return;
            }
            
        }

        GLuint getId(){
            return program_id;
        }
        
        void setCurrent(){
            glUseProgram(program_id);
        }

        void setModelMatrix(glm::mat4 model_matrix){
            glUniformMatrix4fv(glGetUniformLocation(program_id, &quot;model_matrix&quot;), 1, GL_FALSE, glm::value_ptr(model_matrix));
        }

        void setViewMatrix(glm::mat4 view_matrix){
            glUniformMatrix4fv(glGetUniformLocation(program_id, &quot;view_matrix&quot;), 1, GL_FALSE, glm::value_ptr(view_matrix));
        }

        void setProjectionMatrix(glm::mat4 projection_matrix){
            glUniformMatrix4fv(glGetUniformLocation(program_id, &quot;projection_matrix&quot;), 1, GL_FALSE, glm::value_ptr(projection_matrix));
        }
};

#endif
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该 Shader 类还提供了一些向 Shader 中传递 Uniform 变量的方法，最常见的 Uniform 变量就是模型矩阵、视图矩阵和投影矩阵。&lt;/p&gt;
&lt;h2 id=&quot;主程序&quot;&gt;主程序&lt;/h2&gt;
&lt;p&gt;主程序文件为 SphereWorld.cpp，在该文件中，创建一个 App 类的字类，并在 init 方法中创建一个平面、一个球体、一个甜甜圈，并使用模型矩阵分别将它们进行平移、缩放和旋转，以放到场景中的适当位置，另外，使用视图矩阵将 Camera 放到适当的位置，最后，创建合适的透视投影矩阵，就可以看到非常逼真的三维图像了。在创建和使用这些矩阵的时候，GLM 为我们提供了非常大的方便。目前还没有涉及到光照和纹理，故将 OpenGL 设置为线框模式，这样看起来更加立体。程序代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C++&quot;&gt;#include &quot;../include/app.hpp&quot;
#include &quot;../include/shader.hpp&quot;
#include &quot;../include/mesh.hpp&quot;
#include &amp;lt;glm/glm.hpp&amp;gt;
#include &amp;lt;glm/gtc/matrix_transform.hpp&amp;gt;

class MyApp : public App {
    private:
        const GLfloat clearColor[4] = {0.2f, 0.3f, 0.3f, 1.0f};
        Plane plane;
        Sphere sphere;
        Torus torus;
        Shader* shaderSphereWorld;

    public:
        void init(){
            
            ShaderInfo shaders[] = {
                {GL_VERTEX_SHADER, &quot;sphereworld.vert&quot;},
                {GL_FRAGMENT_SHADER, &quot;sphereworld.frag&quot;},
                {GL_NONE, &quot;&quot;}
            };
            shaderSphereWorld = new Shader(shaders);
            plane.generateMesh(20);
            plane.setup();

            sphere.generateMesh(60);
            sphere.setup();

            torus.generateMesh(60);
            torus.setup();
            
            glEnable(GL_DEPTH_TEST);
            glDepthFunc(GL_LEQUAL);

            glPolygonMode( GL_FRONT_AND_BACK, GL_LINE );
        }

        void display(){
            glClearBufferfv(GL_COLOR, 0, clearColor);
            glClear(GL_DEPTH_BUFFER_BIT);

            glm::mat4 I(1.0f);
            glm::vec3 X(1.0f, 0.0f, 0.0f);
            glm::vec3 Y(0.0f, 1.0f, 0.0f);
            glm::vec3 Z(0.0f, 0.0f, 1.0f);
            float t = (float)glfwGetTime();

            glm::mat4 view_matrix = glm::translate(I, glm::vec3(0.0f, 0.0f, -5.0f))
                                        * glm::rotate(I, t, Y);

            glm::mat4 projection_matrix = glm::perspective(glm::radians(45.0f), aspect, 1.0f, 100.0f);

            glm::mat4 plane_model_matrix = glm::translate(I, glm::vec3(0.0f, -1.0f, 0.0f)) 
                                        * glm::rotate(I, glm::radians(-90.0f), X)
                                        * glm::scale(I, glm::vec3(50.0f, 50.0f, 50.0f));
            
            shaderSphereWorld-&amp;gt;setModelMatrix(plane_model_matrix);
            shaderSphereWorld-&amp;gt;setViewMatrix(view_matrix);
            shaderSphereWorld-&amp;gt;setProjectionMatrix(projection_matrix);
            shaderSphereWorld-&amp;gt;setCurrent();
            plane.render();

            glm::mat4 sphere_model_matrix = glm::translate(I, glm::vec3(1.0f, 0.3f, 0.0f))
                                                * glm::scale(I, glm::vec3(0.8f, 0.8f, 0.8f));
            shaderSphereWorld-&amp;gt;setModelMatrix(sphere_model_matrix);
            sphere.render();

            glm::mat4 torus_model_matrix = glm::translate(I, glm::vec3(-1.0f, 0.3f, 0.0f))
                                                * glm::rotate(I, glm::radians(90.0f), Y)
                                                * glm::scale(I, glm::vec3(1.3f, 1.3f, 1.3f));
            shaderSphereWorld-&amp;gt;setModelMatrix(torus_model_matrix);
            torus.render();
        }

        ~MyApp(){
            if(shaderSphereWorld != NULL){
                delete shaderSphereWorld;
            }
        }

};


DECLARE_MAIN(MyApp)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们暂时还没有实现在场景中漫游的功能，所以只能让它自己旋转，以便于我们全方位地观察。在这里，是通过 glfwGetTime() 获取程序运行的时间，并根据时间值来生成视图矩阵来实现这个功能的。&lt;/p&gt;
&lt;h2 id=&quot;编写-shader-程序&quot;&gt;编写 Shader 程序&lt;/h2&gt;
&lt;p&gt;这里的 Shader 程序是 sphereworld.vert 和 sphereworld.frag，前者是顶点着色器程序，后者是片元着色器程序。都很简单。&lt;/p&gt;
&lt;p&gt;sphereworld.vert 文件的内容如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#version 460

uniform mat4 model_matrix;
uniform mat4 projection_matrix;
uniform mat4 view_matrix;

layout (location = 0) in vec4 vPosition;
layout (location = 1) in vec3 vNormal;
layout (location = 1) in vec2 vTexCoord;

out vec4 fColor;
out vec3 fNormal;
out vec2 fTexCoord;
out vec4 fPosition;

void main(void)
{
    mat4 MV_matrix = view_matrix * model_matrix;
    gl_Position = projection_matrix * view_matrix * model_matrix * vPosition;
    fPosition =  MV_matrix * vPosition;
    fNormal = normalize(transpose(inverse(mat3(MV_matrix))) * vNormal);
    fTexCoord = vTexCoord;
    fColor = vec4(1.0f, 1.0f, 1.0f, 1.0f);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;sphereworld.frag 文件内容如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#version 460

layout (location = 0) out vec4 color;

in vec4 fColor;
in vec3 fNormal;
in vec2 fTexCoord;
in vec4 fPosition;

void main(void)
{
    color = fColor;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;最终效果&quot;&gt;最终效果&lt;/h2&gt;
&lt;p&gt;编译，运行，就可以看到最终的效果了。如下图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/16576/202102/16576-20210207224619084-591364241.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我使用的是 Visual Studio Code。从截图中可以看到我所有文件的组织情况。好了，今天就到这里。&lt;/p&gt;
&lt;h2 id=&quot;版权申明&quot;&gt;版权申明&lt;/h2&gt;
&lt;p&gt;该随笔由京山游侠在2021年02月07日发布于博客园，引用请注明出处，转载或出版请联系博主。QQ邮箱：1841079@qq.com&lt;/p&gt;
</description>
<pubDate>Sun, 07 Feb 2021 15:00:00 +0000</pubDate>
<dc:creator>京山游侠</dc:creator>
<og:description>##前言 OpenGL 的学习资料很多，一个是比较著名的 OpenGL 红宝书《OpenGL 编程指南》，可以在这里 http://opengl-redbook.com/ 下载该书配套的源代码；另一个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/youxia/p/cg003.html</dc:identifier>
</item>
</channel>
</rss>