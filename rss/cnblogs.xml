<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>测试同学动手搭个简易web开发项目 - 东方er</title>
<link>http://www.cnblogs.com/df888/p/13191065.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/df888/p/13191065.html</guid>
<description>&lt;p&gt;node.js, vue.js, axios, python, django, orm, restful api, djangorestframework, mysql, nginx, jenkins.&lt;/p&gt;

&lt;h2 id=&quot;操作系统&quot;&gt;操作系统&lt;/h2&gt;
&lt;p&gt;Windows 7 旗舰版，Service Pack 1。&lt;/p&gt;
&lt;h2 id=&quot;前端&quot;&gt;前端&lt;/h2&gt;
&lt;h3 id=&quot;nodejs&quot;&gt;Node.js&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;&amp;gt;node -v
v12.18.0
&amp;gt;npm -v
6.14.4
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;vuejs&quot;&gt;Vue.js&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;&amp;gt;vue -V(大写)
@vue/cli 4.4.1
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;后端&quot;&gt;后端&lt;/h2&gt;
&lt;h3 id=&quot;python&quot;&gt;Python&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;&amp;gt;python --version
Python 3.7.2
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;django&quot;&gt;Django&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;&amp;gt;python -m django --version
3.0.7
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;数据库&quot;&gt;数据库&lt;/h2&gt;
&lt;h3 id=&quot;mysql&quot;&gt;MySQL&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;&amp;gt;mysqladmin --version
mysqladmin  Ver 8.0.19 for Win64 on x86_64 (MySQL Community Server - GPL)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;命令行登录mysql，&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;&amp;gt;mysql -u root -p
Enter password: ******
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查询数据库，&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;mysql&amp;gt; show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| new_schema         |
| performance_schema |
| sakila             |
| sys                |
| world              |
+--------------------+
7 rows in set (0.00 sec)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;代理&quot;&gt;代理&lt;/h2&gt;
&lt;h3 id=&quot;nginx&quot;&gt;Nginx&lt;/h3&gt;
&lt;p&gt;在nginx安装目录执行&lt;code&gt;start nginx&lt;/code&gt;，浏览器访问http://localhost:80，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202006/1629545-20200625084621584-1258032881.png&quot; alt=&quot;1592456182850&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;持续集成&quot;&gt;持续集成&lt;/h2&gt;
&lt;h3 id=&quot;jenkins&quot;&gt;Jenkins&lt;/h3&gt;
&lt;p&gt;安装后，会自动打开http://localhost:8080/，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202006/1629545-20200625084621949-623090588.png&quot; alt=&quot;1592979912495_副本&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;软件安装过程就不赘述了，聪明的你一定知道怎么安。&lt;/p&gt;

&lt;p&gt;本文的目的是走通整个项目的链路，于是会“弱化”掉系统功能的实现。&lt;/p&gt;
&lt;h2 id=&quot;创建后端工程&quot;&gt;创建后端工程&lt;/h2&gt;
&lt;p&gt;执行&lt;code&gt;django-admin startproject djangotest&lt;/code&gt;创建项目。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cd djangotest&lt;/code&gt;，执行&lt;code&gt;python manage.py startapp myapp&lt;/code&gt;创建应用。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;python manage.py runserver&lt;/code&gt;，启动服务，访问http://localhost:8000/，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202006/1629545-20200625084622221-766351503.png&quot; alt=&quot;1591519905326_副本&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;创建restful-api&quot;&gt;创建RESTful API&lt;/h2&gt;
&lt;p&gt;安装mysqlclient和djangorestframework，&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;pip --default-timeout=6000 install -i https://pypi.tuna.tsinghua.edu.cn/simple mysqlclient
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;pip --default-timeout=6000 install -i https://pypi.tuna.tsinghua.edu.cn/simple djangorestframework
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在settings.py中，添加'rest_framework'和'myapp'，&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',

    'rest_framework',

    'myapp',
]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同时修改数据库配置，&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'HOST': '127.0.0.1',
        'PORT': 3306,
        'NAME': 'world',
        'USER': 'root',
        'PASSWORD': '123456'
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在myapp\models.py添加model，model叫做HellloDjango，有2个字段id和name，&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from django.db import models

# Create your models here.


class HelloDjango(models.Model):
    id = models.AutoField(primary_key=True)
    name = models.CharField(null=False, max_length=64, unique=True)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行&lt;code&gt;python manage.py makemigrations&lt;/code&gt;，提交，&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;&amp;gt;python manage.py makemigrations
Migrations for 'myapp':
  myapp\migrations\0001_initial.py
    - Create model HelloDjango
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行&lt;code&gt;python manage.py migrate&lt;/code&gt;，创建，&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;&amp;gt;python manage.py migrate
Operations to perform:
  Apply all migrations: admin, auth, contenttypes, myapp, sessions
Running migrations:
  Applying contenttypes.0001_initial... OK
  Applying auth.0001_initial... OK
  Applying admin.0001_initial... OK
  Applying admin.0002_logentry_remove_auto_add... OK
  Applying admin.0003_logentry_add_action_flag_choices... OK
  Applying contenttypes.0002_remove_content_type_name... OK
  Applying auth.0002_alter_permission_name_max_length... OK
  Applying auth.0003_alter_user_email_max_length... OK
  Applying auth.0004_alter_user_username_opts... OK
  Applying auth.0005_alter_user_last_login_null... OK
  Applying auth.0006_require_contenttypes_0002... OK
  Applying auth.0007_alter_validators_add_error_messages... OK
  Applying auth.0008_alter_user_username_max_length... OK
  Applying auth.0009_alter_user_last_name_max_length... OK
  Applying auth.0010_alter_group_name_max_length... OK
  Applying auth.0011_update_proxy_permissions... OK
  Applying myapp.0001_initial... OK
  Applying sessions.0001_initial... OK
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看看数据库，新增了auth_和django_开头的表，以及model映射的表myapp_hellodjango，&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;mysql&amp;gt; show tables;
+----------------------------+
| Tables_in_world            |
+----------------------------+
| auth_group                 |
| auth_group_permissions     |
| auth_permission            |
| auth_user                  |
| auth_user_groups           |
| auth_user_user_permissions |
| city                       |
| country                    |
| countrylanguage            |
| django_admin_log           |
| django_content_type        |
| django_migrations          |
| django_session             |
| myapp_hellodjango          |
+----------------------------+
14 rows in set (0.00 sec)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;插入2条测试数据，&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;mysql&amp;gt; insert into myapp_hellodjango(name) values('hello');
Query OK, 1 row affected (0.09 sec)

mysql&amp;gt; insert into myapp_hellodjango(name) values('django');
Query OK, 1 row affected (0.20 sec)

mysql&amp;gt; select * from myapp_hellodjango;
+----+--------+
| id | name   |
+----+--------+
|  2 | django |
|  1 | hello  |
+----+--------+
2 rows in set (0.00 sec)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;照着官网的例子，在myapp目录下新增urls.py，添加rest代码，&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from django.conf.urls import url, include
from rest_framework import routers, serializers, viewsets

from .models import HelloDjango


# Serializers define the API representation.
class HelloSerializer(serializers.HyperlinkedModelSerializer):
    class Meta:
        model = HelloDjango
        fields = ['id', 'name']


# ViewSets define the view behavior.
class HelloViewSet(viewsets.ModelViewSet):
    queryset = HelloDjango.objects.all()
    serializer_class = HelloSerializer


# Routers provide an easy way of automatically determining the URL conf.
router = routers.DefaultRouter()
router.register(r'hello', HelloViewSet)

urlpatterns = [
    url(r'demo/', include(router.urls)),
]

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在djangotest下的urls.py中添加路由，&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('api/', include('myapp.urls'))
]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过这2个urls.py文件的指定，api接口的路径为，/api/demo/hello。&lt;/p&gt;
&lt;p&gt;执行&lt;code&gt;python manage.py runserver&lt;/code&gt;启动服务，使用postman来调用http://127.0.0.1:8000/api/demo/hello/。先发1个post请求，往数据库新增1条数据，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202006/1629545-20200625084622449-552269484.png&quot; alt=&quot;1592902408582_副本&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再发1个get请求，会看到返回了3条数据，2条预先插入的数据，1条post请求新增的数据，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202006/1629545-20200625084622677-1948902496.png&quot; alt=&quot;1592902449583_副本&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;创建前端工程&quot;&gt;创建前端工程&lt;/h2&gt;
&lt;p&gt;在djangotest根目录下，执行&lt;code&gt;vue create vuetest&lt;/code&gt;，创建vue工程。&lt;/p&gt;
&lt;p&gt;默认安装，一路回车，啪啪啪。&lt;/p&gt;
&lt;p&gt;开始创建，&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;Vue CLI v4.4.1
a  Creating project in D:\cicd\vuetest.
a  Initializing git repository...
aa Installing CLI plugins. This might take a while...
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建成功，&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;a  Successfully created project vuetest.
a  Get started with the following commands:

 $ cd vuetest
 $ npm run serve
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行&lt;code&gt;cd vuetest&lt;/code&gt;和&lt;code&gt;npm run serve&lt;/code&gt;，前端工程就启动起来了，访问http://localhost:8080/，Welcome to Your Vue.js App,&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202006/1629545-20200625084622908-1687726073.png&quot; alt=&quot;1591501593139_副本&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;前端调后端接口&quot;&gt;前端调后端接口&lt;/h2&gt;
&lt;p&gt;此时djangotest的目录结构为，&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;├─djangotest
│  ├─djangotest
│  ├─myapp  # app
│  ├─vuetest  # 前端
│  ├─manage.py
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改vuetest\src\components\HelloWorld.vue，添加&lt;code&gt;{{info}}&lt;/code&gt;，用来展示后端api返回的数据，&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-vue&quot;&gt;&amp;lt;div class=&quot;hello&quot;&amp;gt;
  {{info}}
    &amp;lt;h1&amp;gt;{{ msg }}&amp;lt;/h1&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同时在&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;中使用axios添加ajax请求，请求http://127.0.0.1:8000/api/demo/hello/，将response.data赋值给info，&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-vue&quot;&gt;&amp;lt;script&amp;gt;
export default {
  name: 'HelloWorld',
  props: {
    msg: String
  },
  data() {
    return {
        info: 123
    }
  },
  mounted () {
    this.$axios
      .get('http://127.0.0.1:8000/api/demo/hello/')
      .then(response =&amp;gt; (this.info = response.data))
      .catch(function (error) { // 请求失败处理
        console.log(error);
      });
  }
}
&amp;lt;/script&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了运行起来，需要安装axios，&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;npm install --save axios
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;并在vuetest\src\main.js中引入，&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;import Vue from 'vue'
import App from './App.vue'
import axios from 'axios'

Vue.config.productionTip = false

Vue.prototype.$axios = axios;

new Vue({
  render: h =&amp;gt; h(App)
}).$mount('#app')
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;分别启动后端和前端服务，&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;python manage.py runserver
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;cd vuetest
npm run serve
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;嚯！ajax请求失败了，F12可以看到报错信息，&lt;/p&gt;
&lt;p&gt;&lt;span&gt;localhost/:1 Access to XMLHttpRequest at '&lt;a href=&quot;http://127.0.0.1:8000/api/demo/hello/&quot;&gt;http://127.0.0.1:8000/api/demo/hello/&lt;/a&gt;' from origin '&lt;a href=&quot;http://localhost:8080&quot;&gt;http://localhost:8080&lt;/a&gt;' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;django的端口是8000，vue的端口是8080，vue在请求django的时候，出现了跨域问题。浏览器有个同源策略，域名+端口+协议都相同才认为是同一来源。&lt;/p&gt;
&lt;p&gt;通过配置django来解决，先安装django-cors-headers，&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;pip install django-cors-headers
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在settings.py中添加中间件和开关，&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'corsheaders.middleware.CorsMiddleware',  # 添加
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

CORS_ORIGIN_ALLOW_ALL = True  # 添加
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时vue就可以请求到django提供的接口了，&lt;a href=&quot;http://localhost:8080/&quot;&gt;http://localhost:8080/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202006/1629545-20200625084623518-826490999.png&quot; alt=&quot;1592972876066_副本&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;前后端结合&quot;&gt;前后端结合&lt;/h2&gt;
&lt;p&gt;在&lt;code&gt;vuetest&lt;/code&gt;目录下创建&lt;code&gt;vue.config.js&lt;/code&gt;，这是因为django只能识别static目录下的静态文件，这里指定vue生成静态文件时套一层static目录，&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;module.exports = {
    assetsDir: 'static'
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在vuetest目录下执行&lt;code&gt;npm run build&lt;/code&gt;，生成静态文件到vuetest/dist文件夹。&lt;/p&gt;
&lt;p&gt;修改urls.py，指定django的模板视图，&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from django.conf.urls import url
from django.contrib import admin
from django.urls import path, include
from django.views.generic import TemplateView

urlpatterns = [
    path('admin/', admin.site.urls),
    path('api/', include('myapp.urls')),
    url(r'^$', TemplateView.as_view(template_name=&quot;index.html&quot;)),
]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在settings.py中配置模板目录为dist文件夹，&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': ['appfront/dist'],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;指定静态文件目录为vuetest/dist/static，&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# Add for vuejs
STATICFILES_DIRS = [
    os.path.join(BASE_DIR, &quot;vuetest/dist/static&quot;),
]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;浏览器访问http://localhost:8000/，显示的不再是django的欢迎页面，而是vue的页面。&lt;/p&gt;
&lt;p&gt;前后端结合完成。vue的8080可以停了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202006/1629545-20200625084623518-826490999.png&quot; alt=&quot;1592972876066_副本&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;nginx常用3个命令，启动，重新加载，停止，&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;nginx start
nginx -s reload
nginx -s stop
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改\conf\nginx.conf，监听端口改为8090，添加转发&lt;code&gt;proxy_pass http://localhost:8000;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   server {
        listen       8090;
        server_name  localhost;

        #charset koi8-r;

        #access_log  logs/host.access.log  main;

        location / {
            root   html;
            index  index.html index.htm;
            proxy_pass http://localhost:8000;
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行&lt;code&gt;nginx start&lt;/code&gt;，浏览器访问http://localhost:8090/，也能正常访问djangotest。&lt;/p&gt;
&lt;p&gt;通过nginx将8090转发到了8000。&lt;/p&gt;

&lt;p&gt;本来想弄个pipline的，无奈家里这台破机器安装失败，windows也没有linux对jenkins支持好，只能将就做个鸡肋版本。&lt;/p&gt;
&lt;p&gt;New Item，命名为vuetest，添加vue的build脚本，&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;d:
cd D:\cicd\djangotest\vuetest
npm run build
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202006/1629545-20200625084623743-1391401473.png&quot; alt=&quot;1592991544913_副本&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;New Item，命名为djangotest，添加django的build脚本，&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;d:
cd D:\cicd\djangotest
python manage.py runserver
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202006/1629545-20200625084623941-33290962.png&quot; alt=&quot;1592991578357_副本&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;直接执行会报错python不是可运行命令。添加python环境变量，在首页左下角，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202006/1629545-20200625084624169-1878505428.png&quot; alt=&quot;1592983220698_副本&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;把路径D:\Python37添加为环境变量path并保存，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202006/1629545-20200625084624394-1275645948.png&quot; alt=&quot;1592983242033_副本&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;建好的这2个job就可以用来编译vue和启动django了，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202006/1629545-20200625084624679-1130558071.png&quot; alt=&quot;1592991709156_副本&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;专注测试，坚持原创，只做精品。欢迎关注公众号『东方er』&lt;br/&gt;&lt;span&gt;版权申明：本文为博主原创文章，转载请保留原文链接及作者。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 25 Jun 2020 00:48:00 +0000</pubDate>
<dc:creator>东方er</dc:creator>
<og:description>技术栈 node.js, vue.js, axios, python, django, orm, restful api, djangorestframework, mysql, nginx, jen</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/df888/p/13191065.html</dc:identifier>
</item>
<item>
<title>JavaScript图形实例：图形放大镜效果 - aTeacher</title>
<link>http://www.cnblogs.com/cs-whut/p/13191030.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cs-whut/p/13191030.html</guid>
<description>&lt;h3 align=&quot;center&quot;&gt;&lt;span&gt;1. 基本四瓣花型图案&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;根据四瓣花卉线的参数方程：&lt;/p&gt;
&lt;p&gt;    t= r*(1+sin(12*θ)/5)*(0.5+sin(4*θ)/2);&lt;/p&gt;
&lt;p&gt;    x=t*cos(θ));&lt;/p&gt;
&lt;p&gt;    y=t*sin(θ));&lt;/p&gt;
&lt;p&gt;编写如下的HTML文件。&lt;/p&gt;
&lt;p&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;head&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;title&amp;gt;基本的四瓣花型图案&amp;lt;/title&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;  function draw(id)&lt;/p&gt;
&lt;p&gt;  {&lt;/p&gt;
&lt;p&gt;     var canvas=document.getElementById(id);&lt;/p&gt;
&lt;p&gt;     if (canvas==null)&lt;/p&gt;
&lt;p&gt;        return false;&lt;/p&gt;
&lt;p&gt;     var context=canvas.getContext('2d');&lt;/p&gt;
&lt;p&gt;     context.fillStyle=&quot;#EEEEFF&quot;;&lt;/p&gt;
&lt;p&gt;     context.fillRect(0,0,320,320);&lt;/p&gt;
&lt;p&gt;     context.strokeStyle=&quot;blue&quot;;&lt;/p&gt;
&lt;p&gt;     context.lineWidth=1;&lt;/p&gt;
&lt;p&gt;     var dig=Math.PI/64;&lt;/p&gt;
&lt;p&gt;     context.beginPath();&lt;/p&gt;
&lt;p&gt;     for (var i=0;i&amp;lt;=128;i++)&lt;/p&gt;
&lt;p&gt;     {&lt;/p&gt;
&lt;p&gt;            d=120*(1+Math.sin(12*i*dig)/5);&lt;/p&gt;
&lt;p&gt;            t=d*(0.5+Math.sin(4*i*dig)/2);&lt;/p&gt;
&lt;p&gt;            x=(160+t*Math.cos(i*dig));&lt;/p&gt;
&lt;p&gt;            y=(160+t*Math.sin(i*dig));&lt;/p&gt;
&lt;p&gt;            if (i==0)&lt;/p&gt;
&lt;p&gt;              context.moveTo(x,y);&lt;/p&gt;
&lt;p&gt;            else&lt;/p&gt;
&lt;p&gt;              context.lineTo(x,y);&lt;/p&gt;
&lt;p&gt;     }&lt;/p&gt;
&lt;p&gt;     context.stroke();&lt;/p&gt;
&lt;p&gt;  }&lt;/p&gt;
&lt;p&gt;&amp;lt;/script&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/head&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;body onload=&quot;draw('myCanvas');&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;canvas id=&quot;myCanvas&quot; width=&quot;320&quot; height=&quot;320&quot;&amp;gt;&amp;lt;/canvas&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/body&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/html&amp;gt;&lt;/p&gt;
&lt;p&gt;在浏览器中打开包含这段HTML代码的html文件，可以看到在画布中绘制出如图1所示的四瓣花卉线图案。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485495/202006/1485495-20200625080328090-2112155047.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt; &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图1  四瓣花卉线图案&lt;/p&gt;
&lt;h3&gt;2．平铺的100朵四瓣花&lt;/h3&gt;
&lt;p&gt;用一个二重循环将图1的四瓣花卉绘制10行10列共100朵。编写的HTML文件内容如下。&lt;/p&gt;
&lt;p&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;head&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;title&amp;gt;平铺的100朵四瓣花&amp;lt;/title&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;  function draw(id)&lt;/p&gt;
&lt;p&gt;  {&lt;/p&gt;
&lt;p&gt;     var canvas=document.getElementById(id);&lt;/p&gt;
&lt;p&gt;     if (canvas==null)&lt;/p&gt;
&lt;p&gt;        return false;&lt;/p&gt;
&lt;p&gt;     var context=canvas.getContext('2d');&lt;/p&gt;
&lt;p&gt;     context.fillStyle=&quot;#EEEEFF&quot;;&lt;/p&gt;
&lt;p&gt;     context.fillRect(0,0,320,320);&lt;/p&gt;
&lt;p&gt;     context.strokeStyle=&quot;blue&quot;;&lt;/p&gt;
&lt;p&gt;     context.lineWidth=1;&lt;/p&gt;
&lt;p&gt;     var dig=Math.PI/64;&lt;/p&gt;
&lt;p&gt;     context.beginPath();&lt;/p&gt;
&lt;p&gt;     for (px=20;px&amp;lt;320;px+=30)&lt;/p&gt;
&lt;p&gt;       for (py=20;py&amp;lt;320;py+=30)&lt;/p&gt;
&lt;p&gt;       {&lt;/p&gt;
&lt;p&gt;         for (var i=0;i&amp;lt;=128;i++)&lt;/p&gt;
&lt;p&gt;         {&lt;/p&gt;
&lt;p&gt;            d=20*(1+Math.sin(12*i*dig)/5);&lt;/p&gt;
&lt;p&gt;            t=d*(0.5+Math.sin(4*i*dig)/2);&lt;/p&gt;
&lt;p&gt;            x=px+t*Math.cos(i*dig);&lt;/p&gt;
&lt;p&gt;            y=py+t*Math.sin(i*dig);&lt;/p&gt;
&lt;p&gt;            if (i==0)&lt;/p&gt;
&lt;p&gt;              context.moveTo(x,y);&lt;/p&gt;
&lt;p&gt;            else&lt;/p&gt;
&lt;p&gt;              context.lineTo(x,y);&lt;/p&gt;
&lt;p&gt;          }&lt;/p&gt;
&lt;p&gt;          context.stroke();&lt;/p&gt;
&lt;p&gt;       }&lt;/p&gt;
&lt;p&gt;  }&lt;/p&gt;
&lt;p&gt;&amp;lt;/script&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/head&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;body onload=&quot;draw('myCanvas');&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;canvas id=&quot;myCanvas&quot; width=&quot;320&quot; height=&quot;320&quot;&amp;gt;&amp;lt;/canvas&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/body&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/html&amp;gt;&lt;/p&gt;
&lt;p&gt;在浏览器中打开包含这段HTML代码的html文件，可以看到在画布中绘制出如图2所示的平铺的100朵四瓣花卉图案。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485495/202006/1485495-20200625080415045-247158317.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt; &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图2  平铺的100朵四瓣花卉图案&lt;/p&gt;
&lt;h3&gt;3．放大镜看平铺的四瓣花&lt;/h3&gt;
&lt;p&gt;      将图2图形中位于中心点周围100以内的点的坐标进行球面镜反射变换，可以实现放大镜效果。编写的HTML文件内容如下。&lt;/p&gt;
&lt;p&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;head&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;title&amp;gt;球面镜反射变换&amp;lt;/title&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;  function draw(id)&lt;/p&gt;
&lt;p&gt;  {&lt;/p&gt;
&lt;p&gt;     var canvas=document.getElementById(id);&lt;/p&gt;
&lt;p&gt;     if (canvas==null)&lt;/p&gt;
&lt;p&gt;        return false;&lt;/p&gt;
&lt;p&gt;     var context=canvas.getContext('2d');&lt;/p&gt;
&lt;p&gt;     context.fillStyle=&quot;#EEEEFF&quot;;&lt;/p&gt;
&lt;p&gt;     context.fillRect(0,0,320,320);&lt;/p&gt;
&lt;p&gt;     context.strokeStyle=&quot;blue&quot;;&lt;/p&gt;
&lt;p&gt;     context.lineWidth=1;&lt;/p&gt;
&lt;p&gt;     var dig=Math.PI/64;&lt;/p&gt;
&lt;p&gt;     context.beginPath();&lt;/p&gt;
&lt;p&gt;     var r=140;&lt;/p&gt;
&lt;p&gt;     var x0=160;&lt;/p&gt;
&lt;p&gt;     var y0=160;&lt;/p&gt;
&lt;p&gt;     for (px=20;px&amp;lt;320;px+=30)&lt;/p&gt;
&lt;p&gt;       for (py=20;py&amp;lt;320;py+=30)&lt;/p&gt;
&lt;p&gt;       {&lt;/p&gt;
&lt;p&gt;         for (var i=0;i&amp;lt;=128;i++)&lt;/p&gt;
&lt;p&gt;         {&lt;/p&gt;
&lt;p&gt;            d=20*(1+Math.sin(12*i*dig)/5);&lt;/p&gt;
&lt;p&gt;            t=d*(0.5+Math.sin(4*i*dig)/2);&lt;/p&gt;
&lt;p&gt;            x=px+t*Math.cos(i*dig);&lt;/p&gt;
&lt;p&gt;            y=py+t*Math.sin(i*dig);&lt;/p&gt;
&lt;p&gt;            l=Math.sqrt((x-x0)*(x-x0)+(y-y0)*(y-y0));&lt;/p&gt;
&lt;p&gt;            if (l&amp;lt;r)&lt;/p&gt;
&lt;p&gt;            { // 圆心为（160,160），半径为140的圆内各点进行球面镜反射变换&lt;/p&gt;
&lt;p&gt;               s=x-x0&amp;lt;0?-1:1;&lt;/p&gt;
&lt;p&gt;               if (x-x0==0)  x=x0+0.1;    &lt;/p&gt;
&lt;p&gt;               bt=2*Math.atan(l/r);&lt;/p&gt;
&lt;p&gt;               th=Math.atan((y-y0)/(x-x0));&lt;/p&gt;
&lt;p&gt;               m=r*Math.sin(bt);&lt;/p&gt;
&lt;p&gt;               x=s*m*Math.cos(th)+x0;&lt;/p&gt;
&lt;p&gt;               y=s*m*Math.sin(th)+y0; &lt;/p&gt;
&lt;p&gt;            }&lt;/p&gt;
&lt;p&gt;            if (i==0)&lt;/p&gt;
&lt;p&gt;              context.moveTo(x,y);&lt;/p&gt;
&lt;p&gt;            else&lt;/p&gt;
&lt;p&gt;              context.lineTo(x,y);&lt;/p&gt;
&lt;p&gt;          }&lt;/p&gt;
&lt;p&gt;          context.stroke();&lt;/p&gt;
&lt;p&gt;       }&lt;/p&gt;
&lt;p&gt;  }&lt;/p&gt;
&lt;p&gt;&amp;lt;/script&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/head&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;body onload=&quot;draw('myCanvas');&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;canvas id=&quot;myCanvas&quot; width=&quot;320&quot; height=&quot;320&quot;&amp;gt;&amp;lt;/canvas&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/body&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/html&amp;gt;&lt;/p&gt;
&lt;p&gt;在浏览器中打开包含这段HTML代码的html文件，可以看到在画布中绘制出如图3所示的图形放大镜效果1。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1485495/202006/1485495-20200625080454024-582811047.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt; &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图3  图形放大镜效果1&lt;/p&gt;
&lt;p&gt;      上面程序中语句var r=140;、var x0=160;和var y0=160;用于设置放大镜的圆心坐标和半径。若修改r=100，x0=100，y0=100，则在画布中绘制出如图4所示的图形放大镜效果2。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485495/202006/1485495-20200625080513112-943923506.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt; &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图4  图形放大镜效果2&lt;/p&gt;
</description>
<pubDate>Thu, 25 Jun 2020 00:06:00 +0000</pubDate>
<dc:creator>aTeacher</dc:creator>
<og:description>1. 基本四瓣花型图案 根据四瓣花卉线的参数方程： t= r*(1+sin(12*θ)/5)*(0.5+sin(4*θ)/2); x=t*cos(θ)); y=t*sin(θ)); 编写如下的HTML</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cs-whut/p/13191030.html</dc:identifier>
</item>
<item>
<title>NFC芯片选型及基本电路框架 - while（1）；</title>
<link>http://www.cnblogs.com/CYP01/p/13191019.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CYP01/p/13191019.html</guid>
<description>&lt;p&gt;RFID作为一项专业度较高的技术，在一些公司，可能还会专门招聘专业的RFID工程师。本篇阐述的涉及到的只是基本选型设计、电路框架，关于RFID天线调试、低功耗检卡调试等，后续再其他篇章会继续更新！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/456919/202006/456919-20200625074150044-502306398.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;NFC(Near Field Communication)芯片选型：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;主要考量点：&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;芯片支持的协议、是否支持低功耗检卡、是否能过金融认证、芯片价格&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;strong&gt;芯片支持协议：&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;6&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;ISO14443A/B、ISO15693、 ISO18092 和 ISO21481 等&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;ISO14443A 卡：Mifare 系列、 Ultralight 系列、 Plus 系列、 CPU 卡系列等。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;ISO14443B 卡：身份证、 SR176、 SRI512 等。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;ISO15693：NXP 的 ICODE 系列、 TI 的 Tag_it HF-I、 ST LRI 等。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;em&gt;ISO18092：&lt;/em&gt;包括读卡模式、卡模式、点对点通信模式。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;ISO21481：在 ISO18092 基础上兼容 ISO15693 协议。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;LPCD 功能：芯片低功耗检测卡片功能。没有卡片靠近时，芯片处于低功耗状态， 仅需10uA 电流，就能完成卡片侦测， 当卡片靠近时，芯片侦测到卡片，唤醒单片机读卡。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;金融认证：PBOC2.0/3.0 标准、 EMV 标准&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;电路架构：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;NFC芯片外部电路通常由以下几个部分组成：供电电路、通信接口电路、天线电路、振荡电路；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;供电电路：&lt;/strong&gt;主要包括模拟电源AVDD、数字电源DVDD、发射器电源TVDD、引脚电源PVDD、测试引脚电源PVDD2；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;a.&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;/strong&gt;如果需要提高发射功率可提高TVDD的电压，例如5V供电的TVDD形成的发射功率会比3V的要强；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;b. &lt;/strong&gt;芯片的供电电流通常在几十到几百mA，主要的能量消耗在发射器的电路上。例如FM175xx的天线发射电流在100mA，RC663则可以达250mA，因此选择供电芯片、电感器件时，需要注意留足余量；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;c.&lt;/strong&gt;读卡芯片天线13.56MHz的正弦波信号会干扰电源，为减少传导干扰，可以在电源端加π型滤波器，但为减少电路设计冗余度，一般情况下不添加。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;通信接口：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通常都支持SPI/I2C/UART，一般通过外部引脚配置选择，为方便升级，可做兼容设计；&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;天线设计：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;天线电路主要由4部分组成：EMC滤波、匹配电路、天线、接收电路。以FM17550为例，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/456919/202006/456919-20200625074136624-1735849751.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;滤波电路：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由L1、C1组成的低通滤波器用于滤除13.56MHz的衍生谐波，该滤波器截止频率应设计在14MHz以上。L1电感不可靠近摆放，以免互相干扰(互感效应)。滤波电路元件匹配公式：f=1/(2π√LC)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;匹配电路：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用于调节发射负载和谐振频率。射频电路功率受芯片内阻和外阻抗影响，当芯片内阻和外阻抗一致时，发射功率效率最高。C2是负载电容，天线感量越大，C2取值越小。C3是谐振电容，取值和天线电感量直接相关，使得谐振频率在13.56MHz。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;接收电路：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;C4滤除直流信号，R2和R3组成分压电路，使得RX接收端正弦波信号幅度在1.5-3V之间。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;天线：&lt;/strong&gt;&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;6.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;由R1电阻(通常是1ohm或0ohm)和印制PCB组成。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;天线越大，读卡距离越远，当天线面积达到5cm x 5cm以后，再增大天线，读卡距离没有明显提升。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;天线线宽建议选择0.5mm - 1mm。天线大于5cm x 5cm不能多于3圈，小于3cm x 3cm不能小于4圈&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;为减小EMC辐射干扰，需要将PCB走线转角处画成圆弧。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;天线区域内和天线边缘禁止将信号、电源、地线画成圈或者半圆，天线圈内不可有大面积金属物体、金属镀膜，避免引起磁场涡流效应造成能力严重损耗。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;天线PCB绕线方式是相对的，不是同向。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;天线电路设计元件的精度应控制在2%以内，否则容易导致天线谐振频点偏差，导致读卡性能严重下降，产品一致性难以保证&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;天线大小和读卡距离关系&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/456919/202006/456919-20200625074215523-2110182545.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 24 Jun 2020 23:45:00 +0000</pubDate>
<dc:creator>while（1）；</dc:creator>
<og:description>RFID作为一项专业度较高的技术，在一些公司，可能还会专门招聘专业的RFID工程师。本篇阐述的涉及到的只是基本选型设计、电路框架，关于RFID天线调试、低功耗检卡调试等，后续再其他篇章会继续更新！ N</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/CYP01/p/13191019.html</dc:identifier>
</item>
<item>
<title>【Spring注解驱动开发】关于BeanPostProcessor后置处理器，你了解多少？ - 冰河团队</title>
<link>http://www.cnblogs.com/binghe001/p/13190768.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/binghe001/p/13190768.html</guid>
<description>&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;blockquote readability=&quot;9.3650793650794&quot;&gt;
&lt;p&gt;有些小伙伴问我，学习Spring是不是不用学习到这么细节的程度啊？感觉这些细节的部分在实际工作中使用不到啊，我到底需不需要学习到这么细节的程度呢？我的答案是：有必要学习到这么细节的程度，而且是有机会、有条件一定要学！吃透Spring的原理和源码！往往拉开人与人之间差距的就是这些细节的部分，当前只要是使用Java技术栈开发的Web项目，几乎都会使用Spring框架。而且目前各招聘网站上对于Java开发的要求几乎清一色的都是熟悉或者精通Spring。所以，你，很有必要学习Spring的细节知识点。&lt;/p&gt;
&lt;p&gt;项目工程源码已经提交到GitHub：&lt;a href=&quot;https://github.com/sunshinelyz/spring-annotation&quot;&gt;https://github.com/sunshinelyz/spring-annotation&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;beanpostprocessor后置处理器概述&quot;&gt;BeanPostProcessor后置处理器概述&lt;/h2&gt;
&lt;p&gt;首先，我们来看下BeanPostProcessor的源码，看下它到底是个什么鬼，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package org.springframework.beans.factory.config;
import org.springframework.beans.BeansException;
import org.springframework.lang.Nullable;
public interface BeanPostProcessor {
        @Nullable
        default Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
                return bean;
        }
        @Nullable
        default Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
                return bean;
        }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从源码可以看出：BeanPostProcessor是一个接口，其中有两个方法，postProcessBeforeInitialization和postProcessAfterInitialization两个方法，这两个方法分别是在spring容器中的bean初始化前后执行，所以spring容器中的每一个bean对象初始化前后，都会执行BeanPostProcessor接口的实现类的这两个方法。&lt;/p&gt;
&lt;p&gt;也就是说，&lt;strong&gt;postProcessBeforeInitialization方法会在bean实例化和属性设置之后，自定义初始化方法之前被调用，而postProcessAfterInitialization方法会在自定义初始化方法之后被调用。当容器中存在多个BeanPostProcessor的实现类时，会按照它们在容器中注册的顺序执行。对于自定义BeanPostProcessor实现类，还可以让其实现Ordered接口自定义排序。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因此我们可以在每个bean对象初始化前后，加上自己的逻辑。实现方式：自定义一个BeanPostProcessor接口的实现类MyBeanPostProcessor，然后在类MyBeanPostProcessor的postProcessBeforeInitialization和postProcessAfterInitialization方法里面写上自己的逻辑。&lt;/p&gt;
&lt;h2 id=&quot;beanpostprocessor后置处理器实例&quot;&gt;BeanPostProcessor后置处理器实例&lt;/h2&gt;
&lt;p&gt;我们创建一个MyBeanPostProcessor类，实现BeanPostProcessor接口，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package io.mykit.spring.plugins.register.bean;

import org.springframework.beans.BeansException;
import org.springframework.beans.factory.config.BeanPostProcessor;
import org.springframework.stereotype.Component;

/**
 * @author binghe
 * @version 1.0.0
 * @description 测试BeanPostProcessor
 */
@Component
public class MyBeanPostProcessor implements BeanPostProcessor {

    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        System.out.println(&quot;调用了postProcessBeforeInitialization方法，beanName = &quot; + beanName + &quot;, bean = &quot; + bean);
        return bean;
    }

    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        System.out.println(&quot;调用了postProcessAfterInitialization，beanName = &quot; + beanName + &quot;, bean = &quot; + bean);
        return bean;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来，我们运行BeanLifeCircleTest类的testBeanLifeCircle04()方法，输出的结果信息如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;调用了postProcessBeforeInitialization方法，beanName = animalConfig, bean = io.mykit.spring.plugins.register.config.AnimalConfig$$EnhancerBySpringCGLIB$$e8ab4f2e@56528192
调用了postProcessAfterInitialization，beanName = animalConfig, bean = io.mykit.spring.plugins.register.config.AnimalConfig$$EnhancerBySpringCGLIB$$e8ab4f2e@56528192
Cat类的构造方法...
调用了postProcessBeforeInitialization方法，beanName = cat, bean = io.mykit.spring.plugins.register.bean.Cat@1b1473ab
Cat的postConstruct()方法...
Cat的init()方法...
调用了postProcessAfterInitialization，beanName = cat, bean = io.mykit.spring.plugins.register.bean.Cat@1b1473ab
Cat的preDestroy()方法...
Cat的destroy()方法...
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，postProcessBeforeInitialization方法会在bean实例化和属性设置之后，自定义初始化方法之前被调用，而postProcessAfterInitialization方法会在自定义初始化方法之后被调用。&lt;/p&gt;
&lt;p&gt;也可以让实现Ordered接口自定义排序，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package io.mykit.spring.plugins.register.bean;

import org.springframework.beans.BeansException;
import org.springframework.beans.factory.config.BeanPostProcessor;
import org.springframework.core.Ordered;
import org.springframework.stereotype.Component;

/**
 * @author binghe
 * @version 1.0.0
 * @description 测试BeanPostProcessor
 */
@Component
public class MyBeanPostProcessor implements BeanPostProcessor, Ordered {

    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        System.out.println(&quot;调用了postProcessBeforeInitialization方法，beanName = &quot; + beanName + &quot;, bean = &quot; + bean);
        return bean;
    }

    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        System.out.println(&quot;调用了postProcessAfterInitialization，beanName = &quot; + beanName + &quot;, bean = &quot; + bean);
        return bean;
    }

    @Override
    public int getOrder() {
        return 3;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再次运行BeanLifeCircleTest类的testBeanLifeCircle04()方法，输出的结果信息如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;调用了postProcessBeforeInitialization方法，beanName = animalConfig, bean = io.mykit.spring.plugins.register.config.AnimalConfig$$EnhancerBySpringCGLIB$$b045438a@1ed1993a
调用了postProcessAfterInitialization，beanName = animalConfig, bean = io.mykit.spring.plugins.register.config.AnimalConfig$$EnhancerBySpringCGLIB$$b045438a@1ed1993a
Cat类的构造方法...
调用了postProcessBeforeInitialization方法，beanName = cat, bean = io.mykit.spring.plugins.register.bean.Cat@36c88a32
Cat的postConstruct()方法...
Cat的init()方法...
调用了postProcessAfterInitialization，beanName = cat, bean = io.mykit.spring.plugins.register.bean.Cat@36c88a32
Cat的preDestroy()方法...
Cat的destroy()方法...
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;beanpostprocessor后置处理器作用&quot;&gt;BeanPostProcessor后置处理器作用&lt;/h2&gt;
&lt;p&gt;后置处理器用于bean对象初始化前后进行逻辑增强。spring提供了BeanPostProcessor的很多实现类，例如AutowiredAnnotationBeanPostProcessor用于@Autowired注解的实现，AnnotationAwareAspectJAutoProxyCreator用于SpringAOP的动态代理等等。&lt;/p&gt;
&lt;p&gt;除此之外，我们还可以自定义BeanPostProcessor的实现类，在其中写入需要的逻辑。下面以AnnotationAwareAspectJAutoProxyCreator为例，说明后置处理器是怎样工作的。我们都知道springAOP的实现原理是动态代理，最终放入容器的是代理类的对象，而不是bean本身的对象，那么spring是什么时候做到这一步的？就是在AnnotationAwareAspectJAutoProxyCreator后置处理器的postProcessAfterInitialization方法，即bean对象初始化完成之后，后置处理器会判断该bean是否注册了切面，如果是，则生成代理对象注入容器。Spring中的关键代码如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
  * Create a proxy with the configured interceptors if the bean is
  * identified as one to proxy by the subclass.
  * @see #getAdvicesAndAdvisorsForBean
  */
@Override
public Object postProcessAfterInitialization(@Nullable Object bean, String beanName) {
    if (bean != null) {
        Object cacheKey = getCacheKey(bean.getClass(), beanName);
        if (this.earlyProxyReferences.remove(cacheKey) != bean) {
            return wrapIfNecessary(bean, beanName, cacheKey);
        }
    }
    return bean;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;好了，咱们今天就聊到这儿吧！别忘了给个在看和转发，让更多的人看到，一起学习一起进步！！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;2.3333333333333&quot;&gt;
&lt;p&gt;项目工程源码已经提交到GitHub：&lt;a href=&quot;https://github.com/sunshinelyz/spring-annotation&quot;&gt;https://github.com/sunshinelyz/spring-annotation&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;写在最后&quot;&gt;写在最后&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;如果觉得文章对你有点帮助，请微信搜索并关注「 &lt;strong&gt;冰河技术&lt;/strong&gt; 」微信公众号，跟冰河学习Spring注解驱动开发。公众号回复“spring注解”关键字，领取Spring注解驱动开发核心知识图，让Spring注解驱动开发不再迷茫。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p align=&quot;right&quot;&gt;部分参考：https://www.cnblogs.com/dubhlinn/p/10668156.html&lt;/p&gt;
</description>
<pubDate>Wed, 24 Jun 2020 16:01:00 +0000</pubDate>
<dc:creator>冰河团队</dc:creator>
<og:description>写在前面 有些小伙伴问我，学习Spring是不是不用学习到这么细节的程度啊？感觉这些细节的部分在实际工作中使用不到啊，我到底需不需要学习到这么细节的程度呢？我的答案是：有必要学习到这么细节的程度，而且</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/binghe001/p/13190768.html</dc:identifier>
</item>
<item>
<title>Docker部署Python项目 - you-men</title>
<link>http://www.cnblogs.com/you-men/p/13190758.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/you-men/p/13190758.html</guid>
<description>&lt;h4 id=&quot;简介&quot;&gt;简介&lt;/h4&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;软件开发最大的麻烦事之一就是环境配置，操作系统设置，各种库和组件的安装。只有它们都正确，软件才能运行。如果从一种操作系统里面运行另一种操作系统，通常我们采取的策略就是引入虚拟机，比如在 Windows 系统里面运行 Linux 系统。这种方式有个很大的缺点就是资源占用多、冗余步骤多、启动慢。目前最流行的 Linux 容器解决方案之一就是Docker，它最大优点就是轻量、资源占用少、启动快。本文从什么是Docker？Docker解决什么问题？有哪些好处？如何去部署实现去全面介绍。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;docker部署项目优势&quot;&gt;docker部署项目优势&lt;/h5&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;设想这样一个真实案例，假如我们要部署一个Python应用程序，要做哪些工作？首先需要python运行环境，比如部署的是python3，而机器上是python2。先装个python3，还要装各种依赖包，机器一些可能的冲突。装完python之后，发现还要装mysql或者redis。继续下载安装配置。啥？服务器不用了，需要换一台服务器？那重新来一遍吧。啥？基础应用做的太好要进行推广，需要指导其他厂商部署？这怎么办？可以看出，在 Docker 之前软件行业的运维存在着以下这些痛点:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 1. 软件的发布和部署低效又繁琐，而且总是需要人工介入
# 2. 环境的一致性难移保证
# 3. 在不同环境之间迁移的成本较高
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;在完成Docker部署安装之前，我们还是先认识下Docker的优点:&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 1. 软件构建容易，分发简单
# 2. 应用得到隔离，依赖被解除
# 3. 可以完美地用于 CI/CD
# 4. 快速部署，测试完以后销毁也方便
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;方式一-基于python基础镜像&quot;&gt;方式一: 基于Python基础镜像&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 准备数据目录
mkdir myproject
cd myproject
docker run -di --name=myproject -p 8080:8080 -v /home/myproject:/home python:3.6

# 将你的项目上传到服务器挂载的存储卷上
scp django.tar.gz 149.129.38.117:
cp /root/django.tar.gz /home/myproject/
tar xvf django.tar.gz

# 进入容器安装相关依赖
pip install -r requirement.txt
apt-get update
apt-get install vi

# setting.py 改成下面
ALLOWED_HOSTS = ['*']
# 运行项目(wsgiref)
python manage.py runserver 0.0.0.0:8080
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;uwsgi运行项目&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;pip3 install uwsgi

# 在项目根路径下创建一个uwsgi.ini 文件，写入

[uwsgi]
#配置和nginx连接的socket连接
socket=0.0.0.0:8080
#也可以使用http
#http=0.0.0.0:8080
#配置项目路径，项目的所在目录
chdir=/home/django_test
#配置wsgi接口模块文件路径
wsgi-file=django_test/wsgi.py
#配置启动的进程数
processes=4
#配置每个进程的线程数
threads=2
#配置启动管理主进程
master=True
#配置存放主进程的进程号文件
pidfile=uwsgi.pid
#配置dump日志记录
daemonize=uwsgi.log


#启动，停止，重启，查看
uwsgi --ini uwsgi.ini #启动
lsof -i :8001    #按照端口号查询
ps aux | grep uwsgi　　　#按照程序名查询
kill -9 13844       #杀死进程

uwsgi --stop uwsgi.pid      #通过uwsg停止uwsgi
uwsgi --reload uwsgi.pid  #重启

# nginx转发

mkdir -p nginx/conf nginx/html nginx/logs

# 在conf目录下新建nginx.conf

worker_processes  1;
events {
    worker_connections  1024;
}
http {
    include       mime.types;
    default_type  application/octet-stream;
    sendfile        on;
    keepalive_timeout  65;
    server {
        listen       80;
        server_name  localhost;
        location / {
          #uwsgi_pass 149.129.38.117:8080;
          proxy_pass http://149.129.38.117:8080;
        }  
        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }
    }
}

docker run --name nginx -id -p 80:80 -v /home/nginx/conf/nginx.conf:/etc/nginx/nginx.conf -v /home/nginx/html:/etc/nginx/html -v /home/nginx/logs:/var/log/nginx nginx

# 在 python的docker中用uwsgi跑起项目来即可

# 外部访问：http://149.129.38.117/
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 24 Jun 2020 15:59:00 +0000</pubDate>
<dc:creator>you-men</dc:creator>
<og:description>简介 软件开发最大的麻烦事之一就是环境配置，操作系统设置，各种库和组件的安装。只有它们都正确，软件才能运行。如果从一种操作系统里面运行另一种操作系统，通常我们采取的策略就是引入虚拟机，比如在 Wind</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/you-men/p/13190758.html</dc:identifier>
</item>
<item>
<title>Linux-权限详解 - Jet丶Bi</title>
<link>http://www.cnblogs.com/qq1207501666/p/13190725.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qq1207501666/p/13190725.html</guid>
<description>&lt;p&gt;我们总说Linux系统是相对安全可靠的，这与Linux系统有着严格的权限管理这一点是密不可分的。关于权限方面Linux有很多限制机制，包括我们常说的文件基本权限&lt;code&gt;rwx&lt;/code&gt;, 访问控制权限&lt;code&gt;ACL&lt;/code&gt;还有美国国防部参与开发的极为复杂的&lt;code&gt;SELINUX&lt;/code&gt; 等 。不过我们最常用的，也必须掌握的就是这个文件的基本权限了。如果权限过高会增加服务器的风险。所以对于了解各种权限以及给用户、文件分配合理的权限十分重要！&lt;/p&gt;

&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# ls -l 命令的第一列
[root@God /]# ls -l
lrwxrwxrwx.   1 root root    7 Jun 21 11:20 bin -&amp;gt; usr/bin
drwxr-xr-x.  76 root root 8192 Jun 24 19:51 etc
drwxrwxrwt.   8 root root  283 Jun 24 19:53 tmp
...

# stat 命令查看
[root@God /]# stat -c %A /
dr-xr-xr-x
[root@God /]# stat -c %a /
555
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# 解释一下这一串字符串的意思
# drwxr-xr-x
# 0123456789

# 第 0 位: 代表文件类型,常用的有 - 普通文件  d 目录  l 软链接(快捷方式)等  
# 第123位: 代表文件所属用户(u表示)的 rwx 权限
# 第456位: 代表文件所属组用户(g表示)的 rwx 权限
# 第789为: 代表其他用户(o表示)的 rwx 权限

# -   代表无此项权限
# r=4 代表读权限
# w=2 代表写权限
# x=1 代表可执行权限

# 7 = 4 + 2 + 1 即代表拥有读、写、可执行权限
# 6 = 4 + 2     即代表拥有读、写权限
# 5 = 4 + 1     即代表拥有读、可执行权限
# 以此类推...
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li&gt;
&lt;p&gt;对于文件&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;r&lt;/code&gt; 表示可以读取文件中的内容&lt;/li&gt;
&lt;li&gt;&lt;code&gt;w&lt;/code&gt; 表示可以修改文件中的内容和文件的一些属性&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x&lt;/code&gt; 表示可以执行文件，普通用户还需要有&lt;code&gt;r&lt;/code&gt;权限才能正常执行&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于目录&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;r&lt;/code&gt; 表示可以查询目录下的内容&lt;/li&gt;
&lt;li&gt;&lt;code&gt;w&lt;/code&gt; 表示可以修改目录结构的权限，如新建文件或目录，删除文件或目录等&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x&lt;/code&gt; 目录没有执行一说，所以&lt;code&gt;x&lt;/code&gt;表示可以进入目录&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;删除文件、修改文件名的权限是受父目录的&lt;code&gt;w&lt;/code&gt;权限控制的，和文件自身的权限无关&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;root&lt;/code&gt;用户对所有文件和目录具有&lt;code&gt;r&lt;/code&gt;读权限&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;root&lt;/code&gt;用户对所有目录具有&lt;code&gt;x&lt;/code&gt;可执行权限，即进入目录的权限&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;root&lt;/code&gt;用户可以更改所有文件或目录的&lt;code&gt;r&lt;/code&gt; &lt;code&gt;w&lt;/code&gt; &lt;code&gt;x&lt;/code&gt;权限&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;chmod&lt;/code&gt;命令可用于更改文件的&lt;code&gt;r&lt;/code&gt;读、&lt;code&gt;w&lt;/code&gt;写、&lt;code&gt;x&lt;/code&gt;执行权限&lt;/p&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;语法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;chmod [选项] rwx的权限分值 文件或目录
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;权限分值 r=4, w=2, x=1&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;chmod [选项] 身份标识(+|-)(r|w|x) 文件或目录
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;身份标识 u=user所属用户 , g=group所属组, o=other其他用户, a=all(u+g+o)所有用户&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;选项&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;-R&lt;/code&gt; 递归处理，将指定目录下所有文件及子目录一并处理&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# 更改文件/local/myscript.sh的权限
# 文件拥有者权限=7(r+w+x) 同组用户权限=5(r+x) 其他用户权限=5(r+x)
chmod 755 /local/myscript.sh

# 去掉其他用户对文件/local/myscript.sh的写权限
chmod o-w /local/myscript.sh

# 去掉其他用户对文件/local/myscript.sh的写权限,给同组用户加上执行权限
chmod o-w,g+x /local/myscript.sh

# 更改目录/local的权限
chmod -R 754 /local
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Linux下创建文件和目录时会有一个默认的权限，一般来讲，我们认为相对安全的权限值为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;文件 &lt;code&gt;644&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;目录 &lt;code&gt;755&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;[root@God ~]# touch testfile
[root@God ~]# stat -c %a testfile
644
[root@God ~]# mkdir testdir
[root@God ~]# stat -c %a testdir/
755
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么为什么默认的权限值会是这样的呢？就是因为&lt;code&gt;umask&lt;/code&gt;权限掩码决定的！下面就好好讲一下这个&lt;code&gt;umask&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# 查看umask值
[root@God ~]# umask
0022

# 设置umask值，临时设置，仅针对本次会话
[root@God dir2]# umask 0011
[root@God dir2]# umask
0011

# 永久修改-全局设置-针对所有用户 修改 /etc/profile 文件
# 永久修改-针对当前用户 在 ~/.bashrc 文件设置
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先，我们先来了解一下什么是&lt;code&gt;最大权限值&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;用户创建文件，因为文件有&lt;code&gt;x&lt;/code&gt;权限“很危险”，则不给&lt;code&gt;x&lt;/code&gt;执行权限，所以文件默认的&lt;code&gt;最大权限值&lt;/code&gt;为&lt;code&gt;666&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;用户创建目录，则由于&lt;code&gt;x&lt;/code&gt;权限与是否可以进入目录有关，即默认&lt;code&gt;最大的权限值&lt;/code&gt;为&lt;code&gt;777&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;umask&lt;/code&gt;的系统默认值是&lt;code&gt;0022&lt;/code&gt; 说一下&lt;code&gt;0022&lt;/code&gt;的第一位数&lt;code&gt;0&lt;/code&gt;，网上有百分之八十的文章都说是表示的特殊权限或粘滞位，然后说一般不予考虑。屁！你倒是考虑考虑啊，我是搜了很多资料，也没找到到底怎么使用(如果谁知道怎么用，请告诉我 = =)。其实，&lt;code&gt;umask&lt;/code&gt;的本质就是一个不大于十进制512的八进制数字，所以第一位只能是&lt;code&gt;0&lt;/code&gt;,至于为什么是不大于512? 你去换算一下十进制511的八进制数是多少……是不是感觉瞬间就明白了？而且，你如果设置&lt;code&gt;umask&lt;/code&gt;的第一位不等于&lt;code&gt;0&lt;/code&gt;时，会报错，而这个错的意思就是八进制越界！&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;[root@God dir2]# umask 1000
-bash: umask: 1000: octal number out of range
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以我们只看后三位&lt;code&gt;022&lt;/code&gt;,我们用十进制算法用&lt;code&gt;最大权限值&lt;/code&gt;去对应着位置去减，就得到了文件或目录的默认权限&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;文件 &lt;code&gt;666 - 022 = 6-0 6-2 6-2 = 644&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;目录 &lt;code&gt;777 - 022 = 7-0 7-2 7-2 = 755&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;那么有人(对，没错，就是我！)会问了，如果设置&lt;code&gt;umask&lt;/code&gt;中的值有&lt;code&gt;1&lt;/code&gt;,&lt;code&gt;3&lt;/code&gt;或&lt;code&gt;5&lt;/code&gt;，比如&lt;code&gt;0035&lt;/code&gt;那按照这个算法，则文件默认不就有执行权限了么，岂不&quot;很危险&quot;?&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;文件 &lt;code&gt;666 - 035 = 6-0 6-3 6-5 = 631&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对！所以,当文件根据&lt;code&gt;umask&lt;/code&gt;计算默认权限时,如果遇到奇数，那么就会给这个数自动加&lt;code&gt;1&lt;/code&gt;。也就意味着你无论&lt;code&gt;umask&lt;/code&gt;的值设置为多少，新建的文件默认都不会有执行权限的！是不是很哇塞？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;文件 &lt;code&gt;666 - 035 = 6-0 6-3 6-5 = 63(+1)1(+1) = 642&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;​&lt;/p&gt;
</description>
<pubDate>Wed, 24 Jun 2020 15:49:00 +0000</pubDate>
<dc:creator>Jet丶Bi</dc:creator>
<og:description>简介 我们总说Linux系统是相对安全可靠的，这与Linux系统有着严格的权限管理这一点是密不可分的。关于权限方面Linux有很多限制机制，包括我们常说的文件基本权限rwx, 访问控制权限ACL还有美</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qq1207501666/p/13190725.html</dc:identifier>
</item>
<item>
<title>Quartz.Net系列（九）：Trigger之DailyTimeIntervalScheduleBuilder详解 - IT技术派</title>
<link>http://www.cnblogs.com/vic-tory/p/13190671.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/vic-tory/p/13190671.html</guid>
<description>&lt;h2&gt;1.介绍&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;中文意义就是每日时间间隔计划生成&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;2.API讲解&lt;/h2&gt;
&lt;h3&gt;&lt;strong&gt;(1)WithInterval、&lt;/strong&gt;WithIntervalInHours、&lt;strong&gt;WithIntervalInMinutes、&lt;/strong&gt;WithIntervalInSeconds&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;WithInterval：指定要生成触发器的时间单位和间隔。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;WithIntervalInHours：&lt;/strong&gt;指定要生成触发器的间隔按小时来&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;WithIntervalInMinutes：&lt;/strong&gt;&lt;strong&gt;指定要生成触发器的间隔按分钟来&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;WithIntervalInSeconds：&lt;/strong&gt;&lt;strong&gt;指定要生成触发器的间隔按秒来&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;和前面的SimpleSceduleBuilder、CalendarIntervalScheduleBuilder一样的&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;(2)OnDaysOfTheWeek、OnMondayThroughFriday、OnSaturdayAndSunday、OnEveryDay&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;OnDaysOfTheWeek：设置触发器一周中的哪几天&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;OnMondayThroughFriday：从星期一到星期五&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;OnSaturdayAndSunday：周六和周日&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;OnEveryDay：每天&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;每天10:00到23:10.00的每一分钟执行一次&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;var&lt;/span&gt; trigger =&lt;span&gt; TriggerBuilder.Create().WithDailyTimeIntervalSchedule(
                  w &lt;/span&gt;=&amp;gt; w.OnEveryDay() &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置每天&lt;/span&gt;
                      .StartingDailyAt(TimeOfDay.HourAndMinuteOfDay(&lt;span&gt;10&lt;/span&gt;, &lt;span&gt;00&lt;/span&gt;)) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置每天开始于几点&lt;/span&gt;
                      .EndingDailyAt(TimeOfDay.HourMinuteAndSecondOfDay(&lt;span&gt;23&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;)) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置每日结束于几点&lt;/span&gt;
                      .WithIntervalInMinutes(&lt;span&gt;1&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;间隔分钟&lt;/span&gt;
                ).Build();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一周当中的星期二和星期三每秒执行一次&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
            List&amp;lt;DayOfWeek&amp;gt; dayOfWeeks = &lt;span&gt;new&lt;/span&gt; List&amp;lt;DayOfWeek&amp;gt;&lt;span&gt;();

            dayOfWeeks.Add(DayOfWeek.Wednesday);

            dayOfWeeks.Add(DayOfWeek.Tuesday);

            trigger &lt;/span&gt;=&lt;span&gt; TriggerBuilder.Create().WithDailyTimeIntervalSchedule(
                 w&lt;/span&gt;=&amp;gt;w.OnDaysOfTheWeek(dayOfWeeks)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;.OnDaysOfTheWeek(new DayOfWeek[2] { DayOfWeek.Wednesday,DayOfWeek.Tuesday})&lt;/span&gt;
                     .WithIntervalInSeconds(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
                ).Build();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1699002/202006/1699002-20200624231454351-1825034487.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;&lt;span&gt; 源码实现&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Set the trigger to fire on the given days of the week.
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;onDaysOfWeek&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;a Set containing the integers representing the days of the week, defined by &lt;/span&gt;&lt;span&gt;&amp;lt;see cref=&quot;DayOfWeek.Sunday&quot;/&amp;gt;&lt;/span&gt;&lt;span&gt; - &lt;/span&gt;&lt;span&gt;&amp;lt;see cref=&quot;DayOfWeek.Saturday&quot;/&amp;gt;&lt;/span&gt;&lt;span&gt;.
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;&lt;span&gt;the updated DailyTimeIntervalScheduleBuilder&lt;/span&gt;&lt;span&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; DailyTimeIntervalScheduleBuilder OnDaysOfTheWeek(IReadOnlyCollection&amp;lt;DayOfWeek&amp;gt;&lt;span&gt; onDaysOfWeek)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (onDaysOfWeek == &lt;span&gt;null&lt;/span&gt; || onDaysOfWeek.Count == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ArgumentException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Days of week must be an non-empty set.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }

            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (DayOfWeek day &lt;span&gt;in&lt;/span&gt;&lt;span&gt; onDaysOfWeek)
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;AllDaysOfTheWeek.Contains(day))
                {
                    &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ArgumentException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Invalid value for day of week: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; day);
                }
            }

            daysOfWeek &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; HashSet&amp;lt;DayOfWeek&amp;gt;&lt;span&gt;(onDaysOfWeek);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Set the trigger to fire on the given days of the week.
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;onDaysOfWeek&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;a variable length list of week days representing the days of the week&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;&lt;span&gt;the updated DailyTimeIntervalScheduleBuilder&lt;/span&gt;&lt;span&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; DailyTimeIntervalScheduleBuilder OnDaysOfTheWeek(&lt;span&gt;params&lt;/span&gt;&lt;span&gt; DayOfWeek[] onDaysOfWeek)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; OnDaysOfTheWeek((IReadOnlyCollection&amp;lt;DayOfWeek&amp;gt;&lt;span&gt;) onDaysOfWeek);
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Set the trigger to fire on the days from Monday through Friday.
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;&lt;span&gt;the updated DailyTimeIntervalScheduleBuilder&lt;/span&gt;&lt;span&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; DailyTimeIntervalScheduleBuilder OnMondayThroughFriday()
        {
            daysOfWeek &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; HashSet&amp;lt;DayOfWeek&amp;gt;&lt;span&gt;(MondayThroughFriday);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Set the trigger to fire on the days Saturday and Sunday.
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;&lt;span&gt;the updated DailyTimeIntervalScheduleBuilder&lt;/span&gt;&lt;span&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; DailyTimeIntervalScheduleBuilder OnSaturdayAndSunday()
        {
            daysOfWeek &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; HashSet&amp;lt;DayOfWeek&amp;gt;&lt;span&gt;(SaturdayAndSunday);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Set the trigger to fire on all days of the week.
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;&lt;span&gt;the updated DailyTimeIntervalScheduleBuilder&lt;/span&gt;&lt;span&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; DailyTimeIntervalScheduleBuilder OnEveryDay()
        {
            daysOfWeek &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; HashSet&amp;lt;DayOfWeek&amp;gt;&lt;span&gt;(AllDaysOfTheWeek);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;(3)StartingDailyAt、EndingDailyAt&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;StartingDailyAt：开始时间于&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;EndingDailyAt：结束时间于&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;源码实现&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; The TimeOfDay for this trigger to start firing each day.
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;timeOfDayUtc&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;&lt;span&gt;the updated DailyTimeIntervalScheduleBuilder&lt;/span&gt;&lt;span&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; DailyTimeIntervalScheduleBuilder StartingDailyAt(TimeOfDay timeOfDayUtc)
        {
            startTimeOfDayUtc &lt;/span&gt;= timeOfDayUtc ?? &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ArgumentException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Start time of day cannot be null!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; The TimeOfDay for this trigger to end firing each day.
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;timeOfDayUtc&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;&lt;span&gt;the updated DailyTimeIntervalScheduleBuilder&lt;/span&gt;&lt;span&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; DailyTimeIntervalScheduleBuilder EndingDailyAt(TimeOfDay timeOfDayUtc)
        {
            endTimeOfDayUtc &lt;/span&gt;=&lt;span&gt; timeOfDayUtc;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;(4)EndingDailyAfterCount&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;EndingDailyAfterCount:使用count、interval和StarTimeOfDay计算并设置EndTimeOfDay。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;源码实现&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
       &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Calculate and set the EndTimeOfDay using count, interval and StarTimeOfDay. This means
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt; that these must be set before this method is call.
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;count&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;&lt;span&gt;the updated DailyTimeIntervalScheduleBuilder&lt;/span&gt;&lt;span&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; DailyTimeIntervalScheduleBuilder EndingDailyAfterCount(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; count)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (count &amp;lt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ArgumentException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Ending daily after count must be a positive number!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (startTimeOfDayUtc == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ArgumentException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;You must set the StartDailyAt() before calling this EndingDailyAfterCount()!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }

            DateTimeOffset today &lt;/span&gt;=&lt;span&gt; SystemTime.UtcNow();
            DateTimeOffset startTimeOfDayDate &lt;/span&gt;=&lt;span&gt; startTimeOfDayUtc.GetTimeOfDayForDate(today).Value;
            DateTimeOffset maxEndTimeOfDayDate &lt;/span&gt;= TimeOfDay.HourMinuteAndSecondOfDay(&lt;span&gt;23&lt;/span&gt;, &lt;span&gt;59&lt;/span&gt;, &lt;span&gt;59&lt;/span&gt;&lt;span&gt;).GetTimeOfDayForDate(today).Value;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;apply proper offsets according to timezone&lt;/span&gt;
            TimeZoneInfo targetTimeZone = timeZone ??&lt;span&gt; TimeZoneInfo.Local;
            startTimeOfDayDate &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DateTimeOffset(startTimeOfDayDate.DateTime, TimeZoneUtil.GetUtcOffset(startTimeOfDayDate.DateTime, targetTimeZone));
            maxEndTimeOfDayDate &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DateTimeOffset(maxEndTimeOfDayDate.DateTime, TimeZoneUtil.GetUtcOffset(maxEndTimeOfDayDate.DateTime, targetTimeZone));

            TimeSpan remainingMillisInDay &lt;/span&gt;= maxEndTimeOfDayDate -&lt;span&gt; startTimeOfDayDate;
            TimeSpan intervalInMillis;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (intervalUnit ==&lt;span&gt; IntervalUnit.Second)
            {
                intervalInMillis &lt;/span&gt;=&lt;span&gt; TimeSpan.FromSeconds(interval);
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (intervalUnit ==&lt;span&gt; IntervalUnit.Minute)
            {
                intervalInMillis &lt;/span&gt;=&lt;span&gt; TimeSpan.FromMinutes(interval);
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (intervalUnit ==&lt;span&gt; IntervalUnit.Hour)
            {
                intervalInMillis &lt;/span&gt;=&lt;span&gt; TimeSpan.FromHours(interval);
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ArgumentException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;The IntervalUnit: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + intervalUnit + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; is invalid for this trigger.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (remainingMillisInDay &amp;lt;&lt;span&gt; intervalInMillis)
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ArgumentException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;The startTimeOfDay is too late with given Interval and IntervalUnit values.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }

            &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; maxNumOfCount = remainingMillisInDay.Ticks /&lt;span&gt; intervalInMillis.Ticks;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (count &amp;gt;&lt;span&gt; maxNumOfCount)
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ArgumentException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;The given count &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + count + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; is too large! The max you can set is &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; maxNumOfCount);
            }

            TimeSpan incrementInMillis &lt;/span&gt;= TimeSpan.FromTicks((count - &lt;span&gt;1&lt;/span&gt;) *&lt;span&gt; intervalInMillis.Ticks);
            DateTimeOffset endTimeOfDayDate &lt;/span&gt;=&lt;span&gt; startTimeOfDayDate.Add(incrementInMillis);

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (endTimeOfDayDate &amp;gt;&lt;span&gt; maxEndTimeOfDayDate)
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ArgumentException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;The given count &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + count + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; is too large! The max you can set is &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; maxNumOfCount);
            }

            DateTime cal &lt;/span&gt;=&lt;span&gt; SystemTime.UtcNow().Date;
            cal &lt;/span&gt;=&lt;span&gt; cal.Add(endTimeOfDayDate.TimeOfDay);
            endTimeOfDayUtc &lt;/span&gt;=&lt;span&gt; TimeOfDay.HourMinuteAndSecondOfDay(cal.Hour, cal.Minute, cal.Second);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Wed, 24 Jun 2020 15:34:00 +0000</pubDate>
<dc:creator>IT技术派</dc:creator>
<og:description>1.介绍 中文意义就是每日时间间隔计划生成 2.API讲解 (1)WithInterval、WithIntervalInHours、WithIntervalInMinutes、WithInterval</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/vic-tory/p/13190671.html</dc:identifier>
</item>
<item>
<title>Java的前生今世 - 行人观学</title>
<link>http://www.cnblogs.com/xingrenguanxue/p/13190582.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xingrenguanxue/p/13190582.html</guid>
<description>&lt;p&gt;Java作为一门编程语言，自诞生以来已经流行了20多年，在学习它之前，我们有必要先了解一下它的历史。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;318&quot;&gt;
&lt;p&gt;Java作为一门编程语言，自诞生以来已经流行了20多年，在学习它之前，我们有必要先了解一下它的历史，了解它是如何一步步发展到今天这个样子。&lt;/p&gt;

&lt;p&gt;上世纪90年代，硬件领域出现了单片式计算机系统，比如电视机机顶盒这些消费设备。这些设备的特点是处理能力和内存都有限。如果使用C++编写程序，则对于这类设备来说过于庞大。&lt;/p&gt;
&lt;p&gt;所以需求便来了，为了适应这类设备，需要一种小型的计算机语言，Java便应运而生了。&lt;/p&gt;
&lt;p&gt;1991年，Sun公司的James Gosling, Mike Sheridan和Patrick Naughton发起了一个名为“Green”的项目小组，主要用于电视机顶盒这类消费设备。&lt;/p&gt;
&lt;p&gt;由于设备的处理能力和内存有限，所以要求&lt;strong&gt;语言短小、代码紧凑&lt;/strong&gt;。而对于电视机顶盒这类消费设备来说，厂商会选择各种不同的CPU，所以要求语言&lt;strong&gt;可移植、不与特定的平台捆绑在一起&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;Green项目组以C++为基础，对C++进行了一些改造，并删除了一些不太实用、复杂繁琐的东西，开发出了名为“Oak”的语言，（Oka来自James Gosling办公室外的橡树）。&lt;/p&gt;

&lt;h2 id=&quot;挫折&quot;&gt;挫折&lt;/h2&gt;
&lt;p&gt;1992年夏天，Green项目组已经能够演示Green操作系统、Oak的程序设计语言、类库和其硬件。&lt;/p&gt;
&lt;p&gt;1992年9月，Green项目组发布了它的第一个名为“Start 7”的产品，该产品是一个个人数字助理设备，具有图形界面和非常智能的远程控制。&lt;/p&gt;
&lt;p&gt;1992年11月，Green项目被剥离，成为Sun Microsystems的全资子公司Firstperson。&lt;/p&gt;
&lt;p&gt;但是当时的硬件生产厂商对其项目并不感兴趣，Firstperson花了一年多也没找到希望购买其技术的买家。&lt;/p&gt;
&lt;p&gt;1994年，First Person公司解散，被重新纳入Sun公司。Oak语言无法进入市场，也被暂时搁置下来。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200624230030571.jpg#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;机遇&quot;&gt;机遇&lt;/h2&gt;
&lt;p&gt;在上面的过程中，Internet的万维网也在不断发展。对于客户机/服务器模型来说，万维网需要做的是将超文本页面转换到屏幕的浏览器中。&lt;/p&gt;
&lt;p&gt;1994年6月到7月，Sun公司的团队看到了互联网的发展，一些图形Web浏览器的出现让他们认为互联网可以演变成他们为有线电视所设想的相同的高度交互性媒体。经过三天的头脑风暴后，该团队将目标平台重新定位为万维网平台。&lt;/p&gt;
&lt;p&gt;1994年中期，Oak语言的开发者意识到他们可以开发一个浏览器，WebRunner浏览器诞生。&lt;/p&gt;
&lt;p&gt;1995年，互联网的发展带给了Oak语言一个机遇。当时的网络页面是单调、死板的静态页面，业界希望页面能够“灵活”起来，并且希望代码能够通过网络传播进行跨平台运行。Oak的语言短小、可移植的特点和这些需求不谋而合。&lt;/p&gt;
&lt;p&gt;Sun公司首先推出了可以嵌入网页并且可以随同网页在网络上传输的Applet（Applet是一种将小程序嵌入到网页中进行执行的技术）。&lt;/p&gt;
&lt;p&gt;设计者在设计WebRunner浏览器具有在网页中执行内嵌代码的能力，这种能力能让网页变得“灵活”。&lt;/p&gt;
&lt;p&gt;同年，Sun公司将Oak更名为Java（因为Oak已经被使用了，Java一词来自咖啡），WebRunner浏览器也演变成了HotJava浏览器，HotJava浏览器完全使用Java开发。&lt;/p&gt;
&lt;p&gt;同年5月23日，Sun公司在Sun World会议上展示并正式发布了Java语言和HotJava浏览器，各大公司都纷纷停止了自己公司相关项目的开发，竞相购买Java的使用许可证，并为自己的产品开发了相应的Java平台。&lt;/p&gt;
&lt;h2 id=&quot;发展&quot;&gt;发展&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020062423004910.jpg#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1996年初，Sun公司发布了Java的第1个开发工具包（JDK1.0），这是Java发展的里程碑，标志着Java成为了一种独立的开发工具。&lt;/p&gt;
&lt;p&gt;同年9月，约8.3万个网页应用了Java来制作。&lt;/p&gt;
&lt;p&gt;同年10月，Sun公司发布了Java平台的第1个即时编译器。&lt;/p&gt;
&lt;p&gt;但是人们很快意识到Java1.0并不能用来进行真正的应用开发。&lt;/p&gt;
&lt;p&gt;1997年2月，JDK1.1面世，它弥补了JDK1.0的大多明显缺陷，改进了反射能力，但是仍有局限性。&lt;/p&gt;
&lt;p&gt;1998年12月，Sun公司发布了第二代Java平台——JDK1.2。此次发布有几个不同的版本，分别是标准版J2SE、用于手机等嵌入式设备的微型版J2ME、用于服务器端处理的企业版J2EE。&lt;/p&gt;
&lt;p&gt;此次发布是Java发展过程中最重要的里程碑，标志着Java的应用开始普及。&lt;/p&gt;
&lt;p&gt;2000年5月，JDK1.3、JDK1.4、J2SE1.3相继发布。&lt;/p&gt;
&lt;p&gt;2001年9月，J2EE1.3发布。&lt;/p&gt;
&lt;p&gt;2002年2月，J2SE1.4发布。该版本提高了Java的计算能力，扩展了标准类库，提高了系统性能。&lt;/p&gt;
&lt;p&gt;在此期间，Java Applet采用低调姿态，淡化了客户端的应用，&lt;strong&gt;成为服务器端应用的首选平台&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;2004年9月，J2SE 1.5版本发布，该版本为重大更新，是自1.1版本以来第一个对Java语言做出重大改进的版本。JavaOne会议后，版本数字从1.5改为5.0。&lt;/p&gt;
&lt;p&gt;2005年6月，Java SE 6发布。版本名称发生了改变，如J2SE改为Java SE、J2ME改为Java ME、J2EE改为Java EE。该版本没有对语言方面再进行改进，但是改进了其他性能，增强了类库。&lt;/p&gt;
&lt;p&gt;2006年11月，Sun公司将Java技术作为免费软件对外发布。&lt;/p&gt;
&lt;p&gt;2007年3月起，全世界所有开发人员均可对Java源代码进行修改。&lt;/p&gt;
&lt;p&gt;随着数据中心越来越依赖于商业硬件而不是专用服务器，Sun公司在2009年被Oracle收购。&lt;/p&gt;
&lt;p&gt;2011年，Oracle发布Java SE 7。&lt;/p&gt;
&lt;p&gt;2014年，Java SE 8发布，近20年以来，该版本有了最大改变，Java 8提供了一种“函数式”编程方式，可以很容易地表述并发执行的计算。&lt;/p&gt;
&lt;p&gt;2017年，Java SE 9发布。&lt;/p&gt;
&lt;p&gt;Java 9之后，Oracle宣布每6月更新一次版本。&lt;/p&gt;
&lt;p&gt;2020年3月，Java SE 14发布。&lt;/p&gt;

&lt;p&gt;Java一路走来，为了适应时代发展，做出了许多改变。&lt;/p&gt;
&lt;p&gt;在早期，Java是为了解决传统的单机程序设计问题，但由于种种原因，Java后来转向Web。&lt;/p&gt;
&lt;h2 id=&quot;web的最初模样&quot;&gt;Web的最初模样&lt;/h2&gt;
&lt;p&gt;Web为了提供交互性内容采取了客户端/服务器系统，但是交互性完全由服务器提供。服务器产生静态页面，这些静态页面是事先写好的，将其提供给能够解释并显示的客户端浏览器。&lt;/p&gt;
&lt;p&gt;但是我们的需求是千变万化的，事先写好的静态页面肯定不能满足我们日益增长的需求。&lt;/p&gt;
&lt;h2 id=&quot;cgi&quot;&gt;CGI&lt;/h2&gt;
&lt;p&gt;CGI（Common Gateway Interfa，通用网关接口），它是一段程序，运行在服务器上，提供同客户端HTML页面的接口，通俗的讲CGI就像是一座桥，把网页和WEB服务器中的执行程序连接起来，它把HTML接收的指令传递给服务器，再把服务器执行的结果返还给HTML页。&lt;/p&gt;
&lt;p&gt;CGI使网页变得不是静态的，而是交互式的。&lt;/p&gt;
&lt;p&gt;但是CGI程序的响应时间依赖于发送的数据量的大小、服务器和网络的负载，一旦网站变得复杂起来，响应就会变得非常慢且难以维护。&lt;/p&gt;
&lt;h2 id=&quot;applet&quot;&gt;Applet&lt;/h2&gt;
&lt;p&gt;Applet是一种将小程序嵌入到网页中进行执行的技术，含有Applet的网页的HTML文件代码中部带有&lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt; 和&lt;code&gt;&amp;lt;/applet&amp;gt;&lt;/code&gt;这样一对标记，当支持Java的网络浏览器遇到这对标记时，就将下载相应的小应用程序代码并在本地计算机上执行该Applet。&lt;/p&gt;
&lt;p&gt;在当时，Java Applet 可以大大提高Web页面的交互能力和动态执行能力。&lt;/p&gt;
&lt;p&gt;Java刚出现时，Applet是最受大家欢欣鼓舞的。但是由于当时的网络环境的问题，安装Java运行时环境（JRE）所需要的10MB带宽对当时的用户来说太过于恐怖。并且微软的IE浏览器并并没有包含JRE，所以Applet并没有得到大规模应用。&lt;/p&gt;
&lt;h2 id=&quot;servlet&quot;&gt;Servlet&lt;/h2&gt;
&lt;p&gt;Servlet（Server+Applet），即服务器端小程序。Servlet能够按照用户提交的内容处理并返回相应的资源。可以输出HTML页面，动态展示数据。Servlet实现正确的接口就能够处理Http请求。&lt;/p&gt;
&lt;p&gt;但是出现了一个很大的问题：HTML代码需要在Servlet类中用Java代码一行一行输出，表现、逻辑、控制、业务等全部在Servlet类中，造成Servlet类代码混乱（HTML代码、Java代码都写在一起），重复性高、阅读性差、开发困难。&lt;/p&gt;
&lt;p&gt;下面是使用Servlet在浏览器中输出有一个h1标题的Hello World！字符串的HTML页面。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    PrintWriter out = response.getWriter();
    response.setContentType(&quot;text/html;charset=utf-8&quot;);
    out.println(&quot;&amp;lt;html&amp;gt;&quot;);
    out.println(&quot;&amp;lt;head&amp;gt;&quot;);
    out.println(&quot;&amp;lt;title&amp;gt;$Title$&amp;lt;/title&amp;gt;&quot;);
    out.println(&quot;&amp;lt;/head&amp;gt;&quot;);
    out.println(&quot;&amp;lt;body&amp;gt;&quot;);
    out.println(&quot;&amp;lt;h1&amp;gt;Hello World!&amp;lt;/h1&amp;gt;&quot;);
    out.println(&quot;&amp;lt;/body&amp;gt;&quot;);
    out.println(&quot;&amp;lt;/html&amp;gt;&quot;);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可想而知，更复杂的页面得写多少代码！&lt;/p&gt;
&lt;h2 id=&quot;jsp&quot;&gt;JSP&lt;/h2&gt;
&lt;p&gt;为了解决上面的问题，Sun公司开发出了JSP。&lt;/p&gt;
&lt;p&gt;JSP（JavaServer Page）是一种动态网页技术标准。JSP部署于网络服务器上，可以响应客户端发送的请求，并根据请求内容动态地生成HTML、XML或其他格式文档的Web网页，然后返回给请求者。JSP技术以Java语言作为脚本语言，为用户的HTTP请求提供服务，并能与服务器上的其它Java程序共同处理复杂的业务需求。&lt;/p&gt;
&lt;p&gt;可以将JSP页面看成是一个能内嵌Java代码的HTML页面。&lt;/p&gt;
&lt;p&gt;静态部分（HTML页面）是模板，可以提前写好，动态部分（数据）可以由Java代码动态生成。这样一来就避免了在单纯使用Servlet时HTML代码和Java代码都出现在Servlet类中的混乱情况。&lt;/p&gt;
&lt;p&gt;JSP在运行时被转换成Servlet，因此JSP本质是Servlet。&lt;/p&gt;
&lt;p&gt;下面是使用JSP做和上面同样的事情：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&amp;gt;
&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;$Title$&amp;lt;/title&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;h1&amp;gt;Hello World!&amp;lt;/h1&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;仍使用HTML模板，但不是用Java语句一行一行“堆”出来，这多方便！&lt;/p&gt;
&lt;p&gt;使用了JSP后，虽然不用一行行地“堆”HTML页面了，但是代码混乱的问题仍没有解决。表现、逻辑、控制、业务等代码仍然写在一块了，只不过是从Servlet类中挪到JSP中了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200624230119969.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样混乱的代码极不利于团队开发，如果项目很小，那还能理顺，但如果项目非常大的话，那就“剪不断，理还乱了”。&lt;/p&gt;
&lt;p&gt;所以这时候，我们急需将代码分门别类的码放整齐。&lt;/p&gt;
&lt;h2 id=&quot;jsp--javabean（model1模式）&quot;&gt;JSP + JavaBean（Model1模式）&lt;/h2&gt;
&lt;p&gt;JavaBean 是用Java语言写成的可重用组件，JavaBean类要求：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;类是公开的&lt;/li&gt;
&lt;li&gt;具有私有成员变量&lt;/li&gt;
&lt;li&gt;具有无参构造器&lt;/li&gt;
&lt;li&gt;具有setter和getter方法&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;上面已经说了，单纯使用JSP会有大量的HTML代码和Java代码耦合在一起，不利于开发、维护、分工协作。&lt;/p&gt;
&lt;p&gt;我们举一个登录的例子：&lt;/p&gt;
&lt;p&gt;登录大致需要以下几步：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在浏览器中输入用户名、密码&lt;/li&gt;
&lt;li&gt;获取数据，交给服务器&lt;/li&gt;
&lt;li&gt;把数据处理成合适的形式&lt;/li&gt;
&lt;li&gt;查询数据库的用户表，看是否有一条用户名和密码都符合输入的记录。如果有，则登录成功。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;单纯使用JSP时，以上步骤全部在JSP登录页面中完成，该页面既需要显示登录表单、又需要获取、处理数据、还需要查询数据库。太乱了！！&lt;/p&gt;
&lt;p&gt;有了JavaBean，我们可以将JSP中大量重复的代码抽取成可重用的组件，封装成JavaBean，在一定程度上减轻了代码的耦合度，也在一定意义上实现了&lt;strong&gt;分层&lt;/strong&gt;。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200624230145897.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;比如，用户本身就是一个对象，我们可以将其抽取成JavaBean，数据的传递、查找都可使用JavaBean来完成。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200624230211590.jpg#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;jspservletjavabean（model2模式mvc模式）&quot;&gt;JSP+Servlet+JavaBean（Model2模式——MVC模式）&lt;/h2&gt;
&lt;p&gt;上面介绍了Servlet、JSP、JSP+JavaBean，虽然在进步，但是都不尽如人意。那为什么不让它们结合起来取长补短？&lt;/p&gt;
&lt;p&gt;我们之所以使用JavaBean，就是为了让Java代码和HTML代码分离开了，而Servlet也是一个Java类，为什么不使用它呢？&lt;/p&gt;
&lt;p&gt;JSP+JavaBean已经实现了部分分层，使用MVC(Model-View-Controller)模式能进一步分层。&lt;/p&gt;
&lt;p&gt;Model（模型）：MVC模式的中心组件，处理数据和逻辑。（比如JavaBean，但不止只有JavaBean）&lt;/p&gt;
&lt;p&gt;View（视图）：展示数据，渲染页面。（前端页面，比如HTML页面、JSP页面）&lt;/p&gt;
&lt;p&gt;Controller（控制器）：从View接收数据，向Model发送数据，即用于控制数据分发。（比如Servlet）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200624230229651.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ3MzM1OTAw,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还用上面的登录例子：&lt;/p&gt;
&lt;ol readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;将JSP登录页面作为View&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Servlet类（Controller）用于接收用户输入的用户名、密码，将其封装为用户类（JavaBean），然后去数据库中查询。如果能查询到则登录成功。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;将查询结果返回给Controller，Controller根据查询结果选择一个合适的View，并将数据渲染到页面，展示给用户。（在本例中，如果查询成功，则进入系统主页；如果查询不到，则用户会看到一个登录失败页面）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;使用了MVC设计模式后，代码有了明显的分层，结构清晰，各司其职。&lt;/p&gt;
&lt;h2 id=&quot;框架&quot;&gt;框架&lt;/h2&gt;
&lt;p&gt;为了减轻工作量，各种框架逐渐出现在人们的视野中。&lt;/p&gt;
&lt;p&gt;所谓框架，可以把它看做一个半成品的项目/软件，框架中有许多东西别人都已经帮我们写好了，比如各种类、方法。&lt;/p&gt;
&lt;p&gt;我们要做的就是去了解、学习框架，在写好的框架的基础上、遵循框架的制定好的规则、按照自己的思路、结合框架的思想、去开发我们自己的项目。&lt;/p&gt;
&lt;p&gt;目前Java的Web开发中最出名的框架就是Spring家族了，比如SpringMVC、Spring、SpringBoot。&lt;/p&gt;
&lt;p&gt;熟悉、利用这些框架能够帮助我们快速、优雅地开发出符合需求的项目。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;另，框架是别人写好的轮子，有了它，我们能够跑得更快，但是别忘了怎么走。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;说了这么多，相当于陪着Java从出生到现在走了一遍。我们可以看出Java的发展也不是一帆风顺的，我认为Java之所以现在还这么流行，原因之一就是它能够一直保持更新，一直在根据时代的需求结合自身的特点不断地做出改变。正如那句话「穷则变，变则通，通则达」。一门语言能做到这样，身为人更应该要做到。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;如有错误，还请指正。&lt;/p&gt;&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;百度百科&lt;/li&gt;
&lt;li&gt;维基百科&lt;/li&gt;
&lt;li&gt;Java官方文档&lt;/li&gt;
&lt;li&gt;Java核心卷一（第10版）&lt;/li&gt;
&lt;li&gt;Java编程思想（第4版）&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;文章首发于公众号『行人观学』&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200624230354247.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Wed, 24 Jun 2020 15:09:00 +0000</pubDate>
<dc:creator>行人观学</dc:creator>
<og:description>Java作为一门编程语言，自诞生以来已经流行了20多年，在学习它之前，我们有必要先了解一下它的历史。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xingrenguanxue/p/13190582.html</dc:identifier>
</item>
<item>
<title>Docker（三）Docker常用命令 - Odousang</title>
<link>http://www.cnblogs.com/hewenhao-blogs/p/13190364.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hewenhao-blogs/p/13190364.html</guid>
<description>[unable to retrieve full-text content]Docker常用命令 帮助命令 # 显示 Docker 版本信息 docker version # 显示系统信息，包括镜像和容器的数量 docker info # 查看帮助文档 帮助文档地址：https://docs.docker.com/reference/ docker [命令] --help </description>
<pubDate>Wed, 24 Jun 2020 14:18:00 +0000</pubDate>
<dc:creator>Odousang</dc:creator>
<dc:identifier>http://www.cnblogs.com/hewenhao-blogs/p/13190364.html</dc:identifier>
</item>
<item>
<title>谈谈 Promise 以及实现 Fetch 的思路 - whosmeya</title>
<link>http://www.cnblogs.com/whosmeya/p/13189761.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/whosmeya/p/13189761.html</guid>
<description>&lt;p&gt;Promise 是异步编程的一种解决方案。&lt;/p&gt;
&lt;h2 id=&quot;promise&quot;&gt;Promise&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;
/**
 * 属性
 */
Promise.length
Promise.prototype

/**
 * 方法
 */
Promise.all(iterable)   // 所有成功触发成功  任何失败触发失败
Promise.race(iterable)  // 任意一个成功或失败后触发
Promise.reject(reason)
Promise.resolve(value)

/**
 * 原型
 */
Promise.prototype.constructor
//方法
Promise.prototype.catch(onRejected)
Promise.prototype.then(onFulfilled, onRejected)
Promise.prototype.finally(onFinally)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Promise 有三种状态&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;pending: 初始状态，既不是成功，也不是失败状态。&lt;/li&gt;
&lt;li&gt;resolve: 意味着操作成功完成。(resoloved)&lt;/li&gt;
&lt;li&gt;reject: 意味着操作失败。&lt;/li&gt;
&lt;/ul&gt;&lt;br/&gt;&lt;h3 id=&quot;pending&quot;&gt;pending&lt;/h3&gt;
&lt;p&gt;pending 是初始状态，执行 resolve/reject 会进入对应状态，如果不执行，责一直为 pending 状态&lt;/p&gt;
&lt;p&gt;例如下面代码，promise 将一直在 pending 状态，不会执行 then/catch.&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;new Promise(function (resolve, reject) { })
  .then(res =&amp;gt; console.log(res))
  .catch(err =&amp;gt; console.log(err))
&lt;/code&gt;
&lt;/pre&gt;
&lt;br/&gt;&lt;h3 id=&quot;resolve&quot;&gt;resolve&lt;/h3&gt;
&lt;p&gt;resolve 意味着操作成功完成, 如果有 .then，值会传入 .then 的第一个参数函数里。&lt;/p&gt;
&lt;p&gt;如&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;new Promise(function (resolve, reject) {
  resolve(1)
})
  .then(res =&amp;gt; console.log(res))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;then 的第一个参数是成功的回调，第一个参数的返回值会影响接下来链的去向。第一个参数的返回值一般有三种情况&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;无返回值：会去执行下一个 .then ，没有参数&lt;/li&gt;
&lt;li&gt;返回值非promise：调用下一个then的函数，参数为返回值&lt;/li&gt;
&lt;li&gt;返回值为promise：根据promise的执行结果，执行 下一个then/catch，如果一直是pending，则不执行下一个then/catch&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;例如想要在当前 then 终止，可以这样操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;  .then((res) =&amp;gt; new Promise(() =&amp;gt; {}))
&lt;/code&gt;
&lt;/pre&gt;
&lt;br/&gt;&lt;h3 id=&quot;reject&quot;&gt;reject&lt;/h3&gt;
&lt;p&gt;reject 意味着操作失败。&lt;/p&gt;
&lt;p&gt;使用 .catch 会捕获到错误信息。&lt;/p&gt;
&lt;p&gt;与代码报错(如 undefined.a)不同的是, 代码报错如果不使用 catch 捕获，会向外传递，最终传递到根结点；而 reject 属于 promise 错误，即使不使用 catch 捕获也不会对全局有影响。&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;用-promise-实现-fetch&quot;&gt;用 promise 实现 fetch&lt;/h2&gt;
&lt;p&gt;先来看几个问题：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如果请求 code 404, 会走 then 还是 catch? (答案：then)&lt;/li&gt;
&lt;li&gt;控制台能看到一行 404 的错误, 为什么还是走 then 不是 catch 呢&lt;/li&gt;
&lt;li&gt;如果请求跨域失败，走 then 还是 catch?（答案：catch）&lt;/li&gt;
&lt;li&gt;同样是控制台看到错误，两者有什么区别呢?&lt;/li&gt;
&lt;li&gt;跨域失败的报错, 和 then 中 undefined.a 报错，如果都不 catch，后者在 react 脚手架开发环境页面会蹦，两者有什么区别?&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;带着这几个问题，来看看 fetch。&lt;/p&gt;
&lt;p&gt;fetch 返回值是 promise，所以有三种状态 pending、resolve、reject.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;pending: 请求中&lt;/li&gt;
&lt;li&gt;resolve: 请求成功（code 200/404/500 等, 非 200 控制台输出错误）&lt;/li&gt;
&lt;li&gt;reject: 请求失败（跨域失败、连接超时、无网络等，控制台输出错误）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们还发现，请求失败时，只能 catch 到最后一行错误, 如图&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/1141466/202006/1141466-20200624183329271-1945336272.png&quot;/&gt;&lt;p&gt;捕获后&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/1141466/202006/1141466-20200624183344795-340635642.png&quot;/&gt;&lt;br/&gt;&lt;h3 id=&quot;为什么-404-在控制台看到错误，还走-then-resolve-如何实现&quot;&gt;为什么 404 在控制台看到错误，还走 then, resolve 如何实现&lt;/h3&gt;
&lt;p&gt;实现有几个难点，&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;throw 后面代码不会执行;&lt;/li&gt;
&lt;li&gt;先报错，后执行 then；&lt;/li&gt;
&lt;li&gt;catch 后错误不会打印在控制台；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;试了下，Promise.reject('xxx') 这样的报错方式虽然是微观任务，但是总是在.then之后才在控制台输出，更像是宏观任务。所以也加个setTImeout宏观任务调至后面。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;var fetch = function () {
  return new Promise(function (resolve, reject) {
    setTimeout(function () {
      if ('请求成功 200') {
        resolve('Response数据结构');
      } else if ('请求成功 404，500等') {
        Promise.reject('GET xxxxxxxx 404');
        setTimeout(function () {
          resolve('Response数据结构');
        });
      }
    })
  })
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;br/&gt;&lt;h3 id=&quot;请求失败-例如跨域失败-reject-如何实现呢&quot;&gt;请求失败 例如跨域失败 reject 如何实现呢&lt;/h3&gt;
&lt;p&gt;同样加个 setTimeout&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;var fetch = function () {
  return new Promise(function (resolve, reject) {
    setTimeout(function () {
      if ('请求成功 200') {
        resolve('Response数据结构');
      } else if ('请求成功 404，500等') {
        Promise.reject('GET xxxxxxxx 404');
        setTimeout(function () {
          resolve('Response数据结构');
        });
      } else if ('请求失败') {
        Promise.reject('Access to fetch xxxxx with CORS disabled.');
        Promise.reject('GET xxxxx net::ERR_FAILED');
        setTimeout(function () {
          reject('TypeError: Failed to fetch');
        });
      }
    })
  })
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还是有些问题，我们实现的因为在promise 中，错误会有前缀 Uncaught (in promise)。浏览器客户端应该有更好的实现方式。&lt;/p&gt;
&lt;p&gt;最后总结一下 fetch 的三种情况&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;pending: 请求中&lt;/li&gt;
&lt;li&gt;resolve: 请求成功（code 200: 调用 resolve 返回数据； code: 404/500 等, 先抛错，再调用 resolve 返回数据。）&lt;/li&gt;
&lt;li&gt;reject: 请求失败（跨域失败、连接超时、无网络等，先控制台抛错，再调用 reject）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;抛错均不影响代码执行，与 undefined.a 不同。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.whosmeya.com/&quot;&gt;whosmeya.com&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 24 Jun 2020 12:43:00 +0000</pubDate>
<dc:creator>whosmeya</dc:creator>
<og:description>Promise 是异步编程的一种解决方案。 Promise /** * 属性 */ Promise.length Promise.prototype /** * 方法 */ Promise.all(i</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/whosmeya/p/13189761.html</dc:identifier>
</item>
</channel>
</rss>