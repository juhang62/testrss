<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>基于C#的机器学习--垃圾邮件过滤 - 王振耀</title>
<link>http://www.cnblogs.com/wangzhenyao1994/p/12193157.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangzhenyao1994/p/12193157.html</guid>
<description>&lt;p&gt;　　在这一章，我们将建立一个垃圾邮件过滤分类模型。我们将使用一个包含垃圾邮件和非垃圾邮件的原始电子邮件数据集，并使用它来训练我们的ML模型。我们将开始遵循上一章讨论的开发ML模型的步骤。这将帮助我们理解工作流程。&lt;/p&gt;
&lt;p&gt;       在本章中，我们将讨论以下主题:&lt;/p&gt;
&lt;p&gt;　　　　l  &lt;strong&gt;定义问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　l  &lt;strong&gt;准备数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　l  &lt;strong&gt;数据分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　l  &lt;strong&gt;构建数据的特征&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　l  &lt;strong&gt;逻辑回归与朴素贝叶斯的&lt;/strong&gt;&lt;strong&gt;Email&lt;/strong&gt;&lt;strong&gt;垃圾邮件过滤&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　l  &lt;strong&gt;验证分类模型&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;定义问题&lt;/h2&gt;
&lt;p&gt;       让我们从定义本章要解决的问题开始。我们可能已经对垃圾邮件很熟悉了;垃圾邮件过滤是众电子邮件服务的基本功能。垃圾邮件对用户来说可能是恼人的，但它们除此之外，也会带来更多的问题和风险。例如，可以设计垃圾邮件来获取信用卡号或银行帐户信息，这些信息可用于信用卡欺诈或洗钱。垃圾邮件也可以用来获取个人数据，然后可以用于身份盗窃和各种其他犯罪。垃圾邮件过滤技术是电子邮件服务避免用户遭受此类犯罪的重要一步。然而，有正确的垃圾邮件过滤解决方案是困难的。我们想过滤掉可疑的邮件，但同时，我们又不想过滤太多，以至于非垃圾邮件进入垃圾邮件文件夹，永远不会被用户看到。为了解决这个问题，我们将让我们的ML模型从原始电子邮件数据集中学习，并使用主题行将可疑电子邮件归类为垃圾邮件。我们将着眼于两个性能指标来衡量我们的成功:准确度和召回率。我们将在以下几节中详细讨论这些指标。&lt;/p&gt;
&lt;p&gt;       总结我们的问题定义:&lt;/p&gt;
&lt;p&gt;n  &lt;strong&gt;需要解决的问题时什么&lt;/strong&gt;&lt;strong&gt;?&lt;/strong&gt;我们需要一个垃圾邮件过滤解决方案，以防止我们的用户成为欺诈活动的受害者，同时改善用户体验。&lt;/p&gt;
&lt;p&gt;n  &lt;strong&gt;为什么这是个问题&lt;/strong&gt;&lt;strong&gt;?&lt;/strong&gt;在过滤可疑邮件和不过滤太多邮件之间取得适当的平衡是很困难的，这样垃圾邮件仍然会进入收件箱。我们将依靠ML模型来学习如何对这些可疑邮件进行统计分类。&lt;/p&gt;
&lt;p&gt;n  &lt;strong&gt;解决这个问题的方法有哪些&lt;/strong&gt;&lt;strong&gt;?&lt;/strong&gt;我们将建立一个分类模型，根据邮件的主题行，标记潜在的垃圾邮件。我们将使用准确性和召回率来平衡被过滤的邮件数量。&lt;/p&gt;
&lt;p&gt;n  &lt;strong&gt;成功的标准是什么&lt;/strong&gt;&lt;strong&gt;?&lt;/strong&gt;我们想要高回复率(实际垃圾邮件检索的百分比占垃圾邮件的总数)，而不牺牲太多的精确率(正确分类的垃圾邮件的百分比中预测为垃圾邮件)。&lt;/p&gt;

&lt;h2&gt;准备数据&lt;/h2&gt;
&lt;p&gt;       现在，我们已经清楚地描述和定义了将要用ML解决的问题，接下来我们需要准备数据。通常，我们需要在数据准备步骤之前采取额外的步骤来收集我们需要的数据，但是现在，我们将使用一个预先编译并标记为公共可用的数据集。在本章中，我们将使用CSDMC2010垃圾数据集来训练和测试我们的模型。我们将看到一个名为SPAMTrain.label的文本文件。SPAMTrain.label文件对训练文件夹中的每封邮件都进行了编码，0代表垃圾邮件，1代表非垃圾邮件。我们将使用此文本文件和训练文件夹中的电子邮件数据来构建垃圾邮件分类模型。&lt;/p&gt;
&lt;p&gt;       我们现在拥有的是一个原始数据集，其中包含许多EML文件，其中包含关于单个电子邮件的信息，以及一个包含标记信息的文本文件。为了使这个原始数据集可用来构建垃圾邮件分类模型，我们需要做以下工作:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;从&lt;/strong&gt;&lt;strong&gt;EML&lt;/strong&gt;&lt;strong&gt;文件中提取主题行&lt;/strong&gt;&lt;strong&gt;:&lt;/strong&gt;为将来的任务准备数据的第一步是从各个EML文件中提取主题和正文。我们将使用一个名为EAGetMail的包来加载和提取EML文件中的信息。使用EAGetMail包，我们可以轻松地从EML文件中加载和提取主题和正文内容。一旦从电子邮件中提取了主题和正文，就需要将每行数据作为一行附加到Deedle数据框架中。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;将提取的数据与标签结合起来&lt;/strong&gt;&lt;strong&gt;:&lt;/strong&gt;在从各个EML文件中提取主题和正文内容之后，我们还需要做一件事。我们需要将经过编码的标签(垃圾邮件为0，而非垃圾邮件为1)映射到我们在前一步中创建的数据帧的每一行。如果我们打开垃圾邮件。标签文件与任何文本编辑器，您可以看到编码的标签在第一列和相应的电子邮件文件名在第二列，由一个空格分隔。使用Deedle frame的ReadCsv函数，我们可以通过指定一个空格作为分隔符来轻松地将这个标签数据加载到数据框架中。一旦我们将这个标记的数据加载到一个数据框架中，我们就可以简单地将这个数据框架的第一列添加到前面步骤中使用Deedle框架的AddColumn函数创建的其他数据框架中。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;将合并后的数据导出为&lt;/strong&gt;&lt;strong&gt;CSV&lt;/strong&gt;&lt;strong&gt;文件&lt;/strong&gt;&lt;strong&gt;:&lt;/strong&gt;现在我们已经有了一个包含电子邮件和标签数据的数据框架，现在可以将该数据框架导出为CSV文件，以供将来使用。使用Deedle frame的SaveCsv函数，您可以轻松地将数据帧保存为CSV文件。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　　这个准备数据步骤的代码如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('16d78f33-46f6-4c7b-81c9-5d274773a930')&quot; readability=&quot;38.5&quot;&gt;&lt;img id=&quot;code_img_closed_16d78f33-46f6-4c7b-81c9-5d274773a930&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_16d78f33-46f6-4c7b-81c9-5d274773a930&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('16d78f33-46f6-4c7b-81c9-5d274773a930',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_16d78f33-46f6-4c7b-81c9-5d274773a930&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;72&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; Deedle;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; EAGetMail;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.IO;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; 准备数据
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;internal&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取所有原始的电子邮件格式的文件
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO: 更改指向数据目录的路径&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;string&lt;/span&gt; rawDataDirPath = &lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;D:\工作\代码库\AI\垃圾邮件过滤\raw-data&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;string&lt;/span&gt;[] emailFiles = Directory.GetFiles(rawDataDirPath, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*.eml&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从电子邮件文件中解析出主题和正文&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; emailDF =&lt;span&gt; ParseEmails(emailFiles);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取每个电子邮件的标签(spam vs. ham)&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; labelDF = Frame.ReadCsv(rawDataDirPath + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\\SPAMTrain.label&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, hasHeaders: &lt;span&gt;false&lt;/span&gt;, separators: &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;, schema: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;int,string&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将这些标签添加到电子邮件数据框架中&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;             emailDF.AddColumn(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;is_ham&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, labelDF.GetColumnAt&amp;lt;String&amp;gt;(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将解析后的电子邮件和标签保存为CSV文件&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;             emailDF.SaveCsv(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;transformed.csv&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;准备数据步骤完成!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;            Console.ReadKey();
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Frame&amp;lt;&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt; ParseEmails(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] files)
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 我们将解析每个电子邮件的主题和正文，并将每个记录存储到键值对中&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; rows = files.AsEnumerable().Select((x, i) =&amp;gt;
&lt;span&gt;35&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将每个电子邮件文件加载到邮件对象中&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;                 Mail email = &lt;span&gt;new&lt;/span&gt; Mail(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TryIt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                 email.Load(x, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; 
&lt;span&gt;40&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 提取主题和正文&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt;                 &lt;span&gt;string&lt;/span&gt; EATrialVersionRemark = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;(Trial Version)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; EAGetMail在试用版本中附加主题“(试用版本)”&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt;                 &lt;span&gt;string&lt;/span&gt; emailSubject = email.Subject.EndsWith(EATrialVersionRemark) ?
&lt;span&gt;43&lt;/span&gt;                     email.Subject.Substring(&lt;span&gt;0&lt;/span&gt;, email.Subject.Length -&lt;span&gt; EATrialVersionRemark.Length) : email.Subject;
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;                 &lt;span&gt;string&lt;/span&gt; textBody =&lt;span&gt; email.TextBody;
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; 
&lt;span&gt;46&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用电子邮件id (emailNum)、主题和正文创建键-值对&lt;/span&gt;
&lt;span&gt;47&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; { emailNum = i, subject = emailSubject, body =&lt;span&gt; textBody };
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;            });
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; 
&lt;span&gt;50&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据上面创建的行创建一个数据帧&lt;/span&gt;
&lt;span&gt;51&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Frame.FromRecords(rows);
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　运行这段代码后，程序将会创建一个名为transformed.csv的文件，它将包含四列(emailNum、subject、body和is_ham)。我们将使用此输出数据作为后面步骤的输入，以构建垃圾邮件过滤项目的ML模型。但是，我们也可以尝试使用Deedle框架和EAGetMail包，以不同的方式调整和准备这些数据。我在这里提供的代码是准备这些原始电子邮件数据以供将来使用的一种方法，以及我们可以从原始电子邮件数据中提取的一些信息。使用EAGetMail包，我们也可以提取其他特征，比如发件人的电子邮件地址和电子邮件中的附件，这些额外的特征可能有助于改进垃圾邮件分类模型。&lt;/p&gt;
&lt;h2&gt;数据分析&lt;/h2&gt;
&lt;p&gt;       在准备数据步骤中，我们将原始数据集转换为更具可读性和可用性的数据集。我们现在有一个文件可以查看，以找出哪些邮件是垃圾邮件，哪些不是。此外，我们可以很容易地找到垃圾邮件和非垃圾邮件的主题行。有了这些转换后的数据，让我们开始看看数据实际上是什么样子的，看看我们能否在数据中找到任何模式或问题。&lt;/p&gt;
&lt;p&gt;       因为我们正在处理文本数据，所以我们首先要看的是垃圾邮件和非垃圾邮件的单词分布有什么不同。为此，我们需要将上一步的数据输出转换为单词出现次数的矩阵表示。让我们以数据中的前三个主题行为例，一步步地完成这一工作。我们的前三个主题如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/912798/202001/912798-20200114164658396-814536292.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;　　如果我们转换这些数据，使每一列对应于每一个主题行中的每个单词，并将每个单元格的值编码为1，如果给定的主题行有单词，则编码为0，如果没有，则生成的矩阵如下所示:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/912798/202001/912798-20200114164721099-113308863.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;　　这种特定的编码方式称为one-hot编码，我们只关心特定的单词是否出现在主题行中，而不关心每个单词在主题行中实际出现的次数。在前面的例子中，我们还去掉了所有的标点符号，比如冒号、问号和感叹号。要以编程方式做到这一点，我们可以使用regex将每个主题行拆分为只包含字母-数字字符的单词，然后用one-hot编码构建一个数据框架。完成这个编码步骤的代码如下:　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('2ddee12a-c2f1-43fa-bb77-465a2f95652b')&quot; readability=&quot;36&quot;&gt;&lt;img id=&quot;code_img_closed_2ddee12a-c2f1-43fa-bb77-465a2f95652b&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_2ddee12a-c2f1-43fa-bb77-465a2f95652b&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('2ddee12a-c2f1-43fa-bb77-465a2f95652b',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_2ddee12a-c2f1-43fa-bb77-465a2f95652b&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Frame&amp;lt;&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt; CreateWordVec(Series&amp;lt;&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; rows)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; wordsByRows = rows.GetAllValues().Select((x, i) =&amp;gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; sb = &lt;span&gt;new&lt;/span&gt; SeriesBuilder&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;                 ISet&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; words = &lt;span&gt;new&lt;/span&gt; HashSet&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;(
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;                    Regex.Matches(
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 只字母字符&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;                         x.Value, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[a-zA-Z]+('(s|d|t|ve|m))?&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;                     ).Cast&amp;lt;Match&amp;gt;&lt;span&gt;().Select(
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 然后，将每个单词转换为小写字母&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;                         y =&amp;gt;&lt;span&gt; y.Value.ToLower()
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;                    ).ToArray()
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;                );
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对每行出现的单词进行1的编码&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;                 &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt; w &lt;span&gt;in&lt;/span&gt;&lt;span&gt; words)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                     sb.Add(w, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; KeyValue.Create(i, sb.Series);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;            });
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从我们刚刚创建的行创建一个数据框架 并将缺失的值编码为0&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; wordVecDF = Frame.FromRows(wordsByRows).FillMissing(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; wordVecDF;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　有了这种one-hot编码矩阵表示的单词，使我们的数据分析过程变的更容易。例如，如果我们想查看垃圾邮件中出现频率最高的10个单词，我们可以简单地对垃圾邮件的一个one-hot编码单词矩阵的每一列的值进行求和，然后取求和值最高的10个单词。这正是我们在以下代码中所做的:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('9b3cf5b0-b99c-47cf-b78b-bd30b4cecef5')&quot; readability=&quot;38.5&quot;&gt;&lt;img id=&quot;code_img_closed_9b3cf5b0-b99c-47cf-b78b-bd30b4cecef5&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_9b3cf5b0-b99c-47cf-b78b-bd30b4cecef5&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('9b3cf5b0-b99c-47cf-b78b-bd30b4cecef5',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_9b3cf5b0-b99c-47cf-b78b-bd30b4cecef5&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;72&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; hamTermFrequencies =&lt;span&gt; subjectWordVecDF.Where(
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;                 x =&amp;gt; x.Value.GetAs&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;is_ham&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) == &lt;span&gt;1&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;             ).Sum().Sort().Reversed.Where(x =&amp;gt; x.Key != &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;is_ham&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; spamTermFrequencies =&lt;span&gt; subjectWordVecDF.Where(
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                 x =&amp;gt; x.Value.GetAs&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;is_ham&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) == &lt;span&gt;0&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;            ).Sum().Sort().Reversed;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 查看排名前十的垃圾邮件和非垃圾邮件&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; topN = &lt;span&gt;10&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; hamTermProportions = hamTermFrequencies /&lt;span&gt; hamEmailCount;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; topHamTerms =&lt;span&gt; hamTermProportions.Keys.Take(topN);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; topHamTermsProportions =&lt;span&gt; hamTermProportions.Values.Take(topN);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            System.IO.File.WriteAllLines(
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                 dataDirPath + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\\ham-frequencies.csv&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;                hamTermFrequencies.Keys.Zip(
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                     hamTermFrequencies.Values, (a, b) =&amp;gt; &lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{0},{1}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, a, b)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;                )
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;            );
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; spamTermProportions = spamTermFrequencies /&lt;span&gt; spamEmailCount;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; topSpamTerms =&lt;span&gt; spamTermProportions.Keys.Take(topN);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; topSpamTermsProportions =&lt;span&gt; spamTermProportions.Values.Take(topN);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;            System.IO.File.WriteAllLines(
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                 dataDirPath + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\\spam-frequencies.csv&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;                spamTermFrequencies.Keys.Zip(
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                     spamTermFrequencies.Values, (a, b) =&amp;gt; &lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{0},{1}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, a, b)
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;                )
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             );
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　从这段代码可以看出，我们使用Deedle的数据框架的求和方法来对每一列中的值求和，并按相反的顺序排序。我们对垃圾邮件这样做一次，对非垃圾邮件这样做一次。然后，我们使用Take方法获得垃圾邮件和非垃圾邮件中出现频率最高的十个单词。当问运行这段代码时，它将生成两个CSV文件:ham-frequency-cies.csv和spam-frequency-cies.csv。这两个文件包含关于垃圾邮件和非垃圾邮件中出现的单词数量的信息，我们将在稍后的构造数据特征和模型构建步骤中使用这些信息。&lt;/p&gt;
&lt;p&gt;       现在让我们将一些数据可视化，以便进一步分析。首先，看一下数据集中ham电子邮件中出现频率最高的10个术语:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/912798/202001/912798-20200114164932433-93858368.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;　　从这个柱状图中可以看出，数据集中的非垃圾邮件比垃圾邮件要多，就像在现实世界中一样。我们的收件箱里收到的非垃圾邮件比垃圾邮件要多。&lt;/p&gt;
&lt;p&gt;       我们使用以下代码来生成这个柱状图，以可视化数据集中的ham和spam电子邮件的分布:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('0bc75b93-3dc3-4963-be66-10d78d2cc61a')&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_0bc75b93-3dc3-4963-be66-10d78d2cc61a&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_0bc75b93-3dc3-4963-be66-10d78d2cc61a&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('0bc75b93-3dc3-4963-be66-10d78d2cc61a',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_0bc75b93-3dc3-4963-be66-10d78d2cc61a&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; barChart =&lt;span&gt; DataBarBox.Show(
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;                 &lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Ham&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Spam&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; },
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;                 &lt;span&gt;new&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt;[] {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;                    hamEmailCount,
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;                    spamEmailCount
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;            );
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; barChart.SetTitle(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Ham vs. Spam in Sample Set&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　使用Accord.Net中的DataBarBox类。我们可以很容易地在柱状图中可视化数据。现在让我们来看看在ham和spam邮件中出现频率最高的十个词。可以使用下面的代码来为ham和spam邮件中排名前十的术语生成柱状图:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('55d3cbc9-aeae-46e3-b9b2-a4da8da96943')&quot; readability=&quot;36&quot;&gt;&lt;img id=&quot;code_img_closed_55d3cbc9-aeae-46e3-b9b2-a4da8da96943&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_55d3cbc9-aeae-46e3-b9b2-a4da8da96943&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('55d3cbc9-aeae-46e3-b9b2-a4da8da96943',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_55d3cbc9-aeae-46e3-b9b2-a4da8da96943&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; hamBarChart =&lt;span&gt; DataBarBox.Show(
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;                topHamTerms.ToArray(),
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;                 &lt;span&gt;new&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt;[][] {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;                    topHamTermsProportions.ToArray(),
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;                    spamTermProportions.GetItems(topHamTerms).Values.ToArray()
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;            );
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             hamBarChart.SetTitle(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Top 10 Terms in Ham Emails (blue: HAM, red: SPAM)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             System.Threading.Thread.Sleep(&lt;span&gt;3000&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            hamBarChart.Invoke(
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 &lt;span&gt;new&lt;/span&gt; Action(() =&amp;gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                     hamBarChart.Size = &lt;span&gt;new&lt;/span&gt; System.Drawing.Size(&lt;span&gt;5000&lt;/span&gt;, &lt;span&gt;1500&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;                })
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            );
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; spamBarChart =&lt;span&gt; DataBarBox.Show(
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;                topSpamTerms.ToArray(),
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                 &lt;span&gt;new&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt;[][] {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;                    hamTermProportions.GetItems(topSpamTerms).Values.ToArray(),
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;                    topSpamTermsProportions.ToArray()
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;            );
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             spamBarChart.SetTitle(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Top 10 Terms in Spam Emails (blue: HAM, red: SPAM)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　类似地，我们使用DataBarBox类来显示条形图。当运行这段代码时，我们将看到下面的图，其中显示了在ham电子邮件中出现频率最高的10个术语:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/912798/202001/912798-20200114165106238-630307667.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 　　spam邮件中最常出现的十大术语的柱状图如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/912798/202001/912798-20200114165121466-1146099194.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;　　正如所料，垃圾邮件中的单词分布与非垃圾邮件有很大的不同。例如，如果你看一下上上边的图表，spam和hibody这两个词在垃圾邮件中出现的频率很高，但在非垃圾邮件中出现的频率不高。然而，有些事情并没有多大意义。如果你仔细观察，你会发现所有的垃圾邮件和非垃圾邮件都有trial和version这两个单词，是不太可能的。如果你在文本编辑器中打开一些原始的EML文件，你会很容易发现并不是所有的电子邮件的标题行都包含这两个词。&lt;/p&gt;
&lt;p&gt;　　那么，到底发生了什么?我们的数据是否被之前的数据准备或数据分析步骤污染了?&lt;/p&gt;
&lt;p&gt;　　进一步的研究表明，我们使用的其中一个软件包导致了这个问题。我们用来加载和提取电子邮件内容的EAGetMail包在使用其试用版本时，会自动将(Trial Version)附加到主题行末尾。现在我们知道了这个数据问题的根本原因，我们需要回去修复它。一种解决方案是返回到数据准备步骤，用以下代码更新ParseEmails函数，它只是从主题行删除附加的(Trial Version)标志:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('f09bad6f-daf6-4727-90bb-e980b4ca84ba')&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_f09bad6f-daf6-4727-90bb-e980b4ca84ba&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_f09bad6f-daf6-4727-90bb-e980b4ca84ba&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('f09bad6f-daf6-4727-90bb-e980b4ca84ba',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_f09bad6f-daf6-4727-90bb-e980b4ca84ba&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Frame&amp;lt;&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt; ParseEmails(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] files)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 我们将解析每个电子邮件的主题和正文，并将每个记录存储到键值对中&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; rows = files.AsEnumerable().Select((x, i) =&amp;gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将每个电子邮件文件加载到邮件对象中&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;                 Mail email = &lt;span&gt;new&lt;/span&gt; Mail(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TryIt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 email.Load(x, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 提取主题和正文&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;                 &lt;span&gt;string&lt;/span&gt; EATrialVersionRemark = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;(Trial Version)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; EAGetMail在试用版本中附加主题“(试用版本)”&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;                 &lt;span&gt;string&lt;/span&gt; emailSubject = email.Subject.EndsWith(EATrialVersionRemark) ?
&lt;span&gt;13&lt;/span&gt;                     email.Subject.Substring(&lt;span&gt;0&lt;/span&gt;, email.Subject.Length -&lt;span&gt; EATrialVersionRemark.Length) : email.Subject;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 &lt;span&gt;string&lt;/span&gt; textBody =&lt;span&gt; email.TextBody;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用电子邮件id (emailNum)、主题和正文创建键-值对&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; { emailNum = i, subject = emailSubject, body =&lt;span&gt; textBody };
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            });
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据上面创建的行创建一个数据帧&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Frame.FromRecords(rows);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　在更新了这段代码并再次运行之前的数据准备和分析代码之后，word分布的柱状图就更有意义了。&lt;/p&gt;
&lt;p&gt;　　下面的条形图显示了修复和删除(Trial Version)标记后，ham邮件中出现频率最高的10个术语:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/912798/202001/912798-20200114165220948-268570484.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;　　下面的条形图显示了修复和删除(Trial Version)标志后spam邮件中出现频率最高的10个术语&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/912798/202001/912798-20200114165234448-1374512098.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;　　这是一个很好的例子，说明了在构建ML模型时数据分析步骤的重要性。在数据准备和数据分析步骤之间进行迭代是非常常见的，因为我们通常会在分析步骤中发现数据的问题，通常我们可以通过更新数据准备步骤中使用的一些代码来提高数据质量。现在，我们已经有了主题行中使用的单词的矩阵表示形式的清晰数据，是时候开始研究我们将用于构建ML模型的实际特性了。&lt;/p&gt;
&lt;h2&gt;构建数据的特征&lt;/h2&gt;
&lt;p&gt;       在前面的步骤中，我们简要地查看了垃圾邮件和非垃圾邮件的单词分类，我们注意到了一些事情。首先，大量的最频繁出现的单词是经常使用的单词，没有什么意义。例如，像to、the、For和a这样的单词是常用的单词，而我们的ML算法不会从这些单词中学到什么。这些类型的单词被称为停止单词，它们经常被忽略或从功能集中删除。我们将使用NLTK的停止单词列表从功能集中过滤出常用的单词。&lt;/p&gt;
&lt;p&gt;       过滤这些停止字的一种方法是如下代码所示:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('902b9559-c8bd-4e88-b356-b325c69d8a6e')&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_902b9559-c8bd-4e88-b356-b325c69d8a6e&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_902b9559-c8bd-4e88-b356-b325c69d8a6e&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('902b9559-c8bd-4e88-b356-b325c69d8a6e',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_902b9559-c8bd-4e88-b356-b325c69d8a6e&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;读停词表 &lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; ISet&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; stopWords = &lt;span&gt;new&lt;/span&gt; HashSet&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;(File.ReadLines(&amp;lt;path-to-your-stopwords.txt&amp;gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;从词频序列中过滤出停止词&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; spamTermFrequenciesAfterStopWords =&lt;span&gt; spamTermFrequencies.Where(
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;                 x =&amp;gt; !&lt;span&gt;stopWords.Contains(x.Key)
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; );
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　经过滤后，非垃圾邮件常出现的十大新词语如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/912798/202001/912798-20200114165317990-1733382780.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　过滤掉停止词后，垃圾邮件最常出现的十大词语如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/912798/202001/912798-20200114165336981-175554492.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　从这些柱状图中可以看出，过滤掉特性集中的停止词，使得更有意义的词出现在频繁出现的单词列表的顶部。然而，我们还注意到一件事。数字似乎是最常出现的单词之一。例如，数字3和2进入了非垃圾邮件中出现频率最高的10个单词。数字80和70进入了垃圾邮件中出现频率最高的10个单词。然而，很难确定这些数字是否有助于训练ML模型将电子邮件归类为垃圾邮件或垃圾邮件。&lt;/p&gt;
&lt;p&gt;       有多种方法可以从特性集中过滤掉这些数字，但是我们将只在这里展示一种方法。我们更新了上一步中使用的正则表达式，以匹配只包含字母字符而不包含字母数字字符的单词。下面的代码展示了我们如何更新CreateWordVec函数来过滤掉特性集中的数字。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('5c2076f7-71af-4c76-a0e4-074587bfa878')&quot; readability=&quot;36&quot;&gt;&lt;img id=&quot;code_img_closed_5c2076f7-71af-4c76-a0e4-074587bfa878&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_5c2076f7-71af-4c76-a0e4-074587bfa878&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('5c2076f7-71af-4c76-a0e4-074587bfa878',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_5c2076f7-71af-4c76-a0e4-074587bfa878&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Frame&amp;lt;&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt; CreateWordVec(Series&amp;lt;&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; rows)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; wordsByRows =&lt;span&gt; rows.GetAllValues()
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;                 .Select((x, i) =&amp;gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; sb = &lt;span&gt;new&lt;/span&gt; SeriesBuilder&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                     ISet&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; words = &lt;span&gt;new&lt;/span&gt; HashSet&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;(
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;仅字母字符&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;                         Regex.Matches(x.Value, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[a-zA-Z]+('(s|d|t|ve|m))?&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                         .Cast&amp;lt;Match&amp;gt;&lt;span&gt;()
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;然后，将每个单词转换为小写字母&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;                         .Select(y =&amp;gt;&lt;span&gt; y.Value.ToLower())
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;                        .ToArray()
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;                    );
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;对每行出现的单词进行1的编码&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;                     &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt; w &lt;span&gt;in&lt;/span&gt;&lt;span&gt; words)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                         sb.Add(w, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; KeyValue.Create(i, sb.Series);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;                });
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;从我们刚刚创建的行中创建一个数据帧，并用0对缺失的值进行编码&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; wordVecDF = Frame.FromRows(wordsByRows).FillMissing(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; wordVecDF;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　一旦我们从功能集过滤掉这些数字，非垃圾邮件的单词分布如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/912798/202001/912798-20200114165445429-725834633.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 而垃圾邮件的单词分布，在过滤掉来自功能集的数字后，看起来像这样:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/912798/202001/912798-20200114165502281-398793829.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　可以从这些柱状图中看到，我们有更多的有意义的词在顶部的名单上，这似乎和之前有一个很大的区别，在垃圾邮件和非垃圾邮件的单词分布。那些经常出现在垃圾邮件中的单词在非垃圾邮件中似乎并不多见，反之亦然。&lt;/p&gt;
&lt;p&gt;　　一旦您运行这段代码时,它将生成柱状图显示垃圾邮件单词分布和非垃圾邮件和两个单词列表的CSV files-one非垃圾邮件与相应项出现和另一个电子邮件在垃圾邮件单词列表和相应的项出现。在下面的模型构建部分中，当我们为垃圾邮件过滤构建分类模型时，我们将使用这个术语频率输出来进行特征选择过程。&lt;/p&gt;
&lt;h2&gt;逻辑回归与朴素贝叶斯的&lt;span lang=&quot;EN-US&quot;&gt;Email垃圾邮件过滤&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　我们已经走了很长的路，最终在c#中构建了我们的第一个ML模型。在本节中，我们将训练逻辑回归和朴素贝叶斯分类器来将电子邮件分为垃圾邮件和非垃圾邮件。我们将使用这两种学习算法来进行交叉验证，以更好地了解我们的分类模型在实践中的表现。如前一章所简要讨论的，在k-fold交叉验证中，训练集被划分为k个大小相等的子集，其中一个子集作为验证集，其余的k-1子集用于训练模型。然后重复这个过程k次，在每次迭代中使用不同的子集或折叠作为测试的验证集，然后对相应的k验证结果求平均值以报告单个估计。&lt;br/&gt;　　让我们首先看看如何使用Accord在c#中用逻辑回归来实例化交叉验证算法。代码如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('d5361fb8-fca3-430a-aab6-3c767c6d5655')&quot; readability=&quot;41&quot;&gt;&lt;img id=&quot;code_img_closed_d5361fb8-fca3-430a-aab6-3c767c6d5655&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_d5361fb8-fca3-430a-aab6-3c767c6d5655&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('d5361fb8-fca3-430a-aab6-3c767c6d5655',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_d5361fb8-fca3-430a-aab6-3c767c6d5655&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;77&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; cvLogisticRegressionClassifier = CrossValidation.Create&amp;lt;&lt;span&gt;LogisticRegression, 
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;                 IterativeReweightedLeastSquares&amp;lt;LogisticRegression&amp;gt;, &lt;span&gt;double&lt;/span&gt;[], &lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt;(
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 折叠数量    &lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;                    k: numFolds,
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 学习算法    &lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;                     learner: (p) =&amp;gt; &lt;span&gt;new&lt;/span&gt; IterativeReweightedLeastSquares&amp;lt;LogisticRegression&amp;gt;&lt;span&gt;()
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                         MaxIterations = &lt;span&gt;100&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                         Regularization = 1e-&lt;span&gt;6&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;                    },
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用0 - 1损失函数作为成本函数 &lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;                     loss: (actual, expected, p) =&amp;gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ZeroOneLoss(expected).Loss(actual),
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 合适的分类器    &lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;                     fit: (teacher, x, y, w) =&amp;gt;&lt;span&gt; teacher.Learn(x, y, w),
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输入    &lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;                    x: input,
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出    &lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;                    y: output
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;                );
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 运行交叉验证&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; result = cvLogisticRegressionClassifier.Learn(input, output);
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　让我们更深入地看看这段代码。通过提供要训练的模型类型、适合模型的学习算法类型、输入数据类型和输出数据类型，我们可以使用静态create函数创建一个新的交叉验证算法。对于这个例子，我们创建了一个新的交叉验证算法，以逻辑回归为模型，以IterativeReweightedLeastSquares作为学习算法，以双数组作为输入类型，以整数作为输出类型(每个标签)。您可以尝试使用不同的学习算法来训练逻辑回归模型。在协议。您可以选择使用随机梯度下降算法(LogisticGradientDescent)作为适合逻辑回归模型的学习算法。&lt;br/&gt;　　对于参数，我们可以为k-fold交叉验证(k)、带有自定义参数的学习方法(learner)、选择的损失/成本函数(loss)和一个知道如何使用学习算法(fit)来拟合模型的函数(x)、输入(x)和输出(y)指定折叠数。为了在本节中进行说明，我们为k-fold交叉验证设置了一个相对较小的数字3。此外，对于最大的迭代，我们选择了一个相对较小的数字，100，而对于迭代加权最小二乘学习算法的正则化，我们选择了一个相对较大的数字，le-6或1/1,000,000。对于损耗函数，我们使用一个简单的0 - 1损耗函数，它为正确的预测分配0，为错误的预测分配1。这就是我们的学习算法试图最小化的代价函数。所有这些参数都可以进行不同的调优。我们可以选择一个不同的损耗/成本函数，k折叠交叉验证中使用的折叠数，以及学习算法的最大迭代次数和正则化次数。我们甚至可以使用不同的学习算法来适应逻辑回归模型，比如LogisticGradientDescent，它将迭代地尝试找到损失函数的局部最小值。&lt;br/&gt;　　我们可以用同样的方法训练朴素贝叶斯分类器，用k次交叉验证。使用朴素贝叶斯学习算法进行k-fold交叉验证的代码如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('dd8341db-c0bb-4a54-8998-9cdfe9e18498')&quot; readability=&quot;40.5&quot;&gt;&lt;img id=&quot;code_img_closed_dd8341db-c0bb-4a54-8998-9cdfe9e18498&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_dd8341db-c0bb-4a54-8998-9cdfe9e18498&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('dd8341db-c0bb-4a54-8998-9cdfe9e18498',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_dd8341db-c0bb-4a54-8998-9cdfe9e18498&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;76&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; cvNaiveBayesClassifier = CrossValidation.Create&amp;lt;NaiveBayes&amp;lt;BernoulliDistribution&amp;gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;                 NaiveBayesLearning&amp;lt;BernoulliDistribution&amp;gt;, &lt;span&gt;double&lt;/span&gt;[], &lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt;(
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 折叠的数量&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;                    k: numFolds,
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 二项分布的朴素贝叶斯分类器&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;                     learner: (p) =&amp;gt; &lt;span&gt;new&lt;/span&gt; NaiveBayesLearning&amp;lt;BernoulliDistribution&amp;gt;&lt;span&gt;(),
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用0 - 1损失函数作为成本函数&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;                     loss: (actual, expected, p) =&amp;gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ZeroOneLoss(expected).Loss(actual),
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 合适的分类器&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;                     fit: (teacher, x, y, w) =&amp;gt;&lt;span&gt; teacher.Learn(x, y, w),
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输入&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;                    x: input,
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;                    y: output
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;                );
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 运行交叉验证&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; result = cvNaiveBayesClassifier.Learn(input, output);
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　之前的逻辑回归模型代码与这段代码的唯一区别是我们选择的模型和学习算法。我们使用NaiveBayes作为模型，NaiveBayesLearning作为学习算法来训练我们的NaiveBayes分类器，而不是使用LogisticRegression和IterativeReweightedLeastSquares。由于所有的输入值都是二进制的(0或1)，所以我们使用BernoulliDistribution作为我们的朴素Byes分类器模型。&lt;br/&gt;　　当你运行这段代码，你应该看到一个输出如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/912798/202001/912798-20200114170212732-1797973599.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 　　在下面讨论模型验证方法的小节中，我们将进一步研究这些数字所代表的内容。为了尝试不同的ML模型。可以使用我们前面讨论过的逻辑回归模型代码来替换它们，或者也可以尝试选择不同的学习算法使用。&lt;/p&gt;
&lt;h2&gt;验证分类模型&lt;/h2&gt;
&lt;p&gt;　　我们使用Accord.Net Framework在c#中建立了第一个ML模型。然而，我们还没有完全完成。如果我们更仔细地查看以前的控制台输出，就会发现有一件事非常令人担忧的情形。训练误差约为0.03，而验证误差约为0.26。这意味着我们的分类模型在训练集中正确预测了100次中的87次，而在验证或测试集中正确预测了100次中的74次。这是一个典型的过度拟合的例子，其中模型与训练集非常接近，以至于它对未预见数据集的预测是不可靠和不可预测的。如果我们将这个模型应用到垃圾邮件过滤系统中，那么实际用于过滤垃圾邮件的模型性能将是不可靠的，并且会与我们在训练集中看到的有所不同。&lt;br/&gt;　　过度拟合通常是因为模型对于给定的数据集来说太复杂，或者使用了太多的参数来拟合模型。我们在上一节中建立的朴素贝叶斯分类器模型的过拟合问题很可能是由于我们用来训练模型的复杂性和特征的数量。&lt;br/&gt;　　如果再次查看上一节末尾的控制台输出，我们可以看到用于训练朴素贝叶斯模型的特性的数量是2,212。这太多了,考虑到我们只有约4200封电子邮件记录，在我们的样本集只有三分之二(或大约3000条记录)被用来训练我们的模型(这是因为我们使用三倍交叉验证,只有两三个折叠用作训练集在每个迭代)。为了解决这个过拟合问题，我们必须减少用于训练模型的特性的数量。为了做到这一点，我们可以过滤掉那些不经常出现的项。完成此任务的代码，如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('81f7975f-7d05-4c64-9dfd-532f33edfcf1')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_81f7975f-7d05-4c64-9dfd-532f33edfcf1&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_81f7975f-7d05-4c64-9dfd-532f33edfcf1&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('81f7975f-7d05-4c64-9dfd-532f33edfcf1',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_81f7975f-7d05-4c64-9dfd-532f33edfcf1&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 改变特征的数量以减少过度拟合&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; minNumOccurences = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;string&lt;/span&gt;[] wordFeatures =&lt;span&gt; indexedSpamTermFrequencyDF.Where(
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         x =&amp;gt; x.Value.GetAs&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;num_occurences&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) &amp;gt;=&lt;span&gt; minNumOccurences
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;    ).RowKeys.ToArray();
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Num特征选择: {0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, wordFeatures.Count());
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　从这段代码可以看出，我们在前一节中构建的Naive Bayes分类器模型至少使用了垃圾邮件中出现的所有单词。&lt;br/&gt;　　如果我们查看垃圾邮件中的单词频率，大约有1400个单词只出现一次(查看在数据分析步骤中创建的spam-frequencies.csv文件)。直观地说，那些出现次数少的单词只会产生噪音，对我们的模型来说没有多少信息可以学习。这告诉我们，当我们在前一节中最初构建分类模型时，我们的模型将暴露在多少噪声中。&lt;br/&gt;　　现在我们知道了这个过度拟合问题的原因，让我们来修复它。让我们用不同的阈值来选择特征。我们已经尝试了5、10、15、20和25，以使垃圾邮件中出现的次数最少(也就是说，我们将minNumOccurrences设置为5、10、15等等)，并使用这些阈值训练Naive Bayes分类器。&lt;br/&gt;　　首先，朴素贝叶斯分类器的结果至少出现5次，如下图所示:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/912798/202001/912798-20200114170711708-2004944979.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 　　首先，朴素贝叶斯分类器的结果至少出现10次，如下图所示:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/912798/202001/912798-20200114170756459-1066974794.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　首先，朴素贝叶斯分类器的结果至少出现15次，如下图所示:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/912798/202001/912798-20200114170806749-1599565166.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　首先，朴素贝叶斯分类器的结果至少出现20次，如下图所示:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/912798/202001/912798-20200114170821606-671861683.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　从这些实验结果可以看到,当我们增加了最小数量的单词出现次数和减少相应的特性数量用来训练模型, 训练误差与验证误差之间的差距减小，训练误差开始与验证误差近似。当我们解决过拟合问题时，我们可以更加确信模型将如何处理未预见的数据和生产系统。&lt;br/&gt;　　现在我们已经介绍了如何处理过拟合问题，我们希望看看更多的模型性能度量工具:&lt;br/&gt;　　　　Confusion matrix（混淆矩阵）: 混淆矩阵是一个表，它告诉我们预测模型的整体性能。每一列表示每个实际类，每一行表示每个预测类。对于二元分类问题，混淆矩阵是一个2×2的矩阵，其中第一行表示消极预测，第二行表示积极预测。第一列表示实际的否定，第二列表示实际的肯定。下表说明了一个二元分类问题的混淆矩阵中的每个单元格代表什么。&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/912798/202001/912798-20200114170905467-1520671255.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　True Negative (TN) ：&lt;/p&gt;
&lt;p&gt;　　　　　　TP、True Positive 真阳性：预测为正，实际也为正&lt;br/&gt;　　　　　　FP、False Positive 假阳性：预测为正，实际为负&lt;br/&gt;　　　　　　FN、False Negative 假阴性：预测与负、实际为正&lt;br/&gt;　　　　　　TN、True Negative 真阴性：预测为负、实际也为负。&lt;br/&gt;　　　　从表中可以看出，混淆矩阵描述了整个模型的性能。在我们的例子中,如果我们看最后一个控制台输出在前面的屏幕截图,显示了控制台输出的逻辑回归分类模型中,我们可以看到,TNs的数量是2847,fn的数量是606,FPs的数量是102,和76 tps的数量是772。根据这些信息，我们可以进一步计算真实阳性率(TPR)、真实负性率(TNR)、假阳性率(FPR)和假阴性率(FNR)，如下:　&lt;/p&gt;
&lt;p&gt;　　　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/912798/202001/912798-20200114171056471-1053418423.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　　　　　使用前面的例子，我们例子中的真实阳性率是0.56,TNR是0.97,FPR是0.03,FNR是0.44&lt;br/&gt;　　　　Accuracy(准确性):准确性是正确预测的比例。使用与前面示例混淆矩阵相同的表示法，计算精度如下:&lt;/p&gt;
&lt;p&gt; 　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/912798/202001/912798-20200114171144606-288639503.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;　　　　准确性是一个经常使用的模型性能指标，但有时它并不能很好地代表整个模型的性能。例如，如果样本集很大程度上是不平衡的，并且，假设在我们的样本集中有5封垃圾邮件和95条火腿，那么一个简单的分类器将每封邮件都归类为火腿，那么它必须有95%的准确率。然而，它永远不会捕捉垃圾邮件。这就是为什么我们需要查看混乱矩阵和其他性能指标，如精度和正确率&lt;br/&gt;　　　　Precision rate（精度）:精度是正确的正面预测数量占全部正面预测数量的比例。使用与之前相同的符号，我们可以计算出精度率如下:&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/912798/202001/912798-20200114171225514-555126734.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;　　　　如果看看过去的控制台输出之前的截图的逻辑回归分类模型结果,精确率计算的数量除以TPs混淆矩阵,772年,由TPs的总和,FPs, 102年,772年从混淆矩阵,结果是0.88。&lt;br/&gt;　　　　Recall rate（召回率）：正确率是正确正面预测的数量占实际阳性总数的比例。这是告诉我们有多少实际的积极案例是由这个模型检索到的一种方式。使用与前面相同的符号，我们可以计算召回率，如下所示:&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/912798/202001/912798-20200114171256026-913353143.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;　　如果看看过去的控制台输出在前面的截图为我们的逻辑回归分类模式的结果,正确率计算的数量除以TPs混淆矩阵,通过TPs的总和,772年,772年和fn, 606年,混淆矩阵,其结果是0.56。&lt;br/&gt;　　有了这些性能指标，我们就可以选择最佳模型。在精度和正确率之间总是存在权衡。与其他模型相比，具有较高准确率的模型召回率较低。对于我们的垃圾邮件过滤问题，如果认为正确地过滤垃圾邮件更重要，并且可以牺牲一些通过用户收件箱的垃圾邮件，那么我们可以优化精度。另一方面，如果认为过滤掉尽可能多的垃圾邮件更重要，即使我们可能会过滤掉一些非垃圾邮件，那么可以优化正确率。选择正确的模型不是一个简单的决定，仔细考虑需求和成功标准是做出正确选择的关键。&lt;br/&gt;　　总之，下面是我们可以用来从交叉验证结果和混淆矩阵中计算性能指标的代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('34228998-a008-42c8-93d7-e9695cdb2ae9')&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_34228998-a008-42c8-93d7-e9695cdb2ae9&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_34228998-a008-42c8-93d7-e9695cdb2ae9&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('34228998-a008-42c8-93d7-e9695cdb2ae9',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_34228998-a008-42c8-93d7-e9695cdb2ae9&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 运行交叉验证&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; result =&lt;span&gt; cvNaiveBayesClassifier.Learn(input, output);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 训练错误&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;double&lt;/span&gt; trainingError =&lt;span&gt; result.Training.Mean;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证错误&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; validationError =&lt;span&gt; result.Validation.Mean;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;混淆矩阵:真阳性与假阳性和真阴性与假阴性：
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 混淆矩阵&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; GeneralConfusionMatrix gcm =&lt;span&gt; result.ToConfusionMatrix(input, output);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; truePositive = (&lt;span&gt;float&lt;/span&gt;)gcm.Matrix[&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;      &lt;span&gt;float&lt;/span&gt; trueNegative = (&lt;span&gt;float&lt;/span&gt;)gcm.Matrix[&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;      &lt;span&gt;float&lt;/span&gt; falsePositive = (&lt;span&gt;float&lt;/span&gt;)gcm.Matrix[&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; falseNegative = (&lt;span&gt;float&lt;/span&gt;)gcm.Matrix[&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;];
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　训练与验证(测试)错误:用于识别过拟合问题:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('8eaf69ec-4c8d-41f2-b634-d04811014fd2')&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_8eaf69ec-4c8d-41f2-b634-d04811014fd2&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_8eaf69ec-4c8d-41f2-b634-d04811014fd2&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('8eaf69ec-4c8d-41f2-b634-d04811014fd2',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_8eaf69ec-4c8d-41f2-b634-d04811014fd2&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 计算的准确率, 精度, 召回&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; accuracy = (truePositive + trueNegative) /&lt;span&gt; numberOfSamples;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; precision = truePositive / (truePositive +&lt;span&gt; falsePositive);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; recall = truePositive / (truePositive + falseNegative);
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;　　在本章中，我们用c#构建了第一个可以用于垃圾邮件过滤的ML模型。我们首先定义并清楚地说明我们要解决的问题以及成功的标准。然后，我们从原始邮件数据中提取相关信息，并将其转换为一种格式，用于数据分析、特征工程和ML模型构建步骤。&lt;/p&gt;
&lt;p&gt;　　在数据分析步骤中，我们学习了如何应用单一热编码并构建主题行中使用的单词的矩阵表示。&lt;/p&gt;
&lt;p&gt;　　我们还从数据分析过程中发现了一个数据问题，并了解了如何在数据准备和分析步骤之间来回迭代。&lt;/p&gt;
&lt;p&gt;　　然后，我们进一步改进了我们的特性集，过滤掉停止单词，并使用正则表达式将非字母数字或非字母单词分隔开。&lt;/p&gt;
&lt;p&gt;　　有了这个特征集，我们使用逻辑回归和朴素贝叶斯分类器算法建立了第一个分类模型，简要介绍了过度拟合的危险，并学习了如何通过观察准确性、精度和召回率来评估和比较模型性能。&lt;/p&gt;
&lt;p&gt;　　最后，我们还学习了精度和召回之间的权衡，以及如何根据这些度量和业务需求选择模型。&lt;/p&gt;
</description>
<pubDate>Wed, 15 Jan 2020 00:40:00 +0000</pubDate>
<dc:creator>王振耀</dc:creator>
<og:description>在这一章，我们将建立一个垃圾邮件过滤分类模型。我们将使用一个包含垃圾邮件和非垃圾邮件的原始电子邮件数据集，并使用它来训练我们的ML模型。我们将开始遵循上一章讨论的开发ML模型的步骤。这将帮助我们理解工</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wangzhenyao1994/p/12193157.html</dc:identifier>
</item>
<item>
<title>机器学习基础——让你一文学会朴素贝叶斯模型 - TechFlow2019</title>
<link>http://www.cnblogs.com/techflow/p/12194870.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/techflow/p/12194870.html</guid>
<description>&lt;p&gt;今天这篇文章和大家聊聊朴素贝叶斯模型，这是机器学习领域非常经典的模型之一，而且非常简单，适合初学者入门。&lt;/p&gt;
&lt;p&gt;朴素贝叶斯模型，顾名思义和贝叶斯定理肯定高度相关。之前我们在三扇门游戏的文章当中介绍过贝叶斯定理，我们先来简单回顾一下贝叶斯公式：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[P(A|B)=\frac{P(A)P(B|A)}{P(B)}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们把&lt;span class=&quot;math inline&quot;&gt;\(P(A)\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(P(B)\)&lt;/span&gt;当做先验概率，那么贝叶斯公式就是通过先验和条件概率推算后验概率的公式。也就是&lt;strong&gt;寻果溯因&lt;/strong&gt;，我们根据已经发生的事件去探究导致事件发生的原因。而朴素贝叶斯模型正是基于这个原理，它的原理非常朴素，朴素到一句话就可以概率：当一个样本有可能属于多个类别的时候，我们简单地选择其中概率最大的那个。&lt;/p&gt;
&lt;p&gt;所以，既然是选择样本所属的类别，显然朴素贝叶斯模型是一个&lt;strong&gt;分类算法&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在我们具体介绍算法原理之前，我们先来熟悉几个概念。其中几个概念在我们之前的文章当中也介绍过，这里就当做复习。&lt;/p&gt;

&lt;h3 id=&quot;先验概率&quot;&gt;先验概率&lt;/h3&gt;

&lt;p&gt;先验概率其实很好理解，我们先不管里面”先后“这两个字。说白了，其实先验概率就是我们可以事先通过做实验计算的概率。比如抛硬币正面朝上，比如在一个路口遇到红灯，再比如明天会下雨。&lt;/p&gt;
&lt;p&gt;这些事情，有些是我们可以通过实验得到的，有些是可以根据之前的经验估计的。在我们问题当中，这些事件的概率是相对明确的。可以认为是我们在做模型探究之前就可以确定的概率，所以称为先验概率。&lt;/p&gt;

&lt;h3 id=&quot;后验概率&quot;&gt;后验概率&lt;/h3&gt;

&lt;p&gt;后验概率从直观上来看与先验概率相反，是我们通过实验或者是之前的经验&lt;strong&gt;没有办法直接获取&lt;/strong&gt;的。它更多的指的是某个事件由于某个原因或者是另一个事件导致的概率。&lt;/p&gt;
&lt;p&gt;举个例子来说，一个学生参加考试，能够及格的概率是可以测量的。无论通过一个学生多次考试进行测试，还是批量学生进行统计，都是可行的。但假设学生在考试之前可以选择复习或者是打游戏，显然，复习会提升学生通过的概率，打游戏可能会降低也可能变化不大，我们不得而知。假设我们知道小明已经通过了考试，想要知道他在考试之前有没有复习，这就是一个&lt;strong&gt;后验概率&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;从逻辑上来看，它和条件概率恰好相反。条件概率是事件A发生的前提下会发生事件B的概率，而后验概率是已经知道事件B发生了，求事件A发生的概率。&lt;/p&gt;

&lt;h3 id=&quot;似然估计&quot;&gt;似然估计&lt;/h3&gt;

&lt;p&gt;这也是一个烂大街的词，所有介绍贝叶斯的文章，没有一个不提到这个词的。但是很少有文章能够将这个概念讲解清楚。&lt;/p&gt;
&lt;p&gt;似然的英文是&lt;strong&gt;likelihood&lt;/strong&gt;，从语义上来说它和&lt;strong&gt;概率&lt;/strong&gt;(probability)非常接近，可能只是翻译的时候做了区分。两者在数学公式上的表示也非常接近，都可以写成&lt;span class=&quot;math inline&quot;&gt;\(P(x|\theta)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;其中概率求的是已经知道参数&lt;span class=&quot;math inline&quot;&gt;\(\theta\)&lt;/span&gt;，事件x发生的概率。而似然侧重事件A发生时的参数&lt;span class=&quot;math inline&quot;&gt;\(\theta\)&lt;/span&gt;。那么自然，似然估计函数就是通过概率分布估计参数的函数了。最大似然估计也就好理解了，就是求事件A发生时，最有可能的参数&lt;span class=&quot;math inline&quot;&gt;\(\theta\)&lt;/span&gt;的值。&lt;/p&gt;
&lt;p&gt;举个很简单的例子，假设我们有一个不透明的黑箱，里面有若干个黑球和若干个白球。但我们不知道到底黑球有几个白球有几个。为了探索这个比例，我们有放回地从箱子当中取出10个球，假设最终结果是7黑3白，那么请问箱子里黑球的比例是多少？&lt;/p&gt;
&lt;p&gt;这题简直不能更简单，不是小学生的问题么？既然取了10次里面有7个黑球，那显然黑球的概率应该是70%啊，这有什么问题吗？&lt;/p&gt;
&lt;p&gt;表面上当然毫无问题，但实际上不对。因为我们&lt;strong&gt;实验得到的实验结果并不代表概率本身&lt;/strong&gt;，简单来说，箱子里黑球是70%可以出现7黑3白，箱子里黑球是50%也一样可以出现这个结果，我们怎么能判断箱子里黑球一定是70%呢？&lt;/p&gt;
&lt;p&gt;这个时候就要用到&lt;strong&gt;似然函数&lt;/strong&gt;了。&lt;/p&gt;

&lt;h3 id=&quot;似然函数&quot;&gt;似然函数&lt;/h3&gt;

&lt;p&gt;我们把刚才黑白球的实验代入到上面的似然估计的公式当中去，实验最后得到的结果是确定的，是事件x。我们要求的，也就是黑球的比例是参数&lt;span class=&quot;math inline&quot;&gt;\(\theta\)&lt;/span&gt;。由于我们是有放回的实验，所以每次拿出黑球的概率是不变的，根据&lt;strong&gt;二项分布&lt;/strong&gt;，我们可以写出事件x发生的概率：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[P(x|\theta)=\theta^7*(1-\theta)^3=f(\theta)\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这个式子就是我们的似然函数，也叫概率函数。它反映不同的参数下，事件x发生的概率。我们要做的就是根据这个函数计算出&lt;span class=&quot;math inline&quot;&gt;\(f(\theta)\)&lt;/span&gt;最大时&lt;span class=&quot;math inline&quot;&gt;\(\theta\)&lt;/span&gt;的取值。&lt;/p&gt;
&lt;p&gt;这个计算过程就很简单了，我们对&lt;span class=&quot;math inline&quot;&gt;\(\theta\)&lt;/span&gt;&lt;strong&gt;求导&lt;/strong&gt;，然后令导数等于0，然后求出此时对应的&lt;span class=&quot;math inline&quot;&gt;\(\theta\)&lt;/span&gt;的取值。最后的结果当然是&lt;span class=&quot;math inline&quot;&gt;\(\theta=0.7\)&lt;/span&gt;时方程有最大值。&lt;/p&gt;
&lt;p&gt;我们也可以把&lt;span class=&quot;math inline&quot;&gt;\(f(\theta)\)&lt;/span&gt;的函数图像画出来，直观地感受概率分布。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import numpy as np
import matplotlib.pyplot as plt

x = np.linspace(0, 1, 100)
y = np.power(x, 7) * np.power(1 - x, 3)

plt.plot(x, y)
plt.xlabel('value of theta')
plt.ylabel('value of f(theta)')
plt.show()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/1/15/16fa67cfd7d4ba83?w=382&amp;amp;h=222&amp;amp;f=png&amp;amp;s=27509&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这也就证明了，我们直观的感受是对的。&lt;strong&gt;不是因为我们拿出来黑球的概率是70%箱子里黑球的比例就是70%，而是箱子里黑球比例是70%拿出来黑球占70%的概率最大&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;模型详解&quot;&gt;模型详解&lt;/h3&gt;

&lt;p&gt;接下来就到了重头戏，我们还是先看贝叶斯公式：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[P(A|B)=\frac{P(A)P(B|A)}{P(B)}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们接下来对公式进行一个变形，我们假设与B事件有关的所有事件的集合为C。显然&lt;span class=&quot;math inline&quot;&gt;\(A \in C\)&lt;/span&gt;，假设C集合中一个有m个事件，分别写成: &lt;span class=&quot;math inline&quot;&gt;\(C_1, C_2, \cdots, C_m\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;那么&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(P(B)=\sum_{i=1}^mP(B|C_i)P(C_i)\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们在追寻事件B发生的原因的时候，会追寻出所有可能导致这个结果的参数集合C，然后从其中挑选出概率最大的那个作为结果。&lt;/p&gt;
&lt;p&gt;我们用它来分类的原理也是一样，对于一个样本x，我们会计算出它分别属于所有类别的概率，然后选择其中概率最大的一个作为最终预测的类别。这个朴素的思想就是朴素贝叶斯模型的原理。&lt;/p&gt;
&lt;p&gt;我们假设&lt;span class=&quot;math inline&quot;&gt;\(x=\{a_1, a_2, \cdots, a_n\}\)&lt;/span&gt;，其中的每一个a表示样本x的一个维度的特征。同样，我们还会有一个类别的集合&lt;span class=&quot;math inline&quot;&gt;\(C=\{y_1, y_2, \cdots, y_m\}\)&lt;/span&gt;，其中的每一个y表示一个特定的类别。我们要做的就是计算出x属于各个类别y的概率，选择其中概率最大的那个作为最终的分类结果。&lt;/p&gt;
&lt;p&gt;我们根据贝叶斯公式写出概率公式：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[P(y_i|x)=\frac{P(x|y_i)P(y_i)}{P(x)}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;span class=&quot;math inline&quot;&gt;\(P(x)\)&lt;/span&gt;是一个常量，对于所有的&lt;span class=&quot;math inline&quot;&gt;\(y_i\)&lt;/span&gt;保持不变，所以可以忽略，我们只需要关注分子的部分。&lt;/p&gt;
&lt;p&gt;这里，我们做一个重要的假设：我们假设样本x中各个维度的特征值彼此是独立的。&lt;/p&gt;
&lt;p&gt;这个假设非常朴素，但是也非常重要，如果没有这个假设，那么这里的概率会复杂到我们几乎无法计算。正是因为有了这个朴素的假设，所以才会称作是&lt;strong&gt;朴素贝叶斯模型&lt;/strong&gt;，这也是得名的原因。当然，英文是naive bayes，所以理论上来说称作是乃衣服贝叶斯也是可以的。&lt;/p&gt;
&lt;p&gt;有了这个假设之后就好办了，我们把公式展开就行：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(P(y_i|x)=P(y_i)P(a_1|y_i)P(a_2|y_i)\cdots P(a_n|y_i)=P(y_i)\prod_{j=1}^nP(a_j|y_i)\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;span class=&quot;math inline&quot;&gt;\(P(y_i)\)&lt;/span&gt;是先验概率，我们可以通过实验或者是其他方法得到，像是&lt;span class=&quot;math inline&quot;&gt;\(P(a_j|y_i)\)&lt;/span&gt;就不能直接得到了，就需要我们用统计的方法来计算。&lt;/p&gt;
&lt;p&gt;如果&lt;span class=&quot;math inline&quot;&gt;\(a_j\)&lt;/span&gt;是离散值，很简单，我们只需要统计&lt;span class=&quot;math inline&quot;&gt;\(y_i\)&lt;/span&gt;事件发生时，各个&lt;span class=&quot;math inline&quot;&gt;\(a_j\)&lt;/span&gt;的实现比例即可。假设我们实验了若干次，&lt;span class=&quot;math inline&quot;&gt;\(y_i\)&lt;/span&gt;一共发生了M次，&lt;span class=&quot;math inline&quot;&gt;\(a_j\)&lt;/span&gt;发生了N次，那么显然：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[P(a_j|y_i)=\frac{N}{M}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;为了防止M=0，我们可以在分子和分母上同时加上一个平滑参数，所以最终的结果写成：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[P(a_j|y_i)=\frac{N+\alpha}{M+\beta}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;但如果&lt;span class=&quot;math inline&quot;&gt;\(a_j\)&lt;/span&gt;是连续值应该怎么办？如果它是连续值，那么它的取值可能是无数多种。那么显然，我们不可能针对它的每一个取值都去计算概率。也不可能搜集到这么多样本。这种情况下我们应该怎么办呢？&lt;/p&gt;
&lt;p&gt;连续值也没关系，我们可以假设变量的分布满足正态分布。它的&lt;strong&gt;正态分布曲线其实就是这个变量的概率分布&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/1/15/16fa6842a388afeb?w=650&amp;amp;h=329&amp;amp;f=png&amp;amp;s=157552&quot;/&gt;&lt;/p&gt;
&lt;p&gt;用上图举个例子，我们观察最下面的累积百分比这个值。它其实代表x的位置与负无穷之间隔成的区域的面积。这个面积的取值范围是0-1，我们就可以用这个&lt;strong&gt;面积的值来代表f(x)的概率&lt;/strong&gt;。实际上假设变量服从不同维度的正态分布，其实就是&lt;strong&gt;高斯混合模型&lt;/strong&gt;（GMM）的思想了，这里点到为止，不做过多展开。&lt;/p&gt;
&lt;p&gt;也就是说，如果是离散值，那么我们就通过计算比例的方式来代表概率，如果是连续值，那么就通过正态分布计算概率分布的方法来计算概率。通过这种方法，我们就可以通过n个&lt;span class=&quot;math inline&quot;&gt;\(P(a_j|y_i)\)&lt;/span&gt;连乘得到&lt;span class=&quot;math inline&quot;&gt;\(P(y_i|x)\)&lt;/span&gt;的概率，最后，我们比较所有y对应的概率，选择其中最大的那个作为分类结果。&lt;/p&gt;
&lt;p&gt;以上流程完全正确，但是还存在一个小小的问题。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(P(a_j|y_i)\)&lt;/span&gt;是一个浮点数，而且很有可能非常小，而我们需要计算n个浮点数的乘积。由于存在精度误差，所以当连乘的结果小于精度的时候，就无法比较两个概率之间的大小了。&lt;/p&gt;
&lt;p&gt;为了解决这个问题，我们需要对浮点数的连乘做一个变形：我们对等式的左右两边取log。将若干个浮点数相乘，转化成相加：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{eqnarray} P(y_i|x) &amp;amp;= P(y_i)P(a_1|y_i)P(a_2|y_i)\cdots P(a_n|y_i) &amp;amp;= P(y_i)\prod_{j=1}^nP(a_j|y_i) \\ \log(P(y_i|x)) &amp;amp;= \log(P(y_i))+ \log(P(a_1|y_i)) + \cdots + log(P(a_n|y_i)) &amp;amp;= \log(P(y_i|x)) + \sum_{i=1}^n \log(P(a_i|y_i)) \end{eqnarray} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;由于对数函数是&lt;strong&gt;单调函数&lt;/strong&gt;，所以我们可以直接用取完对数之后的结果来比大小，就可以避免精度带来的影响了。&lt;/p&gt;
&lt;p&gt;以上就是贝叶斯模型的原理，在之后的文章当中会给大家分享贝叶斯模型在文本分类当中的应用。&lt;/p&gt;
&lt;p&gt;更文不易，如果有所收获，求个**关注*&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/1/15/16fa67d9d33e7a44?w=258&amp;amp;h=258&amp;amp;f=png&amp;amp;s=23988&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 15 Jan 2020 00:07:00 +0000</pubDate>
<dc:creator>TechFlow2019</dc:creator>
<og:description>今天这篇文章和大家聊聊朴素贝叶斯模型，这是机器学习领域非常经典的模型之一，而且非常简单，适合初学者入门。 朴素贝叶斯模型，顾名思义和贝叶斯定理肯定高度相关。之前我们在三扇门游戏的文章当中介绍过贝叶斯定</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/techflow/p/12194870.html</dc:identifier>
</item>
<item>
<title>Go 每日一库之 go-homedir - darjun</title>
<link>http://www.cnblogs.com/darjun/p/12194842.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/darjun/p/12194842.html</guid>
<description>&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;今天我们来看一个很小，很实用的库&lt;a href=&quot;https://github.com/mitchellh/go-homedir&quot;&gt;go-homedir&lt;/a&gt;。顾名思义，&lt;code&gt;go-homedir&lt;/code&gt;用来获取用户的主目录。&lt;br/&gt;实际上，使用标准库&lt;code&gt;os/user&lt;/code&gt;我们也可以得到这个信息：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;package main

import (
  &quot;fmt&quot;
  &quot;log&quot;
  &quot;os/user&quot;
)

func main() {
  u, err := user.Current()
  if err != nil {
    log.Fatal(err)
  }
    
  fmt.Println(&quot;Home dir:&quot;, u.HomeDir)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么为什么还要&lt;code&gt;go-homedir&lt;/code&gt;库？&lt;/p&gt;
&lt;p&gt;在 Darwin 系统上，标准库&lt;code&gt;os/user&lt;/code&gt;的使用需要 cgo。所以，任何使用&lt;code&gt;os/user&lt;/code&gt;的代码都不能交叉编译。&lt;br/&gt;但是，大多数人使用&lt;code&gt;os/user&lt;/code&gt;的目的仅仅只是想获取主目录。因此，&lt;code&gt;go-homedir&lt;/code&gt;库出现了。&lt;/p&gt;
&lt;h2 id=&quot;快速使用&quot;&gt;快速使用&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;go-homedir&lt;/code&gt;是第三方包，使用前需要先安装：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ go get github.com/mitchellh/go-homedir&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用非常简单：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;package main

import (
  &quot;fmt&quot;
  &quot;log&quot;
    
  &quot;github.com/mitchellh/go-homedir&quot;
)

func main() {
  dir, err := homedir.Dir()
  if err != nil {
    log.Fatal(err)
  }
  
  fmt.Println(&quot;Home dir:&quot;, dir)
  
  dir = &quot;~/golang/src&quot;
  expandedDir, err := homedir.Expand(dir)
  if err != nil {
    log.Fatal(err)
  }

  fmt.Printf(&quot;Expand of %s is: %s\n&quot;, dir, expandedDir)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;go-homedir&lt;/code&gt;有两个功能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Dir&lt;/code&gt;：获取用户主目录；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Expand&lt;/code&gt;：将路径中的第一个&lt;code&gt;~&lt;/code&gt;扩展成用户主目录。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;高级用法&quot;&gt;高级用法&lt;/h2&gt;
&lt;p&gt;由于&lt;code&gt;Dir&lt;/code&gt;的调用可能涉及一些系统调用和外部执行命令，多次调用费性能。所以&lt;code&gt;go-homedir&lt;/code&gt;提供了缓存的功能。默认情况下，缓存是开启的。&lt;br/&gt;我们也可以将&lt;code&gt;DisableCache&lt;/code&gt;设置为&lt;code&gt;false&lt;/code&gt;来关闭它。&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;package main

import (
  &quot;fmt&quot;
  &quot;log&quot;
    
  &quot;github.com/mitchellh/go-homedir&quot;
)

func main() {
  homedir.DisableCache = false
  
  dir, err := homedir.Dir()
  if err != nil {
    log.Fatal(err)
  }
  
  fmt.Println(&quot;Home dir:&quot;, dir)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用缓存时，如果程序运行中修改了主目录，再次调用&lt;code&gt;Dir&lt;/code&gt;还是返回之前的目录。如果需要获取最新的主目录，可以先调用&lt;code&gt;Reset&lt;/code&gt;清除缓存。&lt;/p&gt;
&lt;h2 id=&quot;实现&quot;&gt;实现&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;go-homedir&lt;/code&gt;源码只有一个文件&lt;a href=&quot;https://github.com/mitchellh/go-homedir/blob/master/homedir.go&quot;&gt;homedir.go&lt;/a&gt;，今天我们大概看一下&lt;code&gt;Dir&lt;/code&gt;的实现，去掉缓存相关代码：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;func Dir() (string, error) {
  var result string
  var err error
  if runtime.GOOS == &quot;windows&quot; {
    result, err = dirWindows()
  } else {
    // Unix-like system, so just assume Unix
    result, err = dirUnix()
  }

  if err != nil {
    return &quot;&quot;, err
  }
  return result, nil
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;判断当前的系统是&lt;code&gt;windows&lt;/code&gt;还是类 Unix，分别调用不同的方法。先看 windows 的，比较简单：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;func dirWindows() (string, error) {
    // First prefer the HOME environmental variable
    if home := os.Getenv(&quot;HOME&quot;); home != &quot;&quot; {
        return home, nil
    }

    // Prefer standard environment variable USERPROFILE
    if home := os.Getenv(&quot;USERPROFILE&quot;); home != &quot;&quot; {
        return home, nil
    }

    drive := os.Getenv(&quot;HOMEDRIVE&quot;)
    path := os.Getenv(&quot;HOMEPATH&quot;)
    home := drive + path
    if drive == &quot;&quot; || path == &quot;&quot; {
        return &quot;&quot;, errors.New(&quot;HOMEDRIVE, HOMEPATH, or USERPROFILE are blank&quot;)
    }

    return home, nil
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;流程如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;读取环境变量&lt;code&gt;HOME&lt;/code&gt;，如果不为空，返回这个值；&lt;/li&gt;
&lt;li&gt;读取环境变量&lt;code&gt;USERPROFILE&lt;/code&gt;，如果不为空，返回这个值；&lt;/li&gt;
&lt;li&gt;读取环境变量&lt;code&gt;HOMEDRIVE&lt;/code&gt;和&lt;code&gt;HOMEPATH&lt;/code&gt;，如果两者都不为空，拼接这两个值返回。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;类 Unix 系统的实现稍微复杂一点：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;func dirUnix() (string, error) {
  homeEnv := &quot;HOME&quot;
  if runtime.GOOS == &quot;plan9&quot; {
    // On plan9, env vars are lowercase.
    homeEnv = &quot;home&quot;
  }

  // First prefer the HOME environmental variable
  if home := os.Getenv(homeEnv); home != &quot;&quot; {
    return home, nil
  }

  var stdout bytes.Buffer

  // If that fails, try OS specific commands
  if runtime.GOOS == &quot;darwin&quot; {
    cmd := exec.Command(&quot;sh&quot;, &quot;-c&quot;, `dscl -q . -read /Users/&quot;$(whoami)&quot; NFSHomeDirectory | sed 's/^[^ ]*: //'`)
    cmd.Stdout = &amp;amp;stdout
    if err := cmd.Run(); err == nil {
      result := strings.TrimSpace(stdout.String())
      if result != &quot;&quot; {
        return result, nil
      }
    }
  } else {
    cmd := exec.Command(&quot;getent&quot;, &quot;passwd&quot;, strconv.Itoa(os.Getuid()))
    cmd.Stdout = &amp;amp;stdout
    if err := cmd.Run(); err != nil {
      // If the error is ErrNotFound, we ignore it. Otherwise, return it.
      if err != exec.ErrNotFound {
        return &quot;&quot;, err
      }
    } else {
      if passwd := strings.TrimSpace(stdout.String()); passwd != &quot;&quot; {
        // username:password:uid:gid:gecos:home:shell
        passwdParts := strings.SplitN(passwd, &quot;:&quot;, 7)
        if len(passwdParts) &amp;gt; 5 {
          return passwdParts[5], nil
        }
      }
    }
  }

  // If all else fails, try the shell
  stdout.Reset()
  cmd := exec.Command(&quot;sh&quot;, &quot;-c&quot;, &quot;cd &amp;amp;&amp;amp; pwd&quot;)
  cmd.Stdout = &amp;amp;stdout
  if err := cmd.Run(); err != nil {
    return &quot;&quot;, err
  }

  result := strings.TrimSpace(stdout.String())
  if result == &quot;&quot; {
    return &quot;&quot;, errors.New(&quot;blank output when reading home directory&quot;)
  }

  return result, nil
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;流程如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;先读取环境变量&lt;code&gt;HOME&lt;/code&gt;（注意 plan9 系统上为&lt;code&gt;home&lt;/code&gt;），如果不为空，返回这个值；&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;getnet&lt;/code&gt;命令查看系统的数据库中的相关记录，我们知道&lt;code&gt;passwd&lt;/code&gt;文件中存储了用户信息，包括用户的主目录。使用&lt;code&gt;getent&lt;/code&gt;命令查看&lt;code&gt;passwd&lt;/code&gt;中当前用户的那条记录，然后从中找到主目录部分返回；&lt;/li&gt;
&lt;li&gt;如果上一个步骤失败了，我们知道&lt;code&gt;cd&lt;/code&gt;后不加参数是直接切换到用户主目录的，而&lt;code&gt;pwd&lt;/code&gt;可以显示当前目录。那么就可以结合这两个命令返回主目录。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;这里分析源码并不是表示使用任何库都要熟悉它的源码，毕竟使用库就是为了方便开发。&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;但是源码是我们学习和提高的一个非常重要的途径。我们在使用库遇到问题的时候也要有能力从文档或甚至源码中查找原因。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/mitchellh/go-homedir&quot;&gt;home-dir&lt;/a&gt; GitHub 仓库&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;我&quot;&gt;我&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://darjun.github.io&quot;&gt;我的博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎关注我的微信公众号【GoUpUp】，共同学习，一起进步~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1919725/202001/1919725-20200115064328344-1414002693.jpg&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;4.1509433962264&quot;&gt;
&lt;p&gt;本文由博客一文多发平台 &lt;a href=&quot;https://openwrite.cn?from=article_bottom&quot;&gt;OpenWrite&lt;/a&gt; 发布！&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 14 Jan 2020 22:43:00 +0000</pubDate>
<dc:creator>darjun</dc:creator>
<og:description>简介 今天我们来看一个很小，很实用的库 &amp;quot;go homedir&amp;quot; 。顾名思义， 用来获取用户的主目录。 实际上，使用标准库 我们也可以得到这个信息： 那么为什么还要 库？ 在 Da</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/darjun/p/12194842.html</dc:identifier>
</item>
<item>
<title>人人都应该懂点密码学 - 龙跃十二</title>
<link>http://www.cnblogs.com/zhonglongbo/p/12194752.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhonglongbo/p/12194752.html</guid>
<description>&lt;div class=&quot;output_wrapper&quot; id=&quot;output_wrapper_id&quot; readability=&quot;84.395203949688&quot;&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;你可以从别人那里汲取某些思想，但必须用你自己的方式加以思考，在你的模子里铸成你思想的砂型。——兰姆&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p align=&quot;center&quot;&gt;本文已经收录至我的GitHub,欢迎大家踊跃star 和 issues。&lt;/p&gt;
&lt;h3 align=&quot;center&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://github.com/midou-tech/articles&quot; target=&quot;_blank&quot;&gt;https://github.com/midou-tech/articles&lt;/a&gt;&lt;/span&gt;&lt;/h3&gt;

&lt;h4&gt;&lt;span&gt;点关注，不迷路！！！&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt; 上次say&amp;amp;see了密码学的DES算法，接下来就有人私信说是一开始就直接讲算法有点难理解，想让我给打打底，这么说当然没问题，那以后我们就每周一篇，从最基础的东西讲起，下面我还会附上一张基础的知识框架图，感兴趣的盆友来看一看，跟着我带你学习密码学。&lt;/p&gt;
&lt;p&gt; 刚开始接触密码学的时候，我也是一头雾水😳，每次看到加密和解密，各种相似又不同的算法在我的大脑里转圈，我真的是太南了，但是随着学习的深入，好像慢慢了解了其中奥秘，这件事情就不再那么难了，于是我把自己的学习方法总结出来，和大家共同分享。&lt;/p&gt;
&lt;p&gt; 我的所有写作内容会更多的照顾到初学者和进阶的大佬，每一个大纲中的知识点都会从简单到复杂，不会一上来就讲些太难的，也不会只分享一些简单易学的、没有营养的内容。大家在看博文的过程中遇到任何问题或者生活工作上遇到问题私聊我，点击&lt;span&gt;联系作者&lt;/span&gt;加我微信，or发e-mail至：2507367760@qq.com 或者 longyueshier@163.com 或者 longyueshier@gmail.com 。&lt;/p&gt;
&lt;img src=&quot;https://img-blog.csdnimg.cn/20200114112358986.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzODI4NzM4,size_16,color_FFFFFF,t_70&quot; alt=&quot;密码学基础框架&quot; title=&quot;密码学基础框架&quot;/&gt;密码学基础框架
&lt;h5 id=&quot;h&quot;&gt;&lt;span&gt;数学基础：&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt; 关于在密码学中的数学基础（数学+密码学=……虽然有点难，我还是得说给你听，困难的事情简单的道理），主要讲到群、环、域这三个基础的数学模型，听起来觉着复杂，但其实用起来简单，这个时候我们已经不仅仅满足于对单纯的数字进行普通的运算了，它们所描述的就是将数与运算结合起来的一种运算集合。&lt;/p&gt;
&lt;p&gt; 举个简单例子，我简单解释一下什么是&lt;em&gt;群&lt;/em&gt;，群就是在一个非空集合上定义一个新的运算，使这个运算存在交换律、结合律、单位元（e·a=a）、逆元（a·a的逆元=e）就可称之为一个群。环和域和群类似，相比会增多其中的元数个数，以及自定义运算个数。关于代数的内容，推荐大家可以参考杨子胥的《近世代数》，里边关于密码学中所要用到的数学知识都有详细的介绍，看完书可谓是受益匪浅。&lt;/p&gt;
&lt;h5 id=&quot;h-1&quot;&gt;&lt;span&gt;基本概念 ：&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt; 讲完数学基础，接下来，我对后边要讲的知识的大概框架描述一下下，首先给大家讲讲在密码学中的一些基本概念，明文（可不是wang zhe rong yao铭文嗷~ ~）、密文、密钥等等这些词汇都是可以通过字面意思理解的，后边再遇到难以理解的词汇我在给大家解释，首先我们要接触的第一个知识就是通信保密系统，当我们理解了这个系统的整体流程，我们就可以知道，当消息泄露时候，我们从哪里入手排查。&lt;/p&gt;
&lt;img src=&quot;https://img-blog.csdnimg.cn/20200114142633975.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzODI4NzM4,size_16,color_FFFFFF,t_70&quot; alt=&quot;保密通信系统框图&quot; title=&quot;保密通信系统框图&quot;/&gt;保密通信系统框图
&lt;p&gt; 在框图中我们可以看出，加解密的过程中都需要使用到密钥，而密钥的不同使用方法就将密码体制分为单钥体制（加密解密使用同一密钥）和双钥体制（使用不同密钥进行加密和解密），而对于不同的加密结果，都存在多种密码攻击方式，至于这里的具体内容，下次我们来详细解释。&lt;/p&gt;
&lt;h5 id=&quot;h-2&quot;&gt;&lt;span&gt;流密码：&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt; 了解完这些基础，我们就算是正式进军密码学了，开门见山的说，一来你遇到的第一个问题就是流密码，这算是密码学里第一个难懂的专业词汇，流密码主要就是指利用一个密钥流生成器产生一个密钥流，然后用这个密钥流来对明文消息进行加密和解密，所谓同步流密码和自同步流密码就是取决于其输入的明文是否会影响加密器中的记忆元件的存储状态。密钥流的产生依赖于密钥流生成器，这个东西主要由一个驱动系统和一个非线性系统，两者相互配合完成任务，目前所用最多的就是利用一个或者多个LFSR构成其驱动部分，这样看来线性反馈移位寄存器可谓是功不可没。流密码的安全性取决于密钥流的安全性，要求密钥流序列有好的随机性,，以使窃听者对它无法预测。也就是说，即使截获其中一段,也无法推测后面是什么。如果密钥流是周期的，要完全做到随机性是困难的。严格地说,这样的序列不可能做到随机，只能要求截获比周期短的一段密钥流时不会泄露更多信息，这样的序伪随机序列。&lt;/p&gt;
&lt;h5 id=&quot;h-3&quot;&gt;&lt;span&gt;分组密码：&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt; 分组密码与流密码最大的不同在于，流密码的加密器中有一个记忆元件，而分组密码不存在，在许多密码系统中，分组密码也是系统安全的一个重要组成部分，用分组密码易于构造伪随机数生成器、流密码、消息认证码(MAC)和杂凑函数等，还可进而成为消息认证技术、数据完整性机制、实体认证协议以及单钥数字签字体制的核心组成部分。本部分主要介绍一下feistel结构，以及利用feistel结构构成的DES算法和AES算法，并且从一名学习者的角度介绍一下其安全性。&lt;/p&gt;
&lt;img src=&quot;https://img-blog.csdnimg.cn/20200114194655574.jpg&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;h5 id=&quot;h-4&quot;&gt;&lt;span&gt;公钥密码：&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt; 在公钥密码体制中，我们首先需要掌握一些简单的数论知识，例如，模运算，费尔玛定理，欧拉定理，欧几里得定理，中国剩余定理等等，这些基础数论知识在之后的学习中再和大家一一道来，掌握了数论知识以后，我们主要学习公钥加密体制以及RSA算法，以及基于椭圆曲线的密码体制，这一部分就稍稍有些难以理解，公钥密码体制的概念是在解决单钥密码体制中最难解决的两个问题时提出的，这两个问题分别是密钥分配和数字签字。公钥密码算法的最大特点是采用两个相关密钥将加密和解密能力分开，一个密钥是公开密钥，用于加密；另一个密钥是秘密密钥，用于解密。RSA算法是1978年由R.Rivest,A.Shamir和L.Adleman提出的一种用数论构造的、也是迄今为止理论上最为成熟完善的公钥密码体制，该体制已得到广泛的应用。为保证RSA算法的安全性，它的密钥长度需一再增大，使得它的运算负担越来越大。相比之下，椭圆曲线密码体制ECC可用短得多的密钥获得同样的安全性，因此具有广泛的应用前景。ECC已被IEEE公钥密码标准P1363采用。&lt;/p&gt;
&lt;h5 id=&quot;h-5&quot;&gt;&lt;span&gt;消息认证与杂凑算法：&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt; 关于消息认证机制呢，简单来说就是对所接受到的消息进行确认，保证其一定来自于发送方，且消息内容并未被篡改，在认证过程中，需有产生认证符，这一基本功能又作为认证协议的一个组成部分。认证符也就是用于认证消息的数值，主要由消息认证码MAC(messageauthenticationcode)和杂凑函数(hashfunction)两个途径来产生认证符，所以在这个部分我们就要主要讲两者的区别和联系。在杂凑函数中主要涉及两种算法，分别是MD系列以及SHA系列，两者相似又不同，具体详情我们以后慢慢说。&lt;/p&gt;
&lt;h5 id=&quot;h-6&quot;&gt;&lt;span&gt;数字签名：&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt; 数字签名的主要目的就是对消息进行签字，确保其本身的身份，数字签字由公钥密码发展而来，它在网络安全，包括身份认证、数据完整性、不可否认性以及匿名性等方面有着重要应用。&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;以上就是密码学的基础框架图，想必看到这里你也理解了不少东西吧，当然这些都还只是基础部分，想要学好还需要多下功夫多了解，关于后边的具体内容呢，我们下回详解😉&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;h-7&quot;&gt;&lt;span&gt;历史文章：&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/nMTsD2y_drV971RxdE1a5g&quot;&gt;学习linux命令，看这篇2w多字的命令详解就够了&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/V0_fcjr9t-lyqy2qyg6MWw&quot;&gt;HTTP就是这么简单&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/OZRGLGk3MkdkwaNliITTUQ&quot;&gt;Redis基础&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/Sel5ySSh0YJXdQ6KExQxyw&quot;&gt;顶级程序员工具集&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/pcMWdKh9cFMS75sAxgCrWg&quot;&gt;二十多个免费高清图片素材网站送给你&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;求点赞👍 求关注❤️&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;span&gt;「转发」是明目张胆的喜欢，「在看」是偷偷摸摸的爱。&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;如果有人想发文章，我这里提供&lt;code&gt;有偿征文&lt;/code&gt;(具体细则微信联系)，欢迎投稿或推荐你的项目。提供以下几种投稿方式：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;去我的github提交 issue:&lt;/code&gt; https://github.com/midou-tech/articles&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;发送到邮箱: 2507367760@qq.com 或者 longyueshier@163.com 或者 longyueshier@gmail.com&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;微信发送: 扫描下面二维码，公众号里面有作者微信号。&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;精选文章都同步在公众号里面，公众号看起会更方便，随时随地想看就看。微信搜索&lt;code&gt;龙跃十二&lt;/code&gt;或者扫码即可订阅。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1galsp9a07kj30p00dwae3.jpg&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Tue, 14 Jan 2020 16:45:00 +0000</pubDate>
<dc:creator>龙跃十二</dc:creator>
<og:description>在这个互联网时代，数据被称为石油，由此数据安全是被看得尤为重要，本篇文章意在普及密码学的基础知识。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhonglongbo/p/12194752.html</dc:identifier>
</item>
<item>
<title>ThreadLocal = 本地线程? - 风尘博客</title>
<link>http://www.cnblogs.com/vandusty/p/12194718.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/vandusty/p/12194718.html</guid>
<description>&lt;h2 id=&quot;一定义&quot;&gt;一、定义&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;ThreadLocal&lt;/code&gt;是&lt;code&gt;JDK&lt;/code&gt;包提供的，从名字来看，&lt;code&gt;ThreadLocal&lt;/code&gt;意思就是本地线程的意思。&lt;/p&gt;
&lt;h3 id=&quot;是什么&quot;&gt;1.1 是什么？&lt;/h3&gt;
&lt;p&gt;要想知道他是个啥，我们看看&lt;code&gt;ThreadLocal&lt;/code&gt;的源码（基于&lt;code&gt;JDK 1.8&lt;/code&gt;）中对这个类的介绍：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;This class provides thread-local variables.  These variables differ from
their normal counterparts in that each thread that accesses one (via its
{@code get} or {@code set} method) has its own, independently initialized
copy of the variable.  {@code ThreadLocal} instances are typically private
static fields in classes that wish to associate state with a thread (e.g.,
a user ID or Transaction ID).&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;大致能够总结出：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;TreadLocal&lt;/code&gt;可以给我们提供一个线程内的局部变量，而且这个变量与一般的变量还不同，它是每个线程独有的，与其他线程互不干扰的；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ThreadLocal&lt;/code&gt; 与普通变量的区别在于：每个使用该变量的线程都会初始化一个完全独立的实例副本。&lt;code&gt;ThreadLocal&lt;/code&gt; 变量通常被&lt;code&gt;private static&lt;/code&gt;修饰。当一个线程结束时，它所使用的所有 &lt;code&gt;ThreadLocal&lt;/code&gt; 相对的实例副本都会被回收；&lt;/li&gt;
&lt;li&gt;简单说&lt;code&gt;ThreadLocal&lt;/code&gt;就是一种以空间换时间的做法，在每个&lt;code&gt;Thread&lt;/code&gt;里面维护了一个&lt;code&gt;ThreadLocal.ThreadLocalMap&lt;/code&gt;，&lt;strong&gt;把数据进行隔离，每个线程的数据不共享&lt;/strong&gt;，自然就没有线程安全方面的问题了.&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;示例&quot;&gt;1.2 示例&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;一言不合上代码！&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//创建ThreadLocal变量
private static ThreadLocal&amp;lt;String&amp;gt; localParam = new ThreadLocal&amp;lt;&amp;gt;();

@Test
public void threadLocalDemo() {
    //创建2个线程，分别设置不同的值
    new Thread(() -&amp;gt; {
        localParam.set(&quot;Hello 风尘博客!&quot;);
        //打印当前线程本地内存中的localParam变量的值
        log.info(&quot;{}:{}&quot;, Thread.currentThread().getName(), localParam.get());
    }, &quot;T1&quot;).start();
    new Thread(() -&amp;gt; {
        log.info(&quot;{}:{}&quot;, Thread.currentThread().getName(), localParam.get());
    }, &quot;T2&quot;).start();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;... T1:Hello 风尘博客!
... T2:null&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打印结果证明，&lt;code&gt;T1&lt;/code&gt;线程中设置的值无法在&lt;code&gt;T2&lt;/code&gt;取出，证明变量&lt;code&gt;ThreadLocal&lt;/code&gt;在各个线程中数据不共享。&lt;/p&gt;
&lt;h3 id=&quot;threadlocal的api&quot;&gt;1.3 &lt;code&gt;ThreadLocal&lt;/code&gt;的&lt;code&gt;API&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;ThreadLocal&lt;/code&gt;定义了四个方法:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;get()&lt;/code&gt;:返回此线程局部变量当前副本中的值；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set(T value)&lt;/code&gt;:将线程局部变量当前副本中的值设置为指定值；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;initialValue()&lt;/code&gt;:返回此线程局部变量当前副本中的初始值；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;remove()&lt;/code&gt;:移除此线程局部变量当前副本中的值。&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;set()&lt;/code&gt;和&lt;code&gt;initialValue()&lt;/code&gt;区别&lt;/li&gt;
&lt;/ul&gt;&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;定义&lt;/td&gt;
&lt;td&gt;为这个线程设置一个新值&lt;/td&gt;
&lt;td&gt;该方法用于设置初始值，并且在调用&lt;code&gt;get()&lt;/code&gt;方法时才会被触发，所以是懒加载。但是如果在&lt;code&gt;get()&lt;/code&gt;之前进行了&lt;code&gt;set()&lt;/code&gt;操作，这样就不会调用&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;区别&lt;/td&gt;
&lt;td&gt;如果对象生成的时机不由我们控制的时候使用 &lt;code&gt;set()&lt;/code&gt; 方式&lt;/td&gt;
&lt;td&gt;对象初始化的时机由我们控制的时候使用&lt;code&gt;initialValue()&lt;/code&gt; 方式&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;二实现原理&quot;&gt;二、实现原理&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;ThreadLocal&lt;/code&gt;有一个特别重要的静态内部类&lt;code&gt;ThreadLocalMap&lt;/code&gt;，该类才是实现线程隔离机制的关键。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;每个线程的本地变量不是存放在&lt;code&gt;ThreadLocal&lt;/code&gt;实例里面，而是存放在调用线程的&lt;code&gt;threadLocals&lt;/code&gt;变量里面，也就是说：&lt;code&gt;ThreadLocal&lt;/code&gt;类型的本地变量存放在具体的线程内存空间中。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;ThreadLocal.ThreadLocalMap threadLocals = null;
ThreadLocal.ThreadLocalMap inheritableThreadLocals = null;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Thread&lt;/code&gt;类中有两个&lt;code&gt;ThreadLocalMap&lt;/code&gt;类型的变量，分别是&lt;code&gt;threadLocals&lt;/code&gt;和&lt;code&gt;inheritableThreadLocals&lt;/code&gt;，而&lt;code&gt;ThreadLocalMap&lt;/code&gt;是一个定制化的&lt;code&gt;Hashmap&lt;/code&gt;，专门用来存储线程本地变量。在默认情况下，每个线程中的这两个变量都为&lt;code&gt;null&lt;/code&gt;，只有当前线程第一次调用&lt;code&gt;ThreadLocal&lt;/code&gt;的&lt;code&gt;set()&lt;/code&gt;或者&lt;code&gt;get()&lt;/code&gt;方法时才会创建它们。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/1/13/16f9e7a0f5fc169d?w=1118&amp;amp;h=1038&amp;amp;f=png&amp;amp;s=316339&quot; alt=&quot;风尘博客&quot;/&gt;&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;code&gt;ThreadLocal&lt;/code&gt;就是一个工具壳，它通过&lt;code&gt;set()&lt;/code&gt;方法把&lt;code&gt;value&lt;/code&gt;值放入调用线程的&lt;code&gt;threadLocals&lt;/code&gt;里面并存放起来，当调用线程调用它的&lt;code&gt;get()&lt;/code&gt;方法时，再从当前线程的&lt;code&gt;threadLocals&lt;/code&gt;变量里面将其拿出来使用。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;如果调用线程一直不终止，那么这个本地变量会一直存放在调用线程的&lt;code&gt;threadLocals&lt;/code&gt;变量里面，所以当不需要使用本地变量时可以通过调用&lt;code&gt;ThreadLocal&lt;/code&gt;变量的&lt;code&gt;remove()&lt;/code&gt;方法，从当前线程的&lt;code&gt;threadLocals&lt;/code&gt;里面删除该本地变量。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;另外&lt;code&gt;Thread&lt;/code&gt;里面的&lt;code&gt;threadLocals&lt;/code&gt;被设计为&lt;code&gt;Map&lt;/code&gt;结构是因为每个线程可以关联多个&lt;code&gt;ThreadLocal&lt;/code&gt;变量。&lt;/p&gt;
&lt;h3 id=&quot;原理小结&quot;&gt;原理小结&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;每个&lt;code&gt;Thread&lt;/code&gt;维护着一个&lt;code&gt;ThreadLocalMap&lt;/code&gt;的引用；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ThreadLocalMap&lt;/code&gt;是&lt;code&gt;ThreadLocal&lt;/code&gt;的内部类，用&lt;code&gt;Entry&lt;/code&gt;来进行存储；&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;ThreadLocal&lt;/code&gt;的&lt;code&gt;set()&lt;/code&gt;方法时，实际上就是往&lt;code&gt;ThreadLocalMap&lt;/code&gt;设置值，&lt;code&gt;key&lt;/code&gt;是&lt;code&gt;ThreadLocal&lt;/code&gt;对象，值是传递进来的对象；&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;ThreadLocal&lt;/code&gt;的&lt;code&gt;get()&lt;/code&gt;方法时，实际上就是往&lt;code&gt;ThreadLocalMap&lt;/code&gt;获取值，&lt;code&gt;key&lt;/code&gt;是&lt;code&gt;ThreadLocal&lt;/code&gt;对象；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ThreadLocal&lt;/code&gt;本身并不存储值，它只是作为一个&lt;code&gt;key&lt;/code&gt;来让线程从&lt;code&gt;ThreadLocalMa&lt;/code&gt;p获取&lt;code&gt;value&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;三使用场景&quot;&gt;三、使用场景&lt;/h2&gt;
&lt;h3 id=&quot;threadlocal的作用&quot;&gt;3.1 &lt;code&gt;ThreadLocal&lt;/code&gt;的作用&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;保存线程上下文信息，在任意需要的地方可以获取.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;由于&lt;code&gt;ThreadLocal&lt;/code&gt;的特性，同一线程在某地方进行设置，在随后的任意地方都可以获取到。从而可以用来保存线程上下文信息。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;线程安全的，避免某些情况需要考虑线程安全必须同步带来的性能损失.&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;场景一独享对象&quot;&gt;3.2 场景一：独享对象&lt;/h3&gt;
&lt;p&gt;每个线程需要一个独享对象（通常是工具类，典型需要使用的类有&lt;code&gt;SimpleDateFormat&lt;/code&gt;和&lt;code&gt;Random&lt;/code&gt;）&lt;/p&gt;
&lt;p&gt;这类场景阿里规范里面也提到了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/1/13/16f9e78f60c7ce55?w=1436&amp;amp;h=586&amp;amp;f=png&amp;amp;s=172004&quot; alt=&quot;风尘博客&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;场景二当前信息需要被线程内的所有方法共享&quot;&gt;3.3 场景二：当前信息需要被线程内的所有方法共享&lt;/h3&gt;
&lt;p&gt;每个线程内需要保存全局变量（例如在拦截器中获取用户信息），可以让不同方法直接使用，避免参数传递的麻烦。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/1/13/16f9e7bddd3e020f?w=2344&amp;amp;h=1090&amp;amp;f=png&amp;amp;s=459110&quot;/&gt;&lt;/p&gt;
&lt;p&gt;演示（完整演示见文末&lt;a href=&quot;https://github.com/vanDusty&quot;&gt;Github&lt;/a&gt;）&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Data
public class User {
    private String userName;

    public User() {

    }

    public User(String userName) {
        this.userName = userName;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;UserContextHolder.java&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class UserContextHolder {

    public static ThreadLocal&amp;lt;User&amp;gt; holder = new ThreadLocal&amp;lt;&amp;gt;();

}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Service1.java&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Service1 {

    public void process() {
        User user = new User(&quot;Van&quot;);
        //将User对象存储到 holder 中
        UserContextHolder.holder.set(user);
        new Service2().process();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Service2.java&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Service2 {

    public void process() {
        User user = UserContextHolder.holder.get();
        System.out.println(&quot;Service2拿到用户名: &quot; + user.getUserName());
        new Service3().process();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Service3.java&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Service3 {

    public void process() {
        User user = UserContextHolder.holder.get();
        System.out.println(&quot;Service3拿到用户名: &quot; + user.getUserName());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;测试方法&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Test
public void threadForParams() {
    new Service1().process();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;结果打印&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;Service2拿到用户名: Van
Service3拿到用户名: Van&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;使用threadlocal的好处&quot;&gt;3.4 使用&lt;code&gt;ThreadLocal&lt;/code&gt;的好处&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;达到线程安全的目的；&lt;/li&gt;
&lt;li&gt;不需要加锁，执行效率高；&lt;/li&gt;
&lt;li&gt;更加节省内存，节省开销；&lt;/li&gt;
&lt;li&gt;免去传参的繁琐，降低代码耦合度。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;四问题&quot;&gt;四、问题&lt;/h2&gt;
&lt;h3 id=&quot;内存泄漏问题&quot;&gt;4.1 内存泄漏问题&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;内存泄露：某个对象不会再被使用，但是该对象的内存却无法被收回&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;正常情况&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当&lt;code&gt;Thread&lt;/code&gt;运行结束后，&lt;code&gt;ThreadLocal&lt;/code&gt;中的&lt;code&gt;value&lt;/code&gt;会被回收，因为没有任何强引用了。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;非正常情况&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当&lt;code&gt;Thread&lt;/code&gt;一直在运行始终不结束，强引用就不会被回收，存在以下调用链&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Thread--&amp;gt;ThreadLocalMap--&amp;gt;Entry(key为null)--&amp;gt;value&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为调用链中的 &lt;code&gt;value&lt;/code&gt; 和 &lt;code&gt;Thread&lt;/code&gt; 存在强引用，所以&lt;code&gt;value&lt;/code&gt;无法被回收，就有可能出现&lt;code&gt;OOM&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何避免内存泄漏(阿里规范)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;调用&lt;code&gt;remove()&lt;/code&gt;方法，就会删除对应的&lt;code&gt;Entry&lt;/code&gt;对象，可以避免内存泄漏，所以使用完&lt;code&gt;ThreadLocal&lt;/code&gt;后，要调用&lt;code&gt;remove()&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/1/13/16f9e7c4201883f0?w=1392&amp;amp;h=490&amp;amp;f=png&amp;amp;s=132975&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;threadlocal的空指针问题&quot;&gt;4.2 &lt;code&gt;ThreadLocal&lt;/code&gt;的空指针问题&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;ThreadLocalNPE.java&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ThreadLocalNPE {

    ThreadLocal&amp;lt;Long&amp;gt; longThreadLocal = new ThreadLocal&amp;lt;&amp;gt;();

    public void set() {
        longThreadLocal.set(Thread.currentThread().getId());
    }

    /**
     * 当前返回值为基本类型，会报空指针异常，如果改成包装类型Long就不会出错
     * @return
     */
    public long get() {
        return longThreadLocal.get();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;空指针测试&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Test
public void threadLocalNPE() {
    ThreadLocalNPE threadLocalNPE = new ThreadLocalNPE();
    //如果get方法返回值为基本类型，则会报空指针异常，如果是包装类型就不会出错
    System.out.println(threadLocalNPE.get());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果&lt;code&gt;get()&lt;/code&gt;方法返回值为基本类型，则会报空指针异常；如果是包装类型就不会出错。这是因为基本类型和包装类型存在装箱和拆箱的关系，所以，我们必须将&lt;code&gt;get()&lt;/code&gt;方法返回值使用包装类型。&lt;/p&gt;
&lt;h2 id=&quot;参考文章&quot;&gt;4.3 参考文章&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/ithuangqing/p/12114581.html&quot;&gt;再也不学Threadlocal了，看这一篇就忘不掉了（万字总结）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://juejin.im/post/5e0d8765f265da5d332cde44#comment&quot;&gt;使用 ThreadLocal 一次解决老大难问题&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;四技术交流&quot;&gt;四、技术交流&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/vanDusty/JDK/tree/master/JDK-8/src/main/java/cn/van/jdk/eight/threadlocal&quot;&gt;Github 示例代码&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.dustyblog.cn&quot;&gt;风尘博客：https://www.dustyblog.cn&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://juejin.im/user/5d5ea68e6fb9a06afa328f56/posts&quot;&gt;风尘博客-掘金&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/vandusty/&quot;&gt;风尘博客-博客园&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/vanDusty&quot;&gt;Github&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Tue, 14 Jan 2020 16:18:00 +0000</pubDate>
<dc:creator>风尘博客</dc:creator>
<og:description>一、定义 是`JDK ThreadLocal`意思就是本地线程的意思。 1.1 是什么？ 要想知道他是个啥，我们看看 的源码（基于 ）中对这个类的介绍： 大致能够总结出： 1. 可以给我们提供一个线程</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/vandusty/p/12194718.html</dc:identifier>
</item>
<item>
<title>基于Netty和SpringBoot实现一个轻量级RPC框架-Server篇 - throwable</title>
<link>http://www.cnblogs.com/throwable/p/12194713.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/throwable/p/12194713.html</guid>
<description>&lt;h2 id=&quot;前提&quot;&gt;前提&lt;/h2&gt;
&lt;p&gt;前置文章：&lt;/p&gt;
&lt;p&gt;在前置的《基于Netty和SpringBoot实现一个轻量级RPC框架-协议篇》一文中已经定义了一个相对简单的&lt;code&gt;RPC&lt;/code&gt;私有协议，并且实现了对应的编码和解码模块。这篇文章基于协议篇，完成&lt;code&gt;Server&lt;/code&gt;端代码调用的编写。考虑到目前相对主流的&lt;code&gt;IOC&lt;/code&gt;容器是&lt;code&gt;Spring&lt;/code&gt;，这里选用了&lt;code&gt;spring-boot-starter&lt;/code&gt;（非&lt;code&gt;MVC&lt;/code&gt;容器，只是单纯管理&lt;code&gt;Bean&lt;/code&gt;），依赖&lt;code&gt;JDK1.8+&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;思路&quot;&gt;思路&lt;/h2&gt;
&lt;p&gt;首先&lt;code&gt;RPC&lt;/code&gt;私有协议定义了&lt;code&gt;Client&lt;/code&gt;端会传过来四个和服务调用息息相关的字符：接口全类名&lt;code&gt;interfaceName&lt;/code&gt;、方法名&lt;code&gt;methodName&lt;/code&gt;、方法参数签名字符串数组&lt;code&gt;methodArgumentSignatures&lt;/code&gt;（可选，这个参数不是必须传入的）以及方法参数数组&lt;code&gt;methodArguments&lt;/code&gt;（可选，空方法列表的时候不需要传入参数）。主要流程如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;把&lt;code&gt;Server&lt;/code&gt;端的所有服务端（实现）类交由&lt;code&gt;IOC&lt;/code&gt;容器托管。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Client&lt;/code&gt;端发起&lt;code&gt;RPC&lt;/code&gt;请求。&lt;/li&gt;
&lt;li&gt;通过前面提到的最多四个参数，从&lt;code&gt;Server&lt;/code&gt;服务实例的&lt;code&gt;IOC&lt;/code&gt;容器中&lt;strong&gt;匹配出吻合度最高的一个方法&lt;/strong&gt;&lt;code&gt;java.lang.reflect.Method&lt;/code&gt;实例、该方法实例的宿主类以及宿主类对应的&lt;code&gt;Bean&lt;/code&gt;实例，如果这一步匹配的目标方法超过1个或者为0个，可以直接返回异常信息。&lt;/li&gt;
&lt;li&gt;把前一步得到的&lt;code&gt;Method&lt;/code&gt;实例、宿主类&lt;code&gt;Bean&lt;/code&gt;实例，结合方法参数数组&lt;code&gt;methodArguments&lt;/code&gt;进行反射调用，得到调用结果。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Server&lt;/code&gt;端把响应结果封装到&lt;code&gt;payload&lt;/code&gt;通过私有协议发送回&lt;code&gt;Client&lt;/code&gt;端。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;server端代码实现&quot;&gt;Server端代码实现&lt;/h2&gt;
&lt;p&gt;为了暂时方便起见，部分数组入参被重新封装为&lt;code&gt;ArrayList&lt;/code&gt;，实际上编写&lt;code&gt;RPC&lt;/code&gt;框架的时候应该优先考虑性能问题，像&lt;code&gt;JDK&lt;/code&gt;提供的集合类库等等应该尽可能少用（以&lt;code&gt;ArrayList&lt;/code&gt;为例，扩容的时候存在底层&lt;code&gt;Object[]&lt;/code&gt;拷贝，造成性能损失和额外的内存消耗），极尽可能使用基本类型和数组。&lt;/p&gt;
&lt;p&gt;先定义&lt;strong&gt;方法匹配器&lt;/strong&gt;&lt;code&gt;MethodMatcher&lt;/code&gt;相关的类：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface MethodMatcher {

    /**
     * 查找一个匹配度最高的方法信息
     *
     * @param input input
     * @return output
     */
    MethodMatchOutput selectOneBestMatchMethod(MethodMatchInput input);
}

// 输入值
@EqualsAndHashCode
@Data
public class MethodMatchInput {

    private String interfaceName;

    private String methodName;

    private List&amp;lt;String&amp;gt; methodArgumentSignatures;

    private int methodArgumentArraySize;
}

// 输出值
@Data
public class MethodMatchOutput {

    /**
     * 目标方法实例
     */
    private Method targetMethod;

    /**
     * 目标实现类 - 这个有可能是被Cglib增强过的类型,是宿主类的子类,如果没有被Cglib增强过,那么它就是宿主类
     */
    private Class&amp;lt;?&amp;gt; targetClass;

    /**
     * 宿主类
     */
    private Class&amp;lt;?&amp;gt; targetUserClass;

    /**
     * 宿主类Bean实例
     */
    private Object target;

    /**
     * 方法参数类型列表
     */
    private List&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; parameterTypes;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;目标方法匹配的逻辑大致如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;方法名称和方法实例的宿主类型一定作为匹配条件的一部分。&lt;/li&gt;
&lt;li&gt;如果传入了参数签名列表，优先使用参数签名列表类型进行匹配。&lt;/li&gt;
&lt;li&gt;如果没有传入参数签名列表，那么使用参数的数量进行匹配。&lt;/li&gt;
&lt;li&gt;如果参数签名列表和参数列表都没有传入，那么只能通过方法名称和方法实例的宿主类型匹配。&lt;/li&gt;
&lt;li&gt;考虑到方法匹配解析的过程相对耗时，需要把结果缓存起来。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;分析至此，可以基于反射，编写一个抽象的方法匹配器&lt;code&gt;BaseMethodMatcher&lt;/code&gt;，然后把获取宿主类信息的功能委托到子类：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class MethodMatchException extends RuntimeException {

    public MethodMatchException(String message) {
        super(message);
    }

    public MethodMatchException(String message, Throwable cause) {
        super(message, cause);
    }

    public MethodMatchException(Throwable cause) {
        super(cause);
    }
}

@Data
public class HostClassMethodInfo {

    private Class&amp;lt;?&amp;gt; hostClass;
    private Class&amp;lt;?&amp;gt; hostUserClass;
    private Object hostTarget;
}

@Slf4j
abstract class BaseMethodMatcher implements MethodMatcher {

    private final ConcurrentMap&amp;lt;MethodMatchInput, MethodMatchOutput&amp;gt; cache = Maps.newConcurrentMap();

    @Override
    public MethodMatchOutput selectOneBestMatchMethod(MethodMatchInput input) {
        return cache.computeIfAbsent(input, in -&amp;gt; {
            try {
                MethodMatchOutput output = new MethodMatchOutput();
                Class&amp;lt;?&amp;gt; interfaceClass = Class.forName(in.getInterfaceName());
                // 获取宿主类信息
                HostClassMethodInfo info = findHostClassMethodInfo(interfaceClass);
                List&amp;lt;Method&amp;gt; targetMethods = Lists.newArrayList();
                ReflectionUtils.doWithMethods(info.getHostUserClass(), targetMethods::add, method -&amp;gt; {
                    String methodName = method.getName();
                    Class&amp;lt;?&amp;gt; declaringClass = method.getDeclaringClass();
                    List&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; inputParameterTypes = Optional.ofNullable(in.getMethodArgumentSignatures())
                            .map(mas -&amp;gt; {
                                List&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; list = Lists.newArrayList();
                                mas.forEach(ma -&amp;gt; list.add(ClassUtils.resolveClassName(ma, null)));
                                return list;
                            }).orElse(Lists.newArrayList());
                    output.setParameterTypes(inputParameterTypes);
                    // 如果传入了参数签名列表，优先使用参数签名列表类型进行匹配
                    if (!inputParameterTypes.isEmpty()) {
                        List&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; parameterTypes = Lists.newArrayList(method.getParameterTypes());
                        return Objects.equals(methodName, in.getMethodName()) &amp;amp;&amp;amp;
                                Objects.equals(info.getHostUserClass(), declaringClass) &amp;amp;&amp;amp;
                                Objects.equals(parameterTypes, inputParameterTypes);
                    }
                    // 如果没有传入参数签名列表，那么使用参数的数量进行匹配
                    if (in.getMethodArgumentArraySize() &amp;gt; 0) {
                        List&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; parameterTypes = Lists.newArrayList(method.getParameterTypes());
                        return Objects.equals(methodName, in.getMethodName()) &amp;amp;&amp;amp;
                                Objects.equals(info.getHostUserClass(), declaringClass) &amp;amp;&amp;amp;
                                in.getMethodArgumentArraySize() == parameterTypes.size();

                    }
                    // 如果参数签名列表和参数列表都没有传入，那么只能通过方法名称和方法实例的宿主类型匹配
                    return Objects.equals(methodName, in.getMethodName()) &amp;amp;&amp;amp;
                            Objects.equals(info.getHostUserClass(), declaringClass);

                });
                if (targetMethods.size() != 1) {
                    throw new MethodMatchException(String.format(&quot;查找到目标方法数量不等于1,interface:%s,method:%s&quot;,
                            in.getInterfaceName(), in.getMethodName()));
                }
                Method targetMethod = targetMethods.get(0);
                output.setTargetClass(info.getHostClass());
                output.setTargetMethod(targetMethod);
                output.setTargetUserClass(info.getHostUserClass());
                output.setTarget(info.getHostTarget());
                return output;
            } catch (Exception e) {
                log.error(&quot;查找匹配度最高的方法失败,输入参数:{}&quot;, JSON.toJSONString(in), e);
                if (e instanceof MethodMatchException) {
                    throw (MethodMatchException) e;
                } else {
                    throw new MethodMatchException(e);
                }
            }
        });
    }

    /**
     * 获取宿主类的信息
     *
     * @param interfaceClass interfaceClass
     * @return HostClassMethodInfo
     */
    abstract HostClassMethodInfo findHostClassMethodInfo(Class&amp;lt;?&amp;gt; interfaceClass);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着，通过接口类型获取宿主类的功能就委托给&lt;code&gt;Spring&lt;/code&gt;实现，从&lt;code&gt;IOC&lt;/code&gt;容器中获取，定义&lt;code&gt;SpringMethodMatcher&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Component
public class SpringMethodMatcher extends BaseMethodMatcher implements BeanFactoryAware {

    private DefaultListableBeanFactory beanFactory;

    @Override
    public void setBeanFactory(@NonNull BeanFactory beanFactory) throws BeansException {
        this.beanFactory = (DefaultListableBeanFactory) beanFactory;
    }

    @Override
    HostClassMethodInfo findHostClassMethodInfo(Class&amp;lt;?&amp;gt; interfaceClass) {
        HostClassMethodInfo info = new HostClassMethodInfo();
        // 从容器中通过接口类型获取对应的实现,实现必须只有一个
        Object bean = beanFactory.getBean(interfaceClass);
        info.setHostTarget(bean);
        info.setHostClass(bean.getClass());
        info.setHostUserClass(ClassUtils.getUserClass(bean.getClass()));
        return info;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至此，目标方法匹配的模块已经编写完毕，接下来需要处理方法参数列表的反序列化。编写协议的时候，笔者把方法参数列表&lt;code&gt;methodArguments&lt;/code&gt;存放在&lt;code&gt;Object&lt;/code&gt;数组中，传输的时候序列化为&lt;code&gt;byte&lt;/code&gt;数组，经过协议解析之后，方法参数列表的实际类型为&lt;code&gt;ByteBuf&lt;/code&gt;数组（这是因为&lt;code&gt;Netty&lt;/code&gt;中的字节容器就是&lt;code&gt;ByteBuf&lt;/code&gt;），那么需要考虑把&lt;code&gt;ByteBuf&lt;/code&gt;数组转换为目标方法的参数类型实例。主要步骤如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如果方法参数列表为空，那么什么都不用做，也就是调用了无参数的方法。&lt;/li&gt;
&lt;li&gt;如果方法参数列表不为空同时方法参数类型列表不为空，优先选用方法参数类型列表进行转换。&lt;/li&gt;
&lt;li&gt;如果方法参数列表不为空同时方法参数类型列表为空，则使用&lt;code&gt;Method#getParameterTypes()&lt;/code&gt;得到的方法参数列表类型进行转换。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;定义一个方法参数转换器接口&lt;code&gt;MethodArgumentConverter&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface MethodArgumentConverter {

    ArgumentConvertOutput convert(ArgumentConvertInput input);
}

@Data
public class ArgumentConvertInput {

    /**
     * 目标方法
     */
    private Method method;

    /**
     * 方法参数类型列表
     */
    private List&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; parameterTypes;

    /**
     * 方法参数列表
     */
    private List&amp;lt;Object&amp;gt; arguments;
}

@Data
public class ArgumentConvertOutput {


    private Object[] arguments;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;方法参数转换器的默认实现如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Slf4j
@Component
public class DefaultMethodArgumentConverter implements MethodArgumentConverter {

    private final Serializer serializer = FastJsonSerializer.X;

    @Override
    public ArgumentConvertOutput convert(ArgumentConvertInput input) {
        ArgumentConvertOutput output = new ArgumentConvertOutput();
        try {
            if (null == input.getArguments() || input.getArguments().isEmpty()) {
                output.setArguments(new Object[0]);
                return output;
            }
            List&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; inputParameterTypes = input.getParameterTypes();
            int size = inputParameterTypes.size();
            if (size &amp;gt; 0) {
                Object[] arguments = new Object[size];
                for (int i = 0; i &amp;lt; size; i++) {
                    ByteBuf byteBuf = (ByteBuf) input.getArguments().get(i);
                    int readableBytes = byteBuf.readableBytes();
                    byte[] bytes = new byte[readableBytes];
                    byteBuf.readBytes(bytes);
                    arguments[i] = serializer.decode(bytes, inputParameterTypes.get(i));
                    byteBuf.release();
                }
                output.setArguments(arguments);
                return output;
            }
            Class&amp;lt;?&amp;gt;[] parameterTypes = input.getMethod().getParameterTypes();
            int len = parameterTypes.length;
            Object[] arguments = new Object[len];
            for (int i = 0; i &amp;lt; len; i++) {
                ByteBuf byteBuf = (ByteBuf) input.getArguments().get(i);
                int readableBytes = byteBuf.readableBytes();
                byte[] bytes = new byte[readableBytes];
                byteBuf.readBytes(bytes);
                arguments[i] = serializer.decode(bytes, parameterTypes[i]);
                byteBuf.release();
            }
            output.setArguments(arguments);
            return output;
        } catch (Exception e) {
            throw new ArgumentConvertException(e);
        }
    }
}    &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所有前置工作都完成了，现在编写一个&lt;code&gt;Server&lt;/code&gt;端的入站处理器&lt;code&gt;ServerHandler&lt;/code&gt;，暂时不做代码逻辑优化，只做实现，把反射调用的模块直接在此类中编写：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Component
@Slf4j
public class ServerHandler extends SimpleChannelInboundHandler&amp;lt;RequestMessagePacket&amp;gt; {

    @Autowired
    private MethodMatcher methodMatcher;

    @Autowired
    private MethodArgumentConverter methodArgumentConverter;

    @Override
    protected void channelRead0(ChannelHandlerContext ctx, RequestMessagePacket packet) throws Exception {
        log.info(&quot;服务端接收到:{}&quot;, packet);
        MethodMatchInput input = new MethodMatchInput();
        input.setInterfaceName(packet.getInterfaceName());
        input.setMethodArgumentSignatures(Optional.ofNullable(packet.getMethodArgumentSignatures())
                .map(Lists::newArrayList).orElse(Lists.newArrayList()));
        input.setMethodName(packet.getMethodName());
        Object[] methodArguments = packet.getMethodArguments();
        input.setMethodArgumentArraySize(null != methodArguments ? methodArguments.length : 0);
        MethodMatchOutput output = methodMatcher.selectOneBestMatchMethod(input);
        log.info(&quot;查找目标实现方法成功,目标类:{},宿主类:{},宿主方法:{}&quot;,
                output.getTargetClass().getCanonicalName(),
                output.getTargetUserClass().getCanonicalName(),
                output.getTargetMethod().getName()
        );
        Method targetMethod = output.getTargetMethod();
        ArgumentConvertInput convertInput = new ArgumentConvertInput();
        convertInput.setArguments(input.getMethodArgumentArraySize() &amp;gt; 0 ? Lists.newArrayList(methodArguments) : Lists.newArrayList());
        convertInput.setMethod(output.getTargetMethod());
        convertInput.setParameterTypes(output.getParameterTypes());
        ArgumentConvertOutput convertOutput = methodArgumentConverter.convert(convertInput);
        ReflectionUtils.makeAccessible(targetMethod);
        // 反射调用
        Object result = targetMethod.invoke(output.getTarget(), convertOutput.getArguments());
        ResponseMessagePacket response = new ResponseMessagePacket();
        response.setMagicNumber(packet.getMagicNumber());
        response.setVersion(packet.getVersion());
        response.setSerialNumber(packet.getSerialNumber());
        response.setAttachments(packet.getAttachments());
        response.setMessageType(MessageType.RESPONSE);
        response.setErrorCode(200L);
        response.setMessage(&quot;Success&quot;);
        response.setPayload(JSON.toJSONString(result));
        log.info(&quot;服务端输出:{}&quot;, JSON.toJSONString(response));
        ctx.writeAndFlush(response);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;编写一个&lt;code&gt;Server&lt;/code&gt;的启动类&lt;code&gt;ServerApplication&lt;/code&gt;，在&lt;code&gt;Spring&lt;/code&gt;容器启动之后，启动&lt;code&gt;Netty&lt;/code&gt;服务：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@SpringBootApplication(scanBasePackages = &quot;club.throwable.server&quot;)
@Slf4j
public class ServerApplication implements CommandLineRunner {

    @Value(&quot;${netty.port:9092}&quot;)
    private Integer nettyPort;

    @Autowired
    private ServerHandler serverHandler;

    public static void main(String[] args) throws Exception {
        SpringApplication.run(ServerApplication.class, args);
    }

    @Override
    public void run(String... args) throws Exception {
        int port = nettyPort;
        ServerBootstrap bootstrap = new ServerBootstrap();
        EventLoopGroup bossGroup = new NioEventLoopGroup();
        EventLoopGroup workerGroup = new NioEventLoopGroup();
        try {
            bootstrap.group(bossGroup, workerGroup)
                    .channel(NioServerSocketChannel.class)
                    .childHandler(new ChannelInitializer&amp;lt;SocketChannel&amp;gt;() {

                        @Override
                        protected void initChannel(SocketChannel ch) throws Exception {
                            ch.pipeline().addLast(new LengthFieldBasedFrameDecoder(1024, 0, 4, 0, 4));
                            ch.pipeline().addLast(new LengthFieldPrepender(4));
                            ch.pipeline().addLast(new RequestMessagePacketDecoder());
                            ch.pipeline().addLast(new ResponseMessagePacketEncoder(FastJsonSerializer.X));
                            ch.pipeline().addLast(serverHandler);
                        }
                    });
            ChannelFuture future = bootstrap.bind(port).sync();
            log.info(&quot;启动NettyServer[{}]成功...&quot;, port);
            future.channel().closeFuture().sync();
        } finally {
            workerGroup.shutdownGracefully();
            bossGroup.shutdownGracefully();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后，编写契约包和契约实现：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;- ch0-custom-rpc-protocol          项目根目录
  - club.throwable
    - utils                        工具类
    - protocol                     协议
    - exception                    异常
    - contract                     契约
      - HelloService               契约接口
    - server                       服务端
      - contract
        - DefaultHelloService      契约接口实现&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface HelloService {

    String sayHello(String name);
}

// 实现
@Service
public class DefaultHelloService implements HelloService {

    @Override
    public String sayHello(String name) {
        return String.format(&quot;%s say hello!&quot;, name);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;先启动服务端&lt;code&gt;ServerApplication&lt;/code&gt;，再启动上一节提到的&lt;code&gt;TestProtocolClient&lt;/code&gt;，输出结果：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;// 服务端日志
2020-01-15 00:05:57.898  INFO 14420 --- [           main] club.throwable.server.ServerApplication  : 启动NettyServer[9092]成功...
2020-01-15 00:06:05.980  INFO 14420 --- [ntLoopGroup-3-1] club.throwable.server.ServerHandler      : 服务端接收到:RequestMessagePacket(interfaceName=club.throwable.contract.HelloService, methodName=sayHello, methodArgumentSignatures=[java.lang.String], methodArguments=[PooledUnsafeDirectByteBuf(ridx: 0, widx: 6, cap: 6/139)])
2020-01-15 00:06:07.448  INFO 14420 --- [ntLoopGroup-3-1] club.throwable.server.ServerHandler      : 查找目标实现方法成功,目标类:club.throwable.server.contract.DefaultHelloService,宿主类:club.throwable.server.contract.DefaultHelloService,宿主方法:sayHello
2020-01-15 00:06:07.521  INFO 14420 --- [ntLoopGroup-3-1] club.throwable.server.ServerHandler      : 服务端输出:{&quot;attachments&quot;:{},&quot;errorCode&quot;:200,&quot;magicNumber&quot;:10086,&quot;message&quot;:&quot;Success&quot;,&quot;messageType&quot;:&quot;RESPONSE&quot;,&quot;payload&quot;:&quot;\&quot;doge say hello!\&quot;&quot;,&quot;serialNumber&quot;:&quot;65f01b8e89bb479b8a36a60bd6519617&quot;,&quot;version&quot;:1}

// 客户端日志
00:06:05.891 [main] INFO club.throwable.protocol.TestProtocolClient - 启动NettyClient[9092]成功...
...省略...
00:06:13.197 [nioEventLoopGroup-2-1] INFO club.throwable.protocol.TestProtocolClient - 接收到来自服务端的响应消息,消息内容:{&quot;attachments&quot;:{},&quot;errorCode&quot;:200,&quot;magicNumber&quot;:10086,&quot;message&quot;:&quot;Success&quot;,&quot;messageType&quot;:&quot;RESPONSE&quot;,&quot;payload&quot;:&quot;\&quot;doge say hello!\&quot;&quot;,&quot;serialNumber&quot;:&quot;65f01b8e89bb479b8a36a60bd6519617&quot;,&quot;version&quot;:1}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可见&lt;code&gt;RPC&lt;/code&gt;调用成功。&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;编写&lt;code&gt;RPC&lt;/code&gt;的&lt;code&gt;Server&lt;/code&gt;端技巧在于处理目标方法和宿主类的查找，在转换方法参数的时候，需要考虑简化处理和提高效率，剩下的就是做好异常处理和模块封装。限于篇幅，后面会先分析&lt;code&gt;Client&lt;/code&gt;端的处理，再分析心跳处理、服务端优化、甚至是对接注册中心等等，在&lt;code&gt;Netty&lt;/code&gt;、&lt;code&gt;SpringBoot&lt;/code&gt;等优秀框架的加持下编写一个&lt;code&gt;RPC&lt;/code&gt;框架其实并不困难，困难的是性能优化和生态圈的支持。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Demo&lt;/code&gt;项目地址：&lt;/p&gt;
&lt;p&gt;（本文完 c-1-d e-a-20200115）&lt;/p&gt;
</description>
<pubDate>Tue, 14 Jan 2020 16:16:00 +0000</pubDate>
<dc:creator>throwable</dc:creator>
<og:description>前提 前置文章： ： &amp;quot;《基于Netty和SpringBoot实现一个轻量级RPC框架 协议篇》&amp;quot; ： &amp;quot;《基于Netty和SpringBoot实现一个轻量级RPC框架</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/throwable/p/12194713.html</dc:identifier>
</item>
<item>
<title>深入理解 Java 并发锁 - 静默虚空</title>
<link>http://www.cnblogs.com/jingmoxukong/p/12194712.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jingmoxukong/p/12194712.html</guid>
<description>&lt;blockquote readability=&quot;4.2&quot;&gt;
&lt;p&gt;&lt;strong&gt;📦 本文以及示例源码已归档在 &lt;a href=&quot;https://dunwu.github.io/javacore/#/&quot;&gt;javacore&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一并发锁简介&quot;&gt;一、并发锁简介&lt;/h2&gt;
&lt;p&gt;确保线程安全最常见的做法是利用锁机制（&lt;code&gt;Lock&lt;/code&gt;、&lt;code&gt;sychronized&lt;/code&gt;）来对共享数据做互斥同步，这样在同一个时刻，只有一个线程可以执行某个方法或者某个代码块，那么操作必然是原子性的，线程安全的。&lt;/p&gt;
&lt;p&gt;在工作、面试中，经常会听到各种五花八门的锁，听的人云里雾里。锁的概念术语很多，它们是针对不同的问题所提出的，通过简单的梳理，也不难理解。&lt;/p&gt;
&lt;h3 id=&quot;可重入锁&quot;&gt;可重入锁&lt;/h3&gt;
&lt;p&gt;可重入锁又名递归锁，是指 &lt;strong&gt;同一个线程在外层方法获取了锁，在进入内层方法会自动获取锁&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可重入锁可以在一定程度上避免死锁&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;ReentrantLock&lt;/code&gt; 、&lt;code&gt;ReentrantReadWriteLock&lt;/code&gt; 是可重入锁&lt;/strong&gt;。这点，从其命名也不难看出。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;synchronized&lt;/code&gt; 也是一个可重入锁&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;synchronized void setA() throws Exception{
    Thread.sleep(1000);
    setB();
}

synchronized void setB() throws Exception{
    Thread.sleep(1000);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码就是一个典型场景：如果使用的锁不是可重入锁的话，&lt;code&gt;setB&lt;/code&gt; 可能不会被当前线程执行，从而造成死锁。&lt;/p&gt;
&lt;h3 id=&quot;公平锁与非公平锁&quot;&gt;公平锁与非公平锁&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;公平锁&lt;/strong&gt; - 公平锁是指 &lt;strong&gt;多线程按照申请锁的顺序来获取锁&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;非公平锁&lt;/strong&gt; - 非公平锁是指 &lt;strong&gt;多线程不按照申请锁的顺序来获取锁&lt;/strong&gt; 。这就可能会出现优先级反转（后来者居上）或者饥饿现象（某线程总是抢不过别的线程，导致始终无法执行）。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;公平锁为了保证线程申请顺序，势必要付出一定的性能代价，因此其吞吐量一般低于非公平锁。&lt;/p&gt;
&lt;p&gt;公平锁与非公平锁 在 Java 中的典型实现：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;synchronized&lt;/code&gt; 只支持非公平锁&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;ReentrantLock&lt;/code&gt; 、&lt;code&gt;ReentrantReadWriteLock&lt;/code&gt;，默认是非公平锁，但支持公平锁&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;独享锁与共享锁&quot;&gt;独享锁与共享锁&lt;/h3&gt;
&lt;p&gt;独享锁与共享锁是一种广义上的说法，从实际用途上来看，也常被称为互斥锁与读写锁。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;独享锁&lt;/strong&gt; - 独享锁是指 &lt;strong&gt;锁一次只能被一个线程所持有&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;共享锁&lt;/strong&gt; - 共享锁是指 &lt;strong&gt;锁可被多个线程所持有&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;独享锁与共享锁在 Java 中的典型实现：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;synchronized&lt;/code&gt; 、&lt;code&gt;ReentrantLock&lt;/code&gt; 只支持独享锁&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;ReentrantReadWriteLock&lt;/code&gt; 其写锁是独享锁，其读锁是共享锁&lt;/strong&gt;。读锁是共享锁使得并发读是非常高效的，读写，写读 ，写写的过程是互斥的。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;悲观锁与乐观锁&quot;&gt;悲观锁与乐观锁&lt;/h3&gt;
&lt;p&gt;乐观锁与悲观锁不是指具体的什么类型的锁，而是&lt;strong&gt;处理并发同步的策略&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;悲观锁&lt;/strong&gt; - 悲观锁对于并发采取悲观的态度，认为：&lt;strong&gt;不加锁的并发操作一定会出问题&lt;/strong&gt;。&lt;strong&gt;悲观锁适合写操作频繁的场景&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;乐观锁&lt;/strong&gt; - 乐观锁对于并发采取乐观的态度，认为：&lt;strong&gt;不加锁的并发操作也没什么问题。对于同一个数据的并发操作，是不会发生修改的&lt;/strong&gt;。在更新数据的时候，会采用不断尝试更新的方式更新数据。&lt;strong&gt;乐观锁适合读多写少的场景&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;悲观锁与乐观锁在 Java 中的典型实现：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;悲观锁在 Java 中的应用就是通过使用 &lt;code&gt;synchronized&lt;/code&gt; 和 &lt;code&gt;Lock&lt;/code&gt; 显示加锁来进行互斥同步，这是一种阻塞同步。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;乐观锁在 Java 中的应用就是采用 CAS 机制（CAS 操作通过 &lt;code&gt;Unsafe&lt;/code&gt; 类提供，但这个类不直接暴露为 API，所以都是间接使用，如各种原子类）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;轻量级锁重量级锁与偏向锁&quot;&gt;轻量级锁、重量级锁与偏向锁&lt;/h3&gt;
&lt;p&gt;所谓轻量级锁与重量级锁，指的是锁控制粒度的粗细。显然，控制粒度越细，阻塞开销越小，并发性也就越高。&lt;/p&gt;
&lt;p&gt;Java 1.6 以前，重量级锁一般指的是 &lt;code&gt;synchronized&lt;/code&gt; ，而轻量级锁指的是 &lt;code&gt;volatile&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;Java 1.6 以后，针对 &lt;code&gt;synchronized&lt;/code&gt; 做了大量优化，引入 4 种锁状态： 无锁状态、偏向锁、轻量级锁和重量级锁。锁可以单向的从偏向锁升级到轻量级锁，再从轻量级锁升级到重量级锁 。&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li&gt;&lt;strong&gt;偏向锁&lt;/strong&gt; - 偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;轻量级锁&lt;/strong&gt; - 是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;重量级锁&lt;/strong&gt; - 是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;分段锁&quot;&gt;分段锁&lt;/h3&gt;
&lt;p&gt;分段锁其实是一种锁的设计，并不是具体的一种锁。所谓分段锁，就是把锁的对象分成多段，每段独立控制，使得锁粒度更细，减少阻塞开销，从而提高并发性。这其实很好理解，就像高速公路上的收费站，如果只有一个收费口，那所有的车只能排成一条队缴费；如果有多个收费口，就可以分流了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Hashtable&lt;/code&gt; 使用 &lt;code&gt;synchronized&lt;/code&gt; 修饰方法来保证线程安全性，那么面对线程的访问，Hashtable 就会锁住整个对象，所有的其它线程只能等待，这种阻塞方式的吞吐量显然很低。&lt;/p&gt;
&lt;p&gt;Java 1.7 以前的 &lt;code&gt;ConcurrentHashMap&lt;/code&gt; 就是分段锁的典型案例。&lt;code&gt;ConcurrentHashMap&lt;/code&gt; 维护了一个 &lt;code&gt;Segment&lt;/code&gt; 数组，一般称为分段桶。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;final Segment&amp;lt;K,V&amp;gt;[] segments;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当有线程访问 &lt;code&gt;ConcurrentHashMap&lt;/code&gt; 的数据时，&lt;code&gt;ConcurrentHashMap&lt;/code&gt; 会先根据 hashCode 计算出数据在哪个桶（即哪个 Segment），然后锁住这个 &lt;code&gt;Segment&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;显示锁和内置锁&quot;&gt;显示锁和内置锁&lt;/h3&gt;
&lt;p&gt;Java 1.5 之前，协调对共享对象的访问时可以使用的机制只有 &lt;code&gt;synchronized&lt;/code&gt; 和 &lt;code&gt;volatile&lt;/code&gt;。这两个都属于内置锁，即锁的申请和释放都是由 JVM 所控制。&lt;/p&gt;
&lt;p&gt;Java 1.5 之后，增加了新的机制：&lt;code&gt;ReentrantLock&lt;/code&gt;、&lt;code&gt;ReentrantReadWriteLock&lt;/code&gt; ，这类锁的申请和释放都可以由程序所控制，所以常被称为显示锁。&lt;/p&gt;
&lt;blockquote readability=&quot;7.5754189944134&quot;&gt;
&lt;p&gt;💡 &lt;code&gt;synchronized&lt;/code&gt; 的用法和原理可以参考：&lt;a href=&quot;https://github.com/dunwu/javacore/blob/master/docs/concurrent/java-concurrent-basic-mechanism.md#%E4%BA%8Csynchronized&quot;&gt;Java 并发基础机制 - synchronized&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;🔔 注意：如果不需要 &lt;code&gt;ReentrantLock&lt;/code&gt;、&lt;code&gt;ReentrantReadWriteLock&lt;/code&gt; 所提供的高级同步特性，&lt;strong&gt;应该优先考虑使用 &lt;code&gt;synchronized&lt;/code&gt;&lt;/strong&gt; 。理由如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Java 1.6 以后，&lt;code&gt;synchronized&lt;/code&gt; 做了大量的优化，其性能已经与 &lt;code&gt;ReentrantLock&lt;/code&gt;、&lt;code&gt;ReentrantReadWriteLock&lt;/code&gt; 基本上持平。&lt;/li&gt;
&lt;li&gt;从趋势来看，Java 未来更可能会优化 &lt;code&gt;synchronized&lt;/code&gt; ，而不是 &lt;code&gt;ReentrantLock&lt;/code&gt;、&lt;code&gt;ReentrantReadWriteLock&lt;/code&gt; ，因为 &lt;code&gt;synchronized&lt;/code&gt; 是 JVM 内置属性，它能执行一些优化。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ReentrantLock&lt;/code&gt;、&lt;code&gt;ReentrantReadWriteLock&lt;/code&gt; 申请和释放锁都是由程序控制，如果使用不当，可能造成死锁，这是很危险的。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;以下对比一下显示锁和内置锁的差异：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;主动获取锁和释放锁&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;synchronized&lt;/code&gt; 不能主动获取锁和释放锁。获取锁和释放锁都是 JVM 控制的。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ReentrantLock&lt;/code&gt; 可以主动获取锁和释放锁。（如果忘记释放锁，就可能产生死锁）。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;响应中断&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;synchronized&lt;/code&gt; 不能响应中断。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ReentrantLock&lt;/code&gt; 可以响应中断。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;超时机制&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;synchronized&lt;/code&gt; 没有超时机制。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ReentrantLock&lt;/code&gt; 有超时机制。&lt;code&gt;ReentrantLock&lt;/code&gt; 可以设置超时时间，超时后自动释放锁，避免一直等待。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;支持公平锁&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;synchronized&lt;/code&gt; 只支持非公平锁。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ReentrantLock&lt;/code&gt; 支持非公平锁和公平锁。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;是否支持共享&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;被 &lt;code&gt;synchronized&lt;/code&gt; 修饰的方法或代码块，只能被一个线程访问（独享）。如果这个线程被阻塞，其他线程也只能等待&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ReentrantLock&lt;/code&gt; 可以基于 &lt;code&gt;Condition&lt;/code&gt; 灵活的控制同步条件。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;是否支持读写分离&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;synchronized&lt;/code&gt; 不支持读写锁分离；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ReentrantReadWriteLock&lt;/code&gt; 支持读写锁，从而使阻塞读写的操作分开，有效提高并发性。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;二aqs&quot;&gt;二、AQS&lt;/h2&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;code&gt;AbstractQueuedSynchronizer&lt;/code&gt;（简称 &lt;strong&gt;AQS&lt;/strong&gt;）是&lt;strong&gt;队列同步器&lt;/strong&gt;，顾名思义，其主要作用是处理同步。它是并发锁和很多同步工具类的实现基石（如 &lt;code&gt;ReentrantLock&lt;/code&gt;、&lt;code&gt;ReentrantReadWriteLock&lt;/code&gt;、&lt;code&gt;Semaphore&lt;/code&gt; 等）。&lt;/p&gt;
&lt;p&gt;因此，要想深入理解 &lt;code&gt;ReentrantLock&lt;/code&gt;、&lt;code&gt;ReentrantReadWriteLock&lt;/code&gt; 等并发锁和同步工具，必须先理解 AQS 的要点和原理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;aqs-的要点&quot;&gt;AQS 的要点&lt;/h3&gt;
&lt;p&gt;在 &lt;code&gt;java.util.concurrent.locks&lt;/code&gt; 包中的相关锁(常用的有 &lt;code&gt;ReentrantLock&lt;/code&gt;、 &lt;code&gt;ReadWriteLock&lt;/code&gt;)都是基于 AQS 来实现。这些锁都没有直接继承 AQS，而是定义了一个 &lt;code&gt;Sync&lt;/code&gt; 类去继承 AQS。为什么要这样呢？因为锁面向的是使用用户，而同步器面向的则是线程控制，那么在锁的实现中聚合同步器而不是直接继承 AQS 就可以很好的隔离二者所关注的事情。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AQS 提供了对独享锁与共享锁的支持&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&quot;独享锁-api&quot;&gt;独享锁 API&lt;/h4&gt;
&lt;p&gt;获取、释放独享锁的主要 API 如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public final void acquire(int arg)
public final void acquireInterruptibly(int arg)
public final boolean tryAcquireNanos(int arg, long nanosTimeout)
public final boolean release(int arg)&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;acquire&lt;/code&gt; - 获取独占锁。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;acquireInterruptibly&lt;/code&gt; - 获取可中断的独占锁。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tryAcquireNanos&lt;/code&gt; - 尝试在指定时间内获取可中断的独占锁。在以下三种情况下回返回：
&lt;ul&gt;&lt;li&gt;在超时时间内，当前线程成功获取了锁；&lt;/li&gt;
&lt;li&gt;当前线程在超时时间内被中断；&lt;/li&gt;
&lt;li&gt;超时时间结束，仍未获得锁返回 false。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;release&lt;/code&gt; - 释放独占锁。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;共享锁-api&quot;&gt;共享锁 API&lt;/h4&gt;
&lt;p&gt;获取、释放共享锁的主要 API 如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public final void acquireShared(int arg)
public final void acquireSharedInterruptibly(int arg)
public final boolean tryAcquireSharedNanos(int arg, long nanosTimeout)
public final boolean releaseShared(int arg)&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;acquireShared&lt;/code&gt; - 获取共享锁。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;acquireSharedInterruptibly&lt;/code&gt; - 获取可中断的共享锁。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tryAcquireSharedNanos&lt;/code&gt; - 尝试在指定时间内获取可中断的共享锁。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;release&lt;/code&gt; - 释放共享锁。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;aqs-的原理&quot;&gt;AQS 的原理&lt;/h3&gt;
&lt;h4 id=&quot;aqs-的数据结构&quot;&gt;AQS 的数据结构&lt;/h4&gt;
&lt;p&gt;阅读 AQS 的源码，可以发现：AQS 继承自 &lt;code&gt;AbstractOwnableSynchronize&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public abstract class AbstractQueuedSynchronizer
    extends AbstractOwnableSynchronizer
    implements java.io.Serializable {

    /** 等待队列的队头，懒加载。只能通过 setHead 方法修改。 */
    private transient volatile Node head;
    /** 等待队列的队尾，懒加载。只能通过 enq 方法添加新的等待节点。*/
    private transient volatile Node tail;
    /** 同步状态 */
    private volatile int state;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;state&lt;/code&gt; - AQS 使用一个整型的 &lt;code&gt;volatile&lt;/code&gt; 变量来 &lt;strong&gt;维护同步状态&lt;/strong&gt;。
&lt;ul&gt;&lt;li&gt;这个整数状态的意义由子类来赋予，如&lt;code&gt;ReentrantLock&lt;/code&gt; 中该状态值表示所有者线程已经重复获取该锁的次数，&lt;code&gt;Semaphore&lt;/code&gt; 中该状态值表示剩余的许可数量。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;head&lt;/code&gt; 和 &lt;code&gt;tail&lt;/code&gt; - AQS &lt;strong&gt;维护了一个 &lt;code&gt;Node&lt;/code&gt; 类型（AQS 的内部类）的双链表来完成同步状态的管理&lt;/strong&gt;。这个双链表是一个双向的 FIFO 队列，通过 &lt;code&gt;head&lt;/code&gt; 和 &lt;code&gt;tail&lt;/code&gt; 指针进行访问。当 &lt;strong&gt;有线程获取锁失败后，就被添加到队列末尾&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/318837/202001/318837-20200115001414997-1133782389.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再来看一下 &lt;code&gt;Node&lt;/code&gt; 的源码&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;static final class Node {
    /** 该等待同步的节点处于共享模式 */
    static final Node SHARED = new Node();
    /** 该等待同步的节点处于独占模式 */
    static final Node EXCLUSIVE = null;

    /** 线程等待状态，状态值有: 0、1、-1、-2、-3 */
    volatile int waitStatus;
    static final int CANCELLED =  1;
    static final int SIGNAL    = -1;
    static final int CONDITION = -2;
    static final int PROPAGATE = -3;

    /** 前驱节点 */
    volatile Node prev;
    /** 后继节点 */
    volatile Node next;
    /** 等待锁的线程 */
    volatile Thread thread;

    /** 和节点是否共享有关 */
    Node nextWaiter;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;很显然，Node 是一个双链表结构。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;waitStatus&lt;/code&gt; - &lt;code&gt;Node&lt;/code&gt; 使用一个整型的 &lt;code&gt;volatile&lt;/code&gt; 变量来 维护 AQS 同步队列中线程节点的状态。&lt;code&gt;waitStatus&lt;/code&gt; 有五个状态值：
&lt;ul&gt;&lt;li&gt;&lt;code&gt;CANCELLED(1)&lt;/code&gt; - 此状态表示：该节点的线程可能由于超时或被中断而 &lt;strong&gt;处于被取消(作废)状态&lt;/strong&gt;，一旦处于这个状态，表示这个节点应该从等待队列中移除。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SIGNAL(-1)&lt;/code&gt; - 此状态表示：&lt;strong&gt;后继节点会被挂起&lt;/strong&gt;，因此在当前节点释放锁或被取消之后，必须唤醒(&lt;code&gt;unparking&lt;/code&gt;)其后继结点。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CONDITION(-2)&lt;/code&gt; - 此状态表示：该节点的线程 &lt;strong&gt;处于等待条件状态&lt;/strong&gt;，不会被当作是同步队列上的节点，直到被唤醒(&lt;code&gt;signal&lt;/code&gt;)，设置其值为 0，再重新进入阻塞状态。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PROPAGATE(-3)&lt;/code&gt; - 此状态表示：下一个 &lt;code&gt;acquireShared&lt;/code&gt; 应无条件传播。&lt;/li&gt;
&lt;li&gt;0 - 非以上状态。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;独占锁的获取和释放&quot;&gt;独占锁的获取和释放&lt;/h4&gt;
&lt;h5 id=&quot;获取独占锁&quot;&gt;获取独占锁&lt;/h5&gt;
&lt;p&gt;AQS 中使用 &lt;code&gt;acquire(int arg)&lt;/code&gt; 方法获取独占锁，其大致流程如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;先尝试获取同步状态，如果获取同步状态成功，则结束方法，直接返回。&lt;/li&gt;
&lt;li&gt;如果获取同步状态不成功，AQS 会不断尝试利用 CAS 操作将当前线程插入等待同步队列的队尾，直到成功为止。&lt;/li&gt;
&lt;li&gt;接着，不断尝试为等待队列中的线程节点获取独占锁。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/318837/202001/318837-20200115001415216-348571953.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/318837/202001/318837-20200115001415388-1586733197.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;详细流程可以用下图来表示，请结合源码来理解（一图胜千言）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/318837/202001/318837-20200115001416401-2133116045.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;释放独占锁&quot;&gt;释放独占锁&lt;/h5&gt;
&lt;p&gt;AQS 中使用 &lt;code&gt;release(int arg)&lt;/code&gt; 方法释放独占锁，其大致流程如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;先尝试获取解锁线程的同步状态，如果获取同步状态不成功，则结束方法，直接返回。&lt;/li&gt;
&lt;li&gt;如果获取同步状态成功，AQS 会尝试唤醒当前线程节点的后继节点。&lt;/li&gt;
&lt;/ol&gt;&lt;h5 id=&quot;获取可中断的独占锁&quot;&gt;获取可中断的独占锁&lt;/h5&gt;
&lt;p&gt;AQS 中使用 &lt;code&gt;acquireInterruptibly(int arg)&lt;/code&gt; 方法获取可中断的独占锁。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;acquireInterruptibly(int arg)&lt;/code&gt; 实现方式&lt;strong&gt;相较于获取独占锁方法（ &lt;code&gt;acquire&lt;/code&gt;）非常相似&lt;/strong&gt;，区别仅在于它会&lt;strong&gt;通过 &lt;code&gt;Thread.interrupted&lt;/code&gt; 检测当前线程是否被中断&lt;/strong&gt;，如果是，则立即抛出中断异常（&lt;code&gt;InterruptedException&lt;/code&gt;）。&lt;/p&gt;
&lt;h5 id=&quot;获取超时等待式的独占锁&quot;&gt;获取超时等待式的独占锁&lt;/h5&gt;
&lt;p&gt;AQS 中使用 &lt;code&gt;tryAcquireNanos(int arg)&lt;/code&gt; 方法获取超时等待的独占锁。&lt;/p&gt;
&lt;p&gt;doAcquireNanos 的实现方式 &lt;strong&gt;相较于获取独占锁方法（ &lt;code&gt;acquire&lt;/code&gt;）非常相似&lt;/strong&gt;，区别在于它会根据超时时间和当前时间计算出截止时间。在获取锁的流程中，会不断判断是否超时，如果超时，直接返回 false；如果没超时，则用 &lt;code&gt;LockSupport.parkNanos&lt;/code&gt; 来阻塞当前线程。&lt;/p&gt;
&lt;h4 id=&quot;共享锁的获取和释放&quot;&gt;共享锁的获取和释放&lt;/h4&gt;
&lt;h5 id=&quot;获取共享锁&quot;&gt;获取共享锁&lt;/h5&gt;
&lt;p&gt;AQS 中使用 &lt;code&gt;acquireShared(int arg)&lt;/code&gt; 方法获取共享锁。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;acquireShared&lt;/code&gt; 方法和 &lt;code&gt;acquire&lt;/code&gt; 方法的逻辑很相似，区别仅在于自旋的条件以及节点出队的操作有所不同。&lt;/p&gt;
&lt;p&gt;成功获得共享锁的条件如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;tryAcquireShared(arg)&lt;/code&gt; 返回值大于等于 0 （这意味着共享锁的 permit 还没有用完）。&lt;/li&gt;
&lt;li&gt;当前节点的前驱节点是头结点。&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;释放共享锁&quot;&gt;释放共享锁&lt;/h5&gt;
&lt;p&gt;AQS 中使用 &lt;code&gt;releaseShared(int arg)&lt;/code&gt; 方法释放共享锁。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;releaseShared&lt;/code&gt; 首先会尝试释放同步状态，如果成功，则解锁一个或多个后继线程节点。释放共享锁和释放独享锁流程大体相似，区别在于：&lt;/p&gt;
&lt;p&gt;对于独享模式，如果需要 SIGNAL，释放仅相当于调用头节点的 &lt;code&gt;unparkSuccessor&lt;/code&gt;。&lt;/p&gt;
&lt;h5 id=&quot;获取可中断的共享锁&quot;&gt;获取可中断的共享锁&lt;/h5&gt;
&lt;p&gt;AQS 中使用 &lt;code&gt;acquireSharedInterruptibly(int arg)&lt;/code&gt; 方法获取可中断的共享锁。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;acquireSharedInterruptibly&lt;/code&gt; 方法与 &lt;code&gt;acquireInterruptibly&lt;/code&gt; 几乎一致，不再赘述。&lt;/p&gt;
&lt;h5 id=&quot;获取超时等待式的共享锁&quot;&gt;获取超时等待式的共享锁&lt;/h5&gt;
&lt;p&gt;AQS 中使用 &lt;code&gt;tryAcquireSharedNanos(int arg)&lt;/code&gt; 方法获取超时等待式的共享锁。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;tryAcquireSharedNanos&lt;/code&gt; 方法与 &lt;code&gt;tryAcquireNanos&lt;/code&gt; 几乎一致，不再赘述。&lt;/p&gt;
&lt;h2 id=&quot;三reentrantlock&quot;&gt;三、ReentrantLock&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;code&gt;ReentrantLock&lt;/code&gt; 类是 &lt;code&gt;Lock&lt;/code&gt; 接口的具体实现，它是一个&lt;strong&gt;可重入锁&lt;/strong&gt;。与内置锁 &lt;code&gt;synchronized&lt;/code&gt; 不同，&lt;strong&gt;&lt;code&gt;ReentrantLock&lt;/code&gt; 提供了一组无条件的、可轮询的、定时的以及可中断的锁操作&lt;/strong&gt;，所有获取锁、释放锁的操作都是显式的操作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;reentrantlock-的特性&quot;&gt;ReentrantLock 的特性&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;ReentrantLock&lt;/code&gt; 的特性如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;ReentrantLock&lt;/code&gt; 提供了与 &lt;code&gt;synchronized&lt;/code&gt; 相同的互斥性、内存可见性和可重入性&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ReentrantLock&lt;/code&gt; 支持公平锁和非公平锁（默认）两种模式。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ReentrantLock&lt;/code&gt; 实现了 &lt;code&gt;Lock&lt;/code&gt; 接口，支持了 &lt;code&gt;synchronized&lt;/code&gt; 所不具备的&lt;strong&gt;灵活性&lt;/strong&gt;。
&lt;ul&gt;&lt;li&gt;&lt;code&gt;synchronized&lt;/code&gt; 无法中断一个正在等待获取锁的线程&lt;/li&gt;
&lt;li&gt;&lt;code&gt;synchronized&lt;/code&gt; 无法在请求获取一个锁时无休止地等待&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;Lock&lt;/code&gt; 的接口定义如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface Lock {
    void lock();
    void lockInterruptibly() throws InterruptedException;
    boolean tryLock();
    boolean tryLock(long time, TimeUnit unit) throws InterruptedException;
    void unlock();
    Condition newCondition();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;lock()&lt;/code&gt; - &lt;strong&gt;获取锁&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unlock()&lt;/code&gt; - &lt;strong&gt;释放锁&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tryLock()&lt;/code&gt; - &lt;strong&gt;尝试获取锁&lt;/strong&gt;，仅在调用时锁未被另一个线程持有的情况下，才获取该锁。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tryLock(long time, TimeUnit unit)&lt;/code&gt; - 和 &lt;code&gt;tryLock()&lt;/code&gt; 类似，区别仅在于限定时间，如果限定时间内未获取到锁，视为失败。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lockInterruptibly()&lt;/code&gt; - 锁未被另一个线程持有，且线程没有被中断的情况下，才能获取锁。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;newCondition()&lt;/code&gt; - 返回一个绑定到 &lt;code&gt;Lock&lt;/code&gt; 对象上的 &lt;code&gt;Condition&lt;/code&gt; 实例。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;reentrantlock-的用法&quot;&gt;ReentrantLock 的用法&lt;/h3&gt;
&lt;p&gt;前文了解了 &lt;code&gt;ReentrantLock&lt;/code&gt; 的特性，接下来，我们要讲述其具体用法。&lt;/p&gt;
&lt;h4 id=&quot;reentrantlock-的构造方法&quot;&gt;ReentrantLock 的构造方法&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;ReentrantLock&lt;/code&gt; 有两个构造方法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public ReentrantLock() {}
public ReentrantLock(boolean fair) {}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;ReentrantLock()&lt;/code&gt; - 默认构造方法会初始化一个&lt;strong&gt;非公平锁（NonfairSync）&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ReentrantLock(boolean)&lt;/code&gt; - &lt;code&gt;new ReentrantLock(true)&lt;/code&gt; 会初始化一个&lt;strong&gt;公平锁（FairSync）&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;lock-和-unlock-方法&quot;&gt;lock 和 unlock 方法&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;lock()&lt;/code&gt; - &lt;strong&gt;无条件获取锁&lt;/strong&gt;。如果当前线程无法获取锁，则当前线程进入休眠状态不可用，直至当前线程获取到锁。如果该锁没有被另一个线程持有，则获取该锁并立即返回，将锁的持有计数设置为 1。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unlock()&lt;/code&gt; - 用于&lt;strong&gt;释放锁&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;🔔 注意：请务必牢记，获取锁操作 &lt;strong&gt;&lt;code&gt;lock()&lt;/code&gt; 必须在 &lt;code&gt;try catch&lt;/code&gt; 块中进行，并且将释放锁操作 &lt;code&gt;unlock()&lt;/code&gt; 放在 &lt;code&gt;finally&lt;/code&gt; 块中进行，以保证锁一定被被释放，防止死锁的发生&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;示例：&lt;code&gt;ReentrantLock&lt;/code&gt; 的基本操作&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ReentrantLockDemo {

    public static void main(String[] args) {
        Task task = new Task();
        MyThread tA = new MyThread(&quot;Thread-A&quot;, task);
        MyThread tB = new MyThread(&quot;Thread-B&quot;, task);
        MyThread tC = new MyThread(&quot;Thread-C&quot;, task);
        tA.start();
        tB.start();
        tC.start();
    }

    static class MyThread extends Thread {

        private Task task;

        public MyThread(String name, Task task) {
            super(name);
            this.task = task;
        }

        @Override
        public void run() {
            task.execute();
        }

    }

    static class Task {

        private ReentrantLock lock = new ReentrantLock();

        public void execute() {
            lock.lock();
            try {
                for (int i = 0; i &amp;lt; 3; i++) {
                    System.out.println(lock.toString());

                    // 查询当前线程 hold 住此锁的次数
                    System.out.println(&quot;\t holdCount: &quot; + lock.getHoldCount());

                    // 查询正等待获取此锁的线程数
                    System.out.println(&quot;\t queuedLength: &quot; + lock.getQueueLength());

                    // 是否为公平锁
                    System.out.println(&quot;\t isFair: &quot; + lock.isFair());

                    // 是否被锁住
                    System.out.println(&quot;\t isLocked: &quot; + lock.isLocked());

                    // 是否被当前线程持有锁
                    System.out.println(&quot;\t isHeldByCurrentThread: &quot; + lock.isHeldByCurrentThread());

                    try {
                        Thread.sleep(500);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            } finally {
                lock.unlock();
            }
        }

    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;java.util.concurrent.locks.ReentrantLock@64fcd88a[Locked by thread Thread-A]
     holdCount: 1
     queuedLength: 2
     isFair: false
     isLocked: true
     isHeldByCurrentThread: true
java.util.concurrent.locks.ReentrantLock@64fcd88a[Locked by thread Thread-C]
     holdCount: 1
     queuedLength: 1
     isFair: false
     isLocked: true
     isHeldByCurrentThread: true
// ...&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;trylock-方法&quot;&gt;tryLock 方法&lt;/h4&gt;
&lt;p&gt;与无条件获取锁相比，tryLock 有更完善的容错机制。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;tryLock()&lt;/code&gt; - &lt;strong&gt;可轮询获取锁&lt;/strong&gt;。如果成功，则返回 true；如果失败，则返回 false。也就是说，这个方法&lt;strong&gt;无论成败都会立即返回&lt;/strong&gt;，获取不到锁（锁已被其他线程获取）时不会一直等待。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tryLock(long, TimeUnit)&lt;/code&gt; - &lt;strong&gt;可定时获取锁&lt;/strong&gt;。和 &lt;code&gt;tryLock()&lt;/code&gt; 类似，区别仅在于这个方法在&lt;strong&gt;获取不到锁时会等待一定的时间&lt;/strong&gt;，在时间期限之内如果还获取不到锁，就返回 false。如果如果一开始拿到锁或者在等待期间内拿到了锁，则返回 true。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;示例：&lt;code&gt;ReentrantLock&lt;/code&gt; 的 &lt;code&gt;tryLock()&lt;/code&gt; 操作&lt;/p&gt;
&lt;p&gt;修改上个示例中的 &lt;code&gt;execute()&lt;/code&gt; 方法&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void execute() {
    if (lock.tryLock()) {
        try {
            for (int i = 0; i &amp;lt; 3; i++) {
               // 略...
            }
        } finally {
            lock.unlock();
        }
    } else {
        System.out.println(Thread.currentThread().getName() + &quot; 获取锁失败&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;示例：&lt;code&gt;ReentrantLock&lt;/code&gt; 的 &lt;code&gt;tryLock(long, TimeUnit)&lt;/code&gt; 操作&lt;/p&gt;
&lt;p&gt;修改上个示例中的 &lt;code&gt;execute()&lt;/code&gt; 方法&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void execute() {
    try {
        if (lock.tryLock(2, TimeUnit.SECONDS)) {
            try {
                for (int i = 0; i &amp;lt; 3; i++) {
                    // 略...
                }
            } finally {
                lock.unlock();
            }
        } else {
            System.out.println(Thread.currentThread().getName() + &quot; 获取锁失败&quot;);
        }
    } catch (InterruptedException e) {
        System.out.println(Thread.currentThread().getName() + &quot; 获取锁超时&quot;);
        e.printStackTrace();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;lockinterruptibly-方法&quot;&gt;lockInterruptibly 方法&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;lockInterruptibly()&lt;/code&gt; - &lt;strong&gt;可中断获取锁&lt;/strong&gt;。可中断获取锁可以在获得锁的同时保持对中断的响应。可中断获取锁比其它获取锁的方式稍微复杂一些，需要两个 &lt;code&gt;try-catch&lt;/code&gt; 块（如果在获取锁的操作中抛出了 &lt;code&gt;InterruptedException&lt;/code&gt; ，那么可以使用标准的 &lt;code&gt;try-finally&lt;/code&gt; 加锁模式）。
&lt;ul&gt;&lt;li&gt;举例来说：假设有两个线程同时通过 &lt;code&gt;lock.lockInterruptibly()&lt;/code&gt; 获取某个锁时，若线程 A 获取到了锁，则线程 B 只能等待。若此时对线程 B 调用 &lt;code&gt;threadB.interrupt()&lt;/code&gt; 方法能够中断线程 B 的等待过程。由于 &lt;code&gt;lockInterruptibly()&lt;/code&gt; 的声明中抛出了异常，所以 &lt;code&gt;lock.lockInterruptibly()&lt;/code&gt; 必须放在 &lt;code&gt;try&lt;/code&gt; 块中或者在调用 &lt;code&gt;lockInterruptibly()&lt;/code&gt; 的方法外声明抛出 &lt;code&gt;InterruptedException&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;🔔 注意：当一个线程获取了锁之后，是不会被 &lt;code&gt;interrupt()&lt;/code&gt; 方法中断的。单独调用 &lt;code&gt;interrupt()&lt;/code&gt; 方法不能中断正在运行状态中的线程，只能中断阻塞状态中的线程。因此当通过 &lt;code&gt;lockInterruptibly()&lt;/code&gt; 方法获取某个锁时，如果未获取到锁，只有在等待的状态下，才可以响应中断。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;示例：&lt;code&gt;ReentrantLock&lt;/code&gt; 的 &lt;code&gt;lockInterruptibly()&lt;/code&gt; 操作&lt;/p&gt;
&lt;p&gt;修改上个示例中的 &lt;code&gt;execute()&lt;/code&gt; 方法&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void execute() {
    try {
        lock.lockInterruptibly();

        for (int i = 0; i &amp;lt; 3; i++) {
            // 略...
        }
    } catch (InterruptedException e) {
        System.out.println(Thread.currentThread().getName() + &quot;被中断&quot;);
        e.printStackTrace();
    } finally {
        lock.unlock();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;newcondition-方法&quot;&gt;newCondition 方法&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;newCondition()&lt;/code&gt; - 返回一个绑定到 &lt;code&gt;Lock&lt;/code&gt; 对象上的 &lt;code&gt;Condition&lt;/code&gt; 实例。&lt;code&gt;Condition&lt;/code&gt; 的特性和具体方法请阅读下文 &lt;a href=&quot;https://www.cnblogs.com/jingmoxukong/p/12194712.html#五condition&quot;&gt;&lt;code&gt;Condition&lt;/code&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;reentrantlock-的原理&quot;&gt;ReentrantLock 的原理&lt;/h3&gt;
&lt;h4 id=&quot;reentrantlock-的数据结构&quot;&gt;ReentrantLock 的数据结构&lt;/h4&gt;
&lt;p&gt;阅读 &lt;code&gt;ReentrantLock&lt;/code&gt; 的源码，可以发现它有一个核心字段：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private final Sync sync;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;sync&lt;/code&gt; - 内部抽象类 &lt;code&gt;ReentrantLock.Sync&lt;/code&gt; 对象，&lt;code&gt;Sync&lt;/code&gt; 继承自 AQS。它有两个子类：&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ReentrantLock.FairSync&lt;/code&gt; - 公平锁。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ReentrantLock.NonfairSync&lt;/code&gt; - 非公平锁。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;查看源码可以发现，&lt;code&gt;ReentrantLock&lt;/code&gt; 实现 &lt;code&gt;Lock&lt;/code&gt; 接口其实是调用 &lt;code&gt;ReentrantLock.FairSync&lt;/code&gt; 或 &lt;code&gt;ReentrantLock.NonfairSync&lt;/code&gt; 中各自的实现，这里不一一列举。&lt;/p&gt;
&lt;h4 id=&quot;reentrantlock-的获取锁和释放锁&quot;&gt;ReentrantLock 的获取锁和释放锁&lt;/h4&gt;
&lt;p&gt;ReentrantLock 获取锁和释放锁的接口，从表象看，是调用 &lt;code&gt;ReentrantLock.FairSync&lt;/code&gt; 或 &lt;code&gt;ReentrantLock.NonfairSync&lt;/code&gt; 中各自的实现；从本质上看，是基于 AQS 的实现。&lt;/p&gt;
&lt;p&gt;仔细阅读源码很容易发现：&lt;/p&gt;
&lt;ul readability=&quot;-0.41399082568807&quot;&gt;&lt;li&gt;&lt;code&gt;void lock()&lt;/code&gt; 调用 Sync 的 lock() 方法。&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;void lockInterruptibly()&lt;/code&gt; 直接调用 AQS 的 &lt;a href=&quot;https://www.cnblogs.com/jingmoxukong/p/12194712.html#获取可中断的独占锁&quot;&gt;获取可中断的独占锁&lt;/a&gt; 方法 &lt;code&gt;lockInterruptibly()&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;boolean tryLock()&lt;/code&gt; 调用 Sync 的 &lt;code&gt;nonfairTryAcquire()&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;boolean tryLock(long time, TimeUnit unit)&lt;/code&gt; 直接调用 AQS 的 &lt;a href=&quot;https://www.cnblogs.com/jingmoxukong/p/12194712.html#获取超时等待式的独占锁&quot;&gt;获取超时等待式的独占锁&lt;/a&gt; 方法 &lt;code&gt;tryAcquireNanos(int arg, long nanosTimeout)&lt;/code&gt;。&lt;/li&gt;
&lt;li readability=&quot;-0.80769230769231&quot;&gt;
&lt;p&gt;&lt;code&gt;void unlock()&lt;/code&gt; 直接调用 AQS 的 &lt;a href=&quot;https://www.cnblogs.com/jingmoxukong/p/12194712.html#释放独占锁&quot;&gt;释放独占锁&lt;/a&gt; 方法 &lt;code&gt;release(int arg)&lt;/code&gt; 。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;直接调用 AQS 接口的方法就不再赘述了，其原理在 &lt;a href=&quot;https://www.cnblogs.com/jingmoxukong/p/12194712.html#AQS%20的原理&quot;&gt;AQS 的原理&lt;/a&gt; 中已经用很大篇幅进行过讲解。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;nonfairTryAcquire&lt;/code&gt; 方法源码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 公平锁和非公平锁都会用这个方法区尝试获取锁
final boolean nonfairTryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    int c = getState();
    if (c == 0) {
        if (compareAndSetState(0, acquires)) {
         // 如果同步状态为0，将其设为 acquires，并设置当前线程为排它线程
            setExclusiveOwnerThread(current);
            return true;
        }
    }
    else if (current == getExclusiveOwnerThread()) {
        int nextc = c + acquires;
        if (nextc &amp;lt; 0) // overflow
            throw new Error(&quot;Maximum lock count exceeded&quot;);
        setState(nextc);
        return true;
    }
    return false;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;处理流程很简单：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果同步状态为 0，设置同步状态设为 acquires，并设置当前线程为排它线程，然后返回 true，获取锁成功。&lt;/li&gt;
&lt;li&gt;如果同步状态不为 0 且当前线程为排它线程，设置同步状态为当前状态值+acquires 值，然后返回 true，获取锁成功。&lt;/li&gt;
&lt;li&gt;否则，返回 false，获取锁失败。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;lock 方法在公平锁和非公平锁中的实现：&lt;/p&gt;
&lt;p&gt;二者的区别仅在于申请非公平锁时，如果同步状态为 0，尝试将其设为 1，如果成功，直接将当前线程置为排它线程；否则和公平锁一样，调用 AQS 获取独占锁方法 &lt;code&gt;acquire&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 非公平锁实现
final void lock() {
    if (compareAndSetState(0, 1))
    // 如果同步状态为0，将其设为1，并设置当前线程为排它线程
        setExclusiveOwnerThread(Thread.currentThread());
    else
    // 调用 AQS 获取独占锁方法 acquire
        acquire(1);
}

// 公平锁实现
final void lock() {
    // 调用 AQS 获取独占锁方法 acquire
    acquire(1);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;四reentrantreadwritelock&quot;&gt;四、ReentrantReadWriteLock&lt;/h2&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;&lt;code&gt;ReentrantReadWriteLock&lt;/code&gt; 类是 &lt;code&gt;ReadWriteLock&lt;/code&gt; 接口的具体实现，它是一个&lt;strong&gt;可重入的读写锁&lt;/strong&gt;。&lt;strong&gt;&lt;code&gt;ReentrantReadWriteLock&lt;/code&gt; 维护了一对读写锁，将读写锁分开，有利于提高并发效率&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ReentrantLock&lt;/code&gt; 实现了一种标准的互斥锁：每次最多只有一个线程能持有 &lt;code&gt;ReentrantLock&lt;/code&gt;。但对于维护数据的完整性来说，互斥通常是一种过于强硬的加锁策略，因此也就不必要地限制了并发性。大多数场景下，读操作比写操作频繁，只要保证每个线程都能读取到最新数据，并且在读数据时不会有其它线程在修改数据，那么就不会出现线程安全问题。这种策略减少了互斥同步，自然也提升了并发性能，&lt;code&gt;ReentrantReadWriteLock&lt;/code&gt; 就是这种策略的具体实现。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;reentrantreadwritelock-的特性&quot;&gt;ReentrantReadWriteLock 的特性&lt;/h3&gt;
&lt;p&gt;ReentrantReadWriteLock 的特性如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;ReentrantReadWriteLock&lt;/code&gt; 适用于读多写少的场景&lt;/strong&gt;。如果是写多读少的场景，由于 &lt;code&gt;ReentrantReadWriteLock&lt;/code&gt; 其内部实现比 &lt;code&gt;ReentrantLock&lt;/code&gt; 复杂，性能可能反而要差一些。如果存在这样的问题，需要具体问题具体分析。由于 &lt;code&gt;ReentrantReadWriteLock&lt;/code&gt; 的读写锁（&lt;code&gt;ReadLock&lt;/code&gt;、&lt;code&gt;WriteLock&lt;/code&gt;）都实现了 &lt;code&gt;Lock&lt;/code&gt; 接口，所以要替换为 &lt;code&gt;ReentrantLock&lt;/code&gt; 也较为容易。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ReentrantReadWriteLock&lt;/code&gt; 实现了 &lt;code&gt;ReadWriteLock&lt;/code&gt; 接口，支持了 &lt;code&gt;ReentrantLock&lt;/code&gt; 所不具备的读写锁分离。&lt;code&gt;ReentrantReadWriteLock&lt;/code&gt; 维护了一对读写锁（&lt;code&gt;ReadLock&lt;/code&gt;、&lt;code&gt;WriteLock&lt;/code&gt;）。将读写锁分开，有利于提高并发效率。&lt;code&gt;ReentrantReadWriteLock&lt;/code&gt; 的加锁策略是：&lt;strong&gt;允许多个读操作并发执行，但每次只允许一个写操作&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ReentrantReadWriteLock&lt;/code&gt; 为读写锁都提供了可重入的加锁语义。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ReentrantReadWriteLock&lt;/code&gt; 支持公平锁和非公平锁（默认）两种模式。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;ReadWriteLock&lt;/code&gt; 接口定义如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface ReadWriteLock {
    Lock readLock();
    Lock writeLock();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;readLock&lt;/code&gt; - 返回用于读操作的锁（&lt;code&gt;ReadLock&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;writeLock&lt;/code&gt; - 返回用于写操作的锁（&lt;code&gt;WriteLock&lt;/code&gt;）。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在读写锁和写入锁之间的交互可以采用多种实现方式，&lt;code&gt;ReadWriteLock&lt;/code&gt; 的一些可选实现包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;释放优先&lt;/strong&gt; - 当一个写入操作释放写锁，并且队列中同时存在读线程和写线程，那么应该优先选择读线程、写线程，还是最先发出请求的线程？&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;读线程插队&lt;/strong&gt; - 如果锁是由读线程持有，但有写线程正在等待，那么新到达的读线程能否立即获得访问权，还是应该在写线程后面等待？如果允许读线程插队到写线程之前，那么将提高并发性，但可能造成线程饥饿问题。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;重入性&lt;/strong&gt; - 读锁和写锁是否是可重入的？&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;降级&lt;/strong&gt; - 如果一个线程持有写入锁，那么它能否在不释放该锁的情况下获得读锁？这可能会使得写锁被降级为读锁，同时不允许其他写线程修改被保护的资源。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;升级&lt;/strong&gt; - 读锁能否优先于其他正在等待的读线程和写线程而升级为一个写锁？在大多数的读写锁实现中并不支持升级，因为如果没有显式的升级操作，那么很容易造成死锁。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;reentrantreadwritelock-的用法&quot;&gt;ReentrantReadWriteLock 的用法&lt;/h3&gt;
&lt;p&gt;前文了解了 &lt;code&gt;ReentrantReadWriteLock&lt;/code&gt; 的特性，接下来，我们要讲述其具体用法。&lt;/p&gt;
&lt;h4 id=&quot;reentrantreadwritelock-的构造方法&quot;&gt;ReentrantReadWriteLock 的构造方法&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;ReentrantReadWriteLock&lt;/code&gt; 和 &lt;code&gt;ReentrantLock&lt;/code&gt; 一样，也有两个构造方法，且用法相似。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public ReentrantReadWriteLock() {}
public ReentrantReadWriteLock(boolean fair) {}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;ReentrantReadWriteLock()&lt;/code&gt; - 默认构造方法会初始化一个&lt;strong&gt;非公平锁（NonfairSync）&lt;/strong&gt;。在非公平的锁中，线程获得锁的顺序是不确定的。写线程降级为读线程是可以的，但读线程升级为写线程是不可以的（这样会导致死锁）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ReentrantReadWriteLock(boolean)&lt;/code&gt; - &lt;code&gt;new ReentrantLock(true)&lt;/code&gt; 会初始化一个&lt;strong&gt;公平锁（FairSync）&lt;/strong&gt;。对于公平锁，等待时间最长的线程将优先获得锁。如果这个锁是读线程持有，则另一个线程请求写锁，那么其他读线程都不能获得读锁，直到写线程释放写锁。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;reentrantreadwritelock-的使用实例&quot;&gt;ReentrantReadWriteLock 的使用实例&lt;/h4&gt;
&lt;p&gt;在 &lt;a href=&quot;https://www.cnblogs.com/jingmoxukong/p/12194712.html#reentrantreadwritelock-的特性&quot;&gt;&lt;code&gt;ReentrantReadWriteLock&lt;/code&gt; 的特性&lt;/a&gt; 中已经介绍过，&lt;code&gt;ReentrantReadWriteLock&lt;/code&gt; 的读写锁（&lt;code&gt;ReadLock&lt;/code&gt;、&lt;code&gt;WriteLock&lt;/code&gt;）都实现了 &lt;code&gt;Lock&lt;/code&gt; 接口，所以其各自独立的使用方式与 &lt;code&gt;ReentrantLock&lt;/code&gt; 一样，这里不再赘述。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ReentrantReadWriteLock&lt;/code&gt; 与 &lt;code&gt;ReentrantLock&lt;/code&gt; 用法上的差异，主要在于读写锁的配合使用。本文以一个典型使用场景来进行讲解。&lt;/p&gt;
&lt;p&gt;示例：基于 &lt;code&gt;ReentrantReadWriteLock&lt;/code&gt; 实现一个简单的本地缓存&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 简单的无界缓存实现
 * &amp;lt;p&amp;gt;
 * 使用 WeakHashMap 存储键值对。WeakHashMap 中存储的对象是弱引用，JVM GC 时会自动清除没有被引用的弱引用对象。
 */
static class UnboundedCache&amp;lt;K, V&amp;gt; {

    private final Map&amp;lt;K, V&amp;gt; cacheMap = new WeakHashMap&amp;lt;&amp;gt;();

    private final ReentrantReadWriteLock cacheLock = new ReentrantReadWriteLock();

    public V get(K key) {
        cacheLock.readLock().lock();
        V value;
        try {
            value = cacheMap.get(key);
            String log = String.format(&quot;%s 读数据 %s:%s&quot;, Thread.currentThread().getName(), key, value);
            System.out.println(log);
        } finally {
            cacheLock.readLock().unlock();
        }
        return value;
    }

    public V put(K key, V value) {
        cacheLock.writeLock().lock();
        try {
            cacheMap.put(key, value);
            String log = String.format(&quot;%s 写入数据 %s:%s&quot;, Thread.currentThread().getName(), key, value);
            System.out.println(log);
        } finally {
            cacheLock.writeLock().unlock();
        }
        return value;
    }

    public V remove(K key) {
        cacheLock.writeLock().lock();
        try {
            return cacheMap.remove(key);
        } finally {
            cacheLock.writeLock().unlock();
        }
    }

    public void clear() {
        cacheLock.writeLock().lock();
        try {
            this.cacheMap.clear();
        } finally {
            cacheLock.writeLock().unlock();
        }
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用 &lt;code&gt;WeakHashMap&lt;/code&gt; 而不是 &lt;code&gt;HashMap&lt;/code&gt; 来存储键值对。&lt;code&gt;WeakHashMap&lt;/code&gt; 中存储的对象是弱引用，JVM GC 时会自动清除没有被引用的弱引用对象。&lt;/li&gt;
&lt;li&gt;向 &lt;code&gt;Map&lt;/code&gt; 写数据前加写锁，写完后，释放写锁。&lt;/li&gt;
&lt;li&gt;向 &lt;code&gt;Map&lt;/code&gt; 读数据前加读锁，读完后，释放读锁。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;测试其线程安全性：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * @author &amp;lt;a href=&quot;mailto:forbreak@163.com&quot;&amp;gt;Zhang Peng&amp;lt;/a&amp;gt;
 * @since 2020-01-01
 */
public class ReentrantReadWriteLockDemo {

    static UnboundedCache&amp;lt;Integer, Integer&amp;gt; cache = new UnboundedCache&amp;lt;&amp;gt;();

    public static void main(String[] args) {
        ExecutorService executorService = Executors.newCachedThreadPool();
        for (int i = 0; i &amp;lt; 20; i++) {
            executorService.execute(new MyThread());
            cache.get(0);
        }
        executorService.shutdown();
    }

    /** 线程任务每次向缓存中写入 3 个随机值，key 固定 */
    static class MyThread implements Runnable {

        @Override
        public void run() {
            Random random = new Random();
            for (int i = 0; i &amp;lt; 3; i++) {
                cache.put(i, random.nextInt(100));
            }
        }

    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;说明：示例中，通过线程池启动 20 个并发任务。任务每次向缓存中写入 3 个随机值，key 固定；然后主线程每次固定读取缓存中第一个 key 的值。&lt;/p&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;main 读数据 0:null
pool-1-thread-1 写入数据 0:16
pool-1-thread-1 写入数据 1:58
pool-1-thread-1 写入数据 2:50
main 读数据 0:16
pool-1-thread-1 写入数据 0:85
pool-1-thread-1 写入数据 1:76
pool-1-thread-1 写入数据 2:46
pool-1-thread-2 写入数据 0:21
pool-1-thread-2 写入数据 1:41
pool-1-thread-2 写入数据 2:63
main 读数据 0:21
main 读数据 0:21
// ...&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;reentrantreadwritelock-的原理&quot;&gt;ReentrantReadWriteLock 的原理&lt;/h3&gt;
&lt;p&gt;前面了解了 &lt;code&gt;ReentrantLock&lt;/code&gt; 的原理，理解 &lt;code&gt;ReentrantReadWriteLock&lt;/code&gt; 就容易多了。&lt;/p&gt;
&lt;h4 id=&quot;reentrantreadwritelock-的数据结构&quot;&gt;ReentrantReadWriteLock 的数据结构&lt;/h4&gt;
&lt;p&gt;阅读 ReentrantReadWriteLock 的源码，可以发现它有三个核心字段：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/** Inner class providing readlock */
private final ReentrantReadWriteLock.ReadLock readerLock;
/** Inner class providing writelock */
private final ReentrantReadWriteLock.WriteLock writerLock;
/** Performs all synchronization mechanics */
final Sync sync;

public ReentrantReadWriteLock.WriteLock writeLock() { return writerLock; }
public ReentrantReadWriteLock.ReadLock  readLock()  { return readerLock; }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;sync&lt;/code&gt; - 内部类 &lt;code&gt;ReentrantReadWriteLock.Sync&lt;/code&gt; 对象。与 &lt;code&gt;ReentrantLock&lt;/code&gt; 类似，它有两个子类：&lt;code&gt;ReentrantReadWriteLock.FairSync&lt;/code&gt; 和 &lt;code&gt;ReentrantReadWriteLock.NonfairSync&lt;/code&gt; ，分别表示公平锁和非公平锁的实现。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;readerLock&lt;/code&gt; - 内部类 &lt;code&gt;ReentrantReadWriteLock.ReadLock&lt;/code&gt; 对象，这是一把读锁。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;writerLock&lt;/code&gt; - 内部类 &lt;code&gt;ReentrantReadWriteLock.WriteLock&lt;/code&gt; 对象，这是一把写锁。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;reentrantreadwritelock-的获取锁和释放锁&quot;&gt;ReentrantReadWriteLock 的获取锁和释放锁&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static class ReadLock implements Lock, java.io.Serializable {

    // 调用 AQS 获取共享锁方法
    public void lock() {
        sync.acquireShared(1);
    }

    // 调用 AQS 释放共享锁方法
    public void unlock() {
        sync.releaseShared(1);
    }
}

public static class WriteLock implements Lock, java.io.Serializable {

    // 调用 AQS 获取独占锁方法
    public void lock() {
        sync.acquire(1);
    }

    // 调用 AQS 释放独占锁方法
    public void unlock() {
        sync.release(1);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;五condition&quot;&gt;五、Condition&lt;/h2&gt;
&lt;p&gt;前文中提过 &lt;code&gt;Lock&lt;/code&gt; 接口中 有一个 &lt;code&gt;newCondition()&lt;/code&gt; 方法用于返回一个绑定到 &lt;code&gt;Lock&lt;/code&gt; 对象上的 &lt;code&gt;Condition&lt;/code&gt; 实例。&lt;code&gt;Condition&lt;/code&gt; 是什么？有什么作用？本节将一一讲解。&lt;/p&gt;
&lt;p&gt;在单线程中，一段代码的执行可能依赖于某个状态，如果不满足状态条件，代码就不会被执行（典型的场景，如：if ... else ...）。在并发环境中，当一个线程判断某个状态条件时，其状态可能是由于其他线程的操作而改变，这时就需要有一定的协调机制来确保在同一时刻，数据只能被一个线程锁修改，且修改的数据状态被所有线程所感知。&lt;/p&gt;
&lt;p&gt;Java 1.5 之前，主要是利用 &lt;code&gt;Object&lt;/code&gt; 类中的 &lt;code&gt;wait&lt;/code&gt;、&lt;code&gt;notify&lt;/code&gt;、&lt;code&gt;notifyAll&lt;/code&gt; 配合 &lt;code&gt;synchronized&lt;/code&gt; 来进行线程间通信（如果不了解其特性，可以参考：&lt;a href=&quot;https://dunwu.github.io/javacore/#/concurrent/java-thread?id=waitnotifynotifyall&quot;&gt;Java 线程基础 - wait/notify/notifyAll&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;wait&lt;/code&gt;、&lt;code&gt;notify&lt;/code&gt;、&lt;code&gt;notifyAll&lt;/code&gt; 需要配合 &lt;code&gt;synchronized&lt;/code&gt; 使用，不适用于 &lt;code&gt;Lock&lt;/code&gt;。而使用 &lt;code&gt;Lock&lt;/code&gt; 的线程，彼此间通信应该使用 &lt;code&gt;Condition&lt;/code&gt; 。这可以理解为，什么样的锁配什么样的钥匙。&lt;strong&gt;内置锁（&lt;code&gt;synchronized&lt;/code&gt;）配合内置条件队列（&lt;code&gt;wait&lt;/code&gt;、&lt;code&gt;notify&lt;/code&gt;、&lt;code&gt;notifyAll&lt;/code&gt; ），显式锁（&lt;code&gt;Lock&lt;/code&gt;）配合显式条件队列（&lt;code&gt;Condition&lt;/code&gt; ）&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;condition-的特性&quot;&gt;Condition 的特性&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Condition&lt;/code&gt; 接口定义如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface Condition {
    void await() throws InterruptedException;
    void awaitUninterruptibly();
    long awaitNanos(long nanosTimeout) throws InterruptedException;
    boolean await(long time, TimeUnit unit) throws InterruptedException;
    boolean awaitUntil(Date deadline) throws InterruptedException;
    void signal();
    void signalAll();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中，&lt;code&gt;await&lt;/code&gt;、&lt;code&gt;signal&lt;/code&gt;、&lt;code&gt;signalAll&lt;/code&gt; 与 &lt;code&gt;wait&lt;/code&gt;、&lt;code&gt;notify&lt;/code&gt;、&lt;code&gt;notifyAll&lt;/code&gt; 相对应，功能也相似。除此以外，&lt;code&gt;Condition&lt;/code&gt; 相比内置条件队列（ &lt;code&gt;wait&lt;/code&gt;、&lt;code&gt;notify&lt;/code&gt;、&lt;code&gt;notifyAll&lt;/code&gt; ），提供了更为丰富的功能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;每个锁（&lt;code&gt;Lock&lt;/code&gt;）上可以存在多个 &lt;code&gt;Condition&lt;/code&gt;，这意味着锁的状态条件可以有多个。&lt;/li&gt;
&lt;li&gt;支持公平的或非公平的队列操作。&lt;/li&gt;
&lt;li&gt;支持可中断的条件等待，相关方法：&lt;code&gt;awaitUninterruptibly()&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;支持可定时的等待，相关方法：&lt;code&gt;awaitNanos(long)&lt;/code&gt; 、&lt;code&gt;await(long, TimeUnit)&lt;/code&gt;、&lt;code&gt;awaitUntil(Date)&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;condition-的用法&quot;&gt;Condition 的用法&lt;/h3&gt;
&lt;p&gt;这里以 &lt;code&gt;Condition&lt;/code&gt; 来实现一个消费者、生产者模式。&lt;/p&gt;
&lt;blockquote readability=&quot;5.2771084337349&quot;&gt;
&lt;p&gt;🔔 注意：事实上，解决此类问题使用 &lt;code&gt;CountDownLatch&lt;/code&gt;、&lt;code&gt;Semaphore&lt;/code&gt; 等工具更为便捷、安全。想了解详情，可以参考 &lt;a href=&quot;https://dunwu.github.io/javacore/#/concurrent/java-concurrent-tools&quot;&gt;Java 并发工具类&lt;/a&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;产品类&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class Message {

    private final Lock lock = new ReentrantLock();

    private final Condition producedMsg = lock.newCondition();

    private final Condition consumedMsg = lock.newCondition();

    private String message;

    private boolean state;

    private boolean end;

    public void consume() {
        //lock
        lock.lock();
        try {
            // no new message wait for new message
            while (!state) { producedMsg.await(); }

            System.out.println(&quot;consume message : &quot; + message);
            state = false;
            // message consumed, notify waiting thread
            consumedMsg.signal();
        } catch (InterruptedException ie) {
            System.out.println(&quot;Thread interrupted - viewMessage&quot;);
        } finally {
            lock.unlock();
        }
    }

    public void produce(String message) {
        lock.lock();
        try {
            // last message not consumed, wait for it be consumed
            while (state) { consumedMsg.await(); }

            System.out.println(&quot;produce msg: &quot; + message);
            this.message = message;
            state = true;
            // new message added, notify waiting thread
            producedMsg.signal();
        } catch (InterruptedException ie) {
            System.out.println(&quot;Thread interrupted - publishMessage&quot;);
        } finally {
            lock.unlock();
        }
    }

    public boolean isEnd() {
        return end;
    }

    public void setEnd(boolean end) {
        this.end = end;
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;消费者&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class MessageConsumer implements Runnable {

    private Message message;

    public MessageConsumer(Message msg) {
        message = msg;
    }

    @Override
    public void run() {
        while (!message.isEnd()) { message.consume(); }
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;生产者&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class MessageProducer implements Runnable {

    private Message message;

    public MessageProducer(Message msg) {
        message = msg;
    }

    @Override
    public void run() {
        produce();
    }

    public void produce() {
        List&amp;lt;String&amp;gt; msgs = new ArrayList&amp;lt;&amp;gt;();
        msgs.add(&quot;Begin&quot;);
        msgs.add(&quot;Msg1&quot;);
        msgs.add(&quot;Msg2&quot;);

        for (String msg : msgs) {
            message.produce(msg);
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

        message.produce(&quot;End&quot;);
        message.setEnd(true);
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class LockConditionDemo {

    public static void main(String[] args) {
        Message msg = new Message();
        Thread producer = new Thread(new MessageProducer(msg));
        Thread consumer = new Thread(new MessageConsumer(msg));
        producer.start();
        consumer.start();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
</description>
<pubDate>Tue, 14 Jan 2020 16:14:00 +0000</pubDate>
<dc:creator>静默虚空</dc:creator>
<og:description>&amp;#128230; 本文以及示例源码已归档在 &amp;quot;javacore&amp;quot; 一、并发锁简介 确保线程安全最常见的做法是利用锁机制（ 、`sychronized`）来对共享数据做互斥同步，这</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jingmoxukong/p/12194712.html</dc:identifier>
</item>
<item>
<title>Spring（一）开篇 - 龙四丶</title>
<link>http://www.cnblogs.com/loongk/p/12194690.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/loongk/p/12194690.html</guid>
<description>&lt;p&gt;在早期 J2EE 时代，开发一个应用程序非常繁琐，先不说对象的创建及管理，如其它数据库访问、提供 Web 服务等都需耗费我们大量时间。当时一位名为 Rod Johnson 的澳大利亚人率先对这种 J2EE 系统框架臃肿、低效的种种现状提出了质疑，之后 Rod Johnson 编写《Expert one on one J2EE design and development》一书，通过书中阐述的部分理念和原型创建了Spring Framework 。（PS：Rod Johnson 居然是音乐学博士？？？）&lt;/p&gt;
&lt;p&gt;Spring Framework 是一个轻量级的 Java开源框架，主要是为了解决企业应用开发的复杂性而创建。它的核心是帮助我们管理对象及其依赖关系，但还提供像通用日志记录、性能统计、安全控制、异常处理等面向切面的能力，还集成了大量的第三方框架，如数据库访问框架 Hibernate ，mybatis、Web 服务框架 Struts 、自身提供的SpringMVC，还有任务调度、Redis 缓存，Mq等。&lt;/p&gt;
&lt;p&gt;Spring Framework 还致力于 J2EE 应用的各层解决方案，在表现层、业务层及持久层都集成了相应的功能框架，可以说 Spring 是企业应用开发的“一站式”解决方案。&lt;/p&gt;
&lt;p&gt;但其实 J2EE 和 Spring 并不对立，Spring 是 J2EE 的补充，它将 J2EE 的各个规范集成在一起：&lt;/p&gt;
&lt;p&gt;可以说 Spring 是“借鉴了”他山之石，来逐步实现自身的生态系统。&lt;/p&gt;

&lt;p&gt;Spring 第一个版本于2002年10月发布，至今十几年间， Spring 框架的核心功能、社区支持等各方面都发展迅猛，所以有必要回顾一下Spring 每个里程碑版本所带来的重要特性。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Spring 0.9：这是该框架第一个公开发布的版本，以《Expert One-on-One: J2EE Design and Development》一书为基础，提供了 bean 配置基础、AOP 支持、JDBC 抽象框架、抽象事务支持等。该版本没有官方参考文档，但可以在SourceForge 上找到现有的源代码和文档。&lt;/li&gt;
&lt;li&gt;Spring 1.x：这是发布的第一个带有官方参考文档的版本。由七个模块组成。
&lt;ul&gt;&lt;li&gt;Spring Core、Spring Context、Spring DAO、Spring ORM、Spring AOP、Spring Web、Spring Web MVC&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Spring 2.x：该版本由六个模块组成，Spring Context 模块融入了 Spring Core 中，Spring Web MVC 融入了 Spring Web 中。
&lt;ul&gt;&lt;li&gt;支持 AOP 开发的 @AspectJ 注解。&lt;/li&gt;
&lt;li&gt;完全支持异步JMS 消息驱动的POJO。&lt;/li&gt;
&lt;li&gt;为调度任务而引入的 TaskExecutor 抽象。&lt;/li&gt;
&lt;li&gt;Java 5 注解支持，特别是 @Transactional、@Required 和 @AspectJ。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Spring 2.5.x：该版本包含以下功能。
&lt;ul&gt;&lt;li&gt;新增 @Autowired 注解以及对 JSR-250 注解（@Resource、@PostConstruct 和 @PreDestroy）的支持。&lt;/li&gt;
&lt;li&gt;新增注册 Bean 的相关注解：@Component、 @Repository、@Service 和 @Controller。&lt;/li&gt;
&lt;li&gt;除了Spring MVC @Controller 注解，还添加了 @RequestMapping、@RequestParam 和@ModelAttribute 注解，从而支持通过注解配置进行请求处理。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Spring 3.0.x：这是基于Java 5 的 Spring 第一个版本，旨在充分利用 Java5 的功能，如泛型、可变参数。
&lt;ul&gt;&lt;li&gt;支持 Java5 功能，例如泛型、可变参数。&lt;/li&gt;
&lt;li&gt;全面支持 REST。&lt;/li&gt;
&lt;li&gt;新的 MVC XML 名称空间和其他注解，例如 SpringMVC 中的 @CookieValue 和 @RequessHeaders。&lt;/li&gt;
&lt;li&gt;验证增强功能和 JSR-303 (Bean 验证）支持。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Spring 3.2.x：该版本包含以下功能。
&lt;ul&gt;&lt;li&gt;支持基于 Servlet 3.0 的异步请求处理。&lt;/li&gt;
&lt;li&gt;新的 SpringMVC 注解 @ControllerAdvice。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Spring 4.x：这是一个重要的 Spring 版本，也是第一个完全支持 Java 8 的版本。虽然仍然可以使用较旧的版本，但弃用的类和方法己被删除。
&lt;ul&gt;&lt;li&gt;全面支持 Hibernate ORM 5.0 。&lt;/li&gt;
&lt;li&gt;JMS 和 Web 改进。&lt;/li&gt;
&lt;li&gt;对 WebSocket 消息传递的改进。&lt;/li&gt;
&lt;li&gt;引入了AopTestUtils 实用工具类，允许访问 Spring 代理的底层对象。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Spring 5.x：这是一个主要版本，整个框架都基于Java 8。
&lt;ul&gt;&lt;li&gt;充分利用Java 8 的强大功能，从而在性能上得到极大的改进。&lt;/li&gt;
&lt;li&gt;支持 JMS2.0+ 和 JPA 2.1+。&lt;/li&gt;
&lt;li&gt;引入了 Spring Web Flux，这是一个用于替代 SpringMVC 的项目，构建在反应式基础之上，完全是异步和非阻塞的。&lt;/li&gt;
&lt;li&gt;Web 和核心模块适用于反应式编程模型。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;到了 Spring 5.0 时代，其模块大约有 20 个，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwgy1gawfgml8csj30y60n8q6z.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这些模块被总结为以下几部分。&lt;/p&gt;
&lt;h2 id=&quot;core-container&quot;&gt;Core Container&lt;/h2&gt;
&lt;p&gt;Core Container（核心容器）包含 Core 、Beans 、Context 和 Expression Language 四个模块。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Core 模决主要包含 Spring 框架的核心工具类，是其他组件的基本核心。如动态代理相关的 asm、cglib，以及各种 Utils，StringUtils、CollectionUtils。&lt;/li&gt;
&lt;li&gt;Beans 模块包含访问配置文件、创建和管理 bean 以及进行 IoC/DI 操作相关的所有类。如：BeanFactory、BeanDefinitions 等。&lt;/li&gt;
&lt;li&gt;Context 模块构建于 Core 和Beans 模块基础之上，其继承了 Beans 的特性，为Spring 核心提供了大量扩展。ApplicationContext 接口是 Context 模块的核心。&lt;/li&gt;
&lt;li&gt;Expression Language 模块提供了强大的表达式语言。就是在远古 JSP 时期使用的 EL 表达式。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;data-accessintegration&quot;&gt;Data Access/Integration&lt;/h2&gt;
&lt;p&gt;Data Access/Integration 包含 JDBC 、ORM 、OXM、JMS 和 Transaction 模块。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;JDBC 模块提供了一个JDBC 抽象层，用来适配所有的数据库厂商。这个模块包含了 Spring 对 JDBC 数据访问进行封装的所有类。&lt;/li&gt;
&lt;li&gt;ORM 模块提供了几种常用的对象关系映射框架，如 JPA 、Hibernate 、iBatis 。&lt;/li&gt;
&lt;li&gt;OXM 模块提供了一个对ObjecνXML 映射实现的抽象层。&lt;/li&gt;
&lt;li&gt;JMS (Java Messaging Service）模块主要包含一些生产和消费消息的特性。&lt;/li&gt;
&lt;li&gt;Transaction 模块支持编程和声明性的事务管理。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;web&quot;&gt;Web&lt;/h2&gt;
&lt;p&gt;Web 层包含了Web 、Servlet 、WebSocket、Porlet 模块。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Web 模块：提供了基础的面向Web 的集成特性。例如，多文件上传。&lt;/li&gt;
&lt;li&gt;Servlet 模块：该模块包含Spring 的model-view-controller (MVC)实现。&lt;/li&gt;
&lt;li&gt;WebSocket 模块：提供 WebSocket 协议支持。&lt;/li&gt;
&lt;li&gt;Porlet 模块：提供了用于 Portlet 环境和 Servlet 模块的 MVC 的实现&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;aop&quot;&gt;AOP&lt;/h2&gt;
&lt;p&gt;AOP 模块提供了一个符合 AOP 联盟标准的面向切面编程实现，它让你可以定义例如方法拦截器和切点，从而将逻辑代码分开，降低它们之间的耦合性。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Aspects 模块提供了对AspectJ 的集成支持。&lt;/li&gt;
&lt;li&gt;Instrumentation 模块提供了class instrumentation 支持和classloader 实现，使得可以在特定的应用服务器上使用。&lt;/li&gt;
&lt;li&gt;Messaging 模块：对消息通信集成提供了广泛的支持，及提供简化 JMS API 的使用到异步接收消息的完整基础结构。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;test&quot;&gt;Test&lt;/h2&gt;
&lt;p&gt;Test 模块支持使用 JUnit 和TestNG 对 Spring 组件进行测试。&lt;/p&gt;

&lt;p&gt;Spring 背景及架构就介绍到这，接下来将对 Spring 核心容器、AOP、事务这三部分内容展开一系列的讨论。&lt;/p&gt;
&lt;p&gt;注：该系列文章使用的 Spring 版本是 5.0+。&lt;/p&gt;
&lt;p&gt;以上就是本章内容，如果文章中有错误或者需要补充的请及时提出，本人感激不尽。&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;《Spring 源码深度解析（第二版）》&lt;br/&gt;《Spring5 高级编程》&lt;br/&gt;《SpringBoot 编程思想》&lt;br/&gt;https://baike.baidu.com/item/spring/85061#2&lt;br/&gt;https://docs.spring.io/spring/docs/5.2.2.RELEASE/spring-framework-reference/overview.html#overview&lt;/p&gt;
</description>
<pubDate>Tue, 14 Jan 2020 16:01:00 +0000</pubDate>
<dc:creator>龙四丶</dc:creator>
<og:description>[toc] 1、Spring 介绍 在早期 J2EE 时代，开发一个应用程序非常繁琐，先不说对象的创建及管理，如其它数据库访问、提供 Web 服务等都需耗费我们大量时间。当时一位名为 Rod John</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/loongk/p/12194690.html</dc:identifier>
</item>
<item>
<title>Elasticsearch基本概念 - %阳阳羊%</title>
<link>http://www.cnblogs.com/Onlywjy/p/12194626.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Onlywjy/p/12194626.html</guid>
<description>&lt;p&gt;            索引（Index）&lt;/p&gt;
&lt;p&gt;          Index- 索引是文档的容器，是一类文档的结合&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;Index体现了逻辑空间的概念：每一个索引都有自己的Mapping定义，用于定义包含的文档的字段名和字段类型&lt;/li&gt;
&lt;li&gt;Shard体现了物理空间的概念：索引中的数据分散在Shard上&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;          索引的Mapping与Settings&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;Mapping定义文档字段的类型&lt;/li&gt;
&lt;li&gt;Setting定义不同的数据分布&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Tue, 14 Jan 2020 15:36:00 +0000</pubDate>
<dc:creator>%阳阳羊%</dc:creator>
<og:description>Elasticsearch自顶向下的架构体系 文档，索引 文档（Document） Elasticsearch是面向文档的，文档是所有可搜索数据的最小单位 文档会被序列化成JSON格式，保持在Elas</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Onlywjy/p/12194626.html</dc:identifier>
</item>
<item>
<title>Oozie任务调度框架详解及使用简介(一) - 鲁边</title>
<link>http://www.cnblogs.com/lubians/p/12194612.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lubians/p/12194612.html</guid>
<description>&lt;p&gt;摘要:个人最近一段时间一直在使用oozie,从刚开始的各种别扭到现在越来越觉得有意思的情况下,想整理一下关于oozie的认知,整理出来一个oozie系列,本来市面上关于oozie的资料就比较少,希望写完后能形成自己对oozie的独特理解和加强整体性的把握.&lt;/p&gt;
&lt;h4 id=&quot;一.常见的调度框架&quot;&gt;一.常见的调度框架&lt;/h4&gt;
&lt;h5 id=&quot;crontab定时器&quot;&gt;&lt;strong&gt;1.1.crontab定时器&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;linux自带定时器，没有web界面 ，不利于监控任务和调度任务,在工作量比较小的情况下,建议使用linux的crontab定时命令&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;##crongtab 命令 
*   *   *   *   *    后面接调度 job 的命令  
分  时  日   月  周  
##简单实例(每天0点11分执行) 
11 0 * * * /home/hduser/lubians/intelligentDevice/intelligentDevice.sh &lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;azkaban调度&quot;&gt;&lt;strong&gt;1.2.Azkaban调度&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;开源项目，key/value配置对，操作简单，带web界面&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://azkaban.github.io/&quot;&gt;Azkaban开源网站&lt;/a&gt;&lt;/p&gt;
&lt;h5 id=&quot;oozie调度&quot;&gt;&lt;strong&gt;1.3.Oozie调度&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;apache项目，xml配置文件，操作稍微有难度，带web查看界面，常用于hadoop相关任务的调度&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://oozie.apache.org/&quot;&gt;Oozie官网&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;二.使用背景&quot;&gt;&lt;strong&gt;二.使用背景&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;公司下半年技术架构升级,将整个大数据集群管理流程化,规模化,引入了更多的技术组件,这其中就有Oozie.&lt;/p&gt;
&lt;h5 id=&quot;之前使用的调度技术&quot;&gt;&lt;strong&gt;2.1. 之前使用的调度技术&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;在这之前公司使用的调度工具主要是TaskCtl和Kettle,TaskCtl分为三层,Manage,Server和Agent.&lt;/p&gt;
&lt;p&gt;可以理解为将调度分层了.&lt;/p&gt;
&lt;p&gt;TASKCTL主要可以完成串行、并行、依赖、互斥、执行计划、定时、容错、循环、条件分支、远程、负载均衡、自定义条件等各种不同的核心调度功能。&lt;/p&gt;
&lt;p&gt;根据不同的功能分类，TASKCTL将客户端分为Admin(平台管理)、Designer(流程集成开发环境)、Monitor(流程监控管理)三套不同的软件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Admi：&lt;/strong&gt;平台节点管理、任务类型管理、工程管理、应用设置、全局变量管理以及流程导入导出等功能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Designer：&lt;/strong&gt;平台流程代码信息管理、代码设计编辑、流程图形编辑、规则语法适时检测功能以及编译发布等功能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Monitor：&lt;/strong&gt;图形方式监控、多角度统计监控、流程起停重置、任务锁定、任务重做、信息对象查询等。&lt;/p&gt;
&lt;h5 id=&quot;为什么使用oozie&quot;&gt;&lt;strong&gt;2.2. 为什么使用Oozie&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;TaskCtl最大的问题是作为调度系统需要一台单独的调度服务器,并且和Hadoop生态圈的产品搭配不是很好,所以考虑另行办法在Hadoop集群上使用调度工具.&lt;/p&gt;
&lt;p&gt;使用Oozie的原因是因为公司使用的是Ambari集群管理工具,自带Oozie插件安装,同时Oozie支持Java API调度,会在工作中用到Java语言的缘故,选择了Oozie.&lt;/p&gt;
&lt;h4 id=&quot;三.oozie介绍&quot;&gt;&lt;strong&gt;三.Oozie介绍&lt;/strong&gt;&lt;/h4&gt;
&lt;h5 id=&quot;oozie是什么&quot;&gt;&lt;strong&gt;3.1. Oozie是什么&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;oozie是一个workflow(工作流)协调系统,是由Cloudera公司贡献给Apache的,主要用来管理Hadoop作业(job).属于web应用程序,由oozie client和oozie server两个组件构成.&lt;/p&gt;
&lt;p&gt;oozie server运行于java servlet容器（tomcat）中的web程序.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/01/14/x6d5GJpeLHPRoul.png&quot; alt=&quot;image_1akhmftbi11bjakq13n210q216db2a.png&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;为什么需要oozie&quot;&gt;&lt;strong&gt;3.2. 为什么需要Oozie&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;①对于较为复杂的Hadoop作业系统来说,单纯的依靠shell脚本方式,手工方式调度是的流程更加难以控制.&lt;/p&gt;
&lt;p&gt;②复杂系统的算法需要很多不同的作业(如mr,Java程序,shell脚本,hivesql,sqoop,spark等)按照特定的顺序,串行并行,不同时间,不同条件进行执行,就需要oozie这样的调度系统做支撑,将复杂问题简单化.&lt;/p&gt;
&lt;h5 id=&quot;oozie能带来什么&quot;&gt;&lt;strong&gt;3.3. oozie能带来什么&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;①将hadoop生态系统中常见的mr任务启动,hdfs操作,shell调度,hive操作等通过统一的方式进行连贯调度.&lt;/p&gt;
&lt;p&gt;②将复杂的依赖关系,时间触发,事件触发使用xml语言进行表达,提高开发效率.&lt;/p&gt;
&lt;p&gt;③一组任务使用一个DAG(有向无环图)来表示,图形化的表达,流程逻辑更加清晰.&lt;/p&gt;
&lt;p&gt;④支持很多种任务调度,能完成大部分的hadoop任务处理.&lt;/p&gt;
&lt;p&gt;⑤程序定义支持EL常量和函数,写过shell脚本的小伙伴使用根本没难度.&lt;/p&gt;
&lt;h4 id=&quot;四.oozie架构图&quot;&gt;&lt;strong&gt;四.Oozie架构图&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;在网上找了一个oozie架构图,如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/01/14/qXWx4Z8HEjCMfy7.png&quot; alt=&quot;image_1akhmf44nvfh140gqc68pmhs1t.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;oozie包含四大服务组件:&lt;/p&gt;
&lt;p&gt;workflow: 用于支持动作有向无环图(DAG)的设计和执行,可以按照特定的顺序执行mr,hive和shell等节点.&lt;/p&gt;
&lt;p&gt;coordinator: 用于定时调度特定的 workflow 进行执行,可以基于事件,资源存在,传递参数等自动执行.&lt;/p&gt;
&lt;p&gt;bundle: 批量设定一组coordinator执行.&lt;/p&gt;
&lt;p&gt;SLA(Service Level Agreement, oozie服务器等级协定): 用于程序执行过程的日志跟踪.&lt;/p&gt;
&lt;h5 id=&quot;oozie简易架构&quot;&gt;&lt;strong&gt;4.1.Oozie简易架构&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/01/14/HmXMYOnDFATRzU1.png&quot; alt=&quot;image_1akhm3bv8muv162h1u41ve318189.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图,oozie调度本身就是一个mr程序,开始,执行,结束或者失败,简单易懂.&lt;/p&gt;
&lt;p&gt;所以我们可以思考一下,在oozie调度mr程序时,其实同一时间是运行了两个mr的,一个是调度本身,一个是任务.&lt;/p&gt;
&lt;h5 id=&quot;一个有向无环图&quot;&gt;&lt;strong&gt;4.2.一个有向无环图&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;任务本身是一个有向无环图(DAG)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/01/14/gnIDtCb1M5wWVGi.png&quot; alt=&quot;image_1akhmaidd6a3d6m11ak15oe9p0m.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图中fork标签后面的 MR job 和 Hive job 是并行执行的,都成功后通过 join 节点合并.&lt;/p&gt;
&lt;h5 id=&quot;coordinator生命周期&quot;&gt;&lt;strong&gt;4.3.coordinator生命周期&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/01/14/7XNjw5vzuaFidWn.png&quot; alt=&quot;image_1akhmbdfe32m1m6f363juu27713.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;coordinator是一个定时服务,通过定时来固定频率的执行任务,这里的功能类似crontab.&lt;/p&gt;
&lt;h5 id=&quot;bundle-job&quot;&gt;&lt;strong&gt;4.4.bundle Job&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/01/14/Vlx7JqtiEbudGh4.png&quot; alt=&quot;image_1akhmcmbn12hu12g412tv1cjo19g11g.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;bundle的作用就是设定多个coordinator定时服务按批次执行,这样使得多个任务也形成一个DAG.&lt;/p&gt;
&lt;h4 id=&quot;五.oozie的安装与配置&quot;&gt;&lt;strong&gt;五.Oozie的安装与配置&lt;/strong&gt;&lt;/h4&gt;
&lt;h5 id=&quot;oozie的安装方式&quot;&gt;&lt;strong&gt;5.1.Oozie的安装方式&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;单独安装: 需要安装server端和client端&lt;/p&gt;
&lt;p&gt;组件安装: 使用Ambari进行oozie组件添加（可以使用HA）&lt;/p&gt;
&lt;p&gt;注意:如果使用CDH集群管理工具,也是一键配置,因为我是直接组件式安装,这里就不细讲了,有需要的小伙伴可以联系我,看情况写一下ambari配置oozie.&lt;/p&gt;
&lt;h5 id=&quot;oozie配置&quot;&gt;&lt;strong&gt;5.2.Oozie配置&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;节点内存配置：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这里的节点内存配置可能会涉及到oozie调度阻塞的问题,这个在之后有时间整理一下整个问题现象以及解决办法,这里就看一下&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;#（节点并发）,决定了你可以同时执行几个action
oozie.service.callablequeueservice.callable.concurrency 
#（队列大小） 
oozie.service.callablequeueservice.queue.size 
#（扩展）一些扩展相关 
oozie.service.ActionService.executor.ext.classes &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/01/14/G8mDKH1OL4IVP2n.png&quot; alt=&quot;clipboard.png&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;oozie元数据更改&quot;&gt;&lt;strong&gt;5.3.oozie元数据更改&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;ambari配置oozie元数据&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/01/14/yWdjMbr57aJRAcE.png&quot; alt=&quot;clipboard1.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Ambari默认数据库为Derby.&lt;/p&gt;
&lt;p&gt;我们配置时,无特殊需求情况下,一般默认选择mysql&lt;/p&gt;
&lt;p&gt;选择数据库类型,库名,用户名,url连接串,驱动,密码&lt;/p&gt;
&lt;p&gt;测试连接成功即可.&lt;/p&gt;
&lt;h5 id=&quot;ext2.2添加&quot;&gt;&lt;strong&gt;5.4.ext2.2添加&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;进入oozie文件夹&lt;/p&gt;
&lt;p&gt;将ext-2.2.tar.gz解压放到./libext/ext-2.2目录下&lt;/p&gt;
&lt;h5 id=&quot;第三方jar包添加&quot;&gt;&lt;strong&gt;5.5.第三方jar包添加&lt;/strong&gt;&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;运行时的共享目录(在HDFS下)&lt;/li&gt;
&lt;li&gt;libserver目录&lt;/li&gt;
&lt;li&gt;libtools目录&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;六.oozie管理&quot;&gt;&lt;strong&gt;六.Oozie管理&lt;/strong&gt;&lt;/h4&gt;
&lt;h5 id=&quot;oozie管理web界面&quot;&gt;&lt;strong&gt;6.1.Oozie管理Web界面&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;&lt;a href=&quot;http://ip:11000/oozie/&quot; class=&quot;uri&quot;&gt;http://ip:11000/oozie/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里有时候会出现oozieUI界面无法访问问题,之后更新一篇文章,简单说明一下.&lt;/p&gt;
&lt;h5 id=&quot;oozie使用&quot;&gt;&lt;strong&gt;6.2.oozie使用&lt;/strong&gt;&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;任务列表查看&lt;/li&gt;
&lt;li&gt;任务状态查看&lt;/li&gt;
&lt;li&gt;流程返回信息&lt;/li&gt;
&lt;li&gt;节点信息查看&lt;/li&gt;
&lt;li&gt;流程图信息&lt;/li&gt;
&lt;li&gt;日志查看&lt;/li&gt;
&lt;li&gt;系统信息查看和配置&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/01/14/UZM2XEcCDoFLWqe.png&quot; alt=&quot;clipboard2.png&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;状态识别&quot;&gt;&lt;strong&gt;6.3.状态识别&lt;/strong&gt;&lt;/h5&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;8.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;PREP&lt;/td&gt;
&lt;td&gt;一个工作流Job第一次创建将处于PREP状态，表示工作流Job已经定义，但是没有运行。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;RUNNING&lt;/td&gt;
&lt;td&gt;当一个已经被创建的工作流Job开始执行的时候，就处于RUNNING状态。它不会达到结束状态，只能因为出错而结束，或者被挂起。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;SUSPENDED&lt;/td&gt;
&lt;td&gt;一个RUNNING状态的工作流Job会变成SUSPENDED状态，而且它会一直处于该状态，除非这个工作流Job被重新开始执行或者被杀死。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;SUCCEEDED&lt;/td&gt;
&lt;td&gt;当一个RUNNING状态的工作流Job到达了end节点，它就变成了SUCCEEDED最终完成状态。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;KILLED&lt;/td&gt;
&lt;td&gt;当一个工作流Job处于被创建后的状态，或者处于RUNNING、SUSPENDED状态时，被杀死，则工作流Job的状态变为KILLED状态。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;FAILED&lt;/td&gt;
&lt;td&gt;当一个工作流Job不可预期的错误失败而终止，就会变成FAILED状态。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/01/14/bQ3efSHzNov2IPk.png&quot; alt=&quot;clipboard3.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我是鲁边, 2020 peace and love&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;别惊讶,今年的主题就是爱与和平,但愿我能一直用下去...&lt;/p&gt;
&lt;p&gt;按例按例，我的个人公众号：鲁边社，欢迎关注&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/01/11/qrwfVFtR1SKD2bL.jpg&quot; alt=&quot;avatar&quot; width=&quot;300&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 14 Jan 2020 15:28:00 +0000</pubDate>
<dc:creator>鲁边</dc:creator>
<og:description>摘要:个人最近一段时间一直在使用oozie,从刚开始的各种别扭到现在越来越觉得有意思的情况下,想整理一下关于oozie的认知,整理出来一个oozie系列,本来市面上关于oozie的资料就比较少,希望写</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lubians/p/12194612.html</dc:identifier>
</item>
</channel>
</rss>