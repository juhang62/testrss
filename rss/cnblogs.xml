<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>ROS 八叉树地图构建 - 使用 octomap_server 建图过程总结！ - 登龙</title>
<link>http://www.cnblogs.com/dlonng/p/13467644.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dlonng/p/13467644.html</guid>
<description>&lt;p&gt;构建语义地图时，最开始用的是 &lt;a href=&quot;https://github.com/OctoMap/octomap_mapping&quot;&gt;octomap_server&lt;/a&gt;，后面换成了 &lt;a href=&quot;https://github.com/floatlazer/semantic_slam&quot;&gt;semantic_slam: octomap_generator&lt;/a&gt;，不过还是整理下之前的学习笔记。&lt;/p&gt;
&lt;h2 id=&quot;一、增量构建八叉树地图步骤&quot;&gt;一、增量构建八叉树地图步骤&lt;/h2&gt;
&lt;p&gt;为了能够让 octomap_server 建图包实现增量式的地图构建，需要以下 2 个步骤：&lt;/p&gt;
&lt;h3 id=&quot;11-配置-launch-启动参数&quot;&gt;1.1 配置 launch 启动参数&lt;/h3&gt;
&lt;p&gt;这 3 个参数是建图必备：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;地图分辨率 &lt;code&gt;resolution&lt;/code&gt;：用来初始化地图对象&lt;/li&gt;
&lt;li&gt;全局坐标系 &lt;code&gt;frame_id&lt;/code&gt;：构建的全局地图的坐标系&lt;/li&gt;
&lt;li&gt;输入点云话题 &lt;code&gt;/cloud_in&lt;/code&gt;：作为建图的数据输入，建图包是把一帧一帧的点云叠加到全局坐标系实现建图&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;launch&amp;gt;
  &amp;lt;node pkg=&quot;octomap_server&quot; type=&quot;octomap_server_node&quot; name=&quot;octomap_server&quot;&amp;gt;
    &amp;lt;!-- resolution in meters per pixel --&amp;gt;
    &amp;lt;param name=&quot;resolution&quot; value=&quot;0.10&quot; /&amp;gt;

    &amp;lt;!-- 增量式构建地图时，需要提供输入的点云帧和静态全局帧之间的 TF 变换 --&amp;gt;
    &amp;lt;param name=&quot;frame_id&quot; type=&quot;string&quot; value=&quot;map&quot; /&amp;gt;

    &amp;lt;!-- 要订阅的点云主题名称 /fusion_cloud --&amp;gt;
    &amp;lt;remap from=&quot;/cloud_in&quot; to=&quot;/fusion_cloud&quot; /&amp;gt;
  &amp;lt;/node&amp;gt;
&amp;lt;/launch&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以下是所有可以配置的参数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;frame_id&lt;/code&gt; (&lt;code&gt;string&lt;/code&gt;, default: /map)
&lt;ul&gt;&lt;li&gt;Static global frame in which the map will be published. A transform from sensor data to this frame needs to be available when dynamically building maps.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;resolution&lt;/code&gt; (&lt;code&gt;float&lt;/code&gt;, default: 0.05)
&lt;ul&gt;&lt;li&gt;Resolution in meter for the map when starting with an empty map. Otherwise the loaded file's resolution is used&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;height_map&lt;/code&gt; (&lt;code&gt;bool&lt;/code&gt;, default: true)
&lt;ul&gt;&lt;li&gt;Whether visualization should encode height with different colors&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;color/[r/g/b/a]&lt;/code&gt; (&lt;code&gt;float&lt;/code&gt;)
&lt;ul&gt;&lt;li&gt;Color for visualizing occupied cells when ~heigh_map=False, in range [0:1]&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sensor_model/max_range&lt;/code&gt; (&lt;code&gt;float&lt;/code&gt;, default: -1 (unlimited))
&lt;ul&gt;&lt;li&gt;动态构建地图时用于插入点云数据的最大范围（以米为单位），将范围限制在有用的范围内（例如5m）可以防止虚假的错误点。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sensor_model/[hit|miss]&lt;/code&gt; (&lt;code&gt;float&lt;/code&gt;, default: 0.7 / 0.4)
&lt;ul&gt;&lt;li&gt;动态构建地图时传感器模型的命中率和未命中率&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sensor_model/[min|max]&lt;/code&gt; (&lt;code&gt;float&lt;/code&gt;, default: 0.12 / 0.97)
&lt;ul&gt;&lt;li&gt;动态构建地图时的最小和最大 clamp 概率&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;latch&lt;/code&gt; (&lt;code&gt;bool&lt;/code&gt;, default: True for a static map, false if no initial map is given)
&lt;ul&gt;&lt;li&gt;不管主题是锁定发布还是每次更改仅发布一次，为了在构建地图（频繁更新）时获得最佳性能，请将其设置为 false，如果设置为 true，在每个地图上更改都会创建所有主题和可视化。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;base_frame_id&lt;/code&gt;(string, default: base_footprint)
&lt;ul&gt;&lt;li&gt;The robot's base frame in which ground plane detection is performed (if enabled)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;filter_ground&lt;/code&gt;(bool, default: false)
&lt;ul&gt;&lt;li&gt;动态构建地图时是否应从扫描数据中检测并忽略地平面，这会将清除地面所有内容，但不会将地面作为障碍物插入到地图中。如果启用此功能，则可以使用 ground_filter 对其进行进一步配置&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ground_filter/distance&lt;/code&gt; (&lt;code&gt;float&lt;/code&gt;, default: 0.04)
&lt;ul&gt;&lt;li&gt;将点（在 z 方向上）分割为接地平面的距离阈值，小于该阈值被认为是平面&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ground_filter/angle&lt;/code&gt; (&lt;code&gt;float&lt;/code&gt;, default: 0.15)
&lt;ul&gt;&lt;li&gt;被检测平面相对于水平面的角度阈值，将其检测为地面&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ground_filter/plane_distance&lt;/code&gt; (&lt;code&gt;float&lt;/code&gt;, default: 0.07)
&lt;ul&gt;&lt;li&gt;对于要检测为平面的平面，从 z = 0 到距离阈值（来自PCL的平面方程的第4个系数）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pointcloud_[min|max]_z&lt;/code&gt; (&lt;code&gt;float&lt;/code&gt;, default: -/+ infinity)
&lt;ul&gt;&lt;li&gt;要在回调中插入的点的最小和最大高度，在运行任何插入或接地平面滤波之前，将丢弃此间隔之外的任何点。您可以以此为基础根据高度进行粗略过滤，但是如果启用了 ground_filter，则此间隔需要包括接地平面。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;occupancy_[min|max]_z&lt;/code&gt; (&lt;code&gt;float&lt;/code&gt;, default: -/+ infinity)
&lt;ul&gt;&lt;li&gt;最终 map 中要考虑的最小和最大占用单元格高度，发送可视化效果和碰撞 map 时，这会忽略区间之外的所有已占用体素，但不会影响实际的 octomap 表示。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;filter_speckles&lt;/code&gt;(bool)
&lt;ul&gt;&lt;li&gt;是否滤除斑&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;12-要求-tf-变换&quot;&gt;1.2 要求 TF 变换&lt;/h3&gt;
&lt;p&gt;有了全局坐标系和每一帧的点云，但是建图包怎么知道把每一帧点云插入到哪个位置呢？&lt;/p&gt;
&lt;p&gt;因为随着机器人的不断移动，会不断产生新的点云帧，每个点云帧在全局坐标系中插入的时候都有一个确定的位置，否则构建的地图就不对了，因此需要给建图包提供一个当前帧点云到全局坐标系的位姿，这样建图包才能根据这个位姿把当前获得的点云插入到正确的位置上。&lt;/p&gt;
&lt;p&gt;在 ROS 中可以很方便的使用 TF 来表示这个变换，我们只需要在启动建图包的时候，在系统的 TF 树中提供「cloud frame -&amp;gt; world frame」的变换就可以了：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;cloud frame -&amp;gt; world frame (static world frame, changeable with parameter frame_id)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;cloud frame&lt;/code&gt;：就是输入点云话题中 &lt;code&gt;head.frame_id&lt;/code&gt;，比如 Robosense 雷达的 &lt;code&gt;frame_id = rslidar&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;world frame&lt;/code&gt;：这是全局坐标系的 frame_id，在启动 launch 中需要手动给定，比如我给的是 &lt;code&gt;map&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果你给 &lt;code&gt;world frame id&lt;/code&gt; 指定的是输入点云的 &lt;code&gt;frame_id&lt;/code&gt;，比如 &lt;code&gt;fusion_cloud.head.frame_id == wolrd_frame_id == rslidar&lt;/code&gt;，则只会显示当前帧的八叉树，而不会增量构建地图，这点要注意了，可以自己测试看看。&lt;/p&gt;
&lt;p&gt;那么为了增量式建图，还需要在系统的 TF 树中提供「rslidar -&amp;gt; world」的变换，这个变换可以通过其他的 SLAM 等获得，比如我测试时候的一个 TF 树如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://dlonng.oss-cn-shenzhen.aliyuncs.com/blog/octomap_server_tf_test.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我找了下源代码 &lt;a href=&quot;https://github.com/OctoMap/octomap_mapping/blob/kinetic-devel/octomap_server/src/OctomapServer.cpp&quot;&gt;OctomapServer.cpp&lt;/a&gt; 中寻找 TF 的部分：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;        tf::StampedTransform sensorToWorldTf;
  try {
    m_tfListener.lookupTransform(m_worldFrameId, cloud-&amp;gt;header.frame_id, cloud-&amp;gt;header.stamp, sensorToWorldTf);
  } catch(tf::TransformException&amp;amp; ex){
    ROS_ERROR_STREAM( &quot;Transform error of sensor data: &quot; &amp;lt;&amp;lt; ex.what() &amp;lt;&amp;lt; &quot;, quitting callback&quot;);
    return;
  }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;总体来说这个建图包使用起来还是挺简单的，最重要的就是要写清楚输入点云话题和 TF 变换。&lt;/p&gt;
&lt;h4 id=&quot;小-tips：没有-tf-怎么办？&quot;&gt;小 Tips：没有 TF 怎么办？&lt;/h4&gt;
&lt;p&gt;我刚开始建图的时候，我同学录制的 TF 树中并没有「world -&amp;gt; rslidar」的变换，只有「world -&amp;gt; base_link」，所以为了能够测试增量式建图，因为我的点云帧的 frame_id 是 rslidar，因此我就手动发布了一个静态的「base_link -&amp;gt; rslidar」的变换：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;rosrun tf2_ros static_transform_publisher 0 0 0 0 0 0 base_link rslidar
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样系统中就有「rslidar -&amp;gt; world」的变换了，但是我发的位姿都是 0，所以对建图测试没有影响，为了方便启动，放在 launch 中：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;&amp;lt;node pkg = &quot;tf2_ros&quot; type = &quot;static_transform_publisher&quot; name = &quot;dlonng_static_test_broadcaster&quot; args = &quot;0 0 0 0 0 0 base_link rslidar&quot; /&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果你也遇到这个问题，可以试试发个静态 TF 做做测试，关于静态 TF 详细技术可以参考之前的文章：&lt;a href=&quot;https://dlonng.com/posts/static-tf&quot;&gt;ROS 机器人技术 - 静态 TF 坐标帧&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;二、coloroctomap-启用方法&quot;&gt;二、ColorOctomap 启用方法&lt;/h2&gt;
&lt;p&gt;为了显示 RGB 颜色，我分析了下源码，第一步修改头文件，打开注释切换地图类型：&lt;a href=&quot;https://github.com/OctoMap/octomap_mapping/blob/kinetic-devel/octomap_server/include/octomap_server/OctomapServer.h&quot;&gt;OctomapServer.h&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;// switch color here - easier maintenance, only maintain OctomapServer. 
// Two targets are defined in the cmake, octomap_server_color and octomap_server. One has this defined, and the other doesn't
// 打开这个注释
#define COLOR_OCTOMAP_SERVER

#ifdef COLOR_OCTOMAP_SERVER
  typedef pcl::PointXYZRGB PCLPoint;
  typedef pcl::PointCloud&amp;lt;pcl::PointXYZRGB&amp;gt; PCLPointCloud;
  typedef octomap::ColorOcTree OcTreeT;
#else
  typedef pcl::PointXYZ PCLPoint;
  typedef pcl::PointCloud&amp;lt;pcl::PointXYZ&amp;gt; PCLPointCloud;
  typedef octomap::OcTree OcTreeT;
#endif
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/OctoMap/octomap_mapping/blob/kinetic-devel/octomap_server/CMakeLists.txt&quot;&gt;CMakeList.txt&lt;/a&gt; 文件中有 &lt;code&gt;COLOR_OCTOMAP_SERVER&lt;/code&gt; 的编译选项：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;target_compile_definitions(${PROJECT_NAME}_color PUBLIC COLOR_OCTOMAP_SERVER)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/OctoMap/octomap_mapping/blob/kinetic-devel/octomap_server/src/OctomapServer.cpp&quot;&gt;OctomapServer.cpp&lt;/a&gt; 中有 colored_map 的参数：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;m_useHeightMap = true;
m_useColoredMap = false;
  
m_nh_private.param(&quot;height_map&quot;, m_useHeightMap, m_useHeightMap);
m_nh_private.param(&quot;colored_map&quot;, m_useColoredMap, m_useColoredMap);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;地图默认是按照高度设置颜色，如果要设置为带颜色的地图，就要禁用 HeightMap，并启用 ColoredMap：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;if (m_useHeightMap &amp;amp;&amp;amp; m_useColoredMap) {
    ROS_WARN_STREAM(&quot;You enabled both height map and RGB color registration. This is contradictory. Defaulting to height map.&quot;);
    m_useColoredMap = false;
  }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第二步、需要在 octomap_server 的 launch 文件中禁用 height_map，并启用 &lt;a href=&quot;https://github.com/OctoMap/octomap_mapping/blob/kinetic-devel/octomap_server/src/OctomapServer.cpp&quot;&gt;colored_map&lt;/a&gt; ：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;param name=&quot;height_map&quot; value=&quot;false&quot; /&amp;gt;
&amp;lt;param name=&quot;colored_map&quot; value=&quot;true&quot; /&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2 个核心的八叉树生成函数 &lt;code&gt;insertCloudCallback&lt;/code&gt; 和 &lt;code&gt;insertScan&lt;/code&gt; 中有对颜色的操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;#ifdef COLOR_OCTOMAP_SERVER
  unsigned char* colors = new unsigned char[3];
#endif

// NB: Only read and interpret color if it's an occupied node
#ifdef COLOR_OCTOMAP_SERVER 
        m_octree-&amp;gt;averageNodeColor(it-&amp;gt;x, it-&amp;gt;y, it-&amp;gt;z, /*r=*/it-&amp;gt;r, /*g=*/it-&amp;gt;g, /*b=*/it-&amp;gt;b);
#endif
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;三、保存和显示地图&quot;&gt;三、保存和显示地图&lt;/h2&gt;
&lt;p&gt;启动 octomap_server 节点后，可以使用它提供的地图保存服务，保存压缩的二进制存储格式地图：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;octomap_saver mapfile.bt
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;保存一个完整的概率八叉树地图：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;octomap_saver -f mapfile.ot
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装八叉树可视化程序 octovis 来查看地图：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;sudo apt-get install octovis
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装后重启终端，使用以下命令显示一个八叉树地图：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;octovis xxx.ot[bt]
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;四、源码阅读笔记&quot;&gt;四、源码阅读笔记&lt;/h2&gt;
&lt;p&gt;在开组会汇报的时候，整理了以下这个建图包的关键流程，只有 2 个关键的函数也不是很复杂，我给代码加了注释，在文末可以下载。&lt;/p&gt;
&lt;p&gt;第一步是订阅点云的回调：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://dlonng.oss-cn-shenzhen.aliyuncs.com/blog/insert_pointcloud.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第二步是插入单帧点云构建八叉树，这里就不详细介绍过程了，因为涉及到八叉树库 octomap 的更新原理：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://dlonng.oss-cn-shenzhen.aliyuncs.com/blog/insert_scan.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;放一张我们学院后面的一条小路的建图结果，分辨率是 15cm：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://dlonng.oss-cn-shenzhen.aliyuncs.com/blog/map_test.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以下是我建图过程的 launch：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;launch&amp;gt;
  &amp;lt;node pkg=&quot;octomap_server&quot; type=&quot;octomap_server_node&quot; name=&quot;octomap_server&quot;&amp;gt;
    &amp;lt;!-- resolution in meters per pixel --&amp;gt;
    &amp;lt;param name = &quot;resolution&quot; value = &quot;0.15&quot; /&amp;gt;

    &amp;lt;!-- name of the fixed frame, needs to be &quot;/map&quot; for SLAM --&amp;gt;
    &amp;lt;!-- 静态全局地图的 frame_id，但在增量式构建地图时，需要提供输入的点云帧和静态全局帧之间的 TF 变换 --&amp;gt;
    &amp;lt;param name = &quot;frame_id&quot; type = &quot;string&quot; value = &quot;camera_init&quot; /&amp;gt;

    &amp;lt;!-- set min to speed up! --&amp;gt;
    &amp;lt;param name = &quot;sensor_model/max_range&quot; value = &quot;15.0&quot; /&amp;gt;

    &amp;lt;!-- 机器人坐标系 base_link，滤除地面需要该 frame --&amp;gt;
    &amp;lt;!-- &amp;lt;param name = &quot;base_frame_id&quot; type = &quot;string&quot; value = &quot;base_link&quot; /&amp;gt; --&amp;gt;

    &amp;lt;!-- filter ground plane, distance value should be big! 项目并不需要滤除地面 --&amp;gt;
        &amp;lt;!-- &amp;lt;param name = &quot;filter_ground&quot; type = &quot;bool&quot; value = &quot;true&quot; /&amp;gt; --&amp;gt;
    &amp;lt;!-- &amp;lt;param name = &quot;ground_filter/distance&quot; type = &quot;double&quot; value = &quot;1.0&quot; /&amp;gt; --&amp;gt;
    &amp;lt;!-- 分割地面的 Z 轴阈值 value 值 --&amp;gt;
        &amp;lt;!-- &amp;lt;param name = &quot;ground_filter/plane_distance&quot; type = &quot;double&quot; value = &quot;0.3&quot; /&amp;gt; --&amp;gt;

    &amp;lt;!-- 直通滤波的 Z 轴范围，保留 [-1.0, 10.0] 范围内的点 --&amp;gt;
    &amp;lt;!-- &amp;lt;param name = &quot;pointcloud_max_z&quot; type = &quot;double&quot; value = &quot;100.0&quot; /&amp;gt; --&amp;gt;
    &amp;lt;!-- &amp;lt;param name = &quot;pointcloud_min_z&quot; type = &quot;double&quot; value = &quot;-1.0&quot; /&amp;gt; --&amp;gt;

    &amp;lt;!-- &amp;lt;param name = &quot;filter_speckles&quot; type = &quot;bool&quot; value = &quot;true&quot; /&amp;gt; --&amp;gt;

    &amp;lt;param name = &quot;height_map&quot; value = &quot;false&quot; /&amp;gt;
    &amp;lt;param name = &quot;colored_map&quot; value = &quot;true&quot; /&amp;gt;
        
    &amp;lt;!-- 增加了半径滤波器 --&amp;gt;
    &amp;lt;param name = &quot;outrem_radius&quot; type = &quot;double&quot; value = &quot;1.0&quot; /&amp;gt;
    &amp;lt;param name = &quot;outrem_neighbors&quot; type = &quot;int&quot; value = &quot;10&quot; /&amp;gt;

    &amp;lt;!-- when building map, set to false to speed up!!! --&amp;gt;
    &amp;lt;param name = &quot;latch&quot; value = &quot;false&quot; /&amp;gt; 

    &amp;lt;!-- topic from where pointcloud2 messages are subscribed --&amp;gt;
    &amp;lt;!-- 要订阅的点云主题名称 /pointcloud/output --&amp;gt;
    &amp;lt;!-- 这句话的意思是把当前节点订阅的主题名称从 cloud_in 变为 /pointcloud/output --&amp;gt;
    &amp;lt;remap from = &quot;/cloud_in&quot; to = &quot;/fusion_cloud&quot; /&amp;gt;
 
  &amp;lt;/node&amp;gt;
&amp;lt;/launch&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我做的项目代码在这里：&lt;a href=&quot;https://github.com/DLonng/AI-Notes/tree/master/SemanticMap/semantic_map_ws&quot;&gt;AI - Notes: semantic_map&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://dlonng.oss-cn-shenzhen.aliyuncs.com/yingliu_code/yinliu_code.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 10 Aug 2020 00:39:00 +0000</pubDate>
<dc:creator>登龙</dc:creator>
<og:description>构建语义地图时，最开始用的是 octomap_server，后面换成了 semantic_slam: octomap_generator，不过还是整理下之前的学习笔记。 一、增量构建八叉树地图步骤 为</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/dlonng/p/13467644.html</dc:identifier>
</item>
<item>
<title>使用java API进行zip递归压缩文件夹以及解压 - 字母哥博客</title>
<link>http://www.cnblogs.com/zimug/p/13467639.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zimug/p/13467639.html</guid>
<description>&lt;h2 id=&quot;一、概述&quot;&gt;一、概述&lt;/h2&gt;
&lt;p&gt;在本篇文章中，给大家介绍一下如何将文件进行zip压缩以及如何对zip包解压。所有这些都是使用Java提供的核心库&lt;strong&gt;java.util.zip&lt;/strong&gt;来实现的。&lt;/p&gt;
&lt;h2 id=&quot;二、压缩文件&quot;&gt;二、压缩文件&lt;/h2&gt;
&lt;p&gt;首先我们来学习一个简单的例子-压缩单个文件。将一个名为&lt;em&gt;test1.txt&lt;/em&gt;的文件压缩到一个名为&lt;em&gt;Compressed.zip&lt;/em&gt;的zip文件中。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class ZipFile {
    public static void main(String[] args) throws IOException {
       
        //输出压缩包
        FileOutputStream fos = new FileOutputStream(&quot;src/main/resources/compressed.zip&quot;);
        ZipOutputStream zipOut = new ZipOutputStream(fos);

        //被压缩文件
        File fileToZip = new File(&quot;src/main/resources/test1.txt&quot;);
        FileInputStream fis = new FileInputStream(fileToZip);
        
        //向压缩包中添加文件
        ZipEntry zipEntry = new ZipEntry(fileToZip.getName());
        zipOut.putNextEntry(zipEntry);
        byte[] bytes = new byte[1024];
        int length;
        while((length = fis.read(bytes)) &amp;gt;= 0) {
            zipOut.write(bytes, 0, length);
        }
        zipOut.close();
        fis.close();
        fos.close();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;三、压缩多个文件&quot;&gt;三、压缩多个文件&lt;/h2&gt;
&lt;p&gt;接下来，我们看看如何将多个文件压缩为一个zip文件。我们将把&lt;em&gt;test1.txt&lt;/em&gt;和&lt;em&gt;test2.txt&lt;/em&gt;压缩成&lt;em&gt;multiCompressed.zip&lt;/em&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class ZipMultipleFiles {
    public static void main(String[] args) throws IOException {
        List&amp;lt;String&amp;gt; srcFiles = Arrays.asList(&quot;src/main/resources/test1.txt&quot;, &quot;src/main/resources/test2.txt&quot;);
        FileOutputStream fos = new FileOutputStream(&quot;src/main/resources/multiCompressed.zip&quot;);
        ZipOutputStream zipOut = new ZipOutputStream(fos);
        //向压缩包中添加多个文件
        for (String srcFile : srcFiles) {
            File fileToZip = new File(srcFile);
            FileInputStream fis = new FileInputStream(fileToZip);
            ZipEntry zipEntry = new ZipEntry(fileToZip.getName());
            zipOut.putNextEntry(zipEntry);
 
            byte[] bytes = new byte[1024];
            int length;
            while((length = fis.read(bytes)) &amp;gt;= 0) {
                zipOut.write(bytes, 0, length);
            }
            fis.close();
        }
        zipOut.close();
        fos.close();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;四、压缩目录&quot;&gt;四、压缩目录&lt;/h2&gt;
&lt;p&gt;下面的例子，我们将&lt;em&gt;zipTest&lt;/em&gt;目录及该目录下的递归子目录文件，全都压缩到&lt;em&gt;dirCompressed.zip中&lt;/em&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class ZipDirectory {
    public static void main(String[] args) throws IOException, FileNotFoundException {
        //被压缩的文件夹
        String sourceFile = &quot;src/main/resources/zipTest&quot;; 
        //压缩结果输出，即压缩包
        FileOutputStream fos = new FileOutputStream(&quot;src/main/resources/dirCompressed.zip&quot;);
        ZipOutputStream zipOut = new ZipOutputStream(fos);
        File fileToZip = new File(sourceFile);
        //递归压缩文件夹
        zipFile(fileToZip, fileToZip.getName(), zipOut);
        //关闭输出流
        zipOut.close();
        fos.close();
    }
     

    /**
     * 将fileToZip文件夹及其子目录文件递归压缩到zip文件中
     * @param fileToZip 递归当前处理对象，可能是文件夹，也可能是文件
     * @param fileName fileToZip文件或文件夹名称
     * @param zipOut 压缩文件输出流
     * @throws IOException
     */
    private static void zipFile(File fileToZip, String fileName, ZipOutputStream zipOut) throws IOException {
        //不压缩隐藏文件夹
        if (fileToZip.isHidden()) {
            return;
        }
        //判断压缩对象如果是一个文件夹
        if (fileToZip.isDirectory()) {
            if (fileName.endsWith(&quot;/&quot;)) {
                //如果文件夹是以“/”结尾，将文件夹作为压缩箱放入zipOut压缩输出流
                zipOut.putNextEntry(new ZipEntry(fileName));
                zipOut.closeEntry();
            } else {
                //如果文件夹不是以“/”结尾，将文件夹结尾加上“/”之后作为压缩箱放入zipOut压缩输出流
                zipOut.putNextEntry(new ZipEntry(fileName + &quot;/&quot;));
                zipOut.closeEntry();
            }
            //遍历文件夹子目录，进行递归的zipFile
            File[] children = fileToZip.listFiles();
            for (File childFile : children) {
                zipFile(childFile, fileName + &quot;/&quot; + childFile.getName(), zipOut);
            }
            //如果当前递归对象是文件夹，加入ZipEntry之后就返回
            return;
        }
        //如果当前的fileToZip不是一个文件夹，是一个文件，将其以字节码形式压缩到压缩包里面
        FileInputStream fis = new FileInputStream(fileToZip);
        ZipEntry zipEntry = new ZipEntry(fileName);
        zipOut.putNextEntry(zipEntry);
        byte[] bytes = new byte[1024];
        int length;
        while ((length = fis.read(bytes)) &amp;gt;= 0) {
            zipOut.write(bytes, 0, length);
        }
        fis.close();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;要压缩子目录及其子目录文件，所以需要递归遍历&lt;/li&gt;
&lt;li&gt;每次遍历找到的是目录时，我们都将其名称附加“/”,并将其以&lt;em&gt;ZipEntry&lt;/em&gt;保存到压缩包中，从而保持压缩的目录结构。&lt;/li&gt;
&lt;li&gt;每次遍历找到的是文件时，将其以字节码形式压缩到压缩包里面&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;五、解压缩zip压缩包&quot;&gt;五、解压缩zip压缩包&lt;/h2&gt;
&lt;p&gt;下面为大家举例讲解解压缩zip压缩包。在此示例中，我们将&lt;em&gt;compressed.zip&lt;/em&gt;解压缩到名为&lt;em&gt;unzipTest&lt;/em&gt;的新文件夹中。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class UnzipFile {
    public static void main(String[] args) throws IOException {
        //被解压的压缩文件
        String fileZip = &quot;src/main/resources/unzipTest/compressed.zip&quot;;
        //解压的目标目录
        File destDir = new File(&quot;src/main/resources/unzipTest&quot;);

        byte[] buffer = new byte[1024];
        ZipInputStream zis = new ZipInputStream(new FileInputStream(fileZip));
        //获取压缩包中的entry，并将其解压
        ZipEntry zipEntry = zis.getNextEntry();
        while (zipEntry != null) {
            File newFile = newFile(destDir, zipEntry);
            FileOutputStream fos = new FileOutputStream(newFile);
            int len;
            while ((len = zis.read(buffer)) &amp;gt; 0) {
                fos.write(buffer, 0, len);
            }
            fos.close();
            //解压完成一个entry，再解压下一个
            zipEntry = zis.getNextEntry();
        }
        zis.closeEntry();
        zis.close();
    }
    //在解压目标文件夹，新建一个文件
    public static File newFile(File destinationDir, ZipEntry zipEntry) throws IOException {
        File destFile = new File(destinationDir, zipEntry.getName());

        String destDirPath = destinationDir.getCanonicalPath();
        String destFilePath = destFile.getCanonicalPath();

        if (!destFilePath.startsWith(destDirPath + File.separator)) {
            throw new IOException(&quot;该解压项在目标文件夹之外: &quot; + zipEntry.getName());
        }

        return destFile;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;欢迎关注我的博客，里面有很多精品合集&quot;&gt;欢迎关注我的博客，里面有很多精品合集&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;本文转载注明出处（必须带连接，不能只转文字）：&lt;a href=&quot;http://www.zimug.com&quot;&gt;字母哥博客&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;觉得对您有帮助的话，帮我点赞、分享！您的支持是我不竭的创作动力！&lt;/strong&gt; 。另外，笔者最近一段时间输出了如下的精品内容，期待您的关注。&lt;/p&gt;
</description>
<pubDate>Mon, 10 Aug 2020 00:38:00 +0000</pubDate>
<dc:creator>字母哥博客</dc:creator>
<og:description>一、概述 在本篇文章中，给大家介绍一下如何将文件进行zip压缩以及如何对zip包解压。所有这些都是使用Java提供的核心库java.util.zip来实现的。 二、压缩文件 首先我们来学习一个简单的例</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zimug/p/13467639.html</dc:identifier>
</item>
<item>
<title>Java 开发者的编程噩梦，为什么你的代码总有 bug🐛？ - 未读代码</title>
<link>http://www.cnblogs.com/niumoo/p/13467640.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/niumoo/p/13467640.html</guid>
<description>&lt;blockquote readability=&quot;4.8066298342541&quot;&gt;
&lt;p&gt;文章已经收录在 &lt;a href=&quot;https://github.com/niumoo/JavaNotes&quot;&gt;Github.com/niumoo/JavaNotes&lt;/a&gt; ，更有 Java 程序员所需要掌握的核心知识，欢迎Star和指教。&lt;br/&gt;欢迎关注我的&lt;a href=&quot;https://github.com/niumoo/JavaNotes#%E5%85%AC%E4%BC%97%E5%8F%B7&quot;&gt;公众号&lt;/a&gt;，文章每周更新。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;很多 Java 初学者在开始编程时会出现一些问题，这些问题并不是指某个特定领域的问题，也不是指对某个业务不熟悉而导致的问题，而是对基础知识不够熟悉导致的问题。而就是这些问题让我们编写了一些不够健壮的代码。&lt;br/&gt;这篇文章会列举几种编程初学者常常出现的一些问题，我相信这些问题多多少少也曾困扰着现在或曾经的你。如果觉得文章不错，不妨点赞分享，让更多人跳过这些开发中的坑。&lt;/p&gt;
&lt;h2 id=&quot;随处可见的-null-值&quot;&gt;随处可见的 Null 值&lt;/h2&gt;
&lt;p&gt;我见过很多的代码会把 Null 值作为返回值，当你预期是一个字符串时，意外得到了一个 Null 值；当你预期得到一个 List 时，意外又得到了一个 Null 值，如果你不进行处理，那么你还会意外得到 &lt;code&gt;NullPointerException&lt;/code&gt;.&lt;br/&gt;就像下面这样。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 情况1
String userTag = getUserTag();
if (userTag.equals(&quot;admin&quot;)) { // NullPointerException
   // ...
}

// 情况2
List&amp;lt;String&amp;gt; carList = getCarList();
for (String car : carList) { // NullPointerException
    // ...
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了防止这种情况，你可以在 List 返回时给出一个空的集合而不是 Null，如果是字符串，你可以把要确定有值对象放在比较的前面。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;if (&quot;admin&quot;.equals(userTag)) {
    // ...
}
// 或者
if (Objects.equals(userTag,&quot;admin&quot;)){
    // ...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;没有进行空值检查&quot;&gt;没有进行空值检查&lt;/h2&gt;
&lt;p&gt;可能你考虑到了上面的 Null 值情况，但是在实际处理时没有考虑空值情况，比如字符空串空串 &quot;&quot;，或者集合为空。那么在后续处理时又有可能得到一个 &lt;code&gt;NullPointerException&lt;/code&gt;. 所以你应该进行空值判断。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;String userTag = getUserTag();
if (userTag != null &amp;amp;&amp;amp; userTag.trim() != &quot;&quot;) {
    // ...
}

List&amp;lt;String&amp;gt; carList = getCarList();
if (carList != null &amp;amp;&amp;amp; !carList.isEmpty()) {
    // ...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;忽略的异常处理&quot;&gt;忽略的异常处理&lt;/h2&gt;
&lt;p&gt;异常处理总是一件烦人的事，而忽略异常似乎总有一种吸引人的魔力。我见过像下面这样的代码。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;try {
    List&amp;lt;String&amp;gt; result= request();
    // ...
}catch (Exception e){
    
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你没有看错，catch 中没有任何内容，后来出现了问题，看着日志文件一片太平无迹可寻。异常是故意抛出来的，你应该正确处理它们或者继续抛出。而且同时，你该输出一行日志用来记录这个异常，方便以后的问题追踪。&lt;/p&gt;
&lt;h2 id=&quot;没有释放资源&quot;&gt;没有释放资源&lt;/h2&gt;
&lt;p&gt;在读取文件或者请求网络资源时，总是需要进行 close 操作，这很重要，否则可能会阻塞其他线程的使用。但是初学者可能会忘记这一步操作。其实在 Java 7 开始，就提供了 &lt;code&gt;try-with-resources&lt;/code&gt; 自动关闭资源的特性，只需要把打开的资源放入 &lt;code&gt;try&lt;/code&gt; 中。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;try (FileReader fileReader = new FileReader(&quot;setting.xml&quot;)) {
    // fileReader.read();
    // ...
} catch (Exception e) {
    e.printStackTrace();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;像上面这样，不需要在 &lt;code&gt;finally&lt;/code&gt; 里手动调用 &lt;code&gt;fileReader&lt;/code&gt; 的 &lt;code&gt;close&lt;/code&gt; 方法关闭资源，因为放在 &lt;code&gt;try&lt;/code&gt; 里的资源调用会在使用完毕时自动调用 &lt;code&gt;close&lt;/code&gt;. 而且不管是否有异常抛出，这很实用。&lt;/p&gt;
&lt;h2 id=&quot;concuretmodificationexception&quot;&gt;ConcuretModificationException&lt;/h2&gt;
&lt;p&gt;总有一天你会遇到 &lt;code&gt;ConcuretModificationException&lt;/code&gt; ，然后开始百度搜索它的解决方式，这个异常最常见的场景是你在遍历一个集合时进行更新操作，比如像下面这样。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
list.add(&quot;a1&quot;);
list.add(&quot;b1&quot;);
list.add(&quot;b2&quot;);
list.add(&quot;c1&quot;);
for (String s : list) {
    if (&quot;b1&quot;.equals(s)) {
        list.remove(s);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个异常很有用处，因为 ArrayList 不是线程安全的集合，假设你这边一边遍历，另一个线程不断更新，非线程安全集合会导致你的遍历结果不正确，所以这个异常的存在是合理的。同理 HashMap 也是如此，关于 HashMap 之前已经有一篇文章详细介绍了，可以参考 &lt;a href=&quot;https://mp.weixin.qq.com/s/q-rWq79HmzPe08gyfOjaIA&quot;&gt;最通俗易懂的 HashMap 源码分析解读&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;缺少注释&quot;&gt;缺少注释&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;准确的注释可以救人于水火&lt;/strong&gt;，这点有时候一点也不夸张。虽然说优秀的代码本身就是非常好的注释，但是这实际开发起来，很少发生。注释并不需要你事无巨细的一一记录，但是你该在核心逻辑添加应有的注释，比如复杂逻辑的实现思路，当前逻辑业务需求。某个判断的添加原因，某个异常的发生情况等等。这可以让你在未来的某一天需要回看现在的代码时感谢自己。更可以&lt;strong&gt;让你在某天的甩锅中轻松胜出&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;不进行代码测试&quot;&gt;不进行代码测试&lt;/h2&gt;
&lt;p&gt;我见过有些同事在功能开发完毕后直接扔给对接同事使用，而自己却没有经过任何测试，或者只是测试了某个简单的情况。测试是开发过程中的重要环节，没有经过严格测试的代码很难说没有问题，我觉得在功能开发完毕后至少需要&lt;strong&gt;单元测试&lt;/strong&gt;，&lt;strong&gt;特殊用例&lt;/strong&gt;测试，&lt;strong&gt;集成测试&lt;/strong&gt;以及其他形式的测试。&lt;strong&gt;严格的测试不仅可以第一时间发现问题，更可以减少后面不必要的对接调试时间&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;重复造轮子&quot;&gt;重复造轮子&lt;/h2&gt;
&lt;p&gt;你知道的，Java 社区非常活跃，存在着大量的第三方类库，开源作者可能花费了数年时间去维护和完善类库，这些类库非常优秀。同时 JDK 也提供了大量的常用的功能封装。这些都可以&lt;strong&gt;为我们的开发速度插上翅膀&lt;/strong&gt;。所以，当你需要一个功能时候，应该首先看下 JDK 和已经引入的类库中是否已经存在相同功能，而不是自己重复造轮子，而且大部分情况下你造的轮子还不如别人好。&lt;/p&gt;
&lt;p&gt;下面举些例子。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;你需要日志记录，可以使用 logback.&lt;/li&gt;
&lt;li&gt;你需要网络操作，可以使用 netty.&lt;/li&gt;
&lt;li&gt;你需要解析 JSON，可以使用 gson.&lt;/li&gt;
&lt;li&gt;你需要解析表格，可以使用 apache poi.&lt;/li&gt;
&lt;li&gt;你需要通用操作，可以使用 apache commons.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;另外一种情况是，你可能不知道某个功能在 JDK 中已经实现，这时候你应该多多查看 JDK Document. 我就在工作中见到过同事手写字符串 split，为了获取时间戳把 Date 对象转换到 Calendar.&lt;/p&gt;
&lt;h2 id=&quot;缺少必要的沟通&quot;&gt;缺少必要的沟通&lt;/h2&gt;
&lt;p&gt;这个部分是和开发没有关系的，但是这个环节往往会影响最终的开发结果。进行具体的开发之前，你应该详细的沟通并理解功能的需求，这样你才能针对具体的需求写出不偏离实际需要的代码。有时候你很有可能因为缺少必要的沟通，错误了理解了需求，最终在开发完毕后发现自己写的功能完全没有用处。&lt;/p&gt;
&lt;h2 id=&quot;没有代码规范&quot;&gt;没有代码规范&lt;/h2&gt;
&lt;p&gt;代码规范性非常重要，如果一个项目里充斥着各种稀奇古怪的代码规范，会让维护者十分头疼。而且软件行业高速发展，对开发者的综合素质要求也越来越高，优秀的编程习惯也可以提高软件的最终质量。比如：标新立异的命名风格挑战阅读习惯；五花八门的错误码人为地 增加排查问题的难度；工程结构混 乱导致后续项目维护艰难；没有鉴权的漏洞代码易被黑客攻击；质量低下的代码上线之后漏洞百出等等。因为没有统一的代码规范，开发中的问题可能层出不穷。&lt;/p&gt;
&lt;p&gt;下面简单列举些应该统一的开发规范。如&lt;strong&gt;命名风格如何是好；常量名称结构怎样；代码格式怎么统一；日期时间格式如何处理；集合处理注意事项；日志打印有无规范；前后交互具体规约&lt;/strong&gt;等。&lt;/p&gt;
&lt;p&gt;上面所说的开发规范代码规范推荐阿里推出的 《&lt;strong&gt;Java 开发手册&lt;/strong&gt;》，里面详细列举了在 Java 开发中各个方面应该遵守的规约和规范。最新版本在 8月 3日已经发布，可以在公众号 “&lt;strong&gt;未读代码&lt;/strong&gt;” 直接回复 &quot;java &quot; &lt;strong&gt;获取最新版 pdf.&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;Bug 和技术上的误解都是美丽的谜团，福尔摩斯般的我们终将解决这些问题。命运自己掌握，每一次探清的这些技术误解，都会增加我们对开发编码的理解。&lt;strong&gt;尽情接招吧，色彩斑斓才有趣，万般体验才是人生，不管是多样的技术，还是多样的问题，我都想看见。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;[1] &lt;a href=&quot;https://jaxenter.com/java-programming-nightmares-156749.html&quot;&gt;A beginner’s guide to Java programming nightmares&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[2] &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/&quot;&gt;Java™ Platform, Standard Edition 8 API Specification&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最后的话&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6.2348178137652&quot;&gt;
&lt;p&gt;文章已经收录在 &lt;a href=&quot;https://github.com/niumoo/JavaNotes&quot;&gt;Github.com/niumoo/JavaNotes&lt;/a&gt; ，欢迎Star和指教。更有一线大厂面试点，Java程序员需要掌握的核心知识等文章，也整理了很多我的文字，欢迎 &lt;strong&gt;Star&lt;/strong&gt; 和完善，希望我们一起变得优秀。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;文章有帮助可以点个「&lt;strong&gt;赞&lt;/strong&gt;」或「&lt;strong&gt;分享&lt;/strong&gt;」，都是支持，我都喜欢！&lt;br/&gt;文章每周持续更新，要实时关注我更新的文章以及分享的干货，可以关注「 &lt;strong&gt;未读代码&lt;/strong&gt; 」公众号或者&lt;a href=&quot;https://www.wdbyte.com/&quot;&gt;我的博客&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/niumoo/cdn-assets@439f6a5f6bd130e2aec56f3527656d6edb487b91/webinfo/weixin-public.jpg&quot; alt=&quot;公众号&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 10 Aug 2020 00:38:00 +0000</pubDate>
<dc:creator>未读代码</dc:creator>
<og:description>为什么你的代码总有 bug🐛？这些坑你没踩过算我输。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/niumoo/p/13467640.html</dc:identifier>
</item>
<item>
<title>设计模式之状态模式 - WeihanLi</title>
<link>http://www.cnblogs.com/weihanli/p/state-pattern.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/weihanli/p/state-pattern.html</guid>
<description>&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;状态模式（State），当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;使用场景&quot;&gt;使用场景&lt;/h2&gt;
&lt;p&gt;当一个对象的行为取决于它的状态，并且它必须在运行时根据状态改变它的行为时就可以考虑状态模式。&lt;/p&gt;
&lt;p&gt;状态模式主要解决的是当控制一个对象状态转换的条件表达式过于复杂时的情况。把状态的判断逻辑转移到表示不同状态的一系列类当中，可以把复杂的判断逻辑简化。&lt;/p&gt;
&lt;p&gt;状态模式的好处是将与特定状态相关的行为局部化，并且将不同状态的行为分隔开来。将特定的状态相关的行为都放入一个对象中，由于所有与状态相关的代码都存在于某个 &lt;code&gt;State&lt;/code&gt; 中，所以通过定义新的子类可以很容易地增加新的状态和转换。&lt;/p&gt;
&lt;p&gt;状态模式通过把各种状态转义逻辑分布到 &lt;code&gt;State&lt;/code&gt; 的子类之间，来减少相互之间的依赖。&lt;/p&gt;
&lt;h2 id=&quot;sample&quot;&gt;Sample&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;class Work
{
    private WorkState _currentState;

    public Work()
    {
        _currentState = new ForenoonState();
    }

    public int Hour { get; set; }

    public bool TaskFinished { get; set; }

    public void SetState(WorkState workState)
    {
        _currentState = workState;
    }

    public void WriteProgram()
    {
        _currentState.WriteProgram(this);
    }
}


internal abstract class WorkState
{
    public abstract void WriteProgram(Work work);
}

internal class ForenoonState : WorkState
{
    public override void WriteProgram(Work work)
    {
        if (work.Hour &amp;lt; 12)
        {
            Console.WriteLine($&quot;当前时间：{work.Hour}点 上午工作，精神百倍&quot;);
        }
        else
        {
            work.SetState(new NoonState());
            work.WriteProgram();
        }
    }
}

internal class NoonState : WorkState
{
    public override void WriteProgram(Work work)
    {
        if (work.Hour &amp;lt; 13)
        {
            Console.WriteLine($&quot;当前时间：{work.Hour}点 饿了，午饭。犯困，午休&quot;);
        }
        else
        {
            work.SetState(new AfternoonState());
            work.WriteProgram();
        }
    }
}

internal class AfternoonState : WorkState
{
    public override void WriteProgram(Work work)
    {
        if (work.Hour &amp;lt; 18)
        {
            Console.WriteLine($&quot;当前时间：{work.Hour}点 下午状态还不错，继续努力&quot;);
        }
        else
        {
            work.SetState(new EveningState());
            work.WriteProgram();
        }
    }
}

internal class EveningState : WorkState
{
    public override void WriteProgram(Work work)
    {
        if (work.TaskFinished)
        {
            work.SetState(new RestState());
            work.WriteProgram();
        }
        else
        {
            if (work.Hour &amp;lt; 21)
            {
                Console.WriteLine($&quot;当前时间：{work.Hour}点 还在加班啊，疲累之极&quot;);
            }
            else
            {
                work.SetState(new SleepingState());
                work.WriteProgram();
            }
        }
    }
}

internal class RestState : WorkState
{
    public override void WriteProgram(Work work)
    {
        Console.WriteLine($&quot;当前时间：{work.Hour}点 下班回家了&quot;);
    }
}

internal class SleepingState : WorkState
{
    public override void WriteProgram(Work work)
    {
        Console.WriteLine($&quot;当前时间：{work.Hour}点了，不行了，睡着了。&quot;);
    }
}


var emergenceWork = new Work();

emergenceWork.Hour = 9;
emergenceWork.WriteProgram();

emergenceWork.Hour = 10;
emergenceWork.WriteProgram();

emergenceWork.Hour = 12;
emergenceWork.WriteProgram();

emergenceWork.Hour = 13;
emergenceWork.WriteProgram();

emergenceWork.Hour = 14;
emergenceWork.WriteProgram();

emergenceWork.Hour = 17;
emergenceWork.WriteProgram();

emergenceWork.TaskFinished = true;//任务完成，可以提前回家了
// emergenceWork.TaskFinished = false;//任务没完成，在公司加班吧

emergenceWork.Hour = 19;
emergenceWork.WriteProgram();

emergenceWork.Hour = 21;
emergenceWork.WriteProgram();
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;more&quot;&gt;More&lt;/h2&gt;
&lt;p&gt;在状态模式中，我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的 context 对象。&lt;/p&gt;
&lt;p&gt;状态模式一般用来实现状态机，而状态机常用在游戏、工作流引擎等系统开发中。&lt;/p&gt;
&lt;p&gt;有限状态机，英文翻译是 Finite State Machine，缩写为 FSM，简称为状态机。&lt;/p&gt;
&lt;p&gt;状态机有 3 个组成部分：状态（State）、事件（Event）、动作（Action）。其中，事件也称为转移条件（Transition Condition）。事件触发状态的转移及动作的执行。不过，动作不是必须的，也可能只转移状态，不执行任何动作。&lt;/p&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
</description>
<pubDate>Mon, 10 Aug 2020 00:29:00 +0000</pubDate>
<dc:creator>WeihanLi</dc:creator>
<og:description>状态模式</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/weihanli/p/state-pattern.html</dc:identifier>
</item>
<item>
<title>面试这么撩准拿offer，HashMap深度学习，扰动函数、负载因子、扩容拆分，原理和实践验证，让懂了就是真的懂！ - 小傅哥</title>
<link>http://www.cnblogs.com/xiaofuge/p/13467534.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaofuge/p/13467534.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020081007375926.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;作者：小傅哥&lt;br/&gt;博客：&lt;a href=&quot;https://bugstack.cn&quot;&gt;https://bugstack.cn&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;沉淀、分享、成长，让自己和他人都能有所收获！😄&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一、前言&quot;&gt;一、前言&lt;/h2&gt;
&lt;p&gt;得益于&lt;code&gt;Doug Lea&lt;/code&gt;老爷子的操刀，让&lt;code&gt;HashMap&lt;/code&gt;成为使用和面试最频繁的API，没办法设计的太优秀了！&lt;/p&gt;
&lt;p&gt;HashMap 最早出现在 JDK 1.2中，底层基于散列算法实现。HashMap 允许 null 键和 null 值，在计算哈键的哈希值时，null 键哈希值为 0。HashMap 并不保证键值对的顺序，这意味着在进行某些操作后，键值对的顺序可能会发生变化。另外，需要注意的是，HashMap 是非线程安全类，在多线程环境下可能会存在问题。&lt;/p&gt;
&lt;p&gt;HashMap 最早在JDK 1.2中就出现了，底层是基于散列算法实现，随着几代的优化更新到目前为止它的源码部分已经比较复杂，涉及的知识点也非常多，在JDK 1.8中包括；&lt;code&gt;1、散列表实现&lt;/code&gt;、&lt;code&gt;2、扰动函数&lt;/code&gt;、&lt;code&gt;3、初始化容量&lt;/code&gt;、&lt;code&gt;4、负载因子&lt;/code&gt;、&lt;code&gt;5、扩容元素拆分&lt;/code&gt;、&lt;code&gt;6、链表树化&lt;/code&gt;、&lt;code&gt;7、红黑树&lt;/code&gt;、&lt;code&gt;8、插入&lt;/code&gt;、&lt;code&gt;9、查找&lt;/code&gt;、&lt;code&gt;10、删除&lt;/code&gt;、&lt;code&gt;11、遍历&lt;/code&gt;、&lt;code&gt;12、分段锁&lt;/code&gt;等等，因涉及的知识点较多所以需要分开讲解，本章节我们会先把目光放在前五项上，也就是关于数据结构的使用上。&lt;/p&gt;
&lt;p&gt;数据结构相关往往与数学离不开，学习过程中建议下载相应源码进行实验验证，可能这个过程有点烧脑，但学会后不用死记硬背就可以理解这部分知识。&lt;/p&gt;
&lt;h2 id=&quot;二、资源下载&quot;&gt;二、资源下载&lt;/h2&gt;
&lt;p&gt;本章节涉及的源码和资源在工程，&lt;strong&gt;interview-04&lt;/strong&gt;中，包括；&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;10万单词测试数据，在doc文件夹&lt;/li&gt;
&lt;li&gt;扰动函数excel展现，在dock文件夹&lt;/li&gt;
&lt;li&gt;测试源码部分在&lt;code&gt;interview-04&lt;/code&gt;工程中&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;可以通过关注公众号：&lt;a href=&quot;https://bugstack.cn/assets/images/qrcode.png&quot;&gt;&lt;code&gt;bugstack虫洞栈&lt;/code&gt;&lt;/a&gt;，回复下载进行获取{&lt;em&gt;回复下载后打开获得的链接，找到编号ID：19&lt;/em&gt;}&lt;/p&gt;
&lt;h2 id=&quot;三、源码分析&quot;&gt;三、源码分析&lt;/h2&gt;
&lt;h3 id=&quot;1-写一个最简单的hashmap&quot;&gt;1. 写一个最简单的HashMap&lt;/h3&gt;
&lt;p&gt;学习HashMap前，最好的方式是先了解这是一种怎么样的数据结构来存放数据。而HashMap经过多个版本的迭代后，乍一看代码还是很复杂的。就像你原来只穿个裤衩，现在还有秋裤和风衣。所以我们先来看看最根本的HashMap是什么样，也就是只穿裤衩是什么效果，之后再去分析它的源码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;问题：&lt;/strong&gt; 假设我们有一组7个字符串，需要存放到数组中，但要求在获取每个元素的时候时间复杂度是O(1)。也就是说你不能通过循环遍历的方式进行获取，而是要定位到数组ID直接获取相应的元素。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方案：&lt;/strong&gt; 如果说我们需要通过ID从数组中获取元素，那么就需要把每个字符串都计算出一个在数组中的位置ID。&lt;em&gt;字符串获取ID你能想到什么方式？&lt;/em&gt; 一个字符串最直接的获取跟数字相关的信息就是HashCode，可HashCode的取值范围太大了&lt;code&gt;[-2147483648, 2147483647]&lt;/code&gt;，不可能直接使用。那么就需要使用HashCode与数组长度做与运算，得到一个可以在数组中出现的位置。如果说有两个元素得到同样的ID，那么这个数组ID下就存放两个字符串。&lt;/p&gt;
&lt;p&gt;以上呢其实就是我们要把字符串散列到数组中的一个基本思路，接下来我们就把这个思路用代码实现出来。&lt;/p&gt;
&lt;h4 id=&quot;11-代码实现&quot;&gt;1.1 代码实现&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 初始化一组字符串
List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
list.add(&quot;jlkk&quot;);
list.add(&quot;lopi&quot;);
list.add(&quot;小傅哥&quot;);
list.add(&quot;e4we&quot;);
list.add(&quot;alpo&quot;);
list.add(&quot;yhjk&quot;);
list.add(&quot;plop&quot;);

// 定义要存放的数组
String[] tab = new String[8];

// 循环存放
for (String key : list) {
    int idx = key.hashCode() &amp;amp; (tab.length - 1);  // 计算索引位置
    System.out.println(String.format(&quot;key值=%s Idx=%d&quot;, key, idx));
    if (null == tab[idx]) {
        tab[idx] = key;
        continue;
    }
    tab[idx] = tab[idx] + &quot;-&amp;gt;&quot; + key;
}
// 输出测试结果
System.out.println(JSON.toJSONString(tab));
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码整体看起来也是非常简单，并没有什么复杂度，主要包括以下内容；&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;初始化一组字符串集合，这里初始化了7个。&lt;/li&gt;
&lt;li&gt;定义一个数组用于存放字符串，注意这里的长度是8，也就是2的倍数。这样的数组长度才会出现一个 &lt;code&gt;0111&lt;/code&gt; 除高位以外都是1的特征，也是为了散列。&lt;/li&gt;
&lt;li&gt;接下来就是循环存放数据，计算出每个字符串在数组中的位置。&lt;code&gt;key.hashCode() &amp;amp; (tab.length - 1)&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;在字符串存放到数组的过程，如果遇到相同的元素，进行连接操作&lt;code&gt;模拟链表的过程&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;最后输出存放结果。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;测试结果&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;key值=jlkk Idx=2
key值=lopi Idx=4
key值=小傅哥 Idx=7
key值=e4we Idx=5
key值=alpo Idx=2
key值=yhjk Idx=0
key值=plop Idx=5
测试结果：[&quot;yhjk&quot;,null,&quot;jlkk-&amp;gt;alpo&quot;,null,&quot;lopi&quot;,&quot;e4we-&amp;gt;plop&quot;,null,&quot;小傅哥&quot;]
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;在测试结果首先是计算出每个元素在数组的Idx，也有出现重复的位置。&lt;/li&gt;
&lt;li&gt;最后是测试结果的输出，1、3、6，位置是空的，2、5，位置有两个元素被链接起来&lt;code&gt;e4we-&amp;gt;plop&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;这就达到了我们一个最基本的要求，将串元素散列存放到数组中，最后通过字符串元素的索引ID进行获取对应字符串。这样是HashMap的一个最基本原理，有了这个基础后面就会更容易理解HashMap的源码实现。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;12-hash散列示意图&quot;&gt;1.2 Hash散列示意图&lt;/h4&gt;
&lt;p&gt;如果上面的测试结果不能在你的头脑中很好的建立出一个数据结构，那么可以看以下这张散列示意图，方便理解；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9idWdzdGFjay5jbi9hc3NldHMvaW1hZ2VzLzIwMjAvaW50ZXJ2aWV3L2ludGVydmlldy00LTAxLnBuZw?x-oss-process=image/format,png&quot; alt=&quot;bugstack.cn Hash散列示意图&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;这张图就是上面代码实现的全过程，将每一个字符串元素通过Hash计算索引位置，存放到数组中。&lt;/li&gt;
&lt;li&gt;黄色的索引ID是没有元素存放、绿色的索引ID存放了一个元素、红色的索引ID存放了两个元素。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;13-这个简单的hashmap有哪些问题&quot;&gt;1.3 这个简单的HashMap有哪些问题&lt;/h4&gt;
&lt;p&gt;以上我们实现了一个简单的HashMap，或者说还算不上HashMap，只能算做一个散列数据存放的雏形。但这样的一个数据结构放在实际使用中，会有哪些问题呢？&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;这里所有的元素存放都需要获取一个索引位置，而如果元素的位置不够散列碰撞严重，那么就失去了散列表存放的意义，没有达到预期的性能。&lt;/li&gt;
&lt;li&gt;在获取索引ID的计算公式中，需要数组长度是2的倍数，那么怎么进行初始化这个数组大小。&lt;/li&gt;
&lt;li&gt;数组越小碰撞的越大，数组越大碰撞的越小，时间与空间如何取舍。&lt;/li&gt;
&lt;li&gt;目前存放7个元素，已经有两个位置都存放了2个字符串，那么链表越来越长怎么优化。&lt;/li&gt;
&lt;li&gt;随着元素的不断添加，数组长度不足扩容时，怎么把原有的元素，拆分到新的位置上去。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;以上这些问题可以归纳为；&lt;code&gt;扰动函数&lt;/code&gt;、&lt;code&gt;初始化容量&lt;/code&gt;、&lt;code&gt;负载因子&lt;/code&gt;、&lt;code&gt;扩容方法&lt;/code&gt;以及&lt;code&gt;链表和红黑树&lt;/code&gt;转换的使用等。接下来我们会逐个问题进行分析。&lt;/p&gt;
&lt;h3 id=&quot;2-扰动函数&quot;&gt;2. 扰动函数&lt;/h3&gt;
&lt;p&gt;在HashMap存放元素时候有这样一段代码来处理哈希值，这是&lt;code&gt;java 8&lt;/code&gt;的散列值扰动函数，用于优化散列效果；&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &amp;gt;&amp;gt;&amp;gt; 16);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;21-为什么使用扰动函数&quot;&gt;2.1 为什么使用扰动函数&lt;/h4&gt;
&lt;p&gt;理论上来说字符串的&lt;code&gt;hashCode&lt;/code&gt;是一个int类型值，那可以直接作为数组下标了，且不会出现碰撞。但是这个&lt;code&gt;hashCode&lt;/code&gt;的取值范围是[-2147483648, 2147483647]，有将近40亿的长度，谁也不能把数组初始化的这么大，内存也是放不下的。&lt;/p&gt;
&lt;p&gt;我们默认初始化的Map大小是16个长度 &lt;code&gt;DEFAULT_INITIAL_CAPACITY = 1 &amp;lt;&amp;lt; 4&lt;/code&gt;，所以获取的Hash值并不能直接作为下标使用，需要与数组长度进行取模运算得到一个下标值，也就是我们上面做的散列列子。&lt;/p&gt;
&lt;p&gt;那么，hashMap源码这里不只是直接获取哈希值，还进行了一次扰动计算，&lt;code&gt;(h = key.hashCode()) ^ (h &amp;gt;&amp;gt;&amp;gt; 16)&lt;/code&gt;。把哈希值右移16位，也就正好是自己长度的一半，之后与原哈希值做异或运算，这样就混合了原哈希值中的高位和低位，增大了&lt;strong&gt;随机性&lt;/strong&gt;。计算方式如下图；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9idWdzdGFjay5jbi9hc3NldHMvaW1hZ2VzLzIwMjAvaW50ZXJ2aWV3L2ludGVydmlldy00LTAyLnBuZw?x-oss-process=image/format,png&quot; alt=&quot;bugstack.cn 扰动函数&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;说白了，使用扰动函数就是为了增加随机性，让数据元素更加均衡的散列，减少碰撞。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;22-实验验证扰动函数&quot;&gt;2.2 实验验证扰动函数&lt;/h4&gt;
&lt;p&gt;从上面的分析可以看出，扰动函数使用了哈希值的高半区和低半区做异或，混合原始哈希码的高位和低位，以此来加大低位区的随机性。&lt;/p&gt;
&lt;p&gt;但看不到实验数据的话，这终究是一段理论，具体这段哈希值真的被增加了随机性没有，并不知道。所以这里我们要做一个实验，这个实验是这样做；&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;选取10万个单词词库&lt;/li&gt;
&lt;li&gt;定义128位长度的数组格子&lt;/li&gt;
&lt;li&gt;分别计算在扰动和不扰动下，10万单词的下标分配到128个格子的数量&lt;/li&gt;
&lt;li&gt;统计各个格子数量，生成波动曲线。如果扰动函数下的波动曲线相对更平稳，那么证明扰动函数有效果。&lt;/li&gt;
&lt;/ol&gt;&lt;h5 id=&quot;221-扰动代码测试&quot;&gt;2.2.1 扰动代码测试&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;扰动函数对比方法&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Disturb {

    public static int disturbHashIdx(String key, int size) {
        return (size - 1) &amp;amp; (key.hashCode() ^ (key.hashCode() &amp;gt;&amp;gt;&amp;gt; 16));
    }

    public static int hashIdx(String key, int size) {
        return (size - 1) &amp;amp; key.hashCode();
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;disturbHashIdx&lt;/code&gt; 扰动函数下，下标值计算&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hashIdx&lt;/code&gt; 非扰动函数下，下标值计算&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;单元测试&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 10万单词已经初始化到words中
@Test
public void test_disturb() {
    Map&amp;lt;Integer, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;(16);
    for (String word : words) {
        // 使用扰动函数
        int idx = Disturb.disturbHashIdx(word, 128);
        // 不使用扰动函数
        // int idx = Disturb.hashIdx(word, 128);
        if (map.containsKey(idx)) {
            Integer integer = map.get(idx);
            map.put(idx, ++integer);
        } else {
            map.put(idx, 1);
        }
    }
    System.out.println(map.values());
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上分别统计两种函数下的下标值分配，最终将统计结果放到excel中生成图表。&lt;/p&gt;
&lt;h5 id=&quot;222-扰动函数散列图表&quot;&gt;2.2.2 扰动函数散列图表&lt;/h5&gt;
&lt;p&gt;以上的两张图，分别是没有使用扰动函数和使用扰动函数的，下标分配。实验数据；&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;10万个不重复的单词&lt;/li&gt;
&lt;li&gt;128个格子，相当于128长度的数组&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;未使用扰动函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9idWdzdGFjay5jbi9hc3NldHMvaW1hZ2VzLzIwMjAvaW50ZXJ2aWV3L2ludGVydmlldy00LTAzLnBuZw?x-oss-process=image/format,png&quot; alt=&quot;bugstack.cn 未使用扰动函数&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用扰动函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9idWdzdGFjay5jbi9hc3NldHMvaW1hZ2VzLzIwMjAvaW50ZXJ2aWV3L2ludGVydmlldy00LTA0LnBuZw?x-oss-process=image/format,png&quot; alt=&quot;bugstack.cn 使用扰动函数&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;从这两种的对比图可以看出来，在使用了扰动函数后，数据分配的更加均匀了。&lt;/li&gt;
&lt;li&gt;数据分配均匀，也就是散列的效果更好，减少了hash的碰撞，让数据存放和获取的效率更佳。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;3-初始化容量和负载因子&quot;&gt;3. 初始化容量和负载因子&lt;/h3&gt;
&lt;p&gt;接下来我们讨论下一个问题，从我们模仿HashMap的例子中以及HashMap默认的初始化大小里，都可以知道，散列数组需要一个2的倍数的长度，因为只有2的倍数在减1的时候，才会出现&lt;code&gt;01111&lt;/code&gt;这样的值。&lt;/p&gt;
&lt;p&gt;那么这里就有一个问题，我们在初始化HashMap的时候，如果传一个17个的值&lt;code&gt;new HashMap&amp;lt;&amp;gt;(17);&lt;/code&gt;，它会怎么处理呢？&lt;/p&gt;
&lt;h4 id=&quot;31-寻找2的倍数最小值&quot;&gt;3.1 寻找2的倍数最小值&lt;/h4&gt;
&lt;p&gt;在HashMap的初始化中，有这样一段方法；&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public HashMap(int initialCapacity, float loadFactor) {
    ...
    this.loadFactor = loadFactor;
    this.threshold = tableSizeFor(initialCapacity);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;阀值&lt;code&gt;threshold&lt;/code&gt;，通过方法&lt;code&gt;tableSizeFor&lt;/code&gt;进行计算，是根据初始化来计算的。&lt;/li&gt;
&lt;li&gt;这个方法也就是要寻找比初始值大的，最小的那个2进制数值。比如传了17，我应该找到的是32。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;计算阀值大小的方法；&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;static final int tableSizeFor(int cap) {
    int n = cap - 1;
    n |= n &amp;gt;&amp;gt;&amp;gt; 1;
    n |= n &amp;gt;&amp;gt;&amp;gt; 2;
    n |= n &amp;gt;&amp;gt;&amp;gt; 4;
    n |= n &amp;gt;&amp;gt;&amp;gt; 8;
    n |= n &amp;gt;&amp;gt;&amp;gt; 16;
    return (n &amp;lt; 0) ? 1 : (n &amp;gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;MAXIMUM_CAPACITY = 1 &amp;lt;&amp;lt; 30，这个是临界范围，也就是最大的Map集合。&lt;/li&gt;
&lt;li&gt;乍一看可能有点晕😵怎么都在向右移位1、2、4、8、16，这主要是为了把二进制的各个位置都填上1，当二进制的各个位置都是1以后，就是一个标准的2的倍数减1了，最后把结果加1再返回即可。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;那这里我们把17这样一个初始化计算阀值的过程，用图展示出来，方便理解；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9idWdzdGFjay5jbi9hc3NldHMvaW1hZ2VzLzIwMjAvaW50ZXJ2aWV3L2ludGVydmlldy00LTA1LnBuZw?x-oss-process=image/format,png&quot; alt=&quot;bugstack.cn 计算阀值&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;32-负载因子&quot;&gt;3.2 负载因子&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;static final float DEFAULT_LOAD_FACTOR = 0.75f;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;负载因子是做什么的？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;负载因子，可以理解成一辆车可承重重量超过某个阀值时，把货放到新的车上。&lt;/p&gt;
&lt;p&gt;那么在HashMap中，负载因子决定了数据量多少了以后进行扩容。&lt;em&gt;这里要提到上面做的HashMap例子，我们准备了7个元素，但是最后还有3个位置空余，2个位置存放了2个元素。&lt;/em&gt; 所以可能即使你数据比数组容量大时也是不一定能正正好好的把数组占满的，而是在某些小标位置出现了大量的碰撞，只能在同一个位置用链表存放，那么这样就失去了Map数组的性能。&lt;/p&gt;
&lt;p&gt;所以，要选择一个合理的大小下进行扩容，默认值0.75就是说当阀值容量占了3/4s时赶紧扩容，减少Hash碰撞。&lt;/p&gt;
&lt;p&gt;同时0.75是一个默认构造值，在创建HashMap也可以调整，比如你希望用更多的空间换取时间，可以把负载因子调的更小一些，减少碰撞。&lt;/p&gt;
&lt;h3 id=&quot;4--扩容元素拆分&quot;&gt;4. 扩容元素拆分&lt;/h3&gt;
&lt;p&gt;为什么扩容，因为数组长度不足了。那扩容最直接的问题，就是需要把元素拆分到新的数组中。拆分元素的过程中，原jdk1.7中会需要重新计算哈希值，但是到jdk1.8中已经进行优化，不在需要重新计算，提升了拆分的性能，设计的还是非常巧妙的。&lt;/p&gt;
&lt;h4 id=&quot;41-测试数据&quot;&gt;4.1 测试数据&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void test_hashMap() {
    List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
    list.add(&quot;jlkk&quot;);
    list.add(&quot;lopi&quot;);
    list.add(&quot;jmdw&quot;);
    list.add(&quot;e4we&quot;);
    list.add(&quot;io98&quot;);
    list.add(&quot;nmhg&quot;);
    list.add(&quot;vfg6&quot;);
    list.add(&quot;gfrt&quot;);
    list.add(&quot;alpo&quot;);
    list.add(&quot;vfbh&quot;);
    list.add(&quot;bnhj&quot;);
    list.add(&quot;zuio&quot;);
    list.add(&quot;iu8e&quot;);
    list.add(&quot;yhjk&quot;);
    list.add(&quot;plop&quot;);
    list.add(&quot;dd0p&quot;);
    for (String key : list) {
        int hash = key.hashCode() ^ (key.hashCode() &amp;gt;&amp;gt;&amp;gt; 16);
        System.out.println(&quot;字符串：&quot; + key + &quot; \tIdx(16)：&quot; + ((16 - 1) &amp;amp; hash) + &quot; \tBit值：&quot; + Integer.toBinaryString(hash) + &quot; - &quot; + Integer.toBinaryString(hash &amp;amp; 16) + &quot; \t\tIdx(32)：&quot; + ((
        System.out.println(Integer.toBinaryString(key.hashCode()) +&quot; &quot;+ Integer.toBinaryString(hash) + &quot; &quot; + Integer.toBinaryString((32 - 1) &amp;amp; hash));
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;字符串：jlkk       Idx(16)：3       Bit值：1100011101001000010011 - 10000             Idx(32)：19
1100011101001000100010 1100011101001000010011 10011
字符串：lopi        Idx(16)：14      Bit值：1100101100011010001110 - 0                 Idx(32)：14
1100101100011010111100 1100101100011010001110 1110
字符串：jmdw        Idx(16)：7       Bit值：1100011101010100100111 - 0                 Idx(32)：7
1100011101010100010110 1100011101010100100111 111
字符串：e4we        Idx(16)：3       Bit值：1011101011101101010011 - 10000             Idx(32)：19
1011101011101101111101 1011101011101101010011 10011
字符串：io98        Idx(16)：4       Bit值：1100010110001011110100 - 10000             Idx(32)：20
1100010110001011000101 1100010110001011110100 10100
字符串：nmhg        Idx(16)：13      Bit值：1100111010011011001101 - 0                 Idx(32)：13
1100111010011011111110 1100111010011011001101 1101
字符串：vfg6        Idx(16)：8       Bit值：1101110010111101101000 - 0                 Idx(32)：8
1101110010111101011111 1101110010111101101000 1000
字符串：gfrt        Idx(16)：1       Bit值：1100000101111101010001 - 10000             Idx(32)：17
1100000101111101100001 1100000101111101010001 10001
字符串：alpo        Idx(16)：7       Bit值：1011011011101101000111 - 0                 Idx(32)：7
1011011011101101101010 1011011011101101000111 111
字符串：vfbh        Idx(16)：1       Bit值：1101110010111011000001 - 0                 Idx(32)：1
1101110010111011110110 1101110010111011000001 1
字符串：bnhj        Idx(16)：0       Bit值：1011100011011001100000 - 0                 Idx(32)：0
1011100011011001001110 1011100011011001100000 0
字符串：zuio        Idx(16)：8       Bit值：1110010011100110011000 - 10000             Idx(32)：24
1110010011100110100001 1110010011100110011000 11000
字符串：iu8e        Idx(16)：8       Bit值：1100010111100101101000 - 0                 Idx(32)：8
1100010111100101011001 1100010111100101101000 1000
字符串：yhjk        Idx(16)：8       Bit值：1110001001010010101000 - 0                 Idx(32)：8
1110001001010010010000 1110001001010010101000 1000
字符串：plop        Idx(16)：9       Bit值：1101001000110011101001 - 0                 Idx(32)：9
1101001000110011011101 1101001000110011101001 1001
字符串：dd0p        Idx(16)：14      Bit值：1011101111001011101110 - 0                 Idx(32)：14
1011101111001011000000 1011101111001011101110 1110
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;这里我们随机使用一些字符串计算他们分别在16位长度和32位长度数组下的索引分配情况，看哪些数据被重新路由到了新的地址。&lt;/li&gt;
&lt;li&gt;同时，这里还可以观察🕵出一个非常重要的信息，原哈希值与扩容新增出来的长度16，进行&amp;amp;运算，如果值等于0，则下标位置不变。如果不为0，那么新的位置则是原来位置上加16。｛这个地方需要好好理解下，并看实验数据｝&lt;/li&gt;
&lt;li&gt;这样一来，就不需要在重新计算每一个数组中元素的哈希值了。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;42-数据迁移&quot;&gt;4.2 数据迁移&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9idWdzdGFjay5jbi9hc3NldHMvaW1hZ2VzLzIwMjAvaW50ZXJ2aWV3L2ludGVydmlldy00LTA2LnBuZw?x-oss-process=image/format,png&quot; alt=&quot;bugstack.cn 数据迁移&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;这张图就是原16位长度数组元素，像32位数组长度中转移的过程。&lt;/li&gt;
&lt;li&gt;其中黄色区域元素&lt;code&gt;zuio&lt;/code&gt;因计算结果 &lt;code&gt;hash &amp;amp; oldCap&lt;/code&gt; 不为1，则被迁移到下标位置24。&lt;/li&gt;
&lt;li&gt;同时还是用重新计算哈希值的方式验证了，确实分配到24的位置，因为这是在二进制计算中补1的过程，所以可以通过上面简化的方式确定哈希值的位置。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;四、总结&quot;&gt;四、总结&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;如果你能坚持看完这部分内容，并按照文中的例子进行相应的实验验证，那么一定可以学会本章节涉及这五项知识点；&lt;code&gt;1、散列表实现&lt;/code&gt;、&lt;code&gt;2、扰动函数&lt;/code&gt;、&lt;code&gt;3、初始化容量&lt;/code&gt;、&lt;code&gt;4、负载因子&lt;/code&gt;、&lt;code&gt;5、扩容元素拆分&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;对我个人来说以前也知道这部分知识，但是没有验证过，只知道概念如此，正好借着写面试手册专栏，加深学习，用数据验证理论，让知识点可以更加深入的理解。&lt;/li&gt;
&lt;li&gt;这一章节完事，下一章节继续进行HashMap的其他知识点挖掘，让懂了就是真的懂了。好了，写到这里了，感谢大家的阅读。如果某处没有描述清楚，或者有不理解的点，欢迎与我讨论交流。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;五、推荐阅读&quot;&gt;五、推荐阅读&lt;/h2&gt;
</description>
<pubDate>Sun, 09 Aug 2020 23:45:00 +0000</pubDate>
<dc:creator>小傅哥</dc:creator>
<og:description>作者：小傅哥 博客：https://bugstack.cn 沉淀、分享、成长，让自己和他人都能有所收获！&amp;amp;#128516; 一、前言 得益于Doug Lea老爷子的操刀，让HashMap成为使</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiaofuge/p/13467534.html</dc:identifier>
</item>
<item>
<title>你真的理解索引吗？从数据结构层面解析mysql索引原理 - 六点半起床</title>
<link>http://www.cnblogs.com/chentianming/p/13467529.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chentianming/p/13467529.html</guid>
<description>&lt;p&gt;从《&lt;a href=&quot;https://juejin.im/post/6844904190477598733&quot;&gt;mysql存储引擎InnoDB详解，从底层看清InnoDB数据结构&lt;/a&gt;》中，我们已经知道了&lt;strong&gt;数据页内各个记录是按主键正序排列并组成了一个单向链表的，并且各个数据页之间形成了双向链表&lt;/strong&gt;。在数据页内，通过&lt;code&gt;页目录&lt;/code&gt;，根据主键可以快速定位到一条记录。这一章中，我们深入理解一下mysql索引实现。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;本文主要内容是根据掘金小册《从根儿上理解 MySQL》整理而来。如想详细了解，建议购买掘金小册阅读。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;索引数据结构&quot;&gt;索引数据结构&lt;/h2&gt;
&lt;p&gt;先回顾一下上一章节中&lt;code&gt;数据页基本结构&lt;/code&gt;：&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jaGVudGlhbm1pbmcxMS5naXRodWIuaW8vaW1hZ2VzL215c3FsLyVFNiU5NSVCMCVFNiU4RCVBRSVFOSVBMSVCNSVFNSU5RiVCQSVFNiU5QyVBQyVFNyVCQiU5MyVFNiU5RSU4NC53ZWJw?x-oss-process=image/format,png&quot; alt=&quot;数据页基本结构&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;从上图可以推断出，查询某条记录关键步骤只有2个：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;定位到数据页&lt;/li&gt;
&lt;li&gt;定位到记录&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如果没有索引，查询某条记录只能先依次遍历数据页，确定记录所在的数据页之后；再从数据页中通过&lt;code&gt;页目录&lt;/code&gt;定位到具体的记录，这样做效率肯定是很低的。&lt;/p&gt;
&lt;p&gt;为了方便说明，先建一张示例表：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;mysql&amp;gt; CREATE TABLE index_demo(
    -&amp;gt;     c1 INT,
    -&amp;gt;     c2 INT,
    -&amp;gt;     c3 CHAR(1),
    -&amp;gt;     PRIMARY KEY(c1)
    -&amp;gt; ) ROW_FORMAT = Compact;
Query OK, 0 rows affected (0.03 sec)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了展示便方便，行格式中只展示&lt;code&gt;record_type&lt;/code&gt;、&lt;code&gt;next_record&lt;/code&gt;和&lt;code&gt;实际各列的值&lt;/code&gt;。&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jaGVudGlhbm1pbmcxMS5naXRodWIuaW8vaW1hZ2VzL215c3FsLyVFOCVBMSU4QyVFNiVBMCVCQyVFNSVCQyU4RiVFNyVBRSU4MCVFNSU4QyU5Ni53ZWJw?x-oss-process=image/format,png&quot; alt=&quot;行格式简化&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;把一些记录放到页里边的示意图就是：&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jaGVudGlhbm1pbmcxMS5naXRodWIuaW8vaW1hZ2VzL215c3FsLyVFOCVBRSVCMCVFNSVCRCU5NSVFNiU5NCVCRSVFNSU4OCVCMCVFOSVBMSVCNSVFOSU4NyU4QyVFOCVCRSVCOSVFNyU5QSU4NCVFNyVBNCVCQSVFNiU4NCU4RiVFNSU5QiVCRS53ZWJw?x-oss-process=image/format,png&quot; alt=&quot;记录放到页里边的示意图&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面提到过，&lt;strong&gt;数据页中的记录是按主键正序排列的&lt;/strong&gt;。实际上就是为了能够使用&lt;strong&gt;二分查找法&lt;/strong&gt;快速定位一条记录。同理，要想快速定位一个数据页，也得保证各个数据页是按顺序排序的。排序的规则就是&lt;strong&gt;后一个数据页的最小主键必须大于当前数据页的最大主键&lt;/strong&gt;。这样实际上就保证了，所有记录的主键都是正序排列的了。&lt;/p&gt;
&lt;h3 id=&quot;页分裂&quot;&gt;页分裂&lt;/h3&gt;
&lt;p&gt;假设每个数据页最多只能存放3条记录。现在&lt;code&gt;index_demo&lt;/code&gt;插入了3条记录 &lt;code&gt;(1, 4, 'u'), (3, 9, 'd'), (5, 3, 'y')&lt;/code&gt;。&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jaGVudGlhbm1pbmcxMS5naXRodWIuaW8vaW1hZ2VzL215c3FsLyVFNSVBRCU5OCVFNiVCQiVBMSVFOCVBRSVCMCVFNSVCRCU5NSVFNyU5QSU4NCVFNiU5NSVCMCVFNiU4RCVBRSVFOSVBMSVCNS53ZWJw?x-oss-process=image/format,png&quot; alt=&quot;存满记录的数据页&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;然后，再向&lt;code&gt;index_demo&lt;/code&gt;插入一条记录&lt;code&gt;(4, 4, 'a')&lt;/code&gt;。由于每个数据页最多只能存放3条记录，并且还要保证所有记录主键是按主键正序排列的。mysql会新建一个页面(假设是页28)，然后将主键值为5的记录移动到页28中，最后再把主键值为4的记录插入到页10中。&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jaGVudGlhbm1pbmcxMS5naXRodWIuaW8vaW1hZ2VzL215c3FsLyVFOSVBMSVCNSVFNSU4OCU4NiVFOCVBMyU4Mi53ZWJw?x-oss-process=image/format,png&quot; alt=&quot;页分裂&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;简单来说，&lt;strong&gt;当向一个已经存满记录的数据页插入新记录时，mysql会以新插入记录的位置为界，把当前页面分裂为2个页面，最后再将新记录插入进去&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;mysql索引实现&quot;&gt;mysql索引实现&lt;/h3&gt;
&lt;p&gt;假设&lt;code&gt;index_demo&lt;/code&gt;已经存在多条记录，数据页结构如下所示：&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jaGVudGlhbm1pbmcxMS5naXRodWIuaW8vaW1hZ2VzL215c3FsLyVFNyVCNCVBMiVFNSVCQyU5NSVFNSVBRSU5RSVFNyU4RSVCMDEud2VicA?x-oss-process=image/format,png&quot; alt=&quot;索引实现&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;为了能够使用&lt;code&gt;二分法&lt;/code&gt;快速查找数据页，我们可以给每个数据页建一个目录项，每个目录项主要包含两部分数据：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;页的用户记录中最小的主键值，我们用&lt;code&gt;key&lt;/code&gt;来表示。&lt;/li&gt;
&lt;li&gt;页号，我们用&lt;code&gt;page_no&lt;/code&gt;表示。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jaGVudGlhbm1pbmcxMS5naXRodWIuaW8vaW1hZ2VzL215c3FsLyVFNyVCNCVBMiVFNSVCQyU5NSVFNSVBRSU5RSVFNyU4RSVCMDIud2VicA?x-oss-process=image/format,png&quot; alt=&quot;索引实现&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;在mysql中，这些目录项其实就是另一类型的数据记录，称为&lt;code&gt;目录项数据记录&lt;/code&gt;（record_type=1）,&lt;code&gt;目录项数据记录&lt;/code&gt;也是存储在&lt;code&gt;页&lt;/code&gt;中的，同一页中的&lt;code&gt;目录项数据记录&lt;/code&gt;也可以通过&lt;code&gt;页目录&lt;/code&gt;快速定位。&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jaGVudGlhbm1pbmcxMS5naXRodWIuaW8vaW1hZ2VzL215c3FsLyVFNyVCNCVBMiVFNSVCQyU5NSVFNSVBRSU5RSVFNyU4RSVCMDMud2VicA?x-oss-process=image/format,png&quot; alt=&quot;索引实现&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;虽然&lt;code&gt;目录项记录&lt;/code&gt;基本&lt;strong&gt;只存储了主键值和页号&lt;/strong&gt;。但是当表中的数据很多时，一个&lt;code&gt;数据页&lt;/code&gt;肯定是无法保存所有的&lt;code&gt;目录项记录&lt;/code&gt;的。因此存储&lt;code&gt;目录项记录&lt;/code&gt;的&lt;code&gt;数据页&lt;/code&gt;实际上可能有很多个。&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jaGVudGlhbm1pbmcxMS5naXRodWIuaW8vaW1hZ2VzL215c3FsLyVFNyVCNCVBMiVFNSVCQyU5NSVFNSVBRSU5RSVFNyU4RSVCMDQud2VicA?x-oss-process=image/format,png&quot; alt=&quot;索引实现&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;这个时候，我们就需要快速定位存储&lt;code&gt;目录项记录&lt;/code&gt;的&lt;code&gt;数据页&lt;/code&gt;了。实际上，我们只需要生成&lt;strong&gt;更高级的目录即可，同时保证最高一级的&lt;code&gt;目录项记录&lt;/code&gt;的&lt;code&gt;数据页&lt;/code&gt;只有一个&lt;/strong&gt;。这样就能根据主键从上到下快速定位到一条记录了。&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jaGVudGlhbm1pbmcxMS5naXRodWIuaW8vaW1hZ2VzL215c3FsLyVFNyVCNCVBMiVFNSVCQyU5NSVFNSVBRSU5RSVFNyU4RSVCMDUud2VicA?x-oss-process=image/format,png&quot; alt=&quot;索引实现&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;实际上，上面的结构就是一颗B+树。&lt;strong&gt;实际的用户记录其实都存放在B+树的&lt;code&gt;叶子节点&lt;/code&gt;上，而&lt;code&gt;非叶子节点&lt;/code&gt;存放的是目录项&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&quot;聚簇索引&quot;&gt;聚簇索引&lt;/h4&gt;
&lt;p&gt;上面介绍的索引实际上就是聚簇索引，它有两个特点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;使用主键值的大小进行记录和页的排序，这包括三个方面的含义：
&lt;ol&gt;&lt;li&gt;页内的记录是按照主键的大小顺序排成一个单向链表。&lt;/li&gt;
&lt;li&gt;各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个双向链表。&lt;/li&gt;
&lt;li&gt;存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个双向链表。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;B+树的叶子节点存储的是完整的用户记录。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;InnoDB存储引擎会自动根据主键创建聚簇索引。同时，聚簇索引就是InnoDB存储引擎中数据的存储方式（所有的用户记录都存储在了叶子节点），也就是所谓的&lt;strong&gt;索引即数据，数据即索引&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&quot;二级索引&quot;&gt;二级索引&lt;/h4&gt;
&lt;p&gt;在实际场景中，我们更多的是为某个列建立二级索引。实际上，二级索引和聚簇索引实现的原理一样的。主要的区别只有2个：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;使用&lt;code&gt;索引列的值&lt;/code&gt;的大小进行记录和页的排序。&lt;/li&gt;
&lt;li&gt;B+树的叶子节点存储的是对应记录的主键值。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如图是以&lt;code&gt;c2&lt;/code&gt;列建立的二级索引：&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jaGVudGlhbm1pbmcxMS5naXRodWIuaW8vaW1hZ2VzL215c3FsLyVFNCVCQSU4QyVFNyVCQSVBNyVFNyVCNCVBMiVFNSVCQyU5NS53ZWJw?x-oss-process=image/format,png&quot; alt=&quot;二级索引&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于B+树的叶子节点存储的是对应记录的主键值。如果我们要查询完成记录的话，在拿到主键之后，再需要再到&lt;code&gt;聚簇索引&lt;/code&gt;中查出用户记录，这个过程也叫&lt;code&gt;回表&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&quot;联合索引&quot;&gt;联合索引&lt;/h4&gt;
&lt;p&gt;在实际场景中，经常也出现为多个列建立一个索引的情况，这种索引也称为&lt;code&gt;联合索引&lt;/code&gt;。&lt;code&gt;联合索引&lt;/code&gt;本质上也是二级索引，区别仅仅在于由一个列变为多个列而已。简单来说就是&lt;strong&gt;同时以多个列的大小作为排序规则，也就是同时为多个列建立索引&lt;/strong&gt;。比如我们为&lt;code&gt;c2&lt;/code&gt;和&lt;code&gt;c3&lt;/code&gt;列建立联合索引：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;先把各个记录和页按照c2列进行排序。&lt;/li&gt;
&lt;li&gt;在记录的c2列相同的情况下，采用c3列进行排序。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jaGVudGlhbm1pbmcxMS5naXRodWIuaW8vaW1hZ2VzL215c3FsLyVFOCU4MSU5NCVFNSU5MCU4OCVFNyVCNCVBMiVFNSVCQyU5NS53ZWJw?x-oss-process=image/format,png&quot; alt=&quot;联合索引&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;innodb的b树索引的注意事项&quot;&gt;InnoDB的B+树索引的注意事项&lt;/h2&gt;
&lt;h3 id=&quot;根节点不变性&quot;&gt;根节点不变性&lt;/h3&gt;
&lt;p&gt;上面介绍B+树的时候，为了理解方便，采用自下而上的方式介绍。实际上，B+树的形成过程如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;每次为某个表创建&lt;code&gt;B+&lt;/code&gt;索引的时候，都会为这个索引创建一个根节点页面。当表中没有记录时，每个B+根节点既没有用户记录，也没有目录项记录。&lt;/li&gt;
&lt;li&gt;随后向表中插入用户记录时，先把用户记录存储到根节点中。&lt;/li&gt;
&lt;li&gt;当根节点空间用完后，再次插入数据。会将根节点数据复制到一个新页中，再对这个新页进行&lt;code&gt;页分裂&lt;/code&gt;操作。此时，根节点自动升级为存储目录项记录的页。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;可以看出，&lt;strong&gt;一个B+树索引的根节点自诞生之日起，便不会再移动&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;内节点中目录项记录的唯一性&quot;&gt;内节点中目录项记录的唯一性&lt;/h3&gt;
&lt;p&gt;我们知道B+树索引的内节点中目录项记录的内容是索引列+页号的搭配，但是这个搭配对于二级索引来说有点儿不严谨。为了保证内节点目录项记录的唯一性，目录项还需要存储主键值数据。也就是说，目录项记录的内容包含&lt;code&gt;索引列的值&lt;/code&gt;、&lt;code&gt;主键值&lt;/code&gt;和&lt;code&gt;页号&lt;/code&gt;。&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jaGVudGlhbm1pbmcxMS5naXRodWIuaW8vaW1hZ2VzL215c3FsLyVFNSU4NiU4NSVFOCU4QSU4MiVFNyU4MiVCOSVFNCVCOCVBRCVFNyU5QiVBRSVFNSVCRCU5NSVFOSVBMSVCOSVFOCVBRSVCMCVFNSVCRCU5NSVFNyU5QSU4NCVFNSU5NCVBRiVFNCVCOCU4MCVFNiU4MCVBNy53ZWJw?x-oss-process=image/format,png&quot; alt=&quot;内节点中目录项记录的唯一性&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;myisam中的索引方案简单介绍&quot;&gt;MyISAM中的索引方案简单介绍&lt;/h2&gt;
&lt;p&gt;我们知道&lt;strong&gt;InnoDB中索引即数据，也就是聚簇索引的那棵B+树的叶子节点中已经把所有完整的用户记录都包含了&lt;/strong&gt;，而MyISAM的索引方案虽然也使用树形结构，但是却将&lt;strong&gt;索引和数据分开存储&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;MyISAM存储引擎&lt;/code&gt;把记录按照记录的插入顺序单独存储在&lt;code&gt;数据文件&lt;/code&gt;中。这个文件并不划分为若干个数据页，有多少记录就往这个文件中塞多少记录就成了。我们可以通过行号而快速访问到一条记录。&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jaGVudGlhbm1pbmcxMS5naXRodWIuaW8vaW1hZ2VzL215c3FsL015SVNBTSVFNiU5NSVCMCVFNiU4RCVBRSVFNiU5NiU4NyVFNCVCQiVCNi53ZWJw?x-oss-process=image/format,png&quot; alt=&quot;MyISAM数据文件&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MyISAM存储引擎&lt;/code&gt;会把索引信息另外存储到&lt;code&gt;索引文件&lt;/code&gt;中。&lt;code&gt;MyISAM&lt;/code&gt;会单独为表的主键创建一个索引，只不过在&lt;strong&gt;索引的叶子节点中存储的不是完整的用户记录，而是主键值+行号的组合&lt;/strong&gt;。也就是先通过索引找到对应的行号，再通过行号去找对应的记录！&lt;br/&gt;这一点和&lt;code&gt;InnoDB&lt;/code&gt;是完全不相同的，在InnoDB存储引擎中，我们只需要根据主键值对聚簇索引进行一次查找就能找到对应的记录。而在MyISAM中却需要进行一次回表操作，意味着&lt;strong&gt;MyISAM中建立的索引相当于全部都是二级索引&lt;/strong&gt;！&lt;/li&gt;
&lt;li&gt;如果有需要的话，我们也可以对其它的列分别建立索引或者建立联合索引，原理和InnoDB中的索引差不多，不过在叶子节点处存储的是相应的列+行号。这些索引也全部都是二级索引。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;索引的使用&quot;&gt;索引的使用&lt;/h2&gt;
&lt;p&gt;上面介绍了B+索引的原理，接下来介绍如何更好的使用索引。大家都知道索引不是建的越多越好，因为创建索引在空间上和时间上都会付出代价。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;空间上的代价&lt;br/&gt;每创建一个索引，本质上就是要建立一个B+树，创建索引肯定会占用一部分存储空间。&lt;/li&gt;
&lt;li&gt;时间上的代价&lt;br/&gt;每次对表中的数据进行增删改操作时，都需要去修改各个B+树索引，而B+树索引的记录又是按照&lt;code&gt;索引列的值&lt;/code&gt;排序的。每次增删改操作时，不可避免的会破坏原有记录的顺序，所以存储引擎需要额外的时间来进行记录移位、页面分裂等操作来维护记录的顺序。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;简单来说，&lt;strong&gt;一张表的索引越多，占用的存储空间也会越多，增删改的性能会更差&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;b树索引适用的条件&quot;&gt;B+树索引适用的条件&lt;/h3&gt;
&lt;p&gt;首先创建一张示例表&lt;code&gt;person_info&lt;/code&gt;，用来存储人的一些基本信息。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;CREATE TABLE person_info(
    id INT NOT NULL auto_increment,
    name VARCHAR(100) NOT NULL,
    birthday DATE NOT NULL,
    phone_number CHAR(11) NOT NULL,
    country varchar(100) NOT NULL,
    PRIMARY KEY (id),
    KEY idx_name_birthday_phone_number (name, birthday, phone_number)
);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;简要说明一下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;id&lt;/code&gt;列为主键，自动递增。InnoDB会自动为id列建立聚簇索引。&lt;/li&gt;
&lt;li&gt;为&lt;code&gt;name&lt;/code&gt;, &lt;code&gt;birthday&lt;/code&gt;, &lt;code&gt;phone_number&lt;/code&gt;建立了一个联合索引。所以这个二级索引的叶子节点包含了&lt;code&gt;name&lt;/code&gt;, &lt;code&gt;birthday&lt;/code&gt;, &lt;code&gt;phone_number&lt;/code&gt;和&lt;code&gt;id&lt;/code&gt;列的值。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;下面，简要画一下&lt;code&gt;idx_name_birthday_phone_number&lt;/code&gt;联合索引的示意图。&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jaGVudGlhbm1pbmcxMS5naXRodWIuaW8vaW1hZ2VzL215c3FsLyVFOCU4MSU5NCVFNSU5MCU4OCVFNyVCNCVBMiVFNSVCQyU5NSVFNyU5QSU4NCVFNyVBNCVCQSVFNiU4NCU4RiVFNSU5QiVCRS53ZWJw?x-oss-process=image/format,png&quot; alt=&quot;联合索引的示意图&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;从图中可以看出，这个&lt;code&gt;idx_name_birthday_phone_number&lt;/code&gt;索引对应的B+树中页面和记录的排序方式就是这样的：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;先按照&lt;code&gt;name&lt;/code&gt;列的值进行排序。&lt;/li&gt;
&lt;li&gt;如果&lt;code&gt;name&lt;/code&gt;列的值相同，则按照&lt;code&gt;birthday&lt;/code&gt;列的值进行排序。&lt;/li&gt;
&lt;li&gt;如果&lt;code&gt;birthday&lt;/code&gt;列的值也相同，则按照&lt;code&gt;phone_number&lt;/code&gt;的值进行排序。&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;全值匹配&quot;&gt;全值匹配&lt;/h4&gt;
&lt;p&gt;全值匹配指的是&lt;strong&gt;搜索条件中的列和索引列一致&lt;/strong&gt;。比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;SELECT * FROM person_info WHERE name = 'Ashburn' AND birthday = '1990-09-27' AND phone_number = '15123983239';
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在&lt;code&gt;idx_name_birthday_phone_number&lt;/code&gt;联合索引上进行全值匹配的查询过程如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;因为B+树的数据页和记录先是按照&lt;code&gt;name&lt;/code&gt;列的值进行排序的，所以先可以很快定位name列的值是&lt;code&gt;Ashburn&lt;/code&gt;的记录位置。&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;name&lt;/code&gt;列相同的记录里又是按照&lt;code&gt;birthday&lt;/code&gt;列的值进行排序的，所以在&lt;code&gt;name&lt;/code&gt;列的值是&lt;code&gt;Ashburn&lt;/code&gt;的记录里又可以快速定位&lt;code&gt;birthday&lt;/code&gt;列的值是'1990-09-27'的记录。&lt;/li&gt;
&lt;li&gt;如果&lt;code&gt;name&lt;/code&gt;和&lt;code&gt;birthday&lt;/code&gt;列的值都是相同的，那记录是按照phone_number列的值排序的，&lt;strong&gt;所以联合索引中的三个列都可能被用到&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;联合索引最左匹配&quot;&gt;联合索引最左匹配&lt;/h4&gt;
&lt;p&gt;其实在搜索语句中不用包含全部联合索引的列，只包含左边的列也能够使用索引，这就是联合索引的&lt;strong&gt;最左匹配原则&lt;/strong&gt;。比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;SELECT * FROM person_info WHERE name = 'Ashburn' AND birthday = '1990-09-27';
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;如果我们想使用联合索引中尽可能多的列，搜索条件中的各个列必须是联合索引中从最左边连续的列&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&quot;前缀匹配&quot;&gt;前缀匹配&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;对于字符串类型的索引列来说，我们只匹配它的前缀也是可以快速定位记录的&lt;/strong&gt;。因为字符串比较本质上按一个一个字符比较得出的，也就是说这些字符串的前n个字符，也就是前缀都是排好序的。比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;SELECT * FROM person_info WHERE name LIKE 'As%';
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是如果只给出后缀或者中间的某个字符串，是无法使用索引的，比如这样：&lt;code&gt;%As&lt;/code&gt;或者&lt;code&gt;%As%&lt;/code&gt;。如果实际场景中碰到要以字符串后缀查询数据的话，可以考虑&lt;code&gt;逆序存储&lt;/code&gt;，将后缀匹配转化为前缀匹配。&lt;/p&gt;
&lt;h4 id=&quot;范围匹配&quot;&gt;范围匹配&lt;/h4&gt;
&lt;p&gt;因为索引B+树是按照索引列大小排序的，因此按索引列范围查询可以快速查询出数据记录。比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;SELECT * FROM person_info WHERE name &amp;gt; 'Asa' AND name &amp;lt; 'Barlow';
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于B+树中的数据页和记录是先按&lt;code&gt;name&lt;/code&gt;列排序的，所以我们上边的查询过程其实是这样的：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;找到name值为&lt;code&gt;Asa&lt;/code&gt;的记录。&lt;/li&gt;
&lt;li&gt;找到name值为&lt;code&gt;Barlow&lt;/code&gt;的记录。&lt;/li&gt;
&lt;li&gt;由于叶子节点记录本身是一个链表，直接取出范围之内的记录。&lt;/li&gt;
&lt;li&gt;回表查询完整记录。&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;精确匹配某一列并范围匹配另外一列&quot;&gt;精确匹配某一列并范围匹配另外一列&lt;/h4&gt;
&lt;p&gt;对于同一个联合索引来说，虽然对多个列都进行范围查找时只能用到最左边那个索引列，但是如果左边的列是精确查找，则右边的列可以进行范围查找，这种场景下依然会使用索引。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;SELECT * FROM person_info WHERE name = 'Ashburn' AND birthday &amp;gt; '1980-01-01' AND birthday &amp;lt; '2000-12-31' AND phone_number &amp;gt; '15100000000';
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;整个查询过程大致如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;name = 'Ashburn'&lt;/code&gt;，对&lt;code&gt;name&lt;/code&gt;列进行精确查找，当然可以使用B+树索引了。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;birthday &amp;gt; '1980-01-01' AND birthday &amp;lt; '2000-12-31'&lt;/code&gt;，由于&lt;code&gt;name&lt;/code&gt;列是精确查找，所以通过&lt;code&gt;name = 'Ashburn'&lt;/code&gt;条件查找后得到的结果的name值都是相同的，它们会再按照&lt;code&gt;birthday&lt;/code&gt;的值进行排序。所以此时对&lt;code&gt;birthday&lt;/code&gt;列进行范围查找是可以用到B+树索引的。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;phone_number &amp;gt; '15100000000'&lt;/code&gt;，通过&lt;code&gt;birthday&lt;/code&gt;的范围查找的记录的&lt;code&gt;birthday&lt;/code&gt;的值可能不同，所以这个条件无法再利用B+树索引了，只能遍历上一步查询得到的记录。&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;用于排序&quot;&gt;用于排序&lt;/h4&gt;
&lt;p&gt;在实际业务场景中，经常需要对查询出来的结果进行排序。一般情况下，只能将记录全部加载到内存中（结果集太大可能使用磁盘存放中间结果），再使用排序算法排序。这种&lt;strong&gt;在内存中或者磁盘上的排序方式统称为文件排序&lt;code&gt;filesort&lt;/code&gt;，性能较差&lt;/strong&gt;。但是如果&lt;code&gt;order by&lt;/code&gt;子句使用到了索引列，就可能避免&lt;code&gt;filesort&lt;/code&gt;。比如下面这个查询语句：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;SELECT * FROM person_info ORDER BY name, birthday, phone_number LIMIT 10;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个查询结果依次按&lt;code&gt;name&lt;/code&gt;、&lt;code&gt;birthday&lt;/code&gt;和&lt;code&gt;phone_number&lt;/code&gt;排序，而&lt;code&gt;idx_name_birthday_phone_number&lt;/code&gt;B+索引树也刚好是按上述规则排好序的，因此只需要直接从索引中提取数据，然后回表即可。&lt;br/&gt;需要注意的是，对于联合索引来说，&lt;code&gt;ORDER BY&lt;/code&gt;的子句后边的列的顺序也必须跟索引列的顺序一致，否则排序的时候就无法使用索引了。&lt;/p&gt;
&lt;h4 id=&quot;用于分组&quot;&gt;用于分组&lt;/h4&gt;
&lt;p&gt;有时候我们为了方便统计表中的一些信息，会把表中的记录按照某些列进行分组。比如下边这个分组查询：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;SELECT name, birthday, phone_number, COUNT(*) FROM person_info GROUP BY name, birthday, phone_number
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;和使用B+树索引进行排序是一个道理，分组列的顺序也需要和索引列的顺序一致，也可以只使用索引列中左边的列进行分组。&lt;/p&gt;
&lt;h4 id=&quot;覆盖索引&quot;&gt;覆盖索引&lt;/h4&gt;
&lt;p&gt;上面提到到，所谓回表就是在二级索引中获取到主键id集合之后，再分别到聚簇索引查询出完整记录，简单来说就是&lt;strong&gt;一次二级索引查询，多次聚簇索引回表&lt;/strong&gt;。这意味着&lt;strong&gt;二级索引命中的主键记录越多，需要回表的记录也会也多，整体的性能就会越低&lt;/strong&gt;。因此某些查询，宁可使用全表扫描也不使用二级索引。&lt;br/&gt;为了更好的使用&lt;code&gt;二级索引+回表&lt;/code&gt;的方式进行查询，一般推荐使用&lt;code&gt;limit&lt;/code&gt;限制要查询的记录，这样&lt;code&gt;回表&lt;/code&gt;的次数也能得到控制。&lt;/p&gt;
&lt;p&gt;为了彻底告别回表操作带来的性能损耗，建议：&lt;strong&gt;在查询列表里只包含索引列&lt;/strong&gt;，比如这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;SELECT name, birthday, phone_number FROM person_info WHERE name &amp;gt; 'Asa' AND name &amp;lt; 'Barlow'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为只查询&lt;code&gt;name&lt;/code&gt;, &lt;code&gt;birthday&lt;/code&gt;, &lt;code&gt;phone_number&lt;/code&gt;这三个索引列的值，所以就没必要进行回表操作了。我们把这种&lt;strong&gt;只需要用到索引的查询方式称为覆盖索引&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;如何挑选索引&quot;&gt;如何挑选索引&lt;/h3&gt;
&lt;p&gt;上面主要介绍了索引的适用场景，接下来我们介绍下建立索引时或者编写查询语句时就应该注意的一些事项。&lt;/p&gt;
&lt;h4 id=&quot;只为用于搜索、排序或分组的列创建索引&quot;&gt;只为用于搜索、排序或分组的列创建索引&lt;/h4&gt;
&lt;p&gt;只为出现在&lt;code&gt;WHERE&lt;/code&gt;子句中的列、连接子句中的连接列，或者出现在ORDER BY或GROUP BY子句中的列创建索引。而出现在查询列表中的列就没必要建立索引了。&lt;/p&gt;
&lt;h4 id=&quot;考虑列的基数&quot;&gt;考虑列的基数&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;列的基数&lt;/code&gt;指的是某一列中不重复数据的个数。，在记录行数一定的情况下，&lt;strong&gt;列的基数越大，该列中的值越分散，列的基数越小，该列中的值越集中&lt;/strong&gt;。因此推荐的方式是&lt;strong&gt;为那些列的基数大的列建立索引&lt;/strong&gt;，为基数太小列的建立索引效果可能不好。&lt;/p&gt;
&lt;h4 id=&quot;索引列的类型尽量小&quot;&gt;索引列的类型尽量小&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;在表示的整数范围允许的情况下，尽量让索引列使用较小的类型&lt;/strong&gt;。原因如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;数据类型越小，在查询时进行的比较操作越快&lt;/li&gt;
&lt;li&gt;数据类型越小，索引占用的存储空间就越少，在一个数据页内就可以放下更多的记录，从而减少磁盘I/O带来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率。&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;使用前缀索引&quot;&gt;使用前缀索引&lt;/h4&gt;
&lt;p&gt;当字段值比较长的时候，建立索引会消耗很多的空间，搜索起来也会很慢。我们可以通过&lt;strong&gt;截取字段的前面一部分内容建立索引&lt;/strong&gt;，这个就叫前缀索引。&lt;br/&gt;例如：创建一张商户表，因为地址字段比较长，在地址字段上建立前缀索引:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;create table shop(address varchar(120) not null);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;问题是，截取多少呢?截取得多了，达不到节省索引存储空间的目的，截取得少了， 重复内容太多，字段的基数会降低。实际场景中，可以通过不同长度的基数与总记录数据基数的比值，选择一个较为合理的截取长度。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;select count(distinct left(address,10))/count(*) as sub10,
count(distinct left(address,11))/count(*) as sub11,
count(distinct left(address,12))/count(*) as sub12,
count(distinct left(address,13))/count(*) as sub13
from shop;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;避免索引列字段参与计算&quot;&gt;避免索引列字段参与计算&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;如果索引列在比较表达式中不是以单独列的形式出现，而是以某个表达式，或者函数调用形式出现的话，是用不到索引的&lt;/strong&gt;。&lt;br/&gt;比如有一个整数列&lt;code&gt;my_col&lt;/code&gt;，&lt;code&gt;WHERE my_col * 2 &amp;lt; 4&lt;/code&gt;查询是不会使用索引的，而&lt;code&gt;WHERE my_col &amp;lt; 4/2&lt;/code&gt;能正常使用索引。&lt;/p&gt;
&lt;h4 id=&quot;主键插入顺序&quot;&gt;主键插入顺序&lt;/h4&gt;
&lt;p&gt;我们知道，对于InnoDB来说，数据实际上是按主键大小正序存储在聚簇索引的叶子节点上的。所以如果我们插入的记录的主键值是依次增大的话，那我们每插满一个数据页就换到下一个数据页继续插入。而如果我们插入的主键值忽大忽小的话，就会造成频繁的&lt;code&gt;页分裂&lt;/code&gt;，严重影响性能。因此，为了保证性能，需要保证主键是递增的。&lt;/p&gt;
&lt;h3 id=&quot;无法使用索引的几种情况&quot;&gt;无法使用索引的几种情况&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;ORDER BY&lt;/code&gt;的子句后边的列的顺序也必须跟索引列的顺序不一致。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ASC&lt;/code&gt;、&lt;code&gt;DESC&lt;/code&gt;混用&lt;/li&gt;
&lt;li&gt;排序列包含非同一个索引的列&lt;/li&gt;
&lt;li&gt;排序列使用了复杂的表达式&lt;/li&gt;
&lt;li&gt;索引列上使用函数&lt;code&gt;(replace\SUBSTR\CONCAT\sum count avg)、表达式、 计算(+ - * /)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;like 条件中前面带%&lt;/li&gt;
&lt;li&gt;字符串不加引号，出现隐式转换&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;原创不易，觉得文章写得不错的小伙伴，点个赞👍 鼓励一下吧~&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sun, 09 Aug 2020 23:43:00 +0000</pubDate>
<dc:creator>六点半起床</dc:creator>
<og:description>从《mysql存储引擎InnoDB详解，从底层看清InnoDB数据结构》中，我们已经知道了数据页内各个记录是按主键正序排列并组成了一个单向链表的，并且各个数据页之间形成了双向链表。在数据页内，通过页目</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chentianming/p/13467529.html</dc:identifier>
</item>
<item>
<title>【小白学AI】XGBoost 推导详解与牛顿法 - 忽逢桃林</title>
<link>http://www.cnblogs.com/PythonLearner/p/13467492.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/PythonLearner/p/13467492.html</guid>
<description>&lt;p&gt;&lt;strong&gt;文章转自公众号【机器学习炼丹术】，关注回复“炼丹”即可获得海量免费学习资料哦！&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;1-作者前言&quot;&gt;1 作者前言&lt;/h2&gt;
&lt;p&gt;在2020年还在整理XGB的算法，其实已经有点过时了。不过，主要是为了扩大知识面和应付面试嘛。现在的大数据竞赛，XGB基本上已经全面被LGB模型取代了，这里主要是学习一下Boost算法。之前已经在其他博文中介绍了Adaboost算法和Gradient-boost算法，这篇文章讲解一下XGBoost。&lt;/p&gt;
&lt;h2 id=&quot;2-树模型概述&quot;&gt;2 树模型概述&lt;/h2&gt;
&lt;p&gt;XGB就是Extreme Gradient Boosting极限梯度提升模型。XGB简单的说是&lt;strong&gt;一组分类和回归树（CART）&lt;/strong&gt;的组合。跟GBDT和Adaboost都有异曲同工之处。&lt;br/&gt;【CART=classification adn regression trees】&lt;/p&gt;
&lt;p&gt;这里对于一个决策树，如何分裂，如何选择最优的分割点，其实就是一个搜索的过程。搜索怎么分裂，才能让目标函数最小。目标函数如下：&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(Obj = Loss + \Omega\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(Obj\)&lt;/span&gt;就是我们要最小化的优化函数，&lt;span class=&quot;math inline&quot;&gt;\(Loss\)&lt;/span&gt;就是这个CART模型的预测结果和真实值得损失。&lt;span class=&quot;math inline&quot;&gt;\(\Omega\)&lt;/span&gt;就是这个CART模型的复杂度,类似神经网络中的正则项。&lt;br/&gt;&lt;strong&gt;【上面的公式就是一个抽象的概念。我们要知道的是：CART树模型即要求预测尽可能准确，又要求树模型不能过于复杂。】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于回归问题，我们可以用均方差来作为Loss：&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(Loss=\sum_i{(y_i-\hat{y_i})^2}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;对于分类问题，用交叉熵是非常常见的,这里用二值交叉熵作为例子：&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(Loss = \sum_i{(y_ilog(\hat{y_i})+(1-y_i)log(\hat{y_i}))}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;总之，这个Loss就是衡量模型预测准确度的损失。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;下面看一下如何计算这个模型复杂度&lt;span class=&quot;math inline&quot;&gt;\(\Omega\)&lt;/span&gt;吧。&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\Omega = \gamma T+\frac{1}{2} \lambda \sum^T_j{w_j}^2\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(T\)&lt;/span&gt;表示叶子节点的数量，&lt;span class=&quot;math inline&quot;&gt;\(w_j\)&lt;/span&gt;表示每个叶子节点上的权重（与叶子节点的样本数量成正比）。&lt;/p&gt;
&lt;p&gt;【这里有点麻烦的在于，&lt;span class=&quot;math inline&quot;&gt;\(w_j\)&lt;/span&gt;是与每个叶子节点的样本数量成正比，但是并非是样本数量。这个&lt;span class=&quot;math inline&quot;&gt;\(w_j\)&lt;/span&gt;的求取，要依靠与对整个目标函数求导数，然后找到每个叶子节点的权重值&lt;span class=&quot;math inline&quot;&gt;\(w_j\)&lt;/span&gt;。】&lt;/p&gt;
&lt;h2 id=&quot;3-xgb-vs-gbdt&quot;&gt;3 XGB vs GBDT&lt;/h2&gt;
&lt;p&gt;其实说了这么多，感觉XGB和GDBT好像区别不大啊？那是因为说了这么多还没开始说XGB呢！之前都是讲树模型的通用概念的。下面讲解XGB~整理一下网上有的说法，再加上自己的理解。有错误请指出评论，谢谢！&lt;/p&gt;
&lt;h3 id=&quot;31-区别1：自带正则项&quot;&gt;3.1 区别1：自带正则项&lt;/h3&gt;
&lt;p&gt;GDBT中，只是让新的弱分类器来拟合负梯度，那拟合多少棵树才算好呢？不知道。XGB的优化函数中，有一个&lt;span class=&quot;math inline&quot;&gt;\(\Omega\)&lt;/span&gt;复杂度。这个复杂度不是某一课CART的复杂度，而是XGB中所有CART的总复杂度。可想而知，每多一颗CART，这个复杂度就会增加他的惩罚力度，当损失下降小于复杂度上升的时候，XGB就停止了。&lt;/p&gt;
&lt;h3 id=&quot;32-区别2：有二阶导数信息&quot;&gt;3.2 区别2：有二阶导数信息&lt;/h3&gt;
&lt;p&gt;GBDT中新的CART拟合的是负梯度，也就是一阶导数。而在XGB会考虑二阶导数的信息。&lt;/p&gt;
&lt;p&gt;这里简单推导一下XGB如何用上二阶导数的信息的：&lt;/p&gt;
&lt;ol readability=&quot;12&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;之前我们得到了XGB的优化函数：&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(Obj = Loss + \Omega\)&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;然后我们把Loss和Omega写的更具体一点：&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(Obj = \sum_i^n{Loss(y_i,\hat{y}_i^t)}+\sum_j^t{\Omega(cart_j)}\)&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(\hat{y_i^t}\)&lt;/span&gt;表示总共有t个CART弱分类器，然后t个弱分类器给出样本i的估计值就。&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(y_i\)&lt;/span&gt;第i个样本的真实值；&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(\Omega(cart_j)\)&lt;/span&gt;第j个CART模型的复杂度。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;我们现在要求取第t个CART模型的优化函数，所以目前我们只是知道前面t-1的模型。所以我们得到：&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\hat{y}_i^t = \hat{y}_i^{t-1}+f_t(x_i)\)&lt;/span&gt;&lt;br/&gt;t个CART模型的预测，等于前面t-1个CART模型的预测加上第t个模型的预测。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;所以可以得到：&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\sum_i^n{Loss(y_i,\hat{y}_i^t)}=\sum_i^n{Loss(y_i,\hat{y}_i^{t-1}+f_t(x_i))}\)&lt;/span&gt;&lt;br/&gt;这里考虑一下特勒展开：&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(f(x+\Delta x)\approx f(x)+f'(x)\Delta x + \frac{1}{2} f''(x)\Delta x^2\)&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;如何把泰勒公式带入呢？&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\({Loss(y_i,\hat{y}_i^t)}\)&lt;/span&gt;中的&lt;span class=&quot;math inline&quot;&gt;\(y_i\)&lt;/span&gt;其实就是常数，不是变量&lt;br/&gt;所以其实这个是可以看成&lt;span class=&quot;math inline&quot;&gt;\(Loss(\hat{y}_i^t)\)&lt;/span&gt;,也就是:&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(Loss(\hat{y}_i^{t-1}+f_t(x_i))\)&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;带入泰勒公式，把&lt;span class=&quot;math inline&quot;&gt;\(f_t(x_i)\)&lt;/span&gt;看成&lt;span class=&quot;math inline&quot;&gt;\(\Delta x\)&lt;/span&gt;：&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(Loss(\hat{y}_i^{t-1}+f_t(x_i))=Loss(\hat{y}_i^{t-1})+Loss'(\hat{y}_i^{t-1})f_t(x_i)+\frac{1}{2}Loss''(\hat{y}_i^{t-1})(f_t(x_i))^2\)&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在很多的文章中，会用&lt;span class=&quot;math inline&quot;&gt;\(g_i=Loss'(\hat{y}_i^{t-1})\)&lt;/span&gt;,以及&lt;span class=&quot;math inline&quot;&gt;\(h_i=Loss''(\hat{y}_i^{t-1})\)&lt;/span&gt;来表示函数的一阶导数和二阶导数。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;把泰勒展开的东西带回到最开始的优化函数中，删除掉常数项&lt;span class=&quot;math inline&quot;&gt;\(Loss(\hat{y}_i^{t-1})\)&lt;/span&gt;(这个与第t个CART模型无关呀)以及前面t-1个模型的复杂度，可以得到第t个CART的优化函数：&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(Obj^t \approx \sum_i^n{[g_i f_t(x_i)+\frac{1}{2}h_i(f_t(x_i))^2}]+{\Omega(cart_t)}\)&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;【所以XGB用到了二阶导数的信息，而GBDT只用了一阶的梯度】&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;33-区别3：列抽样&quot;&gt;3.3 区别3：列抽样&lt;/h3&gt;
&lt;p&gt;XGB借鉴了随机森林的做法，不仅仅支持样本抽样，还支持特征抽样（列抽样），不仅可以降低过拟合，还可以减少计算。（但是这一点我个人存疑，感觉这个只是代码给出的功能，并不算是XGB本身算法相对GBDT的优势。因为XGB和GBDT明明都可以用列抽样的方法。&lt;strong&gt;总之，最关键的区别是二阶导数那个和引入正则项&lt;/strong&gt;）&lt;/p&gt;
&lt;h2 id=&quot;4-xgb为什么用二阶导&quot;&gt;4 XGB为什么用二阶导&lt;/h2&gt;
&lt;p&gt;这个是一个关于XGB的面试进阶题。第一次看到这个问题的时候，一脸懵逼。&lt;/p&gt;
&lt;p&gt;【先说自己总结的答案】&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;使用了二阶导数的信息，加快了收敛速度。&lt;/li&gt;
&lt;li&gt;减少了计算量。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;41-为什么减少了计算量&quot;&gt;4.1 为什么减少了计算量&lt;/h3&gt;
&lt;p&gt;这个比较理解，就先从这个开始解释。&lt;br/&gt;在GBDT中，最花费时间的就是计算分裂点，选择哪个特征，在哪个分割点进行分裂可以得到最小的loss。假设有5个特征，每个特征有100个潜在分割点，那么分类一次需要计算500次。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(loss(y,\hat{y}^t)\)&lt;/span&gt;像之前一样，写成之前所有已经训练完成的弱分类器和正在训练的分类器&lt;span class=&quot;math inline&quot;&gt;\(loss(y,\hat{y}^{t-1}+f_t(x))\)&lt;/span&gt;&lt;br/&gt;如果计算这个损失的话，我们需要计算500次的&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(loss(y,\hat{y}^{t-1}+f_t(x))\)&lt;/span&gt;&lt;br/&gt;但是假设使用泰勒展开得到：&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(loss(\hat{y}^{t-1})+g*f_t(x)+\frac{1}{2}h(f_t(x))^2\)&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;其中的&lt;span class=&quot;math inline&quot;&gt;\(loss(\hat{y}^{t-1})\)&lt;/span&gt;,&lt;span class=&quot;math inline&quot;&gt;\(g\)&lt;/span&gt;,&lt;span class=&quot;math inline&quot;&gt;\(h\)&lt;/span&gt;都是仅仅与之前已经训练完成的决策树相关，所以就是常数，所以是可以在500次的计算中共享，计算一次足以。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;42-为什么加快收敛速度&quot;&gt;4.2 为什么加快收敛速度&lt;/h3&gt;
&lt;p&gt;这里要回到泰勒展开那里：&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(f(x+\Delta x) = f(x) + g(x) * \Delta x + \frac{1}{2} h(x) (\Delta x)^2\)&lt;/span&gt;&lt;br/&gt;这个式子其实就可以看成是&lt;span class=&quot;math inline&quot;&gt;\(F(\Delta x)\)&lt;/span&gt;,因为&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;可以看成一个常数。我们希望&lt;span class=&quot;math inline&quot;&gt;\(F(\Delta x)\)&lt;/span&gt;最小（也就是损失最小），所以我们对&lt;span class=&quot;math inline&quot;&gt;\(\Delta x\)&lt;/span&gt;求导数：&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(F'(\Delta x)=g(x)+h(x)\Delta x=0\)&lt;/span&gt;&lt;br/&gt;导数为0，则是极小值（默认是凸函数）&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\Delta x=-\frac{g(x)}{h(x)}\)&lt;/span&gt;，也就是说，更新的步长其实就是&lt;strong&gt;一阶导数除以二阶导数&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;了解最优化算法的朋友应该可以意识到，这个其实是跟牛顿法等价的。XGB每一次训练一个新的基模型，其实就是再使用牛顿法来对损失函数进行最小值的优化与更新。&lt;/p&gt;
&lt;p&gt;【小总结】&lt;br/&gt;&lt;strong&gt;因此我个人认为，使用了二阶信息的XGB比使用了一阶信息的GBDT收敛速度快的原因，可以用牛顿法比梯度下降法收敛快来解释。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;【为什么牛顿法收敛速度快】&lt;br/&gt;其实这一块我有些解释不清楚了，因为我最优化算法学的也不精（好像突然发现找不到工作的原因了2333）。能给出的是一个比较通俗的解释：　&lt;strong&gt;从本质上去看，牛顿法是二阶收敛，梯度下降是一阶收敛，所以牛顿法就更快。如果更通俗地说的话，比如你想找一条最短的路径走到一个盆地的最底部，梯度下降法每次只从你当前所处位置选一个坡度最大的方向走一步，牛顿法在选择方向时，不仅会考虑坡度是否够大，还会考虑你走了一步之后，坡度是否会变得更大。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;5-牛顿法&quot;&gt;5 牛顿法&lt;/h2&gt;
&lt;p&gt;这里简单介绍一下牛顿法是什么。毕竟有的朋友可能没学过，或者学过像我一样忘记了。&lt;/p&gt;
&lt;p&gt;【牛顿法的目的】&lt;br/&gt;求解一个函数的根，也就是这个函数与x坐标轴的交点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://helloworld2020.net/wp-content/uploads/2020/07/wp_editor_md_0a308b089d1cc9394b36227b05cb4fa2.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;这里有一个三次曲线，我们初始点在A位置，然后做A位置的切线，可以发现这个切线相交于x轴。&lt;br/&gt;&lt;img src=&quot;http://helloworld2020.net/wp-content/uploads/2020/07/wp_editor_md_89fe27669fd0844a9564deb7fcafff8d.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;然后这个焦点做一个平行于y轴的线，交于B点，然后B点做切线，然后交于x轴，然后......&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://helloworld2020.net/wp-content/uploads/2020/07/wp_editor_md_033028fd1b37bb857af15b22a0da053b.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;然后迭代到C点&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://helloworld2020.net/wp-content/uploads/2020/07/wp_editor_md_0cc516998008aab834291be2e9d8b2a9.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;慢慢的，就逼近三次函数与x轴的交点，也就是三次函数等于0的根了。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;http://helloworld2020.net/wp-content/uploads/2020/07/wp_editor_md_542cfb412baeb81a2dc8069ac4307114.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;【数学算式】&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(x_n\)&lt;/span&gt;点的切线方程：&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(f(x_n)+f'(x_n)(x-x_n)=0\)&lt;/span&gt;&lt;br/&gt;所以很简单得到：&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(x_{n+1}=x_n-\frac{f(x_n)}{f'(x_n)}\)&lt;/span&gt;&lt;br/&gt;【为什么这里只用到了一阶信息？】&lt;br/&gt;因为这里的目的是求取一个函数的根，也就是函数等于0的根。我们在最优化问题中，求解的是一个函数的极小值，这就要求求取这个函数的导数等于0的根，所以在最优化问题中，是一个二阶导数优化方法。&lt;/p&gt;
&lt;p&gt;写了4000字，太累了。欢迎大家加好友交流。&lt;/p&gt;
</description>
<pubDate>Sun, 09 Aug 2020 21:32:00 +0000</pubDate>
<dc:creator>忽逢桃林</dc:creator>
<og:description>文章转自公众号【机器学习炼丹术】，关注回复“炼丹”即可获得海量免费学习资料哦！ 1 作者前言 在2020年还在整理XGB的算法，其实已经有点过时了。不过，主要是为了扩大知识面和应付面试嘛。现在的大数据</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/PythonLearner/p/13467492.html</dc:identifier>
</item>
<item>
<title>ElasticSearch 7.8.1 从入门到精通 - 陈彦斌</title>
<link>http://www.cnblogs.com/chenyanbin/p/13419497.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenyanbin/p/13419497.html</guid>
<description>&lt;ol&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;ElasticSearch&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;对电脑配置要求较高&lt;/strong&gt;&lt;/span&gt;，&lt;span&gt;&lt;strong&gt;内存至少4G以上，空闲2G内存，线程数4018+&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;学习的时候，&lt;span&gt;&lt;strong&gt;推荐将ElasticSearch安装到Linux或者mac上&lt;/strong&gt;&lt;/span&gt;，极度&lt;span&gt;&lt;strong&gt;不推荐装Windows上&lt;/strong&gt;&lt;/span&gt;(坑太多，服务器部署的时候，也不会部署到Window上，学习用Windows上玩，不是耽误自个时间麽)。如果是Window用户想学这个，电脑自身至少16G，然后装虚拟机，在虚拟机上搞个Linux玩&lt;/li&gt;
&lt;li&gt;Linux系统不建议装6/6.5版本的(启动的时候，会检查内核是否3.5+，当然可以忽略这个检查)，推荐装7+&lt;/li&gt;
&lt;li&gt;自身电脑配置不高的话，怎么办呢？土豪做法，去买个云服务器叭，在云服务器上玩&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;注意事项&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;上面第1、2点未满足，又舍不得去买云服务器的小伙伴，就不要往下面看了，看了也白看，ElasticSearch对电脑配置要求较高，前置条件未满足的话，服务是起不来的。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;演示环境说明&lt;/h2&gt;
&lt;p&gt;　　我演示的时候，是用的mac系统，上面装了个虚拟机，虚拟机版本Centos6.5，jdk用的13，ElasticSearch用的版本是 7.8.1。这些&lt;span&gt;&lt;strong&gt;我使用的包我下面也会提供&lt;/strong&gt;&lt;/span&gt;，为了学习的话，尽量和我使用的版本一致，这样大家碰到的问题都一样，安装过程中，我也猜了不少坑，都总结出来了，仔细阅读文档就可以捣鼓出来。&lt;/p&gt;

&lt;p&gt;　　常用的搜索网站：百度、谷歌&lt;/p&gt;
&lt;h2&gt;数据的分类&lt;/h2&gt;
&lt;h3&gt;结构化数据&lt;/h3&gt;
&lt;p&gt;　　指具有固定格式或有限长度的数据，如数据库，元数据等。对于结构化数据，我们一般都是可以通过&lt;span&gt;&lt;strong&gt;关系型数据库&lt;/strong&gt;&lt;/span&gt;（mysql、oracle）的table的&lt;span&gt;&lt;strong&gt;方法存储和搜索&lt;/strong&gt;&lt;/span&gt;，也可以建立索引。通过b-tree等数据结构快速搜索数据&lt;/p&gt;
&lt;h3&gt;非结构化数据&lt;/h3&gt;
&lt;p&gt;　　全文数据，指&lt;span&gt;&lt;strong&gt;不定长或无固定格式的数据&lt;/strong&gt;&lt;/span&gt;，如邮件，word等。对于非结构化数据，也即对全文数据的搜索主要有两种方式：&lt;span&gt;&lt;strong&gt;顺序扫描法，全文搜索法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;顺序扫描法&lt;/h4&gt;
&lt;p&gt;　　我们可以了解它的大概搜索方式，就是按照顺序扫描的方式查找特定的关键字。比如让你在一篇篮球新闻中，找出“科比”这个名字在那些段落出现过。那你肯定需要从头到尾把文章阅读一遍，然后标出关键字在哪些地方出现过&lt;/p&gt;
&lt;p&gt;　　这种方式毋庸置疑是最低效的，如果文章很长，有几万字，等你阅读完这篇新闻找到“科比”这个关键字，那得花多少时间&lt;/p&gt;
&lt;h4&gt;全文搜索&lt;/h4&gt;
&lt;p&gt;　　对非结构化数据进行顺序扫描很慢，我们是否可以进行优化？把非结构化数据想办法弄得有一定结构不就好了嘛？将非结构化数据中的一部分信息提取出来，重新组织，使其变得有一定结构，然后对这些有一定结构的数据进行搜索，从而达到搜索相对较快的目的。这种方式就构成了全文搜索的基本思路。这部分从非结构化数据提取出的然后重新组织的信息，就是索引。&lt;/p&gt;
&lt;h3&gt;什么是全文搜索引擎&lt;/h3&gt;
&lt;p&gt;　　根据百度百科中的定义，全文搜索引擎是目前广泛应用的主流搜索引擎。它的工作原理是计算机索引程序通过扫描文章中的每个词，对每个词建立一个索引，指明该词在文章中出现的次数和位置，当用户查询时，检索程序就根据事先建立的索引进行查找，并将查找的结果反馈给用户。&lt;/p&gt;
&lt;h2&gt;常见的搜索引擎&lt;/h2&gt;
&lt;h3&gt;Lucene&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;Lucene是一个&lt;span&gt;&lt;strong&gt;Java全文搜索引擎&lt;/strong&gt;&lt;/span&gt;，完全用&lt;span&gt;&lt;strong&gt;Java编写&lt;/strong&gt;&lt;/span&gt;。lucene&lt;span&gt;&lt;strong&gt;不是一个完整的应用程序&lt;/strong&gt;&lt;/span&gt;，而是一个代码库和API，可以很容易地用于向应用程序添加搜索功能&lt;/li&gt;
&lt;li&gt;通过简单的API提供强大的功能
&lt;ul&gt;&lt;li&gt;可扩展的高性能索引&lt;/li&gt;
&lt;li&gt;强大，准确，高效的搜索算法&lt;/li&gt;
&lt;li&gt;跨平台解决方案&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Apache软件基金会
&lt;ul&gt;&lt;li&gt;在Apache软件基金会提供的开源软件项目的Apache社区的支持&lt;/li&gt;
&lt;li&gt;但是Lucene只是一个框架，要充分利用它的功能，需要使用Java，并且在程序中集成Lucene。需要很多的学习了解，才能明白它是如何运行的，熟练运用Lucene确实非常复杂&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;Solr&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;Solr是一个基于Lucene的Java库构建的开源搜索平台。它以友好的方式提供Apache Lucene的搜索功能。它是一个成熟的产品，拥有强大而广泛的用户社区。它能提供分布式索引，复制，负载均衡以及自动故障转移和恢复。如果它被正确部署然后管理的好，他就能够成为一个高可用，可扩展且容错的搜索引擎&lt;/li&gt;
&lt;li&gt;强大功能
&lt;ul&gt;&lt;li&gt;全文搜索&lt;/li&gt;
&lt;li&gt;突出&lt;/li&gt;
&lt;li&gt;分面搜索&lt;/li&gt;
&lt;li&gt;实时索引&lt;/li&gt;
&lt;li&gt;动态集群&lt;/li&gt;
&lt;li&gt;数据库集成&lt;/li&gt;
&lt;li&gt;NoSQL功能和丰富的文档处理&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;ElasticSearch&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;ElasticSearch是一个开源，是一个机遇Apache Lucene库构建的Restful搜索引擎&lt;/li&gt;
&lt;li&gt;ElasticSearch是Solr之后几年推出的。它提供了一个分布式，多租户能力的全文搜索引擎，具有HTTP Web页面和无架构JSON文档。ElasticSearch的官方客户端提供Java、Php、Ruby、Perl、Python、.Net和JavaScript&lt;/li&gt;
&lt;li&gt;主要功能
&lt;ul&gt;&lt;li&gt;分布式搜索&lt;/li&gt;
&lt;li&gt;数据分析&lt;/li&gt;
&lt;li&gt;分组和聚合&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;应用场景
&lt;ul&gt;&lt;li&gt;维基百科&lt;/li&gt;
&lt;li&gt;Stack Overflow&lt;/li&gt;
&lt;li&gt;GitHub&lt;/li&gt;
&lt;li&gt;电商网站&lt;/li&gt;
&lt;li&gt;日志数据分析&lt;/li&gt;
&lt;li&gt;商品价格监控网站&lt;/li&gt;
&lt;li&gt;BI系统&lt;/li&gt;
&lt;li&gt;站内搜索&lt;/li&gt;
&lt;li&gt;篮球论坛&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;环境准备&lt;/h2&gt;
&lt;p&gt;　　注意，&lt;span&gt;&lt;strong&gt;我使用的linux搭建的&lt;/strong&gt;&lt;/span&gt;，当然Window(极度不推荐，坑太多)也能搭建，&lt;span&gt;&lt;strong&gt;ElasticSearch安装前需要先安装jdk&lt;/strong&gt;&lt;/span&gt;，这里&lt;span&gt;&lt;strong&gt;我使用的是jdk13&lt;/strong&gt;&lt;/span&gt;，因为linux自带jdk版本，需要先将之前的jdk版本卸载(&lt;a href=&quot;https://www.cnblogs.com/chenyanbin/p/12843149.html&quot; target=&quot;_blank&quot;&gt;点我直达&lt;/a&gt;)，在安装指定的jdk版本!!!&lt;/p&gt;
&lt;p&gt;　　开发环境，建议关闭防火墙，避免不必要的麻烦！！！！生产环境，视情况开启端口号！！！！&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;service iptables stop   命令关闭防火墙，但是系统重启后会开启

chkconfig iptables off--关闭防火墙开机自启动&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;「注意事项」&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;ElasticSearch&lt;/strong&gt;&lt;/span&gt;是&lt;strong&gt;&lt;span&gt;强依赖jdk环境&lt;/span&gt;&lt;/strong&gt;的，所以&lt;span&gt;&lt;strong&gt;一定要安装对应的jdk版本&lt;/strong&gt;&lt;/span&gt;，&lt;span&gt;&lt;strong&gt;&lt;span&gt;并配置好相关的环境变量&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;，比如&lt;span&gt;&lt;strong&gt;ES7.X版本要装jdk8以上的版本&lt;/strong&gt;&lt;/span&gt;，而且是要官方来源的jdk。启动的时候有可能会提示要装jdk11，因为ES7以上官方都是建议使用jdk11，但是一般只是提示信息，不影响启动。&lt;/p&gt;
&lt;p&gt;ES官网推荐JDK版本兼容地址：&lt;a href=&quot;https://www.elastic.co/cn/support/matrix&quot; target=&quot;_blank&quot;&gt;点我直达&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200802195753678-859946891.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　ES强依赖JVM，也很吃内存，所以一定要保证你的机器至少空闲出2G以上内存。推荐使用Linux，可以本地搭建虚拟机。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;&lt;span&gt;启动一定要使用非root账户！！！！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;这是ES强制规定的。ElasticSearch为了安全考虑，不让使用root启动，解决办法是新建一个用户，用此用户进行相关的操作。如果你用root启动，会报错。如果是使用root账户安装ES，首先给安装包授权，比如chown -R 777 安装包路径。然后再使用非root账户启动，具体的权限配置，根据自己想要的配置。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;补充&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;高版本&lt;/strong&gt;&lt;/span&gt;的&lt;strong&gt;&lt;span&gt;ElasticSearch自带jdk版本&lt;/span&gt;&lt;/strong&gt;的，Linux中我安装的是jdk13，没用ElasticSearch自带的jdk，有兴趣的小伙伴可以去研究下。&lt;/p&gt;
&lt;h2&gt;下载&lt;/h2&gt;
&lt;p&gt;官网地址：&lt;a href=&quot;https://www.elastic.co/cn/downloads/elasticsearch&quot; target=&quot;_blank&quot;&gt;点我直达&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;我使用的包(&lt;span&gt;&lt;strong&gt;推荐和我版本保持一致&lt;/strong&gt;&lt;/span&gt;)&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
链接: https://pan.baidu.com/s/1jjNEErHtBu93HmvxKCT5Sw  密码: kbcs
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200802201624179-22818702.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;修改配置文件&lt;/h2&gt;
&lt;p&gt;1、修改elasticsearch-x.x.x/config/&lt;span&gt;&lt;strong&gt;elasticsearch.yml，主要修改成以下内容&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;cluster.name: my-application
node.name: node-1
network.host: 0.0.0.0
http.port: 9200
discovery.seed_hosts: [&quot;127.0.0.1&quot;, &quot;[::1]&quot;]
cluster.initial_master_nodes: [&quot;node-1&quot;]

bootstrap.system_call_filter: false
http.cors.allow-origin: &quot;*&quot;
http.cors.enabled: true
http.cors.allow-headers : X-Requested-With,X-Auth-Token,Content-Type,Content-Length,Authorization
http.cors.allow-credentials: true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、来到elasticsearch-x.x.x/bin下，执行：&lt;span&gt;&lt;strong&gt;sh elasticsearch&lt;/strong&gt;&lt;/span&gt;启动，报错，修改配置文件elasticsearch-env&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200802222027506-1386500274.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3、设置用户和组 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;groupadd elsearch
#添加用户组，语法：groupadd 组名
useradd elsearch -g elsearch -p elasticsearch
#添加用户，并将用户添加到组中，语法：useradd 用户名 -p 密码 -g 组名
chown -R elsearch:elsearch  elasticsearch-6.3.0
# 给用户组授权，语法：chown -R 用户:组名 es安装完整路径&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200802222719769-141772219.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意=================以上root用户操作=============== &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;注意=================以下es用户操作================&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意：若es用户密码登录不上，在回到root用户下，修改es用户的密码，语法：passwd 要修改用户名&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;4、登录到es用户下，继续启动ElasticSearch，执行：sh elasticsearch&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;报错如下：
java.lang.UnsupportedOperationException: seccomp unavailable: requires kernel 3.5+ with CONFIG_SECCOMP and CONFIG_SECCOMP_FILTER compiled in

原因：我用的Centos6.5，其linux内核版本为2.6。而Elasticsearch的插件要求至少3.5以上版本。


解决方案：禁用这个插件即可
修改elasticsearch.yml文件，在最下面添加如下配置：
bootstrap.system_call_filter: false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;5.继续启动ElasticSearch，执行：sh elasticsearch&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;修改一下内容需要使用root权限&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;报错如下4条：
[1]: max file descriptors [4096] for elasticsearch process is too low, increase to at least [65535]
[2]: max number of threads [1024] for user [es] is too low, increase to at least [4096]
[3]: max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144]
[4]: the default discovery settings are unsuitable for production use; at least one of [discovery.seed_hosts, discovery.seed_providers, cluster.initial_master_nodes] must be configured

==========分割线===============
解决办法如下
1、vim /etc/security/limits.conf文件，添加
* soft nofile 65535
* hard nofile 65535

2、vim /etc/security/limits.conf文件，添加
* soft nproc  4096
* hard nproc  4096

3、vim /etc/sysctl.conf 文件，添加
vm.max_map_count=262144  

4、vim /var/soft/es7.8.1/elasticsearch-7.8.1/config/elasticsearch.yml 文件，添加
cluster.initial_master_nodes: [&quot;node-1&quot;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;修改完之后，一定要重启，重启，重启，重要的事儿说三遍！！！！！&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上面第2条问题，线程数修改不了，可以尝试使用这个方法修改线程数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Elasticsearch7.8.1 [1]: max number of threads [1024] for user [es] is too low, increase to at least [4096]异常

根据linux系统差异，有时候需要来点终极解决方案

新建： /etc/security/limits.d/test-limits.conf

cat&amp;gt;&amp;gt;test-limits.conf



然后加下内容：

* soft nofile 65535

* hard nofile 65535

* soft nproc 4096

* hard nproc 4096


ctrl+d保存即可；


然后重启服务器即可；&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200802231831958-1091643975.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;配置小结&lt;/h2&gt;
&lt;p&gt;　　1、第一次配置过程中，踩了不少坑，我踩过的坑，都在上面记录了&lt;/p&gt;
&lt;p&gt;　　2、如果照我上面哪个方法还解决不了，自行根据ElasticSearch日志，百度去找答案叭····&lt;/p&gt;
&lt;h2&gt;启动&lt;/h2&gt;
&lt;h3&gt;正常启动&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;进入软件的安装目录，进入到bin
执行：sh elasticsearch&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;守护进行启动&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;进入软件的安装目录，进入到bin
执行：sh elasticsearch -d -p pid&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;验证&lt;/h2&gt;
&lt;p&gt;　　打开浏览器输入：127.0.0.1:9200&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200802233047105-462812631.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200802235655681-1311117276.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr&gt;&lt;td&gt;类型&lt;/td&gt;
&lt;td&gt;描述&lt;/td&gt;
&lt;td&gt;默认位置&lt;/td&gt;
&lt;td&gt;设置&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;bin&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;⼆进制脚本包含启动节点的elasticsearch&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;{path.home}/bin&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;conf&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;配置⽂件包含elasticsearch.yml &lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;{path.home}/confifig&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;path.conf&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;data&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;在节点上申请的每个index/shard的数据⽂件的位置。&lt;/p&gt;
&lt;p&gt;可容纳多个位置&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;{path.home}/data&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;path.data&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;logs&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;⽇志⽂件位置&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;{path.home}/logs&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;path.logs&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;plugins&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;插件⽂件位置。每个插件将包含在⼀个⼦⽬录中。&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;{path.home}/plugins&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;path.plugins&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h2&gt;核心概念&lt;/h2&gt;
&lt;h3&gt;前言&lt;/h3&gt;
&lt;p&gt;　　传统数据库查询数据的操作步骤是这样的：建立数据库-&amp;gt;建表-&amp;gt;插入数据-&amp;gt;查询&lt;/p&gt;
&lt;h3&gt;索引(&lt;span&gt;index&lt;/span&gt;)&lt;/h3&gt;
&lt;p&gt;　　一个索引可以理解成一个关系型数据库&lt;/p&gt;
&lt;h3&gt;类型(&lt;span&gt;type&lt;/span&gt;)&lt;/h3&gt;
&lt;p&gt;　　一个type就像一类表，比如user表、order表&lt;/p&gt;
&lt;p&gt;　　注意&lt;/p&gt;
&lt;p&gt;　　　　1、ES 5.X中一个index可以有多种type&lt;/p&gt;
&lt;p&gt;　　　　2、ES 6.X中一个index只能有一种type&lt;/p&gt;
&lt;p&gt;　　　　3、ES 7.X以后已经移除type这个概念&lt;/p&gt;
&lt;h3&gt;映射(&lt;span&gt;mapping&lt;/span&gt;)&lt;/h3&gt;
&lt;p&gt;　　mapping定义了每个字段的类型等信息。相当于关系型数据库中的表结构&lt;/p&gt;
&lt;h3&gt;文档(&lt;span&gt;document&lt;/span&gt;)&lt;/h3&gt;
&lt;p&gt;　　一个document相当于关系型数据库中的一行记录&lt;/p&gt;
&lt;h3&gt;字段(&lt;span&gt;field&lt;/span&gt;)&lt;/h3&gt;
&lt;p&gt;　　相当于关系型数据库表的字段&lt;/p&gt;
&lt;h3&gt;集群(&lt;span&gt;cluster&lt;/span&gt;)&lt;/h3&gt;
&lt;p&gt;　　集群由一个或多个节点组成，一个集群由一个默认名称“elasticsearch”&lt;/p&gt;
&lt;h3&gt;节点(&lt;span&gt;node&lt;/span&gt;)&lt;/h3&gt;
&lt;p&gt;　　集群的节点，一台机器或者一个进程&lt;/p&gt;
&lt;h3&gt;分片和副本(&lt;span&gt;shard&lt;/span&gt;)&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;副本是分片的副本。分片有主分片(primary Shard)和副本分片(replica Shard)之分&lt;/li&gt;
&lt;li&gt;一个Index数据在屋里上被分布在多个主分片中，每个主分片只存放部分数据&lt;/li&gt;
&lt;li&gt;每个主分片可以有多个副本，叫副本分片，是主分片的复制&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;RESTful风格的介绍&lt;/h2&gt;
&lt;h3&gt;介绍&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt; RESTful是一种架构的规范与约束、原则，符合这种规范的架构就是RESTful架构&lt;/li&gt;
&lt;li&gt;先看REST是什么意思，英文Representational state transfer表述性状态转移，其实就是对资源的标书性状态转移，即通过HTTP动词来实现资源的状态扭转&lt;/li&gt;
&lt;li&gt;资源是REST系统的核心概念。所有的设计都是以资源为中心&lt;/li&gt;
&lt;li&gt;elasticsearch使用RESTful风格api来设计的&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;方法&lt;/h3&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;action&lt;/td&gt;
&lt;td&gt;描述&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;HEAD&lt;/td&gt;
&lt;td&gt;只获取某个资源的头部信息&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;GET&lt;/td&gt;
&lt;td&gt;获取资源&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;POST&lt;/td&gt;
&lt;td&gt;创建或更新资源&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;PUT&lt;/td&gt;
&lt;td&gt;创建或更新资源&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;DELETE&lt;/td&gt;
&lt;td&gt;删除资源&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;GET /user:列出所有的⽤户
POST /user:新建⼀个⽤户
PUT /user:更新某个指定⽤户的信息
DELETE /user/ID:删除指定⽤户&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;调试工具&lt;/h3&gt;
&lt;h4&gt;Postman工具(&lt;span&gt;推荐&lt;/span&gt;)&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200803221515535-826389706.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;curl工具&lt;/h4&gt;
&lt;p&gt;获取elasticcsearch状态&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
curl -X GET &quot;http://localhost:9200&quot;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;新建一个文档&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;curl -X PUT &quot;localhost:9200/xdclass/_doc/1&quot; -H 'Content-Type:
application/json' -d' {
&quot;user&quot; : &quot;louis&quot;,
&quot;message&quot; : &quot;louis is good&quot;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;删除一个文档&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
curl -X DELETE &quot;localhost:9200/xdclass/_doc/1&quot;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;索引的使用&lt;/h2&gt;
&lt;h3&gt;新增&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200803235912261-597717496.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;单个获取&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200804000213069-1051668846.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;批量获取&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200804000733214-876948181.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;删除&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200804000402060-819102424.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;获取所有&lt;/h3&gt;
&lt;h4&gt;方式一&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200804000956566-1868264517.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;方式二&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200804002255049-1599818844.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200804002318642-599632936.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;判断索引是否存在(存在，返回200，不存在404)&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200804002646359-1259376971.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200804002739971-678882211.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;关闭索引&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200804002946144-811161385.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　此时再次查询cba时，返回json会多一行&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200804003041847-1725755851.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;打开索引&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200804004258960-1746810041.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　关闭索引标记消失&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200804004346380-1438795611.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;介绍&lt;/h2&gt;
&lt;p&gt;　　定义索引的结构，之前定义一个nba索引，但是没有定义他的结构，我们现在开始建立mapping；&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;type=&quot;keyword&quot;：是一个关键字，不会被分词&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;type=&quot;text&quot;：会被分词，使用的是全文索引&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;新增&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200804235510699-857371099.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;json格式&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    &quot;properties&quot;: {
        &quot;name&quot;: {
            &quot;type&quot;: &quot;text&quot;
        },
        &quot;team_name&quot;: {
            &quot;type&quot;: &quot;text&quot;
        },
        &quot;position&quot;: {
            &quot;type&quot;: &quot;keyword&quot;
        },
        &quot;play_year&quot;: {
            &quot;type&quot;: &quot;keyword&quot;
        },
        &quot;jerse_no&quot;: {
            &quot;type&quot;: &quot;keyword&quot;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;获取&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200804235720075-750562025.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;批量获取&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200804235934557-1835658499.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;获取所有mapping&lt;/h3&gt;
&lt;h4&gt;方式一&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200805000120407-199889513.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;方式二&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200805000337375-1406369531.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;添加一次字段&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200805001039629-1601658880.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200805001145345-181954942.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;新增&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200805223923544-990373238.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;不指定索引方式新增&lt;/h3&gt;
&lt;h4&gt;踩坑(&lt;span&gt;要POST请求&lt;/span&gt;)&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200805224714729-439133697.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;PUT请求改POST&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200805230017730-273088302.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;自动创建索引&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;查看auto_create_index开关状态，请求:http://ip:port/_cluster/settings&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200805230643572-1306702978.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当索引不存在并且auto_create_index为true的时候，新增文档时会自动创建索引&lt;/li&gt;
&lt;li&gt;修改auto_create_index状态
&lt;ul&gt;&lt;li&gt;put方式：ip:port/_cluster/settings&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200805230932663-1448852150.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
&quot;persistent&quot;: {
    &quot;action.auto_create_index&quot;: &quot;false&quot;
 }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　当auto_create_index=false时，指定一个不存在的索引，新增文档&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200805231416517-604708195.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    &quot;name&quot;:&quot;杨超越&quot;,
    &quot;team_name&quot;:&quot;梦之队&quot;,
    &quot;position&quot;:&quot;组织后卫&quot;,
    &quot;play_year&quot;:&quot;0&quot;,
    &quot;jerse_no&quot;:&quot;18&quot;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;指定操作类型&lt;/h3&gt;
&lt;p&gt;PUT请求：ip:port/xxx/_doc/1?op_type=create&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200805232518960-1487908581.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;文档查看&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200805224238141-723526011.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;查看多个文档&lt;/h3&gt;
&lt;h4&gt;方式一&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200805233311150-630285133.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    &quot;docs&quot;: [{
            &quot;_index&quot;: &quot;nba&quot;,
            &quot;_type&quot;: &quot;_doc&quot;,
            &quot;_id&quot;: &quot;1&quot;
        },
        {
            &quot;_index&quot;: &quot;nba&quot;,
            &quot;_type&quot;: &quot;_doc&quot;,
            &quot;_id&quot;: &quot;2&quot;
        }
    ]
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;方式二&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200805233524171-984793616.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;方式三&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200805233803816-634801041.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;方式四&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200805234007055-1686498360.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;修改&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200805234709156-1124673982.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;向_source字段，增加一个字段&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200805235534845-1151500934.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    &quot;script&quot;: &quot;ctx._source.age = 18&quot;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;从source字段，删除一个字段&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200806000427390-1076577418.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    &quot;script&quot;: &quot;ctx._source.remove(\&quot;age\&quot;)&quot;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;根据参数值，更新指定文档的字段&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200806001240946-2096723700.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　upsert当指定的文档不存在时，upsert参数包含的内容将会被插入到索引中，作为一个新文档；如果指定的文档存在，ElasticSearch引擎将会执行指定的更新逻辑。&lt;/p&gt;
&lt;h2&gt;删除文档&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200806001608900-921648927.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;准备工作&lt;/h2&gt;
&lt;h3&gt;删除nba索引&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200806220053432-1325323877.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;新建一个索引&lt;/h3&gt;
&lt;p&gt;并指定mapping&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200806220301472-1689820610.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    &quot;mappings&quot;: {
        &quot;properties&quot;: {
            &quot;name&quot;: {
                &quot;type&quot;: &quot;text&quot;
            },
            &quot;team_name&quot;: {
                &quot;type&quot;: &quot;text&quot;
            },
            &quot;position&quot;: {
                &quot;type&quot;: &quot;text&quot;
            },
            &quot;play_year&quot;: {
                &quot;type&quot;: &quot;long&quot;
            },
            &quot;jerse_no&quot;: {
                &quot;type&quot;: &quot;keyword&quot;
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;新增document&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200806220455377-963381252.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;192.168.199.170:9200/nba/_doc/1
{
    &quot;name&quot;: &quot;哈登&quot;,
    &quot;team_name&quot;: &quot;⽕箭&quot;,
    &quot;position&quot;: &quot;得分后卫&quot;,
    &quot;play_year&quot;: 10,
    &quot;jerse_no&quot;: &quot;13&quot;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;192.168.199.170:9200/nba/_doc/2
{
    &quot;name&quot;: &quot;库⾥&quot;,
    &quot;team_name&quot;: &quot;勇⼠&quot;,
    &quot;position&quot;: &quot;控球后卫&quot;,
    &quot;play_year&quot;: 10,
    &quot;jerse_no&quot;: &quot;30&quot;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;192.168.199.170:9200/nba/_doc/3
{
    &quot;name&quot;: &quot;詹姆斯&quot;,
    &quot;team_name&quot;: &quot;湖⼈&quot;,
    &quot;position&quot;: &quot;⼩前锋&quot;,
    &quot;play_year&quot;: 15,
    &quot;jerse_no&quot;: &quot;23&quot;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;词条查询(term)&lt;/h2&gt;
&lt;p&gt;　　词条查询不会分析查询条件，只有当词条和查询字符串完全匹配时，才匹配搜索。&lt;/p&gt;
&lt;h3&gt;单挑term查询&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200806225524638-1582739295.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    &quot;query&quot;: {
        &quot;term&quot;: {
            &quot;jerse_no&quot;: &quot;23&quot;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;多条term查询&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200806230100919-1026027759.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    &quot;query&quot;: {
        &quot;terms&quot;: {
            &quot;jerse_no&quot;: [
                &quot;23&quot;,
                &quot;13&quot;
            ]
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;全文查询(full text)&lt;/h2&gt;
&lt;p&gt;　　ElasticSearch引擎会先分析查询字符串，将其拆分成多个分词，只要已分析的字段中包含词条的任意一个，或全部包含，就匹配查询条件，返回该文档；如果不包含任意一个分词，表示没有任何问的那个匹配查询条件&lt;/p&gt;
&lt;h3&gt;match_all&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200806230828824-1741012944.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    &quot;query&quot;: {
        &quot;match_all&quot;: {}
    },
    &quot;from&quot;: 0,
    &quot;size&quot;: 10
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;match&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200806231059033-1411401384.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    &quot;query&quot;: {
        &quot;match&quot;: {
            &quot;position&quot;:&quot;后卫&quot;
        }
    },
    &quot;from&quot;: 0,
    &quot;size&quot;: 10
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;multi_match&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200806231723234-1589703110.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    &quot;query&quot;: {
        &quot;multi_match&quot;: {
            &quot;query&quot;: &quot;shooter&quot;,
            &quot;fields&quot;: [&quot;title&quot;, &quot;name&quot;]
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;post 192.168.199.170:9200/nba/_update/2
{
    &quot;doc&quot;: {
        &quot;name&quot;: &quot;库⾥&quot;,
        &quot;team_name&quot;: &quot;勇⼠&quot;,
        &quot;position&quot;: &quot;控球后卫&quot;,
        &quot;play_year&quot;: 10,
        &quot;jerse_no&quot;: &quot;30&quot;,
        &quot;title&quot;: &quot;the best shooter&quot;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;match_phrase&lt;/h3&gt;
&lt;p&gt;　　类似于词条查询，精准查询&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200806232024365-608717834.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;match_phrase_prefix&lt;/h3&gt;
&lt;p&gt;　　前缀匹配&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200806232528531-599792971.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    &quot;query&quot;: {
        &quot;match_phrase_prefix&quot;: {
            &quot;title&quot;: &quot;the best s&quot;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;post 192.168.199.170:9200/nba/_update/3
{
    &quot;doc&quot;: {
        &quot;name&quot;: &quot;詹姆斯&quot;,
        &quot;team_name&quot;: &quot;湖⼈&quot;,
        &quot;position&quot;: &quot;⼩前锋&quot;,
        &quot;play_year&quot;: 15,
        &quot;jerse_no&quot;: &quot;23&quot;,
        &quot;title&quot;: &quot;the best small forward&quot;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;什么是分词器&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;将用户输入的一段文本，按照一定逻辑，分析成多个词语的一种工具&lt;/li&gt;
&lt;li&gt;example：The best 3-points shooter is Curry!&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;常用的内置分词器&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;standard analyzer&lt;/li&gt;
&lt;li&gt;simple analyzer&lt;/li&gt;
&lt;li&gt;whitespace analyzer&lt;/li&gt;
&lt;li&gt;stop analyzer&lt;/li&gt;
&lt;li&gt;language analyzer&lt;/li&gt;
&lt;li&gt;pattern analyzer&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;standard analyzer&lt;/h3&gt;
&lt;p&gt;　　标准分析器是&lt;span&gt;&lt;strong&gt;默认分词器&lt;/strong&gt;&lt;/span&gt;，如果未指定，则使用该分词器&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200806233815373-430057577.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    &quot;analyzer&quot;: &quot;standard&quot;,
    &quot;text&quot;: &quot;The best 3-points shooter is Curry!&quot;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;simple analyzer&lt;/h3&gt;
&lt;p&gt;　　simple分析器当他遇到只要&lt;span&gt;&lt;strong&gt;不是字母的字符&lt;/strong&gt;&lt;/span&gt;，就将文本解析成term，而且&lt;span&gt;&lt;strong&gt;所有的term都是小写&lt;/strong&gt;&lt;/span&gt;的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200806234024004-16094870.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;whitespace analyzer&lt;/h3&gt;
&lt;p&gt;　　whitespace分析器，当他遇到&lt;span&gt;&lt;strong&gt;空白字符&lt;/strong&gt;&lt;/span&gt;时，就将文本解析成terms&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200806234223428-873735848.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;stop analyzer&lt;/h3&gt;
&lt;p&gt;　　stop分析器和simple分析器很想，唯一不同的是，stop分析器增加了对删除停止词的支持，默认使用了english停止词&lt;/p&gt;
&lt;p&gt;　　stopwords预定义的停止词列表，比如(ths,a,an,this,of,at)等等&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200806235244774-512010109.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;language analyzer&lt;/h3&gt;
&lt;p&gt;（特定的语⾔的分词器，⽐如说，english，英语分词器),内置语⾔：arabic, armenian,&lt;/p&gt;
&lt;p&gt;basque, bengali, brazilian, bulgarian, catalan, cjk, czech, danish, dutch, english, fifinnish,&lt;/p&gt;
&lt;p&gt;french, galician, german, greek, hindi, hungarian, indonesian, irish, italian, latvian,&lt;/p&gt;
&lt;p&gt;lithuanian, norwegian, persian, portuguese, romanian, russian, sorani, spanish,&lt;/p&gt;
&lt;p&gt;swedish, turkish, thai &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200806235513483-623924294.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;pattern analyzer&lt;/h3&gt;
&lt;p&gt;　　用正则表达式将文本分割成sterms，默认的正则表达式是\W+&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200806235651515-158758844.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;选择分词器&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200807000753119-447127850.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;put 192.168.199.170:9200/my_index
{
    &quot;settings&quot;: {
        &quot;analysis&quot;: {
            &quot;analyzer&quot;: {
                &quot;my_analyzer&quot;: {
                    &quot;type&quot;: &quot;whitespace&quot;
                }
            }
        }
    },
    &quot;mappings&quot;: {
        &quot;properties&quot;: {
            &quot;name&quot;: {
                &quot;type&quot;: &quot;text&quot;
            },
            &quot;team_name&quot;: {
                &quot;type&quot;: &quot;text&quot;
            },
            &quot;position&quot;: {
                &quot;type&quot;: &quot;text&quot;
            },
            &quot;play_year&quot;: {
                &quot;type&quot;: &quot;long&quot;
            },
            &quot;jerse_no&quot;: {
                &quot;type&quot;: &quot;keyword&quot;
            },
            &quot;title&quot;: {
                &quot;type&quot;: &quot;text&quot;,
                &quot;analyzer&quot;: &quot;my_analyzer&quot;
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200807000901015-1272170885.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    &quot;name&quot;: &quot;库⾥&quot;,
    &quot;team_name&quot;: &quot;勇⼠&quot;,
    &quot;position&quot;: &quot;控球后卫&quot;,
    &quot;play_year&quot;: 10,
    &quot;jerse_no&quot;: &quot;30&quot;,
    &quot;title&quot;: &quot;The best 3-points shooter is Curry!&quot;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200807001028699-954689699.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    &quot;query&quot;: {
        &quot;match&quot;: {
            &quot;title&quot;: &quot;Curry!&quot;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;默认的分词standard&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200807220444617-1385681451.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    &quot;analyzer&quot;: &quot;standard&quot;,
    &quot;text&quot;: &quot;⽕箭明年总冠军&quot; 
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;常见分词器&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;smartCN一个简单的中文或中英文混合文本的分词器&lt;/li&gt;
&lt;li&gt;IK分词器，更智能更友好的中文分词器&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;安装smartCN&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;sh elasticsearch-plugin install analysis-smartcn&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200807220756343-1604171915.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;校验&lt;/h4&gt;
&lt;p&gt;　　安装后重启&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200807224309121-79747780.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    &quot;analyzer&quot;: &quot;smartcn&quot;,
    &quot;text&quot;: &quot;⽕箭明年总冠军&quot; 
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;卸载&lt;/h4&gt;
&lt;p&gt;　　sh elasticsearch-plugin remove analysis-smartcn&lt;/p&gt;
&lt;h3&gt;IK分词器&lt;/h3&gt;
&lt;p&gt;　　下载地址：&lt;a href=&quot;https://github.com/medcl/elasticsearch-analysis-ik/releases&quot; target=&quot;_blank&quot;&gt;点我直达&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200807224719009-676258107.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;安装，解压到plugins目录 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200807225252051-1361508952.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后重启 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200807225533861-1268625291.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;数据类型&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;核心数据类型&lt;/li&gt;
&lt;li&gt;复杂数据类型&lt;/li&gt;
&lt;li&gt;专用数据类型&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;核心数据类型&lt;/h2&gt;
&lt;h3&gt;字符串&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;text：用于全文索引，该类型的字段将通过分词器进行分词&lt;/li&gt;
&lt;li&gt;keyword：不分词，只能搜索该字段的完整的值&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;数值型&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;long、integer、short、byte、double、float、half_float、scaled_float&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;布尔&lt;/h3&gt;
&lt;h3&gt;二进制&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;binary：该类型的字段把值当做经过base64编码的字符串，默认不存储，且不可搜索&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;范围类型&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;范围类型表示值是一个范围，而不是一个具体的值&lt;/li&gt;
&lt;li&gt;integer_range、float_range、long_range、double_range、date_range&lt;/li&gt;
&lt;li&gt;比如age类型是integer_range，那么值可以是{&quot;gte&quot;:20,&quot;lte&quot;:40}；搜索&quot;term&quot;:{&quot;age&quot;:21}可以搜索该值&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;日期-date&lt;/h3&gt;
&lt;p&gt;　　由于json类型没有date类型，所以es通过识别字符串是否符合format定义的格式来判断是否为date类型&lt;/p&gt;
&lt;p&gt;　　format默认为：strict_date_optional_time || epoch_millis&lt;/p&gt;
&lt;p&gt;　　格式&lt;/p&gt;
&lt;p&gt;　　　　&quot;2022-01-01&quot; &quot;2022/01/01 12:10:30&quot; 这种字符串格式&lt;/p&gt;
&lt;p&gt;　　从开始纪元（1970年1月1日0点）开始的毫秒数&lt;/p&gt;
&lt;div readability=&quot;25&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;PUT 192.168.199.170:9200/nba/_mapping

{
    &quot;properties&quot;: {
        &quot;name&quot;: {
            &quot;type&quot;: &quot;text&quot;
        },
        &quot;team_name&quot;: {
            &quot;type&quot;: &quot;text&quot;
        },
        &quot;position&quot;: {
            &quot;type&quot;: &quot;text&quot;
        },
        &quot;play_year&quot;: {
            &quot;type&quot;: &quot;long&quot;
        },
        &quot;jerse_no&quot;: {
            &quot;type&quot;: &quot;keyword&quot;
        },
        &quot;title&quot;: {
            &quot;type&quot;: &quot;text&quot;
        },
        &quot;date&quot;: {
            &quot;type&quot;: &quot;date&quot;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;POST 192.168.199.170:9200/nba/_doc/4

{
    &quot;name&quot;: &quot;蔡x坤&quot;,
    &quot;team_name&quot;: &quot;勇⼠&quot;,
    &quot;position&quot;: &quot;得分后卫&quot;,
    &quot;play_year&quot;: 10,
    &quot;jerse_no&quot;: &quot;31&quot;,
    &quot;title&quot;: &quot;打球最帅的明星&quot;,
    &quot;date&quot;: &quot;2020-01-01&quot;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;POST 192.168.199.170:9200/nba/_doc/5

{
    &quot;name&quot;: &quot;杨超越&quot;,
    &quot;team_name&quot;: &quot;猴急&quot;,
    &quot;position&quot;: &quot;得分后卫&quot;,
    &quot;play_year&quot;: 10,
    &quot;jerse_no&quot;: &quot;32&quot;,
    &quot;title&quot;: &quot;打球最可爱的明星&quot;,
    &quot;date&quot;: 1610350870
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;POST 192.168.199.170:9200/nba/_doc/6

{
    &quot;name&quot;: &quot;吴亦凡&quot;,
    &quot;team_name&quot;: &quot;湖⼈&quot;,
    &quot;position&quot;: &quot;得分后卫&quot;,
    &quot;play_year&quot;: 10,
    &quot;jerse_no&quot;: &quot;33&quot;,
    &quot;title&quot;: &quot;最会说唱的明星&quot;,
    &quot;date&quot;: 1641886870000
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;复杂数据类型&lt;/h2&gt;
&lt;/div&gt;
&lt;h3&gt;数据类型 Array&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;ES中没有专门的数据类型，直接使用[]定义接口，数组中所有的值必须是同一种数据类型，不支持混合数据类型的数组&lt;/li&gt;
&lt;li&gt;字符串数组[&quot;one&quot;,&quot;two&quot;]&lt;/li&gt;
&lt;li&gt;整数数组[1,2]&lt;/li&gt;
&lt;li&gt;Object对象数组[{&quot;name&quot;:&quot;alex&quot;,&quot;age&quot;:18},{&quot;name&quot;:&quot;tom&quot;,&quot;age&quot;:18}]&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;对象类型Object&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;POST 192.168.199.170:9200/nba/_doc/8

{
    &quot;name&quot;: &quot;吴亦凡&quot;,
    &quot;team_name&quot;: &quot;湖⼈&quot;,
    &quot;position&quot;: &quot;得分后卫&quot;,
    &quot;play_year&quot;: 10,
    &quot;jerse_no&quot;: &quot;33&quot;,
    &quot;title&quot;: &quot;最会说唱的明星&quot;,
    &quot;date&quot;: &quot;1641886870&quot;,
    &quot;array&quot;: [
        &quot;one&quot;,
        &quot;two&quot;
    ],
    &quot;address&quot;: {
        &quot;region&quot;: &quot;China&quot;,
        &quot;location&quot;: {
            &quot;province&quot;: &quot;GuangDong&quot;,
            &quot;city&quot;: &quot;GuangZhou&quot;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;索引方式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&quot;address.region&quot;: &quot;China&quot;,
&quot;address.location.province&quot;: &quot;GuangDong&quot;,
&quot;address.location.city&quot;: &quot;GuangZhou&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;POST 192.168.199.170:9200/nba/_search

{
    &quot;query&quot;: {
        &quot;match&quot;: {
            &quot;address.region&quot;: &quot;china&quot;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;专用数据类型&lt;/h2&gt;
&lt;h3&gt;IP类型&lt;/h3&gt;
&lt;p&gt;　　IP类型的字段用于存储IPv4和IPv6的地址，本质上是一个长整形字段&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;POST 192.168.199.170:9200/nba/_mapping

{
    &quot;properties&quot;: {
        &quot;name&quot;: {
            &quot;type&quot;: &quot;text&quot;
        },
        &quot;team_name&quot;: {
            &quot;type&quot;: &quot;text&quot;
        },
        &quot;position&quot;: {
            &quot;type&quot;: &quot;text&quot;
        },
        &quot;play_year&quot;: {
            &quot;type&quot;: &quot;long&quot;
        },
        &quot;jerse_no&quot;: {
            &quot;type&quot;: &quot;keyword&quot;
        },
        &quot;title&quot;: {
            &quot;type&quot;: &quot;text&quot;
        },
        &quot;date&quot;: {
            &quot;type&quot;: &quot;date&quot;
        },
        &quot;ip_addr&quot;: {
            &quot;type&quot;: &quot;ip&quot;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;PUT 192.168.199.170:9200/nba/_doc/9

{
    &quot;name&quot;: &quot;吴亦凡&quot;,
    &quot;team_name&quot;: &quot;湖⼈&quot;,
    &quot;position&quot;: &quot;得分后卫&quot;,
    &quot;play_year&quot;: 10,
    &quot;jerse_no&quot;: &quot;33&quot;,
    &quot;title&quot;: &quot;最会说唱的明星&quot;,
    &quot;ip_addr&quot;: &quot;192.168.1.1&quot;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;POST 192.168.199.170:9200/nba/_search

{
    &quot;query&quot;: {
        &quot;term&quot;: {
            &quot;ip_addr&quot;: &quot;192.168.0.0/16&quot;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;简介&lt;/h2&gt;
&lt;p&gt;　　可视化工具kibana的安装和使用&lt;/p&gt;
&lt;h2&gt;下载&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.elastic.co/cn/downloads/kibana&quot; target=&quot;_blank&quot;&gt;点我直达&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200808003422356-2074044787.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;赋权限&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; chown -R es:es781g /var/soft/kibana-7.8.1-linux-x86_64
# 给用户组授权，语法：chown -R 用户:组名 es安装完整路径&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200808003847985-46442331.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;kibana.yml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;server.port: 5601   #kibana端口
server.host: &quot;10.0.0.169&quot;    #绑定的主机IP地址
elasticsearch.hosts: [&quot;http://10.0.0.169:9200&quot;]      #elasticsearch的主机IP
kibana.index: &quot;.kibana&quot;     #开启此选项
i18n.locale: &quot;zh-CN&quot;     #kibana默认文字是英文，变更成中文&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;启动&lt;/h2&gt;
&lt;p&gt;进⼊到⽂件夹的bin⽬录，执⾏sh kibana&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200807235149994-1896408699.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/div&gt;
&lt;h2&gt;访问&lt;/h2&gt;
&lt;p&gt;ip:5601&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200808004301598-440418039.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;简单使用&lt;/h2&gt;
&lt;p&gt;　　后面示例，会大量使用该工具&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200809231641735-520939000.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;简介&lt;/h2&gt;
&lt;p&gt;　　手把手教你批量导入数据&lt;/p&gt;
&lt;h2&gt;Bulk&lt;/h2&gt;
&lt;p&gt;　　ES提供了一个叫bulk的API来进行批量操作&lt;/p&gt;
&lt;h3&gt;批量导入&lt;/h3&gt;
&lt;p&gt;数据&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{&quot;index&quot;: {&quot;_index&quot;: &quot;book&quot;, &quot;_type&quot;: &quot;_doc&quot;, &quot;_id&quot;: 1}}
{&quot;name&quot;: &quot;权⼒的游戏&quot;} {&quot;index&quot;: {&quot;_index&quot;: &quot;book&quot;, &quot;_type&quot;: &quot;_doc&quot;, &quot;_id&quot;: 2}}
{&quot;name&quot;: &quot;疯狂的⽯头&quot;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200808225914165-1026861927.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;POST bulk&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
curl -X POST &quot;192.168.199.170:9200/_bulk&quot; -H 'Content-Type: application/json' --data-binary @test
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200808231101430-503962155.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200808231433833-1757607767.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;h2&gt;介绍&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;单词级别查询&lt;/li&gt;
&lt;li&gt;这些查询通常用于结构化的数据，比如：number，data，keyword等，而不是对text&lt;/li&gt;
&lt;li&gt;也就是说，全文查询之前要先对文本内容进行分词，而单词级别的查询直接在相应字段的反向索引中精确查找，单词级别的查询一般用于数值、日期等类型的字段上&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;准备工作&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;删除nba&lt;/li&gt;
&lt;li&gt;新增nba索引&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
{&quot;mappings&quot;:{&quot;properties&quot;:{&quot;birthDay&quot;:{&quot;type&quot;:&quot;date&quot;},&quot;birthDayStr&quot;: {&quot;type&quot;:&quot;keyword&quot;},&quot;age&quot;:{&quot;type&quot;:&quot;integer&quot;},&quot;code&quot;: {&quot;type&quot;:&quot;text&quot;},&quot;country&quot;:{&quot;type&quot;:&quot;text&quot;},&quot;countryEn&quot;: {&quot;type&quot;:&quot;text&quot;},&quot;displayAffiliation&quot;:{&quot;type&quot;:&quot;text&quot;},&quot;displayName&quot;: {&quot;type&quot;:&quot;text&quot;},&quot;displayNameEn&quot;:{&quot;type&quot;:&quot;text&quot;},&quot;draft&quot;: {&quot;type&quot;:&quot;long&quot;},&quot;heightValue&quot;:{&quot;type&quot;:&quot;float&quot;},&quot;jerseyNo&quot;: {&quot;type&quot;:&quot;text&quot;},&quot;playYear&quot;:{&quot;type&quot;:&quot;long&quot;},&quot;playerId&quot;: {&quot;type&quot;:&quot;keyword&quot;},&quot;position&quot;:{&quot;type&quot;:&quot;text&quot;},&quot;schoolType&quot;: {&quot;type&quot;:&quot;text&quot;},&quot;teamCity&quot;:{&quot;type&quot;:&quot;text&quot;},&quot;teamCityEn&quot;: {&quot;type&quot;:&quot;text&quot;},&quot;teamConference&quot;: {&quot;type&quot;:&quot;keyword&quot;},&quot;teamConferenceEn&quot;:{&quot;type&quot;:&quot;keyword&quot;},&quot;teamName&quot;: {&quot;type&quot;:&quot;keyword&quot;},&quot;teamNameEn&quot;:{&quot;type&quot;:&quot;keyword&quot;},&quot;weight&quot;: {&quot;type&quot;:&quot;text&quot;}}}}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200808233602292-1308096637.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;批量导入player&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;Term query精准匹配查询&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;POST nba/_search
{
  &quot;query&quot;: {
    &quot;term&quot;: {
      &quot;jerseyNo&quot;: &quot;23&quot;
    }
  },
  &quot;from&quot;: 0,
  &quot;size&quot;: 20
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200808234209450-1782525297.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Exsit Query在特定的字段中查找非空值的文档(查找队名非空的球员)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200808234336576-1970469819.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Prefix Query查找包含带有指定前缀term的文档(查找队名为Rock开头的球员)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200808234526577-1615967790.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Wildcard Query支持通配符查询，*表示任意字符，?表示任意单个字符（查找火箭队的球员）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200808234708022-227227798.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Regexp Query正则表达式查询（查找火箭队的球员）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200808234838930-2067334620.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Ids Query(查找id为1和2的球员)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200808234955192-409886664.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;查询指定字段在指定范围内包含值（日期、数字或字符串）的文档&lt;/p&gt;
&lt;p&gt;　　查找在nba打球在2年到10年以内的球员&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200809135838450-748621644.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;POST nba/_search
{
  &quot;query&quot;: {
    &quot;range&quot;: {
      &quot;playYear&quot;: {
        &quot;gte&quot;: 2,
        &quot;lte&quot;: 10
      }
    }
  },
  &quot;from&quot;: 0,
  &quot;size&quot;: 20
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查找1999年到2020年出生的球员&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200809141718939-709337714.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;POST nba/_search
{
  &quot;query&quot;: {
    &quot;range&quot;: {
      &quot;birthDay&quot;: {
        &quot;gte&quot;: &quot;01/01/1999&quot;,
        &quot;lte&quot;: &quot;2020&quot;,
        &quot;format&quot;: &quot;dd/MM/yyyy||yyyy&quot;
      }
    }
  },
  &quot;from&quot;: 0,
  &quot;size&quot;: 20
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;布尔查询&lt;/h2&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr&gt;&lt;td&gt;type&lt;/td&gt;
&lt;td&gt;description&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;must&lt;/td&gt;
&lt;td&gt;必须出现在匹配文档中&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;filter&lt;/td&gt;
&lt;td&gt;必须出现在文档中，但是不打分&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;must_not&lt;/td&gt;
&lt;td&gt;不能出现在文档中&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;should&lt;/td&gt;
&lt;td&gt;应该出现在文档中&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2&gt;must(查询名字叫做james的球员)&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200809142614367-749768234.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;POST nba/_search
{
  &quot;query&quot;: {
    &quot;bool&quot;: {
      &quot;must&quot;: [
        {
          &quot;match&quot;: {
            &quot;displayNameEn&quot;: &quot;james&quot;
          }
        }
      ]
    }
  },
  &quot;from&quot;: 0,
  &quot;size&quot;: 20
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;效果通must，但是不打分(查找名字叫做james的球员)&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200809143117376-167327594.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;POST nba/_search
{
  &quot;query&quot;: {
    &quot;bool&quot;: {
      &quot;filter&quot;: [
        {
          &quot;match&quot;: {
            &quot;displayNameEn&quot;: &quot;james&quot;
          }
        }
      ]
    }
  },
  &quot;from&quot;: 0,
  &quot;size&quot;: 20
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;must_not（查找名字叫做James的西部球员）&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200809143520540-1491349438.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;POST nba/_search
{
  &quot;query&quot;: {
    &quot;bool&quot;: {
      &quot;must&quot;: [
        {
          &quot;match&quot;: {
            &quot;displayNameEn&quot;: &quot;james&quot;
          }
        }
      ],
      &quot;must_not&quot;: [
        {
          &quot;term&quot;: {
            &quot;teamConferenceEn&quot;: {
              &quot;value&quot;: &quot;Eastern&quot;
            }
          }
        }
      ]
    }
  },
  &quot;from&quot;: 0,
  &quot;size&quot;: 20
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;组合起来含义：一定不在东部的james&lt;/p&gt;
&lt;h2&gt;should（查找名字叫做James的打球时间应该在11到20年西部球员）&lt;/h2&gt;
&lt;p&gt;即使匹配不到也返回，只是评分不同&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200809144031938-1716897268.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;POST nba/_search
{
  &quot;query&quot;: {
    &quot;bool&quot;: {
      &quot;must&quot;: [
        {
          &quot;match&quot;: {
            &quot;displayNameEn&quot;: &quot;james&quot;
          }
        }
      ],
      &quot;must_not&quot;: [
        {
          &quot;term&quot;: {
            &quot;teamConferenceEn&quot;: {
              &quot;value&quot;: &quot;Eastern&quot;
            }
          }
        }
      ],
      &quot;should&quot;: [
        {
          &quot;range&quot;: {
            &quot;playYear&quot;: {
              &quot;gte&quot;: 11,
              &quot;lte&quot;: 20
            }
          }
        }
      ]
    }
  },
  &quot;from&quot;: 0,
  &quot;size&quot;: 20
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果minimum_should_match=1，则变成要查出名字叫做James的打球时间在11年到20年西部球员&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200809144315828-224639319.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;POST nba/_search
{
  &quot;query&quot;: {
    &quot;bool&quot;: {
      &quot;must&quot;: [
        {
          &quot;match&quot;: {
            &quot;displayNameEn&quot;: &quot;james&quot;
          }
        }
      ],
      &quot;must_not&quot;: [
        {
          &quot;term&quot;: {
            &quot;teamConferenceEn&quot;: {
              &quot;value&quot;: &quot;Eastern&quot;
            }
          }
        }
      ],
      &quot;should&quot;: [
        {
          &quot;range&quot;: {
            &quot;playYear&quot;: {
              &quot;gte&quot;: 11,
              &quot;lte&quot;: 20
            }
          }
        }
      ],
      &quot;minimum_should_match&quot;: 1
    }
  },
  &quot;from&quot;: 0,
  &quot;size&quot;: 20
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;minimum_should_match代表了最小匹配经度，如果设置minimum_should_match=1，那么should语句中至少需要有一个条件满足&lt;/p&gt;

&lt;h2&gt;火箭队中按打球时间从大到小排序的球员&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200809145015029-2043407873.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;POST nba/_search
{
  &quot;query&quot;: {
    &quot;match&quot;: {
      &quot;teamNameEn&quot;: &quot;Rockets&quot;
    }
  },
  &quot;sort&quot;: [
    {
      &quot;playYear&quot;: {
        &quot;order&quot;: &quot;desc&quot;
      }
    }
  ], 
  &quot;from&quot;: 0,
  &quot;size&quot;: 20
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;火箭队中按打球时间从大到小，如果年龄相同则按照身高从高到低排序的球员&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200809145230889-307097425.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;POST nba/_search
{
  &quot;query&quot;: {
    &quot;match&quot;: {
      &quot;teamNameEn&quot;: &quot;Rockets&quot;
    }
  },
  &quot;sort&quot;: [
    {
      &quot;playYear&quot;: {
        &quot;order&quot;: &quot;desc&quot;
      }
    },{
      &quot;heightValue&quot;: {
        &quot;order&quot;: &quot;asc&quot;
      }
    }
  ],
  &quot;from&quot;: 0,
  &quot;size&quot;: 20
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;ES聚合查询是什么&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;聚合查询是数据库&lt;/strong&gt;&lt;/span&gt;中&lt;strong&gt;&lt;span&gt;重要&lt;/span&gt;&lt;/strong&gt;的&lt;span&gt;&lt;strong&gt;功能特性&lt;/strong&gt;&lt;/span&gt;，完成对一个查询得到的数据集的聚合计算，如：找出某字段(或计算表达式的结果)的&lt;span&gt;&lt;strong&gt;最大值，最小值，计算和，平均值&lt;/strong&gt;&lt;/span&gt;等。ES作为搜索引擎，同样提供了强大的聚合分析能力&lt;/li&gt;
&lt;li&gt;对一个数据集求最大、最小、和、平均值等指标的聚合，在ES中称为&lt;span&gt;&lt;strong&gt;指标聚合&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;而关系型数据库中除了有聚合函数外，还可以对查询出的数据进行分组group by，再在组上进行指标聚合。在ES中称为“&lt;strong&gt;&lt;span&gt;桶聚合&lt;/span&gt;&lt;/strong&gt;”&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;max min sum avg&lt;/h2&gt;
&lt;h3&gt;求出火箭队球员的平均年龄&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200809194808911-809076093.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;POST /nba/_search
{
  &quot;query&quot;: {
    &quot;term&quot;: {
      &quot;teamNameEn&quot;: {
        &quot;value&quot;: &quot;Rockets&quot;
      }
    }
  },
  &quot;aggs&quot;: {
    &quot;avgAge&quot;: {
      &quot;avg&quot;: {
        &quot;field&quot;: &quot;age&quot;
      }
    }
  },
  &quot;size&quot;: 0
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;value_count统计非空字段的文档数&lt;/h3&gt;
&lt;h4&gt;求出火箭队中球员打球时间不为空的数量&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200809195050863-627295009.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;POST /nba/_search
{
  &quot;query&quot;: {
    &quot;term&quot;: {
      &quot;teamNameEn&quot;: {
        &quot;value&quot;: &quot;Rockets&quot;
      }
    }
  },
  &quot;aggs&quot;: {
    &quot;countPlayerYear&quot;: {
      &quot;value_count&quot;: {
        &quot;field&quot;: &quot;playYear&quot;
      }
    }
  },
  &quot;size&quot;: 0
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;查出火箭队有多少名球员&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200809195209347-591320535.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;POST /nba/_search
{
  &quot;query&quot;: {
    &quot;term&quot;: {
      &quot;teamNameEn&quot;: {
        &quot;value&quot;: &quot;Rockets&quot;
      }
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Cardinality值去重计数&lt;/h3&gt;
&lt;h4&gt;查出火箭队中年龄不同的数量&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200809195431617-1014314746.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;POST /nba/_search
{
  &quot;query&quot;: {
    &quot;term&quot;: {
      &quot;teamNameEn&quot;: {
        &quot;value&quot;: &quot;Rockets&quot;
      }
    }
  },
  &quot;aggs&quot;: {
    &quot;countAget&quot;: {
      &quot;cardinality&quot;: {
        &quot;field&quot;: &quot;age&quot;
      }
    }
  },
  &quot;size&quot;: 0
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;stats统计count max min avg sum5个值&lt;/h2&gt;
&lt;h4&gt;查出火箭队球员的年龄stats&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200809195617781-1039383836.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;POST /nba/_search
{
  &quot;query&quot;: {
    &quot;term&quot;: {
      &quot;teamNameEn&quot;: {
        &quot;value&quot;: &quot;Rockets&quot;
      }
    }
  },
  &quot;aggs&quot;: {
    &quot;statsAge&quot;: {
      &quot;stats&quot;: {
        &quot;field&quot;: &quot;age&quot;
      }
    }
  },
  &quot;size&quot;: 0
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Extended stats比stats多4个统计结果：平方和、方差、标准差、平均值加/减两个标准差的区间&lt;/h2&gt;
&lt;h3&gt;查询火箭队球员的年龄Extend stats&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200809205526247-1087747637.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;POST /nba/_search
{
  &quot;query&quot;: {
    &quot;term&quot;: {
      &quot;teamNameEn&quot;: {
        &quot;value&quot;: &quot;Rockets&quot;
      }
    }
  },
  &quot;aggs&quot;: {
    &quot;extendStatsAge&quot;: {
      &quot;extended_stats&quot;: {
        &quot;field&quot;: &quot;age&quot;
      }
    }
  },
  &quot;size&quot;: 0
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Percentiles占比百分位对应的值统计，默认返回【1,5,25,50,75,95,99】分位上的值&lt;/h2&gt;
&lt;h3&gt;查出火箭的球员的年龄占比&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200809205724145-1506446428.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;POST /nba/_search
{
  &quot;query&quot;: {
    &quot;term&quot;: {
      &quot;teamNameEn&quot;: {
        &quot;value&quot;: &quot;Rockets&quot;
      }
    }
  },
  &quot;aggs&quot;: {
    &quot;pecentAge&quot;: {
      &quot;percentiles&quot;: {
        &quot;field&quot;: &quot;age&quot;
      }
    }
  },
  &quot;size&quot;: 0
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;查出火箭的球员的年龄占比（指定分位值）&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200809205838662-242426558.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;POST /nba/_search
{
  &quot;query&quot;: {
    &quot;term&quot;: {
      &quot;teamNameEn&quot;: {
        &quot;value&quot;: &quot;Rockets&quot;
      }
    }
  },
  &quot;aggs&quot;: {
    &quot;pecentAge&quot;: {
      &quot;percentiles&quot;: {
        &quot;field&quot;: &quot;age&quot;,
        &quot;percents&quot;: [
          20,
          50,
          75
        ]
      }
    }
  },
  &quot;size&quot;: 0
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;ES聚合分析是什么&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;聚合分析是数据库中重要的功能特性，完成对一个查询的数据集中数据的聚合计算，如：找出字段（或计算表达式的结果）的最大值、最小值、计算和、平均值等。ES作为搜索引擎兼容数据库，同样提供了强大的聚合分析能力&lt;/li&gt;
&lt;li&gt;对一个&lt;span&gt;&lt;strong&gt;数据集求最大、最小、和、平均值&lt;/strong&gt;&lt;/span&gt;等指标的聚合，在ES中称为&lt;span&gt;&lt;strong&gt;指标聚合&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;而关系型数据库中除了有聚合函数外，还可以对查询出的数据进行分组group by，再在组上进行游标聚合。在ES中称为&lt;span&gt;&lt;em&gt;桶聚合&lt;/em&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;Terms Aggregation根据字段项分组聚合&lt;/h2&gt;
&lt;h3&gt;火箭队根据年龄进行分组&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200809210439225-2024418892.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;POST /nba/_search
{
  &quot;query&quot;: {
    &quot;term&quot;: {
      &quot;teamNameEn&quot;: {
        &quot;value&quot;: &quot;Rockets&quot;
      }
    }
  },
  &quot;aggs&quot;: {
    &quot;aggsAge&quot;: {
      &quot;terms&quot;: {
        &quot;field&quot;: &quot;age&quot;,
        &quot;size&quot;: 10
      }
    }
  },
  &quot;size&quot;: 0
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Order分组聚合排序&lt;/h2&gt;
&lt;h3&gt;火箭队根据年龄进行分组，分组信息通过年龄从大到小排序（通过指定字段）&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200809210619184-724027637.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;POST /nba/_search
{
  &quot;query&quot;: {
    &quot;term&quot;: {
      &quot;teamNameEn&quot;: {
        &quot;value&quot;: &quot;Rockets&quot;
      }
    }
  },
  &quot;aggs&quot;: {
    &quot;aggsAge&quot;: {
      &quot;terms&quot;: {
        &quot;field&quot;: &quot;age&quot;,
        &quot;size&quot;: 10,
        &quot;order&quot;: {
          &quot;_key&quot;: &quot;desc&quot;
        }
      }
    }
  },
  &quot;size&quot;: 0
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;火箭队根据年龄进行分组，分组信息通过文档数从大到小排序（通过文档数）&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200809210748516-1811897803.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;POST /nba/_search
{
  &quot;query&quot;: {
    &quot;term&quot;: {
      &quot;teamNameEn&quot;: {
        &quot;value&quot;: &quot;Rockets&quot;
      }
    }
  },
  &quot;aggs&quot;: {
    &quot;aggsAge&quot;: {
      &quot;terms&quot;: {
        &quot;field&quot;: &quot;age&quot;,
        &quot;size&quot;: 10,
        &quot;order&quot;: {
          &quot;_count&quot;: &quot;desc&quot;
        }
      }
    }
  },
  &quot;size&quot;: 0
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;每支球队按该队所有球员的平均年龄进行分组排序（通过分组指标值）&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200809210923684-1903185006.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;POST /nba/_search
{
  &quot;query&quot;: {
    &quot;term&quot;: {
      &quot;teamNameEn&quot;: {
        &quot;value&quot;: &quot;Rockets&quot;
      }
    }
  },
  &quot;aggs&quot;: {
    &quot;avgAge&quot;: {
      &quot;avg&quot;: {
        &quot;field&quot;: &quot;age&quot;
      }
    }
  },
  &quot;size&quot;: 0
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;筛选分组聚合&lt;/h2&gt;
&lt;h3&gt;湖人和火箭队按球队平均年龄进行分组排序（指定值列表）&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200809211354903-2026559599.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;POST /nba/_search
{
  &quot;aggs&quot;: {
    &quot;aggsTeamName&quot;: {
      &quot;terms&quot;: {
        &quot;field&quot;: &quot;teamNameEn&quot;,
        &quot;include&quot;: [
          &quot;Lakers&quot;,
          &quot;Rockets&quot;,
          &quot;Warriors&quot;
        ],
        &quot;exclude&quot;: [
          &quot;Warriors&quot;
        ],
        &quot;size&quot;: 30,
        &quot;order&quot;: {
          &quot;avgAge&quot;: &quot;desc&quot;
        }
      },
      &quot;aggs&quot;: {
        &quot;avgAge&quot;: {
          &quot;avg&quot;: {
            &quot;field&quot;: &quot;age&quot;
          }
        }
      }
    }
  },
  &quot;size&quot;: 0
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;湖人和火箭队按球队平均年龄进行分组排序（正则表达式匹配值）&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200809211553702-2083045496.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;POST /nba/_search
{
  &quot;aggs&quot;: {
    &quot;aggsTeamName&quot;: {
      &quot;terms&quot;: {
        &quot;field&quot;: &quot;teamNameEn&quot;,
        &quot;include&quot;: &quot;Lakers|Ro.*|Warriors.*&quot;,
        &quot;exclude&quot;: &quot;Warriors&quot;,
        &quot;size&quot;: 30,
        &quot;order&quot;: {
          &quot;avgAge&quot;: &quot;desc&quot;
        }
      },
      &quot;aggs&quot;: {
        &quot;avgAge&quot;: {
          &quot;avg&quot;: {
            &quot;field&quot;: &quot;age&quot;
          }
        }
      }
    }
  },
  &quot;size&quot;: 0
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Range Aggregation范围分组聚合&lt;/h2&gt;
&lt;h3&gt;NBA球员年龄按20，20-35，35这样分组&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200809211848224-1134660634.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;POST /nba/_search
{
  &quot;aggs&quot;: {
    &quot;ageRange&quot;: {
      &quot;range&quot;: {
        &quot;field&quot;: &quot;age&quot;,
        &quot;ranges&quot;: [
          {
            &quot;to&quot;: 20
          },
          {
            &quot;from&quot;: 20,
            &quot;to&quot;: 35
          },
          {
            &quot;to&quot;: 35
          }
        ]
      }
    }
  },
  &quot;size&quot;: 0
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;NBA球员年龄按20，20-35，35这样分组（起别名）&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200809212001240-1826680146.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;Date Range Aggregation时间范围分组聚合&lt;/h2&gt;
&lt;h3&gt;NBA球员按出生年月分组&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200809212226848-623388666.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;POST /nba/_search
{
  &quot;aggs&quot;: {
    &quot;birthDayRange&quot;: {
      &quot;date_range&quot;: {
        &quot;field&quot;: &quot;birthDay&quot;,
        &quot;format&quot;: &quot;MM-yyy&quot;,
        &quot;ranges&quot;: [
          {
            &quot;to&quot;: &quot;01-1989&quot;
          },
          {
            &quot;from&quot;: &quot;01-1989&quot;,
            &quot;to&quot;: &quot;01-1999&quot;
          },
          {
            &quot;from&quot;: &quot;01-1999&quot;,
            &quot;to&quot;: &quot;01-2009&quot;
          },
          {
            &quot;from&quot;: &quot;01-2009&quot;
          }
        ]
      }
    }
  },
  &quot;size&quot;: 0
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Date Histogram Aggregation时间柱状图聚合&lt;/h2&gt;
&lt;h3&gt;按天、月、年等进行聚合统计。可按year(1y)，quarter(1q)，month(1M)，week(1w)，day(1d)，hour(1h)，minute(1m)，second(1s)间隔聚合&lt;/h3&gt;
&lt;h4&gt;NBA球员按出生年分组&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200809213028479-528280958.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;POST /nba/_search
{
  &quot;aggs&quot;: {
    &quot;birthday_aggs&quot;: {
      &quot;date_histogram&quot;: {
        &quot;field&quot;: &quot;birthDay&quot;,
        &quot;format&quot;: &quot;yyyy&quot;,
        &quot;interval&quot;: &quot;year&quot;
      }
    }
  },
  &quot;size&quot;: 0
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200809215134410-1469603574.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;h2&gt;简介&lt;/h2&gt;
&lt;p&gt;　　query_string查询，如果熟悉lucene的查询语法，我们可以直接用lucene查询语法写一个查询串进行查询，ES中接到请求后，通过查询解析器，解析查询串生成对应的查询。&lt;/p&gt;
&lt;h2&gt;指定单个字段查询&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200809223148605-1718570790.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;POST /nba/_search
{
  &quot;query&quot;: {
    &quot;query_string&quot;: {
      &quot;default_field&quot;: &quot;displayNameEn&quot;,
      &quot;query&quot;: &quot;james OR curry&quot;
    }
  }, 
  &quot;size&quot;: 100
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200809223250770-296691656.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;POST /nba/_search
{
  &quot;query&quot;: {
    &quot;query_string&quot;: {
      &quot;default_field&quot;: &quot;displayNameEn&quot;,
      &quot;query&quot;: &quot;james AND harden&quot;
    }
  }, 
  &quot;size&quot;: 100
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;指定多个字段查询&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200809223449266-1484554201.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;h2&gt;别名有什么用&lt;/h2&gt;
&lt;p&gt;　　在开发中，随着业务需求的迭代，较老的业务逻辑就要面临更新甚至是重构，而对于es来说，为了适应新的业务逻辑，可能就要对原有的索引做一些修改，比如对某字段做调整，甚至是重构索引。而做这些操作的时候，可能会对业务造成影响，甚至是停机调整等问题。由此，es提供了索引别名来解决这些问题。索引别名就像一个快捷方式或软连接，可以指向一个或多个索引，也可以给任意一个需要索引名的API来使用。别名的应用为程序提供了极大地灵活性。&lt;/p&gt;
&lt;h2&gt;查询别名&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;GET /nba/_alias

GET /_alias&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200809232554566-1848711376.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200809232618543-1200367559.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;h2&gt;新增别名&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200809232745066-2122500096.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;POST /_aliases
{
  &quot;actions&quot;: [
    {
      &quot;add&quot;: {
        &quot;index&quot;: &quot;nba&quot;,
        &quot;alias&quot;: &quot;nba_v1.0&quot;
      }
    }
  ]
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200809232832897-1793408238.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;删除别名&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200809232957736-1665117554.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;方式一
POST /_aliases
{
  &quot;actions&quot;: [
    {
      &quot;remove&quot;: {
        &quot;index&quot;: &quot;nba&quot;,
        &quot;alias&quot;: &quot;nba_v1.0&quot;
      }
    }
  ]
}

方式二
DELETE /nba/_alias/nba_v1.0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;重命名别名&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200809233351508-1228028649.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;POST /_aliases
{
  &quot;actions&quot;: [
    {
      &quot;remove&quot;: {
        &quot;index&quot;: &quot;nba&quot;,
        &quot;alias&quot;: &quot;nba_v1.0&quot;
      }
    },
    {
      &quot;add&quot;: {
        &quot;index&quot;: &quot;nba&quot;,
        &quot;alias&quot;: &quot;nba_v2.0&quot;
      }
    }
  ]
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;为多个索引指定一个别名&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200809233516578-198131973.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;POST /_aliases
{
  &quot;actions&quot;: [
    {
      &quot;add&quot;: {
        &quot;index&quot;: &quot;nba&quot;,
        &quot;alias&quot;: &quot;nba_v2.0&quot;
      }
    },{
      &quot;add&quot;: {
        &quot;index&quot;: &quot;cba&quot;,
        &quot;alias&quot;: &quot;cba_v2.0&quot;
      }
    }
  ]
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;为同个索引指定多个别名&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200809233612128-1231594258.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;POST /_aliases
{
  &quot;actions&quot;: [
    {
      &quot;add&quot;: {
        &quot;index&quot;: &quot;nba&quot;,
        &quot;alias&quot;: &quot;nba_v2.0&quot;
      }
    },{
      &quot;add&quot;: {
        &quot;index&quot;: &quot;nba&quot;,
        &quot;alias&quot;: &quot;cba_v2.2&quot;
      }
    }
  ]
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;通过别名读索引&lt;/h2&gt;
&lt;h3&gt;当别名指定了一个索引，则查出一个索引&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200809233759745-563557897.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;当别名指定了多个索引，则查出多个索引&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
GET /nba_v2.2
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;通过别名写索引&lt;/h2&gt;
&lt;h3&gt;当别名指定了一个索引，则可以做写的操作&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200809234120335-1705032346.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
&lt;span&gt;POST /nba_v2.0/_doc/566
{
  &quot;countryEn&quot;: &quot;Croatia&quot;,
  &quot;teamName&quot;: &quot;快船&quot;,
  &quot;birthDay&quot;: 858661200000,
  &quot;country&quot;: &quot;克罗地亚&quot;,
  &quot;teamCityEn&quot;: &quot;LA&quot;,
  &quot;code&quot;: &quot;ivica_zubac&quot;,
  &quot;displayAffiliation&quot;: &quot;Croatia&quot;,
  &quot;displayName&quot;: &quot;伊维察 祖巴茨哥哥&quot;,
  &quot;schoolType&quot;: &quot;&quot;,
  &quot;teamConference&quot;: &quot;⻄部&quot;,
  &quot;teamConferenceEn&quot;: &quot;Western&quot;,
  &quot;weight&quot;: &quot;108.9 公⽄&quot;,
  &quot;teamCity&quot;: &quot;洛杉矶&quot;,
  &quot;playYear&quot;: 3,
  &quot;jerseyNo&quot;: &quot;40&quot;,
  &quot;teamNameEn&quot;: &quot;Clippers&quot;,
  &quot;draft&quot;: 2016,
  &quot;displayNameEn&quot;: &quot;Ivica Zubac&quot;,
  &quot;heightValue&quot;: 2.16,
  &quot;birthDayStr&quot;: &quot;1997-03-18&quot;,
  &quot;position&quot;: &quot;中锋&quot;,
  &quot;age&quot;: 22,
  &quot;playerId&quot;: &quot;1627826&quot;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;当别名指定了多个索引，可以指定写某个索引&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;POST /_aliases
{
  &quot;actions&quot;: [
    {
      &quot;add&quot;: {
        &quot;index&quot;: &quot;nba&quot;,
        &quot;alias&quot;: &quot;national_player&quot;,
        &quot;is_write_index&quot;: true
      }
    },
    {
      &quot;add&quot;: {
        &quot;index&quot;: &quot;cba&quot;,
        &quot;alias&quot;: &quot;national_player&quot;
      }
    }
  ]
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
&lt;span&gt;POST /national_player/_doc/566
{
  &quot;countryEn&quot;: &quot;Croatia&quot;,
  &quot;teamName&quot;: &quot;快船&quot;,
  &quot;birthDay&quot;: 858661200000,
  &quot;country&quot;: &quot;克罗地亚&quot;,
  &quot;teamCityEn&quot;: &quot;LA&quot;,
  &quot;code&quot;: &quot;ivica_zubac&quot;,
  &quot;displayAffiliation&quot;: &quot;Croatia&quot;,
  &quot;displayName&quot;: &quot;伊维察 祖巴茨妹妹&quot;,
  &quot;schoolType&quot;: &quot;&quot;,
  &quot;teamConference&quot;: &quot;⻄部&quot;,
  &quot;teamConferenceEn&quot;: &quot;Western&quot;,
  &quot;weight&quot;: &quot;108.9 公⽄&quot;,
  &quot;teamCity&quot;: &quot;洛杉矶&quot;,
  &quot;playYear&quot;: 3,
  &quot;jerseyNo&quot;: &quot;40&quot;,
  &quot;teamNameEn&quot;: &quot;Clippers&quot;,
  &quot;draft&quot;: 2016,
  &quot;displayNameEn&quot;: &quot;Ivica Zubac&quot;,
  &quot;heightValue&quot;: 2.16,
  &quot;birthDayStr&quot;: &quot;1997-03-18&quot;,
  &quot;position&quot;: &quot;中锋&quot;,
  &quot;age&quot;: 22,
  &quot;playerId&quot;: &quot;1627826&quot;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;简介&lt;/h2&gt;
&lt;p&gt;　　ElasticSearch是一个实时的分布式搜索引擎，为用户提供搜索服务，当我们决定存储某种数据时，在创建索引的时候需要将数据结构完整确定下来，于此同时索引的设定和很多固定配置将不能修改。当需要改变数据结构时，就需要重新建立索引，为此，Elastic团队提供了很多辅助工具帮助开发人员进行重建索引&lt;/p&gt;
&lt;h2&gt;步骤&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;nba取一个别名nba_latest，nba_latest作为对外使用&lt;/li&gt;
&lt;li&gt;新增一个索引nba_20200810，结构复制于nba索引，根据业务要求修改字段&lt;/li&gt;
&lt;li&gt;将nba数据同步至nba_20200810&lt;/li&gt;
&lt;li&gt;给nba_20200810添加别名nba_latest，删除此处nba别名nba_latest&lt;/li&gt;
&lt;li&gt;删除nba索引&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200809234950341-203091707.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
&lt;span&gt;PUT /nba_20220810
{
  &quot;mappings&quot;: {
    &quot;properties&quot;: {
      &quot;age&quot;: {
        &quot;type&quot;: &quot;integer&quot;
      },
      &quot;birthDay&quot;: {
        &quot;type&quot;: &quot;date&quot;
      },
      &quot;birthDayStr&quot;: {
        &quot;type&quot;: &quot;keyword&quot;
      },
      &quot;code&quot;: {
        &quot;type&quot;: &quot;text&quot;
      },
      &quot;country&quot;: {
        &quot;type&quot;: &quot;keyword&quot;
      },
      &quot;countryEn&quot;: {
        &quot;type&quot;: &quot;keyword&quot;
      },
      &quot;displayAffiliation&quot;: {
        &quot;type&quot;: &quot;text&quot;
      },
      &quot;displayName&quot;: {
        &quot;type&quot;: &quot;text&quot;
      },
      &quot;displayNameEn&quot;: {
        &quot;type&quot;: &quot;text&quot;
      },
      &quot;draft&quot;: {
        &quot;type&quot;: &quot;long&quot;
      },
      &quot;heightValue&quot;: {
        &quot;type&quot;: &quot;float&quot;
      },
      &quot;jerseyNo&quot;: {
        &quot;type&quot;: &quot;keyword&quot;
      },
      &quot;playYear&quot;: {
        &quot;type&quot;: &quot;long&quot;
      },
      &quot;playerId&quot;: {
        &quot;type&quot;: &quot;keyword&quot;
      },
      &quot;position&quot;: {
        &quot;type&quot;: &quot;text&quot;
      },
      &quot;schoolType&quot;: {
        &quot;type&quot;: &quot;text&quot;
      },
      &quot;teamCity&quot;: {
        &quot;type&quot;: &quot;text&quot;
      },
      &quot;teamCityEn&quot;: {
        &quot;type&quot;: &quot;text&quot;
      },
      &quot;teamConference&quot;: {
        &quot;type&quot;: &quot;keyword&quot;
      },
      &quot;teamConferenceEn&quot;: {
        &quot;type&quot;: &quot;keyword&quot;
      },
      &quot;teamName&quot;: {
        &quot;type&quot;: &quot;keyword&quot;
      },
      &quot;teamNameEn&quot;: {
        &quot;type&quot;: &quot;keyword&quot;
      },
      &quot;weight&quot;: {
        &quot;type&quot;: &quot;text&quot;
      }
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;将旧索引数据copy到新索引&lt;/h3&gt;
&lt;h4&gt;同步等待，接口将会在reindex结束后返回&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200809235130171-772660654.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;POST /_reindex
{
  &quot;source&quot;: {
    &quot;index&quot;: &quot;nba&quot;
  },
  &quot;dest&quot;: {
    &quot;index&quot;: &quot;nba_20220810&quot;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;异步执行，如果reindex时间过长，建议加上“wait_for_completion=false”的参数条件，这样reindex将直接返回taskId&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;POST /_reindex?wait_for_completion=false
{
  &quot;source&quot;: {
    &quot;index&quot;: &quot;nba&quot;
  },
  &quot;dest&quot;: {
    &quot;index&quot;: &quot;nba_20220810&quot;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;替换别名&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200809235344011-569506869.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;POST /_aliases
{
  &quot;actions&quot;: [
    {
      &quot;add&quot;: {
        &quot;index&quot;: &quot;nba_20220810&quot;,
        &quot;alias&quot;: &quot;nba_latest&quot;
      }
    },
    {
      &quot;remove&quot;: {
        &quot;index&quot;: &quot;nba&quot;,
        &quot;alias&quot;: &quot;nba_latest&quot;
      }
    }
  ]
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;删除旧索引&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
DELETE /nba
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;通过别名访问新索引&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200809235451484-315656207.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;POST /nba_latest/_search
{
  &quot;query&quot;: {
    &quot;match&quot;: {
      &quot;displayNameEn&quot;: &quot;james&quot;
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;理想的搜索&lt;/h2&gt;
&lt;p&gt;　　新的数据一添加到索引中立马就能搜索到，但是真实情况不是这样的&lt;/p&gt;
&lt;p&gt;我们使用链式命令请求，先添加一个文档，再立刻搜索&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;curl -X PUT 192.168.199.170:9200/star/_doc/888 -H 'Content-Type:
application/json' -d '{ &quot;displayName&quot;: &quot;蔡徐坤&quot; }'
curl -X GET localhost:9200/star/_doc/_search?pretty&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;强制刷新&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;curl -X PUT 192.168.199.170:9200/star/_doc/666?refresh -H 'Content-Type:
application/json' -d '{ &quot;displayName&quot;: &quot;杨超越&quot; }'
curl -X GET localhost:9200/star/_doc/_search?pretty&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修改默认更新时间（默认时间是1s）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;PUT /star/_settings
{
  &quot;index&quot;: {
    &quot;refresh_interval&quot;: &quot;5s&quot;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将refresh关闭&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;PUT /star/_settings
{
  &quot;index&quot;: {
    &quot;refresh_interval&quot;: &quot;-1&quot;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;　　如果&lt;span&gt;&lt;strong&gt;返回的结果集中&lt;/strong&gt;&lt;/span&gt;很多&lt;span&gt;&lt;strong&gt;符合条件&lt;/strong&gt;&lt;/span&gt;的结果，那&lt;span&gt;&lt;strong&gt;怎么能一眼就能看到我们想要的那个结果呢&lt;/strong&gt;&lt;/span&gt;？比如下面网站所示的那样，我们搜索“科比”，在结果集中，将所有“科比”高亮显示？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200810001155235-797207731.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;高亮查询&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200810001257836-1765935835.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;POST /nba_latest/_search
{
  &quot;query&quot;: {
    &quot;match&quot;: {
      &quot;displayNameEn&quot;: &quot;james&quot;
    }
  },
  &quot;highlight&quot;: {
    &quot;fields&quot;: {
      &quot;displayNameEn&quot;: {}
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;自定义高亮查询&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;POST /nba_latest/_search
{
  &quot;query&quot;: {
    &quot;match&quot;: {
      &quot;displayNameEn&quot;: &quot;james&quot;
    }
  },
  &quot;highlight&quot;: {
    &quot;fields&quot;: {
      &quot;displayNameEn&quot;: {
        &quot;pre_tags&quot;: [
          &quot;&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;
        ],
        &quot;post_tags&quot;: [
          &quot;&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;
        ]
      }
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;查询建议是什么&lt;/h2&gt;
&lt;p&gt;　　查询建议：是为了给用户提供更好的搜索体验。包括：词条检查，自动补全&lt;/p&gt;
&lt;h2&gt;词条检查&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200810001609379-627439629.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;自动补全&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200810001641260-2010858317.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;Suggester&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Term suggester&lt;/li&gt;
&lt;li&gt;Phrase suggester&lt;/li&gt;
&lt;li&gt;Completion suggester&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;字段&lt;/h2&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;5.5&quot;&gt;&lt;tr&gt;&lt;td&gt;text&lt;/td&gt;
&lt;td&gt;指定搜索文本&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;field&lt;/td&gt;
&lt;td&gt;获取建议词的搜索字段&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;analyzer&lt;/td&gt;
&lt;td&gt;指定分词器&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;size&lt;/td&gt;
&lt;td&gt;每个词返回的最大建议词数&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;sort&lt;/td&gt;
&lt;td readability=&quot;9&quot;&gt;
&lt;p&gt;如何对建议词进行排序，可用选项：&lt;/p&gt;
&lt;p&gt;score：先按评分排序、再按文档频率排、term顺序&lt;/p&gt;
&lt;p&gt;frequency：先按文档频率排，再按评分，term顺序排&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8&quot;&gt;&lt;td&gt;suggest_mode&lt;/td&gt;
&lt;td readability=&quot;11&quot;&gt;
&lt;p&gt;建议模式，控制提供建议词的方式：&lt;/p&gt;
&lt;p&gt;missing：仅在搜索的词项在索引中不存在时才提供建议词，默认值；&lt;/p&gt;
&lt;p&gt;popular：仅建议文档频率比搜索词项高的词&lt;/p&gt;
&lt;p&gt;always：总是提供匹配的建议词&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2&gt;Term Suggester&lt;/h2&gt;
&lt;p&gt;　　term词条建议器，对给输入的文本进行分词，为每个分词提供词项建议&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;POST /nba_latest/_search
{
  &quot;suggest&quot;: {
    &quot;my-suggestion&quot;: {
      &quot;text&quot;: &quot;jamse hardne&quot;,
      &quot;term&quot;: {
        &quot;suggest_mode&quot;: &quot;missing&quot;,
        &quot;field&quot;: &quot;displayNameEn&quot;
      }
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Phrase suggester&lt;/h2&gt;
&lt;p&gt;　　phrase短语建议，在term的基础上，会考量多个term之间的关系，比如是否同时出现在索引的原文里，相邻成都，以及词频等&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;POST /nba_latest/_search
{
  &quot;suggest&quot;: {
    &quot;my-suggestion&quot;: {
      &quot;text&quot;: &quot;jamse harden&quot;,
      &quot;phrase&quot;: {
        &quot;field&quot;: &quot;displayNameEn&quot;
      }
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Completion suggester&lt;/h2&gt;
&lt;p&gt;　　Completion完成建议&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;POST /nba_latest/_search
{
  &quot;suggest&quot;: {
    &quot;my-suggestion&quot;: {
      &quot;text&quot;: &quot;Miam&quot;,
      &quot;completion&quot;: {
        &quot;field&quot;: &quot;teamCityEn&quot;
      }
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sun, 09 Aug 2020 16:47:00 +0000</pubDate>
<dc:creator>陈彦斌</dc:creator>
<og:description>学前导读 ElasticSearch对电脑配置要求较高，内存至少4G以上，空闲2G内存，线程数4018+ 学习的时候，推荐将ElasticSearch安装到Linux或者mac上，极度不推荐装Wind</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chenyanbin/p/13419497.html</dc:identifier>
</item>
<item>
<title>技术人怎么“打通”产品业务？ - 九卷</title>
<link>http://www.cnblogs.com/jiujuan/p/13467196.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jiujuan/p/13467196.html</guid>
<description>&lt;h2 id=&quot;一体三面&quot;&gt;一体三面&lt;/h2&gt;
&lt;p&gt;一体：一个目标。做出有价值的产品。&lt;br/&gt;三面：技术、产品、业务。&lt;/p&gt;
&lt;p&gt;业务、产品、技术是做出有价值产品这个一体目标的三个不同方面。所以我们都有着一个共同的目标：做出有价值的产品。我们并不是对立的，我们是有着共同目标。&lt;/p&gt;
&lt;p&gt;打一个不是很恰当的比喻，就像一个人，脑袋，身体，手，脚，一起结合后，相互配合，才能最大体现人的价值。不然单个的存在，都不能很好体现出整体人的价值出来。缺一个，就相当于一位残障人士，做起事来很不方便，会磕磕碰碰。&lt;/p&gt;
&lt;p&gt;技术，业务，产品要相互信任，相互支持，相互理解，才能做出一个有价值的产品出来。&lt;br/&gt;业务不要把技术当作开发资源，大家都是为了一个共同的目标，业务进展或业务结果要带给技术同学做事情的成就感，也需要技术同学理解业务的初衷和价值。&lt;/p&gt;
&lt;p&gt;有时候看到网上一些段子，技术开发同学的桌子上放把“刀”，用来“砍”产品需求的同学。虽然是段子，但是往往还能让技术同学产生共鸣，说明还是有很多这种情况存在。但是这种对立情绪的存在，非常不利于开发和产品同学之间的工作配合与协调。一定要纠正这种错误的认知，我们是一个共同体，有着同一个目标，只不过分工不同。技术和产品一定要多沟通，技术要把自己的困难点，技术风险点，讲给产品同学听；产品同学也要把业务需求会产生什么价值，为什么要这么做讲给技术同学听，大家坦诚沟通交流，共同想办法解决困难。&lt;/p&gt;
&lt;h2 id=&quot;技术、产品、业务的错位&quot;&gt;技术、产品、业务的错位&lt;/h2&gt;
&lt;p&gt;技术、产品、业务沟通时为什么会错位？&lt;/p&gt;
&lt;p&gt;技术人一般想的是什么？&lt;br/&gt;这个需求用技术要怎么实现？要怎么设计才合理？技术人关注的是用技术怎么实现需求，关注技术细节，关注技术设计，关注实现功能。等等&lt;/p&gt;
&lt;p&gt;产品人一般想的是什么？&lt;br/&gt;这个需求怎么来的？哪些用户会用这个功能？要怎么设计产品功能？怎么设计用户操作流程？为什么要做这个功能？能给公司带来什么价值？等等&lt;/p&gt;
&lt;p&gt;业务人想的是什么？&lt;br/&gt;业务怎么来的？业务的市场在哪里？业务的用户在哪里？这个业务有什么价值？业务怎么赚钱？等等&lt;/p&gt;
&lt;p&gt;通过上面的分析，可以看出，技术、产品、业务的同学，大家平常想的都不在同一个维度上，思考的角度不同，或者说做的事情不在一个维度上，都是做各自职责范围内的事情，这就导致了技术、产品和业务沟通时，大家容易不在一个频道上，容易造成鸡同鸭讲的局面。&lt;/p&gt;
&lt;p&gt;这也是分工导致的一个弊端。哪怎么办？&lt;/p&gt;
&lt;h2 id=&quot;沟通对齐&quot;&gt;沟通对齐&lt;/h2&gt;
&lt;p&gt;沟通要怎么对齐呢？上面的分析可以看出，因为分工导致大家只关注本职工作内的事情。为了大家沟通能够对齐，也就是在沟通时大家能在同一个频道上，必须要打破这个只关注各自领域内事情的藩篱，要关注对方所关心的事情。&lt;/p&gt;
&lt;p&gt;讲讲技术人怎么办？答：去了解业务。&lt;/p&gt;
&lt;h3 id=&quot;技术人了解业务&quot;&gt;技术人了解业务&lt;/h3&gt;
&lt;p&gt;按照产品产生的先后顺序来说，是先有业务，后才有技术实现业务需求，进而形成产品。&lt;/p&gt;
&lt;p&gt;怎么了解业务呢？&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;多向业务人员请教学习：听听他们怎么理解业务，怎么分析业务？&lt;/li&gt;
&lt;li&gt;了解公司业务：公司有哪些业务？是干什么的？能说的清楚吗？&lt;/li&gt;
&lt;li&gt;了解业务流程：公司的业务流程，你能讲清楚吗？流程图能画出来吗？&lt;/li&gt;
&lt;li&gt;了解公司产品：公司有哪些产品？都是干什么的？每个产品有哪些功能？产品服务的用户都有哪些？等等&lt;/li&gt;
&lt;li&gt;看书：可以看一些关于公司业务的书籍来了解公司业务情况。&lt;/li&gt;
&lt;li&gt;了解竞争对手：公司的产品有哪些竞品？竞品公司是什么样的公司？等等&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;当然并不是每一个技术人都要了解这些。但是如果你是技术领导，你就有必要去了解这些情况，因为领导需要把产品需求分配给下面开发人员来进行开发，你必须要能分辨这些需求，哪些是合理，哪些不合理，哪些重要，哪些次要，从而定出开发需求的优先级，给开发需求排出开发时间。&lt;/p&gt;
&lt;p&gt;做技术的也不要排斥了解业务，程序员不要给自己设限，认为自己就是程序员，而是要努力的去做一个复合型人才，做T型人才。&lt;/p&gt;
&lt;h3 id=&quot;产品人了解技术&quot;&gt;产品人了解技术&lt;/h3&gt;
&lt;p&gt;做产品的要了解技术的哪些情况呢?&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;技术的风险点&lt;br/&gt;有时候面临时间压力，开发用的临时方案，上线之后就是永久方案了，那么这就是一个技术债。如果后面不还债的话，改动面临的风险可能会越来越大，耗费资源也比较多。&lt;/li&gt;
&lt;li&gt;了解技术开发的难易&lt;br/&gt;不是今天产品说要实现一个需求，明天就要技术上线。如果是改动小牵连模块少，那开发时间可以很短；如果改动牵连的模块很多，那么就要谨慎，开发时间就可能较长；如果开发的技术比较难，那么上线时间也会叫较长；&lt;/li&gt;
&lt;li&gt;了解开发的流程&lt;br/&gt;从需求分析，技术分析，技术设计和架构，编码，测试，修bug，上线测试，联调上线，检验 等一般开发流程，产品人需要了解。开发流程不止一个简单的开发编码一项而已。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;另外，产品同学一定要思考需求的价值，要有自己独立的思考，不要盲目的提出需求。不要上线没几天，就重新修改需求，这种就属于没思考明白的需求，要尽量杜绝这种需求。我们容许试错，但不容许草率的犯错。这种也是造成技术和产品之间总是对立的原因。&lt;/p&gt;
&lt;h3 id=&quot;参与需求讨论&quot;&gt;参与需求讨论&lt;/h3&gt;
&lt;p&gt;为了让技术同学（leader）能真正理解需求，鼓励他们参与需求讨论，了解需求生成的过程，了解需求是怎么产生的，直接和业务对话。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;技术人与产品业务都是有一个共同的目标，打造一个有价值的产品。他们并不是对立的。&lt;br/&gt;技术人不要给自己设限，不要只在自己技术圈里，要勇敢出圈，了解圈子外的其他相关事情。&lt;br/&gt;努力做一个复合型人才，T型人才，甚至π型人才。&lt;/p&gt;
</description>
<pubDate>Sun, 09 Aug 2020 15:54:00 +0000</pubDate>
<dc:creator>九卷</dc:creator>
<og:description>一体三面 一体：一个目标。做出有价值的产品。 三面：技术、产品、业务。 业务、产品、技术是做出有价值产品这个一体目标的三个不同方面。所以我们都有着一个共同的目标：做出有价值的产品。我们并不是对立的，我</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jiujuan/p/13467196.html</dc:identifier>
</item>
<item>
<title>go微服务系列(二) - 服务注册/服务发现 - 宝树呐</title>
<link>http://www.cnblogs.com/baoshu/p/13467149.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/baoshu/p/13467149.html</guid>
<description>&lt;h2 id=&quot;11-代码演示&quot;&gt;1.1 代码演示&lt;/h2&gt;
&lt;p&gt;还是跟上一篇:&lt;a href=&quot;https://www.cnblogs.com/baoshu/p/13461191.html&quot;&gt;go微服务(一) - go micro入门&lt;/a&gt;一样使用&lt;code&gt;consul&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;package main

import (
        &quot;net/http&quot;

        &quot;github.com/gin-gonic/gin&quot;
        &quot;github.com/micro/go-micro/registry&quot;
        &quot;github.com/micro/go-micro/web&quot;
        &quot;github.com/micro/go-plugins/registry/consul&quot;
)

func main() {
    // 1.添加consul地址
        cr := consul.NewRegistry(
                registry.Addrs(&quot;127.0.0.1:8500&quot;))
    
    // 2.使用gin作为router
        router := gin.Default()
        router.GET(&quot;/user&quot;, func(c *gin.Context) {
                c.String(http.StatusOK, &quot;user api&quot;)
        })
    
    // 3.初始化go micro
        server := web.NewService(
                web.Name(&quot;productService&quot;),                          // 当前微服务服务名
                web.Registry(cr),                                    // 注册到consul
                web.Address(&quot;:8081&quot;),                                // 端口
                web.Metadata(map[string]string{&quot;protocol&quot;: &quot;http&quot;}), // 元信息
                web.Handler(router)) // 路由

        _ = server.Run()
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;12-在go-run的时候传入服务注册的参数&quot;&gt;1.2 在go run的时候传入服务注册的参数&lt;/h2&gt;
&lt;p&gt;上面为了演示简便，直接将服务注册的&lt;code&gt;服务名&lt;/code&gt;和&lt;code&gt;端口&lt;/code&gt;等写死在代码里，但是实际运用场景不可能这么写，所以我们一般会&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;把这部分定义在配置文件里&lt;/li&gt;
&lt;li&gt;使用go micro提供的功能，可以在&lt;code&gt;go run&lt;/code&gt;的时候传入参数&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面演示下&lt;strong&gt;如何在&lt;code&gt;go run&lt;/code&gt;的时候传入参数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一步&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在原来的服务注册的基础代码上添加&lt;code&gt;server.Init()&lt;/code&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;加上这个就会解析cli命令中的参数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1ghkf5n2nfrj30lz0hntb1.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如下导航到源码看下具体的实现，就是添加了&lt;code&gt;Init()&lt;/code&gt;方法之后，会将我们传入的cli命令的特定参数，进行注册，&lt;strong&gt;优先级高于代码定义的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1ghkf9fcck4j30nm0piad8.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二步&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里选择改变下服务注册的端口，即在main包路径下执行以下命令，且开两个tab执行两次&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt; # tab1
 go run productService_main.go --server_address :8088
 # tab2
 go run productService_main.go --server_address :8089
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如下运行成功：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1ghkfbizmo8j30pp08umy3.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1ghkfegmohyj30pv091t9u.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后去consul界面查看，两个实例都注册成功：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1ghkffc7po6j30zf0dggnf.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;h2 id=&quot;21-均衡负载算法&quot;&gt;2.1 均衡负载算法&lt;/h2&gt;
&lt;p&gt;go-micro的服务发现的算法由&lt;code&gt;github.com/micro/go-micro/client/selector&lt;/code&gt;下的&lt;code&gt;selector&lt;/code&gt;提供，目前提供了两种算法&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;RoundRobin(轮询算法)&lt;/li&gt;
&lt;li&gt;Random(随机算法)&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;22-服务发现均衡负载的演示&quot;&gt;2.2 服务发现均衡负载的演示&lt;/h2&gt;
&lt;p&gt;使用上一节的方式，&lt;strong&gt;服务注册部分&lt;/strong&gt;，同时启动了以下三个端口的&lt;code&gt;productService&lt;/code&gt;服务&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;8088&lt;/li&gt;
&lt;li&gt;8089&lt;/li&gt;
&lt;li&gt;8090&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;然后在&lt;strong&gt;服务发现部分&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用&lt;code&gt;selector.Random&lt;/code&gt;来随机发现服务&lt;/li&gt;
&lt;li&gt;使用for循环来持续获取&lt;/li&gt;
&lt;li&gt;打印出当前获取到的服务实例的端口&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;func main() {
          // 1.连接到consul
        cr := consul.NewRegistry(registry.Addrs(&quot;127.0.0.1:8500&quot;))

        //  使用for循环持续获取
        for {
                // 2.根据service name获取对应的微服务列表
                services, err := cr.GetService(&quot;productService&quot;)
                if err != nil {
                        log.Fatal(&quot;cannot get service list&quot;)
                }

                // 3.使用random随机获取其中一个实例
                next := selector.Random(services)
                svc, err := next()
                if err != nil {
                        log.Fatal(&quot;cannot get service&quot;)
                }

                fmt.Println(&quot;[测试输出]:&quot;, svc.Address)
                time.Sleep(time.Second * 1)
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以输出的实例端口可以看如下，随机获取到三个端口中的任意一个&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1ghkfxe1xfsj30el08tt9l.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这时候吧&lt;code&gt;8090&lt;/code&gt;端口的服务给关掉，再看下输出，就不会有&lt;code&gt;8090&lt;/code&gt;端口的实例了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1ghkg83jv06j30ei0900tk.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 09 Aug 2020 15:43:00 +0000</pubDate>
<dc:creator>宝树呐</dc:creator>
<og:description>1. 服务注册 1.1 代码演示 还是跟上一篇:go微服务(一) - go micro入门一样使用consul package main import ( &amp;amp;quot;net/http&amp;amp</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/baoshu/p/13467149.html</dc:identifier>
</item>
</channel>
</rss>