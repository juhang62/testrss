<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>kubernetes对象之Volume - 周国通</title>
<link>http://www.cnblogs.com/tylerzhou/p/11001617.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tylerzhou/p/11001617.html</guid>
<description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/tylerzhou/p/10969041.html&quot;&gt;系列目录&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;概述&quot;&gt;概述&lt;/h2&gt;
&lt;p&gt;Volume是对各种存储资源的抽象、虚拟化。为管理、控制、使用存储资源提供统一接口。Openstack中的volume为虚拟机提供存储，Docker中的volume为容器提供存储。因为在kubernetes中可部署运行最小单位是pod ,所以kubernetes的volume为pod提供存储。当然在部署pod时可以不为其提供volume，pod中的容器使用所在节点的硬盘，能同时读写数据的地方称为可读写层。这种存储是容器级的临时存储，不是pod级。其生命周期与容器相同，如果容器crash后被重启，也就是旧容器被删除而新容器启动，则旧容器的可读写层与容器一起被删除，其上数据丢失。同理如果pod在节点之间迁移调度，容器的可读写层并不会迁移调度。因此，kubernetes需要提供pod级volume，本文中的volume特指kubernetes。&lt;/p&gt;
&lt;p&gt;Volume类型&lt;br/&gt;Volume是抽象概念，有很多种具体实现，每种实现各具目的、特点、特性。差不多什么东西都可以当成volume，类型如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;awsElasticBlockStore&lt;/li&gt;
&lt;li&gt;azureDisk&lt;/li&gt;
&lt;li&gt;azureFile&lt;/li&gt;
&lt;li&gt;cephfs&lt;/li&gt;
&lt;li&gt;configMap&lt;/li&gt;
&lt;li&gt;csi&lt;/li&gt;
&lt;li&gt;downwardAPI&lt;/li&gt;
&lt;li&gt;emptyDir&lt;/li&gt;
&lt;li&gt;fc (fibre channel)&lt;/li&gt;
&lt;li&gt;flocker&lt;/li&gt;
&lt;li&gt;gcePersistentDisk&lt;/li&gt;
&lt;li&gt;gitRepo (deprecated)&lt;/li&gt;
&lt;li&gt;glusterfs&lt;/li&gt;
&lt;li&gt;hostPath&lt;/li&gt;
&lt;li&gt;iscsi&lt;/li&gt;
&lt;li&gt;local&lt;/li&gt;
&lt;li&gt;nfs&lt;/li&gt;
&lt;li&gt;persistentVolumeClaim&lt;/li&gt;
&lt;li&gt;projected&lt;/li&gt;
&lt;li&gt;portworxVolume&lt;/li&gt;
&lt;li&gt;quobyte&lt;/li&gt;
&lt;li&gt;rbd&lt;/li&gt;
&lt;li&gt;scaleIO&lt;/li&gt;
&lt;li&gt;secret&lt;/li&gt;
&lt;li&gt;storageos&lt;/li&gt;
&lt;li&gt;vsphereVolume&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里不对以上所有类型一一介绍,只对目前可能会用到的本地磁盘存储和分布式存储做简单介绍说明&lt;/p&gt;
&lt;h2 id=&quot;常见存储类型说明及示例&quot;&gt;常见存储类型说明及示例&lt;/h2&gt;
&lt;h3 id=&quot;cephfs&quot;&gt;&lt;strong&gt;cephfs&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;cephfs是一款优秀、流行的云环境存储解决方案，原因是它开源、高可用、弹性伸缩，对操作系统、硬件无特殊要求，用户很容易搭建，使用它的节点也无特别要求。它具备awsElasticBlockStore陈述之所有特点，并且单个voluem可以被多个节点同时使用。用户首先搭建自己的cephfs环境，然后配置kubernetes集群与其对接，最后在pod中使用其提供的volume，详细参考&lt;a href=&quot;https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;configmap&quot;&gt;&lt;strong&gt;configMap&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;用户首先创建configＭap并创建数据保存其中，此时数据保存在kubernetes的etcd数据库中，volume还不存在。当用户在pod中引用创建的configMap时，系统首先在节点上创建volume并将数据保存其中，这个volume占用的是节占的存储空间。此后就可以像使用普通volume一样使用它。&lt;/p&gt;
&lt;p&gt;configMap是kubernetes中的一种对象类型，核心本质是以volume的方式将单独管理的配置信息传递给pod中的容器，并非用来存储持久化数据。详细参考&lt;a href=&quot;https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;downwardapi&quot;&gt;&lt;strong&gt;downwardAPI&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;与configＭap类似，以volume的方式向pod中的容器传递信息。configMap中的信息由用户在创建对象时传递，而downwardAPI的信息就来自pod对象本身，downwardAPI不需要创建，它是pod Spec中的一个字段，内容指向pod对象本身的其它字段，如pod的metadata、image等信息。在创建pod时系统首先将指向的字段提取出来，然后创建volume并保存提取出来的字段并挂载，容器就可以读取这些字段了。&lt;/p&gt;
&lt;p&gt;downwardAPI的目的是为将pod本身的字段信息如label、annotation等传递给容器的一种手段。详细参考&lt;a href=&quot;https://kubernetes.io/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information/&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;emptydir&quot;&gt;&lt;strong&gt;emptyDir&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;在节点上运行pod实例时才会创建emptyDir volume。它首先是节点上的一个空目录，pod中的任何容器都可以用volume的形式挂载使用它。如果容器因为某种原因被删除并重新启动，创建的emptyDir不会删除也不会被清空。当pod实例离开节点调度到其它节点或因为缩容被删除时，emptyDir被删除，相当于pod还在但数据丢了。示例：&lt;/p&gt;
&lt;pre class=&quot;yml&quot;&gt;
&lt;code&gt;apiVersion: v1
kind: Pod
metadata:
  name: test-pd
spec:
  containers:
  - image: k8s.gcr.io/test-webserver
    name: test-container
    volumeMounts:
    - mountPath: /cache
      name: cache-volume
  volumes:
  - name: cache-volume
    emptyDir: {}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;glusterfs&quot;&gt;&lt;strong&gt;glusterfs&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;与cephfs一样，流行的云环境下的存储解决方案，详细参考&lt;a href=&quot;http://www.gluster.org/&quot;&gt;这里&lt;/a&gt;，示例参考&lt;a href=&quot;https://github.com/kubernetes/examples/tree/master/staging/volumes/glusterfs&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;hostpath&quot;&gt;&lt;strong&gt;hostPath&lt;/strong&gt;&lt;/h3&gt;
&lt;pre class=&quot;yml&quot;&gt;
&lt;code&gt;apiVersion: v1
kind: Pod
metadata:
  name: test-pd
spec:
  containers:
  - image: k8s.gcr.io/test-webserver
    name: test-container
    volumeMounts:
    - mountPath: /test-pd
      name: test-volume
  volumes:
  - name: test-volume
    hostPath:
      # directory location on host
      path: /data
      # this field is optional
      type: Directory&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;iscsi&quot;&gt;&lt;strong&gt;iscsi&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;互联网小型计算机系统接口，其特点是便宜。示例参考&lt;a href=&quot;https://github.com/kubernetes/examples/tree/master/staging/volumes/iscsi&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;local&quot;&gt;&lt;strong&gt;local&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;与emptyDir相似，它也占用节点的存储空间。不同点是它是kubernetes中的一种对象类型，用户可以像管理普通对象一样管理它。emptyDir在pod实例开时运行时分配，当pod离节点时删除。local类型的volume则由用户创建，系统在合适的节点上为其分配资源，调度到这个节点上的pod可以挂载它，pod离开时它也不会消失，除非用户删除。示例：&lt;/p&gt;
&lt;pre class=&quot;yml&quot;&gt;
&lt;code&gt;apiVersion: v1
kind: PersistentVolume
metadata:
  name: example-pv
spec:
  capacity:
    storage: 100Gi
  # volumeMode field requires BlockVolume Alpha feature gate to be enabled.
  volumeMode: Filesystem
  accessModes:
  - ReadWriteOnce
  persistentVolumeReclaimPolicy: Delete
  storageClassName: local-storage
  local:
    path: /mnt/disks/ssd1
  nodeAffinity:
    required:
      nodeSelectorTerms:
      - matchExpressions:
        - key: kubernetes.io/hostname
          operator: In
          values:
          - example-node&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;nfs&quot;&gt;&lt;strong&gt;nfs&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;nfs&lt;br/&gt;网络文件系统，详细参考&lt;a href=&quot;https://kubernetes.io/docs/concepts/storage/persistent-volumes/&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;persistentvolumeclaim&quot;&gt;&lt;strong&gt;persistentVolumeClaim&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;与flocker相似，用来屏蔽不同云环境，详细参考&lt;a href=&quot;https://kubernetes.io/docs/concepts/storage/persistent-volumes/&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;projected&quot;&gt;&lt;strong&gt;projected&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;如果一个容器需要挂开多个已经存在的volume比如Secret、ConfigMap、DownwardAPI等，原本每个这种类型的volume需要各自占用一个挂载目录，而projected能将它们整合在一起，并只挂开到一个目录下，示例：&lt;/p&gt;
&lt;pre class=&quot;yml&quot;&gt;
&lt;code&gt;apiVersion: v1
kind: Pod
metadata:
  name: volume-test
spec:
  containers:
  - name: container-test
    image: busybox
    volumeMounts:
    - name: all-in-one
      mountPath: &quot;/projected-volume&quot;
      readOnly: true
  volumes:
  - name: all-in-one
    projected:
      sources:
      - secret:
          name: mysecret
          items:
            - key: username
              path: my-group/my-username
      - downwardAPI:
          items:
            - path: &quot;labels&quot;
              fieldRef:
                fieldPath: metadata.labels
            - path: &quot;cpu_limit&quot;
              resourceFieldRef:
                containerName: container-test
                resource: limits.cpu
      - configMap:
          name: myconfigmap
          items:
            - key: config
              path: my-group/my-config&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 11 Jun 2019 00:19:00 +0000</pubDate>
<dc:creator>周国通</dc:creator>
<og:description>'系列目录' 概述 Volume是对各种存储资源的抽象、虚拟化。为管理、控制、使用存储资源提供统一接口。Openstack中的volume为虚拟机提供存储，Docker中的volume为容器提供存储。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tylerzhou/p/11001617.html</dc:identifier>
</item>
<item>
<title>死磕 java同步系列之ReentrantLock VS synchronized——结果可能跟你想的不一样 - 彤哥读源码</title>
<link>http://www.cnblogs.com/tong-yuan/p/11001615.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tong-yuan/p/11001615.html</guid>
<description>&lt;h2 id=&quot;问题&quot;&gt;问题&lt;/h2&gt;
&lt;p&gt;（1）ReentrantLock有哪些优点？&lt;/p&gt;
&lt;p&gt;（2）ReentrantLock有哪些缺点？&lt;/p&gt;
&lt;p&gt;（3）ReentrantLock是否可以完全替代synchronized？&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;synchronized是Java原生提供的用于在多线程环境中保证同步的关键字，底层是通过修改对象头中的MarkWord来实现的。&lt;/p&gt;
&lt;p&gt;ReentrantLock是Java语言层面提供的用于在多线程环境中保证同步的类，底层是通过原子更新状态变量state来实现的。&lt;/p&gt;
&lt;p&gt;既然有了synchronized的关键字来保证同步了，为什么还要实现一个ReentrantLock类呢？它们之间有什么异同呢？&lt;/p&gt;
&lt;h2 id=&quot;reentrantlock-vs-synchronized&quot;&gt;ReentrantLock VS synchronized&lt;/h2&gt;
&lt;p&gt;直接上表格：（手机横屏查看更方便）&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;14.5&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;可重入&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;非公平&lt;/td&gt;
&lt;td&gt;支持（默认）&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;加锁/解锁方式&lt;/td&gt;
&lt;td&gt;需要手动加锁、解锁，一般使用try..finally..保证锁能够释放&lt;/td&gt;
&lt;td&gt;手动加锁，无需刻意解锁&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;按key锁&lt;/td&gt;
&lt;td&gt;不支持，比如按用户id加锁&lt;/td&gt;
&lt;td&gt;支持，synchronized加锁时需要传入一个对象&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;公平锁&lt;/td&gt;
&lt;td&gt;支持，new ReentrantLock(true)&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;中断&lt;/td&gt;
&lt;td&gt;支持，lockInterruptibly()&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;尝试加锁&lt;/td&gt;
&lt;td&gt;支持，tryLock()&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;超时锁&lt;/td&gt;
&lt;td&gt;支持，tryLock(timeout, unit)&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;获取当前线程获取锁的次数&lt;/td&gt;
&lt;td&gt;支持，getHoldCount()&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;获取等待的线程&lt;/td&gt;
&lt;td&gt;支持，getWaitingThreads()&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;检测是否被当前线程占有&lt;/td&gt;
&lt;td&gt;支持，isHeldByCurrentThread()&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;检测是否被任意线程占有&lt;/td&gt;
&lt;td&gt;支持，isLocked()&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;条件锁&lt;/td&gt;
&lt;td&gt;可支持多个条件，condition.await()，condition.signal()，condition.signalAll()&lt;/td&gt;
&lt;td&gt;只支持一个，obj.wait()，obj.notify()，obj.notifyAll()&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;对比测试&quot;&gt;对比测试&lt;/h2&gt;
&lt;p&gt;在测试之前，我们先预想一下结果，随着线程数的不断增加，ReentrantLock（fair）、ReentrantLock（unfair）、synchronized三者的效率怎样呢？&lt;/p&gt;
&lt;p&gt;我猜测应该是ReentrantLock（unfair）&amp;gt; synchronized &amp;gt; ReentrantLock（fair）。&lt;/p&gt;
&lt;p&gt;到底是不是这样呢？&lt;/p&gt;
&lt;p&gt;直接上测试代码：（为了全面对比，彤哥这里把AtomicInteger和LongAdder也拿来一起对比了）&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ReentrantLockVsSynchronizedTest {
    public static AtomicInteger a = new AtomicInteger(0);
    public static LongAdder b = new LongAdder();
    public static int c = 0;
    public static int d = 0;
    public static int e = 0;

    public static final ReentrantLock fairLock = new ReentrantLock(true);
    public static final ReentrantLock unfairLock = new ReentrantLock();


    public static void main(String[] args) throws InterruptedException {
        System.out.println(&quot;-------------------------------------&quot;);
        testAll(1, 100000);
        System.out.println(&quot;-------------------------------------&quot;);
        testAll(2, 100000);
        System.out.println(&quot;-------------------------------------&quot;);
        testAll(4, 100000);
        System.out.println(&quot;-------------------------------------&quot;);
        testAll(6, 100000);
        System.out.println(&quot;-------------------------------------&quot;);
        testAll(8, 100000);
        System.out.println(&quot;-------------------------------------&quot;);
        testAll(10, 100000);
        System.out.println(&quot;-------------------------------------&quot;);
        testAll(50, 100000);
        System.out.println(&quot;-------------------------------------&quot;);
        testAll(100, 100000);
        System.out.println(&quot;-------------------------------------&quot;);
        testAll(200, 100000);
        System.out.println(&quot;-------------------------------------&quot;);
        testAll(500, 100000);
        System.out.println(&quot;-------------------------------------&quot;);
//        testAll(1000, 1000000);
        System.out.println(&quot;-------------------------------------&quot;);
        testAll(500, 10000);
        System.out.println(&quot;-------------------------------------&quot;);
        testAll(500, 1000);
        System.out.println(&quot;-------------------------------------&quot;);
        testAll(500, 100);
        System.out.println(&quot;-------------------------------------&quot;);
        testAll(500, 10);
        System.out.println(&quot;-------------------------------------&quot;);
        testAll(500, 1);
        System.out.println(&quot;-------------------------------------&quot;);
    }

    public static void testAll(int threadCount, int loopCount) throws InterruptedException {
        testAtomicInteger(threadCount, loopCount);
        testLongAdder(threadCount, loopCount);
        testSynchronized(threadCount, loopCount);
        testReentrantLockUnfair(threadCount, loopCount);
//        testReentrantLockFair(threadCount, loopCount);
    }

    public static void testAtomicInteger(int threadCount, int loopCount) throws InterruptedException {
        long start = System.currentTimeMillis();

        CountDownLatch countDownLatch = new CountDownLatch(threadCount);
        for (int i = 0; i &amp;lt; threadCount; i++) {
            new Thread(() -&amp;gt; {
                for (int j = 0; j &amp;lt; loopCount; j++) {
                    a.incrementAndGet();
                }
                countDownLatch.countDown();
            }).start();
        }

        countDownLatch.await();

        System.out.println(&quot;testAtomicInteger: result=&quot; + a.get() + &quot;, threadCount=&quot; + threadCount + &quot;, loopCount=&quot; + loopCount + &quot;, elapse=&quot; + (System.currentTimeMillis() - start));
    }

    public static void testLongAdder(int threadCount, int loopCount) throws InterruptedException {
        long start = System.currentTimeMillis();

        CountDownLatch countDownLatch = new CountDownLatch(threadCount);
        for (int i = 0; i &amp;lt; threadCount; i++) {
            new Thread(() -&amp;gt; {
                for (int j = 0; j &amp;lt; loopCount; j++) {
                    b.increment();
                }
                countDownLatch.countDown();
            }).start();
        }

        countDownLatch.await();

        System.out.println(&quot;testLongAdder: result=&quot; + b.sum() + &quot;, threadCount=&quot; + threadCount + &quot;, loopCount=&quot; + loopCount + &quot;, elapse=&quot; + (System.currentTimeMillis() - start));
    }

    public static void testReentrantLockFair(int threadCount, int loopCount) throws InterruptedException {
        long start = System.currentTimeMillis();

        CountDownLatch countDownLatch = new CountDownLatch(threadCount);
        for (int i = 0; i &amp;lt; threadCount; i++) {
            new Thread(() -&amp;gt; {
                for (int j = 0; j &amp;lt; loopCount; j++) {
                    fairLock.lock();
                    // 消除try的性能影响
//                    try {
                        c++;
//                    } finally {
                        fairLock.unlock();
//                    }
                }
                countDownLatch.countDown();
            }).start();
        }

        countDownLatch.await();

        System.out.println(&quot;testReentrantLockFair: result=&quot; + c + &quot;, threadCount=&quot; + threadCount + &quot;, loopCount=&quot; + loopCount + &quot;, elapse=&quot; + (System.currentTimeMillis() - start));
    }

    public static void testReentrantLockUnfair(int threadCount, int loopCount) throws InterruptedException {
        long start = System.currentTimeMillis();

        CountDownLatch countDownLatch = new CountDownLatch(threadCount);
        for (int i = 0; i &amp;lt; threadCount; i++) {
            new Thread(() -&amp;gt; {
                for (int j = 0; j &amp;lt; loopCount; j++) {
                    unfairLock.lock();
                    // 消除try的性能影响
//                    try {
                        d++;
//                    } finally {
                        unfairLock.unlock();
//                    }
                }
                countDownLatch.countDown();
            }).start();
        }

        countDownLatch.await();

        System.out.println(&quot;testReentrantLockUnfair: result=&quot; + d + &quot;, threadCount=&quot; + threadCount + &quot;, loopCount=&quot; + loopCount + &quot;, elapse=&quot; + (System.currentTimeMillis() - start));
    }

    public static void testSynchronized(int threadCount, int loopCount) throws InterruptedException {
        long start = System.currentTimeMillis();

        CountDownLatch countDownLatch = new CountDownLatch(threadCount);
        for (int i = 0; i &amp;lt; threadCount; i++) {
            new Thread(() -&amp;gt; {
                for (int j = 0; j &amp;lt; loopCount; j++) {
                    synchronized (ReentrantLockVsSynchronizedTest.class) {
                        e++;
                    }
                }
                countDownLatch.countDown();
            }).start();
        }

        countDownLatch.await();

        System.out.println(&quot;testSynchronized: result=&quot; + e + &quot;, threadCount=&quot; + threadCount + &quot;, loopCount=&quot; + loopCount + &quot;, elapse=&quot; + (System.currentTimeMillis() - start));
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行这段代码，你会发现结果大大出乎意料，真的是不测不知道，一测吓一跳，运行后发现以下规律：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;随着线程数的不断增加，synchronized的效率竟然比ReentrantLock非公平模式要高！&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;彤哥的电脑上大概是高3倍左右，我的运行环境是4核8G，java版本是8，请大家一定要在自己电脑上运行一下，并且最好能给我反馈一下。&lt;/p&gt;
&lt;p&gt;彤哥又使用Java7及以下的版本运行了，发现在Java7及以下版本中synchronized的效率确实比ReentrantLock的效率低一些。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;（1）synchronized是Java原生关键字锁；&lt;/p&gt;
&lt;p&gt;（2）ReentrantLock是Java语言层面提供的锁；&lt;/p&gt;
&lt;p&gt;（3）ReentrantLock的功能非常丰富，解决了很多synchronized的局限性；&lt;/p&gt;
&lt;p&gt;（4）至于在非公平模式下，ReentrantLock与synchronized的效率孰高孰低，彤哥给出的结论是随着Java版本的不断升级，synchronized的效率只会越来越高；&lt;/p&gt;
&lt;h2 id=&quot;彩蛋&quot;&gt;彩蛋&lt;/h2&gt;
&lt;p&gt;既然ReentrantLock的功能更丰富，而且效率也不低，我们是不是可以放弃使用synchronized了呢？&lt;/p&gt;
&lt;p&gt;答：我认为不是。因为synchronized是Java原生支持的，随着Java版本的不断升级，Java团队也是在不断优化synchronized，所以我认为在功能相同的前提下，最好还是使用原生的synchronized关键字来加锁，这样我们就能获得Java版本升级带来的免费的性能提升的空间。&lt;/p&gt;
&lt;p&gt;另外，在Java8的ConcurrentHashMap中已经把ReentrantLock换成了synchronized来分段加锁了，这也是Java版本不断升级带来的免费的synchronized的性能提升。&lt;/p&gt;
&lt;h2 id=&quot;推荐阅读&quot;&gt;推荐阅读&lt;/h2&gt;
&lt;ol readability=&quot;0.081018518518519&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/iipAVWynBUZazhSvBwMB5g&quot;&gt;死磕 java同步系列之ReentrantLock源码解析（二）——条件锁&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/52Ib23kbmqqkWAZtlZF-zA&quot;&gt;死磕 java同步系列之ReentrantLock源码解析（一）——公平锁、非公平锁&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/nAqgec8GscULz6DkkYFINg&quot;&gt;死磕 java同步系列之AQS起篇&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/1RU5jh7UcXGtKlae8tusVA&quot;&gt;死磕 java同步系列之自己动手写一个锁Lock&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/0s-u-MysppIaIHVrshp9fA&quot;&gt;死磕 java魔法类之Unsafe解析&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/jownTN--npu3o8B4c3sbeA&quot;&gt;死磕 java同步系列之JMM（Java Memory Model）&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/TROZ4BhcDImwHvhAl_I_6w&quot;&gt;死磕 java同步系列之volatile解析&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/RT7VreIh9PU03HhE3WSLjg&quot;&gt;死磕 java同步系列之synchronized解析&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;&lt;p&gt;欢迎关注我的公众号“彤哥读源码”，查看更多源码系列文章, 与彤哥一起畅游源码的海洋。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/alan-tang-tt/yuan/raw/master/%E6%AD%BB%E7%A3%95%20java%E9%9B%86%E5%90%88%E7%B3%BB%E5%88%97/resource/qrcode_ss.jpg&quot; alt=&quot;qrcode&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 11 Jun 2019 00:18:00 +0000</pubDate>
<dc:creator>彤哥读源码</dc:creator>
<og:description>ReentrantLock有哪些优点？ ReentrantLock有哪些缺点？ ReentrantLock是否可以完全替代synchronized？</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tong-yuan/p/11001615.html</dc:identifier>
</item>
<item>
<title>Python自动抢红包，超详细教程，再也不会错过微信红包了！ - 上海小胖</title>
<link>http://www.cnblogs.com/moonhmily/p/11001513.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/moonhmily/p/11001513.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190611064754177.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTIzNjU4Mjg=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;目录：&lt;br/&gt;0 引言&lt;br/&gt;1 环境&lt;br/&gt;2 需求分析&lt;br/&gt;3 前置准备&lt;br/&gt;4 抢红包流程回顾&lt;br/&gt;5 代码梳理&lt;br/&gt;6 后记&lt;/p&gt;

&lt;p&gt;提到抢红包，就不得不提Xposed框架，它简直是个抢红包的神器，但使用Xposed框架有一个前提条件：手机需要root，对于苹果手机的话就需要越狱了。现在的手机想要root或越狱并不容易，同时这会对手机安全性带来一些风险，抢红包本身只是个娱乐活动，这样做就得不偿失了。&lt;/p&gt;
&lt;p&gt;为了自动抢红包，python能帮我们实现吗？&lt;/p&gt;
&lt;p&gt;答案是肯定的，本文就带大家一起探索下用Python如何实现自动抢红包。&lt;/p&gt;

&lt;p&gt;操作系统：Windows&lt;/p&gt;
&lt;p&gt;Python版本：3.7.2&lt;/p&gt;
&lt;p&gt;手机系统：Android&lt;/p&gt;

&lt;p&gt;这里我们的需求是实现自动抢红包。首先要打开微信，进入到指定的群聊，识别微信红包、执行抢红包的动作。这就是关键的步骤，简单清晰。&lt;/p&gt;
&lt;p&gt;因为电脑版本的微信没有抢红包的功能，我们只能手机微信，那么就需要把手机连上电脑，通过电脑控制手机来自动抢，那就需要确保「adb」命令可正常执行。&lt;/p&gt;
&lt;p&gt;识别微信中的消息，是红包还是普通的信息，这里我们通过聊天消息的元素标识来判断。这里我们借助了「Airtest IDE」工具来实现。&lt;/p&gt;

&lt;h2 id=&quot;打开手机的usb调试&quot;&gt;3.1 打开手机的USB调试&lt;/h2&gt;
&lt;p&gt;要正常使用「adb」需要打开USB调试，设置项通常出现在手机系统设置中的[开发人员选项]里面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190611064842160.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTIzNjU4Mjg=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在手机上打开USB调试后，接下来我们通过Airttest IDE验证 adb 运行是否正常。&lt;/p&gt;
&lt;h2 id=&quot;下载安装airtest-ide&quot;&gt;3.2 下载安装Airtest IDE&lt;/h2&gt;
&lt;p&gt;开始之前先，先解释下airttest相关概念：&lt;/p&gt;
&lt;p&gt;Airtest 是一个跨平台的、基于图像识别的UI自动化测试框架，适用于游戏和App，支持平台有Windows、Android和iOS。&lt;/p&gt;
&lt;p&gt;Poco是一款基于UI控件识别的自动化测试框架，目前支持Unity3D/cocos2dx-*/Android原生app/iOS原生app/微信小程序，也可以在其他引擎中自行接入poco-sdk来使用。&lt;/p&gt;
&lt;p&gt;AirtestIDE 是一个我们配套推出的跨平台的UI自动化测试编辑器，内置了Airtest和Poco的相关插件功能，能够使用它快速简单地编写脚本。&lt;/p&gt;
&lt;p&gt;Airtest IDE 的下载地址：&lt;a href=&quot;http://airtest.netease.com/&quot; class=&quot;uri&quot;&gt;http://airtest.netease.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下载之后，解压打开就可以使用，Airtest IDE的界面如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190611064859699.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTIzNjU4Mjg=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用AirtestIDE对Android应用进行自动化操作，第一步就需要连接Android设备。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;请使用USB线连接手机，手机上出现的 允许USB调试 弹窗，点击 确定。&lt;/li&gt;
&lt;li&gt;点击连接面板中的 refresh ADB 按钮，设备列表将会刷新。&lt;/li&gt;
&lt;li&gt;点击列表内对应设备的 Connect 完成连接。&lt;/li&gt;
&lt;li&gt;若设备未刷出，点击 refresh ADB 按钮。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2019061106493013.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTIzNjU4Mjg=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;若连接遇到问题，请参考Airtest的官方教程：Android真机连接&lt;/p&gt;

&lt;p&gt;打开微信，在最左侧的Tab页，微信消息列表，我们需要从这里选择指定的群聊来抢红包。&lt;/p&gt;
&lt;p&gt;在AirtestIDE中，我们可以通过暂停功能，冻结当前的UI树形结构来精确地检视UI控件，我们先来分析下这个页面中元素标识。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190611064954139.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTIzNjU4Mjg=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;▲聊天页面中整体的群聊消息的元素标识 com.tencent.mm:id/d1v&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190611065004461.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTIzNjU4Mjg=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;▲聊天页面中单个群聊消息的元素标识 com.tencent.mm:id/b6e&lt;/p&gt;
&lt;p&gt;接下来进入我们准备要抢红包的群聊中，识别出红包并执行抢红包的动作。&lt;/p&gt;
&lt;p&gt;我们先来看看红包的标识：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190611065020806.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTIzNjU4Mjg=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;▲红包标识的示例1 com.tencent.mm:id/aql&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190611065032340.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTIzNjU4Mjg=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;▲红包标识的示例2 com.tencent.mm:id/aql&lt;/p&gt;
&lt;p&gt;点击红包，记录下弹出的大红包页面中“开”的元素标识&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190611065048615.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTIzNjU4Mjg=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;▲大红包页面中”开“的标识 com.tencent.mm:id/d02&lt;/p&gt;
&lt;p&gt;这里我们需要判断是红包是否有效，比如已被领完或是已被自己领取的红包就是无效的，我们在执行时可以跳过这些。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190611065059749.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTIzNjU4Mjg=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;▲已领取红包的标识 com.tencent.mm:id/apk&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190611065107331.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTIzNjU4Mjg=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;▲已被领完红包的标识 com.tencent.mm:id/apk&lt;/p&gt;
&lt;p&gt;我们用的各元素的标识都已取到，接下来就是组织我们的代码。&lt;/p&gt;

&lt;p&gt;首先得打开微信，利用Airtest启动app应用，只须一行代码即可搞定，如下&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 打开手机微信
poco(text='微信').click()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;获取当前页面中所有所有群聊的名称&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 群聊消息的元素标识
Chat_msg = poco(name='com.tencent.mm:id/d1v').offspring('com.tencent.mm:id/b6e')
# 获取当前页面中所有群聊的名称
Chat_names = []
Chat_names = list(map(lambda x: x.get_text(), Chat_msg))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;选择并进入指定的群聊&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 指定抢红包的群聊名称
chat = input('请指定群聊名称:')
if chat in Chat_names:
    index = Chat_names.index(chat)
    # 点击进入指定的群聊
    Chat_msg[index].click()
在微信聊天页面中，获取当前页面中的所有消息元素。

msg_list = poco(&quot;android.widget.ListView&quot;).children()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;遍历消息并查找红包&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;for msg in msg_list:
    # 微信红包的标识
    LuckyMoney = msg.offspring('com.tencent.mm:id/aql')
    # 已失效红包（比如已领取、已被领完）的标识
    Invalid = msg.offspring('com.tencent.mm:id/aqk')

    # 判断红包是否有效并抢起来！
    if LuckyMoney:
        pass&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在LuckyMoney中定义抢红包的动作&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;if Invalid.exists() and (Invalid.get_text()=='已领取' or Invalid.get_text()=='已被领完'):
    print(f'红包已无效，跳过……')
    continue
else:
    print(f'发现一个新红包，抢起来！')
    poco(&quot;com.tencent.mm:id/d1v&quot;)
    msg.click()

    click_open = poco(&quot;com.tencent.mm:id/d02&quot;)
    if click_open.exists():
        click_open.click()
    keyevent('BACK')&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;若我们在一台电脑上并不想安装Airtest IDE，还能执行这个脚本吗？&lt;/p&gt;
&lt;p&gt;当然可以，只需要安装好「pocoui」这个第三方库就可以“抛弃”它了！&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pip install pocoui&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;利用 AirtestIDE 创建一个项目时，设备类型选中 Android，就会在编码区生成一段初始化的代码。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from airtest.core.api import *
auto_setup(__file__)

from poco.drivers.android.uiautomation import AndroidUiautomationPoco
poco = AndroidUiautomationPoco(use_airtest_input=True, screenshot_each_action=False)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们自己编写的Python代码中也需要加上这段初始化的代码。&lt;/p&gt;
&lt;p&gt;再次强调，在执行脚本时要确保手机连上电脑，并确保「adb」命令正常运行。&lt;/p&gt;
&lt;p&gt;对Airtest有兴趣的小伙伴，可以参考airtest官方教程：AirtestIDE官方文档&lt;/p&gt;
&lt;p&gt;关注公众号「&lt;strong&gt;Python专栏&lt;/strong&gt;」，后台回复：&lt;strong&gt;python抢红包&lt;/strong&gt;，获取本文所涉及的完整代码&lt;/p&gt;
</description>
<pubDate>Mon, 10 Jun 2019 22:54:00 +0000</pubDate>
<dc:creator>上海小胖</dc:creator>
<og:description>提到抢红包，就不得不提Xposed框架，它简直是个抢红包的神器，但使用Xposed框架有一个前提条件：手机需要root，对于苹果手机的话就需要越狱了。现在的手机想要root或越狱并不容易，同时这会对手</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/moonhmily/p/11001513.html</dc:identifier>
</item>
<item>
<title>【好书推荐】《剑指Offer》之硬技能（编程题7~11） - OKevin</title>
<link>http://www.cnblogs.com/yulinfeng/p/11001305.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yulinfeng/p/11001305.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;em&gt;本文例子完整源码地址：&lt;a href=&quot;https://github.com/yu-linfeng/BlogRepositories/tree/master/repositories/sword&quot; target=&quot;_blank&quot;&gt;https://github.com/yu-linfeng/BlogRepositories/tree/master/repositories/sword&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/yulinfeng/p/10946815.html&quot; target=&quot;_blank&quot;&gt;《【好书推荐】《剑指Offer》之软技能》&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/yulinfeng/p/10953039.html&quot; target=&quot;_blank&quot;&gt;《【好书推荐】《剑指Offer》之硬技能（编程题1~6）》&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;持续更新，敬请关注公众号:coderbuff，回复关键字“sword”获取相关电子书。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 dir=&quot;ltr&quot;&gt;7.重建二叉树&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;span id=&quot;docs-internal-guid-848dbb65-7fff-513c-747a-0f487ed32036&quot;&gt;题目：输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。例如：输入前序遍历序列{1, 2, 4, 7, 3, 5, 6, 8}和中序遍历序列{4, 7, 2, 1, 5, 3, 8, 6}。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p dir=&quot;ltr&quot;&gt;　　定义二叉树节点&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;* 二叉树节点
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;* &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; OKevin
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;* @date 2019/5/30
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Node&amp;lt;T&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;    &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    * 左孩子
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Node left;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;    &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    * 右孩子
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Node right;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;    &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    * 值域
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; T data;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Node() {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Node(T data) {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;        &lt;span&gt;this&lt;/span&gt;.data =&lt;span&gt; data;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;省略getter/setter方法&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span id=&quot;docs-internal-guid-4eba9c81-7fff-eb81-3c6f-13abd4262753&quot;&gt;解法一：递归&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;* 根据前序遍历序列和中序遍历序列重建二叉树
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;* &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; OKevin
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;* @date 2019/5/30
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Solution {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;    &lt;span&gt;public&lt;/span&gt; Node&amp;lt;Integer&amp;gt;&lt;span&gt; buildBinaryTree(Integer[] preorder, Integer[] inorder) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;        &lt;span&gt;if&lt;/span&gt; (preorder.length == 0 || inorder.length == 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;       }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;        Node&amp;lt;Integer&amp;gt; root = &lt;span&gt;new&lt;/span&gt; Node&amp;lt;&amp;gt;(preorder[0&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;        &lt;span&gt;int&lt;/span&gt; index = search(0&lt;span&gt;, inorder, root.getData());
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;        root.setLeft(buildBinaryTree(Arrays.copyOfRange(preorder, 1, index + 1), Arrays.copyOfRange(inorder, 0&lt;span&gt;, index)));
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;        root.setRight(buildBinaryTree(Arrays.copyOfRange(preorder, index + 1, preorder.length), Arrays.copyOfRange(inorder, index + 1&lt;span&gt;, inorder.length)));
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; root;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;    &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    * 在中序遍历的序列中查询根节点所在的位置
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; start 开始查找的下标
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; inorder 中序遍历序列
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; rootData 根节点值
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 节点值在中序遍历序列中的下标位置
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; search(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; start, Integer[] inorder, Integer rootData) {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;        &lt;span&gt;for&lt;/span&gt; (; start &amp;lt; inorder.length; start++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (rootData.equals(inorder[start])) {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                &lt;span&gt;return&lt;/span&gt;&lt;span&gt; start;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;           }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;       }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;        &lt;span&gt;return&lt;/span&gt; -1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p dir=&quot;ltr&quot;&gt;二叉树的遍历一共分为：前序遍历、中序遍历和后序遍历&lt;/p&gt;
&lt;p dir=&quot;ltr&quot;&gt;前序遍历遍历顺序为：根节点-&amp;gt;左节点-&amp;gt;右节点&lt;/p&gt;
&lt;p dir=&quot;ltr&quot;&gt;中序遍历遍历顺序为：左节点-&amp;gt;根节点-&amp;gt;右节点&lt;/p&gt;
&lt;p dir=&quot;ltr&quot;&gt;后序遍历遍历顺序为：左节点-&amp;gt;右节点-&amp;gt;根节点&lt;/p&gt;
&lt;p dir=&quot;ltr&quot;&gt;例如二叉树：&lt;/p&gt;
&lt;p dir=&quot;ltr&quot;&gt;           1&lt;/p&gt;
&lt;p dir=&quot;ltr&quot;&gt;        /     \&lt;/p&gt;
&lt;p dir=&quot;ltr&quot;&gt;      2       3&lt;/p&gt;
&lt;p dir=&quot;ltr&quot;&gt;     /       /   \&lt;/p&gt;
&lt;p dir=&quot;ltr&quot;&gt;    4    5     6&lt;/p&gt;
&lt;p dir=&quot;ltr&quot;&gt;      \        /&lt;/p&gt;
&lt;p dir=&quot;ltr&quot;&gt;       7   8 &lt;/p&gt;
&lt;p dir=&quot;ltr&quot;&gt;前序遍历结果为：1、2、4、7、3、5、6、8&lt;/p&gt;
&lt;p dir=&quot;ltr&quot;&gt;中序遍历结果为：4、7、2、1、5、3、8、6&lt;/p&gt;
&lt;p dir=&quot;ltr&quot;&gt;后序遍历结果为：7、4、2、5、8、6、3、1&lt;/p&gt;
&lt;p dir=&quot;ltr&quot;&gt;此题给出前序和中序的遍历结果，要求重建二叉树。从前序遍历结果得知，第一个节点一定是根节点。从中序遍历结果可知，根节点左侧一定是其左子树右侧一定是其右子树。&lt;/p&gt;
&lt;p dir=&quot;ltr&quot;&gt;那么可以得到：&lt;/p&gt;
&lt;p dir=&quot;ltr&quot;&gt;第一次：&lt;/p&gt;
&lt;p dir=&quot;ltr&quot;&gt;根据前序遍历结果得知，1为根节点，根据中序遍历结果得知，4、7、2为左子树，5、3、8、6为右子树。&lt;/p&gt;
&lt;p dir=&quot;ltr&quot;&gt;第二次：&lt;/p&gt;
&lt;p dir=&quot;ltr&quot;&gt;根据前序遍历结果得知，2为节点，根据中序遍历，4、7位节点2的左子树，节点2没有右子树。&lt;/p&gt;
&lt;p dir=&quot;ltr&quot;&gt;第三次：&lt;/p&gt;
&lt;p dir=&quot;ltr&quot;&gt;根据前序遍历结果得知，4为节点，根据中序遍历，7为节点4的右子树，节点4没有左子树。&lt;/p&gt;
&lt;p dir=&quot;ltr&quot;&gt;以此类推，根据递归即可构建一颗二叉树。&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;docs-internal-guid-0777aec5-7fff-4afa-688f-b18822cfa0e1&quot;&gt;　　测试程序&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;*          1
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;*         / \
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;*        2   3
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;*       /   / \
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;*      4   5   6
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;*       \     /
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;*        7   8
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;* &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; OKevin
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;* @date 2019/5/30
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Main {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;        Integer[] preorder = &lt;span&gt;new&lt;/span&gt; Integer[]{1, 2, 4, 7, 3, 5, 6, 8&lt;span&gt;};
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;        Integer[] inorder = &lt;span&gt;new&lt;/span&gt; Integer[]{4, 7, 2, 1, 5, 3, 8, 6&lt;span&gt;};
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;        Solution solution = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Solution();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;        Node&amp;lt;Integer&amp;gt; node =&lt;span&gt; solution.buildBinaryTree(preorder, inorder);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span id=&quot;docs-internal-guid-7070d706-7fff-d3a0-3255-f72f8143f3b5&quot;&gt;8.二叉树的下一个节点&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;span id=&quot;docs-internal-guid-f120d13b-7fff-43b7-2e08-e594d36908ec&quot;&gt;题目：给定一颗二叉树和其中的一个节点，如何找出中序遍历序列的下一个节点？节点中除了两个分别指向左、右子节点的指针，还有一个指向父节点的指针。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;docs-internal-guid-763a2aa6-7fff-da0d-1634-90883991dbdc&quot;&gt;分析：熟悉二叉树中序遍历的特点。查找节点的下一个节点，一共有两种情况：一、节点有右子树，节点的下一个节点即为右子树的最左子节点；二、节点没有右子树，此时又要分为两种情况：1、如果节点位于父节点的左节点，节点的下一个节点即为父节点；2、如果节点位于父节点的右节点，此时向上遍历，找到它是父节点的左节点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span id=&quot;docs-internal-guid-be0c556e-7fff-fac8-96d4-cf6b68fc1650&quot;&gt;节点定义&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;* 二叉树节点定义
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;* &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; OKevin
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;* @date 2019/6/3
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Node&amp;lt;T&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;    &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    * 值域
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; T data;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;    &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    * 左节点
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;    &lt;span&gt;private&lt;/span&gt; Node&amp;lt;T&amp;gt;&lt;span&gt; left;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;    &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    * 右节点
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;    &lt;span&gt;private&lt;/span&gt; Node&amp;lt;T&amp;gt;&lt;span&gt; right;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;    &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    * 父节点
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;    &lt;span&gt;private&lt;/span&gt; Node&amp;lt;T&amp;gt;&lt;span&gt; parent;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Node() {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt;    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Node(T data) {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;        &lt;span&gt;this&lt;/span&gt;.data =&lt;span&gt; data;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;省略getter/setter方法&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p dir=&quot;ltr&quot;&gt;中序遍历情况下，查找二叉树节点的下一个节点&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;* 中序遍历情况下，查找节点的下一个节点
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;* &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; OKevin
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;* @date 2019/6/3
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Solution {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;    &lt;span&gt;public&lt;/span&gt; Node getNextNode(Node&amp;lt;Integer&amp;gt;&lt;span&gt; head) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;        &lt;span&gt;if&lt;/span&gt; (head == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;       }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;        Node&amp;lt;Integer&amp;gt; p =&lt;span&gt; head;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;第一种情况，节点有右子树。节点右子树的最左子节点即为节点中序遍历的下一个节点&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;        &lt;span&gt;if&lt;/span&gt; (p.getRight() != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;            p =&lt;span&gt; p.getRight();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;            &lt;span&gt;while&lt;/span&gt; (p.getLeft() != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                p =&lt;span&gt; p.getLeft();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;           }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; p;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;       }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;第二种情况，节点没有右子树。仍然有两种情况：一、节点位于父节点的左节点，此时父节点即为节点中序遍历的下一个节点；二、节点位于父节点的右节点，此时一直向上查找，直到是它父节点的左节点&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;        &lt;span&gt;while&lt;/span&gt; (p.getParent() != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;            &lt;span&gt;if&lt;/span&gt; (p ==&lt;span&gt; p.getParent().getLeft()) {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                &lt;span&gt;return&lt;/span&gt;&lt;span&gt; p.getParent();
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;           }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;            p =&lt;span&gt; p.getParent();
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;       }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p dir=&quot;ltr&quot;&gt;　　测试程序 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('e342a22a-a06e-4f14-8f14-d1b2760c1d65')&quot; readability=&quot;36&quot;&gt;&lt;img id=&quot;code_img_closed_e342a22a-a06e-4f14-8f14-d1b2760c1d65&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_e342a22a-a06e-4f14-8f14-d1b2760c1d65&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('e342a22a-a06e-4f14-8f14-d1b2760c1d65',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_e342a22a-a06e-4f14-8f14-d1b2760c1d65&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;*          1
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;*         / \
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;*        2   3
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;*       /   / \
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;*      4   5  6
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;*       \    /
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;*        7  8
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;* 中序遍历序列：4,7,2,1,5,3,8,6
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;* &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; OKevin
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;* @date 2019/6/3
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Main {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;        Node&amp;lt;Integer&amp;gt; node1 = &lt;span&gt;new&lt;/span&gt; Node&amp;lt;&amp;gt;(1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;        Node&amp;lt;Integer&amp;gt; node2 = &lt;span&gt;new&lt;/span&gt; Node&amp;lt;&amp;gt;(2&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;        Node&amp;lt;Integer&amp;gt; node3 = &lt;span&gt;new&lt;/span&gt; Node&amp;lt;&amp;gt;(3&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;        Node&amp;lt;Integer&amp;gt; node4 = &lt;span&gt;new&lt;/span&gt; Node&amp;lt;&amp;gt;(4&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;        Node&amp;lt;Integer&amp;gt; node5 = &lt;span&gt;new&lt;/span&gt; Node&amp;lt;&amp;gt;(5&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;        Node&amp;lt;Integer&amp;gt; node6 = &lt;span&gt;new&lt;/span&gt; Node&amp;lt;&amp;gt;(6&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;        Node&amp;lt;Integer&amp;gt; node7 = &lt;span&gt;new&lt;/span&gt; Node&amp;lt;&amp;gt;(7&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;        Node&amp;lt;Integer&amp;gt; node8 = &lt;span&gt;new&lt;/span&gt; Node&amp;lt;&amp;gt;(8&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;       node1.setLeft(node2);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;       node1.setRight(node3);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;       node2.setLeft(node4);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;       node2.setParent(node1);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;       node3.setLeft(node5);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;       node3.setRight(node6);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;       node3.setParent(node1);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;       node4.setRight(node7);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;       node4.setParent(node2);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;       node5.setParent(node3);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;       node6.setLeft(node8);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;       node6.setParent(node3);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;       node7.setParent(node4);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;       node8.setParent(node6);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;        Solution solution = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Solution();
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;       System.out.println(solution.getNextNode(node6).getData());
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span id=&quot;docs-internal-guid-7b4617dd-7fff-00d3-08a8-d4e5f60c016d&quot;&gt;9.用两个栈实现队列&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;span id=&quot;docs-internal-guid-d0a5e1b1-7fff-2a40-21d7-9304619697f2&quot;&gt;题目：用两个栈实现一个队列。&lt;/span&gt;&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;docs-internal-guid-35b11c8c-7fff-444e-58fb-7c58644051b0&quot;&gt;分析：栈的结构是FILO（先进后出），队列的结构是FIFO（先进先出）。栈s1用于存储元素，栈s2当执行删除队列尾元素时，从s1弹出数据进入s2，再弹出s2，即实现一个队列。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;* 两个栈实现一个队列
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;* &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; OKevin
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;* @date 2019/6/3
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MyQueue&amp;lt;T&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;    &lt;span&gt;private&lt;/span&gt; Stack&amp;lt;T&amp;gt; s1 = &lt;span&gt;new&lt;/span&gt; Stack&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;    &lt;span&gt;private&lt;/span&gt; Stack&amp;lt;T&amp;gt; s2 = &lt;span&gt;new&lt;/span&gt; Stack&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;    &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    * 从队尾添加元素
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; t 元素
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 添加的数据
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; T appendTail(T t) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;       s1.push(t);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; t;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;    &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    * 对队头删除元素
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 删除的元素
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; T deleteTail() {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;        &lt;span&gt;if&lt;/span&gt; (s1.empty() &amp;amp;&amp;amp;&lt;span&gt; s2.empty()) {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;       }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (s2.empty()) {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;            &lt;span&gt;while&lt;/span&gt; (!&lt;span&gt;s1.empty()) {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;               s2.push(s1.pop());
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;           }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;       }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;        T t =&lt;span&gt; s2.pop();
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; t;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span id=&quot;docs-internal-guid-8faacc89-7fff-9626-820e-d75546a3f553&quot;&gt;10.斐波那契数列&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;span id=&quot;docs-internal-guid-7070d706-7fff-d3a0-3255-f72f8143f3b5&quot;&gt;&lt;span id=&quot;docs-internal-guid-8d82fb41-7fff-11bc-7100-060b580b7901&quot;&gt;题目：求斐波那契数列的第n项。&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;docs-internal-guid-54d75763-7fff-559a-072b-aa685a64d665&quot;&gt;　　解法一：递归&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;* 求斐波那契数列的第n项
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;* &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; OKevin
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;* @date 2019/6/3
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Solution1 {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer fibonacci(Integer n) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;        &lt;span&gt;if&lt;/span&gt; (n.equals(0&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;            &lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;       }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;        &lt;span&gt;if&lt;/span&gt; (n.equals(1&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;            &lt;span&gt;return&lt;/span&gt; 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;       }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;        &lt;span&gt;return&lt;/span&gt; fibonacci(n - 1) + fibonacci(n - 2&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p dir=&quot;ltr&quot;&gt;优点：简单易懂&lt;/p&gt;
&lt;p dir=&quot;ltr&quot;&gt;缺点：如果递归调用太深，容易导致栈溢出。并且节点有重复计算，导致效率不高。&lt;/p&gt;
&lt;p&gt;　　解法二：循环&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;* 求斐波那契数列的第n项
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;* &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; OKevin
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;* @date 2019/6/3
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Solution2 {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer fibonacci(Integer n) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;        &lt;span&gt;if&lt;/span&gt; (n.equals(0&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;            &lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;       }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;        &lt;span&gt;if&lt;/span&gt; (n.equals(1&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;            &lt;span&gt;return&lt;/span&gt; 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;       }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;        Integer first = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;        Integer second = 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;        Integer result = first +&lt;span&gt; second;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 2; i &amp;lt;= n; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;            result = first +&lt;span&gt; second;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;            first =&lt;span&gt; second;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;            second =&lt;span&gt; result;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;       }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span id=&quot;docs-internal-guid-3c56b729-7fff-fec5-9495-468c1c1d3585&quot;&gt;通过循环计算斐波那契数列能避免重复计算，且不存在调用栈过深的问题。&lt;/span&gt;&lt;/p&gt;
&lt;h3 dir=&quot;ltr&quot;&gt;11. 旋转数组的最小数字&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;span id=&quot;docs-internal-guid-ad61043c-7fff-428e-93e5-a322683cdab9&quot;&gt;题目：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增的数组的一个旋转，输出旋转数组的最小元素。例如，数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p dir=&quot;ltr&quot;&gt;*题中本意是希望能找到数组中的最小数字，直接暴力解法遍历即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;span id=&quot;docs-internal-guid-cbb0a06b-7fff-7d9e-981f-a645dc696198&quot;&gt;引子：通过“二分查找”算法查找有序数组中的数字。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p dir=&quot;ltr&quot;&gt;　　二分查找有序数组是否存在数字&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;* 二分查找有序数组中的数字
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;* &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; OKevin
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;* @date 2019/6/3
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BinarySearch {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; find(Integer[] array, Integer target) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;        Integer start = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;        Integer end = array.length - 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; partition(array, start, end, target);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; partition(Integer[] array, Integer start, Integer end, Integer target) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;        &lt;span&gt;if&lt;/span&gt; (target &amp;lt; array[start] || target &amp;gt; array[end] || start &amp;gt;&lt;span&gt; end) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;       }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;        &lt;span&gt;int&lt;/span&gt; middle = (end + start) / 2&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;        &lt;span&gt;if&lt;/span&gt; (target &amp;gt;&lt;span&gt; array[middle]) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;            &lt;span&gt;return&lt;/span&gt; partition(array, middle + 1&lt;span&gt;, end, target);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;        } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (target &amp;lt;&lt;span&gt; array[middle]) {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;            &lt;span&gt;return&lt;/span&gt; partition(array, start, middle - 1&lt;span&gt;, target);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;        } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;       }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p dir=&quot;ltr&quot;&gt;利用二分法思想查找旋转数组中的最小数字，注意当出现原始数组为：{0,1,1,1,1}时，{1,1,1,0,1}和{1,0,1,1,1}均是旋转数组，这两种情况left=middle=right都是1，不能区别，此时只能按照顺序查找的方式。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;* 找到旋转数组中的最小值
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;* &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; OKevin
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;* @date 2019/6/3
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Solution {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer find(Integer[] array) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;        &lt;span&gt;if&lt;/span&gt; (array.length == 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;            &lt;span&gt;return&lt;/span&gt; -1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;       }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;        &lt;span&gt;int&lt;/span&gt; left = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;        &lt;span&gt;int&lt;/span&gt; right = array.length - 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;        &lt;span&gt;int&lt;/span&gt; middle = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;        &lt;span&gt;while&lt;/span&gt; (array[left] &amp;gt;=&lt;span&gt; array[right]) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;            &lt;span&gt;if&lt;/span&gt; (right - left == 1&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                middle =&lt;span&gt; right;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;           }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;            middle = (left + right) / 2&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;            &lt;span&gt;if&lt;/span&gt; (array[left].equals(array[right]) &amp;amp;&amp;amp;&lt;span&gt; array[left].equals(array[middle])) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                &lt;span&gt;return&lt;/span&gt;&lt;span&gt; min(array, left, right);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;           }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;            &lt;span&gt;if&lt;/span&gt; (array[middle] &amp;gt;=&lt;span&gt; array[left]) {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                left =&lt;span&gt; middle;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;            } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                right =&lt;span&gt; middle;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;           }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;       }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; array[middle];
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt;    &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt; &lt;span&gt;    * 当出现原始数组为：{0,1,1,1,1}时，{1,1,1,0,1}和{1,0,1,1,1}均是旋转数组，这两种情况left=middle=right都是1，不能区别
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;    * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; array 数组
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;    * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; left 起始
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;    * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; right 结束
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;    * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt;    &lt;span&gt;private&lt;/span&gt; Integer min(Integer[] array, &lt;span&gt;int&lt;/span&gt; left, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; right) {
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;        &lt;span&gt;int&lt;/span&gt; min =&lt;span&gt; array[left];
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = left + 1; i &amp;lt; right; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;            &lt;span&gt;if&lt;/span&gt; (array[i] &amp;lt;&lt;span&gt; min) {
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;                min =&lt;span&gt; array[i];
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;           }
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;       }
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; min;
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;本文例子完整源码地址：&lt;a href=&quot;https://github.com/yu-linfeng/BlogRepositories/tree/master/repositories/sword&quot; target=&quot;_blank&quot;&gt;https://github.com/yu-linfeng/BlogRepositories/tree/master/repositories/sword&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/yulinfeng/p/10946815.html&quot; target=&quot;_blank&quot;&gt;《【好书推荐】《剑指Offer》之软技能》&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/yulinfeng/p/10953039.html&quot; target=&quot;_blank&quot;&gt;《【好书推荐】《剑指Offer》之硬技能（编程题1~6）》&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;持续更新，敬请关注公众号:coderbuff，回复关键字“sword”获取相关电子书。&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;这是一个能给程序员加buff的公众号 （CoderBuff）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/630246/201901/630246-20190106013233246-1297584549.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 10 Jun 2019 16:36:00 +0000</pubDate>
<dc:creator>OKevin</dc:creator>
<og:description>本文例子完整源码地址：https://github.com/yu-linfeng/BlogRepositories/tree/master/repositories/sword 《【好书推荐】《剑指O</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yulinfeng/p/11001305.html</dc:identifier>
</item>
<item>
<title>10分钟教你理解反射 - 王景林的博客</title>
<link>http://www.cnblogs.com/netlws/p/11001218.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/netlws/p/11001218.html</guid>
<description>&lt;h2&gt;&lt;span&gt;什么是反射？&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span&gt;反射反射，程序员的快乐，在&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.Net&lt;/span&gt;&lt;span&gt;领域程序设计中，反射是无处不在的，&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;MVC&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;ASP.Net&lt;/span&gt;&lt;span&gt;、各种&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;ORM&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;IOC&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;AOP&lt;/span&gt;&lt;span&gt;几乎所有的框架都离不开反射。反编译工具使用的底层技术用的不是反射，是一种逆向工程。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span&gt;反射（&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Reflection&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;System.Reflection&lt;/span&gt;&lt;span&gt;），是&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.Net Framework&lt;/span&gt;&lt;span&gt;提供的一个帮助类库，可以读取并使用&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Metadata&lt;/span&gt;&lt;span&gt;中描述的数据信息。元数据（&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Metadata&lt;/span&gt;&lt;span&gt;），描述了&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;dll/exe&lt;/span&gt;&lt;span&gt;里面的各种信息，又称中介数据、中继数据，为描述&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE/5947370&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;数据&lt;/span&gt;&lt;/strong&gt;&lt;/a&gt;&lt;/span&gt;&lt;span&gt;的数据（&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;data about data&lt;/span&gt;&lt;span&gt;），主要是描述数据&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;https://baike.baidu.com/item/%E5%B1%9E%E6%80%A7/1405051&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;属性&lt;/span&gt;&lt;/strong&gt;&lt;/a&gt;&lt;/span&gt;&lt;span&gt;（&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;property&lt;/span&gt;&lt;span&gt;）的&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;https://baike.baidu.com/item/%E4%BF%A1%E6%81%AF/111163&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;信息&lt;/span&gt;&lt;/strong&gt;&lt;/a&gt;&lt;/span&gt;&lt;span&gt;，用来支持如指示存储位置、&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;https://baike.baidu.com/item/%E5%8E%86%E5%8F%B2/360&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;历史&lt;/span&gt;&lt;/strong&gt;&lt;/a&gt;&lt;/span&gt;&lt;span&gt;数据、&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;https://baike.baidu.com/item/%E8%B5%84%E6%BA%90/9089683&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;资源&lt;/span&gt;&lt;/strong&gt;&lt;/a&gt;&lt;/span&gt;&lt;span&gt;查找、文件记录等功能。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;反射的优缺点：&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span&gt;优点：动态—在不破坏原有程序的情况下，可对程序进行良好的扩展。&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Eg&lt;/span&gt;&lt;span&gt;：我们有这样一需求，项目在最初的时候用的是&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Mysql&lt;/span&gt;&lt;span&gt;数据库，由于项目情况变化需要更换成&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;SqlServer&lt;/span&gt;&lt;span&gt;数据库。面对这种项目的需求，传统的解决方法是在项目中添加新的&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;SqlServer&lt;/span&gt;&lt;span&gt;数据库访问代码，将数据库访问实现层更改为&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;SqlServer&lt;/span&gt;&lt;span&gt;，最后编译源代码并重新发布。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;strong&gt;&lt;span&gt;传统解决方法示例伪代码如下：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;                     IDBHelper iDBHelper = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MySqlHelper();
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;                     IDBHelper iDBHelper = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SqlServerHelper();
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;                     iDBHelper.Query();
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;strong&gt;&lt;span&gt;使用反射的示例代码：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; ReflectionDemo
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 反射工厂
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SimpleFactory
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;读取配置文件&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; IDBHelperConfig = ConfigurationManager.AppSettings[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;IDBHelperConfig&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取需要加载的dll名称&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; DllName = IDBHelperConfig.Split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]; 
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取需要的类型名称&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; TypeName = IDBHelperConfig.Split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 通过反射动态加载与类型名称相匹配的实例
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; IDBHelper CreateInstance()
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             Assembly assembly =&lt;span&gt; Assembly.Load(DllName);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             Type type =&lt;span&gt; assembly.GetType(TypeName);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;object&lt;/span&gt; oDBHelper =&lt;span&gt; Activator.CreateInstance(type);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             IDBHelper iDBHelper = oDBHelper &lt;span&gt;as&lt;/span&gt;&lt;span&gt; IDBHelper;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; iDBHelper;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
  &amp;lt;add key=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;IDBHelperConfig&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MySqlDb,MySqlDb.MySqlHelper&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
                IDBHelper iDBHelper =&lt;span&gt; SimpleFactory.CreateInstance();
                iDBHelper.Query();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span&gt;通过反射实现了程序的可配置，通过修改配置文件就可以自动切换实现类，实现类必须是事先已有的，&lt;/span&gt; &lt;span&gt;没有将实现类固定，而是通过配置文件执行，通过反射创建的。可扩展&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;:&lt;/span&gt;&lt;span&gt;完全不修改原有代码，只是增加新的实现、修改配置文件，就可以支持新功能。这就是反射的动态特性。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span&gt;缺点：使用麻烦、避开编译器检查导致运程序行时异常变多、性能问题。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;通过反射调用构造函数&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; SqlServerDb
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt; 
&lt;span&gt;  4&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;  5&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 反射测试类
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;  7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ReflectionTest
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt;         &lt;span&gt;#region&lt;/span&gt; Identity
&lt;span&gt; 10&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 11&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 无参构造函数
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 13&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ReflectionTest()
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;这里是{0}无参数构造函数&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.GetType());
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt; 
&lt;span&gt; 18&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 19&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 带参数构造函数
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 21&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;name&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 22&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; ReflectionTest(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; name)
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;这里是{0} 有参数【string】构造函数&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.GetType());
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt; 
&lt;span&gt; 27&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; ReflectionTest(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id)
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;这里是{0} 有参数【int】构造函数&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.GetType());
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt;         &lt;span&gt;#endregion&lt;/span&gt;
&lt;span&gt; 32&lt;/span&gt; 
&lt;span&gt; 33&lt;/span&gt;         &lt;span&gt;#region&lt;/span&gt; Method
&lt;span&gt; 34&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 35&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 无参方法
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 37&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Show1()
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;这里是{0}的Show1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.GetType());
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 42&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 有参数方法
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 44&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;id&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 45&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Show2(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id)
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt; 
&lt;span&gt; 48&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;这里是{0}的Show2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.GetType());
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 51&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 重载方法之一
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 53&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;id&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 54&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;name&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 55&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Show3(&lt;span&gt;int&lt;/span&gt; id, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; name)
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;这里是{0}的Show3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.GetType());
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 60&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 重载方法之二
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 62&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;name&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 63&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;id&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 64&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Show3(&lt;span&gt;string&lt;/span&gt; name, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; id)
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;这里是{0}的Show3_2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.GetType());
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 69&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 重载方法之三
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 71&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;id&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 72&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Show3(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id)
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;这里是{0}的Show3_3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.GetType());
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 77&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 重载方法之四
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 79&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;name&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 80&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Show3(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; name)
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;这里是{0}的Show3_4&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.GetType());
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt; 
&lt;span&gt; 85&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 86&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 重载方法之五
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 88&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Show3()
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;这里是{0}的Show3_1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.GetType());
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt; 
&lt;span&gt; 93&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 94&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 私有方法
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 96&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;name&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 97&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Show4(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; name)
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;这里是{0}的Show4&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.GetType());
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt; 
&lt;span&gt;102&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;103&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 静态方法
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;105&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;name&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;106&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Show5(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; name)
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;这里是{0}的Show5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(ReflectionTest));
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt;         &lt;span&gt;#endregion&lt;/span&gt;
&lt;span&gt;111&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;                 Assembly assembly = Assembly.Load(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SqlServerDb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;                 Type type = assembly.GetType(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SqlServerDb.ReflectionTest&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;                 &lt;span&gt;foreach&lt;/span&gt; (ConstructorInfo ctor &lt;span&gt;in&lt;/span&gt;&lt;span&gt; type.GetConstructors())
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;                     Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ctor.Name：{ctor.Name}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                     &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; parameter &lt;span&gt;in&lt;/span&gt;&lt;span&gt; ctor.GetParameters())
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                         Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ParameterType：{parameter.ParameterType}，parameterName： {parameter.Name}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 &lt;span&gt;object&lt;/span&gt; oTest1 =&lt;span&gt; Activator.CreateInstance(type);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 &lt;span&gt;object&lt;/span&gt; oTest2 = Activator.CreateInstance(type, &lt;span&gt;new&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;[] { &lt;span&gt;123&lt;/span&gt;&lt;span&gt; });
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 &lt;span&gt;object&lt;/span&gt; oTest3 = Activator.CreateInstance(type, &lt;span&gt;new&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;[] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;陌殇&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; });
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; &lt;span&gt;反射破坏单例&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;反射破坏单例---就是反射调用私有构造函数&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;                 Assembly assembly = Assembly.Load(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SqlServerDb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;                 Type type = assembly.GetType(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SqlServerDb.Singleton&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;                 Singleton singletonA = (Singleton)Activator.CreateInstance(type, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;                 Singleton singletonB = (Singleton)Activator.CreateInstance(type, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;                 Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{object.ReferenceEquals(singletonA, singletonB)}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;反射调用泛型类&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; SqlServerDb
{

    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 泛型测试类
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;T&quot;&amp;gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;W&quot;&amp;gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;X&quot;&amp;gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; GenericClass&amp;lt;T, W, X&amp;gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; GenericClass()
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GenericClass&amp;lt;T, W, X&amp;gt;的构造函数被调用了&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }


        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Show(T t, W w, X x)
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;t.type={0},w.type={1},x.type={2}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, t.GetType().Name, w.GetType().Name, x.GetType().Name);
        }
    }

    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 泛型测试方法
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; GenericMethod
    {

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; GenericMethod()
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GenericMethod类的构造函数被调用了。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Show&amp;lt;T, W, X&amp;gt;&lt;span&gt;(T t, W w, X x)
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;t.type={0},w.type={1},x.type={2}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, t.GetType().Name, w.GetType().Name, x.GetType().Name);
        }

        
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; GenericDouble&amp;lt;T&amp;gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Show&amp;lt;W, X&amp;gt;&lt;span&gt;(T t, W w, X x)
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;t.type={0},w.type={1},x.type={2}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, t.GetType().Name, w.GetType().Name, x.GetType().Name);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;                 Assembly assembly = Assembly.Load(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SqlServerDb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;                 Type type = assembly.GetType(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SqlServerDb.GenericClass`3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;                 GenericClass&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;, DateTime&amp;gt; genericClass = &lt;span&gt;new&lt;/span&gt; GenericClass&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;, DateTime&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;genericClass.Show(&quot;12&quot;, 1, DateTime.Now);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;object oGeneric = Activator.CreateInstance(type);&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt;                 Type typeMake = type.MakeGenericType(&lt;span&gt;new&lt;/span&gt; Type[] { &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt;), &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;), &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(DateTime) });
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;                 &lt;span&gt;object&lt;/span&gt; oGeneric = Activator.CreateInstance(typeMake);
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;反射调用泛型方法&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
                Assembly assembly = Assembly.Load(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SqlServerDb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                Type type &lt;/span&gt;= assembly.GetType(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SqlServerDb.GenericMethod&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;object&lt;/span&gt; oGeneric = Activator.CreateInstance(type);
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;如果反射创建对象之后，知道方法名称，怎么样不做类型转换，直接调用方法？&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;   &lt;span&gt; 2&lt;/span&gt;                 Assembly assembly = Assembly.Load(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SqlServerDb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;                 Type type = assembly.GetType(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SqlServerDb.ReflectionTest&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;                 &lt;span&gt;object&lt;/span&gt; oTest =&lt;span&gt; Activator.CreateInstance(type);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;                 &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; method &lt;span&gt;in&lt;/span&gt;&lt;span&gt; type.GetMethods())
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;                    Console.WriteLine(method.Name);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                     &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; parameter &lt;span&gt;in&lt;/span&gt;&lt;span&gt; method.GetParameters())
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                         Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{parameter.Name}  {parameter.ParameterType}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                     ReflectionTest reflection = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReflectionTest();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;                    reflection.Show1();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                     MethodInfo method = type.GetMethod(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Show1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;if()&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;                     method.Invoke(oTest, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                     MethodInfo method = type.GetMethod(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Show2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                     method.Invoke(oTest, &lt;span&gt;new&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;[] { &lt;span&gt;123&lt;/span&gt;&lt;span&gt; });
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                     MethodInfo method = type.GetMethod(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Show3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Type[] { });
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                     method.Invoke(oTest, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                     MethodInfo method = type.GetMethod(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Show3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; Type[] { &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;) });
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;                     method.Invoke(oTest, &lt;span&gt;new&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;[] { &lt;span&gt;123&lt;/span&gt;&lt;span&gt; });
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                     MethodInfo method = type.GetMethod(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Show3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; Type[] { &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;) });
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                     method.Invoke(oTest, &lt;span&gt;new&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;[] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;一生为你&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; });
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;                     MethodInfo method = type.GetMethod(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Show3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; Type[] { &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;), &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;) });
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;                     method.Invoke(oTest, &lt;span&gt;new&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;[] { &lt;span&gt;234&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;心欲无痕&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; });
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;                     MethodInfo method = type.GetMethod(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Show3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; Type[] { &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt;), &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;) });
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;                     method.Invoke(oTest, &lt;span&gt;new&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;[] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;PHS&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;345&lt;/span&gt;&lt;span&gt; });
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;                     MethodInfo method = type.GetMethod(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Show5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;                     method.Invoke(oTest, &lt;span&gt;new&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;[] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;张中魁&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; });&lt;span&gt;//&lt;/span&gt;&lt;span&gt;静态方法实例可以要&lt;/span&gt;
&lt;span&gt;49&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;                     MethodInfo method = type.GetMethod(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Show5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;                     method.Invoke(&lt;span&gt;null&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;[] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;张中魁&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; });&lt;span&gt;//&lt;/span&gt;&lt;span&gt;静态方法实例也可以不要&lt;/span&gt;
&lt;span&gt;53&lt;/span&gt;                 }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;反射调用私有方法&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用私有方法&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;                 Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;私有方法&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;                 Assembly assembly = Assembly.Load(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SqlServerDb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;                 Type type = assembly.GetType(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SqlServerDb.ReflectionTest&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;                 &lt;span&gt;object&lt;/span&gt; oTest =&lt;span&gt; Activator.CreateInstance(type);
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; method = type.GetMethod(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Show4&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, BindingFlags.Instance |&lt;span&gt; BindingFlags.NonPublic);
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;                 method.Invoke(oTest, &lt;span&gt;new&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;[] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;我是老王&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; });
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;             }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;反射调用泛型方法&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;                Assembly assembly &lt;/span&gt;= Assembly.Load(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SqlServerDb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                Type type &lt;/span&gt;= assembly.GetType(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SqlServerDb.GenericMethod&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;object&lt;/span&gt; oGeneric =&lt;span&gt; Activator.CreateInstance(type);
                &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; type.GetMethods())
                {
                    Console.WriteLine(item.Name);
                }
                MethodInfo method &lt;/span&gt;= type.GetMethod(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Show&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定泛型方法的参数类型&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; methodNew = method.MakeGenericMethod(&lt;span&gt;new&lt;/span&gt; Type[] { &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;), &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt;), &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(DateTime) });
                &lt;/span&gt;&lt;span&gt;object&lt;/span&gt; oReturn = methodNew.Invoke(oGeneric, &lt;span&gt;new&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;[] { &lt;span&gt;123&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;董小姐&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, DateTime.Now });
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;反射调用泛型方法加泛型类&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;                 Assembly assembly = Assembly.Load(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SqlServerDb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在获取类型的同时通过MakeGenericType指定泛型的参数类型&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;                 Type type = assembly.GetType(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SqlServerDb.GenericDouble`1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).MakeGenericType(&lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;                 &lt;span&gt;object&lt;/span&gt; oObject =&lt;span&gt; Activator.CreateInstance(type);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;                 MethodInfo method = type.GetMethod(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Show&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).MakeGenericMethod(&lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt;), &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(DateTime));
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;                 method.Invoke(oObject, &lt;span&gt;new&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;[] { &lt;span&gt;345&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;感谢有梦&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, DateTime.Now });
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Mon, 10 Jun 2019 15:54:00 +0000</pubDate>
<dc:creator>王景林的博客</dc:creator>
<og:description>什么是反射？ 反射反射，程序员的快乐，在.Net领域程序设计中，反射是无处不在的，MVC、ASP.Net、各种ORM、IOC、AOP几乎所有的框架都离不开反射。反编译工具使用的底层技术用的不是反射，是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/netlws/p/11001218.html</dc:identifier>
</item>
<item>
<title>Asp.net core使用MediatR进程内发布/订阅 - GUOKUN</title>
<link>http://www.cnblogs.com/guokun/p/11001052.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/guokun/p/11001052.html</guid>
<description>&lt;p&gt;1、背景&lt;/p&gt;
&lt;p&gt;　　最近，一个工作了一个月的同事离职了，所做的东西怼了过来。一看代码，惨不忍睹，一个方法六七百行，啥也不说了吧，实在没法儿说。介绍下业务场景吧，一个公共操作A，业务中各个地方都会做A操作，正常人正常思维应该是把A操作提取出来封装，其他地方调用，可这哥们儿偏偏不这么干，代码到处复制。仔细分析了整个业务之后，发现是一个典型的事件/消息驱动型，或者叫发布/订阅型的业务逻辑。鉴于系统是单体的，所以想到利用进程内发布/订阅的解决方案。记得很久之前，做WPF时候，用过Prism的EventAggregator（是不是暴露年龄了。。。），那玩意儿不知道现在还在不在，支不支持core，目前流行的是MediatR，跟core的集成也好，于是决定采用MediatR。&lt;/p&gt;
&lt;p&gt;2.Demo代码&lt;/p&gt;
&lt;p&gt;Startup服务注册：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
        {
            services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2);
            services.AddScoped&lt;/span&gt;&amp;lt;IService1, Service1&amp;gt;&lt;span&gt;();
            services.AddScoped&lt;/span&gt;&amp;lt;IService2, Service2&amp;gt;&lt;span&gt;();
            services.AddScoped&lt;/span&gt;&amp;lt;IContext, Context&amp;gt;&lt;span&gt;();
            services.AddMediatR(&lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(SomeEventHandler).Assembly);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　服务1：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Service1 : IService1
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; ILogger _logger;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; IMediator _mediator;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; IContext _context;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; IService2 _service2;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Service1(ILogger&amp;lt;Service1&amp;gt;&lt;span&gt; logger,
            IMediator mediator,
            IContext context)
        {
            _logger &lt;/span&gt;=&lt;span&gt; logger;
            _mediator &lt;/span&gt;=&lt;span&gt; mediator;
            _context &lt;/span&gt;=&lt;span&gt; context;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;_service2 = service2;&lt;/span&gt;
&lt;span&gt;        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task Method()
        {
            _context.CurrentUser &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;await _service2.Method();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;_service2.Method();&lt;/span&gt;
            &lt;span&gt;await&lt;/span&gt; _mediator.Publish(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SomeEvent());
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;_mediator.Publish(new SomeEvent());&lt;/span&gt;

            &lt;span&gt;await&lt;/span&gt;&lt;span&gt; Task.CompletedTask;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　可以看到，在服务1的method方法中，发布了SomeEvent事件消息。&lt;/p&gt;
&lt;p&gt;服务2代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Service2 : IService2
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; ILogger _logger;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; IContext _context;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Service2(ILogger&amp;lt;Service2&amp;gt;&lt;span&gt; logger,
            IContext context)
        {
            _logger &lt;/span&gt;=&lt;span&gt; logger;
            _context &lt;/span&gt;=&lt;span&gt; context;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task Method()
        {
            _logger.LogDebug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;当前用户:{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, _context.CurrentUser);
            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt; Task.Delay(&lt;span&gt;5000&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;_logger.LogDebug(&quot;当前用户:{0}&quot;, _context.CurrentUser);&lt;/span&gt;
            _logger.LogDebug(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Service2 Method at :{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, DateTime.Now);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;解释下，为啥服务2 Method方法中，要等待5秒，因为实际项目中，有这么一个操作，把一个压缩程序包传递到远端，然后在远端代码操作IIS创建站点，这玩意儿非常耗时，大概要1分多钟，这里我用5s模拟，意思意思。这个5s至关重要，待会儿会详述。&lt;/p&gt;
&lt;p&gt;再看事件订阅Handler：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; SomeEventHandler : INotificationHandler&amp;lt;SomeEvent&amp;gt;&lt;span&gt;, IDisposable
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; ILogger _logger;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; IServiceProvider _serviceProvider;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; IService2 _service2;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; SomeEventHandler(ILogger&amp;lt;SomeEventHandler&amp;gt;&lt;span&gt; logger,
            IServiceProvider serviceProvider,
            IService2 service2)
        {
            _logger &lt;/span&gt;=&lt;span&gt; logger;
            _serviceProvider &lt;/span&gt;=&lt;span&gt; serviceProvider;
            _service2 &lt;/span&gt;=&lt;span&gt; service2;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Dispose()
        {
            _logger.LogDebug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Handler disposed at :{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, DateTime.Now);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task Handle(SomeEvent notification, CancellationToken cancellationToken)
        {
            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; _service2.Method();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;using (var scope = _serviceProvider.CreateScope())
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    var service2 = scope.ServiceProvider.GetService&amp;lt;IService2&amp;gt;();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    await service2.Method();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;
&lt;span&gt;        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然后，我们的入口Action：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
[HttpGet(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;ActionResult&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt; Test()
        {
            StringBuilder sb &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuilder();
            sb.AppendFormat(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;开始时间：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, DateTime.Now);
            sb.AppendLine();
            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; _service1.Method();
            sb.AppendFormat(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;结束时间：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, DateTime.Now);
            sb.AppendLine();

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; sb.ToString();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;至此，Demo要干的事情，脉络应该很清晰了：控制器接收HTTP请求，然后调用Service1的Method，service1的Method又发布消息，消息处理器接收到消息，调用Service2的Method完成后续操作。我们运行起来看下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/481360/201906/481360-20190610222721206-1730878405.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;http请求开始到结束，耗时5s，看似没问题。我们看系统输出日志：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/481360/201906/481360-20190610222906788-1409524317.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; Service2的Method方法也确实被订阅执行了。&lt;/p&gt;
&lt;p&gt;3.问题&lt;/p&gt;
&lt;p&gt;　　上述一切的一切，看似没问题。运行成功没？成功了。对不对？好像也对。有没问题？大大的问题！HTTP从开始到结束，要耗时5s，实际项目中，那是一分钟，这整整一分钟，你要前端挂起等待么一直？理论上，这种耗时的后端操作，合理做法是HTTP迅速响应前端，并返给前端业务ID，前端根据此业务ID长轮询后端查询操作结果状态，直至此操作完成，决不能一直卡死的，否则交互效果不说，超过一定时间，HTTP请求会直接超时的！这就必须动刀子了，将Service2操作后台任务化且不等待。Service1的Method代码调整如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task Method()
        {
            _context.CurrentUser &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;await _service2.Method();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;_service2.Method();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;await _mediator.Publish(new SomeEvent());&lt;/span&gt;
            _mediator.Publish(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SomeEvent());

            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; Task.CompletedTask;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;见注释前后，改进地方只有一处，发布事件代码去掉了await，这样系统发布事件之后，便不会等待Service2而是继续运行并立刻响应HTTP请求。好，我们再来运行看下效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/481360/201906/481360-20190610224056877-1069072508.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/481360/201906/481360-20190610224205479-441056790.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 我们看到，系统立即响应了HTTP请求（22:40:15），5s之后，Service2才执行完成（22:40:20）。看似又没问题了。那是不是真的没问题呢？我们注意，Service1和Service2中，都注入了一个Context上下文对象，这个对象是我用来模拟一些Scope类型对象，例如DBContext的，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Context : IContext, IDisposable
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; _isDisposed = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; _currentUser;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; CurrentUser
        {
            &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (_isDisposed)
                {
                    &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Exception(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Context disposed&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                }

                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; _currentUser;
            }
            &lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (_isDisposed)
                {
                    &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Exception(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Context disposed&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                }

                _currentUser &lt;/span&gt;=&lt;span&gt; value;
            }
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Dispose()
        {
            _isDisposed &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;里边就一个属性，当前上下文用户，并实现了Dispose模式，并且当前上下文被释放时，对该上下文对象任何操作将引发异常。从上文的Service1及Service2截图中，我们看到了，两个服务均注入了这个context对象，Service1设置，Service2中获取。现在我们将Service2的Method方法稍作调整，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task Method()
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;_logger.LogDebug(&quot;当前用户:{0}&quot;, _context.CurrentUser);&lt;/span&gt;
            &lt;span&gt;await&lt;/span&gt; Task.Delay(&lt;span&gt;5000&lt;/span&gt;&lt;span&gt;);
            _logger.LogDebug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;当前用户:{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, _context.CurrentUser);
            _logger.LogDebug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Service2 Method at :{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, DateTime.Now);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　调整只有一处，就是获取当前上下文用户的操作，从5s延时之前，放到了5s延时之后。我们再来看看效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/481360/201906/481360-20190610225114425-1346880756.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;http请求上看，貌似没问题，立即响应了，是吧。我们再看看程序日志输出：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/481360/201906/481360-20190610225228423-421898276.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;WFT！Service2 Method没成功执行，给了我一个异常。我们看看这个异常：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/481360/201906/481360-20190610225512687-290125525.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; Context dispose异常，就是说上下文这时候已经被释放掉，对它任何操作都无效并引发异常。很容易想到，这里就是为了模拟DBContext这种通常为Scope类型的对象生命周期，这种吊毛它就这样。为啥会释放？因为HTTP请求结束那会儿，core运行时就会Dispose相应scope类型对象（注意，释放，不一定是销毁，具体销毁时间不确定）。那么，怎么解决？如果对基于DI生命周期比较熟悉，就会知道，这儿应该基于HTTP 的Scope之外，单独起一个Scope了，两个scope互补影响，HTTP对应的scope结束，另外的照常运行。我们将Handler处调整如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task Handle(SomeEvent notification, CancellationToken cancellationToken)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;await _service2.Method();&lt;/span&gt;
            &lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; scope =&lt;span&gt; _serviceProvider.CreateScope())
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; service2 = scope.ServiceProvider.GetService&amp;lt;IService2&amp;gt;&lt;span&gt;();
                &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; service2.Method();
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　无非就是Handle中单独起了一个Scope。我们再看运行效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/481360/201906/481360-20190610230404536-2137030637.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/481360/201906/481360-20190610230438092-1478199233.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;OK，HTTP请求23:02:58响应，Service2 Method 23:03:03执行完成。至此，问题才算得到解决。&lt;/p&gt;
&lt;p&gt;顺便提一下，大家注意看截图，当前用户null，因为scope之后，原来的设置过CurrentUser的context已经释放掉了，新开的scope中注入的context是另外的，所以没任何信息。这里你可能会问了，那我确实需要传递上下文怎么办？答案是，订阅事件，本文中SomeEvent未定义任何信息，如果你需要传递，做对应调整即可，比较简单，也不是重点，不做赘述。&lt;/p&gt;

&lt;p&gt;4、总结&lt;/p&gt;
&lt;p&gt;　　感觉，没什么好总结的。扎实，细心，实践，没什么解决不了的。&lt;/p&gt;

</description>
<pubDate>Mon, 10 Jun 2019 15:10:00 +0000</pubDate>
<dc:creator>GUOKUN</dc:creator>
<og:description>1、背景 最近，一个工作了一个月的同事离职了，所做的东西怼了过来。一看代码，惨不忍睹，一个方法六七百行，啥也不说了吧，实在没法儿说。介绍下业务场景吧，一个公共操作A，业务中各个地方都会做A操作，正常人</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/guokun/p/11001052.html</dc:identifier>
</item>
<item>
<title>代价敏感学习初探 - 有偏损失函数设计 - 郑瀚Andrew.Hann</title>
<link>http://www.cnblogs.com/LittleHann/p/10587512.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/LittleHann/p/10587512.html</guid>
<description>&lt;h2&gt;&lt;span&gt;0x1：如何将业务场景中对FP和FN损失的不同接受程度，调整我们的损失函数&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;1. 什么场景下需要代码敏感学习&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;在很多真实业务场景中，包括笔者所在的网络安全领域，误报造成的损失常常比漏报来的要大，原因很简单，如果一个IDS系统每天都在产生大量虚警，那么对事件响应处理人员的压力就会非常大，时间久了，大家对IDS的信任度就会下降，同时真实的有效告警也可能被淹没在海量的虚警中，反而导致更多和更严重的漏报。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但另一方面，可能有人会质疑说漏报的影响不是更恶劣吗？难道不应该秉着”宁可错杀一千，不可放过一个可疑“的方针吗？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;根据笔者目前的从业经验来看，没有必要这样。一个好的做法是构建多层次的纵深检测体系，大白话就是在一个KILLCHAIN的每一个环节都有针对性地部署一个IDS，同时追求每个IDS的精确度，对于单个IDS来说，尽量少误报，对于整体系统来说，所有IDS综合起来构成了一个纵深体系，攻击者想要穿透这个体系而不引发任何的告警，就需要非常高超的技巧和小心翼翼的动作，而这有时候也反过来限制了攻击者所能做的动作，例如内网扫描这件事。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;说完了代码敏感学习的应用场景，接下来的问题肯定是：代价敏感函数是什么？简单的回答是：&lt;strong&gt;代价敏感学习是在原始标准代价损失函数的基础上，增加了一些约束和权重条件，使得最终代价的数值计算朝向一个特定的方向偏置（bias），而这个偏置就是具体业务场景更关注的部分&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们先来看一下常规的代价函数是如何计算的。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2. 常规损失函数的&lt;/span&gt;&lt;span&gt;数值计算&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;一般来说，机器学习领域的检测分类算法所关注的仅仅是如何得到最高的正确率（acc），以2-class分类为例，我们可以使用一个二维矩阵来描述分类算法的预测结果，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201903/532548-20190327173942337-1219372512.png&quot; alt=&quot;&quot; width=&quot;337&quot; height=&quot;118&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;表中的列表示实际数据所属类别，行表示分类算法的预测类别&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;不管使用了损失函数是何种形式，形式上，算法的&lt;strong&gt;预测错误&lt;/strong&gt;的即是 &lt;strong&gt;FP&lt;/strong&gt; 和 &lt;strong&gt;FN&lt;/strong&gt; 两部分所表示，即：&lt;strong&gt;Loss = Loss（FP）+ Loss（FN）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;从损失函数的通用数学公式角度来看，损失函数的求导优化对 FP 和 FN 是没有任何偏置的。分类算法所关心的是如何使得 FP+FN 的值尽可能的小，从而获得较高的分类准确率。对于 FP、FN 两部分各自在错误实例中所占的比重，传统损失函数并没有加以任何的考虑和限制。&lt;/p&gt;
&lt;p&gt;换句话说，传统损失函数实际上是建立在下述假设的基础之上的：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;在所有情况下，分类算法做出 FN 判断和做出 FP 判断对于实际结果的影响因子是完全相同的。所以我们可以不对两种误判所占的比例加以约束&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;3. 业务场景中的损失函数计算&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;然而在现实世界中，这一假设往往是并不成立的，在实际的业务场景中，FN 和 FN 所带来的实际损失往往是不同的。一个被广为接受的上述假设的反例就是银行借贷问题。&lt;/p&gt;
&lt;ul class=&quot;description&quot; readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;从机器学习算法的角度考虑，算法的分类结果应该使得&lt;strong&gt;错误分类率&lt;/strong&gt;降到最低；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;而在实际应用中，算法的分类结果应该保证分类结果给银行造成的&lt;strong&gt;损失&lt;/strong&gt;较小；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在实际情况中，银行做出 FP 判断（即没有将贷款贷给符合条件的申请人），所造成的损失要远小于其做出 FN 判断（即将贷款贷给不符合条件的申请人所造成的损失的）&lt;/p&gt;
&lt;p&gt;如果我们用下图来描述银行做出不同决定所造成的不同的代价的的cost matrix：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201903/532548-20190328150529843-556428855.png&quot; alt=&quot;&quot; width=&quot;396&quot; height=&quot;139&quot;/&gt;&lt;/p&gt;
&lt;p&gt;分类算法导致的实际损失等于：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Loss-real = FP * C01 + FN * C10&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设现在有两个分类已训练好的算法 A 和 B，对于 10 个贷款申请人进行分类。&lt;/p&gt;
&lt;p&gt;我们令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
loss（FN）c10 = &lt;span&gt;10&lt;/span&gt;&lt;span&gt;；
loss（FP）c01 &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;；
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;若 A/B 算法的分类结果为下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201903/532548-20190328151633598-617993952.png&quot; alt=&quot;&quot; width=&quot;439&quot; height=&quot;103&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从数值计算的角度，A 算法的分类正确性要优于 B 算法：Acc（A）= 80% &amp;gt; Acc（B）= 60%&lt;/p&gt;
&lt;p&gt;但是从实际业务场景角度，银行实际损失，A 算法的性能却不如 B 算法：Loss（A）= 20 &amp;gt; Loss（B）= 4&lt;/p&gt;
&lt;p&gt;这就是 cost-sensitive 分类算法所关注和研究的问题。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;0x2：代价敏感学习公式&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;利用 cost matrix，我们可以将 cost-sensitive 分类问题转化一个最优化问题，对于二分类分类算法来说只有2种判断结果，所以优化目标为让下式 L(x, i)达到最小值：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201903/532548-20190328161205128-1599519545.png&quot; alt=&quot;&quot; width=&quot;187&quot; height=&quot;29&quot;/&gt;&lt;/p&gt;
&lt;ul class=&quot;description&quot; readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;其中 x 是一个实例；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;(x, i)表示将其分为 i 类；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;P(j | x) 表示在算法 A 中获得的 x 属于类别 j 的后验概率，这个概率越小，反之 P(i | x) 就越大，这就是求对偶问题的反面；&lt;/li&gt;
&lt;li&gt;c(i，j) 表示算法 A 将类别 i 的样本错判为类别 j 的实际损失（real-cost）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上述公式中，因为损失权重偏置因子c(i，j)的加入，使得我们的目标使得模型不再单纯关注如何获得 P(j|x)的最大值，而是要综合考虑预测结果P(j | x)以及不同预测结果造成的损失c(i，j)。这两个因子互相牵制。&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;1. Cost-sensitive中cost的定义与表示&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;通常情况下，我们使用 cost matrix 描述待分类数据集上的 cost 信息。Cost matrix C 是一个N × N的矩阵，其中 N 代表待分类数据集中的类别的数量。&lt;/p&gt;
&lt;p&gt;C 中的条目 c(i, j)表示分类算法将实际属于 j 类得到实例分为 i 类所造成的 cost。当 i = j 时代表分类算法正确预测了实例的类别，而i ≠ j的条目对应于不正确的分类结果。&lt;/p&gt;
&lt;p&gt;在对 c(i, j)进行赋值的过程中，一般会遵循合理性原则：&lt;/p&gt;
&lt;ul class=&quot;description&quot; readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;即错误分类的造成的 cost 肯定要大于正确分类造成的 cost；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;cost matrix 中的 c(i, j) = 0 , when i = j，而对于其他错误的分类结果对应的条目 c(i, j)， 我们赋其值为正数，用于表示其代价；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;而具体FN和FP如何赋值，取决于具体业务场景。例如如果我们认为误报的损失大于漏报的损失，则赋值：cFN &amp;gt; cFP；&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;2. Cost-sensitive损失权重因子对损失函数的影响&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;从宏观角度来看，代价损失权重因子c(i, j)可以理解为一种先验知识。加入损失权重因子c(i, j)后，目标函数L(x，i)从最大似然估计转变为了最大后验估计。&lt;/p&gt;
&lt;p&gt;笔者认为，cost sensitive的本质是“&lt;strong&gt;对不同的后验预测结果，的条件概率 P(y|x) 赋予不同的惩罚因子&lt;/strong&gt;”。&lt;/p&gt;
&lt;p&gt;在 2-class 分类中，cost-sensitive 分类算法将实例 x 分为 1 类的条件是当且仅当将 x 分为 1 类所造成的预期 cost，不大于将 x 分为 0 类的损失。即&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201906/532548-20190610140631602-318835200.png&quot; alt=&quot;&quot; width=&quot;476&quot; height=&quot;24&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当式子取等号时，这就是所谓的&lt;strong&gt;分类器最优决策面&lt;/strong&gt;（auc曲线本身）。可以看到，cost matrix的不同取值，影响了这个分类器最优决策面的位置，具体如何分析这种影响，我们文章的后面会继续深入讨论。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;0x3：代价敏感损失的泛化讨论&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;笔者希望和大家一起更深入思考一下，代价敏感损失的本质是什么。&lt;/p&gt;
&lt;p&gt;虽然大量的paper上都提出了cost-sensitive是对不同的predict result给予不同的损失因子，这是离散的范畴。但是笔者认为这个概念可以继续延展到连续无限的范畴，即对&lt;strong&gt;对数几率回归损失&lt;/strong&gt;（sigmoid）这种损失函数也同样起作用，sigmoid本质上也体现了cost sensitive的思想。&lt;/p&gt;
&lt;p&gt;一个标准的sigmoid函数如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201903/532548-20190328171131651-2126908756.png&quot; alt=&quot;&quot; width=&quot;334&quot; height=&quot;250&quot;/&gt;&lt;/p&gt;
&lt;p&gt;sigmoid函数的输出代表了对发生几率的预测，目标y为 {1，0}，即发生于不发生，而sigmoid的输出介于【0，1】之间。&lt;/p&gt;
&lt;p&gt;从函数曲线上可以很容易看出：&lt;/p&gt;
&lt;ul class=&quot;description&quot; readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;对于靠近【0，1】两侧的预测值，预测值和实际值的差值是比位于中间概率的差值要小的，因此这个区域中的1阶导数相对就较低，这进而导致了例如GD算法的最终损失较低；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;而位于【0，1】中间位置的地方，1阶导数相对较高，进而导致最终损失较高；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;通过这种函数特性，sigmoid函数会“驱使”模型将预测结果向靠近 0 或者靠近 1 的方向前进，或者说sigmoid函数不喜欢模糊地带，而偏爱（bias）确定性的结果。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;0x4：Cost-Sensitive的几何意义&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;如果我们画出ROC曲线，横轴和纵轴分别是 acc 和 recall，可以现象，曲线是一个形如下图的曲线：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201903/532548-20190329151229215-1088115286.png&quot; alt=&quot;&quot; width=&quot;471&quot; height=&quot;209&quot;/&gt;&lt;/p&gt;
&lt;p&gt;损失函数的极值点就是最终的&lt;strong&gt;决策分界面&lt;/strong&gt;和&lt;strong&gt;ROC曲线&lt;/strong&gt;的“&lt;strong&gt;切线点&lt;/strong&gt;”（图中的绿点）。&lt;/p&gt;
&lt;p&gt;我们可以做一个直观的想象：cost() 函数起到的作用是“拉伸”原始的ROC曲线，使其向acc或者recall的方向拉伸，拉伸的结果会导致超分界面“提早”和 acc 或者 recall 方面相切。&lt;/p&gt;
&lt;ul class=&quot;description&quot; readability=&quot;1&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;对误报的惩罚加大&lt;/strong&gt;：cost()对FN的因子比例增大，则使roc曲线朝上图中 true positive rate 方向拉伸，即向上，则相切点会更靠下，最终的效果是获得更低的 true positive rate；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;对漏报的惩罚加大&lt;/strong&gt;：cost()对FP的因子比例增大，则使roc曲线朝上图中 false positive rate 方向拉伸，即向左，则相切点会更靠右，最终的效果是获得更低的 false positive rate；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以上的函数几何视角，启发我们一点：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;cost-sensitive Loss Function 的作用本质上是通过“拉伸”损失函数的函数形式，进而影响模型的最优决策面。对 acc 和 recall 的不同权重因子，最终影响了 roc 曲线中向 acc 和 recall 方向的偏离程度&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;当然，cost-sensitive只是影响了模型最优决策面的位置，最优决策面并不是最终的决策函数。&lt;/p&gt;
&lt;p&gt;如果将auc函数看成是【x，y】坐标系的话，不同的x，y取值代表了最终决策不同的偏向，例如我们取x=0.1，即追求低误报，则相对的，y值肯定也低，即召回也低了。如果我们稍微放低一些对低误报的追求，则召回也能对应提高。在实际的tensorflow开发中，这通过对最终模型预测的p的threshold来实现。&lt;/p&gt;
&lt;p&gt;那cost-sensitive在这里又扮演了什么角色呢？&lt;/p&gt;
&lt;p&gt;简单来说可以这么理解，在相同的threshold前提下，误报敏感损失函数会使得模型获得更低的误报，漏报敏感损失函数会使得模型会的更低的漏报。&lt;/p&gt;
&lt;p&gt;但是要始终牢记的是：&lt;strong&gt;最终的模型效果是两部分组成的，AUC函数的形式+认为设定的threshold决策策略&lt;/strong&gt;。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;0x5：实现cost sensitive思想的不同方式&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;解决 cost-sensitive 分类问题的核心在于解决&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201903/532548-20190328161205128-1599519545.png&quot; alt=&quot;&quot; width=&quot;187&quot; height=&quot;29&quot;/&gt;的优化问题，即如何使得分类算法的结果能够获得有倾向性的L值。 &lt;/p&gt;
&lt;p&gt;目前，在如何获得有倾向性的分类算法这一问题上，目前有几种比较主流的方法：&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;1. Train set sample rescaling&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;通过有意调整，将训练数据集的正负例呈现不同数量比，以提高分类算法对于某些分类结果的敏感性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如如果想获得更高的acc，更低的误报，我们在训练集中，调整反例的数量是正例的数倍。&lt;/span&gt;&lt;span&gt;相关的讨论，可以参阅另一篇&lt;a href=&quot;https://www.cnblogs.com/LittleHann/p/10498579.html#_label5&quot; target=&quot;_blank&quot;&gt;blog&lt;/a&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2. Class membership probability - cost matrix reweighted&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;通过修改不同分类在算法中的 class membership probability，以获得具有一定数据倾向性的分类算法。这种算法被称为reweighted。这种方法也是本文主要讨论的。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;0x6：代价敏感函数在不同机器学习算法中的应用&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;目前，分类决策树、神经网络、支持向量机(SVM)、boosting等常用学习算法都有其对应的代价敏感扩展算法。&lt;/p&gt;
&lt;p&gt;各个方法在具体形式上各不相同，但其核心思想是一致的，这里以AdaCost为例举例说明。&lt;/p&gt;
&lt;p&gt;AdaCost 算法由 AdaBoost 分类算法改进而来，也是一种通过 reweighted 方式获取 cost-sensitive 分类算法的方法。&lt;/p&gt;
&lt;p&gt;AdaCost 的基本思想是使用若干个较弱的分类器以投票方式集成出一个分类器，各个分类器的权值由评价函数调整确定。在 AdaBoost 算法中，评价函数仅和算法的分类准确性相关。W.Fan 等人在 AdaBoost 的评价函数中引入了 cost 的元素，使得分类算法能够有效降低分类结果的 cost 值。&lt;/p&gt;
&lt;p&gt;具体来说 AdaCost 算法添加了一个评价分类结果的 cost 性能的函数β：y × X × c → ℝ+，使得训练出来的弱分类器的权值集合能够符合 cost-sensitive 的要求。下面给出其伪码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201906/532548-20190610165110794-1509753724.png&quot; alt=&quot;&quot; width=&quot;701&quot; height=&quot;367&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Relevant Link: &lt;/strong&gt;  &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;202.119.32.195/cache/4/03/lamda.nju.edu.cn/d2623fb33f624a2a05033bb5d0e23d45/qiny.pdf&lt;/span&gt;
http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;lamda.nju.edu.cn/huangsj/dm11/files/qiny.pdf &lt;/span&gt;
https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;homes.cs.washington.edu/~pedrod/papers/kdd99.pdf &lt;/span&gt;&lt;span&gt;
https:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;cling.csd.uwo.ca/papers/cost_sensitive.pdf &lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上个章节中，我们谈到了一个词，”分类器最优决策面“，这个东西是什么呢？这个章节我们来详细讨论。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;0x1：贝叶斯最优决策理论&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;1. 贝叶斯最优分类(Bayes optimal classification)&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;对于二分类问题, 定义2级代价矩阵(cost matrix)：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201906/532548-20190610175144907-180619328.png&quot; alt=&quot;&quot; width=&quot;172&quot; height=&quot;78&quot;/&gt;，其中&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201906/532548-20190610201004296-775936452.png&quot; alt=&quot;&quot; width=&quot;25&quot; height=&quot;19&quot;/&gt;是将b类样本预测为a类样本的分类代价。&lt;/p&gt;
&lt;p&gt;据&lt;strong&gt;Bayes决策理论&lt;/strong&gt;，最优决策的目标是&lt;strong&gt;最小化期望分类代价（最大后验概率估计），&lt;/strong&gt;即给定样本x，若下式成立，则预测其类别为正；否则，预测其类别为负。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201906/532548-20190610201453059-290865880.png&quot; alt=&quot;&quot; width=&quot;275&quot; height=&quot;64&quot;/&gt;，其中 p(x)为后验概率，p(x) = P(y = +1|x)，1 − p(x) = P(y = −1|x)。&lt;/p&gt;
&lt;p&gt;上式的意思是：当，Loss（正例判对+负例误报为正例）&amp;lt;= Loss（正例漏报，负例判对）时，模型预测最终结果为正。&lt;/p&gt;
&lt;p&gt;将上式移项后可重写为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201906/532548-20190610201912350-1968552783.png&quot; alt=&quot;&quot; width=&quot;387&quot; height=&quot;65&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中：&lt;/p&gt;
&lt;p&gt;因此贝叶斯最优分类器输出的分类器函数为（这里不考虑人为设定的threshold决策函数）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201906/532548-20190610202611878-609139452.png&quot; alt=&quot;&quot; width=&quot;277&quot; height=&quot;92&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因此，Bayes分类器也可写作：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201906/532548-20190610202657764-1069543530.png&quot; alt=&quot;&quot; width=&quot;212&quot; height=&quot;54&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当正负类别分类代价相等时，即c+ = c−，Bayes分类器退化为普通的无偏损失函数&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201906/532548-20190610203109462-917464026.png&quot; alt=&quot;&quot; width=&quot;109&quot; height=&quot;35&quot;/&gt;；而当c+和c-存在不对称偏置时，Bayes分类器也成为有偏损失函数。&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2. 贝叶斯决策错误理论上界&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;cost matrix本质上是改变了Bayes分类器的损失理论上界。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;0x2：代价敏感损失设计准则(Design criterions of cost-sensitive loss)&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;1. 准则一&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;代价敏感损失函数&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201906/532548-20190610204108116-722627377.png&quot; alt=&quot;&quot; width=&quot;90&quot; height=&quot;21&quot;/&gt;需满足&lt;strong&gt;Bayes一致性&lt;/strong&gt;，即单调性&lt;strong&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新设计的代价敏感损失函数&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201906/532548-20190610204510907-1609276151.png&quot; alt=&quot;&quot; width=&quot;86&quot; height=&quot;22&quot;/&gt;满足下述特性：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201906/532548-20190610202611878-609139452.png&quot; alt=&quot;&quot; width=&quot;277&quot; height=&quot;92&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2. 准则二&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201906/532548-20190610204643903-1966604702.png&quot; alt=&quot;&quot; width=&quot;23&quot; height=&quot;22&quot;/&gt;对应的条件代价敏感风险&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201906/532548-20190610204735884-1660950827.png&quot; alt=&quot;&quot; width=&quot;81&quot; height=&quot;25&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201906/532548-20190610204746835-1276060511.png&quot; alt=&quot;&quot; width=&quot;75&quot; height=&quot;24&quot;/&gt;在Bayes分类边界（分类器最优决策面）&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201906/532548-20190610204850457-99541883.png&quot; alt=&quot;&quot; width=&quot;138&quot; height=&quot;37&quot;/&gt;处取得最大值。&lt;/p&gt;
&lt;p&gt;Bayes分类器的期望分类代价为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201906/532548-20190610210202544-445223678.png&quot; alt=&quot;&quot; width=&quot;345&quot; height=&quot;78&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在分类边界&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201906/532548-20190610210227621-1705898914.png&quot; alt=&quot;&quot; width=&quot;139&quot; height=&quot;35&quot;/&gt;处，将样本x判为正、负类别的分类代价相等并达到最大值&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201906/532548-20190610210307404-852356505.png&quot; alt=&quot;&quot; width=&quot;63&quot; height=&quot;39&quot;/&gt;，此时最难预测样本类别。 &lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Relevant Link: &lt;/strong&gt;  &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.cnblogs.com/Determined22/p/6347778.html&lt;/span&gt;&lt;span&gt;
http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;jcta.cnjournals.com/cta_cn/ch/reader/view_abstract.aspx?doi=10.7641/CTA.2015.40519 &lt;/span&gt;&lt;span&gt;
https:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.bilibili.com/read/cv112928/&lt;/span&gt;&lt;span&gt;
https:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.zhihu.com/question/27670909&lt;/span&gt;&lt;span&gt;
《统计决策论及贝叶斯分析》&lt;/span&gt;- J.O.伯杰
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个章节，我们来真正进入代价敏感函数的内部原理，探究一下cost matrix是如何影响原始损失函数的形态，进而影响原始损失函数的性质的。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;0x1：原始无偏损失函数函数性质&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;我们前面说过，当正负类别分类代价相等时，即c+ = c−，Bayes分类器退化为普通的无偏损失函数&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201906/532548-20190610203109462-917464026.png&quot; alt=&quot;&quot; width=&quot;109&quot; height=&quot;35&quot;/&gt;；而当c+和c-存在不对称偏置时，Bayes分类器也成为有偏损失函数。&lt;/p&gt;
&lt;p&gt;所以这里先来看下我们熟悉的原始无偏损失函数的函数性质。&lt;/p&gt;
&lt;p&gt;具体探讨以下损失函数：平方损失、指数损失、对数损失、SVM损失。这几种损失函数均可表示为间隔yF(x)的函数, 即&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201906/532548-20190610214848354-1321201334.png&quot; alt=&quot;&quot; width=&quot;185&quot; height=&quot;22&quot;/&gt;，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201906/532548-20190610215332686-227176585.png&quot; alt=&quot;&quot; width=&quot;355&quot; height=&quot;319&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下标给出了各个损失函数对应最优决策函数&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201906/532548-20190610215518339-1531099705.png&quot; alt=&quot;&quot; width=&quot;40&quot; height=&quot;19&quot;/&gt;及其条件风险&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201906/532548-20190610215535483-20408441.png&quot; alt=&quot;&quot; width=&quot;128&quot; height=&quot;20&quot;/&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201906/532548-20190610214923482-118931597.png&quot; alt=&quot;&quot; width=&quot;425&quot; height=&quot;195&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下图给出了各个损失函数的最优解和最优解处的条件风险：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201906/532548-20190610215625620-109870274.png&quot; alt=&quot;&quot; width=&quot;347&quot; height=&quot;590&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，在无偏损失情况下，&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201906/532548-20190610204510907-1609276151.png&quot; alt=&quot;&quot; width=&quot;86&quot; height=&quot;22&quot;/&gt;与贝叶斯分类器&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201906/532548-20190610203109462-917464026.png&quot; alt=&quot;&quot; width=&quot;109&quot; height=&quot;35&quot;/&gt;等价，最优解处的条件风险与最小分类误差一致，即在p(x) = 1/2 处取得最大值。&lt;/p&gt;
&lt;p&gt;这和我们的认识是一致的，怎么理解呢？简单来说可以这么理解。&lt;/p&gt;
&lt;p&gt;如果我们使用逻辑斯蒂回归训练一个二分类器，那么我们可以设定预测的阈值p为0.5，当&amp;gt;=0.5时，预测结果为正例，当&amp;lt;0.5时预测结果为负例。这是最优的阈值，任何偏离0.5的阈值p都会增加损失：&lt;/p&gt;
&lt;ul class=&quot;description&quot; readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;决策阈值向0.5左偏：整体损失的增加主要来自误报增加。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;决策阈值向0.5右偏：整体损失的增加主要来自漏报增加，当然在某些情况下，漏报可能是我们可以接受的，因为这换取了一定的误报降低。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;讨论完了原始的无偏损失函数，接下来我们要开始讨论有偏的代价损失函数，现有算法有以下两类常用分类代价引入策略：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;&lt;span&gt;) 分类代价在损失函数外：cyL(yF(x))；
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;) 分类代价在损 函数内：L(ycyF(x))；
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;0x2：分类代价在损失函数外(Classification cost outside of loss function)&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;这种类型的代价敏感损失将分类代价与原始损失相乘。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下表给出了各个代价敏感损失此时的最优决策&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201906/532548-20190610221551037-155882802.png&quot; alt=&quot;&quot; width=&quot;45&quot; height=&quot;20&quot;/&gt;和最优决策处的条件代价敏感风险&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201906/532548-20190610222708288-1196024655.png&quot; alt=&quot;&quot; width=&quot;140&quot; height=&quot;22&quot;/&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201906/532548-20190610222751468-1357634184.png&quot; alt=&quot;&quot; width=&quot;463&quot; height=&quot;220&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们取c+ = 1.5，c− = 0.5这种偏置组合，此时，Bayes分类器为&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201906/532548-20190610222841758-1824276469.png&quot; alt=&quot;&quot; width=&quot;275&quot; height=&quot;39&quot;/&gt;&lt;/p&gt;
&lt;p&gt;绘制各个损失函数的最优解和最优解处的条件风险：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201906/532548-20190610222914646-1018851822.png&quot; alt=&quot;&quot; width=&quot;301&quot; height=&quot;535&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看出，4种代价敏感损失均满足准则1，即最优分类器&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201906/532548-20190610222505948-1634888705.png&quot; alt=&quot;&quot; width=&quot;84&quot; height=&quot;22&quot;/&gt;为Bayes分类器。&lt;/p&gt;
&lt;p&gt;另一方面，除代价敏感SVM损失外，其余损失均不满足准则2, 最优解处的条件代价敏感风险没有在Bayes分类边界&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201906/532548-20190610222537977-129227048.png&quot; alt=&quot;&quot; width=&quot;80&quot; height=&quot;30&quot;/&gt;处取得最大值，而是有不同程度的偏移。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;0x3：分类代价在损失函数内(Classification cost inside of loss function)&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;这种类型的代价敏感损失将分类代价引入损失函数内部，将其与判决函数F相乘。&lt;/p&gt;
&lt;p&gt;下表列出了各个代价敏感损失此时的最优决策&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201906/532548-20190610221551037-155882802.png&quot; alt=&quot;&quot; width=&quot;45&quot; height=&quot;20&quot;/&gt;和最优决策处的条件代价敏感风险&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201906/532548-20190610221614053-1024322559.png&quot; alt=&quot;&quot; width=&quot;139&quot; height=&quot;21&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201906/532548-20190610221642480-926518285.png&quot; alt=&quot;&quot; width=&quot;462&quot; height=&quot;307&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们取c+ = 1.5，c− = 0.5这种偏置组合，绘制各个损失函数的最优解和最优解处的条件风险：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201906/532548-20190610221853027-1344718970.png&quot; alt=&quot;&quot; width=&quot;345&quot; height=&quot;606&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可看出，4种代价敏感损失均满足准则1和准则2，即最优分类器&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201906/532548-20190610222505948-1634888705.png&quot; alt=&quot;&quot; width=&quot;84&quot; height=&quot;22&quot;/&gt;为Bayes分类器，最优解处的条件代价敏感风险在Bayes分类边界&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201906/532548-20190610222537977-129227048.png&quot; alt=&quot;&quot; width=&quot;80&quot; height=&quot;30&quot;/&gt;处取得最大值。&lt;/p&gt;
&lt;p&gt;这种损失偏置条件下，模型的漏报会倾向于低漏报。 &lt;/p&gt;
&lt;p&gt;综上，虽然这4种损失函数代价敏感化之后并未都严格满足准则1/2，但是总体上，cost sensitive实际上扭曲了原始损失函数的函数曲线，使其发生了偏置。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Relevant Link: &lt;/strong&gt; &lt;/span&gt;  &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;jcta.cnjournals.com/cta_cn/ch/reader/create_pdf.aspx?file_no=CCTA140519&amp;amp;flag=1&amp;amp;journal_id=cta_cn&amp;amp;year_id=2015&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在具体工程项目中，因为TensorFlow/Keras并没提供原生的代价敏感函数，我们可以通过继承和重写原有的损失函数的方式，对原始的经典损失函数进行改造（函数内/函数外）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# 方式一
def vae_loss(x, x_decoded_mean):
    xent_loss &lt;/span&gt;=&lt;span&gt; objectives.binary_crossentropy(x, x_decoded_mean)
    kl_loss &lt;/span&gt;= - &lt;span&gt;0.5&lt;/span&gt; * K.mean(&lt;span&gt;1&lt;/span&gt; + z_log_sigma - K.square(z_mean) - K.exp(z_log_sigma), axis=-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; xent_loss +&lt;span&gt; kl_loss
 
vae.compile(optimizer&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;rmsprop&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, loss=&lt;span&gt;vae_loss)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Relevant Link: &lt;/strong&gt;   &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;stackoverflow.com/questions/45961428/make-a-custom-loss-function-in-keras&lt;/span&gt;
https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;blog.csdn.net/A_a_ron/article/details/79050204&lt;/span&gt;
https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;blog.csdn.net/xiaojiajia007/article/details/73274669&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Mon, 10 Jun 2019 14:45:00 +0000</pubDate>
<dc:creator>郑瀚Andrew.Hann</dc:creator>
<og:description>代价敏感学习初探 - 有偏损失函数设计</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/LittleHann/p/10587512.html</dc:identifier>
</item>
<item>
<title>我工作这十年-世界在变化 - 猿界汪汪队</title>
<link>http://www.cnblogs.com/donlianli/p/11000911.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/donlianli/p/11000911.html</guid>
<description>&lt;p align=&quot;left&quot;&gt;深夜放毒，如有错误，还请大家见谅。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;苹果公司&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;刚2008年毕业时，iphone4刚出道，那时的iphone真正属于贵族手机，相比现在还是5000多的价位，当时4000的价位真是没的说。苹果公司这十年给人的感觉就是平稳发展，波澜不惊。当然，十年前的掌舵人还是乔布斯，现在却已经物是人非了。苹果在这十年，从单独的手机设计到现在芯片设计，服务，appstore提成，真的是存活能力越来越强。总体来说，手机比10年前便宜了，业务也比原来更加丰富了。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;google&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;新起之秀，本来是最能和微软一较高低的对手，后来半路杀出了个程咬金，而且不止一个（苹果和facebook)。我觉得苹果和facebook，现在都算google的对手。但是google这十年也是发展非常不错，依靠android一下子跟微软跨入同一级别。原来在OS上面怎么都干不过微软，现在在手机界也算是独霸一方。但是google也是在这十年退出了中国，逐渐在大众视野中消失，想当初刚封google时，只封的域名，有好多国外的IP还能用，好多研发都使用IP访问，但后来IP也都封了，不得不佩服，中国的长城真的很强。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;亚马逊，也算是这10年发展起来的，不过亚马逊在中国一直水土不服。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;高通&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;要是放10年前，绝对不认识这个公司。现在高通大名鼎鼎，甚至比intel名声还大。这个主要是做硬件和SoC芯片的公司，估计还能再火几年，但是后续什么样，都不好说。intel这次真是没有抓住机会。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;三星&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;这十年，真是见证了一个世界级公司崛起，我刚工作时，三星好像只有一个anycall手机。三星的东西，给我的印象就是贵。现在仍然如此。不过，现在三星不仅仅是手机企业，在半导体，芯片和显示面板方面也是世界领先。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;我想，除了上面迅速崛起的企业外，有一些曾经一手遮天的企业，也在逐步淡出人们的视野。我们应该铭记这些公司在历史上发挥的作用。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;IBM，曾经在服务器领域几乎是垄断地位，所有的银行都采购的IBM的小型机，现在市场份额越来越小。大家更喜欢用更便宜的服务器组装功能更加强大的服务（阿里的去IOE的I就是IBM)。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;诺基亚，我刚毕业的时候就是用的诺基亚，当时买的1000多块钱，待机5天，平常2天之内基本上不用担心电池用完。诺基亚没有追的上智能手机的大潮，几乎在2年之内就淡出了人们的视野（这速度，真是让我印象深刻）。现在的90,00后，还有几个人能知道诺基亚经典的铃声和握手标志呢？除了诺基亚，让人忘记更快的估计还有摩托罗拉。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;sun公司&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;现在仍然很风光的Java语言，就是sun公司的出品。sun公司虽然影响比较小，但其对开源的贡献大于其公司存在的意义。因为sun公司，才逐步的有了开源软件，很多企业后来逐步假如开源阵营。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;毋庸置疑，柯达也算这十年没落的比较彻底的企业。日本很多科技企业已经逐步的退居到二线，比如索尼，尼康，松下，日立。这个世界变化真快，唯一不变的就是变化，如何做到始终保持领先，对企业来说真是一个巨大的挑战。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;十年老兵，写有技术深度的技术博客，微信公众号“猿界汪汪队”&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/544558/201906/544558-20190610223610101-1902804142.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 10 Jun 2019 14:41:00 +0000</pubDate>
<dc:creator>猿界汪汪队</dc:creator>
<og:description>深夜放毒，如有错误，还请大家见谅。 苹果公司 刚2008年毕业时，iphone4刚出道，那时的iphone真正属于贵族手机，相比现在还是5000多的价位，当时4000的价位真是没的说。苹果公司这十年给</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/donlianli/p/11000911.html</dc:identifier>
</item>
<item>
<title>从极大似然估计的角度理解深度学习中loss函数 - 碌碌无为的人</title>
<link>http://www.cnblogs.com/hello-ai/p/11000899.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hello-ai/p/11000899.html</guid>
<description>&lt;h2 id=&quot;从极大似然估计的角度理解深度学习中loss函数&quot;&gt;从极大似然估计的角度理解深度学习中loss函数&lt;/h2&gt;
&lt;p&gt;为了理解这一概念,首先回顾下最大似然估计的概念:&lt;br/&gt;最大似然估计常用于利用已知的样本结果,反推最有可能导致这一结果产生的参数值,往往模型结果已经确定,用于反推模型中的参数.即在参数空间中选择最有可能导致样本结果发生的参数.因为结果已知,则某一参数使得结果产生的概率最大,则该参数为最优参数.&lt;br/&gt;似然函数:&lt;span class=&quot;math display&quot;&gt;\[ l(\theta) = p(x_1,x_2,...,x_N|\theta) = \prod_{i=1}^{N}{p(x_i|\theta)}\]&lt;/span&gt;&lt;br/&gt;为了便于分析和计算,常使用对数似然函数:&lt;span class=&quot;math display&quot;&gt;\[ H(\theta) = ln[l(\theta)]\]&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;logistics-regression中常用的loss-function&quot;&gt;1. logistics regression中常用的loss function:&lt;/h3&gt;
&lt;p&gt;在logistic regression中常定义的loss function为:&lt;span class=&quot;math display&quot;&gt;\[ l(w) = -(ylog\hat y+(1-y)log(1-\hat y))\]&lt;/span&gt;&lt;br/&gt;为什么选择这个函数作为loss function? 一个原因是相比于误差平方和函数的非凸性,交叉熵函数是凸的,因此可以通过梯度下降法求得全局最优点,详细原理请参考凸优化相关理论.&lt;br/&gt;此处重点介绍另一个原因,即从最大似然估计得的角度来理解loss function的选择,Andrew Ng 也是从这个角度进行解释的.对于logsitic regression问题,我们实际上做出了如下假设,即训练样本(x,y)服从以下分布:&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ P(x,y|\theta) = \begin{cases}\sigma(z),&amp;amp;y=1 \\ 1-\sigma(z),&amp;amp;y=0\end{cases}\]&lt;/span&gt;&lt;br/&gt;其中,&lt;span class=&quot;math inline&quot;&gt;\(z = w^Tx+b\)&lt;/span&gt;,意思是,在参数&lt;span class=&quot;math inline&quot;&gt;\(\theta\)&lt;/span&gt;下,训练样本(x,y)出现的概率为&lt;span class=&quot;math inline&quot;&gt;\(P(x,y|\theta)\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;上面的概率分布函数也可以写为整体的形式:&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[p(x,y|\theta) = \sigma(z)^y(1-\sigma(z))^{1-y}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;对于极大似然估计而言,我们的目的就是在参数空间中,寻找使得&lt;span class=&quot;math inline&quot;&gt;\(p(x,y|\theta)\)&lt;/span&gt;取得最大的w和b,因为因为训练样本(x,y)已经经过采样得到了,所以使得他们出现概率最大(越接近1)的参数就是最优的参数.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对于单个样本&lt;span class=&quot;math inline&quot;&gt;\((x_i,y_i)\)&lt;/span&gt;,其对应的对数似然函数为&lt;span class=&quot;math inline&quot;&gt;\(ln[p(x_i,y_i|\theta)]= y_iln(\sigma(z_i))+(1-y_i)ln(1-\sigma(z_i))\)&lt;/span&gt;(即在参数&lt;span class=&quot;math inline&quot;&gt;\(\theta(w,b)\)&lt;/span&gt;下,&lt;span class=&quot;math inline&quot;&gt;\((x_i,y_i)\)&lt;/span&gt;出现的概率),其中,&lt;span class=&quot;math inline&quot;&gt;\(\sigma(z_i)=w^Tx_i+b\)&lt;/span&gt;.&lt;br/&gt;因为cost function 一般向小的方向优化,所以在似然函数前加上负号,就变为loss function&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;对于整个样本集来说,对应的似然函数为&lt;span class=&quot;math display&quot;&gt;\[ln(\prod_{i=1}^{N} p(x_i,y_i|\theta)) = \sum_{i=1}^N{y_iln(\sigma(z_i))+(1-y_i)ln(1-\sigma(z_i))}\]&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;softmax-regression中常用的loss-function&quot;&gt;2. softmax regression中常用的loss function:&lt;/h3&gt;
&lt;p&gt;softmax regression中常使用如下loss函数:&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ l(w) = -\sum_{i=1}^{C}y_ilog\hat y_i\]&lt;/span&gt;&lt;br/&gt;此处,C指的是样本y的维度(分类的数目),&lt;span class=&quot;math inline&quot;&gt;\(y_i\)&lt;/span&gt;指的是样本标签第i个分量,&lt;span class=&quot;math inline&quot;&gt;\(\hat y_i\)&lt;/span&gt;同义.&lt;br/&gt;接下来,同样从最大似然估计的角度进行理解.对于softmax regression,我们实际上也做出了假设,即训练样本(x,y)服从以下分布:&lt;span class=&quot;math display&quot;&gt;\[P(x,y|\theta) = \hat y_l = \sum_{i=1}^{C}y_i\hat y_i\]&lt;/span&gt;,其中l是样本标签y中唯一为1的序号&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对于单个训练样本,其对数似然函数为&lt;span class=&quot;math inline&quot;&gt;\(ln[p(x_i,y_i|\theta)] = ln(\sum_{i=1}^{C}y_i\hat y_i)\)&lt;/span&gt;,可以进一步写为&lt;span class=&quot;math inline&quot;&gt;\(ln[p(x_i,y_i|\theta)] = \sum_{i=1}^{C}y_iln(\hat y_i)\)&lt;/span&gt;,因为y中只有唯一的一个维度等于1,其余全为0,通过简单的推理就可以得到化简后的结果.取负号后,得到单样本的loss函数.&lt;/li&gt;
&lt;li&gt;对于整个训练样本集而言,其对数似然函数为&lt;span class=&quot;math display&quot;&gt;\[ln(\prod_{i=1}^{N} p(x_i,y_i|\theta)) =\sum_{j=1}^{m}\sum_{i=1}^{C}y_i^{(j)}ln(\hat y_i^{(j)})\]&lt;/span&gt;&lt;br/&gt;其中,&lt;span class=&quot;math inline&quot;&gt;\(y_i^{(j)}\)&lt;/span&gt;指的是训练样本集中第j个训练样本标签的第i个维度的值,&lt;span class=&quot;math inline&quot;&gt;\(\hat y_i^{(j)}\)&lt;/span&gt;同理.取负号求平均后,得到整个训练样本集的coss函数.&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Mon, 10 Jun 2019 14:39:00 +0000</pubDate>
<dc:creator>碌碌无为的人</dc:creator>
<og:description>从极大似然估计的角度理解深度学习中loss函数 为了理解这一概念,首先回顾下最大似然估计的概念: 最大似然估计常用于利用已知的样本结果,反推最有可能导致这一结果产生的参数值,往往模型结果已经确定,用于</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hello-ai/p/11000899.html</dc:identifier>
</item>
<item>
<title>每日一问：谈谈对 MeasureSpec 的理解 - 南尘</title>
<link>http://www.cnblogs.com/liushilin/p/11000464.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liushilin/p/11000464.html</guid>
<description>&lt;p&gt;作为一名 Android 开发，正常情况下对 View 的绘制机制基本还是耳熟能详的，尤其对于经常需要自定义 View 实现一些特殊效果的同学。&lt;/p&gt;
&lt;p&gt;网上也出现了大量的 Blog 讲 View 的 &lt;code&gt;onMeasure()&lt;/code&gt;、&lt;code&gt;onLayout()&lt;/code&gt;、&lt;code&gt;onDraw()&lt;/code&gt; 等，虽然这是一个每个 Android 开发都应该知晓的东西，但这一系列实在是太多了，完全不符合咱们短平快的这个系列初衷。&lt;/p&gt;
&lt;p&gt;那么，今天我们就来简单谈谈 &lt;code&gt;measure()&lt;/code&gt; 过程中非常重要的 &lt;code&gt;MeasureSpec&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;对于绝大多数人来说，都是知道 &lt;code&gt;MeasureSpec&lt;/code&gt; 是一个 32 位的 int 类型。并且取了最前面的两位代表 Mode，后 30 位代表大小 Size。&lt;/p&gt;
&lt;p&gt;相比也非常清楚 &lt;code&gt;MeasureSpec&lt;/code&gt; 有 3 种模式，它们分别是 &lt;code&gt;EXACTLY&lt;/code&gt;、&lt;code&gt;AT_MOST&lt;/code&gt; 和 &lt;code&gt;UNSPECIFIED&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;精确模式（MeasureSpec.EXACTLY）：在这种模式下，尺寸的值是多少，那么这个组件的长或宽就是多少，对应 &lt;code&gt;MATCH_PARENT&lt;/code&gt; 和确定的值。&lt;/li&gt;
&lt;li&gt;最大模式（MeasureSpec.AT_MOST）：这个也就是父组件，能够给出的最大的空间，当前组件的长或宽最大只能为这么大，当然也可以比这个小。对应 &lt;code&gt;WRAP_CONETNT&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;未指定模式（MeasureSpec.UNSPECIFIED）：这个就是说，当前组件，可以随便用空间，不受限制。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;通常来说，我们在自定义 View 的时候会经常地接触到 &lt;code&gt;AT_MOST&lt;/code&gt; 和 &lt;code&gt;EXACTLY&lt;/code&gt;，我们通常会根据两种模式去定义自己的 View 大小，在 &lt;code&gt;wrap_content&lt;/code&gt; 的时候使用自己计算或者设置的一个默认值。而更多的时候我们都会认为 &lt;code&gt;UNSPECIFIED&lt;/code&gt; 这个模式被应用在系统源码中。具体就体现在 &lt;code&gt;NestedScrollView&lt;/code&gt; 和 &lt;code&gt;ScrollView&lt;/code&gt; 中。&lt;/p&gt;
&lt;p&gt;我们看这样一个 XML 文件：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;android.support.v4.widget.NestedScrollView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:id=&quot;@+id/scrollView&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    tools:context=&quot;.MainActivity&quot;&amp;gt;

    &amp;lt;TextView
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        android:background=&quot;@color/colorAccent&quot;
        android:text=&quot;Hello World&quot;
        android:textColor=&quot;#fff&quot;&amp;gt;
    &amp;lt;/TextView&amp;gt;

&amp;lt;/android.support.v4.widget.NestedScrollView&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 &lt;code&gt;NestedScrollView&lt;/code&gt; 里面写了一个充满屏幕高度的 &lt;code&gt;TextView&lt;/code&gt;，为了更方便看效果，我们设置了一个背景颜色。但我们从 XML 预览中却会惊讶的发现不一样的情况。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3994917-c47baa704e846909.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们所期望的是填充满屏幕的 &lt;code&gt;TextView&lt;/code&gt;，但实际效果却和 &lt;code&gt;TextView&lt;/code&gt; 设置高度为 &lt;code&gt;wrap_content&lt;/code&gt; 如出一辙。&lt;/p&gt;
&lt;p&gt;很明显，这一定是高度测量出现的问题，如果我们的父布局是 &lt;code&gt;LinearLayout&lt;/code&gt;，很明显没有任何问题。所以问题一定出在了 &lt;code&gt;NestedScrollView&lt;/code&gt; 的 &lt;code&gt;onMeasure()&lt;/code&gt; 中。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    super.onMeasure(widthMeasureSpec, heightMeasureSpec);
    if (this.mFillViewport) {
        int heightMode = MeasureSpec.getMode(heightMeasureSpec);
        if (heightMode != 0) {
            if (this.getChildCount() &amp;gt; 0) {
                View child = this.getChildAt(0);
                LayoutParams lp = (LayoutParams)child.getLayoutParams();
                int childSize = child.getMeasuredHeight();
                int parentSpace = this.getMeasuredHeight() - this.getPaddingTop() - this.getPaddingBottom() - lp.topMargin - lp.bottomMargin;
                if (childSize &amp;lt; parentSpace) {
                    int childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec, this.getPaddingLeft() + this.getPaddingRight() + lp.leftMargin + lp.rightMargin, lp.width);
                    int childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(parentSpace, 1073741824);
                    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
                }
            }

        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于我们并没有在外面设置 &lt;code&gt;mFillViewport&lt;/code&gt; 这个属性，所以并不会进入到 if 条件中，我们来看看 &lt;code&gt;NestedScrollView&lt;/code&gt; 的 super &lt;code&gt;FrameLayout&lt;/code&gt; 的 &lt;code&gt;onMeasure()&lt;/code&gt; 做了什么。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    int count = getChildCount();

    final boolean measureMatchParentChildren =
            MeasureSpec.getMode(widthMeasureSpec) != MeasureSpec.EXACTLY ||
            MeasureSpec.getMode(heightMeasureSpec) != MeasureSpec.EXACTLY;
    mMatchParentChildren.clear();

    int maxHeight = 0;
    int maxWidth = 0;
    int childState = 0;

    for (int i = 0; i &amp;lt; count; i++) {
        final View child = getChildAt(i);
        if (mMeasureAllChildren || child.getVisibility() != GONE) {
            measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, 0);
            final LayoutParams lp = (LayoutParams) child.getLayoutParams();
            maxWidth = Math.max(maxWidth,
                    child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);
            maxHeight = Math.max(maxHeight,
                    child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);
            childState = combineMeasuredStates(childState, child.getMeasuredState());
            if (measureMatchParentChildren) {
                if (lp.width == LayoutParams.MATCH_PARENT ||
                        lp.height == LayoutParams.MATCH_PARENT) {
                    mMatchParentChildren.add(child);
                }
            }
        }
    }

    // ignore something...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意其中的关键方法 &lt;code&gt;measureChildWithMargins()&lt;/code&gt;，这个方法在 &lt;code&gt;NestedScrollView&lt;/code&gt; 中得到了完全重写。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;protected void measureChildWithMargins(View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed) {
    MarginLayoutParams lp = (MarginLayoutParams)child.getLayoutParams();
    int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, this.getPaddingLeft() + this.getPaddingRight() + lp.leftMargin + lp.rightMargin + widthUsed, lp.width);
    int childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(lp.topMargin + lp.bottomMargin, 0);
    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
}   &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们看到其中有句非常关键的代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;int childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(lp.topMargin + lp.bottomMargin, 0);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;NestedScrollView&lt;/code&gt; 直接无视了用户设置的 MODE，直接采用了 &lt;code&gt;UNSPECIFIED&lt;/code&gt; 做处理。&lt;strong&gt;经过测试发现，当我们重写 &lt;code&gt;NestedScrollView&lt;/code&gt; 的这句代码，并且把 MODE 设置为 &lt;code&gt;EXACTLY&lt;/code&gt; 的时候，我们得到了我们想要的效果，我已经查看 Google 的源码提交日志，并没有找到原因。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;实际上，绝大多数开发之前遇到的嵌套 &lt;code&gt;ListView&lt;/code&gt; 或者 &lt;code&gt;RecylerView&lt;/code&gt; 只展示一行也是由于这个问题，解决方案就是重写 &lt;code&gt;NestedScrollView&lt;/code&gt; 的 &lt;code&gt;measureChildWithMargins()&lt;/code&gt; 或者重写 &lt;code&gt;ListView&lt;/code&gt; 或者 &lt;code&gt;RecylerView&lt;/code&gt; 的 &lt;code&gt;onMeasure()&lt;/code&gt; 方法让其展示正确的高度。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我起初猜想是只有 &lt;code&gt;UNSPECIFIED&lt;/code&gt; 才能实现滚动效果，但很遗憾并不是这样的。所以在这里抛出这个问题，希望有知情人士能一起讨论。&lt;/p&gt;
</description>
<pubDate>Mon, 10 Jun 2019 13:38:00 +0000</pubDate>
<dc:creator>南尘</dc:creator>
<og:description>作为一名 Android 开发，正常情况下对 View 的绘制机制基本还是耳熟能详的，尤其对于经常需要自定义 View 实现一些特殊效果的同学。 网上也出现了大量的 Blog 讲 View 的 、`o</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/liushilin/p/11000464.html</dc:identifier>
</item>
</channel>
</rss>