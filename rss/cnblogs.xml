<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>行为型模式：状态模式 - LieBrother</title>
<link>http://www.cnblogs.com/liebrother/p/10527850.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liebrother/p/10527850.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;http://www.liebrother.com/upload/8ff9f607e5fe4c8c8be16615a0313abe_0037_01.jpg&quot; alt=&quot;景色&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;十一大行为型模式之八：状态模式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;姓名&lt;/strong&gt; ：状态模式&lt;br/&gt;&lt;strong&gt;英文名&lt;/strong&gt; ：State Pattern&lt;br/&gt;&lt;strong&gt;价值观&lt;/strong&gt; ：有啥事让状态我来维护&lt;br/&gt;&lt;strong&gt;个人介绍&lt;/strong&gt; ：&lt;br/&gt;Allow an object to alter its behavior when its internal state changes.The object will appear to change its class.&lt;br/&gt;当一个对象内在状态改变时允许其改变行为，这个对象看起来像改变了其类。&lt;br/&gt;（来自《设计模式之禅》）&lt;/p&gt;
&lt;h2 id=&quot;你要的故事&quot;&gt;你要的故事&lt;/h2&gt;
&lt;p&gt;现在有好多个人贷款软件，比如：支付宝、360借条(打广告。。。)等等。贷款会有一个用户状态流程，游客-&amp;gt;注册用户-&amp;gt;授信用户-&amp;gt;借款用户(这里简化了状态，只用 4 个)。每个状态拥有的权限不一样，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.liebrother.com/upload/1ce238b0c01a463380b4367d6467c28f_003702.jpg&quot; alt=&quot;状态&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上图可以看到，一个用户有 3 种行为，分别是注册、授信、借款。当注册成功后，用户的状态就从『游客』改变为『注册用户』；当授信成功后，用户的状态就从『注册用户』改变为『授信用户』；当借款成功后，用户的状态就从『授信用户』改变为『借款用户』。现在我们就来实现用户注册、授信、借款的过程，因为每个状态的权限不一样，所以这里需要根据用户的状态来限制用户行为。&lt;/p&gt;
&lt;p&gt;很快，我们就完成下面的代码。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class User {
    private String state;

    public String getState() {
        return state;
    }

    public void setState(String state) {
        this.state = state;
    }

    public void register() {
        if (&quot;none&quot;.equals(state)) {
            System.out.println(&quot;游客。注册中。。。&quot;);
        }else if (&quot;register&quot;.equals(state)) {
            System.out.println(&quot;注册用户。不需要再注册。&quot;);
        } else if (&quot;apply&quot;.equals(state)) {
            System.out.println(&quot;授信用户。不需要再注册。&quot;);
        } else if (&quot;draw&quot;.equals(state)) {
            System.out.println(&quot;借款用户。不需要再注册。&quot;);
        }
    }

    public void apply() {
        if (&quot;none&quot;.equals(state)) {
            System.out.println(&quot;游客。不能申请授信。&quot;);
        }else if (&quot;register&quot;.equals(state)) {
            System.out.println(&quot;注册用户。授信申请中。。。&quot;);
        } else if (&quot;apply&quot;.equals(state)) {
            System.out.println(&quot;授信用户。不需要再授信。&quot;);
        } else if (&quot;draw&quot;.equals(state)) {
            System.out.println(&quot;借款用户。不需要再授信。&quot;);
        }
    }

    public void draw(double money) {
        if (&quot;none&quot;.equals(state)) {
            System.out.println(&quot;游客。申请借款【&quot; + money + &quot;】元。不能申请借款。&quot;);
        } else if (&quot;register&quot;.equals(state)) {
            System.out.println(&quot;注册用户。申请借款【&quot; + money + &quot;】元。还没授信，不能借款。&quot;);
        } else if (&quot;apply&quot;.equals(state)) {
            System.out.println(&quot;授信用户。申请借款【&quot; + money + &quot;】元。申请借款中。。。&quot;);
        } else if (&quot;draw&quot;.equals(state)) {
            System.out.println(&quot;授信用户。申请借款【&quot; + money + &quot;】元。申请借款中。。。&quot;);
        }
    }
}

public class NoStateTest {

    public static void main(String[] args) {
        User user = new User();
        user.setState(&quot;register&quot;);
        user.draw(1000);
    }

}

打印结果：
注册用户。申请借款【1000.0】元。还没授信，不能借款。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面代码实现了用户 register (注册)，apply (授信)，draw (借款) 这 3 种行为，每个行为都会根据状态 state 来做权限控制。看起来有点繁琐，扩展性不高，假设新增了一个状态，那么注册、授信、借款这 3 种行为的代码都要修改。下面通过&lt;code&gt;状态模式&lt;/code&gt;来解决这个问题。&lt;/p&gt;
&lt;p&gt;我们把&lt;code&gt;状态&lt;/code&gt;给抽出来，作为一个接口，因为在每种状态中都可能有注册、授信、借款行为，所以把这 3 个行为作为&lt;code&gt;状态&lt;/code&gt;接口的方法，让每个状态子类都实现相应的行为控制。如下代码所示。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;interface State {

    void register();

    void apply();

    void draw(double money);
}

/**
 * 游客
 */
class NoneState implements State {

    @Override
    public void register() {
        System.out.println(&quot;游客。注册中。。。&quot;);
    }

    @Override
    public void apply() {
        System.out.println(&quot;游客。不能申请授信。&quot;);
    }

    @Override
    public void draw(double money) {
        System.out.println(&quot;游客。申请借款【&quot; + money + &quot;】元。不能申请借款。&quot;);
    }
}

/**
 * 注册状态
 */
class RegisterState implements State {

    @Override
    public void register() {
        System.out.println(&quot;注册用户。不需要再注册。&quot;);
    }

    @Override
    public void apply() {
        System.out.println(&quot;注册用户。授信申请中。。。&quot;);
    }

    @Override
    public void draw(double money) {
        System.out.println(&quot;注册用户。申请借款【&quot; + money + &quot;】元。还没授信，不能借款。&quot;);
    }
}

/**
 * 授信状态
 */
class ApplyState implements State {

    @Override
    public void register() {
        System.out.println(&quot;授信用户。不需要再注册。&quot;);
    }

    @Override
    public void apply() {
        System.out.println(&quot;授信用户。不需要再授信。&quot;);
    }

    @Override
    public void draw(double money) {
        System.out.println(&quot;授信用户。申请借款【&quot; + money + &quot;】元。申请借款中。。。&quot;);
    }
}

/**
 * 借款状态
 */
class DrawState implements State {

    @Override
    public void register() {
        System.out.println(&quot;借款用户。不需要再注册。&quot;);
    }

    @Override
    public void apply() {
        System.out.println(&quot;借款用户。不需要再授信。&quot;);
    }

    @Override
    public void draw(double money) {
        System.out.println(&quot;申请借款【&quot; + money + &quot;】元。申请借款中。。。&quot;);
    }
}

class User1 {
    private State state;

    public State getState() {
        return state;
    }

    public void setState(State state) {
        this.state = state;
    }

    public void register() {
        this.state.register();
    }

    public void apply() {
        this.state.apply();
    }

    public void draw(double money) {
        this.state.draw(money);
    }
}

public class StateTest {
    public static void main(String[] args) {
        User1 user1 = new User1();
        user1.setState(new RegisterState());
        user1.apply();
        user1.draw(1000);
        user1.setState(new ApplyState());
        user1.draw(2000);
    }

}


打印结果：
注册用户。授信申请中。。。
注册用户。申请借款【1000.0】元。还没授信，不能借款。
授信用户。申请借款【2000.0】元。申请借款中。。。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看上面代码，我们抽象了 &lt;code&gt;State&lt;/code&gt; 接口，4 种状态分别用 &lt;code&gt;NoneState&lt;/code&gt; (游客)、&lt;code&gt;RegisterState&lt;/code&gt; (注册)、&lt;code&gt;ApplyState&lt;/code&gt; (授信)、&lt;code&gt;DrawState&lt;/code&gt; (借款) 表示。而每个状态都有 3 种行为，它们各自对这些行为进行权限控制。这样子实现可以让权限逻辑分离开，分散到每个状态里面去，如果以后要业务扩展，要新增状态，那就很方便了，只需要再实现一个状态类就可以，不会影响到其他代码。这也是为什么《阿里巴巴 Java 开发手册》里面讲的，当超过 3 层的 &lt;code&gt;if-else&lt;/code&gt; 的逻辑判断代码，推荐用状态模式来重构代码。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;状态模式&lt;/code&gt; 很好的减低了代码的复杂性，从而提高了系统的可维护性。在业务开发中可以尝试使用，比如在迭代开发中，业务逻辑越来越复杂，从而不得不使用很多 &lt;code&gt;if-else&lt;/code&gt; 语句来实现时，就可以考虑一下是不是可以用 &lt;code&gt;状态模式&lt;/code&gt; 来重构，特别是一些有状态流程转换方面的业务。看到这篇文章，想想工作中是不是有些复杂的代码可以重构，赶紧行动起来。&lt;/p&gt;
&lt;p&gt;推荐阅读：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/1DqPjUZNT5UuRrZwl5QjqQ&quot;&gt;行为型模式：观察者模式&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/ItQUqfzzXw4387PVK0ib_g&quot;&gt;行为型模式：迭代器模式&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/jaejRfi4zAtnMEL8Bf0avg&quot;&gt;行为型模式：策略模式&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;设计模式系列文章持续更新中，欢迎关注公众号 &lt;strong&gt;LieBrother&lt;/strong&gt;，一起交流学习。&lt;/p&gt;
</description>
<pubDate>Wed, 13 Mar 2019 23:18:00 +0000</pubDate>
<dc:creator>LieBrother</dc:creator>
<og:description>十一大行为型模式之八：状态模式。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liebrother/p/10527850.html</dc:identifier>
</item>
<item>
<title>后缀自动机 - kgxpbqbyt</title>
<link>http://www.cnblogs.com/kgxw0430/p/10527844.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kgxw0430/p/10527844.html</guid>
<description>&lt;h3 id=&quot;字符串新算法新自闭&quot;&gt;字符串：新算法，新自闭&lt;/h3&gt;
&lt;hr/&gt;&lt;ul&gt;&lt;li&gt;给定字符串s的后缀自动机是一个接受所有字符串s的后缀的最小DFA（确定性有限自动机或确定性有限状态自动机）。&lt;/li&gt;
&lt;li&gt;性质：
&lt;ul&gt;&lt;li&gt;后缀自动机是一张有向无环图。顶点是状态，边是状态之间的转移。&lt;/li&gt;
&lt;li&gt;初始状态为&lt;span class=&quot;math inline&quot;&gt;\(t_0\)&lt;/span&gt;,它是这张图的源点。&lt;/li&gt;
&lt;li&gt;每个转移代表一个字母。从一个顶点出发的所有转移都不同。&lt;/li&gt;
&lt;li&gt;一个或多个状态为终止状态。如果我们从初始状态出发，最终转移到了一个终止状态，所形成的一个串必定是s的一个后缀。&lt;/li&gt;
&lt;li&gt;后缀自动机是所有满足以上条件的自动机中顶点数最少的一个。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;几个小理解：
&lt;ul&gt;&lt;li&gt;后缀自动机上每一个节点代表了一个endpos等价类，并且从&lt;span class=&quot;math inline&quot;&gt;\(t_0\)&lt;/span&gt;走到当前节点形成的子串一定是这个节点所代表的endpos等价类中长度最长的子串。&lt;/li&gt;
&lt;li&gt;每一条返祖边都对应了parent树上的一条边。且返祖边练的一定是不属于当前endpos等价类的一个最长后缀。&lt;/li&gt;
&lt;li&gt;在parent树上，父节点一定是子节点的后缀。&lt;/li&gt;
&lt;li&gt;构图是为了实现，从初始状态走可以访问到s所有的后缀。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;tjoi2015&quot;&gt;&lt;a href=&quot;https://www.luogu.org/problemnew/show/P3975&quot;&gt;TJOI2015&lt;/a&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;t=0，求本质不同的第k小串。
&lt;ul&gt;&lt;li&gt;想要保证字典序的一个顺序，那我们肯定是在后缀自动机上搞事情。因为在初始状态转移的时候，可以保证字典序。&lt;/li&gt;
&lt;li&gt;而后缀自动机上每一个节点维护的是什么？一个节点代表一个等价类，同时它也代表了从初始状态到这个点所形成的一个子串。我们可以维护经过每一个点有多少个串。即以这个子串为前缀有多少个串。设&lt;span class=&quot;math inline&quot;&gt;\(sum[i]\)&lt;/span&gt;表示经过i节点的子串数量，如果我们处理出了sum数组，那么直接类似线段树求第K大，二分查找就好了。&lt;/li&gt;
&lt;li&gt;怎么处理出sum数组？考虑后缀自动机是一张有向无环图，我们按照拓扑序跑一遍是可以求出sum数组的。并且我们知道，一个节点向另一个节点连一条边，那么这个节点的长度一定小于另一个点的长度。因此我们仍然用桶按照长度从小到大排序，倒序处理，和拓扑序是等价的。（注意这个处理与求siz数组的不同）。初始值，sum=siz=1。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;t=1，相同的子串出现在不同位置，算作不同子串。那么初始值的时候，siz还是siz，不强制赋值为1就好了。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;coding&quot;&gt;&lt;span&gt;Coding&lt;/span&gt;&lt;/h4&gt;
&lt;pre class=&quot;c++11&quot;&gt;
&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
#define rint register int
#define ll long long
using namespace std;
const int N=1e6+10;
int t,n,tot=1,la=1,siz[N],ne[N][30],fa[N],len[N],c[N],A[N];
char s[N];ll sum[N],k;
void add(int c){
    rint p=la,np=la=++tot;siz[tot]=1;len[tot]=len[p]+1;
    for(;p&amp;amp;&amp;amp;!ne[p][c];p=fa[p]) ne[p][c]=np;
    if(!p) fa[np]=1;
    else{
        rint q=ne[p][c];
        if(len[p]+1==len[q]) fa[np]=q;
        else{
            rint nq=++tot;
            memcpy(ne[nq],ne[q],sizeof(ne[q]));
            fa[nq]=fa[q];
            fa[q]=fa[np]=nq;
            len[nq]=len[p]+1;
            for(;p&amp;amp;&amp;amp;ne[p][c]==q;p=fa[p]) ne[p][c]=nq;
        }
    }
}
void dfs(int p,int num){
    if(num&amp;lt;=siz[p]) return;
    num-=siz[p];
    for(int i=0;i&amp;lt;26;++i){
        if(sum[ne[p][i]]&amp;gt;=num){
            putchar(i+'a');
            dfs(ne[p][i],num);
            return ;
        }else num-=sum[ne[p][i]];
    }
}
int main(){
    scanf(&quot;%s&quot;,s+1);
    scanf(&quot;%d %lld&quot;,&amp;amp;t,&amp;amp;k);
    n=strlen(s+1);
    for(rint i=1;i&amp;lt;=n;++i) add(s[i]-'a');
    for(rint i=1;i&amp;lt;=tot;++i) c[len[i]]++;
    for(rint i=1;i&amp;lt;=tot;++i) c[i]+=c[i-1];
    for(rint i=1;i&amp;lt;=tot;++i) A[c[len[i]]--]=i;
    for(rint i=tot;i&amp;gt;0;--i){
        rint p=A[i];
        siz[fa[p]]+=siz[p];
    }
    for(rint i=1;i&amp;lt;=tot;++i) t==0?(sum[i]=siz[i]=1):(sum[i]=siz[i]);
    siz[1]=sum[1]=0;
    for(rint i=tot;i&amp;gt;0;--i){
        rint p=A[i];
        for(int j=0;j&amp;lt;26;++j) sum[p]+=sum[ne[p][j]];
    }
    if(sum[1]&amp;lt;k) cout&amp;lt;&amp;lt;-1&amp;lt;&amp;lt;endl;
    else dfs(1,k),cout&amp;lt;&amp;lt;endl;
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 13 Mar 2019 22:50:00 +0000</pubDate>
<dc:creator>kgxpbqbyt</dc:creator>
<og:description>字符串：新算法，新自闭 给定字符串s的后缀自动机是一个接受所有字符串s的后缀的最小DFA（确定性有限自动机或确定性有限状态自动机）。 性质： 后缀自动机是一张有向无环图。顶点是状态，边是状态之间的转移</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kgxw0430/p/10527844.html</dc:identifier>
</item>
<item>
<title>时间规划在Optaplanner上的实现 - kentzhang</title>
<link>http://www.cnblogs.com/kentzhang/p/10527729.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kentzhang/p/10527729.html</guid>
<description>&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;36mo2&quot; data-offset-key=&quot;2fag8-0-0&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;2fag8-0-0&quot;&gt;　　在与诸位交流中，使用较多的生产计划和路线规划场景中，大家最为关注的焦点是关于时间的处理问题。确实，时间这一维度具有一定的特殊性。因为时间是一维的，体现为通过图形表示时，它仅可以通过一条有向直线来表达它的时刻和方向。相对而言，空间则可以存在多维，例如二维坐标，三维空间等，甚至在生产计划的规划场景中，各种资源可以表示为多个维度。因此，时间的一维特性，决定了在规划过程中，需要处理它的方法也具有一定的特殊性和局限性。本文将讨论通过Optaplanner实现规划过程中，对于时间方面的处理方式。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;36mo2&quot; data-offset-key=&quot;b5dbi-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;b5dbi-0-0&quot;&gt;在众多规划优化场景中，可以归纳为两种情况的规划，分别是单一维的空间维度规划，和同时存在空间与时间两个维度进行规划。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;36mo2&quot; data-offset-key=&quot;a7v1l-0-0&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;a7v1l-0-0&quot;&gt;其中第一种情况，仅对一个维度进行规划的场景，我们可以把这一维归纳为，仅对空间维度的规划。例如八王后(N Qeen)问题，其规划的目标是为每个王后找个适当的位置，位置就是一个最为直观的空间概念，因此它是一个很明确直观的空间规划问题。而另外一些从直接字面意义上可能跟空间并没有直接的关系，但其实也可以将它视作仅有一个空间维度的规划。这类规划的一个特点规划目标与目标之间没有时序关系，即时间维度是不考虑的，例如。有一些存在时间概念的问题，其实也可以转化为唯一空间维度的规划，从而将问题简化。例如排班过程中，将每个人员安排到指定的班次，虽然班次是一个时间上概念的概念，但实际对这个问题进行排班设计的时候，我们可以将时间转化为类似空间的形式处理。更直观的说法，将班次分布在时间轴上，按时间轴来看，各个班次就是时间轴上不同位置的区间，从而令问题简化。因此，这类规则更严格地说，可以理解为无论是空间还是时间上的规划，都可以转化、展开为单一唯度的规划问题，通过使用空间规划的方法进行规划建模求解；即使是时间规划（例如排班）也不例外。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;36mo2&quot; data-offset-key=&quot;3jv92-0-0&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;3jv92-0-0&quot;&gt;　　另外一种规划，则需要同时考虑空间与时间两个维度协同规划。如生产计划、带时间窗口的车辆路线规划等问题，就是其中的典型。以生产计划为例，在空间维度，需要将一个任务分配到合理的机台，即是空间上的规划。然而，生产计划问题的另一个需求是，确定了机台后，还要确定到底这个任务应该在什么时候开始，什么时候结束；哪个任务需要在哪个任何完成后才能开始等等。这些时序逻辑相关的引出的问题，均属于时间规划问题。时间维度可以与空间维度一起，确定一个活动的时空坐标。此坐标是一个逻辑上抽象的概念。以生产计划为例，两个维度均通过平面图形来表示时，可以把计划中的每个任务，分配在指定机台的指定时间区间上，通过下图可以看到，这个示意图的水平轴（X轴）表示时间，从这个方向可以看出一个任务哪个时刻开始，持续多久，哪个时刻结束。以及与该任务同处于一个空间（机台，或产线，或车间）上的前后任务的接续关系。垂直轴（Y轴）表示空间，表示它被分配到哪个机台上执行。如下图：&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;div&gt;
&lt;div&gt;
&lt;div&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic1.zhimg.com/80/v2-ece7a4b0334e5401ade9eece54c0215f_hd.png&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;936&quot; data-rawheight=&quot;408&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;https://pic1.zhimg.com/v2-ece7a4b0334e5401ade9eece54c0215f.png&quot; data-watermark-src=&quot;https://pic4.zhimg.com/v2-18deee4cb455c13577679bda6a840ec2.jpg&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;36mo2&quot; data-offset-key=&quot;66me2-0-0&quot; readability=&quot;13&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;66me2-0-0&quot;&gt;　　&lt;span data-offset-key=&quot;66me2-0-1&quot;&gt;针对不同的时间规划要求，Optaplanner提供了3常用的规划模式，分别是时间槽模式- Time Slot Pattern，时间粒模式 - Time Grain Pattern, 和时间链模式 - Chained Through Time Pattern.下面分别对这三种模式的特征，适用场景和使用方法进行详细介绍。因为翻译准确度原因（对自己的英文水平缺乏自信:P), 下文介绍中均直接使用Time Slot, Time Grain 和 Chained Through Time.以避免本文件的翻译不当造成误解。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;h2 class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;a2ue9-0-0&quot;&gt;&lt;span data-offset-key=&quot;a2ue9-0-0&quot;&gt;时间槽模式 - Time slot&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;36mo2&quot; data-offset-key=&quot;2et15-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;2et15-0-0&quot;&gt;&lt;span data-offset-key=&quot;2et15-0-1&quot;&gt;Time Slot在应用时有一些适用条件,满足以下所有条件，才适用：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;ol class=&quot;public-DraftStyleDefault-ol&quot; data-offset-key=&quot;85eic-0-0&quot; readability=&quot;0&quot;&gt;&lt;li class=&quot;Editable-styled public-DraftStyleDefault-orderedListItem public-DraftStyleDefault-reset public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;36mo2&quot; data-offset-key=&quot;85eic-0-0&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;85eic-0-0&quot;&gt;规划实体中的规划变量是一个时间区间；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;Editable-styled public-DraftStyleDefault-orderedListItem public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;36mo2&quot; data-offset-key=&quot;be9p4-0-0&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;be9p4-0-0&quot;&gt;一个规划变量的取值最多仅可分配一个时间区间；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;Editable-styled public-DraftStyleDefault-orderedListItem public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;36mo2&quot; data-offset-key=&quot;cutep-0-0&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;cutep-0-0&quot;&gt;规划变量对应的时间区间是等长的。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;36mo2&quot; data-offset-key=&quot;bk3di-0-0&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;bk3di-0-0&quot;&gt;　　对于规划值范围各个时间段，将其转换为空间上的概念更为直观。将时间用一个水平轴表示，在轴上划分大小固定的区间，这些区间则可以作为规划过程中的取值范围；在设计时，把这些区间定义成ValueRange。适用于Time slot模式情况，有制定中小学课程表、考试安排等问题。因为大学或公开课程的计划安排，除了排定时间外，可能还需要确定具体的地点，也就是空间维度的规划。此类问题通常需要将时间和空间分开来考虑，但其中的时间纬可以通过Time slot模式转化为与空间规划一样的问题，从而令问题简化。引用Optaplanner开发手册的一张图可以清楚地看到，每一个规划实体只需要一个时间区间，且区间长短是相同的，(如下图）。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;div&gt;
&lt;div&gt;
&lt;div&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic2.zhimg.com/80/v2-ebf0432dcf776f84b6df1256e473f4bc_hd.png&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;762&quot; data-rawheight=&quot;199&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;https://pic2.zhimg.com/v2-ebf0432dcf776f84b6df1256e473f4bc.png&quot; data-watermark-src=&quot;https://pic2.zhimg.com/v2-016dc52e47c099b45b99580c53ebec1b.jpg&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-imageUploader&quot;&gt;
&lt;div class=&quot;Editable-imageUploader-layout is-fullWidth FocusPlugin--unfocused&quot; readability=&quot;7.5&quot;&gt;

&lt;div class=&quot;Editable-imageUploader-placeholder&quot; readability=&quot;10&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/148283/201903/148283-20190313235823500-1869098536.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt; &lt;span data-offset-key=&quot;fti4b-0-0&quot;&gt; &lt;/span&gt;　　从图中可以看出，每门课所需的时间都是固定一小时。具体到这个模式的应用,因为其原理、结构和实现起来都相当简单，本文不通过示例详细讲解了。可参考示例包中的Course timetabling中的设计和代码。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
&lt;h2 class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;fhl0c-0-0&quot;&gt;&lt;span data-offset-key=&quot;fhl0c-0-0&quot;&gt; &lt;/span&gt;时间粒模式 - Time Grain&lt;/h2&gt;
&lt;/p&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;36mo2&quot; data-offset-key=&quot;5ppkt-0-0&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;5ppkt-0-0&quot;&gt;　　&lt;span data-offset-key=&quot;5ppkt-0-1&quot;&gt;在相当多运筹优化场景中，需要规划的时间长短是不固定的，不同的任务其所需的时间有长短之分。这种需求下，若使用Time slot模式就无法实现时间上的精确规划。那些就要使用更灵活，时间粒度更小的Time Grain模式。从Time Grain模式的名称中的Grain可以推测到，此模式是将时间细分成一个一个颗粒并应用于规划。例如可以设定为每1分钟，5分钟，30分钟，1小时等固定的长度，为一个Grain的长度。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;36mo2&quot; data-offset-key=&quot;66t32-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;66t32-0-0&quot;&gt;Time Grain模式适用条件：&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;ol class=&quot;public-DraftStyleDefault-ol&quot; data-offset-key=&quot;eugn9-0-0&quot; readability=&quot;-1&quot;&gt;&lt;li class=&quot;Editable-styled public-DraftStyleDefault-orderedListItem public-DraftStyleDefault-reset public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;36mo2&quot; data-offset-key=&quot;eugn9-0-0&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;eugn9-0-0&quot;&gt;规划变量是时间区间；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;Editable-styled public-DraftStyleDefault-orderedListItem public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;36mo2&quot; data-offset-key=&quot;augiq-0-0&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;augiq-0-0&quot;&gt;业务上对应于规划变量的时间区间可以不等长，但必须是Grain的倍数。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;36mo2&quot; data-offset-key=&quot;8h6rl-0-0&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;8h6rl-0-0&quot;&gt; &lt;/span&gt;　　例如通过Outlook的日历功能创建会议时，默认情况下每个会议的时间，是0.5小时的倍数，也就是一个会议至少是0.5小时，或者是1小时，或1.5小时如此类推。当然如果你不使用Outlook的默认时间精度，也可以将时间精度定到分钟，那么也就表示，会议的时间是1分钟的倍数。只不过针对人的日常活动在时间上的精度，以分钟作为精确度其意义不太大。就如9:01分开会跟9:00开会，对于人类的活动能力来说，正常情况下不存在任何区别。因为你从办公室去到会议室，都可能需要花费1分钟了；所以outlook里默认的是半小时。那么这个最小的时候单位 - 半小时，在Time Grain模式中，就被称为一个Time Grain，以下简称Grain。可以先从开发手册的图中看到Time Grain模式所表达的意义，如下图。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;36mo2&quot; data-offset-key=&quot;5e2vo-0-0&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;5e2vo-0-0&quot; readability=&quot;10&quot;&gt;&lt;span data-offset-key=&quot;5e2vo-0-0&quot;&gt;&lt;span data-offset-key=&quot;5e2vo-0-0&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/148283/201903/148283-20190313235958512-995430342.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;
&lt;p&gt; 　　&lt;span data-offset-key=&quot;blorp-0-1&quot;&gt;从上图可以看到，每个会议所需的时间长度是不相等的，但是其长度必然是一个Time Grain的倍数，从图中上方的时间刻度可以比划出一个TimeGrain应该是15分钟。例如Sales meeting占用了4个Time Grain，即时长1小时。Time Grain模式的使用会相对Time Slot更灵活，适用范围会更广。通过设置可知，其实适用于Time Slot模型的情形，是完全可以通过TimeGrain模式实现的，只是实现起来会更复杂一些。那么Time Grain模式的设计要点在哪里呢？要了解其设计原理，就得先掌握Time Grain的结构及其对时间的提供方法。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;36mo2&quot; data-offset-key=&quot;1pnud-0-0&quot; readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;1pnud-0-0&quot;&gt;　　&lt;span data-offset-key=&quot;1pnud-0-1&quot;&gt;Time Grain中的重点在于一个Grain的设计，与Time Slot中的slot一样，Time Grain中的Grain表示的也是一个时间区间，只不过它所表达的意义不仅在于一个Time Grain的时间区间内，每个Grain的序号也是关键因素，当一个Grain被分配到一个规划变量时，Grain的序号决定了它与时间轴的映射位置。在生产计划中，若一个Grain被分配到一个任务时，表示任务起止于这个Grain的开始时刻。 即该任务的开始时间是哪个Grain内对应的时间区间内，那么这个Grain的开始时间，就是这个任务的开始时间；通过这个任务的长度，推算出它需要占用多少个Grain, 进而推算出它的结束时间会在哪个Grain内，那么这个Grain的结束时间，即是这个任务的结束时间。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;36mo2&quot; data-offset-key=&quot;7ifid-0-0&quot; readability=&quot;14&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;7ifid-0-0&quot;&gt;还是以上图为例，其中的Sales meeting,它的起始是在grain0内，grain0的起始时间是8:00，那么这个会议的起始时间就是8:00。这个会议的长度是1小时，所以它占用了4个Grain,因此，第4个Grain的结束时间就是会议的结束时间，也就是图中Grain3的结束时间 - 9:00，是这个会议的结束时间。进一步分析也知，若这个会议时长是1:10, 那么它的结束时间将会落于gran4内（第5个grain), 那么它的结束时间就是grain4的结束时间 - 9:15. 因此，总结起来，我们在实现这个模式的时候有以下要点在设计时需要注意：&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;ol class=&quot;public-DraftStyleDefault-ol&quot; data-offset-key=&quot;bp70j-0-0&quot; readability=&quot;3&quot;&gt;&lt;li class=&quot;Editable-styled public-DraftStyleDefault-orderedListItem public-DraftStyleDefault-reset public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;36mo2&quot; data-offset-key=&quot;bp70j-0-0&quot; readability=&quot;3&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;bp70j-0-0&quot;&gt;设计好每个Grain的粒度，也就是时间长度。并不是粒度越细越好，例如以1秒钟作为一个粒度，是不是就可以将任务的时间精度控制在1级呢？理论上是可以的，但日常使用中不太可行。因为这样的设计会产生过量的Grain,Grain就是Value Range，当可选值的数量过多时，整个规划问题的规模就会增大，其时间复杂度就会指数级上升，从而令优化效果降低。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;Editable-styled public-DraftStyleDefault-orderedListItem public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;36mo2&quot; data-offset-key=&quot;69qa9-0-0&quot; readability=&quot;3&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;69qa9-0-0&quot;&gt;定义好每个Grain与绝对时间的映射关系。这个模式中的Time Grain其时间上是相对的。如何理解呢？就是说，这个模式在运行的时候，会把初始化出来的Grain对象列表，以Index（Grain的序号）为序形成一个连接的时间粒的序列。列表中每一个具体的Grain对应的绝对时间是什么时候呢？是以第一个Grain作为参照推算出来的。例如上图中的第一个Grain - grain0它的起始时间是8:00, 那么第6个grain - grain5的起始时间就是9:30，这个时间是通过grain0加上6个grain的时长推算出来的，也就是8:00加上1.5小时，因此得到的是9:30。因此，当你设定Time Grain与绝对时间的对应关系时，就需要从业务上考虑，grain0的起始是什么时刻；它决定了后续所有任务的时间。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;36mo2&quot; data-offset-key=&quot;4k0pv-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;4k0pv-0-0&quot;&gt;　　为了防止同一空间上，存两个任务时间重叠的问题，可以根据其分配的Grain进行判断。如示例Meeting scheduling中关于时间重叠的判断，可以参考MeetingAssignment类中的calculateOverlap方法，见以下代码。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;36mo2&quot; data-offset-key=&quot;4dbtq-0-0&quot;&gt;
&lt;div class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;4dbtq-0-0&quot; readability=&quot;8.5&quot;&gt;&lt;span data-offset-key=&quot;4dbtq-0-0&quot;&gt;&lt;span data-offset-key=&quot;4dbtq-0-0&quot;&gt; &lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; calculateOverlap(MeetingAssignment other) {
　　&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (startingTimeGrain == &lt;span&gt;null&lt;/span&gt; || other.getStartingTimeGrain() == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
　　　　&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
　　}&lt;br/&gt;　　&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; start =&lt;span&gt; startingTimeGrain.getGrainIndex();
　　&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; end = start +&lt;span&gt; meeting.getDurationInGrains();
　　&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; otherStart =&lt;span&gt; other.startingTimeGrain.getGrainIndex();
　　&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; otherEnd = otherStart +&lt;span&gt; other.meeting.getDurationInGrains();
 
　　&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (end &amp;lt;&lt;span&gt; otherStart) {
　　　　&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
　　} &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (otherEnd &amp;lt;&lt;span&gt; start) {
　　　　&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
　　}
　　&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Math.min(end, otherEnd) -&lt;span&gt; Math.max(start, otherStart);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;36mo2&quot; data-offset-key=&quot;60d10-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;60d10-0-0&quot;&gt;　　上述代码是判断两个会议的TIme Grain, 若存在重叠，则返回重叠量，供引擎的评分机制来判断各个solution的优劣。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;
&lt;h2 class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;1027h-0-0&quot;&gt;&lt;span data-offset-key=&quot;1027h-0-0&quot;&gt;时间链模式 - Chained Through Time&lt;/span&gt;&lt;/h2&gt;
&lt;/p&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;36mo2&quot; data-offset-key=&quot;bdon6-0-0&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;bdon6-0-0&quot;&gt;　　&lt;span data-offset-key=&quot;bdon6-0-1&quot;&gt;前面提出的两种时间模式，其实有较多的相似之处，都是将时间段划分为单个个体，再将这些个体作为规划变量的取值范围，从而实现与空间规划一致的规划模式。但更复杂的场景下，将时间转化为“空间”的做法，未必能行得通。例如带时间窗口的路径规划，多工序多资源生产计划等问题，其时间维度是难以通过Time Slot或Time Grain模式实现的。我增尝试将Time Grain模式应用于多工序多资源条件下的生产计划规划；其原理上是可行的，但仍然会到到一些相当难解决的问题。其中之一就是Time Grain的粒度大小问题，若需要实现精确到分钟的计划，当编排一个时间跨度较大的计划时，就会引起问题规模过大的问题，从而论引擎效率骤降。另外就是实现相邻任务的重叠和先后次序判断时，会遇到一些难以解决的，问题需要花费较多的精力去处理。因此，Optaplanner引入了第三种时间规划模式 - 时间链模式（同样是翻译问题，下称Chained Through Time模式)。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;36mo2&quot; data-offset-key=&quot;6276r-0-0&quot; readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;6276r-0-0&quot;&gt;&lt;span data-offset-key=&quot;6276r-0-1&quot;&gt;Chained Through Time模式顾名思义就是应用了链状结构的特性，来实现时间的规划。它的设计思想是，规划变量并不是普通的时间或空间上的值, 而是另外一个规划实体；从而形成一个由各个首尾相接的规划实体链，即Value Range的范围就是规划实集合本身。通过规划实体间的链状关系，来推算各个实体的起止时间。事实上，Optaplanner中将规划实体环环相扣形成链的特性，其主要目的并非为了实现时间规划，而是为了解类似TSP，VRP等问题而提供的。这些问题需要规划的，是各个节点之间形成的连通关系；在约定规则下，求解最佳连通方案。根据不同的场景要求，所求的目标有“最短路径”，“最小重复节点”，“最在连接效率”等。在时间规划的功能方面，其实现方式与上两种模式类似。以生产计划的例子来说，通过Chained Through Time模式获得各任务的连接关系与次序后，就可以根据链中首个任务的开始时间，结合各任务的持续时间，推算出各个任务精确的起止时间了，甚至可以精确到秒。所以此模式用于时间规划，只是它的一个“副业”，引擎使用Chained Through Time模式时，并不是直接对时间进行规划优化，而是在优化规划实体之间的连接关系；时间作为这个规划实体中的一个影子变量（Shadow variable）进行计算，最终通过评分机制对这个影子变量进行约束限制，从而得到时间优化的方案。与Time Slot和Time Grain相比，Chained Through Time最大的特性是通过次序来推导时间，而另外两种模式则是需要通过时间来反映任务之间的先后关系。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;36mo2&quot; data-offset-key=&quot;c1quc-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;c1quc-0-0&quot;&gt;　　&lt;span data-offset-key=&quot;c1quc-0-1&quot;&gt;虽然Chained Through Time模式的作用相当巨大且广泛，但该模式的设计与实现难度又是三个模式中最高的，实现起来相对复杂。下面来进一步对其进行深入讨论。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;
&lt;h3 class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;ek0s8-0-0&quot;&gt;&lt;span data-offset-key=&quot;ek0s8-0-0&quot;&gt;Chained Through Time模式的意义&lt;/span&gt;&lt;/h3&gt;
&lt;/p&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;36mo2&quot; data-offset-key=&quot;s9r1-0-0&quot; readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;s9r1-0-0&quot;&gt;　　Chained Through Time模式通过对正在进行规划的所有规划实体建立链状关系，来实现时间推导，其推导结果示意图如下。从图中可以看到，分配给Ann有两个任务(FR taxes和SP taxes),其中第一个任务FR taxes的开始时刻是固定为本次计划的最早时间，而第二个任务SP taxes的开始时刻，则是根据第一个任务推导出来的 - 等于第一个任务的开始时刻加上其持续时间。因此，需要在约束的限制下，引擎过过各种约束分数的判断，生成一个相对最合理的实体连接方案，再在这个方案的基础上来推导时间，或将时间纳入作为约束条件，实现对连接方案的影响，从而实现了时间维度的规划优化。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;Editable-imageUploader&quot;&gt;
&lt;div class=&quot;Editable-imageUploader-layout is-fullWidth FocusPlugin--unfocused&quot;&gt;
&lt;div class=&quot;Editable-imageUploader-placeholder&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/148283/201903/148283-20190314000612151-178779068.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;36mo2&quot; data-offset-key=&quot;e4l2r-0-0&quot; readability=&quot;9&quot;&gt;
&lt;h3 class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;e4l2r-0-0&quot;&gt;&lt;span data-offset-key=&quot;e4l2r-0-0&quot;&gt; &lt;/span&gt;&lt;span&gt;Chained Through Time的内存模型&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　规划实体形成的链是由引擎自动生成的，每生成的一个方案都是由各规划实体之间的相对位置变化而成的。在创建的这些规划实体构成的链中，它会遵循以下原则：&lt;/p&gt;
&lt;/div&gt;
&lt;ol class=&quot;public-DraftStyleDefault-ol&quot; data-offset-key=&quot;ajavp-0-0&quot; readability=&quot;2&quot;&gt;&lt;li class=&quot;Editable-styled public-DraftStyleDefault-orderedListItem public-DraftStyleDefault-reset public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;36mo2&quot; data-offset-key=&quot;ajavp-0-0&quot; readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;ajavp-0-0&quot;&gt;一条链由一个Anchor(锚),和零或，或1个，或多个Entity(实体，其实就是规划实体)构成；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;Editable-styled public-DraftStyleDefault-orderedListItem public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;36mo2&quot; data-offset-key=&quot;6rg7g-0-0&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;6rg7g-0-0&quot;&gt;一条链必须有且仅有一个Anchor(锚）；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;Editable-styled public-DraftStyleDefault-orderedListItem public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;36mo2&quot; data-offset-key=&quot;4idqn-0-0&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;4idqn-0-0&quot;&gt;一条链中的Entity或Anchor之间是一对一的关系，不可出现合流或分流结构；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;Editable-styled public-DraftStyleDefault-orderedListItem public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;36mo2&quot; data-offset-key=&quot;fduvb-0-0&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;fduvb-0-0&quot;&gt;一条链中的Entity或Anchor不可出现循环。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;36mo2&quot; data-offset-key=&quot;6rp1d-0-0&quot;&gt;
&lt;div class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;6rp1d-0-0&quot;&gt;&lt;span data-offset-key=&quot;6rp1d-0-0&quot;&gt;&lt;span data-offset-key=&quot;6rp1d-0-0&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/148283/201903/148283-20190314000655413-1050924410.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;
&lt;h3&gt;Chained Through Time模式的设计实现&lt;/h3&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;36mo2&quot; data-offset-key=&quot;dr4t6-0-0&quot; readability=&quot;15&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;dr4t6-0-0&quot;&gt;　　&lt;span data-offset-key=&quot;dr4t6-0-1&quot;&gt;通过上面的链结构，我们了解到，一条链中将会存在两种对象，一种是Anchor, 一种是Entity.对么它们分别代表现实场景中的什么业务实体呢？其实Entity是其常容易理解，如果是生产计划案例中，它代表的是每个任务；在车辆路线规划案例中，它代表的是每个车辆需要途径的派件/揽件客户。而Anchor则表未任务所在的机台，及各个投/揽方案中的每一车辆。因此，这两种不同的对象，在内容中会形成依赖关系，即一个Entity的前一步可以是另外一个Entiy, 也可以是一个Anchor。以生产计划的业务场景来描述，则表示一个任务的前一个任务，可以是另外一个任务(Entity)，也可以是一个机台(Anchor,当这个任务是这个机台的首个任务时）。因此，在我们设计它的时候需要把这两种不同的业务实体抽象为同一类才有办法实现它们之间的依赖,事实上这种抽象关系，在面向对象的原则，在业务意义上来说，是不成立的，仅仅是为了满足它们形成同一链的要求才作出的计划。如下是一个任务与机台的类设计图。可以看到，我从Taskg与Machine抽象了一个父类Step（这是我想到的最合适类名了）,那么每一个任务的前一个Step有可能是另外一个任务，也有可能是一个机台。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;36mo2&quot; data-offset-key=&quot;dd9me-0-0&quot; readability=&quot;111.39091858038&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/148283/201903/148283-20190314000756478-994050420.png&quot; alt=&quot;&quot;/&gt;&lt;h3&gt;时间推算方法&lt;/h3&gt;
&lt;p&gt;　　Chained Through Time模式与其两种时间规划模式不同，本质上它并不对时间进行规划，只对实体之间的关系进行规划优化。因此，在引擎每一个原子操作中需要通过对VariableListener接口的实现，来对时间进行推算，并在完成推算后，由引擎通过评分机制进行约束评分。一个Move有可能对应多个原子操作，一个Move的操作种类，可以参见开发 手册中关于&lt;a href=&quot;https://docs.optaplanner.org/7.18.0.Final/optaplanner-docs/html_single/index.html#whatIsAMoveSelector&quot; target=&quot;_blank&quot;&gt;Move Selector&lt;/a&gt;一章，在以后对引擎行为进行深入分析的文章中，我将会写一篇关于Move Seletor的文件，来揭示引擎的运行原理。在需要进行时间推算时，可以通过实现接口的afterVariableChanged方法，对当前所处理的规划实体的时间进行更新。因为Chained Through Timea模式下，所有已初始化的规划实体都处在一条链上；因此，当一个规划实体的时间被更新后，跟随着它的后一个规划实体的时间也需要被更新，如此类推，直到链上最后一个实体，或出现一个时间正好不需要更新的规划实体，即该规划实体前面的所有实体的时间出现更新后，其时间不用变化，那么链上从它往后的规划实体的时候也无需更新。&lt;/p&gt;
&lt;p&gt;　　以下是VariableListener接口的afterVariableChanged及其处理方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 实现VariableListener的类&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; StartTimeUpdatingVariableListener &lt;span&gt;implements&lt;/span&gt; VariableListener&amp;lt;Task&amp;gt;&lt;span&gt; {

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 实现afterVariableChanged方法&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; afterVariableChanged(ScoreDirector scoreDirector, Task task) {
        updateStartTime(scoreDirector, task);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; beforeEntityAdded(ScoreDirector scoreDirector, Task task) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Do nothing&lt;/span&gt;
&lt;span&gt;    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; afterEntityAdded(ScoreDirector scoreDirector, Task task) {
        updateStartTime(scoreDirector, task);
    }
    .
    .
    .
}    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当一个任务的时候被更新时，顺着链将它后面所有任务的时候都更新&lt;/span&gt;
&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; updateStartTime(ScoreDirector scoreDirector, Task sourceTask) {
     Step previous &lt;/span&gt;=&lt;span&gt; sourceTask.getPreviousStep();
     Task shadowTask &lt;/span&gt;=&lt;span&gt; sourceTask;
     Integer previousEndTime &lt;/span&gt;= (previous == &lt;span&gt;null&lt;/span&gt; ? &lt;span&gt;null&lt;/span&gt;&lt;span&gt; : previous.getEndTime());
     Integer startTime &lt;/span&gt;=&lt;span&gt; calculateStartTime(shadowTask, previousEndTime);
     &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (shadowTask != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !&lt;span&gt;Objects.equals(shadowTask.getStartTime(), startTime)) {
          scoreDirector.beforeVariableChanged(shadowTask, &lt;/span&gt;&quot;startTime&quot;&lt;span&gt;);
          shadowTask.setStartTime(startTime);
          scoreDirector.afterVariableChanged(shadowTask, &lt;/span&gt;&quot;startTime&quot;&lt;span&gt;);
          previousEndTime &lt;/span&gt;=&lt;span&gt; shadowTask.getEndTime();
          shadowTask &lt;/span&gt;=&lt;span&gt; shadowTask.getNextTask();
          startTime &lt;/span&gt;=&lt;span&gt; calculateStartTime(shadowTask, previousEndTime); 
     }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;规划实体的设计&lt;/h3&gt;
&lt;p&gt;　　上一步我们介绍了如何通过链在引擎的运行过程中进行时间推算，那么如何设定才能让引擎可以执行VariableListener中的方法呢，这就需要在规划实体的设计过程中，反映出Chained Through Time的特性了。我们以上面的类图为例，理解下面其设计要求，在此示例中，把Task作为规划实体(Planning Entity), 那么在Task类中需要定义一个Planning Variable(genuine planning variable), 它的类型是Step,它表示当前Task的上一个步骤（可能是另一个Task，也可能是一Machine). 此外，在 @PlanningVariable注解中，添加graphType = PlanningVariableGraphType.CHAINED说明。如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Planning variables: changes during planning, between score calculations.&lt;/span&gt;
    @PlanningVariable(valueRangeProviderRefs = {&quot;&lt;span&gt;machineRange&lt;/span&gt;&quot;, &quot;&lt;span&gt;taskRange&lt;/span&gt;&quot;&lt;span&gt;},
            graphType &lt;/span&gt;=&lt;span&gt; PlanningVariableGraphType.&lt;strong&gt;CHAINED&lt;/strong&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Step previousStep;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　以上代码说明，规划实体(Task)的genuine planning variable名为previousStep, 它的Value Range有两个来源，分别是机台列表（machineRange)和任务列表(taskRange),并且添加了属性grapType=planningVariableGraphType.CHAINED, 表明将应用Chained Through Time模式运行。&lt;/p&gt;
&lt;p&gt;　　有了genuine planning variable, 还需要Shadow variable, 所谓的Shadow variable，在Chained Through Time模式下有两种作用，分别是：&lt;/p&gt;
&lt;p&gt;　　1. 用于建立两个对象（Entity或Anchor)之间的又向依赖关系；即示例中的Machine与Task, 相信的两个Task。&lt;/p&gt;
&lt;p&gt;　　2. 用于指定当genuine planning variable的值在规划运算过程产生变化时，需要更改哪个变量；即上面提到的开始时间。&lt;/p&gt;
&lt;p&gt;，对于第一个作用，其代码体现如下，在规划实体（Task)中，以@AnchorShadowVariable注解，并在该注解的sourceVariableName中指定该Shadow Variable在链上的前一个对象指向的是哪个变量。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Shadow variables
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Task nextTask inherited from superclass&lt;/span&gt;
    @AnchorShadowVariable(sourceVariableName = &quot;&lt;span&gt;previousStep&lt;/span&gt;&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Machine machine;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上述代码说明成员machine是一个Anchor Shadow Variable, 在链上，它连接的前一个实体是实体类的一个成员 - previousStep.&lt;/p&gt;
&lt;p&gt;　　Chained Through Time中的链需要形成双向关系(bi-directional)，下图是路线规划示例中。一个客户与上一个停靠点之间的又向关系。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/148283/201903/148283-20190314005738818-1995705303.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　在规划实体(Task)中我们已经定义了前一个Step，并以@AnchorShadowVariable注解标识。而双向关系中的另一方，则需要在相邻节点中的前一个节点定义。通过链的内存模型，我们可以知道，在生产计划示例中，一个实体的前一个节点的类型可能是另一个Task, 也要能是一个Machine, 因此，前一个节点指向后一个节点的规划变量，只能在Task与Machine的共同父类中定义，也就是需要在Step中实现。因此，在Step类中需要定义另一个Shadow Variable, 因为相对于Task中的Anchor Shadow variable, 它是反现的，因此，它需要通过@InverseRelationShadowVariable注解，说明它在链上起到反向连接作用，即它是指向后一个节点的。代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@PlanningEntity
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TaskOrEmployee {

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Shadow variables&lt;/span&gt;
    @InverseRelationShadowVariable(sourceVariableName = &quot;previousTaskOrEmployee&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; Task nextTask;
    .
    .
    .
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　可以从代码中看到，Step类也是一个规划实体.其中的一个成员nextTask, 它的类型是Task,它表示在链中指向后面的Entity. 大家可以想一下，为什么它可以是一个Task, 而无需是一个Step。&lt;/p&gt;
&lt;p&gt;　　通过上述设计，已经实现了Chained Through Time的基本模式，可能大家还会问，上面我们实现了VariableListener, 引擎是如何触发它的呢。这就需要用到另外一种Shadow Variable了，这种Shadow Varible是用于实现在运算过程中执行额外处理的，因此称为Custom Shadow Variable.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 自定义Shadow Variable, 它表示当 genuine被引擎改变时，需要处理哪个变量。 &lt;/span&gt;
@CustomShadowVariable(variableListenerClass = StartTimeUpdatingVariableListener.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;,
            sources &lt;/span&gt;= {@PlanningVariableReference(variableName = &quot;&lt;span&gt;previousStep&lt;/span&gt;&quot;&lt;span&gt;)})
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Integer startTime; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 因为时间在规划过程中以相对值进行运算，因此以整数表示。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面的代码通过@CustomShadowVariable注解，说明了Task的成员startTime是一个自定义的Shadow Variable. 同时在注解中添加了variableListenerClass属性，其值指定为刚才我们定义的，实现了VariableListener接口的类 - StartTimeUpdatingVariableListener，同时，能冠军sources属性指定，当前Custom Shadow Variable是跟随着genuine variable - previousStep的变化而变化的。&lt;/p&gt;
&lt;p&gt;　　至此，关于Chained Through Time中的关键要点已全部设计实现，具体的使用可以参照示例包中有用到此模式的代码。&lt;/p&gt;

&lt;p&gt;总结&lt;/p&gt;
&lt;p&gt;　　关于时间的规划，在实际的系统开发时，无不止本文描述的那么简单。有许许多多的个性规则和要求，需要通过大家的技巧来实现；但万变不离其宗，所有处理特殊情况的技巧，都需要甚至Optaplanner这些既有特性。因此，大家可以先通过示例包中的代码将这些特性掌握，再进行更复杂情况下的设计开如。未来若时间允许，我将分享我在项目中遇到的一些特殊，甚至是苛刻的规则要求，及其处理办法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如需了解更多关于Optaplanner的应用，请发电邮致：&lt;a href=&quot;mailto:kentbill@gmail.com&quot; target=&quot;_blank&quot;&gt;kentbill@gmail.com&lt;/a&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;或到讨论组发表你的意见：&lt;a href=&quot;https://groups.google.com/forum/#!forum/optaplanner-cn&quot; target=&quot;_blank&quot;&gt;https://groups.google.com/forum/#!forum/optaplanner-cn&lt;/a&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;若有需要可添加本人微信（13631823503）或QQ(12977379)实时沟通，但因本人日常工作繁忙，通过微信,QQ等工具可能无法深入沟通，较复杂的问题，建议以邮件或讨论组方式提出。(讨论组属于google邮件列表，国内网络可能较难访问，需自行解决)&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Wed, 13 Mar 2019 17:29:00 +0000</pubDate>
<dc:creator>kentzhang</dc:creator>
<og:description>在Optaplanner系列文件中，大家目前最有兴趣的是实现时间维度的规划设计，特别是Chained Through Time模式的设计。本文介绍Optaplanner中常用的三种时间规划方式。并重介</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kentzhang/p/10527729.html</dc:identifier>
</item>
<item>
<title>rabbitmq学习（七） —— springboot下的可靠使用 - pokid</title>
<link>http://www.cnblogs.com/pokid/p/10527708.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pokid/p/10527708.html</guid>
<description>&lt;p&gt;&lt;span&gt;前面的学习都是基于原生的api，下面我们使用spingboot来整合rabbitmq&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;springboot对rabbitmq提供了友好支持，极大的简化了开发流程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;引入maven&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;br/&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-amqp&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-test&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;test&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;配置yml&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;rabbitmq:
    host: &lt;/span&gt;47.102.103.232&lt;span&gt;
    port: &lt;/span&gt;5672&lt;span&gt;
    username: admin
    password: admin
    virtual&lt;/span&gt;-host: /&lt;span&gt;test
    publisher&lt;/span&gt;-confirms: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
    publisher&lt;/span&gt;-returns: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
    cache:
      channel:
        size: &lt;/span&gt;10&lt;span&gt;
    listener:
      simple:
        acknowledge&lt;/span&gt;-&lt;span&gt;mode: manual
        concurrency: &lt;/span&gt;1&lt;span&gt;
        max&lt;/span&gt;-concurrency: 3&lt;span&gt;
        retry:
          enabled: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这是基础的配置，看不懂的配置后面会介绍&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;更详细的配置参考官方&lt;a href=&quot;https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-rabbitmq&quot; target=&quot;_blank&quot;&gt;https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-rabbitmq&lt;/a&gt;（搜索rabbit往下拉即可）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;代码实现&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt; &lt;span&gt;&lt;strong&gt;配置类&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Configuration
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RabbitConfig {&lt;/span&gt;&lt;span&gt;
    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Queue helloQueue() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Queue(&quot;helloQueue&quot;&lt;span&gt;);
    }&lt;br/&gt;　　 &lt;span&gt;//创建topic交换机&lt;/span&gt;
    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; TopicExchange helloExchange() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; TopicExchange(&quot;helloExchange&quot;&lt;span&gt;);
    }
    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Binding bindingPaymentExchange(Queue helloQueue, TopicExchange helloExchange) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; BindingBuilder.bind(helloQueue).to(helloExchange).with(&quot;hello.#&quot;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 定制化amqp模版&lt;br/&gt;　　　* connectionFactory:包含了yml文件配置参数
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; RabbitTemplate rabbitTemplate(ConnectionFactory connectionFactory) {
        RabbitTemplate rabbitTemplate &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RabbitTemplate(connectionFactory);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 必须设置为 true，不然当 发送到交换器成功，但是没有匹配的队列，不会触发 ReturnCallback 回调
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 而且 ReturnCallback 比 ConfirmCallback 先回调，意思就是 ReturnCallback 执行完了才会执行 ConfirmCallback&lt;/span&gt;
        rabbitTemplate.setMandatory(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置 ConfirmCallback 回调   yml需要配置 publisher-confirms: true&lt;/span&gt;
        rabbitTemplate.setConfirmCallback((correlationData, ack, cause) -&amp;gt;&lt;span&gt; {
　　　　　　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果发送到交换器都没有成功（比如说删除了交换器），ack 返回值为 false
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果发送到交换器成功，但是没有匹配的队列（比如说取消了绑定），ack 返回值为还是 true （这是一个坑，需要注意）&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ack) {
                String messageId &lt;/span&gt;=&lt;span&gt; correlationData.getId();
                System.out.println(&lt;/span&gt;&quot;confirm:&quot;+&lt;span&gt;messageId);&lt;/span&gt;
&lt;span&gt;            }
        });
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置 ReturnCallback 回调   yml需要配置 publisher-returns: true
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果发送到交换器成功，但是没有匹配的队列，就会触发这个回调&lt;/span&gt;
&lt;span&gt;        rabbitTemplate.setReturnCallback((message, replyCode, replyText,
                                          exchange, routingKey) &lt;/span&gt;-&amp;gt;&lt;span&gt; {
&lt;/span&gt;            String messageId =&lt;span&gt; message.getMessageProperties().getMessageId();
            System.out.println(&lt;/span&gt;&quot;return:&quot;+&lt;span&gt;messageId);&lt;/span&gt;
&lt;span&gt;        });
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; rabbitTemplate;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;回调机制&lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;消息不管是否投递到交换机都进行&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;ConfirmCallback回调，投递成功ack=true，否则为false&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;交换机匹配到队列成功则不进行&lt;/span&gt;&lt;span&gt;ReturnCallback回调，否则先进行&lt;/span&gt;&lt;span&gt;ReturnCallback回调再进行&lt;/span&gt;&lt;span&gt;ConfirmCallback回调&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;如果消息成功投递到交换机，但没匹配到队列，则&lt;/span&gt;&lt;span&gt;ConfirmCallback回调ack仍为true&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;生产者&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RbProducer {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注意一定要使用RabbitTemplate！！
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;虽然RabbitTemplate实现了AmqpTemplate 但是AmqpTemplate里并没有能发送correlationData的方法&lt;/span&gt;
&lt;span&gt;    @Resource
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; RabbitTemplate rbtemplate;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; send1(String msg){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;CorrelationData用于confirm机制里的回调确认&lt;/span&gt;
        CorrelationData correlationData = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CorrelationData(UUID.randomUUID().toString());
        rbtemplate.convertAndSend(&lt;/span&gt;&quot;helloExchange&quot;, &quot;hello.yj&quot;&lt;span&gt;, msg,correlationData);
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; send2(User user){&lt;/span&gt;&lt;span&gt;
        CorrelationData correlationData &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CorrelationData(UUID.randomUUID().toString());
        rbtemplate.convertAndSend(&lt;/span&gt;&quot;helloExchange&quot;, &quot;hello.yj&quot;&lt;span&gt;, user,correlationData);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;消费者&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Component
@RabbitListener(queues &lt;/span&gt;= &quot;helloQueue&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RbConsumer {
    @RabbitLister(queues = &quot;helloQueue&quot;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; receive0(Message msg,  Channel channel) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
        System.out.println(&lt;/span&gt;&quot;consumer receive message0: &quot; +&lt;span&gt; msg);
        channel.basicAck(msg.getMessageProperties().getDeliveryTag(), &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
    }
    @RabbitHandler
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; receive1(String msg, @Header(AmqpHeaders.DELIVERY_TAG)&lt;span&gt;long&lt;/span&gt; deliveryTag, Channel channel) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
        System.out.println(&lt;/span&gt;&quot;consumer receive message1: &quot; +&lt;span&gt; msg);
        channel.basicAck(deliveryTag, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
    }
    @RabbitHandler
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; receive2(User user, @Header(AmqpHeaders.DELIVERY_TAG)&lt;span&gt;long&lt;/span&gt; deliveryTag, Channel channel) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
        System.out.println(&lt;/span&gt;&quot;consumer receive message2: &quot;+&lt;span&gt;user);
　　　　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果发生以下情况投递消息所有的通道或连接被突然关闭（包括消费者端丢失TCP连接、消费者应用程序（进程）挂掉、通道级别的协议异常）任何已经投递的消息但是没有被消费者端确认的消息会自动重新排队。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;请注意，连接检测不可用客户端需要一段时间才会发现，所以会有一段时间内的所有消息会重新投递
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;因为消息的可能重新投递，所有必须保证消费者端的接口的幂等。

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在RabbitMQ中影响吞吐量最大的参数是：消息确认模式和Qos预取值
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;自动消息确认模式或设置Qos预取值为无限虽然可以最大的提高消息的投递速度，但是在消费者端未及时处理的消息的数量也将增加，从而增加消费者RAM消耗，使用消费者端奔溃。所以以上两种情况需要谨慎使用。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;RabbitMQ官方推荐Qos预取值设置在 100到300范围内的值通常提供最佳的吞吐量，并且不会有使消费者奔溃的问题&lt;/span&gt;&lt;span&gt;
        channel.basicAck(deliveryTag, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
        channel.basicQos(&lt;/span&gt;100&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 代表消费者拒绝一条或者多条消息，第二个参数表示一次是否拒绝多条消息，第三个参数表示是否把当前消息重新入队
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; channel.basicNack(deliveryTag, false, false);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 代表消费者拒绝当前消息，第二个参数表示是否把当前消息重新入队
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; channel.basicReject(deliveryTag,false);&lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;@RabbitListener+@RabbitHandler：消费者监听&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;使用@RabbitListener+@RabbitHandler组合进行监听，监听器会根据队列发来的消息类型自动选择处理方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;channel.basicAck(deliveryTag, false)：手动确认机制&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　deliverTag：该消息的标识，每来一个消息该标识+1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　multiple：第二个参数标识书否批量确认&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　requeue：被拒绝的是否重新入队&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;channel.basicQos(100)：最多未确认的消息数量为100，超过100队列将停止给该消费者投递消息&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;更多参数详解参考&lt;a href=&quot;https://www.cnblogs.com/piaolingzxh/p/5448927.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/piaolingzxh/p/5448927.html&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;测试&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;br/&gt;@RunWith(SpringRunner.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
@SpringBootTest(classes &lt;/span&gt;= TestBoot.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestRabbit {
    @Resource
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; RbProducer producer;
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; send1() {
        producer.send1(&lt;/span&gt;&quot;hello,im a string&quot;&lt;span&gt;);
    }
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; send2() {
        User user &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User();
        user.setNickname(&lt;/span&gt;&quot;hello,im a object&quot;&lt;span&gt;);
        producer.send2(user);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 成功消费&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/828869/201903/828869-20190314003721491-590069911.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/828869/201903/828869-20190314003940226-2068764919.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;完结&lt;/p&gt;
&lt;p&gt;下篇博客我们讨论下在拥有了手动ack机制、confirm机制、return机制后，是否真的可靠~&lt;/p&gt;
</description>
<pubDate>Wed, 13 Mar 2019 16:46:00 +0000</pubDate>
<dc:creator>pokid</dc:creator>
<og:description>前面的学习都是基于原生的api，下面我们使用spingboot来整合rabbitmq springboot对rabbitmq提供了友好支持，极大的简化了开发流程 引入maven 配置yml 这是基础的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pokid/p/10527708.html</dc:identifier>
</item>
<item>
<title>JavaScript类型化数组（二进制数组） - 进击的蘑菇</title>
<link>http://www.cnblogs.com/ad-mushroom/p/10514063.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ad-mushroom/p/10514063.html</guid>
<description>&lt;p&gt;&lt;span&gt;0、前言&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　对于前端程序员来说，平时很少和二进制数据打交道，所以基本上用不到ArrayBuffer，大家对它很陌生，但是在使用WebGL的时候，ArrayBuffer无处不在。浏览器通过WebGL和显卡进行通信，它们之间会发生大量的、实时的数据交互，对性能的要求特别高，它们之间的数据通信必须是二进制的才能满足性能要求，而不能是传统的文本格式。文本格式传递一个 32 位整数，两端的 JavaScript 脚本与显卡都要进行格式转化，将非常耗时。类型化数组的诞生就是为了能够让开发者通过类型化数组来操作内存，大大增强了JavaScript处理二进制数据的能力。&lt;/p&gt;
&lt;p&gt;　　JavaScript类型化数组将实现拆分为&lt;strong&gt;缓冲&lt;/strong&gt;和&lt;strong&gt;视图&lt;/strong&gt;两部分。一个缓冲（ArrayBuffer）描述的是内存中的一段二进制数据，缓冲没有格式可言，并且不提供机制访问其内容。为了访问在缓存对象中包含的内存，你需要使用视图。视图可以将二进制数据转换为实际有类型的数组。一个缓冲可以提供给多个视图进行读取，不同类型的视图读取的内存长度不同，读取出来的数据格式也不同。缓冲和视图的工作方式如下图所示：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/717109/201903/717109-20190311235955129-84313514.png&quot; alt=&quot;&quot; width=&quot;1120&quot; height=&quot;528&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、缓冲（ArrayBuffer）和视图&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　ArrayBuffer是一个构造函数，可以分配一段可以存放数据的&lt;strong&gt;连续&lt;/strong&gt;内存区域。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; buffer = &lt;span&gt;new&lt;/span&gt; ArrayBuffer(8);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面代码生成了一段8字节的内存区域，每个字节的值默认都是0。1 字节（Byte） ＝ 8 比特（bit），1比特就是一个二进制位（0 或 1）。上面代码生成的8个字节的内存区域，一共有 8*8=64 比特，每一个二进制位都是0。&lt;/p&gt;
&lt;p&gt;　　为了读写这个buffer，我们需要为它指定视图。视图有两种，一种是TypedArray视图，它一共包括9种类型，还有一种是DataView视图，它可以自定义复合类型。 基础用法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre readability=&quot;5&quot;&gt;
&lt;span&gt;var&lt;/span&gt; dataView = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DataView(buffer);
dataView.getUint8(&lt;/span&gt;0) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 0&lt;/span&gt;
&lt;span&gt;
var int32View &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Int32Array(buffer);
int32View[&lt;/span&gt;0] = 1 // 修改底层内存&lt;p&gt;var uint8View = new Uint8Array(buffer);&lt;br/&gt;uint8View[0] // 1&lt;span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;视图类型&lt;/td&gt;
&lt;td&gt;说明&lt;/td&gt;
&lt;td&gt;字节大小&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Uint8Array&lt;/td&gt;
&lt;td&gt;8位无符号整数&lt;/td&gt;
&lt;td&gt;1字节&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Int8Array&lt;/td&gt;
&lt;td&gt;8位有符号整数&lt;/td&gt;
&lt;td&gt;1字节&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Uint8ClampedArray&lt;/td&gt;
&lt;td&gt;8位无符号整数（溢出处理不同）&lt;/td&gt;
&lt;td&gt;1字节&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Uint16Array&lt;/td&gt;
&lt;td&gt;16位无符号整数&lt;/td&gt;
&lt;td&gt;2字节&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Int16Array&lt;/td&gt;
&lt;td&gt;16位有符号整数&lt;/td&gt;
&lt;td&gt;2字节&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Uint32Array&lt;/td&gt;
&lt;td&gt;32位无符号整数&lt;/td&gt;
&lt;td&gt;4字节&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Int32Array&lt;/td&gt;
&lt;td&gt;32位有符号整数&lt;/td&gt;
&lt;td&gt;4字节&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Float32Array&lt;/td&gt;
&lt;td&gt;32位IEEE浮点数&lt;/td&gt;
&lt;td&gt;4字节&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Float64Array&lt;/td&gt;
&lt;td&gt;64位IEEE浮点数&lt;/td&gt;
&lt;td&gt;8字节&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;　　下面来看一个完整的例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建一个16字节长度的缓冲&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; buffer = &lt;span&gt;new&lt;/span&gt; ArrayBuffer(16&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建一个视图，此视图把缓冲内的数据格式化为一个32位（4字节）有符号整数数组&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; int32View = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Int32Array(buffer);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 我们可以像普通数组一样访问该数组中的元素&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; int32View.length; i++&lt;span&gt;) {
  int32View[i] &lt;/span&gt;= i * 2&lt;span&gt;;
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 运行完之后 int32View 为[0,2,4,6]&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; 创建另一个视图，此视图把缓冲内的数据格式化为一个16位（2字节）有符号整数数组&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; int16View = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Int16Array(buffer);

&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; int16View.length; i++&lt;span&gt;) {
  console.log(&lt;/span&gt;&lt;span&gt;int16View[i]);
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打印出来的结果依次是0，0，2，0，4，0，6，0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/717109/201903/717109-20190313223421772-633405403.png&quot; alt=&quot;&quot; width=&quot;1147&quot; height=&quot;413&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　相信图片已经很直观的表达了这段代码的意思。这里应该有人会疑问，为什么2、4、6这三个数字会排在0的前面，这是因为x86的系统都是使用的小端字节序来存储数据的，小端字节序就是在内存中，数据的高位保存在内存的高地址中，数据的低位保存在内存的低地址中。就拿上面这段代码举例，上图中内存大小排列的顺序是从左向右依次变大，int32View[1]对应的4个字节，它填入的值是 10 （2的2进制表示），把0补齐的话就是 00000000 00000000 00000000 00000010（中间的分隔方便观看），计算机会倒过来填充，最终会成为 00000010 00000000 00000000 00000000。与小端字节序对应的就是大端字节序，它就是我们平时读数字的顺序。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、实际场景&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　在WebGL中有这么一个需求，我要绘制一个带颜色的三角形，这个三角形有三个顶点，每个点有3个坐标和一个RGBA颜色，现在有了三角形的顶点和颜色数据，需要创建一个缓冲，把三角形的数据按顺序填入，然后传输给WebGL。目前的三角形数据是这样的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
      &lt;span&gt;var&lt;/span&gt; triangleVertices =&lt;span&gt; [
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; (x,   y,   z)  (r,   g,   b,   a)&lt;/span&gt;
        0.0,  0.5, 0.0, 255,   0,   0, 255, &lt;span&gt;//&lt;/span&gt;&lt;span&gt; V0&lt;/span&gt;
        0.5, -0.5, 0.0,   0, 250,   6, 255, &lt;span&gt;//&lt;/span&gt;&lt;span&gt; V1&lt;/span&gt;
       -0.5, -0.5, 0.0,   0,   0, 255, 255  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; V2&lt;/span&gt;
      ];
&lt;/pre&gt;&lt;/div&gt;

&lt;p dir=&quot;ltr&quot;&gt; 　　目标格式是一个ArrayBuffer，它的格式是这样的：&lt;/p&gt;
&lt;p dir=&quot;ltr&quot;&gt; 　&lt;img src=&quot;https://img2018.cnblogs.com/blog/717109/201903/717109-20190314000258182-1151644114.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p dir=&quot;ltr&quot;&gt;　　表示坐标的浮点数是32位的，占4个字节，表示颜色的正整数是8位的，占1个字节，因此我们需要创建两个视图来对这个缓冲进行赋值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
      &lt;span&gt;var&lt;/span&gt; triangleVertices =&lt;span&gt; [
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; (x,   y,   z)  (r,   g,   b,   a)&lt;/span&gt;
        0.0,  0.5, 0.0, 255,   0,   0, 255, &lt;span&gt;//&lt;/span&gt;&lt;span&gt; V0&lt;/span&gt;
        0.5, -0.5, 0.0,   0, 250,   6, 255, &lt;span&gt;//&lt;/span&gt;&lt;span&gt; V1&lt;/span&gt;
       -0.5, -0.5, 0.0,   0,   0, 255, 255  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; V2&lt;/span&gt;
&lt;span&gt;      ];

      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; nbrOfVertices = 3; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 顶点数量&lt;/span&gt;
      &lt;span&gt;var&lt;/span&gt; vertexSizeInBytes = 3 * Float32Array.BYTES_PER_ELEMENT + 4 * Uint8Array.BYTES_PER_ELEMENT; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 一个顶点所占的字节数 3*4+4*1 ＝ 16&lt;/span&gt;

      &lt;span&gt;var&lt;/span&gt; buffer = &lt;span&gt;new&lt;/span&gt; ArrayBuffer(nbrOfVertices * vertexSizeInBytes); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3 ＊ 16 = 48 三个顶点一共需要的字节数&lt;/span&gt;
      &lt;span&gt;var&lt;/span&gt; positionView = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Float32Array(buffer); 
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; colorView = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Uint8Array(buffer);

      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; positionOffsetInFloats = 0&lt;span&gt;;
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; colorOffsetInBytes = 12&lt;span&gt;;
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; k = 0&lt;span&gt;;
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用三角形数据填充arrayBuffer&lt;/span&gt;
      &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; nbrOfVertices; i++&lt;span&gt;) {
        positionView[positionOffsetInFloats] &lt;/span&gt;= triangleVertices[k];         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; x&lt;/span&gt;
        positionView[1 + positionOffsetInFloats] = triangleVertices[k + 1]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; y&lt;/span&gt;
        positionView[2 + positionOffsetInFloats] = triangleVertices[k + 2]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; z&lt;/span&gt;
        colorView[colorOffsetInBytes] = triangleVertices[k + 3];            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; r&lt;/span&gt;
        colorView[1 + colorOffsetInBytes] = triangleVertices[k + 4];            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; g&lt;/span&gt;
        colorView[2 + colorOffsetInBytes] = triangleVertices[k + 5];            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; b&lt;/span&gt;
        colorView[3 + colorOffsetInBytes] = triangleVertices[k + 6];            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; a&lt;/span&gt;
&lt;span&gt;
        positionOffsetInFloats &lt;/span&gt;+=&lt;span&gt; 4; // 4个字节的浮点数循环一次要偏移4位
        colorOffsetInBytes &lt;/span&gt;+=&lt;span&gt; 16;    // 1个字节的整数循环一次要偏移16位
        k &lt;/span&gt;+= 7&lt;span&gt;;                      // 原数组一次处理七个数值(三个坐标四个颜色)
      }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p dir=&quot;ltr&quot;&gt; 　　这段代码运行完，就可以得到我们想要的ArrayBuffer。希望大家可以在浏览器控制台运行一下，然后看看positionView和colorView里面的数据验证一下。细心的小伙伴会发现，如果使用positionView访问颜色数据，或者colorView访问位置数据，得到的数据是“奇怪”的，不知道原因的读者朋友可以去了解一下原码、补码、IEEE浮点数相关的知识。&lt;/p&gt;
&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;3、总结&lt;/span&gt;&lt;/p&gt;
&lt;p dir=&quot;ltr&quot;&gt;　　类型化数组的内容还有很多，在这里我只重点介绍了一下缓冲和视图是如何一起合作来管理内存的。&lt;/p&gt;
&lt;p dir=&quot;ltr&quot;&gt;　　类型化数组的出现最大的作用就是提升了数组的性能，js中Array的内部实现是链表，可以动态增大减少元素，但是元素多的话，性能会比较差，类型化数组管理的是&lt;strong&gt;连续&lt;/strong&gt;内存区域，知道了这块内存的起始位置，可以通过起始位置＋N * 偏移量（一次加法一次乘法操作）访问到第N个位置的元素，而Array的话就需要通过链表一个一个的找下去。&lt;/p&gt;
&lt;p dir=&quot;ltr&quot;&gt;　　类型化数组的使用场景并不多，可以说是为WebGL量身定做的，不过还是希望你能在以后遇到大量数据的场景能够想起来JS的类型化数组这个功能。&lt;/p&gt;
&lt;p dir=&quot;ltr&quot;&gt; &lt;/p&gt;

</description>
<pubDate>Wed, 13 Mar 2019 16:42:00 +0000</pubDate>
<dc:creator>进击的蘑菇</dc:creator>
<og:description>0、前言 对于前端程序员来说，平时很少和二进制数据打交道，所以基本上用不到ArrayBuffer，大家对它很陌生，但是在使用WebGL的时候，ArrayBuffer无处不在。浏览器通过WebGL和显卡</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ad-mushroom/p/10514063.html</dc:identifier>
</item>
<item>
<title>java提高（15）---java深浅拷贝 - 雨点的名字</title>
<link>http://www.cnblogs.com/qdhxhz/p/10527245.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qdhxhz/p/10527245.html</guid>
<description>&lt;center&gt;

&lt;/center&gt;
&lt;h2 id=&quot;一前言&quot;&gt;&lt;span&gt;一、前言&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;为什么会有深浅拷贝这个概念?&lt;/p&gt;
&lt;p&gt;我觉得主要跟JVM内存分配有关,对于基本数据类型,只存在栈内存,所以它的拷贝不存在深浅拷贝这个概念。而对于对象而言,一个对象的创建会在内存中分配两块空间,一个在栈内存存对象的引用指针,一个在堆内存存放对象。这个时候会有一个问题，你拷贝的只是这个引用指针还是拷贝两块内存一起拷贝,这个时候就会有深浅拷贝一说。&lt;br/&gt;还有之前我认为Arrays.copyOf()是深度拷贝,亲测后发现原来它也是浅拷贝。下面进行具体说明。&lt;/p&gt;

&lt;h2 id=&quot;二数据类型&quot;&gt;&lt;span&gt;二、数据类型&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;数据分为&lt;code&gt;基本数据&lt;/code&gt;类型(int, boolean, double, byte, char等)和&lt;code&gt;对象数据&lt;/code&gt;类型。&lt;br/&gt;基本数据类型的特点：&lt;code&gt;直接存储在栈(stack)中的数据&lt;/code&gt;.&lt;br/&gt;引用数据类型的特点：&lt;code&gt;在栈内存存储对象引用，真实的数据存放在堆内存里&lt;/code&gt;&lt;br/&gt;引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201903/1090617-20190313235427505-245278508.jpg&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;三什么是浅拷贝和深拷贝&quot;&gt;&lt;span&gt;三、什么是浅拷贝和深拷贝&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;首先需要明白，&lt;code&gt;深拷贝和浅拷贝是只针对Object和Array这样的引用数据类型的&lt;/code&gt;。那先来看看浅拷贝和深拷贝的概念。&lt;br/&gt;在 Java 中，除了基本数据类型（元类型）之外，还存在 类的实例对象 这个引用数据类型。而一般使用 &lt;code&gt;=&lt;/code&gt;号做赋值操作的时候。对于基本数据类型，实际上是拷贝的它的值，但是对于对象而言，其实赋值的只是这个对象的引用，将原对象的引用传递过去，他们实际上还是指向的同一个对象。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;浅拷贝&lt;/code&gt;：如果在拷贝这个对象的时候，只对基本数据类型进行了拷贝，而对引用数据类型只是进行了引用的传递，而没有真实的创建一个新的对象。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;深拷贝&lt;/code&gt;：在对引用数据类型进行拷贝的时候，创建了一个新的对象，并且复制其内的成员变量。&lt;/p&gt;
&lt;p&gt;深拷贝和浅拷贝的示意图大致如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201903/1090617-20190313235500918-1556393479.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201903/1090617-20190313235507983-512560464.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;具体接下来代码演示。&lt;/p&gt;

&lt;h2 id=&quot;四代码演示&quot;&gt;&lt;span&gt;四、代码演示&lt;/span&gt;&lt;/h2&gt;
&lt;h4 id=&quot;浅拷贝&quot;&gt;1、浅拷贝&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Person&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Person {
    public String name;
    public Integer age;
    public String sex;
    /**
     * 提供get和set方法和全参构造函数
     */
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Test&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    public static void main(String[] args) throws Exception {
        Person person = new Person(&quot;小小&quot;,3,&quot;女&quot;);
        //将person值赋值给person1
        Person person1 = person;
        System.out.println(person);
        System.out.println(person1);
        person1.setName(&quot;小小她爸&quot;);
        System.out.println(&quot;person 中 name为：&quot;+person.getName());
        System.out.println(&quot;person1 中 name为：&quot;+person.getName());
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看运行结果&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201903/1090617-20190313235604444-1064708140.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从图片中我们可以很明显看出,它们指向的内存地址是一致的,同样我改变person1的属性值时发现person的属性值也改变了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;说明&lt;/code&gt;：对于对象用&lt;code&gt;&quot;=&quot;&lt;/code&gt; 赋值 其实只是引用指针的复制,这两个引用还是指向同一个对象。&lt;/p&gt;
&lt;h4 id=&quot;深拷贝&quot;&gt;2、深拷贝&lt;/h4&gt;
&lt;p&gt;如果要实现深拷贝就会比较复杂点&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Student&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 如果对象要实现深拷贝 那么实体需要做两步
 * 1、实体实现Cloneable接口
 * 2、重写 clone()方法
 */
public class Student implements Cloneable {

    public String name;
    public Integer age;
    public String sex;
    //这也是个实体
    public Address address;
    /**
     * 提供get和set方法和全参构造函数
     */
    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Test&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    public static void main(String[] args) throws Exception {
        Student student = new Student(&quot;小小&quot;, 3, &quot;女&quot;, null);
        //将person值赋值给person1
        Student student1 = (Student) student.clone();
        System.out.println(student);
        System.out.println(student1);
        student1.setName(&quot;小小她爸&quot;);
        System.out.println(&quot;person 中 name为：&quot; + student.getName());
        System.out.println(&quot;person1 中 name为：&quot; + student1.getName());
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201903/1090617-20190313235621488-1930654079.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里可以已经是两个不同的对象了。但是这里需要注意的是,如果对象中含有对象,这个对象还是浅拷贝。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Address&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Address  {
    public String  city;
    public  int phone;
    /**
     * 提供get和set方法和全参构造函数
     */
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Test&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    public static void main(String[] args) throws Exception {
        Address address = new Address(&quot;杭州&quot;, 1888888888);
        Student student2 = new Student(&quot;小小&quot;, 3, &quot;女&quot;, address);
        //将person值赋值给person1
        Student student3 = (Student) student2.clone();
        address.setCity(&quot;北京天安门&quot;);
        System.out.println(&quot;person2 中 city为：&quot; + student2.getAddress().getCity());
        System.out.println(&quot;person3 中 city为：&quot; + student3.getAddress().getCity());

    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201903/1090617-20190313235642049-1971336257.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们发现虽然Student是实现了深拷贝，但Address却还是浅拷贝,那如何让Adress也实现深拷贝呢。&lt;br/&gt;&lt;strong&gt;Address修改&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Address implements Cloneable {
    public String  city;
    public  int phone;
   /**
     * 提供get和set方法和全参构造函数
     */
    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Student修改&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; //修改clone方法
   @Override
    protected Object clone() throws CloneNotSupportedException {
        Student s = (Student) super.clone();
        s.address = (Address) address.clone();
        return s;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201903/1090617-20190313235631951-1609979398.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;弊端&lt;/code&gt;: 这里我们Person 类只有一个 Address 引用类型，而 Address 类没有，所以我们只用重写 Address 类的clone 方法，但是如果 Address 类也存在一个引用类型，&lt;br/&gt;那么我们也要重写其clone 方法，这样下去，有多少个引用类型，我们就要重写多少次，如果存在很多引用类型，那么代码量显然会很大，所以这种方法不太合适。&lt;br/&gt;所以还有另一种实现深拷贝方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;序列化实现深拷贝&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//序列化实现深拷贝
public Object deepClone() throws Exception{
    // 序列化
    ByteArrayOutputStream bos = new ByteArrayOutputStream();
    ObjectOutputStream oos = new ObjectOutputStream(bos);
    oos.writeObject(this);
    // 反序列化
    ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());
    ObjectInputStream ois = new ObjectInputStream(bis);
    return ois.readObject();
}
　//因为序列化产生的是两个完全独立的对象，所有无论嵌套多少个引用类型，序列化都是能实现深拷贝的。&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;五arrays.copyof&quot;&gt;&lt;span&gt;五、Arrays.copyOf()&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;之前我误以为Arrays.copyOf()为深拷贝,那只是因为我用的是基本数据类型作为数组,而基本数据类型上面已经说过它没有深浅拷贝这个概念，可以把他理解成只有深拷贝。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; public static void main(String[] args) {

        //1、基本数据类型
        int[] a = {0, 1, 2, 3};
        // Arrays.copyOf拷贝
        int[] copy = Arrays.copyOf(a, a.length);
        a[0] = 1;
        System.out.println(Arrays.toString(copy));
        System.out.println(Arrays.toString(a));

        //2、对象数组
        Student[]  stuArr = {new Student(&quot;小小&quot;, 3, &quot;女&quot;),new Student(&quot;小小爸&quot;, 29, &quot;男&quot;),new Student(&quot;小小妈&quot;, 27, &quot;女&quot;)};
        // Arrays.copyOf拷贝
        Student[] copyStuArr = Arrays.copyOf(stuArr, stuArr.length);
        copyStuArr[0].setName(&quot;小小爷爷&quot;);
        System.out.println(Arrays.toString(stuArr));
        System.out.println(Arrays.toString(copyStuArr));
        

    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201903/1090617-20190313235732499-1673590724.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以明显看出,对于基本数据类型只有深拷贝,而对于数组对象而言,明显存在深浅拷贝,而且可以看出&lt;code&gt;Arrays.copyOf()为浅拷贝&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;只要自己变优秀了，其他的事情才会跟着好起来（少将2）&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 13 Mar 2019 16:06:00 +0000</pubDate>
<dc:creator>雨点的名字</dc:creator>
<og:description>java深浅拷贝 一、前言 为什么会有深浅拷贝这个概念? 我觉得主要跟JVM内存分配有关,对于基本数据类型,只存在栈内存,所以它的拷贝不存在深浅拷贝这个概念。而对于对象而言,一个对象的创建会在内存中分</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qdhxhz/p/10527245.html</dc:identifier>
</item>
<item>
<title>Java中的集合类、Lambda、鲁棒性简述 - Amboo</title>
<link>http://www.cnblogs.com/Jashinck/p/10527598.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Jashinck/p/10527598.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;集合类&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在java.util包中提供了一些集合类，常用的有List、Set和Map类，其中List类和Set类继承了Collection接口。这些集合类又称为容器，长度是可变的，数组用来存放基本数据类型的数据，集合用来存放类对象的引用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;List接口、Set接口、Map接口以及Collection接口的主要特征如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Collection接口是List接口和Set接口的父接口，通常情况下不被直接使用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;List接口继承了Collection接口，List接口允许存放重复的对象，排序方式为按照对象的插入顺序。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Set接口继承了Collection接口，Set接口不允许存放重复的对象，排序方式为按照自身内部的排序规则。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Map接口以键值对（key—value）的形式存放对象，其中键（key）对象不可以重复，值（value）对象可以重复，排序方式为按照自身内部的规则。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/918723/201903/918723-20190313235828452-1483138074.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Lambda表达式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其主要作用就是代替匿名内部类的繁琐语法， 它由三部分组成：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1） 形参列表。形参列表允许省略形参类型。如果形参列表中只有一个参数，甚至连形参列表的圆括号也可以省略。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2） 箭头（→）。必须通过英文中画线和大于符号组成。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）代码块。如果代码块只包含一条语句，Lambda表达式允许省略代码块的花括号，那么那条语句就不要用花括号表示语句结束。Lambda代码块只有一条return语句，甚至可以省略return关键字。Lambda表达式需要返回值，而它的代码块中仅有一套省略了return的语句。Lambda表达式会自动返回这条语句的值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;鲁棒性(Robust,即健壮性)&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;Java在编译和运行程序时，都要对可能出现的问题进行检查，以消除错误的产生。它提供自动垃圾收集来进行内存管理，防止程序员在管理内存时容易产生 的错误。通过集成的面向对象的例外处理机制，在编译时，Java揭示出可能出现但未被处理的例外，帮助程序员正确地进行选择以防止系统的崩溃。另外， Java在编译时还可捕获类型声明中的许多常见错误，防止动态运行时不匹配问题的出现。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 13 Mar 2019 15:59:00 +0000</pubDate>
<dc:creator>Amboo</dc:creator>
<og:description>集合类 在java.util包中提供了一些集合类，常用的有List、Set和Map类，其中List类和Set类继承了Collection接口。这些集合类又称为容器，长度是可变的，数组用来存放基本数据类</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Jashinck/p/10527598.html</dc:identifier>
</item>
<item>
<title>mybatis之旅第一篇-初识mybatis - 茶底世界</title>
<link>http://www.cnblogs.com/yuanqinnan/p/10527557.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuanqinnan/p/10527557.html</guid>
<description>&lt;h2&gt;一、JDBC的问题&lt;/h2&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;为什么我们要使用mybatis，是因为JDBC存在以下问题&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;1、 数据库连接创建、释放频繁造成系统资源浪费，从而影响系统性能。如果使用数据库连接池可解决此问题。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;2、 Sql语句在代码中硬编码，造成代码不易维护，实际应用中sql变化的可能较大，sql变动需要改变java代码。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;3、 使用preparedStatement向占有位符号传参数存在硬编码，因为sql语句的where条件不一定，可能多也可能少，修改sql还要修改代码，系统不易维护。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;4、 对结果集解析存在硬编码（查询列名），sql变化导致解析代码变化，系统不易维护，如果能将数据库记录封装成pojo对象解析比较方便。&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block&quot;&gt;二、&lt;span class=&quot;md-expand&quot;&gt;mybatis介绍&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block&quot;&gt;MyBatis 本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。2013年11月迁移到Github。&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;MyBatis是一个优秀的持久层框架，它对jdbc的操作数据库的过程进行封装，使开发者只需要关注 SQL 本身，而不需要花费精力去处理例如注册驱动、创建connection、创建statement、手动设置参数、结果集检索等jdbc繁杂的过程代码。&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;Mybatis通过xml或注解的方式将要执行的各种statement（statement、preparedStatemnt、CallableStatement）配置起来，并通过java对象和statement中的sql进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射成java对象并返回。​&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-focus&quot;&gt;三、&lt;span class=&quot;md-expand&quot;&gt;Mybatis架构&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201903/1113901-20190313232241040-1655203991.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;ol-list&quot;&gt;&lt;li class=&quot;md-list-item&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;mybatis配置&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;          SqlMapConfig.xml，此文件作为mybatis的全局配置文件，配置了mybatis的运行环境等信息。mapper.xml 文件即sql映射文件，文件中配置了操作数据库的sql语句。此文件需要在SqlMapConfig.xml中加载。&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;ol-list&quot; start=&quot;2&quot; readability=&quot;4.5&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;通过mybatis环境等配置信息构造SqlSessionFactory即会话工厂&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;由会话工厂创建sqlSession即会话，操作数据库需要通过sqlSession进行。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;mybatis底层自定义了Executor执行器接口操作数据库，Executor接口有两个实现，一个是基本执行器、一个是缓存执行器。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Mapped Statement也是mybatis一个底层封装对象，它包装了mybatis配置信息及sql映射信息等。mapper.xml文件中一个sql对应一个Mapped Statement对象，sql的id即是Mapped statement的id&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Mapped Statement对sql执行输入参数进行定义，包括HashMap、基本类型、pojo，Executor通过Mapped Statement在执行sql前将输入的java对象映射至sql中，输入参数映射就是jdbc编程中对preparedStatement设置参数。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;Mapped Statement对sql执行输出结果进行定义，包括HashMap、基本类型、pojo，Executor通过Mapped Statement在执行sql后将输出结果映射至java对象中，输出结果映射过程相当于jdbc编程中对结果的解析处理过程。&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;四、&lt;/span&gt;&lt;span class=&quot;md-expand&quot;&gt;入门程序&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;使用mybatis进行简单的增删改查能够让我们先有个大体感受，话不多说，开始撸代码&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;第一步：&lt;span class=&quot;md-expand&quot;&gt;新建一个maven项目&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;span class=&quot;md-expand&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201903/1113901-20190313232602928-1978170158.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;增加依赖，POM文件内容：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;project &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://maven.apache.org/POM/4.0.0&quot;&lt;/span&gt;&lt;span&gt; xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt;
  xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;modelVersion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;4.0.0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;modelVersion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.yuanqinnan&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;mybatis-first&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.0-SNAPSHOT&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;mybatis-first&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; FIXME change it to the project's website &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;http://www.example.com&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;properties&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;project.build.sourceEncoding&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;UTF-8&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;project.build.sourceEncoding&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;maven.compiler.source&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.7&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;maven.compiler.source&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;maven.compiler.target&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.7&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;maven.compiler.target&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;properties&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;junit&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;junit&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;4.11&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;test&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.mybatis&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;mybatis&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;3.4.1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;mysql&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;mysql-connector-java&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;6.0.6&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;log4j&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;log4j&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.2.17&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.slf4j&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;slf4j-log4j12&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.7.25&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;project&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;第二步：&lt;span class=&quot;md-expand&quot;&gt;添加配置文件&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;创建资源文件夹config，SqlMapConfig.xml配置文件，暂且不管在config下创建SqlMapConfig.xml，如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; &lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 和spring整合后 environments配置将废除 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;environments &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;=&quot;development&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;environment &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;development&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 使用jdbc事务管理 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;transactionManager &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;JDBC&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 数据库连接池 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dataSource &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;POOLED&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;driver&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;com.mysql.jdbc.Driver&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;url&quot;&lt;/span&gt;&lt;span&gt;
                          value&lt;/span&gt;&lt;span&gt;=&quot;jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;username&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;root&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;password&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;123456&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dataSource&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;environment&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;environments&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;第三步：&lt;span class=&quot;md-expand&quot;&gt;创建数据库并新建实体&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;创建脚本：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;68&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; `&lt;span&gt;user&lt;/span&gt;&lt;span&gt;` (
  `id` &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt; AUTO_INCREMENT,
  `username` &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;32&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;用户名称&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  `birthday` date &lt;/span&gt;&lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;生日&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  `sex` &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;性别&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  `address` &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;256&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;地址&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;PRIMARY&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt;&lt;span&gt; (`id`)
) ENGINE&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;InnoDB AUTO_INCREMENT&lt;span&gt;=&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; CHARSET&lt;span&gt;=&lt;/span&gt;&lt;span&gt;utf8;

&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt; ----------------------------&lt;/span&gt;&lt;span&gt;
--&lt;/span&gt;&lt;span&gt; Records of user&lt;/span&gt;&lt;span&gt;
--&lt;/span&gt;&lt;span&gt; ----------------------------&lt;/span&gt;
&lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; `&lt;span&gt;user&lt;/span&gt;` &lt;span&gt;VALUES&lt;/span&gt; (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;王五&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; `&lt;span&gt;user&lt;/span&gt;` &lt;span&gt;VALUES&lt;/span&gt; (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;张三&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2014-07-10&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;北京市&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; `&lt;span&gt;user&lt;/span&gt;` &lt;span&gt;VALUES&lt;/span&gt; (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;张小明&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;河南郑州&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; `&lt;span&gt;user&lt;/span&gt;` &lt;span&gt;VALUES&lt;/span&gt; (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;陈小明&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;河南郑州&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; `&lt;span&gt;user&lt;/span&gt;` &lt;span&gt;VALUES&lt;/span&gt; (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;张三丰&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;河南郑州&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; `&lt;span&gt;user&lt;/span&gt;` &lt;span&gt;VALUES&lt;/span&gt; (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;陈小明&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;河南郑州&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; `&lt;span&gt;user&lt;/span&gt;` &lt;span&gt;VALUES&lt;/span&gt; (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;王五&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;实体：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; User &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Serializable {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; serialVersionUID = 1L&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer id;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; String username;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用户姓名&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; String sex;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 性别&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; Date birthday;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 生日&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; String address;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 地址&lt;/span&gt;


    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer getId() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; id;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setId(Integer id) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.id =&lt;span&gt; id;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getUsername() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; username;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setUsername(String username) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.username =&lt;span&gt; username;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getSex() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; sex;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setSex(String sex) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sex =&lt;span&gt; sex;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Date getBirthday() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; birthday;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setBirthday(Date birthday) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.birthday =&lt;span&gt; birthday;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getAddress() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; address;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setAddress(String address) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.address =&lt;span&gt; address;
    }
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;User [id=&quot; + id + &quot;, username=&quot; + username + &quot;, sex=&quot; +&lt;span&gt; sex
                &lt;/span&gt;+ &quot;, birthday=&quot; + birthday + &quot;, address=&quot; + address + &quot;]&quot;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;第四步：sql映射文件&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;先新增一个查询方法&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; &lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; namespace：命名空间，用于隔离sql，还有一个很重要的作用，后面会讲 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mapper &lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt;=&quot;test&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;queryUserById&quot;&lt;/span&gt;&lt;span&gt; parameterType&lt;/span&gt;&lt;span&gt;=&quot;int&quot;&lt;/span&gt;&lt;span&gt; resultType&lt;/span&gt;&lt;span&gt;=&quot;com.yuanqinnan.model.User&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    SELECT * FROM `user`where id=#{id}
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;mapper&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;第五步：加载映射文件&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;在SqlMapConfig.xml中增加代码段&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mappers&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 映射文件方式1，一个一个的配置&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mapper &lt;/span&gt;&lt;span&gt;resource&lt;/span&gt;&lt;span&gt;=&quot;config/sqlmap/User.xml&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;mappers&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;整体结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201903/1113901-20190313233121077-1743175174.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;第六步：测试&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CRUDTest {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义 SqlSession&lt;/span&gt;
    SqlSession session =&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

    @Before
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; init(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义mybatis全局配置文件&lt;/span&gt;
        String resource = &quot;config/SqlMapConfig.xml&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加载 mybatis 全局配置文件&lt;/span&gt;
        InputStream inputStream = CRUDTest.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.getClassLoader()
                .getResourceAsStream(resource);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;构建sqlSession的工厂&lt;/span&gt;
        SqlSessionFactory sessionFactory = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SqlSessionFactoryBuilder().build(inputStream);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据 sqlSessionFactory 产生 session&lt;/span&gt;
        session =&lt;span&gt; sessionFactory.openSession();
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据id查询user表数据&lt;/span&gt;
&lt;span&gt;    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testSelectUserById(){
        String statement &lt;/span&gt;= &quot;queryUserById&quot;&lt;span&gt;;
        User user &lt;/span&gt;= session.selectOne(statement, 1&lt;span&gt;);
        System.out.println(user);
        session.close();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;测试结果：User [id=1, username=王五, sex=2, birthday=null, address=null]&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;至此，mybatis的功能已经实现，我们按照此例继续其他的操作&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block&quot;&gt;&lt;span&gt;五、其他操作&lt;/span&gt;&lt;/h2&gt;
&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;5.1查询列表&lt;/span&gt;&lt;/h3&gt;
&lt;h5 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;user.xml 增加查询&lt;/span&gt;&lt;/h5&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 查询 user 表的所有数据&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;selectUserAll&quot;&lt;/span&gt;&lt;span&gt; resultType&lt;/span&gt;&lt;span&gt;=&quot;com.yuanqinnan.model.User&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    select * from user
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;查询所有user表所有数据&lt;/span&gt;
&lt;span&gt;@Test
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testSelectUserAll(){
    String statement &lt;/span&gt;= &quot;selectUserAll&quot;&lt;span&gt;;
    List&lt;/span&gt;&amp;lt;User&amp;gt; listUser =&lt;span&gt; session.selectList(statement);
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(User user : listUser){
        System.out.println(user);
    }
    session.close();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201903/1113901-20190313233530414-1927624892.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;5.2模糊查询(用${}实现)&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;
            1、${value}里面必须要写value，不然会报错
            2、${}表示拼接 sql 字符串，将接收到的参数不加任何修饰拼接在sql语句中
            3、使用${}会造成 sql 注入
    &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;selectLikeUserName&quot;&lt;/span&gt;&lt;span&gt; resultType&lt;/span&gt;&lt;span&gt;=&quot;com.yuanqinnan.model.User&quot;&lt;/span&gt;&lt;span&gt; parameterType&lt;/span&gt;&lt;span&gt;=&quot;String&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        select * from user where username like '%${value}%'
        &lt;/span&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; select * from user where username like #{username} &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;模糊查询：根据 user 表的username字段(用${}实现)&lt;/span&gt;
&lt;span&gt;@Test
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testSelectLikeUserName(){
    String statement &lt;/span&gt;= &quot;selectLikeUserName&quot;&lt;span&gt;;
    List&lt;/span&gt;&amp;lt;User&amp;gt; listUser = session.selectList(statement, &quot;三&quot;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(User user : listUser){
        System.out.println(user);
    }
    session.close();

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201903/1113901-20190313233655242-1992877391.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;5.3 模糊查询(用#{}实现)&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;#{}实现&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;selectLikeUserName2&quot;&lt;/span&gt;&lt;span&gt; resultType&lt;/span&gt;&lt;span&gt;=&quot;com.yuanqinnan.model.User&quot;&lt;/span&gt;&lt;span&gt; parameterType&lt;/span&gt;&lt;span&gt;=&quot;String&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    select * from user where username like #{username}
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;模糊查询：根据 user 表的username字段(用#{}实现)&lt;/span&gt;
&lt;span&gt;@Test
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testSelectLikeUserName2(){
    String statement &lt;/span&gt;= &quot;selectLikeUserName2&quot;&lt;span&gt;;
    List&lt;/span&gt;&amp;lt;User&amp;gt; listUser = session.selectList(statement, &quot;%三%&quot;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(User user : listUser){
        System.out.println(user);
    }
    session.close();

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果与上面相同&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;5.4 新增用户&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 向 user 表插入一条数据 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;insert &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;insertUser&quot;&lt;/span&gt;&lt;span&gt; parameterType&lt;/span&gt;&lt;span&gt;=&quot;com.yuanqinnan.model.User&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    insert into user(id,username,sex,birthday,address)
        value(#{id},#{username},#{sex},#{birthday},#{address})
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;向 user 表中插入一条数据&lt;/span&gt;
&lt;span&gt;@Test
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testInsertUser(){
    String statement &lt;/span&gt;= &quot;insertUser&quot;&lt;span&gt;;
    User user &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User();
    user.setUsername(&lt;/span&gt;&quot;袁帅&quot;&lt;span&gt;);
    user.setSex(&lt;/span&gt;&quot;1&quot;&lt;span&gt;);
    session.insert(statement, user);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;提交插入的数据&lt;/span&gt;
&lt;span&gt;    session.commit();
    session.close();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201903/1113901-20190313233907171-68334337.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果我们想要返回当前新增的ID，则需要先获取自增ID&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 保存用户 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;insert &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;saveUser&quot;&lt;/span&gt;&lt;span&gt; parameterType&lt;/span&gt;&lt;span&gt;=&quot;com.yuanqinnan.model.User&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; selectKey 标签实现主键返回 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; keyColumn:主键对应的表中的哪一列 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; keyProperty：主键对应的pojo中的哪一个属性 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; order：设置在执行insert语句前执行查询id的sql，在执行insert语句之后执行查询id的sql &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; resultType：设置返回的id的类型 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;selectKey &lt;/span&gt;&lt;span&gt;keyColumn&lt;/span&gt;&lt;span&gt;=&quot;id&quot;&lt;/span&gt;&lt;span&gt; keyProperty&lt;/span&gt;&lt;span&gt;=&quot;id&quot;&lt;/span&gt;&lt;span&gt; order&lt;/span&gt;&lt;span&gt;=&quot;AFTER&quot;&lt;/span&gt;&lt;span&gt;
               resultType&lt;/span&gt;&lt;span&gt;=&quot;int&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        SELECT LAST_INSERT_ID()
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;selectKey&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    INSERT INTO `user`
    (username,birthday,sex,address) VALUES
    (#{username},#{birthday},#{sex},#{address})
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Test
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testInsertUser2(){
    String statement &lt;/span&gt;= &quot;saveUser&quot;&lt;span&gt;;
    User user &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User();
    user.setUsername(&lt;/span&gt;&quot;袁大帅&quot;&lt;span&gt;);
    user.setSex(&lt;/span&gt;&quot;1&quot;&lt;span&gt;);
    session.insert(statement, user);
    System.out.println(user);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;提交插入的数据&lt;/span&gt;
&lt;span&gt;    session.commit();
    session.close();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果：User [id=29, username=袁大帅, sex=1, birthday=null, address=null]&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;5.5 更新用户&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 根据 id 更新 user 表的数据 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;update &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;updateUserById&quot;&lt;/span&gt;&lt;span&gt; parameterType&lt;/span&gt;&lt;span&gt;=&quot;com.yuanqinnan.model.User&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    update user set username=#{username} where id=#{id}
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;update&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据 id 更新 user 表的数据&lt;/span&gt;
&lt;span&gt;@Test
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testUpdateUserById(){
    String statement &lt;/span&gt;= &quot;updateUserById&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果设置的 id不存在，那么数据库没有数据更改&lt;/span&gt;
    User user = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User();
    user.setId(&lt;/span&gt;29&lt;span&gt;);
    user.setUsername(&lt;/span&gt;&quot;袁不帅&quot;&lt;span&gt;);
    session.update(statement, user);
    session.commit();
    session.close();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201903/1113901-20190313234059096-1957657953.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;5.6 删除用户&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 根据 id 删除 user 表的数据 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;delete &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;deleteUserById&quot;&lt;/span&gt;&lt;span&gt; parameterType&lt;/span&gt;&lt;span&gt;=&quot;int&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    delete from user where id=#{id}
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//根据 id 删除 user 表的数据
@Test
public void testDeleteUserById(){
    String statement = &quot;deleteUserById&quot;;
    session.delete(statement,29);
    session.commit();
    session.close();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果：删除成功&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;6 总结&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;#{}和${}&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;#&lt;span&gt;{}表示一个占位符号，通过#{}可以实现preparedStatement向占位符中设置值，自动进行java类型和jdbc类型转换。#{}可以有效防止sql注入。 #{}可以接收简单类型值或pojo属性值。 如果parameterType传输单个简单类型值，#{}括号中可以是value或其它名称。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-inline-math&quot;&gt;&lt;span class=&quot;inline-math-svg math-jax-postprocess&quot;&gt;&lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;span id=&quot;MathJax-Element-2-Frame&quot; class=&quot;MathJax_SVG&quot;&gt;表示拼接串，通过&lt;span class=&quot;md-math-after-sym&quot;&gt;&lt;span&gt;{}可以将parameterType 传入的内容拼接在sql中且不进行jdbc类型转换， &lt;span class=&quot;md-inline-math&quot;&gt;&lt;span class=&quot;inline-math-svg math-jax-postprocess&quot;&gt;&lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;span id=&quot;MathJax-Element-3-Frame&quot; class=&quot;MathJax_SVG&quot;&gt;可以接收简单类型值或属性值，如果传输单个简单类型值，&lt;span class=&quot;md-math-after-sym&quot;&gt;&lt;span&gt;{}括号中只能是value。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;parameterType和resultType&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;parameterType：指定输入参数类型，mybatis通过ognl从输入对象中获取参数值拼接在sql中。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;resultType：指定输出结果类型，mybatis将sql查询结果的一行记录数据映射为resultType指定类型的对象。如果有多条数据，则分别进行映射，并把对象放到容器List中&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;selectOne和selectList&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;selectOne查询一条记录，如果使用selectOne查询多条记录则抛出异常：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;org.apache.ibatis.exceptions.TooManyResultsException: Expected one result (or null) to be returned by selectOne(), but found: 3&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;at org.apache.ibatis.session.defaults.DefaultSqlSession.selectOne(DefaultSqlSession.java:70)&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;selectList可以查询一条或多条记录。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;Mybatis解决jdbc编程的问题&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;1、 数据库连接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库连接池可解决此问题。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;解决：在SqlMapConfig.xml中配置数据连接池，使用连接池管理数据库链接。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;2、 Sql语句写在代码中造成代码不易维护，实际应用sql变化的可能较大，sql变动需要改变java代码。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;解决：将Sql语句配置在XXXXmapper.xml文件中与java代码分离。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;3、 向sql语句传参数麻烦，因为sql语句的where条件不一定，可能多也可能少，占位符需要和参数一一对应。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;解决：Mybatis自动将java对象映射至sql语句，通过statement中的parameterType定义输入参数的类型。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;4、 对结果集解析麻烦，sql变化导致解析代码变化，且解析前需要遍历，如果能将数据库记录封装成pojo对象解析比较方便。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;解决：Mybatis自动将sql执行&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;mybatis与hibernate不同&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Mybatis和hibernate不同，它不完全是一个ORM框架，因为MyBatis需要程序员自己编写Sql语句。mybatis可以通过XML或注解方式灵活配置要运行的sql语句，并将java对象和sql语句映射生成最终执行的sql，最后将sql执行的结果再映射生成java对象。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Mybatis学习门槛低，简单易学，程序员直接编写原生态sql，可严格控制sql执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，例如互联网软件、企业运营类软件等，因为这类软件需求变化频繁，一但需求变化要求成果输出迅速。但是灵活的前提是mybatis无法做到数据库无关性，如果需要实现支持多种数据库的软件则需要自定义多套sql映射文件，工作量大。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Hibernate对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件（例如需求固定的定制化软件）如果用hibernate开发可以节省很多代码，提高效率。但是Hibernate的学习门槛高，要精通门槛更高，而且怎么设计O/R映射，在性能和对象模型之间如何权衡，以及怎样用好Hibernate需要具有很强的经验和能力才行。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;总之，按照用户的需求在有限的资源环境下只要能做出维护性、扩展性良好的软件架构都是好架构，所以框架只有适合才是最好。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 13 Mar 2019 15:45:00 +0000</pubDate>
<dc:creator>茶底世界</dc:creator>
<og:description>一、JDBC的问题 为什么我们要使用mybatis，是因为JDBC存在以下问题 1、 数据库连接创建、释放频繁造成系统资源浪费，从而影响系统性能。如果使用数据库连接池可解决此问题。 2、 Sql语句在</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuanqinnan/p/10527557.html</dc:identifier>
</item>
<item>
<title>测试客户端连接12c ASM实例 - AlfredZhao</title>
<link>http://www.cnblogs.com/jyzhao/p/10527450.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jyzhao/p/10527450.html</guid>
<description>&lt;p&gt;&lt;strong&gt;环境：&lt;/strong&gt;Oracle 12.2.0.1 RAC&lt;br/&gt;&lt;strong&gt;背景：&lt;/strong&gt;用户反映12c ASM创建的用户具备sysasm权限，但无法在客户端连接到ASM实例，且没有报错。&lt;/p&gt;

&lt;p&gt;sqlplus / as sysasm&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SQL&amp;gt; create user infa identified by infa;
User created.
SQL&amp;gt; grant sysasm to infa;
Grant succeeded.&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;分别针对ASM实例1和实例2配置对应的信息：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ASM12c1 =
  (DESCRIPTION =
    (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.1.90)(PORT = 1521))
    (CONNECT_DATA =
      (SERVER = DEDICATED)
      (SERVICE_NAME = +ASM)
      (INSTANCE_NAME = +ASM1)
    )
  )
  
ASM12c2 =
  (DESCRIPTION =
    (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.1.92)(PORT = 1521))
    (CONNECT_DATA =
      (SERVER = DEDICATED)
      (SERVICE_NAME = +ASM)
      (INSTANCE_NAME = +ASM2)
    )
  )&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为是12c版本，无需配置UR=A，关于UR=A可参考之前的测试：&lt;/p&gt;

&lt;p&gt;客户端测试连接ASM12c1:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[oracle@db01 admin]$ sqlplus infa/infa@asm12c1 as sysasm

SQL*Plus: Release 11.2.0.4.0 Production on Wed Mar 13 22:45:53 2019

Copyright (c) 1982, 2013, Oracle.  All rights reserved.


Connected to:
Oracle Database 12c Enterprise Edition Release 12.2.0.1.0 - 64bit Production

SQL&amp;gt; show parameter instance_name

NAME                                 TYPE
------------------------------------ ----------------------
VALUE
------------------------------
instance_name                        string
+ASM1
SQL&amp;gt; exit
Disconnected from Oracle Database 12c Enterprise Edition Release 12.2.0.1.0 - 64bit Production&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;客户端测试连接ASM12c2:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[oracle@db01 admin]$ sqlplus infa/infa@asm12c2 as sysasm

SQL*Plus: Release 11.2.0.4.0 Production on Wed Mar 13 22:46:19 2019

Copyright (c) 1982, 2013, Oracle.  All rights reserved.


Connected to:
Oracle Database 12c Enterprise Edition Release 12.2.0.1.0 - 64bit Production

SQL&amp;gt; show parameter instance_name

NAME                                 TYPE
------------------------------------ ----------------------
VALUE
------------------------------
instance_name                        string
+ASM2
SQL&amp;gt; &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我测试是没有任何问题的，明天连接实际客户环境再进一步看具体情况。&lt;/p&gt;
</description>
<pubDate>Wed, 13 Mar 2019 15:18:00 +0000</pubDate>
<dc:creator>AlfredZhao</dc:creator>
<og:description>环境： Oracle 12.2.0.1 RAC 背景： 用户反映12c ASM创建的用户具备sysasm权限，但无法在客户端连接到ASM实例，且没有报错。 '1.ASM实例创建用户赋予sysasm权限</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jyzhao/p/10527450.html</dc:identifier>
</item>
<item>
<title>MCD 机电一体化概念设计首选项 - jgh</title>
<link>http://www.cnblogs.com/cosimulation/p/10527436.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cosimulation/p/10527436.html</guid>
<description>&lt;p&gt;机电一体化概念设计首选项(机电概念首选项)可以更改默认的系统参数并将其应用到工作部件中，可以灵活地在工作部件中设置不同于用户默认设置的系统参数。在机电概念首选项中可以执行以下操作：&lt;/p&gt;
&lt;p&gt;1 设置重力、摩擦和阻尼属性。&lt;/p&gt;
&lt;p&gt;2 调整物理引擎。&lt;/p&gt;
&lt;p&gt;3 设置仿真刷新频率。&lt;/p&gt;
&lt;p&gt;4 更改仿真显示速度。&lt;/p&gt;
&lt;p&gt;5 设置联合仿真主机和时序设置。&lt;/p&gt;

&lt;p&gt;通常可以从两个地方对MCD的默认系统参数进行设置：用户默认设置（下图右）和机电概念首选项（下图左）。两者的区别在于：用户默认设置用于全局默认参数的设置，设置后需要重启NX才能生效。机电概念首选项设置的参数存储在工作部件中，只对当前工作部件有效，机电概念首选项设置的参数将会覆盖用户默认设置的参数。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1058890/201903/1058890-20190313231229928-1081489622.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;各参数具体含义如下：&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;
&lt;table border=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;23.5&quot;&gt;&lt;tr&gt;&lt;td colspan=&quot;2&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;常规选项&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td width=&quot;14%&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;重力&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;84%&quot; readability=&quot;7&quot;&gt;
&lt;p align=&quot;left&quot;&gt;指定重力在全局坐标系中的 X, Y, Z 分量。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td width=&quot;14%&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;材料参数&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;84%&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;指定材料的碰撞参数，包括动摩擦/动摩擦/滑动摩擦系数，以及恢复系数。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td width=&quot;14%&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;阻尼&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;84%&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;指定线性或角度阻尼值，以降低振动幅度。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td width=&quot;14%&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;碰撞高亮&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;84%&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;当碰撞体接触相似的碰撞体时，高亮显示模型中的碰撞体。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td colspan=&quot;2&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;机电引擎选项&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;12.5&quot;&gt;&lt;td width=&quot;14%&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;运行时参数&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;84%&quot; readability=&quot;18&quot;&gt;
&lt;p align=&quot;left&quot;&gt;设置以下默认的运行时参数：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;碰撞精度—&lt;/strong&gt;设置碰撞检测的精度。当两个碰撞体距离小于等于该值，可以认为两个对象发生了碰撞。距离达到该值时物体可以相互穿透。较大的值更有效，但会导致更大的穿透率。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;分布时间—&lt;/strong&gt;设置最小时间增量。每个时间步长进行一次物理计算。动作不会在时间步长之内发生。较大的值会提高系统性能，但会降低准确性。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;注意：步长过大可能会导致模拟不稳定，约束中断，物体获得无限能量。如果出现不稳定性，可以减小步长，使步长的倒数比系统中最快振荡的频率大10倍。默认步长为1毫秒，振荡频率低于100赫兹。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;弹力乘数—&lt;/strong&gt;指定在仿真过程中鼠标拖动对象时施加的力。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;12&quot;&gt;&lt;td width=&quot;14%&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;物理引擎调整&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;84%&quot; readability=&quot;17&quot;&gt;
&lt;p align=&quot;left&quot;&gt;指定物理引擎的默认值。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;公差—&lt;/strong&gt;设置关节允许变动量，该距离仍被视为关节对齐（关节位置未改变）。较大的值求解得更快，但会导致关节定位中有更多的间隙。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;误差减少量—&lt;/strong&gt;设置决定关节位置求解速度的因子。较大的值会导致解算器以较少的步骤将关节拉在一起，但过高的值会导致不稳定。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;最大迭代次数—&lt;/strong&gt;设置每个时间步长的最大迭代次数，求解器使用该次数求解关节的位置，并使其所有位置都在公差范围内。较大的值会让求解器有更多的时间将大量关节放置到位，但求解可能需要更长的时间。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;粘着力—&lt;/strong&gt;设置碰撞体之间的结合力，以抵消碰撞引起的排斥力。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td colspan=&quot;2&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;运行时控制选项&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td colspan=&quot;2&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;部件设置&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;显示多个零件时，这些设置仅适用于工作零件。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td width=&quot;14%&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;刷新精度&lt;/strong&gt;&lt;strong&gt;( % )&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;84%&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;指定查看器中值的刷新率，以确定是否更新UI中的属性值。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td width=&quot;14%&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;步长&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;84%&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;指定查看器的步长，指定仿真期间采样点的时间间隔。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td colspan=&quot;2&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;会话设置&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;当显示多个零件时，这些设置适用于整个仿真。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td width=&quot;14%&quot;&gt;
&lt;p align=&quot;left&quot;&gt;默认缩放因子&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;84%&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;指定仿真的显示速率。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td width=&quot;14%&quot;&gt;
&lt;p align=&quot;left&quot;&gt;单步前进时间&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;84%&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;指定仿真的时间增量，单步前进中仿真进行的时间量。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td colspan=&quot;2&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;协同仿真选项&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td width=&quot;14%&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;使用时间同步&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;84%&quot; readability=&quot;7&quot;&gt;
&lt;p align=&quot;left&quot;&gt;同步MCD信号的PLCSIM Adv信号&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;PLCSIM Adv处于冻结模式。MCD比较仿真时间并和PLCSIM Adv保持同步。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td width=&quot;14%&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;启用&lt;/strong&gt;&lt;strong&gt;SIMIT&lt;/strong&gt;&lt;strong&gt;控制服务&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;84%&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;设置运行启动SIMIT协同仿真。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td width=&quot;14%&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;主导程序&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;84%&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;指定MCD或SIMIT控制哪个是仿真主导软件。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td width=&quot;14%&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;激活时间同步&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;84%&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;当主机设置为MCD时可用。设置同步时间以设置数据传输间隔。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td colspan=&quot;2&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;序列编辑器选项&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td width=&quot;14%&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;导出后调用时序图&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;84%&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;允许导出后打开时序文件。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td colspan=&quot;2&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;系统导航选项&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td colspan=&quot;2&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;仅适用于集成到Teamcenter的NX。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td width=&quot;14%&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;保存时加载&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;84%&quot;&gt;
&lt;p align=&quot;left&quot;&gt;设置加载选项。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td width=&quot;14%&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;选择修订规则&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;84%&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;从Teamcenter加载模型时，将修订规则设置为。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1058890/201903/1058890-20190313231424266-899294276.jpg&quot; alt=&quot;&quot;/&gt;该公众号主要介绍工业仿真软件及虚拟调试技术，欢迎各位小伙伴们关注。&lt;/p&gt;
</description>
<pubDate>Wed, 13 Mar 2019 15:16:00 +0000</pubDate>
<dc:creator>jgh</dc:creator>
<og:description>机电一体化概念设计首选项(机电概念首选项)可以更改默认的系统参数并将其应用到工作部件中，可以灵活地在工作部件中设置不同于用户默认设置的系统参数。在机电概念首选项中可以执行以下操作： 1 设置重力、摩擦</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cosimulation/p/10527436.html</dc:identifier>
</item>
</channel>
</rss>