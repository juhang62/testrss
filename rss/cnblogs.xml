<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>MySQL 常用操作 - 刘哇勇</title>
<link>http://www.cnblogs.com/Wayou/p/mysql_most_used_actions.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Wayou/p/mysql_most_used_actions.html</guid>
<description>&lt;p&gt;如果是本地开发，使用 GUI 工具比如官方的 &lt;a href=&quot;https://www.mysql.com/products/workbench/&quot; rel=&quot;nofollow&quot;&gt;MySQL Workbench&lt;/a&gt; 会省事很多，但命令行方式在服务器环境特别有用。&lt;/p&gt;
&lt;p&gt;另，如果官方的下载地址很慢的话，可尝试这个&lt;a href=&quot;http://www.mirrorservice.org/sites/ftp.mysql.com/Downloads/MySQLGUITools/&quot; rel=&quot;nofollow&quot;&gt;镜像&lt;/a&gt;，速度超快的。&lt;/p&gt;
&lt;h2&gt;数据库&lt;/h2&gt;
&lt;h3&gt;创建数据库&lt;/h3&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
CREATE DATABASE &lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt;db_name&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;删除数据库&lt;/h3&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;DROP&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;DATABASE&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt;db_name&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt;; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意 &lt;code&gt;DROP&lt;/code&gt; 操作没有确认步骤，回车就执行了。所以进行删除操作时需要谨慎。&lt;/p&gt;
&lt;h3&gt;重命名数据库&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;RENAME&lt;/code&gt; 命令是用来对表进行重命名的，数据库没有对应的命令，只能间接实现。原理是将老数据库中的所有表重命名到新数据库下。当然，首先得创建新数据库。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
RENAME TABLE &lt;span class=&quot;pl-c1&quot;&gt;old_db&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;table&lt;/span&gt; TO &lt;span class=&quot;pl-c1&quot;&gt;new_db&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;table&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是一个重复性的操作，所以可以通过脚本来实现，&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
mysql -u username -ppassword old_db -sNe &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;show tables&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;read&lt;/span&gt; table&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;pl-cce&quot;&gt;\ &lt;/span&gt;
    &lt;span class=&quot;pl-k&quot;&gt;do&lt;/span&gt; mysql -u username -ppassword -sNe &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;rename table old_db.&lt;span class=&quot;pl-smi&quot;&gt;$table&lt;/span&gt; to new_db.&lt;span class=&quot;pl-smi&quot;&gt;$table&lt;/span&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;done&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或，&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;mysql -u root -ppassword -s -N -e &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;use old_db;show tables from old_db;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;do&lt;/span&gt; mysql -u root -ppassword -s -N -e &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;use old_db;rename table old_db.&lt;span class=&quot;pl-smi&quot;&gt;$table&lt;/span&gt; to new_db.&lt;span class=&quot;pl-smi&quot;&gt;$table&lt;/span&gt;;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;done&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中 &lt;code&gt;-ppassword&lt;/code&gt; 中 &lt;code&gt;password&lt;/code&gt; 为你的密码，和 &lt;code&gt;-p&lt;/code&gt; 之间没有空格。&lt;/p&gt;
&lt;h3&gt;清空数据库&lt;/h3&gt;
&lt;p&gt;清空数据库，即清空数据库中所有表中的记录。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;15&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;SET&lt;/span&gt; FOREIGN_KEY_CHECKS &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;;

&lt;span class=&quot;pl-k&quot;&gt;SELECT&lt;/span&gt; @str :&lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; CONCAT(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;TRUNCATE TABLE &lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;, table_schema, &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;.&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;, table_name, &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;)
&lt;span class=&quot;pl-k&quot;&gt;FROM&lt;/span&gt;   &lt;span class=&quot;pl-c1&quot;&gt;information_schema&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;tables&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;WHERE&lt;/span&gt;  table_type   &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;BASE TABLE&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;
  &lt;span class=&quot;pl-k&quot;&gt;AND&lt;/span&gt;  table_schema &lt;span class=&quot;pl-k&quot;&gt;IN&lt;/span&gt; (&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;db1_name&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;,&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;db2_name&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;);

PREPARE stmt &lt;span class=&quot;pl-k&quot;&gt;FROM&lt;/span&gt; @str;

EXECUTE stmt;

DEALLOCATE PREPARE stmt;

&lt;span class=&quot;pl-k&quot;&gt;SET&lt;/span&gt; FOREIGN_KEY_CHECKS &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;导出数据库&lt;/h3&gt;
&lt;p&gt;导出操作是通过 &lt;code&gt;mysqldump&lt;/code&gt; 命令行工具来完成的。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
$ mysqldump &lt;span class=&quot;pl-k&quot;&gt;-&lt;/span&gt;u &lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt;username&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;-&lt;/span&gt;p &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;--&lt;/span&gt;dabases [db1] [db2]... &amp;gt; backup.sql&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;默认导出时是带数据记录的，可通过 &lt;code&gt;--no-data&lt;/code&gt; 只导出表结构，&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
$ mysqldump &lt;span class=&quot;pl-k&quot;&gt;-&lt;/span&gt;u &lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt;username&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;-&lt;/span&gt;p &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;--&lt;/span&gt;no-data --dabases [db1] [db2]... &amp;gt; backup.sql&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;更多 &lt;code&gt;mysqldump&lt;/code&gt; 相关的参数可参见&lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/mysqldump.html&quot; rel=&quot;nofollow&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;导入数据库&lt;/h3&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
mysql &lt;span class=&quot;pl-k&quot;&gt;-&lt;/span&gt;u username &lt;span class=&quot;pl-k&quot;&gt;-&lt;/span&gt;ppassword database_name &lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;backup&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;sql&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;表&lt;/h2&gt;
&lt;h3&gt;创建表&lt;/h3&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
CREATE TABLE [IF NOT EXISTS] table_name(
    column_list
);
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;重命名表&lt;/h3&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot;&gt;
&lt;pre&gt;
RENAME TABLE tb1 TO tb2;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果想一次重命名多张表，&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
RENAME TABLE tb1 TO tb2, tb3 TO tb4;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;删除表&lt;/h3&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;DROP&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt;table_name&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;同时删除多张表，&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;DROP&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;TABLE&lt;/span&gt; table1,table2...;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;像这种操作表记录的，如果表存在外键关联，一般会报错，如果你明显知道自己在干什么，且知道操作是安全的，可暂时关闭 MySQL 的外键检查，操作完成后再开启。后续的操作中遇到该报错可同样应用此设置。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;SET&lt;/span&gt; FOREIGN_KEY_CHECKS &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;; 
&lt;span class=&quot;pl-k&quot;&gt;DROP&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt;table_name&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt;;
&lt;span class=&quot;pl-k&quot;&gt;SET&lt;/span&gt; FOREIGN_KEY_CHECKS &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;; 
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;清空表&lt;/h3&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
TRUNCATE [TABLE] tbl_name;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;列&lt;/h2&gt;
&lt;h3&gt;更新列&lt;/h3&gt;
&lt;p&gt;更新列的定义可通过 &lt;code&gt;CHANGE&lt;/code&gt; 或 &lt;code&gt;MODIFY&lt;/code&gt;。 区别仅在于后者不需要重新指定一个新的一列名。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;ALTER&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;TABLE&lt;/span&gt; MyTable CHANGE COLUMN foo bar &lt;span class=&quot;pl-k&quot;&gt;VARCHAR&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;32&lt;/span&gt;) &lt;span class=&quot;pl-k&quot;&gt;NOT NULL&lt;/span&gt; FIRST;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;ALTER&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;TABLE&lt;/span&gt; MyTable MODIFY COLUMN foo &lt;span class=&quot;pl-k&quot;&gt;VARCHAR&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;32&lt;/span&gt;) &lt;span class=&quot;pl-k&quot;&gt;NOT NULL&lt;/span&gt; AFTER baz;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;添加列&lt;/h3&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;ALTER&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt;table_name&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; ADD COLUMN tempID &lt;span class=&quot;pl-k&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;NULL&lt;/span&gt; DEFAULT &lt;span class=&quot;pl-c1&quot;&gt;3&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;默认会添加到表中最后一列，可通过 &lt;code&gt;AFTER&lt;/code&gt; 来控制其位置。比如，将新增的列添加到 &lt;code&gt;ID&lt;/code&gt; 列后面。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;ALTER&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt;table_name&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; ADD COLUMN tempID &lt;span class=&quot;pl-k&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;NULL&lt;/span&gt; DEFAULT &lt;span class=&quot;pl-c1&quot;&gt;3&lt;/span&gt; AFTER ID;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;删除列&lt;/h3&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;ALTER&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt;table_name&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; DROP COLUMN &lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt;column_name&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一次删除多列，&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;ALTER&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;TABLE&lt;/span&gt; table
DROP COLUMN column_1,
DROP COLUMN column_2,
…;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;记录&lt;/h2&gt;
&lt;h3&gt;插入记录&lt;/h3&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;13&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;INSERT INTO&lt;/span&gt; table_name (column1, column2, column3, ...)
&lt;span class=&quot;pl-k&quot;&gt;VALUES&lt;/span&gt; (value1, value2, value3, ...);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一次插入多条记录：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;17&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;INSERT INTO&lt;/span&gt; table(c1,c2,...)
&lt;span class=&quot;pl-k&quot;&gt;VALUES&lt;/span&gt; 
   (v11,v12,...),
   (v21,v22,...),
    ...
   (vnn,vn2,...);
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;删除记录&lt;/h3&gt;
&lt;p&gt;删除满足条件的列：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;DELETE&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;table_name&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;&lt;/span&gt; [&lt;span class=&quot;pl-k&quot;&gt;WHERE&lt;/span&gt; condition];
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果是删除某列其值介于一个区间，比如 id 在 50~100 的记录，可以这样：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;DELETE&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;FROM&lt;/span&gt; tablename &lt;span class=&quot;pl-k&quot;&gt;WHERE&lt;/span&gt; id BETWEEN &lt;span class=&quot;pl-c1&quot;&gt;50&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;AND&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;100&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;需要删除的记录，其某列的值，在一个可选的列表中，可以将 &lt;code&gt;WHERE&lt;/code&gt; 搭配 &lt;code&gt;IN&lt;/code&gt; 关键词：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;11&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;DELETE&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;FROM&lt;/span&gt; tablename &lt;span class=&quot;pl-k&quot;&gt;WHERE&lt;/span&gt; id &lt;span class=&quot;pl-k&quot;&gt;IN&lt;/span&gt; (&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;pl-c1&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;pl-c1&quot;&gt;3&lt;/span&gt;,...,&lt;span class=&quot;pl-c1&quot;&gt;254&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;像上面范围命中时，还可配合 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 不等于来进一步控制：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;DELETE&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;FROM&lt;/span&gt; tablename &lt;span class=&quot;pl-k&quot;&gt;WHERE&lt;/span&gt; id BETWEEN &lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;AND&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;254&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;AND&lt;/span&gt; id&lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;10&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;范围的情况常用的场景是命中一个日期区间的记录：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;DELETE&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;objects&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;WHERE&lt;/span&gt; (date_field BETWEEN &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;2010-01-30 14:15:55&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;AND&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;2010-09-29 10:15:55&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;更新记录&lt;/h3&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;UPDATE&lt;/span&gt; [LOW_PRIORITY] [IGNORE] table_name 
&lt;span class=&quot;pl-k&quot;&gt;SET&lt;/span&gt; 
    column_name1 &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; expr1,
    column_name2 &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; expr2,
    ...
[&lt;span class=&quot;pl-k&quot;&gt;WHERE&lt;/span&gt;
    condition];
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;UPDATE&lt;/span&gt; employees 
&lt;span class=&quot;pl-k&quot;&gt;SET&lt;/span&gt; 
    lastname &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;Hill&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;,
    email &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;mary.hill@classicmodelcars.com&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;WHERE&lt;/span&gt;
    employeeNumber &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;1056&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;外键&lt;/h2&gt;
&lt;h3&gt;创建外键&lt;/h3&gt;
&lt;p&gt;外键可在创建表时指定，通过 &lt;code&gt;FOREIGN KEY&lt;/code&gt; 关键字。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;CONSTRAINT&lt;/span&gt; constraint_name
&lt;span class=&quot;pl-k&quot;&gt;FOREIGN KEY&lt;/span&gt; foreign_key_name (columns)
&lt;span class=&quot;pl-k&quot;&gt;REFERENCES&lt;/span&gt; parent_table(columns)
&lt;span class=&quot;pl-k&quot;&gt;ON DELETE&lt;/span&gt; action
&lt;span class=&quot;pl-k&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;UPDATE&lt;/span&gt; action
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;12&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Orders&lt;/span&gt; (
    OrderID &lt;span class=&quot;pl-k&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;NOT NULL&lt;/span&gt;,
    OrderNumber &lt;span class=&quot;pl-k&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;NOT NULL&lt;/span&gt;,
    PersonID &lt;span class=&quot;pl-k&quot;&gt;int&lt;/span&gt;,
    &lt;span class=&quot;pl-k&quot;&gt;PRIMARY KEY&lt;/span&gt; (OrderID),
    &lt;span class=&quot;pl-k&quot;&gt;FOREIGN KEY&lt;/span&gt; (PersonID) &lt;span class=&quot;pl-k&quot;&gt;REFERENCES&lt;/span&gt; Persons(PersonID)
);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于已经存在的表，使用 &lt;code&gt;ALTER TABLE&lt;/code&gt; 配合 &lt;code&gt;ADD FOREIGN KEY&lt;/code&gt; 来完成。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
ALTER table_name
ADD &lt;span class=&quot;pl-k&quot;&gt;CONSTRAINT&lt;/span&gt; constraint_name
&lt;span class=&quot;pl-k&quot;&gt;FOREIGN KEY&lt;/span&gt; foreign_key_name(columns)
&lt;span class=&quot;pl-k&quot;&gt;REFERENCES&lt;/span&gt; parent_table(columns)
&lt;span class=&quot;pl-k&quot;&gt;ON DELETE&lt;/span&gt; action
&lt;span class=&quot;pl-k&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;UPDATE&lt;/span&gt; action;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;ALTER&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;TABLE&lt;/span&gt; Orders
ADD &lt;span class=&quot;pl-k&quot;&gt;FOREIGN KEY&lt;/span&gt; (PersonID) &lt;span class=&quot;pl-k&quot;&gt;REFERENCES&lt;/span&gt; Persons(PersonID);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;创建的同时可指定一个外键名，否则 MySQL 会自己生成一个。这个名字在删除时有用。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;ALTER&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;TABLE&lt;/span&gt; Orders
ADD &lt;span class=&quot;pl-k&quot;&gt;CONSTRAINT&lt;/span&gt; FK_PersonOrder
&lt;span class=&quot;pl-k&quot;&gt;FOREIGN KEY&lt;/span&gt; (PersonID) &lt;span class=&quot;pl-k&quot;&gt;REFERENCES&lt;/span&gt; Persons(PersonID);
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;外键删除&lt;/h3&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;ALTER&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;TABLE&lt;/span&gt; table_name 
DROP &lt;span class=&quot;pl-k&quot;&gt;FOREIGN KEY&lt;/span&gt; constraint_name;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;创建并查看表的关系图&lt;/h2&gt;
&lt;p&gt;有一样是命令行无法进行的，那就是生成数据库整体的表关系图(&lt;a href=&quot;https://dev.mysql.com/doc/workbench/en/wb-creating-eer-diagram.html&quot; rel=&quot;nofollow&quot;&gt;EER 图&lt;/a&gt;)。这个需要借助文章开头提到的 GUI 工具 MySQL Workbench。&lt;/p&gt;
&lt;p&gt;方法是从菜单中 &lt;code&gt;database&lt;/code&gt; -&amp;gt; &lt;code&gt;Reverse Engineer...&lt;/code&gt; 进入，然后跟着向导一步步直到结束，便创建好了相应数据库的表间关系图。&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://user-images.githubusercontent.com/3783096/57940394-ff31f080-78fe-11e9-8010-96cb561734c1.png&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/3783096/57940394-ff31f080-78fe-11e9-8010-96cb561734c1.png&quot; alt=&quot;MySQL Reverse Engineer 菜单&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;MySQL Reverse Engineer 菜单&lt;/p&gt;
&lt;p&gt;生成结果示例：&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://user-images.githubusercontent.com/3783096/57940601-5e900080-78ff-11e9-809e-118d12a6d910.png&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/3783096/57940601-5e900080-78ff-11e9-809e-118d12a6d910.png&quot; alt=&quot;MySQL EER 图&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;MySQL EER 图&lt;/p&gt;
&lt;h2&gt;相关资源&lt;/h2&gt;
</description>
<pubDate>Fri, 17 May 2019 15:47:00 +0000</pubDate>
<dc:creator>刘哇勇</dc:creator>
<og:description>如果是本地开发，使用 GUI 工具比如官方的 MySQL Workbench 会省事很多，但命令行方式在服务器环境特别有用。 另，如果官方的下载地址很慢的话，可尝试这个镜像，速度超快的。 数据库 创建</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Wayou/p/mysql_most_used_actions.html</dc:identifier>
</item>
<item>
<title>Java面试题总结之Java基础(三) - AlbertYang666</title>
<link>http://www.cnblogs.com/yangxianyang/p/10884192.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yangxianyang/p/10884192.html</guid>
<description>&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;strong&gt;、&lt;/strong&gt;&lt;strong&gt;JAVA&lt;/strong&gt; &lt;strong&gt;语言如何进行异常处理，关键字：&lt;/strong&gt;&lt;strong&gt;throws,throw,try,catch,finally&lt;/strong&gt;&lt;strong&gt;分别代表什么意义？在&lt;/strong&gt;&lt;strong&gt;try&lt;/strong&gt; &lt;strong&gt;块中可以抛出异常吗&lt;/strong&gt;&lt;strong&gt;？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答：Java 通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供了良好的接口。在Java 中，每个异常都是一个对象，它是Throwable 类或其它子类的实例。当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并进行处理。Java 的异常处理是通过5 个关键词来实现的：try、catch、throw、throws 和finally。一般情况下是用try 来执行一段程序，如果出现异常，系统会抛出（throws）一个异常，这时候你可以通过它的类型来捕捉（catch）它，或最后（finally）由缺省处理器来处理；try 用来指定一块预防所有“异常”的程序；catch 子句紧跟在try 块后面，用来指定你想要捕捉的“异常”的类型；throw 语句用来明确地抛出一个“异常”；throws 用来标明一个成员函数可能抛出的各种“异常”；Finally 为确保一段代码不管发生什么“异常”都被执行的一段代码；可以在一个成员函数调用的外面写一个try 语句，在这个成员函数内部写另一个try 语句保护其他代码。每当遇到一个try 语句，“异常”的框架就放到堆栈上面，直到所有的try 语句都完成。如果下一级的try 语句没有对某种“异常”进行处理，堆栈就会展开，直到遇到有处理这种“异常”的try 语句。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;strong&gt;、运行时异常与一般异常有何异同？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答：异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误。java 编译器要求方法必须声明抛出可能发生的非运行时异常，但是并不要求必须声明抛出未被捕获的运行时异常。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;strong&gt;、说出一个你最常见到的&lt;/strong&gt;&lt;strong&gt;runtime exception&lt;/strong&gt;&lt;strong&gt;？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答：&lt;span&gt;ArithmeticException, ArrayStoreException, BufferOverflowException,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;BufferUnderflowException, CannotRedoException, CannotUndoException,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ClassCastException, CMMException, ConcurrentModificationException,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;DOMException, EmptyStackException, IllegalArgumentException,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;IllegalMonitorStateException, IllegalPathStateException,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;IllegalStateException, ImagingOpException, IndexOutOfBoundsException,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;MissingResourceException, NegativeArraySizeException,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;NoSuchElementException, NullPointerException, ProfileDataException,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ProviderException, RasterFormatException, SecurityException,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SystemException, UndeclaredThrowableException,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;UnmodifiableSetException, UnsupportedOperationException&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4&lt;/strong&gt;&lt;strong&gt;、&lt;/strong&gt;&lt;strong&gt;final, finally, finalize&lt;/strong&gt; &lt;strong&gt;的区别&lt;/strong&gt;&lt;strong&gt;?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答：final：修饰符（关键字）；如果一个类被声明为final，意味着它不能不能作为父类被继承，因此一个类不能既被声明为abstract的，又被声明为final 的；将变量或方法声明为final，可以保证它们在使用中不被改变；被声明为final 的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改；被声明为final 的方法也同样只能使用，不能重载。finally：异常处理时提供finally 块来执行任何清除操作。finalize：方法名；Java 技术允许使用finalize() 方法在垃圾收集器，将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时，对这个对象调用的。它是在Object 类中定义的，因此所有的类都继承了它。子类覆盖finalize() 方法以整理系统资源或者执行其他清理工作。finalize() 方法是在垃圾收集器删除对象之前对这个对象调用的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5&lt;/strong&gt;&lt;strong&gt;、类&lt;/strong&gt;&lt;strong&gt;Example A&lt;/strong&gt; &lt;strong&gt;继承&lt;/strong&gt;&lt;strong&gt;Exception&lt;/strong&gt;&lt;strong&gt;，类&lt;/strong&gt;&lt;strong&gt;ExampleB&lt;/strong&gt; &lt;strong&gt;继承&lt;/strong&gt;&lt;strong&gt;Example A&lt;/strong&gt;&lt;strong&gt;；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有如下代码片断：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{

&lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ExampleB(“b”)；

}&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;（ExampleA e）{

System.out.printfln（“ExampleA”）；

}&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;（Exception e）{

System.out.printfln（“Exception”）；

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;输出的内容应该是：&lt;/p&gt;
&lt;p&gt;A：ExampleA  B：Exception  C：b  D：无&lt;/p&gt;
&lt;p&gt;答：输出为A。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6&lt;/strong&gt;&lt;strong&gt;、介绍&lt;/strong&gt;&lt;strong&gt;JAVA&lt;/strong&gt; &lt;strong&gt;中的&lt;/strong&gt;&lt;strong&gt;Collection FrameWork(&lt;/strong&gt;&lt;strong&gt;及如何写自己的数据结构&lt;/strong&gt;&lt;strong&gt;)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答：Collection FrameWork 如下：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Collection&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;├List元素可以重复，有序(存入顺序和取出顺序一致)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;│├LinkedList底层数据结构是链表，查询慢，增删快，线程不安全效率高。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;│├ArrayList底层数据结构是数组，查询快，增删慢，线程不安全效率高。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;│└Vector底层数据结构是数组，查询快，增删慢，线程安全效率低。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;│ └Stack&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;└Set元素无序，不可以重复。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   ├HashSet线程不安全，存取速度快。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; └TreeSet线程不安全，可以对Set集合中的元素进行排序。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Map&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;├Hashtable线程安全，速度快。底层是哈希表数据结构。是&lt;strong&gt;同步&lt;/strong&gt;的。不允许null作为键，null作为值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;├HashMap线程不安全，速度慢。底层也是哈希表数据结构。是&lt;strong&gt;不同步&lt;/strong&gt;的。允许null作为键，null作为值。替代了Hashtable.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;└WeakHashMap可以用来对Map集合中的&lt;strong&gt;键&lt;/strong&gt;进行排序。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Collection 是最基本的集合接口，一个Collection 代表一组Object，即Collection 的元素（Elements）； Map 提供key 到value 的映射。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Collection &lt;/strong&gt;&lt;strong&gt;和 Collections&lt;/strong&gt;&lt;strong&gt;的区别&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Collection&lt;/strong&gt;是集合类的上级接口，子接口主要有Set 和List、Map。 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Collections&lt;/strong&gt;是针对集合类的一个帮助类，提供了操作集合的工具方法：一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;7&lt;/strong&gt;&lt;strong&gt;、你所知道的集合类都有哪些？主要方法有哪些？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答：最常用的集合类是List 和Map。List 的具体实现包括ArrayList 和Vector，它们是可变大小的列表，比较适合构建、存储和操作任何类型对象的元素列表。List 适用于按数值索引访问元素的情形。Map 提供了一个更通用的元素存储方法。Map 集合类用于存储元素对（称作“键”和“值”），其中每个键映射到一个值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;8&lt;/strong&gt;&lt;strong&gt;、说出&lt;/strong&gt;&lt;strong&gt;ArrayList,Vector, LinkedList&lt;/strong&gt; &lt;strong&gt;的存储性能和特性？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答：ArrayList 和Vector 都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector 由于使用了synchronized 方法（线程安全），通常性能上较ArrayList 差，而LinkedList 使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;9&lt;/strong&gt;&lt;strong&gt;、&lt;/strong&gt;&lt;strong&gt;Collection&lt;/strong&gt; &lt;strong&gt;和&lt;/strong&gt;&lt;strong&gt;Collections&lt;/strong&gt; &lt;strong&gt;的区别？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答：Collection 是java.util 下的接口，它是各种集合的父接口，继承于它的接口主要有Set 和List；Collections 是个java.util 下的类，是针对集合的帮助类，提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;10&lt;/strong&gt;&lt;strong&gt;、&lt;/strong&gt;&lt;strong&gt;HashMap&lt;/strong&gt; &lt;strong&gt;和&lt;/strong&gt;&lt;strong&gt;Hashtable&lt;/strong&gt; &lt;strong&gt;的区别&lt;/strong&gt;&lt;strong&gt;?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答：二者都实现了Map 接口，是将惟一键映射到特定的值上；主要区别在于：&lt;/p&gt;
&lt;p&gt;1)HashMap 没有排序，允许一个null 键和多个null 值,而Hashtable 不允许；&lt;/p&gt;
&lt;p&gt;2)HashMap 把Hashtable 的contains 方法去掉了，改成containsvalue 和containsKey,因为contains 方法容易让人引起误解；&lt;/p&gt;
&lt;p&gt;3)Hashtable 继承自Dictionary 类，HashMap 是Java1.2 引进的Map 接口的实现；&lt;/p&gt;
&lt;p&gt;4)Hashtable 的方法是Synchronize 的，而HashMap 不是，在多个线程访问Hashtable 时，不需要自己为它的方法实现同步，而HashMap 就必须为之提供外同步。Hashtable 和HashMap 采用的hash/rehash 算法大致一样，所以性能不会有很大的差异。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;11&lt;/strong&gt;&lt;strong&gt;、&lt;/strong&gt;&lt;strong&gt;Arraylist&lt;/strong&gt; &lt;strong&gt;与&lt;/strong&gt;&lt;strong&gt;Vector&lt;/strong&gt; &lt;strong&gt;区别？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答：就ArrayList 与Vector 主要从二方面来说：&lt;/p&gt;
&lt;p&gt;1）同步性：Vector 是线程安全的（同步），而ArrayList 是线程序不安全的；&lt;/p&gt;
&lt;p&gt;2）数据增长：当需要增长时,Vector 默认增长一倍，而ArrayList 却是一半。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;12&lt;/strong&gt;&lt;strong&gt;、&lt;/strong&gt;&lt;strong&gt;List&lt;/strong&gt;&lt;strong&gt;、&lt;/strong&gt;&lt;strong&gt;Map&lt;/strong&gt;&lt;strong&gt;、&lt;/strong&gt;&lt;strong&gt;Set&lt;/strong&gt; &lt;strong&gt;三个接口，存取元素时，各有什么特点？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答：List 以特定次序来持有元素，可有重复元素。Set 无法拥有重复元素,内部排序。Map 保存key-value 值，value 可多值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;13&lt;/strong&gt;&lt;strong&gt;、&lt;/strong&gt;&lt;strong&gt;Set&lt;/strong&gt; &lt;strong&gt;里的元素是不能重复的，那么用什么方法来区分重复与否呢&lt;/strong&gt;&lt;strong&gt;?&lt;/strong&gt; &lt;strong&gt;是用&lt;/strong&gt;&lt;strong&gt;==&lt;/strong&gt;&lt;strong&gt;还是&lt;/strong&gt;&lt;strong&gt;equals()?&lt;/strong&gt; &lt;strong&gt;它们有何区别&lt;/strong&gt;&lt;strong&gt;?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答：Set 里的元素是不能重复的，用equals ()方法来区分重复与否。覆盖equals()方法用来判断对象的内容是否相同，而”==”判断地址是否相等,用来决定引用值是否指向同一对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;14&lt;/strong&gt;&lt;strong&gt;、用程序给出随便大小的&lt;/strong&gt;&lt;strong&gt;10&lt;/strong&gt; &lt;strong&gt;个数，序号为&lt;/strong&gt;&lt;strong&gt;1-10&lt;/strong&gt;&lt;strong&gt;，按从小到大顺序输出，并输出相应的序号。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答：代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.ArrayList;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Collections;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Iterator;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Random;

 

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RandomSort {

      &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; printRandomBySort() {

             Random random &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Random(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建随机数生成器&lt;/span&gt;
&lt;span&gt;
             List&lt;/span&gt;&amp;lt;Integer&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Integer&amp;gt;&lt;span&gt;();

             &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 生成10 个随机数，并放在集合list 中&lt;/span&gt;

             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 10; i++&lt;span&gt;) {

                    list.add(random.nextInt(&lt;/span&gt;1000&lt;span&gt;));

             }

             Collections.sort(list); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对集合中的元素进行排序

             &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第一种输出方法&lt;/span&gt;
&lt;span&gt;
             Iterator&lt;/span&gt;&amp;lt;Integer&amp;gt; it =&lt;span&gt; list.iterator();

             &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; count = 0&lt;span&gt;;

             &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (it.hasNext()) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 顺序输出排序后集合中的元素&lt;/span&gt;
&lt;span&gt;
                    System.out.println(&lt;/span&gt;++count + &quot;: &quot; +&lt;span&gt; it.next());

             }

             &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第二种输出方法&lt;/span&gt;

             &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Integer integer : list) {

                    System.out.println(integer);

             }

      }

 

      &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {

             printRandomBySort();

      }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;15&lt;/strong&gt;&lt;strong&gt;、用&lt;/strong&gt;&lt;strong&gt;JAVA&lt;/strong&gt; &lt;strong&gt;实现一种排序，&lt;/strong&gt;&lt;strong&gt;JAVA&lt;/strong&gt; &lt;strong&gt;类实现序列化的方法？&lt;/strong&gt;&lt;strong&gt;在&lt;/strong&gt;&lt;strong&gt;COLLECTION&lt;/strong&gt; &lt;strong&gt;框架中，实现比较要实现什么样的接口？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答：用选择排序代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ChooseSort {

   &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] array;

   &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; length;

 

   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ChooseSort(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] array) {

      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.array =&lt;span&gt; array;

      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.length =&lt;span&gt; array.length;

   }

 

   &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;

    * 打印数组中的所有元素

    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

   &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; display() {

      &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i : array) {

        System.out.print(i &lt;/span&gt;+ &quot; &quot;&lt;span&gt;);

      }

      System.out.println();

   }

 

   &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;

    * 选择排序算法

    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

   &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; chooseSort() {

      &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; length - 1; i++) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 做第i趟排序&lt;/span&gt;

        &lt;span&gt;int&lt;/span&gt; minIndex =&lt;span&gt; i;

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = minIndex + 1; j &amp;lt; length; j++) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 选最小的记录&lt;/span&gt;

           &lt;span&gt;if&lt;/span&gt; (array[minIndex]&amp;gt;&lt;span&gt;array[j]) {

              minIndex &lt;/span&gt;= j;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 记下目前找到的最小值所在的位置&lt;/span&gt;
&lt;span&gt;
           }

        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在内层循环结束，也就是找到本轮循环的最小的数以后，再进行交换&lt;/span&gt;

        &lt;span&gt;if&lt;/span&gt; (i != minIndex) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 交换a[i]和a[minIndex]&lt;/span&gt;

           &lt;span&gt;int&lt;/span&gt; temp =&lt;span&gt; array[i];

           array[i] &lt;/span&gt;=&lt;span&gt; array[minIndex];

           array[minIndex] &lt;/span&gt;=&lt;span&gt; temp;

        }

      }

   }

 

   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {

      &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;[] array = { 100, 45, 36, 21, 17, 13, 7&lt;span&gt; };

      ChooseSort cs &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ChooseSort(array);

      System.out.println(&lt;/span&gt;&quot;排序前的数据为：&quot;&lt;span&gt;);

      cs.display();

      cs.chooseSort();

      System.out.println(&lt;/span&gt;&quot;排序后的数据为：&quot;&lt;span&gt;);

      cs.display();

   }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;JAVA 类实现序例化的方法是实现java.io.Serializable 接口；Collection 框架中实现比较要实现Comparable 接口和Comparator 接口。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;16&lt;/strong&gt;&lt;strong&gt;、&lt;/strong&gt;&lt;strong&gt;sleep()&lt;/strong&gt; &lt;strong&gt;和&lt;/strong&gt;&lt;strong&gt;wait()&lt;/strong&gt; &lt;strong&gt;有什么区别&lt;/strong&gt;&lt;strong&gt;?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答：sleep 是线程类（Thread）的方法，使此线程暂停执行并指定时间，把执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复。调用sleep 不会释放对象锁。wait 是Object 类的方法，对对象调用wait 方法导致本线程放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象发出notify 方法（或notifyAll）后本线程才进入对象锁定池准备，获得对象锁进入运行状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;17&lt;/strong&gt;&lt;strong&gt;、当一个线程进入一个对象的一个&lt;/strong&gt;&lt;strong&gt;synchronized&lt;/strong&gt; &lt;strong&gt;方法后，其它线程是否可进入此对象的其它方法&lt;/strong&gt;&lt;strong&gt;?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答：其它线程只能访问该对象的其它非同步方法，同步方法则不能进入。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;18&lt;/strong&gt;&lt;strong&gt;、请说出你所知道的线程同步的方法。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答：wait():使一个线程处于等待状态，并且释放所持有的对象的lock；sleep():使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉InterruptedException 异常；notify():唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM 确定唤醒哪个线程，而且不是按优先级；&lt;/p&gt;
&lt;p&gt;notityAll():唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们互相竞争。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;19&lt;/strong&gt;&lt;strong&gt;、多线程有几种实现方法&lt;/strong&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;strong&gt;都是什么&lt;/strong&gt;&lt;strong&gt;?&lt;/strong&gt;&lt;strong&gt;同步有几种实现方法&lt;/strong&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;strong&gt;都是什么&lt;/strong&gt;&lt;strong&gt;?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答：多线程有两种实现方法，分别是继承Thread 类与实现Runnable 接口,同步的实现方面有两种，分别是synchronized,wait 与notify。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;20&lt;/strong&gt;&lt;strong&gt;、同步和异步有何异同，在什么情况下使用他们？举例说明。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答：如果数据将在线程间共享。例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行同步存取。当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;21&lt;/strong&gt;&lt;strong&gt;、启动一个线程是用&lt;/strong&gt;&lt;strong&gt;run()&lt;/strong&gt;&lt;strong&gt;还是&lt;/strong&gt;&lt;strong&gt;start()?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答：启动一个线程是调用start()方法，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由JVM 调度并执行。这并不意味着线程就会立即运行。当cpu分配给它时间时，才开始执行run()方法(如果有的话)。start()是方法,它调用run()方法.而run()方法是你必须重写的. run()方法中包含的是线程的主体。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;22&lt;/strong&gt;&lt;strong&gt;、线程的基本概念、线程的基本状态以及状态之间的关系？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答：线程指在程序执行过程中，能够执行程序代码的一个执行单位，每个程序至少都有一个线程，也就是程序本身；Java 中的线程有四种状态分别是：运行、就绪、挂起、结束。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;23&lt;/strong&gt;&lt;strong&gt;、简述&lt;/strong&gt;&lt;strong&gt;synchronized&lt;/strong&gt; &lt;strong&gt;和&lt;/strong&gt;&lt;strong&gt;java.util.concurrent.locks.Lock&lt;/strong&gt; &lt;strong&gt;的异同？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答：相同点：Lock 能完成synchronized 所实现的所有功能；&lt;/p&gt;
&lt;p&gt;不同点：Lock 有比synchronized 更精确的线程语义和更好的性能。synchronized 会自动释放锁，而Lock 一定要求程序员手工释放，并且必须在finally中释放。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;24&lt;/strong&gt;&lt;strong&gt;、&lt;/strong&gt;&lt;strong&gt;java&lt;/strong&gt; &lt;strong&gt;中有几种方法可以实现一个线程？用什么关键字修饰同步方法&lt;/strong&gt;&lt;strong&gt;?stop()&lt;/strong&gt;&lt;strong&gt;和&lt;/strong&gt;&lt;strong&gt;suspend()&lt;/strong&gt;&lt;strong&gt;方法为何不推荐使用？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答：有两种实现方法，分别是继承Thread 类与实现Runnable 接口；用synchronized 关键字修饰同步方法；反对使用stop()，是因为它不安全。它会解除由线程获取的所有锁定，而且如果对象处于一种不连贯状态，那么其他线程能在那种状态下检查和修改它们。结果很难检查出真正的问题所在；suspend()方法容易发生死锁。调用suspend()的时候，目标线程会停下来，但却仍然持有在这之前获得的锁定。此时，其他任何线程都不能访问锁定的资源，除非被“挂起”的线程恢复运行。对任何线程来说，如果它们想恢复目标线程，同时又试图使用任何一个锁定的资源，就会造成死锁。故不应该使用suspend()，而应在自己的Thread 类中置入一个标志，指出线程应该活动还是挂起。若标志指出线程应该挂起，便用wait()命其进入等待状态。若标志指出线程应当恢复，则用一个notify()重新启动线程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;25&lt;/strong&gt;&lt;strong&gt;、设计&lt;/strong&gt;&lt;strong&gt;4&lt;/strong&gt; &lt;strong&gt;个线程，其中两个线程每次对&lt;/strong&gt;&lt;strong&gt;j&lt;/strong&gt; &lt;strong&gt;增加&lt;/strong&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;strong&gt;，另两个线程对&lt;/strong&gt;&lt;strong&gt;j&lt;/strong&gt; &lt;strong&gt;每次减少&lt;/strong&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;strong&gt;；写出程序。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答：以下程序使用内部类实现线程，对j 增减的时候没有考虑顺序问题：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestThread {

   &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; j;

 

   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; TestThread(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; j) {

      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.j =&lt;span&gt; j;

   }

 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;增加j&lt;/span&gt;
   &lt;span&gt;private&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; inc() {

      j&lt;/span&gt;++&lt;span&gt;;

      System.out.println(j &lt;/span&gt;+ &quot;--Inc--&quot; +&lt;span&gt; Thread.currentThread().getName());

   }

 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;减少j&lt;/span&gt;

   &lt;span&gt;private&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; dec() {

      j&lt;/span&gt;--&lt;span&gt;;

      System.out.println(j &lt;/span&gt;+ &quot;--Dec--&quot; +&lt;span&gt; Thread.currentThread().getName());

   }

 

   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {

      &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Dec().start();

      &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Inc()).start();

      &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Dec().start();

      &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Inc()).start();

   }

 

   &lt;/span&gt;&lt;span&gt;class&lt;/span&gt; Dec &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread {

      &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 100; i++&lt;span&gt;) {

           dec();

        }

      }

   }

 

   &lt;/span&gt;&lt;span&gt;class&lt;/span&gt; Inc &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable {

      &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 100; i++&lt;span&gt;) {

 

           inc();

        }

      }

   }

 

   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {

      &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; TestThread(5&lt;span&gt;).run();

   }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;26&lt;/strong&gt;&lt;strong&gt;、什么是&lt;/strong&gt;&lt;strong&gt;java&lt;/strong&gt; &lt;strong&gt;序列化，如何实现&lt;/strong&gt;&lt;strong&gt;java&lt;/strong&gt; &lt;strong&gt;序列化？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答：序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决在对对象流进行读写操作时所引发的问题；序列化的实现：将需要被序列化的类实现Serializable 接口，该接口没有需实现的方法，implements Serializable 只是为了标注该对象是可被序列化的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;27&lt;/strong&gt;&lt;strong&gt;、&lt;/strong&gt;&lt;strong&gt;java&lt;/strong&gt; &lt;strong&gt;中有几种类型的流？&lt;/strong&gt;&lt;strong&gt;JDK&lt;/strong&gt; &lt;strong&gt;为每种类型的流提供了一些抽象类以供继承，请说出他们分别是哪些类？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答：字节流，字符流。字节流继承于InputStream、OutputStream，字符流继承于Reader、Writer。在java.io 包中还有许多其他的流，主要是为了提高性能和使用方便。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;28&lt;/strong&gt;&lt;strong&gt;、文件和目录（&lt;/strong&gt;&lt;strong&gt;IO&lt;/strong&gt;&lt;strong&gt;）操作：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1)如何列出某个目录下的所有文件？&lt;/p&gt;
&lt;p&gt;2)如何列出某个目录下的所有子目录？&lt;/p&gt;
&lt;p&gt;3)如何判断一个文件或目录是否存在？&lt;/p&gt;
&lt;p&gt;4)如何读写文件？&lt;/p&gt;
&lt;p&gt;答：1)示例代码如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
File file = &lt;span&gt;new&lt;/span&gt; File(&quot;e:&quot;&lt;span&gt;);

      File[] files &lt;/span&gt;=&lt;span&gt; file.listFiles();

      &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; files.length; i++&lt;span&gt;) {

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (files[i].isFile())

           System.out.println(files[i]);

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2)示例代码如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
File file = &lt;span&gt;new&lt;/span&gt; File(&quot;e:\\&quot;&lt;span&gt;);

      File[] files &lt;/span&gt;=&lt;span&gt; file.listFiles();

      &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; files.length; i++&lt;span&gt;) {

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (files[i].isDirectory())

           System.out.println(files[i]);

  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;3)创建File 对象,调用其exsit()方法即可返回是否存在,如:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
System.out.println(&lt;span&gt;new&lt;/span&gt; File(&quot;d:\\t.txt&quot;).exists());
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;4)示例代码如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {

   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {

      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 读文件:&lt;/span&gt;
&lt;span&gt;
      FileInputStream fin &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; FileInputStream(&quot;e:\\tt.txt&quot;&lt;span&gt;);

      &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] bs = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[100&lt;span&gt;];

      &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {

        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; len =&lt;span&gt; fin.read(bs);

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (len &amp;lt;= 0&lt;span&gt;)

           &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

        System.out.print(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; String(bs, 0&lt;span&gt;, len));

      }

      fin.close();

      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 写文件:&lt;/span&gt;
&lt;span&gt;
      FileWriter fw &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; FileWriter(&quot;e:\\test.txt&quot;&lt;span&gt;);

      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;System.getProperty(&quot;line.separator&quot;)相当于&quot;/n&quot;\n’ 这样写的话，剔除了平台无关性&lt;/span&gt;
&lt;span&gt;
      fw.write(&lt;/span&gt;&quot;hello world!&quot; + System.getProperty(&quot;line.separator&quot;&lt;span&gt;));

      fw.write(&lt;/span&gt;&quot;你好！郑州！&quot;&lt;span&gt;);

      fw.close();

 

   }

 

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;29&lt;/strong&gt;&lt;strong&gt;、写一个方法&lt;/strong&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;strong&gt;输入一个文件名和一个字符串&lt;/strong&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;strong&gt;统计这个字符串在这个文件中出现的次数。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答：代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; countWords(String file, String find) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {

      &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; count = 0&lt;span&gt;;

      Reader in &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileReader(file);

      &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; c;

      &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; ((c = in.read()) != -1&lt;span&gt;) {

        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (c == find.charAt(0&lt;span&gt;)) {

           &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 1; i &amp;lt; find.length(); i++&lt;span&gt;) {

              c &lt;/span&gt;=&lt;span&gt; in.read();

              &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (c !=&lt;span&gt; find.charAt(i))

                 &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

              &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i == find.length() - 1&lt;span&gt;)

                 count&lt;/span&gt;++&lt;span&gt;;

           }

        }

      }

      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; count;

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;30&lt;/strong&gt;&lt;strong&gt;、&lt;/strong&gt;&lt;strong&gt;Java&lt;/strong&gt; &lt;strong&gt;的通信编程，编程题&lt;/strong&gt;&lt;strong&gt;(&lt;/strong&gt;&lt;strong&gt;或问答&lt;/strong&gt;&lt;strong&gt;)&lt;/strong&gt;&lt;strong&gt;，用&lt;/strong&gt;&lt;strong&gt;JAVA SOCKET&lt;/strong&gt; &lt;strong&gt;编程，读服务器几个字符，再写入本地显示？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答：Server 端程序:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt; java.net.*&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; java.io.*&lt;span&gt;;

 

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Server {

   &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; ServerSocket ss;

   &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Socket socket;

   &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; BufferedReader in;

   &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; PrintWriter out;

 

   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Server() {

      &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建 ServerSocket 对象（并绑定端口）&lt;/span&gt;
&lt;span&gt;
        ss &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ServerSocket(10000&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {

           &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用 accept 方法，等待来自客户端的连接&lt;/span&gt;
&lt;span&gt;
           socket &lt;/span&gt;=&lt;span&gt; ss.accept();

           String RemoteIP &lt;/span&gt;=&lt;span&gt; socket.getInetAddress().getHostAddress();

           String RemotePort &lt;/span&gt;= &quot;:&quot; +&lt;span&gt; socket.getLocalPort();

           System.out.println(&lt;/span&gt;&quot;A client come in!IP:&quot; + RemoteIP +&lt;span&gt; RemotePort);

           &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用 getXXXStream 方法，进行 I/O操作&lt;/span&gt;
&lt;span&gt;
           in &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; BufferedReader(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; InputStreamReader(socket.getInputStream()));

           String line &lt;/span&gt;=&lt;span&gt; in.readLine();

           System.out.println(&lt;/span&gt;&quot;Cleint send is :&quot; +&lt;span&gt; line);

           out &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; PrintWriter(socket.getOutputStream(), &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);

           out.println(&lt;/span&gt;&quot;Your Message Received!&quot;&lt;span&gt;);

           out.close();

           in.close();

           &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭 Socket&lt;/span&gt;
&lt;span&gt;
           socket.close();

        }

      } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {

        out.println(&lt;/span&gt;&quot;wrong&quot;&lt;span&gt;);

      }

   }

 

   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {

      &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Server();

   }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Client 端程序:&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt; java.io.*&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; java.net.*&lt;span&gt;;

 

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Client {

   Socket socket;

   BufferedReader in;

   PrintWriter out;

 

   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Client() {

      &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {

        System.out.println(&lt;/span&gt;&quot;Try to Connect to 127.0.0.1:10000&quot;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.创建 Socket 对象，并连接服务器 （ip字符串,端口号）&lt;/span&gt;
&lt;span&gt;
        socket &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Socket(&quot;127.0.0.1&quot;, 10000&lt;span&gt;);

        System.out.println(&lt;/span&gt;&quot;The Server Connected!&quot;&lt;span&gt;);

        System.out.println(&lt;/span&gt;&quot;Please enter some Character:&quot;&lt;span&gt;);

        BufferedReader line &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; BufferedReader(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; InputStreamReader(System.in));

        out &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; PrintWriter(socket.getOutputStream(), &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);

        out.println(line.readLine());

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.调用 getXXXStream 方法，进行 I/O操作&lt;/span&gt;
&lt;span&gt;
        in &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; BufferedReader(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; InputStreamReader(socket.getInputStream()));

        System.out.println(in.readLine());

        out.close();

        in.close();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3、关闭 Socket&lt;/span&gt;
&lt;span&gt;
        socket.close();

      } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {

        out.println(&lt;/span&gt;&quot;Wrong&quot;&lt;span&gt;);

      }

   }

 

   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {

      &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Client();

   }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Fri, 17 May 2019 15:05:00 +0000</pubDate>
<dc:creator>AlbertYang666</dc:creator>
<og:description>1、JAVA 语言如何进行异常处理，关键字：throws,throw,try,catch,finally分别代表什么意义？在try 块中可以抛出异常吗？ 答：Java 通过面向对象的方法进行异常处理，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yangxianyang/p/10884192.html</dc:identifier>
</item>
<item>
<title>Python基础（四）——迭代器/对象，生成器 - 孔胡子</title>
<link>http://www.cnblogs.com/KongHuZi/p/10878145.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/KongHuZi/p/10878145.html</guid>
<description>&lt;p&gt;　　首先&lt;span&gt;&lt;em&gt;&lt;strong&gt;&lt;a href=&quot;https://www.liaoxuefeng.com/wiki/1016959663602400/1017318207388128&quot; target=&quot;_blank&quot;&gt;廖雪峰网站&lt;/a&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;写的内容就我目前初步学习来说，已经相当详实，知识点平铺直叙让人易接受，所以以下内容均作为一种摘&lt;span&gt;&lt;em&gt;&lt;strong&gt;记记录以及补充&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;。&lt;/p&gt;

&lt;p&gt;　　主要目的是创建 list 。多看例子就能清楚：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;68&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;(list(range(1,10,2)))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;[1, 3, 5, 7, 9].生成1~&lt;span&gt;9（左闭右开）&lt;/span&gt;,相隔为2&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;([t * t &lt;span&gt;for&lt;/span&gt; t &lt;span&gt;in&lt;/span&gt; range(1,10,3) &lt;span&gt;if&lt;/span&gt; t % 2 == 0]) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;[16].生成1~9相隔4,且是偶数的平方和&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;([m + n &lt;span&gt;for&lt;/span&gt; m &lt;span&gt;in&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; n &lt;span&gt;in&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;456&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;['14', '15', '16', '24', '25', '26', '34', '35', '36'].全排列&lt;/span&gt;
&lt;span&gt;
d &lt;/span&gt;= {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;x&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;y&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;z&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; k, v &lt;span&gt;in&lt;/span&gt;&lt;span&gt; d.items():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(k, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, v)

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;([m + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + n &lt;span&gt;for&lt;/span&gt; m,n &lt;span&gt;in&lt;/span&gt; d.items()])  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;['x=A', 'y=B', 'z=C']&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;筛选单词，并全变小写&lt;/span&gt;
L = [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Hello&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;World&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 18, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Apple&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, None]
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;([t.lower() &lt;span&gt;for&lt;/span&gt; t &lt;span&gt;in&lt;/span&gt; L &lt;span&gt;if&lt;/span&gt; isinstance(t, str)])  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;['hello', 'world', 'apple']&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;　　iterable 是&lt;span&gt;可迭代对象&lt;/span&gt;，iterator 是&lt;span&gt;迭代器&lt;/span&gt;。两者都是 collection.abc 中得抽象类。iterator 继承自 iterable 。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;　　iterable 有常见得 list，dict，str，tuple 等或者自定义的类（该类必须实现抽象方法 _iter()_）。当一个可迭代对象作为参数调用自身的 iter() 方法时，会返回一个迭代器。&lt;span&gt;迭代器拥有 _next()_ 抽象方法，可迭代对象没有&lt;/span&gt;，通过该方法就可以逐个得到 “序列” 中的各个值，不断调用 _next()_ 方法，最后会引起 StopIteration 异常报错，代表迭代结束了。同时&lt;span&gt;迭代器还拥有 _iter()_ 方法&lt;/span&gt;，所以迭代器也是个可迭代对象。即&lt;span&gt;所有的迭代器都是可迭代对象，但是&lt;/span&gt;可迭代对象并不都是迭代器，基本判断方法是是否调用 next() 方法，list，dect，str，tuple 都并不行，即不是迭代器。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　   我们可以通过 isinstance 来判断：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; collections.abc &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Iterable,Iterator
t &lt;/span&gt;= [1,2,3&lt;span&gt;]   #列表
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(isinstance(t, Iterable)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(isinstance(t, Iterator)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;         我们常用的 for...in [ ] 。就是利用了迭代器&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; collections.abc &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Iterable,Iterator
L &lt;/span&gt;= [1,2,3&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(isinstance(L, Iterator)) #Flase
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; t &lt;span&gt;in&lt;/span&gt;&lt;span&gt; L:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(t, end=&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;) #1  2  3
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;          这是我们常写的代码，输出123。既然 L 不是迭代器为啥也能迭代输出呢。这就是在使用 for...in 的时候，&lt;span&gt;Python 解释器主动将可迭代对象调用了 iter() 返回迭代器&lt;/span&gt;，即每次都是通过迭代器的 next() 方法进行输出。那么哪个异常 StopIteration 呢？异常应该被 for...in 内部处理了，并不显式的抛出。&lt;/p&gt;
&lt;p&gt;　　   我们换一种更明显的写法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; collections.abc &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Iterable,Iterator
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; L = [1,2,3&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(isinstance(L, Iterator))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; T = L.&lt;span&gt;__iter__&lt;/span&gt;&lt;span&gt;()
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(isinstance(T, Iterator))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;true。现在T就是迭代器了，拥有了next()方法。&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(T.&lt;span&gt;__next__&lt;/span&gt;())  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(T.&lt;span&gt;__next__&lt;/span&gt;())  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;
&lt;span&gt;8&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(T.&lt;span&gt;__next__&lt;/span&gt;())  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;
&lt;span&gt;9&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(T.&lt;span&gt;__next__&lt;/span&gt;())  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; StopIteration&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;         结果和我们想的是一样的。或者再这样写&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; collections.abc &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Iterable,Iterator
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; L = [1,2,3&lt;span&gt;]
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(isinstance(L, Iterator))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; T =&lt;span&gt; iter(L)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(next(T), end=&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;except&lt;/span&gt;&lt;span&gt; StopIteration:
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;结束&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;break&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　（点击图片查看原文）&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://nvie.com/posts/iterators-vs-generators/&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1144707/201905/1144707-20190517160723155-1980435125.png&quot; alt=&quot;&quot; width=&quot;772&quot; height=&quot;258&quot;/&gt;&lt;/a&gt;&lt;/p&gt;


&lt;ul&gt;&lt;li&gt;生成器是返回一个 generator iterator 的函数。但是这个函数中包含 yield 表达式，除此之外别无它异，用来产生一系列供 for 循环使用的值或者通过 next() 逐一获取。所以生成器一般也称为生成器函数。&lt;/li&gt;
&lt;li&gt;生成迭代器 generator iterator 是由生成器 generator 创建的对象。每遇到 yield 会暂停（相当于return），&lt;span&gt;并记住当前位置&lt;/span&gt;，之后在继续在记住的位置继续向下运行。而不同于普通函数每次都由上往下运行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;&lt;em&gt;第一种创建生成器的方法&lt;/em&gt;&lt;/span&gt;&lt;/strong&gt;：将列表生成式的 [ ] 换成 ( )&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
L = ( t * t &lt;span&gt;for&lt;/span&gt; t &lt;span&gt;in&lt;/span&gt; range(1,10&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(L)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;&amp;lt;generator object &amp;lt;genexpr&amp;gt; at 0x0000028D2F68B840&amp;gt;&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(next(L)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(next(L)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; L: &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 迭代输出&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(i)
&lt;/pre&gt;&lt;/div&gt;



&lt;ul&gt;&lt;li&gt;&lt;span&gt;当一个生成函数被调用时，返回一个迭代器，成为生成器&lt;/span&gt;。这个&lt;span&gt;生成器来控制&lt;/span&gt;生成函数的执行，遇到 yield 就挂起，下次继续从 挂起处执行。前面说过迭代器有 next() 方法，所以这里的yield 就是干了 next() 方法的事。一样不断next 直到无数据 StopIteration。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;&lt;em&gt;第二种是通过定义函数&lt;/em&gt;&lt;/span&gt;&lt;/strong&gt;：&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; test():
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;yield&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;yield&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;yield&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; t = test()  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; t 是生成器，生成器来控制函数&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(t) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; &amp;lt;generator object test at 0x0000021EF6C5B840&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; next(t) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; next(t) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; next(t) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; next(t) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; StopIteration&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　可以通过 11~14 行看出，yield 起的作用就是挂起。第一次调用next() 方法，函数执行到第三句就停了，第二次调用 next() 执行到第五句。yield 就像是 OS 中的中断语句，保护现场--恢复现场。&lt;/p&gt;
&lt;p&gt;　　再来看一个斐波那契例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;斐波那契数列&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;常规写法一：&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; def fib(max):&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;     n, a, b = 0, 0, 1&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;     while n &amp;lt; max:&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;         print(b)&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;         a, b = b, a + b&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;         n = n + 1&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;     return 'done'&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;#
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; fib(6)&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;生成器写法二：&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; collections.abc &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Iterator,Iterable
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; fib(max):
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     n, a, b = 0, 0, 1
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt; n &amp;lt;&lt;span&gt; max:
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;yield&lt;/span&gt; b     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; yield 类似于return 将 b 返回&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;         a, b = b, a +&lt;span&gt; b
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         n = n + 1
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;done&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt; f = fib(6&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(f)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;&amp;lt;generator object fib at 0x00000124DDD8B840&amp;gt;&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(isinstance(f, Iterator)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;True。生成函数返回迭代器&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; n &lt;span&gt;in&lt;/span&gt;&lt;span&gt; f:
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(n, end=&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;1 1 2 3 5 8&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　通过观察24，25行可以知道，调用了 fib() 之后，函数并没有执行到尾（否则返回 str = 'done'），正如上文所说，返回的是一个 生成器，也就是调用生成函数（含 yield语句的）返回生成器，然后我们通过生成器来控制函数的执行。只有执行27行的 for...in 的时候，才会去执行15~21这段函数代码。&lt;/p&gt;
&lt;p&gt;　　具体执行过程：第一次从16至18行停止，因为yield的存在，执行到18行就停了，然后返回一个值 b 给 for 循环，然后执行28行输出 b，然后next()迭代器继续从上次停止的地方的下一行19行继续执行(迭代器next()只要不是StopIteration 或者生成函数结束了，for 循环就得以继续)，然后在while循环内，再次执行到18行停止，返回 b 给 for。继续重复，直至跳出while循环，fib() 这段生成器函数结束了，for...in 也就结束了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; # &lt;span&gt;生成器写法三
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; collections.abc &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Iterator,Iterable
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; fib(max):
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     n, a, b = 0, 0, 1
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt; n &amp;lt;&lt;span&gt; max:
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;yield&lt;/span&gt; b     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; yield 类似于return 将 b 返回&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         a, b = b, a +&lt;span&gt; b
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         n = n + 1
&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; f = fib(3&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(f)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;&amp;lt;generator object &amp;gt;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(isinstance(f, Iterator)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;True。生成函数返回迭代器&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(next(f))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(next(f))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(next(f))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(next(f))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; StopIteration&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;　　stackoverflow 上还有关于生成 yield 配合使用 send()的方法。查阅官网，send(value) 函数意思：恢复执行，并向生成器发送一个值，value 参数将被当作 yield 表达式结果。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; test():
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         x = &lt;span&gt;yield&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;         &lt;span&gt;yield&lt;/span&gt; x * 2
&lt;span&gt;5&lt;/span&gt; 
&lt;span&gt;6&lt;/span&gt; g =&lt;span&gt; test()
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(next(g)) # none
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(g.send(12)) #24
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　我们已经知道 yield 可以当作return来理解。&lt;/p&gt;
&lt;p&gt;　　首先第六行创建了 g (生成器)，第七行输出 none，因为执行第七行，也就是去执行test()函数了，函数顺利执行到第三行，3 = yield 明显是我们学的赋值语句，难道是将yield赋值给3？不是的。先解释输出的none，因为没有参数写在yield的右边，即没有参数返回，所以第七行输出 None。同时因为yield存在而停止继续。&lt;/p&gt;
&lt;p&gt;　　而第八行：遇到g.send() 会继续执行上次执行到第三行的地方，&lt;span&gt;这里传入的参数12就是赋值给x的&lt;/span&gt;。所以再往下第四行，yiled看成return 返回12*2，同时test()函数被挂起，返回24给第八行。至此函数结束。&lt;/p&gt;
&lt;p&gt;　　又比如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; test(x):
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         x *= 2
&lt;span&gt;4&lt;/span&gt;         x = &lt;span&gt;yield&lt;/span&gt;&lt;span&gt; x
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; 
&lt;span&gt;6&lt;/span&gt; g = test(3&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(next(g)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;
&lt;span&gt;8&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(g.send(12))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　第四行意思：先看右边yield x 就是返回 x 。再看左边 x = yield 就是赋值给 x 。所以不难理解了。不解释了。 &lt;/p&gt;


&lt;p&gt;&lt;a href=&quot;https://nvie.com/posts/iterators-vs-generators/&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1144707/201905/1144707-20190517203043671-1660204524.png&quot; alt=&quot;&quot; width=&quot;1006&quot; height=&quot;454&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 17 May 2019 12:30:00 +0000</pubDate>
<dc:creator>孔胡子</dc:creator>
<og:description>首先廖雪峰网站写的内容就我目前初步学习来说，已经相当详实，知识点平铺直叙让人易接受，所以以下内容均作为一种摘记记录以及补充。 1. 列表生成器 主要目的是创建 list 。多看例子就能清楚： 2. I</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/KongHuZi/p/10878145.html</dc:identifier>
</item>
<item>
<title>当Python中混进一只薛定谔的猫…… - 豌豆花下猫</title>
<link>http://www.cnblogs.com/pythonista/p/10883351.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pythonista/p/10883351.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/68b02e3bgy1g34jsy035ij21g80yt0va.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本文原创并首发于公众号【&lt;strong&gt;Python猫&lt;/strong&gt;】，未经授权，请勿转载。&lt;br/&gt;原文地址：https://mp.weixin.qq.com/s/-fFVTgWVsydFsNu1nyxUzA&lt;/p&gt;
&lt;p&gt;Python 是一门强大的动态语言，那动态体现在哪里，强大又体现在哪里呢？除了好的方面，Python 的动态性是否还藏着一些使用陷阱呢，有没有办法识别与避免呢？&lt;/p&gt;
&lt;p&gt;沿着它的动态特性话题，猫哥有几篇文章依次探及了：动态修改变量、动态定义函数、动态执行代码等内容，然而，当混合了变量赋值、动态赋值、命名空间、作用域、函数的编译原理等等内容时，问题就可能会变得非常棘手。&lt;/p&gt;
&lt;p&gt;因此，这篇文章将前面一些内容融汇起来，再做一次延展的讨论，希望能够理清一些使用的细节，更深入地探索 Python 语言的奥秘。&lt;/p&gt;
&lt;h2 id=&quot;疑惑重重的例子&quot;&gt;（1）疑惑重重的例子&lt;/h2&gt;
&lt;p&gt;先看看这一个例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 例0
def foo():
    exec('y = 1 + 1')
    z = locals()['y']
    print(z)
    
foo()

# 输出：2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;exec() 函数的代码块中定义了变量 y，这个值可以被随后的 locals() 取到，在赋值后也打印了出来。然而，在这个例子的基础上，只需做出小小的改变，结果就可能大不相同了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 例1
def foo():
    exec('y = 1 + 1')
    y = locals()['y']
    print(y)
    
foo()

# 报错：KeyError: 'y'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;把前例的 z 改为 y ，就报错了。其中，&lt;code&gt;KeyError&lt;/code&gt; 指的是在字典中不存在对应的 key 。为什么会这样呢，新赋值的变量是 y 或者 z，为什么对结果有这么不同的影响？&lt;/p&gt;
&lt;p&gt;试试把 exec 去掉，不报错！&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 例2
def foo():
    y = 1 + 1
    y = locals()['y']
    print(y)

foo()

# 2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;问题：直接对 y 赋值，跟动态地在 exec() 中赋值，会对 locals() 取值产生怎样的影响？&lt;/p&gt;
&lt;p&gt;再试试对例 1 的 locals() 先赋值，还是报错：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 例3
def foo():
    exec('y = 1 + 1')
    boc = locals()
    y = boc['y']
    print(y)
 
foo()

# KeyError: 'y'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;先做一次赋值，难道没有用么？也不是，如果把赋值的顺序调前，就不报错了：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 例4
def foo():
    boc = locals()
    exec('y = 1 + 1')
    y = boc['y']
    print(y)

foo()

# 2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也就是说，locals() 的值并不是固定的，它的值与调用时的上下文相关，调用 locals() 的时机至关重要。&lt;/p&gt;
&lt;p&gt;然而，如果想要验证一下，在函数中增加一个 locals() 的打印，这个动作却会影响到最终的执行结果。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 例5
def foo():
    boc = locals()
    exec('y = 1 + 1')
    print(locals())
    y = boc['y']
    print(y)

foo()

# {'boc': {...}}
# KeyError: 'y'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这到底是怎么回事呢？&lt;/p&gt;
&lt;h2 id=&quot;多元知识的储备&quot;&gt;（2）多元知识的储备&lt;/h2&gt;
&lt;p&gt;以上例子在细微之处有较大的不同，主要由于以下知识点的影响：&lt;/p&gt;
&lt;p&gt;1、变量的声明与赋值&lt;/p&gt;
&lt;p&gt;2、locals() 取值与修改的逻辑&lt;/p&gt;
&lt;p&gt;3、locals() 字典与局部命名空间的关系&lt;/p&gt;
&lt;p&gt;4、函数的编译，抽象语法树的解析&lt;/p&gt;
&lt;p&gt;注意：exec() 函数有两个缺省的参数 globals() 与 locals() （与内置函数同名），起的是限定字符串参数中变量的作用，若添加出来，只会增加以上例子的复杂度，因此，我们都做缺省处理，这里讨论的是 exec() 只有一个参数的情况。&lt;/p&gt;
&lt;p&gt;在某些编程语言中，变量的声明与赋值是可以分开的，例如在声明时写 &lt;code&gt;int a&lt;/code&gt; ，需要赋值时，再写 &lt;code&gt;a = 1&lt;/code&gt; ，当然也可不拆分，则是 &lt;code&gt;int a = 1&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;对应到 Python 中，情况就不同了，这两个动作在书写时是合二为一的。首先它不用指定变量的类型，任何时候都不需要（也不能）在变量前加类型（如 int），其次，声明与赋值过程无法拆分书写，即只能写成 &lt;code&gt;a = 1&lt;/code&gt; 这样。看起来它跟其它语言的赋值写法一样，但实际上，它的效果是 &lt;code&gt;int a = 1&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;这虽然是一种便利，但也隐藏了一个不易察觉的陷阱（划重点）：&lt;strong&gt;当看到 &lt;code&gt;a = 1&lt;/code&gt; 时，你无法确定 a 是初次声明的，还是已被声明过的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;关于 locals() 的创建过程，在《&lt;a href=&quot;https://mp.weixin.qq.com/s/f9BBe2W1X1p7NcHg665I4A&quot;&gt;Python 动态赋值的陷阱&lt;/a&gt;》文中有所分析，locals() 字典是局部命名空间的代理，它会采集局部作用域的变量，代码运行期若动态修改局部变量，只会影响该字典，并不会影响真正的局部作用域的变量。因此，当再次调用 locals() 时，由于重新采集，则动态修改的内容会被丢弃。&lt;/p&gt;
&lt;p&gt;运行期的局部命名空间不可改变，这意味着 exec() 函数中的变量赋值不会对它产生影响，但 locals() 字典是可变的，会受到 exec() 函数的影响。&lt;/p&gt;
&lt;p&gt;而关于函数的编译，我在《&lt;a href=&quot;https://mp.weixin.qq.com/s/EsWmCbH3RtL_QpafyMryOw&quot;&gt;Python与家国天下&lt;/a&gt;》中写到了对 &lt;strong&gt;抽象语法树&lt;/strong&gt; 的分析，Python 在编译时就确定了局部作用域内合法的变量名，在运行时再与内容绑定。作用域内变量的解析跟它的执行顺序无关，更与是否会被执行无关。&lt;/p&gt;
&lt;h2 id=&quot;薛定谔的猫&quot;&gt;（3）薛定谔的猫&lt;/h2&gt;
&lt;p&gt;以上内容是前提，友情提示，如你有理解模糊之处，请先阅读对应的文章。接下来则是基于这些内容而作的分析。&lt;/p&gt;
&lt;p&gt;我不敢保证每个细节都准确无误，但这个分析力求达到深入浅出、面面俱到、逻辑自恰，而且顺便幽默有趣……&lt;/p&gt;
&lt;p&gt;例 0 中，局部作用域内虽然没有 ‘y’，但 exec() 函数动态创建了它，因此动态地写入了 locals() 字典中，所以能查找到而不报错。&lt;/p&gt;
&lt;p&gt;例 1 中，exec() 不影响局部作用域，即此时 y 未在局部作用域内做过声明与赋值，接下来的一句才是&lt;strong&gt;第一次在局部作用域中对 y 作声明与赋值&lt;/strong&gt; ！&lt;/p&gt;
&lt;p&gt;&lt;code&gt;y = locals()['y']&lt;/code&gt; ，等号左侧在做声明，只要等号右侧的结果成立，整个声明与赋值的过程就成立。右侧需在 locals() 字典中查找 y 对应的值。&lt;/p&gt;
&lt;p&gt;在创建 locals() 字典时，由于局部作用域内有变量 y 的声明，因此我们首先在其中采集到了 y，而不必在 exec() 函数的动态结果中查找。这就有了字典的一个 key，接着要匹配这个 key 对应的值，也即 y 所绑定的值。&lt;/p&gt;
&lt;p&gt;但是，刚才说了这是 y 的第一次赋值，并未完成呢，因此 y 并无有效的绑定值。&lt;/p&gt;
&lt;p&gt;矛盾出现了，这里有点绕，我们理一下：左侧的 y 等着完成赋值，因此需要右侧的执行结果；而右侧的字典需要使用到 y 的值，因此就依赖着左侧的 y 完成赋值。两边的操作都未完成，但双方都需要依赖对方先完成，这是个无法破解的死局。&lt;/p&gt;
&lt;p&gt;可以说，y 的值是一团混沌，它必然等于 “locals()['y']” ，然而只有解开这团代码才能确切得到结果——只有打开笼子才知道结果，你是否想到了薛定谔的那只猫呢？&lt;/p&gt;
&lt;p&gt;locals() 字典虽然拿到了 y 的名，却拿不到它的实，空欢喜一场，所以报 KeyError。&lt;/p&gt;
&lt;p&gt;例 3 同理，未完成赋值就使用，所以报错。&lt;/p&gt;
&lt;p&gt;例 2 中，y 在二次赋值的过程时，局部命名空间中已经存在着有效的 y 等于 2，因此 locals() 查找到它而用于赋值，所以不报错。&lt;/p&gt;
&lt;p&gt;至于例 4，它跟例 3 只差了一个执行顺序，为什么不会报错呢？还有更奇怪的，在例 4 上再加一个打印（例5），理应不会影响结果，可事实却是又报错了，为什么？&lt;/p&gt;
&lt;p&gt;例 4 中，&lt;code&gt;boc = locals()&lt;/code&gt; 这句同样存在循环引用的问题，因此执行后的字典中没有 y，接着 exec() 这句动态地修改了 locals()，执行后 boc 的结果是 {'y' : 2}，因此再下一句的 boc['y'] 能查找到结果，而不报错。&lt;/p&gt;
&lt;p&gt;例 4 与例 3 的 ”y = boc['y']“ ，虽然都是第一次在局部作用域中声明与赋值 y，但例 4 的 boc 已被 exec() 修改过，因此它能取到实实在在的值，就不再有循环引用的问题了。&lt;/p&gt;
&lt;p&gt;接着看例 5，第一个 locals() 还是存在循环引用现象，接着 exec() 往字典中写入变量 y，但是，第二个 locals() 又触发了新的创建字典过程，会把 exec() 的执行结果覆盖，因此进入第二轮循环引用，导致报错。&lt;/p&gt;
&lt;p&gt;例 5 与例 4 的不同在于，它是根据局部作用域重新生成的字典，其效果等同于例 3。&lt;/p&gt;
&lt;p&gt;另外，请特别注意打印的结果：&lt;strong&gt;{'boc': {…}}&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;这个结果说明，第二个 locals() 是一个字典，而且它只有唯一的 key 是 ’boc‘，而 ’boc‘ 映射的是第一个 locals() 字典，也即是 {...} 。这个写法表示它内部出现了循环引用，直观地证实了前面的所有分析。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字典内部出现循环引用&lt;/strong&gt; ，这个现象极其罕见！前面虽然做了分析，但看到这里的时候，不知道你是否觉得不可思议？&lt;/p&gt;
&lt;p&gt;之所以第一次的循环引用能被记录下来，原因在于我们没有试图去取出 ’y‘ 的值，而第二个循环引用则由于取值报错而无法记录下来。&lt;/p&gt;
&lt;p&gt;这个例子告诉大家：&lt;strong&gt;薛定谔的猫混入了 Python 的字典中，而且答案是，打开笼子，这只猫就会死亡。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;字典的循环引用现象在几个例子中扮演了极其重要的角色，但是往往被人忽视。之所以难以被人觉察，原因还是前面划重点的内容：&lt;strong&gt;当看到 &lt;code&gt;a = 1&lt;/code&gt; 时，你无法确定 a 是初次声明的，还是已被声明过的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在《&lt;a href=&quot;https://mp.weixin.qq.com/s/EsWmCbH3RtL_QpafyMryOw&quot;&gt;Python与家国天下&lt;/a&gt;》文中，猫哥分析了两类经典的报错：name 'x' is not defined、local variable 'x' referenced before assignment。它们通常也是由于声明与赋值不分，而导致的失察。&lt;/p&gt;
&lt;p&gt;本文中的 KeyError 实际上就是 “local variable 'y' referenced before assignment”，y 已 defined 而未 assigned，导致 reference 时报错。&lt;/p&gt;
&lt;p&gt;已赋值还是未赋值，这是个问题。也是一只猫。&lt;/p&gt;
&lt;p&gt;最后，尽管这只猫在暗中捣了大乱，我们还是要感谢它：感谢它串联了其它知识被我们“一锅端”，感谢它为这篇抽象烧脑的文章挠出了几分活泼生动的趣味……（以及，感谢它带来的标题灵感，不知道有多少人是冲着标题而阅读的？）&lt;/p&gt;
&lt;h3 id=&quot;后记&quot;&gt;后记&lt;/h3&gt;
&lt;p&gt;本文中的几个例子早在 3 月 24 日就想到了，但我没法给自己一套完全满意的解答。在与群内小伙伴们陆续讨论了一整个下午后，我依然不满足，最终打消了写入《&lt;a href=&quot;https://mp.weixin.qq.com/s/6V8z2Gr94PpLbbUUo1K3AQ&quot;&gt;深度辨析 Python 的 eval() 与 exec()&lt;/a&gt;》这篇文章的念头。两个月来，群内偶尔讨论过几次相关的知识点，感谢好几位同学（特别@樱雨楼）的讨论，我终于觉得时机到了（其实是稿荒啦），把沉睡近两个月的草稿翻出来……如今的分析，我自认为是能说得通，而且关键细节无遗漏的，但仍可能有瑕疵，如果你有什么想交流的，欢迎给我留言。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/68b02e3bly1g2aiq1kpa8j21hc0nmgs4.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;公众号【&lt;strong&gt;Python猫&lt;/strong&gt;】， 本号连载优质的系列文章，有喵星哲学猫系列、Python进阶系列、好书推荐系列、技术写作、优质英文推荐与翻译等等，欢迎关注哦。后台回复“&lt;strong&gt;爱学习&lt;/strong&gt;”，免费获得一份学习大礼包。&lt;/p&gt;
</description>
<pubDate>Fri, 17 May 2019 11:49:00 +0000</pubDate>
<dc:creator>豌豆花下猫</dc:creator>
<og:description>本文原创并首发于公众号【 Python猫 】，未经授权，请勿转载。 原文地址：https://mp.weixin.qq.com/s/ fFVTgWVsydFsNu1nyxUzA Python 是一门强</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pythonista/p/10883351.html</dc:identifier>
</item>
<item>
<title>I/O复用 - 一盏淡酒、醉了夕阳</title>
<link>http://www.cnblogs.com/helloworldcode/p/10883130.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/helloworldcode/p/10883130.html</guid>
<description>&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;　　内核（操作系统）一旦发现进程指定的一个或者多个IO条件准备读或者准备写的时候，就会给该进程发一个通知。当服务端要处理多个套接字文件描述符的时候，这个时候可以采用IO复用，操作系统发现哪些套接字文件描述符可读或可写的时候，就会通知相应的进程才去执行对应的read（保证文件描述符对应的地址有可用的数据返回，而不是由于试探性的返回无用的值）或write操作。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;可以举个例子：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;　　例如：现在李老师收取刚刚布置给学生要默写在纸上的古诗的作业。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;　　第一种情况：李老师按照学号的顺序来收取，并且会等待将要收取作业的同学同意提交作业，直到该同学提交作业，才会去下一个学号的同学那里去询问是否提交作业。（循环处理每个socket，不支持高并发，效率低）&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;　　第二种情况：李老师向其他老师请求帮助，拉来了很多老师帮忙收作业，每个老师处理一小部分学生的古诗词作业的提交任务。（相当与创建多个进程或者线程处理socket）&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;　　第三种情况：李老师站在讲台上，根据同学们的反应来做出相应的动作（如果谁的要提交作业，该同学就举手），某些同学举手后，李就会去收取这些同学的作业。（IO复用）&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;系统调用函数实现IO复用&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span&gt;将多个文件描述符集中到一起统一监视。比如对多个套接字进行统一管理与调度 。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;1.select函数&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;　　函数会做的事情包括：&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;*&quot; readability=&quot;0&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;检测是否存在套接字接受数据&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;检测是否存在套接字无阻塞的传输数据&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;哪些套接字发生了异常&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;该函数的调用时的顺序&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;1. 设置文件描述符&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;将需要监视的文件描述符集中到一起(fd_set)，集中的时候要按照监视项来区分（包括接收，传输，异常）。&lt;span&gt;&lt;code&gt;fd_set&lt;/code&gt;&lt;span&gt;结构体如下：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
/* The fd_set member is required to be an array of longs.  */
typedef long int __fd_mask;
/* Number of descriptors that can fit in an `fd_set'.  */
#define __FD_SETSIZE        1024
/* It's easier to assume 8-bit bytes than to get CHAR_BIT.  */
#define __NFDBITS   (8 * (int) sizeof (__fd_mask))
/* fd_set for select and pselect.  */
typedef struct
  {
    __fd_mask fds_bits[__FD_SETSIZE / __NFDBITS];
  } fd_set;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;code&gt;fd_set&lt;/code&gt;&lt;span&gt;结构如下（有三种情况，监听接收作用的fd_set，监听传输作用的fd_set，监听异常作用的fd_set），当对应的区上的位置的值0被置为1，表示该位置对应的文件描述符正在被监视，或可读或可写，亦或者是有异常：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1047362/201905/1047362-20190517185054034-1749463044.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;./img/fd_set_s.jpg&quot;&gt;在&lt;code&gt;fd_set&lt;/code&gt;中注册文件描述符或者更改值的操作都是由相关宏来完成的。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;53&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
/* Access macros for `fd_set'.  */
#define FD_SET(fd, fdsetp)  __FD_SET (fd, fdsetp)  
#define FD_CLR(fd, fdsetp)  __FD_CLR (fd, fdsetp)  
#define FD_ISSET(fd, fdsetp)    __FD_ISSET (fd, fdsetp)
#define FD_ZERO(fdsetp)     __FD_ZERO (fdsetp)  
​
FD_ZERO(fd_set* fdset);           //将fd_set的所有位都初始化为0 
FD_SET(int fd, fd_set* fdset);    //在fd_set中注册文件描述符fd的信息
FD_CLR(int fd, fd_set* fdset);    //从参数fd_set中清除文件描述符fd的信息
FD_ISSET(int fd, fd_set* fdset);  //若参数fd_set所指向的变量包含文件描述符fd的信息，则返回1，否则返回0/* Access macros for `fd_set'.  */
#define FD_SET(fd, fdsetp)  __FD_SET (fd, fdsetp)  
#define FD_CLR(fd, fdsetp)  __FD_CLR (fd, fdsetp)  
#define FD_ISSET(fd, fdsetp)    __FD_ISSET (fd, fdsetp)
#define FD_ZERO(fdsetp)     __FD_ZERO (fdsetp)  
​
FD_ZERO(fd_set* fdset);           //将fd_set的所有位都初始化为0 
FD_SET(int fd, fd_set* fdset);    //在fd_set中注册文件描述符fd的信息
FD_CLR(int fd, fd_set* fdset);    //从参数fd_set中清除文件描述符fd的信息
FD_ISSET(int fd, fd_set* fdset);  //若参数fd_set所指向的变量包含文件描述符fd的信息，则返回1，否则返回0
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.指定监视范围和超时&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;code&gt;　　select&lt;/code&gt;&lt;span&gt;函数的原型如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
/* Check the first NFDS descriptors each in READFDS (if not NULL) for read
   readiness, in WRITEFDS (if not NULL) for write readiness, and in EXCEPTFDS
   (if not NULL) for exceptional conditions.  If TIMEOUT is not NULL, time out
   after waiting the interval specified therein.  Returns the number of ready
   descriptors, or -1 for errors.
​
   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int select (int __nfds, fd_set *__restrict __readfds,
           fd_set *__restrict __writefds,
           fd_set *__restrict __exceptfds,
           struct timeval *__restrict __timeout);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一个参数：监视对象文件描述符的数量&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;第二个参数：传递包含所有关注“是否存在待读取”的文件描述符的fdset。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;第三个参数：传递包含所有关注“是否可传输无阻塞数据”的文件描述符的fdset 。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;第三个参数：传递包含所有关注“是否可发生异常”的文件描述符的fdset 。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;第四个参数：为防止陷入无限阻塞的状态， 传递超时信息。&lt;/span&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;3. 调用select函数&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;　　调用函数返回结果：&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;ol-list&quot; start=&quot;&quot;&gt;&lt;li&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;4. 调用select查看结果&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;code&gt;　　select&lt;/code&gt;&lt;span&gt;函数返回值如果是大于0的整数，表示相应数量的文件描述符发生了变化。如下图示例，&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1047362/201905/1047362-20190517185338260-1803784896.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;./img/fd_set_change.png&quot;&gt;&lt;img src=&quot;file:///home/gqx/github/Socket-Program/concurrence_Server/img/fd_set_change.png?lastModify=1558089890&quot; alt=&quot;&quot; data-local-refresh=&quot;true&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;　　调用函数select函数时，向其传递的fd_set变量将发送变化，所有的1都被为0，但发生变化变化的文件描述符对应的位除外，如图，调用select函数结束后，可知传入的fd_set中只有fd1和fd3是1，即它们对应的文件描述符发生了变化。&lt;/span&gt;&lt;/p&gt;

&lt;h4 class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;进一步理解select函数&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span&gt;理解select模型的关键在于理解fd_set(这里声明的变量名为reads)这个数据结构，现在假设fd_set的大小是1字节，即8个bit（位）。执行过程可以这样表示：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;*&quot; readability=&quot;5.5&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;第一步：FD_ZERO(&amp;amp;reads); 将read指向的fd_set初始化为00000000。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;将对应位设置处于监听状态，如fd=6，FD_SET(fd, &amp;amp;reads);此时fd_set变为00100000。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;如果还有需要监听的文件描述符，fd1=1，fd2=2，通过FD_SET后结果变为00100011。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;4&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;调用select(7,reads,0,0,timeval)阻塞等待。默认是从位置0开始，所以要将最大的fd_max+1。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;如果此时fd=2对应的文件描述服发生了可读事件，select调用结束，此时fd_set对应的值是00000010，没有事件发生所对应的位将被清空。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;示例程序&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span&gt;利用select监听键盘输入操作：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;46&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;list&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;sys/wait.h&amp;gt;
#include &amp;lt;sys/select.h&amp;gt;
using namespace std;
#define BUF_SIZE 30
​
int main(){
    fd_set reads, temps;
    int result, str_len;
    char buf[BUF_SIZE];
    struct timeval timeout;
​
    FD_ZERO(&amp;amp;reads);
    FD_SET(0, &amp;amp;reads);  //0-该位置是控制台的标准输入
​
    while (1) {
        temps = reads;
        timeout.tv_sec = 5; //秒
        timeout.tv_usec = 0; //微秒
        result = select(1, &amp;amp;temps, 0, 0, &amp;amp;timeout);
        if(result == -1){
            puts(&quot;select() error...&quot;);
            break;
        }
        else if(result == 0){
            puts(&quot;Time wait...&quot;);
        }else{
            if(FD_ISSET(0, &amp;amp;temps)){    //fd_set指向的变量中包含文件描述符的信息，返回真
                str_len = read(0, buf, BUF_SIZE);
                buf[str_len] = 0;
                printf(&quot;message from console: %s.&quot;, buf);
            }
        }
​
    }
​
    return 0;
}
​
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;&lt;strong&gt;select模型的特点&lt;/strong&gt;&lt;/h4&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;*&quot; readability=&quot;2&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;可监控的文件描述符的数量与机器对应的fd_set大小有关，即sizeof(fd_set);&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;2&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;将fd_set传入到select函数调用前，还需要一个fd_set结构存储源数据，用于和调用select函数后的fd_set进行逐位对比，如果有事件发生，则通过FD_ISSET返回；如果原来标记为1，处于监听的文件描述符但没有事件发生，此时会将其置为0;。如上面示例程序的reads和temps。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;select上接收到普通数据或者带外数据会使select返回不同的就绪状态，普通数据触发可读状态，带外数据触发异常状态。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;如下，是一个I/O复用的服务端的案例用来解决多客户端请求的问题：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;68&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;signal.h&amp;gt;
#include &amp;lt;sys/wait.h&amp;gt;
#include &amp;lt;arpa/inet.h&amp;gt;
#include&amp;lt;sys/socket.h&amp;gt;
​
#define BUF_SIZE 100
void error_handling(char* message);
​
int main(int argc, char *argv[]){
    int serv_sock, clnt_sock;
    struct sockaddr_in serv_adr, clnt_adr;
    struct timeval timeout;
    fd_set reads, cpy_reads;
​
    socklen_t adr_sz;
    int fd_max, str_len, fd_num, i;
    char buf[BUF_SIZE];
    if(argc != 2){
        printf(&quot;Usage : %s &amp;lt;port&amp;gt;\n&quot;, argv[0]);
        exit(1);
    }
​
    serv_sock = socket(PF_INET, SOCK_STREAM, 0);
    memset(&amp;amp;serv_adr, 0, sizeof(serv_adr));
    serv_adr.sin_family = AF_INET;
    serv_adr.sin_port = htons(atoi(argv[1]));
    serv_adr.sin_addr.s_addr = htonl(INADDR_ANY);
​
    if(bind(serv_sock, (struct sockaddr*)&amp;amp;serv_adr, sizeof(serv_adr)) == -1){
        error_handling(&quot;bind() error.........&quot;);
    }
​
    if(listen(serv_sock, 5) == -1){
        error_handling(&quot;listen error.........&quot;);
    }
​
    FD_ZERO(&amp;amp;reads);
    FD_SET(serv_sock, &amp;amp;reads);
    fd_max = serv_sock;
​
    while(1){   //无限循环中调用select
        cpy_reads = reads;
        timeout.tv_sec = 5;
        timeout.tv_usec = 500;
​
        if((fd_num = select(fd_max+1, &amp;amp;cpy_reads, 0, 0, &amp;amp;timeout)) == -1)
            break;
​
        if(fd_num == 0)
            continue;
​
        for(i = 0; i &amp;lt; fd_max+1; i++){  //遍历观察那些文件描述符发生了变化
            if(FD_ISSET(i, &amp;amp;cpy_reads))  //观察fd_set中位发生变化
            {
                if(i == serv_sock){     //如果是连接请求
                    adr_sz = sizeof(clnt_adr);
                    clnt_sock = accept(serv_sock, (struct sockaddr*)&amp;amp;clnt_adr, &amp;amp;adr_sz);
                    FD_SET(clnt_sock, &amp;amp;reads);
                    if(fd_max &amp;lt; clnt_sock)  //如果clnt_sock对应fd_set中位置大于原先设定的需要监听的范围，则修改监听范围。
                        fd_max  = clnt_sock;
                    printf(&quot;Connected client : %d \n&quot;, clnt_sock);
                }
                else{   //某些套接字文件描述符指向的信息发生了改变，即收到通知，该文件描述符现在可读
                    str_len = read(i, buf, BUF_SIZE);
                    if(str_len == 0){
                        FD_CLR(i,&amp;amp;reads);
                        close(i);
                        printf(&quot;close client:%d \n&quot;, i);
                    }else{
                        write(i, buf, str_len);
                    }
                }
            }
        }
    }
    close(serv_sock);
    return 0;
}
​
void error_handling(char* message){
    fputs(message, stderr);
    fputc('\n', stderr);
    exit(1);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2.epoll&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span&gt;epoll是在2.5.44版内核中提出的（在使用前，应该验证一下内核版本，现在大部分内核版本都在2.6以上，可以通过&lt;span&gt;&lt;code&gt;cat /proc/sys/kernel/osrelease&lt;/code&gt;&lt;span&gt;查看），而且epoll方式只在linux下体统支持。关于epoll实现的三个函数：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
#include &amp;lt;sys/epoll.h&amp;gt;
int epoll_create(int size); 
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;epoll_create&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
int epoll_create(int size);
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;通过调用该函数执行成功后创建的文件描述符保存空间被称为“epoll例程”，参数size只是为操作系统提供一个参考需要为epoll例程多大的空间，即size大小并不等于最终的epoll例程大小。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;epoll_ctl&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span&gt;生成epoll例程后，在其内部注册监视对象文件描述符时需要用到&lt;span&gt;&lt;code&gt;epoll_ctl&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　参数说明：&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;*&quot; readability=&quot;1&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;epfd 用于注册监视对象的epoll实例（文件描述符）&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;op 指定监视对象的添加，删除或修改等操作&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;fd 需要监视对象的文件描述符&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;event 监视对象的事件类型&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;op可以有3个值，分别为：&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;0&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;EPOLL_CTL_ADD : 添加监听的事件&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;EPOLL_CTL_DEL : 删除监听的事件&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;EPOLL_CTL_MOD : 修改监听的事件&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;如&lt;span&gt;&lt;code&gt;epoll_ctl(A, EPOLL_CTL_ADD, B, C)&lt;/code&gt;&lt;span&gt;表示在epoll例程A中注册文件描述符B用于监视参数C中的事件。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;　　epoll_event的结构体如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
struct epoll_event {
    __uint32_t   events; /* Epoll events */
    epoll_data_t data;   /* User data variable 根据用户需求定制 */
};
typedef union epoll_data {
    void        *ptr;
    int          fd;
    __uint32_t   u32;
    __uint64_t   u64;
} epoll_data_t;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;epoll_event的event中保存的常量及其对应的具体时间类型&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;5&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;EPOLLERR : 文件上发上了一个错误。这个事件是一直监控的，即使没有明确指定&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;EPOLLHUP : 文件被挂断。这个事件是一直监控的，即使没有明确指定&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;EPOLLRDHUP : 对端关闭连接或者shutdown写入半连接&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;EPOLLET : 开启边缘触发，默认的是水平触发，所以我们并未看到EPOLLLT&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;EPOLLONESHOT : 一个事件发生并读取后，文件自动不再监控&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;EPOLLIN : 文件可读&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;EPOLLPRI : 文件有紧急数据可读&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;EPOLLOUT : 文件可写&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;EPOLLWAKEUP : 如果EPOLLONESHOT和EPOLLET清除了，并且进程拥有CAP_BLOCK_SUSPEND权限，那么这个标志能够保证事件在挂起或者处理的时候，系统不会挂起或休眠&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;如下示例代码展示其过程&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
struct epoll_event event;
event.events = EPOLLIN; //发生需要读取数据的情况时
event.data.fd = sockfd;
epoll_ctl(epfd,EPOLL_CTL_ADD,sockfd,event);
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;如果&lt;span&gt;&lt;code&gt;epoll_ctl&lt;/code&gt;&lt;span&gt;方法返回-1，则标志出现了问题，我们可以读取errno来定位错误，有如下errno会被设置：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;3&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;EBADF : epfd或者fd不是一个有效的文件描述符&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;EEXIST : op为EPOLL_CTL_ADD，但fd已经被监控&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;EINVAL : epfd是无效的epoll文件描述符&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;ENOENT : op为EPOLL_CTL_MOD或者EPOLL_CTL_DEL，并且fd未被监控&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;ENOMEM : 没有足够的内存完成当前操作&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;ENOSPC : epoll实例超过了/proc/sys/fs/epoll/max_user_watches中限制的监听数量&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;epoll_wait&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;参数说明：&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;*&quot; readability=&quot;1&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;epfd 用于注册监视对象的epoll实例（文件描述符）&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;events 保存发生事件的文件描述符集合的结构体地址值（数组首地址）&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;maxevents 保存的最大事件数量&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;timeout 等待时间（毫秒），-1表示一直等待事件的发生&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;该函数的作用类似与select函数。该函数被调用后，返回发生事件的文件描述符数，同时，第二个参数保存发生事件的文件描述符集合。此时，就不需要向像select那样针对所有文件描述符进行循环扫描，确定发生事件的文件描述符。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;工作模式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;　　epoll对文件描述符的操作有两种模式：LT（level trigger 条件触发）和ET（edge trigger 边缘触发）。LT模式是默认模式，LT模式与ET模式的区别可以通过TCP/IP网络编程书中的案例进行解释：&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;ol-list&quot; start=&quot;&quot;&gt;&lt;li class=&quot;md-list-item&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;LT 水平触发&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;7&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;儿子：“妈妈，我收到了5000元压岁钱。”&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;妈妈：“恩，省着点花！”&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;儿子：“妈妈，我今天买了个ipad，花了3000元。”&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;妈妈：“噢，这东西真贵。”&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;儿子：“妈妈，我今天买好多吃的，还剩1000元。”&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;妈妈：“用完了这些钱，我可不会再给你了。”&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;儿子：“妈妈，那1000元我没花，零花钱够用了。”&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;妈妈：“恩，这才是明智的做法！”&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;儿子：“妈妈，那1000元我没花，我要攒起来。”&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;妈妈：“恩，加油！”&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;　　&lt;/span&gt;只要儿子手中还有钱，他就会一直汇报，这就是LT模式。有钱就是1，没钱就是0，那么只要儿子还有钱，这种事件就是1-&amp;gt;1类型事件，自然是LT。将案例中儿子钱包换成输入缓冲区，压岁钱换成输入数据，在条件触发中，只要输入缓冲区有数据，将将会以事件的方式再次注册。&lt;/p&gt;
&lt;ol class=&quot;ol-list&quot; start=&quot;2&quot;&gt;&lt;li class=&quot;md-list-item&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;ET 边缘触发&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;0&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;儿子：“妈妈，我收到了5000元压岁钱。”&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;妈妈：“恩，省着点花！”&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;儿子：“……”&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;妈妈：“你倒是说话啊？压岁钱呢？！”&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;　　儿子从没钱到有钱，是一个0-&amp;gt;1的过程，因此为ET。儿子和妈妈说过自己拿到了压岁钱就完事了，至于怎么花钱，还剩多少钱，一概不说。可以看出，边缘触发中输入缓冲区中收到数据时仅注册一次，即使输入缓冲区中还有数据，也不会再次注册。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;示例程序&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;　　基于socket的客户端和服务端利用epoll来处理I/O复用问题：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;服务端程序：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;70&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;signal.h&amp;gt;
#include &amp;lt;sys/wait.h&amp;gt;
#include &amp;lt;arpa/inet.h&amp;gt;
#include&amp;lt;sys/socket.h&amp;gt;
#include&amp;lt;sys/epoll.h&amp;gt;
#define BUF_SIZE 4
#define EPOLL_SIZE 50
void error_handling(char* message);
​
int main(int argc, char *argv[]){
    int serv_sock, clnt_sock;
    struct sockaddr_in serv_adr, clnt_adr;
​
​
    socklen_t adr_sz;
    int  str_len, i;
    char buf[BUF_SIZE];
    if(argc != 2){
        printf(&quot;Usage : %s &amp;lt;port&amp;gt;\n&quot;, argv[0]);
        exit(1);
    }
​
    struct epoll_event* ep_events;
    struct epoll_event event;
    int epfd, event_cnt;
​
    serv_sock = socket(PF_INET, SOCK_STREAM, 0);
    memset(&amp;amp;serv_adr, 0, sizeof(serv_adr));
    serv_adr.sin_family = AF_INET;
    serv_adr.sin_port = htons(atoi(argv[1]));
    serv_adr.sin_addr.s_addr = htonl(INADDR_ANY);
​
    if(bind(serv_sock, (struct sockaddr*)&amp;amp;serv_adr, sizeof(serv_adr)) == -1){
        error_handling(&quot;bind() error.........&quot;);
    }
​
    if(listen(serv_sock, 5) == -1){
        error_handling(&quot;listen error.........&quot;);
    }
​
    epfd = epoll_create(EPOLL_SIZE); //返回创建的epoll文件描述符
    ep_events = (struct epoll_event*)malloc(sizeof(struct epoll_event)*EPOLL_SIZE);
​
    event.events = EPOLLIN; //发生读取事件的时候
    event.data.fd = serv_sock;
    epoll_ctl(epfd, EPOLL_CTL_ADD, serv_sock, &amp;amp;event);
​
    while(1){
        event_cnt = epoll_wait(epfd, ep_events, EPOLL_SIZE, -1);
​
        if(event_cnt == -1){
            error_handling(&quot;epoll_wait() failed...&quot;);
        }
​
        puts(&quot;return epoll_wait&quot;);
        for(i = 0; i &amp;lt; event_cnt; i++){
            if(ep_events[i].data.fd == serv_sock){  //处理新进的连接请求
                adr_sz = sizeof(clnt_adr);
                clnt_sock = accept(serv_sock, (struct sockaddr*)&amp;amp;clnt_adr, &amp;amp;adr_sz);
                event.data.fd = clnt_sock;
                event.events= EPOLLIN;
                epoll_ctl(epfd, EPOLL_CTL_ADD, clnt_sock, &amp;amp;event);
                printf(&quot;Connected client: %d \n&quot;, clnt_sock);
            }else{
                str_len = read(ep_events[i].data.fd, buf, BUF_SIZE);
                if(str_len == 0){   // 关闭客户端连接
                    epoll_ctl(epfd, EPOLL_CTL_DEL, ep_events[i].data.fd, NULL); //将读取完的连接取消监听
                    close(ep_events[i].data.fd);    //关闭客户端连接
                    printf(&quot;close client: %d \n&quot;, ep_events[i].data.fd);
                }else{
                    write(ep_events[i].data.fd, buf, str_len);
                }
            }
        }
    }
    close(serv_sock);
    close(epfd);
    return 0;
}
​
void error_handling(char* message){
    fputs(message, stderr);
    fputc('\n', stderr);
    exit(1);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;客户端程序：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;58&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;
#include &amp;lt;arpa/inet.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
using namespace std;
​
#define BUF_SIZE 1024
void errorhandling(char *message);
​
int main(int argc, char *argv[])
{
    int sock;
    struct sockaddr_in serv_addr;
    char message[BUF_SIZE];
    int str_len = 0 ,idx = 0, read_len = 0;
​
    if(argc != 3){
        printf( &quot;Usage : %d &amp;lt;IP&amp;gt; &amp;lt;port&amp;gt; &quot;, argv[0]);
        exit(0);
    }
​
    sock = socket(PF_INET, SOCK_STREAM, 0);
    if(sock == -1){
        errorhandling(&quot;socket() error;&quot;);
    }
​
    memset(&amp;amp;serv_addr, 0, sizeof(serv_addr));
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_addr.s_addr = inet_addr(argv[1]);
    serv_addr.sin_port = htons(atoi(argv[2]));
​
    if(connect(sock, (struct sockaddr*)&amp;amp;serv_addr, sizeof(serv_addr)) == -1){
        errorhandling(&quot;connect error!&quot;);
    }else{
        printf(&quot;connected.....\n&quot;);
    }
​
    while(1){
        fgets(message, BUF_SIZE, stdin);
        fflush(stdin);
        if(!strcmp(message, &quot;q\n&quot;) || !strcmp(message, &quot;Q\n&quot;))
            break;
        write(sock, message, strlen(message));
         memset(message, 0, sizeof(message));
        str_len = read(sock, message, BUF_SIZE - 1);
        message[str_len] = '\0';
        printf(&quot;Message from server : %s&quot;, message);
    }
​
    close(sock);
    return 0;
}
​
void errorhandling(char *message){
    fputs(message, stderr);
    fputc('\n', stderr);
    exit(1);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;参考资料&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;TCP/IP网络编程（[韩&lt;span&gt;] &lt;span&gt;尹圣雨 ）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-link&quot;&gt;&lt;a href=&quot;https://www.zhihu.com/question/28594409&quot;&gt;&lt;span&gt;I/O多路复用技术（multiplexing）是什么？&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span class=&quot; md-link&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/skyfsm/p/7079458.html&quot;&gt;&lt;span&gt;Linux编程之select&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span class=&quot; md-link&quot;&gt;&lt;span class=&quot;md-meta md-before&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/Anker/p/3263780.html&quot;&gt;&lt;span&gt;IO多路复用之epoll总结&lt;/span&gt;&lt;/a&gt;&lt;span class=&quot;md-meta md-before&quot;&gt;&lt;span class=&quot;md-content md-url&quot;&gt;&lt;span class=&quot;md-meta&quot;&gt;&lt;span class=&quot;md-content md-link-title&quot;&gt;&lt;span class=&quot;md-meta md-after&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 17 May 2019 10:59:00 +0000</pubDate>
<dc:creator>一盏淡酒、醉了夕阳</dc:creator>
<og:description>内核（操作系统）一旦发现进程指定的一个或者多个IO条件准备读或者准备写的时候，就会给该进程发一个通知。当服务端要处理多个套接字文件描述符的时候，这个时候可以采用IO复用，操作系统发现哪些套接字文件描述</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/helloworldcode/p/10883130.html</dc:identifier>
</item>
<item>
<title>ERP选型准备、方法及注意事项 - 怡海软件CRM</title>
<link>http://www.cnblogs.com/frensworkz/p/10882690.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/frensworkz/p/10882690.html</guid>
<description>&lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;伴随着市场的需求，ERP系统管理厂商如雨后春笋般推向市场，企业在选择时面临着多种选择。本文怡海软件将针对ERP系统如何选型从选型前的准备工作、了解ERP厂商、如何选择及注意事项等方面进行简要阐述。&lt;br/&gt;&lt;strong&gt;关键词：&lt;/strong&gt;ERP,SAP,Oracle,infor&lt;/p&gt;&lt;p&gt;接触过ERP（Enterprise Resource Planning 企业资源计划）的人，大多应该都听说过这样一句话：“上ERP找死，不上ERP等死”，横竖都是死，ERP系统有这么可怕吗？其实不然，ERP建设的重要性不言而喻，是企业信息管理投资的重点，正确实施将会给企业发挥巨大的作用。本文怡海软件将围绕ERP系统实施的第一步工作--软件选型进行简要阐述，希望能帮助那些计划实施ERP的企业在追寻ERP的道路上走得更加顺利。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1581663/201905/1581663-20190517172337069-1815767336.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;选型前的准备工作&lt;/strong&gt;&lt;br/&gt;企业在上ERP项目之前，必须要考虑这些问题：&lt;br/&gt;√ 清楚企业的现状、制定发展计划；&lt;br/&gt;√ 分析自身的管理特征；&lt;br/&gt;√ 明确引入ERP系统的目的及需求分析；&lt;br/&gt;√ 结合企业财务状况，做好预算；&lt;br/&gt;√ 选型小组成员确定。&lt;/p&gt;&lt;p&gt;提前进行或提前做计划，这样在选择ERP系统时才能做到有的放矢。否则，在众多ERP厂商中无目的的挑选，既有可能迷失方向，浪费时间，还有可能造成直到项目实施后才发现软件功能与企业的生产类型不相适应。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;了解ERP厂商&lt;/strong&gt;&lt;br/&gt;伴随着市场的需求，ERP系统管理厂商如雨后春笋般推向市场，企业在选择时面临着多种选择。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1581663/201905/1581663-20190517173530957-720052091.jpg&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;strong&gt;国外主要有：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SAP：SAP公司是ERP思想的倡导者，成立于1972年，总部设在德国南部的沃尔道夫市。SAP所提供的是一个有效的标准而又全面的ERP软件，同时软件模块化结构保证了数据单独处理的特殊方案需求。&lt;/p&gt;
&lt;p&gt;Oracle：Oracle公司是全球最大的应用软件供应商，成立于1977年，总部设在美国加州。Oracle主打管理软件产品是目前全面集成的电子商务套件之一，能够使企业经营的各个方面全面自动化。&lt;/p&gt;
&lt;p&gt;Infor ：作为一家 ERP 软件公司成立于2002 年，是为特定行业提供商业云软件的全球领先提供商。Infor 构建基于云的全面行业套件，并帮您部署用户体验至上的软件，充分利用数据科学并与您现有系统轻松集成。&lt;/p&gt;
&lt;p&gt;Microsoft：微软ERP全称是Microsoft Dynamics ERP，包括Microsoft Dynamics Ax（Axapta）和Microsoft Dynamics Nav（Navision）。微软 ERP是专为企业定制的企业资源规划解决方案，可以最大限度地提高企业生产效率，提高整个组织的透明度并简化合规性，使您轻松开展跨国地区业务或跨国企业管理。&lt;/p&gt;
&lt;p&gt;NETSUITE:&lt;em&gt;NetSuite&lt;/em&gt; 公司成立于1998年，总部设在美国加利福尼亚洲的 San Mateo ，是专门为中小型企业提供定制企业管理软件的应用程序制造商。NETSUITE erp 是一套统一的商业管理套件,涵盖了ERP/财务,CRM和电子商务等功能。&lt;/p&gt;
&lt;p&gt;IFS： IFS 应用系统是一款与众不同的企业资源规划 (ERP) 软件。它不像其它一些 ERP 套件那样复杂和死板，其设计原则就是能够根据技术和业务的变化快速调整，从而最大程度地提高企业的敏捷性。&lt;/p&gt;
&lt;p&gt;Sage：赛捷集团是全球第三大管理软件及解决方案专业提供商，其提供的ERP是一套全面的、多层架构的管理系统，其为客户提供多样化的选择、卓越的性能、使用的可靠性，以及无缝连接等功能。&lt;/p&gt;
&lt;p&gt;此外国外厂商还有Syspro 和 IQMS等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;国内主要有：&lt;/strong&gt;用友、金碟、智邦国际、浪潮通软、东软、宝信、航天信息、速达、任我行、金算盘等。&lt;/p&gt;&lt;p&gt;他们有的已经在ERP行业做了很久，积累了丰富的经验；有些厂商则是从财务软件转型做ERP，这样的厂商，他的ERP软件可能在财务模块上的功能很用强，但在其他模块就有可能存在弱点；还有的只是刚刚起步，但他们在ERP行业中各有千秋。分析一下目前市场上的ERP软件厂商，根据市场份额排名大致可以分为三类：&lt;/p&gt;&lt;p&gt;1、高端产品市场：如SAP、Oracle、Microsoft。它们功能强大，性能稳定、系统安全性高、具有开放性和可扩展性等特点，但实施复杂、实施难度大、周期长、价格高昂。要成功实施这样的ERP软件，价位一般在几十万，上百万元以上。这样的系统适合有一定预算的企业。&lt;br/&gt;2、中端产品市场：全球排行在10名左右的ERP软件如IFS、IQMS、Syspro等。这些ERP软件在某些行业领域的跨国公司管理方面有成功经验，往往在某个或某几个行业具有专业版本和相当强的优势。&lt;br/&gt;3、低端产品市场：主要是全球排行在20以后ERP软件。这些ERP软件实施周期短、价格低，但其稳定性、安全性及功能丰富程度方面差强人意。&lt;/p&gt;&lt;p&gt;需注意，企业在ERP系统选型方面，不要盲目追求最好，也不要因为资金紧张就选择不成熟的ERP软件，企业应该充分考虑自身的运作特点和性能价格比进行选择。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;ERP系统选型&lt;/strong&gt;&lt;br/&gt;企业在有的放矢地了解了ERP厂商之后，面对琳琅满目的各色ERP，开始要选择恰当的ERP了，这里怡海软件建议企业可以从下这些方面来考察ERP厂商。&lt;br/&gt;1、专业背景&lt;br/&gt;√是否有企业所在行业的实施经验？ERP厂商应该在相关行业有成功应用和相关行业的管理经验。企业ERP系统建设的实践及专业性非常的强，ERP软件厂商的专业程度直接影响企业的实施效果。&lt;br/&gt;√是否熟悉企业的具体运作模式和把掘企业的真正需求？企业的ERP系统建设不是“纸上谈兵”的事情，而是要切实能解决企业的具体问题。&lt;br/&gt;√是否能提供企业信息化建设的解决方案？&lt;br/&gt;√是否真正踏实地在做该领域的工作？因为企业的ERP系统建设是一个长期的工作，所选择的ERP厂商应该是专注在此行业。&lt;/p&gt;&lt;p&gt;2、技术实力&lt;br/&gt;√企业研发、实施团队的能力如何？&lt;br/&gt;√企业是否会花费更多的时间和资金投入到ERP产品的研发和优化中？软件开发尤其是要关注企业的研发管理能力，一家合格的ERP厂商对研发的投入会占全年收入的一定比例。&lt;br/&gt;√能否提供及时、快捷、优质、健全的技术支持？技术支持的好坏直接影&lt;br/&gt;响企业的具体实施和运用。&lt;/p&gt;&lt;p&gt;3、产品实力&lt;br/&gt;√是否涵盖了企业的主要业务范围？&lt;br/&gt;√是否满足企业现阶段需求？&lt;br/&gt;√产品是否满足企业可持续发展需求？ERP厂商不但要提供合理的ERP产品来满足企业的需求，更要提供适应企业未来发展的解决方案。&lt;br/&gt;√是否具备分析、优化和适应企业管理流程变化的功能？&lt;/p&gt;&lt;p&gt;4、服务和咨询能力&lt;br/&gt;√是否提供咨询服务？企业的ERP系统建设，有时并不是一个企业能完全解决的，就需要ERP软件厂商能站在企业的高度为企业提供相关的咨询服务工作，以满足企业的不同要求。&lt;br/&gt;√是否能为企业提供其他的增值服务能力？&lt;/p&gt;&lt;p&gt;5、其他&lt;br/&gt;√系统是否足够安全和稳定？&lt;br/&gt;√是否能与企业现有系统集成？目前大多数的企业的信息化建设都不是“白纸一张”，而是在单元技术方面取得了一定的实质性的进展，因此，企业在选择集成商时一定还要考虑能否继承企业现有的系统，或实现对现有系统的良性改造，实现企业信息化建设的平稳过渡。&lt;br/&gt;企业在明确了自身的需求后，还应明确ERP厂商能提供什么？只有在全方位的考察之后，企业才可能成功地完成ERP系统项目的选型工作。因为企业的信息化建设是一个长期的系统工程，需站在企业整体信息化的全局上来确定ERP软件厂商。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;选型注意事项&lt;/strong&gt;&lt;br/&gt;1、企业是主角：企业在ERP系统建设过程中，摆正企业与ERP厂商之间的关系非常关键，企业一定要树立企业的ERP系统建设不应该由ERP厂商独立完成的观念。“主角”是企业本身，而ERP厂商仅仅是“配角”的身份。ERP厂商应该放在咨询、顾问和具体实施的地位。摆正了关系，才能更好的进行合作，将双方的优势集中，实现“专业人做专业事”。&lt;br/&gt;2、转变管理理念：用先进实用的管理理念理顺企业现有的管理；需要时制定企业结构调整计划，尤其是关键业务的流程重组。&lt;br/&gt;3、强调软件的实用性：技术的领先性和技术的实用性一直困扰企业ERP系统建设时的选型，单纯追求技术的先进性和实用性都是不足取的，企业应该结合企业自身的实际，在追求先进性的同时强调实用性，并且一定要站在整个企业信息集成的角度来选择软件，并且要切实注重于系统的集成和开放。&lt;br/&gt;4、整体规划、分步实施：整体规划是系统的“整体”,是系统的“整体规划”，是实现整个系统的“技术途径”，总体规划一般不承担具体的项目设计，是整个研制工作中不可缺少的技术总纲。在具体实施过程中，要从简单技术入手，迅速向广度和深度发展。在应用的基础上启发更广泛、更深入的需求，同时通过效益驱动可以以树立企业建设信息化的信心，减少企业一次投入过多，负担过重而带来不必要的风险，分步实施同时可以紧跟信息技术发展的前沿。&lt;br/&gt;5、明确目标：即是不要偏离系统建设的最终目标，实现企业的整体的信息集成。&lt;br/&gt;6、高层领导：参与确实领会“一把手工程”，也即是不仅仅是企业的最高领导亲自参与，还应该包括整个决策层的参与决策，是一个企业的高层领导组成的领导班子，是广义上的“一把手”。&lt;/p&gt;&lt;p&gt;ERP系统能够将企业外部客户需求、内部生产制造流程以及供应商资源整合在一起，从而体现以客户为导向、市场为中心、整合企业资源的经营宗旨，提升企业的核心竞争力。随着信息技术的不断发展，企业信息化成为企业不可或缺的一环，而ERP作为必要手段，如何选择ERP软件，减少企业风险，是信息化建设过程中至关重要的事情。&lt;/p&gt;
&lt;p&gt;欢迎转载，转载请注明出处：怡海软件（&lt;a href=&quot;http://www.frensworkz.com/&quot; target=&quot;_blank&quot;&gt;http://www.frensworkz.com/&lt;/a&gt;）&lt;/p&gt;

</description>
<pubDate>Fri, 17 May 2019 09:37:00 +0000</pubDate>
<dc:creator>怡海软件CRM</dc:creator>
<og:description>摘要：伴随着市场的需求，ERP系统管理厂商如雨后春笋般推向市场，企业在选择时面临着多种选择。本文怡海软件将针对ERP系统如何选型从选型前的准备工作、了解ERP厂商、如何选择及注意事项等方面进行简要阐述</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/frensworkz/p/10882690.html</dc:identifier>
</item>
<item>
<title>Google IO 2019 Android 太长不看版 - 圣骑士wind</title>
<link>http://www.cnblogs.com/mengdd/p/Google-IO-2019-Android-TLDR.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mengdd/p/Google-IO-2019-Android-TLDR.html</guid>
<description>&lt;p&gt;Google I/O 2019, 这里有个playlist是所有Android开发相关的session视频合集:&lt;br/&gt;&lt;a href=&quot;https://www.youtube.com/playlist?list=PLWz5rJ2EKKc9FfSQIRXEWyWpHD6TtwxMM&quot;&gt;Android &amp;amp; Play at Google I/O 2019&lt;/a&gt;&lt;br/&gt;当然啦每个视频都看不太现实了, 就挑几个看看吧.&lt;br/&gt;这里是我个人的一点笔记, 可以作为一个太长不看版, 感兴趣的点再自己了解下.&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;更易用的API.&lt;/li&gt;
&lt;li&gt;隐藏底层细节.&lt;/li&gt;
&lt;li&gt;兼容各种设备.&lt;/li&gt;
&lt;li&gt;自动化测试套件.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Design Toolchain:&lt;/p&gt;
&lt;h3 id=&quot;layout-editor&quot;&gt;Layout Editor&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;Blueprint mode.&lt;/li&gt;
&lt;li&gt;context menu来提供一些更方便的工作. constraint popup. constraint menu.&lt;/li&gt;
&lt;li&gt;预览改进: RecyclerView的预览改进. 预览sample数据.&lt;/li&gt;
&lt;li&gt;attribute界面可以指定dimen中定义的自定义尺寸.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;相关文章:&lt;br/&gt;https://medium.com/androiddevelopers/android-studio-project-marble-layout-editor-608b6704957a&lt;/p&gt;
&lt;h3 id=&quot;navigation-editor&quot;&gt;Navigation Editor&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;navigation components的使用.&lt;/li&gt;
&lt;li&gt;navigation editor中的预览.&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;resource-manager&quot;&gt;Resource Manager:&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;Batch Import, 可以直接把图片资源拖拽整理进去. * 可以把svg拽进去变成vector drawable.&lt;/li&gt;
&lt;li&gt;提供了layout, color等的小图预览.&lt;/li&gt;
&lt;li&gt;颜色的alpha终于可以用百分比设置了.&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;layout-inspector&quot;&gt;Layout Inspector:&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;改进了属性显示.&lt;/li&gt;
&lt;li&gt;可以直接预览修改.&lt;/li&gt;
&lt;li&gt;3D显示, 可以查找某个背景颜色到底是哪一层设置的.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;(我的思考: 现在Android Studio越来越鼓励开发者直接利用图形界面来设置layout了, 总是喜欢直接编辑xml算不算是早期Android遗老遗少的一个陋习?)&lt;/p&gt;

&lt;p&gt;Kotlin first.&lt;/p&gt;
&lt;h3 id=&quot;data-binding&quot;&gt;Data binding:&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;Faster complilation:&lt;br/&gt;&lt;code&gt;android.databinding.incremental = true&lt;/code&gt;.&lt;br/&gt;增量注解处理.&lt;/li&gt;
&lt;li&gt;错误信息改善了. (耶!)&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;how-to-access-views&quot;&gt;How to access views?&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;几种find view的方法比较.&lt;/li&gt;
&lt;li&gt;View Binding: coming soon in Android Studio 3.6.&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;lifecycle&quot;&gt;Lifecycle&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;ViewModel和Saved State.&lt;br/&gt;&lt;code&gt;SavedStateHandle&lt;/code&gt;: 传入ViewModel, 用于保存一些在应用被杀死后重启仍然需要恢复的值.&lt;/li&gt;
&lt;li&gt;一些代码的写法被优化了.&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;workmanager&quot;&gt;WorkManager&lt;/h3&gt;
&lt;p&gt;优点: deferrable, persistent, constraint-based, backwards compatible.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;性能: on-demand initialization.&lt;/li&gt;
&lt;li&gt;Google Play Services integration.&lt;/li&gt;
&lt;li&gt;兼容性.&lt;/li&gt;
&lt;li&gt;测试.&lt;/li&gt;
&lt;li&gt;Future: foreground service.&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;room&quot;&gt;Room&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;Coroutines, 协程支持: suspend方法.&lt;/li&gt;
&lt;li&gt;Full text search: &lt;code&gt;@Fts4&lt;/code&gt;, &lt;code&gt;MATCH&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Database Views. &lt;code&gt;@DatabaseView&lt;/code&gt;. 重新组织一个可查询的数据结构, 类似于重新组装一个表, 用来查询.&lt;/li&gt;
&lt;li&gt;扩展了Rx支持: 数据库操作方法可以返回&lt;code&gt;Single&lt;/code&gt;, &lt;code&gt;Completable&lt;/code&gt;等Rx类型.&lt;/li&gt;
&lt;li&gt;Future: 注解处理; 关系改善; migration改善; 协程Channel&amp;amp;Flow.&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;paging&quot;&gt;Paging&lt;/h3&gt;
&lt;p&gt;What's next in Paging?&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Built in network support with error handling.&lt;/li&gt;
&lt;li&gt;Headers &amp;amp; footers&lt;/li&gt;
&lt;li&gt;更好的Rx和协程集成.&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;navigation&quot;&gt;Navigation&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;ViewModels scoped to Navigation Graphs.&lt;/li&gt;
&lt;li&gt;Navigate by URI.&lt;/li&gt;
&lt;li&gt;Dialog as destinations.&lt;/li&gt;
&lt;li&gt;Safe Args.&lt;/li&gt;
&lt;li&gt;Future: Better support for dynamic features.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;最后广告了一下这个课程:&lt;br/&gt;https://www.udacity.com/course/developing-android-apps-with-kotlin--ud9012&lt;/p&gt;

&lt;p&gt;What's new in Android Q:&lt;/p&gt;
&lt;h3 id=&quot;system-ui&quot;&gt;System UI&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;SAW: System Alert Window. -&amp;gt; 安全问题. -&amp;gt; 引入Bubbles (API 29).&lt;/li&gt;
&lt;li&gt;Dark theme.&lt;/li&gt;
&lt;li&gt;Share sheet: 内容预览, 粘贴, 性能改善.&lt;/li&gt;
&lt;li&gt;通知分区域: Priority, Gentle.&lt;/li&gt;
&lt;li&gt;Notification actions: 自动生成回复.&lt;/li&gt;
&lt;li&gt;手势导航.&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;platform&quot;&gt;Platform&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;WebView: Trichrome: Separate WebView/Chrome, hung renderer检测.&lt;/li&gt;
&lt;li&gt;Accessibility.&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;text&quot;&gt;Text&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;API 23默认开启了连字符, 性能下降, 所以在Q默认关闭了.&lt;/li&gt;
&lt;li&gt;API for fonts.&lt;br/&gt;还单独有个text的演讲专门讲这个.&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;magnifier&quot;&gt;Magnifier&lt;/h3&gt;
&lt;h3 id=&quot;private-apis&quot;&gt;private APIs&lt;/h3&gt;
&lt;p&gt;要么用public的, 要么private改成public的, 要么加新的.&lt;br/&gt;gray list中加了更多的(以后的版本将不能用了).&lt;/p&gt;
&lt;h3 id=&quot;android-runtime-art&quot;&gt;Android Runtime (ART)&lt;/h3&gt;
&lt;p&gt;Profile, 启动改善, GC改善.&lt;/p&gt;
&lt;h3 id=&quot;kotlin&quot;&gt;Kotlin&lt;/h3&gt;
&lt;p&gt;Q的新API有nullability注解.&lt;/p&gt;
&lt;h3 id=&quot;security&quot;&gt;Security&lt;/h3&gt;
&lt;p&gt;TLS 1.3 默认开启.&lt;br/&gt;生物识别改进.&lt;/p&gt;
&lt;h3 id=&quot;jetpack-compose&quot;&gt;Jetpack Compose&lt;/h3&gt;
&lt;p&gt;全新的UI组件: Kotlin, Reactive.&lt;br/&gt;(很像Flutter.)&lt;/p&gt;
&lt;h3 id=&quot;privacy&quot;&gt;Privacy&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;外部存储限制.&lt;/li&gt;
&lt;li&gt;Location: 权限设置更新. 新增只有前台时允许的选项.&lt;/li&gt;
&lt;li&gt;后台启动Activity限制.&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;其他&quot;&gt;其他&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;CameraX&lt;/li&gt;
&lt;li&gt;Architecture Components&lt;/li&gt;
&lt;li&gt;ViewPager2&lt;/li&gt;
&lt;li&gt;ViewBindings&lt;/li&gt;
&lt;li&gt;Blend Modes&lt;/li&gt;
&lt;li&gt;RenderNode&lt;/li&gt;
&lt;li&gt;HardwareRenderer: 可以控制光源(阴影)&lt;/li&gt;
&lt;li&gt;Hardware Bitmaps&lt;/li&gt;
&lt;li&gt;Audio Playback Capture&lt;/li&gt;
&lt;li&gt;应用不能控制wifi开关&lt;/li&gt;
&lt;li&gt;Settings Panel&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;为什么我们要模块化呢&quot;&gt;为什么我们要模块化呢?&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;scale: 更易分组开发人员; 更易查找资源.&lt;/li&gt;
&lt;li&gt;更快的编译速度.&lt;/li&gt;
&lt;li&gt;更快的CI. 只执行有修改的module相关的测试.&lt;/li&gt;
&lt;li&gt;Good for business. App Bundles: 更小的apk.&lt;/li&gt;
&lt;li&gt;分离的feature测试. 快速AB Test一个新功能.&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;两种modules&quot;&gt;两种Modules:&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;Library Module&lt;/li&gt;
&lt;li&gt;Dynamic Feature Module&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;如何分离模块呢&quot;&gt;如何分离模块呢?&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;by feature&lt;/li&gt;
&lt;li&gt;by layer&lt;/li&gt;
&lt;li&gt;feature &amp;amp; layer.&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;模块间的依赖&quot;&gt;模块间的依赖&lt;/h3&gt;
&lt;p&gt;Module A依赖Module B:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;api&lt;/code&gt;: Module B is part of my &lt;strong&gt;Public API&lt;/strong&gt;. 依赖A的可以看到B.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;implementation&lt;/code&gt;: Module B is my &lt;strong&gt;Implementation Detail&lt;/strong&gt;. 依赖A的看不到B.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里讨论了一个分层模块化构架中的问题: repo模块对数据库模块的依赖, 用&lt;code&gt;api&lt;/code&gt;, 上层可以直接使用数据库模块中的实例类, 但是同时暴露了DAO, 破坏了模块化分离的意义.&lt;br/&gt;两个选择:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;规定在上层不要操作数据库.&lt;/li&gt;
&lt;li&gt;新建一个通用的数据模块, 存放实体类, 数据库模块&lt;code&gt;implementation&lt;/code&gt;依赖它, repo模块&lt;code&gt;api&lt;/code&gt;依赖它.&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;测试.&quot;&gt;测试.&lt;/h3&gt;
&lt;h3 id=&quot;dynamic-feature-modules&quot;&gt;Dynamic feature modules&lt;/h3&gt;
&lt;p&gt;几个挑战:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;导航. 需要hardcode类名.&lt;/li&gt;
&lt;li&gt;找依赖. Dynamically loaded modules.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;代码例子: &lt;a href=&quot;https://github.com/googlesamples/android-dynamic-code-loading&quot;&gt;android-dynamic-code-loading&lt;/a&gt;&lt;br/&gt;结合dagger.&lt;/p&gt;
&lt;h3 id=&quot;数据库&quot;&gt;数据库&lt;/h3&gt;
&lt;p&gt;数据库的几种选择:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一个数据库: 好维护, 好共享, 但是没有分离.&lt;/li&gt;
&lt;li&gt;一个核心数据库 + 每个feature自己的数据库: 有了分离, 但是共享成了问题. 如果hybrid: 让有交互的模块共享, 也是挺复杂的.&lt;/li&gt;
&lt;li&gt;一个Room的bright feature: Multi-module数据库. (Not Available now.)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;最后闲聊了几句关于构架的讨论.&lt;br/&gt;Android team只是提供options, 最后的选择还是depends.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;考虑: short time costs, long time benefits.&lt;/li&gt;
&lt;li&gt;用户不会因为app的构架好而给你5星.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;三个方面:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Sharing: 性能改进; UI改进; 更多自定义选项.&lt;/li&gt;
&lt;li&gt;Notifications: gentle; actions.&lt;/li&gt;
&lt;li&gt;Multitasking: Bubbles.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Jetpack Benchmark Library:&lt;br/&gt;https://developer.android.com/studio/profile/benchmark.md&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;可以测量工作方法的时间: 重复测量的Rule;&lt;br/&gt;合理排除初始化时间.&lt;/li&gt;
&lt;li&gt;UI测试.&lt;/li&gt;
&lt;li&gt;新增module: Benchmark Module.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;工具实现细节介绍.&lt;/p&gt;
&lt;p&gt;Best Practices:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Start with tracing.&lt;/li&gt;
&lt;li&gt;Synchronous blocks.&lt;/li&gt;
&lt;li&gt;Small blocks&lt;/li&gt;
&lt;li&gt;Hot code.&lt;/li&gt;
&lt;li&gt;Caches.&lt;/li&gt;
&lt;li&gt;@RunWith(Parameterized)&lt;/li&gt;
&lt;li&gt;不要比较设备.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;例子: &lt;a href=&quot;https://github.com/googlesamples/android-performance&quot;&gt;googlesamples/android-performance&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最后, 欢迎关注微信公众号: 圣骑士Wind&lt;br/&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/325852/201610/325852-20161025151540109-490601558.png&quot; alt=&quot;微信公众号&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 17 May 2019 09:33:00 +0000</pubDate>
<dc:creator>圣骑士wind</dc:creator>
<og:description>Google I/O 2019, Android版本的学霸画重点的笔记.</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mengdd/p/Google-IO-2019-Android-TLDR.html</dc:identifier>
</item>
<item>
<title>网络应用（6）：http报文结构与curl的使用 - 广州小程</title>
<link>http://www.cnblogs.com/freeself/p/10882404.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/freeself/p/10882404.html</guid>
<description>&lt;p&gt;http是一个协议，协议就是约定、规定，先不管为什么这么约定有什么高深的东西，为了解决具体问题，我们先要能使用协议，理解协议中对我们有用的那部分数据，是的，我们不是研究生，更不是纯研究，所有的研究都要由具体的问题来驱动。&lt;/p&gt;
&lt;p&gt;那这里的具体问题是什么？就是看懂http的请求跟回复啊，就像写某某申请一样，你不理申请最终怎么传递出去，你先要知道以什么格式来写，对方回复后你怎么看明白它，这才是基本的。所以，http的请求格式跟回复格式，其实也只是形式上的东西，形式是多变而不稳定的，更不是什么深奥的东西，它只是表达了一些内容。&lt;/p&gt;
&lt;p&gt;那就来看看http请求与响应的形式上的东西吧。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文介绍http请求与响应的报文结构，以及curl的使用。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;先抓个包来直观看一下，在百度的搜索框中，敲入“helloworld”并回车，这时会发起一个http请求，用charles来抓包（为什么用它？因为我介绍过！），可以看到这样的请求与响应的信息：&lt;br/&gt;&lt;img src=&quot;https://free-picture1.oss-cn-shenzhen.aliyuncs.com/%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8/http%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94%26curl/get%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94%E7%9A%84%E6%95%B0%E6%8D%AE.jpg&quot; alt=&quot;http请求与响应信息&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从数据包来看，有一个GET方法，返回了200的状态码，等等。但这里混合了请求与响应的信息，如果分开来看，请求与响应各自有什么数据组织结构呢？&lt;/p&gt;
&lt;h4 id=&quot;请求报文&quot;&gt;（1）请求报文&lt;/h4&gt;
&lt;p&gt;http请求数据，使用的结构是这样的：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;{请求行，请求头，请求体}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;小程引用网上的一张图，这张图描绘了这个结构：&lt;br/&gt;&lt;img src=&quot;https://free-picture1.oss-cn-shenzhen.aliyuncs.com/%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8/http%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94%26curl/http%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E7%9A%84%E7%BB%93%E6%9E%84.jpg&quot; alt=&quot;http请求报文结构&quot;/&gt;&lt;/p&gt;
&lt;p&gt;参照上图，&lt;strong&gt;请求行&lt;/strong&gt;是这个样子：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GET /index.html HTTP/1.1&lt;br/&gt;或者：&lt;br/&gt;POST /xiaocheng/about.html HTTP/1.1&lt;br/&gt;...&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;注意，请求行一般不包括host的地址，而host地址存放在请求头中。&lt;/p&gt;
&lt;p&gt;然后是&lt;strong&gt;请求头&lt;/strong&gt;，分为多行，每一行是一个键值对（key: value的格式），比如请求头是这个样子的：&lt;br/&gt;&lt;img src=&quot;https://free-picture1.oss-cn-shenzhen.aliyuncs.com/%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8/http%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94%26curl/http%E8%AF%B7%E6%B1%82%E5%A4%B4.jpg&quot; alt=&quot;http请求头&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后是&lt;strong&gt;请求体&lt;/strong&gt;，一般来说GET方法是不带请求体的，因为所有内容都放到请求行（特别是url中）或请求头中了，一般来说POST方法需要带请求体，比如在iTunes下载一个APP时，POST请求数据是这样的：&lt;br/&gt;&lt;img src=&quot;https://free-picture1.oss-cn-shenzhen.aliyuncs.com/%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8/http%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94%26curl/http%E8%AF%B7%E6%B1%82%E4%BD%931.jpg&quot; alt=&quot;http请求体1&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://free-picture1.oss-cn-shenzhen.aliyuncs.com/%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8/http%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94%26curl/http%E8%AF%B7%E6%B1%82%E4%BD%932.jpg&quot; alt=&quot;http请求体2&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不要觉得好新奇，又是请求行、请求头又是请求体的，这都只是规则，形式上的东西，以这种形式传递了内容。&lt;/p&gt;
&lt;h4 id=&quot;响应报文&quot;&gt;（2）响应报文&lt;/h4&gt;
&lt;p&gt;响应数据的结构，也可以分三部分：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;{响应行，响应头，响应体}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里给一个响应实例：&lt;br/&gt;&lt;img src=&quot;https://free-picture1.oss-cn-shenzhen.aliyuncs.com/%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8/http%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94%26curl/http%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%871.jpg&quot; alt=&quot;http响应报文1&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://free-picture1.oss-cn-shenzhen.aliyuncs.com/%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8/http%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94%26curl/http%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%872.jpg&quot; alt=&quot;http响应报文2&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;响应行&lt;/strong&gt;，也叫状态行，包括http的版本、状态码与状态描述。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;响应头&lt;/strong&gt;跟请求头一样，由一行一行的key-value构成。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;响应体&lt;/strong&gt;一般就是请求方想要的数据了，但响应体不一定会存在，比如HEAD请求方法时不返回响应体（这时响应行就是请求方想要的）。&lt;/p&gt;
&lt;p&gt;规则上是这样的，响应/请求行就是一行，响应/请求头就是key-value的集合，响应/请求体就是各种格式的数据（xml、gif、png等格式）。&lt;/p&gt;
&lt;p&gt;http请求与响应数据，还有其它的一些知识，比如GET与POST的区别、返回404/403/303表示什么意思，等等，这个谁用谁查，不细说。&lt;/p&gt;
&lt;p&gt;但我想说一个工具，一个可以发起http请求的工具，好用，就是&lt;strong&gt;curl&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&quot;curl的使用&quot;&gt;（3）curl的使用&lt;/h4&gt;
&lt;p&gt;小程使用的是macos，mac自带了curl工具。&lt;/p&gt;
&lt;p&gt;curl的功能也算强大的，提供了系列的选项，这里只介绍一些常规的使用方式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;get请求，与保存&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;curl www.baidu.com
curl &quot;http://172.17.21.197:54321?pa1=hello&quot;
// 保存，下载
curl -o file.html www.baidu.com   
curl -o i.jpg http://img3.douban.com/lpic/s4549903.jpg
// -A 仿造ie与运行平台
curl -A &quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)&quot; www.baidu.com   
// -e 仿造入口链接（即referer，用于盗链）
curl -A &quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)&quot; -e &quot;www.google.com&quot; www.baidu.com   
// -x 使用代理
curl -x a.b.c.d:54321 http://google.com  
// -D 保存cookie到文件
curl www.baidu.com -o aa.txt -D cookie.txt  
// -b 读取文件并当作cookie数据来请求
curl www.baidu.com -b cookie.txt  
// -H 设置请求头，这里设置了cookie跟ua
curl -H &quot;Cookie: install_id=14621691626; sid_guard=\&quot;0eb878191489e4247f643672c932c814|1504782359|2592000|Sat\054 07-Oct-2017 11:05:59 GMT\&quot;; \n User-Agent: xxx/1.5.6 (iPhone; iOS 10.2; Scale/2.00)&quot; &quot;https://xxx.yy.com/...&quot;  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;post&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// -d 请求体
curl -d &quot;user=nickwolfe&amp;amp;password=12345&quot; http://www.linuxidc.com/login.cgi  
curl -d &quot;key=jet&quot; 192.168.2.32:54321&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;post，以表单的方式（multipart/form-data）&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// &quot;file&quot;为key名，随便起，后面为文件路径（包括文件包）
curl -F &quot;file=@./myfile.ok&quot; &quot;http://172.17.xx.xx:54321&quot;   &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;总结一下，本文介绍了http请求与响应报文的数据结构，也介绍了用于发送http请求的工具curl的使用。文章的目的，一方面是让你巩固http报文的结构（其实这只是形式的东西，不要太在意），另一方面掌握一个便利的发送http请求的工具（这个就很实用了）。&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://free-picture1.oss-cn-shenzhen.aliyuncs.com/%E9%80%BB%E8%BE%91%E9%A2%98/%E9%80%BB15.png&quot; alt=&quot;smile&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 17 May 2019 09:13:00 +0000</pubDate>
<dc:creator>广州小程</dc:creator>
<og:description>http是一个协议，协议就是约定、规定，先不管为什么这么约定有什么高深的东西，为了解决具体问题，我们先要能使用协议，理解协议中对我们有用的那部分数据，是的，我们不是研究生，更不是纯研究，所有的研究都要</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/freeself/p/10882404.html</dc:identifier>
</item>
<item>
<title>讨论：研发团队到底应该是制定OKR还是制定KPI？ - 猎手家园</title>
<link>http://www.cnblogs.com/hunttown/p/10882308.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hunttown/p/10882308.html</guid>
<description>&lt;p&gt;在讨论之前我们先来了解两个概念：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、KPI&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;KPI是一套绩效管理的方法。全称为：Key Performance Indicator。中文叫：&lt;strong&gt;关键绩效指标&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;KPI，和我们的“任务分解”不同。任务分解是把目标，分解成可执行的任务。是在“如何执行”层面的思考。KPI，是把目标分解成可考核的指标，是在“如何管理”层面的思考。KPI是非常重要的一种管理手段，只是它有它的适用性。KPI是你管理驾驶舱中的仪表盘，让你时刻知道组织的运行状态。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二、OKR&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;OKR，是“Objective &amp;amp; Key Results”的缩写。简单来说，就是整个公司、团队、个人，都要设立目标（Objective），和衡量这些目标完成与否的关键结果（Key Results）。&lt;/p&gt;
&lt;p&gt;OKR是目标管理工具。如果说KPI是秒表，那OKR就是指南针。它最重要的作用，是让一个无法用数字考核的团队，通过层层分解的目标、关键任务，向同一个方向前行。&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot; __bg_gif&quot; src=&quot;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/IEWeX9udEiaKiboYiaWuRG3iaMht8PmwGzN0FllAPj1rATaCYmT9RiaK6yWy0D5fV9iblFyIrH1DPeROzZcIJ6zk5bYg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;128&quot; data-order=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三、绩效管理毁了索尼？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;索尼公司前常务董事土井利忠于2006年的一篇文章《&lt;a href=&quot;https://www.cnblogs.com/hunttown/p/10880022.html&quot; target=&quot;_blank&quot;&gt;绩效管理毁了索尼&lt;/a&gt;》中写到：“（绩效管理）让研发人员为了外部动机工作，丧失了内在的创新热情；那些短期内难见效益的工作，比如产品质量检验以及“老化处理”工序被忽视，为了完成业绩考核，几乎所有的人都只提出容易实现的低目标……”&lt;/p&gt;

&lt;p&gt;此文一出，一时间在互联网引起轩然大波。&lt;strong&gt;难道KPI就不能使用了吗？&lt;/strong&gt;当然不是了，只是索尼公司没有正确使用它。&lt;/p&gt;
&lt;p&gt;同一时期，三星的李健熙认为“奖励工资”是人类最伟大的发明，于是，他决定在三星集团内，打破传统，推行年薪制。三星集团各子公司的CEO，基本工资只占25%，其余的75%由绩效来决定。三星的绩效管理，极大地激励了管理层和员工。同样在2006年，三星电子超额利润达到2.52亿美元，当年提取用于员工分配的奖金就高达5040万美元。&lt;/p&gt;
&lt;p&gt;除了成就三星，绩效管理还成就了IBM。郭士纳接任IBM的CEO后，一个重要的举措，就是把沃森父子的“家庭文化”，改造为“绩效文化”。郭士纳帮助IBM这只大象重新起舞，成为了商界的传奇。&lt;/p&gt;

&lt;p&gt;那为什么索尼失败了呢？其实，&lt;strong&gt;索尼的问题不在于“绩效管理”，而在于“绩效管理”之前的“目标管理”，是把员工锁死在错误目标上的管理层。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;作为管理者，在用“绩效管理”锁死目标之前，&lt;strong&gt;第一重要的事情是，想想自己锁对了目标没有。&lt;/strong&gt;你可以把“目标管理”，看成是“绩效管理”的一部分，也可以认为目标管理，先于绩效管理。如果说，我们需要一把同心锁，把员工和企业牢牢锁在一起，&lt;strong&gt;目标管理，是确保我们锁对了目标，绩效管理，就是确保我们锁死了目标&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;绩效管理和OKR的目标管理，是前行的两条腿，缺谁都会寸步难行。正确的做法是把企业的使命和任务，转化为经营目标，然后再用KPI、OKR等绩效管理工具，分解、执行、考核。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;四、&lt;/strong&gt;研发团队到底使用KPI还是OKR？&lt;/p&gt;
&lt;p&gt;“怎么解决工程师的绩效考核问题”，整个科技界都没有好办法。大家能想到的唯一办法，就是通过多方均衡，让主观打分，尽量接近客观。通过多人打分，让直属经理一个人的主观，接近多人评价的客观；通过更高级别组织对得分的再平衡，让小团队的主观，接近多团队均衡的客观。&lt;/p&gt;

&lt;p&gt;小米雷军：&lt;strong&gt;KPI早已跟不上时代，小米公司没有KPI，责任感驱动员工执行力&lt;/strong&gt;。那也仅仅是在创业期，而且你的故事还要讲得好；当你的企业进入了稳定期你还没有KPI的话，我觉得这是一件非常危险的事。&lt;/p&gt;
&lt;p&gt;我记得新浪对谷歌内部考核系统进行过相关报道，大概意思是：&lt;strong&gt;谷歌放弃了KPI，选择了OKR，是OKR帮助谷歌成为了一家伟大的公司&lt;/strong&gt;。但是你要知道，谷歌他是一家创新公司，一家技术驱动的公司，他需要员工走出舒适区，站得更高，看得更远，不断的突破自己的极限。&lt;/p&gt;

&lt;p&gt;所以，很难说KPI和OKR哪个好，他只是在不同的公司、不同的创业阶段有不同的使用方式，但他们一定是相互配合使用的。正如文章开始所说，OKR是指南针，要确实公司上下目标一致，而KPI是秒表，鞭策公司的前行。KPI绩效管理和OKR的目标管理，是前行的两条腿，缺谁都会寸步难行。正确的做法是&lt;strong&gt;把企业的使命和任务，转化为经营目标，然后再用KPI、OKR等绩效管理工具，分解、执行、考核。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐阅读：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、&lt;a href=&quot;https://www.cnblogs.com/hunttown/p/10880022.html&quot; target=&quot;_blank&quot;&gt;绩效主义毁了索尼&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2、&lt;a href=&quot;https://mp.weixin.qq.com/s/PXfOKmKvB4lNvXBZ8gL_VA&quot; target=&quot;_blank&quot;&gt;一切不行都是人的不行？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3、&lt;a href=&quot;https://mp.weixin.qq.com/s/PWtlKz2M3sanWW8XvEVONQ&quot; target=&quot;_blank&quot;&gt;不会把目标翻译成任务要你何用？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4、&lt;a href=&quot;https://mp.weixin.qq.com/s/-zHn3qiXE7wKr3uRck7qdA&quot; target=&quot;_blank&quot;&gt;为什么不能用工时来考核研发的工作&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 17 May 2019 09:03:00 +0000</pubDate>
<dc:creator>猎手家园</dc:creator>
<og:description>在讨论之前我们先来了解两个概念： 一、KPI KPI是一套绩效管理的方法。全称为：Key Performance Indicator。中文叫：关键绩效指标。 KPI，和我们的“任务分解”不同。任务分解</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hunttown/p/10882308.html</dc:identifier>
</item>
<item>
<title>是时候拥有一个你自己的命令行工具了 - detectiveHLH</title>
<link>http://www.cnblogs.com/detectiveHLH/p/10881963.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/detectiveHLH/p/10881963.html</guid>
<description>&lt;p&gt;本篇博客主要介绍了如何使用commander, inquirer以及chalk从零开始，创建属于自己的命令行工具。&lt;/p&gt;
&lt;h2 id=&quot;一分钟体验&quot;&gt;0. 一分钟体验&lt;/h2&gt;
&lt;p&gt;首先我们先花一分钟的时间，体验一下创建自己的命令行cli工具是什么感觉。&lt;/p&gt;
&lt;h3 id=&quot;新建项目目录&quot;&gt;0.1. 新建项目目录&lt;/h3&gt;
&lt;p&gt;假如我们的项目名称叫&lt;code&gt;hello-cli&lt;/code&gt;，使用如下命令新建项目目录。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;mkdir hello-cli &amp;amp;&amp;amp; cd hello-cli&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;初始化项目&quot;&gt;0.2. 初始化项目&lt;/h3&gt;
&lt;p&gt;接下里使用npm-init命令来初始化一个简单的package.json文件。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;npm init -y&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;-y&lt;/code&gt;命令表示接受npm的一切默认参数设置。然后替换package.json为如下代码。&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
  &quot;name&quot;: &quot;hello-cli&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;bin&quot;: {
    &quot;hello&quot;: &quot;hello&quot;
  },
  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;amp;&amp;amp; exit 1&quot;
  },
  &quot;keywords&quot;: [],
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;,
  &quot;dependencies&quot;: {
    &quot;chalk&quot;: &quot;^2.4.2&quot;,
    &quot;commander&quot;: &quot;^2.20.0&quot;,
    &quot;inquirer&quot;: &quot;^6.3.1&quot;,
    &quot;shelljs&quot;: &quot;^0.8.3&quot;
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后使用&lt;code&gt;npm install&lt;/code&gt;安装依赖。&lt;/p&gt;
&lt;h3 id=&quot;新建入口文件&quot;&gt;0.3. 新建入口文件&lt;/h3&gt;
&lt;p&gt;在项目根目录下新建名为&lt;code&gt;hello&lt;/code&gt;的文件，不需要任何后缀，值得注意的是此时的文件名就是你的cli工具第一个键入的命令，例如&lt;code&gt;npm install&lt;/code&gt;，那么&lt;code&gt;hello&lt;/code&gt;就等价于&lt;code&gt;npm&lt;/code&gt;。并将代码替换如下。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;#! /usr/bin/env node

const program = require('commander');
const inquirer = require('inquirer');
const chalk = require('chalk');

program
  .command('init')
  .alias('i')
  .description('初始化项目')
  .action(option =&amp;gt; {
    // 该对象用于存储所有与用户交互的数据
    let config = {
      // 假设我们需要用户自定义项目名称
      projectName: null
    };
    // 使用chalk打印美化的版本信息
    console.log(chalk.default.bold('hello v1.0.0'));

    // 用于存储所有的交互步骤，例如让用户输入项目名称就是其中一个步骤
    let promps = [];
    if (config.projectName === null) {
      promps.push({
        type: 'input',
        name: 'projectName',
        message: '请输入项目名称',
        validate: input =&amp;gt; {
          if (!input) {
            return '项目名称不能为空';
          }
          // 更新对象中属性的数据
          config.projectName = input;
          return true;
        }
      });
    }

    // 至此，与用户的所有交互均已完成，answers是收集到的用户所填的所有数据
    // 同时，这也是你开始操作的地方，这个cli工具的核心代码应该从这个地方开始
    inquirer.prompt(promps).then(async (answers) =&amp;gt; {
      // do something here
      console.log(answers);
    });
  });

program.parse(process.argv);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;npm-link&quot;&gt;0.4. npm link&lt;/h3&gt;
&lt;p&gt;那么问题来了，&lt;br/&gt;在你的项目根目录下使用&lt;code&gt;npm link&lt;/code&gt;，然后在你本地上就相当于安装了名为&lt;code&gt;hello-cli&lt;/code&gt;这样的一个全局npm包了。其原理是将你本地的项目在全局的node_modules中做了一个软链接，拿此项目举例，全局的&lt;code&gt;hello&lt;/code&gt;命令已经指向了你的本地目录。如果你想取消测试项目在全局中的映射，同样的进入项根目录，输入命令&lt;code&gt;npm unlink&lt;/code&gt;即可。&lt;/p&gt;
&lt;p&gt;然后搭配以下命令食用你的第一个cli工具吧。如果报错提示没有权限，在命令前加上sudo即可。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;hello init
# 或者
# hello i&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;commander&quot;&gt;1. commander&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/tj/commander.js&quot;&gt;commander&lt;/a&gt;是一个Node.js环境下的命令行接口解决方案。在上面的一分钟体验例子中，我们用到了&lt;code&gt;command&lt;/code&gt;,&lt;code&gt;alias&lt;/code&gt;,&lt;code&gt;description&lt;/code&gt;,&lt;code&gt;action&lt;/code&gt;这四个API。&lt;/p&gt;
&lt;ul readability=&quot;4&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;command &lt;code&gt;command&lt;/code&gt;代表了这个cli工具向用户暴露的命令行指令。我们还是拿&lt;code&gt;npm install&lt;/code&gt;来举例子，&lt;code&gt;command('init')&lt;/code&gt;声明了一个叫init的命令，在此处，init等价于install&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;alias &lt;code&gt;alias&lt;/code&gt;是对于当前命令行指令的更短的指令。例如大家都知道，&lt;code&gt;npm install&lt;/code&gt;可以简写为&lt;code&gt;npm i&lt;/code&gt;。&lt;code&gt;i&lt;/code&gt;就是定义的alias&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;description &lt;code&gt;description&lt;/code&gt;是对当前命令行指令的描述，commander会自动的生成当前cli工具的帮助文档，而该描述就会在&lt;code&gt;hello -h&lt;/code&gt;中展示，如果你的一分钟体验项目还在的话，在命令行中输入&lt;code&gt;hello -h&lt;/code&gt;就可以看到自动生成的帮助文档了&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;action &lt;code&gt;action&lt;/code&gt;是我们注册我们自己回调函数的地方&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;parse &lt;code&gt;parse&lt;/code&gt;命令则是解析命令行&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面是一分钟体验项目中没有使用的命令，option。还是举一个例子。如果有用过&lt;a href=&quot;https://hexo.io/zh-cn/index.html&quot;&gt;hexo&lt;/a&gt;的应该熟悉这个命令。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;hexo new post $YOUR_POST_NAME&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;没用过也没关系，这个命令是用于创建一个可以自定义名字的Markdown的文档的。大家可能会发现，上面的命令包含了4个单词，而我们的例子中只有两个。那是因为一分钟项目中没有使用commander的&lt;code&gt;option&lt;/code&gt;API。&lt;/p&gt;
&lt;p&gt;如果你想在hello项目中实现一样的命令，那么只需要在program中调用该API即可。&lt;code&gt;.option('-p, --post', 'add post')&lt;/code&gt;，然后就可以通过&lt;code&gt;option&lt;/code&gt;参数获取到-p后面，用户输入的参数的值。&lt;/p&gt;
&lt;h2 id=&quot;inquirer&quot;&gt;2. inquirer&lt;/h2&gt;
&lt;p&gt;大家也发现了，在命令行输入init命令后，我们需要不停地与命令行进行交互拿到数据，但是在代码里并没有怎么体现，这是因为我们用了&lt;a href=&quot;https://github.com/SBoudrias/Inquirer.js/&quot;&gt;inquirer&lt;/a&gt;来帮我们做这些事情。&lt;/p&gt;
&lt;p&gt;通过inquirer，我们可以实现输入框，获取用户的输入数据，还可以实现选择框。举个例子，用过antd-design-pro应该熟悉创建项目的流程。在命令行中输入命令&lt;code&gt;yarn create umi&lt;/code&gt;，在之后的流程中就会出现一个可选择的list。只需要将步骤中的代码替换成如下即可。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;promps.push({
    type: 'list',
    name: 'projectName',
    message: '请输入项目名称',
    choices: [
      {
        name: 'ant-design-pro',
        value: 'ant-design-pro'
      },
      {
        name: 'dva',
        value: 'dva'
      }
    ]
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在项目中，还使用了&lt;code&gt;validate&lt;/code&gt;来对用户的输入数据进行验证，如果不需要验证的话，直接把validate整个代码删除掉就好。&lt;/p&gt;
&lt;h2 id=&quot;chalk&quot;&gt;3. chalk&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chalk/chalk&quot;&gt;chalk&lt;/a&gt;没有什么好介绍的，官网上的文档已经写的很详细了。给大家列一下项目中使用的例子就好。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// 使用默认的字体颜色，加粗字体
console.log(chalk.default.bold('hello v1.0.0'));
// 打印蓝色的提示信息
console.log(chalk.blue('hello v1.0.0'));
// 字符串模板用法，在同一行中打印不同样式的信息
console.log(chalk`{white.bold [1/3]} 🔍` + chalk`{default.bold Clone project into local path...}`);&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;最后&quot;&gt;4. 最后&lt;/h2&gt;
&lt;p&gt;如果你厌倦了Node.js写后端，想用Java的Spring Boot来写，但是又担心环境的搭建浪费太多时间。那么你可以试试&lt;a href=&quot;https://github.com/detectiveHLH/venus-init&quot;&gt;venus-init&lt;/a&gt;，只需要一行命令便可以快速搭建Java的开发环境。&lt;/p&gt;
&lt;p&gt;Happy hacking.&lt;/p&gt;
</description>
<pubDate>Fri, 17 May 2019 08:21:00 +0000</pubDate>
<dc:creator>detectiveHLH</dc:creator>
<og:description>本篇博客主要介绍了如何使用commander, inquirer以及chalk从零开始，创建属于自己的命令行工具。 0. 一分钟体验 首先我们先花一分钟的时间，体验一下创建自己的命令行cli工具是什么</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/detectiveHLH/p/10881963.html</dc:identifier>
</item>
</channel>
</rss>