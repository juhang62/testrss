<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>程序员跳槽到对手公司，被前老板设计陷害 - 锋哥程序十年</title>
<link>http://www.cnblogs.com/bianchengniuren/p/10233171.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bianchengniuren/p/10233171.html</guid>
<description>&lt;p&gt;这件事发生在2007年，我就职的第一家公司。今天把它整理写出来，希望它对程序员有一个警醒的作用。永远要记住，程序员的世界除了有代码，还有被套路。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;资深工程师的苦恼&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;第一天到公司，是浩子带着我办理了入职手续。浩子是公司里的骨干工程师，对公司的业务非常熟悉，同时在软件研发方面有非常深的造诣。公司的人员流动比较大，浩子是那种很能沉得住气的人，慢慢地在行业里面都小有名气。&lt;/p&gt;
&lt;p&gt;浩子曾经指导我的一句话，到现在依然对我帮助很大。浩子说：“在公司里，不要光顾眼前，要想想你来年想要得到什么样的报酬，然后现在需要付出怎么样的努力才能拿到那个报酬。”&lt;/p&gt;
&lt;p&gt;浩子其实在公司里的地位也很尴尬。上面有经理压着，升又升不上去。以浩子的能力和资历，在其他公司应该早就进入管理层了。所谓的资深工程师，只是一个名号，手里没有资源做不了多大的事情。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;对手公司来挖，工资给双倍&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为是浩子带我，所以和我的关系不错。一天下班后，浩子找我去喝酒。浩子说，这次是要辞行的。因为是找到了新的公司，工资是现在的双倍。我知道那时候浩子的工资是6K左右，双倍的话就是12K。针对当时深圳的房价在8K左右，这个工资已经算可以了。&lt;/p&gt;
&lt;p&gt;浩子去和公司谈的时候，公司提出挽留。但是当浩子提出工资翻倍的要求之后，公司毫不犹豫的拒绝了。其实也能理解，有几家公司有这个气魄一下子给员工工资翻倍？我问浩子去哪家公司，浩子闭口不谈。我隐隐觉得这里面有些不方便透露的秘密。&lt;/p&gt;
&lt;p&gt;浩子走了之后，前方市场很快传来消息。浩子果然跳槽到了对手的公司，在技术上给公司制造了很大的竞争。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;江湖有多大，套路就有多深&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;大约半个月之后，浩子突然找我，告诉我他失业了。一问，原来浩子去了对手公司之后，公司老板指使客户去挖浩子。工资根据浩子的要求给到了16K。浩子不知是计，欣然答应。于是浩子从对手公司辞职，打算加盟原公司客户。当浩子拿着离职证明到客户的公司那里上班，给客户找了个理由，拒绝了。浩子说，当时他就傻眼了。就这样，浩子失业了。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;程序员怎么避免离职套路 &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;首先，员工和公司基本上就是一盘生意。商人无利不起早，你要是真把公司当家，那就真的是太单纯了。决定要离职之后，有几条守则必须遵守：&lt;/p&gt;
&lt;p&gt;1.好马不吃回头草，既然提出了辞职，就要坚决走人。无论老板给多少钱，坚决不能留下。&lt;/p&gt;
&lt;p&gt;2.不要相信天上能掉下来免费的馅饼。要想明白自己能给公司创造什么样的价值，只有在给公司创造价值的基础上，公司才会付你相应的报酬。&lt;/p&gt;
&lt;p&gt;3.适当的时候，要敢于用法律的武器保护自己。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;后记&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;以上发生的事情，虽然已经过了十来年，却依然历历在目。十年时间好短，一转眼就过去了。我从上一家辞职出来创业，已经4个月又27天，也经常在我的微信公众号《编程牛人》上分享自己的经验。曾经创业失败过两次，内心有很多经验想和大家分享，后续会陆续总结分享给大家。觉得写得好的，记得给个赞，谢谢大家。&lt;/p&gt;
</description>
<pubDate>Mon, 07 Jan 2019 07:32:00 +0000</pubDate>
<dc:creator>锋哥程序十年</dc:creator>
<og:description>这件事发生在2007年，我就职的第一家公司。今天把它整理写出来，希望它对程序员有一个警醒的作用。永远要记住，程序员的世界除了有代码，还有被套路。 资深工程师的苦恼 第一天到公司，是浩子带着我办理了入职</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bianchengniuren/p/10233171.html</dc:identifier>
</item>
<item>
<title>红黑树的删除 - MichaelCen</title>
<link>http://www.cnblogs.com/mcomco/p/10213468.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mcomco/p/10213468.html</guid>
<description>&lt;h2&gt;1.前文回顾&lt;/h2&gt;
&lt;p&gt;　　上一篇随笔写到了红黑树的实现及其各种功能的实现，本文将讲红黑树的删除。&lt;/p&gt;
&lt;p&gt;　　上一篇随笔提到了二叉搜索树的删除功能在红黑树中虽然可以用，但会破坏红黑树的结构。&lt;/p&gt;
&lt;p&gt;　　其实红黑树的删除功能是在二叉搜索树的删除功能上加上了重构结构的功能。因此，如果不熟悉二叉搜索树的删除功能和红黑树的，建议先看&lt;a href=&quot;https://www.cnblogs.com/mcomco/p/10184033.html&quot; target=&quot;_blank&quot;&gt;二叉搜索树&lt;/a&gt;和&lt;a href=&quot;https://www.cnblogs.com/mcomco/p/10195046.html&quot; target=&quot;_blank&quot;&gt;红黑树&lt;/a&gt;。&lt;/p&gt;

&lt;h2&gt;2.红黑树的特性&lt;/h2&gt;
&lt;p&gt;　　在讲删除前，有必要先讲下红黑树的特性。因为我们删除节点后，红黑树的特性应该继续有效。&lt;/p&gt;
&lt;p&gt;　　算法导论的原话：&lt;/p&gt;
&lt;p&gt;　　1. Every node is either red or black.（每个节点不是红色就是黑色）&lt;/p&gt;
&lt;p&gt;　　2. The root is black.（根节点是黑色的）&lt;/p&gt;
&lt;p&gt;　　3. Every leaf (NIL) is black.（每个空的节点都是黑色的）&lt;/p&gt;
&lt;p&gt;　　4. If a node is red, then both its children are black.（红色节点的子节点都是黑色的）&lt;/p&gt;
&lt;p&gt;　　5. For each node, all simple paths from the node to descendant leaves contain the same number of black nodes.（任意节点到它的子孙节点的路径上，含有的黑节点数目相同）&lt;/p&gt;
&lt;p&gt;　　前四条很容易理解，关键是第五条。举个例子：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1534783/201901/1534783-20190103153727091-1583687931.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　节点19到节点1,5,14,20,30,35的路径都经过了2个黑色节点（不算节点19自己）。&lt;/p&gt;

&lt;h2&gt;3.删除节点的种类&lt;/h2&gt;
&lt;p&gt;　　节点可能有0个子节点、1个子节点、2个子节点，再加上节点可分为红色节点和黑色节点，因此总共有6种节点。&lt;/p&gt;
&lt;p&gt;　　a. 黑色节点，没子节点。&lt;/p&gt;
&lt;p&gt;　　b. 黑色节点，1个子节点。&lt;/p&gt;
&lt;p&gt;　　c. 黑色节点，2个子节点。&lt;/p&gt;
&lt;p&gt;　　d. 红色节点，没子节点。&lt;/p&gt;
&lt;p&gt;　　e. 红色节点，1个子节点。&lt;/p&gt;
&lt;p&gt;　　f.  红色节点，2个子节点。&lt;/p&gt;
&lt;p&gt;　　但是，在红黑树中，e情况不可能出现，因为要使父节点变为红色，只能通过颜色反转来实现。&lt;/p&gt;
&lt;p&gt;　　b情况中，该子节点只能是红色，否则不满足性质5。&lt;/p&gt;
&lt;p&gt;　　假设e情况存在，看下图：（由于实际情况下，e情况不可能出现，下面是强行造成e情况存在，故这个红黑树是错误的，不满足性质5：任意节点到它的子孙节点的路径上，含有的黑节点数目相同）&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1534783/201901/1534783-20190103114250218-1792680445.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　我们把目光注视到节点25，这是一个e情况。试想节点20是怎么来的：要么是在节点25之后插入的新节点；要么是删除了节点25的右节点。&lt;/p&gt;
&lt;p&gt;　　但是，在即将介绍的删除方法中，不会造成删除了节点25的右节点后，红色节点25只有一个左节点20的情况。　　&lt;/p&gt;
&lt;p&gt;　　那么节点20只能是在节点25之后插入的新节点，但是新节点都是红色的，插入时，会变成下图：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1534783/201901/1534783-20190103114735351-1162000408.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这样会触发右旋，随后再触发颜色反转、左旋。如下图：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1534783/201901/1534783-20190103152636176-1871198568.png&quot; alt=&quot;&quot;/&gt;（由于实际情况下，e情况不可能出现，这里是强行造成e情况存在，故这个红黑树是错误的，不满足性质5：任意节点到它的子孙节点的路径上，含有的黑节点数目相同）&lt;/p&gt;
&lt;p&gt;　　因此，在节点25之后插入的新节点20，并不会造成红色节点25只有一个左节点20的情况。故，e情况（e. 红色节点，1个子节点。）不可能出现在红黑树中。&lt;/p&gt;
&lt;p&gt;　　请看节点34，这是黑色节点只含有一个黑色子节点的情况。从根节点25到34的左空节点经过了1个黑色节点；从根节点25到节点35经过了2个黑色节点，故不满足性质5，黑色节点只含有一个黑色子节点的情况在红黑树中不存在。&lt;/p&gt;
&lt;p&gt;　　综上所述，我们只需要处理的情况有5种：　&lt;/p&gt;
&lt;p&gt;　　a. 黑色节点，没子节点。&lt;/p&gt;
&lt;p&gt;　　b. 黑色节点，1个红色子节点。&lt;/p&gt;
&lt;p&gt;　　c. 黑色节点，2个子节点。&lt;/p&gt;
&lt;p&gt;　　d. 红色节点，没子节点。&lt;/p&gt;
&lt;p&gt;　　f.  红色节点，2个子节点。&lt;/p&gt;

&lt;h2&gt; 4.删除节点时的各种情况讨论&lt;/h2&gt;

&lt;h3&gt;一、节点有两个子节点时&lt;/h3&gt;
&lt;p&gt;　　先讨论情况c和f，即节点有两个子节点。&lt;/p&gt;
&lt;p&gt;　　假设要删除节点X，按照二叉搜索树的删除方法，寻找X的后驱继承节点Y。然后除了颜色不变之外，互换X和Y的位置。此时X节点只有一个或没有节点，继续删除它。具体删除方法请看a、b、d情况的删除。&lt;/p&gt;
&lt;p&gt;　　举个例子，如下图：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1534783/201901/1534783-20190103153727091-1583687931.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　假设要删除节点4，则节点5是节点4的后驱继承者。（节点4的右节点中的最小节点。）交换节点5和4，节点颜色不变，如下图：(X=4)&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1534783/201901/1534783-20190103154735248-148158242.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　继续删除X。此时X是没有子节点的黑色节点，适用于情况a（a. 黑色节点，没子节点。）的删除，下文即将介绍。&lt;/p&gt;

&lt;h3&gt;二、节点是红色，且没子节点时&lt;/h3&gt;
&lt;p&gt;　　要讨论的是情况 d. 红色节点，没子节点。直接删除即可。&lt;/p&gt;
&lt;p&gt;　　举个例子：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1534783/201901/1534783-20190103153727091-1583687931.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　如果要删除节点1，节点1属于情况d. 红色节点，没子节点。直接删除，红黑树仍遵守所有特性。&lt;/p&gt;

&lt;h3&gt;三、节点是黑色，且只有一个红色子节点时&lt;/h3&gt;
&lt;p&gt;　　要讨论的是情况b（黑色节点，1个红色子节点）。&lt;/p&gt;
&lt;p&gt;　　从例子入手：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1534783/201901/1534783-20190103153727091-1583687931.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　现在要删除节点2。节点2有一个红色节点，直接删除节点2，节点1补上节点2的位置，并且节点1的颜色变为黑色。&lt;/p&gt;
&lt;p&gt;　　如下图：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1534783/201901/1534783-20190103162813320-2052256534.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　即如果要删除含有一个红色子节点的黑色节点，直接删除黑色节点，红色子节点补位，且变为黑色节点。&lt;/p&gt;

&lt;h3&gt;四、节点是黑色，且没有子节点时&lt;/h3&gt;
&lt;p&gt;　　要讨论的是情况 a. 黑色节点，没子节点。&lt;/p&gt;
&lt;p&gt;　　这里引入一个新节点双重黑色节点（double black），图中用矩形来代表，如下图：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1534783/201901/1534783-20190103163110186-1973981134.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　节点1为双重黑色节点，双重黑色节点不能存在于红黑树中，我们需要把它变回黑色节点，这样红色树才成立。&lt;/p&gt;
&lt;p&gt;　　首先，双重黑色节点怎么产生：当我们要删除一个没有子节点的黑色节点时，就会产生一个双重黑色空节点，且补到删除节点的位置。（还有一种产生方法是在消除双重黑色节点的过程中出现的，稍后介绍。）&lt;/p&gt;
&lt;p&gt; 　　举个例子：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1534783/201901/1534783-20190103162813320-2052256534.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　现在删除节点1，由于节点1是没有子节点的黑色节点，故产生一个双重黑色空节点。如下图：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1534783/201901/1534783-20190103164823874-1996647482.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　然后，我们接下来讲如何消除双重黑色节点。&lt;/p&gt;
&lt;h4&gt;消除公式：&lt;/h4&gt;
&lt;p&gt;　　黑色节点=双重黑色节点+红色节点&lt;/p&gt;

&lt;p&gt;　　先介绍邻居节点：假设节点a的两个子节点为节点b和节点c，则节点b是节点c的邻居节点；节点c是节点b的邻居节点&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1534783/201901/1534783-20190103171200252-2106387124.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　如上图，节点10的邻居节点是节点25;节点25的邻居节点是节点10。&lt;/p&gt;
&lt;p&gt;　　双重黑色节点出现时，可能面临的情况有：&lt;/p&gt;
&lt;p&gt;　　情况1：双重黑色节点的邻居节点是黑色节点，且此邻居节点有一个红色子节点时（最多只能有一个红色子节点，如果有两个，则会触发反转颜色。）&lt;/p&gt;
&lt;p&gt;　　情况2：双重黑色节点的邻居节点是黑色节点，且此邻居节点有两个黑色子节点或黑色空子节点时（根据性质5，邻居节点不可能有黑色子节点。因为变成双重黑色节点前，它肯定是一个黑色节点，邻居节点也是黑色节点，如果邻居节点有黑色子节点，则会违反性质5。）&lt;/p&gt;
&lt;p&gt;　　情况3：双重黑色节点的邻居节点是红色节点时&lt;/p&gt;
&lt;p&gt;　　情况4：双重黑色节点是根节点，没有邻居节点时（如果双重黑色节点不是根节点，不可能没有邻居节点。因为变成双重黑色节点前，它肯定是一个黑色节点，根据性质5，它邻居节点要么是黑色节点，要么是含有两个黑色子节点的红色节点。）&lt;/p&gt;

&lt;h4&gt;下面将根据各种情况来消除双重黑色节点&lt;/h4&gt;
&lt;h5&gt;情况1：双重黑色节点的邻居节点是黑色节点，且有一个红色子节点时&lt;/h5&gt;
&lt;p&gt;　　双重黑色节点的邻居节点是黑色节点，且有一个红色子节点的情况如下图：（我们这里的红黑树所有的红色联系都是向左的，所以红色子节点一定为左子节点）&lt;/p&gt;
&lt;p&gt;　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1534783/201901/1534783-20190103172603347-32525267.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　根据性质5，节点a只能是空节点，节点25只有一个子节点。&lt;/p&gt;
&lt;p&gt;　　先对节点23和25进行右旋：&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1534783/201901/1534783-20190103173748562-913486187.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　然后对节点20和23进行左旋，红色节点25变为黑色节点，双重黑色空节点变为黑色空节点：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1534783/201901/1534783-20190103174025182-1228201435.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　消除完毕。&lt;/p&gt;
&lt;p&gt;　　上述为邻居节点为右节点时的情形。当邻居节点是左节点时，看下图：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1534783/201901/1534783-20190107095114963-943160170.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　对15,13进行右旋，红色节点10变为黑色节点，双重黑色空节点变为黑色空节点：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1534783/201901/1534783-20190107095322993-1242938032.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　消除完毕。&lt;/p&gt;

&lt;h5&gt;情况2：双重黑色节点的邻居节点是黑色节点，且有两个黑色空子节点时&lt;/h5&gt;
&lt;h4&gt;当父节点为红色节点时：&lt;/h4&gt;
&lt;p&gt;　　如下图：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1534783/201901/1534783-20190103164823874-1996647482.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　请看红色节点4，如果这个节点是反转颜色而来的，那么反转颜色之前是什么样子的呢？&lt;/p&gt;
&lt;p&gt;　　逆反转颜色：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1534783/201901/1534783-20190103170401171-1433488651.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这个时候，双重黑色空节点和红色节点重合，相加得黑节点：（黑色节点=双重黑色节点+红色节点）&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1534783/201901/1534783-20190103170531662-388371657.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　消除完成，触发左旋：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1534783/201901/1534783-20190104093516693-211712753.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;当父节点为黑色节点时：&lt;/h4&gt;
&lt;p&gt;　　如下图：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1534783/201901/1534783-20190104094053572-1487179159.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　黑色节点=双重黑色节点+红色节点　　&lt;/p&gt;
&lt;p&gt;　　黑色节点5可以看作是双重黑色节点和红色节点的结合体：（这里会产生一个双重黑色节点）&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1534783/201901/1534783-20190104094526102-424778678.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　然后逆反转颜色：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1534783/201901/1534783-20190104094619100-421823694.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　然后双重黑色空节点就消除了。&lt;/p&gt;
&lt;p&gt; 　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1534783/201901/1534783-20190104095026605-1584713868.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　 新产生的黑色节点需要根据邻居节点的情况进一步消除。（这里邻居节点的情况是双重黑色节点的邻居节点是黑色节点，且有两个黑色子节点或黑色空子节点，且父节点为红色节点时）&lt;/p&gt;

&lt;h5&gt;情况3：双重黑色节点的邻居节点是红色节点时&lt;/h5&gt;
&lt;p&gt;　　这个红色节点肯定是有两个黑色子节点或黑色空子节点。且此红色节点肯定是左节点。（因为在此红黑树中，所有红色节点的都是左节点。）&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1534783/201901/1534783-20190104100154291-1893788390.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　节点a,b可能同时为黑色非空节点，也可能是同时为黑色空节点。&lt;/p&gt;
&lt;p&gt;　　对节点5和11进行右旋：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1534783/201901/1534783-20190104100310684-179606064.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　然后逆反转颜色和消除：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1534783/201901/1534783-20190104100425151-1300462174.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1534783/201901/1534783-20190104100443077-1265021755.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　消除完毕。&lt;/p&gt;

&lt;h5&gt;情况4：双重黑色节点是根节点，没有邻居节点时&lt;/h5&gt;
&lt;p&gt; 　　看下图演变过程：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1534783/201901/1534783-20190104101011620-401292008.png&quot; alt=&quot;&quot;/&gt;删除节点20 &lt;img src=&quot;https://img2018.cnblogs.com/blog/1534783/201901/1534783-20190104101042116-350092519.png&quot; alt=&quot;&quot;/&gt;双重黑色空节点邻居节点为黑色，且没子节点，消除双重黑色空节点&lt;img src=&quot;https://img2018.cnblogs.com/blog/1534783/201901/1534783-20190104101141978-1828420366.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　如果双重黑节点是根节点，直接变成黑色节点即可：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1534783/201901/1534783-20190104101232578-1182652019.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　触发左旋：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1534783/201901/1534783-20190104103741673-242315999.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　至此，所有情况讨论完毕，红黑树删除节点完成。&lt;/p&gt;
&lt;p&gt;　　参考文章：&lt;a href=&quot;https://www.geeksforgeeks.org/red-black-tree-set-3-delete-2/&quot; target=&quot;_blank&quot;&gt;https://www.geeksforgeeks.org/red-black-tree-set-3-delete-2/&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;5.完整代码&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;121&quot;&gt;
&lt;pre&gt;
&lt;span&gt;节点.h:

UCLASS()
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; ALGORITHM_API ARedBlackNode : &lt;span&gt;public&lt;/span&gt;&lt;span&gt; AActor
{
    GENERATED_BODY()
    
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Sets default values for this actor's properties&lt;/span&gt;
&lt;span&gt;    ARedBlackNode();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Called every frame&lt;/span&gt;
    &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Tick(&lt;span&gt;float&lt;/span&gt; DeltaTime) &lt;span&gt;override&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设值&lt;/span&gt;
    FORCEINLINE &lt;span&gt;void&lt;/span&gt; SetValue(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; Newkey, FString NewValue)
    {
        Key &lt;/span&gt;=&lt;span&gt; Newkey;
        Value &lt;/span&gt;=&lt;span&gt; NewValue;
    }

    FORCEINLINE ARedBlackNode&lt;/span&gt;* Get() { &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取或修改私有变量&lt;/span&gt;
    FORCEINLINE &lt;span&gt;int&lt;/span&gt; GetKey() { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Key; }
    FORCEINLINE &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; SetKey(&lt;span&gt;int&lt;/span&gt; NewKey) { Key =&lt;span&gt; NewKey; }
    FORCEINLINE &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; GetCount() { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Count; }
    FORCEINLINE &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; SetCount(&lt;span&gt;int&lt;/span&gt; NewCount) { Count =&lt;span&gt; NewCount; }
    FORCEINLINE FString GetValue() { &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Value; }
    FORCEINLINE &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; SetValue(FString NewValue) { Value =&lt;span&gt; NewValue; }
    FORCEINLINE &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; GetColor() { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Color; }
    FORCEINLINE &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; SetColor(&lt;span&gt;bool&lt;/span&gt; IsRed) { Color =&lt;span&gt; IsRed; }
    FORCEINLINE ARedBlackNode&lt;/span&gt;* GetParent() { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Parent; }
    FORCEINLINE &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; SetParent(ARedBlackNode* X) { Parent =&lt;span&gt; X; }
    FORCEINLINE ARedBlackNode&lt;/span&gt;* GetNode(&lt;span&gt;bool&lt;/span&gt;&lt;span&gt; Left)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (Left) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; LeftNode;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; RightNode;
    }
    FORCEINLINE &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; SetNode(&lt;span&gt;bool&lt;/span&gt; Left, ARedBlackNode*&lt;span&gt; NewNode)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设定父节点&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (NewNode)  NewNode-&amp;gt;SetParent(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (Left)  LeftNode =&lt;span&gt; NewNode;
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; RightNode =&lt;span&gt; NewNode;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取邻居节点，用于删除&lt;/span&gt;
    FORCEINLINE ARedBlackNode*&lt;span&gt; GetSibling()
    { 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果没父节点，则没邻居节点&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (!Parent) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; nullptr;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果这个节点是父节点的左节点，则邻居节点是父节点的右节点&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt; == Parent-&amp;gt;GetNode(&lt;span&gt;true&lt;/span&gt;)) &lt;span&gt;return&lt;/span&gt; Parent-&amp;gt;GetNode(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;反之则邻居节点是父节点的左节点&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt; &lt;span&gt;return&lt;/span&gt; Parent-&amp;gt;GetNode(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个节点有没红色子节点&lt;/span&gt;
    FORCEINLINE &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; HasRedChild() 
    { 
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (LeftNode &amp;amp;&amp;amp; LeftNode-&amp;gt;GetColor() == &lt;span&gt;true&lt;/span&gt;) ||&lt;span&gt;
            (RightNode &lt;/span&gt;&amp;amp;&amp;amp; RightNode-&amp;gt;GetColor() == &lt;span&gt;true&lt;/span&gt;&lt;span&gt;) ;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个节点是左子节点？&lt;/span&gt;
    FORCEINLINE &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; IsOnLeft()
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!Parent) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt; == Parent-&amp;gt;GetNode(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
    }

&lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Called when the game starts or when spawned&lt;/span&gt;
    &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BeginPlay() &lt;span&gt;override&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; Key;
    FString Value;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;左右节点&lt;/span&gt;
    ARedBlackNode*&lt;span&gt; LeftNode;
    ARedBlackNode&lt;/span&gt;*&lt;span&gt; RightNode;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;父节点，这个节点是为了记录每个节点的位置（用于测试程序是否正确建立红黑树），与红黑树的实现无关。&lt;/span&gt;
    ARedBlackNode*&lt;span&gt; Parent;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算此节点下面共有多少个节点（包括自己）&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt;&lt;span&gt; Count;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;与父节点之间的联系，如果为True,则是红色的；如果为False,则是黑色的&lt;/span&gt;
    &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; Color;
    
};

红黑树.h:

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; ARedBlackNode;

UCLASS()
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; ALGORITHM_API ARedBlackBST : &lt;span&gt;public&lt;/span&gt;&lt;span&gt; AActor
{
    GENERATED_BODY()
    
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Sets default values for this actor's properties&lt;/span&gt;
&lt;span&gt;    ARedBlackBST();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Called every frame&lt;/span&gt;
    &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Tick(&lt;span&gt;float&lt;/span&gt; DeltaTime) &lt;span&gt;override&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断一个节点和它父节点的联系是否是红色的&lt;/span&gt;
    &lt;span&gt;bool&lt;/span&gt; IsRed(ARedBlackNode*&lt;span&gt; X);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;查值&lt;/span&gt;
    FString GetValue(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; InputKey);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;提供一个方法让TreeNode之间进行比较
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果a大于b，返回1；如果a小于b，返回-1；如果相等，返回0&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; CompareTo(&lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; b);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;向左旋转
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;为什么要左旋：因为在红黑树中，所有红色的联系都是向左的。&lt;/span&gt;
    ARedBlackNode* RotateLeft(ARedBlackNode*&lt;span&gt; h);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;向右旋转
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;为什么要右旋：
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果出现连续两个红色联系时（即a,b,c是三个连续的节点，且ab，bc间的联系都是红色的),需要右旋一次
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;然后反转一次颜色，从而符合红黑树的游戏规则。&lt;/span&gt;
    ARedBlackNode* RotateRight(ARedBlackNode*&lt;span&gt; h);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;反转颜色：如果一个节点的左右联系都是红色，则将它们变为黑色，此节点与父节点的联系变为红色&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; FlipColors(ARedBlackNode*&lt;span&gt; h);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;插入一个节点&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; Put(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; Newkey);
    ARedBlackNode&lt;/span&gt;* Put(ARedBlackNode* h, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; NewKey);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;中序遍历&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; InorderTraversal();
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; Inorder(ARedBlackNode*&lt;span&gt; X);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;寻找最小值&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt;&lt;span&gt; FindMin();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;寻找拥有最小值的节点&lt;/span&gt;
    ARedBlackNode* FindMin(ARedBlackNode*&lt;span&gt; X);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;寻找最大值&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt;&lt;span&gt; FindMax();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;寻找拥有最大值的节点&lt;/span&gt;
    ARedBlackNode* FindMax(ARedBlackNode*&lt;span&gt; X);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;给定一个数字，寻找最接近它的key(比它小)&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; FindFloor(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; InputKey);
    ARedBlackNode&lt;/span&gt;* FindFloor(ARedBlackNode* X, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; InputKey);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;给定一个数字，寻找最接近它的key(比它大)&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; FindCeiling(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; InputKey);
    ARedBlackNode&lt;/span&gt;* FindCeiling(ARedBlackNode* X, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; InputKey);
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;求有多少个数字少于给定数字&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; Size(ARedBlackNode*&lt;span&gt; X);
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; Rank(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; InputKey);
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; Rank(&lt;span&gt;int&lt;/span&gt; InputKey, ARedBlackNode*&lt;span&gt; X);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;更新各节点路线(先进行层次排序，再更新路线)&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; UpdateRouteString();
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; UpdateRouteString(ARedBlackNode*&lt;span&gt; X);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用二叉搜索树删除的方法寻找继承节点(删除某个节点后，这个节点会补位)&lt;/span&gt;
    ARedBlackNode* BSTReplace(ARedBlackNode*&lt;span&gt; X);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;找后驱节点&lt;/span&gt;
    ARedBlackNode* Successor(ARedBlackNode*&lt;span&gt; X);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除某个节点&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; DeleteNode(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; InputKey);
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; DeleteNode(ARedBlackNode*&lt;span&gt; X);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;消除双重黑色节点&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; FixDoubleBlack(ARedBlackNode*&lt;span&gt; X);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;交换两个节点的值&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; SwapKey(ARedBlackNode* X, ARedBlackNode*&lt;span&gt; Y);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;更新所有父节点的节点数&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; UpdateParentsCount(ARedBlackNode*&lt;span&gt; X);

&lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Called when the game starts or when spawned&lt;/span&gt;
    &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BeginPlay() &lt;span&gt;override&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;:

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根节点&lt;/span&gt;
    ARedBlackNode*&lt;span&gt; RootNode;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;每个节点输入的值，可根据具体情况更改，这里只输入空格&lt;/span&gt;
&lt;span&gt;    FString FakeValue;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;把节点接过的路线记录下来，方便测试&lt;/span&gt;
&lt;span&gt;    FString RouteString;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;把节点按中序遍历放进数组&lt;/span&gt;
    TArray&amp;lt;ARedBlackNode*&amp;gt;&lt;span&gt; OrderNodeArray;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;把节点按层次遍历放进数组&lt;/span&gt;
    TArray&amp;lt;ARedBlackNode*&amp;gt;&lt;span&gt; LevelOrderNodeArray;
};

红黑树.cpp:

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果为True,则是红色的；如果为False,则是黑色的&lt;/span&gt;
&lt;span&gt;bool&lt;/span&gt; Red = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; Black = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Sets default values&lt;/span&gt;
&lt;span&gt;ARedBlackBST::ARedBlackBST()
{
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.&lt;/span&gt;
    PrimaryActorTick.bCanEverTick = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    FakeValue &lt;/span&gt;= &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Called when the game starts or when spawned&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; ARedBlackBST::BeginPlay()
{
    Super::BeginPlay();
    FRandomStream Stream;
    Stream.GenerateNewSeed();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;生成节点&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;1000&lt;/span&gt;; i++&lt;span&gt;)
    {
        Put(Stream.RandRange(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;&lt;span&gt;));
    }
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Put(40);&lt;/span&gt;
    Put(&lt;span&gt;19&lt;/span&gt;&lt;span&gt;);
    Put(&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;&lt;span&gt;);
    Put(&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;&lt;span&gt;);
    Put(&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;);
    Put(&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;&lt;span&gt;);
    Put(&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;);
    Put(&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;&lt;span&gt;);
    Put(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
    Put(&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;);
    Put(&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;&lt;span&gt;);
    Put(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    Put(&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;中序排列&lt;/span&gt;
&lt;span&gt;    InorderTraversal();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;观察搜索树是否排列正确&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; OrderNodeArray.Num(); i++&lt;span&gt;)
    {
        UKismetSystemLibrary::PrintString(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;, FString::FromInt(i) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
            + FString::FromInt(OrderNodeArray[i]-&amp;gt;GetKey())+&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;+ OrderNodeArray[i]-&amp;gt;&lt;span&gt;GetValue());
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;测试搜索和查值功能&lt;/span&gt;
    UKismetSystemLibrary::PrintString(&lt;span&gt;this&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Find 40: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + GetValue(&lt;span&gt;40&lt;/span&gt;&lt;span&gt;));
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;测试寻找最小值、最大值、Floor、Ceiling&lt;/span&gt;
    UKismetSystemLibrary::PrintString(&lt;span&gt;this&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Min: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + FString::FromInt(FindMin()) +
        &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; Max: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; FString::FromInt(FindMax()));
    UKismetSystemLibrary::PrintString(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Floor of 50: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + FString::FromInt(FindFloor(&lt;span&gt;50&lt;/span&gt;&lt;span&gt;)));
    UKismetSystemLibrary::PrintString(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Ceiling of 50: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + FString::FromInt(FindCeiling(&lt;span&gt;50&lt;/span&gt;&lt;span&gt;)));
    UKismetSystemLibrary::PrintString(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Rank(49): &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+FString::FromInt(Rank(&lt;span&gt;49&lt;/span&gt;&lt;span&gt;)));
    UpdateRouteString();
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; LevelOrderNodeArray.Num(); i++&lt;span&gt;)
    {
        FString Temp;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (LevelOrderNodeArray[i]-&amp;gt;GetColor()) Temp = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;red&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; Temp = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Black&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        
        UKismetSystemLibrary::PrintString(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;, FString::FromInt(i) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
            + FString::FromInt(LevelOrderNodeArray[i]-&amp;gt;GetKey()) + &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; + LevelOrderNodeArray[i]-&amp;gt;&lt;span&gt;GetValue()
            &lt;/span&gt;+ &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; Count: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + FString::FromInt(LevelOrderNodeArray[i]-&amp;gt;GetCount()) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; Color:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; Temp);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;if (LevelOrderNodeArray[i]-&amp;gt;GetKey() == 2)
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;{
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;测试寻找邻居节点和是否有红色子节点
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    UKismetSystemLibrary::PrintString(this, &quot;Sibling: &quot; + FString::FromInt(LevelOrderNodeArray[i]-&amp;gt;GetSibling()-&amp;gt;GetKey())
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        + &quot; HasRedChild: &quot; + UKismetStringLibrary::Conv_BoolToString(LevelOrderNodeArray[i]-&amp;gt;HasRedChild()));
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;测试寻找继承节点
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    if (BSTReplace(LevelOrderNodeArray[i]))
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        UKismetSystemLibrary::PrintString(this, FString::FromInt(BSTReplace(LevelOrderNodeArray[i])-&amp;gt;GetKey()));
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    else UKismetSystemLibrary::PrintString(this, &quot;BSTReplace Not Exist&quot;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;
&lt;span&gt;    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;测试删除&lt;/span&gt;
    UKismetSystemLibrary::PrintString(&lt;span&gt;this&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;StartDelete!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    DeleteNode(&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;&lt;span&gt;);
    DeleteNode(&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;&lt;span&gt;);
    DeleteNode(&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;);
    DeleteNode(&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;&lt;span&gt;);
    DeleteNode(&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;&lt;span&gt;);
    DeleteNode(RootNode);
    UpdateRouteString();
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; LevelOrderNodeArray.Num(); i++&lt;span&gt;)
    {
        FString Temp;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (LevelOrderNodeArray[i]-&amp;gt;GetColor()) Temp = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;red&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; Temp = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Black&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

        UKismetSystemLibrary::PrintString(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;, FString::FromInt(i) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
            + FString::FromInt(LevelOrderNodeArray[i]-&amp;gt;GetKey()) + &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; + LevelOrderNodeArray[i]-&amp;gt;&lt;span&gt;GetValue()
            &lt;/span&gt;+ &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; Count: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + FString::FromInt(LevelOrderNodeArray[i]-&amp;gt;GetCount()) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; Color:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; Temp);
    }
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Called every frame&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; ARedBlackBST::Tick(&lt;span&gt;float&lt;/span&gt;&lt;span&gt; DeltaTime)
{
    Super::Tick(DeltaTime);
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断一个节点和它父节点的联系是否是红色的&lt;/span&gt;
&lt;span&gt;bool&lt;/span&gt; ARedBlackBST::IsRed(ARedBlackNode*&lt;span&gt; X)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!X) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; X-&amp;gt;GetColor() ==&lt;span&gt; Red;
}

FString ARedBlackBST::GetValue(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; InputKey)
{
    ARedBlackNode&lt;/span&gt;* X =&lt;span&gt; RootNode;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (X !=&lt;span&gt; nullptr)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;比较key的大小&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; Temp = CompareTo(InputKey, X-&amp;gt;&lt;span&gt;GetKey());
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果输入的key比X的小，去X的左边&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (Temp &amp;lt; &lt;span&gt;0&lt;/span&gt;) X = X-&amp;gt;GetNode(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果输入的key比X的大，去X的右边&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (Temp &amp;gt; &lt;span&gt;0&lt;/span&gt;) X = X-&amp;gt;GetNode(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果相等，说明找到这个key了，输出Value&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt; &lt;span&gt;return&lt;/span&gt; X-&amp;gt;&lt;span&gt;GetValue();
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果X为空指针，说明找不到这个key&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;NotFind&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果a大于b，返回1；如果a小于b，返回-1；如果相等，返回0&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; ARedBlackBST::CompareTo(&lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; b)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (a &amp;gt; b) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (a &amp;lt; b) &lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}

ARedBlackNode&lt;/span&gt;* ARedBlackBST::RotateLeft(ARedBlackNode*&lt;span&gt; h)
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;X节点是h的右节点。
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;左旋的结果是:
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.X成为了h的父节点，h是X的左节点。
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.X原来的左节点变成了h的右节点,其它节点不变，h和X之间的联系还是红色。
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果旋转前，h是根节点，则旋转后，X是根节点，X没父节点&lt;/span&gt;
    &lt;span&gt;bool&lt;/span&gt; HIsRoot = h ==&lt;span&gt; RootNode;
    
    ARedBlackNode&lt;/span&gt;* X = h-&amp;gt;GetNode(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ARedBlackNode* Parent = h-&amp;gt;GetParent();&lt;/span&gt;
    h-&amp;gt;SetNode(&lt;span&gt;false&lt;/span&gt;, X-&amp;gt;GetNode(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;));
    X&lt;/span&gt;-&amp;gt;SetNode(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;, h);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果X节点是红色节点，则左旋后，h是红色节点，X是黑色节点&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (X-&amp;gt;GetColor() ==&lt;span&gt; Red)
    {
        X&lt;/span&gt;-&amp;gt;SetColor(h-&amp;gt;&lt;span&gt;GetColor());
        h&lt;/span&gt;-&amp;gt;&lt;span&gt;SetColor(Red);
    }
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;左旋后，两节点的Count更新&lt;/span&gt;
    h-&amp;gt;SetCount(&lt;span&gt;1&lt;/span&gt; + Size(h-&amp;gt;GetNode(&lt;span&gt;false&lt;/span&gt;)) + Size(h-&amp;gt;GetNode(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)));
    X&lt;/span&gt;-&amp;gt;SetCount(&lt;span&gt;1&lt;/span&gt; + Size(X-&amp;gt;GetNode(&lt;span&gt;false&lt;/span&gt;)) + Size(X-&amp;gt;GetNode(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)));
    UKismetSystemLibrary::PrintString(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RotateLeft&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (HIsRoot)
    {
        X&lt;/span&gt;-&amp;gt;&lt;span&gt;SetParent(nullptr);
        RootNode &lt;/span&gt;=&lt;span&gt; X;
    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; X;
}

ARedBlackNode&lt;/span&gt;* ARedBlackBST::RotateRight(ARedBlackNode*&lt;span&gt; h)
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;X节点是h的左节点。
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;左旋的结果是:
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.X成为了h的父节点，h是X的右节点。
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.X原来的右节点变成了h的左节点,其它节点不变，h和X之间的联系还是红色。
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果旋转前，h是根节点，则旋转后，X是根节点，X没父节点&lt;/span&gt;
    &lt;span&gt;bool&lt;/span&gt; HIsRoot = h ==&lt;span&gt; RootNode;
    ARedBlackNode&lt;/span&gt;* X = h-&amp;gt;GetNode(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ARedBlackNode* Parent = h-&amp;gt;GetParent();&lt;/span&gt;
    h-&amp;gt;SetNode(&lt;span&gt;true&lt;/span&gt;, X-&amp;gt;GetNode(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;));
    X&lt;/span&gt;-&amp;gt;SetNode(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;, h);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果X节点是红色节点，则右旋后，h是红色节点，X是黑色节点&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (X-&amp;gt;GetColor() ==&lt;span&gt; Red)
    {
        X&lt;/span&gt;-&amp;gt;SetColor(h-&amp;gt;&lt;span&gt;GetColor());
        h&lt;/span&gt;-&amp;gt;&lt;span&gt;SetColor(Red);
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;右旋后，两节点的Count更新&lt;/span&gt;
    h-&amp;gt;SetCount(&lt;span&gt;1&lt;/span&gt; + Size(h-&amp;gt;GetNode(&lt;span&gt;false&lt;/span&gt;)) + Size(h-&amp;gt;GetNode(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)));
    X&lt;/span&gt;-&amp;gt;SetCount(&lt;span&gt;1&lt;/span&gt; + Size(X-&amp;gt;GetNode(&lt;span&gt;false&lt;/span&gt;)) + Size(X-&amp;gt;GetNode(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)));
    UKismetSystemLibrary::PrintString(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RotateRight&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (X == RootNode) X-&amp;gt;&lt;span&gt;SetParent(nullptr);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (HIsRoot)
    {
        X&lt;/span&gt;-&amp;gt;&lt;span&gt;SetParent(nullptr);
        RootNode &lt;/span&gt;=&lt;span&gt; X;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; X;
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; ARedBlackBST::FlipColors(ARedBlackNode*&lt;span&gt; h)
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;反转颜色：如果一个节点的左右联系都是红色，则将它们变为黑色，此节点与父节点的联系变为红色&lt;/span&gt;
    h-&amp;gt;&lt;span&gt;SetColor(Red);
    h&lt;/span&gt;-&amp;gt;GetNode(&lt;span&gt;true&lt;/span&gt;)-&amp;gt;&lt;span&gt;SetColor(Black);
    h&lt;/span&gt;-&amp;gt;GetNode(&lt;span&gt;false&lt;/span&gt;)-&amp;gt;&lt;span&gt;SetColor(Black);
    h&lt;/span&gt;-&amp;gt;SetValue(&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;);
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; ARedBlackBST::Put(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; Newkey)
{
    RootNode &lt;/span&gt;=&lt;span&gt; Put(RootNode, Newkey);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根节点必须是黑色的&lt;/span&gt;
    RootNode-&amp;gt;&lt;span&gt;SetColor(Black);
}

ARedBlackNode&lt;/span&gt;* ARedBlackBST::Put(ARedBlackNode* h, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; NewKey)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;h)
    {
        ARedBlackNode&lt;/span&gt;* NewNode = GetWorld()-&amp;gt;SpawnActor&amp;lt;ARedBlackNode&amp;gt;&lt;span&gt;(ARedBlackNode::StaticClass());
        NewNode&lt;/span&gt;-&amp;gt;&lt;span&gt;SetValue(NewKey, FakeValue);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;新节点与父节点的联系一开始是红色的（后续可能会经过旋转，反转等操作，变成黑色）&lt;/span&gt;
        NewNode-&amp;gt;&lt;span&gt;SetColor(Red);
        NewNode&lt;/span&gt;-&amp;gt;SetCount(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NewNode;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;与二叉搜索树相同，如果新节点的key比h节点的key小，则去h节点的左边；如果大，则去右边；如果相同，则覆盖h节点&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; Temp = CompareTo(NewKey, h-&amp;gt;&lt;span&gt;GetKey());
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果要插入新节点，则新节点的所有父节点都要更新一次&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (Temp &amp;lt; &lt;span&gt;0&lt;/span&gt;) h-&amp;gt;SetNode(&lt;span&gt;true&lt;/span&gt;, Put(h-&amp;gt;GetNode(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;), NewKey));
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (Temp &amp;gt; &lt;span&gt;0&lt;/span&gt;) h-&amp;gt;SetNode(&lt;span&gt;false&lt;/span&gt;, Put(h-&amp;gt;GetNode(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;), NewKey));
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; h-&amp;gt;&lt;span&gt;SetValue(FakeValue);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;更新h节点的Count&lt;/span&gt;
    h-&amp;gt;SetCount(&lt;span&gt;1&lt;/span&gt; + Size(h-&amp;gt;GetNode(&lt;span&gt;true&lt;/span&gt;)) + Size(h-&amp;gt;GetNode(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;)));

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;h与右节点联系是红色的，且与左节点的联系是黑色的，则需要左旋&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (IsRed(h-&amp;gt;GetNode(&lt;span&gt;false&lt;/span&gt;)) &amp;amp;&amp;amp; !IsRed(h-&amp;gt;GetNode(&lt;span&gt;true&lt;/span&gt;))) h =&lt;span&gt; RotateLeft(h);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果h与左节点的联系是红色的，且h与左节点的左节点的联系也是红色的，说明出现连续两个红色联系，需要右旋&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (IsRed(h-&amp;gt;GetNode(&lt;span&gt;true&lt;/span&gt;)) &amp;amp;&amp;amp; IsRed(h-&amp;gt;GetNode(&lt;span&gt;true&lt;/span&gt;)-&amp;gt;GetNode(&lt;span&gt;true&lt;/span&gt;))) h =&lt;span&gt; RotateRight(h);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果h节点的左右联系都是红色，则需要反转（注意：根节点的反转只会把它们变为黑色，因为它没有父节点）&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (IsRed(h-&amp;gt;GetNode(&lt;span&gt;true&lt;/span&gt;)) &amp;amp;&amp;amp; IsRed(h-&amp;gt;GetNode(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;))) FlipColors(h);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;以上三种情况排序是故意的，因为左旋后可能需要右旋，右旋后需要反转
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;以上三种情况可能会分别触发，也可能会连续触发

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;给左右子节点设置父节点
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;if (h-&amp;gt;GetNode(true)) h-&amp;gt;GetNode(true)-&amp;gt;SetParent(h);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;if (h-&amp;gt;GetNode(false)) h-&amp;gt;GetNode(false)-&amp;gt;SetParent(h);&lt;/span&gt;
    
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; h;
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; ARedBlackBST::InorderTraversal()
{
    OrderNodeArray.Empty();
    Inorder(RootNode);
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; ARedBlackBST::Inorder(ARedBlackNode*&lt;span&gt; X)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!X) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;先去加X的左节点&lt;/span&gt;
    Inorder(X-&amp;gt;GetNode(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;));
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;再加X&lt;/span&gt;
&lt;span&gt;    OrderNodeArray.Add(X);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;最后加X的右节点&lt;/span&gt;
    Inorder(X-&amp;gt;GetNode(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;));
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; ARedBlackBST::FindMin()
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从根节点开始比较&lt;/span&gt;
    ARedBlackNode* X =&lt;span&gt; FindMin(RootNode);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (X) &lt;span&gt;return&lt;/span&gt; X-&amp;gt;&lt;span&gt;GetKey();
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}

ARedBlackNode&lt;/span&gt;* ARedBlackBST::FindMin(ARedBlackNode*&lt;span&gt; X)
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当节点存在时&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt;&lt;span&gt; (X)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果左节点存在，继续循环&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (X-&amp;gt;GetNode(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;))
        {
            X &lt;/span&gt;= X-&amp;gt;GetNode(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果右节点不存在，这个节点就是最小值&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; X;
        }
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; X;
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; ARedBlackBST::FindMax()
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从根节点开始比较&lt;/span&gt;
    ARedBlackNode* X =&lt;span&gt; FindMax(RootNode);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (X) &lt;span&gt;return&lt;/span&gt; X-&amp;gt;&lt;span&gt;GetKey();
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}

ARedBlackNode&lt;/span&gt;* ARedBlackBST::FindMax(ARedBlackNode*&lt;span&gt; X)
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当节点存在时&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt;&lt;span&gt; (X)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果右节点存在，继续循环&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (X-&amp;gt;GetNode(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;))
        {
            X &lt;/span&gt;= X-&amp;gt;GetNode(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果右节点不存在，这个节点就是最小值&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; X;
        }
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; X;
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; ARedBlackBST::FindFloor(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; InputKey)
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从根节点开始比较&lt;/span&gt;
    ARedBlackNode* X =&lt;span&gt; FindFloor(RootNode, InputKey);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (X) &lt;span&gt;return&lt;/span&gt; X-&amp;gt;&lt;span&gt;GetKey();
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}

ARedBlackNode&lt;/span&gt;* ARedBlackBST::FindFloor(ARedBlackNode* X, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; InputKey)
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果X节点不存在，就别继续下去了&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (!X) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; nullptr;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; Temp = CompareTo(InputKey, X-&amp;gt;&lt;span&gt;GetKey());
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果存在节点的key与输入值相等，则这个节点就是最接近它了&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (Temp == &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; X;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果节点的key比较大，则去找它的左节点，直到找到小于等于输入值的节点为止&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (Temp &amp;lt; &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; FindFloor(X-&amp;gt;GetNode(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;), InputKey);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果节点的key比较小，则要找的节点可能在它的右节点的左端&lt;/span&gt;
    ARedBlackNode* T = FindFloor(X-&amp;gt;GetNode(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;), InputKey);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果找到了T,则说明找到了，返回T;如果找不到，说明X已经是最接近的了，返回X&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (T) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; T;
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;return&lt;/span&gt;&lt;span&gt; X;
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; ARedBlackBST::FindCeiling(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; InputKey)
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从根节点开始比较&lt;/span&gt;
    ARedBlackNode* X =&lt;span&gt; FindCeiling(RootNode, InputKey);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (X) &lt;span&gt;return&lt;/span&gt; X-&amp;gt;&lt;span&gt;GetKey();
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}

ARedBlackNode&lt;/span&gt;* ARedBlackBST::FindCeiling(ARedBlackNode* X, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; InputKey)
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果X节点不存在，就别继续下去了&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (!X) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; nullptr;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; Temp = CompareTo(InputKey, X-&amp;gt;&lt;span&gt;GetKey());
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果存在节点的key与输入值相等，则这个节点就是最接近它了&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (Temp == &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; X;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果节点的key比较小，则去找它的右节点，直到找到大于等于输入值的节点为止&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (Temp &amp;gt; &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; FindCeiling(X-&amp;gt;GetNode(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;), InputKey);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果节点的key比较大，则要找的节点可能在它的左节点的左端&lt;/span&gt;
    ARedBlackNode* T = FindCeiling(X-&amp;gt;GetNode(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;), InputKey);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果找到了T,则说明找到了，返回T;如果找不到，说明X已经是最接近的了，返回X&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (T) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; T;
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;return&lt;/span&gt;&lt;span&gt; X;
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; ARedBlackBST::Size(ARedBlackNode*&lt;span&gt; X)
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果节点不存在，返回0&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (!X) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果节点存在，返回Count&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; X-&amp;gt;&lt;span&gt;GetCount();
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; ARedBlackBST::Rank(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; InputKey)
{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Rank(InputKey, RootNode);
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; ARedBlackBST::Rank(&lt;span&gt;int&lt;/span&gt; InputKey, ARedBlackNode*&lt;span&gt; X)
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果节点不存在，返回0&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (!X) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; Temp = CompareTo(InputKey, X-&amp;gt;&lt;span&gt;GetKey());
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果给定数字比X的key小，则去X的左边去找比给定数字小的数字&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (Temp &amp;lt; &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; Rank(InputKey, X-&amp;gt;GetNode(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;));
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果给定数字比X的key大，则X和X的左节点都比给定数字小，把它们算上后，去X的右节点找是否还有比给定数字小的数字&lt;/span&gt;
    &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (Temp &amp;gt; &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; + Size(X-&amp;gt;GetNode(&lt;span&gt;true&lt;/span&gt;)) + Rank(InputKey, X-&amp;gt;GetNode(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;));
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;因为右节点都比X大，而X的Key与给定数字相等，故比给定数字小的数字都在X的左节点里&lt;/span&gt;
    &lt;span&gt;else&lt;/span&gt; &lt;span&gt;return&lt;/span&gt; Size(X-&amp;gt;GetNode(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;));
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; ARedBlackBST::UpdateRouteString()
{
    RouteString &lt;/span&gt;= &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
    LevelOrderNodeArray.Empty();
    UpdateRouteString(RootNode);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;RootNode-&amp;gt;SetValue(&quot;Root&quot;);&lt;/span&gt;
&lt;span&gt;}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; ARedBlackBST::UpdateRouteString(ARedBlackNode*&lt;span&gt; X)
{
    TQueue&lt;/span&gt;&amp;lt;ARedBlackNode*&amp;gt;&lt;span&gt; q;
    q.Enqueue(RootNode);
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (!&lt;span&gt;q.IsEmpty())
    {
        ARedBlackNode&lt;/span&gt;*&lt;span&gt; T;
        q.Dequeue(T);
        LevelOrderNodeArray.Add(T);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果T的父节点存在&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (T-&amp;gt;&lt;span&gt;GetParent())
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果T是左节点&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (T == T-&amp;gt;GetParent()-&amp;gt;GetNode(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;))
            {
                FString TempString;
                TempString.Append(T&lt;/span&gt;-&amp;gt;GetParent()-&amp;gt;&lt;span&gt;GetValue());
                TempString.Append(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-&amp;gt;Left&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                T&lt;/span&gt;-&amp;gt;&lt;span&gt;SetValue(TempString);
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果T是右节点&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (T == T-&amp;gt;GetParent()-&amp;gt;GetNode(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;))
            {
                FString TempString;
                TempString.Append(T&lt;/span&gt;-&amp;gt;GetParent()-&amp;gt;&lt;span&gt;GetValue());
                TempString.Append(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-&amp;gt;Right&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                T&lt;/span&gt;-&amp;gt;&lt;span&gt;SetValue(TempString);
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                T&lt;/span&gt;-&amp;gt;SetValue(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Root&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果父节点不存在，说明是根节点&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        {
            T&lt;/span&gt;-&amp;gt;SetValue(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Root&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将出队的左节点入队&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (T-&amp;gt;GetNode(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;))
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;T-&amp;gt;GetNode(true)-&amp;gt;SetParent(T);&lt;/span&gt;
            q.Enqueue(T-&amp;gt;GetNode(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;));
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将出队的右节点入队&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (T-&amp;gt;GetNode(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;))
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;T-&amp;gt;GetNode(false)-&amp;gt;SetParent(T);&lt;/span&gt;
            q.Enqueue(T-&amp;gt;GetNode(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;));
        }
    }
}

ARedBlackNode&lt;/span&gt;* ARedBlackBST::BSTReplace(ARedBlackNode*&lt;span&gt; X)
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果X节点有两个子节点，返回后驱节点&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (X-&amp;gt;GetNode(&lt;span&gt;true&lt;/span&gt;) &amp;amp;&amp;amp; X-&amp;gt;GetNode(&lt;span&gt;false&lt;/span&gt;)) &lt;span&gt;return&lt;/span&gt; Successor(X-&amp;gt;GetNode(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;));
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果X节点没有子节点，返回空&lt;/span&gt;
    &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!X-&amp;gt;GetNode(&lt;span&gt;true&lt;/span&gt;) &amp;amp;&amp;amp; !X-&amp;gt;GetNode(&lt;span&gt;false&lt;/span&gt;)) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; nullptr;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果X节点只有一个左节点&lt;/span&gt;
    &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (X-&amp;gt;GetNode(&lt;span&gt;true&lt;/span&gt;)) &lt;span&gt;return&lt;/span&gt; X-&amp;gt;GetNode(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果X节点只有一个右节点&lt;/span&gt;
    &lt;span&gt;else&lt;/span&gt; &lt;span&gt;return&lt;/span&gt; X-&amp;gt;GetNode(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
}

ARedBlackNode&lt;/span&gt;* ARedBlackBST::Successor(ARedBlackNode*&lt;span&gt; X)
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;后驱节点是X节点下面的最小节点，它没有左节点&lt;/span&gt;
    ARedBlackNode* Temp =&lt;span&gt; X;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (Temp-&amp;gt;GetNode(&lt;span&gt;true&lt;/span&gt;)) Temp = Temp-&amp;gt;GetNode(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Temp;
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; ARedBlackBST::DeleteNode(ARedBlackNode*&lt;span&gt; X)
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;继承节点&lt;/span&gt;
    ARedBlackNode* u =&lt;span&gt; BSTReplace(X);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;u和x都是黑色节点吗？&lt;/span&gt;
    &lt;span&gt;bool&lt;/span&gt; uxBlack = ((!u || u-&amp;gt;GetColor() == Black) &amp;amp;&amp;amp; (X-&amp;gt;GetColor() ==&lt;span&gt; Black));
    ARedBlackNode&lt;/span&gt;* Parent = X-&amp;gt;&lt;span&gt;GetParent();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果继承节点u不存在，说明节点X没子节点&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;u)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果X是根节点，说明想删根节点，且根节点下面没节点&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (X == RootNode) RootNode =&lt;span&gt; nullptr;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;X是普通节点&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果u,x都是黑色节点，且X没子节点，那么删除它将产生双重黑色节点，需要消除它&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (uxBlack)
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除后，节点数更新&lt;/span&gt;
                Parent-&amp;gt;SetCount(Parent-&amp;gt;GetCount() - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
                UpdateParentsCount(Parent);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;X还没删除，X的节点数设为0&lt;/span&gt;
                X-&amp;gt;SetCount(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
                FixDoubleBlack(X);
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果uxBlack==false,说明X节点是红色的，且没子节点，直接删除&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除后，节点数更新&lt;/span&gt;
                Parent-&amp;gt;SetCount(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
                UpdateParentsCount(Parent);
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除这个节点后，父节点把这个节点清空&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (X-&amp;gt;IsOnLeft()) Parent-&amp;gt;SetNode(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;, nullptr);
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; Parent-&amp;gt;SetNode(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;, nullptr);
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除节点&lt;/span&gt;
        X-&amp;gt;&lt;span&gt;Destroy();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果X只有一个子节点，那么只有一种可能性：X是黑色节点，u是红色节点&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (!X-&amp;gt;GetNode(&lt;span&gt;true&lt;/span&gt;) || !X-&amp;gt;GetNode(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;))
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果X是根节点，且只有一个节点，直接删除，子节点成为根节点
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里是把子节点的值和X的值互换，然后删除子节点u&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (X ==&lt;span&gt; RootNode)
        {
            X&lt;/span&gt;-&amp;gt;SetKey(u-&amp;gt;&lt;span&gt;GetKey());
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除后，没有子节点了&lt;/span&gt;
            X-&amp;gt;SetNode(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;, nullptr);
            X&lt;/span&gt;-&amp;gt;SetNode(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;, nullptr);
            u&lt;/span&gt;-&amp;gt;&lt;span&gt;Destroy();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;更新节点数&lt;/span&gt;
            X-&amp;gt;SetCount(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果X不是根节点,直接删除X节点，u节点补位，并变成黑色节点&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;子节点u补位&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (X-&amp;gt;IsOnLeft()) Parent-&amp;gt;SetNode(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;, u);
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; Parent-&amp;gt;SetNode(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;, u);
            X&lt;/span&gt;-&amp;gt;&lt;span&gt;Destroy();
            u&lt;/span&gt;-&amp;gt;&lt;span&gt;SetParent(Parent);
            u&lt;/span&gt;-&amp;gt;&lt;span&gt;SetColor(Black);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;u的节点数是正确的，不用更新
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;更新U的所有父节点的节点数&lt;/span&gt;
&lt;span&gt;            UpdateParentsCount(u);
            
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果来到这，说明X有两个子节点，交换u,x的值，继续删除u节点&lt;/span&gt;
&lt;span&gt;    SwapKey(X, u);
    DeleteNode(u);
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; ARedBlackBST::DeleteNode(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; InputKey)
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;先找到这个节点&lt;/span&gt;
    ARedBlackNode* X =&lt;span&gt; RootNode;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (X !=&lt;span&gt; nullptr)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;比较key的大小&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; Temp = CompareTo(InputKey, X-&amp;gt;&lt;span&gt;GetKey());
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果输入的key比X的小，去X的左边&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (Temp &amp;lt; &lt;span&gt;0&lt;/span&gt;) X = X-&amp;gt;GetNode(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果输入的key比X的大，去X的右边&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (Temp &amp;gt; &lt;span&gt;0&lt;/span&gt;) X = X-&amp;gt;GetNode(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果相等，说明找到这个节点了,跳出循环&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt; &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果X不存在，说明要删除的节点不存在&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (!X) UKismetSystemLibrary::PrintString(&lt;span&gt;this&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Not Such Node!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果存在，进行删除&lt;/span&gt;
&lt;span&gt;    DeleteNode(X);
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; ARedBlackBST::FixDoubleBlack(ARedBlackNode*&lt;span&gt; X)
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果X是双重黑色根节点，说明此时X有一个红色子节点，如果是右红色子节点，需要左旋。随后返回&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (X ==&lt;span&gt; RootNode)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (X-&amp;gt;GetNode(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;)) RotateLeft(X);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取X的邻居节点和父节点&lt;/span&gt;
    ARedBlackNode* Sibling = X-&amp;gt;&lt;span&gt;GetSibling();
    ARedBlackNode&lt;/span&gt;* Parent = X-&amp;gt;&lt;span&gt;GetParent();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果X不是根节点，则不可能没有邻居节点和父节点&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (!Sibling) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!Parent) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果邻居节点是红色节点，那么此节点肯定是左节点，右旋&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (Sibling-&amp;gt;GetColor() ==&lt;span&gt; Red)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;父节点的父节点&lt;/span&gt;
        ARedBlackNode* GrandParent = Parent-&amp;gt;&lt;span&gt;GetParent();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果祖父节点存在，需要更新节点联系&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (GrandParent)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果父节点是左节点，把旋转后的节点放回祖父节点的左节点处&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (Parent-&amp;gt;IsOnLeft()) GrandParent-&amp;gt;SetNode(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;, RotateRight(Parent));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;反之，则放回祖父节点的右节点处&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt; GrandParent-&amp;gt;SetNode(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;, RotateRight(Parent));
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果祖父节点不存在，说明父节点是根节点，不需要更新祖父节点&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt; RotateRight(Parent);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;为了消除双重黑色节点，逆反转颜色&lt;/span&gt;
        Parent-&amp;gt;&lt;span&gt;SetColor(Black);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;右旋之后，如果Parent的左子节点存在，把它变红&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (Parent-&amp;gt;GetNode(&lt;span&gt;true&lt;/span&gt;)) Parent-&amp;gt;GetNode(&lt;span&gt;true&lt;/span&gt;)-&amp;gt;&lt;span&gt;SetColor(Red);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;邻居节点是黑色&lt;/span&gt;
    &lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;邻居节点有红色子节点，这个节点肯定是左节点&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (Sibling-&amp;gt;&lt;span&gt;HasRedChild())
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;邻居节点是左节点时&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (Sibling-&amp;gt;&lt;span&gt;IsOnLeft())
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;子节点变为黑色节点&lt;/span&gt;
                Sibling-&amp;gt;GetNode(&lt;span&gt;true&lt;/span&gt;)-&amp;gt;&lt;span&gt;SetColor(Black);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;记录父节点是不是红色的&lt;/span&gt;
                &lt;span&gt;bool&lt;/span&gt; RedParent = Parent-&amp;gt;GetColor() ==&lt;span&gt; Red;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;旋转前，把父节点的颜色变为黑色&lt;/span&gt;
                Parent-&amp;gt;&lt;span&gt;SetColor(Black);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;父节点的父节点&lt;/span&gt;
                ARedBlackNode* GrandParent = Parent-&amp;gt;&lt;span&gt;GetParent();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果祖父节点存在，需要更新节点联系&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (GrandParent)
                {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果父节点是左节点，把旋转后的节点放回祖父节点的左节点处&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; (Parent-&amp;gt;IsOnLeft()) GrandParent-&amp;gt;SetNode(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;, RotateRight(Parent));
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;反之，则放回祖父节点的右节点处&lt;/span&gt;
                    &lt;span&gt;else&lt;/span&gt; GrandParent-&amp;gt;SetNode(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;, RotateRight(Parent));
                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果祖父节点不存在，说明父节点是根节点，不需要更新祖父节点&lt;/span&gt;
                &lt;span&gt;else&lt;/span&gt;&lt;span&gt; RotateRight(Parent);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果旧父节点是红色的，则成为了新父节点的邻居节点也应该是红色的&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (RedParent) Sibling-&amp;gt;&lt;span&gt;SetColor(Red);
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;邻居节点是右节点时&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;记录父节点是不是红色的&lt;/span&gt;
                &lt;span&gt;bool&lt;/span&gt; RedParent = Parent-&amp;gt;GetColor() ==&lt;span&gt; Red;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;把红色子节点记录下来，最后消除完毕时，此节点变成了父节点&lt;/span&gt;
                ARedBlackNode* RedChild = Sibling-&amp;gt;GetNode(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;旋转前，把父节点的颜色变为黑色&lt;/span&gt;
                Parent-&amp;gt;&lt;span&gt;SetColor(Black);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Sibling-&amp;gt;GetNode(true)-&amp;gt;SetColor(Parent-&amp;gt;GetColor());
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;先对邻居节点右旋,右旋后，邻居节点变成了红色节点&lt;/span&gt;
                Parent-&amp;gt;SetNode(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;, RotateRight(Sibling));
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;红色节点变回黑色节点&lt;/span&gt;
                Sibling-&amp;gt;&lt;span&gt;SetColor(Black);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;再对父节点左旋，注意，这里的左旋中，父节点的右节点是黑色节点，左旋后，它们还是黑色节点
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;父节点的父节点&lt;/span&gt;
                ARedBlackNode* GrandParent = Parent-&amp;gt;&lt;span&gt;GetParent();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果祖父节点存在，需要更新节点联系&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (GrandParent)
                {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果父节点是左节点，把旋转后的节点放回祖父节点的左节点处&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; (Parent-&amp;gt;IsOnLeft()) GrandParent-&amp;gt;SetNode(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;, RotateLeft(Parent));
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;反之，则放回祖父节点的右节点处&lt;/span&gt;
                    &lt;span&gt;else&lt;/span&gt; GrandParent-&amp;gt;SetNode(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;, RotateLeft(Parent));
                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果祖父节点不存在，说明父节点是根节点，不需要更新祖父节点&lt;/span&gt;
                &lt;span&gt;else&lt;/span&gt;&lt;span&gt; RotateLeft(Parent);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果旧父节点是红色的，则新父节点也应该是红色的&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (RedParent) RedChild-&amp;gt;&lt;span&gt;SetColor(Red);
            }
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;邻居节点有两个黑色子节点或没有子节点时&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;进行逆反转颜色
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不管父节点是否是红色节点，邻居节点都会变成红色节点&lt;/span&gt;
            Sibling-&amp;gt;&lt;span&gt;SetColor(Red);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果父节点是红色节点，直接变成黑色节点&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (Parent-&amp;gt;GetColor() == Red) Parent-&amp;gt;&lt;span&gt;SetColor(Black);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果父节点是黑色节点，变成双重黑色节点，继续消除它&lt;/span&gt;
&lt;span&gt;            FixDoubleBlack(Parent);
        }
    }
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;交换两个节点的值&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; ARedBlackBST::SwapKey(ARedBlackNode* X, ARedBlackNode*&lt;span&gt; Y)
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; Temp;
    Temp &lt;/span&gt;= X-&amp;gt;&lt;span&gt;GetKey();
    X&lt;/span&gt;-&amp;gt;SetKey(Y-&amp;gt;&lt;span&gt;GetKey());
    Y&lt;/span&gt;-&amp;gt;&lt;span&gt;SetKey(Temp);
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; ARedBlackBST::UpdateParentsCount(ARedBlackNode*&lt;span&gt; X)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!X) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;X的所有父节点都要更新节点数&lt;/span&gt;
    ARedBlackNode* G = X-&amp;gt;&lt;span&gt;GetParent();
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (G)
    {
        G&lt;/span&gt;-&amp;gt;SetCount(&lt;span&gt;1&lt;/span&gt; + Size(G-&amp;gt;GetNode(&lt;span&gt;true&lt;/span&gt;)) + Size(G-&amp;gt;GetNode(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;)));
        G &lt;/span&gt;= G-&amp;gt;&lt;span&gt;GetParent();
        
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Mon, 07 Jan 2019 07:22:00 +0000</pubDate>
<dc:creator>MichaelCen</dc:creator>
<og:description>1.前文回顾 上一篇随笔写到了红黑树的实现及其各种功能的实现，本文将讲红黑树的删除。 上一篇随笔提到了二叉搜索树的删除功能在红黑树中虽然可以用，但会破坏红黑树的结构。 其实红黑树的删除功能是在二叉搜索</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mcomco/p/10213468.html</dc:identifier>
</item>
<item>
<title>数据预处理也有套路的 - 蕉爷</title>
<link>http://www.cnblogs.com/Alear/p/10233307.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Alear/p/10233307.html</guid>
<description>&lt;p&gt;数据挖掘的核心是什么？这个的答案是算法应该没什么疑问。那数据挖掘的基石又是什么呢？那就是今天我们要来说的数据预处理。&lt;/p&gt;
&lt;h3 data-source-line=&quot;3&quot;&gt;什么是数据预处理？&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/roPWrjQ5nUG9X3FRJIibNB3zUMIRYKibEy6e7TKl1c5ZpzxWlqNv4icstyU5DHuz3HlV1NtTwPxUI99YicehrzYvvw/0?wx_fmt=png&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;524&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;439&quot; data-ratio=&quot;0.8384332925336597&quot; data-w=&quot;817&quot;/&gt;&lt;/p&gt;
&lt;p&gt;数据科学家们一直想为数据预处理赋予一个定义。其实简单地说，数据预处理就是一种数据挖掘技术，本质就是为了将原始数据转换为可以理解的格式或者符合我们挖掘的格式。&lt;/p&gt;
&lt;h3 data-source-line=&quot;8&quot;&gt;那么为什么需要数据预处理呢&lt;/h3&gt;
&lt;p&gt;在真实世界中，数据通常是不完整的（缺少某些感兴趣的属性值），不一致的（包含代码或者名称的差异），极易受到噪声（错误或异常值）的侵扰的。因为数据库太大，而且数据集经常来自多个异种数据源，低质量的数据将导致低质量的挖掘结果。就像一个大厨现在要做美味的蒸鱼，如果不将鱼进行去鳞等处理，一定做不成我们口中美味的鱼。数据预处理就是解决上面所提到的数据问题的可靠方法。&lt;/p&gt;
&lt;h3 data-source-line=&quot;12&quot;&gt;那它是怎么做到的呢？&lt;/h3&gt;
&lt;p&gt;就像大厨准备处理鱼的刀具一样，数据预处理也是如此。它准备原始数据以便进一步处理。下面是数据预处理要采取的步骤，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qlogo.cn/mmbiz_png/roPWrjQ5nUG9X3FRJIibNB3zUMIRYKibEywtz3N8rFkA4LppoQiaWYica51qXZAMZHVJBVjQSrzGgviaoTqPibZ637Nw/0?wx_fmt=png&quot; alt=&quot;&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-ratio=&quot;0.2768878718535469&quot; data-w=&quot;874&quot;/&gt;&lt;/p&gt;
&lt;p&gt;数据清洗： 填写缺失的值，光滑噪声数据，识别或删除离群点，并解决不一致性来“清理数据”。&lt;/p&gt;
&lt;p&gt;数据集成：使用多个数据库，数据立方体或文件&lt;/p&gt;
&lt;p&gt;数据归约： 用替代的，较小的数据表示形式替换元数据，得到信息内容的损失最小化，方法包括维规约，数量规约和数据压缩&lt;/p&gt;
&lt;p&gt;数据变换：将数据变换成使用挖掘的形式。&lt;/p&gt;
&lt;p&gt;下面这张图很形象得把这四个步骤的作用表现出来，挺有意思的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/roPWrjQ5nUG9X3FRJIibNB3zUMIRYKibEyPvotnEQUw28KXR0icr7s5lNOQoYdT3LJ2BicKdq5xEMn9txBc6jbzMwA/0?wx_fmt=png&quot; alt=&quot;&quot; data-type=&quot;png&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;524&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;397&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.7576530612244898&quot; data-w=&quot;784&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　　　　　　　　数据预处理任务&lt;/p&gt;
&lt;h3 data-source-line=&quot;31&quot;&gt;应用&lt;/h3&gt;
&lt;p&gt;是时候我们采取一些简单的实际应用来了解数据预处理是如何完成的&lt;/p&gt;
&lt;p&gt;下面的例子我们用 python 来处理，还需要用到两个库，分别是 numpy,pandas。&lt;/p&gt;
&lt;p&gt;准备数据&lt;/p&gt;
&lt;p&gt;在这里，我们有一个数据集，其中包括IT专业人员的信息，比如国家，工资，性别，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/roPWrjQ5nUG9X3FRJIibNB3zUMIRYKibEyQ56yI0yS2icNZ7BuiaVG5eqia04My0KH7aBUW84hnzicxNSpibq7U51IZnA/640?wx_fmt=png&quot; alt=&quot;&quot; data-ratio=&quot;0.5520361990950227&quot; data-type=&quot;png&quot; data-w=&quot;663&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以随意创建此数据集的副本。&lt;/p&gt;
&lt;p&gt;我们可以观察到上面的数据集包含一些空值，这是故意的。后面很快可以看到它发挥的作用&lt;/p&gt;
&lt;p&gt;导入库&lt;/p&gt;
&lt;p&gt;简单说下 numpy, pandas 这两个库的作用，numpy 库包含数学工具，它可以用于在我们代码中的任何类型的数学。pandas 库用于导入和管理数据集。&lt;/p&gt;
&lt;p&gt;下面是我们导入库的方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; pandas as pd
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; numpy as np
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;导入数据集&lt;/p&gt;
&lt;p&gt;我们已经导入库了，接下来我们需要获取数据集。在我本地里，我将我的数据集文件命名为‘profess’，它的格式为.csv。&lt;/p&gt;
&lt;pre data-source-line=&quot;64&quot;&gt;
&lt;code class=&quot;hljs&quot;/&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
data = pd.read_csv(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;profess.csv&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;pre data-source-line=&quot;64&quot;&gt;
&lt;code class=&quot;hljs&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;导入数据集后，我们输出看下它的格式如何&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;(data)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/roPWrjQ5nUG9X3FRJIibNB3zUMIRYKibEy6y12zerfUiaiaSbQbIk3Kicbnicnhx9uQN7ToFvrWuA0ooq8lwZb8h0ibOQ/640?wx_fmt=png&quot; alt=&quot;&quot; data-ratio=&quot;0.7964824120603015&quot; data-type=&quot;png&quot; data-w=&quot;398&quot;/&gt;&lt;/p&gt;
&lt;p&gt;good!我们成功得将数据集导入测试环境中。&lt;/p&gt;
&lt;p&gt;数据清洗--查看缺失值&lt;/p&gt;
&lt;p&gt;为了成功管理数据，缺失值的概念很重要。如果工程师没有正确处理缺失值，可能最后得出关于数据的推断是不准确的。 我们再来仔细看下我们的数据的缺失值情况，用 pandas 库的 isnull 函数来看看。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;(data.isnull().sum())
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/roPWrjQ5nUG9X3FRJIibNB3zUMIRYKibEyvVddPBGv4uhjkfpBiaZ2ufRL81aYCn0X7hZeaia1UYZHxkcVl9sBaIHw/640?wx_fmt=png&quot; alt=&quot;&quot; data-ratio=&quot;0.574585635359116&quot; data-type=&quot;png&quot; data-w=&quot;181&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以发现 Age,Salary列都有缺失值（就是为空的值），缺失值数量都为1。处理缺失值有7种处理方法，我们这里说说比较常用的两种。&lt;/p&gt;
&lt;p&gt;1、此方法经常用于处理空值，如果某行有特定特征d的空值，就删除此行。如果特定列具有超过75%的缺失值，就删除特定列。不过我们要在确保样本数据足够多的情况下，采用这个方法。因为我们要确保删除数据后，不会增加偏差。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
data.dropna(inplace=&lt;span&gt;True)

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(data.isnull().sum())
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/roPWrjQ5nUG9X3FRJIibNB3zUMIRYKibEyOChXlSsRJ7dGiblSxaCr5nggMwWm59aqUtF0HZpUBdKl9Y6qib2jl10A/640?wx_fmt=png&quot; alt=&quot;&quot; data-ratio=&quot;0.5649717514124294&quot; data-type=&quot;png&quot; data-w=&quot;177&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、这个方法适用于具有年份或者年龄，金额等数字数据的功能。我们可以计算特征的均值，中值或众数，将其替换为缺失值。与第一种方法相比，这种可以抵消数据的缺失，产生更好的效果。&lt;/p&gt;
&lt;p&gt;我们用来看一下操作&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将 Age 列中为空的值替换为 Age 的中位数。&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; medain()是 pandas 库的求中位数的方法&lt;/span&gt;
&lt;span&gt;
data[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
            .replace(np.NaN,data[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
            .median())
            
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;])
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/roPWrjQ5nUG9X3FRJIibNB3zUMIRYKibEyF5F5Hu4bmkibpdNek9VKTVSY3aAVHK0yOBtN588BP5xaGt2M1Xfkm2A/640?wx_fmt=png&quot; alt=&quot;&quot; data-ratio=&quot;1.0076045627376427&quot; data-type=&quot;png&quot; data-w=&quot;263&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们成功替换掉了&lt;/p&gt;
&lt;p&gt;数据归约 为了满足挖掘需求，我们需要知道这些工程师们的薪水分布区间，但是我们只有 ‘Salary’ 薪水这一列，所以为了方便挖掘，我们给我们的数据集增加‘薪水等级’ level 这一列，通过 Salary 列进行区间归约，这种方法叫做“属性构造”。我们看看操作&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;数据归约&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; section(d):   
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; 50000 &amp;gt;&lt;span&gt; d:        
         &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;50000以下&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
     &lt;span&gt;if&lt;/span&gt;  100000 &amp;gt; d &amp;gt;= 5000&lt;span&gt;:        
         &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;50000-100000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
     &lt;span&gt;if&lt;/span&gt;  d &amp;gt; 100000&lt;span&gt;:       
         &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;100000以上&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

data[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;level&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =  data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Salary&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;].apply(&lt;/span&gt;&lt;span&gt;lambda&lt;/span&gt;&lt;span&gt; x: section(x))

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;level&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;])
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/roPWrjQ5nUG9X3FRJIibNB3zUMIRYKibEy34Trib744SD1obgLR3XqfWt3icvVajQDJcJUSBEic9tfgZAbBl8d2NA4g/640?wx_fmt=png&quot; alt=&quot;&quot; data-ratio=&quot;0.926829268292683&quot; data-type=&quot;png&quot; data-w=&quot;287&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们定义一个‘数据变换’的函数给，根据 Salary 判断选择区间进行变换并赋值给 level。&lt;/p&gt;
&lt;p&gt;数据变换&lt;/p&gt;
&lt;p&gt;我们可以看到 Salary 列也有空值，从业务上理解它应该是数字数值才是。但是我们发现我们的数据集中是货币格式，我们需要对它进行‘数据变换’，转换成我们所需的数字格式。来看下实际操作&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;数据变换&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; convert_currency(d):
    new_value &lt;/span&gt;= str(d).replace(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;)
                .replace(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; float(new_value)    
                
data[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Salary&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Salary&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;].apply(convert_currency)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; mean()是 pandas 库的求平均值的方法&lt;/span&gt;
&lt;span&gt;
data[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Salary&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Salary&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
                    .replace(np.NaN,data[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Salary&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
                    .mean())

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Salary&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;])
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;变换成功&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/roPWrjQ5nUG9X3FRJIibNB3zUMIRYKibEyWiaibwhKnJ6vfyyUJ5R3C56Cd4sNmdXZKdYWBibV4MEFC0236x4cLY38A/640?wx_fmt=png&quot; alt=&quot;&quot; data-ratio=&quot;0.89&quot; data-type=&quot;png&quot; data-w=&quot;300&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们定义一个“数据变换”的函数，然后将它应用再 Salary 列上，最后同数据清洗那一步同样的替换操作，我们这里用平均值替换。&lt;/p&gt;
&lt;h3 data-source-line=&quot;164&quot;&gt;总结下&lt;/h3&gt;
&lt;p&gt;至此我们算走完数据预处理的一个基本流程。这是比较基础的一个小应用。但是相信我们以后处理数据的时候能有一个基本清晰的解决思路，以及如何选择处理方法以及为什么选择有所了解。&lt;/p&gt;
&lt;p&gt;数据挖掘一路走来，也有几十年的历史了，数据预处理每个步骤都开发出很多的方法。由于不一致或脏数据的数量巨大，以及问题本身的复杂性，数据预处理仍然是一个活跃的研究领域。篇幅所限，无法一一叙述，以后会再深入。&lt;/p&gt;
&lt;p&gt;我整理了数据预处理的一个思维导图，对系统了解数据预处理有一定帮助，一直都相信了解体系对于学习能起到重要作用。有需要关注公众号回复【数据预处理】获得。&lt;/p&gt;
&lt;p&gt;ps:本文所用例子的数据集以及代码有需要可以点击下面链接下载&lt;/p&gt;
&lt;p&gt;&lt;em&gt;https://github.com/Tomcccc/Blog&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;推荐阅读：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUyMTk4NzQzNg==&amp;amp;mid=2247483760&amp;amp;idx=1&amp;amp;sn=9a82a66ae7c4b272f5f64d571f8aba06&amp;amp;chksm=f9d3f573cea47c6575a8f60572a4c650174df2206bc65b29917ae3e2157241a37a01d79ab7ba&amp;amp;scene=21&amp;amp;token=487325609&amp;amp;lang=zh_CN#wechat_redirect&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;一个数据仓库时代开始--Hive&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUyMTk4NzQzNg==&amp;amp;mid=2247483724&amp;amp;idx=1&amp;amp;sn=437f687a1c538941ae7fc2b0a44fe261&amp;amp;chksm=f9d3f54fcea47c590f74250e67d76c987aea1af383e35c4f9e34339a89644dc4971d57800baf&amp;amp;scene=21&amp;amp;token=1411479704&amp;amp;lang=zh_CN#wechat_redirect&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;不一样的并发编程 -- Actor 并发编程模型&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUyMTk4NzQzNg==&amp;amp;mid=2247483780&amp;amp;idx=1&amp;amp;sn=b98b78763d6154f278cfc274bf5534ef&amp;amp;chksm=f9d3f587cea47c9145ae34a5feabfdb6ee9b6094a17c0b5ab828c02d696d007953e439d3815f&amp;amp;scene=21&amp;amp;token=1411479704&amp;amp;lang=zh_CN#wechat_redirect&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;数据的相似性和相异性我们可以怎么分析&lt;/a&gt;&lt;/p&gt;
&lt;p data-source-line=&quot;1&quot;&gt;&lt;strong&gt; 本文首发微信公众号“哈尔的数据城堡”.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/roPWrjQ5nUF5wkrkByF4Kh3VwTvAE762K0icDf8BoOfLqFXDgKVmBLU9iaOcia1vWyxJa7fIiaVZv3ednVhJNADukQ/640?wx_fmt=png&quot; alt=&quot;&quot; data-ratio=&quot;0.5180467091295117&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;471&quot;/&gt;                                                                &lt;/p&gt;

</description>
<pubDate>Mon, 07 Jan 2019 07:02:00 +0000</pubDate>
<dc:creator>蕉爷</dc:creator>
<og:description>数据挖掘的核心是什么？这个的答案是算法应该没什么疑问。那数据挖掘的基石又是什么呢？那就是今天我们要来说的数据预处理。 什么是数据预处理？ 数据科学家们一直想为数据预处理赋予一个定义。其实简单地说，数据</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Alear/p/10233307.html</dc:identifier>
</item>
<item>
<title>当Flutter遇到节流与防抖 - 阿尔卑斯de秘密</title>
<link>http://www.cnblogs.com/lunlunshiwo/p/10233185.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lunlunshiwo/p/10233185.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;相信web前端的开发者都或多或少的遇到过节流与防抖的问题。函数节流和函数防抖，两者都是优化执行代码效率的一种手段。在一定时间内，代码执行的次数不一定是越多越好。相反，频繁的触发或者执行代码，会造成大量的重绘等问题，影响浏览器或者机器资源。因此把代码的执行次数控制在合理的范围。既能节省浏览器CPU资源，又能让页面浏览更加顺畅，不会因为js的执行而发生卡顿。这就是函数节流和函数防抖要做的事。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在最近由我为国内某航空开发的某空货管理App中，简单的使用了一下关于节流与防抖的思路对流程进行了优化。&lt;/p&gt;
&lt;h2 id=&quot;节流与防抖&quot;&gt;节流与防抖&lt;/h2&gt;
&lt;p&gt;函数节流是指一定时间内js方法只跑一次。比如人的眨眼睛，就是一定时间内眨一次。&lt;/p&gt;
&lt;p&gt;而函数防抖是指频繁触发的情况下，只有足够的空闲时间，才执行代码一次。比如生活中的坐公交，就是一定时间内，如果有人陆续刷卡上车，司机就不会开车。只有别人没刷卡了，司机才开车。&lt;/p&gt;
&lt;h2 id=&quot;flutter的节流&quot;&gt;Flutter的节流&lt;/h2&gt;
&lt;p&gt;函数节流，简单地讲，就是让一个函数无法在很短的时间间隔内连续调用，只有当上一次函数执行后过了你规定的时间间隔，才能进行下一次该函数的调用。&lt;/p&gt;
&lt;p&gt;放到业务中分析节流函数：&lt;/p&gt;
&lt;pre class=&quot;dart&quot;&gt;
&lt;code&gt;class MyStatefulWidgetState extends State&amp;lt;OrderPageEdit&amp;gt; {
  bool canScanning; //是否可以扫描
  //扫描控制流
  final Stream&amp;lt;dynamic&amp;gt; _barScanner =
      EventChannel('com.freshport.freshport/barcode').receiveBroadcastStream();
  StreamSubscription&amp;lt;dynamic&amp;gt; _barScannerSubscription;

  @override
  void initState() {
    super.initState();
    _barScannerSubscription = _barScanner.listen((data) {
      if (!canScanning) return;
      setState(() {
        canScanning = false;
      });
      scanning(data);
    });
  }

  @override
  void dispose() {
    _barScannerSubscription.cancel();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Widget;
  }

  //扫面获取
  scanning(goodsCode) async {
    final result = await fetch.fetch(url: 'www.nicai.com');
    setState(() {
      canScanning = true;
    });
    if (result.result) {
    } else {}
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解释一下这段代码，因为这个项目是有扫描条形码进行货物移库的操作，我们的期望是扫描一次，从数据库中读取完成增加到列表中一个货物。因此，在此之前即使扫描也无法读取。因此我在&lt;code&gt;_barScanner&lt;/code&gt;的监听函数中增加一个flag标志位的判断，这个标志位用于判断是否在读取中，读取完成后将flag置成&lt;code&gt;true&lt;/code&gt;。此时就可以继续扫描。&lt;br/&gt;当然，我这个节流函数并未像有些截留函数那样带有明显的不可触发时间，这个函数的不可触发时间为加载的时间。&lt;/p&gt;
&lt;h2 id=&quot;flutter的防抖&quot;&gt;Flutter的防抖&lt;/h2&gt;
&lt;p&gt;防抖函数的定义为多次触发事件后，事件处理函数只执行一次，并且是在触发操作结束时执行。其原理是对处理函数进行延时操作，若设定的延时到来之前，再次触发事件，则清除上一次的延时操作定时器，重新定时。&lt;/p&gt;
&lt;p&gt;防抖函数多用于处理实时搜索，拖拽，登录用户名密码格式验证。在js的环境中，我们一般使用定时函数setTimeout进行防抖处理。同样的原理，在Flutter中，我们会原则定时函数（或者叫延时函数进行处理）。&lt;/p&gt;
&lt;p&gt;在一个输入框对应的时时搜索中，我使用了防抖处理：&lt;/p&gt;
&lt;pre class=&quot;dart&quot;&gt;
&lt;code&gt;class MyStatefulWidgetState extends State&amp;lt;GoodsCodeList&amp;gt; {
  //检索输入
  final TextEditingController _textController = TextEditingController();
  //设置防抖周期为3s
  Duration durationTime = Duration(seconds: 3);
  Timer timer;

  @override
  void initState() {
    super.initState();
  }

  @override
  void dispose() {
    _textController.clear();
    timer?.cancel();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return TextField(
        controller: _textController,
        decoration: InputDecoration(
            contentPadding: EdgeInsets.all(5.0),
            hintText: &quot;请输入商品编码&quot;,
            prefixIcon: Icon(Icons.search, color: Colors.black),
            focusedBorder: OutlineInputBorder(
              borderSide: BorderSide(color: Colors.black),
            ),
            border:
                OutlineInputBorder(borderRadius: BorderRadius.circular(3.0))),
        onChanged: (String text) {
          //限制加节流
          if (text.trim().length &amp;lt; 5) return;
          setState(() {
            timer?.cancel();
            timer = new Timer(durationTime, () {
              //搜索函数
            });
          });
        });
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如代码所示，先设置一个 &lt;strong&gt;Timer&lt;/strong&gt; 对象,当输入框&lt;strong&gt;TextField&lt;/strong&gt;持续输入时，会一直触发 &lt;strong&gt;Timer&lt;/strong&gt;对象的&lt;strong&gt;cancel&lt;/strong&gt;事件，既取消，然后会重新给&lt;strong&gt;Timer&lt;/strong&gt;赋值新的周期为&lt;strong&gt;3s&lt;/strong&gt;的定时函数。当&lt;strong&gt;3s&lt;/strong&gt;中内不输入信息时，这个定时函数会触发。但是三秒钟内&lt;strong&gt;再次输入&lt;/strong&gt;，这个定时函数又会被取消然后赋值新的周期为&lt;strong&gt;3s&lt;/strong&gt;的定时函数。&lt;/p&gt;
&lt;p&gt;这就是防抖函数的实际应用。&lt;/p&gt;
&lt;h2 id=&quot;收尾&quot;&gt;收尾&lt;/h2&gt;
&lt;p&gt;我们在js的代码中会经常接触到函数节流与防抖，是因为在js中，DOM操作(onresize, onscroll等等操作)是最消耗性能的，但是一些场景中同一事件会多次触发，为了减少操作，从而有了防抖和节流的概念。其实在很多开发中，我们还是可以使用防抖和节流减少不必要的一些操作和ajax请求的。&lt;/p&gt;
</description>
<pubDate>Mon, 07 Jan 2019 06:45:00 +0000</pubDate>
<dc:creator>阿尔卑斯de秘密</dc:creator>
<og:description>相信web前端的开发者都或多或少的遇到过节流与防抖的问题。函数节流和函数防抖，两者都是优化执行代码效率的一种手段。在一定时间内，代码执行的次数不一定是越多越好。相反，频繁的触发或者执行代码，会造成大量</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lunlunshiwo/p/10233185.html</dc:identifier>
</item>
<item>
<title>程序配置的原则和实践以及 Spring Boot 支持方式 - 小陆</title>
<link>http://www.cnblogs.com/lane_cn/p/10233024.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lane_cn/p/10233024.html</guid>
<description>&lt;h2&gt;原则&lt;/h2&gt;
&lt;p&gt;软件需要在不同的环境中部署，代码是保持不变的，但是不同的运行环境存在差异，所以需要使用配置适应不同的环境。比如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;数据库，Redis，以及其他 后端服务 的配置；&lt;/li&gt;
&lt;li&gt;第三方服务的证书，如 oAuth、支付接口 等；&lt;/li&gt;
&lt;li&gt;每份部署特有的配置，如域名等。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;配置的原则是：代码与配置要严格分离，不允许在代码中使用常量保存配置。&lt;/p&gt;
&lt;p&gt;最常见的配置方式就是配置文件，按照配置文件的存储位置，可以分为内部配置和外部配置：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;内部配置：部署文件是发布产物的一部分，存储在发布目录中，甚至打包在一起，比如 jar 包里面的 properties 文件。这些配置文件在不同的环境间不存在差异，其实他们可以看做是部署产物的一部分，比如 Spring 用来定义类创建和注入关系的 xml 文件。从运维的角度来看，尽管他们是配置文件，实际上和写死代码没有什么区别。反过来说，如果某个配置项在不同环境中是有差异的，就不应该放到内部；&lt;/li&gt;
&lt;li&gt;外部配置：不在部署产物内，需要在部署环境上修改。需要注意不要把这样的文件提交到代码控制系统，总是有人不小心这样做。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;配置漂移&lt;/h2&gt;
&lt;p&gt;构建好的程序被部署在服务器上后，为了解决故障、性能优化、适应新的需求，需要对服务器和应用的配置进行更改。如果直接登录服务器修改某个配置，随着时间的推移和管理的复杂化，就会引发配置漂移。&lt;/p&gt;
&lt;p&gt;这种可以直接登录修改的服务器称为可变服务器。可变服务器会造成开发、测试、生产服务器不一致，生产环境中不同的节点也不一致，容易出现运行问题。&lt;/p&gt;
&lt;p&gt;要防止配置漂移，服务器要禁止手动修改，只能通过自动化部署形式更改配置，这种服务器就叫不可变服务器。不可变服务器消除了不一致性，开发、测试环境中得到的程序包和最终到达服务器的程序包是完全相同的。这样就能防止配置漂移。&lt;/p&gt;
&lt;h2&gt;推荐方式&lt;/h2&gt;
&lt;p&gt;生产环境使用以下几配置种技术：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;配置文件：使用外部配置，按照 Linux 的目录规范在 &lt;code&gt;/etc&lt;/code&gt; 目录，或者其他合适的位置；&lt;/li&gt;
&lt;li&gt;启动参数：在启动参数中注入配置数据，这是防止配置漂移的好办法；&lt;/li&gt;
&lt;li&gt;环境变量：与启动参数相似，也是推荐的方式；&lt;/li&gt;
&lt;li&gt;配置服务：使用某种集中配置平台，比如 etcd、Zookeeper、Spring Cloud Config. 这些平台使用不同的协议，在数据结构、存储一致性方面有不同的设计思想，可以选择一个合适的。配置服务可以支持动态修改，比如 Spring Cloud Config 提供了 &lt;code&gt;refresh&lt;/code&gt; 端口，可以调动这个端口在不重启进程的情况下修改配置项。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;Spring Boot 配置方式&lt;/h2&gt;
&lt;p&gt;示例程序演示了 Spring Boot 配置方式，打包运行：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
mvn package
&lt;span class=&quot;pl-k&quot;&gt;export message=bonjour
java -Dmessage=hello \
    -jar spring-boot-config-sample-1.0.0-SNAPSHOT.jar \
    --message=hi \
    --spring.config.name=application,conf&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;message&lt;/code&gt; 配置出现在 4 个位置：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;系统环境变量 &lt;code&gt;export message=bonjour&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Java 属性 &lt;code&gt;-Dmessage=hello&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;命令行参数 &lt;code&gt;--message=hi&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;内部配置文件 &lt;code&gt;application.properties&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;启动之后在 &lt;code&gt;env&lt;/code&gt; 端口查看设置：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;19&quot;&gt;
&lt;pre&gt;
$ curl http://localhost:8080/actuator/env
{
    &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;propertySources&lt;span class=&quot;pl-pds&quot;&gt;&quot;:
    [
        {
            &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;name&lt;span class=&quot;pl-pds&quot;&gt;&quot;: &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;commandLineArgs&lt;span class=&quot;pl-pds&quot;&gt;&quot;,
            &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;properties&lt;span class=&quot;pl-pds&quot;&gt;&quot;:
            {
                &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;message&lt;span class=&quot;pl-pds&quot;&gt;&quot;:
                {
                    &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;value&lt;span class=&quot;pl-pds&quot;&gt;&quot;: &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;hi&lt;span class=&quot;pl-pds&quot;&gt;&quot;
                }
            }
        },
        {
            &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;name&lt;span class=&quot;pl-pds&quot;&gt;&quot;: &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;systemProperties&lt;span class=&quot;pl-pds&quot;&gt;&quot;,
            &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;properties&lt;span class=&quot;pl-pds&quot;&gt;&quot;:
            {
                &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;message&lt;span class=&quot;pl-pds&quot;&gt;&quot;:
                {
                    &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;value&lt;span class=&quot;pl-pds&quot;&gt;&quot;: &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;hello&lt;span class=&quot;pl-pds&quot;&gt;&quot;
                }
            }
        },
        {
            &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;name&lt;span class=&quot;pl-pds&quot;&gt;&quot;: &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;systemEnvironment&lt;span class=&quot;pl-pds&quot;&gt;&quot;,
            &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;properties&lt;span class=&quot;pl-pds&quot;&gt;&quot;:
            {
                &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;message&lt;span class=&quot;pl-pds&quot;&gt;&quot;:
                {
                    &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;value&lt;span class=&quot;pl-pds&quot;&gt;&quot;: &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;bonjour&lt;span class=&quot;pl-pds&quot;&gt;&quot;,
                    &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;origin&lt;span class=&quot;pl-pds&quot;&gt;&quot;: &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;System Environment Property &lt;span class=&quot;pl-cce&quot;&gt;\&quot;message&lt;span class=&quot;pl-cce&quot;&gt;\&quot;&lt;span class=&quot;pl-pds&quot;&gt;&quot;
                }
            }
        },
        {
            &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;name&lt;span class=&quot;pl-pds&quot;&gt;&quot;: &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;applicationConfig: [classpath:/application.properties]&lt;span class=&quot;pl-pds&quot;&gt;&quot;,
            &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;properties&lt;span class=&quot;pl-pds&quot;&gt;&quot;:
            {
                &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;message&lt;span class=&quot;pl-pds&quot;&gt;&quot;:
                {
                    &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;value&lt;span class=&quot;pl-pds&quot;&gt;&quot;: &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;nihao&lt;span class=&quot;pl-pds&quot;&gt;&quot;,
                    &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;origin&lt;span class=&quot;pl-pds&quot;&gt;&quot;: &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;class path resource [application.properties]:9:9&lt;span class=&quot;pl-pds&quot;&gt;&quot;
                }
            }
        }
    ]
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里删掉了一些无关的内容，可以看到 &lt;code&gt;message&lt;/code&gt; 设置是按照 &lt;code&gt;commandLineArgs&lt;/code&gt;、&lt;code&gt;systemProperties&lt;/code&gt;、&lt;code&gt;systemEnvironment&lt;/code&gt;、&lt;code&gt;applicationConfig&lt;/code&gt; 的顺序加载的，以最先出现的为准。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;spring.config.name&lt;/code&gt; 启动参数定义了配置文件的名称。Spring Boot 默认的配置文件是 &lt;code&gt;application.properties&lt;/code&gt;，这里添加了一个 &lt;code&gt;conf.properties&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;Spring Boot 按照特定的顺序加载配置项，位置和顺序如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;DevTool&lt;/code&gt; 定义的配置项&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@TestPropertySource&lt;/code&gt; 标签定义的配置项&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@SpringBootTest#properties&lt;/code&gt; 标签定义的配置项&lt;/li&gt;
&lt;li&gt;启动参数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SPRING_APPLICATION_JSON&lt;/code&gt; 环境变量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ServletConfig&lt;/code&gt; 定义的 &lt;code&gt;init&lt;/code&gt; 参数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ServletContext&lt;/code&gt; 定义的 &lt;code&gt;init&lt;/code&gt; 参数&lt;/li&gt;
&lt;li&gt;JNDI 属性&lt;/li&gt;
&lt;li&gt;Java 系统属性，使用 &lt;code&gt;-Dkey=value&lt;/code&gt; 定义，&lt;code&gt;System.getProperties()&lt;/code&gt; 可以查看到&lt;/li&gt;
&lt;li&gt;操作系统环境变量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RandomValuePropertySource&lt;/code&gt; 定义的随机值&lt;/li&gt;
&lt;li&gt;带 &lt;code&gt;profile&lt;/code&gt; 的外部配置文件&lt;/li&gt;
&lt;li&gt;带 &lt;code&gt;profile&lt;/code&gt; 的内部配置文件&lt;/li&gt;
&lt;li&gt;不带 &lt;code&gt;profile&lt;/code&gt; 的外部配置文件&lt;/li&gt;
&lt;li&gt;不带 &lt;code&gt;profile&lt;/code&gt; 的内部配置文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Configuration&lt;/code&gt; 类型里面的 &lt;code&gt;@PropertySource&lt;/code&gt; 标签定义的配置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SpringApplication.setDefaultProperties&lt;/code&gt; 方法设置的默认值&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;内外部配置文件的加载位置和顺序如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;config&lt;/code&gt; 目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.&lt;/code&gt; 当前目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;classpath:/config&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;classpath:/&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;Docker&lt;/h2&gt;
&lt;p&gt;使用 &lt;code&gt;Dockerfile&lt;/code&gt; 是在生产环境创建 Docker 镜像的唯一推荐方式，示例程序提供了 &lt;code&gt;Dockerfile&lt;/code&gt; 样例。&lt;code&gt;Dockerfile&lt;/code&gt; 将运行包和配置文件复制到镜像里：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
RUN mkdir -p /opt/stack
COPY target/spring-boot-config-sample-1.0.0-SNAPSHOT.jar /opt/stack/
COPY ./conf.properties /opt/stack/
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在环境变量和启动参数中注入配置项：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;12&quot;&gt;
&lt;pre&gt;
ENV message=bonjour
ENTRYPOINT [&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;java&lt;span class=&quot;pl-pds&quot;&gt;&quot;, \
    &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;-jar&lt;span class=&quot;pl-pds&quot;&gt;&quot;, \
    &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;spring-boot-config-sample-1.0.0-SNAPSHOT.jar&lt;span class=&quot;pl-pds&quot;&gt;&quot;, \
    &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;--spring.config.name=application,conf&lt;span class=&quot;pl-pds&quot;&gt;&quot;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;定义了健康检查规则：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
HEALTHCHECK --interval=30s --timeout=10s \
    CMD curl -f http://localhost:8080/actuator/health &lt;span class=&quot;pl-k&quot;&gt;|| &lt;span class=&quot;pl-c1&quot;&gt;exit 1&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;Dockerfile&lt;/code&gt; 里面还对镜像系统进行了设置，提高了打开文件句柄数。Docker 是实现不可变服务器的最佳方式。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot;&gt;
&lt;pre&gt;
RUN &lt;span class=&quot;pl-c1&quot;&gt;ulimit -n 65536&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用 &lt;code&gt;docker build&lt;/code&gt; 命令制作镜像，第一次运行会下载一个 &lt;code&gt;primetoninc/jdk&lt;/code&gt; 基础镜像，需要花一些时间：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
docker build -t config-sample &lt;span class=&quot;pl-c1&quot;&gt;.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用 &lt;code&gt;docker run&lt;/code&gt; 命令运行程序：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
docker run -it -p 8080:8080 config-sample
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在实际环境上可以使用 Kubernetes、Mesos 这样的平台管理和运行 Docker 镜像，完全可以避免直接登录服务器操作。&lt;/p&gt;
&lt;p&gt;本文代码示例：&lt;a href=&quot;https://github.com/lane-cn/spring-boot-config-sample&quot; target=&quot;_blank&quot;&gt;https://github.com/lane-cn/spring-boot-config-sample&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 07 Jan 2019 06:23:00 +0000</pubDate>
<dc:creator>小陆</dc:creator>
<og:description>原则 软件需要在不同的环境中部署，代码是保持不变的，但是不同的运行环境存在差异，所以需要使用配置适应不同的环境。比如： 数据库，Redis，以及其他 后端服务 的配置； 第三方服务的证书，如 oAut</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lane_cn/p/10233024.html</dc:identifier>
</item>
<item>
<title>DirectX11--实现一个3D魔方(1) - X_Jun</title>
<link>http://www.cnblogs.com/X-Jun/p/10230580.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/X-Jun/p/10230580.html</guid>
<description>&lt;p&gt;可以说，魔方跟我的人生也有一定的联系。&lt;/p&gt;
&lt;p&gt;在高中的学校接触到了魔方社，那时候的我虽然也能够还原魔方，可看到大神们总是可以非常快地还原，为此我也走上了学习高级公式CFOP的坑。当初学习的网站是在魔方小站，不过由于公式太多了，那一年主要也就学会了顶层公式PLL和底二层公式F2L，最好的时候大概30s能够复原一个魔方，不过后来还是退坑了。&lt;/p&gt;
&lt;p&gt;然后到了大学，参加考核的时候被要求用DirectX9来实现考题规定的游戏，我选择了魔方。然后在仅有12天的时间狂肝Direct3D 9，虽然那时候写的代码还比较生涩，不过至少实现的效果还是比较满意的，至少在可玩性上我感觉还不错，甚至可以用来竞速。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/MKXJun/Rubik-Cube&quot;&gt;Github项目--魔方&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个是DX9魔方的游玩过程。碍于图片最大只能上传10M，将就一下。&lt;br/&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/01/07/FbBdBV.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;嗯，现在距离这个Demo都已经过去快两年了，然后电脑应为一些不可抗因素把系统升到了Win10。然后现在，我居然运行不了所有的DirectX 9游戏，包括我之前写的demo也翻车了。不过目前我学DirectX 11断断续续也是差不过有两年了，然后重构的念头一直在我脑海中回响。写了大半年的教程，中间也积累了不少的代码，用现有的代码框架应该也可以很快搭建出来吧。现在开始一边开发一边记录自己的思路，所以现在你能看到的魔方也并不是最终版本。&lt;/p&gt;
&lt;p&gt;顺便下面安利一波本人正在编写的DX11教程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/X-Jun/p/9028764.html&quot;&gt;DirectX11 With Windows SDK完整目录&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;欢迎加入QQ群: 727623616 可以一起探讨DX11，以及有什么问题也可以在这里汇报。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如果你现在只是想考虑魔方的实现原理的话，那可以直接先跟着下面的教程开始。&lt;/strong&gt;我会尽可能的以自顶向下的方式来进行讲述。&lt;/p&gt;
&lt;p&gt;该项目的Direct3D 11源自&lt;strong&gt;Windows SDK&lt;/strong&gt;，注意不是DirectX SDK！这意味着只要你有Visual Studio 2015/2017，只要安装了C++相关的组件，打开本项目你就可以直接生成出来并运行了。&lt;/p&gt;
&lt;p&gt;说实话，即便是个看起来比较简单的魔方，内部的实现也是比较硬核的。而且因为是使用DirectX 11写的，对于正在学习或者想要学习DirectX 11的人来说，你必须要把很多底层的原理给弄懂，所以大多数人可能会偏向于先造一个自己的软引擎。以下是理解整个项目的要求：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;熟悉C++11和少量14，熟悉HLSL语法&lt;/li&gt;
&lt;li&gt;学习过线性代数和3D数学基础，了解渲染管线的流程&lt;/li&gt;
&lt;li&gt;初步了解Windows编程&lt;/li&gt;
&lt;li&gt;Direct3D 11的初始化&lt;/li&gt;
&lt;li&gt;HLSL的编译，顶点、索引、常量缓冲区的创建、绑定和修改&lt;/li&gt;
&lt;li&gt;纹理映射、纹理数组的加载&lt;/li&gt;
&lt;li&gt;第三人称摄像机&lt;/li&gt;
&lt;li&gt;鼠标拾取&lt;/li&gt;
&lt;li&gt;特效管理框架的实现(本项目不使用Effects11或FX11)&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;对了，本项目不打算使用光照。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了尽可能简化开发流程，我把之前写教程实现的大部分模块都搬过来这里用了，这样可以尽可能屏蔽底层实现而让我更专注于魔方本身的实现。如果要理解这些模块的功能你仍需要花费大量的时间来学习。&lt;/p&gt;
&lt;p&gt;首先列出项目的超长文件结构图（先不要被吓跑）。。。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1172605/201901/1172605-20190107134949342-221938165.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中从微软那边直接搬运过来的模块如下：&lt;/p&gt;

&lt;p&gt;然后是自己之前积累下来的一些模块，也包括龙书的：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Camera&lt;/td&gt;
&lt;td&gt;简易摄像机&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;d3dUtil&lt;/td&gt;
&lt;td&gt;包含了一些d3d常用的头文件和个人之前实现过的一些函数&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;DXTrace&lt;/td&gt;
&lt;td&gt;贡献了HR宏，用于错误追踪&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;GameTimer&lt;/td&gt;
&lt;td&gt;龙书的计时器&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Vertex&lt;/td&gt;
&lt;td&gt;包含了一些常用的顶点类型&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;由于上述代码都是已经实现好的，所以对我来说里面的实现现在可以忽略。&lt;/p&gt;
&lt;p&gt;而下面这些模块则是我需要重点进行修改的&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;d3dApp&lt;/td&gt;
&lt;td&gt;Direct3D和Windows的初始化&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;GameApp&lt;/td&gt;
&lt;td&gt;管理游戏的逻辑实现部分&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;BasicEffect&lt;/td&gt;
&lt;td&gt;特效、常量缓冲区的管理&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;然后基础游戏框架使用的本人项目13的&lt;code&gt;d3dApp&lt;/code&gt;和&lt;code&gt;GameApp&lt;/code&gt;。因此现在需要重点关注的就是着色器、特效管理、魔方相关和游戏逻辑的实现了。&lt;/p&gt;

&lt;p&gt;本项目的魔方预期实现的功能如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;实现魔方的单层旋转和整体旋转&lt;/li&gt;
&lt;li&gt;提供键盘和鼠标操作&lt;/li&gt;
&lt;li&gt;摄像机第三人称视角调整(看心情)&lt;/li&gt;
&lt;li&gt;检验魔方是否完成&lt;/li&gt;
&lt;li&gt;计时器、本地排行榜(看心情)&lt;/li&gt;
&lt;li&gt;天空盒(看心情)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;首先，魔方的6个面可以使用下面的枚举值来确定：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;enum RubikFace {
    RubikFace_PosX,     // +X面
    RubikFace_NegX,     // -X面
    RubikFace_PosY,     // +Y面
    RubikFace_NegY,     // -Y面
    RubikFace_PosZ,     // +Z面
    RubikFace_NegZ,     // -Z面
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这和天空盒指定面的枚举值是一致的。所谓的+X面你可以理解为从魔方中心发射一条+X轴的射线所指向的面，注意这是建立在左手坐标系的基础上确定的。&lt;/p&gt;
&lt;p&gt;然后，本项目提供了7种魔方纹理的颜色，由先的枚举值来确定：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;enum RubikFaceColor {
    RubikFaceColor_Black,       // 黑色
    RubikFaceColor_Orange,      // 橙色
    RubikFaceColor_Red,         // 红色
    RubikFaceColor_Green,       // 绿色
    RubikFaceColor_Blue,        // 蓝色
    RubikFaceColor_Yellow,      // 黄色
    RubikFaceColor_White        // 白色
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所谓的黑色是指藏在魔方内部平时看不到的面，但是在魔方旋转的时候可以看到露出的一部分。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1172605/201901/1172605-20190107133421660-2048265042.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里我准备了七张魔方表面的纹理贴图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1172605/201901/1172605-20190107133505848-555665345.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;目前立方体结构体&lt;code&gt;Cube&lt;/code&gt;的定义如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;struct Cube
{
    // 获取当前立方体的世界矩阵
    DirectX::XMMATRIX GetWorldMatrix() const;

    RubikFaceColor faceColors[6];   // 六个面的颜色，索引0-5分别对应+X, -X, +Y, -Y, +Z, -Z面
    DirectX::XMFLOAT3 pos;          // 旋转结束后中心所处位置
    DirectX::XMFLOAT3 rotation;     // 仅允许存在单轴旋转，记录当前分别绕x轴, y轴, z轴旋转的弧度

};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在我们不讨论&lt;code&gt;Cube::GetWorldMatrix&lt;/code&gt;的实现，你可以先默认它返回一个根据pos进行平移的矩阵。&lt;/p&gt;
&lt;p&gt;可以看到这个结构体甚至不存放什么顶点和索引数据，它只记录一下关键的信息。这么做是方便我判断魔方是否还原，以及尽可能最简化魔方的旋转操作。&lt;/p&gt;
&lt;p&gt;然后是魔方类&lt;code&gt;Rubik&lt;/code&gt;的初步定义：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;class Rubik
{
public:
    template&amp;lt;class T&amp;gt;
    using ComPtr = Microsoft::WRL::ComPtr&amp;lt;T&amp;gt;;

    // 初始化资源
    void InitResources(ComPtr&amp;lt;ID3D11Device&amp;gt; device, ComPtr&amp;lt;ID3D11DeviceContext&amp;gt; deviceContext);
    // 立即复原魔方
    void Reset();
    // 更新魔方状态
    void Update();
    // 绘制魔方
    void Draw(ComPtr&amp;lt;ID3D11DeviceContext&amp;gt; deviceContext, BasicEffect&amp;amp; effect);

private:
    // 魔方 [X][Y][Z]
    Cube mCubes[3][3][3];

    // 顶点缓冲区，包含6个面的24个顶点
    // 索引0-3对应+X面
    // 索引4-7对应-X面
    // 索引8-11对应+Y面
    // 索引12-15对应-Y面
    // 索引16-19对应+Z面
    // 索引20-23对应-Z面
    ComPtr&amp;lt;ID3D11Buffer&amp;gt; mVertexBuffer; 

    // 索引缓冲区，仅6个索引
    ComPtr&amp;lt;ID3D11Buffer&amp;gt; mIndexBuffer;
    
    // 纹理数组，包含7张纹理
    ComPtr&amp;lt;ID3D11ShaderResourceView&amp;gt; mTexArray;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;魔方的索引对应的关系满足左手坐标系，一级、二级、三级索引分别对应X轴、Y轴、Z轴方向上的偏移：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1172605/201901/1172605-20190107133552466-457886030.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意我们的魔方中心是始终位于世界坐标系的中心的，这样有利于我们对魔方进行旋转操作。此外你也可以看到，我将立方体六个正方形表面的24个顶点都同时存放在一个索引缓冲区中，在绘制的时候只需要设置顶点偏移量就可以指定当前绘制哪个面。所有的27个立方体都是依赖于这两个缓冲区，加上世界矩阵和纹理数组绘制出来的。&lt;/p&gt;
&lt;p&gt;当然上面的索引缓冲区实际上也是可以扔掉的，只需要将顶点缓冲区中的顶点次序稍微调整下，然后使用原始拓扑类型&lt;code&gt;D3D11_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP&lt;/code&gt;即可。正方形面此时顶点按索引的排布如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1172605/201901/1172605-20190107133609131-1835778317.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个类在后续我们还会进行修改。&lt;/p&gt;

&lt;p&gt;根据上面所给的数据结构，现在我需要初始化的数据有：纹理数组、顶点缓冲区、索引缓冲区、每个立方体的数据。&lt;/p&gt;
&lt;p&gt;其中顶点和索引直接在初始化中提供即可。下面是&lt;code&gt;Rubik::InitResources&lt;/code&gt;的实现：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void Rubik::InitResources(ComPtr&amp;lt;ID3D11Device&amp;gt; device, ComPtr&amp;lt;ID3D11DeviceContext&amp;gt; deviceContext)
{
    // 初始化纹理数组
    mTexArray = CreateDDSTexture2DArrayFromFile(
        device,
        deviceContext,
        std::vector&amp;lt;std::wstring&amp;gt;{
            L&quot;Resource/Black.dds&quot;,
            L&quot;Resource/Orange.dds&quot;,
            L&quot;Resource/Red.dds&quot;,
            L&quot;Resource/Green.dds&quot;,
            L&quot;Resource/Blue.dds&quot;,
            L&quot;Resource/Yellow.dds&quot;,
            L&quot;Resource/White.dds&quot;,
    });

    //
    // 初始化立方体网格模型
    //

    VertexPosTex vertices[] = {
        // +X面
        { XMFLOAT3(1.0f, -1.0f, -1.0f), XMFLOAT2(1.0f, 0.0f) },
        { XMFLOAT3(1.0f, 1.0f, -1.0f), XMFLOAT2(0.0f, 0.0f) },
        { XMFLOAT3(1.0f, 1.0f, 1.0f), XMFLOAT2(0.0f, 1.0f) },
        { XMFLOAT3(1.0f, -1.0f, 1.0f), XMFLOAT2(1.0f, 1.0f) },
        // -X面
        { XMFLOAT3(-1.0f, -1.0f, 1.0f), XMFLOAT2(1.0f, 0.0f) },
        { XMFLOAT3(-1.0f, 1.0f, 1.0f), XMFLOAT2(0.0f, 0.0f) },
        { XMFLOAT3(-1.0f, 1.0f, -1.0f), XMFLOAT2(0.0f, 1.0f) },
        { XMFLOAT3(-1.0f, -1.0f, -1.0f), XMFLOAT2(1.0f, 1.0f) },
        // +Y面
        { XMFLOAT3(-1.0f, 1.0f, -1.0f), XMFLOAT2(1.0f, 0.0f) },
        { XMFLOAT3(-1.0f, 1.0f, 1.0f), XMFLOAT2(0.0f, 0.0f) },
        { XMFLOAT3(1.0f, 1.0f, 1.0f), XMFLOAT2(0.0f, 1.0f) },
        { XMFLOAT3(1.0f, 1.0f, -1.0f), XMFLOAT2(1.0f, 1.0f) },
        // -Y面
        { XMFLOAT3(-1.0f, -1.0f, 1.0f), XMFLOAT2(1.0f, 0.0f) },
        { XMFLOAT3(-1.0f, -1.0f, -1.0f), XMFLOAT2(0.0f, 0.0f) },
        { XMFLOAT3(1.0f, -1.0f, -1.0f), XMFLOAT2(0.0f, 1.0f) },
        { XMFLOAT3(1.0f, -1.0f, 1.0f), XMFLOAT2(1.0f, 1.0f) },
        // +Z面
        { XMFLOAT3(1.0f, -1.0f, 1.0f), XMFLOAT2(1.0f, 0.0f) },
        { XMFLOAT3(1.0f, 1.0f, 1.0f), XMFLOAT2(0.0f, 0.0f) },
        { XMFLOAT3(-1.0f, 1.0f, 1.0f), XMFLOAT2(0.0f, 1.0f) },
        { XMFLOAT3(-1.0f, -1.0f, 1.0f), XMFLOAT2(1.0f, 1.0f) },
        // -Z面
        { XMFLOAT3(-1.0f, -1.0f, -1.0f), XMFLOAT2(1.0f, 0.0f) },
        { XMFLOAT3(-1.0f, 1.0f, -1.0f), XMFLOAT2(0.0f, 0.0f) },
        { XMFLOAT3(1.0f, 1.0f, -1.0f), XMFLOAT2(0.0f, 1.0f) },
        { XMFLOAT3(1.0f, -1.0f, -1.0f), XMFLOAT2(1.0f, 1.0f) },
    };

    // 设置顶点缓冲区描述
    D3D11_BUFFER_DESC vbd;
    ZeroMemory(&amp;amp;vbd, sizeof(vbd));
    vbd.Usage = D3D11_USAGE_IMMUTABLE;
    vbd.ByteWidth = sizeof vertices;
    vbd.BindFlags = D3D11_BIND_VERTEX_BUFFER;
    vbd.CPUAccessFlags = 0;
    // 新建顶点缓冲区
    D3D11_SUBRESOURCE_DATA initData;
    ZeroMemory(&amp;amp;initData, sizeof(initData));
    initData.pSysMem = vertices;
    HR(device-&amp;gt;CreateBuffer(&amp;amp;vbd, &amp;amp;initData, mVertexBuffer.ReleaseAndGetAddressOf()));
    

    WORD indices[] = { 0, 1, 2, 2, 3, 0 };
    // 设置索引缓冲区描述
    D3D11_BUFFER_DESC ibd;
    ZeroMemory(&amp;amp;ibd, sizeof(ibd));
    ibd.Usage = D3D11_USAGE_IMMUTABLE;
    ibd.ByteWidth = sizeof indices;
    ibd.BindFlags = D3D11_BIND_INDEX_BUFFER;
    ibd.CPUAccessFlags = 0;
    // 新建索引缓冲区
    initData.pSysMem = indices;
    HR(device-&amp;gt;CreateBuffer(&amp;amp;ibd, &amp;amp;initData, mIndexBuffer.ReleaseAndGetAddressOf()));

    // 初始化魔方所有面
    Reset();

    // 预先绑定顶点/索引缓冲区到渲染管线
    UINT strides[1] = { sizeof(VertexPosTex) };
    UINT offsets[1] = { 0 };
    deviceContext-&amp;gt;IASetVertexBuffers(0, 1, mVertexBuffer.GetAddressOf(), strides, offsets);
    deviceContext-&amp;gt;IASetIndexBuffer(mIndexBuffer.Get(), DXGI_FORMAT_R16_UINT, 0);

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而&lt;code&gt;Rubik::Reset&lt;/code&gt;用来方便一次性还原魔方：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void Rubik::Reset()
{
    // 初始化魔方中心位置，用六个面默认填充黑色
    for (int i = 0; i &amp;lt; 3; ++i)
        for (int j = 0; j &amp;lt; 3; ++j)
            for (int k = 0; k &amp;lt; 3; ++k)
            {
                mCubes[i][j][k].pos = XMFLOAT3(-2.0f + 2.0f * i,
                    -2.0f + 2.0f * j, -2.0f + 2.0f * k);
                mCubes[i][j][k].rotation = XMFLOAT3();
                memset(mCubes[i][j][k].faceColors, 0, 
                    sizeof mCubes[i][j][k].faceColors);
            }
    
    

    // +X面为橙色，-X面为红色
    for (int j = 0; j &amp;lt; 3; ++j)
        for (int k = 0; k &amp;lt; 3; ++k)
        {
            mCubes[2][j][k].faceColors[RubikFace_PosX] = RubikFaceColor_Orange;
            mCubes[0][j][k].faceColors[RubikFace_NegX] = RubikFaceColor_Red;
        }   

    // +Y面为绿色，-Y面为蓝色
    for (int i = 0; i &amp;lt; 3; ++i)
        for (int k = 0; k &amp;lt; 3; ++k)
        {
            mCubes[i][2][k].faceColors[RubikFace_PosY] = RubikFaceColor_Green;
            mCubes[i][0][k].faceColors[RubikFace_NegY] = RubikFaceColor_Blue;
        }

    // +Z面为黄色，-Z面为白色
    for (int i = 0; i &amp;lt; 3; ++i)
        for (int j = 0; j &amp;lt; 3; ++j)
        {
            mCubes[i][j][2].faceColors[RubikFace_PosZ] = RubikFaceColor_Yellow;
            mCubes[i][j][0].faceColors[RubikFace_NegZ] = RubikFaceColor_White;
        }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在&lt;code&gt;Rubik::InitResources&lt;/code&gt;中用到了我自己之前编写的&lt;code&gt;CreateDDSTexture2DArrayFromFile&lt;/code&gt;函数，里面要求传递的是dds纹理文件，但是我现在所拥有的魔方贴图全部都是从画图工具弄出来的png格式。为此，我还需要对纹理进行格式的转换。&lt;/p&gt;

&lt;p&gt;dxtex通常是在你安装了DirectX SDK后可以找到的，位于&lt;code&gt;Microsoft DirectX SDK\Utilities\bin\x86&lt;/code&gt;或&lt;code&gt;Microsoft DirectX SDK\Utilities\bin\x64&lt;/code&gt;中。没有安装该SDK的，你也可以在我的Github中找到：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/MKXJun/DirectX11-With-Windows-SDK/tree/master/Utility&quot;&gt;点此查看&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;打开dxtex，载入png位图&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1172605/201901/1172605-20190107134031470-1610976209.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后选择Format-Change Surface Format，将位图格式改为Unsigned 32-bit: A8R8G8B8&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1172605/201901/1172605-20190107133645555-1219639697.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;紧接着，我们需要给它生成mipmap，否则可能会导致在用大纹理绘制实际较小的部分时，某些倾斜的条纹会因为采样而产生类似锯齿状条纹：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1172605/201901/1172605-20190107133659270-1382540967.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而且就是开了4倍MSAA都拯救不了这么强烈的锯齿感！&lt;/p&gt;
&lt;p&gt;点击Format-Generate Mip Maps，程序自动为其创建Mipmap。在View选项中你可以通过Smaller Mipmap Level来观察生成的mipmap。&lt;/p&gt;
&lt;p&gt;最后选择File-Save As，直接另存为.dds文件即可。&lt;/p&gt;

&lt;p&gt;该框架的流程图如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1172605/201901/1172605-20190107133756088-604513026.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中需要我做修改的部分主要落在了&lt;code&gt;GameApp::Init&lt;/code&gt;, &lt;code&gt;GameApp::UpdateScene&lt;/code&gt; 和&lt;code&gt;GameApp::DrawScene&lt;/code&gt;上。&lt;/p&gt;
&lt;h2 id=&quot;gameappinitresources方法&quot;&gt;GameApp::InitResources方法&lt;/h2&gt;
&lt;p&gt;该方法随&lt;code&gt;GameApp::Init&lt;/code&gt;调用，用于初始化游戏所需的资源：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;bool GameApp::InitResource()
{
    // 初始化魔方
    mRubik.InitResources(md3dDevice, md3dImmediateContext);
    
    // 初始化特效、着色器资源
    mBasicEffect.SetRenderDefault(md3dImmediateContext);
    mBasicEffect.SetViewMatrix(XMMatrixLookAtLH(
        XMVectorSet(6.0f, 6.0f, -6.0f, 1.0f),
        XMVectorSet(0.0f, 0.0f, 0.0f, 1.0f),
        XMVectorSet(0.0f, 1.0f, 0.0f, 1.0f)
    ));
    mBasicEffect.SetProjMatrix(XMMatrixPerspectiveFovLH(
        XM_PI / 3, AspectRatio(), 1.0f, 1000.0f
    ));
    mBasicEffect.SetTextureArray(mRubik.GetTexArray());
    

    return true;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于&lt;code&gt;mBasicEffect&lt;/code&gt;，你现在暂时不需要知道它底层原理，可以先把它当做一个类似于&lt;code&gt;ID3DX11Effect&lt;/code&gt;的对象。它可以用于设置默认的渲染模式，以及各项所需的资源给HLSL，包括世界矩阵、观察矩阵、投影矩阵和纹理数组。&lt;/p&gt;
&lt;p&gt;着色器的具体实现这里我们也先不提，我们把更细节的内容留到后续的章节来讲。现在要做的，就是利用现有的框架先把这个魔方给绘制出来。&lt;/p&gt;
&lt;h2 id=&quot;gameappdrawscene方法&quot;&gt;GameApp::DrawScene方法&lt;/h2&gt;
&lt;p&gt;目前&lt;code&gt;GameApp::UpdateScene&lt;/code&gt;还没有做任何事情，可以不管。&lt;code&gt;GameApp::DrawScene&lt;/code&gt;的实现如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void GameApp::DrawScene()
{
    assert(md3dImmediateContext);
    assert(mSwapChain);

    // 使用偏紫色的纯色背景
    float backgroundColor[4] = { 0.45882352f, 0.42745098f, 0.51372549f, 1.0f };
    md3dImmediateContext-&amp;gt;ClearRenderTargetView(mRenderTargetView.Get(), backgroundColor);
    md3dImmediateContext-&amp;gt;ClearDepthStencilView(mDepthStencilView.Get(), D3D11_CLEAR_DEPTH | D3D11_CLEAR_STENCIL, 1.0f, 0);
    
    // 绘制魔方
    mRubik.Draw(md3dImmediateContext, mBasicEffect);

    // 省略目前没有作为的部分...

    HR(mSwapChain-&amp;gt;Present(0, 0));
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后&lt;code&gt;Rubik::Draw&lt;/code&gt;的实现目前如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void Rubik::Draw(ComPtr&amp;lt;ID3D11DeviceContext&amp;gt; deviceContext, BasicEffect&amp;amp; effect)
{
    for (int i = 0; i &amp;lt; 3; ++i)
        for (int j = 0; j &amp;lt; 3; ++j)
            for (int k = 0; k &amp;lt; 3; ++k)
            {
                effect.SetWorldMatrix(mCubes[i][j][k].GetWorldMatrix());
                for (int face = 0; face &amp;lt; 6; ++face)
                {
                    effect.SetTexIndex(mCubes[i][j][k].faceColors[face]);
                    effect.Apply(deviceContext);
                    deviceContext-&amp;gt;DrawIndexed(6, 0, 4 * face);
                }
            }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过&lt;code&gt;BasicEffect::SetTexIndex&lt;/code&gt;我们可以指定当前绘制的立方体面使用的是纹理数组中的哪一个纹理。&lt;/p&gt;
&lt;p&gt;每绘制一个立方体中的一个表面，就需要切换一次世界矩阵，并应用所有的变更。&lt;/p&gt;
&lt;p&gt;由于我把所有的顶点都放在同一个缓冲区了，只需要在&lt;code&gt;ID3D11DeviceContext::DrawIndexed&lt;/code&gt;指定起始顶点的偏移量即可。&lt;/p&gt;
&lt;p&gt;最终的效果如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1172605/201901/1172605-20190107133814736-999960766.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;目前的开发进度用了我半天时间，然后还有大半天的时间用来写这篇博客，理论上我稍微爆肝一点可能两天时间就可以弄出来了吧。虽然表面开发了半天，但为了这个教程至少也准备了大半年的时间。现在趁这个机会可以好好理顺一下自己的开发思路，可能要多花3-4天的时间。目前的项目我已经放到Github中了：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/MKXJun/Rubik-Cube&quot;&gt;Github项目--魔方&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下一篇可能会涉及：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;魔方的旋转(一些tricks)&lt;/li&gt;
&lt;li&gt;HLSL和特效管理&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;欢迎加入QQ群: 727623616 可以一起探讨DX11，以及有什么问题也可以在这里汇报。&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 07 Jan 2019 06:21:00 +0000</pubDate>
<dc:creator>X_Jun</dc:creator>
<og:description>前言 可以说，魔方跟我的人生也有一定的联系。 在高中的学校接触到了魔方社，那时候的我虽然也能够还原魔方，可看到大神们总是可以非常快地还原，为此我也走上了学习高级公式CFOP的坑。当初学习的网站是在魔方</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/X-Jun/p/10230580.html</dc:identifier>
</item>
<item>
<title>Python聚类模型原理及应用--批发商客户分群 - Star_Zhao</title>
<link>http://www.cnblogs.com/star-zhao/p/10209333.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/star-zhao/p/10209333.html</guid>
<description>&lt;p&gt;&lt;span&gt;在前面介绍的线性回归, 岭回归, Lasso回归, 逻辑回归均是监督学习, 下面将要介绍一种无监督学习—“聚类&quot;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/star-zhao/p/10209333.html#label1&quot;&gt;&lt;span&gt; 1. 划分聚类&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;a href=&quot;http://www.cnblogs.com/star-zhao/p/10209333.html#label2&quot;&gt;2. k-means算法&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;a href=&quot;http://www.cnblogs.com/star-zhao/p/10209333.html#label3&quot;&gt;3. 优缺点及注意事项&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;a href=&quot;http://www.cnblogs.com/star-zhao/p/10209333.html#label4&quot;&gt;4. 实际案例应用&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; “物以类聚，人以群分”, 所谓聚类就是将相似的元素分到一&quot;类&quot;(有时也被称为&quot;簇&quot;或&quot;集合&quot;), 簇内元素相似程度高, 簇间元素相似程度低. 常用的聚类方法有划分聚类, 层次聚类, 密度聚类, 网格聚类, 模型聚类等. 我们这里重点介绍划分聚类.&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;1. 划分聚类&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;划分聚类, 就是给定一个样本量为N的数据集, 将其划分为K个簇(K&amp;lt;N), 每一个簇中至少包含一个样本点.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;大部分的划分方法是基于距离的, 即簇内距离最小化, 簇间距离最大化. 常用的距离计算方法有: 曼哈顿距离和欧几里得距离. &lt;/span&gt;&lt;span&gt;坐标点(x&lt;sub&gt;1&lt;/sub&gt;, y&lt;sub&gt;1&lt;/sub&gt;)到坐标点(x&lt;sub&gt;2&lt;/sub&gt;, y&lt;sub&gt;2&lt;/sub&gt;)的曼哈顿距离和欧几里得距离分别表示为:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1469712/201901/1469712-20190103184532125-574721958.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了达到全局最优解, 传统的划分法可能需要穷举所有可能的划分点, 这计算量是相当大的. 而在实际应用中, 通常会通过计算到均值或中心点的距离进行划分来逼近局部最优, 把计算到均值和到中心点距离的算法分别称为K-MEANS算法和K-MEDOIDS算法, 在这里只介绍K-MEANS算法.&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;2. K-MEANS算法&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;K-MEANS算法有时也叫快速聚类算法, 其大致流程为:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一步: 随机选取K个点, 作为初始的K个聚类中心, 有时也叫质心.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第二步: 计算每个样本点到K个聚类中心的距离, 并将其分给距离最短的簇, 如果k个簇中均至少有一个样本点, 那么我们就说将所有样本点分成了K个簇.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第三步: 计算K个簇中所有样本点的均值, 将这K个均值作为K个新的聚类中心.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第四步: 重复第二步和第三步, 直到聚类中心不再改变时停止算法, 输出聚类结果.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;显然, 初始聚类中心的选择对迭代时间和聚类结果产生的影响较大, 选不好的话很有可能严重偏离最优聚类. 在实际应用中, 通常选取多个不同的K值以及初始聚类中心, 选取其中表现最好的作为最终的初始聚类中心. 怎么算表现最好呢? 能满足业务需求的, 且簇内距离最小的.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;簇内距离可以簇内离差平方和表示: &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1469712/201901/1469712-20190103225256136-8178708.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其中, K表示K个簇, n&lt;sub&gt;j&lt;/sub&gt;表示第j个簇中的样本个数, x&lt;sub&gt;i&lt;/sub&gt;表示样本, u&lt;sub&gt;j&lt;/sub&gt;表示第j个簇的质心, K-means算法中质心可以表示为:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1469712/201901/1469712-20190103225521468-551150224.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;3. 优缺点及注意事项&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;优点:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 原理简单, 计算速度快&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 聚类效果较理想.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;缺点:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. K值以及初始质心对结果影响较大, 且不好把握.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 在大数据集上收敛较慢.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3. 由于目标函数(簇内离差平方和最小)是非凸函数, 因此通过迭代只能保证局部最优.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4. 对于离群点较敏感, 这是由于其是基于均值计算的, 而均值易受离群点的影响.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5. 由于其是基于距离进行计算的, 因此通常只能发现&quot;类圆形&quot;的聚类.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意事项:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 由于其是基于距离进行计算的, 因此通常需要对连续型数据进行标准化处理来缩小数据间的差异.(对于离散型, 则需要进行one-hot编码)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 如果采用欧几里得距离进行计算的话, 单位的平方和的平方根是没有意义的, 因此通常需要进行无量纲化处理&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;4. 实际案例应用&lt;/h2&gt;
&lt;h3&gt;1. 数据来源及背景&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;数据来源: http://archive.ics.uci.edu/ml/machine-learning-databases/00292/, 它是某批发经销商的客户数据, 其中包含440个样本以及8个特征,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面将通过划分聚类中的k-means算法对这些客户进行细分.&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;2. 数据概览&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;1. 前2行和后2行&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; pandas as pd
df &lt;/span&gt;= pd.read_csv(r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;D:\aPython\Data\DataVisualization\Wholesale customers data.csv&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
pd.set_option(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;display.max_rows&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 4&lt;span&gt;)
df&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;8个字段分别表示批发商客户: 渠道, 地区, 以及每年分别在新鲜产品, 奶制品, 食品杂货, 冷冻产品, 洗涤剂和纸制品, 熟食这6种产品上的类别上的消费支出.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1469712/201901/1469712-20190104172005195-898210851.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 查看数据整体信息&lt;/span&gt;&lt;/p&gt;

&lt;pre&gt;
&amp;lt;class 'pandas.core.frame.DataFrame'&amp;gt;
RangeIndex: 440 entries, 0 to 439
Data columns (total 8 columns):
Channel             440 non-null int64
Region              440 non-null int64
Fresh               440 non-null int64
Milk                440 non-null int64
Grocery             440 non-null int64
Frozen              440 non-null int64
Detergents_Paper    440 non-null int64
Delicassen          440 non-null int64
dtypes: int64(8)
memory usage: 27.6 KB
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;没有缺失值, 且均为整数型.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3. 描述性统计&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
df.describe()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;有两种渠道来源, 和三种地区, 各自分别占多少还需要进一步探索. &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;新鲜产品每年支出: 范围3~112151, 中位数为8504, 均值为12000, 呈现右偏分布&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;奶制品每年支出: 范围55~73498, 中位数为3627, 均值为5796, 呈现右偏分布&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;食品杂货每年支出: 范围3~92780, 中位数为4756, 均值为7951, 呈现右偏分布&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;冷冻产品每年支出: 范围25~60869, 中位数为1526, 均值为3072, 呈现右偏分布&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;洗涤剂和纸制品每年支出: 范围3~40827, 中位数为817, 均值为2881, 呈现右偏分布&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;熟食每年支出: 范围3~47943, 中位数为965, 均值为1525, 呈现右偏分布&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1469712/201901/1469712-20190104180049746-522743215.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4. 偏态和峰态&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(2, 8&lt;span&gt;):
    name &lt;/span&gt;=&lt;span&gt; df.columns[i]
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(name)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;    偏态系数为 {0}, 峰态系数为 {1}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.format(df[name].skew(), df[name].kurt()))
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
Fresh
    偏态系数为 2.561322751927935, 峰态系数为 11.536408493056006
Milk
    偏态系数为 4.053754849210881, 峰态系数为 24.669397750673077
Grocery
    偏态系数为 3.5874286903915453, 峰态系数为 20.914670390919653
Frozen
    偏态系数为 5.9079856924559575, 峰态系数为 54.68928069737255
Detergents_Paper
    偏态系数为 3.6318506306913645, 峰态系数为 19.009464335418212
Delicassen
    偏态系数为 11.151586478906117, 峰态系数为 170.69493933454066
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;可以看到均表现为尖峰, 高度偏态分布.&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;3. 数据预处理&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;没有缺失值, 因此不用缺失值处理&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 异常值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在处理异常值之前, 先来通过箱线图看看异常值.&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; seaborn as sns
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; matplotlib.pyplot as plt
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_boxplot(data, start, end):
    fig, ax &lt;/span&gt;= plt.subplots(1, end-start, figsize=(24, 4&lt;span&gt;))
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(start, end):
        sns.boxplot(y&lt;/span&gt;=data[data.columns[i]], data=data, ax=ax[i-&lt;span&gt;start])
get_boxplot(df, &lt;/span&gt;2, 8)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1469712/201901/1469712-20190105180301666-946880970.png&quot; alt=&quot;&quot; width=&quot;1040&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;可以看到以上6个连续型变量均有不同程度的异常值, 由于k-means算法对异常值较敏感, 因此选择剔除它&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; drop_outlier(data, start, end):
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(start, end):
        field &lt;/span&gt;=&lt;span&gt; data.columns[i]
        Q1 &lt;/span&gt;= np.quantile(data[field], 0.25&lt;span&gt;)
        Q3 &lt;/span&gt;= np.quantile(data[field], 0.75&lt;span&gt;)
        deta &lt;/span&gt;= (Q3 - Q1) * 1.5&lt;span&gt;
        data &lt;/span&gt;= data[(data[field] &amp;gt;= Q1 - deta) &amp;amp; (data[field] &amp;lt;= Q3 +&lt;span&gt; deta)]
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; data
del_df &lt;/span&gt;= drop_outlier(df, 2, 8&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;原有样本容量:{0}, 剔除后样本容量:{1}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(df.shape[0], del_df.shape[0]))
get_boxplot(del_df, &lt;/span&gt;2, 8)
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
原有样本容量:440, 剔除后样本容量:318
&lt;/pre&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1469712/201901/1469712-20190105180813626-593718706.png&quot; alt=&quot;&quot; width=&quot;1040&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在剔除一次异常值之后, 6个连续变量的波动幅度也都都大致接近, 你可能会问为什么还有异常值存在? 现在的异常值是相对于新数据集产生的, 而我们把原数据集中的异常值已经剔除了, 通常来说, 对于异常值只需剔除一次即可, 如果彻底剔除的话, 样本容量可能会有大幅度的变化, 比如:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
df_new =&lt;span&gt; df.copy()
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;直到第10次的时候图像上才没有出现异常值&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(10&lt;span&gt;):
    df_new &lt;/span&gt;= drop_outlier(df_new, 2, 8&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;原有样本容量:{0}, 彻底剔除后样本容量:{1}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(df.shape[0], df_new.shape[0]))
get_boxplot(df_new, &lt;/span&gt;2, 8)
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
原有样本容量:440, 彻底剔除后样本容量:97
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1469712/201901/1469712-20190105182030443-86210704.png&quot; alt=&quot;&quot; width=&quot;1040&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以看到现在的数据集中已经不存在异常了, 但是样本容量也从440大幅度下降为97, 因此这里不建议彻底删除.&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;4. 可视化分析&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;这里直接采用seaborn的pairplot方法&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; seaborn as sns
sns.pairplot(del_df)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;变量之间存在不同程度的相关关系, 以及在剔除异常值之后连续型变量依然表现为高度偏态分布.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1469712/201901/1469712-20190105220658760-641840900.png&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;5. 特征工程&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;1. 离散型变量&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;将离散型变量处理成哑变量.&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
del_df[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Channel&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; del_df.Channel.astype(str)
del_df[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Region&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; del_df.Region.astype(str)
del_df &lt;/span&gt;= pd.get_dummies(del_df)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2. 连续型变量&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 由于连续型变量的数值范围有大有小, 为消除其对聚类结果的影响, 这里采用z-score进行归一化处理&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(6&lt;span&gt;):
    field &lt;/span&gt;=&lt;span&gt; del_df.columns[i]
    del_df[field] &lt;/span&gt;= del_df[field].apply(&lt;span&gt;lambda&lt;/span&gt; x: (x - del_df[field].mean()) / del_df[field].mean())
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;6. 聚类模型&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;1. 构建K=2的聚类模型&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; sklearn.cluster &lt;span&gt;import&lt;/span&gt;&lt;span&gt; KMeans
km &lt;/span&gt;= KMeans(n_clusters=2, random_state=10&lt;span&gt;)
km.fit(del_df)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(km.cluster_centers_) 
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(km.labels_)
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
[[ 0.08057098 -0.36005276 -0.42021772  0.11899282 -0.66737726 -0.10885484
   0.97333333  0.02666667  0.2         0.10222222  0.69777778]
 [-0.19492979  0.8710954   1.01665578 -0.28788585  1.61462241  0.26335849
   0.13978495  0.86021505  0.10752688  0.07526882  0.8172043 ]]
[1 1 0 1 1 1 0 1 1 0 1 1 1 0 1 1 0 0 0 1 0 0 0 0 0 0 0 1 1 1 0 1 1 1 0 0 1
 0 0 1 0 1 1 1 1 0 0 1 0 0 1 0 0 0 0 1 1 0 1 0 0 1 0 1 0 0 0 1 1 1 0 0 1 1
 0 1 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
 0 0 1 0 1 1 1 0 0 1 1 0 0 0 1 0 0 1 0 0 0 0 1 0 0 0 1 1 1 0 0 1 0 1 0 0 0
 0 0 1 0 0 0 1 1 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0
 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 1 0 0 0 1 1 0 1 1 1
 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 1 1 0 1 1 1 0 0 0 0 0 0 0 0 0 0
 0 0 1 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 1 1
 0 1 0 1 1 1 1 0 1 1 0 0 1 1 0 0 0 0 0 0 0 0]
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;将客户分为2类到底合不合适呢? 通过迭代的方式来选择.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 迭代选择合适的k值&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; matplotlib.pyplot as plt
K &lt;/span&gt;= range(1, 10&lt;span&gt;)
sse &lt;/span&gt;=&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; k &lt;span&gt;in&lt;/span&gt;&lt;span&gt; K:
    km &lt;/span&gt;= KMeans(n_clusters=k, random_state=10&lt;span&gt;)
    km.fit(del_df)
    sse.append(km.inertia_)
plt.figure(figsize&lt;/span&gt;=(8, 6&lt;span&gt;))
plt.plot(K, sse, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-o&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, alpha=0.7&lt;span&gt;)
plt.xlabel(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
plt.ylabel(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SSE&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
plt.show()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1469712/201901/1469712-20190106010810574-1795169066.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;根据肘部法则, 选择K=2, 也就是说将客户分成两群.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3. 客户分群&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; pandas.plotting &lt;span&gt;import&lt;/span&gt;&lt;span&gt; parallel_coordinates
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;训练模型&lt;/span&gt;
km = KMeans(n_clusters=2, random_state=10&lt;span&gt;)
km.fit(del_df)
centers &lt;/span&gt;=&lt;span&gt; km.cluster_centers_ 
labels &lt;/span&gt;=&lt;span&gt;  km.labels_
customer &lt;/span&gt;= pd.DataFrame({&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: centers[0], &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: centers[1&lt;span&gt;]}).T
customer.columns &lt;/span&gt;=&lt;span&gt; del_df.keys()
df_median &lt;/span&gt;= pd.DataFrame({&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: del_df.median()}).T
customer &lt;/span&gt;=&lt;span&gt; pd.concat([customer, df_median])
customer[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;category&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] = [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;customer_1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;customer_2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;median&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;绘制图像&lt;/span&gt;
plt.figure(figsize=(12, 6&lt;span&gt;))
parallel_coordinates(customer, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;category&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, colormap=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;flag&lt;/span&gt;&lt;span&gt;''&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
plt.xticks(rotation = 15&lt;span&gt;)
plt.show()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;从6种产品每年消费支出来看, 客户群1在冷冻产品上最高, 在洗涤剂和纸制品上最低, 而客户群2则在冷冻产品上最低, 在洗涤剂和纸制品上最高, 且客户群2在6种产品的消费支出均高于中位数水平, 因此客户群2为重要客户, 客户群1则是一般客户.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1469712/201901/1469712-20190106170127839-989973315.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4. 最终分群结果&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;将聚类后的标签加入数据集&lt;/span&gt;
del_df[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;category&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; labels
del_df[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;category&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = np.where(del_df.category == 0, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;customer_1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;customer_2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
customer &lt;/span&gt;= pd.DataFrame({&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: centers[0], &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: centers[1&lt;span&gt;]}).T
customer[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;category&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] = [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;customer_1_center&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;customer_2_center&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
customer.columns &lt;/span&gt;=&lt;span&gt; del_df.keys()
del_df &lt;/span&gt;=&lt;span&gt; pd.concat([del_df, customer])
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;对6类产品每年消费水平进行绘制图像&lt;/span&gt;
df_new = del_df[[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Fresh&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Milk&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Grocery&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Frozen&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Detergents_Paper&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Delicassen&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;category&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]]
plt.figure(figsize&lt;/span&gt;=(18, 6&lt;span&gt;))
parallel_coordinates(df_new, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;category&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, colormap=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;cool&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.xticks(rotation &lt;/span&gt;= 15&lt;span&gt;)
plt.show()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 通过下图可以看到, 最终的聚类效果较理想, 其中客户群1(一般客户)在图像上表现较为密集, 代表其数量多, 而客户群2(重要客户)在图像上则较稀疏, 数量较少.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1469712/201901/1469712-20190106193701355-1392237038.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参考资料:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;网易云课堂《吴恩达机器学习》&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;《数据分析与挖掘实战》&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;声明: 本文仅用于学习交流&lt;/p&gt;
</description>
<pubDate>Mon, 07 Jan 2019 06:19:00 +0000</pubDate>
<dc:creator>Star_Zhao</dc:creator>
<og:description>前言 在前面介绍的线性回归, 岭回归, Lasso回归, 逻辑回归均是监督学习, 下面将要介绍一种无监督学习—“聚类&quot; 目录 1. 划分聚类 2. k-means算法 3. 优缺点及注意事项</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/star-zhao/p/10209333.html</dc:identifier>
</item>
<item>
<title>JavaScrpt中的this指向规则 - 他乡踏雪</title>
<link>http://www.cnblogs.com/ZheOnaAndOnly/p/10226506.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ZheOnaAndOnly/p/10226506.html</guid>
<description>&lt;p&gt;首先，JavaScript的this指向问题并非传说中的那么难，不难的是机制并不复杂，而被认为不好理解的是逻辑关系和容易混淆的执行上下文。这篇博客也就会基于这两个不好理解的角度来展开，如要要严格的来对this的指向来分类的话，有三类不同的情况，一种是独立函数执行的指向机制，第二种就是引用指向机制，第三种是new机制下的this指向。然后建立在这三个指向机制的基础上来剖析一些this的常见问题，下面进入正文解析this指向机制：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、独立函数执行的指向机制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在JavaScript中函数执行可以分为两种情况，一种是函数纯粹的执行，另一种是被某个对象引用执行。函数纯粹的执行也通常被描述为独立函数执行，这种情况的函数执行内部this指向全局对象，但是在严格模式下独立函数执行this会指向undefined。注意，机制的本身非常简单，但是容易出错的却在函数被调用的机制上，如果再在这个问题上深入的追溯问题的根源的话，其本身的问题是出在JavaScript对象与对象的属性和方法的归属关系问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1.1指向全局与指向undefined&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; foo(){
    console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.a);
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; a = 2&lt;span&gt;;
foo();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个运行结果证明了独立的函数执行的this指向了全局对象，接下来我们再看看严格模式下的独立函数的this的指向。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; foo(){
    &lt;/span&gt;&quot;use strict&quot;&lt;span&gt;;
    console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.a);
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; a = 2&lt;span&gt;;
foo();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;TypeError: Cannot read property 'a' of undefined&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从错误提示可以看出来，严格模式下的this指向是undefined。但是这两个函数的执行能不能就代表全部的纯函数执行就是这个机制呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1.2this向与赋值机制&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; foo(){
    console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.a);
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; obj =&lt;span&gt; {
    a:&lt;/span&gt;2&lt;span&gt;,
    foo:foo
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; bar =&lt;span&gt; obj.foo;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; a = 1&lt;span&gt;;
bar();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行结果为什么是1？因为bar是一个纯函数执行啊。很难理解这部分机制的大多都是学习后台强属性语言，因为在强属性语言中，属性的归属永远都是一个对象的，但是在JavaScript中所有的函数都是一个独立的个体，它不属于任何对象，又可以是任何对象的方法。当函数在不被任何对象引用执行的时候它就算是一个独立函数，可能有的人会理解为var bar = obj.foo是对象引用啊，记住在JavaScript中，这行代码的函数是赋值，bar获得是foo函数的堆内存地址，不会记录obj的关联性。而在强属性语言中，这种赋值就不只是把函数赋给一个变量了，同时还会带着这个函数的关联对象的关系一起赋给这个变量，所以这就是JavaScript的赋值机制给this带来的问题。&lt;/p&gt;
&lt;p&gt;关于个赋值机制这段代码可能还不能完全说服你，因为foo函数被声明在全局，那下面来看看下面这段修改后的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; obj =&lt;span&gt; {
    a:&lt;/span&gt;2&lt;span&gt;,
    foo:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
        console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.a);
    }
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; bar =&lt;span&gt; obj.foo;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; a = 1&lt;span&gt;;
bar();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;引用方法赋值行为，接收方法的变量不会接收引用关系，获得的是一个独立函数的纯粹堆内存引用，这对理解this引用很重要。而且还有值得我们注意的一个地方就是通过参数的传值行为本质上也只是函数的纯粹赋值而已，不会带着引用关系传递到形参上的。看下面这段代码来理解这种机制：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; obj =&lt;span&gt; {
    a:&lt;/span&gt;2&lt;span&gt;,
    foo:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
        console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.a);
    }
}
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; bar(fn){
    fn();
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; a = 1&lt;span&gt;;
bar(obj.foo);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;JavaScript传值、赋值本质上都只是将函数的堆内存地址赋给变量而已，而上面这段代码有说明了另一个问题就是不管在什么地方，函数纯粹的执行它的this指向都是全局（fn嵌套在bar内，但是this还是指向了全局对象），然后这里又会延伸出一个新的问题，嵌套函数内严格模式，这里有一个细节值得注意。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; obj =&lt;span&gt; {
    a:&lt;/span&gt;2&lt;span&gt;,
    foo:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
        console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.a);
    }
}
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; bar(fn){
    &lt;/span&gt;&quot;use strict&quot;&lt;span&gt;;
    fn();
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; a = 1&lt;span&gt;;
bar(obj.foo);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;不是说严格模式下的this指向undefined吗？怎么这里的this还是指向了全局对象呢？&lt;/p&gt;
&lt;p&gt;不错，在严格模式下this指向会被修改为undefined，但是必须是当前作用域被设置了严格模式，看下面这段代码来理解：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; obj =&lt;span&gt; {
    a:&lt;/span&gt;2&lt;span&gt;,
    foo:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
        &lt;/span&gt;&quot;use strict&quot;&lt;span&gt;;
        console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.a);
    }
}
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; bar(fn){
    fn();
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; a = 1&lt;span&gt;;
bar(obj.foo);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Cannot read property 'a' of undefined&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;关于纯函数的执行this指向已经全部解析完，接下来我们继续引用函数执行的this指向机制。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、引用函数执行的this指向机制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;关于引用函数执行的this指向机制比起纯函数执行来说，要简单的多，唯一存在容易混淆不清的地方就是对象属性与作用域，很多时候我们都把作用域当做是对象，但实际上不是，他只是在某些情况下有些特性与对象类似而已。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; foo(){
    console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.a);
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; obj =&lt;span&gt; {
    a:&lt;/span&gt;1&lt;span&gt;,
    foo:foo
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; a = 3&lt;span&gt;;
obj.foo();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其实通过上面的示例我们可以看到函数内的this指向了引用函数执行的对象。其实从这个例子我们也可以反推出一个逻辑，那就是纯函数执行其实质并非是纯粹的函数执行，而是当函数没有被指定的对象引用执行的时候，函数其实质上是被全局对象隐式的引用执行，在严格模式下是被undefined隐式的引用执行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.1引用函数执行的this机制与赋值&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; foo(){
    console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.a);
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; obj =&lt;span&gt; {
    a:&lt;/span&gt;1&lt;span&gt;,
    foo:foo
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; obj1 =&lt;span&gt; {
    a:&lt;/span&gt;2&lt;span&gt;,
    obj:obj
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; a = 3&lt;span&gt;;
obj1.obj.foo();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们在前面对函数赋值机制做了深入剖析，再来看看对象赋值。将一个对象赋给另一个对象，再通过链式调用对象的方法，其本质上this还是遵循了引用执行机制，this指向直接调用函数的对象，再来看下一个示例就会更清楚了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; foo(){
    console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.a);
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; obj =&lt;span&gt; {
    foo:foo
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; obj1 =&lt;span&gt; {
    a:&lt;/span&gt;2&lt;span&gt;,
    obj:obj
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; a = 3&lt;span&gt;;
obj1.obj.foo();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;undefined&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当引用执行函数的对象没有函数执行需要的参数时，这个参数的值会默认为undefined，一定要注意，这种赋值调用，对象与对象之间并不是继承关系，仅仅只是一个调用关系。在对象原型链的博客里我会详细剖析引用执行函数的对象this指向及内部原型链的查询机制。&lt;/p&gt;
&lt;p&gt;2.2引用函数执行的this指向与call和apply&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; foo(){
    console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.a);
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; obj =&lt;span&gt; {
    a:&lt;/span&gt;1&lt;span&gt;
}
foo.call(obj);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的示例证明函数this指向了传入call方法的实参obj上了，并且会立即执行这个函数，call方法其本质上是一个非常简单的操作，只不过是实现了对象动态添加方法并且立即执行的一个行为而已。所以上面的代码可以显示的用下列代码静态添加方法并引用执行来完成：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; foo(){
    console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.a);
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; obj =&lt;span&gt; {
    a:&lt;/span&gt;1&lt;span&gt;,
    foo:foo
}
obj.foo();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面这两段代码从本质上来将是完全对等的操作，只不过通过call方法实现了动态添加执行，在obj对象上实质上是找不到foo这个方法的。关于call的this指向解析清楚以后，关于apply就很容易了，这两个方法的核心功能其实是一样的，都是将方法动态的绑定到指定的对象上然后引用执行这个方法。既然是方法要执行就必然会涉及到参数传递，这两个方法的差异就在于参数的传递有写差异，其他的完全一致。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; foo(a,b,c){
    console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.a + &quot;；参数：&quot; + a + b +&lt;span&gt; c);
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; obj =&lt;span&gt; {
    a:&lt;/span&gt;1&lt;span&gt;
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; a = &quot;a&quot;&lt;span&gt;,
    b &lt;/span&gt;= &quot;b&quot;&lt;span&gt;,
    c &lt;/span&gt;= &quot;c&quot;&lt;span&gt;,
    arr &lt;/span&gt;= [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&lt;span&gt;];
foo.call(obj,a,b,c);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1;参数：abc&lt;/span&gt;
foo.apply(obj,arr);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1;参数：abc&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;call的参数传递和普通的函数传参一致，都是单个一一传入，apply的参数传递方式是将实参打包成一个数组传入，数组的下标与形参的顺序一一对应，因为call和apply方法的第一个参数需要传入函数执行的引用对象，所以函数执行的参数都是从第二位开始传入。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;关于函数执行的this指向解析全部解析完，还记得在博客开头的我有提到关于this指向的执行上下文混淆的问题吗？这个问题主要出在当引用对象是一个回调函数的时候，就会容易混淆this的指向，这是因为我们经常把执行性上下单纯的看成一个对象来对待，这样的观点导致我们对this的指向很容易混淆不清，下面我们来看一段代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; foo(){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; a = 1&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; bar(){
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; a = 2&lt;span&gt;
        console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.a);
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; bar;
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; a = 3&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; baz(){
    console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.a);
}
baz.call(foo());&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;undefined&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;有点小惊讶吧，不是2，也不是3，而是undefined，这里有几个误区：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.通常我们都把call和apply两个方法的第一个参数成为执行上下文，这不完全正确。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.因为全局作用域会把变量和函数转成自身属性（即全局对象的属性），但是其他的函数的作用域不能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.通常我们把作用域成为执行上下文当做是一个对象，误认为把作用域内的变量和方法及调用执行方法的对象的属性都归为执行上下文对象的属性，这个误区可以算是上面两个误区的加强版。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这里我们先要试着理解执行上下文到底是个什么东西？然后才能弄清楚this指向的到底是什么？&lt;/p&gt;
&lt;p&gt;我们通常所表达的执行上下文其实质上包含了三个部分：&lt;span&gt;引用方法执行的对象，方法自身执行的作用域，除自身作用域的所有上层作用域。而this指向的是引用方法执行的对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上面的代码中，baz.call(foo())可以理解为时bar.baz()这样的引用执行方式，但是因为bar上没有baz这个方法，这样写会报错，而call和apply实质上在调用函数之前给引用执行方法的对象临时的做了一个添加方法的处理，只是这个方法会执行完以后就会被删除，表面上我们可以这么理解，但是引擎内部是不回做这种损耗效率的事情，call和apply的内部机制应该是一种又有效的动态的添加执行行为，这部分没有深入研究，有兴趣的朋友可以在评论区一起讨论。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其实这里应该还有一个关于bind的柯里化的this指向问题，这部分我写到柯里化那部分博客的时候，再考虑是在这篇博客上添加还是在柯里化部分的博客上扩展。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三、new机制下的this指向&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;关于new机制的this指向相对来说是最简单的，因为这个机制下的this是一个固定指向，只出现在通过function实例化对象的时候，不会出现在程序逻辑中。因为涉及一些对象实例化所以会在这里扩展一点对象实例化的内容，因为是一个交叉知识点，后期还会在对象原型机制的时候再做管理解析。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Car(name,height,lang,weight,health){
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.height =&lt;span&gt; height;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.lang =&lt;span&gt; lang;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.weight =&lt;span&gt; weight;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.health =&lt;span&gt; health;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.run = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.health --&lt;span&gt;;
    }
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; BMW = &lt;span&gt;new&lt;/span&gt; Car(&quot;BMW&quot;,1400,4900,1400,100&lt;span&gt;);
console.log(BMW);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在new机制下的this，指向新创建的对象。这个新创建的对象的描述是一个非常模糊的说法，比如从字面量的层面来理解，上面的示例中，可以说this是指向BMW，如果对JavaScript的堆栈存储关系有所了解就会知道这个描述可以说是错误的，因为当我们var一个新的变量，然后将BMW的值赋给这个新的变量，这个新的变量并不会记忆BWM的引用赋值关系，而是直接将BMW指向的堆内存当成自己的，这时候这个新的变量和BMW就同时平等的关联着这个同一个对象的堆内存地址。&lt;/p&gt;
&lt;p&gt;从上面的思考可以看出，这个新创建的对象从严格意义上来讲并不能说是指向了某个变量，还有一种情况就是只通过new关键字示例化了对象，但并没有给某个变量赋值操作：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;new&lt;/span&gt; Car(&quot;BMW&quot;,1400,4900,1400,100);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个不做赋值操作的对象实例化，在实际开发中我们虽然不会这么做，但是本质上确实是实例化了一个对象，这就进一步说明前面的思考是值得探讨的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;我们连这个新对象是谁都不知道，就说this指向了新创建的对象，这有点太不负责任了吧！！！&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所以这里，重点需要探讨的是这个新的对象到底是谁？下面我通过一个流程图来描述function的new机制实例化对象的全过程来说明这个问题：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1309608/201901/1309608-20190107133625878-902736026.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过上图基本上就可以完全理解function构造对象实例化的内部机制了，基本上就是一下几个步骤：&lt;/p&gt;
&lt;p&gt;1.函数执行的前一刻创建变量对象后，在变量对象上隐式的生成一个属性this，并赋值{}。&lt;/p&gt;
&lt;p&gt;2.变量提升参数统一，函数声明提升完成后开始执行，通过this.xxx的方式给this对象添加属性，然后执行赋值；（并且还会隐式的添加原型指向：__proto__指向Object，在原型上的&lt;span class=&quot;name object-properties-section-dimmed&quot;&gt;constructor&lt;span class=&quot;object-properties-section-separator&quot;&gt;的值赋为构造函数&lt;/span&gt;&lt;/span&gt;）。&lt;/p&gt;
&lt;p&gt;3.函数执行完的前一刻隐式的执行return this操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;以上就是this指向规则的全部剖析内容，ES6的胖箭头this词法不在这里分析，后期会有关于ES6的详细内容博客。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 07 Jan 2019 06:12:00 +0000</pubDate>
<dc:creator>他乡踏雪</dc:creator>
<og:description>首先，JavaScript的this指向问题并非传说中的那么难，不难的是机制并不复杂，而被认为不好理解的是逻辑关系和容易混淆的执行上下文。这篇博客也就会基于这两个不好理解的角度来展开，如要要严格的来对</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ZheOnaAndOnly/p/10226506.html</dc:identifier>
</item>
<item>
<title>Java并发编程：Java的四种线程池的使用，以及自定义线程工厂 - xue无止境</title>
<link>http://www.cnblogs.com/yeya/p/10232808.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yeya/p/10232808.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;h2 id=&quot;引言&quot;&gt;引言&lt;/h2&gt;
&lt;p&gt;通过前面的文章，我们学习了Executor框架中的核心类ThreadPoolExecutor ，对于线程池的核心调度机制有了一定的了解，并且成功使用ThreadPoolExecutor 创建了线程池。&lt;/p&gt;
&lt;p&gt;而在Java中，除了ThreadPoolExecutor ，Executor框架中还提供了四种线程池，这四种线程池都是直接或间接配置ThreadPoolExecutor的参数实现的，对于ThreadPoolExecutor类不熟悉的读者可以参考&lt;a href=&quot;https://www.cnblogs.com/yeya/p/10218358.html&quot;&gt;Java并发编程：Java线程池核心ThreadPoolExecutor的使用和原理分析&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;四种线程池&quot;&gt;四种线程池&lt;/h2&gt;
&lt;p&gt;四种线程池分别是：newCachedThreadPool、newFixedThreadPool 、newScheduledThreadPool 和newSingleThreadExecutor ，下面对这几个线程池一一讲解。&lt;/p&gt;
&lt;h3 id=&quot;newcachedthreadpool可缓存的线程池&quot;&gt;newCachedThreadPool：可缓存的线程池&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;源码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue&amp;lt;Runnable&amp;gt;());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;newCachedThreadPool的方法中是返回一个ThreadPoolExecutor实例，从源码中可以看出该线程池的特点：&lt;/p&gt;
&lt;p&gt;1、该线程池的核心线程数量是0，线程的数量最高可以达到&lt;strong&gt;Integer&lt;/strong&gt; 类型最大值；&lt;/p&gt;
&lt;p&gt;2、创建ThreadPoolExecutor实例时传过去的参数是一个SynchronousQueue实例，说明在创建任务时，若存在空闲线程就复用它，没有的话再新建线程。&lt;/p&gt;
&lt;p&gt;3、线程处于闲置状态超过60s的话，就会被销毁。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用法：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static void main(String[] args) {
    //定义ExecutorService实例
    ExecutorService cachedThreadPool = Executors.newCachedThreadPool();
    for (int i = 0; i &amp;lt; 10; i++) {
        final int index = i;
        try {
            Thread.sleep(index * 1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        //调用execute方法
        cachedThreadPool.execute(new Runnable() {
            @Override
            public void run() {
                System.out.println(Thread.currentThread() + &quot;:&quot; + index);
            }
        });
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码因为每次循环都是隔一秒执行，这个时间足够之前的线程工作完毕，并在新循环中复用这个线程，程序的运行结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Thread[pool-1-thread-1,5,main]:0
Thread[pool-1-thread-1,5,main]:1
Thread[pool-1-thread-1,5,main]:2
Thread[pool-1-thread-1,5,main]:3
Thread[pool-1-thread-1,5,main]:4
Thread[pool-1-thread-1,5,main]:5
Thread[pool-1-thread-1,5,main]:6
Thread[pool-1-thread-1,5,main]:7
Thread[pool-1-thread-1,5,main]:8
Thread[pool-1-thread-1,5,main]:9&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;newfixedthreadpool定长线程池&quot;&gt;newFixedThreadPool：定长线程池&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;源码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue&amp;lt;Runnable&amp;gt;());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;线程池特点：&lt;/p&gt;
&lt;p&gt;1、线程池的最大线程数等于核心线程数，并且线程池的线程不会因为闲置超时被销毁。&lt;/p&gt;
&lt;p&gt;2、使用的列队是&lt;strong&gt;LinkedBlockingQueue&lt;/strong&gt;，表示如果当前线程数小于核心线程数，那么即使有空闲线程也不会复用线程去执行任务，而是创建新的线程去执行任务。如果当前执行任务数量大于核心线程数，此时再提交任务就在队列中等待，直到有可用线程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用法：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static void main(String[] args) {
    ExecutorService cachedThreadPool = Executors.newFixedThreadPool(3);
    for (int i = 0; i &amp;lt; 10; i++) {
        final int index = i;
        try {
            Thread.sleep(index * 1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        cachedThreadPool.execute(new Runnable() {
            @Override
            public void run() {
                System.out.println(Thread.currentThread() + &quot;:&quot; + index);
            }
        });
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;定义一个线程数为3的线程池，循环10次执行，可以发现运行的线程永远只有三个，结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Thread[pool-1-thread-1,5,main]:0
Thread[pool-1-thread-2,5,main]:1
Thread[pool-1-thread-3,5,main]:2
Thread[pool-1-thread-1,5,main]:3
Thread[pool-1-thread-2,5,main]:4
Thread[pool-1-thread-3,5,main]:5
Thread[pool-1-thread-1,5,main]:6
Thread[pool-1-thread-2,5,main]:7
Thread[pool-1-thread-3,5,main]:8
Thread[pool-1-thread-1,5,main]:9&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;newsinglethreadexecutor单线程线程池&quot;&gt;newSingleThreadExecutor：单线程线程池&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;源码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue&amp;lt;Runnable&amp;gt;()));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从源码就可以看出，该线程池基本就是只有一个线程数的&lt;strong&gt;newFixedThreadPool&lt;/strong&gt;，它只有一个线程在工作，所有任务按照指定顺序执行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;和newFixedThreadPool类似，只是一直只有一个线程在工作，这里就不贴代码了。&lt;/p&gt;
&lt;h3 id=&quot;newscheduledthreadpool支持定时的定长线程池&quot;&gt;newScheduledThreadPool：支持定时的定长线程池&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;源码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {
    return new ScheduledThreadPoolExecutor(corePoolSize);
}

public ScheduledThreadPoolExecutor(int corePoolSize) {
        super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,
              new DelayedWorkQueue());
}
public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue&amp;lt;Runnable&amp;gt; workQueue) {
        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
             Executors.defaultThreadFactory(), defaultHandler);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;newScheduledThreadPool的方法不是直接返回一个ThreadPoolExecutor实例，而是通过有定时功能的ThreadPoolExecutor，也就是&lt;code&gt;ScheduledThreadPoolExecutor&lt;/code&gt; 来返回ThreadPoolExecutor实例，从源码中可以看出：&lt;/p&gt;
&lt;p&gt;1、该线程池可以设置核心线程数量，最大线程数与newCachedThreadPool一样，都是Integer.MAX_VALUE。&lt;/p&gt;
&lt;p&gt;2、该线程池采用的队列是DelayedWorkQueue，具有延迟和定时的作用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用法：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static void main(String[] args) {
    ExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(3);

    //延迟3秒执行，只执行一次
    ((ScheduledExecutorService) scheduledThreadPool).schedule(new Runnable() {
        @Override
        public void run() {
            System.out.println(&quot;延迟========&quot;);
        }
    },3,TimeUnit.SECONDS);

    //延迟1秒后每隔两秒执行一次
    ((ScheduledExecutorService) scheduledThreadPool).scheduleAtFixedRate(new Runnable() {
        @Override
        public void run() {
            System.out.println(&quot;执行============&quot;);
        }
    },1,2,TimeUnit.SECONDS);            //单位是秒
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;自定义threadfactory&quot;&gt;自定义ThreadFactory&lt;/h2&gt;
&lt;p&gt;四种线程池的使用就说到这里了，值得说明的是，除了上面的参数外，Executors类中还给这四种线程池提供了可传&lt;code&gt;ThreadFactory&lt;/code&gt;的重载方法，以下是它们的源码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue&amp;lt;Runnable&amp;gt;(),
                                threadFactory));
}
public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                60L, TimeUnit.SECONDS,
                                new SynchronousQueue&amp;lt;Runnable&amp;gt;(),
                                threadFactory);
}
public static ScheduledExecutorService newScheduledThreadPool(
                int corePoolSize, ThreadFactory threadFactory) {
    return new ScheduledThreadPoolExecutor(corePoolSize, threadFactory);
}
public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) {
        return new ThreadPoolExecutor(nThreads, nThreads,
                                      0L, TimeUnit.MILLISECONDS,
                                      new LinkedBlockingQueue&amp;lt;Runnable&amp;gt;(),
                                      threadFactory);
}    &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ThreadFactory是一个接口类，也就是我们经常说的线程工厂，只有一个方法，可以用于创建线程：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Thread newThread(Runnable r);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;默认情况下，ThreadPoolExecutor构造器传入的&lt;code&gt;ThreadFactory&lt;/code&gt; 参数是Executors类中的defaultThreadFactory()，相当于一个线程工厂，帮我们创建了线程池中所需的线程。&lt;/p&gt;
&lt;p&gt;除此之外，我们也可以自定义ThreadFactory，并根据自己的需要来操作线程，下面是实例代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static void main(String[] args) {
    ExecutorService service = new ThreadPoolExecutor(5, 5, 0L, TimeUnit.MILLISECONDS,
            new SynchronousQueue&amp;lt;Runnable&amp;gt;(), new ThreadFactory() {
        @Override
        public Thread newThread(Runnable r) {
            Thread t = new Thread(r);
            System.out.println(&quot;我是线程&quot; + r);
            return t;
        }
    }
    );
    //用lambda表达式编写方法体中的逻辑
    Runnable run = () -&amp;gt; {
        try {
            Thread.sleep(1000);
            System.out.println(Thread.currentThread().getName() + &quot;正在执行&quot;);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    };
    for (int i = 0; i &amp;lt; 5; i++) {
        service.submit(run);
    }
    //这里一定要做关闭
    service.shutdown();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行代码后，控制行会输出五行 “我是线程java.util.concurrent.ThreadPoolExecutor。。。。。”的信息，也证明了我们自定义的ThreadFactory起到了作用。&lt;/p&gt;
</description>
<pubDate>Mon, 07 Jan 2019 05:47:00 +0000</pubDate>
<dc:creator>xue无止境</dc:creator>
<og:description>[toc] 引言 通过前面的文章，我们学习了Executor框架中的核心类ThreadPoolExecutor ，对于线程池的核心调度机制有了一定的了解，并且成功使用ThreadPoolExecuto</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yeya/p/10232808.html</dc:identifier>
</item>
<item>
<title>Redis的Pub/Sub客户端实现 - 丶Pz</title>
<link>http://www.cnblogs.com/panzi/p/10232452.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/panzi/p/10232452.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;  在&lt;a href=&quot;https://www.cnblogs.com/panzi/p/10213821.html&quot;&gt;学习T-io框架，从写一个Redis客户端开始&lt;/a&gt;一文中，已经简单介绍了&lt;code&gt;Redis&lt;/code&gt;客户端的实现思路，并且基础架构已经搭建完成，只不过支持的命令不全，不过后期在加命令就会很简单了。本篇就要实现&lt;code&gt;Publish/Subscribe&lt;/code&gt;功能。&lt;/p&gt;
&lt;h2 id=&quot;pubsub&quot;&gt;Pub/Sub&lt;/h2&gt;
&lt;p&gt;  发布订阅模式在很多场景中用的都很频繁，这里不再赘述。下面看一下&lt;code&gt;Redis&lt;/code&gt;中的命令。参考资料：&lt;a href=&quot;https://redis.io/topics/pubsub&quot; class=&quot;uri&quot;&gt;https://redis.io/topics/pubsub&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//发布
PUBLISH
//订阅
SUBSCRIBE
//模式匹配订阅
PSUBSCRIBE
//取消订阅
UNSUBSCRIBE
//取消订阅（模式匹配）
PUNSUBSCRIBE
//其他&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;publishsubscribe&quot;&gt;PUBLISH/SUBSCRIBE&lt;/h2&gt;
&lt;p&gt;  命令使用方式很简单：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;PUBLISH CHANNEL MESSAGE&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例如：&lt;code&gt;publish user helloworld&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Client&lt;/code&gt;类中增加代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    @Override
    public void publish(final String channel, final String message) {
        sendCommand(Command.PUBLISH, channel, message);
    }

    @Override
    public void subscribe(final String... channels) {
        sendCommand(SUBSCRIBE, channels);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调试代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; //发布
 Tedis tedisPublish =  new Tedis(&quot;192.168.1.225&quot;, 6379);
 tedisPublish.publish(&quot;channel1&quot;,&quot;hello world&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt; //订阅
 Tedis tedis = new Tedis(&quot;192.168.1.225&quot;, 6379);
 tedis.subscribe(new MyPubSub(),&quot;channel1&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;先订阅，后发布，订阅响应结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;*3
$9
subscribe
$8
channel1
:1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过响应结果可以看出，我们当前的命令是 &lt;code&gt;subscribe&lt;/code&gt;，然后订阅的是&lt;code&gt;channel1&lt;/code&gt;，当前共订阅了&lt;code&gt;:1&lt;/code&gt;个。&lt;/p&gt;
&lt;p&gt;发布响应结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;:1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;总共发给了&lt;code&gt;:1&lt;/code&gt;个订阅客户端。这个结果就是订阅客户端的个数。&lt;/p&gt;
&lt;h2 id=&quot;psubscribe&quot;&gt;PSUBSCRIBE&lt;/h2&gt;
&lt;p&gt;命令格式如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;PSUBSCIRBE  news.*&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改一下调试代码：&lt;/p&gt;
&lt;p&gt;订阅&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  tedis.pSubscribe(new MyPubSub(),&quot;news.*&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;响应结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;*3
$10
psubscribe
$6
news.*
:1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;发布&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  tedisPublish.publish(&quot;news.sports&quot;,&quot;welcome to NBA&quot;);
  tedisPublish.publish(&quot;news.country&quot;,&quot;this is china news&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;订阅客户端收到消息：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;*4
$8
pmessage
$6
news.*
$11
news.sports
$14
welcome to NBA


*4
$8
pmessage
$6
news.*
$12
news.country
$18
this is china news
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从响应结果可以看出，客户端订阅了 &lt;code&gt;news.*&lt;/code&gt;，然后收到了&lt;code&gt;news.sports,news.country&lt;/code&gt;的消息。&lt;/p&gt;
&lt;h2 id=&quot;响应消息解析&quot;&gt;响应消息解析&lt;/h2&gt;
&lt;p&gt;  上述代码中有一个&lt;code&gt;MyPubSub&lt;/code&gt;对象，它继承自抽象类&lt;code&gt;TedisPubSub&lt;/code&gt;.这个类做了发布订阅核心的业务处理。通过对服务端返回的消息格式，我们可以发现，它的消息格式是统一的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    EVENT_NAME --事件

    CHANNEL_NAME --频道
    
    OTHER --其他信息，根据每个事件可能不同
    &lt;/code&gt;
&lt;/pre&gt;
&lt;p readability=&quot;26.375245194194&quot;&gt;所以我们在做发布订阅的响应消息解析时，可以返回 List&lt;/p&gt;
</description>
<pubDate>Mon, 07 Jan 2019 05:26:00 +0000</pubDate>
<dc:creator>丶Pz</dc:creator>
<og:description>前言   在</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/panzi/p/10232452.html</dc:identifier>
</item>
</channel>
</rss>