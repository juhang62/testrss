<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>由老同事学习SAP所想到的 - SAP梦心</title>
<link>http://www.cnblogs.com/saper/p/11087842.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/saper/p/11087842.html</guid>
<description>&lt;p&gt;前段时间一位老同事在微信上跟我说他们公司正计划导SAP系统，但整个IT中心几乎无人使用过SAP，知道我在这行业干了多年了，所以想问我怎么开始学习。于是我约他今天出来聊聊，顺便把手里的SAP ECC EHP6版本的虚拟机拷给他自己先自学。 &lt;/p&gt;
&lt;p&gt;他们公司一直都是在用九二年版的QAD系统（美国ERP厂商），跟之前我们同事的那家企业系统一致，非常古老的系统，不支持鼠标操作，基本上现在ERP系统该有的功能它都没有，唯一好处的是开源可开发。公司老板不知道从哪里交流了一下，然后打算大刀阔斧大干一场，改革目前信息化现状，为将来业务扩展做信息化支撑。 &lt;/p&gt;
&lt;p&gt;一直以来他都是做ERP行业，接触过多个模块，现在这个公司可能是因为体量小的原因，一个人几乎全管了所有的模块，业务能力很扎实，对企业的流程和供应链非常熟悉。看我给他演示了一下基础的SAP操作和逻辑，一直惊呼SAP的强大。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/41253/201906/41253-20190626083719518-559891226.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; SAP的庞大复杂对于一个从来没接触到人来说门槛还是相当高的，这个门槛并不是看几本PDF、看几个视频、上上培训机构就能越过得了的，其中包含的后台逻辑配置和各种强关联绝对会把一个人打蒙。想起前几年碰到一个啥都不懂的信息化管理者，在ERP选型会议上跟演示系统的供应商要求在企业内部安装一套空白的ERP试用，想想这真是一大笑柄。&lt;/p&gt;
&lt;p&gt; 这持续枯燥乏味的学习过程绝对非常考验一个人的毅力。想起十多年前，为了学习SAP，我从腾讯拍拍上花了600元买SAP ECC的安装包，含视频教程差不多三十多张DVD光盘，升级了老爷笔记本配置（酷睿双核、4G内存、500G机械硬盘），安装Windows Server，安装Java，安装MSSQL，安装SAP，通宵安装了十五六个小时才搞定，占用硬盘空间220G，一开启SAP服务整个电脑就得卡死半个小时，CPU直接100%，内存爆满。&lt;/p&gt;
&lt;p&gt;之后对着SAP GUI界面一脸懵逼，根本不知道怎么下手。虽然我知道部分ERP的流程和功能，但我根本不知道怎么弄。看购买回来的视频也是一脸懵逼，因为系统里面的组织配置跟视频教程里根本就不一样，真要操作起来困难重重，各种红灯错误，这也不行那也不行，那种深深的绝望感至今历历在目。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/41253/201906/41253-20190626083742679-1225569209.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;后来跌跌撞撞学了一点ABAP开发，由于没有实际的工作经历，也只是懂个ABAP开发的一丝丝皮毛而已。那时候没有SAP前辈先驱可以交流，没有QQ群，连热闹一点的论坛都没有，夜以继日枯燥得学习才进步这么点，支撑起我这份毅力恒心的大概就是“生存”压力吧。一心想离开那时候的工作环境，不愿被温水煮死。&lt;/p&gt;
&lt;p&gt;后来在厦门面试了一家正在实施SAP的企业，面试的主管给我出了一道SAP开发的题目，非常简单的数据查询我都没能做出来，好在他们给了我机会让我回去用自己的电脑做题。回去之后我狂恶补知识，当晚做题到凌晨，将源码发邮件给那位主管，第二天早上接到他们复试的通知，于是第二轮面试的时候我也很幸运成功解决了ABAP的问题，就这样开始跟SAP结缘了。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/41253/201906/41253-20190626083755986-1589242916.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了不让主管失望，觉得我SAP技术是半桶水，那时候我疯狂加班，下班回来也利用自己电脑的SAP狂学习，不停研究顾问开发的代码，看到不熟悉的语法就记下来百度，做各种尝试测试。恰好那时候公司要开发三支程序，顾问那边报价十多万台币。于是我自告奋勇，跟主管说我来开发。然后就是疯狂的查阅资料，查看SAP官方英文文档，系统测试，顺利得完成了任务。短短2个月就给公司省了十多万的开发费用，且提前了一个月转正。不得不说，不逼一下自己都不知道自己原来可以如此优秀。&lt;/p&gt;
&lt;p&gt;再后来跳槽去做业务模块做项目了，开始是做MM模块，实施和运维过程中遇到过各种各样的问题，也深深感受到了SAP的强大，后来又接触了SD模块，Basis模块等。我觉得一个SAP顾问如果不精通一两个模块，其他模块如果不熟悉的话，是很没优势的。这个过程中累积的各种笔记和实施运维实录有五六百兆，上千篇文档。&lt;/p&gt;
&lt;p&gt;就这样曲曲折折这么些年，非常成功的项目也有，失败的项目也有，见识到了形形色色的SAP顾问和关键用户，这些都变成了自己非常宝贵的经验。&lt;strong&gt;一个顾问如果没有经历过失败的项目，那就是失败的！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/41253/201906/41253-20190626083811883-1519843147.jpg&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当然，之前两年半的QAD运维并非全是没用的，至少让我懂得了部分业务，知道了如何敏捷高效开发（这点得感谢那时候的主管领导，至今让我受益无穷，很遗憾现在绝大多数只是有开发的语法并没有开发的思维观念），也让我明白系统固然重要但企业流程和业务分析能力更重要。我曾经不止一次说过&lt;strong&gt;考验一个SAP顾问的能力并不在于他会多少事务代码，知道后台表是什么，不在于他知道SAP这个功能如何配置，而是他对业务的分析水平的高低以及需求沟通的能力大小&lt;/strong&gt;，这才是一个资深的SAP顾问跟一个培训机构培训出来的人的区别。&lt;/p&gt;
&lt;p&gt;很多人来信问我该如何入行SAP这个行业，每个人成长的道路不同，但我还是很忌讳培训机构的，他们只会弄虚作假，投机取巧，教你如何在简历上谎报项目经验，也只会教一些系统层级的东西，随便甲方稍微面试一下就露马脚了。我觉得时刻准备着，好好学习，找机会入职甲方或者乙方才是正道，别去花冤枉钱。&lt;/p&gt;
&lt;p&gt;老同事如今也面临“生存”压力，我想他应该是有毅力坚持下去的，但能学到什么程度就不知道了。不过他懂开发，懂业务，学起SAP应该可以轻松不少。&lt;strong&gt;要知道一个人能集业务分析、开发、项目管理、系统配置于一身，那真的不得了！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/41253/201906/41253-20190626083825424-1083780790.jpg&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;hr/&gt;

&lt;p&gt;  本文作者 | SAP梦心&lt;/p&gt;
&lt;p&gt;  联系方式 | 微信：W150112458（疯狂的程序员）&lt;/p&gt;
&lt;p&gt;  特别敬告 | 欢迎转载，转载请注明出处并保持原文不动，谢谢&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/41253/201906/41253-20190626084105384-1843158377.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 26 Jun 2019 00:42:00 +0000</pubDate>
<dc:creator>SAP梦心</dc:creator>
<og:description>前段时间一位老同事在微信上跟我说他们公司正计划导SAP系统，但整个IT中心几乎无人使用过SAP，知道我在这行业干了多年了，所以想问我怎么开始学习。于是我约他今天出来聊聊，顺便把手里的SAP ECC E</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/saper/p/11087842.html</dc:identifier>
</item>
<item>
<title>双针针技巧汇总 - murphy_gb</title>
<link>http://www.cnblogs.com/kyoner/p/11087755.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kyoner/p/11087755.html</guid>
<description>&lt;p&gt;我认为双指针技巧还可以分为两类，一类是&lt;strong&gt;「快慢指针」&lt;/strong&gt;，另一类是&lt;strong&gt;「左右指针」&lt;/strong&gt;。前者解决主要解决链表中的问题，比如典型的判定链表中是否包含环；后者主要解决数组（或者字符串）中的问题，比如二分查找。&lt;/p&gt;

&lt;p&gt;快慢指针一般都初始化指向链表的头结点 head，前进时快指针 fast 在前，慢指针 slow 在后，巧妙解决一些链表中的问题。&lt;/p&gt;
&lt;h2 id=&quot;判定链表中是否含有环&quot;&gt;&lt;em&gt;1&lt;/em&gt;、判定链表中是否含有环&lt;/h2&gt;
&lt;p&gt;这应该属于链表最基本的操作了，如果读者已经知道这个技巧，可以跳过。&lt;/p&gt;
&lt;p&gt;单链表的特点是每个节点只知道下一个节点，所以一个指针的话无法判断链表中是否含有环的。&lt;/p&gt;
&lt;p&gt;如果链表中不包含环，那么这个指针最终会遇到空指针 null 表示链表到头了，这还好说，可以判断该链表不含环。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;boolean hasCycle(ListNode head) {
    while (head != null)
        head = head.next;
    return false;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是如果链表中含有环，那么这个指针就会陷入死循环，因为环形数组中没有 null 指针作为尾部节点。&lt;/p&gt;
&lt;p&gt;经典解法就是用两个指针，一个每次前进两步，一个每次前进一步。如果不含有环，跑得快的那个指针最终会遇到 null，说明链表不含环；如果含有环，快指针最终会超慢指针一圈，和慢指针相遇，说明链表含有环。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;boolean hasCycle(ListNode head) {
    ListNode fast, slow;
    fast = slow = head;
    while(fast != null &amp;amp;&amp;amp; fast.next != null) {
        fast = fast.next.next;
        slow = slow.next;
        
        if (fast == slow)
            return true;
    }
    return false;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;已知链表中含有环返回这个环的起始位置&quot;&gt;2、已知链表中含有环，返回这个环的起始位置&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1566782/201906/1566782-20190626075016458-1495003044.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个问题其实不困难，有点类似脑筋急转弯，先直接看代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;ListNode detectCycle(ListNode head) {
    ListNode fast, slow;
    fast = slow = head;
    while (fast != null &amp;amp;&amp;amp; fast.next != null) {
        fast = fast.next.next;
        slow = slow.next;
        if (fast == slow)
            break;
    }
    
    slow = head;
    while (slow != fast) {
        fast = fast.next;
        slow = slow.next;
    }
    return slow;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，当快慢指针相遇时，让其中任一个指针重新指向头节点，然后让它俩以相同速度前进，再次相遇时所在的节点位置就是环开始的位置。这是为什么呢？&lt;/p&gt;
&lt;p&gt;第一次相遇时，假设慢指针 slow 走了 k 步，那么快指针 fast 一定走了 2k 步，也就是说比 slow 多走了 k 步（也就是环的长度）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1566782/201906/1566782-20190626075054000-1816921447.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;设相遇点距环的起点的距离为 m，那么环的起点距头结点 head 的距离为 k - m，也就是说如果从 head 前进 k - m 步就能到达环起点。&lt;/p&gt;
&lt;p&gt;巧的是，如果从相遇点继续前进 k - m 步，也恰好到达环起点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1566782/201906/1566782-20190626075122685-698940711.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以，只要我们把快慢指针中的任一个重新指向 head，然后两个指针同速前进，k - m 步后就会相遇，相遇之处就是环的起点了。&lt;/p&gt;
&lt;h2 id=&quot;寻找链表的中点&quot;&gt;&lt;em&gt;3&lt;/em&gt;、寻找链表的中点&lt;/h2&gt;
&lt;p&gt;类似上面的思路，我们还可以让快指针一次前进两步，慢指针一次前进一步，当快指针到达链表尽头时，慢指针就处于链表的中间位置。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;ListNode slow, fast;
slow = fast = head;
while (fast != null &amp;amp;&amp;amp; fast.next != null) {
    fast = fast.next.next;
    slow = slow.next;
}
// slow 就在中间位置
return slow;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当链表的长度是奇数时，slow 恰巧停在中点位置；如果长度是偶数，slow 最终的位置是中间偏右：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1566782/201906/1566782-20190626075146010-1979098095.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;寻找链表中点的一个重要作用是对链表进行归并排序。&lt;/p&gt;
&lt;p&gt;回想数组的归并排序：求中点索引递归地把数组二分，最后合并两个有序数组。对于链表，合并两个有序链表是很简单的，难点就在于二分。&lt;/p&gt;
&lt;p&gt;但是现在你学会了找到链表的中点，就能实现链表的二分了。关于归并排序的具体内容本文就不具体展开了。&lt;/p&gt;
&lt;h2 id=&quot;寻找链表的倒数第-k-个元素&quot;&gt;&lt;em&gt;4&lt;/em&gt;、寻找链表的倒数第 k 个元素&lt;/h2&gt;
&lt;p&gt;我们的思路还是使用快慢指针，让快指针先走 k 步，然后快慢指针开始同速前进。这样当快指针走到链表末尾 null 时，慢指针所在的位置就是倒数第 k 个链表节点（为了简化，假设 k 不会超过链表长度）：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;ListNode slow, fast;
slow = fast = head;
while (k-- &amp;gt; 0) 
    fast = fast.next;

while (fast != null) {
    slow = slow.next;
    fast = fast.next;
}
return slow;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;左右指针在数组中实际是指两个索引值，一般初始化为 left = 0, right = nums.length - 1 。&lt;/p&gt;
&lt;h2 id=&quot;二分查找&quot;&gt;1、二分查找&lt;/h2&gt;
&lt;p&gt;前文 &lt;a href=&quot;https://www.cnblogs.com/kyoner/p/11080078.html&quot;&gt;二分查找算法详解&lt;/a&gt; 有详细讲解，这里只写最简单的二分算法，旨在突出它的双指针特性：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;int binarySearch(int[] nums, int target) {
    int left = 0;
    int right = nums.length - 1;
    while(left &amp;lt;= right) {
        int mid = (right + left) / 2;
        if (nums[mid] == target)
            return mid;
        else if (nums[mid] &amp;lt; target)
            left = mid + 1;
        else if (nums[mid] &amp;gt; target)
            right = mid - 1;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;两数之和&quot;&gt;2、两数之和&lt;/h2&gt;
&lt;p&gt;直接看一道 LeetCode 题目吧：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1566782/201906/1566782-20190626075621446-2077996103.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;只要数组有序，就应该想到双指针技巧。这道题的解法有点类似二分查找，通过调节 left 和 right 可以调整 sum 的大小：&lt;/p&gt;
&lt;h2 id=&quot;反转数组&quot;&gt;&lt;em&gt;3&lt;/em&gt;、反转数组&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;void reverse(int[] nums) {
    int left = 0;
    int right = nums.length - 1;
    while (left &amp;lt; right) {
        // swap(nums[left], nums[right])
        int temp = nums[left];
        nums[left] = nums[right];
        nums[right] = temp;
        left++;
        right--;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;滑动窗口算法&quot;&gt;&lt;em&gt;4&lt;/em&gt;、滑动窗口算法&lt;/h2&gt;
&lt;p&gt;这也许是双指针技巧的最高境界了，如果掌握了此算法，可以解决一大类子字符串匹配的问题，不过「滑动窗口」算法比上述的这些算法稍微复杂些。&lt;/p&gt;
&lt;p&gt;幸运的是，这类算法是有框架模板的，下篇文章就准备讲解「滑动窗口」算法模板，帮大家秒杀几道 LeetCode 子串匹配的问题。&lt;/p&gt;
</description>
<pubDate>Tue, 25 Jun 2019 23:53:00 +0000</pubDate>
<dc:creator>murphy_gb</dc:creator>
<og:description>我认为双指针技巧还可以分为两类，一类是 「快慢指针」 ，另一类是 「左右指针」 。前者解决主要解决链表中的问题，比如典型的判定链表中是否包含环；后者主要解决数组（或者字符串）中的问题，比如二分查找。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kyoner/p/11087755.html</dc:identifier>
</item>
<item>
<title>Hadoop 三剑客之 —— 分布式文件存储系统 HDFS - 单人影</title>
<link>http://www.cnblogs.com/danrenying/p/11087666.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/danrenying/p/11087666.html</guid>
<description>&lt;nav&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/danrenying/p/11087666.html#一介绍&quot;&gt;一、介绍&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/danrenying/p/11087666.html#二HDFS-设计原理&quot;&gt;二、HDFS 设计原理&lt;/a&gt;&lt;br/&gt;    &lt;a href=&quot;https://www.cnblogs.com/danrenying/p/11087666.html#21-HDFS-架构&quot;&gt;2.1 HDFS 架构&lt;/a&gt;&lt;br/&gt;    &lt;a href=&quot;https://www.cnblogs.com/danrenying/p/11087666.html#22-文件系统命名空间&quot;&gt;2.2 文件系统命名空间&lt;/a&gt;&lt;br/&gt;    &lt;a href=&quot;https://www.cnblogs.com/danrenying/p/11087666.html#23-数据复制&quot;&gt;2.3 数据复制&lt;/a&gt;&lt;br/&gt;    &lt;a href=&quot;https://www.cnblogs.com/danrenying/p/11087666.html#24-数据复制的实现原理&quot;&gt;2.4 数据复制的实现原理&lt;/a&gt;&lt;br/&gt;    &lt;a href=&quot;https://www.cnblogs.com/danrenying/p/11087666.html#25--副本的选择&quot;&gt;2.5 副本的选择&lt;/a&gt;&lt;br/&gt;    &lt;a href=&quot;https://www.cnblogs.com/danrenying/p/11087666.html#26-架构的稳定性&quot;&gt;2.6 架构的稳定性&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/danrenying/p/11087666.html#三HDFS-的特点&quot;&gt;三、HDFS 的特点&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/danrenying/p/11087666.html#附图解HDFS存储原理&quot;&gt;附：图解HDFS存储原理&lt;/a&gt;&lt;br/&gt;    &lt;a href=&quot;https://www.cnblogs.com/danrenying/p/11087666.html#1-HDFS写数据原理&quot;&gt;1. HDFS写数据原理&lt;/a&gt;&lt;br/&gt;    &lt;a href=&quot;https://www.cnblogs.com/danrenying/p/11087666.html#2-HDFS读数据原理&quot;&gt;2. HDFS读数据原理&lt;/a&gt;&lt;br/&gt;    &lt;a href=&quot;https://www.cnblogs.com/danrenying/p/11087666.html#3-HDFS故障类型和其检测方法&quot;&gt;3. HDFS故障类型和其检测方法&lt;/a&gt;&lt;br/&gt;&lt;/nav&gt;&lt;h2 id=&quot;一介绍&quot;&gt;一、介绍&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;HDFS&lt;/strong&gt; （&lt;strong&gt;Hadoop Distributed File System&lt;/strong&gt;）是Hadoop下的分布式文件系统，具有高容错、高吞吐量等特性，可以部署在低成本的硬件上。&lt;/p&gt;
&lt;h2 id=&quot;二hdfs-设计原理&quot;&gt;二、HDFS 设计原理&lt;/h2&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img width=&quot;600px&quot; src=&quot;https://raw.githubusercontent.com/heibaiying/BigData-Notes/master/pictures/hdfsarchitecture.png&quot;/&gt;&lt;/div&gt;
&lt;h3 id=&quot;hdfs-架构&quot;&gt;2.1 HDFS 架构&lt;/h3&gt;
&lt;p&gt;HDFS 遵循主/从架构，由单个NameNode(NN)和多个DataNode(DN)组成：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;NameNode&lt;/strong&gt; : 负责执行有关&lt;code&gt;文件系统命名空间&lt;/code&gt;的操作，例如打开，关闭、重命名文件和目录等。它同时还负责集群元数据的存储，记录着文件中各个数据块的位置信息。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DataNode&lt;/strong&gt;：负责提供来自文件系统客户端的读写请求，执行块的创建，删除等操作。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;文件系统命名空间&quot;&gt;2.2 文件系统命名空间&lt;/h3&gt;
&lt;p&gt;HDFS的&lt;code&gt;文件系统命名空间&lt;/code&gt;的层次结构与大多数文件系统类似(如Linux)， 支持目录和文件的创建、移动、删除和重命名等操作，支持配置用户和访问权限，但不支持硬链接和软连接。&lt;code&gt;NameNode&lt;/code&gt;负责维护文件系统名称空间，记录对名称空间或其属性的任何更改。&lt;/p&gt;
&lt;h3 id=&quot;数据复制&quot;&gt;2.3 数据复制&lt;/h3&gt;
&lt;p&gt;由于Hadoop被设计运行在廉价的机器上，这意味着硬件是不可靠的，为了保证容错性，HDFS提供了数据复制机制。HDFS 将每一个文件存储为一系列&lt;strong&gt;块&lt;/strong&gt;，每个块由多个副本来保证容错，块的大小和复制因子可以自行配置（默认情况下，块大小是128M，默认复制因子是3）。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img width=&quot;600px&quot; src=&quot;https://raw.githubusercontent.com/heibaiying/BigData-Notes/master/pictures/hdfsdatanodes.png&quot;/&gt;&lt;/div&gt;
&lt;h3 id=&quot;数据复制的实现原理&quot;&gt;2.4 数据复制的实现原理&lt;/h3&gt;
&lt;p&gt;大型的HDFS实例在通常分布在多个机架的多台服务器上，不同机架上的两台服务器之间通过交换机进行通讯。在大多数情况下，同一机架中的服务器间的网络带宽大于不同机架中的服务器之间的带宽。因此HDFS采用机架感知副本放置策略，对于常见情况，当复制因子为3时，HDFS的放置策略是：&lt;/p&gt;
&lt;p&gt;在写入程序位于&lt;code&gt;datanode&lt;/code&gt;上时，就优先将写入文件的一个副本放置在该&lt;code&gt;datanode&lt;/code&gt;上，否则放在随机&lt;code&gt;datanode&lt;/code&gt;上。之后在另一个远程机架上的任意一个节点上放置另一个副本，并在该机架上的另一个节点上放置最后一个副本。此策略可以减少机架间的写入流量，从而提高写入性能。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/heibaiying/BigData-Notes/master/pictures/hdfs-%E6%9C%BA%E6%9E%B6.png&quot;/&gt;&lt;/div&gt;
&lt;p&gt;如果复制因子大于3，则随机确定第4个和之后副本的放置位置，同时保持每个机架的副本数量低于上限，上限值通常为&lt;code&gt;（复制系数 - 1）/机架数量 + 2&lt;/code&gt;，需要注意的是不允许同一个&lt;code&gt;dataNode&lt;/code&gt;上具有同一个块的多个副本。&lt;/p&gt;
&lt;h3 id=&quot;副本的选择&quot;&gt;2.5 副本的选择&lt;/h3&gt;
&lt;p&gt;为了最大限度地减少带宽消耗和读取延迟，HDFS在执行读取请求时，优先读取距离读取器最近的副本。如果在与读取器节点相同的机架上存在副本，则优先选择该副本。如果HDFS群集跨越多个数据中心，则优先选择本地数据中心上的副本。&lt;/p&gt;
&lt;h3 id=&quot;架构的稳定性&quot;&gt;2.6 架构的稳定性&lt;/h3&gt;
&lt;h4 id=&quot;心跳机制和重新复制&quot;&gt;1. 心跳机制和重新复制&lt;/h4&gt;
&lt;p&gt;每个DataNode定期向NameNode发送心跳消息，如果超过指定时间没有收到心跳消息，则将DataNode标记为死亡。NameNode不会将任何新的IO请求转发给标记为死亡的DataNode，也不会再使用这些DataNode上的数据。 由于数据不再可用，可能会导致某些块的复制因子小于其指定值，NameNode会跟踪这些块，并在必要的时候进行重新复制。&lt;/p&gt;
&lt;h4 id=&quot;数据的完整性&quot;&gt;2. 数据的完整性&lt;/h4&gt;
&lt;p&gt;由于存储设备故障等原因，存储在DataNode上的数据块也会发生损坏。为了避免读取到已经损坏的数据而导致错误，HDFS提供了数据完整性校验机制来保证数据的完整性，具体操作如下：&lt;/p&gt;
&lt;p&gt;当客户端创建HDFS文件时，它会计算文件的每个块的&lt;code&gt;校验和&lt;/code&gt;，并将&lt;code&gt;校验和&lt;/code&gt;存储在同一HDFS命名空间下的单独的隐藏文件中。当客户端检索文件内容时，它会验证从每个DataNode接收的数据是否与存储在关联校验和文件中的&lt;code&gt;校验和&lt;/code&gt;匹配。如果匹配失败，则证明数据已经损坏，此时客户端会选择从其他DataNode获取该块的其他可用副本。&lt;/p&gt;
&lt;h4 id=&quot;元数据的磁盘故障&quot;&gt;3.元数据的磁盘故障&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;FsImage&lt;/code&gt;和&lt;code&gt;EditLog&lt;/code&gt;是HDFS的核心数据，这些数据的意外丢失可能会导致整个HDFS服务不可用。为了避免这个问题，可以配置NameNode使其支持&lt;code&gt;FsImage&lt;/code&gt;和&lt;code&gt;EditLog&lt;/code&gt;多副本同步，这样&lt;code&gt;FsImage&lt;/code&gt;或&lt;code&gt;EditLog&lt;/code&gt;的任何改变都会引起每个副本&lt;code&gt;FsImage&lt;/code&gt;和&lt;code&gt;EditLog&lt;/code&gt;的同步更新。&lt;/p&gt;
&lt;h4 id=&quot;支持快照&quot;&gt;4.支持快照&lt;/h4&gt;
&lt;p&gt;快照支持在特定时刻存储数据副本，在数据意外损坏时，可以通过回滚操作恢复到健康的数据状态。&lt;/p&gt;
&lt;h2 id=&quot;三hdfs-的特点&quot;&gt;三、HDFS 的特点&lt;/h2&gt;
&lt;h3 id=&quot;高容错&quot;&gt;3.1 高容错&lt;/h3&gt;
&lt;p&gt;由于HDFS 采用数据的多副本方案，所以部分硬件的损坏不会导致全部数据的丢失。&lt;/p&gt;
&lt;h3 id=&quot;高吞吐量&quot;&gt;3.2 高吞吐量&lt;/h3&gt;
&lt;p&gt;HDFS设计的重点是支持高吞吐量的数据访问，而不是低延迟的数据访问。&lt;/p&gt;
&lt;h3 id=&quot;大文件支持&quot;&gt;3.3 大文件支持&lt;/h3&gt;
&lt;p&gt;HDFS适合于大文件的存储，文档的大小应该是是GB到TB级别的。&lt;/p&gt;
&lt;h3 id=&quot;简单一致性模型&quot;&gt;3.3 简单一致性模型&lt;/h3&gt;
&lt;p&gt;HDFS更适合于一次写入多次读取(write-once-read-many)的访问模型。支持将内容追加到文件末尾，但不支持数据的随机访问，不能从文件任意位置新增数据。&lt;/p&gt;
&lt;h3 id=&quot;跨平台移植性&quot;&gt;3.4 跨平台移植性&lt;/h3&gt;
&lt;p&gt;HDFS具有良好的跨平台移植性，这使得其他大数据计算框架都将其作为数据持久化存储的首选方案。&lt;/p&gt;
&lt;h2 id=&quot;附图解hdfs存储原理&quot;&gt;附：图解HDFS存储原理&lt;/h2&gt;
&lt;blockquote readability=&quot;2.6&quot;&gt;
&lt;p&gt;说明：以下图片引用自博客：&lt;a href=&quot;https://blog.csdn.net/hudiefenmu/article/details/37655491&quot;&gt;翻译经典 HDFS 原理讲解漫画&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;hdfs写数据原理&quot;&gt;1. HDFS写数据原理&lt;/h3&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/heibaiying/BigData-Notes/master/pictures/hdfs-write-1.jpg&quot;/&gt;&lt;/div&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/heibaiying/BigData-Notes/master/pictures/hdfs-write-2.jpg&quot;/&gt;&lt;/div&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/heibaiying/BigData-Notes/master/pictures/hdfs-write-3.jpg&quot;/&gt;&lt;/div&gt;
&lt;h3 id=&quot;hdfs读数据原理&quot;&gt;2. HDFS读数据原理&lt;/h3&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/heibaiying/BigData-Notes/master/pictures/hdfs-read-1.jpg&quot;/&gt;&lt;/div&gt;
&lt;h3 id=&quot;hdfs故障类型和其检测方法&quot;&gt;3. HDFS故障类型和其检测方法&lt;/h3&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/heibaiying/BigData-Notes/master/pictures/hdfs-tolerance-1.jpg&quot;/&gt;&lt;/div&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/heibaiying/BigData-Notes/master/pictures/hdfs-tolerance-2.jpg&quot;/&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;第二部分：读写故障的处理&lt;/strong&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/heibaiying/BigData-Notes/master/pictures/hdfs-tolerance-3.jpg&quot;/&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;第三部分：DataNode故障处理&lt;/strong&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/heibaiying/BigData-Notes/master/pictures/hdfs-tolerance-4.jpg&quot;/&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;副本布局策略&lt;/strong&gt;：&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/heibaiying/BigData-Notes/master/pictures/hdfs-tolerance-5.jpg&quot;/&gt;&lt;/div&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;http://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-hdfs/HdfsDesign.html&quot;&gt;Apache Hadoop 2.9.2 &amp;gt; HDFS Architecture&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Tom White . hadoop权威指南 [M] . 清华大学出版社 . 2017.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/hudiefenmu/article/details/37655491&quot;&gt;翻译经典 HDFS 原理讲解漫画&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;3.8333333333333&quot;&gt;
&lt;p&gt;更多大数据系列文章可以参见个人 GitHub 开源项目： &lt;a href=&quot;https://github.com/heibaiying/BigData-Notes&quot;&gt;大数据入门指南&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 25 Jun 2019 23:26:00 +0000</pubDate>
<dc:creator>单人影</dc:creator>
<og:description>一、介绍 二、HDFS 设计原理     2.1 HDFS 架构     2.2 文件系统命名空间  &amp;nbs</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/danrenying/p/11087666.html</dc:identifier>
</item>
<item>
<title>Make 编译脚本上手 - 刘哇勇</title>
<link>http://www.cnblogs.com/Wayou/p/gnu_make_tutorial.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Wayou/p/gnu_make_tutorial.html</guid>
<description>&lt;p&gt;考察下面的示例代码：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;main.c&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-c&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
#&lt;span class=&quot;pl-k&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&amp;lt;&lt;/span&gt;stdio.h&lt;span class=&quot;pl-pds&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;

&lt;span class=&quot;pl-k&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;main&lt;/span&gt;(){
    &lt;span class=&quot;pl-c1&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;hello world!&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
    &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;正常情况下，通过 &lt;code&gt;gcc&lt;/code&gt; 在命令行将其编译后产出相应文件，可执行文件或 object 文件等。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot;&gt;
&lt;pre&gt;
$ gcc -o main.out main.c
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面命令编译后运行 &lt;code&gt;main.out&lt;/code&gt; 可执行文件。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
$ ./main.out
hello world&lt;span class=&quot;pl-k&quot;&gt;!&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Make 工具&lt;/h2&gt;
&lt;p&gt;通过 &lt;code&gt;make&lt;/code&gt; 命令，可以将上面的编译进行有效自动化管理。通过将从输入文件到输出文件的编译无则编写成 Makefile 脚本，Make 工具将自动处理文件间依赖及是否需要编译的检测。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;make&lt;/code&gt; 命令所使用的编译配置文件可以是 &lt;code&gt;Makefile&lt;/code&gt;，&lt;code&gt;makefile&lt;/code&gt; 或 &lt;code&gt;GUNMake&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;其中定义任务的基本语法为：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
target1 [target2 ...]: [pre-req-1 pre-req-2 ...]
    [command1
     command2
     ......]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面形式也可称作是一条编译规则（rule）。&lt;/p&gt;
&lt;p&gt;其中，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;target&lt;/code&gt; 为任务名或文件产出。如果该任务不产出文件，则称该任务为 &lt;code&gt;Phony Targets&lt;/code&gt;。&lt;code&gt;make&lt;/code&gt; 内置的 phony target 有 &lt;code&gt;all&lt;/code&gt;, &lt;code&gt;install&lt;/code&gt; 及 &lt;code&gt;clean&lt;/code&gt; 等，这些任务都不实际产出文件，一般用来执行一些命令。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pre-req123...&lt;/code&gt; 这些是依赖项，即该任务所需要的外部输入，这些输入可以是其他文件，也可以是其他任务产出的文件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;command&lt;/code&gt; 为该任务具体需要执行的 shell 命令。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;Makefile 示例&lt;/h2&gt;
&lt;p&gt;比如文章最开始的编译，可通过编写下面的 Makefile 来完成：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Makefile&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-makefile&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-en&quot;&gt;all&lt;/span&gt;:main.out

&lt;span class=&quot;pl-en&quot;&gt;main.out&lt;/span&gt;: main.c
    gcc -o main.out main.c

&lt;span class=&quot;pl-en&quot;&gt;clean&lt;/span&gt;:
    rm main.out
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的 Makefile 中定义了三个任务，调用时可通过 &lt;code&gt;make &amp;lt;target name&amp;gt;&lt;/code&gt; 形式来调用。&lt;/p&gt;
&lt;p&gt;比如:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
$ make main.out
gcc -o main.out main.c
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;产出 &lt;code&gt;main.out&lt;/code&gt; 文件。&lt;/p&gt;
&lt;p&gt;再比如：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot;&gt;
&lt;pre&gt;
$ make clean
rm main.out
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该 &lt;code&gt;clean&lt;/code&gt; 任务清除刚刚生成的 &lt;code&gt;main.out&lt;/code&gt; 文件。&lt;/p&gt;
&lt;p&gt;三个任务中，&lt;code&gt;all&lt;/code&gt; 为内置的任务名，一般一个 Makefile 中都会包含，当直接调用 &lt;code&gt;make&lt;/code&gt; 后面没有跟任务名时，默认执行的就是 &lt;code&gt;all&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
$ make
gcc -o main.out main.c
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;命令的换行&lt;/h2&gt;
&lt;p&gt;如果一条编译规则中所要执行的 shell 命令有单条很长的情况，可通过 &lt;code&gt;\&lt;/code&gt; 来换行。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-makefile&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-en&quot;&gt;main.out&lt;/span&gt;: main.c
    gcc \
    -o main.out \
    main.c
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意 &lt;code&gt;\&lt;/code&gt; 与命令结尾处需要间隔一个空格，否则识别出错。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-makefile&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-en&quot;&gt;main.out&lt;/span&gt;: main.c
    gcc\ &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;#&lt;/span&gt; 🚨&lt;/span&gt;
    -o main.out\ &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;#&lt;/span&gt; 🚨&lt;/span&gt;
    main.c
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;任务间的依赖&lt;/h2&gt;
&lt;p&gt;前面调用 &lt;code&gt;all&lt;/code&gt; 的效果等同于调用 &lt;code&gt;main.out&lt;/code&gt; 任务，因为 &lt;code&gt;all&lt;/code&gt; 的输入依赖为 &lt;code&gt;main.out&lt;/code&gt; 文件。Make 在执行任务前会先检查其输入的依赖项，执行 &lt;code&gt;all&lt;/code&gt; 时发现它依赖 &lt;code&gt;main.out&lt;/code&gt; 文件，于是本地查找，发现本地没有，再从 Makefile 中查找看是否有相应任务会产生该文件，结果确实有相应任务能产生该文件，所以先执行能够产生依赖项的任务。&lt;/p&gt;
&lt;h2&gt;增量编译&lt;/h2&gt;
&lt;p&gt;使用 Makefile 进行编译有个好处是，在执行任务时，它会先检查依赖项是否比需要产出的文件新，如果说依赖项更新新，则说明我们需要产出的目标文件属于过时的产物，需要重新生成。&lt;/p&gt;
&lt;p&gt;什么意思。比如上面的示例，当执行&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot;&gt;
&lt;pre&gt;
$ make main.out 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;试图生成 &lt;code&gt;main.out&lt;/code&gt; 产出时，会检查这个任务的依赖文件 &lt;code&gt;main.c&lt;/code&gt; 是否有修改过。&lt;/p&gt;
&lt;p&gt;比如前面我们已经执行过该任务产生过 &lt;code&gt;main.out&lt;/code&gt;。再次执行时，会得到如下提示：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
$ make main.out 
make: &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;main.out&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt; is up to date.&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; 上面是 Mac 上最新版本的 Make 工具（GNU Make 3.81）的提示语，老版或其他变种工具得到的可能是 &lt;code&gt;Nothing to be done for \&lt;/code&gt;main.out` `。&lt;/p&gt;
&lt;p&gt;现在对输入文件 &lt;code&gt;main.c&lt;/code&gt; 进行修改：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-diff&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;#&lt;/span&gt;include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;

int main(){
&lt;span class=&quot;pl-md&quot;&gt;&lt;span class=&quot;pl-md&quot;&gt;-&lt;/span&gt;     printf(&quot;hello world!&quot;);&lt;/span&gt;
&lt;span class=&quot;pl-mi1&quot;&gt;&lt;span class=&quot;pl-mi1&quot;&gt;+&lt;/span&gt;     printf(&quot;hello wayou!&quot;);&lt;/span&gt;
    return 0;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再次执行 &lt;code&gt;make main.out&lt;/code&gt; 会发现任务正常执行并产生了新的输出，&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
$ make main.out
gcc -o main.out main.c

$ ./main.out
hello wayou&lt;span class=&quot;pl-k&quot;&gt;!&lt;/span&gt;⏎
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里 &lt;code&gt;main.c&lt;/code&gt; 修改后，它在文件上来说，就比 &lt;code&gt;main.out&lt;/code&gt; 更新了，所以我们说 &lt;code&gt;main.out&lt;/code&gt; 这个目标，**过时（out-dated）**了。&lt;/p&gt;
&lt;p&gt;过时的任务才会被重新执行，而未过时的会跳过，并输出相应信息。&lt;/p&gt;
&lt;p&gt;以上，Makefile 天然实现了增量编译的效果，在大型项目下会节省不少编译时间，因为它只编译过期的任务。&lt;/p&gt;
&lt;h2&gt;Phony 类型任务的执行&lt;/h2&gt;
&lt;p&gt;需要注意的是，phony 类型的任务永远都属于过时类型，即，每次 &lt;code&gt;make&lt;/code&gt; 都会执行。因为这种类型的任务它没有文件产出，就无所谓检查，它的主体只是调用了另外的命令而以。&lt;/p&gt;
&lt;p&gt;拿这里的 &lt;code&gt;all&lt;/code&gt; 来说，当我们执行 &lt;code&gt;make&lt;/code&gt; 或 &lt;code&gt;make all&lt;/code&gt; 时，得到：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
$ make
make: Nothing to be &lt;span class=&quot;pl-k&quot;&gt;done&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;all&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;.&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里看不出来 &lt;code&gt;all&lt;/code&gt; 有没有执行，因为目前它还没有包含任何一句命令，调用 &lt;code&gt;all&lt;/code&gt; 后实际执行的是它的依赖文件 &lt;code&gt;main.out&lt;/code&gt; 中的任务，而因为后者已经是最新的了，所以无须执行，所以得到了如上的输出。&lt;/p&gt;
&lt;p&gt;为了验证 phony 类型任务是否每次都执行，向 &lt;code&gt;all&lt;/code&gt; 及 &lt;code&gt;main.out&lt;/code&gt; 中添加 &lt;code&gt;echo&lt;/code&gt; 命令打印一些信息、&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-diff&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
all:main.out
&lt;span class=&quot;pl-mi1&quot;&gt;&lt;span class=&quot;pl-mi1&quot;&gt;+&lt;/span&gt;  echo &quot;[all] done&quot;&lt;/span&gt;

main.out: main.c
    gcc -o main.out main.c
&lt;span class=&quot;pl-mi1&quot;&gt;&lt;span class=&quot;pl-mi1&quot;&gt;+&lt;/span&gt;  echo &quot;[main.out] done&quot;&lt;/span&gt;

clean:
    rm main.out
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再次执行：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
$ make
&lt;span class=&quot;pl-c1&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;[all] done&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;
[all] &lt;span class=&quot;pl-k&quot;&gt;done&lt;/span&gt;

$ make
&lt;span class=&quot;pl-c1&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;[all] done&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;
[all] &lt;span class=&quot;pl-k&quot;&gt;done&lt;/span&gt;

$ make main.out
make: &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;main.out&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt; is up to date.&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到，属于 phony 类型的任务 &lt;code&gt;all&lt;/code&gt; 每次都会执行其中定义的 shell 命令，而非 phony 类型的任务 &lt;code&gt;main.out&lt;/code&gt; 则走了增量编译的逻辑。&lt;/p&gt;
&lt;h2&gt;变量/宏&lt;/h2&gt;
&lt;p&gt;Makefile 中可使用变量（宏）来让脚本更加灵活和减少冗余。&lt;/p&gt;
&lt;p&gt;其中变量使用 &lt;code&gt;$&lt;/code&gt; 加圆括号或花括号的形式来使用，&lt;code&gt;$(VAR)&lt;/code&gt;，定义时类似于 C 中定义宏，所以变量也可叫 Makefile 中的宏，&lt;/p&gt;

&lt;p&gt;这里定义 &lt;code&gt;CC&lt;/code&gt; 表示 &lt;code&gt;gcc&lt;/code&gt; 编译工具。然后在后续编译命令中，就可以使用 &lt;code&gt;$(CC)&lt;/code&gt; 代替 &lt;code&gt;gcc&lt;/code&gt; 来书写 shell 命令了。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-diff&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-mi1&quot;&gt;&lt;span class=&quot;pl-mi1&quot;&gt;+&lt;/span&gt; CC=gcc&lt;/span&gt;

all:main.out

main.out: main.c
&lt;span class=&quot;pl-md&quot;&gt;&lt;span class=&quot;pl-md&quot;&gt;-&lt;/span&gt;    gcc -o main.out main.c&lt;/span&gt;
&lt;span class=&quot;pl-mi1&quot;&gt;&lt;span class=&quot;pl-mi1&quot;&gt;+&lt;/span&gt;  $(CC) -o main.out main.c&lt;/span&gt;

clean:
    rm main.out
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样做的好处是什么？因为编译工具可能随着平台或环境或需要编译的目标不同，而不同。比如 &lt;code&gt;gcc&lt;/code&gt; 只是用来编译 C 代码的，如果是 C++ 你可能要用 &lt;code&gt;g++&lt;/code&gt; 来编译。如果是编译 WebAssembly 则需要使用 &lt;code&gt;emcc&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;无论怎样变，我们只需要修改定义在文件开头的 &lt;code&gt;CC&lt;/code&gt; 变量即可，无须修改其他地方。这当然只是其中一点好处。&lt;/p&gt;
&lt;h2&gt;自动变量/Automatic Variables&lt;/h2&gt;
&lt;p&gt;自动变量/Automatic Variables 是在编译规则匹配后工具进行设置的，具体包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;$@&lt;/code&gt;：代表产出文件名&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$*&lt;/code&gt;：代表产出文件名不包括扩展名&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$&amp;lt;&lt;/code&gt;：依赖项中第一个文件名&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$^&lt;/code&gt;：空格分隔的去重后的所有依赖项&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$+&lt;/code&gt;：同上，但没去重&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$?&lt;/code&gt;：同上，但只包含比产出更新的那些依赖&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这些变量都只有一个符号，区别于正常用字母命名的变量需要使用 &lt;code&gt;$(VAL)&lt;/code&gt; 的形式来使用，自动变量无需加括号。&lt;/p&gt;
&lt;p&gt;利用自动变量，前面示例可改造成：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-makefile&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-smi&quot;&gt;CC&lt;/span&gt;=gcc

&lt;span class=&quot;pl-smi&quot;&gt;TARGET&lt;/span&gt;=main.out

&lt;span class=&quot;pl-en&quot;&gt;all&lt;/span&gt;:&lt;span class=&quot;pl-s&quot;&gt;$(&lt;span class=&quot;pl-smi&quot;&gt;TARGET&lt;/span&gt;)&lt;/span&gt;

&lt;span class=&quot;pl-en&quot;&gt;&lt;span class=&quot;pl-s&quot;&gt;$(&lt;span class=&quot;pl-smi&quot;&gt;TARGET&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;: main.c
    &lt;span class=&quot;pl-s&quot;&gt;$(&lt;span class=&quot;pl-smi&quot;&gt;CC&lt;/span&gt;)&lt;/span&gt; -o &lt;span class=&quot;pl-c1&quot;&gt;$@&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;$^&lt;/span&gt;

&lt;span class=&quot;pl-en&quot;&gt;clean&lt;/span&gt;:
    rm &lt;span class=&quot;pl-s&quot;&gt;$(&lt;span class=&quot;pl-smi&quot;&gt;TARGET&lt;/span&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;减少了重复代码，更加易于维护，需要修改时，改动比较小。&lt;/p&gt;
&lt;h2&gt;VPATH &amp;amp; vpath&lt;/h2&gt;
&lt;p&gt;可通过 &lt;code&gt;VPATH&lt;/code&gt; 指定依赖文件及产出文件的搜索目录。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-makefile&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-smi&quot;&gt;VPATH&lt;/span&gt; = src include
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过小写的 &lt;code&gt;vpath&lt;/code&gt; 可指定具体的文件名及扩展名类型，&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-makefile&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;vpath&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;%&lt;/span&gt;.c src
&lt;span class=&quot;pl-k&quot;&gt;vpath&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;%&lt;/span&gt;.h include
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此处 &lt;code&gt;%&lt;/code&gt; 表示文件名。&lt;/p&gt;
&lt;h2&gt;依赖规则/Dependency Rules&lt;/h2&gt;
&lt;div class=&quot;highlight highlight-source-makefile&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-en&quot;&gt;Main.o&lt;/span&gt; : Main.h Test1.h Test2.h
&lt;span class=&quot;pl-en&quot;&gt;Test1.o&lt;/span&gt; : Test1.h Test2.h
&lt;span class=&quot;pl-en&quot;&gt;Test2.o&lt;/span&gt; : Test2.h
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;像这种，只定义了产出与依赖没包含任务命令的无则，叫作依赖无则。因为它只定义了某个产出依赖哪些输入，故名。&lt;/p&gt;
&lt;p&gt;这种规则可达到这种效果，即，右边任何文件有变更，左边的产出便成为过时的了。&lt;/p&gt;
&lt;h2&gt;匹配规则/Pattern Rules&lt;/h2&gt;
&lt;p&gt;区别于明确指定了产出与依赖，如果一条规则包含通配符，则称作匹配规则（Pattern Rules）。&lt;/p&gt;
&lt;p&gt;比如，&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-makefile&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-en&quot;&gt;&lt;span class=&quot;pl-c1&quot;&gt;%&lt;/span&gt;.o&lt;/span&gt;: &lt;span class=&quot;pl-c1&quot;&gt;%&lt;/span&gt;.c
    gcc -o $@ $^
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面定义了这么一条编译规则，将所有匹配到的 c 文件编译成 Object 产出。&lt;/p&gt;
&lt;p&gt;有什么用？&lt;/p&gt;
&lt;p&gt;这种规则一般不是直接调用的，是被其他它规则触间接使用。比如上面的依赖规则。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-makefile&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-en&quot;&gt;&lt;span class=&quot;pl-c1&quot;&gt;%&lt;/span&gt;.o&lt;/span&gt; : &lt;span class=&quot;pl-c1&quot;&gt;%&lt;/span&gt;.cpp
  g++ -g -o $@ -c $&amp;lt;

&lt;span class=&quot;pl-en&quot;&gt;Main.o&lt;/span&gt; : Main.h Test1.h Test2.h
&lt;span class=&quot;pl-en&quot;&gt;Test1.o&lt;/span&gt; : Test1.h Test2.h
&lt;span class=&quot;pl-en&quot;&gt;Test2.o&lt;/span&gt; : Test2.h
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当右侧这些头文件有变动时，左边的产出会在 &lt;code&gt;make&lt;/code&gt; 时被检测到过时，于是会被执行。当执行时匹配规则 &lt;code&gt;%.o&lt;/code&gt; 会被匹配到，所以匹配规则里面的命令会执行，从而将 &lt;code&gt;cpp&lt;/code&gt; 文件编译成相应 Object 文件。达到了依赖更新后批量更新产出的目的，而不写成这样：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-makefile&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-en&quot;&gt;Main.o&lt;/span&gt; : Main.h Test1.h Test2.h
    g++ -g -o $@ -c $&amp;lt;
&lt;span class=&quot;pl-en&quot;&gt;Test1.o&lt;/span&gt; : Test1.h Test2.h
    g++ -g -o $@ -c $&amp;lt;
&lt;span class=&quot;pl-en&quot;&gt;Test2.o&lt;/span&gt; : Test2.h
    g++ -g -o $@ -c $&amp;lt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;一个实际一点的示例&lt;/h2&gt;
&lt;p&gt;添加 &lt;a href=&quot;http://lame.sourceforge.net/using.php&quot; rel=&quot;nofollow&quot;&gt;lame&lt;/a&gt; 依赖到项目并将其编译打包。&lt;/p&gt;
&lt;p&gt;首先下载并解压 lame 到项目目录：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
$ wget https://sourceforge.net/projects/lame/files/lame/3.100/lame-3.100.tar.gz
$ tar -zxvf lame-3.100.tar.gz
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;主程序中调用 lame，这只仅简单地打印其版本信息：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;main.c&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-c&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
#&lt;span class=&quot;pl-k&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&amp;lt;&lt;/span&gt;stdio.h&lt;span class=&quot;pl-pds&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
#&lt;span class=&quot;pl-k&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;./lame-3.100/include/lame.h&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;

&lt;span class=&quot;pl-k&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;main&lt;/span&gt;() {
  &lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;char&lt;/span&gt;* ver = &lt;span class=&quot;pl-c1&quot;&gt;get_lame_version&lt;/span&gt;();
  &lt;span class=&quot;pl-c1&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;lame ver: &lt;span class=&quot;pl-c1&quot;&gt;%s&lt;/span&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, *ver);
  &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;编译项目的 Makefile:&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Makefile&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-makefile&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-smi&quot;&gt;CC&lt;/span&gt;=gcc

&lt;span class=&quot;pl-smi&quot;&gt;TARGET&lt;/span&gt;=main.out
&lt;span class=&quot;pl-smi&quot;&gt;ENTRY&lt;/span&gt;=main.c
&lt;span class=&quot;pl-smi&quot;&gt;LAME_DIR&lt;/span&gt;=lame-3.100

&lt;span class=&quot;pl-en&quot;&gt;all&lt;/span&gt;: &lt;span class=&quot;pl-s&quot;&gt;$(&lt;span class=&quot;pl-smi&quot;&gt;TARGET&lt;/span&gt;)&lt;/span&gt;

&lt;span class=&quot;pl-en&quot;&gt;&lt;span class=&quot;pl-s&quot;&gt;$(&lt;span class=&quot;pl-smi&quot;&gt;TARGET&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;: &lt;span class=&quot;pl-s&quot;&gt;$(&lt;span class=&quot;pl-smi&quot;&gt;ENTRY&lt;/span&gt;)&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;$(&lt;span class=&quot;pl-smi&quot;&gt;LAME_DIR&lt;/span&gt;)&lt;/span&gt;/libmp3lame/.libs/libmp3lame.a
    &lt;span class=&quot;pl-s&quot;&gt;$(&lt;span class=&quot;pl-smi&quot;&gt;CC&lt;/span&gt;)&lt;/span&gt; -o &lt;span class=&quot;pl-c1&quot;&gt;$@&lt;/span&gt; &lt;span class=&quot;pl-cce&quot;&gt;\&lt;/span&gt;
    &lt;span class=&quot;pl-c1&quot;&gt;$^&lt;/span&gt;

&lt;span class=&quot;pl-en&quot;&gt;&lt;span class=&quot;pl-s&quot;&gt;$(&lt;span class=&quot;pl-smi&quot;&gt;LAME_DIR&lt;/span&gt;)&lt;/span&gt;/libmp3lame/.libs/libmp3lame.a&lt;/span&gt;: 
    &lt;span class=&quot;pl-c1&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;$(&lt;span class=&quot;pl-smi&quot;&gt;LAME_DIR&lt;/span&gt;)&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt; ./configure &lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt; make

&lt;span class=&quot;pl-en&quot;&gt;clean&lt;/span&gt;:
    rm &lt;span class=&quot;pl-s&quot;&gt;$(&lt;span class=&quot;pl-smi&quot;&gt;TARGET&lt;/span&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;编译并运行：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
$ make
$ ./main.out
lame ver: 3⏎
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;相关资源&lt;/h2&gt;
</description>
<pubDate>Tue, 25 Jun 2019 17:58:00 +0000</pubDate>
<dc:creator>刘哇勇</dc:creator>
<og:description>考察下面的示例代码： main.c include &lt;stdio.h&gt; int main(){ printf('hello world!'); return 0; } 正常情况下，通过 g</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Wayou/p/gnu_make_tutorial.html</dc:identifier>
</item>
<item>
<title>【拆分版】Docker-compose构建Zookeeper集群管理Kafka集群 - 东北小狐狸</title>
<link>http://www.cnblogs.com/hellxz/p/docker_zookeeper_cluster_and_kafka_cluster.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hellxz/p/docker_zookeeper_cluster_and_kafka_cluster.html</guid>
<description>&lt;h2 id=&quot;写在前边&quot;&gt;写在前边&lt;/h2&gt;
&lt;p&gt;在搭建Logstash多节点之前，想到就算先搭好Logstash启动会因为日志无法连接到Kafka Brokers而无限重试，所以这里先构建下Zookeeper集群管理的Kafka集群。&lt;/p&gt;
&lt;p&gt;众所周知，Zookeeper是一个高效的分布式协调中间件，可以提供配置信息管理、命名、分布式同步（分布式锁）、集群管理、数据库切换等服务。这里主要用它的集群管理功能，它可以确保在网络状态不一致，选出一致的Master节点。它是Apache下的一个Java项目，隶属于Hadroop系统，正如其名&quot;动物管理员&quot;，作为管理员的角色存在。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;有兴趣了解zookeeper的原理，可以学习Paxos协议与Zab协议。&lt;/p&gt;
&lt;p&gt;ps: Hadroop系统下基本上所有的软件都是动物命名的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在这里，我们将使用Zookeeper来管理Kafka集群，Kafka是一种消息队列（Message Queue）中间件，具有高并发、高吞吐量、容错性强、可扩展等优点。在ELK日志系统中使用Kafka作为数据的缓冲层，提高了系统的性能与稳定性。&lt;/p&gt;
&lt;p&gt;正好今天通过翻看两者官方的文档与其Docker镜像的文档，终于搭建成功，遂记之分享诸君。鉴于水平有限，如有写得不对的地方，欢迎大家指正。&lt;/p&gt;
&lt;h2 id=&quot;本文搭建架构图&quot;&gt;本文搭建架构图&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1149398/201906/1149398-20190625223655424-59132984.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;说明&quot;&gt;说明：&lt;/h2&gt;
&lt;p&gt;Zookeeper搭建成集群后，提供命名服务与集群协调服务，Kafka的节点Broker通过domain与ip进行注册到Zookeeper集群中，通过Zookeeper的协调能力，选出唯一的Leader节点，集群服务启动并对外提供服务。&lt;/p&gt;
&lt;h2 id=&quot;环境准备&quot;&gt;环境准备&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;GNU/Debian Stretch 9.9 linux-4.19&lt;/li&gt;
&lt;li&gt;Docker 18.09.6&lt;/li&gt;
&lt;li&gt;Docker-Compose 1.17.1&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;目录结构&quot;&gt;目录结构&lt;/h2&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;├── docker-kafka-cluster
│   ├── docker-kafka-cluster-down.sh
│   ├── docker-kafka-cluster-up.sh
│   ├── kafka-01
│   │   ├── docker-compose.yml
│   │   └── .env
│   ├── kafka-02
│   │   ├── docker-compose.yml
│   │   └── .env
│   ├── kafka-03
│   │   ├── docker-compose.yml
│   │   └── .env
│   └── kafka-manager
│       ├── docker-compose.yml
│       └── .env
└── docker-zookeeper-cluster
    ├── docker-zk-cluster-down.sh
    ├── docker-zk-cluster-up.sh
    ├── zk-01
    │   ├── docker-compose.yml
    │   └── .env
    ├── zk-02
    │   ├── docker-compose.yml
    │   └── .env
    └── zk-03
        ├── docker-compose.yml
        └── .env
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;docker-zookeeper-cluster源码参见我的Git仓库 &lt;a href=&quot;https://github.com/hellxz/docker-zookeeper-cluster.git&quot; class=&quot;uri&quot;&gt;https://github.com/hellxz/docker-zookeeper-cluster.git&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;docker-kafka-cluster源码参见我的Git仓库 &lt;a href=&quot;https://github.com/hellxz/docker-kafka-cluster.git&quot; class=&quot;uri&quot;&gt;https://github.com/hellxz/docker-kafka-cluster.git&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;各节点容器说明列表&quot;&gt;各节点容器说明列表&lt;/h2&gt;
&lt;h3 id=&quot;zookeeper集群&quot;&gt;Zookeeper集群&lt;/h3&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;zk-01&lt;/td&gt;
&lt;td&gt;zk-01&lt;/td&gt;
&lt;td&gt;2181&lt;/td&gt;
&lt;td&gt;2888&lt;/td&gt;
&lt;td&gt;3888&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;zk-02&lt;/td&gt;
&lt;td&gt;zk-02&lt;/td&gt;
&lt;td&gt;2182&lt;/td&gt;
&lt;td&gt;2889&lt;/td&gt;
&lt;td&gt;3889&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;zk-03&lt;/td&gt;
&lt;td&gt;zk-03&lt;/td&gt;
&lt;td&gt;2183&lt;/td&gt;
&lt;td&gt;2890&lt;/td&gt;
&lt;td&gt;3890&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;kafka集群&quot;&gt;Kafka集群&lt;/h3&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;kafka-01&lt;/td&gt;
&lt;td&gt;kafka-1&lt;/td&gt;
&lt;td&gt;9092&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;kafka-02&lt;/td&gt;
&lt;td&gt;kafka-2&lt;/td&gt;
&lt;td&gt;9093&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;kafka-03&lt;/td&gt;
&lt;td&gt;kafka-3&lt;/td&gt;
&lt;td&gt;9094&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;kafka-manager&lt;/td&gt;
&lt;td&gt;kafka-manager&lt;/td&gt;
&lt;td&gt;19000&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;各文件内容说明&quot;&gt;各文件内容说明&lt;/h2&gt;
&lt;h3 id=&quot;zookeeper部分&quot;&gt;Zookeeper部分&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;docker-zookeeper-cluster/zk-01&lt;/code&gt;目录下的&lt;code&gt;.env&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;.env&lt;/code&gt;配置文件为&lt;code&gt;docker-compose.yml&lt;/code&gt;提供了多个zookeeper的发现服务节点列表&lt;/p&gt;
&lt;p&gt;配置格式为 &lt;code&gt;server.x=x节点主机ip:随从端口:选举端口;客户端口&lt;/code&gt; 其中&lt;code&gt;x&lt;/code&gt;为&lt;code&gt;ZOO.MY.ID&lt;/code&gt;的数值，客户端口前是&lt;code&gt;;&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;# set args to docker-compose.yml by default
# set zookeeper servers, pattern is `server.x=ip:follower-port:election-port;client:port`,
# such as &quot;server.1=192.168.1.1:2888:3888;2181 server.2=192.168.1.2:2888:3888;2181&quot;, 
# `x` is the `ZOO.MY.ID` in docker-compose.yml, multiple server separator by white space.
# now you can overide the ip for server.1 server.2 server.3, here demonstrate in one machine so ip same.
ZOO_SERVERS=server.1=10.2.114.110:2888:3888;2181 server.2=10.2.114.111:2889:3889;2182 server.3=10.2.114.112:2890:3890;2183&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;docker-zookeeper-cluster/zk-01&lt;/code&gt;目录下的&lt;code&gt;docker-compose.yml&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;version: '3'
services:
    zk-01:
        image: zookeeper:3.5.5
        restart: always
        container_name: zk-01
        ports:
            - 2181:2181 # client port
            - 2888:2888 # follower port
            - 3888:3888 # election port
        environment:
            ZOO_MY_ID: 1 # this zookeeper's id, and others zookeeper node distinguishing
            ZOO_SERVERS: ${ZOO_SERVERS} # zookeeper services list
        network_mode: &quot;host&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;kafka部分&quot;&gt;Kafka部分&lt;/h3&gt;
&lt;p&gt;以&lt;code&gt;kafka-01&lt;/code&gt;目录下的&lt;code&gt;.env&lt;/code&gt; 为例&lt;/p&gt;
&lt;p&gt;&lt;code&gt;.env&lt;/code&gt;配置文件为&lt;code&gt;docker-compose.yml&lt;/code&gt;提供了多个zookeeper的&lt;code&gt;ip:client-port&lt;/code&gt;列表&lt;/p&gt;
&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;# default env for kafka docker-compose.yml
# set zookeeper cluster, pattern is &quot;zk1-host:port,zk2-host:port,zk3-host:port&quot;, use a comma as multiple servers separator.
ZOO_SERVERS=10.2.114.110:2181,10.2.114.111:2182,10.2.114.112:2183&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以&lt;code&gt;kafka-01&lt;/code&gt;目录下的&lt;code&gt;docker-compose.yml&lt;/code&gt;，为docker-compse的配置文件&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;version: &quot;3&quot;
services:
    kafka-1:
        image: wurstmeister/kafka:2.12-2.1.1
        restart: always
        container_name: kafka-1
        environment:
            - KAFKA_BROKER_ID=1 #kafka的broker.id，区分不同broker
            - KAFKA_LISTENERS=PLAINTEXT://kafka1:9092 #绑定监听9092端口
            - KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://kafka1:9092 #绑定发布订阅的端口
            - KAFKA_ZOOKEEPER_CONNECT=${ZOO_SERVERS} #连接zookeeper的服务地址
            - KAFKA_MESSAGE_MAX_BYTES=2000000 #单条消息最大字节数
            #- KAFKA_CREATE_TOPICS=Topic1:1:3,Topic2:1:1:compact #创建broker时创建的topic:partition-num:replica-num[:clean.policy]
        network_mode: &quot;host&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7.2567567567568&quot;&gt;
&lt;p&gt;&lt;code&gt;KAFKA_CREATE_TOPICS&lt;/code&gt;使用官方说明：&lt;code&gt;Topic 1&lt;/code&gt; will have 1 partition and 3 replicas, &lt;code&gt;Topic 2&lt;/code&gt; will have 1 partition, 1 replica and a &lt;code&gt;cleanup.policy&lt;/code&gt; set to &lt;code&gt;compact&lt;/code&gt;. 文档地址：&lt;a href=&quot;https://hub.docker.com/r/wurstmeister/kafka&quot; class=&quot;uri&quot;&gt;https://hub.docker.com/r/wurstmeister/kafka&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;zookeeper集群使用&quot;&gt;Zookeeper集群使用&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;请确保所布署的 1~3 台服务器网络可以ping通&lt;/li&gt;
&lt;li&gt;确保第一台主机的2181\2888\3888端口未占用，第二台主机的2182\2889\3889端口未占用，第三台主机的2183\2890\3890端口未占用&lt;/li&gt;
&lt;li&gt;复制zk-01到第一台主机、复制zk-02到第二台主机、复制zk-03到第三台主机&lt;/li&gt;
&lt;li&gt;修改zk-01\zk-02\zk-03目录下的.env中的&lt;code&gt;ZOO_SERVERS&lt;/code&gt;的值，按上述配置要求修改。修改完后的配置应该是集群内通用的，可以scp复制过去。&lt;/li&gt;
&lt;li&gt;单台主机请为&lt;code&gt;docker-zk-cluster-up.sh&lt;/code&gt;与&lt;code&gt;docker-zk-cluster-down.sh&lt;/code&gt;授执行权，使用它们进行up和down操作；多台主机请手动分别进入zk-0x目录，执行&lt;code&gt;docker-compose up -d&lt;/code&gt;以启动，执行&lt;code&gt;docker-compose down&lt;/code&gt;以关闭。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;kafka集群使用&quot;&gt;Kafka集群使用&lt;/h2&gt;
&lt;ol readability=&quot;9.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;使用前确保各主机可以互相ping通&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;确保zookeeper的服务列表与各对应的zookeeper的ip与客户端口相同，如不同注意修改&lt;code&gt;.env&lt;/code&gt;，集群中&lt;code&gt;.env&lt;/code&gt;文件相同，可scp复制&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;确保zookeeper集群启动&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;复制kafka-01到第一台主机、复制kafka-02到第二台主机、复制kafka-03到第三台主机&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;确保这几台主机对应的占用端口号不被占用 &lt;code&gt;kafka-01对应9092&lt;/code&gt;、 &lt;code&gt;kafka-02对应9093&lt;/code&gt;、&lt;code&gt;kafka-03对应9094&lt;/code&gt;、&lt;code&gt;kafka-manager对应19000&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;分别对每一台kafka-0x所在的主机修改&lt;code&gt;/etc/hosts&lt;/code&gt;，例&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;10.2.114.110 kafka1
10.2.114.111 kafka2
10.2.114.112 kafka3&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;其中每个主机只需要设置自己的主机上的host，比如我复制了&lt;code&gt;kafka-01&lt;/code&gt;我就写&lt;code&gt;本机ip kafka1&lt;/code&gt; ,依次类推.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;单台主机部署kafka集群请为&lt;code&gt;docker-kafka-cluster-up.sh&lt;/code&gt;与&lt;code&gt;docker-kafka-cluster-down.sh&lt;/code&gt;授执行权，不要移动目录，通过这两个shell脚本来启动项目；多台主机请手动进入&lt;code&gt;kafka-0x&lt;/code&gt;目录下，执行&lt;code&gt;docker-compose up -d&lt;/code&gt;以后台启动，执行&lt;code&gt;docker-compose down&lt;/code&gt;以移除容器&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;启动脚本中没有启动&lt;code&gt;kafka-manager&lt;/code&gt;，有需要请自行启动。为了匹配kafka的版本，使用时设置2.1.1即可。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;3.974025974026&quot;&gt;
&lt;p&gt;文中配置部分的ip因使用同一台主机做的测试，所以ip相同，为了防止误解，在文中已经修改了ip，具体详见：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;本文系原创文章，谢绝转载&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 25 Jun 2019 17:44:00 +0000</pubDate>
<dc:creator>东北小狐狸</dc:creator>
<og:description>写在前边 在搭建Logstash多节点之前，想到就算先搭好Logstash启动会因为日志无法连接到Kafka Brokers而无限重试，所以这里先构建下Zookeeper集群管理的Kafka集群。 众</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hellxz/p/docker_zookeeper_cluster_and_kafka_cluster.html</dc:identifier>
</item>
<item>
<title>在 Ubuntu 开启 GO 程序编译之旅 - 三人行工作室</title>
<link>http://www.cnblogs.com/timeddd/p/11087602.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/timeddd/p/11087602.html</guid>
<description>&lt;p&gt;本文将使用 putty 连接到一台阿里云 Ubuntu 16.04 服务器，在其上安装 go 语言的编译环境，旨在呈现从安装到“你好，世界！”涉及的方方面面，希望完成这个过程无须觅它处。&lt;/p&gt;
&lt;h3 id=&quot;安装&quot;&gt;1. 安装&lt;/h3&gt;
&lt;h4 id=&quot;方式一使用-apt-get&quot;&gt;方式一使用 apt-get&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;apt-get install golang-go&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行完成之后，会把 golang 安装在这个位置：&lt;code&gt;/usr/lib/go-1.6/&lt;/code&gt;，go 命令会在该目录的 bin 子目录下，同时，/usr/bin 下会有该命令的文件链接。&lt;/p&gt;
&lt;p&gt;当然，也许你并不知道到底安装在哪，可以通过以下命令找找观察判断一下。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 找名字为 go 的文件
find / -name go&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行 &lt;code&gt;/usr/bin/go version&lt;/code&gt;，结果如下，显示的版本号为 go1.6.2，版本比较低。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/577842/201906/577842-20190626013853184-548647452.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;是不是想卸载？使用以下命令可以完成卸载，跟安装一一对应。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;apt-get --purge remove golang-go&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;方式二使用-wget&quot;&gt;方式二使用 wget&lt;/h4&gt;
&lt;p&gt;直接下载想要的版本进行安装，一切皆在掌控之中。通过以下两条命令，我们把 golang 安装在 /usr/local/go 下。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 下载
wget https://storage.googleapis.com/golang/go1.9.1.linux-amd64.tar.gz
# 解压
tar -xzf go1.9.1.linux-amd64.tar.gz -C /usr/local&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;设置环境变量&quot;&gt;2. 设置环境变量&lt;/h3&gt;
&lt;p&gt;这里会涉及到3个环境变量，分别是 PATH、GOROOT、GOPATH。&lt;br/&gt;&lt;strong&gt;PATH&lt;/strong&gt;，是为了让 go 命令随处可敲。&lt;br/&gt;&lt;strong&gt;GOROOT&lt;/strong&gt;，代表 golang 的根目录，在设置PATH时可以用一下，如　export PATH=$GOROOT/bin。&lt;br/&gt;&lt;strong&gt;GOPATH&lt;/strong&gt;，特别重要，单独做一节(2.2)来讲。&lt;/p&gt;
&lt;h4 id=&quot;设置&quot;&gt;2.1 设置&lt;/h4&gt;
&lt;p&gt;环境变量可以设置在不同的文件中。&lt;br/&gt;etc/profile : 对所有用户生效&lt;br/&gt;~/.profile : 对当前用户生效&lt;/p&gt;
&lt;p&gt;配置在哪都行，能用到即可。在配置文件末尾加上以下文本。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;export GOROOT=/usr/local/go
export GOPATH=/usr/goprojs
export PATH=$GOROOT/bin:$PATH:$GOPATH/bin&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;GOPATH、PATH 多个路径，中间使用冒号分隔。&lt;br/&gt;配置完成后，使用&lt;code&gt;source ~/.profile&lt;/code&gt; 让其立即生效。&lt;/p&gt;
&lt;h4 id=&quot;gopath&quot;&gt;2.2 GOPATH&lt;/h4&gt;
&lt;p&gt;GOPATH 是GO程序找依赖包的路径。&lt;br/&gt;其子目录 src 中可放置各个包的源码，编译时会通过 GOPATH 去引用它们。&lt;br/&gt;子目录 bin 则是编译之后的可执行文件，在PATH 里要加上各$GOPATH/bin 可以让编译的运行文件在执行搜索路径范围内方便执行。&lt;br/&gt;子目录 pkg，编译包的中间文件，不太关心它。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;GOPATH 的第一个路径特别重要&lt;/strong&gt;。&lt;br/&gt;使用 go get 下载的包都会安装在第一个路径，所以如果想让公共包统一在某处，应该要为它单独建立一个路径作为GOPATH的第一个路径，从而使得 go get 总去向那里。实际项目最好另建路径加入GOPATH，这样即在引用范围 go get 又影响不到。&lt;/p&gt;
&lt;p&gt;附 go get 可带参数：&lt;br/&gt;|参数|描述|&lt;br/&gt;|------|------|&lt;br/&gt;| -v |显示操作流程的日志及信息 |&lt;br/&gt;| -u |仅下载丢失的包，不更新已存在的 |&lt;br/&gt;| -d | 只下载，不安装 |&lt;br/&gt;| -insecure | 允许使用HTTP，而不一定要HTTPS |&lt;/p&gt;
&lt;h3 id=&quot;你好世界&quot;&gt;3. 你好，世界！&lt;/h3&gt;
&lt;h4 id=&quot;编写代码&quot;&gt;3.1 编写代码&lt;/h4&gt;
&lt;p&gt;建立代码文件。&lt;a href=&quot;https://www.runoob.com/try/runcode.php?filename=helloworld&amp;amp;type=go&quot;&gt;点此可以在线尝鲜 GO 代码&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;vi hello.go
// 输入以下代码保存
package main
import &quot;fmt&quot;

func main(){
    fmt.Println(&quot;Hello world!&quot;)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;执行&quot;&gt;3.2 执行&lt;/h4&gt;
&lt;p&gt;直接在文件目录执行以下命令运行。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;go run hello.go
// 或者
go build hello.go
./hello&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;附件&quot;&gt;4. 附件&lt;/h3&gt;
&lt;p&gt;设置环境变量的配置文件，有网友总结：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;/etc/profile，/etc/bashrc 是系统全局环境变量设定&lt;br/&gt;~/.profile，~/.bashrc用户家目录下的私有环境变量设定&lt;br/&gt;当登入系统时候获得一个shell进程时，其读取环境设定档有三步&lt;br/&gt;1）.首先读入的是全局环境变量设定档/etc/profile，然后根据其内容读取额外的设定的文档，如&lt;br/&gt;/etc/profile.d和/etc/inputrc&lt;br/&gt;2）.然后根据不同使用者帐号，去其家目录读取~/.bash_profile，如果这读取不了就读取~/.bash_login，这个也读取不了才会读取&lt;br/&gt;~/.profile，这三个文档设定基本上是一样的，读取有优先关系&lt;br/&gt;3）.然后在根据用户帐号读取~/.bashrc&lt;br/&gt;~/.profile与~/.bashrc的区别&lt;br/&gt;都具有个性化定制功能&lt;br/&gt;~/.profile可以设定本用户专有的路径，环境变量，等，它只能登入的时候执行一次&lt;br/&gt;~/.bashrc也是某用户专有设定文档，可以设定路径，命令别名，每次shell script的执行都会使用它一次&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 25 Jun 2019 17:41:00 +0000</pubDate>
<dc:creator>三人行工作室</dc:creator>
<og:description>本文将使用 putty 连接到一台阿里云 Ubuntu 16.04 服务器，在其上安装 go 语言的编译环境，旨在呈现从安装到“你好，世界！”涉及的方方面面，希望完成这个过程无须觅它处。 1. 安装</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/timeddd/p/11087602.html</dc:identifier>
</item>
<item>
<title>微信小程序入口场景的问题整理与相关解决方案 - 韩子卢</title>
<link>http://www.cnblogs.com/vvjiang/p/11087376.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/vvjiang/p/11087376.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;最近一段时间都在做小程序。&lt;/p&gt;
&lt;p&gt;虽然是第二次开发小程序，但是上次做小程序已经是一年前的事了，所以最终还是被坑得死去活来。&lt;/p&gt;
&lt;p&gt;这次是从零开始开发一个小程序，其实除了一些莫名其妙的兼容性问题，大多数坑点都是在微信小程序的各个入口场景处。&lt;/p&gt;
&lt;p&gt;所以这里整理一下微信小程序的各个入口场景，以及从这些入口场景进入小程序会面临的问题以及解决方案。&lt;/p&gt;
&lt;p&gt;这里只列出常用的几种场景：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;[简单场景]启动小程序并进入&lt;/li&gt;
&lt;li&gt;[简单场景]退出重进（启动小程序后，退出小程序，再次进入小程序）&lt;/li&gt;
&lt;li&gt;[简单场景]退出重进首页（启动小程序后，退出小程序，通过扫二维码再次进入小程序）&lt;/li&gt;
&lt;li&gt;[复杂场景]启动并进入指定页面（从小程序的分享卡片或者微信发送的通知消息进入小程序）&lt;/li&gt;
&lt;li&gt;[复杂场景]退出重进指定页面（启动小程序后，退出小程序，从小程序的分享卡片或者微信发送的通知消息进入小程序）&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;启动小程序并进入&quot;&gt;启动小程序并进入&lt;/h2&gt;
&lt;p&gt;微信小程序的入口场景光微信提供的场景值就有几十种，但是绝大多数都可以划分为启动小程序并进入。&lt;/p&gt;
&lt;p&gt;这是最常用的一种进入小程序的方式，比如通过搜索进入或者点击最近使用小程序的方式进入，都算是这种类型。&lt;/p&gt;
&lt;p&gt;这一场景下，首先我们需要明白发生了什么：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;下载小程序 =&amp;gt; 启动小程序 onLaunch事件触发 =&amp;gt; 加载首页 onLoad事件触发 =&amp;gt; 首页 onShow事件&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在这个场景下，需要注意以下几个问题：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;这个场景下一般会涉及到登录。&lt;br/&gt;所谓登录，不一定是要在这个阶段做，但是登录信息的判断这个阶段是一定要做的。&lt;br/&gt;通常前端肯定是要将登录的这些信息存储在小程序的storage里，然后在onLaunch事件中判断是否登录，没登录就跳转到登录页面，登录了就跳转到首页。&lt;br/&gt;这里的登录判断一定要放在onLaunch，而不要放在首页的onLoad里面，因为小程序启动一定会进入onLaunch，而不一定会进入首页的onLoad。&lt;/li&gt;
&lt;li&gt;而登录页面在设计的时候最好要加上一个url参数，传入登录成功后跳转到的页面地址，而不是登录之后始终跳转到首页，后面会讲为什么需要这么做。&lt;/li&gt;
&lt;li&gt;onLaunch阶段是否有发出请求，并在请求完成后进行了页面跳转，或者请求完成设置storage，并在onLoad页面中使用？&lt;br/&gt;这种情况的出现，会导致在请求时间过长时，首页的onLoad已经执行了，此时就会出现BUG。&lt;br/&gt;对于这个问题，有的人会用定时器去判断是否完成这个操作，但是我的建议是尽量避免在onLaunch中进行这些操作。&lt;br/&gt;如果一定要有，那么最好的方式就是做一个加载页面去承载这些功能。&lt;/li&gt;
&lt;li&gt;首页数据的初始化，一般是放在onLoad中执行。当然总是有些特殊的需求是要放在onShow里面的。&lt;br/&gt;关于onLoad和onShow，最常见的处理区别就在跳转页面时。&lt;br/&gt;当载入首页时，先触发onLoad，再触发onShow。&lt;br/&gt;此时通过wx.navigateTo 的方式跳转到页面A，这个时候首页并没有被关闭，那么从页面A再返回首页时，onLoad就不会触发，但onShow会触发。&lt;br/&gt;通常在加载数据时，一般会用到onLoad。&lt;br/&gt;但是如果说页面A更新了数据，然后返回首页时，首页的相关数据也需要更新。&lt;br/&gt;那么初始化数据就不能放在onLoad里，而需要放在onShow里。&lt;br/&gt;（当然还有一种方式是通过getCurrentPages的方式在页面A中调用首页的方法。但是这里极不推荐这种方式，属于某个页面的事情一定要给这个页面。最好不要将页面间的职责通过这种方式打乱，容易引起代码混乱，不易维护。）&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;退出重进启动小程序后退出小程序再次进入小程序&quot;&gt;退出重进（启动小程序后，退出小程序，再次进入小程序）&lt;/h2&gt;
&lt;p&gt;这种场景实际上是对第一种场景的扩展。&lt;/p&gt;
&lt;p&gt;而所谓的退出小程序不管你是点右上角的退出按钮还是Home键直接切出都算是这类退出。&lt;/p&gt;
&lt;p&gt;但是退出后再立即进入小程序的时候，依然会进入你退出小程序时所在的页面，而不会触发onLaunch，也不会触发这个页面的onLoad，不过onShow是肯定会触发的。&lt;/p&gt;
&lt;p&gt;这一场景下，首先我们需要明白发生了什么：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;再次进入小程序 =&amp;gt; 进入退出小程序时所在页面 触发onShow&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这个场景下，只需要注意onShow中是否有不可重复执行的操作。&lt;/p&gt;
&lt;p&gt;例如onShow中会获取用户喜欢吃的食物，加载到页面的列表中，在这种场景下，如果不清空之前的列表或者加个判断的话，就会出现重复数据。&lt;/p&gt;
&lt;h2 id=&quot;退出重进首页启动小程序后退出小程序通过扫二维码再次进入小程序&quot;&gt;退出重进首页（启动小程序后，退出小程序，通过扫二维码再次进入小程序）&lt;/h2&gt;
&lt;p&gt;这种场景实际上是对第二种场景的扩展。&lt;/p&gt;
&lt;p&gt;我们通常给二维码配置的是一个无参数的小程序首页地址，当我们退出小程序，通过扫二维码再次进入小程序时会进入首页。&lt;/p&gt;
&lt;p&gt;这一场景下，首先我们需要明白发生了什么：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;再次进入小程序 =&amp;gt; 进入退出小程序时所在页面A 不触发onShow =&amp;gt; 触发页面A onHide =&amp;gt; 触发页面A onUnload=&amp;gt; 进入首页 onLoad =&amp;gt; 首页onShow&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这个场景下，除了需要注意第二种场景存在的问题，还需要注意页面A的onHide事件中是否会触发奇怪的操作，例如页面跳转。&lt;/p&gt;
&lt;h2 id=&quot;启动并进入指定页面从小程序的分享卡片或者微信发送的通知消息进入小程序&quot;&gt;启动并进入指定页面（从小程序的分享卡片或者微信发送的通知消息进入小程序）&lt;/h2&gt;
&lt;p&gt;这块场景常见于邀请他人进入小程序，需要注意的是他们往往被赋予了更多的业务功能，也就往往增大了小程序的实现难度。&lt;/p&gt;
&lt;p&gt;这一场景下，首先我们需要明白发生了什么：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;下载小程序 =&amp;gt; 启动小程序 onLaunch事件触发 =&amp;gt; 加载指定页面 onLoad事件触发 =&amp;gt;指定页面  onShow事件&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里就可以看出，并不是进入小程序就一定会进入首页的onLoad。&lt;/p&gt;
&lt;p&gt;所以这就是为什么之前强调不要将登录判断放在首页的onLoad中，而一定要放在onLaunch里。&lt;/p&gt;
&lt;p&gt;但是这里又和扫二维码不同，扫二维码的链接一般都是指定的首页。&lt;/p&gt;
&lt;p&gt;而这里通常跳转到的是非首页的页面，而且可能还多了复杂的业务功能。&lt;/p&gt;
&lt;p&gt;我们在需求分析和设计阶段应该更多地考虑到这里可能会引发的复杂问题，而尽量将此处的业务逻辑简化，或者加大估时。&lt;/p&gt;
&lt;p&gt;接下来，我们将根据业务从简单到复杂，慢慢讲解这个场景下可能存在的问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最简单的邀请函（进入小程序首页）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;和第一种场景差不多，这里略过&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;进阶邀请函（进入小程序指定页面，带参数，需要根据参数初始化页面）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这种情况下，需要考虑以下几个问题：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;首先在onLaunch阶段会判断是否登录，没登录那么就需要跳转到登录页面，登录页面登录之后，肯定要跳转到这个页面，而不是首页。&lt;br/&gt;所以之前说过登录页面设计的时候需要传入一个url参数，来明确登录成功后跳转到哪个页面。&lt;/li&gt;
&lt;li&gt;这种跳转到指定页面的情况通常都需要一个回到首页的按钮。&lt;br/&gt;就比如邀请某人查看一篇文章，点击邀请卡片后会进入小程序内的文章详情。&lt;br/&gt;一般在小程序内通常是通过点击文章列表跳转到文章详情，那么这个时候可以逐级返回到首页。&lt;br/&gt;但是在点击邀请函进入的情况是没有返回功能的，此时如果没有回到首页功能，那么用户可能就永远没法回到首页。&lt;br/&gt;（其实是可以的，但是小程序的的这个功能藏得比较深，不要指望所有用户都那么热爱摸索）&lt;/li&gt;
&lt;li&gt;这里一定要特别注意第一种场景的第三个应该注意的问题，对于第一种场景而言那个问题因为启动次数很多容易出现，但是在当前的场景下可能很容易被忽略掉。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;涉及身份的邀请函（进入小程序指定页面，带参数，需要根据参数切换身份，更可能涉及到登录）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了更好地说明这种情况，我们来列举一个场景。&lt;/p&gt;
&lt;p&gt;如果有一个打车软件，进入这个软件后有两种身份，一种是乘客，一种是司机。&lt;/p&gt;
&lt;p&gt;用户是司机，那么看到的是页面A或者选定了TabA，如果是乘客，那么看到的是页面B或者选定了TabB。&lt;/p&gt;
&lt;p&gt;而且还有一个需求，用户上次登陆时什么身份，这次登陆也是什么身份。&lt;/p&gt;
&lt;p&gt;考虑到换手机的场景，那么这个信息肯定是存储在服务端的，所以进入小程序的时候会去请求服务端进行判断。&lt;/p&gt;
&lt;p&gt;现在我用司机的身份发了个单，微信给了个通知消息，我没点开。然后切换到乘客的身份了，再去点击通知消息，那么我会以司机的身份去打开这个消息。&lt;/p&gt;
&lt;p&gt;这个场景其实在业务上来看是很合理的，但是对于我们的程序实现来看，复杂度一下子就上来了。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;首先我们确定一下这个请求身份信息的请求在哪个阶段发出？&lt;br/&gt;onLaunch？&lt;br/&gt;那么是不是需要在onLoad阶段去获取这个身份的信息然后给出不同的页面？&lt;br/&gt;这样一下子就会出现进阶邀请函的第三个问题，而且还不仅仅是这一个问题，之后我们会讲到。&lt;br/&gt;所以这个地方需要做一个专门的邀请加载页面去处理这个事情。&lt;/li&gt;
&lt;li&gt;分离出一个单独的加载页面之后，其实我们的工作会变的简单清晰起来。&lt;br/&gt;因为我们只需要去做我们这个页面所需要做的事情就行了。&lt;br/&gt;根据参数去获取我们现在的身份，然后以这种身份跳转到相应的页面。&lt;/li&gt;
&lt;li&gt;这里还涉及到一个问题，那就是正常启动而不是通过通知消息进入的时候，也需要去请求服务端获取身份信息。&lt;br/&gt;我给的建议是一定要另外单独建一个页面去承载这个功能，而不要将这两个加载页面糅合到一起。&lt;br/&gt;里面的页面展示我们可以用组件化的方式去做，但是页面的逻辑一点更要分开。&lt;br/&gt;因为这两种情况真的很容易混杂，也是为了利于后面的维护工作。&lt;/li&gt;
&lt;li&gt;正常启动时的加载页面也可以看情况糅合到首页的onLoad里面。&lt;br/&gt;但是如果有可能，还是希望放在单独的页面里。&lt;br/&gt;首页往往功能很多，代码量比较大，不要将本来可以分离出去的功能放进去。&lt;br/&gt;还是那句话，页面的职责分开。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我这里讲的其实还是一个比较常见的功能，通常我们的业务也不一定像上面这样简单。&lt;/p&gt;
&lt;p&gt;所以如果涉及到这方面的操作，在需求分析和设计的时候就应该考虑清楚。&lt;/p&gt;
&lt;p&gt;如果等到功能开发的时候再去考虑这些事情，那么等待你的一定是延期或者加班。&lt;/p&gt;
&lt;h2 id=&quot;退出重进指定页面启动小程序后退出小程序从小程序的分享卡片或者微信发送的通知消息进入小程序&quot;&gt;退出重进指定页面（启动小程序后，退出小程序，从小程序的分享卡片或者微信发送的通知消息进入小程序）&lt;/h2&gt;
&lt;p&gt;这种场景同样是第四种场景的进阶，但是如果你在第四种场景中使用了我所说的加载页面，那么接下来的问题会简单很多。&lt;/p&gt;
&lt;p&gt;这一场景下，首先我们需要明白发生了什么：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;再次进入小程序 =&amp;gt; 进入退出小程序时所在页面A 不触发onShow =&amp;gt; 触发页面A onHide =&amp;gt; 触发页面A onUnload =&amp;gt; 进入邀请加载页面onLoad =&amp;gt; 加载页面onShow&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于第四种场景中的打车小程序而言，如果按照我们先前所说没有在onLaunch中获取身份信息，而是放在了加载页中，那么现在什么都不用改。&lt;/p&gt;
&lt;p&gt;如果获取身份信息的请求放在onLaunch中，现在又得在onLoad中加一道逻辑。&lt;/p&gt;
&lt;p&gt;当然这里还是得注意一个问题，对于这一类型的进入小程序的方式，比如从分享卡片进入和微信的通知消息进入。&lt;/p&gt;
&lt;p&gt;即使他们所进入的页面不同，但是他们都可以使用这个载入页面去做判断。&lt;/p&gt;
&lt;p&gt;与正常启动场景的载入页面是不同的，他们本来就是同一种入口场景。&lt;/p&gt;
&lt;p&gt;所以该共用的地方还是得共用，用不同的业务code判断即可。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;总的来说，以上的几种情况应该能涵盖绝大多数小程序的入口场景。&lt;/p&gt;
&lt;p&gt;整理的目的其实主要是为了做需求分析和设计时参考使用，以避免在考虑业务问题时漏过这些场景导致后期的工作计划受到影响。&lt;/p&gt;
&lt;p&gt;所谓加班和项目延期发布，大都是前期需求分析和设计考虑不周。&lt;/p&gt;
&lt;p&gt;我们不可能考虑到所有的场景，但是应该尽善尽美。&lt;/p&gt;
&lt;p&gt;谋定而后动，前事不忘后事之师，也算是PDCA了。&lt;/p&gt;
</description>
<pubDate>Tue, 25 Jun 2019 16:41:00 +0000</pubDate>
<dc:creator>韩子卢</dc:creator>
<og:description>前言 最近一段时间都在做小程序。 虽然是第二次开发小程序，但是上次做小程序已经是一年前的事了，所以最终还是被坑得死去活来。 这次是从零开始开发一个小程序，其实除了一些莫名其妙的兼容性问题，大多数坑点都</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/vvjiang/p/11087376.html</dc:identifier>
</item>
<item>
<title>kubeadm1.14.1 安装Metrics Server - 渣渣辉</title>
<link>http://www.cnblogs.com/Dev0ps/p/11087497.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Dev0ps/p/11087497.html</guid>
<description>&lt;p class=&quot;blockParagraph-544a408c&quot; data-key=&quot;65a9bf7d355f40e89049d2dadef3f800&quot;&gt;&lt;span class=&quot;text-4505230f--TextH400-3033861f--textContentFamily-49a318e1&quot;&gt;&lt;span data-key=&quot;3d8494a78b3440d79e6473e6bd46860e&quot;&gt;&lt;span data-offset-key=&quot;3d8494a78b3440d79e6473e6bd46860e:0&quot;&gt;介绍Metrics-Server之前，必须要提一下Metrics API的概念&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;blockParagraph-544a408c&quot; data-key=&quot;13e989eaf7254ba4ad6bdcbbf100debb&quot;&gt;&lt;span class=&quot;text-4505230f--TextH400-3033861f--textContentFamily-49a318e1&quot;&gt;&lt;span data-key=&quot;cfd73afb723a4e8b94bd22b10d19b5c2&quot;&gt;&lt;span data-offset-key=&quot;cfd73afb723a4e8b94bd22b10d19b5c2:0&quot;&gt;Metrics API相比于之前的监控采集方式(hepaster)是一种新的思路，官方希望核心指标的监控应该是稳定的，版本可控的，且可以直接被用户访问(例如通过使用 kubectl top 命令)，或由集群中的控制器使用(如HPA)，和其他的Kubernetes APIs一样。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;blockParagraph-544a408c&quot; data-key=&quot;fa334aeb8e014ea8975aeab733c44b31&quot;&gt;&lt;span class=&quot;text-4505230f--TextH400-3033861f--textContentFamily-49a318e1&quot;&gt;&lt;span data-key=&quot;e6292472cbdb4846bcc1a8934a879f6c&quot;&gt;&lt;span data-offset-key=&quot;e6292472cbdb4846bcc1a8934a879f6c:0&quot;&gt;官方废弃heapster项目，就是为了将核心资源监控作为一等公民对待，即像pod、service那样直接通过api-server或者client直接访问，不再是安装一个hepater来汇聚且由heapster单独管理。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;blockParagraph-544a408c&quot; data-key=&quot;d5982b25335d48f7885ab73e027b149b&quot;&gt;&lt;span class=&quot;text-4505230f--TextH400-3033861f--textContentFamily-49a318e1&quot;&gt;&lt;span data-key=&quot;44fc46f347524656b18aa86312771041&quot;&gt;&lt;span data-offset-key=&quot;44fc46f347524656b18aa86312771041:0&quot;&gt;假设每个pod和node我们收集10个指标，从k8s的1.6开始，支持5000节点，每个节点30个pod，假设采集粒度为1分钟一次，则：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;codeBlock-18b09018&quot; readability=&quot;6&quot;&gt;
&lt;div data-key=&quot;f57c7e173edc406b89d542db994efae2&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-key=&quot;f3b203a911164e06bf22e1bad826222a&quot;&gt;&lt;span data-offset-key=&quot;f3b203a911164e06bf22e1bad826222a:0&quot;&gt;10 x 5000 x 30 / 60 = 25000 平均每分钟2万多个采集指标&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;blockParagraph-544a408c&quot; data-key=&quot;ae4f760b73b24098805f8e531502b2da&quot;&gt;&lt;span class=&quot;text-4505230f--TextH400-3033861f--textContentFamily-49a318e1&quot;&gt;&lt;span data-key=&quot;5bcee2e38e7e453e8ef0e9ceee20ac2d&quot;&gt;&lt;span data-offset-key=&quot;5bcee2e38e7e453e8ef0e9ceee20ac2d:0&quot;&gt;因为k8s的api-server将所有的数据持久化到了etcd中，显然k8s本身不能处理这种频率的采集，而且这种监控数据变化快且都是临时数据，因此需要有一个组件单独处理他们，k8s版本只存放部分在内存中，于是metric-server的概念诞生了。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;blockParagraph-544a408c&quot; data-key=&quot;bf180a14b21249adb2ab9857084ab136&quot;&gt;&lt;span class=&quot;text-4505230f--TextH400-3033861f--textContentFamily-49a318e1&quot;&gt;&lt;span data-key=&quot;4078ff027e4243b1af951e5c1b94004f&quot;&gt;&lt;span data-offset-key=&quot;4078ff027e4243b1af951e5c1b94004f:0&quot;&gt;其实hepaster已经有暴露了api，但是用户和Kubernetes的其他组件必须通过master proxy的方式才能访问到，且heapster的接口不像api-server一样，有完整的鉴权以及client集成。这个api现在还在alpha阶段（18年8月），希望能到GA阶段。类api-server风格的写法：&lt;a class=&quot;link-a079aa82--primary-53a25e66--link-faf6c434&quot; href=&quot;https://github.com/kubernetes/apiserver&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot; data-key=&quot;1097647783ca4b48a06edc9ef4a0dd38&quot;&gt;&lt;span data-key=&quot;65e8a3aed2d24e83851fcd4bf55ecb6d&quot;&gt;&lt;span data-offset-key=&quot;65e8a3aed2d24e83851fcd4bf55ecb6d:0&quot;&gt;generic apiserver&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;span data-key=&quot;73a40a676a344c8bb554a610c89436ee&quot;&gt;&lt;span data-offset-key=&quot;73a40a676a344c8bb554a610c89436ee:0&quot;&gt;&lt;span data-slate-zero-width=&quot;z&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;blockParagraph-544a408c&quot; data-key=&quot;1b5290ca61dd4a769907f0c7e29d0467&quot;&gt;&lt;span class=&quot;text-4505230f--TextH400-3033861f--textContentFamily-49a318e1&quot;&gt;&lt;span data-key=&quot;947c984bfb0d4360b8a038ad7be10de6&quot;&gt;&lt;span data-offset-key=&quot;947c984bfb0d4360b8a038ad7be10de6:0&quot;&gt;有了Metrics Server组件，也采集到了该有的数据，也暴露了api，但因为api要统一，如何将请求到api-server的&lt;span data-offset-key=&quot;947c984bfb0d4360b8a038ad7be10de6:1&quot;&gt;&lt;code class=&quot;code-81e98f88&quot; data-slate-leaf=&quot;true&quot;&gt;/apis/metrics&lt;/code&gt;&lt;span data-offset-key=&quot;947c984bfb0d4360b8a038ad7be10de6:2&quot;&gt;请求转发给Metrics Server呢，解决方案就是：&lt;a class=&quot;link-a079aa82--primary-53a25e66--link-faf6c434&quot; href=&quot;https://github.com/kubernetes/kube-aggregator&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot; data-key=&quot;6e0d3508f8da49bb80d81cc615c21696&quot;&gt;&lt;span data-key=&quot;e9a48d602ca949308846db2d6c7cea47&quot;&gt;&lt;span data-offset-key=&quot;e9a48d602ca949308846db2d6c7cea47:0&quot;&gt;kube-aggregator&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;span data-key=&quot;bb00bbece78d40d09b22c1a423ef5dea&quot;&gt;&lt;span data-offset-key=&quot;bb00bbece78d40d09b22c1a423ef5dea:0&quot;&gt;,在k8s的1.7中已经完成，之前Metrics Server一直没有面世，就是耽误在了kube-aggregator这一步。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;blockParagraph-544a408c&quot; data-key=&quot;8fdf4067f5cc4b91ab0de54b82ccba9b&quot;&gt;&lt;span class=&quot;text-4505230f--TextH400-3033861f--textContentFamily-49a318e1&quot;&gt;&lt;span data-key=&quot;3db9299942634b31bd2867b13f47f7a1&quot;&gt;&lt;span data-offset-key=&quot;3db9299942634b31bd2867b13f47f7a1:0&quot;&gt;kube-aggregator（聚合api）主要提供：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;list-20526648&quot; data-key=&quot;bb054a2e53414a3386a46f2036334b2b&quot;&gt;&lt;li readability=&quot;-2&quot;&gt;
&lt;div class=&quot;reset-3c756112--listItemContent-756c9114&quot; data-key=&quot;e88ad62b415048d19f45e55ceb48a756&quot; readability=&quot;32&quot;&gt;
&lt;p class=&quot;blockParagraph-544a408c--noMargin-acdf7afa&quot; data-key=&quot;206b89bfacb245dd84aa2f5dc1b39052&quot;&gt;&lt;span class=&quot;text-4505230f--TextH400-3033861f--textContentFamily-49a318e1&quot;&gt;&lt;span data-key=&quot;d7ff55aaacd749b0b0e7da1e7fa36354&quot;&gt;&lt;span data-offset-key=&quot;d7ff55aaacd749b0b0e7da1e7fa36354:0&quot;&gt;Provide an API for registering API servers.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;
&lt;div class=&quot;reset-3c756112--listItemContent-756c9114&quot; data-key=&quot;d5f6bc0280714e4290e310cfac196693&quot; readability=&quot;32&quot;&gt;
&lt;p class=&quot;blockParagraph-544a408c--noMargin-acdf7afa&quot; data-key=&quot;b86057b198d5494ebb65134c08a2caf0&quot;&gt;&lt;span class=&quot;text-4505230f--TextH400-3033861f--textContentFamily-49a318e1&quot;&gt;&lt;span data-key=&quot;baa2f40787ae4031951d67a84c560c37&quot;&gt;&lt;span data-offset-key=&quot;baa2f40787ae4031951d67a84c560c37:0&quot;&gt;Summarize discovery information from all the servers.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;
&lt;div class=&quot;reset-3c756112--listItemContent-756c9114&quot; data-key=&quot;73c34783987d4158aa00977b52a11ef4&quot; readability=&quot;32&quot;&gt;
&lt;p class=&quot;blockParagraph-544a408c--noMargin-acdf7afa&quot; data-key=&quot;15f38ad415784f92971b55fc48e9c552&quot;&gt;&lt;span class=&quot;text-4505230f--TextH400-3033861f--textContentFamily-49a318e1&quot;&gt;&lt;span data-key=&quot;b7035c5fd7454a2eb33fc17bac9eb7ef&quot;&gt;&lt;span data-offset-key=&quot;b7035c5fd7454a2eb33fc17bac9eb7ef:0&quot;&gt;Proxy client requests to individual servers.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;blockParagraph-544a408c&quot; data-key=&quot;6a7a42da69eb4dfb8cf9eb6fda3c1efd&quot;&gt;&lt;span class=&quot;text-4505230f--TextH400-3033861f--textContentFamily-49a318e1&quot;&gt;&lt;span data-key=&quot;41506eb96af14087af40423271d14452&quot;&gt;&lt;span data-offset-key=&quot;41506eb96af14087af40423271d14452:0&quot;&gt;详细设计文档：&lt;a class=&quot;link-a079aa82--primary-53a25e66--link-faf6c434&quot; href=&quot;https://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/aggregated-api-servers.md&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot; data-key=&quot;5f547359ae384f7097c93d78c99bb116&quot;&gt;&lt;span data-key=&quot;10bdb6c7794941749d38ec405fd9ceaa&quot;&gt;&lt;span data-offset-key=&quot;10bdb6c7794941749d38ec405fd9ceaa:0&quot;&gt;参考链接&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;span data-key=&quot;0edf163f1d9e407e87c3ffb6bb7e7ba3&quot;&gt;&lt;span data-offset-key=&quot;0edf163f1d9e407e87c3ffb6bb7e7ba3:0&quot;&gt;&lt;span data-slate-zero-width=&quot;z&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;blockParagraph-544a408c&quot; data-key=&quot;7c3edd73e0b945808bb1beb1709694b3&quot;&gt;&lt;span class=&quot;text-4505230f--TextH400-3033861f--textContentFamily-49a318e1&quot;&gt;&lt;span data-key=&quot;09c53e12577e4058aecd40f4a59abaff&quot;&gt;&lt;span data-offset-key=&quot;09c53e12577e4058aecd40f4a59abaff:0&quot;&gt;metric api的使用：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;list-20526648&quot; data-key=&quot;f3b6e985483146c5968d806246685000&quot;&gt;&lt;li readability=&quot;-2&quot;&gt;
&lt;div class=&quot;reset-3c756112--listItemContent-756c9114&quot; data-key=&quot;6cc38170304742789662af8b20805351&quot; readability=&quot;32&quot;&gt;
&lt;p class=&quot;blockParagraph-544a408c--noMargin-acdf7afa&quot; data-key=&quot;8054d9bc07a94e87ab01bffb1304461b&quot;&gt;&lt;span class=&quot;text-4505230f--TextH400-3033861f--textContentFamily-49a318e1&quot;&gt;&lt;span data-key=&quot;4ff1b72e808b4f1d9d0d0d500cbae246&quot;&gt;&lt;span data-offset-key=&quot;4ff1b72e808b4f1d9d0d0d500cbae246:0&quot;&gt;Metrics API 只可以查询当前的度量数据，并不保存历史数据&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;
&lt;div class=&quot;reset-3c756112--listItemContent-756c9114&quot; data-key=&quot;34fc99976d114b7594f6d36bfd550eca&quot; readability=&quot;32&quot;&gt;
&lt;p class=&quot;blockParagraph-544a408c--noMargin-acdf7afa&quot; data-key=&quot;d850c9986f404cff9edc8f50b6f9ad25&quot;&gt;&lt;span class=&quot;text-4505230f--TextH400-3033861f--textContentFamily-49a318e1&quot;&gt;&lt;span data-key=&quot;bff46c5943f6410fbbf7b8a4f2bc4cba&quot;&gt;&lt;span data-offset-key=&quot;bff46c5943f6410fbbf7b8a4f2bc4cba:0&quot;&gt;Metrics API URI 为 /apis/metrics.k8s.io/，在 k8s.io/metrics 维护&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1.5&quot;&gt;
&lt;div class=&quot;reset-3c756112--listItemContent-756c9114&quot; data-key=&quot;bfad9c9f33af428e90c974fd5cb225fa&quot; readability=&quot;33&quot;&gt;
&lt;p class=&quot;blockParagraph-544a408c--noMargin-acdf7afa&quot; data-key=&quot;0bad3d5258f54ecb872981164cef2e34&quot;&gt;&lt;span class=&quot;text-4505230f--TextH400-3033861f--textContentFamily-49a318e1&quot;&gt;&lt;span data-key=&quot;9ded5f049fdb46da80e46cebe780bdbf&quot;&gt;&lt;span data-offset-key=&quot;9ded5f049fdb46da80e46cebe780bdbf:0&quot;&gt;必须部署 metrics-server 才能使用该 API，metrics-server 通过调用 Kubelet Summary API 获取数据&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;blockParagraph-544a408c&quot; data-key=&quot;6f21e8d2485c4a1eb992b80e5d57e5b0&quot;&gt;&lt;span class=&quot;text-4505230f--TextH400-3033861f--textContentFamily-49a318e1&quot;&gt;&lt;span data-key=&quot;0545e72a376743a2930b2b1d0e0963a2&quot;&gt;&lt;span data-offset-key=&quot;0545e72a376743a2930b2b1d0e0963a2:0&quot;&gt;如：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;codeBlock-18b09018&quot;&gt;
&lt;div data-key=&quot;1d621f1f823142a39753966127b1d572&quot; readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
http://127.0.0.1:8001/apis/metrics.k8s.io/v1beta1/nodes
​
http://127.0.0.1:8001/apis/metrics.k8s.io/v1beta1/nodes/&amp;lt;node-name&amp;gt;
​
http://127.0.0.1:8001/apis/metrics.k8s.io/v1beta1/namespace/&amp;lt;namespace-name&amp;gt;/pods/&amp;lt;pod-name&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3 class=&quot;blockHeadingContent-756c9114&quot;&gt;&lt;span class=&quot;text-4505230f--HeadingH700-04e1a2a3--textContentFamily-49a318e1&quot;&gt;&lt;span data-key=&quot;ae7f6f82713e4c5eb0755828b4d5b1d2&quot;&gt;&lt;span data-offset-key=&quot;ae7f6f82713e4c5eb0755828b4d5b1d2:0&quot;&gt;Metrics-Server&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;blockParagraph-544a408c&quot; data-key=&quot;0ad9644e469e4d2a8e561c5cc2083349&quot;&gt;&lt;span class=&quot;text-4505230f--TextH400-3033861f--textContentFamily-49a318e1&quot;&gt;&lt;span data-key=&quot;24fc1c0bf13e46dbb8289f8580b8fe97&quot;&gt;&lt;span data-offset-key=&quot;24fc1c0bf13e46dbb8289f8580b8fe97:0&quot;&gt;Metrics server定时从Kubelet的Summary API(类似/ap1/v1/nodes/nodename/stats/summary)采集指标信息，这些聚合过的数据将存储在内存中，且以metric-api的形式暴露出去。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;blockParagraph-544a408c&quot; data-key=&quot;4afa2514161f402f879167543ea3afb3&quot;&gt;&lt;span class=&quot;text-4505230f--TextH400-3033861f--textContentFamily-49a318e1&quot;&gt;&lt;span data-key=&quot;92d915b89cc64cf9a38ddf99270cbf17&quot;&gt;&lt;span data-offset-key=&quot;92d915b89cc64cf9a38ddf99270cbf17:0&quot;&gt;Metrics server复用了api-server的库来实现自己的功能，比如鉴权、版本等，为了实现将数据存放在内存中吗，去掉了默认的etcd存储，引入了内存存储（即实现&lt;a class=&quot;link-a079aa82--primary-53a25e66--link-faf6c434&quot; href=&quot;https://github.com/kubernetes/apiserver/blob/master/pkg/registry/rest/rest.go&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot; data-key=&quot;6b18c5bb07d54c0e9eea020791384c4c&quot;&gt;&lt;span data-key=&quot;dda3f411e9d74145ab3f7b77bf3868ff&quot;&gt;&lt;span data-offset-key=&quot;dda3f411e9d74145ab3f7b77bf3868ff:0&quot;&gt;Storage interface&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;span data-key=&quot;ad3f523ed20a44f0ba688c561dd24584&quot;&gt;&lt;span data-offset-key=&quot;ad3f523ed20a44f0ba688c561dd24584:0&quot;&gt;)。因为存放在内存中，因此监控数据是没有持久化的，可以通过第三方存储来拓展，这个和heapster是一致的。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div data-slate-void=&quot;true&quot; data-key=&quot;59507f68f767439abcb1b40a45483011&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;reset-3c756112--figureAlignCenter-2d9bf702&quot;&gt;
&lt;div class=&quot;reset-3c756112--figureLayer-b6ab7c94&quot;&gt;&lt;img class=&quot;imgTag-b489daf6&quot; src=&quot;http://www.xuyasong.com/wp-content/uploads/2019/01/03659112b8502f2a2ab7b7df8b735782.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;blockParagraph-544a408c&quot; data-key=&quot;aa009be33a30498bbcbe6b4a12bb12a0&quot;&gt;&lt;span class=&quot;text-4505230f--TextH400-3033861f--textContentFamily-49a318e1&quot;&gt;&lt;span data-key=&quot;1c227f05d9c94fe19257c64791fdb0c3&quot;&gt;&lt;span data-offset-key=&quot;1c227f05d9c94fe19257c64791fdb0c3:0&quot;&gt;Metrics server出现后，新的​Kubernetes 监控架构将变成上图的样子&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;list-20526648&quot; data-key=&quot;0c1c4484e32e4cba908641aa73aa13fd&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;div class=&quot;reset-3c756112--listItemContent-756c9114&quot; data-key=&quot;30a5ac5a70374a5b85abc24b62cd463d&quot; readability=&quot;34&quot;&gt;
&lt;p class=&quot;blockParagraph-544a408c--noMargin-acdf7afa&quot; data-key=&quot;b686e48e2d2948cdb6b745e3e2af8648&quot;&gt;&lt;span class=&quot;text-4505230f--TextH400-3033861f--textContentFamily-49a318e1&quot;&gt;&lt;span data-key=&quot;de58f8cd535a49d2aa9289b61da8a90c&quot;&gt;&lt;span data-offset-key=&quot;de58f8cd535a49d2aa9289b61da8a90c:0&quot;&gt;核心流程（黑色部分）：这是 Kubernetes正常工作所需要的核心度量，从 Kubelet、cAdvisor 等获取度量数据，再由metrics-server提供给 Dashboard、HPA 控制器等使用。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;div class=&quot;reset-3c756112--listItemContent-756c9114&quot; data-key=&quot;4096249c2f6a40058771a886e617c000&quot; readability=&quot;34&quot;&gt;
&lt;p class=&quot;blockParagraph-544a408c--noMargin-acdf7afa&quot; data-key=&quot;41ded858cacb4b4280abc9595b7908f9&quot;&gt;&lt;span class=&quot;text-4505230f--TextH400-3033861f--textContentFamily-49a318e1&quot;&gt;&lt;span data-key=&quot;a80cec9baa694310b874d9b5280dab40&quot;&gt;&lt;span data-offset-key=&quot;a80cec9baa694310b874d9b5280dab40:0&quot;&gt;监控流程（蓝色部分）：基于核心度量构建的监控流程，比如 Prometheus 可以从 metrics-server 获取核心度量，从其他数据源（如 Node Exporter 等）获取非核心度量，再基于它们构建监控告警系统。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;blockParagraph-544a408c&quot; data-key=&quot;b2c75090ac5c49e6be648de7b19ad4ca&quot;&gt;&lt;span class=&quot;text-4505230f--TextH400-3033861f--textContentFamily-49a318e1&quot;&gt;&lt;span data-key=&quot;77de4fc437a742f6a9a4ce895b027ef9&quot;&gt;&lt;span data-offset-key=&quot;77de4fc437a742f6a9a4ce895b027ef9:0&quot;&gt;官方地址：&lt;a class=&quot;link-a079aa82--primary-53a25e66--link-faf6c434&quot; href=&quot;https://github.com/kubernetes-incubator/metrics-server&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot; data-key=&quot;c3815fee0dee4ae8a67e748e73f90acd&quot;&gt;&lt;span data-key=&quot;bbc3d61934cb4beab4552a8d15a2ea35&quot;&gt;&lt;span data-offset-key=&quot;bbc3d61934cb4beab4552a8d15a2ea35:0&quot;&gt;https://github.com/kubernetes-incubator/metrics-server&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;blockParagraph-544a408c&quot; data-key=&quot;b2c75090ac5c49e6be648de7b19ad4ca&quot;&gt;&lt;span class=&quot;text-4505230f--TextH400-3033861f--textContentFamily-49a318e1&quot;&gt;&lt;span data-key=&quot;77de4fc437a742f6a9a4ce895b027ef9&quot;&gt;&lt;span data-offset-key=&quot;77de4fc437a742f6a9a4ce895b027ef9:0&quot;&gt;&lt;span data-key=&quot;bbc3d61934cb4beab4552a8d15a2ea35&quot;&gt;&lt;span data-offset-key=&quot;bbc3d61934cb4beab4552a8d15a2ea35:0&quot;&gt;部署&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
mkdir metrics;cd metics
git clone https://github.com/kubernetes-incubator/metrics-server.git
cd metrics-server/deploy/1.8+/
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 修改metrics-server-deployment.yaml，红色部分。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: metrics-server
  namespace: kube-system
---
apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: metrics-server
  namespace: kube-system
  labels:
    k8s-app: metrics-server
spec:
  selector:
    matchLabels:
      k8s-app: metrics-server
  template:
    metadata:
      name: metrics-server
      labels:
        k8s-app: metrics-server
    spec:
      serviceAccountName: metrics-server
      volumes:
      # mount in tmp so we can safely use from-scratch images and/or read-only containers
      - name: tmp-dir
        emptyDir: {}
      containers:
      - name: metrics-server
        image: k8s.gcr.io/metrics-server-amd64:v0.3.3
&lt;span&gt;        command:
        - /metrics-server
        - --metric-resolution=30s
        - --kubelet-preferred-address-types=InternalIP,Hostname,InternalDNS,ExternalDNS,ExternalIP
        - --kubelet-insecure-tls&lt;/span&gt;
        imagePullPolicy: Always
        volumeMounts:
        - name: tmp-dir
          mountPath: /tmp
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 创建&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@cn-hongkong 1.8+]# kubectl apply -f .
clusterrole.rbac.authorization.k8s.io/system:aggregated-metrics-reader unchanged
clusterrolebinding.rbac.authorization.k8s.io/metrics-server:system:auth-delegator unchanged
rolebinding.rbac.authorization.k8s.io/metrics-server-auth-reader unchanged
apiservice.apiregistration.k8s.io/v1beta1.metrics.k8s.io unchanged
serviceaccount/metrics-server unchanged
deployment.extensions/metrics-server configured
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 等待一会就可以看下集群的资源使用情况了！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1271786/201906/1271786-20190626000959663-1627279715.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 25 Jun 2019 16:10:00 +0000</pubDate>
<dc:creator>渣渣辉</dc:creator>
<og:description>Metrics API 介绍Metrics-Server之前，必须要提一下Metrics API的概念 Metrics API相比于之前的监控采集方式(hepaster)是一种新的思路，官方希望核心指</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Dev0ps/p/11087497.html</dc:identifier>
</item>
<item>
<title>Git的使用 -- 用git玩翻github,结尾有惊喜！有惊喜！有惊喜！林妙妙看了说:牛呲呼啦带闪电 （三）（超详解） - 北京-宏哥</title>
<link>http://www.cnblogs.com/du-hong/p/11087181.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/du-hong/p/11087181.html</guid>
<description>&lt;p&gt;      上一篇主要讲解的是Git安装及配置，这一篇就详细的从无到有的来用Git玩翻github。&lt;/p&gt;

&lt;p&gt;Github是全球最大的社交编程及代码托管网站（https://github.com/）。&lt;/p&gt;
&lt;p&gt;Github可以托管各种git库，并提供一个web界面（用户名.github.io/仓库名）&lt;/p&gt;

&lt;p&gt;Git是版本控制软件&lt;/p&gt;
&lt;p&gt;Github是项目代码托管的平台，借助git来管理项目代码&lt;/p&gt;
&lt;h2&gt;1、 使用Github&lt;/h2&gt;
&lt;h3&gt;目的：借助github托管项目代码&lt;/h3&gt;
&lt;h2&gt;2、基本概念&lt;/h2&gt;
&lt;h3&gt;a、仓库（Repository）&lt;/h3&gt;
&lt;p&gt; 仓库的意思，即你的项目，你想在 GitHub 上开源一个项目，那就必须要新建一个 Repository ，如果你开源的项目多了，你就拥有了多个 Repositories 。&lt;/p&gt;
&lt;p&gt; 仓库用来存放项目代码，每个项目对应一个仓库，多个开源项目则有多个仓库。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;b、收藏（Star）&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;仓库主页star按钮，意思为收藏项目的人数，收藏项目，方便下次查看，在 GitHub 上如果你有一个项目获得100个star都算很不容易了！&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;【如何收藏】&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt; 操作：打开对应项目主页，点击右上角  star 按钮即可收藏&lt;/p&gt;
&lt;p&gt; 情景：张三无意访问到李四的开源项目感觉不错并进行收藏&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201906/1232840-20190625230434935-1851542422.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;【如何查看自己得收藏】&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201906/1232840-20190625230727662-386923807.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;c、复制项目（Fork）派生&lt;/h3&gt;
&lt;p&gt;这个不好翻译，如果实在要翻译我把他翻译成分叉，什么意思呢？你开源了一个项目，别人想在你这个项目的基础上做些改进，然后应用到自己的项目中，这个时候他就可以 Fork 你的项目（打开项目主页点击右上角的fork按钮即可），然后他的 GitHub 主页上就多了一个项目，只不过这个项目是基于你的项目基础（本质上是在原有项目的基础上新建了一个分支），他就可以随心所欲的去改进，但是丝毫不会影响原有项目的代码与结构。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/810514/201707/810514-20170708230258175-1667897819.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;注意：该fork的项目时独立存在的&lt;/p&gt;
&lt;p&gt;比如：张三fork了李四的项目，相当于张三复制了李四的项目，所以自己也单独有了一个一样名称的仓库（注：该仓库会声明来自于李四，但是独立存在）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201906/1232840-20190625232040331-242828300.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;d、发起请求（Pull Request）&lt;/h3&gt;
&lt;p&gt;发起请求，这个其实是基于 Fork 的，还是上面那个例子，如果别人在你基础上做了改进，后来觉得改进的很不错，应该要把这些改进让更多的人收益，于是就想把自己的改进合并到原有项目里，这个时候他就可以发起一个 Pull Request（简称PR） ，原有项目创建人，也就是你，就可以收到这个请求，这个时候你会仔细review他的代码，并且测试觉得OK了，就会接受他的PR，这个时候他做的改进原有项目就会拥有了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/810514/201707/810514-20170708230438800-459632433.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;e、关注（Watch）&lt;/h3&gt;
&lt;p&gt;这个也好理解就是观察，如果你 Watch 了某个项目，那么以后只要这个项目有任何更新，你都会第一时间收到关于这个项目的通知提醒。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201906/1232840-20190625232230533-1820528028.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;f、问题（Issue）&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;发现代码BUG，但是目前没有成型代码，需要讨论时用； 问题的意思，举个例子，就是你开源了一个项目，别人发现你的项目中有bug，或者哪些地方做的不够好，他就可以给你提个 Issue ，即问题，提的问题多了，也就是 Issues ，然后你看到了这些问题就可以去逐个修复，修复ok了就可以一个个的 Close 掉。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;g、Github主页&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;账号创建成功或点击网址导航栏github图标都可进入github主页：该页左侧主要显示用户动态以及关注用户或关注仓库的动态；右侧显示所有的git库&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;h、仓库主页&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;仓库主页主要显示项目的信息，如：项目代码，版本，收藏/关注/fork情况等&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;i、个人主页&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;个人信息：头像，个人简介，关注我的人，我关注的人，我关注的git库，我的开源项目，我贡献的开源项目等信息&lt;/p&gt;
&lt;h2&gt;3、&lt;strong&gt;注册github账号&lt;/strong&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;strong&gt;官方网址：https://&lt;/strong&gt;github.com&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/810514/201707/810514-20170708231942956-944296015.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/810514/201707/810514-20170708232357940-155450031.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/810514/201707/810514-20170708233152925-269633233.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/810514/201707/810514-20170708233241847-1099922957.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/810514/201707/810514-20170708233443190-1925301343.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;p&gt;a、因为github在国外服务器所以访问较慢或者无法访问，需要FQ（***）&lt;/p&gt;
&lt;p&gt;b、私有仓库只能自己或者指定的朋友才有权限操作（私有仓库是收费的）&lt;/p&gt;
&lt;p&gt;c、新注册的用户必须验证邮箱后才可以创建git库仓库&lt;/p&gt;
&lt;h2&gt;4、创建仓库/创建新项目&lt;/h2&gt;
&lt;h3&gt;&lt;strong&gt;说明：&lt;/strong&gt;一个git库（仓库）对应一个开源项目。通过git管理git库&lt;/h3&gt;
&lt;h3&gt;a、创建仓库&lt;/h3&gt;
&lt;p&gt;1)点击【Start a project】创建一个仓库&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/810514/201707/810514-20170708234146394-24230739.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2)问题：点击【Start a project】创建一个仓库，后出现该页面&lt;/p&gt;
&lt;p&gt;2)原因：未验证邮箱，点击下图框框中的链接进行验证&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2015.cnblogs.com/blog/810514/201707/810514-20170708234402269-1081107384.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3)点击【resend】发送邮件验证邮箱&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2015.cnblogs.com/blog/810514/201707/810514-20170708234621800-1070199204.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 4)点击【verify email address】验证邮箱&lt;/p&gt;
&lt;p class=&quot;NewStyle17&quot;&gt;   说明：验证成功后会自动跳转github主页，重新点击【Start a project】即可创建仓库&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2015.cnblogs.com/blog/810514/201707/810514-20170708234755300-1543178880.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5) 验证邮箱后，点击【Start a project】进入下图界面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/810514/201707/810514-20170709123407572-1422667023.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;b、仓库主页说明&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201906/1232840-20190625234111497-60230348.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 注意：qq邮箱需要设置白名单才可以收到邮件&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;设置QQ邮箱白名单&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;1、打开QQ邮箱、点击【设置】&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;2、点击【反垃圾】&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;3、点击【设置域名白名单】&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;4、在新页面的input框中输入【github.com】添加即可&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/810514/201707/810514-20170709000023659-620733431.png&quot; alt=&quot;&quot; width=&quot;586&quot; height=&quot;319&quot;/&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/810514/201707/810514-20170709000055065-1150943625.png&quot; alt=&quot;&quot; width=&quot;507&quot; height=&quot;322&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;5、仓库管理&lt;/h2&gt;
&lt;h3&gt;a、新建文件：仓库主页，点击【create new file】创建仓库文件&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201906/1232840-20190625234232537-1266551532.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201906/1232840-20190625235057239-997284576.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;   &lt;img src=&quot;https://images2015.cnblogs.com/blog/810514/201707/810514-20170709001005565-1557847834.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;b、编辑文件：&lt;/strong&gt;仓库主页，点击【需要修改的文件】进入文件详情页&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://images2015.cnblogs.com/blog/810514/201707/810514-20170709001248206-1319004311.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/810514/201707/810514-20170709001329362-387423324.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    &lt;img src=&quot;https://images2015.cnblogs.com/blog/810514/201707/810514-20170709001401409-482027208.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;c、删除文件&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://images2015.cnblogs.com/blog/810514/201707/810514-20170709001459565-512687449.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/810514/201707/810514-20170709001600800-1740677648.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;d、被删除文件如何查看信息&lt;/h3&gt;
&lt;p&gt;答案：点击commits按钮查看&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/810514/201707/810514-20170709001651987-1855978595.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;e、上传文件&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://images2015.cnblogs.com/blog/810514/201707/810514-20170709001831284-1266086581.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;f、搜索仓库文件：&lt;/strong&gt;快捷键（t）&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/810514/201707/810514-20170709002123815-1658782510.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/810514/201707/810514-20170709002308987-1429002132.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;6、下载/检出项目&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/810514/201707/810514-20170709002547253-1984849913.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;7、Github Issues&lt;/h2&gt;
&lt;p&gt;作用：发现代码BUG，但是目前没有成型代码，需要讨论时用；或者使用开源项目出现问题时使用&lt;/p&gt;
&lt;p&gt;情景：张三发现李四开源git库，则发提交了一个issue；李四隔天登录在github主页看到通知并和张三交流，最后关闭issue&lt;/p&gt;
&lt;h2&gt;三、基本概念（实战操作）&lt;/h2&gt;
&lt;h3&gt;&lt;strong&gt;1、Github主页&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://images2015.cnblogs.com/blog/810514/201707/810514-20170709120229103-726725059.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2、个人主页&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://images2015.cnblogs.com/blog/810514/201707/810514-20170709120530868-636741445.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;1、&lt;strong&gt;新建Issue&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;提交使用问题或者建议或者想法&lt;/p&gt;
&lt;h3&gt;2、&lt;strong&gt;Pull Request&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;步骤：&lt;/p&gt;
&lt;p&gt;a、 fork项目&lt;/p&gt;
&lt;p&gt;b、 修改自己仓库的项目代码&lt;/p&gt;
&lt;p&gt;c、 新建 pull request&lt;/p&gt;
&lt;p&gt;d、 等待作者操作审核&lt;/p&gt;

&lt;h3&gt;1、个人站点&lt;/h3&gt;
&lt;h3&gt;访问：https://用户名.github.io&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;搭建步骤：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;a、创建个人站点-》新建仓库（仓库名必须是【用户名.github.io】）&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2015.cnblogs.com/blog/810514/201707/810514-20170708204746253-113853036.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;b、在仓库下新建index.html的文件即可&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/810514/201707/810514-20170708210906909-857187362.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意：a、Github Page仅支持静态页面&lt;/p&gt;
&lt;p&gt;　　　b、仓库里面只能是.html文件&lt;/p&gt;
&lt;p&gt;　　　c、个人主页也可以设置主题&lt;/p&gt;
&lt;h3&gt;2、Project Pages 项目站点&lt;/h3&gt;
&lt;h3&gt;访问：https://用户名.github.io/仓库名&lt;/h3&gt;
&lt;h3&gt;&lt;strong&gt;原理：&lt;/strong&gt;gh-pages 用于构建和发布&lt;/h3&gt;
&lt;h3&gt;&lt;strong&gt;搭建步骤&lt;/strong&gt;&lt;/h3&gt;
&lt;h3&gt;a、进入项目主页，点击settings&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/810514/201707/810514-20170708211055440-517958463.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;b、在settings页面，点击【Choose a theme 】来自动生成主题页面&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/810514/201707/810514-20170708211209253-924052065.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;c、新建站点基础信息设置&lt;/h3&gt;
&lt;h3&gt;d、选择主题&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/810514/201707/810514-20170708211407175-1507084462.png&quot; alt=&quot;&quot; width=&quot;832&quot; height=&quot;451&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;e、发布网页（publish page）&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/810514/201707/810514-20170708211637222-80110718.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Clone和Fork的区别：&lt;/p&gt;&lt;p&gt;fork(派生)：将别人的仓库复制一份到自己的仓库。&lt;br/&gt;clone(克隆)：将仓库克隆到自己本地电脑中。&lt;/p&gt;&lt;p&gt;Fork的主要应用场景：&lt;br/&gt;1.在A的仓库中fork项目B （此时我们自己的github就有一个一模一样的仓库B，但是URL不同）&lt;br/&gt;2.将我们修改的代码push到自己github中的仓库B中&lt;br/&gt;3.pull request ，主人就会收到请求，并决定要不要接受你的代码&lt;/p&gt;
</description>
<pubDate>Tue, 25 Jun 2019 15:58:00 +0000</pubDate>
<dc:creator>北京-宏哥</dc:creator>
<og:description>简介 上一篇主要讲解的是Git安装及配置，这一篇就详细的从无到有的来用Git玩翻github。 一、什么是Github Github是全球最大的社交编程及代码托管网站（https://github.c</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/du-hong/p/11087181.html</dc:identifier>
</item>
<item>
<title>多线程与高并发(一)多线程入门 - 茶底世界</title>
<link>http://www.cnblogs.com/yuanqinnan/p/11087354.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuanqinnan/p/11087354.html</guid>
<description>&lt;h2&gt;一、基础概念&lt;/h2&gt;
&lt;p&gt;多线程的学习从一些概念开始，进程和线程，并发与并行，同步与异步，高并发。&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;1.1 进程与线程&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;几乎所有的操作系统都支持同时运行期多个任务，所有运行中的任务通常就是一个进程，进程是处于运行过程中的程序，进程是操作系统进行资源分配和调度的一个独立单位。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201906/1113901-20190625232244625-1328119315.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;进程有三个如下特征：&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;2.5&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;独立性：进程是系统中独立存在的实体，它可以拥有自己独立的资源，每一个进程都拥有自己私有的地址空间。在没有经过进程本身允许的情况下，一个用户进程不可以直接访问其他进程的地址空间。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;动态性：进程与程序的区别在于，程序只是一个静态的指令集合，而进程是一个正在系统中活动的指令集合。在进程中加入了时间的概念，进程具有自己的生命周期和各种不同的状态，这些概念在程序中部是不具备的。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;并发性：多个进程可以在单个处理器上并发执行，多个进程之间不会互相影响。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;线程是进程的组成部分，一个进程可以拥有多个线程，而线程必须有一个父进程，线程可以有自己的堆栈、自己的程序计数器和自己的局部变量，但不拥有系统资源。比如使用QQ时，我们可以同事传文件，发送图片，聊天，这就是多个线程在进行。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;线程可以完成一定的任务，线程能够独立运行的，它不知道有其他线程的存在，线程的执行是抢占式的，当前线程随时可能被挂起。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;总之：一个程序运行后至少有一个进程，一个进程里可以有多个线程，但至少要有一个线程。&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;1.2 并发和并行&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;并发和并行是比较容易混淆的概念，他们都表示两个或者多个任务一起执行，但并发侧重多个任务交替执行，同一时刻只能有一条指令执行，但多个进程指令被快速轮换执行，使得在宏观上具有多个进程同时执行的效果。而并行确实真正的同时执行，有多条指令在多个处理器上同时执行，并行的前提条件就是多核CPU。&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;1.3 同步和异步&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;同步和异步通常用来形容一次方法调用。同步方法调用一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为。异步方法调用更像一个消息传递，一旦开始，方法调用就会立即返回，调用者可以继续后续的操作。&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;1.4 高并发&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;高并发一般是指在短时间内遇到大量操作请求，非常具有代表性的场景是秒杀活动与抢票，高并发是互联网分布式系统架构设计中必须考虑的因素之一，高并发相关常用的一些指标有响应时间（Response Time），吞吐量（Throughput），每秒查询率QPS（Query Per Second），并发用户数等。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;多线程在这里只是在同/异步角度上解决高并发问题的其中的一个方法手段，是在同一时刻利用计算机闲置资源的一种方式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;1.5 多线程的好处&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;线程在程序中是独立的、并发的执行流，拥有独立的内存单元，多个线程共享父进程里的全部资源，线程共享的环境有进程的代码段，进程的公有数据等，利用这些共享数据,线程很容易实现相互之间的通信，可以提高程序的运行效率。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;多线程的好处主要有：&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;0.5&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;进程之间不能共享内存，但线程之间共享内存非常容易。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;系统创建进程时需要给进程重新分配系统资源，但创建线程代价小得多，所以使用多线程实现多任务并发比多进程效率高&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Java语言内置了多线程功能支持。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;二、使用多线程&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;上面讲了多线程的一些概念，都有些抽象，下面将学习如何使用多线程,创建多线程的方式有三种。&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;2.1 继承Thread类创建&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;继承Thread创建并启动多线程有三个步骤：&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;ol-list&quot; start=&quot;&quot; readability=&quot;1&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;定义类并继承Thread,重写run()方法,run()方法中为需要多线程执行的任务。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;创建该类的实例，即创建了线程对象。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;调用实例的start()方法启动线程。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; FirstThread &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; i=0&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (; i &amp;lt; 100; i++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取当前线程名称&lt;/span&gt;
            System.out.println(&lt;span&gt;this&lt;/span&gt;.getName() + &quot; &quot; +&lt;span&gt; i);
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 100; i++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Thread的静态方法currentThread，获取当前线程&lt;/span&gt;
&lt;span&gt;            System.out.println(Thread.currentThread().getName());
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i == 20&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建线程并启动&lt;/span&gt;
                &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FirstThread().start();
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; FirstThread().start();
            }

        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;运行结果可以看到两个线程的i并不是连续的，说明他们并不共享数据。&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;2.2 实现Runnable接口&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;实现Runnable接口创建并启动多线程也有以下步骤：&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;ol-list&quot; start=&quot;&quot; readability=&quot;1&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;2&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;定义类并继承Runnable接口,重写run()方法,run()方法中为需要多线程执行的任务。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;创建该类的实例，并以此实例作为target为参数来创建Thread对象，这个Thread对象才是真正的多线程对象。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; SecondThread &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; i = 0&lt;span&gt;;
    
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (; i &amp;lt; 100; i++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;此时想要获取到多线程对象，只能使用Thread.currentThread()方法&lt;/span&gt;
            System.out.println(Thread.currentThread().getName() + &quot; &quot; +&lt;span&gt; i);
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 100; i++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Thread的静态方法currentThread，获取当前线程&lt;/span&gt;
&lt;span&gt;            System.out.println(Thread.currentThread().getName());
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i == 20&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建线程并启动&lt;/span&gt;
                SecondThread secondThread=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SecondThread();
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Thread(secondThread,&quot;线程一&quot;&lt;span&gt;).start();
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Thread(secondThread,&quot;线程二&quot;&lt;span&gt;).start();
            }

        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;2.3 使用Callable和Future&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Callable是Runnable的增加版，主要是接口中的call()方法可以有返回值，并且可以申明抛出异常，使用Callable创建的步骤如下：&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;ol-list&quot; start=&quot;&quot; readability=&quot;2.5&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;2&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;定义类并继承Callable接口,重写call()方法,run()方法中为需要多线程执行的任务。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;创建类实例，使用FutureTask来包装对象实例，&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;使用FutureTask对象作为Thread的target来创建多线程，并启动线程。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;调用FutureTask对象的get()方法来获取子线程结束后的返回值。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ThirdThread {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用lambda表达式&lt;/span&gt;
        FutureTask&amp;lt;Integer&amp;gt; task = &lt;span&gt;new&lt;/span&gt; FutureTask&amp;lt;&amp;gt;((Callable&amp;lt;Integer&amp;gt;) () -&amp;gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i = 0&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (; i &amp;lt; 100; i++&lt;span&gt;) {
                System.out.println(Thread.currentThread().getName() &lt;/span&gt;+ &quot;的循环变量i的值：&quot; +&lt;span&gt; i);
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; i;
        });
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 100; i++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Thread的静态方法currentThread，获取当前线程&lt;/span&gt;
&lt;span&gt;            System.out.println(Thread.currentThread().getName());
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i == 20&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建线程并启动&lt;/span&gt;
                &lt;span&gt;new&lt;/span&gt; Thread(task, &quot;有返回值的线程&quot;&lt;span&gt;).start();
            }
        }
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            System.out.println(&lt;/span&gt;&quot;线程的返回值：&quot; +&lt;span&gt; task.get());
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ExecutionException e) {
            e.printStackTrace();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;这里使用了lambda表达式，不使用表达式的方式也很简单，可以去源码中查看。Callable与Runnable方式基本相同，只不过增加了返回值且可允许声明抛出异常。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;使用三种方式都可以创建线程，且方式也相对简单，大体分为实现接口和实现Thread类两种，这两种都各有优缺点。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;继承接口实现:&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li class=&quot;md-end-block&quot;&gt;&lt;span&gt;优点：&lt;/span&gt;除了继承接口之外，还可以继承其他类。这种方式多个线程共享一个target对象，可以处理用于共同资源的情况。&lt;/li&gt;
&lt;li class=&quot;md-end-block&quot;&gt;&lt;span&gt;缺点：&lt;/span&gt;编程稍微复杂一些，并且没有直接获取当前线程对象的方式，必须使用Thread.currentThread()方式。&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;md-end-block&quot;&gt;&lt;strong&gt;基础Thread类:&lt;/strong&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;三、多线程的生命周期&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;线程状态是线程中非常重要的一个概念，然而我看过很多资料，线程的状态理解有很多种方式，很多人将其分为五个基本状态：新建、就绪、运行、阻塞、死亡，但在状态枚举中并不是这五个状态，我不知道是什么原因（有大神可以解答更好），只能按照枚举中的状态根据自己的理解。&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;ol-list&quot; start=&quot;&quot; readability=&quot;4.5&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;初始(NEW)：新创建了一个线程对象，但还没有调用start()方法，而且就算调用了改方法也不代表状态立即改变。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;运行(RUNNABLE)：在运行的状态肯定就处于RUNNABLE状态。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;阻塞(BLOCKED)：表示线程阻塞，或者说线程已经被挂起了。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;等待(WAITING)：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;超时等待(TIMED_WAITING)：该状态不同于WAITING，它可以在指定的时间后自行返回。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;终止(TERMINATED)：表示该线程已经执行完毕。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;状态流程图如下：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201906/1113901-20190625232635949-798047380.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;理解：&lt;span&gt;&lt;strong&gt;初始状态&lt;/strong&gt;&lt;span&gt;很好理解，这个时候其实还不能被称为一个线程，因为他还没被启动，当调用start()方法后，线程正式启动，但是也不代表立即就改变了状态。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;运行状态&lt;/strong&gt;&lt;span&gt;中其实包含两种状态，&lt;span&gt;&lt;strong&gt;运行中（RUNING）&lt;/strong&gt;&lt;span&gt;和&lt;span&gt;&lt;strong&gt;就绪（READY）&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;就绪状态&lt;/strong&gt;&lt;span&gt;表示你有资格运行，只要CPU还未调度到你，就处于就绪状态，有几个状态会是线程状态编程就绪状态&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;1.5&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;调用线程的start()方法。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;当前线程sleep()方法结束，其他线程join()结束，等待用户输入完毕，某个线程拿到对象锁。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;当前线程时间片用完了，调用当前线程的yield()方法。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;锁池里的线程拿到对象锁后。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;运行中（RUNING）状态&lt;/strong&gt;&lt;span&gt;比较好理解，线程调度程序选择了当前线程作。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;阻塞状态&lt;/strong&gt;&lt;span&gt;是线程阻塞在进入synchronized关键字修饰的方法或代码块(获取锁)时的状态。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;等待状态&lt;/strong&gt;&lt;span&gt;是指线程没有被CPU分配执行时间，需要等待，这种等待是需要被显示的唤醒，否则会无限等待下去。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;超时等待状态&lt;/strong&gt;&lt;span&gt;是这现在没有被CPU分配执行时间，需要等待，不过这种等待不需要被显示的唤醒，会设置一定的时间后zi懂唤醒。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;死亡状态&lt;/strong&gt;&lt;span&gt;也很好理解，说明线程方法被执行完成，或者出错了，线程一旦进入这个状态就代表彻底的结束&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 25 Jun 2019 15:31:00 +0000</pubDate>
<dc:creator>茶底世界</dc:creator>
<og:description>一、基础概念 多线程的学习从一些概念开始，进程和线程，并发与并行，同步与异步，高并发。 1.1 进程与线程 几乎所有的操作系统都支持同时运行期多个任务，所有运行中的任务通常就是一个进程，进程是处于运行</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yuanqinnan/p/11087354.html</dc:identifier>
</item>
</channel>
</rss>