<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>【重复图识别】在茫茫图海中，怎么找到相同的它？ - ERKE</title>
<link>http://www.cnblogs.com/ERKE/p/14111989.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ERKE/p/14111989.html</guid>
<description>&lt;p&gt;在一些图像相关的项目中，重复图识别是很重要的。就比如**热图排行榜**（需要识别出重复图）；涉及**图像深度学习**的项目（训练数据需要剔除重复图）；**图片原创&amp;amp;视频原创**（需要识别出重复图）等等。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;138.74665856622&quot;&gt;

&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;在一些图像相关的项目中，重复图识别是很重要的。就比如&lt;strong&gt;热图排行榜&lt;/strong&gt;（需要识别出重复图）；涉及&lt;strong&gt;图像深度学习&lt;/strong&gt;的项目（训练数据需要剔除重复图）；&lt;strong&gt;图片原创&amp;amp;视频原创&lt;/strong&gt;（需要识别出重复图）等等。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;什么是相同图片？相信在不同场景下，这个答案是不一样。有些场景把肉眼看起来一样的图片当作相同图片，有些场景把用滤镜处理过的图片也当作相同图片，而有些场景下只把原图当作相同图片。&lt;br/&gt;这里按照相同程度划分，相同程度从高到低，其实可以分为3个等级：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;绝对原图&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;肉眼相同&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;抄袭原图&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;接下来我们逐一详细介绍下这3类。&lt;/p&gt;

&lt;p&gt;这个等级，图片相同的程度是最高的，就如下面2张图片，1.png通过直接copy的方式产生的2.png&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/551233/202012/551233-20201209191413910-63336286.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;它们从图片内容已经无法判断是否是原图，只能从文件的角度识别，一般来说都是直接md5判断2个图片，如下所示：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/551233/202012/551233-20201209191406194-1962607194.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;它属于用图片文件进行hash处理。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;PS：一般来说，所有场景都会先用md5来过滤一边，因为它算法复杂度很低，根本不用理解图片&lt;/p&gt;

&lt;p&gt;这个等级的场景最多，比如图片训练数据去重，热图排行榜等等。&lt;br/&gt;就如下图所示，1.png经过压缩、resize、转码等图片处理的方式产生的3.jpg：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/551233/202012/551233-20201209191342649-1498560461.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;它们肉眼看起来是相同，但是绝对不是原图，md5无法识别这种情况，只能图像的&lt;strong&gt;感知hash&lt;/strong&gt;处理。感知hash主要有3种（AHash、DHash、PHash），它们都是&lt;strong&gt;用图片内容进行hash处理，只是hash方式不同&lt;/strong&gt;，下面逐一介绍一波：&lt;/p&gt;
&lt;h3 id=&quot;ahash&quot;&gt;AHash&lt;/h3&gt;
&lt;p&gt;这种感知hash最简单，算法复杂度也最低，它只需要处理2步 &lt;strong&gt;预处理 + 二值化&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;具体流程图如下所示：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/551233/202012/551233-20201209191329944-1792191571.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;它的二值化方式比较简单，只是比较了像素点跟均值，所以效果一般般。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;python源码如下：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt; def ahash(image, hash_size=8):
     image = image.convert(&quot;L&quot;).resize((hash_size, hash_size), Image.ANTIALIAS)// 1、【预处理】转灰度图，resize
     pixels = numpy.asarray(image)
     avg = np.mean(pixels)//2、计算均值，这里也可以用中值
     diff = pixels &amp;gt; avg // 3、【二值化】大于均值为1，小于等于均值为0
     return diff
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;dhash&quot;&gt;DHash&lt;/h3&gt;
&lt;p&gt;这种感知hash的复杂度也很低，重点是它比AHash的效果好，主要原因它二值化方式考虑上了相邻像素的差值，算法更加鲁棒。（当然这只是一种思想，我们也可以比较固定的2个像素点的大小，每个像素点都有一个与之对应的像素点）。&lt;br/&gt;算法流程图如下（跟AHash差不多，差别在于二值化方式不一样）：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/551233/202012/551233-20201209191314367-186576811.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;python源码如下：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt; def dhash(image, hash_size=8):
     image = image.convert(&quot;L&quot;).resize((hash_size + 1, hash_size), Image.ANTIALIAS)// 1、【预处理】转灰度图，resize
     pixels = numpy.asarray(image)
     diff = pixels[:, 1:] &amp;gt; pixels[:, :-1] //2、【二值化】相邻2个元素对比，右边大于左边为1，右边小于等于左边为0。（也可以改成上下2个元素的对比，或者固定2个元素之间的对比）
     return diff
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;phash&quot;&gt;Phash&lt;/h3&gt;
&lt;p&gt;Phash是目前效果最好，它引入了DCT变换，去除图片中的高频信息，把注意力集中在低频信息中，这是由于人眼对于细节信息不是很敏感。具体算法原理见&lt;a href=&quot;https://www.cnblogs.com/ERKE/p/14110372.html&quot; target=&quot;_blank&quot;&gt;下一篇&lt;/a&gt;。&lt;br/&gt;phash有很多种改版，下面只给出效果最好的一种，它的算法流程图如下：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/551233/202012/551233-20201209191302089-576515741.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;python 源码如下：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt; def phash(image, hash_size=8, highfreq_factor=4):
     import scipy.fftpack
     img_size = hash_size * highfreq_factor
     image = image.convert(&quot;L&quot;).resize((img_size, img_size), Image.ANTIALIAS)// 1、【预处理】转灰度图，resize
     pixels = numpy.asarray(image)
     dct = scipy.fftpack.dct(scipy.fftpack.dct(pixels, axis=0), axis=1) //DCT变换
     dctlowfreq = dct[:hash_size, :hash_size] //2、只留下直流&amp;amp;&amp;amp;低频变量
     med = numpy.median(dctlowfreq) //取中值
     diff = dctlowfreq &amp;gt; med //3、【二值化】大于中值为1，小于等于中值为0
     return diff
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;这种场景也挺多的，而且其中每个场景都有自己独特的要求。就比如一个视频平台，它的视频原创项目，把加滤镜、换音频、裁剪等方式也判定为相同图片的话，感知hash已经不适用，必须用上图像深度学习了。&lt;br/&gt;一般来说也不需要很强的模型，但是必须针对性的训练特定场景，就比如滤镜，logo，黑边等场景。&lt;br/&gt;滤镜就如下图所示，1.png经过一个滤镜产生了4.png：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/551233/202012/551233-20201209191246212-1083527443.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还有一种场景是游戏领域的视频去重，由于游戏背景都一样，只有小小的一块人物或者名字不同，也是需要针对性的加数据训练的。&lt;/p&gt;
&lt;p&gt;这里的话，深度学习 MoCo 可能会合适一些。&lt;/p&gt;

&lt;p&gt;重复图在图像相关的项目中基本都会用到，不同的场景用不同的算法。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th&gt;复杂度&lt;/th&gt;
&lt;th&gt;适用场景&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;MD5&lt;/td&gt;
&lt;td&gt;超级低&lt;/td&gt;
&lt;td&gt;绝对原图&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;感知Hash&lt;/td&gt;
&lt;td&gt;低&lt;/td&gt;
&lt;td&gt;肉眼相同&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;深度学习&lt;/td&gt;
&lt;td&gt;高&lt;/td&gt;
&lt;td&gt;特定场景相同&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;</description>
<pubDate>Thu, 10 Dec 2020 00:54:00 +0000</pubDate>
<dc:creator>ERKE</dc:creator>
<og:description>在一些图像相关的项目中，重复图识别是很重要的。就比如**热图排行榜**（需要识别出重复图）；涉及**图像深度学习**的项目（训练数据需要剔除重复图）；**图片原创&amp;视频原创**（需要识别出重复图）等等</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ERKE/p/14111989.html</dc:identifier>
</item>
<item>
<title>Shell：子shell概念 - 不羁的罗恩</title>
<link>http://www.cnblogs.com/Rohn/p/14111943.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Rohn/p/14111943.html</guid>
<description>&lt;p&gt;所谓子shell，即从当前shell环境中新开了一个shell环境，这个新开的shell环境就是子shell，而开启子shell的环境称为该子shell的父shell。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;91.579429735234&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;Blog：&lt;a href=&quot;https://www.cnblogs.com/Rohn/&quot; target=&quot;_blank&quot;&gt;博客园&lt;/a&gt; &lt;a href=&quot;https://k8sdev.com/&quot; target=&quot;_blank&quot;&gt;个人&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;shell环境&quot;&gt;shell环境&lt;/h2&gt;
&lt;p&gt;每个shell进程有一个自己的运行环境，不同的Shell进程有不同的Shell环境。Shell解析命令行、调用命令行的过程都在这个环境中完成。&lt;/p&gt;
&lt;p&gt;调用shell程序时，会读取配置文件来初始化Shell环境。&lt;/p&gt;
&lt;p&gt;读取配置文件情况分为两种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;用户登录启动的shell&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://rohn-web.oss-cn-hangzhou.aliyuncs.com/img/blog/image-20200722201723821.png?x-oss-process=style/cnblog&quot; alt=&quot;image-20200722201723821&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;非用户登录启动的shell&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://rohn-web.oss-cn-hangzhou.aliyuncs.com/img/blog/image-20200722202245669.png?x-oss-process=style/cnblog&quot; alt=&quot;image-20200722202245669&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;什么是子shell&quot;&gt;什么是子shell&lt;/h2&gt;
&lt;p&gt;所谓子shell，即从当前shell环境中新开了一个shell环境，这个新开的shell环境就是子shell，而开启子shell的环境称为该子shell的父shell。&lt;/p&gt;
&lt;p&gt;子Shell的本质可以理解为Shell的子进程，子进程的概念是由父进程的概念引申而来的，在Linux系统中，系统运行的应用程序几乎都是从&lt;code&gt;init&lt;/code&gt;（pid为1的进程）进程派生而来的，所有这些应用程序都可以视为init进程的子进程，而&lt;code&gt;init&lt;/code&gt;则为它们的父进程。通过执行&lt;code&gt;pstree -a&lt;/code&gt;命令就可以看到&lt;code&gt;init&lt;/code&gt;及系统中其他进程的进程树信息：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;[root@test ~]# pstree -a
systemd --switched-root --system --deserialize 22
  ├─NetworkManager --no-daemon
  │   └─2*[{NetworkManager}]
  ├─VGAuthService -s
  ├─agetty --noclear tty1 linux
  ├─auditd
  │   └─{auditd}
  ├─chronyd
  ├─crond -n
  ├─dbus-daemon --system --address=systemd: --nofork --nopidfile --systemd-activation
  ├─irqbalance --foreground
  ├─lvmetad -f
  ├─master -w
  │   ├─pickup -l -t unix -u
  │   └─qmgr -l -t unix -u
  ├─polkitd --no-debug
  │   └─6*[{polkitd}]
  ├─rsyslogd -n
  │   └─2*[{rsyslogd}]
  ├─sshd -D
  │   └─sshd
  │       └─bash
  │           └─pstree -a
  ├─systemd-journal
  ├─systemd-logind
  ├─systemd-udevd
  ├─tuned -Es /usr/sbin/tuned -l -P
  │   └─4*[{tuned}]
  └─vmtoolsd
      └─2*[{vmtoolsd}]
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Tips：若无pstree命令，请执行&lt;code&gt;yum -y install psmisc&lt;/code&gt;安装。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于Shell的子进程来说，它是一个从父级Shell进程派生而来的新的Shell进程，我们将这种新的Shell进程称为这个&lt;strong&gt;父级Shell的子Shell&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;u&gt;Shell脚本是从上至下、从左至右依次执行每一行的命令及语句的，即执行完一个命令之后再执行下一个。如果在Shell脚本中遇到子脚本（即脚本嵌套），就会先执行子脚本的内容，完成后再返回父脚本继续执行父脚本内后续的命令及语句。&lt;/u&gt;&lt;/p&gt;
&lt;p&gt;子shell会从父shell中继承很多环境，如变量、命令全路径、文件描述符、当前工作目录、陷阱等等，但子shell有很多种类型，不同类型的子shell继承的环境不相同。可以使用&lt;code&gt;$BASH_SUBSHELL&lt;/code&gt;变量来查看从当前进程开始的子shell层数，&lt;code&gt;$BASHPID&lt;/code&gt;查看当前所处BASH的PID，这不同于特殊变量&lt;code&gt;$$&lt;/code&gt;值，因为&lt;code&gt;$$&lt;/code&gt;在大多数情况下都会从父shell中继承。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;注意：子 Shell 虽然能使用父 Shell 的的一切，但是如果子 Shell 对数据做了修改，比如修改了全局变量，那么这种修改只能停留在子 Shell，无法传递给父 Shell。不管是子进程还是子 Shell，都是“传子不传父”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;子shell的分类&quot;&gt;子shell的分类&lt;/h2&gt;
&lt;p&gt;大致分为两类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;sub shell：通过进程替换&lt;code&gt;&amp;lt;(cmd),&amp;gt;(cmd)&lt;/code&gt;、命令替换&lt;code&gt;$(cmd)&lt;/code&gt;、&lt;code&gt;(cmd)&lt;/code&gt;、&lt;code&gt;|&lt;/code&gt;或者&lt;code&gt;$&lt;/code&gt;隐式生成的子shell。因为父shell是通过&lt;code&gt;fork&lt;/code&gt;创建sub shell，因此子shell会从父shell中继承很多环境，如变量、命令全路径、文件描述符、当前工作目录、陷阱等等；&lt;/li&gt;
&lt;li&gt;child shell：通过以可执行文件的方式运行shell脚本或直接在当前shell中启动shell解释器的方式得到的子shell。父shell通过&lt;code&gt;fork-exec&lt;/code&gt;的方式创建子shell，导致父shell和子shell除了维持“父子关系”外，没有其他关联。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;注释：使用 fork() 函数可以创建一个子进程；除了 PID（进程ID）等极少的参数不同外，子进程的一切都来自父进程，包括代码、数据、堆栈、打开的文件等，就连代码的执行位置（状态）都是一样的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;</description>
<pubDate>Thu, 10 Dec 2020 00:35:00 +0000</pubDate>
<dc:creator>不羁的罗恩</dc:creator>
<og:description>所谓子shell，即从当前shell环境中新开了一个shell环境，这个新开的shell环境就是子shell，而开启子shell的环境称为该子shell的父shell。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Rohn/p/14111943.html</dc:identifier>
</item>
<item>
<title>为什么要有 Servlet ，什么是 Servlet 容器，什么是 Web 容器？ - yes的练级攻略</title>
<link>http://www.cnblogs.com/yescode/p/14099868.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yescode/p/14099868.html</guid>
<description>&lt;blockquote readability=&quot;4.2385321100917&quot;&gt;
&lt;p&gt;本文已收录至 &lt;a href=&quot;https://github.com/yessimida/yes&quot; target=&quot;_blank&quot;&gt;https://github.com/yessimida/yes&lt;/a&gt; ，这里有我的所有文章分类汇总，欢迎 star!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以下代码相信大家都很熟悉，大学时学 Java Web 都写过这样的代码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16034279-bf414e4786bed774.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从第一次接触 Servlet 到之后的很长一段时间内，我都没理解 Servlet 是个什么玩意？&lt;/p&gt;
&lt;p&gt;为什么要有 Servlet ？&lt;/p&gt;
&lt;p&gt;为什么要有 Servlet 容器？&lt;/p&gt;
&lt;p&gt;啥又是 Web 容器、HTTP 服务器？&lt;/p&gt;
&lt;p&gt;今儿咱们就来盘盘，并且从中来看看&lt;strong&gt;架构和框架的设计套路。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;看完之后可能对接口、抽象会有进一步的认识。&lt;/p&gt;
&lt;p&gt;来，上车！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16034279-9f89a3491eb763a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;正文&quot;&gt;正文&lt;/h2&gt;
&lt;p&gt;首先浏览器发起 HTTP 请求，像早期的时候只会请求一些静态资源，这时候需要一个服务器来处理 HTTP 请求，并且将相应的静态资源返回。&lt;/p&gt;
&lt;p&gt;这个服务器叫 HTTP 服务器。&lt;/p&gt;
&lt;p&gt;简单点说就是解析请求，然后得知需要服务器上面哪个文件夹下哪个名字的静态文件，找到返回即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16034279-ddc25eee08a0c67b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而随着互联网的发展，交互越发得重要，单纯的静态文件满足不了需求。&lt;/p&gt;
&lt;p&gt;业务变得复杂，需要我们编写代码来处理诸多业务。&lt;/p&gt;
&lt;p&gt;需要根据 HTTP 请求调用不同的业务逻辑来响应，但是我们的业务代码不能跟 HTTP 服务器耦合起来。&lt;/p&gt;
&lt;p&gt;总不能在 HTTP 服务器的具体实现里面来做判断到底需要调用哪个业务类吧？&lt;/p&gt;
&lt;p&gt;这就把非业务和业务强相关了。&lt;/p&gt;
&lt;p&gt;所以需要做一层&lt;strong&gt;抽象&lt;/strong&gt;，将 HTTP 的解析和具体的业务隔离。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16034279-bb4ac87610ae49f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本质上的需求就是根据 HTTP 请求找到对应的业务实现类然后执行逻辑再返回。&lt;/p&gt;
&lt;p&gt;而&lt;strong&gt;业务千千万&lt;/strong&gt;，所以需要规定一个接口，所以业务类都实现这个接口这样才好对接。&lt;/p&gt;
&lt;p&gt;这就是接口的含义，就像 USB。&lt;/p&gt;
&lt;p&gt;这个接口就是 Servlet，当然这是最狭义的解释。&lt;/p&gt;
&lt;p&gt;Servlet 其实是 Server Applet，全称 Java Servlet，指的是用Java 编写的服务端程序。&lt;/p&gt;
&lt;p&gt;其实指代的是实现 Servlet 接口的那些业务类。&lt;/p&gt;
&lt;p&gt;这就是 Servlet 的由来。&lt;/p&gt;
&lt;p&gt;而 Servlet 容器其实就是&lt;strong&gt;管理和加载这些 Servlet 类的&lt;/strong&gt;，拿到 HTTP 请求之后找到对应的 Servlet 类这就是 Servlet 容器要做的事情。&lt;/p&gt;
&lt;p&gt;看到这是不是觉得还能再抽一层？因为这好像也和具体的业务实现没关系？&lt;/p&gt;
&lt;p&gt;是的，还能抽一层。&lt;/p&gt;
&lt;p&gt;没必要把 Servlet 容器做的事情和具体的业务耦合起来，业务反正照着 Servlet 接口实现就行，这样 Servlet 容器就可以加载它和管理它。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16034279-4307d42cc6d5fb5d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;把请求和哪个 Servlet 对应关系也抽象出来，就是 web.xml 了，咱们在配置里面告诉 Servlet 容器对应关系即可。&lt;/p&gt;
&lt;p&gt;我图中的业务实现其实对应的就是我们平常的 war 包，这就是业务和 Servlet 容器的解耦。&lt;/p&gt;
&lt;p&gt;想必你也听过 Servlet 规范，其实 Servlet 接口和 Servlet 容器这一整套包括目录命名啊啥的合起来就叫 Servlet 规范。&lt;/p&gt;
&lt;p&gt;所有相关的中间件按照 Servlet 规范实现，我们也按 Servlet 规范来实现业务代码，这样我们就能在不同场景选择不同的 Web 中间件。&lt;/p&gt;
&lt;p&gt;反正规范的目的就是为了对接方便，减少对接成本。&lt;/p&gt;
&lt;p&gt;至此 HTTP 服务器、Servlet 、Servlet 容器想必都清晰了。&lt;/p&gt;
&lt;p&gt;而 Web 容器其实就是 HTTP 服务器 + Servlet 容器，因为单单 Servlet 容器没有解析 HTTP 请求、通信等相关功能。&lt;/p&gt;
&lt;p&gt;所以把 Tomcat、Jetty 等实现包含了 HTTP 服务器和 Servlet 容器的功能，称之为 Web 容器。&lt;/p&gt;
&lt;p&gt;从我们的分析一层一层的剥离，一层一层的抽象，相信你对 Web 有了更进一步的认识，我再画个 Tomcat 的分析图，应该就很清晰了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16034279-a3206d8fefca7f97.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上面的一步步分析可以看出：其实&lt;strong&gt;架构的设计就是一系列相关的抽象。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;先是抽象出 HTTP 服务，用来通信和解析协议。&lt;/p&gt;
&lt;p&gt;再因为业务的复杂，为了不和 HTTP 服务耦合又抽象了一层 Servlet。&lt;/p&gt;
&lt;p&gt;由 Servlet 加载和管理 Servlet ，来控制请求转发到指定的 Servlet 实现类。&lt;/p&gt;
&lt;p&gt;然后我们安心的开发业务即可。&lt;/p&gt;
&lt;p&gt;因为抽象所以灵活易扩展，比如现在是 HTTP1.1 服务，可以换成 HTTP 2。&lt;/p&gt;
&lt;p&gt;现在用 Tomcat 来作为 Servlet 容器，也可以换成 Jetty。&lt;/p&gt;
&lt;p&gt;现在用原生的实现 Servlet 来做业务，也可以换成 SpringMVC。&lt;/p&gt;
&lt;p&gt;随意变更，因为都抽象出来了，就很好替换，只要遵循约定的接口实现即可。&lt;/p&gt;
&lt;h2 id=&quot;框架设计的一个套路&quot;&gt;框架设计的一个套路&lt;/h2&gt;
&lt;p&gt;看完了架构设计的套路，再说说框架套路。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;接口和抽象类。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所有中间件设计必用的套路，当然我们自己的代码也会这样用。&lt;/p&gt;
&lt;p&gt;先&lt;strong&gt;定义一个接口来约定一些动作&lt;/strong&gt;，能做啥做啥。&lt;/p&gt;
&lt;p&gt;然后再&lt;strong&gt;定义一个抽象类来实现这个接口&lt;/strong&gt;，用来实现一些通用的逻辑，做到代码的复用。&lt;/p&gt;
&lt;p&gt;然后再搞一些常用的实现类继承抽象类，方便开发者的使用。&lt;/p&gt;
&lt;p&gt;剩下的就留给开发者自行扩展即可。&lt;/p&gt;
&lt;p&gt;然后抽象类都会使用模板方法，也就是定义执行的流程，具体实现逻辑由子类自行实现。&lt;/p&gt;
&lt;p&gt;这就是必用的套路。&lt;/p&gt;
&lt;p&gt;接口约束、抽象类代码复用、实现常用实现类方便使用、剩下的自行扩展。&lt;/p&gt;
&lt;p&gt;拿 Servlet 举例，首先定义 Servlet 接口。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public interface Servlet {
    void init(ServletConfig config) throws ServletException;
    ServletConfig getServletConfig();
    void service(ServletRequest req, ServletResponse res）throws ServletException, IOException;
    String getServletInfo();
    void destroy();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后搞了个通用抽象类 GenericServlet，不过这个抽象类逻辑比较简单。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public abstract class GenericServlet implements Servlet, ServletConfig,
        java.io.Serializable {
  ................省略一些.............
   @Override
    public ServletConfig getServletConfig() {
        return config;
    }
    @Override
    public ServletContext getServletContext() {
        return getServletConfig().getServletContext();
    }
    @Override
    public void init(ServletConfig config) throws ServletException {
        this.config = config;
        this.init();
    }
................省略一些.....................
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后搞了个常用的 HttpServlet 继承了 GenericServlet。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public abstract class HttpServlet extends GenericServlet {

    private static final long serialVersionUID = 1L;

    private static final String METHOD_DELETE = &quot;DELETE&quot;;
    private static final String METHOD_HEAD = &quot;HEAD&quot;;
    private static final String METHOD_GET = &quot;GET&quot;;
  ....................
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;套路就是这么个套路，之后面试官问你接口和抽象类的问题，相信你也能答出来了。&lt;/p&gt;
&lt;h2 id=&quot;最后&quot;&gt;最后&lt;/h2&gt;
&lt;p&gt;套路大家应该都 GET 到了。&lt;/p&gt;
&lt;p&gt;想必大家都听过“计算机科学中的每个问题都可以用一间接层解决”。&lt;/p&gt;
&lt;p&gt;是的，基本上所有问题抽象一层都能解决。&lt;/p&gt;
&lt;p&gt;如果一层不够，那就两层。&lt;/p&gt;
&lt;p&gt;欢迎加我好友进行深入地交流，备注「进群」，拉你进交流&amp;amp;内推群。&lt;/p&gt;
&lt;p&gt;平日的面试题遇到难处，或者看某个知识点翻遍全网的资料还是感觉很模糊、不透彻，可以私聊我，给我留言。&lt;/p&gt;
&lt;p&gt;遇到合适的我会整理写出一篇文章，我不会的去请教别人也给整出来。&lt;/p&gt;
&lt;p&gt;那种工作遇到很细节的场景的还是别了，这种问你上司比较合适:)&lt;/p&gt;
&lt;p&gt;欢迎关注我的公众号【yes的练级攻略】，更多硬核文章等你来读。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2083803/202012/2083803-20201207214108282-2114526457.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;巨人的肩膀&quot;&gt;巨人的肩膀&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;《深入拆解Tomcat &amp;amp; Jetty》 李号双&lt;/em&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;6.0175438596491&quot;&gt;
&lt;p&gt;微信搜索【yes的练级攻略】，关注 yes，回复【123】一份20W字的算法刷题笔记等你来领，从一点点到亿点点，我们下篇见。&lt;br/&gt;个人文章汇总：&lt;a href=&quot;https://github.com/yessimida/yes&quot; target=&quot;_blank&quot;&gt;https://github.com/yessimida/yes&lt;/a&gt; 欢迎 star !&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 10 Dec 2020 00:35:00 +0000</pubDate>
<dc:creator>yes的练级攻略</dc:creator>
<og:description>本文已收录至 https://github.com/yessimida/yes ，这里有我的所有文章分类汇总，欢迎 star! 以下代码相信大家都很熟悉，大学时学 Java Web 都写过这样的代码。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yescode/p/14099868.html</dc:identifier>
</item>
<item>
<title>换种思路写Mock，让单元测试更简单 - 行无际</title>
<link>http://www.cnblogs.com/itwild/p/14111830.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/itwild/p/14111830.html</guid>
<description>&lt;h2 id=&quot;开篇引入&quot;&gt;开篇引入&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;单元测试中的Mock方法，通常是为了绕开那些依赖外部资源或无关功能的方法调用，使得测试重点能够集中在需要验证和保障的代码逻辑上。在定义Mock方法时，开发者真正关心的只有一件事：&quot;这个调用，在测试的时候要换成那个假的Mock方法&quot;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然而当下主流的Mock框架在实现Mock功能时，需要开发者操心的事情实在太多：Mock框架如何初始化、与所用的单元测试框架是否兼容、要被Mock的方法是不是私有的、是不是静态的、被Mock对象是new出来的还是注入的、怎样把被测对象送回被测类里...这些非关键的额外工作极大分散了使用Mock工具应有的乐趣。&lt;/p&gt;
&lt;p&gt;周末，在翻github上alibaba的开源项目时，无意间看到了下面这个特立独行的轻量Mock工具。当前知道这个工具的人应该很少，star人数28(包括本人在内)，另外我留意了一下该项目在github上第一次提交代码时间是2020年5月9日。&lt;/p&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/alibaba/testable-mock&quot; target=&quot;_blank&quot;&gt;https://github.com/alibaba/testable-mock&lt;/a&gt;&lt;br/&gt;文档：&lt;a href=&quot;https://alibaba.github.io/testable-mock/&quot; target=&quot;_blank&quot;&gt;https://alibaba.github.io/testable-mock/&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;换种思路写Mock，让单元测试更简单。无需初始化，不挑测试框架，甭管要换的方法是被测类的私有方法、静态方法还是其他任何类的成员方法，也甭管要换的对象是怎么创建的。写好Mock方法，加个@TestableMock注解，一切统统搞定。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是 &lt;code&gt;README&lt;/code&gt; 上的描述。扫了一眼项目描述与目录结构后，就抵制不住诱惑，快速上手玩了一下。于是，就有了这篇划水博客，让看到的朋友也心痒一下(●´ω｀●)。当然，最重要的是如果确实好用的话，可以在实际项目中用起来，这样就不再反感需要Mock的单元测试了。&lt;/p&gt;
&lt;h2 id=&quot;快速上手&quot;&gt;快速上手&lt;/h2&gt;
&lt;p&gt;完整代码见本人github：&lt;a href=&quot;https://github.com/itwild/less/tree/master/less-alibaba/less-testable&quot; target=&quot;_blank&quot;&gt;https://github.com/itwild/less/tree/master/less-alibaba/less-testable&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里有一个 &lt;code&gt;WeatherApi&lt;/code&gt; 的接口，通过调用第三方接口查询天气情况，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;import com.github.itwild.less.base.http.feign.WeatherExample;
import feign.Param;
import feign.RequestLine;

public interface WeatherApi {

    @RequestLine(&quot;GET /api/weather/city/{city_code}&quot;)
    WeatherExample.Response query(@Param(&quot;city_code&quot;) String cityCode);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;CityWeather&lt;/code&gt; 查询具体城市的天气，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;import cn.hutool.core.map.MapUtil;
import com.github.itwild.less.base.http.feign.WeatherExample;
import feign.Feign;
import feign.jackson.JacksonDecoder;
import feign.jackson.JacksonEncoder;

import java.util.HashMap;
import java.util.Map;

public class CityWeather {

    private static final String API_URL = &quot;http://t.weather.itboy.net&quot;;

    private static final String BEI_JING = &quot;101010100&quot;;
    private static final String SHANG_HAI = &quot;101020100&quot;;
    private static final String HE_FEI = &quot;101220101&quot;;

    public static final Map&amp;lt;String, String&amp;gt; CITY_CODE = MapUtil.builder(new HashMap&amp;lt;String, String&amp;gt;())
            .put(BEI_JING, &quot;北京市&quot;)
            .put(SHANG_HAI, &quot;上海市&quot;)
            .put(HE_FEI, &quot;合肥市&quot;)
            .build();

    private static WeatherApi weatherApi = Feign.builder()
            .encoder(new JacksonEncoder())
            .decoder(new JacksonDecoder())
            .target(WeatherApi.class, API_URL);

    public String queryShangHaiWeather() {
        WeatherExample.Response response = weatherApi.query(SHANG_HAI);
        return response.getCityInfo().getCity() + &quot;: &quot; + response.getData().getYesterday().getNotice();
    }

    private String queryHeFeiWeather() {
        WeatherExample.Response response = weatherApi.query(HE_FEI);
        return response.getCityInfo().getCity() + &quot;: &quot; + response.getData().getYesterday().getNotice();
    }

    public static String queryBeiJingWeather() {
        WeatherExample.Response response = weatherApi.query(BEI_JING);
        return response.getCityInfo().getCity() + &quot;: &quot; + response.getData().getYesterday().getNotice();
    }

    public static void main(String[] args) {
        CityWeather cityWeather = new CityWeather();

        String shanghai = cityWeather.queryShangHaiWeather();
        String hefei = cityWeather.queryHeFeiWeather();
        String beijing = CityWeather.queryBeiJingWeather();

        System.out.println(shanghai);
        System.out.println(hefei);
        System.out.println(beijing);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行 &lt;code&gt;main&lt;/code&gt; 方法，输出如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;上海市: 不要被阴云遮挡住好心情
合肥市: 不要被阴云遮挡住好心情
北京市: 阴晴之间，谨防紫外线侵扰
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;相信大多数人编写单元测试时，遇到这种依赖第三方资源时，可能就有点反感写单元测试了。&lt;br/&gt;下面看看有了 &lt;code&gt;testable-mock&lt;/code&gt; 工具，如何编写单元测试？&lt;br/&gt;&lt;code&gt;CityWeatherTest&lt;/code&gt; 文件如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;import com.alibaba.testable.core.accessor.PrivateAccessor;
import com.alibaba.testable.core.annotation.TestableMock;
import com.alibaba.testable.processor.annotation.EnablePrivateAccess;
import com.github.itwild.less.base.http.feign.WeatherExample;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

@EnablePrivateAccess
public class CityWeatherTest {

    @TestableMock(targetMethod = &quot;query&quot;)
    public WeatherExample.Response query(WeatherApi self, String cityCode) {
        WeatherExample.Response response = new WeatherExample.Response();
        // mock天气接口调用返回的结果
        response.setCityInfo(new WeatherExample.CityInfo().setCity(
                CityWeather.CITY_CODE.getOrDefault(cityCode, cityCode)));
        response.setData(new WeatherExample.Data().setYesterday(
                new WeatherExample.Forecast().setNotice(&quot;this is from mock&quot;)));
        return response;
    }

    CityWeather cityWeather = new CityWeather();

    /**
     * 测试 public方法调用
     */
    @Test
    public void test_public() {
        String shanghai = cityWeather.queryShangHaiWeather();

        System.out.println(shanghai);
        assertEquals(&quot;上海市: this is from mock&quot;, shanghai);
    }

    /**
     * 测试 private方法调用
     */
    @Test
    public void test_private() {
        String hefei = (String) PrivateAccessor.invoke(cityWeather, &quot;queryHeFeiWeather&quot;);

        System.out.println(hefei);
        assertEquals(&quot;合肥市: this is from mock&quot;, hefei);
    }

    /**
     * 测试 静态方法调用
     */
    @Test
    public void test_static() {
        String beijing = CityWeather.queryBeiJingWeather();

        System.out.println(beijing);
        assertEquals(&quot;北京市: this is from mock&quot;, beijing);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行单元测试，输出如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;合肥市: this is from mock
上海市: this is from mock
北京市: this is from mock
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从运行结果不难发现，依赖第三方接口的 &lt;code&gt;query&lt;/code&gt; 方法已经被仅仅加了个 &lt;code&gt;TestableMock&lt;/code&gt; 注解的方法Mock了。也就是说达到了预期的Mock效果，而且代码优雅易读。&lt;/p&gt;
&lt;h2 id=&quot;实现原理&quot;&gt;实现原理&lt;/h2&gt;
&lt;p&gt;那么，这优雅易读的背后到底隐藏着什么秘密呢？&lt;/p&gt;
&lt;p&gt;相信对这方面有些了解的朋友或多或少也猜到了，没错，正是字节码增强技术！！！&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.alibaba.testable.agent;

import com.alibaba.testable.agent.transformer.TestableClassTransformer;
import java.lang.instrument.Instrumentation;

/**
 * Agent entry, dynamically modify the byte code of classes under testing
 * @author flin
 */
public class PreMain {
    
    public static void premain(String agentArgs, Instrumentation inst) {
        parseArgs(agentArgs);
        inst.addTransformer(new TestableClassTransformer());
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.alibaba.testable.agent.handler;

import org.objectweb.asm.ClassReader;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.tree.ClassNode;

import java.io.IOException;

/**
 * @author flin
 */
abstract public class BaseClassHandler implements Opcodes {

    public byte[] getBytes(byte[] classFileBuffer) throws IOException {
        ClassReader cr = new ClassReader(classFileBuffer);
        ClassNode cn = new ClassNode();
        cr.accept(cn, 0);
        transform(cn);
        ClassWriter cw = new ClassWriter( 0);
        cn.accept(cw);
        return cw.toByteArray();
    }

    /**
     * Transform class byte code
     * @param cn original class node
     */
    abstract protected void transform(ClassNode cn);

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;追一下源码，可见，该Mock工具借助了ASM Core API来修改字节码。上面也提到了，该项目在github上开源出来的时间并不长，核心代码并不多，认真看应该能看懂，主要是有些朋友可能从来没有了解过字节码增强技术。这里推荐美团技术团队的一篇字节码增强技术相关的文章，&lt;a href=&quot;https://tech.meituan.com/2019/09/05/java-bytecode-enhancement.html&quot; target=&quot;_blank&quot;&gt;https://tech.meituan.com/2019/09/05/java-bytecode-enhancement.html&lt;/a&gt;，相信有了这样的基础，回过头来再看看 &lt;code&gt;TestableMock&lt;/code&gt; 的源码会轻松许多。&lt;/p&gt;
&lt;p&gt;本篇博客并不会过多探究字节码增强技术的细节，顶多算是抛砖引玉，目的是让读者知道有这么一个优雅的Mock工具，另外字节码增强技术相当于是一把打开运行时JVM的钥匙，利用它可以动态地对运行中的程序做修改，也可以跟踪JVM运行中程序的状态，这样就能在开发中减少冗余代码，提高开发效率。顺便提一句，我们平时使用的AOP(Cglib就是基于ASM的)也与字节码增强密切相关，它们实质上还是利用各种手段生成符合规范的字节码文件。&lt;/p&gt;
&lt;p&gt;虽然这篇不讲修改字节码的操作细节，但我还是想让读者直观地看到增强后的字节码(class文件)是什么样子的，说白了就是到底把我写的代码在运行时修改成了啥？？？于是，我把运行时增强过的字节码重新写入了文件，然后使用反编译工具(拖到IDEA中即可)观察被修改后的源码。&lt;/p&gt;
&lt;p&gt;运行时(即增强后的)CityWeatherTest.class反编译后如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;import com.alibaba.testable.core.accessor.PrivateAccessor;
import com.alibaba.testable.core.annotation.TestableMock;
import com.alibaba.testable.core.util.InvokeRecordUtil;
import com.alibaba.testable.processor.annotation.EnablePrivateAccess;
import com.github.itwild.less.base.http.feign.WeatherExample.CityInfo;
import com.github.itwild.less.base.http.feign.WeatherExample.Data;
import com.github.itwild.less.base.http.feign.WeatherExample.Forecast;
import com.github.itwild.less.base.http.feign.WeatherExample.Response;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

@EnablePrivateAccess
public class CityWeatherTest {
    CityWeather cityWeather = new CityWeather();
    public static CityWeatherTest _testableInternalRef;
    public static CityWeatherTest _testableInternalRef;

    public CityWeatherTest() {
    }

    @TestableMock(
        targetMethod = &quot;query&quot;
    )
    public Response query(WeatherApi var1, String cityCode) {
        InvokeRecordUtil.recordMockInvoke(new Object[]{var1, cityCode}, false);
        InvokeRecordUtil.recordMockInvoke(new Object[]{var1, cityCode}, false);
        Response response = new Response();
        response.setCityInfo((new CityInfo()).setCity((String)CityWeather.CITY_CODE.getOrDefault(cityCode, cityCode)));
        response.setData((new Data()).setYesterday((new Forecast()).setNotice(&quot;this is from mock&quot;)));
        return response;
    }

    @Test
    public void test_public() {
        _testableInternalRef = this;
        _testableInternalRef = this;
        String shanghai = this.cityWeather.queryShangHaiWeather();
        System.out.println(shanghai);
        Assertions.assertEquals(&quot;上海市: this is from mock&quot;, shanghai);
    }

    @Test
    public void test_private() {
        _testableInternalRef = this;
        _testableInternalRef = this;
        String hefei = (String)PrivateAccessor.invoke(this.cityWeather, &quot;queryHeFeiWeather&quot;, new Object[0]);
        System.out.println(hefei);
        Assertions.assertEquals(&quot;合肥市: this is from mock&quot;, hefei);
    }

    @Test
    public void test_static() {
        _testableInternalRef = this;
        _testableInternalRef = this;
        String beijing = CityWeather.queryBeiJingWeather();
        System.out.println(beijing);
        Assertions.assertEquals(&quot;北京市: this is from mock&quot;, beijing);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行时(即增强后的)CityWeather.class反编译后如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;import cn.hutool.core.map.MapUtil;
import com.github.itwild.less.base.http.feign.WeatherExample.Response;
import feign.Feign;
import feign.jackson.JacksonDecoder;
import feign.jackson.JacksonEncoder;
import java.util.HashMap;
import java.util.Map;

public class CityWeather {
    private static final String API_URL = &quot;http://t.weather.itboy.net&quot;;
    private static final String BEI_JING = &quot;101010100&quot;;
    private static final String SHANG_HAI = &quot;101020100&quot;;
    private static final String HE_FEI = &quot;101220101&quot;;
    public static final Map&amp;lt;String, String&amp;gt; CITY_CODE = MapUtil.builder(new HashMap()).put(&quot;101010100&quot;, &quot;北京市&quot;).put(&quot;101020100&quot;, &quot;上海市&quot;).put(&quot;101220101&quot;, &quot;合肥市&quot;).build();
    private static WeatherApi weatherApi = (WeatherApi)Feign.builder().encoder(new JacksonEncoder()).decoder(new JacksonDecoder()).target(WeatherApi.class, &quot;http://t.weather.itboy.net&quot;);

    public CityWeather() {
    }

    public String queryShangHaiWeather() {
        Response response = CityWeatherTest._testableInternalRef.query(weatherApi, &quot;101020100&quot;);
        return response.getCityInfo().getCity() + &quot;: &quot; + response.getData().getYesterday().getNotice();
    }

    private String queryHeFeiWeather() {
        Response response = CityWeatherTest._testableInternalRef.query(weatherApi, &quot;101220101&quot;);
        return response.getCityInfo().getCity() + &quot;: &quot; + response.getData().getYesterday().getNotice();
    }

    public static String queryBeiJingWeather() {
        Response response = CityWeatherTest._testableInternalRef.query(weatherApi, &quot;101010100&quot;);
        return response.getCityInfo().getCity() + &quot;: &quot; + response.getData().getYesterday().getNotice();
    }

    public static void main(String[] args) {
        CityWeather cityWeather = new CityWeather();
        String shanghai = cityWeather.queryShangHaiWeather();
        String hefei = cityWeather.queryHeFeiWeather();
        String beijing = queryBeiJingWeather();
        System.out.println(shanghai);
        System.out.println(hefei);
        System.out.println(beijing);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;原来，运行时把调用到 &lt;code&gt;query&lt;/code&gt; 方法的实现都换成了自己Mock的代码。&lt;/p&gt;
</description>
<pubDate>Thu, 10 Dec 2020 00:30:00 +0000</pubDate>
<dc:creator>行无际</dc:creator>
<og:description>开篇引入 单元测试中的Mock方法，通常是为了绕开那些依赖外部资源或无关功能的方法调用，使得测试重点能够集中在需要验证和保障的代码逻辑上。在定义Mock方法时，开发者真正关心的只有一件事：&amp;amp;q</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/itwild/p/14111830.html</dc:identifier>
</item>
<item>
<title>MySQL必知必会详细总结 - 不懒人</title>
<link>http://www.cnblogs.com/wuwuyong/p/14100891.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wuwuyong/p/14100891.html</guid>
<description>&lt;p&gt;1.检索单个列：SELECT prod_name FROM products;&lt;/p&gt;
&lt;p&gt;2.检索多个列：SELECT prod_id，prod_name，prod_price FROM products;&lt;/p&gt;
&lt;p&gt;3.检索所有列：SELECT * FROM products;&lt;/p&gt;
&lt;p&gt;4.检索不同的行：SELECT DISTINCT vend_id FROM products;&lt;/p&gt;
&lt;p&gt;5.限制结果：SELECT prod_nameFROM products LIMIT 5,5;&lt;/p&gt;
&lt;p&gt;6.使用完全限定的表名：SELECT products.prod_name FROM products;&lt;/p&gt;


&lt;p&gt;1.排序数据：SELECT prod_name FROM products ORDER BY prod_name;&lt;/p&gt;
&lt;p&gt;2.按多个列排序：SELECT prod_id，prod_price，prod_name FROM products ORDER BY prod_price，prod_name;&lt;/p&gt;
&lt;p&gt;3.指定排序方向&lt;/p&gt;
&lt;p&gt;降序：SELECT prod_id，prod_price，prod_name FROM products ORDER BY prod_price DESC;&lt;/p&gt;
&lt;p&gt;升序：SELECT prod_id，prod_price，prod_name FROM products ORDER BY prod_price ASC;&lt;/p&gt;


&lt;p&gt;1.使用WHERE子句：SELECT prod_name，prod_price FROM products WHERE prod_price = 2.50;&lt;/p&gt;
&lt;p&gt;2.WHERE子句操作符&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1424223/202012/1424223-20201207192040883-333240149.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt; SELECT prod_name，prod_price FROM products WHERE prod_price &amp;lt; 10;&lt;/p&gt;
&lt;p&gt;SELECT prod_name，prod_price FROM products WHERE prod_price &amp;lt;= 10;&lt;/p&gt;
&lt;p&gt;SELECT vend_id，prod_name FROM products WHERE vend_id 1003;&lt;/p&gt;
&lt;p&gt;SELECT vend_id，prod_name FROM products WHERE vend_id != 1003;&lt;/p&gt;
&lt;p&gt;SELECT prod_name，prod_price FROM products WHERE prod_price BETWEEN 5 AND 10;&lt;/p&gt;
&lt;p&gt;SELECT prod_name FROM products WHERE prod_price IS NULL;&lt;/p&gt;


&lt;p&gt;1.组合WHERE子句&lt;/p&gt;
&lt;p&gt;（1）AND操作符：SELECT prod_id，prod_price，prod_name FROM products WHERE vend id = 1003 AND prod_price &amp;lt;= 10;&lt;/p&gt;
&lt;p&gt;（2）OR操作符：SELECT prod_name，prod_price FROM products WHERE vend_id = 1002 OR vend_id = 1003;&lt;/p&gt;
&lt;p&gt;（3）计算次序：例如SELECT prod_name，prod_price FROM products WHERE vend_id = 1002 OR vend_id = 1003 AND prod_price &amp;gt;= 10;先执行AND再执行OR&lt;/p&gt;
&lt;p&gt;2.IN操作符：SELECT prod_name，prod_price FROM products WHERE vend_id IN (1002,1003)ORDER BY prod_name;&lt;/p&gt;
&lt;p&gt;3.NOT操作符：SELECT prod_name，prod_price FROM products WHERE vend_id NOT IN (1002,1003)ORDER BY prod_name;&lt;/p&gt;


&lt;p&gt;1.LIKE操作符&lt;/p&gt;
&lt;p&gt;（1）.百分号（%）通配符：SELECT prod_id，prod_name FROM products WHERE prod_name LIKE 'jet%' ;&lt;/p&gt;
&lt;p&gt;（2）.下划线（_）通配符（匹配单个字符）：SELECT prod_id，prod_name FROM products WHERE prod_name LIKE '_ ton anvil ';&lt;/p&gt;
&lt;p&gt;2.使用通配符的技巧&lt;/p&gt;
&lt;p&gt;不要过度使用通配符。如果其他操作符能达到相同的目的，应该使用其他操作符。&lt;br/&gt;在确实需要使用通配符时，除非绝对有必要，否则不要把它们用在搜索模式的开始处。把通配符置于搜索模式的开始处，搜索起来是最慢的。&lt;br/&gt;仔细注意通配符的位置。如果放错地方，可能不会返回想要的数据。&lt;/p&gt;


&lt;p&gt;1.基本字符匹配（包含文本1000）：SELECT prod_name FROM products WHERE prod_name REGEXP '1000'ORDER BY prod_name;&lt;/p&gt;
&lt;p&gt;2.进行OR匹配：SELECT prod_name FROM products WHERE prod_name REGEXP '1000| 2000' ORDER BY prod_name;&lt;/p&gt;
&lt;p&gt;3.匹配几个字符之一：SELECT prod_name FROM products WHERE prod_name REGEXP '[123] Ton' ORDER BY prod_name;&lt;/p&gt;
&lt;p&gt;4.匹配范围：SELECT prod_name FROM products WHERE prod_name REGEXP '[1-5]Ton' ORDER BY prod_name;&lt;/p&gt;
&lt;p&gt;5.匹配特殊字符：SELECT vend_name FROM vendors WHERE vend_name REGEXP '\ \.' ORDER BY vend_name;&lt;/p&gt;
&lt;p&gt;6.匹配字符类：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1424223/202012/1424223-20201208091209493-175196835.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 7.匹配多个实例&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1424223/202012/1424223-20201208091544631-939146180.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 例：SELECT prod_name FROM products WHERE prod_name REGEXP '\\([0-9] sticks?\ \)' ORDER BY prod_name;&lt;/p&gt;
&lt;p&gt;8.定位符&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1424223/202012/1424223-20201208092156400-1243057783.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 例：SELECT prod_name FROM products WHERE prod_name REGEXP '^[0-9\\.]' ORDER BY prod_name;&lt;/p&gt;


&lt;p&gt;1.拼接字段Concat（显示vend_name(vend_country)格式）：SELECT Concat(vend_name,' ( '， vend_country，') ') FROM vendors ORDER BY vend_name;&lt;/p&gt;
&lt;p&gt;2.执行算术计算：SELECT prod_id,quantity,item_price,quantity*item_price As expanded_price FROM orderitems WHERE order_num = 20005;&lt;/p&gt;


&lt;p&gt;1.文本处理函数&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1424223/202012/1424223-20201208105305480-700228064.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1424223/202012/1424223-20201208105317952-919308196.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 2.日期和时间处理函数&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1424223/202012/1424223-20201208105714498-1929865077.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 例如查询order_date为2005-09-01的数据：SELECT cust_id，order_num FROM orders WHERE Date(order_date) = '2005-09-01';&lt;/p&gt;
&lt;p&gt;3.数值处理函数&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1424223/202012/1424223-20201208111856336-2113341169.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;




&lt;p&gt;1.聚集函数&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1424223/202012/1424223-20201208112148198-1477966716.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt;(1).AVG()函数：SELECT AVG(prod_price) AS avg _price FROM products;&lt;/p&gt;
&lt;p&gt;(2).COUNT()函数：SELECT COUNT(*) AS num__cust FROM customers;&lt;/p&gt;
&lt;p&gt;使用COUNT(*)对表中行的数目进行计数,不管表列中包含的是空值(NULL）还是非空值。&lt;br/&gt;使用COUNT ( column)对特定列中具有值的行进行计数，忽略NULL值。&lt;/p&gt;
&lt;p&gt;(3).MAX函数：SELECT MAX(prod_price) AS max_price FROM products;&lt;/p&gt;
&lt;p&gt;(4).MIN函数：SELECT MIN(prod_price) AS min_price FROM products;&lt;/p&gt;
&lt;p&gt;(5).SUM函数：SELECT SUM(quantity) AS items_ordered FROM orderitems WHERE order_num = 20005;&lt;/p&gt;
&lt;p&gt;2.聚集不同值DISTINCT（计算不同价格的平均数）：SELECT AVG(DISTINCT prod_price) As avg_price FROM products WHERE vend_id = 1003;&lt;/p&gt;
&lt;p&gt;3.组合聚集函数：SELECT COUNT(*) AS num_items, MIN(prod_price) AS price_min，MAX(prod_price) AS price_max,AVG(prod_price) AS price_avg FROM products;&lt;/p&gt;


&lt;p&gt;1.创建分组：SELECT vend_id，COUNT(*) AS num_prods FROM products GROUP BY vend_id;&lt;/p&gt;
&lt;p&gt;2.过滤分组：SELECT cust_id，COUNT(*) AS orders FROM orders GROUP BY cust_id HAVING COUNT(*) &amp;gt;= 2;&lt;/p&gt;
&lt;p&gt;3.分组和排序：SELECT order_num，SUM(quantity*item_price) AS ordertotal FROM orderitems GROUP BY order_num HAVING SUM(quantity*i tem_price) &amp;gt;= 50 ORDER BY ordertotal;&lt;/p&gt;


&lt;p&gt;1.利用子查询进行过滤&lt;/p&gt;
&lt;p&gt;SELECT cust_name，cust_contact FROM customers WHERE cust_id IN (SELECT cust_id FROM orders WHERE order_num IN (SELECT order_num FROM orderitems WHERE prod_id = 'TNT2'));&lt;/p&gt;
&lt;p&gt;2.作为计算字段使用子查询：SELECT cust_name,cust_state, (SELECT COUNT(*) FROM orders WHERE orders.cust_id = customers.cust_id)  AS orders FROM customers ORDER BY cust_name;&lt;/p&gt;


&lt;p&gt;1.创建联结：SELECT vend_name，prod_name，prod_price FROM vendors，products WHERE vendors.vend_id = products.vend_id ORDER BY vend_name，prod_name;&lt;/p&gt;


&lt;p&gt; 1.外部联结（LEFT OUTER J0IN）&lt;/p&gt;
&lt;p&gt;SELECT customers.cust_id，orders.order_num FROM customers LEFT OUTER J0IN orders ON customers.cust_id = orders.cust_id;&lt;/p&gt;
&lt;p&gt;SELECT customers.cust_id，orders.order_num FROM customers RIGHT OUTER JOIN orders ON orders.cust_id = customers.cust_id;&lt;/p&gt;
&lt;p&gt;2.使用带聚集函数的联结&lt;/p&gt;
&lt;p&gt;SELECT customers.cust_name, customers.cust_id， COUNT(orders.order_num) AS num_ord FROM customers INNER J0IN orders ON customers.cust_id = orders.cust_id GROUP BY customers.cust_id;&lt;/p&gt;


&lt;p&gt;1.使用UNION（去除重复行）&lt;/p&gt;
&lt;p&gt;SELECT vend_id，prod_id，prod_price FROM products WHERE prod_price &amp;lt;= 5&lt;/p&gt;
&lt;p&gt;UNION&lt;/p&gt;
&lt;p&gt;SELECT vend_id，prod_id，prod_price FROM products WHERE vend_id IN (1001,1002);&lt;/p&gt;
&lt;p&gt;2.使用UNION ALL（可以重复）&lt;/p&gt;
&lt;p&gt;SELECT vend_id，prod_id，prod_price FROM products WHERE prod_price &amp;lt;= 5&lt;/p&gt;
&lt;p&gt;UNION ALL&lt;/p&gt;
&lt;p&gt;SELECT vend_id，prod_id，prod_price FROM products WHERE vend_id IN (1001,1002);&lt;/p&gt;
&lt;p&gt;3.对组合查询结果排序：在用UNION组合查询时，只能使用一条ORDER BY子句，它必须出现在最后一条SELECT语句之后。&lt;/p&gt;
&lt;p&gt;SELECT vend_id，prod_id，prod_price FROM products&lt;br/&gt;WHERE prod_price &amp;lt;= 5UNION&lt;br/&gt;SELECT vend_id，prod_id，prod_price FROM products&lt;br/&gt;WHERE vend_id IN (1001,1002) ORDER BY vend_id，prod_price;&lt;/p&gt;


&lt;p&gt;1.启用全文本搜索支持（FULLTEXT）&lt;/p&gt;
&lt;p&gt;CREATE TABLE productnotes(&lt;br/&gt;note_id int NOT NULL AUTO_INCREMENT ,&lt;/p&gt;
&lt;p&gt;prod_id char(10) NOT NULL,&lt;/p&gt;
&lt;p&gt;note_date datetime NOT NULL,&lt;/p&gt;
&lt;p&gt;note_text text NULL ,&lt;/p&gt;
&lt;p&gt;PRIMARY KEY(note_id)，&lt;br/&gt;FULLTEXT(note_text))&lt;/p&gt;
&lt;p&gt;ENGINE=MyISAM;&lt;/p&gt;
&lt;p&gt;2.进行全文本搜索（Match()指定被搜索的列，Against()指定要使用的搜索表达式）&lt;/p&gt;
&lt;p&gt;SELECT note_text FROM productnotes WHERE Match(note_text) Against( ' rabbit');&lt;/p&gt;
&lt;p&gt;3.使用查询扩展&lt;/p&gt;
&lt;p&gt;SELECT note_text FROM productnotes WHERE Match(note_text) Against( 'anvils' WITH QUERY EXPANSION);&lt;/p&gt;
&lt;p&gt;4.布尔文本搜索&lt;/p&gt;
&lt;p&gt;匹配包含heavy：SELECT note_text FROM productnotes WHERE Match(note_text) Against( 'heavy' IN BOOLEAN MODE);&lt;/p&gt;
&lt;p&gt;匹配包含heavy但不包含任意以rope开始的词的行：SELECT note_text FROM productnotes WHERE Match(note_text) Against( 'heavy -rope*' IN BOOLEAN MODE);&lt;/p&gt;
&lt;p&gt;全文本布尔操作符：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1424223/202012/1424223-20201209094322655-698712479.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;



&lt;p&gt;1.插入完整的行：INSERT INTO customers (cust__name,cust_address,cust_city,cust_state,cust_zip,cust_country ,cust_contact,cust_emai1) VALUES( 'Pep E. LaPew ' ,'100 Main Street','Los Angeles','CA','90046','USA' ,NULL,NULL);&lt;/p&gt;
&lt;p&gt;2.插入多个行&lt;/p&gt;
&lt;p&gt;INSERT INTO customers(cust_name,cust_address,cust_city,cust_state,cust_zip,cust_country)&lt;/p&gt;
&lt;p&gt;VALUES('Pep E. LaPew ' ,'100 Main Street' ,'Los Angeles','CA'，'90046','USA'),&lt;/p&gt;
&lt;p&gt;('M. Martian ' ,'42 Galaxy way ' ,'New York ' ,'NY','11213','USA');&lt;/p&gt;
&lt;p&gt;3.插入检索出的数据&lt;/p&gt;
&lt;p&gt;INSERT INTO customers(cust_id,cust_contact,cust__emai1,cust_name,cust_address,cust_city,cust_state,cust_zip,cust__country)&lt;/p&gt;
&lt;p&gt;SELECT cust_id,cust_contact,cust_emai1,cust_name,cust_address,cust_city,cust_state,cust_zip，cust_countryFROM custnew;&lt;/p&gt;

&lt;p&gt;十七.更新和删除数据&lt;/p&gt;
&lt;p&gt;1.更新数据：UPDATE customers SET cust_email = 'e1mer@fudd. com' WHERE cust_id = 10005;&lt;/p&gt;
&lt;p&gt;2.删除数据：DELETE FROM customersWHERE cust_id = 10006;&lt;/p&gt;


&lt;p&gt;1.创建表基础&lt;/p&gt;
&lt;p&gt;CREATE TABLE customers(&lt;br/&gt;　　cust_id int NOT NULL AUTO_INCREMENT,&lt;/p&gt;
&lt;p&gt;　　cust_namechar(50)NOT NULL ,&lt;br/&gt;　　cust_address char(50) NULL ,&lt;br/&gt;　　cust_citychar(50) NULL ,cust_statechar(5) NULL ,cust_zip&lt;br/&gt;　　char(10) NULL ,&lt;br/&gt;　　cust_country char(50) NULL ,&lt;/p&gt;
&lt;p&gt;　　cust_contact char(50) NULL ,&lt;/p&gt;
&lt;p&gt;　　cust_emai1char(255) NULL ,&lt;/p&gt;
&lt;p&gt;　　PRIMARY KEY (cust_id)&lt;/p&gt;
&lt;p&gt;) ENGINE=InnoDB;&lt;/p&gt;
&lt;p&gt;2.使用AUTO_INCREMENT：cust_id int NOT NULL AUTO_INCREMENT ,&lt;/p&gt;
&lt;p&gt;3.添加一列：ALTER TABLE vendors ADD vend_phone CHAR(20);&lt;/p&gt;
&lt;p&gt;4.删除一列：ALTER TABLE VendorsDROP COLUMN vend_phone;&lt;/p&gt;
&lt;p&gt;5.删除表：DROP TABLE customers2 ;&lt;/p&gt;
&lt;p&gt;6.重命名表：RENAME TABLE customers2 TO customers;&lt;/p&gt;


&lt;p&gt;理解视图的最好方法是看一个例子：&lt;/p&gt;
&lt;p&gt;SELECT cust_name，cust_contact FROM customers,orders，orderitems&lt;br/&gt;WHERE customers.cust_id = orders.cust_id&lt;br/&gt;AND orderitems.order_num = orders.order_num AND prod_id = 'TNT2 ';&lt;/p&gt;
&lt;p&gt;此查询用来检索订购了某个特定产品的客户。任何需要这个数据的人都必须理解相关表的结构，并且知道如何创建查询和对表进行联结。为了检索其他产品（或多个产品）的相同数据，必须修改最后的WHERE子句。&lt;br/&gt;现在，假如可以把整个查询包装成一个名为productcustomers的虚拟表，则可以如下轻松地检索出相同的数据:&lt;/p&gt;
&lt;p&gt;SELECT cust_name，cust_contact FROM productcustomers WHERE prod_id = 'TNT2';&lt;/p&gt;
&lt;p&gt;1.创建视图&lt;/p&gt;
&lt;p&gt;CREATE VIEW productcustomers AS&lt;br/&gt;SELECT cust_name，cust_contact，prod_id FROM customers，orders，orderitems&lt;br/&gt;WHERE customers.cust_id = orders.cust_id&lt;br/&gt;AND orderitems.order_num = orders.order_num;&lt;/p&gt;


&lt;p&gt;存储过程简单来说，就是为以后的使用而保存的一条或多条MySQL语句的集合。&lt;/p&gt;
&lt;p&gt;1.执行存储过程：CALL productpricing(@pricelow,@pricehigh,@priceaverage);&lt;/p&gt;
&lt;p&gt;其中，执行名为productpricing的存储过程，它计算并返回产品的最低、最高和平均价格。&lt;/p&gt;
&lt;p&gt;2.创建存储过程&lt;/p&gt;
&lt;p&gt;CREATE PROCEDURE productpricing()&lt;/p&gt;
&lt;p&gt;BEGIN&lt;br/&gt;　　SELECT Avg(prod_price) AS priceaverage FROM products;&lt;br/&gt;END;&lt;/p&gt;
&lt;p&gt;我此存储过程名为productpricing，用CREATE PROCEDURE productpricing( )语句定义。如果存储过程接受参数，它们将在()中列举出来。此存储过程没有参数，但后跟的()仍然需要。BEGIN和END语句用来限定存储过程体，过程体本身仅是一个简单的SELECT语句。&lt;/p&gt;
&lt;p&gt;使用：CALL productpricing();&lt;/p&gt;
&lt;p&gt;3.删除存储过程：DROP PROCEDURE productpricing;&lt;/p&gt;
&lt;p&gt;4.使用参数&lt;/p&gt;
&lt;p&gt;一般，存储过程并不显示结果，而是把结果返回给你指定的变量。&lt;/p&gt;
&lt;p&gt;CREATE PROCEDURE productpricing(&lt;br/&gt;　　OUT pl DECIMAL(8,2)，&lt;br/&gt;　　OUT ph DECIMAL(8,2)，&lt;/p&gt;
&lt;p&gt;　　OUT pa DECIMAL(8,2)&lt;br/&gt;)&lt;br/&gt;BEGIN&lt;br/&gt;　　SELECT Min(prod_price) INTO pl&lt;br/&gt;　　FROM products;&lt;br/&gt;　　SELECT Max(prod_price) INTO ph&lt;br/&gt;　　FROM products;&lt;br/&gt;　　SELECT Avg(prod_price) INTO pa&lt;br/&gt;　　FROM products;&lt;/p&gt;
&lt;p&gt;END;&lt;/p&gt;
&lt;p&gt;此存储过程接受3个参数:pl存储产品最低价格，ph存储产品最高价格，pa存储产品平均价格。每个参数必须具有指定的类型，这里使用十进制值。关键字OUT指出相应的参数用来从存储过程传出一个值（返回给调用者)。MySQL支持IN（传递给存储过程)、OUT（从存储过程传出，如这里所用）和INOUT(对存储过程传入和传出）类型的参数。存储过程的代码位于BEGIN和END语句内，如前所见，它们是一系列SELECT语句，用来检索值，然后保存到相应的变量（通过指定INTO关键字)。&lt;/p&gt;
&lt;p&gt;调用：CALL productpricing(@pricelow,@pricehigh,@priceaverage);&lt;/p&gt;
&lt;p&gt;SELECT @pricehigh，@pricelow，@priceaverage;&lt;/p&gt;
&lt;p&gt;5.建立智能存储过程&lt;/p&gt;
&lt;p&gt;CREATE PROCEDURE ordertotal(&lt;br/&gt;　　IN onumber INT,&lt;br/&gt;　　IN taxable BOOLEAN,&lt;/p&gt;
&lt;p&gt;　　OUT otota1 DECIMAL(8,2)&lt;br/&gt;) COMMENT ‘0btain order total， optiona1ly adding tax'&lt;/p&gt;
&lt;p&gt;BEGIN&lt;br/&gt;　　-- Declare variable for total&lt;/p&gt;
&lt;p&gt;　　DECLARE total DECIMAL(8,2);&lt;/p&gt;
&lt;p&gt;　　-- Declare tax percentage&lt;br/&gt;　　DECLARE taxrate INT DEFAULT 6;&lt;br/&gt;　　-- Get the order total&lt;br/&gt;　　SELECT Sum(item_price*quantity)&lt;/p&gt;
&lt;p&gt;　　FROM orderitems&lt;br/&gt;　　WHERE order_num = onumber&lt;/p&gt;
&lt;p&gt;　　INTO total;&lt;br/&gt;　　-- Is this taxab1e?&lt;/p&gt;
&lt;p&gt;　　IF taxable THEN&lt;br/&gt;　　　　-- Yes,so add taxrate to the total&lt;br/&gt;　　SELECT total+(total/100*taxrate) INTO total;&lt;/p&gt;
&lt;p&gt;　　END IF;&lt;/p&gt;
&lt;p&gt;　　-- And final1y，save to out variable&lt;/p&gt;
&lt;p&gt;　　SELECT total INTO ototal;&lt;br/&gt;END;&lt;/p&gt;
&lt;p&gt;此存储过程有很大的变动。首先，增加了注释（前面放置--)。在存储过程复杂性增加时，这样做特别重要。添加了另外一个参数taxable，它是一个布尔值（如果要增加税则为真，否则为假)。在存储过程体中，用DECLARE语句定义了两个局部变量。DECLARE要求指定变量名和数据类型，它也支持可选的默认值（这个例子中的taxrate的默认被设置为6%)。SELECT语句已经改变，因此其结果存储到total(局部变量）而不是ototal。IF语句检查taxable是否为真，如果为真，则用另一SELECT语句增加营业税到局部变量total。最后，用另一SELECT语句将total （它增加或许不增加营业税）保存到ototal。&lt;/p&gt;
&lt;p&gt;调用：CALL ordertotal(20005，o，@total);&lt;/p&gt;
&lt;p&gt;6.检查存储过程：SHOW CREATE PROCEDURE ordertotal;&lt;/p&gt;


&lt;p&gt;游标(cursor)是一个存储在MySQL服务器上的数据库查询,它不是一条SELECT语句，而是被该语句检索出来的结果集。在存储了游标之后，应用程序可以根据需要滚动或浏览其中的数据。&lt;/p&gt;
&lt;p&gt;1.创建游标&lt;/p&gt;
&lt;p&gt;CREATE PROCEDURE processorders()&lt;/p&gt;
&lt;p&gt;BEGIN&lt;br/&gt;　　DECLARE ordernumbers CURSOR&lt;/p&gt;
&lt;p&gt;　　FOR&lt;br/&gt;　　SELECT order_num FROM orders;&lt;/p&gt;
&lt;p&gt;END;&lt;/p&gt;
&lt;p&gt;2.打开和关闭游标&lt;/p&gt;
&lt;p&gt;OPEN ordernumbers;&lt;/p&gt;
&lt;p&gt;CLOSE ordernumbers;&lt;/p&gt;
&lt;p&gt;3.例子&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1424223/202012/1424223-20201209231950616-2010431916.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1424223/202012/1424223-20201209232005241-1866264977.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 在这个例子中，我们增加了另一个名为t的变量（存储每个订单的合计)。此存储过程还在运行中创建了一个新表(如果它不存在的话)，名为ordertotals。这个表将保存存储过程生成的结果。FETCH像以前一样取每个order_num，然后用CALL执行另一个存储过程来计算每个订单的带税的合计（结果存储到t)。最后，用INSERT保存每个订单的订单号和合计。&lt;/p&gt;


&lt;p&gt;1.创建触发器：CREATE TRIGGER newproduct AFTER INSERT ON products FOR EACH ROw SELECT 'Product added ' ;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1424223/202012/1424223-20201209232623925-124010810.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 2.删除触发器：DROP TRIGGER newproduct;&lt;/p&gt;
</description>
<pubDate>Thu, 10 Dec 2020 00:11:00 +0000</pubDate>
<dc:creator>不懒人</dc:creator>
<og:description>一.检索数据 1.检索单个列：SELECT prod_name FROM products; 2.检索多个列：SELECT prod_id，prod_name，prod_price FROM prod</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wuwuyong/p/14100891.html</dc:identifier>
</item>
<item>
<title>MySQL事务（一）认识事务 - 大杂草</title>
<link>http://www.cnblogs.com/liang24/p/14111897.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liang24/p/14111897.html</guid>
<description>&lt;p&gt;简单来说，事务就是要保证一组数据库操作，要么全部完成，要么全部失败。&lt;/p&gt;
&lt;h2 id=&quot;为什么要有事务&quot;&gt;为什么要有事务&lt;/h2&gt;
&lt;p&gt;数据库中的数据是共享资源，因此数据库系统通常要支持多个用户的或不同应用程序的访问，会出现并发存取数据的现象。&lt;/p&gt;
&lt;p&gt;数据库系统必须对这种并发操作提供一种相应的处理机制来保证，访问彼此之间不受任何干扰，从而保证数据库的正确性不受到破坏，这种处理机制称为“并发控制”。其中事务就是为了保证数据的一致性而产生的一种概念和手段。&lt;/p&gt;
&lt;h2 id=&quot;事务特性&quot;&gt;事务特性&lt;/h2&gt;
&lt;p&gt;为了保证数据库的正确性与一致性，事务要具有4个特性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;原子性（atomicity）：一个事务应该是一个不可分割的工作单位，事务中包括的操作要么都成功，要么都不成功。&lt;/li&gt;
&lt;li&gt;一致性（consistency）：事务必须是使数据库从一个一致性状态变成另一个一致性状态。一致性与原子性是密切相关的。&lt;/li&gt;
&lt;li&gt;隔离性（isolation）：一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据在事务未提交前对并发的其他事务是隔离的，并发执行的各个事务之间不能互相影响。&lt;/li&gt;
&lt;li&gt;持久性（durability）：一个事务一旦成功提交，它对数据库中数据的改变就应该是永久性的。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;并发事务存在的问题&quot;&gt;并发事务存在的问题&lt;/h2&gt;
&lt;p&gt;如果不考虑事务的隔离性，会发生以下几种问题：&lt;/p&gt;
&lt;h3 id=&quot;脏读&quot;&gt;脏读&lt;/h3&gt;
&lt;p&gt;脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。&lt;/p&gt;
&lt;h3 id=&quot;不可重复读&quot;&gt;不可重复读&lt;/h3&gt;
&lt;p&gt;不可重复读是指在对于数据库中的某条数据，一个事务范围内多次查询返回不同的数据值（这里的不同是指某一条或多条数据的内容前后不一致，但数据条数相同）。&lt;/p&gt;
&lt;p&gt;不可重复读和脏读的区别是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;脏读是某一事务读取了另一个事务未提交的脏数据。&lt;/li&gt;
&lt;li&gt;不可重复读是读取了其他事务提交的数据。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;幻读&quot;&gt;幻读&lt;/h3&gt;
&lt;p&gt;幻读指的是一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的行。&lt;/p&gt;
&lt;h2 id=&quot;事务隔离级别&quot;&gt;事务隔离级别&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;读未提交（read uncommitted）：一个事务还没提交时，它做的变更就能被别的事务看到。&lt;/li&gt;
&lt;li&gt;读提交（read committed）：一个事务提交之后，它做的变更才会被其他事务看到。&lt;/li&gt;
&lt;li&gt;可重复读（repeatable read）：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。&lt;/li&gt;
&lt;li&gt;串行化（serializable ）：顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面用一个例子来说明这四种隔离级别：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;mysql&amp;gt; create table T(c int) engine=InnoDB;
mysql&amp;gt; insert into T(c) values(1);
&lt;/code&gt;
&lt;/pre&gt;
&lt;img src=&quot;https://yxl-article.oss-cn-shenzhen.aliyuncs.com/images/mysql/transaction-rc-rr.png&quot;/&gt;&lt;p&gt;假设表T只有一条记录，值是1。我们来看看在不同的隔离级别下，事务A会有哪些不同的返回结果，也就是图里面T4、T6、T8的返回值分别是什么。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;若隔离级别是“读未提交”， 则T4的值就是2。这时候事务B虽然还没有提交，但是结果已经被A看到了。因此，T6、T8也都是2。&lt;/li&gt;
&lt;li&gt;若隔离级别是“读提交”，则T4是1，T6的值是2。事务B的更新在提交后才能被A看到。所以， T8的值也是2。&lt;/li&gt;
&lt;li&gt;若隔离级别是“可重复读”，则T4、T6是1，T8是2。之所以T6还是1，遵循的就是这个要求：事务在执行期间看到的数据前后必须是一致的。&lt;/li&gt;
&lt;li&gt;若隔离级别是“串行化”，则在事务B执行“将1改成2”的时候，会被锁住。直到事务A提交后，事务B才可以继续执行。所以从A的角度看， T4、T6值是1，T8的值是2。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;参数资料&quot;&gt;参数资料&lt;/h2&gt;
</description>
<pubDate>Thu, 10 Dec 2020 00:08:00 +0000</pubDate>
<dc:creator>大杂草</dc:creator>
<og:description>简单来说，事务就是要保证一组数据库操作，要么全部完成，要么全部失败。 为什么要有事务 数据库中的数据是共享资源，因此数据库系统通常要支持多个用户的或不同应用程序的访问，会出现并发存取数据的现象。 数据</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/liang24/p/14111897.html</dc:identifier>
</item>
<item>
<title>条件循环语句组成了Python代码的骨架 - dongfanger</title>
<link>http://www.cnblogs.com/df888/p/14107867.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/df888/p/14107867.html</guid>
<description>&lt;p&gt;我们都知道流程图是有多个分支的，程序中也是如此，在Python中是用if语句来判断程序该走哪个分支的。它的执行过程如下：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202012/1629545-20201209153454635-995946787.png&quot;/&gt;&lt;/center&gt;
&lt;p&gt;代码执行过程如下：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202012/1629545-20201209153455095-273827781.png&quot;/&gt;&lt;/center&gt;
&lt;h2 id=&quot;if&quot;&gt;if&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;if&lt;/code&gt;语句的一般形式如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;if condition_1:
    statement_block_1
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;如果condition_1为True，执行statement_block_1。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;condition_1是条件表达式，由各种运算符和数据类型组成，条件表达式的结果可以是True/False的布尔值，也可以是非布尔值。Python中的0、None、空列表、空字典等都会被认为是False，反之都会被认为是True。&lt;/p&gt;
&lt;h2 id=&quot;else&quot;&gt;else&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;else&lt;/code&gt;语句在条件为False时执行：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;if condition_1:
    statement_block_1
else:
    statement_block_2
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;如果condition_1为True，执行statement_block_1。&lt;/li&gt;
&lt;li&gt;如果condition_1为False，执行statement_block_2。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;elif&quot;&gt;elif&lt;/h2&gt;
&lt;p&gt;if...else实现了“如果满足条件，那么xxx，否则xxx”，除此之外，还可以用&lt;code&gt;elif&lt;/code&gt;实现多个连续判断，分别执行不同的语句：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;if condition_1:
    statement_block_1
elif condition_2:
    statement_block_2
else:
    statement_block_3
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;如果condition_1为True，执行statement_block_1。&lt;/li&gt;
&lt;li&gt;如果condition_1为False，再判断，如果condition_2为True，执行statement_block_2。&lt;/li&gt;
&lt;li&gt;否则，执行statement_block_3。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;elif&lt;/code&gt;可以写多个。这种写法的执行顺序是从上往下，只要满足了某个&lt;code&gt;if&lt;/code&gt;或&lt;code&gt;elif&lt;/code&gt;的条件，就会在当前分支执行后跳出去，不再执行后面的判断，如果每个&lt;code&gt;if&lt;/code&gt;或&lt;code&gt;elif&lt;/code&gt;的条件都是False，最后就会执行&lt;code&gt;else&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;if嵌套&quot;&gt;if嵌套&lt;/h2&gt;
&lt;p&gt;假如想满足&lt;code&gt;if&lt;/code&gt;或&lt;code&gt;elif&lt;/code&gt;的条件后，继续做判断，那么就需要进行&lt;code&gt;if&lt;/code&gt;语句嵌套，让statement_block_1等代码块也包含&lt;code&gt;if&lt;/code&gt;语句：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;if 表达式1:
    语句
    if 表达式2:
        语句
    elif 表达式3:
        语句
    else:
        语句
elif 表达式4:
    语句
else:
    语句
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;num=int(input(&quot;输入一个数字：&quot;))
if num%2==0:
    if num%3==0:
        print(&quot;你输入的数字可以整除 2 和 3&quot;)
    else:
        print(&quot;你输入的数字可以整除 2，但不能整除 3&quot;)
else:
    if num%3==0:
        print(&quot;你输入的数字可以整除 3，但不能整除 2&quot;)
    else:
        print  (&quot;你输入的数字不能整除 2 和 3&quot;)
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;条件语句是从上往下流水式单次执行，循环语句和条件语句的不同点在于，循环是可以回到起始点，反复执行多次的，它的执行过程如下：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202012/1629545-20201209153455360-1296762912.png&quot;/&gt;&lt;/center&gt;
&lt;h2 id=&quot;while&quot;&gt;while&lt;/h2&gt;
&lt;p&gt;循环语句的一种形式是while语句：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;while 判断条件(condition)：
    执行语句(statements)……
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它的执行流程图如下：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202012/1629545-20201209153455625-1399320562.png&quot;/&gt;&lt;/center&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;n = 100
 
sum = 0
counter = 1
while counter &amp;lt;= n:
    sum = sum + counter
    counter += 1
 
print(&quot;1 到 %d 之和为: %d&quot; % (n,sum))  # 5050
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;for&quot;&gt;for&lt;/h2&gt;
&lt;p&gt;循环语句的另一种形式是for语句：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;for &amp;lt;variable&amp;gt; in &amp;lt;sequence&amp;gt;:
    &amp;lt;statements&amp;gt;
else:
    &amp;lt;statements&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它的执行流程图如下：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202012/1629545-20201209153455985-526796397.png&quot;/&gt;&lt;/center&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;languages = [&quot;C&quot;, &quot;C++&quot;, &quot;Perl&quot;, &quot;Python&quot;]
for x in languages:
    print(x)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;break&quot;&gt;break&lt;/h2&gt;
&lt;p&gt;break用来跳出整个循环，它的执行流程图如下：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202012/1629545-20201209153456271-855186978.png&quot;/&gt;&lt;/center&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;for letter in 'Runoob':     # 第一个实例
   if letter == 'b':
      break
   print ('当前字母为 :', letter)
  
var = 10                    # 第二个实例
while var &amp;gt; 0:              
   print ('当期变量值为 :', var)
   var = var -1
   if var == 5:
      break
 
print (&quot;Good bye!&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;continue&quot;&gt;continue&lt;/h2&gt;
&lt;p&gt;break用来跳出整个循环，continue则是用来跳过当前循环，回到起点，继续下一次循环。它的执行流程图如下：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202012/1629545-20201209153456541-1548500393.png&quot;/&gt;&lt;/center&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;for letter in 'Runoob':     # 第一个实例
   if letter == 'o':        # 字母为 o 时跳过输出
      continue
   print ('当前字母 :', letter)
 
var = 10                    # 第二个实例
while var &amp;gt; 0:              
   var = var -1
   if var == 5:             # 变量为 5 时跳过输出
      continue
   print ('当前变量值 :', var)
print (&quot;Good bye!&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;break和continue在while循环和for循环中的代码执行过程如下：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202012/1629545-20201209153456827-2074206865.png&quot;/&gt;&lt;/center&gt;
&lt;br/&gt;&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202012/1629545-20201209153457081-1307240062.png&quot;/&gt;&lt;/center&gt;
&lt;h2 id=&quot;循环else&quot;&gt;循环else&lt;/h2&gt;
&lt;p&gt;循环后面可以加else语句，&lt;code&gt;while...else&lt;/code&gt;，&lt;code&gt;for...else&lt;/code&gt;。咋看一下else好像并没有什么用，因为while循环条件为False或for循环结束后，一定会执行接下来的语句。但是如果循环中出现了break，当循环从break跳出来后，是不会执行else语句的。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;for n in range(2, 10):
    for x in range(2, n):
        if n % x == 0:
            print(n, '等于', x, '*', n//x)
            break
    else:
        # 循环中没有找到元素
        print(n, ' 是质数')
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;range()函数可以生成数字序列。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;无限循环&quot;&gt;无限循环&lt;/h2&gt;
&lt;p&gt;通过设置while循环条件始终为True，可以让循环一直进行下去，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;while True:
    pass
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;pass是占位语句，不执行任何操作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;无限循环是很有用的，比如定时任务，每隔5分钟收1次邮件：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import time

while True:
    receive_email()
    time.sleep(300)
    
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还有比如客户端和服务器保持连接的心跳机制等。&lt;/p&gt;

&lt;p&gt;本文介绍了条件控制和循环语句，也就是写Python常用的&lt;code&gt;if&lt;/code&gt;、&lt;code&gt;while&lt;/code&gt;、&lt;code&gt;for&lt;/code&gt;语句，同时也讲解了附带语句&lt;code&gt;elif&lt;/code&gt;、&lt;code&gt;else&lt;/code&gt;、&lt;code&gt;break&lt;/code&gt;、&lt;code&gt;continue&lt;/code&gt;、&lt;code&gt;pass&lt;/code&gt;的使用。同时也包括了if嵌套、循环else、无限循环的知识点。这一部分的知识非常重要，是代码的骨架，除了看文章，学代码最好的方式是实际敲代码。我们建了一个“Python互助讨论群”，每周日会有算法刷题打卡活动（照着答案敲一遍也ok），公众号后台回复“加群”即可加入，有兴趣的同学可以一起来相互学习交流呀。&lt;/p&gt;
&lt;blockquote readability=&quot;0.90839694656489&quot;&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.runoob.com/python3/python3-conditional-statements.html&quot; target=&quot;_blank&quot;&gt;https://www.runoob.com/python3/python3-conditional-statements.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.runoob.com/python3/python3-loop.html&quot; target=&quot;_blank&quot;&gt;https://www.runoob.com/python3/python3-loop.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 09 Dec 2020 23:48:00 +0000</pubDate>
<dc:creator>dongfanger</dc:creator>
<og:description>条件控制 我们都知道流程图是有多个分支的，程序中也是如此，在Python中是用if语句来判断程序该走哪个分支的。它的执行过程如下： 代码执行过程如下： if if语句的一般形式如下： if condi</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/df888/p/14107867.html</dc:identifier>
</item>
<item>
<title>中间件面试专题：kafka高频面试问题 - Java极客思维</title>
<link>http://www.cnblogs.com/xgx120413/p/14111767.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xgx120413/p/14111767.html</guid>
<description>&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;3&quot;&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/6e696191676991ccbc247c04e4fa7dcd.png&quot; alt=&quot;&quot; class=&quot;cke_widget_element&quot; data-cke-saved-src=&quot;https://img-blog.csdnimg.cn/img_convert/6e696191676991ccbc247c04e4fa7dcd.png&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://mmbiz.qpic.cn/mmbiz_jpg/wM1qhSaKmN5OGTODOQic5GI7jwgTzXf1ySLM7RAAiaxZsFuOVvWGpmxQmIjP2THludNLVDmiazdobnFsDfn5aJ3tQ/640?wx_fmt=jpeg&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:[]}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; width=&quot;15&quot; height=&quot;15&quot; class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;开篇介绍&lt;/p&gt;
&lt;p&gt;大家好，近期会整理一些Java高频面试题分享给小伙伴，也希望看到的小伙伴在找工作过程中能够用得到！本章节主要针对Java一些&lt;strong&gt;消息中间件&lt;/strong&gt;高频面试题进行分享。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;strong&gt;Q1：&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;什么是消息和批次？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        &lt;strong&gt;消息&lt;/strong&gt;，Kafka里的数据单元，也就是我们一般消息中间件里的消息的概念。消息由字节数组组成。消息还可以包含键，用以对消息选取分区。&lt;/p&gt;
&lt;p&gt;为了提高效率，消息被分批写入Kafka。&lt;/p&gt;
&lt;p&gt;        &lt;strong&gt;批次，&lt;/strong&gt;就是一组消息，这些消息属于同一个主题和分区。如果只传递单个消息，会导致大量的网络开销，把消息分成批次传输可以减少这开销。但是，这个需要权衡，批次里包含的消息越多，单位时间内处理的消息就越多，单个消息的传输时间就越长。如果进行压缩，可以提升数据的传输和存储能力，但需要更多的计算处理。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;strong&gt;Q2：&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;什么是主题和分区？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        Kafka的消息用&lt;strong&gt;主题&lt;/strong&gt;进行分类，主题下可以被分为若干个&lt;strong&gt;分区&lt;/strong&gt;。分区本质上是个提交日志，有新消息，这个消息就会以追加的方式写入分区，然后用先入先出的顺序读取。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;1&quot;&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/5a844e6348d6f6eb94f27e294c05ffb1.png&quot; alt=&quot;&quot; class=&quot;cke_widget_element&quot; data-cke-saved-src=&quot;https://img-blog.csdnimg.cn/img_convert/5a844e6348d6f6eb94f27e294c05ffb1.png&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://mmbiz.qpic.cn/mmbiz_png/wM1qhSaKmN5aaliawOf6XgmFicPZibADxLZkyr7c2ADEZ2lZhfzMgF79TFxwTK2eLh1HeDY0sea6OI818mL5PDfibA/640?wx_fmt=png&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:[]}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; width=&quot;15&quot; height=&quot;15&quot; class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;        但是因为主题会有多个分区，所以在整个主题的范围内，是无法保证消息的顺序的，单个分区则可以保证。&lt;/p&gt;
&lt;p&gt;        Kafka通过分区来实现数据冗余和伸缩性，因为分区可以分布在不同的服务器上，那就是说一个主题可以跨越多个服务器。&lt;/p&gt;
&lt;p&gt;        前面我们说Kafka可以看成一个流平台，很多时候，我们会把一个主题的数据看成一个流，不管有多少个分区。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;strong&gt;Q3：&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Kafka中的ISR、AR代表什么？ISR的伸缩指的什么？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ISR是由leader维护，follower从leader同步数据有一些延迟（包括 &lt;strong&gt;延迟时间replica.lag.time.max.ms&lt;/strong&gt; 和 &lt;strong&gt;延迟条数replica.lag.max.message&lt;/strong&gt; 两个维度，当前最新的版本0.10.x中只支持 &lt;strong&gt;replica.lag.time.max.ms&lt;/strong&gt; 这个维度），任意一个超过阈值都会把follower剔除出ISR，存入OSR（Outof-Sync Replicas）列表，新加入的follower也会先存放在OSR中。&lt;/p&gt;
&lt;p&gt;注：AR = ISR + OSR&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;strong&gt;Q4：&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Broker 和 集群&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        一个独立的Kafka服务器叫Broker。broker的主要工作是，接收生产者的消息，设置偏移量，提交消息到磁盘保存；为消费者提供服务，响应请求，返回消息。在合适的硬件上，单个broker可以处理上千个分区和每秒百万级的消息量。&lt;/p&gt;
&lt;p&gt;        多个broker可以组成一个集群。每个集群中broker会选举出一个集群控制器。控制器会进行管理，包括将分区分配给broker和监控broker。&lt;/p&gt;
&lt;p&gt;        集群里，一个分区从属于一个broker，这个broker被称为首领。但是分区可以被分配给多个broker，这个时候会发生分区复制。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;0&quot;&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/5ca7c9b7fadd2d5e6d063c4fc27d914b.png&quot; alt=&quot;&quot; class=&quot;cke_widget_element&quot; data-cke-saved-src=&quot;https://img-blog.csdnimg.cn/img_convert/5ca7c9b7fadd2d5e6d063c4fc27d914b.png&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://mmbiz.qpic.cn/mmbiz_png/wM1qhSaKmN5aaliawOf6XgmFicPZibADxLZyKkznITBibRvjLx2bqvxjAjHic8YaO9wSV32ZG3MY3m1p0TicIRedKo4A/640?wx_fmt=png&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:[]}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; width=&quot;15&quot; height=&quot;15&quot; class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;分区复制带来的好处是，提供了消息冗余。一旦首领broker失效，其他broker可以接管领导权。当然相关的消费者和生产者都要重新连接到新的首领上。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;strong&gt;Q5：&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;kafka中的zookeeper起到什么作用？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        zookeeper是一个分布式的协调组件，早期版本的kafaka用zk做 &lt;strong&gt;meta信息存储&lt;/strong&gt; ， &lt;strong&gt;consumer的消费状态&lt;/strong&gt; ， &lt;strong&gt;group的管理&lt;/strong&gt; 以及 &lt;strong&gt;offset&lt;/strong&gt; 的值。&lt;/p&gt;
&lt;p&gt;        考虑到zk本身的一些因素以及整个架构较大概率存在单点问题，新版本中逐渐弱化了zookeeper的作用。新的consumer使用了kafka内部的 &lt;strong&gt;group coordination&lt;/strong&gt; 协议，也减少了对zookeeper的依赖。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;strong&gt;Q6：&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;kafka follower如何与leader数据同步？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        kafka的复制机制既不是完全的同步复制，也不是单纯的异步复制。&lt;/p&gt;
&lt;p&gt;        完全同步复制要求 &lt;strong&gt;All Alive Follower&lt;/strong&gt; 都复制完，这条消息才会被认为commit，这种复制方式极大的影响了吞吐率。&lt;/p&gt;
&lt;p&gt;        一步复制方式下，Follower异步的从Leader复制数据，数据只要被Leader写入log就被认为已经commit，这种情况下，如果leader挂掉，会丢失数据；&lt;/p&gt;
&lt;p&gt;        kafka使用 &lt;strong&gt;ISR&lt;/strong&gt; 的方式很好的均衡了确保数据不丢失以及吞吐率。Follower可以批量的从Leader复制数据，而且Leader充分利用磁盘顺序读以及 &lt;strong&gt;send file（zero copy）&lt;/strong&gt; 机制，这样极大的提高复制性能，内部批量写磁盘，大幅减少了Follower与Leader的消息量差。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;strong&gt;Q7：&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;kafka中的消息是否会丢失和重复消费？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;消息发送&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;kafka消息发送有两种方式：同步（sync）和异步（async）；&lt;/p&gt;
&lt;p&gt;默认是同步方式，可通过 &lt;strong&gt;producer.type&lt;/strong&gt; 属性进行配置；&lt;/p&gt;
&lt;p&gt;kafka通过配置 &lt;strong&gt;request.required.acks&lt;/strong&gt; 属性来确认消息的生产。&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;0：表示不进行消息接收是否成功的确认；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;1：表示当Leader接收成功时确认；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;-1：表示Leader和Follower都接收成功时确认；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;综上所述，有6种消息产生的情况，消息丢失的场景有：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;acks=0，不和kafka集群进行消息接收确认，则当网络异常、缓冲区满了等情况时，消息可能丢失；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;acks=1、同步模式下，只有Leader确认接收成功后但挂掉了，副本没有同步，数据可能丢失；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;消息消费&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;kafka消息消费有两个consumer接口， &lt;strong&gt;Low-level API&lt;/strong&gt; 和 &lt;strong&gt;High-level API &lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;如果使用高级接口High-level API，可能存在一个问题就是当消息消费者从集群中把消息取出来，并提交了新的消息offset值后，还没来得及消费就挂掉了，那么下次再消费时之前没消费成功的消息就&quot;诡异&quot;的消失了；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方案&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;1 针对消息丢失：同步模式下，确认机制设置为-1，即让消息写入Leader 和 Follower之后再确认消息发送成功；异步模式下，为防止缓冲区满，可以在配置文件设置不限制阻塞超时时间，当缓冲区满时让生产者一直处于阻塞状态。&lt;/p&gt;
&lt;p&gt;2 针对消息重复：将消息的唯一标识保存到外部介质中，每次消费时判断是否处理过即可。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;strong&gt;Q8：&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;kafka为什么不支持读写分离？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在kafka中，生产者写入消息、消费者读取消息的操作都是与Leader副本进行交互的，从而实现的是一种主写主读的生产消费模型。&lt;/p&gt;
&lt;p&gt;kafka并不支持主写从读，因为主写从读有2个很明显的缺点：&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;数据一致性问题&lt;/strong&gt;：数据从主节点转到从节点必然会有一个延时的时间窗口，这个时间窗口会导致主从节点之间的数据不一致。某一时刻，在主节点和从节点中A数据的值都为X，之后将主节点中A的值修改为Y，那么在这个变更通知到从节点之前，应用读取从节点中的A数据的值并不为最新的Y值，由此便产生了数据不一致的问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;延时问题&lt;/strong&gt;：类似Redis这种组件，数据从写入主节点到同步至从节点的过程中需要经历 &lt;strong&gt;网络→主节点内存→网络→从节点内存&lt;/strong&gt; 这几个阶段，整个过程会耗费一定的时间。而在kafka中，主从同步会比Redis更加耗时，它需要经历 &lt;strong&gt;网络→主节点内存→主节点磁盘→网络→从节点内存→从节点磁盘&lt;/strong&gt; 这几个阶段。对延时敏感的应用而言，主写从读的功能场景并不太适用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h2 id=&quot;item-5&quot;&gt;点关注、不迷路&lt;/h2&gt;
&lt;p&gt;如果觉得文章不错，欢迎&lt;strong&gt;关注&lt;/strong&gt;、&lt;strong&gt;点赞&lt;/strong&gt;、&lt;strong&gt;收藏&lt;/strong&gt;，你们的支持是我创作的动力，感谢大家。&lt;/p&gt;
&lt;p&gt;如果文章写的有问题，请不要吝啬，欢迎留言指出，我会及时核查修改。&lt;/p&gt;
&lt;p&gt;如果你还想更加深入的了解我，可以私信我。每天8:00准时推送技术文章，让你的上班路不在孤独，而且每月还有送书活动，助你提升硬实力！&lt;/p&gt;
</description>
<pubDate>Wed, 09 Dec 2020 16:16:00 +0000</pubDate>
<dc:creator>Java极客思维</dc:creator>
<og:description>​ 开篇介绍 大家好，近期会整理一些Java高频面试题分享给小伙伴，也希望看到的小伙伴在找工作过程中能够用得到！本章节主要针对Java一些消息中间件高频面试题进行分享。 Q1： 什么是消息和批次？ 消</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xgx120413/p/14111767.html</dc:identifier>
</item>
<item>
<title>Deep Learning with Differential Privacy - xdroc</title>
<link>http://www.cnblogs.com/xdroc/p/14100114.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xdroc/p/14100114.html</guid>
<description>&lt;p&gt;原文链接：&lt;a title=&quot;Deep Learning with Differential Privacy&quot; href=&quot;https://dl.acm.org/doi/pdf/10.1145/2976749.2978318?download=true&quot; target=&quot;_blank&quot;&gt;Deep Learning with Differential Privacy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;abstract：新的机器学习算法，差分隐私框架下&lt;strong&gt;隐私成本的改良分析&lt;/strong&gt;，使用非凸目标训练深度神经网络。&lt;/p&gt;
&lt;p&gt;数学中最优化问题的一般表述是求取$  x * \in \chi $ 使得 $ f(x * ) = min\{ f(x):x \in \chi \}  $，其中x是n维向量， $  \chi $ &lt;span class=&quot;katex--inline&quot;&gt;&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt; &lt;span class=&quot;katex-html&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot;&gt;&lt;span class=&quot;mord mathdefault&quot;&gt;是x的可行域，f是$ \chi $&lt;span class=&quot;katex--inline&quot;&gt;&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt; &lt;span class=&quot;katex-html&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot;&gt;&lt;span class=&quot;mord mathdefault&quot;&gt;上的实值函数。凸优化问题是指$  \chi $ &lt;span class=&quot;katex--inline&quot;&gt;&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;span class=&quot;katex-html&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot;&gt;&lt;span class=&quot;mord mathdefault&quot;&gt;是闭合的凸集且f是$  \chi $ &lt;span class=&quot;katex--inline&quot;&gt;&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;span class=&quot;katex-html&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot;&gt;&lt;span class=&quot;mord mathdefault&quot;&gt;上的凸函数的最优化问题，这两个条件任一不满足则该问题即为非凸的最优化问题。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Part1 introduction：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们训练模型使用非凸目标、多个层次、上万个参数&lt;br/&gt;相比来说：以往的工作对参数较少的凸模型和隐私损失较大的复杂神经网络都取得了较好的结果&lt;/p&gt;
&lt;p&gt;contribution:&lt;br/&gt;1.&lt;span&gt;&lt;strong&gt;跟踪隐私丢失细节&lt;/strong&gt;&lt;/span&gt;，我们可以从渐进和经验两方面获得对整体隐私损失的更严格的估计。&lt;br/&gt;2.提出独立训练样本计算梯度的高效算法，&lt;span&gt;&lt;strong&gt;任务分成小堆&lt;/strong&gt;&lt;/span&gt;，输入层使用差分隐私策略投影。&lt;br/&gt;3.机器学习框架&lt;strong&gt;&lt;span&gt;TensorFlow建立DP模型&lt;/span&gt;&lt;/strong&gt;，MNIST/CIFAR测试数据集（机器学习公认测试集），在软件复杂度、训练效率和模型质量方面，深度神经网络的隐私保护可以以适当的成本实现。&lt;br/&gt;规范化技术避免对训练样本过拟合。&lt;br/&gt;一个特定的敌手很可能是提取部分训练数据，逆模型攻击（恢复图像）只需要黑盒访问模型&lt;br/&gt;假设敌手对训练机制有完全了解且完全访问模型参数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Part2 Background&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.1差分：&lt;/strong&gt;&lt;br/&gt;相邻数据集的定义 例如，在我们的实验中，每个训练数据集是一组图像-标签对;如果这两个集合在单个项中不同，也就是说，如果一个图像-标签对存在于一个集合中，而另一个集合中不存在，我们就说它们是相邻的。&lt;br/&gt;Dierential隐私有几个特性:&lt;strong&gt;&lt;span&gt;可组合性、组隐私和对辅助信息的健壮性&lt;/span&gt;&lt;/strong&gt;。&lt;br/&gt;组隐私意味着如果数据集包含相关的输入，比如由同一个人提供的输入，隐私保证的完美减低。&lt;br/&gt;对辅助信息的鲁棒性是指隐私保证不受对手可用的任何辅助信息的影响。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;preliminary：设计一个差分隐私额外噪声机制的基本流程：&lt;br/&gt;1.通过限定敏感度函数的顺序组合逼近函数性。&lt;br/&gt;2.选择额外噪声的参数。&lt;br/&gt;3.执行隐私分析的结果机制。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.2深度学习：&lt;/strong&gt;&lt;br/&gt;深度神经网络，在许多机器学习任务中非常有效，定义从输入到输出的参数化函数为许多基础模块的组合，比如仿射转换和简单的非线性函数，后者常用的例子是S型和改正线型单元。通过改变这些模块的参数，我们可以训练一个参数化函数，这个函数的目的是适应任何给定的有限输入输出例子。&lt;br/&gt;我们定义了一个损失函数，表征与训练数据不匹配的惩罚。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2239105/202012/2239105-20201208212554698-395925783.png&quot; alt=&quot;&quot; width=&quot;129&quot; height=&quot;17&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;训练包含寻找到θ，产生可接受的最小损失。&lt;br/&gt;the minimization is often done by the mini-batch stochastic gradient descent(SGD) algorithm.&lt;br/&gt;在这个算法中，每一步生成一组随机数，并计算梯度。然后θ根据梯度方向更新，直到损失函数达到局部最小。&lt;br/&gt;我们的工作基于TensorFlow，一个谷歌发布的开源数据流引擎。TensorFlow允许程序员从基本运算符定义大型计算图，并在异构的分布式系统中分布它们的执行。TensorFlow自动创建梯度的计算图形;它还使批处理计算变得容易。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.Our Approach&lt;/strong&gt;&lt;br/&gt;本节描述了我们对神经网络进行差分私有训练的方法的主要组成部分：&lt;strong&gt;&lt;span&gt;差分私有随机梯度下降（SGD）算法，矩阵计算和超参数调整&lt;/span&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.1 Differentially Private SGD Algorithm&lt;/strong&gt;&lt;br/&gt;人们试图保护训练数据，通过仅仅对最终参数工作，视整个过程为黑盒子，但是没有对这些参数对训练数据依赖性有用准确的定义&lt;br/&gt;对参数加入过度保守的噪声，这些噪声根据最差情况选择，会破坏学习模型的实用性。因此，我们选择更加精细的方法，旨在控制训练过程中训练数据的影响，特别是在SGD的计算中。&lt;/p&gt;
&lt;p&gt;算法实现：剪切每个梯度的L2范数，计算平均值，添加噪声以保护隐私。然后对此平均噪声梯度逆梯度操作一步。最后，除了提出模型，我们计算根据隐私计算的隐私损失。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/2239105/202012/2239105-20201208214309176-1221621699.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 标准裁剪：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/2239105/202012/2239105-20201208215425634-1487778704.png&quot; alt=&quot;&quot; width=&quot;399&quot; height=&quot;23&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;出于非隐私原因，对于深层网络，此形式的梯度裁剪是SGD的一种流行成分，尽管在这种情况下，通常取平均值后就足以裁剪。&lt;/p&gt;

&lt;p&gt; 每层与时间相关参数：&lt;br/&gt;算法的伪代码将所有参数放在损失函数$ \mathcal{L} (\cdot)$的输出$ \theta $，&lt;br/&gt;对于多层次神经网络我们分别考虑每个层次，允许设置不同的阈值和噪声范围&lt;br/&gt;削减和噪声参数随着训练步骤t不同&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分组Lots：&lt;br/&gt;&lt;/strong&gt;像普通的SGD算法一样，本算法通过计算一组例子的梯度并取平均估算L的梯度。这个平均值提供了一个无偏差的估算值，它的变化随着数据量的增加迅速减少。我们称这个组合为lot，与通常的计算组合batch区别开。&lt;br/&gt;为了限制内存消耗，我们设置batch的容量远小于lot，batch是算法的参量。我们对batch进行计算，然后将batch放在一个lot中为了添加噪声。&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;隐私计算：&lt;/strong&gt;&lt;br/&gt;差分隐私的可组合性允许我们执行可累加过程：先计算每种到达训练数据的方式的隐私，然后将这些隐私累加作为训练过程。&lt;br/&gt;训练的每一步骤要求多个层次的梯度，然后计算器累加对应于它们的所有成本。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Moments accountant:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于特定噪声分布下的隐私损失以及隐私损失的构成进行了大量的研究&lt;br/&gt;产生最佳整体限制的结果是强组合理论&lt;br/&gt;强组合理论可能是不准确的，无法将特殊噪声分布纳入考虑&lt;br/&gt;这允许我们证明该算法1是差分隐私的，如果选择合适的噪声范围和削减阈值。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2239105/202012/2239105-20201208221617837-412959298.png&quot; alt=&quot;&quot; width=&quot;407&quot; height=&quot;119&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt; 3.2 The Moments Accountant: Details&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 时刻计算追踪隐私损失随机变量，它概括了追踪（ε，δ）的传统方法和使用强组合理论&lt;br/&gt;直接从它组合可能导致结果是松的。我们转而计算隐私损失随机变量时刻的log，这是线性组合的&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2239105/202012/2239105-20201208221905285-2010880481.png&quot; alt=&quot;&quot; width=&quot;381&quot; height=&quot;89&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 一个普遍的设计方法是更新状态，通过有序的运用差分隐私机制&lt;br/&gt;前一个机制的输出作为下一个的附加输入。&lt;/p&gt;


&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/2239105/202012/2239105-20201208222047208-2003840519.png&quot; alt=&quot;&quot; width=&quot;454&quot; height=&quot;264&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/2239105/202012/2239105-20201208222212148-2137714254.png&quot; alt=&quot;&quot; width=&quot;443&quot; height=&quot;252&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;当机制本身根据前一个机制的(公共)输出选择时，保持不变&lt;/p&gt;
&lt;p&gt; 3.3 Hyperparameter Tuning&lt;br/&gt;我们可以调节的超参数，从而平衡隐私、准确性和性能。&lt;br/&gt;我们发现对于神经网络模型结构的准确性对训练参数更敏感，比如batch的容量、噪声水平&lt;br/&gt;凸目标函数的差分隐私优化是使用小到1的批处理大小来最佳实现的，非凸学习本身固有的稳定性较差，这受益于聚集成较大的Batch。&lt;br/&gt;当模型收敛到局部最优时，非私有训练中的学习率通常会向下调整。&lt;br/&gt;我们永远不需要把学习率降低到一个很小的值，因为从本质上讲，差分隐私训练永远不会达到一个需要被判断的领域。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Part4.implementation&lt;br/&gt;&lt;/strong&gt;我们需要在使用梯度去更新参数前对它们进行清洗&lt;br/&gt;我们需要根据清洗是如何完成的来跟踪隐私成本&lt;br/&gt;因此，我们的实现主要由两个组件组成:sanitizer和privacy_accountant，前者对梯度进行预处理以保护隐私，后者在训练过程中跟踪隐私开销。&lt;/p&gt;
&lt;p&gt;在许多情况下，神经网络模型可以通过将输入投影在主方向（PCA）上或通过卷积层进行输入来从输入处理中受益。 我们实施差分私有PCA，并应用预训练的卷积层（从公共数据中学到）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Sanitizer：&lt;br/&gt;&lt;/strong&gt;执行两个操作：&lt;span&gt;通过裁剪每个示例的梯度范数来限制每个示例的灵敏度&lt;/span&gt;;&lt;span&gt;在更新网络参数之前，将噪声添加到一批的梯度中。&lt;br/&gt;&lt;span&gt;我们当前的实现支持损失函数L的bacthed计算，其中每个xi都单独连接到L，允许我们处理大多数隐藏层，但不能处理卷积层。&lt;br/&gt;一旦我们能够访问每个示例的梯度，就很容易使用TensorFlow操作符来剪辑它的范数和添加噪声。&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;Privacy accountant：&lt;/strong&gt;&lt;br/&gt;我们实施的主要组成部分是PrivacyAccountant，它在训练过程中跟踪隐私开销。&lt;br/&gt;第一种方法恢复了一般的高级组合定理，后两种方法对隐私损失进行了更准确的计算。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;根据Theorem2.2在训练期间的任何时候，都可以使用(epslion，delta)隐私更可解释的概念查询隐私损失.&lt;br/&gt;我们通过提前确定迭代次数和隐私参数，避免他们的攻击和负面结果。隐私计算的更一般实现必须正确区分作为隐私距离或隐私过滤器的两种操作模式&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Differentially private PCA:&lt;/strong&gt;Principal component analysis(PCA) is a useful method for capturing the main features of the input data.&lt;br/&gt;捕获输入数据的主要特征的有用方法&lt;br/&gt;We take a random sample of the training examples, treat them as vectors, and normalize each vector to unit l2 norm to form the matrix A, where each vector is a row in the matrix. We then add Gaussian noise to the covariance matrix A&lt;sup&gt;T&lt;/sup&gt;A and compute the principal directions of the noisy covariance matrix.&lt;br/&gt;Then for each input example we apply the projection to these principal directions before feeding it into the neural network.&lt;br/&gt;我们从训练样本中随机抽取一个样本，将它们视为向量，然后将每个向量归一化为2范数以形成矩阵A，其中每个向量都是矩阵中的一行。 然后，我们将高斯噪声添加到协方差矩阵A&lt;sup&gt;T&lt;/sup&gt;A并计算有噪协方差矩阵的主要方向。&lt;br/&gt;然后，对于每个输入示例，我们将投影应用于这些主要方向，然后再将其提供给神经网络。&lt;/p&gt;
&lt;p&gt;由于运行PCA，我们产生了隐私成本。然而，我们发现它对于提高模型质量和减少训练时间都是有用的，正如我们在MNIST数据上的实验所表明的那样。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Convolutional layers：&lt;/strong&gt;&lt;br/&gt;卷积层对深度神经网络很有用。然而,一个有效的per-example梯度计算卷积层TensorFlow框架内仍然是一个挑战,它激励创建一个单独的工作。例如，最近的一些研究表明，即使是随机的卷积也满足。&lt;/p&gt;
&lt;p&gt;另外，我们遵循Jarrett等人的观点探索在公共数据上学习卷积层的想法。 这样的卷积层可以基于用于图像模型的GoogLeNet或AlexNet功能，或者基于语言模型中的预训练word2vec或GloVe嵌入&lt;/p&gt;
&lt;p&gt;Part5 Experiment Results&lt;br/&gt;&lt;strong&gt;Part6 Related Work&lt;/strong&gt;&lt;br/&gt;现有的文献可以沿着几个轴进行广泛的分类:模型的类别、学习算法和隐私保证。&lt;br/&gt;&lt;strong&gt;Privacy guarantees&lt;/strong&gt;&lt;br/&gt;隐私保护学习的早期研究是在安全函数评估的框架下进行的(SFE)和安全多方计算(MPC)，其中输入在两个或更多方之间分割，重点是使在某些已达成共识的功能的联合计算过程中泄漏的信息最小化。 相反，我们假设数据集中保存，并且我们担心功能输出（模型）的泄漏。&lt;/p&gt;
&lt;p&gt;另一种方法是k-匿名性和紧密相关的概念[53]，它试图通过归纳和抑制某些识别属性来对基础数据提供一定程度的保护。该方法具有很强的理论和经验限制[4，9]，这使其几乎不适用于高维，多样化输入数据集的去匿名化。与其保持输入原始状态不变，我们不破坏基础原始记录，而扰乱派生数据。&lt;br/&gt;差分隐私理论为我们的工作提供了分析框架，已被应用于大量的机器学习任务，这些任务在训练机制或目标模型上都与我们的不同。&lt;br/&gt;moments accountant与R'enyi差异隐私概念密切相关[42]，后者提出了（定标）α（λ）作为量化隐私保证的一种手段。在并发且独立的工作中，Bun和Steinke [10]通过α（λ）的线性上限定义了放宽的差分隐私（概括了Dwork和Rothblum [20]的工作），这些工作证明了moments accountant是一种用于复杂隐私保护算法的理论和实证分析的有用技术。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Learning algorithm&lt;/strong&gt;&lt;br/&gt;隐私学习的一个共同目标是一类可应用多种技术的凸优化问题。&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;在并行工作中，Wu等人通过凸经验风险最小化在MNIST上实现了83%的准确率。&lt;br/&gt;多层神经网络的训练是非凸的，通常通过SGD的应用来解决，其理论保证很少被理解。&lt;br/&gt;对于CIFAR神经网络，我们分别对主成分分析投影矩阵[23]进行私有训练，用于降低输入的维数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Model class&lt;/strong&gt;&lt;br/&gt;第一个端到端的差分隐私系统评估在Netflix Prize数据集[39],一个版本的协同过滤的问题。&lt;br/&gt;尽管该问题与我们的高维输入有很多相似之处，但非凸目标函数的使用由McSherry和Mironov所采用的方法明显不同。 他们确定了学习任务的核心，即有效的足够的统计数据，可以通过高斯机制以差分隐私的方式进行计算。 在我们的方法中，没有足够的统计数据。&lt;/p&gt;
&lt;p&gt;在最近的工作中，Shokri和Shmatikov [50]设计和评估了用于深度神经网络的&lt;strong&gt;分布式训练&lt;/strong&gt;的系统。 紧密保持数据的参与者将经过sanitized处理的更新传达给central authority。 sanitization依赖于基于敏感性估计的加性噪声机制，可以将其改进为硬性敏感性保证。 他们计算每个参数的隐私损失（不适用于整个模型）。 按着我们的标准，MNIST数据集上每个参与者的总隐私损失超过数千。&lt;/p&gt;
&lt;p&gt; Phan等人[45]探讨了另一种最新的差分隐私深度学习方法。这项工作的重点是学习自动编码器。隐私是基于干扰这些自动编码器的目标函数。&lt;/p&gt;
</description>
<pubDate>Wed, 09 Dec 2020 15:40:00 +0000</pubDate>
<dc:creator>xdroc</dc:creator>
<og:description>原文链接：Deep Learning with Differential Privacy abstract：新的机器学习算法，差分隐私框架下隐私成本的改良分析，使用非凸目标训练深度神经网络。 数学中最</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xdroc/p/14100114.html</dc:identifier>
</item>
<item>
<title>认识 Cargo-Rust构建工具和包管理器 - Angel_L</title>
<link>http://www.cnblogs.com/angell-N/p/14111604.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/angell-N/p/14111604.html</guid>
<description>&lt;blockquote readability=&quot;6.626334519573&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/KA1EzMpSYAdGQUHV1F71tA&quot; target=&quot;_blank&quot;&gt;上两篇文章&lt;/a&gt; 都有说到 hello world 程序，但是我们如果使用自己创建文件的方式创建项目，一旦文件多了，那得多麻烦，整个项目将变得难以管理。下面我来介绍和实际使用一下 Rust 的构建工具和包管理工具 - Cargo ！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;验证-cargo-是否安装&quot;&gt;验证 Cargo 是否安装&lt;/h2&gt;
&lt;p&gt;如果你是通过本号的文章开始的配置 Rust 开发环境，那么进入 cmd 控制台，输入&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cargo --version
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;验证 Cargo 是否安装了，如下图输出了 Cargo 的版本号，祝贺你，你的电脑已经安装好了 cargo 了。如果没有安装好，可以查看上次文章安装，再有问题可辽我。&lt;br/&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/filess/img0@main/2020/12/09/1607523830882-60c98364-ee96-4385-b2eb-1b8bd29f9502.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;使用-cargo-创建项目&quot;&gt;使用 Cargo 创建项目&lt;/h2&gt;
&lt;h3 id=&quot;新建&quot;&gt;新建&lt;/h3&gt;
&lt;p&gt;打开 vs code ide 开发工具，打开控制台，输入&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;工具栏找到 Terminal &amp;gt; New Terminal
// 输入
cargo new hello_cargo
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/filess/img14@main/2020/12/09/1607524704861-1f443998-1714-4c8c-9351-6c6268938ce4.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如图，我们已经成功的使用 cargo 创建了一个完整的 Rust 项目。&lt;br/&gt;下面使用 vs code 打开刚刚创建的 hello_cargo 项目，里面包含了&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;src 文件夹：用来存放源码
&lt;ul&gt;&lt;li&gt;main.rs: 源码&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;.gitignore 文件： 里面可以配置 Git 提交代码时需要忽略的文件（不上传）&lt;/li&gt;
&lt;li&gt;Cargo.toml 文件：这里面是 cargo 管理项目的配置信息&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/filess/img11@main/2020/12/09/1607524937751-d6cd71e4-67a6-4ec9-b4b2-ef8fe87abacf.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;编译&quot;&gt;编译&lt;/h3&gt;
&lt;p&gt;在控制台使用命令“cd”进入刚刚创建的 hello_cargo 文件夹，然后输入&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 进入 hello_cargo 文件夹
cd hello_cargo
// 输入命令构建项目
cargo build
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;构建 hello_cargo 项目。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/filess/img18@main/2020/12/09/1607526306808-566b39e7-be3c-42c5-9019-6057e66bd366.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在构建完成项目后，在 hello_cargo 文件夹下面自动生成了 target 文件夹，里面存放的就是构建出来的文件了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/filess/img19@main/2020/12/09/1607526425868-cea12e3a-e386-47e3-b21c-051210461bb3.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们打开 target 文件夹下面的 debug 文件夹就可以看到和之前使用 cmd 控制台输入 rustc 命令生成的可执行文件一样。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/filess/img14@main/2020/12/09/1607526555875-ead20875-3016-461a-b72c-bfa82bd17439.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;运行&quot;&gt;运行&lt;/h3&gt;
&lt;p&gt;下面我们来运行 hello_cargo 项目，输入命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cargo run
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/filess/img3@main/2020/12/09/1607526677886-1d4304c0-6a45-447b-b1a6-e54a5ba9dd20.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如图，我们可以看到正确的输出了 “Hello，world！”。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;使用 cargo 创建项目可以节省我们的很多时间，同时最主要的还是 cargo 帮助我们管理项目，减少了维护项目的成本和精力，让我们更加专注于开发。&lt;br/&gt;几个主要命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cargo new 
cargo build
cargo check
cargo run
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 09 Dec 2020 15:30:00 +0000</pubDate>
<dc:creator>Angel_L</dc:creator>
<og:description>认识 Cargo-Rust构建工具和包管理器 上两篇文章 都有说到 hello world 程序，但是我们如果使用自己创建文件的方式创建项目，一旦文件多了，那得多麻烦，整个项目将变得难以管理。下面我来</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/angell-N/p/14111604.html</dc:identifier>
</item>
</channel>
</rss>