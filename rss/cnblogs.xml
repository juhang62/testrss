<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>ReentrantLock之公平锁源码分析 - Pedlar</title>
<link>http://www.cnblogs.com/pedlar/p/10731516.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pedlar/p/10731516.html</guid>
<description>&lt;p&gt;　　本文分析的ReentrantLock所对应的Java版本为JDK8。&lt;/p&gt;
&lt;p&gt;　　在阅读本文前，读者应该知道什么是CAS、自旋。&lt;/p&gt;
&lt;h2&gt;本文大纲&lt;/h2&gt;
&lt;p&gt;　　1.&lt;a href=&quot;http://www.cnblogs.com/pedlar/p/10731516.html#p1&quot;&gt;ReentrantLock简介&lt;/a&gt;&lt;br/&gt;　　2.&lt;a href=&quot;http://www.cnblogs.com/pedlar/p/10731516.html#p2&quot;&gt;AQS&lt;/a&gt;&lt;br/&gt;　　3.&lt;a href=&quot;http://www.cnblogs.com/pedlar/p/10731516.html#p3&quot;&gt;lock方法&lt;/a&gt;&lt;br/&gt;　　4.&lt;a href=&quot;http://www.cnblogs.com/pedlar/p/10731516.html#p4&quot;&gt;unlock方法&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;1. ReentrantLock简介&lt;/h2&gt;
&lt;p&gt;　　ReentrantLock是JUC（java.util.concurrent）包中Lock接口的一个实现类，它是基于AbstractQueuedSynchronizer（下文简称AQS）来实现锁的功能。ReentrantLock的内部类Sync继承了AbstractQueuedSynchronizer，Sync又有FairSync和NonFairSync两个子类。FairSync实现了公平锁相关的操作，NonFairSync实现了非公平锁相关的操作。它们之间的关系如下：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1439038/201904/1439038-20190419145547003-1078781413.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　本文将分析ReentrantLock的公平锁，下面这段代码展示了公平锁的使用方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Lock lock = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReentrantLock(true);

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; method() {
     lock.lock();  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; block until condition holds&lt;/span&gt;
     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ... method body&lt;/span&gt;
     } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
       lock.unlock();
     }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2. AQS&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;2.1 Node&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　AQS中，维护了一个Node内部类，用于包装我们的线程。我们需要关注Node中的如下属性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;　　&lt;strong&gt;pre&lt;/strong&gt;：当前节点的前驱节点。&lt;/li&gt;
&lt;li&gt;　　&lt;strong&gt;next&lt;/strong&gt;：当前节点的后继节点。&lt;/li&gt;
&lt;li&gt;　　&lt;strong&gt;thread&lt;/strong&gt;：thread表示需要被包装的线程。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;　　waitStatus&lt;/strong&gt;：waitStatus是一个int整型，可以被赋予如下几种值：&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; CANCELLED =  1; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 线程被取消&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; SIGNAL  = -1; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 后继节点中的线程需要被唤醒&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; CONDITION = -2; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 暂不关注&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; PROPAGATE = -3; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 暂不关注&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　另外，当一个新的Node被创建时，waitStatus是0。&lt;/p&gt;
&lt;h3&gt;2.2 head&lt;/h3&gt;
&lt;p&gt;　　head指向队列中的队首元素，可以理解为当前持有锁的线程。&lt;/p&gt;
&lt;h3&gt;2.3 tail&lt;/h3&gt;
&lt;p&gt;　　tail指向队列中的队尾元素。&lt;/p&gt;
&lt;h3&gt;2.4 state&lt;/h3&gt;
&lt;p&gt;　　state表示锁的状态，0表示当前锁没有被占用，大于0的数表示锁被当前线程重入的次数。例如，当state等于2时，表示当前线程在这把锁上进入了两次。&lt;/p&gt;
&lt;h3&gt;2.5 exclusiveOwnerThread&lt;/h3&gt;
&lt;p&gt;　　表示当前占用锁的线程。&lt;/p&gt;
&lt;h3&gt;2.6 等待队列&lt;/h3&gt;
&lt;p&gt;　　下图简单展示了AQS中的等待队列：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1439038/201904/1439038-20190419110421003-490740387.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;3. lock方法&lt;/h2&gt;
&lt;p&gt;　　有了上面的AQS的基础知识后，我们就可以展开对ReentrantLock公平锁的分析了，先从lock方法入手。&lt;/p&gt;
&lt;p&gt;　　ReentrantLock中的lock方法很简单，只是调用了Sync类（本文研究公平锁，所以应该是FairSync类）中的lock方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; lock() {
    sync.lock();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　我们跟到FairSync的lock方法，代码也很简单，调用了AQS中的acquire方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; lock() {
    acquire(&lt;/span&gt;1&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　acquire方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; acquire(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; arg) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!tryAcquire(arg) &amp;amp;&amp;amp; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用tryAcquire尝试去获取锁，如果获取成功，则方法结束&lt;/span&gt;
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果获取锁失败，执行acquireQueued方法，将把当前线程排入队尾&lt;/span&gt;
&lt;span&gt;        selfInterrupt();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　tryAcquire方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; tryAcquire(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; acquires) {
    &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Thread current =&lt;span&gt; Thread.currentThread();
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; c = getState(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取锁的状态&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (c == 0) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果状态是0，表示锁没有被占用&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (!hasQueuedPredecessors() &amp;amp;&amp;amp; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断是队列中是否有排队中的线程&lt;/span&gt;
            compareAndSetState(0, acquires)) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 队列中没有排队的线程，则尝试用CAS去获取一下锁&lt;/span&gt;
            setExclusiveOwnerThread(current); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取锁成功，则将当前占有锁的线程设置为当前线程&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 锁被占用、队列中有排队的线程或者当前线程在获取锁的时候失败将执行下面的代码&lt;/span&gt;
    &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (current == getExclusiveOwnerThread()) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当前线程是否是占有锁的线程&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; nextc = c + acquires; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 是的话，表示当前线程是重入这把锁，将锁的状态进行加1&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (nextc &amp;lt; 0&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Error(&quot;Maximum lock count exceeded&quot;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 锁的重入次数超过int能够表示最大的值，抛出异常&lt;/span&gt;
        setState(nextc); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置锁的状态&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 没有获取到锁&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　hasQueuedPredecessors方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; hasQueuedPredecessors() {
    Node t &lt;/span&gt;=&lt;span&gt; tail;
    Node h &lt;/span&gt;=&lt;span&gt; head;
    Node s;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; h != t &amp;amp;&amp;amp; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 队列中的队首和队尾元素不相同&lt;/span&gt;
        ((s = h.next) == &lt;span&gt;null&lt;/span&gt; || s.thread != Thread.currentThread()); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 队列中的第二个元素不为null，且第二个元素中的线程不是当前线程&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　如果tryAcquire没有获取到锁，将执行：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
acquireQueued(addWaiter(Node.EXCLUSIVE), arg)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我们先分析addWaiter方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Node addWaiter(Node mode) {
    Node node &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Node(Thread.currentThread(), mode); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将当前线程包装成Node，mode参数值为null，表示独占模式
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Try the fast path of enq; backup to full enq on failure&lt;/span&gt;
    Node pred =&lt;span&gt; tail;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (pred != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        node.prev &lt;/span&gt;= pred; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果队列中的尾节点不为空，将当前node的前驱节点设置为之前队列中的tail&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (compareAndSetTail(pred, node)) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用CAS把当前node设置为队尾元素&lt;/span&gt;
            pred.next = node; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 成功的话，则将之前队尾元素的后继节点设置为当前节点。如果这里不清楚的话，请结合前面讲等待队列的那张图进行理解。&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; node;
        }
    }
    enq(node); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 队尾节点为空，或者用CAS设置队尾元素失败，则用自旋的方式入队&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; node;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　enq方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; Node enq(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; Node node) {
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
        Node t &lt;/span&gt;=&lt;span&gt; tail;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (t == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (compareAndSetHead(&lt;span&gt;new&lt;/span&gt; Node())) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 队尾元素为空，创建一个空的Node，并设置为队首&lt;/span&gt;
                tail = head; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置队首和队尾为同一个空Node，进入下一次循环&lt;/span&gt;
        } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            node.prev &lt;/span&gt;= t; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果队列中的尾节点不为空，将当前node的前驱节点设置为之前队列中的tail&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (compareAndSetTail(t, node)) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用CAS把当前node设置为队尾元素&lt;/span&gt;
                t.next = node; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 成功的话，则将之前队尾元素的后继节点设置为当前节点&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt; t;
&lt;span&gt;            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　下面这张图反应了上面enq方法的处理流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1439038/201904/1439038-20190419123501490-49345016.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　经过上面的方法，当前node已经加入等待队列的队尾，接下来将执行acquireQueued方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; acquireQueued(&lt;span&gt;final&lt;/span&gt; Node node, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; arg) {
    &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; failed = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; interrupted = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
            &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Node p = node.predecessor(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取node的前驱节点&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (p == head &amp;amp;&amp;amp; tryAcquire(arg)) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果node的前驱是head，它将去尝试获取锁（tryAcquire方法在前面已经分析过）&lt;/span&gt;
                setHead(node); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取成功，则将node设置为head&lt;/span&gt;
                p.next = &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将之前的head的后继节点置空&lt;/span&gt;
                failed = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; interrupted;
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当前node的前驱不是head，将为当前node找到一个能够将其唤醒的前驱节点；或者当前node的前驱是head，但是获取锁失败&lt;/span&gt;
                parkAndCheckInterrupt()) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将当前线程挂起&lt;/span&gt;
                interrupted = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }
    } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (failed)
            cancelAcquire(node);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　shouldParkAfterFailedAcquire方法的作用就是找到一个能够唤醒当前node的节点：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; shouldParkAfterFailedAcquire(Node pred, Node node) {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; ws = pred.waitStatus; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 开始时是0&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (ws ==&lt;span&gt; Node.SIGNAL)
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
         * This node has already set status asking a release
         * to signal it, so it can safely park.
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 前驱节点的状态是-1，会唤醒后继节点，可以将线程挂起&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (ws &amp;gt; 0&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
         * Predecessor was cancelled. Skip over predecessors and
         * indicate retry.
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;do&lt;/span&gt;&lt;span&gt; {
            node.prev &lt;/span&gt;= pred = pred.prev; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 前驱节点中的线程被取消，那就需要一直循环直到找到一个没有被设置为取消状态的前驱节点&lt;/span&gt;
        } &lt;span&gt;while&lt;/span&gt; (pred.waitStatus &amp;gt; 0&lt;span&gt;);
        pred.next &lt;/span&gt;= node; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从后向前找，将第一个非取消状态的节点，设置这个节点的后继节点设置为当前node&lt;/span&gt;
    } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
         * waitStatus must be 0 or PROPAGATE.  Indicate that we
         * need a signal, but don't park yet.  Caller will need to
         * retry to make sure it cannot acquire before parking.
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        compareAndSetWaitStatus(pred, ws, Node.SIGNAL); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; waitStatus是0或者-3的时候，这时waitStatus都将被设置为-1
                                                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 即后继节点需要前驱节点唤醒&lt;/span&gt;
&lt;span&gt;    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 上层代码再进行一次循环，下次进入此方法时，将进入第一个if条件&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　找到了合适的前驱节点，parkAndCheckInterrupt方法当前线程挂起：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; parkAndCheckInterrupt() { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将线程挂起，等待前驱节点的唤醒&lt;/span&gt;
    LockSupport.park(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Thread.interrupted();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt; 4. unlock方法&lt;/h2&gt;
&lt;p&gt;　　ReentrantLock的unlock方法调用AQS中的release方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; unlock() {
    sync.release(&lt;/span&gt;1); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用AQS的release方法&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　release方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; release(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; arg) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tryRelease(arg)) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 尝试去释放锁&lt;/span&gt;
        Node h =&lt;span&gt; head;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (h != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; h.waitStatus != 0&lt;span&gt;)
            unparkSuccessor(h); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 释放锁成功，head不为空，并且head的waitStatus不为0的情况下，将唤醒后继节点&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　tryRelease方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; tryRelease(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; releases) {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; c = getState() - releases; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将锁的状态减1&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (Thread.currentThread() !=&lt;span&gt; getExclusiveOwnerThread())
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalMonitorStateException(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 准备释放锁的线程不是持有锁的线程，抛出异常&lt;/span&gt;
    &lt;span&gt;boolean&lt;/span&gt; free = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (c == 0&lt;span&gt;) {
        free &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 锁的状态是0，说明不存在重入的情况了，可以直接释放了&lt;/span&gt;
        setExclusiveOwnerThread(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
    }
    setState(c);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; free;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　锁释放成功，将唤醒后继节点，unparkSuccessor方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; unparkSuccessor(Node node) {
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
     * If status is negative (i.e., possibly needing signal) try
     * to clear in anticipation of signalling.  It is OK if this
     * fails or if status is changed by waiting thread.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; ws = node.waitStatus; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注意，这个node是head节点&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (ws &amp;lt; 0&lt;span&gt;)
        compareAndSetWaitStatus(node, ws, &lt;/span&gt;0); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当前node的状态是小于0，将其状态设置为0&lt;/span&gt;

    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
     * Thread to unpark is held in successor, which is normally
     * just the next node.  But if cancelled or apparently null,
     * traverse backwards from tail to find the actual
     * non-cancelled successor.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    Node s &lt;/span&gt;= node.next; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; head节点的后继节点&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (s == &lt;span&gt;null&lt;/span&gt; || s.waitStatus &amp;gt; 0&lt;span&gt;) {
        s &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行到这表示head的后继节点是-1，处于取消的状态&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (Node t = tail; t != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; t != node; t =&lt;span&gt; t.prev)
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (t.waitStatus &amp;lt;= 0&lt;span&gt;)
                s &lt;/span&gt;= t; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从等待队列的尾部向前找，找到倒序的最后一个处于非取消状态的节点&lt;/span&gt;
&lt;span&gt;    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (s != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
        LockSupport.unpark(s.thread); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 唤醒head后面的处于非取消状态的第一个（顺序）节点&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　到此，全文结束，大家看代码的时候结合图来理解会容易很多。&lt;/p&gt;
</description>
<pubDate>Fri, 19 Apr 2019 07:14:00 +0000</pubDate>
<dc:creator>Pedlar</dc:creator>
<og:description>本文分析的ReentrantLock所对应的Java版本为JDK8。 在阅读本文前，读者应该知道什么是CAS、自旋。 本文大纲 1.ReentrantLock简介 2.AQS 3.lock方法 4.u</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pedlar/p/10731516.html</dc:identifier>
</item>
<item>
<title>MongoDB从入门到优化 - 自由早晚乱余生</title>
<link>http://www.cnblogs.com/operationhome/p/10734659.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/operationhome/p/10734659.html</guid>
<description>&lt;h3 id=&quot;一mongodb-简介&quot;&gt;一、MongoDB 简介&lt;/h3&gt;
&lt;p&gt;本文的内容是基于 &lt;code&gt;MongoDB 4.0&lt;/code&gt; 的。 参考于 &lt;code&gt;MongoDB 4.0&lt;/code&gt; 官方文档。&lt;/p&gt;
&lt;p&gt;​ MongoDB 是由&lt;code&gt;C++&lt;/code&gt;语言编写的，是一个基于分布式文件存储的开源数据库系统。属于 &lt;code&gt;nosql&lt;/code&gt; 数据库。MongoDB 数据库中最小的数据单元是文档，它是由 key 和 value 组成的数据结构， MongoDB 文档类似于 JSON 对象。value 的值可以是数组、字符串、数值、文档。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://docs.mongodb.com/manual/_images/crud-annotated-document.bakedsvg.svg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;主要优点&quot;&gt;主要优点&lt;/h4&gt;
&lt;p&gt;​ 支持多语言、高性能、丰富的查询语言、高可用性、可扩展、支持多个储存引擎、高效存储二进制大对象 (比如照片和视频)。&lt;/p&gt;
&lt;p&gt;4.0版本的优势：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;MongoDB 4.0版将文档模型的速度，灵活性和功能与ACID保证相结合。&lt;/li&gt;
&lt;li&gt;MongoDB 4.0版借助事务特性，使得备节点不再因为同步日志而阻塞读取请求。&lt;/li&gt;
&lt;li&gt;MongoDB 4.0版提供并发的读取和写入能力，使得新增分片shard迁移性能提升了约 40%， 新增节点能更快的承载业务压力。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;MongoDB 与 mysql 对比&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;6.5&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&lt;strong&gt;database&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;database&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;&lt;strong&gt;table&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;collection&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;row&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;document or BSON document&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;&lt;strong&gt;column&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;field&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&lt;strong&gt;index&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;index&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;table joins&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;embedded documents and linking&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;&lt;strong&gt;primary keySpecify any unique column orcolumn combination asprimary key.&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;primary keyIn MongoDB, the primary key isautomatically set to the _id field.&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&lt;strong&gt;aggregation (e.g. group by)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;aggregation pipelineSee the SQL to Aggregation MappingChart.&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;应用场景&quot;&gt;应用场景&lt;/h4&gt;
&lt;p&gt;位置查询的移动类APP，储存数据结构易变化的数据。&lt;/p&gt;
&lt;p&gt;电商后台(商品更新记录,会员每天虚拟币余额(定时获取)，会员账号信息，订单信息等等) 。&lt;/p&gt;
&lt;p&gt;储存用户发表的朋友圈。&lt;/p&gt;
&lt;p&gt;储存直播行业的用户信息、礼物信息以及日志等信息，同时可通过丰富的聚合查询来进行业务分析。&lt;/p&gt;
&lt;h3 id=&quot;二mongodb-的储存引擎&quot;&gt;二、MongoDB 的储存引擎&lt;/h3&gt;
&lt;p&gt;MongoDB 有三大储存引擎，分别是 WiredTiger 、In-Memory 、MMAPv1。&lt;/p&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;WiredTiger&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;是MongoDB 3.2 中的默认储存引擎，是多线程的，它适合大多数的工程场景，支持文档级别的并发，压缩等功能，官方建议使用该储存引擎。在3.6版本后 WiredTiger 每60s将数据写入到磁盘，在下一次写入成功前，本次节点的数据仍然有效。当发生故障时，MongoDB 可以从最后的一次成功写入进行恢复。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;In-Memory&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;In-Memory 只能在 企业版本中使用，它不是将文档储存在磁盘上，而是保存在内存上，实现更快的检索。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;MMAPv1&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;是 MongoDB 3.0 之前的更早版本的默认储存引擎。从 MongoDB 4.0 开始官方不推荐使用该引擎。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;MongoDB 如何保证数据的完整性 ，通过检查点(也就是每60s写入一次)和事务性日志来确保数据的完整性和持久性。&lt;/p&gt;
&lt;p&gt;我们接下来介绍下 我们常用的引擎 WiredTiger 的相关信息：&lt;/p&gt;
&lt;h4 id=&quot;wiredtiger&quot;&gt;WiredTiger&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;WiredTiger 日志&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;日志功能默认启用。 WiredTiger 日志会在检查点之间保留所有数据修改。如果 MongoDB 在检查点之间退出，它将使用日志重播自上一个检查点以来修改的所有数据。&lt;/p&gt;
&lt;p&gt;我们可以禁用日志功能，来减少开启日志功能所需要的开销。但是这样也就意味着，当MongoDB 非正常退出时，最后一个检查点之后的数据将会都丢失。&lt;/p&gt;
&lt;p&gt;WiredTiger 日志默认启用数据压缩。此日志非 MongoDB 的日志文件，而是 WiredTiger 日志，通过该日志我们可以获取上一个检查点之后发生的操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用日志功能，恢复流程：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;先查看数据文件查找最后一个检查点的位置的标识符。&lt;/li&gt;
&lt;li&gt;在日志文件中搜索与检查点标识符相匹配的记录。&lt;/li&gt;
&lt;li&gt;获取从上一个检查点之后的操作。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;日志文件会在 &lt;code&gt;dbpath&lt;/code&gt; 下以 &lt;code&gt;journal&lt;/code&gt; 命名的子目录下，以形如 &lt;code&gt;WiredTigerLog.0000000001&lt;/code&gt; 格式的文件名储存。&lt;/p&gt;
&lt;blockquote readability=&quot;15&quot;&gt;
&lt;p&gt;WiredTiger 的最小日志记录大小为128个字节。如果日志记录是128字节或更小，WiredTiger 不会压缩该记录。&lt;/p&gt;
&lt;p&gt;日志文件包含每个写操作的记录。每条记录都有唯一的标识符。MongoDB 将 WiredTiger 配置为对日记数据使用snappy压缩。&lt;/p&gt;
&lt;p&gt;MongoDB 的 WiredTiger 日志文件的最大大小限制大约为100 MB。一旦文件超过该限制，WiredTiger就会创建一个新的日志文件。&lt;/p&gt;
&lt;p&gt;WiredTiger 会自动删除旧日志文件，以仅维护从上一个检查点恢复所需的文件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;数据压缩&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用 WiredTiger，MongoDB支持对所有集合和索引进行压缩。压缩是以 CPU 为代价来减少磁盘的使用。默认情况下，WiredTiger 会对数据进行压缩。在大多数情况下，默认的压缩设置以及平衡了 储存空间和 CPU 使用率。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;内存使用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从 MongoDB 3.4开始，默认WiredTiger内部缓存大小取值是取以下两个值中的较大者：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;(totalRAM - 1G) 50%&lt;/li&gt;
&lt;li&gt;256MB&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;例如 一个主机的内存是 4G ,那么取值为 1.5G, 如果是 1.25G,那么取值为256M。&lt;/p&gt;
&lt;p&gt;调整 内存使用，需要使用 &lt;a href=&quot;https://docs.mongodb.com/manual/reference/configuration-options/#storage.wiredTiger.engineConfig.cacheSizeGB&quot;&gt;&lt;code&gt;storage.wiredTiger.engineConfig.cacheSizeGB&lt;/code&gt;&lt;/a&gt;内部缓存和 &lt;a href=&quot;https://docs.mongodb.com/manual/reference/program/mongod/#cmdoption-mongod-wiredtigercachesizegb&quot;&gt;&lt;code&gt;--wiredTigerCacheSizeGB&lt;/code&gt;&lt;/a&gt;。 两个参数。&lt;/p&gt;
&lt;h3 id=&quot;三mongodb-配置参数&quot;&gt;三、mongodb 配置参数&lt;/h3&gt;
&lt;p&gt;Mongodb 建议使用 YAML 格式的配置文件，也支持 ini 格式的配置文件。&lt;/p&gt;
&lt;h4 id=&quot;ini-配置文件参数解析&quot;&gt;ini 配置文件参数解析&lt;/h4&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;bind_ip=0.0.0.0  #绑定的 ip,如果是 0.0.0.0 就是绑定本地所有ip
port=27037  # 监听端口号，默认为27017。
dbpath=/opt/mongodb/data/ # 数据储存的位置 
logpath=/opt/mongodb/logs/mongodb.log # 日志储存的位置
pidfilepath=/opt/mongodb/logs/mongod.pid # pid文件储存的位置
logRotate= rename/reopen
    #3.0.0版中的新功能。可以取值为 rename 或 reopen：
        rename 重命名日志文件。每次重启都会重命名日志文件。
        reopen 按照典型的 Linux/Unix 日志循环行为关闭并重新打开日志文件。使用 reopen 使用的             Linux/Unix logrotate的工具时，以避免日志的丢失。
        如果指定 reopen，则还必须使用 logappend
logappend= true # 当 MongoDB 实例重新启动时，将新的日志内容添加到现有日志文件的末尾。如果没有此选项，MongoDB 将备份现有日志并创建新文件。
listenBacklog= 128 #侦听队列中可以存在的最大连接数。取决于 /proc/sys/net/core/somaxconn 这个值
maxConns= 500  #最大连接数
directoryperdb=true # 将每个数据库的数据分目录储存
# replS=fymongodb # 在配置副本集的时候设置副本集名称，单节点的不需要设置该参数
auth=true # 开启登录验证
fork=true # 后台运行
journal=true # 开启预写日志&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;yaml-配置文件参数解析&quot;&gt;&lt;a href=&quot;https://docs.mongodb.com/manual/reference/configuration-options/&quot;&gt;YAML 配置文件&lt;/a&gt;参数解析&lt;/h4&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;systemLog:  # 日志配置 日志切割见文章：https://dwz.cn/VPxxTf38
   destination: file
   path: &quot;/opt/mongodb/logs/mongodb.log&quot;  
   logAppend: true
   timeStampFormat: &quot;iso8601-local&quot;  # 日志使用的时间格式,默认为iso8601-local，可选值 ctime、iso8601-utc、iso8601-local。
   # 还有更详细的组件、控制、索引、回滚等日志的输出等级配置见官网
processManagement: # 进程控制配置
   fork: true  #后台以守护进程运行
   pidFilePath: &quot;/opt/mongodb/logs/mongod.pid&quot;  # pid 文件路径
   timeZoneInfo: &quot;/usr/share/zoneinfo/Asia/Shanghai&quot;  #数据库使用的时区，未设置使用系统默认
net:
   bindIp: &quot;0.0.0.0&quot;  # 绑定的ip,127.0.0.1/0.0.0.0/::,0.0.0.0(绑定到所有IP地址),与bindIpAll 参数是互斥的
   bindIpAll: &amp;lt;boolean&amp;gt;  # 是否绑定本地所有ip，与bindIp 参数是互斥的
   port: 27017  # 绑定的端口，默认值27017
   maxIncomingConnections: 500 # 最大同时连接数，默认值为65536
   wireObjectCheck: &amp;lt;boolean&amp;gt;  # 对客户端的写入进行验证，会有较小的性能影响，默认为 True.
   ssl:  # ssl 的详细配置
      sslOnNormalPorts: &amp;lt;boolean&amp;gt;  # deprecated since 2.6
      certificateSelector: &amp;lt;string&amp;gt;
      clusterCertificateSelector: &amp;lt;string&amp;gt;
      mode: &amp;lt;string&amp;gt;
      PEMKeyFile: &amp;lt;string&amp;gt;
      PEMKeyPassword: &amp;lt;string&amp;gt;
      clusterFile: &amp;lt;string&amp;gt;
      clusterPassword: &amp;lt;string&amp;gt;
      CAFile: &amp;lt;string&amp;gt;
      clusterCAFile: &amp;lt;string&amp;gt;
      CRLFile: &amp;lt;string&amp;gt;
      allowConnectionsWithoutCertificates: &amp;lt;boolean&amp;gt;
      allowInvalidCertificates: &amp;lt;boolean&amp;gt;
      allowInvalidHostnames: &amp;lt;boolean&amp;gt;
      disabledProtocols: &amp;lt;string&amp;gt;
      FIPSMode: &amp;lt;boolean&amp;gt;
   compression:
      compressors: &amp;lt;string&amp;gt; # 通信压缩器，可取值 snappy、zlib(版本3.6+可用)、disabled,默认值snappy,
   serviceExecutor: &amp;lt;string&amp;gt; #线程执行模型 3.6+版本使用，默认值: synchronous，可取值 adaptive、synchronous
storage: # 数据储存配置
   dbPath: &quot;/opt/mongodb/data/&quot;   #  mongod 数据储存的位置
   indexBuildRetry: &amp;lt;boolean&amp;gt; # mongod 在下次启动重新构建不完整索引，默认为True,不能与replication.replSetName 一起使用
   repairPath: &amp;lt;string&amp;gt;   
   journal: 
      enabled: &amp;lt;boolean&amp;gt; # 是否开启journal日志在64位系统默认为 true,在32位系统为false,建议启用
      commitIntervalMs: &amp;lt;num&amp;gt; # 设置日志储存到磁盘的间隔时间，默认为100毫秒，可以设置为1-500.
   directoryPerDB: &amp;lt;boolean&amp;gt;  # 是否开启分目录储存数据，默认值为 False,
   syncPeriodSecs: &amp;lt;int&amp;gt;  # MongoDB通过fsync操作将数据储存到磁盘的时间，默认值 60,单位秒，不建议更改此值
   engine: &amp;lt;string&amp;gt; # 储存引擎，默认值wiredTiger，MongoDB不推荐使用MMAPv1存储引擎
   wiredTiger:    # wiredTiger 储存引擎配置
      engineConfig:
         cacheSizeGB: &amp;lt;number&amp;gt;  # 内部缓存内存大小，默认是取50% of (RAM - 1 GB)和256 MB的最大者，可设置值为 0.25G-10000G，如果一台服务器有多个MongoDB实例或者运行在docker中，需要设置该值，避免多台实例占用完系统的所有内存，和mongodb在容器中获取不到实际内存大小。
         journalCompressor: &amp;lt;string&amp;gt; # WiredTiger日志数据的压缩类型 默认值 snappy，可选值 none、snappy、zlib.
         directoryForIndexes: &amp;lt;boolean&amp;gt; # 将index储存到一个目录，并软连接到数据目录，默认值为False,
      collectionConfig: 
         blockCompressor: &amp;lt;string&amp;gt;  # 集合数据的压缩类型，默认值 snappy，可选值 none、snappy、zlib.
      indexConfig:
         prefixCompression: &amp;lt;boolean&amp;gt; # 启用的索引的前缀压缩 默认值为 true
   inMemory:  # inmemory 引擎配置
      engineConfig:
         inMemorySizeGB: &amp;lt;number&amp;gt;  # 设置 inmemory 引擎分配的最大内存默认为50%(RAM - 1 GB)
security:
   keyFile: &amp;lt;string&amp;gt; #储存密钥文件的路径，用于存储MongoDB实例用于在分片集群或副本集中相互进行身份验证的共享密钥 
   clusterAuthMode: &amp;lt;string&amp;gt; #集群验证模式
   authorization: &amp;lt;string&amp;gt; #启用基于角色的访问控制,可选值enabled、disabled默认值为禁用，建议开启

operationProfiling:  # 开启慢查询
   mode: &amp;lt;string&amp;gt;  # 慢查询模式 可选值，off、slowOp、all,默认值off。建议开启
   slowOpThresholdMs: &amp;lt;int&amp;gt;  # 阈值，默认值100 毫秒
   slowOpSampleRate: &amp;lt;double&amp;gt; # 随机采集慢查询的百分比值，sampleRate 值默认为1，表示都采集，0.42 表示采集42%的内容
replication:  # 复制配置，副本集，indexBuildRetry与副本集互斥 Oplog 具体见文章： https://dwz.cn/98tUpUfu
   oplogSizeMB: &amp;lt;int&amp;gt; # Oplog 的最大大小，单位Mb ，
   replSetName: &amp;lt;string&amp;gt; # 副本集名称
   secondaryIndexPrefetch: &amp;lt;string&amp;gt; # 仅适用于mmapv1 存储引擎
   enableMajorityReadConcern: &amp;lt;boolean&amp;gt; # 开启 Majority 读取，默认为 True.
sharding: # 分片
   clusterRole: &amp;lt;string&amp;gt; # 设置该实例角色，可选值configsvr、shardsvr
   archiveMovedChunks: &amp;lt;boolean&amp;gt;   # 迁移过程块不保存 从3.2版本开始，默认为 False&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;示例配置文件&quot;&gt;示例配置文件&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;MongoDB 示例 ini 配置文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;github地址 : &lt;a href=&quot;https://github.com/tobewithyou1996/LinuxGuide/blob/master/MongoDB/mongodb.conf&quot; class=&quot;uri&quot;&gt;https://github.com/tobewithyou1996/LinuxGuide/blob/master/MongoDB/mongodb.conf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MongoDB 示例 YAML 配置文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;github地址 : &lt;a href=&quot;https://github.com/tobewithyou1996/LinuxGuide/blob/master/MongoDB/mongodb.yaml&quot; class=&quot;uri&quot;&gt;https://github.com/tobewithyou1996/LinuxGuide/blob/master/MongoDB/mongodb.yaml&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;四mongodb-单节点搭建&quot;&gt;四、MongoDB 单节点搭建&lt;/h3&gt;
&lt;h4 id=&quot;单节点搭建&quot;&gt;单节点搭建&lt;/h4&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;cd /tmp &amp;amp;&amp;amp; wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-4.0.8.tgz
tar -zxf mongodb-linux-x86_64-4.0.8.tgz 
mv  mongodb-linux-x86_64-4.0.8  /opt/mongodb
mkdir  /opt/mongodb/{data,logs}
touch  /opt/mongodb/mongodb.conf
useradd  mongodb 
# 添加配置文件
cat &amp;lt;&amp;lt;EOF  &amp;gt;&amp;gt; /opt/mongodb/mongodb.conf
bind_ip=0.0.0.0
port=27037
dbpath=/opt/mongodb/data/
logpath=/opt/mongodb/logs/mongodb.log
pidfilepath=/opt/mongodb/logs/mongod.pid
logRotate= reopen
logappend= true
listenBacklog= 128
maxConns= 500
directoryperdb=true
noauth=true
fork=true
journal=true
profile=2
slowms=200
EOF
# 更改 mongodb 的目录所有者
chown  -R mongodb:mongodb  /opt/mongodb
# 启动 MongoDB 服务
mongod -f /opt/mongodb/mongodb.conf
# 如果当前登录的用户是 root 需要指定用户 mongodb 启动。
su - mongodb  -c &quot;/opt/mongodb/bin/mongod -f /opt/mongodb/mongodb.conf&quot;
# 添加环境变量
echo &quot;export PATH=$PATH:/opt/mongodb/bin&quot; &amp;gt;&amp;gt;/etc/profile
source /etc/profile
# 暂停 MongoDB  服务
/opt/mongodb/bin/mongod --shutdown   --dbpath /opt/mongodb/data
#`mongod` 是服务端
#`mongo` 是客户端连接工具。&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;配置管理用户和普通用户&quot;&gt;配置管理用户和普通用户&lt;/h4&gt;
&lt;p&gt;创建管理员用户：创建管理员用户 admin ，密码 9toc7ttpji8 ，拥有最高级权限。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;&amp;gt; use admin
switched to db admin
&amp;gt; db.createUser({ user: &quot;admin&quot;, pwd: &quot;9toc7tpji8&quot;, roles: [{ role: &quot;root&quot;, db: &quot;admin&quot; }] })
Successfully added user: {
    &quot;user&quot; : &quot;admin&quot;,
    &quot;roles&quot; : [
        {
            &quot;role&quot; : &quot;root&quot;,
            &quot;db&quot; : &quot;admin&quot;
        }
    ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建普通用户 : 在数据库 djx, 创建用户名为 dd ，密码为 djx@123456，对数据库 djx 具有读写权限的用户。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;&amp;gt; use djx
switched to db djx
&amp;gt; db.createUser({user: &quot;dd&quot;,pwd: &quot;djx@123456&quot;,roles:[{&quot;role&quot;:&quot;readWrite&quot;,&quot;db&quot;:&quot;djx&quot;}]});
Successfully added user: {
    &quot;user&quot; : &quot;dd&quot;,
    &quot;roles&quot; : [
        {
            &quot;role&quot; : &quot;readWrite&quot;,
            &quot;db&quot; : &quot;djx&quot;
        }
    ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;详细配置见本文后半部分的 MongoDB用户认证和 MongoDB 角色。&lt;/p&gt;
&lt;h4 id=&quot;开启登陆验证&quot;&gt;开启登陆验证&lt;/h4&gt;
&lt;p&gt;将 &lt;code&gt;mongodb.conf&lt;/code&gt; 文件中的 &lt;code&gt;noauth=true&lt;/code&gt; 替换为 &lt;code&gt;auth=true&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;sed -i s/noauth/auth/g /opt/mongodb/mongodb.conf&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;并重启&lt;code&gt;MongoDB&lt;/code&gt; 才能生效&lt;/p&gt;
&lt;h4 id=&quot;配置systemd-脚本&quot;&gt;配置systemd 脚本&lt;/h4&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;cat &amp;lt;&amp;lt;EOF &amp;gt;&amp;gt;/usr/lib/systemd/system/mongodb.service
[Unit]
Description= mongodb service manager
[Service]
# Other directives omitted
# (file size)
LimitFSIZE=infinity
# (cpu time)
LimitCPU=infinity
# (virtual memory size)
LimitAS=infinity
# (locked-in-memory size)
LimitMEMLOCK=infinity
# (open files)
LimitNOFILE=64000
# (processes/threads)
LimitNPROC=64000
Type=forking
User=mongodb
Group=mongodb
PIDFile=/opt/mongodb/logs/mongod.pid
ExecStart= /opt/mongodb/bin/mongod -f /opt/mongodb/mongodb.conf
ExecStop= /opt/mongodb/bin/mongod --shutdown   --dbpath /opt/mongodb/data
Restart=always
[Install]
WantedBy=multi-user.target
EOF
systemctl status  mongodb # 查看 mongodb 状态
systemctl start mongodb # 启动 mongodb
systemctl enable  mongodb # 将 mongodb 添加到开机自启
systemctl stop mongodb # 暂停 mongodb &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;如果是在生产环境中使用，查看 &lt;a href=&quot;https://www.cnblogs.com/operationhome/p/10734047.html&quot;&gt;MongoDB 生产环境笔记&lt;/a&gt; 。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;五mongodb-连接&quot;&gt;五、MongoDB 连接&lt;/h3&gt;
&lt;p&gt;MongoDB 默认连接端口 27017 。&lt;/p&gt;
&lt;h4 id=&quot;mongodb-shell-连接&quot;&gt;MongoDB shell 连接&lt;/h4&gt;
&lt;p&gt;指定端口：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;mongo --port 27037&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;指定端口和主机&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;mongo --host mongodb0.example.com:28015&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具有认证的 MongoDB 实例&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;mongo --host mongodb://alice@mongodb0.examples.com:28015/?authSource=admin
或者使用
 --username &amp;lt;user&amp;gt;  --password, --authenticationDatabase &amp;lt;db&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;mongodb-应用程序连接&quot;&gt;MongoDB 应用程序连接&lt;/h4&gt;
&lt;p&gt;连接到 MongoDB 的副本集&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;mongo mongodb://mongodb0.example.com.local:27017,mongodb1.example.com.local:27017,mongodb2.example.com.local:27017/?replicaSet=replA

或者是
mongo --host replA/mongodb0.example.com.local:27017,mongodb1.example.com.local:27017,mongodb2.example.com.local:27017&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用 TLS/SSL 连接&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;在连接后面加上＆ssl = true 即可&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;MongoDB 设置连接池的连接数&lt;/p&gt;
&lt;p&gt;最大连接数 &lt;code&gt;&amp;amp;maxPoolSize=&amp;lt;integer&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;mongo &quot;mongodb://root:xxxxxx@dds-bpxxxxxxxx-pub.mongodb.rds.aliyuncs.com:3717,dds-bpxxxxxxxx-pub.mongodb.rds.aliyuncs.com:3717/admin?replicaSet=mgset-xxxxxx&amp;amp;maxPoolSize=10&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最小连接数 &lt;code&gt;&amp;amp;minPoolSize=&amp;lt;integer&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;六mongodb-常用命令&quot;&gt;六、MongoDB 常用命令&lt;/h3&gt;
&lt;h4 id=&quot;数据库级别常用命令&quot;&gt;数据库级别常用命令&lt;/h4&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;db.version() # 查看数据库版本
db  #查看当前所在的数据库
db.help() # 帮助
use databasename # 切换数据库
show dbs  # 列出当前用户可用的所有数据库
db.getSiblingDB() #不切换数据库，在别的数据库执行程序
db.stats()  # 查看当前所在数据库的状态
db.getMongo() # 查看当前 MongoDB 连接路径
use newdatabasename  # 创建数据库
db.dropDatabase()#  删除当前所在数据库
show profile # 打印最近执行花费1毫秒或更长时间的五个最近的操作。
db.serverStatus().connections #  查询当前连接数，以及最大连接数。
use admin , db.runCommand({currentOp: 1, $all:[{&quot;active&quot; : true}]}) # 查询每个连接对应的来源IP地址。
db.currentOp() # 查看 MongoDB 当前正在执行的操作。
db.killOp(opid) # 终止请求执行
db.fsyncLock()# 刷新写入磁盘并锁定数据库
db.fsyncUnlock()# 解锁
db.serverStatus().storageEngine # 显示当前 MongoDB 所使用的储存引擎
db.runCommand( { &quot;connPoolStats&quot; : 1 } ) # 查询数据库当前的连接信息
db.runCommand({logRotate:1}) # mongodb 日志切割&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;集合级别常用命令&quot;&gt;集合级别常用命令&lt;/h4&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;show collections #  查看当前数据库已有的集合
db.createCollection('name')#  创建集合
db.collectionname.drop()# 删除集合
db.collectionname.dataSize(); # 查询集合的大小
db.collectionname.find({key:value}) # 查询集合的数据包含 key 和 value。
db.collectionname.find() # 查询整个集合，每次只会显示部分数据，通过输入 it 来查看其它数据。
db.collectionname.renameCollection(&quot;newname&quot;)# 集合重命名
db.collectionname.stats()# 查询集合的状态&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;文档级别常用命令&quot;&gt;文档级别常用命令&lt;/h4&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;db.collectionname.insert({key:value})#  添加数据,collectionname指的是集合名称。
db.collectionname.count() #查询集合有多少文档数量
db.collectionname.remove({'key':value}) # 删除集合collectionname 中 key='key',value=value 的 文档。
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;用户常用命令&quot;&gt;用户常用命令&lt;/h4&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;show users #  当前数据库的用户列表
show roles #  当前数据库的所有角色列表，包括用户定义和内置角色。
db.auth(username,pwd) # 登录验证
db.changeUserPassword(username, password) # 更改用户密码
db.createUser() # 创建用户
db.dropUser(username) # 删除用户
db.dropAllUsers() # 删除所有的用户
db.getUser(username)  # 查询用户
db.getUsers() # 返回当前数据库所有的用户
db.removeUser(username) # 删除用户
db.grantRolesToUser(username, roles, writeConcern) # 给用户授权新的权限
db.revokeRolesFromUser() # 删除用户授权的权限
db.updateUser() # 更新用户信息，该方法会替代用户原有的所有值。&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;七mongodb-认证&quot;&gt;七、MongoDB 认证&lt;/h3&gt;
&lt;p&gt;MongoDB 默认的认证是 SCRAM&lt;/p&gt;
&lt;p&gt;MongoDB 创建用户命令详解：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;#  创建用户 
db.createUser(
{
user: &quot;用户名&quot;,
pwd: &quot;密码&quot;,
customData: {  &amp;lt; any  information &amp;gt;  },
roles: [
    { role: &quot;&amp;lt;role&amp;gt;&quot;, db: &quot;&amp;lt;database&amp;gt;&quot; } | &quot;&amp;lt;role&amp;gt;&quot;,
    ...
  ],
authenticationRestrictions: [
     {
       clientSource: [&quot;&amp;lt;IP&amp;gt;&quot; | &quot;&amp;lt;CIDR range&amp;gt;&quot;, ...]
       serverAddress: [&quot;&amp;lt;IP&amp;gt;&quot; | &quot;&amp;lt;CIDR range&amp;gt;&quot;, ...]
     },
     ...
  ],
  mechanisms: [ &quot;&amp;lt;SCRAM-SHA-1|SCRAM-SHA-256&amp;gt;&quot;, ... ],
  passwordDigestor: &quot;&amp;lt;server|client&amp;gt;&quot;
}
)&lt;/code&gt;
&lt;/pre&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;7.5&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;user&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;用户名&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;pwd&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;密码&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;customData&lt;/td&gt;
&lt;td&gt;document&lt;/td&gt;
&lt;td&gt;可选的，任意信息，可以是用户的id&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;roles&lt;/td&gt;
&lt;td&gt;array&lt;/td&gt;
&lt;td&gt;授权用户的角色。可以指定一个空数组&lt;code&gt;[]&lt;/code&gt;来创建没有角色的用户。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;authenticationRestrictions&lt;/td&gt;
&lt;td&gt;array&lt;/td&gt;
&lt;td&gt;可选，3.6版本中的新功能，允许服务器可以接受用户的IP地址和服务器地址，和CIDR 范围&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;mechanisms&lt;/td&gt;
&lt;td&gt;array&lt;/td&gt;
&lt;td&gt;可选的，4.0版本的功能，指定用于创建SCRAM用户凭据的特定SCRAM机制，可选值为 SCRAM-SHA-1 、SCRAM-SHA-256&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;passwordDigestor&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;可选的，服务端和客户端是否记录密码，默认为 server ,可选 server 、client。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;创建管理员用户&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;use admin
db.createUser(
  {
    user: &quot;myUserAdmin&quot;,
    pwd: &quot;abc123&quot;,
    roles: [ { role: &quot;userAdminAnyDatabase&quot;, db: &quot;admin&quot; }, &quot;readWriteAnyDatabase&quot; ]
  }
)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建普通用户 myTester ,密码为 xyz123 ，对库 test 有可读可写的权限 和 对库 reporting 有可读的权限。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;use test
db.createUser(
  {
    user: &quot;myTester&quot;,
    pwd: &quot;xyz123&quot;,
    roles: [ { role: &quot;readWrite&quot;, db: &quot;test&quot; },
             { role: &quot;read&quot;, db: &quot;reporting&quot; } ]
  }
)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;八mongodb-用户角色&quot;&gt;八、MongoDB 用户角色&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.mongodb.com/manual/reference/built-in-roles/&quot;&gt;官网链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;MongoDB 包含以下客户端的角色 ：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基本权限：&lt;/strong&gt; read(可读)、readWrite(可读可写)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;管理员权限：&lt;/strong&gt;dbAdmin(管理员)、userAdmin(当前数据库上创建和修改角色和用户的功能)、dbOwner (数据库所有者，包含&lt;a href=&quot;https://docs.mongodb.com/manual/reference/built-in-roles/#readWrite&quot;&gt;&lt;code&gt;readWrite&lt;/code&gt;&lt;/a&gt;， &lt;a href=&quot;https://docs.mongodb.com/manual/reference/built-in-roles/#dbAdmin&quot;&gt;&lt;code&gt;dbAdmin&lt;/code&gt;&lt;/a&gt;，&lt;a href=&quot;https://docs.mongodb.com/manual/reference/built-in-roles/#userAdmin&quot;&gt;&lt;code&gt;userAdmin&lt;/code&gt;&lt;/a&gt;角色)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;备份和还原权限：&lt;/strong&gt;&lt;a href=&quot;https://docs.mongodb.com/manual/reference/built-in-roles/#backup&quot;&gt;backup&lt;/a&gt;(提供备份数据所需要的最小权限)、&lt;a href=&quot;https://docs.mongodb.com/manual/reference/built-in-roles/#restore&quot;&gt;restore&lt;/a&gt;(提供从不包含&lt;a href=&quot;https://docs.mongodb.com/manual/reference/system-collections/#%3Cdatabase%3E.system.profile&quot;&gt;&lt;code&gt;system.profile&lt;/code&gt;&lt;/a&gt; 集合数据的备份还原数据所需的权限)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;针对所有数据库的权限：&lt;/strong&gt;&lt;a href=&quot;https://docs.mongodb.com/manual/reference/built-in-roles/#readAnyDatabase&quot;&gt;readAnyDatabase&lt;/a&gt;、&lt;a href=&quot;https://docs.mongodb.com/manual/reference/built-in-roles/#readWriteAnyDatabase&quot;&gt;readWriteAnyDatabase&lt;/a&gt;、`&lt;a href=&quot;https://docs.mongodb.com/manual/reference/built-in-roles/#userAdminAnyDatabase&quot;&gt;userAdminAnyDatabase&lt;/a&gt;、&lt;a href=&quot;https://docs.mongodb.com/manual/reference/built-in-roles/#userAdminAnyDatabase&quot;&gt;userAdminAnyDatabase&lt;/a&gt;、&lt;a href=&quot;https://docs.mongodb.com/manual/reference/built-in-roles/#dbAdminAnyDatabase&quot;&gt;dbAdminAnyDatabase&lt;/a&gt;，&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;超级管理员：&lt;/strong&gt; root (包含readWriteAnyDatabase， dbAdminAnyDatabase，userAdminAnyDatabase， clusterAdmin，restore，和 backup)&lt;/p&gt;
&lt;p&gt;我们也可以定义自己需要的角色，来实现我们特定的权限规则。我们可以创建角色，并赋予其权限，详细设置见官网。&lt;/p&gt;
&lt;h3 id=&quot;九mongodb-备份与恢复&quot;&gt;九、MongoDB 备份与恢复&lt;/h3&gt;
&lt;p&gt;由于文章篇幅太长，所以单独放到一个文章里了。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/operationhome/p/10724374.html&quot;&gt;MongoDB 备份与还原 mongodump、mongorestore&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;十生产环境注意事项&quot;&gt;十、生产环境注意事项&lt;/h3&gt;
&lt;p&gt;由于文章篇幅太长，所以单独放到一个文章里了。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/operationhome/p/10734047.html&quot;&gt;MongoDB 生产环境笔记&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;十一mongodb-调优&quot;&gt;十一、MongoDB 调优&lt;/h3&gt;
&lt;h4 id=&quot;mongodb-日志切割&quot;&gt;MongoDB 日志切割&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/operationhome/p/10677099.html&quot;&gt;MongoDB 日志切割三种方式&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;cpu-占用较高&quot;&gt;CPU 占用较高&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;%3Chttps://help.aliyun.com/document_detail/62224.html&quot;&gt;MongoDBCPU占用较高(阿里云)&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;mongodb-开启慢查询&quot;&gt;MongoDB 开启慢查询&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/operationhome/p/10728654.html&quot;&gt;MongoDB调优-查询优化-MongoDB Profiler&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;mongodb-oplog详解&quot;&gt;MongoDB Oplog详解&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/operationhome/p/10688798.html&quot;&gt;MongoDB-Oplog详解&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;mongodb-日志清理&quot;&gt;MongoDB 日志清理&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;用户禁止使用 &lt;code&gt;db.repairDatabase&lt;/code&gt;命令。&lt;/li&gt;
&lt;li&gt;日志占用空间过大时，会触发自动清理策略。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注：紧急情况下请使用 &lt;code&gt;db.runCommand({compact: 'oplog.rs'})&lt;/code&gt;命令清理日志。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;十二mongodb-常用的几大gui工具&quot;&gt;十二、MongoDB 常用的几大GUI工具&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/operationhome/p/10709879.html&quot;&gt;MongoDB 常用的几大GUI工具&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 19 Apr 2019 06:53:00 +0000</pubDate>
<dc:creator>自由早晚乱余生</dc:creator>
<og:description>[TOC] 一、MongoDB 简介 本文的内容是基于 的。 参考于 官方文档。 ​ MongoDB 是由 语言编写的，是一个基于分布式文件存储的开源数据库系统。属于 数据库。MongoDB 数据库中</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/operationhome/p/10734659.html</dc:identifier>
</item>
<item>
<title>Java代码规范与质量检测插件SonarLint - 不要乱摸</title>
<link>http://www.cnblogs.com/cjsblog/p/10735800.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cjsblog/p/10735800.html</guid>
<description>&lt;p&gt;&lt;span&gt;1.  SonarLint&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SonarLint是一个代码质量检测插件，可以帮助我们检测出代码中的&lt;span&gt;&lt;strong&gt;坏味道&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/874963/201904/874963-20190419130739837-1182426945.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下载与安装&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/874963/201904/874963-20190419131034027-1698295479.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在需要检测的单个文件或者单个项目上右键 --&amp;gt; Analyze --&amp;gt; Analyze with SonarLint&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;或者选中文件或目录，点击菜单栏 Analyze --&amp;gt; Analyze with SonarLint&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/874963/201904/874963-20190419131419797-1783454354.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们还可以禁用某些规则&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/874963/201904/874963-20190419142824037-196909341.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;如果需要同步自定义的规则时，可以绑定到SonarQube&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/874963/201904/874963-20190419142928972-1521046395.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/874963/201904/874963-20190419143149086-1480485034.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/874963/201904/874963-20190419143205345-1404531760.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;查看检测的结果&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/874963/201904/874963-20190419131539747-1900601094.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于代码中的警告我们不能视而不见&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/874963/201904/874963-20190419140041708-2129732214.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有了代码质量检测工具以后，在一定程度上可以保证代码的质量&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于每一个问题，SonarLint都给出了示例，还有相应的解决方案，教我们怎么修改，极大的方便了我们的开发&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如，对于日期类型尽量用LocalDate、LocalTime、LocalDateTime，还有重复代码、潜在的空指针异常、循环嵌套等等问题&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;有了代码规范与质量检测工具以后，很多东西就可以&lt;span&gt;&lt;strong&gt;量化&lt;/strong&gt;&lt;/span&gt;了，比如bug率、代码重复率等，还可以自定义各种指标，方便管理人员查看&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为此，我们需要一个平台来记录每次检测分析的结果，这样就可以进行分析和统计，并且可以直观的看到这一切&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;于是，&lt;span&gt;&lt;strong&gt;SonarQube&lt;/strong&gt;&lt;/span&gt; 闪亮登场！&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;2.  SonarQube&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SonarQube是一个开源的代码质量管理平台&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/874963/201904/874963-20190419133235532-740155228.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/874963/201904/874963-20190419133541852-1023559726.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/874963/201904/874963-20190419133816753-1086201894.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/874963/201904/874963-20190419133832886-1908956251.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解压&amp;amp;本地启动&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://docs.sonarqube.org/latest/setup/get-started-2-minutes/&quot;&gt;https://docs.sonarqube.org/latest/setup/get-started-2-minutes/&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;unzip&lt;/span&gt; sonarqube-&lt;span&gt;7.7&lt;/span&gt;.&lt;span&gt;zip&lt;/span&gt;&lt;span&gt;
cd sonarqube&lt;/span&gt;-&lt;span&gt;7.7&lt;/span&gt;&lt;span&gt;
bin&lt;/span&gt;/[OS]/sonar.&lt;span&gt;sh&lt;/span&gt; consol
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/874963/201904/874963-20190419133938001-1731552190.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;启动成功后，访问 http://localhost:9000  用管理员账号（admin/admin）登录&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/874963/201904/874963-20190419134351858-821697120.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接下来，为了把检测的结果传到服务器，我们需要配置一个Scanner&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://docs.sonarqube.org/display/SCAN/Analyzing+with+SonarQube+Scanner+for+Maven&quot;&gt;https://docs.sonarqube.org/display/SCAN/Analyzing+with+SonarQube+Scanner+for+Maven&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里我在项目中添加 sonar-maven-plugin 插件&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;build&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;plugins&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;plugin&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.sonarsource.scanner.maven&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;sonar-maven-plugin&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;3.6.0.1398&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;plugin&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;plugins&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;build&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;命令行执行： mvn clean compile &lt;strong&gt;&lt;span&gt;sonar:sonar&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;成功后，可以在控制台中看到这样的输出&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/874963/201904/874963-20190419135213002-647346053.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;再次刷新 http://localhost:9000/ 会看到跟刚才不一样了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/874963/201904/874963-20190419135319971-1072994509.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/874963/201904/874963-20190419135334677-1765697118.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/874963/201904/874963-20190419135354813-642129288.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以上只是本地演示，在正式环境中这些数据当然要保存到数据库中，具体安装就不演示了，下面是文档&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://docs.sonarqube.org/latest/setup/install-server/&quot;&gt;https://docs.sonarqube.org/latest/setup/install-server/&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;3.  Alibaba代码规约插件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;阿里代码规范，相信大家都不陌生&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/874963/201904/874963-20190419140522306-731136621.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/874963/201904/874963-20190419140539824-1910544399.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/874963/201904/874963-20190419140555441-816378513.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.  文档&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://www.sonarqube.org/&quot;&gt;https://www.sonarqube.org/&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://www.sonarsource.com/plans-and-pricing/community/&quot;&gt;https://www.sonarsource.com/plans-and-pricing/community/&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://www.sonarlint.org/&quot;&gt;https://www.sonarlint.org/&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://docs.sonarqube.org/latest/setup/overview/&quot;&gt;https://docs.sonarqube.org/latest/setup/overview/&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://docs.sonarqube.org/latest/&quot;&gt;https://docs.sonarqube.org/latest/&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://github.com/SonarSource/sonar-scanning-examples/tree/master/sonarqube-scanner-maven&quot;&gt;https://github.com/SonarSource/sonar-scanning-examples/tree/master/sonarqube-scanner-maven&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://github.com/SonarSource&quot;&gt;https://github.com/SonarSource&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 19 Apr 2019 06:36:00 +0000</pubDate>
<dc:creator>不要乱摸</dc:creator>
<og:description>1. SonarLint SonarLint是一个代码质量检测插件，可以帮助我们检测出代码中的坏味道 下载与安装 在需要检测的单个文件或者单个项目上右键 --&gt; Analyze --&gt; A</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cjsblog/p/10735800.html</dc:identifier>
</item>
<item>
<title>程序员如何巧用Excel提高工作效率 第二篇 - 周伟伟的博客</title>
<link>http://www.cnblogs.com/zwwhnly/p/10735759.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zwwhnly/p/10735759.html</guid>
<description>&lt;p&gt;之前写了一篇博客&lt;a href=&quot;https://www.cnblogs.com/zwwhnly/p/10695533.html&quot;&gt;程序员如何巧用Excel提高工作效率&lt;/a&gt;，讲解了程序员在日常工作中如何利用Excel来提高工作效率，没想到收到很好的反馈，点赞量，评论量以及阅读量一度飙升为我的博客中Top 1，看来大家平时帮业务修改数据的场景很多啊，哈哈。&lt;/p&gt;
&lt;p&gt;好了，言归正传，本篇博客我们主要讲解下Excel中VLOOKUP函数的使用，相比于上一篇中的内容，个人觉得这个相对高级一些。&lt;/p&gt;
&lt;h2 id=&quot;使用背景&quot;&gt;1.使用背景&lt;/h2&gt;
&lt;p&gt;为什么会使用到这个函数呢，背景是这样的，有两个系统，我们假设叫A系统，B系统，这两个系统都存储了供应商的信息并且和平相处很长时间，忽然有一天上班，就看到业务同学发的钉钉消息：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;业务：在不，我发现你们A系统存储的供应商名称不对啊&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;我：举个例子&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;业务：有个供应商A系统叫[联营]苏州食行生鲜电子商务有限公司，但是B系统叫苏州食行生鲜电子商务有限公司，类似的还有很多，基本上A系统都加上了&lt;strong&gt;[联营]&lt;/strong&gt;这个前缀或者&lt;strong&gt;[联营]&lt;/strong&gt;这个后缀&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;我：那你的需求是？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;业务：我需要A系统里的供应商名称全部修改为和B系统一致，以B系统为准，并且现在A系统我需要供应商的联系人信息，这个数据B系统是有的，你也帮我一并初始化过来&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;我：好吧，你说了算……&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;使用方法&quot;&gt;2.使用方法&lt;/h2&gt;
&lt;p&gt;按照上述的使用背景，业务提供了如下的Excel，这个Excel分3个Sheet，分别是：A系统供应商数据，B系统供应商数据，B系统供应商联系人数据，具体的数据如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/424537/201904/424537-20190419133258451-807860759.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/424537/201904/424537-20190419133302651-442103274.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/424537/201904/424537-20190419133306099-2046536830.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们的最终目的是拼接一个Update语句来更新A系统的供应商数据，然后批量生成，这样就可以批量更新A系统的供应商数据了。&lt;/p&gt;
&lt;p&gt;基于此目的，我们拆分步骤如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;把第2个Sheet和第3个Sheet中的数据匹配到第一个Sheet中,匹配条件是列：B系统供应商编码&lt;/li&gt;
&lt;li&gt;在第一个Sheet中拼接Update语句(拼接方法可参考之前的博客&lt;a href=&quot;https://www.cnblogs.com/zwwhnly/p/10695533.html&quot;&gt;程序员如何巧用Excel提高工作效率&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;批量生成Update语句&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;第一步我们就需要用到VLOOKUP函数了，以下为匹配方法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/424537/201904/424537-20190419135815181-346432334.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/424537/201904/424537-20190419135822383-84686435.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时我们已经将需要的数据都匹配到了第一个Sheet中：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/424537/201904/424537-20190419135832140-1245670127.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来我们需要的是拼接Update语句，方法如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/424537/201904/424537-20190419140652843-331661076.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最终批量生成的语句如下，完美完成：&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;UPDATE supplier_seller
SET supplier_seller_name = '苏州食行生鲜电子商务有限公司',
    contact_name='张洪良',
    contact_email='zhanghongliang@163.com',
    contact_mobile='13758494357'
WHERE disabled = 0
  AND supplier_seller_code = 'A000001';

UPDATE supplier_seller
SET supplier_seller_name = '北京每日优鲜电子商务有限公司',
    contact_name='曾斌',
    contact_email='zengbin@163.com',
    contact_mobile='15601637452'
WHERE disabled = 0
  AND supplier_seller_code = 'A000002';&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;常见问题&quot;&gt;3.常见问题&lt;/h2&gt;
&lt;p&gt;在这个过程中，可能会出现以下情况，明明数据存在，匹配完成却显示&lt;strong&gt;#N/A&lt;/strong&gt;（注意：数据不存在也会显示#N/A）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/424537/201904/424537-20190419141146010-2131165933.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;出现的原因可能有以下两种：&lt;/p&gt;
&lt;p&gt;1.匹配的两列的单元格格式不同，比如第一个Sheet中的单元格格式是常规，第二个Sheet里的单元格格式是文本，解决方案就是将两列的单元格格式修改为一样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/424537/201904/424537-20190419141726683-926783090.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.匹配列不在第一列，如我们调整下第2个Sheet中两列的位置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/424537/201904/424537-20190419142524737-300351695.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因此建议将匹配列放在第一列，避免出现问题排查浪费时间。&lt;/p&gt;
</description>
<pubDate>Fri, 19 Apr 2019 06:31:00 +0000</pubDate>
<dc:creator>周伟伟的博客</dc:creator>
<og:description>之前写了一篇博客 '程序员如何巧用Excel提高工作效率' ，讲解了程序员在日常工作中如何利用Excel来提高工作效率，没想到收到很好的反馈，点赞量，评论量以及阅读量一度飙升为我的博客中Top 1，看</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zwwhnly/p/10735759.html</dc:identifier>
</item>
<item>
<title>python接口自动化（十九）--Json 数据处理---实战（详解） - 北京-宏哥</title>
<link>http://www.cnblogs.com/du-hong/p/10729660.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/du-hong/p/10729660.html</guid>
<description>&lt;h2&gt;简介&lt;/h2&gt;
&lt;p&gt;　　上一篇说了关于json数据处理，是为了断言方便，这篇就带各位小伙伴实战一下。首先捋一下思路，然后根据思路一步一步的去实现和实战，不要一开始就盲目的动手和无头苍蝇一样到处乱撞，撞得头破血流后而放弃了。不仅什么没学习&lt;/p&gt;
&lt;p&gt;到，自己的自信心都受到打击了，自己都怀疑自己。其实你是最棒的，天生我材必有用，好了废话不说，进入实战——以查看快递物流接口为例。&lt;/p&gt;
&lt;p&gt;　　大致流程步骤：web页面操作—&amp;gt;抓包看参数和url—&amp;gt;代码模拟接口请求—&amp;gt;取到接口返回结果—&amp;gt;断言&lt;/p&gt;
&lt;h2&gt; web页面操作&lt;/h2&gt;
&lt;p&gt;1、浏览器输入快递物流查询url，输入快递单号，点击“查询”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201904/1232840-20190419141511965-1753386553.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;抓包看参数和url&lt;/h2&gt;
&lt;p&gt;1、点击“查询”，fiddler抓包，查看url和参数&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201904/1232840-20190419140316034-2114919797.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt; 代码模拟接口请求&lt;/h2&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201904/1232840-20190419141802721-1381488165.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;取到接口返回结果&lt;/h2&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201904/1232840-20190419141832962-1187277977.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;断言&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201904/1232840-20190419141854588-1768672082.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;代码及运行结果&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201904/1232840-20190419142011078-567748148.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;参考代码&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; # coding:utf-&lt;span&gt;8&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import requests
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; url =&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.kuaidi100.com/query?type=annengwuliu&amp;amp;postid=300240694004&amp;amp;temp=0.5964149534969456&amp;amp;phone=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; headers =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;User-Agent&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (Windows NT 10.0; WOW64; Trident/7.0; rv:11.0) like Gecko&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; } # &lt;span&gt;get&lt;/span&gt; 方法加个 User-&lt;span&gt;Agent 就可以了
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; s =&lt;span&gt; requests.session()
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; r = s.&lt;span&gt;get&lt;/span&gt;(url, headers=headers,verify=&lt;span&gt;False)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; result =&lt;span&gt; r.json()
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;print(result)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; data = result[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;data&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;] # 获取 data 里面内容
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;print (data)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; print (data[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]) # 获取 data 里最上面有个
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; get_result = data[&lt;span&gt;0&lt;/span&gt;][&lt;span&gt;'&lt;/span&gt;&lt;span&gt;context&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;] # 获取已签收状态
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;print (get_result)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;#进行断言
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; u&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;已签收&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;span&gt; get_result:
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;  print (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;快递单已签收成功&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;  print (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;未签收&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;小结&lt;/h2&gt;
&lt;p&gt;　　各位小伙伴，看到了，断言就是这么简单，其实和你写的测试用例差不多，将预期与实际结果进行对比，只不过是用代码体现出来。&lt;/p&gt;
</description>
<pubDate>Fri, 19 Apr 2019 06:25:00 +0000</pubDate>
<dc:creator>北京-宏哥</dc:creator>
<og:description>简介 上一篇说了关于json数据处理，是为了断言方便，这篇就带各位小伙伴实战一下。首先捋一下思路，然后根据思路一步一步的去实现和实战，不要一开始就盲目的动手和无头苍蝇一样到处乱撞，撞得头破血流后而放弃</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/du-hong/p/10729660.html</dc:identifier>
</item>
<item>
<title>asp.net core系列 58 IS4 基于浏览器的JavaScript客户端应用程序 - 花阴偷移</title>
<link>http://www.cnblogs.com/MrHSR/p/10735033.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MrHSR/p/10735033.html</guid>
<description>&lt;h3&gt;一. 概述&lt;/h3&gt;
&lt;p&gt;　　本篇探讨使用&quot;基于浏览器的JavaScript客户端应用程序&quot;。与上篇实现功能一样，只不过这篇使用JavaScript作为客户端程序，而非core mvc的后台代码HttpClient实现。 功能一样：用户首先要登录IdentityServer站点，再使用IdentityServer发出的访问令牌调用We​​b API，可以注销IdentityServer站点下登录的用户，清除cookie中的令牌信息。所有这些都将来自浏览器中运行的JavaScript。&lt;/p&gt;
&lt;p&gt;　　此示例还是三个项目：&lt;/p&gt;
&lt;p&gt;　　　　IdentityServer令牌服务项目 http://localhost:5000&lt;/p&gt;
&lt;p&gt;　　　　API资源项目 http://localhost:5001&lt;/p&gt;
&lt;p&gt;　　　　JavaScript客户端项目 http://localhost:5003&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;https://github.com/IdentityServer/IdentityServer4.Samples/tree/master/Quickstarts/6_JavaScriptClient&quot; target=&quot;_blank&quot;&gt;开源Github&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;二. IdentityServer项目&lt;/h3&gt;
&lt;p&gt;　　1.1 定义客户端配置&lt;/p&gt;
&lt;p&gt;　　　　Config.cs中，定义客户端，使用code 授权码模式，即先登录获取code,再获取token。项目其它处代码不变。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
       &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IEnumerable&amp;lt;Client&amp;gt;&lt;span&gt; GetClients()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; List&amp;lt;Client&amp;gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; JavaScript Client&lt;/span&gt;
                &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Client
                {
                    ClientId &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;js&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    ClientName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;JavaScript Client&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;授权码模式&lt;/span&gt;
                    AllowedGrantTypes =&lt;span&gt; GrantTypes.Code,
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;基于授权代码的令牌是否需要验证密钥,默认为false&lt;/span&gt;
                    RequirePkce = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;令牌端点请求令牌时不需要客户端密钥&lt;/span&gt;
                    RequireClientSecret = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;,

                    RedirectUris &lt;/span&gt;=           { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:5003/callback.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; },
                    PostLogoutRedirectUris &lt;/span&gt;= { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:5003/index.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; },

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定跨域请求,让IdentityServer接受这个指定网站的认证请求。&lt;/span&gt;
                    AllowedCorsOrigins =     { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:5003&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; },

                    AllowedScopes &lt;/span&gt;=&lt;span&gt;
                    {
                        IdentityServerConstants.StandardScopes.OpenId,
                        IdentityServerConstants.StandardScopes.Profile,
                        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                    }
                }
            };
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;三. API项目&lt;/h3&gt;
&lt;p&gt;　　在Web API项目中配置 跨域资源共享CORS。这将允许从http:// localhost:5003 (javascript站点) 到http:// localhost:5001 (API站点) 进行Ajax调用(跨域)。项目其它处代码不变。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
       &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
        {
            services.AddMvcCore()
                .AddAuthorization()
                .AddJsonFormatters();

            services.AddAuthentication(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Bearer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                .AddJwtBearer(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Bearer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, options =&amp;gt;&lt;span&gt;
                {
                    options.Authority &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:5000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                    options.RequireHttpsMetadata &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

                    options.Audience &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                });

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加Cors服务&lt;/span&gt;
            services.AddCors(options =&amp;gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; this defines a CORS policy called &quot;default&quot;&lt;/span&gt;
                options.AddPolicy(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, policy =&amp;gt;&lt;span&gt;
                {
                    policy.WithOrigins(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:5003&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                        .AllowAnyHeader()
                        .AllowAnyMethod();
                });
            });
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加管道&lt;/span&gt;
            app.UseCors(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            app.UseAuthentication();
            app.UseMvc();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;四. JavaScript客户端项目&lt;/h3&gt;
&lt;p&gt;　　　　在项目中，所有代码都在wwwroot下，没有涉及到服务端代码，可以完全不用core程序来调用。目录如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201904/151560-20190419114337569-523701188.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　其中添加了两个html 页(index.html, callback.html),一个app.js文件，这些属于自定义文件。oidc-client.js是核心库。&lt;/p&gt;

&lt;p&gt;　　4.1 index页面&lt;/p&gt;
&lt;p&gt;　　　　用于调用登录、注销、和api。引用了oidc-client.js和app.js　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;login&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Login&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;api&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Call API&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;logout&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Logout&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;pre &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;results&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;pre&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;oidc-client.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;app.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 　　4.2 app.js&lt;/p&gt;
&lt;p&gt;　　　　是应用程序的主要代码，包括：登录、Api请求，注销。配置与服务端代码差不多，如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;/ &amp;lt;reference path=&quot;oidc-client.js&quot; /&amp;gt;&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt;消息填充&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; log() {
    document.getElementById(&lt;/span&gt;'results').innerText = ''&lt;span&gt;;

    Array.prototype.forEach.call(arguments, &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (msg) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (msg &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; Error) {
            msg &lt;/span&gt;= &quot;Error: &quot; +&lt;span&gt; msg.message;
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; msg !== 'string'&lt;span&gt;) {
            msg &lt;/span&gt;= JSON.stringify(msg, &lt;span&gt;null&lt;/span&gt;, 2&lt;span&gt;);
        }
        document.getElementById(&lt;/span&gt;'results').innerHTML += msg + '\r\n'&lt;span&gt;;
    });
}

document.getElementById(&lt;/span&gt;&quot;login&quot;).addEventListener(&quot;click&quot;, login, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
document.getElementById(&lt;/span&gt;&quot;api&quot;).addEventListener(&quot;click&quot;, api, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
document.getElementById(&lt;/span&gt;&quot;logout&quot;).addEventListener(&quot;click&quot;, logout, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; config =&lt;span&gt; {
    authority: &lt;/span&gt;&quot;http://localhost:5000&quot;&lt;span&gt;,
    client_id: &lt;/span&gt;&quot;js&quot;&lt;span&gt;,
    redirect_uri: &lt;/span&gt;&quot;http://localhost:5003/callback.html&quot;&lt;span&gt;,
    response_type: &lt;/span&gt;&quot;code&quot;&lt;span&gt;,
    scope:&lt;/span&gt;&quot;openid profile api1&quot;&lt;span&gt;,
    post_logout_redirect_uri : &lt;/span&gt;&quot;http://localhost:5003/index.html&quot;&lt;span&gt;,
};
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;UserManager类&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; mgr = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Oidc.UserManager(config);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用户是否登录到JavaScript应用程序&lt;/span&gt;
mgr.getUser().then(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (user) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (user) {
        log(&lt;/span&gt;&quot;User logged in&quot;&lt;span&gt;, user.profile);
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        log(&lt;/span&gt;&quot;User not logged in&quot;&lt;span&gt;);
    }
});

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;登录&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; login() {
    mgr.signinRedirect();
}

&lt;/span&gt;&lt;span&gt;//跨域&lt;/span&gt;&lt;span&gt;请求api&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; api() {
    mgr.getUser().then(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (user) {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; url = &quot;http://localhost:5001/identity&quot;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; xhr = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; XMLHttpRequest();
        xhr.open(&lt;/span&gt;&quot;GET&quot;&lt;span&gt;, url);
        xhr.onload &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
            log(xhr.status, JSON.parse(xhr.responseText));
        }
        xhr.setRequestHeader(&lt;/span&gt;&quot;Authorization&quot;, &quot;Bearer &quot; +&lt;span&gt; user.access_token);
        xhr.send();
    });
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注销&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; logout() {
    mgr.signoutRedirect();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　4.3 callback.html&lt;/p&gt;
&lt;p&gt;　　　　用于完成与IdentityServer的OpenID Connect协议登录握手。对应app.js中config对象下的redirect_uri: &quot;http://localhost:5003/callback.html&quot;。登录完成后，我们可以将用户重定向回主index.html页面。添加此代码以完成登录过程&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;oidc-client.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Oidc.UserManager({ response_mode: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;query&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; }).signinRedirectCallback().then(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
            window.location &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;index.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        }).&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (e) {
            console.error(e);
        });
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;五 测试&lt;/h3&gt;
&lt;p&gt;　　(1) 启动IdentityServer程序http://localhost:5000&lt;/p&gt;
&lt;p&gt;　　(2) 启动API程序http://localhost:5001。这二个程序属于服务端&lt;/p&gt;
&lt;p&gt;　　(3) 启动javascriptClient程序 http://localhost:5003&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201904/151560-20190419114946974-705857593.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　(4) 用户点击login，开始握手授权，重定向到IdentityServer站点的登录页&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201904/151560-20190419115010817-71879792.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　(5) 输入用户的用户名和密码，登录成功。跳转到IdentityServer站点consent同意页面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201904/151560-20190419115032114-90774819.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　(6) 点击 yes allow后，跳回到客户端站点http://localhost:5003/index.html，完成了交互式身份认证。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201904/151560-20190419115054630-559900387.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span lang=&quot;EN-US&quot;&gt;(7) 调用点击&lt;span lang=&quot;EN-US&quot;&gt;Call API按钮，获取访问令牌，请求受保护的&lt;span lang=&quot;EN-US&quot;&gt;api资源。调用&lt;span lang=&quot;EN-US&quot;&gt;CallAPI 时，是访问的&lt;span lang=&quot;EN-US&quot;&gt;api站点&lt;span lang=&quot;EN-US&quot;&gt;http://localhost:5001/identity。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201904/151560-20190419115113764-2007251470.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;参考文献&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;https://identityserver4.readthedocs.io/en/latest/quickstarts/6_javascript_client.html&quot; target=&quot;_blank&quot;&gt;添加JavaScript客户端&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 19 Apr 2019 06:17:00 +0000</pubDate>
<dc:creator>花阴偷移</dc:creator>
<og:description>一. 概述 本篇探讨使用&quot;基于浏览器的JavaScript客户端应用程序&quot;。与上篇实现功能一样，只不过这篇使用JavaScript作为客户端程序，而非core mvc的后台代码Ht</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/MrHSR/p/10735033.html</dc:identifier>
</item>
<item>
<title>前端笔记之NodeJS（一）初识NodeJS&amp;内置模块&amp;特点 - mufengsm</title>
<link>http://www.cnblogs.com/rope/p/10724604.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rope/p/10724604.html</guid>
<description>[unable to retrieve full-text content]一、NodeJS简介 NodeJS是开发服务器后台的东西，和PHP、JavaEE、python类似，和传统的浏览器的关注DOM的JS完全不同，将JavaScript触角伸到了服务器端。内核是Chrome浏览器的V8引擎，解析JavaScript的效率是非常快的。 创始人。 在不升级服务器配置的情况下</description>
<pubDate>Fri, 19 Apr 2019 05:37:00 +0000</pubDate>
<dc:creator>mufengsm</dc:creator>
<og:description>一. 概述 本篇探讨使用&quot;基于浏览器的JavaScript客户端应用程序&quot;。与上篇实现功能一样，只不过这篇使用JavaScript作为客户端程序，而非core mvc的后台代码Ht</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/MrHSR/p/10735033.html</dc:identifier>
</item>
<item>
<title>浅谈数据库索引的结构设计与优化 - 流星划过天际</title>
<link>http://www.cnblogs.com/zhaowei520/p/10722697.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhaowei520/p/10722697.html</guid>
<description>
&lt;h2&gt; 一. 了解数据库索引的必要性&lt;/h2&gt;
&lt;p&gt;　　对于稍微数据量大一点的表，如果不适用索引，那么性能效率都会很低；如果绕开了索引，直接进行分区分表，数据库集群读写分离来解决性能问题的话，那么未免也太小题大做了。&lt;/p&gt;
&lt;p&gt;　　对于大多数中小型系统，索引能够帮你解决90%的性能问题，所以索引是解决关系型数据库非常有利的武器。&lt;/p&gt;


&lt;h2&gt;二. 表和索引结构&lt;/h2&gt;

&lt;h3&gt;　　1.索引页和表页&lt;/h3&gt;
&lt;p&gt;　　　　表和索引都是存在页中。页的大小一般是4KB.页的大小仅仅决定了一个页能存储多少个索引行，表行。&lt;/p&gt;
&lt;h3&gt;　　2.索引行&lt;/h3&gt;
&lt;p&gt;　　　　索引行是很有用的一个概念对于访问路径的时候。索引行的概念可以通过下图来了解:&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1657327/201904/1657327-20190417125602523-190253829.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　每一个页上包含了很多索引行，每个索引行里存储着索引条目和指向下一层的页，这种数据结构为B-tree结构。&lt;/p&gt;

&lt;h3&gt;　　3.缓冲池和磁盘I/O&lt;/h3&gt;
&lt;p&gt;　　　　我们可以使用内存的缓冲池来减小到磁盘的访问。这一策略对sql性能表现至关重要。下图展示了磁盘读取到缓冲区的巨大成本：&lt;/p&gt;

&lt;p&gt;　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1657327/201904/1657327-20190417130723490-2146617106.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　当我们需要某一页的一行数据时，和需要这一页的数据时，所花费的时间是相等的。可以通过执行:show global status like 'innodb%read%';来判断缓存命中的情况，具体的参数可以自行在网上查找:&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1657327/201904/1657327-20190417131351635-1508465935.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　可以算出来缓存命中率为=260850/(64+260850+1927)=99.24%,是很高的命中率了。&lt;/p&gt;
&lt;h3&gt;　　4.硬件特性&lt;/h3&gt;
&lt;p&gt;　　　　硬盘磁盘的图可以用下图简单表示:&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1657327/201904/1657327-20190417132441910-1621280412.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　我们的数据库表里的数据就保存在磁盘上，如果要读取数据，就要砖头磁盘，用磁头和磁盘的磁力来改变状态，来读取数据，所以，我们应该尽量少的转动磁盘，来优化数据库性能。&lt;/p&gt;

&lt;h2&gt;三.SQL处理过程&lt;/h2&gt;
&lt;p&gt;　　我们现在先讨论基础的处理过程，先来谈谈处理过程的一些基本概念。&lt;/p&gt;
&lt;h3&gt;　　1.关键字（谓词）&lt;/h3&gt;
&lt;p&gt;　　where子句由一个或者多个谓词组成，比如说：&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1657327/201904/1657327-20190417182027663-324817267.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　那么这个就有一个组合谓词，组合谓词是索引设计的主要入手点。&lt;/p&gt;
&lt;h3&gt;　　2.过滤因子&lt;/h3&gt;
&lt;p&gt;　　过滤因子是描述谓词的选择性，它主要依赖于列值的分布情况。它是一个计算值，公式为：&lt;/p&gt;
&lt;p&gt;　　　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1657327/201904/1657327-20190418131557515-1175662284.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　用来计算谓词结果集的返回大小估算。&lt;/p&gt;

&lt;h3&gt;　　3.物化结果集&lt;/h3&gt;
&lt;p&gt;　　是执行数据库访问来构建结果集。最好的情况下，是从数据库缓冲池返回一条记录，最坏的情况就是访问大量的磁盘读取数据。&lt;/p&gt;
&lt;p&gt;　　物化结果集有2种方式：&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　1.一次FETCH物化返回一条数据&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　2.提前物化&lt;/p&gt;


&lt;h2&gt;四.为SELECT语句创建理想索引&lt;/h2&gt;

&lt;h3&gt;　　1.三星索引&lt;/h3&gt;
&lt;p&gt;　　三星索引是指一条sql所能达到索引的最优设计。&lt;/p&gt;
&lt;p&gt;　　第一颗星：&lt;/p&gt;
&lt;p&gt;　　　　如果与一个查询相关的索引行是相邻的，那么这个索引就为第一颗星。&lt;/p&gt;
&lt;p&gt;　　第二颗星：&lt;/p&gt;
&lt;p&gt;　　　　如果索引行的顺序与查询语句一致，则为第二颗星。&lt;/p&gt;
&lt;p&gt;　　第三颗星：&lt;/p&gt;
&lt;p&gt;　　　　查询的数据为索引的信息，不需要额外的磁盘随机读。这一颗星能大大改善性能。&lt;/p&gt;
&lt;p&gt;　　假设有一条sql语句如下所示：&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1657327/201904/1657327-20190418132412139-973463367.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　如果要满足一星索引：索引的顺序可以是LNAME,CITY或者CITY,LNAME&lt;/p&gt;
&lt;p&gt;　　如果要满足第二星索引：FNAME加在LNAME,CITY或者CITY,LNAME后面&lt;/p&gt;
&lt;p&gt;　　如果要满足第三索引：CNO也要在索引里面&lt;/p&gt;
&lt;p&gt;　　那么组合起来得三星索引就是：LNAME,CITY,FNAME,CNO或者CITY,LNAME,FNAME,CNO&lt;/p&gt;


&lt;h2&gt;五.前瞻性索引&lt;/h2&gt;

&lt;h3&gt;　　1.发现不合适的索引&lt;/h3&gt;
&lt;p&gt;　　有两种基本的方法来发现不合适的索引：&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　1.基本问题法(BQ)&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　2.快速上线评估法(QUBE)&lt;/p&gt;

&lt;p&gt;　　在这里我仅仅讨论一下快速上线评估法(QUBE)&lt;/p&gt;

&lt;h3&gt;　　2.快速上线评估法(QUBE)&lt;/h3&gt;

&lt;p&gt;　　　QUBE是悲观上限，它的目的是在早期发现程序设计的缺陷，并且及时更改。QUBE忽略了排队时间，锁竞争时间等，把问题单一化来评估sql的性能问题。&lt;/p&gt;
&lt;p&gt;　　　下图就是QUBE计算评估sql时间公式：&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1657327/201904/1657327-20190419131321866-64563622.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 　　可以发现，TR和TS存在巨大的时间差距，随机访问会消耗大量的时间，那么来说说随机和顺序访问。&lt;/p&gt;
&lt;h4&gt;　　随机访问：&lt;/h4&gt;
&lt;p&gt;　　　　先说一说磁盘读和访问的区别。读是读取一页的信息，访问时访问一行的信息。所以单次随机访问的时间与一次磁盘随机读取的时间相同，都是10ms。&lt;/p&gt;
&lt;h4&gt;　　顺序访问：&lt;/h4&gt;
&lt;p&gt;　　　　一次顺序读是指物理上读取连续的下一行，这一行要么在同一页中，要么在下一页中，估算出来时间是0.01ms。&lt;/p&gt;
&lt;h4&gt;　　FETCH:&lt;/h4&gt;
&lt;p&gt;　　　　是FETCH调用次数来确定被接收行的数量。F的时间数量级要比TS大一级，但是要比TR小2级。&lt;/p&gt;


&lt;p&gt;　　下面给出一个简单的事例来说明QUBE计算方法：&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1657327/201904/1657327-20190419132921670-1868069076.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　那么可以根据上面的公式得到：&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1657327/201904/1657327-20190419132959129-477924788.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;　　QUBE算法其实可以多结合自己的项目事例来计算判断一下，因为这个公式是很多年前的了，现在磁盘读写能力肯定有了显著提升，但是判断sql性能的方式是一致的。&lt;/p&gt;


</description>
<pubDate>Fri, 19 Apr 2019 05:34:00 +0000</pubDate>
<dc:creator>流星划过天际</dc:creator>
<og:description>浅谈数据库索引的结构设计与优化 一. 了解数据库索引的必要性 对于稍微数据量大一点的表，如果不适用索引，那么性能效率都会很低；如果绕开了索引，直接进行分区分表，数据库集群读写分离来解决性能问题的话，那</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhaowei520/p/10722697.html</dc:identifier>
</item>
<item>
<title>LearnOpenGL学习笔记（五）——纹理 - zobol</title>
<link>http://www.cnblogs.com/zobol/p/10735365.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zobol/p/10735365.html</guid>
<description>&lt;p&gt;      在设计物体表面时，很多时候我们不满足于一种颜色或者几种简单颜色，我们希望是丰富多彩的图案，或者说我们提供给它的图片。这样一个顶点一个顶点的去指定那是行不通了，我们&lt;span&gt;不可能把所有顶点用数字去表达出来&lt;/span&gt;，必须用一种新的方式去设置颜色。这就是纹理，像用一张画去贴在物体的表面一样，这样就不用指定太多的点，只需要设置“边界”就可以了。我们把这种行为叫做映射。 我们不可能随便映射，我们必须告诉程序三个东西：1.纹理图片剪裁多少（边界坐标位置）2.纹理图片对应的3d面的边界（顶点坐标位置）3将纹理图片的坐标与3d面的坐标一一对应。 &lt;span&gt;&lt;strong&gt;（一）纹理图片设定：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;和标准化坐标一样，纹理的坐标也是从0——1，不过这回没有负值了，不管图片有多么大，我们都将它们认为是在0-1的图片&lt;/span&gt;
&lt;span&gt;坐标系中，其中左下顶点是原点。我们需要三个点构成一个面，所以我们找三个顶点作为表示边界的数据。&lt;/span&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1662138/201904/1662138-20190419132038427-268827914.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;float&lt;/span&gt; texCoords[] = {
    &lt;span class=&quot;hljs-number&quot;&gt;0.0f&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;0.0f&lt;/span&gt;, 
    &lt;span class=&quot;hljs-number&quot;&gt;1.0f&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;0.0f&lt;/span&gt;, 
    &lt;span class=&quot;hljs-number&quot;&gt;0.5f&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;1.0f&lt;/span&gt; 
};&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;（二）处理坐标超出（0，1）设定，纹理环绕方式&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;      不同于openGL的标准化坐标，在超出（-1，1）时候，直接不显示，当纹理坐标超出（0，1）的时候，纹理处理会将图片进行变
化，使图片将贴合的那个面完全包含，OpenGL默认的行为是重复这个纹理图像（我们基本上忽略浮点纹理坐标的整数部分）。
&lt;img src=&quot;https://img2018.cnblogs.com/blog/1662138/201904/1662138-20190419131954229-1125056689.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;
&lt;/pre&gt;


&lt;pre&gt;
&lt;span&gt;
    接下来介绍一个函数，它用来设置种情况，它要放在你创建了一个纹理对象，并且绑定到当前上下文的后面，保证它对这个纹理对象起作用。
&lt;strong&gt;&lt;span&gt;glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT); &lt;/span&gt;&lt;/strong&gt;
&lt;strong&gt;&lt;span&gt;glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_MIRRORED_REPEAT);
&lt;/span&gt;&lt;/strong&gt;第一个参数是表示2d渲染，第二个参数表示这是对那个坐标轴进行的（可以猜测这样可以有好多的组合情况发生），
最后一个参数需要我们传递一个环绕方式，这里设置的是GL_MIRRORED_REPEAT，和&lt;var&gt;GL_REPEAT&lt;/var&gt;一样，但每次重复图片是镜像放置的。
（大多数情况都是这样，但有时候我们还需要指定填充颜色，这个我们一般用这个函数的变形函数，没办法c语言不支持重载）  &lt;/span&gt;
&lt;/pre&gt;

&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;（三）处理放大，缩小情况，纹理过滤&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;：

&lt;/strong&gt;&lt;span&gt;   我们对于物体不可避免要应对放大和缩小的情况。首先我们屏幕的像素点数量是不可能改变的，也就是说，有的时候当你缩小物体的时候
你需要用更小的像素点数量去承载图片，放大的时候你需要用更多的像素点去表现物体，这就是纹理过滤的问题。此外还有一个情况就是当一
个分辨率很高的物体，在很远的地方。我们只能用很少的像素点去表现它。这一系列问题都是这个纹理过滤的原由

    这里需要三个属性作为分析。&lt;span&gt;1.纹理像素 2.纹理顶点 3.屏幕像素&lt;/span&gt;
  首先纹理像素，就是一张图片不断放大后，能发现它是由一个一个点组成的，这就是纹理像素，它由拍摄这张图片的仪器决定，照片大小不变
它不变。
  之后是纹理顶点，这个从（0，1）的绝对坐标组，不受分辨率影响，所以所以OpenGL需要知道怎样将纹理像素(Texture Pixel，也叫Texel，
译注1)映射到纹理坐标。
  最后是屏幕像素，OpenGL根据纹理顶点坐标，查找纹理图片上的像素，再根据纹理像素判断分析，提取出一个颜色值，放置到屏幕像素上。
纹理过滤主要就是考虑如何分析判断。目前提供两种过滤GL_NEAREST（颗粒状的图案），&lt;var&gt;GL_LINEAR（&lt;/var&gt;更平滑的图案）。
&lt;img src=&quot;https://learnopengl-cn.github.io/img/01/06/filter_nearest.png&quot; alt=&quot;&quot; width=&quot;185&quot; height=&quot;115&quot;/&gt;&lt;img src=&quot;https://learnopengl-cn.github.io/img/01/06/filter_linear.png&quot; alt=&quot;&quot; width=&quot;182&quot; height=&quot;113&quot;/&gt;&lt;img src=&quot;https://learnopengl-cn.github.io/img/01/06/texture_filtering.png&quot; alt=&quot;&quot; width=&quot;348&quot; height=&quot;180&quot;/&gt;&lt;strong&gt;&lt;span&gt;glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST); &lt;/span&gt;&lt;/strong&gt;
&lt;strong&gt;&lt;span&gt;glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);&lt;/span&gt;&lt;/strong&gt;

&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;（四）处理物体远近情况，多级渐远纹理&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;
&lt;span&gt;   接下来我们考虑之前说的一个问题，当一个纹理分辨率很高的物体，在很远的地方，我们只能用很少的屏幕像素点去表示它。
OpenGL从高分辨率纹理中为这些片段获取正确的颜色值就很困难，因为它需要对一个跨过纹理很大部分的片段只拾取一个纹理颜色。在小物
体上这会产生不真实的感觉，对它们使用高分辨率纹理浪费内存的问题。这就是用多级渐远纹理的原因。
  这是一种用“空间换时间”的手段。多级渐远纹理背后的理念很简单：距观察者的距离超过一定的阈值，OpenGL会使用不同的多级渐远纹理，
即最适合物体的距离的那个。
&lt;img src=&quot;https://learnopengl-cn.github.io/img/01/06/mipmaps.png&quot; alt=&quot;&quot;/&gt;
注意每个二分之一的图片它们的纹理像素只有之前的四分之一多。&lt;span&gt;这一步必须在加载图片成功之后再执行。
&lt;span&gt;这个负责函数是glGenerateMipmaps（），此外也可以为这种缩小或者放大，指定纹理过滤形式。
&lt;strong&gt;&lt;span&gt;glGenerateMipmap(GL_TEXTURE_2D);
&lt;/span&gt;&lt;/strong&gt;这个参数跟VBO,VAO类似，代表了绑定在这个属性上的纹理对象。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;（五）加载与创建纹理：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;  接下来我们要把存储在文件中的图片转化成二进制流，让OpenGL识别，由于图片格式有很多种，我们要写很多读取函数去读，
这些函数我们当然不必自己去写，引用一个开源的支持多种流行格式的图像加载库就好了。stb_image.h库是我们用的。
我们引用一个stbi_load函数去加载图片文件好了。
&lt;strong&gt;&lt;span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; width, height, nrChannels; &lt;/span&gt;&lt;/strong&gt;
&lt;strong&gt;&lt;span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;char&lt;/span&gt; *data = stbi_load(&lt;span class=&quot;hljs-string&quot;&gt;&quot;container.jpg&quot;&lt;/span&gt;, &amp;amp;width, &amp;amp;height, &amp;amp;nrChannels, &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;);
&lt;/span&gt;&lt;/strong&gt;第一个参数接受一个图像文件的位置，剩下三个是宽度、高度和颜色通道的个数，最后一个填0.暂时不管。&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;（六）生成纹理：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;使用前面载入的图片数据生成一个纹理&lt;/strong&gt;&lt;span&gt;   接下来就是生成纹理了，首先我们需要一个纹理对象作为处理对象，毕竟前面我们一直在做图片的工作，那些属性的设置都需要一个
对象去承载它们。
//ID引用生成对象
&lt;strong&gt;&lt;span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; texture; &lt;/span&gt;&lt;/strong&gt;
&lt;strong&gt;&lt;span&gt;glGenTextures(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &amp;amp;texture);
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;//绑定2d纹理目标（属性），之前的哪些纹理过滤也是这个时候用&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;
glBindTexture(GL_TEXTURE_2D, texture);
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;//使用前面载入的图片数据生成一个纹理，用的生成函数为glTexImage2D，用处就是根据数据生成纹理
&lt;strong&gt;&lt;span&gt;glTexImage2D(GL_TEXTURE_2D, &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, GL_RGB, width, height, &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, GL_RGB, GL_UNSIGNED_BYTE, data); &lt;/span&gt;&lt;/strong&gt;
&lt;strong&gt;&lt;span&gt;glGenerateMipmap(GL_TEXTURE_2D);
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;//&lt;/span&gt;&lt;/span&gt;第一个参数指定了纹理目标(Target)。第二个参数为纹理指定多级渐远纹理的级别。这里我们填0，也就是基本级别（不自动生成）。
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;//第三个参数告诉OpenGL我们希望把纹理储存为何种格式。我们的图像只有&lt;code&gt;RGB&lt;/code&gt;值，因此我们也把纹理储存为&lt;code&gt;RGB&lt;/code&gt;值 &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;//第四个和第五个参数设置最终的纹理的宽度和高度。我们之前加载图像的时候储存了它们，所以我们使用对应的变量。 &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;//下个参数应该总是被设为0（历史遗留的问题）。 &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;//第七第八个参数定义了源图的格式和数据类型。我们使用RGB值加载这个图像，并把它们储存为char(byte)数组，我们将会传入对应值。 //最后一个参数是真正的图像数据。 &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;生成纹理和多纹渐进纹理之后，我们就不需要图片数据了，这时释放它们，不要占用内存了&lt;/span&gt;&lt;/span&gt;&lt;strong&gt; &lt;span&gt;stbi_image_free(data); &lt;/span&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;（七）将纹理对象传给着色器，显示到屏幕上：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;     严格来讲之前我们只是去处理了图片数据和纹理对象，如果我们想看到纹理的样子，我们就必须用着色器去显示。
我们要把纹理对象传递到着色器内部，然后告诉它如何去显示到3d图形的每个点上。
顶点着色器：
&lt;strong&gt;&lt;span&gt;&lt;span class=&quot;hljs-preprocessor&quot;&gt;#version 330 core&lt;/span&gt; layout (location = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;) in vec3 aPos; &lt;/span&gt;&lt;/strong&gt;
&lt;strong&gt;&lt;span&gt;layout (location = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;) in vec3 aColor; &lt;/span&gt;&lt;/strong&gt;
&lt;strong&gt;&lt;span&gt;layout (location = &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;) in vec2 aTexCoord; &lt;/span&gt;&lt;/strong&gt;
&lt;strong&gt;&lt;span&gt;out vec3 ourColor; &lt;/span&gt;&lt;/strong&gt;
&lt;strong&gt;&lt;span&gt;out vec2 TexCoord; &lt;/span&gt;&lt;/strong&gt;

&lt;strong&gt;&lt;span&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{ &lt;/span&gt;&lt;/strong&gt;
&lt;strong&gt;&lt;span&gt;gl_Position = vec4(aPos, &lt;span class=&quot;hljs-number&quot;&gt;1.0&lt;/span&gt;); &lt;/span&gt;&lt;/strong&gt;
&lt;strong&gt;&lt;span&gt;ourColor = aColor; &lt;/span&gt;&lt;/strong&gt;
&lt;strong&gt;&lt;span&gt;TexCoord = aTexCoord; &lt;/span&gt;&lt;/strong&gt;
&lt;strong&gt;&lt;span&gt;}

&lt;/span&gt;&lt;/strong&gt;把数据（纹理数据坐标）读进来，传到片段着色器，此外我们这个时候要从程序CPU把纹理对象传入着色器了，这个最好用之前的uniform
&lt;strong&gt;&lt;span class=&quot;hljs-preprocessor&quot;&gt;#version 330 core &lt;/span&gt;&lt;/strong&gt;
&lt;strong&gt;&lt;span&gt;out vec4 FragColor; &lt;/span&gt;&lt;/strong&gt;
&lt;strong&gt;&lt;span&gt;in vec3 ourColor; &lt;/span&gt;&lt;/strong&gt;
&lt;strong&gt;&lt;span&gt;in vec2 TexCoord; &lt;/span&gt;&lt;/strong&gt;
&lt;strong&gt;&lt;span&gt;uniform sampler2D ourTexture; &lt;/span&gt;&lt;/strong&gt;
&lt;strong&gt;&lt;span&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{ &lt;/span&gt;&lt;/strong&gt;
&lt;strong&gt;&lt;span&gt;FragColor = texture(ourTexture, TexCoord); &lt;/span&gt;&lt;/strong&gt;
&lt;strong&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;texture函数来采样纹理的颜色，它第一个参数是纹理采样器，第二个参数是对应的纹理坐标。&lt;/span&gt;&lt;/span&gt;
&lt;span&gt;&lt;span&gt;texture函数会使用之前设置的纹理参数对相应的颜色值进行采样。这个片段着色器的输出就是纹理的（插值）纹理坐标上的(过滤后的)颜色。

&lt;/span&gt;&lt;/span&gt;那怎么把纹理对象赋值给着色器呢，这个不用咱们去做，咱们只需要绑定纹理对象，绑定VAO，就可调用绘制函数了，纹理对象会自动传入的。
&lt;strong&gt;&lt;span&gt;glBindTexture(GL_TEXTURE_2D, texture); &lt;/span&gt;&lt;/strong&gt;
&lt;strong&gt;&lt;span&gt;glBindVertexArray(VAO); &lt;/span&gt;&lt;/strong&gt;
&lt;strong&gt;&lt;span&gt;glDrawElements(GL_TRIANGLES, &lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;, GL_UNSIGNED_INT, &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;/strong&gt;


&lt;/span&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 19 Apr 2019 05:22:00 +0000</pubDate>
<dc:creator>zobol</dc:creator>
<og:description>在设计物体表面时，很多时候我们不满足于一种颜色或者几种简单颜色，我们希望是丰富多彩的图案，或者说我们提供给它的图片。这样一个顶点一个顶点的去指定那是行不通了，我们不可能把所有顶点用数字去表达出来，必须</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zobol/p/10735365.html</dc:identifier>
</item>
<item>
<title>分布式系列十三: nginx - 罪恶斯巴克</title>
<link>http://www.cnblogs.com/walkinhalo/p/10735292.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/walkinhalo/p/10735292.html</guid>
<description>&lt;p&gt;&lt;em&gt;nginx偏运维, 不过作为开发应该了解它能做什么事情, 其作为技术架构的一部分必不可少&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;正向代理和反向代理&quot;&gt;正向代理和反向代理&lt;/h2&gt;
&lt;p&gt;正向代理是代理的客户端, 反向代理是代理的服务端. nginx就是一款可以作反向代理的web服务器.&lt;/p&gt;
&lt;h2 id=&quot;常见的web服务器&quot;&gt;常见的Web服务器&lt;/h2&gt;
&lt;p&gt;Apache, Nginx,Tomcat,WebLogic, iis, jetty, undertowe, resin&lt;/p&gt;
&lt;p&gt;Apache,Nginx 是同一类型的服务器, 都可以提供反向代理功能.&lt;/p&gt;
&lt;p&gt;web服务器按提供的内容可以划分为动态web服务器和静态web服务器, 静态web服务器提供静态的文件内容, 比如html,css,js,image等, 动态web服务器提供动态内容, 如jsp,asp等经过服务器程序运行输出的页面.&lt;/p&gt;
&lt;h2 id=&quot;nginx的安装&quot;&gt;Nginx的安装&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;tar -zxvf 安装包&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;./configure --prefix=/user/nginx&lt;/code&gt; 没有则默认安装到/user/local/nginx&lt;/li&gt;
&lt;li&gt;如果报缺少pcre包, 需要安装&lt;code&gt;sudo apt-get install libpcre3 libpcre3-dev&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果缺少zlib包, 需要安装&lt;code&gt;sudo apt-get install zlib1g-dev&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;make&lt;/code&gt; 以及 &lt;code&gt;make install&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;命令&quot;&gt;命令&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;启动: &lt;code&gt;./nginx -c /user/data/nginx/conf/nginx.conf&lt;/code&gt; -c 表示指定nginx.conf文件, 默认为NGINX-HOME/conf/nginx.conf&lt;/li&gt;
&lt;li&gt;命令方式停止:&lt;br/&gt;&lt;code&gt;./nginx -s stop&lt;/code&gt;&lt;br/&gt;&lt;code&gt;./nginx -s quit&lt;/code&gt;&lt;br/&gt;&lt;code&gt;./nginx -s reload&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;发送信号的方式停止:&lt;br/&gt;&lt;code&gt;kill -QUIT pid&lt;/code&gt; pid是进程号. 安全停止, 可以使正在处理的停止&lt;br/&gt;&lt;code&gt;kill -TERM pid&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;进程模型&quot;&gt;进程模型&lt;/h2&gt;
&lt;p&gt;多进程模型: 主进程fork出一个进程处理请求.nginx的方式.&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;多线程模型: 可能有并发问题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;异步方式: 每个进程采用异步非阻塞模型处理请求.&lt;/p&gt;
&lt;h2 id=&quot;配置&quot;&gt;配置&lt;/h2&gt;
&lt;p&gt;主要分三部分:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;work_processes 2; //工作进程数, 一般为cpu核数
work_cpu_affinity 01 10 
error_log /var/log/nginx/error.log warn; //错误日志
worker_rlimit_nofile 10240; // 最大打开文件数&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;event{
    use epoll ; // 选项有 select poll epoll kqueue等
    work_connections 10240; //连接数
    accept_mutex off; //off 可以提高效率
}

http{
    include mime.types;
    default_type application/octet-stream; //默认mime
    charset utf-8;
    access_log off;
    sendfile on;
    gzip on;
    ....
    proxy_temp_path /data/
    proxy_cache_path /data/cache; level=1:2
    inclued /etc/nginx/conf.d/*.conf;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;虚拟主机&quot;&gt;虚拟主机&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;基于域名&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面配置一个虚拟主机:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;server{
    listen 80;
    server_name www.my.com;
    location / {
        root html/domain;
        index index.html index.htm;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;基于IP&lt;/li&gt;
&lt;li&gt;基于端口&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;server{
    listen 8080;
    server_name localhost;
    location / {
        root html/domain;
        index index.html index.htm;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;nginx日志配置&quot;&gt;nginx日志配置&lt;/h3&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;log_format formatName '.....' //日志格式
access_log logs/logfile.log  formatName //指定日志路径和格式&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;日志切割&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mv access.log access.log.001&lt;/code&gt; 然后重启生成, 可以写个运维脚本, 定时执行&lt;/p&gt;
&lt;h3 id=&quot;location-的语法和匹配规则&quot;&gt;location 的语法和匹配规则&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;=&lt;/code&gt; 是精确匹配, 如&lt;code&gt;=/mypage.html&lt;/code&gt; 优先级最高(类似servlet规范的url的优先级规则)&lt;/p&gt;
&lt;p&gt;一般匹配, 优先级高于正则匹配, 如:&lt;code&gt;/myroot/mydir/mypage/&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;正则匹配, 如&lt;code&gt;^~ /prefix/my/jsp&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;location[~|=|^~|~*]/uri{

}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;rewrite-使用&quot;&gt;rewrite 使用&lt;/h2&gt;
&lt;p&gt;使用 rewrite 支持 url 重写. 支持 &lt;code&gt;if&lt;/code&gt;,&lt;code&gt;return&lt;/code&gt;语句.&lt;/p&gt;
&lt;p&gt;只能在server/location/if中使用. 只能对域名后除去参数外的字符串起作用.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;if(条件){}&lt;/code&gt;: 条件可以是 &lt;code&gt;=&lt;/code&gt; 或者 &lt;code&gt;~&lt;/code&gt; 后者表示一个正则, 如&lt;code&gt;if($request_uri~*\.sh){ return 403; }&lt;/code&gt; 表示如果请求是.sh结尾的, 则返回403.&lt;/p&gt;
&lt;h3 id=&quot;rewrite的语法&quot;&gt;rewrite的语法&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;rewrite regex replacement[flag]{last/break/redirect/permant}&lt;/code&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;last 停止处理后续的rewrite 指令集, 然后对当前重写的uri在 rewrite 指令集上重新查找; break则不会重新查找;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;//重定向到百度
location / {
    rewrite ^/ http://www.baidu.com ;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;location / {
    rewrite '^/images/([a-z]{3})/(.*)\.(png)$' /images?file=$2.$3 ;
    set $image_file $2;
    set $image_type $3;
}
loation /images {
    root html;
    try_files /$arg_file /image404.html; 
}
location =/image404.html{
    return 404 &quot;image not found&quot;;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;浏览器本地缓存&quot;&gt;浏览器本地缓存&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;expires 60s&lt;/code&gt; s|m|h|d 可用的时间单位&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;server{
    listen 80;
    server_name localhost;
    location /{
        root html;
        index index.html index.htm
    }
    location ~ \.(png|jpg|js|css|gif)${
        root html/images;
        expires 60s
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;gzip-压缩&quot;&gt;Gzip 压缩&lt;/h3&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;server{
    ...
    gzip on;
    gzip_buffers 4 16k  //16k为单位, 4倍申请
    gzip_comp_level 4;  //0-9
    gzip_min_length 500;  //最小压缩大小,小于此大小不压缩
    gzip_types text/css; //压缩的mime类型
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;反向代理&quot;&gt;反向代理&lt;/h3&gt;
&lt;p&gt;为了方便单独配置, 新增 &lt;code&gt;proxy.conf&lt;/code&gt; 然后在主文件中的&lt;code&gt;http&lt;/code&gt;节点添加&lt;code&gt;include /path/proxy.conf&lt;/code&gt; 当然也可以直接修改&lt;code&gt;nginx.conf&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;location =/s {
    proxt_set_header Host $host
    proxt_set_header X-Real_IP $remote_addr // 设置请求的真实ip
    proxy_set_header interface_version $Host //版本号
    proxy_pass http://www.baidu.com;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;负载均衡&quot;&gt;负载均衡&lt;/h3&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;upstream tomcatserver{
    ip_hash; // 也可以不配置,不配置则轮训策略, 或者配置为fair(按响应时间),utl_hash
    server 192.168.1.122:8080;
    server 192.168.1.123:8080 weight=4; //如果是轮训, 则权重起作用
}

// 修改proxy_pass节点为负载均衡
prox_pass http://tomcatserver&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;配置https&quot;&gt;配置https&lt;/h3&gt;
&lt;p&gt;生成证书:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;openssl genrsa -des3 -out server.key 1024&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;openssl req -new -key server.key -out server.csr&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cp server.key server.key.org&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;openssl rsa -in server.key.org -out server.key&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;openssl x509 -req -days 365 -in server.csr -signkey server.key -out server.crt&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;配置:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;server{
    listen 443;
    server_name www.myhost.com;
    ssl on;
    ssl_certificate /my/host/conf/server.crt;
    ssl_certificate_key /my/host/conf/server.key;
    location / {
        proxy_pass http://myhost;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改tomcat配置(最后两个配置新增): 这个可以不配置, 走http&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;Connector port=&quot;8080&quot; protocal=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; 
proxyPort=&quot;443&quot; redirectPort=&quot;443&quot; /&amp;gt; &lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;nginxkeepalived-相当于nginx主从&quot;&gt;nginx+keepalived (相当于nginx主从)&lt;/h2&gt;
&lt;p&gt;基于 VRRP(虚拟路由器冗余协议);&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;下载解压keepalived包&lt;/li&gt;
&lt;li&gt;配置&lt;code&gt;./configure --prefix=/mydir/keepalived/ --sysconf=/etc&lt;/code&gt; 最后一个参数是表明把配置文件存储到指定目录下&lt;/li&gt;
&lt;li&gt;&lt;code&gt;make &amp;amp; make install&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ln -s /.../sbin/keepalived /sbin&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cp /etc/init.d/keepalived /etc/init.d/&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;chkconfig --add keepalived&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;chkconfig keeepalived on&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;修改keepalived.conf文件&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;vrrp_instance_VI_1{
    state MASTER  // 另一台为BACKUP
    interface eth0 //网卡端口, ifconfig后修改为正确端口
    virtual_router_id 51 //主从保持一致
    priority 100 //master必须大于backup, 大的节点会变成master
    ...
    virtual_ipaddress{ //虚拟服务器ip
        192.168.1.123
        192.168.1.124
    }
}

vitrual_server 192.168.1.123{
    delay_loop 6
    lb_glgo rr //loadbalance 算法
    ...

    real_server 192.168.11.123{
        weight 1 //权重
        TCP_CHECK{
            connect_timeout 3
            delay_before_retry 3
            connect_port 80
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 19 Apr 2019 05:03:00 +0000</pubDate>
<dc:creator>罪恶斯巴克</dc:creator>
<og:description>nginx偏运维, 不过作为开发应该了解它能做什么事情, 其作为技术架构的一部分必不可少 正向代理和反向代理 正向代理是代理的客户端, 反向代理是代理的服务端. nginx就是一款可以作反向代理的we</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/walkinhalo/p/10735292.html</dc:identifier>
</item>
</channel>
</rss>