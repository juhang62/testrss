<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>重磅来袭 Vue 3.0 One Piece 正式发布 - sjpqy</title>
<link>http://www.cnblogs.com/shenjp/p/13694601.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shenjp/p/13694601.html</guid>
<description>&lt;p&gt;&lt;strong&gt;代号为One Piece 的Vue3.0 在9月19日凌晨正式发布！！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;此次vue3.0 为用户提供了全新的 composition-api 以及更小的包大小，和更好的 TypeScript 支持。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/vuejs/vue-next/releases/tag/v3.0.0&quot; rel=&quot;nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;发布地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/vuejs/vue-next&quot; rel=&quot;nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Vue-next&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Vue3.0 是当前非常流行的框架，Vue3.0更是酝酿了2年多的时间，经过2600多次commit，600多次PR，中间也发布了很多beta版本。&lt;/p&gt;
&lt;p&gt;终于在经过尤大神和社区的共同努力下，Vue3.0带着全新的 &lt;a href=&quot;https://vue-composition-api-rfc.netlify.app/&quot; rel=&quot;nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;composition-api&lt;/a&gt; 正式发布了。&lt;/p&gt;
&lt;p&gt;一起发布的新特性还有：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://v3.vuejs.org/guide/teleport.html&quot; rel=&quot;nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Teleport 组件&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://v3.vuejs.org/guide/migration/global-api-treeshaking.html#_2-x-syntax&quot; rel=&quot;nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Treeshaking的全新API&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://v3.vuejs.org/&quot; rel=&quot;nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Vue3.0官方文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;也可以再在线体验Vue3.0: &lt;a href=&quot;https://codepen.io/yyx990803/pen/OJNoaZL&quot; rel=&quot;nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;codepen.io/yyx990803/p…&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&amp;lt;template&amp;gt;
  &amp;lt;div id=&quot;app&quot;&amp;gt;
    &amp;lt;h1&amp;gt;{{message}}&amp;lt;/h1&amp;gt;

    &amp;lt;p&amp;gt;&lt;span&gt;
      Learn more &lt;/span&gt;&lt;span&gt;with&lt;/span&gt;&lt;span&gt; the
      &lt;/span&gt;&amp;lt;&lt;span&gt;a
        href&lt;/span&gt;=&quot;https://v3.vuejs.org/&quot;&lt;span&gt;
        target&lt;/span&gt;=&quot;_blank&quot;&lt;span&gt;
        rel&lt;/span&gt;=&quot;noopener&quot;
      &amp;gt;Vue Docs &amp;amp;amp; Resources&amp;lt;/a&amp;gt;.
    &amp;lt;/p&amp;gt;

    &amp;lt;button @click=&quot;doSomething&quot;&amp;gt;Say hello.&amp;lt;/button&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;&lt;span&gt;
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {
  data() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
      message: &lt;/span&gt;'Welcome to Vue 3!'&lt;span&gt;
    };
  },
  methods: {
    doSomething() {
      alert(&lt;/span&gt;'Hello!'&lt;span&gt;);
    }
  }
};
&lt;/span&gt;&amp;lt;/script&amp;gt;

&amp;lt;!-- Use preprocessors via the lang attribute! e.g. &amp;lt;style lang=&quot;scss&quot;&amp;gt; --&amp;gt;
&amp;lt;style&amp;gt;&lt;span&gt;
#app {
  font&lt;/span&gt;-family: Avenir, Helvetica, Arial, sans-&lt;span&gt;serif;
  text&lt;/span&gt;-&lt;span&gt;align: center;
  color: #2c3e50;
  margin&lt;/span&gt;-&lt;span&gt;top: 60px;
}

a,
button {
  color: #4fc08d;
}

button {
  background: none;
  border: solid 1px;
  border&lt;/span&gt;-&lt;span&gt;radius: 2em;
  font: inherit;
  padding: &lt;/span&gt;0&lt;span&gt;.75em 2em;
}
&lt;/span&gt;&amp;lt;/style&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre&gt;
&lt;code class=&quot;copyable&quot;&gt; &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有兴趣也可以观看尤大神在19号凌晨发布的视频&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://m.youtube.com/watch?v=Vp5ANvd88x0&quot; rel=&quot;nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;m.youtube.com/watch?v=Vp5…&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;直播中尤大神也讲诉了整个Vue3.0 的历程，同时也介绍了一些新的特性。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1094267/202009/1094267-20200919082622939-567337027.png&quot; alt=&quot;&quot; width=&quot;690&quot; height=&quot;356&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1094267/202009/1094267-20200919082642746-146331987.png&quot; alt=&quot;&quot; width=&quot;704&quot; height=&quot;366&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1094267/202009/1094267-20200919082709222-2001321170.png&quot; alt=&quot;&quot; width=&quot;719&quot; height=&quot;368&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt;另外，所有的官方生态库和工具，例如vue-cli、vue-router、vuex、Vue-Test-utils、vue devtools、VSCode插件Vetur，现在都支持Vue3，但大多数仍然处于beta状态，并在NPM的&quot;next&quot;标签目录下发布。&lt;/p&gt;
&lt;p&gt;官方计划在2020年年底之前稳定所有项目并将其转换为使用&quot;latest&quot;标签。&lt;/p&gt;
&lt;p&gt;官方发布的推文&lt;/p&gt;

&lt;img src=&quot;https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c22652022424488585f5940946dc7223~tplv-k3u1fbpfcp-zoom-1.image&quot; width=&quot;539&quot; height=&quot;976&quot; class=&quot;lazyload inited loaded&quot; data-src=&quot;https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c22652022424488585f5940946dc7223~tplv-k3u1fbpfcp-zoom-1.image&quot; data-width=&quot;800&quot; data-height=&quot;600&quot;/&gt;
&lt;p&gt;Vue 3.0 正式版&lt;/p&gt;

&lt;img src=&quot;https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e1a6749cab74dde9e7de5d55e8624c0~tplv-k3u1fbpfcp-zoom-1.image&quot; width=&quot;1066&quot; height=&quot;601&quot; class=&quot;lazyload inited loaded&quot; data-src=&quot;https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e1a6749cab74dde9e7de5d55e8624c0~tplv-k3u1fbpfcp-zoom-1.image&quot; data-width=&quot;800&quot; data-height=&quot;600&quot;/&gt;
</description>
<pubDate>Sat, 19 Sep 2020 00:30:00 +0000</pubDate>
<dc:creator>sjpqy</dc:creator>
<og:description>代号为One Piece 的Vue3.0 在9月19日凌晨正式发布！！ 此次vue3.0 为用户提供了全新的&amp;#160;composition-api 以及更小的包大小，和更好的 TypeScript</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/shenjp/p/13694601.html</dc:identifier>
</item>
<item>
<title>Java程序员必备基础：JDK 5-15都有哪些经典新特性 - Jay_huaxiao</title>
<link>http://www.cnblogs.com/jay-huaxiao/p/13694593.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jay-huaxiao/p/13694593.html</guid>
<description>&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;前言&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JDK 15发布啦~ 我们一起回顾JDK 5-15 的新特性吧，大家一起学习哈~&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文已经收录到github&lt;/p&gt;
&lt;blockquote data-tool=&quot;mdnice编辑器&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;❝&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;https://github.com/whx123/JavaHome&lt;/p&gt;
&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;公众号：捡田螺的小男孩&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;Java 5 新特性&lt;/span&gt;&lt;/h3&gt;
&lt;img src=&quot;https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/03f5d66e89bb4cd49e85fbfd795f204d~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;1. 泛型&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;泛型本质是参数化类型，解决不确定具体对象类型的问题。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt; List&amp;lt;String&amp;gt; strList=new ArrayList&amp;lt;String&amp;gt;();&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;2. 增强循环（for-each）&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;for-each循环简化了集合的遍历。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;String [] str = {&lt;span class=&quot;hljs-string&quot;&gt;&quot;关注&quot;&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;&quot;公众号&quot;&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;&quot;捡田螺的小男孩&quot;&lt;/span&gt;};&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (String temp:str) {&lt;br/&gt;System.out.println(temp);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;3. 自动封箱拆箱&lt;/span&gt;&lt;/h4&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;自动装箱: 就是将基本数据类型自动转换成对应的包装类。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;自动拆箱：就是将包装类自动转换成对应的基本数据类型。&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;包装类型有：Integer,Double,Float,Long,Short,Character和Boolean&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;Integer i =666;  //自动装箱&lt;br/&gt;int a= i;     //自动拆箱&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;4. 枚举&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关键字enum可以将一组具名的值的有限集合创建为一种新的类型，而这些具名的值可以作为常规的程序组件使用，这就是枚举类型。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;enum SeasonEnum {&lt;br/&gt;SPRING,SUMMER,FALL,WINTER;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;5. 可变参数&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在定义方法参数的时候不确定定义多少个，就可以定义为&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;可变参数&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;，它本质上是一个&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;数组&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;public static void main(String[] args) throws Exception {&lt;br/&gt;String [] str = {&lt;span class=&quot;hljs-string&quot;&gt;&quot;关注&quot;&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;&quot;公众号&quot;&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;&quot;捡田螺的小男孩&quot;&lt;/span&gt;};&lt;br/&gt;testVarargs(str);&lt;br/&gt;String str1 = &lt;span class=&quot;hljs-string&quot;&gt;&quot;关注公众号，捡田螺的小男孩&quot;&lt;/span&gt;;&lt;br/&gt;testVarargs(str1);&lt;br/&gt;}&lt;br/&gt;//可变参数String... args&lt;br/&gt;private static void testVarargs(String... args) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (String arg : args) {&lt;br/&gt;System.out.println(arg);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;6. 注解&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以把注解理解为代码里的特殊标记，这些标记可以在编译，类加载，运行时被读取，并执行相应的处理。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;@Target(ElementType.METHOD)&lt;br/&gt;@Retention(RetentionPolicy.SOURCE)&lt;br/&gt;public @interface Override {&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;7.静态导入&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过import static类，就可以使用类里的静态变量或方法。看一下例子哈~&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;import static java.lang.System.out; //静态导入System类的静态变量out&lt;br/&gt;public class Test {&lt;br/&gt;public static void main(String[] args) throws Exception {&lt;br/&gt;String str1 = &lt;span class=&quot;hljs-string&quot;&gt;&quot;关注公众号，捡田螺的小男孩&quot;&lt;/span&gt;;&lt;br/&gt;System.out.println(str1); //常规写法&lt;br/&gt;out.println(str1);  //静态导入，可以直接使用out输出&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;8. 线程并发库（JUC）&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JDK5 丰富了线程处理功能，java.util.concurrent包提供了以下的类、接口：&lt;/p&gt;
&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;p&gt;&lt;span&gt;❝&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;section&gt;线程池：ExecutorService接口&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;线程护斥：Lock 类&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;线程通信：Condition接口&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;同步队列：ArrayBlockingQueue类&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;同步集合：ConcurrentHashMap类&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;Java 6 新特性&lt;/span&gt;&lt;/h3&gt;
&lt;img src=&quot;https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a91df99e8eb948e7a208d7222eb162cf~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;1.Desktop类和SystemTray类&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JDK 6在java.awt包下，新增了两个类：Desktop类和SystemTray类&lt;/p&gt;
&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;p&gt;&lt;span&gt;❝&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;section&gt;&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;Desktop类&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;: 用来打开系统默认浏览器浏览指定的URL,打开系统默认邮件客户端发邮件等&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;SystemTray类&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;:用来在系统托盘区创建一个托盘程序,如果在微软的Windows上，它被称为“任务栏”状态区域。&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;//获取Desktop实例&lt;br/&gt;Desktop desktop = Desktop.getDesktop();&lt;br/&gt;desktop.browse(URI.create(&lt;span class=&quot;hljs-string&quot;&gt;&quot;https://www.baidu.com&quot;&lt;/span&gt;));&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;2. 使用JAXB2来实现对象与XML之间的映射&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JAXB,即Java Architecture for XML Binding,可以实现对象与XML之间的映射，常用注解如下:&lt;/p&gt;
&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;p&gt;&lt;span&gt;❝&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;section&gt;@XmlRootElement：注解在类上面，对应xml的跟元素，使用name属性定义根节点的名称。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;@XmlElement：指定一个字段或get/set方法映射到xml的节点，使用name属性定义这个根节点的名称。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;@XmlAttribute：将JavaBean对象的属性映射为xml的属性,使用name属性为生成的xml属性指定别名。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;@XmlAccessorType:定义映射这个类中的何种类型都需要映射到xml。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;@XmlSchema: 将包映射到XML名称空间&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;看个例子吧~&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;20.5&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;35&quot;&gt;public class JAXB2XmlTest {&lt;p&gt;public static void main(String[] args) throws JAXBException, IOException {&lt;/p&gt;&lt;p&gt;List&amp;lt;Singer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;list.add(new Singer(&lt;span class=&quot;hljs-string&quot;&gt;&quot;jay&quot;&lt;/span&gt;, 8));&lt;br/&gt;list.add(new Singer(&lt;span class=&quot;hljs-string&quot;&gt;&quot;eason&quot;&lt;/span&gt;, 10));&lt;/p&gt;&lt;p&gt;SingerList singerList = new SingerList();&lt;br/&gt;singerList.setSingers(list);&lt;/p&gt;&lt;p&gt;String str = JAXB2XmlTest.beanToXml(singerList, SingerList.class);&lt;br/&gt;String path = &lt;span class=&quot;hljs-string&quot;&gt;&quot;C:\\jay.txt&quot;&lt;/span&gt;;&lt;br/&gt;BufferedWriter bfw = new BufferedWriter(new FileWriter(new File(path)));&lt;br/&gt;bfw.write(str);&lt;br/&gt;bfw.close();&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;private static String beanToXml(Object obj, Class&amp;lt;?&amp;gt; load) throws JAXBException {&lt;br/&gt;JAXBContext context = JAXBContext.newInstance(load);&lt;br/&gt;Marshaller marshaller = context.createMarshaller();&lt;br/&gt;marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;);&lt;br/&gt;marshaller.setProperty(Marshaller.JAXB_ENCODING, &lt;span class=&quot;hljs-string&quot;&gt;&quot;GBK&quot;&lt;/span&gt;);&lt;br/&gt;StringWriter writer = new StringWriter();&lt;br/&gt;marshaller.marshal(obj,writer);&lt;br/&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;return&lt;/span&gt; writer.toString();&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;public class Singer {&lt;/p&gt;&lt;p&gt;private String name;&lt;br/&gt;private int age;&lt;br/&gt;public Singer(String name, int age) {&lt;br/&gt;this.name = name;&lt;br/&gt;this.age = age;&lt;br/&gt;}&lt;br/&gt;@XmlAttribute(name=&lt;span class=&quot;hljs-string&quot;&gt;&quot;name&quot;&lt;/span&gt;)&lt;br/&gt;public String &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;getName&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;return&lt;/span&gt; name;&lt;br/&gt;}&lt;br/&gt;public void setName(String name) {&lt;br/&gt;this.name = name;&lt;br/&gt;}&lt;br/&gt;@XmlAttribute(name=&lt;span class=&quot;hljs-string&quot;&gt;&quot;age&quot;&lt;/span&gt;)&lt;br/&gt;public int &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;getAge&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;return&lt;/span&gt; age;&lt;br/&gt;}&lt;br/&gt;public void setAge(int age) {&lt;br/&gt;this.age = age;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;@XmlRootElement(name=&lt;span class=&quot;hljs-string&quot;&gt;&quot;list&quot;&lt;/span&gt;)&lt;br/&gt;public class SingerList {&lt;/p&gt;&lt;p&gt;private List&amp;lt;Singer&amp;gt; singers;&lt;/p&gt;&lt;p&gt;@XmlElement(name=&lt;span class=&quot;hljs-string&quot;&gt;&quot;singer&quot;&lt;/span&gt;)&lt;br/&gt;public List&amp;lt;Singer&amp;gt; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;getSingers&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;return&lt;/span&gt; singers;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;public void setSingers(List&amp;lt;Singer&amp;gt; singers) {&lt;br/&gt;this.singers = singers;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;运行效果：&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&amp;lt;?xml version=&lt;span class=&quot;hljs-string&quot;&gt;&quot;1.0&quot;&lt;/span&gt; encoding=&lt;span class=&quot;hljs-string&quot;&gt;&quot;GBK&quot;&lt;/span&gt; standalone=&lt;span class=&quot;hljs-string&quot;&gt;&quot;yes&quot;&lt;/span&gt;?&amp;gt;&lt;br/&gt;&amp;lt;list&amp;gt;&lt;br/&gt;&amp;lt;singer age=&lt;span class=&quot;hljs-string&quot;&gt;&quot;8&quot;&lt;/span&gt; name=&lt;span class=&quot;hljs-string&quot;&gt;&quot;jay&quot;&lt;/span&gt;/&amp;gt;&lt;br/&gt;&amp;lt;singer age=&lt;span class=&quot;hljs-string&quot;&gt;&quot;10&quot;&lt;/span&gt; name=&lt;span class=&quot;hljs-string&quot;&gt;&quot;eason&quot;&lt;/span&gt;/&amp;gt;&lt;br/&gt;&amp;lt;/list&amp;gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;3.轻量级 Http Server API&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JDK 6中提供了简单的Http Server API，可以构建嵌入式Http服务器,同时支持Http和Https协议。HttpServer会调用HttpHandler实现类的回调方法来处理客户端请求,这里用户只需实现HttpHandler接口就可以了。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;13&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;20&quot;&gt;/**&lt;br/&gt;* 根据Java提供的API实现Http服务器&lt;br/&gt;*/&lt;br/&gt;public class MyHttpServer {&lt;p&gt;/**&lt;br/&gt;* @param args&lt;br/&gt;* @throws IOException&lt;br/&gt;*/&lt;br/&gt;public static void main(String[] args) throws IOException {&lt;br/&gt;//创建HttpServer服务器&lt;br/&gt;HttpServer httpServer = HttpServer.create(new InetSocketAddress(8080), 10);&lt;br/&gt;//将 /jay请求交给MyHandler处理器处理&lt;br/&gt;httpServer.createContext(&lt;span class=&quot;hljs-string&quot;&gt;&quot;/&quot;&lt;/span&gt;, new MyHandler());&lt;br/&gt;httpServer.start();&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;public class MyHandler implements HttpHandler {&lt;/p&gt;&lt;p&gt;public void handle(HttpExchange httpExchange) throws IOException {&lt;br/&gt;//请求头&lt;br/&gt;Headers headers = httpExchange.getRequestHeaders();&lt;br/&gt;Set&amp;lt;Map.Entry&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt;&amp;gt; entries = headers.entrySet();&lt;/p&gt;&lt;p&gt;StringBuffer response = new StringBuffer();&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (Map.Entry&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt; entry : entries){&lt;br/&gt;response.append(entry.toString() + &lt;span class=&quot;hljs-string&quot;&gt;&quot;\n&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;//设置响应头属性及响应信息的长度&lt;br/&gt;httpExchange.sendResponseHeaders(200, response.length());&lt;br/&gt;//获得输出流&lt;br/&gt;OutputStream os = httpExchange.getResponseBody();&lt;br/&gt;os.write(response.toString().getBytes());&lt;br/&gt;os.close();&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;4. 插入式注解处理API&lt;/span&gt;&lt;/h4&gt;
&lt;blockquote data-tool=&quot;mdnice编辑器&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;❝&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;JDK 6提供了插入式注解处理API，可以让我们定义的注解在编译期而不是运行期生效，从而可以在编译期修改字节码。lombok框架就是使用该特性来实现的，Lombok通过注解的方式，在编译时自动为属性生成构造器、getter/setter、equals、hashcode、toString等方法，大大简化了代码的开发。&lt;/p&gt;
&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;5. STAX&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;STAX，是JDK6中一种处理XML文档的API。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;6.5&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;7&quot;&gt;public class STAXTest {&lt;p&gt;public static void main(String[] args) throws Exception {&lt;/p&gt;&lt;p&gt;XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();&lt;br/&gt;XMLEventReader xmlEventReader = xmlInputFactory.createXMLEventReader(new FileInputStream(&lt;span class=&quot;hljs-string&quot;&gt;&quot;C:\\jay.xml&quot;&lt;/span&gt;));&lt;br/&gt;XMLEvent event = null;&lt;br/&gt;StringBuffer stringBuffer = new StringBuffer();&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (xmlEventReader.hasNext()) {&lt;br/&gt;event = xmlEventReader.nextEvent();&lt;br/&gt;stringBuffer.append(event.toString());&lt;br/&gt;}&lt;br/&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;xml文档解析结果：&quot;&lt;/span&gt;);&lt;br/&gt;System.out.println(stringBuffer);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;运行结果:&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;xml文档解析结果：&lt;br/&gt;&amp;lt;?xml version=&lt;span class=&quot;hljs-string&quot;&gt;&quot;1.0&quot;&lt;/span&gt; encoding=&lt;span class=&quot;hljs-string&quot;&gt;'GBK'&lt;/span&gt; standalone=&lt;span class=&quot;hljs-string&quot;&gt;'yes'&lt;/span&gt;?&amp;gt;&amp;lt;list&amp;gt;&lt;br/&gt;&amp;lt;singer name=&lt;span class=&quot;hljs-string&quot;&gt;'jay'&lt;/span&gt; age=&lt;span class=&quot;hljs-string&quot;&gt;'8'&lt;/span&gt;&amp;gt;&amp;lt;/singer&amp;gt;&lt;br/&gt;&amp;lt;singer name=&lt;span class=&quot;hljs-string&quot;&gt;'eason'&lt;/span&gt; age=&lt;span class=&quot;hljs-string&quot;&gt;'10'&lt;/span&gt;&amp;gt;&amp;lt;/singer&amp;gt;&lt;br/&gt;&amp;lt;/list&amp;gt;ENDDOCUMENT&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;6. Common Annotations&lt;/span&gt;&lt;/h4&gt;
&lt;blockquote data-tool=&quot;mdnice编辑器&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;❝&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Common annotations原本是Java EE 5.0(JSR 244)规范的一部分，现在SUN把它的一部分放到了Java SE 6.0中。随着Annotation元数据功能加入到Java SE 5.0里面，很多Java 技术都会用Annotation部分代替XML文件来配置运行参数。&lt;/p&gt;
&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以下列举Common Annotations 1.0里面的几个Annotations:&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;@Generated：用于标注生成的源代码&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;@Resource： 用于标注所依赖的资源，容器据此注入外部资源依赖，有基于字段的注入和基于setter方法的注入两种方式 。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;@Resources：同时标注多个外部依赖，容器会把所有这些外部依赖注入&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;@PostConstruct：标注当容器注入所有依赖之后运行的方法，用来进行依赖注入后的初始化工作，只有一个方法可以标注为PostConstruct 。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;@PreDestroy：当对象实例将要被从容器当中删掉之前，要执行的回调方法要标注为PreDestroy&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;7. Compiler API&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;javac编译器可以把.java的源文件编译为.class文件，JDK 6的新特性Compiler API(JSR 199)也可以动态编译Java源文件。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;public class CompilerApiTest {&lt;br/&gt;public static void main(String[] args) throws Exception {&lt;br/&gt;JavaCompiler javaCompiler = ToolProvider.getSystemJavaCompiler();&lt;br/&gt;StandardJavaFileManager standardJavaFileManager = javaCompiler.getStandardFileManager(null,null,null);&lt;br/&gt;Iterable&amp;lt;? extends JavaFileObject&amp;gt; javaFileObjects = standardJavaFileManager.getJavaFileObjects(&lt;span class=&quot;hljs-string&quot;&gt;&quot;C:\\Singer.java&quot;&lt;/span&gt;);&lt;br/&gt;javaCompiler.getTask(null, standardJavaFileManager, null, null, null, javaFileObjects).call();&lt;br/&gt;standardJavaFileManager.close();&lt;br/&gt;}&lt;br/&gt;}&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行结果：会在C目录生成Singer.class文件&lt;/p&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;8. 对脚本语言的支持（如: ruby, groovy, javascript）&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JDK6增加了对脚本语言的支持(JSR 223)，原理是将脚本语言编译成字节码，这样脚本语言也能享用Java平台的诸多优势，包括可移植性，安全等。JDK6实现包含了一个基于Mozilla Rhino的 脚本语言引擎,因此可以支持javascript，当然JDK也支持ruby等其他语言&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;5.5&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;5&quot;&gt;public class JavaScriptTest {&lt;p&gt;public static void main(String[] args) throws Exception {&lt;br/&gt;ScriptEngineManager factory = new ScriptEngineManager();&lt;br/&gt;ScriptEngine engine = factory.getEngineByName(&lt;span class=&quot;hljs-string&quot;&gt;&quot;JavaScript&quot;&lt;/span&gt;);&lt;br/&gt;String script;&lt;br/&gt;try {&lt;br/&gt;script = &lt;span class=&quot;hljs-string&quot;&gt;&quot;print('Hello')&quot;&lt;/span&gt;;&lt;br/&gt;engine.eval(script);// 执行脚本&lt;br/&gt;}catch (Exception e) {&lt;br/&gt;e.printStackTrace();&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;//output&lt;br/&gt;Hello&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;Java 7 新特性&lt;/span&gt;&lt;/h3&gt;
&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c52833f0793f4c0fadf77f172b016912~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;1.switch 支持String字符串类型。&lt;/span&gt;&lt;/h4&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;String singer = &lt;span class=&quot;hljs-string&quot;&gt;&quot;jay&quot;&lt;/span&gt;;&lt;br/&gt;switch (singer) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;jay&quot;&lt;/span&gt; :&lt;br/&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;周杰伦&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;break&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;eason&quot;&lt;/span&gt; :&lt;br/&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;陈奕迅&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;break&lt;/span&gt; ;&lt;br/&gt;default :&lt;br/&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;其他&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;break&lt;/span&gt; ;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;2.try-with-resources，资源自动关闭&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JDK 7 之前:&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;BufferedReader br = new BufferedReader(new FileReader(&lt;span class=&quot;hljs-string&quot;&gt;&quot;d:七里香.txt&quot;&lt;/span&gt;));&lt;br/&gt;try {&lt;br/&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;return&lt;/span&gt; br.readLine();&lt;br/&gt;} finally {&lt;br/&gt;br.close();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JDK 7 之后：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;/*&lt;br/&gt;* 声明在try括号中的对象称为资源，在方法执行完毕后会被自动关闭&lt;br/&gt;*/&lt;br/&gt;try (BufferedReader br = new BufferedReader(new FileReader(&lt;span class=&quot;hljs-string&quot;&gt;&quot;d:七里香.txt&quot;&lt;/span&gt;)) {&lt;br/&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;return&lt;/span&gt; br.readLine();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;3. 整数类型如（byte，short，int，long）能够用二进制来表示&lt;/span&gt;&lt;/h4&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;//0b或者0B表示二进制&lt;br/&gt;int a = 0b010;&lt;br/&gt;int b = 0B010;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;4. 数字常量支持下划线&lt;/span&gt;&lt;/h4&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;int a = 11_11;//a的值为1111，下划线不影响实际值，提升可读性&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;5. 泛型实例化类型自动推断,即”&amp;lt;&amp;gt;”&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JDK 7 之前：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;Map&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt; map = new HashMap&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt;();&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JDK 7之后：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;//不须声明类型,自动根据前面&amp;lt;&amp;gt;推断其类型&lt;br/&gt;Map&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt; map = new HashMap&amp;lt;&amp;gt;();&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;6.一个catch中捕获多个异常类型，用（|）分隔开&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JDK 7之前&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;try{&lt;br/&gt;//&lt;span class=&quot;hljs-keyword&quot;&gt;do&lt;/span&gt; something&lt;br/&gt;} catch (FirstException e) {&lt;br/&gt;logger.error(e);&lt;br/&gt;} catch (SecondException e) {&lt;br/&gt;logger.error(ex);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JDk 7之后&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;try{&lt;br/&gt;//&lt;span class=&quot;hljs-keyword&quot;&gt;do&lt;/span&gt; something&lt;br/&gt;} catch (FirstException | SecondException e) {&lt;br/&gt;logger.error(e);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;7. 增强的文件系统&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java7 提供了全新的NIO2.0 API，方便文件管理的编码。如，可以在java.nio.file包下使用Path、Paths、Files、WatchService等常用类型。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;Path path = Paths.get(&lt;span class=&quot;hljs-string&quot;&gt;&quot;C:\\jay\\七里香.txt&quot;&lt;/span&gt;); //创建Path对象&lt;br/&gt;byte[] bytes= Files.readAllBytes(path);  //读取文件&lt;br/&gt;System.out.println(path.getFileName()); //获取当前文件名称&lt;br/&gt;System.out.println(path.toAbsolutePath()); // 获取文件绝对路径&lt;br/&gt;System.out.println(new String(bytes, &lt;span class=&quot;hljs-string&quot;&gt;&quot;utf-8&quot;&lt;/span&gt;));&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;8. Fork/join 框架&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java7提供的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。 &lt;img src=&quot;https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/823a548cf6d64cedb1dd507c5234788f~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Fork/join计算1-1000累加值：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;16.5&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;27&quot;&gt;public class ForkJoinPoolTest {&lt;p&gt;private static final Integer DURATION_VALUE = 100;&lt;/p&gt;&lt;p&gt;static class ForkJoinSubTask extends RecursiveTask&amp;lt;Integer&amp;gt;{&lt;/p&gt;&lt;p&gt;// 子任务开始计算的值&lt;br/&gt;private Integer startValue;&lt;br/&gt;// 子任务结束计算的值&lt;br/&gt;private Integer endValue;&lt;/p&gt;&lt;p&gt;private ForkJoinSubTask(Integer startValue , Integer endValue) {&lt;br/&gt;this.startValue = startValue;&lt;br/&gt;this.endValue = endValue;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;@Override&lt;br/&gt;protected Integer &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;compute&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;//小于一定值DURATION,才开始计算&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(endValue - startValue &amp;lt; DURATION_VALUE) {&lt;br/&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;执行子任务计算：开始值 = &quot;&lt;/span&gt; + startValue + &lt;span class=&quot;hljs-string&quot;&gt;&quot;;结束值 = &quot;&lt;/span&gt; + endValue);&lt;br/&gt;Integer totalValue = 0;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (int index = this.startValue; index &amp;lt;= this.endValue; index++) {&lt;br/&gt;totalValue += index;&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;return&lt;/span&gt; totalValue;&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; {&lt;br/&gt;// 将任务拆分，拆分成两个任务&lt;br/&gt;ForkJoinSubTask subTask1 = new ForkJoinSubTask(startValue, (startValue + endValue) / 2);&lt;br/&gt;subTask1.fork();&lt;br/&gt;ForkJoinSubTask subTask2 = new ForkJoinSubTask((startValue + endValue) / 2 + 1 , endValue);&lt;br/&gt;subTask2.fork();&lt;br/&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;return&lt;/span&gt; subTask1.join() + subTask2.join();&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;public static void main(String[] args) throws ExecutionException, InterruptedException {&lt;br/&gt;// Fork/Join框架的线程池&lt;br/&gt;ForkJoinPool pool = new ForkJoinPool();&lt;br/&gt;ForkJoinTask&amp;lt;Integer&amp;gt; taskFuture =  pool.submit(new ForkJoinSubTask(1,1000));&lt;/p&gt;&lt;p&gt;Integer result = taskFuture.get();&lt;br/&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;累加结果是:&quot;&lt;/span&gt; + result);&lt;/p&gt;&lt;p&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行结果：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;...&lt;br/&gt;执行子任务计算：开始值 = 189;结束值 = 250&lt;br/&gt;执行子任务计算：开始值 = 251;结束值 = 313&lt;br/&gt;执行子任务计算：开始值 = 314;结束值 = 375&lt;br/&gt;执行子任务计算：开始值 = 376;结束值 = 438&lt;br/&gt;执行子任务计算：开始值 = 439;结束值 = 500&lt;br/&gt;执行子任务计算：开始值 = 501;结束值 = 563&lt;br/&gt;执行子任务计算：开始值 = 564;结束值 = 625&lt;br/&gt;执行子任务计算：开始值 = 626;结束值 = 688&lt;br/&gt;执行子任务计算：开始值 = 689;结束值 = 750&lt;br/&gt;执行子任务计算：开始值 = 751;结束值 = 813&lt;br/&gt;执行子任务计算：开始值 = 814;结束值 = 875&lt;br/&gt;执行子任务计算：开始值 = 876;结束值 = 938&lt;br/&gt;执行子任务计算：开始值 = 939;结束值 = 1000&lt;br/&gt;累加结果是:500500&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;Java 8 新特性&lt;/span&gt;&lt;/h3&gt;
&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5730671f3ef344bd89163eb4a3f9f710~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;1.lambada表达式&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Lambda 允许把函数作为一个方法的参数，传递到方法中&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;语法格式：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;(parameters) -&amp;gt; expression 或 (parameters) -&amp;gt;{ statements; }&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码示例：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;Arrays.asList(&lt;span class=&quot;hljs-string&quot;&gt;&quot;jay&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;Eason&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;SHE&quot;&lt;/span&gt;).forEach(&lt;br/&gt;( String singer ) -&amp;gt; System.out.print( singer + &lt;span class=&quot;hljs-string&quot;&gt;&quot;,&quot;&lt;/span&gt;) );&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;2. 函数式接口&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Lambda的设计者为了让现有的功能与Lambda表达式很好兼容，设计出函数式接口。&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;函数式接口是指只有一个函数的接口，可以隐式转换为lambada表达式。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;Java 8 提供了注解@FunctionalInterface，显示声明一个函数式接口。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;java.lang.Runnable和java.util.concurrent.Callable是函数式接口的例子~&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;@FunctionalInterface&lt;br/&gt;public interface Runnable {&lt;br/&gt;public abstract void run();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;3. 方法引用&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。它与Lambda表达式配合使用，可以减少冗余代码，使代码更加简洁。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;//利用函数式接口Consumer的accept方法实现打印，Lambda表达式如下&lt;br/&gt;Consumer&amp;lt;String&amp;gt; consumer = x -&amp;gt; System.out.println(x);&lt;br/&gt;consumer.accept(&lt;span class=&quot;hljs-string&quot;&gt;&quot;jay&quot;&lt;/span&gt;);&lt;br/&gt;//引用PrintStream类（也就是System.out的类型）的println方法，这就是方法引用&lt;br/&gt;consumer = System.out::println;&lt;br/&gt;consumer.accept(&lt;span class=&quot;hljs-string&quot;&gt;&quot;关注公众号捡田螺的小男孩&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;4. 默认方法&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;默认方法就是一个在接口里面有了一个实现的方法。它允许将新方法添加到接口，但不强制实现了该接口的类必须实现新的方法。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;5&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;4&quot;&gt;public interface ISingerService {&lt;br/&gt;// 默认方法&lt;br/&gt;default void &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;sing&lt;/span&gt;&lt;/span&gt;(){&lt;br/&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;唱歌&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;void writeSong();&lt;br/&gt;}&lt;p&gt;//JaySingerServiceImpl 不用强制实现ISingerService的默认sing()方法&lt;br/&gt;public class JaySingerServiceImpl implements ISingerService {&lt;br/&gt;@Override&lt;br/&gt;public void &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;writeSong&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;写了一首七里香&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;5.Stream API&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Stream API，支持对元素流进行函数式操作，它集成在Collections API 中，可以对集合进行批量操作。常用API：&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;filter 筛选&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;map流映射&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;reduce 将流中的元素组合起来&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;collect 返回集合&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;sorted 排序&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;flatMap 流转换&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;limit返回指定流个数&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;distinct去除重复元素&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;10.5&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;15&quot;&gt;public class Singer {&lt;p&gt;private String name;&lt;br/&gt;private Integer songNum;&lt;br/&gt;private Integer age;&lt;br/&gt;...&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;List&amp;lt;Singer&amp;gt; singerList = new ArrayList&amp;lt;Singer&amp;gt;();&lt;br/&gt;singerList.add(new Singer(&lt;span class=&quot;hljs-string&quot;&gt;&quot;jay&quot;&lt;/span&gt;, 11, 36));&lt;br/&gt;singerList.add(new Singer(&lt;span class=&quot;hljs-string&quot;&gt;&quot;eason&quot;&lt;/span&gt;, 8, 31));&lt;br/&gt;singerList.add(new Singer(&lt;span class=&quot;hljs-string&quot;&gt;&quot;JJ&quot;&lt;/span&gt;, 6, 29));&lt;/p&gt;&lt;p&gt;List&amp;lt;String&amp;gt; singerNameList = singerList.stream()&lt;br/&gt;.filter(singer -&amp;gt; singer.getAge() &amp;gt; 30)  //筛选年龄大于30&lt;br/&gt;.sorted(Comparator.comparing(Singer::getSongNum))  //根据歌曲数量排序&lt;br/&gt;.map(Singer::getName)  //提取歌手名字&lt;br/&gt;.collect(Collectors.toList()); //转换为List&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;6. Optional&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 8引入Optional类，用来解决NullPointerException。Optional代替if...else解决空指针问题，使代码更加简洁。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;if...else 判空&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;Singer singer = getSingerById(&lt;span class=&quot;hljs-string&quot;&gt;&quot;666&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (singer != null) {&lt;br/&gt;String name  = singer.getName();&lt;br/&gt;System.out.println(name);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Optional的判空&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;Optional&amp;lt;Singer&amp;gt; singer = Optional.ofNullable(getSingerById(&lt;span class=&quot;hljs-string&quot;&gt;&quot;666&quot;&lt;/span&gt;));&lt;br/&gt;singer.ifPresent(s -&amp;gt; System.out.println(s.getName()));&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;7. Date Time API&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JDK 8之前的日期API处理存在非线程安全、时区处理麻烦等问题。Java 8 在 java.time包下提供了新的日期API，简化了日期的处理~&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;9&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;12&quot;&gt;LocalDate today = LocalDate.now();&lt;br/&gt;int year = today.getYear();&lt;br/&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;今年是&quot;&lt;/span&gt; + year);&lt;br/&gt;//是否闰年&lt;br/&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;今年是不是闰年:&quot;&lt;/span&gt; + today.isLeapYear());&lt;p&gt;LocalDateTime todayTime = LocalDateTime.now();&lt;br/&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;当前时间&quot;&lt;/span&gt; + todayTime);&lt;br/&gt;//时区指定&lt;br/&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;美国时间:&quot;&lt;/span&gt; + ZonedDateTime.of(todayTime,ZoneId.of(&lt;span class=&quot;hljs-string&quot;&gt;&quot;America/Los_Angeles&quot;&lt;/span&gt;)));&lt;/p&gt;&lt;p&gt;LocalDate specailDate = LocalDate.of(2020, 6, 20);&lt;br/&gt;LocalDate expectDate = specailDate.plus(100, ChronoUnit.DAYS);&lt;br/&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;比较特别的一天&quot;&lt;/span&gt; + specailDate);&lt;br/&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;特殊日期的100天&quot;&lt;/span&gt; + expectDate);&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;8. 重复注解&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重复注解，即一个注解可以在一个类、属性或者方法上同时使用多次；用@Repeatable定义重复注解&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;5.5&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;5&quot;&gt;@Repeatable(ScheduleTimes.class)&lt;br/&gt;public @interface ScheduleTime {&lt;br/&gt;String value();&lt;br/&gt;}&lt;p&gt;public @interface ScheduleTimes {&lt;br/&gt;ScheduleTime[] value();&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;public class ScheduleTimeTask {&lt;br/&gt;@ScheduleTime(&lt;span class=&quot;hljs-string&quot;&gt;&quot;10&quot;&lt;/span&gt;)&lt;br/&gt;@ScheduleTime(&lt;span class=&quot;hljs-string&quot;&gt;&quot;12&quot;&lt;/span&gt;)&lt;br/&gt;public void &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;doSomething&lt;/span&gt;&lt;/span&gt;() { }&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;9. Base64&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 8把Base64编码的支持加入到官方库中~&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;String str = &lt;span class=&quot;hljs-string&quot;&gt;&quot;公众号:捡田螺的小男孩&quot;&lt;/span&gt;;&lt;br/&gt;String encoded = Base64.getEncoder().encodeToString(str.getBytes( StandardCharsets.UTF_8));&lt;br/&gt;String decoded = new String(Base64.getDecoder().decode(encoded), StandardCharsets.UTF_8);&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;10. JVM的新特性&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用元空间Metaspace代替持久代（PermGen space），JVM参数使用-XX:MetaSpaceSize和-XX:MaxMetaspaceSize设置大小。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;Java 9 新特性&lt;/span&gt;&lt;/h3&gt;
&lt;img src=&quot;https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b0457ff711b412094b2900ba4b4e974~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;1. java模块系统&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;什么是模块化？&lt;/p&gt;
&lt;blockquote data-tool=&quot;mdnice编辑器&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;❝&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;一个大型系统，比如一个商城网站，它会包含很多模块的，如：订单模块，用户信息模块，商品信息模块，广告位模块等等。各个模块之间会相互调用。如果每个模块单独运行都会带动其他所有模块，性能非常低效。但是，如果某一模块运行时，只会启动它所依赖的模块，性能大大提升。这就是JDK 9模块化的思想。&lt;/p&gt;
&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;什么是JDK 9模块化？&lt;/p&gt;
&lt;blockquote data-tool=&quot;mdnice编辑器&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;❝&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Java 平台模块系统，即Project Jigsaw，把模块化开发实践引入到了Java平台中。在引入了模块系统之后，JDK 被重新组织成94个模块。Java 应用可以通过新增的jlink 工具，创建出只包含所依赖的JDK模块的自定义运行时镜像。这样可以极大的减少Java运行时环境的大小。&lt;/p&gt;
&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 9 模块的重要特征：&lt;/p&gt;
&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;p&gt;&lt;span&gt;❝&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;section&gt;在其工件（artifact）的根目录中包含了一个描述模块的 module-info.class 文 件。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;工件的格式可以是传统的 JAR 文件或是 Java 9 新增的 JMOD 文件。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;这个文件由根目录中的源代码文件 module-info.java 编译而来。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;该模块声明文件可以描述模块的不同特征。&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 module-info.java 文件中，我们可以用新的关键词module来声明一个模块，如下所示。下面给出了一个模块com.mycompany.mymodule的最基本的模块声明&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;module com.jay.sample {   //关键词module来声明一个模块&lt;br/&gt;exports com.jay.sample; //使用 exports可以声明模块对其他模块所导出的包。&lt;br/&gt;requires com.jay.common; //使用requires可以声明模块对其他模块的依赖关系。&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;2. 不可变集合工厂方法&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了创建不可变集合，JDK9之前酱紫的：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;List&amp;lt;String&amp;gt; stringList = new ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;stringList.add(&lt;span class=&quot;hljs-string&quot;&gt;&quot;关注公众号:&quot;&lt;/span&gt;);&lt;br/&gt;stringList.add(&lt;span class=&quot;hljs-string&quot;&gt;&quot;捡田螺的小男孩&quot;&lt;/span&gt;);&lt;br/&gt;List&amp;lt;String&amp;gt; unmodifiableList = Collections.unmodifiableList(stringList);&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JDK 9 提供了List.of()、Set.of()、Map.of()和Map.ofEntries()等工厂方法来创建不可变集合：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;List&amp;lt;String&amp;gt; unmodifiableList = List.of(&lt;span class=&quot;hljs-string&quot;&gt;&quot;关注公众号:&quot;&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;&quot;捡田螺的小男孩&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;3. 接口支持私有方法&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JDK 8支持在接口实现默认方法和静态方法，但是不能在接口中创建私有方法，为了避免了代码冗余和提高阅读性，JDK 9在接口中支持私有方法。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;6.5&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;7&quot;&gt;public interface IPrivateInterfaceTest {&lt;p&gt;//JDK 7 之前&lt;br/&gt;String a = &lt;span class=&quot;hljs-string&quot;&gt;&quot;jay&quot;&lt;/span&gt;;&lt;br/&gt;void method7();&lt;/p&gt;&lt;p&gt;//JDK 8&lt;br/&gt;default void &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;methodDefault8&lt;/span&gt;&lt;/span&gt;(){&lt;br/&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;JDK 8新特性默认方法&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;static void &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;methodStatic8&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;JDk 8新特性静态方法&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;//Java 9 接口支持私有方法&lt;br/&gt;private void &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;method9&lt;/span&gt;&lt;/span&gt;(){}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;4. 钻石操作符升级&lt;/span&gt;&lt;/h4&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;钻石操作符是在 java 7 中引入的，可以让代码更易读，但它不能用于匿名的内部类。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;在 java 9 中， 它可以与匿名的内部类一起使用，从而提高代码的可读性。&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;//JDK 5,6&lt;br/&gt;Map&amp;lt;String, String&amp;gt; map56 = new HashMap&amp;lt;String,String&amp;gt;();&lt;br/&gt;//JDk 7,8&lt;br/&gt;Map&amp;lt;String, String&amp;gt; map78 = new HashMap&amp;lt;&amp;gt;();&lt;br/&gt;//JDK 9 结合匿名内部类的实现&lt;br/&gt;Map&amp;lt;String, String&amp;gt; map9 = new HashMap&amp;lt;&amp;gt;(){};&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;5. Optional 类改进&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;java 9 中，java.util.Optional 添加了很多新的有用方法，如：&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;stream()&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;ifPresentOrElse()&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;or()&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ifPresentOrElse 方法的改进就是有了 else，接受两个参数 Consumer 和 Runnable。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;9.5&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;13&quot;&gt;import java.util.Optional;&lt;p&gt;public class OptionalTest {&lt;br/&gt;public static void main(String[] args) {&lt;br/&gt;Optional&amp;lt;Integer&amp;gt; optional = Optional.of(1);&lt;/p&gt;&lt;p&gt;optional.ifPresentOrElse( x -&amp;gt; System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Value: &quot;&lt;/span&gt; + x),() -&amp;gt; &lt;br/&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Not Present.&quot;&lt;/span&gt;));&lt;/p&gt;&lt;p&gt;optional = Optional.empty();&lt;/p&gt;&lt;p&gt;optional.ifPresentOrElse( x -&amp;gt; System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Value: &quot;&lt;/span&gt; + x),() -&amp;gt; &lt;br/&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Not Present.&quot;&lt;/span&gt;));&lt;br/&gt;}  &lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;6. 多版本兼容Jar包&lt;/span&gt;&lt;/h4&gt;
&lt;blockquote data-tool=&quot;mdnice编辑器&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;❝&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;很多公司使用的JDK都是老版本的，JDK6、JDk5 ，甚至JDk4的，不是他们不想升级JDk版本，而是担心兼容性问题。JDK 9的一个新特性，多版本兼容Jar包解决了这个问题。举个例子：假设你一直用的是小米8，已经非常习惯它的运行流程了，突然出来小米9，即使小米9很多新功能引人入胜，但是有些人不会轻易买小米9，因为已经已经习惯小米8的流程。同理，为什么很多公司不升级JDK，就是在此。但是呢，JDK 9的这个功能很强大，它可以让你的版本升级到JDK 9，但是还是老版本的运行流程，即在老的运行流程继承新的功能~&lt;/p&gt;
&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;7. JShell工具&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;jShell工具相当于cmd工具，然后呢，你可以像在cmd工具操作一样，直接在上面运行Java方法，Java语句等~&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;jshell&amp;gt; System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;关注公众号：捡田螺的小男孩&quot;&lt;/span&gt;);&lt;br/&gt;关注公众号：捡田螺的小男孩&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;8. try-with-resources的改进&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JDK 9对try-with-resources异常处理机制进行了升级~&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;//JDK 7,8&lt;br/&gt;try (BufferedReader br = new BufferedReader(new FileReader(&lt;span class=&quot;hljs-string&quot;&gt;&quot;d:七里香.txt&quot;&lt;/span&gt;)) {&lt;br/&gt;br.readLine();&lt;br/&gt;}catch(IOException e){&lt;br/&gt;log.error(&lt;span class=&quot;hljs-string&quot;&gt;&quot;IO 异常，e:{}&quot;&lt;/span&gt;,e);&lt;br/&gt;}&lt;br/&gt;//JDk 9&lt;br/&gt;BufferedReader br = new BufferedReader(new FileReader(&lt;span class=&quot;hljs-string&quot;&gt;&quot;d:七里香.txt&quot;&lt;/span&gt;)&lt;br/&gt;try(br){&lt;br/&gt;br.readLine();&lt;br/&gt;}catch(IOException e){&lt;br/&gt;log.error(&lt;span class=&quot;hljs-string&quot;&gt;&quot;IO 异常，e:{}&quot;&lt;/span&gt;,e);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;9. Stream API的改进&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JDK 9 为Stream API引入以下这些方法，丰富了流处理操作：&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;takeWhile（）&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;dropWhile（）&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;iterate&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;ofNullable&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;takeWhile&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用一个断言（Predicate 接口）作为参数，返回给定Stream的子集直到断言语句第一次返回 false&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;// 语法格式&lt;br/&gt;default Stream&amp;lt;T&amp;gt; takeWhile(Predicate&amp;lt;? super T&amp;gt; predicate)&lt;br/&gt;//代码示例&lt;br/&gt;Stream.of(1,2,3).takeWhile(s-&amp;gt; x&amp;lt;2)&lt;br/&gt;.forEach(System.out::println); &lt;br/&gt;//输出&lt;br/&gt;1&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;dropWhile&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与 takeWhile（）作用相反，使用一个断言（Predicate 接口）作为参数，直到断言语句第一次返回true，返回给定Stream的子集&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;//语法&lt;br/&gt;default Stream&amp;lt;T&amp;gt; dropWhile(Predicate&amp;lt;? super T&amp;gt; predicate)&lt;br/&gt;//代码示例&lt;br/&gt;Stream.of(1,2,3).dropWhile(s-&amp;gt; x&amp;lt;2)&lt;br/&gt;.forEach(System.out::println);&lt;br/&gt;//输出&lt;br/&gt;2&lt;br/&gt;3&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;iterate&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;iterate() 方法能够返回以seed（第一个参数）开头，匹配 Predicate（第二个参数）直到返回false，并使用第三个参数生成下一个元素的元素流。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;//语法&lt;br/&gt;static &amp;lt;T&amp;gt; Stream&amp;lt;T&amp;gt; iterate(T seed, Predicate&amp;lt;? super T&amp;gt; hasNext, UnaryOperator&amp;lt;T&amp;gt; next)&lt;br/&gt;//代码示例&lt;br/&gt;IntStream.iterate(2, x -&amp;gt; x &amp;lt; 10, x -&amp;gt; x*x).forEach(System.out::println);&lt;br/&gt;//输出&lt;br/&gt;2&lt;br/&gt;4&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;ofNullable&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果指定元素为非null，则获取一个元素并生成单个元素流，元素为null则返回一个空Stream。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;//语法&lt;br/&gt;static &amp;lt;T&amp;gt; Stream&amp;lt;T&amp;gt; ofNullable(T t)&lt;br/&gt;//代码示例&lt;br/&gt;Stream&amp;lt;Integer&amp;gt; s1= Stream.ofNullable(100);&lt;br/&gt;s1.forEach(System.out::println)&lt;br/&gt;Stream&amp;lt;Integer&amp;gt; s2 = Stream.ofNullable(null)；&lt;br/&gt;s2.forEach(System.out::println)&lt;br/&gt;//输出&lt;br/&gt;100&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;10.其他&lt;/span&gt;&lt;/h4&gt;
&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;p&gt;&lt;span&gt;❝&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;section&gt;HTTP 2客户端 (支持 WebSocket和 HTTP2 流以及服务器推送)&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;进程API（控制和管理操作系统进程）&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;String底层存储结构更改(char[]替换为byte[])&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;标识符添加限制( String _ =&quot;hello&quot;不能用)&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;响应式流 API (支持Java 9中的响应式编程)&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;Java 10 新特性&lt;/span&gt;&lt;/h3&gt;
&lt;img src=&quot;https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1641de35ea274dbb9d7d34c78ea40a0f~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;1.局部变量类型推断&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JDK 10增加了局部变量类型推断（Local-Variable Type Inference）功能，让 Java 可以像Js里的var一样可以自动推断数据类型。Java中的var是一个保留类型名称，而不是关键字。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JDK 10之前&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;String&amp;gt;();&lt;br/&gt;Stream&amp;lt;Integer&amp;gt; stream = Stream.of(1, 2, 3);&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JDK 10 之后&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;var list = new ArrayList&amp;lt;String&amp;gt;(); // ArrayList&amp;lt;String&amp;gt;&lt;br/&gt;var stream =  Stream.of(1, 2, 3);&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;var 变量类型推断的使用也有局限性，仅&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;局限&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;于以下场景：&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;具有初始化器的局部变量&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;增强型for循环中的索引变量&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;传统for循环中声明的局部变量&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;不能用于&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;推断方法的参数类型&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;构造函数参数类型推断&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;推断方法返回类型&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;字段类型推断&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;捕获表达式&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;2. 不可变集合的改进&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JDK 10中，List，Set，Map 提供了一个新的静态方法copyOf(Collection&amp;lt;? extends E&amp;gt; coll)，它返回Collection集合一个不可修改的副本。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JDK 源码：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;static &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; copyOf(Collection&amp;lt;? extends E&amp;gt; coll) {&lt;br/&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;return&lt;/span&gt; ImmutableCollections.listCopy(coll);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用实例：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;4.5&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;3&quot;&gt;var oldList = new ArrayList&amp;lt;String&amp;gt;();&lt;br/&gt;oldList.add(&lt;span class=&quot;hljs-string&quot;&gt;&quot;欢迎关注公众号：&quot;&lt;/span&gt;);&lt;br/&gt;oldList.add(&lt;span class=&quot;hljs-string&quot;&gt;&quot;捡田螺的小男孩&quot;&lt;/span&gt;);&lt;p&gt;var copyList = List.copyOf(oldList);&lt;br/&gt;oldList.add(&lt;span class=&quot;hljs-string&quot;&gt;&quot;在看、转载、点赞三连&quot;&lt;/span&gt;); &lt;br/&gt;copyList.add(&lt;span class=&quot;hljs-string&quot;&gt;&quot;双击666&quot;&lt;/span&gt;);  //UnsupportedOperationException异常&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;3. 并行全垃圾回收器 G1&lt;/span&gt;&lt;/h4&gt;
&lt;blockquote data-tool=&quot;mdnice编辑器&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;❝&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;JDK 9引入 G1 作为默认垃圾收集器，执行GC 时采用的是基于单线程标记扫描压缩算法（mark-sweep-compact）。为了最大限度地减少 Full GC 造成的应用停顿的影响，Java 10 中将为 G1 引入多线程并行 GC，同时会使用与年轻代回收和混合回收相同的并行工作线程数量，从而减少了 Full GC 的发生，以带来更好的性能提升、更大的吞吐量。&lt;/p&gt;
&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;4. 线程本地握手&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 10 中线程管控引入JVM安全点的概念，将允许在不运行全局JVM安全点的情况下实现线程回调，由线程本身或者JVM线程来执行，同时保持线程处于阻塞状态，这将会很方便使得停止单个线程或不停止线程成为可能。&lt;/p&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;5. Optional新增orElseThrow()方法&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Optional、OptionalDouble等类新增一个方法orElseThrow()，在没有值时抛出异常&lt;/p&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;6. 其他新特性&lt;/span&gt;&lt;/h4&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;基于 Java 的 实验性 JIT 编译器&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;类数据共享&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;Unicode 语言标签扩展&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;根证书&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;基于时间（Time-Based）的版本控制模型&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;Java 11 新特性&lt;/span&gt;&lt;/h3&gt;
&lt;img src=&quot;https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4041b93cd08c4865aaceec2bafbd214f~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;1.字符串操作&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;String类是Java最常用的类，JDK 11增加了一系列好用的字符串处理方法&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;isBlank() 判空。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;strip() 去除首尾空格&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;stripLeading() 去除字符串首部空格&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;stripTrailing() 去除字符串尾部空格&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;lines() 分割获取字符串流。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;repeat() 复制字符串&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;8&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;10&quot;&gt;// 判断字符串是否为空白&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;  &quot;&lt;/span&gt;.isBlank();    // &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;&lt;p&gt;// 去除首尾空格&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot; jay &quot;&lt;/span&gt;.strip();  // &lt;span class=&quot;hljs-string&quot;&gt;&quot;jay&quot;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;// 去除首部空格 &lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot; jay &quot;&lt;/span&gt;.stripLeading();   // &lt;span class=&quot;hljs-string&quot;&gt;&quot;jay &quot;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;去除字符串尾部空格&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot; jay &quot;&lt;/span&gt;.stripLeading();   // &lt;span class=&quot;hljs-string&quot;&gt;&quot; jay&quot;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;// 行数统计&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;a\nb\nc&quot;&lt;/span&gt;.lines().count();    // 3&lt;/p&gt;&lt;p&gt;// 复制字符串&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;jay&quot;&lt;/span&gt;.repeat(3);   // &lt;span class=&quot;hljs-string&quot;&gt;&quot;jayjayjay&quot;&lt;/span&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;2.用于 Lambda 参数的局部变量语法&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;局部变量类型推断是Java 10引入的新特性，但是不能在Lambda 表达式中使用。Java 11再次创新，它允许开发者在 Lambda 表达式中使用 var 进行参数声明。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;var map = new HashMap&amp;lt;String, Object&amp;gt;();&lt;br/&gt;map.put(&lt;span class=&quot;hljs-string&quot;&gt;&quot;公众号&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;捡田螺的小男孩&quot;&lt;/span&gt;);&lt;br/&gt;map.forEach((var k, var v) -&amp;gt; {&lt;br/&gt;System.out.println(k + &lt;span class=&quot;hljs-string&quot;&gt;&quot;: &quot;&lt;/span&gt; + v);&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;3.标准化HTTP Client&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 9 引入Http Client API,Java 10对它更新，Java 11 对它进行标准化。这几个版本后，Http Client几乎被完全重写，支持HTTP/1.1和HTTP/2 ，也支持 websockets。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;7&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;8&quot;&gt;HttpClient client = HttpClient.newHttpClient();&lt;br/&gt;HttpRequest request = HttpRequest.newBuilder()&lt;br/&gt;.uri(URI.create(&lt;span class=&quot;hljs-string&quot;&gt;&quot;https://github.com/whx123/JavaHome&quot;&lt;/span&gt;))&lt;br/&gt;.GET()&lt;br/&gt;.build();&lt;p&gt;// 同步&lt;br/&gt;HttpResponse&amp;lt;String&amp;gt; response = client.send(request, HttpResponse.BodyHandlers.ofString());&lt;br/&gt;System.out.println(response.body());&lt;/p&gt;&lt;p&gt;// 异步&lt;br/&gt;client.sendAsync(request, HttpResponse.BodyHandlers.ofString())&lt;br/&gt;.thenApply(HttpResponse::body)&lt;br/&gt;.thenAccept(System.out::println);&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;4. 单个命令编译运行源代码&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 11增强了Java 启动器，使之能够运行单一文件的Java 源代码。&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;Java 11之前,要运行一个 Java 源代码必须先编译，再运行&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;// 编译&lt;br/&gt;javac Jay.java&lt;br/&gt;// 运行&lt;br/&gt;java Jay&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;Java 11之后,只要一个java命令就搞定&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;java Jay.java&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;5. ZGC：可伸缩低延迟垃圾收集器&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ZGC ，即 Z Garbage Collector（垃圾收集器或垃圾回收器）。它是一个可伸缩的、低延迟的垃圾收集器。 ZGC 主要为了满足如下目标进行设计：&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;GC 停顿时间不超过 10ms&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;既能处理几百 MB 的小堆，也能处理几个 TB 的大堆&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;应用吞吐能力不会下降超过 15%（与 G1 回收算法相比）&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;方便在此基础上引入新的 GC 特性和利用 colord&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;针以及 Load barriers 优化奠定基础&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;当前只支持 Linux/x64 位平台&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;6.其他一些特性&lt;/span&gt;&lt;/h4&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;添加 Epsilon 垃圾收集器。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;支持 TLS 1.3 协议&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;飞行记录器分析工具&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;动态类文件常量&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;低开销的 Heap Profiling&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;Java 12 新特性&lt;/span&gt;&lt;/h3&gt;
&lt;img src=&quot;https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a9700faac24f45508d6f7071e779d1b8~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;1. Switch 表达式扩展（预览功能）&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;传统的switch语句，容易漏写break而出错，同时写法并不简洁优雅。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 12之前&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;switch (day) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;case&lt;/span&gt; MONDAY:&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;case&lt;/span&gt; FRIDAY:&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;case&lt;/span&gt; SUNDAY:&lt;br/&gt;System.out.println(6);&lt;br/&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;break&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;case&lt;/span&gt; TUESDAY:&lt;br/&gt;System.out.println(7);&lt;br/&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;break&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;case&lt;/span&gt; THURSDAY:&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;case&lt;/span&gt; SATURDAY:&lt;br/&gt;System.out.println(8);&lt;br/&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;break&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;case&lt;/span&gt; WEDNESDAY:&lt;br/&gt;System.out.println(9);&lt;br/&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;break&lt;/span&gt;;&lt;br/&gt;}&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JDk 12 之后，Switch表达式得到增强，能接受语句和表达式。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;switch (day) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;case&lt;/span&gt; MONDAY, FRIDAY, SUNDAY -&amp;gt; System.out.println(6);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;case&lt;/span&gt; TUESDAY                -&amp;gt; System.out.println(7);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;case&lt;/span&gt; THURSDAY, SATURDAY     -&amp;gt; System.out.println(8);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;case&lt;/span&gt; WEDNESDAY              -&amp;gt; System.out.println(9);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;2. 紧凑的数据格式&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JDK 12 新增了NumberFormat对复杂数字的格式化&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;NumberFormat numberFormat = NumberFormat.getCompactNumberInstance(Locale.CHINA, NumberFormat.Style.SHORT);&lt;br/&gt;System.out.println(numberFormat.format(100000));&lt;br/&gt;//output&lt;br/&gt;10万&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;3. 字符串支持transform、indent操作&lt;/span&gt;&lt;/h4&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;transform 字符串转换，可以配合函数式接口Function一起使用&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;List&amp;lt;String&amp;gt; list1 = List.of(&lt;span class=&quot;hljs-string&quot;&gt;&quot;jay&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot; 捡田螺的小男孩&quot;&lt;/span&gt;);&lt;br/&gt;List&amp;lt;String&amp;gt; list2 = new ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;list1.forEach(element -&amp;gt;&lt;br/&gt;list2.add(element.transform(String::strip)&lt;br/&gt;.transform((e) -&amp;gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;Hello,&quot;&lt;/span&gt; + e))&lt;br/&gt;);&lt;br/&gt;list2.forEach(System.out::println);&lt;br/&gt;//输出&lt;br/&gt;Hello,jay&lt;br/&gt;Hello,捡田螺的小男孩&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;indent 缩进，每行开头增加空格space和移除空格&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;String result = &lt;span class=&quot;hljs-string&quot;&gt;&quot;Java\n Python\nC&quot;&lt;/span&gt;.indent(3);&lt;br/&gt;System.out.println(result);&lt;br/&gt;//输出&lt;br/&gt;Java&lt;br/&gt;Python&lt;br/&gt;C&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;4. Files.mismatch(Path, Path)&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 12 新增了mismatch方法，此方法返回第一个不匹配的位置，如果没有不匹配，则返回 -1L。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;public static long mismatch(Path path, Path path2) throws IOException;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码示例：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;5&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;4&quot;&gt;Path file1 = Paths.get(&lt;span class=&quot;hljs-string&quot;&gt;&quot;c:\\jay.txt&quot;&lt;/span&gt;);&lt;br/&gt;Path file2 = Paths.get(&lt;span class=&quot;hljs-string&quot;&gt;&quot;c：\\捡田螺的小男孩.txt&quot;&lt;/span&gt;);&lt;p&gt;try {&lt;br/&gt;long fileMismatch = Files.mismatch(file1, file2);&lt;br/&gt;System.out.println(fileMismatch);&lt;br/&gt;} catch (IOException e) {&lt;br/&gt;e.printStackTrace();&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;5. Teeing Collector&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Teeing Collector 是 Streams API 中引入的新的收集器实用程序，它的作用是 merge 两个 collector 的结果,API格式如下：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;public static &amp;lt;T, R1, R2, R&amp;gt;&lt;br/&gt;Collector&amp;lt;T, ?, R&amp;gt; teeing(Collector&amp;lt;? super T, ?, R1&amp;gt; downstream1,&lt;br/&gt;Collector&amp;lt;? super T, ?, R2&amp;gt; downstream2,&lt;br/&gt;BiFunction&amp;lt;? super R1, ? super R2, R&amp;gt; merger)&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;直接看代码例子吧，如下为求学生的平均分和总分的例子&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;  List&amp;lt;Student&amp;gt; studentList= Arrays.asList(&lt;br/&gt;new Student(&lt;span class=&quot;hljs-string&quot;&gt;&quot;jay&quot;&lt;/span&gt;, 90),&lt;br/&gt;new Student(&lt;span class=&quot;hljs-string&quot;&gt;&quot;捡田螺的小男孩&quot;&lt;/span&gt;, 100),&lt;br/&gt;new Student(&lt;span class=&quot;hljs-string&quot;&gt;&quot;捡表情的小男孩&quot;&lt;/span&gt;, 80)&lt;br/&gt;);&lt;br/&gt;String teeingResult=studentList.stream().collect(&lt;br/&gt;Collectors.teeing(&lt;br/&gt;Collectors.averagingInt(Student::getScore),&lt;br/&gt;Collectors.summingInt(Student::getScore),&lt;br/&gt;(s1,s2)-&amp;gt; s1+ &lt;span class=&quot;hljs-string&quot;&gt;&quot;:&quot;&lt;/span&gt;+ s2&lt;br/&gt;)&lt;br/&gt;);&lt;br/&gt;System.out.println(teeingResult); //90:270&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;6.其他特性&lt;/span&gt;&lt;/h4&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;支持unicode 11（684个新字符、11个新blocks、7个新脚本）&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;JVM 常量 API （主要在新的java.lang.invoke.constant包中定义了一系列基于值的符号引用类型，能够描述每种可加载常量。）&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;Shenandoah GC（低暂停时间垃圾收集器）&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;G1 收集器提升 （可中止的混合收集集合、及时返回未使用的已分配内存）&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;默认CDS档案&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;JMH 基准测试&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;Java 13 新特性&lt;/span&gt;&lt;/h3&gt;
&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/404668ad77d248ec97d482622182eb70~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;Switch 表达式扩展（引入 yield 关键字）&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;传统的switch：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;private static String getText(int number) {&lt;br/&gt;String result = &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&lt;/span&gt;;&lt;br/&gt;switch (number) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;case&lt;/span&gt; 1, 2:&lt;br/&gt;result = &lt;span class=&quot;hljs-string&quot;&gt;&quot;one or two&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;break&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;case&lt;/span&gt; 3:&lt;br/&gt;result = &lt;span class=&quot;hljs-string&quot;&gt;&quot;three&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;break&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;case&lt;/span&gt; 4, 5, 6:&lt;br/&gt;result = &lt;span class=&quot;hljs-string&quot;&gt;&quot;four or five or six&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;break&lt;/span&gt;;&lt;br/&gt;default:&lt;br/&gt;result = &lt;span class=&quot;hljs-string&quot;&gt;&quot;unknown&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;break&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 13之后，value break 语句不再被编译，而是用 yield 来进行值返回&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;private static String getText(int number) {&lt;br/&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;return&lt;/span&gt; switch (number) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;case&lt;/span&gt; 1, 2:&lt;br/&gt;yield &lt;span class=&quot;hljs-string&quot;&gt;&quot;one or two&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;case&lt;/span&gt; 3:&lt;br/&gt;yield &lt;span class=&quot;hljs-string&quot;&gt;&quot;three&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;case&lt;/span&gt; 4, 5, 6:&lt;br/&gt;yield &lt;span class=&quot;hljs-string&quot;&gt;&quot;four or five or six&quot;&lt;/span&gt;;&lt;br/&gt;default:&lt;br/&gt;yield &lt;span class=&quot;hljs-string&quot;&gt;&quot;unknown&quot;&lt;/span&gt;;&lt;br/&gt;};&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;2.文本块升级&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 13之前，字符串不能够多行使用，需要通过换行转义或者换行连接符等等，反正就是好麻烦、好难维护。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;String html = &lt;span class=&quot;hljs-string&quot;&gt;&quot;&amp;lt;html&amp;gt;\n&quot;&lt;/span&gt; +&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;    &amp;lt;body&amp;gt;\n&quot;&lt;/span&gt; +&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;        &amp;lt;p&amp;gt;Hello, 捡田螺的小男孩&amp;lt;/p&amp;gt;\n&quot;&lt;/span&gt; +&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;    &amp;lt;/body&amp;gt;\n&quot;&lt;/span&gt; +&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;&amp;lt;/html&amp;gt;\n&quot;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 13之后，清爽多了~&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;String html = &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;br/&gt;&amp;lt;html&amp;gt;&lt;br/&gt;&amp;lt;body&amp;gt;&lt;br/&gt;&amp;lt;p&amp;gt;Hello,  捡田螺的小男孩&amp;lt;/p&amp;gt;&lt;br/&gt;&amp;lt;/body&amp;gt;&lt;br/&gt;&amp;lt;/html&amp;gt;&lt;br/&gt;&quot;&lt;/span&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;3. SocketAPI 重构&lt;/span&gt;&lt;/h4&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;传统的Java Socket API（java.net.ServerSocket 和 java.net.Socket）依赖于SocketImpl 的内部实现&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;在 Java 13之前，通过使用 PlainSocketImpl 作为 SocketImpl 的具体实现。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;Java 13 中的新底层实现，引入 NioSocketImpl 的实现用以替换 SocketImpl 的 PlainSocketImpl 实现，此实现与 NIO（新 I/O）实现共享相同的内部基础结构，并且与现有的缓冲区高速缓存机制集成在一起。&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个Socket简单例子：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;5&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;4&quot;&gt;import java.io.IOException;&lt;br/&gt;import java.net.ServerSocket;&lt;br/&gt;import java.net.Socket;&lt;p&gt;public class SocketAPITest {&lt;br/&gt;public static void main(String[] args) {&lt;br/&gt;try (ServerSocket serverSocket = new ServerSocket(8080)){&lt;br/&gt;boolean runFlag = &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt;(runFlag){&lt;br/&gt;Socket clientSocket = serverSocket.accept();&lt;br/&gt;//搞事情&lt;br/&gt;}&lt;br/&gt;} catch (IOException e) {&lt;br/&gt;e.printStackTrace();&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行以上的实例，看下是否有以下关键词输出~&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;[class,load] sun.nio.ch.NioSocketImpl&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;4.FileSystems.newFileSystem新方法&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;FileSystems 类中添加了以下三种新方法，以便更容易地使用将文件内容视为文件系统的文件系统提供程序：&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;1、newFileSystem(Path)&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;2、newFileSystem(Path, Map&amp;lt;String, ?&amp;gt;)&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;3、newFileSystem(Path, Map&amp;lt;String, ?&amp;gt;, ClassLoader)&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;5. 增强 ZGC 释放未使用内存&lt;/span&gt;&lt;/h4&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;ZGC 是Java 11 中引入的最为瞩目的垃圾回收特性，是一种可伸缩、低延迟的垃圾收集器。但是实际使用中，它不能够主动将未使用的内存释放给操作系统。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;Java 13 中对 ZGC 的改进，包括释放未使用内存给操作系统、支持最大堆大小为 16TB、JVM参数-XX:SoftMaxHeapSize 来软限制堆大小&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;6.其他特性&lt;/span&gt;&lt;/h4&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;动态 CDS 存档， 扩展了 Java 10 中引入的类数据共享功能， 使用CDS 存档变得更容易。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;文本块的字符串类新方法，如formatted(Object…args)，stripIndent()等。&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;Java 14 新特性&lt;/span&gt;&lt;/h3&gt;
&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c386249741174a38b6d29f6900829a66~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;1. instanceof模式匹配&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;instanceof 传统使用方式：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (person instanceof Singer) {&lt;br/&gt;Singer singer = (Singer) person;&lt;br/&gt;singer.sing();&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (person instanceof Writer) {&lt;br/&gt;Writer writer = (Writer) person;&lt;br/&gt;writer.write();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 14 对 instanceof 进行模式匹配改进之后&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (person instanceof Singer singer) {&lt;br/&gt;singer.sing();&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (person instanceof Writer writer) {&lt;br/&gt;writer.write();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;2.Record 类型（预览功能）&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 14将Record 类型作为预览特性而引入，有点类似于Lombok 的@Data注解，看个例子吧：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;4&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;2&quot;&gt;public record Person(String name, int age) {&lt;br/&gt;public static String address;&lt;p&gt;public String &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;getName&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;return&lt;/span&gt; name;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;反编译结果：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;10.5&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;15&quot;&gt;public final class Person extends java.lang.Record {&lt;br/&gt;private final java.lang.String name;&lt;br/&gt;private final java.lang.String age;&lt;p&gt;public Person(java.lang.String name, java.lang.String age) { /* compiled code */ }&lt;/p&gt;&lt;p&gt;public java.lang.String &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;getName&lt;/span&gt;&lt;/span&gt;() { /* compiled code */ }&lt;/p&gt;&lt;p&gt;public java.lang.String &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;toString&lt;/span&gt;&lt;/span&gt;() { /* compiled code */ }&lt;/p&gt;&lt;p&gt;public final int &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;hashCode&lt;/span&gt;&lt;/span&gt;() { /* compiled code */ }&lt;/p&gt;&lt;p&gt;public final boolean equals(java.lang.Object o) { /* compiled code */ }&lt;/p&gt;&lt;p&gt;public java.lang.String &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;name&lt;/span&gt;&lt;/span&gt;() { /* compiled code */ }&lt;/p&gt;&lt;p&gt;public java.lang.String &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;age&lt;/span&gt;&lt;/span&gt;() { /* compiled code */ }&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以发现，当用 Record 来声明一个类时，该类将自动拥有下面特征：&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;构造方法&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;hashCode() 方法&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;euqals() 方法&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;toString() 方法&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;类对象被final 关键字修饰，不能被继承。&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;3. Switch 表达式-标准化&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;switch 表达式在之前的 Java 12 和 Java 13 中都是处于预览阶段，终于在 Java 14 标准化，成为稳定版本。&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;Java 12 为switch 表达式引入Lambda 语法&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;Java 13 使用yield代替 break 关键字来返回表达式的返回值。&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;String result = switch (day) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;M&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;W&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;F&quot;&lt;/span&gt; -&amp;gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;MWF&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;T&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;TH&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;S&quot;&lt;/span&gt; -&amp;gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;TTS&quot;&lt;/span&gt;;&lt;br/&gt;default -&amp;gt; {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (day.isEmpty()) {&lt;br/&gt;yield &lt;span class=&quot;hljs-string&quot;&gt;&quot;Please insert a valid day.&quot;&lt;/span&gt;;&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; {&lt;br/&gt;yield &lt;span class=&quot;hljs-string&quot;&gt;&quot;Looks like a Sunday.&quot;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;};&lt;br/&gt;System.out.println(result);&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;4. 改进 NullPointerExceptions提示信息&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 14 之前：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;4.5&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;3&quot;&gt;String name = song.getSinger().getSingerName()&lt;p&gt;//堆栈信息&lt;br/&gt;Exception &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; thread &lt;span class=&quot;hljs-string&quot;&gt;&quot;main&quot;&lt;/span&gt; java.lang.NullPointerException&lt;br/&gt;at NullPointerExample.main(NullPointerTest.java:6)&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 14，通过引入JVM 参数-XX:+ShowCodeDetailsInExceptionMessages，可以在空指针异常中获取更为详细的调用信息。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;Exception &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; thread &lt;span class=&quot;hljs-string&quot;&gt;&quot;main&quot;&lt;/span&gt; java.lang.NullPointerException: Cannot invoke &lt;span class=&quot;hljs-string&quot;&gt;&quot;Singer.getSingerName()&quot;&lt;/span&gt; &lt;br/&gt;because the &lt;span class=&quot;hljs-built_in&quot;&gt;return&lt;/span&gt; value of &lt;span class=&quot;hljs-string&quot;&gt;&quot;rainRow.getSinger()&quot;&lt;/span&gt; is null&lt;br/&gt;at NullPointerExample.main(NullPointerTest.java:6)&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;5. 其他特性&lt;/span&gt;&lt;/h4&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;G1 的 NUMA 可识别内存分配&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;删除 CMS 垃圾回收器&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;GC 支持 MacOS 和 Windows 系统&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;Java 15 新特性&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img src=&quot;https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/691c5bdd4de64d41bc5f50599b9ba078~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/96a3928212f1483ca669f6cbc7893c21~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;1.EdDSA 数字签名算法&lt;/span&gt;&lt;/h4&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;使用 Edwards-Curve 数字签名算法（EdDSA）实现加密签名。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;与其它签名方案相比，EdDSA 具有更高的安全性和性能。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;得到许多其它加密库（如 OpenSSL、BoringSSL）的支持。&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;2.Sealed Classes（封闭类，预览）&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;封闭类，可以是封闭类、封闭接口，防止其他类或接口扩展或实现它们。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;public abstract sealed class Singer&lt;br/&gt;permits Jay, Eason{&lt;br/&gt;...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类Singer被sealed 修饰，是封闭类，只能被2个指定子类（Jay, Eason）继承。&lt;/p&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;3. Hidden Classes（隐藏类）&lt;/span&gt;&lt;/h4&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;隐藏类天生为框架设计的。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;隐藏类只能通过反射访问，不能直接被其他类的字节码。&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;4. Remove the Nashorn JavaScript Engine&lt;/span&gt;&lt;/h4&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;Nashorn太难维护了，移除 Nashorn JavaScript引擎成为一种必然&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;其实早在JDK 11 中就已经被标记为 deprecated 了。&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;5.Reimplement the Legacy DatagramSocket API（重新实现DatagramSocket API）&lt;/span&gt;&lt;/h4&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;重新实现老的DatagramSocket API&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;更改java.net.DatagramSocket 和 java.net.MulticastSocket 为更加简单、现代化的底层实现。&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;6.其他&lt;/span&gt;&lt;/h4&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;Disable and Deprecate Biased Locking（准备禁用偏向锁）&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;instanceof 自动匹配模式（预览）&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;ZGC，一个可伸缩、低延迟的垃圾回收器。（转正）&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;Text Blocks，文本功能转正（JDK 13和14预览，14终于转正）&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;Remove the Solaris and SPARC Ports（删除 Solaris 和 SPARC 端口）&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;外部存储器访问 API（允许Java 应用程序安全有效地访问 Java 堆之外的外部内存。）&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;Record类型二次预览（在Java 14就预览过啦）&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;参考与感谢&lt;/span&gt;&lt;/h3&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;个人公众号&lt;/span&gt;&lt;/h3&gt;
&lt;img src=&quot;https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2845e9f737f14311a119f45751683b3c~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;
</description>
<pubDate>Sat, 19 Sep 2020 00:17:00 +0000</pubDate>
<dc:creator>Jay_huaxiao</dc:creator>
<og:description>前言 JDK 15发布啦~ 我们一起回顾JDK 5-15 的新特性吧，大家一起学习哈~ 本文已经收录到github ❝ https://github.com/whx123/JavaHome ❞ 「公众</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jay-huaxiao/p/13694593.html</dc:identifier>
</item>
<item>
<title>从一次编译出发梳理概念: Jetty,Jersey,hk2,glassFish,Javax,Jakarta  - 罗西的思考</title>
<link>http://www.cnblogs.com/rossiXYZ/p/13694489.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rossiXYZ/p/13694489.html</guid>
<description>&lt;p&gt;本文借助一次开源项目的编译过程，梳理了一些java相关概念，与大家分享此文。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;284.83439860546&quot;&gt;


&lt;h2 id=&quot;0x00-摘要&quot;&gt;0x00 摘要&lt;/h2&gt;
&lt;p&gt;本文借助一次开源项目的编译过程，梳理了一些java相关概念，与大家分享此文。&lt;/p&gt;
&lt;h2 id=&quot;0x01-缘由&quot;&gt;0x01 缘由&lt;/h2&gt;
&lt;p&gt;最近在编译蚂蚁金服的sofa-registry，因为不可名状的原因，无法完全下载依赖的maven包，所以只能手动一个一个下载。事实证明，这是一个痛苦的过程，因为各种java包环环相扣，于是一个个java相关概念跃入眼帘。索性把这些概念一一梳理下，与大家分享。&lt;/p&gt;
&lt;p&gt;比如从下面 &lt;code&gt;mvn dependency:tree&lt;/code&gt; 的输出结果看，我们遇到的概念或者名词就有：&lt;u&gt;&lt;strong&gt;glassfish，javax.ws.rs，jersey，jetty，hk2，javax.inject，javax.annotation&lt;/strong&gt;&lt;/u&gt; ......&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;[INFO] +- com.alipay.sofa:registry-remoting-http:jar:5.4.2:compile
[INFO] |  +- org.glassfish.jersey.core:jersey-server:jar:2.26:compile
[INFO] |  |  +- org.glassfish.jersey.core:jersey-common:jar:2.26:compile
[INFO] |  |  |  \- org.glassfish.hk2:osgi-resource-locator:jar:1.0.1:compile
[INFO] |  |  +- javax.ws.rs:javax.ws.rs-api:jar:2.1:compile
[INFO] |  |  +- org.glassfish.jersey.media:jersey-media-jaxb:jar:2.25.1:compile
[INFO] |  |  |  \- org.glassfish.hk2:hk2-api:jar:2.5.0-b32:compile
[INFO] |  |  +- javax.annotation:javax.annotation-api:jar:1.2:compile
[INFO] |  |  \- org.glassfish.hk2.external:javax.inject:jar:2.5.0-b42:compile
[INFO] |  +- org.glassfish.jersey.inject:jersey-hk2:jar:2.26:compile
[INFO] |  |  \- org.glassfish.hk2:hk2-locator:jar:2.5.0-b42:compile
[INFO] |  |     +- org.glassfish.hk2:hk2-utils:jar:2.5.0-b42:compile
[INFO] |  |     |  \- javax.inject:javax.inject:jar:1:compile
[INFO] |  |     \- org.javassist:javassist:jar:3.21.0-GA:compile
[INFO] |  +- org.eclipse.jetty:jetty-server:jar:9.4.19.v20190610:compile
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;0x02-概念&quot;&gt;0x02 概念&lt;/h2&gt;
&lt;h3 id=&quot;21-jsr&quot;&gt;2.1 JSR&lt;/h3&gt;
&lt;p&gt;JSR 是 Java Specification Requests 的缩写，意思是Java 规范提案。是指向 JCP (Java Community Process)提出新增一个标准化技术规范的正式请求。任何人都可以提交JSR，以向Java平台增添新的API和服务。JSR已成为Java界的一个重要标准。&lt;/p&gt;
&lt;h3 id=&quot;22-javax&quot;&gt;2.2 javax&lt;/h3&gt;
&lt;p&gt;java 和 javax 都是Java的API(Application Programming Interface)包，java是核心包，javax的x是extension的意思，也就是扩展包。&lt;/p&gt;
&lt;p&gt;java类库是java发布之初就确定了的基础库，而javax类库则是在上面增加的一层东西，就是为了保持版本兼容要保存原来的，但有些东西有了更好的解决方案，所以就加上些。典型的就是awt(Abstract Windowing ToolKit) 和swing。&lt;/p&gt;
&lt;h3 id=&quot;23-jsr311&quot;&gt;2.3 JSR311&lt;/h3&gt;
&lt;h4 id=&quot;231-jsr311&quot;&gt;2.3.1 JSR311&lt;/h4&gt;
&lt;p&gt;JSR311是java中实现Restful Web Service的API规范&lt;u&gt;（JSR311: &lt;strong&gt;JAX-RS&lt;/strong&gt;: The Java API for RESTful Web Services）&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;JSR311有一个重要目标：使用注解（annotation）把POJO暴露成Web Service，这样就比较轻量级。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;jsr311-api&lt;/strong&gt; - 这是JAX-RS 1.x系列的官方规范jar&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;javax.ws.rs-api&lt;/strong&gt; - 这是JAX-RS 2.x系列的官方规范jar&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;232-javaxwsrs&quot;&gt;2.3.2 javax.ws.rs&lt;/h4&gt;
&lt;p&gt;java.ws.rs 是&lt;strong&gt;JAX-RS&lt;/strong&gt;规范中定义的包名。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;jax-rs&lt;/code&gt; 全称 Java API for RESTful Services，规范目前版本是 2.0。&lt;/p&gt;
&lt;p&gt;jax-rs 中定义了：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;一组启动方式&lt;/code&gt; (以jee作为http容器，还是配合servlet作为http容器)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;一组注解&lt;/code&gt; &lt;code&gt;@GET, @POST, @DELETE, @PUT, @Consumes ...&lt;/code&gt; 通过 POJO Resource类, 提供Rest服务&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;就像 JSR 规范中定义了 Servlet 是 以继承 HttpServlet 并重写 doGet, doPost, do... 方法 一样。只要遵循 这套标准的 我们我们都可以称之为 Servlet 程序。你写的 Servlet 程序，可以不经过任何修改，放到任何实现 Servlet 容器中运行。类似，&lt;u&gt;你写的 jax-rs 程序，可以不经任何修改，和任何 jax-rs 框架配合使用&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;而 Spring MVC 是以 Servlet 为http容器，并自己构建了一套Api，没有遵循 &lt;code&gt;jax-rs&lt;/code&gt; 规范。&lt;/p&gt;
&lt;h4 id=&quot;233-框架&quot;&gt;2.3.3 框架&lt;/h4&gt;
&lt;p&gt;目前实现 jax-rs 标准的框架有很多：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Apache CXF，开源的Web服务框架。&lt;/li&gt;
&lt;li&gt;Jersey， 由Sun提供的JAX-RS的参考实现。&lt;/li&gt;
&lt;li&gt;RESTEasy，JBoss的实现。&lt;/li&gt;
&lt;li&gt;Restlet，由Jerome Louvel和Dave Pawson开发，是最早的REST框架，先于JAX-RS出现。&lt;/li&gt;
&lt;li&gt;Apache Wink，一个Apache软件基金会孵化器中的项目，其服务模块实现JAX-RS规范&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;234-jersey&quot;&gt;2.3.4 Jersey&lt;/h4&gt;
&lt;p&gt;Jersey 是 JAX-RS（JSR311）开源参考实现。&lt;/p&gt;
&lt;p&gt;SpringMVC在开发REST应用时，是不支持 JSR311/JSR339 标准的。如果想要按照标准行事，最常用的实现了这两个标准的框架就是Jersey和CxF了。但因为Jersey是最早的实现，也是JSR311参考的主要对象，可以说Jersey就是事实上的标准（类似Hibernate是JPA的事实上的标准），也是现在使用最为广泛的REST开发框架之一。&lt;/p&gt;
&lt;p&gt;Jersey用于构建 RESTful Web service。此外 Jersey 还提供一些额外的 API 和扩展机制，所以开发人员能够按照自己的需要对 Jersey 进行扩展。&lt;/p&gt;
&lt;p&gt;sun.Jersey 和 glassfish.Jersey 是Jersey的两个版本，对应1.x和2.x，其中：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1.x中Jersey的包是以com.sun开头。&lt;/li&gt;
&lt;li&gt;2.x是以org.glassfish为前缀。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;24-jsr-330&quot;&gt;2.4 JSR-330&lt;/h3&gt;
&lt;h4 id=&quot;241-jsr-330&quot;&gt;2.4.1 JSR-330&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;JSR-330&lt;/code&gt; 是 &lt;code&gt;Java&lt;/code&gt; 的依赖注入标准。定义了如下的术语描述依赖注入：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;A 类型依赖 B类型（或者说 B 被 A 依赖），则 A类型 称为”&lt;strong&gt;依赖(物) dependency&lt;/strong&gt;”&lt;/li&gt;
&lt;li&gt;运行时查找依赖的过程，称为”&lt;strong&gt;解析 resolving&lt;/strong&gt;“依赖&lt;/li&gt;
&lt;li&gt;如果找不到依赖的实例，称该依赖是”&lt;strong&gt;不能满足的 unsatisfied&lt;/strong&gt;”&lt;/li&gt;
&lt;li&gt;在”依赖注入 dependency injection”机制中，提供依赖的工具称为 ”依赖注入器 dependency injector”&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;242-javaxinject&quot;&gt;2.4.2 javax.inject&lt;/h4&gt;
&lt;p&gt;标准对依赖注入的使用进行了定义, 但是对实现和配置未定义。&lt;code&gt;Java EE&lt;/code&gt;包&lt;code&gt;javax.inject&lt;/code&gt;对应此标准。其中也仅定义了依赖注入的使用（即通过注解），同样也未定义依赖注入的配置方式和实现方式。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;javax.inject&lt;/code&gt; 提供如下5个注解（Inject、Qualifier、Named、Scope、Singleton）和1个接口（Provider）。&lt;/p&gt;
&lt;h4 id=&quot;243-框架&quot;&gt;2.4.3 框架&lt;/h4&gt;
&lt;p&gt;支持JSR-330的框架有很多：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Android下面的Dagger2就是基于这个规范。在dagger2 中用的JSR-330标准注释有：@Inject @Qualifier @Scope @Named等。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Guice&lt;/code&gt;是一个由Google实现的针对Java 6以上版本的流行的、轻量级的DI框架。&lt;/li&gt;
&lt;li&gt;而其他的注入框架如Spring也支持JSR-330。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当使用JSR-330标准的注解时，了解其和Spring注解的不同点也是十分必要的，参考如下表。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Spring&lt;/th&gt;
&lt;th&gt;javax.inject.*&lt;/th&gt;
&lt;th&gt;javax.inject 限制&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;7.5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;@Autowired&lt;/td&gt;
&lt;td&gt;@Inject&lt;/td&gt;
&lt;td&gt;&lt;code&gt;@Inject&lt;/code&gt;注解没有&lt;code&gt;required&lt;/code&gt;属性，但是可以通过Java 8的&lt;code&gt;Optional&lt;/code&gt;取代&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;@Component&lt;/td&gt;
&lt;td&gt;@Named&lt;/td&gt;
&lt;td&gt;JSR_330标准并没有提供复合的模型，只有一种方式来识别组件&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;@Scope(“singleton”)&lt;/td&gt;
&lt;td&gt;@Singleton&lt;/td&gt;
&lt;td&gt;JSR-330默认的作用域类似Spring的&lt;code&gt;prototype&lt;/code&gt;，然而，为何和Spring的默认保持一致，JSR-330标准中的Bean在Spring中默认也是单例的。如果要使用非单例的作用域，开发者应该使用Spring的&lt;code&gt;@Scope&lt;/code&gt;注解。&lt;code&gt;java.inject&lt;/code&gt;也提供一个&lt;code&gt;@Scope&lt;/code&gt;注解，然而，这个注解仅仅可以用来创建自定义的作用域时才能使用。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;@Qualifier&lt;/td&gt;
&lt;td&gt;@Qualifier/@Named&lt;/td&gt;
&lt;td&gt;&lt;code&gt;javax.inject.Qualifier&lt;/code&gt;仅仅是一个元注解，用来构建自定义限定符的。而String的限定符（比如Spring中的&lt;code&gt;@Qualifier&lt;/code&gt;）可以通过&lt;code&gt;javax.inject.Named&lt;/code&gt;来实现&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@Value&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;不等价&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@Required&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;不等价&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@Lazy&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;不等价&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;ObjectFactory&lt;/td&gt;
&lt;td&gt;Provider&lt;/td&gt;
&lt;td&gt;&lt;code&gt;javax.inject.Provider&lt;/code&gt;是Spring&lt;code&gt;ObjectFactory&lt;/code&gt;的另一个选择，通过&lt;code&gt;get()&lt;/code&gt;方法来代理，&lt;code&gt;Provider&lt;/code&gt;可以和Spring的&lt;code&gt;@Autowired&lt;/code&gt;组合使用&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;244-hk2&quot;&gt;2.4.4 hk2&lt;/h4&gt;
&lt;p&gt;HK2是一个轻量级动态依赖注入框架，&lt;u&gt;它是JSR-330的实现&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;HK2的全称为“Hundred Kilobytes Kernel”，包括Modules Subsytem和Component Model两部分。SUN在其开源的GlassFish J2EE应用服务器项目中将HK2作为其系统内核实现。&lt;/p&gt;
&lt;p&gt;在HK2组件模型中，一个组件的功能是通过服务接口-服务实现的模式声明的。一个HK2服务接口 标识并描述了一个构建模块或者应用程序扩展点。HK2服务实现实现了HK2服务接口。&lt;/p&gt;
&lt;p&gt;hk2包为 &lt;u&gt;org.glassfish.hk2&lt;/u&gt;。&lt;/p&gt;
&lt;h3 id=&quot;25-jsr-250&quot;&gt;2.5 JSR 250&lt;/h3&gt;
&lt;h4 id=&quot;251-jsr-250&quot;&gt;2.5.1 JSR 250&lt;/h4&gt;
&lt;p&gt;JSR 250 规范包含用于将资源注入到端点实现类的注释和用于管理应用程序生命周期的注释。&lt;/p&gt;
&lt;h4 id=&quot;252-javaxannotation&quot;&gt;2.5.2 javax.annotation&lt;/h4&gt;
&lt;p&gt;包含 JST 250 标准中的每一个注释的 Java™ 类的名称为 &lt;u&gt;&lt;strong&gt;javax.annotation.&lt;em&gt;xxx&lt;/em&gt;&lt;/strong&gt;&lt;/u&gt;，其中 &lt;em&gt;xxx&lt;/em&gt; 是“@”字符后面的注释的名称。 例如，@Resource 注释的 Java 类名为 javax.annotation.resource。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;javax.annotation&lt;/em&gt; 中主要包含以下几个注解：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;@Generated：生成资源的注解，通过该项标记产生的实例是一个资源。类似于Spring中的@Bean注解，用于生成一向资源。&lt;/li&gt;
&lt;li&gt;@PostConstruct 创造资源之后的回调处理。&lt;/li&gt;
&lt;li&gt;@PreDestroy 销毁资源之前的回调处理。&lt;/li&gt;
&lt;li&gt;@Resource 标记使用资源的位置。功能上有些类似于@Autowired、@Inject，但是两者有不少的差别。&lt;/li&gt;
&lt;li&gt;@Resources 标记使用多项资源的位置，类似于使用@Autowired向一个列表装载数据。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;253-框架&quot;&gt;2.5.3 框架&lt;/h4&gt;
&lt;p&gt;仔细看JSR-250定义的这些注解就会发现，他们都是关于“资源”的构建、销毁、使用的。&lt;/p&gt;
&lt;p&gt;&lt;u&gt;Spring实现了@PostConstruct、@PreDestroy和@Resource&lt;/u&gt;。&lt;/p&gt;
&lt;h3 id=&quot;26-jakarta&quot;&gt;2.6 Jakarta&lt;/h3&gt;
&lt;p&gt;虽然Oracle 决定把 JavaEE 移交给开源组织 Eclipse 基金会，但是不希望 JavaEE 继续使用 Java 这个名字。于是 Eclipse 做了一项民意调查，最终 JakartaEE 已明显的优势胜出。因此&lt;strong&gt;Eclipse 宣布正式将 JavaEE 更名为 JakartaEE&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;Eclipse基金会也对 Java EE 标准的每个规范进行了重命名，阐明了每个规范在Jakarta EE平台未来的角色。&lt;/p&gt;
&lt;p&gt;新的名称Jakarta EE是Java EE的第二次重命名。2006年5月，“J2EE”一词被弃用，并选择了Java EE这个名称。在YouTube还只是一家独立的公司的时候，数字2就就从名字中消失了，而且当时冥王星仍然被认为是一颗行星。同样，作为Java SE 5（2004）的一部分，数字2也从J2SE中删除了，那时谷歌还没有上市。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;因为不能再使用javax名称空间，Jakarta EE提供了非常明显的分界线。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Jakarta 9（2019及以后）使用jakarta命名空间。&lt;/li&gt;
&lt;li&gt;Java EE 5（2005）到Java EE 8（2017）使用javax命名空间。&lt;/li&gt;
&lt;li&gt;Java EE 4使用javax命名空间。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;u&gt;提到java改名，我想起了javaeye网站更名为iteye之后，影响力急剧下降，令人扼腕&lt;/u&gt;。&lt;/p&gt;
&lt;h3 id=&quot;27-glassfish&quot;&gt;2.7 GlassFish&lt;/h3&gt;
&lt;p&gt;Eclipse Foundation不只是发布规范。它还发布了Eclipse GlassFish 5.1，这是一个可立即运行的Jakarta EE 8实现。它还被认证为Jakarta EE 8平台的开源兼容实现。&lt;/p&gt;
&lt;p&gt;GlassFish 是用于构建 Java EE 5应用服务器的开源开发项目的名称。它基于 Sun Microsystems 提供的 Sun Java System Application Server PE 9 的源代码以及 Oracle 贡献的 TopLink 持久性代码。该项目提供了开发高质量应用服务器的结构化过程，以前所未有的速度提供新的功能。这是对希望能够获得源代码并为开发 Sun 的下一代应用服务器（基于 GlassFish）作出贡献的 Java 开发者作出的回应。该项目旨在促进 Sun 和 Oracle 工程师与社区之间的交流，它将使得所有开发者都能够参与到应用服务器的开发过程中来。&lt;/p&gt;
&lt;p&gt;过去，新EE功能诞生的过程称为Java Community Process。&lt;/p&gt;
&lt;p&gt;Java SE今天仍然使用JCP。但是，由于EE已经改变了它的所有权，从Oracle到Eclipse Foundation，我们有一个新的独立流程。它是Eclipse Foundation Specification Process（&lt;a href=&quot;https://www.eclipse.org/projects/efsp/&quot;&gt;EFSP&lt;/a&gt;），是&lt;a href=&quot;https://www.eclipse.org/projects/dev_process&quot;&gt;Eclipse Development Process&lt;/a&gt;的扩展。&lt;/p&gt;
&lt;p&gt;作为JCP的一部分，JSR需要一个具体的参考实现。这有点像实现接口的类。参考实现必须兼容以往库包或其他组织的开发人员创建自己的规范实现。&lt;/p&gt;
&lt;p&gt;&lt;u&gt;对于Java EE功能，JCP使用Glassfish作为其参考实现&lt;/u&gt;。&lt;/p&gt;
&lt;h3 id=&quot;28-jetty&quot;&gt;2.8 Jetty&lt;/h3&gt;
&lt;p&gt;Jetty 是一个开源的servlet容器，它为基于Java的web容器，例如JSP和servlet提供运行环境。Jetty是使用Java语言编写的，它的API以一组JAR包的形式发布。开发人员可以将Jetty容器实例化成一个对象，可以迅速为一些独立运行（stand-alone）的Java应用提供网络和web连接。由于其轻量、灵活的特性，Jetty也被应用于一些知名产品中，例如ActiveMQ、Maven、Spark、GoogleAppEngine、Eclipse、Hadoop等。&lt;/p&gt;
&lt;p&gt;为什么使用Jetty？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;异步的 Servlet，支持更高的并发量&lt;/li&gt;
&lt;li&gt;模块化的设计，更灵活，更容易定制，也意味着更高的资源利用率&lt;/li&gt;
&lt;li&gt;在面对大量长连接的业务场景下，Jetty 默认采用的 NIO 模型是更好的选择&lt;/li&gt;
&lt;li&gt;将jetty嵌入到应用中，使一个普通应用可以快速支持 http 服务&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;29-概念关系&quot;&gt;2.9 概念关系&lt;/h3&gt;
&lt;p&gt;以上涉及概念中，若干关系如下（ 只是大致逻辑示意图，不代表继承等关系 ）：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;  +--------+                  +--------+                   +---------+            Jakarta
  | JSR311 |                  | JSR330 |                   | JSR 250 |
  +----+---+                  +----+---+                   +----+----+
       |                           |                            |
       v                           v                            v
+------+-----+              +------+-----+             +--------+-------+
|javax.ws.rs |              |javax.inject|             |javax.annotation|
+------+-----+              +------+-----+             +--------+-------+
       |                           |                            |
       |                           v                            |
       |                   +-------+---------+                  |
       |     +-----------+ |org.glassfish.hk2|                  |
       |     |             +-----------------+                  |
       |     |                                                  |
       v     v                                                  |
+------+-----+-------+                                          |
|org.glassfish.jersey| &amp;lt;----------------------------------------+
+-------------------++
                    |
                    v
                +---+---+
                | Jetty |
                +-------+
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;0x03-在sofaregistry的使用&quot;&gt;0x03 在SOFARegistry的使用&lt;/h2&gt;
&lt;p&gt;我们来看看前面提到的概念中，其中几个在SOFARegistry中如何使用。&lt;/p&gt;
&lt;h3 id=&quot;31-javaxwsrs&quot;&gt;3.1 javax.ws.rs&lt;/h3&gt;
&lt;p&gt;javax.ws.rs是JSR311的包名。其重要目标是：使用注解（annotation）把POJO暴露成Web Service。&lt;/p&gt;
&lt;p&gt;具体举例如下，可以看到 DecisionModeResource 已经被暴露成 Web Service：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.alipay.sofa.registry.server.meta.resource;

import javax.ws.rs.POST;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;

@Path(&quot;decisionMode&quot;)
public class DecisionModeResource {

    @Autowired
    private MetaServerConfig metaServerConfig;

    @POST
    @Produces(MediaType.APPLICATION_JSON)
    public Result changeDecisionMode(DecisionMode decisionMode) {
        ((MetaServerConfigBean) metaServerConfig).setDecisionMode(decisionMode);
        Result result = new Result();
        result.setSuccess(true);
        return result;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;32-jersey和jetty&quot;&gt;3.2 jersey和jetty&lt;/h3&gt;
&lt;p&gt;因为jetty轻量级的特点，在SOFARegistry中，使用了 org.eclipse.jetty.server.Server，从而拉开了一场大戏。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;com.alipay.sofa.registry.remoting.jersey.JerseyJettyServer

import javax.ws.rs.ProcessingException;
import org.eclipse.jetty.server.Connector;
import org.eclipse.jetty.server.ServerConnector;
import org.eclipse.jetty.util.thread.QueuedThreadPool;
import org.glassfish.jersey.internal.guava.ThreadFactoryBuilder;
import org.glassfish.jersey.jetty.JettyHttpContainer;
import org.glassfish.jersey.jetty.internal.LocalizationMessages;
import org.glassfish.jersey.process.JerseyProcessingUncaughtExceptionHandler;
import org.glassfish.jersey.server.ContainerFactory;
import org.glassfish.jersey.server.ResourceConfig;
import org.glassfish.jersey.server.spi.Container;

public class JerseyJettyServer implements Server {
        private org.eclipse.jetty.server.Server server;
        
        public static org.eclipse.jetty.server.Server createServer(final URI uri,
                                                        final ResourceConfig resourceConfig,
                                                        final boolean start) {
    JettyHttpContainer handler = 
                 ContainerFactory.createContainer(JettyHttpContainer.class, resourceConfig);  
    final org.eclipse.jetty.server.Server server = new org.eclipse.jetty.server.Server(
            new JettyConnectorThreadPool());
    server.setHandler(handler);
    server.start();
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;33-hk2&quot;&gt;3.3 hk2&lt;/h3&gt;
&lt;p&gt;HK2是一个轻量级动态依赖注入框架，&lt;u&gt;它是JSR-330的实现&lt;/u&gt;。其应用十分广泛且底层，比如在 jersey 中就有各种直接或者间接的使用。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package org.glassfish.jersey.server;

...
import org.glassfish.jersey.internal.inject.Binder;
import org.glassfish.jersey.internal.inject.Bindings;
import org.glassfish.jersey.internal.inject.CompositeBinder;
import org.glassfish.jersey.internal.inject.InjectionManager;
import org.glassfish.jersey.internal.inject.Injections;
import org.glassfish.jersey.internal.inject.InstanceBinding;
import org.glassfish.jersey.internal.inject.Providers;
...
  
public final class ApplicationHandler implements ContainerLifecycleListener {
  ...
    public ApplicationHandler(final Class&amp;lt;? extends Application&amp;gt; jaxrsApplicationClass) {
        initialize(new ApplicationConfigurator(jaxrsApplicationClass), Injections.createInjectionManager(), null);
    }
  ...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;org.glassfish.jersey.internal.inject.*&lt;/code&gt; 是一个对hk2的封装，选取一个堆栈给大家看看，能够看到最终调用到了 hk2。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;value:73, NamedImpl (org.glassfish.hk2.utilities)
invoke0:-1, NativeMethodAccessorImpl (sun.reflect)
invoke:62, NativeMethodAccessorImpl (sun.reflect)
invoke:43, DelegatingMethodAccessorImpl (sun.reflect)
invoke:498, Method (java.lang.reflect)
invoke:309, AnnotationLiteral (org.glassfish.hk2.api)
hashCode:242, AnnotationLiteral (org.glassfish.hk2.api)
hash:339, HashMap (java.util)
put:612, HashMap (java.util)
add:220, HashSet (java.util)
getThreeThirtyDescriptor:1282, Utilities (org.jvnet.hk2.internal)
initialize:76, ServiceLocatorGeneratorImpl (org.jvnet.hk2.external.generator)
create:103, ServiceLocatorGeneratorImpl (org.jvnet.hk2.external.generator)
internalCreate:312, ServiceLocatorFactoryImpl (org.glassfish.hk2.internal)
create:268, ServiceLocatorFactoryImpl (org.glassfish.hk2.internal)
createLocator:114, AbstractHk2InjectionManager (org.glassfish.jersey.inject.hk2)
&amp;lt;init&amp;gt;:86, AbstractHk2InjectionManager (org.glassfish.jersey.inject.hk2)
&amp;lt;init&amp;gt;:62, ImmediateHk2InjectionManager (org.glassfish.jersey.inject.hk2)
createInjectionManager:79, Hk2InjectionManagerFactory$Hk2InjectionManagerStrategy$1 (org.glassfish.jersey.inject.hk2)
create:97, Hk2InjectionManagerFactory (org.glassfish.jersey.inject.hk2)
createInjectionManager:93, Injections (org.glassfish.jersey.internal.inject)
&amp;lt;init&amp;gt;:282, ApplicationHandler (org.glassfish.jersey.server)
&amp;lt;init&amp;gt;:469, JettyHttpContainer (org.glassfish.jersey.jetty)
createContainer:61, JettyHttpContainerProvider (org.glassfish.jersey.jetty)
createContainer:82, ContainerFactory (org.glassfish.jersey.server)
createServer:100, JerseyJettyServer (com.alipay.sofa.registry.remoting.jersey)
startServer:83, JerseyJettyServer (com.alipay.sofa.registry.remoting.jersey)
......
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;0xff-参考&quot;&gt;0xFF 参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_36883987/article/details/82183053&quot;&gt;Glassfish的安装与使用&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/a9b0ebd4c3fe&quot;&gt;Jersey是一个什么框架,价值在哪里？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://baike.baidu.com/item/jetty/370234&quot;&gt;jetty&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://baike.baidu.com/item/javax/6413567&quot;&gt;javax&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/46eab9bf774a&quot;&gt;import java和javax有什么区别？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://jakarta.apache.org/&quot;&gt;http://jakarta.apache.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.baeldung.com/java-enterprise-evolution&quot;&gt;JEE、J2EE与Jakarta等概念解释&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://baijiahao.baidu.com/s?id=1594743793083794097&amp;amp;wfr=spider&amp;amp;for=pc&quot;&gt;从此再无 JavaEE，现在叫 JakartaEE&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/88f97b90963c&quot;&gt;Jersey 开发RESTful（七）Jersey快速入门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/setlilei/article/details/99211804&quot;&gt;javax.ws.rs restful开发&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/u010278882/article/details/50773687&quot;&gt;Java 依赖注入标准 JSR-330 简介&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/youanyyou/article/details/97205164&quot;&gt;厉害了，Java EE 再次更名为 Jakarta EE&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/chouyanzha3932/article/details/100946316&quot;&gt;轻量级IOC/DI 容量HK2初探（零配置）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/renzhe333/article/details/10207481&quot;&gt;JSR311让Restful WebService变简单&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/Dream_Weave/article/details/108330885&quot;&gt;Spring - JSR-330 标准注解&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Fri, 18 Sep 2020 22:51:00 +0000</pubDate>
<dc:creator>罗西的思考</dc:creator>
<og:description>本文借助一次开源项目的编译过程，梳理了一些java相关概念，与大家分享此文。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/rossiXYZ/p/13694489.html</dc:identifier>
</item>
<item>
<title>Django 模型层 - 云崖先生</title>
<link>http://www.cnblogs.com/Yunya-Cnblogs/p/13694386.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Yunya-Cnblogs/p/13694386.html</guid>
<description>&lt;p&gt;　　 &lt;code&gt;Django&lt;/code&gt;模型层的功能就是与数据库打交道，其中最主要的框架为&lt;code&gt;ORM&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;　　 &lt;code&gt;ORM&lt;/code&gt;为对象关系映射，说白了就是将&lt;code&gt;Python&lt;/code&gt;中的类映射成数据表，将表中每一条记录映射成类的实例对象，将对象属性映射成表中的字段。&lt;/p&gt;
&lt;p&gt;　　 如果用原生的&lt;code&gt;SQL&lt;/code&gt;语句结合&lt;code&gt;pymysql&lt;/code&gt;来对数据库进行操作无疑是非常繁琐的，但是&lt;code&gt;Django&lt;/code&gt;提供了非常强大的&lt;code&gt;ORM&lt;/code&gt;框架来对数据库进行操作，在增删改查方面都有非常大的提升，学会使用&lt;code&gt;ORM&lt;/code&gt;十分的必要。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;　　 注意：尽管&lt;code&gt;ORM&lt;/code&gt;十分方便，但是也请不要过分依赖它从而忘记原生&lt;code&gt;SQL&lt;/code&gt;命令。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　 &lt;code&gt;ORM&lt;/code&gt;作为&lt;code&gt;Django&lt;/code&gt;中最难的一章基础知识点，应该是很多初学者的第一道门槛。&lt;/p&gt;
&lt;p&gt;　　 那么在学习&lt;code&gt;ORM&lt;/code&gt;之前，我想写一些我的心得体会，&lt;code&gt;ORM&lt;/code&gt;的操作很方便，但是有些设计比较反人类，你可以使用原生&lt;code&gt;SQL&lt;/code&gt;进行代替。&lt;/p&gt;
&lt;p&gt;　　 条条大路通罗马，不一定非要在一棵树上吊死。&lt;/p&gt;

&lt;h2&gt;原生语句&lt;/h2&gt;
&lt;p&gt;　　 如果想在操作&lt;code&gt;ORM&lt;/code&gt;时还能看到原生的&lt;code&gt;SQL&lt;/code&gt;语句，请在&lt;code&gt;settings.py&lt;/code&gt;中添加上以下代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'handlers': {
        'console':{
            'level':'DEBUG',
            'class':'logging.StreamHandler',
        },
    },
    'loggers': {
        'django.db.backends': {
            'handlers': ['console'],
            'propagate': True,
            'level':'DEBUG',
        },
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;测试脚本&lt;/h2&gt;
&lt;p&gt;　　 &lt;code&gt;Django&lt;/code&gt;中允许对&lt;code&gt;py&lt;/code&gt;文件做单独的测试，而不用启动&lt;code&gt;Django&lt;/code&gt;项目，这是非常方便的。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;　　 注意：所有测试中的代码都必须在&lt;code&gt;if &quot;__name__&quot; == &quot;__main__&quot;:&lt;/code&gt;下进行，这意味着你的&lt;code&gt;from xx import xx&lt;/code&gt;不能放在顶行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;from django.test import TestCase

# Create your tests here.
import os
import sys
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))  # 如果在pycharm中，这两句可以省略

if __name__ == &quot;__main__&quot;:
    os.environ.setdefault(&quot;DJANGO_SETTINGS_MODULE&quot;, &quot;project01.settings&quot;)

    import django
    django.setup()

    # 测试代码均在下面进行
    from app01 import models
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;　　 &lt;code&gt;Django&lt;/code&gt;中默认使用的数据库是&lt;code&gt;sqlit3&lt;/code&gt;，所以我们需要在配置文件中对其实行修改。&lt;/p&gt;
&lt;p&gt;　　 大体分为两个步骤&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;　　 1.修改默认链接为&lt;code&gt;MySQL&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;　　 2.链接声明，即声明链接&lt;code&gt;MySQL&lt;/code&gt;的模块为&lt;code&gt;pymysql&lt;/code&gt;（默认是&lt;code&gt;MySQLdb&lt;/code&gt;）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;修改链接&lt;/h2&gt;
&lt;p&gt;　　 打开项目全局文件夹下的&lt;code&gt;settings.py&lt;/code&gt;，找到以下代码进行注释&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',  # 默认链接sqlite3
        'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 现在我们就要进行手动配置了，参照如下代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',  # 默认链接sqlite3
        'NAME': 'db1',                  # 你的数据库名称
        'USER': 'root',                 # 你的登录用户名称
        'PASSWORD': '123',              # 你的登录密码，如果没有留空即可
        'HOST': 'localhost',    # 链接地址
        'PORT': '3306',                 # MySQL服务端端口号
        'CHARSET': 'utf8mb4',   # 默认字符编码
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 现在，你的&lt;code&gt;Django&lt;/code&gt;会抛出一个异常，不管他，直接进入下一个步骤&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;django.core.exceptions.ImproperlyConfigured: Error loading MySQLdb module: No module named 'MySQLdb'.
Did you install mysqlclient or MySQL-python?
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;链接声明&lt;/h2&gt;
&lt;p&gt;　　 由于我们要将默认链接&lt;code&gt;MySQL&lt;/code&gt;的模块从&lt;code&gt;MySQLdb&lt;/code&gt;修改为&lt;code&gt;pymysql&lt;/code&gt;，所以你要先安装&lt;code&gt;pymysql&lt;/code&gt;模块&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;pip install pymysql
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 安装完成后打开项目全局文件夹下的&lt;code&gt;__init__&lt;/code&gt;（实际上任意&lt;code&gt;APP&lt;/code&gt;下的&lt;code&gt;__init__&lt;/code&gt;都可以），添加代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import pymysql
pymysql.install_as_MySQLdb()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 现在我们的&lt;code&gt;Django&lt;/code&gt;就可以使用&lt;code&gt;MySQL&lt;/code&gt;进行连接了。&lt;/p&gt;

&lt;p&gt;　　 &lt;code&gt;ORM&lt;/code&gt;为对象关系映射，类就相当于数据表，属性就相当于字段。&lt;/p&gt;
&lt;p&gt;　　 因此我们有两条很常见的命令用于操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;python manage.py makemigrations  # 创建模型映射表
python manage.py migrate # 同步模型表至数据库中
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 这两条命令在对数据库字段、数据表结构进行修改时都需要重新进行。&lt;/p&gt;
&lt;h2&gt;单表创建&lt;/h2&gt;
&lt;p&gt;　　 在项目的&lt;code&gt;APP&lt;/code&gt;中，打开&lt;code&gt;models.py&lt;/code&gt;，开始创建表（该文件下可以建立一个表，也可以建立多个表）。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;　　 注意：&lt;code&gt;ORM&lt;/code&gt;创建表时如果不指定主键字段，将会默认创建一个名为&lt;code&gt;id&lt;/code&gt;的主键字段。并且我们在使用时可以使用&lt;code&gt;pk&lt;/code&gt;来代指主键&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;from django.db import models

class User(models.Model): # 必须继承
    # 自动创建 id 的主键
    username = models.CharField(max_length=16,verbose_name=&quot;用户名&quot;,db_index=True)
    age = models.IntegerField()
    gender = models.BooleanField(choices=([0,&quot;male&quot;],[1,&quot;famale&quot;]),default=0)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 接下来要运行创建模型映射表的命令，以及运行数据库同步命令。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;python manage.py makemigrations  # 创建模型映射表
python manage.py migrate # 同步模型表至数据库中
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 当创建模型映射表命令运行完成后，会发现&lt;code&gt;APP&lt;/code&gt;下的&lt;code&gt;migrations&lt;/code&gt;文件夹中多一一个文件，文件中就存放的刚刚建立好的模型表。&lt;/p&gt;
&lt;p&gt;　　 当数据库同步命令执行完成后，&lt;code&gt;MySQL&lt;/code&gt;中才会真正的创建出一张真实的物理表。&lt;/p&gt;
&lt;p&gt;　　 模型表信息：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# project01项目/app01/migrations

# -*- coding: utf-8 -*-
# Generated by Django 1.11.11 on 2020-09-12 18:18
from __future__ import unicode_literals

from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='User',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('username', models.CharField(db_index=True, max_length=16, verbose_name='用户名')),
                ('age', models.IntegerField()),
                ('gender', models.BooleanField(choices=[[0, 'male'], [1, 'famale']], default=0)),
            ],
        ),
    ]

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 物理表（注意：物理表的命名会以&lt;code&gt;APP&lt;/code&gt;名称开始）:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;desc app01_user;

+----------+-------------+------+-----+---------+----------------+
| Field    | Type        | Null | Key | Default | Extra          |
+----------+-------------+------+-----+---------+----------------+
| id       | int(11)     | NO   | PRI | NULL    | auto_increment |
| username | varchar(16) | NO   | MUL | NULL    |                |
| age      | int(11)     | NO   |     | NULL    |                |
| gender   | tinyint(1)  | NO   |     | NULL    |                |
+----------+-------------+------+-----+---------+----------------+
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;字段操作&lt;/h2&gt;
&lt;p&gt;　　 所有关于字段的增删改查都直接操纵对象属性即可，这里要提一下增加字段。&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;　　 如果需要新增一个字段，而数据表中又有一些数据，此时&lt;code&gt;Django&lt;/code&gt;会提醒你为原本的老数据设置一个默认值。&lt;/p&gt;
&lt;p&gt;　　 它会提供给你2个选项，选项1：立即为所有老数据设置默认值。选项2：放弃本次新增字段的操作，重新新增字段并设置默认值（也可以设置&lt;code&gt;null=True&lt;/code&gt;）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　 示例如下：我们现在表中创建一条信息。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from app01 import models

res = models.User.objects.create(
        username= &quot;云崖&quot;,
        age=18,
        gender=0,
)

print(res)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 然后修改其字段，新增一个注册时间。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from django.db import models

class User(models.Model): # 必须继承
    # 自动创建 id 的主键
    username = models.CharField(max_length=16,verbose_name=&quot;用户名&quot;,db_index=True)
    age = models.IntegerField()
    gender = models.BooleanField(choices=([0,&quot;male&quot;],[1,&quot;famale&quot;]),default=0)
    register_time = models.DateField(auto_now_add=True)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 在执行修改模型映射表的结构命令时，会让你做出选择。此时我们选择1，并且给定一个默认值就好。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;PS D:\project\project01&amp;gt; python manage.py makemigrations
You are trying to add the field 'register_time' with 'auto_now_add=True' to user without a default; the database needs something to populate existing rows.

 1) Provide a one-off default now (will be set on all existing rows)  # 1.新增一个默认值
 2) Quit, and let me add a default in models.py # 2.退出，自己手动添加default参数设置默认值
Select an option: 1
Please enter the default value now, as valid Python
You can accept the default 'timezone.now' by pressing 'Enter' or you can provide another value.
The datetime and django.utils.timezone modules are available, so you can do e.g. timezone.now
Type 'exit' to exit this prompt
[default: timezone.now] &amp;gt;&amp;gt;&amp;gt; &quot;2020-01-28&quot;  # 选择新增，给定一个时间
Migrations for 'app01':
  app01\migrations\0002_user_register_time.py
    - Add field register_time to user
PS D:\project\project01&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 记得最后运行数据库同步&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;python manage.py migrate
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;返回信息&lt;/h2&gt;
&lt;p&gt;　　 其实在创建数据表时，我们都会为其加上&lt;code&gt;__str__&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;　　 这是为了方便查询操作时看到那一条数据。&lt;/p&gt;
&lt;p&gt;　　 如下，如果不加的话返回结果是&lt;code&gt;QuerySet&lt;/code&gt;中套上列表+对象，十分不利于查看信息。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from app01 import models

res = models.User.objects.all()

print(res)  # &amp;lt;QuerySet [&amp;lt;User: User object&amp;gt;]&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 如果我们加上&lt;code&gt;__str__&lt;/code&gt;方法，那么就方便我们进行查看，到底查询的有那些记录。&lt;/p&gt;
&lt;p&gt;　　 (只要不对模型表本身结构做出修改，都不用重新执行模型表和物理表的两条命令)&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from django.db import models

class User(models.Model): # 必须继承
    # 自动创建 id 的主键
    username = models.CharField(max_length=16,verbose_name=&quot;用户名&quot;,db_index=True)
    age = models.IntegerField()
    gender = models.BooleanField(choices=([0,&quot;male&quot;],[1,&quot;famale&quot;]),default=0)
    register_time = models.DateField(auto_now_add=True)

    def __str__(self) -&amp;gt; str:
        return &quot;对象-%s&quot;%self.username 
        # 每一个记录对象都是User的实例化对象，所以我们返回一下self的username即可
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 现在再来进行查询&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from app01 import models

res = models.User.objects.all()

print(res)  # &amp;lt;QuerySet [&amp;lt;User: 对象-云崖&amp;gt;]&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2&gt;新增记录&lt;/h2&gt;
&lt;p&gt;　　 新增记录语法有两种，均可使用。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;models.表名.objects.create(col='xxx', col='xxx')  # 注意，返回值是创建好的对象记录本身

obj = models.表名(col='xxx', col='xxx')
obj.save()
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;　　 每次的创建，都会返回一个创建成功的新对象。一个实例对象中包含字段及字段数据，换而言之就是一条记录。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　 示例演示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from app01 import models

# 方式一：推荐使用
obj1 = models.User.objects.create(
    # 主键自动添加，AUTOFILED
    username=&quot;及时雨&quot;,
    age=21,
    gender=0,
    # register_time 创建时自动添加
)

# 方式二：
obj2 = models.User(
    # 主键自动添加，AUTOFILED
    username=&quot;玉麒麟&quot;,
    age=22,
    gender=0,
    # register_time 创建时自动添加
)

obj2.save()

print(obj1, obj2)  # 对象-及时雨 对象-玉麒麟
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;修改记录&lt;/h2&gt;
&lt;p&gt;　　 修改记录有两种方式，推荐使用第一种，因为第二种修改会将该条记录的所有字段都进行修改，无论数据是否有更新。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;models.表名.objects.filter(col='旧数据').update(col='新数据') 
# filter相当于where，不可以使用get，因为单一对象没有update方法，只有QuerySet对象才有。

obj = models.表名.objects.get(col='旧数据') # get() 只获取单个对象
obj.col = '新数据'
obj.save() 
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;　　 对于方式1而言，它可能修改多条记录。所以每次修改后，都会返回一个&lt;code&gt;int&lt;/code&gt;类型的数字，这代表受到影响的行数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　 示例演示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from app01 import models

# 方式一：推荐使用
num1 = models.User.objects.filter(pk=1).update(username=&quot;宋公明&quot;)

# 方式二：
obj = models.User.objects.get(pk=2)
obj.username=&quot;卢俊义&quot;
obj.save()

print(num1)  # 1
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;删除记录&lt;/h2&gt;
&lt;p&gt;　　 语法介绍：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;models.表名.objects.filter(col='xxx').delete()
# 删除指定条件的数据 filter相当于where，不可以使用get，因为单一对象没有delete方法，只有QuerySet对象才有。
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;　　 返回值是一个元组，包含删除成功的行数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　 示例如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from app01 import models

num_obj = models.User.objects.filter(pk=2).delete()

print(num_obj)  # (1, {'app01.User': 1})
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;批量增加&lt;/h2&gt;
&lt;p&gt;　　 如果要插入的数据量很大，则可以使用&lt;code&gt;bulk_create&lt;/code&gt;来进行批量插入。&lt;/p&gt;
&lt;p&gt;　　 它比单纯的&lt;code&gt;create&lt;/code&gt;效率更高。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;book_list = []
for i in range(100000):
        book_obj = models.Book(title=&quot;第%s本书&quot;%i)
        book_list.append(book_obj)
models.Book.objects.bulk_create(book_list)
&lt;/code&gt;
&lt;/pre&gt;

&lt;pre&gt;
&lt;code&gt;truncate app01_user;

INSERT INTO app01_user(username, age, gender,register_time) VALUES
    (&quot;云崖&quot;,18,0,now()),
    (&quot;及时雨&quot;,21,0,now()),
    (&quot;玉麒麟&quot;,22,0,now()),
    (&quot;智多星&quot;,21,0,now()),
    (&quot;入云龙&quot;,23,0,now()),
    (&quot;大刀&quot;,22,0,now());
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;QuerySET&lt;/h2&gt;
&lt;p&gt;　　 在查询时候，一定要区分开&lt;code&gt;QuerySet&lt;/code&gt;对象与单条记录对象的区别。&lt;/p&gt;
&lt;p&gt;　　 比如：我们的单条记录对象中保存有字段名等数据，均可进行&lt;code&gt;.&lt;/code&gt;出来。它的格式应该是这样的：&lt;code&gt;obj[col1,col2,col3]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;　　 而&lt;code&gt;QuerySet&lt;/code&gt;对象是一个对象集合体，中间包含很多单条记录对象，它的格式是：&lt;code&gt;QuerySet&amp;lt;[obj1,obj2,obj3]&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;　　 不同的对象有不同的方法，单条记录对象中能&lt;code&gt;.&lt;/code&gt;出字段，而&lt;code&gt;QuerySet&lt;/code&gt;对象中能点出&lt;code&gt;filter()/values()&lt;/code&gt;等方法。所以一定要区分开。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;　　 &lt;code&gt;QuerySet&lt;/code&gt;集合对象：暂时可以理解为一个列表，里面可以包含很多记录对象，但是不支持负向的索引取值，并且&lt;code&gt;Django&lt;/code&gt;不太希望你使用&lt;code&gt;index&lt;/code&gt;进行取值，而应该使用&lt;code&gt;first()&lt;/code&gt;以及&lt;code&gt;last()&lt;/code&gt;进行取出单条记录对象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;基本查询&lt;/h2&gt;
&lt;p&gt;　　 语法介绍：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;models.表名.objects.all() # 拿到当前模型类映射表中的所有记录，返回QuerySet集合对象
models.表名.objects.filter(col='xxx')     # 相当于whlie条件过滤，可拿到多条，返回QuerySet集合对象
models.表名.objects.get(col='xxx')        # 返回单个记录对象。注意区分与QuerySet的区别
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 示例演示：（仔细看结果，区分&lt;code&gt;QuerySet&lt;/code&gt;与单个对象的区别）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from app01 import models

all_queryset = models.User.objects.all()

filter_queryset = models.User.objects.filter(pk__gt=3)

obj = models.User.objects.get(pk=1)

print(all_queryset)
# &amp;lt;QuerySet [&amp;lt;User: 对象-云崖&amp;gt;, &amp;lt;User: 对象-及时雨&amp;gt;, &amp;lt;User: 对象-玉麒麟&amp;gt;, &amp;lt;User: 对象-智多星&amp;gt;, &amp;lt;User: 对象-入云龙&amp;gt;, &amp;lt;User: 对象-大刀&amp;gt;]&amp;gt;
print(filter_queryset)
# &amp;lt;QuerySet [&amp;lt;User: 对象-智多星&amp;gt;, &amp;lt;User: 对象-入云龙&amp;gt;, &amp;lt;User: 对象-大刀&amp;gt;]&amp;gt;
print(obj)
# 对象-云崖
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;filter过滤&lt;/h2&gt;
&lt;p&gt;　　 &lt;code&gt;filter()&lt;/code&gt;相当于&lt;code&gt;where&lt;/code&gt;条件，那么在其中可以进行过滤操作&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;　　 过滤使用&lt;code&gt;__&lt;/code&gt;双下划线进行操作。&lt;/p&gt;
&lt;p&gt;　　 注意：在&lt;code&gt;filter()&lt;/code&gt;中，所有的条件都是&lt;code&gt;AND&lt;/code&gt;关系&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;条件&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;25.5&quot;&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;filter(col1=xxx,col2=xxx)&lt;/td&gt;
&lt;td&gt;查询符合多个条件的记录&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;col__lt = xxx&lt;/td&gt;
&lt;td&gt;字段数据小于xxx的记录&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;col__lte = xxx&lt;/td&gt;
&lt;td&gt;字段数据小于等于xxx的记录&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;col_gt = xxx&lt;/td&gt;
&lt;td&gt;字段数据大于xxx的记录&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;col_gte = xxx&lt;/td&gt;
&lt;td&gt;字段数据大于xxx的记录&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;col_in = [x,y,z]&lt;/td&gt;
&lt;td&gt;字段数据在[x,y,z]中的记录&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;col_range = [1,5]&lt;/td&gt;
&lt;td&gt;字段数据在1-5范围内的记录&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;col_startswith = &quot;xxx&quot;&lt;/td&gt;
&lt;td&gt;字段数据以&quot;xxx&quot;开头的记录，区分大小写&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;col_istartswith = &quot;xxx&quot;&lt;/td&gt;
&lt;td&gt;字段数据以&quot;xxx&quot;开头的记录，不区分大小写&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;col_endswith = &quot;xxx&quot;&lt;/td&gt;
&lt;td&gt;字段数据以&quot;xxx&quot;结尾的记录，区分大小写&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;col_iendswith = &quot;xxx&quot;&lt;/td&gt;
&lt;td&gt;字段数据以&quot;xxx&quot;结尾的记录，不区分大小写&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;col__contains = ”xxx&quot;&lt;/td&gt;
&lt;td&gt;字段数据包含&quot;xxx&quot;的记录，区分大小写&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;col__icontains = ”xxx&quot;&lt;/td&gt;
&lt;td&gt;字段数据包含&quot;xxx&quot;的记录，不区分大小写&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;col__year = 2020&lt;/td&gt;
&lt;td&gt;日期字段在2020年中的记录&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;col__year__lt = 2020&lt;/td&gt;
&lt;td&gt;日期字段在2020年之后的记录&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;col__date__gte = datetime.date(2017, 1, 1)&lt;/td&gt;
&lt;td&gt;日期字段在2017年1月1日之后的记录&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;col__month = 3&lt;/td&gt;
&lt;td&gt;日期字段在3月的记录&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;col__day = 3&lt;/td&gt;
&lt;td&gt;日期字段在3天的记录&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;col__hour = 3&lt;/td&gt;
&lt;td&gt;日期字段在3小时的记录&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;col__minute = 3&lt;/td&gt;
&lt;td&gt;日期字段在3分钟的记录&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;col__second = 3&lt;/td&gt;
&lt;td&gt;日期字段在3秒钟的记录&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;pre&gt;
&lt;code&gt;User.objects.filter(pk__lt=2)  # 查找id小于2的对象

User.objects.filter(pk__lte=2) # 查找id小于等于2的对象

User.objects.filter(pk__gt=2)  # 查找id大于2的对象

User.objects.filter(pk__gte=2) # 查找id大于等于2的对象

User.objects.filter(pk__in=[1,2,5]) # 查找id为1,2,5的对象。

User.objects.filter(pk__range=[1,5])  # 查找id为1-5之间的对象。（左右都为闭区间）

User.objects.filter(name__contains=&quot;shawn&quot;)  # 查找name中包含shawn的对象。类似于正则/%shawn%/

User.objects.filter(name__icontains=&quot;shawn&quot;)  # 查找name中包含shawn的对象。(忽略大小写)

User.objects.filter(name__startswith=&quot;shawn&quot;)  # 查找name以shawn开头的对象 

User.objects.filter(name__istartswith=&quot;shawn&quot;)  # 查找name以shawn开头的对象(忽略大小写)

User.objects.filter(name__endswith=&quot;shawn&quot;)  # 查找name以shawn结尾的对象 

User.objects.filter(name__iendswith=&quot;shawn&quot;)  # 查找name以shawn结尾的对象 （忽略大小写）

User.objects.exclude(name__contains=&quot;shawn&quot;)  # 查找name不包含shawn的所有对象。
xx__date类型字段可以根据年月日进行过滤

User.objects.filter(birthday__year=2012)   # 查找出生在2012年的对象

User.objects.filter(birthday__year__gte=2012)  # 查找出生在2012年之后对象

User.objects.filter(birthday__date__gte=datetime.date(2017, 1, 1))  # 查找在2017,1,1之后出生的对象

User.objects.filter(birthday__month=3)  查找出生在3月份的对象

User.objects.filter(birthday__week_day=3) 

User.objects.filter(birthday__day=3)

User.objects.filter(birthday__hour=3)

User.objects.filter(birthday__minute=3)

User.objects.filter(birthday__second=3)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;常用操作&lt;/h2&gt;
&lt;p&gt;　　 下面将例举一些常用操作。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;单词&lt;/th&gt;
&lt;th&gt;查询操作&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;33.5&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;all()&lt;/td&gt;
&lt;td&gt;models.表名.objects.all()&lt;/td&gt;
&lt;td&gt;&amp;lt;QuerySet [obj obj obj]&amp;gt;，相当于查询该表所有记录。返回值相当于列表套对象&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;filter()&lt;/td&gt;
&lt;td&gt;models.表名.objects.filter(col=xxx)&lt;/td&gt;
&lt;td&gt;&amp;lt;QuerySet [obj obj objJ]&amp;gt;，过滤条件可通过逗号分割，等同于where查询。返回值相当于列表套对象&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;get()&lt;/td&gt;
&lt;td&gt;models.表名.objects.get(col=xxx)&lt;/td&gt;
&lt;td&gt;obj，单条记录，即一个类的实例化对象，直接返回对象&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;以下方法多为配合第一个或第二个方法使用&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8&quot;&gt;&lt;td&gt;values()&lt;/td&gt;
&lt;td&gt;models.表名.objects.values(&quot;col&quot;)&lt;/td&gt;
&lt;td&gt;&amp;lt;QerySet [{col,x1},{col,x2}]&amp;gt;，返回记录中所有字段的值。返回值相当于列表套字典&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;values_list()&lt;/td&gt;
&lt;td&gt;models.表名.objects.values_list(&quot;col&quot;)&lt;/td&gt;
&lt;td&gt;&amp;lt;QerySet [(x1),(x2)]&amp;gt;，返回记录中所有字段的值。返回值相当于列表套元组&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8&quot;&gt;&lt;td&gt;distinct()&lt;/td&gt;
&lt;td&gt;models.表名.objects.values(&quot;col&quot;).distinct()&lt;/td&gt;
&lt;td&gt;&amp;lt;QuerySet [{col,x1},{col,x2}]&amp;gt;，对指定字段去重。返回记录中所有字段的值。返回值相当于列表套字典&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;order_by()&lt;/td&gt;
&lt;td&gt;models.类名.objects.order_by(&quot;-col&quot;)&lt;/td&gt;
&lt;td&gt;&amp;lt;QuerySet [obj obj objJ]&amp;gt;，对指定字段排序，如直接写col是升序，-col则是降序。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;reverse()&lt;/td&gt;
&lt;td&gt;models.类名.objects.order_by(&quot;-col&quot;).reverse()&lt;/td&gt;
&lt;td&gt;&amp;lt;QuerySet [obj obj obj]&amp;gt;，前置条件必须有order_by(col），对其进行反转操作&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;exclude()&lt;/td&gt;
&lt;td&gt;models.表名.objects.exclude(col=&quot;xxx&quot;)&lt;/td&gt;
&lt;td&gt;&amp;lt;QuerySet [obj obj obj]&amp;gt;，除开col=xxx的记录，其他记录都拿&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;count()&lt;/td&gt;
&lt;td&gt;models.表名.objects.values(&quot;col&quot;).count()&lt;/td&gt;
&lt;td&gt;int，返回该字段记录的个数&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;exists()&lt;/td&gt;
&lt;td&gt;models.表名.objects.filter(col=“data”).exists()&lt;/td&gt;
&lt;td&gt;bool，返回该记录是否存在&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;first()&lt;/td&gt;
&lt;td&gt;models.表名.objects.first()&lt;/td&gt;
&lt;td&gt;obj，单条记录，取QuerySet中第一条记录&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;last()&lt;/td&gt;
&lt;td&gt;models.表名.objects.last()&lt;/td&gt;
&lt;td&gt;obj，单条记录，取QuerySet中最后一条记录&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;strong&gt;注意：获取all()后想配合其他的一些方法，可直接使用models.类型.object.其他方法()。这等同于all()&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;　　 示例演示如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;、
from app01 import models

values_queryset_dict = models.User.objects.values(&quot;username&quot;)
print(values_queryset_dict)
# &amp;lt;QuerySet [{'username': '云崖'}, {'username': '入云龙'}, {'username': '及时雨'}, {'username': '大刀'}, {'username': '智多星'}, {'username': '玉麒麟'}]&amp;gt;

values_list_queryset_tuple = models.User.objects.values_list(&quot;username&quot;)
print(values_list_queryset_tuple)
# &amp;lt;QuerySet [('云崖',), ('入云龙',), ('及时雨',), ('大刀',), ('智多星',), ('玉麒麟',)]&amp;gt;

distict_queryset = models.User.objects.values(&quot;age&quot;).distinct()
print(distict_queryset)
# &amp;lt;QuerySet [{'age': 18}, {'age': 21}, {'age': 22}, {'age': 23}]&amp;gt;

order_by_queryset = models.User.objects.order_by(&quot;-age&quot;)
print(order_by_queryset)
# &amp;lt;QuerySet [&amp;lt;User: 对象-入云龙&amp;gt;, &amp;lt;User: 对象-玉麒麟&amp;gt;, &amp;lt;User: 对象-大刀&amp;gt;, &amp;lt;User: 对象-及时雨&amp;gt;, &amp;lt;User: 对象-智多星&amp;gt;, &amp;lt;User: 对象-云崖&amp;gt;]&amp;gt;

reverse_queryset = models.User.objects.order_by(&quot;-age&quot;).reverse()
print(reverse_queryset)
# &amp;lt;QuerySet [&amp;lt;User: 对象-云崖&amp;gt;, &amp;lt;User: 对象-及时雨&amp;gt;, &amp;lt;User: 对象-智多星&amp;gt;, &amp;lt;User: 对象-玉麒麟&amp;gt;, &amp;lt;User: 对象-大刀&amp;gt;, &amp;lt;User: 对象-入云龙&amp;gt;]&amp;gt;

exclude_queryset = models.User.objects.exclude(pk__gt=3)
print(exclude_queryset)
# &amp;lt;QuerySet [&amp;lt;User: 对象-云崖&amp;gt;, &amp;lt;User: 对象-及时雨&amp;gt;, &amp;lt;User: 对象-玉麒麟&amp;gt;]&amp;gt;

num_pk = models.User.objects.values(&quot;pk&quot;).count()
print(num_pk)
# 6

bool_res = models.User.objects.filter(username=&quot;云崖&quot;).exists()
print(bool_res)
# True

first_obj = models.User.objects.first()
print(first_obj)
# 对象-云崖

last_obj = models.User.objects.last()
print(last_obj)
# 对象-大刀
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;　　 &lt;code&gt;Django&lt;/code&gt;中如果要实现多表查询，必须要建立外键，因为&lt;code&gt;Django&lt;/code&gt;的多表查询是建立在外键关系基础之上的。&lt;/p&gt;
&lt;p&gt;　　 但是如果使用原生的&lt;code&gt;SQL&lt;/code&gt;命令时我并不推荐使用外键做关联，因为这样会使得表与表之间的耦合度增加。&lt;/p&gt;
&lt;p&gt;　　 值得一提的是&lt;code&gt;Django&lt;/code&gt;中多对多关系创建则只需要两张表即可，因为它会自动创建第三张表（当然也可以手动创建，有两种手动创建的方式，下面也会进行介绍）。&lt;/p&gt;
&lt;h2&gt;一对一&lt;/h2&gt;
&lt;p&gt;　　 作者与作者详情是一对一&lt;/p&gt;
&lt;p&gt;　　 关键字：&lt;code&gt;OneToOneField&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;　　 注意事项如下：&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;　　 1.如不指定关联字段，自动关联主键&lt;code&gt;id&lt;/code&gt;字段&lt;/p&gt;
&lt;p&gt;　　 2.关联过后从表的关联字段会自动加上 &lt;code&gt;_id&lt;/code&gt;后缀&lt;/p&gt;
&lt;p&gt;　　 3.一对一关系建立在任何一方均可，但是建议建立在查询使用多的一方，如作者一方&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;class Author(models.Model):
    name = models.CharField(max_length=16, default=&quot;0&quot;)
    age = models.IntegerField()
    # 作者与作者详情一对一
    author_detail = models.OneToOneField(
        to=&quot;Authordetail&quot;, on_delete=models.CASCADE)

    def __str__(self) -&amp;gt; str:
        return &quot;对象-%s&quot; % self.name


class Authordetail(models.Model):
    phone = models.BigIntegerField()
    # 手机号，用BigIntegerField，

    def __str__(self) -&amp;gt; str:
        return &quot;对象-%s&quot; % self.phone
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 查看一对一关系（注意，外键上加了一个&lt;code&gt;UNIQUE&lt;/code&gt;约束）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;desc app01_author;

+------------------+-------------+------+-----+---------+----------------+
| Field            | Type        | Null | Key | Default | Extra          |
+------------------+-------------+------+-----+---------+----------------+
| id               | int(11)     | NO   | PRI | NULL    | auto_increment |
| age              | int(11)     | NO   |     | NULL    |                |
| author_detail_id | int(11)     | NO   | UNI | NULL    |                |
| name             | varchar(16) | NO   |     | NULL    |                |
+------------------+-------------+------+-----+---------+----------------+
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;一对多&lt;/h2&gt;
&lt;p&gt;　　 书籍与出版社是一对多&lt;/p&gt;
&lt;p&gt;　　 关键字：&lt;code&gt;ForeignKey&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;　　 注意事项如下：&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;　　 1.如不指定关联字段，自动关联主键&lt;code&gt;id&lt;/code&gt;字段&lt;/p&gt;
&lt;p&gt;　　 2.关联过后从表的关联字段会自动加上 &lt;code&gt;_id&lt;/code&gt;后缀&lt;/p&gt;
&lt;p&gt;　　 3.一对多关系的&lt;code&gt;fk&lt;/code&gt;应该建立在多的一方&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;class Publish(models.Model):
    name = models.CharField(max_length=16)
    addr = models.CharField(max_length=64)
    email = models.EmailField()

    def __str__(self) -&amp;gt; str:
        return &quot;对象-%s&quot; % self.name


class Book(models.Model):
    title = models.CharField(max_length=16)
    price = models.DecimalField(max_digits=5, decimal_places=2)
    publish_date = models.DateField(auto_now=False, auto_now_add=True)
    publish = models.ForeignKey(to=&quot;Publish&quot;, on_delete=models.CASCADE)
    
    def __str__(self) -&amp;gt; str:
        return &quot;对象-%s&quot; % self.title
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 查看一对多关系：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;decs app01_book;

+--------------+--------------+------+-----+---------+----------------+
| Field        | Type         | Null | Key | Default | Extra          |
+--------------+--------------+------+-----+---------+----------------+
| id           | int(11)      | NO   | PRI | NULL    | auto_increment |
| title        | varchar(16)  | NO   |     | NULL    |                |
| price        | decimal(5,2) | NO   |     | NULL    |                |
| publish_date | date         | NO   |     | NULL    |                |
| publish_id   | int(11)      | NO   | MUL | NULL    |                |
+--------------+--------------+------+-----+---------+----------------+
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;多对多&lt;/h2&gt;
&lt;p&gt;　　 书籍与作者是多对多&lt;/p&gt;
&lt;p&gt;　　 关键字：&lt;code&gt;ManyToManyFiled&lt;/code&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;　　 1.&lt;code&gt;Django&lt;/code&gt;使用&lt;code&gt;ManyToManyFiled&lt;/code&gt;会自动创建第三张表，而该字段就相当于指向第三张表，并且第三张表默认关联其他两张表的&lt;code&gt;pk&lt;/code&gt;字段&lt;/p&gt;
&lt;p&gt;　　 2.多对多关系建立在任何一方均可，但是建议建立在查询使用多的一方&lt;/p&gt;
&lt;p&gt;　　 3.多对多没有级联操作&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;class Book(models.Model):
    title = models.CharField(max_length=16)
    price = models.DecimalField(max_digits=5, decimal_places=2)
    publish_date = models.DateField(auto_now=False, auto_now_add=True)
    publish = models.ForeignKey(to=&quot;Publish&quot;, on_delete=models.CASCADE)
    # 书籍和出版社是一对多/多对一
    authors = models.ManyToManyField(&quot;Author&quot;)
    # 书籍与作者是多对多关系

    def __str__(self) -&amp;gt; str:
        return &quot;对象-%s&quot; % self.title
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 查看多对多关系，即第三张表：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;desc app01_book_authors;

+-----------+---------+------+-----+---------+----------------+
| Field     | Type    | Null | Key | Default | Extra          |
+-----------+---------+------+-----+---------+----------------+
| id        | int(11) | NO   | PRI | NULL    | auto_increment |
| book_id   | int(11) | NO   | MUL | NULL    |                |
| author_id | int(11) | NO   | MUL | NULL    |                |
+-----------+---------+------+-----+---------+----------------+
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;自关联&lt;/h2&gt;
&lt;p&gt;　　 自关联是一个很特殊的关系，如评论表。&lt;/p&gt;
&lt;p&gt;　　 一个文章下可以有很多评论，这些评论又分为根评论和子评论，那么这个时候就可以使用自关联建立关系。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#评论表
class Comment(models.Model):
    #评论的内容字段
    content=models.CharField(max_length=255)
    #评论的发布时间
    push_time=models.DateTimeField(auto_now_add=True)
    #关联父评论的id，可以为空，一定要设置null=True
    pcomment = models.ForeignKey(to='self',null=True) 
    def __str__(self):
        return self.content
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;级联操作&lt;/h2&gt;
&lt;p&gt;　　 一对一，一对多关系均可使用级联操作。&lt;/p&gt;
&lt;p&gt;　　 在&lt;code&gt;Django&lt;/code&gt;中，默认会开启级联更新，我们可自行指定级联删除&lt;code&gt;on_delete&lt;/code&gt;的操作方式。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;级联删除选项&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;7.5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;models.CASCADE&lt;/td&gt;
&lt;td&gt;删除主表数据时，从表关联数据也将进行删除&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;models.SET&lt;/td&gt;
&lt;td&gt;删除主表数据时，与之关联的值设置为指定值，设置：models.SET(值)，或者运行一个可执行对象（函数）。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;models.SET_NUL&lt;/td&gt;
&lt;td&gt;删除主表数据时，从表与之关联的值设置为null（前提FK字段需要设置为可空）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;models.SET_DEFAULT&lt;/td&gt;
&lt;td&gt;删除主表数据时，从表与之关联的值设置为默认值（前提FK字段需要设置默认值）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;models.DO_NOTHING&lt;/td&gt;
&lt;td&gt;删除主表数据时，如果从表中有与之关联的数据，引发错误IntegrityError&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;models.PROTECT&lt;/td&gt;
&lt;td&gt;删除主表数据时，如果从表中有与之关联的数据，引发错误ProtectedError&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;　　 操作演示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; publish = models.ForeignKey(to=&quot;Publish&quot;,on_delete=models.CASCADE)
    # 书籍和出版社是一对多/多对一
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;全部代码&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;from django.db import models

class Author(models.Model):
    name = models.CharField(max_length=16,default=&quot;0&quot;)
    age = models.IntegerField()
    # 作者与作者详情一对一
    author_detail = models.OneToOneField(to=&quot;Authordetail&quot;,on_delete=models.CASCADE)

    def __str__(self) -&amp;gt; str:
        return &quot;对象-%s&quot; % self.name


class Authordetail(models.Model):
    phone = models.BigIntegerField()
    # 手机号，用BigIntegerField，

    def __str__(self) -&amp;gt; str:
        return &quot;对象-%s&quot; % self.phone


class Publish(models.Model):
    name = models.CharField(max_length=16)
    addr = models.CharField(max_length=64)
    email = models.EmailField()

    def __str__(self) -&amp;gt; str:
        return &quot;对象-%s&quot; % self.name


class Book(models.Model):
    title = models.CharField(max_length=16)
    price = models.DecimalField(max_digits=5, decimal_places=2)
    publish_date = models.DateField(auto_now=False, auto_now_add=True)
    publish = models.ForeignKey(to=&quot;Publish&quot;,on_delete=models.CASCADE)
    # 书籍和出版社是一对多/多对一
    authors = models.ManyToManyField(&quot;Author&quot;)
    # 书籍与作者是多对多关系

    def __str__(self) -&amp;gt; str:
        return &quot;对象-%s&quot; % self.title
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2&gt;一对多&lt;/h2&gt;
&lt;h3&gt;新增记录&lt;/h3&gt;
&lt;p&gt;　　 对于增加操作而言有两种&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;　　 1.使用&lt;code&gt;fk_id&lt;/code&gt;进行增加，添加另一张表的&lt;code&gt;id&lt;/code&gt;号（因为外键会自动添加&lt;code&gt;_id&lt;/code&gt;前缀，所以我们可以直接使用）&lt;/p&gt;
&lt;p&gt;　　 2.使用&lt;code&gt;fk&lt;/code&gt;进行增加，添加另一张表的具体记录对象&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;第一种:
        models.表名.objects.create(
                col = xxx,
                col = xxx,
                外键_id = int,
        )
第二种:
        # 先获取对象
        obj = models.表名.objects.get(col=xxx)
        models.表名.objects.create(
                col = xxx,
                col = xxx,
                外键 = obj,
        )
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 示例操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from app01 import models

# 添加出版社
models.Publish.objects.create(
    # id自动为1
    name=&quot;北京出版社&quot;,
    addr=&quot;北京市海淀区&quot;,
    email=&quot;BeiJingPublish@gmail.com&quot;,
)

models.Publish.objects.create(
    # id自动为2
    name=&quot;上海出版社&quot;,
    addr=&quot;上海市蒲东区&quot;,
    email=&quot;ShangHaiPublish@gmail.com&quot;,
)

# 第一种：直接使用fk_id，添加id号
models.Book.objects.create(
    title=&quot;Django入门&quot;,
    price=99.50,
    # auto_now_add，不用填
    publish_id=1,  # 填入出版设id号
)

# 第二种，使用fk，添加对象
# 2.1 先获取出版社对象
pub_obj = models.Publish.objects.get(pk=1)
    # 2.2 添加对象
    models.Book.objects.create(
    title=&quot;CSS攻略&quot;,
    price=81.50,
    # auto_now_add，不用填
    publish=pub_obj, # 填入出版社对象
) 
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3&gt;修改记录&lt;/h3&gt;
&lt;p&gt;　　 修改记录和增加记录一样，都是有两种&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;　　 1.使用&lt;code&gt;fk_id&lt;/code&gt;进行修改，改为另一张表的&lt;code&gt;id&lt;/code&gt;号（因为外键会自动添加&lt;code&gt;_id&lt;/code&gt;前缀，所以我们可以直接使用）&lt;/p&gt;
&lt;p&gt;　　 2.使用&lt;code&gt;fk&lt;/code&gt;进行修改，改为另一张表的具体记录对象&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;第一种:
        models.表名.objects.filter(col=xxx).update(外键_id=int)
第二种:
        # 先获取对象
        obj = models.表名.objects.get(col=xxx)
        models.表名.objects.filter(col=xxx).update(外键=obj)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 示例操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from app01 import models

# 第一种，直接使用fk_id  # 将第一本书改为上海出版社 # 注意，这里只能使用filter，因为QuerySet对象才具有update方法
models.Book.objects.filter(pk=1).update(publish_id=2,)

# 第二种，获取出版设对象，使用fk进行修改 # 将第二本书改为北京出版社
# 2.1获取出版设对象
pub_obj = models.Publish.objects.get(pk=2)
# 2.2使用fk进行修改
models.Book.objects.filter(pk=2).update(publish=pub_obj)  #  注意，这里只能使用filter，因为QuerySet对象才具有update方法
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3&gt;删除记录&lt;/h3&gt;
&lt;p&gt;　　 如果删除一个出版社对象，与其关联的所有书籍都将会被级联删除。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;models.Publish.objects.filter(pk=1).delete()
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;多对多&lt;/h2&gt;
&lt;p&gt;　　 多对多的外键，相当于第三张表，必须要拿到第三张表才能进行操作。&lt;/p&gt;
&lt;p&gt;　　 这一点只要能理解，那么对多对多的操作就会十分便捷。&lt;/p&gt;
&lt;h3&gt;增加记录&lt;/h3&gt;
&lt;p&gt;　　 增加记录也是两种操作，拿到第三张表后可以增加对象，也可以增加&lt;code&gt;id&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;　　 注意：可以一次添加一个对象或&lt;code&gt;fk_id&lt;/code&gt;，也可以添加多个&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;第一种:
   obj = models.表名.objects.get(col=xxx)
   obj.外键.add(id_1, id_2) # 可以增加一个，也可以增加多个
第二种:
        # 先获取对象
        obj1 = models.表名.objects.get(col=xxx)
        obj2 = models.表名.objects.get(col=xxx)
        # 拿到第三张表
        obj = models.表名.objects.get(col=xxx)
        obj.外键.add(obj1, obj2) # 可以增加一个，也可以增加多个

# obj.外键 就是第三张表
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 示例操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from app01 import models

# 创建作者详细
a1 = models.Authordetail.objects.create(
        phone=12345678911
)

a2 = models.Authordetail.objects.create(
        phone=15196317676
)

# 创建作者
models.Author.objects.create(
    name=&quot;云崖&quot;,
    age=18,
    author_detail=a1,  # a1是创建的记录对象本身
)

models.Author.objects.create(
    name=&quot;杰克&quot;,
    age=18,
    author_detail=a2,  # a2是创建的记录对象本身
)

# 为书籍添加作者
# 方式1 先拿到具体对象，通过外键字段拿到第三张表，添加作者的id
# 拿到书籍，通过书籍外键字段拿到第三张表（必须是具体对象，不是QuerySet）
book_obj = models.Book.objects.get(pk=1)
book_obj.authors.add(1, 2)  # 为第一部书添加两个作者

# 方式2 先拿到作者的对象，再拿到第三张表，添加作者对象
author_1 = models.Author.objects.get(name=&quot;云崖&quot;)
author_2 = models.Author.objects.get(name=&quot;杰克&quot;)

# 拿到书籍，通过书籍外键字段拿到第三张表（必须是具体对象，不是QuerySet）
book_obj = models.Book.objects.get(pk=2)
book_obj.authors.add(author_1, author_2)  # 为第一部书添加两个作者

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3&gt;修改记录&lt;/h3&gt;
&lt;p&gt;　　 修改记录也是拿到第三张表进行修改，可以修改对象，也可以修改&lt;code&gt;id&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;　　 注意：可以一次设置一个对象或&lt;code&gt;id&lt;/code&gt;，也可以添加多个，但是要使用&lt;code&gt;[]&lt;/code&gt;进行包裹&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;第一种:
    obj = models.表名.objects.get(col=xxx)
    book_obj.authors.set([1]) # 注意[]包裹，可以设置一个，也可以设置多个
第二种:
        # 先获取对象
        obj1 = models.表名.objects.get(col=xxx)
        obj2 = models.表名.objects.get(col=xxx)
        # 拿到第三张表
        obj = models.表名.objects.get(col=xxx)
        obj.表名.set([obj1, obj2]) # 注意[]包裹，可以设置一个，也可以设置多个
        
# obj.外键 就是第三张表
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 示例操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from app01 import models

# 用id进行设置
book_obj = models.Book.objects.get(pk=1)
book_obj.authors.set([1])  # 拿到第三张表，放入作者的id进行设置。注意[]包裹，可以设置一个，也可以设置多个

# 用对象进行设置
author_obj = models.Author.objects.first()
# 先获取作者对象
book_obj = models.Book.objects.get(pk=2)
book_obj.authors.set([author_obj])  # 拿出第三张表，放入作者对象，注意[]包裹，可以设置一个，也可以设置多个
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3&gt;删除记录&lt;/h3&gt;
&lt;p&gt;　　 直接拿到第三张表进行删除即可。可以删除对象，也可以删除&lt;code&gt;id&lt;/code&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;　　 注意：可以一次性删除单个，也可以一次性删除多个&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;第一种：
        obj = models.表名.objects.get(col=xxx)
    obj.外键.remove(id_1,id_2) # 可以删除一个，也可以设置多个
第二种：
        # 先获取对象
        obj1 = models.表名.objects.get(col=xxx)
        obj2 = models.表名.objects.get(col=xxx)
        # 拿到第三张表
        obj = models.表名.objects.get(col=xxx)
        obj.外键.remove(obj1, obj2) # 可以删除一个，也可以设置多个
        
# obj.外键 就是第三张表
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 示例操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from app01 import models

# 用id进行删除
book_obj = models.Book.objects.get(pk=1)
book_obj.authors.remove(1) # 拿到第三张表，放入作者的id进行删除。可以删除一个，也可以删除多个

# 用对象进行删除
author_obj = models.Author.objects.last()
# 先获取作者对象
book_obj = models.Book.objects.get(pk=2)
book_obj.authors.remove(author_obj) # 拿出第三张表，放入作者对象，可以删除一个，也可以删除多个
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3&gt;清空记录&lt;/h3&gt;
&lt;p&gt;　　 拿到第三张表，执行&lt;code&gt;clear()&lt;/code&gt;则是清空操作。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;book_obj = models.Book.objects.get(pk=1) # 拿到具体对象
book_obj.authors.clear() # 删除其所有作者
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2&gt;数据准备&lt;/h2&gt;
&lt;p&gt;　　 还是用多表操作中的结构，数据有一些不同。&lt;/p&gt;
&lt;p&gt;　　 书籍与出版社是一对多&lt;/p&gt;
&lt;p&gt;　　 书籍与作者是多对多&lt;/p&gt;
&lt;p&gt;　　 作者与作者详情是一对一&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select * from app01_publish;  -- 出版社

+----+-----------------+-----------------------------+--------------------+
| id | name            | addr                        | email              |
+----+-----------------+-----------------------------+--------------------+
|  1 | 北京出版社      | 北京市海淀区                | BeiJing@gmail.com  |
|  2 | 上海出版社      | 上海浦东区                  | ShangHai@gmail.com |
|  3 | 西藏出版社      | 乌鲁木齐其其格乐区          | XiZang@gmail.com   |
+----+-----------------+-----------------------------+--------------------+

select * from app01_author;  -- 作者

+----+--------------+-----+------------------+
| id | name         | age | author_detail_id |
+----+--------------+-----+------------------+
|  1 | 云崖         |  18 |                1 |
|  2 | 浪里白条     |  17 |                2 |
|  3 | 及时雨       |  21 |                3 |
|  4 | 玉麒麟       |  22 |                4 |
|  5 | 入云龙       |  21 |                5 |
+----+--------------+-----+------------------+

select * from app01_book;  -- 书籍

+----+-------------------+--------+--------------+------------+
| id | title             | price  | publish_date | publish_id |
+----+-------------------+--------+--------------+------------+
|  1 | Django精讲        |  99.23 | 2020-09-11   |          1 |
|  2 | HTML入门          |  78.34 | 2020-09-07   |          2 |
|  3 | CSS入门           | 128.00 | 2020-07-15   |          3 |
|  4 | Js精讲            | 152.00 | 2020-06-09   |          1 |
|  5 | Python入门        |  18.00 | 2020-08-12   |          1 |
|  6 | PHP全套           |  73.53 | 2020-09-15   |          2 |
|  7 | GO入门到精通      | 166.00 | 2020-07-14   |          3 |
|  8 | JAVA入门          | 123.00 | 2020-04-22   |          2 |
|  9 | C语言入门         |  19.00 | 2020-02-03   |          3 |
| 10 | FLASK源码分析     | 225.00 | 2019-11-06   |          1 |
+----+-------------------+--------+--------------+------------+


select * from app01_book_authors;  -- 作者书籍关系

+----+---------+-----------+
| id | book_id | author_id |
+----+---------+-----------+
|  1 |       1 |         1 |
|  2 |       2 |         1 |
|  3 |       2 |         2 |
|  4 |       2 |         3 |
|  5 |       2 |         5 |
|  6 |       3 |         4 |
|  7 |       3 |         5 |
|  8 |       4 |         2 |
|  9 |       5 |         2 |
| 10 |       6 |         2 |
| 11 |       7 |         1 |
| 12 |       7 |         2 |
| 13 |       7 |         3 |
| 14 |       8 |         4 |
| 15 |       9 |         1 |
| 16 |       9 |         5 |
| 17 |      10 |         5 |
+----+---------+-----------+

select * from app01_authordetail;  -- 作者详情

+----+-------------+
| id | phone       |
+----+-------------+
|  1 | 15163726474 |
|  2 | 17738234753 |
|  3 | 15327787382 |
|  4 | 13981080124 |
|  5 | 13273837482 |
+----+-------------+
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;正反向&lt;/h2&gt;
&lt;p&gt;　　 正反向的概念就是看外键建立在那张表之上。&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;　　 book(fk) ---&amp;gt; publish : 正向 publish ---&amp;gt; book(fk) : 反向&lt;/p&gt;
&lt;p&gt;　　 &lt;strong&gt;切记一句话：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　 &lt;strong&gt;正向查询用外键&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　 &lt;strong&gt;反向查询用 &lt;code&gt;表名_set&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;对象跨表&lt;/h2&gt;
&lt;p&gt;　　 使用对象跨表语法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;正向：
        book_obj = models.书籍.objects.get(col=xxx)
        publish_obj = book_obj.fk_出版社            # 这里publish_obj就是与book_obj相关的出版社了
        publish_obj.all()/.filter(col=xxx)/.get(col_xxx)  
反向：
        publish_obj = models.出版社.objects.get(col=xxx)
        book_obj = publish_obj.book_set            # 这里book_obj就是与publish_obj相关的书籍了
        book_obj.all()/.filter(col=xxx)/.get(col_xxx)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 查找&lt;code&gt;id&lt;/code&gt;为1的出版社出版的所有书籍，反向&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from app01 import models

publish = models.Publish.objects.get(pk=1)
book_queryset = publish.book_set
res = book_queryset.all()
print(res)

# &amp;lt;QuerySet [&amp;lt;Book: 对象-Django精讲&amp;gt;, &amp;lt;Book: 对象-Js精讲&amp;gt;, &amp;lt;Book: 对象-Python入门&amp;gt;, &amp;lt;Book: 对象-FLASK源码分析&amp;gt;]&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 查找&lt;code&gt;id&lt;/code&gt;为2的书籍作者，正向&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from app01 import models

book = models.Book.objects.get(pk=2)
authors_queryset = book.authors
res = authors_queryset.all()
print(res)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;双下跨表&lt;/h2&gt;
&lt;p&gt;　　 双下划线也可以进行正向或者反向的跨表，并且支持跨多张表。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;　　 注意：双下划线能在&lt;code&gt;filter()&lt;/code&gt;中使用，也能在&lt;code&gt;values()&lt;/code&gt;中使用。拿对象用&lt;code&gt;filter()&lt;/code&gt;，拿单一字段用&lt;code&gt;values()&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　 查找&lt;code&gt;id&lt;/code&gt;为1的出版社出版的所有书籍，反向，拿对象&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from app01 import models

res_queryset = models.Book.objects.filter(publish__id=1)
print(res_queryset)

# &amp;lt;QuerySet [&amp;lt;Book: 对象-Django精讲&amp;gt;, &amp;lt;Book: 对象-Js精讲&amp;gt;, &amp;lt;Book: 对象-Python入门&amp;gt;, &amp;lt;Book: 对象-FLASK源码分析&amp;gt;]&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 查找&lt;code&gt;id&lt;/code&gt;为2的书籍作者姓名，正向，拿字段&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from app01 import models

res_queryset = models.Book.objects.filter(id=2).values(&quot;authors__name&quot;)
print(res_queryset)

# &amp;lt;QuerySet [{'authors__name': '云崖'}, {'authors__name': '浪里白条'}, {'authors__name': '及时雨'}, {'authors__name': '入云龙'}]&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 查找入云龙出的所有书籍，正向，拿对象&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from app01 import models

res_queryset = models.Book.objects.filter(authors__name=&quot;入云龙&quot;)
print(res_queryset)

# &amp;lt;QuerySet [&amp;lt;Book: 对象-HTML入门&amp;gt;, &amp;lt;Book: 对象-CSS入门&amp;gt;, &amp;lt;Book: 对象-C语言入门&amp;gt;, &amp;lt;Book: 对象-FLASK源码分析&amp;gt;]&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 查找入云龙出的所有书籍，拿对象，反向查（这个需要配合对象跨表才行）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from app01 import models

res_queryset = models.Author.objects.filter(name=&quot;入云龙&quot;).first().book_set.all()
print(res_queryset)

# &amp;lt;QuerySet [&amp;lt;Book: 对象-HTML入门&amp;gt;, &amp;lt;Book: 对象-CSS入门&amp;gt;, &amp;lt;Book: 对象-C语言入门&amp;gt;, &amp;lt;Book: 对象-FLASK源码分析&amp;gt;]&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 跨多表，从&lt;code&gt;pk&lt;/code&gt;为1的出版社中查到其所有作者的手机号，拿字段。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from app01 import models

res_queryset = models.Publish.objects.filter(pk=1).values(&quot;book__authors__author_detail__phone&quot;)
print(res_queryset)

# &amp;lt;QuerySet [{'book__authors__author_detail__phone': 15163726474}, {'book__authors__author_detail__phone': 17738234753}, {'book__authors__author_detail__phone': 17738234753}, {'book__authors__author_detail__phone': 13273837482}]&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2&gt;聚合函数&lt;/h2&gt;
&lt;p&gt;　　 使用聚合函数前应进行导入，在&lt;code&gt;ORM&lt;/code&gt;中，单独使用聚合查询的关键字是&lt;code&gt;aggregate()&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from django.db.models import Min,Max,Avg,Count,Sum
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 聚合函数应该配合分组一起使用，而不是单独使用。&lt;/p&gt;
&lt;p&gt;　　 单独使用一般都是对单表进行操作。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;　　 注意：单独使用聚合函数后，返回的并非一个&lt;code&gt;QuerySet&lt;/code&gt;对象，这代表&lt;code&gt;filter()/values()&lt;/code&gt;等方法将无法继续使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　 查询书籍的平均价格：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from app01 import models

from django.db.models import Max,Min,Avg,Count,Sum
res = models.Book.objects.aggregate(Avg(&quot;price&quot;)) # 如不进行分组，则整张表为一组
print(res) # {'price__avg': 108.21}  # 单独使用聚合，返回的是字典
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 查询最贵的书籍，以及最便宜的书籍。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from app01 import models

from django.db.models import Max, Min, Avg, Count, Sum
res = models.Book.objects.aggregate(Max(&quot;price&quot;),Min(&quot;price&quot;))
print(res)  # {'price__max': Decimal('225.00'), 'price__min': Decimal('18.00')}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;分组查询&lt;/h2&gt;
&lt;p&gt;　　 在&lt;code&gt;ORM&lt;/code&gt;中，分组查询使用关键字&lt;code&gt;annotate()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;　　 切记以下几点：&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;　　 1.只要对表使用了&lt;code&gt;annotate()&lt;/code&gt;，则按照&lt;code&gt;pk&lt;/code&gt;进行分组&lt;/p&gt;
&lt;p&gt;　　 2.如果分组前指定&lt;code&gt;values()&lt;/code&gt;，则按照该字段进行分组，如&lt;code&gt;values(&quot;name&quot;).annotate()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;　　 3.分组函数中可以使用聚合函数，并且不同于使用&lt;code&gt;aggregate()&lt;/code&gt;后的返回对象是一个字典，使用分组函数进行聚合查询后，返回依旧是一个&lt;code&gt;QuerySet&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　 统计每本书的作者个数&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from app01 import models

from django.db.models import Max, Min, Avg, Count, Sum

# authors_num 别名
res = models.Book.objects.annotate(authors_num=Count(&quot;authors__pk&quot;),).values('title','authors_num')
print(res)  
# &amp;lt;QuerySet [{'title': 'Django精讲', 'authors_num': 1}, {'title': 'HTML入门', 'authors_num': 4}, {'title': 'CSS入门', 'authors_num': 2}, {'title': 'Js精讲', 'authors_num': 1}, {'title': 'Python入门', 'authors_num': 1}, {'title': 'PHP全套', 'authors_num': 1}, {'title': 'GO入门到精通', 'authors_num': 3}, {'title': 'JAVA入门', 'authors_num': 1}, {'title': 'C语言入门', 'authors_num': 2}, {'title': 'FLASK源码分析', 'authors_num': 1}]&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 统计每个出版社中卖的最便宜的书籍&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from app01 import models

from django.db.models import Max, Min, Avg, Count, Sum

# book_name 别名
res = models.Publish.objects.annotate(book_name=Min(&quot;book__price&quot;),).values('name','book_name')
print(res)  

# &amp;lt;QuerySet [{'name': '北京出版社', 'book_name': Decimal('18.00')}, {'name': '上海出版社', 'book_name': Decimal('73.53')}, {'name': '西藏出版社', 'book_name': Decimal('19.00')}]&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 统计不止一个作者的图书&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from app01 import models

from django.db.models import Max, Min, Avg, Count, Sum

# authors_num 别名   只要返回的QuerySet对象，就可以使用filter
res = models.Book.objects.annotate(authors_num=Count(&quot;authors__pk&quot;),).values('title','authors_num').filter(authors_num__gt=1)
print(res)  

# &amp;lt;QuerySet [{'title': 'HTML入门', 'authors_num': 4}, {'title': 'CSS入门', 'authors_num': 2}, {'title': 'GO入门到精通', 'authors_num': 3}, {'title': 'C语言入门', 'authors_num': 2}]&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 查询每个作者出书的总价&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from app01 import models

from django.db.models import Max, Min, Avg, Count, Sum

# sum_price 别名
res = models.Author.objects.annotate(sum_price=Sum(&quot;book__price&quot;),).values('name','sum_price')
print(res)

# &amp;lt;QuerySet [{'name': '云崖', 'sum_price': Decimal('362.57')}, {'name': '浪里白条', 'sum_price': Decimal('487.87')}, {'name': '及时雨', 'sum_price': Decimal('244.34')}, {'name': '玉麒麟', 'sum_price': Decimal('251.00')}, {'name': '入云龙', 'sum_price': Decimal('450.34')}]&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2&gt;F查询&lt;/h2&gt;
&lt;p&gt;　　 &lt;code&gt;F&lt;/code&gt;查询能够拿到字段的数据。使用前应该先进行导入&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;form django.db.moduls import F
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;　　 注意：如果要操纵的字段是字符类型，要对其进行拼接操作还需导入&lt;code&gt;Concat&lt;/code&gt;进行拼接&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　 将所有书籍的价格提升50元&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from app01 import models

from django.db.models import Max, Min, Avg, Count, Sum
from django.db.models import F, Q

res = models.Book.objects.update(price=F(&quot;price&quot;)+50)
print(res)  # 10
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 在每本书名字后面加上爆款二字（注意：操纵字符类型，需要用到&lt;code&gt;Concat&lt;/code&gt;与&lt;code&gt;Value&lt;/code&gt;函数）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from app01 import models

from django.db.models import Max, Min, Avg, Count, Sum
from django.db.models import F, Q
# 必须配合下面的两个进行使用
from django.db.models.functions import Concat
from django.db.models import Value

res = models.Book.objects.update(title=Concat(F(&quot;title&quot;), Value(&quot;爆款&quot;)))
print(res)  # 10
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;Q查询&lt;/h2&gt;
&lt;p&gt;　　 在&lt;code&gt;filter()&lt;/code&gt;中，只要多字段筛选中用逗号进行分割都是&lt;code&gt;AND&lt;/code&gt;链接，如何进行&lt;code&gt;OR&lt;/code&gt;与&lt;code&gt;NOT&lt;/code&gt;呢？此时就要用到&lt;code&gt;Q&lt;/code&gt;，还是要先进行导入该功能。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;form django.db.moduls import Q
&lt;/code&gt;
&lt;/pre&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;符号&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;6.5&quot;&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;filter(Q(col=xxx),Q(col=xxx))&lt;/td&gt;
&lt;td&gt;AND关系，只要在filter()中用逗号分割，就是&lt;code&gt;AND&lt;/code&gt;关系&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;filter(Q(col=xxx)!Q(col=xxx))&lt;/td&gt;
&lt;td&gt;OR关系，用|号进行链接&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;filter(~Q(col=xxx)!Q(col=xxx))&lt;/td&gt;
&lt;td&gt;NO关系，用~号进行连接&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;　　 查询书籍表中入云龙或云崖出版的书籍&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from app01 import models

from django.db.models import Max, Min, Avg, Count, Sum
from django.db.models import F, Q

res = models.Book.objects.filter(Q(authors__name='云崖')|Q(authors__name=&quot;入云龙&quot;))
print(res)
# &amp;lt;QuerySet [&amp;lt;Book: 对象-Django精讲爆款&amp;gt;, &amp;lt;Book: 对象-HTML入门爆款&amp;gt;, &amp;lt;Book: 对象-GO入门到精通爆款&amp;gt;, &amp;lt;Book: 对象-C语言入门爆款&amp;gt;, &amp;lt;Book: 对象-HTML入门爆款&amp;gt;, &amp;lt;Book: 对象-CSS入门爆款&amp;gt;, &amp;lt;Book: 对象-C语言入门爆款&amp;gt;, &amp;lt;Book: 对象-FLASK源码分析爆款&amp;gt;]&amp;gt;

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 查询书籍表中不是云崖和入云龙出版的书籍&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from app01 import models

from django.db.models import Max, Min, Avg, Count, Sum
from django.db.models import F, Q


res = models.Book.objects.filter(~Q(authors__name='云崖'),Q(authors__name=&quot;入云龙&quot;))
print(res)
# &amp;lt;QuerySet [&amp;lt;Book: 对象-CSS入门爆款&amp;gt;, &amp;lt;Book: 对象-FLASK源码分析爆款&amp;gt;]&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;Q进阶&lt;/h2&gt;
&lt;p&gt;　　 如果我们的&lt;code&gt;Q&lt;/code&gt;查询中，能去让用户来输入字符串指定字段进行查询，那么就非常厉害了。&lt;/p&gt;
&lt;p&gt;　　 其实这也是能够实现。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from app01 import models

from django.db.models import Max, Min, Avg, Count, Sum
from django.db.models import F, Q

q = Q() # 实例化出一个对象
q.connector = &quot;and&quot;  # 指定q的关系

# 两个Q
q.children.append((&quot;price__lt&quot;,&quot;120&quot;)) 
q.children.append((&quot;price__gt&quot;,&quot;50&quot;))

res = models.Book.objects.filter(q)
# 相当于： models.Book.objects.filter(Q(price__lt=120),Q(price__gt=50))

print(res)
# &amp;lt;QuerySet [&amp;lt;Book: 对象-Python入门爆款&amp;gt;, &amp;lt;Book: 对象-C语言入门爆款&amp;gt;]&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;　　 使用单表或多表时，可以使用以下方法进行查询优化。&lt;/p&gt;
&lt;h2&gt;only&lt;/h2&gt;
&lt;p&gt;　　 &lt;code&gt;only&lt;/code&gt;取出的记录对象中只有指定的字段，没有其他字段。&lt;/p&gt;
&lt;p&gt;　　 因此查询速度会非常快。&lt;/p&gt;
&lt;p&gt;　　 默认会拿出所有字段。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from app01 import models

obj = models.Book.objects.all().first()

print(obj.title)
print(obj.price)

SELECT `app01_book`.`id`, `app01_book`.`title`, `app01_book`.`price`, `app01_book`.`publish_date`, `app01_book`.`publish_id` FROM `app01_book` ORDER BY `app01_book`.`id` ASC LIMIT 1;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 使用&lt;code&gt;only&lt;/code&gt;只会拿出指定字段，但是如果要拿指定字段以外的字段。则会再次进行查询&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from app01 import models

obj = models.Book.objects.only(&quot;title&quot;).first()

print(obj.title)
print(obj.price)

SELECT `app01_book`.`id`, `app01_book`.`title` FROM `app01_book` ORDER BY `app01_book`.`id` ASC LIMIT 1; 
SELECT `app01_book`.`id`, `app01_book`.`price` FROM `app01_book` WHERE `app01_book`.`id` = 1; 
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;defer&lt;/h2&gt;
&lt;p&gt;　　 &lt;code&gt;defer&lt;/code&gt;与&lt;code&gt;only&lt;/code&gt;正好相反，拿除了指定字段以外的其他字段。&lt;/p&gt;
&lt;p&gt;　　 但是如果要拿指定字段的字段。则会再次进行查询&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from app01 import models

obj = models.Book.objects.defer(&quot;title&quot;).first()


print(obj.title)
print(obj.price)

SELECT `app01_book`.`id`, `app01_book`.`price`, `app01_book`.`publish_date`, `app01_book`.`publish_id` FROM app01_book` ORDER BY `app01_book`.`id` ASC LIMIT 1;
SELECT `app01_book`.`id`, `app01_book`.`title` FROM `app01_book` WHERE `app01_book`.`id` = 1;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;select_related&lt;/h2&gt;
&lt;p&gt;　　 原本的跨表，尤其是使用对象跨表，都会查询两次。&lt;/p&gt;
&lt;p&gt;　　 但是&lt;code&gt;select_related&lt;/code&gt;指定连表，则只会查询一次。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;　　 注意！&lt;code&gt;select_related&lt;/code&gt;中指定的连表，只能是外键名。并且不能是多对多关系&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　 原本跨表，两次查询语句。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from app01 import models

obj = models.Book.objects.all().first()
obj_fk = obj.publish
print(obj)
print(obj_fk)

SELECT `app01_book`.`id`, `app01_book`.`title`, `app01_book`.`price`, `app01_book`.`publish_date`, `app01_book`.`publish_id` FROM `app01_book` ORDER BY `app01_book`.`id` ASC LIMIT 1;

SELECT `app01_publish`.`id`, `app01_publish`.`name`, `app01_publish`.`addr`, `app01_publish`.`email` FROM `app01_publish` WHERE `app01_publish`.`id` = 1;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 如果是使用&lt;code&gt;select_related&lt;/code&gt;，则只需要查询一次。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from app01 import models

obj = models.Book.objects.select_related(&quot;publish&quot;).first()
obj_fk = obj.publish
print(obj)
print(obj_fk)


SELECT `app01_book`.`id`, `app01_book`.`title`, `app01_book`.`price`, `app01_book`.`publish_date`, `app01_book`.`publish_id`, `app01_publish`.`id`, `app01_publish`.`name`, `app01_publish`.`addr`, `app01_publish`.`email` FROM `app01_book` INNER JOIN `app01_publish` ON (`app01_book`.`publish_id` = `app01_publish`.`id`) ORDER BY `app01_book`.`id` ASC LIMIT 1;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;prefetch_related&lt;/h2&gt;
&lt;p&gt;　　 &lt;code&gt;prefetch_related&lt;/code&gt;是子查询。它会默认走两次&lt;code&gt;SQL&lt;/code&gt;语句，相比于&lt;code&gt;select_related&lt;/code&gt;，它的查询次数虽然多了一次，但是量级少了很多，不用拼两张表全部内容。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;　　 注意！&lt;code&gt;prefetch_related&lt;/code&gt;中指定的连表，只能是外键名。并且不能是多对多关系&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;from app01 import models

obj = models.Book.objects.prefetch_related(&quot;publish&quot;).first()
obj_fk = obj.publish
print(obj)
print(obj_fk)

SELECT `app01_book`.`id`, `app01_book`.`title`, `app01_book`.`price`, `app01_book`.`publish_date`, `app01_book`.`publish_id` FROM `app01_book` ORDER BY `app01_book`.`id` ASC LIMIT 1;

SELECT `app01_publish`.`id`, `app01_publish`.`name`, `app01_publish`.`addr`, `app01_publish`.`email` FROM `app01_publish` WHERE `app01_publish`.`id` IN (1);  # 注意in，只查这一条
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;　　 如果要使用两张表中许多数据，则使用&lt;code&gt;select_related&lt;/code&gt;拼出整表。&lt;/p&gt;
&lt;p&gt;　　 如果连表需要的数据不多，可使用&lt;code&gt;prefetch_related&lt;/code&gt;子查询。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　 如果你觉得&lt;code&gt;ORM&lt;/code&gt;有一些查询搞不定，就可以使用原生&lt;code&gt;SQL&lt;/code&gt;语句。&lt;/p&gt;
&lt;p&gt;　　 官方文档：&lt;a class=&quot;url&quot; href=&quot;https://docs.djangoproject.com/zh-hans/3.1/topics/db/sql/&quot; target=&quot;_blank&quot;&gt;https://docs.djangoproject.com/zh-hans/3.1/topics/db/sql/&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;connection&lt;/h2&gt;
&lt;p&gt;　　 这和&lt;code&gt;pymysql&lt;/code&gt;的使用基本一致，但是并不提供返回&lt;code&gt;dict&lt;/code&gt;类型的数据。所以我们需要自定义一个函数来进行封装。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from app01 import models
from django.db import connection, connections

def dictfetchall(cursor):
    &quot;Return all rows from a cursor as a dict&quot;
    columns = [col[0] for col in cursor.description]
    return [
    dict(zip(columns, row))
    for row in cursor.fetchall()
]

print(help(connection.cursor))

# 1.1 获取游标对象
cursor = connection.cursor()  # 默认连接default数据库。
cursor.execute(
    &quot;&quot;&quot;
    SELECT * FROM app01_book INNER JOIN app01_publish
    on app01_book.publish_id = app01_publish.id
    where app01_book.id = 1;
    &quot;&quot;&quot;
,()) #第二参数，字符串拼接。与pymysql使用相同，防止sql注入。

# 1.2 返回封装结果
row = dictfetchall(cursor)
print(row)

# [{'id': 1, 'title': 'Django精讲', 'price': Decimal('99.23'), 'publish_date': datetime.date(2020, 9, 11), 'publish_id': 1, 'name': '北京出版社', 'addr': '北京市海淀区', 'email': 'BeiJing@gmail.com'}]
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;raw&lt;/h2&gt;
&lt;p&gt;　　 &lt;code&gt;raw&lt;/code&gt;是借用一个模型类，返回结果将返回至模型类中。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;　　 返回结果是一个&lt;code&gt;RawQuerySet&lt;/code&gt;对象，这种用法必须将主键取出&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;from app01 import models

res_obj = models.Book.objects.raw(&quot;select id,name from app01_author&quot;,params=[]) # 必须取出其他表的主键
# params = 格式化。防止sql注入

for i in res_obj:
        print(i.name)  # 虽然返回的Book实例化，但是其中包含了作者的字段。可以通过属性点出来

# 云崖
# 浪里白条
# 及时雨
# 玉麒麟
# 入云龙
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 你可以用 &lt;code&gt;raw()&lt;/code&gt; 的 &lt;code&gt;translations&lt;/code&gt; 参数将查询语句中的字段映射至模型中的字段。这是一个字典，将查询语句中的字段名映射至模型中的字段名。说白了就是&lt;code&gt;as&lt;/code&gt;一个别名。&lt;/p&gt;
&lt;p&gt;　　 例如，上面的查询也能这样写:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from app01 import models
name_map = {'pk': 'aid', 'name': 'a_name',}  # 不要使用id，使用pk。它知道是id  

res_obj = models.Book.objects.raw(&quot;select * from app01_author&quot;, params=[],translations=name_map)
# params = 格式化。防止sql注入

for i in res_obj:
        print(i.a_name) 

# 云崖
# 浪里白条
# 及时雨
# 玉麒麟
# 入云龙
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;extra&lt;/h2&gt;
&lt;p&gt;　　 原生与&lt;code&gt;ORM&lt;/code&gt;结合，这个可用于写子查询。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;　　 我没怎么用过这个，很少使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;def extra(self, select=None, where=None, params=None, tables=None, order_by=None, select_params=None)
    # 构造额外的查询条件或者映射，如：子查询

    Entry.objects.extra(select={'new_id': &quot;select col from sometable where othercol &amp;gt; %s&quot;}, select_params=(1,))
    Entry.objects.extra(where=['headline=%s'], params=['Lennon'])
    Entry.objects.extra(where=[&quot;foo='a' OR bar = 'a'&quot;, &quot;baz = 'a'&quot;])
    Entry.objects.extra(select={'new_id': &quot;select id from tb where id &amp;gt; %s&quot;}, select_params=(1,), order_by=['-nid'])
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;　　 &lt;code&gt;Django&lt;/code&gt;中开启事务非常简单，因为又&lt;code&gt;with()&lt;/code&gt;上下文管理器的情况，所以我们只需要在没出错的时候提交，出错后回滚即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from django.db import transaction

 
def func_views(request):
    try:
        with transaction.atomic():      
                        # 操作1
                        # 操作2
                        # 如果没发生异常自动提交事务
            # raise DatabaseError 数据库异常，说明sql语句有问题    
    except DatabaseError:     # 自动回滚，不需要任何操作
            pass
            
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2&gt;惰性求值&lt;/h2&gt;
&lt;p&gt;　　 &lt;code&gt;QuerySet&lt;/code&gt;的一大特性就是惰性求值，即你不使用数据时是不会进行数据库查询。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from app01 import models
res_queryset = models.Book.objects.all()
# 无打印SQL
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;缓存机制&lt;/h2&gt;
&lt;p&gt;　　 &lt;code&gt;QuerySet&lt;/code&gt;具有缓存机制，下次再使用同一变量时，不会走数据库查询而是使用缓存。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from app01 import models
res_queryset = models.Book.objects.filter(pk=1)

for i in res_queryset:
        print(i)

for i in res_queryset:
        print(i)

# (0.001) SELECT `app01_book`.`id`, `app01_book`.`title`, `app01_book`.`price`, `app01_book`.`publish_date`, `app01_book`.`publish_id` FROM `app01_book` WHERE `app01_book`.`id` = 1; args=(1,)
# 对象-Django精讲
# 对象-Django精讲
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;避免脏数据&lt;/h2&gt;
&lt;p&gt;　　 因为&lt;code&gt;QuerySet&lt;/code&gt;的缓存机制，所以使得可能出现脏数据。&lt;/p&gt;
&lt;p&gt;　　 即数据库中修改了某个数据，但是&lt;code&gt;QuerySet&lt;/code&gt;缓存中依旧是旧数据。&lt;/p&gt;
&lt;p&gt;　　 避免这种问题的解决方案有两种：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;　　 1.不要重复使用同一变量。每次使用都应该重新赋值（虽然增加查询次数，但是保证数据准确）&lt;/p&gt;
&lt;p&gt;　　 2.使用迭代器方法，不可重复用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;from app01 import models
res_queryset = models.Book.objects.filter(pk=1)

for i in res_queryset.iterator(): # 迭代器
        print(i)

for i in res_queryset:  # 缓存没有，重新获取
        print(i)

# (0.001) SELECT `app01_book`.`id`, `app01_book`.`title`, `app01_book`.`price`, `app01_book`.`publish_date`, `app01_book`.`publish_id` FROM `app01_book` WHERE `app01_book`.`id` = 1; args=(1,)
# 对象-Django精讲
# (0.003) SELECT `app01_book`.`id`, `app01_book`.`title`, `app01_book`.`price`, `app01_book`.`publish_date`, `app01_book`.`publish_id` FROM `app01_book` WHERE `app01_book`.`id` = 1; args=(1,)
# 对象-Django精讲
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2&gt;mysql对照&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Django&lt;/th&gt;
&lt;th&gt;MySQL&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr&gt;&lt;td&gt;AutoField&lt;/td&gt;
&lt;td&gt;integer AUTO_INCREMENT&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;BigAutoField&lt;/td&gt;
&lt;td&gt;bigint AUTO_INCREMENT&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;BinaryField&lt;/td&gt;
&lt;td&gt;longblob&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;BooleanField&lt;/td&gt;
&lt;td&gt;bool&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;CharField&lt;/td&gt;
&lt;td&gt;varchar(%(max_length)s)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;CommaSeparatedIntegerField&lt;/td&gt;
&lt;td&gt;varchar(%(max_length)s)&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;DateField&lt;/td&gt;
&lt;td&gt;date&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;DecimalField&lt;/td&gt;
&lt;td&gt;numeric(%(max_digits)s, %(decimal_places)s)&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;DurationField&lt;/td&gt;
&lt;td&gt;bigint&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;FileField&lt;/td&gt;
&lt;td&gt;varchar(%(max_length)s)&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;FilePathField&lt;/td&gt;
&lt;td&gt;varchar(%(max_length)s)&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;IntegerField&lt;/td&gt;
&lt;td&gt;integer&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;BigIntegerField&lt;/td&gt;
&lt;td&gt;bigint&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;IPAddressField&lt;/td&gt;
&lt;td&gt;char(15)&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;GenericIPAddressField&lt;/td&gt;
&lt;td&gt;char(39)&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;NullBooleanField&lt;/td&gt;
&lt;td&gt;bool&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;OneToOneField&lt;/td&gt;
&lt;td&gt;integer&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;PositiveIntegerField&lt;/td&gt;
&lt;td&gt;nteger UNSIGNED&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;SlugField&lt;/td&gt;
&lt;td&gt;varchar(%(max_length)s)&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;SmallIntegerField&lt;/td&gt;
&lt;td&gt;smallint&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;TextField&lt;/td&gt;
&lt;td&gt;longtext&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;TimeField&lt;/td&gt;
&lt;td&gt;time&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;UUIDField&lt;/td&gt;
&lt;td&gt;char(32)&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2&gt;数值类型&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Django字段&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;是否有注意事项&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;7&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;AutoField&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;int自增列，必须填入参数 primary_key=True&lt;/td&gt;
&lt;td&gt;有，见描述&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;BigAutoField&lt;/td&gt;
&lt;td&gt;bigint自增列，必须填入参数 primary_key=True&lt;/td&gt;
&lt;td&gt;有，见描述&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;SmallIntegerField&lt;/td&gt;
&lt;td&gt;小整数 -32768 ～ 32767&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;PositiveSmallIntegerField&lt;/td&gt;
&lt;td&gt;正小整数 0 ～ 32767&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;IntegerField&lt;/td&gt;
&lt;td&gt;整数列(有符号的) -2147483648 ～ 2147483647&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;PositiveIntegerField&lt;/td&gt;
&lt;td&gt;正整数 0 ～ 2147483647&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;BigIntegerField&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;长整型(有符号的) -9223372036854775808 ～ 9223372036854775807&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;BooleanField&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;布尔值类型&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;NullBooleanField&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;可以为空的布尔值&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;FloatField&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;浮点型&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;DecimalField&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;10进制小数&lt;/td&gt;
&lt;td&gt;有，见说明&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;BinaryField&lt;/td&gt;
&lt;td&gt;二进制类型&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;　　 说明补充：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;DecimalField(Field)
- 10进制小数
- 参数：
        max_digits，小数总长度
        decimal_places，小数位长度
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 其他补充：自定义无符号整数类型&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class UnsignedIntegerField(models.IntegerField): # 必须继承
        def db_type(self, connection):
                return 'integer UNSIGNED' # 返回真实存放的类型
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;字符类型&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Django字段&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;是否有注意事项&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;12.5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;CharField&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;必须提供max_length参数， max_length表示字符长度&lt;/td&gt;
&lt;td&gt;有，见描述&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;EmailField&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;字符串类型，Django Admin以及ModelForm中提供验证机制&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;IPAddressField&lt;/td&gt;
&lt;td&gt;字符串类型，Django Admin以及ModelForm中提供验证 IPV4 机制&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;GenericIPAddressField&lt;/td&gt;
&lt;td&gt;字符串类型，Django Admin以及ModelForm中提供验证 Ipv4和Ipv6&lt;/td&gt;
&lt;td&gt;有，见说明&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;URLField&lt;/td&gt;
&lt;td&gt;字符串类型，Django Admin以及ModelForm中提供验证 URL&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;SlugField&lt;/td&gt;
&lt;td&gt;字符串类型，Django Admin以及ModelForm中提供验证支持 字母、数字、下划线、连接符（减号）&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;CommaSeparatedIntegerField&lt;/td&gt;
&lt;td&gt;字符串类型，格式必须为逗号分割的数字&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;UUIDField&lt;/td&gt;
&lt;td&gt;字符串类型，Django Admin以及ModelForm中提供对UUID格式的验证&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;FilePathField&lt;/td&gt;
&lt;td&gt;字符串，Django Admin以及ModelForm中提供读取文件夹下文件的功能&lt;/td&gt;
&lt;td&gt;有，见说明&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;FileField&lt;/td&gt;
&lt;td&gt;字符串，路径保存在数据库，文件上传到指定目录&lt;/td&gt;
&lt;td&gt;有，见说明&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;ImageField&lt;/td&gt;
&lt;td&gt;字符串，路径保存在数据库，文件上传到指定目录&lt;/td&gt;
&lt;td&gt;有，见说明&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;　　 说明补充：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;GenericIPAddressField(Field)
- 字符串类型，Django Admin以及ModelForm中提供验证 Ipv4和Ipv6
- 参数：
    protocol，用于指定Ipv4或Ipv6， 'both',&quot;ipv4&quot;,&quot;ipv6&quot;
    unpack_ipv4， 如果指定为True，则输入::ffff:192.0.2.1时候，可解析为192.0.2.1，开启刺功能，需要protocol=&quot;both&quot;

FilePathField(Field)
- 字符串，Django Admin以及ModelForm中提供读取文件夹下文件的功能
- 参数：
    path,                      文件夹路径
    match=None,                正则匹配
    recursive=False,           递归下面的文件夹
    allow_files=True,          允许文件
    allow_folders=False,       允许文件夹

FileField(Field)
- 字符串，路径保存在数据库，文件上传到指定目录
- 参数：
    upload_to = &quot;&quot;      上传文件的保存路径
    storage = None      存储组件，默认django.core.files.storage.FileSystemStorage


ImageField(FileField)
- 字符串，路径保存在数据库，文件上传到指定目录
- 参数：
    upload_to = &quot;&quot;      上传文件的保存路径
    storage = None      存储组件，默认django.core.files.storage.FileSystemStorage
    width_field=None,   上传图片的高度保存的数据库字段名（字符串）
    height_field=None   上传图片的宽度保存的数据库字段名（字符串）
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;时间类型&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Django字段&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;是否有注意事项&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3.5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;DateTimeField&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;日期+时间格式 YYYY-MM-DD HH:MM[:ss[.uuuuuu]][TZ]&lt;/td&gt;
&lt;td&gt;有，见说明&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;DateField&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;日期格式 YYYY-MM-DD&lt;/td&gt;
&lt;td&gt;有，见说明&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;TimeField&lt;/td&gt;
&lt;td&gt;时间格式 HH:MM[:ss[.uuuuuu]]&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;DurationField&lt;/td&gt;
&lt;td&gt;长整数，时间间隔，数据库中按照bigint存储，ORM中获取的值为datetime.timedelta类型&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;　　 说明补充：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;时间类型的字段都有两个参数：
auto_now=False  # 当记录更新时是否自动更新当前时间
auto_now_add=False # 当记录创建时是否自动更新当前时间
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;条件参数&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;条件参数&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;9&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;null&lt;/td&gt;
&lt;td&gt;数据库中字段是否可以为空，接受布尔值&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;db_column&lt;/td&gt;
&lt;td&gt;数据库中字段的列名，接受字符串&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;default&lt;/td&gt;
&lt;td&gt;数据库中字段的默认值，接受时间，数值，字符串&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;primary_key&lt;/td&gt;
&lt;td&gt;数据库中字段是否为主键，接受布尔值（一张表最多一个主键）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;db_index&lt;/td&gt;
&lt;td&gt;数据库中字段是否可以建立索引，接受布尔值&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;unique&lt;/td&gt;
&lt;td&gt;数据库中字段是否可以建立唯一索引，接受布尔值&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;unique_for_date&lt;/td&gt;
&lt;td&gt;数据库中字段【日期】部分是否可以建立唯一索引，接受布尔值&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;unique_for_month&lt;/td&gt;
&lt;td&gt;数据库中字段【月】部分是否可以建立唯一索引，接受布尔值&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;unique_for_year&lt;/td&gt;
&lt;td&gt;数据库中字段【年】部分是否可以建立唯一索引，接受布尔值&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2&gt;choices&lt;/h2&gt;
&lt;p&gt;　　 &lt;code&gt;choices&lt;/code&gt;是一个非常好用的参数。它允许你数据库中存一个任意类型的值，但是需要使用时则是使用的它的描述。&lt;/p&gt;
&lt;p&gt;　　 如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;gender = models.BooleanField(choices=((0,&quot;male&quot;),(1,&quot;female&quot;)),default=0)
# 实际只存0和1，但是我们取的时候会取male或者female
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 取出方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;get_col_display()

后端示例：
        obj = models.User.objects.get(pk=1)
        gender = obj.get_gender_display()
        print(gender)  # male
        
前端示例：
        {{obj.get_gender_display}}  &amp;lt;!-- 前端不用加括号，自己调用 --&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;元信息&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;class UserInfo(models.Model):
        nid = models.AutoField(primary_key=True)
        username = models.CharField(max_length=32)
        class Meta:
            # 数据库中生成的表名称 默认 app名称 + 下划线 + 类名
            db_table = &quot;table_name&quot;

            # 联合索引
            index_together = [
                (&quot;pub_date&quot;, &quot;deadline&quot;),
            ]

            # 联合唯一索引
            unique_together = ((&quot;driver&quot;, &quot;restaurant&quot;),)

            # admin中显示的表名称
            verbose_name

            # verbose_name加s
            verbose_name_plural
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;多表关系参数&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;ForeignKey(ForeignObject) # ForeignObject(RelatedField)
        to,                         # 要进行关联的表名
        to_field=None,              # 要关联的表中的字段名称
        on_delete=None,             # 当删除关联表中的数据时，当前表与其关联的行的行为
                                        - models.CASCADE，删除关联数据，与之关联也删除
                                        - models.DO_NOTHING，删除关联数据，引发错误IntegrityError
                                        - models.PROTECT，删除关联数据，引发错误ProtectedError
                                        - models.SET_NULL，删除关联数据，与之关联的值设置为null（前提FK字段需要设置为可空）
                                        - models.SET_DEFAULT，删除关联数据，与之关联的值设置为默认值（前提FK字段需要设置默认值）
                                        - models.SET，删除关联数据，
                                                      a. 与之关联的值设置为指定值，设置：models.SET(值)
                                                      b. 与之关联的值设置为可执行对象的返回值，设置：models.SET(可执行对象)

                                                        def func():
                                                            return 10

                                                        class MyModel(models.Model):
                                                            user = models.ForeignKey(
                                                                to=&quot;User&quot;,
                                                                to_field=&quot;id&quot;
                                                                on_delete=models.SET(func),)
        related_name=None,          # 反向操作时，使用的字段名，用于代替 【表名_set】 如： obj.表名_set.all()
        related_query_name=None,    # 反向操作时，使用的连接前缀，用于替换【表名】     如： models.UserGroup.objects.filter(表名__字段名=1).values('表名__字段名')
        limit_choices_to=None,      # 在Admin或ModelForm中显示关联数据时，提供的条件：
                                    # 如：
                                            - limit_choices_to={'nid__gt': 5}
                                            - limit_choices_to=lambda : {'nid__gt': 5}

                                            from django.db.models import Q
                                            - limit_choices_to=Q(nid__gt=10)
                                            - limit_choices_to=Q(nid=8) | Q(nid__gt=10)
                                            - limit_choices_to=lambda : Q(Q(nid=8) | Q(nid__gt=10)) &amp;amp; Q(caption='root')
        db_constraint=True          # 是否在数据库中创建外键约束
        parent_link=False           # 在Admin中是否显示关联数据


    OneToOneField(ForeignKey)
        to,                         # 要进行关联的表名
        to_field=None               # 要关联的表中的字段名称
        on_delete=None,             # 当删除关联表中的数据时，当前表与其关联的行的行为

                                    ###### 对于一对一 ######
                                    # 1. 一对一其实就是 一对多 + 唯一索引
                                    # 2.当两个类之间有继承关系时，默认会创建一个一对一字段
                                    # 如下会在A表中额外增加一个c_ptr_id列且唯一：
                                            class C(models.Model):
                                                nid = models.AutoField(primary_key=True)
                                                part = models.CharField(max_length=12)

                                            class A(C):
                                                id = models.AutoField(primary_key=True)
                                                code = models.CharField(max_length=1)

    ManyToManyField(RelatedField)
        to,                         # 要进行关联的表名
        related_name=None,          # 反向操作时，使用的字段名，用于代替 【表名_set】 如： obj.表名_set.all()
        related_query_name=None,    # 反向操作时，使用的连接前缀，用于替换【表名】     如： models.UserGroup.objects.filter(表名__字段名=1).values('表名__字段名')
        limit_choices_to=None,      # 在Admin或ModelForm中显示关联数据时，提供的条件：
                                    # 如：
                                            - limit_choices_to={'nid__gt': 5}
                                            - limit_choices_to=lambda : {'nid__gt': 5}

                                            from django.db.models import Q
                                            - limit_choices_to=Q(nid__gt=10)
                                            - limit_choices_to=Q(nid=8) | Q(nid__gt=10)
                                            - limit_choices_to=lambda : Q(Q(nid=8) | Q(nid__gt=10)) &amp;amp; Q(caption='root')
        symmetrical=None,           # 仅用于多对多自关联时，symmetrical用于指定内部是否创建反向操作的字段
                                    # 做如下操作时，不同的symmetrical会有不同的可选字段
                                        models.BB.objects.filter(...)

                                        # 可选字段有：code, id, m1
                                            class BB(models.Model):

                                            code = models.CharField(max_length=12)
                                            m1 = models.ManyToManyField('self',symmetrical=True)

                                        # 可选字段有: bb, code, id, m1
                                            class BB(models.Model):

                                            code = models.CharField(max_length=12)
                                            m1 = models.ManyToManyField('self',symmetrical=False)

        through=None,               # 自定义第三张表时，使用字段用于指定关系表
        through_fields=None,        # 自定义第三张表时，使用字段用于指定关系表中那些字段做多对多关系表
                                        from django.db import models

                                        class Person(models.Model):
                                            name = models.CharField(max_length=50)

                                        class Group(models.Model):
                                            name = models.CharField(max_length=128)
                                            members = models.ManyToManyField(
                                                Person,
                                                through='Membership',
                                                through_fields=('group', 'person'),
                                            )

                                        class Membership(models.Model):
                                            group = models.ForeignKey(Group, on_delete=models.CASCADE)
                                            person = models.ForeignKey(Person, on_delete=models.CASCADE)
                                            inviter = models.ForeignKey(
                                                Person,
                                                on_delete=models.CASCADE,
                                                related_name=&quot;membership_invites&quot;,
                                            )
                                            invite_reason = models.CharField(max_length=64)
        db_constraint=True,         # 是否在数据库中创建外键约束
        db_table=None,              # 默认创建第三张表时，数据库中表的名称字段以及参数
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;　　 &lt;code&gt;M2M&lt;/code&gt;的创建方式有三种，分别是全自动，半自动，全手动。&lt;/p&gt;
&lt;p&gt;　　 全自动使用最方便，但是扩展性最差。&lt;/p&gt;
&lt;p&gt;　　 半自动介于全自动与全手动之间。&lt;/p&gt;
&lt;p&gt;　　 全手动使用最麻烦，但是扩展性最好。&lt;/p&gt;
&lt;h2&gt;全自动&lt;/h2&gt;
&lt;p&gt;　　 自动创建的第三张表，即为全自动。&lt;/p&gt;
&lt;p&gt;　　 最上面多表关系中的多对多，使用的便是全自动创建。&lt;/p&gt;
&lt;p&gt;　　 全自动创建操纵及其方便，如&lt;code&gt;add/set/remove/clear&lt;/code&gt;。&lt;/p&gt;
&lt;h2&gt;半自动&lt;/h2&gt;
&lt;p&gt;　　 手动创建第三张表，并指定此表中那两个字段是其他两张表的关联关系。&lt;/p&gt;
&lt;p&gt;　　 可使用&lt;code&gt;__&lt;/code&gt;跨表，正反向查询。&lt;/p&gt;
&lt;p&gt;　　 但是不可使用如&lt;code&gt;add/set/remove/clear&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;　　 在实际生产中，推荐使用半自动。它的扩展性最强&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;class Book(models.Model):
        name = models.CharField(max_length=32)
        authors = models.ManyToManyField(
                to=&quot;Author&quot;, # 与作者表创建关系。
                through=&quot;M2M_BookAuthor&quot;, # 使用自己创建的表
                through_fields=('book','author'), # 这两个字段是关系  注意！那张表上创建多对多，就将字段放在前面
        )
        
class Author(models.Model):
        name = models.CharField(max_length=32)
        # book = models.ManyToManyField(
                # to=&quot;Book&quot;,
                # through=&quot;M2M_BookAuthor&quot;,
                # through_fields=('author','book'), Author创建，所以author放在前面
        
        # )
        
class M2M_BookAuthor(models.Model):
        book = models.ForeignKey(to=&quot;Book&quot;)
        author = models.ForeignKey(to=&quot;Author&quot;)
        # 两个fk，自动添加_id后缀。
        
    class Meta:
        unique_together = ((&quot;author&quot;, &quot;book&quot;),)
        # 联合唯一索引
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;全手动&lt;/h2&gt;
&lt;p&gt;　　 不可使用&lt;code&gt;add/set/remove/clear&lt;/code&gt;，以及&lt;code&gt;__&lt;/code&gt;跨表，正反向查询。&lt;/p&gt;
&lt;p&gt;　　 所有数据均手动录入。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Book(models.Model):
        name = models.CharField(max_length=32)

        
class Author(models.Model):
        name = models.CharField(max_length=32)
        
class M2M_BookAuthor(models.Model):
        book = models.ForeignKey(to=&quot;Book&quot;)
        author = models.ForeignKey(to=&quot;Author&quot;)
        # 两个fk，自动添加_id后缀。
        
    class Meta:
        unique_together = ((&quot;author&quot;, &quot;book&quot;),)
        # 联合唯一索引
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 18 Sep 2020 21:37:00 +0000</pubDate>
<dc:creator>云崖先生</dc:creator>
<og:description>Django ORM Django模型层的功能就是与数据库打交道，其中最主要的框架为ORM。 ORM为对象关系映射，说白了就是将Python中的类映射成数据表，将表中每一条记录映射成类的实例对象，将对</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Yunya-Cnblogs/p/13694386.html</dc:identifier>
</item>
<item>
<title>数据分析与数据挖掘 - 05统计概率 - 马一特</title>
<link>http://www.cnblogs.com/mayite/p/13694194.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mayite/p/13694194.html</guid>
<description>&lt;h3 id=&quot;一-统计学基础运算&quot;&gt;一 统计学基础运算&lt;/h3&gt;
&lt;h4 id=&quot;1-方差的计算&quot;&gt;1 方差的计算&lt;/h4&gt;
&lt;p&gt;在统计学中为了观察数据的离散程度，我们需要用到标准差，方差等计算。我们现在拥有以下两组数据，代表着两组同学们的成绩，现在我们要研究哪一组同学的成绩更稳定一些。方差是中学就学过的知识，可能有的同学忘记了 ，一起来回顾下。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;A组 = [50,60,40,30,70,50] B组 = [40,30,40,40,100]&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;为了便于理解，我们可以先使用平均数来看，它们的平均数都是50，无法比较出他们的离散程度的差异。针对这样的情况，我们可以先把分数减去平均分进行平方运算后，再取平均值。&lt;br/&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/281865/1599874385027-d4ac447d-bc84-4f7d-9de6-5dc66086278e.png#align=left&amp;amp;display=inline&amp;amp;height=438&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;name=image.png&amp;amp;originHeight=876&amp;amp;originWidth=1592&amp;amp;size=428197&amp;amp;status=done&amp;amp;style=none&amp;amp;width=796&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;想上面这样就是方差的计算方式，就是数组中的每一个数减去平均值，然后再分别计算它们的平方值，最后再取平均数的运算就叫方差。方差很适合用来研究数据的离散程度，但是会存在两个问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;有时数值会变得特别大&lt;/li&gt;
&lt;li&gt;运算的结果变成了原来的平方&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;为了解决上面的问题，我们会把最后的结果开方，就像这样：&lt;br/&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/281865/1599878040294-b5b66567-b9b2-4148-9287-a7d107702117.png#align=left&amp;amp;display=inline&amp;amp;height=366&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;name=image.png&amp;amp;originHeight=882&amp;amp;originWidth=1800&amp;amp;size=503460&amp;amp;status=done&amp;amp;style=none&amp;amp;width=746&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;在方差的结果上，开一个根号，运算出来的结果就叫做标准差了。通过标准差的计算后，我们一下就能够看出来，标准差越小的，证明其成绩越稳定。&lt;/p&gt;
&lt;h4 id=&quot;2-使用numpy计算标准差和方差&quot;&gt;2 使用numpy计算标准差和方差&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import numpy as np

# 创建一个二维数组
arr = np.array([[3, 7, 25, 8, 15, 20],
                [4, 5, 6, 9, 14, 21]])

# 计算方差
print(arr.var())
print(np.var(arr))
# 计算标准差
print(arr.std())
print(np.std(arr))

# 计算轴0方向方差
print(arr.var(axis=0))
print(np.var(arr, axis=0))
# 计算轴1方向方差
print(arr.var(axis=1))
print(np.var(arr, axis=1))

# 计算轴0方向标准差
print(arr.std(axis=0))
print(np.std(arr, axis=0))
# 计算轴1方向标准差
print(arr.std(axis=1))
print(np.std(arr, axis=1))
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;二-二项式定理&quot;&gt;二 二项式定理&lt;/h3&gt;
&lt;h4 id=&quot;1-二项式系数&quot;&gt;1 二项式系数&lt;/h4&gt;
&lt;p&gt;二项式定理非常重要，是理解和应用概率分布的前提，这都是中学学过的，我们一起来回顾一下。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/4be1d758b373540114edf33d4d3db633.svg#card=math&amp;amp;code=%E6%A0%B9%E6%8D%AE%E6%9C%80%E5%9F%BA%E7%A1%80%E7%9A%84%E5%85%AC%E5%BC%8F%EF%BC%9A%0A%EF%BC%88a%2Bb%EF%BC%89%5E2%20%3D%20a%5E2%2B2ab%2Bb%5E2%20%5C%5C%0A&amp;amp;height=41&amp;amp;width=724&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;&lt;p&gt;2ab这一项可以用排列组合的知识来理解，从(a+b)(a+b)分别选出a和b的可能性，那么一共有两种情况：&lt;br/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;从第一个(a+b)中选出a，从第二个(a+b)选出b&lt;/li&gt;
&lt;li&gt;从第二个(a+b)中选出a，从第一个(a+b)中选出b&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;所以ab左边的系数就是2，这个2就是二项式系数，同理：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/5d347d9540b62b266039b6a731279efd.svg#card=math&amp;amp;code=%E6%A0%B9%E6%8D%AE%E5%85%AC%E7%A4%BA%EF%BC%9A%28a%2Bb%29%5E3%3Da%5E3%2B3a%5E2b%2B3ab%5E2%2Bb%5E3%20%5C%5C&amp;amp;height=38&amp;amp;width=724&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/281865/1600015170655-b49062ad-ddbb-4712-847d-fd9552bbf685.png#align=left&amp;amp;display=inline&amp;amp;height=926&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;name=WechatIMG62%E5%89%AF%E6%9C%AC.png&amp;amp;originHeight=926&amp;amp;originWidth=1702&amp;amp;size=281853&amp;amp;status=done&amp;amp;style=none&amp;amp;width=1702&quot; alt=&quot;WechatIMG62副本.png&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;我们从上边的两个例子中可以看到，无论是第一个例子中的从两个括号中选出一个b，还是后边的从3个括号中选出一个b(这里我们把b作为研究对象，其实无论是谁都是一样的)都是组合的问题，所以结合我们中学学过的知识二项系数可以总结为如下公式：&lt;br/&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/281865/1600015643414-4d4e3a5c-a7d6-47d7-955b-9c56885d5735.png#align=left&amp;amp;display=inline&amp;amp;height=269&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;name=image.png&amp;amp;originHeight=538&amp;amp;originWidth=1472&amp;amp;size=95087&amp;amp;status=done&amp;amp;style=none&amp;amp;width=736&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;在统计学中，对于二项分布来说，二项系数是必不可少的知识，关于二项分布我们后边会讲到。&lt;/p&gt;
&lt;h4 id=&quot;2-用python获得二项系数&quot;&gt;2 用Python获得二项系数&lt;/h4&gt;
&lt;p&gt;首先需要声明一个函数，函数接收两个参数，一个是n，一个是k，返回值为其二项系数的值。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import itertools
import numpy as np

# 等待排列的数组
arr = [1, 2, 3, 4, 5]
# 排列的实现P
print(list(itertools.permutations(arr, 3)))

# 组合的实现C
print(list(itertools.combinations(arr, 3)))


# 获取二项系数的函数
# 支持两个参数，第一个是n，第二个是k
def get_binomial_coefficient(n, k):
    return len(list(itertools.combinations(np.arange(n), k)))


print(get_binomial_coefficient(3, 1))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用二项式系数就可以展开(a+b)^n，所以有二项式定理，如下：&lt;br/&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/281865/1600021759469-e9ff9de2-bd10-4e21-ac27-d838a98d366f.png#align=left&amp;amp;display=inline&amp;amp;height=242&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;name=image.png&amp;amp;originHeight=484&amp;amp;originWidth=1764&amp;amp;size=90287&amp;amp;status=done&amp;amp;style=none&amp;amp;width=882&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;三-独立实验与重复实验&quot;&gt;三 独立实验与重复实验&lt;/h3&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;寺庙在中国已经遍布大江南北了，一天小王和小李二人出游，爬山后，偶遇一寺庙，寺庙中有一个大师，善占卜。于是二人决定请大师帮忙占卜一次。大师见二人结伴而来，便问二人是占卜独卦，还是连卦呢？二人不解，何为独卦，何为连卦？于是大师解答到：独卦为第一人占卜后，将卦签放回签桶中后，再进行第二次占卜。连卦为第一人占卜后，已抽出的卦签不放回签桶中，直接进行第二次占卜。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;假设签筒中，只有5根签，其中2根是上签，而其他3根是下签。小王先抽签，小王抽签的行为记为S，小李抽签的行为记为T。在独卦的占卜规则下，S的结果并不影响T的结果。也就是说不管小王是否抽中上签，小李抽中上签的概率都是2/5。而在连卦的占卜规则下，S的结果对T的结果产生影响。因为小王抽完签之后，并不把签放回桶中。如果小王抽中上签，那么小李抽中上签的概率就是1/4，如果小王没有抽中上签，那么小李抽中上签的概率就是2/4。在独卦的占卜规则下，两次抽签行为S与T的。它们的结果互不影响，我们在统计学中称S与T是独立试验。&lt;/p&gt;&lt;p&gt;当S与T相互独立时，S中发生事件A和T中发生的事件B的概率P可以表示为：&lt;/p&gt;&lt;p&gt;&lt;strong&gt;P(A∩B) = P(A) * P(B)&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;显然，在独卦的占卜规则下，小王和小李都抽中上签的概率是4/25。&lt;br/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;现在有这样一个场景，掷骰子的游戏，仍然是小王和小李一起玩，每人拿3颗骰子。游戏规则是三颗骰子每个掷一次，最后谁的点数大谁赢。这里不管他们掷骰子多少次，每一次的结果对于其他次的结果都不会产生影响，所以他们都是相互独立的实验。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于这样反复的独立试验，我们称其为重复试验或者叫独立重复试验。现在我们把掷3次骰子，每一次掷骰子时，其中2颗骰子都出现1的情况画图如下(X代表其他数字)：&lt;br/&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/281865/1600102116039-b6defc00-e954-415b-b753-6d9ce43caa54.png#align=left&amp;amp;display=inline&amp;amp;height=453&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;name=image.png&amp;amp;originHeight=906&amp;amp;originWidth=1558&amp;amp;size=438721&amp;amp;status=done&amp;amp;style=none&amp;amp;width=779&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;我们先来看一下第一次掷骰子的情况前两颗骰子为1，第三颗骰子为其他数字的概率分别为1/6、1/6、5/6，因为每一次的试验都是相互独立的，所以发生的概率为1/6×1/6×5/6。三次掷骰子，每一次有两颗骰子是1的情况的种类为3种，由于3种情况是互斥的(不可能同时发生)，所以概率应该为3次的概率相加。也就是:3×(1/6)²×5/6。A事件和B事件相互排斥时，公式可以表示为：&lt;/p&gt;&lt;p&gt;&lt;strong&gt;P(A∪B)=P(A)+P(B)&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;根据以上试验结果，可得重复试验的概率公式为：&lt;br/&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/281865/1600102690790-ae1183f7-12d7-409d-8604-93bd4f215e2c.png#align=left&amp;amp;display=inline&amp;amp;height=734&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;name=WechatIMG2.png&amp;amp;originHeight=734&amp;amp;originWidth=1508&amp;amp;size=148292&amp;amp;status=done&amp;amp;style=none&amp;amp;width=1508&quot; alt=&quot;WechatIMG2.png&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;重复试验对于下一章我们要学习的二项分布的理解非常有帮助，所以一定要理解。如果不是特别的理解，你可以现在把上边掷骰子的情况修改成为4颗骰子掷6次，每一次出现两个1的情况画图重新按照咱们上边的思路梳理一下，相信你就已经能够掌握了。&lt;/p&gt;&lt;p&gt;练习题：&lt;br/&gt;现在有5道4选1的问题。A同学对这5道题目完全不会，但在乱答的情况下，能够答对一半以上的概率是多少，用代码实现一下。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import itertools
import numpy as np

&quot;&quot;&quot;
题目解析:答对一半以上的情况分别为3题，4题和5题
不用考虑其顺序，答对任意题目都可以，所以这是一个组合的问题
&quot;&quot;&quot;


# 声明一个函数来求组合问题
def get_binomial_coefficient(n, k):
    return len(list(itertools.combinations(np.arange(n), k)))


# 每题答对的概率
P_true = 1 / 4
# 每题答错的概率
P_false = 3 / 4

# 求答对0到5题的组合情况
# 答对0题的组合情况
zero = get_binomial_coefficient(5, 0)
# 答对1题的组合情况
one = get_binomial_coefficient(5, 1)
# 答对2题的组合情况
two = get_binomial_coefficient(5, 2)
# 答对3题的组合情况
three = get_binomial_coefficient(5, 3)
# 答对4题的组合情况
four = get_binomial_coefficient(5, 4)
# 答对5题的组合情况
five = get_binomial_coefficient(5, 5)
# # # 答对一半以上的概率(答对3题、4题、5题)
last = three * pow(P_true, 3) * pow(P_false, 2) + four * pow(P_true, 4) * pow(P_false, 1) + five * pow(P_true, 5) * pow(
    P_false, 0)
print(last)
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;学霸的世界：有一两个不太确定的，蒙一下吧，考完了很没信心，感觉考得不怎么样，结果是除了蒙的，其他的都对了，数学140分。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;学渣的世界：好多不会的，我感觉选这个就应该对，毕竟蒙对的经验很丰富，感觉考得还可以，结果是会的马虎做错了，蒙的就对了一个，数学89分，啪啪打脸。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;根据概率结果可知，乱答看似概率还不错，但实际运算出来后概率低的可怜，所以每次乱答后，实际得分总比想象中的得分低。&lt;/p&gt;
&lt;h3 id=&quot;四-∑符号及其意义&quot;&gt;四 ∑符号及其意义&lt;/h3&gt;
&lt;p&gt;在以前，我们表示a1到a5的和会这样写：S5 = a1 + a2 + a3 + a4 + a5。同理，如果我们要表示a1到a10的和会这样写：S10 = a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8 + a9 + a10。如果我们要表示a1到a1000的和我们会这样写S1000 = a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8 + …… + a1000。但是中间的……总给人一种不好的感觉，就像我们在学习二项定理时的表达方式，总感觉特别的冗长。为了解决这个问题，我们就引入了Σ(读西格玛)符号，也可以叫做求和符号。像上边的表示a1到a1000的和我们可以这样表达：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/9bfbe3dd6db9a8bbeb9a4a086fc71095.svg#card=math&amp;amp;code=S1000%20%3D%20%5CSigma_%7Bn%3D1%7D%5E%7B1000%7D%20%7Ba_n%7D%20%5C%5C&amp;amp;height=37&amp;amp;width=724&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;Σ(读西格玛)符号在数学中非常的常见，在以后的学习中，你也几乎可以在任意一个算法模型中见到这个符号，所以它的特点也一定要掌握。&lt;/p&gt;&lt;p&gt;Σ可以使用分配率，我们一起来看一个例子：&lt;br/&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/281865/1600105705582-52cc2465-c209-4335-8032-a9297d8b1d8f.png#align=left&amp;amp;display=inline&amp;amp;height=872&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;name=WechatIMG64.png&amp;amp;originHeight=872&amp;amp;originWidth=1784&amp;amp;size=168953&amp;amp;status=done&amp;amp;style=none&amp;amp;width=1784&quot; alt=&quot;WechatIMG64.png&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;下面我们一起来学习一下几个关于Σ的计算公式，记住它们，以后你的计算将会非常的方便。&lt;/p&gt;&lt;p&gt;公式一及其证明过程如下：&lt;br/&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/281865/1600105800857-2e93f7ef-6cae-4396-b20d-6b01d14684e8.png#align=left&amp;amp;display=inline&amp;amp;height=824&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;name=WechatIMG65.png&amp;amp;originHeight=824&amp;amp;originWidth=1614&amp;amp;size=117111&amp;amp;status=done&amp;amp;style=none&amp;amp;width=1614&quot; alt=&quot;WechatIMG65.png&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;公式二及其证明过程如下：&lt;br/&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/281865/1600105844496-6f2ccfad-b7ca-4d59-af42-764b218c9940.png#align=left&amp;amp;display=inline&amp;amp;height=424&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;name=image.png&amp;amp;originHeight=848&amp;amp;originWidth=1502&amp;amp;size=155565&amp;amp;status=done&amp;amp;style=none&amp;amp;width=751&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;Σ的计算公式我们暂时先学习这两个，其他的公式后边用到的时候我们再来结合着场景进行学习。&lt;/p&gt;
&lt;h3 id=&quot;五-随机变量&quot;&gt;五 随机变量&lt;/h3&gt;
&lt;p&gt;终于到了随机变量，随机变量后边就是概率分布的知识了，随机变量在人工智能领域中的应用非常的普遍。首先说一下随机变量的分类，随机变量分为离散型随机变量和连续型随机变量。离散型随机变量的基本定义就是在实数范围内取值并不连续，或者说他的取值不是一个区间，而是一些固定的值。连续型随机变量则相反，它的取值是一个区间，在实数范围内是连续的。&lt;/p&gt;&lt;p&gt;还是举个例子比较形象，请看下面的示例：&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;离散型随机变量：一次掷20个硬币，k个硬币正面朝上，k是随机变量，k的取值只能是自然数0,1,2,…,20，而不能取小数3.5、无理数√20，因而k是离散型随机变量。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;连续型随机变量：公共汽车每15分钟一班，某人在站台等车时间x是个随机变量，x的取值范围是[0,15)，它是一个区间，从理论上说在这个区间内可取任一实数3.5、√20等，因而称这随机变量是连续型随机变量。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;六-伯努利分布&quot;&gt;六 伯努利分布&lt;/h3&gt;
&lt;p&gt;伯努利分布也被称为“零一分布”或“两点分布”。从名字上，我们就能够看出来，伯努利分布中事件的发生就两种情况。伯努利分布指的是一次随机试验，结果只有两种。生活中这样的场景很多，抛硬币是其中一个，我们抛一次硬币，其结果只有正面或反面。或某一个事件的成功和失败，病情的康复或未康复等等。&lt;/p&gt;&lt;p&gt;我们用字母x来表示随机变量的取值，并且它的概率计算公式为：&lt;/p&gt;&lt;p&gt;&lt;strong&gt;P(x=1) = p&lt;/strong&gt;&lt;strong&gt;，&lt;/strong&gt;P(x=0) = 1-p&lt;/p&gt;&lt;p&gt;当x=1时，它的概率为p，当x-0时，它的概率为1-p，我们就称随机变量x服从伯努利分布。&lt;/p&gt;&lt;p&gt;练习：&lt;br/&gt;甲和乙，两个人用一个均匀的硬币来赌博，均匀的意思就是不存在作弊行为，硬币抛出正面和反面的概率各占一半。硬币抛出正面时，甲输给乙一块钱，抛出反面时，乙输给甲一块钱。我们来用Python实现这一过程和输赢的总金额呈现的分布情况。&lt;br/&gt;分析：&lt;br/&gt;我们用数字1来表示抛得的结果为正面，用数字-1来表示抛得的结果为反面。为了呈现出概率分布的情况，我们需要有足够多的人来参与这个游戏，并且让他们两两一组来进行对决。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 导入 matplotlib库，用来画图，关于画图我们后边会有专门的章节进行讲解
import matplotlib.pyplot as plt

# 导入numpy
import numpy as np

n_person = 200
n_times = 500

t = np.arange(n_times)

# 创建包含1和-1两种类型元素的随机数组来表示输赢
# *2 -1 是为了随机出1 和-1，(n_person, n_times)表示生成一个200*500的二维数组
steps = 2 * np.random.random_integers(0, 1, (n_person, n_times)) - 1

# 计算每一组的输赢总额
amount = np.cumsum(steps, axis=1)

# 计算平方
sd_amount = amount ** 2

# 计算所有参加赌博的组的平均值
average_amount = np.sqrt(sd_amount.mean(axis=0))
print(average_amount)

# 画出数据,用绿色表示，并画出平方根的曲线，用红色表示
plt.plot(t, average_amount, 'g.', t, np.sqrt(t), 'r')
plt.show()
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;七-二项分布&quot;&gt;七 二项分布&lt;/h3&gt;
&lt;p&gt;离散型随机变量最常见的分布就是二项分布，我们还是以掷骰子为例子来开始这一章节的知识讲解。比如我们拥有一个骰子，那么每掷一次骰子的取值可能性为1、2、3、4、5、6，这些取值每一次的可能性都为六分之一，因为每一次掷骰子的行为都是独立的，第一次的结果并不影响第二次的任何行为和结果，这也叫概率的独立性。&lt;/p&gt;&lt;p&gt;总结一下，它一共有两个特点：&lt;br/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;每一次事件的概率都大于等于0，如果我们用P来表示概率，用X来表示事件，其数学表示就是P(X)&amp;gt;=0&lt;/li&gt;
&lt;li&gt;所有事件的概率的总和为1，也就是说骰子一共有6个面，我们每投掷一次骰子，一定会获得1、2、3、4、5、6数字其中的一个，其数学表示就是∑P(Xi)=1&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;现在有两个人A和B在进行某种对决，瓶子里有两个红球，一个白球，从里面随机抽取，抽到红球A获胜，抽到白球B获胜，抽完球再放进去。显然，A获胜的概率为2/3，在这种情况下，A能赢的次数就是一个随机变量了，而这个随机变量是如何分布的呢？&lt;/p&gt;&lt;p&gt;假设对局3次，A能赢的次数为x，则x的值有可能是0、1、2、3中的一个，关于其分别出现的概率，我们可以用反复试验的概率来进行求解(这其实就是3重伯努利试验)。&lt;/p&gt;&lt;p&gt;概率计算结果如下：&lt;br/&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/281865/1600154678270-34d7a69b-6e81-47a0-b6ab-22364f5695ec.png#align=left&amp;amp;display=inline&amp;amp;height=296&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;name=image.png&amp;amp;originHeight=888&amp;amp;originWidth=1646&amp;amp;size=215184&amp;amp;status=done&amp;amp;style=none&amp;amp;width=548.6666666666666&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;将x的概率分布整理成表，并替换成二项系数如下图：&lt;br/&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/281865/1600154719462-7695ec2d-8da3-4b2e-a5cf-a84bf81a0e36.png#align=left&amp;amp;display=inline&amp;amp;height=310&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;name=image.png&amp;amp;originHeight=930&amp;amp;originWidth=1476&amp;amp;size=479448&amp;amp;status=done&amp;amp;style=none&amp;amp;width=492&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;这就是二项分布的典型例子啦。一般来说，成功概率为p的试验，独立重复n次后的成功次数为X的概率分布，被称为关于发生概率为p、次数为n的二项分布。&lt;/p&gt;&lt;p&gt;这中情况下，X=k(k=0、1、2、…、n)的概率为n次重复中有k次成功(一次成功概率为p)，整理后的公式如下：&lt;br/&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/281865/1600155866791-0679b34f-2921-49ae-912f-55eff6afa3c0.png#align=left&amp;amp;display=inline&amp;amp;height=233&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;name=image.png&amp;amp;originHeight=700&amp;amp;originWidth=1150&amp;amp;size=70172&amp;amp;status=done&amp;amp;style=none&amp;amp;width=383.3333333333333&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;那么二项分布又与伯努利分布是什么样的关系呢？看着好像感觉有一些相似的地方，这种结果为成功或失败，胜或负等，结果是二选一的试验，被称为伯努利试验。在伯努利试验中，已知其中一个结果发生的概率(多数取成功的概率)时，此伯努利试验重复n次(也叫n重伯努利试验)时，其事件发生的次数(成功次数)遵循二项分布。如果二项分布中的试验次数变成了1次，那么这就叫做伯努利试验了，其随机变量是服从二项分布的。所以伯努利分布是二项分布在n=1时的特例，这就是它们的关系了。&lt;/p&gt;&lt;p&gt;最后总结一下二项分布，如下图：&lt;br/&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/281865/1600156138913-9f4f8f9b-10f3-439d-95b9-561aced73f7c.png#align=left&amp;amp;display=inline&amp;amp;height=890&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;name=WechatIMG67.png&amp;amp;originHeight=890&amp;amp;originWidth=1814&amp;amp;size=378025&amp;amp;status=done&amp;amp;style=none&amp;amp;width=1814&quot; alt=&quot;WechatIMG67.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;八-条件概率&quot;&gt;八 条件概率&lt;/h3&gt;
&lt;p&gt;现在假设我们有两个事件，事件A和事件B。当事件B发生时，事件A发生的概率，这就是条件概率的理解。条件概率公式是:&lt;/p&gt;&lt;p&gt;&lt;strong&gt;P(A|B) = P(A∩B)÷P(B)&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;br/&gt;这个公式看似有点抽象，但如果我们把它变形为&lt;/strong&gt; P(B) * P(A|B) = P(A∩B)，**就很好理解，P(B)表示事件B发生的概率，确定了事件B发生的概率再乘以P(A|B)自然就是事件A和事件B同时发生的概率。P(A|B)就是事件B发生时事件A发生的概率，P(A∩B)指的是事件A和事件B同时发生的概率。&lt;/p&gt;
&lt;p&gt;同理，可得：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P(B|A) = P(A∩B)÷P(A)&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;br/&gt;把两个公式变形：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;P(A∩B) = P(B) * P(A|B)&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt; P(A∩B) = P(A) * P(B|A) &lt;strong/&gt;&lt;/p&gt;&lt;p&gt;即可推导出：&lt;/p&gt;&lt;p&gt;P(A|B) = P(B|A) * P(A) / P(B)&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;br/&gt;这就是简单贝叶斯公式和它的推导过程，贝叶斯定理在人工智能领域可是非常重要的知识点，未来你会学到很多贝叶斯模型的，比如高斯贝叶斯、多项式贝叶斯、伯努利贝叶斯等等的分类器。&lt;/p&gt;&lt;p&gt;练习：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;现在假设一天之中，我饿了的概率是10%，我饿了并且在吃饭的概率是50%，我吃饭的概率是40%&lt;br/&gt;问:我吃饭的时候饿了的概率。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br/&gt;把我饿了看作事件A，则P(A) = 10%，把我吃饭的概率看作事件B，则P(B) = 40%，已知P(B|A) = 50%，则P(A|B) = P(B|A) * P(A) / P(B) = 0.5 * 0.1 / 0.4 = 12.5%&lt;/p&gt;
&lt;h3 id=&quot;九-全概率&quot;&gt;九 全概率&lt;/h3&gt;
&lt;p&gt;全概率可是概率论中非常重要的知识点，也关系着后边我们对贝叶斯定理进行深入的推导。那么什么又是全概率呢？&lt;br/&gt;先从一个故事开始讲解一下，拿上班的道路选择举例说明吧。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;我每天上班一共有4条路可以选择，我们现在把这4条路编成号码，分别是1号路到4号路。我每天会选择不同的路进行上班，来碰一下自己运气。现在我每天选择1号路上班的概率是20%，2号路的概率是30%，3号路的概率是10%，4号路的概率是40%。但是北京的路很糟糕，尤其是上班的高峰期，每一条路都有可能拥堵。现在1号路堵的概率为30%，2号路堵的概率是40%，3号路堵的概率是50%，4号路堵的概率是25%。一旦发生拥堵的情况我一定会迟到，现在来求一下我上班不迟到的概率。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这道题目首先要理解的就是如果我想要上班不迟到，那么路上就不能遇到拥堵的情况，也就是我们现在要把拥堵的概率，转换成为不拥堵的概率。那么对应的把拥堵的概率换算成不拥堵的概率就是1号路不堵的概率为70%，2号路不堵的概率是60%，3号路不堵的概率是50%，4号路堵的不概率是75%。换算完成后，下一步就是计算出我选择了其中一条路，并且这条路没有发生拥堵的概率。&lt;/p&gt;&lt;p&gt;首先我选择1号路的概率是20%，也就是0.2，并且1号路不拥堵的概率为70%，就是0.7，那么这件事情发生的概率就是0.2&lt;em&gt;0.7，结果等于0.14。这里有两个事件，事件A是我选择了1号路，事件B是1号路不拥堵，那么可以用P(AB)来进行概率的表示。也就是P(AB)=0.14,当我选择了1号路，并且一号路不拥堵的概率是0.14。我选择2号路的概率是0.3，2号路不拥堵的概率是0.6，这个时候我把事件A当做是2号路不拥堵，事件B当做是我选择了2号路，那么就可以写成P(AB)=0.18。那么现在我们来看一下我选择了3号路，并且3号路不堵的概率吧，就是0.1&lt;/em&gt;0.5 = 0.05。同理，我选择了4号路，并且4号路不堵的概率是0.4*0.75 = 0.3。那么最终我上班不迟到的概率就是0.14+0.18+0.05+0.3=0.67。&lt;/p&gt;&lt;p&gt;以上就是全概率的计算过程。我们来总结一下全概率公式。这里我们把上班不迟到的这件事情叫做事件A，它可以表示为P(A)。选择上班路线的事件叫做事件B，那么4条路的选择概率分别可以表示为P(B1)=0.2、P(B2)=0.3、P(B3)=0.1、P(B4)=0.4。那么分别对应着4条路，并且选择后它们不堵的概率可以表示为P(A|B1)=0.7、P(A|B2)=0.6、P(A|B3)=0.5、P(A|B4)=0.75。&lt;/p&gt;
&lt;p&gt;也就是说，我上班不迟到的全概率的计算方法就是&lt;/p&gt;&lt;p&gt;&lt;strong&gt;P(A)=P(A|B1)P(B1)+P(A|B2)P(B21)+P(A|B3)P(B3)+P(A|B4)P(B4)&lt;/strong&gt;&lt;br/&gt;**&lt;br/&gt;以上只有4种情况的发生，那么针对于n中情况的全概率公式，我们可以这样写P(A)=P(A|B1)P(B1) + P(A|B2)P(B2) + ... + P(A|Bn)P(Bn)，进一步简化公式，用求和符号Σ(西格玛)来进行表示就是：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/4148ec2199e46a3b2cc2089616014365.svg#card=math&amp;amp;code=P%28A%29%20%3D%20%5Csum_%7Bn%3D1%7D%5EnP%28B_n%29P%28A%7CB_n%29%20%20%5C%5C%20&amp;amp;height=57&amp;amp;width=724&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;&lt;p&gt;以上这就是全概率公式和他的推导过程。&lt;/p&gt;
&lt;h3 id=&quot;十-贝叶斯定理&quot;&gt;十 贝叶斯定理&lt;/h3&gt;
&lt;p&gt;上面的章节我们分别学习了简单贝叶斯公式和全概率公式，现在我们把全概率公式A和B做一个互换，可得：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/08006f8d84aeff54a16dd885118dce51.svg#card=math&amp;amp;code=P%28B%29%20%3D%20%5Csum_%7Bn%3D1%7D%5EnP%28A_n%29P%28B%7CA_n%29%20%20%5C%5C%20&amp;amp;height=57&amp;amp;width=724&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;&lt;p&gt;把现在的P(B)带入到简单贝叶斯公式中，并替换P(B)，可得：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/95188e153959aa2dd605b35f1d226355.svg#card=math&amp;amp;code=P%28A%7CB%29%20%3D%20P%28B%7CA%29%20%2A%20P%28A%29%20%2F%20%5Csum_%7Bn%3D1%7D%5EnP%28A_n%29P%28B%7CA_n%29%20%20%20%5C%5C&amp;amp;height=57&amp;amp;width=724&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;&lt;p&gt;这个最终的公式就叫做贝叶斯定理，下面我们用一个经典的题目来练习一下。&lt;br/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;有一种疾病，发病率为千分之一。目前的基因检测技术，只要发病了就一定能够检测到。但如果没有发病的话，其误诊的概率为百分之五。这里我们用阳性代表生病了，这是医院里的检测报告的术语。现在一个人的化验结果呈阳性(结果代表它得病了)，求这个人真实患病的概率。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br/&gt;这道题目的解题思路是，首先我们要列出已知条件：&lt;br/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一个已知条件是这种疾病的发病率为千分之一，那么用可以用P(病)=0.001来表示。&lt;/li&gt;
&lt;li&gt;第二个已知条件是只要发病了就一定能够检测到，那么也就是P(阳性|病)=1，也就是生病了那么其检测结果就是阳性，因为阳性代表着生病。&lt;/li&gt;
&lt;li&gt;第三个条件是误诊率为百分之五，也就是P(阳性|健康)=0.05。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;梳理清楚了三个条件，那么问题是其化验结果呈阳性，其真实的患病概率是多少，其实求的就是P(病|阳性)的值是多少？&lt;br/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;根据简单贝叶斯公式来进行计算一下，也就是P(病|阳性)=P(阳性|病)P(病)/P(阳性)。&lt;/li&gt;
&lt;li&gt;进一步的把P(阳性)换算成全概率公式P(阳性)=P(病)P(阳性|病)+P(健康)P(阳性|健康)。&lt;/li&gt;
&lt;li&gt;最终得到P(病|阳性)=P(阳性|病)P(病)/(P(病)P(阳性|病)+P(健康)P(阳性|健康))&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;br/&gt;P(病|阳性) = 1 * 0.001 / (0.001 * 1 + 0.999 * 0.05) = 0.0196 = 1.96%&lt;/p&gt;&lt;p&gt;这一章到这里就结束了，最后留一个小题目：垃圾邮件筛选&lt;/p&gt;&lt;p&gt;判断邮件标题中包含&quot;购买商品，不是广告&quot;，这样一个邮件是垃圾邮件吗？&lt;br/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;我们通过分词技术已经把&quot;购买商品，不是广告&quot;切分为4个单词，分别是购买、商品、不是、广告。&lt;br/&gt;在已知的数据样本中，共有36封邮件。其中的24封邮件为正常邮件，12封邮件为垃圾邮件。其中正常邮件包含&quot;购买&quot;这个词的有2封，包含&quot;商品&quot;的邮件有4封，包含&quot;不是&quot;的邮件有4封，包含&quot;广告&quot;的邮件有5封。&lt;br/&gt;在垃圾邮件中包含&quot;购买&quot;这个词的有5封，包含&quot;商品&quot;的邮件有3封，包含&quot;不是&quot;的邮件有3封，包含&quot;广告&quot;的邮件有3封。注：一封邮件标题可以包含一个或多个关键词。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br/&gt;问题：判断一封新来的邮件，标题是&quot;购买商品，不是广告&quot;，是正常邮件还是垃圾邮件。&lt;/p&gt;&lt;p&gt;思路提示：求的就是P(&quot;购买商品，不是广告&quot;)P(&quot;正常&quot;)的概率大还是P(&quot;购买商品，不是广告&quot;)P(&quot;垃圾&quot;)的概率大，谁的概率大结果就是谁。&lt;/p&gt;
</description>
<pubDate>Fri, 18 Sep 2020 18:10:00 +0000</pubDate>
<dc:creator>马一特</dc:creator>
<og:description>一 统计学基础运算 1 方差的计算 在统计学中为了观察数据的离散程度，我们需要用到标准差，方差等计算。我们现在拥有以下两组数据，代表着两组同学们的成绩，现在我们要研究哪一组同学的成绩更稳定一些。方差是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mayite/p/13694194.html</dc:identifier>
</item>
<item>
<title>对我来说数据库图形化管理工具用这个足够了 - 码农小胖哥</title>
<link>http://www.cnblogs.com/felordcn/p/13694117.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/felordcn/p/13694117.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1739473/202009/1739473-20200919003836313-1750955981.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-前言&quot;&gt;1. 前言&lt;/h2&gt;
&lt;p&gt;胖哥是一个有软件洁癖的人，能用现有的软件解决问题的绝不安装新的软件。&lt;strong&gt;Java&lt;/strong&gt;后端开发主要跟数据库打交道，所以数据库图形化界面（GUI）是少不了的。通常图形化操作关系型数据库（RMDBS）大多数人会选择&lt;strong&gt;Navicat&lt;/strong&gt;。如果你用的是&lt;strong&gt;Intellij IDEA&lt;/strong&gt;，不管是旗舰版还是社区版，都不需要&lt;strong&gt;Navicat&lt;/strong&gt;了，旗舰版自带数据库图形界面，社区版你可以通过插件集成图形界面。今天就以旗舰版为例演示一下&lt;strong&gt;IDEA&lt;/strong&gt;的数据库图形管理能力。&lt;/p&gt;
&lt;h2 id=&quot;2-idea数据库图形管理&quot;&gt;2. IDEA数据库图形管理&lt;/h2&gt;
&lt;p&gt;在&lt;strong&gt;IDEA&lt;/strong&gt;旗舰版的右侧边栏打开&lt;strong&gt;Database&lt;/strong&gt;就是数据库图形界面了，社区版可以安装插件获得。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1739473/202009/1739473-20200919003836466-1391183765.png&quot; alt=&quot;IDEA数据库图形界面&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击➕号，出现了所有支持的数据库类型的清单，常用的&lt;strong&gt;MySQL&lt;/strong&gt;、&lt;strong&gt;Oracle&lt;/strong&gt;、&lt;strong&gt;PostgreSQL&lt;/strong&gt;、&lt;strong&gt;H2&lt;/strong&gt;、&lt;strong&gt;SQL Server&lt;/strong&gt;都支持，甚至对列式数据库&lt;strong&gt;ClickHouse&lt;/strong&gt;和文档数据库&lt;strong&gt;MongoDB&lt;/strong&gt;也支持。&lt;/p&gt;
&lt;p&gt;选择其中的一种，配置一下就可以了，以&lt;strong&gt;MySQL&lt;/strong&gt;为例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1739473/202009/1739473-20200919003836645-831794310.png&quot; alt=&quot;配置MySQL&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后就进入了图形化界面，你就可以通过图形进行数据库管理了。这个图形界面提供了很多功能，我来演示几个常用的功能。&lt;/p&gt;
&lt;h3 id=&quot;console控制台&quot;&gt;Console控制台&lt;/h3&gt;
&lt;p&gt;我们可以通过console控制台来编写DDL、DML语句来操作数据库。Win下快捷键为 &lt;strong&gt;CTRL+SHIFT+F10&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1739473/202009/1739473-20200919003836801-999583732.png&quot; alt=&quot;Console&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;提供了强大的提示功能、Tx事务类型控制、查看历史语句、多次查询结果对比等功能。而且对于查询的结果展示形式也十分丰富，除了你知道的表格之外还有很多，例如&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1739473/202009/1739473-20200919003836957-1188038282.png&quot; alt=&quot;JSON&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1739473/202009/1739473-20200919003837418-2137379642.png&quot; alt=&quot;XML&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;你可以通过下面的步骤操作来满足你的需要：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1739473/202009/1739473-20200919003837570-680885543.png&quot; alt=&quot;展示类型操作&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;生成代码语句功能&quot;&gt;生成代码语句功能&lt;/h3&gt;
&lt;p&gt;首先可以根据已有数据库来生成DDL语句。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1739473/202009/1739473-20200919003837714-999268821.png&quot; alt=&quot;生成DDL语句&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;根据数据库生成实体类，这个也非常实用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1739473/202009/1739473-20200919003837856-600966430.png&quot; alt=&quot;你可以生成Kotlin和Java两种语言的POJO&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;导入导出功能&quot;&gt;导入导出功能&lt;/h3&gt;
&lt;p&gt;这个几乎所有的数据库GUI都是必备的功能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1739473/202009/1739473-20200919003837972-1690632572.png&quot; alt=&quot;导入和导出&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;语法高亮功能&quot;&gt;语法高亮功能&lt;/h3&gt;
&lt;p&gt;这个功能是一个我选择使用它的根本原因之一，作为开发来说，思维的连贯性非常重要，很多时候我希望在编写&lt;strong&gt;Mybatis Mapper&lt;/strong&gt;时能够快速跳转到数据库、或者实时提示我数据库的相关表、字段信息，帮助你纠错。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1739473/202009/1739473-20200919003838115-1907223331.png&quot; alt=&quot;快速定位到表&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1739473/202009/1739473-20200919003838271-1370122541.png&quot; alt=&quot;Mapper提示&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;讲到这里你是不是蠢蠢欲动要试一试呢？还没有完呢！&lt;/p&gt;
&lt;h2 id=&quot;3-其它数据库插件&quot;&gt;3. 其它数据库插件&lt;/h2&gt;
&lt;p&gt;你甚至还可以通过插件来集成其它类型的数据库，特别是&lt;strong&gt;Redis&lt;/strong&gt;和&lt;strong&gt;Elasticsearch&lt;/strong&gt;这两种。&lt;/p&gt;
&lt;h3 id=&quot;redis&quot;&gt;Redis&lt;/h3&gt;
&lt;p&gt;通过下面这几种插件你可以集成Redis GUI工具了，不用在找半天Redis可视化客户端了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1739473/202009/1739473-20200919003838455-1126534541.png&quot; alt=&quot;Redis GUI 插件&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;elasticsearch&quot;&gt;Elasticsearch&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Elasticsearch&lt;/strong&gt;你也可以可视化的进行操作了，只需要安装免费插件即可：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1739473/202009/1739473-20200919003838620-1684604216.png&quot; alt=&quot;Elasticsearch免费插件&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;4-总结&quot;&gt;4. 总结&lt;/h2&gt;
&lt;p&gt;今天对&lt;strong&gt;IDEA&lt;/strong&gt;的数据库管理GUI进行了归纳，基本可以让你放弃很多其它的管理工具了。有人说吃内存，如果吃内存就集中让一个吃内存不好吗？工具来回切换并不是一个很舒服的事。我是：&lt;strong&gt;码农小胖哥&lt;/strong&gt; 关注我获取更多编程技巧。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;关注公众号：Felordcn 获取更多资讯&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://felord.cn&quot;&gt;个人博客：https://felord.cn&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 18 Sep 2020 16:39:00 +0000</pubDate>
<dc:creator>码农小胖哥</dc:creator>
<og:description>1. 前言 胖哥是一个有软件洁癖的人，能用现有的软件解决问题的绝不安装新的软件。Java后端开发主要跟数据库打交道，所以数据库图形化界面（GUI）是少不了的。通常图形化操作关系型数据库（RMDBS）大</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/felordcn/p/13694117.html</dc:identifier>
</item>
<item>
<title>elasticsearch 索引清理脚本及常用命令 - 钢铁侠的知识库</title>
<link>http://www.cnblogs.com/jiba/p/13694079.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jiba/p/13694079.html</guid>
<description>&lt;p&gt;elastic索引日志清理不及时，很容易产生磁盘紧张，官网给出&lt;code&gt;curl -k -XDELETE&lt;/code&gt;可以清理不需要的索引日志。&lt;/p&gt;
&lt;h2 id=&quot;清理脚本&quot;&gt;清理脚本&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;#!/bin/bash
#Author: 648403020@qq.com
#date: 2019.03.28

# 需要清理几天以前的索引日志
CLEAN_DAY=7

# 获取N天以前的年月日
YEAR=$(date -d &quot;$(date -I) -$CLEAN_DAY&quot;day&quot;&quot; +%Y)
MONTH=$(date -d &quot;$(date -I) -$CLEAN_DAY&quot;day&quot;&quot; +%m)
DAY=$(date -d &quot;$(date -I) -$CLEAN_DAY&quot;day&quot;&quot; +%d)

# 获取需要过滤N天前的ES索引数据
DATA=`curl -sk https://esadmin:your_password@10.124.56.120:9200/_cat/indices?v \
|awk '/[0-9]{4}-[0-9]{2}-[0-9]{2}/ {print $3}' |awk -F- '{s2=mktime($(NF-2)&quot; &quot;$(NF-1)&quot; &quot;$NF&quot; 0 0 0&quot;);\
s1=systime()}{if(s1-s2 &amp;gt;= 86400*&quot;'$CLEAN_DAY'&quot;) print $0}'`

echo &quot;即将清理&quot;$YEAR'-'$MONTH'-'$DAY&quot;前ES索引数据&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&quot;
echo &quot;清理数据为: &quot;$DATA 

# 执行清理工作
for i in $DATA
    do
    sleep 3
    curl -k -XDELETE https://esadmin:your_password@10.124.56.120:9200/$i
done

echo &quot;=======================&quot; 
echo    &quot;执行完成&quot;
echo &quot;=======================&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;添加到任务计划，每天3点执行清理&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;crontab -e
00 03 * * * sh /apps/sh/ESindex_clean_v3.sh &amp;gt; /dev/null 2&amp;gt;&amp;amp;1
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;常用命令&quot;&gt;常用命令&lt;/h2&gt;
</description>
<pubDate>Fri, 18 Sep 2020 16:10:00 +0000</pubDate>
<dc:creator>钢铁侠的知识库</dc:creator>
<og:description>elastic索引日志清理不及时，很容易产生磁盘紧张，官网给出curl -k -XDELETE可以清理不需要的索引日志。 清理脚本 #!/bin/bash #Author: 648403020@qq.</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jiba/p/13694079.html</dc:identifier>
</item>
<item>
<title>native到CPU - eternal_heathens</title>
<link>http://www.cnblogs.com/eternal-heathens/p/13694051.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/eternal-heathens/p/13694051.html</guid>
<description>&lt;ul&gt;&lt;li&gt;所谓的native准确的说是借由虚拟机实现的JNI接口调用的操作系统提供的API&lt;/li&gt;
&lt;li&gt;JNI使得class中的ACC_NATIVE标至的方法能借由JNI类的实例转换为JNI规范（如全限定名）的c实现方法实例（已经由.lib在虚拟机初始化时加载或者借由已经加载的类库的load方法，用java等语言加入内存），该实例会调用本地方法栈中的方法（操作系统提供的API）&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;h、cpp、lib和dll&quot;&gt;.h、.cpp、.lib和.dll&lt;/h2&gt;
&lt;p&gt;.h头文件和.cpp是编译时必须的，lib是链接时需要的，dll是运行时需要的。&lt;/p&gt;
&lt;blockquote readability=&quot;21&quot;&gt;
&lt;p&gt;.h:声明函数接口&lt;/p&gt;
&lt;p&gt;.cpp:c++语言实现的功能源码&lt;/p&gt;
&lt;p&gt;.lib :&lt;/p&gt;
&lt;p&gt;LIB有两种，一种是静态库，比如C-Runtime库，这种LIB中有函数的实现代码，一般用在静态连编上，它是将LIB中的代码加入目标模块(EXE或者DLL)文件中，所以链接好了之后，LIB文件就没有用了。&lt;/p&gt;
&lt;p&gt;一种LIB是和DLL配合使用的，里面没有代码，代码在DLL中，这种LIB是用在静态调用DLL上的，所以起的作用也是链接作用，链接完成了，LIB也没用了。至于动态调用DLL的话，根本用不上LIB文件。 目标模块（EXE或者DLL）文件生成之后，就用不着LIB文件了。&lt;/p&gt;
&lt;p&gt;.dll:&lt;/p&gt;
&lt;p&gt;动态链接库英文为&lt;strong&gt;DLL，是Dynamic Link Library&lt;/strong&gt;的缩写。DLL是一个包含可由多个程序，同时使用的代码和数据的库。&lt;/p&gt;
&lt;p&gt;当程序使用 DLL 时，具有以下的优点： 使用较少的资源，当多个程序使用同一个函数库时，DLL 可以减少在磁盘和物理内存中加载的代码的重复量(运行时需要的库是需要加入内存的)。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;.h和.cpp编译后会生成.lib和.dll 或者 .dll 文件&lt;/p&gt;
&lt;p&gt;我们的程序引用别的文件的函数，需要调用其头文件，但是头文件找到相应的实现有两种方式，一种是同个项目目录下的其他cpp文件（公用性差），一种是链接时的lib文件（静态，lib中自己有实现代码），一种是运行时的dll文件，一种是lib和dll 的结合（动态，lib放索引，dll为具体实现）&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;还要指定编译器链接相应的库文件。在IDE环境下，一般是一次指定所有用到的库文件，编译器自己寻找每个模块需要的库；在命令行编译环境下，需要指定每个模块调用的库。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一般不开源的系统是后面三种方式，因为可以做到接口开放，源码闭合&lt;/p&gt;
&lt;h4 id=&quot;静态链接库&quot;&gt;静态链接库&lt;/h4&gt;
&lt;p&gt;静态链接库(Static Libary，以下简称“静态库”)，静态库是一个或者多个obj文件的打包，所以有人干脆把从obj文件生成lib的过程称为Archive，即合并到一起。比如你链接一个静态库，如果其中有错，它会准确的找到是哪个obj有错，即静态lib只是壳子，但是静态库本身就包含了实际执行代码、符号表等等。&lt;/p&gt;
&lt;p&gt;如果采用静态链接库，在链接的时候会将lib链接到目标代码中,结果便是lib 中的指令都全部被直接包含在最终生成的 EXE 文件中了。&lt;/p&gt;
&lt;p&gt;这个lib文件是静态编译出来的，索引和实现都在其中。&lt;/p&gt;
&lt;p&gt;静态编译的lib文件有好处：给用户安装时就不需要再挂动态库了。但也有缺点，就是导致应用程序比较大，而且失去了动态库的灵活性，在版本升级时，同时要发布新的应用程序才行。&lt;/p&gt;
&lt;h4 id=&quot;动态链接库dll&quot;&gt;动态链接库(DLL)&lt;/h4&gt;
&lt;p&gt;.dll + .lib : 导入库形式，在动态库的情况下，有两个文件，而一个是引入库（.LIB）文件，一个是DLL文件，引入库文件包含被DLL导出的函数的名称和位置，DLL包含实际的函数和数据，应用程序使用LIB文件链接到所需要使用的DLL文件，库中的函数和数据并不复制到可执行文件中，因此在应用程序的可执行文件中，存放的不是被调用的函数代码，而是DLL中所要调用的函数的内存地址，这样当一个或多个应用程序运行是再把程序代码和被调用的函数代码链接起来，从而节省了内存资源。&lt;/p&gt;
&lt;p&gt;从上面的说明可以看出，DLL和.LIB文件必须随应用程序一起发行，否则应用程序将会产生错误。&lt;/p&gt;
&lt;p&gt;.dll形式： 单独的可执行文件形式，因为没有lib 的静态载入，需要自己手动载入，LoadLibary调入DLL文件，然后再手工GetProcAddress获得对应函数了，若是java 会调用System的LoadLibary，但是也是调用JVM中对于操作系统的接口，使用操作系统的LoadLibary等方法真正的将.dll读入内存，再调用生成的相应函数。&lt;/p&gt;
&lt;p&gt;.dll+ .lib和.dll本质上是一样的，只是前者一般用于通用库的预设置，是的我们通过lib直接能查询到.dll文件，不用我们自己去查询，虽会消耗一部分性能，但是实用性很大。.dll 每一个需要到的文件都需自己调用加载命令，容易出错与浪费较多时间（但是我们测试时却可以很快的看出功能实现情况，而且更灵活地调用）&lt;/p&gt;
&lt;h2 id=&quot;jni&quot;&gt;JNI&lt;/h2&gt;
&lt;p&gt;JNI是Java Native Interface的缩写，通过使用 &lt;a href=&quot;https://baike.baidu.com/item/Java/85979&quot;&gt;Java&lt;/a&gt;本地接口书写程序，可以确保代码在不同的平台上方便移植，它允许Java代码和其他语言写的代码进行交互。&lt;/p&gt;
&lt;p&gt;java生成符合JNI规范的C接口文件（头文件）：&lt;/p&gt;
&lt;ol readability=&quot;1.96138996139&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;编写带有native声明的方法的java类&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-0.88095238095238&quot;&gt;
&lt;p&gt;使用&lt;a href=&quot;https://baike.baidu.com/item/javac&quot;&gt;javac&lt;/a&gt;命令编译所编写的java类&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;然后使用javah + java类名生成扩展名为h的头文件&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;使用C/C++实现本地方法&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;将C/C++编写的文件生成动态连接库 （linux gcc windows 可以用VS）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;编写范例：&lt;a href=&quot;https://blog.csdn.net/wzgbgz/article/details/82979728&quot;&gt;https://blog.csdn.net/wzgbgz/article/details/82979728&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;生成的.h的样例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;/* DO NOT EDIT THIS FILE - it is machine generated */
#include &quot;jni.h&quot;
/* Header for class NativeDemo */
 
#ifndef _Included_NativeDemo
#define _Included_NativeDemo
#ifdef __cplusplus
extern &quot;C&quot; {
#endif
/*
 * Class:     NativeDemo
 * Method:    sayHello
 * Signature: ()V
 */
JNIEXPORT void JNICALL Java_NativeDemo_sayHello
  (JNIEnv *, jobject);
 
#ifdef __cplusplus
}
#endif
#endif
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;“jni.h” 是必须要导入的，因为JNIEXPORT等都需要他的支持才行,而且有些方法中需要借助里面的函数。&lt;/p&gt;
&lt;p&gt;Java_NativeDemo_sayHello这样的规范命名是生成的.dll在被操作系统dlopen读取入内存时返回的handle能经由dlsym截取出正确的函数名，他可能将xxx.dll全都加载入内存，放入一个handle或者一个handle集合中，这时就需要包的全限定类名来确定到底获取的是handle中的哪个方法了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;jnienv-，jobject-，jclass&quot;&gt;&lt;strong&gt;JNIEnv&lt;/strong&gt; &lt;strong&gt;，jobject&lt;/strong&gt; &lt;strong&gt;，jclass&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1. JNIEnv&lt;/strong&gt;类实际代表了Java环境，通过这个JNIEnv 指针，就可以对Java端的代码进行操作。例如，创建Java类的对象，调用Java对象的方法，获取Java对象的属性等等，JNIEnv的指针会被JNI传入到本地方法的实现两数中來对Java端的代码进行操作。&lt;/p&gt;
&lt;p&gt;JNIEnv类中有很多函数用可以用如下所示其中：TYPE代表属性或者方法的类型（比如：int float double byte ......）&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;1.NewObject/NewString/New&amp;lt;TYPE&amp;gt;Array
2.Get/Set&amp;lt;TYPE&amp;gt;Field
3.Get/SetStatic&amp;lt;TYPE&amp;gt;Field
4.Call&amp;lt;TYPE&amp;gt;Method/CallStatic&amp;lt;TYPE&amp;gt;Method等许许多多的函数
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2.&lt;/strong&gt; &lt;strong&gt;jobject&lt;/strong&gt;代表了在java端调用本地c/c++代码的那个类的一个实例（对象）。在修改和调用java端的属性和方法的时候，用jobject 作为参数，代表了修改了jobject所对应的java端的对象的属性和方法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. jclass&lt;/strong&gt; : 为了能够在c/c++中使用java类,JNI.h头文件中专门定义了jclass类型来表示java中的Class类&lt;/p&gt;
&lt;p&gt;JNIEvn中规定可以用以下几个函数来取得jclass&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1.jclass FindClass(const char* clsName) ;
2.jclass GetObjectClass(jobject obj);
3.jclass GetSuperClass(jclass obj);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;jni原理&quot;&gt;JNI原理&lt;/h2&gt;
&lt;p&gt;我们编译xxx.h和xxx.cpp生成了dll文件，运行java文件JNI会帮我们调用dll中的方法， 但是java对象是如何具体调用他的我们不清楚&lt;/p&gt;
&lt;p&gt;我们自己实现的dll需要大概如下的模板：&lt;/p&gt;
&lt;p&gt;Test.java&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package hackooo;
public class Test{
        static{
                // java层调用.dll文件进入内存，但是底层仍是由虚拟机调用JNI用C实现对操作系统的提供的接口加载入内存
                System.loadLibrary(&quot;bridge&quot;);
        }
        public native int nativeAdd(int x,int y);
        public int add(int x,int y){
                return x+y;
        }
        public static void main(String[] args){
                Test obj = new Test();
                System.out.printf(&quot;%d\n&quot;,obj.nativeAdd(2012,3));
                System.out.printf(&quot;%d\n&quot;,obj.add(2012,3));
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们需要先看到System.loadLibrary(&quot;bridge&quot;)的作用&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@CallerSensitive
public static void loadLibrary(String libname) {
    // Runtime类是Application进程的建立后，用来查看JVM当前状态和控制JVM行为的类
    // Runtime是单例模式，且只能用静态getRuntime获取，不能实例化
    // 其中load是加载动态链接库的绝对路径方法
    // loadLibrary是读取相对路径的，动态链接库需要在java.library.path中，一般为系统path，也可以设置启动项的 -VMoption
    // 通过ClassLoader.loadLibrary0(fromClass, filename, true);中的第三个参数判断
    Runtime.getRuntime().loadLibrary0(Reflection.getCallerClass(), libname);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;java.lang.Runtime&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt; @CallerSensitive
    public void loadLibrary(String libname) {
        loadLibrary0(Reflection.getCallerClass(), libname);
    }

    synchronized void loadLibrary0(Class&amp;lt;?&amp;gt; fromClass, String libname) {
        SecurityManager security = System.getSecurityManager();
        if (security != null) {
            security.checkLink(libname);
        }
        if (libname.indexOf((int)File.separatorChar) != -1) {
            throw new UnsatisfiedLinkError(
    &quot;Directory separator should not appear in library name: &quot; + libname);
        }
        // false，调用相对路径
        ClassLoader.loadLibrary(fromClass, libname, false);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;java.lang.ClassLoader&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;static void loadLibrary(Class&amp;lt;?&amp;gt; fromClass, String name,
                        boolean isAbsolute) {
    // 通过方法区中的class类找到相应的类加载器
    ClassLoader loader =
        (fromClass == null) ? null : fromClass.getClassLoader();
    if (sys_paths == null) {
        // 加载的绝对路径
        // 系统环境变量
        usr_paths = initializePath(&quot;java.library.path&quot;);
        // 我们启动时加入的依赖项
        sys_paths = initializePath(&quot;sun.boot.library.path&quot;);
    }
    if (isAbsolute) {
        // 若是决定路径，调用真正的执行方法
        if (loadLibrary0(fromClass, new File(name))) {
            return;
        }
        throw new UnsatisfiedLinkError(&quot;Can't load library: &quot; + name);
    }
    if (loader != null) {
        // 判断当前类加载器及其双亲是否有该lib的类信息
        String libfilename = loader.findLibrary(name);
        if (libfilename != null) {
            File libfile = new File(libfilename);
            if (!libfile.isAbsolute()) {
                throw new UnsatisfiedLinkError(
&quot;ClassLoader.findLibrary failed to return an absolute path: &quot; + libfilename);
            }
            if (loadLibrary0(fromClass, libfile)) {
                return;
            }
            throw new UnsatisfiedLinkError(&quot;Can't load &quot; + libfilename);
        }
    }
    // 查询sys_paths路径下是否有.dll文件
    for (int i = 0 ; i &amp;lt; sys_paths.length ; i++) {
        File libfile = new File(sys_paths[i], System.mapLibraryName(name));
        if (loadLibrary0(fromClass, libfile)) {
            return;
        }
        libfile = ClassLoaderHelper.mapAlternativeName(libfile);
        if (libfile != null &amp;amp;&amp;amp; loadLibrary0(fromClass, libfile)) {
            return;
        }
    }
    // 查询usr_paths路径下是否有.dll文件
    if (loader != null) {
        for (int i = 0 ; i &amp;lt; usr_paths.length ; i++) {
            File libfile = new File(usr_paths[i],
                                    System.mapLibraryName(name));
            if (loadLibrary0(fromClass, libfile)) {
                return;
            }
            libfile = ClassLoaderHelper.mapAlternativeName(libfile);
            if (libfile != null &amp;amp;&amp;amp; loadLibrary0(fromClass, libfile)) {
                return;
            }
        }
    }
    // Oops, it failed
    throw new UnsatisfiedLinkError(&quot;no &quot; + name + &quot; in java.library.path&quot;);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private static boolean loadLibrary0(Class&amp;lt;?&amp;gt; fromClass, final File file) {
    // Check to see if we're attempting to access a static library
    // 查看是否调用的lib为静态链接库
    String name = findBuiltinLib(file.getName());
    boolean isBuiltin = (name != null);
    // 若是静态链接库则跳过，否则获取file的路径
    if (!isBuiltin) {
        boolean exists = AccessController.doPrivileged(
            new PrivilegedAction&amp;lt;Object&amp;gt;() {
                public Object run() {
                    return file.exists() ? Boolean.TRUE : null;
                }})
            != null;
        if (!exists) {
            return false;
        }
        try {
            name = file.getCanonicalPath();
        } catch (IOException e) {
            return false;
        }
    }
    ClassLoader loader =
        (fromClass == null) ? null : fromClass.getClassLoader();
    // 
    Vector&amp;lt;NativeLibrary&amp;gt; libs =
        loader != null ? loader.nativeLibraries : systemNativeLibraries;
    synchronized (libs) {
        int size = libs.size();
        for (int i = 0; i &amp;lt; size; i++) {
            NativeLibrary lib = libs.elementAt(i);
            if (name.equals(lib.name)) {
                return true;
            }
        }

        synchronized (loadedLibraryNames) {
            if (loadedLibraryNames.contains(name)) {
                throw new UnsatisfiedLinkError
                    (&quot;Native Library &quot; +
                     name +
                     &quot; already loaded in another classloader&quot;);
            }
            /* If the library is being loaded (must be by the same thread,
             * because Runtime.load and Runtime.loadLibrary are
             * synchronous). The reason is can occur is that the JNI_OnLoad
             * function can cause another loadLibrary invocation.
             *
             * Thus we can use a static stack to hold the list of libraries
             * we are loading.
             *
             * If there is a pending load operation for the library, we
             * immediately return success; otherwise, we raise
             * UnsatisfiedLinkError.
             */
            //如果我们突然发现library已经被加载，可能是我们执行一半被挂起了或者其他线程在synchronized前也调用了该classLoader，执行JNI_OnLoad又一次调用了启用了同个线程中过的另一个loadLibrary方法，加载了我们的文件
            //之所以是同个线程中的，因为run一个application对应一个java.exe/javaw.extin进程，一个JVM实例，一个Runtime实例，且其是实现了synchronized的。
            // 查看此时nativeLibraryContext中存储了什么
            int n = nativeLibraryContext.size();
            for (int i = 0; i &amp;lt; n; i++) {
                NativeLibrary lib = nativeLibraryContext.elementAt(i);
                if (name.equals(lib.name)) {
                    if (loader == lib.fromClass.getClassLoader()) {
                        return true;
                    } else {
                        throw new UnsatisfiedLinkError
                            (&quot;Native Library &quot; +
                             name +
                             &quot; is being loaded in another classloader&quot;);
                    }
                }
            }
            NativeLibrary lib = new NativeLibrary(fromClass, name, isBuiltin);
            nativeLibraryContext.push(lib);
            try {
                // 尝试加载
                lib.load(name, isBuiltin);
            } finally {
                nativeLibraryContext.pop();
            }
            if (lib.loaded) {
                // 加入已加载Vetor中
                loadedLibraryNames.addElement(name);
                libs.addElement(lib);
                return true;
            }
            return false;
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;native void load(String name, boolean isBuiltin);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后的load是虚拟机中实现的方法（用来加载我们自己要加入的.dll的），我们通过调用他来调用操作系统的API来真正将其放入内存&lt;/p&gt;
&lt;p&gt;而那些已经编译好的库函数，虚拟机初始化时就调用LoadLibrary（Linux是dlopen）等操作系统API（本地方法栈）加入了内存中&lt;/p&gt;
&lt;p&gt;(windows的)LoadLibrary与dlopen原理相似，若是还未加载过的dll，会调用相关方法，windows会用DLL_PROCESS_ATTACH调用&lt;a href=&quot;https://docs.microsoft.com/en-us/windows/desktop/Dlls/dllmain&quot;&gt;DllMain&lt;/a&gt; 方法，若是成功则返回一个handle对象可以调用&lt;strong&gt;GetProcAddress&lt;/strong&gt;（linux 为dlsym）获得函数进行使用。&lt;/p&gt;
&lt;p&gt;load是在jVM初始化就加载了lib文件，通过jvm.h就能通过该lib找到调用的函数的入口，调用相应的.dll二进制文件&lt;/p&gt;
&lt;p&gt;LoadLibrary是操作系统初始化时加载的windows.lib加载入内存的，我们需要调用windows.h文件，调用该函数的.dll入内存（延迟加载的话）&lt;/p&gt;
&lt;p&gt;我们java中的native方法的实现和到此时load便接轨了，我们来看看native如何被解析的&lt;/p&gt;
&lt;p&gt;编译：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;javac hackooo/Test.java
javap -verbose hackooo.Test
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Test.class:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;  public native int nativeAdd(int, int);
    flags: ACC_PUBLIC, ACC_NATIVE

  public int add(int, int);
    flags: ACC_PUBLIC
    Code:
      stack=2, locals=3, args_size=3
         0: iload_1       
         1: iload_2       
         2: iadd          
         3: ireturn       
      LineNumberTable:
        line 8: 0
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;普通的“add”方法是直接把字节码放到code属性表中，而native方法，与普通的方法通过一个标志“ACC_NATIVE”区分开来。java在执行普通的方法调用的时候，可以通过找方法表，再找到相应的code属性表，最终解释执行代码，那么，对于native方法，在class文件中，并没有体现native代码在哪里，只有一个“ACC_NATIVE”的标识，那么在执行的时候改怎么找到动态链接库的代码呢？&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;到了这一步，我们就需要开始钻研JVM到底运行逻辑是什么了&lt;/p&gt;
&lt;p&gt;刚开始时，我们通过javac 编译一个xxx.java 成一个字节码文件,javac进行前端编译时包括了词法分析,语法分析生成抽象语法树,在生成字节码指令流(编译期)后交由解释器/即时编译器进行解释/编译优化(运行期)&lt;/p&gt;
&lt;p&gt;然后用java xxx 命令在操作系统中初始化一个进程,这个进程为我们分配了一块内存空间,我们开始新建一个JVM(或者说是JRE)在该内存中并进行初始化(该步骤是操作系统通过java这个命令(其为windows的一个脚本),调用其他系统命令将我们预先编译好的二进制指令集放入CPU运行生成)&lt;/p&gt;
&lt;p&gt;虚拟机的实例创建好后,java脚本的最后一条命令便是执行JVM中的main方法,jvm会帮我们创建BoostrapClassLoader,其是用C实现的,并不符合加入class区后的实例化流程,因此我们的java代码并不能引用他,创建完他后,BoostrapClassLoader会帮我们将一些jdk的核心class文件通过它加载入方法区中,紧接着JVM会通过launcher的c实现通过JNI(还需看源码确定是不是这样,JNI是JVM初始化时创建的?不在JVM运行时区域中,在执行引擎中),依据导入java实现的Launcher的class信息通过帮我们创建sun.misc.Launcher对象并初始化(单例),他的创建还会伴随着ExtClassLoader的初始化和appClassLoader的创建(三层和双亲),这里涉及类的加载过程.&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;更好的了解java实现的ClassLoaderhttps://blog.csdn.net/briblue/article/details/54973413&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接着,线程会默认调用APPClassLoader帮我们将命令中的 xxx参数的class装入方法区(之所以要通过classLoader来加载是为了只在需要时我们加载类,而不是全部加载,节约内存空间,而这里加载的class不止硬盘,只要是二进制字节流就可以),并为main函数在java栈中预留一个栈帧,经生成的后端编译器的实例进行字节码的解释执行优化和编译优化代替执行(后端编译器大部分既有解释器又有编译器参数设置,决定如何编译优化).&lt;/p&gt;
&lt;p&gt;从APPClassLader将class装入方法区开始,就是类的加载过程了&lt;/p&gt;
&lt;p&gt;具体流程是&lt;/p&gt;
&lt;ol readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;7.5&quot;&gt;
&lt;p&gt;加载(既可以由JVM本身加载入方法区,也可自定义的classLoder选取需要加载的class,通过JNI调用)&lt;/p&gt;
&lt;blockquote readability=&quot;14&quot;&gt;
&lt;p&gt;通过一个类的全限定类名来获取定义此类的二进制字节流&lt;/p&gt;
&lt;p&gt;将这个字节流所代表的静态结构转化为方法区的运行时数据结构&lt;/p&gt;
&lt;p&gt;在内存（堆）中生成一个代表这个类的java.lang.Class对象,作为方法区这个类的各种数据的访问入口（单例模式）&lt;/p&gt;
&lt;p&gt;至于什么时候加载，除了遇到new、getstatic、putstatic、invokestatic四条指令时，必须立刻加载··到初始化完成&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;7.5&quot;&gt;
&lt;p&gt;验证(java源码本身的编译是相对安全的,但是字节码的内容可能会加入恶意代码,因此需要验证)&lt;/p&gt;
&lt;blockquote readability=&quot;14&quot;&gt;
&lt;p&gt;文件格式验证(字节流的各个部分划分是否符合规范)&lt;/p&gt;
&lt;p&gt;元数据验证(对元数据信息中的数据类型检验)&lt;/p&gt;
&lt;p&gt;字节码校验(对方法体中的内容进行校验,较为复杂耗时,jdk6后可以将权重部分移向了javac)&lt;/p&gt;
&lt;p&gt;符号引用校验(在解析阶段同时进行)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;准备&lt;/p&gt;
&lt;blockquote readability=&quot;23&quot;&gt;
&lt;p&gt;正式为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值的阶段。从概念上讲，这些变量所使用的内存都应当在方法区中进行分配，但需要注意的是方法区本身是一个逻辑层面的概念，其实现在不同的版本，不同的虚拟机上可能分布在不同的内存空间，如同JMM之于JVM一般&lt;/p&gt;
&lt;p&gt;jdk 8之前，HotSpot团队选择把收集器的分代扩展至方法区，由垃圾收集器统一收集，省去专门写一个独立的管理方法区的方法，而方法区的存储内容与前面的分代的更新换代条件大不相同，所以专门划分了个永久代，但这容易导致更多的内存溢出问题&lt;/p&gt;
&lt;p&gt;jdk6hotspot就将舍弃永久代放进了发展策略，逐步改用成了用直接内存（Direct Memory）中的元空间等来存储方法区的内容，实现单独的回收管理，&lt;/p&gt;
&lt;p&gt;jdk7已经将字符串常量池、静态变量等移出，jdk8以全部移出&lt;/p&gt;
&lt;p&gt;jdk8 时类变量会随着Class对象一起存放到Java堆中，类型信息则放到了直接内存中了。&lt;/p&gt;
&lt;p&gt;图网上找的（其中类信息也称为静态常量池）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2xlaXl1MTk5Ny9QaWNCZWRAbWFzdGVyL2Jsb2dzL3BpY3R1cmVzL2phdmElRTUlODYlODUlRTUlQUQlOTglRTclQkIlOTMlRTYlOUUlODQucG5n?x-oss-process=image/format,png&quot; alt=&quot;java内存结构&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;40&quot;&gt;
&lt;p&gt;解析&lt;/p&gt;
&lt;blockquote readability=&quot;89&quot;&gt;
&lt;p&gt;解析阶段是java虚拟机将常量池内的符号引用（存放在方法区的常量池中）替换为直接引用（我们当初在堆中创建的Class对象的具体内存地址）的过程，即将我们最初的ACC_NATIVE等字面量进替换。&lt;/p&gt;
&lt;p&gt;加载阶段只是将字节码按表静态翻译成字节码对应的表示按约定大小划分入内存中，常量池中只存放字面量并被翻译的方法表中的方法引用作为所存储内存的部分信息保存，只有在解析阶段才专门将常量池中的字符引用依据Class对象中分出的各个内存中预先存储的部分信息匹配返回地址换成直接引用。放入运行时常量池直接调用&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;至jdk13常量池中存有 17类常量表，每一个tag用u1长度（两个字节）代表一类常量表，对应的常量表中规定了后面需要读取多少字节分别，分为几个部分代表哪些东西。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们需要了解一份class文件大概有哪些信息（xx信息便是xx表集合）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2017476/202009/2017476-20200919000016594-1837082281.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;解析可以发生在任何时间，包括运行时再被确定也是可能的，只要求了在执行anewarray，checkcast, getfield, getstatic, instanceof, invokedynamic, invokeinterface, invokespecial, 等17个用于操作符号引用的字节码指令之前，需要对他们所使用的符号引用进行解析&lt;/p&gt;
&lt;p&gt;符号引用可以将第一次的解析结果进行缓存，如在运行时直接引用常量池中的记录。不过对于invokedynamic指令，上面的规则就不使用了，它要求程序在解释器基于栈或者编译器基于寄存器解读方法时实际运行到这条指令时，解析动作才能进行。&lt;/p&gt;
&lt;p&gt;解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符这七类&lt;/p&gt;
&lt;p&gt;分别对应CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info、CONSTANT_InterfaceMethodref_info，这前四种基本都是在解析时便可以替换为直接引用&lt;/p&gt;
&lt;p&gt;CONSTANT_MethodType_info、CONSTANT_MethodHandle_info、CONSTANT_Dynamic_info和CONSTANT_InvokeDynamic_info&lt;/p&gt;
&lt;p&gt;这四种于动态语言联系紧密，为此我们需要明白解析与分派的区别&lt;/p&gt;
&lt;p&gt;先从前四种开始说起&lt;/p&gt;
&lt;p&gt;我们前面的8个符号引用，分别有自己单独的常量表，其中记录了去往哪查询自己的代码的索引值，去调用字段表和方法表中对于字段和方法的定义&lt;/p&gt;
&lt;p&gt;编译器通过方法区预存的常量表解读了class文件中的字节码中的各个常量，创建了常量池，但是常量池中的存储仍是依据字面量的索引，由字面量项保存了一些字面量实现的信息，并没有真正的内存保留他，而我们的字段表，方法表等依据name_index引用常量池中的常量项，但他们只保存声明的部分，至于初始化和方法体的实现，常常是放置在code中，code一般会在字段表或方法表的后面&lt;/p&gt;
&lt;p&gt;而我们的解析的作用就是将如CONSTANT_Class_info的字符引用找到字面量记录的全限定类名交由classLoader加载（加载阶段已扫描过一遍字段表、方法表等并已创建出了Class对象在堆中存放了静态的数据接口）&lt;/p&gt;
&lt;p&gt;将字段表中的对于CONSTANT_Fieldref_info存储的索引的字面量的读取出的简单名称和字段描述符去匹配class_index中由类加载器加载出来的类是否有相应字段，有则返回直接引用&lt;/p&gt;
&lt;p&gt;方法解析与接口方法解析也是与字段大致一样的查询逻辑，但是都只是找到了方法的入口，并非实现了其中的代码 ，这时候我们可以思考一下native的直接引用的地址是哪里呢，个人认为此时已经是相应的javah实现的.h文件的实现cpp了（还不知道如何调试查看）&lt;/p&gt;
&lt;p&gt;而到了方法调用阶段，则需要依据方法类型来判断方法是在编译期可知，运行期不可变还是依据分派配合动态语言进行解析&lt;/p&gt;
&lt;p&gt;方法的调用并不如同字段、方法等的入口等将字符引用换成直接引用保存一个入口就可，而是依据code中的字节码转换成相应的指令命令，使得引用时可以直接调用指令进行方法的执行，其中jvm若是解释执行，则是依据操作栈来进行字节码指令的运作的通过调用操作系统对CPU操作的API来实现功能，若是基于编译后实现的寄存器的，则是直接交由寄存器硬件实现的指令集执行（如x86）.&lt;/p&gt;
&lt;p&gt;而如何执行code中的指令，就需要方法类型的区分，其也是依据字节码指令来的：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;invokestatic 用于调用静态方法&lt;/li&gt;
&lt;li&gt;invokespecial 用于调用实例构造器()方法、私有方法、父类中的方法&lt;/li&gt;
&lt;li&gt;invokevirtual 用于调用所有的虚方法&lt;/li&gt;
&lt;li&gt;invokeinterface 用于调用接口方法，会在运行时再确定一个实现该接口的对象&lt;/li&gt;
&lt;li&gt;invokedynamic 现在运行时动态解析出调用点限定符所引用的方法，然后在执行该方法&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;其中invokestatic喝invokespecial是在符合运行时指令集是固定的（包括1和2的四种和final，final是用invokevirtual实现，但是因为不可修改），因此可以直接将其依据相应表解析成指令集后放入堆中Class实例的内存中（class对象时读取方法表等），并返回地址将字符引用改为直接引用，这种方法称为非虚方法（当我们将常量池的字符引用解析到属性表集合时&lt;/p&gt;
&lt;p&gt;而其他方法称为虚方法（如：Code），不像前面的静态类型直接就去查看Class实例是否有匹配返回地址，而是需要依据上面的五个指针类型进行是否直接查找直接引用还是其他的实现再返回地址作为直接引用）&lt;/p&gt;
&lt;p&gt;而虚方法需要依靠分派调用（重载与重写）&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;静态分派（重载）&lt;/li&gt;
&lt;li&gt;动态分派（重写）&lt;/li&gt;
&lt;li&gt;单分派与多分派&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;为了提高动态分派效率，我们还专门在方法区中建立了虚方法表&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;最后便是初始化，用,收敛初始化类变量等，&amp;lt;其中client 会经常调用，准备阶段的初始化是系统变量的默认值，这里是我们自定义的&amp;gt;将运行权重转移到程序本身的code实现上&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我们已经知道我们在加载阶段就在堆中实现了Class，使得我们能后续能为常量池中的常量项进行解析，最后会将解析后的常量池放到运行时常量池中进行调用&lt;/p&gt;
&lt;p&gt;通过 我们开始依据运行时常量池中的方法顺序依据直接引用的地址调用code中的字节码指令（此时，无论是哪种指令集，指令集只是我们将二进制按位数划分助记而已，已经都是0101这种cpu能解读的模式了，但都需要按照（操作码字段|地址码字段）来传送给CPU，不同的指令集只是将二进制串划分成不同的段交给CPU，CPU所能读取指令长度会依据指令的操作码判断是几地址指令，比如add它可以有00，01，10，11 分别表示1234地址指令）&lt;/p&gt;
&lt;p&gt;若是基于栈的解释执行，我们会依据各个方法创建栈帧，并用栈帧中的操作数栈实现字节码指令对操作系统对于CPUapi的调用运行code中的字节码指令，而字节码指令基本上都是零地址指令（他会对指令的读取和数值的取出读入等由几个固定栈结构进行操作）。若是经过编译的，则是依据编译器，则依据寄存器的硬件实现的指令集进行解读。两者的不同主要在运行时前者需要将操作数出栈计算再入栈保存，而后者则可以在cpu计算后直接保存回寄存器操作数地址的位置上。&lt;/p&gt;
&lt;p&gt;无论是c还是java，都是最后都是经过CPU对内存中某个内存地址那一部分的存储值依据指令集进行修改，jni也不过是起到使得c方法编译后的指令集的地址查询能符合java地址直接引用的规则，而其会将入口地址放入lib中使得能通过c中的表查询到入口（c入口地址都通过链接写到了lib中，而java的虚方法还接收者需要运行时根据实际类型选择版本等），因此无论是JNI中java对于C对象的调用还是c对于java对象的调用，只要有相应的地址，源码编译成的相应的指令集都可以实现对不同语言对象的操作，操作系统也无外乎用自己实现的指令集组合用cpu修改其他各个硬件的电平状态来达到控制所有硬件各种语言的目的。&lt;/p&gt;
&lt;p&gt;而解释器和编译器通过操作数栈或者寄存器都调用系统API的实现，都是基于执行引擎调用该些后端编译器进行的，等javac自己加上去的方法会调用执行引擎依据自己的实现选择使用上两者。&lt;/p&gt;
&lt;p&gt;执行引擎是我们与操作系统交互的最直接的部分,我们最后将class类加入方法区后并不是就可以直接加入对JVM的其他结构,而是需要执行引擎使用后端编译器进行解释编译时,javac输出的字节码指令流,基本上是一种基于栈的指令集结构,是解释器和即时编译器运行优化的方式,是基本将中间码在JVM栈上运行的,由栈保存值的,&lt;/p&gt;
&lt;p&gt;而提前编译编译后的或者即时编译后的直接的二进制文件,则是多基于寄存器直接实现(如x86的二地址指令集),但若是源码启动,需要你的程序刚开始需要较长的时间去编译,若是二进制版本的,则需要为每一个指令集专门编译一个版本而且也不一定完全适配,效率也没有源码编译的更快(但其实相差无几)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们这时候也不难想象ACC_NATIVE是如何通过本地方法栈找到对c方法地址的直接引用放入运行时常量池中，调用方法时java栈通过操作数栈找到虚拟机c的方法指令的位置（而其中多是对操作系统API的调用），将方法中的指令经由CPU（用户线程）计算结果传给操作系统API（也是地址，再调用操作系统实现的指令，至于是直接汇编语言编译结果还是高级语言的编译结果就不得而知了），操作系统将自身编译的指令送入CPU计算，返回我们想要的结果的了，到了这一步我终于明白为什么知道面试官为什么喜欢懂得操作系统内核的了，因为操作系统中实现了很多如网络，shell显示，IO的，其中的API就是相应实现后编译的指令集的入口，而且要考虑很多的优化和并发，其中特别是要自己实现用户线程去调用CPU还是要自己的用户线程调用操作系统的API经过操作系统的内核线程使用CPU，线程调用CPU后得到的运算结果，要自己去调用IO等还是回操作系统的API实现都是很复杂的需要考虑编译器能否实现准确的编译后能否适配的，还需要借助汇编语言来查看调试优化，太难了&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;3&quot;&gt;
&lt;p&gt;本地方法栈和操作系统的关系可以参考：&lt;a href=&quot;https://blog.csdn.net/yfqnihao/article/details/8289363&quot;&gt;https://blog.csdn.net/yfqnihao/article/details/8289363&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 18 Sep 2020 15:55:00 +0000</pubDate>
<dc:creator>eternal_heathens</dc:creator>
<og:description>Native 所谓的native准确的说是借由虚拟机实现的JNI接口调用的操作系统提供的API JNI使得class中的ACC_NATIVE标至的方法能借由JNI类的实例转换为JNI规范（如全限定名）</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/eternal-heathens/p/13694051.html</dc:identifier>
</item>
<item>
<title>实战-电力窃露漏电用户自动识别 - 西西嘛呦</title>
<link>http://www.cnblogs.com/xiximayou/p/13682052.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiximayou/p/13682052.html</guid>
<description>&lt;p&gt;问题描述：判断用户是否窃漏电&lt;/p&gt;
&lt;p&gt;问题解决：二分类问题&lt;/p&gt;
&lt;p&gt;缺失值：拉格朗日插值法进行填充&lt;/p&gt;
&lt;p&gt;使用的特征：电量趋势下降指标、线损指标、警告类指标&lt;/p&gt;
&lt;p&gt;这里使用的数据来&lt;strong&gt;&amp;lt;python数据分析与实战第六章&amp;gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数据：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503039/202009/1503039-20200916203100160-3091461.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码实现：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、加载数据&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; pandas as pd
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; random &lt;span&gt;import&lt;/span&gt;&lt;span&gt; shuffle

datafile &lt;/span&gt;= path + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;chapter6/model.xls&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
data &lt;/span&gt;= pd.read_excel(datafile)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2、划分训练集和测试集&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;data = data.as_matrix() 旧版本的pandas是这么使用的，将dataframe转换为矩阵&lt;/span&gt;
data = data.iloc[:,:].values &lt;span&gt;#&lt;/span&gt;&lt;span&gt;新版本这么使用&lt;/span&gt;
&lt;span&gt;shuffle(data)

p &lt;/span&gt;= 0.8 &lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置训练数据比例&lt;/span&gt;
train = data[:int(len(data)*&lt;span&gt;p),:]
test &lt;/span&gt;= data[int(len(data)*p):,:]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3、使用keras定义模型&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; keras.models &lt;span&gt;import&lt;/span&gt; Sequential &lt;span&gt;#&lt;/span&gt;&lt;span&gt;导入神经网络初始化函数&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; keras.layers.core &lt;span&gt;import&lt;/span&gt; Dense, Activation &lt;span&gt;#&lt;/span&gt;&lt;span&gt;导入神经网络层函数、激活函数&lt;/span&gt;
&lt;span&gt;
netfile &lt;/span&gt;= path + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;chapter6/net.model&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;构建的神经网络模型存储路径&lt;/span&gt;
&lt;span&gt;
net &lt;/span&gt;= Sequential() &lt;span&gt;#&lt;/span&gt;&lt;span&gt;建立神经网络&lt;/span&gt;
net.add(Dense(3, 10)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;添加输入层（3节点）到隐藏层（10节点）的连接&lt;/span&gt;
net.add(Activation(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;relu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;隐藏层使用relu激活函数&lt;/span&gt;
net.add(Dense(10, 1)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;添加隐藏层（10节点）到输出层（1节点）的连接&lt;/span&gt;
net.add(Activation(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sigmoid&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;输出层使用sigmoid激活函数&lt;/span&gt;
net.compile(loss = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;binary_crossentropy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, optimizer = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;adam&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, class_mode = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;binary&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;编译模型，使用adam方法求解&lt;/span&gt;
&lt;span&gt;
net.fit(train[:,:&lt;/span&gt;3], train[:,3], nb_epoch=100, batch_size=1) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;训练模型，循环100次&lt;/span&gt;
net.save_weights(netfile) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;保存模型&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于keras版本导致的错误：&lt;/p&gt;
&lt;p&gt;常见错误（均是因为keras版本改动）&lt;/p&gt;
&lt;p&gt;修改后的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; keras.models &lt;span&gt;import&lt;/span&gt; Sequential &lt;span&gt;#&lt;/span&gt;&lt;span&gt;导入神经网络初始化函数&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; keras.layers.core &lt;span&gt;import&lt;/span&gt; Dense, Activation &lt;span&gt;#&lt;/span&gt;&lt;span&gt;导入神经网络层函数、激活函数&lt;/span&gt;
&lt;span&gt;
netfile &lt;/span&gt;= path + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;chapter6/net.model&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;构建的神经网络模型存储路径&lt;/span&gt;
&lt;span&gt;
net &lt;/span&gt;= Sequential() &lt;span&gt;#&lt;/span&gt;&lt;span&gt;建立神经网络&lt;/span&gt;
net.add(Dense(input_dim=3, units=10)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;添加输入层（3节点）到隐藏层（10节点）的连接&lt;/span&gt;
net.add(Activation(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;relu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;隐藏层使用relu激活函数&lt;/span&gt;
net.add(Dense(input_dim=10, units=1)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;添加隐藏层（10节点）到输出层（1节点）的连接&lt;/span&gt;
net.add(Activation(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sigmoid&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;输出层使用sigmoid激活函数&lt;/span&gt;
net.compile(loss = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;binary_crossentropy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, optimizer = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;adam&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;编译模型，使用adam方法求解&lt;/span&gt;
&lt;span&gt;
net.fit(train[:,:&lt;/span&gt;3], train[:,3], epochs=100, batch_size=1) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;训练模型，循环100次&lt;/span&gt;
net.save_weights(netfile) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;保存模型&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;部分结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Epoch &lt;/span&gt;97/100
232/232 [==============================] - 1s 3ms/step - loss: 0.3171&lt;span&gt;
Epoch &lt;/span&gt;98/100
232/232 [==============================] - 1s 3ms/step - loss: 0.3196&lt;span&gt;
Epoch &lt;/span&gt;99/100
232/232 [==============================] - 1s 3ms/step - loss: 0.3194&lt;span&gt;
Epoch &lt;/span&gt;100/100
232/232 [==============================] - 1s 3ms/step - loss: 0.3144
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们也可以训练时加入更多的评价指标：（二分类指标）&lt;/p&gt;
&lt;p&gt;具体的评价指标的使用可参考文档：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://keras.io/api/metrics/classification_metrics/#precision-class&quot; target=&quot;_blank&quot;&gt;https://keras.io/api/metrics/classification_metrics/#precision-class&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; tensorflow as tf
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;精确率评价指标&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; keras.models &lt;span&gt;import&lt;/span&gt; Sequential &lt;span&gt;#&lt;/span&gt;&lt;span&gt;导入神经网络初始化函数&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; keras.layers.core &lt;span&gt;import&lt;/span&gt; Dense, Activation &lt;span&gt;#&lt;/span&gt;&lt;span&gt;导入神经网络层函数、激活函数&lt;/span&gt;
&lt;span&gt;
netfile &lt;/span&gt;= path + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;chapter6/net.model&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;构建的神经网络模型存储路径&lt;/span&gt;
&lt;span&gt;
net &lt;/span&gt;= Sequential() &lt;span&gt;#&lt;/span&gt;&lt;span&gt;建立神经网络&lt;/span&gt;
net.add(Dense(input_dim=3, units=10)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;添加输入层（3节点）到隐藏层（10节点）的连接&lt;/span&gt;
net.add(Activation(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;relu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;隐藏层使用relu激活函数&lt;/span&gt;
net.add(Dense(input_dim=10, units=1)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;添加隐藏层（10节点）到输出层（1节点）的连接&lt;/span&gt;
net.add(Activation(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sigmoid&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;输出层使用sigmoid激活函数&lt;/span&gt;
&lt;span&gt;
net.compile(loss &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;binary_crossentropy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, optimizer = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;adam&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, 
            metrics&lt;/span&gt;=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;accuracy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
            tf.keras.metrics.Precision(),
            tf.keras.metrics.Recall()]) &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;编译模型，使用adam方法求解&lt;/span&gt;
&lt;span&gt;
net.fit(train[:,:&lt;/span&gt;3], train[:,3], epochs=100, batch_size=1) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;训练模型，循环1000次&lt;/span&gt;
net.save_weights(netfile) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;保存模型&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;部分结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
Epoch 97/100
232/232 [==============================] - 1s 4ms/step - loss: 0.1729 - accuracy: 0.9526 - precision: 0.8902 - recall: 0.8770&lt;span&gt;
Epoch &lt;/span&gt;98/100
232/232 [==============================] - 1s 4ms/step - loss: 0.1740 - accuracy: 0.9526 - precision: 0.8908 - recall: 0.8774&lt;span&gt;
Epoch &lt;/span&gt;99/100
232/232 [==============================] - 1s 4ms/step - loss: 0.1693 - accuracy: 0.9569 - precision: 0.8910 - recall: 0.8780&lt;span&gt;
Epoch &lt;/span&gt;100/100
232/232 [==============================] - 1s 4ms/step - loss: 0.1750 - accuracy: 0.9526 - precision: 0.8915 - recall: 0.8783
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对模型进行验证：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
scores = net.evaluate(test[:,:3], test[:,3], verbose=&lt;span&gt;0)
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(1&lt;span&gt;,len(net.metrics_names)):
  &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s: %.2f%%&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; % (net.metrics_names[i], scores[i]*100)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 打印出验证集准确率&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;accuracy: 88.14%&lt;/p&gt;
&lt;p&gt;precision: 89.14%&lt;/p&gt;
&lt;p&gt;recall: 87.85%&lt;/p&gt;
&lt;p&gt;使用模型进行预测：这里注意有两个api，一个得到的是概率值，另一个得到的是类别：&lt;/p&gt;
&lt;p&gt;使用predict()得到的是概率值：这里将其用round进行四舍五入后进行展开。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
predict_result = tf.round(net.predict(test[:,:3&lt;span&gt;]).reshape(len(test)))
with tf.Session() as sess:
  &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(predict_result.eval())
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;[0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 1. 1. 0. 0. 1. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 1. 1. 0. 0. 1. 0. 0. 1. 1. 1. 1. 0. 0. 1. 1. 0. 0. 0. 0. 0. 0. 1. 0. 0. 0. 1. 0. 0. 0.]&lt;/p&gt;
&lt;p&gt;使用predict_classes()得到的是类别：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
predict_result2 = net.predict_classes(test[:,:3&lt;span&gt;]).reshape(len(test))
predict_result2 &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0], dtype=int32)&lt;/p&gt;
&lt;p&gt;打印一下真实的标签：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
y_true = np.array(test[:,3])
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;array([0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4、评价指标的计算方式以及混淆矩阵&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们可以直接通过sklearn api来计算评价指标：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; sklearn.metrics &lt;span&gt;import&lt;/span&gt;&lt;span&gt; classification_report
target_names &lt;/span&gt;= [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;no&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;yes&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(classification_report(test[:,3],predict_result2,target_names=target_names))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
              precision    recall  f1-&lt;span&gt;score   support

          no       &lt;/span&gt;0.98      0.88      0.93        50&lt;span&gt;
         yes       &lt;/span&gt;0.57      0.89      0.70         9&lt;span&gt;

    accuracy                           &lt;/span&gt;0.88        59&lt;span&gt;
   macro avg       &lt;/span&gt;0.77      0.88      0.81        59&lt;span&gt;
weighted avg       &lt;/span&gt;0.92      0.88      0.89        59
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或者我们可以通过混淆矩阵自己来计算：首先是获得混淆矩阵&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; sklearn.metrics &lt;span&gt;import&lt;/span&gt;&lt;span&gt; confusion_matrix
cnf_matrix &lt;/span&gt;= confusion_matrix(test[:,3&lt;span&gt;], predict_result2)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(cnf_matrix)
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
#行、列的索引就是标签id，这里有两类，用0,1,表示&lt;br/&gt;[[44  6&lt;span&gt;]
 [ &lt;/span&gt;1  8]]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;混淆矩阵中的四个值分别代表TP、FP、TN、PN&lt;/p&gt;
&lt;p&gt;根据混淆矩阵，我们可以计算二分类评价指标：（标签为1的是正样本，因此TP是[1][1]）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
TP=cnf_matrix[1][1] &lt;span&gt;#&lt;/span&gt;&lt;span&gt;预测为正的真实标签为正&lt;/span&gt;
FP=cnf_matrix[0][1] &lt;span&gt;#&lt;/span&gt;&lt;span&gt;预测为正的真实标签为负&lt;/span&gt;
FN=cnf_matrix[1][0] &lt;span&gt;#&lt;/span&gt;&lt;span&gt;预测为负的真实标签为正&lt;/span&gt;
TN=cnf_matrix[0][0] &lt;span&gt;#&lt;/span&gt;&lt;span&gt;预测为负的真实标签为负&lt;/span&gt;
accuracy=(TP+TN)/(TP+FP+FN+&lt;span&gt;TN)
precision&lt;/span&gt;=TP/(TP+&lt;span&gt;FP)
recall&lt;/span&gt;=TP/(TP+&lt;span&gt;FN)
f1score&lt;/span&gt;=2 * precision * recall/(precision +&lt;span&gt; recall)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(accuracy,precision,recall,f1score)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;0.8813559322033898 0.5714285714285714 0.8888888888888888 0.6956521739130435&lt;/p&gt;
&lt;p&gt;这也上面api计算的yes的评价指标的值一致。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;5、绘制混淆矩阵&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; matplotlib.pyplot as plt 
&lt;/span&gt;%&lt;span&gt;matplotlib inline
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; cm_plot(y, yp, labels_name):
  
  &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; sklearn.metrics &lt;span&gt;import&lt;/span&gt; confusion_matrix &lt;span&gt;#&lt;/span&gt;&lt;span&gt;导入混淆矩阵函数&lt;/span&gt;
&lt;span&gt;
  cm &lt;/span&gt;= confusion_matrix(y, yp) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;混淆矩阵&lt;/span&gt;
&lt;span&gt;  
  plt.matshow(cm, cmap&lt;/span&gt;=plt.cm.Greens) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;画混淆矩阵图，配色风格使用cm.Greens，更多风格请参考官网。&lt;/span&gt;
  plt.colorbar() &lt;span&gt;#&lt;/span&gt;&lt;span&gt;颜色标签&lt;/span&gt;
  num_local =&lt;span&gt; np.array(range(len(labels_name))) 
  plt.xticks(num_local, labels_name)    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将标签印在x轴坐标上&lt;/span&gt;
  plt.yticks(num_local, labels_name)    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将标签印在y轴坐标上&lt;/span&gt;

  &lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt; range(len(cm)): &lt;span&gt;#&lt;/span&gt;&lt;span&gt;数据标签&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; y &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(len(cm)):
      plt.annotate(cm[x,y], xy&lt;/span&gt;=(x, y), horizontalalignment=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;center&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, verticalalignment=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;center&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

  plt.ylabel(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;True label&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;坐标轴标签&lt;/span&gt;
  plt.xlabel(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Predicted label&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;坐标轴标签&lt;/span&gt;
  &lt;span&gt;return&lt;/span&gt;&lt;span&gt; plt
cm_plot(test[:,&lt;/span&gt;3],predict_result2,[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;no&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;yes&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]).show()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503039/202009/1503039-20200917231327653-1094708423.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;6、二分类其他评价指标（这两个我重新在colab上运行的，因此数据和上面不一样）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;ROC曲线：&lt;/p&gt;
&lt;p&gt;横坐标：假正率（False positive rate， FPR），预测为正但实际为负的样本占所有负例样本的比例；&lt;/p&gt;
&lt;p&gt;FPR = FP / ( FP +TN)   &lt;/p&gt;
&lt;p&gt;纵坐标：真正率（True positive rate， TPR），这个其实就是召回率，预测为正且实际为正的样本占所有正例样本的比例。&lt;/p&gt;
&lt;p&gt;TPR = TP / ( TP+ FN) &lt;/p&gt;
&lt;p&gt;AUC：就是roc曲线和横坐标围城的面积。&lt;/p&gt;
&lt;p&gt;如何绘制？&lt;/p&gt;
&lt;p&gt;对于二值分类问题，实例的值往往是连续值，通过设定一个阈值，将实例分类到正类或者负类（比如大于阈值划分为正类）。上述中我们直接利用四舍五入来区分正类和负类。因此，可以变化阈值，根据不同的阈值进行分类，根据分类结果计算得到ROC空间中相应的点，连接这些点就形成ROC curve。ROC curve经过(0,0) (1,1)，实际上(0,0)和(1,1)连线形成的ROC curve实际上代表的是一个随机分类器。一般情况下，这个曲线都应该处于(0,0)和(1,1)连线的上方，&lt;/p&gt;
&lt;p&gt;代码实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; sklearn.metrics &lt;span&gt;import&lt;/span&gt;&lt;span&gt; roc_curve, auc
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 为每个类别计算ROC曲线和AUC&lt;/span&gt;
predict_res=net.predict(test[:,:3&lt;span&gt;]).reshape(len(test))
fpr,tpr,threholds&lt;/span&gt;=roc_curve(test[:,3],predict_res,pos_label=1&lt;span&gt;)
roc_auc&lt;/span&gt;=&lt;span&gt;auc(fpr,tpr)
plt.plot(fpr,tpr,linewidth&lt;/span&gt;=2, label=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ROC curve (area = %0.2f)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; roc_auc)
plt.xlabel(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;False Positive Rate&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.ylabel(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;True Positive Rate&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.title(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Receiver operating characteristic example&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.legend(loc&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lower right&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
plt.show()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503039/202009/1503039-20200918213849977-652678627.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;绘制Precision-Recall曲线：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; sklearn.metrics &lt;span&gt;import&lt;/span&gt;&lt;span&gt; precision_recall_curve
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; sklearn.metrics &lt;span&gt;import&lt;/span&gt;&lt;span&gt; average_precision_score
precision,recall,_ &lt;/span&gt;= precision_recall_curve(test[:,3],predict_res,pos_label=1&lt;span&gt;)
average_precision &lt;/span&gt;= average_precision_score(test[:,3],predict_res,pos_label=1&lt;span&gt;)
plt.plot(recall, precision,label&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Precision-recall curve of class (area = {1:0.2f})&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(i, average_precision))
plt.xlabel(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Recall&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, fontsize=16&lt;span&gt;)
plt.ylabel(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Precision&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,fontsize=16&lt;span&gt;)
plt.title(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Extension of Precision-Recall curve to 2-class&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,fontsize=16&lt;span&gt;)
plt.legend(loc&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;upper right&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;legend 是用于设置图例的函数&lt;/span&gt;
plt.show()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503039/202009/1503039-20200918215621046-413248196.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;关于二分类评价指标网上已经有很多讲解的很清楚的了，就不仔细讲了，还是注重实际的代码。本来是应该对比不同的模型的，结果搞成了讲解二分类指标了。。。 &lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;《python数据分析与挖掘实战》 &lt;/p&gt;
&lt;p&gt;https://www.cnblogs.com/liweiwei1419/p/9870034.html&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/weixin_39541558/article/details/82708832&lt;/p&gt;
</description>
<pubDate>Fri, 18 Sep 2020 13:59:00 +0000</pubDate>
<dc:creator>西西嘛呦</dc:creator>
<og:description>问题描述：判断用户是否窃漏电 问题解决：二分类问题 缺失值：拉格朗日插值法进行填充 使用的特征：电量趋势下降指标、线损指标、警告类指标 这里使用的数据来&amp;lt;python数据分析与实战第六章&amp;gt;</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiximayou/p/13682052.html</dc:identifier>
</item>
<item>
<title>Spock测试套件入门 - 西北偏北UP</title>
<link>http://www.cnblogs.com/niceshot/p/13693660.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/niceshot/p/13693660.html</guid>
<description>&lt;h3 id=&quot;spock测试套件&quot;&gt;Spock测试套件&lt;/h3&gt;
&lt;p&gt;Spock套件基于一个单元测试框架，它有比junit更为简洁高效的测试语法。&lt;/p&gt;
&lt;h3 id=&quot;核心概念&quot;&gt;核心概念&lt;/h3&gt;
&lt;h4 id=&quot;整体认识&quot;&gt;整体认识&lt;/h4&gt;
&lt;p&gt;Spock中一个单元测试类名叫Specification。所有的单元测试类，都需要继承Specification&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class MyFirstSpecification extends Specification {
  // fields
  // fixture methods
  // feature methods
  // helper methods
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于spock来说，Specification代表了一个软件、应用、类的使用规范，其中的所有单元测试方法，被称为feature，即功能。&lt;/p&gt;
&lt;p&gt;一个feature method的执行逻辑大概是如下几步：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;setup 设置该功能的前置配置&lt;/li&gt;
&lt;li&gt;stimulus 提供一个输入，触发该功能&lt;/li&gt;
&lt;li&gt;response 描述你期望该功能的返回值&lt;/li&gt;
&lt;li&gt;cleanup 清理功能的前置配置&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;所以，&lt;strong&gt;对spock来说，一个单元测试，其实是这个软件应用提供的功能使用规范，这个规范中提供了每个功能的使用说明书，输入什么，会得到什么&lt;/strong&gt;，大体是按这个看法，去写单元测试的。&lt;/p&gt;
&lt;h4 id=&quot;前置、后置&quot;&gt;前置、后置&lt;/h4&gt;
&lt;p&gt;就像junit一样，我们可以对整个单元测试类做一些前置，并清理。也可以对每个单元测试的方法做一些前置后清理。&lt;/p&gt;
&lt;p&gt;其跟Junit的类比关系为&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;setupSpec 对应 @BeforeClass
setup 对应 @Before
cleanup 对应 @After
cleanupSpec 对应 @AfterClass
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同时由于Spock的单元测试本身是会集成Specification 父类的，所以父类中的前置、后置方法也会被调用，不过不用显示调用，会自动调用。&lt;/p&gt;
&lt;p&gt;一个测试功能方法执行时，其整体的执行顺序为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;super.setupSpec

sub.setupSpec

super.setup

sub.setup

**feature method

sub.cleanup

super.cleanup

sub.cleanupSpec

super.cleanupSpec
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;同junit的类比&quot;&gt;同junit的类比&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2007268/202009/2007268-20200918213904973-1052154928.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;feature-方法&quot;&gt;Feature 方法&lt;/h3&gt;
&lt;h4 id=&quot;blocks&quot;&gt;blocks&lt;/h4&gt;
&lt;p&gt;feature的具体写法有很多的block组成，这些block对应的feature方法本身的四个阶段（setup, stimulus, reponse, cleanup) 。每个block对应阶段示意图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2007268/202009/2007268-20200918213917716-908409410.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;典型的用法&quot;&gt;典型的用法&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;    def '测试++'(){
        given:
            def x = 5
        when: def result = calculateService.plusPlus(x)
        then: result == 6
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;given也可以写成setup，feature方法里的given其实跟外面的setup方法功能一样，都是做测试功能的前置设置。只是单独的setup方法，是用来写对每个测试feature都有用的测试。只跟当前feature相关的设置，请放在feature方法内的given标签&lt;/li&gt;
&lt;li&gt;when 标签用来实际调用想要测试的feature&lt;/li&gt;
&lt;li&gt;then 中对when的调用返回进行结果验证，这里不需要写断言，直接写表达式就是断言&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;异常condition&quot;&gt;异常condition&lt;/h4&gt;
&lt;p&gt;then中的断言在spock中叫condition。比如Java中的Stack在没有元素时，进行Popup，则会EmptyStackException异常。我们期望它确实会抛出这个异常，那么写法如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def '异常2'() {
        given:
        def stack = new Stack()
        when:
        def result = stack.pop()
        then:
        EmptyStackException e = thrown()
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它并不会抛出EmptyStackException，我们要测试这个预期的话，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    def '异常2'() {
        given:
        def stack = new Stack()
        stack.push(&quot;hello world&quot;)
        when:
        stack.pop()
        then:
        EmptyStackException e = notThrown()
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;then和expect的区别&quot;&gt;then和expect的区别&lt;/h4&gt;
&lt;p&gt;前面说了when block用来调用，then用来判断预期结果。但有的时候，我们的调用和预期判断并不复杂，那么可以用expect将两者合在一起，比如以下两段代码等价&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;when:
def x = Math.max(1, 2)

then:
x == 2
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;expect:
Math.max(1, 2) == 2
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;cleanup-block的用法&quot;&gt;cleanup block的用法&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;def 'cleanup'() {
        given:
        def file = new File(&quot;/some/path&quot;)
        file.createNewFile()

        // ...

        cleanup:
        file.delete()
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用于清理feature测试执行后的一些设置，比如打开的文件链接。该操作即便测试的feature出异常，依然会被调用&lt;/p&gt;
&lt;p&gt;同样，如果多个测试feature都需要这个cleanup.那么建议将cleanup的资源提到setup方法中，并在cleanup方法中去清理&lt;/p&gt;
&lt;h4 id=&quot;测试用例中的文本描述&quot;&gt;测试用例中的文本描述&lt;/h4&gt;
&lt;p&gt;为了让单元测试可读性更高，可以将测试方法中每一部分用文本进行描述，多个描述可以用and来串联&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    def '异常2'() {
        given:'设置stack对象'
        def stack = new Stack()

        and:'其它变量设施'
        stack.push('hello world')


        when:'从stack中弹出元素'
        def result = stack.pop()

        then:'预期会出现的异常'
        EmptyStackException e = thrown()
    }

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;extension&quot;&gt;Extension&lt;/h3&gt;
&lt;p&gt;spock通过标注来扩充单元测试的功能&lt;/p&gt;
&lt;p&gt;&lt;code&gt;@Timeout&lt;/code&gt;指定一个测试方法，或一个设置方法最长可以执行的时间，用于对性能有要求的测试&lt;br/&gt;&lt;code&gt;@Ignore&lt;/code&gt;用于忽略当前的测试方法&lt;br/&gt;&lt;code&gt;@IgnoreRest&lt;/code&gt;忽略除当前方法外的所有方法，用于想快速的测一个方法&lt;br/&gt;&lt;code&gt;@FailsWith&lt;/code&gt; 跟exception condition类似&lt;/p&gt;
&lt;h3 id=&quot;数据驱动测试&quot;&gt;数据驱动测试&lt;/h3&gt;
&lt;h4 id=&quot;数据表&quot;&gt;数据表&lt;/h4&gt;
&lt;p&gt;对于有些功能逻辑，其代码是一样的，只是需要测试不同输入值。按照先前的介绍，最简洁的写法为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    def &quot;maximum of two numbers1&quot;() {
        expect:
        // exercise math method for a few different inputs
        Math.max(1, 3) == 3
        Math.max(7, 4) == 4
        Math.max(0, 0) == 1
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Math.max代码需要手动调用三次&lt;/li&gt;
&lt;li&gt;第二行出错后，第三行不会被执行&lt;/li&gt;
&lt;li&gt;数据和代码耦合在一起，不方便数据从其它地方独立准备&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;所以spock引入了数据表的概念，将测试数据和代码分开。典型实例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class MathSpec extends Specification {
  def &quot;maximum of two numbers&quot;() {
    expect:
    Math.max(a, b) == c

    where:
    a | b || c
    1 | 3 || 3
    7 | 4 || 7
    0 | 0 || 0
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;where语句中，定义数据表。第一行是表头，定义这一列所属的变量。&lt;/li&gt;
&lt;li&gt;实际代码调用，只需要调用一次。代码中的变量跟数据表中的变量必须一一对应&lt;/li&gt;
&lt;li&gt;看似一个方法，实际上执行时，spock会根据数据表中的行数，循环迭代执行代码。每一行都是独立于其余行执行，所以有setup和cleanup块，对每一个行的都会重复执行一次&lt;/li&gt;
&lt;li&gt;并且某一行的数据出错，并不影响其余行的执行&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;另外的写法&quot;&gt;另外的写法&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;def &quot;maximum of two numbers&quot;(int a, int b ,int c) {
        expect:
        Math.max(a, b) == c

        where:
        a | b | c
        1 | 3 | 3
        7 | 4 | 4
        0 | 0 | 1
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;变量可以在方法参数中声明，但没必要&lt;/li&gt;
&lt;li&gt;数据表可以全部用一个竖线来分割，但无法像两个竖线一样清晰的分割输入和输出&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;更清晰的测试结果展示&quot;&gt;更清晰的测试结果展示&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;class MathSpec extends Specification {
  def &quot;maximum of two numbers&quot;() {
    expect:
    Math.max(a, b) == c

    where:
    a | b || c
    1 | 3 || 3
    7 | 4 || 4
    0 | 0 || 1
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上测试代码，数据表中的后两行会执行失败。但从测试结果面板中，不能很好的看到详细结果&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2007268/202009/2007268-20200918213939884-1522419768.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;@Unroll&lt;/code&gt;可以将每个迭代的执行结果输出&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2007268/202009/2007268-20200918213952263-1846954594.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到面板中实际输出的文本为测试方法的名称。如果像在输出中加上输入输出的变量，来详细展示每个迭代，可以在方法名中使用占位符&lt;code&gt;#variable&lt;/code&gt;来引用变量的值。举例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Unroll
    def &quot;maximum of #a and #b is #c&quot;() {
        expect:
        Math.max(a, b) == c

        where:
        a | b || c
        1 | 3 || 3
        7 | 4 || 4
        0 | 0 || 1
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2007268/202009/2007268-20200918214006929-325281759.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;更丰富的数据准备方式&quot;&gt;更丰富的数据准备方式&lt;/h4&gt;
&lt;p&gt;前面的数据表显示的将数据以表格的形式写出来。实际上，数据在where block中的准备还有其它多种方式。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;where:
a &amp;lt;&amp;lt; [1, 7, 0]
b &amp;lt;&amp;lt; [3, 4, 0]
c &amp;lt;&amp;lt; [3, 7, 0]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从数据库中查询&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Shared sql = Sql.newInstance(&quot;jdbc:h2:mem:&quot;, &quot;org.h2.Driver&quot;)

def &quot;maximum of two numbers&quot;() {
  expect:
  Math.max(a, b) == c

  where:
  [a, b, c] &amp;lt;&amp;lt; sql.rows(&quot;select a, b, c from maxdata&quot;)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用groovy代码赋值&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;where:
a = 3
b = Math.random() * 100
c = a &amp;gt; b ? a : b
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上几种方式可以混搭。&lt;/p&gt;
&lt;p&gt;其中方法名也可以以丰富的表达式引用where block中的变量&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def &quot;person is #person.age years old&quot;() { 
  ...
  where:
  person &amp;lt;&amp;lt; [new Person(age: 14, name: 'Phil Cole')]
  lastName = person.name.split(' ')[1]
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;基于交互的测试interaction-based-testing&quot;&gt;基于交互的测试(Interaction Based Testing)&lt;/h3&gt;
&lt;p&gt;有的时候，我们测试的功能，需要依赖另外的collaborators来测试。这种涉及到多个执行单元之间的交互，叫做交互测试&lt;/p&gt;
&lt;p&gt;比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Publisher {
  List&amp;lt;Subscriber&amp;gt; subscribers = []
  int messageCount = 0
  void send(String message){
    subscribers*.receive(message)
    messageCount++
  }
}

interface Subscriber {
  void receive(String message)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们想测Publisher，但Publisher有个功能是是发消息给所有的Subscriber。要想测试Publisher的发送功能确实ok，那么需要测试Subscriber的确能收到消息。&lt;/p&gt;
&lt;p&gt;使用一个实际的Subscriber实现固然能实现这个测试。但对具体的Subscriber实现造成了依赖，这里需要Mock。使用spock的测试用例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class PublisherTest extends Specification{
    Publisher publisher = new Publisher()
    Subscriber subscriber = Mock()
    Subscriber subscriber2 = Mock()　//创建依赖的Subscriber　Mock

    def setup() {
        publisher.subscribers &amp;lt;&amp;lt; subscriber // &amp;lt;&amp;lt; is a Groovy shorthand for List.add()
        publisher.subscribers &amp;lt;&amp;lt; subscriber2
    }


    def &quot;should send messages to all subscribers&quot;() {
        when:
        publisher.send(&quot;hello&quot;)　//调用publisher的方法
        then:
        1*subscriber.receive(&quot;hello&quot;) //期望subscriber的receive方法能被调用一次
        1*subscriber2.receive(&quot;hello&quot;)//期望subscriber1的receive方法能被调用一次
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上代码的目的是通过mock来测试当Publisher的send的方法被执行时，且执行参数是'hello'时，subscriber的receive方法一定能被调用，且入参也为‘hello’&lt;/p&gt;
&lt;h4 id=&quot;对依赖mock的调用期望，其结构如下&quot;&gt;对依赖Mock的调用期望，其结构如下&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;1 * subscriber.receive(&quot;hello&quot;)
|   |          |       |
|   |          |       argument constraint
|   |          method constraint
|   target constraint
cardinality
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;cardinality&lt;/strong&gt;&lt;br/&gt;定义右边期望方法执行的次数，这里是期望执行一次，可能的写法有如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1 * subscriber.receive(&quot;hello&quot;)      // exactly one call
0 * subscriber.receive(&quot;hello&quot;)      // zero calls
(1..3) * subscriber.receive(&quot;hello&quot;) // between one and three calls (inclusive)
(1.._) * subscriber.receive(&quot;hello&quot;) // at least one call
(_..3) * subscriber.receive(&quot;hello&quot;) // at most three calls
_ * subscriber.receive(&quot;hello&quot;)      // any number of calls, including zero
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;target constraint&lt;/strong&gt;&lt;br/&gt;定义被依赖的对象。可能的写法如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1 * subscriber.receive(&quot;hello&quot;) // a call to 'subscriber'
1 * _.receive(&quot;hello&quot;)          // a call to any mock object
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Method Constraint&lt;/strong&gt;&lt;br/&gt;定义在上述对象上期望被调用的方法，可能的写法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1 * subscriber.receive(&quot;hello&quot;) // a method named 'receive'
1 * subscriber./r.*e/(&quot;hello&quot;)  // a method whose name matches the given regular expression
                                // (here: method name starts with 'r' and ends in 'e')
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Argument Constraints&lt;/strong&gt;&lt;br/&gt;对被调用方法，期望的入参进行定义。可能写法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1 * subscriber.receive(&quot;hello&quot;)        // an argument that is equal to the String &quot;hello&quot;
1 * subscriber.receive(!&quot;hello&quot;)       // an argument that is unequal to the String &quot;hello&quot;
1 * subscriber.receive()               // the empty argument list (would never match in our example)
1 * subscriber.receive(_)              // any single argument (including null)
1 * subscriber.receive(*_)             // any argument list (including the empty argument list)
1 * subscriber.receive(!null)          // any non-null argument
1 * subscriber.receive(_ as String)    // any non-null argument that is-a String
1 * subscriber.receive(endsWith(&quot;lo&quot;)) // any non-null argument that is-a String
1 * subscriber.receive({ it.size() &amp;gt; 3 &amp;amp;&amp;amp; it.contains('a') })
// an argument that satisfies the given predicate, meaning that
// code argument constraints need to return true of false
// depending on whether they match or not
// (here: message length is greater than 3 and contains the character a)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;一些通配符&quot;&gt;一些通配符&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;1 * subscriber._(*_)     // any method on subscriber, with any argument list
1 * subscriber._         // shortcut for and preferred over the above

1 * _._                  // any method call on any mock object
1 * _                    // shortcut for and preferred over the above
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;严格模式strict-mocking&quot;&gt;严格模式(Strict Mocking)&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;when:
publisher.publish(&quot;hello&quot;)

then:
1 * subscriber.receive(&quot;hello&quot;) // demand one 'receive' call on 'subscriber'
_ * auditing._                  // allow any interaction with 'auditing'
0 * _                           // don't allow any other interaction
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;默认情况下，你对Mock实例的方法的调用，会返回该方法返回值的默认值，比如该方法返回的是布尔型，那么你你调用mock实例中的该方法时，将返回布尔型的默认值false.&lt;/p&gt;
&lt;p&gt;如果我们希望严格的限定Mock实例的各方法行为，可以通过上述代码，对需要测试的方法显示定义期望调用行为，对其它方法设置期望一次都不调用。以上then block中的&lt;code&gt;0 * _&lt;/code&gt;　即是定义这种期望。当除subscriber中的receive和auditing中的所有方法被调用时，该单元测试会失败，因为这不符合我们对其它方法调用0次的期望&lt;/p&gt;
&lt;h4 id=&quot;调用顺序&quot;&gt;调用顺序&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;then:
2 * subscriber.receive(&quot;hello&quot;)
1 * subscriber.receive(&quot;goodbye&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上两个期望被调用的顺序是随机的。如果要保证调用顺序，使用两个then&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;then:
2 * subscriber.receive(&quot;hello&quot;)

then:
1 * subscriber.receive(&quot;goodbye&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;stubbing-定义方法返回&quot;&gt;Stubbing　定义方法返回&lt;/h3&gt;
&lt;p&gt;前面的interaction mock是用来测试被mock的对象，期望方法的调用行为。比如入参，调用次数。&lt;/p&gt;
&lt;p&gt;而stubbing则用来定义被mock的实例，在调用时返回的行为&lt;/p&gt;
&lt;p&gt;总结，前者定义调用行为期望，后者定义返回行为期望。且Interaction test　测试的是执行期望或断言。的stubbing则是用来定义mock的模拟的行为。&lt;/p&gt;
&lt;p&gt;所以stubbing　对mock方法返回值的定义应该放在given block. 而对mock方法本身的调用Interaction test　应该放在then block中。所以stubbing对返回值的定义相当于在定义测试的测试数据。&lt;/p&gt;
&lt;p&gt;Stubbing的使用场景也很明确。假设Publisher需要依赖Subscriber方法的返回值，再做下一步操作。那我们就需要对Subscriber的返回值进行mock，来测试不同返回值对目标测试代码(feature)的行为。&lt;/p&gt;
&lt;p&gt;我们将上述Subscriber接口对应的方法添加一个返回值&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Publisher {
        Subscriber subscriber
        int messageCount = 0

        int send(String message){
            if(subscriber.receive(message) == 'ok') {
                this.messageCount++
            }
            return messageCount
        }
    }

interface Subscriber {
    String receive(String message)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试代码举例&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Publisher publisher = new Publisher()
Subscriber subscriber = Mock()

def setup() {
    publisher.subscriber = subscriber
}

def &quot;should send msg to subscriber&quot;() {
     given:
     subscriber.receive(&quot;message1&quot;) &amp;gt;&amp;gt; &quot;ok&quot;

     when:
     def result = publisher.send(&quot;message1&quot;)

     then:
     result == 1
 }

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上代码表示，模拟subscriber.receive被调用时，且调用参数为message1，方法返回ok. 而此时期望(断言)Publisher的send方法，返回的是1&lt;/p&gt;
&lt;h4 id=&quot;stubbing-返回值结构&quot;&gt;stubbing 返回值结构&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;subscriber.receive(_) &amp;gt;&amp;gt; &quot;ok&quot;
|          |       |     |
|          |       |     response generator
|          |       argument constraint
|          method constraint
target constraint
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意这里多了response generator，并且没有interaction test中的Cardinality&lt;/p&gt;
&lt;h4 id=&quot;各种返回值定义&quot;&gt;各种返回值定义&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;返回固定值&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;subscriber.receive(&quot;message1&quot;) &amp;gt;&amp;gt; &quot;ok&quot;
subscriber.receive(&quot;message2&quot;) &amp;gt;&amp;gt; &quot;fail&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;顺序调用返回不同的值&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;subscriber.receive(_) &amp;gt;&amp;gt;&amp;gt; [&quot;ok&quot;, &quot;error&quot;, &quot;error&quot;, &quot;ok&quot;]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第一次调用返回ok,第二次、三次调用返回error。剩下的调用返回ok&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;根据入参计算返回值&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;subscriber.receive(_) &amp;gt;&amp;gt; { args -&amp;gt; args[0].size() &amp;gt; 3 ? &quot;ok&quot; : &quot;fail&quot; }
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;subscriber.receive(_) &amp;gt;&amp;gt; { String message -&amp;gt; message.size() &amp;gt; 3 ? &quot;ok&quot; : &quot;fail&quot; }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述两者效果都一样，都是对第一个入参的长度进行判断，然后确定返回值&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;返回异常&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;subscriber.receive(_) &amp;gt;&amp;gt; { throw new InternalError(&quot;ouch&quot;) }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;链式返回值设定&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;subscriber.receive(_) &amp;gt;&amp;gt;&amp;gt; [&quot;ok&quot;, &quot;fail&quot;, &quot;ok&quot;] &amp;gt;&amp;gt; { throw new InternalError() } &amp;gt;&amp;gt; &quot;ok&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;前三次调用依次返回ok,fail,ok。第四次调用返回异常，之后的调用返回ok&lt;/p&gt;
&lt;h3 id=&quot;将interaction-mock和stubbing组合&quot;&gt;将Interaction Mock和stubbing组合&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;1 * subscriber.receive(&quot;message1&quot;) &amp;gt;&amp;gt; &quot;ok&quot;
1 * subscriber.receive(&quot;message2&quot;) &amp;gt;&amp;gt; &quot;fail&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里即定义了被mock 的subscriber其方法返回值，也定义了该方法期望被调用多少次。举例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Publisher publisher = new Publisher()
Subscriber subscriber = Mock()

def setup() {
    publisher.subscriber = subscriber
}

def &quot;should send msg to subscriber&quot;() {
    given:
    1*subscriber.receive(&quot;message1&quot;) &amp;gt;&amp;gt; &quot;ok&quot;

    when:
    def result = publisher.send(&quot;message1&quot;)

    then:
    result == 1
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上写法，即测试了subscriber.receive被调用了一次，也测试了publisher.send执行结果为1．如果将Interaction Mock和stubbing组合拆开，像下面这种写法是不行的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Publisher publisher = new Publisher()
Subscriber subscriber = Mock()

def setup() {
    publisher.subscriber = subscriber
}

def &quot;should send msg to subscriber&quot;() {
        given:
        subscriber.receive(&quot;message1&quot;) &amp;gt;&amp;gt; &quot;ok&quot;

        when:
        def result = publisher.send(&quot;message1&quot;)

        then:
        result == 1
        1*subscriber.receive(&quot;message1&quot;)
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;如何创建单元测试类&quot;&gt;如何创建单元测试类&lt;/h3&gt;
&lt;h4 id=&quot;方式一&quot;&gt;方式一&lt;/h4&gt;
&lt;p&gt;像Junit一样，在需要测试的类上，使用Idea的帮助快捷键，然后弹出&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2007268/202009/2007268-20200918214056491-1845880103.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择指定的测试框架spock和路径即可&lt;/p&gt;
&lt;h4 id=&quot;方式二&quot;&gt;方式二&lt;/h4&gt;
&lt;p&gt;直接在指定的测试目录下，新建对应的测试类，注意是新建groovy class&lt;br/&gt;在Idea中，groovy class的图标是方块，java class是圆形，注意区分&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2007268/202009/2007268-20200918214104963-487643204.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有可能建完后，对应的图标是&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2007268/202009/2007268-20200918214115233-904295424.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;，说明Ide没有识别到这是个groovy 类，一般是由于其代码有问题，可以打开该文件，把具体的错误修复，比如把注释去掉之类的&lt;/p&gt;
&lt;h3 id=&quot;参考资料&quot;&gt;参考资料&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://spockframework.org/spock/docs/1.1/all_in_one.html#_introduction&quot;&gt;http://spockframework.org/spock/docs/1.1/all_in_one.html#_introduction&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 18 Sep 2020 13:42:00 +0000</pubDate>
<dc:creator>西北偏北UP</dc:creator>
<og:description>Spock测试套件 Spock套件基于一个单元测试框架，它有比junit更为简洁高效的测试语法。 核心概念 整体认识 Spock中一个单元测试类名叫Specification。所有的单元测试类，都需要</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/niceshot/p/13693660.html</dc:identifier>
</item>
</channel>
</rss>