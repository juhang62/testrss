<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Vue 2.6版本基础知识概要(一) - 散场丶丶</title>
<link>http://www.cnblogs.com/sanchang/p/10549900.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sanchang/p/10549900.html</guid>
<description>&lt;h3 id=&quot;挂载组件&quot;&gt;挂载组件&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;//将 App组件挂载到div#app节点里
new Vue({
  render: h =&amp;gt; h(App),
}).$mount('#app')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;VueComponent.$mount&lt;/p&gt;
&lt;h3 id=&quot;封装组件&quot;&gt;封装组件&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;div id=&quot;app&quot;&amp;gt;
    Hello Vue
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
export default {
  name: 'app',
}
&amp;lt;/script&amp;gt;

&amp;lt;style&amp;gt;
#app {
  font-family: 'Avenir', Helvetica, Arial, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  text-align: center;
  color: #2c3e50;
}
&amp;lt;/style&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;1 Vue组件文件以.vue 结尾;&lt;/p&gt;
&lt;p&gt;2 Vue组件模版，将html,css,js分别抽离到 tempplate ,style ,script ，各司其职，层次分明;&lt;/p&gt;
&lt;p&gt;3 Vue实现css模块化的方式，是 scoped属性，style scoped ,其原理与css-module类似，以多位hash值避免命名冲突(所以依然存在冲突的可能性);&lt;/p&gt;
&lt;p&gt;4 Vue实现数据双向绑定, 指令 v-model = 'dataOrPropName',即绑定props对象或data对象的key。因此，props与data的key命名不可冲突；&lt;/p&gt;
&lt;p&gt;5 Vue实现列表渲染的关键指令是 v-for:&quot;item in list&quot; ,v-for属性对当前标签起作用,为了diff算法依赖key值遍历比对的实现，应当同时添加 v-bind:key = 'renewableVariat'绑定key值 ;&lt;/p&gt;
&lt;p&gt;6 Vue组件实现父子组件间通信:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;div id=&quot;app&quot;&amp;gt;
    &amp;lt;HelloWorld v-bind:msg='msg' v-bind:click='getDataFormChild'/&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
import HelloWorld from './components/HelloWorld.vue'

export default {
  name: 'app',
  components: {
    HelloWorld
  },
  methods:{
    getDataFormChild:(zz,yy)=&amp;gt;{
      console.log(zz,yy);
    }
  }
}
&amp;lt;/script&amp;gt;

&amp;lt;style&amp;gt;
#app {
  font-family: 'Avenir', Helvetica, Arial, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  text-align: center;
  color: #2c3e50;
}
&amp;lt;/style&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如代码所示，单向数据流父传子依然是通过props传递信息，通过v-bind实现变量的传值，子组件可通过调用父组件定义的方法并传参，实现数据的逆向传递；&lt;/p&gt;
&lt;p&gt;7 注意定义data的方式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; data:()=&amp;gt;({
    msg:'hello, vue'
  }),&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如代码所示，data为函数，最终返回一个data对象。（这里应考虑返回data对象的函数如果为异步的情形）;&lt;/p&gt;
&lt;p&gt;8 :&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;script&amp;gt;
import HelloWorld from './components/HelloWorld.vue';
export default {
  name: 'app',
  components: {
    HelloWorld
  },
  props: {
    msg: String,
    click: Function
  },
  data:()=&amp;gt;({
    msg:'hello, vue'
  }),
  methods:{
    getDataFormChild:(zz,yy)=&amp;gt;{
      console.log(zz,yy);
    }
  }
}
&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如代码所示，在js中引入依赖组件,最终暴露的是一个Vue组件的配置对象,其中，components为引入的组件集对象，data为函数，return出一个data对象，methods是方法集对象 ，props里为props类型检测对象。&lt;/p&gt;
&lt;p&gt;9 注意所有js集或框架的类型检测，都是 弱类型(源于js)的静态/动态类型检测: 静态-指代码运行时才进行检测; 动态-指代码编译时就进行检测(如ts);&lt;/p&gt;
&lt;p&gt;10 Vue其他丰富的指令及封装指令的方式;&lt;/p&gt;
&lt;p&gt;11 Vue提供的组件通信的多种api；&lt;/p&gt;
&lt;p&gt;12 Vue-router ， vuex等插件的使用;&lt;/p&gt;
&lt;p&gt;13 vue 配合node 实现 ssr;&lt;/p&gt;
&lt;p&gt;14 vue 配合node 实现部分同构；&lt;/p&gt;
&lt;p&gt;15 vue底层源码的消化;&lt;/p&gt;
&lt;p&gt;16 基于vue手封实现vuex的功能;&lt;/p&gt;
&lt;p&gt;17 拥抱新版本，全面面向es6，深刻学习proxy(替代Object.defineProperty)及class(替代构造函数)的使用;&lt;/p&gt;
&lt;p&gt;18 基于Vue指令的思想，写react继承类高阶组件基于React.Component实现多个指令;&lt;/p&gt;
</description>
<pubDate>Sun, 17 Mar 2019 16:48:00 +0000</pubDate>
<dc:creator>散场丶丶</dc:creator>
<og:description>Vue 26版本基础知识概要与进阶学习步骤</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sanchang/p/10549900.html</dc:identifier>
</item>
<item>
<title>C++第三章复习与总结（思维导图分享） - KOKODA</title>
<link>http://www.cnblogs.com/KOKODA/p/10548366.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/KOKODA/p/10548366.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://my-markdown-picture.oss-cn-shanghai.aliyuncs.com/pics/ev7S.png&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;info&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;在完成了第三章的学习后，为了便于日后的复习整理，我制作了一张思维导图，有需要的可以自取。&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id=&quot;函数的定义与使用&quot;&gt;函数的定义与使用&lt;/h2&gt;
&lt;h3 id=&quot;带默认值的函数&quot;&gt;带默认值的函数&lt;/h3&gt;
&lt;p&gt;在C++中我们可以为函数添加默认的参数值，在调用时可不传入或部分传入参数，为传入的部分便会采用默认值。&lt;/p&gt;
&lt;p&gt;带默认参数的函数可以放在main函数前。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;

int add(int a = 5, int b = 6)
{
    return a + b;
}

int main(void)
{
    cout&amp;lt;&amp;lt;add();
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也可把函数放在main函数后，将默认值放在函数声明中。&lt;br/&gt;&lt;/p&gt;
&lt;div class=&quot;info&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;这种情况下，默认值只可出现在函数声明中，不可出现在函数定义中&lt;/p&gt;
&lt;/div&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;

int add(int a = 5, int b = 6);

int main(void)
{
    cout &amp;lt;&amp;lt; add();
    return 0;
}

int add(int a, int b)  //add(int a = 5,b = 6)为错误写法
{
    return a + b;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;内联函数&quot;&gt;内联函数&lt;/h3&gt;
&lt;p&gt;C++中添加了一个新的关键字&lt;code&gt;inline&lt;/code&gt;，在函数定义前加上即可将函数嵌入所有调用函数的地方，以此来消除调用函数时产生的时间开销，适用于简单且规模小的函数。&lt;br/&gt;内联函数的定义非常简单，但是使用时也有一些注意点。&lt;br/&gt;&lt;/p&gt;
&lt;div class=&quot;info&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;关键字inline 必须与函数定义体放在一起才能使函数成为内联，仅将inline 放在函数声明前面不起任何作用。(摘自高质量C++/C 编程指南)&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id=&quot;参数传递&quot;&gt;参数传递&lt;/h3&gt;
&lt;h4 id=&quot;值传递&quot;&gt;值传递&lt;/h4&gt;
&lt;p&gt;C++中的值传递与C语言中的值传递并无两样。在发生普通的函数调用时，系统会给形参分配空间并用实参的值给形参初始化。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://my-markdown-picture.oss-cn-shanghai.aliyuncs.com/pics/sEpQ.png&quot;/&gt;&lt;br/&gt;所以，对形参的任何改动都不会对实参产生影响，需求的结果都通过返回值传回。&lt;/p&gt;
&lt;h4 id=&quot;引用传递&quot;&gt;引用传递&lt;/h4&gt;
&lt;p&gt;引用是一种特殊类型的变量，可看作另一个变量的别称。&lt;br/&gt;&lt;img src=&quot;https://my-markdown-picture.oss-cn-shanghai.aliyuncs.com/pics/Y5dc.png&quot;/&gt;&lt;br/&gt;对引用的改动会直接反映到被引用的变量上。&lt;/p&gt;
&lt;h2 id=&quot;函数重载&quot;&gt;函数重载&lt;/h2&gt;
&lt;p&gt;C++中的函数重载允许我们使用相同的函数名却使用不同数据类型的数据与返回值，在进行函数调用的时候，编译器会自动根据数据类型选择合适的函数。&lt;/p&gt;
&lt;h3 id=&quot;普通的函数重载&quot;&gt;普通的函数重载&lt;/h3&gt;
&lt;p&gt;一般的函数重载要求我们为每一个数据类型写一个函数，函数名相同，只有参数的数据类型和返回值的数据类型不同。&lt;br/&gt;比如我要实现一个add函数，可以对&lt;code&gt;double&lt;/code&gt; &lt;code&gt;int&lt;/code&gt; &lt;code&gt;complex&lt;/code&gt;实现相加操作。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;complex&amp;gt;
#include &amp;lt;iostream&amp;gt;
using namespace std;

int add(int, int);
double add(double, double);
complex&amp;lt;double&amp;gt; add(complex&amp;lt;double&amp;gt;, complex&amp;lt;double&amp;gt;);

int main()
{
    int a = 1, b = 5;
    double x = 1.12, y = 5.36;
    complex&amp;lt;double&amp;gt; m{2.2, 5.4};
    complex&amp;lt;double&amp;gt; n{3.5, 2.1};
    cout &amp;lt;&amp;lt; add(a, b) &amp;lt;&amp;lt; endl;
    cout &amp;lt;&amp;lt; add(x, y) &amp;lt;&amp;lt; endl;
    cout &amp;lt;&amp;lt; add(m, n).real() &amp;lt;&amp;lt; &quot;+&quot; &amp;lt;&amp;lt; add(m, n).imag() &amp;lt;&amp;lt; &quot;i&quot; &amp;lt;&amp;lt; endl;
    return 0;
}

int add(int a, int b)
{
    return a + b;
}

double add(double a, double b)
{
    return a + b;
}

complex&amp;lt;double&amp;gt; add(complex&amp;lt;double&amp;gt; a, complex&amp;lt;double&amp;gt; b)
{
    return a + b;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;就可以实现这样的输出，函数的使用更加符合人们日常生活中的逻辑了。&lt;br/&gt;&lt;img src=&quot;https://my-markdown-picture.oss-cn-shanghai.aliyuncs.com/pics/1D1k.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;用函数模板实现函数重载&quot;&gt;用函数模板实现函数重载&lt;/h3&gt;
&lt;div class=&quot;info&quot;&gt;
&lt;p&gt;还是觉得麻烦？&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;C++中有一个更方便的方法，就是使用函数模板。但是函数模板有它的缺点，就是只有除了数据类型不同，其他代码一模一样的函数才能使用函数模板合并，我们上文中例子里的三个函数刚好都符合，那么就可以使用函数模板将他们合并。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;complex&amp;gt;
#include &amp;lt;iostream&amp;gt;
using namespace std;

template &amp;lt;typename T&amp;gt;
T add(T a, T b)
{
    return a + b;
}

int main()
{
    int a = 1, b = 5;
    double x = 1.12, y = 5.36;
    complex&amp;lt;double&amp;gt; m{2.2, 5.4};
    complex&amp;lt;double&amp;gt; n{3.5, 2.1};
    cout &amp;lt;&amp;lt; add(a, b) &amp;lt;&amp;lt; endl;
    cout &amp;lt;&amp;lt; add(x, y) &amp;lt;&amp;lt; endl;
    cout &amp;lt;&amp;lt; add(m, n).real() &amp;lt;&amp;lt; &quot;+&quot; &amp;lt;&amp;lt; add(m, n).imag() &amp;lt;&amp;lt; &quot;i&quot; &amp;lt;&amp;lt; endl;
    cin.get();
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样，我们只需要写一遍逻辑就可以多处重复使用，代码也更加简洁易读。事实上用函数模板写的函数在使用时也可以指定数据类型 &lt;code&gt;add&amp;lt;typename&amp;gt;()&lt;/code&gt;，但为了方便使用，我们一般让编译器从传递给函数的实参推断类型参数，这一功能被称为&lt;code&gt;模板实参推断&lt;/code&gt; 。&lt;/p&gt;
&lt;h2 id=&quot;c系统函数&quot;&gt;C++系统函数&lt;/h2&gt;
&lt;p&gt;除了直接可以根据需求写出我们自己的函数，C++的系统库为我们提供了几百个函数。要使用它们，只需要将函数所在的头文件包含进我们直接的源文件中，便可以直接调用。要知道函数所在的头文件或者想知道C++是否提供了想要的函数，都可以访问&lt;a href=&quot;https://en.cppreference.com/w/&quot;&gt;cppreference&lt;/a&gt;网站查询。&lt;/p&gt;
</description>
<pubDate>Sun, 17 Mar 2019 15:53:00 +0000</pubDate>
<dc:creator>KOKODA</dc:creator>
<og:description>在完成了第三章的学习后，为了便于日后的复习整理，我制作了一张思维导图，有需要的可以自取。 函数的定义与使用 带默认值的函数 在C++中我们可以为函数添加默认的参数值，在调用时可不传入或部分传入参数，为</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/KOKODA/p/10548366.html</dc:identifier>
</item>
<item>
<title>.net辗转java系列（二）IDE - 哲智</title>
<link>http://www.cnblogs.com/zeje/p/10549788.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zeje/p/10549788.html</guid>
<description>&lt;p&gt;上一篇文章&lt;a href=&quot;https://www.cnblogs.com/zeje/p/10544888.html&quot;&gt;.net辗转java系列（一）视野&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;“视野”这篇文章，管理员说它比较空洞！也许初学者看不懂表格中的大部分内容！多年的neter估计也有很多不知道的！&lt;/p&gt;
&lt;p&gt;“辗转”并不代表“转”，它是指反复不定，翻来覆去的样子。所以在此过程，并不是说要弃net而去，也不一定能够完全进入java。懂多一门技术多一条出路。&lt;/p&gt;
&lt;p&gt;小公司一直在模仿大厂，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;华为 DevOps 转型之旅&lt;/li&gt;
&lt;li&gt;微软 DevOps 转型之旅&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;从未得要领，却要求有狼性效应！DevOps，在各个公司的转型过程中表现不同，所获得得成功不同 —— “全栈工程师”，“全能员工” 是企业所要求的，也是最容易动了别人奶酪的！&lt;/p&gt;

&lt;p&gt;要知道，现在（2019-03-17）很多neter，都没有使用最新版本的Visual Studio！为什么呢？因为Out！因为累！因为不思进取！一部分老的neter，特别是做上位机的neter，他们居然不懂.net可以做web服务！&lt;/p&gt;
&lt;p&gt;现在neters，最熟悉的IDE莫过于Visual Studio！即Visual Studio （2003-2019）+ Visual Studio Code。&lt;/p&gt;
&lt;p&gt;很遗憾的是，作为一名老的neter，本人习惯了Visual Studio（2013-2017），习惯了他们的主题！Visual Studio Code我一般只用来写MarkDown！辗转java，如何选择IDE是一件值得纠结的事情！&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;现在Java界最火的IDE是 JetBrains 出品的 IntelliJ IDEA，所以要大势所趋！&lt;/li&gt;
&lt;li&gt;本人最熟悉的是C# + Visual Studio（2013-2017），所以要体验下JetBrains Rider。&lt;/li&gt;
&lt;li&gt;本人次熟悉的是Visual Studio Code，所以要体验下Language support for Java。&lt;/li&gt;
&lt;li&gt;当然，本人也学过Android、Python、Go的基本语法，却从未入坑。后续也会用下JetBrains的Pycharm、GoLand。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;IDEA&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;下载：官网上的文件永远是最新的发布版，到官网（&lt;a href=&quot;https://www.jetbrains.com/&quot;&gt;https://www.jetbrains.com/&lt;/a&gt;）下载IntelliJ IDEA和JetBrains Rider。&lt;/li&gt;
&lt;li&gt;安装：略。&lt;/li&gt;
&lt;li&gt;注册：作为一个学习者，注册问题基本上困扰着每一个人。&lt;/li&gt;
&lt;li&gt;
&lt;/li&gt;
&lt;li&gt;安装完之后的目录，我们对比下&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/87284/201903/87284-20190317235056095-1715290281.png&quot;&gt;&lt;img width=&quot;731&quot; height=&quot;407&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/87284/201903/87284-20190317235059706-339105281.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;剖析 IDEA (JetBrains Rider) 的目录结构&lt;/h3&gt;
&lt;p&gt;正常而言，一个软件安装完成之后，不需要用户去关心软件的安装目录和其中的文件才是合理的。但是深入地剖析一下 IntelliJ IDEA 安装后的文件和目录结构，给我带来了意外的收获。&lt;/p&gt;
&lt;h4&gt;整体结构&lt;/h4&gt;
&lt;p&gt;首先，我们需要知道 IntelliJ IDEA 本身就是一个 Java 应用，所以必须运用于 JRE或者JDK之上。我们看一下该软件安装后的整体目录结构，如下图：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;bin&lt;/code&gt; 是 &lt;code&gt;IDEA&lt;/code&gt; 的可执行代码目录。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;help&lt;/code&gt; 是 &lt;code&gt;IDEA&lt;/code&gt; 的帮助文件目录。&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;打开ReferenceCard.pdf、ReferenceCardForMac.pdf，发现是快捷键说明文档)&lt;/li&gt;
&lt;li&gt;本人英语四级考了4次，每次都是差一点才过。可以说明，英语能力那是一般中的一般，而且还有英文密集恐惧症，那怎么办？&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;作为开发，PDF转HTML难道不懂？自己实现？no！肯定是找线上的！比如：&lt;a title=&quot;http://www.docpe.com/ppt/ppt-to-html.aspx&quot; href=&quot;http://www.docpe.com/ppt/ppt-to-html.aspx&quot;&gt;http://www.docpe.com/ppt/ppt-to-html.aspx&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;网页翻译，百度网页翻译？省省吧！翻译最好的要找谷歌，利用最新Chrome浏览器，右键“翻译成中文”。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;jre64&lt;/code&gt; 是 &lt;code&gt;IDEA&lt;/code&gt; 自带的 &lt;code&gt;JRE&lt;/code&gt; 环境，故 &lt;code&gt;IDEA&lt;/code&gt; 可在未安装 &lt;code&gt;JDK&lt;/code&gt; 的计算机上进行 &lt;code&gt;PHP&lt;/code&gt;、&lt;code&gt;Python&lt;/code&gt;等语言的编码。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lib&lt;/code&gt; 是 &lt;code&gt;IDEA&lt;/code&gt; 依赖的库文件目录，里面有很多的 Jar 文件。&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;其实之前也捣鼓过Idea，说到底是要深入了解学习，所以这个目录我进入看了！&lt;/li&gt;
&lt;li&gt;统计了下有4个文件夹，有199个Jar文件，我看到了作为一个老neter不少熟悉的字眼：httpclient等！&lt;/li&gt;
&lt;li&gt;每个Jar文件都有什么用途？（待）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;license&lt;/code&gt; 是 &lt;code&gt;IDEA&lt;/code&gt; 的许可证文件目录。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;plugins&lt;/code&gt; 是 &lt;code&gt;IDEA&lt;/code&gt; 的插件目录。&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;为了深入学习，我们再进入这个目录看看！&lt;/li&gt;
&lt;li&gt;统计了下有134个文件夹，我又看到了作为一个老neter不少熟悉的字眼：restClient、WebServices 、WebSocket等！&lt;/li&gt;
&lt;li&gt;每个插件到底有何用途？（待）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;redist&lt;/code&gt; 是 &lt;code&gt;IDEA&lt;/code&gt; 中索引机制所依赖的 &lt;code&gt;redist&lt;/code&gt; 库目录。&lt;/li&gt;
&lt;li&gt;两个 .txt 说明文件和一个注册表项文件。&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;执行结构&lt;/h4&gt;
&lt;p&gt;如果只为了熟练掌握 &lt;code&gt;IntelliJ IDEA(JetBrains Rider)&lt;/code&gt; 的使用和配置，仔细查看所有的文件和目录是没有必要的，本文主要看看其中的 bin 目录的几个重要文件。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;idea.exe&lt;/code&gt; 文件是 &lt;code&gt;IntelliJ IDEA&lt;/code&gt; 32位的可执行文件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;idea.exe.vmoptions&lt;/code&gt; 文件是 &lt;code&gt;IntelliJ IDEA&lt;/code&gt; 32位的可执行文件的 JVM 配置文件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;idea.properties&lt;/code&gt; 文件是 &lt;code&gt;IntelliJ IDEA&lt;/code&gt; 的一切全局属性的配置文件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;idea64.exe（rider64.exe）&lt;/code&gt; 文件是 &lt;code&gt;IntelliJ IDEA(JetBrains Rider)&lt;/code&gt;64位的可执行文件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;idea64.exe.vmoptions(rider64.exe.vmoptions)&lt;/code&gt; 文件是 &lt;code&gt;IntelliJ IDEA&lt;/code&gt; (JetBrains Rider) 64位的可执行文件的 JVM 配置文件。&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;idea64.exe.vmoptions 文件&lt;/h4&gt;
&lt;p&gt;正如我们前面所述，&lt;code&gt;IntelliJ IDEA&lt;/code&gt; 本身就是一个 &lt;code&gt;Java&lt;/code&gt; 引用，所以也必须运行于 &lt;code&gt;JVM&lt;/code&gt; 之上。此处的 &lt;code&gt;idea64.exe.vmoptions&lt;/code&gt; 文件就是用来配置64位的 &lt;code&gt;IDEA&lt;/code&gt; 所使用的 &lt;code&gt;JVM&lt;/code&gt; 参数。我们看一下该文件的默认内容：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;对于是否需要修改该文件，需要具体情况具体分析。对于计算机内存配置大于 8G，开发的项目功能复杂的情况，可以进行适当的修改，具体修改值可以通过分析工具，比如 Jconsole等，进行实际情况分析。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;idea.properties 文件&lt;/h4&gt;
&lt;p&gt;虽然 &lt;code&gt;IntelliJ IDEA&lt;/code&gt; 分成了32位和64位两种，但是只存在一份 &lt;code&gt;idea.properties&lt;/code&gt; 文件。该文件的主要作用是完成 &lt;code&gt;IntelliJ IDEA&lt;/code&gt; 的一些个人化配置。该文件内容较多，我们只截图了其中的部分内容：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;该文件中使用了几个属性变量，比如 &lt;code&gt;$(idea.home.path)&lt;/code&gt; 代表了 &lt;code&gt;IDEA&lt;/code&gt; 安装的顶级目录，&lt;code&gt;$(user.home)&lt;/code&gt; 表示用户的根目录等。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;idea.config.path=${user.home}/.IntelliJIdea/config&lt;/code&gt; 指向 &lt;code&gt;IntelliJ IDEA&lt;/code&gt; 的个性化配置目录，默认不启用。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;idea.system.path=${user.home}/.IntelliJIdea/system&lt;/code&gt; 指向 &lt;code&gt;IntelliJ IDEA&lt;/code&gt; 的系统文件目录，默认不启用。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;idea.max.intellisense.filesize=2500&lt;/code&gt; 文件超过此处设置的大小后，关闭该文件的智能检查和提示等功能，有效消除大文件的卡顿问题。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;idea.cycle.buffer.size=1024&lt;/code&gt; 设置控制输出台的缓存大小，解决大项目时，控制台缓存溢出的问题。&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;个性配置&lt;/h4&gt;
&lt;p&gt;现存的三个主流操作系统中，无论是 &lt;code&gt;Windows&lt;/code&gt;、&lt;code&gt;macOS&lt;/code&gt; 还是 &lt;code&gt;Liunx&lt;/code&gt;，都是支持多用户的。&lt;code&gt;IntelliJ IDEA&lt;/code&gt; 支持同一台计算机上的多个用户使用不同的配置选项。所以，在用户的主目录下都具有 &lt;code&gt;IDEA&lt;/code&gt; 的个性化配置目录，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/87284/201903/87284-20190317235100629-268454458.png&quot;&gt;&lt;img width=&quot;297&quot; height=&quot;110&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/87284/201903/87284-20190317235101551-1031270886.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/87284/201903/87284-20190317235102334-1299364223.png&quot;&gt;&lt;img width=&quot;304&quot; height=&quot;118&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/87284/201903/87284-20190317235103187-1223921210.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;该配置目录的最显著特点是：如果删除整个目录，重启 &lt;code&gt;IntelliJ IDEA&lt;/code&gt; 会自动重新生成一个全新的默认配置目录。所以，我们完全可以对 IDEA 进行大胆地修改和配置尝试，一旦需要恢复配置，删除该配置目录就可以了。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;config&lt;/code&gt; 目录是 &lt;code&gt;IntelliJ IDEA&lt;/code&gt; 个人性配置的保存目录，这个目录记录了该 IDE 的所有主要配置值、自定义的代码模板、自定义的快捷键、自定义的文件模板、插件的启用与停用记录等重要信息。实际上，安装新版本 &lt;code&gt;IntelliJ IDEA&lt;/code&gt; 时的默认查找目录就是该目录。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;system&lt;/code&gt; 目录是 &lt;code&gt;IntelliJ IDEA&lt;/code&gt; 的系统文件目录，这个目录记录了该 &lt;code&gt;IDE&lt;/code&gt; 所管理的所有项目信息。该目录主要存储了项目的索引、缓存、容器文件输出等重要资料。&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;主题&lt;/h4&gt;
&lt;p&gt;我把JetBrains Rider的UI Settings 通过 file –&amp;gt; export settings 导出到了压缩文件，再将其导入到 &lt;code&gt;&lt;span&gt;IntelliJ IDEA，希望能能保留点Visual Studio的影子，找回点熟悉感觉！&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;h4&gt;idea代码字体模糊&lt;/h4&gt;
&lt;p&gt;通过 `file` -&amp;gt; `settings` -&amp;gt; `editor` -&amp;gt; `font` 下设置font 为 consolas 或者其他几种，都不会再虚化。&lt;/p&gt;
&lt;h4&gt;官网资料&lt;/h4&gt;
&lt;p&gt;官方的资料一直都是最权威的，也是更新最及时的，我们点击 &lt;code&gt;IntelliJ IDEA&lt;/code&gt; 的菜单 Help –&amp;gt; Help，便可以定位到：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jetbrains.com/help/idea/meet-intellij-idea.html&quot;&gt;https://www.jetbrains.com/help/idea/meet-intellij-idea.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;真TMD都是英文的，哥们英文真一般，那么请谷歌浏览器帮忙吧！右键“翻译成中文”，英文跟中文对比着看，这英文密集恐惧症就不会发作了。&lt;/p&gt;
&lt;h4&gt;创建SpringMVC项目&lt;/h4&gt;
&lt;p&gt;大概文件结构如下，明天上班请教下Java同事，各目录的用途！&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/87284/201903/87284-20190317235104446-1919001203.png&quot;&gt;&lt;img width=&quot;316&quot; height=&quot;265&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/87284/201903/87284-20190317235106049-1572163577.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;完了，截图有水印，等下又要被通报说泄露公司代码了！&lt;/p&gt;
&lt;h2&gt;Visual Studio Code体验Java&lt;/h2&gt;
&lt;p&gt;因为本人之前一直在肤浅的使用Visual Studio Code，故具体的下载、安装就省略了，关于Visual Studio Code的文档，请打开Visual Studio Code，点击菜单栏 –&amp;gt; 帮助 –&amp;gt; 文档，它会帮我们定位到：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://code.visualstudio.com/docs&quot;&gt;https://code.visualstudio.com/docs&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;怎么用Visual Studio Code写Java&lt;/h4&gt;
&lt;p&gt;我们在&lt;a href=&quot;https://code.visualstudio.com/docs&quot;&gt;https://code.visualstudio.com/docs&lt;/a&gt;右上角的输入框中输入java，然后回车&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/87284/201903/87284-20190317235112978-1739918588.png&quot;&gt;&lt;img width=&quot;749&quot; height=&quot;268&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/87284/201903/87284-20190317235115807-535719397.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;差不多就这样了！后续几天还需要继续捣鼓IDE、捡回Core Java。然后这一系列再继续下去吧！&lt;/p&gt;
</description>
<pubDate>Sun, 17 Mar 2019 15:51:00 +0000</pubDate>
<dc:creator>哲智</dc:creator>
<og:description>上一篇文章.net辗转java系列（一）视野废话：“视野”这篇文章，管理员说它比较空洞！也许初学者看不懂表格中的大部分内容！多年的neter估计也有很多不知道的！“辗转”并不代表“转”，它是指反复不定</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zeje/p/10549788.html</dc:identifier>
</item>
<item>
<title>浏览器加载解析渲染网页原理 - 他乡踏雪</title>
<link>http://www.cnblogs.com/ZheOneAndOnly/p/10514287.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ZheOneAndOnly/p/10514287.html</guid>
<description>&lt;ul&gt;&lt;li&gt;浏览器加载网页资源的原理&lt;/li&gt;
&lt;li&gt;JS与CSS阻塞&lt;/li&gt;
&lt;li&gt;重排与重绘&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt; 一、浏览器加载网页资源的原理&lt;/h2&gt;
&lt;p&gt;1、HTML支持的组要资源类型&lt;/p&gt;
&lt;p&gt;在浏览器内核有一个管理资源的对象CachedResource类，在CachedResource类下有很多子类来分工不同的资源管理，这些资源管理子类分别是：&lt;/p&gt;
&lt;table border=&quot;1&quot;&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr&gt;&lt;td&gt; 资源&lt;/td&gt;
&lt;td&gt; 资源管理类&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt; HTML&lt;/td&gt;
&lt;td&gt; MainResource ===&amp;gt; CachedRawResource&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt; JavaScript&lt;/td&gt;
&lt;td&gt; CachedScript&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt; CSS&lt;/td&gt;
&lt;td&gt; CachedCSStyleSheet&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt; 图片&lt;/td&gt;
&lt;td&gt; CachedImage&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt; SVG&lt;/td&gt;
&lt;td&gt; CachedSVGDocument&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt; CSS Shader&lt;/td&gt;
&lt;td&gt; CachedShader&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt; 视频、音频、字幕&lt;/td&gt;
&lt;td&gt; CachedTextTrack&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt; 字体文件&lt;/td&gt;
&lt;td&gt; CachedFont&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt; XSL样式表&lt;/td&gt;
&lt;td&gt; CachedXSLStyleSheet&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;2、资源缓存&lt;/p&gt;
&lt;p&gt;资源的缓存机制是提高资源使用效率的有效方法。基本思想就是建立一个资源缓存池，当web需要请求资源时，会先从资源池中查找是否存在相应的资源，如果有的话就直接取缓存，如果没有就创建一个新的CachedResource子类的对象，并发送请求给服务器（由网络模块完成），请求回来的资源会被添加到资源池，并且将资源(数据信息：比如在资源池中的物理地址)设置到该资源的对象中去，以便下次使用。&lt;/p&gt;
&lt;p&gt;下面是一个缩减版的资源请求原理图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1309608/201903/1309608-20190311222705431-923779466.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;实质上的操作是在资源对象中找到对应资源的物理地址(url)，然后返回给渲染引擎，渲染引擎在渲染页面时根据url获取物理内存中的资源数据。由于资源的唯一特性是url，所以当两个资源有不同的url，但是他们的内容完全相同时，也不会被认定是同一个资源。&lt;/p&gt;
&lt;p&gt;注：这里所说的缓存是内存，不是磁盘。&lt;/p&gt;
&lt;p&gt;3、资源加载器&lt;/p&gt;
&lt;p&gt;在WebKit中共有三种类型的资源加载器，分别是：&lt;/p&gt;
&lt;p&gt;3.1针对每种资源类型的&lt;span&gt;特定加载器&lt;/span&gt;，用来加载某一类资源。例如“image”这个元素，该元素需要图片资源，对应的顶资源加载器是ImageLoader类。&lt;/p&gt;
&lt;p&gt;3.2&lt;span&gt;资源缓存机制的资源加载器，&lt;/span&gt;特点是所有特定加载器都共享它来查找并插入缓存资源——CachedResourceLoader类。特定加载器是通过缓存机制的资源加载器来查找是否有缓存资源，它属于HTML的文档对象。&lt;/p&gt;
&lt;p&gt;3.3&lt;span&gt;通用的资源加载器&lt;/span&gt;——ResourceLoader类，是在WebKit需要从网络或者文件系统获取资源的时候使用该类只负责获得资源的数据，因此被所有特定资源加载器所共享，它属于CachedResource类，与CachedResourceLoader类没有继承关系。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果说资源缓存和网络资源是浏览器要渲染页面的资源实体，那资源加载器就是为浏览器实现页面渲染提供资源数据的搬运工。前面的资源请求相当于就是资源地址寻址的过程，真正为渲染提供资源的过程是下面这样的：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1309608/201903/1309608-20190312021318632-369927145.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个资源加载看起来很复杂，但是模块分工很明确，基于资源对象与内存资源缓存的对应关系（每个缓存资源在资源对象上有一个实例），当浏览器触发资源请求时先通过判断资源是否有缓存资源，如果有的话就就直接拿缓存资源给渲染引擎，如果没有就通过网络请求获取资源给渲染引擎，并且同时会将资源缓存到内存中。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;同CachedResourceLoader对象一样，资源池也属于HTML文档对象，所以资源池不能无限大，对于资源容量不能无限大的问题浏览器的解决方法有两种：第一种是采用LRU（Least Recent Rsed最近最少使用原则）算法。第二种方法是通过HTTP协议决定是否缓存，缓存多久，以及什么时候更新缓存，然后我们开发时还可决定资源如何拆分，拆分可以让我决定哪些资源缓存，哪些资源不缓存。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;当请求协议指定可以取缓存数据，请求资源会先判断内存中是否有资源，然后将资源的信息（版本，缓存时常等）通过HTTP报文一起发送给服务器，服务器通过报文判断缓存的资源是否是最新的，资源缓存是否超时来决定是否重新获取服务端的资源，如果不需要重新获取服务端的资源，服务器会返回状态码304，告诉浏览器取本地缓存资源。&lt;/p&gt;
&lt;p&gt;下面通过Chrome浏览器来请求饿了吗官网，在控制台查看数据请求的资源加载过程，并且通过刷新页面查看当页面刷新时浏览器在缓存中取了哪些信息：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1309608/201903/1309608-20190312032244258-60714572.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接着我们再来刷新页面看看取了哪些缓存数据：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1309608/201903/1309608-20190312033024009-1139325677.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到饿了吗官网的缓存机制是将document主文件和js文件做了缓存处理。这样的处理方式可以很大程度上提高页面性能和降低服务器请求压力，至于为什么就是接下来的内容了。&lt;/p&gt;
&lt;h2&gt; 二、解析HTML标签和CSS样式表、生成DOMTree和CSSTree&lt;/h2&gt;
&lt;p&gt;前面介绍了浏览器资源请求与资源加载的基本原理，看上去好像是一个简单的线性步骤，但是实质上浏览器内部是多进程异步加载这些资源的，我们知道网页的效果是基于DOM结构和CSS样式表来完成基本的页面效果呈现，但是JS代码又可以对DOM节点进行增删该查操作，还可以修改DOM的CSS样式，那必然就是需要先有DOM结构，然后添加CSS样式，再就这两个资源的基础通过JS修改后才能呈现出来，但是什么时候加载(&lt;span&gt;指的是下载资源，并不是前面的资源加载到页面上的整个过程&lt;/span&gt;)?什么时候执行？什么时候渲染页面？按照什么规则来完成这些工作呢。&lt;/p&gt;
&lt;p&gt;通常我们给某个服务器发送一个web请求时，首先返回的是一个HTML资源。假设这个资源的内部代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;http-equiv&lt;/span&gt;&lt;span&gt;=&quot;X-UA-Compatible&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;IE=edge&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;link &lt;/span&gt;&lt;span&gt;rel&lt;/span&gt;&lt;span&gt;=&quot;stylesheet&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;text/css&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;.../css/xxx.css&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;.../image/xxx.png&quot;&lt;/span&gt;&lt;span&gt; alt&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;.../image/xxx.png&quot;&lt;/span&gt;&lt;span&gt; alt&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;.../image/xxx.png&quot;&lt;/span&gt;&lt;span&gt; alt&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;.../javascripts/xxx.js&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;本地获取到了HTML资源后第一步就是解析HTML，也就是常说的DOM解析，首先是创建一个document对象，然后通过DOM解析出每个节点。通过DOM解析发现页面中有css外部样式表需要加载，就立即通过CSS加载器执行加载。解析到img元素发现需要加载图片，就立即通过图片加载器执行加载，这个过程不会等待前面加载的资源加载完成才启动第二个加载，而是通过异步的方法开启多个加载线程，并且浏览器底层会开启多个进程来处理这些线程（Chrome会开启五个进程）。同样解析到了script元素时发现需要外部js资源会立即加载js文件资源。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;深度优先原则解析构建DOM树和CSS树：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;深度优先原则就是对每一个结构顺着第一个内部节点一直往内部解析，直到结构尽头，然后再回退到上一个节点，再对第二个节点执行深入优先原则的解析构建。下图是上面示例请求到的HTML资源的解析流程图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1309608/201903/1309608-20190312201230476-776186024.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;按照示例HTML解析流程图，根据编号顺序按照1--&amp;gt;1.1--&amp;gt;1.2--&amp;gt;1.3--&amp;gt;1.4--&amp;gt;2--&amp;gt;2.1--&amp;gt;2.1.1--&amp;gt;2.1.1.1--&amp;gt;2.1.2--&amp;gt;2.1.2.--&amp;gt;2.1.2.1--&amp;gt;2.1.2.2--&amp;gt;2.1.2.3--&amp;gt;2.2。用一句来表达这种解析原则就是一条道走到黑，开玩笑，但是的确很形象哈。CSS样式表解析和构建CSS树也同样使用这个原则。当DOMTree和CSSTree都构建完成以后就会被合并成渲染树(randerTree)。渲染树解析完毕以后就开始绘制页面。&lt;/p&gt;
&lt;h2&gt; 三、JS与CSS阻塞&lt;/h2&gt;
&lt;p&gt;了解了DOMTree和CSSTree的构建原理，然后合成randerTree绘制页面，但是这个过程怎么能缺少JS呢？有了JS的参与，这个过程就会变得复杂了。首先，CSS资源是异步加载(下载)，在CSS资源加载的过程中，DOM解析会继续执行操作。但是当遇到script标签的时候，如果是外部资源就要立即加载(下载)，如果是内部资源就会立即执行JS代码，立即执行JS代码会阻断HTML的解析(因为JS会操作DOM节点增删改查什么的，还会操作元素样式)，霸道总裁JS就这样让傻媳妇HTML傻呆着让它为所欲为了。就算是外部JS资源加载(下载)的过程HTML的解析也是被阻断的，这个过程是必须等到JS加载(下载)完，然后还要等他执行完才能继续解析HTML。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;img1&quot;&lt;/span&gt;&lt;span&gt; src&lt;/span&gt;&lt;span&gt;=&quot;https://img.baidu.com/search/img/baidulogo_clarity_80_29.gif&quot;&lt;/span&gt;&lt;span&gt; alt&lt;/span&gt;&lt;span&gt;=&quot;Baidu&quot;&lt;/span&gt;&lt;span&gt; align&lt;/span&gt;&lt;span&gt;=&quot;bottom&quot;&lt;/span&gt;&lt;span&gt; border&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 循环5秒钟&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; n &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;Number(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date());
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; n2 &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; Number(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date());
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt;((n2 &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt; n) &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt; (&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;)){
        n2 &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; Number(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date());
    }
    console.log(document.querySelectorAll(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.img1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;NodeList [img.img1]&lt;/span&gt;
&lt;span&gt;    console.log(document.querySelectorAll(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.img2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;NodeList []&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;img2&quot;&lt;/span&gt;&lt;span&gt; src&lt;/span&gt;&lt;span&gt;=&quot;https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268%3Bg%3D0/sign=7aa2c00bdd58ccbf1bbcb23c21e3db03/908fa0ec08fa513defeb0567316d55fbb3fbd9c2.jpg&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; n3 &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; Number(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date() &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt; n2);
    console.log(n3);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;
&lt;span&gt;    console.log(document.querySelectorAll(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.img1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;NodeList [img.img1]&lt;/span&gt;
&lt;span&gt;    console.log(document.querySelectorAll(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.img2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;NodeList [img.img2]&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由上面的示例可以说明js执行会阻塞DOMTree构建，不然在JS等待的10秒里足够解析一个img元素，但是10秒后只能查询到img1，img2查询不到(打印空DOM节点对象)。当第二次打印的时候两个img节点就都获取到了。接着我们来看看外部JS加载会不会阻塞DOMTree构建：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; n &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;Number(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date());
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 设置网速30kb/s测试js是否阻塞渲染 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;https://cdn.staticfile.org//vue/2.2.2//vue.min.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; n3 &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; Number(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date() &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt; n);
    console.log(n3);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;30~40秒 ---- 注释外部js加载代码测试时间差为0秒&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试结果是外部JS的加载也会阻塞HTML解析构建DOMTree。所以结论是JS的加载和执行都会阻塞DOMTree的构建，接着问题又来了，我们前面提到过JS代码会操作DOM还会操作CSS，所以从理论上讲JS肯定得需要等到CSS加载解析完才会执行，CSS阻塞JS执行是肯定的，再思考CSS的加载(下载)会阻塞JS的加载(下载)吗？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Title&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;link &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/css&quot;&lt;/span&gt;&lt;span&gt; rel&lt;/span&gt;&lt;span&gt;=&quot;stylesheet&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;https://cdn.staticfile.org/twitter-bootstrap/3.3.7/css/bootstrap.min.css&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;https://cdn.staticfile.org//vue/2.2.2//vue.min.js&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt; charset&lt;/span&gt;&lt;span&gt;=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt; async defer&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们来看Chrome控制台的时间线：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1309608/201903/1309608-20190313034511402-2145623810.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由Chrome控制台的时间线可以看到外部JS和外部CSS几乎是同时开始加载，CSS加载并没有阻塞JS的加载。既然这样我们再来测试以下CSS加载阻塞JS执行是否是真的？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; n &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; Number(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date());
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;link &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/css&quot;&lt;/span&gt;&lt;span&gt; rel&lt;/span&gt;&lt;span&gt;=&quot;stylesheet&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;https://cdn.staticfile.org/twitter-bootstrap/3.3.7/css/bootstrap.min.css&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    console.log(Number(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date()) &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt; n);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;外部CSS阻塞JS执行40~200毫秒 --- 注释外部CSS代码测试差值0~1毫秒&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可能有人会疑惑我为什么不测试外部CSS会不会阻塞HTML解析，你想想如果CSS阻塞HTML解析那JS加载必须会被阻塞吧，所以CSS加载也就不会阻塞HTML解析了。但是，CSS会阻塞JS执行，也就间接的阻塞了JS后面的DOM解析。&lt;/p&gt;
&lt;p&gt;其实相对来说JS与CSS阻塞还是比较好理解的，毕竟还有可参考的数值和可视的图像信息，接下来的问题就只能依靠逻辑推理了。&lt;/p&gt;
&lt;h2&gt; 四、JS时间线&lt;/h2&gt;
&lt;p&gt;在阐述JS时间线之前，我另外总结了一部分非常重要的内容：JS的异步加载（&lt;a href=&quot;https://www.cnblogs.com/ZheOneAndOnly/p/10527706.html&quot; target=&quot;-bland&quot;&gt;JS异步加载的三种方案&lt;/a&gt;），JS异步加载与下面的内容相关联的内容比较多，建议在了解下面内容之前先了解一下JS异步加载。&lt;/p&gt;
&lt;p&gt;在前面的内容中解析了访问网站获取资源的基本原理，然后资源被访问到本地后怎么解析，解析时发什么的异步资源加载，同步资源加载，同步执行等一系列内容。然后在JS异步加载中提到了&lt;span&gt;script.onload事件、&lt;span&gt;script.onreadystatechange&lt;/span&gt;事件、&lt;span&gt;script.readyState&lt;/span&gt;状态，然后还有document.readyState=&quot;interactive&quot;文档状态和docuement.readyState=&quot;complete&quot;文档状态。这些内容都发生在打开网页的那一瞬间，但是这一瞬间不只是检验物理配置的性能、浏览器内核的性能以及网络的性能，还关系到web开发者基于这些已定的基础平台的代码优化，所以我们有必要对这整个过程有非常清晰的理解，才能实现友好的程序设计。下面我们就通过JS时间线来描述这个过程如何发生的：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;页面加载的五个步骤和JS时间线的十个环节：&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;五个步骤：&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;解析HTML生成DOMTree&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;解释CSS样式表生成CSSTree&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;合并DOMTree和CSSTree生成randerTree&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;randerTree生成完以后开始绘制页面&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;浏览器在解析页面时同时下载页面内容内容数据(异步：图片，src)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;JS时间线之十个环节：&lt;/h3&gt;
&lt;p&gt; 要说是JS时间线的话，可能不是很恰当，或者应该说是文档模型初始化构建过程的JS表示，能够操作DOM对象接口的语言有很多，这里就是用JS来表示DOM对象模型初始化的整个过程。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1.创建document对象，开始解析web页面。解析HTML原始和他们的文件内容添加Element对象和Text节点到文档中。阶段：document.readyState = &quot;loading&quot;。（表示可以触发一次document.&lt;span&gt;onreadystatechange事件）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;2.遇到link外部css，创建线程加载，并继续解析文档。&lt;/li&gt;
&lt;li&gt;3.遇到script外部JS,并没有设置async、defer，浏览器加载，并阻塞，等待JS加载完成并执行脚本，完后继续解析文档。&lt;/li&gt;
&lt;li&gt;4.遇到script外部JS，并且设置async、defer，浏览器创建线程加载，并继续解析文档。&lt;/li&gt;
&lt;li&gt;5.遇到img等外部内容数据，先正常解析DOM结构，然后浏览器异步加载src，并且继续解析文档。&lt;/li&gt;
&lt;li&gt;6.当文档解析完成后。document.readyState = &quot;interactive&quot;。（表示可以触发一次document.&lt;span&gt;onreadystatechange事件&lt;/span&gt;）&lt;/li&gt;
&lt;li&gt;7.文档解析完成后，所有设置有defer的脚本会按照顺序执行。（禁止使用document.wrlte()）。&lt;/li&gt;
&lt;li&gt;8.document对象触发DOMContentLoaded事件，这也标志着程序执行从同步执行阶段，转化为事件取动阶段。(这里开始绘制页面)&lt;/li&gt;
&lt;li&gt;9.当所有async的脚本加载完成，img等加载完成后，document.readyState = &quot;complete&quot;,window对象触发事件。（表示可以触发一次document.&lt;span&gt;onreadystatechange事件&lt;/span&gt;或者标准浏览器可以触发window.onload事件了）&lt;/li&gt;
&lt;li&gt;10.从此，以异步响应方式处理用户输入、网络事件等。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//readyState属性返回当前文档的状态
uninitialized - 还未开始载入
loading - 载入中
interactive - 已加载，文档与用户可以开始交互
complete - 载入完成--loaded&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt; 五、重排/回流与重绘&lt;/h2&gt;
&lt;p&gt;关于重排/回流(reflow)重绘(repaint)简单来说就是会将已经计算好的布局和构建好的渲染树(randerTree)重新计算和构建全部或者部分。这部分发生在DOMTree和CSSTree解析完成以后，也就是会发生在构建randerTree时和之后，这里我们重点关注发生在randerTree构建时的重排/回流和重绘问题，也是网页渲染除了JS、CSS阻塞之后的性能优化区间。&lt;/p&gt;
&lt;p&gt;发生重排/回流与重绘其本质上重新布局和构建randerTree，如果将DOM之前的执行过程理解为同步，这个时候浏览器转为事件取动的异步阶段，浏览器内核在构建randerTree的同时JS也会被事件取动参与修改文档的结构和样式，也是触发重排/回流与重绘行为的关键所在，而本质上做的事情就是重新计算布局和构建randerTree树，所以在解析重排与重绘之前先来了解以下布局计算和randerTree构建：&lt;/p&gt;
&lt;h3&gt; 布局&lt;/h3&gt;
&lt;p&gt;在构建randerTree时并不会把CSS样式表或者行内样式表示元素大小和位置的数据添加到RanderObject上，而是要基于样式设置(如)：width、height、font-size、display、left、top、bottun、right还有borde、padding、margin的大小，结合上下文的相互作用(比如有子元素自适应父级元素大小和位置或者父元素基于子元素定义自身大小和位置)，最后使用RanderObject上的layout()方法计算出确定的元素大小和位置，这个过程layout()方法是递归完成整个计算操作。&lt;/p&gt;
&lt;p&gt;因为布局计算需要基于元素上下节点来进行，元素的大小和位置变化都有可能会影响到父级和子级的元素大小和位置变化，所以randerTree上的某个RanderObject的相关数据发生变化除了自身的layout()方法需要重新执行计算，还可能会触发上下级的节点的layout()方法的重新执行计算。&lt;/p&gt;
&lt;p&gt;所以当构建randerTree的时候由document.&lt;span&gt;onreadystatechange事件、defer的脚本、DOMContentLoaded事件还有不确定的src异步加载的JS脚本都可能在这时候修改元素的大小和位置，甚至修改DOM结构。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;除了脚本的影响外，还有可能是浏览器窗口发生产生变化导致全局的randerTree重新布局计算，另外如果脚本修改了全局的样式也同样可能会触发全局的重新布局计算。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt; 重排/回流(reflow)&lt;/h3&gt;
&lt;p&gt;有了前面对布局的介绍，重排/回流就一目了然了，当由于脚本执行或者浏览器窗口变化，引发RanderObject上的layout()方法重新计算机布局数据，就叫做重排/回流。从字面上的含义来理解重排很容易，就是由于元素的大小和位置变化页面重新排列布局。回流就存在一些逻辑上的理解了，在布局中因为元素节点的位置和大小是存在上下级和同级之间相互影响的，所以如果有脚本修改DOM节点或者大小位置样式，就会对相关连的元素进行判断查找修改的范围指定修改逻辑，制定layout()方法的递归顺序的最优方案，这个查询判断和修改过程就是需要在节点之间来回操作，这也就是回流。实质上重排/回流说的都是一回事。&lt;/p&gt;
&lt;h3&gt; 重绘(repaint)&lt;/h3&gt;
&lt;p&gt;重绘不会影响布局，但是当脚本触发了样式修改，而修改的部分是背景(图片和颜色)、字体颜色、边框颜色等，而这些修改也存在嵌套的节点链级相互影响，所以也是需要遍历操作，重绘不至于影响到布局，但也是一个相对损耗性能的操作，毕竟都需要DOM文档和JS引擎结构之间的桥梁通道来执行操作。不过重绘相对于重排来说就要快的多了。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;重排/回流与重绘是会发生在randerTree构造时，也会发生在randerTree构造结束后，都是相对损耗CPU甚至GPU的操作，只是页面首次渲染更值得的我们关注。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt; 绘制(paint)&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1309608/201903/1309608-20190317231909299-159006565.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当randerTree构建完成以后就会开始绘制页面了，在绘制页面过程中仍然可能发生重排与重绘，但这里需要重点关注的是图层合并，绘制主要是基于CPU的计算来实现，同时浏览器基本上都采用GPU加速的混合模式，其实浏览器本身不需要操作图层合并，因为绘图不管是CPU还是GPU来实现都是基于元素的大小和位置将它们实现的图层，图们本身就在同一个位置，所以无需合并操作。&lt;/p&gt;
&lt;p&gt;CPU主要负责randerTree的绘制工作，它与GPU的配合在不同浏览器内核中会略微不同，但是在同一个位置出现的图层越多，肯定是对性能的损耗就越大。而且由于CPU主要负责randerTree的绘制，多图层就会对GPU带来很大的工作负载，具体包括：CSS3 3D变形、CSS3 3D 变换、WebGL 和 视频。也有浮动，定位，溢出隐藏，z坐标重叠等都是在绘制过程中比较损耗性能的行为。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1309608/201903/1309608-20190317234354179-1196448127.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后经过这样艰难的过程过后，网页终于呈现在我们桌面，但是注意window事件交互不会等待绘制完成，决定window事件交互的是资源是否全部加载完成，这里指的资源是HTML文档包含内容资源，并不包含外部脚本加载的资源。&lt;/p&gt;
&lt;p&gt;(&lt;span&gt;减少重排与重绘的一些要点&lt;/span&gt;)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('7fb53166-f6b6-426d-8298-ab2568bdfc35')&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_7fb53166-f6b6-426d-8298-ab2568bdfc35&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_7fb53166-f6b6-426d-8298-ab2568bdfc35&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('7fb53166-f6b6-426d-8298-ab2568bdfc35',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_7fb53166-f6b6-426d-8298-ab2568bdfc35&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;1：不要通过父级来改变子元素样式，最好直接改变子元素样式，改变子元素样式尽可能不要影响父元素和兄弟元素的大小和尺寸
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;2：尽量通过class来设计元素样式，切忌用style
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;3：实现元素的动画，对于经常要进行回流的组件，要抽离出来，它的position属性应当设为fixed或absolute
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;4：权衡速度的平滑。比如实现一个动画，以1个像素为单位移动这样最平滑，但reflow就会过于频繁，CPU很快就会被完全占用。如果以3个像素为单位移动就会好很多。
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;5：不要用tables布局的另一个原因就是tables中某个元素一旦触发reflow就会导致table里所有的其它元素reflow。在适合用table的场合，可以设置table-layout为auto或fixed，
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;6：这样可以让table一行一行的渲染，这种做法也是为了限制reflow的影响范围。
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;7：css里不要有表达式expression
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;8：减少不必要的 DOM 层级（DOM depth）。改变 DOM 树中的一级会导致所有层级的改变，上至根部，下至被改变节点的子节点。这导致大量时间耗费在执行 reflow 上面。
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;9：避免不必要的复杂的 CSS 选择器，尤其是后代选择器（descendant selectors），因为为了匹配选择器将耗费更多的 CPU。
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;10: 尽量不要过多的频繁的去增加，修改，删除元素，因为这可能会频繁的导致页面reflow，可以先把该dom节点抽离到内存中进行复杂的操作然后再display到页面上。
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 11：请求如下值offsetTop, offsetLeft, offsetWidth, offsetHeight，scrollTop/Left/Width/Height，clientTop/Left/Width/Height，浏览器会发生reflow，建议将他们合并到一起操作，可以减少回流的次数。
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

</description>
<pubDate>Sun, 17 Mar 2019 15:49:00 +0000</pubDate>
<dc:creator>他乡踏雪</dc:creator>
<og:description>浏览器加载网页资源的原理 JS与CSS阻塞 重排与重绘 一、浏览器加载网页资源的原理 1、HTML支持的组要资源类型 在浏览器内核有一个管理资源的对象CachedResource类，在CachedRe</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ZheOneAndOnly/p/10514287.html</dc:identifier>
</item>
<item>
<title>【效率神奇】Github丧心病狂的9个狠招 - 初一丶</title>
<link>http://www.cnblogs.com/wyl-0120/p/10549773.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wyl-0120/p/10549773.html</guid>
<description>&lt;p&gt;&lt;span&gt;Github,一个被业内朋友成为「全球最大的同性交友社区」的平台。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1457234/201903/1457234-20190317233810251-1273181722.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;小时候遇到不会的字可以查新华字典。后来写作文我们可以通过作文书、或者文摘去找合适的素材。同样，写代码可以去Github上找适合自己的代码片段，甚至开源框架。不再重复造轮子，带来的好处不言而喻。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Github在年初宣布个人私有仓库免费，小伙伴们拍手叫好。除了日常的托管代码功能以外。还可以在上面搭建博客，写技术教程或者书籍，发布一些日常的碎碎念，当然你也可以follow一些大佬，关注他们的日常动态。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;今天主要分享一些检索上的技巧，能够帮你更精确的找到需要的项目代码。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;开始之前有必要说一下几个常用词的含义，肯定有很多人不知道&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;watch&lt;/strong&gt;：会持续收到该项目的动态&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;fork&lt;/strong&gt;，复制某个项目到自己的Github仓库中&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;star&lt;/strong&gt;，可以理解为点赞&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;clone&lt;/strong&gt;，将项目下载至本地&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;follow&lt;/strong&gt;，关注你感兴趣的作者，会收到他们的动态&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;通过in关键词限制搜索范围&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;xxx in:name&lt;/strong&gt;  项目名包含xxx的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;xxx in:description&lt;/strong&gt; 项目描述包含xxx的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;xxx in:readme&lt;/strong&gt; 项目的readme文件中包含xxx的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当然也可以通过&lt;strong&gt;xxx in:name,desciption&lt;/strong&gt;来组合使用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如下，我需要搜索项目名或者描述中包含「Hello」的项目，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过&lt;strong&gt;Hello in:name,decription&lt;/strong&gt; 完成&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1457234/201903/1457234-20190317234012538-1814541479.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;通过 Star 或者Fork数 去查找项目&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过通配符 &amp;gt; &amp;lt; = 即可，区间范围内可通过 num1..num2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如，要查找stars数不小于666的springboot项目&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;springboot  stars:&amp;gt;=666&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;forks 大于等于500&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;springboot forks:&amp;gt;500&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;查找fork在100到200之间 且stars数在80到100之间的springboot项目&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;springboot forks:100..200 stars:80..100&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;awesome + 关键字&lt;/strong&gt;&lt;/em&gt;  &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;搜索和关键字匹配的优秀项目&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;awesome springboot 搜索优秀的springboot相关的项目，包括框架、教程等&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1457234/201903/1457234-20190317234048675-604212920.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;分享项目中某一行的代码&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;只需要在具体的网址后面拼接#Lxx(xx为行数)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我需要分享这个类中的@SprintBootApplication注解，值需要在后面拼接上#L6 即可&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
https://github.com/lxy-go/SpringBoot/.../JpaApplication.java#L6
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1457234/201903/1457234-20190317234145886-1533636799.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;项目内搜索&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;打开你想要搜索的项目，然后按一下‘T’键。会跳转至一个新的网页，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1457234/201903/1457234-20190317234154929-1773853099.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;例如我想要搜索该项目的配置文件 application.yml&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1457234/201903/1457234-20190317234221259-1406117202.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;类似的页面内快捷键还有很多，常用的还有’L‘, 在文件内跳转到多少行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;更多快捷键可以查看官方文档&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;https://help.github.com/en/articles/using-keyboard-shortcuts&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;搜索某个地区内的大佬&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以通过location:地区 进行检索，在具体可以通过language:语言  缩小检索范围&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如搜索地区在北京的Java方向的用户&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;location:beijing language:java&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1457234/201903/1457234-20190317234249705-2141172536.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;推荐一些Github插件&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;em&gt;1、O&lt;/em&gt;ctotree&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;平时浏览github代码时，每个文件都需要点击才能查看，用了这个插件可以将项目的目录结构以树形结构显示，点击之后会自动跳转到相应的目录。墙裂推荐！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1457234/201903/1457234-20190317234328243-1397526297.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;em&gt;2、O&lt;/em&gt;ctoLinker&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;浏览代码如果可以像ide那样可以链接跳转岂不是美滋滋，这个插件就可以帮助我们完成这些。只需要ctrl+点击变量名即可。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;3、Sourcegraph&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一个可以在github上浏览和搜索代码的工具，安装好插件之后会出现一个view Repository的按钮&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1457234/201903/1457234-20190317234400431-1217890254.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;点击进去之后，简直不要太爽。可以随意在项目中搜索，可以查看变量和方法，以及进行跳转等等。多说无益，推荐大家安装插件自己感受一下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1457234/201903/1457234-20190317234413702-26294058.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;
&lt;p&gt;&lt;strong&gt;欢迎大家关注我的公众号「&lt;span&gt;程序员共成长&lt;/span&gt;」，每天都会有干货分享&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;在这里插入图片描述&quot; src=&quot;https://img-blog.csdnimg.cn/20190217014313978.jpg&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 17 Mar 2019 15:46:00 +0000</pubDate>
<dc:creator>初一丶</dc:creator>
<og:description>Github,一个被业内朋友成为「全球最大的同性交友社区」的平台。 小时候遇到不会的字可以查新华字典。后来写作文我们可以通过作文书、或者文摘去找合适的素材。同样，写代码可以去Github上找适合自己的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wyl-0120/p/10549773.html</dc:identifier>
</item>
<item>
<title>零基础学Python--------第9章 异常处理及程序调试 - 牧牛人</title>
<link>http://www.cnblogs.com/ooo888ooo/p/10360656.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ooo888ooo/p/10360656.html</guid>
<description>&lt;h2&gt;9.1 异常概述&lt;/h2&gt;
&lt;p&gt;在程序运行过程中，经常会遇到各种各样的错误，这些错误统称为“异常”。这些异常有的是由于开发者将关键字敲错导致的，这类错误多数产生的是SyntaxError:invalid syntax（无效的语法），这将直接导致程序不能运行。这类异常是显式的，在开发阶段很容易被发现。还有一类是隐式的，通常和使用者的操作有关。&lt;/p&gt;
&lt;p&gt;实例01：模拟幼儿园分苹果&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; division():
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;功能：分苹果&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n=====================分苹果======================\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    apple &lt;/span&gt;= int(input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请输入苹果的个数：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;))                         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输入苹果的数量&lt;/span&gt;
    children = int(input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请输入来了几个小朋友：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
    result &lt;/span&gt;= apple//children                                         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 计算每人分几个苹果&lt;/span&gt;
    remain = apple-result*children                                   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 计算余下几个苹果&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; remain&amp;gt;&lt;span&gt;0:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(apple,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;个苹果，平均分给&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,children,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;个小朋友，每人分&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,result,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;个，剩下&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,remain,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;个。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(apple,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;个苹果，平均分给&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,children,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;个小朋友，每人分&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,result,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;个。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    division()                                                       &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 调用分苹果的函数&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;运行程序，当输入苹果和小朋友的数量都是10时：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
请输入苹果的个数：10&lt;span&gt;
请输入来了几个小朋友：&lt;/span&gt;10
10 个苹果，平均分给 10 个小朋友，每人分 1 个。
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果在输入数量时，不小心把小朋友的人数输成了0：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1372012/201903/1372012-20190317213702486-1088064475.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;产生了ZeroDivisionError（除数为0错误）的根源在于算术表达式“10/0”中，0作为除数出现，所以正在执行的程序中被中断（第6行以后，包括第6行的代码都不会被执行）。&lt;/p&gt;
&lt;p&gt;Python中还有很多异常。&lt;/p&gt;
&lt;table border=&quot;2&quot;&gt;&lt;caption&gt;Python中常见的异常&lt;/caption&gt;
&lt;tbody readability=&quot;8&quot;&gt;&lt;tr valign=&quot;middle&quot;&gt;&lt;td&gt;异常&lt;/td&gt;
&lt;td&gt;描述&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;NameError&lt;/td&gt;
&lt;td&gt;尝试访问一个没有声明的变量引发的错误&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;IndexError&lt;/td&gt;
&lt;td&gt;索引超出序列范围引发的错误&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;IndentationError&lt;/td&gt;
&lt;td&gt;缩进错误&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;ValueError&lt;/td&gt;
&lt;td&gt;传入错误&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;KeyError&lt;/td&gt;
&lt;td&gt;请求一个不存在的字典关键字引发的错误&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;IOError&lt;/td&gt;
&lt;td&gt;输入输出错误（如要读取的文件不存在）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;ImportError&lt;/td&gt;
&lt;td&gt;当import语句无法找到模块或from 无法在模块中找到相应的名称时引发的错误&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;AttributeError&lt;/td&gt;
&lt;td&gt;尝试访问未知的对象属性引发的错误&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;TypeError&lt;/td&gt;
&lt;td&gt;类型不合适引发的错误&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;MemoryError&lt;/td&gt;
&lt;td&gt;内存不足&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;ZeroDivisionError&lt;/td&gt;
&lt;td&gt;除数为0 引发的错误&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2&gt;9.2 异常处理语句&lt;/h2&gt;
&lt;p&gt;在程序开发时，有些错误并不是每次运行都会出现。&lt;/p&gt;
&lt;p&gt;下面将详细介绍Python中提供的异常处理语句。&lt;/p&gt;
&lt;h3&gt;9.2.1 try...eccept&lt;/h3&gt;
&lt;p&gt;在Python中，提供了try...except语句捕获并处理异常。在使用时，把可能产生异常的代码放在try 语句块中，把处理结果放在except 语句块中，这样，当try 语句块中的代码出现错误时，就会执行except语句块中的代码，如果try 语句块中的代码没有错误，那么except 语句块将不会执行。具体的语法格式如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
    block1    
&lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; [ExceptionName [as alias]]:
    block2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;参数说明：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;block1：表示可能出现错误的代码块。&lt;/li&gt;
&lt;li&gt;ExceptionName [as alias]:可选参数，用于指定要捕获的异常。其中，ExceptionName表示要捕获的异常名称，如果在其右侧加上as alias，则表示为当前的异常指定一个别名，通过该别名，可以记录异常的具体内容。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;说明：在使用try...except语句捕获异常时，如果在except后面不指定异常名称，则表示捕获全部异常。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;block2：表示进行异常处理的代码块。在这里可以输出固定的提示信息，也可以通过别名输出异常的具体内容。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;说明：使用try...except语句捕获异常后，当程序出错时，输出错误信息后，程序会继续执行。&lt;/p&gt;
&lt;p&gt; 实例02：模拟幼儿园分苹果（除数不能为0）&lt;/p&gt;
&lt;p&gt;对“if __name__ =='__main__':”语句下面的代码进行修改，应用try...except语句捕获执行division()函数可能抛出的ZeroDivisionError（除数为零）异常，修改后的代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; division():
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;功能：分苹果&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n=====================分苹果======================\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    apple &lt;/span&gt;= int(input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请输入苹果的个数：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;))                         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输入苹果的数量&lt;/span&gt;
    children = int(input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请输入来了几个小朋友：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
    result &lt;/span&gt;= apple//children                                         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 计算每人分几个苹果&lt;/span&gt;
    remain = apple-result*children                                   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 计算余下几个苹果&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; remain&amp;gt;&lt;span&gt;0:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(apple,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;个苹果，平均分给&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,children,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;个小朋友，每人分&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,result,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;个，剩下&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,remain,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;个。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(apple,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;个苹果，平均分给&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,children,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;个小朋友，每人分&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,result,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;个。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:                                                                 # 捕获异常
        division()                                                       &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 调用分苹果的函数&lt;/span&gt;
    &lt;span&gt;except&lt;/span&gt; ZeroDivisionError:                                            &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 处理异常&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n出错了 ~_~ ——苹果不能被0个小朋友分！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;执行以上的代码，输入苹果的数量为10，小朋友的人数为0时，将不再抛出异常：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1372012/201903/1372012-20190317215248922-1449956887.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;目前，我们只处理了除数为0的情况，如果将苹果和小朋友的数量输入成小数或者不是数字会是什么结果呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1372012/201903/1372012-20190317215456289-678807827.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看出，程序中要求输入整数，而实际输入的是小数，则抛出ValueError（传入的值错误）异常。要解决该问题，可以在实例02的代码中，为try...except语句再添加一个except语句，用于处理抛出ValueError异常的情况。修改后的代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; division():
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;功能：分苹果&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n=====================分苹果======================\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    apple &lt;/span&gt;= int(input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请输入苹果的个数：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;))                         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输入苹果的数量&lt;/span&gt;
    children = int(input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请输入来了几个小朋友：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
    result &lt;/span&gt;= apple//children                                         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 计算每人分几个苹果&lt;/span&gt;
    remain = apple-result*children                                   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 计算余下几个苹果&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; remain&amp;gt;&lt;span&gt;0:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(apple,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;个苹果，平均分给&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,children,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;个小朋友，每人分&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,result,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;个，剩下&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,remain,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;个。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(apple,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;个苹果，平均分给&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,children,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;个小朋友，每人分&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,result,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;个。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:                                                                 # 捕获异常
        division()                                                       &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 调用分苹果的函数&lt;/span&gt;
    &lt;span&gt;except&lt;/span&gt; ZeroDivisionError:                                            &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 处理异常&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n出错了 ~_~ ——苹果不能被0个小朋友分！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;except&lt;/span&gt; ValueError as e:                                              &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 处理ValueError异常&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;输入错误：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,e)                                             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输出错误原因&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;再次运行程序：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1372012/201903/1372012-20190317221105614-421722849.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;多学两招：&lt;/p&gt;
&lt;p&gt;在捕获异常时，如果需要同时处理多个异常也可以采用下面的代码实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;try&lt;/span&gt;:                                                                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 捕获异常&lt;/span&gt;
        division()                                                       &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 调用分苹果的函数&lt;/span&gt;
    &lt;span&gt;except&lt;/span&gt; (ZeroDivisionError,ValueError) as e:                          &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 处理异常&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;输入错误：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,e)                                            &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输出错误原因&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;即在except语句后面使用一对小括号将可能出现的异常名称括起来，多个异常名称之间使用逗号分隔。如果想要显示具体的出错原因，那么再加上as指定一个别名。&lt;/p&gt;
&lt;h3&gt;9.2.2 try...except...else 语句&lt;/h3&gt;
&lt;p&gt;在Python中国，还有另一种异常处理结构，它是try...except...else语句，也就是在原来try...except语句的基础上再添加一个else子句，用于指定当try语句块中没有发现异常时要执行的语句块。该语句块中的内容当try语句中发现异常，将不被执行。例如，实例02进行修改，实现当division()函数被执行后没有抛出异常时，输出文字“分苹果顺利完成...”。修改后的代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; division():
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;功能：分苹果&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n=====================分苹果======================\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    apple &lt;/span&gt;= int(input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请输入苹果的个数：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;))                         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输入苹果的数量&lt;/span&gt;
    children = int(input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请输入来了几个小朋友：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
    result &lt;/span&gt;= apple//children                                         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 计算每人分几个苹果&lt;/span&gt;
    remain = apple-result*children                                   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 计算余下几个苹果&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; remain&amp;gt;&lt;span&gt;0:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(apple,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;个苹果，平均分给&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,children,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;个小朋友，每人分&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,result,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;个，剩下&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,remain,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;个。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(apple,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;个苹果，平均分给&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,children,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;个小朋友，每人分&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,result,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;个。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;:                                                                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 捕获异常&lt;/span&gt;
        division()                                                       &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 调用分苹果的函数&lt;/span&gt;
    &lt;span&gt;except&lt;/span&gt; ZeroDivisionError                  :                          &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 处理异常&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n出错了 ~_~ ——苹果不能被0个小朋友分！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;except&lt;/span&gt; ValueError as e:                                              &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 处理ValueError异常&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;输入错误：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,e)                                            &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输出错误原因&lt;/span&gt;
    &lt;span&gt;else&lt;/span&gt;:                                                                &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 没有抛出异常时执行&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;分苹果顺利完成...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;执行以上代码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1372012/201903/1372012-20190317223033438-488816338.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;9.2.3 try...except...finally 语句&lt;/h3&gt;
&lt;p&gt;完整的异常处理语句应该包含finally 代码块，通常情况下，无论程序中有无异常产生，finally 代码块中的代码都会被执行，其语法格式如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;try&lt;/span&gt;&lt;span&gt;：
    block1
&lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; [ExceptionName [as alias]]:
    block2
fianlly:
    block3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;对于try...except...finally 语句的理解并不复杂，它只是比try...except 语句多了一个finally 语句，如果程序中有一些在任何情形中都必须执行的代码，那么就可以将它们放在finally 代码块中。&lt;/p&gt;
&lt;p&gt;说明：使用except 子句是为了允许处理异常。无论是否引起了异常，使用finally 子句都是可以执行清理代码。如果分配了有限的资源（如打开文件），则应将释放这些资源的代码放置在finally 代码块中。&lt;/p&gt;
&lt;p&gt;例如，在对实例02进行修改，实现当division() 函数在执行时无论是否抛出异常，都输出文字“进行了一次分苹果操作”。修改后的代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; division():
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;功能：分苹果&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n=====================分苹果======================\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    apple &lt;/span&gt;= int(input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请输入苹果的个数：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;))                         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输入苹果的数量&lt;/span&gt;
    children = int(input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请输入来了几个小朋友：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
    result &lt;/span&gt;= apple//children                                         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 计算每人分几个苹果&lt;/span&gt;
    remain = apple-result*children                                   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 计算余下几个苹果&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; remain&amp;gt;&lt;span&gt;0:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(apple,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;个苹果，平均分给&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,children,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;个小朋友，每人分&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,result,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;个，剩下&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,remain,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;个。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(apple,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;个苹果，平均分给&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,children,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;个小朋友，每人分&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,result,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;个。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;:                                                                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 捕获异常&lt;/span&gt;
        division()                                                       &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 调用分苹果的函数&lt;/span&gt;
    &lt;span&gt;except&lt;/span&gt; ZeroDivisionError                  :                          &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 处理异常&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n出错了 ~_~ ——苹果不能被0个小朋友分！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;except&lt;/span&gt; ValueError as e:                                              &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 处理ValueError异常&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;输入错误：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,e)                                            &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输出错误原因&lt;/span&gt;
    &lt;span&gt;else&lt;/span&gt;:                                                                &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 没有抛出异常时执行&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;分苹果顺利完成...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;:                                                             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 无论是否抛出异常都执行&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;进行了一次分苹果操作。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;执行程序：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1372012/201903/1372012-20190317224316503-1914061652.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，已经介绍了异常处理语句的try....except、try...except...else 和 try...except...finally 等形式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1372012/201903/1372012-20190317225744821-159385040.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;异常处理语句的不同子句的执行关系&lt;/p&gt;
&lt;h3&gt;9.2.4 使用raise 语句抛出异常&lt;/h3&gt;
&lt;p&gt;如果某个函数或方法可能会产生异常，但不想在当前函数或方法中处理这个异常，则可以使用raise 语句在函数或方法中抛出异常。raise 语句的语法格式如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;raise&lt;/span&gt; [ExceptionName[(reason)]]
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其中，ExceptionName[(reason)]为可选参数，用于指定抛出的异常名称以及异常信息的相关描述。如果省略，就会把当前的错误原样抛出。&lt;/p&gt;
&lt;p&gt;说明：ExceptionName[(reason)]参数中的“(reason)”也可以省略，如果省略，则在抛出异常时，不附带任何描述信息。&lt;/p&gt;
&lt;p&gt;例如，修改实例02，加入限制苹果数量必须大于或等于小朋友的数量，从而保证每个小朋友都能至少分到一个苹果。&lt;/p&gt;
&lt;p&gt;实例03：模拟幼儿园分苹果（每个人至少分到一个苹果）&lt;/p&gt;
&lt;p&gt;在第5行代码“children = int(input(&quot;请输入来了几个小朋友：&quot;))”的下方添加一个if 语句，实现当苹果的数量小于小朋友的数量时，应用raise 语句抛出一个ValueError 异常，接下来再在最后一行语句的下方添加except 语句处理ValueError 异常。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; division():
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;功能：分苹果&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n=====================分苹果======================\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    apple &lt;/span&gt;= int(input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请输入苹果的个数：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;))                         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输入苹果的数量&lt;/span&gt;
    children = int(input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请输入来了几个小朋友：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; apple &amp;lt;&lt;span&gt; children:
        &lt;/span&gt;&lt;span&gt;raise&lt;/span&gt; ValueError(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;苹果太少了，不够分...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    result &lt;/span&gt;= apple//children                                         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 计算每人分几个苹果&lt;/span&gt;
    remain = apple - result*children                                   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 计算余下几个苹果&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; remain&amp;gt;&lt;span&gt;0:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(apple,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;个苹果，平均分给&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,children,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;个小朋友，每人分&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,result,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;个，剩下&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,remain,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;个。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(apple,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;个苹果，平均分给&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,children,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;个小朋友，每人分&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,result,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;个。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;:                                                                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 捕获异常&lt;/span&gt;
        division()                                                       &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 调用分苹果的函数&lt;/span&gt;
    &lt;span&gt;except&lt;/span&gt; ZeroDivisionError                  :                          &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 处理ZeroDivisionError异常&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n出错了 ~_~ ——苹果不能被0个小朋友分！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;except&lt;/span&gt; ValueError as e:                                              &lt;span&gt;#&lt;/span&gt;&lt;span&gt; ValueError&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n出错了~_~ ——&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,e)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;执行程序：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1372012/201903/1372012-20190317233217502-1891384863.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;说明：在应用raise 抛出异常时，要尽量选择合理的异常对象，而不应该抛出一个与实际内容不相关的异常。流入，在实例03中，想要处理的是一个和值有关的异常，这时就不应该抛出一个IndentationError异常。&lt;/p&gt;
&lt;h2&gt;9.3 程序调试&lt;/h2&gt;

</description>
<pubDate>Sun, 17 Mar 2019 15:36:00 +0000</pubDate>
<dc:creator>牧牛人</dc:creator>
<og:description>第9章 异常处理及程序调试 9.1 异常概述 在程序运行过程中，经常会遇到各种各样的错误，这些错误统称为“异常”。这些异常有的是由于开发者将关键字敲错导致的，这类错误多数产生的是SyntaxError</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ooo888ooo/p/10360656.html</dc:identifier>
</item>
<item>
<title>自然语言处理系列-4条件随机场（CRF）及其tensorlofw实现 - 小Dream</title>
<link>http://www.cnblogs.com/jen104/p/10549690.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jen104/p/10549690.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　前些天与一位&lt;/span&gt;NLP&lt;span&gt;大牛交流，请教其如何提升技术水平，其跟我讲务必要重视“&lt;/span&gt;&lt;strong&gt;NLP的最基本知识&lt;/strong&gt;”的掌握。掌握好最基本的模型理论，不管是对日常工作和后续论文的发表都有重要的意义。小&lt;span&gt;Dream&lt;/span&gt;&lt;span&gt;听了不禁心里一颤，那些自认为放在“历史尘埃”里的机器学习算法我都只有了解了一个大概，至于&lt;/span&gt;&lt;span&gt;NLP&lt;/span&gt;&lt;span&gt;早期的那些大作也鲜有拜读。心下便决定要好好补一补这个空缺。所以，接下来的数篇文章会相继介绍在&lt;/span&gt;&lt;span&gt;NLP&lt;/span&gt;&lt;span&gt;中应用比较多的一些机器学习模型，隐马尔科夫模型（&lt;/span&gt;&lt;span&gt;HMM&lt;/span&gt;&lt;span&gt;），条件随机场（&lt;/span&gt;&lt;span&gt;CRF&lt;/span&gt;&lt;span&gt;），朴素贝叶斯，支持向量机（&lt;/span&gt;&lt;span&gt;SVM&lt;/span&gt;&lt;span&gt;），&lt;/span&gt;EM算法&lt;span&gt;等相继都会聊到，感兴趣的朋友可以订阅我的博客，或者关注我的微信公众号，会定期更新&lt;/span&gt;NLP&lt;span&gt;相关的文章。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1243524/201903/1243524-20190317231045759-2075660311.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　好了，废话不多说，这篇博客先好好聊聊条件随机场。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;1.&lt;span&gt;条件随机场是什么？&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　条件随机场（&lt;/span&gt;Conditional Random Field&lt;span&gt;，简称&lt;/span&gt;&lt;span&gt;CRF&lt;/span&gt;&lt;span&gt;），是一种判别式无向图模型。机器学习最重要的任务，是根据一些已观察到的证据（例如训练样本）来对感兴趣的未知变量（例如类别标记）进行估计和推测。概率模型提供这样一种描述的框架，将学习任务归结于计算变量的概率分布。在概率模型中，利用已知变量推测未知变量的分布称为“推断”，其核心是如何基于可观测变量推测出未知变量的条件分布。具体来说，假定所关心的变量集合为&lt;/span&gt;&lt;span&gt;Y&lt;/span&gt;&lt;span&gt;，可观测变量集合为&lt;/span&gt;&lt;span&gt;X&lt;/span&gt;&lt;span&gt;，“生成式”模型直接通过训练样本基本联合概率分布&lt;/span&gt;&lt;span&gt;P&lt;/span&gt;&lt;span&gt;（&lt;/span&gt;&lt;span&gt;Y&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;X&lt;/span&gt;&lt;span&gt;）；“判别式”模型通过先计算条件分布&lt;/span&gt;&lt;span&gt;P&lt;/span&gt;&lt;span&gt;（&lt;/span&gt;&lt;span&gt;Y|X&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　通俗来讲，&lt;/span&gt;CRF&lt;span&gt;是在给定一组变量的情况下，求解另一组变量的条件概率的模型。设&lt;/span&gt;&lt;span&gt;X&lt;/span&gt;&lt;span&gt;与&lt;/span&gt;&lt;span&gt;Y&lt;/span&gt;&lt;span&gt;是随机变量，&lt;/span&gt;&lt;span&gt;P&lt;/span&gt;&lt;span&gt;（&lt;/span&gt;&lt;span&gt;Y|X&lt;/span&gt;&lt;span&gt;）是给定随机变量&lt;/span&gt;&lt;span&gt;X&lt;/span&gt;&lt;span&gt;情况下，随机变量&lt;/span&gt;&lt;span&gt;Y&lt;/span&gt;&lt;span&gt;的条件概率。若随机变量&lt;/span&gt;&lt;span&gt;Y&lt;/span&gt;&lt;span&gt;构成一个无向图&lt;/span&gt;&lt;span&gt;G(V,E)&lt;/span&gt;&lt;span&gt;（概率图模型，请看李航，《统计学习方法》&lt;/span&gt;&lt;span&gt;chapter10&lt;/span&gt;&lt;span&gt;），同时，&lt;/span&gt;&lt;span&gt;CRF&lt;/span&gt;&lt;span&gt;满足如下的条件，&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1243524/201903/1243524-20190317231141094-302644859.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　其中，&lt;/span&gt;v&lt;span&gt;表示&lt;/span&gt;&lt;span&gt;G&lt;/span&gt;&lt;span&gt;中的任一节点，&lt;/span&gt;&lt;span&gt;v~V&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;n(v)&lt;/span&gt;&lt;span&gt;表示与&lt;/span&gt;&lt;span&gt;v&lt;/span&gt;&lt;span&gt;有边连接的节点的集合。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;在更多的情况下，应用的都是线性链条件随机场，线性链条件随机场这样定义：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;设&lt;/span&gt;X={X&lt;sub&gt;1&lt;/sub&gt;,X&lt;sub&gt;2&lt;/sub&gt;,X&lt;sub&gt;3&lt;/sub&gt;,....X&lt;sub&gt;n&lt;/sub&gt;}&lt;span&gt;，&lt;/span&gt;&lt;span&gt;Y={Y&lt;/span&gt;&lt;sub&gt;1&lt;/sub&gt;,Y&lt;sub&gt;2&lt;/sub&gt;,Y&lt;sub&gt;3&lt;/sub&gt;,....Y&lt;sub&gt;n&lt;/sub&gt;}&lt;span&gt;均为线性链表示的随机变量序列，若在给定随机变量序列&lt;/span&gt;&lt;span&gt;X&lt;/span&gt;&lt;span&gt;的情况下，随机变量序列&lt;/span&gt;&lt;span&gt;Y&lt;/span&gt;&lt;span&gt;的条件概率&lt;/span&gt;&lt;span&gt;P&lt;/span&gt;&lt;span&gt;（&lt;/span&gt;&lt;span&gt;Y|X&lt;/span&gt;&lt;span&gt;）构成条件随机场，其满足如下的条件：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1243524/201903/1243524-20190317231238985-1099960696.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1243524/201903/1243524-20190317231307395-1083620785.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;X&lt;span&gt;和&lt;/span&gt;&lt;span&gt;Y&lt;/span&gt;&lt;span&gt;具有相同图结构的线性链条件随机场&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　从上面的定义可以看出，条件随机场很适合用于解决序列标注问题问题。例如在分词问题中，&lt;/span&gt;X&lt;span&gt;可以作为输入的句子，&lt;/span&gt;&lt;span&gt;Y&lt;/span&gt;&lt;span&gt;是分词的标注结果。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　上面应该大致讲了条件随机场是个什么样的东西，有什么样的性质。可能到目前为止，同志们应该还是有点云里雾里。反正我在第一次看到这个定义的时候，能够理解上述定义，但是总感觉不通透。后来知道，是没有跟实际结合起来，所以理解不到位。但是在将实际应用之前，还有一个东西需要介绍，就是条件随机场的参数化形式。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; 2.&lt;span&gt;条件随机场的参数化形式&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　我们先列出来&lt;/span&gt;CRF&lt;span&gt;的参数化形式吧。假设&lt;/span&gt;&lt;span&gt;P&lt;/span&gt;&lt;span&gt;（&lt;/span&gt;&lt;span&gt;Y|X&lt;/span&gt;&lt;span&gt;）是随机序列&lt;/span&gt;&lt;span&gt;Y&lt;/span&gt;&lt;span&gt;在给定随机序列&lt;/span&gt;&lt;span&gt;X&lt;/span&gt;&lt;span&gt;情况下的条件随机场，则在随机变量&lt;/span&gt;&lt;span&gt;X&lt;/span&gt;&lt;span&gt;取值为&lt;/span&gt;&lt;span&gt;x&lt;/span&gt;&lt;span&gt;的情况下，随机变量&lt;/span&gt;&lt;span&gt;Y&lt;/span&gt;&lt;span&gt;的取值&lt;/span&gt;&lt;span&gt;y&lt;/span&gt;&lt;span&gt;具有如下关系：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1243524/201903/1243524-20190317231441227-1674827441.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;　　　&lt;span&gt;其中&lt;img src=&quot;https://img2018.cnblogs.com/blog/1243524/201903/1243524-20190317231531230-1567599133.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　　　&lt;/span&gt;t&lt;sub&gt;k&lt;/sub&gt;&lt;span&gt;和&lt;/span&gt;S&lt;sub&gt;l&lt;/sub&gt;&lt;span&gt;是特征函数，&lt;/span&gt;v&lt;sub&gt;k&lt;/sub&gt;&lt;span&gt;和&lt;/span&gt;u&lt;sub&gt;l&lt;/sub&gt;&lt;span&gt;是对应的权值。　　　　&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　好的，假如我们所有的&lt;/span&gt;t&lt;sub&gt;k&lt;/sub&gt;&lt;span&gt;，&lt;/span&gt;s&lt;sub&gt;l&lt;/sub&gt;&lt;span&gt;和&lt;/span&gt;v&lt;sub&gt;k&lt;/sub&gt;&lt;span&gt;，&lt;/span&gt;u&lt;sub&gt;l&lt;/sub&gt;&lt;span&gt;都已知的情况下，我们要算的&lt;/span&gt;P&lt;span&gt;（&lt;/span&gt;&lt;span&gt;Y&lt;/span&gt;&lt;sub&gt;i&lt;/sub&gt; =y&lt;sub&gt;i&lt;/sub&gt;|X&lt;span&gt;）是不是就可以算出来啦？已知的有所谓的前向&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;后向算法。在给定随机序列&lt;/span&gt;&lt;span&gt;X&lt;/span&gt;&lt;span&gt;的情况下，计算概率最大&lt;/span&gt;&lt;span&gt;Y&lt;/span&gt;&lt;span&gt;序列可以用维特比算法，感兴趣的同学可以看李航，《统计学习方法》&lt;/span&gt;&lt;span&gt;chapter11&lt;/span&gt;&lt;span&gt;，我这里就不再赘述了。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　网上绝大部分的博客到这里就结束了，但是大家应该还有一大堆的疑问，&lt;/span&gt;t&lt;sub&gt;k&lt;/sub&gt;&lt;span&gt;，&lt;/span&gt;s&lt;sub&gt;l&lt;/sub&gt;&lt;span&gt;和&lt;/span&gt;v&lt;sub&gt;k&lt;/sub&gt;&lt;span&gt;，&lt;/span&gt;u&lt;sub&gt;l&lt;/sub&gt;&lt;span&gt;如何确定和学习？在实际中我们如何使用？小&lt;/span&gt;Dream&lt;span&gt;如果只讲到这里，就会太让大家失望了。下面我们看看在&lt;/span&gt;&lt;span&gt;tensorflow&lt;/span&gt;&lt;span&gt;里，&lt;/span&gt;&lt;span&gt;CRF&lt;/span&gt;&lt;span&gt;是怎么实现的，以及我们如何使用他，经过这一段，大家对条件随机场应该就会有一个较为完整的认识了。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;3.tensorflow&lt;span&gt;里的条件随机场&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　因为小&lt;/span&gt;Dream&lt;span&gt;之前做过一个用&lt;/span&gt;&lt;span&gt;LSTM+CRF&lt;/span&gt;&lt;span&gt;的命名实体识别项目，这一节我们以命名实体识别为例，来介绍在&lt;/span&gt;&lt;span&gt;tensorflow&lt;/span&gt;&lt;span&gt;里如何使用条件随机场&lt;/span&gt;&lt;span&gt;(CRF)&lt;/span&gt;&lt;span&gt;。命名实力识别与分词一样，是一个序列标注的问题，因为篇幅问题，这里就不展开，不清楚的同学可以出门百度一下，以后我们再找机会，好好讲一下命名实体识别的项目。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;　　LSTM+CRF&lt;span&gt;网络的主要结构如下：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1243524/201903/1243524-20190317231644616-772435749.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　其他的我们先不看，我们只用知道，自然语言的句子经过神经网络进行特征提取之后，会得到一个特征输出，将这个特征和相应的标记（&lt;/span&gt;label&lt;span&gt;）输入到条件随机场中，就可以计算损失了。我们来看看具体的代码。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1243524/201903/1243524-20190317231654862-1123756236.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　这是我定义的损失层，&lt;/span&gt;project_logits&lt;span&gt;是神经网络最后一层的输出，该矩阵的&lt;/span&gt;&lt;span&gt;shape&lt;/span&gt;&lt;span&gt;为&lt;/span&gt;&lt;span&gt;[batch_size, num_steps, num_tags],&lt;/span&gt; &lt;span&gt;第一个是&lt;/span&gt;&lt;span&gt;batch size&lt;/span&gt;&lt;span&gt;，第二个是输入的句子的长度，第三个标记的个数，即命名实体识别总标记的类别数。&lt;/span&gt;&lt;span&gt;targets&lt;/span&gt;&lt;span&gt;是输入句子的&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;，即每个字的&lt;/span&gt;&lt;span&gt;laibel&lt;/span&gt;&lt;span&gt;，它的维度为&lt;/span&gt;&lt;span&gt;[batch_size, num_steps]&lt;/span&gt;&lt;span&gt;。损失层定义了一个&lt;/span&gt;&lt;span&gt;self.trans&lt;/span&gt;&lt;span&gt;矩阵，大小是&lt;/span&gt;&lt;span&gt;[num_tags+1, num_tags+1]&lt;/span&gt;&lt;span&gt;， 加&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;是因为还有一个类别是未定义。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　将&lt;/span&gt;project_logit&lt;span&gt;，&lt;/span&gt;&lt;span&gt;targets&lt;/span&gt;&lt;span&gt;以及&lt;/span&gt;&lt;span&gt;self.trans&lt;/span&gt;&lt;span&gt;交给&lt;/span&gt;&lt;span&gt;tensorflow&lt;/span&gt;&lt;span&gt;的系统函数&lt;/span&gt;&lt;span&gt;crf_log_likelihood&lt;/span&gt;&lt;span&gt;即可求得损失了。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　下面我们进一步来看看&lt;/span&gt;crf_log_likelihood&lt;span&gt;是怎么实现的。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1243524/201903/1243524-20190317231725093-892082175.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1243524/201903/1243524-20190317231751988-1696773376.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　从&lt;/span&gt;crf_sequence_score&lt;span&gt;函数的实现中，我们看出，&lt;/span&gt;&lt;span&gt;tf&lt;/span&gt;&lt;span&gt;中的损失值包括一元损失和二元损失。其中&lt;/span&gt;&lt;span&gt;unary_scores&lt;/span&gt;&lt;span&gt;表示的是标记是输入序列之间的损失，&lt;/span&gt;&lt;span&gt;unary_scores&lt;/span&gt;&lt;span&gt;表示的转化矩阵的损失值。那这两项到底是什么呢？是不是和&lt;/span&gt;&lt;span&gt;CRF&lt;/span&gt;&lt;span&gt;的参数化形式感觉有点像？我们看看相关论文&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;&lt;span&gt;是怎么说的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1243524/201903/1243524-20190317231831400-976773354.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们看一下，得分分为两项，第一项，&lt;/span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1243524/201903/1243524-20190317231908142-1378165584.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　它表示输入句子中，第&lt;/span&gt;i&lt;span&gt;个词，相应标记位置的概率。举个例子，加入输入的句子是“&lt;/span&gt;&lt;span&gt;Mark Watney visit Mars&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;相应的&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;是&lt;/span&gt;&lt;span&gt;[B-PER,E-PER,O,S-LOC]&lt;/span&gt;&lt;span&gt;，则&lt;/span&gt;&lt;span&gt;P&lt;/span&gt;&lt;sub&gt;1&lt;span&gt;，“&lt;/span&gt;&lt;span&gt;B-PER&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;/sub&gt;&lt;span&gt;表示的是第一个词的标记是&lt;/span&gt;B-PER&lt;span&gt;的概率。所以第一项会是&lt;/span&gt;P&lt;sub&gt;1&lt;span&gt;，“&lt;/span&gt;&lt;span&gt;B-PER&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;/sub&gt;+P&lt;sub&gt;2&lt;span&gt;，“&lt;/span&gt;&lt;span&gt;E-PER&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;/sub&gt;+P&lt;sub&gt;3&lt;span&gt;，“&lt;/span&gt;&lt;span&gt;O&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;/sub&gt;+P&lt;sub&gt;4&lt;span&gt;，“&lt;/span&gt;&lt;span&gt;S-LOC&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;/sub&gt;&lt;span&gt;，具体在代码中，就会取到&lt;/span&gt;project_logits&lt;span&gt;矩阵中相应的值，这一点交叉熵有点像，同学们体会一下。第二项，&lt;/span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1243524/201903/1243524-20190317231928754-37568691.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;它代表的是真个序列从一个标记转化到下一个标记的损失值，这个矩阵就是&lt;/span&gt;self.trans&lt;span&gt;，它最开始是按照我们初始化的方式初始化的，然后会随着训练的过程优化。最后再对整个序列的损失值做一个归一化，也就是执行&lt;/span&gt;&lt;span&gt;crf_log_norm&lt;/span&gt;&lt;span&gt;函数。好了，&lt;/span&gt;&lt;span&gt;tensorflow&lt;/span&gt;&lt;span&gt;中&lt;/span&gt;&lt;span&gt;crf&lt;/span&gt;&lt;span&gt;就是这么实现的，是不是有种忽然开朗的感觉？？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我们来做一个总结，&lt;/span&gt;CRF&lt;span&gt;是一个在给定某一个随机序列的情况下，求另一个随机序列的概率分布的概率图模型，在序列标注的问题中有广泛的应用。在&lt;/span&gt;&lt;span&gt;tensorflow&lt;/span&gt;&lt;span&gt;中，实现了&lt;/span&gt;&lt;span&gt;crf_log_likelihood&lt;/span&gt;&lt;span&gt;函数。在本文讲的命名实体识别项目中，自然语言经是已知的序列，自然语言经过特征提取过后的&lt;/span&gt;&lt;span&gt;logits&lt;/span&gt;&lt;span&gt;被当作是&lt;/span&gt;&lt;span&gt;t&lt;/span&gt;&lt;sub&gt;k&lt;/sub&gt;&lt;span&gt;函数，随机初始化的&lt;/span&gt;self.trans&lt;span&gt;矩阵是&lt;/span&gt;&lt;span&gt;S&lt;/span&gt;&lt;sub&gt;l&lt;/sub&gt;&lt;span&gt;函数，随着训练的过程不断的优化。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这就是条件随机场要讲的全部内容啦，欢迎各位评论。后续更新&lt;/span&gt;HMM&lt;span&gt;，&lt;/span&gt;&lt;span&gt;SVM&lt;/span&gt;&lt;span&gt;等，感兴趣的朋友可以关注我的博客或者公众号。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1243524/201903/1243524-20190317232005733-1769285330.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p align=&quot;justify&quot;&gt;[1] &lt;span&gt;周志华&lt;/span&gt;. 机器学习. 清华大学出版社&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;[2] &lt;span&gt;李航&lt;/span&gt; &lt;span&gt;统计学习方法&lt;/span&gt;.清华大学出版社&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;[3]Lample G, Ballesteros M, Subramanian S, et al. Neural architectures for named entity recognition[J]. arXiv preprint arXiv:1603.01360, 2016.&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;分享时刻：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;常常再想，人生大抵苦多乐少。每个人都有太多不想做却又不得不去做的事。那么，何不在心中忘苦常乐，就算人生命有定数，也要活的自在。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 17 Mar 2019 15:34:00 +0000</pubDate>
<dc:creator>小Dream</dc:creator>
<og:description>前些天与一位NLP大牛交流，请教其如何提升技术水平，其跟我讲务必要重视“NLP的最基本知识”的掌握。掌握好最基本的模型理论，不管是对日常工作和后续论文的发表都有重要的意义。小Dream听了不禁心里一颤</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jen104/p/10549690.html</dc:identifier>
</item>
<item>
<title>MySQL索引优化经验总结 - Jasonchan1994</title>
<link>http://www.cnblogs.com/Jasonchan1994/p/10549736.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Jasonchan1994/p/10549736.html</guid>
<description>&lt;p&gt;1.对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。&lt;/p&gt;
&lt;p&gt;2.尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描。&lt;/p&gt;
&lt;p&gt;3.应尽量避免在 where 子句中使用!=或&amp;lt;&amp;gt;操作符，否则引擎将放弃使用索引而进行全表扫描。&lt;/p&gt;
&lt;p&gt;4.应尽量避免在 where 子句中使用or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描。&lt;/p&gt;
&lt;p&gt;5.应尽量避免在 where 子句中使用in 和 not in ，否则会导致全表扫描。&lt;/p&gt;
&lt;p&gt;6.应尽量避免在 where 子句中使用like，否则会导致全表扫描。&lt;/p&gt;
&lt;p&gt;7.如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然 而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。&lt;/p&gt;
&lt;p&gt;8.应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。&lt;/p&gt;
&lt;p&gt;9.应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。&lt;/p&gt;
&lt;p&gt;10.不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。&lt;/p&gt;
&lt;p&gt;11.在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。&lt;/p&gt;
&lt;p&gt;12.并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL查询可能不会去利用索引，如一表中有字段sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用。&lt;/p&gt;
&lt;p&gt;13.索引并不是越多越好，索引固然可 以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。&lt;/p&gt;
</description>
<pubDate>Sun, 17 Mar 2019 15:34:00 +0000</pubDate>
<dc:creator>Jasonchan1994</dc:creator>
<og:description>1.对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。 2.尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Jasonchan1994/p/10549736.html</dc:identifier>
</item>
<item>
<title>JavaScript DOM事件模型 - Westin-Chen</title>
<link>http://www.cnblogs.com/Westin-Chen/p/10549684.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Westin-Chen/p/10549684.html</guid>
<description>&lt;p&gt;　　早期由于浏览器厂商对于浏览器市场的争夺，各家浏览器厂商对同一功能的JavaScript的实现都不进相同，本节内容介绍JavaScript的DOM事件模型及事件处理程序的分类。&lt;/p&gt;
&lt;p&gt;　　1、DOM事件模型。DOM事件模型分为两种：事件冒泡和事件捕获。事件冒泡最初是微软提出的DOM事件流的模型，顾名思义，就是值浏览器的事件流如同冒泡一样，从最低处到最高处。最低处对应的是DOM中最具体的元素，最高处则是最外层元素，最外层元素一般就是document元素。&lt;/p&gt;
&lt;p&gt;　　a、事件冒泡模型：&lt;/p&gt;
&lt;p&gt; 　　　　如下图，当点击最底层的span元素时，在冒泡模型中触发的事件流为：span的click事件触发----&amp;gt;父级元素div的click事件触发----&amp;gt;顶层的document元素的click事件触发。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1553374/201903/1553374-20190317220100787-1853791316.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　b、事件捕获模型：&lt;/p&gt;
&lt;p&gt;　　　　如下图，当点击span元素时，在事件捕获模型中触发的事件流为：最顶层的document的click事件首先被触发----&amp;gt;子容器div（同时也是span的父容器）的click事件被触发&lt;/p&gt;
&lt;p&gt;----&amp;gt;最底层的span元素的click事件触发。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1553374/201903/1553374-20190317220459611-2035869902.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　可见，事件冒泡和事件捕获的事件触发流程是完全相反的。&lt;/p&gt;

&lt;p&gt;　　2、DOM事件处理程序的分类。DOM事件处理程序分为三种：HTML事件处理程序、DOM 0级事件处理程序、DOM 2级事件处理程序（注意：、没有DOM1级事件处理程序）。&lt;/p&gt;
&lt;p&gt;　　a、HTML事件处理程序：&lt;/p&gt;
&lt;p&gt;　　　　指的是事件绑定直接写在HTML上，如:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &amp;lt;input type=&quot;button' value=&quot;button&quot; onclick=&quot;alert('button clicked!')&quot; /&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　这里button的click事件的绑定直接写在HTML中，这种写法即是HTML事件处理程序。由于这种写法造成HTML和JavaScript的紧耦合，当需要调整JavaScript事件时，不得不调整HTML代码（就算不修改JavaScript函数名，只修改函数的内部实现，仍然不推荐使用这种语法绑定事件，会增加不必要的维护成本）。&lt;/p&gt;

&lt;p&gt; 　　b、DOM 0级事件处理程序：&lt;/p&gt;
&lt;p&gt;　　　　指的是通过给JavaScript对象的事件参数属性赋值的模式，如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &amp;lt;input id=&quot;btn&quot; type=&quot;button&quot; value=&quot;button&quot; /&amp;gt;
&lt;span&gt;2&lt;/span&gt; &amp;lt;script&amp;gt;
&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; btn = document.getElementById(&quot;btn&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     btn.onclick = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         alert(&quot;button clicked!&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　这里通过直接给btnDOM对象的onclick属性赋值的形式来绑定click事件就是DOM 0级事件处理程序，赋值可以使用匿名函数的形式，也可以使用具名函数的形式，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &amp;lt;input id=&quot;btn&quot; type=&quot;button&quot; value=&quot;button&quot; /&amp;gt;
&lt;span&gt;2&lt;/span&gt; &amp;lt;script&amp;gt;
&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; btn = document.getElementById(&quot;btn&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;    btn.onclick clickHandle;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; clickHandle(){
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;         alert(&quot;something clicked!&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　如需注销，只需将该属性设置为null即可，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &amp;lt;input id=&quot;btn&quot; type=&quot;button&quot; value=&quot;button&quot; /&amp;gt;
&lt;span&gt;2&lt;/span&gt; &amp;lt;script&amp;gt;
&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; btn = document.getElementById(&quot;btn&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;    btn.onclick clickHandle;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; clickHandle(){
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;         alert(&quot;something clicked!&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;     btn.onclick = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt; &amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　注意：如果绑定使用的是匿名函数的形式，通过给事件属性赋值null仍然可以注销该事件。&lt;/p&gt;

&lt;p&gt;　　c、DOM 2级事件处理程序：&lt;/p&gt;
&lt;p&gt;　　　　指的是使用 addEventListener(&quot;eventName&quot;,&quot;eventHandle&quot;,false)，其中eventName表示事件名称、eventHandle表示事件处理函数，false表示是否启用事件捕获模式，默认为false。使用addEventListener函数来给DOM元素绑定事件处理程序，如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &amp;lt;input id=&quot;btn&quot; type=&quot;button&quot; value=&quot;button&quot; /&amp;gt;
&lt;span&gt;2&lt;/span&gt; &amp;lt;script&amp;gt;
&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; btn = document.getElementById(&quot;btn&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     btn.addEventListener(&quot;click&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         alert(&quot;something clicked!&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     },&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　同样，这里既可以使用匿名函数的形式也可以使用具名函数的形式，如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &amp;lt;input id=&quot;btn&quot; type=&quot;button&quot; value=&quot;button&quot; /&amp;gt;
&lt;span&gt;2&lt;/span&gt; &amp;lt;script&amp;gt;
&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; btn = document.getElementById(&quot;btn&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     btn.addEventListener(&quot;click&quot;,clickHandle,&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; clickHandle(){
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;         alert(&quot;something clicked!&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　注意：通过addEventListener绑定的事件只能通过removeEventListener来注销，不能使用DOM 0级中的方式注销事件处理程序，注销事件如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &amp;lt;input id=&quot;btn&quot; type=&quot;button&quot; value=&quot;button&quot; /&amp;gt;
&lt;span&gt;2&lt;/span&gt; &amp;lt;script&amp;gt;
&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; btn = document.getElementById(&quot;btn&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     btn.addEventListener(&quot;click&quot;,clickHandle,&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; clickHandle(){
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;         alert(&quot;something clicked!&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;     btn.removeEventListener(&quot;click&quot;&lt;span&gt;,clickHandle);
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt; &amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　如果绑定时使用的是匿名函数，则注销操作比较麻烦，可以通过事件参数的callee属性获取当前正在执行的函数，但必须使用在事件绑定的函数内，如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &amp;lt;script&amp;gt;
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; dom=document.getElementById(&quot;content&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; clickNum=0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     dom.addEventListener(&quot;click&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e){
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     clickNum++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     alert('你摸了我'+clickNum+'下了。最多摸2下哦'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(clickNum&amp;gt;=2&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         dom.removeEventListener(e.type,arguments.callee,&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         console.log(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;});
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　d、IE中DOM 2级事件处理程序的是通过attachevent来绑定的，语法与addEventListener完全一致。&lt;/p&gt;

&lt;p&gt;　　e、DOM 0级和DOM 2级事件处理程序的主要区别：&lt;/p&gt;
&lt;p&gt;　　　　DOM 2级事件处理程序可以给元素的事件绑定多个处理程序，如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &amp;lt;input id=&quot;btn&quot; type=&quot;button&quot; value=&quot;button&quot; /&amp;gt;
&lt;span&gt; 2&lt;/span&gt; &amp;lt;script&amp;gt;
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; btn = document.getElementById(&quot;btn&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     btn.addEventListener(&quot;click&quot;,clickHandle1,&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     btn.addEventListener(&quot;click&quot;,clickHandle2,&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; clickHandle1(){
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         alert(&quot;something clicked!&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; clickHandle2(){
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         alert(&quot;something clicked again!&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　此时，点击btn时将会依次触发clickHandle1、clickHandle2，注销事件处理程序也需要针对每个事件处理程序使用removeEventListener。&lt;/p&gt;
&lt;p&gt;　　　    DOM 0级事件处理程序如果以这种形式绑定事件，则后写的方法会覆盖掉之前的方法，即：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &amp;lt;input id=&quot;btn&quot; type=&quot;button&quot; value=&quot;button&quot; /&amp;gt;
&lt;span&gt; 2&lt;/span&gt; &amp;lt;script&amp;gt;
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; btn = document.getElementById(&quot;btn&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     btn.onclick =&lt;span&gt; clickHandle1();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     btn.onclick =&lt;span&gt; clickHandle2();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; clickHandle1(){
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         alert(&quot;something clicked!&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; clickHandle2(){
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         alert(&quot;something clicked again!&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　这里实际只会绑定clickHandle2方法，clickHandle1被后面的clickHandle2覆盖掉。&lt;/p&gt;

&lt;p&gt; 　　开发过程中推荐使用DOM 0级事件处理程序或者DOM 2级事件处理程序，如果只有一个事件处理程序DOM 0级就足够了，当然，如需绑定多个事件处理程序，则需使用DOM 2级事件处理程序。&lt;/p&gt;
&lt;p&gt;　　为了屏蔽各浏览器之间的实现差异，推荐使用一些JavaScript库来辅助完成事件绑定。推荐使用jQuery，针对不同的浏览器，可以使用统一的接口来完成这一过程。&lt;/p&gt;


&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;　　js如何移除匿名函数的事件绑定 - https://www.cnblogs.com/sichaoyun/p/6776310.html&lt;/p&gt;
</description>
<pubDate>Sun, 17 Mar 2019 15:20:00 +0000</pubDate>
<dc:creator>Westin-Chen</dc:creator>
<og:description>早期由于浏览器厂商对于浏览器市场的争夺，各家浏览器厂商对同一功能的JavaScript的实现都不进相同，本节内容介绍JavaScript的DOM事件模型及事件处理程序的分类。 1、DOM事件模型。DO</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Westin-Chen/p/10549684.html</dc:identifier>
</item>
<item>
<title>java日志规约及配置示例终极总结 - 五色花的</title>
<link>http://www.cnblogs.com/luao/p/10549610.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/luao/p/10549610.html</guid>
<description>&lt;h3&gt;目录&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;什么是日志&lt;/li&gt;
&lt;li&gt;常用日志框架&lt;/li&gt;
&lt;li&gt;日志级别详解&lt;/li&gt;
&lt;li&gt;日志的记录时机&lt;/li&gt;
&lt;li&gt;日志使用规约&lt;/li&gt;
&lt;li&gt;logback 配置示例&lt;/li&gt;
&lt;li&gt;loh4j2 配置示例&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;　　简单的说，日志就是记录程序的运行轨迹，方便查找关键信息，也方便快速定位解决问题。我们 Java 程序员在开发项目时都是依赖 Eclipse/ Idea 等开发工具的 Debug 调试功能来跟踪解决 Bug，在开发环境可以这么做，但项目发布到了测试、生产环境呢？你有可能会说可以使用远程调试，但实际并不能允许让你这么做。所以，日志的作用就是在测试、生产环境没有 Debug 调试工具时开发、测试人员定位问题的手段。日志打得好，就能根据日志的轨迹快速定位并解决线上问题，反之，日志输出不好不能定位到问题不说反而会影响系统的性能。优秀的项目都是能根据日志定位问题的，而不是在线调试，或者半天找不到有用的日志。&lt;/p&gt;

&lt;p&gt;　　log4j、Logging、commons-logging、slf4j、logback，开发的同学对这几个日志相关的技术不陌生吧，为什么有这么多日志技术，它们都是什么区别和联系呢？相信大多数人搞不清楚它们的关系，下面我将一一介绍一下，以后大家再也不用傻傻分不清楚了。&lt;/p&gt;
&lt;h3&gt;Logging 【java 自带工具】&lt;/h3&gt;
&lt;p&gt;　　这是 Java 自带的日志工具类，在 JDK 1.5 开始就已经有了，在java.util.logging 包下。&lt;/p&gt;
&lt;h3&gt;Log4j 【框架实现】&lt;/h3&gt;
&lt;p&gt;　　Log4j 是 Apache 的一个开源日志框架，也是市场占有率最多的一个框架。大多数没用过 Java Logging， 但没人敢说没用过 Log4j 吧，反正从我接触 Java 开始就是这种情况，做 Java 项目必有 Log4j 日志框架。注意：log4j 在 2015/08/05 这一天被 Apache 宣布停止维护了，用户需要切换到 Log4j2上面去。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;下面是官方宣布原文&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;On August 5, 2015 the Logging Services Project Management Committee announced that Log4j 1.x had reached end of life. For complete text of the announcement please see the Apache Blog. Users of Log4j 1 are recommended to upgrade to Apache Log4j 2.&lt;/p&gt;
&lt;h3&gt;Commons-logging 【日志接口】&lt;/h3&gt;
&lt;p&gt;　　上面介绍的 log4j 是一个具体的日志框架的实现，而 commons-logging 就是日志门面接口，它也是 apache 最早提供的日志门面接口，用户可以根据喜好选择不同的日志实现框架，而不必改动日志定义，这就是日志门面的好处，符合面向接口抽象编程。&lt;/p&gt;
&lt;h3&gt;Slf4j 【日志接口】&lt;/h3&gt;
&lt;p&gt;　　全称：Simple Logging Facade for Java，即简单日志门面接口，和 Apache 的 commons-logging是一样的概念，它们都不是具体的日志框架，你可以指定其他主流的日志实现框架。Slf4j也是现在主流的日志门面框架，使用Slf4j可以很灵活的使用占位符进行参数占位，简化代码，拥有更好的可读性，这个后面会讲到。&lt;/p&gt;
&lt;h3&gt;Logback 【框架实现】&lt;/h3&gt;
&lt;p&gt;　　Logback 是 Slf4j 的原生实现框架，同样也是出自 Log4j一个人之手，但拥有比log4j更多的优点、特性和更做强的性能，现在基本都用来代替 log4j 成为主流。&lt;/p&gt;
&lt;h3&gt;日志框架总结&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;commons-loggin、slf4j 只是一种日志抽象门面，不是具体的日志框架。&lt;/li&gt;
&lt;li&gt;log4j、logback 是具体的日志实现框架。&lt;/li&gt;
&lt;li&gt;一般首选强烈推荐使用 slf4j + logback。当然也可以使用slf4j + log4j、commons-logging + log4j 这两种日志组合框架。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;　　日志的输出都是分级别的，不同的设置不同的场合打印不同的日志。下面拿最普遍用的 Log4j 日志框架来做个日志级别的说明，这个也比较全面，其他的日志框架也都大同小异。Log4j 的级别类 org.apache.log4j.Level 里面定义了日志级别，日志输出优先级由高到底分别为以下8种。&lt;/p&gt;
&lt;h3&gt;日志级别及描述&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;ERROR：系统发生了错误事件，但仍然不影响系统的继续运行。系统需要将错误或异常细节记录ERROR日志中，方便后续人工回溯解决。&lt;/li&gt;
&lt;li&gt;WARN： 系统在业务处理时触发了异常流程(参数验证不过)，但系统可恢复到正常态，下一次业务可以正常执行。如程序调用了一个旧版本的接口，可选参数不合法，非业务预期的状态但仍可继续处理等&lt;/li&gt;
&lt;li&gt;INFO： 记录系统关键信息，旨在保留系统正常工作期间关键运行指标，开发人员可以将初始化系统配置、业务状态变化信息，或者用户业务流程中的核心处理记录到INFO日志中，方便日常运维工作以及错误回溯时上下文场景复现&lt;/li&gt;
&lt;li&gt;DEBUG： 可以将各类详细信息记录到DEBUG里，起到调试的作用，包括参数信息，调试细节信息，返回值信息等。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;日志优先级别标准顺序&lt;/h3&gt;
&lt;p&gt;　　ALL &amp;lt; TRACE &amp;lt; DEBUG &amp;lt; INFO &amp;lt; WARN &amp;lt; ERROR &amp;lt; FATAL &amp;lt; OFF&lt;/p&gt;
&lt;h3&gt;设置级别和打印级别的关系&lt;/h3&gt;
&lt;p&gt;　　如果日志级别设置 INFO，只有输出级别为 INFO、WARN，后面的日志才会正常输出。&lt;/p&gt;

&lt;h3&gt;系统初始化&lt;/h3&gt;
&lt;p&gt;　　系统初始化时会依赖一些关键配置，根据参数不同会提供不一样的服务。将系统的启动参数记录INFO日志，打印出参数以及服务启动完成状态。&lt;/p&gt;
&lt;h3&gt;业务流程与预期不符&lt;/h3&gt;
&lt;p&gt;　　系统中结果与期望不符，应当记录日志。常见的合适场景包括外部参数不正确，数据处理问题导致返回码不在合理范围内等等。&lt;/p&gt;
&lt;h3&gt;系统核心的关键动作&lt;/h3&gt;
&lt;p&gt;　　系统中核心角色触发的业务动作是需要多加关注的，是衡量系统正常运行的重要指标，建议记录INFO级别日志，比如微服务各服务节点交互等。&lt;/p&gt;
&lt;h3&gt;捕获到异常时&lt;/h3&gt;
&lt;p&gt;　　这类捕获的异常是系统告知开发人员需要加以关注的，应当记录日志，根据实际情况使用warn或者error级别。&lt;/p&gt;
&lt;h3&gt;外部接口日志&lt;/h3&gt;
&lt;p&gt;　　这类日志涉及到与外部系统的交互，事关责任问题，建议将原始数据文件内容写入日志或数据库（如mongodb），核心处理逻辑关键业务数据也尽量写入日志。如果涉及到重发，建议将处理失败的原始数据文件日志写入数据库，以便重发执行。&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;使用@SLF4J中的API进行日志打印。&lt;/li&gt;
&lt;li&gt;日志输出必须采用UTF-8字符集，推荐打印日志时输出英文，防止中文不支持而打印出乱码的情况。&lt;/li&gt;
&lt;li&gt;不允许记录日志后又抛出异常，因为这样会多次记录日志，只允许记录一次日志，应抛出异常，顶层打印一次日志。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
try {
　　// 错误 
} catch (Exception e) { 
　　log.error(&quot;xxxxxx&quot;, e);
　　throw e；
}
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;输出Exceptions的全部堆栈信息，但是不能使用e.printStackTrace()&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
// 错误例子, 丢失掉StackTrace信息 
log.error(e.getMessage()); 
// 错误例子,丢失掉StackTrace信息 
log.error(“Bad things : {}“, e.getMessage()); 
// 正确例子 
log.error(“Bad things : {}“,e); 

// e.printStackTrace()的源码
public void printStackTrace() { 
    printStackTrace(System.err); 
}
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;禁止system.out 用于日志记录。&lt;/li&gt;
&lt;li&gt;线上必须关闭 DEBUG 级别日志。&lt;/li&gt;
&lt;li&gt;非正常的情况，需要根据情况选择打印warn 或 error 日志,不能使用错误的日志级别。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
try { 
// ... 
} catch (Exception e) { 
// 错误LOG.info(&quot;XX 发生异常...&quot;, e); 
}
// 用 info 记录 error 日志，日志输出到了 info 日志文件中了，同事拼命地在 error 错误日志文件里 面找怎么能找到呢？
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;日志输出，必须使用占位符的方式，因为即使信息不打印，也会执行字符串拼接，造成资源浪费。&lt;/li&gt;
&lt;li&gt;日志中不允许出现计算或方法调用，防止在打印日志的时候报错。&lt;/li&gt;
&lt;li&gt;输出的POJO类必须重写toString方法，否则只输出对象的hashCode值，没有参考意义。&lt;/li&gt;
&lt;li&gt;不记录对于排查故障毫无意义的日志信息，日志信息一定要带有业务信息。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
//错误 
log.error(“handle failed“); 
//正确
log.error(“handle failed，id= {}“, id); 
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;禁止大量无效重复的日志输出，通常情况下在程序日志只记录一些有意义的状态数据，参考日志记录时机。&lt;/li&gt;
&lt;li&gt;不可以讲敏感业务信息记录入日志文件。&lt;/li&gt;
&lt;li&gt;严防日志占满磁盘，定期检查磁盘（确定是否有磁盘告警）。&lt;/li&gt;
&lt;li&gt;不要在千层循环中打印日志&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
for(int i=0; i&amp;lt;2000; i++){
LOG.info(&quot;XX&quot;);
}
// 这个是什么意思，如果你的框架使用了性能不高的 Log4j 框架，那就不要在上千个 for 循环中打印日志，
// 这样可能会拖垮你的应用程序，如果你的程序响应时间变慢，那要考虑是不是日志打印的过多了。
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;配置说明&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;统一使用logback.xml配置，logback.xml 文件放在 classpath 目录下。&lt;/li&gt;
&lt;li&gt;所有的jar包中不建议包含logback.xml文件，避免干扰实际的业务系统。&lt;/li&gt;
&lt;li&gt;通过在文件logback.xml中引入资源文件log.properties定义logback属性信息，log.properties根据不同的profile放置在不同位置；&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;property resource=&quot;log.properties&quot;/&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;log.properties文件&lt;/li&gt;
&lt;li&gt;属性命名推荐使用统一使用大写，以下划线分隔，参考&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
APP_NAME = yourAppName
LOG_DIR = /export/home/logs/yourSystem/yourAppName
LOG_PATTERN = [%date{yyyy-MM-dd HH:mm:ss.SSS}] %level [%mdc{invokeNo}] %C{0}:%line - %message%n
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;注意Logger间的继承关系，推荐additivity设置false;&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;子logger会默认继承父logger的appender，将它们加入到自己的Appender中；除非加上了additivity=&quot;false&quot;，则不再继承父logger的appender。&lt;/li&gt;
&lt;li&gt;子logger只在自己未定义输出级别的情况下，才会继承父logger的输出级别。&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;将日志输出到文件当中，禁止使用FileAppender，推荐使用提供自动切换功能的RollingFileAppender Log文件位置和命名，目前Log文件的位置统一放在相同目录下面。&lt;/li&gt;
&lt;/ul&gt;&lt;table border=&quot;0&quot;&gt;&lt;caption&gt; &lt;/caption&gt;
&lt;tbody readability=&quot;4&quot;&gt;&lt;tr&gt;&lt;td&gt;文件名&lt;/td&gt;
&lt;td&gt;描述&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;/export/home/logs&lt;/td&gt;
&lt;td&gt;默认日志路径（所有日志的根路径）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;/export/home/logs/${SYSTEM_NAME}/${APP_NAME}&lt;/td&gt;
&lt;td&gt;log.properties中配置的日志全路径LOG_DIR&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;${LOG_DIR}/all.log&lt;/td&gt;
&lt;td&gt;必选&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;${LOG_DIR}/ all-%d{yyyy-MM-dd}.log&lt;/td&gt;
&lt;td&gt;All历史文件命名&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;${LOG_DIR}/all_error.log&lt;/td&gt;
&lt;td&gt;必选&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;${LOG_DIR}/sql.log&lt;/td&gt;
&lt;td&gt;可选&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;ul&gt;&lt;li&gt;日志按天记录，单个日志文件最大不超过2000MB，考虑到有些bug按月规律出现，推荐历史日志保留30天。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;rollingPolicy &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;fileNamePattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;${LOG_DIR}/all-%d{yyyy-MM-dd}.log&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;fileNamePattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;maxHistory&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;30&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;maxHistory&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;timeBasedFileNamingAndTriggeringPolicy &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;maxFileSize&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2000MB&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;maxFileSize&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;timeBasedFileNamingAndTriggeringPolicy&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;rollingPolicy&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;在出现问题之后，需要立即根据日志定位问题。对于INFO及以上级别的日志，要求按照一定顺序，输出以下必要的信息。参考日志格式定义&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;encoder &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;[%date{yyyy-MM-dd HH:mm:ss.SSS}] %level 
　　[%mdc{invokeNo}] %C{0}:%line - %message%n&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;encoder&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;一个完整的Appender配置如下&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;resource&lt;/span&gt;&lt;span&gt;=&quot;log.properties&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;    
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;contextName&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;${APP_NAME}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;contextName&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;    &lt;br/&gt;　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;appender &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;console&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;ch.qos.logback.core.ConsoleAppender&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;encoder &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　　　　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;${LOG_PATTERN}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　　　&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;encoder&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;appender&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;appender &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;all&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;${LOG_DIR}/all.log&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;rollingPolicy &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;fileNamePattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;${LOG_DIR}/all-%d{yyyy-MM-dd}.%i.log&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;fileNamePattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;maxHistory&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;30&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;maxHistory&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;timeBasedFileNamingAndTriggeringPolicy &lt;br/&gt;　　　　　　&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;    
　　　　　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;maxFileSize&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2000MB&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;maxFileSize&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 每个日志文件大小不超过2GB &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
　　　　&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;timeBasedFileNamingAndTriggeringPolicy&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;rollingPolicy&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;encoder &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;${LOG_PATTERN}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;encoder&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;level&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;info&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;level&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filter&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;appender&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;appender &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;all-error&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;${LOG_DIR}/all-error.log&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;level&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;ERROR&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;level&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;onMatch&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;ACCEPT&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;onMatch&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;onMismatch&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;DENY&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;onMismatch&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filter&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;rollingPolicy &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;fileNamePattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
　　　　　　${LOG_DIR}/all-error-%d{yyyy-MM-dd}.%i.log 
　　　　&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;fileNamePattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;maxHistory&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;30&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;maxHistory&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;timeBasedFileNamingAndTriggeringPolicy&lt;br/&gt;　　　　　  &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　　　　　&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 每个日志文件大小不超过2GB &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
　　　　　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;maxFileSize&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2000MB&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;maxFileSize&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　　　&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;timeBasedFileNamingAndTriggeringPolicy&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;rollingPolicy&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;encoder &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;br/&gt;　　　　　　&lt;/span&gt;&lt;span&gt;[%date{yyyy-MM-dd HH:mm:ss.SSS}] %level [%mdc{invokeNo}] %C{0}:%line - %message%n
　　　　&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;encoder&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;appender&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;br/&gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;root &lt;/span&gt;&lt;span&gt;level&lt;/span&gt;&lt;span&gt;=&quot;debug&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;appender-ref &lt;/span&gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt;=&quot;all&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;appender-ref &lt;/span&gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt;=&quot;all-error&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;appender-ref &lt;/span&gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt;=&quot;console&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;配置说明&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;统一使用log4j2.xml配置，log4j2.xml 文件放在 resource目录下。&lt;/li&gt;
&lt;li&gt;注意Logger间的继承关系，推荐additivity设置false：&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;子logger会默认继承父logger的appender，将它们加入到自己的Appender中；除非加上了additivity=&quot;false&quot;，则不再继承父logger的appender。&lt;/li&gt;
&lt;li&gt;子logger只在自己未定义输出级别的情况下，才会继承父logger的输出级别。&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;将日志输出到文件当中，考虑到RollingRandomAccessFile比RollingFile更灵活，推荐统一使用RollingRandomAccessFile。&lt;/li&gt;
&lt;li&gt;Log文件位置和命名，目前Log文件的位置统一放在相同目录下面。&lt;/li&gt;
&lt;/ul&gt;&lt;table border=&quot;0&quot;&gt;&lt;caption&gt; &lt;/caption&gt;
&lt;tbody readability=&quot;4&quot;&gt;&lt;tr&gt;&lt;td&gt;文件名&lt;/td&gt;
&lt;td&gt;描述 &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;/export/home/logs`&lt;/td&gt;
&lt;td&gt;默认日志路径（所有日志的根路径）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;/export/home/logs/${SYSTEM_NAME}/${APP_NAME}&lt;/td&gt;
&lt;td&gt; log.properties中配置的日志全路径LOG_DIR&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;${LOG_DIR}/all.log&lt;/td&gt;
&lt;td&gt;必选 &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;${LOG_DIR}/ all-%d{yyyy-MM-dd}.log&lt;/td&gt;
&lt;td&gt;All历史文件命名&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;${LOG_DIR}/all_error.log&lt;/td&gt;
&lt;td&gt;必选&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;${LOG_DIR}/sql.log&lt;/td&gt;
&lt;td&gt;可选 &lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;ul&gt;&lt;li&gt;日志按天记录，单个日志文件最大不超过3000MB，考虑到有些bug按周规律出现，推荐历史日志保留14天。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;RollingRandomAccessFile &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;all-append&quot;&lt;/span&gt;&lt;span&gt; immediateFlush&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt; &lt;br/&gt;　　　　fileName&lt;/span&gt;&lt;span&gt;=&quot;${LOG_DIR}/all.log&quot;&lt;/span&gt;&lt;span&gt; filePattern&lt;/span&gt;&lt;span&gt;=&quot;${LOG_DIR}/all-%d{yyyy-MM-dd}-%i.log&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Policies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;SizeBasedTriggeringPolicy &lt;/span&gt;&lt;span&gt;size&lt;/span&gt;&lt;span&gt;=&quot;3GB&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TimeBasedTriggeringPolicy &lt;/span&gt;&lt;span&gt;interval&lt;/span&gt;&lt;span&gt;=&quot;8&quot;&lt;/span&gt;&lt;span&gt; modulate&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 最多备份14天以内||日志文件大小达到50GB的日志||文件数量超过20此处为策略限制，&lt;br/&gt;　　　　Delete中可以按自己需要用正则表达式编写 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;DefaultRolloverStrategy&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Delete &lt;/span&gt;&lt;span&gt;basePath&lt;/span&gt;&lt;span&gt;=&quot;${filePath}&quot;&lt;/span&gt;&lt;span&gt; maxDepth&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;IfLastModified &lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;=&quot;14d&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
　　　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;IfAccumulatedFileSize &lt;/span&gt;&lt;span&gt;exceeds&lt;/span&gt;&lt;span&gt;=&quot;50 GB&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
　　　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;IfAccumulatedFileCount &lt;/span&gt;&lt;span&gt;exceeds&lt;/span&gt;&lt;span&gt;=&quot;20&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Delete&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;DefaultRolloverStrategy&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;在出现问题之后，需要立即根据日志定位问题。对于INFO及以上级别的日志，要求按照一定顺序，输出以下必要的信息。参考日志格式定义&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;PatternLayout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%t] %-5level [%mdc{invokeNo}] %C{2}:%L %M - %msg%n
　　&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;PatternLayout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;一个完整的Appender配置如下&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; Configuration后面的status，这个用于设置log4j2自身内部的信息输出，可以不设置，当设置成trace时，&lt;br/&gt;　　你会看到log4j2内部各种详细输出。monitorInterval：Log4j能够自动检测修改配置文件和重新配置本身，&lt;br/&gt;　　设置间隔秒数。
&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;configuration &lt;/span&gt;&lt;span&gt;status&lt;/span&gt;&lt;span&gt;=&quot;OFF&quot;&lt;/span&gt;&lt;span&gt; monitorInterval&lt;/span&gt;&lt;span&gt;=”600″&amp;gt;
&lt;/span&gt;&lt;span&gt;&amp;lt;properties&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;LOG_PATH&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;/export/home/logs/yourSystem/yourAppName&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;LOG_PATTERN&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%t] %-5level [%mdc{invokeNo}]&lt;br/&gt;　　　　　　　　 %C{2}:%L %M - %msg%n &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;EVERY_FILE_SIZE&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;3GB&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;OUTPUT_LOG_LEVEL&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;info&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;FILE_COUNT&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;20&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;ERROR_FILE_COUNT&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;3&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;properties&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;先定义所有的appender&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;appenders&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;br/&gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;输出控制台的配置&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Console &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;console&quot;&lt;/span&gt;&lt;span&gt; target&lt;/span&gt;&lt;span&gt;=&quot;SYSTEM_OUT&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　　　&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;控制台只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch）&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
　　　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ThresholdFilter &lt;/span&gt;&lt;span&gt;level&lt;/span&gt;&lt;span&gt;=&quot;info&quot;&lt;/span&gt;&lt;span&gt; onMatch&lt;/span&gt;&lt;span&gt;=&quot;ACCEPT&quot;&lt;/span&gt;&lt;span&gt; onMismatch&lt;/span&gt;&lt;span&gt;=&quot;DENY&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
　　　　&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;输出日志的格式&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
　　　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;PatternLayout &lt;/span&gt;&lt;span&gt;pattern&lt;/span&gt;&lt;span&gt;=&quot;${LOG_PATTERN}&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Console&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 打印信息，每次大小超过size，则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩，&lt;br/&gt;　　作为存档&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;RollingRandomAccessFile 
　　&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;all&quot;&lt;/span&gt;&lt;span&gt;
　　immediateFlush&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt; 
　　fileName&lt;/span&gt;&lt;span&gt;=&quot;${LOG_DIR}/all.log&quot;&lt;/span&gt;&lt;span&gt;
　　filePattern&lt;/span&gt;&lt;span&gt;=&quot;${LOG_DIR}/all-%d{yyyy-MM-dd}-%i.log&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Filters&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ThresholdFilter &lt;/span&gt;&lt;span&gt;level&lt;/span&gt;&lt;span&gt;=&quot;error&quot; &lt;/span&gt;&lt;span&gt;onMatch&lt;/span&gt;&lt;span&gt;=&quot;ACCEPT&quot; &lt;/span&gt;&lt;span&gt;onMismatch&lt;/span&gt;&lt;span&gt;=&quot;NEUTRAL&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
　　　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ThresholdFilter &lt;/span&gt;&lt;span&gt;level&lt;/span&gt;&lt;span&gt;=&quot;warn&quot;&lt;/span&gt;&lt;span&gt; onMatch&lt;/span&gt;&lt;span&gt;=&quot;ACCEPT&quot;&lt;/span&gt;&lt;span&gt; onMismatch&lt;/span&gt;&lt;span&gt;=&quot;NEUTRAL&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
　　　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ThresholdFilter &lt;/span&gt;&lt;span&gt;level&lt;/span&gt;&lt;span&gt;=&quot;info&quot;&lt;/span&gt;&lt;span&gt; onMatch&lt;/span&gt;&lt;span&gt;=&quot;ACCEPT&quot;&lt;/span&gt;&lt;span&gt; onMismatch&lt;/span&gt;&lt;span&gt;=&quot;NEUTRAL&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
　　　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ThresholdFilter &lt;/span&gt;&lt;span&gt;level&lt;/span&gt;&lt;span&gt;=&quot;trace&quot; &lt;/span&gt;&lt;span&gt;onMatch&lt;/span&gt;&lt;span&gt;=&quot;DENY&quot;&lt;/span&gt;&lt;span&gt; onMismatch&lt;/span&gt;&lt;span&gt;=&quot;DENY&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Filters&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;PatternLayout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;${LOG_PATTERN}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;PatternLayout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Policies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;SizeBasedTriggeringPolicy &lt;/span&gt;&lt;span&gt;size&lt;/span&gt;&lt;span&gt;=&quot;${EVERY_FILE_SIZE}&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TimeBasedTriggeringPolicy &lt;/span&gt;&lt;span&gt;interval&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt; modulate&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Policies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; DefaultRolloverStrategy属性如不设置，则默认为最多同一文件夹下7个文件，这里设置了20 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt; 
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;DefaultRolloverStrategy&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 最多备14 天以内||日志文件大小达到50GB的日志||文件数量超过20此处为策略限制，Delete中可以按自&lt;br/&gt;　　　　　己需要用正则表达式编写 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Delete &lt;/span&gt;&lt;span&gt;basePath&lt;/span&gt;&lt;span&gt;=&quot;${LOG_DIR}&quot;&lt;/span&gt;&lt;span&gt; maxDepth&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;IfLastModified &lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;=&quot;14d&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
　　　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;IfAccumulatedFileSize &lt;/span&gt;&lt;span&gt;exceeds&lt;/span&gt;&lt;span&gt;=&quot;50 GB&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
　　　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;IfAccumulatedFileCount &lt;/span&gt;&lt;span&gt;exceeds&lt;/span&gt;&lt;span&gt;=&quot;20&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Delete&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;DefaultRolloverStrategy&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;RollingRandomAccessFile&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;RollingRandomAccessFile 
　　&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;all-error&quot;&lt;/span&gt;&lt;span&gt;
　　immediateFlush&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt; 
　　fileName&lt;/span&gt;&lt;span&gt;=&quot;${LOG_DIR}/all-error.log&quot;&lt;/span&gt;&lt;span&gt;
　　filePattern&lt;/span&gt;&lt;span&gt;=&quot;${LOG_DIR}/all-error-%d{yyyy-MM-dd}-%i.log&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Filters&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ThresholdFilter &lt;/span&gt;&lt;span&gt;level&lt;/span&gt;&lt;span&gt;=&quot;error&quot;&lt;/span&gt;&lt;span&gt; onMatch&lt;/span&gt;&lt;span&gt;=&quot;ACCEPT&quot;&lt;/span&gt;&lt;span&gt;onMismatch&lt;/span&gt;&lt;span&gt;=&quot;NEUTRAL&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;　　　　&amp;lt;&lt;/span&gt;&lt;span&gt;ThresholdFilter &lt;/span&gt;&lt;span&gt;level&lt;/span&gt;&lt;span&gt;=&quot;warn&quot;&lt;/span&gt;&lt;span&gt; onMatch&lt;/span&gt;&lt;span&gt;=&quot;ACCEPT&quot;&lt;/span&gt;&lt;span&gt;onMismatch&lt;/span&gt;&lt;span&gt;=&quot;DENY&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;　　&amp;lt;/&lt;/span&gt;&lt;span&gt;Filters&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;PatternLayout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;${LOG_PATTERN}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;PatternLayout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Policies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;SizeBasedTriggeringPolicy &lt;/span&gt;&lt;span&gt;size&lt;/span&gt;&lt;span&gt;=&quot;${EVERY_FILE_SIZE}&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
　　　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TimeBasedTriggeringPolicy &lt;/span&gt;&lt;span&gt;interval&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt; modulate&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Policies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; DefaultRolloverStrategy属性如不设置，则默认为最多同一文件夹下7个文件，这里设置了20 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;DefaultRolloverStrategy &lt;/span&gt;&lt;span&gt;max&lt;/span&gt;&lt;span&gt;=&quot;${ERROR_FILE_COUNT}&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;RollingRandomAccessFile&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;br/&gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;appenders&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;然后定义logger，只有定义了logger并引入的appender，appender才会生效&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;loggers&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;默认的root的logger&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Logger &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;all&quot;&lt;/span&gt;&lt;span&gt; level&lt;/span&gt;&lt;span&gt;=&quot;info&quot;&lt;/span&gt;&lt;span&gt; additivity&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
　　　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;AppenderRef &lt;/span&gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt;=&quot;all&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt; 
　　&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Logger&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Logger &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;all-error&quot;&lt;/span&gt;&lt;span&gt; level&lt;/span&gt;&lt;span&gt;=&quot;error&quot;&lt;/span&gt;&lt;span&gt; additivity&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;span&gt;　　　　&amp;lt;&lt;/span&gt;&lt;span&gt;AppenderRef &lt;/span&gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt;=&quot;all-error&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt; 
　　&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Logger&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;root &lt;/span&gt;&lt;span&gt;level&lt;/span&gt;&lt;span&gt;=&quot;${OUTPUT_LOG_LEVEL}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;appender-ref &lt;/span&gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt;=&quot;console&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;loggers&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;br/&gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Sun, 17 Mar 2019 15:05:00 +0000</pubDate>
<dc:creator>五色花的</dc:creator>
<og:description>目录 1、什么是日志？ 简单的说，日志就是记录程序的运行轨迹，方便查找关键信息，也方便快速定位解决问题。我们 Java 程序员在开发项目时都是依赖 Eclipse/ Idea 等开发工具的 Debug</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/luao/p/10549610.html</dc:identifier>
</item>
</channel>
</rss>