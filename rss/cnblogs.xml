<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>null调整为not null default xxx，不得不注意的坑 - iVictor</title>
<link>http://www.cnblogs.com/ivictor/p/14347901.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ivictor/p/14347901.html</guid>
<description>&lt;p&gt;最近碰到一个case，值得分享一下。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;现象&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;一个DDL，将列的属性从null调整为not null default xxx，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;alter&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; slowtech.t1 modify name &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;10&lt;/span&gt;) &lt;span&gt;not&lt;/span&gt; &lt;span&gt;null&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;slowtech&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过平台执行（平台调用的是pt-online-schema-change）。&lt;/p&gt;
&lt;p&gt;但在执行的过程中，业务SQL报错，提示“ERROR 1048 (23000): Column 'name' cannot be null”。&lt;/p&gt;

&lt;p&gt;在剖析具体的问题之前，首先，我们看看pt-online-schema-change的原理。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;PT-OSC的实现原理&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/576154/202101/576154-20210130075044224-966605335.png&quot; alt=&quot;&quot; width=&quot;1357&quot; height=&quot;1039&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;从原理图中可以看到，&lt;/p&gt;
&lt;p&gt;1.  对于全量数据的同步，pt-online-schema-change是以chunk为单位分批来拷贝的。&lt;/p&gt;
&lt;p&gt;2.  对于增量数据的同步，pt-online-schema-change是通过触发器来实现的。&lt;/p&gt;

&lt;p&gt;结合pt-online-schema-change的原理，我们来重现下问题场景。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
mysql&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;create&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; slowtech.t1(id &lt;span&gt;int&lt;/span&gt; &lt;span&gt;primary&lt;/span&gt; &lt;span&gt;key&lt;/span&gt;,name &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;10&lt;/span&gt;&lt;span&gt;));

mysql&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;create&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; slowtech._t1_new(id &lt;span&gt;int&lt;/span&gt; &lt;span&gt;primary&lt;/span&gt; &lt;span&gt;key&lt;/span&gt;,name &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;10&lt;/span&gt;&lt;span&gt;));

mysql&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;alter&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; slowtech._t1_new modify name &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;10&lt;/span&gt;) &lt;span&gt;not&lt;/span&gt; &lt;span&gt;null&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;slowtech&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

mysql&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;create&lt;/span&gt; &lt;span&gt;trigger&lt;/span&gt; slowtech.`pt_osc_slowtech_t1_ins` after &lt;span&gt;insert&lt;/span&gt; &lt;span&gt;on&lt;/span&gt; `slowtech`.`t1` &lt;span&gt;for&lt;/span&gt; each row &lt;span&gt;replace&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; `slowtech`.`_t1_new` (`id`, `name`) &lt;span&gt;values&lt;/span&gt;&lt;span&gt; (new.`id`, new.`name`);

mysql&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; slowtech.t1(id) &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
ERROR &lt;/span&gt;&lt;span&gt;1048&lt;/span&gt; (&lt;span&gt;23000&lt;/span&gt;): &lt;span&gt;Column&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; cannot be &lt;span&gt;null&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;问题完美呈现，有的童鞋可能会有疑问，t1的name列默认不是null么？为什么不允许null值的插入？&lt;/p&gt;

&lt;p&gt;&lt;span&gt;问题原因&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;问题出在触发器上面。&lt;/p&gt;
&lt;p&gt;触发器会将业务SQL（“insert into slowtech.t1(id) values(1)”）和触发操作（“replace into slowtech._t1_new (id, name) values(1, null)”）放到一个事务内执行。&lt;/p&gt;
&lt;p&gt;“insert into slowtech.t1(id) values(1)”并不违反t1表的约束，但违反了_t1_new表的约束。&lt;/p&gt;

&lt;p&gt;通过上面的分析，我们得到了两点启示：&lt;/p&gt;
&lt;p&gt;1.  类似DDL（将列的属性从null修改为not null default 'abc'）要注意。&lt;/p&gt;
&lt;p&gt;从原理上看，既然涉及到全量数据+增量数据的同步，都会存在这种问题，不单单是pt-online-schema-change，包括Online DDL，gh-ost同样如此。&lt;/p&gt;
&lt;p&gt;只不过，触发器这种方案会将业务SQL和触发操作耦合在一起，相对来说，对业务有一定的侵入性。&lt;/p&gt;

&lt;p&gt;2. 既然触发器会将业务SQL和触发操作放到一个事务内执行，如果pt-online-schema-change异常退出，留下了触发器和中间表（_t1_new），在清理现场时，应首先删除触发器，再删除中间表。&lt;/p&gt;
&lt;p&gt;如果首先删除中间表，会导致针对原表的所有DML操作失败。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
mysql&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;drop&lt;/span&gt; &lt;span&gt;table&lt;/span&gt;&lt;span&gt; slowtech._t1_new;

mysql&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; slowtech.t1 &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;victor&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
ERROR &lt;/span&gt;&lt;span&gt;1146&lt;/span&gt; (42S02): &lt;span&gt;Table&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;slowtech._t1_new&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; doesn&lt;span&gt;'&lt;/span&gt;&lt;span&gt;t exist&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;数据拷贝也有坑&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在执行DDL之前，还有一段小插曲。&lt;/p&gt;
&lt;p&gt;在执行DDL之前，开发提单将该列的null值修改为了默认值。这样就导致了，问题是在业务SQL插入的过程中暴露的，而不是在数据拷贝过程中暴露。&lt;/p&gt;
&lt;p&gt;在数据拷贝的过程中，如果拷贝的数据中，该列存在null值，pt-online-schema-change会直接报错退出。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
mysql&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;create&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; slowtech.t1(id &lt;span&gt;int&lt;/span&gt; &lt;span&gt;primary&lt;/span&gt; &lt;span&gt;key&lt;/span&gt;,name &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;10&lt;/span&gt;&lt;span&gt;));

mysql&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; slowtech.t1(id) &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);

# pt&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;online&lt;span&gt;-&lt;/span&gt;&lt;span&gt;schema&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;change h&lt;span&gt;=&lt;/span&gt;xxxxx,u&lt;span&gt;=&lt;/span&gt;root,p&lt;span&gt;=&lt;/span&gt;&lt;span&gt;123456&lt;/span&gt;,D&lt;span&gt;=&lt;/span&gt;slowtech,t&lt;span&gt;=&lt;/span&gt;t1 &lt;span&gt;--&lt;/span&gt;&lt;span&gt;alter &quot;modify name varchar(10) not null default 'slowtech'&quot; --execute&lt;/span&gt;
No slaves found.  See &lt;span&gt;--&lt;/span&gt;&lt;span&gt;recursion-method if host xxxx has slaves.&lt;/span&gt;
&lt;span&gt;Not&lt;/span&gt; checking slave lag because no slaves were found &lt;span&gt;and&lt;/span&gt; &lt;span&gt;--&lt;/span&gt;&lt;span&gt;check-slave-lag was not specified.&lt;/span&gt;
&lt;span&gt;Operation, tries, wait:
  analyze_table, &lt;/span&gt;&lt;span&gt;10&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;
  copy_rows, &lt;/span&gt;&lt;span&gt;10&lt;/span&gt;, &lt;span&gt;0.25&lt;/span&gt;&lt;span&gt;
  create_triggers, &lt;/span&gt;&lt;span&gt;10&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;
  drop_triggers, &lt;/span&gt;&lt;span&gt;10&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;
  swap_tables, &lt;/span&gt;&lt;span&gt;10&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;
  update_foreign_keys, &lt;/span&gt;&lt;span&gt;10&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;
Altering `slowtech`.`t1`...
Creating new &lt;/span&gt;&lt;span&gt;table&lt;/span&gt;&lt;span&gt;...
Created new &lt;/span&gt;&lt;span&gt;table&lt;/span&gt;&lt;span&gt; slowtech._t1_new OK.
Altering new &lt;/span&gt;&lt;span&gt;table&lt;/span&gt;&lt;span&gt;...
Altered `slowtech`.`_t1_new` OK.
&lt;/span&gt;&lt;span&gt;2020&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;09&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;07T09:&lt;span&gt;13&lt;/span&gt;:&lt;span&gt;25&lt;/span&gt;&lt;span&gt; Creating triggers...
&lt;/span&gt;&lt;span&gt;2020&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;09&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;07T09:&lt;span&gt;13&lt;/span&gt;:&lt;span&gt;25&lt;/span&gt;&lt;span&gt; Created triggers OK.
&lt;/span&gt;&lt;span&gt;2020&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;09&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;07T09:&lt;span&gt;13&lt;/span&gt;:&lt;span&gt;25&lt;/span&gt; Copying approximately &lt;span&gt;1&lt;/span&gt;&lt;span&gt; rows...
&lt;/span&gt;&lt;span&gt;2020&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;09&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;07T09:&lt;span&gt;13&lt;/span&gt;:&lt;span&gt;25&lt;/span&gt;&lt;span&gt; Dropping triggers...
&lt;/span&gt;&lt;span&gt;2020&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;09&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;07T09:&lt;span&gt;13&lt;/span&gt;:&lt;span&gt;25&lt;/span&gt;&lt;span&gt; Dropped triggers OK.
&lt;/span&gt;&lt;span&gt;2020&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;09&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;07T09:&lt;span&gt;13&lt;/span&gt;:&lt;span&gt;25&lt;/span&gt; Dropping new &lt;span&gt;table&lt;/span&gt;&lt;span&gt;...
&lt;/span&gt;&lt;span&gt;2020&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;09&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;07T09:&lt;span&gt;13&lt;/span&gt;:&lt;span&gt;25&lt;/span&gt; Dropped new &lt;span&gt;table&lt;/span&gt;&lt;span&gt; OK.
`slowtech`.`t1` was &lt;/span&gt;&lt;span&gt;not&lt;/span&gt;&lt;span&gt; altered.
        (&lt;/span&gt;&lt;span&gt;in&lt;/span&gt; cleanup) &lt;span&gt;2020&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;09&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;07T09:&lt;span&gt;13&lt;/span&gt;:&lt;span&gt;25&lt;/span&gt; Error copying rows &lt;span&gt;from&lt;/span&gt; `slowtech`.`t1` &lt;span&gt;to&lt;/span&gt; `slowtech`.`_t1_new`: &lt;span&gt;2020&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;09&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;07T09:&lt;span&gt;13&lt;/span&gt;:&lt;span&gt;25&lt;/span&gt; Copying rows caused a MySQL error &lt;span&gt;1048&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;Level&lt;/span&gt;&lt;span&gt;: Warning
     Code: &lt;/span&gt;&lt;span&gt;1048&lt;/span&gt;&lt;span&gt;
  Message: &lt;/span&gt;&lt;span&gt;Column&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; cannot be &lt;span&gt;null&lt;/span&gt;&lt;span&gt;
    Query: &lt;/span&gt;&lt;span&gt;INSERT&lt;/span&gt; LOW_PRIORITY IGNORE &lt;span&gt;INTO&lt;/span&gt; `slowtech`.`_t1_new` (`id`, `name`) &lt;span&gt;SELECT&lt;/span&gt; `id`, `name` &lt;span&gt;FROM&lt;/span&gt; `slowtech`.`t1` LOCK &lt;span&gt;IN&lt;/span&gt; SHARE MODE &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;pt-online-schema-change 9234 copy table&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;2020&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;09&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;07T09:&lt;span&gt;13&lt;/span&gt;:&lt;span&gt;25&lt;/span&gt;&lt;span&gt; Dropping triggers...
&lt;/span&gt;&lt;span&gt;2020&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;09&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;07T09:&lt;span&gt;13&lt;/span&gt;:&lt;span&gt;25&lt;/span&gt;&lt;span&gt; Dropped triggers OK.
`slowtech`.`t1` was &lt;/span&gt;&lt;span&gt;not&lt;/span&gt; altered.
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上述报错，pt-online-schema-change加个参数即可规避（--null-to-not-null）。&lt;/p&gt;
&lt;p&gt;在实现上，该参数会忽略1048错误，此时，对于字符类型的列，会填充空字符，对于数字类型的列，会填充0。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
mysql&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;create&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; slowtech.t1(id &lt;span&gt;int&lt;/span&gt; &lt;span&gt;primary&lt;/span&gt; &lt;span&gt;key&lt;/span&gt;,name &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;10&lt;/span&gt;&lt;span&gt;));

mysql&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;create&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; slowtech._t1_new(id &lt;span&gt;int&lt;/span&gt; &lt;span&gt;primary&lt;/span&gt; &lt;span&gt;key&lt;/span&gt;,name &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;10&lt;/span&gt;&lt;span&gt;));

mysql&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;alter&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; slowtech._t1_new modify name &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;10&lt;/span&gt;) &lt;span&gt;not&lt;/span&gt; &lt;span&gt;null&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;slowtech&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

mysql&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; slowtech.t1(id) &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);

mysql&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt;&lt;span&gt; slowtech.t1;
&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; id &lt;span&gt;|&lt;/span&gt; name &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+------+&lt;/span&gt;
&lt;span&gt;1&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.00&lt;/span&gt;&lt;span&gt; sec)

mysql&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;insert&lt;/span&gt; low_priority ignore &lt;span&gt;into&lt;/span&gt; slowtech._t1_new (id, name) &lt;span&gt;select&lt;/span&gt; id, name &lt;span&gt;from&lt;/span&gt; slowtech.t1 lock &lt;span&gt;in&lt;/span&gt;&lt;span&gt; share mode;
Query OK, &lt;/span&gt;&lt;span&gt;1&lt;/span&gt; row affected, &lt;span&gt;1&lt;/span&gt; warning (&lt;span&gt;0.01&lt;/span&gt;&lt;span&gt; sec)
Records: &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;  Duplicates: &lt;span&gt;0&lt;/span&gt;  Warnings: &lt;span&gt;1&lt;/span&gt;&lt;span&gt;

mysql&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt; show warnings;
&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-------+------+------------------------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; &lt;span&gt;Level&lt;/span&gt;   &lt;span&gt;|&lt;/span&gt; Code &lt;span&gt;|&lt;/span&gt; Message                      &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-------+------+------------------------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; Warning &lt;span&gt;|&lt;/span&gt; &lt;span&gt;1048&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;Column&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; cannot be &lt;span&gt;null&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-------+------+------------------------------+&lt;/span&gt;
&lt;span&gt;1&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.00&lt;/span&gt;&lt;span&gt; sec)

mysql&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt;&lt;span&gt; slowtech._t1_new;
&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; id &lt;span&gt;|&lt;/span&gt; name &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;      &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+------+&lt;/span&gt;
&lt;span&gt;1&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.00&lt;/span&gt; sec)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所以，线上使用该参数要注意，要确认被填充的值是否符合自己的预期行为。&lt;/p&gt;

&lt;p&gt;从目前的分析来看，要将一个列的属性从null直接修改为not null default xxx，几乎是不可能的，除非：&lt;/p&gt;
&lt;p&gt;1.  该列不存在null值。&lt;/p&gt;
&lt;p&gt;2.  在DDL的过程中，没有类似于“insert into slowtech.t1(id) values(1)”的业务SQL出现。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;结论&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;很显然，这两个条件很难同时满足。既然如此，这个需求还能实现吗？能！只不过比较复杂。&lt;/p&gt;
&lt;p&gt;下面，看看具体的实施步骤。&lt;/p&gt;
&lt;p&gt;1. 首先，将列的属性调整为null default xxx，这样做的目的是为了避免增量同步过程中，类似“insert into slowtech.t1(id) values(1)”的业务SQL，产生新的null值。&lt;/p&gt;
&lt;p&gt;2. 其次，手动将null值调整为默认值。需要注意的是，如果记录数较多，这一步的操作难度也是极大的。&lt;/p&gt;
&lt;p&gt;3. 最后，将列的属性调整为not null default xxx。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;对于not null default xxx的正确理解&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在很多数据库规范里面，都推荐将列定义为not null default xxx，但很多童鞋，对这段定义的实际效果却相当模糊。&lt;/p&gt;
&lt;p&gt;下面具体来说说，这段定义的实际作用。这段定义实际上由两部分组成：&lt;/p&gt;
&lt;p&gt;1.  not null，约束，指的是不可显式插入null值，如，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
mysql&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;create&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; slowtech.t1(id &lt;span&gt;int&lt;/span&gt; &lt;span&gt;primary&lt;/span&gt; &lt;span&gt;key&lt;/span&gt;,name &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;10&lt;/span&gt;) &lt;span&gt;not&lt;/span&gt; &lt;span&gt;null&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;slowtech&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);

mysql&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; slowtech.t1 &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
ERROR &lt;/span&gt;&lt;span&gt;1048&lt;/span&gt; (&lt;span&gt;23000&lt;/span&gt;): &lt;span&gt;Column&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; cannot be &lt;span&gt;null&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.  default 'slowtech'，如果在插入时，没有显式指定值，则以默认值填充。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
mysql&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; slowtech.t1(id) &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);

mysql&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt;&lt;span&gt; slowtech.t1;
&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+----------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; id &lt;span&gt;|&lt;/span&gt; name     &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+----------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; slowtech &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+----------+&lt;/span&gt;
&lt;span&gt;1&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.00&lt;/span&gt; sec)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到，这两部分其实没有任何关系，对于一个列，我们同样可以定义为null default xxx。&lt;/p&gt;

</description>
<pubDate>Fri, 29 Jan 2021 23:55:00 +0000</pubDate>
<dc:creator>iVictor</dc:creator>
<og:description>最近碰到一个case，值得分享一下。 现象 一个DDL，将列的属性从null调整为not null default xxx， alter table slowtech.t1 modify name v</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ivictor/p/14347901.html</dc:identifier>
</item>
<item>
<title>Linux常用命令：文件操作命令 - 测试开发小记</title>
<link>http://www.cnblogs.com/hiyong/p/14170537.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hiyong/p/14170537.html</guid>
<description>&lt;p&gt;Linux系统命令主要包括文件操作、网络命令和性能命令，本文介绍常用文件操作命令。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2229336/202012/2229336-20201221223521969-1694389676.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;文件类型：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;普通文件：-&lt;/li&gt;
&lt;li&gt;目录文件：d&lt;/li&gt;
&lt;li&gt;块设备文件：b，硬盘&lt;/li&gt;
&lt;li&gt;字符设备： c，串行端口的接口设备，例如键盘、鼠标&lt;/li&gt;
&lt;li&gt;链接文件：l&lt;/li&gt;
&lt;li&gt;套接字文件：s&lt;/li&gt;
&lt;li&gt;管道文件：p&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;r 读权限read &lt;strong&gt;4&lt;/strong&gt;&lt;br/&gt;w 写权限 write &lt;strong&gt;2&lt;/strong&gt;&lt;br/&gt;x 操作权限 execute &lt;strong&gt;1&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;常用命令：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;chmod 777 test，修改test文件属性为可读，可写，可执行（4+2+1=7）&lt;/li&gt;
&lt;li&gt;ls -l 查看文件属性（或者使用&lt;code&gt;ll&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;ls -ld 查看当前目录的属性&lt;/li&gt;
&lt;li&gt;ls -l 长模式，属性信息&lt;/li&gt;
&lt;li&gt;ls -1 把文件一行一个的显示出来&lt;/li&gt;
&lt;li&gt;ls -a 显示所有文件&lt;/li&gt;
&lt;li&gt;ls -s 显示文件及文件大小&lt;/li&gt;
&lt;li&gt;ls -l -a -s  --&amp;gt; ls -las&lt;/li&gt;
&lt;li&gt;ls -sh (h-human，显示文件大小单位）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ls: 列出目录文件&lt;br/&gt;pwd: 显示目前的目录&lt;br/&gt;cd: 切换目录&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;cd - ：切换到上次目录&lt;/li&gt;
&lt;li&gt;cd .. ：切换到上级目录&lt;/li&gt;
&lt;li&gt;cd / ：切换到根目录&lt;/li&gt;
&lt;li&gt;cd ~ ：切换到当前用户的home目录&lt;/li&gt;
&lt;li&gt;cd start*end ：目录名较长时可使用通配符&quot;*&quot;，比如进入system目录，可以使用 cd s*m&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;man命令：可以通过 &lt;code&gt;man + 命令&lt;/code&gt; 查看帮助文档：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;j：下翻&lt;/li&gt;
&lt;li&gt;k：上翻&lt;/li&gt;
&lt;li&gt;空格键：翻页&lt;/li&gt;
&lt;li&gt;q：退出&lt;/li&gt;
&lt;li&gt;/-e：查找“-e”
&lt;ul&gt;&lt;li&gt;n 下一个“-e”&lt;/li&gt;
&lt;li&gt;N（shift+n） 上一个“-e”&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;[root@client ~]# ls
desktop.ini  jenkins  test.log  test.txt  t.txt
[root@client ~]# cd j*s
[root@client jenkins]# pwd  
/root/jenkins
[root@client jenkins]# cd -
/root
[root@client ~]# pwd
/root
[root@client ~]# cd jenkins/
[root@client jenkins]# pwd
/root/jenkins
[root@client jenkins]# cd ..
[root@client ~]# pwd
/root
[root@client ~]# 
/root
[root@client ~]# cd /
[root@client /]# pwd
/
[root@client /]# cd ~
[root@client ~]# pwd
/root
[root@client ~]# 
&lt;/code&gt;
&lt;/pre&gt;

&lt;ul&gt;&lt;li&gt;touch：新建文件，或者使用vim命令创建文件：vim test.txt，保存&lt;/li&gt;
&lt;li&gt;mkdir: 创建一个新的目录&lt;/li&gt;
&lt;li&gt;rmdir: 删除一个空的目录&lt;/li&gt;
&lt;li&gt;cp: 复制文件或目录&lt;/li&gt;
&lt;li&gt;rm: 移除文件或目录&lt;/li&gt;
&lt;li&gt;mv: 移动文件与目录，或修改文件与目录的名称&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# 将目录A复制到目录B下
cp -r /etc/A /etc/B
# 将目录A的内容复制到目录B下
cp -r /etc/A/* /etc/B
cp -r /etc/A/. /etc/B
# 删除目录A及其下面的所有文件
rm -r /etc/A
rm -rf /etc/A #强制删除
# 移动目录A到目录B下
mv /etc/A /etc/B
# 移动目录A下的所有文件到目录B下
mv /etc/A/* /etc/B
&lt;/code&gt;
&lt;/pre&gt;

&lt;ul&gt;&lt;li&gt;cat：显示文件内容，还可以将多个文件连接起来显示，适用于内容少的文件&lt;/li&gt;
&lt;li&gt;more：以一页一页的显示内容，空格键下一页&lt;/li&gt;
&lt;li&gt;less：支持向前翻，向后翻页&lt;/li&gt;
&lt;li&gt;head：打印前面n行内容：head -2 test.txt&lt;/li&gt;
&lt;li&gt;tail：打印后面n行内容：tail -2 test.txt&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;将内容&quot;TEST&quot;添加到test.txt文件中&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法一：vi编辑法&lt;/strong&gt;　&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;打开终端，输入vi test.txt 回车，按a或i进入编辑模式&lt;br/&gt;输入 TEST，然后按esc键退出编辑模式，输入 &lt;code&gt;:wq&lt;/code&gt; 保存并退出。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;方法二：echo命令法&lt;/strong&gt;　　&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# 追加
echo 'TEST' &amp;gt;&amp;gt; ./test.txt
# 覆盖
echo 'TEST' &amp;gt; ./test.txt
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;方法三：cat命令法&lt;/strong&gt;　　&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;cat &amp;gt;&amp;gt; ./test.txt &amp;lt;&amp;lt;TEST
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结尾的TEST要顶格。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法四：cat编辑法&lt;/strong&gt;　　&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;cat &amp;gt;&amp;gt; ./test.txt
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;回车后开始编辑输入内容：TEST&lt;/li&gt;
&lt;li&gt;按ctrl+d组合键结束编辑。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用于查找文件，基本用法：&lt;code&gt;find path -name‘xxx'&lt;/code&gt;&lt;br/&gt;&lt;code&gt;find / -name jenkins&lt;/code&gt;：查找所有目录下的jenkins文件&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;[root@client ~]# find / -name jenkins
/root/jenkins
/var/lib/docker/overlay2/6cc1d9dcc70fed5dcc455ca4147a13f650724c2e8004a9c101b4e2130276241c/diff/usr/share/jenkins
/var/lib/docker/overlay2/9b98446d8cf91c4c8da9d8eab5cd6366ef2cec266615c1fe6ad4f4faa84f25a1/diff/usr/share/jenkins
/var/lib/docker/overlay2/f1f4123687b215d1eff46d989df6c9568be89c231a83ab6105dc22c136ccf24b/diff/usr/share/jenkins
[root@iZ8vb54310gt89j8qct198Z ~]# 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;限制搜索深度&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;-maxdepth&lt;/li&gt;
&lt;li&gt;-mindefth&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;限制文件类型：文件类型有：普通文件f，目录d，符号链接 l，字符设备c，块设备b，套接字s，FIFO-p&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;-type f：搜索普通文件和目录&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;还有其他限制条件，可以通过命令 &lt;code&gt;man find&lt;/code&gt; 查看&lt;/p&gt;

&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;tar -xvzf xxx.tar.gz
&lt;/code&gt;
&lt;/pre&gt;
&lt;center&gt;&lt;strong&gt;--THE END--&lt;/strong&gt;&lt;/center&gt;
&lt;blockquote readability=&quot;5.5023255813953&quot;&gt;
&lt;p&gt;&lt;strong&gt;文章标题：Linux常用命令：文件操作命令&lt;br/&gt;本文作者：hiyo&lt;br/&gt;本文链接：&lt;a href=&quot;https://www.cnblogs.com/hiyong/p/14170537.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/hiyong/p/14170537.html&lt;/a&gt;&lt;br/&gt;欢迎关注公众号:「测试开发小记」及时接收最新技术文章！&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 29 Jan 2021 23:11:00 +0000</pubDate>
<dc:creator>测试开发小记</dc:creator>
<og:description>Linux系统命令主要包括文件操作、网络命令和性能命令，本文介绍常用文件操作命令。 修改文件属性 文件类型： 普通文件：- 目录文件：d 块设备文件：b，硬盘 字符设备： c，串行端口的接口设备，例如</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hiyong/p/14170537.html</dc:identifier>
</item>
<item>
<title>layui的tabletree扩展组件 - 1763392456</title>
<link>http://www.cnblogs.com/cnoneblog/p/14347884.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cnoneblog/p/14347884.html</guid>
<description>&lt;p&gt;&lt;strong&gt;需求：&lt;/strong&gt;点击父级菜单展示子级菜单&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;难点：&lt;/strong&gt;某个父级菜单下面有5000条子级菜单（有点坑），当我想把这5000条子级菜单塞到父级菜单下面的时候完蛋了，页面卡死了...&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决：&lt;/strong&gt;&lt;a title=&quot;http://www.dtmao.cc/news_show_654630.shtml&quot; href=&quot;http://www.dtmao.cc/news_show_654630.shtml&quot; target=&quot;_blank&quot;&gt;tabletree&lt;/a&gt;这组件我发现用的人是真的少，没办法只能硬着头皮去看这么low的组件js源码。下面是解决步骤，希望能帮助到和我遇到一样困惑的小盆友。&lt;/p&gt;
&lt;p&gt;步骤一：下图一是我页面上的代码，思路其实就是先判断子级菜单的数量，如果子级菜单少于200条的话就直接用组件的obj.async(数组)；把子级菜单数组塞给父级菜单，这个方法会自动局部刷新（还是比较好用的，layui官方文档没有讲到这个方法，自己开源码找到的，真坑）；如果子级菜单多于200条的话就把查询到的子级菜单按200条一批分批塞给父级菜单，这里还有个小问题，我这一批塞成功后这个obj.async()方法没有返回值，日了狗了还得看图二&lt;a title=&quot;https://www.taodudu.cc/news/show-2050555.html&quot; href=&quot;https://www.taodudu.cc/news/show-2050555.html&quot; target=&quot;_blank&quot;&gt;tableTree&lt;/a&gt;.js源码，发现每当这个obj.async()方法执行完后能获取obj.data.&lt;a title=&quot;http://www.dtmao.cc/news_show_654630.shtml&quot; href=&quot;http://www.dtmao.cc/news_show_654630.shtml&quot; target=&quot;_blank&quot;&gt;treeList&lt;/a&gt;，这样就有实现思路了，我先定义了一个临时变量dataList = [],当obj.async()方法执行完一批后给dataList = obj.data.&lt;a title=&quot;https://www.taodudu.cc/news/show-2050555.html&quot; href=&quot;https://www.taodudu.cc/news/show-2050555.html&quot; target=&quot;_blank&quot;&gt;treeList&lt;/a&gt;赋值，判断dataList是否大于0，大于0说明这批数据塞成功了，然后dataList = []赋值空，去塞下一批数据。&lt;/p&gt;
&lt;p&gt;图一：（我本地页面）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210130052358756.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdzaGVuZ2xpNTU1,size_16,color_FFFFFF,t_70&quot; alt=&quot;&quot; width=&quot;1179&quot; height=&quot;879&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图2：（&lt;a title=&quot;http://www.qishunwang.net/news_show_12464.aspx&quot; href=&quot;http://www.qishunwang.net/news_show_12464.aspx&quot; target=&quot;_blank&quot;&gt;tableTree&lt;/a&gt;源码）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210130053409972.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdzaGVuZ2xpNTU1,size_16,color_FFFFFF,t_70&quot; alt=&quot;&quot; width=&quot;1200&quot; height=&quot;754&quot;/&gt;&lt;/p&gt;
&lt;p&gt;步骤二：功能是实现了，问题又来了，5000条数据要耗时十几分钟去塞，什么鬼，我代码没有这么烂啊，还得看源码，发现在塞数据的时候这个组件会自动去重，就下图我标出来的方法，因为我数据后台查询的时候已经去重，所以果断注释掉了这个方法，效率大大提高了，只能这样先凑合用了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210130054623720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdzaGVuZ2xpNTU1,size_16,color_FFFFFF,t_70&quot; alt=&quot;&quot; width=&quot;1200&quot; height=&quot;744&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;结论：&lt;/strong&gt;论技术选型和选择组件的重要性，个人感觉一个好的选择大于一切，如果是我的话绝对不会选择tabletree这个组件，这里是没办法有强制要求...&lt;/p&gt;
</description>
<pubDate>Fri, 29 Jan 2021 22:00:00 +0000</pubDate>
<dc:creator>1763392456</dc:creator>
<og:description>需求：点击父级菜单展示子级菜单 难点：某个父级菜单下面有5000条子级菜单（有点坑），当我想把这5000条子级菜单塞到父级菜单下面的时候完蛋了，页面卡死了... 解决：tabletree这组件我发现用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cnoneblog/p/14347884.html</dc:identifier>
</item>
<item>
<title>那些我们不知道的 Python 免费学习资料   - MicrosoftReactor</title>
<link>http://www.cnblogs.com/MSReactor/p/14347712.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MSReactor/p/14347712.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;作者：小R&lt;br/&gt;编辑：AI 兔兔&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Python 语言因为其易学，以及强大的功能，是很多刚开始学习编程的入门语言的选择之一。 Python 语言被列入中小学教材后引起了越来越多人的关注。&lt;/p&gt;
&lt;p&gt;希望孩子学习编程的家长, 需要进行数据处理的 市场，数据分析，财务人员，以及想学习编程的人都再关注 Python。那么问题来了，如何学习 Python？&lt;/p&gt;
&lt;p&gt;相信只要搜索一下 “Python” 这个关键字，各种学习资料以及培训机构的广告就会铺天盖地地呈现在眼前。&lt;br/&gt;其实学习编程，两项重要的基本技能是阅读官方文档的能力和搜索正确的解决方案的能力。技术文档的写作可以层出不穷，关键是找到适合你项目情况的解决方案。&lt;/p&gt;
&lt;p&gt;在所有的文档中，毫无疑问地，Python 的官方文档——由 PSF（ Python Software Foundation）牵头维护的 Python 官方资料——成为了最值得信任和查阅的资料（网址：https://docs.python.org/3/）。&lt;/p&gt;
&lt;p&gt;Python 作为一门开源语言，在国内外有数以千计的志愿者在维护和更新这个文档。与此同时，中国也有几十位志愿者在进行文档的简体中文翻译工作。以帮助更多的国人去学习和使用 Python 。&lt;/p&gt;
&lt;p&gt;欢迎大家在学习使用 Python 的同时也贡献出一份自己的力量，参与到 Python 官方文档的翻译工作中，去帮助更多的人来学习 Coding 学习 Python 。&lt;/p&gt;
&lt;p&gt;希望贡献翻译成果的人员，可以参与到以下 Github 库的维护中：&lt;/p&gt;
&lt;p&gt;https://github.com/zhsj/python-docs-zh-cn&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2170493/202101/2170493-20210129202214386-1800019140.png&quot; alt=&quot;&quot; width=&quot;584&quot; height=&quot;412&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;2020年，发生了一件大事，Python 之父 Guido van Rossum 正式宣布加入微软。而实际上在此之前，微软就已经开始重视起 Python 这门编程语言，并在 2010 年发布了 Python Tools for Visual Studio（简称PTVS）。&lt;/p&gt;
&lt;p&gt;因此，在微软官网上，也会有专门的平台和若干套系统的教程，以模块化的方式帮助你从 0 到 1 定制学习 Python 语言。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210129195916373.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY3Jvc29mdFJlYWN0b3I=,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; width=&quot;586&quot; height=&quot;490&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;学习的网址：https://aka.ms/MSLearn-Python&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210129200012217.png#pic_center&quot; alt=&quot;在这里插入图片描述&quot; width=&quot;107&quot; height=&quot;107&quot;/&gt;&lt;/p&gt;
&lt;p&gt;完成这一模块的学习以后，系统将会有测试来评估你的学习情况并且进行总结。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210129200144413.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY3Jvc29mdFJlYWN0b3I=,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;图片&quot; width=&quot;594&quot; height=&quot;275&quot;/&gt;&lt;/p&gt;
&lt;p&gt;完成一个模块的学习，就可以解锁该模块的成就并进行到下一模块的学习。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210129200204813.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY3Jvc29mdFJlYWN0b3I=,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; width=&quot;595&quot; height=&quot;285&quot;/&gt;&lt;/p&gt;
&lt;p&gt;了解了 Python 是什么语言以及基本原理以后，就可以安装环境并继续自己的学习之旅。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210129200222724.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY3Jvc29mdFJlYWN0b3I=,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; width=&quot;596&quot; height=&quot;368&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以此类推。可以跟着系统一步一步的进行编程实践，解锁自己的 Python 开发技能。&lt;/p&gt;
&lt;p&gt;如果你希望在指定路线的前提下，通过学习解锁对应技能。那么可以选择你现在的或者希望成为的工作角色。目前支持的角色模块列表如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;管理员&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;工程师&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;应用开发者&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;业务用户&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据分析人员&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据科学家&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;开发人员&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DevOps工程师&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;功能顾问&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安全工程师&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解决方案架构师&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;学生&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;系统会根据不同的角色自动向你推荐不同的相关课程。&lt;/p&gt;
&lt;p&gt;比如 AI 工程师：完成学习后可以参加相应的认证考核。通过考核后，其结果可以作为资格认证，在未来帮助你找到合适的工作机会。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210129200344178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY3Jvc29mdFJlYWN0b3I=,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; width=&quot;718&quot; height=&quot;451&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;14&quot;&gt;
&lt;p&gt;一个人的学习是孤独的，欢迎加入我们的学习社区，微软 Reactor 将不定期邀请专业的讲师为大家免费分享 Python 相关教程，大家可以到群里来和我们一起学习。&lt;/p&gt;
&lt;p&gt;希望我们可以陪伴你成就更好的自己。&lt;/p&gt;
&lt;p&gt;扫描下方二维码关注微软 Reactor 公众号：MSReactor，回复 “MSLearn” 加入开发技能学习群。&lt;/p&gt;
&lt;p&gt;和更多的伙伴们一起学习，成长！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2021012920044047.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY3Jvc29mdFJlYWN0b3I=,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; width=&quot;154&quot; height=&quot;154&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;

</description>
<pubDate>Fri, 29 Jan 2021 17:43:00 +0000</pubDate>
<dc:creator>MicrosoftReactor</dc:creator>
<og:description>作者：小R编辑：AI 兔兔 Python 语言因为其易学，以及强大的功能，是很多刚开始学习编程的入门语言的选择之一。 Python 语言被列入中小学教材后引起了越来越多人的关注。 希望孩子学习编程的家</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/MSReactor/p/14347712.html</dc:identifier>
</item>
<item>
<title>MyBatis学习笔记 - ANTIA11</title>
<link>http://www.cnblogs.com/antaia11/p/14347814.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/antaia11/p/14347814.html</guid>
<description>&lt;h2 id=&quot;1、简介&quot;&gt;1、简介&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1541219/202101/1541219-20210130005935306-1272344159.png&quot; alt=&quot;image-20210129225418682&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;环境说明：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;jdk 8 +&lt;/li&gt;
&lt;li&gt;MySQL 5.7.19&lt;/li&gt;
&lt;li&gt;maven-3.6.1&lt;/li&gt;
&lt;li&gt;IDEA&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;学习前需要掌握：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;JDBC&lt;/li&gt;
&lt;li&gt;MySQL&lt;/li&gt;
&lt;li&gt;Java 基础&lt;/li&gt;
&lt;li&gt;Maven&lt;/li&gt;
&lt;li&gt;Junit&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;11、什么是-mybatis-？&quot;&gt;1.1、什么是 MyBatis ？&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;MyBatis 是一款优秀的&lt;strong&gt;持久层框架&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;它支持定制化 SQL、存储过程以及高级映射。&lt;/li&gt;
&lt;li&gt;MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。&lt;/li&gt;
&lt;li&gt;MyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。&lt;/li&gt;
&lt;li&gt;MyBatis 本是 &lt;a href=&quot;https://baike.baidu.com/item/apache/6265&quot; target=&quot;_blank&quot;&gt;apache&lt;/a&gt; 的一个开源项目&lt;a href=&quot;https://baike.baidu.com/item/iBatis&quot; target=&quot;_blank&quot;&gt;iBatis&lt;/a&gt;, 2010年这个项目由 apache software foundation 迁移到了 google code，并且改名为MyBatis 。&lt;/li&gt;
&lt;li&gt;2013年11月迁移到Github。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如何获得 MyBatis？&lt;/p&gt;
&lt;h3 id=&quot;12、持久化&quot;&gt;1.2、持久化&lt;/h3&gt;
&lt;p&gt;数据持久化&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;持久化就是将程序的数据在持久状态和瞬时状态转化的过程&lt;/li&gt;
&lt;li&gt;内存：&lt;strong&gt;断电即失&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;数据库（jdbc），io 文件持久化。&lt;/li&gt;
&lt;li&gt;生活：冷藏. 罐头。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;为什么需要需要持久化？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;有一些对象，不能让他丢掉。&lt;/li&gt;
&lt;li&gt;内存太贵了&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;13、持久层&quot;&gt;1.3、持久层&lt;/h3&gt;
&lt;p&gt;Dao 层，Service 层，Controller 层…&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;完成持久化工作的代码块&lt;/li&gt;
&lt;li&gt;层界限十分明显。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;14-为什么需要-mybatis-？&quot;&gt;1.4 为什么需要 Mybatis ？&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;帮助程序猿将数据存入到数据库中。&lt;/li&gt;
&lt;li&gt;方便&lt;/li&gt;
&lt;li&gt;传统的 JDBC 代码太复杂了。简化。框架。自动化。&lt;/li&gt;
&lt;li&gt;不用 MyBatis 也可以。更容易上手。 &lt;strong&gt;技术没有高低之分&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;优点：
&lt;ul&gt;&lt;li&gt;简单易学&lt;/li&gt;
&lt;li&gt;灵活&lt;/li&gt;
&lt;li&gt;SQL 和代码的分离，提高了可维护性。&lt;/li&gt;
&lt;li&gt;提供映射标签，支持对象与数据库的 ORM 字段关系映射&lt;/li&gt;
&lt;li&gt;提供对象关系映射标签，支持对象关系组建维护&lt;/li&gt;
&lt;li&gt;提供 XML 标签，支持编写动态 SQL 。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;最重要的一点：使用的人多！&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;2、环境搭建&quot;&gt;2、环境搭建&lt;/h2&gt;
&lt;h3 id=&quot;21、搭建实验数据库&quot;&gt;2.1、搭建实验数据库&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;CREATE DATABASE `mybatis`;

USE `mybatis`;

DROP TABLE IF EXISTS `user`;

CREATE TABLE `user` (
`id` int(20) NOT NULL,
`name` varchar(30) DEFAULT NULL,
`pwd` varchar(30) DEFAULT NULL,
PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

insert  into `user`(`id`,`name`,`pwd`) values (1,'狂神','123456'),(2,'张三','abcdef'),(3,'李四','987654');
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;22、导入-maven-相关依赖&quot;&gt;2.2、导入 Maven 相关依赖&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;dependency&amp;gt;
   &amp;lt;groupId&amp;gt;org.mybatis&amp;lt;/groupId&amp;gt;
   &amp;lt;artifactId&amp;gt;mybatis&amp;lt;/artifactId&amp;gt;
   &amp;lt;version&amp;gt;3.5.2&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
   &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
   &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
   &amp;lt;version&amp;gt;5.1.47&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;23、编写-mybatis-核心配置文件&quot;&gt;2.3、编写 MyBatis 核心配置文件&lt;/h3&gt;
&lt;p&gt;可以根据帮助文档来进行编写&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&amp;gt;
&amp;lt;!DOCTYPE configuration
       PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
       &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&amp;gt;
&amp;lt;configuration&amp;gt;
   &amp;lt;environments default=&quot;development&quot;&amp;gt;
       &amp;lt;environment id=&quot;development&quot;&amp;gt;
           &amp;lt;transactionManager type=&quot;JDBC&quot;/&amp;gt;
           &amp;lt;dataSource type=&quot;POOLED&quot;&amp;gt;
               &amp;lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&amp;gt;
               &amp;lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;amp;useUnicode=true&amp;amp;amp;characterEncoding=utf8&quot;/&amp;gt;
               &amp;lt;property name=&quot;username&quot; value=&quot;root&quot;/&amp;gt;
               &amp;lt;property name=&quot;password&quot; value=&quot;123456&quot;/&amp;gt;
           &amp;lt;/dataSource&amp;gt;
       &amp;lt;/environment&amp;gt;
   &amp;lt;/environments&amp;gt;
   &amp;lt;mappers&amp;gt;
       &amp;lt;mapper resource=&quot;com/kuang/dao/userMapper.xml&quot;/&amp;gt;
   &amp;lt;/mappers&amp;gt;
&amp;lt;/configuration&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;24、编写-mybatis-工具类&quot;&gt;2.4、编写 MyBatis 工具类&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import java.io.IOException;
import java.io.InputStream;

public class MybatisUtils {

   private static SqlSessionFactory sqlSessionFactory;

   static {
       try {
           String resource = &quot;mybatis-config.xml&quot;;
           InputStream inputStream = Resources.getResourceAsStream(resource);
           sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
      } catch (IOException e) {
           e.printStackTrace();
      }
  }

   //获取SqlSession连接
   public static SqlSession getSession(){
       return sqlSessionFactory.openSession();
  }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;25、创建实体类&quot;&gt;2.5、创建实体类&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class User {
   
   private int id;  //id
   private String name;   //姓名
   private String pwd;   //密码
   
   //构造,有参,无参
   //set/get
   //toString()
   
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;26、编写-mapper-接口&quot;&gt;2.6、编写 Mapper 接口&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;import com.kuang.pojo.User;
import java.util.List;

public interface UserMapper {
   List&amp;lt;User&amp;gt; selectUser();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;27、编写-mapperxml-配置文件&quot;&gt;2.7、编写 Mapper.xml 配置文件&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;注意 &lt;code&gt;namespace&lt;/code&gt; 不要写错！&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&amp;gt;
&amp;lt;!DOCTYPE mapper
       PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
       &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&amp;gt;

&amp;lt;mapper namespace=&quot;com.kuang.dao.UserMapper&quot;&amp;gt;
    
 &amp;lt;select id=&quot;selectUser&quot; resultType=&quot;com.kuang.pojo.User&quot;&amp;gt;
        select * from user
 &amp;lt;/select&amp;gt;
    
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;28、编写测试类&quot;&gt;2.8、编写测试类&lt;/h3&gt;
&lt;p&gt;**junit 包测试 **&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class MyTest {
   @Test
   public void selectUser() {
       SqlSession session = MybatisUtils.getSession();
       //方法一:
       //List&amp;lt;User&amp;gt; users = session.selectList(&quot;com.kuang.mapper.UserMapper.selectUser&quot;);
       
       //方法二:
       UserMapper mapper = session.getMapper(UserMapper.class);
       List&amp;lt;User&amp;gt; users = mapper.selectUser();

       for (User user: users){
           System.out.println(user);
      }
       session.close();
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;出现的问题&quot;&gt;出现的问题:&lt;/h2&gt;
&lt;p&gt;1、Maven 静态资源过滤问题&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;resources&amp;gt;
   &amp;lt;resource&amp;gt;
       &amp;lt;directory&amp;gt;src/main/java&amp;lt;/directory&amp;gt;
       &amp;lt;includes&amp;gt;
           &amp;lt;include&amp;gt;**/*.properties&amp;lt;/include&amp;gt;
           &amp;lt;include&amp;gt;**/*.xml&amp;lt;/include&amp;gt;
       &amp;lt;/includes&amp;gt;
       &amp;lt;filtering&amp;gt;false&amp;lt;/filtering&amp;gt;
   &amp;lt;/resource&amp;gt;
   &amp;lt;resource&amp;gt;
       &amp;lt;directory&amp;gt;src/main/resources&amp;lt;/directory&amp;gt;
       &amp;lt;includes&amp;gt;
           &amp;lt;include&amp;gt;**/*.properties&amp;lt;/include&amp;gt;
           &amp;lt;include&amp;gt;**/*.xml&amp;lt;/include&amp;gt;
       &amp;lt;/includes&amp;gt;
       &amp;lt;filtering&amp;gt;false&amp;lt;/filtering&amp;gt;
   &amp;lt;/resource&amp;gt;
&amp;lt;/resources&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;3、crud操作配置解析&quot;&gt;3、CRUD操作配置解析&lt;/h2&gt;
&lt;h3 id=&quot;31、select-标签&quot;&gt;3.1、select 标签&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;练习 1 ：根据 id 查询 用户&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.在 UserMapper 中添加对应方法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface UserMapper {
   //查询全部用户
   List&amp;lt;User&amp;gt; selectUser();
   //根据id查询用户
   User selectUserById(int id);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.在UserMapper.xml中添加 &lt;code&gt;select&lt;/code&gt; 语句&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;select id=&quot;selectUserById&quot; resultType=&quot;com.anti.pojo.User&quot;&amp;gt;
        select * from user where id = #{id}
&amp;lt;/select&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.在测试类中测试&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void tsetSelectUserById() {
   SqlSession session = MybatisUtils.getSession();  //获取SqlSession连接
   UserMapper mapper = session.getMapper(UserMapper.class);
   User user = mapper.selectUserById(1);
   System.out.println(user);
   session.close();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4.运行结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1541219/202101/1541219-20210130005935625-147668548.png&quot; alt=&quot;运行结果&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;练习2：根据 密码 和名字 查询用户&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;方法一：直接在方法中传递参数&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;​ 在接口方法中的参数前加 &lt;code&gt;@Param&lt;/code&gt; 属性。&lt;/li&gt;
&lt;li&gt;​ SQL 语句编写的时候，直接取 &lt;code&gt;@Param&lt;/code&gt; 中设置的值即可，不需要到单独设置参数类型。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//通过密码和名字查询用户
User selectUserByNP(@Param(&quot;username&quot;) String username,@Param(&quot;pwd&quot;) String pwd);


//mapper.xml
&amp;lt;select id=&quot;selectUserByNP&quot; resultType=&quot;com.kuang.pojo.User&quot;&amp;gt;
    select * from user where name = #{username} and pwd = #{pwd}
&amp;lt;/select&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;方法二：万能Map&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在接口方法中，参数数直接传递Map。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;User selectUserByNP2(Map&amp;lt;String,Object&amp;gt; map);
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;在编写SQL语句的时候，需要传递参数类型 &lt;code&gt;parameterType=&quot;map&quot;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;select id=&quot;selectUserByNP2&quot; parameterType=&quot;map&quot; resultType=&quot;com.kuang.pojo.User&quot;&amp;gt;
    select * from user where name = #{username} and pwd = #{pwd}
&amp;lt;/select&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;在使用方法的时候，Map 的 KEY 为 SQL 中取的值即可。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void test03(){
    SqlSession session = MybatisUtils.getSession();
    UserMapper mapper = session.getMapper(UserMapper.class);
    HashMap&amp;lt;String, Object&amp;gt; map = new HashMap&amp;lt;String, Object&amp;gt;();
    map.put(&quot;username&quot;,&quot;张三&quot;);
    map.put(&quot;pwd&quot;,&quot;abcdef&quot;);
    User user = mapper.selectUserByNP2(map);
    System.out.println(user);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果参数过多，我们可以考虑直接使用 Map 实现，如果参数比较少，直接传递参数即可。&lt;/p&gt;
&lt;h3 id=&quot;32、insert-标签&quot;&gt;3.2、insert 标签&lt;/h3&gt;
&lt;p&gt;我们一般使用 insert 标签进行插入操作，它的配置和 select 标签差不多.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;练习1：增加一个用户&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.在 UserMapper 接口中添加对应的方法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//添加一个用户
int addUser(User user);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、在UserMapper.xml中添加insert语句&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;&amp;lt;insert id=&quot;addUser&quot; parameterType=&quot;com.anti.pojo.User&quot;&amp;gt;
    insert into user (id,name,pwd) values (#{id},#{name},#{pwd})
&amp;lt;/insert&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.测试&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void testAddUser() {
   SqlSession session = MybatisUtils.getSession();
   UserMapper mapper = session.getMapper(UserMapper.class);
   User user = new User(5,&quot;王五&quot;,&quot;zxcvbn&quot;);
   int i = mapper.addUser(user);
   System.out.println(i);
   session.commit(); //提交事务,重点!不写的话不会提交到数据库
   session.close();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意点：增、删、改操作需要提交事务！&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;33、update-标签&quot;&gt;3.3、update 标签&lt;/h3&gt;
&lt;p&gt;我们一般使用update标签进行更新操作，它的配置和select标签差不多。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;练习：修改用户的信息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、同理，编写接口方法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//修改一个用户
int updateUser(User user);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、编写对应的配置文件SQL&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;update id=&quot;updateUser&quot; parameterType=&quot;com.kuang.pojo.User&quot;&amp;gt;
  update user set name=#{name},pwd=#{pwd} where id = #{id}
&amp;lt;/update&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3、测试&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void testUpdateUser() {
   SqlSession session = MybatisUtils.getSession();
   UserMapper mapper = session.getMapper(UserMapper.class);
   User user = mapper.selectUserById(1);
   user.setPwd(&quot;asdfgh&quot;);
   int i = mapper.updateUser(user);
   System.out.println(i);
   session.commit(); //提交事务,重点!不写的话不会提交到数据库
   session.close();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;34、delete-标签&quot;&gt;3.4、delete 标签&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;需求：根据id删除一个用户&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、同理，编写接口方法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//根据id删除用户
int deleteUser(int id);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、编写对应的配置文件SQL&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;delete id=&quot;deleteUser&quot; parameterType=&quot;int&quot;&amp;gt;
  delete from user where id = #{id}
&amp;lt;/delete&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3、测试&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void testDeleteUser() {
   SqlSession session = MybatisUtils.getSession();
   UserMapper mapper = session.getMapper(UserMapper.class);
   int i = mapper.deleteUser(5);
   System.out.println(i);
   session.commit(); //提交事务,重点!不写的话不会提交到数据库
   session.close();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;小结：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;所有的 增、删、改操作都需要提交事务！&lt;/li&gt;
&lt;li&gt;所有的普通参数，尽量都写上 &lt;code&gt;@Param&lt;/code&gt; 参数，尤其是多个参数时，必须写上！&lt;/li&gt;
&lt;li&gt;有时候根据业务的需求，可以考虑使用 map 传递参数！&lt;/li&gt;
&lt;li&gt;为了规范操作， 在 SQL 的配置文件中，我们尽量将 &lt;code&gt;parameterType&lt;/code&gt; 和 &lt;code&gt;resultType&lt;/code&gt; 都写上！&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;35、模糊查询&quot;&gt;3.5、模糊查询&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;第1种（推荐）&lt;/strong&gt;：在 Java代码中添加 SQL通配符。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;List&amp;lt;User&amp;gt; users = mapper.selectLikeUser(&quot;%朱%&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;select id=&quot;selectLikeUser&quot;&amp;gt;
        select * from user where name like #{name}
&amp;lt;/select&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第2种（不推荐）：在 SQL 语句中拼接通配符，会引起 SQL 注入。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;String name = &quot;朱&quot;;
List&amp;lt;User&amp;gt; users = mapper.selectLikeUser(name);
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;&amp;lt;select id=&quot;selectLikeUser&quot;&amp;gt;
        select * from user where name like &quot;%&quot; #{name} &quot;%&quot;
&amp;lt;/select&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;4、配置解析&quot;&gt;4、配置解析&lt;/h2&gt;
&lt;h3 id=&quot;41、mybatis-configxml--核心配置文件&quot;&gt;4.1、mybatis-config.xml 核心配置文件&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;MyBatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息。&lt;/li&gt;
&lt;li&gt;能配置的内容如下：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-txt&quot;&gt;configuration（配置）
properties（属性）
settings（设置）
typeAliases（类型别名）
typeHandlers（类型处理器）
objectFactory（对象工厂）
plugins（插件）
environments（环境配置）
environment（环境变量）
transactionManager（事务管理器）
dataSource（数据源）
databaseIdProvider（数据库厂商标识）
mappers（映射器）
&amp;lt;!-- 注意元素节点的顺序！顺序不对会报错 --&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以阅读 &lt;code&gt;mybatis-config.xml&lt;/code&gt; 上面的 &lt;code&gt;dtd&lt;/code&gt; 的头文件！&lt;/p&gt;
&lt;h3 id=&quot;42、environments-元素&quot;&gt;4.2、environments 元素&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;   &amp;lt;environments default=&quot;development&quot;&amp;gt;
       &amp;lt;environment id=&quot;development&quot;&amp;gt;
           &amp;lt;transactionManager type=&quot;JDBC&quot;/&amp;gt;
           &amp;lt;dataSource type=&quot;POOLED&quot;&amp;gt;
               &amp;lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&amp;gt;
               &amp;lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;amp;useUnicode=true&amp;amp;amp;characterEncoding=utf8&quot;/&amp;gt;
               &amp;lt;property name=&quot;username&quot; value=&quot;root&quot;/&amp;gt;
               &amp;lt;property name=&quot;password&quot; value=&quot;123456&quot;/&amp;gt;
           &amp;lt;/dataSource&amp;gt;
       &amp;lt;/environment&amp;gt;
   &amp;lt;/environments&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置 MyBatis 的多套运行环境，将 SQL 映射到多个不同的数据库上，必须指定其中一个为默认运行环境（通过default指定）&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;!-- 语法 --&amp;gt;
&amp;lt;transactionManager type=&quot;[ JDBC | MANAGED ]&quot;/&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;43、mappers-元素&quot;&gt;4.3、mappers 元素&lt;/h3&gt;
&lt;p&gt;mappers&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;映射器 : 定义映射SQL语句文件&lt;/li&gt;
&lt;li&gt;既然 MyBatis 的行为其他元素已经配置完了，我们现在就要定义 SQL 映射语句了。但是首先我们需要告诉 MyBatis 到哪里去找到这些语句。Java 在自动查找这方面没有提供一个很好的方法，所以最佳的方式是告诉 MyBatis 到哪里去找映射文件。你可以使用相对于类路径的资源引用， 或完全限定资源定位符（包括 &lt;code&gt;file:///&lt;/code&gt; 的 URL），或类名和包名等。映射器是MyBatis中最核心的组件之一，在MyBatis 3之前，只支持xml映射器，即：所有的SQL语句都必须在xml文件中配置。而从MyBatis 3开始，还支持接口映射器，这种映射器方式允许以Java代码的方式注解定义SQL语句，非常简洁。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;!-- 使用相对于类路径的资源引用 --&amp;gt;
&amp;lt;mappers&amp;gt;
        &amp;lt;mapper resource=&quot;org/mybatis/builder/PostMapper.xml&quot;/&amp;gt;
&amp;lt;/mappers&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;!-- 使用完全限定资源定位符（URL） --&amp;gt;
&amp;lt;mappers&amp;gt;
        &amp;lt;mapper url=&quot;file:///var/mappers/AuthorMapper.xml&quot;/&amp;gt;
&amp;lt;/mappers&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;!--
使用映射器接口实现类的完全限定类名
需要配置文件名称和接口名称一致，并且位于同一目录下
--&amp;gt;
&amp;lt;mappers&amp;gt;
        &amp;lt;mapper class=&quot;org.mybatis.builder.AuthorMapper&quot;/&amp;gt;
&amp;lt;/mappers&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;!--
将包内的映射器接口实现全部注册为映射器
但是需要配置文件名称和接口名称一致，并且位于同一目录下
--&amp;gt;
&amp;lt;mappers&amp;gt;
        &amp;lt;package name=&quot;org.mybatis.builder&quot;/&amp;gt;
&amp;lt;/mappers&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;mapper文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&amp;gt;
&amp;lt;!DOCTYPE mapper
       PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
       &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&amp;gt;
&amp;lt;mapper namespace=&quot;com.kuang.mapper.UserMapper&quot;&amp;gt;
   
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;namespace 中文意思：命名空间，作用如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;​ namespace 的命名必须跟某个接口同名&lt;/li&gt;
&lt;li&gt;​ 接口中的方法与映射文件中 sql 语句 id 应该一 一对应&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;namespace 和子元素的 id 联合保证唯一 , 区别不同的mapper&lt;/p&gt;
&lt;p&gt;绑定 DAO 接口&lt;/p&gt;
&lt;p&gt;namespace 命名规则 : 包名 + 类名&lt;/p&gt;
&lt;h3 id=&quot;44、properties-优化&quot;&gt;4.4、properties 优化&lt;/h3&gt;
&lt;p&gt;数据库这些属性都是可外部配置且可动态替换的，既可以在典型的 Java 属性文件中配置，亦可通过 properties 元素的子元素来传递。具体的请参考官方文档&lt;/p&gt;
&lt;p&gt;我们来优化我们的配置文件&lt;/p&gt;
&lt;p&gt;第一步 ; 在&lt;code&gt;resources&lt;/code&gt;资源目录下新建一个 &lt;code&gt;db.properties&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-properties&quot;&gt;driver=com.mysql.jdbc.Driver
url=jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf8&amp;amp;serverTimezone=UTC
username=root
password=123456
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第二步 : 将文件导入 &lt;code&gt;properties&lt;/code&gt; 配置文件&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;configuration&amp;gt;
   &amp;lt;!--导入properties文件--&amp;gt;
   &amp;lt;properties resource=&quot;db.properties&quot;/&amp;gt;

   &amp;lt;environments default=&quot;development&quot;&amp;gt;
       &amp;lt;environment id=&quot;development&quot;&amp;gt;
           &amp;lt;transactionManager type=&quot;JDBC&quot;/&amp;gt;
           &amp;lt;dataSource type=&quot;POOLED&quot;&amp;gt;
               &amp;lt;property name=&quot;driver&quot; value=&quot;${driver}&quot;/&amp;gt;
               &amp;lt;property name=&quot;url&quot; value=&quot;${url}&quot;/&amp;gt;
               &amp;lt;property name=&quot;username&quot; value=&quot;${username}&quot;/&amp;gt;
               &amp;lt;property name=&quot;password&quot; value=&quot;${password}&quot;/&amp;gt;
           &amp;lt;/dataSource&amp;gt;
       &amp;lt;/environment&amp;gt;
   &amp;lt;/environments&amp;gt;
   &amp;lt;mappers&amp;gt;
       &amp;lt;mapper resource=&quot;mapper/UserMapper.xml&quot;/&amp;gt;
   &amp;lt;/mappers&amp;gt;
&amp;lt;/configuration&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;5、typealiases优化&quot;&gt;5、typeAliases优化&lt;/h2&gt;
&lt;p&gt;类型别名是为 Java 类型设置一个短的名字。它只和 XML 配置有关，存在的意义仅在于用来减少类完全限定名的冗余。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;!--配置别名,注意顺序--&amp;gt;
&amp;lt;typeAliases&amp;gt;
   &amp;lt;typeAlias type=&quot;com.anti.pojo.User&quot; alias=&quot;User&quot;/&amp;gt;
&amp;lt;/typeAliases&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当这样配置时，&lt;code&gt;User&lt;/code&gt; 可以用在任何使用 &lt;code&gt;com.kuang.pojo.User&lt;/code&gt; 的地方。&lt;/p&gt;
&lt;p&gt;也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean，比如:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;typeAliases&amp;gt;
   &amp;lt;package name=&quot;com.anti.pojo&quot;/&amp;gt;
&amp;lt;/typeAliases&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;每一个在包 &lt;code&gt;com.anti.pojo&lt;/code&gt; 中的 Java Bean，在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;若有注解，则别名为其注解值。见下面的例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Alias(&quot;user&quot;)
public class User {
  ...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;去官网查看一下Mybatis默认的一些类型别名: &lt;a href=&quot;https://mybatis.org/mybatis-3/zh/configuration.html#typeAliases&quot; target=&quot;_blank&quot;&gt;https://mybatis.org/mybatis-3/zh/configuration.html#typeAliases&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;6、其他配置浏览&quot;&gt;6、其他配置浏览&lt;/h2&gt;
&lt;h3 id=&quot;61、设置&quot;&gt;6.1、设置&lt;/h3&gt;
&lt;p&gt;设置（settings）相关 =&amp;gt; 查看帮助文档&lt;/p&gt;
&lt;p&gt;懒加载&lt;/p&gt;
&lt;p&gt;日志实现&lt;/p&gt;
&lt;p&gt;缓存开启关闭&lt;/p&gt;
&lt;p&gt;一个配置完整的 settings 元素的示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;settings&amp;gt;
 &amp;lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&amp;gt;
 &amp;lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&amp;gt;
 &amp;lt;setting name=&quot;multipleResultSetsEnabled&quot; value=&quot;true&quot;/&amp;gt;
 &amp;lt;setting name=&quot;useColumnLabel&quot; value=&quot;true&quot;/&amp;gt;
 &amp;lt;setting name=&quot;useGeneratedKeys&quot; value=&quot;false&quot;/&amp;gt;
 &amp;lt;setting name=&quot;autoMappingBehavior&quot; value=&quot;PARTIAL&quot;/&amp;gt;
 &amp;lt;setting name=&quot;autoMappingUnknownColumnBehavior&quot; value=&quot;WARNING&quot;/&amp;gt;
 &amp;lt;setting name=&quot;defaultExecutorType&quot; value=&quot;SIMPLE&quot;/&amp;gt;
 &amp;lt;setting name=&quot;defaultStatementTimeout&quot; value=&quot;25&quot;/&amp;gt;
 &amp;lt;setting name=&quot;defaultFetchSize&quot; value=&quot;100&quot;/&amp;gt;
 &amp;lt;setting name=&quot;safeRowBoundsEnabled&quot; value=&quot;false&quot;/&amp;gt;
 &amp;lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;false&quot;/&amp;gt;
 &amp;lt;setting name=&quot;localCacheScope&quot; value=&quot;SESSION&quot;/&amp;gt;
 &amp;lt;setting name=&quot;jdbcTypeForNull&quot; value=&quot;OTHER&quot;/&amp;gt;
 &amp;lt;setting name=&quot;lazyLoadTriggerMethods&quot; value=&quot;equals,clone,hashCode,toString&quot;/&amp;gt;
&amp;lt;/settings&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;62、类型处理器&quot;&gt;6.2、类型处理器&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;无论是 MyBatis 在预处理语句（PreparedStatement）中设置一个参数时，还是从结果集中取出一个值时， 都会用类型处理器将获取的值以合适的方式转换成 Java 类型。&lt;/li&gt;
&lt;li&gt;你可以重写类型处理器或创建你自己的类型处理器来处理不支持的或非标准的类型。【了解即可】&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;63、对象工厂&quot;&gt;6.3、对象工厂&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;MyBatis 每次创建结果对象的新实例时，它都会使用一个对象工厂（ObjectFactory）实例来完成。&lt;/li&gt;
&lt;li&gt;默认的对象工厂需要做的仅仅是实例化目标类，要么通过默认构造方法，要么在参数映射存在的时候通过有参构造方法来实例化。&lt;/li&gt;
&lt;li&gt;如果想覆盖对象工厂的默认行为，则可以通过创建自己的对象工厂来实现。【了解即可】&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;7、生命周期和作用域&quot;&gt;7、生命周期和作用域&lt;/h2&gt;
&lt;p&gt;理解我们目前已经讨论过的不同作用域和生命周期类是至关重要的，因为错误的使用会导致非常严重的并发问题。&lt;/p&gt;
&lt;p&gt;我们可以先画一个流程图，分析一下 Mybatis 的执行过程！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1541219/202012/1541219-20201205171544225-1984485250.png&quot; alt=&quot;image-20201205171543934&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;71、作用域理解&quot;&gt;7.1、作用域理解&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;SqlSessionFactoryBuilder 的作用在于创建 SqlSessionFactory，创建成功后，SqlSessionFactoryBuilder 就失去了作用，所以它只能存在于创建 SqlSessionFactory 的方法中，而不要让其长期存在。因此 &lt;strong&gt;SqlSessionFactoryBuilder 实例的最佳作用域是方法作用域&lt;/strong&gt;（也就是局部方法变量）。&lt;/li&gt;
&lt;li&gt;SqlSessionFactory 可以被认为是一个数据库连接池，它的作用是创建 SqlSession 接口对象。因为 MyBatis 的本质就是 Java 对数据库的操作，所以 SqlSessionFactory 的生命周期存在于整个 MyBatis 的应用之中，所以一旦创建了 SqlSessionFactory，就要长期保存它，直至不再使用 MyBatis 应用，所以可以认为 SqlSessionFactory 的生命周期就等同于 MyBatis 的应用周期。&lt;/li&gt;
&lt;li&gt;由于 SqlSessionFactory 是一个对数据库的连接池，所以它占据着数据库的连接资源。如果创建多个 SqlSessionFactory，那么就存在多个数据库连接池，这样不利于对数据库资源的控制，也会导致数据库连接资源被消耗光，出现系统宕机等情况，所以尽量避免发生这样的情况。&lt;/li&gt;
&lt;li&gt;因此在一般的应用中我们往往希望 SqlSessionFactory 作为一个单例，让它在应用中被共享。所以说 &lt;strong&gt;SqlSessionFactory 的最佳作用域是应用作用域。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;如果说 SqlSessionFactory 相当于数据库连接池，那么 SqlSession 就相当于一个数据库连接（Connection 对象），你可以在一个事务里面执行多条 SQL，然后通过它的 commit、rollback 等方法，提交或者回滚事务。所以它应该存活在一个业务请求中，处理完整个请求后，应该关闭这条连接，让它归还给 SqlSessionFactory，否则数据库资源就很快被耗费精光，系统就会瘫痪，所以用 try...catch...finally... 语句来保证其正确关闭。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;所以 SqlSession 的最佳的作用域是请求或方法作用域。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1541219/202012/1541219-20201205171556085-2001899442.png&quot; alt=&quot;image-20201205171555725&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;8、reusltmap&quot;&gt;8、ReusltMap&lt;/h2&gt;
&lt;h3 id=&quot;81、在进行简单查询时，查询出来的值为-null&quot;&gt;8.1、在进行简单查询时，查询出来的值为 &lt;code&gt;null&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1541219/202101/1541219-20210130005935939-1597404568.png&quot; alt=&quot;image-20201206133705016&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可以看到查询出来的结果集中 &lt;code&gt;username&lt;/code&gt; 属性为 &lt;code&gt;null&lt;/code&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;82、原因分析&quot;&gt;8.2、原因分析&lt;/h3&gt;
&lt;p&gt;MyBatis 会根据这些查询的列名(会将列名转化为小写,数据库不区分大小写) , 去对应的实体类中查找相应列名的 &lt;code&gt;set方法&lt;/code&gt; 设值 , 由于找不到 &lt;code&gt;setUsernmae()&lt;/code&gt; , 所以 username 返回 null ; 【自动映射】&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1541219/202101/1541219-20210130005936162-1849939008.png&quot; alt=&quot;image-20201206133911746&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;83、解决方法&quot;&gt;8.3、解决方法&lt;/h3&gt;
&lt;p&gt;1.【不推荐】修改实体类的属性名，使其和数据库字段名一致。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1541219/202101/1541219-20210130005936383-1487354548.png&quot; alt=&quot;image-20201206134056441&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.【不推荐】在 SQL 语句中使用别名对应实体类中的属性名。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1541219/202101/1541219-20210130005936581-648890352.png&quot; alt=&quot;image-20201206134740333&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.【推荐】使用在 xxMapper.xml` 中使用 ResultMap 进行结果集映射。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1541219/202101/1541219-20210130005936832-1296485878.png&quot; alt=&quot;image-20201206135146896&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;84、数据库中，存在一对多，多对一的情况时&quot;&gt;8.4、数据库中，存在一对多，多对一的情况时&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;【多对一】的处理：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;多个学生对应一个老师&lt;/li&gt;
&lt;li&gt;如果对于学生这边，就是一个多对一的现象，即从学生这边关联一个老师。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1541219/202101/1541219-20210130005937012-571902712.png&quot; alt=&quot;image-20201206135928746&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1541219/202101/1541219-20210130005937183-256613384.png&quot; alt=&quot;image-20201206141735576&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1541219/202101/1541219-20210130005937367-824024862.png&quot; alt=&quot;image-20201206141721977&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1541219/202101/1541219-20210130005937578-1522163434.png&quot; alt=&quot;image-20201206141754594&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【一对多】的处理：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1541219/202101/1541219-20210130005937756-581158079.png&quot; alt=&quot;image-20201206142906498&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1541219/202101/1541219-20210130005937913-691131387.png&quot; alt=&quot;image-20201206142852540&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1541219/202101/1541219-20210130005938113-1441631942.png&quot; alt=&quot;image-20201206142917246&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;85、-总结：&quot;&gt;8.5、 总结：&lt;/h3&gt;
&lt;p&gt;1、关联 - &lt;code&gt;association&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;2、集合 - &lt;code&gt;collection&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;3、所以 &lt;code&gt;association&lt;/code&gt; 是用于一对一和多对一，而 &lt;code&gt;collection&lt;/code&gt; 是用于一对多的关系&lt;/p&gt;
&lt;p&gt;4、&lt;code&gt;JavaType&lt;/code&gt; 和 &lt;code&gt;ofType&lt;/code&gt; 都是用来指定对象类型的&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;JavaType&lt;/code&gt; 是用来指定 &lt;code&gt;pojo&lt;/code&gt; 中属性的类型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ofType&lt;/code&gt;指定的是映射到 &lt;code&gt;List&lt;/code&gt; 集合属性中 &lt;code&gt;pojo&lt;/code&gt; 的类型。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;注意说明：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、保证SQL的可读性，尽量通俗易懂&lt;/p&gt;
&lt;p&gt;2、根据实际要求，尽量编写性能更高的SQL语句&lt;/p&gt;
&lt;p&gt;3、注意属性名和字段不一致的问题&lt;/p&gt;
&lt;p&gt;4、注意一对多和多对一 中：字段和属性对应的问题&lt;/p&gt;
&lt;p&gt;5、尽量使用Log4j，通过日志来查看自己的错误&lt;/p&gt;
&lt;h2 id=&quot;9、-log日志&quot;&gt;9、 Log日志&lt;/h2&gt;
&lt;h3 id=&quot;91、思考&quot;&gt;9.1、思考&lt;/h3&gt;
&lt;p&gt;我们在测试 SQL 的时候，要是能够在控制台输出 SQL 的话，是不是就能够有更快的排错效率？&lt;/p&gt;
&lt;p&gt;如果一个 数据库相关的操作出现了问题，我们可以根据输出的 SQL 语句快速排查问题。&lt;/p&gt;
&lt;p&gt;对于以往的开发过程，我们会经常使用到debug模式来调节，跟踪我们的代码执行过程。但是现在使用 Mybatis 是基于接口，配置文件的源代码执行过程。因此，我们必须选择日志工具来作为我们开发，调节程序的工具。&lt;/p&gt;
&lt;p&gt;Mybatis内置的日志工厂提供日志功能，具体的日志实现有以下几种工具：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;SLF4J&lt;/li&gt;
&lt;li&gt;Apache Commons Logging&lt;/li&gt;
&lt;li&gt;Log4j 2&lt;/li&gt;
&lt;li&gt;Log4j&lt;/li&gt;
&lt;li&gt;JDK logging&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;具体选择哪个日志实现工具由 MyBatis 的内置日志工厂确定。它会使用最先找到的（按上文列举的顺序查找）。如果一个都未找到，日志功能就会被禁用。&lt;/p&gt;
&lt;h3 id=&quot;92、标准日志实现&quot;&gt;9.2、标准日志实现&lt;/h3&gt;
&lt;p&gt;指定 MyBatis 应该使用哪个日志记录实现。如果此设置不存在，则会自动发现日志记录实现。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;settings&amp;gt;
       &amp;lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&amp;gt;
&amp;lt;/settings&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试，可以看到控制台有大量的输出！我们可以通过这些输出来判断程序到底哪里出了Bug&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;Logging initialized using 'class org.apache.ibatis.logging.stdout.StdOutImpl' adapter.
PooledDataSource forcefully closed/removed all connections.
PooledDataSource forcefully closed/removed all connections.
PooledDataSource forcefully closed/removed all connections.
PooledDataSource forcefully closed/removed all connections.
Opening JDBC Connection
Loading class `com.mysql.jdbc.Driver'. This is deprecated. The new driver class is `com.mysql.cj.jdbc.Driver'. The driver is automatically registered via the SPI and manual loading of the driver class is generally unnecessary.
Created connection 355115154.
Setting autocommit to false on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@152aa092]
==&amp;gt;  Preparing: select * from teacher where id = ? 
==&amp;gt; Parameters: 1(Integer)
&amp;lt;==    Columns: id, name
&amp;lt;==        Row: 1, 秦老师
====&amp;gt;  Preparing: select * from student 
====&amp;gt; Parameters: 
&amp;lt;====    Columns: id, name, tid
&amp;lt;====        Row: 1, 小明, 1
&amp;lt;====        Row: 2, 小红, 1
&amp;lt;====        Row: 3, 小张, 1
&amp;lt;====        Row: 4, 小李, 1
&amp;lt;====        Row: 5, 小王, 1
&amp;lt;====      Total: 5
&amp;lt;==      Total: 1
Teacher(id=null, name=秦老师, students=[Student(id=1, name=小明), Student(id=2, name=小红), Student(id=3, name=小张), Student(id=4, name=小李), Student(id=5, name=小王)])
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;93、使用-log4j&quot;&gt;9.3、使用 Log4j&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;简介：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Log4j是Apache的一个开源项目&lt;/li&gt;
&lt;li&gt;通过使用Log4j，我们可以控制日志信息输送的目的地：控制台，文本，GUI组件....&lt;/li&gt;
&lt;li&gt;我们也可以控制每一条日志的输出格式；&lt;/li&gt;
&lt;li&gt;通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。最令人感兴趣的就是，这些可以通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;使用步骤：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、导入log4j的包&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;dependency&amp;gt;
   &amp;lt;groupId&amp;gt;log4j&amp;lt;/groupId&amp;gt;
   &amp;lt;artifactId&amp;gt;log4j&amp;lt;/artifactId&amp;gt;
   &amp;lt;version&amp;gt;1.2.17&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、配置文件编写&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-properties&quot;&gt;#将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码
log4j.rootLogger=DEBUG,console,file

#控制台输出的相关设置
log4j.appender.console = org.apache.log4j.ConsoleAppender
log4j.appender.console.Target = System.out
log4j.appender.console.Threshold=DEBUG
log4j.appender.console.layout = org.apache.log4j.PatternLayout
log4j.appender.console.layout.ConversionPattern=[%c]-%m%n

#文件输出的相关设置
log4j.appender.file = org.apache.log4j.RollingFileAppender
log4j.appender.file.File=./log/kuang.log
log4j.appender.file.MaxFileSize=10mb
log4j.appender.file.Threshold=DEBUG
log4j.appender.file.layout=org.apache.log4j.PatternLayout
log4j.appender.file.layout.ConversionPattern=[%p][%d{yy-MM-dd}][%c]%m%n

#日志输出级别
log4j.logger.org.mybatis=DEBUG
log4j.logger.java.sql=DEBUG
log4j.logger.java.sql.Statement=DEBUG
log4j.logger.java.sql.ResultSet=DEBUG
log4j.logger.java.sql.PreparedStatement=DEBUG
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3、setting设置日志实现&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;settings&amp;gt;
   &amp;lt;setting name=&quot;logImpl&quot; value=&quot;LOG4J&quot;/&amp;gt;
&amp;lt;/settings&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;[org.apache.ibatis.datasource.pooled.PooledDataSource]-Created connection 71706941.
[org.apache.ibatis.transaction.jdbc.JdbcTransaction]-Setting autocommit to false on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@446293d]
[com.anti.dao.TeacherMapper.getTeacherById]-==&amp;gt;  Preparing: select * from teacher where id = ? 
[com.anti.dao.TeacherMapper.getTeacherById]-==&amp;gt; Parameters: 1(Integer)
[com.anti.dao.TeacherMapper.student]-====&amp;gt;  Preparing: select * from student 
[com.anti.dao.TeacherMapper.student]-====&amp;gt; Parameters: 
[com.anti.dao.TeacherMapper.student]-&amp;lt;====      Total: 5
[com.anti.dao.TeacherMapper.getTeacherById]-&amp;lt;==      Total: 1
Teacher(id=null, name=秦老师, students=[Student(id=1, name=小明), Student(id=2, name=小红), Student(id=3, name=小张), Student(id=4, name=小李), Student(id=5, name=小王)])
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1541219/202101/1541219-20210130005938275-1821306730.png&quot; alt=&quot;image-20201206145306565&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;10、分页&quot;&gt;10、分页&lt;/h2&gt;
&lt;p&gt;在学习 MyBatis 等持久层框架的时候，会经常对数据进行增删改查操作，使用最多的是对数据库进行查询操作，如果查询大量数据的时候，我们往往使用分页进行查询，也就是每次处理小部分数据，这样对数据库压力就在可控范围内。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用Limit实现分页&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;#语法
SELECT * FROM table LIMIT page,pageSize

page = 当前页数 = (page-1)*pageSize
pageSize = 一页多少条数据
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;UserMapper.java&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface UserMapper {
    //选择全部用户实现分页
    List&amp;lt;User&amp;gt; selectUser(Map&amp;lt;String,Integer&amp;gt; map);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;UserMapper.xml&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;select id=&quot;selectUser&quot; parameterType=&quot;map&quot; resultType=&quot;com.anti.pojo.User&quot;&amp;gt;
    select * from user limit #{page},#{pageSize}
&amp;lt;/select&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;MyTest.java&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void test01(){
    SqlSession session = MybatisUtils.getSession();
    UserMapper mapper = session.getMapper(UserMapper.class);

    HashMap&amp;lt;String, Integer&amp;gt; map = new HashMap&amp;lt;String, Integer&amp;gt;();
    int page = 1; //第几页
    int limit = 10; //每页多少数据
    map.put(&quot;page&quot;,(page-1) * limit);
    map.put(&quot;limit&quot;,limit);

    List&amp;lt;User&amp;gt; users = mapper.selectUser(map);
    for (User user : users) {
        System.out.println(user);
    }
    session.close();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果 :&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-verilog&quot;&gt;==&amp;gt;  Preparing: select * from user limit ?,? 
==&amp;gt; Parameters: 0(Integer), 10(Integer)
&amp;lt;==    Columns: uid, name, gender, birthday, dept, cno, address, phone, remark, password, type
&amp;lt;==        Row: 999, 管理员, M, 2020/09/02, AAA, 0, AAA, null, null, 123, 0
&amp;lt;==        Row: 10101, 怡香, M, 2020/02/08, Accounting, 1, Cameroon, 823-954-4217, null, 1, 1
&amp;lt;==        Row: 10102, 唯枫, M, 2020/01/25, Accounting, 2, Palestinian Territory, 978-827-9275, null, 2, 1
&amp;lt;==        Row: 10103, 海程, M, 2020/09/05, Human Resources, 3, Thailand, 978-712-9955, null, 3, 1
&amp;lt;==        Row: 10104, 琪煜, M, 2020/10/07, Accounting, 4, Palestinian Territory, 730-153-0025, null, 4, 1
&amp;lt;==        Row: 10105, 彦军, F, 2020/11/05, Services, 5, China, 504-460-1356, null, 5, 1
&amp;lt;==        Row: 10106, 宇涵, F, 2020/11/08, Product Management, 6, Argentina, 252-143-6848, null, 6, 1
&amp;lt;==        Row: 10107, 辰华, M, 2019/11/25, Business Development, 7, Philippines, 884-928-7856, null, 7, 1
&amp;lt;==        Row: 10108, 晓烽, M, 2020/08/05, Engineering, 8, Philippines, 152-366-5638, null, 8, 1
&amp;lt;==        Row: 10109, 尹智, F, 2020/01/12, Human Resources, 9, Argentina, 803-602-3704, null, 9, 1
&amp;lt;==      Total: 10
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;11、使用注解开发&quot;&gt;11、使用注解开发&lt;/h2&gt;
&lt;p&gt;​ &lt;strong&gt;MyBatis最初配置信息是基于 XML ,映射语句(SQL)也是定义在 XML 中的。而到MyBatis 3提供了新的基于注解的配置。不幸的是，java 注解的的表达力和灵活性十分有限。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​ &lt;strong&gt;最强大的 MyBatis 映射并不能用注解来构建&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;注解主要分成 :
&lt;ul&gt;&lt;li&gt;&lt;code&gt;@select ()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@update ()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Insert ()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@delete ()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;利用注解开发就不需要mapper.xml映射文件了 .&lt;/p&gt;
&lt;p&gt;1.在接口中添加注解&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface UserMapper {
        //查询全部用户
    @Select(&quot;select * from user&quot;)
    List&amp;lt;User&amp;gt; getUsers();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.在mybatis的核心配置文件中注入&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;!--使用class绑定接口--&amp;gt;
&amp;lt;mappers&amp;gt;
   &amp;lt;mapper class=&quot;com.anti.mapper.UserMapper&quot;/&amp;gt;
&amp;lt;/mappers&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.测试&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void test01(){
    UserMapper mapper = MybatisUtils.getSession().getMapper(UserMapper.class);
    List&amp;lt;User&amp;gt; users = mapper.getUsers();
    for (User user : users) {
        System.out.println(user);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4.结果&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Setting autocommit to false on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@3c0be339]
==&amp;gt;  Preparing: select * from user 
==&amp;gt; Parameters: 
&amp;lt;==    Columns: id, name, pwd
&amp;lt;==        Row: 1, 狂神, 123456
&amp;lt;==        Row: 2, 张三, abcdef
&amp;lt;==        Row: 3, 李四, 987654
&amp;lt;==        Row: 5, 王五, zxcvbn
&amp;lt;==      Total: 4
User(id=1, name=狂神, pwd=123456)
User(id=2, name=张三, pwd=abcdef)
User(id=3, name=李四, pwd=987654)
User(id=5, name=王五, pwd=zxcvbn)

Process finished with exit code 0
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;12、动态sql&quot;&gt;12、动态SQL&lt;/h2&gt;
&lt;h3 id=&quot;121、if-语句&quot;&gt;12.1、if 语句&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;!--需求1：
根据作者名字和博客名字来查询博客！
如果作者名字为空，那么只根据博客名字查询，反之，则根据作者名来查询
select * from blog where title = #{title} and author = #{author}
--&amp;gt;
&amp;lt;select id=&quot;queryBlogIf&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&amp;gt;
  select * from blog where
   &amp;lt;if test=&quot;title != null&quot;&amp;gt;
      title = #{title}
   &amp;lt;/if&amp;gt;
   &amp;lt;if test=&quot;author != null&quot;&amp;gt;
      and author = #{author}
   &amp;lt;/if&amp;gt;
&amp;lt;/select&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样写我们可以看到，如果 &lt;code&gt;author&lt;/code&gt; 等于 &lt;code&gt;null&lt;/code&gt;，那么查询语句为 &lt;code&gt;select * from user where title=#{title}&lt;/code&gt;,但是如果 &lt;code&gt;title&lt;/code&gt; 为空呢？那么查询语句为 &lt;code&gt;select * from user where and author=#{author}&lt;/code&gt;，这是错误的 SQL 语句，如何解决呢？请看下面的 where 语句！&lt;/p&gt;
&lt;h3 id=&quot;122、where-语句&quot;&gt;12.2、where 语句&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;select id=&quot;queryBlogIf&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&amp;gt;
  select * from blog
   &amp;lt;where&amp;gt;
       &amp;lt;if test=&quot;title != null&quot;&amp;gt;
          title = #{title}
       &amp;lt;/if&amp;gt;
       &amp;lt;if test=&quot;author != null&quot;&amp;gt;
          and author = #{author}
       &amp;lt;/if&amp;gt;
   &amp;lt;/where&amp;gt;
&amp;lt;/select&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个“where”标签会知道如果它包含的标签中有返回值的话，它就插入一个‘where’。此外，如果标签返回的内容是以AND 或OR 开头的，则它会剔除掉。&lt;/p&gt;
&lt;h3 id=&quot;123、set-语句&quot;&gt;12.3、set 语句&lt;/h3&gt;
&lt;p&gt;同理，上面的对于查询 SQL 语句包含 where 关键字，如果在进行更新操作的时候，含有 set 关键词，我们怎么处理呢？&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;!--注意set是用的逗号隔开--&amp;gt;
&amp;lt;update id=&quot;updateBlog&quot; parameterType=&quot;map&quot;&amp;gt;
  update blog
     &amp;lt;set&amp;gt;
         &amp;lt;if test=&quot;title != null&quot;&amp;gt;
            title = #{title},
         &amp;lt;/if&amp;gt;
         &amp;lt;if test=&quot;author != null&quot;&amp;gt;
            author = #{author}
         &amp;lt;/if&amp;gt;
     &amp;lt;/set&amp;gt;
  where id = #{id};
&amp;lt;/update&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;124、choose-语句&quot;&gt;12.4、choose 语句&lt;/h3&gt;
&lt;p&gt;有时候，我们不想用到所有的查询条件，只想选择其中的一个，查询条件有一个满足即可，使用 choose 标签可以解决此类问题，类似于 Java 的 switch 语句。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;choose 与 if 的区别：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;if 如果条件都满足会带出&lt;strong&gt;所有&lt;/strong&gt;满足条件的语句&lt;/li&gt;
&lt;li&gt;choose 只会带出最先满足的条件的语句&lt;/li&gt;
&lt;li&gt;choose 如果没有满足的条件会执行 otherwise 语句&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;select id=&quot;queryBlogChoose&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&amp;gt;
  select * from blog
   &amp;lt;where&amp;gt;
       &amp;lt;choose&amp;gt;
           &amp;lt;when test=&quot;title != null&quot;&amp;gt;
                title = #{title}
           &amp;lt;/when&amp;gt;
           &amp;lt;when test=&quot;author != null&quot;&amp;gt;
              and author = #{author}
           &amp;lt;/when&amp;gt;
           &amp;lt;otherwise&amp;gt;
              and views = #{views}
           &amp;lt;/otherwise&amp;gt;
       &amp;lt;/choose&amp;gt;
   &amp;lt;/where&amp;gt;
&amp;lt;/select&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;125、sql-片段&quot;&gt;12.5、SQL 片段&lt;/h3&gt;
&lt;p&gt;有时候可能某个 sql 语句我们用的特别多，为了增加代码的重用性，简化代码，我们需要将这些代码抽取出来，然后使用时直接调用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;提取SQL片段：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;sql id=&quot;if-title-author&quot;&amp;gt;
   &amp;lt;if test=&quot;title != null&quot;&amp;gt;
      title = #{title}
   &amp;lt;/if&amp;gt;
   &amp;lt;if test=&quot;author != null&quot;&amp;gt;
      and author = #{author}
   &amp;lt;/if&amp;gt;
&amp;lt;/sql&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;引用SQL片段：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;select id=&quot;queryBlogIf&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&amp;gt;
  select * from blog
   &amp;lt;where&amp;gt;
       &amp;lt;!-- 引用 sql 片段，如果refid 指定的不在本文件中，那么需要在前面加上 namespace --&amp;gt;
       &amp;lt;include refid=&quot;if-title-author&quot;&amp;gt;&amp;lt;/include&amp;gt;
       &amp;lt;!-- 在这里还可以引用其他的 sql 片段 --&amp;gt;
   &amp;lt;/where&amp;gt;
&amp;lt;/select&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;最好基于 单表来定义 sql 片段，提高片段的可重用性&lt;/li&gt;
&lt;li&gt;在 sql 片段中不要包括 where&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;126、foreach-语句&quot;&gt;12.6、foreach 语句&lt;/h3&gt;
&lt;p&gt;需求：我们需要查询 blog 表中 id 分别为1,2,3的博客信息&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;select id=&quot;queryBlogForeach&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&amp;gt;
  select * from blog
   &amp;lt;where&amp;gt;
       &amp;lt;!--
       collection:指定输入对象中的集合属性
       item:每次遍历生成的对象
       open:开始遍历时的拼接字符串
       close:结束时拼接的字符串
       separator:遍历对象之间需要拼接的字符串
       select * from blog where 1=1 and (id=1 or id=2 or id=3)
     --&amp;gt;
       &amp;lt;foreach collection=&quot;ids&quot;  item=&quot;id&quot; open=&quot;and (&quot; close=&quot;)&quot; separator=&quot;or&quot;&amp;gt;
          id=#{id}
       &amp;lt;/foreach&amp;gt;
   &amp;lt;/where&amp;gt;
&amp;lt;/select&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;小结：&lt;/p&gt;
&lt;p&gt;其实动态 sql 语句的编写往往就是一个拼接的问题，为了保证拼接准确，我们最好首先要写原生的 sql 语句出来，然后在通过 mybatis 动态sql 对照着改，防止出错。多在实践中使用才是熟练掌握它的技巧。&lt;/p&gt;
&lt;h2 id=&quot;13、缓存&quot;&gt;13、缓存&lt;/h2&gt;
&lt;p&gt;1、什么是缓存 [ Cache ]？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;存在内存中的临时数据。&lt;/li&gt;
&lt;li&gt;将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上(关系型数据库数据文件)查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;2、为什么使用缓存？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;减少和数据库的交互次数，减少系统开销，提高系统效率。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;3、什么样的数据能使用缓存？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;经常查询并且不经常改变的数据。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;131、mybatis缓存&quot;&gt;13.1、Mybatis缓存&lt;/h3&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;MyBatis包含一个非常强大的查询缓存特性，它可以非常方便地定制和配置缓存。缓存可以极大的提升查询效率。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;MyBatis系统中默认定义了两级缓存：&lt;strong&gt;一级缓存&lt;/strong&gt; 和 &lt;strong&gt;二级缓存&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;默认情况下，只有一级缓存开启。（SqlSession级别的缓存，也称为本地缓存）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;二级缓存需要手动开启和配置，他是基于namespace级别的缓存。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;为了提高扩展性，MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;132、一级缓存&quot;&gt;13.2、一级缓存&lt;/h3&gt;
&lt;p&gt;一级缓存也叫本地缓存：&lt;/p&gt;
&lt;p&gt;1.在mybatis中加入日志，方便测试结果&lt;/p&gt;
&lt;p&gt;2.编写接口方法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//根据id查询用户
User queryUserById(@Param(&quot;id&quot;) int id);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.接口对应的Mapper文件&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;select id=&quot;queryUserById&quot; resultType=&quot;user&quot;&amp;gt;
  select * from user where id = #{id}
&amp;lt;/select&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4.测试&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void testQueryUserById(){
   SqlSession session = MybatisUtils.getSession();
   UserMapper mapper = session.getMapper(UserMapper.class);

   User user = mapper.queryUserById(1);
   System.out.println(user);
   User user2 = mapper.queryUserById(1);
   System.out.println(user2);
   System.out.println(user==user2);

   session.close();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;5.结果分析&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1541219/202101/1541219-20210130005938447-1960307212.png&quot; alt=&quot;image-20201206213629212&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;133、一级缓存失效的四种情况&quot;&gt;13.3、一级缓存失效的四种情况:&lt;/h3&gt;
&lt;p&gt;一级缓存是SqlSession级别的缓存，是一直开启的，我们关闭不了它；&lt;/p&gt;
&lt;p&gt;一级缓存失效情况：没有使用到当前的一级缓存，效果就是，还需要再向数据库中发起一次查询请求！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.sqlSession不同&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void testQueryUserById(){
   SqlSession session = MybatisUtils.getSession();
   SqlSession session2 = MybatisUtils.getSession();
   UserMapper mapper = session.getMapper(UserMapper.class);
   UserMapper mapper2 = session2.getMapper(UserMapper.class);

   User user = mapper.queryUserById(1);
   System.out.println(user);
   User user2 = mapper2.queryUserById(1);
   System.out.println(user2);
   System.out.println(user==user2);

   session.close();
   session2.close();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;观察结果：发现发送了两条SQL语句！&lt;/p&gt;
&lt;p&gt;结论：&lt;strong&gt;每个sqlSession中的缓存相互独立&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.sqlSession相同，查询条件不同&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void testQueryUserById(){
   SqlSession session = MybatisUtils.getSession();
   UserMapper mapper = session.getMapper(UserMapper.class);
   UserMapper mapper2 = session.getMapper(UserMapper.class);

   User user = mapper.queryUserById(1);
   System.out.println(user);
   User user2 = mapper2.queryUserById(2);
   System.out.println(user2);
   System.out.println(user==user2);

   session.close();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;观察结果：发现发送了两条SQL语句！很正常的理解&lt;/p&gt;
&lt;p&gt;结论：&lt;strong&gt;当前缓存中，不存在这个数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.sqlSession相同，两次查询之间执行了增删改操作！&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void testQueryUserById(){
   SqlSession session = MybatisUtils.getSession();
   UserMapper mapper = session.getMapper(UserMapper.class);

   User user = mapper.queryUserById(1);
   System.out.println(user);

   HashMap map = new HashMap();
   map.put(&quot;name&quot;,&quot;kuangshen&quot;);
   map.put(&quot;id&quot;,4);
   mapper.updateUser(map);

   User user2 = mapper.queryUserById(1);
   System.out.println(user2);

   System.out.println(user==user2);

   session.close();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;观察结果：查询在中间执行了增删改操作后，重新执行了&lt;/p&gt;
&lt;p&gt;结论：&lt;strong&gt;因为增删改操作可能会对当前数据产生影响&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.sqlSession相同，手动清除一级缓存&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void testQueryUserById(){
   SqlSession session = MybatisUtils.getSession();
   UserMapper mapper = session.getMapper(UserMapper.class);

   User user = mapper.queryUserById(1);
   System.out.println(user);

   session.clearCache();//手动清除缓存

   User user2 = mapper.queryUserById(1);
   System.out.println(user2);

   System.out.println(user==user2);

   session.close();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一级缓存就是一个map&lt;/p&gt;
&lt;h3 id=&quot;134、二级缓存&quot;&gt;13.4、二级缓存&lt;/h3&gt;
&lt;p&gt;1.开启全局缓存 【mybatis-config.xml】&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.去每个mapper.xml中配置使用二级缓存，这个配置非常简单；【xxxMapper.xml】&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;cache/&amp;gt;

官方示例=====&amp;gt;查看官方文档
&amp;lt;cache
 eviction=&quot;FIFO&quot;
 flushInterval=&quot;60000&quot;
 size=&quot;512&quot;
 readOnly=&quot;true&quot;
/&amp;gt;
这个更高级的配置创建了一个 FIFO 缓存，每隔 60 秒刷新，最多可以存储结果对象或列表的 512 个引用，而且返回的对象被认为是只读的，因此对它们进行修改可能会在不同线程中的调用者产生冲突。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.代码测试&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;所有的实体类先实现序列化接口&lt;/li&gt;
&lt;li&gt;测试代码&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void testQueryUserById(){
   SqlSession session = MybatisUtils.getSession();
   SqlSession session2 = MybatisUtils.getSession();

   UserMapper mapper = session.getMapper(UserMapper.class);
   UserMapper mapper2 = session2.getMapper(UserMapper.class);

   User user = mapper.queryUserById(1);
   System.out.println(user);
   session.close();

   User user2 = mapper2.queryUserById(1);
   System.out.println(user2);
   System.out.println(user==user2);

   session2.close();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1541219/202101/1541219-20210130005938644-1386369591.png&quot; alt=&quot;image-20201206214729672&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;结论：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;只要开启了二级缓存，我们在同一个Mapper中的查询，可以在二级缓存中拿到数据&lt;/li&gt;
&lt;li&gt;查出的数据都会被默认先放在一级缓存中&lt;/li&gt;
&lt;li&gt;只有会话提交或者关闭以后，一级缓存中的数据才会转到二级缓存中&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;缓存原理图：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1541219/202101/1541219-20210130005938915-1627391220.png&quot; alt=&quot;image-20201206214908158&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;135、第三方缓存实现-ehcache&quot;&gt;13.5、第三方缓存实现 EhCache&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1541219/202101/1541219-20210130005939233-1402660519.png&quot; alt=&quot;image-20210130005613005&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Ehcache是一种广泛使用的 java 分布式缓存，用于通用缓存；&lt;/p&gt;
&lt;p&gt;1.要在应用程序中使用Ehcache，需要引入依赖的 jar 包&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;!-- https://mvnrepository.com/artifact/org.mybatis.caches/mybatis-ehcache --&amp;gt;
&amp;lt;dependency&amp;gt;
   &amp;lt;groupId&amp;gt;org.mybatis.caches&amp;lt;/groupId&amp;gt;
   &amp;lt;artifactId&amp;gt;mybatis-ehcache&amp;lt;/artifactId&amp;gt;
   &amp;lt;version&amp;gt;1.1.0&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.在mapper.xml中使用对应的缓存即可&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;mapper namespace = “org.acme.FooMapper” &amp;gt;
   &amp;lt;cache type = “org.mybatis.caches.ehcache.EhcacheCache” /&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.编写ehcache.xml文件，如果在加载时未找到/ehcache.xml资源或出现问题，则将使用默认配置。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xsi:noNamespaceSchemaLocation=&quot;http://ehcache.org/ehcache.xsd&quot;
        updateCheck=&quot;false&quot;&amp;gt;
   &amp;lt;!--
      diskStore：为缓存路径，ehcache分为内存和磁盘两级，此属性定义磁盘的缓存位置。参数解释如下：
      user.home – 用户主目录
      user.dir – 用户当前工作目录
      java.io.tmpdir – 默认临时文件路径
    --&amp;gt;
   &amp;lt;diskStore path=&quot;./tmpdir/Tmp_EhCache&quot;/&amp;gt;
   
   &amp;lt;defaultCache
           eternal=&quot;false&quot;
           maxElementsInMemory=&quot;10000&quot;
           overflowToDisk=&quot;false&quot;
           diskPersistent=&quot;false&quot;
           timeToIdleSeconds=&quot;1800&quot;
           timeToLiveSeconds=&quot;259200&quot;
           memoryStoreEvictionPolicy=&quot;LRU&quot;/&amp;gt;

   &amp;lt;cache
           name=&quot;cloud_user&quot;
           eternal=&quot;false&quot;
           maxElementsInMemory=&quot;5000&quot;
           overflowToDisk=&quot;false&quot;
           diskPersistent=&quot;false&quot;
           timeToIdleSeconds=&quot;1800&quot;
           timeToLiveSeconds=&quot;1800&quot;
           memoryStoreEvictionPolicy=&quot;LRU&quot;/&amp;gt;
   &amp;lt;!--
      defaultCache：默认缓存策略，当ehcache找不到定义的缓存时，则使用这个缓存策略。只能定义一个。
    --&amp;gt;
   &amp;lt;!--
     name:缓存名称。
     maxElementsInMemory:缓存最大数目
     maxElementsOnDisk：硬盘最大缓存个数。
     eternal:对象是否永久有效，一但设置了，timeout将不起作用。
     overflowToDisk:是否保存到磁盘，当系统当机时
     timeToIdleSeconds:设置对象在失效前的允许闲置时间（单位：秒）。仅当eternal=false对象不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。
     timeToLiveSeconds:设置对象在失效前允许存活时间（单位：秒）。最大时间介于创建时间和失效时间之间。仅当eternal=false对象不是永久有效时使用，默认是0.，也就是对象存活时间无穷大。
     diskPersistent：是否缓存虚拟机重启期数据 Whether the disk store persists between restarts of the Virtual Machine. The default value is false.
     diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区。
     diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒。
     memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。
     clearOnFlush：内存数量最大时是否清除。
     memoryStoreEvictionPolicy:可选策略有：LRU（最近最少使用，默认策略）、FIFO（先进先出）、LFU（最少访问次数）。
     FIFO，first in first out，这个是大家最熟的，先进先出。
     LFU， Less Frequently Used，就是上面例子中使用的策略，直白一点就是讲一直以来最少被使用的。如上面所讲，缓存的元素有一个hit属性，hit值最小的将会被清出缓存。
     LRU，Least Recently Used，最近最少使用的，缓存的元素有一个时间戳，当缓存容量满了，而又需要腾出地方来缓存新的元素的时候，那么现有缓存元素中时间戳离当前时间最远的元素将被清出缓存。
  --&amp;gt;

&amp;lt;/ehcache&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;14、mybatis详细的执行流程&quot;&gt;14、Mybatis详细的执行流程&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LZwwtchlelS8kzAAyVia5uNvhic22X8ahJy5BdOfjy1LlDRfo8Nf3GOAzwALgvriau4SzmXZIhUUd2A/640?wx_fmt=png&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;img&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 29 Jan 2021 17:00:00 +0000</pubDate>
<dc:creator>ANTIA11</dc:creator>
<og:description>1、简介 环境说明： jdk 8 + MySQL 5.7.19 maven-3.6.1 IDEA 学习前需要掌握： JDBC MySQL Java 基础 Maven Junit 1.1、什么是 MyB</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/antaia11/p/14347814.html</dc:identifier>
</item>
<item>
<title>JPEG解码——(3)文件头解析 - OnlyTime_唯有时光</title>
<link>http://www.cnblogs.com/Dreaming-in-Gottingen/p/14347789.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Dreaming-in-Gottingen/p/14347789.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　与具体的编码数据空间相比，jpeg文件头占据非常小乃至可以忽略不计的大小。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　仍然拿&lt;span&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2 vertical-middle&quot; href=&quot;https://www.cnblogs.com/Dreaming-in-Gottingen/p/14285605.html&quot;&gt;&lt;span&gt;JPEG解码--(1)JPEG文件格式概览&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;中的《animal park》这张图片来举例，从跳过SOS(FF DA)的TAG开始——0x153，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;就真正进入了编码数据区域，如下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1770222/202101/1770222-20210129235216123-1179184789.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　其占据的比例为：0x153/0x9721 = 339/38689 = 0.876%，还不到1%，其他jpeg图片也是类似情况。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　但是，就是这么小的数据区域，却是至关重要的地方，某些关键的地方一个字节出错了的话，解码就会出错（例如huffman table&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;中数据），或者重建出的yuv图像异常（例如quantization table中数据）！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　本篇博客主要介绍jpeg头信息解析，其中除了huffman table重建较复杂外，其他TAG的解析都比较容易。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1. APP0——FF EO&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　先贴出这段区域：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1770222/202101/1770222-20210130000934614-1081789853.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　从ASCII值可以看出，保存了JFIF——&lt;span class=&quot;op_dict3_highlight&quot;&gt;JPEG File Interchange Format（JPEG文件交换格式），后面的几个字节应该是version信&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;op_dict3_highlight&quot;&gt;息吧，没深究。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span class=&quot;op_dict3_highlight&quot;&gt;2. DQT——FF DB&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;op_dict3_highlight&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1770222/202101/1770222-20210130001337691-2052223105.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　量化表有两个，上面贴图只高亮了其中一个表。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　从offset=0x16开始的两个字节（0x00 43）为这段区域的size=67，后面的一个字节为表的ID——0x00=0（可以看到第二张表中对&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;应位置offset=0x5D处为0x1）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　跳过前面三字节从offset=0x19处开始的64字节，即为量化表中量化值。其中需要说明的是，量化值是固定为64字节的，因为按8X8&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;进行DCT变换的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　工具解析的结果如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1770222/202101/1770222-20210130002234920-686393230.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　需要补充两点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　A.亮度信号的Y分量使用DQT表一，UV分量使用表二。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　B.亮度信号通常采用细量化（量化值较小），对应位置处，表一通常比表二值要小。此量化原因是人眼对亮度信号比较敏感，采用颗粒度&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;较细来&lt;/span&gt;&lt;span&gt;量化，细量化引入的一个问题会消耗更多的数据空间。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3. SOF——FF C0&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1770222/202101/1770222-20210130003007688-363223783.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在该JPEG解码系列中第一篇已经详细介绍过了，不再赘述。工具解析如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1770222/202101/1770222-20210130003231741-961179399.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4. DHT——FF C4&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1770222/202101/1770222-20210130003418397-1268076119.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　共有四张表，上面只贴出第一张表。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　DHT表的重建有些复杂，涉及底层更多关于数据压缩领域的知识，可以参考“范式霍夫曼编码”相关材料，本博文不再做介绍该编码原理。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 29 Jan 2021 16:48:00 +0000</pubDate>
<dc:creator>OnlyTime_唯有时光</dc:creator>
<og:description>与具体的编码数据空间相比，jpeg文件头占据非常小乃至可以忽略不计的大小。 仍然拿JPEG解码--(1)JPEG文件格式概览中的《animal park》这张图片来举例，从跳过SOS(FF DA)的T</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Dreaming-in-Gottingen/p/14347789.html</dc:identifier>
</item>
<item>
<title>浅析 record 使用场景 - WeihanLi</title>
<link>http://www.cnblogs.com/weihanli/p/14347769.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/weihanli/p/14347769.html</guid>
<description>&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;/h2&gt;
&lt;p&gt;之前我们有介绍过 &lt;code&gt;record&lt;/code&gt; 基本知识，&lt;code&gt;record&lt;/code&gt; 会实现基于值的类型比较，最近遇到的几个问题觉得用 &lt;code&gt;record&lt;/code&gt; 来解决会非常方便，分享一下&lt;/p&gt;
&lt;h2 id=&quot;基于值的类型比较&quot;&gt;基于值的类型比较&lt;/h2&gt;
&lt;p&gt;最近有遇到一个场景，需要比较两个 JSON 字符串是否相等，字符串比较简单，就是一个固定值的 &lt;code&gt;Dictionary&lt;/code&gt;，或者认为它就是一个简单的 &lt;code&gt;Model&lt;/code&gt;，但是 JSON 字符串的的属性顺序可能不同，比如说下面的这个示例：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;{&quot;Id&quot;:1, &quot;Name&quot;:&quot;Tom&quot;}&lt;/code&gt;, &lt;code&gt;{&quot;Name&quot;:&quot;Tom&quot;, &quot;Id&quot;:1}&lt;/code&gt;，这两个字符串从字符串上来说顺序不同，自然不相等，但是对应的属性的值是相同的，怎么比较方便的进行比较呢，使用 &lt;code&gt;record&lt;/code&gt; 可以比较方便进行比较，来看代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;record Person(int Id, string Name);

[Fact]
public void RecordTest()
{
    var str1 = &quot;{\&quot;Id\&quot;:1, \&quot;Name\&quot;:\&quot;Tom\&quot;}&quot;;
    var p1 = JsonConvert.DeserializeObject&amp;lt;Person&amp;gt;(str1);

    var str2 = &quot;{\&quot;Name\&quot;:\&quot;Tom\&quot;,\&quot;Id\&quot;:1}&quot;;
    var p2 = JsonConvert.DeserializeObject&amp;lt;Person&amp;gt;(str2);

    Assert.True(p1 == p2);
    Assert.Equal(p1, p2);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;基于值比较的去重&quot;&gt;基于值比较的去重&lt;/h2&gt;
&lt;p&gt;我们有一个 API 有收到反馈说，调用多次返回的结果不同，于是我就想写一段代码调用个一百次看是否会有重复，大致代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public record Result
{
    public string Data { get; set;}
    public int Code { get; set; }
}

var i = 100;
var results = new HashSet&amp;lt;Result&amp;gt;();
using var httpClient = new HttpClient();
while(i-- &amp;gt; 0)
{
    var responseText = await httpClient.GetStringAsync(&quot;&quot;);
    var result = JsonConvert.DeserializeObject&amp;lt;Result&amp;gt;(responseText);
    results.Add(result);
}
Console.WriteLine(results.Count);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为 &lt;code&gt;record&lt;/code&gt; 不仅会重写 &lt;code&gt;Equals&lt;/code&gt; 方法还会重写 &lt;code&gt;GetHashCode&lt;/code&gt; 方法，所以可以使用 &lt;code&gt;HashSet&lt;/code&gt; 或者 &lt;code&gt;Dictionary&lt;/code&gt; 来实现去重&lt;/p&gt;
&lt;h2 id=&quot;对象克隆&quot;&gt;对象克隆&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;record&lt;/code&gt; 提供了 &lt;code&gt;with&lt;/code&gt; 表达式来方便的克隆一个新的对象，所以在需要克隆的时候可以考虑使用 &lt;code&gt;record&lt;/code&gt;，另外所有原型模式的地方都可以考虑使用 &lt;code&gt;record&lt;/code&gt; 来实现&lt;/p&gt;
&lt;p&gt;之前我实现了一个简单的日志框架，有一个日志对象，定义如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public class LogHelperLoggingEvent : ICloneable
{
    public string CategoryName { get; set; }

    public DateTimeOffset DateTime { get; set; }

    public string MessageTemplate { get; set; }

    public string Message { get; set; }

    public LogHelperLogLevel LogLevel { get; set; }

    public Dictionary&amp;lt;string, object&amp;gt; Properties { get; set; }

    public LogHelperLoggingEvent Copy() 
    {
        var newEvent = new LogHelperLoggingEvent()
        {
            CategoryName = CategoryName,
            DateTime = DateTime,
            MessageTemplate = MessageTemplate,
            Message = Message,
            LogLevel = LogLevel
        };
        if (Properties != null)
        {
            newEvent.Properties = new Dictionary&amp;lt;string, object&amp;gt;();
            foreach (var property in Properties)
            {
                newEvent.Properties[property.Key] = property.Value;
            }
        }
        return newEvent;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以使用 &lt;code&gt;MemberwiseClone&lt;/code&gt; 做一个简化&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public class LogHelperLoggingEvent : ICloneable
{
    public string CategoryName { get; set; }

    public DateTimeOffset DateTime { get; set; }

    public string MessageTemplate { get; set; }

    public string Message { get; set; }

    public LogHelperLogLevel LogLevel { get; set; }

    public Dictionary&amp;lt;string, object&amp;gt; Properties { get; set; }

    public LogHelperLoggingEvent Copy()
    {
        var newEvent = (LogHelperLoggingEvent)MemberwiseClone();
        if (Properties != null)
        {
            newEvent.Properties = new Dictionary&amp;lt;string, object&amp;gt;();
            foreach (var property in Properties)
            {
                newEvent.Properties[property.Key] = property.Value;
            }
        }
        return newEvent;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用了 &lt;code&gt;record&lt;/code&gt; 之后如下，&lt;code&gt;with&lt;/code&gt; 表达式返回的是强类型的对象，不再需要自己做强制类型转换了，上面的做法还是比较取巧的办法，使用了 &lt;code&gt;MemberwiseClone&lt;/code&gt; 去做复制，如果自己写代码一个一个复制，将会更加繁琐，使用 &lt;code&gt;record&lt;/code&gt; 之后就很简单了，只是我们需要注意一下，&lt;code&gt;with&lt;/code&gt; 表达式也只是浅复制，如果内部包含复杂引用类型，需要小心使用&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public record LogHelperLoggingEvent
{
    public string CategoryName { get; set; }

    public DateTimeOffset DateTime { get; set; }

    public string MessageTemplate { get; set; }

    public string Message { get; set; }

    public LogHelperLogLevel LogLevel { get; set; }

    public Dictionary&amp;lt;string, object&amp;gt; Properties { get; set; }

    public LogHelperLoggingEvent Copy()
    {
        var newEvent = this with{ };
        if (Properties != null)
        {
            newEvent.Properties = new Dictionary&amp;lt;string, object&amp;gt;();
            foreach (var property in Properties)
            {
                newEvent.Properties[property.Key] = property.Value;
            }
        }
        return newEvent;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;more&quot;&gt;More&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;record&lt;/code&gt; 在很多场景下能够简化我们的代码，使得代码更加干净简洁，在合适的场景下不要忘记使用哦~&lt;/p&gt;
&lt;p&gt;微软的反向代理项目 YARP 也使用了 &lt;code&gt;record&lt;/code&gt; 来简化原来代码中 &lt;code&gt;DeepClone&lt;/code&gt; 的功能，可以参考 PR：&lt;a href=&quot;https://github.com/microsoft/reverse-proxy/pull/662&quot; target=&quot;_blank&quot;&gt;https://github.com/microsoft/reverse-proxy/pull/662&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 29 Jan 2021 16:31:00 +0000</pubDate>
<dc:creator>WeihanLi</dc:creator>
<og:description>record</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/weihanli/p/14347769.html</dc:identifier>
</item>
<item>
<title>Asp.netCore 3.1控制器属性注入and异步事务Aop by AutoFac - 做自己-jason</title>
<link>http://www.cnblogs.com/Fengge518/p/14347759.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Fengge518/p/14347759.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;Aspect Oriented Programming（AOP）是较为热门的一个话题。AOP，国内我们都习惯称之为：面向切面编程&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;下面直接code 干货展示：(&lt;/strong&gt;一般人我还不告诉,嘻嘻)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1:导入相关的包：AutoFac 默认最新稳定版即可&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Autofac.Extensions.DependencyInjection Version=&quot;7.1.0&quot; &lt;/span&gt;&lt;br/&gt;&lt;span&gt;Autofac.Extras.DynamicProxy Version=&quot;6.0.0&quot;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2：AutoFac注入的扩展方法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; ZRF.CRM.Commoms
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;using&lt;/span&gt;&lt;span&gt; Autofac;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;using&lt;/span&gt;&lt;span&gt; Autofac.Extras.DynamicProxy;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Mvc;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Reflection;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;using&lt;/span&gt;&lt;span&gt; ZRF.CRM.Commoms.Interceptors;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;using&lt;/span&gt;&lt;span&gt; ZRF.CRM.MyAttrobutrs;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ContainerBuilderExtenTion
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; DependInjecterIoc(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; ContainerBuilder builder)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             builder.RegisterType&amp;lt;TransactionScopeAsyncInterCeptor&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             builder.RegisterAssemblyTypes(Assembly.Load(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ZRF.CRM.Service&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                 .AsImplementedInterfaces().PropertiesAutowired().InterceptedBy(&lt;span&gt;typeof&lt;/span&gt;(TransactionScopeAsyncInterCeptor)).EnableInterfaceInterceptors().OnRegistered(t =&amp;gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                     Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ZRF.CRM.Service===Register_ok&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;                });
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3：新增ConfigureContainer(ContainerBuilder builder)方法，并在Startup方法中注册&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Reflection;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; Autofac;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Builder;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Hosting;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Mvc;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Mvc.Controllers;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.Configuration;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.DependencyInjection;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.DependencyInjection.Extensions;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.Hosting;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; WebApplication1.IOCS;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; ZRF.CRM.Commoms;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; WebApplication1
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Startup
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Startup(IConfiguration configuration)
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             Configuration =&lt;span&gt; configuration;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureContainer(ContainerBuilder builder)
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;            builder.DependInjecterIoc();
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;控制器属性注入&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;             builder.RegisterModule&amp;lt;ControllerModule&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; IConfiguration Configuration { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; This method gets called by the runtime. Use this method to add services to the container.&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;            services.AddControllersWithViews();
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; 
&lt;span&gt;40&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;core 3.0级以上&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt;             services.Replace(ServiceDescriptor.Transient&amp;lt;IControllerActivator, ServiceBasedControllerActivator&amp;gt;&lt;span&gt;());
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; 
&lt;span&gt;44&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; This method gets called by the runtime. Use this method to configure the HTTP request pipeline.&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app, IWebHostEnvironment env)
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (env.IsDevelopment())
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;                app.UseDeveloperExceptionPage();
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;52&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;                 app.UseExceptionHandler(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/Home/Error&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;            app.UseStaticFiles();
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; 
&lt;span&gt;57&lt;/span&gt; &lt;span&gt;            app.UseRouting();
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; 
&lt;span&gt;59&lt;/span&gt; &lt;span&gt;            app.UseAuthorization();
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; 
&lt;span&gt;61&lt;/span&gt;             app.UseEndpoints(endpoints =&amp;gt;
&lt;span&gt;62&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; &lt;span&gt;                endpoints.MapControllerRoute(
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;                     name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;                     pattern: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{controller=Home}/{action=Index}/{id?}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt; &lt;span&gt;            });
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4：Controller&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Mvc;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.Logging;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Diagnostics;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; WebApplication1.Models;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; ZRF.CRM.MyAttrobutrs;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; ZRF.CRM.InterFaces;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; WebApplication1.Controllers
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    [ControllerCanInjectPropertity]
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HomeController : Controller
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; ILogger&amp;lt;HomeController&amp;gt;&lt;span&gt; _logger;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        IDoLog _dolog;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        ITest002Service _service;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; IDoLog _dolog2 { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; HomeController(ILogger&amp;lt;HomeController&amp;gt;&lt;span&gt; logger, IDoLog dolog, ITest002Service service)
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             _logger =&lt;span&gt; logger;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             _dolog =&lt;span&gt; dolog;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;._service =&lt;span&gt; service;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; IActionResult Index()
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; boolflag = _dolog2.LogWork(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;aaaa&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             &lt;span&gt;bool&lt;/span&gt; flag = _dolog.LogWork(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;qqai&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; getMsg = _service.Dowork(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;有aop的方法&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Aop获取到方法：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; getMsg);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;_service.DoWork02(&quot;没有aop的普通方法&quot;);&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; View();
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; 
&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; IActionResult Privacy()
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; View();
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; 
&lt;span&gt;44&lt;/span&gt;         [ResponseCache(Duration = &lt;span&gt;0&lt;/span&gt;, Location = ResponseCacheLocation.None, NoStore = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; IActionResult Error()
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; View(&lt;span&gt;new&lt;/span&gt; ErrorViewModel { RequestId = Activity.Current?.Id ??&lt;span&gt; HttpContext.TraceIdentifier });
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;5:InterFace &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; ZRF.CRM.InterFaces
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     
&lt;span&gt; 8&lt;/span&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; ITest002Service
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;string&lt;/span&gt; Dowork(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; msg);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;string&lt;/span&gt; DoWork02(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; msg);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;6：Service&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; ZRF.CRM.Service
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;using&lt;/span&gt;&lt;span&gt; ZRF.CRM.InterFaces;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;using&lt;/span&gt;&lt;span&gt; ZRF.CRM.MyAttrobutrs;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test002Service : ITest002Service
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        [TransactionScopeAsync]
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Dowork(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; msg)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Test002Service:Dowork {DateTime.Now}-{msg}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; DoWork02(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; msg)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Test002Service:DoWork02:{DateTime.Now}-{msg}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;7：自定义特性，将来判断哪些方法可以aop&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; ZRF.CRM.MyAttrobutrs
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    [AttributeUsage(AttributeTargets.Method)]
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TransactionScopeAsyncAttribute : Attribute
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;8:自定义类来实现Aop的IInterceptor方法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; ZRF.CRM.Commoms.Interceptors
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;using&lt;/span&gt;&lt;span&gt; Autofac;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;using&lt;/span&gt;&lt;span&gt; Castle.DynamicProxy;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Reflection;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Transactions;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;using&lt;/span&gt;&lt;span&gt; ZRF.CRM.MyAttrobutrs;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TransactionScopeAsyncInterCeptor : IInterceptor
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Intercept(IInvocation invocation)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (HaveAsyncTrascAttribute(invocation))
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                 TransactionScope scope = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                 &lt;span&gt;try&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                     scope = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TransactionScope(TransactionScopeAsyncFlowOption.Enabled);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                     Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TransactionScopeAsyncFlowOption之前=======&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;                    invocation.Proceed();
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;                    scope.Complete();
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                     Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;invocation.Proceed()用户自己的逻辑处理ok=======&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                     Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TransactionScopeAsyncFlowOption之后=======&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                 &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception)
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;                     Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TransactionScopeAsyncInterCeptor：发生异常&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (scope != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;                        scope.Dispose();
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;                 Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;没有异步事务发生！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;                invocation.Proceed();
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; 
&lt;span&gt;46&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; HaveAsyncTrascAttribute(IInvocation invocation)
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; methodInfo = invocation.MethodInvocationTarget ??&lt;span&gt; invocation.Method;
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (methodInfo.GetCustomAttribute&amp;lt;TransactionScopeAsyncAttribute&amp;gt;() != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;9：来一张测试的截图&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1734768/202101/1734768-20210130002259072-1583045237.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;10：最后欢迎留言指教&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 29 Jan 2021 16:26:00 +0000</pubDate>
<dc:creator>做自己-jason</dc:creator>
<og:description>Aspect Oriented Programming（AOP）是较为热门的一个话题。AOP，国内我们都习惯称之为：面向切面编程 下面直接code 干货展示：(一般人我还不告诉,嘻嘻) 1:导入相关的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Fengge518/p/14347759.html</dc:identifier>
</item>
<item>
<title>《思维力量》阅读笔记 - 欧与贾之歌</title>
<link>http://www.cnblogs.com/Euler-Jiaxu/p/14347643.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Euler-Jiaxu/p/14347643.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1618555/202101/1618555-20210129233700836-112847288.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;《思维力量：如何思考、决策、行动以及取得更佳成效》，当当评分4星半，或许也是一本成功学的书，但好在内容不长，语言精炼，没有大篇幅的案例分析；内容没有新鲜的观点，大致也是强调要有目标、要行动、重大决定不要马上决定等等。但是如果是温习一下这些观点，不妨一看。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以下是我看完之后的笔记。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;①行动即一切。所有的行动都致力于要实现某种改进“意外后果定律”和“错误后果定律”。意外后果定律：很多情况下，一种行为带来的短期结果是积极的，但从长远来看影响可能非常消极。&lt;/p&gt;
&lt;p&gt;错误后果定律：一个非常积极的行动带来的结果却是比什么都不做造成的后果还要糟糕。&lt;/p&gt;
&lt;p&gt;②成功的人愿意牺牲或延迟当前即时的满足和喜悦，这是短期的，他们愿意享受未来更大的回报，这就是长期的。&lt;/p&gt;
&lt;p&gt;③练习“未来倒逼”机制，形成看待问题的长期视角。&lt;/p&gt;
&lt;p&gt;④大家通常会高估他们一年内能完成的任务，但会极大低估他们五年内能完成的任务。&lt;/p&gt;
&lt;p&gt;⑤训练自己自律、自控和自我管理的能力。 &lt;/p&gt;

&lt;p&gt;①在做出一个对生活和工作可能产生积极或消极影响的决策之前，必须要放慢节奏。&lt;/p&gt;
&lt;p&gt;②一种做起来比较简单的方法就是在我们接受一条信息，并把它当成自己做决策的前提时，不断地问自己“怎么知道这条信息是真实的呢”。&lt;/p&gt;
&lt;p&gt;③把想法写在纸上是最为强大的思考工具，在白纸上详细地写出问题和所做决定的每一个细节。&lt;/p&gt;
&lt;p&gt;④独处最好的精神状态可能就是“心如止水”&lt;/p&gt;

&lt;p&gt;①科学家经常采用的方法：提出一个假设，一个还没有被证明的理论，用各种方法来证明这个假设是不正确的，以证明你自己的观点是错误的。&lt;/p&gt;
&lt;p&gt;②在一个特定领域里，只有通过不断地犯错误来积累经验，有一些非常重要的经验和教训只有通过犯错误和尝试才能获得。&lt;/p&gt;

&lt;p&gt;①培养高级思维的三种最重要的思维要素：明确性、聚焦和全神贯注。&lt;/p&gt;
&lt;p&gt;②没有自己目标的人注定只能为有目标的人打工。&lt;/p&gt;
&lt;p&gt;③成功的一个重要秘密就是不要担心那些自己无力改变的事情。&lt;/p&gt;
&lt;p&gt;④什么是能够给你带来使你自己感觉最重要、最有个人价值和个人尊严的事情？&lt;/p&gt;
&lt;p&gt;⑤世上根本没有不切实际的目标，只有不切实际的截止日期。&lt;/p&gt;
&lt;p&gt;⑥写下来接下来一年你要实现的10个目标，可以是周目标、月目标、半年目标或年度目标。&lt;/p&gt;

&lt;p&gt;①你挣钱的能力就是你自己最值钱的金融资产。&lt;/p&gt;
&lt;p&gt;②挣钱能力就是你所具有的能够获得为你付酬的人希望看到的结果的能力。&lt;/p&gt;
&lt;p&gt;③把职场中的成功和工作成就看作完成你的目标和为过上你希望的生活而必须完成的任务的踏板。&lt;/p&gt;
&lt;p&gt;④只有开始和完成那些重要的任务时，你才是在工作。&lt;/p&gt;
&lt;p&gt;⑤管理时间方面，最有效的工具就是一张清单。&lt;/p&gt;
&lt;p&gt;⑥改掉各种电子设备的干扰。&lt;/p&gt;

&lt;p&gt;①大部分情况下，衡量你成功的真正标准就是你是否开心。&lt;/p&gt;
&lt;p&gt;②消极思维的人大部分时间怀有敌意、抱有怀疑，对他们而言，生活就是一系列问题和难题，他们对此束手无策，不能掌控。&lt;/p&gt;
&lt;p&gt;③每个人和自己希望得到的快乐之间的主要障碍就是消极情绪。&lt;/p&gt;
&lt;p&gt;④当停止抱怨时，消极情绪就会立即停止。&lt;/p&gt;
&lt;p&gt;⑤你的头脑一次只能容纳一个思想，要么是积极的，要么是消极的，你随时能消除消极情绪，只要对自己不断重复：“我负责”。&lt;/p&gt;
&lt;p&gt;⑥消除消极情绪的一个关键就是谅解。&lt;/p&gt;
&lt;p&gt;⑦要成为一个完全积极向上的人，主要工作就是要让过去的事情过去，面向未来。&lt;/p&gt;

&lt;p&gt;①没有人能够在一个地方待很长时间，如果不能持续地升级自己的知识和技能，不能一直待在这个地方。&lt;/p&gt;
&lt;p&gt;②改变自己视角和培养更高水平的灵活性，一个全能型的工具就是“归零思维”。&lt;/p&gt;
&lt;p&gt;③问自己一个残忍的问题：“我们今天要做的事情中，有没有一件是今天做了，以后就不用再做的”？&lt;/p&gt;
&lt;p&gt;④人们在工作和生活中所做的决策中，70%到最后都是错误的。&lt;/p&gt;
&lt;p&gt;⑤“7R”原则：重要思考、重要评估、重要组织、重新架构、重新规划、重新发现、重新获得控制权。&lt;/p&gt;

&lt;p&gt;①天才的3种特质：秉持开放的思维、行动是解决问题的最好办法、系统性地解决问题。&lt;/p&gt;
&lt;p&gt;②成功的诊断是治愈的一半。清晰地在纸上写下问题和目标，给问题下一个清晰且正确的定义；为决策成功与否制定衡量标准。&lt;/p&gt;
&lt;p&gt;③领导力就是解决问题的能力。&lt;/p&gt;

&lt;p&gt;①企业家思维的核心就是在一个充满竞争的市场上要聚焦培养和维持一种有意义的竞争优势。&lt;/p&gt;
&lt;p&gt;②企业家思维更多地关注什么是正确的，而不是说谁是正确的。&lt;/p&gt;

&lt;p&gt;①要想实现自己的外在财富，首先要在内心深处像有钱人一样思考。&lt;/p&gt;
&lt;p&gt;②所有外在表现和结果的改进，始于自我概念的改进。自我概念即关于自己的想法、方式、信念的所有东西。&lt;/p&gt;
&lt;p&gt;③创造财富的关键：要想真正拥有财富，只有给其他人提供他们想要的和需要的东西，且他们愿意为之付费。&lt;/p&gt;
&lt;p&gt;④富有的人一个重要秘诀之一是总是要做比薪酬支付多的事情。&lt;/p&gt;
&lt;p&gt;⑤富人最重要的物质：最好的投资就是投资自己，在关键技术领域越来越好。&lt;/p&gt;
</description>
<pubDate>Fri, 29 Jan 2021 15:39:00 +0000</pubDate>
<dc:creator>欧与贾之歌</dc:creator>
<og:description>《思维力量：如何思考、决策、行动以及取得更佳成效》，当当评分4星半，或许也是一本成功学的书，但好在内容不长，语言精炼，没有大篇幅的案例分析；内容没有新鲜的观点，大致也是强调要有目标、要行动、重大决定不</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Euler-Jiaxu/p/14347643.html</dc:identifier>
</item>
<item>
<title>Redis 实战 —— 10. 实现内容搜索、定向广告和职位搜索 - 满赋诸机</title>
<link>http://www.cnblogs.com/manfuzhuji/p/14347458.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/manfuzhuji/p/14347458.html</guid>
<description>&lt;h4 id=&quot;使用-redis-进行搜索-p153&quot;&gt;使用 Redis 进行搜索 &lt;code&gt;P153&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;通过改变程序搜索数据的方式，并使用 Redis 来减少绝大部分基于单词或者关键字进行的内容搜索操作的执行时间。 &lt;code&gt;P154&lt;/code&gt;&lt;/p&gt;
&lt;h5 id=&quot;基本搜索原理-p154&quot;&gt;基本搜索原理 &lt;code&gt;P154&lt;/code&gt;&lt;/h5&gt;
&lt;p&gt;倒排索引 (inverted indexes) 是互联网上绝大部分搜索引擎使用的底层结构，它类似于书本末尾的索引。倒排索引从每个被索引的文档里面提取一些单词，并记录包含每个单词的文档集合。 &lt;code&gt;P154&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设有三个文档：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;R = &quot;it is what it is&quot;&lt;/li&gt;
&lt;li&gt;S = &quot;what is it&quot;&lt;/li&gt;
&lt;li&gt;T = &quot;it is a banana&quot;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们就能得到下面的倒排索引集合：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&quot;a&quot;: &lt;code&gt;{2}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&quot;banana&quot;: &lt;code&gt;{2}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&quot;is&quot;: &lt;code&gt;{0, 1, 2}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&quot;it&quot;: &lt;code&gt;{0, 1, 2}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&quot;what&quot;: &lt;code&gt;{0, 1}&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;检索的条件 &quot;what&quot;, &quot;is&quot; 和 &quot;it&quot; 将对应这个集合：&lt;code&gt;{0,1} ∩ {0,1,2} ∩ {0,1,2} = {0,1}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;可以发现 Redis 的集合和有序集合非常适合处理倒排索引。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基本索引操作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从文档里面提取单词的过程通常被成为语法分析 (parsing) 和标记化 (tokenization) ，这个过程可以产生一系列用于表示文档的标记 (token) ，有时又被成为单词 (word) 。 &lt;code&gt;P155&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;标记化的一个常见的附加步骤就是移除非用词 (stop word) 。非用词就是那些在文档中频繁出现却没有提供相应信息量的单词，对这些单词进行搜索将返回大量无用的结果。 &lt;code&gt;P155&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;本书中实现方向索引的逻辑非常简单：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;将文档划分为单词，并移除一个字符的单词&lt;/li&gt;
&lt;li&gt;对于每个单词获取或创建对应的集合，将当前文档的唯一标识放入集合中&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如果需要支持中文等，就不能简单进行英文分词，需要分词器进行处理。第一次接触倒排索引是在 &lt;code&gt;Elasticsearch&lt;/code&gt; 中，感兴趣的可以了解 &lt;code&gt;Elasticsearch&lt;/code&gt; 中倒排索引的实现以及 &lt;code&gt;IK&lt;/code&gt; 中文分词器。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基本搜索操作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在索引里面查找一个单词是非常容易的，只需要获取单词集合里面的所有文档即可。根据多个单词查找文档时，就需要根据条件处理对应的集合，再从最终集合中获取所有文档。 &lt;code&gt;P156&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;可以使用 Redis 的集合操作完成对不同条件的处理：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;SINTER&lt;/code&gt; / &lt;code&gt;SINTERSTORE&lt;/code&gt;: 找出同时包含所有指定单词的文档集合&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SUNION&lt;/code&gt; / &lt;code&gt;SUNIONSTORE&lt;/code&gt;: 找出至少包含一个指定单词的文档集合&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SDIFF&lt;/code&gt; / &lt;code&gt;SDIFFSTORE&lt;/code&gt;: 找出包含某个单词且包含其他某些单词的文档集合&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;通过以上三类命令，我们基本能实现条件大部分的与或非操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分析并执行搜索&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们使用的查询语句进行分词后具有以下特征：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;以 + 开头的单词：表示这个单词是前一个单词的同义词，需要取并集&lt;/li&gt;
&lt;li&gt;以 - 开头的单词：表示这个单词不希望包含在文档中，需要取差集&lt;/li&gt;
&lt;li&gt;其他普通单词：表示用户需要查询这个单词，需要取交集&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;即： &quot;connect +connection chat -proxy -proxies&quot; 表示查询的文档需要包含 &quot;connect&quot; 或 &quot;connection&quot; ，同时也要包含 &quot;chat&quot; ，并且不能包含 &quot;proxy&quot; 和 &quot;proxies&quot; 。&lt;/p&gt;
&lt;p&gt;实际处理时，先对同义词组分别取并集，然后与需要查询的单词一起取交集，最后与不希望包含的单词取差集，这样所得到的集合就是用户查询的结果集。&lt;/p&gt;
&lt;h5 id=&quot;对搜索结果进行排序和分页-p160&quot;&gt;对搜索结果进行排序和分页 &lt;code&gt;P160&lt;/code&gt;&lt;/h5&gt;
&lt;p&gt;上述搜索功能以及能够搜索出用户查询的所有文档唯一标识的集合，现在我们将根据这个文档唯一标识集合以及每个文档的具体信息进行排序分页。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;文档唯一标识集合： 存储每个文档的唯一标识，例如： &lt;code&gt;{1, 2, 276}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;每个文档的具体信息： 数据结构为 &lt;code&gt;HASH&lt;/code&gt;, 以 &lt;code&gt;doc_{id}&lt;/code&gt; 为键，内部存储对应文档的相关信息，例如： &lt;code&gt;&quot;doc:276&quot;: {&quot;id&quot;: 276, &quot;created&quot;: 1324114412, &quot;updated&quot;: 132562777, &quot;title&quot;: &quot;Troubleshooting...&quot;, ...}&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于这种情况我们可以使用 Redis 的 &lt;code&gt;SORT&lt;/code&gt; 命令对文档唯一标识集合通过引用每个文档的具体信息进行排序分页。 （&lt;a href=&quot;https://mp.weixin.qq.com/s/BpNqT7PPvQ0phCshZfHpqQ&quot; target=&quot;_blank&quot;&gt;05. Redis 其他命令简介&lt;/a&gt;）&lt;/p&gt;
&lt;h4 id=&quot;有序索引-p162&quot;&gt;有序索引 &lt;code&gt;P162&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;上面介绍了使用 Redis 进行搜索，并通过引用存储在 &lt;code&gt;HASH&lt;/code&gt; 里面的数据对搜索结果进行排序分页。接下来将介绍利用集合和有序集合实现基于多个分值的复合排序操作，它能提供比 &lt;code&gt;SORT&lt;/code&gt; 命令更高的灵活性。 &lt;code&gt;P162&lt;/code&gt;&lt;/p&gt;
&lt;h5 id=&quot;对多个数值字段进行排序-p162&quot;&gt;对多个数值字段进行排序 &lt;code&gt;P162&lt;/code&gt;&lt;/h5&gt;
&lt;p&gt;假设我们目前需要根据文档对更新时间和得票数进行排序，为此我们需要用两个有序集合存储相关信息。这两个有序集合的成员都是文档唯一标识，成员的分值则分别是文档的更新时间和得票数。&lt;/p&gt;
&lt;p&gt;设经过搜索后满足搜索条件的文档唯一标识集合为 &lt;code&gt;filtered_doc_ids&lt;/code&gt; ，文档唯一标识及其更新时间对应的有序集合为 &lt;code&gt;doc_ids_with_update&lt;/code&gt; ，文档唯一 标识及其得票数对应的有序集合为 &lt;code&gt;doc_ids_with_votes&lt;/code&gt; 。那么可以通过 &lt;code&gt;ZINTERSTORE&lt;/code&gt; 命令对这三个集合求交集，最后得出的满足搜索条件的文档唯一标识及其排序分值对应的有序集合，再使用 &lt;code&gt;ZRANGE&lt;/code&gt;, &lt;code&gt;ZREVRANGE&lt;/code&gt; 进行分页获取即可。 &lt;code&gt;P162&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;示例： &lt;code&gt;ZINTERSTORE filtered_doc_ids_with_sort_score 3 filtered_doc_ids doc_ids_with_update doc_ids_with_votes WEIGHTS 0 {update_weight} {vote_weight}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;其中：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;filtered_doc_ids_with_sort_score&lt;/code&gt; 为结果有序集合&lt;/li&gt;
&lt;li&gt;&lt;code&gt;filtered_doc_ids&lt;/code&gt; 的权重为 &lt;code&gt;0&lt;/code&gt; ，仅用做筛选结果，不用于排序&lt;/li&gt;
&lt;li&gt;&lt;code&gt;doc_ids_with_update&lt;/code&gt;, &lt;code&gt;doc_ids_with_votes&lt;/code&gt; 的权重可以进行设置，为 &lt;code&gt;0&lt;/code&gt; 时表示不用于排序；为其他数时，表示对应字段对最终排序分所占的权重，正数相当于该字段需要正序排序，负数相当于该字段需要倒序排序。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;所思&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这种利用分值的方法很巧妙，基本可以实现多字段排序，但是优先级可能难以掌控，难以做到先按照某一字段排序，再按照另一字段排序的形式。因为每个字段对应的分值的数量级可能差别比较小，这个时候如果需要有排序字段的优先级，那么可能需要对每个权重进行精巧地设计才行。&lt;/p&gt;
&lt;h5 id=&quot;对非数值字段进行排序-p164&quot;&gt;对非数值字段进行排序 &lt;code&gt;P164&lt;/code&gt;&lt;/h5&gt;
&lt;p&gt;上面介绍了使用有序集合对多个数值字段进行排序，由于有序集合的分值只能是浮点数，所以非数值字段不能直接用于排序，需要转换成对应的浮点数。但由于双精度浮点数只有 64 个二进制位，实际能使用 63 个二进制位，所以能表示的字符串并不多，只能使用字符串的前几个字符进行分值估计，不足指定字符数的需要补齐到指定字符数。当然如果字符集缩小的话，可以重新进行编码计算，进而可以对更长的字符串进行分值估计。 &lt;code&gt;P165&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;当这个分值特别大的时候，可能会引发最终计算的分值溢出而出错的问题。&lt;/p&gt;
&lt;h4 id=&quot;广告定向-p166&quot;&gt;广告定向 &lt;code&gt;P166&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;接下来将介绍使用集合和有序集合构建出一个几乎完整的广告服务平台 (ad-serving platform) 。 &lt;code&gt;P166&lt;/code&gt;&lt;/p&gt;
&lt;h5 id=&quot;对广告进行索引-p167&quot;&gt;对广告进行索引 &lt;code&gt;P167&lt;/code&gt;&lt;/h5&gt;
&lt;p&gt;针对广告的索引操作和针对其他内容的索引操作并没有太大的不同，被索引的的广告通常都拥有像位置、年龄和性别这类必需的定向参数，并且往往只会返回单个广告。 &lt;code&gt;P167&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;广告的价格&lt;/strong&gt; &lt;code&gt;P167&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;按展示次数计费 (cost per view) ：这种广告又称 CPM 广告或按千次计费 (cost per mille) ，每展示 1000 次就需要收取固定的费用&lt;/li&gt;
&lt;li&gt;按点击次数计费 (cost per click) ：这种广告又称 CPC 广告，根据被点击的次数收取固定费用&lt;/li&gt;
&lt;li&gt;按动作执行次数计费 (cost per action) ：又称按购买次数计费 (cost per acquisition) ，这种广告又称 CPA 广告，根据用户在广告的目的地网站上执行的动作收取不同的费用&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;为了尽可能简化广告价格的计算方式，将对所有类型的广告进行转换，使得它们的价格可以基于每千次展示进行计算，产生出一个估算 CPM (estimated CPM, eCPM) 。 &lt;code&gt;P168&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;CPM 的 eCPM 价格可以直接使用 CPM 价格&lt;/li&gt;
&lt;li&gt;CPC 的 eCPM 价格可以通过将广告的每次点击价格乘以广告的点击通过率 (click-through rate, CTR) ，然后再乘以 1000 得到&lt;/li&gt;
&lt;li&gt;CPA 的 eCPM 价格可以将广告的点击通过率、用户在广告投放者的目标页面上执行动作的概率、被执行动作的价格这三者相乘起来，然后再乘以 1000 得到&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;将广告插入倒排索引&lt;/strong&gt; &lt;code&gt;P169&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;我们基本可以复用上面提到的搜索功能，除了会将广告的关键词插入倒排索引，还会将广告的定向参数（位置、年龄和性别等）插入倒排索引中，并记录广告的类型、基本价格和 eCPM 价格。 &lt;code&gt;P169&lt;/code&gt;&lt;/p&gt;
&lt;h5 id=&quot;执行广告定向操作-p170&quot;&gt;执行广告定向操作 &lt;code&gt;P170&lt;/code&gt;&lt;/h5&gt;
&lt;p&gt;当系统收到广告定向请求的时候，它要做的就是在匹配用户定向参数的一系列广告里面，找出 eCPM 最高的那一个广告。同时，程序还会记录页面内容与广告内容的匹配程度，以及不同匹配程度对广告点击通过率的影响等统计数据。通过使用这些统计数据，广告中与页面相匹配的那些内容就会作为附加值被计入 CPC 和 CPA 的 eCPM 价格，使得那些包含了匹配内容的广告能够更多地被展示出来。 &lt;code&gt;P170&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;计算附加值&lt;/strong&gt;&lt;br/&gt;计算附加值就是基于页面内容和广告内容两者之间匹配的单词，计算出应该给广告的 eCPM 价格加上多少增量。每个单词都有一个有序集合，成员为广告 id ，成员的分值为当前单词对这则广告的 eCPM 的附加值。 &lt;code&gt;P171&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在寻找合适的广告时，我们首先会过滤出匹配定位位置且至少包含一个页面单词的广告，然后通过计算附加值的方法替代搜索，以便实现每次投放价值最高的广告，并能够根据用户的行为学习。同时由于每个广告匹配的内容不同，最优方式应该是使用加权平均值来计算单词部分的附加值，但限于 Redis 本身的命令，我们最终采取 (max + min) / 2 的形式计算单词部分的附加值（max 表示所有匹配单词的最大附加值， min 表示所有匹配单词的最小附加值），采用如下命令即可： &lt;code&gt;ZUNIONSTORE final_score 3 base max min WEIGHTS 1 0.5 0.5&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;从用户行为中学习&lt;/strong&gt; &lt;code&gt;P175&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;首先需要存储用户的浏览记录，包括三部分：（每 100 次就主动更新一次 eCPM ） &lt;code&gt;P175&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;被定向至给定广告的单词（即：内容中单词和给定广告单词的交集）&lt;/li&gt;
&lt;li&gt;给定广告被定向的次数&lt;/li&gt;
&lt;li&gt;广告中的某个单词被用于计算附加值的次数&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其次需要存储用户的点击和动作记录，用于计算 点击通过率 = 点击量或动作次数 / 广告展示次数。（每次都更新 eCPM） &lt;code&gt;P176&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;最后就是更新 eCPM ，包括两部分：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;广告的 eCPM ：根据广告的实际价格和当前广告的点击通过率，计算出最新的 eCPM&lt;/li&gt;
&lt;li&gt;广告单词的 eCPM 附加值：根据广告的基本价格和每个单词的点击通过率，计算出每个单词最新的 eCPM 附加值&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;改进方案-p179&quot;&gt;改进方案 &lt;code&gt;P179&lt;/code&gt;&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;随时间流逝：可以仿照 &lt;a href=&quot;https://mp.weixin.qq.com/s/YxsNWyLeCuy-1SdPa8Tdxw&quot; target=&quot;_blank&quot;&gt;03. Redis 简单实践 - Web应用&lt;/a&gt; 文章的 &lt;code&gt;RescaleItemViewedNum&lt;/code&gt; 函数进行定期降低广告的展示次数和点击次数（或者动作执行次数）&lt;/li&gt;
&lt;li&gt;增加计数值：可以考虑前一天、前一星期或者其他时间段的点击技术，并基于时间段的长短给予不同的权重&lt;/li&gt;
&lt;li&gt;使用第二价格拍卖 (second-price auction) 的方式来决定广告位的费用&lt;/li&gt;
&lt;li&gt;给予低价广告一定曝光量：部分时间内，获取收益排名前 100 的广告，基于它们的 eCPM 的相对值来挑选广告，而不是挑选 eCPM 最高的广告&lt;/li&gt;
&lt;li&gt;优化新广告初始 eCPM ：
&lt;ul&gt;&lt;li&gt;初期使用同类型广告的平均点击数据&lt;/li&gt;
&lt;li&gt;在同类型广告的平均点击通过率和当前实际点击通过率之间，构建一种简单的反线性关系 (inverse linear relationship) 或者反 S 关系 (inverse sigmoid relationship) ，直到广告有足够的展示次数为止&lt;/li&gt;
&lt;li&gt;人为提高点击通过率，保证有足够多的流量学习真正 eCPM&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;考虑使用真正的贝叶斯统计、神经网络、关联规则学习、聚类计算或者其他技术来计算附加值&lt;/li&gt;
&lt;li&gt;将记录信息的逻辑变为异步（可以利用 &lt;a href=&quot;https://mp.weixin.qq.com/s/LqYEXJ9AP3gSnqXMiKbyQw&quot; target=&quot;_blank&quot;&gt;09. 实现任务队列、消息拉取和文件分发&lt;/a&gt; 中的任务队列实现），提高响应效率&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;职位搜索-p180&quot;&gt;职位搜索 &lt;code&gt;P180&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;接下来将使用集合和有序集合实现职位搜索功能，并根据求职者拥有技能来为他们寻找合适的职位。 &lt;code&gt;P180&lt;/code&gt;&lt;/p&gt;
&lt;h5 id=&quot;遍历合适的职位-p180&quot;&gt;遍历合适的职位 &lt;code&gt;P180&lt;/code&gt;&lt;/h5&gt;
&lt;p&gt;第一反应肯定是直接对每一个求职者搜索所有的岗位，从而找到求职者合适的岗位。但这种方法效率极低（大部分岗位肯定是技能对不上的），而且无法进行性能扩展。 &lt;code&gt;P181&lt;/code&gt;&lt;/p&gt;
&lt;h5 id=&quot;搜索合适的岗位-p181&quot;&gt;搜索合适的岗位 &lt;code&gt;P181&lt;/code&gt;&lt;/h5&gt;
&lt;p&gt;使用类似上面提到的附加值形式，每次添加一个岗位时，在对应的技能集合中添加这个岗位的 id (&lt;code&gt;SADD idx:skill:{skill} {job_id}&lt;/code&gt;)，再在岗位有序集合中进行添加，成员为岗位 id ，成员的分值为所需的技能数量 (&lt;code&gt;ZADD job_required_skill_count {job_id} {required_skill_count}&lt;/code&gt;)。搜索的时候就先对求职者所有技能对应的集合使用 &lt;code&gt;ZUNIONSTORE&lt;/code&gt; 操作计算每个公司匹配的技能数量 (&lt;code&gt;ZUNIONSTORE matched {n} idx:skill:{skill} ... WEIGHTS 1 ...&lt;/code&gt;)，然后再与岗位有序集合求交集，并让公司有序集合的权重为 -1 (&lt;code&gt;ZINTERSTORE result 2 job_required_skill_count matched WEIGHTS -1 1&lt;/code&gt;)，最后获取分值为 0 的所有岗位即可完成搜索。 &lt;code&gt;P181&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所思&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;书上的这个方法比较麻烦，其实可以使用文章最开始的无序倒排索引，岗位相当于要搜索的文档，岗位所需的技能相当于单词。&lt;/p&gt;
&lt;blockquote readability=&quot;3.5044247787611&quot;&gt;
&lt;p&gt;本文首发于公众号：满赋诸机（&lt;a href=&quot;https://mp.weixin.qq.com/s/l3PJWStTslrw1_Vf6zCFww&quot; target=&quot;_blank&quot;&gt;点击查看原文&lt;/a&gt;） 开源在 GitHub ：&lt;a href=&quot;https://github.com/idealism-xxm/reading-notes/tree/master/redis-in-action&quot; target=&quot;_blank&quot;&gt;reading-notes/redis-in-action&lt;/a&gt;&lt;br/&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/16055078/103480735-02019200-4e11-11eb-91a2-70a687781033.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 29 Jan 2021 14:40:00 +0000</pubDate>
<dc:creator>满赋诸机</dc:creator>
<og:description>使用 Redis 进行搜索 P153 通过改变程序搜索数据的方式，并使用 Redis 来减少绝大部分基于单词或者关键字进行的内容搜索操作的执行时间。 P154 基本搜索原理 P154 倒排索引 (in</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/manfuzhuji/p/14347458.html</dc:identifier>
</item>
</channel>
</rss>