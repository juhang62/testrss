<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>小白学 Python（17）：基础数据类型（函数）（下） - 极客挖掘机</title>
<link>http://www.cnblogs.com/babycomeon/p/11817982.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/babycomeon/p/11817982.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201911/908359-20191108084416545-1517822672.jpg&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;人生苦短，我选Python&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;前文传送门&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/12/2870915863/&quot;&gt;小白学 Python（1）：开篇&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/13/2870915864/&quot;&gt;小白学 Python（2）：基础数据类型（上）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/15/25090937/&quot;&gt;小白学 Python（3）：基础数据类型（下）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/17/2392286754/&quot;&gt;小白学 Python（4）：变量基础操作&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/18/999362065/&quot;&gt;小白学 Python（5）：基础运算符（上）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/20/2416267271/&quot;&gt;小白学 Python（6）：基础运算符（下）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/22/979409150/&quot;&gt;小白学 Python（7）：基础流程控制（上）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/23/2184234984/&quot;&gt;小白学 Python（8）：基础流程控制（下）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/23/3066758654/&quot;&gt;小白学 Python（9）：基础数据结构（列表）（上）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/25/1277177083/&quot;&gt;小白学 Python（10）：基础数据结构（列表）（下）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/26/1783681326/&quot;&gt;小白学 Python（11）：基础数据结构（元组）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/27/1304658395/&quot;&gt;小白学 Python（12）：基础数据结构（字典）（上）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/27/2327215405/&quot;&gt;小白学 Python（13）：基础数据结构（字典）（下）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/29/2327215406/&quot;&gt;小白学 Python（14）：基础数据结构（集合）（上）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/30/3105860436/&quot;&gt;小白学 Python（15）：基础数据结构（集合）（下）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/31/3818474124/&quot;&gt;小白学 Python（16）：基础数据类型（函数）（上）&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;变量作用域&quot;&gt;变量作用域&lt;/h2&gt;
&lt;p&gt;变量的作用域是指在程序中命名的变量产生想过的范围。&lt;/p&gt;
&lt;p&gt;没看懂？没关系，我们写个示例慢慢品。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;a = 0

def print_1():
    a = 1
    print('a =', a)

    def print_2():
        a = 2
        print('a =', a)

print_a()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;显示结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;a = 1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上面的示例中， a 我们进行了三次赋值，但是注意，这里并不是赋值覆盖，而是每次赋值时作用域不同。&lt;/p&gt;
&lt;p&gt;第一次赋值 a 是在最外面，这个称为全局变量，意思是它的作用域是全局的，我们在全局任何地方使用 a ，都能获得这个值。&lt;/p&gt;
&lt;p&gt;第二次赋值， a 是在 &lt;code&gt;print_1()&lt;/code&gt; 这个函数中，我们调用了 &lt;code&gt;print_1()&lt;/code&gt; 这个函数，所以这里的赋值会生效。&lt;/p&gt;
&lt;p&gt;第三次赋值是在 &lt;code&gt;print_2()&lt;/code&gt; 这个函数中，我们并未调用这个函数，所以这里 a 的赋值并不会生效。&lt;/p&gt;
&lt;p&gt;比如我们可以这么打印：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;a = 0

def print_1():
    a = 1
    print('a =', a)

    def print_2():
        a = 2
        print('a =', a)


print('a =', a)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打印结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;a = 0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这时我们就将这个全局变量打印出来了。&lt;/p&gt;
&lt;p&gt;第二个和第三个在方法内的 a 就成了局部变量，这两个 a 都是只在当前的函数中生效，出了这个函数就不生效了。&lt;/p&gt;
&lt;p&gt;如果我们将局部变量中的的赋值注释掉，那么在函数中是否能取到全局变量的值？&lt;/p&gt;
&lt;p&gt;答案当然是肯定的，我们试试看：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;a = 0

def print_1():
    # a = 1
    print('a =', a)

    def print_2():
        a = 2
        print('a =', a)

print_a()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打印结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;a = 0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们还可以再做一点改变，在函数 &lt;code&gt;print_1()&lt;/code&gt; 中调用函数 &lt;code&gt;print_2()&lt;/code&gt; ，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;a = 0

def print_1():
    # a = 1
    print('a1 =', a)

    def print_2():
        a = 2
        print('a2 =', a)

    print_2()

print('a3 =', a)
print_1()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打印结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;a3 = 0
a1 = 0
a2 = 2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此示例添加 a1 、 a2 、 a3 仅为打印后方便识别，并非这是三个变量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 内层函数的变量作用域仅在内层函数中，并不会覆盖到外层函数。&lt;/p&gt;
&lt;h2 id=&quot;匿名函数&quot;&gt;匿名函数&lt;/h2&gt;
&lt;p&gt;是的，你没看错，函数是可以不命名的。&lt;/p&gt;
&lt;p&gt;当我们需要使用匿名函数的时候，可以使用 &lt;code&gt;lambda&lt;/code&gt; 关键字来声明匿名函数。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;lambda 只是一个表达式，函数体比 def 简单很多。&lt;/li&gt;
&lt;li&gt;lambda的主体是一个表达式，而不是一个代码块。仅仅能在lambda表达式中封装有限的逻辑进去。&lt;/li&gt;
&lt;li&gt;lambda 函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间里的参数。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;语法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;函数对象名 = lambda 形参：表达式&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们还是写一个简单的匿名函数大家体会一下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;add = lambda x,y: x + y

print(add(1, 2))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打印结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里是实现了我们上一篇文章中最简单的加法，如果写一个稍微复杂一点，比如说加上逻辑判断的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;max_num = lambda x,y: x if x &amp;gt;= y else y

print(max_num(5, 9))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打印结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;9&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;建议：&lt;/strong&gt; 当函数比较复杂的时候，不建议使用匿名函数，因为它只能是一行，写起来不好写的同时还不好阅读，结构晦涩难懂，如果进行复杂的业务逻辑，匿名函数能让写的人怀疑人生，读的人生不如死。真爱生命，请远离匿名函数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201911/908359-20191108084416765-1337546021.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;递归函数&quot;&gt;递归函数&lt;/h2&gt;
&lt;p&gt;一个函数是可以调用另一个函数的，如果这个函数调用自己的话，那么这个就叫递归函数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201911/908359-20191108084416906-634034723.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在我们如果要求 n 的阶乘：&lt;/p&gt;
&lt;p&gt;千万别告我你不知道什么阶乘，可能你需要回去问下你的初中数学老师。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;n! = 1 * 2 * 3 * ... * n&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;看懂了哇，想想看代码怎么写。&lt;/p&gt;
&lt;p&gt;想不出来还是看我写的吧：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def factorial(n):
    if n == 1:
        return 1
    return n * factorial(n - 1)

print('10的阶乘为：', factorial(10))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打印结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;10的阶乘为： 3628800&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;希望各位同学一定要自己动手敲代码。&lt;/p&gt;
&lt;h2 id=&quot;示例代码&quot;&gt;示例代码&lt;/h2&gt;
&lt;p&gt;本系列的所有代码小编都会放在代码管理仓库 Github 和 Gitee 上，方便大家取用。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/meteor1993/python-learning/tree/master/base-data-def&quot; title=&quot;示例代码-Github&quot;&gt;示例代码-Github&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/inwsy/python-learning/tree/master/base-data-def&quot; title=&quot;示例代码-Gitee&quot;&gt;示例代码-Gitee&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 08 Nov 2019 00:44:00 +0000</pubDate>
<dc:creator>极客挖掘机</dc:creator>
<og:description>人生苦短，我选Python 前文传送门 '小白学 Python（1）：开篇' '小白学 Python（2）：基础数据类型（上）' '小白学 Python（3）：基础数据类型（下）' '小白学 Pyth</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/babycomeon/p/11817982.html</dc:identifier>
</item>
<item>
<title>27 个问题突破所有重难点，BroadcastReceiver 、ContentProvider 知多少？「建议收藏」 - __yuanhao</title>
<link>http://www.cnblogs.com/yuanhao-1999/p/11817955.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuanhao-1999/p/11817955.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191029235433160.png&quot; alt=&quot;Android&quot;/&gt;&lt;/p&gt;

&lt;hr/&gt;&lt;ul&gt;&lt;li&gt;距离上次更新过去一周多了，打破了之前两到三天一更的惯例，主要还是这部分内容太多了。&lt;/li&gt;
&lt;li&gt;原先想把 &lt;code&gt;BroadcastReceiver&lt;/code&gt; 、&lt;code&gt;ContentProvider&lt;/code&gt; 分两篇来总结，但的确，这两大组件的使用不像 &lt;code&gt;Activity&lt;/code&gt; 、&lt;code&gt;Service&lt;/code&gt; 那么频繁，所以还是决定一次性搞定。&lt;/li&gt;
&lt;li&gt;于是这篇近 &lt;code&gt;1.5 W&lt;/code&gt; 字的文章就诞生了。可以说这周几乎所有时间都花在这上面，自己看了几遍感觉已经极为全面了。&lt;/li&gt;
&lt;li&gt;祝大家阅读愉快。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;最后，希望大家都能有所收获，欢迎食用！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191107121725799.png&quot; alt=&quot;文章目录&quot;/&gt;&lt;/p&gt;

&lt;hr/&gt;
&lt;hr/&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;BroadcastReceiver&lt;/code&gt;，顾名思义就是“广播接收者”的意思，它是Android四大基本组件之一。&lt;/li&gt;
&lt;li&gt;这种组件本质上是一种全局的监听器，用于监听系统全局的广播消息。&lt;/li&gt;
&lt;li&gt;它可以接收来自系统和应用的的广播。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191107121904789.png&quot; alt=&quot;BroadcastReceiver&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;什么是-broadcastreceiver&quot;&gt;1.1 什么是 BroadcastReceiver&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191106111343298.png&quot; alt=&quot;什么是 BroadcastReceiver&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;是四大组件之一, 主要用于接收 &lt;code&gt;app&lt;/code&gt; 发送的广播&lt;/li&gt;
&lt;li&gt;内部通信实现机制:通过 &lt;code&gt;android&lt;/code&gt; 系统的 &lt;code&gt;Binder&lt;/code&gt; 机制.&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;广播分为两种&quot;&gt;1.2 广播分为两种&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191106111449581.png&quot; alt=&quot;广播分为两种&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;无序广播&quot;&gt;1.2.1 无序广播&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191106111738682.png&quot; alt=&quot;无序广播&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;也叫标准广播，是一种完全异步执行的广播。&lt;/li&gt;
&lt;li&gt;在广播发出之后，所有广播接收器几乎都会在同一时刻接收到这条广播消息，它们之间没有任何先后顺序，广播的效率较高。&lt;/li&gt;
&lt;li&gt;优点: 完全异步, 逻辑上可被任何接受者收到广播,效率高&lt;/li&gt;
&lt;li&gt;缺点: 接受者不能将处理结果交给下一个接受者, 且无法终止广播.&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;有序广播&quot;&gt;1.2.2 有序广播&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191106120042195.png&quot; alt=&quot;有序广播&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;是一种同步执行的广播。&lt;/li&gt;
&lt;li&gt;在广播发出之后，同一时刻只有一个广播接收器能够收到这条广播消息，当其逻辑执行完后该广播接收器才会继续传递。&lt;/li&gt;
&lt;li&gt;调用 &lt;code&gt;SendOrderedBroadcast()&lt;/code&gt; 方法来发送广播，同时也可调用 &lt;code&gt;abortBroadcast()&lt;/code&gt; 方法拦截该广播。可通过 &lt;code&gt;&amp;lt;intent-filter&amp;gt;&lt;/code&gt; 标签中设置 &lt;code&gt;android:property&lt;/code&gt; 属性来设置优先级，未设置时按照注册的顺序接收广播。&lt;/li&gt;
&lt;li&gt;有序广播接受器间可以互传数据。&lt;/li&gt;
&lt;li&gt;当广播接收器收到广播后，当前广播也可以使用 &lt;code&gt;setResultData&lt;/code&gt; 方法将数据传给下一个接收器。&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;getStringExtra&lt;/code&gt; 函数获取广播的原始数据，通过 &lt;code&gt;getResultData&lt;/code&gt; 方法取得上个广播接收器自己添加的数据，并可用 &lt;code&gt;abortBroadcast&lt;/code&gt; 方法丢弃该广播，使该广播不再被别的接收器接收到。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191106120154988.png&quot; alt=&quot;总结&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;按被接收者的优先级循序传播 &lt;code&gt;A &amp;gt; B &amp;gt; C&lt;/code&gt; ,&lt;/li&gt;
&lt;li&gt;每个都有权终止广播, 下一个就得不到&lt;/li&gt;
&lt;li&gt;每一个都可进行修改操作, 下一个就得到上一个修改后的结果.&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;最终广播者&quot;&gt;1.2.3 最终广播者&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191106120446188.png&quot; alt=&quot;最终广播者&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Context.sendOrderedBroadcast ( intent , receiverPermission , resultReceiver , scheduler , initialCode , initialData , initialExtras )&lt;/code&gt; 时我们可以指定 &lt;code&gt;resultReceiver&lt;/code&gt; 为最终广播接收者.&lt;/li&gt;
&lt;li&gt;如果比他优先级高的接受者不终止广播, 那么他的 &lt;code&gt;onReceive&lt;/code&gt; 会执行两次&lt;/li&gt;
&lt;li&gt;第一次是正常的接收&lt;/li&gt;
&lt;li&gt;第二次是最终的接收&lt;/li&gt;
&lt;li&gt;如果优先级高的那个终止广播, 那么他还是会收到一次最终的广播&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;常见的广播接收者运用场景&quot;&gt;1.2.4 常见的广播接收者运用场景&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191106120724144.png&quot; alt=&quot;广播接收者运用场景&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;开机启动, &lt;code&gt;sd&lt;/code&gt; 卡挂载, 低电量, 外拨电话, 锁屏等&lt;/li&gt;
&lt;li&gt;比如根据产品经理要求, 设计播放音乐时, 锁屏是否决定暂停音乐.&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;broadcastreceiver-的种类&quot;&gt;1.3 BroadcastReceiver 的种类&lt;/h2&gt;
&lt;h4 id=&quot;广播作为-android-组件间的通信方式如下使用场景&quot;&gt;1.3.1 广播作为 Android 组件间的通信方式，如下使用场景：&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;对前一部分 “ 请描述一下 &lt;code&gt;BroadcastReceiver&lt;/code&gt; ” 进行展开补充&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191107100322247.png&quot; alt=&quot;BroadcastReceiver 使用场景&quot;/&gt;&lt;/p&gt;
&lt;ul readability=&quot;5&quot;&gt;&lt;li&gt;&lt;code&gt;APP&lt;/code&gt; 内部的消息通信。&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;不同 &lt;code&gt;APP&lt;/code&gt; 之间的消息通信。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;Android&lt;/code&gt; 系统在特定情况下与 APP 之间的消息通信。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;广播使用了观察者模式，基于消息的发布 / 订阅事件模型。广播将广播的发送者和接受者极大程度上解耦，使得系统能够方便集成，更易扩展。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;BroadcastReceiver 本质是一个全局监听器，用于监听系统全局的广播消息，方便实现系统中不同组件间的通信。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;自定义广播接收器需要继承基类 &lt;code&gt;BroadcastReceiver&lt;/code&gt; ，并实现抽象方法 &lt;code&gt;onReceive ( context, intent )&lt;/code&gt; 。默认情况下，广播接收器也是运行在主线程，因此 &lt;code&gt;onReceiver()&lt;/code&gt; 中不能执行太耗时的操作（ 不超过 &lt;code&gt;10s&lt;/code&gt; ），否则将会产生 &lt;code&gt;ANR&lt;/code&gt; 问题。&lt;code&gt;onReceiver()&lt;/code&gt; 方法中涉及与其他组件之间的交互时，可以使用发送 &lt;code&gt;Notification&lt;/code&gt; 、启动 &lt;code&gt;Service&lt;/code&gt; 等方式，最好不要启动 &lt;code&gt;Activity&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;系统广播&quot;&gt;1.3.2 系统广播&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191107100859618.png&quot; alt=&quot;系统广播&quot;/&gt;&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;code&gt;Android&lt;/code&gt; 系统内置了多个系统广播，只要涉及手机的基本操作，基本上都会发出相应的系统广播，如开机启动、网络状态改变、拍照、屏幕关闭与开启、电量不足等。在系统内部当特定时间发生时，系统广播由系统自动发出。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;常见系统广播 &lt;code&gt;Intent&lt;/code&gt; 中的 &lt;code&gt;Action&lt;/code&gt; 为如下值：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191107100913873.png&quot; alt=&quot;常见系统广播 Intent 中的 Action&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;短信提醒：&lt;code&gt;android.provider.Telephony.SMS_RECEIVED&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;电量过低：&lt;code&gt;ACTION_BATIERY_LOW&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;电量发生改变：&lt;code&gt;ACTION_BATTERY_CHANGED&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;连接电源：&lt;code&gt;ACTION_POWER_CO&lt;/code&gt; 　　　　　　　　　　　　&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;从 &lt;code&gt;Android 7.0&lt;/code&gt; 开始，系统不会再发送广播 &lt;code&gt;ACTION_NEW_PICTURE&lt;/code&gt; 和 &lt;code&gt;ACTION_NEW_VIDEO&lt;/code&gt; ，对于广播 &lt;code&gt;CONNECTIVITY_ACTION&lt;/code&gt; 必须在代码中使用 &lt;code&gt;registerReceiver&lt;/code&gt; 方法注册接收器，在 &lt;code&gt;AndroidManifest&lt;/code&gt; 文件中声明接收器不起作用。&lt;/li&gt;
&lt;li&gt;从 &lt;code&gt;Android 8.0&lt;/code&gt; 开始，对于大多数隐式广播，不能在 &lt;code&gt;AndroidManifest&lt;/code&gt; 文件中声明接收器。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;局部广播&quot;&gt;1.3.3 局部广播&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191107101241519.png&quot; alt=&quot;局部广播&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;局部广播的发送者和接受者都同属于一个 &lt;code&gt;APP&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;相比于全局广播具有以下优点：&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;其他的 &lt;code&gt;APP&lt;/code&gt; 不会受到局部广播，不用担心数据泄露的问题。&lt;/li&gt;
&lt;li&gt;其他 &lt;code&gt;APP&lt;/code&gt; 不可能向当前的 &lt;code&gt;APP&lt;/code&gt; 发送局部广播，不用担心有安全漏洞被其他 &lt;code&gt;APP&lt;/code&gt; 利用。&lt;/li&gt;
&lt;li&gt;局部广播比通过系统传递的全局广播的传递效率更高。&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;Android v4&lt;/code&gt; 包中提供了 &lt;code&gt;LocalBroadcastManager&lt;/code&gt; 类，用于统一处理 APP 局部广播，使用方式与全局广播几乎相同，只是调用注册 / 取消注册广播接收器和发送广播偶读方法时，需要通过 &lt;code&gt;LocalBroadcastManager&lt;/code&gt; 类的 &lt;code&gt;getInstance()&lt;/code&gt; 方法获取的实例调用。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;broadcastreceiver-注册方式&quot;&gt;1.4 BroadcastReceiver 注册方式&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191107101500794.png&quot; alt=&quot;BroadcastReceiver 注册方式&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;静态注册&quot;&gt;1.4.1 静态注册&lt;/h4&gt;
&lt;p&gt;在 &lt;code&gt;AndroidManifest.xml&lt;/code&gt; 文件中配置。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;&amp;lt;receiver android:name=&quot;.MyReceiver&quot; android:exported=&quot;true&quot;&amp;gt;
    &amp;lt;intent-filter&amp;gt;
        &amp;lt;!-- 指定该 BroadcastReceiver 所响应的 Intent 的 Action --&amp;gt;
        &amp;lt;action android:name=&quot;android.intent.action.INPUT_METHOD_CHANGED&quot;
        &amp;lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot; /&amp;gt;
    &amp;lt;/intent-filter&amp;gt;
&amp;lt;/receiver&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;两个重要属性需要关注：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2019110710183499.png&quot; alt=&quot;两个重要属性需要关注&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;android: exported&lt;/code&gt;&lt;br/&gt;其作用是设置此 &lt;code&gt;BroadcastReceiver&lt;/code&gt; 能否接受其他 &lt;code&gt;APP&lt;/code&gt; 发出的广播 ，当设为 &lt;code&gt;false&lt;/code&gt; 时，只能接受同一应用的的组件或具有相同 &lt;code&gt;user ID&lt;/code&gt; 的应用发送的消息。这个属性的默认值是由 &lt;code&gt;BroadcastReceiver&lt;/code&gt; 中有无 &lt;code&gt;Intent-filter&lt;/code&gt; 决定的，如果有 &lt;code&gt;Intent-filter&lt;/code&gt; ，默认值为 &lt;code&gt;true&lt;/code&gt; ，否则为 &lt;code&gt;false&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;android: permission&lt;/code&gt;&lt;br/&gt;如果设置此属性，具有相应权限的广播发送方发送的广播才能被此 &lt;code&gt;BroadcastReceiver&lt;/code&gt; 所接受；如果没有设置，这个值赋予整个应用所申请的权限。&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;动态注册&quot;&gt;1.4.2 动态注册&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;调用 &lt;code&gt;Context&lt;/code&gt; 的 &lt;code&gt;registerReceiver ( BroadcastReceiver receiver , IntentFilter filter )&lt;/code&gt; 方法指定。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;在-mainfest-和代码如何注册和使用-broadcastreceiver-一个-action-是重点&quot;&gt;1.5 在 Mainfest 和代码如何注册和使用 BroadcastReceiver ? ( 一个 action 是重点 )&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191107102527861.png&quot; alt=&quot;Mainfest 和代码如何注册和使用 BroadcastReceiver&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;使用文件注册-静态广播&quot;&gt;1.5.1 使用文件注册 ( 静态广播 )&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;只要 &lt;code&gt;app&lt;/code&gt; 还在运行,那么会一直收到广播消息&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191107103009543.png&quot; alt=&quot;使用文件注册 ( 静态广播 )&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;一个 &lt;code&gt;app&lt;/code&gt; 里: 自定义一个类继承 &lt;code&gt;BroadcastReceiver&lt;/code&gt; 然后要求重写 &lt;code&gt;onReveiver&lt;/code&gt; 方法&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class MyBroadCastReceiver extends BroadcastReceiver {
    @Override
    public void onReceive(Context context, Intent intent) {
        Log.d(&quot;MyBroadCastReceiver&quot;, &quot;收到信息,内容是 :　&quot; + intent.getStringExtra(&quot;info&quot;) + &quot;&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;清单文件注册,并设置 &lt;code&gt;Action&lt;/code&gt; , 就那么简单完成接收准备工作&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;&amp;lt;receiver android:name=&quot;.MyBroadCastReceiver&quot;&amp;gt;
    &amp;lt;intent-filter&amp;gt;
        &amp;lt;action android:name=&quot;myBroadcast.action.call&quot;/&amp;gt;
    &amp;lt;/intent-filter&amp;gt;
&amp;lt;/receiver&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;代码注册-动态广播&quot;&gt;1.5.2 代码注册 ( 动态广播 )&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;当注册的 &lt;code&gt;Activity&lt;/code&gt; 或者 &lt;code&gt;Service&lt;/code&gt; 销毁了那么就会接收不到广播.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191107103420600.png&quot; alt=&quot;代码注册 ( 动态广播 )&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在和广播接受者相同的 &lt;code&gt;app&lt;/code&gt; 里的 &lt;code&gt;MainActivity&lt;/code&gt; 添加一个注册按钮 , 用来注册广播接收者&lt;/li&gt;
&lt;li&gt;设置意图过滤,添加 &lt;code&gt;Action&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//onCreate创建广播接收者对象
mReceiver = new MyBroadCastReceiver();              

//注册按钮
public void click(View view) {
    IntentFilter intentFilter = new IntentFilter();
    intentFilter.addAction(&quot;myBroadcast.action.call&quot;);
    registerReceiver(mReceiver, intentFilter);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;销毁的时候取消注册&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Override
protected void onDestroy() {
    unregisterReceiver(mReceiver);
    super.onDestroy();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;在另一个-app-定义一个按钮-设置意图-意图添加消息内容-意图设置-action-...-要匹配-然后发送广播即可.&quot;&gt;1.5.3 在另一个 app , 定义一个按钮, 设置意图, 意图添加消息内容, 意图设置 action( ... ) 要匹配 , 然后发送广播即可.&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191107104115937.png&quot; alt=&quot;代码注册 ( 动态广播 )&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void click(View view) {
    Intent intent = new Intent();
    intent.putExtra(&quot;info&quot;, &quot;消息内容&quot;);
    intent.setAction(&quot;myBroadcast.action.call&quot;);
    sendBroadcast(intent);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;运行两个 &lt;code&gt;app&lt;/code&gt; 之后:&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;静态注册的方法: 另一 &lt;code&gt;app&lt;/code&gt; 直接发广播就收到了&lt;/li&gt;
&lt;li&gt;动态注册的方法: 自己的 &lt;code&gt;app&lt;/code&gt; 先代码注册,然后另一个 &lt;code&gt;app&lt;/code&gt; 直接发广播即可.-&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;broadcastreceiver-的实现原理是什么&quot;&gt;1.6 BroadcastReceiver 的实现原理是什么？&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Android&lt;/code&gt; 中的广播使用了设计模式中的观察者模式：基于消息的发布 / 订阅事件模型。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2019110710425074.png&quot; alt=&quot;BroadcastReceiver 的实现原理&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;模型中主要有 &lt;code&gt;3&lt;/code&gt; 个角色：&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;消息订阅者（ 广播接收者 ）&lt;/li&gt;
&lt;li&gt;消息发布者（ 广播发布者 ）&lt;/li&gt;
&lt;li&gt;消息中心（ &lt;code&gt;AMS&lt;/code&gt;，即 &lt;code&gt;Activity Manager Service&lt;/code&gt; ）&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;原理&quot;&gt;1.6.1 原理：&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191107104516822.png&quot; alt=&quot;原理&quot;/&gt;&lt;/p&gt;
&lt;ul readability=&quot;4&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;广播接收者通过 &lt;code&gt;Binder&lt;/code&gt; 机制在 &lt;code&gt;AMS&lt;/code&gt;（ &lt;code&gt;Activity Manager Service&lt;/code&gt; ） 注册；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;广播发送者通过 &lt;code&gt;Binder&lt;/code&gt; 机制向 &lt;code&gt;AMS&lt;/code&gt; 发送广播；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;AMS&lt;/code&gt; 根据广播发送者要求，在已注册列表中，寻找合适的 &lt;code&gt;BroadcastReceiver&lt;/code&gt; （ 寻找依据：&lt;code&gt;IntentFilter / Permission&lt;/code&gt; ）；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;AMS&lt;/code&gt; 将广播发送到 &lt;code&gt;BroadcastReceiver&lt;/code&gt; 相应的消息循环队列中；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;广播接收者通过消息循环拿到此广播，并回调 &lt;code&gt;onReceive()&lt;/code&gt; 方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;需要注意的是：广播的发送和接受是异步的，发送者不会关心有无接收者或者何时收到。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;本地广播&quot;&gt;1.7 本地广播&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191107105513821.png&quot; alt=&quot;本地广播&quot;/&gt;&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li&gt;本地广播机制使得发出的广播只能够在应用程序的内部进行传递，并且广播接收器也只能接受来自本应用程序发出的广播，则安全性得到了提高。&lt;/li&gt;
&lt;li&gt;本地广播主要是使用了一个 &lt;code&gt;LocalBroadcastManager&lt;/code&gt; 来对广播进行管理，并提供了发送广播和注册广播接收器的方法。&lt;/li&gt;
&lt;li&gt;开发者只要实现自己的 &lt;code&gt;BroadcastReceiver&lt;/code&gt; 子类，并重写 &lt;code&gt;onReceive ( Context context, Intetn intent )&lt;/code&gt; 方法即可。&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;当其他组件通过 &lt;code&gt;sendBroadcast()&lt;/code&gt; 、&lt;code&gt;sendStickyBroadcast()&lt;/code&gt; 、&lt;code&gt;sendOrderBroadcast()&lt;/code&gt; 方法发送广播消息时，如果该 &lt;code&gt;BroadcastReceiver&lt;/code&gt; 也对该消息“感兴趣”，&lt;code&gt;BroadcastReceiver&lt;/code&gt; 的 &lt;code&gt;onReceive ( Context context, Intetn intent )&lt;/code&gt; 方法将会被触发。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用步骤：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;调用 LocalBroadcastManager.getInstance() 获得实例&lt;/li&gt;
&lt;li&gt;调用 registerReceiver() 方法注册广播&lt;/li&gt;
&lt;li&gt;调用 sendBroadcast() 方法发送广播&lt;/li&gt;
&lt;li&gt;调用 unregisterReceiver() 方法取消注册&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;注意事项&quot;&gt;1.7.1 注意事项：&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191107105854829.png&quot; alt=&quot;注意事项&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;本地广播无法通过静态注册方式来接受，相比起系统全局广播更加高效。&lt;/li&gt;
&lt;li&gt;在广播中启动 &lt;code&gt;Activity&lt;/code&gt; 时，需要为 &lt;code&gt;Intent&lt;/code&gt; 加入 &lt;code&gt;FLAG_ACTIVITY_NEW_TASK&lt;/code&gt; 标记，否则会报错，因为需要一个栈来存放新打开的 &lt;code&gt;Activity&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;广播中弹出 &lt;code&gt;Alertdialog&lt;/code&gt; 时，需要设置对话框的类型为 &lt;code&gt;TYPE_SYSTEM_ALERT&lt;/code&gt; ，否则无法弹出。&lt;/li&gt;
&lt;li&gt;不要在 &lt;code&gt;onReceiver()&lt;/code&gt; 方法中添加过多的逻辑或者进行任何的耗时操作，因为在广播接收器中是不允许开启线程的，当 &lt;code&gt;onReceiver()&lt;/code&gt; 方法运行了较长时间而没有结束时，程序就会报错。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;sticky-broadcast-粘性广播&quot;&gt;1.8 Sticky Broadcast 粘性广播&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191107110331528.png&quot; alt=&quot;Sticky Broadcast 粘性广播&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;粘性广播通过 &lt;code&gt;Context&lt;/code&gt; 的 &lt;code&gt;sendStickyBroadcast ( Intent )&lt;/code&gt; 接口发送，需要添加权限&lt;/li&gt;
&lt;li&gt;&lt;code&gt;uses-permission android:name=”android.permission.BROADCAST_STICKY”&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;也可以通过 &lt;code&gt;Context&lt;/code&gt; 的 &lt;code&gt;removeStickyBroadcast ( Intent intent )&lt;/code&gt; 接口移除缓存的粘性广播&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;localbroadcastmanager-详解&quot;&gt;1.9 LocalBroadcastManager 详解&lt;/h2&gt;
&lt;h4 id=&quot;特点&quot;&gt;1.9.1 特点：&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2019110614270135.png&quot; alt=&quot;LocalBroadcastManager 特点&quot;/&gt;&lt;/p&gt;
&lt;ol readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;使用它发送的广播将只在自身APP内传播，因此你不必担心泄漏隐私数据；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;其他 &lt;code&gt;APP&lt;/code&gt; 无法对你的 &lt;code&gt;APP&lt;/code&gt; 发送该广播，因为你的APP根本就不可能接收到非自身应用发送的该广播，因此你不必担心有安全漏洞可以利用；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;比系统的全局广播更加高效。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;源码分析&quot;&gt;1.9.2 源码分析 ：&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191106143227175.png&quot; alt=&quot;LocalBroadcastManager 源码分析&quot;/&gt;&lt;/p&gt;
&lt;ol readability=&quot;3&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;code&gt;LocalBroadcastManager&lt;/code&gt; 内部协作主要是靠这两个 &lt;code&gt;Map&lt;/code&gt; 集合：&lt;code&gt;MReceivers&lt;/code&gt; 和 &lt;code&gt;MActions&lt;/code&gt; ，当然还有一个 List 集合 &lt;code&gt;MPendingBroadcasts&lt;/code&gt; ，这个主要就是存储待接收的广播对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;code&gt;LocalBroadcastManager&lt;/code&gt; 高效的原因主要是因为它内部是通过 &lt;code&gt;Handler&lt;/code&gt; 实现的，它的 &lt;code&gt;sendBroadcast()&lt;/code&gt; 方法含义并非和我们平时所用的一样，它的 &lt;code&gt;sendBroadcast()&lt;/code&gt; 方法其实是通过 &lt;code&gt;handler&lt;/code&gt; 发送一个 &lt;code&gt;Message&lt;/code&gt; 实现的；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;既然它内部是通过 &lt;code&gt;Handler&lt;/code&gt; 来实现广播的发送的，那么相比于系统广播通过 &lt;code&gt;Binder&lt;/code&gt; 实现那肯定是更高效了，同时使用 &lt;code&gt;Handler&lt;/code&gt; 来实现，别的应用无法向我们的应用发送该广播，而我们应用内发送的广播也不会离开我们的应用；&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;broadcastreceiver-安全问题&quot;&gt;1.9.3 BroadcastReceiver 安全问题&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191106143732515.png&quot; alt=&quot;BroadcastReceiver 安全问题&quot;/&gt;&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;code&gt;BroadcastReceiver&lt;/code&gt; 设计的初衷是从全局考虑可以方便应用程序和系统、应用程序之间、应用程序内的通信，所以对单个应用程序而言&lt;code&gt;BroadcastReceiver&lt;/code&gt; 是存在安全性问题的 ( 恶意程序脚本不断的去发送你所接收的广播 ) 。为了解决这个问题 &lt;code&gt;LocalBroadcastManager&lt;/code&gt; 就应运而生了。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;code&gt;LocalBroadcastManager&lt;/code&gt; 是 &lt;code&gt;Android Support&lt;/code&gt; 包提供了一个工具，用于在同一个应用内的不同组件间发送 &lt;code&gt;Broadcast&lt;/code&gt;。&lt;code&gt;LocalBroadcastManager&lt;/code&gt; 也称为局部通知管理器，这种通知的好处是安全性高，效率也高，适合局部通信，可以用来代替 &lt;code&gt;Handler&lt;/code&gt; 更新 &lt;code&gt;UI&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;广播的安全性&quot;&gt;1.9.4 广播的安全性&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Android&lt;/code&gt; 系统中的广播可以跨进程直接通信，会产生以下两个问题：&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;其他 &lt;code&gt;APP&lt;/code&gt; 可以接收到当前 &lt;code&gt;APP&lt;/code&gt; 发送的广播，导致数据外泄。&lt;/li&gt;
&lt;li&gt;其他 &lt;code&gt;APP&lt;/code&gt; 可以向当前 &lt;code&gt;APP&lt;/code&gt; 放广播消息，导致 &lt;code&gt;APP&lt;/code&gt; 被非法控制。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191106144807321.png&quot; alt=&quot;广播的安全性&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;发送广播&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;发送广播时，增加相应的 &lt;code&gt;permission&lt;/code&gt; ，用于权限验证。&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;Android 4.0&lt;/code&gt; 及以上系统中发送广播时，可以使用 &lt;code&gt;setPackage()&lt;/code&gt; 方法设置接受广播的包名。&lt;/li&gt;
&lt;li&gt;使用局部广播。&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;接受广播&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;注册广播接收器时，增加相应的 &lt;code&gt;permission&lt;/code&gt; ，用于权限验证。&lt;/li&gt;
&lt;li&gt;注册广播接收器时，设置 &lt;code&gt;android:exported&lt;/code&gt; 的值为false。&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;使用局部广播。&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;发送广播时，如果增加了 &lt;code&gt;permission&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;那接受广播的 &lt;code&gt;APP&lt;/code&gt; 必须申请相应权限，这样才能收到对应的广播，反之亦然。&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;使用-broadcastreceiver-的好处&quot;&gt;1.9.5 使用 BroadcastReceiver 的好处&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191106143838935.png&quot; alt=&quot;BroadcastReceiver 的好处&quot;/&gt;&lt;/p&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;因广播数据在本应用范围内传播，你不用担心隐私数据泄露的问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;不用担心别的应用伪造广播，造成安全隐患。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;相比在系统内发送全局广播，它更高效。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;如何让自己的广播只让指定的-app-接收&quot;&gt;1.10 如何让自己的广播只让指定的 app 接收?&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191107110804921.png&quot; alt=&quot;让自己的广播只让指定的 app 接收&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在发送广播的 &lt;code&gt;app&lt;/code&gt; 端,自定义定义权限, 那么想要接收的另外 &lt;code&gt;app&lt;/code&gt; 端必须声明权限才能收到.&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;权限, 保护层级是普通正常.&lt;/li&gt;
&lt;li&gt;用户权限&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;&amp;lt;permission android:name=&quot;broad.ok.receiver&quot; android:protectionLevel=&quot;normal&quot;/&amp;gt;
&amp;lt;uses-permission android:name=&quot;broad.ok.receiver&quot; /&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;发送广播的时候加上权限字符串&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void click(View view) {
    Intent intent = new Intent();
    intent.putExtra(&quot;info&quot;, &quot;消息内容&quot;);
    intent.setAction(&quot;myBroadcast.action.call&quot;);
    sendBroadcast(intent, &quot;broad.ok.receiver&quot;);
    //sendOrderedBroadcast(intent,&quot;broad.ok.receiver&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;其他app接收者想好获取广播,必须声明在清单文件权限&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;&amp;lt;uses-permission android:name=&quot;broad.ok.receiver&quot;/&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;广播的优先级对无序广播生效吗&quot;&gt;1.11 广播的优先级对无序广播生效吗?&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191106144310550.png&quot; alt=&quot;广播的优先级对无序广播生效&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;优先级对无序也生效.&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;动态注册的广播优先级谁高&quot;&gt;1.12 动态注册的广播优先级谁高?&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191106144226955.png&quot; alt=&quot;动态注册的广播优先级谁高&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;谁先注册,谁就高&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;如何判断当前的-brodcastreceiver-接收到的是有序还是无序的广播&quot;&gt;1.13 如何判断当前的 BrodcastReceiver 接收到的是有序还是无序的广播?&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191107111129523.png&quot; alt=&quot;判断当前的 BrodcastReceiver 接收到的是有序还是无序&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在 &lt;code&gt;onReceiver&lt;/code&gt; 方法里,直接调用判断方法得返回值&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void onReceive(Context context, Intent intent) {
    Log.d(&quot;MyBroadCastReceiver&quot;, &quot;收到信息,内容是 :　&quot; + intent.getStringExtra(&quot;info&quot;) + &quot;&quot;);
    boolean isOrderBroadcast = isOrderedBroadcast();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;broadcastreceiver-不能执行耗时操作&quot;&gt;1.14 BroadcastReceiver 不能执行耗时操作&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2019110711124336.png&quot; alt=&quot;BroadcastReceiver 不能执行耗时操作&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;BroadcastReceiver&lt;/code&gt; 一般处于主线程。&lt;/li&gt;
&lt;li&gt;耗时操作会导致 &lt;code&gt;ANR&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;另一方面&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;&lt;code&gt;BroadcastReceiver&lt;/code&gt; 启动时间较短。&lt;/li&gt;
&lt;li&gt;如果一个进程里面只存在一个 &lt;code&gt;BroadcastReceiver&lt;/code&gt; 组件。并且在其中开启子线程执行耗时任务。&lt;/li&gt;
&lt;li&gt;系统会认为该进程是优先级最低的空进程。很容易将其杀死。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr/&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;ContentProvider&lt;/code&gt; 应用程序间非常通用的共享数据的一种方式，也是 &lt;code&gt;Android&lt;/code&gt; 官方推荐的方式。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Android&lt;/code&gt; 中许多系统应用都使用该方式实现数据共享，比如通讯录、短信等。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2019110712210021.png&quot; alt=&quot;ContentProvider&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;android-为什么要设计-contentprovider-这个组件&quot;&gt;2.1 Android 为什么要设计 ContentProvider 这个组件？&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191107111728578.png&quot; alt=&quot;为什么要设计 ContentProvider&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;很多做 &lt;code&gt;Android&lt;/code&gt; 开发的人都不怎么使用它，觉得直接读取数据库会更简单方便。&lt;/li&gt;
&lt;li&gt;那么 &lt;code&gt;Android&lt;/code&gt; 搞一个内容提供者在数据和应用之间，只是为了装高大上，故弄玄虚？我认为其设计用意在于：&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;封装。对数据进行封装，提供统一的接口，使用者完全不必关心这些数据是在 &lt;code&gt;DB&lt;/code&gt; ，&lt;code&gt;XML&lt;/code&gt; 、&lt;code&gt;Preferences&lt;/code&gt; 或者网络请求来的。当项目需求要改变数据来源时，使用我们的地方完全不需要修改。&lt;/li&gt;
&lt;li&gt;提供一种跨进程数据共享的方式。&lt;/li&gt;
&lt;li&gt;应用程序间的数据共享还有另外的一个重要话题，就是数据更新通知机制了。因为数据是在多个应用程序中共享的，当其中一个应用程序改变了这些共享数据的时候，它有责任通知其它应用程序，让它们知道共享数据被修改了，这样它们就可以作相应的处理。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;如何访问自定义-contentprovider&quot;&gt;2.2 如何访问自定义 ContentProvider&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191107112119671.png&quot; alt=&quot;如何访问自定义 ContentProvider&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;ContentResolver&lt;/code&gt; 接口的 &lt;code&gt;notifyChange&lt;/code&gt; 函数来通知那些注册了监控特定 URI的ContentObserver 对象，使得它们可以相应地执行一些处理。&lt;/li&gt;
&lt;li&gt;ContentObserver 可以通过 registerContentObserver 进行注册。&lt;/li&gt;
&lt;li&gt;通过 &lt;code&gt;ContentProvider&lt;/code&gt; 的 &lt;code&gt;Uri&lt;/code&gt; 访问开放的数据。&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;&lt;code&gt;ContenResolver&lt;/code&gt; 对象通过 &lt;code&gt;Context&lt;/code&gt; 提供的方法 &lt;code&gt;getContenResolver()&lt;/code&gt; 来获得。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ContenResolver&lt;/code&gt; 提供了以下方法来操作：&lt;code&gt;insert&lt;/code&gt; &lt;code&gt;delete&lt;/code&gt; &lt;code&gt;update&lt;/code&gt; &lt;code&gt;query&lt;/code&gt; 这些方法分别会调用 &lt;code&gt;ContenProvider&lt;/code&gt; 中与之对应的方法并得到返回的结果。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;通过-contentresolver-获取-contentprovider-内容的基本步骤&quot;&gt;2.3 通过 ContentResolver 获取 ContentProvider 内容的基本步骤&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191107112310552.png&quot; alt=&quot;ContentResolver 获取 ContentProvider 内容的基本步骤&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;得到 &lt;code&gt;ContentResolver&lt;/code&gt; 类对象：&lt;code&gt;ContentResolver cr = getContentResolver ( )&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;定义要查询的字段 &lt;code&gt;String&lt;/code&gt; 数组。&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;cr.query()&lt;/code&gt; ; 返回一个 &lt;code&gt;Cursor&lt;/code&gt; 对象。&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;while&lt;/code&gt; 循环得到 &lt;code&gt;Cursor&lt;/code&gt; 里面的内容。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;contentprovider-是如何实现数据共享的&quot;&gt;2.4 ContentProvider 是如何实现数据共享的：&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191107112741556.png&quot; alt=&quot;ContentProvider 是如何实现数据共享的&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在 &lt;code&gt;Android&lt;/code&gt; 中如果想将自己应用的数据 ( 一般多为数据库中的数据 ) 提供给第三发应用, 那么我们只能通过 &lt;code&gt;ContentProvider&lt;/code&gt; 来实现了。 &lt;code&gt;ContentProvider&lt;/code&gt; 是应用程序之间共享数据的接口。&lt;/li&gt;
&lt;li&gt;使用的时候首先自定义 一个类继承 &lt;code&gt;ContentProvider&lt;/code&gt; , 然后覆写 &lt;code&gt;query&lt;/code&gt; 、&lt;code&gt;insert&lt;/code&gt; 、&lt;code&gt;update&lt;/code&gt; 、&lt;code&gt;delete&lt;/code&gt; 等 方法。&lt;/li&gt;
&lt;li&gt;因为其是四大组件之一因此必须在 &lt;code&gt;AndroidManifest&lt;/code&gt; 文件中进行注册。&lt;/li&gt;
&lt;li&gt;把自己的数据通过 &lt;code&gt;uri&lt;/code&gt; 的形式共享出去 &lt;code&gt;android&lt;/code&gt; 系统下 不同程序 数据默认是不能共享访问 需要去实现一个类去继承 &lt;code&gt;ContentProvider&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class PersonContentProvider extends ContentProvider{

   public boolean onCreate(){ }
   query(Url, String[], String, String[], String);
   insert(Uri,ContentValues);
   update(Uri,ContentValues,String[]);
   delete(Uri,String,String[]);
   
} &lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;为什么要用-contentprovider-它和-sql-的实现上有什么差别&quot;&gt;2.5 为什么要用 ContentProvider ?它和 sql 的实现上有什么差别?&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191107112907157.png&quot; alt=&quot;为什么要用 ContentProvider ?它和 sql 的实现上有什么差别&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;ContentProvider&lt;/code&gt; 屏蔽了数据存储的细节 , 内部实现对用户完全透明 , 用户只需要关心操作数据的 &lt;code&gt;uri&lt;/code&gt; 就可以了, &lt;code&gt;ContentProvider&lt;/code&gt; 可以实现不同 &lt;code&gt;app&lt;/code&gt;之间 共享。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Sql&lt;/code&gt; 也有增删改查的方法, 但是 &lt;code&gt;sql&lt;/code&gt; 只能查询本应用下的数据库。&lt;/li&gt;
&lt;li&gt;而 &lt;code&gt;ContentProvider&lt;/code&gt; 还可以去增删改查本地文件. &lt;code&gt;xml&lt;/code&gt; 文件的读取等。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;uri-介绍&quot;&gt;2.6 Uri 介绍&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191107113345318.png&quot; alt=&quot;Uri 介绍&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;为系统的每一个资源给其一个名字，比方说通话记录。&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;每一个 &lt;code&gt;ContentProvider&lt;/code&gt; 都拥有一个公共的 &lt;code&gt;URI&lt;/code&gt; ，这个 &lt;code&gt;URI&lt;/code&gt; 用于表示这个 &lt;code&gt;ContentProvider&lt;/code&gt; 所提供的数据。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Android&lt;/code&gt; 所提供的 &lt;code&gt;ContentProvider&lt;/code&gt; 都存放在 &lt;code&gt;android.provider&lt;/code&gt; 包中。&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;将其分为 &lt;code&gt;A，B，C，D&lt;/code&gt; 4个部分：&lt;/li&gt;
&lt;li&gt;&lt;code&gt;A&lt;/code&gt;：标准前缀，用来说明一个 &lt;code&gt;Content Provider&lt;/code&gt; 控制这些数据，无法改变的；&lt;code&gt;&quot;content://&quot;&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;B&lt;/code&gt;：&lt;code&gt;URI&lt;/code&gt; 的标识，用于唯一标识这个 &lt;code&gt;ContentProvider&lt;/code&gt; ，外部调用者可以根据这个标识来找到它。它定义了是哪个 &lt;code&gt;ContentProvider&lt;/code&gt; 提供这些数据。对于第三方应用程序，为了保证 &lt;code&gt;URI&lt;/code&gt; 标识的唯一性，它必须是一个完整的、小写的类名。这个标识在元素的 &lt;code&gt;authorities&lt;/code&gt; 属性中说明：一般是定义该 &lt;code&gt;ContentProvider&lt;/code&gt; 的包类的名称；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;C&lt;/code&gt;：路径（ &lt;code&gt;path&lt;/code&gt; ），通俗的讲就是你要操作的数据库中表的名字，或者你也可以自己定义，记得在使用的时候保持一致就可以了；&lt;code&gt;&quot;content://com.bing.provider.myprovider/tablename&quot;&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;D&lt;/code&gt;：如果URI中包含表示需要获取的记录的 &lt;code&gt;ID&lt;/code&gt;；则就返回该id对应的数据，如果没有 &lt;code&gt;ID&lt;/code&gt;，就表示返回全部； &lt;code&gt;&quot;content://com.bing.provider.myprovider/tablename/#&quot;&lt;/code&gt; &lt;code&gt;#&lt;/code&gt; 表示数据 &lt;code&gt;id&lt;/code&gt; 。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;如何访问-asserts-资源目录下的数据库&quot;&gt;2.7 如何访问 asserts 资源目录下的数据库?&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191107113504103.png&quot; alt=&quot;访问 asserts 资源目录下的数据库&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;把数据库 &lt;code&gt;db&lt;/code&gt; 复制到 &lt;code&gt;/data/data/packagename/databases/&lt;/code&gt; 目录下, 然后直接就能访问了。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;多个进程同时调用一个-contentprovider-的-query-获取数据contentprvoider-是如何反应的呢&quot;&gt;2.8 多个进程同时调用一个 ContentProvider 的 query 获取数据，ContentPrvoider 是如何反应的呢？&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191107114742923.png&quot; alt=&quot;调用一个 ContentProvider 的 query 获取数据，ContentPrvoider 是如何反应的&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一个 &lt;code&gt;ContentProvider&lt;/code&gt; 可以接受来自另外一个进程的数据请求。&lt;/li&gt;
&lt;li&gt;尽管 &lt;code&gt;ContentResolver&lt;/code&gt; 与 &lt;code&gt;ContentProvider&lt;/code&gt; 类隐藏了实现细节，但是 &lt;code&gt;ContentProvider&lt;/code&gt; 所提供的 &lt;code&gt;query()&lt;/code&gt;，&lt;code&gt;insert()&lt;/code&gt;，&lt;code&gt;delete()&lt;/code&gt;，&lt;code&gt;update()&lt;/code&gt; 都是在 &lt;code&gt;ContentProvider&lt;/code&gt; 进程的线程池中被调用执行的，而不是进程的主线程中。&lt;/li&gt;
&lt;li&gt;这个线程池是有 &lt;code&gt;Binder&lt;/code&gt; 创建和维护的，其实使用的就是每个应用进程中的 &lt;code&gt;Binder&lt;/code&gt; 线程池。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;android-设计-contentprovider-的目的是什么呢&quot;&gt;2.9 Android 设计 ContentProvider 的目的是什么呢？&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191107114949656.png&quot; alt=&quot;设计 ContentProvider 的目的&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;隐藏数据的实现方式，对外提供统一的数据访问接口；&lt;/li&gt;
&lt;li&gt;更好的数据访问权限管理。&lt;code&gt;ContentProvider&lt;/code&gt; 可以对开发的数据进行权限设置，不同的 &lt;code&gt;URI&lt;/code&gt; 可以对应不同的权限，只有符合权限要求的组件才能访问到 &lt;code&gt;ContentProvider&lt;/code&gt; 的具体操作。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ContentProvider&lt;/code&gt; 封装了跨进程共享的逻辑，我们只需要 &lt;code&gt;Uri&lt;/code&gt; 即可访问数据。由系统来管理 &lt;code&gt;ContentProvider&lt;/code&gt; 的创建、生命周期及访问的线程分配，简化我们在应用间共享数据（ 进程间通信 ）的方式。我们只管通过 &lt;code&gt;ContentResolver&lt;/code&gt; 访问 &lt;code&gt;ContentProvider&lt;/code&gt; 所提示的数据接口，而不需要担心它所在进程是启动还是未启动。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;运行在主线程的-contentprovider-为什么不会影响主线程的ui操作&quot;&gt;2.10 运行在主线程的 ContentProvider 为什么不会影响主线程的UI操作?&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2019110711540975.png&quot; alt=&quot;ContentProvider 为什么不会影响主线程的UI操作&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;ContentProvider&lt;/code&gt; 的 &lt;code&gt;onCreate()&lt;/code&gt; 是运行在 &lt;code&gt;UI&lt;/code&gt; 线程的，而 &lt;code&gt;query()&lt;/code&gt; ，&lt;code&gt;insert()&lt;/code&gt; ，&lt;code&gt;delete()&lt;/code&gt; ，&lt;code&gt;update()&lt;/code&gt; 是运行在线程池中的工作线程的&lt;/li&gt;
&lt;li&gt;所以调用这向个方法并不会阻塞 &lt;code&gt;ContentProvider&lt;/code&gt; 所在进程的主线程，但可能会阻塞调用者所在的进程的 &lt;code&gt;UI&lt;/code&gt; 线程！&lt;/li&gt;
&lt;li&gt;所以，调用 &lt;code&gt;ContentProvider&lt;/code&gt; 的操作仍然要放在子线程中去做。&lt;/li&gt;
&lt;li&gt;虽然直接的 &lt;code&gt;CRUD&lt;/code&gt; 的操作是在工作线程的，但系统会让你的调用线程等待这个异步的操作完成，你才可以继续线程之前的工作。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;外提供数据共享那么如何限制对方的使用呢&quot;&gt;2.11 外提供数据共享，那么如何限制对方的使用呢？&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191107115200504.png&quot; alt=&quot;如何限制对方的使用&quot;/&gt;&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li&gt;&lt;code&gt;android:exported&lt;/code&gt; 属性非常重要。这个属性用于指示该服务是否能够被其他应用程序组件调用或跟它交互。&lt;/li&gt;
&lt;li&gt;如果设置为 &lt;code&gt;true&lt;/code&gt;，则能够被调用或交互，否则不能。&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;设置为 &lt;code&gt;false&lt;/code&gt; 时，只有同一个应用程序的组件或带有相同用户 &lt;code&gt;ID&lt;/code&gt; 的应用程序才能启动或绑定该服务。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;对于需要开放的组件应设置合理的权限，如果只需要对同一个签名的其它应用开放 &lt;code&gt;ContentProvider&lt;/code&gt; ，则可以设置 &lt;code&gt;signature&lt;/code&gt; 级别的权限。&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;大家可以参考一下系统自带应用的代码，自定义了 &lt;code&gt;signature&lt;/code&gt; 级别的 &lt;code&gt;permission&lt;/code&gt; ：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;&amp;lt;permission android:name=&quot;com.android.gallery3d.filtershow.permission.READ&quot;
            android:protectionLevel=&quot;signature&quot; /&amp;gt;

&amp;lt;permission android:name=&quot;com.android.gallery3d.filtershow.permission.WRITE&quot;
            android:protectionLevel=&quot;signature&quot; /&amp;gt;

&amp;lt;provider
    android:name=&quot;com.android.gallery3d.filtershow.provider.SharedImageProvider&quot;
    android:authorities=&quot;com.android.gallery3d.filtershow.provider.SharedImageProvider&quot;
    android:grantUriPermissions=&quot;true&quot;
    android:readPermission=&quot;com.android.gallery3d.filtershow.permission.READ&quot;
    android:writePermission=&quot;com.android.gallery3d.filtershow.permission.WRITE&quot; /&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;如果我们只需要开放部份的-uri-给其他的应用访问呢&quot;&gt;2.11.1 如果我们只需要开放部份的 &lt;code&gt;URI&lt;/code&gt; 给其他的应用访问呢？&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191107115607274.png&quot; alt=&quot;如果我们只需要开放部份的 URI 给其他的应用访问呢&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;可以参考 &lt;code&gt;Provider&lt;/code&gt; 的 &lt;code&gt;URI&lt;/code&gt; 权限设置，只允许访问部份 &lt;code&gt;URI&lt;/code&gt; ，可以参考原生 &lt;code&gt;ContactsProvider2&lt;/code&gt; 的相关代码（ 注意 &lt;code&gt;path-permission&lt;/code&gt; 这个选项 ）：&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;&amp;lt;provider android:name=&quot;ContactsProvider2&quot;
    android:authorities=&quot;contacts;com.android.contacts&quot;
    android:label=&quot;@string/provider_label&quot;
    android:multiprocess=&quot;false&quot;
    android:exported=&quot;true&quot;
    android:grantUriPermissions=&quot;true&quot;
    android:readPermission=&quot;android.permission.READ_CONTACTS&quot;
    android:writePermission=&quot;android.permission.WRITE_CONTACTS&quot;&amp;gt;
    &amp;lt;path-permission
            android:pathPrefix=&quot;/search_suggest_query&quot;
            android:readPermission=&quot;android.permission.GLOBAL_SEARCH&quot; /&amp;gt;
    &amp;lt;path-permission
            android:pathPrefix=&quot;/search_suggest_shortcut&quot;
            android:readPermission=&quot;android.permission.GLOBAL_SEARCH&quot; /&amp;gt;
    &amp;lt;path-permission
            android:pathPattern=&quot;/contacts/.*/photo&quot;
            android:readPermission=&quot;android.permission.GLOBAL_SEARCH&quot; /&amp;gt;
    &amp;lt;grant-uri-permission android:pathPattern=&quot;.*&quot; /&amp;gt;
&amp;lt;/provider&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;contentprovider-接口方法运行在哪个线程中呢&quot;&gt;2.12 ContentProvider 接口方法运行在哪个线程中呢？&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191107115802830.png&quot; alt=&quot;ContentProvider 接口方法运行在哪个线程中&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;ContentProvider&lt;/code&gt; 可以在 &lt;code&gt;AndroidManifest.xml&lt;/code&gt; 中配置一个叫做 &lt;code&gt;android:multiprocess&lt;/code&gt; 的属性，默认值是 false ，表示 ContentProvider 是单例的&lt;/li&gt;
&lt;li&gt;无论哪个客户端应用的访问都将是同一个 &lt;code&gt;ContentProvider&lt;/code&gt; 对象，如果设为 &lt;code&gt;true&lt;/code&gt; ，系统会为每一个访问该 &lt;code&gt;ContentProvider&lt;/code&gt; 的进程创建一个实例。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;这点还是比较好理解的那如果我要问每个-contentprovider-的操作是在哪个线程中运行的呢-其实我们关心的是-ui-线程和工作线程&quot;&gt;2.12.1 这点还是比较好理解的，那如果我要问每个 ContentProvider 的操作是在哪个线程中运行的呢?（ 其实我们关心的是 UI 线程和工作线程 ）&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191107120017748.png&quot; alt=&quot;每个 ContentProvider 的操作是在哪个线程中运行的&quot;/&gt;&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;比如我们在UI线程调用getContentResolver().query查询数据，而当数据量很大时（或者需要进行较长时间的计算）会不会阻塞UI线程呢？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;要分两种情况回答这个问题：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;&lt;code&gt;ContentProvider&lt;/code&gt; 和调用者在同一个进程，&lt;code&gt;ContentProvider&lt;/code&gt; 的方法（ &lt;code&gt;query/insert/update/delete&lt;/code&gt; 等 ）和调用者在同一线程中；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ContentProvider&lt;/code&gt; 和调用者在不同的进程，&lt;code&gt;ContentProvider&lt;/code&gt; 的方法会运行在它自身所在进程的一个 Binder 线程中。&lt;br/&gt;但是，注意这两种方式在 &lt;code&gt;ContentProvider&lt;/code&gt; 的方法没有执行完成前都会 &lt;code&gt;blocked&lt;/code&gt; 调用者。所以你应该知道这个上面这个问题的答案了吧。&lt;/li&gt;
&lt;li&gt;也可以看看 &lt;code&gt;CursorLoader&lt;/code&gt; 这个类的源码，看 &lt;code&gt;Google&lt;/code&gt; 自己是怎么使用 &lt;code&gt;getContentResolver().query&lt;/code&gt; 的。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;contentprovider-是如何在不同应用程序之间传输数据的&quot;&gt;2.13 ContentProvider 是如何在不同应用程序之间传输数据的？&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191107120231873.png&quot; alt=&quot;ContentProvider 是如何在不同应用程序之间传输数据&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一个应用进程有 &lt;code&gt;16&lt;/code&gt; 个 &lt;code&gt;Binder&lt;/code&gt; 线程去和远程服务进行交互，而每个线程可占用的缓存空间是 &lt;code&gt;128KB&lt;/code&gt; 这样，超过会报异常。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ContentResolver&lt;/code&gt; 虽然是通过 &lt;code&gt;Binder&lt;/code&gt; 进程间通信机制打通了应用程序之间共享数据的通道，但 &lt;code&gt;ContentProvider&lt;/code&gt; 组件在不同应用程序之间传输数据是基于匿名共享内存机制来实现的。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191105184103232.png&quot; alt=&quot;图解 ContentProvider&quot;/&gt;&lt;/p&gt;

&lt;hr/&gt;&lt;ol&gt;&lt;li&gt;本文应该是全网最全面的 &lt;code&gt;BroadcastReceiver&lt;/code&gt; 、&lt;code&gt;ContentProvider&lt;/code&gt; 知识总结了，前前后后投入了大量时间来完成。希望大家通过本次阅读都能有所收获。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;重点&lt;/code&gt;&lt;/strong&gt;：关于 &lt;code&gt;Android&lt;/code&gt; 的四大组件，到现在为止我才总结完 &lt;code&gt;Activity&lt;/code&gt; 、&lt;code&gt;Service&lt;/code&gt; 、&lt;code&gt;BroadcastRecevier&lt;/code&gt; 、&lt;code&gt;ContentProvider&lt;/code&gt;等，以及事件分发、滑动冲突、新能优化等重要模块，进行全面总结，欢迎大家关注 &lt;a href=&quot;https://www.cnblogs.com/yuanhao-1999/&quot;&gt;_yuanhao 的 博客园&lt;/a&gt; ，方便及时接收更新&lt;/li&gt;
&lt;/ol&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191029235448320.jpeg&quot; alt=&quot;Android&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 08 Nov 2019 00:33:00 +0000</pubDate>
<dc:creator>__yuanhao</dc:creator>
<og:description>前言 距离上次更新过去一周多了，打破了之前两到三天一更的惯例，主要还是这部分内容太多了。 原先想把 、 分两篇来总结，但的确，这两大组件的使用不像 、 那么频繁，所以还是决定一次性搞定。 于是这篇近</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yuanhao-1999/p/11817955.html</dc:identifier>
</item>
<item>
<title>微服务架构案例(06)：通过业务、应用、技术、存储方面，聊聊架构 - 知了一笑</title>
<link>http://www.cnblogs.com/cicada-smile/p/11817455.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cicada-smile/p/11817455.html</guid>
<description>&lt;p&gt;&lt;strong&gt;更新进度(共6节)： 源码地址：&lt;/strong&gt;&lt;a href=&quot;https://github.com/cicadasmile/husky-spring-cloud&quot;&gt;GitHub·点这里&lt;/a&gt; || &lt;a href=&quot;https://gitee.com/cicadasmile/husky-spring-cloud&quot;&gt;GitEE·点这里&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1691717/201911/1691717-20191108080026229-1775366391.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;架构分类可细化的分为业务架构、应用架构、技术选型、代码规划、部署环境架构等。业务架构是核心的驱动力，应用架构是实现的思路，技术选型落地是结果。根据用户需求，设计合理的业务架构，做出相应的应用架构流程，最后落地实施，完成项目。如何在架构的初期，预判业务发展的速度，保证架构可以稳定快速的扩展，支撑起业务发展，这个是软件开发者，特别是架构师，需要长期积累和修炼的核心能力。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1691717/201911/1691717-20191108080036041-267341921.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;业务架构中包括业务规划、功能模块、流程设计，微服务架构模式中对整个系统的业务进行服务化拆分设计，把实际的业务抽象化,进而进行封装，优化服务结构。不需要最好的架构，只选则合适的架构，系统架构的原则都要以解决业务问题为核心目标，任何不基于业务做天马行空的架构都是对公司的不负责任。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1691717/201911/1691717-20191108080045441-514126298.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;应用架构流程是基于业务架构来设计的，相辅相成的关系。每个应用可以作为独立的服务组件，把系统规划为一个个服务模块，进而进行开发，部署，运维等系列操作，所谓应用就是各个服务模块。首选要明确各个服务核心功能，其次确定各个服务间协调工作，保证服务的稳定性。微服务架构模式下，对系统进行水平拆分和垂直拆分，做到可以对任何高并发的服务模块进行独立扩展，灵活性非常好。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1691717/201911/1691717-20191108080055341-190411403.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;数据架构是确定数据库模型的设计，不同业务场景下的数据可以选择不同种类的库来存储，例如搜索的数据可以使用ES，热点数据可以使用Redis，普通业务数据可以选择MySQL。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1691717/201911/1691717-20191108080107981-1631781164.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、分层结构设计&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;清晰的分层设计可以帮助快发人员快速的理解系统，缩短熟悉系统的时间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、模块依赖&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给出模块依赖的明确顺序，比如接口(Web层)依赖服务层(Service层)，服务实现(Impl)依赖持久层接口(Dao)，持久层实现(DaoImpl)依赖表实体对象(Entity),避免系统陷入代码杂乱的坑中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、开发规范&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每个项目开发必须要遵守统一的编码规范文档，统一命名格式，注释风格，这样可以方便其他人员快速阅读和理解代码逻辑。&lt;/p&gt;

&lt;p&gt;选择合适的基础框架，数据库，中间件，基于项目的开发规范，把应用架构完整的实现，这样项目就很难走偏。把握系统的高可用、高性能、扩展、伸缩、安全管理等方方面面的知识需要一个持久的积累和在实践中不断进步。&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;GitHub·地址
https://github.com/cicadasmile/husky-spring-cloud
GitEE·地址
https://gitee.com/cicadasmile/husky-spring-cloud&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1691717/201908/1691717-20190823075428183-1996768914.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 08 Nov 2019 00:19:00 +0000</pubDate>
<dc:creator>知了一笑</dc:creator>
<og:description>更新进度(共6节)： 源码地址： 'GitHub·点这里' || 'GitEE·点这里' 章节 | 文章标题 | 01 | '项目技术选型简介，架构图解说明' 02 | '业务架构设计，系统分层管理'</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cicada-smile/p/11817455.html</dc:identifier>
</item>
<item>
<title>前端技术之：如何在vuex状态管理action异步调用结束后执行UI中的方法 - sxliuchunrong</title>
<link>http://www.cnblogs.com/popgis/p/11817443.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/popgis/p/11817443.html</guid>
<description>&lt;h3 id=&quot;%E4%B8%80%E3%80%81%E9%97%AE%E9%A2%98%E7%9A%84%E8%B5%B7%E6%BA%90&quot;&gt;一、问题的起源&lt;/h3&gt;
&lt;p&gt;最近在做vue.js项目时，遇到了vuex状态管理action与vue.js方法互相通信、互操作的问题。场景如下图所示：&lt;/p&gt;
&lt;h3 id=&quot;%E4%BA%8C%E3%80%81%E7%AC%AC%E4%B8%80%E7%A7%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95&quot;&gt;二、第一种解决方法&lt;/h3&gt;
&lt;p&gt;例如，我们在页面初始化的时候，需要从服务端通过API接口获取数据，数据获取成功前需要显示Loading状态框，数据获取完成后，需要将Loading状态框隐藏。&lt;/p&gt;
&lt;p&gt;这是一种相对比较简单的应用场景，解决起来当然也比较简单。&lt;/p&gt;
&lt;p&gt;我们可以&lt;code data-backticks=&quot;1&quot;&gt;通过state数据字段来实现&lt;/code&gt;，在state中存储一个loading字段，并设置默认值为false。&lt;/p&gt;
&lt;pre data-language=&quot;JavaScript&quot;&gt;
&lt;code class=&quot;hljs lang-JavaScript&quot; data-language=&quot;JavaScript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;const store = &lt;span class=&quot;hljs-keyword&quot;&gt;new Vuex.Store({
  &lt;span class=&quot;hljs-attr&quot;&gt;state: {
    &lt;span class=&quot;hljs-attr&quot;&gt;loading: &lt;span class=&quot;hljs-literal&quot;&gt;false
  },
  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为要对state.loading进行操作，所以，我们需要定义一个mutation方法，用于更新loading状态数据。&lt;/p&gt;
&lt;pre data-language=&quot;JavaScript&quot;&gt;
&lt;code class=&quot;hljs lang-JavaScript&quot; data-language=&quot;JavaScript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;const UPDATE_LOADING = &lt;span class=&quot;hljs-string&quot;&gt;'updateLoading';

&lt;span class=&quot;hljs-keyword&quot;&gt;const store = &lt;span class=&quot;hljs-keyword&quot;&gt;new Vuex.Store({
  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后，我们声明一个action方法，用于从HTTP API获取数据。&lt;/p&gt;
&lt;pre data-language=&quot;JavaScript&quot;&gt;
&lt;code class=&quot;hljs lang-JavaScript&quot; data-language=&quot;JavaScript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;const store = &lt;span class=&quot;hljs-keyword&quot;&gt;new Vuex.Store({
  &lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在页面模板中，我们通过mapActions函数将vuex的action方法映射为vue.js中对象的方法。&lt;/p&gt;
&lt;pre data-language=&quot;JavaScript&quot;&gt;
&lt;code class=&quot;hljs lang-JavaScript&quot; data-language=&quot;JavaScript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import { mapActions } &lt;span class=&quot;hljs-keyword&quot;&gt;from &lt;span class=&quot;hljs-string&quot;&gt;'vuex'

&lt;span class=&quot;hljs-keyword&quot;&gt;export &lt;span class=&quot;hljs-keyword&quot;&gt;default {
  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后，在vue.js的mounted生命周期方法中调用通过mapActions映身的方法fetchData即可。&lt;/p&gt;
&lt;pre data-language=&quot;JavaScript&quot;&gt;
&lt;code class=&quot;hljs lang-JavaScript&quot; data-language=&quot;JavaScript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;export &lt;span class=&quot;hljs-keyword&quot;&gt;default {
  &lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;%E4%B8%89%E3%80%81%E7%AC%AC%E4%BA%8C%E7%A7%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95&quot;&gt;三、第二种解决方法&lt;/h3&gt;
&lt;p&gt;上述的第一种解决方法，可以通过mutation修改state的状态数据控制UI上的数据渲染。但如果想要将获取到的结果数据传到UI组件是不行的，另外，如果想要在调用action方法执行完成后在UI中再去做一些事情也是行不通的。&lt;/p&gt;
&lt;p&gt;以前我们知道，异步方法传递数据，可以通过回调函数的参数进行传递数据，所以，我提到的第二种解决办法就是&lt;code data-backticks=&quot;1&quot;&gt;通过回调函数实现&lt;/code&gt;的。&lt;/p&gt;
&lt;pre data-language=&quot;JavaScript&quot;&gt;
&lt;code class=&quot;hljs lang-JavaScript&quot; data-language=&quot;JavaScript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;const store = &lt;span class=&quot;hljs-keyword&quot;&gt;new Vuex.Store({
  &lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;%E5%9B%9B%E3%80%81%E7%AC%AC%E4%B8%89%E7%A7%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95&quot;&gt;四、第三种解决方法&lt;/h3&gt;
&lt;p&gt;以上两种方式虽然可以解决某些问题，但解决方法不够优雅，而且第一种方法具有很大的局限性。比如，不能回调主界面中的方法执行后续的操作，也不能自由地传递参数。第二种方法采用回调可以调用方法，也可以传参，但callback的调用是同步方式，代码风格也不是很好。所以，我比较提倡大家使用第三种方法，就是在action调用时返回一个Promise，这样在主界面就可以拿到这个promise对象，并进行链式执行后续的任务，也可以将action异步任务的结果数据传递给主UI。&lt;/p&gt;
&lt;pre data-language=&quot;js&quot;&gt;
&lt;code class=&quot;hljs lang-js&quot; data-language=&quot;js&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;const store = &lt;span class=&quot;hljs-keyword&quot;&gt;new Vuex.Store({
  &lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在主UI中，我们就可以采用如下的方式进行后续的操作。&lt;/p&gt;
&lt;pre data-language=&quot;js&quot;&gt;
&lt;code class=&quot;hljs lang-js&quot; data-language=&quot;js&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;export &lt;span class=&quot;hljs-keyword&quot;&gt;default {
  &lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 08 Nov 2019 00:06:00 +0000</pubDate>
<dc:creator>sxliuchunrong</dc:creator>
<og:description>一、问题的起源 最近在做vue.js项目时，遇到了vuex状态管理action与vue.js方法互相通信、互操作的问题。场景如下图所示： 二、第一种解决方法 例如，我们在页面初始化的时候，需要从服务端</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/popgis/p/11817443.html</dc:identifier>
</item>
<item>
<title>什么是浮点型？什么是单精度浮点数（float）以及双精度浮点数（double）？ - 宜春</title>
<link>http://www.cnblogs.com/yichunguo/p/11817440.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yichunguo/p/11817440.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;作为一名java学习者，怎能不懂这些java基础中的基础呢？本文就带各位温顾温顾java浮点型、单精度浮点数、双精度浮点数。&lt;/p&gt;
&lt;h2 id=&quot;浮点型&quot;&gt;浮点型&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;首先明确java中浮点型数据类型主要有：单精度&lt;code&gt;float&lt;/code&gt;、双精度&lt;code&gt;double&lt;/code&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;至于&lt;strong&gt;浮点型&lt;/strong&gt;就是跟&lt;code&gt;int&lt;/code&gt; ，&lt;code&gt;string&lt;/code&gt;类型差不多。都是&lt;strong&gt;数据类型&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;浮点型浮点型别给我整些花里胡哨的定义，&lt;span&gt;浮点型简单来说就是表示带有小数的数据&lt;/span&gt;，而恰恰小数点可以在相应的二进制的不同位置浮动，可能是这样就被定义成浮点型了。~不得不佩服这文化程度，定义个数据名称都这么有深度~&lt;/p&gt;
&lt;p&gt;浮点型常量 Java的实常数有两种表示形式：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;1、 十进制数形式：由数字和小数点组成,且必须有小数点,如&lt;code&gt;0.123&lt;/code&gt; , &lt;code&gt;123.0&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;2、科学计数法形式：如:&lt;code&gt;123e3&lt;/code&gt;或&lt;code&gt;123E3&lt;/code&gt;,其中&lt;code&gt;e&lt;/code&gt;或&lt;code&gt;E&lt;/code&gt;之前必须有数字,且e或E后面的指数必须为&lt;strong&gt;整数&lt;/strong&gt;（当然也包括负整数）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;科学计数法中的e&quot;&gt;科学计数法中的E&lt;/h2&gt;
&lt;p&gt;了解浮点型常量 Java的实常数有两种表示形式之后，很有必要给各位科普科普下科学计数法中&lt;code&gt;E&lt;/code&gt;的面貌了~&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;code&gt;E&lt;/code&gt;是指数的意思，&lt;code&gt;E&lt;/code&gt;代表的英文是&lt;code&gt;exponent&lt;/code&gt;&lt;strong&gt;，&lt;code&gt;E&lt;/code&gt;表示10的多少次方的意思&lt;/strong&gt;。&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;比如&lt;code&gt;7.823E5 = 782300&lt;/code&gt; 这里&lt;code&gt;E5&lt;/code&gt;表示10的5次方，再比如&lt;code&gt;54.3E-2 = 0.543&lt;/code&gt;这里&lt;code&gt;E-2&lt;/code&gt;表示10的-2次方&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;再补充一点（&lt;strong&gt;针对负次方理解&lt;/strong&gt;）&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span&gt;一个数的负几次方就是这个数的几次方的倒数&lt;/span&gt;。&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;比如： 2的负1次方＝2的1次方分之一＝&lt;code&gt;1/2&lt;/code&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;比如： 3的负2次方＝3的2次方分之一＝&lt;code&gt;1/9&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;单精度浮点数float&quot;&gt;单精度浮点数（float）&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;单精度浮点数在机内占&lt;code&gt;4&lt;/code&gt;个字节、有效数字&lt;code&gt;8&lt;/code&gt;位、表示范围：&lt;code&gt;-3.40E+38 ~ +3.40E+38&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在Java语言当中，所有的浮点型字面值 ~【V8提示】浮点型简单来说就是表示带有小数的数据~ 默认当做&lt;code&gt;double&lt;/code&gt;类型来处理，要想该字面值当做&lt;code&gt;float&lt;/code&gt;类型来处理，需要在字面值后面添加&lt;code&gt;F/f&lt;/code&gt;,或者强制装换为&lt;code&gt;float&lt;/code&gt;。具体如下代码：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt; public static void main(String[] args) {
   //3.10是浮点型，浮点型字面值默认当做double类型来处理，直接编译通过；
      double d=3.10;
   //3.10是浮点型，则必须加 F或者f，若没加，直接编译不通过，会报错“损失精度”   
      float f=3.10;  //编译出错会报错“损失精度”
     //   解决办法：
     //   第一种方式：强制类型转换
        float f1=（float）5.1；
     //   第二种方式：没有类型转换；
        folat f2=5.1f;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再来看看下面的测试，结果肯定十之八九会在意料之外，哈哈~&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt; public static void main(String[] args) {
        float a = 12345678.90123456789f;
        double b=0.12345678901234567890;
        float c=0.12345678901234567890f;
     
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        
        打印结果
        a = 1.2345679E7
        b = 0.12345678901234568
        c = 0.12345679
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;双精度浮点数double&quot;&gt;双精度浮点数（double）&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;双精度浮点数在机内占&lt;code&gt;8&lt;/code&gt;个字节、有效数字&lt;code&gt;16&lt;/code&gt;位、表示范围：&lt;code&gt;-1.79E+308 ~ +1.79E+308&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;double&lt;/code&gt;的精度太低，不适合用于做财务软件，财务涉及到钱的问题，要求精度较高，所以在java中有一个基础的类库名为：&lt;code&gt;java.math.BigDecimal&lt;/code&gt;，但这个&lt;code&gt;BigDecimal&lt;/code&gt;&lt;span&gt;类型是&lt;strong&gt;引用类型&lt;/strong&gt;不是基础类型&lt;/span&gt;，切记！！！&lt;/p&gt;
&lt;p&gt;在讲单精度浮点数（&lt;code&gt;float&lt;/code&gt;）的时候，差不多顺道把&lt;code&gt;double&lt;/code&gt;之间的区别讲了哈哈，所以最后给张很经典的图片“敷衍敷衍”下，哈哈哈 ~哎哎哎..别打...别打...别打脸QAQ~&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191003213949742.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;想深入了解浮点数在计算机中存储方式可以参考这篇文章&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/jillzhang/archive/2007/06/24/793901.html&quot;&gt;浮点数在计算机中存储方式&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 08 Nov 2019 00:03:00 +0000</pubDate>
<dc:creator>宜春</dc:creator>
<og:description>前言 作为一名java学习者，怎能不懂这些java基础中的基础呢？本文就带各位温顾温顾java浮点型、单精度浮点数、双精度浮点数。 浮点型 首先明确java中浮点型数据类型主要有：单精度 、双精度 至</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yichunguo/p/11817440.html</dc:identifier>
</item>
<item>
<title>[springboot 开发单体web shop] 4. Swagger生成Javadoc - IsaacZhang</title>
<link>http://www.cnblogs.com/zhangpan1244/p/11817436.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangpan1244/p/11817436.html</guid>
<description>&lt;hr/&gt;&lt;p&gt;在日常的工作中，特别是现在前后端分离模式之下，接口的提供造成了我们前后端开发人员的沟通&lt;br/&gt;成本大量提升，因为沟通不到位，不及时而造成的[撕币]事件都成了日常工作。特别是很多的开发人员&lt;br/&gt;不擅长沟通，造成的结果就会让自己特别的痛苦，也让合作人员&lt;code&gt;恨&lt;/code&gt;的牙根痒痒。&lt;br/&gt;为了结束战火蔓延，同时为了提升开发人员的满意度，&lt;code&gt;Swagger&lt;/code&gt;应运而生。&lt;/p&gt;
&lt;h2 id=&quot;什么是swagger&quot;&gt;什么是Swagger&lt;/h2&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;Swagger for Everyone&lt;br/&gt;Simplify API development for users, teams, and enterprises with the Swagger open source and professional toolset.&lt;br/&gt;Swagger open source and pro tools have helped millions of API developers, teams, and organizations deliver great APIs.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简言之就是指使用工具集简化用户、团队和企业的API开发。&lt;/p&gt;
&lt;h2 id=&quot;集成swagger&quot;&gt;集成Swagger&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;系统中我选择使用的是&lt;code&gt;swagger-spring-boot-starter&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;该项目主要利用Spring Boot的自动化配置特性来实现快速的将swagger2引入spring boot应用来生成API文档，简化原生使用swagger2的整合代码。&lt;br/&gt;看得出来，我在教大家使用的都是在偷懒哦，这可不是什么好现象。。。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;添加依赖&quot;&gt;添加依赖&lt;/h3&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;        &amp;lt;!--整合Swagger2--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.spring4all&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;swagger-spring-boot-starter&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.9.0.RELEASE&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;点击版本号进入&lt;code&gt;swagger-spring-boot-starter/1.9.0.RELEASE/swagger-spring-boot-starter-1.9.0.RELEASE.pom&lt;/code&gt;，可以看到它依赖的版本信息。&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;    &amp;lt;properties&amp;gt;
        &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt;
        &amp;lt;version.java&amp;gt;1.8&amp;lt;/version.java&amp;gt;
        &amp;lt;version.swagger&amp;gt;2.9.2&amp;lt;/version.swagger&amp;gt;
        &amp;lt;version.spring-boot&amp;gt;1.5.10.RELEASE&amp;lt;/version.spring-boot&amp;gt;
        &amp;lt;version.lombok&amp;gt;1.18.6&amp;lt;/version.lombok&amp;gt;
    &amp;lt;/properties&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;启用功能&quot;&gt;启用功能&lt;/h3&gt;
&lt;p&gt;在我们的启动类&lt;code&gt;ApiApplication&lt;/code&gt;上增加@EnableSwagger2Doc注解&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@SpringBootApplication
@MapperScan(basePackages = &quot;com.liferunner.mapper&quot;)
@ComponentScan(basePackages = {&quot;com.liferunner&quot;, &quot;org.n3r.idworker&quot;})
@EnableSwagger2Doc //启动Swagger
public class ApiApplication {

    public static void main(String[] args) {
        new SpringApplicationBuilder()
                .sources(ApiApplication.class)
                .run(args);
    }

    @Autowired
    private CORSConfig corsConfig;

    /**
     * 注册跨域配置信息
     *
     * @return {@link CorsFilter}
     */
    @Bean
    public CorsFilter corsFilter() {
        val corsConfiguration = new CorsConfiguration();
        corsConfiguration.addAllowedOrigin(this.corsConfig.getAllowOrigin());
        corsConfiguration.addAllowedMethod(this.corsConfig.getAllowedMethod());
        corsConfiguration.addAllowedHeader(this.corsConfig.getAllowedHeader());
        corsConfiguration.setAllowCredentials(this.corsConfig.getAllowCredentials());

        val urlBasedCorsConfigurationSource = new UrlBasedCorsConfigurationSource();
        urlBasedCorsConfigurationSource.registerCorsConfiguration(&quot;/**&quot;, corsConfiguration);

        return new CorsFilter(urlBasedCorsConfigurationSource);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;配置基础信息&quot;&gt;配置基础信息&lt;/h3&gt;
&lt;p&gt;可以通过&lt;code&gt;properties&lt;/code&gt;文件和&lt;code&gt;yml/yaml&lt;/code&gt;文件配置。&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;# 配置swagger2
swagger:
  enabled: true #是否启用swagger，默认：true
  title: 实战电商api平台
  description: provide 电商 API
  version: 1.0.0.RC
  license: Apache License, Version 2.0
  license-url: https://www.apache.org/licenses/LICENSE-2.0.html
  terms-of-service-url: http://www.life-runner.com
  contact:
    email: magicianisaac@gmail.com
    name: Isaac-Zhang
    url: http://www.life-runner.com
  base-package: com.liferunner
  base-path: /**&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;阶段效果一&quot;&gt;阶段效果一&lt;/h3&gt;
&lt;p&gt;运行我们的api项目，在浏览器输入：&lt;code&gt;http://localhost:8088/swagger-ui.html&lt;/code&gt;,可以看到如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/48397/201911/48397-20191108075842977-1998519974.png&quot; alt=&quot;阶段效果1&quot;/&gt;&lt;br/&gt;可以看到，我们在&lt;code&gt;yml&lt;/code&gt;文件中配置的信息，展示在了页面的顶部，点击&lt;code&gt;用户管理&lt;/code&gt;:&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/48397/201911/48397-20191108075843506-669988036.png&quot; alt=&quot;用户管理&quot;/&gt;&lt;br/&gt;从上图可以看出，我们的&lt;code&gt;/users/create&lt;/code&gt;接口展出出来，并且要传入的参数，请求类型等等信息都已经展示在上图中。&lt;br/&gt;但是，要传递的参数是什么意思，都是我们的字段信息，我们要如何让它更友好的展示给调用方呢？让我们继续&lt;br/&gt;完善我们的文档信息：&lt;/p&gt;
&lt;h3 id=&quot;完善说明信息&quot;&gt;完善说明信息&lt;/h3&gt;
&lt;p&gt;在我们创建用户的时候，需要传递一个&lt;code&gt;com.liferunner.dto.UserRequestDTO&lt;/code&gt;对象，这个对象的属性如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RestController
@RequestMapping(value = &quot;/users&quot;)
@Slf4j
@Api(tags = &quot;用户管理&quot;)
public class UserController {

    @Autowired
    private IUserService userService;

    @ApiOperation(value = &quot;用户详情&quot;, notes = &quot;查询用户&quot;)
    @ApiIgnore
    @GetMapping(&quot;/get/{id}&quot;)
    //@GetMapping(&quot;/{id}&quot;) 如果这里设置位这样，每次请求swagger都会进到这里，是一个bug
    public String getUser(@PathVariable Integer id) {
        return &quot;hello, life.&quot;;
    }

    @ApiOperation(value = &quot;创建用户&quot;, notes = &quot;用户注册接口&quot;)
    @PostMapping(&quot;/create&quot;)
    public JsonResponse createUser(@RequestBody UserRequestDTO userRequestDTO) {
        //...
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Data
@AllArgsConstructor
@NoArgsConstructor
@Builder
@ApiModel(value = &quot;创建用户DTO&quot;, description = &quot;用户注册需要的参数对象&quot;)
public class UserRequestDTO {
    @ApiModelProperty(value = &quot;用户名&quot;, notes = &quot;username&quot;, example = &quot;isaaczhang&quot;, required = true)
    private String username;
    @ApiModelProperty(value = &quot;注册密码&quot;, notes = &quot;password&quot;, example = &quot;12345678&quot;, required = true)
    private String password;
    @ApiModelProperty(value = &quot;确认密码&quot;, notes = &quot;confimPassword&quot;, example = &quot;12345678&quot;, required = true)
    private String confirmPassword;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，我们有很多通过&lt;code&gt;@Apixxx&lt;/code&gt;开头的注解说明，这个就是Swagger提供给我们用以说明字段和文档说明的注解。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;@Api&lt;/code&gt; 表示对外提供API&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@ApiIgnore&lt;/code&gt; 表示不对外展示，可用于类和方法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@ApiOperation&lt;/code&gt; 就是指的某一个API下面的CURD动作&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@ApiResponses&lt;/code&gt; 描述操作可能出现的异常情况&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@ApiParam&lt;/code&gt; 描述传递的单参数信息&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@ApiModel&lt;/code&gt; 用来描述java object的属性说明&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@ApiModelProperty&lt;/code&gt; 描述object 字段说明&lt;br/&gt;所有的使用，都可以进入到相关的注解的具体class去查看所有的属性信息，都比较简单，这里就不做具体描述了。想要查看更多的属性说明，&lt;br/&gt;大家可以进入：&lt;a href=&quot;http://docs.swagger.io/swagger-core/apidocs/index.html&quot;&gt;Swagger属性说明传送门&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;配置完之后，重启应用，刷新UI页面：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/48397/201911/48397-20191108075844006-240559586.png&quot; alt=&quot;阶段效果二&quot;/&gt;&lt;br/&gt;上图中红框圈定的都是我们重新配置的说明信息，足够简单明了吧～&lt;/p&gt;
&lt;h2 id=&quot;集成更好用的ui界面&quot;&gt;集成更好用的UI界面&lt;/h2&gt;
&lt;p&gt;针对于API说明来说，我们上述的信息已经足够优秀了，可是做技术，我们应该追求的是更加极致的地步，上述的UI界面在我们提供大批量&lt;br/&gt;用户接口的时候，友好型就有那么一丢丢的欠缺了，现在给大家再介绍一款更好用的开源&lt;code&gt;Swagger UI&lt;/code&gt;，有请&lt;a href=&quot;https://github.com/xiaoymin/swagger-bootstrap-ui&quot;&gt;swagger-bootstrap-ui&lt;/a&gt;。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/48397/201911/48397-20191108075844612-639930582.png&quot; alt=&quot;UI2&quot;/&gt;&lt;br/&gt;我们从上图可以看到，这个UI的Star数目已经超过1.1K了，这就证明它已经很优秀了，我们接下来解开它的庐山真面目吧。&lt;/p&gt;
&lt;h3 id=&quot;集成依赖&quot;&gt;集成依赖&lt;/h3&gt;
&lt;p&gt;只需要在我们的&lt;code&gt;expensive-shop\pom.xml&lt;/code&gt;中加入以下依赖代码：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;        &amp;lt;!--一种新的swagger ui--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.github.xiaoymin&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;swagger-bootstrap-ui&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.6&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;预览效果&quot;&gt;预览效果&lt;/h3&gt;
&lt;p&gt;添加完依赖后，只需要重启我们的应用，然后访问&lt;code&gt;http://localhost:8088/doc.html&lt;/code&gt;,效果如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/48397/201911/48397-20191108075845055-395446120.png&quot; alt=&quot;阶段效果3&quot;/&gt;&lt;br/&gt;点击创建用户：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/48397/201911/48397-20191108075845661-946427685.png&quot; alt=&quot;阶段效果4&quot;/&gt;&lt;br/&gt;上述的效果是不是更符合我们的审美了～&lt;br/&gt;到此为止，我们使用&lt;code&gt;Swagger&lt;/code&gt;来动态生成API的效果已经全部演示完了，但是如果某一天我们要和一个不能连接查看我们网站的客户进行集成的时候，我们怎么办呢？&lt;br/&gt;还是要手写一份文档给他们吗？ 那我们不就一样很痛苦吗！！！&lt;br/&gt;作为程序员，我们是绝对不能允许这种情况发生的！&lt;br/&gt;那就让我们继续看下去。&lt;/p&gt;
&lt;h2 id=&quot;生成离线文档&quot;&gt;生成离线文档&lt;/h2&gt;
&lt;p&gt;为了不让我们做痛苦的工作，我们既然已经在代码中添加了那么多的说明信息，是否有一种方式可以帮助我们来生成一份离线的文档呢？答案是肯定的。&lt;/p&gt;
&lt;h3 id=&quot;开源项目swagger2markup&quot;&gt;开源项目swagger2markup&lt;/h3&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;A Swagger to AsciiDoc or Markdown converter to simplify the generation of an up-to-date RESTful API documentation by combining documentation that’s been hand-written with auto-generated API documentation.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Swagger2Markup/swagger2markup&quot;&gt;源码传送门&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://swagger2markup.github.io/swagger2markup/1.3.3/&quot;&gt;documents传送门&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Swagger2Markup它主要是用来将Swagger自动生成的文档转换成几种流行的格式以便离线使用&lt;br/&gt;格式：AsciiDoc、HTML、Markdown、Confluence&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;使用maven插件生成asciidoc文档&quot;&gt;使用MAVEN插件生成AsciiDoc文档&lt;/h3&gt;
&lt;p&gt;在&lt;code&gt;mscx-shop-api\pom.xml&lt;/code&gt;中加入以下依赖代码：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;build&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;!--生成 AsciiDoc 文档(swagger2markup)--&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;io.github.swagger2markup&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;swagger2markup-maven-plugin&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;1.3.3&amp;lt;/version&amp;gt;
                &amp;lt;configuration&amp;gt;
                    &amp;lt;!--这里是要启动我们的项目，然后抓取api-docs的返回结果--&amp;gt;
                    &amp;lt;swaggerInput&amp;gt;http://localhost:8088/v2/api-docs&amp;lt;/swaggerInput&amp;gt;
                    &amp;lt;outputDir&amp;gt;src/docs/asciidoc/generated-doc&amp;lt;/outputDir&amp;gt;
                    &amp;lt;config&amp;gt;
                        &amp;lt;swagger2markup.markupLanguage&amp;gt;ASCIIDOC&amp;lt;/swagger2markup.markupLanguage&amp;gt;
                    &amp;lt;/config&amp;gt;
                &amp;lt;/configuration&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;&amp;lt;swaggerInput&amp;gt;http://localhost:8088/v2/api-docs&amp;lt;/swaggerInput&amp;gt;&lt;/code&gt; 是为了获取我们的&lt;code&gt;api JSON&lt;/code&gt;数据，如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/48397/201911/48397-20191108075846215-1106369248.png&quot; alt=&quot;API-JSON&quot;/&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;outputDir&amp;gt;src/docs/asciidoc/generated-doc&amp;lt;/outputDir&amp;gt;&lt;/code&gt; 设置我们要生成的目录地址&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;执行命令:&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;expensive-shop\mscx-shop-api&amp;gt;mvn swagger2markup:convertSwagger2markup&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;要是大家觉得命令太长了，也可以点击&lt;code&gt;IDEA =&amp;gt; Maven =&amp;gt; mscx-shop-api =&amp;gt; Plugins =&amp;gt; swagger2markup =&amp;gt; swagger2markup:convertSwagger2markup&lt;/code&gt;就可以执行啦，如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/48397/201911/48397-20191108075846622-1343019917.png&quot; alt=&quot;swagger2markup&quot;/&gt;&lt;br/&gt;生成结果如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/48397/201911/48397-20191108075847039-403008193.png&quot; alt=&quot;asciidoc&quot;/&gt;&lt;br/&gt;adoc文件生成好了，那么我们使用它来生成html吧&lt;/p&gt;
&lt;h3 id=&quot;使用maven插件生成html&quot;&gt;使用MAVEN插件生成HTML&lt;/h3&gt;
&lt;p&gt;在&lt;code&gt;mscx-shop-api\pom.xml&lt;/code&gt;中加入以下依赖代码：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;            &amp;lt;!--生成 HTML 文档--&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.asciidoctor&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;asciidoctor-maven-plugin&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;1.5.6&amp;lt;/version&amp;gt;
                &amp;lt;configuration&amp;gt;
                    &amp;lt;sourceDirectory&amp;gt;src/docs/asciidoc/generated-doc&amp;lt;/sourceDirectory&amp;gt;
                    &amp;lt;outputDirectory&amp;gt;src/docs/asciidoc/html&amp;lt;/outputDirectory&amp;gt;
                    &amp;lt;backend&amp;gt;html&amp;lt;/backend&amp;gt;
                    &amp;lt;sourceHighlighter&amp;gt;coderay&amp;lt;/sourceHighlighter&amp;gt;
                    &amp;lt;attributes&amp;gt;
                        &amp;lt;toc&amp;gt;left&amp;lt;/toc&amp;gt;
                    &amp;lt;/attributes&amp;gt;
                &amp;lt;/configuration&amp;gt;
            &amp;lt;/plugin&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;&amp;lt;sourceDirectory&amp;gt;src/docs/asciidoc/generated-doc&amp;lt;/sourceDirectory&amp;gt;&lt;/code&gt; 源文件目录指定为我们上一节生成的adoc&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;outputDirectory&amp;gt;src/docs/asciidoc/html&amp;lt;/outputDirectory&amp;gt;&lt;/code&gt; 指定输出目录&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;执行生成命令：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;\expensive-shop\mscx-shop-api&amp;gt;mvn asciidoctor:process-asciidoc&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;生成结果如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/48397/201911/48397-20191108075847374-1108331532.png&quot; alt=&quot;result html&quot;/&gt;&lt;br/&gt;打开&lt;code&gt;overview.html&lt;/code&gt;,如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/48397/201911/48397-20191108075847937-1944003336.png&quot; alt=&quot;html&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，我们的文档就已经全部生成了！&lt;/p&gt;
&lt;h2 id=&quot;下节预告&quot;&gt;下节预告&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;下一节我们将继续开发我们的用户登录以及首页信息的部分展示，在过程中使用到的任何开发组件，我都会通过专门的一节来进行介绍的，兄弟们末慌！&lt;/p&gt;
&lt;p&gt;gogogo！&lt;/p&gt;
</description>
<pubDate>Thu, 07 Nov 2019 23:59:00 +0000</pubDate>
<dc:creator>IsaacZhang</dc:creator>
<og:description>Swagger生成JavaDoc 在日常的工作中，特别是现在前后端分离模式之下，接口的提供造成了我们前后端开发人员的沟通 成本大量提升，因为沟通不到位，不及时而造成的[撕币]事件都成了日常工作。特别是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhangpan1244/p/11817436.html</dc:identifier>
</item>
<item>
<title>对比讲解lambda表达式与传统接口函数实现方式 - 字母哥博客</title>
<link>http://www.cnblogs.com/zimug/p/11817433.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zimug/p/11817433.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1815316/201911/1815316-20191108075526811-1303861599.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在本号之前写过的一些文章中，笔者使用了lambda表达式语法，一些读者反映说代码看不懂。本以为java 13都已经出了，java 8中最重要特性lambda表达式大家应该都掌握了，实际上还是存在大量的程序员没有使用java8，还有的使用了java8也不会使用lambda表达式。所以，写这篇文章还是有必要的，&lt;strong&gt;如果您觉得我的文章对您有帮助，期待您的关注&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;Lambda表达式是Java 8最流行最常用的功能特性。它将函数式编程概念引入Java，函数式编程的好处在于可以帮助我们节省大量的代码，非常方便易用，能够大幅度的提高我们的编码效率。在本文中，我们将介绍lambda表达式是什么，并将传统的java代码写法转换为lambda表达式写法，大家可以通过示例了解lambda表达式都对传统代码做了哪些简化。&lt;/p&gt;
&lt;h2 id=&quot;一接口定义&quot;&gt;&lt;strong&gt;一、接口定义&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;首先，我们要明白lambda表达式在表达什么？答案就是lambda表达式表达接口函数的实现，所以我们有必要做一下准备工作。在传统的开发方式下，我们不习惯将代码块传递给函数。我们所有的行为定义代码都封装在方法体内，并通过对象引用执行，就像使用下面的代码一样：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
public class LambdaDemo {
    //函数定义
    public void printSomething(String something) {
        System.out.println(something);
    }
    //通过创建对象调用函数
    public static void main(String[] args) {
        LambdaDemo demo = new LambdaDemo();
        String something = &quot;I am learning Lambda&quot;;
        demo.printSomething(something);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;大家应该对上面的代码的开发方式不感到陌生，这是经典OOP的实现样式。下面我们对上面的代码做一个修改，创建一个功能接口，并对该接口定义抽象方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
public class LambdaDemo {
    //抽象功能接口
    interface Printer {
        void print(String val);
    }
    //通过参数传递功能接口
    public void printSomething(String something, Printer printer) {
        printer.print(something);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;二传统的接口函数实现方式&quot;&gt;二、传统的接口函数实现方式&lt;/h2&gt;
&lt;p&gt;在上述实现中，Printer接口负责打印行为，可以是控制台打印，也可以是其他的打印行为。方法&lt;em&gt;printSomething&lt;/em&gt;不再定义行为，而是执行&lt;em&gt;Printer&lt;/em&gt;定义的行为，这样的设计更加灵活。代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
public static void main(String[] args) {
    LambdaDemo demo = new LambdaDemo();
    String something = &quot;I am using a Functional interface&quot;;
    //实现Printer接口
    Printer printer = new Printer() {
        @Override
        public void print(String val) {
            //控制台打印
            System.out.println(val);
        }
    };
    demo.printSomething(something, printer);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至此我们都尚未使用lambda表达式。我们仅创建了Printer接口的具体实现，并将其传递给&lt;em&gt;printSomething&lt;/em&gt;方法。&lt;/p&gt;
&lt;h2 id=&quot;三lambda表示式实现方式&quot;&gt;三、lambda表示式实现方式&lt;/h2&gt;
&lt;p&gt;关于lambda表达式概念后文再说，我们先来学习一下lambda表达式的语法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;（param1，param2，param3 ...，paramN）-  &amp;gt; {   //代码块；  }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;首先我们知道lambda表达式，表达的是接口函数&lt;/li&gt;
&lt;li&gt;箭头左侧是函数的逗号分隔的形式参数列表&lt;/li&gt;
&lt;li&gt;箭头右侧是函数体代码&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;现在，我们使用lambda表达式重构一下第一小节中的代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
public static void main(String[] args) {
    LambdaDemo demo = new LambdaDemo();
    String something = &quot;I am learning Lambda&quot;;
    //实现Printer接口（请关注下面这行lambda表达式代码）
    Printer printer = (String toPrint)-&amp;gt;{System.out.println(toPrint);};
    //调用接口打印
    demo.printSomething(something, printer);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;lambda表达式使我们代码更简洁。实际上使用lambda表达式在性能和多核处理还有更多的好处，但是只有在理解java8 Streams API之后它们才有意义，因此不在本文讨论范围之内（本号之前的文章都有介绍）。&lt;/p&gt;
&lt;p&gt;对比传统java代码的实现方式，代码量是不是减少了很多？但这仍然不是最简的实现方式，我们一步一步来。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
Printer printer = (String toPrint)-&amp;gt;{System.out.println(toPrint);};
//简化：去掉参数类型
Printer printer = (toPrint)-&amp;gt;{System.out.println(toPrint);};
//简化：去掉参数括号
Printer printer = toPrint-&amp;gt;{System.out.println(toPrint);};
//简化：去掉函数体花括号
Printer printer = toPrint-&amp;gt;System.out.println(toPrint);&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;即使没有在箭头的左侧指定参数的类型，编译器也会从接口方法的形式参数中推断出其类型&lt;/li&gt;
&lt;li&gt;当只有一个参数的时候，我们完全可以省略参数的括号&lt;/li&gt;
&lt;li&gt;当函数体只有一行的时候，我们完全可以省略函数体花括号&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果我们的接口方法定义不带任何参数，则可以用空括号替换：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;（）-&amp;gt;  System.out.println(&quot;anything you wan to print&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么，我们最终通过lambda表达式，简化完成的代码是什么样的呢？庐山真面目：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
public static void main(String[] args) {
    LambdaDemo demo = new LambdaDemo();
    String something=&quot;I am Lambda&quot;;
    //关注下面的这行代码
    demo.printSomething(something, toPrint -&amp;gt; System.out.println(toPrint));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们使用lambda表达式内联为函数调用参数，将最初main方法的9行代码下降到只有3行。但笔者要说，这仍然不是lambda表达式可以完成的最终极代码简化方式，当你学习了java8 Stream API结合lambda表达式使用，你会发现你的编码效率将大幅度提高！&lt;/p&gt;
&lt;h2 id=&quot;结论&quot;&gt;&lt;strong&gt;结论&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;lambda表达式表达的是接口函数，箭头左侧是函数参数，箭头右侧是函数体。函数的参数类型和返回值类型都可以省略，程序会根据接口定义的上下文自动确定数据类型。&lt;/p&gt;
&lt;p&gt;在这篇文章中，我们对Java中的Lambda表达式进行了详尽的介绍，并了解了如何使用它们来提高接口实现效率和质量。请关注本号更多有关内容，Stream API与Collections框架一起使用时为Lambda提供了更多优势。&lt;/p&gt;
&lt;h2 id=&quot;期待您的关注&quot;&gt;期待您的关注&lt;/h2&gt;
</description>
<pubDate>Thu, 07 Nov 2019 23:55:00 +0000</pubDate>
<dc:creator>字母哥博客</dc:creator>
<og:description>在本号之前写过的一些文章中，笔者使用了lambda表达式语法，一些读者反映说代码看不懂。本以为java 13都已经出了，java 8中最重要特性lambda表达式大家应该都掌握了，实际上还是存在大量的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zimug/p/11817433.html</dc:identifier>
</item>
<item>
<title>数据库存数据时，逻辑上防重了为啥还会出现重复记录？ - kevinbai_cn</title>
<link>http://www.cnblogs.com/kevinbai/p/11817150.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kevinbai/p/11817150.html</guid>
<description>&lt;p&gt;在很多异常情况下，比如高并发、网络糟糕的时候，数据库里偶尔会出现重复的记录。&lt;/p&gt;
&lt;p&gt;假如现在有一张书籍表，结构类似这样&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;+----+--------------+
| id | name         |
+----+--------------+
|  1 | 世界简史     |
+----+--------------+&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在异常情况下，可能会出现下面这样的记录&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;+----+--------------+
| id | name         |
+----+--------------+
|  1 | 世界简史     |
|  2 | 人类简史     |
|  3 | 人类简史     |
+----+--------------+&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是，想了想，自己在处理相关数据的时候也加了判重的相关逻辑，比如，新增时当图书 name 相同时，会提示图书重复而返回。&lt;/p&gt;
&lt;p&gt;初次遇到这个情况的时候，感觉有点摸不着头脑，后面想了想，还是理清了，其实这和数据库的事务隔离级别有一定关系。&lt;/p&gt;
&lt;p&gt;先简单说下数据库事务的 4 个隔离级别，然后重现下上述问题，最后说说解决办法。&lt;/p&gt;

&lt;h2 id=&quot;未提交读&quot;&gt;1.1 未提交读&lt;/h2&gt;
&lt;p&gt;顾名思义，当事务隔离级别处于这个设置的时候，不同事务能读取其它事务中未提交的数据。&lt;/p&gt;
&lt;p&gt;便于说明，我开了两个客户端（A 以及 B），并设置各自的隔离级别为未提交读。（并没有全局设置）&lt;/p&gt;
&lt;p&gt;设置隔离级别命令&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SET [SESSION | GLOBAL] TRANSACTION ISOLATION LEVEL {READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;好了，开始。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Client A&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
Query OK, 0 rows affected (0.00 sec)

mysql&amp;gt; SELECT @@session.tx_isolation;
+------------------------+
| @@session.tx_isolation |
+------------------------+
| READ-UNCOMMITTED       |
+------------------------+
1 row in set (0.00 sec)

mysql&amp;gt; start transaction;
Query OK, 0 rows affected (0.01 sec)

mysql&amp;gt; select * from books;
+----+--------------+
| id | name         |
+----+--------------+
|  1 | 世界简史     |
+----+--------------+
1 row in set (0.00 sec)

mysql&amp;gt; insert into books(name) values('人类简史');
Query OK, 1 row affected (0.01 sec)

mysql&amp;gt; select * from books;
+----+--------------+
| id | name         |
+----+--------------+
|  1 | 世界简史     |
|  4 | 人类简史     |
+----+--------------+
2 rows in set (0.00 sec)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当 A 中的事务没有关闭的时候，我们去 B 中看下数据&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Client B&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
Query OK, 0 rows affected (0.00 sec)

mysql&amp;gt; SELECT @@session.tx_isolation;
+------------------------+
| @@session.tx_isolation |
+------------------------+
| READ-UNCOMMITTED       |
+------------------------+
1 row in set (0.00 sec)

mysql&amp;gt; start transaction;
Query OK, 0 rows affected (0.00 sec)

mysql&amp;gt; select * from books;
+----+--------------+
| id | name         |
+----+--------------+
|  1 | 世界简史     |
|  4 | 人类简史     |
+----+--------------+
2 rows in set (0.00 sec)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;B 中可以读取 A 未提交的数据，所谓未提交读就是这样。&lt;/p&gt;
&lt;p&gt;最后，记得把各个事务提交。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Client A &amp;amp; Client B&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; commit;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;提交读&quot;&gt;1.2 提交读&lt;/h2&gt;
&lt;p&gt;不能事务可以读取其它事务中已经提交的数据。&lt;/p&gt;
&lt;p&gt;篇幅问题，这里我就不贴出设置隔离级别的语句，测试某个隔离级别的时候，默认已经设置好该级别。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Client A&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; start transaction;
Query OK, 0 rows affected (0.00 sec)

mysql&amp;gt; select * from books;
+----+--------------+
| id | name         |
+----+--------------+
|  1 | 世界简史     |
+----+--------------+
1 row in set (0.00 sec)

mysql&amp;gt; insert into books(name) values('人类简史');
Query OK, 1 row affected (0.00 sec)

mysql&amp;gt; select * from books;
+----+--------------+
| id | name         |
+----+--------------+
|  1 | 世界简史     |
|  5 | 人类简史     |
+----+--------------+
2 rows in set (0.00 sec)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;A 没提交，在 B 里面去看下数据&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Client B&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; start transaction;
Query OK, 0 rows affected (0.00 sec)

mysql&amp;gt; select * from books;
+----+--------------+
| id | name         |
+----+--------------+
|  1 | 世界简史     |
+----+--------------+
1 row in set (0.00 sec)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;和预期一样，A 中未提交的数据在 B 中看不到。&lt;/p&gt;
&lt;p&gt;A 中提交事务&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Client A&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; commit;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 B 中看下&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Client B&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; select * from books;
+----+--------------+
| id | name         |
+----+--------------+
|  1 | 世界简史     |
|  5 | 人类简史     |
+----+--------------+
2 rows in set (0.00 sec)

mysql&amp;gt; commit;
Query OK, 0 rows affected (0.00 sec)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;B 中能看到 A 中提交的数据。&lt;/p&gt;
&lt;h2 id=&quot;可重复读&quot;&gt;1.3 可重复读&lt;/h2&gt;
&lt;p&gt;细心的朋友可能会发现一个问题，那就是在 B 中的同一个事务读同一个表，得到的结果却不一致，开始只有 1 条，后面有 2 条，而如果没有这个问题的话，也就是可重复读了。&lt;/p&gt;
&lt;p&gt;我们来验证下&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Client A&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; start transaction;
Query OK, 0 rows affected (0.00 sec)

mysql&amp;gt; select * from books;
+----+--------------+
| id | name         |
+----+--------------+
|  1 | 世界简史     |
+----+--------------+
1 row in set (0.00 sec)

mysql&amp;gt; insert into books(name) values('人类简史');
Query OK, 1 row affected (0.01 sec)

mysql&amp;gt; select * from books;
+----+--------------+
| id | name         |
+----+--------------+
|  1 | 世界简史     |
|  6 | 人类简史     |
+----+--------------+
2 rows in set (0.00 sec)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Client B&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; start transaction;
Query OK, 0 rows affected (0.00 sec)

mysql&amp;gt; select * from books;
+----+--------------+
| id | name         |
+----+--------------+
|  1 | 世界简史     |
+----+--------------+
1 row in set (0.00 sec)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Client A&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; commit
Query OK, 0 rows affected (0.00 sec)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Client B&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; select * from books;
+----+--------------+
| id | name         |
+----+--------------+
|  1 | 世界简史     |
+----+--------------+
1 row in set (0.00 sec)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;和预期一致。B 中事务没有受到 A 中事务的提交影响，读取的数据和事务刚开始的时候一致，books 中都只有一条数据，这就是可重复读。&lt;/p&gt;
&lt;p&gt;当然，B 在自己的事务中做修改，肯定是可见的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Client B&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; insert into books(name) value ('时间简史');
Query OK, 1 row affected (0.00 sec)

mysql&amp;gt; select * from books;
+----+--------------+
| id | name         |
+----+--------------+
|  1 | 世界简史     |
|  8 | 时间简史     |
+----+--------------+
2 rows in set (0.00 sec)

mysql&amp;gt; commit;
Query OK, 0 rows affected (0.00 sec)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;串行化&quot;&gt;1.4 串行化&lt;/h2&gt;
&lt;p&gt;这是隔离级别最严格的一级，在该级别中，不同事务中的读写会相互阻塞。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Client A&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; start transaction;
Query OK, 0 rows affected (0.00 sec)

mysql&amp;gt; select * from books;
+----+--------------+
| id | name         |
+----+--------------+
|  1 | 世界简史     |
+----+--------------+
1 row in set (0.00 sec)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当 A 未提交的时候在 B 中对同一个表进行写&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Client B&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; start transaction;
Query OK, 0 rows affected (0.00 sec)

mysql&amp;gt; select * from books;
+----+--------------+
| id | name         |
+----+--------------+
|  1 | 世界简史     |
+----+--------------+
1 row in set (0.00 sec)

mysql&amp;gt; insert into books(name) value ('人类简史');
ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于不同事务中的读写相互阻塞，所以出现了上面超时的情况。&lt;/p&gt;
&lt;p&gt;如果 A 中提交事务&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Client A&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; commit;
Query OK, 0 rows affected (0.00 sec)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么在 B 中就能正常写了&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Client B&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; insert into books(name) value ('人类简史');
Query OK, 1 row affected (0.00 sec)

mysql&amp;gt; commit;
Query OK, 0 rows affected (0.01 sec)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同理，在 A 中开启事务并向 books 中插入一条记录后不提交，B 中开启事务并对该表进行读操作，也会超时。当 A 中的事务提交后，B 中对 books 的读操作就没有问题了。&lt;/p&gt;

&lt;p&gt;由于 MySQL 的 Innodb 的默认事务隔离级别为可重复读，也就导致了判重逻辑可能会出现问题，我们来重现一下。&lt;/p&gt;
&lt;p&gt;现在，数据库的数据是这样的&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;+----+--------------+
| id | name         |
+----+--------------+
|  1 | 世界简史     |
+----+--------------+&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;后端逻辑类似这样的&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;try:
    book_name = '人类简史'
    book = get_by_name(book_name)
    if book:
        raise Exception(f'图书 {book_name} 已存在')

    # 新增操作
    # 其它操作

    db.session.commit()
    return {'success': True}
except Exception as e:
    db.session.rollback()
    return {'success': False, 'msg': f'新增图书失败 {e}'}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当两个用户输入书名「人类简史」并提交后，同时有两个线程执行这段逻辑，也就相当于上面两个客户端同时开启了事务，我们以这两个客户端来说明问题&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Client A&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; start transaction;
Query OK, 0 rows affected (0.00 sec)

mysql&amp;gt; select * from books where name = '人类简史';
Empty set (0.00 sec)

mysql&amp;gt; insert into books(name) values('人类简史');
Query OK, 1 row affected (0.00 sec)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;A 中检测图书不存在，然后插入，但是由于「其它操作」由于网络或者其它原因太费时间，导致事务提交延迟。&lt;/p&gt;
&lt;p&gt;这时在 B 中执行类似操作&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Client B&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; start transaction;
Query OK, 0 rows affected (0.00 sec)

mysql&amp;gt; select * from books where name = '人类简史';
Empty set (0.00 sec)

mysql&amp;gt; insert into books(name) values('人类简史');
Query OK, 1 row affected (0.00 sec)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于事务隔离级别是可重复读的，B 中无法读取 A 中未提交的数据，所以判重逻辑顺利通过，也插入了同一本书。（也就是说隔离级别在提交读及以上都有可能出现这个问题）&lt;/p&gt;
&lt;p&gt;最后 A 和 B 都提交后&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Client A &amp;amp; Clinet B&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; commit;
Query OK, 0 rows affected (0.01 sec)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;就出现了重复记录了&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;+----+--------------+
| id | name         |
+----+--------------+
|  1 | 世界简史     |
| 12 | 人类简史     |
| 13 | 人类简史     |
+----+--------------+&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;数据库层面&quot;&gt;3.1 数据库层面&lt;/h2&gt;
&lt;p&gt;从底层进行限制，对 name 添加唯一索引后，插入重复记录会报错，简单粗暴的解决了这个问题。&lt;/p&gt;
&lt;h2 id=&quot;代码层面&quot;&gt;3.2 代码层面&lt;/h2&gt;
&lt;p&gt;加唯一索引能解决，但是总觉得代码不够完整，其实在代码层面也可以解决这个问题。&lt;/p&gt;
&lt;p&gt;如果我们在接收请求的时候如果碰到关键参数相同的请求，我们可以直接拒绝，返回类似「操作进行中」的响应，这样也就从源头上解决了这个问题。&lt;/p&gt;
&lt;p&gt;实现上面的思路也很简单，借助 redis 的 setnx 即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;book_name = request.form.get('book_name', '')
if not book_name:
    reutrn json.dumps({'success': False, 'msg': '请填写书名'})

redis_key = f'add_book_{book_name}'
set_res = redis_client.setnx(redis_key, 1)
if not set_res:
    reutrn json.dumps({'success': False, 'msg': '操作进行中'})

add_res = add_book(book_name)  # 添加操作

redis_client.delete(redis_key)
return json.dumps(add_res)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果类似场景比较多，可以考虑把 redis 的操作封装成一个装饰器，让代码能复用起来，这里不再赘述。&lt;/p&gt;

&lt;p&gt;由于数据库隔离级别的原因，一些数据就算是逻辑上进行防重了，也有可能出现重复记录。解决这个问题，可以在数据库层面加唯一索引解决，也可以在代码层面进行解决。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原文博客：&lt;a href=&quot;http://www.kevinbai.com&quot;&gt;www.kevinbai.com&lt;/a&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;关注「小小后端」公众号，更多干货等着你喔！&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 07 Nov 2019 15:55:00 +0000</pubDate>
<dc:creator>kevinbai_cn</dc:creator>
<og:description>在很多异常情况下，比如高并发、网络糟糕的时候，数据库里偶尔会出现重复的记录。 假如现在有一张书籍表，结构类似这样 在异常情况下，可能会出现下面这样的记录 但是，想了想，自己在处理相关数据的时候也加了判</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kevinbai/p/11817150.html</dc:identifier>
</item>
<item>
<title>FPGA时序约束理解记录 - aslmer</title>
<link>http://www.cnblogs.com/aslmer/p/11746947.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/aslmer/p/11746947.html</guid>
<description>&lt;p&gt;最近整理了一下时序约束的内容，顺便发出来分享记录一下。&lt;/p&gt;
&lt;p&gt;任何硬件想要工作正常，均需满足建立和保持时间，至于这个概念不再陈述。&lt;/p&gt;
&lt;p&gt;下面将重点介绍两个概念：建立余量和保持余量。FPGA内部进行时序分析无非就是计算这两个余量，为正，则时序满足要求，否则不满足。&lt;/p&gt;
&lt;p&gt;FPGA在与外部器件打交道时，端口如果为输入则与input delay约束相关，如果最为输出则output delay,这两种约束的值究竟是什么涵义，在下文中我也会重点刨析，但是前提是需要理解图1和图2建立余量和保持余量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、建立余量&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;不考虑clk_skew,数据在regA 的发射沿（即第一个上升沿）经过Tco+Tdata则会一直保持不变，等待着接受沿采集，接收沿有关建立只需满足的建立时间即可，建立余量=T-Tco-Tdata即下图红色区所示。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/994469/201910/994469-20191027110718626-792610326.png&quot; alt=&quot;&quot; width=&quot;586&quot; height=&quot;369&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、保持余量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;蓝色是第一个数据，第一个上升沿是蓝色数据的发射沿，第二个上升沿是蓝色数据的接收沿&lt;/p&gt;
&lt;p&gt;紫色是第二个数据，第二个上升沿是紫色数据的发射沿，第三个上升沿是紫色数据接收沿（图中未画）&lt;/p&gt;
&lt;p&gt;意思是什么？第一个蓝色数据经过发射沿后延迟Tco+Tdata的时间就一直保持不变，直到紫色的数据在其发射沿来后经过Tco+Tdata时间将蓝色数据代替，蓝色数据只需要在其接收沿后停留的时间大于等于保持时间即可被正常采集，但是蓝色数据实际上能够停留多久是由Tco+Tdata决定的，因此Tco+Tdata的值决定了其在接受沿后的寿命，即Tco+Tdata&amp;gt;=Th就可以满足保持时间，保持余量=Tco+Tdata-Th,保持时间和时钟周期T无关，因为他的寿命是由Tco+Tdata决定的。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/994469/201911/994469-20191107223502461-562949420.png&quot; alt=&quot;&quot; width=&quot;504&quot; height=&quot;302&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 3、input delay 和output delay&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于input /output delay的保持余量和建立余量的计算方法和前面讲的是一样的，区别在于前面的例子中REGA和REGB均是在FPGA内部的，计算余量的所有参数FPGA自身是知道的，他自己可以完成整个计算分析，但是一旦涉及到input delay和output delay,即FPGA作为是接收端或者发送端与其他器件交互时，有些计算的参数FPGA自己知道，有的计算的参数是外部器件知道，为了完成余量的计算，那么就要通过约束把FPGA不知道的量告诉FPGA。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用input delay举例说明 见下图 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;建立余量=T-Tco-Tdata-Tsu,FPGA作为接收端Tsu，Th是知道的，但是其余两个量不知道，Tco与外部器件性能相关，可以从其数据手册中获取这个量，Tdata也许和你PCB的布线延迟等有关，为了完成计算，只需要把Tdata+Tco的最告诉fpga即可，max参数是与建立参数相关，min与保持余量相关，其最大值为 input delay max为Tco+Tdata的最大值,最小值为input delay min为Tco+Tdata的最小值。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/994469/201911/994469-20191107224926239-1830610720.png&quot; alt=&quot;&quot; width=&quot;530&quot; height=&quot;347&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;output delay见下图&lt;/span&gt;，图中红色代表FPGA自己知道的量，其余需要通过约束告知，所以约束只需补充FPGA不知道的值即可，最大值max 为Tdata+Tsu，min为Tdata-Th&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/994469/201911/994469-20191107230640281-1263948639.png&quot; alt=&quot;&quot; width=&quot;658&quot; height=&quot;413&quot;/&gt;&lt;/p&gt;
&lt;p&gt;--------------------------------------------------------------------------------------------------------------------------------------------------------------&lt;/p&gt;
&lt;p&gt;下面是我做的一些其他概念的理解记录，简单总结供自己以后查询&lt;/p&gt;
&lt;p&gt;SDR和DDR的概念：S是单沿触发，D是双沿，双沿又分中心对齐和边沿对齐，见图&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/994469/201911/994469-20191107232505604-1417559952.png&quot; alt=&quot;&quot; width=&quot;357&quot; height=&quot;353&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 下图是input delay 的DDR中心对齐，其中黑色方框框起来的是理想情况下的数据，蓝色是数据整体左偏移，红色是数据整体右偏移，来回抖动的范围，图示中XXXX则表示的数据不稳定的区域，对于上升沿，最小值就是到蓝色框dv_are的大小，最大值就是到红色框边沿T/2-dv_bfe.下降沿不再赘述。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/994469/201911/994469-20191107231230873-1811155553.png&quot; alt=&quot;&quot; width=&quot;525&quot; height=&quot;231&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于DDR边沿对齐，对上升沿来讲，黑色数据框是理想情况，红色是向右偏移，蓝色则是向左偏移，在第三个红色框那里，延迟已经等于0，再进一步左移则为负，蓝色所示。对上升沿来讲，max为skew_are,min为 负-skew_bre。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/994469/201911/994469-20191107231649243-1837411868.png&quot; alt=&quot;&quot; width=&quot;520&quot; height=&quot;301&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此篇较为粗糙，时序每研究一遍都会有不同的理解，而且每个人理解的着手点不一样，希望能够静下心来，好好沉淀，莫急躁。&lt;/p&gt;
&lt;p&gt;有问题欢迎讨论&lt;/p&gt;
&lt;p&gt;未来可期&lt;/p&gt;
&lt;p&gt; 博客原为链接：&lt;a href=&quot;https://www.cnblogs.com/aslmer/p/11746947.html&quot;&gt;https://www.cnblogs.com/aslmer/p/11746947.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 07 Nov 2019 15:42:00 +0000</pubDate>
<dc:creator>aslmer</dc:creator>
<og:description>最近整理了一下时序约束的内容，顺便发出来分享记录一下。 任何硬件想要工作正常，均需满足建立和保持时间，至于这个概念不再陈述。 下面将重点介绍两个概念：建立余量和保持余量。FPGA内部进行时序分析无非就</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/aslmer/p/11746947.html</dc:identifier>
</item>
<item>
<title>beanFactory 设计模式 Bean 生命周期的胡言乱语，哈哈 - sanri1993</title>
<link>http://www.cnblogs.com/sanri1993/p/11816411.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sanri1993/p/11816411.html</guid>
<description>&lt;h2 id=&quot;写在前面的话&quot;&gt;写在前面的话&lt;/h2&gt;
&lt;p&gt;适用读者：有一定经验的，本文不适合初学者，因为可能不能理解我在说什么&lt;/p&gt;
&lt;p&gt;文章思路：不会一开始就像别的博客文章那样，Bean 的生命周期，源码解读（给你贴一大堆的源码）。个人觉得应该由问题驱动，为什么为出现 BeanFactory ，为什么会有生命周期。&lt;/p&gt;
&lt;h2 id=&quot;正文&quot;&gt;正文&lt;/h2&gt;
&lt;p&gt;一开始我们使用 bean 都是简单bean，如 vo ，po，entity，dto，我们是这么玩的&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;XXEntity xxEntity = new XXEntity();
xxEntity.setPropA(&quot;字符串&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;后面可能出现了某个比较复杂的 bean ，它有一个对象做为属性，需要在构造时或构造后设置值(示例而已，不要较真)，如&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 构建序列化实例，这里 Serializable 是接口，使用接口的好处是在使用别的序列化时，不需要修改 jedis 类
Serializable fastJsonSerizlizable = new FastJsonSerizlizable();

// 构建目标 jedis 实例 ，需要先构建序列化对象 
Jedis jedis = new Jedis();
jedis.setSerializable(fastJsonSerizlizable);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这时来了 serviceA 类和 serviceB 类，它们都需要使用 redis，我不可能在每个类里面都去把 jedis 实例化的过程写一遍，这时有经验的同学会写一个工具类来创建 jedis ，像这样&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public BeanUtil {
    // 可以把创建序列化单拿出来，因为除了 redis 需要序列化之外，kafka 也需要序列化
    public static Serializable createSerializable(){
        return new FastJsonSerizlizable();
    }
    
    public static Jedis createJedis(){
        Jedis jedis = new Jedis();
        jedis.setSerializable(createSerializable());
        return jedis;
    }
}

// 这里我 serviceA，serviceB 都可以使用 createJedis 来直接获取 jedis 实例 ，而不需要关心创建细节，使用哪个序列化等问题&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面代码有几个问题&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;每次使用时都会创建 jedis 对象 ，而每一个 jedis 对象又会单独对一个 Serializable 对象 ，但是 fastJson 的序列化和 jedis 都只是工具类型的东西，一个实例足已。&lt;/li&gt;
&lt;li&gt;无法对 Jedis 进行配置&lt;/li&gt;
&lt;li&gt;不能让使用者去创建 BeanUtil 实例 ，改进的代码 如下&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public BeanUtil {
    // 禁用 BeanUtil 构建 
    private BeanUtil(){}
    
    // 这里我们可以使用 bean 的全路径 =&amp;gt; bean 实例来缓存 bean 
    static Map&amp;lt;String,Object&amp;gt; beansCache = new ConcurrentHashMap&amp;lt;String,Object&amp;gt;();
    
    static{
        // 初始化时，在内容缓存这些 bean 的实例，因为 jedis 依赖于 serializable ，需要需要先创建 serializable
        Serializable serializable = createSerializable();
        beansCache.put(Serializable.class.getSimpleName(),serializable);
        Jedis jedis = createJedis();
        beansCache.put(jedis.class.getSimpleName(),jedis);
    }
    
    static Serializable createSerializable(String type){
        Serializable serializable =  beansCache.get(&quot;serializable&quot;);
        if(serializable != null)return serializable;
        
        switch(type){
            case &quot;kryo&quot;:    // kryo 不能用单例，请忽略本问题，示例而已
                return new KryoSerializable();
            case &quot;protostuff&quot;:
                return new protostuffSerializable();
            default:
                return new FastJsonSerizlizable();
        }
    }
    
    static Jedis createJedis(String serializableType){
        Jedis jedis = new Jedis();
        Serializable serializable = beansCache.get(&quot;serializable&quot;);
        jedis.setSerializable(serializable);
        return jedis;
    }

    //然后对外提供获取 Bean 的方法 
    public static Object getBean(String beanName){
        return beansCache.get(beanName);
    }
    
    public static T getBean(Class&amp;lt;T&amp;gt; type){
        return beansCache.get(type.getSimpleName());
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但如果写这个类的是小明，经过一段时间后这个类里会出现大量的 createXx 和 XX 的初始化操作，而且依赖程度也非常复杂，这时小明想，是时候优化一波了，于是小明想了一种解决方案，定义了一种 xml 语法&lt;/p&gt;
&lt;p&gt;使用 bean 标签来定义一个 bean，每个 bean 都有唯一的一个 id 信息 ,使用 property 来定义它的属性 ，如果是复杂属性使用 ref ，解析这个xml 得到一个完整的 bean 依赖图&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;beans&amp;gt;
    &amp;lt;bean id=&quot;serializable&quot; class=&quot;com.xx.FastJsonSerizlizable&quot; /&amp;gt;
    
    &amp;lt;bean id=&quot;jedis&quot; class=&quot;com.xx.Jedis&quot;&amp;gt;
        &amp;lt;property name=&quot;host&quot; value=&quot;localhost&quot; /&amp;gt;
        &amp;lt;property name=&quot;serializable&quot; ref=&quot;serializable&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这时会有一个依赖问题，我创建 jedis 要先创建 serializable ，但是 serializable 的 xml bean 定义是写在文件前面 的，小明想了一个办法，先把 ref 使用字符串先存着，全部放到一个 bean 定义中，像这样&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Map&amp;lt;String,BeanDefinition&amp;gt; beanDefinitions = new HashMap();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后把其解析成一颗依赖树，这样就可以先构造树叶，然后逐层构造对象 ，但也有一种棘手的情况 ，那就是循环依赖&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;root

  |-jedis

    |- serializable&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;什么是循环依赖呢，最简单的 A 依赖于 B，B 依赖于 A ，或者中间有更多的依赖最后形成了一个圈，A-B-C-A&lt;/p&gt;
&lt;p&gt;最原始的解决方式是这样的，我们可以先使用构造函数把它们都创建出来，不能是有带它们的构造函数，然后通过 set 把对象通过属性设置值。所以除了构造注入外，通过属性方式是可以解决循环依赖的。&lt;/p&gt;
&lt;p&gt;这时我们的 BeanUtil 变成了这样，想想不能叫工具类了，改为实体类 Factory&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public BeanFactory {
    
    Map&amp;lt;String,BeanDefinition&amp;gt; beanDefinitions = new HashMap();
    
    // 这里我们可以使用 bean 的全路径 =&amp;gt; bean 实例来缓存 bean 
    Map&amp;lt;String,Object&amp;gt; beansCache = new ConcurrentHashMap&amp;lt;String,Object&amp;gt;();
 
    {
        // 加载 xml bean 配置文件
        beanDefinitions = loadXml(contextConfigurations:String []);
        
        //实例化所有 bean 
        beansCache = instanceBeans(beanDefinitions);
    }
    
    //然后对外提供获取 Bean 的方法 
    public  Object getBean(String beanName){
        return beansCache.get(beanName);
    }
    
    public  T getBean(Class&amp;lt;T&amp;gt; type){
        return beansCache.get(type.getSimpleName());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这看起来已经足够完美了，但这时程序员A提问了，我需要对我的某个类的初始化时，我要获取一些比如连接资源，文件资源，然后在类销毁时想要回收资源，但根据上面没任何办法可以做到。&lt;/p&gt;
&lt;p&gt;小明说，这好办，我提供几个接口给你，你实现一下，我会在实例化 Bean 的时候 ，如果发现你有实现接口，在相应的过程里我就帮你调用一下，于是小明就添加了两个接口&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface InitializingBean{
    void afterPropertiesSet() throws Exception;
}

public  interface DisposableBean{
    void destroy() throws Exception;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;程序员A 的问题解决了，这时程序员B说，有没有一种办法，可以对所有 Bean 的初始化过程进行拦截，而不是我当前这个类，我想把每一个 service 改成代理类，我想要给 service 中的方法添加事务。&lt;/p&gt;
&lt;p&gt;小明说，那好吧，我把 bean 的属性都注入完了，然后给这个 bean 交给你，你装饰一下这个 bean 然后再还给我，于是小明提供出了这样一个接口 ，在 bean 初始化前和初始化后，你都可以来修改 bean ，不要要注意，这个是针对全局的，不是你个人的 bean ，要做好过滤操作&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface BeanPostProcessor {
    Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException ;
    
    Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;程序员C 这时又发问了，我创建了一个 BeanA 但我怎么样可以拿到 BeanC 啊，我想看看 c 的一些属性。&lt;/p&gt;
&lt;p&gt;小说说，真烦，我干脆把 map 都给你好，不，我把 BeanFactory 都给你好了，于是有了这个接口&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface BeanFactoryAware{
    void setBeanFactory(BeanFactory beanUtil);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这时程序D 又问了，我在 setBeanFactory 的时候 ，我创建的全局 processor 执行了吗，还是在之后执行，头大。&lt;/p&gt;
&lt;p&gt;小明说，我整理下执行顺序，取个名吧，叫 bean 的生命周期，顺便再提供几个实用的接口，bean 的名字我还没告诉你呢，于是整理的生命周期如下&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;反射创建 Bean 
填充对象属性
BeanNameAware.setBeanName();
BeanFactoryAware.setBeanFactory ();
BeanPostProcessor.postProcessBeforeInitialization(); 多个
InitializingBean.afterPropertiesSet()
BeanPostProcessor.postProcessAfterInitialization(); 多个
DisposableBean.destory()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;程序员E 又说了，xml 配置太麻烦了，jdk1.5 不是有注解吗，我在类上加个标识，你扫描我的类，帮我创建实例呗&lt;/p&gt;
&lt;p&gt;然后我需要用的时候，我在属性上加个标识，你同样可以根据类型找到依赖的类，然后把对应的实例创建好，帮我把值放进去就好了，如果这个类的创建过程比较复杂，我自己来创建，然后我把它返回给你，我定义一个方法，加个 Bean 的标识，你来读进容器。&lt;/p&gt;
&lt;p&gt;于是小明又加了 &lt;code&gt;@Component&lt;/code&gt; 来表示组件，&lt;code&gt;@Bean&lt;/code&gt; 来表示自定义实例创建，&lt;code&gt;@Autowired&lt;/code&gt; 来注入对象 &lt;code&gt;@PostConstruct&lt;/code&gt; 来执行类的初始化工作 &lt;code&gt;@PreDestroy&lt;/code&gt; 来做类的销毁工作，类的生命周期变成这样&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;反射创建 Bean 
填充对象属性
BeanNameAware.setBeanName();
BeanFactoryAware.setBeanFactory ();
BeanPostProcessor.postProcessBeforeInitialization(); 多个
PostConstruct
InitializingBean.afterPropertiesSet()
BeanPostProcessor.postProcessAfterInitialization(); 多个
PreDestroy
DisposableBean.destory()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是为了兼容以前的 xml 形式，小明这时把 BeanFactory 抽象成接口，提供 getBean 方法，根据职责单一原则，BeanFactory 不应该再做解析 Bean 的工作；&lt;/p&gt;
&lt;p&gt;再创建一个接口用于加载 Bean 定义，有两个实现 XmlBeanRegistry ，AnnotationBeanRegistry ，加载 Bean 定义后再合并，考虑到以后还有可能添加别的注册 bean 的方式 ，一次性提供一个对外的接口&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface BeanFactoryPostProcessor{
    void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你可以把你规则写成的 bean 定义，实例化为我要求的 BeanDefinition 然后发给我就可以自定义实现把你自定义的 bean 添加到容器中了&lt;/p&gt;
&lt;h2 id=&quot;一点小推广&quot;&gt;一点小推广&lt;/h2&gt;
&lt;p&gt;创作不易，希望可以支持下我的开源软件，及我的小工具，欢迎来 gitee 点星，fork ，提 bug 。&lt;/p&gt;
&lt;p&gt;Excel 通用导入导出，支持 Excel 公式&lt;br/&gt;博客地址：&lt;a href=&quot;https://blog.csdn.net/sanri1993/article/details/100601578&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/sanri1993/article/details/100601578&lt;/a&gt;&lt;br/&gt;gitee：&lt;a href=&quot;https://gitee.com/sanri/sanri-excel-poi&quot; class=&quot;uri&quot;&gt;https://gitee.com/sanri/sanri-excel-poi&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用模板代码 ，从数据库生成代码 ，及一些项目中经常可以用到的小工具&lt;br/&gt;博客地址：&lt;a href=&quot;https://blog.csdn.net/sanri1993/article/details/98664034&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/sanri1993/article/details/98664034&lt;/a&gt;&lt;br/&gt;gitee：&lt;a href=&quot;https://gitee.com/sanri/sanri-tools-maven&quot; class=&quot;uri&quot;&gt;https://gitee.com/sanri/sanri-tools-maven&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 07 Nov 2019 14:49:00 +0000</pubDate>
<dc:creator>sanri1993</dc:creator>
<og:description>写在前面的话 适用读者：有一定经验的，本文不适合初学者，因为可能不能理解我在说什么 文章思路：不会一开始就像别的博客文章那样，Bean 的生命周期，源码解读（给你贴一大堆的源码）。个人觉得应该由问题驱</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sanri1993/p/11816411.html</dc:identifier>
</item>
</channel>
</rss>