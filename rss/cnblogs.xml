<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>js数据类型转换 - Moon65</title>
<link>http://www.cnblogs.com/moon-lee/p/12556773.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/moon-lee/p/12556773.html</guid>
<description>&lt;p&gt;&lt;span&gt;JavaScript 中，变量可以赋予任何类型的值。但是运算符对数据类型是有要求的，如果运算符发现，运算子的类型与预期不符，就会自动转换类型。数据类型除了可以自动转换以外，还可以手动强制转换。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;数据类型的转换&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;强制转换&lt;/li&gt;
&lt;li&gt;隐式转换&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;typeof 判断数据类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;typeof操作符是用来检测变量的数据类型。对于值或变量使用typeof 操作符会返回如下字符串。&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
1 &lt;span&gt;var&lt;/span&gt; type=&lt;span&gt;typeof&lt;/span&gt; &quot;aaa&quot;&lt;span&gt;;
&lt;/span&gt;2 console.log(type);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一：强制转换&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、 强制转换为 - 字符串&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1）.String() String(数据)&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; num=10&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; a=num.toString(2&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;console.log(a);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; console.log(&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt; num);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; console.log(&lt;span&gt;typeof&lt;/span&gt; a);
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2）.toString()  .toString(进制)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以将任意数字转换为任意进制&lt;/p&gt;
&lt;p&gt;toString 可以将任意数字转换为任意进制，进制必须大于等于2，小于等于36；&lt;/p&gt;
&lt;p&gt;最小是2进制，最大是36进制，因为数字（10）字母（26）共36个；&lt;/p&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
1 &lt;span&gt;var&lt;/span&gt; color=255&lt;span&gt;；
&lt;/span&gt;2 &lt;span&gt;var&lt;/span&gt; c=color.toString(16&lt;span&gt;);
&lt;/span&gt;3 console.log(c); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ff&lt;/span&gt;
3）.toFixed()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;3）&lt;/strong&gt;&lt;strong&gt;.toFixed()   &lt;/strong&gt;&lt;strong&gt;.toFixed(小数点后几位)；&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;将数值转换为字符串，并按照小数点四舍五入，保留位数，但是有精度误差。&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
1 &lt;span&gt;var&lt;/span&gt; num=10.35&lt;span&gt;;
&lt;/span&gt;2 &lt;span&gt;var&lt;/span&gt; a=num.toFixed(1);3 console.log(a); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;10.3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
1 &lt;span&gt;var&lt;/span&gt; num=0.5‐0.2&lt;span&gt;;
&lt;/span&gt;2 console.log(num==0.3&lt;span&gt;);
&lt;/span&gt;3 console.log(0.3‐0.2==0.1);
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、强制转换为 - 数值&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Number()&lt;/p&gt;
&lt;p&gt;Number(数据)&lt;/p&gt;
&lt;p&gt;NaN 非数值 类型是number&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1) 纯字符---》 NaN&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
1 &lt;span&gt;var&lt;/span&gt; str=&quot;你好&quot;&lt;span&gt;;
&lt;/span&gt;2 &lt;span&gt;var&lt;/span&gt; num=&lt;span&gt;Number(str);
&lt;/span&gt;3 console.log(num); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;NaN&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2) 纯数字---》数字&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
1 &lt;span&gt;var&lt;/span&gt; str=&quot;你好&quot;&lt;span&gt;;
&lt;/span&gt;2 &lt;span&gt;var&lt;/span&gt; num=&lt;span&gt;Number(str);
&lt;/span&gt;3 console.log(num);
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;3) 部分数字，部分字符---》NaN&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
1 &lt;span&gt;var&lt;/span&gt; str=&quot;12&quot;&lt;span&gt;;
&lt;/span&gt;2 &lt;span&gt;var&lt;/span&gt; num=&lt;span&gt;Number(str);
&lt;/span&gt;3 console.log(num);
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;4) 布尔值---》数字 true---&amp;gt;1 false---&amp;gt;0&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
1 &lt;span&gt;var&lt;/span&gt; str=&quot;1a&quot;&lt;span&gt;;
&lt;/span&gt;2 &lt;span&gt;var&lt;/span&gt; num=&lt;span&gt;Number(str);
&lt;/span&gt;3 console.log(num);
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;5) undefined---》NaN&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
1 &lt;span&gt;var&lt;/span&gt; b=&lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;2 &lt;span&gt;var&lt;/span&gt; num=&lt;span&gt;Number(b);
&lt;/span&gt;3 console.log(num);
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;6) null---》0&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
1 &lt;span&gt;var&lt;/span&gt; a;&lt;br/&gt;2 &lt;span&gt;var&lt;/span&gt; num=&lt;span&gt;Number(a);
&lt;/span&gt;3 console.log(num);
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;3、强制转换为 - 整数&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1）parseInt(str)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;a：纯字符---》 NaN&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
1 &lt;span&gt;var&lt;/span&gt; str=&quot;你好&quot;&lt;span&gt;;
&lt;/span&gt;2 &lt;span&gt;var&lt;/span&gt; num=&lt;span&gt;parseInt(str);
&lt;/span&gt;3 console.log(num); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;NaN&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;b：纯数字---》数字&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
1 &lt;span&gt;var&lt;/span&gt; str=&quot;20&quot;&lt;span&gt;;
&lt;/span&gt;2 &lt;span&gt;var&lt;/span&gt; num=&lt;span&gt;parseInt(str);
&lt;/span&gt;3 console.log(str); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; num ：20&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;c：部分数字，部分字符---》 通过parseInt转换数值可以从开始转换到字符前为止变成数值，如果第一位是字符，返回NaN&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
1 &lt;span&gt;var&lt;/span&gt; str1=&quot;16a&quot;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;部分数值部分字符 按照10进制转换16&lt;/span&gt;
2 &lt;span&gt;var&lt;/span&gt; num=&lt;span&gt;parseInt(str1);
&lt;/span&gt;3&lt;span&gt; console.log(num1);
&lt;/span&gt;4 &lt;span&gt;var&lt;/span&gt; str2=&quot;a16&quot;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;部分数值部分字符 NaN&lt;/span&gt;
5 &lt;span&gt;var&lt;/span&gt; num=&lt;span&gt;parseInt(str2);
&lt;/span&gt;6 console.log(num2);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;d：布尔值---》NaN&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
1 &lt;span&gt;var&lt;/span&gt; str=&lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;2 &lt;span&gt;var&lt;/span&gt; num=&lt;span&gt;parseInt(str);
&lt;/span&gt;3 console.log(num);
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;e：undefined---》NaN&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
1 &lt;span&gt;var&lt;/span&gt;&lt;span&gt; str;
&lt;/span&gt;2 &lt;span&gt;var&lt;/span&gt; num=&lt;span&gt;parseInt(str);
&lt;/span&gt;3 console.log(num);
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;f：null---》NaN&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
1 &lt;span&gt;var&lt;/span&gt; str=&lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;2 &lt;span&gt;var&lt;/span&gt; num=&lt;span&gt;parseInt(str);
&lt;/span&gt;3 console.log(num);
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2）parseInt(字符，进制)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以将指定进制方式字符串转换为10进制，是toString()逆转换&lt;/p&gt;
&lt;p&gt;例1：parseInt(str,2); 将2进制字符串转换为10进制数值&lt;/p&gt;
&lt;div readability=&quot;9.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
1 &lt;span&gt;var&lt;/span&gt; str=&quot;1010&quot;&lt;span&gt;;
&lt;/span&gt;2 &lt;span&gt;var&lt;/span&gt; num=parseInt(str,2&lt;span&gt;);
&lt;/span&gt;3 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; num ：10&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;例2：parseInt(str,16); 将16进制字符串转换为10进制数值&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
1 &lt;span&gt;var&lt;/span&gt; str=&quot;FF&quot;&lt;span&gt;;
&lt;/span&gt;2 &lt;span&gt;var&lt;/span&gt; num=parseInt(str,16&lt;span&gt;);
&lt;/span&gt;3&lt;span&gt; console.log(num);
&lt;/span&gt;4 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; #FF0000&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4、强制转换为 - 小数&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;parseFloat() 可以保留小数位&lt;/p&gt;
&lt;p&gt;强转小数和parseInt类似&lt;/p&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
1 &lt;span&gt;var&lt;/span&gt; str1=25.541&lt;span&gt;;
&lt;/span&gt;2 &lt;span&gt;var&lt;/span&gt; str2=25.541&lt;span&gt;;
&lt;/span&gt;3 &lt;span&gt;var&lt;/span&gt; num1=&lt;span&gt;parseInt(str1);
&lt;/span&gt;4 &lt;span&gt;var&lt;/span&gt; num2=&lt;span&gt;parseFloat(str2);
&lt;/span&gt;5 console.log(num1); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;
6 console.log(num2); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;25.541&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;5、强制转换为 - 布尔值&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;boolen()&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1) 转换为false有：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&quot;&quot; 0 false,undefined,null,NaN,转换为布尔值都会变成false&lt;/p&gt;

&lt;p&gt;a：“”引号中间没有空格&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
1 &lt;span&gt;var&lt;/span&gt; str1=&quot;&quot;&lt;span&gt;;
&lt;/span&gt;2 &lt;span&gt;var&lt;/span&gt; b=&lt;span&gt;Boolean(str1);
&lt;/span&gt;3 console.log(b); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;b： 0&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
1 &lt;span&gt;var&lt;/span&gt; str2=0&lt;span&gt;;
&lt;/span&gt;2 &lt;span&gt;var&lt;/span&gt; b=&lt;span&gt;Boolean(str2);
&lt;/span&gt;3 console.log(b); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;c： false&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
1 &lt;span&gt;var&lt;/span&gt; str3=&lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;2 &lt;span&gt;var&lt;/span&gt; b=&lt;span&gt;Boolean(str3);
&lt;/span&gt;3 console.log(b); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;d： underfind&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
1 &lt;span&gt;var&lt;/span&gt;&lt;span&gt; str4;
&lt;/span&gt;2 &lt;span&gt;var&lt;/span&gt; b=&lt;span&gt;Boolean(str4);
&lt;/span&gt;3 console.log(b); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;e： null&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
1 &lt;span&gt;var&lt;/span&gt; str5=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;2 &lt;span&gt;var&lt;/span&gt; b=&lt;span&gt;Boolean(str5);
&lt;/span&gt;3 console.log(b); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;f：NaN&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
1 &lt;span&gt;var&lt;/span&gt; str6=&lt;span&gt;NaN;
&lt;/span&gt;2 &lt;span&gt;var&lt;/span&gt; b=&lt;span&gt;Boolean(str6);
&lt;/span&gt;3 console.log(b); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2) 除此之外转换都是：true&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
1 &lt;span&gt;var&lt;/span&gt; str=&quot;aaa&quot;&lt;span&gt;;
&lt;/span&gt;2 &lt;span&gt;var&lt;/span&gt; b=&lt;span&gt;Boolean(str);
&lt;/span&gt;3 console.log(b); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;str&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;二：隐式转换&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;j类型不同，弱类型语言会自动将数据转换为对应的类型&lt;/li&gt;
&lt;li&gt;当数据类型不相同时，做数据的运算，就会自动将两端的数据转换为相同类型然后运算，这是隐式转换&lt;/li&gt;
&lt;li&gt;隐式转换遵从与 String() Number() Boolean()&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;例：加法运算：都转换为字符串运算&lt;/p&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
1 &lt;span&gt;var&lt;/span&gt; a=6&lt;span&gt;;
&lt;/span&gt;2 &lt;span&gt;var&lt;/span&gt; b=&quot;a&quot;&lt;span&gt;;
&lt;/span&gt;3 &lt;span&gt;var&lt;/span&gt; c=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;4 console.log(a+b); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;6a&lt;/span&gt;
5 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里将a隐式转换为字符串，并且相加首尾相连6 console.log(a+c); // 7&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;例：减法运算：都转换为数值&lt;/p&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
1 &lt;span&gt;var&lt;/span&gt; a=6&lt;span&gt;;
&lt;/span&gt;2 &lt;span&gt;var&lt;/span&gt; b=&quot;a&quot;&lt;span&gt;;
&lt;/span&gt;3&lt;span&gt; console.log(a‐b);
&lt;/span&gt;4 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;减法会隐式转换将a和b都转换为数值 NaN 6‐NaN&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
</description>
<pubDate>Tue, 24 Mar 2020 00:55:00 +0000</pubDate>
<dc:creator>Moon65</dc:creator>
<og:description>JavaScript 中，变量可以赋予任何类型的值。但是运算符对数据类型是有要求的，如果运算符发现，运算子的类型与预期不符，就会自动转换类型。数据类型除了可以自动转换以外，还可以手动强制转换。 数据类</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/moon-lee/p/12556773.html</dc:identifier>
</item>
<item>
<title> mysql之事务 - 李福春</title>
<link>http://www.cnblogs.com/snidget/p/12556761.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/snidget/p/12556761.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/268922/202003/268922-20200324084827080-1066728381.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们为什么要使用数据库的事务呢？使用事务有什么缺点呢？&lt;/p&gt;
&lt;p&gt;使用原因：保持数据的匹配和一致性。&lt;br/&gt;缺点： 并发操作中过度使用事务影响性能，因为事务用到了锁技术。&lt;/p&gt;
&lt;p&gt;我是李福春，今天我们来复习一下事务的特性。&lt;br/&gt;你可以收获下图中的知识点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/268922/202003/268922-20200324084827995-697681657.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面我们发散一下。&lt;/p&gt;

&lt;p&gt;原子性： 要么全部成功要么全部失败&lt;br/&gt;一致性： 保证事务的前后一致性 &lt;br/&gt;隔离性：事物之间的执行不能互相干扰 &lt;br/&gt;持久性： 事务终结的标志，内存的数据持久化到硬盘中&lt;/p&gt;

&lt;p&gt;脏读：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/268922/202003/268922-20200324084828892-1343614766.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不可重复读&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/268922/202003/268922-20200324084829564-904996078.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;幻读：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/268922/202003/268922-20200324084830397-699387598.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;依赖id的自增做为依据。&lt;/p&gt;

&lt;p&gt;读未提交     隔离度最弱           脏读 不可重复度 幻读&lt;/p&gt;
&lt;p&gt;读已提交                             不可重复度 幻读&lt;/p&gt;
&lt;p&gt;可重复读      数据库默认          幻读&lt;/p&gt;
&lt;p&gt;可串行化       性能最低            没有问题&lt;/p&gt;
&lt;p&gt;innodb mvcc   不能解决幻读&lt;/p&gt;

&lt;h2 id=&quot;没有数据一致性要求场景&quot;&gt;没有数据一致性要求场景&lt;/h2&gt;
&lt;p&gt;不使用事务&lt;/p&gt;
&lt;h2 id=&quot;只有查询的场景&quot;&gt;只有查询的场景:&lt;/h2&gt;
&lt;p&gt;不需要使用事务&lt;/p&gt;
&lt;h2 id=&quot;更新记录表，然后更新统计表&quot;&gt;更新记录表，然后更新统计表&lt;/h2&gt;
&lt;p&gt;不要使用事务， 使用事务触发或者定时任务；&lt;/p&gt;
&lt;h2 id=&quot;内容繁杂的大事务&quot;&gt;内容繁杂的大事务&lt;/h2&gt;
&lt;p&gt;分拆成各种小事务，各种反向操作辅助&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/268922/202003/268922-20200324084831121-534987049.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;原创不易，转载请注明出处。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 24 Mar 2020 00:49:00 +0000</pubDate>
<dc:creator>李福春</dc:creator>
<og:description>我们为什么要使用数据库的事务呢？使用事务有什么缺点呢？ 使用原因：保持数据的匹配和一致性。缺点： 并发操作中过度使用事务影响性能，因为事务用到了锁技术。 我是李福春，今天我们来复习一下事务的特性。你可</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/snidget/p/12556761.html</dc:identifier>
</item>
<item>
<title>欲善事先利器-IEAD插件篇 - MageByte-借来方向</title>
<link>http://www.cnblogs.com/WeaRang/p/12555834.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/WeaRang/p/12555834.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;工欲善其事，必先利其器，好鞋踢好球是非常合乎逻辑的事情。&lt;/p&gt;
&lt;p&gt;——《长江七号》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;同样的开场白，不一样的酒，不一样的故事。&lt;/p&gt;
&lt;p&gt;上篇&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU3NDkwMjAyOQ==&amp;amp;mid=2247483975&amp;amp;idx=1&amp;amp;sn=6f51a57582f1c965b747fc157253fdeb&amp;amp;chksm=fd2a1825ca5d9133f938f94550335cb79aba324b1cb61d422f4821c0e5a57dc44196f7e4b656&amp;amp;scene=21#wechat_redirect&quot;&gt;《欲善事先利器——系统篇》&lt;/a&gt;已经推荐了一些个人常用的效率系统软件。觉得有帮助的，有共鸣的 Rock 一下。我们继续新篇——IDEA 插件篇。用 Eclipse 的请原谅，本人已经好几年没用过 Eclipse 了，给不了你好的建议。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以下插件插件直接在 IDEA 插件管理里面搜索安装：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;IDEA &amp;gt; Ctrl+A &amp;gt; 输入&quot;plugins&quot; &amp;gt; 选择plugins &amp;gt; 选择marketplace(tab) &amp;gt; 输入插件名 &amp;gt; 选择Install&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;其中提供链接的是希望读者自己看一看官方文档。&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;acejump&quot;&gt;AceJump&lt;/h2&gt;
&lt;p&gt;快速定位光标，有它，你可以丢掉鼠标了。&lt;/p&gt;
&lt;p&gt;你只需要 &lt;code&gt;Ctrl + ;&lt;/code&gt; 然后输入跳转到的字符即可定位到相应的位置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://magebyte.oss-cn-shenzhen.aliyuncs.com/toolsscreen2gif.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;ideavim&quot;&gt;IdeaVim&lt;/h2&gt;
&lt;p&gt;在 Idea 中使用 Vim 风格写代码，只适合 Vim 党。不多介绍，懂得自然懂，不懂的自行先学 Vim(自动狗头)。&lt;/p&gt;
&lt;h2 id=&quot;generateallsetter&quot;&gt;GenerateAllSetter&lt;/h2&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://github.com/gejun123456/intellij-generateAllSetMethod&quot;&gt;https://github.com/gejun123456/intellij-generateAllSetMethod&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;为本地变量快速生成 setter 方法。再不需要一个一个去 set 了，经常忘了一个结果就出 bug 了。&lt;/li&gt;
&lt;li&gt;在方法上快速 convert 的 setter 形式的代码。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;camelcase&quot;&gt;CamelCase&lt;/h2&gt;
&lt;p&gt;驼峰式大小写切换插件。&lt;/p&gt;
&lt;p&gt;可以通过快捷键在 CamelCase, camelCase, snake_case and SNAKE_CASE 之间快速切换。&lt;/p&gt;
&lt;p&gt;默认快捷键：&lt;code&gt;ctrl + shift + u&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://magebyte.oss-cn-shenzhen.aliyuncs.com/tools/idea_plugins/camelCase.gif&quot; alt=&quot;MageByte&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;free-mybatis-plugin&quot;&gt;Free MyBatis plugin&lt;/h2&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;快速在 Mybatis Mapper 类方法和 Mybatis mapper.xml sql 语句间相互定位。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://magebyte.oss-cn-shenzhen.aliyuncs.com/tools/idea_plugins/free-mybatis-1.gif&quot; alt=&quot;MageByte&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;快速根据方法定义生成相应的 mapper 语句。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://magebyte.oss-cn-shenzhen.aliyuncs.com/tools/idea_plugins/free-mybatis-2.gif&quot; alt=&quot;MateByte&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;codehelpergenerator&quot;&gt;Codehelper.generator&lt;/h2&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://github.com/zhengjunbase/codehelper.generator&quot;&gt;https://github.com/zhengjunbase/codehelper.generator&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特性：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;根据 Pojo 文件一键生成 Dao，Service，Xml，Sql 文件。&lt;/li&gt;
&lt;li&gt;Pojo 文件更新后一键更新对应的 Sql 和 mybatis xml 文件。&lt;/li&gt;
&lt;li&gt;提供 insert，insertList，update，select，delete 五种方法。&lt;/li&gt;
&lt;li&gt;能够批量生成多个 Pojo 的对应的文件。&lt;/li&gt;
&lt;li&gt;Pojo 文件新增字段后，同时生成添加字段的 sql 语句。&lt;/li&gt;
&lt;li&gt;自动将 pojo 的注释添加到对应的 Sql 文件的注释中。&lt;/li&gt;
&lt;li&gt;丰富的配置，如果没有配置文件，则会使用默认配置。&lt;/li&gt;
&lt;li&gt;可以在 Intellij Idea 中快捷键配置中配置快捷键。&lt;/li&gt;
&lt;li&gt;目前支持 MySQL + Java，后续会支持更多的 DB。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;maven-helper&quot;&gt;Maven Helper&lt;/h2&gt;
&lt;p&gt;查看 maven 包引用关系，快速定位有冲突的吧。比起 IDEA 自带的 &lt;code&gt;Diagrams&lt;/code&gt; 更清晰好用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://magebyte.oss-cn-shenzhen.aliyuncs.com/tools/idea_plugins/codeMaker.gif&quot; alt=&quot;MageByte&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;codemaker&quot;&gt;CodeMaker&lt;/h2&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://github.com/x-hansong/CodeMaker&quot;&gt;https://github.com/x-hansong/CodeMaker&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;有点想法的程序员大都会对一直重复的代码很暴躁，想要么能不能通过框架解决，要么能不能通过代码自动生成解决。&lt;code&gt;CodeMaker&lt;/code&gt;就是一个 IDEA 代码生成插件，你可以根据类来生成相应的 Template（基于 Velocity），之后想生成类似的类就直接可以通过 IDEA 生成了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://magebyte.oss-cn-shenzhen.aliyuncs.com/tools/idea_plugins/codeMaker.gif&quot; alt=&quot;MageByte&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;git-commit-template&quot;&gt;Git Commit Template&lt;/h2&gt;
&lt;p&gt;Git Commit Message 一定要简约而实用，描述清楚提交的功能。&lt;em&gt;插一句题外话，注释的老代码就直接删除掉，不要说什么以后可能会用到啊，git history 已经帮你记录了，请不要留在当前版本下！！！&lt;/em&gt;&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;按如下风格整理 message&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;type&amp;gt;(&amp;lt;scope&amp;gt;): &amp;lt;subject&amp;gt;
&amp;lt;BLANK LINE&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;BLANK LINE&amp;gt;
&amp;lt;footer&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;按如下方式提交 message&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://magebyte.oss-cn-shenzhen.aliyuncs.com/tools/idea_plugins/git-commit-t-3.png&quot; alt=&quot;MageByte&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;message 将看起来如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://magebyte.oss-cn-shenzhen.aliyuncs.com/tools/idea_plugins/git-commit-t.png&quot; alt=&quot;MageByte&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;grep-console&quot;&gt;Grep Console&lt;/h2&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://plugins.jetbrains.com/plugin/7125-grep-console&quot;&gt;https://plugins.jetbrains.com/plugin/7125-grep-console&lt;/a&gt;&lt;/p&gt;
&lt;ol readability=&quot;-1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;让 Console 日志有颜色，可以对 trace，debug，info，warn，error 配置不同的颜色。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://magebyte.oss-cn-shenzhen.aliyuncs.com/tools/idea_plugins/gc-1.png&quot; alt=&quot;MageByte&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;grep 过滤日志&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://magebyte.oss-cn-shenzhen.aliyuncs.com/tools/idea_plugins/gc-2.png&quot; alt=&quot;MageByte&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;jackson-generator-plugin&quot;&gt;Jackson Generator Plugin&lt;/h2&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://plugins.jetbrains.com/plugin/7678-jackson-generator-plugin&quot;&gt;https://plugins.jetbrains.com/plugin/7678-jackson-generator-plugin&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;快速在 class 和 json 间相互生成。同样的还有 &lt;code&gt;Gson Generator&lt;/code&gt;。一个生成 &lt;code&gt;Jackson&lt;/code&gt; 风格的类(注解)，一个生成 &lt;code&gt;Gson&lt;/code&gt; 风格的类。&lt;/p&gt;
&lt;h2 id=&quot;lombok&quot;&gt;Lombok&lt;/h2&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://plugins.jetbrains.com/plugin/6317-lombok&quot;&gt;https://plugins.jetbrains.com/plugin/6317-lombok&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用 Lombok 必须安装的插件。&lt;/p&gt;
&lt;p&gt;Lombok 通过添加注解的方式来生成 getter，setter，toString，builder 等这些无意义代码（原理是字节码修改，maven 插件和 idea 插件）。&lt;/p&gt;
&lt;h2 id=&quot;rainbow-brackets&quot;&gt;Rainbow Brackets&lt;/h2&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://plugins.jetbrains.com/plugin/10080-rainbow-brackets&quot;&gt;https://plugins.jetbrains.com/plugin/10080-rainbow-brackets&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;让你的左括号和对应的右括号(大小括号都可以)显示相同的颜色，以此快速看出括号的范围。&lt;/p&gt;
&lt;p&gt;like this:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://magebyte.oss-cn-shenzhen.aliyuncs.com/tools/idea_plugins/rb.png&quot; alt=&quot;MageByte&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;string-manipulation&quot;&gt;String Manipulation&lt;/h2&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://plugins.jetbrains.com/plugin/2162-string-manipulation&quot;&gt;https://plugins.jetbrains.com/plugin/2162-string-manipulation&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;和 &lt;code&gt;CamelCase&lt;/code&gt; 的功能类似，不过除了 &lt;code&gt;camel&lt;/code&gt; 风格字符串转换，还包括很多强大的功能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;风格切换(camelCase, kebab-lowercase, KEBAB-UPPERCASE, snake_case, SCREAMING_SNAKE_CASE, dot.case, words lowercase, First word capitalized, Words Capitalized, PascalCase)。&lt;/li&gt;
&lt;li&gt;Un/Escape 代码(Java、JavaScript、SQL、HTML 等)。&lt;/li&gt;
&lt;li&gt;编码/解码(MD5、Hex、Base64 等)&lt;/li&gt;
&lt;li&gt;排序字符行&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://magebyte.oss-cn-shenzhen.aliyuncs.com/tools/idea_plugins/sm-1.png&quot; alt=&quot;MageByte&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://magebyte.oss-cn-shenzhen.aliyuncs.com/tools/idea_plugins/sm-2.png&quot; alt=&quot;MageByte&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以上插件建议直接在 IDEA 插件管理里面搜索安装：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;IDEA &amp;gt; Ctrl+A &amp;gt; 输入&quot;plugins&quot; &amp;gt; 选择plugins &amp;gt; 选择marketplace(tab) &amp;gt; 输入插件名 &amp;gt; 选择Install&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;其中提供链接的是希望读者自己看一看官方文档。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;推荐：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU3NDkwMjAyOQ==&amp;amp;mid=2247483975&amp;amp;idx=1&amp;amp;sn=6f51a57582f1c965b747fc157253fdeb&amp;amp;chksm=fd2a1825ca5d9133f938f94550335cb79aba324b1cb61d422f4821c0e5a57dc44196f7e4b656&amp;amp;scene=21#wechat_redirect&quot;&gt;《欲善事先利器——系统篇》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;《欲善事先利器——IDEA 插件篇》(本篇)&lt;/li&gt;
&lt;li&gt;《欲善事先利器——Library 篇》（待更新）&lt;/li&gt;
&lt;li&gt;《欲善事先利器——流程篇》（待更新）&lt;/li&gt;
&lt;li&gt;《欲善事先利器——网站篇》（待更新）&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;如果对以上一两款插件有兴趣，可以自行找资料了解(推荐官网)，也可以留言，有时间可以详细分享一下我的使用经验。如果你有其他上面没提到的小工具，不妨在评论区一起分享。请关注我的公众号。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://magebyte.oss-cn-shenzhen.aliyuncs.com/wechat/Snip20200314_5.png&quot; alt=&quot;MageByte&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 24 Mar 2020 00:47:00 +0000</pubDate>
<dc:creator>MageByte-借来方向</dc:creator>
<og:description>工欲善其事，必先利其器，好鞋踢好球是非常合乎逻辑的事情。 ——《长江七号》 同样的开场白，不一样的酒，不一样的故事。 上篇 &amp;quot;《欲善事先利器——系统篇》&amp;quot; 已经推荐了一些个人常用的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/WeaRang/p/12555834.html</dc:identifier>
</item>
<item>
<title>Python基础 | 数据文件的读写 - dataxon</title>
<link>http://www.cnblogs.com/dataxon/p/12556727.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dataxon/p/12556727.html</guid>
<description>&lt;p&gt;用python读写常见的数据文件，包括：txt、csv、xlsx、网页数据、PDF、word等&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;201.76179775281&quot;&gt;

&lt;p&gt;本文总结使用Python对常见的数据文件进行读写操作。&lt;/p&gt;
&lt;h2 id=&quot;txt&quot;&gt;txt&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.python.org/3/tutorial/inputoutput.html#reading-and-writing-files&quot;&gt;关于一般文件读写的更多参考&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;txt的读入&quot;&gt;txt的读入&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;## 文件读取

# 文件路径
file_in = os.path.join(workdir,'Data/demo_text.txt')

# 打开文件
f_in = open(file_in, encoding='utf-8')

# 将每行的文本读取，并存为列表
# 此处使用.rstrip()去除右侧的空格、换行符等
lines_raw = [x.rstrip() for x in f_in]
# 或者
# lines_raw = [l.rstrip() for l in f.readlines()]

print(lines_raw)

# 关闭文件
f_in.close()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果txt内部存储的是表格(dataframe)格式的数据，那么可以直接用&lt;code&gt;pandas.read_csv&lt;/code&gt;来读取。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;df_txt = pd.read_csv(file_in, names=['txt'], encoding='utf-8')
df_txt.head()
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;txt的写出&quot;&gt;txt的写出&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 文件输出
file_out = os.path.join(workdir,'Data/out_text.txt')

f_out = open(file_out, encoding='utf-8',mode = 'w')

f_out.writelines(lines_raw)
f_out.close()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的列子是一次写入所有行。&lt;br/&gt;也可以使用&lt;code&gt;.writeline&lt;/code&gt;方法一行一行写入，比如写log日志。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 程序执行的日志
file_log = os.path.join(workdir,'Data/run_log.txt')

f_log = open(file_log, encoding='utf-8',mode = 'w')

for i in range(5):
    line = 'this is %d run \n'%i
    f_log.write(line)

f_log.close()
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;csv&quot;&gt;csv&lt;/h2&gt;
&lt;p&gt;csv即逗号分隔的文件，可以使用的包&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pandas&lt;/code&gt;在数据分析中最常用，功能也很强大，这里只示范pandas的用法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 定义文件路径
file_csv = os.path.join(workdir,'Data/demo_csv.csv')

# pandas.read_csv()函数来读取文件
df_csv = pd.read_csv(file_csv,sep=',',encoding='utf-8')

# dataframe.to_csv()保存csv文件
# 保存文件的时候一定要注意encoding
df_csv.to_csv('out_csv',index=False,encoding='utf-8')
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也可以用来读取在线的文件，文件的后缀可能是txt、data之类的，不过没关系，只要里面存的是表格(dataframe)格式的数据，就可以用&lt;code&gt;pandas.read_csv&lt;/code&gt;来读取。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;#此处使用UCI机器学习用的数据
url_data = 'https://archive.ics.uci.edu/ml/machine-learning-databases/adult/adult.data'
# 字段描述见https://archive.ics.uci.edu/ml/machine-learning-databases/adult/adult.names
df_adult = pd.read_csv(url_data, sep=',', names = col_names,index_col=None)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;xlsxlsx&quot;&gt;xls\xlsx&lt;/h2&gt;
&lt;p&gt;pandas工具包中也提供了相应的函数来读写excel文件(&lt;code&gt;pandas.read_excel()&lt;/code&gt;和&lt;code&gt;dataframe.to_excel()&lt;/code&gt;)。&lt;br/&gt;&lt;a href=&quot;https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_excel.html#pandas.read_excel&quot;&gt;更多参考&lt;/a&gt;&lt;br/&gt;不同于csv文件，xlsx文件中会有多个sheet，pandas.read_excel函数默认读取第一个sheet.&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 定义文件路径
file_excel = os.path.join(workdir,'Data/demo_xlsx.xlsx')

# pandas.read_excel()函数来读取文件
# sheet_name=0表示读取第一个sheet，也可以指定要读取的sheet的名称(字符串格式)
# header=0 表示使用第一行作为表头(列名)
# 如果数据中没有列名(表头)，可以设置header=None,同时names参数来指定list格式的列名
df_excel = pd.read_excel(file_excel,sheet_name=0,header=0,encoding='utf-8')

# dataframe.to_csv()保存csv文件
# 保存文件的时候一定要注意encoding
df_excel.to_excel('out_excel.xlsx',index=False,encoding='utf-8')
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果我们是想在单元格颗粒度上进行操作，可以考虑两个工具包：&lt;/p&gt;
&lt;p&gt;这里用xlwings示范自动化“填表”，比如现在有3个项目对应的3个单元格需要填写。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;evernotecid://01028f55-d279-4be9-a4a3-ecaabc21ef9c/appyinxiangcom/22897375/ENResource/p26061&quot; alt=&quot;2c34fa33c093bd27ea06cd2c33ddff5d.jpeg&quot;/&gt;@w=500&lt;/p&gt;
&lt;p&gt;如果要批量从多个统一格式的excel文件中读取多个单元格或者写入数据，可参考如下代码。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import xlwings as xw

file_excel = os.path.join(workdir,'Data/demo_填表.xlsx')

# 打开excel文件的时候不要展示页面
app = xw.App(visible=False)

# 打开工作簿
wb = xw.Book(file_excel)

# 打开工作表
# 可以用index，可以指定sheet的名称
ws = wb.sheets[0]

# 读取对应单元格的值
print(ws.range('A1').value)

ws.range('B1').value = 'Ahong'
ws.range('B2').value  = '男'
ws.range('B3').value  = 'Pyhon'

# 保存工作簿
wb.save() 
# 也可以保存为新的文件名，e.g.wb.save('new.xlsx')

# 关闭工作簿
wb.close()
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;在线网页数据&quot;&gt;在线网页数据&lt;/h2&gt;
&lt;p&gt;在线网页数据通常需要&lt;strong&gt;网络爬虫&lt;/strong&gt;来抓取，同时网页是半结构化的数据，需要整理为结构化的数据。&lt;br/&gt;关于网络爬虫可以参考如下两本书：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;em&gt;&lt;strong&gt;Web Scraping with Python: Collecting More Data from the Modern Web&lt;/strong&gt;&lt;/em&gt;, Ryan Mitchell, O’Reilly书系，中文版是&lt;em&gt;&lt;strong&gt;Python网络爬虫权威指南&lt;/strong&gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;Python 3网络爬虫开发实战&lt;/strong&gt;&lt;/em&gt;，崔庆才，也可以访问&lt;a href=&quot;https://cuiqingcai.com/&quot;&gt;作者的博客&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;常用的工具&quot;&gt;常用的工具&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;网页数据的爬取和解析常会用到的工具包&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;爬虫的步骤&quot;&gt;爬虫的步骤&lt;/h3&gt;
&lt;p&gt;通常网络爬虫的步骤如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;分析网页请求规范，比如是get还是post，请求的url是啥，返回的数据是什么格式(json?静态html?)，header参数，url或者post中的变量有什么等；&lt;/li&gt;
&lt;li&gt;获取网页数据，使用requests包；&lt;/li&gt;
&lt;li&gt;解析网页数据(将半结构化的网页数据转化为结构化数据)，BeautifulSoup、lxml、re、json齐上阵；&lt;/li&gt;
&lt;li&gt;整合数据并存档，使用pandas对数据进行整合并初步清洗。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;pdf&quot;&gt;pdf&lt;/h2&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;对于pdf文件而言，如果要对文档操作(比如合并、筛选、删除页面等)，建议使用的工具包：&lt;/p&gt;
&lt;p&gt;处理pdf文件时，要注意文件需要是“无密码”状态，“加密”状态的文件处理时会报错。&lt;br/&gt;pdf解密工具推荐：&lt;/p&gt;
&lt;p&gt;这里举例说明两个包的用法：筛选奇数页面并保存为新文档。&lt;/p&gt;
&lt;h3 id=&quot;pdfrw&quot;&gt;pdfrw&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from pdfrw import PdfReader

pdf_r = PdfReader(os.path.join(workdir,'Data/demo_pdf.pdf'))

from pdfrw import PdfWriter
pdf_w = PdfWriter()

page_cnt = pdf_r.numPages

# 筛选奇数页面
for i in range(0,page_cnt,2):
    pdf_w.addpage(pdf_r.pages[i])
    
pdf_w.write('filtered_pages.pdf')

y.write('dd.pdf')
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;pypdf2&quot;&gt;PyPDF2&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import PyPDF2

# 读入文件路径
file_in = os.path.join(workdir,'Data/demo_pdf.pdf')
# 打开要读取的pdf文件
f_in = open(file_in,'rb') 

# 读取pdf文档信息
pdfReader = PyPDF2.PdfFileReader(f_in)

# pdf文件页面数
page_cnt = pdfReader.getNumPages()

pdfWriter = PyPDF2.PdfFileWriter()

# 筛选奇数页面
for page_idx in range(0,page_cnt,2):
    page = pdfReader.getPage(page_idx)
    pdfWriter.addPage(page)
    
# 输出文档
file_out = open('pdf_out.pdf', 'wb')
pdfWriter.write(file_out)

# 关闭输出的文件
file_out.close()

# 关闭读入的文件
# pdf_file.close()
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;提取文档信息&quot;&gt;提取文档信息&lt;/h3&gt;
&lt;p&gt;如果要解析pdf文件的页面数据(文件上都写了啥)，推荐的工具包为：&lt;/p&gt;
&lt;p&gt;安装好pdfminer.six后，直接在命令行中调用如下命令即可：&lt;br/&gt;&lt;code&gt;pdf2txt.py demo_pdf.pdf -o demo_pdf.txt&lt;/code&gt;&lt;br/&gt;或者参考&lt;a href=&quot;https://stackoverflow.com/questions/26494211/extracting-text-from-a-pdf-file-using-pdfminer-in-python&quot;&gt;stackoverflow问答&lt;/a&gt;可以自定义一个函数批量对pdf进行转换(文末附有该函数)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;批量提取PDF内容的代码&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# ref: https://stackoverflow.com/questions/26494211/extracting-text-from-a-pdf-file-using-pdfminer-in-python

from pdfminer.pdfinterp import PDFResourceManager, PDFPageInterpreter
from pdfminer.converter import TextConverter
from pdfminer.layout import LAParams
from pdfminer.pdfpage import PDFPage
from io import StringIO

def convert_pdf_to_txt(path):
    rsrcmgr = PDFResourceManager()
    retstr = StringIO()
    codec = 'utf-8'
    laparams = LAParams()
    device = TextConverter(rsrcmgr, retstr, codec=codec, laparams=laparams)
    fp = open(path, 'rb')
    interpreter = PDFPageInterpreter(rsrcmgr, device)
    password = &quot;&quot;
    maxpages = 0
    caching = True
    pagenos=set()

    for page in PDFPage.get_pages(fp, pagenos, maxpages=maxpages, password=password,caching=caching, check_extractable=True):
        interpreter.process_page(page)

    text = retstr.getvalue()

    fp.close()
    device.close()
    retstr.close()
    return text
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;textract使用示例&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import textract

# 文件路径
file_pdf = os.path.join(workdir,'Data/demo_pdf.pdf')

# 提取文本
text = textract.process(file_pdf)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;word文档&quot;&gt;word文档&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://python-docx.readthedocs.io/en/latest/&quot;&gt;python-docx&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;其他统计软件生成文件&quot;&gt;其他统计软件生成文件&lt;/h2&gt;
&lt;p&gt;可以使用的工具包：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;pandas.read_sas&lt;/code&gt;, &lt;code&gt;pandas.read_spss&lt;/code&gt;, &lt;code&gt;pandas.read_stata&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Roche/pyreadstat&quot;&gt;pyreadstat&lt;/a&gt;，可以读取SAS,SPSS,Stata等统计软件导出的数据文件。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;SPSS生成的.sav文件&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 使用Python读取.sav文件
# https://github.com/Roche/pyreadstat
import pyreadstat

# 文件路径
file_data = os.path.join(workdir,'Data/demo_sav.sav')

# 读取文件
df,meta = pyreadstat.read_sav(file_data)
# df就是转化后的数据框

# 查看编码格式
print(meta.file_encoding)

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;pyreadstat包还可以读取sas,stat的数据文件&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Function in this package&lt;/th&gt;
&lt;th&gt;Purpose&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr&gt;&lt;td&gt;read_sas7dat&lt;/td&gt;
&lt;td&gt;read SAS sas7bdat files&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;read_xport&lt;/td&gt;
&lt;td&gt;read SAS Xport (XPT) files&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;read_sas7bcat&lt;/td&gt;
&lt;td&gt;read SAS catalog files&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;read_dta&lt;/td&gt;
&lt;td&gt;read STATA dta files&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;read_sav&lt;/td&gt;
&lt;td&gt;read SPSS sav and zsav files&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;read_por&lt;/td&gt;
&lt;td&gt;read SPSS por files&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;set_catalog_to_sas&lt;/td&gt;
&lt;td&gt;enrich sas dataframe with catalog formats&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;set_value_labels&lt;/td&gt;
&lt;td&gt;replace values by their labels&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;</description>
<pubDate>Tue, 24 Mar 2020 00:33:00 +0000</pubDate>
<dc:creator>dataxon</dc:creator>
<og:description>用python读写常见的数据文件，包括：txt、csv、xlsx、网页数据、PDF、word等</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/dataxon/p/12556727.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core应用的7种依赖注入方式 - Artech</title>
<link>http://www.cnblogs.com/artech/p/di-in-asp-net-core-3.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/artech/p/di-in-asp-net-core-3.html</guid>
<description>&lt;div id=&quot;cnblogs_post_description&quot; readability=&quot;35&quot;&gt;&lt;img src=&quot;http://images.cnblogs.com/cnblogs_com/artech/158198/o_.netcore.png&quot; class=&quot;desc_img&quot;/&gt;ASP.NET Core框架中的很多核心对象都是通过依赖注入方式提供的，如用来对应用进行初始化的Startup对象、中间件对象，以及ASP.NET Core MVC应用中的Controller对象和View对象等，所以我们可以在定义它们的时候采用注入的形式来消费已经注册的服务。下面简单介绍几种服务注入的应用场景。&lt;/div&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;148.90793945011&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/19327/202003/19327-20200323202521281-805820578.jpg&quot;&gt;&lt;img width=&quot;158&quot; height=&quot;206&quot; title=&quot;19327-20200323085612647-219130351&quot; align=&quot;right&quot; alt=&quot;19327-20200323085612647-219130351&quot; src=&quot;https://img2020.cnblogs.com/blog/19327/202003/19327-20200323202521576-819392510.jpg&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;ASP.NET Core框架中的很多核心对象都是通过依赖注入方式提供的，如用来对应用进行初始化的Startup对象、中间件对象，以及ASP.NET Core MVC应用中的Controller对象和View对象等，所以我们可以在定义它们的时候采用注入的形式来消费已经注册的服务。下面简单介绍几种服务注入的应用场景。本篇文章节选自《ASP.NET Core 3框架揭秘》，针对本书的5折优惠还有&lt;span&gt;最后2天&lt;/span&gt;，有兴趣可以扫描右边二维码或者从&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-3-sale.html&quot;&gt;这里&lt;/a&gt;入群购买。。&lt;/p&gt;

&lt;p&gt;构成HostBuilderContext上下文的两个核心对象（表示配置的&lt;span&gt;IConfiguration&lt;/span&gt;对象和表示承载环境的&lt;span&gt;IHostEnvironment&lt;/span&gt;对象）可以直接注入Startup构造函数中进行消费。由于ASP.NET Core应用中的承载环境通过IWebHostEnvironment接口表示，IWebHostEnvironment接口派生于IHostEnvironment接口，所以也可以通过注入&lt;span&gt;IWebHostEnvironment&lt;/span&gt;对象的方式得到当前承载环境相关的信息。&lt;/p&gt;
&lt;p&gt;我们可以通过一个简单的实例来验证针对Startup的构造函数注入。如下面的代码片段所示，我们在调用IWebHostBuilder接口的Startup&amp;lt;TStartup&amp;gt;方法时注册了自定义的Startup类型。在定义Startup类型时，我们在其构造函数中注入上述3个对象，提供的调试断言不仅证明了3个对象不为Null，还表明采用IHostEnvironment接口和IWebHostEnvironment接口得到的其实是同一个实例。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
    {
        Host.CreateDefaultBuilder().ConfigureWebHostDefaults(builder &lt;/span&gt;=&amp;gt; builder.UseStartup&amp;lt;Startup&amp;gt;&lt;span&gt;())
        .Build()
        .Run();
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Startup
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Startup(&lt;span&gt;IConfiguration configuration, IHostEnvironment hostingEnvironment,IWebHostEnvironment webHostEnvironment&lt;/span&gt;)
    {
        Debug.Assert(configuration &lt;/span&gt;!= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        Debug.Assert(hostingEnvironment &lt;/span&gt;!= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        Debug.Assert(webHostEnvironment &lt;/span&gt;!= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        Debug.Assert(ReferenceEquals(hostingEnvironment, webHostEnvironment));
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app) { }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;依赖服务还可以直接注入用于注册中间件的Configure方法中。如果构造函数注入还可以对注入的服务有所选择，那么对于Configure方法来说，通过任意方式注册的服务都可以注入其中，包括通过调用IHostBuilder、IWebHostBuilder和Startup自身的ConfigureServices方法注册的服务，还包括框架自行注册的所有服务。&lt;/p&gt;
&lt;p&gt;如下面的代码代码片段所示，我们分别调用IWebHostBuilder和Startup的ConfigureServices方法注册了针对IFoo接口和IBar接口的服务，这两个服务直接注入Startup的Configure方法中。另外，Configure方法要求提供一个用来注册中间件的IApplicationBuilder对象作为参数，但是对该参数出现的位置并未做任何限制。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
    {
        Host.CreateDefaultBuilder().ConfigureWebHostDefaults(builder &lt;/span&gt;=&amp;gt;&lt;span&gt; builder
            .UseStartup&lt;/span&gt;&amp;lt;Startup&amp;gt;&lt;span&gt;()
            .ConfigureServices(svcs &lt;/span&gt;=&amp;gt; svcs.AddSingleton&amp;lt;IFoo, Foo&amp;gt;&lt;span&gt;()))
        .Build()
        .Run();
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Startup
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ConfigureServices(IServiceCollection services) =&amp;gt; services.AddSingleton&amp;lt;IBar, Bar&amp;gt;&lt;span&gt;();
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app, &lt;span&gt;IFoo foo, IBar bar&lt;/span&gt;)
    {
        Debug.Assert(foo &lt;/span&gt;!= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        Debug.Assert(bar &lt;/span&gt;!= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;ASP.NET Core请求处理管道最重要的对象是用来真正处理请求的中间件。由于ASP.NET Core在创建中间件对象并利用它们构建整个请求处理管道时，所有的服务都已经注册完毕，所以任何一个注册的服务都可以注入中间件类型的构造函数中。如下所示的代码片段体现了针对中间件类型的构造函数注入。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
    {
        Host.CreateDefaultBuilder().ConfigureWebHostDefaults(builder &lt;/span&gt;=&amp;gt;&lt;span&gt; builder
            .ConfigureServices(svcs &lt;/span&gt;=&amp;gt;&lt;span&gt; svcs
                .AddSingleton&lt;/span&gt;&amp;lt;FoobarMiddleware&amp;gt;&lt;span&gt;()
                .AddSingleton&lt;/span&gt;&amp;lt;IFoo, Foo&amp;gt;&lt;span&gt;()
                .AddSingleton&lt;/span&gt;&amp;lt;IBar, Bar&amp;gt;&lt;span&gt;())
            .Configure(app &lt;/span&gt;=&amp;gt; app.UseMiddleware&amp;lt;FoobarMiddleware&amp;gt;&lt;span&gt;()))
        .Build()
        .Run();
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FoobarMiddleware : IMiddleware
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; FoobarMiddleware(&lt;span&gt;IFoo foo, IBar bar&lt;/span&gt;)
    {
        Debug.Assert(foo &lt;/span&gt;!= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        Debug.Assert(bar &lt;/span&gt;!= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Task InvokeAsync(HttpContext context, RequestDelegate next)
    {
        Debug.Assert(next &lt;/span&gt;!= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Task.CompletedTask;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果采用基于约定的中间件类型定义方式，注册的服务还可以直接注入真正用于处理请求的InvokeAsync方法或者Invoke方法中。另外，将方法命名为InvokeAsync更符合TAP（Task-based Asynchronous Pattern）编程模式，之所以保留Invoke方法命名，主要是出于版本兼容的目的。如下所示的代码片段展示了针对InvokeAsync方法的服务注入。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
    {
        Host.CreateDefaultBuilder().ConfigureWebHostDefaults(builder &lt;/span&gt;=&amp;gt;&lt;span&gt; builder
            .ConfigureServices(svcs &lt;/span&gt;=&amp;gt;&lt;span&gt; svcs
                .AddSingleton&lt;/span&gt;&amp;lt;IFoo, Foo&amp;gt;&lt;span&gt;()
                .AddSingleton&lt;/span&gt;&amp;lt;IBar, Bar&amp;gt;&lt;span&gt;())
            .Configure(app &lt;/span&gt;=&amp;gt; app.UseMiddleware&amp;lt;FoobarMiddleware&amp;gt;&lt;span&gt;()))
        .Build()
        .Run();
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FoobarMiddleware
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; RequestDelegate _next;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; FoobarMiddleware(RequestDelegate next) =&amp;gt; _next =&lt;span&gt; next;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Task InvokeAsync(HttpContext context,&lt;span&gt; IFoo foo, IBar bar&lt;/span&gt;)
    {
        Debug.Assert(context &lt;/span&gt;!= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        Debug.Assert(foo &lt;/span&gt;!= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        Debug.Assert(bar &lt;/span&gt;!= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; _next(context);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;虽然约定定义的中间件类型和Startup类型采用了类似的服务注入方式，它们都支持构造函数注入和方法注入，但是它们之间有一些差别。中间件类型的构造函数、Startup类型的Configure方法和中间件类型的Invoke方法或者InvokeAsync方法都具有一个必需的参数，其类型分别为RequestDelegate、IApplicationBuilder和HttpContext，对于该参数在整个参数列表的位置，前两者都未做任何限制，只有后者要求表示当前请求上下文的参数HttpContext必须作为方法的第一个参数。按照上述约定，如下这个中间件类型FoobarMiddleware的定义是不合法的，但是Starup类型的定义则是合法的。对于这一点，笔者认为可以将这个限制放开，这样不仅使中间件类型的定义更加灵活，还能保证注入方式的一致性。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FoobarMiddleware
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; FoobarMiddleware(RequestDelegate next);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Task InvokeAsync(IFoo foo, IBar bar, HttpContext context);
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Startup
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IFoo foo, IBar bar, IApplicationBuilder app);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于基于约定的中间件，构造函数注入与方法注入存在一个本质区别。由于中间件被注册为一个&lt;span&gt;Singleton&lt;/span&gt;对象，所以我们不应该在它的构造函数中注入&lt;span&gt;Scoped&lt;/span&gt;服务。&lt;span&gt;Scoped服务只能注入中间件类型的InvokeAsync方法中&lt;/span&gt;，因为依赖服务是在针对当前请求的服务范围中提供的，所以能够确保Scoped服务在当前请求处理结束之后被释放。&lt;/p&gt;

&lt;p&gt;在一个ASP.NET Core MVC应用中，我们可以在定义的Controller中以构造函数注入的方式注入所需的服务。在如下所示的代码片段中，我们将IFoobar服务注入到HomeController的构造函数中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
    {
        Host.CreateDefaultBuilder().ConfigureWebHostDefaults(builder &lt;/span&gt;=&amp;gt;&lt;span&gt; builder
            .ConfigureServices(svcs &lt;/span&gt;=&amp;gt;&lt;span&gt; svcs
                .AddSingleton&lt;/span&gt;&amp;lt;IFoobar, Foobar&amp;gt;&lt;span&gt;()
                .AddSingleton&lt;/span&gt;&amp;lt;IBar, Bar&amp;gt;&lt;span&gt;()
                .AddControllersWithViews())
            .Configure(app &lt;/span&gt;=&amp;gt;&lt;span&gt; app
                .UseRouting()
                .UseEndpoints(endpoints &lt;/span&gt;=&amp;gt;&lt;span&gt; endpoints.MapControllers())))
        .Build()
        .Run();
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HomeController : Controller
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; HomeController(&lt;span&gt;IFoobar foobar&lt;/span&gt;) =&amp;gt; Debug.Assert(foobar != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;借助于ASP.NET Core MVC基于模型绑定的参数绑定机制，我们可以将注册的服务绑定到目标Action方法的参数上，进而实现针对Action方法的依赖注入。在采用这种类型的注入方式时，我们需要在注入参数上按照如下的方式标注&lt;span&gt;FromServicesAttribute&lt;/span&gt;特性，用以确定参数绑定的来源是注册的服务。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
    {
        Host.CreateDefaultBuilder().ConfigureWebHostDefaults(builder &lt;/span&gt;=&amp;gt;&lt;span&gt; builder
            .ConfigureServices(svcs &lt;/span&gt;=&amp;gt;&lt;span&gt; svcs
                .AddSingleton&lt;/span&gt;&amp;lt;IFoobar, Foobar&amp;gt;&lt;span&gt;()
                .AddControllersWithViews())
            .Configure(app &lt;/span&gt;=&amp;gt;&lt;span&gt; app
                .UseRouting()
                .UseEndpoints(endpoints &lt;/span&gt;=&amp;gt;&lt;span&gt; endpoints.MapControllers())))
        .Build()
        .Run();
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HomeController: Controller
{
    [HttpGet(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Index(&lt;span&gt;[FromServices]IFoobar foobar&lt;/span&gt;)
    {
        Debug.Assert(foobar &lt;/span&gt;!= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在ASP.NET Core MVC应用中，我们还可以将服务注册到现的View中。假设我们定义了如下这个简单的MVC程序，并定义了一个简单的HomeController。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
    {
        Host.CreateDefaultBuilder().ConfigureWebHostDefaults(builder &lt;/span&gt;=&amp;gt;&lt;span&gt; builder
            .ConfigureServices(svcs &lt;/span&gt;=&amp;gt;&lt;span&gt; svcs
                .AddSingleton&lt;/span&gt;&amp;lt;IFoobar, Foobar&amp;gt;&lt;span&gt;()
                .AddControllersWithViews())
            .Configure(app &lt;/span&gt;=&amp;gt;&lt;span&gt; app
                .UseRouting()
                .UseEndpoints(endpoints &lt;/span&gt;=&amp;gt;&lt;span&gt; endpoints.MapControllers())))
        .Build()
        .Run();
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HomeController: Controller
{
        [HttpGet(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IActionResult Index() =&amp;gt;&lt;span&gt; View();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们为HomeController定义了一个路由指向根路径（“/”）的Action方法Index，该方法在调用View方法呈现默认的View之前，将注入的IFoo服务以ViewBag的形式传递到View中。如下所示的代码片段是这个Action方法对应View（/Views/Home/Index.cshtml）的定义，我们通过@inject指令注入了IFoobar服务，并将属性名设置为Foobar，这意味着当前View对象将添加一个Foobar属性来引用注入的服务。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@inject IFoobar Foobar
@
{
    Debug.Assert(Foobar&lt;/span&gt;!= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;</description>
<pubDate>Tue, 24 Mar 2020 00:24:00 +0000</pubDate>
<dc:creator>Artech</dc:creator>
<og:description>ASP.NET Core框架中的很多核心对象都是通过依赖注入方式提供的，如用来对应用进行初始化的Startup对象、中间件对象，以及ASP.NET Core MVC应用中的Controller对象和V</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/artech/p/di-in-asp-net-core-3.html</dc:identifier>
</item>
<item>
<title>高德车载导航的差分更新优化实践 - 高德技术</title>
<link>http://www.cnblogs.com/amap_tech/p/12556697.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/amap_tech/p/12556697.html</guid>
<description>&lt;p&gt;本文小结了高德车载导航在版本自更新演进过程中二进制差分解决方案的性能优化实践。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;149&quot;&gt;
&lt;p&gt;&lt;strong&gt;导读&lt;/strong&gt;&lt;br/&gt;随着车载设备联网化，越来越多的车载设备从离线走到了线上。高德车载导航也早已从过去的离线安装包更新演进到了在线迭代更新。但原车载设备的Android硬件配置远低于手机，主要表现在处理器主频低、内存和存储空间有限，导致车载导航在车机上会出现无法下载新版本数据包、更新过程耗时长导致卡顿的情况，对导航应用的性能提出了要求。&lt;/p&gt;
&lt;p&gt;为提高用户体验，高德技术团队立项解决了该问题。本文小结了高德车载导航在版本自更新演进过程中二进制差分解决方案的性能优化实践。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;差分更新方案比较&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于应用程序的版本更新迭代，除了分发全量的安装包，还有一种更低成本的方式是分发增量包，即通过下发前后两个版本的差异部分(这个过程下面简称Diff)，然后在客户端对原版本进行补丁更新(这个过程下面简称Patch)。因此也叫差分更新。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;业内比较流行的差分方案主要有: bsdiff、Xdelta3和Courgette。&lt;/strong&gt;最后一个方案Courgette来自于谷歌，主要解决的是可执行文件的差分，而导航更新资源不仅包含可执行文件，还包含了图片等各种资源文件。所以，我们主要对比bsdiff和Xdelta3方案。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;bsdiff和Xdelta3方案比较&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面是我们对选取的几个文件做的bsdiff和Xdelta3差分性能对比：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1521790/202003/1521790-20200324081628631-47673552.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;bsdiff的优势是压缩比高，生成的差分文件非常小，但Patch过程耗时。而Xdelta3的优势是Patch过程耗时极短，但内存消耗非常大。&lt;/p&gt;
&lt;p&gt;相比高德车载导航自身运行内存开销不足100MB的情况，Xdelta3的Patch内存消耗无法接受。因此我们选用了bsdiff作为自更新方案。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原生bsdiff方案缺陷与改进&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;原生bsdiff方案使得压缩比问题得到解决，但在车载导航自更新中还存在下面两个缺陷：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;内存消耗大，整个过程会占用10~35MB左右的内存。&lt;/li&gt;
&lt;li&gt;耗时长，整个包更新时间在3分钟左右。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在对bsdiff的优化探索中我们发现Chromium开源项目中存在一份基于bsdiff的优化版本。该版本将bsidff的默认sufsort算法替换成了divsufsort算法，在Patch时间上有了较大的提升。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1521790/202003/1521790-20200324081719212-1228845872.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1521790/202003/1521790-20200324081730473-1858176519.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用Chromium版本的bsdiff, 高德车载导航的自更新性能如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;内存消耗在10~20MB。&lt;/li&gt;
&lt;li&gt;整个Patch过程耗时仍然长达25秒左右。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;耗时依然很长。&lt;/p&gt;
&lt;p&gt;由于Patch过程是一个CPU密集型的操作，且车载设备CPU的性能普遍不足，这意味着在整个升级过程中用户能明显感受到导航的操作卡顿。同时，更新时间越长意味着遭遇断电的可能性也越大。&lt;/p&gt;
&lt;p&gt;基于以上分析，我们决定对Chromium版本的bsdiff进行CPU和内存上的性能优化。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;bsdiff在车载自更新业务中的性能优化实践&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在车载自更新业务上，我们设定的目标是整体更新时间小于6秒，且内存开销小于2MB。整个优化的过程就是围绕时间和空间的取舍。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;内存优化方案&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;经过对bsdiff源码的分析，其Patch内存主要开销来自文件内容在内存中的读写暂存和Bzip2的解压开销。通过调整Bzip2参数可以降低部分内存，但无法达到期望。而文件读写的内存占用主要来自于其在内存中的暂存。&lt;/p&gt;
&lt;p&gt;基于bsdiff差分Patch包的文件格式，我们增加了滑动窗口缓冲区的Patch特性，使其在文件的流式处理上能够有更好的内存消耗可控性。每次读取和写入指定的滑动窗口大小数据，使数据即来即走。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;算法优化方案&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;经过上述的优化后，Patch过程的主要性能瓶颈在于Bzip2的解压算法中，即使调整Bzip2参数也无法减少本身的计算量。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1521790/202003/1521790-20200324081816285-764452066.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;bsdiff差分算法的一个特性就是差分出的Patch数据包含了大量连续的01冗余数据，而Bzip2算法的优点就是对这类数据可以做到高度的压缩，这也是bsdiff压缩比高的原因。不过现在是目前的瓶颈。&lt;/p&gt;
&lt;p&gt;此外，我们会制作软件整体的压缩差分包(即生成tar.bz2或zip格式文件)，也就是说针对每个Bzip2压缩后的差分文件还要再经过一次压缩归档。这也意味着在客户段要进行两次的解压。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;替换压缩算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;类似的冗余压缩算法有RLE(Run-length encoding)，这个算法也是Bzip2算法的第一步。简单来说RLE算法就是针对连续多个冗余字节去掉其冗余字节，仅保留冗余的长度信息。这个算法相对更简单。&lt;/p&gt;
&lt;p&gt;因此，我们将Bzip2压缩算法替换成了RLE算法，实际结果发现生成的Patch文件很大, 压缩比很低。但是可以通过再次压缩归档制作一次差分包，就可以达到和Bzip2几乎相同的压缩比效果。唯一的不足就是在客户端解压后会占用多一些磁盘空间, 而这个代价相对廉价多了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优化性能对比&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;经过上述整体优化后，性能对比如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1521790/202003/1521790-20200324081850732-1946715089.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;经过内存优化后的方案空间复杂度将为了O(1)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1521790/202003/1521790-20200324081917505-962230901.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面的耗时差异在ARM车机会更明显：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1521790/202003/1521790-20200324081931912-2108853324.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最终优化收益：内存消耗控制在2MB以内，整体Patch更新耗时3~5秒。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;br/&gt;通过对bsdiff的优化，高德车载导航在自更新性能上取得了较大收益。大幅缩短了用户下载和更新时间，降低了对ARM车机的硬件资源要求。为推动车载导航OTA更新提供了技术基础，对未来高德车载导航在分发新功能、新业务上铺平了道路。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1521790/202003/1521790-20200324082105489-1296316983.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Tue, 24 Mar 2020 00:20:00 +0000</pubDate>
<dc:creator>高德技术</dc:creator>
<og:description>本文小结了高德车载导航在版本自更新演进过程中二进制差分解决方案的性能优化实践。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/amap_tech/p/12556697.html</dc:identifier>
</item>
<item>
<title>asp.net core 3.1 引用的元包dll版本兼容性问题解决方案 - 沐雪小程序开发者</title>
<link>http://www.cnblogs.com/puzi0315/p/12556138.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/puzi0315/p/12556138.html</guid>
<description>&lt;p&gt;自从.netcore 3.1出来后，大家都想立马升级到最新版本。我也是如此，微软也对&lt;a href=&quot;http://www.zyiz.net/xilie-293.html&quot; target=&quot;_blank&quot;&gt;.netcore 3.1&lt;/a&gt;的官方组件不断升级，几乎每隔几天就会有部分元包可以升级。每次打开Nuget包管理器，“更新”的tab处总会有个数字暗示着你快点升级！一向有代码洁癖的同学（包括我），都会毫不犹豫的点击“全部升级”。我们总是幻想着使用更高的版本，可以获取更牛的功能和更快的性能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/3/23/17107fca8066cbb6?w=1232&amp;amp;h=568&amp;amp;f=png&amp;amp;s=68175&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可惜，梦想是好的，结局却是残酷的。升级后，却发现有很多错误。.netcore 3.1的确在性能方面有极大的提升，各个方面都比.netcore 2.2强多了，但是，其生态还没有完全的发展起来，很多第3方组件依旧还是netcore2.2的版本甚至更低。这个时候最让人头疼的就是包的版本问题，比如如下错误：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
MuXue.Zyiz.Net.WebAPI/MuXue.Zyiz.Net.WebAPI.csproj : error NU1605: Detected package downgrade: System.Threading.ThreadPool &lt;span&gt;from&lt;/span&gt; 4.3.0 to 4.0.10. Reference the package directly &lt;span&gt;from&lt;/span&gt; the project to select a different version. 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;error NU1605: Detected package downgrade的中文意思是“错误NU1605:检测到包降级 ”。大家都知道，元包里还包含很多子的组件，多个元包之间引用的子组件版本不一致，就会造成这个错误。这种情况在.netcore 3.1目前的情况下经常出现。&lt;/p&gt;
&lt;p&gt;根据&lt;a href=&quot;http://www.zyiz.net/xilie-293.html&quot; target=&quot;_blank&quot;&gt;官方教程&lt;/a&gt;的知道方案得出解决方案如下：&lt;/p&gt;
&lt;p&gt;强制将版本不一致的包升级到统一的版本，（比如我们这里的System.Threading.ThreadPool）&lt;/p&gt;
&lt;p&gt;双击MuXue.Zyiz.Net.WebAPI.csproj项目，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 &amp;lt;ItemGroup&amp;gt;
    &amp;lt;PackageReference Include=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AutoMapper&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Version=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;9.0.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
    &amp;lt;PackageReference Include=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AutoMapper.Extensions.Microsoft.DependencyInjection&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Version=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;7.0.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
    &amp;lt;PackageReference Include=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Consul&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Version=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0.7.2.6&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
    &amp;lt;PackageReference Include=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;FluentValidation.AspNetCore&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Version=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;8.6.1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
    &amp;lt;PackageReference Include=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Microsoft.AspNetCore.Authentication.JwtBearer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Version=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;3.1.1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
    &amp;lt;PackageReference Include=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Microsoft.EntityFrameworkCore&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Version=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;3.1.1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
    &amp;lt;PackageReference Include=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Microsoft.EntityFrameworkCore.SqlServer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Version=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;3.1.1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
    &amp;lt;PackageReference Include=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Microsoft.VisualStudio.Web.CodeGeneration.Design&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Version=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;3.1.1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
    &amp;lt;PackageReference Include=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;NLog.Web.AspNetCore&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Version=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;4.9.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
    &amp;lt;PackageReference Include=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SkyAPM.Agent.AspNetCore&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Version=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0.9.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
    &amp;lt;PackageReference Include=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Swashbuckle.AspNetCore&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Version=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;5.0.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
    &amp;lt;PackageReference Include=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;System.Text.Json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Version=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;4.7.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
    &amp;lt;PackageReference Include=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;System.Net.NameResolution&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Version=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;4.3.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
    &amp;lt;PackageReference Include=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;System.Threading.ThreadPool&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Version=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;4.3.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
  &amp;lt;/ItemGroup&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;看到这行代码：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;PackageReference Include=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;System.Threading.ThreadPool&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Version=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;4.3.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;将这个组件统一指定为4.3.0版本，问题就解决了。&lt;/p&gt;

</description>
<pubDate>Mon, 23 Mar 2020 15:31:00 +0000</pubDate>
<dc:creator>沐雪小程序开发者</dc:creator>
<og:description>自从.netcore 3.1出来后，大家都想立马升级到最新版本。我也是如此，微软也对.netcore 3.1的官方组件不断升级，几乎每隔几天就会有部分元包可以升级。每次打开Nuget包管理器，“更新”</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/puzi0315/p/12556138.html</dc:identifier>
</item>
<item>
<title>微信小程序开发中的http请求总结 - 飘羽</title>
<link>http://www.cnblogs.com/RobinGao/p/12556078.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/RobinGao/p/12556078.html</guid>
<description>&lt;p&gt;在微信小程序进行网络通信，只能和指定的域名进行通信，微信小程序包括四种类型的网络请求。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;普通HTTPS请求(wx.request)&lt;/li&gt;
&lt;li&gt;上传文件(wx.uploadFile)&lt;/li&gt;
&lt;li&gt;下载文件(wx.downloadFile)&lt;/li&gt;
&lt;li&gt;WebSocket通信(wx.connectSocket)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里以介绍&lt;code&gt;wx.request&lt;/code&gt;,&lt;code&gt;wx.uploadFile&lt;/code&gt;,&lt;code&gt;wx.dowloadFile&lt;/code&gt;三种网络请求为主&lt;/p&gt;
&lt;h4 data-id=&quot;heading-0&quot;&gt;设置域名&lt;/h4&gt;
&lt;p&gt;要微信小程序进行网络通信，必须先设置域名，不然会出现错误:&lt;/p&gt;
&lt;blockquote&gt;
&lt;h5 data-id=&quot;heading-1&quot;&gt;URL 域名不合法，请在 mp 后台配置后重试&lt;/h5&gt;
&lt;/blockquote&gt;
&lt;p&gt;需要在微信公众平台的小程序中设置域名。&lt;br/&gt;在微信小程序的&lt;a href=&quot;https://mp.weixin.qq.com/wxopen/devprofile&quot; rel=&quot;nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;设置界面&lt;/a&gt;可以看到设置选项：&lt;/p&gt;
&lt;div&gt;&lt;img class=&quot;lazyload inited loaded&quot; src=&quot;https://user-gold-cdn.xitu.io/2016/11/29/6ae29780e61402cacb5c34e8f4a2e166?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot; width=&quot;459&quot; height=&quot;846&quot; data-src=&quot;https://user-gold-cdn.xitu.io/2016/11/29/6ae29780e61402cacb5c34e8f4a2e166?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; data-width=&quot;800&quot; data-height=&quot;600&quot;/&gt;&lt;/div&gt;
&lt;p&gt;选择&lt;code&gt;开发设置&lt;/code&gt;：&lt;/p&gt;
&lt;div&gt;&lt;img class=&quot;lazyload inited loaded&quot; src=&quot;https://user-gold-cdn.xitu.io/2016/11/29/aee08076a738520dcd1d8ff091926c9e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot; width=&quot;496&quot; height=&quot;185&quot; data-src=&quot;https://user-gold-cdn.xitu.io/2016/11/29/aee08076a738520dcd1d8ff091926c9e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; data-width=&quot;800&quot; data-height=&quot;600&quot;/&gt;&lt;p&gt;开发设置&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;可以看到服务器设置:&lt;/p&gt;
&lt;div&gt;&lt;img class=&quot;lazyload inited loaded&quot; src=&quot;https://user-gold-cdn.xitu.io/2016/11/29/f8657cec10e03452a573aee48eb72f41?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot; width=&quot;795&quot; height=&quot;250&quot; data-src=&quot;https://user-gold-cdn.xitu.io/2016/11/29/f8657cec10e03452a573aee48eb72f41?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; data-width=&quot;800&quot; data-height=&quot;600&quot;/&gt;&lt;p&gt;服务器设置&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;在这里可以设置对应四种网络访问的域名，每一种类型的网络请求需要设置一个域名，注意如果在这里设置域名为&lt;code&gt;https://example.com/api/&lt;/code&gt;,那么&lt;code&gt;https://example.com/api&lt;/code&gt;是无法调用的，必须加上后面&lt;code&gt;/&lt;/code&gt;。&lt;/p&gt;
&lt;h4 data-id=&quot;heading-2&quot;&gt;http请求&lt;/h4&gt;
&lt;p&gt;使用&lt;code&gt;wx.request&lt;/code&gt;可以发起一个http请求，一个微信小程序被限制为同时只有5个网络请求。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; queryRequest(data){    
    wx.request({
        url:&lt;/span&gt;&quot;https://example.com/api/&quot;&lt;span&gt;,
        data:data,
        header:{
           &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; &quot;Content-Type&quot;:&quot;application/json&quot;&lt;/span&gt;
&lt;span&gt;        },
        success:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(res){
            console.log(res.data)
        },
        fail:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(err){
            console.log(err)
        }

    })

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上面的代码会发送一个http get请求，然后打印出返回的结果。其中的参数也比较容易理解。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;url&lt;/code&gt; 服务器的url地址&lt;/li&gt;
&lt;li&gt;&lt;code&gt;data&lt;/code&gt; 请求的参数可以采用String &lt;code&gt;data:&quot;xxx=xxx&amp;amp;xxx=xxx&quot;&lt;/code&gt;的形式或者Object &lt;code&gt;data:{&quot;userId&quot;:1}&lt;/code&gt;的形式&lt;/li&gt;
&lt;li&gt;&lt;code&gt;header&lt;/code&gt; 设置请求的header&lt;/li&gt;
&lt;li&gt;&lt;code&gt;success&lt;/code&gt; 接口成功的回调&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fail&lt;/code&gt; 接口失败的回调&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;另外还有两个参数没有在代码里:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;method&lt;/code&gt; http的方法,默认为GET请求&lt;/li&gt;
&lt;li&gt;&lt;code&gt;complete&lt;/code&gt; 调用接口结束之后的回调，无论成功或者失败该接口都会被调用&lt;/li&gt;
&lt;/ul&gt;&lt;h4 data-id=&quot;heading-3&quot;&gt;上传文件&lt;/h4&gt;
&lt;p&gt;上传文件的api为&lt;code&gt;wx.uploadFile&lt;/code&gt;，该api会发起一个&lt;code&gt;http post&lt;/code&gt;请求，其中的&lt;code&gt;Content-type&lt;/code&gt;为&lt;code&gt;multipart/form-data&lt;/code&gt;。服务器端需要按照该&lt;code&gt;Content-type&lt;/code&gt;类型接收文件,示例代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; uploadFile(file,data) {
    wx.uploadFile({
        url: &lt;/span&gt;'http://example.com/upload'&lt;span&gt;,
        filePath: file,
        name: &lt;/span&gt;'file'&lt;span&gt;,
        formData:data,
        success:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(res){
            console.log(res.data)
        },
        fail:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(err){
            console.log(err)
        }

    })

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其中的&lt;code&gt;url&lt;/code&gt;，&lt;code&gt;header&lt;/code&gt;，&lt;code&gt;success&lt;/code&gt;，&lt;code&gt;fail&lt;/code&gt;以及&lt;code&gt;complete&lt;/code&gt;和普通的http请求是一样的。&lt;br/&gt;这里有区别的参数是:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;name&lt;/code&gt;文件对应的key，服务器端需要通过&lt;code&gt;name&lt;/code&gt;参数获取文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;formData&lt;/code&gt; http请求中可以使用的其他参数&lt;/li&gt;
&lt;/ul&gt;&lt;h4 data-id=&quot;heading-4&quot;&gt;下载文件&lt;/h4&gt;
&lt;p&gt;下载文件的api为&lt;code&gt;wx.downloadFile&lt;/code&gt;,该api会发起一个http get请求，并在下载成功之后返回文件的临时路径，示例代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; downloadFile(url,typ,success){
    wx.downloadFile({
        url:url,
        type:typ,
        success:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(res){
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(success){
                success(res.tempFilePath)
            }
        },
        fail:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(err){
            console.log(err)
        }
    })
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其中的&lt;code&gt;url&lt;/code&gt;,&lt;code&gt;header&lt;/code&gt;,&lt;code&gt;fail&lt;/code&gt;,&lt;code&gt;complete&lt;/code&gt;和&lt;code&gt;wx.uploadFile&lt;/code&gt;的参数使用是一致的，其中有区别的参数是:&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li&gt;&lt;code&gt;type&lt;/code&gt;:下载资源的类型，用于客户端自动识别，可以使用的参数&lt;code&gt;image/audio/video&lt;/code&gt;&lt;/li&gt;
&lt;li readability=&quot;7.5&quot;&gt;
&lt;p&gt;&lt;code&gt;success&lt;/code&gt;：下载成功之后的回调，以&lt;code&gt;tempFilePath&lt;/code&gt;的参数返回文件的临时目录：&lt;code&gt;res={tempFilePath:'文件路径'}&lt;/code&gt;&lt;br/&gt;下载成功后的是临时文件，只会在程序本次运行期间可以使用，如果需要持久的保存，需要调用方法&lt;code&gt;wx.saveFile&lt;/code&gt;主动持久化文件，实例代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
function svaeFile(tempFile,success){
  wx.saveFile({
      tempFilePath:tempFile,
      success:function(res){
          var svaedFile=res.savedFilePath
          if(success){
              success(svaeFile)
          }
      }
  })
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;使用&lt;code&gt;wx.saveFile&lt;/code&gt;保存临时文件到本地，提供给小程序下次启动时使用，其中的参数：&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;tempFilePath&lt;/code&gt; 需要被保存文件的路径&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;success&lt;/code&gt; 保存成功的回调，返回保存成功的路径，使用&lt;code&gt;res.savedFilePath&lt;/code&gt;可以获取保存成功的路径&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fail&lt;/code&gt; 失败的回调&lt;/li&gt;
&lt;li&gt;&lt;code&gt;complete&lt;/code&gt;结束的回调&lt;/li&gt;
&lt;/ul&gt;&lt;h4 data-id=&quot;heading-5&quot;&gt;超时的设置&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;app.js中调整设置：&lt;/code&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&quot;networkTimeout&quot;&lt;span&gt;:{
   &lt;/span&gt;&quot;request&quot;: 10000&lt;span&gt;,
   &lt;/span&gt;&quot;connectSocket&quot;: 10000&lt;span&gt;,
   &lt;/span&gt;&quot;uploadFile&quot;: 10000&lt;span&gt;,
   &lt;/span&gt;&quot;downloadFile&quot;: 10000&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里设置的超时时间对应着四种类型的网络请求。&lt;/p&gt;

</description>
<pubDate>Mon, 23 Mar 2020 15:18:00 +0000</pubDate>
<dc:creator>飘羽</dc:creator>
<og:description>小程序开发总结</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/RobinGao/p/12556078.html</dc:identifier>
</item>
<item>
<title>高性能-GC - 梦一回</title>
<link>http://www.cnblogs.com/ccaa/p/12556080.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ccaa/p/12556080.html</guid>
<description>&lt;p&gt;带着问题去思考！大家好&lt;/p&gt;
&lt;p&gt;相对.NET 来说。CLR去处理了，C,C++这些就需要手动去垃圾回收。&lt;/p&gt;
&lt;p&gt;　　GC大部分容易察觉的性能问题。其实很多问题实际是哪个都是由于对垃圾回收器的行为和预期结果理解有误。在,NET环境中，你需要更多的关注内存的性能，那么接下里我们主要是讲内存性能问题。&lt;/p&gt;
&lt;p&gt;　　GC实际上会调整体提高内存堆[1]的性能，因为他能高效的完成内存分配和碎片整理工作。&lt;/p&gt;
&lt;p&gt;　　在Windows的本机代码模式下，内存堆维护着一张空闲内存块的列表，用于内存的分配，尽量用低碎片化的内存堆，因为长时间运行，还要考虑内存碎片问题，内存占用率会持续增长。所以本机代码程序用大量代码实现了自己的内存分配机制，把默认的malloc函数给替换掉&lt;/p&gt;
&lt;p&gt;　　在.NET环境中，内存分配的工作量会很小，因为内存总是整段分配的。所以不会比内存的扩大，减小和比较增加多少开销，不存在遍历空闲内存列表，几乎不会出现内存碎片，GC内存堆的效率还会更高的，因为连续分配的多个对象往往在内存堆中也是连续存放，提高就近访问的可能性。&lt;/p&gt;
&lt;p&gt;　　在默认的内存分配流程中，有一小段代码会先检查目标对象的大小，看看内存分配缓冲区中所剩的内存够不够，如果内存分配缓冲区已耗尽，就会交由GC分配程序来检索足以容纳目标对象的空闲内存。然后一个新的分配缓冲区就会被保留下来。&lt;/p&gt;
&lt;p&gt;　　接下里看下内存分配的过程&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyObject
        {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; x;
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; y;
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; z;
        }
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; x = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyObject();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;了解汇编语言的都知道这一流程，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006793/202003/1006793-20200323215119935-78859847.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; MOV指令是数据传送指令,其他的大家可以自行去查约。大致是说，把类的方法表指针拷贝到ecx（计数暂存器）中，作为new （）的参数，调用new，把返回值（对象的地址）拷贝到寄存器中。这里大家大概了解一下就可以了&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;基本运作方式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;在托管进程中存在两种内存堆（本机堆和托管堆），这里我们说下托管堆，本机堆大大家可以自行了解下，&lt;/p&gt;
&lt;p&gt;CLR在托管堆（Managed Heap）上为所有的.NET托管对象分配内存，也称之为GC堆，因为其中的对象都要受到垃圾回收机制的控制。&lt;/p&gt;
&lt;p&gt;　　托管堆又分为两种，小对象堆和大对象堆（LOH）,都拥有自己的内存段（Segment&lt;span&gt;[ˈseɡmənt]&lt;/span&gt;）.内存段的大小视配置和硬件环境而定。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;小对象堆&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　小对象堆有什么？它又是怎么变化的？&lt;/p&gt;
&lt;p&gt;　　小对象堆的内存堆分为3代，0,1,2代。第0代和第1代总是位于同一个内存段中，第2代可能跨越多个内存段，LOH也可以跨越多个内存段。包含第0代和第1代堆的内存段被称为暂时段（Ephemeral &lt;span&gt;[ɪˈfemərəl] &lt;/span&gt;Segment &lt;span&gt;ˈseɡmənt]&lt;/span&gt;）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006793/202003/1006793-20200323221207159-2108745301.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　小对象堆中分配内存的对象生存期。&lt;span&gt;如果 对象小于85000字节，CLR会把它分配在小对象堆中的第0代&lt;/span&gt;，通常紧挨当前已用内存空间往后分配，如果扩大内存堆时超越了内存段的边界，则就会触发垃圾回收过程。&lt;/p&gt;
&lt;p&gt;　　对象总是诞生于第0代内存堆中，只要对象保持存活，每当发生垃圾回收时，GC都会把他提升一代。第0代和第1代内存堆的垃圾回收有时候被称为瞬时回收（Ephemeral Collection）&lt;/p&gt;
&lt;p&gt;　　在垃圾回收的时候，可能会进行碎片整理（Compaction），也及时GC把对象物理迁移到新的位置中去，以便让内存段中的空闲空间能够连续起来使用。如果为发生碎片整理，那就只需要重新调整各块内存的边界。以下是经历几次未做碎片整理的垃圾回收之后，内存堆的分布可能如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006793/202003/1006793-20200323223512802-785691708.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对象的位置没有移动，但是各代的内存堆的边界发生了变化。&lt;/p&gt;
&lt;p&gt;　　如果对象到达第2代内存堆，它就会一直留在哪里直至终结。但不代表第2代内存堆只会一直变大， 如果第2代内存堆中的对象都终结了，整个内存段有没有存活[2]的对象，垃圾回收器会把整个内存段交换给操作系统，或者作为其他几代内存堆的附加段，在进行完全垃圾回收（Full Garbge Collection）时，就会可能发生第2代内存堆的回收。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[2]:存活：GC能通过任一已知的GC跟对象（Root），沿着层层引用访问到某个对象，那么它是存活的。GC的根对象可以是程序中的静态变量，或者某个线程的堆栈被正在运行的方法占用（局部变量）或者GC句柄（比如固定对象的句柄，Pinned Handle），或是终结器队列（Finalizer Queue），有些对象可能没有受GC根对象的引用，但如果位于第2代内存堆中，那么第0代回收是不会清理这些对象的。只有完全垃圾回收才会被清理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 　　如果第0代堆即将占满一个内存段，垃圾回收也无法通过碎片整理获取足够空闲内存，那么GC会分配一个新的内存段。如图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006793/202003/1006793-20200323225425679-378856230.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 如果第2代堆继续变大，就可能会跨越多个内存段。LOH也是。但是无论存在多少内存段，第0代和第1代总是位于同一个内存段中。以后我们找出内存堆中有哪些对象存活时。这些会用到。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;LOH&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;LOH，大于85000字节的对象将自动在LOH中分配内存。没有代的概念，垃圾回收期间也不会自动进行碎片化整理，但是可以人为的碎片整理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;垃圾回收的时候会造成什么影响呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　垃圾回收是针对某一代及以下几代内存堆进行的。如果回收1代，就会回收0代。如果发生了第0代或第1代垃圾回收，程序在回收期间就会暂停运行，第二代垃圾回收，有部分回收是在后台线程运行进行的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;垃圾回收的4个阶段&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;挂起（Suspension）---在垃圾回收发生之前，所有托管线程都被强行中止&lt;/li&gt;
&lt;li&gt;标记（Mark）--从GC根对象开始，垃圾回收器沿着所有对象引用进行遍历并把所见对象记录下来&lt;/li&gt;
&lt;li&gt;碎片整理（Compact）--将对象重新紧挨着存放并更新所有引用，以便减少内存碎片，在小对象堆中，碎片整理会按需进行，无法控制。在LOH中，碎片整理不会自动进行，可以必要时通知垃圾回收器来上一次。&lt;/li&gt;
&lt;li&gt;恢复（Resume）--托管线程恢复运行&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在标记阶段，不需要遍历内存堆中的所有对象，只要访问那些需要回收的部分即。比如第0代回收只涉及到第0代内存堆中的对象，第1代回收将会标记第0代和第1代内存中的对象。第2代和完全回收，需要遍历内存堆中的所有存活对象，这一开销很大。&lt;/p&gt;
&lt;p&gt;　　1：垃圾回收过程的耗时几乎完全取决于所涉及的“代”内存堆中的对象数量，而不是你分配到的对象数量，你分配1棵包含100万个对象的树，只要在下次垃圾回收之前把根对象的引用解除。就不会增加垃圾回收的耗时&lt;/p&gt;
&lt;p&gt;　　2：只要已分配的内存超过某个内部阀值，就会发生这个代垃圾回收，这个阀值是持续变化的。GC会进行调整。&lt;/p&gt;
&lt;p&gt;计数器&lt;/p&gt;
</description>
<pubDate>Mon, 23 Mar 2020 15:18:00 +0000</pubDate>
<dc:creator>梦一回</dc:creator>
<og:description>带着问题去思考！大家好 相对.NET 来说。CLR去处理了，C,C++这些就需要手动去垃圾回收。 GC大部分容易察觉的性能问题。其实很多问题实际是哪个都是由于对垃圾回收器的行为和预期结果理解有误。在,</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ccaa/p/12556080.html</dc:identifier>
</item>
<item>
<title> LeetCode#232-Implement Queue using Stacks-用栈实现队列 - 鹿呦呦</title>
<link>http://www.cnblogs.com/sunshineliulu/p/12556052.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sunshineliulu/p/12556052.html</guid>
<description>&lt;h4 id=&quot;一、题目&quot;&gt;一、题目&lt;/h4&gt;
&lt;p&gt;使用栈实现队列的下列操作：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;push(x) -- 将一个元素放入队列的尾部。&lt;/li&gt;
&lt;li&gt;pop() -- 从队列首部移除元素。&lt;/li&gt;
&lt;li&gt;peek() -- 返回队列首部的元素。&lt;/li&gt;
&lt;li&gt;empty() -- 返回队列是否为空。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;示例:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;MyQueue queue = new MyQueue();

queue.push(1);
queue.push(2);  
queue.peek();  // 返回 1
queue.pop();   // 返回 1
queue.empty(); // 返回 false
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;你只能使用标准的栈操作 -- 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。&lt;/li&gt;
&lt;li&gt;你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。&lt;/li&gt;
&lt;li&gt;假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;二、题解&quot;&gt;二、题解&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;解法1：两个栈&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;队列是先进先出，栈是先进后出。所以可以用两个栈，新元素压入栈的时候，先将栈中的元素弹出，放到另一个栈中，把新元素压入到栈的底部，再把另一个栈的元素弹出，放回原栈中。此时，栈顶元素就是出队时要先出的队首元素。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/953680/202003/953680-20200323231031175-904812961.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里用的是数组表示队列，空间复杂度O(n)，时间复杂度分 push 和 pop ，前者是O(n)，后者是O(1)。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-php&quot;&gt;class MyQueue {
    /**
     * Initialize your data structure here.
     */
    function __construct() {
        $this-&amp;gt;stack1 = [];
        $this-&amp;gt;stack2 = [];
    }

    /**
     * Push element x to the back of queue.
     * @param Integer $x
     * @return NULL
     */
    function push($x) {
        while (!$this-&amp;gt;empty()) {
            $this-&amp;gt;stack2[] = array_pop($this-&amp;gt;stack1);
        }
        $this-&amp;gt;stack1[] = $x;
        while (!empty($this-&amp;gt;stack2)) {
            $this-&amp;gt;stack1[] = array_pop($this-&amp;gt;stack2);
        }
    }

    /**
     * Removes the element from in front of queue and returns that element.
     * @return Integer
     */
    function pop() {
        return array_pop($this-&amp;gt;stack1);
    }

    /**
     * Get the front element.
     * @return Integer
     */
    function peek() {
        return end($this-&amp;gt;stack1);
    }

    /**
     * Returns whether the queue is empty.
     * @return Boolean
     */
    function empty() {
        return empty($this-&amp;gt;stack1) ? true :false;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;解法2：两个栈&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;使用两个栈，一个栈（stack1）仅负责入栈，一个栈（stack2）仅负责出栈。有新元素入队时，直接将元素压入 stack1 即可。但当出队时，需要判断 stack2 是否为空，如果为空，将 stack1 的元素依次出栈，压入 stack2 中，随后从 stack2 弹出，即为出队。但当 stack2 不为空时，仍然直接从 stack2 出栈即可，知道 stack2 为空时，才可将 stack1 的元素拿出来放入 stack2 中。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/953680/202003/953680-20200323231054113-258115157.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里用的是数组表示队列，空间复杂度O(n)，时间复杂度分 push 和 pop ，前者是O(n)，后者是O(1)。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-php&quot;&gt;class MyQueue2 {
    /**
     * Initialize your data structure here.
     */
    function __construct() {
        $this-&amp;gt;stack1 = [];
        $this-&amp;gt;stack2 = [];
    }

    /**
     * Push element x to the back of queue.
     * @param Integer $x
     * @return NULL
     */
    function push($x) {
        $this-&amp;gt;stack1[] = $x;
    }

    /**
     * Removes the element from in front of queue and returns that element.
     * @return Integer
     */
    function pop() {
        if (empty($this-&amp;gt;stack2)) {
            while (!empty($this-&amp;gt;stack1)) {
                $this-&amp;gt;stack2[] = array_pop($this-&amp;gt;stack1);
            }
        }
        return array_pop($this-&amp;gt;stack2);
    }

    /**
     * Get the front element.
     * @return Integer
     */
    function peek() {
        if (empty($this-&amp;gt;stack2)) {
            while (!empty($this-&amp;gt;stack1)) {
                $this-&amp;gt;stack2[] = array_pop($this-&amp;gt;stack1);
            }
        }
        return end($this-&amp;gt;stack2);
    }

    /**
     * Returns whether the queue is empty.
     * @return Boolean
     */
    function empty() {
        return empty($this-&amp;gt;stack1) &amp;amp;&amp;amp; empty($this-&amp;gt;stack2) ? true : false;
    }
}
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 23 Mar 2020 15:13:00 +0000</pubDate>
<dc:creator>鹿呦呦</dc:creator>
<og:description>LeetCode#232-Implement Queue using Stacks-用栈实现队列</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sunshineliulu/p/12556052.html</dc:identifier>
</item>
</channel>
</rss>