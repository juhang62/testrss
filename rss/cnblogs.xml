<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>git之旅，畅游git的世界 - $小铭酱$</title>
<link>http://www.cnblogs.com/xiaomingjiang/p/11399512.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaomingjiang/p/11399512.html</guid>
<description>&lt;p&gt;今天小铭酱带大家探索一下git的奥秘！&lt;/p&gt;

&lt;p&gt;首先我在一个空的文件夹新建了一个名叫hello.html文件，文件内容只有一句话“hello git”。我们先引入git，看看git能为我们它能干什么，嘻嘻~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1775459/201908/1775459-20190823134330846-897380226.png&quot; alt=&quot;&quot; width=&quot;660&quot; height=&quot;339&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1775459/201908/1775459-20190823135435885-1784276379.png&quot; alt=&quot;&quot; width=&quot;660&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;1) git init&lt;/h2&gt;
&lt;p&gt;初始化后，在当前目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中。就这么简单，我们已经有一个代码仓库了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1775459/201908/1775459-20190823135609694-1252613092.png&quot; alt=&quot;&quot; width=&quot;660&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;2) git add&lt;/h2&gt;
&lt;p&gt;有了仓库，那第二部我们要让git知道哪些文件需要被管理或跟踪的。输入&quot;git add .&quot; (这里.是代表所有文件，也可以输具体文件名) 让当前所有文件都被git跟踪到。&lt;/p&gt;
&lt;h2&gt;3) git commit&lt;/h2&gt;
&lt;p&gt;add后我们需要第一次commit,这样git才会帮我们创建一个主分支，什么是分支后面会讲。我们先输入&quot;git commit -m &quot;init commit&quot; 这里-m必须加，表示这次提交的描述，内容我们随意输，主要是给自己做标记用的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1775459/201908/1775459-20190823140000122-881838763.png&quot; alt=&quot;&quot; width=&quot;660&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;4) git log&lt;/h2&gt;
&lt;p&gt;试试输入git log,我们发现我们的提交已经被记录下来了。就这样一个最基本简单的流程已经走完了。哎呀，妈呀，这git到底有啥用？我咋完全不懂呢？别急，我们看看神奇的事情开始发生了。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1775459/201908/1775459-20190823140305281-662737280.png&quot; alt=&quot;&quot; width=&quot;660&quot;/&gt;&lt;/p&gt;


&lt;h2&gt;1) git checkout&lt;/h2&gt;
&lt;p&gt;这时粗心的我不小心把hello文件中的代码给误删了，而且我又忘了代码写些什么来着~~~咋办尼？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1775459/201908/1775459-20190823140817296-1997168658.png&quot; alt=&quot;&quot; width=&quot;660&quot;/&gt;&lt;/p&gt;
&lt;p&gt;嘿嘿，这时git闪亮登场。试试输入&quot;git checkout hello.html&quot;看看会怎样。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1775459/201908/1775459-20190823141554920-555396462.png&quot; alt=&quot;&quot; width=&quot;660&quot;/&gt;&lt;/p&gt;
&lt;p&gt;咦！我们发现那句代码神奇的又回来了。难道这个命令是可以把我现在的代码还原到上次提交的吗？好像没那么简单，不过我们也暂时这样理解吧，稍后会详细介绍。这下我会玩了，我可以随便修改代码，如果错了，直接checkout不就行了吗，哈哈。&lt;/p&gt;
&lt;h2&gt;2) git status&lt;/h2&gt;
&lt;p&gt;这时我们继续编辑代码，当代码敲得差不多时，咦~ 我到底改了什么呢？输入&quot;git status&quot;,我们看到以下信息，它告诉我们hello.html文件被修改了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1775459/201908/1775459-20190823142536848-244271625.png&quot; alt=&quot;&quot; width=&quot;660&quot;/&gt;&lt;/p&gt;
&lt;p&gt;大家肯定跟我一样，那到底这个文件修改了哪些内容呢？不急，这&quot;git status&quot;只是列了个大概，告诉你有哪些文件被修改过，但如果想知道具体内容，就要借助git diff命令。&lt;/p&gt;
&lt;h2&gt;3)git diff&lt;/h2&gt;
&lt;p&gt;输入&quot;git diff&quot;这里显示了详细的修改。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1775459/201908/1775459-20190823142830439-147238548.png&quot; alt=&quot;&quot; width=&quot;660&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ok,查看了修改内容，觉得没问题，那就提交吧。输入“git add .&quot;  等等，我好像发现了个问题。为什么git要先add然后再commit呢？干嘛不直接commit要多一部这么麻烦呢？这里就涉及git的设计了。&lt;/p&gt;

&lt;h2&gt;1）理解git构造&lt;/h2&gt;
&lt;p&gt;首先我们先来理解以下git的概念&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;工作区：&lt;/strong&gt;就是你在电脑看到的目录&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;暂存区：&lt;/strong&gt;英文叫stage或index&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;版本库：&lt;/strong&gt;工作区隐藏目录.git&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分支：&lt;/strong&gt;一连串提交组成了一个分支&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1775459/201908/1775459-20190823143548385-1473146271.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这里借用w3c的图给大家看，当我们编辑完代码，然后准备提交。当我们add时候，其实是把我们工作区的代码放到了暂存区了。然后当我们commit时候，才是真的写到分支上了。分支是什么呢？分支就相当于把我们每一次提交串连成一条时间轴。而这条时间轴就相当于一个分支，哦~ 这样大概理解了。至于为什么要搞一个暂存区，是因为中间有了缓冲，使得管理代码更具有灵活性了。&lt;/p&gt;
&lt;h2&gt;2)重温git status 和 git diff 和 git checkout&lt;/h2&gt;
&lt;p&gt;现在，我们新建一个html文件，取名heihei。输入&quot;git add heihei.html&quot;让git跟踪这个文件。同时这时我们修改一下hello.html文件(注意，hello文件没有现在是没执行add)。这时试试status一下会怎样？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1775459/201908/1775459-20190823144528119-2108343011.png&quot; alt=&quot;&quot; width=&quot;660&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这下我好像看懂了，哈哈。那再试试diff命令？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1775459/201908/1775459-20190823144754382-1099960123.png&quot; alt=&quot;&quot; width=&quot;660&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Yoshi（日文）原来这是默认查看工作区和暂存区之间的差异变化，也就是修改之后还没暂存起来的变化内容。那我要看暂存区和上次提交的详细变化该怎么看呢？输入&quot;git diff --staged&quot;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1775459/201908/1775459-20190823144913543-751563005.png&quot; alt=&quot;&quot; width=&quot;660&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Yoshi 原来是这样子 哈哈 好简单是吧~ 就是这么简单，不过这只是最基本的操作，我们再看看checkout命令,这时候先忽略掉heihei文件，把hello文件add一下，再给hello文件添加一句代码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1775459/201908/1775459-20190823145512333-2115274833.png&quot; alt=&quot;&quot; width=&quot;660&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在工作区，暂存区，分支上的代码分别是这样的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1775459/201908/1775459-20190823150133134-1170917434.png&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1775459/201908/1775459-20190823150222718-1380657292.png&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1775459/201908/1775459-20190823150245724-286256800.png&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好，现在三个地方的代码都不一样，这时候我们执行checkout命令会怎样呢？我们知道checkout是把工作区修改的代码删去，那它是根据暂存区的呢还是分支上的呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1775459/201908/1775459-20190823150606170-320183511.png&quot; alt=&quot;&quot; width=&quot;660&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输入命令checkout,我们发现竟然回到了暂存区的代码。噢~ 这下我懂了，原来checkout是回退到暂存区的代码。这下好玩了，我可以随便敲代码，然后把确定的代码放到暂存区，一出问题，就checkout回退到暂存区的就可以了。这时候有孩童又想问了，那如何回退分支上的代码尼？&lt;/p&gt;
&lt;h2&gt;3) git checkout head&lt;/h2&gt;
&lt;p&gt; 现在工作区，暂存区，分支上刚刚上面的一样&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1775459/201908/1775459-20190823150133134-1170917434.png&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1775459/201908/1775459-20190823150222718-1380657292.png&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1775459/201908/1775459-20190823150245724-286256800.png&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输入 “git checkout head&quot; 看看会怎么样？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1775459/201908/1775459-20190823152353960-1778700070.png&quot; alt=&quot;&quot; width=&quot;660&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这时候，惊奇的发现暂存区和工作区都被分支上的代码重写了，也就是说工作区回退到分支上的代码，暂存区也被清空。（意味着你工作区和暂存区新修改的代码都没了）所以这个命令是极具危险性的，一定要小心使用哦~&lt;/p&gt;
&lt;h2&gt;4) git reset命令&lt;/h2&gt;
&lt;p&gt;当你玩转工作区，暂存区，分支三地的代码时，也许你还不满足。感觉git应该有更强大的功能，我们现在就看看git reset命令到底是个啥东西。git reset命令主要有三个可选参数，分别是git reset --soft,git reset --mixed,git reset --hard,它们的危险性也是逐步增大的，下面我们详细看一下。现在的代码是这样子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1775459/201908/1775459-20190823153231339-1116651945.png&quot; alt=&quot;&quot; width=&quot;660&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在我们再修改一下代码，并提交。标记名称 &quot;test get reset&quot;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1775459/201908/1775459-20190823153443178-910431614.png&quot; alt=&quot;&quot; width=&quot;660&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在我们输入&quot;git reset --soft 3d542d6e307e067e7b281de74d328d6114084d04&quot; 看看会怎么样？后面那串(3d....)是 &quot;beautiful girl&quot; 那次提交的id。 我们log一下，发觉最新的一次提交不见了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1775459/201908/1775459-20190823153941459-1619496282.png&quot; alt=&quot;&quot; width=&quot;660&quot;/&gt;&lt;/p&gt;
&lt;p&gt;status和diff看看？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1775459/201908/1775459-20190823154823555-1024974654.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不知道大家看懂没，我们发现git reset --soft命令竟然把最近一次提交 &quot;倒回到&quot; 未提交的状态，所有改变都回到了暂存区放着，哈哈，原来如此~ 那这个有什么用呢？比如我们提交了后，誒~发现漏了点东西，那我们就可以用git reset --soft（别忘了加上上一次提交的id）回退到我们未提交的状态，然后修改重新提交。Ok，很好用~。下面再看看git reset mixed,这是不带参数的默认选项。我们把刚刚reset --soft回滚的再次提交,取名&quot;text reset mixed&quot;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1775459/201908/1775459-20190824083900097-1447853525.png&quot; alt=&quot;&quot; width=&quot;660&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输入 &quot;git reset mixed 3d542d6e307e067e7b281de74d328d6114084d04&quot; 或 &quot;git reset 3d542d6e307e067e7b281de74d328d6114084d04&quot; 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1775459/201908/1775459-20190824084434742-563926276.png&quot; alt=&quot;&quot; width=&quot;660&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个神奇了，我们发现最近的一次提交记录没有了（注意上图中我忘记log一下给大家看了），暂存区没有变化，上一次提交的修改都回到了工作区（红色字体代表工作区的修改，也就是没执行add)。&lt;/p&gt;
&lt;p&gt;git reset hard这里就不演示了，相信大家也能猜到到结果，就是最近一次提交的修改不是回到暂存区，也不是回到工作区，而是完全丢失了，所以这个操作是最危险的，一定要小心使用。到这里小铭酱就有点不明白了，git reset好像都不是针对上一次提交回退代码的，而是针对上上一次进行回滚操作的，噢~ 对了，假如我工作区的代码胡乱写了一番，暂存区的没有任何修改，那我直接checkout不就相当于回退到上一个版本了吗？那如果这时暂存区里面已经有东西了，那该如何回到上一个版本呢？我们可以用checkoutout head是吧。好~ 这下大概懂了。&lt;/p&gt;
&lt;p&gt;总结一下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;git reset --soft &lt;/strong&gt;加上（上上一次commit的id），那么上一次提交会消失，回到没提交状态，所有修改放在暂存区里&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;git reset --mixed &lt;/strong&gt;加上（上上一次commit的id），那么上一次提交同样消失，所有修改回放到工作区里&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;git reset --hard &lt;/strong&gt;加上（上上一次commit的id），那么上一次提交&quot;永久&quot;消失，上一次提交数据就完全没了，代码完全回到上上一次提交的版本&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;说到这里，也感叹git的设计好厉害，好吧~ 这部分先到此为止，下面又更好玩的 ——分支&lt;/p&gt;

&lt;h2&gt;1)git branch (branchname)&lt;/h2&gt;
&lt;p&gt;我们输入&quot;git branch two&quot; 创建一个名为two的分支&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1775459/201908/1775459-20190824141204554-512408419.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;2)git checkout (branchname)&lt;/h2&gt;
&lt;p&gt;输入&quot;git checkout two&quot; 切换到two分支&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1775459/201908/1775459-20190824091446745-416466951.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;3) git branch&lt;/h2&gt;
&lt;p&gt;列出所有分支，妈呀，这个到底咋玩？别急，我们先切换到主分支上，现在我们修改代码，看下面hello.html的改动&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1775459/201908/1775459-20190824091621123-1386936449.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1775459/201908/1775459-20190824091644813-331404469.png&quot; alt=&quot;&quot; width=&quot;660&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们把修改的提交了，命名为&quot;test branch&quot;，好~ 神奇的事情出现了，我们切回分支two，log一下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1775459/201908/1775459-20190824091719281-76628171.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;发现在分支two上，根本没有&quot;test branch&quot;提交，这说明现在代码已经在两条线上开发啦~ 我们再在分支two上作一些修改，并且同样是修改hello.html文件看看会怎样？同时我们画个图看看。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1775459/201908/1775459-20190824091740640-147778599.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1775459/201908/1775459-20190824091927893-1011162018.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;相信聪明的小伙伴们都知道这是有啥用，这里不多说了，我这里是想跟大家探究一下合并分支的问题，来~ 一起看一下。&lt;/p&gt;
&lt;h2&gt;4）git merge&lt;/h2&gt;
&lt;p&gt;切换到主分支，输入“git merge two&quot;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1775459/201908/1775459-20190824091837111-1359898110.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1775459/201908/1775459-20190824092011637-1696286431.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;哇草，既然冲突了~ 哈哈，当我们两个分支都同时修改了同一个文件，合并时就会出现冲突，这时候我们就需要手动修改一下，然后重新提交，便能把分支上改的东东合并我主分支上啦~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1775459/201908/1775459-20190824092025863-1193093452.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 最后，感谢大家和小铭酱畅游了一遍git的世界，第一次写，写得不是很好，哈哈~ 在后续中小铭酱将会跟大家继续发掘git的好玩之处，谢谢大家！&lt;/p&gt;
</description>
<pubDate>Mon, 26 Aug 2019 00:48:00 +0000</pubDate>
<dc:creator>$小铭酱$</dc:creator>
<og:description>今天小铭酱带大家探索一下git的奥秘！ 1.初步探索 首先我在一个空的文件夹新建了一个名叫hello.html文件，文件内容只有一句话“hello git”。我们先引入git，看看git能为我们它能干</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiaomingjiang/p/11399512.html</dc:identifier>
</item>
<item>
<title>部署Kettle做ETL开发并使用Crontab制作调度系统 - Huidoo_Yang</title>
<link>http://www.cnblogs.com/yangp/p/11410137.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yangp/p/11410137.html</guid>
<description>&lt;p&gt;背景说明：&lt;br/&gt;在数据量较小，且数据源和装载地都是关系型数据库时，使用Kettle做ETL较为简便。&lt;br/&gt;由于调度系统产品因为服务器环境方面的因素，而无法部署，故使用Linux的crontab定时器来制作简易调度系统是一个比较简便的解决方案。&lt;br/&gt;本文旨在记录Kettle的部署及配置文件配置注意事项和如何自制简易调度系统，以便处理类似问题时方案的复用。&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;CentOS 6.7&lt;/li&gt;
&lt;li&gt;JDK1.8/JDK1.7&lt;/li&gt;
&lt;li&gt;pdi-ce-6.1.0.1-196.zip&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;安装jdk并配置环境变量&quot;&gt;2.1 安装JDK并配置环境变量&lt;/h2&gt;
&lt;p&gt;Kettle的运行需要jdk环境，所以需要先安装jdk。jdk的安装方法此处略去。&lt;/p&gt;
&lt;h2 id=&quot;创建kettle用户&quot;&gt;2.2 创建kettle用户&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;# useradd -m kettle&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;上传kettle安装包并解压&quot;&gt;2.3 上传Kettle安装包并解压&lt;/h2&gt;
&lt;p&gt;创建kettle部署目录&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# mkdir /opt/kettle&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将安装包pdi-ce-6.1.0.1-196.zip上传至/opt/kettle目录下，并解压：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# unzip /opt/kettle/pdi-ce-6.1.0.1-196.zip&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;更改属主属组和执行权限&quot;&gt;2.4 更改属主属组和执行权限&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;# chown -R kettle:kettle /opt/kettle
# chmod 755 /opt/kettle/pdi-ce-6.1.0.1-196/data-integration/*.sh&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;测试&quot;&gt;2.5 测试&lt;/h2&gt;
&lt;p&gt;切换至kettle用户&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# su kettle&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动kettle的kitchen或pan&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ cd /opt/kettle/pdi-ce-6.1.0.1-196/data-integration/
$ ./kitchen.sh&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果能正常启动，则说明kettle安装成功。&lt;/p&gt;
&lt;h2 id=&quot;配置文件设置&quot;&gt;2.6 配置文件设置&lt;/h2&gt;
&lt;p&gt;在/home/kettle/.kettle目录下有一个kettle.properties文件，在kettle程序启动时会读取这个文件配置的属性。这里一般可以将数据库的连接信息（包含ip，端口，数据库实例，用户名，密码等）以及自定的一些变量（如etl_path等）。&lt;br/&gt;将这些连接信息配置在配置文件中，而在kettle脚本中使用这些变量名来代替，好处在与脚本的移植与复用时，不需要改动脚本，只需要修改配置文件即可。&lt;/p&gt;

&lt;h2 id=&quot;创建调度系统目录&quot;&gt;3.1 创建调度系统目录&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;创建kettle脚本存放目录&lt;br/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;# mkdir -p /opt/kettle/scripts
# mkdir -p /opt/kettle/scripts/jobs
# mkdir -p /opt/kettle/scripts/trans&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;创建调度脚本存放目录&lt;br/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;# mkdir -p /opt/kettle/scheduler&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;创建日志存放目录&lt;br/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;# mkdir -p /opt/kettle/logs&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;上传或创建调度脚本kettle_scheduler.sh&quot;&gt;3.2 上传或创建调度脚本kettle_scheduler.sh&lt;/h2&gt;
&lt;p&gt;上传kettle_scheduler.sh文件到/opt/kettle/scheduler目录下。或者进入目录创建：&lt;br/&gt;编辑文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# cd /opt/kettle/scheduler
# vim kettle_scheduler.sh&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输入如下内容并保存：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#!/bin/bash
#
cd /opt/kettle/scripts/jobs/
date=`date +%Y%m%d`
files=`ls /opt/kettle/scripts/jobs/*.kjb`
for file in $files
do
file_name=`echo &quot;$file&quot; | awk -F '.' '{print $1}' | awk -F '/' '{print $6}'`
log_name=&quot;${file_name}-${date}.log&quot;
mkdir -p /opt/kettle/logs/$file_name
/opt/kettle/pdi-ce-6.1.0.1-196/data-integration/kitchen.sh -file=$file -level=basic&amp;gt;&amp;gt;/opt/kettle/logs/$file_name/$log_name
done&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;修改权限&quot;&gt;3.3 修改权限&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;# chown -R kettle:kettle /opt/kettle
# chmod 755 /opt/kettle/scheduler/kettle_scheduler.sh&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;配置定时任务&quot;&gt;3.4 配置定时任务&lt;/h2&gt;
&lt;p&gt;进入crontab编辑界面&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# crontab -e&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输入如下内容，保存退出&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1　　0　　*　　*　　*　　chown -R kettle:kettle /opt/kettle/scripts
5　　0　　*　　*　　*　　su - kettle -c &quot;/opt/kettle/scheduler/kettle_scheduler.sh&quot; &amp;amp;&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;kettle脚本的上线&quot;&gt;4.1 kettle脚本的上线&lt;/h2&gt;
&lt;p&gt;上传开发好的kettle脚本到指定路径。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;将所有的kettle作业(以.kjb为后缀)上传至/opt/kettle/scripts/jobs目录下；&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;将所有的kettle转换(以.ktr为后缀)上传至/opt/kettle/scripts/trans目录下。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里开发kettle作业时，需要注意作业和转换的目录位置关系，比如可以在配置文件kettle.properties中配置etl_path=/opt/kettle/scripts。&lt;/p&gt;
&lt;h2 id=&quot;日志查看&quot;&gt;4.2 日志查看&lt;/h2&gt;
&lt;p&gt;在/opt/kettle/logs目录下，每一个作业会新建一个对应名称的文件夹用于存储执行的日志，作业的每一次执行都会在这个文件夹下创建一个日志文件并加上日期。&lt;br/&gt;例如，/opt/kettle/scripts/jobs目录下有个test.kjb的作业，则执行完后会在/opt/kettle/logs/test目录下创建一个test-20190823.log&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# cd /opt/kettle/logs/test
# cat test-20190823.log&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;上传或创建日志清理脚本kettle_clean.sh&quot;&gt;5.1 上传或创建日志清理脚本kettle_clean.sh&lt;/h2&gt;
&lt;p&gt;上传kettle_clean.sh文件到/opt/kettle/scheduler目录下。或者进入目录创建：&lt;br/&gt;编辑文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# cd /opt/kettle/scheduler
# vim kettle_clean.sh&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输入如下内容并保存：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#!/bin/bash
dir=/opt/kettle/logs
cd ${dir}
reserveDays=7  # 设置要保留的日志天数
sub_dirs=`ls ${dir}`
for sub_dir in ${sub_dirs}; do
    count=$(ls ${sub_dir} | wc -l)
    if [[ ${count} -gt ${reserveDays} ]]; then
        cleanCnt=$((count-reserveDays))
        files=$(ls ${dir}/${sub_dir} | head -n ${cleanCnt})
        cd ${sub_dir}
        rm -rf ${files}
        cd ..
    fi
done&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;更改属主属组和执行权限-1&quot;&gt;5.2 更改属主属组和执行权限&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;# chown kettle:kettle /opt/kettle/scheduler/kettle_clean.sh
# chmod 755 /opt/kettle/scheduler/kettle_clean.sh&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;配置定时任务-1&quot;&gt;5.3 配置定时任务&lt;/h2&gt;
&lt;p&gt;进入crontab编辑界面&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# crontab -e&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;增加一行如下内容，保存退出&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;0　　2　　*　　*　　*　　su - kettle -c &quot;/opt/kettle/scheduler/kettle_clean.sh&quot;&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 26 Aug 2019 00:48:00 +0000</pubDate>
<dc:creator>Huidoo_Yang</dc:creator>
<og:description>Linux环境下部署Kettle，Kettle配置文件的使用说明。制作作业调度脚本、日志清理脚本，使用Crontab做定时任务。最终达到一键上传，实现脚本上线，并可在相应日志中查看每个调度周期脚本执行</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yangp/p/11410137.html</dc:identifier>
</item>
<item>
<title>调度系统Airflow1.10.4调研与介绍和docker安装 - Ryan.Miao</title>
<link>http://www.cnblogs.com/woshimrf/p/airflow-install-with-docker.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/woshimrf/p/airflow-install-with-docker.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;现在是9102年，8月中旬。airflow当前版本是1.10.4.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;随着公司调度任务增大，原有的，基于crontab和mysql的任务调度方案已经不太合适了，需要寻找一个可以支持分布式扩容的调度系统解决方案。&lt;/p&gt;
&lt;p&gt;最初瞄准azkaban来着，想着基于这个的二次开发。对比功能和社区热度之后，Airflow比较符合我们寻找的调度系统。&lt;/p&gt;
&lt;h2 id=&quot;什么是airflow&quot;&gt;什么是Airflow&lt;/h2&gt;
&lt;p&gt;Airflow是一个以编程方式创作，安排和监控工作流程的平台。对比crontab来看，它是一个可以定时调度任务的系统，只不过，airflow的调度更容易管理。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;airflow支持任务依赖pipeline， 这是crontab以及quartz所不支持的。&lt;/li&gt;
&lt;li&gt;airflow调度系统和业务系统解耦。业务单独编写流程，支持任务热加载。&lt;/li&gt;
&lt;li&gt;airflow支持crontab定时格式&lt;/li&gt;
&lt;li&gt;airflow通过Python来定义task，可以实现复杂的逻辑，支持分支条件等&lt;/li&gt;
&lt;li&gt;airflow有一套完整的UI和管理系统&lt;/li&gt;
&lt;li&gt;airflow有强大的插件扩展方式，各种插件很丰富，很容易二次开发，添加新功能&lt;/li&gt;
&lt;li&gt;airflow是分布式设计，支持水平扩容&lt;/li&gt;
&lt;li&gt;airflow支持task实例，并支持数据业务日期bizdate, 也叫 execution_date.&lt;/li&gt;
&lt;li&gt;airflow支持任务补录backfill&lt;/li&gt;
&lt;li&gt;airflow支持任务之间数据传递(这个任务依赖于上个任务的变量)&lt;/li&gt;
&lt;li&gt;airflow支持序列执行(这个周期的任务依赖于上一个周期的执行结果是否成功)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Airflow 于 2014 年 10 月由 Airbnb 的 Maxime Beauchemin 开始。它是第一次提交的开源，并在 2015 年 6 月宣布正式加入 Airbnb Github。&lt;/p&gt;
&lt;p&gt;该项目于 2016 年 3 月加入了 Apache Software Foundation 的孵化计划。&lt;/p&gt;
&lt;p&gt;关于airflow具体使用细节，后面再详细介绍，这里就是一些在调度系统选型过程中查找的资料。&lt;/p&gt;
&lt;p&gt;阿里基于airflow二次开发了调度平台Maat:&lt;/p&gt;
&lt;p&gt;有赞基于airflow二次开发了大数据任务调度平台：&lt;/p&gt;
&lt;p&gt;Google cloud提供了基于airflow的数据分析产品：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/686418/201908/686418-20190823211224205-1859351394.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;微软Azure支持airflow的运行：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/686418/201908/686418-20190823211442645-650029831.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然，这些云厂商很可能是为了让你使用他们的数据产品，比如对象存储，lambda等。&lt;/p&gt;
&lt;p&gt;社区异常活跃，star破万，更新频繁， Apache背书。据说作者早期在Facebook搞过一套调度系统，到airbnb就开源了airflow。大公司背书。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/686418/201908/686418-20190823205811854-2104669722.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;slack群组也很活跃&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/686418/201908/686418-20190823211758487-903394192.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;虽然是Python开发的，我也没玩过Python web， 但调研结果就是： 用Airflow吧。&lt;/p&gt;
&lt;h2 id=&quot;airflow的安装&quot;&gt;Airflow的安装&lt;/h2&gt;
&lt;p&gt;官方文档有非常详细的安装教程。这里不再赘述。&lt;/p&gt;
&lt;p&gt;想要记录的是基于docker安装airflow，以及做了一些特定的修改。&lt;/p&gt;
&lt;p&gt;最终docker镜像为： &lt;a href=&quot;https://github.com/Ryan-Miao/docker-airflow&quot; class=&quot;uri&quot;&gt;https://github.com/Ryan-Miao/docker-airflow&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用方式很简单：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;clone 项目&lt;/li&gt;
&lt;li&gt;构建airflow镜像&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;make build&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;启动&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;docker-compose -f docker-compose-CeleryExecutor.yml up -d&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;浏览器访问localhost:8089可以查看dag&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/686418/201908/686418-20190823212503296-1277620303.png&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;浏览器访问localhost:5555可以查看worker&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;扩容3个worker&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker-compose -f docker-compose-CeleryExecutor.yml scale worker=3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/686418/201908/686418-20190823212705768-375326507.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;所做的一些修改&quot;&gt;所做的一些修改&lt;/h2&gt;
&lt;h3 id=&quot;修改时区为utc8&quot;&gt;修改时区为utc+8&lt;/h3&gt;
&lt;p&gt;Docker容器的时区&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ENV LANGUAGE zh_CN.UTF-8
ENV LANG zh_CN.UTF-8
ENV LC_ALL zh_CN.UTF-8
ENV LC_CTYPE zh_CN.UTF-8
ENV LC_MESSAGES zh_CN.UTF-8

sed -i 's/^# zh_CN.UTF-8 UTF-8$/zh_CN.UTF-8 UTF-8/g' /etc/locale.gen \
    &amp;amp;&amp;amp; locale-gen \

/bin/cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;amp;&amp;amp; echo 'Asia/Shanghai' &amp;gt;/etc/timezone&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;web server ui显示的时区，以及任务运行时的ds等时区：&lt;/p&gt;
&lt;p&gt;参考https://blog.csdn.net/Crazy__Hope/article/details/83688986，&lt;/p&gt;
&lt;p&gt;airflow.cfg&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;default_timezone = Asia/Shanghai&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;/usr/local/lib/python3.7/site-packages/airflow/utils/timezone.py&lt;/p&gt;
&lt;p&gt;在 utc = pendulum.timezone(‘UTC’) 这行(第27行)代码下添加,&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from airflow import configuration as conf
try:
    tz = conf.get(&quot;core&quot;, &quot;default_timezone&quot;)
    if tz == &quot;system&quot;:
        utc = pendulum.local_timezone()
    else:
        utc = pendulum.timezone(tz)
except Exception:
    pass
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改utcnow()函数 (在第69行)&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;原代码 d = dt.datetime.utcnow() 
修改为 d = dt.datetime.now()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;/usr/local/lib/python3.7/site-packages/airflow/utils/sqlalchemy.py&lt;/p&gt;
&lt;p&gt;在utc = pendulum.timezone(‘UTC’) 这行(第37行)代码下添加&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from airflow import configuration as conf
try:
    tz = conf.get(&quot;core&quot;, &quot;default_timezone&quot;)
    if tz == &quot;system&quot;:
        utc = pendulum.local_timezone()
    else:
        utc = pendulum.timezone(tz)
except Exception:
    pass&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;/usr/local/lib/python3.7/site-packages/airflow/www/templates/admin/master.html&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;把代码 var UTCseconds = (x.getTime() + x.getTimezoneOffset()*60*1000); 
改为 var UTCseconds = x.getTime();

把代码 &quot;timeFormat&quot;:&quot;H:i:s %UTC%&quot;,
改为  &quot;timeFormat&quot;:&quot;H:i:s&quot;,&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;webserver查看日志中文乱码问题&quot;&gt;webserver查看日志，中文乱码问题&lt;/h3&gt;
&lt;p&gt;容器编码设置没问题，进去看日志文件也没问题，但是webserver查看的时候日志中文乱码。原因是http请求的mime&lt;br/&gt;没设置编码。&lt;/p&gt;
&lt;p&gt;/usr/local/lib/python3.7/site-packages/airflow/bin/cli.py&lt;br/&gt;修改mime&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mimetype=&quot;application/json;charset=utf-8&quot;,&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;hive-beeline认证&quot;&gt;Hive beeline认证&lt;/h3&gt;
&lt;p&gt;airflow支持beeline， 在connection里填写beeline的配置后，使用HiveOperator进行hive操作。我们的hive&lt;br/&gt;没有使用kerberos， 而是ldap的账号密码认证。需要对后台的hvie任务做认证的修改。&lt;/p&gt;
&lt;p&gt;修改hive_hooks.py的认证部分即可。Dockerfile注释掉的部分就是。&lt;/p&gt;
&lt;h3 id=&quot;添加hive的支持&quot;&gt;添加hive的支持&lt;/h3&gt;
&lt;p&gt;github的airflow docker没有hive相关的lib。我在Dockerfile里添加了hive的环境，这个后面再做优化，针对&lt;br/&gt;不同的pool，安装不同的依赖。&lt;/p&gt;
&lt;h2 id=&quot;ldap配置&quot;&gt;ldap配置&lt;/h2&gt;
&lt;p&gt;参见https://www.cnblogs.com/woshimrf/p/ldap.html 配置我们的ldap服务。&lt;/p&gt;
&lt;p&gt;然后修改airflow.cfg. 找到263行&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;authenticate = False
# 设置为True并打开ldap即可使用ldap配置
# auth_backend = airflow.contrib.auth.backends.ldap_auth&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以及518行&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[ldap]
# set this to ldaps://&amp;lt;your.ldap.server&amp;gt;:&amp;lt;port&amp;gt;
uri = ldap://192.168.2.2:389
user_filter = objectClass=inetOrgPerson
user_name_attr = sn
group_member_attr = memberOf
superuser_filter = memberOf=cn=g-admin,ou=group,dc=demo,dc=com
data_profiler_filter = memberOf=cn=g-users,ou=group,dc=demo,dc=com
bind_user = cn=admin,dc=demo,dc=com
bind_password = admin
basedn = dc=demo,dc=com
cacert = 
search_scope = SUBTREE&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
</description>
<pubDate>Mon, 26 Aug 2019 00:46:00 +0000</pubDate>
<dc:creator>Ryan.Miao</dc:creator>
<og:description>Airflow1.10.4介绍与安装 ===================== 现在是9102年，8月中旬。airflow当前版本是1.10.4. 随着公司调度任务增大，原有的，基于crontab和</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/woshimrf/p/airflow-install-with-docker.html</dc:identifier>
</item>
<item>
<title>.net测试篇之Moq框架简单使用 - 周国通</title>
<link>http://www.cnblogs.com/tylerzhou/p/11410337.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tylerzhou/p/11410337.html</guid>
<description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/tylerzhou/p/11204826.html&quot;&gt;系列目录&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;moq简介&quot;&gt;Moq简介&lt;/h2&gt;
&lt;p&gt;Moq是.net平台下的一个非常流行的模拟库,只要有一个接口它就可以动态生成一个对象,底层使用的是Castle的动态代理功能.&lt;/p&gt;
&lt;p&gt;它的流行赖于依赖注入模式的兴起,现在越来越多的分层架构使用依赖注入的方式来解耦层与层之间的关系.最为常见的是数据层和业务逻辑层之间的依赖注入,业务逻辑层不再强依赖数据层对象,而是依赖数据层对象的接口,在IOC容器里完成依赖的配置.&lt;/p&gt;
&lt;p&gt;这种解耦给单元测试带来了巨大的便利,使得对业务逻辑的测试可以脱离对数据层的依赖,单元测试的粒度更小,更容易排查出问题所在.&lt;/p&gt;
&lt;p&gt;大家可能都知道,数据层的接口往往有很多方法,少则十几个,多则几十个.我们如果在单元测试的时候把接口切换为假实现,即使实现类全是空也需要大量代码,并且这些代码不可重用,一旦接口层改变不但要更改真实数据层实现还要修改这些专为测试做的假实现.这显然是不小的工作量.&lt;/p&gt;
&lt;p&gt;幸好有Moq,它可以在编译时动态生成接口的代理对象.大大提高了代码的可维护性,同时也极大减少工作量.&lt;/p&gt;
&lt;p&gt;除了动态创建代理外,Moq还可以进行行为测试,触发事件等.&lt;/p&gt;
&lt;h2 id=&quot;moq安装&quot;&gt;Moq安装&lt;/h2&gt;
&lt;p&gt;Moq安装非常简单,在Nuget里面搜索moq,第一个结果便是moq框架,点击安装即可.&lt;/p&gt;

&lt;p&gt;本示例中要使用到的代码如下&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt; public class MyDto
    {
        public string Name { get; set; }
        public int Age { get; set; }
    }
    public interface IDataBaseContext&amp;lt;out T&amp;gt; where T:new()
    {
        T GetElementById(string id);
        IEnumerable&amp;lt;T&amp;gt; GetAll();
        IEnumerable&amp;lt;T&amp;gt; GetElementsByName(string name);
        IEnumerable&amp;lt;T&amp;gt; GetPageElementsByName(string name, int startPage = 0, int pageSize = 20);
        IEnumerable&amp;lt;T&amp;gt; GetElementsByDate(DateTime? startDate, DateTime? endDate);
    }

    public class MyBll
    {
        private readonly IDataBaseContext&amp;lt;MyDto&amp;gt; _dataBaseContext;

        public MyBll(IDataBaseContext&amp;lt;MyDto&amp;gt; dataBaseContext)
        {
            _dataBaseContext = dataBaseContext;
        }

        public MyDto GetADto(string id)
        {
            if (string.IsNullOrWhiteSpace(id)) return null;
            return _dataBaseContext.GetElementById(id);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;MyDto为业务层和数据层交互的对象,IDataBaseContext为数据层接口,MyBll为我们的业务逻辑层&lt;/p&gt;
&lt;p&gt;我们要测试的是业务逻辑层的代码.这里业务逻辑类并没有无参构造函数,如果手动创建起来非常麻烦,里面的坑前面说过.下面看如何使用Moq来模拟一个IDataBaseContext对象&lt;/p&gt;
&lt;p&gt;我们编写以下测试类&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;       [Test]
        public void SimpleTest()
        {
            var moq = new Mock&amp;lt;IDataBaseContext&amp;lt;MyDto&amp;gt;&amp;gt;();
            MyBll bll = new MyBll(moq.Object);
            var result = bll.GetADto(null);
            Assert.Null(result);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于bll的GetADto如果传的参数是null或者空就会返回一个null对象,因些返回的结果是Null,以上测试会通过.&lt;/p&gt;
&lt;p&gt;这里我们首先创建了一个moq对象,它的Object属性就是我们要模拟的IDataBaseContext对象,我们在创建MyBll对象时把它作为参数传入.&lt;/p&gt;

&lt;p&gt;我们再为MyBll添加以下方法&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt; public IEnumerable&amp;lt;MyDto&amp;gt; GetDtos(string name)
        {
            if (string.IsNullOrWhiteSpace(name)) return null;
            var dtos = _dataBaseContext.GetElementsByName(name);
           return dtos;
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们编写如下测试方法&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;       [Test]
        public void ShouldReturn_A_Collection_Of_Dtos()
        {
            var moq = new Mock&amp;lt;IDataBaseContext&amp;lt;MyDto&amp;gt;&amp;gt;();
            MyBll bll = new MyBll(moq.Object);
            var dtos = bll.GetDtos(&quot;sto&quot;);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上测试方法调用了bll的GetDtos方法,我们知道GetDtos内部调用了数据访问接口的GetElementsByName方法,我们在调试模式下看看返回的结果是什么.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201908/811801-20190826081102800-861615553.png&quot; alt=&quot;Avatar&quot;/&gt;&lt;/p&gt;
&lt;p&gt;它返回了一个空集合,实际上不管我们提供的是什么样的字符串,它都返回一个空集合,这是默认行为,因为&lt;code&gt;_dataBaseContext.GetElementsByName&lt;/code&gt;并不知道我们的真实逻辑是什么.&lt;/p&gt;
&lt;p&gt;这样很显然并不是总能满足我们的要求,很多时候我们在测试业务逻辑层的时候需要具体的数据,然后才能继续往下走.&lt;/p&gt;
&lt;p&gt;比如以下方法,我们获取数据库里的所有数据,然而通过一系列逻辑进行过滤,最终返回过滤后的结果.&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt; public IEnumerable&amp;lt;MyDto&amp;gt; GetAllDtos()
        {
            var all = _dataBaseContext.GetAll().ToList();
            if (!all.Any()) return Enumerable.Empty&amp;lt;MyDto&amp;gt;();
            //一系列逻辑...
            var filteredDtos = all.Where(a =&amp;gt; a.Age &amp;gt; 20);
            var orderDtos = filteredDtos.OrderBy(a =&amp;gt; a.Name);
            return orderDtos;
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果是默认行为(调用模拟的接口方法,引用对象返回null,集合返回空,简单对象返回默认值),则代码很快就返回了,if下面的业务逻辑测不到了.下面我们看下如何配置接口方法的返回值&lt;/p&gt;
&lt;p&gt;这里其实主要用到了 新建moq对象的&lt;code&gt;setup&lt;/code&gt;方法,我们可以在setup里设置方法,属性的值.&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;       [Test]
        public void ShouldReturn_A_Collection_Of_Dtos()
        {
            var moq = new Mock&amp;lt;IDataBaseContext&amp;lt;MyDto&amp;gt;&amp;gt;();
            moq.Setup(a =&amp;gt; a.GetAll()).Returns(new List&amp;lt;MyDto&amp;gt;
            {
                new MyDto{Name=&quot;baidu&quot;,Age=15},
                new MyDto{Name=&quot;sto&quot;,Age=32},
                new MyDto{Name=&quot;zto&quot;,Age=24},
                new MyDto{Name=&quot;yto&quot;,Age=12}
            });
            MyBll bll = new MyBll(moq.Object);
            var dtos = bll.GetAllDtos().ToList();
            dtos.Should().HaveCount(2);
            dtos.Select(a =&amp;gt; a.Name).Should().BeInAscendingOrder();
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们看以上代码,我们我们让数据访问接口的代理对象返回一个MyDto类型集合,一共四个元素,由我们的业务可知,我们只要年龄大于20的元素,并且名字按正序排列.因此以上测试应该返回成功,实际上也是测试通过了.&lt;/p&gt;
&lt;h2 id=&quot;带参数的方法设置&quot;&gt;带参数的方法设置&lt;/h2&gt;
&lt;p&gt;以上的GetAll是不带参数的,带参数的方法我们可以显式的指定一个参数,我们也可以使用Moq框架提供的方法来模糊指定参数,比如我们可以指定方法是任意字符,任意数字,任意范围的数字等.&lt;/p&gt;
&lt;p&gt;我们再看前面的一个方法&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt; public MyDto GetADto(string id)
        {
            if (string.IsNullOrWhiteSpace(id)) return null;
            return _dataBaseContext.GetElementById(id);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个方法接收一个类型为字符串的id,只要字符串不是空字符串或者null时我们都返回一个MyDto对象.&lt;/p&gt;
&lt;p&gt;测试方法如下&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;        [Test]
        public void ShouldReturn_A_Dto_If_QueryBy_Id_With_Valid_Parameter()
        {
            var moq = new Mock&amp;lt;IDataBaseContext&amp;lt;MyDto&amp;gt;&amp;gt;();
           moq.Setup(a =&amp;gt; a.GetElementById(It.IsAny&amp;lt;string&amp;gt;())).Returns(new MyDto());
            MyBll bll = new MyBll(moq.Object);
            var dto = bll.GetADto(&quot;afakeid&quot;);
            dto.Should().NotBeNull();
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我们使用到了Moq里的It.Is方法,这个方法接受一个Func&amp;lt;T,bool&amp;gt;类型的委托,我们的条件是不管它是一个什么样的string,总是返回一个new MyDto();&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;strong&gt;[warning]&lt;/strong&gt;注意这里配置的是Moq对象(即moq.Object)的方法返回值,而不是bll对象的方法的返回值,如果我们传入的字符串是空字符串,则GetADto直接返回了null,数据访问对象就没机会执行了.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;It里面还有很多静态方法,用于指定数字是否是否在某一范围,对象是否是列表中的对象,字符串是否满足正则等.语义都非常明确,大家可以自己研究一下.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;指定参数的配置&quot;&gt;指定参数的配置&lt;/h2&gt;
&lt;p&gt;以上使用到了It.IsAny方法.It里面还有一个Is方法,接受一个Func&amp;lt;T,bool&amp;gt;类型委托,用于指定对象为满足特定条件的对象,而不是任意对象.&lt;/p&gt;
&lt;p&gt;Bll层新增以下方法&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt; public bool IsVip(string id)
        {
            if (string.IsNullOrWhiteSpace(id)) return false;
            var dto = _dataBaseContext.GetElementById(id);
            if (dto?.Name?.Contains(&quot;sto&quot;)) return true;
            return false;
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们判断一个dto是否是vip,如果传入id为null返回false,如果不是则获取一个对象,如果对象的名字包含sto关键字则返回true&lt;/p&gt;
&lt;p&gt;比如我们知道id为9527的对象为sto,因此它是个vip,我们的测试方法如下&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;        [Test]
        public void ShouldReturn_True_If_Id_Is_9527()
        {
            var moq = new Mock&amp;lt;IDataBaseContext&amp;lt;MyDto&amp;gt;&amp;gt;();
            moq.Setup(a =&amp;gt; a.GetElementById(It.Is&amp;lt;string&amp;gt;(t =&amp;gt; t.Trim() == &quot;9527&quot;))).Returns(new MyDto { Name = &quot;sto&quot;, Age = 24 });
            MyBll bll = new MyBll(moq.Object);
            bool isVip = bll.IsVip(&quot;9527&quot;);
            Assert.True(isVip);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上测试通过.&lt;/p&gt;
&lt;h2 id=&quot;mock.of&quot;&gt;MOCk.Of&lt;/h2&gt;
&lt;p&gt;我们以上仅配置了接口代表的一个方法,有时候需要配置多个,这样需要多个Setup,这时候我们可以使用Mock.Of,注意Mock.Of创建出来的是一个代理对象,而不是一个mock对象.&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;       [Test]
        public void MockOf_Test()
        {
            var obj = Mock.Of&amp;lt;IDataBaseContext&amp;lt;MyDto&amp;gt;&amp;gt;(a =&amp;gt;a.GetAll()==new List&amp;lt;MyDto&amp;gt;(){new MyDto()}
                                                           &amp;amp;&amp;amp;a.GetElementById(It.IsAny&amp;lt;string&amp;gt;())==new MyDto()
                                                           &amp;amp;&amp;amp;a.GetElementsByName(It.IsAny&amp;lt;string&amp;gt;())==new MyDto[3]);
            var all = obj.GetAll();
            var one = obj.GetElementById(&quot;s&quot;);
            var some = obj.GetElementsByName(&quot;somename&quot;);
            Assert.Multiple(() =&amp;gt;
            {
                Assert.AreEqual(1, all.Count());
                Assert.NotNull(one);
                Assert.AreEqual(3, some.Count());
            });
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上测试会通过.&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意以上的xxx==xxx并不是比较两个对象,Mock利用它进行赋值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;26&quot;&gt;
&lt;p&gt;很多初接触单元测试的朋友看完以上代码后可能感觉一脸懵,完全不理解利用moq在dao层生成一些看似无意义的假数据有什么意义,其实大家要明白单元测试的目的是什么,单元测试是以代码块为基础(通常是一个方法),测试这一个单元逻辑的正确性,在dao层,我们只关心这一层拿到数据后的处理逻辑.很多朋友可能知道ef可以搭建内存服务器来模拟真实数据库,这样也同样不依赖于外部的数据库.其实大家也可以这样做,也可以不这样而使用moq来模拟一个数据库连接上下文对象.因为在单元测试里,真实的数据是什么样的并不是首要关心的问题,而是这个代码单元逻辑的正确性.如果是做集成测试,我们则需要模拟一个真实环境,这个时候我们就需要使用内存服务器甚至使用外部服务器.当然,如果要做压力测试,我们还需要模拟产品运行时真实的物理环境,网络环境等条件(当然,很多时候直接在真实的运行环境进行测试了).总之我们要搞清楚不同的测试要解决什么样的问题,要达到什么样的目的,剩下的才是工具框架的使用.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 26 Aug 2019 00:29:00 +0000</pubDate>
<dc:creator>周国通</dc:creator>
<og:description>'系列目录' Moq库简介及安装 Moq简介 Moq是.net平台下的一个非常流行的模拟库,只要有一个接口它就可以动态生成一个对象,底层使用的是Castle的动态代理功能. 它的流行赖于依赖注入模式的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tylerzhou/p/11410337.html</dc:identifier>
</item>
<item>
<title>优化Recorder H5录音：可边录边转码上传服务器，支持微信提供Android IOS Hybrid App源码 - xiangyuecn</title>
<link>http://www.cnblogs.com/xiangyuecn/p/11410312.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiangyuecn/p/11410312.html</guid>
<description>&lt;blockquote readability=&quot;7.7142857142857&quot;&gt;
&lt;p&gt;Recorder H5 GitHub开源库随着支持功能的增多，音频转码处理效率渐渐的跟不上需求了，近期抽时间对音频转码部分进行了升级优化，以支持更多实用的功能。&lt;br/&gt;另外IOS的Hybrid App也完成了移植，Android和IOS都有了Demo App。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://xiangyuecn.github.io/Recorder/&quot;&gt;在线测试&lt;/a&gt;，GitHub地址：&lt;a href=&quot;https://github.com/xiangyuecn/Recorder&quot; class=&quot;uri&quot;&gt;https://github.com/xiangyuecn/Recorder&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;浏览器支持&quot;&gt;（1）浏览器支持&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;PC：包括但不限于&lt;code&gt;Chrome&lt;/code&gt;、&lt;code&gt;Firefox&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Android：&lt;code&gt;Chrome&lt;/code&gt;、&lt;code&gt;Firefox&lt;/code&gt;、&lt;code&gt;Android WebView&lt;/code&gt;、&lt;code&gt;腾讯Android X5内核(QQ、微信)&lt;/code&gt; &lt;em&gt;（不支持UC系列浏览器，如：UC、支付宝、大部分国产手机厂商的浏览器）&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;IOS：&lt;code&gt;Safari&lt;/code&gt;，&lt;code&gt;微信(JsSDK)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Hybrid App：提供Android、IOS端App的&lt;code&gt;JsBridge&lt;/code&gt;接口进行对接即可&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;功能支持&quot;&gt;（2）功能支持&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;已提供&lt;code&gt;mp3&lt;/code&gt; &lt;code&gt;wav&lt;/code&gt; &lt;code&gt;ogg(beta)&lt;/code&gt; &lt;code&gt;webm(beta)&lt;/code&gt; &lt;code&gt;amr(beta)&lt;/code&gt;格式支持，支持任意格式扩展&lt;/li&gt;
&lt;li&gt;提供实时音量反馈&lt;/li&gt;
&lt;li&gt;提供一个美观的实时波形绘制扩展插件&lt;/li&gt;
&lt;li&gt;录音权限请求和录音功能分开设计，可先请求权限，在需要的时候开始录音&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mp3&lt;/code&gt;格式录音文件默认2kb大小/秒，语音音质尚可，再降低音质可小到1kb/秒&lt;/li&gt;
&lt;li&gt;^【新】^ &lt;code&gt;mp3&lt;/code&gt; &lt;code&gt;wav&lt;/code&gt;格式转码“迅速”，结束录音时几乎可立即得到音频文件，另外可实现边录边转码成小语音片段文件实时上传服务器&lt;/li&gt;
&lt;li&gt;提供功能丰富的Demo，支持浏览器在线测试，^【新】^ 提供Android(15+) Hybrid App安装包和源码，^【新】^ 提供IOS(9.0+) Hybrid App源码供自行编译&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;移动端h5&quot;&gt;（1）移动端H5&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://tva1.sinaimg.cn/large/007X8olVly1g6crlpsjjng30ei0fcdn4.gif&quot; alt=&quot;移动端H5&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;ios-hybrid-app&quot;&gt;（2）IOS Hybrid App&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://tva1.sinaimg.cn/large/007X8olVly1g6crpoxewxg30jz0i5k18.gif&quot; alt=&quot;IOS Hybrid App&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;android-hybrid-app&quot;&gt;（3）Android Hybrid App&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://tva1.sinaimg.cn/large/007X8olVly1g6crpeeeorg30jz0i57ev.gif&quot; alt=&quot;Android Hybrid App&quot;/&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;移动端、PC端H5录音&lt;/li&gt;
&lt;li&gt;移动端、PC端H5发送语音&lt;/li&gt;
&lt;li&gt;移动端、PC端H5语音识别&lt;/li&gt;
&lt;li&gt;移动端、PC端H5语音聊天&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;为什么要升级优化&quot;&gt;（1）为什么要升级优化&lt;/h2&gt;
&lt;p&gt;最开始写Recorder的时候，只追求简短的语音录制，因此采用的是录音结束后一次性进行异步（setTimeout分片）转码，1分钟语音在pc端转码MP3花费100-300ms，移动端花费600-1500ms，体验上延迟不算大，并且代码逻辑很简单；如果使用Web Worker（多线程），几乎可以做到没有延迟，但代码似乎会复杂很多，就没有采用。&lt;/p&gt;
&lt;p&gt;后面实际使用过程中发现：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;稍微长点的语音转码移动端非常吃力，2、3分钟的语音要花费5、10秒进行MP3转码；&lt;/li&gt;
&lt;li&gt;进行实时转码发送给服务器时，除了wav格式本身编码非常迅速外，其他格式一律会导致录音卡顿，原因是编码占用了太多的时间，编码期间的录音数据无法正常接收。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;基于以上两点问题，似乎只有Web Worker（多线程）能够解决。&lt;/p&gt;
&lt;h2 id=&quot;开始使用web-worker加速转码&quot;&gt;（2）开始使用Web Worker加速转码&lt;/h2&gt;
&lt;p&gt;“加速”是要加引号的，其实开启了Web Worker支持，转码速度还是一样的速度，只是转码工作放到了后台线程，不占用页面的时间而已。&lt;/p&gt;
&lt;p&gt;但可以做到边录音边转码，不需要等到录音结束时扎堆转码，结果就是不管录制的语音有多长，结束录音时转码都是瞬间完成的。&lt;/p&gt;
&lt;p&gt;也可以完美的做到实时进行转码成小语音片段文件上传到服务器，因为转码不占用网页的时间了，录音可以正常的接收数据，不会产生卡顿。&lt;/p&gt;
&lt;h2 id=&quot;剩下的问题&quot;&gt;（3）剩下的问题&lt;/h2&gt;
&lt;p&gt;要支持边录边转码，并非仅仅开启Web Worker支持就可以了，还必须要有音频编码器的支持。如果编码器只能将完整的PCM数据一次性的转码成音频文件，那么就需要修改编码器源码，用来支持流式的转码，来一段PCM转一段。&lt;/p&gt;
&lt;p&gt;还好库里的MP3编码器是支持流式的，不需要改动就能用；不过其他的格式不改编码器源码似乎无法去支持；wav格式除外，wav编码速度出奇的快，不用优化也是没有问题的。&lt;/p&gt;
&lt;p&gt;因此目前MP3格式使用了Web Worker，MP3和wav格式都支持边录边转码，其他格式依旧是结束录音时异步（setTimeout分片）转码。&lt;/p&gt;

&lt;p&gt;本身是无意义的（或者说纯粹是多余的），但无奈IOS各种不支持：非官方浏览器不支持、App内WebView不支持，但Android又各种都支持，本来纯粹的H5一把梭（包括在Hybrid App中）是最方便的，苹果要拖后腿也没办法。&lt;/p&gt;
&lt;p&gt;因此仅需在IOS的Hybrid App上做兼容即可，但考虑到简化js端的复杂性（出问题了好甩锅），不管是Android还是IOS都实现一下可能会简单很多；另外Android和IOS的音频编码并非易事，且不易更新，使用js版的音频转码可大大简化App的逻辑；所以Android端也提供Hybrid App支持。&lt;/p&gt;

&lt;p&gt;GitHub仓库内有所有的源代码，有详细的使用介绍和Demo，有使用交流群，如果使用过程中有什么问题可以提issue或发消息。要是能打赏支持就更好了，仓库内有二维码。哈哈嘿~ GitHub地址：&lt;a href=&quot;https://github.com/xiangyuecn/Recorder&quot; class=&quot;uri&quot;&gt;https://github.com/xiangyuecn/Recorder&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 26 Aug 2019 00:19:00 +0000</pubDate>
<dc:creator>xiangyuecn</dc:creator>
<og:description>[TOC] Recorder H5 GitHub开源库随着支持功能的增多，音频转码处理效率渐渐的跟不上需求了，近期抽时间对音频转码部分进行了升级优化，以支持更多实用的功能。 另外IOS的Hybrid</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiangyuecn/p/11410312.html</dc:identifier>
</item>
<item>
<title>Swoole引擎原理的快速入门干货 - 全菜工程师小辉</title>
<link>http://www.cnblogs.com/mseddl/p/11410291.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mseddl/p/11410291.html</guid>
<description>&lt;p&gt;更多内容，欢迎关注微信公众号：全菜工程师小辉~&lt;/p&gt;
&lt;p&gt;过去一年使用PHP和Java两种技术栈完成了一个游戏服务器项目。由于项目中有高频的网络请求，所以PHP技术栈尝试使用Swoole引擎（基于事件的高性能异步并行网络通信引擎）来完成部分游戏业务。&lt;/p&gt;

&lt;p&gt;安装swoole很简单，由于是国人做的项目，很多issue可以在&lt;a href=&quot;https://www.swoole.com&quot;&gt;官网&lt;/a&gt;文档找到答案。安装分两种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;编译安装。直接去github或者gitee去下载官方的发行版，编译安装后，将so拓展写入php.ini文件。&lt;/li&gt;
&lt;li&gt;容器安装。swoole引擎应用广泛，所以hub上有很多可用的容器，选择需要的pull一下即可。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;具体操作百度一下即可，网上相关内容很多。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;&lt;li&gt;常驻内存。传统 PHP框架或者单文件，在处理每个请求之前，都要做一遍加载框架文件、配置的操作，请求完成之后会释放所有资源和内存，无须担心内存泄漏。但是如果请求数量上升，并发很高的时候，快速创建资源，又马上释放，会导致 PHP 程序运行效率急剧下降。而使用 Swoole 则没有这个问题：PHP的代码加载到内存后，拥有更长的生命周期，这样建立的数据库连接和其他大的对象，不被释放。每次请求只需要处理很少的代码，而这些代码只在第一次运行时，被 PHP 解析器编译，驻留内存。以后都是直接载入 OPCODE ，让 Zend 引擎直接运行。另外，之前PHP不能实现的，如数据库连接池，缓存连接池都可以在Swoole引擎下实现。系统的运行效率会大大提高。&lt;/li&gt;
&lt;li&gt;快速开发。Swoole引擎提供了PHP语言的异步多线程服务器，异步TCP/UDP网络客户端，异步MySQL，异步Redis，数据库连接池，AsyncTask，消息队列，毫秒定时器，异步文件读写，异步DNS查询。 Swoole内置了Http/WebSocket服务器端/客户端、Http2.0服务器端。&lt;/li&gt;
&lt;li&gt;协程编程模式。Swoole4可以使用完全同步的代码实现异步程序。PHP代码无需额外增加任何关键词，底层自动进行协程调度，实现异步IO。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Swoole运行的流程图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1327889/201908/1327889-20190826080624929-380750057.png&quot; alt=&quot;Swoole的运行图&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;swoole中的线程或进程&quot;&gt;Swoole中的线程或进程&lt;/h2&gt;
&lt;p&gt;结构图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1327889/201908/1327889-20190826080625230-1801021952.jpg&quot; alt=&quot;Swoole的线程图&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Swoole引擎分为两种模式：单线程模式和进程模式。本文只讨论进程模式。具体两者区别官方文档中有说明。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;master进程&quot;&gt;Master进程&lt;/h3&gt;
&lt;p&gt;用于处理swoole核心事件，比如来自客户端的连接，本地通讯的管道。master进程里有多个线程，每个线程运行了一个epol函数的实例。（由于Worker进程并不是由Master进程fork出来的，所以可能会出现强行kill Master进程后，Worker进程依旧存在）&lt;/p&gt;
&lt;h3 id=&quot;reactor线程&quot;&gt;Reactor线程&lt;/h3&gt;
&lt;p&gt;Swoole的主进程是一个多线程的程序。其中有一组很重要的线程，称之为Reactor线程。它就是真正处理TCP连接，收发数据的线程。&lt;br/&gt;Swoole的主线程在Accept新的连接后，会将这个连接分配给一个固定的Reactor线程，并由这个线程负责监听此socket。在socket可读时读取数据，并进行协议解析，将请求投递到Worker进程。在socket可写时将数据发送给TCP客户端&lt;/p&gt;
&lt;h3 id=&quot;manager进程&quot;&gt;Manager进程&lt;/h3&gt;
&lt;p&gt;swoole中worker/task进程都是由Manager进程Fork并管理的。&lt;br/&gt;子进程结束运行时，manager进程负责回收此子进程，避免成为僵尸进程。并创建新的子进程&lt;br/&gt;服务器关闭时，manager进程将发送信号给所有子进程，通知子进程关闭服务&lt;br/&gt;服务器reload时，manager进程会逐个关闭/重启子进程&lt;/p&gt;
&lt;h3 id=&quot;worker进程&quot;&gt;Worker进程&lt;/h3&gt;
&lt;p&gt;Swoole提供了完善的进程管理机制，当Worker进程异常退出，如发生PHP的致命错误、被其他程序误杀，或达到max_request次数之后正常退出。主进程会重新拉起新的Worker进程。 Worker进程内可以像普通的apache+php或者php-fpm中写代码。不需要像Node.js那样写异步回调的代码。&lt;/p&gt;
&lt;h2 id=&quot;各进程的回调函数&quot;&gt;各进程的回调函数&lt;/h2&gt;
&lt;p&gt;Master内的回调函数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;onStart&lt;/li&gt;
&lt;li&gt;onShutdown&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Worker进程内的回调函数&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;onWorkerStart&lt;/li&gt;
&lt;li&gt;onWorkerStop&lt;/li&gt;
&lt;li&gt;onConnect&lt;/li&gt;
&lt;li&gt;onClose&lt;/li&gt;
&lt;li&gt;onReceive&lt;/li&gt;
&lt;li&gt;onFinish&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;TaskWorker进程内的回调函数&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;onTask&lt;/li&gt;
&lt;li&gt;onWorkerStart&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Manager进程内的回调函数&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;onManagerStart&lt;/li&gt;
&lt;li&gt;onManagerStop&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;reactorworkertaskworker的关系&quot;&gt;Reactor、Worker、TaskWorker的关系&lt;/h2&gt;
&lt;p&gt;可以理解为Reactor就是nginx，Worker就是php-fpm。Reactor线程异步并行地处理网络请求，然后再转发给Worker进程中去处理。Reactor和Worker间通过UnixSocket进行通信。&lt;br/&gt;在php-fpm的应用中，经常会将一个任务异步投递到Redis等队列中，并在后台启动一些php进程异步地处理这些任务。Swoole提供的TaskWorker是一套更完整的方案，将任务的投递、队列、php任务处理进程管理合为一体。通过底层提供的API可以非常简单地实现异步任务的处理。另外TaskWorker还可以在任务执行完成后，再返回一个结果反馈到Worker。&lt;br/&gt;Swoole的Reactor、Worker、TaskWorker之间可以紧密的结合起来，提供更高级的使用方式。一个更通俗的比喻：假设Swoole应用服务器是一个工厂，那Reactor就是销售，接受客户订单。而Worker就是工人，当销售接到订单后，Worker去工作生产出客户要的东西。而TaskWorker可以理解为行政人员，可以帮助Worker干些杂事，让Worker专心工作。&lt;br/&gt;底层会为Worker进程、TaskWorker进程分配一个唯一的ID。不同的Worker和TaskWorker进程之间可以通过sendMessage接口进行通信。&lt;/p&gt;
&lt;h2 id=&quot;实际项目中的各进程线程的分工&quot;&gt;实际项目中的各进程线程的分工：&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Manager进程：负责管理worker进程，创建或回收&lt;/li&gt;
&lt;li&gt;Worker进程：游戏逻辑处理&lt;/li&gt;
&lt;li&gt;taskWorker进程：向客户端发网络包、关闭长期不活跃的tcp连接&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;swoole版本兼容性&quot;&gt;Swoole版本兼容性&lt;/h2&gt;
&lt;p&gt;该项目开发阶段使用的swoole引擎版本1.9.6，后来由于测试环境安装成了4.3.2版本，所以尝试业务代码作调整。不过swoole的向下兼容很值得佩服的是，这过程中竟然只发现了一处代码不兼容的问题：是有关swoole_server的一项配置参数，在原来版本采用了魔鬼数字进行配置的，但是到新版本，这个数字没有被宏定义，后来通过查看swoole源码找到了宏定义组，然后修改了这处配置。（不过版本升级顺利也是基于swoole的业务代码比较少，所以仅供参考）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1327889/201908/1327889-20190826080625378-2001569378.png&quot; alt=&quot;哎呀，如果我的名片丢了。微信搜索“全菜工程师小辉”，依然可以找到我&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 26 Aug 2019 00:06:00 +0000</pubDate>
<dc:creator>全菜工程师小辉</dc:creator>
<og:description>更多内容，欢迎关注微信公众号：全菜工程师小辉~ 过去一年使用PHP和Java两种技术栈完成了一个游戏服务器项目。由于项目中有高频的网络请求，所以PHP技术栈尝试使用Swoole引擎（基于事件的高性能异</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mseddl/p/11410291.html</dc:identifier>
</item>
<item>
<title>mybatis多表查询之多对多关系查询的实现-xml方式 - 全me村的希望</title>
<link>http://www.cnblogs.com/hopeofthevillage/p/11410221.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hopeofthevillage/p/11410221.html</guid>
<description>&lt;p&gt;　　Mybatis对于多对多关系下的查询提供了集合（collection）的概念来解决，collection属性是resultMap高级结果映射的子集，首先，在本例中我们使用的是集合元素来解决多对多的查询。 然后你会注意到有一个新的 “ofType” 属性。这个属性非常重要，它用来将 JavaBean（或字段）属性的类型和集合存储的类型区分开来。在集合中ofType指的是集合中元素的类型。&lt;/p&gt;
&lt;p&gt;　　首先介绍一下Demo情况：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;实体类:User（用户）类和Role（角色）类，类中的属性在后面代码中贴出&lt;/li&gt;
&lt;li&gt;关系：一个用户可以有多个角色，一个角色可以赋予多个用户中&lt;/li&gt;
&lt;li&gt;数据库表结构：用户表、角色表、中间表（用于存储用户和角色的关系）&lt;/li&gt;
&lt;li&gt;本例中实现查询的目标：查询用户时同时获取用户所拥有的角色的信息（当查询角色时同时获取角色所属用户的信息的情况和下面的例子原理一样，主要是修改select中的sql语句）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　1.用户实体类以及角色实体类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; User &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Serializable{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer id;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String username;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Date birthday;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String sex;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String address;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; List&amp;lt;Role&amp;gt;&lt;span&gt; roles;

    get和set方法省略 ......     
}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Role &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Serializable{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer roleId;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String roleName;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String roleDesc;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; List&amp;lt;User&amp;gt;&lt;span&gt; users;
     get和set方法省略 ......     
}    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里主要是增加用户所拥有的角色的List属性和角色所属用户的List属性，后面做resultMap结果映射的时候使用。&lt;/p&gt;
&lt;p&gt;  　　2.数据库表结构&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;84&quot;&gt;
&lt;pre&gt;
&lt;span&gt;DROP TABLE IF EXISTS user;
CREATE TABLE user (
    id INT(11) NOT NULL auto_increment,
    username VARCHAR(32) NOT NULL COMMENT '用户名称',
    birthday datetime default NULL COMMENT '生日',
    sex char(1) default NULL COMMENT '性别',
    address varchar(256) default NULL COMMENT '地址',
    PRIMARY KEY (id)
)ENGINE=InnoDB default CHARSET=utf8
INSERT INTO `user` VALUES ('41', '老王', '2018-02-27 17:47:08', '男', '石家庄');
INSERT INTO `user` VALUES ('45', '老李', '2018-02-27 17:47:08', '男', '石家庄');
INSERT INTO `user` VALUES ('46', '老郭', '2018-02-27 17:47:08', '男', '石家庄');
INSERT INTO `user` VALUES ('47', 'mde', '2019-06-26 15:04:25', '女', '河南');
INSERT INTO `user` VALUES ('48', 'nan', '2019-08-01 15:04:54', '女', '合肥');



DROP TABLE IF EXISTS role;
CREATE TABLE role(
ID int(11) NOT NULL COMMENT '编号',
ROLE_NAME VARCHAR(30) DEFAULT NULL COMMENT '角色名称',
ROLE_DESC VARCHAR(60) DEFAULT NULL COMMENT  '角色描述',
PRIMARY KEY (ID)
)ENGINE=INNODB DEFAULT CHARSET=utf8

INSERT INTO role (ID,ROLE_NAME,ROLE_DESC) VALUES (1,'院长','管理整个学院'),(2,'总裁','管理整个公司'),(3,'校长','管理整个学校');


DROP TABLE IF EXISTS user_role;
CREATE TABLE user_role(
UID int(11) NOT NULL COMMENT '用户编号',
RID INT(11) NOT NULL COMMENT '角色编号',
PRIMARY KEY (UID,RID),
CONSTRAINT FK_Reference_10 FOREIGN KEY(RID) REFERENCES role(ID),
CONSTRAINT FK_Reference_9 FOREIGN KEY(UID) REFERENCES user(id)
)ENGINE=INNODB DEFAULT CHARSET=utf8;
INSERT INTO user_role(UID,RID) VALUES(41,1),(45,1),(41,2);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里主要是增加了中间表。&lt;/p&gt;
&lt;p&gt; 　　3.在UserDao接口中声明查询所有用户的方法findAll();&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 查询所有的用户同时查询出所拥有的角色的信息
     *
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    List&lt;/span&gt;&amp;lt;User&amp;gt; findAll();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　4.在UserDao.xml中配置findAll()方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mapper &lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt;=&quot;com.example.dao.UserDao&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;resultMap &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;userMap&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;com.example.domain.User&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;id &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;id&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;id&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;username&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;username&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;birthday&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;birthday&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;sex&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;sex&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;address&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;address&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;collection &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;roles&quot;&lt;/span&gt;&lt;span&gt; ofType&lt;/span&gt;&lt;span&gt;=&quot;com.example.domain.Role&quot;&lt;/span&gt;&lt;span&gt; resultMap&lt;/span&gt;&lt;span&gt;=&quot;roleMap&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;resultMap&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;resultMap &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;roleMap&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;com.example.domain.Role&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;id &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;roleId&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;rid&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;roleName&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;ROLE_NAME&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;roleDesc&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;ROLE_DESC&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;resultMap&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;findAll&quot;&lt;/span&gt;&lt;span&gt; resultMap&lt;/span&gt;&lt;span&gt;=&quot;userMap&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
       SELECT u.*,r.ID as rid,r.ROLE_DESC,r.ROLE_NAME FROM user u
         LEFT OUTER JOIN user_role ur on u.id = ur.UID
          LEFT OUTER JOIN role r on ur.RID = r.ID
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;mapper&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　实现多对多关系查询的主要工作都放在了这里，首先通过resultMap 声明用户类的结果映射，id以及result等标签就是User类中的基本属性，User类中的角色属性roles通过collection集合标签来映射到结果集中，&amp;lt;collection property=&quot;roles&quot; ofType=&quot;com.example.domain.Role&quot; resultMap=&quot;roleMap&quot;/&amp;gt;，property对应User类中声明的roles属性，ofType用于标识集合中元素的类型，resultMap用于引用其他的结果映射来说明集合中元素的属性，在这里为roleMap。如果roleMap不在其他地方使用，也可以直接将角色的属性直接配置在collection属性的子集里，如以下形式也可以使用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;resultMap &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;userMap&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;com.example.domain.User&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;id &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;id&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;id&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;username&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;username&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;birthday&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;birthday&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;sex&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;sex&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;address&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;address&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;&amp;lt;collection property=&quot;roles&quot; ofType=&quot;com.example.domain.Role&quot; resultMap=&quot;roleMap&quot;/&amp;gt;&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;collection &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;roles&quot;&lt;/span&gt;&lt;span&gt; ofType&lt;/span&gt;&lt;span&gt;=&quot;com.example.domain.Role&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;br/&gt;&lt;/span&gt;　　　　　　　　&amp;lt;!--这里的rid是role表中的id,在select语句中为了防止id字段在两个表中都出现导致的重复，所以给role的字段id 起了别名 注意要与select中的别名保持一致--&amp;gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;id &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;roleId&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;rid&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;roleName&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;ROLE_NAME&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;roleDesc&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;ROLE_DESC&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;collection&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;resultMap&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; select中的SQL查询语句解释：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;findAll&quot;&lt;/span&gt;&lt;span&gt; resultMap&lt;/span&gt;&lt;span&gt;=&quot;userMap&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
       SELECT u.*,r.ID as rid,r.ROLE_DESC,r.ROLE_NAME FROM user u
         LEFT OUTER JOIN user_role ur on u.id = ur.UID
          LEFT OUTER JOIN role r on ur.RID = r.ID
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　u.*：查询USER表中所有的属性&lt;/p&gt;
&lt;p&gt;　　r.ID as rid：对于role表中的id起一个别名rid&lt;/p&gt;
&lt;p&gt;　　user u LEFT OUTER JOIN user_role ur on u.id = ur.UID：前面的表左连接后面的表，并且连接条件是User表中的id与User_role表中的uid相等&lt;/p&gt;
&lt;p&gt;　　5.测试代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('77f13d2e-f29c-4187-ba33-59ab407f9d1b')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_77f13d2e-f29c-4187-ba33-59ab407f9d1b&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_77f13d2e-f29c-4187-ba33-59ab407f9d1b&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('77f13d2e-f29c-4187-ba33-59ab407f9d1b',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_77f13d2e-f29c-4187-ba33-59ab407f9d1b&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserDaoTest {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; InputStream in;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; SqlSession session;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; UserDao userDao;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; SqlSessionFactory factory;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    @Before
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; init()&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception{
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取配置文件&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         in = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取工厂&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;         factory = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SqlSessionFactoryBuilder().build(in);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;         session =&lt;span&gt; factory.openSession();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;         userDao = session.getMapper(UserDao.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    @After
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; destory()&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception{
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        session.commit();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        session.close();
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        in.close();
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    @Test
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; findAllTest(){
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         List&amp;lt;User&amp;gt; userList =&lt;span&gt; userDao.findAll();
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (User user: userList){
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             System.out.println(&quot;每个用户的信息&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;            System.out.println(user);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;            System.out.println(user.getRoles());
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;6.测试结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1765949/201908/1765949-20190826030536482-1365126557.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 25 Aug 2019 19:10:00 +0000</pubDate>
<dc:creator>全me村的希望</dc:creator>
<og:description>Mybatis对于多对多关系下的查询提供了集合（collection）的概念来解决，collection属性是resultMap高级结果映射的子集，首先，在本例中我们使用的是集合元素来解决多对多的查询</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hopeofthevillage/p/11410221.html</dc:identifier>
</item>
<item>
<title>【持续集成】GitLab CI + Docker 实现持续集成 - 周二</title>
<link>http://www.cnblogs.com/jojop/p/11409075.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jojop/p/11409075.html</guid>
<description>&lt;h2 id=&quot;一持续集成continuous-integration-ci的基本概念&quot;&gt;一、持续集成（Continuous Integration， CI）的基本概念&lt;/h2&gt;
&lt;h3 id=&quot;概述&quot;&gt;概述&lt;/h3&gt;
&lt;p&gt;在传统软件的开发中，代码的集成工作通常是在所有人都将工作完成后在项目即将结束进行时，而这往往会花费大量的时间和精力。而持续集成是一种将集成阶段放在软件开发阶段的做法，以便更加有规律地构建，测试和集成代码。&lt;/p&gt;
&lt;p&gt;“持续集成并不能消除 Bug，而是让它们非常容易发现和改正。”&lt;/p&gt;
&lt;p&gt;持续集成可以在开发人员提交了新代码后，立刻进行构建、单元测试。从而我们可以根据测试结果以确定新的代码或者环境配置与原来的以及其他开发人员的代码或者环境配置能否正确地集成在一起。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://106.53.89.78:8888/images/2019/08/25/img1.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;持续交付-持续部署&quot;&gt;持续交付 &amp;amp; 持续部署&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;持续交付（Continuous Delivery）：频繁地将软件的新版本，交付给质量团队或者用户，以供评审。如果评审通过，代码就进入生产阶段。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;持续部署（Continuous Deployment）：是持续交付的下一步，指的是代码评审以后，自动部署到生产环境。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://106.53.89.78:8888/images/2019/08/25/img3.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;二gitlab-持续集成起步&quot;&gt;二、GitLab 持续集成起步&lt;/h2&gt;
&lt;p&gt;从 GitLab 8.0 开始，GitLab CI 就已经集成在 GitLab 中，我们只需要在项目中添加一个 &lt;code&gt;.gitlab-ci.yml&lt;/code&gt; 文件，然后添加一个 &lt;code&gt;Runner&lt;/code&gt;，即可进行持续集成。而且随着 GitLab 的升级，GitLab 也变得越来越强大。&lt;/p&gt;
&lt;h3 id=&quot;gitlab-ci.yml&quot;&gt;.gitlab-ci.yml&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;.gtilab-ci.yml&lt;/code&gt; 文件存放与项目于仓库的根目录，用以来定义 GitLab CI/CD 中的 &lt;code&gt;Pipeline&lt;/code&gt;。其实无非是一个配置文件，理解起来挺简单的，我们主要是需要了解 &lt;code&gt;Pipeline&lt;/code&gt; 的概念以及如何配置一个 &lt;code&gt;.gitlab-ci.yml&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;pipeline-stages-jobs&quot;&gt;Pipeline &amp;amp; Stages &amp;amp; Jobs&lt;/h3&gt;
&lt;p&gt;一个 Pipeline 大概相对于一个构建任务，里面可以包含多个流程，如安装依赖、运行测试、编译、部署测试服务器、部署生产服务器等流程，Git 提交时会触发 Pipeline。而一个 Pipeline 中又可以包含一至多个 &lt;code&gt;Stage&lt;/code&gt;，即用来定义安装依赖、运行测试之类的流程的。然后，一个 Stage 中又包含了一至多个 &lt;code&gt;Job&lt;/code&gt;，Jobs 表示一个 Stage 中具体的构建工作，即某个 Stage 里面执行的工作。我们可以在 Stages 里面定义这些 Job，它们之间的关系如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://106.53.89.78:8888/images/2019/08/26/img4.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Stages 会按 &lt;code&gt;.gitlab-ci.yml&lt;/code&gt; 中配置的顺序执行，当前面的 Stage 执行完毕后才会继续执行后面的 Stage，如果一个 Stage 失败，那么后面的 Stage 不会执行，该构建任务失败。&lt;/li&gt;
&lt;li&gt;Stage 中的 Jobs 会并行执行，当这个 Stage 中所有的 Job 都执行完毕，该 Stage 才算执行成功。换而言之，只要有一个 Job 执行失败，整个 Pipeline 也就失败了。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;yml&quot;&gt;
&lt;code&gt;stages:
 - build
 - test
 - deploy
 
build:
  stage: build
  script: 
    - &quot;execute-script-for-build&quot;
    - &quot;do something...&quot;&quot;
  only:
    - master
  tags:
    - ruby
    - postage

test:
  stage: test
  script:
  
......
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面配置将一次 pipeline 分成了三个阶段：build、test、deploy。下面介绍配置文件中的节点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;stages： 定义构建的阶段；&lt;/li&gt;
&lt;li&gt;build、test、...：定义 jobs_name，即在 stages 中定义的 stage 阶段，一般在 stage 节点注明所属的 stage；&lt;/li&gt;
&lt;li&gt;script：Runner 执行的脚本或命令，该节点是必须的。&lt;/li&gt;
&lt;li&gt;其他节点：stage 中还有许多其他节点，例如 only、tags 等，但并不是 required ，其具体作用可在文档中了解。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;gitlab-runner&quot;&gt;GitLab Runner&lt;/h3&gt;
&lt;p&gt;当我们理解完上面的概念后，我们还没了解最重要的东西——上面的任务由谁来构建呢？答案就是 Gitlab-runner 了！&lt;/p&gt;
&lt;p&gt;为什么不用 GitLab CI 来运行这些构建任务呢？&lt;/p&gt;
&lt;p&gt;一般来说，构建任务任务都会占用很多的系统资源（譬如编译代码），而 GitLab CI 又是 GitLab 的一部分，如果由 GitLab CI 来运行构建任务的话，在执行构建任务的时候， GitLab 的性能会大幅下降。&lt;/p&gt;
&lt;p&gt;GitLab CI 最大的作用是管理各个项目的构建状态，因此，运行构建任务这种浪费资源的事情就交给 GitLab Runner 来做啦！&lt;/p&gt;
&lt;p&gt;因为 GitLab Runner 可以安装到不同的机器上，所以在构建任务运行期间并不会影响到 GitLab 的性能。&lt;/p&gt;
&lt;h2 id=&quot;三持续集成的实现&quot;&gt;三、持续集成的实现&lt;/h2&gt;
&lt;p&gt;接下来介绍 GitLab 对 Spring Boot 程序的持续集成，当然 GitLab 不止支持 Java 应用服务，肯定也支持其他编译语言，这里主要只是像演示一下过程，过程基本上是相通的。&lt;/p&gt;
&lt;h3 id=&quot;搭建-gitlab-服务&quot;&gt;搭建 GitLab 服务&lt;/h3&gt;
&lt;p&gt;这不是本次的重点，所以就简要介绍下咯。&lt;br/&gt;利用 Docker 和 Docker Compose 快速搭建 GitLab 服务，docker-compose.yml 文件如下：&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;version: '3'
services:
    web:
      image: 'twang2218/gitlab-ce-zh:10.5'
      restart: always
      hostname: '192.168.253.139'
      environment:
        TZ: 'Asia/Shanghai'
        GITLAB_OMNIBUS_CONFIG: |
          external_url 'http://192.168.253.139:8080'
          gitlab_rails['gitlab_shell_ssh_port'] = 2222
          unicorn['port'] = 8888
          nginx['listen_port'] = 8080
      ports:
        - '8080:8080'
        - '8443:443'
        - '2222:22'
      volumes:
        - /usr/local/docker/gitlab/config:/etc/gitlab
        - /usr/local/docker/gitlab/data:/var/opt/gitlab
        - /usr/local/docker/gitlab/logs:/var/log/gitlab&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动完毕后，访问 &lt;a href=&quot;http://ip:8080%EF%BC%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AE%89%E8%A3%85%E5%AE%8C%E6%88%90%E5%90%8E%E6%95%88%E6%9E%9C%E5%A6%82%E4%B8%8B&quot; class=&quot;uri&quot;&gt;http://ip:8080，初始化安装完成后效果如下&lt;/a&gt;：&lt;br/&gt;&lt;img src=&quot;http://106.53.89.78:8888/images/2019/08/26/img5.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;设置初始化密码后刷新，就可以看见登录界面了，登录！&lt;/p&gt;
&lt;h4 id=&quot;配置-ssh-免密登录&quot;&gt;配置 SSH 免密登录&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;ssh-keygen -t rsa -P 'youname'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;复制用户目录下的 .ssh 文件夹下的公钥，将其复制到 GitLab 的&lt;br/&gt;&lt;img src=&quot;http://106.53.89.78:8888/images/2019/08/26/img6.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;构建-docker-runner&quot;&gt;构建 Docker Runner&lt;/h3&gt;
&lt;h4 id=&quot;环境准备&quot;&gt;环境准备&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;创建工作目录 &lt;code&gt;/usr/lcoal/docker/runner&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;创建构建目录 &lt;code&gt;/usr/local/docker/runner/enviroment&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;下载 &lt;code&gt;jdk-8u152-linux-x64.tar.gz&lt;/code&gt; 并复制到 &lt;code&gt;/usr/local/docker/runner/environment&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;dockerfile&quot;&gt;Dockerfile&lt;/h4&gt;
&lt;p&gt;在 &lt;code&gt;usr/lcoal/docker/runner/environment&lt;/code&gt; 目录下创建 &lt;code&gt;Dockerfile&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;FROM gitlab/gitlab-runner:v11.0.2

RUN echo 'deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiverse' &amp;gt; /etc/apt/sources.list &amp;amp;&amp;amp; \
    echo 'deb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiverse' &amp;gt;&amp;gt; /etc/apt/sources.list &amp;amp;&amp;amp; \
    echo 'deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiverse' &amp;gt;&amp;gt; /etc/apt/sources.list &amp;amp;&amp;amp; \
    echo 'deb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse' &amp;gt;&amp;gt; /etc/apt/sources.list &amp;amp;&amp;amp; \
    apt-get update -y &amp;amp;&amp;amp; \
    apt-get clean

RUN apt-get -y install apt-transport-https ca-certificates curl software-properties-common &amp;amp;&amp;amp; \
    curl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | apt-key add - &amp;amp;&amp;amp; \
    add-apt-repository &quot;deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable&quot; &amp;amp;&amp;amp; \
    apt-get update -y &amp;amp;&amp;amp; \
    apt-get install -y docker-ce

COPY daemon.json /etc/docker/daemon.json

WORKDIR /usr/local/bin
RUN wget https://raw.githubusercontent.com/topsale/resources/master/docker/docker-compose

RUN chmod +x docker-compose

RUN mkdir -p /usr/local/java
WORKDIR /usr/local/java
COPY jdk-8u152-linux-x64.tar.gz /usr/local/java
RUN tar -zxvf jdk-8u152-linux-x64.tar.gz &amp;amp;&amp;amp; \
    rm -fr jdk-8u152-linux-x64.tar.gz

RUN mkdir -p /usr/local/maven
WORKDIR /usr/local/maven
RUN wget https://raw.githubusercontent.com/topsale/resources/master/maven/apache-maven-3.5.3-bin.tar.gz

RUN tar -zxvf apache-maven-3.5.3-bin.tar.gz &amp;amp;&amp;amp; \
    rm -fr apache-maven-3.5.3-bin.tar.gz


ENV JAVA_HOME /usr/local/java/jdk1.8.0_152
ENV MAVEN_HOME /usr/local/maven/apache-maven-3.5.3
ENV PATH $PATH:$JAVA_HOME/bin:$MAVEN_HOME/bin

WORKDIR /&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;daemon.json&quot;&gt;daemon.json&lt;/h4&gt;
&lt;p&gt;在 &lt;code&gt;/usr/local/docker/runner/environment&lt;/code&gt; 目录下创建 &lt;code&gt;daemon.json&lt;/code&gt;，用于配置加速器和仓库地址&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
  &quot;registry-mirrors&quot;: [
    &quot;https://registry.docker-cn.com&quot;
  ],
  &quot;insecure-registries&quot;: [
    &quot;ip:port&quot;
  ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;新建-git-项目&quot;&gt;新建 Git 项目&lt;/h3&gt;
&lt;p&gt;新建一个 Git 项目，将其克隆到本地&lt;/p&gt;
&lt;h3 id=&quot;注册-runner&quot;&gt;注册 Runner&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;docker exec -it gitlab-runner gitlab-runner register

# 输入 GitLab 地址
Please enter the gitlab-ci coordinator URL (e.g. https://gitlab.com/):
http://192.168.75.146:8080/

# 输入 GitLab Token
Please enter the gitlab-ci token for this runner:
1Lxq_f1NRfCfeNbE5WRh

# 输入 Runner 的说明
Please enter the gitlab-ci description for this runner:
可以为空

# 设置 Tag，可以用于指定在构建规定的 tag 时触发 ci
Please enter the gitlab-ci tags for this runner (comma separated):
可以为空

# 选择 runner 执行器，这里我们选择的是 shell
Please enter the executor: virtualbox, docker+machine, parallels, shell, ssh, docker-ssh+machine, kubernetes, docker, docker-ssh:
shell&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上交互中，GitLab 地址和 Token 令牌可以在 GitLab 的项目的设置中找到：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://106.53.89.78:8888/images/2019/08/26/img7.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当上述步骤完成后，刷新当前页面，可以看见当前页面下多出来一个 runner：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://106.53.89.78:8888/images/2019/08/26/img8.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;完善项目&quot;&gt;完善项目&lt;/h3&gt;
&lt;p&gt;在这里我只简单地做了个小 dome，大概这么简单：&lt;br/&gt;&lt;img src=&quot;http://106.53.89.78:8888/images/2019/08/26/img9.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;项目中用到的 &lt;code&gt;.gitlab-ci.yml&lt;/code&gt;、&lt;code&gt;Dockerfile&lt;/code&gt;、&lt;code&gt;docker-compose.yml&lt;/code&gt; 如下：&lt;br/&gt;.gitlab-ci.yml&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;stages:
  - build
  - run
  - clean

build:
  stage: build
  script:
    - /usr/local/maven/apache-maven-3.5.3/bin/mvn clean package
    - cp target/ci-test-project-1.0.0-SNAPSHOT.jar docker
    - cd docker
    - docker build -t ci-test-project .

run:
  stage: run
  script:
    - cd docker
    - docker-compose down
    - docker-compose up -d

clean:
  stage: clean
  script:
    - docker rmi $(docker images -q -f dangling=true)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Dockerfile&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;FROM openjdk:8-jre

RUN mkdir /app

COPY ci-test-project-1.0.0-SNAPSHOT.jar /app/app.jar

ENTRYPOINT [&quot;java&quot;, &quot;-Djava.security.egd=file:/dev/./urandom&quot;, &quot;-jar&quot;, &quot;/app/app.jar&quot;]

EXPOSE 8080&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;docker-compose.yml&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;version: '3.1'
services:
  itoken-config:
    restart: always
    image: ci-test-project
    ports:
      - 8080:8080
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;提交项目&quot;&gt;提交项目&lt;/h3&gt;
&lt;p&gt;完成 demo 的之后就将项目提交到 GitLab 上，push 完成之后，点击项目的 CI/CD 可以看见一下页面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://106.53.89.78:8888/images/2019/08/26/img10.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再点击进入就可以看见具体的作业了，自行体会&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://106.53.89.78:8888/images/2019/08/26/img11.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当项目出现所有 jobs 全部通过时，也就是持续集成初步完善了，这时我们可以打开浏览器访问 &lt;code&gt;ip:8080&lt;/code&gt; 可以看见浏览器上显示&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Hello GitLab&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时我们可以尝试修改项目中的代码再提交，比如简单地将 &lt;code&gt;retuen &quot;Hello GitLab&quot;&lt;/code&gt; 改成 &lt;code&gt;return &quot;Hello World&quot;&lt;/code&gt; 再提交一遍代码，等 jobs 通过后，再刷新浏览器，我们可以看见&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Hello World&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至此，这个小 Demo 也就完成了。&lt;/p&gt;
&lt;h2 id=&quot;四参考&quot;&gt;四、参考&lt;/h2&gt;
</description>
<pubDate>Sun, 25 Aug 2019 16:36:00 +0000</pubDate>
<dc:creator>周二</dc:creator>
<og:description>GitLab CI + Docker 实现持续集成 一、持续集成（Continuous Integration， CI）的基本概念 概述 在传统软件的开发中，代码的集成工作通常是在所有人都将工作完成后</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jojop/p/11409075.html</dc:identifier>
</item>
<item>
<title>LinkedHashMap源码剖析 - 一缕清风007</title>
<link>http://www.cnblogs.com/xtz2018/p/11410102.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xtz2018/p/11410102.html</guid>
<description>&lt;p&gt;LinkedHashMap源码导读：&lt;/p&gt;
&lt;p&gt;1，概述&lt;/p&gt;
&lt;p&gt;2，LinkedHashMap与hashMap的一些关系&lt;/p&gt;
&lt;p&gt;3，LinkedHashMap核心成员变量&lt;/p&gt;
&lt;p&gt;4，LinkedHashMap核心方法&lt;/p&gt;

&lt;h2&gt;1，概述&lt;/h2&gt;
&lt;p&gt;前面讲了hashMap的一些原理，LinkedHashMap继承自hashMap，这篇文章我们来大概看看LinkedHashMap的原理。首先说明一下，HashMap是无序的也就是不会基于插入的顺序来读取，这种场景之下就会考虑使用LinkedHashMap。&lt;/p&gt;
&lt;h2&gt;2，LinkedHashMap与HashMap的一些关系&lt;/h2&gt;
&lt;p&gt;LinkedHashMap继承自HashMap,也就是是HashMap的子类，在HashMap那篇文章中，有一些回调函数就是子类来实现的，所以等会我们可以来看看。&lt;/p&gt;
&lt;p&gt;HashMap数据结构存放的元素是一个内部实现的类：Node&amp;lt;K,V&amp;gt;，同理LinkedHashMap也有个类似的元素Entry，也是继承自HashMap的Node&amp;lt;K,V&amp;gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Entry&amp;lt;K,V&amp;gt; &lt;span&gt;extends&lt;/span&gt; HashMap.Node&amp;lt;K,V&amp;gt;&lt;span&gt; {&lt;br/&gt;#多出来两个节点：before、after 可以组成一个双向链表，保持顺序。
        Entry&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; before, after;
        Entry(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; hash, K key, V value, Node&amp;lt;K,V&amp;gt;&lt;span&gt; next) {
            &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(hash, key, value, next);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3，LinkedHashMap核心成员变量&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    //用于指向双向链表的头部
    &lt;span&gt;transient&lt;/span&gt; LinkedHashMap.Entry&amp;lt;K,V&amp;gt;&lt;span&gt; head;
&lt;/span&gt;    //用于指向双向链表的尾部
    &lt;span&gt;transient&lt;/span&gt; LinkedHashMap.Entry&amp;lt;K,V&amp;gt; tail;&lt;br/&gt;//用来指定LinkedHashMap的迭代顺序：true表示的是按照基于访问的顺序来排序，就是把最近读的元素，放在链表的尾部；false表示的是按照插入的顺序来排序。&lt;br/&gt;final boolean accessOrder;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;4，LinkedHashMap核心方法&lt;/h2&gt;
&lt;h3&gt;4.1 put()&lt;/h3&gt;
&lt;p&gt;通过查看源码可以发现，LinkedHashMap调用的就是HashMap的put()方法。不过LinkedHashMap复写了其中的3个方法：newNode()、afterNodeAccess()、afterNodeInsertion()&lt;/p&gt;
&lt;h4&gt;newNode()：&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
    Node&amp;lt;K,V&amp;gt; newNode(&lt;span&gt;int&lt;/span&gt; hash, K key, V value, Node&amp;lt;K,V&amp;gt;&lt;span&gt; e) {&lt;br/&gt;#构造了一个LinkedHashMap.Entry对象，并调用linkNodeLast方法
        LinkedHashMap.Entry&lt;/span&gt;&amp;lt;K,V&amp;gt; p =
            &lt;span&gt;new&lt;/span&gt; LinkedHashMap.Entry&amp;lt;K,V&amp;gt;&lt;span&gt;(hash, key, value, e);&lt;br/&gt;linkNodeLast(p);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; p;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面看看linkNodeLast()方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; linkNodeLast(LinkedHashMap.Entry&amp;lt;K,V&amp;gt;&lt;span&gt; p) {
        LinkedHashMap.Entry&lt;/span&gt;&amp;lt;K,V&amp;gt; last =&lt;span&gt; tail;
        tail &lt;/span&gt;=&lt;span&gt; p;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (last == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            head &lt;/span&gt;=&lt;span&gt; p;
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            p.before &lt;/span&gt;=&lt;span&gt; last;
            last.after &lt;/span&gt;=&lt;span&gt; p;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面简单画个图，看看这个执行过程会怎么样。场景是：三个节点没有冲突，插入的图形是怎么样的（冲突就不画图了，其实很简单，对着源码来画图就可以）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1473559/201908/1473559-20190826001126919-549597155.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看出来是一个双向链表维持了一个顺序，遍历的时候只要知道首尾，就可以维持住顺序。&lt;/p&gt;
&lt;h4&gt; afterNodeAccess()：&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;void&lt;/span&gt; afterNodeAccess(Node&amp;lt;K,V&amp;gt; e) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; move node to last&lt;/span&gt;
        LinkedHashMap.Entry&amp;lt;K,V&amp;gt;&lt;span&gt; last;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (accessOrder &amp;amp;&amp;amp; (last = tail) !=&lt;span&gt; e) {
            LinkedHashMap.Entry&lt;/span&gt;&amp;lt;K,V&amp;gt; p =&lt;span&gt;
                (LinkedHashMap.Entry&lt;/span&gt;&amp;lt;K,V&amp;gt;)e, b = p.before, a =&lt;span&gt; p.after;
            p.after &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (b == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                head &lt;/span&gt;=&lt;span&gt; a;
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                b.after &lt;/span&gt;=&lt;span&gt; a;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (a != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                a.before &lt;/span&gt;=&lt;span&gt; b;
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                last &lt;/span&gt;=&lt;span&gt; b;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (last == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                head &lt;/span&gt;=&lt;span&gt; p;
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                p.before &lt;/span&gt;=&lt;span&gt; last;
                last.after &lt;/span&gt;=&lt;span&gt; p;
            }
            tail &lt;/span&gt;=&lt;span&gt; p;
            &lt;/span&gt;++&lt;span&gt;modCount;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里的accessOrder默认是false,并没有执行。&lt;/p&gt;
&lt;h4&gt;afterNodeInsertion()：&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;void&lt;/span&gt; afterNodeInsertion(&lt;span&gt;boolean&lt;/span&gt; evict) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; possibly remove eldest&lt;/span&gt;
        LinkedHashMap.Entry&amp;lt;K,V&amp;gt;&lt;span&gt; first;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (evict &amp;amp;&amp;amp; (first = head) != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; removeEldestEntry(first)) {
            K key &lt;/span&gt;=&lt;span&gt; first.key;
            removeNode(hash(key), key, &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里的removeEldestEntry总是返回false，所以并不执行。可能又是为了给子类复写，来扩展的。&lt;/p&gt;
&lt;p&gt;put()方法需要了解的点：&lt;/p&gt;
&lt;p&gt;有了hashMap的铺垫，其实这个还是很简单的。之所以能够按照顺序，是因为插入的时候维护了一个双向链表，秘密就在子类LinkedHashMap复写了newNode方法。所以以后写框架的话也需要扩展出一些方法，能够让子类来回调。&lt;/p&gt;
&lt;h3&gt;4.2 get()&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; V get(Object key) {
        Node&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; e;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((e = getNode(hash(key), key)) == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (accessOrder)
            afterNodeAccess(e);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; e.value;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;默认情况下get()也是和hashMap走的是一样的。&lt;/p&gt;
&lt;h3&gt;4.3 LinkedHashMap的迭代器&lt;/h3&gt;
&lt;p&gt;能够保持顺序，一是插入的时候维护的双向链表，，二是在迭代器中肯定使用了这种数据结构，我们来看看它的迭代器:LinkedEntryIterator，而它的父类是LinkedHashIterator，源码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LinkedHashIterator {
        LinkedHashMap.Entry&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; next;
        LinkedHashMap.Entry&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; current;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; expectedModCount;

        LinkedHashIterator() {
            next &lt;/span&gt;=&lt;span&gt; head;
            expectedModCount &lt;/span&gt;=&lt;span&gt; modCount;
            current &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; hasNext() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; next != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
&lt;br/&gt;#遍历的代码。可以看出来非常简单，就是遍历了这个双向链表。
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; LinkedHashMap.Entry&amp;lt;K,V&amp;gt;&lt;span&gt; nextNode() {&lt;br/&gt;#从首节点开始
            LinkedHashMap.Entry&lt;/span&gt;&amp;lt;K,V&amp;gt; e =&lt;span&gt; next;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (modCount !=&lt;span&gt; expectedModCount)
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConcurrentModificationException();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NoSuchElementException();
            current &lt;/span&gt;=&lt;span&gt; e;&lt;br/&gt;#依次进行遍历。
            next &lt;/span&gt;=&lt;span&gt; e.after;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; e;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; remove() {
            Node&lt;/span&gt;&amp;lt;K,V&amp;gt; p =&lt;span&gt; current;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (p == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalStateException();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (modCount !=&lt;span&gt; expectedModCount)
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConcurrentModificationException();
            current &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            K key &lt;/span&gt;=&lt;span&gt; p.key;
            removeNode(hash(key), key, &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
            expectedModCount &lt;/span&gt;=&lt;span&gt; modCount;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看出来是简单的链表遍历。有兴趣的朋友可以了解下hashMap的遍历流程。hashMap最后一个环节大概就说到这个话题了。可以再去看看源码，记住：源码出真知！！&lt;/p&gt;
</description>
<pubDate>Sun, 25 Aug 2019 16:13:00 +0000</pubDate>
<dc:creator>一缕清风007</dc:creator>
<og:description>LinkedHashMap源码导读： 1，概述 2，LinkedHashMap与hashMap的一些关系 3，LinkedHashMap核心成员变量 4，LinkedHashMap核心方法 1，概述</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xtz2018/p/11410102.html</dc:identifier>
</item>
<item>
<title>[程序人生]工作若干年，那些IT圈“活久见”的奇葩现象 - 宋者为王</title>
<link>http://www.cnblogs.com/andy-songwei/p/11410092.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/andy-songwei/p/11410092.html</guid>
<description>&lt;p&gt;        常言道，人活久了什么稀奇古怪的事都会见到。本文盘点几件刚毕业工作时想当然，工作若干年后啪啪打脸的“奇葩”事。&lt;/p&gt;

&lt;p&gt;       (1)去年推荐一朋友来我们公司面试时，朋友说起当年她去某游戏公司时，那公司HR说这家公司是游戏界的“黄埔军校”，在那里工作两年后再出去的员工，工资都翻倍了。听到这，我会心地笑了，把要说的话又咽了回去，因为我来当前公司的时候，面试官也说过同样的话，是手机界的“黄埔军校”，从这里工作两年出去的员工，都去了更好的公司，工资也翻倍。原来，那些自诩为“黄埔军校”的公司，都是在业界有那么一丢丢小名气，招人进来工资给得很低，干活多，又留不住人的公司。原来这就是“黄埔军校”……&lt;/p&gt;

&lt;p&gt;      (2)刚毕业时在一家创业公司做了3年，工资每年涨300块，我一度觉得这真够奇葩的。后来我一大学同学去某青宝工作，他说公司同事都不涨工资，一般工作两年就都走了。他老婆研究生毕业去了某骨文做测试，发现里面有的6年没涨过工资，吓得她干了两年就赶紧跳了。后来我在另外一家公司的同事，来自某知名手机公司，低薪校招进去后两年没涨工资，然后赶紧走了……刚工作时只知道IT企业涨薪慢，原来还有这么多从来不涨薪的公司！&lt;/p&gt;

&lt;p&gt;      (3)我一哥们经常拿我跟他姐夫比，他姐夫跟我年纪差不多，也做开发，平均每年跳槽两次，每次涨薪几千不等，短短五六年时间，月薪从几千慢慢跳到了5万以上，我这个几乎不怎么爱跳槽的人跟他比要差不少。一直以来我们都被灌输一种观点，太频繁跳槽的人，没公司会要他，没忠诚度，对职业生涯不好。但实际上，几年工作下来发现，很多有目的且频繁跳槽的人工资普遍比不怎么跳槽的人工资高不少，并且找工作也没什么阻力，总有公司要他们，无论是大公司还是小公司。那些说一看简历跳槽频繁就pass的用人企业，很大程度上就是付不起别人提的薪资要求而找一些冠冕堂皇的理由，美其名曰不稳定。当然，频繁跳槽会对去大公司产生一些不利因素，但也没那么恐怖，一般不会成为用人企业拒绝你的决定因素，他们更多看的还是工作能力。&lt;/p&gt;

&lt;p&gt;      (4)一大学同专业的同学，在一家公司做测试，前两三年工资没怎么变过。后来他所在的部门的业务因为某些原因没什么订单，他们团队被裁了，赔了几万块钱给他。两三个月后，这家公司又拿到订单了，很快又把他挖回来了，工资比以前有了大幅提升。有时候不是我们不值钱，而是没有找到真正需要自己的位置，还误以为自己能力不够，找到合适自己的位置真的很重要。&lt;/p&gt;

&lt;p&gt;       ……&lt;/p&gt;

&lt;p&gt;       我们绝大部分的人都受到很多固有思维的影响，很多现象总是想当然认为应该是某个样子，否则就是异类。世界是多元的，这些看似“奇葩”的事，其实都是赤裸裸的人性，只是我们大多数人都太“图样图森破”。&lt;/p&gt;

&lt;p&gt;      当然，我活了这么久，工作了这么多年，遇到的“奇葩”事还有很多，篇幅有限，先分享这么几件，有机会下回再继续。 广大的读者朋友们，有啥“奇葩”事，也来一起分享分享吧!&lt;/p&gt;
</description>
<pubDate>Sun, 25 Aug 2019 16:08:00 +0000</pubDate>
<dc:creator>宋者为王</dc:creator>
<og:description>常言道，人活久了什么事情就都会见到。想想刚毕业入行时很多事情都理所当然，工作几年后却被现实啪啪打脸。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/andy-songwei/p/11410092.html</dc:identifier>
</item>
</channel>
</rss>