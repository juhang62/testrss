<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>分布式数据库中间件 MyCat 搞起来！ - 江南一点雨</title>
<link>http://www.cnblogs.com/lenve/p/11100766.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lenve/p/11100766.html</guid>
<description>&lt;p&gt;关于 MyCat 的铺垫文章已经写了三篇了：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/bcyjBgEqg6Or5zdi4jHaiA&quot;&gt;MySQL 只能做小项目？松哥要说几句公道话！&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/qUGANVj2mmoMwUZEV5Zc1w&quot;&gt;北冥有 Data，其名为鲲，鲲之大，一个 MySQL 放不下！&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/7pj5E2HvmiejBJrW0T86oQ&quot;&gt;What？Tomcat 竟然也算中间件？&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;今天终于可以迎接我们的大 Boss 出场了！&lt;/p&gt;

&lt;p&gt;前面文章我们提到，如果数据量比较大的话，我们需要对数据进行分库分表，分完之后，原本存在一个数据库中的数据，现在就存在多个数据库中了，就像下面这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.javaboy.org/images/mysql/6-2.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么此时 MyCat 所扮演的角色就是分布式数据库中间件！&lt;/p&gt;
&lt;p&gt;MyCat 是一个开源的分布式数据库中间件，它实现了 MySQL 协议，在开发者眼里，他就是一个数据库代理，我们甚至可以使用 MySQL 的客户端工具以及命令行来访问 MyCat 。&lt;/p&gt;
&lt;p&gt;MyCat 现在已经不仅仅只支持 MySQL 了，同时也支持 MSSQL、Oracle、DB2、以及 PostgreSQL等主流数据库。甚至像 MongoDB 这种 NoSQL 也支持。&lt;/p&gt;

&lt;h2 id=&quot;搭建读写分离&quot;&gt;搭建读写分离&lt;/h2&gt;
&lt;p&gt;要搞 MyCat ，一般要先搭建好 MySQL 的读写分离，MySQL 的读写分离可以参考松哥之前的这篇文章：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/SC0OYM6yO_GxQh9DvSsnoQ&quot;&gt;提高性能，MySQL 读写分离环境搭建(二)&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;mycat-安装&quot;&gt;MyCat 安装&lt;/h2&gt;
&lt;p&gt;环境：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;CentOS7&lt;/li&gt;
&lt;li&gt;JDK1.8&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;MyCat 使用 Java 开发，因此，运行 MyCat ，一定要具备 Java 环境，配置 Java 运行环境这个比较容易，网上资料也很多，我就不详细介绍了。&lt;/p&gt;
&lt;p&gt;Java 环境安装好之后，首先下载 MyCat：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;wget http://dl.mycat.io/1.6.7.1/Mycat-server-1.6.7.1-release-20190213150257-linux.tar.gz&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下载完成后，对下载文件进行解压。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;tar -zxvf Mycat-server-1.6.7.1-release-20190213150257-linux.tar.gz&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解压成功后，会出现一个 &lt;code&gt;mycat&lt;/code&gt; 目录，进入到 &lt;code&gt;mycat/conf&lt;/code&gt; 目录，对 &lt;code&gt;mycat&lt;/code&gt; 进行配置：&lt;/p&gt;
&lt;p&gt;首先来配置 &lt;code&gt;schema.xml&lt;/code&gt; 文件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.javaboy.org/images/mysql/7-1.png&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;首先在 &lt;code&gt;schema&lt;/code&gt; 中指定逻辑库的名字，逻辑库是指 &lt;code&gt;MyCat&lt;/code&gt; 中的库，这个库不存储数据，数据存储在 &lt;code&gt;MySQL&lt;/code&gt; 中的物理库中。&lt;/li&gt;
&lt;li&gt;逻辑库中配置逻辑表，配置逻辑表时，需要指定 &lt;code&gt;dataNode&lt;/code&gt; 节点， &lt;code&gt;dataNode&lt;/code&gt; 就是指数据库存储的位置&lt;/li&gt;
&lt;li&gt;配置 &lt;code&gt;dataNode&lt;/code&gt; ，&lt;code&gt;dataNode&lt;/code&gt; 指定 &lt;code&gt;dataHost&lt;/code&gt; 和物理库的名字。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dataHost&lt;/code&gt; 则配置 &lt;code&gt;MySQL&lt;/code&gt; 的主机和从机的位置，登录密码等。主机和从机都可以配置多个。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;配置完 schema.xml 后 ，接下来配置 server.xml。&lt;/p&gt;
&lt;p&gt;server.xml 中主要配置 MyCat 的登录用户名和密码，以及需要操作的逻辑库。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.javaboy.org/images/mysql/7-2.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;配置完成后，接下来就可以启动 MyCat 了 。&lt;/p&gt;
&lt;p&gt;执行 MyCat 解压目录下的 bin 目录下的 mycat 命令，可以启动 MyCat&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;./bin/mycat start&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果启动后，提示无法创建 &lt;code&gt;mycat.pid&lt;/code&gt; 文件，就自己手动创建一个 &lt;code&gt;mycat.pid&lt;/code&gt; 文件。启动成功之后，就可以在本地连接 &lt;code&gt;MyCat&lt;/code&gt; 了，连接方式和 &lt;code&gt;MySQL&lt;/code&gt; 一样，唯一的区别在于端口号不同。&lt;/p&gt;
&lt;p&gt;在连接 &lt;code&gt;MyCat&lt;/code&gt; 之前，先在 &lt;code&gt;MySQL&lt;/code&gt; 物理库中创建 &lt;code&gt;db1&lt;/code&gt;、&lt;code&gt;db2&lt;/code&gt; 以及 &lt;code&gt;db3&lt;/code&gt; 三个数据库。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;SQLyog&lt;/code&gt; 连接：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.javaboy.org/images/mysql/7-3.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也可以在 &lt;code&gt;cmd&lt;/code&gt; 命令行登录 &lt;code&gt;MyCat&lt;/code&gt; ：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.javaboy.org/images/mysql/7-4.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;登录成功后 ，在 &lt;code&gt;MyCat&lt;/code&gt; 的窗口中，执行如下命令，创建表：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;create table t_user (id integer primary key,username varchar(255))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行成功后，我们会发现物理库中出现了相应的表。&lt;br/&gt;接下来，手动往各个物理库的物理表中存储一条数据，然后在 MyCat 窗口中查询：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.javaboy.org/images/mysql/7-5.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样就可以查询到 三个库中的三个表中的数据。&lt;/p&gt;

&lt;p&gt;整个过程不难，但是有的小伙伴在第一次配置的过程中还是容易出错，因此我这里还是来说两句，出错了要如何定位。&lt;/p&gt;
&lt;p&gt;一般来说，配置 MyCat 出错，问题可能发生在两个阶段。第一个阶段就是客户端连接 MyCat 出错，第二个阶段就是 MyCat 连接 MySQL 出错。&lt;/p&gt;
&lt;p&gt;无论你是使用 SQLyog 还是 Navicat ，我们在连接数据库的过程中，都可以先测试连接，很多人卡在这一步。&lt;/p&gt;
&lt;p&gt;如果在测试连接的时候就连接不通，说明是 MyCat 的问题，这个时候检查步骤如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;首先当然是查看日志信息，看能不能找出端倪&lt;/li&gt;
&lt;li&gt;通过 jps 命令查看 mycat 是否成功启动&lt;/li&gt;
&lt;li&gt;检查 server.xml 中配置是否正确，用户名密码是否输入正确&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这是第一种可能的问题，第二种问题就是测试连接没问题，但是测试完后，却连接不上。反映到 Navicat 上，就是测试连接没问题，测完之后，点击连接名要打开连接时，Navicat 就崩了，出现这个问题一般是 MyCat 在连接 MySQL 出问题了，这个时候就要去检查 schema.xml 文件中关于 MySQL 主机和从机的配置是否正确，数据库地址是否正确，用户名密码是否正确。&lt;/p&gt;

&lt;p&gt;好了，本文主要简单介绍了下 MyCat 的安装问题，下篇文章我们来看 MyCat 中的分片规则问题。&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;http://www.mycat.io/&quot;&gt;MyCat 官方文档&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;关注公众号【江南一点雨】，专注于 Spring Boot+微服务以及前后端分离等全栈技术，定期视频教程分享，关注后回复 Java ，领取松哥为你精心准备的 Java 干货！&lt;br/&gt;&lt;img src=&quot;http://www.javaboy.org/images/sb/javaboy.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 28 Jun 2019 00:51:00 +0000</pubDate>
<dc:creator>江南一点雨</dc:creator>
<og:description>关于 MyCat 的铺垫文章已经写了三篇了： 1. 'MySQL 只能做小项目？松哥要说几句公道话！' 2. '北冥有 Data，其名为鲲，鲲之大，一个 MySQL 放不下！' 3. 'What？To</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lenve/p/11100766.html</dc:identifier>
</item>
<item>
<title>《HelloGitHub》第 39 期 - 削微寒</title>
<link>http://www.cnblogs.com/xueweihan/p/11097717.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xueweihan/p/11097717.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;兴趣是最好的老师，&lt;strong&gt;HelloGitHub&lt;/strong&gt; 就是帮你找到兴趣！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201906/759200-20190627172349264-1031314241.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;分享 GitHub 上有趣、入门级的开源项目。&lt;/p&gt;
&lt;p&gt;这是一个面向&lt;strong&gt;编程新手&lt;/strong&gt;、&lt;strong&gt;热爱编程&lt;/strong&gt;、&lt;strong&gt;对开源社区感兴趣&lt;/strong&gt; 人群的月刊，月刊的内容包括：&lt;strong&gt;各种编程语言的项目&lt;/strong&gt;、&lt;strong&gt;让生活变得更美好的工具&lt;/strong&gt;、&lt;strong&gt;书籍、学习笔记、教程等&lt;/strong&gt;，这些开源项目大多都是非常容易上手，而且非常 Cool。主要是希望大家能动手用起来，加入到&lt;strong&gt;开源社区&lt;/strong&gt;中。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;会编程的可以贡献代码&lt;/li&gt;
&lt;li&gt;不会编程的可以反馈使用这些工具中的 Bug&lt;/li&gt;
&lt;li&gt;帮着宣传你觉得优秀的项目&lt;/li&gt;
&lt;li&gt;Star 项目⭐️&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在浏览、参与这些项目的过程中，你将学习到&lt;strong&gt;更多编程知识&lt;/strong&gt;、&lt;strong&gt;提高编程技巧&lt;/strong&gt;、&lt;strong&gt;找到编程的乐趣&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;🎉 最后 &lt;a href=&quot;https://hellogithub.com/&quot;&gt;HelloGitHub&lt;/a&gt; 这个项目就诞生了 🎉&lt;/p&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;3.5882352941176&quot;&gt;
&lt;p&gt;&lt;strong&gt;以下为本期内容&lt;/strong&gt;｜每个月 &lt;strong&gt;28&lt;/strong&gt; 号发布最新一期｜&lt;a href=&quot;https://github.com/521xueweihan/HelloGitHub#%E5%86%85%E5%AE%B9&quot;&gt;点击查看往期内容&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;c-项目&quot;&gt;C# 项目&lt;/h4&gt;
&lt;p&gt;1、&lt;a href=&quot;https://github.com/2881099/FreeSql&quot;&gt;FreeSql&lt;/a&gt;：一个功能强大的 C# 对象关系映射程序（ORM），支持 .NETCore 2.1+、.NETFramework 4.5+ 开发模式下，开箱即用，可繁可简的使用方式。支持 CodeFirst 迁移、丰富的表达式函数、支持多种数据库、大量采用 ExpressionTree 技术提升性能等功能。示例代码：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var t0 = fsql.Select&amp;lt;Tag&amp;gt;()
    .Where(a =&amp;gt; a.Parent.Parent.Name == &quot;粤语&quot;)
    .IncludeMany(a =&amp;gt; a.Tags, then =&amp;gt; then.Where(sub =&amp;gt; sub.Name == &quot;xxx&quot;))
    .ToList();

var t3 = fsql.Select&amp;lt;Xxx&amp;gt;()
    .Where(a =&amp;gt; a.IsDelete == 0)
    .WhereIf(keyword != null, a =&amp;gt; a.UserName.Contains(keyword))
    .WhereIf(role_id &amp;gt; 0, a =&amp;gt; a.RoleId == role_id)
    .Where(a =&amp;gt; a.Nodes.AsSelect().Any(t =&amp;gt; t.Parent.Id == t.UserId))
    .Count(out var total)
    .Page(page, size)
    .OrderByDescending(a =&amp;gt; a.Id)
    .ToList()&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;c-项目-1&quot;&gt;C++ 项目&lt;/h4&gt;
&lt;p&gt;2、&lt;a href=&quot;https://github.com/p-ranav/pprint&quot;&gt;pprint&lt;/a&gt;：一个让输出变得更漂亮的 C++ 库。就像 python 语言的 pprint 库，它对基本类型、字符串、复数、enum 类型、STL 容器等做了输出格式优化，有了缩紧和分行才更容易发现这个世界的美好。示例代码如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;pprint.hpp&amp;gt;
printer.print(std::map&amp;lt;std::string, std::set&amp;lt;int&amp;gt;&amp;gt;{{&quot;foo&quot;, {1, 2, 3, 3, 2, 1}}, {&quot;bar&quot;, {7, 6, 5, 4}}});

// 输出结果如下
{
  &quot;bar&quot; : {4, 5, 6, 7}, 
  &quot;foo&quot; : {1, 2, 3}
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3、&lt;a href=&quot;https://github.com/Gltina/marksencent&quot;&gt;marksencent&lt;/a&gt;：这是一个在托福听力中标记句子的工具（即精听工具）。在听力时可文本对照，并且对听力音频中没听懂片段进行标记，并选择标记理由，方便日后的反复复习&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201906/759200-20190627160306195-1358194840.gif&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;css-项目&quot;&gt;CSS 项目&lt;/h4&gt;
&lt;p&gt;4、&lt;a href=&quot;https://github.com/Remix-Design/RemixIcon&quot;&gt;RemixIcon&lt;/a&gt;：一套免费、可商用、设计精美、细致的图标库。看到它第一眼后，我感觉自己之前用的图标简直就是枯草🙈。这个项目可以让开发者、设计师在一个图标库中快速找到适合的图标，用于自己的网站或 APP 开发。不同于混搭收集的图标库，RemixIcon 的每一枚图标都是由设计师精心设计而成，并且每一枚图标都包含填充和描边两种风格，便于切换使用&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201906/759200-20190627160334659-1199129539.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;go-项目&quot;&gt;Go 项目&lt;/h4&gt;
&lt;p&gt;5、&lt;a href=&quot;https://github.com/olivia-ai/olivia&quot;&gt;olivia&lt;/a&gt;：一个类似 Siri 的开源语音助手，目前只支持英文。开源的语音助手并不多，而且涉及的问题很复杂，现在有了它就可以基于这个项目做一些有趣的小应用&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201906/759200-20190627160358313-1702643307.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;6、&lt;a href=&quot;https://github.com/target/goalert&quot;&gt;goalert&lt;/a&gt;：一个基于 Go 语言实现的报警和处理报警系统。它以发请求或者手动添加方式进行告警，支持短信、电话、发邮件等通知方式。集成了一个看板，基本上算是开箱即用。安装命令如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker run -it --rm -p 8081:8081 goalert/all-in-one
访问本地 8081 端口，用户名 admin，密码 admin123&lt;/code&gt;
&lt;/pre&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201906/759200-20190627160424842-1822672406.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;7、&lt;a href=&quot;https://github.com/geziyor/geziyor&quot;&gt;geziyor&lt;/a&gt;：Go 的分布式爬虫框架。示例代码：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func main() {
    geziyor.NewGeziyor(&amp;amp;geziyor.Options{
        StartURLs: []string{&quot;http://quotes.toscrape.com/&quot;},
        ParseFunc: quotesParse,
// exporter 可以用来把最终结果存成各种格式，例如 json
        Exporters: []geziyor.Exporter{exporter.JSONExporter{}},
    }).Start()
}

// 请求的结果直接进了一个管道处理函数，这样的函数可以串联起来，爬虫和清洗二合一
// 这样拆分爬虫逻辑，某些逻辑也可以重用
func quotesParse(g *geziyor.Geziyor, r *geziyor.Response) {
    r.HTMLDoc.Find(&quot;div.quote&quot;).Each(func(i int, s *goquery.Selection) {
        g.Exports &amp;lt;- map[string]interface{}{
            &quot;text&quot;:   s.Find(&quot;span.text&quot;).Text(),
            &quot;author&quot;: s.Find(&quot;small.author&quot;).Text(),
        }
    })
    if href, ok := r.HTMLDoc.Find(&quot;li.next &amp;gt; a&quot;).Attr(&quot;href&quot;); ok {
        g.Get(r.JoinURL(href), quotesParse)
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;8、&lt;a href=&quot;https://github.com/bitfield/script&quot;&gt;script&lt;/a&gt;：一个封装好的 OS 三方库，解决了 Go 使用 OS 标准库错误处理的麻烦。如果没有它，打开一个文件查找一个关键字再统计下数量，你至少会需要 2-3 个异常处理的逻辑。有了它，只需要：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;numErrors, err := script.File(&quot;test.txt&quot;).Match(&quot;Error&quot;).CountLines()
// 等同于 grep Error test.txt | wc -l&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;9、&lt;a href=&quot;https://github.com/unidoc/unioffice&quot;&gt;unioffice&lt;/a&gt;：一个让 Go 可以创建、操作 Office Word、Excel、Powerpoint 三件套的库。示例代码：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;dox := document.New()
doc.X().Background = wordprocessingml.NewCT_Background()
doc.X().Background.ColorAttr = &amp;amp;wordprocessingml.ST_HexColor{}
doc.X().Background.ColorAttr.ST_HexColorRGB = color.RGB(50, 50, 50).AsRGBString()&lt;/code&gt;
&lt;/pre&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201906/759200-20190627160459415-813848662.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;java-项目&quot;&gt;Java 项目&lt;/h4&gt;
&lt;p&gt;10、&lt;a href=&quot;https://github.com/TheAlgorithms/Java&quot;&gt;Java&lt;/a&gt;：一份算法清单，详细演示了 Java 中内置的算法实现。如果你想要知道平时使用 Java 时，Java 的内置算法如何帮你处理任务，那么这个项目值得一读。此外，这份清单中还用到了配图来帮助你理解&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201906/759200-20190627160523339-842802651.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;11、&lt;a href=&quot;https://github.com/KunMinX/Linkage-RecyclerView&quot;&gt;Linkage-RecyclerView&lt;/a&gt;：一款基于 MVP 架构开发的二级联动列表控件，高度解耦、轻松配置、使用方便。依托于 MVP 的 “配置解耦” 特性，使用者无需知道内部的实现细节，仅通过实现配置类即可完成功能的定制和扩展。此外，在不设置自定义配置的情况下，最少只需一行代码即可运行起来&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201906/759200-20190627160549347-863484152.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;12、&lt;a href=&quot;https://github.com/dkzwm/SmoothRefreshLayout&quot;&gt;SmoothRefreshLayout&lt;/a&gt;：一个高效、强大的 Android 刷新库。支持越界回弹、二级刷新、横向刷新、拉伸回弹、类QQ下拉回弹效果等&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201906/759200-20190627160620032-1965543784.gif&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;javascript-项目&quot;&gt;JavaScript 项目&lt;/h4&gt;
&lt;p&gt;13、&lt;a href=&quot;https://github.com/lyricat/wechat-format&quot;&gt;wechat-format&lt;/a&gt;：公众号文章的排版真是让人头大，还好有这个微信公众号排版编辑器。便捷地把 Markdown 内容转换成微信特定的 HTML 内容，然后粘贴到公众号的编辑后台就完活了。虽然不是特别美观，但是节省了很多时间，&lt;a href=&quot;https://lab.lyric.im/wxformat/&quot;&gt;在线尝试&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;14、&lt;a href=&quot;https://github.com/haizlin/fe-interview&quot;&gt;fe-interview&lt;/a&gt;：每天早上 4 个基础前端面试题，助你在前端面试中‘所向披靡’，无人能挡&lt;/p&gt;
&lt;p&gt;15、&lt;a href=&quot;https://github.com/WarpPrism/AutoPiano&quot;&gt;AutoPiano&lt;/a&gt;：自由钢琴（AutoPiano）是利用 HTML5 技术开发的在线钢琴应用。在学习工作之余可以享受钢琴、音乐的美好，支持钢琴曲的自动播放功能、按键提示。让学习钢琴变得简单，谁都可以练成‘钢琴手’，&lt;a href=&quot;http://www.autopiano.cn/&quot;&gt;在线体验&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;16、&lt;a href=&quot;https://github.com/wonderbeyond/HitUP&quot;&gt;HitUP&lt;/a&gt;：一款发现 Top 系列的 Chrome 扩展。它会替换掉浏览器默认的 New Tab 空白页面，助你保持对流行技术趋势的跟进。核心功能是展示 GitHub 上近期最流行的项目，并会围绕 “Find top things” 的主题谨慎添加新特性，让你对新技术和新事物‘了如指掌’&lt;/p&gt;
&lt;p&gt;17、&lt;a href=&quot;https://github.com/pqina/filepond&quot;&gt;filepond&lt;/a&gt;：一个 JavaScript 文件上传库。可以上传拖入的任何内容，具有体积小、上传快、方便的文件管理等特点，从而让用户享受‘丝滑’般的文件上传体验&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201906/759200-20190627160659290-562732976.gif&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;objective-c-项目&quot;&gt;Objective-C 项目&lt;/h4&gt;
&lt;p&gt;18、&lt;a href=&quot;https://github.com/OpenEmu/OpenEmu&quot;&gt;OpenEmu&lt;/a&gt;：在 macOS 系统上回味下童年时的游戏，一个可以玩各种复古游戏的游戏机&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201906/759200-20190627160727456-1138102719.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;php-项目&quot;&gt;PHP 项目&lt;/h4&gt;
&lt;p&gt;19、&lt;a href=&quot;https://github.com/FreshRSS/FreshRSS&quot;&gt;FreshRSS&lt;/a&gt;：一个 PHP 写的免费自托管 RSS 阅读器（free and free），据说上万条订阅都不带卡顿。可分配多账户、支持第三方安卓、iOS 客户端、支持 FEVER API 协议，与 Rsshub 搭配使用，完美解决 RSS 重度用户的痛点。是 RSS 爱好者的福音和神器&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201906/759200-20190627160749090-1116083327.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;python-项目&quot;&gt;Python 项目&lt;/h4&gt;
&lt;p&gt;20、&lt;a href=&quot;https://github.com/giampaolo/psutil&quot;&gt;psutil&lt;/a&gt;：一个跨平台库的进程和系统资源监控、管理库。用于查看有关正在运行的进程和系统利用率，如 CPU、内存、磁盘、网络等信息。 实现了 UNIX 命令行工具提供的许多功能，例如：ps、top、lsof、netstat、ifconfig 等，支持 Linux、Windows、macOS 等系统。学会了这个库，就可以通过 Python 脚本做更多有趣的事情了。查看内存的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; psutil.virtual_memory()
svmem(total=10367352832, available=6472179712, percent=37.6, used=8186245120, free=2181107712, active=4748992512, inactive=2758115328, buffers=790724608, cached=3500347392, shared=787554304)
&amp;gt;&amp;gt;&amp;gt; psutil.swap_memory()
sswap(total=2097147904, used=296128512, free=1801019392, percent=14.1, sin=304193536, sout=677842944)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;21、&lt;a href=&quot;https://github.com/3b1b/manim&quot;&gt;manim&lt;/a&gt;：一个生成数学教学视频的动画引擎。它用编程的方式创建精美的数学动画，让数学更加易懂。效果如&lt;br/&gt;3Blue1Brown 的视频中所展示的那样，效果炫酷。但要学会和用好这个工具需要花些精力&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201906/759200-20190627160822446-585546572.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;22、&lt;a href=&quot;https://github.com/soimort/you-get&quot;&gt;you-get&lt;/a&gt;：一个 Python 写的视频下载工具，下载工具千万个但我仅仅推荐了这个工具。是因为正常情况下载不了视频的网站，用它你就可以方便地下载下来。剩下的要自己去看介绍，不能再多说了🙊&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;(env) ➜  ~ you-get 'https://v.ifeng.com/c/7msWmwppMPC'
Site:       ifeng.com
Title:      完整版第五期：陈晓卿 中国有俩行当门槛极低——美食圈和摄影圈
Type:       MPEG-4 video (video/mp4)
Size:       0.01 MiB (8578 Bytes)

Downloading 完整版第五期：陈晓卿 中国有俩行当门槛极低——美食圈和摄影圈.mp4
 100% (  0.0/  0.0MB) ├████████████████████┤[1/1]   71 kB/s
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;23、&lt;a href=&quot;https://github.com/crsmithdev/arrow&quot;&gt;arrow&lt;/a&gt;：还在为处理时间、时区、转化、夏令时等问题而头疼吗？这个 Python 的第三方时间库。提供了更便捷的方式来创建、操作和格式化时间和日期，用更少的代码来处理时间和日期。示例代码：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; import arrow
&amp;gt;&amp;gt;&amp;gt; utc = arrow.utcnow()
&amp;gt;&amp;gt;&amp;gt; utc
&amp;lt;Arrow [2013-05-11T21:23:58.970460+00:00]&amp;gt;

&amp;gt;&amp;gt;&amp;gt; utc = utc.replace(hours=-1)
&amp;gt;&amp;gt;&amp;gt; utc
&amp;lt;Arrow [2013-05-11T20:23:58.970460+00:00]&amp;gt;

&amp;gt;&amp;gt;&amp;gt; local = utc.to('US/Pacific')
&amp;gt;&amp;gt;&amp;gt; local
&amp;lt;Arrow [2013-05-11T13:23:58.970460-07:00]&amp;gt;

&amp;gt;&amp;gt;&amp;gt; arrow.get('2013-05-11T21:23:58.970460+00:00')
&amp;lt;Arrow [2013-05-11T21:23:58.970460+00:00]&amp;gt;

&amp;gt;&amp;gt;&amp;gt; local.timestamp
1368303838&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;24、&lt;a href=&quot;https://github.com/Macr0phag3/GithubMonitor&quot;&gt;GithubMonitor&lt;/a&gt;：由于很多猪队友的存在，公司敏感信息通过 GitHub 泄露出去是很常见的。这个项目主要根据关键字与 hosts 生成的关键词，利用 GitHub 提供的 API 监控 Git 泄漏，并在检测到信息泄露的时候发送邮件通知&lt;/p&gt;
&lt;h4 id=&quot;ruby-项目&quot;&gt;Ruby 项目&lt;/h4&gt;
&lt;p&gt;25、&lt;a href=&quot;https://github.com/ddnexus/pagy&quot;&gt;pagy&lt;/a&gt;：特别快的 Ruby 分页库。具有效率高、易用、自定义等特性，只需要少量代码就可实现分页。还有丰富文档可够参考，如果你要在 Ruby 程序中实现分页又不想自己费神，那就快试试这个吧&lt;/p&gt;
&lt;h4 id=&quot;swift-项目&quot;&gt;Swift 项目&lt;/h4&gt;
&lt;p&gt;26、&lt;a href=&quot;https://github.com/michaelvillar/timer-app&quot;&gt;timer-app&lt;/a&gt;：一个 macOS 上简单的计时器软件。拖动蓝色箭头设置时间，当时间到了会显示通知，并发出一个很好的声音&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201906/759200-20190627160900794-2081464642.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;其它&quot;&gt;其它&lt;/h4&gt;
&lt;p&gt;27、&lt;a href=&quot;https://github.com/zhaoolee/ChineseBQB&quot;&gt;ChineseBQB&lt;/a&gt;：表情包资源库，我悄悄的下了好几张，终于可以在群里挺起腰板了&lt;/p&gt;
&lt;p&gt;28、&lt;a href=&quot;https://github.com/dyweb/papers-notebook&quot;&gt;papers-notebook&lt;/a&gt;：论文阅读笔记，包含：分布式、虚拟化、容器、机器学习等方面。可以作为学习计算机部分专业论文的入门资料&lt;/p&gt;
&lt;p&gt;29、&lt;a href=&quot;https://github.com/Wei-Xia/most-frequent-technology-english-words&quot;&gt;most-frequent-technology-english-words&lt;/a&gt;：程序员工作中常见、应知应会的英语词汇列表。该列表中的单词是英语类计算机书籍、文档、文章中高频常见的技术词汇。最终目的是希望程序员结合自身的英语基础，在掌握列表中的词汇后，可以无障碍阅读英语技术文章和文档&lt;/p&gt;
&lt;p&gt;30、&lt;a href=&quot;https://github.com/ddzy/fe-necessary-book&quot;&gt;fe-necessary-book&lt;/a&gt;：该项目主要是分享一些技术书籍，也会不定期分享一些开发者必备的软件、工具包、社区、相亲等程序员相关的资源。放松的时候来看看挺不错的✌️&lt;/p&gt;
&lt;h4 id=&quot;开源书籍&quot;&gt;开源书籍&lt;/h4&gt;
&lt;p&gt;31、&lt;a href=&quot;https://github.com/Snowming04/The-Hacker-Playbook-3-Translation&quot;&gt;The-Hacker-Playbook-3-Translation&lt;/a&gt;：《The Hacker Playbook 3》中文翻译版（渗透测试实战红队第三版）&lt;/p&gt;
&lt;h4 id=&quot;机器学习&quot;&gt;机器学习&lt;/h4&gt;
&lt;p&gt;32、&lt;a href=&quot;https://github.com/Jiakui/awesome-bert&quot;&gt;awesome-bert&lt;/a&gt;：与 bert 相关的 nlp 论文、应用、资源集合。紧跟自然语言处理发展前沿，便于加速开展相关研究工作&lt;/p&gt;
&lt;p&gt;33、&lt;a href=&quot;https://github.com/itisyang/ImageMiniLab&quot;&gt;ImageMiniLab&lt;/a&gt;：图像迷你实验室，可进行图像实验、处理、分析。使用 PyQt5 结合 opencv-python 实现代码简洁易读，通过该工具可以快速演示图像算法效果，便于 cv 入门学习&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201906/759200-20190627160929917-1640481166.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;34、&lt;a href=&quot;https://github.com/PetrochukM/PyTorch-NLP&quot;&gt;PyTorch-NLP&lt;/a&gt;：简称 torchnlp 是一个支持快速原型设计（包括数据集和神经网络层）的 PyTorch-NLP 工具包。该库封装好了神经网络层、文本处理模块和数据集库，有利于加速自然语言处理研究和实践。示例代码：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# Load a Dataset
from torchnlp.datasets import imdb_dataset

# Load the imdb training dataset
train = imdb_dataset(train=True)
train[0]  # RETURNS: {'text': 'For a movie that gets..', 'sentiment': 'pos'}

# Apply Neural Networks Layers
import torch
from torchnlp.nn import LockedDropout

input_ = torch.randn(6, 3, 10)
dropout = LockedDropout(0.5)

# Apply a LockedDropout to `input_`
dropout(input_) # RETURNS: torch.FloatTensor (6x3x10)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;35、&lt;a href=&quot;https://github.com/zihangdai/xlnet&quot;&gt;xlnet&lt;/a&gt;：CMU 全新 XLNet 预训练模型。BERT 带来的影响还未平复，CMU 与谷歌大脑提出的 XLNet 在 20 个任务上的表现超过了 BERT，并在 18 个任务上取得了当前最佳效果。令人激动的是目前 XLNet 已经开放了训练代码和大型预训练模型，这回又有的玩了&lt;/p&gt;
&lt;p&gt;36、&lt;a href=&quot;https://github.com/rasbt/deeplearning-models&quot;&gt;deeplearning-models&lt;/a&gt;：各种深度学习架构、模型和技巧的集合。TensorFlow 和 PyTorch 的各种深度学习架构、模型和技巧的 Jupyter 集合，非常适合学习&lt;/p&gt;
&lt;hr/&gt;&lt;p align=&quot;center&quot;&gt;“看完了，还不够？&lt;a href=&quot;https://github.com/521xueweihan/HelloGitHub#%E5%86%85%E5%AE%B9&quot;&gt;&amp;lt;往期内容&amp;gt;&lt;/a&gt; | 还不过瘾，那就看看每天更新的前端日报吧 &lt;a href=&quot;https://daily.fairyever.com/&quot;&gt;&amp;lt;今日前端&amp;gt;&lt;/a&gt;”&lt;br/&gt;如果你发现了好玩、有意义的开源项目 &lt;a href=&quot;https://github.com/521xueweihan/HelloGitHub/issues/new&quot;&gt;点击这里&lt;/a&gt; 分享你觉得有趣的项目。&lt;/p&gt;
&lt;h2 id=&quot;公众号&quot;&gt;公众号&lt;/h2&gt;
&lt;p&gt;最近开了公众号，后续公众号会针对月刊推荐过的内容精选、梳理，做成系列的文章发布。月刊也会同时发布在公众号，便于第一时间阅读。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201906/759200-20190627161011301-451224177.png&quot;/&gt;&lt;br/&gt;欢迎关注 HelloGitHub 公众号，获取更多开源项目的资料和内容。&lt;/p&gt;
&lt;h2 id=&quot;声明&quot;&gt;声明&lt;/h2&gt;
&lt;p&gt;&lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by-sa/4.0/&quot;&gt;&lt;img alt=&quot;知识共享许可协议&quot; src=&quot;https://i.creativecommons.org/l/by-sa/4.0/88x31.png&quot;/&gt;&lt;/a&gt;&lt;br/&gt;本作品采用&lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by-sa/4.0/&quot;&gt;知识共享署名-相同方式共享 4.0 国际许可协议&lt;/a&gt;进行许可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;欢迎转载，请注明出处和作者，同时保留声明。&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 28 Jun 2019 00:50:00 +0000</pubDate>
<dc:creator>削微寒</dc:creator>
<og:description>兴趣是最好的老师， HelloGitHub 就是帮你找到兴趣！ 简介 分享 GitHub 上有趣、入门级的开源项目。 这是一个面向 编程新手 、 热爱编程 、 对开源社区感兴趣 人群的月刊，月刊的内容</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xueweihan/p/11097717.html</dc:identifier>
</item>
<item>
<title>用JavaScript刷LeetCode的正确姿势 - wenr</title>
<link>http://www.cnblogs.com/wenruo/p/11100537.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wenruo/p/11100537.html</guid>
<description>&lt;p&gt;&lt;span&gt;虽然很多人都觉得前端算法弱，但其实 JavaScript 也可以刷题啊！最近两个月断断续续刷完了 leetcode 前 200 的 middle + hard ，总结了一些刷题常用的模板代码。&lt;span&gt;走过路过发现 bug 请指出，拯救一个辣鸡（但很帅）的少年就靠您啦！&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;常用函数&lt;/h2&gt;
&lt;p&gt;包括打印函数和一些数学函数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
const _max =&lt;span&gt; Math.max.bind(Math);
const _min &lt;/span&gt;=&lt;span&gt; Math.min.bind(Math);
const _pow &lt;/span&gt;=&lt;span&gt; Math.pow.bind(Math);
const _floor &lt;/span&gt;=&lt;span&gt; Math.floor.bind(Math);
const _round &lt;/span&gt;=&lt;span&gt; Math.round.bind(Math);
const _ceil &lt;/span&gt;=&lt;span&gt; Math.ceil.bind(Math);
const log &lt;/span&gt;=&lt;span&gt; console.log.bind(console);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;const log = _ =&amp;gt; {}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;log&lt;/span&gt; 在提交的代码中当然是用不到的，不过在调试时十分有用。但是当代码里面加了很多 &lt;span class=&quot;cnblogs_code&quot;&gt;log&lt;/span&gt; 的时候，提交时还需要一个个注释掉就相当麻烦了，只要将 &lt;span class=&quot;cnblogs_code&quot;&gt;log&lt;/span&gt; 赋值为空函数就可以了。&lt;/p&gt;
&lt;p&gt;举一个简单的例子，下面的代码是可以直接提交的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 计算 1+2+...+n&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; const log = console.log.bind(console);&lt;/span&gt;
const log = _ =&amp;gt;&lt;span&gt; {}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; sumOneToN(n) {
    let sum &lt;/span&gt;= 0&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (let i = 1; i &amp;lt;= n; i++&lt;span&gt;) {
        sum &lt;/span&gt;+=&lt;span&gt; i;
        log(`i&lt;/span&gt;=${i}: sum=&lt;span&gt;${sum}`);
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; sum;
}

sumOneToN(&lt;/span&gt;10);
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 class=&quot;heading&quot;&gt;位运算的一些小技巧&lt;/h2&gt;
&lt;p&gt;判断一个整数 &lt;code&gt;x&lt;/code&gt; 的奇偶性： &lt;span class=&quot;cnblogs_code&quot;&gt;x &amp;amp; 1 = 1&lt;/span&gt; &lt;code&gt; (奇数) ，  &lt;span class=&quot;cnblogs_code&quot;&gt;x &amp;amp; 1 = 0&lt;/span&gt;  (偶数)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;求一个浮点数 &lt;code&gt;x&lt;/code&gt; 的整数部分： &lt;span class=&quot;cnblogs_code&quot;&gt;~~x&lt;/span&gt; ，对于正数相当于  &lt;span class=&quot;cnblogs_code&quot;&gt;floor(x)&lt;/span&gt;  对于负数相当于  &lt;span class=&quot;cnblogs_code&quot;&gt;ceil(-x)&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;计算  &lt;span class=&quot;cnblogs_code&quot;&gt;2 ^ n&lt;/span&gt; ： &lt;span class=&quot;cnblogs_code&quot;&gt;1 &amp;lt;&amp;lt; n&lt;/span&gt;  相当于  &lt;span class=&quot;cnblogs_code&quot;&gt;pow(2, n)&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;计算一个数 &lt;code&gt;x&lt;/code&gt; 除以 2 的 n 倍： &lt;span class=&quot;cnblogs_code&quot;&gt;x &amp;gt;&amp;gt; n&lt;/span&gt;  相当于  &lt;span class=&quot;cnblogs_code&quot;&gt;~~(x / pow(2, n))&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;判断一个数 &lt;code&gt;x&lt;/code&gt; 是 2 的整数幂（即  &lt;span class=&quot;cnblogs_code&quot;&gt;x = 2 ^ n&lt;/span&gt; ）:  &lt;span class=&quot;cnblogs_code&quot;&gt;x &amp;amp; (x - 1) = 0&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;※注意※：上面的位运算只对32位带符号的整数有效，如果使用的话，一定要注意数！据！范！围！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;记住这些技巧的作用：&lt;/p&gt;
&lt;p&gt;提升运行速度 ❌&lt;/p&gt;
&lt;p&gt;提升逼格 ✅&lt;/p&gt;
&lt;p&gt;举一个实用的例子，快速幂（原理自行google）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 计算x^n n为整数&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; qPow(x, n) {
    let result &lt;/span&gt;= 1&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (n) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (n &amp;amp; 1) result *= x; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 同 if(n%2)&lt;/span&gt;
        x = x *&lt;span&gt; x;
        n &lt;/span&gt;&amp;gt;&amp;gt;= 1; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 同 n=floor(n/2)&lt;/span&gt;
&lt;span&gt;    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 class=&quot;heading&quot;&gt;链表&lt;/h2&gt;
&lt;p&gt;刚开始做 LeetCode 的题就遇到了很多链表的题。恶心心。最麻烦的不是写题，是调试啊！！于是总结了一些链表的辅助函数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 链表节点
 * @param {*} val
 * @param {ListNode} next
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt; ListNode(val, next = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.val =&lt;span&gt; val;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.next =&lt;span&gt; next;
}
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 将一个数组转为链表
 * @param {array} a
 * @return {ListNode}
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
const getListFromArray &lt;/span&gt;= (a) =&amp;gt;&lt;span&gt; {
    let dummy &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ListNode()
    let pre &lt;/span&gt;=&lt;span&gt; dummy;
    a.forEach(x &lt;/span&gt;=&amp;gt; pre = pre.next = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ListNode(x));
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; dummy.next;
}
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 将一个链表转为数组
 * @param {ListNode} node
 * @return {array}
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
const getArrayFromList &lt;/span&gt;= (node) =&amp;gt;&lt;span&gt; {
    let a &lt;/span&gt;=&lt;span&gt; [];
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (node) {
        a.push(node.val);
        node &lt;/span&gt;=&lt;span&gt; node.next;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; a;
}
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 打印一个链表
 * @param {ListNode} node 
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
const logList &lt;/span&gt;= (node) =&amp;gt;&lt;span&gt; {
    let str &lt;/span&gt;= 'list: '&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (node) {
        str &lt;/span&gt;+= node.val + '-&amp;gt;'&lt;span&gt;;
        node &lt;/span&gt;=&lt;span&gt; node.next;
    }
    str &lt;/span&gt;+= 'end'&lt;span&gt;;
    log(str);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;还有一个常用小技巧，每次写链表的操作，都要注意判断表头，如果创建一个空表头来进行操作会方便很多。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
let dummy = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ListNode();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回&lt;/span&gt;
&lt;span&gt;return&lt;/span&gt; dummy.next;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用起来超爽哒~举个例子。@leetcode 82。题意就是删除链表中连续相同值的节点。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
 * @lc app=leetcode id=82 lang=javascript
 *
 * [82] Remove Duplicates from Sorted List II
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * @param {ListNode} head
 * @return {ListNode}
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; deleteDuplicates = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(head) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 空指针或者只有一个节点不需要处理&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (head === &lt;span&gt;null&lt;/span&gt; || head.next === &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; head;

    let dummy &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ListNode();
    let oldLinkCurrent &lt;/span&gt;=&lt;span&gt; head;
    let newLinkCurrent &lt;/span&gt;=&lt;span&gt; dummy;

    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (oldLinkCurrent) {
        let next &lt;/span&gt;=&lt;span&gt; oldLinkCurrent.next;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果当前节点和下一个节点的值相同 就要一直向前直到出现不同的值&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (next &amp;amp;&amp;amp; oldLinkCurrent.val ===&lt;span&gt; next.val) {
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (next &amp;amp;&amp;amp; oldLinkCurrent.val ===&lt;span&gt; next.val) {
                next &lt;/span&gt;=&lt;span&gt; next.next;
            }
            oldLinkCurrent &lt;/span&gt;=&lt;span&gt; next;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            newLinkCurrent &lt;/span&gt;= newLinkCurrent.next =&lt;span&gt; oldLinkCurrent;
            oldLinkCurrent &lt;/span&gt;=&lt;span&gt; oldLinkCurrent.next;
        }
    }
    newLinkCurrent.next &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 记得结尾置空~&lt;/span&gt;
&lt;span&gt;    logList(dummy.next);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; dummy.next;
};

deleteDuplicates(getListFromArray([&lt;/span&gt;1,2,3,3,4,4,5&lt;span&gt;]));
deleteDuplicates(getListFromArray([&lt;/span&gt;1,1,2,2,3,3,4,4,5&lt;span&gt;]));
deleteDuplicates(getListFromArray([&lt;/span&gt;1,1&lt;span&gt;]));
deleteDuplicates(getListFromArray([&lt;/span&gt;1,2,2,3,3]));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;本地运行结果&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
list: 1-&amp;gt;2-&amp;gt;5-&amp;gt;&lt;span&gt;end
list: &lt;/span&gt;5-&amp;gt;&lt;span&gt;end
list: end
list: &lt;/span&gt;1-&amp;gt;end
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;是不是很方便！&lt;/p&gt;
&lt;h2 class=&quot;heading&quot;&gt;矩阵（二维数组）&lt;/h2&gt;
&lt;p&gt;矩阵的题目也有很多，基本每一个需要用到二维数组的题，都涉及到初始化，求行数列数，遍历的代码。于是简单提取出来几个函数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 初始化一个二维数组
 * @param {number} r 行数
 * @param {number} c 列数
 * @param {*} init 初始值
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
const initMatrix &lt;/span&gt;= (r, c, init = 0) =&amp;gt; &lt;span&gt;new&lt;/span&gt; Array(r).fill().map(_ =&amp;gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Array(c).fill(init));
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 获取一个二维数组的行数和列数
 * @param {any[][]} matrix
 * @return [row, col]
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
const getMatrixRowAndCol &lt;/span&gt;= (matrix) =&amp;gt; matrix.length === 0 ? [0, 0] : [matrix.length, matrix[0&lt;span&gt;].length];
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 遍历一个二维数组
 * @param {any[][]} matrix 
 * @param {Function} func 
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
const matrixFor &lt;/span&gt;= (matrix, func) =&amp;gt;&lt;span&gt; {
    matrix.forEach((row, i) &lt;/span&gt;=&amp;gt;&lt;span&gt; {
        row.forEach((item, j) &lt;/span&gt;=&amp;gt;&lt;span&gt; {
            func(item, i, j, row, matrix);
        });
    })
}
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 获取矩阵第index个元素 从0开始
 * @param {any[][]} matrix 
 * @param {number} index 
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; getMatrix(matrix, index) {
    let col &lt;/span&gt;= matrix[0&lt;span&gt;].length;
    let i &lt;/span&gt;= ~~(index /&lt;span&gt; col);
    let j &lt;/span&gt;= index - i *&lt;span&gt; col;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; matrix[i][j];
}
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 设置矩阵第index个元素 从0开始
 * @param {any[][]} matrix 
 * @param {number} index 
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; setMatrix(matrix, index, value) {
    let col &lt;/span&gt;= matrix[0&lt;span&gt;].length;
    let i &lt;/span&gt;= ~~(index /&lt;span&gt; col);
    let j &lt;/span&gt;= index - i *&lt;span&gt; col;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; matrix[i][j] =&lt;span&gt; value;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;找一个简单的矩阵的题示范一下用法。@leetcode 566。题意就是将一个矩阵重新排列为r行c列。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
 * @lc app=leetcode id=566 lang=javascript
 *
 * [566] Reshape the Matrix
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * @param {number[][]} nums
 * @param {number} r
 * @param {number} c
 * @return {number[][]}
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; matrixReshape = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(nums, r, c) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将一个矩阵重新排列为r行c列&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 首先获取原来的行数和列数&lt;/span&gt;
    let [r1, c1] =&lt;span&gt; getMatrixRowAndCol(nums);
    log(r1, c1);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 不合法的话就返回原矩阵&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (!r1 || r1 * c1 !== r * c) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; nums;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化新矩阵&lt;/span&gt;
    let matrix =&lt;span&gt; initMatrix(r, c);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 遍历原矩阵生成新矩阵&lt;/span&gt;
    matrixFor(nums, (val, i, j) =&amp;gt;&lt;span&gt; {
        let index &lt;/span&gt;= i * c1 + j; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 计算是第几个元素&lt;/span&gt;
&lt;span&gt;        log(index);
        setMatrix(matrix, index, val); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在新矩阵的对应位置赋值&lt;/span&gt;
&lt;span&gt;    });
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; matrix;
};

let x &lt;/span&gt;= matrixReshape([[1],[2],[3],[4]], 2, 2&lt;span&gt;);
log(x)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 class=&quot;heading&quot;&gt;二叉树&lt;/h2&gt;
&lt;p&gt;当我做到二叉树相关的题目，我发现，我错怪链表了，呜呜呜这个更恶心。&lt;/p&gt;
&lt;p&gt;当然对于二叉树，只要你掌握先序遍历，后序遍历，中序遍历，层序遍历，递归以及非递归版，先序中序求二叉树，先序后序求二叉树，基本就能AC大部分二叉树的题目了（我瞎说的）。&lt;/p&gt;
&lt;p&gt;二叉树的题目 input 一般都是层序遍历的数组，所以写了层序遍历数组和二叉树的转换，方便调试。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt; TreeNode(val, left = &lt;span&gt;null&lt;/span&gt;, right = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.val =&lt;span&gt; val;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.left =&lt;span&gt; left;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.right =&lt;span&gt; right;
}
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 通过一个层次遍历的数组生成一棵二叉树
 * @param {any[]} array
 * @return {TreeNode}
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; getTreeFromLayerOrderArray(array) {
    let n &lt;/span&gt;=&lt;span&gt; array.length;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!n) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    let index &lt;/span&gt;= 0&lt;span&gt;;
    let root &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; TreeNode(array[index++&lt;span&gt;]);
    let queue &lt;/span&gt;=&lt;span&gt; [root];
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(index &amp;lt;&lt;span&gt; n) {
        let top &lt;/span&gt;=&lt;span&gt; queue.shift();
        let v &lt;/span&gt;= array[index++&lt;span&gt;];
        top.left &lt;/span&gt;= v == &lt;span&gt;null&lt;/span&gt; ? &lt;span&gt;null&lt;/span&gt; : &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TreeNode(v);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (index &amp;lt;&lt;span&gt; n) {
            let v &lt;/span&gt;= array[index++&lt;span&gt;];
            top.right &lt;/span&gt;= v == &lt;span&gt;null&lt;/span&gt; ? &lt;span&gt;null&lt;/span&gt; : &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TreeNode(v);
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (top.left) queue.push(top.left);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (top.right) queue.push(top.right);
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; root;
}
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 层序遍历一棵二叉树 生成一个数组
 * @param {TreeNode} root 
 * @return {any[]}
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; getLayerOrderArrayFromTree(root) {
    let res &lt;/span&gt;=&lt;span&gt; [];
    let que &lt;/span&gt;=&lt;span&gt; [root];
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (que.length) {
        let len &lt;/span&gt;=&lt;span&gt; que.length;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (let i = 0; i &amp;lt; len; i++&lt;span&gt;) {
            let cur &lt;/span&gt;=&lt;span&gt; que.shift();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (cur) {
                res.push(cur.val);
                que.push(cur.left, cur.right);
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                res.push(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
            }
        }
    }
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (res.length &amp;gt; 1 &amp;amp;&amp;amp; !res[res.length - 1]) res.pop(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 删掉结尾的 null&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; res;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一个例子，@leetcode 110，判断一棵二叉树是不是平衡二叉树。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * @param {TreeNode} root
 * @return {boolean}
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; isBalanced = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(root) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!root) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 认为空指针也是平衡树吧&lt;/span&gt;

    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取一个二叉树的深度&lt;/span&gt;
    const d = (root) =&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!root) &lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; _max(d(root.left), d(root.right)) + 1&lt;span&gt;;
    }

    let leftDepth &lt;/span&gt;=&lt;span&gt; d(root.left);
    let rightDepth &lt;/span&gt;=&lt;span&gt; d(root.right);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 深度差不超过 1 且子树都是平衡树&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (_min(leftDepth, rightDepth) + 1 &amp;gt;=&lt;span&gt; _max(leftDepth, rightDepth)
        &lt;/span&gt;&amp;amp;&amp;amp; isBalanced(root.left) &amp;amp;&amp;amp; isBalanced(root.right)) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
};

log(isBalanced(getTreeFromLayerOrderArray([&lt;/span&gt;3,9,20,&lt;span&gt;null&lt;/span&gt;,&lt;span&gt;null&lt;/span&gt;,15,7&lt;span&gt;])));
log(isBalanced(getTreeFromLayerOrderArray([&lt;/span&gt;1,2,2,3,3,&lt;span&gt;null&lt;/span&gt;,&lt;span&gt;null&lt;/span&gt;,4,4])));
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 class=&quot;heading&quot;&gt;二分查找&lt;/h2&gt;
&lt;p&gt;参考 C++ STL 中的 &lt;span class=&quot;cnblogs_code&quot;&gt;lower_bound&lt;/span&gt;  和 &lt;span class=&quot;cnblogs_code&quot;&gt;upper_bound&lt;/span&gt; 。这两个函数真的很好用的！&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 寻找&amp;gt;=target的最小下标
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; lower_bound(nums, target) {
    let first &lt;/span&gt;= 0&lt;span&gt;;
    let len &lt;/span&gt;=&lt;span&gt; nums.length;

    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (len &amp;gt; 0&lt;span&gt;) {
        let half &lt;/span&gt;= len &amp;gt;&amp;gt; 1&lt;span&gt;;
        let middle &lt;/span&gt;= first +&lt;span&gt; half;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (nums[middle] &amp;lt;&lt;span&gt; target) {
            first &lt;/span&gt;= middle + 1&lt;span&gt;;
            len &lt;/span&gt;= len - half - 1&lt;span&gt;;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            len &lt;/span&gt;=&lt;span&gt; half;
        }
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; first;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 寻找&amp;gt;target的最小下标
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; upper_bound(nums, target) {
    let first &lt;/span&gt;= 0&lt;span&gt;;
    let len &lt;/span&gt;=&lt;span&gt; nums.length;

    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (len &amp;gt; 0&lt;span&gt;) {
        let half &lt;/span&gt;= len &amp;gt;&amp;gt; 1&lt;span&gt;;
        let middle &lt;/span&gt;= first +&lt;span&gt; half;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (nums[middle] &amp;gt;&lt;span&gt; target) {
            len &lt;/span&gt;=&lt;span&gt; half;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            first &lt;/span&gt;= middle + 1&lt;span&gt;;
            len &lt;/span&gt;= len - half - 1&lt;span&gt;;
        }
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; first;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;照例，举个例子，@leetcode 34。题意是给一个排好序的数组和一个目标数字，求数组中等于目标数字的元素最小下标和最大下标。不存在就返回 -1。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
 * @lc app=leetcode id=34 lang=javascript
 *
 * [34] Find First and Last Position of Element in Sorted Array
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; searchRange = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(nums, target) {
  let lower &lt;/span&gt;=&lt;span&gt; lower_bound(nums, target);
  let upper &lt;/span&gt;=&lt;span&gt; upper_bound(nums, target);
  let size &lt;/span&gt;=&lt;span&gt; nums.length;
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 不存在返回 [-1, -1]&lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt; (lower &amp;gt;= size || nums[lower] !== target) &lt;span&gt;return&lt;/span&gt; [-1, -1&lt;span&gt;];
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; [lower, upper - 1&lt;span&gt;];
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 class=&quot;heading&quot;&gt;在 VS Code 中刷 LeetCode&lt;/h2&gt;
&lt;p&gt;前面说的那些模板，难道每一次打开新的一道题都要复制一遍么？当然不用啦。&lt;/p&gt;
&lt;p&gt;首先配置代码片段 选择 Code -&amp;gt; Preferences -&amp;gt; User Snippets ，然后选择 JavaScript&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/6/22/16b7e9c0a793f7d9?w=541&amp;amp;h=254&amp;amp;f=png&amp;amp;s=128089&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;然后把文件替换为下面的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;266&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&quot;leetcode template&quot;&lt;span&gt;: {
    &lt;/span&gt;&quot;prefix&quot;: &quot;@lc&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;body&quot;&lt;span&gt;: [
      &lt;/span&gt;&quot;const _max = Math.max.bind(Math);&quot;,&quot;const _min = Math.min.bind(Math);&quot;,&quot;const _pow = Math.pow.bind(Math);&quot;,&quot;const _floor = Math.floor.bind(Math);&quot;,&quot;const _round = Math.round.bind(Math);&quot;,&quot;const _ceil = Math.ceil.bind(Math);&quot;,&quot;const log = console.log.bind(console);&quot;,&quot;// const log = _ =&amp;gt; {}&quot;,&quot;/**************** 链表 ****************/&quot;,&quot;/**&quot;,&quot; * 链表节点&quot;,&quot; * @param {*} val&quot;,&quot; * @param {ListNode} next&quot;,&quot; */&quot;,&quot;function ListNode(val, next = null) {&quot;,&quot;    this.val = val;&quot;,&quot;    this.next = next;&quot;,&quot;}&quot;,&quot;/**&quot;,&quot; * 将一个数组转为链表&quot;,&quot; * @param {array} array&quot;,&quot; * @return {ListNode}&quot;,&quot; */&quot;,&quot;const getListFromArray = (array) =&amp;gt; {&quot;,&quot;    let dummy = new ListNode()&quot;,&quot;    let pre = dummy;&quot;,&quot;    array.forEach(x =&amp;gt; pre = pre.next = new ListNode(x));&quot;,&quot;    return dummy.next;&quot;,&quot;}&quot;,&quot;/**&quot;,&quot; * 将一个链表转为数组&quot;,&quot; * @param {ListNode} list&quot;,&quot; * @return {array}&quot;,&quot; */&quot;,&quot;const getArrayFromList = (list) =&amp;gt; {&quot;,&quot;    let a = [];&quot;,&quot;    while (list) {&quot;,&quot;        a.push(list.val);&quot;,&quot;        list = list.next;&quot;,&quot;    }&quot;,&quot;    return a;&quot;,&quot;}&quot;,&quot;/**&quot;,&quot; * 打印一个链表&quot;,&quot; * @param {ListNode} list &quot;,&quot; */&quot;,&quot;const logList = (list) =&amp;gt; {&quot;,&quot;    let str = 'list: ';&quot;,&quot;    while (list) {&quot;,&quot;        str += list.val + '-&amp;gt;';&quot;,&quot;        list = list.next;&quot;,&quot;    }&quot;,&quot;    str += 'end';&quot;,&quot;    log(str);&quot;,&quot;}&quot;,&quot;/**************** 矩阵（二维数组） ****************/&quot;,&quot;/**&quot;,&quot; * 初始化一个二维数组&quot;,&quot; * @param {number} r 行数&quot;,&quot; * @param {number} c 列数&quot;,&quot; * @param {*} init 初始值&quot;,&quot; */&quot;,&quot;const initMatrix = (r, c, init = 0) =&amp;gt; new Array(r).fill().map(_ =&amp;gt; new Array(c).fill(init));&quot;,&quot;/**&quot;,&quot; * 获取一个二维数组的行数和列数&quot;,&quot; * @param {any[][]} matrix&quot;,&quot; * @return [row, col]&quot;,&quot; */&quot;,&quot;const getMatrixRowAndCol = (matrix) =&amp;gt; matrix.length === 0 ? [0, 0] : [matrix.length, matrix[0].length];&quot;,&quot;/**&quot;,&quot; * 遍历一个二维数组&quot;,&quot; * @param {any[][]} matrix &quot;,&quot; * @param {Function} func &quot;,&quot; */&quot;,&quot;const matrixFor = (matrix, func) =&amp;gt; {&quot;,&quot;    matrix.forEach((row, i) =&amp;gt; {&quot;,&quot;        row.forEach((item, j) =&amp;gt; {&quot;,&quot;            func(item, i, j, row, matrix);&quot;,&quot;        });&quot;,&quot;    })&quot;,&quot;}&quot;,&quot;/**&quot;,&quot; * 获取矩阵第index个元素 从0开始&quot;,&quot; * @param {any[][]} matrix &quot;,&quot; * @param {number} index &quot;,&quot; */&quot;,&quot;function getMatrix(matrix, index) {&quot;,&quot;    let col = matrix[0].length;&quot;,&quot;    let i = ~~(index / col);&quot;,&quot;    let j = index - i * col;&quot;,&quot;    return matrix[i][j];&quot;,&quot;}&quot;,&quot;/**&quot;,&quot; * 设置矩阵第index个元素 从0开始&quot;,&quot; * @param {any[][]} matrix &quot;,&quot; * @param {number} index &quot;,&quot; */&quot;,&quot;function setMatrix(matrix, index, value) {&quot;,&quot;    let col = matrix[0].length;&quot;,&quot;    let i = ~~(index / col);&quot;,&quot;    let j = index - i * col;&quot;,&quot;    return matrix[i][j] = value;&quot;,&quot;}&quot;,&quot;/**************** 二叉树 ****************/&quot;,&quot;/**&quot;,&quot; * 二叉树节点&quot;,&quot; * @param {*} val&quot;,&quot; * @param {TreeNode} left&quot;,&quot; * @param {TreeNode} right&quot;,&quot; */&quot;,&quot;function TreeNode(val, left = null, right = null) {&quot;,&quot;    this.val = val;&quot;,&quot;    this.left = left;&quot;,&quot;    this.right = right;&quot;,&quot;}&quot;,&quot;/**&quot;,&quot; * 通过一个层次遍历的数组生成一棵二叉树&quot;,&quot; * @param {any[]} array&quot;,&quot; * @return {TreeNode}&quot;,&quot; */&quot;,&quot;function getTreeFromLayerOrderArray(array) {&quot;,&quot;    let n = array.length;&quot;,&quot;    if (!n) return null;&quot;,&quot;    let index = 0;&quot;,&quot;    let root = new TreeNode(array[index++]);&quot;,&quot;    let queue = [root];&quot;,&quot;    while(index &amp;lt; n) {&quot;,&quot;        let top = queue.shift();&quot;,&quot;        let v = array[index++];&quot;,&quot;        top.left = v == null ? null : new TreeNode(v);&quot;,&quot;        if (index &amp;lt; n) {&quot;,&quot;            let v = array[index++];&quot;,&quot;            top.right = v == null ? null : new TreeNode(v);&quot;,&quot;        }&quot;,&quot;        if (top.left) queue.push(top.left);&quot;,&quot;        if (top.right) queue.push(top.right);&quot;,&quot;    }&quot;,&quot;    return root;&quot;,&quot;}&quot;,&quot;/**&quot;,&quot; * 层序遍历一棵二叉树 生成一个数组&quot;,&quot; * @param {TreeNode} root &quot;,&quot; * @return {any[]}&quot;,&quot; */&quot;,&quot;function getLayerOrderArrayFromTree(root) {&quot;,&quot;    let res = [];&quot;,&quot;    let que = [root];&quot;,&quot;    while (que.length) {&quot;,&quot;        let len = que.length;&quot;,&quot;        for (let i = 0; i &amp;lt; len; i++) {&quot;,&quot;            let cur = que.shift();&quot;,&quot;            if (cur) {&quot;,&quot;                res.push(cur.val);&quot;,&quot;                que.push(cur.left, cur.right);&quot;,&quot;            } else {&quot;,&quot;                res.push(null);&quot;,&quot;            }&quot;,&quot;        }&quot;,&quot;    }&quot;,&quot;    while (res.length &amp;gt; 1 &amp;amp;&amp;amp; !res[res.length - 1]) res.pop(); // 删掉结尾的 null&quot;,&quot;    return res;&quot;,&quot;}&quot;,&quot;/**************** 二分查找 ****************/&quot;,&quot;/**&quot;,&quot; * 寻找&amp;gt;=target的最小下标&quot;,&quot; * @param {number[]} nums&quot;,&quot; * @param {number} target&quot;,&quot; * @return {number}&quot;,&quot; */&quot;,&quot;function lower_bound(nums, target) {&quot;,&quot;    let first = 0;&quot;,&quot;    let len = nums.length;&quot;,&quot;&quot;,&quot;    while (len &amp;gt; 0) {&quot;,&quot;        let half = len &amp;gt;&amp;gt; 1;&quot;,&quot;        let middle = first + half;&quot;,&quot;        if (nums[middle] &amp;lt; target) {&quot;,&quot;            first = middle + 1;&quot;,&quot;            len = len - half - 1;&quot;,&quot;        } else {&quot;,&quot;            len = half;&quot;,&quot;        }&quot;,&quot;    }&quot;,&quot;    return first;&quot;,&quot;}&quot;,&quot;&quot;,&quot;/**&quot;,&quot; * 寻找&amp;gt;target的最小下标&quot;,&quot; * @param {number[]} nums&quot;,&quot; * @param {number} target&quot;,&quot; * @return {number}&quot;,&quot; */&quot;,&quot;function upper_bound(nums, target) {&quot;,&quot;    let first = 0;&quot;,&quot;    let len = nums.length;&quot;,&quot;&quot;,&quot;    while (len &amp;gt; 0) {&quot;,&quot;        let half = len &amp;gt;&amp;gt; 1;&quot;,&quot;        let middle = first + half;&quot;,&quot;        if (nums[middle] &amp;gt; target) {&quot;,&quot;            len = half;&quot;,&quot;        } else {&quot;,&quot;            first = middle + 1;&quot;,&quot;            len = len - half - 1;&quot;,&quot;        }&quot;,&quot;    }&quot;,&quot;    return first;&quot;,&quot;}&quot;&lt;span&gt;,
      &lt;/span&gt;&quot;$1&quot;&lt;span&gt;
    ],
    &lt;/span&gt;&quot;description&quot;: &quot;LeetCode常用代码模板&quot;&lt;span&gt;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以后每一次写题之前，键入 &lt;code&gt;@lc&lt;/code&gt; 就会出现提示，轻松加入代码模板。 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/6/22/16b7ea5270447a30?w=508&amp;amp;h=111&amp;amp;f=png&amp;amp;s=15530&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;当然，必须推荐刷题神器，vscode 中的一款插件 &lt;a href=&quot;https://github.com/jdneo/vscode-leetcode/blob/master/docs/README_zh-CN.md&quot; target=&quot;_blank&quot;&gt;vscode-leetcode&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最后我要大声说，前端真的有机会用到算法的（不只面试）！来一起快乐刷题！&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 28 Jun 2019 00:48:00 +0000</pubDate>
<dc:creator>wenr</dc:creator>
<og:description>虽然很多人都觉得前端算法弱，但其实 JavaScript 也可以刷题啊！最近两个月断断续续刷完了 leetcode 前 200 的 middle + hard ，总结了一些刷题常用的模板代码。走过路过</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wenruo/p/11100537.html</dc:identifier>
</item>
<item>
<title>sentinel 核心概念 - luoxn28</title>
<link>http://www.cnblogs.com/luoxn28/p/11100726.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/luoxn28/p/11100726.html</guid>
<description>&lt;blockquote readability=&quot;16.410891089109&quot;&gt;
&lt;p&gt;编者注：前段时间笔者在团队内部分享了sentinel原理设计与实现，主要讲解了sentinel基础概念和工作原理，工作原理部分大家听了基本都了解了，但是对于sentinel的几个概念及其之间的关系还有挺多同学有点模糊的，趁着这几天比较空，针对sentinel的几个核心概念，做了一些总结，希望能帮助一些sentinel初学者理清这些概念之间的关系。&lt;/p&gt;

&lt;p&gt;PS：本文主要参考sentinel源码实现和部分官方文档，建议小伙伴阅读本文的同时也大致看下官方文档和源码，学习效果更好呦 : )  官方文档讲解的其实还是挺详细的，但是对于这些概念之间的关系可能对于初学者来说还有点不够。&lt;/p&gt;

&lt;p&gt;估计挺多小伙伴还不知道Sentinel是个什么东东，Sentinel是一个以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性的框架。github地址为：&lt;a href=&quot;https://github.com/alibaba/Sentinel&quot; target=&quot;_blank&quot;&gt;https://github.com/alibaba/Sentinel&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;h3&gt;资源和规则&lt;br/&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;资源&lt;/strong&gt;&lt;span&gt;是 Sentinel 的关键概念。它可以是 Java 应用程序中的任何内容，例如，由应用程序提供的服务，或由应用程序调用的其它应用提供的服务，甚至可以是一段代码。只要通过 Sentinel API 定义的代码，就是资源，能够被 Sentinel 保护起来。大部分情况下，可以使用方法签名，URL，甚至服务名称作为资源名来标示资源。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;围绕资源的实时状态设定的&lt;span&gt;&lt;strong&gt;规则&lt;/strong&gt;&lt;span&gt;，可以包括流量控制规则、熔断降级规则以及系统保护规则。所有规则可以动态实时调整。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;sentinel中调用SphU或者SphO的entry方法获取限流资源，不同的是前者获取限流资源失败时会抛BlockException异常，后者或捕获该异常并返回false，二者的实现都是基于CtSph类完成的。简单的sentinel示例：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; Entry entry = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;    entry =&lt;span&gt; SphU.entry(KEY);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;    System.out.println(&quot;entry ok...&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (BlockException e1) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取限流资源失败&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e2) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; biz exception&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;    &lt;span&gt;if&lt;/span&gt; (entry != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;       entry.exit();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; Entry entry = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (SphO.entry(KEY)) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;    System.out.println(&quot;entry ok&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取限流资源失败&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;SphU和SphO二者没有孰优孰略问题，底层实现是一样的，根据不同场景选举合适的一个即可。看了简单示例之后，一起来看下sentinel中的核心概念，便于理解后续内容。&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;核心概念&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;Resource&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;resource是sentinel中最重要的一个概念，sentinel通过资源来保护具体的业务代码或其他后方服务。sentinel把复杂的逻辑给屏蔽掉了，用户只需要为受保护的代码或服务定义一个资源，然后定义规则就可以了，剩下的通通交给sentinel来处理了。并且资源和规则是解耦的，规则甚至可以在运行时动态修改。定义完资源后，就可以通过在程序中埋点来保护你自己的服务了，埋点的方式有两种：&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; data-mark=&quot;-&quot; readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;try-catch 方式（&lt;span&gt;&lt;code&gt;通过 SphU.entry(...)&lt;/code&gt;&lt;span&gt;），当 catch 到BlockException时执行异常处理(或fallback)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;if-else 方式（&lt;span&gt;&lt;code&gt;通过 SphO.entry(...)&lt;/code&gt;&lt;span&gt;），当返回 false 时执行异常处理(或fallback)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;以上这两种方式都是通过硬编码的形式定义资源然后进行资源埋点的，对业务代码的侵入太大，从0.1.1版本开始，sentinel加入了注解的支持，可以通过注解来定义资源，具体的注解为：SentinelResource 。通过注解除了可以定义资源外，还可以指定 blockHandler 和 fallback 方法。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;在sentinel中具体表示资源的类是：ResourceWrapper ，他是一个抽象的包装类，包装了资源的 Name 和EntryType。他有两个实现类，分别是：StringResourceWrapper 和 MethodResourceWrapper。顾名思义，StringResourceWrapper 是通过对一串字符串进行包装，是一个通用的资源包装类，MethodResourceWrapper 是对方法调用的包装。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;Context&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;Context是对资源操作时的上下文环境，每个资源操作(&lt;span&gt;&lt;code&gt;针对Resource进行的entry/exit&lt;/code&gt;&lt;span&gt;)必须属于一个Context，如果程序中未指定Context，会创建name为&quot;sentinel_default_context&quot;的默认Context。一个Context生命周期内可能有多个资源操作，Context生命周期内的最后一个资源exit时会清理该Context，这也预示这整个Context生命周期的结束。Context主要属性如下：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Context {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; context名字，默认名字 &quot;sentinel_default_context&quot;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; String name;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; context入口节点，每个context必须有一个entranceNode&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; DefaultNode entranceNode;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; context当前entry，Context生命周期中可能有多个Entry，所有curEntry会有变化&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Entry curEntry;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; The origin of this context (usually indicate different invokers, e.g. service consumer name or origin IP).&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;    &lt;span&gt;private&lt;/span&gt; String origin = &quot;&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; async;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;注意：一个Context生命期内Context只能初始化一次，因为是存到ThreadLocal中，并且只有在非null时才会进行初始化。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;如果想在调用 SphU.entry() 或 SphO.entry() 前，自定义一个context，则通过ContextUtil.enter()方法来创建。context是保存在ThreadLocal中的，每次执行的时候会优先到ThreadLocal中获取，为null时会调用 &lt;span&gt;&lt;code&gt;MyContextUtil.myEnter(Constants.CONTEXT_DEFAULT_NAME, &quot;&quot;, resourceWrapper.getType())&lt;/code&gt;&lt;span&gt;创建一个context。当Entry执行exit方法时，如果entry的parent节点为null，表示是当前Context中最外层的Entry了，此时将ThreadLocal中的context清空。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;Entry&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;刚才在Context身影中也看到了Entry的出现，现在就谈谈Entry。每次执行 SphU.entry() 或 SphO.entry() 都会返回一个Entry，Entry表示一次资源操作，内部会保存当前invocation信息。在一个Context生命周期中多次资源操作，也就是对应多个Entry，这些Entry形成parent/child结构保存在Entry实例中，entry类CtEntry结构如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CtEntry &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Entry {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;    &lt;span&gt;protected&lt;/span&gt; Entry parent = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;    &lt;span&gt;protected&lt;/span&gt; Entry child = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;    &lt;span&gt;protected&lt;/span&gt; ProcessorSlot&amp;lt;Object&amp;gt;&lt;span&gt; chain;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;    &lt;span&gt;protected&lt;/span&gt;&lt;span&gt; Context context;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Entry &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; AutoCloseable {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; createTime;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Node curNode;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;    &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    * {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; Node} of the specific origin, Usually the origin is the Service Consumer.
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Node originNode;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;    &lt;span&gt;private&lt;/span&gt; Throwable error; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 是否出现异常&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;    &lt;span&gt;protected&lt;/span&gt; ResourceWrapper resourceWrapper; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 资源信息&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Entry实例代码中出现了Node，这个又是什么东东呢 :(，咱们接着往下看：&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;DefaultNode&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;Node（&lt;span&gt;&lt;em&gt;关于StatisticNode的讨论放到下一小节&lt;/em&gt;&lt;span&gt;）默认实现类DefaultNode，该类还有一个子类EntranceNode；context有一个entranceNode属性，Entry中有一个curNode属性。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; data-mark=&quot;-&quot; readability=&quot;2&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;EntranceNode&lt;/strong&gt;：该类的创建是在初始化Context时完成的（ContextUtil.trueEnter方法），注意该类是针对Context维度的，也就是一个context有且仅有一个EntranceNode。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;&lt;strong&gt;DefaultNode&lt;/strong&gt;：该类的创建是在NodeSelectorSlot.entry完成的，当不存在context.name对应的DefaultNode时会新建（new DefaultNode(resourceWrapper, null)，对应resouce）并保存到本地缓存（NodeSelectorSlot中private volatile Map&amp;lt;String, DefaultNode&amp;gt; map）；获取到context.name对应的DefaultNode后会将该DefaultNode设置到当前context的curEntry.curNode属性，也就是说，在NodeSelectorSlot中是一个context有且仅有一个DefaultNode。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;看到这里，你是不是有疑问？为什么一个context有且仅有一个DefaultNode，我们的resouece跑哪去了呢，其实，这里的一个context有且仅有一个DefaultNode是在NodeSelectorSlot范围内，NodeSelectorSlot是ProcessorSlotChain中的一环，获取ProcessorSlotChain是根据Resource维度来的。总结为一句话就是：&lt;span&gt;&lt;strong&gt;针对同一个Resource，多个context对应多个DefaultNode；针对不同Resource，(不管是否是同一个context)对应多个不同DefaultNode&lt;/strong&gt;&lt;span&gt;。这还没看明白 : (，好吧，我不bb了，上图吧：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;rich_pages img_loading&quot; src=&quot;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&quot; alt=&quot;&quot; data-ratio=&quot;0.6997476871320437&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jOD3PUUxTibMchXH6VFm3ib3rQ1EJX5iahQ1vqKPmNIsKbWejmZOl0s5cp8XLUHuKlN3EwGt80FauN0s4GPVzEp3Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1189&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772134/201906/772134-20190628084406534-263571734.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;DefaultNode结构如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DefaultNode &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; StatisticNode {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; ResourceWrapper id;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;    &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    * The list of all child nodes.
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    * 子节点集合
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; Set&amp;lt;Node&amp;gt; childList = &lt;span&gt;new&lt;/span&gt; HashSet&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;    &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    * Associated cluster node.
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; ClusterNode clusterNode;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一个Resouce只有一个clusterNode，多个defaultNode对应一个clusterNode，如果defaultNode.clusterNode为null，则在ClusterBuilderSlot.entry中会进行初始化。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;同一个Resource，对应同一个ProcessorSlotChain，这块处理逻辑在lookProcessChain方法中，如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; ProcessorSlot&amp;lt;Object&amp;gt;&lt;span&gt; lookProcessChain(ResourceWrapper resourceWrapper) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;    ProcessorSlotChain chain =&lt;span&gt; chainMap.get(resourceWrapper);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;    &lt;span&gt;if&lt;/span&gt; (chain == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;        &lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; (LOCK) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;            chain =&lt;span&gt; chainMap.get(resourceWrapper);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;            &lt;span&gt;if&lt;/span&gt; (chain == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Entry size limit.&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;                &lt;span&gt;if&lt;/span&gt; (chainMap.size() &amp;gt;=&lt;span&gt; Constants.MAX_SLOT_CHAIN_SIZE) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;              }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;                chain =&lt;span&gt; SlotChainProvider.newSlotChain();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                Map&amp;lt;ResourceWrapper, ProcessorSlotChain&amp;gt; newMap = newHashMap&amp;lt;ResourceWrapper, ProcessorSlotChain&amp;gt;&lt;span&gt;(
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                    chainMap.size() + 1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;               newMap.putAll(chainMap);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;               newMap.put(resourceWrapper, chain);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                chainMap =&lt;span&gt; newMap;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;          }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; chain;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;span&gt;StatisticNode&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;StatisticNode中保存了资源的实时统计数据（基于滑动时间窗口机制），通过这些统计数据，sentinel才能进行限流、降级等一系列操作。StatisticNode属性如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; StatisticNode &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Node {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;    &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    * 秒级的滑动时间窗口（时间窗口单位500ms）
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;transient&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; Metric rollingCounterInSecond =&lt;span&gt; newArrayMetric(SampleCountProperty.SAMPLE_COUNT,
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;       IntervalProperty.INTERVAL);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;    &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    * 分钟级的滑动时间窗口（时间窗口单位1s）
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;transient&lt;/span&gt; Metric rollingCounterInMinute = &lt;span&gt;new&lt;/span&gt; ArrayMetric(60, 60 * 1000,&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;    &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    * The counter for thread count. 
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;* 线程个数用户触发线程数流控
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;    &lt;span&gt;private&lt;/span&gt; LongAdder curThreadNum = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LongAdder();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ArrayMetric &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Metric {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; LeapArray&amp;lt;MetricBucket&amp;gt;&lt;span&gt; data;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MetricBucket {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 保存统计值&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; LongAdder[] counters;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 最小rt&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; minRt;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中MetricBucket.counters数组大小为MetricEvent枚举值的个数，每个枚举对应一个统计项，比如PASS表示通过个数，限流可根据通过的个数和设置的限流规则配置count大小比较，得出是否触发限流操作，所有枚举值如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; MetricEvent {
   PASS, &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Normal pass.&lt;/span&gt;
   BLOCK, &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Normal block.&lt;/span&gt;
&lt;span&gt;   EXCEPTION,
   SUCCESS,
   RT,
   OCCUPIED_PASS
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;span&gt;Slot&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;slot是另一个sentinel中非常重要的概念，sentinel的工作流程就是围绕着一个个插槽所组成的插槽链来展开的。需要注意的是每个插槽都有自己的职责，他们各司其职完好的配合，通过一定的编排顺序，来达到最终的限流降级的目的。默认的各个插槽之间的顺序是固定的，因为有的插槽需要依赖其他的插槽计算出来的结果才能进行工作。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;但是这并不意味着我们只能按照框架的定义来，sentinel 通过 SlotChainBuilder 作为 SPI 接口，使得 Slot Chain 具备了扩展的能力。我们可以通过实现 SlotsChainBuilder 接口加入自定义的 slot 并自定义编排各个 slot 之间的顺序，从而可以给 sentinel 添加自定义的功能。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;那SlotChain是在哪创建的呢？是在 CtSph.lookProcessChain() 方法中创建的，并且该方法会根据当前请求的资源先去一个静态的HashMap中获取，如果获取不到才会创建，创建后会保存到HashMap中。这就意味着，同一个资源会全局共享一个SlotChain。默认生成ProcessorSlotChain为：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; DefaultSlotChainBuilder&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ProcessorSlotChain build() {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;    ProcessorSlotChain chain = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultProcessorSlotChain();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;    chain.addLast(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; NodeSelectorSlot());
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;    chain.addLast(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ClusterBuilderSlot());
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;    chain.addLast(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; LogSlot());
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;    chain.addLast(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; StatisticSlot());
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;    chain.addLast(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SystemSlot());
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;    chain.addLast(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; AuthoritySlot());
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;    chain.addLast(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; FlowSlot());
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;    chain.addLast(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; DegradeSlot());
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;    &lt;span&gt;return&lt;/span&gt; chain;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;到这里本文结束了，谢谢小伙伴们的阅读~ 在理解了这些核心概念之后，相信聪明的你回过头再看sentinel源码就不会觉得有很大难度了 : )&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;strong&gt; 往期精选 &lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;br/&gt;觉得文章不错，对你有所启发和帮助，希望能转发给更多的小伙伴。如果有问题，请关注下面公众号，发送问题给我，多谢。&lt;br/&gt;欢迎小伙伴&lt;strong&gt;关注【TopCoder】&lt;/strong&gt;阅读更多精彩好文。</description>
<pubDate>Fri, 28 Jun 2019 00:47:00 +0000</pubDate>
<dc:creator>luoxn28</dc:creator>
<og:description>编者注：前段时间笔者在团队内部分享了sentinel原理设计与实现，主要讲解了sentinel基础概念和工作原理，工作原理部分大家听了基本都了解了，但是对于sentinel的几个概念及其之间的关系还有</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/luoxn28/p/11100726.html</dc:identifier>
</item>
<item>
<title>使用 Cake 推送 NuGet 包到 AzureDevops 的 Artifacts 上 - Wigor</title>
<link>http://www.cnblogs.com/AMortal/p/11100669.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/AMortal/p/11100669.html</guid>
<description>&lt;p&gt;大家好，我最近在想如何提交代码的时候自动的打包 NuGet 然后发布到 &lt;code&gt;AzureDevOps&lt;/code&gt; 中的 &lt;code&gt;Artifacts&lt;/code&gt;，在这个过程中踩了很多坑，也走了很多弯路，所以这次篇文章就是将我探索的结果和我遇到的一些问题整理分享给大家。&lt;/p&gt;
&lt;p&gt;我的上一篇关于 &lt;code&gt;CI/CD&lt;/code&gt; 的文章&lt;a href=&quot;https://www.cnblogs.com/AMortal/p/10845783.html&quot;&gt;《使用 Gitlab CI/CD 实现自动化发布站点到 IIS》&lt;/a&gt; 中是使用脚本的形式实现的，后来有&lt;a href=&quot;https://www.cnblogs.com/linianhui/&quot;&gt;园友&lt;/a&gt;在下面评论说可以使用 &lt;a href=&quot;https://cakebuild.net/&quot;&gt;Cake（C# Make）&lt;/a&gt; 这个工具来实现其中的功能，所以本次就不用了脚本了。有时间会使用 Cake 对它进行改造。&lt;/p&gt;
&lt;p&gt;整体思路：&lt;/p&gt;
&lt;ol readability=&quot;2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;首先介绍下 &lt;code&gt;Cake&lt;/code&gt;、&lt;code&gt;AzureDevops Pipelines/Artifacts&lt;/code&gt; 怎么使用&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;接着配置 AzureDevops Pipelines&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;创建 AzureDevops Artifacts （NuGet 服务端）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;AzureDevops 配置 PAT (Personal Access Tokens) 和 Pipelines 所需的 Variables（变量）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Cake 增加打包、推送 NuGet 包代码。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最后查看运行结果&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;使用到的工具及版本：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;dotnet core 2.2&lt;/p&gt;
&lt;p&gt;cake 0.33.0&lt;/p&gt;
&lt;p&gt;PowerShell、NuGet、CredentialProvider&lt;/p&gt;
&lt;p&gt;AzureDevops Pipelines 和 AzureDevops Artifacts&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul readability=&quot;0.98739495798319&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;Cake 的全称是 &lt;code&gt;C# Make&lt;/code&gt;，它是一个跨平台的自动化构建系统，基于 C# DSL，所以可以用我们熟悉的 C# 语言来替换掉我们之前使用脚本的构建方式。使用它我们能非常方便的编译代码，复制文件和文件夹，当然还可以运行单元测试以以确保我们的代码没有问题，我们本次的 NuGet 发布到 Artifacts 它占很重要的地位。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;AzureDevops 的前身是 VSTS，它提供了 Repos、Pipelines、Boards、Test Plans、Artifacts：
&lt;ul&gt;&lt;li&gt;Repos 提供 Git 存储库，用于代码的源代码控制，你可以直接引入你在 GitHub 上的仓储。&lt;/li&gt;
&lt;li&gt;Pipelines 提供构建和发布服务，以支持应用程序的持续集成和交付（CI/CD）&lt;/li&gt;
&lt;li&gt;Boards 提供了一套 Agile 工具，支持使用看板和 Scrum 方法规划和跟踪工作，代码缺陷管理等等，类似的工具有腾讯的 &lt;a href=&quot;https://www.tapd.cn/&quot;&gt;TAPD&lt;/a&gt;、阿里的 &lt;a href=&quot;https://www.aliyun.com/product/yunxiao&quot;&gt;云效&lt;/a&gt;、华为云的 &lt;a href=&quot;https://www.huaweicloud.com/devcloud/&quot;&gt;DevCloud&lt;/a&gt; 等等。&lt;/li&gt;
&lt;li&gt;Test Plans 提供了多种测试应用程序的工具，包括手动/探索性测试和持续测试&lt;/li&gt;
&lt;li&gt;Artifacts 允许团队从公共和私人来源共享 Maven，npm 和 NuGet 包。&lt;br/&gt;协作工具，包括可自定义的团队仪表板和可配置的小部件，以共享信息，进度和趋势; 用于共享信息的内置 wiki; 可配置的通知等。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;CredentialProvider 是凭据提供程序，当我们进行 NuGet Push 时需要进行身份验证，只需要将它放在 NuGet 程序的下即可。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本次案例我已经发布到 GitHub 上了：&lt;a href=&quot;https://github.com/WuMortal/CakePushNuGet.Example&quot; class=&quot;uri&quot;&gt;https://github.com/WuMortal/CakePushNuGet.Example&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安装：这里我使用 dotnet core 进行演示，cake 还支持 .NET Framework、Mono。首先我们需要安装 cake，借助 dotnet tool 这个命令。&lt;/p&gt;
&lt;pre class=&quot;sh&quot;&gt;
&lt;code&gt;dotnet tool install --global cake.tool --version 0.33.0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装成功会出现如下提示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WuMortal/CakePushNuGet.Example/master/doc/images/2.jpg&quot; alt=&quot;cake 安装&quot;/&gt;&lt;/p&gt;
&lt;p&gt;cake 的使用方式非常简单，而且还是 C# 语法相信应该是很容易就能理解的。&lt;/p&gt;
&lt;p&gt;这里首先定义了一个 target 变量，它里面保存的就是我们将要执行的 Task（任务）的名称。接着可以看到在在代码块中定义了许多的 Task，这里就是具体需要执行的 “任务”，第一个任务是还原项目的依赖，其实核心代码就一行 &lt;code&gt;DotNetCoreRestore(solution);&lt;/code&gt;，第二个任务是生成项目，需要说明的是第三个任务其实是将前面两个任务整合到一起。你也可以在中第二个任务 &lt;code&gt;.IsDependentOn (&quot;Restore&quot;)&lt;/code&gt; 调用第一个任务，当然 &lt;code&gt;var target = Argument (&quot;target&quot;, &quot;Demo&quot;);&lt;/code&gt; 就需要改为 &lt;code&gt;var target = Argument (&quot;target&quot;, &quot;Build&quot;);&lt;/code&gt; 了，这个看个人喜好了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WuMortal/CakePushNuGet.Example/master/doc/images/3.jpg&quot; alt=&quot;cake 安装&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var rootPath = &quot;../&quot;;   //根目录
var srcPath = rootPath + &quot;src/&quot;;    
var solution = srcPath + &quot;Wigor.CakePushNuGet.Example.sln&quot;;   //解决方案文件
//需要执行的目标任务
var target = Argument (&quot;target&quot;, &quot;Demo&quot;);

Task (&quot;Restore&quot;)
  .Description (&quot;还原项目依赖&quot;)
  .Does (() =&amp;gt; {
    //Restore
    Information (&quot;开始执行还原项目依赖任务&quot;);
    DotNetCoreRestore (solution);
  });

Task (&quot;Build&quot;)
  .Description (&quot;编译项目&quot;)
  .Does (() =&amp;gt; {
    Information (&quot;开始执行编译生成项目任务&quot;);
    //Build
    DotNetCoreBuild (solution, new DotNetCoreBuildSettings {
        NoRestore = true,   //不执行还原，上一步已经还原过了
        Configuration = &quot;Release&quot;
    });
  });

// 执行的任务
Task (&quot;Demo&quot;)
  .IsDependentOn (&quot;Restore&quot;)    //1. 执行上面的 Restore 任务
  .IsDependentOn (&quot;Build&quot;)      //2. 需要执行 上面的 Build 任务
  .Does (() =&amp;gt; {
    Information (&quot;所有任务完成&quot;);
  });

//运行目标任务 Demo
RunTarget (target);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;cake 编写好后我们就可以尝试运行它，这里我的 cake 路径是 build/build.cake 大家可以根据具体情况更改 ，命令如下：&lt;/p&gt;
&lt;pre class=&quot;sh&quot;&gt;
&lt;code&gt;dotnet cake build/build.cake -verbosity=diagnostic&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WuMortal/CakePushNuGet.Example/master/doc/images/4.jpg&quot; alt=&quot;cake 运行&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到这里的 cake 已经运行成功了，它会将我们每个任务运行的结果和信息显示在控制台上。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WuMortal/CakePushNuGet.Example/master/doc/images/5.jpg&quot; alt=&quot;cake 运行&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到这里相信大家对 cake 是干什么了有点了解吧，有关它跟多的使用方法可以访问官网：&lt;a href=&quot;https://cakebuild.net/&quot; class=&quot;uri&quot;&gt;https://cakebuild.net/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;首先你需要一个 Microsoft 账号或者 GitHub 账号，登录地址为：&lt;a href=&quot;https://dev.azure.com&quot; class=&quot;uri&quot;&gt;https://dev.azure.com&lt;/a&gt;，登录之后你需要创建一个项目，这里我已经创建好一个项目了，首先我们点击 Pipelines 选择 Builds，之后会出现如下界面，点击 New Pipeline。然后跟着我下面图片的步骤一步一步来就行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WuMortal/CakePushNuGet.Example/master/doc/images/6.jpg&quot; alt=&quot;AzureDevops Pipelines 使用&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果你的仓储就在 AzureDevops上那么直接选 Azure Repos Git 就行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WuMortal/CakePushNuGet.Example/master/doc/images/7.jpg&quot; alt=&quot;AzureDevops Pipelines 使用&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里你的账号是 GitHub 授权登录的话会先跳转到授权界面可能会跳转多次，同意即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WuMortal/CakePushNuGet.Example/master/doc/images/8.jpg&quot; alt=&quot;AzureDevops Pipelines 使用&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WuMortal/CakePushNuGet.Example/master/doc/images/9.jpg&quot; alt=&quot;AzureDevops Pipelines 使用&quot;/&gt;&lt;/p&gt;
&lt;p&gt;删除我选中的代码，因为我不打算用 AzureDevops Pipelines 的脚本来执行本次操作，它做的只是提供我们 cake 运行的环境。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WuMortal/CakePushNuGet.Example/master/doc/images/10.jpg&quot; alt=&quot;AzureDevops Pipelines 使用&quot;/&gt;&lt;/p&gt;
&lt;p&gt;更换为如下脚本，&lt;code&gt;PowerShell.exe -file ./cake.ps1&lt;/code&gt; 是指使用 PowerShell 运行我们的 cake.ps1 文件，关于 cake.ps1 文件后面会介绍，这里我们先这样写，接着点击 &lt;code&gt;Save and run&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WuMortal/CakePushNuGet.Example/master/doc/images/11.jpg&quot; alt=&quot;AzureDevops Pipelines 使用&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;yml&quot;&gt;
&lt;code&gt;trigger:
- master

pool:
  vmImage: 'windows-latest'

steps:
- script: PowerShell.exe -file ./cake.ps1
  displayName: 'Push NuGet Package'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到问们管道的运行出现了错误，那是因为我们上面在运行了 cake.ps1 这个脚本，但是我们现在还没有创建这个脚本。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WuMortal/CakePushNuGet.Example/master/doc/images/12.jpg&quot; alt=&quot;AzureDevops Pipelines 使用&quot;/&gt;&lt;/p&gt;
&lt;p&gt;回到我们的项目中，将 AzureDevops Pipelines 创建的 &lt;code&gt;azure-pipelines.yml&lt;/code&gt; 文件 pull 到我们本地。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WuMortal/CakePushNuGet.Example/master/doc/images/13.jpg&quot; alt=&quot;AzureDevops Pipelines 使用&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接着我们编写我们下面缺少的 cake.ps1 文件，它做的事情就是将我们之前手动在 cmd 中运行的命令放入了一个 PowerShell 脚本文件中，Linux 平台的话就编写一个 shell 脚本。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WuMortal/CakePushNuGet.Example/master/doc/images/13_1.jpg&quot; alt=&quot;AzureDevops Pipelines 使用&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;sh&quot;&gt;
&lt;code&gt;# Install cake.tool
dotnet tool install --global cake.tool --version 0.33.0

# 输出将要执行的命命令
Write-Host &quot;dotnet cake build\build.cake -verbosity=diagnostic&quot; -ForegroundColor GREEN

dotnet cake build\build.cake -verbosity=diagnostic&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;尝试项目根目录下运行这个脚本，在 cmd 中执行 &lt;code&gt;powershell .\cake.ps1&lt;/code&gt;，下面报了一个错。&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WuMortal/CakePushNuGet.Example/master/doc/images/14.jpg&quot; alt=&quot;AzureDevops Pipelines 使用&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们只需要以管理员身份运行 PowerShell 然后执行 &lt;code&gt;set-ExecutionPolicy RemoteSigned&lt;/code&gt; 即可&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WuMortal/CakePushNuGet.Example/master/doc/images/15.jpg&quot; alt=&quot;AzureDevops Pipelines 使用&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WuMortal/CakePushNuGet.Example/master/doc/images/16.jpg&quot; alt=&quot;AzureDevops Pipelines 使用&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后再次运行 &lt;code&gt;powershell .\cake.ps1&lt;/code&gt; 或者命令，可以看到正确的输出了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WuMortal/CakePushNuGet.Example/master/doc/images/18.jpg&quot; alt=&quot;AzureDevops Pipelines 使用&quot;/&gt;&lt;/p&gt;
&lt;p&gt;OK，这次我们推送（git push）下代码，在到 AzureDevops Pipelines 看看我们执行结果。&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WuMortal/CakePushNuGet.Example/master/doc/images/19.jpg&quot; alt=&quot;AzureDevops Pipelines 使用&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点进去可以看到整个执行的过程，如果报错了也可以从这里看到出错的信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WuMortal/CakePushNuGet.Example/master/doc/images/20.png&quot; alt=&quot;AzureDevops Pipelines 使用&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果是 powershell 报错 AzureDevops Pipelines 是不会显示执行失败的，如果没得到你想要的结果你就需要点开认真的分析你的脚本了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;前面已经讲过了如果使用 cake 和 在 AzureDevops Pipelines 下执行 cake。下面我们需要创建一个 NuGet Repository，这里我使用 AzureDevops 提供的 Artifacts。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WuMortal/CakePushNuGet.Example/master/doc/images/21.png&quot; alt=&quot;AzureDevops Artifacts 使用&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WuMortal/CakePushNuGet.Example/master/doc/images/22.jpg&quot; alt=&quot;AzureDevops Artifacts 使用&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WuMortal/CakePushNuGet.Example/master/doc/images/23.png&quot; alt=&quot;AzureDevops Artifacts 使用&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里面会用的就是 &lt;code&gt;package source URL&lt;/code&gt; 和下面命令中的 -ApiKey 中的 &lt;code&gt;AzureDevOps&lt;/code&gt;，还有这里我们需要将 &lt;code&gt;NuGet + Credentials Provider&lt;/code&gt; 下载到我们的本地，如果你的运行环境是 Linux 或其他可以在 &lt;code&gt;microsoft/artifacts-credprovider&lt;/code&gt; 的 GitHub 上获取对应平台的这两个包， &lt;a href=&quot;https://github.com/Microsoft/artifacts-credprovider&quot;&gt;点击查看 GitHub 地址&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;上面说过了我们推送 NuGet 包到 Artifacts 时候是需要为两个参数提供指的的 -UserName 和 -Password，这里的 UserName 我们可以随意填，但是 Password 填的的是我们创建的 PAT。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WuMortal/CakePushNuGet.Example/master/doc/images/24.png&quot; alt=&quot;APersonal Access Tokens 使用&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WuMortal/CakePushNuGet.Example/master/doc/images/25.jpg&quot; alt=&quot;Personal Access Tokens 使用&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是选择我们 PAT 所拥有的权限，需要点击 &lt;code&gt;Show all scopes&lt;/code&gt; 找到 &lt;code&gt;Packaging&lt;/code&gt; 勾选 &lt;code&gt;Red,wirte,&amp;amp; manage&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WuMortal/CakePushNuGet.Example/master/doc/images/26.png&quot; alt=&quot;Personal Access Tokens 使用&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以看到我们的 PAT ，需要注意的是这个 token 只会出现一次，你需要将它保存好，如果忘记了，那么可以点击 &lt;code&gt;Regenerate&lt;/code&gt; 重新获取 token。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WuMortal/CakePushNuGet.Example/master/doc/images/27.png&quot; alt=&quot;Personal Access Tokens 使用&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在 &lt;a href=&quot;https://www.cnblogs.com/AMortal/p/10845783.html&quot;&gt;上一篇文章&lt;/a&gt; 中我说过了为什么需要变量，这里就不重复了，有兴趣的可以看看。下面开始添加我们需要的变量。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WuMortal/CakePushNuGet.Example/master/doc/images/28.png&quot; alt=&quot;添加变量 使用&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WuMortal/CakePushNuGet.Example/master/doc/images/29.jpg&quot; alt=&quot;A添加变量 使用&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们需要添加的变量有四个，分别是 &lt;code&gt;NUGET_REPOSITORY_API_URL&lt;/code&gt;、&lt;code&gt;NUGET_REPOSITORY_API_KEY&lt;/code&gt;、&lt;code&gt;USERNAME&lt;/code&gt;、&lt;code&gt;PASSWORD&lt;/code&gt;。&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;NUGET_REPOSITORY_API_URL：就是我们在创建 AzureDevops Artifacts 后出现的 &lt;code&gt;package source URL&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;NUGET_REPOSITORY_API_KEY：就是那个 -ApiKey 参数的值 &lt;code&gt;AzureDevOps&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;USERNAME：这个上面说过了可以随便填。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;PASSWORD：这个就是之前创建的 PAT。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;点击保存（Save &amp;amp; queue）或者 Ctrl + s 保存。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WuMortal/CakePushNuGet.Example/master/doc/images/30.jpg&quot; alt=&quot;添加变量 使用&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这里为已经封装过了的工具类包含了打包和推送方法,地址：&lt;a href=&quot;https://github.com/WuMortal/CakePushNuGet.Example/blob/master/build/nuget.tool.cake&quot;&gt;NuGet.Tool.cake&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;using System;
using System.Collections.Generic;
using System.Linq;
using Cake.Common.Tools.DotNetCore;
using Cake.Common.Tools.DotNetCore.Pack;
using Cake.Common.Tools.NuGet;
using Cake.Common.Tools.NuGet.List;
using Cake.Core;
using NuGet.Packaging;

public class NuGetTool {
    public ICakeContext CakeContext { get; }

    public string RepositoryApiUrl { get; }

    public string RepositoryApiKey { get; }

    public string UserName { get; set; }

    public string Password { get; set; }

    private NuGetListSettings ListSettings =&amp;gt; new NuGetListSettings {
        AllVersions = true,
        Source = new string[] { this.RepositoryApiUrl }
    };

    private DotNetCorePackSettings BuildPackSettings (string packOutputDirectory) =&amp;gt; new DotNetCorePackSettings {
        Configuration = &quot;Release&quot;,
        OutputDirectory = packOutputDirectory,
        IncludeSource = true,
        IncludeSymbols = true,
        NoBuild = false
    };

    private NuGetTool (ICakeContext cakeContext) {
        CakeContext = cakeContext;
        RepositoryApiUrl = cakeContext.Environment.GetEnvironmentVariable (&quot;NUGET_REPOSITORY_API_URL&quot;);
        RepositoryApiKey = cakeContext.Environment.GetEnvironmentVariable (&quot;NUGET_REPOSITORY_API_KEY&quot;);
        UserName = cakeContext.Environment.GetEnvironmentVariable (&quot;USERNAME&quot;);
        Password = cakeContext.Environment.GetEnvironmentVariable (&quot;PASSWORD&quot;);
        CakeContext.Information ($&quot;获取所需参数成功：{RepositoryApiUrl}&quot;);
    }

    public static NuGetTool FromCakeContext (ICakeContext cakeContext) {
        return new NuGetTool (cakeContext);
    }

    public void Pack (List&amp;lt;string&amp;gt; projectFilePaths, string packOutputDirectory) {
        projectFilePaths.ForEach (_ =&amp;gt; CakeContext.DotNetCorePack (_, BuildPackSettings (packOutputDirectory)));
    }

    public void Push (List&amp;lt;string&amp;gt; packageFilePaths) {

        foreach (var packageFilePath in packageFilePaths) {
            CakeContext.NuGetAddSource (
                &quot;wigor&quot;,
                this.RepositoryApiUrl,
                new NuGetSourcesSettings {
                    UserName = this.UserName,
                    Password = this.Password
                });

            CakeContext.NuGetPush (packageFilePath, new NuGetPushSettings {
                Source = &quot;wigor&quot;,
                ApiKey = this.RepositoryApiKey
            });

        }

    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在项目的 build/ 下创建 &lt;code&gt;nuget.tool.cake&lt;/code&gt; 文件（build/nuget.tool.cake） 拷贝上面的代码。&lt;/p&gt;
&lt;blockquote readability=&quot;5.3571428571429&quot;&gt;
&lt;p&gt;这里参考了最开始提到的园友的项目，非常感谢它的贡献，GitHub 地址如下：&lt;a href=&quot;https://github.com/linianhui/cake.example&quot;&gt;cake.example&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在创建 &lt;code&gt;AzureDevops Artifacts&lt;/code&gt; 的时候那不是提供了 &lt;code&gt;NuGet + Credentials Provider&lt;/code&gt; 的下载地址嘛，现在把它解压到我们项目的 &lt;code&gt;build\tool\&lt;/code&gt; 下。再次说明这里我是 Windows 环境，如果你的运行环境是 Linux 或其他可以在 &lt;code&gt;microsoft/artifacts-credprovider&lt;/code&gt; 的 GitHub 上获取对应平台的这两个包， &lt;a href=&quot;https://github.com/Microsoft/artifacts-credprovider&quot;&gt;点击查看 GitHub 地址&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WuMortal/CakePushNuGet.Example/master/doc/images/31.jpg&quot; alt=&quot;NuGet.exe、Credentials Provider&quot;/&gt;&lt;/p&gt;

&lt;p&gt;修改 cake.ps1，只是增加了 NuGet.exe 的环境变量，因为不加到时候 cake 会找不到 NuGet.exe，或许还有其他办法这里就先这么干，如果各位还有更方便的方法可以在下面留言，感谢！&lt;/p&gt;
&lt;pre class=&quot;powershell&quot;&gt;
&lt;code&gt;# 执行的文件
[string]$SCRIPT = 'build/build.cake'

[string]$CAKE_VERSION = '0.33.0'

# 配置 NuGet 环境变量
$NUGET_EXE = &quot;build/tool/NuGet.exe&quot;
$NUGET_DIRECTORY = Get-ChildItem -Path $NUGET_EXE
$NUGET_DIRECTORY_NAME=$NUGET_DIRECTORY.DirectoryName
$ENV:Path += &quot;;$NUGET_DIRECTORY_NAME&quot;

# Install cake.tool
dotnet tool install --global cake.tool --version $CAKE_VERSION

# 参数：显需要执行cake 执行信息
[string]$CAKE_ARGS = &quot;-verbosity=diagnostic&quot;

# 输出将要执行的命命令
Write-Host &quot;dotnet cake $SCRIPT $CAKE_ARGS $ARGS&quot; -ForegroundColor GREEN

dotnet cake $SCRIPT $CAKE_ARGS $ARGS&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改 build.cake 文件，看着是多了很多东西其实就多了两个 Task (任务) 分别是： &lt;code&gt;pack（打包）&lt;/code&gt; 和 &lt;code&gt;push（推送包）&lt;/code&gt;，这里需要大家需要修改的就是 &lt;code&gt;solution&lt;/code&gt; 和 &lt;code&gt;project&lt;/code&gt; 两个变量，将其修改为自己的解决方案名称和需要打包的项目名称。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;#reference &quot;NuGet.Packaging&quot;

#load nuget.tool.cake

var target = Argument (&quot;target&quot;, &quot;PushPack&quot;);

var rootPath = &quot;../&quot;;
var srcPath = rootPath + &quot;src/&quot;;
var solution = srcPath + &quot;Wigor.CakePushNuGet.Example.sln&quot;;
var project = GetFiles (srcPath + &quot;Wigor.CakePushNuGet.HelloWorld/*.csproj&quot;);
var nugetPakcageDirectory = $&quot;{srcPath}nugetPackage/&quot;;

var nugetTool = NuGetTool.FromCakeContext (Context);

Task (&quot;Restore&quot;)
  .Description (&quot;还原项目依赖&quot;)
  .Does (() =&amp;gt; {
    //Restore
    Information (&quot;开始执行还原项目依赖任务&quot;);
    DotNetCoreRestore (solution);
  });

Task (&quot;Build&quot;)
  .Description (&quot;编译项目&quot;)
  .Does (() =&amp;gt; {
    Information (&quot;开始执行编译生成项目任务&quot;);
    //Build
    DotNetCoreBuild (solution, new DotNetCoreBuildSettings {
        NoRestore = true,
        Configuration = &quot;Release&quot;
    });
  });

Task (&quot;UnitTest&quot;)
  .Description (&quot;单元测试&quot;)
  .Does (() =&amp;gt; {
    Information (&quot;开始执行单元测试任务&quot;);
    
    DotNetCoreTest(solution);
  });

Task (&quot;Pack&quot;)
  .Description (&quot;Nuget 打包&quot;)
  .Does (() =&amp;gt; {
    Information (&quot;开始执行打包任务&quot;);

    // 确保目录存在
    EnsureDirectoryExists (nugetPakcageDirectory);

    var packageFilePaths = project.Select (_ =&amp;gt; _.FullPath).ToList ();

    nugetTool.Pack (packageFilePaths, nugetPakcageDirectory);
  });

Task (&quot;Push&quot;)
  .Description (&quot;Nuget 发布&quot;)
  .Does (() =&amp;gt; {
    Information (&quot;开始执行 Nuget 包发布任务&quot;);
    var packageFilePaths = GetFiles ($&quot;{nugetPakcageDirectory}*.symbols.nupkg&quot;).Select (_ =&amp;gt; _.FullPath).ToList ();

    nugetTool.Push(packageFilePaths);
  });

Task (&quot;PushPack&quot;)
  .Description (&quot;发布 Nuget 包&quot;)
  .IsDependentOn (&quot;Restore&quot;)
  .IsDependentOn (&quot;Build&quot;)
  .IsDependentOn (&quot;Pack&quot;)
  .IsDependentOn (&quot;Push&quot;)
  .Does (() =&amp;gt; {
    Information (&quot;所有任务完成&quot;);
  });

RunTarget (target);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后我们推送修改后的代码，查看执行结果看看 NuGet 包是否发布到 &lt;code&gt;AzureDevops Artifacts&lt;/code&gt; 上。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WuMortal/CakePushNuGet.Example/master/doc/images/32.png&quot; alt=&quot;结果&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此已经实现了 使用 Cake 推送 NuGet 包到 AzureDevops 的 Artifacts 上，你如果不熟悉 &lt;code&gt;AzureDevops Pipelines&lt;/code&gt; 你也可以用其他的 CI/CD 工具来执行。&lt;/p&gt;

&lt;p&gt;在整个尝试过程中肯定会出现一些问题，不要着急认真分析，看看 &lt;code&gt;AzureDevops Pipelines&lt;/code&gt; 上给出的提示，也可以现在本机跑一下看看是否正常。出现问题第一步查看错误信息，看看有没有错误信息（基本都有），然后根据错误信息去分析是我们的那个地方出错了，顺序是 cake.ps1 --&amp;gt; build.cake --&amp;gt; nuget.tool.cake，然后是所需的 PAT 的权限是否勾选，&lt;code&gt;AzureDevops Pipelines&lt;/code&gt; 变量是否配置并且是 URL、Key 什么的都是正确，再然后就是 百度、Google。最后你可以在评论区留言（分享你碰到的问题以及解决方法）。&lt;/p&gt;

&lt;p&gt;在这里感谢各位的贡献！&lt;/p&gt;
&lt;blockquote readability=&quot;0.30357142857143&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/linianhui/p/cake-overview.html&quot;&gt;《[Cake] 0. C#Make自动化构建-简介》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/linianhui/p/cake-with-dotnet-tool.html&quot;&gt;《2. dotnet 全局工具 cake》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://neilq.github.io/2018/04/18/dotnet-ci-base-on-cake-build/&quot;&gt;《基于cake-build的dotnet自动化发布》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://daveaglick.com/posts/pushing-packages-from-azure-pipelines-to-azure-artifacts-using-cake&quot;&gt;《Pushing Packages From Azure Pipelines To Azure Artifacts Using Cake》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/azure/devops/pipelines/process/variables?view=azure-devops&amp;amp;tabs=yaml%2Cbatch&quot;&gt;AzureDevops Pipelines 变量相关文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/playermaker57/article/details/86760521&quot;&gt;《认识一下 Azure DevOps》&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://github.com/WuMortal/CakePushNuGet.Example&quot;&gt;参考项目：CakePushNuGet.Example&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/linianhui/cake.example&quot;&gt;参考项目：cake.example&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 28 Jun 2019 00:23:00 +0000</pubDate>
<dc:creator>Wigor</dc:creator>
<og:description>前言 大家好，我最近在想如何提交代码的时候自动的打包 NuGet 然后发布到 中的 ，在这个过程中踩了很多坑，也走了很多弯路，所以这次篇文章就是将我探索的结果和我遇到的一些问题整理分享给大家。 我的上</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/AMortal/p/11100669.html</dc:identifier>
</item>
<item>
<title>kubernetes实战篇之nexus oss服务器部署及基于nexus的docker镜像仓库搭建 - 周国通</title>
<link>http://www.cnblogs.com/tylerzhou/p/11100659.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tylerzhou/p/11100659.html</guid>
<description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/tylerzhou/p/11100649.html&quot;&gt;系列目录&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;nexus-oss仓库管理平台搭建&quot;&gt;Nexus oss仓库管理平台搭建&lt;/h2&gt;
&lt;p&gt;Nexus是一款仓库管理工具,支持Npm,bower,maven,nuget,apt,yum甚至docker,helm等各种仓库,说的通俗以下,就是私服镜像仓库.并且有免费版,OSS版即为免费版,下载的时候请注意版本的选择.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.sonatype.com/download-oss-sonatype&quot;&gt;下载地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;往下面滚动页面,可以看到&lt;code&gt;Choose your Nexus&lt;/code&gt;,有osx,windows和unix版本可供选择.这里我选择的是&lt;code&gt;windows&lt;/code&gt;版本.&lt;/p&gt;
&lt;p&gt;下载的内容是一个压缩包,下载完成后把压缩包解压.解压后有两个文件夹,我们进入&lt;code&gt;nexus-3.x.x&lt;/code&gt;文件夹下的&lt;code&gt;bin&lt;/code&gt;目录,我们在当前目录下打开&lt;code&gt;cmd&lt;/code&gt;或者从任意位置打开cmd,然后cd到上述目录.执行&lt;code&gt;nexus.exe /run&lt;/code&gt;来安装nexus&lt;/p&gt;
&lt;h3 id=&quot;注册服务&quot;&gt;注册服务&lt;/h3&gt;
&lt;p&gt;安装完成以后,执行&lt;code&gt;nexus.exe /install Nexus Service&lt;/code&gt;来注册服务&lt;/p&gt;
&lt;h3 id=&quot;启动服务&quot;&gt;启动服务&lt;/h3&gt;
&lt;p&gt;执行命令&lt;code&gt;nexus.exe /start Nexus Service&lt;/code&gt;来启动服务&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;通过以上操作,实际上是往windows服务里面添加了一个名字叫作&lt;code&gt;nexus service&lt;/code&gt;的服务,我们可以通过powerhsell命令&lt;code&gt;Get-Service &quot;nexus service&quot;&lt;/code&gt;来找到这个服务,通过&lt;code&gt;Restart-Service &quot;nexus service&quot;&lt;/code&gt;来重启它.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以上执行完成以后,就可以通过打开浏览器,输入&lt;code&gt;localhost:8081&lt;/code&gt;来访问它,也可以通过其它局域网主机使用&lt;code&gt;IP:8081&lt;/code&gt;方式来访问它.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201906/811801-20190628075946965-230779203.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过首页,我们可以看到Nexus罗列出来的支持的仓库类型,非常丰富.&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;注意,大家可能看到我访问的端口号并不是&lt;code&gt;8081&lt;/code&gt;而是8443,这是因为我设置的http自动跳转到https,并且指定的https端口为&lt;code&gt;8443&lt;/code&gt;,这里之所以要启用https是因为下面即将讲到的docker镜像上传需要使用https.这部分内容将在下一节讲解.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;登陆&quot;&gt;登陆&lt;/h3&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;注意,如果没有登陆,Nexus并不是以显著的方式提示你登陆,但是非登陆用户功能受限.要想实现一些管理功能,必须登陆.登陆需要点击右上角&lt;code&gt;sign in&lt;/code&gt;按钮.默认登陆用户名为&lt;code&gt;admin&lt;/code&gt;密码为&lt;code&gt;admin123&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;nexus搭建docker镜像仓库&quot;&gt;Nexus搭建docker镜像仓库&lt;/h2&gt;
&lt;p&gt;上一节我们讲了如何在windows下安装nexus,本节我们讲解如何来搭建nexus来搭建docker镜像仓库.&lt;/p&gt;
&lt;p&gt;我们进入web管理界面,点击&lt;code&gt;齿轮&lt;/code&gt;图标,然后点击&lt;code&gt;Repositories&lt;/code&gt;.如下图示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201906/811801-20190628080039990-1327947430.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;注意,以上操作需要登陆.登陆方式为点击右上角&lt;code&gt;sign in&lt;/code&gt;,然后用默认&lt;code&gt;admin&lt;/code&gt;,&lt;code&gt;admin123&lt;/code&gt;登陆.详细请见上一节内容&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然后点击&lt;code&gt;create repository&lt;/code&gt;按钮.如下图操作&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201906/811801-20190628080033265-642130129.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;页面出来了非常多的仓库类型供选择,由于我们要创建的是docker仓库,这里选择的是&lt;code&gt;docker hosted&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201906/811801-20190628080026576-19377466.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击后出现如下界面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201906/811801-20190628080020171-1408567751.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;配置上面填写的内容,填写完成后我们点击左下角&lt;code&gt;create repository&lt;/code&gt;来创建仓库&lt;/p&gt;
&lt;h3 id=&quot;nexus服务器支持https配置&quot;&gt;nexus服务器支持https配置&lt;/h3&gt;
&lt;p&gt;由于我们使用的是https方式通讯,因此我们需要对nexus服务器进行配置,以支持https.由于我们的证书是自己生成的,因此docker客户端也需添加对自己生成key的信任.&lt;/p&gt;
&lt;h4 id=&quot;服务端开启监听ssl协议端口&quot;&gt;服务端开启监听ssl协议端口&lt;/h4&gt;
&lt;p&gt;进到&lt;code&gt;nexus-xxx-xxx&lt;/code&gt;目录下(前面一节提到的从官网下载的nexus压缩包解压后的一个目录),进到&lt;code&gt;ect&lt;/code&gt;目录下,里面有一个&lt;code&gt;nexus-default.properties&lt;/code&gt;文件,用文本编辑器打开它&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;# Jetty section&lt;/code&gt;注释下面添加一行,内容为&lt;code&gt;application-port-ssl=8443&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;nexus-args&lt;/code&gt;一行尾部添加&lt;code&gt;,${jetty.etc}/jetty-http-redirect-to-https.xml&lt;/code&gt;,以指示服务器自动将http跳转到https&lt;/p&gt;
&lt;h4 id=&quot;生成证书秘钥&quot;&gt;生成证书秘钥&lt;/h4&gt;
&lt;p&gt;网上有很多生成密码证书的博客文章,使用的工具也不尽相同.这里,我们使用java jkd自带的&lt;code&gt;keytool.exe&lt;/code&gt;来生成ssl证书.&lt;/p&gt;
&lt;p&gt;进入到&lt;code&gt;nexus-xxx-xxx&lt;/code&gt;目录下的&lt;code&gt;ect/ssl&lt;/code&gt;目录下,执行以下命令:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;keytool -genkeypair -keystore keystore.jks -storepass nexus3 -keypass nexus3 -alias jetty -keyalg RSA -keysize 2048 -validity 5000 -dname &quot;CN=${NEXUS_DOMAIN}, OU=Example, O=Sonatype, L=Unspecified, ST=Unspecified, C=US&quot; -ext &quot;SAN=DNS:${NEXUS_DOMAIN},IP:${NEXUS_IP_ADDRESS}&quot; -ext &quot;BC=ca:true&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中&lt;code&gt;${NEXUS_IP_ADDRESS}&lt;/code&gt;替换为你的实际ip地址,${NEXUS_DOMAIN}如果没有域名可以随便填写&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;需要注意的是,如果由于环境变量配置问题导致&lt;code&gt;keytool&lt;/code&gt;命令找不到,则需要显式指定&lt;code&gt;keytool.exe&lt;/code&gt;完整路径,然后后面带上要执行的命令.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;修改jetty-https.xml&quot;&gt;修改&lt;code&gt;jetty-https.xml&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;进入到&lt;code&gt;nexus-xxx-xxx&lt;/code&gt;目录下的&lt;code&gt;etc/jetty&lt;/code&gt;目录下,用文本编辑器打开&lt;code&gt;jetty-https.xml&lt;/code&gt;文件&lt;/p&gt;
&lt;p&gt;把里面对应的内容修改为如下配置:&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;    &amp;lt;Set name=&quot;KeyStorePath&quot;&amp;gt;&amp;lt;Property name=&quot;karaf.etc&quot;/&amp;gt;/ssl/keystore.jks&amp;lt;/Set&amp;gt;
    &amp;lt;Set name=&quot;KeyStorePassword&quot;&amp;gt;nexus3&amp;lt;/Set&amp;gt;
    &amp;lt;Set name=&quot;KeyManagerPassword&quot;&amp;gt;nexus3&amp;lt;/Set&amp;gt;
    &amp;lt;Set name=&quot;TrustStorePath&quot;&amp;gt;&amp;lt;Property name=&quot;karaf.etc&quot;/&amp;gt;/ssl/keystore.jks&amp;lt;/Set&amp;gt;
    &amp;lt;Set name=&quot;TrustStorePassword&quot;&amp;gt;nexus3&amp;lt;/Set&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;注意以上内容全是修改,而不是新增,修改的时候找到相同key的修改即可.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;重启nexus服务器&quot;&gt;重启nexus服务器&lt;/h3&gt;
&lt;p&gt;可以通过上一节介绍的powershell命令&lt;code&gt;Restart-Service &quot;nexus service&lt;/code&gt;来重启服务,以使配置生效.&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;需要注意的是,执行以上命令需要以管理员身份启动powershell.除了使用命令以外,也可以进入到服务管理里面找到名为&lt;code&gt;nexus service&lt;/code&gt;的服务,然后手动重启它.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;执行完以上配置以后,我们再打开浏览器访问&lt;code&gt;https://..localhost:8443&lt;/code&gt;或者&lt;code&gt;http://localhost:8081&lt;/code&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;注意,重启服务以后,如果以上内容不能马上响应,可以等一会时间再观察看看.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;配置客户端信任ca证书&quot;&gt;配置客户端信任ca证书&lt;/h3&gt;
&lt;p&gt;我的docker服务器安装在&lt;code&gt;192.168.122.65&lt;/code&gt;上面.下面介绍centos和ubuntu下如何添加证书信任&lt;/p&gt;
&lt;h4 id=&quot;centos下添加证书信任&quot;&gt;centos下添加证书信任&lt;/h4&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;#生成cert文件
[root@localhost ~]# keytool -printcert -sslserver 192.168.124.43:8443 -rfc &amp;gt;nexus.crt
[root@localhost ~]# yum install ca-certificates
[root@localhost ~]# update-ca-trust force-enable
# 还可以放在/etc/docker/certs.d/192.168.124.43:8443目录下
[root@localhost ~]# mv nexus.crt /etc/pki/ca-trust/source/anchors/nexus.crt
[root@localhost ~]# update-ca-trust
[root@localhost ~]# service docker restart
[root@localhost ~]# docker login -u admin -p admin123 192.168.124.43:8002
Login Succeeded&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;ubuntu下添加信任证书&quot;&gt;ubuntu下添加信任证书&lt;/h4&gt;
&lt;p&gt;对于Ubuntu系统来说certificate的存放路径是 /usr/local/share/ca-certificates&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;
### 生成cert文件
[root@localhost ~]# keytool -printcert -sslserver 192.168.124.43:8443 -rfc &amp;gt;nexus.crt
# 还可以放在/etc/docker/certs.d/192.168.124.43:8443目录下
[root@localhost ~]# mv nexus.crt /usr/local/share/ca-certificates/nexus.crt
[root@localhost ~]# update-ca-certificates
[root@localhost ~]# service docker restart
[root@localhost ~]# docker login -u admin -p admin123 192.168.124.43:8002&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;在redhat系统中,如果报Unkonw authority错误,修改&lt;code&gt;/etc/pki/tls/openssl.cnf&lt;/code&gt;。在其中的&lt;code&gt;[ v3_ca]&lt;/code&gt;部分，添加&lt;code&gt;subjectAltName&lt;/code&gt;选项&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[ v3_ca ]  
subjectAltName = IP:192.168.124.43&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后再执行以下命令&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[root@localhost ~]# service docker restart
[root@localhost ~]# docker login -u admin -p admin123 192.168.124.43:8002
Login Succeeded&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;注,网上有不少介绍使用http访问的方法,但是却没有执行成功,大家可以尝试一下&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[root@localhost centos]# vi /etc/docker/daemon.json
{
  &quot;insecure-registries&quot;: [
    &quot;192.168.124.43:8003&quot;
  ],
  &quot;disable-legacy-registry&quot;: true&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;上传镜像到docker仓库&quot;&gt;上传镜像到docker仓库&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;为镜像打标签&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;docker tag 镜像名:tag名 192.168.124.43:8002/镜像名:tag名&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我里,我没有自己创建镜像,而是随便找了一个已以存在的镜像,然后打上标签,如下&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;192.168.124.43:8002/rancher/nginx-ingress-controller-defaultbackend&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过执行&lt;code&gt;docker push&lt;/code&gt;命令把它推到远程私服仓库&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[root@localhost ~]# docker push 192.168.124.43:8002/rancher/nginx-ingress-controller-defaultbackend
The push refers to a repository [192.168.124.43:8002/rancher/nginx-ingress-controller-defaultbackend]
d62604d5d244: Pushed
1.4: digest: sha256:f63ced70bc85ca753e715c93b0adc3115510a6575129102383236c30112379e5 size: 528
[root@localhost ~]#&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;注意,推送前是需要先登陆的,登陆的方法上面也介绍过了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们登陆nexus web管理界面,点击左侧&lt;code&gt;Broswe&lt;/code&gt;,可以看到已经有内容push进来了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201906/811801-20190628080014152-896355813.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们执行&lt;code&gt;docker search&lt;/code&gt;命令&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[root@localhost ~]# docker search 192.168.124.43:8002/rancher/nginx-ingress-controller-defaultbackend
NAME                                                                      DESCRIPTION   STARS     OFFICIAL   AUTOMATED
192.168.124.43:8002/rancher/nginx-ingress-controller-defaultbackend:1.4                 0
[root@localhost ~]#&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到能够从远程服务器上搜索到它.&lt;/p&gt;
&lt;h3 id=&quot;拉取上传的镜像&quot;&gt;拉取上传的镜像&lt;/h3&gt;
&lt;p&gt;实际环境中,生成docker镜像和服务器和使用docker镜像的服务器往往不是同一台服务器.这里我们使用另一个服务器&lt;code&gt;192.168.124.59&lt;/code&gt;来拉取刚刚上传的镜像&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;需要注意的是,这里基于的前提是用于拉取镜像的服务器已经安装了docker,docker的安装可以参考其它章节或者网络上的教程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;-紧接着执行&lt;code&gt;update-ca-trust force-enable&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[root@k8s-master ~]# docker login -u admin -p admin123 192.168.124.43:8002
WARNING! Using --password via the CLI is insecure. Use --password-stdin.
WARNING! Your password will be stored unencrypted in /root/.docker/config.json.
Configure a credential helper to remove this warning. See
https://docs.docker.com/engine/reference/commandline/login/#credentials-store

Login Succeeded&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们执行&lt;code&gt;docker pull&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;
[root@k8s-master ~]# docker pull 192.168.124.43:8002/rancher/nginx-ingress-controller-defaultbackend:1.4
1.4: Pulling from rancher/nginx-ingress-controller-defaultbackend
5990baa43a5e: Pull complete
Digest: sha256:f63ced70bc85ca753e715c93b0adc3115510a6575129102383236c30112379e5
Status: Downloaded newer image for 192.168.124.43:8002/rancher/nginx-ingress-controller-defaultbackend:1.4
[root@k8s-master ~]#&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注意pull的时候要带上版本的tag&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以上,我们从一台服务器(192.168.122.65)推送镜像到私服,然后用另一台服务器拉取(192.168.124.59).需要注意的是,由于服务端使用了自已生成的https证书,因此docker镜像生产端和消费端都要添加ca证书信任&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/michaelwubo/article/details/80691594&quot;&gt;参考资料1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/wzy5223/p/5410990.html&quot;&gt;参考资料2&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 28 Jun 2019 00:18:00 +0000</pubDate>
<dc:creator>周国通</dc:creator>
<og:description>'系列目录' Nexus oss仓库管理平台搭建 Nexus是一款仓库管理工具,支持Npm,bower,maven,nuget,apt,yum甚至docker,helm等各种仓库,说的通俗以下,就是私</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tylerzhou/p/11100659.html</dc:identifier>
</item>
<item>
<title>在.NET Core 3.0中的WPF中使用IOC图文教程 - 依乐祝</title>
<link>http://www.cnblogs.com/yilezhu/p/11099358.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yilezhu/p/11099358.html</guid>
<description>&lt;p&gt;我们都知道.NET Core 3.0已经发布了第六个预览版，我们也知道.NET Core 3.0现在已经支持创建WPF项目了，刚好今天在写一个代码生成器的客户端的时候用到了WPF，所以就把WPF创建以及使用IOC的过程记录一下，希望能对大家有所帮助。当然文章实例我就以我曾阅读过的一篇文章的示例代码来进行演示了。&lt;/p&gt;
&lt;blockquote readability=&quot;2.0987654320988&quot;&gt;
&lt;p&gt;作者：依乐祝&lt;/p&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://www.cnblogs.com/yilezhu/p/11099358.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/yilezhu/p/11099358.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;步骤&quot;&gt;步骤&lt;/h2&gt;
&lt;ol readability=&quot;18.5&quot;&gt;&lt;li readability=&quot;10&quot;&gt;
&lt;p&gt;通过命令行创建wpf项目，当然你也可以通过vs2019来进行创建。具体的步骤就不演示了，当然，如果你还不会用vs2019创建项目，那么请你右上角关闭网页，省的烦心。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;❯ mkdir WpfIoc
❯ cd WpfIoc
❯ dotnet.exe --version
3.0.100-preview6-012264

❯ dotnet new wpf
The template &quot;WPF Application&quot; was created successfully.

Processing post-creation actions...
Running 'dotnet restore' on C:\Users\laure\projects\WpfIoc\WpfIoc.csproj...
  Restore completed in 90.03 ms for C:\Users\laure\projects\WpfIoc\WpfIoc.csproj.

Restore succeeded.

❯ dotnet build
Microsoft (R) Build Engine version 16.1.54-preview+gd004974104 for .NET Core
Copyright (C) Microsoft Corporation. All rights reserved.

  Restore completed in 19.92 ms for C:\Users\laure\projects\WpfIoc\WpfIoc.csproj.
C:\Program Files\dotnet\sdk\3.0.100-preview6-012264\Sdks\Microsoft.NET.Sdk\targets\Microsoft.NET.RuntimeIdentifierInference.targets(151,5): message NETSDK1057: You are using a preview version of .NET Core. See: https://aka.ms/dotnet-core-preview [C:\Users\laure\projects\WpfIoc\WpfIoc.csproj]
  WpfIoc -&amp;gt; C:\Users\laure\projects\WpfIoc\bin\Debug\netcoreapp3.0\WpfIoc.dll

Build succeeded.
    0 Warning(s)
    0 Error(s)

Time Elapsed 00:00:01.63&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们想要实现的是引导应用程序并在MainWindow的构造函数中注入一个服务，该服务将被调用以便在应用程序的主窗口上显示一些文本。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;我们首选要安装下&lt;code&gt;Microsoft Extensions DependencyInjection&lt;/code&gt;nuget包，当然你也可以通过下面的方式进行添加，不过最好还是通过nuget的方式引入最新的预览版即可。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;&amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk.WindowsDesktop&quot;&amp;gt;

  &amp;lt;PropertyGroup&amp;gt;
    &amp;lt;OutputType&amp;gt;WinExe&amp;lt;/OutputType&amp;gt;
    &amp;lt;TargetFramework&amp;gt;netcoreapp3.0&amp;lt;/TargetFramework&amp;gt;
    &amp;lt;UseWPF&amp;gt;true&amp;lt;/UseWPF&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;

  &amp;lt;ItemGroup&amp;gt;
    &amp;lt;PackageReference Include=&quot;Microsoft.Extensions.DependencyInjection&quot; Version=&quot;3.0.0-preview6.19304.6&quot; /&amp;gt;
  &amp;lt;/ItemGroup&amp;gt;

  &amp;lt;ItemGroup&amp;gt;
    &amp;lt;ProjectReference Include=&quot;..\StoneGenerate.Core\StoneGenerate.Core.csproj&quot; /&amp;gt;
  &amp;lt;/ItemGroup&amp;gt;

&amp;lt;/Project&amp;gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;创建一个&lt;code&gt;ITextService&lt;/code&gt;接口服务，这个接口将由依赖注入容器注入到&lt;code&gt;MainWindow&lt;/code&gt;类中进行使用。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public interface ITextService
{
    string GetText();
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;当然你还得创建一个&lt;code&gt;TextService&lt;/code&gt;类来实现上面的接口。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;class TextService : ITextService
{
    private string _text;

    public TextService(string text)
    {
        _text = text;
    }

    public string GetText()
    {
        return _text;
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;接下来在我们的入口&lt;code&gt;App.xaml.cs&lt;/code&gt;文件中配置我们的IOC容器，并入住我们的服务，相信做过.NET Core项目的你，对下面的代码应该都非常的熟悉，这里就不过多的解释了，省的浪费大家的宝贵时间。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public App()
{
    var serviceCollection = new ServiceCollection();
    ConfigureServices(serviceCollection);

    _serviceProvider = serviceCollection.BuildServiceProvider();
}

private void ConfigureServices(IServiceCollection services)
{
    services.AddSingleton&amp;lt;ITextService&amp;gt;(provider =&amp;gt; new TextService(&quot;Hi WPF .NET Core 3.0&quot;));
    services.AddSingleton&amp;lt;MainWindow&amp;gt;();
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;接下来我们重写一下&lt;code&gt;App.xaml.cs&lt;/code&gt;的&lt;code&gt;OnStartup&lt;/code&gt;方法，解析出&lt;code&gt;MainWindow&lt;/code&gt; 并show出来&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;protected override void OnStartup(StartupEventArgs e)
        {
            base.OnStartup(e);
            var main = serviceProvider.GetRequiredService&amp;lt;MainWindow&amp;gt;();
            main.Show();
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然，这也就意味着你得移除&lt;code&gt;App.xmal&lt;/code&gt;中的启动选项，代码如下：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;&amp;lt;Application x:Class=&quot;wpfioc.App&quot;
             xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;
             xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;
             xmlns:local=&quot;clr-namespace:wpfioc&quot;
             Startup=&quot;App_OnStartup&quot;&amp;gt;
    &amp;lt;Application.Resources&amp;gt;
    &amp;lt;/Application.Resources&amp;gt;
&amp;lt;/Application&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ol readability=&quot;3&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;接下来我们修改一下&lt;code&gt;MainWindow&lt;/code&gt;的xaml代码以便来显示我们的文本信息：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;&amp;lt;Window x:Class=&quot;WpfIoc.MainWindow&quot;
        xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;
        xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;
        xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot;
        xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot;
        xmlns:local=&quot;clr-namespace:WpfIoc&quot;
        mc:Ignorable=&quot;d&quot;
        Title=&quot;MainWindow&quot; Height=&quot;450&quot; Width=&quot;800&quot;&amp;gt;
    &amp;lt;Grid&amp;gt;
        &amp;lt;Grid.RowDefinitions&amp;gt;
            &amp;lt;RowDefinition Height=&quot;9*&quot; /&amp;gt;
            &amp;lt;RowDefinition Height=&quot;1*&quot; /&amp;gt;
        &amp;lt;/Grid.RowDefinitions&amp;gt;
        &amp;lt;Label Name=&quot;Label&quot; Content=&quot;Hello .NET Core!&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot; FontSize=&quot;40&quot; /&amp;gt;
    &amp;lt;/Grid&amp;gt;
&amp;lt;/Window&amp;gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;当然，&lt;code&gt;MainWindow&lt;/code&gt;的cs代码也要进行下调整，以便能够接受IOC注入进来的方法。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public partial class MainWindow : Window
{
    public MainWindow(ITextService textService)
    {
        InitializeComponent();

        Label.Content = textService.GetText();
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;结果&quot;&gt;结果&lt;/h2&gt;
&lt;p&gt;相信上面的繁琐的步骤你也都看完了，那么接下来就是见证奇迹的时刻了，睁开你的双眼，奉上精美图片一张：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201906/1377250-20190627200714818-1963353196.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图所示：&lt;code&gt;MainWindow&lt;/code&gt;调用了IOC注入进来的&lt;code&gt;TextService&lt;/code&gt;服务并正确的显示了文字。&lt;/p&gt;
&lt;p&gt;谢天谢地，没出bug，其实我想说，这张图为了偷懒，我都是盗的，文末上原文链接。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://laurentkempe.com/2019/04/18/WPF-and-IOC-on-NET-Core-3-0/&quot; class=&quot;uri&quot;&gt;https://laurentkempe.com/2019/04/18/WPF-and-IOC-on-NET-Core-3-0/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;最后&quot;&gt;最后&lt;/h2&gt;
&lt;p&gt;最近事情比较多，都没时间好好的分享文章了。当然，每当我闲下来的时候我就会对所学所用进行相应的总结后进行分享的。只是工作忙的原因，频次越来越低而已。&lt;/p&gt;
</description>
<pubDate>Thu, 27 Jun 2019 23:59:00 +0000</pubDate>
<dc:creator>依乐祝</dc:creator>
<og:description>我们都知道.NET Core 3.0已经发布了第六个预览版，我们也知道.NET Core 3.0现在已经支持创建WPF项目了，刚好今天在写一个代码生成器的客户端的时候用到了WPF，所以就把WPF创建以</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yilezhu/p/11099358.html</dc:identifier>
</item>
<item>
<title>多进程界面开发-Qt试玩儿 - 朝十晚八</title>
<link>http://www.cnblogs.com/swarmbees/p/11100513.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/swarmbees/p/11100513.html</guid>
<description>&lt;h2 id=&quot;一概述&quot;&gt;一、概述&lt;/h2&gt;
&lt;p&gt;做客户端开发已经有好几个年头了，今天看到同事发了一篇关于富途牛牛的文章，核心思想就是想说，新版本的富途支持多进程架构了，效率大大提升啦，可以更好的适应多核CPU，提高软件运行效率。&lt;/p&gt;
&lt;p&gt;听到这个消息，我不仅感叹，我靠，真的好牛逼。&lt;/p&gt;
&lt;p&gt;但是心里又在默默的想，这个东西到底有什么好处，多进程写界面！！！从来没这么搞过呀，会不会有坑，到底比多线程好在了哪里？带着这个问题，从百度上看了几篇相关文章，其中一些是线程和进程的区别文章，而更多的还是关注多进程界面怎么去开发。&lt;/p&gt;
&lt;p&gt;资料真是少的可怜，而且都不是特别全面。所以自己打算深入的写写这方面的东西&lt;/p&gt;
&lt;p&gt;其实很早以前就接触过多进程，只是自己好像也没有想那么多，一直对多进程架构的概念不是那么清晰。今天和同事聊了一些相关话题，感觉自己的知识面豁然开朗，要学习的东西好像还挺多。&lt;/p&gt;
&lt;p&gt;看下面这张图，是任务管理器的应用截图，以前还真是没发现，居然我自己用的这么多应用都是多进程架构的。&lt;/p&gt;
&lt;p&gt;我们平时最常用的Chrome浏览器，客户端版本微信，还有有道云笔记等等&lt;/p&gt;
&lt;center&gt;&lt;br/&gt;&lt;div&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/swarmbees/1491901/o_example_muti.png&quot;/&gt;&lt;br/&gt;&lt;/div&gt;
&lt;br/&gt;&lt;/center&gt;
&lt;p&gt;有了这么多的多进程架构开发的客户端软件，难道说多进程开发已经是势在必行了？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说这么多，还不如来点儿实际的干货，这篇文章是我初步开始使用多进程开发端产品的尝试，有不对的地方欢迎大家指出，可以给出更好建议&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;二效果展示&quot;&gt;二、效果展示&lt;/h2&gt;
&lt;p&gt;下面是我做的一个demo程序截图，测试程序中一共包含了4个使用场景，分别是：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Qt嵌入系统自带计算机&lt;/li&gt;
&lt;li&gt;Qt嵌入系统自带记事本&lt;/li&gt;
&lt;li&gt;Qt调用系统ping命令，并收集结果&lt;/li&gt;
&lt;li&gt;Qt嵌入其他Qt可执行程序&lt;/li&gt;
&lt;/ol&gt;&lt;center&gt;
&lt;div&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/swarmbees/1491901/o_mutil_process.gif&quot;/&gt;&lt;/div&gt;
&lt;/center&gt;
&lt;p&gt;大家可以先看看效果图，如果觉着有价值的可以继续往下看，下面我会分章节把四个事例进行讲解。&lt;/p&gt;
&lt;h2 id=&quot;三使用方法&quot;&gt;三、使用方法&lt;/h2&gt;
&lt;p&gt;首先需要清楚，我们是多进程界面开发，那么我们的exe启动后，势必是需要启动其他可执行程序的，并且把其他进程的界面嵌入到我们的窗口中来，代码执行流程可能像这样。&lt;/p&gt;
&lt;h3 id=&quot;启动外部进程&quot;&gt;1、启动外部进程&lt;/h3&gt;
&lt;p&gt;启动外部进程有多种方式，Qt使用比较习惯的同学可以直接使用QProcess类，这个类是Qt封装的一个跨平台的类。&lt;/p&gt;
&lt;p&gt;启动方式可能像下面这样&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;QProcess * myProcess = new QProcess(this);
QStringList arguments;
myProcess-&amp;gt;start(&quot;C:/Windows/System32/notepad.exe&quot;);
myProcess-&amp;gt;waitForFinished(2000);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;除过QProcess之外，Windows系统上我们还可以使用CreateProcess方法来创建进程。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;QString cmd = &quot;C:/Windows/system32/calc.exe&quot;;
STARTUPINFO si = { sizeof(si) };
PROCESS_INFORMATION pi;
si.dwFlags = STARTF_USESHOWWINDOW;
si.wShowWindow = true;

bool bRet = CreateProcess(
    NULL,
    (LPWSTR)cmd.toStdWString().c_str(),
    NULL,
    NULL,
    FALSE,
    CREATE_NEW_CONSOLE,
    NULL,
    NULL, &amp;amp;si, &amp;amp;pi);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;创建qt窗口&quot;&gt;2、创建Qt窗口&lt;/h3&gt;
&lt;p&gt;外部进程启动后，我们可以在任务管理器中找到启动的进程&lt;/p&gt;
&lt;p&gt;接着我们需要使用SPY++工具进行查看外部进程的类名称和窗口名称，并使用FindWindow接口进行查找，找到这个进程的主窗口句柄后，嵌入到我们的程序中来。&lt;/p&gt;
&lt;p&gt;类名和窗口名称查找过程可以参考&lt;a href=&quot;https://blog.csdn.net/u013394556/article/details/78534833&quot;&gt;外部进程嵌入到Qt进程界面&lt;/a&gt;这篇文章中的内容。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;WId wid = (WId)FindWindow(QStringLiteral(&quot;Notepad&quot;).toStdWString().c_str()
        , QStringLiteral(&quot;无标题 - 记事本&quot;).toStdWString().c_str());

QWindow * window = QWindow::fromWinId(wid);
if (window)
{
    window-&amp;gt;setFlags(window-&amp;gt;flags() | Qt::CustomizeWindowHint | Qt::WindowTitleHint); //这边可以设置一下属性

    QWidget * widget = QWidget::createWindowContainer(window, this, Qt::Widget);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上代码所示，我们如果找到外部进程的主窗口句柄后，就可以使用Qt提供的createWindowContainer这个接口进行创建QWidget，并加入到我们的程序中来。&lt;/p&gt;
&lt;h3 id=&quot;加入到主进程布局&quot;&gt;3、加入到主进程布局&lt;/h3&gt;
&lt;p&gt;外部进程被封装成为一个QWidget后，我们只需要加入到自己的布局中即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ui.verticalLayout_2-&amp;gt;addWidget(widget);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来我们分别讲解不同场景下的多进程界面开发的简单使用&lt;/p&gt;
&lt;h2 id=&quot;四嵌入notepad&quot;&gt;四、嵌入NotePad&lt;/h2&gt;
&lt;p&gt;第三小节已经把嵌入其他程序的流程大致说了一遍，这里我就不在详细说明了，直接给出具体代码。&lt;/p&gt;
&lt;p&gt;代码中比较关键的有2个地方&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;QProcess不能使用临时变量，要不然函数执行完毕notepad.exe进程也就退出了。&lt;/li&gt;
&lt;li&gt;FindWindow的两个参数，一个是类名，一个窗口标题栏名称，这两个信息都可以用个SPY++进行查找。&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;void EmbedCalculate::on_pushButton_2_clicked()
{
    //创建进程
    QString cmd = &quot;C:/Windows/System32/notepad.exe&quot;;

    QProcess * myProcess = new QProcess(this);
    QStringList arguments;
    myProcess-&amp;gt;start(cmd);
    myProcess-&amp;gt;waitForFinished(2000);

    WId wid = (WId)FindWindow(QStringLiteral(&quot;Notepad&quot;).toStdWString().c_str()
        , QStringLiteral(&quot;无标题 - 记事本&quot;).toStdWString().c_str());

    QWindow * window = QWindow::fromWinId(wid);
    if (window)
    {
        window-&amp;gt;setFlags(window-&amp;gt;flags() | Qt::CustomizeWindowHint | Qt::WindowTitleHint); //这边可以设置一下属性

        QWidget * widget = QWidget::createWindowContainer(window, this, Qt::Widget);

        ui.verticalLayout_2-&amp;gt;addWidget(widget);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;五调用ping命令&quot;&gt;五、调用Ping命令&lt;/h2&gt;
&lt;p&gt;ping命令使用场景主要是想展示主进程和外部进程是怎样通信的，虽然这个事例比较简单，但也算是两者之间发生了信息交换&lt;/p&gt;
&lt;p&gt;子进程在执行完ping一个地址之后，会把得到的结果传递给主进程，主进程使用readAll函数全部读入到主进程中。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void EmbedCalculate::on_pushButton_3_clicked()
{
    //创建进程
    QProcess * myProcess = new QProcess(this);
    connect(myProcess, static_cast&amp;lt;void (QProcess::*)(int)&amp;gt;(&amp;amp;QProcess::finished), this, [this, myProcess](int exitCode){
        if (exitCode == 0) {
            QTextCodec * gbkCodec = QTextCodec::codecForName(&quot;GBK&quot;);
            QString result = gbkCodec-&amp;gt;toUnicode(myProcess-&amp;gt;readAll());
            ui.textEdit-&amp;gt;setText(result);
        }
    });

    //myProcess-&amp;gt;start(&quot;cmd.exe&quot;, QStringList() &amp;lt;&amp;lt; &quot;/c&quot; &amp;lt;&amp;lt; &quot;ping www.baidu.com&quot;);
    myProcess-&amp;gt;start(&quot;cmd.exe&quot;, QStringList() &amp;lt;&amp;lt; &quot;/c&quot; &amp;lt;&amp;lt; &quot;ping &quot; + ui.lineEdit-&amp;gt;text().trimmed());
    myProcess-&amp;gt;waitForFinished(2000);

    ···
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;虽然这个东西是最后讲的，但是这个才是重头戏，有了这个实验之后，我们以后的Qt多进程界面开发也可以进行投入正式环境了。&lt;/p&gt;
&lt;p&gt;如下所示，ChildWidget外部程序的主窗体被我们嵌入到了EmbedCalculate这个进程的主界面上，突然觉着好神奇，给自己点赞，哈哈哈哈。&lt;/p&gt;
&lt;center&gt;
&lt;div&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/swarmbees/1491901/o_mutil_explorer.gif&quot;/&gt;&lt;/div&gt;
&lt;/center&gt;
&lt;p&gt;由于我这里的ChildWidget外部程序和EmbedCalculate主程序在一个目录中，因此cmd变量直接就指向了ChildWidget这个外部程序的名称。&lt;/p&gt;
&lt;p&gt;其他部分的代码基本上就和前边几种使用场景差不多。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void EmbedCalculate::on_pushButton_4_clicked()
{
    //创建进程
    QString cmd = &quot;ChildWidget.exe&quot;;

    QProcess * myProcess = new QProcess(this);
    QStringList arguments;
    myProcess-&amp;gt;start(cmd);
    myProcess-&amp;gt;waitForFinished(2000);

    WId wid = (WId)FindWindow(QStringLiteral(&quot;Qt5QWindowIcon&quot;).toStdWString().c_str()
        , QStringLiteral(&quot;ChildWidget&quot;).toStdWString().c_str());

    QWindow * window = QWindow::fromWinId(wid);
    if (window)
    {
        window-&amp;gt;setFlags(window-&amp;gt;flags() | Qt::CustomizeWindowHint | Qt::WindowTitleHint); //这边可以设置一下属性

        QWidget * widget = QWidget::createWindowContainer(window, this, Qt::Widget);

        ui.verticalLayout_3-&amp;gt;addWidget(widget);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;七相关文章&quot;&gt;七、相关文章&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/u013394556/article/details/78534833&quot;&gt;外部进程嵌入到Qt进程界面&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;以上的内容，基本上就是本篇文章的内容所有内容啦！初步完成了qt内嵌其他进程界面的功能，希望可以帮到大家。&lt;/strong&gt;&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;很重要--转载声明&lt;/strong&gt;&lt;/p&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;本站文章无特别说明，皆为原创，版权所有，转载时请用链接的方式，给出原文出处。同时写上原作者：&lt;a href=&quot;https://www.cnblogs.com/swarmbees/&quot;&gt;朝十晚八&lt;/a&gt; or &lt;a href=&quot;https://www.jianshu.com/u/7673f8cfb4e6&quot;&gt;Twowords&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如要转载，请原文转载，如在转载时修改本文，请事先告知，谢绝在转载时通过修改本文达到有利于转载者的目的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;</description>
<pubDate>Thu, 27 Jun 2019 22:59:00 +0000</pubDate>
<dc:creator>朝十晚八</dc:creator>
<og:description>[TOC] 一、概述 做客户端开发已经有好几个年头了，今天看到同事发了一篇关于富途牛牛的文章，核心思想就是想说，新版本的富途支持多进程架构了，效率大大提升啦，可以更好的适应多核CPU，提高软件运行效率</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/swarmbees/p/11100513.html</dc:identifier>
</item>
<item>
<title>Spring5源码深度分析(二)之理解@Conditional,@Import注解 - Brian_Huang</title>
<link>http://www.cnblogs.com/hlkawa/p/11088129.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hlkawa/p/11088129.html</guid>
<description>&lt;p&gt; 代码地址：&lt;a href=&quot;https://github.com/showkawa/spring-annotation/tree/master/src/main/java/com/brian&quot; target=&quot;_blank&quot;&gt;https://github.com/showkawa/spring-annotation/tree/master/src/main/java/com/brian&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;1.源码分析二主要分析的内容&lt;/h3&gt;
&lt;p&gt;1.使用@Condition多条件注册bean对象&lt;br/&gt;2.@Import注解快速注入第三方bean对象&lt;br/&gt;3.@EnableXXXX 开启原理&lt;br/&gt;4.基于ImportBeanDefinitionRegistrar注册bean&lt;br/&gt;5.基于FactoryBean注册bean对象&lt;/p&gt;

&lt;h3&gt;1.使用@Conditional多条件注册bean对象&lt;/h3&gt;
&lt;p&gt;conditional字面意思条件句，亦即满足某些条件将该类注册到IOC容器的意思&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Conditional {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * All {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; Condition Conditions} that must {&lt;/span&gt;&lt;span&gt;@linkplain&lt;/span&gt;&lt;span&gt; Condition#matches match}
     * in order for the component to be registered.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    Class&lt;/span&gt;&amp;lt;? &lt;span&gt;extends&lt;/span&gt; Condition&amp;gt;&lt;span&gt;[] value();

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到 Conditional注解的value是Condition的子类或实现类&lt;/p&gt;
&lt;p&gt;我这里写自定义的BriancCondition类来实现Condition接口，可以看到Condition就一个返回boolean值的mathes()方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BrianCondition &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Condition {

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
    * context:判断条件能使用的上下文（环境）
    * metadata: 注释信息
    * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; matches(ConditionContext context, AnnotatedTypeMetadata metadata) {

        System.out.println(&lt;/span&gt;&quot;---male:&quot; + context.getRegistry().containsBeanDefinition(&quot;person&quot;&lt;span&gt;));&lt;br/&gt;　　　　　//我这里判断ioc容器中是否有person实例，有返回true,否则返回false
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(context.getRegistry().containsBeanDefinition(&quot;person&quot;&lt;span&gt;))
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 现在在配置类中加上，注册Person类到容器中，然后用@Conditional控制是否将person01和person02注册到容器中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
@Configuration &lt;span&gt;//&lt;/span&gt;&lt;span&gt;告诉spring这是一个配置类&lt;/span&gt;&lt;span&gt;
/*&lt;/span&gt;&lt;span&gt;
* @ComponentScan
*   value:只当于扫描的的包
*   excludeFilters = 指定扫描的时候按照什么规则排除哪些组件
*   includeFilters = 指定扫描的时候只需要包含哪些组件
*   Filter.ANNOTATION:按照注解
*   Filter.ASSIGNABLE_TYPE: 按照给定的类型
* &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

@ComponentScans(value &lt;/span&gt;=&lt;span&gt; {
        @ComponentScan(value &lt;/span&gt;= &quot;com.brian&quot;,includeFilters =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                @ComponentScan.Filter(type = FilterType.ANNOTATION,classes = {Controller.class}),
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                @ComponentScan.Filter(type=FilterType.ASSIGNABLE_TYPE,classes = {BookService.class}),&lt;/span&gt;
                @ComponentScan.Filter(type = FilterType.CUSTOM,classes = {BrianTypeFilter.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;})
        },useDefaultFilters &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
})
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;@Import({Brian.class,Alan.class,BrianSelector.class})&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MainConfig {

    @Bean(&lt;/span&gt;&quot;person&quot;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;给容器中注册一个Bean;类型为返回值的类型；id默认是方法名作为id&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Person person(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Person(&quot;Alan&quot;,18&lt;span&gt;);
    }


    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
    * @Conditional() 按照条件注册
    *
    * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Conditional({BrianCondition.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;})
    @Bean(&lt;/span&gt;&quot;person01&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Person person01() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Person(&quot;Brian&quot;,17&lt;span&gt;);
    }

    @Conditional({BrianCondition.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;})
    @Bean(&lt;/span&gt;&quot;person02&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Person person02() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Person(&quot;wenTao&quot;,19&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
    *
    *给容器中注册组件
    * 1，包扫描+ 组件标注注解（@Controller/@Service/@Repository/@Component）[自己写的方法]
    * 2， @Bean [导入的第三方包里面的组件]
    * 3，@Import [快速的给容器导入一个组件]
    *       1.@Import(要导入的组件class)
    *       2.ImportSelector：返回需要导入的组件的全类名数组
    *       3.ImportBeanDefinitionRegistrar: 手动注册bean到容器
    *  4. 使用Spring提供的FactoryBean
    * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; BrianBeanFactory brianBeanFactory() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BrianBeanFactory();
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;加上测试类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MainTest {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
         ApplicationContext acac &lt;/span&gt;=
                 &lt;span&gt;new&lt;/span&gt; AnnotationConfigApplicationContext(MainConfig.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; ApplicationContext acac =
                 new AnnotationConfigApplicationContext(MainConfigOfLifeCycle.class);&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        System.out.println(&lt;/span&gt;&quot;ioc容器创建成功&quot;&lt;span&gt;);
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  Alan alan1 =  acac.getBean(Alan.class);
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Alan alan2 =  acac.getBean(Alan.class);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;System.out.println(&quot;比较两个Alan实例: &quot; + (alan1 == alan2));&lt;/span&gt;
        Person person1 = (Person) acac.getBean(&quot;person01&quot;&lt;span&gt;);
        System.out.println(&lt;/span&gt;&quot;---main---test---person1---: &quot; +&lt;span&gt; person1.toString());
        Person person2 &lt;/span&gt;= (Person) acac.getBean(&quot;person02&quot;&lt;span&gt;);
        System.out.println(&lt;/span&gt;&quot;---main---test---person2---: &quot; +&lt;span&gt; person2.toString());


        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭ioc容器&lt;/span&gt;
&lt;span&gt;        ((AnnotationConfigApplicationContext) acac).close();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;你会发现控制台可以获取到对象person01和person02的信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1051005/201906/1051005-20190627073049520-1058040564.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我这边再做一个matches发返回false的测试，亦即修改BrianCondition类的matches返回值为false,可以下面的测试结果：NoSuchBeanDefinitionException: No bean named 'person01' available。所i以根据上面我们测试的接口可以知道@Conditional注解的使用也是简单的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1051005/201906/1051005-20190627073552543-307029361.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2.@Import注解快速注入第三方bean对象&lt;/h3&gt;
&lt;p&gt;通过@Import可以快速的导入依赖的bean对象，比如我们在配置类上导入其他类@Import({Brian.class,Alan.class})&lt;/p&gt;
&lt;p&gt;configure配置类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
@Configuration &lt;span&gt;//&lt;/span&gt;&lt;span&gt;告诉spring这是一个配置类&lt;/span&gt;&lt;span&gt;
/*&lt;/span&gt;&lt;span&gt;
* @ComponentScan
*   value:只当于扫描的的包
*   excludeFilters = 指定扫描的时候按照什么规则排除哪些组件
*   includeFilters = 指定扫描的时候只需要包含哪些组件
*   Filter.ANNOTATION:按照注解
*   Filter.ASSIGNABLE_TYPE: 按照给定的类型
* &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

@ComponentScans(value &lt;/span&gt;=&lt;span&gt; {
        @ComponentScan(value &lt;/span&gt;= &quot;com.brian&quot;,includeFilters =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                @ComponentScan.Filter(type = FilterType.ANNOTATION,classes = {Controller.class}),
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                @ComponentScan.Filter(type=FilterType.ASSIGNABLE_TYPE,classes = {BookService.class}),&lt;/span&gt;
                @ComponentScan.Filter(type = FilterType.CUSTOM,classes = {BrianTypeFilter.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;})
        },useDefaultFilters &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
})
@Import({Brian.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;,Alan.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;})
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;@Import({BrianSelector.class})&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MainConfig {

    @Bean(&lt;/span&gt;&quot;person&quot;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;给容器中注册一个Bean;类型为返回值的类型；id默认是方法名作为id&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Person person(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Person(&quot;Alan&quot;,18&lt;span&gt;);
    }


    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
    * @Conditional() 按照条件注册
    *
    * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Conditional({BrianCondition.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;})
    @Bean(&lt;/span&gt;&quot;person01&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Person person01() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Person(&quot;Brian&quot;,17&lt;span&gt;);
    }

    @Conditional({BrianCondition.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;})
    @Bean(&lt;/span&gt;&quot;person02&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Person person02() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Person(&quot;wenTao&quot;,19&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
    *
    *给容器中注册组件
    * 1，包扫描+ 组件标注注解（@Controller/@Service/@Repository/@Component）[自己写的方法]
    * 2， @Bean [导入的第三方包里面的组件]
    * 3，@Import [快速的给容器导入一个组件]
    *       1.@Import(要导入的组件class)
    *       2.ImportSelector：返回需要导入的组件的全类名数组
    *       3.ImportBeanDefinitionRegistrar: 手动注册bean到容器
    *  4. 使用Spring提供的FactoryBean
    * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; BrianBeanFactory brianBeanFactory() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BrianBeanFactory();
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre readability=&quot;17&quot;&gt;
public class MainTest {&lt;br/&gt;public static void main(String[] args) {&lt;br/&gt;ApplicationContext acac =&lt;br/&gt;new AnnotationConfigApplicationContext(MainConfig.class);&lt;p&gt;/* ApplicationContext acac =&lt;br/&gt;new AnnotationConfigApplicationContext(MainConfigOfLifeCycle.class);*/&lt;br/&gt;System.out.println(&quot;ioc容器创建成功&quot;);&lt;br/&gt;Alan alan1 =  acac.getBean(Alan.class);&lt;br/&gt;System.out.println(&quot;--ALAN--:&quot; + alan1);&lt;br/&gt;// Alan alan2 =  acac.getBean(Alan.class);&lt;br/&gt;//System.out.println(&quot;比较两个Alan实例: &quot; + (alan1 == alan2));&lt;/p&gt;&lt;p&gt;//        Person person1 = (Person) acac.getBean(&quot;person01&quot;);&lt;br/&gt;//        System.out.println(&quot;---main---test---person1---: &quot; + person1.toString());&lt;br/&gt;//        Person person2 = (Person) acac.getBean(&quot;person02&quot;);&lt;br/&gt;//        System.out.println(&quot;---main---test---person2---: &quot; + person2.toString());&lt;/p&gt;&lt;p&gt;//        MathCalculator mathCalculator = (MathCalculator) acac.getBean(&quot;mathCalculator&quot;);&lt;br/&gt;//        System.out.println(&quot;----get--mathCalculator---: &quot; + mathCalculator);&lt;/p&gt;&lt;p&gt;//关闭ioc容器&lt;br/&gt;((AnnotationConfigApplicationContext) acac).close();&lt;br/&gt;}&lt;br/&gt;}
&lt;/p&gt;&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1051005/201906/1051005-20190627204357850-6247364.png&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;
&lt;p&gt; @Import上面的使用方式属于静态的导入依赖，当然Import注解还有一种动态导入第三组件的方式是和ImportSelector结合使用&lt;/p&gt;
&lt;p&gt;比如我在这里MainConfig配置类上通过Import注解导入BrianSelector类.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
@Configuration &lt;span&gt;//&lt;/span&gt;&lt;span&gt;告诉spring这是一个配置类&lt;/span&gt;&lt;span&gt;
/*&lt;/span&gt;&lt;span&gt;
* @ComponentScan
*   value:只当于扫描的的包
*   excludeFilters = 指定扫描的时候按照什么规则排除哪些组件
*   includeFilters = 指定扫描的时候只需要包含哪些组件
*   Filter.ANNOTATION:按照注解
*   Filter.ASSIGNABLE_TYPE: 按照给定的类型
* &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

@ComponentScans(value &lt;/span&gt;=&lt;span&gt; {
        @ComponentScan(value &lt;/span&gt;= &quot;com.brian&quot;,includeFilters =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                @ComponentScan.Filter(type = FilterType.ANNOTATION,classes = {Controller.class}),
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                @ComponentScan.Filter(type=FilterType.ASSIGNABLE_TYPE,classes = {BookService.class}),&lt;/span&gt;
                @ComponentScan.Filter(type = FilterType.CUSTOM,classes = {BrianTypeFilter.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;})
        },useDefaultFilters &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
})
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;@Import({Brian.class,Alan.class})&lt;/span&gt;
@Import({BrianSelector.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;})
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MainConfig {

    @Bean(&lt;/span&gt;&quot;person&quot;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;给容器中注册一个Bean;类型为返回值的类型；id默认是方法名作为id&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Person person(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Person(&quot;Alan&quot;,18&lt;span&gt;);
    }


    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
    * @Conditional() 按照条件注册
    *
    * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Conditional({BrianCondition.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;})
    @Bean(&lt;/span&gt;&quot;person01&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Person person01() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Person(&quot;Brian&quot;,17&lt;span&gt;);
    }

    @Conditional({BrianCondition.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;})
    @Bean(&lt;/span&gt;&quot;person02&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Person person02() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Person(&quot;wenTao&quot;,19&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
    *
    *给容器中注册组件
    * 1，包扫描+ 组件标注注解（@Controller/@Service/@Repository/@Component）[自己写的方法]
    * 2， @Bean [导入的第三方包里面的组件]
    * 3，@Import [快速的给容器导入一个组件]
    *       1.@Import(要导入的组件class)
    *       2.ImportSelector：返回需要导入的组件的全类名数组
    *       3.ImportBeanDefinitionRegistrar: 手动注册bean到容器
    *  4. 使用Spring提供的FactoryBean
    * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; BrianBeanFactory brianBeanFactory() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BrianBeanFactory();
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;BrianSelector类，该类实现了ImportSelector接口，通过实现selectImports方法，返回需要动态导入到IOC容器的其他的配置类的全量类名&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
* 自定义返回需要导入的组件
* &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BrianSelector &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; ImportSelector {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; importingClassMetadata 当前被标记有@Import注解的所有注解信息
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String[] selectImports(AnnotationMetadata importingClassMetadata) {

        System.out.println(&lt;/span&gt;&quot;----ImportSelector----:&quot;+&lt;span&gt;importingClassMetadata.getClassName());
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;return new String[]{};&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; String[]{MainConfigOfAOP.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.getName()};
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;MainConfigOfAOP配置类有注入MathCalculator对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Configuration
ublic &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MainConfigOfAOP {

    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; MathCalculator mathCalculator()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MathCalculator();
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试类，主要测试在IOC容器中获取MathCalculator类的信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MainTest {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
         ApplicationContext acac &lt;/span&gt;=
                 &lt;span&gt;new&lt;/span&gt; AnnotationConfigApplicationContext(MainConfig.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; ApplicationContext acac =
                 new AnnotationConfigApplicationContext(MainConfigOfLifeCycle.class);&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        System.out.println(&lt;/span&gt;&quot;ioc容器创建成功&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;         Alan alan1 =  acac.getBean(Alan.class);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        System.out.println(&quot;--ALAN--:&quot; + alan1);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Alan alan2 =  acac.getBean(Alan.class);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;System.out.println(&quot;比较两个Alan实例: &quot; + (alan1 == alan2));

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        Person person1 = (Person) acac.getBean(&quot;person01&quot;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        System.out.println(&quot;---main---test---person1---: &quot; + person1.toString());
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        Person person2 = (Person) acac.getBean(&quot;person02&quot;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        System.out.println(&quot;---main---test---person2---: &quot; + person2.toString());&lt;/span&gt;
&lt;span&gt;

        MathCalculator mathCalculator &lt;/span&gt;= (MathCalculator) acac.getBean(&quot;mathCalculator&quot;&lt;span&gt;);
        System.out.println(&lt;/span&gt;&quot;----get--mathCalculator---: &quot; +&lt;span&gt; mathCalculator);


        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭ioc容器&lt;/span&gt;
&lt;span&gt;        ((AnnotationConfigApplicationContext) acac).close();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1051005/201906/1051005-20190627225649928-1571719419.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里简单的扩展下@Import注解和@Bean注解异同点&lt;br/&gt;1.都是导入的外部的Jar包&lt;br/&gt;2.@Import的bean id是当前完整路径地址注册到IOC容器，@Bean的bean id是以方法名注册到IOC容器，相比来说@Import注入类更加简单&lt;/p&gt;
&lt;h3&gt;3.@EnableXXXX 开启原理&lt;/h3&gt;
&lt;p&gt;enable字面意思启动，亦即开关的概念，有@EnableXXXX注解的地方，基本会看到@Import这个注解，一般他们都是结合起来使用的&lt;/p&gt;
&lt;p&gt;比如看到我代码里面的MainConfigOfAutowired这个配置类，上有加上@EnableTransactionManagement这个注解，亦即打开事务管理&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 自动装配
 *   Spring利用依赖注入(DI),完成对IOC容器中各个组件的依赖关系赋值
 *1).@Autowired，自动注入：
 *      1.默认优先按照类型去容器中找对应的组件：applicationContext.getBean(BookDao.class);
 *      2.如果找到多个相同类型的组件，再将属性方法的名称作为组件的id去容器中查找
 *                          applicationContext.getBean(&quot;bookDao&quot;);
 *      3.@Qualifier(&quot;bookDao&quot;):使用@Qualifier指定需要装配的组件id,而不是使用属性名
 *      4.自动装配默认一定要将属性赋值好，没有就会报错
 *              使用@Autoeired(required=false),没有默认值也不会报错
 *      5.@Primary, 让Spring进行自动装配的时候，默认使用首先的Bean
 *
 * 2).Spring还支持使用@Resource(JSR250)和@Inject(JSR330) [java规范的注解]
 * 3）.@Autowired :构造器，参数，方法，属性，
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@EnableAspectJAutoProxy        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开启AOP代理自动配置&lt;/span&gt;
@EnableTransactionManagement   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;基于注解的事务管理
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;@ComponentScan(value = {&quot;com.brian.bean&quot;,&quot;com.write.annotation&quot;})&lt;/span&gt;
@ComponentScan(value = {&quot;com.write.annotation.transaction&quot;&lt;span&gt;})
@Configuration
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MainConfigOfAutowired {

        @Bean
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DataSource dataSource() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; PropertyVetoException {
            ComboPooledDataSource dataSource &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ComboPooledDataSource();
            dataSource.setJdbcUrl(&lt;/span&gt;&quot;jdbc:mysql://remotemysql.com:3306/khgvUiO4eh&quot;&lt;span&gt;);
        &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们再看看@EnableTransactionManagement的代码，通过Import快速导入TransactionManagementConfigurationSelector&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Retention(RetentionPolicy.RUNTIME)
@Documented
@Import(TransactionManagementConfigurationSelector.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; EnableTransactionManagement {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Indicate whether subclass-based (CGLIB) proxies are to be created ({&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; true}) as
     * opposed to standard Java interface-based proxies ({&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; false}). The default is
     * {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; false}. &amp;lt;strong&amp;gt;Applicable only if {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #mode()} is set to
     * {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; AdviceMode#PROXY}&amp;lt;/strong&amp;gt;.
     * &amp;lt;p&amp;gt;Note that setting this attribute to {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; true} will affect &amp;lt;em&amp;gt;all&amp;lt;/em&amp;gt;
     * Spring-managed beans requiring proxying, not just those marked with
     * {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; @Transactional}. For example, other beans marked with Spring's
     * {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; @Async} annotation will be upgraded to subclass proxying at the same
     * time. This approach has no negative impact in practice unless one is explicitly
     * expecting one type of proxy vs another, e.g. in tests.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;boolean&lt;/span&gt; proxyTargetClass() &lt;span&gt;default&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Indicate how transactional advice should be applied.
     * &amp;lt;p&amp;gt;&amp;lt;b&amp;gt;The default is {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; AdviceMode#PROXY}.&amp;lt;/b&amp;gt;
     * Please note that proxy mode allows for interception of calls through the proxy
     * only. Local calls within the same class cannot get intercepted that way; an
     * {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; Transactional} annotation on such a method within a local call will be
     * ignored since Spring's interceptor does not even kick in for such a runtime
     * scenario. For a more advanced mode of interception, consider switching this to
     * {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; AdviceMode#ASPECTJ}.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    AdviceMode mode() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; AdviceMode.PROXY;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Indicate the ordering of the execution of the transaction advisor
     * when multiple advices are applied at a specific joinpoint.
     * &amp;lt;p&amp;gt;The default is {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; Ordered#LOWEST_PRECEDENCE}.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; order() &lt;span&gt;default&lt;/span&gt;&lt;span&gt; Ordered.LOWEST_PRECEDENCE;

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们再点进去看看TransactionManagementConfigurationSelector这个类，会发现selectImports会根据条件，选择不同的配置类，所以这就是为什么说ImportSelector可以动态加载其他配置类了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; TransactionManagementConfigurationSelector &lt;span&gt;extends&lt;/span&gt; AdviceModeImportSelector&amp;lt;EnableTransactionManagement&amp;gt;&lt;span&gt; {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Returns {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; ProxyTransactionManagementConfiguration} or
     * {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; AspectJ(Jta)TransactionManagementConfiguration} for {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; PROXY}
     * and {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; ASPECTJ} values of {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; EnableTransactionManagement#mode()},
     * respectively.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; String[] selectImports(AdviceMode adviceMode) {
        &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (adviceMode) {
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; PROXY:
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; String[] {AutoProxyRegistrar.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.getName(),
                        ProxyTransactionManagementConfiguration.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.getName()};
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; ASPECTJ:
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; String[] {determineTransactionAspectClass()};
            &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String determineTransactionAspectClass() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (ClassUtils.isPresent(&quot;javax.transaction.Transactional&quot;, getClass().getClassLoader()) ?&lt;span&gt;
                TransactionManagementConfigUtils.JTA_TRANSACTION_ASPECT_CONFIGURATION_CLASS_NAME :
                TransactionManagementConfigUtils.TRANSACTION_ASPECT_CONFIGURATION_CLASS_NAME);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;4.基于ImportBeanDefinitionRegistrar注册bean&lt;/h3&gt;
&lt;p&gt;再回到MainConfigOfAOP这个配置类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 *  AOP: [动态代理]
 *      指在程序运行时期间将某段代码切入到指定方法指定位置执行的编程方式
 *
 *      1.将业务逻辑类和切面类注入到容器中（加上@Aspect注解表示切面类 ）
 *      2.在切面类上的每个通知方法注解上注解，定义好切点
 *      3.开启基于注解的AOP模式: @EnableAspectAutoProxy
 *
 *
 * AOP 原理：
 * @EnableAspectJAutoProxy
 *      @Import(AspectJAutoProxyRegistrar.class) 给容器中导入AspectJAutoProxyRegistrar类
 *          利用AspectJAutoProxyRegistrar自定义向容器中注册bean
 *               AnnotationAwareAspectJAutoProxyCreator
 *                  -&amp;gt;AspectJAwareAdvisorAutoProxyCreator
 *                      -&amp;gt;AbstractAdvisorAutoProxyCreator
 *                          -&amp;gt;AbstractAutoProxyCreator
 *                              implements SmartInstantiationAwareBeanPostProcessor, BeanFactoryAware
 *                              后置处理器（在bean初始化完成前后执行） ，自动装配BeanFactory
 *
 *
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Configuration
@EnableAspectJAutoProxy
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MainConfigOfAOP {

    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; MathCalculator mathCalculator()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MathCalculator();
    }

    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; LogAspects logAspects() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LogAspects();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面通过@EnableAspectJAutoProxy开启基于注解的AOP模式，我们点进去看看，又是熟悉的@Import注解&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Import(AspectJAutoProxyRegistrar.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; EnableAspectJAutoProxy {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Indicate whether subclass-based (CGLIB) proxies are to be created as opposed
     * to standard Java interface-based proxies. The default is {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; false}.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;boolean&lt;/span&gt; proxyTargetClass() &lt;span&gt;default&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Indicate that the proxy should be exposed by the AOP framework as a {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; ThreadLocal}
     * for retrieval via the {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; org.springframework.aop.framework.AopContext} class.
     * Off by default, i.e. no guarantees that {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; AopContext} access will work.
     * &lt;/span&gt;&lt;span&gt;@since&lt;/span&gt;&lt;span&gt; 4.3.1
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;boolean&lt;/span&gt; exposeProxy() &lt;span&gt;default&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们再点进去看看AspectJAutoProxyRegistrar这个类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt; AspectJAutoProxyRegistrar &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; ImportBeanDefinitionRegistrar {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Register, escalate, and configure the AspectJ auto proxy creator based on the value
     * of the @{&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; EnableAspectJAutoProxy#proxyTargetClass()} attribute on the importing
     * {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; @Configuration} class.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; registerBeanDefinitions(
            AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {

        AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);

        AnnotationAttributes enableAspectJAutoProxy &lt;/span&gt;=&lt;span&gt;
                AnnotationConfigUtils.attributesFor(importingClassMetadata, EnableAspectJAutoProxy.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (enableAspectJAutoProxy != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (enableAspectJAutoProxy.getBoolean(&quot;proxyTargetClass&quot;&lt;span&gt;)) {
                AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (enableAspectJAutoProxy.getBoolean(&quot;exposeProxy&quot;&lt;span&gt;)) {
                AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);
            }
        }
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;你会发现该类通过实现ImportBeanDefinitionRegistrar接口的registerBeanDefinitions的方法，最终通过AopConfigUtil工具类来注册到容器中&lt;/p&gt;
&lt;h3&gt;5.基于FactoryBean注册bean对象&lt;/h3&gt;
&lt;p&gt; 再次回到我的MainConfig这个配置类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
@Configuration &lt;span&gt;//&lt;/span&gt;&lt;span&gt;告诉spring这是一个配置类&lt;/span&gt;&lt;span&gt;
/*&lt;/span&gt;&lt;span&gt;
* @ComponentScan
*   value:只当于扫描的的包
*   excludeFilters = 指定扫描的时候按照什么规则排除哪些组件
*   includeFilters = 指定扫描的时候只需要包含哪些组件
*   Filter.ANNOTATION:按照注解
*   Filter.ASSIGNABLE_TYPE: 按照给定的类型
* &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

@ComponentScans(value &lt;/span&gt;=&lt;span&gt; {
        @ComponentScan(value &lt;/span&gt;= &quot;com.brian&quot;,includeFilters =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                @ComponentScan.Filter(type = FilterType.ANNOTATION,classes = {Controller.class}),
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                @ComponentScan.Filter(type=FilterType.ASSIGNABLE_TYPE,classes = {BookService.class}),&lt;/span&gt;
                @ComponentScan.Filter(type = FilterType.CUSTOM,classes = {BrianTypeFilter.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;})
        },useDefaultFilters &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
})
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;@Import({Brian.class,Alan.class})&lt;/span&gt;
@Import({BrianSelector.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;})
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MainConfig {

    @Bean(&lt;/span&gt;&quot;person&quot;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;给容器中注册一个Bean;类型为返回值的类型；id默认是方法名作为id&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Person person(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Person(&quot;Alan&quot;,18&lt;span&gt;);
    }


    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
    * @Conditional() 按照条件注册
    *
    * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Conditional({BrianCondition.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;})
    @Bean(&lt;/span&gt;&quot;person01&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Person person01() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Person(&quot;Brian&quot;,17&lt;span&gt;);
    }

    @Conditional({BrianCondition.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;})
    @Bean(&lt;/span&gt;&quot;person02&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Person person02() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Person(&quot;wenTao&quot;,19&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
    *
    *给容器中注册组件
    * 1，包扫描+ 组件标注注解（@Controller/@Service/@Repository/@Component）[自己写的方法]
    * 2， @Bean [导入的第三方包里面的组件]
    * 3，@Import [快速的给容器导入一个组件]
    *       1.@Import(要导入的组件class)
    *       2.ImportSelector：返回需要导入的组件的全类名数组
    *       3.ImportBeanDefinitionRegistrar: 手动注册bean到容器
    *  4. 使用Spring提供的FactoryBean
    * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; BrianBeanFactory brianBeanFactory() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BrianBeanFactory();
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过@Bean注解注入BrianBeanFactory，我们点进去看看&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BrianBeanFactory  &lt;span&gt;implements&lt;/span&gt; FactoryBean&amp;lt;WenTao&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取对象&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; WenTao getObject() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; WenTao();
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取对象的类型&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; Class&amp;lt;?&amp;gt;&lt;span&gt; getObjectType() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; WenTao.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;;
    }
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取对象是单例模式还是原型模式&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isSingleton() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;BrianBeanFactoryt通过实现了BeanFactory接口的getObject()获取到bean对象&lt;/p&gt;
&lt;p&gt;上测试类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MainTest {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
         ApplicationContext acac &lt;/span&gt;=
                 &lt;span&gt;new&lt;/span&gt; AnnotationConfigApplicationContext(MainConfig.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; ApplicationContext acac =
                 new AnnotationConfigApplicationContext(MainConfigOfLifeCycle.class);&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        System.out.println(&lt;/span&gt;&quot;ioc容器创建成功&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;         Alan alan1 =  acac.getBean(Alan.class);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        System.out.println(&quot;--ALAN--:&quot; + alan1);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Alan alan2 =  acac.getBean(Alan.class);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;System.out.println(&quot;比较两个Alan实例: &quot; + (alan1 == alan2));

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        Person person1 = (Person) acac.getBean(&quot;person01&quot;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        System.out.println(&quot;---main---test---person1---: &quot; + person1.toString());
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        Person person2 = (Person) acac.getBean(&quot;person02&quot;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        System.out.println(&quot;---main---test---person2---: &quot; + person2.toString());


       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; MathCalculator mathCalculator = (MathCalculator) acac.getBean(&quot;mathCalculator&quot;);
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; System.out.println(&quot;----get--mathCalculator---: &quot; + mathCalculator);&lt;/span&gt;
&lt;span&gt;
        BrianBeanFactory beanFactory &lt;/span&gt;= acac.getBean(BrianBeanFactory.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        WenTao wentao &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            wentao &lt;/span&gt;=&lt;span&gt; beanFactory.getObject();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            e.printStackTrace();
        }
        System.out.println(&lt;/span&gt;&quot;----get--WenTao---: &quot; +&lt;span&gt; wentao);


        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭ioc容器&lt;/span&gt;
&lt;span&gt;        ((AnnotationConfigApplicationContext) acac).close();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1051005/201906/1051005-20190628000139910-322729058.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里拓展一点FactoryBean和 BeanFactory的区别，FactoryBean是创建bean对象，BeanFactory是获取bean对象。&lt;/p&gt;

&lt;h4&gt;最后说一下，我的博客可能不是首创，但也属于我自己根据自己理解一点点分析的，如果有帮助到你，转载请注明出处！ &lt;/h4&gt;
</description>
<pubDate>Thu, 27 Jun 2019 16:10:00 +0000</pubDate>
<dc:creator>Brian_Huang</dc:creator>
<og:description>代码地址：https://github.com/showkawa/spring-annotation/tree/master/src/main/java/com/brian 1.源码分析二主要分析的内</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hlkawa/p/11088129.html</dc:identifier>
</item>
<item>
<title>[NewLife.XCode]导入导出（实体对象百变魔君） - 大石头</title>
<link>http://www.cnblogs.com/nnhy/p/xcode_import_export.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nnhy/p/xcode_import_export.html</guid>
<description>&lt;p&gt;NewLife.XCode是一个有10多年历史的开源数据中间件，支持nfx/netcore，由新生命团队(2002~2019)开发完成并维护至今，以下简称XCode。&lt;/p&gt;
&lt;p&gt;整个系列教程会大量结合示例代码和运行日志来进行深入分析，蕴含多年开发经验于其中，代表作有百亿级大数据实时计算项目。&lt;/p&gt;
&lt;p&gt;开源地址：&lt;a href=&quot;https://github.com/NewLifeX/X&quot; target=&quot;_blank&quot;&gt;https://github.com/NewLifeX/X &lt;/a&gt;（求star, 864+）&lt;/p&gt;

&lt;p&gt;XCode是充血模型，在实体类上附带有大量便捷操作，其中就包括各种目标数据类型的导入导出！&lt;/p&gt;


&lt;p&gt; 当下最常用的数据通信格式毋容置疑肯定是Json，实体对象可直接转Json作为接口返回值。&lt;/p&gt;
&lt;p&gt;下面看看一个普通Role实体对象的Json序列化（ToJson）和Json反序列化（ToJsonEntity）的例程和效果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/19592/201906/19592-20190627220914899-450192951.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上，Role实体对象可通过ToJson转为json字符串，并通过ToJsonEntity把字符串转为另一个Role实体对象。&lt;/p&gt;
&lt;p&gt;在XCode v9.0之前，实体基类Entity直接带有ToJson/FromJson。后来因为Json实在太常用了，提升为全局扩展方法。&lt;/p&gt;

&lt;p&gt;Json作为最通用的数据传输格式（没有之一），ToJson直接扩展Object，有三个参数：是否换行缩进、是否写空值、是否驼峰命名&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/19592/201906/19592-20190627221618117-1061340512.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上文示例中的ToJson(true, false, false)表示采用换行缩进（可读性更好），不写空值（整数的0和字符串的null等），不适用驼峰命名。&lt;/p&gt;


&lt;p&gt; Xml作为曾经的数据传输格式之王，仍然有相当一部分古老接口使用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/19592/201906/19592-20190627223420747-1548190033.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ToXml/ToXmlEntity 也是全局扩展方法，其中参数可以控制序列化为普通Xml或者Xml属性。&lt;/p&gt;
&lt;p&gt;从结果来看，Xml可读性非常好，但是占用空间很大，一般比Json还要大一截。&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt; XCode序列化的绝招是二进制序列化，能够让实体对象和二进制数据互相转换，更小、更快！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/19592/201906/19592-20190627224236157-1614882804.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;序列化同样的实体对象，只需要39字节，远小于Json和Xml，并且速度更快（不需要字符串分割操作）。&lt;/p&gt;
&lt;p&gt;实体对象没有ToBinary之类的快速方法，而是需要先转化为IAccessor接口，然后Write序列化为数据流，或者Read读取数据流。&lt;/p&gt;
&lt;p&gt;数据流是个好东西，最常用的有内存流、文件流、网络流、加密流、压缩流，等等等。&lt;/p&gt;
&lt;p&gt;文件流FileStream，可以让实体对象保存为文件，或者文件加载为实体对象，（借助文件缓存实体数据？）；&lt;/p&gt;
&lt;p&gt;网络流NetworkStream，可以让实体对象在网络中传输；&lt;/p&gt;

&lt;p&gt;IAccessor 访问器接口，可实现任意对象到数据流的读写访问。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/NewLifeX/NewLife.Redis&quot; target=&quot;_blank&quot;&gt;NewLife.Redis&lt;/a&gt; 优先支持 IAccessor 接口，因此，&lt;strong&gt;&lt;span&gt;把XCode实体对象写入Redis时，采用的是二进制高效精简格式，而不是默认的Json格式&lt;/span&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;实体类可通过重载 OnWrite 来自定义二进制序列化的行为。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;&lt;span&gt;二进制序列化到数据流&lt;/span&gt;&lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;stream&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;数据流&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;context&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;上下文&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;extend&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;是否序列化扩展属性&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt;&lt;span&gt; Boolean OnWrite(Stream stream, Object context, Boolean extend)
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; bn = context &lt;span&gt;as&lt;/span&gt;&lt;span&gt; Binary;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (bn == &lt;span&gt;null&lt;/span&gt;) bn = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Binary
    {
        Stream &lt;/span&gt;=&lt;span&gt; stream,
        EncodeInt &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
    };

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; fs = extend ?&lt;span&gt; Meta.AllFields : Meta.Fields;
    &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; fi &lt;span&gt;in&lt;/span&gt;&lt;span&gt; fs)
    {
        bn.Write(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;[fi.Name], fi.Type);
    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从上面代码可以看出，只是调用二进制序列化Binary来把各个数据字段写入流中。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;看到这里，你是不是有很多可以大干一场的想法？别急，这只是开胃菜，还有更好的。&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;示例中看到，二进制序列化最大缺点是可读性极差！一般只能看到其中部分字符串。&lt;/p&gt;


&lt;p&gt; 单个实体对象的二进制序列化只适用于简单场合，如写入Redis，实际工程级应用，多以实体列表为主。&lt;/p&gt;
&lt;p&gt;实体列表存储以扩展方法提供：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Write，写入实体列表到数据流&lt;/li&gt;
&lt;li&gt;Read，从数据流加载实体列表&lt;/li&gt;
&lt;li&gt;SaveFile，保存实体列表到文件（可用作数据缓存）&lt;/li&gt;
&lt;li&gt;LoadFile，从文件加载实体列表&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/19592/201906/19592-20190627231235076-1562717744.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以上示例演示了具有4个对象的角色列表如果读写数据流以及文件。&lt;/p&gt;

&lt;p&gt; 有朋友要问，能否借助实体列表读写文件的功能，实现某些数据表的本地化缓存，即使数据库宕机，仍然能够继续提供服务？&lt;/p&gt;
&lt;p&gt;答案显然是可以的，并且我在实际工作中也经常这么干。&lt;/p&gt;

&lt;p&gt;数据分析中经常需要用到几十上百台服务器进行分析计算，应用启动时必须把配置数据和常用基础数据一次性载入内存，例如几万行的网点数据；&lt;/p&gt;
&lt;p&gt;如果几十个节点同时启动向数据库请求网点数据，数据库将不堪重负变得非常缓慢，影响计算应用的加载甚至可能导致出错退出；&lt;/p&gt;
&lt;p&gt;这种场景，可以在加载一次后，把实体列表数据保存到本地文件中，然后定时（10分钟）更新；&lt;/p&gt;
&lt;p&gt;下次启动时，直接使用本地缓存数据，大大提升了应用启动速度，并且降低了数据库负担；&lt;/p&gt;


&lt;p&gt; Csv格式常用于办公室Excel数据传递，以及数据库数据导入导出等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/19592/201906/19592-20190627232403300-648490765.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/19592/201906/19592-20190627232519335-212424516.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/19592/201906/19592-20190627232549443-373989781.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;XCode支持百万级导出！内部 CsvFile 支持流式读写，一边构造一边写入文件，而不是一次性在内存生成好再写入！&lt;/p&gt;

&lt;p&gt;魔方的 Excel导出、Csv导出、Json导出、Xml导出等功能，都由 XCode 实现！&lt;/p&gt;


&lt;p&gt;NewLife.XCode教程系列[2019版]&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_curd.html&quot; target=&quot;_blank&quot;&gt;增删改查入门&lt;/a&gt;。快速展现用法，代码配置连接字符串&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_model.html&quot; target=&quot;_blank&quot;&gt;数据模型文件&lt;/a&gt;。建立表格字段和索引，名字以及数据类型规范，推荐字段（时间，用户，IP）&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_entity.html&quot; target=&quot;_blank&quot;&gt;实体类详解&lt;/a&gt;。数据类业务类，泛型基类，接口&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_setting.html&quot; target=&quot;_blank&quot;&gt;功能设置&lt;/a&gt;。连接字符串，调试开关，SQL日志，慢日志，参数化，执行超时。代码与配置文件设置，连接字符串局部设置&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_negative.html&quot; target=&quot;_blank&quot;&gt;反向工程&lt;/a&gt;。自动建立数据库数据表&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_initdata.html&quot; target=&quot;_blank&quot;&gt;数据初始化&lt;/a&gt;。InitData写入初始化数据&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_curd_adv.html&quot; target=&quot;_blank&quot;&gt;高级增删改&lt;/a&gt;。重载拦截，自增字段，Valid验证，实体模型（时间，用户，IP）&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_dirty.html&quot; target=&quot;_blank&quot;&gt;脏数据&lt;/a&gt;。如何产生，怎么利用&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_additional.html&quot; target=&quot;_blank&quot;&gt;增量累加&lt;/a&gt;。高并发统计&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_transaction.html&quot; target=&quot;_blank&quot;&gt;事务处理&lt;/a&gt;。单表和多表，不同连接，多种写法&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_extend.html&quot; target=&quot;_blank&quot;&gt;扩展属性&lt;/a&gt;。多表关联，Map映射&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_search.html&quot; target=&quot;_blank&quot;&gt;高级查询&lt;/a&gt;。复杂条件，分页，自定义扩展FieldItem，查总记录数，查汇总统计&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_dbcache.html&quot; target=&quot;_blank&quot;&gt;数据层缓存&lt;/a&gt;。Sql缓存，更新机制&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_entitycache.html&quot; target=&quot;_blank&quot;&gt;实体缓存&lt;/a&gt;。全表整理缓存，更新机制&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_singlecache.html&quot; target=&quot;_blank&quot;&gt;对象缓存&lt;/a&gt;。字典缓存，适用用户等数据较多场景。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_100billion.html&quot; target=&quot;_blank&quot;&gt;百亿级性能&lt;/a&gt;。字段精炼，索引完备，合理查询，充分利用缓存&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_factory.html&quot; target=&quot;_blank&quot;&gt;实体工厂&lt;/a&gt;。元数据，通用处理程序&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_membership.html&quot; target=&quot;_blank&quot;&gt;角色权限&lt;/a&gt;。Membership&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_import_export.html&quot; target=&quot;_blank&quot;&gt;导入导出&lt;/a&gt;。Xml，Json，二进制，网络或文件&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_division.html&quot; target=&quot;_blank&quot;&gt;分表分库&lt;/a&gt;。常见拆分逻辑&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_stat.html&quot; target=&quot;_blank&quot;&gt;高级统计&lt;/a&gt;。聚合统计，分组统计&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_batch.html&quot; target=&quot;_blank&quot;&gt;批量写入&lt;/a&gt;。批量插入，批量Upsert，异步保存&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_queue.html&quot; target=&quot;_blank&quot;&gt;实体队列&lt;/a&gt;。写入级缓存，提升性能。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_backup.html&quot; target=&quot;_blank&quot;&gt;备份同步&lt;/a&gt;。备份数据，恢复数据，同步数据&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_service.html&quot; target=&quot;_blank&quot;&gt;数据服务&lt;/a&gt;。提供RPC接口服务，远程执行查询，例如SQLite网络版&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_bigdata.html&quot; target=&quot;_blank&quot;&gt;大数据分析&lt;/a&gt;。ETL抽取，调度计算处理，结果持久化 &lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Thu, 27 Jun 2019 15:29:00 +0000</pubDate>
<dc:creator>大石头</dc:creator>
<og:description>XCode是充血模型，在实体类上附带有大量便捷操作，其中就包括各种目标数据类型的导入导出！</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/nnhy/p/xcode_import_export.html</dc:identifier>
</item>
</channel>
</rss>