<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>【输入法】Rime-中州韵 基本设置 附：官方定制指南 - 东北小狐狸</title>
<link>http://www.cnblogs.com/hellxz/p/10198540.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hellxz/p/10198540.html</guid>
<description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;不知不觉就到了年终了，距离上次更新博客已经有一个半月，这段时间天天在加班，也没作一下新的学习计划，趁着元旦放假，写一点好玩的东西，这次要记录的是一点关于Rime相关的东西，文章本身不会长，只是说一点平时比较好用的设置，为了方便查阅，文末贴上&lt;strong&gt;定制指南&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;本文内容&quot;&gt;本文内容&lt;/h3&gt;
&lt;p&gt;基于上一篇&lt;a href=&quot;https://www.cnblogs.com/hellxz/p/9091151.html&quot;&gt;「简记」 Linux安装五笔输入法，包含arch和debian系&lt;/a&gt;的基础上安装好Rime，本文要记录的是设置几个实用的快捷键功能，顺便搬运来一些Rime的设置，大家有兴趣可以跟着本文设置玩玩。&lt;/p&gt;
&lt;h3 id=&quot;正文&quot;&gt;正文&lt;/h3&gt;
&lt;p&gt;就记两条最常用的设置吧，Rime是使用yaml配置的，不熟悉的请百度下了解大体概念&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;设置分号选第二候选词，引号选第三候选词&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这里使用ibus-rime举例，执行&lt;code&gt;cd ~/.config/ibus/rime&lt;/code&gt;进入用户家目录的设置位置，如图，之后的设置都在这里&lt;img src=&quot;https://img2018.cnblogs.com/blog/1149398/201812/1149398-20181229234105189-741987506.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;当然也可以在共享文件夹中，详见&lt;code&gt;/usr/share/rime-data&lt;/code&gt;目录&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1149398/201812/1149398-20181229235044143-604389133.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这个文件夹下，我们看到了之前设置五笔的文件，和很多文件，这里我们只修改&lt;code&gt;default.yaml&lt;/code&gt;，打开这个文件，我们往下翻，看到&lt;code&gt;key_binder&lt;/code&gt;下级&lt;code&gt;bindings&lt;/code&gt;，如图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1149398/201812/1149398-20181229235453444-1117730325.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里我们到&lt;strong&gt;这个标签&lt;/strong&gt;最下方添加如下代码（注意缩进和冒号后面的空格）&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt; - {accept: semicolon, send: 2, when: has_menu}
 - {accept: apostrophe, send: 3, when: has_menu}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解释一下，accept后边第一个参数表示接收的按键代号（详见官网），send 表示发送的文字，这里后边设定了when即当这种has_menu有候选字出菜单的时候，发送第几个文字/词组，也可以设置一些字母，设置的效果，如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1149398/201812/1149398-20181229235648910-662424390.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这里vim设置了行号&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;保存设置，点击rime的状态栏上的图标，单击部署，完成配置的加载，功能实现&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1149398/201812/1149398-20181230001032464-697288173.png&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;四码、无重码自动上屏&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;打开&lt;code&gt;wubi86.schema.yaml&lt;/code&gt;，在第49行左右有个根标签名为speller，我们定位到这里，如图，添加代码&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;max_code_length: 4 # 最长4码
auto_select: true  # 顶字上屏
auto_select_unique_candidate: true # 无重码自动上屏&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1149398/201812/1149398-20181230001819210-697570840.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;保存设置，点部署。本文后续内容就不赘述这句了。&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;如果没有这个文件，可能是没有安装&lt;code&gt;librime-data-wubi&lt;/code&gt;，使用命令自行安装即可&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sudo apt-get install librime-data-wubi&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;当然了，不止是五笔，Rime支持很多输入法，大家可以参考设置&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;导入词库&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;发现已经有人写了，直接贴地址&lt;a href=&quot;http://www.cnblogs.com/sunjie21/p/3327221.html&quot;&gt;Rime中州韵导入QQ五笔词库&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;附：&lt;/p&gt;
&lt;h2 id=&quot;rime-定製指南&quot;&gt;Rime 定製指南&lt;/h2&gt;
&lt;h2 id=&quot;必知必會&quot;&gt;必知必會&lt;/h2&gt;
&lt;p&gt;建議您在定製 Rime 輸入法之前瞭解 Rime 輸入方案的概念、Rime 中的數據文件分佈及作用等基礎知識。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/rime/home/wiki/RimeWithSchemata&quot;&gt;必知必會&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;section&quot;/&gt;
&lt;h3 id=&quot;重新佈署的操作方法&quot;&gt;重新佈署的操作方法&lt;/h3&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;【中州韻】點擊輸入法狀態欄上的 ⟲ (Deploy) 按鈕 或：如果找不到狀態欄，在終端輸入以下命令，可觸發自動部署：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;rm ~/.config/ibus/rime/default.yaml; ibus-daemon -drx&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;【小狼毫】開始菜單→小狼毫輸入法→重新佈署；當開啓托盤圖標時，右鍵點選「重新佈署」&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;【鼠鬚管】在系統語言文字選單中選擇「重新佈署」&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;對設置的修改於重新佈署後生效。編譯新的輸入方案需要一段時間，此間若無法輸出中文，請稍等片刻。&lt;/p&gt;
&lt;p&gt;若部署完畢後，可以通過 Ctrl+` 喚出方案選單，輸入方案卻仍無法正常使用，可能是輸入方案未部署成功。請&lt;a href=&quot;https://github.com/rime/home/wiki/RimeWithSchemata#%E9%97%9C%E6%96%BC%E8%AA%BF%E8%A9%A6&quot;&gt;查看日誌文件&lt;/a&gt;定位錯誤。&lt;/p&gt;
&lt;h3 id=&quot;section-1&quot;/&gt;
&lt;h3 id=&quot;查閱-diy-處方集&quot;&gt;查閱 DIY 處方集&lt;/h3&gt;
&lt;p&gt;已將一些定製 Rime 的常見問題、解法及定製檔鏈接俱收錄於下文的〔DIY 處方集〕&lt;/p&gt;
&lt;h3 id=&quot;section-2&quot;/&gt;
&lt;h3 id=&quot;設定項速查手冊&quot;&gt;設定項速查手冊&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/LEOYoon-Tsaw/Rime_collections/blob/master/Rime_description.md&quot;&gt;雪齋的文檔&lt;/a&gt; 全面而詳細解釋了輸入方案及詞典中各設定項的含義及用法。&lt;/p&gt;
&lt;h2 id=&quot;section-3&quot;/&gt;
&lt;h2 id=&quot;定製指南&quot;&gt;定製指南&lt;/h2&gt;
&lt;p&gt;Rime 輸入方案，將 Rime 輸入法的設定整理成完善的、可分發的形式。 但並非一定要創作新的輸入方案，才可以改變 Rime 的行爲。&lt;/p&gt;
&lt;p&gt;當用戶需要對 Rime 中的各種設定做小幅的調節，最直接、但不完全正確的做法是：編輯用戶資料夾中那些 .yaml 文檔。&lt;/p&gt;
&lt;p&gt;這一方法有弊端：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;當 Rime 軟件升級時，也會升級各種設定檔、預設輸入方案。用戶編輯過的文檔會被覆寫爲更高版本，所做調整也便丟失了。&lt;/li&gt;
&lt;li&gt;即使在軟件升級後再手動恢復經過編輯的文件，也會因設定檔的其他部分未得到更新而失去本次升級新增和修復的功能。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;因此，對於隨 Rime 發行的設定檔及預設輸入方案，推薦的定製方法是：&lt;/p&gt;
&lt;p&gt;創建一個文件名的主體部份（「.」之前）與要定製的文件相同、次級擴展名（「.yaml」之前）爲 &lt;code&gt;.custom&lt;/code&gt; 的定製文檔：&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;patch:
  &quot;一級設定項/二級設定項/三級設定項&quot;: 新的設定值
  &quot;另一個設定項&quot;: 新的設定值
  &quot;再一個設定項&quot;: 新的設定值
  &quot;含列表的設定項/@n&quot;: 列表第n個元素新的設定值，從0開始計數
  &quot;含列表的設定項/@last&quot;: 列表最後一個元素新的設定值
  &quot;含列表的設定項/@before 0&quot;: 在列表第一個元素之前插入新的設定值（不建議在補靪中使用）
  &quot;含列表的設定項/@after last&quot;: 在列表最後一個元素之後插入新的設定值（不建議在補靪中使用）
  &quot;含列表的設定項/@next&quot;: 在列表最後一個元素之後插入新的設定值（不建議在補靪中使用）&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;就是這樣：&lt;code&gt;patch&lt;/code&gt; 定義了一組「補靪」，以源文件中的設定爲基礎，寫入新的設定項、或以新的設定值取代現有設定項的值。&lt;/p&gt;
&lt;p&gt;不懂？那看我來示範。&lt;/p&gt;
&lt;h3 id=&quot;section-4&quot;/&gt;
&lt;h3 id=&quot;一例定製每頁候選數&quot;&gt;一例、定製每頁候選數&lt;/h3&gt;
&lt;p&gt;Rime 中，默認每頁至多顯示 5 個候選項，而允許的範圍是 1〜9（個別 Rime 發行版可支持10個候選）。&lt;/p&gt;
&lt;p&gt;設定每頁候選個數的默認值爲 9，在用戶目錄建立文檔 &lt;code&gt;default.custom.yaml&lt;/code&gt; ：&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;patch:
  &quot;menu/page_size&quot;: 9&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重新佈署即可生效。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;〔注意〕&lt;/strong&gt; 如果 default.custom.yaml 裏面已經有其他設定內容，只要以相同的縮進方式添加 &lt;code&gt;patch:&lt;/code&gt; 以下的部分，不可重複 &lt;code&gt;patch:&lt;/code&gt; 這一行。&lt;/p&gt;
&lt;p&gt;若只需要將獨孤一個輸入方案的每頁候選數設爲 9，以【朙月拼音】爲例，建立文檔 &lt;code&gt;luna_pinyin.custom.yaml&lt;/code&gt; 寫入相同內容，重新佈署即可生效。&lt;/p&gt;
&lt;p&gt;註：請參閱前文「重新佈署的操作方法」★&lt;/p&gt;
&lt;h3 id=&quot;section-5&quot;/&gt;
&lt;h3 id=&quot;一例定製標點符號&quot;&gt;一例、定製標點符號&lt;/h3&gt;
&lt;p&gt;有的用家習慣以 &lt;code&gt;/&lt;/code&gt; 鍵輸入標點「、」。&lt;/p&gt;
&lt;p&gt;仍以【朙月拼音】爲例，輸入方案中有以下設定：&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;# luna_pinyin.schema.yaml
# ...

punctuator:
  import_preset: default&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解釋：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;punctuator&lt;/code&gt; 是 Rime 中負責轉換標點符號的組件。該組件會從設定中讀取符號映射表，而知道該做哪些轉換。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;punctuator/import_preset&lt;/code&gt; 是說，本方案要繼承一組預設的符號映射表、要從另一個設定檔 &lt;code&gt;default.yaml&lt;/code&gt; 導入。&lt;/p&gt;
&lt;p&gt;查看 &lt;code&gt;default.yaml&lt;/code&gt; ，確有如下符號表：&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;punctuator:
  full_shape:
    # ……其他……
    &quot;/&quot; : [ ／, &quot;/&quot;, ÷ ]
    # ……其他……
  half_shape:
    # ……其他……
    &quot;/&quot; : [ &quot;/&quot;, ／, ÷ ]
    # ……其他……&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可見按鍵 &lt;code&gt;/&lt;/code&gt; 是被指定到 &lt;code&gt;&quot;/&quot;, ／, ÷&lt;/code&gt; 等一組符號了。 並且全角和半角狀態下，符號有不同的定義。&lt;/p&gt;
&lt;p&gt;欲令 &lt;code&gt;/&lt;/code&gt; 鍵直接輸出「、」，可如此定製 &lt;code&gt;luna_pinyin.custom.yaml&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;patch:
  punctuator/full_shape:
    &quot;/&quot; : &quot;、&quot;
  punctuator/half_shape:
    &quot;/&quot; : &quot;、&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上在輸入方案設定中寫入兩組新值，合併後的輸入方案成爲：&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;# luna_pinyin.schema.yaml
# ...

punctuator:
  import_preset: default
  full_shape:
    &quot;/&quot; : &quot;、&quot;
  half_shape:
    &quot;/&quot; : &quot;、&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;含義是、在由 &lt;code&gt;default&lt;/code&gt; 導入的符號表之上，覆寫對按鍵 &lt;code&gt;/&lt;/code&gt; 的定義。&lt;/p&gt;
&lt;p&gt;通過這種方法，既直接繼承了大多數符號的默認定義，又做到了局部的個性化。&lt;/p&gt;
&lt;h3 id=&quot;section-6&quot;/&gt;
&lt;h3 id=&quot;使用全套西文標點&quot;&gt;使用全套西文標點&lt;/h3&gt;
&lt;p&gt;有些用戶習慣在中文裏使用ASCII標點，那麼與其一個一個覆寫，不如 &lt;em&gt;整套都換掉&lt;/em&gt; 。&lt;/p&gt;
&lt;p&gt;取得這份設定檔—— &lt;a href=&quot;http://gist.github.com/2334409&quot;&gt;Rime 別樣設定，使用西文標點&lt;/a&gt; 在用戶資料夾保存爲 &lt;code&gt;alternative.yaml&lt;/code&gt; ；&lt;/p&gt;
&lt;p&gt;再將輸入方案中的「導入 &lt;code&gt;default&lt;/code&gt; 設定」通過打 patch 替換爲「導入 &lt;code&gt;alternative&lt;/code&gt; 設定」&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;# luna_pinyin.custom.yaml

patch:
  'punctuator/import_preset': alternative&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;就換上了自己習慣的一套標點！&lt;/p&gt;
&lt;h3 id=&quot;section-7&quot;/&gt;
&lt;h3 id=&quot;一例定製簡化字輸出&quot;&gt;一例、定製簡化字輸出&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;注意：&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果您只是需要 Rime 輸出簡化字，敲 Ctrl+` 組合鍵、從菜單中選擇「漢字→汉字」即可！&lt;/li&gt;
&lt;li&gt;本例說明了其中原理，以及通過設定檔修改預設輸出字形的方法。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Rime 預設的詞彙表使用傳統漢字。 這是因爲傳統漢字較簡化字提供了更多信息，做「繁→簡」轉換能夠保證較高的精度。&lt;/p&gt;
&lt;p&gt;Rime 中的過濾器組件 simplifier，完成對候選詞的繁簡轉換。&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;# luna_pinyin.schema.yaml
# ...

switches:
  - name: ascii_mode
    reset: 0
    states: [ 中文, 西文 ]
  - name: full_shape
    states: [ 半角, 全角 ]
  - name: simplification    # 轉換開關
    states: [ 漢字, 汉字 ]

engine:
  filters:
    - simplifier  # 必要組件一
    - uniquifier  # 必要組件二&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上是【朙月拼音】中有關繁簡轉換功能的設定。&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;engine/filters&lt;/code&gt; 中，除了 &lt;code&gt;simplifier&lt;/code&gt;，還用了一件 &lt;code&gt;uniquifier&lt;/code&gt;。 這是因爲有些時候，不同的候選會轉化爲相同的簡化字，例如「鐘→钟」、「鍾→钟」。 &lt;code&gt;uniquifier&lt;/code&gt; 的作用是在 &lt;code&gt;simplifier&lt;/code&gt; 執行轉換之後，將文字相同的候選項合併。&lt;/p&gt;
&lt;p&gt;該輸入方案設有三個狀態開關：中／西文、全／半角、繁簡字。即 &lt;code&gt;switches&lt;/code&gt; 之下三項。&lt;/p&gt;
&lt;p&gt;每個開關可在兩種狀態（&lt;code&gt;states&lt;/code&gt;）之間切換，&lt;code&gt;simplifier&lt;/code&gt; 依據名爲 &lt;code&gt;simplification&lt;/code&gt; 的開關狀態來決定是否做簡化：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;初始狀態下、輸出爲傳統漢字、〔方案選單〕中的開關選項顯示爲「漢字→汉字」。&lt;/li&gt;
&lt;li&gt;選擇該項後、輸出爲簡化漢字、〔方案選單〕中顯示「汉字→漢字」。&lt;/li&gt;
&lt;li&gt;Rime 會記憶您的選擇，下次打開輸入法時、直接切換到所選的字形。&lt;/li&gt;
&lt;li&gt;亦可無視上次記住的選擇，在方案中重設初始值：&lt;code&gt;reset&lt;/code&gt; 設爲 0 或 1，分別選中 &lt;code&gt;states&lt;/code&gt; 列表中的兩種狀態。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果日常應用以簡化字爲主&lt;code&gt;:-(&lt;/code&gt;，則每每在〔方案選單〕中切換十分不便； 於是佛振獻上默認輸出簡化字的設定檔：&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;# luna_pinyin.custom.yaml

patch:
  switches:                   # 注意縮進
    - name: ascii_mode
      reset: 0                # reset 0 的作用是當從其他輸入方案切換到本方案時，
      states: [ 中文, 西文 ]  # 重設爲指定的狀態，而不保留在前一個方案中設定的狀態。
    - name: full_shape        # 選擇輸入方案後通常需要立即輸入中文，故重設 ascii_mode = 0；
      states: [ 半角, 全角 ]  # 而全／半角則可沿用之前方案中的用法。
    - name: simplification
      reset: 1                # 增加這一行：默認啓用「繁→簡」轉換。
      states: [ 漢字, 汉字 ]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其實預設輸入方案中就提供了一套【朙月拼音】的簡化字版本，名爲【簡化字】，以應大家“填表”之需。 看他的代碼如何卻與上篇定製檔寫得不同：&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;# luna_pinyin_simp.schema.yaml
# ...

switches:
  - name: ascii_mode
    reset: 0
    states: [ 中文, 西文 ]
  - name: full_shape
    states: [ 半角, 全角 ]
  - name: zh_simp           # 注意這裏（※1）
    reset: 1
    states: [ 漢字, 汉字 ]

simplifier:
  option_name: zh_simp      # 和這裏（※2）&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;前文說，&lt;code&gt;simplifier&lt;/code&gt; 這個組件會檢查名爲 &lt;code&gt;simplification&lt;/code&gt; 的開關狀態； 而這款【簡化字】方案卻用了一個不同名的開關 &lt;code&gt;zh_simp&lt;/code&gt;，即 ※1 處所示； 並通過在 ※2 行設定 &lt;code&gt;simplifier/option_name&lt;/code&gt; 告知 &lt;code&gt;simplifier&lt;/code&gt; 組件所需關注的開關名字。&lt;/p&gt;
&lt;p&gt;何故？&lt;/p&gt;
&lt;p&gt;還記得否，前文對「全／半角」這個開關的討論—— 當切換方案時，未明確使用 &lt;code&gt;reset&lt;/code&gt; 重置的開關，會保持之前設定過的狀態。&lt;/p&gt;
&lt;p&gt;【朙月拼音】等多數方案，並未重設 &lt;code&gt;simplification&lt;/code&gt; 這個選項—— 因爲用戶換了一種輸入編碼的方式、並不意味着需要變更輸出的字形。&lt;/p&gt;
&lt;p&gt;而【簡化字】這一方案不同，恰恰是表達變更輸出字形的需求； 用戶再從【簡化字】切回【朙月拼音】時，一定是爲了「回到」繁體輸出模式。 所以令【簡化字】使用獨立命名的開關、而非方案間共用的 &lt;code&gt;simplification&lt;/code&gt; 開關， 以避免影響其他輸入方案的繁簡轉換狀態。&lt;/p&gt;
&lt;h3 id=&quot;section-8&quot;/&gt;
&lt;h3 id=&quot;一例默認英文輸出&quot;&gt;一例、默認英文輸出&lt;/h3&gt;
&lt;p&gt;有些用戶習慣默認英文輸出，在需要用中文時再做切換。這就需要我們在方案中重設狀態開關初始值。&lt;/p&gt;
&lt;p&gt;還記得否？我們可用&lt;code&gt;reset&lt;/code&gt;設定項在方案中爲某些狀態開關重設初始值：&lt;code&gt;reset&lt;/code&gt; 設爲 0 或 1，分別選中 &lt;code&gt;states&lt;/code&gt; 列表中的兩種狀態。&lt;/p&gt;
&lt;p&gt;我們以【朙月拼音】爲例：&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;# luna_pinyin.custom.yaml

patch:
  &quot;switches/@0/reset&quot;: 1  #表示將 switcher 列表中的第一個元素（即 ascii_mode 開關）的初始值重設爲狀態1（即「英文」）。&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;section-9&quot;/&gt;
&lt;h3 id=&quot;一例定製方案選單&quot;&gt;一例、定製方案選單&lt;/h3&gt;
&lt;p&gt;在【小狼毫】方案選單設定介面上勾勾選選，就可以如此定製輸入方案列表：&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;# default.custom.yaml

patch:
  schema_list:  # 對於列表類型，現在無有辦法指定如何添加、消除或單一修改某項，於是要在定製檔中將整個列表替換！
    - schema: luna_pinyin
    - schema: cangjie5
    - schema: luna_pinyin_fluency
    - schema: luna_pinyin_simp
    - schema: my_coolest_ever_schema  # 這樣就啓用了未曾有過的高級輸入方案！其實這麼好的方案應該排在最前面哈。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;無有設定介面時，又想啓用、禁用某個輸入方案，手寫這樣一份定製檔、重新佈署就好啦。&lt;/p&gt;
&lt;h3 id=&quot;section-10&quot;/&gt;
&lt;h3 id=&quot;一例定製喚出方案選單的快捷鍵&quot;&gt;一例、定製喚出方案選單的快捷鍵&lt;/h3&gt;
&lt;p&gt;喚出方案選單，當然要用鍵盤。默認的快捷鍵爲 Ctrl+` 或 F4。&lt;/p&gt;
&lt;p&gt;不過，有些同學電腦上 Ctrl+` 與其他軟件衝突，F4 甚至本文寫作時在【鼠鬚管】中還不可用。又或者有的玩家切換頻繁，想定義到更好的鍵位。&lt;/p&gt;
&lt;p&gt;那麼……&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;# default.custom.yaml

patch:
  &quot;switcher/hotkeys&quot;:  # 這個列表裏每項定義一個快捷鍵，使哪個都中
    - &quot;Control+s&quot;      # 添加 Ctrl+s
    - &quot;Control+grave&quot;  # 你看寫法並不是 Ctrl+` 而是與 IBus 一致的表示法
    - F4&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;按鍵定義的格式爲「修飾符甲+修飾符乙+…+按鍵名稱」，加號爲分隔符，要寫出。&lt;/p&gt;
&lt;p&gt;所謂修飾符，就是以下組合鍵的狀態標誌或是按鍵彈起的標誌：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Release——按鍵被放開，而不是按下&lt;/li&gt;
&lt;li&gt;Shift&lt;/li&gt;
&lt;li&gt;Control&lt;/li&gt;
&lt;li&gt;Alt——Windows上 Alt+字母 會被系統優先識別爲程序菜單項的快捷鍵，當然 Alt+Tab 也不可用&lt;/li&gt;
&lt;li&gt;嗯，Linux 發行版還支持 Super, Meta 等組合鍵，不過最好選每個平臺都能用的啦&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;按鍵的名稱，大小寫字母和數字都用他們自己表示，其他的按鍵名稱 &lt;a href=&quot;https://github.com/rime/librime/blob/develop/thirdparty/include/X11/keysymdef.h&quot;&gt;參考這裏&lt;/a&gt; &lt;a href=&quot;https://github.com/LEOYoon-Tsaw/Rime_collections/blob/master/Rime_description.md&quot;&gt;这个更直观的文档&lt;/a&gt; 的定義，去除代碼前綴 &lt;code&gt;XK_&lt;/code&gt; 即是。&lt;/p&gt;
&lt;h3 id=&quot;section-11&quot;/&gt;
&lt;h3 id=&quot;一例定製小狼毫字體字號&quot;&gt;一例、定製【小狼毫】字體字號&lt;/h3&gt;
&lt;p&gt;雖與輸入方案無關，也在此列出以作參考。&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;# weasel.custom.yaml

patch:
  &quot;style/font_face&quot;: &quot;明兰&quot;  # 字體名稱，從記事本等處的系統字體對話框裏能看到
  &quot;style/font_point&quot;: 14     # 字號，只認數字的，不認「五號」、「小五」這樣的&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;section-12&quot;/&gt;
&lt;h3 id=&quot;一例定製小狼毫配色方案&quot;&gt;一例、定製【小狼毫】配色方案&lt;/h3&gt;
&lt;p&gt;註：這款配色已經在新版本的小狼毫裏預設了，做練習時，你可以將文中 &lt;code&gt;starcraft&lt;/code&gt; 換成自己命名的標識。&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;# weasel.custom.yaml

patch:
  &quot;style/color_scheme&quot;: starcraft    # 這項用於選中下面定義的新方案
  &quot;preset_color_schemes/starcraft&quot;:  # 在配色方案列表裏加入標識爲 starcraft 的新方案
    name: 星際我爭霸／StarCraft
    author: Contralisk &amp;lt;contralisk@gmail.com&amp;gt;, original artwork by Blizzard Entertainment
    text_color: 0xccaa88             # 編碼行文字顏色，24位色值，用十六進制書寫方便些，順序是藍綠紅0xBBGGRR
    candidate_text_color: 0x30bb55   # 候選項文字顏色，當與文字顏色不同時指定
    back_color: 0x000000             # 底色
    border_color: 0x1010a0           # 邊框顏色，與底色相同則爲無邊框的效果
    hilited_text_color: 0xfecb96     # 高亮文字，即與當前高亮候選對應的那部份輸入碼
    hilited_back_color: 0x000000     # 設定高亮文字的底色，可起到凸顯高亮部份的作用
    hilited_candidate_text_color: 0x60ffa8  # 高亮候選項的文字顏色，要醒目！
    hilited_candidate_back_color: 0x000000  # 高亮候選項的底色，若與背景色不同就會顯出光棒&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果自己看！&lt;/p&gt;
&lt;p&gt;也可以參照這張比較直觀的圖：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://camo.githubusercontent.com/95ec5aa3aa10b6f5d62295a3aea8107933881ca5/687474703a2f2f692e696d6775722e636f6d2f685374793663422e706e67&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另，此處有現成的配色方案工具供用家調配：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://tieba.baidu.com/p/2491103778&quot; class=&quot;uri&quot;&gt;http://tieba.baidu.com/p/2491103778&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;section-13&quot;/&gt;
&lt;h2 id=&quot;diy-處方集&quot;&gt;DIY 處方集&lt;/h2&gt;
&lt;p&gt;已將一些定製 Rime 的常見問題、解法及定製檔鏈接收錄於此。&lt;/p&gt;
&lt;p&gt;建議您首先讀完《定製指南》、通曉相關原理，以正確運用這些處方。&lt;/p&gt;
&lt;h3 id=&quot;section-14&quot;/&gt;
&lt;h3 id=&quot;初始設定&quot;&gt;初始設定&lt;/h3&gt;
&lt;h4 id=&quot;section-15&quot;/&gt;
&lt;h4 id=&quot;在方案選單中添加五筆雙拼&quot;&gt;在方案選單中添加五筆、雙拼&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://gist.github.com/2309739&quot; class=&quot;uri&quot;&gt;https://gist.github.com/2309739&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;倣此例，可啓用任一預設或自訂輸入方案，如【粵拼】、【注音】等。（詳解：參見前文「定製方案選單」一節）&lt;/p&gt;
&lt;p&gt;如果下載、自己製作了非預設的輸入方案，將源文件複製到「用戶資料夾」後，也用上面的方法將方案標識加入選單！&lt;/p&gt;
&lt;p&gt;修改於重新佈署後生效。&lt;/p&gt;
&lt;h4 id=&quot;section-16&quot;/&gt;
&lt;h4 id=&quot;小狼毫外觀設定&quot;&gt;【小狼毫】外觀設定&lt;/h4&gt;
&lt;p&gt;上文已介紹設定字體字號、製作配色方案的方法。&lt;/p&gt;
&lt;p&gt;使用橫向候選欄、嵌入式編碼行：&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;# weasel.custom.yaml
patch:
  style/horizontal: true      # 候選橫排
  style/inline_preedit: true  # 內嵌編碼（僅支持TSF）
  style/display_tray_icon: true  # 顯示托盤圖標&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;section-17&quot;/&gt;
&lt;h4 id=&quot;鼠鬚管外觀與鍵盤設定&quot;&gt;【鼠鬚管】外觀與鍵盤設定&lt;/h4&gt;
&lt;p&gt;鼠鬚管從 0.9.6 版本開始支持選擇配色方案，用 &lt;code&gt;squirrel.custom.yaml&lt;/code&gt; 保存用戶的設定。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gist.github.com/2290714&quot; class=&quot;uri&quot;&gt;https://gist.github.com/2290714&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;section-18&quot;/&gt;
&lt;h3 id=&quot;在特定程序裏關閉中文輸入&quot;&gt;在特定程序裏關閉中文輸入&lt;/h3&gt;
&lt;p&gt;【鼠鬚管】0.9.9 開始支持這項設定：&lt;/p&gt;
&lt;p&gt;在指定的應用程序中，改變輸入法的初始轉換狀態。如在&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;終端 &lt;code&gt;Terminal / iTerm&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;代碼編輯器 &lt;code&gt;MacVim&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;快速啓動工具 &lt;code&gt;QuickSilver / Alfred&lt;/code&gt; 等程序裏很少需要輸入中文，於是鼠鬚管在這些程序裏默認不開啓中文輸入。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;自定義 Mac 應用程序的初始轉換狀態，首先查看應用的 &lt;code&gt;Info.plist&lt;/code&gt; 文件得到 該應用的 &lt;code&gt;Bundle Identifier&lt;/code&gt;，通常是形如 &lt;code&gt;com.apple.Xcode&lt;/code&gt; 的字符串。&lt;/p&gt;
&lt;p&gt;例如，要在 &lt;code&gt;Xcode&lt;/code&gt; 裏面默認關閉中文輸入，又要在 &lt;code&gt;Alfred&lt;/code&gt; 裏面恢復開啓中文輸入，可如此設定：&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;# example squirrel.custom.yaml
patch:
  app_options/com.apple.Xcode:
    ascii_mode: true
  app_options/com.alfredapp.Alfred: {}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;註：一些版本的 &lt;code&gt;Xcode&lt;/code&gt; 標識爲 &lt;code&gt;com.apple.dt.Xcode&lt;/code&gt;，請注意查看 &lt;code&gt;Info.plist&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;【小狼毫】0.9.16 亦開始支持這項設定。&lt;/p&gt;
&lt;p&gt;例如，要在 &lt;code&gt;gVim&lt;/code&gt; 裏面默認關閉中文輸入，可如此設定：&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;# example weasel.custom.yaml
patch:
  app_options/gvim.exe:  # 程序名字全用小寫字母
    ascii_mode: true&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;section-19&quot;/&gt;
&lt;h3 id=&quot;輸入習慣&quot;&gt;輸入習慣&lt;/h3&gt;
&lt;h4 id=&quot;section-20&quot;/&gt;
&lt;h4 id=&quot;使用control鍵切換中西文&quot;&gt;使用Control鍵切換中西文&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://gist.github.com/2981316&quot; class=&quot;uri&quot;&gt;https://gist.github.com/2981316&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;以及修改Caps Lock、左右Shift、左右Control鍵的行爲，提供三種切換方式。 詳見 Gist 代碼註釋。&lt;/p&gt;
&lt;h4 id=&quot;section-21&quot;/&gt;
&lt;h4 id=&quot;方便地輸入含數字的西文用戶名&quot;&gt;方便地輸入含數字的西文用戶名&lt;/h4&gt;
&lt;p&gt;通常，輸入以小寫拉丁字母組成的編碼後，數字鍵的作用是選擇相應序號的候選字。&lt;/p&gt;
&lt;p&gt;假設我的郵箱地址是 &lt;code&gt;rime123@company.com&lt;/code&gt;，則需要在輸入rime之後上屏或做臨時中西文切換，方可輸入數字部分。&lt;/p&gt;
&lt;p&gt;爲了更方便輸入我的用戶名 &lt;code&gt;rime123&lt;/code&gt;，設置一組特例，將 &lt;code&gt;rime&lt;/code&gt; 與其後的數字優先識別西文：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gist.github.com/3076166&quot; class=&quot;uri&quot;&gt;https://gist.github.com/3076166&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;section-22&quot;/&gt;
&lt;h4 id=&quot;以方括號鍵換頁&quot;&gt;以方括號鍵換頁&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://gist.github.com/2316704&quot; class=&quot;uri&quot;&gt;https://gist.github.com/2316704&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;添加 Mac 風格的翻頁鍵 &lt;code&gt;[ ]&lt;/code&gt; 。這是比較直接的設定方式。下一則示例給出了一種更系統、可重用的設定方式。&lt;/p&gt;
&lt;h4 id=&quot;section-23&quot;/&gt;
&lt;h4 id=&quot;使用西文標點兼以方括號鍵換頁&quot;&gt;使用西文標點兼以方括號鍵換頁&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://gist.github.com/2334409&quot; class=&quot;uri&quot;&gt;https://gist.github.com/2334409&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;詳見上文「使用全套西文標點」一節。&lt;/p&gt;
&lt;h4 id=&quot;section-24&quot;/&gt;
&lt;h4 id=&quot;以回車鍵清除編碼兼以分號單引號選字&quot;&gt;以回車鍵清除編碼兼以分號、單引號選字&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://gist.github.com/2390510&quot; class=&quot;uri&quot;&gt;https://gist.github.com/2390510&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;適合一些形碼輸入法（如五筆、鄭碼）的快手。&lt;/p&gt;
&lt;h4 id=&quot;section-25&quot;/&gt;
&lt;h4 id=&quot;關閉逐鍵提示&quot;&gt;關閉逐鍵提示&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;table_translator&lt;/code&gt; 默認開啓逐鍵提示。若要只出精確匹配輸入碼的候選字，可關閉這一選項。&lt;/p&gt;
&lt;p&gt;以【倉頡五代】爲例：&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;# cangjie5.custom.yaml
patch:
  translator/enable_completion: false&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;section-26&quot;/&gt;
&lt;h4 id=&quot;關閉用戶詞典和字頻調整&quot;&gt;關閉用戶詞典和字頻調整&lt;/h4&gt;
&lt;p&gt;以【五笔86】爲例：&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;# wubi86.custom.yaml
patch:
  translator/enable_user_dict: false&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;section-27&quot;/&gt;
&lt;h4 id=&quot;關閉碼表輸入法連打&quot;&gt;關閉碼表輸入法連打&lt;/h4&gt;
&lt;p&gt;註：這個選項僅針對 &lt;code&gt;table_translator&lt;/code&gt;，用於屏蔽倉頡、五筆中帶有太極圖章「☯」的連打詞句選項，不可作用於拼音、注音、速成等輸入方案。&lt;/p&gt;
&lt;p&gt;以【倉頡】爲例：&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;# cangjie5.custom.yaml
patch:
  translator/enable_sentence: false&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;section-28&quot;/&gt;
&lt;h4 id=&quot;關閉倉頡與拼音混打&quot;&gt;關閉倉頡與拼音混打&lt;/h4&gt;
&lt;p&gt;默認，給出倉頡與拼音候選的混合列表。&lt;/p&gt;
&lt;p&gt;如此設定，直接敲字母只認作倉頡碼，但仍可在敲 ` 之後輸入拼音：&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;# cangjie5.custom.yaml
patch:
  abc_segmentor/extra_tags: {}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;section-29&quot;/&gt;
&lt;h4 id=&quot;空碼時按空格鍵清空輸入碼&quot;&gt;空碼時按空格鍵清空輸入碼&lt;/h4&gt;
&lt;p&gt;首先需要關閉碼表輸入法連打（參見上文），這樣才可以在打空時不出候選詞。&lt;/p&gt;
&lt;p&gt;然後設定（以五筆86爲例）：&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;# wubi86.custom.yaml
patch:
  translator/enable_sentence: false
  key_binder/bindings:
    - {when: has_menu, accept: space, send: space}
    - {when: composing, accept: space, send: Escape}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;section-30&quot;/&gt;
&lt;h3 id=&quot;模糊音&quot;&gt;模糊音&lt;/h3&gt;
&lt;h4 id=&quot;section-31&quot;/&gt;
&lt;h4 id=&quot;朙月拼音模糊音定製模板&quot;&gt;【朙月拼音】模糊音定製模板&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://gist.github.com/2320943&quot; class=&quot;uri&quot;&gt;https://gist.github.com/2320943&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【明月拼音·简化字／臺灣正體／語句流】也適用， 只須將模板保存到 &lt;code&gt;luna_pinyin_simp.custom.yaml&lt;/code&gt; 、 &lt;code&gt;luna_pinyin_tw.custom.yaml&lt;/code&gt; 或 &lt;code&gt;luna_pinyin_fluency.custom.yaml&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;对比模糊音定製模板與&lt;a href=&quot;https://github.com/rime/rime-luna-pinyin/blob/master/luna_pinyin.schema.yaml&quot;&gt;【朙月拼音】方案原件&lt;/a&gt;， 可見模板的做法是，在 &lt;code&gt;speller/algebra&lt;/code&gt; 原有的規則中插入了一些定義模糊音的代碼行。&lt;/p&gt;
&lt;p&gt;類似方案如雙拼、粵拼等可參考模板演示的方法改寫 &lt;code&gt;speller/algebra&lt;/code&gt; 。&lt;/p&gt;
&lt;h4 id=&quot;section-32&quot;/&gt;
&lt;h4 id=&quot;吳語模糊音定製模板&quot;&gt;【吳語】模糊音定製模板&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://gist.github.com/2015335&quot; class=&quot;uri&quot;&gt;https://gist.github.com/2015335&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;section-33&quot;/&gt;
&lt;h3 id=&quot;編碼反查&quot;&gt;編碼反查&lt;/h3&gt;
&lt;h4 id=&quot;section-34&quot;/&gt;
&lt;h4 id=&quot;設定速成的反查碼爲粵拼&quot;&gt;設定【速成】的反查碼爲粵拼&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://gist.github.com/2944320&quot; class=&quot;uri&quot;&gt;https://gist.github.com/2944320&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;section-35&quot;/&gt;
&lt;h4 id=&quot;設定倉頡的反查碼爲雙拼&quot;&gt;設定【倉頡】的反查碼爲雙拼&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://gist.github.com/2944319&quot; class=&quot;uri&quot;&gt;https://gist.github.com/2944319&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;section-36&quot;/&gt;
&lt;h3 id=&quot;在mac系統上輸入emoji表情&quot;&gt;在Mac系統上輸入emoji表情&lt;/h3&gt;
&lt;p&gt;參考 &lt;a href=&quot;https://gist.github.com/2309739&quot; class=&quot;uri&quot;&gt;https://gist.github.com/2309739&lt;/a&gt; 把 &lt;code&gt;emoji&lt;/code&gt; 加入輸入方案選單；&lt;/p&gt;
&lt;p&gt;切換到 &lt;code&gt;emoji&lt;/code&gt; 輸入方案，即可通過拼音代碼輸入表情符號。&lt;a href=&quot;https://github.com/rime/home/raw/master/images/emoji-chart.png&quot;&gt;查看符號表&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;輸入 &lt;code&gt;all&lt;/code&gt; 可以列出全部符號，符號後面的括弧裏標記其拼音代碼。&lt;/p&gt;
&lt;p&gt;若要直接在【朙月拼音】裏輸入表情符號，請按此文設定：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://gist.github.com/3705586&quot; class=&quot;uri&quot;&gt;http://gist.github.com/3705586&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;section-37&quot;/&gt;
&lt;h3 id=&quot;五筆簡入繁出&quot;&gt;五筆簡入繁出&lt;/h3&gt;
&lt;p&gt;【小狼毫】用家請到&lt;a href=&quot;https://github.com/rime/home/wiki/Downloads&quot;&gt;下載頁&lt;/a&gt;取得「擴展方案集」。&lt;/p&gt;
&lt;p&gt;安裝完成後，執行輸入法設定，添加【五筆·簡入繁出】輸入方案。&lt;/p&gt;
&lt;p&gt;其他版本請參考這篇說明：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gist.github.com/3467172&quot; class=&quot;uri&quot;&gt;https://gist.github.com/3467172&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;section-38&quot;/&gt;
&lt;h4 id=&quot;修正不對稱繁簡字&quot;&gt;修正不對稱繁簡字&lt;/h4&gt;
&lt;p&gt;繁→簡即時轉換比簡體轉繁體要輕鬆許多，卻也免不了個別的錯誤。&lt;/p&gt;
&lt;p&gt;比如這一例，「乾」字是一繁對多簡的典型。由它組成的常用詞組，opencc 都做了仔細分辨。但是遇到較生僻的詞組、專名，就比較頭疼：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://tieba.baidu.com/p/1909252328&quot; class=&quot;uri&quot;&gt;http://tieba.baidu.com/p/1909252328&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;section-39&quot;/&gt;
&lt;h3 id=&quot;活用標點創建自定義詞組&quot;&gt;活用標點創建自定義詞組&lt;/h3&gt;
&lt;p&gt;在【朙月拼音】裏添加一些自定義文字、符號。可以按照上文設定「emoji表情」的方式爲自定義詞組創建一個專門的詞典。&lt;/p&gt;
&lt;p&gt;可是建立詞典稍顯繁瑣，而活用自定義標點，不失爲一個便捷的方法：&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;# luna_pinyin.custom.yaml
# 如果不需要 ` 鍵的倉頡反查拼音功能，則可利用 ` 鍵輸入自定義詞組
patch:
  recognizer/patterns/reverse_lookup:
  'punctuator/half_shape/`':
    - '佛振 &amp;lt;chen.sst@gmail.com&amp;gt;'
    - 'http://rime.github.io'
    - 上天赋予你高的智商，教你用到有用的地方。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上例 &lt;code&gt;recognizer/patterns/reverse_lookup:&lt;/code&gt; 作用是關閉 ` 鍵的反查功能。若選用其他符號則不需要這行。又一例：&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;patch:
  'punctuator/half_shape/+': '+_+'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;'punctuator/half_shape/+'&lt;/code&gt; 因爲字符串包含符號，最好用 &lt;strong&gt;單引號&lt;/strong&gt; 括起來，避免符號的轉義問題。&lt;/p&gt;
&lt;p&gt;重定義「/」這個符號，無法用上面演示的路徑連寫方式，那就分開寫：&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;patch:
  punctuator/half_shape:
   '/': [ '/', '/hello', '/bye', '/* TODO */' ]
   '+': '+_+'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;更多请参考&lt;/strong&gt;：&lt;/p&gt;
</description>
<pubDate>Sat, 29 Dec 2018 18:08:00 +0000</pubDate>
<dc:creator>东北小狐狸</dc:creator>
<og:description>前言 不知不觉就到了年终了，距离上次更新博客已经有一个半月，这段时间天天在加班，也没作一下新的学习计划，趁着元旦放假，写一点好玩的东西，这次要记录的是一点关于Rime相关的东西，文章本身不会长，只是说</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hellxz/p/10198540.html</dc:identifier>
</item>
<item>
<title>这年头做开源项目，被冷嘲热讽，FreeSql 0.0.4 - nicye</title>
<link>http://www.cnblogs.com/kellynic/p/10198518.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kellynic/p/10198518.html</guid>
<description>&lt;p&gt;FreeSql 项目大概在20天前想着要做的，今天发布0.0.4在群里被一位大神讽刺。&lt;/p&gt;
&lt;p&gt;这位无名氏哥们的观点，先声明这不是找安慰的文章，更加不是报复打击的目的。&lt;/p&gt;
&lt;p&gt;1 所以这个比EF好在哪里&lt;br/&gt;2 毕竟EF是官方的技术，你自己造的轮子得说明自己哪里不是重复造轮子，而不是问已有的轮子到底怎么样&lt;br/&gt;3 EF完全可以胜任并且超出一个ORM框架需要的所有功能&lt;br/&gt;4 你可以觉得EF不够好，自己做一个更好的，但是这建立在你能指出EF哪里不好的前提下&lt;br/&gt;5 另外插入一个话题，[图片]这个项目引用 很显然 这违背了.NET Core的小包思想，四个字，按需引用&lt;br/&gt;6 这根本就不是什么拆包的问题，而是在开发的时候就是小包，你不了解.NET Core的思想，每必要非得说自己是正确的，有人教你，你就虚心接受，没什么大不了的&lt;br/&gt;7 你target了.NET Standard，却走的是原来的那一套思路，&lt;br/&gt;8 在接受一个新的平台的时候，你需要接受它的思想&lt;br/&gt;9 不要重复造轮子，你如果觉得ef有缺陷，哪不好，自己提issue，给pull request，如果你觉得ef一无是处，你自己做，那也得说明它比ef好在哪里，是吧&lt;br/&gt;10 你和ef的区别在于你把sql语句暴露出来了，而ef是使用IQueryable来完全封装sql的&lt;br/&gt;11 IQueryable是一个标准接口，你要标新立异，本来就是兼容性很差的&lt;br/&gt;12 你觉得微软不对你可以别用微软，但是你用微软你就得遵循用微软的人在遵循的标准&lt;br/&gt;13 ORM框架本身，并不是一个功能性的东西，就是提供一个优雅的coding style，但是你的ORM框架，却忽略了coding style的问题&lt;br/&gt;14 现在.NET上的ORM框架、甚至是一些no sql的数据驱动，他们的查询操作，主流的，你觉得有几个不是实现IQueryable接口的？&lt;br/&gt;15 你标新立异，就代表着现存项目没有这个开发成本来重构成基于你的框架的版本，新的项目也无法接受选型你这个框架的风险&lt;br/&gt;16 不实现IQueryable接口的查询API，实际项目无论是迁入到你这个框架，还是从你的框架迁出到别的框架，都有巨额的重构成本&lt;br/&gt;17 你写出来一个东西来符合自己的理解，自己觉得更优雅，但是实际项目选型的时候要选用你的框架，会有这些问题：&lt;br/&gt;1)你的文档中没有任何对比说明你的框架哪比EF更好&lt;br/&gt;2)你的框架迁入迁出成本太高&lt;br/&gt;3)你的框架缺乏学习资源&lt;br/&gt;4)你的框架缺乏可靠的社区支持&lt;br/&gt;18 是，有了.NET Core，微软拥抱开源了，.NET开发者都可以融入开源社区了，但是你得知道什么是开源社区，开源社区什么东西能好，什么东西得避免，开源社区的运作思想，而不是，哦，我写一个库，放github上，就是开源，你造轮子也得按照基本法，不要重复造轮子&lt;br/&gt;19 [图片]从关键字搜索来看，这个项目里没有任何连接池控制的逻辑&lt;br/&gt;20 我不知道你的项目里有没有实现数据库的版本控制的逻辑，如果没有，那你真的该去好好了解为什么要用ef，如果有，那么你是真正的勇士，花了一大把时间来重复造了一个很繁琐的轮子&lt;br/&gt;21 算了，你自己要花时间，谁也拦不住，但是当成果被认可的程度没有达到你的预期时，请不要忘记我曾经提醒过你，大家都是程序员，坑都得自己跳一下才知道深，这个我是理解的&lt;/p&gt;
&lt;p&gt;老哥应该是怕我被坑，我觉得做项目不容易，愿意开放源代码不应该鼓励吗？下班的时候和这位老哥聊了半小时，我很感激你的提醒，但是我需要更多的应该是认可。&lt;/p&gt;
&lt;p&gt;咱们无偿开放源代码容易吗，好好给一点点鼓励就行，.net社区的未来才会更好。&lt;/p&gt;
&lt;p&gt;项目仓库：&lt;a href=&quot;https://github.com/2881099/FreeSql&quot; class=&quot;uri&quot;&gt;https://github.com/2881099/FreeSql&lt;/a&gt;&lt;br/&gt;目前版本 0.0.4，目前可用性已经挺高了，如果觉得不容易，请给予一星，谢谢🙏&lt;/p&gt;
</description>
<pubDate>Sat, 29 Dec 2018 17:23:00 +0000</pubDate>
<dc:creator>nicye</dc:creator>
<og:description>FreeSql 项目大概在20天前想着要做的，今天发布0.0.4在群里被一位大神讽刺。 这位无名氏哥们的观点，先声明这不是找安慰的文章，更加不是报复打击的目的。 1 所以这个比EF好在哪里 2 毕竟E</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kellynic/p/10198518.html</dc:identifier>
</item>
<item>
<title>使用node和express+mongodb实现数据增删改功能 - 小周sri的码农</title>
<link>http://www.cnblogs.com/zhoulifeng/p/10197816.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhoulifeng/p/10197816.html</guid>
<description>&lt;p&gt;2018即将过去，2019即将来临，前端技术不断在在更新，学的东西越来越多。我们只有不断的学习，才不能被淘汰。在前后端分离的一个时代，后端提供接口，前端调用接口，逻辑判断，每个都是独立的工作。如果自己在空余的时间，想学习新的知识，却没有好的接口，只能写写假的json数据。或者网上开源的数据库，mock，野狗数据库，firebase，或者使用本地的json-server搭建本地数据库使用也是完全没有问题的，也可以正常的实现数据的接口请求。&lt;/p&gt;
&lt;p&gt;　今天小编就写一遍关于node写接口的文档，会从环境搭建，数据库链接，数据模型，接口文档以及到测试，一步一步的来，尽最大可能写好，让每一位读者都能看懂，文章可能过程，希望慢慢理解&lt;/p&gt;
&lt;p&gt;   2018最后的一篇博客，希望在2019继续努力&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.准备工作&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;postman接口测试工具，&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;node安装&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;mlab数据存储&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;mongodb数据库&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.node + express环境搭建&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.1环境搭建之前，首先要检查自己电脑是否安装node环境，如果没有安装，先安装node环境.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.2在自己电脑创建一个目录文件，打开自己终端，先进行初始化 cnpm init(在这里使用了cnpm国内镜像，如果没有安装，请自行安装cnpm)；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;初始化之后会出现下面这个界面，会在我们的文件中生成一个package.json文件；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1188378/201812/1188378-20181229203220529-186410470.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.3在自己根目录创建一个入口文件，app.js文件或者通过终端命令touch app.js创建一个文件，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.4这时候我们可以搭建服务器环境，但是需要依赖express，这时候我们就需要安装express&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
cnpm install express
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2.5工作环境准备好之后，需要在我们的入口文件引入express，并创建一个app实列，请看下面，&lt;/p&gt;
&lt;p&gt;　　2.5.1：port是我们的端口号，app.listen是监听端口号运行&lt;/p&gt;
&lt;p&gt;　　2.5.2：然后通过node app.js运行，查看服务器是否正常运行成功，然后在浏览器出入http://localhost:5000，就可以查看运行的结果了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1188378/201812/1188378-20181229204909155-793339301.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 2.6但是我们每次修改代码的时候都要重新运行node app.js，这个时候我们只需要安装nodemon,监听node变化的一个工具&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
cnpm install nodemon -g  在这里是全局安装
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.7：配置package.json启动命令，在开发环境的时候，直接可以通过cnpm run app来监听每次修改node的变化，nodemon我们已经全局安装过了，可以在任何地方都可以使用，只要我们每次修改代码都会发生变化，这样我们就不会手动输入命令了&lt;/p&gt;
&lt;p&gt;    &lt;img src=&quot;https://img2018.cnblogs.com/blog/1188378/201812/1188378-20181229205435410-1457027883.png&quot; alt=&quot;&quot;/&gt;   &lt;img src=&quot;https://img2018.cnblogs.com/blog/1188378/201812/1188378-20181229205542265-647226612.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.数据库mlab创建&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.1:mlab是MongoDB提供的免费存储的数据库，使用的时候必须先注册，才可以使用，这个mlab需要FQ注册，注册登录之后会出现下面的界面&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1188378/201812/1188378-20181229210347794-199639574.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;3.2然后点击Create  new 创建   》》》》  然后选择下面的两个，&lt;span&gt;amazon&lt;/span&gt;和&lt;span&gt;SANDBOX&lt;/span&gt;最后点击右下角&lt;span&gt;CONTINUE，&lt;span&gt;会跳转下一步&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.3在这个界面选择国家地区，选择US EAST和Europe都可以，然后点击&lt;span&gt;CONTINUE，&lt;span&gt;会跳转下一步&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;3.4在这个界面，需要我们输入一个名字，名字随便输入，然后点击&lt;span&gt;CONTINUE&lt;/span&gt;，会跳转下一步，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1188378/201812/1188378-20181229211124929-1132559524.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3.5在下一个页面，然后在点击&lt;span&gt;SUBMIT ORDER&lt;/span&gt;，这样我们就创建好一个数据库，然后点击进入数据库中&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1188378/201812/1188378-20181229211526933-948720275.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.6进入我的数据库中，黄色警告提示我们需要创建一个用户信息，也就是我们最后链接的用户名和密码，点击add会弹出一个框，然后我门添加用户名和密码就可以了，最后点击CREATE，这样我们的数据库就已经创建完成了，接下来我们可以使用node链接我们的数据库了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1188378/201812/1188378-20181229212009732-1391804735.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.node链接MongoDB&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;4.1安装mongoose链接数据库&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
cnpm install mongoose
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4.2然后在你的入口文件引入(app.js),&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;const&lt;/span&gt; mongoose require(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;mongoose&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4.3在我们的根目录创建一个config文件，在confing中创建一个db.js文件，这个文件存放我们的数据库的地址，连接数据库的地址放在一个单独的文件，把我们服务器的地址引入过了就行了，修改用户名和密码就行了，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1188378/201812/1188378-20181230003421836-2133801181.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.4使用mongoose链接数据库，在我们的根目录引入config下面的db文件。然后通过mongoose链接数据，最后在控制台可以看到我们已经链接成功了，到现在为止，数据已经链接配置好了，接下来接开始写接口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1188378/201812/1188378-20181229213858522-952564903.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;5.接口路由搭建和数据模型&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.1在我们的根目录下创建一个router &amp;gt;&amp;gt;&amp;gt; api &amp;gt;&amp;gt;&amp;gt; useinfo.js文件，这个用于存放我们的请求接口的路由文件;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　5.1.1在userinfo文件中引入express和路由，先写一个get请求方法，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1188378/201812/1188378-20181229215739570-667727576.png&quot; alt=&quot;&quot;/&gt;   &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;span&gt;　5.2.2需要在我们的app.js文件引入userinfo.js文件，并使用router中间件，不然不会生效&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;/api/userinfo：这个相当于我们访问的接口地址&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre readability=&quot;5&quot;&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;引入userinfo.js&lt;/span&gt;
&lt;span&gt;const&lt;/span&gt; userinfo = require(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;./router/api/userinfo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用router中间件&lt;/span&gt;
app.use(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/api/userinfo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,userinfo)&lt;p&gt;然后就可以在浏览器输入&lt;span&gt;http://localhost:5000/api/userinfo&lt;/span&gt;
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; 5.2postman接口测试工具使用&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;span&gt;5.2.1我们已经写好一个get的测试请求，接下来我们进行测试，我们可以通过postman这个工具进行测试，下载好之后需要登录注册，&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　下载好之后打开这个工具，第一步输入我们的地址，点击send，就能看到我们请求的结果是否正确了&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1188378/201812/1188378-20181229220918333-2060118616.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;5.3创建数据模型&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.3.1创建我们的数据模型用于存放数据字段名。在根目录创建models文件，然后创建Userinfo.js文件，用于写数据字段模型。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;创建了name,age,sex,address,date几个字段名，(使用什么字段创建什么字段，在这里先使用这么多)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;mongoose.Schema是一个MongoDB对象建模工具,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;每一个Schema对应一个mongoDB collection 并且在那个collection里面定义了documents的模型。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1188378/201812/1188378-20181229223529105-2132582495.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;5.4编写路由接口，实现数据的添加，删除，修改功能&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在我们路由文件userinfo引入数据模型Userinfo文件，这样我们就可以查询数据库中是否有这些字段名了&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
const Userinfo =require('../../models/Userinfo')
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;5.4.1添加用户信息&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;span&gt;添加用户信息肯定需要使用post去添加用户信息了，这时候我们需要安装第三方依赖body-parser&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
cnpm install body-parser
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　5.4.2在安装完之后，需要在app.js文件引入，并使用，这样我们就可以使用post进行数据存储了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;const&lt;/span&gt; bodyParser = require(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;body-parser&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用body-parser中间件&lt;/span&gt;
app.use(bodyParser.urlencoded({extended:&lt;span&gt;false&lt;/span&gt;&lt;span&gt;}));
app.use(bodyParser.json());&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;5.4.3添加数据接口,。先创建一个空的对，判断数据是否存在，如果不存在的话，通过new Userinfo添加数据库中，Userinfo就是我们上面引入的模型&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; $route  GET api/userinfo/add
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; @desc   添加用户数据
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; @access public&lt;/span&gt;
router.post(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/add&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,(req,res) =&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; UserName =&lt;span&gt; {};
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(req.body.name) UserName.name =&lt;span&gt; req.body.name;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(req.body.sex) UserName.sex =&lt;span&gt; req.body.sex;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(req.body.age) UserName.age =&lt;span&gt; req.body.age;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(req.body.address) UserName.address =&lt;span&gt; req.body.address;
    
    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Userinfo(UserName).save().then(user =&amp;gt;&lt;span&gt; {
    res.json(user);
  });
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;5.4.4使用postman接口测试，请求接口类型是post请求，输入我们的接口地址，添加字段，点击send，就可以看到我们添加数据的字段了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1188378/201812/1188378-20181229233658057-330863975.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;5.5获取所有数据&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.5.1通过get请求，获取数据库中所有的数据信息&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; $route  GET api/userinfo
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; @desc   获取所有的数据
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; @access public&lt;/span&gt;
&lt;span&gt;//find()是mongodb的数据库语法
router.&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, (req,res) =&amp;gt;&lt;span&gt; {
    Userinfo.find().then(user &lt;/span&gt;=&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;user) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; res.status(&lt;span&gt;400&lt;/span&gt;).json(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;没有任何数据存在&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; res.json(user)
    }).&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;(err =&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; res.status(&lt;span&gt;404&lt;/span&gt;&lt;span&gt;).json(err)
    })
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;5.5.1通过postman测试接口，http://localhost:5000/api/userinfo，就可以获取到我们数据库中所有的信息了，&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1188378/201812/1188378-20181229234431103-1914287633.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;5.6获取单个用户信息&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.6.1：通过根据用户的id去获取单个用户的信息&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; $route  GET api/userinfo/:id
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; @desc   获取单个的数据
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; @access public&lt;/span&gt;
router.&lt;span&gt;get&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/:id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,(req,res) =&amp;gt;&lt;span&gt; {
    Userinfo.findOne({_id:req.&lt;/span&gt;&lt;span&gt;params&lt;/span&gt;.id}).then(user =&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;user) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; res.status(&lt;span&gt;400&lt;/span&gt;).json(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;没有任何数据存在&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; res.json(user)
    }).&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;(err =&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; res.status(&lt;span&gt;404&lt;/span&gt;&lt;span&gt;).json(err)
    })
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;5.6.2通过postman测试接口，http://localhost:5000/api/userinfo/5c27929b2a87821914f8b195，就可以获取到我们数据库中所需要的信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1188378/201812/1188378-20181230000226514-1825787125.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;5.7编辑用户信息&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;5.7.1编辑用户信息，也是根据用户的id去更新数据，通过monoose提供的findByIdAndUpdate去更新数据库&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; $route  GET api/userinfo/exit/:id
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; @desc   编辑用户信息
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; @access public&lt;/span&gt;
&lt;span&gt;
router.post(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/exit/:id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,(req,res) =&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; UserName =&lt;span&gt; {};
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(req.body.name) UserName.name =&lt;span&gt; req.body.name;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(req.body.sex) UserName.sex =&lt;span&gt; req.body.sex;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(req.body.age) UserName.age =&lt;span&gt; req.body.age;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(req.body.address) UserName.address =&lt;span&gt; req.body.address;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;更新数据&lt;/span&gt;
    Userinfo.findByIdAndUpdate({ _id: req.&lt;span&gt;params&lt;/span&gt;&lt;span&gt;.id }, 
        { $&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;: UserName }, { &lt;span&gt;new&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;&lt;span&gt; })
    .then(user &lt;/span&gt;=&amp;gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;user) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; res.status(&lt;span&gt;400&lt;/span&gt;).json(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;数据不存在&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
      }
     res.json(user);
    })
    .&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;(err =&amp;gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; res.status(&lt;span&gt;404&lt;/span&gt;&lt;span&gt;).json(err);
    });
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;5.7.2这是我们更新第一个字段的用户信息，把张三的名字改成张飞，在postman中可以看到我们成功更新数据&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1188378/201812/1188378-20181230000517654-221829284.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;5.8删除用户信息&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;5.8.1在这里，我们只删除根据用户的id删除，不会实现全部删除。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; $route  GET api/userinfo/delete/:id
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; @desc   删除用户信息
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; @access public&lt;/span&gt;
&lt;span&gt;
router.delete(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/delete/:id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,(req,res) =&amp;gt;&lt;span&gt; {
    Userinfo.findByIdAndRemove({_id:req.&lt;/span&gt;&lt;span&gt;params&lt;/span&gt;.id}).then(user =&amp;gt;&lt;span&gt; {
        user.save().then(user &lt;/span&gt;=&amp;gt;&lt;span&gt; {
            res.json(user)
        })
    }).&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;(err =&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; res.status(&lt;span&gt;404&lt;/span&gt;&lt;span&gt;).json(err)
    })
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;5.8.2我们通过postman测试http://localhost:5000/api/userinfo/delete/5c27929b2a87821914f8b195，成功姓名为张飞的数据删除成功&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1188378/201812/1188378-20181230001514828-2007913299.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;以上都是我们使用node+express实现的数据的添加，删除，修改功能。希望这篇博客能够帮助你。提前祝愿2019前端小伙伴元旦快乐，2019更上技术更上一层楼。&lt;/p&gt;

</description>
<pubDate>Sat, 29 Dec 2018 16:38:00 +0000</pubDate>
<dc:creator>小周sri的码农</dc:creator>
<og:description>2018即将过去，2019即将来临，前端技术不断在在更新，学的东西越来越多。我们只有不断的学习，才不能被淘汰。在前后端分离的一个时代，后端提供接口，前端调用接口，逻辑判断，每个都是独立的工作。如果自己</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhoulifeng/p/10197816.html</dc:identifier>
</item>
<item>
<title>2018即将过去,立个flag - 房东家的猫</title>
<link>http://www.cnblogs.com/fangdongdemao/p/10198346.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fangdongdemao/p/10198346.html</guid>
<description>&lt;h3 id=&quot;过去的2018&quot;&gt;过去的2018&lt;/h3&gt;
&lt;blockquote readability=&quot;14&quot;&gt;
&lt;p&gt;自己有没有值得有意义的地方呢?&lt;/p&gt;
&lt;p&gt;自己有没有认识新的异性朋友呢?&lt;/p&gt;
&lt;p&gt;自己都在忙啥呢?&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;敲代码,然后发现敲坏了一个键盘,换了HHKB,一个字舒服,还有就是通宵把一部电视剧看完了&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;觉得有没有遗憾的事？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;有，太多了，比如生了一场大病，写代码不要命，不注意身体，要钱不要命，跟人打交道太少，去健身太少，一天的时间太短，一年的时间太短，没有完成自己年初计划，经济负增长，没有好好孝敬父母，还让父母为我操心，自己太笨，技术还是这么菜.......&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;有没有觉得自己变了&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;变了,比如脾气比以前好了很多,比较有耐心了点,与人交流太少了,想多站在大佬的肩膀下学习,还有自己太懒了,通宵是常态,分不清白天黑夜, 沉浸在自己的世界中,没有达到自己的要求很失望&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;有没有发现自己变厉害了,那么一点点&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;应该有吧,又或许没有,呵呵呵,我也不知道,不过感觉还是那么菜&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;​ 在这过去的一年来我都干了什么,注意广度,忽略了深度,对于一个小白来说是多么可怕的时候,就一直在天上飘,没有认识到自己实际上自己菜的原因,竟然有了自己转行去搞大数据的想法,自己前端都是囫囵吞枣,java基础学的都够呛,飘来飘去没有做什么实事,不过发现好多讲师技术博客写的真的不错,没事还是多看看视频,无聊的时候就看看博客吧,后来发现老男孩的linux讲的不错也看了下,这是教人做事,哪里是讲课,后来linux实在没时间学,意外接触到了python被这门语言迷住了,代码这的好简洁,能说自己能算上入门了,剩下的时间就是能把django框架看能不能啃完吧,那是有时间的情况吧,后来因为一个女老师讲的go语言,意外地接触下go,听说go语言开发的性能是python的几十倍,在这竞争力这么大的环境下,我的想法是如果有时间好好啃啃这两个python+go,那java呢?暂时放放吧,如果要搞算法方面可以去看看,不过我还是想保持持续学习的心,虽然自己是大专,智商没有那些大佬高,不过至少自己还在努力吧,希望自己不要抱着恐惧的心去学习,而是抱着热爱友好的心去学习,别因为别人说这个很难就不去学他,谁说java学起来很难,还好吧,没别人说的那么恐怖&lt;/p&gt;
&lt;p&gt;​ 放回脚下,自己终于知道为什么还是这么菜了,很多以前不理解的东西也理解了,比如在学习ES6的时候,能够跟python的一些知识联系起来,node也没有想象中那么难,现在看看一年前看的珠峰的相关视频,竟然真正的看的懂了,能理解他为什么这么做了, 还是再三提醒自己别以抵制的心去学习,在学习前一定要觉得它很简单,这么才能真正的有信心去学,对于学习,我觉得最重要的是是自信和自律,这是老男孩的讲师说的,觉得挺不错了就记录下来,那么这么样才能正常,在长达的一段时间类,我一直在看别人的博客,把ES6,css88,掘金...的博客看了很多,慢慢重新找回了,前端的美妙,还是那句话,回归基础,老板说的&quot;好好回顾你的原生&quot;,&lt;/p&gt;
&lt;h3 id=&quot;即将到来的2019&quot;&gt;即将到来的2019&lt;/h3&gt;
&lt;p&gt;​ 应该给自己定定目标,虽然18年的目标,也以笑笑而过无奈的表情飘过了&lt;/p&gt;
&lt;blockquote readability=&quot;35&quot;&gt;
&lt;p&gt;能撸完lodash源码&lt;/p&gt;
&lt;p&gt;能把react学会&lt;/p&gt;
&lt;p&gt;node看上去不是那么陌生&lt;/p&gt;
&lt;p&gt;还有那句回归基础,回归基础,&lt;/p&gt;
&lt;p&gt;继续保持好奇的心去学习&lt;/p&gt;
&lt;p&gt;犀牛书能不能啃完&lt;/p&gt;
&lt;p&gt;能去成都去吃吃吃&lt;/p&gt;
&lt;p&gt;别跳跳跳,要稳稳稳,能不能稳一年,稳住能赢&lt;/p&gt;
&lt;p&gt;坚持写博客,博客通过博客才会知道自己都在干嘛,不忘初心&lt;/p&gt;
&lt;p&gt;别让父母那么辛苦,虽然还是扛起来家里的大梁,但是也希望自己能够为家里分担点&lt;/p&gt;
&lt;p&gt;不去外地了,抽出时间陪陪妈妈, 给弟弟多来来鸡汤&lt;/p&gt;
&lt;p&gt;别把工资看的那么重,成长很重要(命重要!important)&lt;/p&gt;
&lt;p&gt;能不能有腹肌(不忘初心,健身还是要拾起来)&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sat, 29 Dec 2018 15:27:00 +0000</pubDate>
<dc:creator>房东家的猫</dc:creator>
<og:description>过去的2018 自己有没有值得有意义的地方呢? 没有, 自己有没有认识新的异性朋友呢? 没有, 自己都在忙啥呢? 敲代码,然后发现敲坏了一个键盘,换了HHKB,一个字舒服,还有就是通宵把一部电视剧看完</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fangdongdemao/p/10198346.html</dc:identifier>
</item>
<item>
<title>2018年终总结暨这些年的折腾 - ytkah</title>
<link>http://www.cnblogs.com/ytkah/p/i2018.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ytkah/p/i2018.html</guid>
<description>&lt;p&gt;　　２０１８马上就要走向尾声了，在这辞旧迎新的日子里适合发表一些感慨，回顾这一年走过的路和这些年的历程，然后展望一下２０１９年以及往后的时光。&lt;/p&gt;
&lt;p&gt;　　2018年，离开呆了好多年的厦门来到深圳，节奏更快了，竞争也更大了，但是水平也可以提升很快了。一线城市有很多高手可以交流学习，但是你得想好要学什么、怎么去提问，不能问太低级的问题，高手愿意回答你问题也是需要时间的，所以要把问题准备得充分一些具体一点。还有接触新项目先去看文档，到网上找找有没相关的解决方法。希望你能去问google而不是BD，去问Stack Overflow而不是BD，这是在网上看到的一句标语，很有个性，也很好用。&lt;/p&gt;
&lt;p&gt;　　2018学了很多Linux运维的技能，几个命令就能让你提升很多的开发速度；2018学了全球最流行的PHP框架Laravel，还用它搭建了电商系统，包括高性能无限级分类、众筹商品管理、众筹商品下单逻辑、众筹商品结束逻辑、使用分期付款支付订单、计算分期付款逾期费、分期付款订单的退款、给商品增加属性、使用 Elasticsearch 重构商品搜索模块、分面搜索、相似商品查询（类似于亚马逊的『商品推荐』功能）、Elasticsearch 的索引迁移、秒杀商品管理、秒杀商品下单逻辑、秒杀接口性能优化、编写部署脚本、多机部署实现负载均衡等。&lt;/p&gt;
&lt;p&gt;　　2018参与了ERP的制作与实施，感受了它复杂的业务和缜密的逻辑，企业正是需要建立完善的系统才能做大做强走得更远！肯德基麦当劳等那些大型企业哪个没有自己一套健全的系统来支撑她们的成长？把那些流程正规化、系统化、电子化，减少时间成本/提高效率不正是资本寒冬中企业所渴求的吗？&lt;/p&gt;
&lt;p&gt;　　回望这些年的折腾&lt;/p&gt;
&lt;p&gt;　　09 - 10年 第三方博客平台&lt;br/&gt;　　那时刚从学校出来，还带着一点文艺气息，喜欢发表一点自己的思想，那段时间不定时更新了一些文章，自我感觉有些成就感，可惜后面那个网站改版下线还是怎么的，好像是博客中国，后面账号密码都忘记了。&lt;/p&gt;
&lt;p&gt;　　那时还接触了淘宝店铺，感觉好神奇，居然可以在业余时间通过网上卖东西赚了点小钱，虽然不多但还是很兴奋。年轻气盛想着做点更宏伟的事情就没继续经营了，如果坚持到现在至少也有皇冠了吧？&lt;/p&gt;
&lt;p&gt;　　10 -13年 Zencart、Magento、Wordpress、Drupal、Joomla&lt;br/&gt;　　那段时间从事外贸行业，通过Zencart、Magento自建站建商城，做好站内优化，在第三方博客、论坛等平台发布外部链接提升排名。还用Wordpress、Drupal、Joomla搭建博客站引流，然后把流量导给商城进行转化。那时候谷歌排名相对比较容易做上去，可是支付通道不是很稳定，账号被冻结，有点心灰意冷。加上一些其他因素后面就转战国内市场了。&lt;/p&gt;
&lt;p&gt;　　13 - 18年 Dedecms、帝国cms、ThinkPHP、CI&lt;br/&gt;　　机缘巧合进了一家比较大型的集团，从dedecms的改造到帝国cms的深度开发，从移动网页加速器MIP改造到熊掌号搭建，从单站到CI框架多站管理系统，从Excel批量操作到ThinkPHP营销系统的开发，从不算特别酷炫的PPT到逻辑清晰的思维导图制作，从公众平台二次开发到TP后台API开发，从https部署到小程序上线，一路走来，踩了不少坑，也填了很多坑，都记录在这个博客里www.cnblogs.com/ytkah，满满当当地记录了5年3个月，总算有了一点小成就，在465228个开发者博客中排第262位，感谢各位一直以来对我不离不弃的支持，我会继续记录点点滴滴，我们一起成长，一同进步！&lt;/p&gt;
&lt;p&gt;　　展望2019及未来，移动互联网将继续进化，APP还是一个重要的承载体，虽然流量都被全球各大科技公司瓜分，但是守住细分领域自己一亩三分地还是很有必要的，积累用户，做好服务，变现逐步！Webapp可能作为一个衍生品得到广泛发展。它们共同的点是通过API来连接，所以写好接口才是硬道理。&lt;br/&gt;　　Python的运用。大数据经常被人谈及，数据从何而来？通过各个平台、app、网站数据的收集，分析，过滤，生成报告，这些都可以用python来处理，并且有很多成熟的库可以直接用了。那还不赶紧深入得学习？&lt;br/&gt;　　AI人工智能。最了解你的以后可能不是你自己或别人，因为机器更懂你！让AI帮你处理问题比你自己做得更好！&lt;/p&gt;
&lt;p&gt;　　Fighting！！！&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;　　- 2018.12.29晚&lt;/p&gt;
</description>
<pubDate>Sat, 29 Dec 2018 14:16:00 +0000</pubDate>
<dc:creator>ytkah</dc:creator>
<og:description>２０１８马上就要走向尾声了，在这辞旧迎新的日子里适合发表一些感慨，回顾这一年走过的路和这些年的历程，然后展望一下２０１９年以及往后的时光。 2018年，离开呆了好多年的厦门来到深圳，节奏更快了，竞争也</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ytkah/p/i2018.html</dc:identifier>
</item>
<item>
<title>编程：从前有一个傻呆程序员，老婆交给他一项任务，他办了四次才满意 - 石桥码农</title>
<link>http://www.cnblogs.com/sban/p/10198086.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sban/p/10198086.html</guid>
<description>&lt;p&gt;从前有一个傻呆程序员，他老婆交给他一项任务：“去买3斤橙子，买最大最甜最便宜的脐橙”。&lt;/p&gt;

&lt;p&gt;普通人买水果直接去店里就买了，但程序员不同。程序员心道：“大，好分辨，甜，不好分辩。水果店老板肯定不让每个橙子都试吃一下的”。于是问Siri，Siri说：“一般橙子屁股上有脐圈的，是母橙，母橙比较甜”。就这样通过调研，甜度辨别的技术难题解决了。&lt;/p&gt;

&lt;p&gt;接下来程序员开始策划去哪里买。经Siri调查，小区里共有4家水果店。程序员心道：“这4家店每家都可能卖橙子，也都有可能是最便宜的。如果冒然去了A店买，而C店才是最便宜的，就失去了做事的严谨性，回来可能挨骂。严谨的做法应该是货比三家，每家都看看并把价格记下来，然后选一家价格最低的购买。但是，应该先去哪家看价格呢？理论上应该先去离家的店，最后去离家最远的店。”&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic1.zhimg.com/80/v2-e65ce847cbe93558208566d253f80124_hd.jpg&quot; alt=&quot;&quot; width=&quot;694&quot; data-caption=&quot;&quot; data-size=&quot;small&quot; data-rawwidth=&quot;694&quot; data-rawheight=&quot;459&quot; data-original=&quot;https://pic1.zhimg.com/v2-e65ce847cbe93558208566d253f80124_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-e65ce847cbe93558208566d253f80124_b.jpg&quot;/&gt;&lt;/p&gt;

&lt;p&gt;经大致估算，4家店按离家距离排序，依次是ABCD。程序员应该先去A店。但估算毕竟是不严谨的，于是程序员请出百度地图，在地图上一一标上家和4家店的GPS坐标，再以水果店的GPS坐标分别计算离家的距离。最后得出结论，顺序依次是CABD（因为C店是直接距离，店距离排序逻辑略）。&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic4.zhimg.com/80/v2-5b89b3c35f6ccbe26554aa3e83f41853_hd.jpg&quot; alt=&quot;&quot; width=&quot;599&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;599&quot; data-rawheight=&quot;314&quot; data-original=&quot;https://pic4.zhimg.com/v2-5b89b3c35f6ccbe26554aa3e83f41853_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-5b89b3c35f6ccbe26554aa3e83f41853_b.jpg&quot;/&gt;&lt;/p&gt;

&lt;p&gt;于是程序员去C店，得到一个结果，然后又分别去ABD各店，最终得出A店返回无穷大。A店可能没有脐橙或有效货存不足。其它3家店，B店最便宜。程序员决定去B店购买。此时程序员老婆打来了电话，说“叫你买个橙子怎么去这么半天！”，程序员道：“目标已经锁定，即将完成任务”。&lt;/p&gt;

&lt;p&gt;程序员到了B店，不敢耽搁，马上开始了选脐橙的逻辑：&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic3.zhimg.com/80/v2-721b1db8bd1faa9035c394ef96451d9a_hd.jpg&quot; alt=&quot;&quot; width=&quot;621&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;621&quot; data-rawheight=&quot;665&quot; data-original=&quot;https://pic3.zhimg.com/v2-721b1db8bd1faa9035c394ef96451d9a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-721b1db8bd1faa9035c394ef96451d9a_b.jpg&quot;/&gt;&lt;/p&gt;

&lt;p&gt;半小时后，程序员拎着水果回到了家。老婆骂他：“怎么买水果比种果树都慢！”程序员开始反思，这个买水果的流程是不是还有很多优化的空间？&lt;/p&gt;

&lt;p&gt;第二次买橙子时，净化数据源与冒泡排序这两个循环，程序员将它们合在了一起：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/567788/201812/567788-20181229220026776-18016021.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;由于减少了时间复杂度，并且略去了第一次技术调研、系统架构的时间，这一次只用了20分钟，但老婆大人还是嫌慢：“别人买水果几分种，你买水果20分钟！”&lt;/p&gt;

&lt;p&gt;第三次买水果，程序员不再使用单只手的冒泡排序，而使用两只手的快速排序法，左手向右比较，右手向左比较（算法过于复杂，不作伪码展示了）。这次用了15分钟，但老婆大人仍然不满意。&lt;/p&gt;

&lt;p&gt;第四次买水果，程序员优化了进店询价逻辑。前几次买水果，程序员要了老板的微信，这次出发前先给4家老板群发了一条微信息：“老板，今天脐橙还有没有，多少钱一斤？”&lt;/p&gt;

&lt;p&gt;这次用多线程问询，替代了之前的单线程走路问询，只用了5分钟就完成了任务。老婆满意了。&lt;/p&gt;

&lt;p&gt;程序员感叹道：“程序优化果然是无止境啊！但貌似目前的逻辑还可以再优化，譬如历次购买水果第一优先选择基本都是B店，下次可以直接去B店。在去的路上向4家老板发微信询价，大概率答案还是B店。如果不是，进店前还有时间调整路线，这是执行与问询的多线程。”&lt;/p&gt;

&lt;p&gt;你能从这个程序员买橙子的故事中，看出编程难在哪里吗？&lt;/p&gt;

&lt;p&gt;2018年12月29日&lt;/p&gt;

&lt;p&gt;本文首发于微信公众号“艺述思维”：&lt;a class=&quot; wrap external&quot; href=&quot;http://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/5-dRz2u1od76sG8eT0ClgA&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot; data-za-detail-view-id=&quot;1043&quot;&gt;从前有一个傻呆程序员，老婆交给他一项任务，他办了四次才满意&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 29 Dec 2018 13:57:00 +0000</pubDate>
<dc:creator>石桥码农</dc:creator>
<og:description>从前有一个傻呆程序员，他老婆交给他一项任务：“去买3斤橙子，买最大最甜最便宜的脐橙”。 普通人买水果直接去店里就买了，但程序员不同。程序员心道：“大，好分辨，甜，不好分辩。水果店老板肯定不让每个橙子都</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sban/p/10198086.html</dc:identifier>
</item>
<item>
<title>python的partial()用法说明 - 骏马金龙</title>
<link>http://www.cnblogs.com/f-ck-need-u/p/10198013.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/f-ck-need-u/p/10198013.html</guid>
<description>&lt;p&gt;在functools模块中有一个工具partial()，可以用来&quot;冻结&quot;一个函数的参数，并返回&quot;冻结&quot;参数后的新函数。&lt;/p&gt;
&lt;p&gt;很简单的解释，也是&lt;a href=&quot;https://docs.python.org/3/library/functools.html#functools.partial&quot;&gt;官方手册&lt;/a&gt;给的示例。对于int()函数，它可以将给定的数值转换成十进制整数，转换时可以指定以几进制的方式解析给定的数。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 以10进制解析123，并转换成10进制整数
&amp;gt;&amp;gt;&amp;gt; int(&quot;123&quot;)
123

# 以2进制解析10101，并转换成10进制整数
&amp;gt;&amp;gt;&amp;gt; int(&quot;10101&quot;, base=2)
21

# 以13进制解析&quot;abc12c&quot;，并转换成10进制整数
&amp;gt;&amp;gt;&amp;gt; int(&quot;abc12c&quot;, base=13)
4053672&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在不想这样指定&lt;code&gt;base=2&lt;/code&gt;参数来将二进制转换为10进制整数了，而是像普通函数一样，直接指定待转换的值即可。于是，定义另外一个函数来封装int()，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def inttwo(x):
    return int(x, base=2)

inttwo(&quot;10101&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;functools中提供的partial()就是做类似事情的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;inttwo = partial(int, base=2)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它表示int()中指定参数base=2，也就是&quot;冻结&quot;了这个参数。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from functools import partial
&amp;gt;&amp;gt;&amp;gt; inttwo = partial(int,base=2)
&amp;gt;&amp;gt;&amp;gt; inttwo(&quot;10101&quot;)
21&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;之所以&quot;冻结&quot;加上了引号，是因为可以在inttwo()中再次指定参数来覆盖partial()中&quot;冻结&quot;的参数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; inttwo(&quot;10101&quot;,base=10)
10101&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;回头再看partial()的定义：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;functools.partial(func, *args, **keywords)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从它的定义不难知道，不仅仅是像int()中base这样的kw参数格式，位置参数args也一样能&quot;冻结&quot;。&lt;/p&gt;
&lt;p&gt;partial()返回的其实是一个partial对象，这个对象包含了3个特殊的属性：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; dir(inttwo)
[...... 'args', 'func', 'keywords']&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;func&lt;/code&gt;表示该对象所封装的原始函数&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;args&lt;/code&gt;表示&quot;冻结&quot;的位置参数列表&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;keywords&lt;/code&gt;表示&quot;冻结&quot;的关键字参数&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; inttwo.func
&amp;lt;class 'int'&amp;gt;
&amp;gt;&amp;gt;&amp;gt; inttwo.args
()
&amp;gt;&amp;gt;&amp;gt; inttwo.keywords
{'base': 2}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另外需要注意的是，partial()不会保留封装函数的元数据，比如注释文档、注解等。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; def myfunc(x:int, y:int) -&amp;gt; int:
...     ''' sum x + y '''
...     return x + y


# 函数元数据信息
&amp;gt;&amp;gt;&amp;gt; myfunc.__doc__
' sum x + y '
&amp;gt;&amp;gt;&amp;gt; myfunc.__annotations__
{'x': &amp;lt;class 'int'&amp;gt;, 'y': &amp;lt;class 'int'&amp;gt;, 'return': &amp;lt;class 'int'&amp;gt;}

# partial()包装后的函数，没有函数元数据
&amp;gt;&amp;gt;&amp;gt; newfunc = functools.partial(myfunc,y=3)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以如果需要这些元数据，必须自己手动将元数据赋值给partial对象：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; newfunc.__doc__ = myfunc.__doc__
&amp;gt;&amp;gt;&amp;gt; newfunc.__annotations__ = myfunc.__annotations__
&amp;gt;&amp;gt;&amp;gt; newfunc.__doc__
' sum x + y '
&amp;gt;&amp;gt;&amp;gt; newfunc.__annotations__
{'x': &amp;lt;class 'int'&amp;gt;, 'y': &amp;lt;class 'int'&amp;gt;, 'return': &amp;lt;class 'int'&amp;gt;}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后，除了partial()可以将函数的参数&quot;冻结&quot;，functools还提供了partialmethod()将方法的参数&quot;冻结&quot;，但基本上用不上，就连partial()也很少用。&lt;/p&gt;
</description>
<pubDate>Sat, 29 Dec 2018 13:32:00 +0000</pubDate>
<dc:creator>骏马金龙</dc:creator>
<og:description>在functools模块中有一个工具partial()，可以用来</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/f-ck-need-u/p/10198013.html</dc:identifier>
</item>
<item>
<title>我是如何将页面加载时间从6S降到2S的？ - 我的世界只因有你</title>
<link>http://www.cnblogs.com/yuyong970919/p/10197754.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuyong970919/p/10197754.html</guid>
<description>&lt;h3&gt;写在前面&lt;/h3&gt;
&lt;p&gt;生活在信息爆炸的今天，我们每天不得不面对和过滤海量的信息--无疑是焦躁和浮动的，这就意味着用户对你站点投入的时间可能是及其吝啬的（当然有一些刚需站点除外）。&lt;/p&gt;
&lt;p&gt;如何给用户提供迅速的响应就显得十分重要了，这可能成为你留住用户的关键。即使网站设计的再优秀，功能再完美，但是响应的巨慢，用户的耐心很快会被耗光，这可能成为他最后一次访问，这绝对不是危言耸听，最近有幸参与到了公司海外站点项目，对于这点深有体会。&lt;/p&gt;
&lt;h3&gt;问题的复盘&lt;/h3&gt;
&lt;p&gt;某一天海外运营告知说最近几天的海外站点pv,uv下降严重，希望技术帮忙查看一下原因。WTF，这跟技术有毛线关系，该用的都用了，TM的页面不吸引人，用户不想来，我能怎么办？事实证明不要太自信。&lt;/p&gt;
&lt;p&gt;搬来梯子，熟练的打开海外站点，速度还可以，这个时候差点就给pass了，幸好去看了一下世界各个地区的加载时间后发现，有些地区的加载时间简直不能看。好吧，实锤。&lt;/p&gt;
&lt;p&gt;在查找慢速过程中收获很多决定记录下来。（在这里强烈安利一个可以检测站点 全球各个地区加载时间的网站 https://www.dotcom-tools.com/website-speed-test.aspx ，真的强烈推荐）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文章不包含压缩文件、图片，增加资源域名等等雅虎军规中提到的内容，因为是这些都是必须的。如果你还没有实践的话，建议先遵循再来看。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;预备知识&lt;/h3&gt;
&lt;p&gt;在开始分析和解决之前，惯例先来简单介绍一下涉及的知识点，这样大家可能更加有代入感，也算有个铺垫。&lt;/p&gt;
&lt;h4&gt;DNS&lt;/h4&gt;
&lt;p&gt;这个大家应该是很熟悉的，每天都在用的东西&lt;/p&gt;
&lt;p&gt;说的通俗点，它就是一个用来将ip地址和域名相互映射的数据库，帮助人们更加方便的使用互联网，再也不用记住那些复杂的服务器地址，直接输入服务器地址所绑定域名就可以访问，例如 juejin.im，多好记。&lt;/p&gt;
&lt;h4&gt;CDN&lt;/h4&gt;
&lt;p&gt;内容分发网络（Content delivery network）其实就是一种透过互联网互相连接的计算机网络系统。利用最靠近每位用户的服务器，更快、更可靠地将资源发送给用户。&lt;strong&gt;特点就是高性能、可扩展性及低成本&lt;/strong&gt;。国内两云的这项服务打的不可开胶。&lt;/p&gt;
&lt;p&gt;由于篇幅的原因这里就不详细介绍了。对它不熟悉的或者想要温习一下的 https://zh.wikipedia.org/wiki/%E5%85%A7%E5%AE%B9%E5%82%B3%E9%81%9E%E7%B6%B2%E8%B7%AF 。我觉得主要有两个因素来判断CDN服务的优劣---命中率和节点数量。&lt;/p&gt;
&lt;p&gt;命中率意味着是否回源，回源的请求会打到你的服务器上，那么加载时间就取决与用户与你服务器的通讯状态了，说白了就是听天由命。&lt;/p&gt;
&lt;p&gt;节点数多意味着可供用户选择的响应节点多，优中选优，不必多说了，优秀。&lt;/p&gt;
&lt;h4&gt;网页加载时间&lt;/h4&gt;
&lt;p&gt;网页加载时间其实可以看作是页面响应时间。那么，它是由哪些部分组成的？影响因素都有哪些？哪些我们是可以优化的？ 上一张神图，帮助理解（这是优化过后的截图）&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz/MpGQUHiaib4ib6n0WBiaCgTRWCaQVqlBjd88v7hSIiay85Zb7EPJwIS6PCv9nRibTYDBZ2KDibzS1OY70F0P9JEdzicelw/640?wx_fmt=other&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; width=&quot;16&quot; height=&quot;16&quot; border=&quot;0&quot; vspace=&quot;0&quot; data-ratio=&quot;1.2175925925925926&quot; data-type=&quot;other&quot; data-w=&quot;432&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/MpGQUHiaib4ib6n0WBiaCgTRWCaQVqlBjd88v7hSIiay85Zb7EPJwIS6PCv9nRibTYDBZ2KDibzS1OY70F0P9JEdzicelw/640?wx_fmt=other&quot; data-fail=&quot;0&quot;/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/12/5/1677ea8ab4fb7a01?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;开始分析&lt;/h3&gt;
&lt;p&gt;说完了预备的知识点，我们开始按照上图开始撸一遍吧&lt;/p&gt;
&lt;h4&gt;DNS Time&lt;/h4&gt;
&lt;p&gt;DNS lookup time，就是寻找域名对应ip地址的过程，这个过程时间长短与选择的服务商有关。&lt;strong&gt;在查慢速问题这个可能会被忽略，但是不同服务商差距那是相当大&lt;/strong&gt;，我们原来选择的那家，简直不要太坑（就不点名了），后来换了 Cloudflare，瞬间清爽了。&lt;/p&gt;
&lt;p&gt;这里再次安利，推荐一个网站 https://www.dnsperf.com/ ，&lt;strong&gt;既可以查看不同服务商的DNS lookup time，还可以查看具体的波动，更加可以通过域名查看它在各个地区的DNS lookup time&lt;/strong&gt;，简直太好用了，赶紧保存吧。&lt;/p&gt;
&lt;p&gt;上一组换之前和之后的对比图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/12/6/16781bd1bdc4bc66?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/12/6/16781b453cbc04be?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot;/&gt;&lt;img title=&quot;&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz/MpGQUHiaib4ib6n0WBiaCgTRWCaQVqlBjd885rYClk8opHWylicOycRbJRNVByCHguCkqDXNSdCGs11djejRBqqSUyA/640?wx_fmt=other&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; width=&quot;16&quot; height=&quot;16&quot; border=&quot;0&quot; vspace=&quot;0&quot; data-ratio=&quot;0.8147368421052632&quot; data-type=&quot;other&quot; data-w=&quot;950&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/MpGQUHiaib4ib6n0WBiaCgTRWCaQVqlBjd885rYClk8opHWylicOycRbJRNVByCHguCkqDXNSdCGs11djejRBqqSUyA/640?wx_fmt=other&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz/MpGQUHiaib4ib6n0WBiaCgTRWCaQVqlBjd88VrJhvgrKaz93AMjDhknXLLVUrdElXs05iaPV6VLATMqHRujI0A6o8Ug/640?wx_fmt=other&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; width=&quot;16&quot; height=&quot;16&quot; border=&quot;0&quot; vspace=&quot;0&quot; data-ratio=&quot;0.8163265306122449&quot; data-type=&quot;other&quot; data-w=&quot;1176&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/MpGQUHiaib4ib6n0WBiaCgTRWCaQVqlBjd88VrJhvgrKaz93AMjDhknXLLVUrdElXs05iaPV6VLATMqHRujI0A6o8Ug/640?wx_fmt=other&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;p&gt;全绿色了有没有，看着有种很爽的感觉，你可以看一看这一项为我们省了多少时间&lt;/p&gt;
&lt;h4&gt;Connect Time and SSl Time&lt;/h4&gt;
&lt;p&gt;一个是http网络连接用时，另一个是SSl协议用时，优化空间不大，pass。&lt;/p&gt;
&lt;h4&gt;Request Time&lt;/h4&gt;
&lt;p&gt;见名知意系列。&lt;/p&gt;
&lt;h4&gt;First Byte Time&lt;/h4&gt;
&lt;p&gt;表示浏览器在从服务器接收第一个字节数据之前需要等待多长时间。获取该数据所需的时间越长, 显示页面所需的时间就越长。&lt;/p&gt;
&lt;p&gt;这部分主要能做的就是使用CDN和优化后端性能。&lt;/p&gt;
&lt;ul class=&quot; list-paddingleft-2&quot; readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;CDN 原来使用的是某云的服务，查看日志发现命中率较低，回源较多，在加上节点数量一般。换成了aws，同样为我们节省了很多加载时间（注册和开通相对麻烦，但是为了用户体验这些都是值得的）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;后端性能优化 如何进行后端优化可以写几本书毫不夸张，但是我们做的就是加配置，有钱人性。啊哈哈哈哈&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;Response Time&lt;/h3&gt;
&lt;p&gt;这部分做的就是页面的静态化还有就是开启服务端的gzip功能，具体方法请google。别小看这个功能，真真可以节约时间。&lt;/p&gt;
&lt;h3&gt;dig&lt;/h3&gt;
&lt;p&gt;想要深入理解DNS查询过程和原理，这个命令是不可或缺的 。通过它你可以灵活、清晰的查看域名DNS解析及其过程，帮助理解。&lt;/p&gt;
&lt;p&gt;下面以taobao为例，说一下过程（这里指的是没有缓存的情况下）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/12/6/16782011e14f3ffc?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot;/&gt;&lt;img title=&quot;&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz/MpGQUHiaib4ib6n0WBiaCgTRWCaQVqlBjd88SlNT7ib9W9oZl1CqpE8HHBicGcdiaPKeq5iaxUkdUoiaxQlp5u1JkCuL7EA/640?wx_fmt=other&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; width=&quot;16&quot; height=&quot;16&quot; border=&quot;0&quot; vspace=&quot;0&quot; data-ratio=&quot;1.372375690607735&quot; data-type=&quot;other&quot; data-w=&quot;905&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/MpGQUHiaib4ib6n0WBiaCgTRWCaQVqlBjd88SlNT7ib9W9oZl1CqpE8HHBicGcdiaPKeq5iaxUkdUoiaxQlp5u1JkCuL7EA/640?wx_fmt=other&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1.输入taobao.com后，直接为你服务的DNS（简称为H吧）会将请求报告给最高等级服务器&quot;.&quot; &lt;strong&gt;(这些最高等级DNS服务器称为root, 就是图中最开始站在食物链顶端的13个，但并不是13台机器，它们使用了任播https://zh.wikipedia.org/zh/%E4%BB%BB%E6%92%AD 技术可以在全球设立镜像节点，想想以现在的网络请求的量级来说13台肯定不现实。具体的镜像分布可以参考这里https://zh.wikipedia.org/wiki/%E6%A0%B9%E7%B6%B2%E5%9F%9F%E5%90%8D%E7%A8%B1%E4%BC%BA%E6%9C%8D%E5%99%A8 ，这些主机的内容都是同步的）&lt;/strong&gt; ，然后最高等级服务器告诉它你去找.com的DNS，我不管。&lt;/p&gt;
&lt;p&gt;2.得到这个响应后，H又将请求报告给 .com，.com告诉它，你去找taobao的DNS吧，我不管&lt;/p&gt;
&lt;p&gt;3.得到这个响应后，H又将请求报告给taobao,taobao告诉它，我不管，你去找我四个小弟吧。&lt;/p&gt;
&lt;ul class=&quot; list-paddingleft-2&quot;&gt;&lt;li&gt;
&lt;p&gt;ns4.taobao.com.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ns5.taobao.com.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ns6.taobao.com.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ns7.taobao.com.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;最后被分配给了ns4，从这得到了最终ip，完成了DNS lookup&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;看到评论中有疑问，其实可以多试几次，会分配到不同的小弟，但是都有淘宝的A记录，所以都可以解析 也可以dig不同的ns4，ns5，ns6，ns7 具像化的看一看。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;最后&lt;/h3&gt;
&lt;p&gt;通过这次排查慢速的过程，不止学到了技术方面可以改进的地方，也真正认识到了对于网站来说，时间就是生命。加载时间长，用户真的是不惯着你。 优秀的站点之所以优秀，就在于把每个细节都做的很优雅。&lt;/p&gt;

&lt;p&gt;转载：&lt;a href=&quot;http://www.xjqyc.cn/contents/2/43.html&quot; target=&quot;_blank&quot;&gt;http://www.xjqyc.cn/contents/2/43.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 29 Dec 2018 12:02:00 +0000</pubDate>
<dc:creator>我的世界只因有你</dc:creator>
<og:description>写在前面 生活在信息爆炸的今天，我们每天不得不面对和过滤海量的信息--无疑是焦躁和浮动的，这就意味着用户对你站点投入的时间可能是及其吝啬的（当然有一些刚需站点除外）。 如何给用户提供迅速的响应就显得十</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuyong970919/p/10197754.html</dc:identifier>
</item>
<item>
<title>打开这个文档，你就被控制 - yuleitest</title>
<link>http://www.cnblogs.com/yuleitest/p/10197720.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuleitest/p/10197720.html</guid>
<description>&lt;p&gt;对于攻击者或渗透测试者来说，最大的挑战是绕过一个目标的安全控制。&lt;/p&gt;
&lt;p&gt;想要攻击目标网络中的系统往往很困难，通常要绕过防火墙，代理服务器，入侵检测系统等等防护体系。&lt;/p&gt;
&lt;p&gt;一个最好的解决思路就是：将客户端作为攻击目标，与网络中的客户端进行交互，客户端防护相对薄弱。借助客户端访问目标系统的便利性、通过社会工程的方法，一旦攻击成功并且建立了稳定的通信，攻击者便能连接到目标网络。事实证明这种类型的攻击是绕过网络安全控制最有效的方法之一。&lt;/p&gt;
&lt;p&gt;通过本文你将学到——客户端攻击技术—宏攻击&lt;/p&gt;

&lt;h2&gt;VBScript宏攻击&lt;/h2&gt;
&lt;p&gt;    VBScript是一个微软开发的脚本语言。它目前已经集成在了Windows中，最典型的就是Office，因此，它成为了客户端攻击首选语言。&lt;/p&gt;
&lt;p&gt;    下面我们将用到Msfvnom命令行为&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/741432/201812/741432-20181229195921449-650807860.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;执行后我们收到了payload，该payload分为两部分&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/741432/201812/741432-20181229195922048-2077013881.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第一部分是宏代码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/741432/201812/741432-20181229195922590-642203834.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第二部分是shellcode代码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/741432/201812/741432-20181229195923275-1286153423.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来，我们新建一个WORD/PPT/EXCEL&lt;/p&gt;
&lt;p&gt;打开&lt;span&gt;工具-视图-宏&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/741432/201812/741432-20181229195923853-1384356132.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;创建一个名为test的宏，再将宏代码拷贝到Sub test()到End Sub区间&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/741432/201812/741432-20181229195924178-590767520.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后将shellcode代码拷贝至文档主体&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/741432/201812/741432-20181229195924519-579456504.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了使攻击成为可能，最后通过改变字体颜色，加入适当内容等等以混淆隐藏shellcode&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/741432/201812/741432-20181229195924889-523927851.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后我们将在Metasoloit中设置一个监听会话&lt;/p&gt;
&lt;p&gt;将文件发送给目标，一旦打开，就会在攻击者控制台生成一个反向Shell&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/741432/201812/741432-20181229195925315-523807290.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;目标上的Windows上没有任何感知&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/741432/201812/741432-20181229195925842-1576669345.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最重要的是它会在你打开所有文档中运行，而且无需启用宏。之所以会如此，因为它已经在所有文档中生效，它将生成一个后门在C盘用户临时文件中，关掉文档也无济于事，因为它已经运行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/741432/201812/741432-20181229195926188-264375659.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/741432/201812/741432-20181229195926462-867289749.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;宏当前的设置情况&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/741432/201812/741432-20181229195926759-1905500703.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;分析&lt;/h2&gt;
&lt;p&gt;通过木马查杀，效果感人。大部分杀毒引擎都无法检测到。因此它具有很强的免杀能力&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/741432/201812/741432-20181229195927093-835047030.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过查看本地资源监视器，我们可以找到一个通讯进程，指向的则是刚才设置的主机IP和8080端口&lt;/p&gt;
&lt;p&gt;根据pid查找文件路径的命令&lt;/p&gt;
&lt;p&gt;wmic process get name,executablepath,processid|findstr 5256找到文件在C盘USERS下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/741432/201812/741432-20181229195927434-1160097782.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;宏病毒清理&lt;/h2&gt;
&lt;p&gt;在生成宏的位置删除宏，找到文件删除该后门文件即可&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/741432/201812/741432-20181229195927728-1469451044.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/741432/201812/741432-20181229195928022-1815125723.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 29 Dec 2018 11:52:00 +0000</pubDate>
<dc:creator>yuleitest</dc:creator>
<og:description>前言： 对于攻击者或渗透测试者来说，最大的挑战是绕过一个目标的安全控制。 想要攻击目标网络中的系统往往很困难，通常要绕过防火墙，代理服务器，入侵检测系统等等防护体系。 一个最好的解决思路就是：将客户端</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuleitest/p/10197720.html</dc:identifier>
</item>
<item>
<title>Bootstrap - 伍萬磊</title>
<link>http://www.cnblogs.com/wanlei/p/10197657.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wanlei/p/10197657.html</guid>
<description>&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;一、简介&lt;/span&gt;&lt;/h2&gt;
&lt;ul&gt;&lt;li class=&quot;md-fences md-end-block ty-contain-cm modeLoaded&quot;&gt;
&lt;h4&gt;&lt;span&gt;Bootstrap是美国Twitter公司的设计师Mark Otto和Jacob Thornton合作基于HTML、CSS、JavaScript 开发的简洁、直观、强悍的前端开发框架，使得 Web 开发更加快捷。&lt;/span&gt;&lt;/h4&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4&gt;凡是使用过Bootstrap的开发者，都不在乎做这么两件事情：复制and粘贴。&lt;/h4&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4&gt;它用于开发响应式布局、移动设备优先的 WEB 项目&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;二、安装&lt;/span&gt;&lt;/h2&gt;
&lt;h4 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;1、本地链接&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot; md-link&quot;&gt;&lt;a href=&quot;https://github.com/twbs/bootstrap/releases/download/v3.3.7/bootstrap-3.3.7-dist.zip&quot;&gt;&lt;span&gt;官网下载&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;2、CDN&lt;/span&gt;&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('0e30141d-caeb-4868-bc34-12c7ce755ff3')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_0e30141d-caeb-4868-bc34-12c7ce755ff3&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_0e30141d-caeb-4868-bc34-12c7ce755ff3&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('0e30141d-caeb-4868-bc34-12c7ce755ff3',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_0e30141d-caeb-4868-bc34-12c7ce755ff3&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&amp;lt;!-- 最新版本的 Bootstrap 核心 CSS 文件 --&amp;gt;
&amp;lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/css/bootstrap.min.css&quot; integrity=&quot;sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u&quot; crossorigin=&quot;anonymous&quot;&amp;gt;&lt;span&gt;
​
&lt;/span&gt;&amp;lt;!-- 可选的 Bootstrap 主题文件（一般不用引入） --&amp;gt;
&amp;lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/css/bootstrap-theme.min.css&quot; integrity=&quot;sha384-rHyoN1iRsVXV4nD0JutlnGaslCJuC7uwjduW9SVrLvRYooPp2bWYgmgJQIXwl/Sp&quot; crossorigin=&quot;anonymous&quot;&amp;gt;&lt;span&gt;
​
&lt;/span&gt;&amp;lt;!-- 最新的 Bootstrap 核心 JavaScript 文件 --&amp;gt;
&amp;lt;script src=&quot;https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/js/bootstrap.min.js&quot; integrity=&quot;sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa&quot; crossorigin=&quot;anonymous&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;引入：&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 在head标签上部导入bs的css &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;link &lt;/span&gt;&lt;span&gt;rel&lt;/span&gt;&lt;span&gt;=&quot;stylesheet&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;bootstrap-3.3.7-dist/css/bootstrap.css&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 再导入自定义修改的css &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;link &lt;/span&gt;&lt;span&gt;rel&lt;/span&gt;&lt;span&gt;=&quot;stylesheet&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;css/my.css&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; html代码结构 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;&lt;span&gt;
    ...
    
&lt;/span&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;bs的脚本依赖于jq, 所以要提前导入jq&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;脚本逻辑尽量放在html结构之下&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;js/jquery-3.3.1.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;bootstrap-3.3.7-dist/js/bootstrap.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;三、布局容器&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;Bootstrap 需要为页面内容和栅格系统包裹一个 .container 容器。我们提供了两个作此用处的类。&lt;span&gt;注意，由于 padding 等属性的原因，这两种 容器类不能互相嵌套。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;.container 类用于固定宽度并支持响应式布局的容器&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;div class=&quot;container&quot;&amp;gt;&lt;span&gt;
  ...
&lt;/span&gt;&amp;lt;/div&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;.container-fluid 类用于 100% 宽度，占据全部视口（viewport）的容器&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;div class=&quot;container-fluid&quot;&amp;gt;&lt;span&gt;
  ...
&lt;/span&gt;&amp;lt;/div&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot;&gt;&lt;li class=&quot;md-list-item&quot;&gt;
&lt;h4 class=&quot;md-end-block&quot;&gt;&lt;span&gt;固定宽度：.container&lt;/span&gt;&lt;/h4&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot;&gt;
&lt;h4 class=&quot;md-end-block&quot;&gt;&lt;span&gt;流式布局：.container-fluid&lt;/span&gt;&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;总结; 两种容器(container | container-fluid)默认都有左右15px padding&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;固定宽度容器(采用响应式布局)&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;container&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 行: .row, 可以取消容器的默认左右15px padding&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;row&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1 &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;bg-info&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;标题&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;动态宽度布局(采用流式布局)&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;container-fluid&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;row&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1 &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;bg-info&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;标题&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;四、响应式布局&lt;/span&gt;&lt;/h2&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;概念：开发了一种自适应写法，即一次开发，处处显示！&lt;/h3&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot;&gt;&lt;li class=&quot;md-list-item&quot;&gt;
&lt;h4 class=&quot;md-end-block&quot;&gt;&lt;span&gt;超小屏幕：小于 768px&lt;/span&gt;&lt;/h4&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot;&gt;
&lt;h4 class=&quot;md-end-block&quot;&gt;&lt;span&gt;小屏幕：大于等于 768px&lt;/span&gt;&lt;/h4&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot;&gt;
&lt;h4 class=&quot;md-end-block&quot;&gt;&lt;span&gt;中等屏幕：大于等于 992px&lt;/span&gt;&lt;/h4&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot;&gt;
&lt;h4 class=&quot;md-end-block&quot;&gt;&lt;span&gt;大屏幕：大于等于 1200px&lt;/span&gt;&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;五、删格系统&lt;/span&gt;&lt;/h2&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;1、概念&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-fences md-end-block ty-contain-cm modeLoaded&quot;&gt;&lt;span&gt;&lt;span&gt;将父级可用宽度(content)均分为12等份！&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Bootstrap 提供了一套响应式、移动设备优先的流式栅格系统，随着屏幕或视口（viewport）尺寸的增加，系统会自动分为最多12列&lt;/p&gt;
&lt;p&gt;栅格系统用于通过一系列的行（row）与列（column）的组合来创建页面布局，你的内容就可以放入这些创建好的布局中。下面就介绍一下 Bootstrap 栅格系统的工作原理：&lt;/p&gt;
&lt;pre class=&quot;md-fences md-end-block ty-contain-cm modeLoaded&quot;&gt;
&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1442172/201812/1442172-20181229190840277-71462083.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;span&gt;栅格参数：&lt;/span&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1442172/201812/1442172-20181229190927022-953604575.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;使用单一的一组 .col-md-* 栅格类，就可以创建一个基本的栅格系统，在手机和平板设备上一开始是堆叠在一起的（超小屏幕到小屏幕这一范围），在桌面（中等）屏幕设备上变为水平排列。所有“列（column）必须放在 ” .row 内。&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;2、列比&lt;/span&gt;&lt;/h3&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot;&gt;&lt;li class=&quot;md-list-item&quot;&gt;
&lt;h4 class=&quot;md-end-block&quot;&gt;&lt;span&gt;超小屏幕：.col-xs-*&lt;/span&gt;&lt;/h4&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot;&gt;
&lt;h4 class=&quot;md-end-block&quot;&gt;&lt;span&gt;小屏幕：.col-sm-*&lt;/span&gt;&lt;/h4&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot;&gt;
&lt;h4 class=&quot;md-end-block&quot;&gt;&lt;span&gt;中等屏幕：.col-md-*&lt;/span&gt;&lt;/h4&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot;&gt;
&lt;h4 class=&quot;md-end-block&quot;&gt;&lt;span&gt;大屏幕：.col-lg-*&lt;/span&gt;&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h6 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;只设置小屏列比会影响大屏列比；只设置大屏列比小屏时会撑满屏幕&lt;/span&gt;&lt;/h6&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;3、行&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;div class=&quot;row&quot;&amp;gt;&amp;lt;/div&amp;gt;
&lt;span&gt;...
&lt;/span&gt;&amp;lt;div class=&quot;row&quot;&amp;gt;&amp;lt;/div&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;4、列偏移&lt;/span&gt;&lt;/h3&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot;&gt;&lt;li class=&quot;md-list-item&quot;&gt;
&lt;h4 class=&quot;md-end-block&quot;&gt;&lt;span&gt;超小屏幕：.col-xs-offset-*&lt;/span&gt;&lt;/h4&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot;&gt;
&lt;h4 class=&quot;md-end-block&quot;&gt;&lt;span&gt;小屏幕：.col-sm-offset-*&lt;/span&gt;&lt;/h4&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot;&gt;
&lt;h4 class=&quot;md-end-block&quot;&gt;&lt;span&gt;中等屏幕：.col-md-offset-*&lt;/span&gt;&lt;/h4&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot;&gt;
&lt;h4 class=&quot;md-end-block&quot;&gt;&lt;span&gt;大屏幕：.col-lg-offset-*&lt;/span&gt;&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;六、辅助类&lt;/span&gt;&lt;/h2&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;1、 情境背景色&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;p class=&quot;bg-primary&quot;&amp;gt;...&amp;lt;/p&amp;gt;
&amp;lt;p class=&quot;bg-success&quot;&amp;gt;...&amp;lt;/p&amp;gt;
&amp;lt;p class=&quot;bg-info&quot;&amp;gt;...&amp;lt;/p&amp;gt;
&amp;lt;p class=&quot;bg-warning&quot;&amp;gt;...&amp;lt;/p&amp;gt;
&amp;lt;p class=&quot;bg-danger&quot;&amp;gt;...&amp;lt;/p&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;2、快速浮动&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;div class=&quot;pull-left&quot;&amp;gt;...&amp;lt;/div&amp;gt;
&amp;lt;div class=&quot;pull-right&quot;&amp;gt;...&amp;lt;/div&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;3、快速清浮动&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;div class=&quot;clearfix&quot;&amp;gt;...&amp;lt;/div&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;4、显隐&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;div class=&quot;show&quot;&amp;gt;...&amp;lt;/div&amp;gt;
&amp;lt;div class=&quot;hidden&quot;&amp;gt;...&amp;lt;/div&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;七、字体图标&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;i class=&quot;glyphicon glyphicon-*&quot;&amp;gt;&amp;lt;/i&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;八、组件&lt;/span&gt;&lt;/h2&gt;
&lt;pre class=&quot;md-fences md-end-block ty-contain-cm&quot;&gt;
&lt;a title=&quot;官方文档&quot; href=&quot;https://v3.bootcss.com/components/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;官方文档&lt;/span&gt;&lt;/a&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 29 Dec 2018 11:35:00 +0000</pubDate>
<dc:creator>伍萬磊</dc:creator>
<og:description>Bootstrap 一、简介 Bootstrap是美国Twitter公司的设计师Mark Otto和Jacob Thornton合作基于HTML、CSS、JavaScript 开发的简洁、直观、强悍的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wanlei/p/10197657.html</dc:identifier>
</item>
</channel>
</rss>