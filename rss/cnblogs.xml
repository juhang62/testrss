<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>【疑难杂症】windows下如何有效重装印象笔记 - 弗兰克的猫</title>
<link>http://www.cnblogs.com/mfrank/p/11136171.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mfrank/p/11136171.html</guid>
<description>&lt;p&gt;重装这么简单的操作还用得着写篇文章吗？？emmmm，言之有理，简单的重装就是卸载后重新下载最新的安装包然后安装就完事了，这里说的肯定是不简单的重装【滑稽】。&lt;/p&gt;
&lt;p&gt;背景是这样的，之前在mac上对印象笔记的笔记本做了一次重新编排，并将很多没有用的文章做了删除，一顿操作猛如虎。重排一时爽，一直重排一直爽，但在window上打开印象笔记时，却发现了问题，点击同步后，就开始爱的魔力转圈圈，里面文章却半天没有反应，一开始我以为是因为调整的内容过多，所以同步需要时间，于是我早上把电脑放家里开启同步，就上班去了。晚上回来准备操作一波的时候，以为它再怎么慢也应该同步完了，结果一打开，发现它已经自闭了。。。&lt;/p&gt;
&lt;p&gt;于是我便想到了曲线救国的道路，先将印象笔记卸载，然后重新安装，这样应该就能直接把最新的内容同步过来。&lt;/p&gt;
&lt;p&gt;想法是好的，可是重装完之后，登陆后发现之前的旧笔记又一次出现在了我的眼前。。。联想到之前看的一篇关于印象笔记的文章，印象笔记为了加快操作效率，会把所有笔记都存储到本地，所以我猜想应该是本地缓存导致的，印象笔记会先查找本地缓存，没有的话再拉取服务器数据，所以删除掉本地缓存再重新安装应该就没有问题了。&lt;/p&gt;
&lt;p&gt;找到思路后，又开始了一波操作，打开印象笔记，工具-》选项-》打开数据库文件夹，数据库文件夹默认存放在c盘。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;C:\Users\[用户名]\Yinxiang Biji\Databases&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后退出印象笔记，直接删除整个Yinxiang Biji文件夹（操作要慎重，直接删除本地数据库会导致你尚未同步的数据无法同步到服务器而丢失，我这里这样操作只是因为想用服务器数据直接覆盖本地数据），再进行一次重装操作即可完成同步。&lt;/p&gt;
&lt;p&gt;虽然不是什么艰难的事情，但也是折腾了我好几个小时，所以记录一下，希望能对刚好有同样困扰的人有帮助。&lt;/p&gt;
</description>
<pubDate>Fri, 05 Jul 2019 00:41:00 +0000</pubDate>
<dc:creator>弗兰克的猫</dc:creator>
<og:description>重装这么简单的操作还用得着写篇文章吗？？emmmm，言之有理，简单的重装就是卸载后重新下载最新的安装包然后安装就完事了，这里说的肯定是不简单的重装【滑稽】。 背景是这样的，之前在mac上对印象笔记的笔</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mfrank/p/11136171.html</dc:identifier>
</item>
<item>
<title>数据库之MySQL的基本使用 - YifChan</title>
<link>http://www.cnblogs.com/yifchan/p/sql-1-1.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yifchan/p/sql-1-1.html</guid>
<description>&lt;h2&gt;数据库简介&lt;/h2&gt;
&lt;h3&gt;数据库&lt;/h3&gt;
&lt;p&gt;数据库就是一种特殊的文件，其中存储着需要的数据；&lt;br/&gt;关系型数据库核心元素：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;数据行(记录)&lt;/li&gt;
&lt;li&gt;数据列(字段)&lt;/li&gt;
&lt;li&gt;数据表(数据行的集合)&lt;/li&gt;
&lt;li&gt;数据库(数据表的集合)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Ubuntu进入数据库：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1.sudo -s;&lt;/li&gt;
&lt;li&gt;2.cd /var/lib/mysql;&lt;/li&gt;
&lt;li&gt;3.ls -h;&lt;/li&gt;
&lt;li&gt;4.cd 数据库名；&lt;/li&gt;
&lt;li&gt;5.ls&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;一个表中：&lt;br/&gt;一列---&amp;gt;一个字段&lt;br/&gt;一行---&amp;gt;一条记录&lt;/p&gt;
&lt;p&gt;字段和记录组成表；&lt;br/&gt;几个表组成一个数据库；&lt;/p&gt;
&lt;p&gt;一个大的系统可能有几个数据库，而几个数据库里面有很多表；&lt;/p&gt;


&lt;h3&gt;RDBMS&lt;/h3&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;Relational Database Management System&lt;/p&gt;
&lt;p&gt;通过表来表示关系型&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当前主要使用两种类型的数据库：关系型数据库、非关系型数据库，本部分主要讨论关系型数据库，对于非关系型数据库会在后面学习；&lt;/p&gt;
&lt;p&gt;所谓的关系型数据库RDBMS，是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据；&lt;/p&gt;
&lt;p&gt;查看数据库排名:https://db-engines.com/en/ranking&lt;/p&gt;

&lt;p&gt;关系型数据库的主要产品：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;oracle：在以前的大型项目中使用,银行,电信等项目&lt;/li&gt;
&lt;li&gt;mysql：web时代使用最广泛的关系型数据库&lt;/li&gt;
&lt;li&gt;ms sql server：在微软的项目中使用&lt;/li&gt;
&lt;li&gt;sqlite：轻量级数据库，主要应用在移动平台&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;python中常用的数据库：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;mysql，关系型数据库，一般用来做网站，&lt;/li&gt;
&lt;li&gt;redis一般用来做缓存，&lt;/li&gt;
&lt;li&gt;MongoDB，非关系型数据库，一般做爬虫，用来存储非关系型数据；&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;RDBMS和数据库的关系&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1618401/201907/1618401-20190704220348359-480208794.png&quot; alt=&quot;&quot; width=&quot;543&quot; height=&quot;271&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为RDBMS和数据库的关系，所以我们只需要关心在数据库客户端通过SQL语句操作数据库服务端的数据库表即可；&lt;/p&gt;

&lt;h3&gt;SQL&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Structured Query Language&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;SQL是结构化查询语言，是一种用来操作RDBMS的数据库语言，当前关系型数据库都支持使用SQL语言进行操作,也就是说可以通过 SQL 操作 oracle,sql server,mysql,sqlite 等等所有的关系型的数据库。&lt;/p&gt;
&lt;p&gt;SQL语句主要分为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;DQL：数据查询语言，用于对数据进行查询，如select&lt;/li&gt;
&lt;li&gt;DML：数据操作语言，对数据进行增加、修改、删除，如insert、udpate、delete&lt;/li&gt;
&lt;li&gt;TPL：事务处理语言，对事务进行处理，包括begin transaction、commit、rollback&lt;/li&gt;
&lt;li&gt;DCL：数据控制语言，进行授权与权限回收，如grant、revoke&lt;/li&gt;
&lt;li&gt;DDL：数据定义语言，进行数据库、表的管理等，如create、drop&lt;/li&gt;
&lt;li&gt;CCL：指针控制语言，通过控制指针完成表的操作，如declare cursor&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于web程序员来讲，重点是数据的crud（增删改查），必须熟练编写DQL、DML，能够编写DDL完成数据库、表的操作，其它语言如TPL、DCL、CCL了解即可；&lt;br/&gt;SQL 是一门特殊的语言,专门用来操作关系数据库；&lt;br/&gt;不区分大小写；&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;学习要求&lt;br/&gt;熟练掌握数据增删改查相关的 SQL 语句编写&lt;br/&gt;在 Python代码中操作数据就是通过 SQL 语句来操作数据&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建Connection连接&lt;/span&gt;
conn = connect(host=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, port=3306, user=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, password=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;mysql&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, database=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;python1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, charset=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 得Cursor对象&lt;/span&gt;
cs =&lt;span&gt; conn.cursor()
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 更新&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; sql = 'update students set name=&quot;刘邦&quot; where id=6'&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 删除&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; sql = 'delete from students where id=6'&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 执行select语句，并返回受影响的行数：查询一条学生数据&lt;/span&gt;
sql = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;select id,name from students where id = 7&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; sql = 'SELECT id,name FROM students WHERE id = 7'&lt;/span&gt;
count=&lt;span&gt;cs.execute(sql)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 打印受影响的行数&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(count)
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;MySQL 简介&lt;/h3&gt;
&lt;p&gt;MySQL官方网站：http://www.mysql.com&lt;/p&gt;
&lt;p&gt;MySQL是一个关系型数据库管理系统，由瑞典MySQL AB公司开发，后来被Sun公司收购，Sun公司后来又被Oracle公司收购，目前属于Oracle旗下产品&lt;/p&gt;

&lt;p&gt;特点&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用C和C++编写，并使用了多种编译器进行测试，保证源代码的可移植性&lt;/li&gt;
&lt;li&gt;支持多种操作系统，如Linux、Windows、AIX、FreeBSD、HP-UX、MacOS、NovellNetware、OpenBSD、OS/2 Wrap、Solaris等&lt;/li&gt;
&lt;li&gt;为多种编程语言提供了API，如C、C++、Python、Java、Perl、PHP、Eiffel、Ruby等&lt;/li&gt;
&lt;li&gt;支持多线程，充分利用CPU资源&lt;/li&gt;
&lt;li&gt;优化的SQL查询算法，有效地提高查询速度&lt;/li&gt;
&lt;li&gt;提供多语言支持，常见的编码如GB2312、BIG5、UTF8&lt;/li&gt;
&lt;li&gt;提供TCP/IP、ODBC和JDBC等多种数据库连接途径&lt;/li&gt;
&lt;li&gt;提供用于管理、检查、优化数据库操作的管理工具&lt;/li&gt;
&lt;li&gt;大型的数据库。可以处理拥有上千万条记录的大型数据库&lt;/li&gt;
&lt;li&gt;支持多种存储引擎&lt;/li&gt;
&lt;li&gt;MySQL 软件采用了双授权政策，它分为社区版和商业版，由于其体积小、速度快、总体拥有成本低，尤其是开放源码这一特点，一般中小型网站的开发都选择MySQL作为网站数据库&lt;/li&gt;
&lt;li&gt;MySQL使用标准的SQL数据语言形式&lt;/li&gt;
&lt;li&gt;Mysql是可以定制的，采用了GPL协议，你可以修改源码来开发自己的Mysql系统&lt;/li&gt;
&lt;li&gt;在线DDL更改功能&lt;/li&gt;
&lt;li&gt;复制全局事务标识&lt;/li&gt;
&lt;li&gt;复制无崩溃从机&lt;/li&gt;
&lt;li&gt;复制多线程从机&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;开源 免费 不要钱 使用范围广,跨平台支持性好,提供了多种语言调用的 API；&lt;/p&gt;
&lt;p&gt;是学习数据库开发的首选；&lt;/p&gt;

&lt;h2&gt;MySQL安装&lt;/h2&gt;
&lt;h3&gt;服务器端安装&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;安装服务器端：在终端中输入如下命令，回车后，然后按照提示输入&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
sudo apt-get install mysql-server
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;服务器用于接收客户端的请求、执行sql语句、管理数据库&lt;/li&gt;
&lt;li&gt;服务器端一般以服务方式管理，名称为mysql&lt;/li&gt;
&lt;li&gt;启动服务&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
sudo service mysql start
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看进程中是否存在mysql服务&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
ps ajx|grep mysql
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;停止服务&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
sudo service mysql stop
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;重启服务&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
sudo service mysql restart
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;配置&lt;br/&gt;配置文件目录为/etc/mysql/mysql.cnf&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1618401/201907/1618401-20190704223407294-797453298.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;进入conf.d目录，打开mysql.cnf，发现并没有配置&lt;/p&gt;
&lt;p&gt;进入mysql.conf.d目录，打开mysql.cnf，可以看到配置项&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1618401/201907/1618401-20190704223430858-2130504807.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;主要配置项如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
bind-address表示服务器绑定的ip，默认为127.0.0.1&lt;span&gt;

port表示端口，默认为3306

datadir表示数据库目录，默认为&lt;/span&gt;/var/lib/&lt;span&gt;mysql

general_log_file表示普通日志，默认为&lt;/span&gt;/var/log/mysql/&lt;span&gt;mysql.log

log_error表示错误日志，默认为&lt;/span&gt;/var/log/mysql/error.log
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;客户端安装&lt;/h3&gt;
&lt;p&gt;客户端为开发人员与dba使用，通过socket方式与服务端通信，常用的有navicat、命令行mysql&lt;/p&gt;
&lt;h4&gt;图形化界面客户端navicat&lt;/h4&gt;
&lt;p&gt;可以到&lt;a href=&quot;https://www.navicat.com.cn/&quot; target=&quot;_blank&quot;&gt;Navicat官网&lt;/a&gt;下载&lt;br/&gt;将压缩文件拷贝到ubuntu虚拟机中，放到桌面上，解压&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
tar zxvf navicat112_mysql_cs_x64.tar.gz
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;进入解压的目录，运行如下命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
./start_navicat
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;点两次取消后，点击“试用”按钮；&lt;/p&gt;
&lt;p&gt;问题一：中文乱码&lt;/p&gt;
&lt;p&gt;解决：打开start_navicat文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
将export LANG=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;en_US.UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;改为export LANG=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;zh_CN.UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;问题二：试用期&lt;br/&gt;解决：删除用户目录下的.navicat64目录&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
cd ~&lt;span&gt;
rm &lt;/span&gt;-r .navicat64
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;命令行客户端&lt;/h4&gt;
&lt;p&gt;在终端运行如下命令，按提示填写信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
sudo apt-get install mysql-client
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;详细连接的命令可以查看帮助文档&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
mysql --help
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最基本的连接命令如下，输入后回车&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
mysql -uroot -&lt;span&gt;proot
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; u后面的是用户名，p后面的是密码；&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;连接成功。&lt;/p&gt;
&lt;p&gt;按ctrl+d或输入如下命令退出&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
quit 或者 exit
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;数据完整性&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;一个数据库就是一个完整的业务单元，可以包含多张表，数据被存储在表中&lt;/li&gt;
&lt;li&gt;在表中为了更加准确的存储数据，保证数据的正确有效，可以在创建表的时候，为表添加一些强制性的验证，包括数据字段的类型、约束&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;数据类型&lt;/h3&gt;
&lt;p&gt;可以通过查看帮助文档查阅所有支持的数据类型&lt;/p&gt;
&lt;p&gt;使用数据类型的原则是：够用就行，尽量使用取值范围小的，而不用大的，这样可以更多的节省存储空间&lt;/p&gt;
&lt;p&gt;常用数据类型如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;整数：int，bit&lt;/li&gt;
&lt;li&gt;小数：decimal&lt;/li&gt;
&lt;li&gt;字符串：varchar,char&lt;/li&gt;
&lt;li&gt;日期时间: date, time, datetime&lt;/li&gt;
&lt;li&gt;枚举类型(enum)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;特别说明的类型如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;decimal表示浮点数，如decimal(5,2)表示共存5位数，小数占2位&lt;/li&gt;
&lt;li&gt;char表示固定长度的字符串，如char(3)，如果填充'ab'时会补一个空格为'ab '&lt;/li&gt;
&lt;li&gt;varchar表示可变长度的字符串，如varchar(3)，填充'ab'时就会存储'ab'&lt;/li&gt;
&lt;li&gt;字符串text表示存储大文本，当字符大于4000时推荐使用&lt;/li&gt;
&lt;li&gt;对于图片、音频、视频等文件，不存储在数据库中，而是上传到某个服务器上，然后在表中存储这个文件的保存路径&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;更全的数据类型可以参考 http://blog.csdn.net/anxpp/article/details/51284106&lt;/p&gt;
&lt;h3&gt;约束&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;主键primary key：物理上存储的顺序&lt;/li&gt;
&lt;li&gt;非空not null：此字段不允许填写空值&lt;/li&gt;
&lt;li&gt;惟一unique：此字段的值不允许重复&lt;/li&gt;
&lt;li&gt;默认default：当不填写此值时会使用默认值，如果填写时以填写为准&lt;/li&gt;
&lt;li&gt;外键foreign key：对关系字段进行约束，当为关系字段填写值时，会到关联的表中查询此值是否存在，如果存在则填写成功，如果不存在则填写失败并抛出异常&lt;/li&gt;
&lt;li&gt;说明：虽然外键约束可以保证数据的有效性，但是在进行数据的crud（增加、修改、删除、查询）时，都会降低数据库的性能，所以不推荐使用，那么数据的有效性怎么保证呢？答：可以在逻辑层进行控制&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;数值类型(常用)&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;类型&lt;/td&gt;
&lt;td&gt;字节大小&lt;/td&gt;
&lt;td&gt;有符号范围(Signed)&lt;/td&gt;
&lt;td&gt;无符号范围(Unsigned)&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;TINYINT&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;-128 ~ 127&lt;/td&gt;
&lt;td&gt;0 ~ 255&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;SMALLINT&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;-32768 ~ 32767&lt;/td&gt;
&lt;td&gt;0 ~ 65535&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;MEDIUMINT&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;-8388608 ~ 8388607&lt;/td&gt;
&lt;td&gt;0 ~ 16777215&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;INT/INTEGER&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;-2147483648 ~2147483647&lt;/td&gt;
&lt;td&gt;0 ~ 4294967295&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;BIGINT&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;-9223372036854775808 ~ 9223372036854775807&lt;/td&gt;
&lt;td&gt;0 ~ 18446744073709551615&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;   &lt;br/&gt;字符串&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;4.5&quot;&gt;&lt;tr&gt;&lt;td&gt;类型 &lt;/td&gt;
&lt;td&gt;字节大小&lt;/td&gt;
&lt;td&gt; 示例&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;CHAR&lt;/td&gt;
&lt;td&gt; 0-255&lt;/td&gt;
&lt;td&gt;类型:char(3) 输入 'ab', 实际存储为'ab ', 输入'abcd' 实际存储为 'abc'&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;VARCHAR&lt;/td&gt;
&lt;td&gt; 0-255&lt;/td&gt;
&lt;td&gt;类型:varchar(3) 输 'ab',实际存储为'ab', 输入'abcd',实际存储为'abc'&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;TEXT&lt;/td&gt;
&lt;td&gt; 0-65535&lt;/td&gt;
&lt;td&gt; 大文本&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;br/&gt;日期时间类型&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;类型&lt;/td&gt;
&lt;td&gt; 字节大小&lt;/td&gt;
&lt;td&gt; 示例&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;DATE&lt;/td&gt;
&lt;td&gt; 4&lt;/td&gt;
&lt;td&gt; '2020-01-01'&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;TIME&lt;/td&gt;
&lt;td&gt; 3&lt;/td&gt;
&lt;td&gt; '12:29:59'&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;DATETIME&lt;/td&gt;
&lt;td&gt; 8 &lt;/td&gt;
&lt;td&gt;'2020-01-01 12:29:59'&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;YEAR&lt;/td&gt;
&lt;td&gt; 1&lt;/td&gt;
&lt;td&gt; '2017'&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;TIMESTAMP&lt;/td&gt;
&lt;td&gt; 4&lt;/td&gt;
&lt;td&gt; '1970-01-01 00:00:01' UTC ~ '2038-01-01 00:00:01' UTC&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;

&lt;h2&gt;命令行脚本&lt;/h2&gt;
&lt;h3&gt;数据库的操作&lt;/h3&gt;
&lt;p&gt;sql语句最后需要有分号;结尾&lt;/p&gt;
&lt;p&gt;链接数据库&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
mysql -uroot -&lt;span&gt;p
mysql &lt;/span&gt;-uroot -pmysql
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;退出数据库&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
exit/quit/ctrl+d
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;查看所有数据库&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
show databases;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;创建数据库&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
create database 数据库名 charset=&lt;span&gt;utf8;

示例：
create database python04;
create database python05 charset=utf8;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用数据库&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;use 数据库的名字

示例：
use python05;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;删除数据库&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;drop database 数据库名;

示例：
drop database python04;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;查看创建数据库的语句&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
show crate database databasename;

示例：
show create database python04;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看当前使用的数据库&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
select database();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;显示数据库版本&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
select version();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;显示时间&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
select now();
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;数据表的操作&lt;/h3&gt;
&lt;p&gt;查看当前数据库中所有表&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
show tables;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;创建表&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;auto_increment表示自动增长&lt;/li&gt;
&lt;li&gt;not null 表示不能为空&lt;/li&gt;
&lt;li&gt;primary key 表示主键&lt;/li&gt;
&lt;li&gt;default 默认值&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;create table 数据表名字 (字段 类型 约束[, 字段 类型 约束]);

示例：
create table xxxxx(id int, name varchar(&lt;/span&gt;30&lt;span&gt;));
create table yyyyy(id int primary key &lt;/span&gt;&lt;span&gt;not&lt;/span&gt; null auto_increment, name varchar(30&lt;span&gt;));
create table zzzzz(
　　id int primary key &lt;/span&gt;&lt;span&gt;not&lt;/span&gt;&lt;span&gt; null auto_increment,
　　name varchar(&lt;/span&gt;30&lt;span&gt;)
);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;创建students表(id、name、age、high、gender、cls_id)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;create table students(
　　id int unsigned &lt;/span&gt;&lt;span&gt;not&lt;/span&gt;&lt;span&gt; null auto_increment primary key,
　　name varchar(&lt;/span&gt;30&lt;span&gt;),
　　age tinyint unsigned default 0,
　　high decimal(&lt;/span&gt;5,2&lt;span&gt;),
　　gender enum(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;男&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;女&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;中性&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;保密&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) default &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;保密&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
　　cls_id int unsigned default 0

);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;创建classes表(id、name)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;create table classes(
　　id int unsigned &lt;/span&gt;&lt;span&gt;not&lt;/span&gt;&lt;span&gt; null auto_increment primary key,
　　name varchar(&lt;/span&gt;30&lt;span&gt;)
);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;修改表-添加字段&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;alter table 表名 add 列名 类型;
例：
alter table students add birthday datetime;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修改表-修改字段：重命名版&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;alter table 表名 change 原名 新名 类型及约束;
例：
alter table students change birthday birth datetime &lt;/span&gt;&lt;span&gt;not&lt;/span&gt; null;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修改表-修改字段：不重命名版&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;alter table 表名 modify 列名 类型及约束;
例：
alter table students modify birth date &lt;/span&gt;&lt;span&gt;not&lt;/span&gt; null;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修改表-删除字段&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;alter table 表名 drop 列名;
例：
alter table students drop birthday;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;删除表&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;drop table 表名;
例：
drop table students;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看表结构&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
desc 表名;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看表的创建语句&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;show create table 表名;
例：
show create table classes;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;增删改查(curd)&lt;/h3&gt;
&lt;p&gt;curd的解释: 代表创建（Create）、更新（Update）、读取（Retrieve）和删除（Delete）&lt;/p&gt;
&lt;h4&gt;查询基本使用&lt;/h4&gt;
&lt;p&gt;查询所有列&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
select * &lt;span&gt;from&lt;/span&gt;&lt;span&gt; 表名;
例：
select &lt;/span&gt;* &lt;span&gt;from&lt;/span&gt; classes;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查询指定列&lt;br/&gt;可以使用as为列或表指定别名&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
select 列1,列2,... &lt;span&gt;from&lt;/span&gt;&lt;span&gt; 表名;
例：
select id,name &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; classes;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;增加&lt;/h4&gt;
&lt;p&gt;格式:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
INSERT [INTO] tb_name [(col_name,...)] {VALUES | VALUE} ({expr | DEFAULT},...),(...),...
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;说明：主键列是自动增长，但是在全列插入时需要占位，通常使用0或者 default 或者 null 来占位，插入成功后以实际数据为准&lt;br/&gt;全列插入：值的顺序与表中字段的顺序对应&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;insert into 表名 values(...)
例：
insert into students values(0,’郭靖‘,&lt;/span&gt;1,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;蒙古&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2016-1-2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;部分列插入：值的顺序与给出的列顺序对应&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;insert into 表名(列1,...) values(值1,...)
例：
insert into students(name,hometown,birthday) values(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;黄蓉&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;桃花岛&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2016-3-2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的语句一次可以向表中插入一行数据，还可以一次性插入多行数据，这样可以减少与数据库的通信&lt;br/&gt;全列多行插入：值的顺序与给出的列顺序对应&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;insert into 表名 values(...),(...)...;
例：
insert into classes values(0,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;python1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;),(0,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;python2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;insert into 表名(列1,...) values(值1,...),(值1,...)...;
例：
insert into students(name) values(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;杨康&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;),(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;杨过&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;),(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;小龙女&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;修改&lt;/h4&gt;
&lt;p&gt;格式:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 UPDATE tbname SET col1={expr1|DEFAULT} [,col2={expr2|default}]...[where 条件判断]
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
update 表名 set 列1=值1,列2=&lt;span&gt;值2... where 条件
例：
update students set gender&lt;/span&gt;=0,hometown=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;北京&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; where id=5;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;删除&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
DELETE FROM tbname [where 条件判断]
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
delete &lt;span&gt;from&lt;/span&gt;&lt;span&gt; 表名 where 条件
例：
delete &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; students where id=5;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;逻辑删除，本质就是修改操作&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
update students set isdelete=1 where id=1;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;增删改查示例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('541a8ca0-8e39-490e-b56f-489f71acbc0f')&quot; readability=&quot;61&quot;&gt;&lt;img id=&quot;code_img_closed_541a8ca0-8e39-490e-b56f-489f71acbc0f&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_541a8ca0-8e39-490e-b56f-489f71acbc0f&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('541a8ca0-8e39-490e-b56f-489f71acbc0f',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_541a8ca0-8e39-490e-b56f-489f71acbc0f&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;117&quot;&gt;
&lt;pre&gt;
--&lt;span&gt; 增删改查(curd)

    &lt;/span&gt;--&lt;span&gt; 增加
        &lt;/span&gt;--&lt;span&gt; 全列插入
        &lt;/span&gt;--&lt;span&gt; insert [into] 表名 values(...)
        &lt;/span&gt;--&lt;span&gt; 主键字段 可以用 0  null   default 来占位
        &lt;/span&gt;--&lt;span&gt; 向classes表中插入 一个班级
        insert into classes values(0, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;菜鸟班&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);


        &lt;/span&gt;+--------+-------------------------------------+------+-----+------------+----------------+
        | Field  | Type                                | Null | Key | Default    | Extra          |
        +--------+-------------------------------------+------+-----+------------+----------------+
        | id     | int(10) unsigned                    | NO   | PRI | NULL       | auto_increment |
        | name   | varchar(30)                         | YES  |     | NULL       |                |
        | age    | tinyint(3) unsigned                 | YES  |     | 0          |                |
        | gender | enum(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;男&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;女&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;中性&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;保密&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)       | YES  |     | 保密       |                |
        | cls_id | int(10) unsigned                    | YES  |     | NULL       |                |
        | birth  | date                                | YES  |     | 2000-01-01 |                |
        +--------+-------------------------------------+------+-----+------------+----------------+

        --&lt;span&gt; 向students表插入 一个学生信息
        insert into students values(0, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小李飞刀&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, 20, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;女&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, 1, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1990-01-01&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        insert into students values(null, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小李飞刀&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, 20, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;女&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, 1, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1990-01-01&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        insert into students values(default, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小李飞刀&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, 20, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;女&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, 1, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1990-01-01&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;--&lt;span&gt; 失败
        &lt;/span&gt;-- insert into students values(default, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小李飞刀&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, 20, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;第4性别&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, 1, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1990-02-01&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;-- 枚举中 的 下标从1 开始 1---“男” 2---&amp;gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;女&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;....
        insert into students values(default, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小李飞刀&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, 20, 1, 1, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1990-02-01&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;--&lt;span&gt; 部分插入
        &lt;/span&gt;--&lt;span&gt; insert into 表名(列1,...) values(值1,...)
        insert into students (name, gender) values (&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小乔&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, 2&lt;span&gt;);


        &lt;/span&gt;--&lt;span&gt; 多行插入
        insert into students (name, gender) values (&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;大乔&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, 2),(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;貂蝉&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, 2&lt;span&gt;);
        insert into students values(default, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;西施&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, 20, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;女&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, 1, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1990-01-01&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;), (default, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;王昭君&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, 20, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;女&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, 1, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1990-01-01&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);


    &lt;/span&gt;--&lt;span&gt; 修改
    &lt;/span&gt;-- update 表名 set 列1=值1,列2=&lt;span&gt;值2... where 条件;
        update students set gender&lt;/span&gt;=1; --&lt;span&gt; 全部都改
        update students set gender&lt;/span&gt;=1 where name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小李飞刀&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;; --&lt;span&gt; 只要name是小李飞刀的 全部的修改
        update students set gender&lt;/span&gt;=1 where id=3; --&lt;span&gt; 只要id为3的 进行修改
        update students set age&lt;/span&gt;=22, gender=1 where id=3; --&lt;span&gt; 只要id为3的 进行修改
    
    &lt;/span&gt;--&lt;span&gt; 查询基本使用
        &lt;/span&gt;--&lt;span&gt; 查询所有列
        &lt;/span&gt;-- select * &lt;span&gt;from&lt;/span&gt;&lt;span&gt; 表名;
        select &lt;/span&gt;* &lt;span&gt;from&lt;/span&gt;&lt;span&gt; students;

        &lt;/span&gt;---&lt;span&gt;定条件查询
        select &lt;/span&gt;* &lt;span&gt;from&lt;/span&gt; students where name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小李飞刀&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;; --&lt;span&gt; 查询 name为小李飞刀的所有信息
        select &lt;/span&gt;* &lt;span&gt;from&lt;/span&gt; students where id&amp;gt;3; --&lt;span&gt; 查询 name为小李飞刀的所有信息


        &lt;/span&gt;--&lt;span&gt; 查询指定列
        &lt;/span&gt;-- select 列1,列2,... &lt;span&gt;from&lt;/span&gt;&lt;span&gt; 表名;
        select name,gender &lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt; students;


        &lt;/span&gt;--&lt;span&gt; 可以使用as为列或表指定别名
        &lt;/span&gt;-- select 字段[as 别名] , 字段[as 别名] &lt;span&gt;from&lt;/span&gt;&lt;span&gt; 数据表 where ....;
        select name as 姓名,gender as 性别 &lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt; students;


        &lt;/span&gt;--&lt;span&gt; 字段的顺序
        select id as 序号, gender as 性别, name as 姓名 &lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt; students;
    

    &lt;/span&gt;--&lt;span&gt; 删除
        &lt;/span&gt;--&lt;span&gt; 物理删除
        &lt;/span&gt;-- delete &lt;span&gt;from&lt;/span&gt;&lt;span&gt; 表名 where 条件
        delete &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; students; --&lt;span&gt; 整个数据表中的所有数据全部删除
        delete &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; students where name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小李飞刀&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;--&lt;span&gt; 逻辑删除
        &lt;/span&gt;--&lt;span&gt; 用一个字段来表示 这条信息是否已经不能再使用了
        &lt;/span&gt;--&lt;span&gt; 给students表添加一个is_delete字段 bit 类型
        alter table students add is_delete bit default 0;
        update students set is_delete&lt;/span&gt;=1 where id=6;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;增删改查示例&lt;/span&gt;&lt;/div&gt;

</description>
<pubDate>Fri, 05 Jul 2019 00:30:00 +0000</pubDate>
<dc:creator>YifChan</dc:creator>
<og:description>数据库之MySQL的基本使用，内容包括 数据库简介，MySQL安装，数据完整性，命令行脚本。其中，数据库简介包括 数据库，RDBMS，RDBMS和数据库的关系，SQL，MySQL 简介；数据库安装包括</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yifchan/p/sql-1-1.html</dc:identifier>
</item>
<item>
<title>.Net之使用Jquery Ajax通过FormData对象异步提交图片文件到服务端保存并返回保存的图片路径 - 追逐时光</title>
<link>http://www.cnblogs.com/Can-daydayup/p/11124668.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Can-daydayup/p/11124668.html</guid>
<description>&lt;h2&gt;前言：&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　首先对于图片上传而言，在我们的项目开发中可以说出现的频率是相当的高的。这篇文章中，我将要描述的是在我们.Net中如何使用Jquery Ajax通过FormData对象异步提交图片文件到后台保存，并返回保存的图片路径展示出图片，实现一个无刷新的异步图片上传的过程，当然这里我讲解的是单张图片的保存过程，对于多图片上传的话其实我们只需要在type='file'文本框中加上一个multiple可多选，然后获取input中的文件数组遍历向后台提交感兴趣的话可以尝试，不过下一篇博客将会讲解如何使用Layui上传多张图片到服务端保存。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;FormData对象概述：&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　FormData对象是H5中的一个新特性，用以将数据编译成键值对，以便用XMLHttpRequest来发送数据。其主要用于发送表单数据，但亦可用于发送带键数据(keyed data)，而独立于表单使用。如果表单enctype属性设为multipart/form-data ，则会使用表单的submit()方法来发送数据，从而，发送数据具有同样形式。比起普通的ajax,使用FormData的最大优点就是我们可以异步上传一个二进制文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;关于FormData对象的使用参考文章：&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/FormData/Using_FormData_Objects&quot;&gt;https://developer.mozilla.org/zh-CN/docs/Web/API/FormData/Using_FormData_Objects&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;Jquery Ajax通过FormData对象异步提交图片文件：&lt;/h2&gt;
&lt;h3&gt;HTML中选中图片的按钮：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;头像&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;tuxiang-up&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;headPortrait&quot;&lt;/span&gt;&lt;span&gt; style&lt;/span&gt;&lt;span&gt;=&quot;background-image:url(/Content/ExSys/images/ktoux.jpg))&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;file&quot;&lt;/span&gt;&lt;span&gt; onchange&lt;/span&gt;&lt;span&gt;=&quot;uploadImage(this)&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;点击上传按钮后，图片缩略图以上级背景图片显示&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt; 
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Jquery中FormData二进制文件对象拼接和提交：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用户头像修改&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; uploadImage(obj) {
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; formData = &lt;span&gt;new&lt;/span&gt; FormData();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建FormData对象，以键值对的方式拼接form表单数据（multipart/form-data，图片媒体文件）&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;获取input中的文件列表信息&lt;/span&gt;
 &lt;span&gt;var&lt;/span&gt; files = $(obj).prop(&quot;files&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;拼接图片文件流信息&lt;/span&gt;
console.log(files[0&lt;span&gt;]);
formData.append(&lt;/span&gt;&quot;file&quot;, files[0&lt;span&gt;]);
$.ajax({
url: &lt;/span&gt;&quot;/FileUpload/FileLoad/&quot;&lt;span&gt;,
type: &lt;/span&gt;'POST'&lt;span&gt;,
data: formData,
async: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
dataType: &lt;/span&gt;&quot;json&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 告诉jQuery不要去处理发送的数据&lt;/span&gt;
processData: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 告诉jQuery不要去设置Content-Type请求头&lt;/span&gt;
contentType: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
beforeSend: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
console.log(&lt;/span&gt;&quot;正在进行，请稍候&quot;&lt;span&gt;);
},
success: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (data) {
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (data.isSuccess) {
console.log(data.path);
console.log(&lt;/span&gt;&quot;图片上传成功&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;动态赋值&lt;/span&gt;
$(&quot;#headPortrait&quot;).css(&quot;background-image&quot;, &quot;url(&quot; + data.path + &quot;)&quot;&lt;span&gt;);
} 
&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
console.log(&lt;/span&gt;&quot;网络异常，请稍后再试&quot;&lt;span&gt;);
}
},
 error: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (data) {
console.log(&lt;/span&gt;&quot;error2&quot;&lt;span&gt;);
}
});
}
&lt;/span&gt;&amp;lt;/script&amp;gt;    　
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;服务端接收Ajax异步提交的二进制图片文件信息，并保存：&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FileUploadController : Controller
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 对验证和处理 HTML 窗体中的输入数据所需的信息进行封装，如FromData拼接而成的文件
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;  6&lt;/span&gt; &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;context&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;FemContext对验证和处理html窗体中输入的数据进行封装&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;  8&lt;/span&gt; &lt;span&gt;[HttpPost]
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ActionResult FileLoad(FormContext context)
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt; &lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt; HttpPostedFileBase httpPostedFileBase = Request.Files[&lt;span&gt;0&lt;/span&gt;];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取二进制图片文件流&lt;/span&gt;
&lt;span&gt; 12&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (httpPostedFileBase != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt; &lt;span&gt;try&lt;/span&gt;
&lt;span&gt; 15&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt; ControllerContext.HttpContext.Request.ContentEncoding = Encoding.GetEncoding(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt; ControllerContext.HttpContext.Response.Charset = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt; 
&lt;span&gt; 19&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; fileName = Path.GetFileName(httpPostedFileBase.FileName);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;原始文件名称&lt;/span&gt;
&lt;span&gt; 20&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; fileExtension = Path.GetExtension(fileName);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文件扩展名&lt;/span&gt;
&lt;span&gt; 21&lt;/span&gt; 
&lt;span&gt; 22&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] fileData = ReadFileBytes(httpPostedFileBase);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文件流转化为二进制字节&lt;/span&gt;
&lt;span&gt; 23&lt;/span&gt; 
&lt;span&gt; 24&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; result = SaveFile(fileExtension, fileData);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文件保存&lt;/span&gt;
&lt;span&gt; 25&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(result))
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt; &lt;span&gt;return&lt;/span&gt; Json(&lt;span&gt;new&lt;/span&gt; { isSuccess = &lt;span&gt;false&lt;/span&gt;, path = &lt;span&gt;&quot;&quot;&lt;/span&gt;,errorMsg= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;上传文件失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;});
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt; 
&lt;span&gt; 30&lt;/span&gt; &lt;span&gt;return&lt;/span&gt; Json(&lt;span&gt;new&lt;/span&gt; { isSuccess = &lt;span&gt;true&lt;/span&gt;, path =&lt;span&gt; result });
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt; &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt; &lt;span&gt;return&lt;/span&gt; Json(&lt;span&gt;new&lt;/span&gt; { isSuccess = &lt;span&gt;false&lt;/span&gt;, path = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt; });
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt; &lt;span&gt;else&lt;/span&gt;
&lt;span&gt; 38&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt; &lt;span&gt;return&lt;/span&gt; Json(&lt;span&gt;new&lt;/span&gt; { isSuccess = &lt;span&gt;false&lt;/span&gt;, path = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt; });
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt; 
&lt;span&gt; 43&lt;/span&gt; 
&lt;span&gt; 44&lt;/span&gt; &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 45&lt;/span&gt; &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 将文件流转化为二进制字节
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt; &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 47&lt;/span&gt; &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;fileData&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;图片文件流&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 48&lt;/span&gt; &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt; 49&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] ReadFileBytes(HttpPostedFileBase fileData)
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] data;
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt; &lt;span&gt;using&lt;/span&gt; (Stream inputStream =&lt;span&gt; fileData.InputStream)
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt; MemoryStream memoryStream = inputStream &lt;span&gt;as&lt;/span&gt;&lt;span&gt; MemoryStream;
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (memoryStream == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt; memoryStream = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MemoryStream();
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt; &lt;span&gt;inputStream.CopyTo(memoryStream);
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt; data =&lt;span&gt; memoryStream.ToArray();
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt; &lt;span&gt;return&lt;/span&gt;&lt;span&gt; data;
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt; 
&lt;span&gt; 65&lt;/span&gt; &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 66&lt;/span&gt; &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 保存文件
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt; &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 68&lt;/span&gt; &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;fileExtension&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;文件扩展名&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 69&lt;/span&gt; &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;fileData&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;图片二进制文件信息&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 70&lt;/span&gt; &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt; 71&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; SaveFile(&lt;span&gt;string&lt;/span&gt; fileExtension, &lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] fileData)
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; result;
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt; &lt;span&gt;try&lt;/span&gt;
&lt;span&gt; 75&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt; 
&lt;span&gt; 77&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; saveName = Guid.NewGuid().ToString()+ fileExtension; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存文件名称
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt; 
&lt;span&gt; 79&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 文件上传后的保存路径&lt;/span&gt;
&lt;span&gt; 80&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; basePath = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UploadFile&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; saveDir = DateTime.Now.ToString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yyyy-MM-dd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; savePath =&lt;span&gt; System.IO.Path.Combine(saveDir, saveName);
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt; 
&lt;span&gt; 84&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; serverDir = System.IO.Path.Combine(Server.MapPath(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;~/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;), basePath, saveDir);
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;System.IO.Directory.Exists(serverDir))
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt; &lt;span&gt;System.IO.Directory.CreateDirectory(serverDir);
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; fileNme = System.IO.Path.Combine(serverDir, saveName);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存文件完整路径&lt;/span&gt;
&lt;span&gt; 90&lt;/span&gt; System.IO.File.WriteAllBytes(fileNme, fileData);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;WriteAllBytes创建一个新的文件，按照对应的文件流写入，假如已存在则覆盖
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回完整的图片保存地址&lt;/span&gt;
&lt;span&gt; 92&lt;/span&gt; result=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+basePath + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + saveDir + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; saveName;
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt; &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception)
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt; result = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;发生错误&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt; &lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;&lt;/span&gt;
&lt;span&gt;100&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;


</description>
<pubDate>Fri, 05 Jul 2019 00:27:00 +0000</pubDate>
<dc:creator>追逐时光</dc:creator>
<og:description>前言： 首先对于图片上传而言，在我们的项目开发中可以说出现的频率是相当的高的。这篇文章中，我将要描述的是在我们.Net中如何使用Jquery Ajax通过FormData对象异步提交图片文件到后台保存</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Can-daydayup/p/11124668.html</dc:identifier>
</item>
<item>
<title>我在“美菜”读的书 - 2J</title>
<link>http://www.cnblogs.com/jijunjian/p/11136041.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jijunjian/p/11136041.html</guid>
<description>&lt;p&gt;　    今天，翻完《分布式系统原理介绍.ppt》了最后一页，感觉有点失落：又一本好书看完了（不知，大伙儿是否也是这样的）。惆怅中，才发现，自去年10月，进入美菜后，7个月的时间，已经看完了6-7本书了，这个战绩绝对是之前无法想像的，但是它就是发生了。&lt;/p&gt;
&lt;p&gt;　　 说起，看书这事儿吧，也前吧，也不爱，觉得程序员，就应该看代码，撸代码，还是受到前任领导（我们都叫他：惠丰）与 前任同事（我们都叫他：大师）的影响。&lt;/p&gt;
&lt;p&gt;　　与前任领导，一起工作了8-9年，见证了他，因为读书而优秀，因为优秀而读书。&lt;/p&gt;
&lt;p&gt;　　大师，有钱而优秀的大师，经常看书，看到11，12点，因为他说，如果不做这行，只能回家管生意。原来，工作可以不仅仅是为了生活。　&lt;/p&gt;
&lt;p&gt;        在读书过程中，也遇到一个现同事，我们叫他猴哥，第一次，看到他ipad上的几百页的读书笔记，逻辑清晰，字迹漂亮，原来ipad，可以这么用。&lt;/p&gt;
&lt;p&gt;       当然，还有一个重要原因：媳妇儿，也开始天天看书，我自然也不能落后了。&lt;/p&gt;
&lt;p&gt;        以下，给大伙儿，分享下，我们的读书清单，也希望大伙儿，给推荐一些书籍。　　　　　　　　　　　　　　　　　　　　　　　&lt;/p&gt;

&lt;p&gt;　                                                                         　&lt;img src=&quot;https://img2018.cnblogs.com/blog/88102/201907/88102-20190705000229042-796547587.jpg&quot; alt=&quot;&quot; width=&quot;196&quot; height=&quot;349&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这应该是相当经典的一本书了，据说做为java程序员，都应该看好几遍，在大学就蠢蠢欲动，当时，睡我对面的军军同学（这也是唯一，现在还能，一起吃饭聊天的大学朋友了），也买了一本；最终，自己也没去看，也许是因为，时候未到吧（哈哈）。&lt;/p&gt;
&lt;p&gt;       在上一份工作的，最后两月里，终于，从同事的显示器下（经典，居然用来垫显示器），拿起了这本书，这是一本，你拿起来，就很难放下的书，因为太厚，两个“厚”，800多页，肯定厚，另一个，就是内容非常丰富，每点节都讲得非常详细。比如，&lt;/p&gt;
&lt;p&gt;内部类一章，比如 Class 类一节。&lt;/p&gt;
&lt;p&gt;       印象最深的，也是关于 讲 Class 类 的一节，以前，觉得 &amp;lt;&amp;gt; 就是表示list，因为只会写  List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;()， 理解 Class 类，才能继续理解 泛型，以及 .class文件，与 Class的关系。&lt;/p&gt;
&lt;p&gt;        最终，在6月25号，算是看了第一遍，从哈米到美菜，历时差不多9个月，收货良多。&lt;/p&gt;


&lt;p&gt;                                                                                    &lt;img src=&quot;https://img2018.cnblogs.com/blog/88102/201907/88102-20190705002931121-262434559.jpg&quot; alt=&quot;&quot; width=&quot;302&quot; height=&quot;537&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　 进入美菜后，总会遇到一些，线上问题，关于Cpu，内存之类，总是感觉无从下手，一次与小王子（一活泼同事，熟称小王子）聊天时，他推荐了这本书。这是一本，你拿起来，就不会放下的书，原理清晰，理论结合实践。&lt;/p&gt;
&lt;p&gt;        对于各种垃圾回收器工作流程介绍，由浅入深，让人记忆深刻。&lt;/p&gt;
&lt;p&gt;　　 Class文件结构介绍，虽然无法逃脱枯燥，但是这也是各类字节码操作的基础，值得枯燥。&lt;/p&gt;
&lt;p&gt;　　 对于锁的底层实现，有相当细致的讲解，对后面，学习并发编程中，锁的概念，与实现，就会轻松不少。&lt;/p&gt;
&lt;p&gt;　　 因为是看的电子书，非常方便随地阅读，其中不少章节，来回看了好多遍，任感觉意犹未尽。值得，多读几遍。&lt;/p&gt;
&lt;p&gt;　　 虽然截图是，15小时，阅读完成，加上一些代码实操，时间也不少。于，4月10号首次阅读完成。&lt;/p&gt;


&lt;p&gt;                                                                                        &lt;img src=&quot;https://img2018.cnblogs.com/blog/88102/201907/88102-20190705004352192-1381691205.jpg&quot; alt=&quot;&quot; width=&quot;288&quot; height=&quot;512&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　 并发，是一个java程序员，绕不开的话题，本来想看《并发编程实战》，苦于没有电子书，什么百度读书，豆瓣读书，多看阅读，都找了，就是没有，看pdf文件吧，又感觉没有哪个app，在手机上有好的体验。最后就退而求其次了，选择了这本。&lt;/p&gt;
&lt;p&gt;         以前，总是对volatile，不是特别理解，为什么叫轻量锁；Synchronized实现原理说不明白，Lock为什么能在有竞争时，性能优于Synchronized；Lock与AQS是什么关系。。。&lt;/p&gt;
&lt;p&gt;         带着这些疑问，翻开这本书，显示，翻了几遍后，这些问题，你会从根上理解他，真正的理解，那种不会忘记的理解。&lt;/p&gt;
&lt;p&gt;         对于，volatile 的理解，与应用场景算，是印象比较深的几个点之一了，从字节码指令，中可以很明显看到，为什么volatile修饰的变量，不能用于，做++ 操作。因为，它的可见性，你会取到正确的值，但是变量放到栈中后，其他线程修改了此变量，&lt;/p&gt;
&lt;p&gt;         栈中的值，可能就是最新值了，所以++，操作会有问题。也就说明，它的应该场景，应该局限在，不依赖原始值的情况。&lt;/p&gt;
&lt;p&gt;         看完本书，项目有设计并发，多线程，Lock等问题时，就踏实多了，4月26号第一次读完成，敲了书中不少demo，受益不少。&lt;/p&gt;


&lt;p&gt;                                                                                    &lt;img src=&quot;https://img2018.cnblogs.com/blog/88102/201907/88102-20190705011858078-462135944.jpg&quot; alt=&quot;&quot; width=&quot;287&quot; height=&quot;510&quot;/&gt;&lt;/p&gt;
&lt;p&gt;        读完前一本书后，开始焦虑，接下来读什么书了，感觉像上瘾了一样，哈哈，       &lt;/p&gt;
&lt;p&gt;        正巧，团队中来了一个以前阿里的，我们叫他燊哥（【&lt;em id=&quot;__mceDel&quot;&gt;shēn】，很复杂的一个字），混熟了之后，推荐了几本，这就是其中一本，正感觉缺mysql知识，就果断读了这本，也刚好，微信读书里，有这个电子书。 &lt;/em&gt;&lt;/p&gt;
&lt;p&gt;        本书第二章节讲了，一些体系架构，相关线程，文件结构之类的，相当枯燥，阅读进度非常缓慢，用了很长时间，磨到第三章中，实在看不动了，一度想放弃了；最后，果断的，从第一页，重新开始阅读，&lt;/p&gt;
&lt;p&gt;　　 第二遍，明显轻松了许多，一些原来跳过的，重新回味，感觉别有一翻滋味了。&lt;/p&gt;
&lt;p&gt;　　 这本书，最大的收获，应该算时，关于索引原理，以及其内部结构，一张表是如何用B+树组织起来，辅助索引，与主键索引如何关连的。&lt;/p&gt;
&lt;p&gt;　　也对索引优化，有了感性的认识，也恰好，最近手头的项目的数据，都是千万级的数据查询问题（可能对各位看官来说，都是小数目，对我，确实是挺大的数据了），这些准备如及时雨一般，&lt;/p&gt;
&lt;p&gt;        感觉，生活就是么这多巧合组成了。于6月3号看完第一遍，虽然此时，燊哥已经不在美菜，在此，谢过！&lt;/p&gt;


&lt;p&gt;                                                                                    &lt;img src=&quot;https://img2018.cnblogs.com/blog/88102/201907/88102-20190705013047022-181381903.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;        在阅读过程中，现任领导，我们都叫他雷老大，推荐一个书单，感觉如获至宝，因为，未来好长一段时间，都有书可读了。但是，细看，那些书，比如 netty，分布式等都与tcp/ip相关，再想想，大学那会学的网络知识，早已经不知去向了。&lt;/p&gt;
&lt;p&gt;　　 本来书单里，有一本是关于这方便的，它叫：TCP/IP详解。一来，此书，没有找到电子书；二来，这书太厚了，我感觉，我也用不到书那么多内容；于是，选择了一本，轻松，简单的。旨在了解，基本知识。&lt;/p&gt;
&lt;p&gt;        书中重点看了，tcp/ip协议系统，对于基本体系有了感性的认识，特别是TCP建立链接的3次握手，从数据报内容层面，简单了解了，总算明白了 ACK 与ack ,SYN 与syn的含义，以看其他文章，总是不明白。&lt;/p&gt;
&lt;p&gt;　　另外，也了解了，之前一个算法题目：找出一个二进制里1的个数（使用  n &amp;amp; (&amp;amp;-1) 可以让时间复杂度 小于 O（n） ），应用场景：奇偶校验。&lt;/p&gt;
&lt;p&gt;        这书，后面几10几章，就没有什么用处了，看了前几章，虽是入门级的，对我来说够用了，能方便理解一些网络模型就行了。这书，就不推荐了。&lt;/p&gt;


&lt;p&gt;                                                                                   &lt;img src=&quot;https://img2018.cnblogs.com/blog/88102/201907/88102-20190705015308279-348532237.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;        这书为什么没有图片，因为这只一个ppt，所有没有封面，但是它，不仅仅是一个ppt。这也是雷老大，推荐书单里的一本，在此，再一次感谢雷老大，他现在应该正在家里抱着刚出生二胎，估计忙得不亦乐乎吧。&lt;/p&gt;
&lt;p&gt;        这个70页的ppt，讲述了分布式基本原理，让我们这些小白，能顺利理解，书中，内容不少，但是泛而不糙，原理分析明的，粗中带着细腻。&lt;/p&gt;
&lt;p&gt;　　 看完本书，会对 TCC, 2PC 等概念，有一些非具象的认识。&lt;/p&gt;
&lt;p&gt;　　会对 X/Open DTP ， XA 协议 等一些分布式基础知识，有简单的认识。&lt;/p&gt;
&lt;p&gt;        你会发现， 0/1 direcory的实现 与 垃圾回收中 复制算法 真是异曲同工。&lt;/p&gt;
&lt;p&gt;　　 对于 分布式中 常用用机制 如  quorum, Lease 等。有基本认识，以后你会在很多地方看到他们的影子。&lt;/p&gt;
&lt;p&gt;　　 看书本ppt，你就可以开始分布式更多深入的学习了。&lt;/p&gt;
&lt;p&gt;        因为，这是一个ppt，手机上不方便，都在电脑上阅读，花了大概2周时间，与7月4号阅读完成。这是一本好书，值得阅读。&lt;/p&gt;


&lt;p&gt;　　在看技术书籍时，也偶尔想换换风格，中间也看了些小说。&lt;/p&gt;
&lt;p&gt;　　流浪地球，电影热播时，听说，小说，很多短，果断看了一遍，感觉小说有感觉，比电影感觉还好，特别是反动武装，“打赢”之时，&quot;氦闪&quot;来临的一刹那... &lt;/p&gt;
&lt;p&gt;       倚天屠龙记，新版出来时，好多吐槽，为了吐槽，有水平，又看了大部分小说，看小说，画面感十足，并且金老，手法奇特，真有点停不下来。最后，感觉时间用得有点多，才理智的停下了&lt;/p&gt;

&lt;p&gt;　　看到英文两个字，大伙，有没有诧异，其实都是一些初级的小说，想着，小孩子快3岁了，要开始接触英文了，自己也就开始准备了。&lt;/p&gt;
&lt;p&gt;　　特意买了金山词霸的会员，因为生词本可以自动生成，太方便了。&lt;/p&gt;
&lt;p&gt;　　比如：Robinson Crusose, Sherlock Holmes Short Stories, Sherlock Holmes the Dukes Son，Skyjack, Formula One,,  &lt;/p&gt;
&lt;p&gt;       当然，这些其实算不上小说，1w左右个单词，很快，可以读完一个，很有成就感，教娃也够了。&lt;/p&gt;


&lt;p&gt;　　在读书过过程中，得到雷老大的支持，除了推荐书单，也给予了他能给的一些东西（哈哈），感觉得到了认可，还得谢谢一次。&lt;/p&gt;
&lt;p&gt;　　目前正在《netty权威指南》，《从Paxos到zookeeper:分布式一致性原理与实践》&lt;/p&gt;

&lt;p&gt;　　以上就是最近一段时间的，读书分享，也许分享的内容也有不对的地方，期待讨论哈。&lt;/p&gt;
&lt;p&gt;　　不知道会有人疑问：时间哪里来的吗？其实大部是是在地铁上，公交中，以及每天早2小时到公司，晚2小时下班；都不知道，以前不读书的时间，都哪里去了。&lt;/p&gt;
&lt;p&gt;　　当然，也因为一个人北京，无以解忧，唯有读书。希望将来回来杭州，也能坚持读书。&lt;/p&gt;

&lt;p&gt;　　 成为一名优秀的程序员！&lt;/p&gt;

</description>
<pubDate>Fri, 05 Jul 2019 00:25:00 +0000</pubDate>
<dc:creator>2J</dc:creator>
<og:description>今天，翻完《分布式系统原理介绍.ppt》了最后一页，感觉有点失落：又一本好书看完了（不知，大伙儿是否也是这样的）。惆怅中，才发现，自去年10月，进入美菜后，7个月的时间，已经看完了6-7本书了，这个战</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jijunjian/p/11136041.html</dc:identifier>
</item>
<item>
<title>What？一个 Dubbo 服务启动要两个小时！ - crossoverJie</title>
<link>http://www.cnblogs.com/crossoverJie/p/11135619.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/crossoverJie/p/11135619.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/07/04/5d1e14ea0052047268.jpg&quot;/&gt;&lt;/p&gt;

&lt;p&gt;前几天在测试环境碰到一个非常奇怪的与 &lt;code&gt;dubbo&lt;/code&gt; 相关的问题，事后我在网上搜索了一圈并没有发现类似的帖子或文章，于是便有了这篇。&lt;/p&gt;
&lt;p&gt;希望对还未碰到或正在碰到的朋友有所帮助。&lt;/p&gt;

&lt;p&gt;现象是这样的，有一天测试在测试环境重新部署一个 &lt;code&gt;dubbo&lt;/code&gt; 应用的时候发现应用&lt;code&gt;“启动不起来”&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;但过几个小时候之后又能自己慢慢恢复，并能够对外提供 &lt;code&gt;dubbo&lt;/code&gt; 服务。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;但其实经过我后续排查发现刚开始其实并不是启动不起来，而是启动速度非常缓慢，所以当应用长时间启动后才会对外提供服务。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/07/04/5d1e14eb2d3b613329.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而这个速度慢到居然要花费 &lt;code&gt;2 个小时&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;导致的一个结果是测试完全不敢在测试环境发版验证了，每验证一个功能修复一个 &lt;code&gt;bug&lt;/code&gt; 就得等上两个小时，这谁受得了😂。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;而且经过多次观察，确实每次都是花费两小时左右应用才能启动起来。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;最后测试顶不住了，只能让我这个&lt;code&gt;“事故报告撰写专家”&lt;/code&gt;来看看。&lt;/p&gt;
&lt;p&gt;当我得知这个问题的现象时其实完全没当一回事：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;都不用想，这不就是主线程阻塞了嘛，先看看是否在初始化的时候数据库、Zookeeper 之类的连不上导致阻塞了-------来之多次事故处理的经验告诉我。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;于是我把这事打回给测试让他先找运维排查下，不到万不得已不要影响我 &lt;code&gt;Touch fish&lt;/code&gt;🐳。&lt;/p&gt;
&lt;p&gt;第二天一早看到测试同学的微信头像跳动时我都已经准备接受又一句 &lt;code&gt;“膜拜大佬👍”&lt;/code&gt; 的回复时，却收到 “网络一切正常，没人动过，再不解决就要罢工了🤬”。&lt;/p&gt;
&lt;p&gt;好吧，忽悠不过去了。&lt;/p&gt;
&lt;p&gt;首先这类问题的排查方向应该不会错，就是主线程阻塞了，至于是啥导致的阻塞就不能像之前那样瞎猜了。&lt;/p&gt;
&lt;p&gt;我将应用重启后用 &lt;code&gt;jstack pid&lt;/code&gt; 将线程快照打印到终端，直接拉到最后看看 &lt;code&gt;main&lt;/code&gt; 线程到底在干啥。&lt;/p&gt;
&lt;p&gt;前几次的快照都是很正常：&lt;/p&gt;
&lt;p&gt;加载 &lt;code&gt;Spring&lt;/code&gt; ----&amp;gt;连接 &lt;code&gt;Zookeeper&lt;/code&gt; ---&amp;gt; 连接 &lt;code&gt;Redis&lt;/code&gt;，都是依次执行下来没有阻塞。&lt;/p&gt;
&lt;p&gt;隔了一段后应用确实还没起来，我再次 &lt;code&gt;jstack&lt;/code&gt; 后得到如下信息：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/07/04/5d1e14ec2185426171.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;翻源码&quot;&gt;翻源码&lt;/h2&gt;
&lt;p&gt;我一直等了十几分钟再多次 &lt;code&gt;jstack&lt;/code&gt; 得到的快照得到的信息都是一样的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/07/04/5d1e14ec2185426171.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如图所示可见主线程是卡在了 dubbo 的某个方法 &lt;code&gt;ServiceConfig.java&lt;/code&gt; 的 303 行中。&lt;/p&gt;
&lt;p&gt;于是我找到此处的源码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/07/04/5d1e14ec68e8259933.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;简单来说这里的逻辑就是要获取本机的 &lt;code&gt;IP&lt;/code&gt; 将其注册到 &lt;code&gt;Zookeeper&lt;/code&gt; 中用于其他服务调用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/07/04/5d1e14eca624d69950.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再往下跟就如堆栈中一样是卡在了 &lt;code&gt;Inet4AddressImpl.getLocalHostName&lt;/code&gt; 处。&lt;/p&gt;
&lt;p&gt;但这是一个 &lt;code&gt;native&lt;/code&gt; 方法，我们应用也根本干涉不了，最终的现象就是调用这个本地方法非常耗时。&lt;/p&gt;
&lt;p&gt;于是这问题貌似也阻塞在这儿了，没有太多办法。&lt;/p&gt;

&lt;p&gt;既然这是一个 native 方法，那说明和应用本身没有啥关系（确实也是这样，这个问题是突然间出现的。）&lt;/p&gt;
&lt;p&gt;那是否是服务器本身的问题呢，想到在 &lt;code&gt;native&lt;/code&gt; 方法里是获取本机的 &lt;code&gt;hostname&lt;/code&gt;，那是否和这个 &lt;code&gt;hostname&lt;/code&gt; 有关系呢。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/07/04/5d1e14ecd59a795394.jpg&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这是在我自己的阿里云服务器上测试，真正的测试环境不是这个名字。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;拿到服务器 &lt;code&gt;hostname&lt;/code&gt; 后再尝试 &lt;code&gt;ping&lt;/code&gt; 这个 &lt;code&gt;hostname&lt;/code&gt;，奇怪的现象发生了：&lt;/p&gt;
&lt;p&gt;命令刚开始会卡住一段时间（大概几十秒），然后才会输出 &lt;code&gt;hostname&lt;/code&gt; 对应的 &lt;code&gt;ip&lt;/code&gt; 以及对应的延迟。&lt;/p&gt;
&lt;p&gt;而当我直接 &lt;code&gt;ping&lt;/code&gt; 这个 &lt;code&gt;ip&lt;/code&gt; 时却能快速响应后面的输出。&lt;/p&gt;
&lt;p&gt;最后我尝试在 /etc/hosts 配置文件中加入了对应的 host 配置：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;xx.xx.xx.xx(ip) hostname&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再次 &lt;code&gt;ping hostname&lt;/code&gt; 的效果就和直接 &lt;code&gt;ping ip&lt;/code&gt; 一样了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;于是我再次重启应用，一切都正常了。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;最后根据我调整的内容尝试分析下本次问题的原因：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当 &lt;code&gt;Dubbo&lt;/code&gt; 在启动获取本地 ip 时，是通过服务器 &lt;code&gt;hostname&lt;/code&gt; 从 &lt;code&gt;dns&lt;/code&gt; 服务器返回当前的 ip 地址。&lt;/li&gt;
&lt;li&gt;由于 &lt;code&gt;dns&lt;/code&gt; 服务器或者是本地服务器与 dns 服务器之间存在网络问题，导致这个过程的时间被拉长（猜测）。&lt;/li&gt;
&lt;li&gt;我在本地的 &lt;code&gt;host&lt;/code&gt; 文件中配置后，就相当于本地有一个缓存，优先取本地配置的 ip ，避免了和 dns 服务器交互的过程，所以速度提升了。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;虽然问题得到解决了，但还是有几个疑问：&lt;/p&gt;
&lt;p&gt;第一个是为什么和 &lt;code&gt;DNS&lt;/code&gt; 服务器的交互会这么慢，即便是慢也没有像应用那样需要 2 个小时才能返回，这里我也没搞得太清楚，有相关经验的朋友可以留言讨论。&lt;/p&gt;
&lt;p&gt;第二就是 Dubbo 在这个依赖外部获取资源时健壮性是否可以做的更好，虽说我这问题估计也几人碰到。&lt;/p&gt;
&lt;p&gt;对于这种长时间没有启动成功的问题是否可以加上提示，比如直接抛出异常退出程序，将问题可能的原因告诉开发者，方便排查问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;你的点赞与分享是对我最大的支持&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 05 Jul 2019 00:16:00 +0000</pubDate>
<dc:creator>crossoverJie</dc:creator>
<og:description>前几天在测试环境碰到一个非常奇怪的与 dubbo 相关的问题，事后我在网上搜索了一圈并没有发现类似的帖子或文字，于是便有了这篇。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/crossoverJie/p/11135619.html</dc:identifier>
</item>
<item>
<title>kubernetes实战篇之helm完整示例 - 周国通</title>
<link>http://www.cnblogs.com/tylerzhou/p/11136107.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tylerzhou/p/11136107.html</guid>
<description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/tylerzhou/p/11100649.html&quot;&gt;系列目录&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;构建一个-helm-chart&quot;&gt;构建一个 Helm Chart&lt;/h2&gt;
&lt;p&gt;下面我们通过一个完整的示例来学习如何使用 Helm 创建、打包、分发、安装、升级及回退Kubernetes应用。&lt;/p&gt;
&lt;p&gt;创建一个名为 mychart 的 Chart&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ helm create mychart&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该命令创建了一个 mychart 目录，该目录结构如下所示。这里我们主要关注目录中的 Chart.yaml、values.yaml、NOTES.txt 和 Templates 目录。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[centos@k8s-master helm]$ tree mychart
mychart
├── charts
├── Chart.yaml
├── templates
│   ├── deployment.yaml
│   ├── _helpers.tpl
│   ├── ingress.yaml
│   ├── NOTES.txt
│   ├── service.yaml
│   └── tests
│       └── test-connection.yaml
└── values.yaml&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;Chart.yaml 用于描述这个 Chart的相关信息，包括名字、描述信息以及版本等。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;仅仅是一些简单的文本描述&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;values.yaml 用于存储 templates 目录中模板文件中用到变量的值。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;NOTES.txt 用于介绍 Chart 部署后的一些信息，例如：如何使用这个 Chart、列出缺省的设置等。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Templates 目录下是 YAML 文件的模板，该模板文件遵循 Go template 语法。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Templates 目录下 YAML 文件模板的值默认都是在 values.yaml 里定义的，比如在 deployment.yaml 中定义的容器镜像。&lt;/p&gt;
&lt;p&gt;image: &quot;{{ .Values.image.repository }}:{{ .Values.image.tag }}&quot;&lt;/p&gt;
&lt;p&gt;其中的 &lt;code&gt;.Values.image.repository&lt;/code&gt; 的值就是在 &lt;code&gt;values.yaml&lt;/code&gt; 里定义的 &lt;code&gt;nginx&lt;/code&gt;，&lt;code&gt;.Values.image.tag&lt;/code&gt; 的值就是 &lt;code&gt;stable&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;以上两个变量值是在 create chart 的时候就自动生成的默认值，你可以根据实际情况进行修改。实际上都是静态文本,只在是执行的时候才被解析.&lt;/p&gt;
&lt;blockquote readability=&quot;5.5263157894737&quot;&gt;
&lt;p&gt;如果你需要了解更多关于 Go 模板的相关信息，可以查看 Hugo 的一个关于 &lt;a href=&quot;https://gohugo.io/&quot;&gt;Go 模板&lt;/a&gt; 的介绍&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;编写应用的介绍信息&quot;&gt;编写应用的介绍信息&lt;/h3&gt;
&lt;p&gt;打开 Chart.yaml,可以看到内容如下&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ cat mychart/Chart.yaml
apiVersion: v1
appVersion: &quot;1.0&quot;
description: A Helm chart for Kubernetes
name: mychart
version: 0.1.0&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;编写具体应用部署信息&quot;&gt;编写具体应用部署信息&lt;/h3&gt;
&lt;p&gt;编辑 values.yaml，它默认会在 Kubernetes 部署一个 Nginx。下面是 mychart 应用的 values.yaml 文件的内容：&lt;/p&gt;
&lt;pre class=&quot;yml&quot;&gt;
&lt;code&gt;$ cat mychart/values.yaml
# Default values for mychart.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

replicaCount: 1

image:
  repository: nginx
  tag: stable
  pullPolicy: IfNotPresent

service:
  type: ClusterIP
  port: 80

ingress:
  enabled: false
  annotations: {}
    # kubernetes.io/ingress.class: nginx
    # kubernetes.io/tls-acme: &quot;true&quot;
  path: /
  hosts:
    - chart-example.local
  tls: []
  #  - secretName: chart-example-tls
  #    hosts:
  #      - chart-example.local

resources: {}
  # We usually recommend not to specify default resources and to leave this as a conscious
  # choice for the user. This also increases chances charts run on environments with little
  # resources, such as Minikube. If you do want to specify resources, uncomment the following
  # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
  # limits:
  #  cpu: 100m
  #  memory: 128Mi
  # requests:
  #  cpu: 100m
  #  memory: 128Mi

nodeSelector: {}

tolerations: []

affinity: {}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;检查依赖和模板配置是否正确&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ helm lint mychart/
==&amp;gt; Linting .
[INFO] Chart.yaml: icon is recommended

1 chart(s) linted, no failures&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果文件格式错误，可以根据提示进行修改。&lt;/p&gt;
&lt;h3 id=&quot;将应用打包&quot;&gt;将应用打包&lt;/h3&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ helm package mychart
Successfully packaged chart and saved it to: /home/k8s/mychart-0.1.0.tgz&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;mychart 目录会被打包为一个 mychart-0.1.0.tgz 格式的压缩包，该压缩包会被放到当前目录下，并同时被保存到了 Helm 的本地缺省仓库目录中。&lt;/p&gt;
&lt;p&gt;如果你想看到更详细的输出，可以加上 --debug 参数来查看打包的输出，输出内容应该类似如下：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ helm package mychart --debug
Successfully packaged chart and saved it to: /home/k8s/mychart-0.1.0.tgz
[debug] Successfully saved /home/k8s/mychart-0.1.0.tgz to /home/k8s/.helm/repository/local&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;将应用发布到-repository&quot;&gt;将应用发布到 Repository&lt;/h3&gt;
&lt;p&gt;虽然我们已经打包了 Chart 并发布到了 Helm 的本地目录中，但通过 helm search 命令查找，并不能找不到刚才生成的 mychart包。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ helm search mychart
No results found&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是因为 Repository 目录中的 Chart 包还没有被 Helm 管理。通过 helm repo list 命令可以看到目前 Helm 中已配置的 Repository 的信息。&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;注：新版本中执行 helm init 命令后默认会配置一个名为 local 的本地仓库。如果大家通过helm repo list 可以看到local选项,则为默认添加了,下面的有配置不用管,当然如果你不太明白仍然按照下面的操作执行了,也是没有问题的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们可以在本地启动一个 Repository Server，并将其加入到 Helm Repo 列表中。Helm Repository 必须以 Web 服务的方式提供，这里我们就使用 helm serve 命令启动一个 Repository Server，该 Server 缺省使用 &lt;code&gt;$HOME/.helm/repository/local&lt;/code&gt; 目录作为 Chart 存储，并在 8879 端口上提供服务。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ helm serve &amp;amp;
Now serving you on 127.0.0.1:8879&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;默认情况下该服务只监听 127.0.0.1，如果你要绑定到其它网络接口，可使用以下命令：&lt;/p&gt;
&lt;p&gt;helm serve --address 192.168.100.211:8879 &amp;amp;&lt;/p&gt;
&lt;p&gt;如果你想使用指定目录来做为 Helm Repository 的存储目录，可以加上 --repo-path 参数&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;helm serve --address 192.168.124.59:8879 --repo-path /data/helm/repository/ --url http://192.168.124.59:8879/charts/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过 helm repo index 命令将 Chart 的 Metadata 记录更新在 index.yaml 文件中:&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt; 更新 Helm Repository 的索引文件
$ cd /home/k8s/.helm/repository/local
$ helm repo index --url=http://192.168.100.211:8879 .&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;完成启动本地 Helm Repository Server 后，就可以将本地 Repository 加入 Helm 的 Repo 列表&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ helm repo add local http://127.0.0.1:8879
&quot;local&quot; has been added to your repositories&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在再次查找 mychart 包，就可以搜索到了。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ helm repo update
$ helm search mychart
NAME            CHART VERSION   APP VERSION DESCRIPTION
local/mychart   0.1.0           1.0         A Helm chart for Kubernetes&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;在-kubernetes-中部署应用&quot;&gt;在 Kubernetes 中部署应用&lt;/h2&gt;
&lt;h3 id=&quot;部署一个应用&quot;&gt;部署一个应用&lt;/h3&gt;
&lt;p&gt;Chart 被发布到仓储后，就可以通过 helm install 命令部署该 Chart。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;检查配置和模板是否有效&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当使用 &lt;code&gt;helm install&lt;/code&gt; 命令部署应用时，实际上就是将 templates 目录下的模板文件渲染成 Kubernetes 能够识别的 YAML 格式。&lt;/p&gt;
&lt;p&gt;在部署前我们可以使用 helm install --dry-run --debug --name 命令来验证 Chart 的配置。该输出中包含了模板的变量配置与最终渲染的 YAML 文件。&lt;/p&gt;
&lt;pre class=&quot;yml&quot;&gt;
&lt;code&gt;$ helm install --dry-run --debug local/mychart --name mike-test
[debug] Created tunnel using local port: '46649'

[debug] SERVER: &quot;127.0.0.1:46649&quot;

[debug] Original chart version: &quot;&quot;
[debug] Fetched local/mychart to /home/k8s/.helm/cache/archive/mychart-0.1.0.tgz

[debug] CHART PATH: /home/k8s/.helm/cache/archive/mychart-0.1.0.tgz

NAME:   tylertest
REVISION: 1
RELEASED: Mon Jul 23 10:39:49 2018
CHART: mychart-0.1.0
USER-SUPPLIED VALUES:
{}

COMPUTED VALUES:
affinity: {}
image:
  pullPolicy: IfNotPresent
  repository: nginx
  tag: stable
ingress:
  annotations: {}
  enabled: false
  hosts:
  - chart-example.local
  path: /
  tls: []
nodeSelector: {}
replicaCount: 1
resources: {}
service:
  port: 80
  type: ClusterIP
tolerations: []

HOOKS:
MANIFEST:

---
# Source: mychart/templates/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: tylertest-mychart
  labels:
    app: mychart
    chart: mychart-0.1.0
    release: tyler-test
    heritage: Tiller
spec:
  type: ClusterIP
  ports:
    - port: 80
      targetPort: http
      protocol: TCP
      name: http
  selector:
    app: mychart
    release: mike-test
---
# Source: mychart/templates/deployment.yaml
apiVersion: apps/v1beta2
kind: Deployment
metadata:
  name: tylertest-mychart
  labels:
    app: mychart
    chart: mychart-0.1.0
    release: tyler-test
    heritage: Tiller
spec:
  replicas: 1
  selector:
    matchLabels:
      app: mychart
      release: tyler-test
  template:
    metadata:
      labels:
        app: mychart
        release: tyler-test
    spec:
      containers:
        - name: mychart
          image: &quot;nginx:stable&quot;
          imagePullPolicy: IfNotPresent
          ports:
            - name: http
              containerPort: 80
              protocol: TCP
          livenessProbe:
            httpGet:
              path: /
              port: http
          readinessProbe:
            httpGet:
              path: /
              port: http
          resources:
            {}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;验证完成没有问题后，我们就可以使用以下命令将其部署到 Kubernetes 上了。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;# 部署时需指定 Chart 名及 Release（部署的实例）名。
$ helm install local/mychart --name mike-test
NAME:   mike-test
LAST DEPLOYED: Mon Jul 23 10:41:20 2018
NAMESPACE: default
STATUS: DEPLOYED

RESOURCES:
==&amp;gt; v1/Service
NAME               TYPE       CLUSTER-IP      EXTERNAL-IP  PORT(S)  AGE
mike-test-mychart  ClusterIP  10.254.120.177  &amp;lt;none&amp;gt;       80/TCP   1s

==&amp;gt; v1beta2/Deployment
NAME               DESIRED  CURRENT  UP-TO-DATE  AVAILABLE  AGE
mike-test-mychart  1        0        0           0          0s

==&amp;gt; v1/Pod(related)
NAME                                READY  STATUS   RESTARTS  AGE
mike-test-mychart-6d56f8c8c9-d685v  0/1    Pending  0         0s


NOTES:
1. Get the application URL by running these commands:
  export POD_NAME=$(kubectl get pods --namespace default -l &quot;app=mychart,release=mike-test&quot; -o jsonpath=&quot;{.items[0].metadata.name}&quot;)
  echo &quot;Visit http://127.0.0.1:8080 to use your application&quot;
  kubectl port-forward $POD_NAME 8080:80&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注：helm install 默认会用到 socat，需要在所有节点上安装 socat 软件包。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;关于访问的部分这里就不再介绍了,后面会讲解一个完整项目对外暴露访问&lt;/p&gt;
&lt;p&gt;使用下面的命令列出的所有已部署的 Release 以及其对应的 Chart。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ helm list
NAME        REVISION    UPDATED                     STATUS      CHART           NAMESPACE
tylertest   1           Mon Jul 23 10:41:20 2018    DEPLOYED    mychart-0.1.0   default&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你还可以使用 &lt;code&gt;helm status&lt;/code&gt; 查询一个特定的 Release 的状态。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ helm status tylertest
LAST DEPLOYED: Mon Jul 23 10:41:20 2018
NAMESPACE: default
STATUS: DEPLOYED

RESOURCES:
==&amp;gt; v1/Pod(related)
NAME                                READY  STATUS   RESTARTS  AGE
tylertest-mychart-6d56f8c8c9-d685v  1/1    Running  0         1m

==&amp;gt; v1/Service
NAME               TYPE       CLUSTER-IP      EXTERNAL-IP  PORT(S)  AGE
tylertest-mychart  ClusterIP  10.254.120.177  &amp;lt;none&amp;gt;       80/TCP   1m

==&amp;gt; v1beta2/Deployment
NAME               DESIRED  CURRENT  UP-TO-DATE  AVAILABLE  AGE
tylertest-mychart  1        1        1           1          1m


NOTES:
1. Get the application URL by running these commands:
  export POD_NAME=$(kubectl get pods --namespace default -l &quot;app=mychart,release=tyler-test&quot; -o jsonpath=&quot;{.items[0].metadata.name}&quot;)
  echo &quot;Visit http://127.0.0.1:8080 to use your application&quot;
  kubectl port-forward $POD_NAME 8080:80&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;升级和回退一个应用&quot;&gt;升级和回退一个应用&lt;/h3&gt;
&lt;p&gt;从上面 helm list 输出的结果中我们可以看到有一个 Revision（更改历史）字段，该字段用于表示某一个 Release 被更新的次数，我们可以用该特性对已部署的 Release 进行回滚。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;修改 Chart.yaml 文件&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;将版本号从 0.1.0 修改为 0.2.0, 然后使用 &lt;code&gt;helm package&lt;/code&gt; 命令打包并发布到本地仓库。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ cat mychart/Chart.yaml
apiVersion: v1
appVersion: &quot;1.0&quot;
description: A Helm chart for Kubernetes
name: mychart
version: 0.2.0

$ helm package mychart
Successfully packaged chart and saved it to: /home/k8s/mychart-0.2.0.tgz&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查询本地仓库中的 Chart 信息&lt;/p&gt;
&lt;p&gt;我们可以看到在本地仓库中 mychart 有两个版本&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[centos@k8s-master helm]$ helm search mychart -l
NAME            CHART VERSION   APP VERSION     DESCRIPTION
local/mychart   0.2.0           1.0             A Helm chart for Kubernetes
local/mychart   0.1.0           1.0             A Helm chart for Kubernetes&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;升级一个应用&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;现在用 helm upgrade 命令将已部署的 tylertest 升级到新版本。你可以通过 --version 参数指定需要升级的版本号，如果没有指定版本号，则缺省使用最新版本。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;
[centos@k8s-master helm]$ helm upgrade tylertest mychart
Release &quot;tylertest&quot; has been upgraded. Happy Helming!
LAST DEPLOYED: Thu Apr 25 09:19:53 2019
NAMESPACE: default
STATUS: DEPLOYED

RESOURCES:
==&amp;gt; v1/Deployment
NAME               READY  UP-TO-DATE  AVAILABLE  AGE
tylertest-mychart  1/1    1           1          25m

==&amp;gt; v1/Pod(related)
NAME                                READY  STATUS   RESTARTS  AGE
tylertest-mychart-545479dd4b-hj9ml  1/1    Running  0         25m

==&amp;gt; v1/Service
NAME               TYPE       CLUSTER-IP    EXTERNAL-IP  PORT(S)  AGE
tylertest-mychart  ClusterIP  10.103.51.57  &amp;lt;none&amp;gt;       80/TCP   25m


NOTES:
1. Get the application URL by running these commands:
  export POD_NAME=$(kubectl get pods --namespace default -l &quot;app.kubernetes.io/name=mychart,app.kubernetes.io/instance=tylertest&quot; -o jsonpath=&quot;{.items[0].metadata.name}&quot;)
  echo &quot;Visit http://127.0.0.1:8080 to use your application&quot;
  kubectl port-forward $POD_NAME 8080:80
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;完成后，可以看到已部署的 tylertest 被升级到 0.2.0 版本。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;NAME                    REVISION        UPDATED                         STATUS          CHART                           APP VERSION     NAMESPACE
kubernetes-dashboard    1               Thu Mar 14 09:06:25 2019        DEPLOYED        kubernetes-dashboard-1.2.0      1.10.1          kube-system
tylertest               2               Thu Apr 25 09:19:53 2019        DEPLOYED        mychart-0.2.0                   1.0             default&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;回退一个应用&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果更新后的程序由于某些原因运行有问题，需要回退到旧版本的应用。首先我们可以使用 &lt;code&gt;helm history&lt;/code&gt; 命令查看一个 Release 的所有变更记录。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;
[centos@k8s-master helm]$ helm list tylertest
NAME            REVISION        UPDATED                         STATUS          CHART           APP VERSION     NAMESPACE
tylertest       2               Thu Apr 25 09:19:53 2019        DEPLOYED        mychart-0.2.0   1.0             default&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其次，我们可以使用下面的命令对指定的应用进行回退。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;
[centos@k8s-master helm]$ helm rollback tylertest 1
Rollback was a success! Happy Helming!&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注：其中的参数 1 是 helm history 查看到 Release 的历史记录中 REVISION 对应的值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;最后，我们使用 helm list 和 helm history 命令都可以看到 mychart 的版本已经回退到 0.1.0 版本。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[centos@k8s-master helm]$ helm list
NAME                    REVISION        UPDATED                         STATUS          CHART                           APP VERSION     NAMESPACE
kubernetes-dashboard    1               Thu Mar 14 09:06:25 2019        DEPLOYED        kubernetes-dashboard-1.2.0      1.10.1          kube-system
tylertest               3               Thu Apr 25 09:22:19 2019        DEPLOYED        mychart-0.1.0                   1.0             default
[centos@k8s-master helm]$ helm history tylertest
REVISION        UPDATED                         STATUS          CHART           DESCRIPTION
1               Thu Apr 25 08:54:49 2019        SUPERSEDED      mychart-0.1.0   Install complete
2               Thu Apr 25 09:19:53 2019        SUPERSEDED      mychart-0.2.0   Upgrade complete
3               Thu Apr 25 09:22:19 2019        DEPLOYED        mychart-0.1.0   Rollback to 1&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;删除一个应用&quot;&gt;删除一个应用&lt;/h3&gt;
&lt;p&gt;如果需要删除一个已部署的 Release，可以利用 helm delete 命令来完成删除。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[centos@k8s-master helm]$ helm delete tylertest
release &quot;tylertest&quot; deleted&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;确认应用是否删除，该应用已被标记为 DELETED 状态&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;
[centos@k8s-master helm]$ helm ls --deleted
NAME                    REVISION        UPDATED                         STATUS  CHART                   APP VERSION     NAMESPACE
intentional-chinchilla  1               Wed Apr 24 18:37:29 2019        DELETED mychart-0.1.0           1.0             default
invisible-turkey        1               Mon Apr 22 17:39:14 2019        DELETED nginx-ingress-0.21.1    0.14.0          jx
punk-condor             1               Wed Apr 24 18:38:09 2019        DELETED mychart-0.1.0           1.0             default
tylerchart              1               Wed Apr 24 18:40:01 2019        DELETED mychart-0.1.0           1.0             default
tylertest               3               Thu Apr 25 09:22:19 2019        DELETED mychart-0.1.0           1.0             default
vigilant-bat            1               Wed Apr 24 17:40:02 2019        DELETED xray-0.4.2              2.3.0           default
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面的结果也可以看出，默认情况下已经删除的 Release 只是将状态标识为 DELETED 了 ，但该 Release 的历史信息还是继续被保存的。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;
[centos@k8s-master helm]$ helm history tylertest
REVISION        UPDATED                         STATUS          CHART           DESCRIPTION
1               Thu Apr 25 08:54:49 2019        SUPERSEDED      mychart-0.1.0   Install complete
2               Thu Apr 25 09:19:53 2019        SUPERSEDED      mychart-0.2.0   Upgrade complete
3               Thu Apr 25 09:22:19 2019        DELETED         mychart-0.1.0   Deletion complete&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果要移除指定 Release 所有相关的 Kubernetes 资源和 Release 的历史记录，可以用如下命令：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[centos@k8s-master helm]$ helm delete --purge tylertest
release &quot;tylertest&quot; deleted&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再次查看已删除的 Release，已经无法找到相关信息。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ helm hist tylertest
Error: release: &quot;tyertest&quot; not found

# helm ls 命令也已均无查询记录。
$ helm ls --deleted
$ helm ls -a tylertest&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 04 Jul 2019 23:57:00 +0000</pubDate>
<dc:creator>周国通</dc:creator>
<og:description>'系列目录' 构建一个 Helm Chart 下面我们通过一个完整的示例来学习如何使用 Helm 创建、打包、分发、安装、升级及回退Kubernetes应用。 创建一个名为 mychart 的 Cha</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tylerzhou/p/11136107.html</dc:identifier>
</item>
<item>
<title>Java虚拟机详解（二）------运行时内存结构 - YSOcean</title>
<link>http://www.cnblogs.com/ysocean/p/9345622.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ysocean/p/9345622.html</guid>
<description>&lt;p&gt;　　首先通过一张图了解 Java程序的执行流程：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1120165/201807/1120165-20180721205440562-1136861165.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　我们编写好的Java源代码程序，通过Java编译器javac编译成Java虚拟机识别的class文件（字节码文件），然后由 JVM 中的类加载器加载编译生成的字节码文件，加载完毕之后再由 JVM 执行引擎去执行。在加载完毕到执行过程中，JVM会将程序执行时用到的数据和相关信息存储在运行时数据区（Runtime Data Area），这块区域也就是我们常说的JVM内存结构，垃圾回收也是作用在该区域。&lt;/p&gt;
&lt;p&gt;　　关于这幅图涉及到的：&lt;/p&gt;
&lt;p&gt;　　①、class文件&lt;/p&gt;
&lt;p&gt;　　②、类加载器&lt;/p&gt;
&lt;p&gt;　　③、运行时数据区&lt;/p&gt;
&lt;p&gt;　　④、执行引擎&lt;/p&gt;
&lt;p&gt;　　⑤、垃圾回收器&lt;/p&gt;
&lt;p&gt;　　这都是接下来将要介绍的重点。&lt;/p&gt;
&lt;p&gt;　　本篇博客我们将首先介绍什么是运行时数据区。&lt;/p&gt;
&lt;p&gt;　　PS：下面介绍的是根据 &lt;strong&gt;Java虚拟机规范 &lt;/strong&gt;定义的运行时数据区，上一篇博客我们讲过根据虚拟机规范实现的虚拟机有很多个，而不同的虚拟机其运行时数据区定义也会有所不同。比如默认的 HotSpot 在实现 JDK1.7 虚拟机规范时，其常量池的定义不在方法区中，而是移到了堆中；到了 HotSpot JDK1.8 中，则彻底移除了持久代（方法区）而使用Metaspace（元数据区）来进行替代等等，关于这些区别本篇博客也会在文章末尾进行相应的说明。&lt;/p&gt;
&lt;h3&gt;1、运行时数据区结构图&lt;/h3&gt;
&lt;p&gt;　　&lt;strong&gt;①、Java虚拟机规范定义的运行时数据区&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1120165/201906/1120165-20190629223841564-1721538458.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;②、HotSpot JDK1.8定义的运行时数据区&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1120165/201906/1120165-20190629232328134-1467592616.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;注意：&lt;/strong&gt;HotSpot实现的运行时数据区和Java虚拟机规范定义的还是有所不同的，&lt;/p&gt;
&lt;p&gt;　　①、将&lt;strong&gt;Java虚拟机栈和本地方法栈&lt;/strong&gt;合二为一；&lt;/p&gt;
&lt;p&gt;　　②、&lt;strong&gt;元数据区取代了方法区&lt;/strong&gt;，并且元数据区不在Java虚拟机中，而是在本地内存中。&lt;/p&gt;
&lt;p&gt;　　③、&lt;strong&gt;运行时常量池&lt;/strong&gt;由方法区中移到了堆中&lt;/p&gt;
&lt;h3&gt;2、程序计数器&lt;/h3&gt;
&lt;p&gt;　　程序计数器（Program Conputer Register）这是一块较小的内存空间，可以看做是当前线程所执行的字节码的行号指示器，在虚拟机的概念模型里，字节码解释器的工作就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;①、线程私有&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　Java虚拟机支持多线程，是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任一确定的时刻，一个处理器只会执行一条线程中的指令，因此为了线程切换后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器。因此线程启动时，JVM 会为每个线程分配一个PC寄存器（Program Conter，也称程序计数器）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　②、记录当前字节码指令执行地址&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　如果当前线程执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是 Native 方法，则这个计数器值为空（Undefined）。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;③、不抛 OutOfMemoryError 异常&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　程序计数器的空间大小不会随着程序执行而改变，始终只是保存一个 returnAdress 类型的数据或者一个与平台相关的本地指针的值。所以该区域是Java运行时内存区域中唯一一个Java虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。&lt;/p&gt;
&lt;h3&gt;3、虚拟机栈&lt;/h3&gt;
&lt;p&gt;　　Java虚拟机栈（Java Virtual Machine stack），这块区域也是线程私有的，与线程同时创建，用于存储栈帧。Java 每个方法执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息，每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1120165/201807/1120165-20180722152410736-914758638.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;①、线程私有&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　随线程创建而创建，声明周期和线程保持一致。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;②、由栈帧组成&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　线程每个方法被执行的时候都会创建一个栈帧，用于存储局部变量表、操作栈、动态链接、方法出口等信息，每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;③、抛出 StackOverflowError 和 OutOfMemoryError 异常&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverflowError 异常；如果虚拟机栈可以动态扩展，当扩展时无法申请到足够的内存时会抛出 OutOfMemoryError  异常。&lt;/p&gt;
&lt;h3&gt;4、本地方法栈&lt;/h3&gt;
&lt;p&gt;　　本地方法栈（Native Method Stacks）作用和虚拟机栈类型，虚拟机栈执行的是Java方法，本地方法栈执行的是 Native 方法，本地方法栈也会抛出抛出 StackOverflowError 和 OutOfMemoryError 异常。&lt;/p&gt;
&lt;p&gt;　　注意：由于虚拟机规范并没有对本地方法栈中的方法使用语言、使用方式和数据结构强制规定，因此具体的虚拟机可以自由实现它。上图我们也给出在 HotSpot 虚拟机中，本地方法栈和虚拟机栈合为一体了。&lt;/p&gt;
&lt;h3&gt;5、Java堆&lt;/h3&gt;
&lt;p&gt;　　Java堆是Java虚拟机所管理内存最大、被所有线程共享的一块区域，目的是用来存放对象，基本上所有的对象实例和数组都在堆上分配（不是绝对）。Java堆也是垃圾回收器管理的主要区域。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;①、线程共享&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　堆存放的对象，某个线程修改了对象属性，另外一个线程从堆中获取的该对象是修改后的对象，为什么堆要设计成线程共享呢？&lt;/p&gt;
&lt;p&gt;　　我们可以假设堆是线程私有的，很显然一个系统创建的对象会有很多，而且有些对象会比较大，如果设计成线程私有的，那么如果有很多线程同时工作，那么都必须给他们分配相应的私有内存，我相信内存很快就撑爆了，很显然将堆设计为线程共享是最好不过了，不过凡事都具有两面性，线程共享的设计这也带来了&lt;strong&gt;多线程并发资源冲突问题&lt;/strong&gt;，关于这个问题由于不是本系列博客的主旨，这里就不做详细介绍了。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;②、存放对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　基本上所有的对象实例和数组都要在堆上进行分配，但是随着 JIT 编译器的发展和逃逸分析技术的成熟，栈上分配、标量替换等优化技术会导致对象不一定在堆上进行分配。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;③、垃圾收集&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　Java堆也被称为“GC堆”，是垃圾回收器的主要操作内存区域。当前垃圾回收器都是使用的分代收集算法，所以Java堆还可以分为：新生代和老年代，而新生代又可以分为 Eden 空间、From Survivor 空间、To Survivor空间。这是为了更好的回收内存，关于垃圾回收算法在后续博客会详细介绍。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1120165/201807/1120165-20180722113121049-1392980428.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;④、抛出 OutOfMemoryError 异常&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　根据Java虚拟机规范，Java堆可以处于物理上不连续的内存空间中，只要逻辑上连续即可，实现时既可以实现成固定大小，也可以是扩展的。如果在堆中没有完成实例分配，并且堆也无法扩展，将抛出OutOfMemoryError 异常。&lt;/p&gt;
&lt;h3&gt;6、方法区&lt;/h3&gt;
&lt;p&gt; 　　方法区（Method Area）用来存储已被Java虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。&lt;/p&gt;
&lt;p&gt;　　方法区也称为“永久代”，这是因为垃圾回收器对方法区的垃圾回收比较少，主要是针对常量池的回收以及对类型的卸载，回收条件比较苛刻。经常会导致对此内存未完全回收而导致内存泄露，最后当方法区无法满足内存分配时，将抛出 OutOfMemoryError 异常。&lt;/p&gt;
&lt;p&gt;　　PS：在Java虚拟机规范中把方法区描述为堆的一个逻辑部分（&lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.4&quot; target=&quot;_blank&quot;&gt;https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.4&lt;/a&gt;），在很多虚拟机中（JRockit、IBM J9等虚拟机不存在永久代的概念）。&lt;/p&gt;
&lt;p&gt;　　　　 在JDK1.8 的 HotSpot 虚拟机中，已经去掉了方法区的概念，用 Metaspace 代替，并且将其移到了本地内存来规划了。&lt;/p&gt;
&lt;h3&gt;7、运行时常量池&lt;/h3&gt;
&lt;p&gt; 　　在Java虚拟机规范中，运行时常量池（Runtime Constant Pool）用于存放编译期生成的各种字面量和符号引用，是&lt;strong&gt;方法区&lt;/strong&gt;的一部分。但是Java虚拟机规范对其没有做任何细节的要求，所以不同虚拟机实现商可以按照自己的需求来实现该区域，比如在 &lt;strong&gt;HotSpot&lt;/strong&gt; 虚拟机实现中，就将运行时常量池移到了堆中。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;①、存放字面量、符号引用、直接引用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　通常来说，该区域除了保存Class文件中描述的引用外，还会把翻译出来的直接引用也存储在运行时常量池，并且Java语言并不要求常量一定只能在编译器产生，运行期间也可能将常量放入池中，比如String类的intern()方法，&lt;strong&gt;当调用intern方法时，如果池中已经包含一个与该&lt;code&gt;String&lt;/code&gt;确定的字符串相同&lt;code&gt;equals(Object)&lt;/code&gt;的字符串，则返回该字符串。否则，将此&lt;code&gt;String&lt;/code&gt;对象添加到池中，并返回此对象的引用。&lt;/strong&gt;关于该方法的介绍可以看我&lt;a href=&quot;https://www.cnblogs.com/ysocean/p/8571426.html#_label12&quot; target=&quot;_blank&quot;&gt;这篇博客&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;②、抛出 OutOfMemoryError 异常&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　运行时常量池是方法区的一部分，会受到方法区内存的限制，当常量池无法申请到内存时，会抛出该异常。&lt;/p&gt;
&lt;h3&gt;8、直接内存&lt;/h3&gt;
&lt;p&gt;　　直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，它也不是Java虚拟机规范定义的内存区域。我们可以看到在 HotSpot 中，就将方法区移除了，用元数据区来代替，并且将元数据区从虚拟机运行时数据区移除了，转到了本地内存中，也就是说这块区域是受本机物理内存的限制，当申请的内存超过了本机物理内存，才会抛出 OutOfMemoryError 异常。&lt;/p&gt;
&lt;p&gt;　　直接内存也是受本机物理内存的限制，在JDK1.4中新加入的 NIO（new input/output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的 I/O 方式，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在Java堆里面的 DirectByteBuffer 对象作为这块内存的引用操作，这样避免了在Java堆和Native堆中来回复制数据，显著提高性能。&lt;/p&gt;

</description>
<pubDate>Thu, 04 Jul 2019 23:20:00 +0000</pubDate>
<dc:creator>YSOcean</dc:creator>
<og:description>Java虚拟机详解（二）------内存结构</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ysocean/p/9345622.html</dc:identifier>
</item>
<item>
<title>跟我学SpringCloud | 第五篇：熔断监控Hystrix Dashboard和Turbine - 极客挖掘机</title>
<link>http://www.cnblogs.com/babycomeon/p/11130009.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/babycomeon/p/11130009.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Springboot: 2.1.6.RELEASE&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;SpringCloud: Greenwich.SR1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;如无特殊说明，本系列教程全采用以上版本&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Hystrix-dashboard是一款针对Hystrix进行实时监控的工具，通过Hystrix Dashboard我们可以在直观地看到各Hystrix Command的请求响应时间, 请求成功率等数据。但是只使用Hystrix Dashboard的话, 你只能看到单个应用内的服务信息, 这明显不够。我们需要一个工具能让我们汇总系统内多个服务的数据并显示到Hystrix Dashboard上, 这个工具就是Turbine。&lt;/p&gt;
&lt;h2 id=&quot;hystrix-dashboard&quot;&gt;1. Hystrix Dashboard&lt;/h2&gt;
&lt;p&gt;创建一个新的项目hystrix-dashboard，延用上一篇文章提到的eureka和producer两个项目。&lt;/p&gt;
&lt;h4 id=&quot;hystrix-dashboard-pom.xml-依赖包管理&quot;&gt;1. hystrix-dashboard pom.xml 依赖包管理&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;
    &amp;lt;parent&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;2.1.6.RELEASE&amp;lt;/version&amp;gt;
        &amp;lt;relativePath/&amp;gt; &amp;lt;!-- lookup parent from repository --&amp;gt;
    &amp;lt;/parent&amp;gt;
    &amp;lt;groupId&amp;gt;com.springcloud&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;hystrix-dashboard&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;name&amp;gt;hystrix-dashboard&amp;lt;/name&amp;gt;
    &amp;lt;description&amp;gt;Demo project for Spring Boot&amp;lt;/description&amp;gt;

    &amp;lt;properties&amp;gt;
        &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt;
        &amp;lt;spring-cloud.version&amp;gt;Greenwich.SR1&amp;lt;/spring-cloud.version&amp;gt;
    &amp;lt;/properties&amp;gt;

    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-actuator&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-client&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-hystrix&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-hystrix-dashboard&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-cloud-starter-openfeign&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;

    &amp;lt;dependencyManagement&amp;gt;
        &amp;lt;dependencies&amp;gt;
            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-cloud-dependencies&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;${spring-cloud.version}&amp;lt;/version&amp;gt;
                &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt;
                &amp;lt;scope&amp;gt;import&amp;lt;/scope&amp;gt;
            &amp;lt;/dependency&amp;gt;
        &amp;lt;/dependencies&amp;gt;
    &amp;lt;/dependencyManagement&amp;gt;

    &amp;lt;build&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt;

&amp;lt;/project&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;前面介绍过的包我这里不再多说，讲几个前面没有见过的包：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;actuator：&lt;/strong&gt; 这个包是用来做服务监控的，很多监控相关的功能都会用到这个包，具体的内容我这里先不讲，后面会专门有一篇来讲这个。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;hystrix-dashboard：&lt;/strong&gt; 这个是今天的主角，hystrix-dashboard帮我们封装好了hystrix的监控面板。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;启动类-hystrixdashboardapplication.java&quot;&gt;2. 启动类 HystrixDashboardApplication.java&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;package com.springcloud.hystrixdashboard;

import com.netflix.hystrix.contrib.metrics.eventstream.HystrixMetricsStreamServlet;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.web.servlet.ServletRegistrationBean;
import org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;
import org.springframework.cloud.netflix.hystrix.dashboard.EnableHystrixDashboard;
import org.springframework.cloud.openfeign.EnableFeignClients;
import org.springframework.context.annotation.Bean;

@SpringBootApplication
@EnableEurekaClient
@EnableFeignClients
@EnableHystrixDashboard
@EnableCircuitBreaker
public class HystrixDashboardApplication {

    public static void main(String[] args) {
        SpringApplication.run(HystrixDashboardApplication.class, args);
    }

    @Bean
    public ServletRegistrationBean getServlet(){
        HystrixMetricsStreamServlet streamServlet = new HystrixMetricsStreamServlet();
        ServletRegistrationBean registrationBean = new ServletRegistrationBean(streamServlet);
        registrationBean.setLoadOnStartup(1);
        registrationBean.addUrlMappings(&quot;/hystrix.stream&quot;);
        registrationBean.setName(&quot;HystrixMetricsStreamServlet&quot;);
        return registrationBean;
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动类添加启用Hystrix Dashboard和熔断器&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 各位看官这里一定要注意，我在这里注册了HystrixMetricsStreamServlet，在springboot1.x版本下，这里是无需生命的，在2.x版本后，这里才需要注册HystrixMetricsStreamServlet，并且显示的给出访问路径。&lt;/p&gt;
&lt;h4 id=&quot;测试&quot;&gt;3. 测试&lt;/h4&gt;
&lt;p&gt;又到了测试时间，我们先把昨天的eureka和producer CV到今天的工作目录下，顺次启动服务，HystrixDashboard最后启动，启动完成后我们访问：http://localhost:8081/hystrix，将会看到如下界面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://springcloud-oss.oss-cn-shanghai.aliyuncs.com/chapter5/hystrix-dashboard.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图中会有一些提示：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Cluster via Turbine (default cluster): http://turbine-hostname:port/turbine.stream&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Cluster via Turbine (custom cluster): http://turbine-hostname:port/turbine.stream?cluster=[clusterName]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Single Hystrix App: http://hystrix-app:port/hystrix.stream&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;大致大概意思就是如果查看默认集群使用第一个url,查看指定集群使用第二个url,单个应用的监控使用最后一个，我们暂时只演示单个应用的所以在输入框中输入： http://localhost:8081/hystrix.stream ，输入之后点击 monitor，进入页面。&lt;/p&gt;
&lt;p&gt;如果没有请求会先显示Loading ...，访问http://localhost:8081/hystrix.stream 也会不断的显示ping。&lt;/p&gt;
&lt;p&gt;我们请求一下昨天用过的链接：http://localhost:8081/hello/spring。&lt;/p&gt;
&lt;p&gt;马上就能看到统计信息了。&lt;/p&gt;
&lt;p&gt;可以再访问一下http://localhost:8081/hystrix.stream，显示如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ping: 

data: {&quot;type&quot;:...}

data: {&quot;type&quot;:...}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;说明已经返回了监控的各项结果.&lt;/p&gt;
&lt;p&gt;到了监控页面就会显示如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://springcloud-oss.oss-cn-shanghai.aliyuncs.com/chapter5/stream.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其实就是http://localhost:8081/hystrix.stream返回结果的图形化显示，Hystrix Dashboard Wiki上详细说明了图上每个指标的含义，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://springcloud-oss.oss-cn-shanghai.aliyuncs.com/chapter5/hystrix-dashboard-3.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到此单个应用的熔断监控已经完成。&lt;/p&gt;
&lt;h2 id=&quot;turbine&quot;&gt;2. Turbine&lt;/h2&gt;
&lt;p&gt;在复杂的分布式系统中，相同服务的节点经常需要部署上百甚至上千个，很多时候，运维人员希望能够把相同服务的节点状态以一个整体集群的形式展现出来，这样可以更好的把握整个系统的状态。 为此，Netflix提供了一个开源项目（Turbine）来提供把多个hystrix.stream的内容聚合为一个数据源供Dashboard展示。&lt;/p&gt;
&lt;h4 id=&quot;turbine-pom.xml&quot;&gt;1. Turbine pom.xml&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;
    &amp;lt;parent&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;2.1.6.RELEASE&amp;lt;/version&amp;gt;
        &amp;lt;relativePath/&amp;gt; &amp;lt;!-- lookup parent from repository --&amp;gt;
    &amp;lt;/parent&amp;gt;
    &amp;lt;groupId&amp;gt;com.springcloud&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;turbine&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;name&amp;gt;turbine&amp;lt;/name&amp;gt;
    &amp;lt;description&amp;gt;Demo project for Spring Boot&amp;lt;/description&amp;gt;

    &amp;lt;properties&amp;gt;
        &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt;
        &amp;lt;spring-cloud.version&amp;gt;Greenwich.SR1&amp;lt;/spring-cloud.version&amp;gt;
    &amp;lt;/properties&amp;gt;

    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-actuator&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-hystrix-dashboard&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-turbine&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;

    &amp;lt;dependencyManagement&amp;gt;
        &amp;lt;dependencies&amp;gt;
            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-cloud-dependencies&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;${spring-cloud.version}&amp;lt;/version&amp;gt;
                &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt;
                &amp;lt;scope&amp;gt;import&amp;lt;/scope&amp;gt;
            &amp;lt;/dependency&amp;gt;
        &amp;lt;/dependencies&amp;gt;
    &amp;lt;/dependencyManagement&amp;gt;

    &amp;lt;build&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt;

&amp;lt;/project&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;配置文件&quot;&gt;2. 配置文件&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;server:
  port: 8888
spring:
  application:
    name: hystrix-dashboard-turbine
turbine:
  app-config: node01,node02
  aggregator:
    cluster-config: default
  cluster-name-expression: new String(&quot;default&quot;)
  combine-host-port: true
eureka:
  client:
    service-url:
      defaultZone: http://localhost:8761/eureka/
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;turbine.appConfig：&lt;/strong&gt; 配置Eureka中的serviceId列表，表明监控哪些服务&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;turbine.aggregator.clusterConfig：&lt;/strong&gt; 指定聚合哪些集群，多个使用”,”分割，默认为default。可使用http://.../turbine.stream?cluster={clusterConfig之一}访问&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;turbine.clusterNameExpression：&lt;/strong&gt; 1. clusterNameExpression指定集群名称，默认表达式appName；此时：turbine.aggregator.clusterConfig需要配置想要监控的应用名称；2. 当clusterNameExpression: default时，turbine.aggregator.clusterConfig可以不写，因为默认就是default；3. 当clusterNameExpression: metadata[‘cluster’]时，假设想要监控的应用配置了eureka.instance.metadata-map.cluster: ABC，则需要配置，同时turbine.aggregator.clusterConfig: ABC&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;启动类&quot;&gt;3. 启动类&lt;/h4&gt;
&lt;p&gt;启动类添加@EnableTurbine，激活对Turbine的支持&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.springcloud.turbine;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.hystrix.dashboard.EnableHystrixDashboard;
import org.springframework.cloud.netflix.turbine.EnableTurbine;

@SpringBootApplication
@EnableHystrixDashboard
@EnableTurbine
public class TurbineApplication {

    public static void main(String[] args) {
        SpringApplication.run(TurbineApplication.class, args);
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;创建消费者集群&quot;&gt;4. 创建消费者集群&lt;/h4&gt;
&lt;p&gt;将昨天的消费者copy2份到今天的文件路径下，修改名称为consumers-node01，consumers-node02&lt;/p&gt;
&lt;p&gt;增加依赖包&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-hystrix-dashboard&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动类增加HystrixMetricsStreamServlet注册&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.springcloud.consumers;

import com.netflix.hystrix.contrib.metrics.eventstream.HystrixMetricsStreamServlet;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.web.servlet.ServletRegistrationBean;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;
import org.springframework.cloud.openfeign.EnableFeignClients;
import org.springframework.context.annotation.Bean;

@SpringBootApplication
@EnableEurekaClient
@EnableFeignClients
public class ConsumersApplication {

    public static void main(String[] args) {
        SpringApplication.run(ConsumersApplication.class, args);
    }

    @Bean
    public ServletRegistrationBean getServlet(){
        HystrixMetricsStreamServlet streamServlet = new HystrixMetricsStreamServlet();
        ServletRegistrationBean registrationBean = new ServletRegistrationBean(streamServlet);
        registrationBean.setLoadOnStartup(1);
        registrationBean.addUrlMappings(&quot;/actuator/hystrix.stream&quot;);
        registrationBean.setName(&quot;HystrixMetricsStreamServlet&quot;);
        return registrationBean;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 这里注册的HystrixMetricsStreamServlet访问路径是&quot;/actuator/hystrix.stream&quot;，这是因为Turbine默认访问的是这个路径。&lt;/p&gt;
&lt;p&gt;两个配置文件大家自行修改启动端口号，spring.application.name分别修改为node01和node02&lt;/p&gt;
&lt;h4 id=&quot;测试-1&quot;&gt;5. 测试&lt;/h4&gt;
&lt;p&gt;现在依次启动注册中心，两个消费者和Turbine，顺次访问两个消费者，并访问 http://localhost:8888/turbine.stream， 会返回和上面一样的一穿ping的信息。&lt;/p&gt;
&lt;p&gt;并且会不断刷新以获取实时的监控数据，说明和单个的监控类似，返回监控项目的信息。&lt;/p&gt;
&lt;p&gt;进行图形化监控查看，输入：http://localhost:8888/hystrix，返回酷酷的小熊界面，输入： http://localhost:8888/turbine.stream，然后点击 Monitor Stream ,可以看到出现了俩个监控列表（这是理论情况）&lt;/p&gt;
&lt;p&gt;注意，这里本地环境无法测试成功，本地环境只能显示一个服务，Turbine日志中会报错&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;你的主机中的软件中止了一个已建立的连接。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;原因目前不明，已经在github上提Issues。&lt;/p&gt;
</description>
<pubDate>Thu, 04 Jul 2019 23:16:00 +0000</pubDate>
<dc:creator>极客挖掘机</dc:creator>
<og:description>SpringCloud系列教程 | 第五篇：熔断监控Hystrix Dashboard和Turbine Springboot: 2.1.6.RELEASE SpringCloud: Greenwich</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/babycomeon/p/11130009.html</dc:identifier>
</item>
<item>
<title>dubbo整合springboot最详细入门教程 - 布尔bl</title>
<link>http://www.cnblogs.com/chenzhuantou/p/11135976.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenzhuantou/p/11135976.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/07/05/ZaELxe.jpg&quot; alt=&quot;ZaELxe.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;说明&quot;&gt;说明&lt;/h2&gt;
&lt;p&gt;目前互联网公司，大部分项目都是基于分布式，一个项目被拆分成几个小项目，这些小项目会分别部署在不同的计算机上面，这个叫做微服务。当一台计算机的程序需要调用另一台计算机代码的时候，就涉及远程调用。此时dubbo就粉末登场了。&lt;/p&gt;
&lt;h2 id=&quot;搭建工程&quot;&gt;搭建工程&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/07/04/ZU6JWq.png&quot; alt=&quot;ZU6JWq.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/07/04/ZU6aOU.png&quot; alt=&quot;ZU6aOU.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/07/04/ZU6BTJ.png&quot; alt=&quot;ZU6BTJ.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;idea新建工程后，删除src文件夹，然后在gradle文件中输入&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;buildscript {
    repositories {
        maven { url 'http://maven.aliyun.com/nexus/content/groups/public/' }
        mavenCentral()
    }
    dependencies {
        classpath 'org.springframework.boot:spring-boot-gradle-plugin:1.5.21.RELEASE'
    }
}


plugins {
    id 'java'
}
apply plugin: 'org.springframework.boot'
apply plugin: 'war'
group 'com.demoMuty'
version '1.0-SNAPSHOT'
sourceCompatibility = 1.8

repositories {
    maven { url 'http://maven.aliyun.com/nexus/content/groups/public/' }
    mavenCentral()
}

dependencies {
    compile 'org.springframework.boot:spring-boot-starter-mail'
    compile 'org.springframework.boot:spring-boot-starter-thymeleaf'
    compile 'org.springframework.boot:spring-boot-starter-web'
    compile 'org.mybatis.spring.boot:mybatis-spring-boot-starter:1.3.4'
    compile 'com.alibaba.boot:dubbo-spring-boot-starter:0.1.0'
    compile 'com.101tec:zkclient:0.10'
//  developmentOnly 'org.springframework.boot:spring-boot-devtools'
    runtime 'mysql:mysql-connector-java'
    compile(&quot;com.baomidou:mybatis-plus-boot-starter:3.1.0&quot;)
    compile(&quot;com.baomidou:mybatis-plus-generator:3.1.1&quot;)
    compileOnly 'org.projectlombok:lombok'
    testCompile 'org.springframework.boot:spring-boot-starter-test'
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如图所示&lt;br/&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/07/04/ZUcM1x.png&quot; alt=&quot;ZUcM1x.png&quot;/&gt;&lt;br/&gt;boolean作为父工程，然后再见三个模块&lt;br/&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/07/04/ZUcsHg.png&quot; alt=&quot;ZUcsHg.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;booleanone作为父模块 booleanteo作为服务者模块 booleanthree作为消费者模块&lt;/p&gt;
&lt;h2 id=&quot;添加dubbo.xml&quot;&gt;添加dubbo.xml&lt;/h2&gt;
&lt;p&gt;然后在每个模块新建com.test包，在包下新建启动类&lt;br/&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/07/04/ZUgvJs.png&quot; alt=&quot;ZUgvJs.png&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@SpringBootApplication
public class BaseApplication extends SpringBootServletInitializer {
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在每个模块的gradle文件中引入上面的依赖，然后在消费者模块和生产者模块的依赖中加入父模块依赖，如图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/07/04/ZUg6sK.png&quot; alt=&quot;ZUg6sK.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后在booleantwo的生产者模块的resource资源文件中加入dubbo文件&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://code.alibabatech.com/schema/dubbo
        http://code.alibabatech.com/schema/dubbo/dubbo.xsd
        &quot;&amp;gt;

    &amp;lt;!-- 提供方应用信息，用于计算依赖关系 --&amp;gt;
    &amp;lt;dubbo:application name=&quot;hello-world-app&quot;/&amp;gt;

    &amp;lt;!-- 使用multicast广播注册中心暴露服务地址 --&amp;gt;
    &amp;lt;dubbo:registry address=&quot;zookeeper://localhost:2181&quot;/&amp;gt;

    &amp;lt;!-- 用dubbo协议在20880端口暴露服务 --&amp;gt;
    &amp;lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20880&quot;/&amp;gt;

    &amp;lt;!-- 声明需要暴露的服务接口 --&amp;gt;
    &amp;lt;dubbo:service
            interface=&quot;com.test1.provider.DemoService&quot;
            ref=&quot;demoService&quot;
            group=&quot;hello-world-app&quot;
            version=&quot;1.0.0&quot;
    /&amp;gt;
&amp;lt;/beans&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在启动类中加入注解&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@ImportResource({&quot;classpath:dubbo.xml&quot;})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在booleantwo的消费者模块的resource资源文件中加入dubbo文件&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://code.alibabatech.com/schema/dubbo
        http://code.alibabatech.com/schema/dubbo/dubbo.xsd
        &quot;&amp;gt;

&amp;lt;!-- 提供方应用信息，用于计算依赖关系 --&amp;gt;
&amp;lt;dubbo:application name=&quot;hello-world-app&quot;/&amp;gt;

&amp;lt;!-- 使用multicast广播注册中心暴露服务地址 --&amp;gt;
&amp;lt;dubbo:registry address=&quot;zookeeper://localhost:2181&quot;/&amp;gt;

&amp;lt;!-- 生成远程服务代理，可以和本地bean一样使用demoService --&amp;gt;
&amp;lt;dubbo:reference
        interface=&quot;com.test1.provider.DemoService&quot;
        group=&quot;hello-world-app&quot;
        version=&quot;1.0.0&quot;
        id=&quot;demoService&quot;/&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在启动类中加入注解&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@ImportResource({&quot;classpath:dubbo.xml&quot;})&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;编写dubbo代码&quot;&gt;编写dubbo代码&lt;/h2&gt;
&lt;p&gt;在父模块中写dubbo接口&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.test1.provider;

/**
 * @author buer
 * create 2019/7/2 22:13
 * description
 */
public interface DemoService {
    String sayHello(String name);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在生产者模块中写dubbo实现类&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.test1.dubbo;

import com.test1.provider.DemoService;
import org.springframework.stereotype.Service;

/**
 * @author buer
 * create 2019/7/2 22:14
 * description
 */
@Service(&quot;demoService&quot;)
public class DemoServiceImpl implements DemoService {
    @Override
    public String sayHello(String name) {
        return &quot;hello,dubbo&quot;+name;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在消费者模块中写dubbo调用&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
package com.test1.controller;

import com.test1.provider.DemoService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * @author boolean
 * Date: 2019/7/2 19:48
 * description:
 */
@RestController
public class he {
    @Autowired
    private DemoService demoService;

    @RequestMapping(&quot;/he&quot;)
    public String hello(){
        return &quot;he&quot;;
    }

    @RequestMapping(&quot;/chen&quot;)
    public String hello1(){
        return demoService.sayHello(&quot;chen&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;启动&quot;&gt;启动&lt;/h2&gt;
&lt;p&gt;最后添加war包&lt;br/&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/07/04/ZUXOGq.png&quot; alt=&quot;ZUXOGq.png&quot;/&gt;&lt;br/&gt;打开zkServer.cmd&lt;br/&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/07/04/ZUjMod.png&quot; alt=&quot;ZUjMod.png&quot;/&gt;&lt;br/&gt;启动信息&lt;br/&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/07/04/ZUXzsU.png&quot; alt=&quot;ZUXzsU.png&quot;/&gt;&lt;br/&gt;如果启动有乱码的话&lt;/p&gt;
&lt;p&gt;回到idea软件 打开tomcat的设置 找到VM options:,然后输入&lt;br/&gt;-Dfile.encoding=UTF-8&lt;/p&gt;
&lt;h2 id=&quot;测试&quot;&gt;测试&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/07/04/ZUxRi9.png&quot; alt=&quot;ZUxRi9.png&quot;/&gt;&lt;br/&gt;代码地址：&lt;/p&gt;
&lt;p&gt;https://github.com/blackdogss/HelloWorld.git&lt;/p&gt;
&lt;h2 id=&quot;公众号&quot;&gt;公众号&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/07/05/ZaAFFf.png&quot; alt=&quot;ZaAFFf.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 04 Jul 2019 17:03:00 +0000</pubDate>
<dc:creator>布尔bl</dc:creator>
<og:description>说明 目前互联网公司，大部分项目都是基于分布式，一个项目被拆分成几个小项目，这些小项目会分别部署在不同的计算机上面，这个叫做微服务。当一台计算机的程序需要调用另一台计算机代码的时候，就涉及远程调用。此</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chenzhuantou/p/11135976.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core on K8S学习初探（3）部署API到K8S - Edison Chou</title>
<link>http://www.cnblogs.com/edisonchou/p/aspnet_core_on_k8s_firststudy_part3.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/edisonchou/p/aspnet_core_on_k8s_firststudy_part3.html</guid>
<description>&lt;p&gt;在上一篇《&lt;a href=&quot;https://www.cnblogs.com/edisonchou/p/aspnet_core_on_k8s_firststudy_part2.html&quot; target=&quot;_blank&quot;&gt;基本概念快速一览&lt;/a&gt;》中，我们把基本的一些概念快速地简单地不求甚解地过了一下，本篇开始我们会将ASP.NET Core WebAPI部署到K8S，从而结束初探的旅程。&lt;/p&gt;
&lt;blockquote readability=&quot;3.8280542986425&quot;&gt;
&lt;p&gt;Section 1 - &lt;a href=&quot;https://www.cnblogs.com/edisonchou/p/aspnet_core_on_k8s_firststudy_part1.html&quot;&gt;ASP.NET Core on K8S学习初探（1）K8S单节点环境搭建&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Section 2 - &lt;a href=&quot;https://www.cnblogs.com/edisonchou/p/aspnet_core_on_k8s_firststudy_part2.html&quot;&gt;ASP.NET Core on K8S学习初探（2）K8S基本概念快速一览&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Section 3 - ASP.NET Core on K8S学习初探（3）部署API到K8S&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　这里准备一个空的ASP.NET Core WebAPI项目，使用默认自带的ValuesController控制器，具体代码见&lt;a href=&quot;https://github.com/EdisonChou/AspNetCore.On.K8S/tree/master/src/01_hello-k8s/EDC.K8S.Demo.WebApi&quot; target=&quot;_blank&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;　　Dockerfile如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
FROM microsoft/dotnet:&lt;span&gt;2.1&lt;/span&gt;-aspnetcore-runtime AS &lt;span&gt;base&lt;/span&gt;&lt;span&gt;
WORKDIR &lt;/span&gt;/&lt;span&gt;app
EXPOSE &lt;/span&gt;&lt;span&gt;80&lt;/span&gt;&lt;span&gt;

FROM microsoft&lt;/span&gt;/dotnet:&lt;span&gt;2.1&lt;/span&gt;-&lt;span&gt;sdk AS build
WORKDIR &lt;/span&gt;/&lt;span&gt;src
COPY . .

RUN dotnet restore
RUN dotnet build &lt;/span&gt;-c Release -o /&lt;span&gt;app

FROM build AS publish
RUN dotnet publish &lt;/span&gt;-c Release -o /&lt;span&gt;app

FROM &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt; AS final
WORKDIR &lt;/span&gt;/&lt;span&gt;app
COPY &lt;/span&gt;--&lt;span&gt;from&lt;/span&gt;=publish /&lt;span&gt;app .
ENTRYPOINT [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dotnet&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;EDC.K8S.Demo.WebApi.dll&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我们可以事先在自己的Docker环境构建这样的一个镜像，看看能否正常使用。&lt;/p&gt;
&lt;p&gt;　　由于后面会使用到这个镜像，因此可以将此镜像push到&lt;a href=&quot;https://hub.docker.com&quot; target=&quot;_blank&quot;&gt;Docker Hub&lt;/a&gt;上。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
docker push your-image-name:tagname
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　当然你也可以直接使用我上传的这个镜像（edisonsaonian/k8s-demo）。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201907/381412-20190704230802546-1084887579.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;2.1 准备Deployment YAML&lt;/h2&gt;
&lt;p&gt;　　在上一篇中我们知道Deployment主要负责Pod的编排，那么我们这里就通过一个YAML来创建一个Deployment。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
apiVersion: apps/&lt;span&gt;v1
kind: Deployment
metadata:
  name: k8s&lt;/span&gt;-&lt;span&gt;demo
  &lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt;: aspnetcore
  labels:
    name: k8s&lt;/span&gt;-&lt;span&gt;demo
spec:
  replicas: &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
  selector:
    matchLabels:
      name: k8s&lt;/span&gt;-&lt;span&gt;demo
  template:
    metadata:
      labels:
        name: k8s&lt;/span&gt;-&lt;span&gt;demo
    spec:
      containers:
      &lt;/span&gt;- name: k8s-&lt;span&gt;demo
        image: edisonsaonian&lt;/span&gt;/k8s-&lt;span&gt;demo
        ports:
        &lt;/span&gt;- containerPort: &lt;span&gt;80&lt;/span&gt;&lt;span&gt;
        imagePullPolicy: Always

&lt;/span&gt;---&lt;span&gt;

kind: Service
apiVersion: v1
metadata:
  name: k8s&lt;/span&gt;-&lt;span&gt;demo
  &lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt;: aspnetcore
spec:
  type: NodePort
  ports:
    &lt;/span&gt;- port: &lt;span&gt;80&lt;/span&gt;&lt;span&gt;
      targetPort: &lt;/span&gt;&lt;span&gt;80&lt;/span&gt;&lt;span&gt;
  selector:
    name: k8s&lt;/span&gt;-demo
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里这个deploy.yaml就会告诉K8S关于你的API的所有信息，以及通过什么样的方式暴露出来让外部访问。&lt;/p&gt;
&lt;p&gt;　　需要注意的是，这里我们提前为要部署的ASP.NET Core WebAPI项目创建了一个namespace，叫做aspnetcore，因此这里写的namespace : aspnetcore。&lt;/p&gt;
&lt;p&gt;　　K8S中通过标签来区分不同的服务，因此这里统一name写成了k8s-demo。&lt;/p&gt;
&lt;p&gt;　　在多实例的配置上，通过replicas : 2这个设置告诉K8S给我启动2个实例起来，当然你可以写更大的一个数量值。&lt;/p&gt;
&lt;p&gt;　　最后，在spec中告诉K8S我要通过NodePort的方式暴露出来公开访问，因此端口范围从上一篇可以知道，应该是 30000-32767这个范围之内。&lt;/p&gt;
&lt;h2&gt;2.2 通过kubectl部署到K8S&lt;/h2&gt;
&lt;p&gt;　　首先，确保你的Docker for Windows以及Kubernetes都启动起来了。&lt;/p&gt;
&lt;p&gt;　　然后，在Powershell中通过kubectl完成API的部署，只需要下面这一句命令行即可：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
kubectl create -f deploy.yaml
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201907/381412-20190704231845375-1550566867.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　看到上面的提示&quot;service created&quot;，就可以知道已经创建好了，这里我们再通过下面这个命令来验证一下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
kubectl &lt;span&gt;get&lt;/span&gt; svc -n aspnetcore
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201907/381412-20190704232024294-684500717.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　可以看到，在命名空间aspnetcore下，就有了一个k8s-demo的服务运行起来了，并通过端口号31435向外部提供访问。&lt;/p&gt;
&lt;h2&gt;2.3 在K8S中验证WebAPI&lt;/h2&gt;
&lt;p&gt;　　首先，我们可以通过浏览器来访问一下这个API接口，看看是否能正常访问到。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;/api/values&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201907/381412-20190704232222869-1582519881.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;/api/values/1000&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201907/381412-20190704232248531-1243811655.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　其次，还记得在第一篇中部署的Dashboard吗？我们通过Dashboard来看看我们的k8s-demo的状态：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201907/381412-20190704232447196-773216759.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　从Dashboard中可以看到更为详细的信息，包括运行的Deployment、容器组（由于我们设置的replicas=2，因此会有2个容器运行起来）、副本集等等，也可以通过Dashboard实时初步地监控我们的API的运行情况。&lt;/p&gt;

&lt;h2&gt;3.1 通过Dashboard伸缩WebAPI&lt;/h2&gt;
&lt;p&gt;　　在Dashboard中，我们可以可视化地对我们的Deployment进行容器实例的伸缩，如下图所示：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201907/381412-20190704232829710-142397424.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在弹出的伸缩选项对话框中输入个数，例如我们这里从2个缩减为1个，然后确定。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201907/381412-20190704232904939-355439095.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　再次观看Dashboard，可以看到已经从原来的2个容器实例变为1个了。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201907/381412-20190704232940918-87844413.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;3.2 通过Kubectl伸缩WebAPI&lt;/h2&gt;
&lt;p&gt;　　除了在Dashboard中可视化地操作进行伸缩，也可以通过kubectl来进行，例如下面这句命令，将容器实例扩展到3个。需要注意的是，由于我们的k8s-demo所在的命名空间是在aspnetcore下，因此也需要指明--namespace=aspnetcore。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
kubectl scale deployment k8s-demo --replicas=&lt;span&gt;3&lt;/span&gt; --&lt;span&gt;namespace&lt;/span&gt;=aspnetcore
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201907/381412-20190704233253797-89909816.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　再到Dashboard中来验证一下，是否扩展到了3个容器实例：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201907/381412-20190704233453902-542370658.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;3.2 自动伸缩WebAPI实例&lt;/h2&gt;
&lt;p&gt;　　在K8S中，提供了一个autoscale接口来实现服务的自动伸缩，它会采用默认的自动伸缩策略（例如根据CPU的负载情况）来帮助我们实现弹性伸缩的功能。例如下面这句命令可以实现我们的k8s-demo可以伸缩的范围是1~3个，根据负载情况自己伸缩，在没有多少请求量压力很小时收缩为一个，在压力较大时启动另一个实例来降低负载。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
kubectl autoscale deployment k8s-demo --min=&lt;span&gt;1&lt;/span&gt; --max=&lt;span&gt;3 &lt;span&gt;--namespace=&lt;/span&gt;aspnetcore&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201907/381412-20190704233738538-446980324.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;4.1 常用Kubectl命令&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
kubectl &lt;span&gt;get&lt;/span&gt; svc -n kube-system  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取指定命名空间的服务&lt;/span&gt;
kubectl cluster-info &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取集群信息&lt;/span&gt;
kubectl &lt;span&gt;get&lt;/span&gt; nodes &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取集群节点信息&lt;/span&gt;
kubectl delete node &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;2.152&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除节点 192.168.2.152&lt;/span&gt;
kubectl &lt;span&gt;get&lt;/span&gt; namespaces &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取所有命名空间&lt;/span&gt;
kubectl create &lt;span&gt;namespace&lt;/span&gt; aspnetcore &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建一个命名空间“aspnetcore”&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　更多kubectl命令参考：&lt;/p&gt;
&lt;p&gt;　　（1）&lt;a href=&quot;https://jimmysong.io/kubernetes-handbook/guide/kubectl-cheatsheet.html&quot; target=&quot;_blank&quot;&gt;https://jimmysong.io/kubernetes-handbook/guide/kubectl-cheatsheet.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　（2）&lt;a href=&quot;https://www.jianshu.com/p/fb5c0d115421&quot; target=&quot;_blank&quot;&gt;https://www.jianshu.com/p/fb5c0d115421&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;4.2 YAML文件解析&lt;/h2&gt;
&lt;p&gt; 　　关于YAML文件各个节点的解释，可以通过下面这个命令去了解：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
kubectl explain deployment.metadata
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201907/381412-20190704234349953-1029596526.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　更多YAML文件的节点参考：&lt;a href=&quot;https://www.kubernetes.org.cn/1414.html&quot;&gt;https://www.kubernetes.org.cn/1414.html&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;4.3 更多K8S基础知识？&lt;/h2&gt;
&lt;p&gt;　　推荐阅读《&lt;a href=&quot;http://www.ijiandao.com/2b/baijia/290521.html&quot; target=&quot;_blank&quot;&gt;18张插画了解Kubernetes背景与概念&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201907/381412-20190704234624690-990379422.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　本文简单的介绍了一下在Docker for Windows环境下，通过kubectl部署一个ASP.NET Core WebAPI到K8S中，并初步使用了K8S的伸缩特性对Deployment进行实例的伸缩，体验了一下所谓的容器的编排。当然，笔者也是初玩，有很多还没学习，这也只是K8S的冰山一角，后续我会学习在Linux下部署K8S的生产级集群环境，深入学习K8S的各种概念并实践，最后会学习阿里云ACK服务（容器服务Kubernetes版）或腾讯云TKE服务（基于Kubernetes的容器服务）去部署和实践公司的生产环境，相信到时也会有很多的分享的！&lt;/p&gt;


&lt;div id=&quot;Copyright&quot; readability=&quot;8.2242990654206&quot;&gt;
&lt;p&gt;作者：&lt;a title=&quot;author&quot; href=&quot;http://www.edisonchou.cn&quot; target=&quot;_blank&quot;&gt;周旭龙&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;出处：&lt;a title=&quot;from&quot; href=&quot;http://edisonchou.cnblogs.com&quot; target=&quot;_blank&quot;&gt;http://edisonchou.cnblogs.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接。&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Thu, 04 Jul 2019 15:57:00 +0000</pubDate>
<dc:creator>Edison Chou</dc:creator>
<og:description>在上一篇《基本概念快速一览》中，我们把基本的一些概念快速地简单地不求甚解地过了一下，本篇开始我们会将ASP.NET Core WebAPI部署到K8S，从而结束初探的旅程。 Section 1 -</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/edisonchou/p/aspnet_core_on_k8s_firststudy_part3.html</dc:identifier>
</item>
</channel>
</rss>