<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>聊聊Lambda架构 - 渡码</title>
<link>http://www.cnblogs.com/duma/p/11013531.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/duma/p/11013531.html</guid>
<description>&lt;h2&gt;定义&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;在数据分析场景中，我们可能会遇到这样的问题。例如，我们要做一个推荐系统，如果我们用批处理任务去做，一天或者一小时的推荐频次明显延迟太大。如果用流处理任务，虽然延迟的问题解决了，然而只用实时数据而没有历史数据，那么准确性就无法保证。因此需要结合批处理的历史数据和流处理的实时数据进行处理，既能保证准确性，又能保证实时性。再比如反作弊系统，实时识别作弊用户的时候同时需要用到用户的历史行为。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;针对上述问题，Storm 的作者 Nathan Marz 提出了 Lambda 架构。&lt;/span&gt;&lt;span&gt;根据维基百科的定义，Lambda 架构的设计是为了在处理大规模数据时，同时发挥流处理和批处理的优势。通过批处理提供全面、准确的数据，通过流处理提供低延迟的数据，从而达到平衡延迟、吞吐量和容错性的目的。为了满足下游的即席查询，批处理和流处理的结果会进行合并。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从上面定义可以看出，Lambda 架构包含三层，Batch Layer、Speed Layer 和 Serving Layer。架构图如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1129006/201906/1129006-20190612233533812-829039313.png&quot; alt=&quot;&quot; width=&quot;605&quot; height=&quot;229&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面分别介绍这三层架构的作用。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;Batch Layer&lt;/strong&gt;：批处理层，对离线的历史数据进行预计算，为了下游能够快速查询想要的结果。由于批处理基于完整的历史数据集，因此准确性可以得到保证。批处理层可以用 Hadoop、Spark 和 Flink 等框架计算&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;Speed Layer&lt;/strong&gt;：加速处理层，处理实时的增量数据，这一层重点在于低延迟。加速层的数据不如批处理层那样完整和准确，但是可以填补批处理高延迟导致的数据空白。加速层可以用 Storm、Spark streaming 和 Flink 等框架计算&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;Serving Layer&lt;/strong&gt;：合并层，计算历史数据和实时数据都有了， 合并层的工作自然就是将两者数据合并，输出到数据库或者其他介质，供下游分析。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;Amazon AWS 的 Lambda 架构&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;这里，我将用 AWS 作为例子来介绍 Lambda 架构，AWS Lambda 架构图如下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1129006/201906/1129006-20190612234748885-460852205.png&quot; alt=&quot;&quot; width=&quot;829&quot; height=&quot;407&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;Batch Layer&lt;/strong&gt;：使用 S3 bucket 从各种数据源收集数据，使用 AWS Glue 进行 ETL，输出到 Amazon S3。数据也可以输出到 Amazon Athena （交互式查询工具）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Speed Layer&lt;/strong&gt;： 从上图看加速层有三个过程&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;Kinesis Stream 从实时数据流中处理增量的数据，这部分数据数据输出到 Serving Layer 的 Amazon EMR，也可以输出到 Kinesis Firehose 对增量数据进行后续处理&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Kinesis Firehose 处理增量数据并写入 Amazone S3 中&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Kinesis Analytics 提供 SQL 的能力对增量的数据进行分析&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;其实只有上面第一个组件与我们今天讨论的 Lambda 架构有关，其他两个组件只是针对实时处理的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Serving Layer&lt;/strong&gt;：合并层使用基于 Amazon EMR 的 Spark SQL 来合并 Batch Layer 和 Speed Layer 的数据。批处理数据可以从 Amazon S3 加载批处理数据，实时数据可以从 Kinesis Stream 直接加载，合并的数据可以写到 Amazone S3。下面是一段合并数据代码&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1129006/201906/1129006-20190613001549730-2034971902.png&quot; alt=&quot;&quot; width=&quot;789&quot; height=&quot;346&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以上便是 Amazon AWS 实现 Lambda 架构的简单介绍。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;我的经历&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;接下来分享下我之前的项目经历。其实，我们的项目跟上面的 Lambda 架构并不是特别贴合，但是我觉得思想是一致的。本质上都是批处理和流处理相关补充，同时发挥二者的优势。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们的业务是处理用户的定位数据，最开始主要使用 Spark Streaming 进行增量处理，处理后的数据实时写入 MongoDB。数据读写以用户 id 为粒度，由于粒度比较细，因此每天的数据量比较大。前端如果查询时间跨度较大的数据，每次都需按照用户粒度数据做聚合，导致查询响应比较慢且容易影响实时写入。因此，我们用批处理任务对历史的离线数据进行预计算，再存储到 MongoDB。同时我们开发了基于 gRPC 实现的一套 Service 来充当 Serving Layer，将历史的数据与实时的数据合并返回给前端，避免前端直接连接数据库。在这个项目中我们的 Batch Layer 和 Speed Layer 都是用的 Spark 框架，因此维护相对容易。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;之前介绍 Lambda 都是用加速层弥补批处理层的空白，但是上面的例子中是用批处理层弥补加速层的不足。因此，架构设计只是一个思想，具体的实施还是要根据业务进行灵活变通，不能生搬硬套。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;小结&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;本篇文章简单介绍了 Lambda 架构的内容，同时介绍了 Amazon AWS 实现 Lambda 架构的例子。最后举了一个我自己项目中的一个例子。经过整篇内容我们了解了 Lambda 架构的优势，但是它有没有缺点呢。显然也是有的，我能想到的有以下几点：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;批处理层、加速层和合并层用到的框架可能不一样，因此会增加了开发的成本&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;批处理层和加速层处理的结果有可能不一致，如果用户看到的数据会变，这个体验不太好&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果某一层的逻辑变了，是不是其他两层或者一层的逻辑也要跟着变，因此层与层处理逻辑耦合度较大&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;你还能想到其他的问题吗， 以及有没有更好的架构能解决这个问题？欢迎交流&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;欢迎关注公众号&lt;strong/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1129006/201906/1129006-20190610224613682-287034495.png&quot; alt=&quot;&quot; width=&quot;162&quot; height=&quot;161&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 13 Jun 2019 00:33:00 +0000</pubDate>
<dc:creator>渡码</dc:creator>
<og:description>定义 在数据分析场景中，我们可能会遇到这样的问题。例如，我们要做一个推荐系统，如果我们用批处理任务去做，一天或者一小时的推荐频次明显延迟太大。如果用流处理任务，虽然延迟的问题解决了，然而只用实时数据而</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/duma/p/11013531.html</dc:identifier>
</item>
<item>
<title>Spire.Doc 生成pdf业务运营报告 - 天戈朱</title>
<link>http://www.cnblogs.com/tgzhu/p/11003290.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tgzhu/p/11003290.html</guid>
<description>&lt;p&gt;&lt;span&gt;  需求：每天向全国各运营大区钉钉运营群定时发送pdf业务运营报告；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  通过对各Office操作组件对比，选择Spire.Doc。它专门为开发人员进行创建，读取，写入、转换打印 word 文档文件提供便利，不需要安装 MS Office即可对 word、Excel、Pdf 进行操作。包含商业版与免费版，其中免费版对文档页数有限制（&lt;span&gt;&lt;em&gt;Free version is limited to &lt;span&gt;500 paragraphs and 25 tables&lt;/span&gt;. This limitation is enforced during reading or writing files. When converting word documents to PDF and XPS files, you can only get the first &lt;span&gt;3 page of PDF file&lt;/span&gt;.&lt;/em&gt;&lt;/span&gt;）。官方地址：&lt;a href=&quot;https://www.e-iceblue.com/&quot;&gt;https://www.e-iceblue.com/&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;组件安装&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;打开Visual Studio ，选择 “工具&quot; --&amp;gt;”NuGet包管理器“ --&amp;gt;”程序包管理控制台“&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;输入：Install-Package FreeSpire.Doc -Version 7.1.13&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;其中：可安装的历史版本可参见：&lt;a href=&quot;https://www.nuget.org/packages/FreeSpire.Doc&quot; target=&quot;_blank&quot;&gt;https://www.nuget.org/packages/FreeSpire.Doc&lt;/a&gt;， 如下图：&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1004194/201906/1004194-20190612175110558-1682649059.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;常用操作&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;1、加载Word模板&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li readability=&quot;-1.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Document document = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Document();
document.LoadFromFile(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sample.docx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, FileFormat.Docx);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt; 2 、获取模板中的表格&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li readability=&quot;-1.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取第一个节&lt;/span&gt;
Section section = document.Sections[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取第一个表格，若模板中有多个表格，则序号从0开始依次顺延&lt;/span&gt;
Table table = section.Tables[&lt;span&gt;0&lt;/span&gt;] &lt;span&gt;as&lt;/span&gt; Table;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;3、表格行列操作&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li readability=&quot;1.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加一行到表格的最后&lt;/span&gt;
table.AddRow(&lt;span&gt;true&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;插入一行到表格的第三行&lt;/span&gt;
table.Rows.Insert(&lt;span&gt;2&lt;/span&gt;&lt;span&gt;, table.AddRow());

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加一列到表格，设置单元格的宽度和宽度类型&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; table.Rows.Count; i++&lt;span&gt;)
{
    TableCell cell &lt;/span&gt;= table.Rows[i].AddCell(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
    cell.Width &lt;/span&gt;= table[&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;].Width;
    cell.CellWidthType &lt;/span&gt;= table[&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;].CellWidthType;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除第二行&lt;/span&gt;
table.Rows.RemoveAt(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除第二列&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; table.Rows.Count; i++&lt;span&gt;)
{
    table.Rows[i].Cells.RemoveAt(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置第一行的行高&lt;/span&gt;
table.Rows[&lt;span&gt;0&lt;/span&gt;].Height = &lt;span&gt;40&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置第二列的列宽&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; table.Rows.Count; i++&lt;span&gt;)
{    
    table.Rows[i].Cells[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;].Width = &lt;span&gt;40&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;4、表格单元格赋值及样式 &lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加第1行&lt;/span&gt;
TableRow row1 =&lt;span&gt; table.AddRow();

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加第1个单元格到第1行&lt;/span&gt;
TableCell cell1 =&lt;span&gt; row1.AddCell();
cell1.AddParagraph().AppendText(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;姓 名&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加第2个单元格到第1行&lt;/span&gt;
TableCell cell2 =&lt;span&gt; row1.AddCell();
cell2.AddParagraph().AppendText(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;年 龄&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置表格的第二行第一列水平居左                        &lt;/span&gt;
table[&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;].Paragraphs[&lt;span&gt;0&lt;/span&gt;].Format.HorizontalAlignment =&lt;span&gt; HorizontalAlignment.Left;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置表格第二行第一列垂直居上&lt;/span&gt;
table[&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;].CellFormat.VerticalAlignment =&lt;span&gt; VerticalAlignment.Top;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置第二行第一个单元格的背景颜色&lt;/span&gt;
table[&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;].CellFormat.BackColor =&lt;span&gt; Color.SeaGreen;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过 TextRange.CharacterFormat 来设置单元格内文本属性，如：阴影，字体、颜色等&lt;/span&gt;
TextRange HText = paragraph.AppendText(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;this is a test!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
HText.CharacterFormat.IsShadow &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
HText.CharacterFormat.FontSize &lt;/span&gt;= &lt;span&gt;80&lt;/span&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;5、表格样式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6、写操作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;应用开发步骤&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;新建Word报告模板，包括变量、表格等，模板中的表格，我是在Excel中画好后复制过来的,如下图：&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1004194/201906/1004194-20190612201310318-2038383219.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;NuGet安装Spire.Doc组件&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;加载Word模板，获取业务数据填充表格&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;保存pdf文档，免费组件只能最多3页数据，因此在定义Word模板时，将文档长宽设置为文档允许的最大高度，以便于显示更多的内容&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;示例应用效果如下图：&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1004194/201906/1004194-20190612202128970-976979659.png&quot; alt=&quot;&quot; width=&quot;829&quot; height=&quot;724&quot;/&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;文档中设置的联查，可以在数据填充的过程中设置联查到你的业务系统，联查的设置参见上一节的第4小节，单元格内的paragraph允许向其内添加不同的控件，如：文本、图片、超链、复选框等，点击联查应用效果如下图（当然你得控制访问权限）： &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1004194/201906/1004194-20190612202835008-1043317221.png&quot; alt=&quot;&quot; width=&quot;834&quot; height=&quot;496&quot;/&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;生成报告是本需求的核心，你可以将生成的文档保存至指定的Web站点对应的目录下，然后建立钉钉机器人，定时发送消息，消息体指定为一个http地址即可，应用效果如下图：&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1004194/201906/1004194-20190612203418922-1614135912.png&quot; alt=&quot;&quot; width=&quot;828&quot; height=&quot;515&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;参考文档&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 13 Jun 2019 00:18:00 +0000</pubDate>
<dc:creator>天戈朱</dc:creator>
<og:description>需求：每天向全国各运营大区钉钉运营群定时发送pdf业务运营报告； 通过对各Office操作组件对比，选择Spire.Doc。它专门为开发人员进行创建，读取，写入、转换打印 word 文档文件提供便利，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tgzhu/p/11003290.html</dc:identifier>
</item>
<item>
<title>asp.net core 集成JWT - 7tiny</title>
<link>http://www.cnblogs.com/7tiny/p/11012035.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/7tiny/p/11012035.html</guid>
<description>&lt;h2&gt;【什么是JWT】&lt;/h2&gt;
&lt;p&gt;　　JSON Web Token（JWT）是目前最流行的跨域身份验证解决方案。&lt;/p&gt;
&lt;p&gt;　　JWT的官网地址：&lt;a href=&quot;https://jwt.io/&quot; target=&quot;_blank&quot;&gt;https://jwt.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　通俗地来讲，JWT是能代表用户身份的令牌，可以使用JWT令牌在api接口中校验用户的身份以确认用户是否有访问api的权限。&lt;/p&gt;
&lt;p&gt;　　JWT中包含了身份认证必须的参数以及用户自定义的参数，&lt;span&gt;&lt;span&gt;JWT可以使用秘密（使用&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;HMAC&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;算法）或使用&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;RSA&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;或&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;ECDSA&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;的公钥/私钥对进行&lt;/span&gt;&lt;span&gt;签名&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;【什么时候应该使用JSON Web令牌？】&lt;/h2&gt;
&lt;ol readability=&quot;1&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;授权：这是使用JWT的最常见方案。一旦用户登录，每个后续请求将包括JWT，允许用户访问该令牌允许的路由，服务和资源。Single Sign On是一种现在广泛使用JWT的功能，因为它的开销很小，并且能够在不同的域中轻松使用。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;信息交换：JSON Web令牌是在各方之间安全传输信息的好方法。因为JWT可以签名 - 例如，使用公钥/私钥对 - 您可以确定发件人是他们所说的人。此外，由于使用标头和有效负载计算签名，您还可以验证内容是否未被篡改。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;【JWT有什么优势？】&lt;/h2&gt;
&lt;h4&gt;　　我们先看我们传统的身份校验方式&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;用户向服务器发送用户名和密码。&lt;/li&gt;
&lt;li&gt;服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。&lt;/li&gt;
&lt;li&gt;服务器向用户返回一个 session_id，写入用户的 Cookie。&lt;/li&gt;
&lt;li&gt;用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。&lt;/li&gt;
&lt;li&gt;服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　　这种模式的问题在于，扩展性（scaling）不好。单机当然没有问题，如果是服务器集群，或者是跨域的服务导向架构，就要求 session 数据共享，每台服务器都能够读取 session。如果session存储的节点挂了，那么整个服务都会瘫痪，体验相当不好，风险也很高。&lt;/p&gt;
&lt;p&gt;　　相比之下，JWT的实现方式是将用户信息存储在客户端，服务端不进行保存。每次请求都把令牌带上以校验用户登录状态，这样服务就变成了无状态的，服务器集群也很好扩展。&lt;/p&gt;
&lt;h2&gt;【JWT令牌结构】&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　在紧凑的形式中，JSON Web Tokens由dot（&lt;/span&gt;&lt;/span&gt;&lt;code&gt;.&lt;/code&gt;&lt;span&gt;&lt;span&gt;）&lt;/span&gt;&lt;span&gt;分隔的三个部分组成&lt;/span&gt;&lt;span&gt;，它们是：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Header　头&lt;/li&gt;
&lt;li&gt;Payload　有效载荷&lt;/li&gt;
&lt;li&gt;Signature　签名&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　因此，JWT通常如下所示：&lt;/p&gt;
&lt;p&gt;　　xxxxx.yyyyy.zzzzz&lt;/p&gt;
&lt;h4&gt;　　1.Header 头&lt;/h4&gt;
&lt;p&gt;　　&lt;span&gt;&lt;span&gt;标头&lt;/span&gt;&lt;/span&gt;&lt;em&gt;&lt;span&gt;&lt;span&gt;通常&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;span&gt;&lt;span&gt;由两部分组成：令牌的类型，即JWT，以及正在使用的签名算法，例如HMAC SHA256或RSA。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　例如：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&quot;alg&quot;: &quot;HS256&quot;&lt;span&gt;,
  &lt;/span&gt;&quot;typ&quot;: &quot;JWT&quot;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;&lt;span&gt;然后，这个JSON被&lt;/span&gt;&lt;span&gt;编码&lt;/span&gt;&lt;span&gt;为&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;Base64Url&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;，形成JWT的第一部分。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;　　2.Payload 有效载荷&lt;/h4&gt;
&lt;p&gt;　　Payload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。JWT 规定了7个官方字段，供选用。&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li&gt;
&lt;p&gt;iss (issuer)：签发人&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;exp (expiration time)：过期时间&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;sub (subject)：主题&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;aud (audience)：受众&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;nbf (Not Before)：生效时间&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;iat (Issued At)：签发时间&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;jti (JWT ID)：编号&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　除了官方字段，你还可以在这个部分定义私有字段，下面就是一个例子。例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&quot;sub&quot;: &quot;1234567890&quot;&lt;span&gt;,
  &lt;/span&gt;&quot;name&quot;: &quot;John Doe&quot;&lt;span&gt;,
  &lt;/span&gt;&quot;admin&quot;: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　注意，JWT 默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。这个 JSON 对象也要使用 Base64URL 算法转成字符串。&lt;/p&gt;
&lt;h4&gt;　　3.Signature　签名&lt;/h4&gt;
&lt;p&gt;　　Signature 部分是对前两部分的签名，防止数据篡改。&lt;/p&gt;
&lt;p&gt;　　首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;HMACSHA256(
  base64UrlEncode(header) &lt;/span&gt;+ &quot;.&quot; +&lt;span&gt;
  base64UrlEncode(payload),
  secret)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　签名用于验证消息在此过程中未被更改，并且，在使用私钥签名的令牌的情况下，它还可以验证JWT的发件人是否是它所声称的人。　　&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;span&gt;　&lt;strong&gt;把他们三个全部放在一起&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　输出是三个由点分隔的Base64-URL字符串，可以在HTML和HTTP环境中轻松传递，而与基于XML的标准（如SAML）相比更加紧凑。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　下面显示了一个JWT，它具有先前的头和​​有效负载编码，并使用机密签名。 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201906/998608-20190612203731579-330783312.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;span&gt;如果您想使用JWT并将这些概念付诸实践，您可以使用&lt;/span&gt;&lt;/span&gt;&lt;a href=&quot;http://jwt.io/&quot;&gt;&lt;span&gt;&lt;span&gt;jwt.io Debugger&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;来解码，验证和生成JWT。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201906/998608-20190612203819742-1549182390.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;【JSON Web令牌如何工作？】&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;在身份验证中，当用户使用其凭据成功登录时，将返回JSON Web令牌。&lt;/span&gt;&lt;span&gt;由于令牌是凭证，因此必须非常小心以防止出现安全问题。&lt;/span&gt;&lt;span&gt;一般情况下，您不应该将令牌保留的时间超过要求。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;span&gt;每当用户想要访问受保护的路由或资源时，用户代理应该&lt;/span&gt;&lt;span&gt;使用&lt;/span&gt;&lt;span&gt;承载&lt;/span&gt;&lt;span&gt;模式&lt;/span&gt;&lt;span&gt;发送JWT，通常在&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;Authorization&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;标头中&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;标题的内容应如下所示：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　Authorization: Bearer &amp;lt;token&amp;gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;span&gt;在某些情况下，这可以是无状态授权机制。&lt;/span&gt;&lt;span&gt;服务器的受保护路由将检查&lt;/span&gt;&lt;/span&gt;&lt;code&gt;Authorization&lt;/code&gt;&lt;span&gt;&lt;span&gt;标头中&lt;/span&gt;&lt;span&gt;的有效JWT &lt;/span&gt;&lt;span&gt;，如果存在，则允许用户访问受保护资源。&lt;/span&gt;&lt;span&gt;如果JWT包含必要的数据，则可以减少查询数据库以进行某些操作的需要，尽管可能并非总是如此。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;span&gt;如果在标&lt;/span&gt;&lt;/span&gt;&lt;code&gt;Authorization&lt;/code&gt;&lt;span&gt;&lt;span&gt;头中&lt;/span&gt;&lt;span&gt;发送令牌&lt;/span&gt;&lt;span&gt;，则跨域资源共享（CORS）将不会成为问题，因为它不使用cookie。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　下图显示了如何获取JWT并用于访问API或资源：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201906/998608-20190612204041691-1832137404.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;应用程序向授权服务器请求授权&lt;/li&gt;
&lt;li&gt;校验用户身份，校验成功，返回token&lt;/li&gt;
&lt;li&gt;应用程序使用访问令牌访问受保护的资源&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;【ASP.Net Core 集成JWT】&lt;/h2&gt;
&lt;p&gt;　　前面我们介绍了JWT的原理，下面我们在asp.net core实际项目中集成JWT。&lt;/p&gt;
&lt;p&gt;　　首先我们新建一个Demo asp.net core 空web项目&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201906/998608-20190612204724789-2111438119.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;　　添加数据访问模拟api，ValuesController&lt;/h4&gt;
&lt;p&gt;　　其中api/value1是可以直接访问的，api/value2添加了权限校验特性标签 [Authorize]&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Authorization;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Mvc;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Demo.Jwt.Controllers
{
    [ApiController]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ValuesController : ControllerBase
    {
        [HttpGet]
        [Route(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api/value1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ActionResult&amp;lt;IEnumerable&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt; Get()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
        }

        [HttpGet]
        [Route(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api/value2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        [Authorize]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ActionResult&amp;lt;IEnumerable&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt; Get2()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;　　添加模拟登陆，生成Token的api，AuthController&lt;/h4&gt;
&lt;p&gt;　　这里模拟一下登陆校验，只验证了用户密码不为空即通过校验，真实环境完善校验用户和密码的逻辑。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.IdentityModel.Tokens.Jwt;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Security.Claims;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Authorization;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Http;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Mvc;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.IdentityModel.Tokens;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Demo.Jwt.Controllers
{
    [Route(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api/[controller]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    [ApiController]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AuthController : ControllerBase
    {
        [AllowAnonymous]
        [HttpGet]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IActionResult Get(&lt;span&gt;string&lt;/span&gt; userName, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; pwd)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;string&lt;/span&gt;.IsNullOrEmpty(userName) &amp;amp;&amp;amp; !&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(pwd))
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; claims = &lt;span&gt;new&lt;/span&gt;&lt;span&gt;[]
                {
                    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Claim(JwtRegisteredClaimNames.Nbf,$&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{new DateTimeOffset(DateTime.Now).ToUnixTimeSeconds()}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) ,
                    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Claim (JwtRegisteredClaimNames.Exp,$&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{new DateTimeOffset(DateTime.Now.AddMinutes(30)).ToUnixTimeSeconds()}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
                    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Claim(ClaimTypes.Name, userName)
                };
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; key = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SymmetricSecurityKey(Encoding.UTF8.GetBytes(Const.SecurityKey));
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; creds = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SigningCredentials(key, SecurityAlgorithms.HmacSha256);
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; token = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JwtSecurityToken(
                    issuer: Const.Domain,
                    audience: Const.Domain,
                    claims: claims,
                    expires: DateTime.Now.AddMinutes(&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;&lt;span&gt;),
                    signingCredentials: creds);

                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Ok(&lt;span&gt;new&lt;/span&gt;&lt;span&gt;
                {
                    token &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JwtSecurityTokenHandler().WriteToken(token)
                });
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; BadRequest(&lt;span&gt;new&lt;/span&gt; { message = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;username or password is incorrect.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; });
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;　　Startup添加JWT验证的相关配置&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Authentication.JwtBearer;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Builder;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Hosting;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Mvc;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.Configuration;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.DependencyInjection;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.IdentityModel.Tokens;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;


&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Demo.Jwt
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Startup
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Startup(IConfiguration configuration)
        {
            Configuration &lt;/span&gt;=&lt;span&gt; configuration;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IConfiguration Configuration { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; This method gets called by the runtime. Use this method to add services to the container.&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加jwt验证：&lt;/span&gt;
&lt;span&gt;            services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
                .AddJwtBearer(options &lt;/span&gt;=&amp;gt;&lt;span&gt; {
                    options.TokenValidationParameters &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TokenValidationParameters
                    {
                        ValidateIssuer &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否验证Issuer&lt;/span&gt;
                        ValidateAudience = &lt;span&gt;true&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否验证Audience&lt;/span&gt;
                        ValidateLifetime = &lt;span&gt;true&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否验证失效时间&lt;/span&gt;
                        ClockSkew = TimeSpan.FromSeconds(&lt;span&gt;30&lt;/span&gt;&lt;span&gt;),
                        ValidateIssuerSigningKey &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否验证SecurityKey&lt;/span&gt;
                        ValidAudience = Const.Domain,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Audience&lt;/span&gt;
                        ValidIssuer = Const.Domain,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Issuer，这两项和前面签发jwt的设置一致&lt;/span&gt;
                        IssuerSigningKey = &lt;span&gt;new&lt;/span&gt; SymmetricSecurityKey(Encoding.UTF8.GetBytes(Const.SecurityKey))&lt;span&gt;//&lt;/span&gt;&lt;span&gt;拿到SecurityKey&lt;/span&gt;
&lt;span&gt;                    };
                });

            services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2);
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; This method gets called by the runtime. Use this method to configure the HTTP request pipeline.&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app, IHostingEnvironment env)
        {
            &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;添加jwt验证&lt;/span&gt;
&lt;span&gt;            app.UseAuthentication();

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (env.IsDevelopment())
            {
                app.UseDeveloperExceptionPage();
            }

            app.UseMvc(routes &lt;/span&gt;=&amp;gt;&lt;span&gt;
            {
                routes.MapRoute(
                    name: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                        template: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{controller=Home}/{action=Index}/{id?}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            });
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;　　最后把代码里面用到的一些相关常量也粘贴过来，Const.cs&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Demo.Jwt
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Const
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 这里为了演示，写死一个密钥。实际生产环境可以从配置文件读取,这个是用网上工具随便生成的一个密钥
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; SecurityKey = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDI2a2EJ7m872v0afyoSDJT2o1+SitIeJSWtLJU8/Wz2m7gStexajkeD+Lka6DSTy8gt9UwfgVQo6uKjVLG5Ex7PiGOODVqAEghBuS7JzIYU5RvI543nNDAPfnJsas96mSA7L/mD7RTE2drj6hf3oZjJpMPZUQI/B1Qjb5H3K3PNwIDAQAB&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Domain = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:5000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　到这里，已经是我们项目的所有代码了。&lt;/p&gt;
&lt;p&gt;　　如果需要完整的项目代码，Github地址：&lt;a href=&quot;https://github.com/sevenTiny/Demo.Jwt&quot; target=&quot;_blank&quot;&gt;https://github.com/sevenTiny/Demo.Jwt&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;【JWT测试】&lt;/h2&gt;
&lt;p&gt; 　　我们找一个趁手的工具，比如fiddler，然后把我们的web站点运行起来&lt;/p&gt;
&lt;p&gt;　　首先调用无权限的接口：http://localhost:5000/api/value1&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201906/998608-20190612210847103-761861033.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201906/998608-20190612210904407-811199721.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　正确地返回了数据，那么接下来我们测试JWT的流程&lt;/p&gt;
&lt;h4&gt;　　1. 无权限&lt;/h4&gt;
&lt;p&gt;　　首先我们什么都不加调用接口：http://localhost:5000/api/value2&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201906/998608-20190612210451568-208825811.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201906/998608-20190612210551083-131706055.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　返回了状态码401，也就是未经授权:访问由于凭据无效被拒绝。 说明JWT校验生效了，我们的接口收到了保护。&lt;/p&gt;
&lt;h4&gt;　　2.获取Token&lt;/h4&gt;
&lt;p&gt;　　调用模拟登陆授权接口：http://localhost:5000/api/Auth?userName=zhangsan&amp;amp;pwd=123&lt;/p&gt;
&lt;p&gt;　　这里的用户密码是随便写的，因为我们模拟登陆只是校验了下非空，因此写什么都能通过&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201906/998608-20190612211036300-1542333543.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　成功得到了响应&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201906/998608-20190612211129852-998461064.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201906/998608-20190612211141133-2025469516.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　然后我们得到了一个xxx.yyy.zzz 格式的 token 值。我们把token复制出来&lt;/p&gt;
&lt;h4&gt;　　3.在刚才401的接口请求HEADER中添加JWT的参数，把我们的token加上去&lt;/h4&gt;
&lt;p&gt;　　再次调用我们的模拟数据接口，但是这次我们加了一个HEADER：http://localhost:5000/api/value2&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201906/998608-20190612211605338-1304787952.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　把内容粘出来&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
User-&lt;span&gt;Agent: Fiddler
Host: localhost:&lt;/span&gt;&lt;span&gt;5000&lt;/span&gt;&lt;span&gt;
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYmYiOiIxNTYwMzQ1MDIxIiwiZXhwIjoxNTYwMzQ2ODIxLCJodHRwOi8vc2NoZW1hcy54bWxzb2FwLm9yZy93cy8yMDA1LzA1L2lkZW50aXR5L2NsYWltcy9uYW1lIjoiemhhbmdzYW4iLCJpc3MiOiJodHRwOi8vbG9jYWxob3N0OjUwMDAiLCJhdWQiOiJodHRwOi8vbG9jYWxob3N0OjUwMDAifQ.x7Slk4ho1hZc8sR8_McVTB6VEYLz_v&lt;/span&gt;-5eaHvXtIDS-o
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里需要注意 Bearer 后面是有一个空格的，然后就是我们上一步获取到的token&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201906/998608-20190612211704037-776363322.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201906/998608-20190612211714814-778048096.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　嗯，没有401了，成功返回了数据&lt;/p&gt;
&lt;h4&gt;　　4.JWT的Token过期&lt;/h4&gt;
&lt;p&gt;　　我们且倒一杯开水，坐等30分钟（我们代码中设置的过期时间），然后再次调用数据接口：http://localhost:5000/api/value2&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201906/998608-20190612211838172-1714000743.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201906/998608-20190612211855561-1370400281.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　又变成了401，我们看下详细的返回数据&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201906/998608-20190612211927469-1744741191.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这里有标注，错误描述 token过期，说明我们设置的token过期时间生效了&lt;/p&gt;
&lt;h2&gt;【结束】&lt;/h2&gt;
&lt;p&gt;　　到这里，我们JWT的简介以及asp.net core 集成JWT已经完美完成，当然了这只是一个demo，在实际的应用中需要补充和完善的地方还有很多。&lt;/p&gt;
&lt;p&gt;　　如果想要完整项目源码的，可以参考地址：&lt;a href=&quot;https://github.com/sevenTiny/Demo.Jwt&quot; target=&quot;_blank&quot;&gt;https://github.com/sevenTiny/Demo.Jwt&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　如果有幸能帮助到你，高抬贵手点个star吧~&lt;/p&gt;
</description>
<pubDate>Wed, 12 Jun 2019 23:36:00 +0000</pubDate>
<dc:creator>7tiny</dc:creator>
<og:description>【什么是JWT】 JSON Web Token（JWT）是目前最流行的跨域身份验证解决方案。 JWT的官网地址：https://jwt.io/ 通俗地来讲，JWT是能代表用户身份的令牌，可以使用JWT</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/7tiny/p/11012035.html</dc:identifier>
</item>
<item>
<title>spark内存管理器--MemoryManager源码解析 - _朱葛</title>
<link>http://www.cnblogs.com/zhuge134/p/11013826.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhuge134/p/11013826.html</guid>
<description>&lt;p&gt;内存管理器可以说是spark内核中最重要的基础模块之一，shuffle时的排序，rdd缓存，展开内存，广播变量，Task运行结果的存储等等，凡是需要使用内存的地方都需要向内存管理器定额申请。我认为内存管理器的主要作用是为了尽可能减小内存溢出的同时提高内存利用率。旧版本的spark的内存管理是静态内存管理器StaticMemoryManager，而新版本（应该是从1.6之后吧，记不清了）则改成了统一内存管理器UnifiedMemoryManager，同一内存管理器相对于静态内存管理器最大的区别在于执行内存和存储内存二者之间没有明确的界限，可以相互借用，但是执行内存的优先级更高，也就是说如果执行内存不够用就会挤占存储内存，这时会将一部分缓存的rdd溢写到磁盘上直到腾出足够的空间。但是执行内存任何情况下都不会被挤占，想想这也可以理解，毕竟执行内存是用于shuffle时排序的，这只能在内存中进行，而rdd缓存的要求就没有这么严格。&lt;br/&gt;有几个参数控制各个部分内存的使用比例，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;spark.memory.fraction，默认值0.6，这个参数控制spark内存管理器管理的内存占内存存的比例（准确地说是：堆内存-300m，300m是为永久代预留），也就是说执行内存和存储内存加起来只有（堆内存-300m）的0.6，剩余的0.4是用于用户代码执行过程中的内存占用，比如你的代码中可能会加载一些较大的文件到内存中，或者做一些排序，用户代码使用的内存并不受内存管理器管理，所以需要预留一定的比例。&lt;/li&gt;
&lt;li&gt;spark.memory.storageFraction，默认值0.5，顾名思义，这个值决定了存储内存的占比，注意是占内存管理器管理的那部分内存的比例，剩余的部分用作执行内存。例如，默认情况下，存储内存占堆内存的比例是0.6 * 0.5 = 0.3（当然准确地说是占堆内存-300m的比例）。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;memorymanager概述&quot;&gt;MemoryManager概述&lt;/h3&gt;
&lt;p&gt;我们首先整体看一下MemoryManager这个类，&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    maxOnHeapStorageMemory
    maxOffHeapStorageMemory
    setMemoryStore
    acquireStorageMemory
    acquireUnrollMemory
    acquireExecutionMemory
    releaseExecutionMemory
    releaseAllExecutionMemoryForTask
    releaseStorageMemory
    releaseAllStorageMemory
    releaseUnrollMemory
    executionMemoryUsed
    storageMemoryUsed
    getExecutionMemoryUsageForTask&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以发现，MemoryManager内部的方法比较少而且是有规律的，它将内存在功能上分为三种：StorageMemory，UnrollMemory，ExecutionMemory，&lt;br/&gt;针对这三种内存分别有申请内存的方法和释放内存的方法，并且三种申请内存的方法都是抽象方法，由子类实现。&lt;br/&gt;此外，我们看一下MemoryManager内部有哪些成员变量：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    protected val onHeapStorageMemoryPool = new StorageMemoryPool(this, MemoryMode.ON_HEAP)
    protected val offHeapStorageMemoryPool = new StorageMemoryPool(this, MemoryMode.OFF_HEAP)
    protected val onHeapExecutionMemoryPool = new ExecutionMemoryPool(this, MemoryMode.ON_HEAP)
    protected val offHeapExecutionMemoryPool = new ExecutionMemoryPool(this, MemoryMode.OFF_HEAP)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这四个成员变量分别代表四种内存池。这里要注意的是，MemoryPool的构造其中有一个Object类型参数用于同步锁，MemoryPool内部的一些方法会获取该对象锁用于同步。&lt;br/&gt;我们看一下他们的初始化：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    onHeapStorageMemoryPool.incrementPoolSize(onHeapStorageMemory)
    onHeapExecutionMemoryPool.incrementPoolSize(onHeapExecutionMemory)
    offHeapExecutionMemoryPool.incrementPoolSize(maxOffHeapMemory - offHeapStorageMemory)
    offHeapStorageMemoryPool.incrementPoolSize(offHeapStorageMemory)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;memorymanager.releaseexecutionmemory&quot;&gt;MemoryManager.releaseExecutionMemory&lt;/h3&gt;
&lt;p&gt;其实就是调用ExecutionMemoryPool的相关方法，&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  private[memory]
  def releaseExecutionMemory(
      numBytes: Long,
      taskAttemptId: Long,
      memoryMode: MemoryMode): Unit = synchronized {
    memoryMode match {
      case MemoryMode.ON_HEAP =&amp;gt; onHeapExecutionMemoryPool.releaseMemory(numBytes, taskAttemptId)
      case MemoryMode.OFF_HEAP =&amp;gt; offHeapExecutionMemoryPool.releaseMemory(numBytes, taskAttemptId)
    }
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;executionmemorypool.releasememory&quot;&gt;ExecutionMemoryPool.releaseMemory&lt;/h4&gt;
&lt;p&gt;代码逻辑很简单，就不多说了。&lt;br/&gt;其实从这个方法，我们大概可以看出，spark内存管理的含义，其实spark的内存管理说到底就是对内存使用量的记录和管理，而并不是像操作系统或jvm那样真正地进行内存的分配和回收。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def releaseMemory(numBytes: Long, taskAttemptId: Long): Unit = lock.synchronized {
// 从内部的簿记量中获取该任务使用的内存
val curMem = memoryForTask.getOrElse(taskAttemptId, 0L)
// 检查要释放的内存是否超过了该任务实际使用的内存，并打印告警日志
var memoryToFree = if (curMem &amp;lt; numBytes) {
  logWarning(
    s&quot;Internal error: release called on $numBytes bytes but task only has $curMem bytes &quot; +
      s&quot;of memory from the $poolName pool&quot;)
  curMem
} else {
  numBytes
}
if (memoryForTask.contains(taskAttemptId)) {
  // 更新簿记量
  memoryForTask(taskAttemptId) -= memoryToFree
  // 如果该任务的内存使用量小于等于0，那么从簿记量中移除该任务
  if (memoryForTask(taskAttemptId) &amp;lt;= 0) {
    memoryForTask.remove(taskAttemptId)
  }
}
// 最后通知其他等待的线程
// 因为可能会有其他的任务在等待获取执行内存
lock.notifyAll() // Notify waiters in acquireMemory() that memory has been freed
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;memorymanager.releaseallexecutionmemoryfortask&quot;&gt;MemoryManager.releaseAllExecutionMemoryForTask&lt;/h4&gt;
&lt;p&gt;把堆上的执行内存和直接内存的执行内存中该任务使用的内存都释放掉，&lt;br/&gt;onHeapExecutionMemoryPool和offHeapExecutionMemoryPool是同一个类，只是一个记录执行内存对直接内存的使用，一个记录执行内存对堆内存的使用。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private[memory] def releaseAllExecutionMemoryForTask(taskAttemptId: Long): Long = synchronized {
onHeapExecutionMemoryPool.releaseAllMemoryForTask(taskAttemptId) +
  offHeapExecutionMemoryPool.releaseAllMemoryForTask(taskAttemptId)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;memorymanager.releasestoragememory&quot;&gt;MemoryManager.releaseStorageMemory&lt;/h4&gt;
&lt;p&gt;对于存储内存的使用的记录并没有执行内存那么细，不会记录每个RDD使用了多少内存&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def releaseStorageMemory(numBytes: Long, memoryMode: MemoryMode): Unit = synchronized {
memoryMode match {
  case MemoryMode.ON_HEAP =&amp;gt; onHeapStorageMemoryPool.releaseMemory(numBytes)
  case MemoryMode.OFF_HEAP =&amp;gt; offHeapStorageMemoryPool.releaseMemory(numBytes)
}
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;memorymanager.releaseunrollmemory&quot;&gt;MemoryManager.releaseUnrollMemory&lt;/h4&gt;
&lt;p&gt;这里，我们看一下释放展开内存的方法，发现展开内存使用的就是存储内存。回顾一下BlockManager部分，展开内存的申请主要是在将数据通过MemoryStore存储成块时需要将数据临时放在内存中，这时就需要申请展开内存。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;final def releaseUnrollMemory(numBytes: Long, memoryMode: MemoryMode): Unit = synchronized {
releaseStorageMemory(numBytes, memoryMode)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;从上面分析的几个释放内存的方法不难看出，所谓的释放内存其实只是对内存管理器内部的一些簿记量的改变，这就要求外部的调用者必须确保它们确实释放了这么多的内存，否则内存管理就会和实际的内存使用情况出现很大偏差。当然，好在内存管理器是spark内部的模块，并不向用户开放，所以在用户代码中不会调用内存管理模块。&lt;/p&gt;
&lt;h3 id=&quot;unifiedmemorymanager&quot;&gt;UnifiedMemoryManager&lt;/h3&gt;
&lt;p&gt;开篇我们讲到，spark的内存管理器分为两种，而新的版本默认都是使用统一内存管理器UnifiedMemoryManager，后面静态内存管理器会逐渐启用，所以这里我们也重点分析统一内存管理。&lt;br/&gt;前面，我们分析了父类MemoryManager中释放内存的几个方法，而申请内存的几个方法都是抽象方法，这些方法的实现都是在子类中，也就是UnifiedMemoryManager中实现的。&lt;/p&gt;
&lt;h4 id=&quot;unifiedmemorymanager.acquireexecutionmemory&quot;&gt;UnifiedMemoryManager.acquireExecutionMemory&lt;/h4&gt;
&lt;p&gt;这个方法是用来申请执行内存的。其中定义了几个局部方法，maybeGrowExecutionPool方法用来挤占存储内存以扩展执行内存空间；&lt;br/&gt;computeMaxExecutionPoolSize方法用来计算最大的执行内存大小。&lt;br/&gt;最后调用了executionPool.acquireMemory方法实际申请执行内存。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;override private[memory] def acquireExecutionMemory(
  numBytes: Long,
  taskAttemptId: Long,
  memoryMode: MemoryMode): Long = synchronized {
// 检查内存大小是否正确
assertInvariants()
assert(numBytes &amp;gt;= 0)
// 根据堆内存还是直接内存决定使用不同的内存池和内存大小
val (executionPool, storagePool, storageRegionSize, maxMemory) = memoryMode match {
  case MemoryMode.ON_HEAP =&amp;gt; (
    onHeapExecutionMemoryPool,
    onHeapStorageMemoryPool,
    onHeapStorageRegionSize,
    maxHeapMemory)
  case MemoryMode.OFF_HEAP =&amp;gt; (
    offHeapExecutionMemoryPool,
    offHeapStorageMemoryPool,
    offHeapStorageMemory,
    maxOffHeapMemory)
}

/**
 * Grow the execution pool by evicting cached blocks, thereby shrinking the storage pool.
 *
 * When acquiring memory for a task, the execution pool may need to make multiple
 * attempts. Each attempt must be able to evict storage in case another task jumps in
 * and caches a large block between the attempts. This is called once per attempt.
 */
// 通过挤占存储内存来扩张执行内存，
// 通过将缓存的块溢写到磁盘上，从而为执行内存腾出空间
def maybeGrowExecutionPool(extraMemoryNeeded: Long): Unit = {
  if (extraMemoryNeeded &amp;gt; 0) {
    // There is not enough free memory in the execution pool, so try to reclaim memory from
    // storage. We can reclaim any free memory from the storage pool. If the storage pool
    // has grown to become larger than `storageRegionSize`, we can evict blocks and reclaim
    // the memory that storage has borrowed from execution.
    // 我们可以将剩余的存储内存都借过来用作执行内存
    // 另外，如果存储内存向执行内存借用了一部分内存，也就是说此时存储内存的实际大小大于配置的值
    // 那么我们就将所有的借用的存储内存都还回来
    val memoryReclaimableFromStorage = math.max(
      storagePool.memoryFree,
      storagePool.poolSize - storageRegionSize)
    if (memoryReclaimableFromStorage &amp;gt; 0) {
      // Only reclaim as much space as is necessary and available:
      // 只腾出必要大小的内存空间，这个方法会将内存中的block挤到磁盘中
      val spaceToReclaim = storagePool.freeSpaceToShrinkPool(
        math.min(extraMemoryNeeded, memoryReclaimableFromStorage))
      // 更新一些簿记量，存储内存少了这么多内存，相应的执行内存增加了这么多内存
      storagePool.decrementPoolSize(spaceToReclaim)
      executionPool.incrementPoolSize(spaceToReclaim)
    }
  }
}

/**
 * The size the execution pool would have after evicting storage memory.
 *
 * The execution memory pool divides this quantity among the active tasks evenly to cap
 * the execution memory allocation for each task. It is important to keep this greater
 * than the execution pool size, which doesn't take into account potential memory that
 * could be freed by evicting storage. Otherwise we may hit SPARK-12155.
 *
 * Additionally, this quantity should be kept below `maxMemory` to arbitrate fairness
 * in execution memory allocation across tasks, Otherwise, a task may occupy more than
 * its fair share of execution memory, mistakenly thinking that other tasks can acquire
 * the portion of storage memory that cannot be evicted.
 */
def computeMaxExecutionPoolSize(): Long = {
  maxMemory - math.min(storagePool.memoryUsed, storageRegionSize)
}

executionPool.acquireMemory(
  numBytes, taskAttemptId, maybeGrowExecutionPool, () =&amp;gt; computeMaxExecutionPoolSize)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;executionmemorypool.acquirememory&quot;&gt;ExecutionMemoryPool.acquireMemory&lt;/h4&gt;
&lt;p&gt;这个方法的代码我就不贴了，主要是一些复杂的内存申请规则的计算，以及内部簿记量的维护，此外如果现有可用的内存量太小，则会等待（通过对象锁等待）直到其他任务释放一些内存；&lt;br/&gt;除此之外最重要的就是对上面提到的maybeGrowExecutionPool方法的调用，所以我们重点还是看一下maybeGrowExecutionPool方法。&lt;/p&gt;
&lt;h4 id=&quot;maybegrowexecutionpool&quot;&gt;maybeGrowExecutionPool&lt;/h4&gt;
&lt;p&gt;由于这个方法在前面已经贴出来，并且标上了很详细的注释，所以代码逻辑略过，其中有一个关键的调用storagePool.freeSpaceToShrinkPool，这个方法实现了将内存中的块挤出去的逻辑。&lt;/p&gt;
&lt;h4 id=&quot;storagepool.freespacetoshrinkpool&quot;&gt;storagePool.freeSpaceToShrinkPool&lt;/h4&gt;
&lt;p&gt;我们发现其中调用了memoryStore.evictBlocksToFreeSpace方法，&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def freeSpaceToShrinkPool(spaceToFree: Long): Long = lock.synchronized {
    val spaceFreedByReleasingUnusedMemory = math.min(spaceToFree, memoryFree)
    val remainingSpaceToFree = spaceToFree - spaceFreedByReleasingUnusedMemory
    if (remainingSpaceToFree &amp;gt; 0) {
      // If reclaiming free memory did not adequately shrink the pool, begin evicting blocks:
      val spaceFreedByEviction =
        memoryStore.evictBlocksToFreeSpace(None, remainingSpaceToFree, memoryMode)
      // When a block is released, BlockManager.dropFromMemory() calls releaseMemory(), so we do
      // not need to decrement _memoryUsed here. However, we do need to decrement the pool size.
      spaceFreedByReleasingUnusedMemory + spaceFreedByEviction
    } else {
      spaceFreedByReleasingUnusedMemory
    }
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;memorystore.evictblockstofreespace&quot;&gt;memoryStore.evictBlocksToFreeSpace&lt;/h4&gt;
&lt;p&gt;这个方法看似很长，其实大概可以总结为一点。&lt;br/&gt;因为MemoryStore存储了内存中所有块的实际数据，所以可以根据这些信息知道每个块实际大小，这样就能计算出需要挤出哪些块，当然这个过程中还有一些细节的处理，比如块的写锁的获取和释放等等。&lt;br/&gt;这里面，实际将块从内存中释放（本质上就是将块的数据对应的MemoryEntry的引用设为null，这样gc就可以回收这个块）的功能代码在blockEvictionHandler.dropFromMemory方法中实现，也就是&lt;br/&gt;BlockManager.dropFromMemory。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private[spark] def evictBlocksToFreeSpace(
  blockId: Option[BlockId],
  space: Long,
  memoryMode: MemoryMode): Long = {
assert(space &amp;gt; 0)
memoryManager.synchronized {
  var freedMemory = 0L
  val rddToAdd = blockId.flatMap(getRddId)
  val selectedBlocks = new ArrayBuffer[BlockId]
  def blockIsEvictable(blockId: BlockId, entry: MemoryEntry[_]): Boolean = {
    entry.memoryMode == memoryMode &amp;amp;&amp;amp; (rddToAdd.isEmpty || rddToAdd != getRddId(blockId))
  }
  // This is synchronized to ensure that the set of entries is not changed
  // (because of getValue or getBytes) while traversing the iterator, as that
  // can lead to exceptions.
  entries.synchronized {
    val iterator = entries.entrySet().iterator()
    while (freedMemory &amp;lt; space &amp;amp;&amp;amp; iterator.hasNext) {
      val pair = iterator.next()
      val blockId = pair.getKey
      val entry = pair.getValue
      if (blockIsEvictable(blockId, entry)) {
        // We don't want to evict blocks which are currently being read, so we need to obtain
        // an exclusive write lock on blocks which are candidates for eviction. We perform a
        // non-blocking &quot;tryLock&quot; here in order to ignore blocks which are locked for reading:
        // 这里之所以要获取写锁是为了防止在块正在被读取或写入的时候将其挤出去
        if (blockInfoManager.lockForWriting(blockId, blocking = false).isDefined) {
          selectedBlocks += blockId
          freedMemory += pair.getValue.size
        }
      }
    }
  }

  def dropBlock[T](blockId: BlockId, entry: MemoryEntry[T]): Unit = {
    val data = entry match {
      case DeserializedMemoryEntry(values, _, _) =&amp;gt; Left(values)
      case SerializedMemoryEntry(buffer, _, _) =&amp;gt; Right(buffer)
    }
    // 这里的调用将块挤出内存，如果允许写到磁盘则溢写到磁盘上
    // 注意blockEvictionHandler的实现类就是BlockManager
    val newEffectiveStorageLevel =
      blockEvictionHandler.dropFromMemory(blockId, () =&amp;gt; data)(entry.classTag)
    if (newEffectiveStorageLevel.isValid) {
      // The block is still present in at least one store, so release the lock
      // but don't delete the block info
      // 因为前面获取了这些块的写锁，还没有释放，
      // 所以在这里释放这些块的写锁
      blockInfoManager.unlock(blockId)
    } else {
      // The block isn't present in any store, so delete the block info so that the
      // block can be stored again
      // 因为块由于从内存中移除又没有写到磁盘上，所以直接从内部的簿记量中移除该块的信息
      blockInfoManager.removeBlock(blockId)
    }
  }

  // 如果腾出的内存足够多，比申请的量要大，这时才会真正释放相应的块
  if (freedMemory &amp;gt;= space) {
    var lastSuccessfulBlock = -1
    try {
      logInfo(s&quot;${selectedBlocks.size} blocks selected for dropping &quot; +
        s&quot;(${Utils.bytesToString(freedMemory)} bytes)&quot;)
      (0 until selectedBlocks.size).foreach { idx =&amp;gt;
        val blockId = selectedBlocks(idx)
        val entry = entries.synchronized {
          entries.get(blockId)
        }
        // This should never be null as only one task should be dropping
        // blocks and removing entries. However the check is still here for
        // future safety.
        if (entry != null) {
          dropBlock(blockId, entry)
          // 这时为测试留的一个钩子方法
          afterDropAction(blockId)
        }
        lastSuccessfulBlock = idx
      }
      logInfo(s&quot;After dropping ${selectedBlocks.size} blocks, &quot; +
        s&quot;free memory is ${Utils.bytesToString(maxMemory - blocksMemoryUsed)}&quot;)
      freedMemory
    } finally {
      // like BlockManager.doPut, we use a finally rather than a catch to avoid having to deal
      // with InterruptedException
      // 如果不是所有的块都转移成功，那么必然有的块的写锁可能没有释放
      // 所以在这里将这些没有移除成功的块的写锁释放掉
      if (lastSuccessfulBlock != selectedBlocks.size - 1) {
        // the blocks we didn't process successfully are still locked, so we have to unlock them
        (lastSuccessfulBlock + 1 until selectedBlocks.size).foreach { idx =&amp;gt;
          val blockId = selectedBlocks(idx)
          blockInfoManager.unlock(blockId)
        }
      }
    }
  } else {// 如果不能腾出足够多的内存，那么取消这次行动，释放所有已经持有的块的写锁
    blockId.foreach { id =&amp;gt;
      logInfo(s&quot;Will not store $id&quot;)
    }
    selectedBlocks.foreach { id =&amp;gt;
      blockInfoManager.unlock(id)
    }
    0L
  }
}
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;blockmanager.dropfrommemory&quot;&gt;BlockManager.dropFromMemory&lt;/h4&gt;
&lt;p&gt;总结一下这个方法的主要逻辑：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果存储级别允许存到磁盘，那么先溢写到磁盘上&lt;/li&gt;
&lt;li&gt;将block从MemoryStore内部的map结构中移除掉&lt;/li&gt;
&lt;li&gt;向driver上的BlockManagerMaster汇报块更新&lt;/li&gt;
&lt;li&gt;向任务度量系统汇报块更新的统计信息&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以，七绕八绕，饶了这么一大圈，其实所谓的内存挤占，其实就是把引用设为null ^_^当然肯定不是这么简单啦，其实在整个分析的过程中我们也能发现，所谓的内存管理大部分工作就是对任务使用内存一些簿记量的管理维护，这里面有一些比较复杂的逻辑，例如给每个任务分配多少内存的计算逻辑就比较复杂。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private[storage] override def dropFromMemory[T: ClassTag](
  blockId: BlockId,
  data: () =&amp;gt; Either[Array[T], ChunkedByteBuffer]): StorageLevel = {
logInfo(s&quot;Dropping block $blockId from memory&quot;)
val info = blockInfoManager.assertBlockIsLockedForWriting(blockId)
var blockIsUpdated = false
val level = info.level

// Drop to disk, if storage level requires
// 如果存储级别允许存到磁盘，那么先溢写到磁盘上
if (level.useDisk &amp;amp;&amp;amp; !diskStore.contains(blockId)) {
  logInfo(s&quot;Writing block $blockId to disk&quot;)
  data() match {
    case Left(elements) =&amp;gt;
      diskStore.put(blockId) { channel =&amp;gt;
        val out = Channels.newOutputStream(channel)
        serializerManager.dataSerializeStream(
          blockId,
          out,
          elements.toIterator)(info.classTag.asInstanceOf[ClassTag[T]])
      }
    case Right(bytes) =&amp;gt;
      diskStore.putBytes(blockId, bytes)
  }
  blockIsUpdated = true
}

// Actually drop from memory store
val droppedMemorySize =
  if (memoryStore.contains(blockId)) memoryStore.getSize(blockId) else 0L
val blockIsRemoved = memoryStore.remove(blockId)
if (blockIsRemoved) {
  blockIsUpdated = true
} else {
  logWarning(s&quot;Block $blockId could not be dropped from memory as it does not exist&quot;)
}

val status = getCurrentBlockStatus(blockId, info)
if (info.tellMaster) {
  reportBlockStatus(blockId, status, droppedMemorySize)
}
// 向任务度量系统汇报块更新的统计信息
if (blockIsUpdated) {
  addUpdatedBlockStatusToTaskMetrics(blockId, status)
}
status.storageLevel
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;unifiedmemorymanager.acquirestoragememory&quot;&gt;UnifiedMemoryManager.acquireStorageMemory&lt;/h3&gt;
&lt;p&gt;我们再来看一下对于存储内存的申请。&lt;br/&gt;其中，存储内存向执行内存借用 的逻辑相对简单，仅仅是将两个内存池的大小改一下，执行内存池减少一定的大小,存储内存池则增加相应的大小。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;override def acquireStorageMemory(
  blockId: BlockId,
  numBytes: Long,
  memoryMode: MemoryMode): Boolean = synchronized {
assertInvariants()
assert(numBytes &amp;gt;= 0)
val (executionPool, storagePool, maxMemory) = memoryMode match {
  case MemoryMode.ON_HEAP =&amp;gt; (
    onHeapExecutionMemoryPool,
    onHeapStorageMemoryPool,
    maxOnHeapStorageMemory)
  case MemoryMode.OFF_HEAP =&amp;gt; (
    offHeapExecutionMemoryPool,
    offHeapStorageMemoryPool,
    maxOffHeapStorageMemory)
}
// 因为执行内存挤占不了，所以这里如果申请的内存超过现在可用的内存，那么就申请不了了
if (numBytes &amp;gt; maxMemory) {
  // Fail fast if the block simply won't fit
  logInfo(s&quot;Will not store $blockId as the required space ($numBytes bytes) exceeds our &quot; +
    s&quot;memory limit ($maxMemory bytes)&quot;)
  return false
}
// 如果大于存储内存的可用内存，那么就需要向执行内存借用一部分内存
if (numBytes &amp;gt; storagePool.memoryFree) {
  // There is not enough free memory in the storage pool, so try to borrow free memory from
  // the execution pool.
  val memoryBorrowedFromExecution = Math.min(executionPool.memoryFree,
    numBytes - storagePool.memoryFree)
  // 存储内存向执行内存借用的逻辑很简单，
  // 仅仅是将两个内存池的大小改一下，
  // 执行内存池减少一定的大小,存储内存池则增加相应的大小
  executionPool.decrementPoolSize(memoryBorrowedFromExecution)
  storagePool.incrementPoolSize(memoryBorrowedFromExecution)
}
// 通过storagePool申请一定量的内存
storagePool.acquireMemory(blockId, numBytes)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;storagememorypool.acquirememory&quot;&gt;StorageMemoryPool.acquireMemory&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;def acquireMemory(
  blockId: BlockId,
  numBytesToAcquire: Long,
  numBytesToFree: Long): Boolean = lock.synchronized {
assert(numBytesToAcquire &amp;gt;= 0)
assert(numBytesToFree &amp;gt;= 0)
assert(memoryUsed &amp;lt;= poolSize)
// 首先调用MemoryStore的相关方法挤出一些块以释放内存
if (numBytesToFree &amp;gt; 0) {
  memoryStore.evictBlocksToFreeSpace(Some(blockId), numBytesToFree, memoryMode)
}
// NOTE: If the memory store evicts blocks, then those evictions will synchronously call
// back into this StorageMemoryPool in order to free memory. Therefore, these variables
// should have been updated.
// 因为前面挤出一些块后释放内存时，BlockManager会通过MemoryManager相关方法更新内部的簿记量，
// 所以这里的memoryFree就会变化，会变大
val enoughMemory = numBytesToAcquire &amp;lt;= memoryFree
if (enoughMemory) {
  _memoryUsed += numBytesToAcquire
}
enoughMemory
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，这里也调用了memoryStore.evictBlocksToFreeSpace方法来讲一部分块挤出内存，以此来为新的block腾出空间。&lt;/p&gt;
&lt;h3 id=&quot;unifiedmemorymanager.acquireunrollmemory&quot;&gt;UnifiedMemoryManager.acquireUnrollMemory&lt;/h3&gt;
&lt;p&gt;另外还有对展开内存的申请，实际就是申请存储内存。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;override def acquireUnrollMemory(
  blockId: BlockId,
  numBytes: Long,
  memoryMode: MemoryMode): Boolean = synchronized {
acquireStorageMemory(blockId, numBytes, memoryMode)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;内存管理，本质上是对shuffle排序过程中使用的内存和rdd缓存使用的内存的簿记，通过对内存使用量的详细精确的记录和管理，最大限度避免OOM的发生，同时尽量提高内存利用率。&lt;/p&gt;
</description>
<pubDate>Wed, 12 Jun 2019 17:35:00 +0000</pubDate>
<dc:creator>_朱葛</dc:creator>
<og:description>MemoryManager内存管理器 内存管理器可以说是spark内核中最重要的基础模块之一，shuffle时的排序，rdd缓存，展开内存，广播变量，Task运行结果的存储等等，凡是需要使用内存的地方</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhuge134/p/11013826.html</dc:identifier>
</item>
<item>
<title>分表后需要注意的二三事 - crossoverJie</title>
<link>http://www.cnblogs.com/crossoverJie/p/11013769.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/crossoverJie/p/11013769.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/06/13/5d012e6a6fd7729354.jpg&quot;/&gt;&lt;/p&gt;

&lt;p&gt;本篇是上一篇&lt;a href=&quot;https://crossoverjie.top/2019/04/16/framework-design/sharding-db/&quot;&gt;《一次分表踩坑实践的探讨》&lt;/a&gt;，所以还没看过的朋友建议先看上文。&lt;/p&gt;
&lt;p&gt;还是先来简单回顾下上次提到了哪些内容：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;分表策略：哈希、时间归档等。&lt;/li&gt;
&lt;li&gt;分表字段的选择。&lt;/li&gt;
&lt;li&gt;数据迁移方案。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;而本篇文章的背景是在我们上线这段时间遇到的一些问题并尝试解决的方案。&lt;/p&gt;

&lt;p&gt;之前提到在分表应用上线前我们需要将原有表的数据迁移到新表中，这样才能保证业务不受影响。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/06/13/5d0126128f1e678414.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以我们单独写了一个迁移应用，它负责将大表中的数据迁移到 64 张分表，而再迁移过程中产生的数据毕竟是少数，最后在上线当晚再次迁移过去即可。&lt;/p&gt;
&lt;p&gt;一切想的很美好，当这个应用上线后却发现没这么简单。&lt;/p&gt;
&lt;h2 id=&quot;数据库负载升高&quot;&gt;数据库负载升高&lt;/h2&gt;
&lt;p&gt;首先第一个问题是数据库自己就顶不住了，在我们上这个迁移程序之前数据库的压力本身就比较大，这个应用一上去就成了最后一根稻草。&lt;/p&gt;
&lt;p&gt;最后导致的结果是：所有连接了数据库的程序大部分的操作都出现超时，获取不到数据库连接等一系列的异常。&lt;/p&gt;
&lt;p&gt;最后没办法我们只能把这个应用放到凌晨执行，但其实后面观察发现依然不行。&lt;/p&gt;
&lt;p&gt;虽说凌晨的业务量下降，但依然有少部分的请求过来，也会出现各种数据库异常。&lt;/p&gt;
&lt;p&gt;再一个是迁移程序的效率也非常低下，按照这样是速度，我们预估了一下迁移时间，大约需要 10 几天才能把三张最大的表（3、4亿的数据）迁移到分表中。&lt;/p&gt;
&lt;p&gt;于是我们换了一个方案，将这个迁移程序在从库中运行，最后再用运维的方法将分表直接导入进主库。&lt;/p&gt;
&lt;p&gt;因为从库的压力要比主库小很多，对业务的影响很小，同时迁移的效率也要快很多。&lt;/p&gt;
&lt;p&gt;即便是这样也花了一晚上+一个白天的时间才将一张 1亿的数据迁移完成，但是业务上的压力越来越大，数据量再不断新增，这个效率依然不够。&lt;/p&gt;

&lt;p&gt;最终没办法只有想一个不迁移数据的方案，但是新产生的数据还是往分表里写，至少保证大表的数据不再新增。&lt;/p&gt;
&lt;p&gt;但这样对于以前的数据咋办呢？总不能不让看了吧。&lt;/p&gt;
&lt;p&gt;其实对于数据的操作无非就分为&lt;code&gt;增删改查&lt;/code&gt;，就这四种操作来看看如何兼容。&lt;/p&gt;
&lt;h2 id=&quot;新增&quot;&gt;新增&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/06/13/5d012612de57f13422.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;新增最简单，所有的数据根据分表规则直接写入新表，这样可以保证老表的数据不再新增。&lt;/p&gt;
&lt;h2 id=&quot;删除&quot;&gt;删除&lt;/h2&gt;
&lt;p&gt;删除就要比新增稍微复杂一些，比如用户想要删除他个人产生的一条信息（比如说是订单数据），有可能这个数据在新表也可能在老表。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/06/13/5d01261336daf24547.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以删除时优先删除新表（毕竟新产生的数据访问的频次越高），如果删除失败再从老表删除一次。&lt;/p&gt;
&lt;h2 id=&quot;修改&quot;&gt;修改&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/06/13/5d01261380d6599845.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而修改同理，同样的会不确定数据存在于哪里，所以先要修改新表，失败后再次修改老表。&lt;/p&gt;
&lt;h2 id=&quot;查询&quot;&gt;查询&lt;/h2&gt;
&lt;p&gt;查询相对就要复杂一些了，因为这些大表的数据大部分都是存放一个用户产生的多条记录（比如一个用户的订单信息）。&lt;/p&gt;
&lt;p&gt;这时在页面上通常都会有分页，并且按照时间进行排序。&lt;/p&gt;
&lt;p&gt;麻烦的地方就出在这里：既然是要分页那就有可能出现要查询一部分分表数据和原来的大表数据做组合。&lt;/p&gt;
&lt;p&gt;所以这里的查询其实分为三种情况。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/06/13/5d012613da28015150.jpg&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先查询的时候要计算这个用户所在分表中的数据可以分为几页。&lt;/li&gt;
&lt;li&gt;第一步首先判断当前页是否可以在分表中全部获取，如果可以则直接从分表中取出数据返回（假设分页中总共可以查询 2 页数据，当前为第 1 页，那就全部取分表数据）。&lt;/li&gt;
&lt;li&gt;如果不可以就要判断当前页数在分表中是否取不到任何一条数据，如果是则直接取老表数据（比如现在要取第 5 页的数据，分表中一共才只有 2 页数据，所以第 5 页数据只能全部从老表中获取）。&lt;/li&gt;
&lt;li&gt;但如果分表和老表都存在一部分数据时，则需要同时取两张表然后做一个汇总再返回。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;这种逻辑只适用于根据分表字段进行查询分页的前提下&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;我想肯定会有朋友提出这样是否会有性能问题？&lt;/p&gt;
&lt;p&gt;同时如果在计算分表分页数量时出现并发写入的情况，导致分页数量不准从而对后续的查询出现影响该怎么处理？&lt;/p&gt;
&lt;p&gt;首先第一个性能问题：&lt;/p&gt;
&lt;p&gt;其实这个要看怎么取舍，为了这样的兼容目的其实会比常规查询多出几个步骤：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;判断当前页是否可以在分表中查询。&lt;/li&gt;
&lt;li&gt;当新老表中都有数据时候需要额外多查询一张大表。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;第一个判断逻辑其实是在内存中计算，这个损耗我觉得完全可以忽略不计。&lt;/p&gt;
&lt;p&gt;至于第二步确实会有损耗，毕竟多查了一张表。&lt;/p&gt;
&lt;p&gt;但在分表之前所有的数据都是从老表中获取的，当时的业务也没有出现问题；现在多的只是查询分表而已，但分表的数据量肯定要比大表小的多，而且有索引，所以这个效率也不会慢多少。&lt;/p&gt;
&lt;p&gt;而且根据局部性原理及用户的使用习惯来看，老表中的数据很少会去查询，随着时间的推移所有的数据肯定都会从分表中获取，逐渐老表就会成为历史表。&lt;/p&gt;
&lt;p&gt;而第二个并发带来的问题我觉得影响也不大，一定要这个分页准的前提肯定得是加锁了，但为了这样一个不痒的小问题却带来性能的下降，我觉得是不划算的。&lt;/p&gt;
&lt;p&gt;而且后续我们也可以慢慢的将老表的数据迁移到新表，这样就可以完全去掉这个兼容逻辑了，所有的数据都从分表中获取。&lt;/p&gt;

&lt;p&gt;还是之前那句话，这里的各种操作、方法不适合所有人，毕竟脱离场景都是耍牛氓。&lt;/p&gt;
&lt;p&gt;比如分表搞的早，业务上允许一定的时间将数据迁移到分表那就不会有这次的兼容处理。&lt;/p&gt;
&lt;p&gt;甚至一开始业务规划合理、团队架构师看的长远，一来就将关键数据分表存储那根本就不会有数据迁移这个流程（大厂有经验的团队可能，小公司小作坊都得靠自己摸索）。&lt;/p&gt;
&lt;p&gt;这段期间也被数据库折腾惨了，数据库是最后一根稻草果然也不是瞎说的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;你的点赞与分享是对我最大的支持&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 12 Jun 2019 17:01:00 +0000</pubDate>
<dc:creator>crossoverJie</dc:creator>
<og:description>本篇是上一篇《一次分表踩坑实践的探讨》，所以还没看过的朋友建议先看上文。 还是先来简单回顾下上次提到了哪些内容： 分表策略：哈希、时间归档等。 分表字段的选择。 数据迁移方案。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/crossoverJie/p/11013769.html</dc:identifier>
</item>
<item>
<title>权值初始化 - Xavier和MSRA方法 - Brook_icv</title>
<link>http://www.cnblogs.com/wangguchangqing/p/11013698.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangguchangqing/p/11013698.html</guid>
<description>&lt;p&gt;设计好神经网络结构以及loss function 后，训练神经网络的步骤如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;初始化权值参数&lt;/li&gt;
&lt;li&gt;选择一个合适的梯度下降算法（例如：Adam，RMSprop等）&lt;/li&gt;
&lt;li&gt;重复下面的迭代过程：
&lt;ol&gt;&lt;li&gt;输入的正向传播&lt;/li&gt;
&lt;li&gt;计算loss function 的值&lt;/li&gt;
&lt;li&gt;反向传播，计算loss function 相对于权值参数的梯度值&lt;/li&gt;
&lt;li&gt;根据选择的梯度下降算法，使用梯度值更新每个权值参数&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;初始化&quot;&gt;初始化&lt;/h3&gt;
&lt;p&gt;神经网络的训练过程是一个迭代的过程，俗话说：好的开始就是成功的一半，所以的权值参数的初始化的值对网络最终的训练结果有很大的影响。 过大或者过小的初始值，对网络收敛的结果都会有不好的结果。&lt;/p&gt;
&lt;h4 id=&quot;所有的参数初始化为0或者相同的常数&quot;&gt;所有的参数初始化为0或者相同的常数&lt;/h4&gt;
&lt;p&gt;最简单的初始化方法就是将权值参数全部初始化为0或者一个常数，但是使用这种方法会导致&lt;strong&gt;网络中所有的神经元学习到的是相同的特征&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;假设神经网络中只有一个有2个神经元的隐藏层，现在将偏置参数初始化为：&lt;span class=&quot;math inline&quot;&gt;\(bias = 0\)&lt;/span&gt;，权值矩阵初始化为一个常数&lt;span class=&quot;math inline&quot;&gt;\(\alpha\)&lt;/span&gt;。 网络的输入为&lt;span class=&quot;math inline&quot;&gt;\((x_1,x_2)\)&lt;/span&gt;，隐藏层使用的激活函数为&lt;span class=&quot;math inline&quot;&gt;\(ReLU\)&lt;/span&gt;，则隐藏层的每个神经元的输出都是&lt;span class=&quot;math inline&quot;&gt;\(relu(\alpha x_1 + \alpha x_2)\)&lt;/span&gt;。 这就导致，对于loss function的值来说，两个神经元的影响是一样的，在反向传播的过程中对应参数的梯度值也是一样，也就说&lt;strong&gt;在训练的过程中，两个神经元的参数一直保持一致，其学习到的特征也就一样，相当于整个网络只有一个神经元。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;过大或者过小的初始化&quot;&gt;过大或者过小的初始化&lt;/h4&gt;
&lt;p&gt;如果权值的初始值过大，则会导致梯度&lt;strong&gt;爆炸&lt;/strong&gt;，使得网络不收敛；过小的权值初始值，则会导致梯度&lt;strong&gt;消失&lt;/strong&gt;，会导致网络收敛缓慢或者收敛到局部极小值。&lt;/p&gt;
&lt;p&gt;如果权值的初始值过大，则loss function相对于权值参数的梯度值很大，每次利用梯度下降更新参数的时，参数更新的幅度也会很大，这就导致loss function的值在其最小值附近震荡。&lt;/p&gt;
&lt;p&gt;而过小的初值值则相反，loss关于权值参数的梯度很小，每次更新参数时，更新的幅度也很小，着就会导致loss的收敛很缓慢，或者在收敛到最小值前在某个局部的极小值收敛了。&lt;/p&gt;
&lt;h3 id=&quot;xavier初始化&quot;&gt;Xavier初始化&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Xavier&lt;/strong&gt;初始化，由Xavier Glorot 在2010年的论文 &lt;a href=&quot;http://proceedings.mlr.press/v9/glorot10a/glorot10a.pdf?hc_location=ufi&quot; title=&quot;Understanding the difficulty of training deep feedforward neural networks&quot;&gt;Understanding the difficulty of training deep feedforward neural networks&lt;/a&gt; 提出。&lt;br/&gt;为了避免梯度爆炸或者梯度消失，有两个经验性的准则：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;每一层神经元激活值的均值要保持为0&lt;/li&gt;
&lt;li&gt;每一层激活的方差应该保持不变。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在正向传播时，每层的激活值的方差保持不变；在反向传播时，每层的梯度值的方差保持不变。&lt;/p&gt;
&lt;p&gt;基于上述的准则，初始的权值参数&lt;span class=&quot;math inline&quot;&gt;\(W^l\)&lt;/span&gt;（&lt;span class=&quot;math inline&quot;&gt;\(l\)&lt;/span&gt;为网络的第&lt;span class=&quot;math inline&quot;&gt;\(l\)&lt;/span&gt;层）要符合以下公式&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{aligned} W^{[l]} &amp;amp; \sim \mathcal{N}\left(\mu=0, \sigma^{2}=\frac{1}{n^{[l-1]}}\right) \\ b^{[l]} &amp;amp;=0 \end{aligned} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;span class=&quot;math inline&quot;&gt;\(n^{n-1}\)&lt;/span&gt;是第&lt;span class=&quot;math inline&quot;&gt;\(l-1\)&lt;/span&gt;层的神经元的个数。 也就是说，初始的权值&lt;span class=&quot;math inline&quot;&gt;\(w\)&lt;/span&gt;可以从均值&lt;span class=&quot;math inline&quot;&gt;\(\mu = 0\)&lt;/span&gt;，方差为&lt;span class=&quot;math inline&quot;&gt;\(\sigma^{2}=\frac{1}{n ^{l-1}}\)&lt;/span&gt;的正态分布中随机选取。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;正向传播的推导过程&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;推导过程中的三个假设：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;权值矩阵&lt;span class=&quot;math inline&quot;&gt;\(w\)&lt;/span&gt;是独立同分布的，且其均值为0&lt;/li&gt;
&lt;li&gt;每一层的输入&lt;span class=&quot;math inline&quot;&gt;\(a\)&lt;/span&gt;是独立同分布的，且均值也为0&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(w\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(a\)&lt;/span&gt;是相互独立的&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;设&lt;span class=&quot;math inline&quot;&gt;\(L\)&lt;/span&gt;层的权值矩阵为&lt;span class=&quot;math inline&quot;&gt;\(W\)&lt;/span&gt;，偏置为&lt;span class=&quot;math inline&quot;&gt;\(b\)&lt;/span&gt;,其输入为&lt;span class=&quot;math inline&quot;&gt;\(a\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ z^l = w^la^{l-1} + b^l \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;则&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ Var(z^l) = Var(\sum_{i=0}^nw_{i}^la_i^l) = \sum_{i=0}^n Var(w_{i}^la_i^{l-1}) \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;有统计概率的知识可得到：(第一个假设&lt;span class=&quot;math inline&quot;&gt;\(W\)&lt;/span&gt;,&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;相互独立）&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ Var(w_ix_i) = E^2(w_i)Var(w_i) + E^2(x_i)Var(x_i) + Var(w_i)Var(x_i) \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;由第一第二个假设可知：&lt;span class=&quot;math inline&quot;&gt;\(l\)&lt;/span&gt;层输入的均值为0，权值参数&lt;span class=&quot;math inline&quot;&gt;\(W\)&lt;/span&gt;的均值也为0，即：&lt;span class=&quot;math inline&quot;&gt;\(E(x_i) = 0,E(w_i) = 0\)&lt;/span&gt;则有：&lt;span class=&quot;math inline&quot;&gt;\(Var(w_ix_i) = Var(w_i)Var(x_i)\)&lt;/span&gt;，即&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ Var(z^l) = \sum_{i=0}^nVar(w_i^l)Var(x_i^{l-1}) \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;设权值矩阵&lt;span class=&quot;math inline&quot;&gt;\(W\)&lt;/span&gt;独立同分布的则有&lt;span class=&quot;math inline&quot;&gt;\(Var(w^l) = Var(w_{11}^l) = \cdots = Var(W_{ij}^l)\)&lt;/span&gt;，输入&lt;span class=&quot;math inline&quot;&gt;\(a^{l-1}\)&lt;/span&gt;也是独立同分布的有：&lt;span class=&quot;math inline&quot;&gt;\(Var(a^{l-1}) = Var(a_1^{l-1}) = \cdots = Var(a_i^{l-1})\)&lt;/span&gt;&lt;br/&gt;则有&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ Var(z^l) = n^{l-1}Var(w^l)Var(a^{l-1}),(n-1)为上一层神经元的个数 \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这里得出了第&lt;span class=&quot;math inline&quot;&gt;\(l\)&lt;/span&gt;层输入到激活函数中的值&lt;span class=&quot;math inline&quot;&gt;\(z^l\)&lt;/span&gt;与其输入&lt;span class=&quot;math inline&quot;&gt;\(a^{l-1}\)&lt;/span&gt;（也就是上一层输出的激活值）的方差之间的关系。但我们假设的是&lt;strong&gt;每一层输出的激活值的方差保持不变&lt;/strong&gt;，也就是说要得到&lt;span class=&quot;math inline&quot;&gt;\(Var(a^l)\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(Var(a^{l-1})\)&lt;/span&gt;之间的关系。&lt;/p&gt;
&lt;p&gt;设&lt;span class=&quot;math inline&quot;&gt;\(f\)&lt;/span&gt;为激活函数，则有&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ a^l = f(z^l) \]&lt;/span&gt;&lt;br/&gt;Xavier假设的激活函数为&lt;span class=&quot;math inline&quot;&gt;\(tanh\)&lt;/span&gt;，其函数曲线为&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/439761/201906/439761-20190613003148482-1284113283.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中间的部分可以近似线性（linear regime)，而在训练的过程就要保证激活值是落在这个线性状体的区间内的，不然就会出现梯度饱和的情况。所以，这里可以近似的有&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ a^l = tanh(z^l) \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;也就是说：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ Var(a^l) = Var(z^l) = n^{l-1}Var(w^l)Var(a^{l-1}) \]&lt;/span&gt;&lt;br/&gt;要让每一层的激活值的方差保持不变，则有&lt;span class=&quot;math inline&quot;&gt;\(Var(a^l) = Var(a^{l-1})\)&lt;/span&gt;，既有&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ Var(w^l) = \frac{1}{n^{l-1}} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;通常输入神经元和输出神经元的个数不一定总是相同的，这里取两者的均值&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \forall i, \operatorname{Var}\left(W^{l+1}\right)=\frac{2}{n_{l}+n_{l+1}} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;限制&lt;/strong&gt;&lt;br/&gt;对于权值的初始化，Glorot提出两个准则：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;各个层激活值的方差保持不变（正向传播）&lt;/li&gt;
&lt;li&gt;各个层的梯度值的方差保持不变（反向传播）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在Xavier的推导的过程中，做了以下假设：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;权值矩阵&lt;span class=&quot;math inline&quot;&gt;\(w\)&lt;/span&gt;是独立同分布的，且其均值为0&lt;/li&gt;
&lt;li&gt;每一层的输入&lt;span class=&quot;math inline&quot;&gt;\(a\)&lt;/span&gt;是独立同分布的，且均值也为0&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(w\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(a\)&lt;/span&gt;是相互独立的&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;但是，对Xavier限制最大的则是，其是基于tanh作为激活函数的。&lt;br/&gt;上述公式的详细推导过程可参见 &lt;a href=&quot;http://www.deeplearning.ai/ai-notes/initialization/&quot; class=&quot;uri&quot;&gt;http://www.deeplearning.ai/ai-notes/initialization/&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;Xavier的初始化有个假设条件，激活函数关于0对称，且主要针对于全连接神经网络。适用于tanh和softsign。&lt;/p&gt;
&lt;h4 id=&quot;均匀分布&quot;&gt;均匀分布&lt;/h4&gt;
&lt;p&gt;通过上面的推导，得出权值矩阵的均值为：0，方差为&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \forall i, \operatorname{Var}\left(W^{l+1}\right)=\frac{2}{n_{l}+n_{l+1}} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;$[a,b] &lt;span class=&quot;math inline&quot;&gt;\(间的均匀分布的方差为\)&lt;/span&gt; var = \frac{(b-a)^2}{12}&lt;span class=&quot;math inline&quot;&gt;\(,设\)&lt;/span&gt;F_{in}&lt;span class=&quot;math inline&quot;&gt;\(为输入的神经元个数，\)&lt;/span&gt;F_{out}$为输出的神经元个数&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ limit = \sqrt{\frac{6}{F_{in} + F_{out}}} \]&lt;/span&gt;&lt;br/&gt;则权值参数从分布&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ W \sim U[-limit,limit] \rightarrow W \sim U\left[-\sqrt{\frac{6}{F_{in} + F_{out}}}, + \sqrt{\frac{6}{F_{in} + F_{out}}}\right] \]&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;正态分布&quot;&gt;正态分布&lt;/h4&gt;
&lt;p&gt;基于正态分布的Xavier初始化从均值为0，方差为&lt;span class=&quot;math inline&quot;&gt;\(\sqrt{\frac{2}{F_{in} + F_{out}}}\)&lt;/span&gt;的正态分布中随机选取。&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ W \sim N(0.0,\sqrt{\frac{2}{F_{in} + F_{out}}}) \]&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;he初始化msra&quot;&gt;He初始化（MSRA）&lt;/h3&gt;
&lt;p&gt;由 Kaiming 在论文&lt;a href=&quot;https://www.cv-foundation.org/openaccess/content_iccv_2015/papers/He_Delving_Deep_into_ICCV_2015_paper.pdf&quot; title=&quot;Delving Deep into Rectifiers: Surpassing Human-Level Performance on ImageNet Classification&quot;&gt;Delving Deep into Rectifiers: Surpassing Human-Level Performance on ImageNet Classification&lt;/a&gt;提出，由于Xavier的假设条件是激活函数是关于0对称的，而常用的ReLU激活函数并不能满足该条件。&lt;/p&gt;
&lt;p&gt;只考虑输入的个数，MSRA的初始化是一个均值为0，方差为&lt;span class=&quot;math inline&quot;&gt;\(\sqrt{\frac{2}{F_{in}}}\)&lt;/span&gt;的高斯分布&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ w \sim G\left[0, \sqrt{\frac{2}{F_{in }}}\right] \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;正向传播的推导过程&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;其前半部分的推导和Xavider类似&lt;br/&gt;对于第&lt;span class=&quot;math inline&quot;&gt;\(l\)&lt;/span&gt;层，有如下公式 :&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \mathbf{y}_{l}=\mathbf{W}_{l} \mathbf{x}_{l}+\mathbf{b}_{l} \]&lt;/span&gt;&lt;br/&gt;其中，&lt;span class=&quot;math inline&quot;&gt;\(x_l\)&lt;/span&gt;为当前层的输入，也是上一层的激活后的输出值。&lt;span class=&quot;math inline&quot;&gt;\(y_l\)&lt;/span&gt;为当前层输入到激活函数的值，&lt;span class=&quot;math inline&quot;&gt;\(w_l\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(b_l\)&lt;/span&gt;为权值和偏置。其中&lt;span class=&quot;math inline&quot;&gt;\(x_l\)&lt;/span&gt;以及&lt;span class=&quot;math inline&quot;&gt;\(w_l\)&lt;/span&gt;都是独立同分布的，（和Xavier相同的假设条件），则有：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \operatorname{Var}\left[y_{l}\right]=n_{l} \operatorname{Var}\left[w_{l} x_{l}\right] \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;设&lt;span class=&quot;math inline&quot;&gt;\(w_l\)&lt;/span&gt;的均值为0，即&lt;span class=&quot;math inline&quot;&gt;\(E(w_l) = 0\)&lt;/span&gt;,则有：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{align*} \operatorname{Var}(y_l) &amp;amp; = n_{l}(E(W_l^2) \cdot E(x_l^2) - E^2(w_l) \cdot E^2(x_l)) \\ &amp;amp;= n_{l}(E(W_l^2) \cdot E(x_l^2) - 0 \cdot E^2(x_l)) \\ &amp;amp; = n_{l}(E(W_l^2) \cdot E(x_l^2) - 0 \cdot E(x_l^2)) \\ &amp;amp; = n_{l}(E(W_l^2) \cdot E(x_l^2) - E^2(w_l) \cdot E(x_l^2)) \\ &amp;amp; = n_{l}(E(W_l^2) - E^2(w_l)) \cdot E(x_l^2) \\ &amp;amp; = n_{l} \operatorname{Var}(w_l) \cdot E(x_l^2) \end{align*} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这里有和Xavier一个很大的不同是，这里没有假设&lt;strong&gt;输入的值的均值为0&lt;/strong&gt;。这是由于，使用ReLU的激活函数，&lt;span class=&quot;math inline&quot;&gt;\(x_l = max(0,y_{l-1})\)&lt;/span&gt;,每层输出的值不可能均值为0。&lt;/p&gt;
&lt;p&gt;上面最终得到&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \operatorname{Var}(y_l) = n_{l} \operatorname{Var}(w_l) \cdot E(x_l^2) \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;初始化时通常设，&lt;span class=&quot;math inline&quot;&gt;\(w\)&lt;/span&gt;的均值为0，偏置&lt;span class=&quot;math inline&quot;&gt;\(b = 0\)&lt;/span&gt;，以及&lt;span class=&quot;math inline&quot;&gt;\(w\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;是相互独立的，则有&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{align*} \operatorname{E}(y_l) &amp;amp;= \operatorname{E}(w_lx_l) \\ &amp;amp;= \operatorname{E}(x_l) \cdot \operatorname{E}(w_l) \\ &amp;amp;= 0 \end{align*} \]&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;也就是说，&lt;span class=&quot;math inline&quot;&gt;\(y_l\)&lt;/span&gt;的均值为0。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;再假设&lt;span class=&quot;math inline&quot;&gt;\(w\)&lt;/span&gt;是关于0对称分布的（均匀分布，高斯分布都符合），则可以得到&lt;span class=&quot;math inline&quot;&gt;\(y_l\)&lt;/span&gt;在0附近也是对称分布的。&lt;/p&gt;
&lt;p&gt;这样，使用ReLU作为激活函数，则有&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ x_l = max(0,y_{l-1}) \]&lt;/span&gt;&lt;br/&gt;由于只有当&lt;span class=&quot;math inline&quot;&gt;\(y_{l-1} &amp;gt; 0\)&lt;/span&gt;的部分，&lt;span class=&quot;math inline&quot;&gt;\(x_l\)&lt;/span&gt;才有值，且&lt;span class=&quot;math inline&quot;&gt;\(y_l\)&lt;/span&gt;在0附近也是对称分布的，则可以得到&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{align*} \operatorname{E}(x_l^2) &amp;amp;=\frac{1}{2} \operatorname{E}(y_{l-1}^2） \\ &amp;amp;= \frac{1}{2}({E}(y_{l-1}^2) - E(y_{l-1})),(由于E(y_{l-1}) = 0）\\ &amp;amp; = \frac{1}{2}\operatorname{Var}(y_{l-1}) \end{align*} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;将得到的&lt;span class=&quot;math inline&quot;&gt;\(\operatorname{E}(x_l^2) = \frac{1}{2}\operatorname{Var}(y_{l-1})\)&lt;/span&gt;，带入到 $\operatorname{Var}(y_l) = n_{l} \operatorname{Var}(w_l) \cdot E(x_l^2) $ 则可以得到&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \operatorname{Var}\left[y_{l}\right]=\frac{1}{2} n_{l} \operatorname{Var}\left[w_{l}\right] \operatorname{Var}\left[y_{l-1}\right] \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;将所有层的方差累加到一起有：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \operatorname{Var}\left[y_{L}\right]=\operatorname{Var}\left[y_{1}\right]\left(\prod_{l=2}^{L} \frac{1}{2} n_{l} \operatorname{Var}\left[w_{l}\right]\right) \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;为了是每一层的方差保持不变，则有：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \frac{1}{2} n_{l} \operatorname{Var}\left[w_{l}\right]=1, \quad \forall l \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;也即得到 权值矩阵的方差应该是&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \sqrt{2 / n_{l}} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;和Xavier的方法，也可以使用正态分布或者均匀分布来取得初始的权值矩阵的值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;正态分布&lt;/strong&gt;&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ W \sim N(0.0,\sqrt{2 / n_{l}}) \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;均匀分布&lt;/strong&gt;&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ W \sim U[-\sqrt{6 / n_{l}},\sqrt{6 / n_{l}}] \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;### 总结及使用的概率公式&lt;/p&gt;
&lt;p&gt;正确的初始化方法应该避免指数级地减小或放大输入值的大小，防止梯度“饱和”。 Glorot提出两个准则：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;各个层激活值的方差保持不变（正向传播）&lt;/li&gt;
&lt;li&gt;各个层的梯度值的方差保持不变（反向传播）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;通常初始的权值矩阵的均值为0.&lt;/p&gt;
&lt;p&gt;这这些条件的基础上，Glorot 使用&lt;span class=&quot;math inline&quot;&gt;\(tanh\)&lt;/span&gt;作为激活函数，并&lt;strong&gt;假设输入值的均值为0&lt;/strong&gt;，提出了Xavier初始化的方法。&lt;/p&gt;
&lt;p&gt;而Kaiming使用ReLU作为激活函数，就无法满足&lt;strong&gt;数值的均值为0&lt;/strong&gt;的条件，因此使用Xavier来初始化ReLU作为激活函数的网络，效果也就不是那么理想。其提出了MSRA的初始化方法，来解决该问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;附&lt;/strong&gt;&lt;br/&gt;推导时使用的概率公式：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ D(x)=E\left(x^{2}\right)-E^{2}(x) \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ D(x y)=E\left(x^{2} y^{2}\right)-E^{2}(x y)=E\left(x^{2}\right) E\left(y^{2}\right)-E^{2}(x) E^{2}(y) \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如果&lt;span class=&quot;math inline&quot;&gt;\(E(y) = 0\)&lt;/span&gt;,则有：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ D(xy) = D(y)E(x^2) \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如果&lt;span class=&quot;math inline&quot;&gt;\(x,y\)&lt;/span&gt;是相互独立的，则有&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ E(xy) = E(x)E(y) \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;本文只推导了正向传播的过程，对于反向传播的推导可参考原始论文&lt;/p&gt;
</description>
<pubDate>Wed, 12 Jun 2019 16:32:00 +0000</pubDate>
<dc:creator>Brook_icv</dc:creator>
<og:description>设计好神经网络结构以及loss function 后，训练神经网络的步骤如下： 1. 初始化权值参数 2. 选择一个合适的梯度下降算法（例如：Adam，RMSprop等） 3. 重复下面的迭代过程：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wangguchangqing/p/11013698.html</dc:identifier>
</item>
<item>
<title>一个因MySQL大小写敏感导致的问题 - 阿飞云</title>
<link>http://www.cnblogs.com/aflyun/p/11013604.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/aflyun/p/11013604.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;做一个积极的人&lt;/p&gt;
&lt;p&gt;编码、改bug、提升自己&lt;/p&gt;
&lt;p&gt;我有一个乐园，面向编程，春暖花开！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;00mysql&quot;&gt;00 MYSQL对大小写敏感&lt;/h2&gt;
&lt;p&gt;见字如面，见标题知内容。你有遇到过因为MYSQL对大小写敏感而被坑的体验吗？&lt;/p&gt;
&lt;p&gt;之前看过阿里巴巴Java开发手册，在MySql建表规约里有看到：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;【强制】表名、字段名必须使用小写字母或数字 ， 禁止出现数字开头，禁止两个下划线中间只 出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;说明： MySQL 在 Windows 下不区分大小写，但在 Linux 下默认是区分大小写&lt;/strong&gt;。因此，数据库名、 表名、字段名，都不允许出现任何大写字母，避免节外生枝。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;正例： aliyun _ admin ， rdc _ config ， level 3_ name 反例： AliyunAdmin ， rdcConfig ， level &lt;em&gt;3&lt;/em&gt; name&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果没有真正遇到过类似的问题，有时候干巴巴的看这些规约体会不深，理解起来似懂非懂，并且也只是死记硬背而已。&lt;/p&gt;
&lt;h2 id=&quot;01&quot;&gt;01 一个表字母大小故事&lt;/h2&gt;
&lt;p&gt;最近自己在鼓捣一个项目玩玩，在自己本机上开发和测试过程中一直没有问题，但是部署到Linux服务器上后，发现有报错，日志信息大概是：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;MySQLSyntaxErrorException: Table 'kytu.tb_sutyHo' doesn't exist&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;出现了问题，有点郁闷，本地开发好好的，怎么部署服务器就不行了。有鬼……不过莫慌。看着错误提示很明显，不就是&lt;code&gt;tb_sutyHo&lt;/code&gt; 表不存在吗！&lt;/p&gt;
&lt;p&gt;①于是我不慌不忙打开nv（navicat），查看这个表在不在，一看还真在，数据库中显示的&lt;code&gt;tb_sutyho&lt;/code&gt; ，不过h是小写；&lt;/p&gt;
&lt;p&gt;②查看代码发现代码中还真把表名写成&lt;code&gt;tb_sutyHo&lt;/code&gt; ,就一个h写成大写H了。&lt;/p&gt;
&lt;p&gt;问题找到了，原来是不小心写SQL的时候没有写对表名，改一下表名就搞定了，功能也一切正常了。一般情况下故事到这里也就应该结束了？问题找到了，也修复了，万事大吉了，稍后就可以吃鸡了。&lt;/p&gt;
&lt;p&gt;对于不会玩吃鸡的我，到这里并没有结束，找到问题和解决问题的确很重要，但是找到问题出现的根源更重要，这样就能在下次规避此类问题，作为一个程序员不要两次掉入一个坑里。&lt;/p&gt;
&lt;p&gt;我在想这个问题，本地Window环境怎么就一直没有出现这个报错提示呢？非要等我部署服务器才出现，这到底是什么问题？（如果你对Mysql大小敏感很了解，以下内容可以跳过….）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://dufyun.gitee.io/images_bed/images/techy/JVM11-03.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;于是就利用搜索引擎，发现Mysql中控制数据库名和表名的大小写敏感由参数&lt;code&gt;lower_case_table_names&lt;/code&gt;控制。&lt;/p&gt;
&lt;p&gt;在本机Window环境查看如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;sql language-sql hljs&quot;&gt;mysql&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;show &lt;span class=&quot;hljs-keyword&quot;&gt;variables &lt;span class=&quot;hljs-keyword&quot;&gt;like &lt;span class=&quot;hljs-string&quot;&gt;'%case%';
+&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在Linux服务器查看如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;sql language-sql hljs&quot;&gt;mysql&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;show &lt;span class=&quot;hljs-keyword&quot;&gt;variables &lt;span class=&quot;hljs-keyword&quot;&gt;like &lt;span class=&quot;hljs-string&quot;&gt;'%case%';
+&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面的结果已经可以看出不同了，然而对这两个参数还没有感觉，不知道具体是什么意思。&lt;/p&gt;
&lt;p&gt;在介绍&lt;code&gt;lower_case_table_names&lt;/code&gt;的时候，顺便也说一下&lt;code&gt;lower_case_file_system&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;lower_case_file_systemhttpsdevmysqlcomdocrefman57enserversystemvariableshtmlsysvar_lower_case_file_system&quot;&gt;&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_lower_case_file_system&quot;&gt;lower&lt;em&gt;case&lt;/em&gt;file_system&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;此变量描述数据目录所在的文件系统上文件名的区分大小写。 OFF表示文件名区分大小写，ON表示它们不区分大小写。此变量是只读的，因为它反映了文件系统属性并设置它对文件系统没有影响。&lt;/p&gt;
&lt;h3 id=&quot;lower_case_table_nameshttpsdevmysqlcomdocrefman57enserversystemvariableshtmlsysvar_lower_case_table_names&quot;&gt;&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_lower_case_table_names&quot;&gt;lower&lt;em&gt;case&lt;/em&gt;table_names&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;该参数为静态，可设置为0、1、2。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;0 --大小写敏感。（Unix，Linux默认）&lt;/strong&gt; 创建的库表将原样保存在磁盘上。如create database TeSt;将会创建一个TeSt的目录，create table AbCCC …将会原样生成AbCCC.frm。 SQL语句也会原样解析。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1 --大小写不敏感。（Windows默认）&lt;/strong&gt; 创建的库表时，MySQL将所有的库表名转换成小写存储在磁盘上。 SQL语句同样会将库表名转换成小写。 如需要查询以前创建的Test&lt;em&gt;table（生成Test&lt;/em&gt;table.frm文件），即便执行select * from Test&lt;em&gt;table，也会被转换成select * from test&lt;/em&gt;table，致使报错表不存在。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2 --大小写不敏感（OS X默认）&lt;/strong&gt; 创建的库表将原样保存在磁盘上。 但SQL语句将库表名转换成小写。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;On Windows the default value is 1. On macOS, the default value is 2. On Linux, a value of 2 is not supported; the server forces the value to 0 instead.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在Windows上，默认值为1。在macOS上，默认值为2。在Linux上不支持值2;服务器强制该值为0。&lt;/p&gt;
&lt;p&gt;并且官网也提示说：如果在数据目录驻留在不区分大小写的文件系统（例如Windows或macOS）上的系统上运行MySQL，则&lt;strong&gt;不应将lower&lt;em&gt;case&lt;/em&gt;table_names设置为0&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我自己在我的window10环境尝试设置&lt;code&gt;lower_case_table_names&lt;/code&gt;为0的时候，MySQL的服务怎么也启动不能，启动服务报错。windows系统对大小写不敏感，见下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190612233128835.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hZmx5dW4uYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注： 如果要修改&lt;code&gt;lower_case_table_names&lt;/code&gt;这个值，windows下修改my.ini ，Linux下修改my.cnf配置文件，需要重启服务,具体操作可以自行上网找资料。&lt;/p&gt;

&lt;h2 id=&quot;02&quot;&gt;02 注意事项&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;修改lower&lt;em&gt;case&lt;/em&gt;table_names导致的常见不良隐患&lt;/strong&gt;： 如果在&lt;code&gt;lower_case_table_names=0&lt;/code&gt;时，创建了含有大写字母的库表，改为&lt;code&gt;lower_case_table_names=1&lt;/code&gt;后，则会无法被查到。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://dufyun.gitee.io/images_bed/images/techy/JVM12-03.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先设置&lt;code&gt;lower_case_table_names=0&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;sql language-sql hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;CREATE &lt;span class=&quot;hljs-keyword&quot;&gt;TABLE &lt;span class=&quot;hljs-string&quot;&gt;`Student` (
  &lt;span class=&quot;hljs-string&quot;&gt;`id` &lt;span class=&quot;hljs-built_in&quot;&gt;int(&lt;span class=&quot;hljs-number&quot;&gt;11) &lt;span class=&quot;hljs-keyword&quot;&gt;unsigned &lt;span class=&quot;hljs-keyword&quot;&gt;NOT &lt;span class=&quot;hljs-literal&quot;&gt;NULL AUTO_INCREMENT,
  &lt;span class=&quot;hljs-string&quot;&gt;`name` &lt;span class=&quot;hljs-built_in&quot;&gt;varchar(&lt;span class=&quot;hljs-number&quot;&gt;25) &lt;span class=&quot;hljs-keyword&quot;&gt;NOT &lt;span class=&quot;hljs-literal&quot;&gt;NULL,
  PRIMARY &lt;span class=&quot;hljs-keyword&quot;&gt;KEY (&lt;span class=&quot;hljs-string&quot;&gt;`id`)
) &lt;span class=&quot;hljs-keyword&quot;&gt;ENGINE=&lt;span class=&quot;hljs-keyword&quot;&gt;InnoDB &lt;span class=&quot;hljs-keyword&quot;&gt;DEFAULT &lt;span class=&quot;hljs-keyword&quot;&gt;CHARSET=utf8;

&lt;span class=&quot;hljs-keyword&quot;&gt;show &lt;span class=&quot;hljs-keyword&quot;&gt;tables;
+&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再设置&lt;code&gt;lower_case_table_names=1&lt;/code&gt;,执行查询，不管表名是大写还是小写，都提示表不存在。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;sql language-sql hljs&quot;&gt;mysql&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;select * &lt;span class=&quot;hljs-keyword&quot;&gt;from Student;
1146 - Table 'aflyun.Student' doesn't exist

mysql&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;select * &lt;span class=&quot;hljs-keyword&quot;&gt;from student;
1146 - Table 'aflyun.student' doesn't exist
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;解决方法&lt;/strong&gt;：如果要将默认的&lt;code&gt;lower_case_tables_name&lt;/code&gt;为0设置成1，&lt;strong&gt;需先将已经存在的库表名转换为小写&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;针对仅表名存在大写字母的情况：&lt;/p&gt;
&lt;p&gt;①、&lt;code&gt;lower_case_tables_name=0&lt;/code&gt;时，执行&lt;code&gt;rename table&lt;/code&gt;成小写。&lt;/p&gt;
&lt;p&gt;②、设置&lt;code&gt;lower_case_tables_name=1&lt;/code&gt;，重启生效。&lt;/p&gt;

&lt;p&gt;针对库名存在大写字母的情况：&lt;/p&gt;
&lt;p&gt;①、&lt;code&gt;lower_case_tables_name=0&lt;/code&gt;时，使用&lt;code&gt;mysqldump&lt;/code&gt;导出，并删除老的数据库。&lt;/p&gt;
&lt;p&gt;②、设置&lt;code&gt;lower_case_tables_name=1&lt;/code&gt;，重启生效。&lt;/p&gt;
&lt;p&gt;③、导入数据至实例，此时包含大写字母的库名已转换为小写。&lt;/p&gt;

&lt;h2 id=&quot;03&quot;&gt;03 总结&lt;/h2&gt;
&lt;p&gt;有了踩坑的经验，对开头说的阿里Mysql规约理解更加深入了。操作系统不同导致大小写敏感不一致。我们在开发时，应该按大小写敏感的原则去开发，这样可以使开发的程序兼容不同的操作系统。因此，建议在开发测试环境下把&lt;code&gt;lower_case_table_names&lt;/code&gt;的值设为0，便于在开发中就严格控制代码大小写敏感，提高代码的兼容和严谨。&lt;/p&gt;

&lt;h2 id=&quot;04&quot;&gt;04 参考资料&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.linuxidc.com/Linux/2018-01/150696.htm&quot;&gt;MySQL大小写敏感问题lower&lt;em&gt;case&lt;/em&gt;table&lt;em&gt;names &amp;amp; lower&lt;/em&gt;case&lt;em&gt;file&lt;/em&gt;system&lt;/a&gt;&lt;/p&gt;


&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;谢谢你的阅读，如果您觉得这篇博文对你有帮助，请点赞或者喜欢，让更多的人看到！祝你每天开心愉快！&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;strong&gt;不管做什么，只要坚持下去就会看到不一样！在路上，不卑不亢!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://aflyun.blog.csdn.net/&quot;&gt; &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;愿你我在人生的路上能都变成最好的自己，能够成为一个独挡一面的人&lt;/strong&gt;&lt;img src=&quot;http://dufyun.gitee.io/images_bed/images/life/qrcode_javaCoder.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;© 每天都在变得更好的阿飞云&lt;/p&gt;
</description>
<pubDate>Wed, 12 Jun 2019 16:02:00 +0000</pubDate>
<dc:creator>阿飞云</dc:creator>
<og:description>【强制】表名、字段名必须使用小写字母或数字 ， 禁止出现数字开头，禁止两个下划线中间只 出现数字。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/aflyun/p/11013604.html</dc:identifier>
</item>
<item>
<title>【译】3D打印：介绍 - 我没有三颗心脏</title>
<link>http://www.cnblogs.com/wmyskxz/p/11013536.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wmyskxz/p/11013536.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;原文地址：（需要FQ）https://ordina-jworks.github.io/iot/2018/09/28/3D-Printing-Intro.html&lt;br/&gt;文章发表日期：2018-09-28&lt;br/&gt;第一次尝试翻译这么一篇大且长的文章，如果读着感觉不太通常或者有错误的地方，请多包涵..&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;介绍&quot;&gt;介绍&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;3D打印是一个长期被炒作的术语。这种技术本质上不是新技术，但现在比以往任何时候都更好，每个人都可以使用。今天，我们将深入探讨3D打印的世界，以及它在未来几年为我们和全世界带来的真正体验。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-20a7627bd54e70b8?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;什么是-3d-打印&quot;&gt;什么是 3D 打印&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;基本上3D打印可以描述为：通过使用3D打印机使用3D建模技术建好的物品。它提供了一种快速原型制作的新方法，无需制造非常昂贵的模具或模板。&lt;/p&gt;
&lt;p&gt;长期以来，它一直被下面这些大的领域（big thing）所炒作：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;日常使用：重新创建物体，更换破损的部件&lt;/li&gt;
&lt;li&gt;医疗用途：创造适合患者的特定支管或假体&lt;/li&gt;
&lt;li&gt;武器：在新闻中，3D打印一支可以通过金属探测器的枪，并且没有向当局登记&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;尽管3D打印改变了原型设计的工作原理，但存在许多误解：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;3D打印速度慢，速度很慢
&lt;ul&gt;&lt;li&gt;因此无法用于创建同一对象的批次&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;有限的可用材料（供业余爱好使用）&lt;/li&gt;
&lt;li&gt;3D打印部件坚固但不如模塑或铸造部件（主要用于塑料）强&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;d-打印的类型&quot;&gt;3D 打印的类型&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;3D打印不是一种技术，有多种不同的方法可以创建3D打印。其中，创建打印的方法取决于所使用的技术。&lt;/p&gt;
&lt;p&gt;不同的技术使用不同的方法和材料，每种都有其独特的优点和缺点。&lt;/p&gt;
&lt;p&gt;其中一些方法包括（但不限于）：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;熔融沉积建模（FDM）&lt;/li&gt;
&lt;li&gt;立体光刻（SLA）&lt;/li&gt;
&lt;li&gt;数字光处理（DLP）&lt;/li&gt;
&lt;li&gt;蒙面立体光刻（MSLA）&lt;/li&gt;
&lt;li&gt;直接金属激光烧结（DMLS）&lt;/li&gt;
&lt;li&gt;选择性激光熔化（SLM）&lt;/li&gt;
&lt;li&gt;电子束熔炼（EBM）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面我们将详细介绍一些更常用的类型：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;FDM&lt;/li&gt;
&lt;li&gt;SLA，DLP和MSLA&lt;/li&gt;
&lt;li&gt;SLS和SLM&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;fdm熔融沉积建模&quot;&gt;1. FDM：熔融沉积建模&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-165bd788cc2a0e51?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;与&lt;code&gt;Fused Deposition Modeling&lt;/code&gt;所述印刷模型是通过熔融的化合物创建（这是大多PLA / ABS / PETG）和跟踪由层模型层，每一层增厚模型作为模型上的打印机沉积更多的材料。&lt;/p&gt;
&lt;p&gt;在上图中，可以看到FDM打印机的所有主要部件。喷嘴在Z轴上移动，并且构建板通过步进电机在X / Y轴上移动，步进电机控制运动直到十分之一甚至二十分之一毫米。将一卷材料送入喷嘴，使其熔化并通过使用挤出轮/步进电机将其沉积到模型上。&lt;/p&gt;
&lt;p&gt;FDM打印机既可以随时使用，也可以作为需要组装的套件，这些也是市场上最实惠的打印机类型。您可以随时扩展打印机，甚至可以打印更换损坏的组件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-b88c812e8230daed?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;sla和dlp立体光刻和数字光处理&quot;&gt;2. SLA和DLP：立体光刻和数字光处理&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-3270232f9664c831?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这种类型的打印机通过使用激光或投影图像来固化UV反应性树脂。&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;Stereolithography&lt;/code&gt;强大的紫外激光逐层追踪物体，就像FDM打印机一样，但它本身不会沉积材料，而是在激光点处固化罐中的树脂。由于SLA使用由镜子移动的激光器，因此它具有非常高的分辨率，缺点是它与FDM打印机一样慢，因为需要跟踪每一层。&lt;/p&gt;
&lt;p&gt;使用Digital Light ProcessingUV投影仪时，它会同时投影整个图层，这会导致对象的可打印分辨率降低，但由于整个图层一次打印，因此速度显着提高，无需跟踪整个图层。 Masked SLA是一种更便宜的DLP方法，其中基于LCD的光掩模用于UV-LED阵列而不是基于UV的投影仪。（这里看不懂..大家看图感受下吧..）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-df61bec494808fe1?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-89c6f898fa114730?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面的图像显示了这两种（三种）方法之间的明显差异。与DLP或MSLA方法相比，SLA方法具有更好的质量。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-2a4d2d184c63ec3c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;dmls和slm直接金属激光烧结和选择性激光熔化&quot;&gt;3. DMLS和SLM：直接金属激光烧结和选择性激光熔化&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-162caf214d64fdff?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Direct Metal Laser Sintering&lt;/code&gt;和&lt;code&gt;Selective Laser Melting&lt;/code&gt;是3D打印的两种更工业化的方法。顾名思义，它们用于金属中的3D打印对象。两种方法的主要程序类似。移动臂将金属颗粒推过打印区域，之后强大的激光将跟踪被打印物体的当前层。这会将颗粒融合在一起，也是两种方法之间存在最大差异的地方。一旦当前层完成，臂再次来回移动，带来一层新的金属颗粒。&lt;/p&gt;
&lt;p&gt;使用DMLS，颗粒被烧结在一起，但是金属本身没有完全熔化，没有流动。当使用SLM时，金属颗粒实际上是完全熔化的，并且它们更加牢固地融合在一起，形成了极其坚固的物体！&lt;/p&gt;
&lt;p&gt;使用这些方法创建的对象没有内部压力和缺陷，这些压力和缺陷是常见的，并且很难通过其他生产方法来预防 这些部件也可以作为一个整体进行印刷，而不需要组装不同的部件，这进一步降低了组装过程中出现故障或错误的可能性。然而，从字面上看，这需要很高的成本，因为这些方法非常昂贵并且需要最先进的设备！由于这种高成本，它们被用于容错性非常低的行业，例如航空航天。&lt;/p&gt;
&lt;h3 id=&quot;不同的印刷材料&quot;&gt;不同的印刷材料&lt;/h3&gt;
&lt;p&gt;正如您在上一节中可能已经注意到的那样，不同的打印方法需要不同的打印材 在下面的部分中，我们将详细介绍这些材料。&lt;/p&gt;
&lt;h3 id=&quot;聚合物塑料&quot;&gt;1. 聚合物/塑料&lt;/h3&gt;
&lt;p&gt;FDM和DLP打印机需要基于聚合物的材料。这些是塑料或类似塑料的材料，易于打印。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PLA（聚乳酸）：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;生物可降解的&lt;/li&gt;
&lt;li&gt;熔化（印刷）温度：170⇔230°C&lt;/li&gt;
&lt;li&gt;可用于打印医疗用品&lt;/li&gt;
&lt;li&gt;许多颜色可用+在黑暗中发光&lt;/li&gt;
&lt;li&gt;不是UV稳定的&lt;/li&gt;
&lt;li&gt;不能承受高温，不要把它留在车内的阳光下！&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;ABS（丙烯腈丁二烯苯乙烯）：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;不可生物降解&lt;/li&gt;
&lt;li&gt;熔化（印刷）温度：220⇔260°C&lt;/li&gt;
&lt;li&gt;提供多种颜色+半透明&lt;/li&gt;
&lt;li&gt;紫外半稳定&lt;/li&gt;
&lt;li&gt;可以承受比PLA更高的温度！&lt;/li&gt;
&lt;li&gt;由于烟雾有毒，因此比PLA更难打印并需要排气！&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;PETG（聚对苯二甲酸乙二醇酯）：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;不可生物降解&lt;/li&gt;
&lt;li&gt;结合最好的PLA和ABS&lt;/li&gt;
&lt;li&gt;熔化（印刷）温度：220⇔250°C&lt;/li&gt;
&lt;li&gt;提供多种颜色+半透明&lt;/li&gt;
&lt;li&gt;紫外半稳定&lt;/li&gt;
&lt;li&gt;可以承受比PLA更高的温度！&lt;/li&gt;
&lt;li&gt;没有有毒烟雾，无味&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这三种材料通常用于FDM打印机。最安全的是PLA，它是完全可生物降解的（长时间使用），它也是最容易印刷的材料。ABS更坚固但不可生物降解，在印刷时会产生有毒烟雾，在印刷过程中也需要非常精确的冷却，否则印刷会翘曲，层会分离，破坏印刷品。PETG则两全其美，它比PLA强，不产生有毒烟雾。有更多的材料可供选择，通常具有非常特殊的特性，使其更像橡胶，更灵活，在黑暗中发光，......所有这些不同的材料需要不同的打印设置，有些可能很难做到正确，实验是关键！还存在一些可用于医学背景的材料，&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DLP材料：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;经历光聚合的液态聚合物，意味着其通过暴露于UV光而固化/硬化。&lt;/li&gt;
&lt;li&gt;有许多不同类型的树脂可供选择
&lt;ul&gt;&lt;li&gt;可生物降解的⇔不可生物降解&lt;/li&gt;
&lt;li&gt;灵活⇔坚固&lt;/li&gt;
&lt;li&gt;聚合物⇔陶瓷&lt;/li&gt;
&lt;li&gt;低温⇔高温&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;还有可用常规“日光”固化的树脂，不需要特殊的紫外线灯来固化印刷物&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;金属&quot;&gt;2. 金属&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-486b578076c4a3c3?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;目前，金属印刷不仅适用于普通人，也有一些较大的公司/行业已经在使用能够印刷金属的3D打印机。并非所有方法都可以打印所有金属材料，有些像SLM一样受限于它可以“打印”的金属。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;大多数印刷金属：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;钛&lt;/li&gt;
&lt;li&gt;铝&lt;/li&gt;
&lt;li&gt;钴铬合金&lt;/li&gt;
&lt;li&gt;金&lt;/li&gt;
&lt;li&gt;银&lt;/li&gt;
&lt;li&gt;铜&lt;/li&gt;
&lt;li&gt;Bras（合金）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如今航空航天工业印刷火箭及其发动机的外部和内部部件，这些物体更坚固，内部缺陷和应力更小。医疗行业还可以在钛中打印患者特定的假体，以便在受伤后更好地恢复患者。&lt;/p&gt;
&lt;h3 id=&quot;混凝土construction&quot;&gt;3. 混凝土/CONSTRUCTION&lt;/h3&gt;
&lt;p&gt;近年来，混凝土印刷引起了一些关注，人们正在试验它。它有一些很好的优点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;允许更便宜的小型建筑物建设&lt;/li&gt;
&lt;li&gt;施工更快&lt;/li&gt;
&lt;li&gt;发展中国家的小面积小型住宅 - 或者 - 在发生自然灾害之后&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;食物&quot;&gt;4. 食物&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-a9c6a42289c199a5?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;食品印刷长期以来一直是炒作。烹饪专家一直在试验这个概念，但也有像宇航员这样的公司为宇航员。&lt;/p&gt;
&lt;p&gt;巧克力和面团等简单物品已经可以3D打印，基于FDM方法，可食用物体逐层打印。有“机器人”可以打印更复杂的项目，但这些不是真正的3D打印机和更自动化的装配机，3D打印和装配之间的界限可能会变得有点模糊。目前还不能用原料基础成分打印全部食物。随着时间的推移，这无疑将得到进一步发展。&lt;/p&gt;
&lt;h2 id=&quot;d-打印入门&quot;&gt;3D 打印入门&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-add008fd1d6213ec?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;开始使用3D打印并不容易，这可能非常令人生畏。您需要考虑很多事情&lt;/p&gt;
&lt;p&gt;由于它仍然相对昂贵，你想问自己这些问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;我想要什么类型的3D打印？&lt;/li&gt;
&lt;li&gt;什么是最好的（价格/质量）打印机？&lt;/li&gt;
&lt;li&gt;我会用它来证明购买的合理性吗？&lt;/li&gt;
&lt;li&gt;您也可以在线订购印刷模型！&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;把事情做对很难：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;打印机校准&lt;/li&gt;
&lt;li&gt;模型切片和打印设置&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;⇒3D打印仍然是一个密集的试错过程！只有你愿意投入必要的时间才能开始。如果一开始你没有成功，请一次又一次地尝试！&lt;/p&gt;
&lt;p&gt;值得庆幸的是，在线爱好社区非常庞大，通常非常有帮助。您需要为对象建模或从“制造商”网站下载。您需要使用特定打印机的设置对模型进行切片，并根据所需的质量和速度调整这些设置。&lt;/p&gt;
&lt;p&gt;(这里作者推荐了一些在线的资源&amp;amp;建模工具&amp;amp;制造商网站，这里省略了...能FQ的小伙伴在文章顶部戳过去找找吧）&lt;/p&gt;
&lt;h2 id=&quot;未来&quot;&gt;未来&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;未来是现在！&lt;/p&gt;
&lt;p&gt;3D打印机正在以极快的速度发展，新的打印机型号几乎每周都会上市。中国公司正在生产高质量的打印机，生产质量也在不断提高。&lt;/p&gt;
&lt;p&gt;未来将带来更多：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;打印机更好&lt;/li&gt;
&lt;li&gt;更好的分辨率&lt;/li&gt;
&lt;li&gt;更低的花费&lt;/li&gt;
&lt;li&gt;降低维护&lt;/li&gt;
&lt;li&gt;越来越多的多功能材料&lt;/li&gt;
&lt;li&gt;每个家庭都有3D打印机？&lt;/li&gt;
&lt;li&gt;自己修理⇔扔掉破碎的东西，打破...&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;p&gt;按照惯例黏一个尾巴：&lt;/p&gt;
&lt;blockquote readability=&quot;6.0896860986547&quot;&gt;
&lt;p&gt;欢迎转载，转载请注明出处！&lt;br/&gt;简书ID：&lt;a href=&quot;https://www.jianshu.com/u/a40d61a49221&quot;&gt;@我没有三颗心脏&lt;/a&gt;&lt;br/&gt;github：&lt;a href=&quot;https://github.com/wmyskxz/&quot;&gt;wmyskxz&lt;/a&gt;&lt;br/&gt;欢迎关注公众微信号：wmyskxz&lt;br/&gt;分享自己的学习 &amp;amp; 学习资料 &amp;amp; 生活&lt;br/&gt;想要交流的朋友也可以加qq群：3382693&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 12 Jun 2019 15:44:00 +0000</pubDate>
<dc:creator>我没有三颗心脏</dc:creator>
<og:description>原文地址：（需要翻墙）https://ordina jworks.github.io/iot/2018/09/28/3D Printing Intro.html 文章发表日期：2018 09 28 第</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wmyskxz/p/11013536.html</dc:identifier>
</item>
<item>
<title>PHP转Go系列：数组与切片 - 平也</title>
<link>http://www.cnblogs.com/enochzzg/p/11013005.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/enochzzg/p/11013005.html</guid>
<description>&lt;h2 id=&quot;数组的定义&quot;&gt;数组的定义&lt;/h2&gt;
&lt;p&gt;用过PHP的同学应该很清楚，无论多么复杂的数据格式都可以用数组来表达，什么类型的数据都可以往里塞，它是工作必备的一部分，使用很简单，易用程度简直变态。&lt;/p&gt;
&lt;pre class=&quot;php&quot;&gt;
&lt;code&gt;$array = [1, 'name', ['sex' =&amp;gt; '男']];&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在Go语言中就有所不同了，数组是一段固定长度的连续内存区域，与C语言概念完全一致，在声明数组时，要先确定数组的长度，而且数组中的元素只能使用一种类型，心痛，我们再也不能随心所欲的存储数据了。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;array := [3]int{1, 2, 3}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上是数组在Go语言中的定义方法，&lt;code&gt;[3]&lt;/code&gt;代表数组长度为3，&lt;code&gt;int&lt;/code&gt;是数组中元素的类型，花括号中的是数组元素，切记元素个数与类型一定要与前面声明的相符，否则会报错。除了这种方式，PHP中还有一种动态赋值的方法，代码如下。&lt;/p&gt;
&lt;pre class=&quot;php&quot;&gt;
&lt;code&gt;$array = [];
$array[0] = 'name';
$array[1] = 1;
print_r($array);

//output
Array
(
    [0] =&amp;gt; name
    [1] =&amp;gt; 1
)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Go语言也能做到，不过别想那么多，要存储不同数据类型的元素就别想了（其实也不是没有办法，后续文章讲解）。可以通过var声明一个数组，数组的长度和类型提前定义好，接下来就可以根据数组下标来赋值了，可以不必为每个下标赋值，但是切记下标不能越界，否则会报错。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;var array [3]string
array[0] = &quot;name&quot;
array[1] = &quot;sex&quot;
fmt.Print(array) //output [name sex ]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;每次声明数组时都要数一下元素个数写在中括号里也太鸡肋了，这点Go不可能想不到，果然，可以用&lt;code&gt;...&lt;/code&gt;方法来省略掉中括号的数值，这样编译器会自动确定数组中的元素。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;array := [...]string{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;}
fmt.Print(array) //output [a b c d]&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;数组的遍历&quot;&gt;数组的遍历&lt;/h2&gt;
&lt;p&gt;数组已经定义了，来看一下怎么遍历，在PHP中通过&lt;code&gt;foreach&lt;/code&gt;进行遍历。&lt;/p&gt;
&lt;pre class=&quot;php&quot;&gt;
&lt;code&gt;$array = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;];
foreach($array as $k =&amp;gt; $v) {
    echo $v;
}
//output abcd&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Go的写法很类似，通过&lt;code&gt;range&lt;/code&gt;进行遍历，只是语法看起来有点怪怪的。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;array := [...]string{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;}
for k, v := range array {
    fmt.Print(k, v)
}
//output 0a1b2c3d&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在Go中没有使用的变量在编译时会报错，那遍历时的k不见得会用到，那怎么解决变量k未被使用的问题呢？其实可以使用Go内置的符号&lt;code&gt;_&lt;/code&gt;来替换掉变量k，它的意思是把当前赋的值丢弃掉。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;array := [...]string{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;}
for _, v := range array {
    fmt.Print(v)
}
//output abcd&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;数组的截取&quot;&gt;数组的截取&lt;/h3&gt;
&lt;p&gt;PHP中对数组截取通过&lt;code&gt;array_slice&lt;/code&gt;函数，以下代码是从数组的第二个元素开始，截取两个元素。&lt;/p&gt;
&lt;pre class=&quot;php&quot;&gt;
&lt;code&gt;$array = [1, 2, 3, 4, 5];
print_r(array_slice($array, 1, 2));

//output
Array
(
    [0] =&amp;gt; 2
    [1] =&amp;gt; 3
)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在Go中更简单一些，可以直接取出第二到第四个元素之间的数据，值得注意的是，取出来的已经不是数组了，叫做切片，记住了，从数组切出来的部分就叫切片，数组与切片最简单的区别就是：数组需要明确指定大小，切片不需要，数组是值传递，切片是地址传递。不过目前还是把它当数组好了。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;array := [...]int{1, 2, 3, 4, 5}
fmt.Print(array[1:3])&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;数组的追加&quot;&gt;数组的追加&lt;/h3&gt;
&lt;p&gt;在PHP中为数组添加一个新元素使用&lt;code&gt;array_push&lt;/code&gt;函数。&lt;/p&gt;
&lt;pre class=&quot;php&quot;&gt;
&lt;code&gt;$array = [1, 2, 3, 4, 5];
array_push($array, 6);
print_r($array);

//output
Array
(
    [0] =&amp;gt; 1
    [1] =&amp;gt; 2
    [2] =&amp;gt; 3
    [3] =&amp;gt; 4
    [4] =&amp;gt; 5
    [5] =&amp;gt; 6
)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在Go中使用&lt;code&gt;append&lt;/code&gt;函数，注意这里实际上是对切片的添加而不是数组。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;array := []int{1, 2, 3, 4, 5}
array = append(array, 6)
fmt.Print(array) //output [1 2 3 4 5 6]&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;数组元素的删除&quot;&gt;数组元素的删除&lt;/h3&gt;
&lt;p&gt;在PHP中删除数组元素非常简单，直接&lt;code&gt;unset&lt;/code&gt;即可，以下代码是删除第二个元素。&lt;/p&gt;
&lt;pre class=&quot;php&quot;&gt;
&lt;code&gt;$array = [1, 2, 3, 4, 5];
unset($array[1]);
print_r($array);

//output
Array
(
    [0] =&amp;gt; 1
    [2] =&amp;gt; 3
    [3] =&amp;gt; 4
    [4] =&amp;gt; 5
)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Go中比较特别，它并没有提供原生的删除方法，只能利用切片的特性，我们定义删除的元素索引为1，然后将1前面的元素与1后面的元素拼接起来，就过滤掉了第1个元素，感觉这种实现方式有点投机，不知道为什么不提供函数来操作。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;index := 1
array := []int{1, 2, 3, 4, 5}
array = append(array[:index], array[index+1:]...)
fmt.Print(array) //output [1 3 4 5]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上就是PHP与Go在数组上的区别，感兴趣的同学可以自行了解或关注我后续的文章。&lt;/p&gt;
</description>
<pubDate>Wed, 12 Jun 2019 13:57:00 +0000</pubDate>
<dc:creator>平也</dc:creator>
<og:description>数组的定义 用过PHP的同学应该很清楚，无论多么复杂的数据格式都可以用数组来表达，什么类型的数据都可以往里塞，它是工作必备的一部分，使用很简单，易用程度简直变态。 在Go语言中就有所不同了，数组是一段</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/enochzzg/p/11013005.html</dc:identifier>
</item>
<item>
<title>比特币入门之使用PRC应用开发接口 - 社会主义接班人</title>
<link>http://www.cnblogs.com/5ishare/p/10933399.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/5ishare/p/10933399.html</guid>
<description>&lt;p&gt;&lt;strong&gt;一、RPC API概述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比特币定义了RPC API来允许第三方应用通过节点软件访问比特币网络。 事实上，bitcoin-cli就是通过这个接口来实现其功能的，也就是说， 我们可以在自己的C#程序中完全实现bitcoin-cli的功能。&lt;/p&gt;
&lt;p&gt;JSON RPC采用JSON语法表示一个远程过程调用（Remote Procedure Call） 的请求与应答消息。例如对于&lt;code&gt;getbalance&lt;/code&gt;调用，请求消息与应答消息的格式 示意如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733213/201905/733213-20190527211703307-1545376988.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在请求消息中使用&lt;code&gt;method&lt;/code&gt;字段声明要调用的远程方法名，使用&lt;code&gt;params&lt;/code&gt;字段 声明调用参数列表；消息中的&lt;code&gt;jsonrpc&lt;/code&gt;字段声明所采用的JSON RPC版本号， 而可选的&lt;code&gt;id&lt;/code&gt;字段则用于建立响应消息与请求消息之间的关联，以便客户端 在同时发送多个请求后能正确跟踪其响应。&lt;/p&gt;
&lt;p&gt;响应消息中的&lt;code&gt;result&lt;/code&gt;字段记录了远程调用的执行结果，而&lt;code&gt;error&lt;/code&gt;字段 则记录了调用执行过程中出现的错误，&lt;code&gt;id&lt;/code&gt;字段则对应于请求消息中的同名 字段值。&lt;/p&gt;
&lt;p&gt;JSON RPC是传输协议无关的，但基于HTTP的广泛应用，节点通常都会提供基于 HTTP协议的实现，也就是说将JSON PRC消息作为HTTP报文的内容载荷进行传输：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733213/201905/733213-20190527211752851-636125892.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;bitcoind在不同的运行模式下，会在不同的默认端口监听HTTP RPC API请求：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;主网模式：8332&lt;/li&gt;
&lt;li&gt;测试网模式：18332&lt;/li&gt;
&lt;li&gt;Regtest开发模式：18443&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;可以在bitcoind的配置文件中使用&lt;code&gt;rpcbind&lt;/code&gt;选项和&lt;code&gt;rpcport&lt;/code&gt;选项修改监听端结点， 例如，设置为本地7878端口：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
rpcbind=&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;&lt;span&gt;
rpcport&lt;/span&gt;=&lt;span&gt;7878&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;二、使用curl测试RPC API&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;curl是一个支持URL语法的多协议命令行数据传输工具，可以从 &lt;a href=&quot;https://curl.haxx.se/&quot; target=&quot;_blank&quot;&gt;官网&lt;/a&gt;下载：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733213/201905/733213-20190527212016756-654271422.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;curl支持HTTP、FTP等多种协议，因此我们可以使用它来验证节点基于HTTP旳rpc接口 是否正常工作。例如，使用如下的命令访问节点旳&lt;code&gt;getnetworkinfo&lt;/code&gt;接口：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
~$ curl -X POST -d &lt;span&gt;'&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;
&amp;gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;jsonrpc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&amp;gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;method&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;getnetworkinfo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&amp;gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;params&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:[],
&lt;/span&gt;&amp;gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&amp;gt; }&lt;span&gt;'&lt;/span&gt;&lt;span&gt;  http://user:123456@localhost:18443&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;curl提供了很多选项用来定制HTTP请求。例如，可以使用&lt;code&gt;-X&lt;/code&gt;选项声明HTTP请求 的方法，对于JSON RPC来说，我们总是使用&lt;code&gt;POST&lt;/code&gt;方法；&lt;code&gt;-d&lt;/code&gt;选项则用来声明请求中包含 的数据，对于JSON RPC调用，这部分就是请求消息，例如我们按照&lt;code&gt;getnetworkinfo&lt;/code&gt;调用的 要求进行组织即可；命令的最后，也就是RPC调用消息的发送目的地址，即节点RPC API的访问URL。&lt;/p&gt;
&lt;p&gt;默认情况下curl返回的结果是没有格式化的JSON字符串，对机器友好，但并不适合人类查阅：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733213/201905/733213-20190527212057173-1833088272.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果你希望结果显示的更友好一些，可以级联一个命令行的json解析工具例如&lt;code&gt;jq&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
~$ curl -X POST -s -d &lt;span&gt;'&lt;/span&gt;&lt;span&gt;{...}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;user:123456@localhost:18443 | jq&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;jq&lt;/code&gt;是一个轻量级的命令行JSON处理器，你可以从&lt;a href=&quot;https://stedolan.github.io/jq/&quot; target=&quot;_blank&quot;&gt;官网&lt;/a&gt; 下载它。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
curl -X POST -s -d &lt;span&gt;'&lt;/span&gt;&lt;span&gt;{&quot;method&quot;:&quot;getnetworkinfo&quot;,&quot;params&quot;:[],&quot;id&quot;:123,&quot;jsonrpc&quot;:&quot;1.0&quot;}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; \
      http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;user:123456@localhost:18443 | jq&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;三、在C#代码中访问RPC API&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;自然，我们也可以在C#代码中来调用节点旳JSON RPC开发接口，可以借助于一个 http协议封装库来执行这些发生在HTTP之上的远程调用，例如.NET内置的HttpClient：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733213/201905/733213-20190527212238935-1905603013.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;例如，下面的代码使用HttpClient调用比特币节点的&lt;code&gt;getnetworkinfo&lt;/code&gt;接口：&lt;/p&gt;
&lt;p&gt; 首先下载bitcoin： https://bitcoin.org/zh_CN/download，如果使用主网络需要同步240G的数据，这里在本地以私链模式运行。私链模式运行也比较容易配置，只需要在bitcoin.conf中配置regtest=1。在windows下，bitcoin.conf的默认路径为%APPDATA%\bitcoin\bitcoin.conf。我的电脑在C:\Users\Administrator\AppData\Roaming\Bitcoin目录下。默认情况下bitcoind并不会自动创建上述路径下的bitcoin.conf配置文件，因此需要 自行制作一份放入上述目录。如果你没有现成的配置文件可用，可以从github拷贝一份：https://github.com/bitcoin/bitcoin/blob/master/share/examples/bitcoin.conf。关于bitcoin.conf的配置可以参考我的另一博客。&lt;/p&gt;
&lt;p&gt;这里regtest=1使用私链模式，server=1启动rpc，rpcuser=usertest、rpcpassword=usertest 设置用户名、密码。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('0ace8a5e-15f8-4dbf-a933-e28ea9292048')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_0ace8a5e-15f8-4dbf-a933-e28ea9292048&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_0ace8a5e-15f8-4dbf-a933-e28ea9292048&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('0ace8a5e-15f8-4dbf-a933-e28ea9292048',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_0ace8a5e-15f8-4dbf-a933-e28ea9292048&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
#testnet=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
regtest&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
proxy&lt;/span&gt;=&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;9050&lt;/span&gt;&lt;span&gt;
#bind&lt;/span&gt;=&amp;lt;addr&amp;gt;&lt;span&gt;
#whitebind&lt;/span&gt;=&amp;lt;addr&amp;gt;&lt;span&gt;
#addnode&lt;/span&gt;=&lt;span&gt;69.164&lt;/span&gt;.&lt;span&gt;218.197&lt;/span&gt;&lt;span&gt;
#addnode&lt;/span&gt;=&lt;span&gt;10.0&lt;/span&gt;.&lt;span&gt;0.2&lt;/span&gt;:&lt;span&gt;8333&lt;/span&gt;&lt;span&gt;
#connect&lt;/span&gt;=&lt;span&gt;69.164&lt;/span&gt;.&lt;span&gt;218.197&lt;/span&gt;&lt;span&gt;
#listen&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
#maxconnections&lt;/span&gt;=&lt;span&gt;
server&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
#rpcbind&lt;/span&gt;=&amp;lt;addr&amp;gt;&lt;span&gt;
rpcuser&lt;/span&gt;=&lt;span&gt;usertest
rpcpassword&lt;/span&gt;=&lt;span&gt;usertest
#rpcclienttimeout&lt;/span&gt;=&lt;span&gt;30&lt;/span&gt;&lt;span&gt;
#rpcallowip&lt;/span&gt;=&lt;span&gt;10.1&lt;/span&gt;.&lt;span&gt;1.34&lt;/span&gt;/&lt;span&gt;255.255&lt;/span&gt;.&lt;span&gt;255.0&lt;/span&gt;&lt;span&gt;
#rpcallowip&lt;/span&gt;=&lt;span&gt;1.2&lt;/span&gt;.&lt;span&gt;3.4&lt;/span&gt;/&lt;span&gt;24&lt;/span&gt;&lt;span&gt;
#rpcallowip&lt;/span&gt;=&lt;span&gt;2001&lt;/span&gt;:db8:85a3:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:8a2e:&lt;span&gt;370&lt;/span&gt;:&lt;span&gt;7334&lt;/span&gt;/&lt;span&gt;96&lt;/span&gt;&lt;span&gt;
#rpcport&lt;/span&gt;=&lt;span&gt;8332&lt;/span&gt;&lt;span&gt;
#rpcconnect&lt;/span&gt;=&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;&lt;span&gt;
#txconfirmtarget&lt;/span&gt;=&lt;span&gt;n
#paytxfee&lt;/span&gt;=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;.000x
#keypool&lt;/span&gt;=&lt;span&gt;100&lt;/span&gt;&lt;span&gt;
#prune&lt;/span&gt;=&lt;span&gt;550&lt;/span&gt;&lt;span&gt;
#min&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
#minimizetotray&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;启动之后如下图所示：会有一个regtest标记。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733213/201905/733213-20190528204941867-1539602098.png&quot; alt=&quot;&quot; width=&quot;611&quot; height=&quot;461&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('9fc25600-414d-49af-a271-83ece0782c86')&quot; readability=&quot;36&quot;&gt;&lt;img id=&quot;code_img_closed_9fc25600-414d-49af-a271-83ece0782c86&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_9fc25600-414d-49af-a271-83ece0782c86&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('9fc25600-414d-49af-a271-83ece0782c86',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_9fc25600-414d-49af-a271-83ece0782c86&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Net.Http;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Net.Http.Headers;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; RPCHttpClient
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            Task.Run(&lt;/span&gt;&lt;span&gt;async&lt;/span&gt; () =&amp;gt;&lt;span&gt;
            {
                HttpClient httpClient &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpClient();

                &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] authBytes = Encoding.ASCII.GetBytes(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;usertest:usertest&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                httpClient.DefaultRequestHeaders.Authorization &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; AuthenticationHeaderValue(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Basic&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Convert.ToBase64String(authBytes));

                &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; payload = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{\&quot;jsonrpc\&quot;:\&quot;1.0\&quot;,\&quot;method\&quot;:\&quot;getnetworkinfo\&quot;,\&quot;params\&quot;:[],\&quot;id\&quot;:7878}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

                StringContent content &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; StringContent(payload, Encoding.UTF8, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;application/json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                HttpResponseMessage rsp &lt;/span&gt;= &lt;span&gt;await&lt;/span&gt; httpClient.PostAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://127.0.0.1:18443&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, content);

                &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; ret = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; rsp.Content.ReadAsStringAsync();
                Console.WriteLine(ret);
                Console.ReadLine();
            }).Wait();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;在上面的代码中，我们首先实例化一个HttpClient对象并设置HTTP验证信息，然后调用该对象 的PostAsync()方法向节点旳RPC端口发送请求消息即可完成调用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733213/201905/733213-20190528205135403-1205727407.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 四、序列化与反序列化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在应用逻辑里直接拼接RPC请求字符串，或者直接解析RPC响应字符串，都不是件令人舒心的事情， 我们需要改进这一点。&lt;/p&gt;
&lt;p&gt;更干净的办法是使用数据传输对象（Data Transfer Object）来 隔离这个问题，在DTO层将 C#的对象序列化为Json字符串，或者从Json字符串 反序列化为C#的对象，应用代码只需要操作C#对象即可。&lt;/p&gt;
&lt;p&gt;我们首先定义出JSON请求与响应所对应的C#类。例如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733213/201905/733213-20190528205525130-1256073859.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在我们获取比特币网络信息的代码可以不用直接操作字符串了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('24f03e70-a810-401e-90dc-483870c070dc')&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_24f03e70-a810-401e-90dc-483870c070dc&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_24f03e70-a810-401e-90dc-483870c070dc&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('24f03e70-a810-401e-90dc-483870c070dc',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_24f03e70-a810-401e-90dc-483870c070dc&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Newtonsoft.Json;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; RPCHttpDTO
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; RpcRequestMessage
    {
        [JsonProperty(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; Id;

        [JsonProperty(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;method&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; Method;

        [JsonProperty(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;params&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt;[] Parameters;

        [JsonProperty(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;jsonrpc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; JsonRPC = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; RpcRequestMessage(&lt;span&gt;string&lt;/span&gt; method, &lt;span&gt;params&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt;[] parameters)
        {
            Id &lt;/span&gt;=&lt;span&gt; Environment.TickCount;
            Method &lt;/span&gt;=&lt;span&gt; method;
            Parameters &lt;/span&gt;=&lt;span&gt; parameters;
        }
    }
     

    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; RpcResponseMessage
    {
        [JsonProperty(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Id { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        [JsonProperty(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;result&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; Result { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        [JsonProperty(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;jsonrpc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; JsonRPC { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('b488f20a-b5f0-42b1-bc4b-7a52256982eb')&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_b488f20a-b5f0-42b1-bc4b-7a52256982eb&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_b488f20a-b5f0-42b1-bc4b-7a52256982eb&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('b488f20a-b5f0-42b1-bc4b-7a52256982eb',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_b488f20a-b5f0-42b1-bc4b-7a52256982eb&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Newtonsoft.Json;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Net.Http;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Net.Http.Headers;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; RPCHttpDTO
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            Task.Run(&lt;/span&gt;&lt;span&gt;async&lt;/span&gt; () =&amp;gt;&lt;span&gt;
            {
                HttpClient httpClient &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpClient();

                &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] authBytes = Encoding.ASCII.GetBytes(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;usertest:usertest&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                httpClient.DefaultRequestHeaders.Authorization &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; AuthenticationHeaderValue(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Basic&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Convert.ToBase64String(authBytes));

                RpcRequestMessage reqMsg &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; RpcRequestMessage(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;getnetworkinfo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;=&amp;gt; {0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, reqMsg.Method);

                &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; payload =&lt;span&gt; JsonConvert.SerializeObject(reqMsg);


                StringContent content &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; StringContent(payload, Encoding.UTF8, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;application/json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                HttpResponseMessage rsp &lt;/span&gt;= &lt;span&gt;await&lt;/span&gt; httpClient.PostAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:18443&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, content);

                &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; ret = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; rsp.Content.ReadAsStringAsync();
                RpcResponseMessage rspMsg &lt;/span&gt;= JsonConvert.DeserializeObject&amp;lt;RpcResponseMessage&amp;gt;&lt;span&gt;(ret);
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;= {0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, rspMsg.Result);
                Console.ReadLine();
            }).Wait();
        }
    }
}
 
    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733213/201905/733213-20190528210856306-1069476171.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;五、使用JSON RPC封装库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 除了直接使用HTTP协议库来访问比特币节点，在开源社区中也有一些直接针对 比特币RPC协议的封装，例如MetacoSA的&lt;a href=&quot;https://github.com/MetacoSA/NBitcoin&quot; target=&quot;_blank&quot;&gt;NBitcoin&lt;/a&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733213/201905/733213-20190528210956851-1945361317.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;NBitcoin是.NET平台上最完整的比特币开发库，实现了很多相关的比特币改进建议（Bitcoin Improvement Proposal)。 与RPC协议封装相关的类主要在NBitcoin.RPC命名空间下，入口类为&lt;code&gt;RPCClient&lt;/code&gt;， 它代表了对一个的比特币RPC访问端结点的协议封装。&lt;/p&gt;
&lt;p&gt;例如，下面的代码创建一个指向本机的私有链节点RPC的RPCClient实例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;using NBitcon.RPC;&lt;/span&gt;
&lt;span&gt;string&lt;/span&gt; auth = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user:123456&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;rpc接口的账号和密码&lt;/span&gt;
&lt;span&gt;string&lt;/span&gt; url = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:18443&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;本机私有链的默认访问端结点&lt;/span&gt;
Network network  = Network.RegTest;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;网络参数对象&lt;/span&gt;
RPCClient client = &lt;span&gt;new&lt;/span&gt; RPCClient(auth,url,network);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;实例化&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;比特币有三个不同的网络：主网、测试网和私有链，分别有一套对应的网络参数。 在NBitcoin中，使用Network类来表征比特币网络，它提供了三个静态属性分别 返回对应于三个不同网络的Network实例。在实例化RPCClient时需要传入与节点 对应的网络参数对象，例如当连接的节点是主网节点时，需要传入Network.Main， 而当需要本地私有链节点时，就需要传入&lt;code&gt;Network.RegTest&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;一旦实例化了RPCClient，就可以使用其&lt;code&gt;SendCommand()&lt;/code&gt;或&lt;code&gt;SendCommandAsync()&lt;/code&gt; 方法调用比特币节点的RPC接口了。容易理解，这两个方法分别对应于同步调用 和异步调用，除此之外，两者是完全一致的。&lt;/p&gt;
&lt;p&gt;例如，下面的代码使用同步方法调用&lt;code&gt;getnetworkinfo&lt;/code&gt;接口返回节点软件版本号：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;using Newtonsoft.Json.Linq;&lt;/span&gt;
RPCRequest req = &lt;span&gt;new&lt;/span&gt; RPCRequest{           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;RPC请求对象&lt;/span&gt;
  Method = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;getnetworkinfo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
  Params &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt;[]{}
};
RPCResponse rsp &lt;/span&gt;= client.SendCommand(req); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回RPC响应对象&lt;/span&gt;
Console.WriteLine(rsp.ResultString); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;ResultString返回原始的响应字符串&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;SendCommand/SendCommandAsync的重载&lt;/p&gt;
&lt;p&gt;如果你注意到实例化RPCRequest对象最重要的是Method和Params这两个属性，就容易 理解应该有更简单的SendCommand/SendCommandAsync方法了。下面是最常用的一种， 只需要传入方法名和动态参数列表，不需要自己再定义RPCRequest数据：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; RPCResponse SendCommand(&lt;span&gt;string&lt;/span&gt; commandName, &lt;span&gt;params&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;[] parameters)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;例如，下面的代码分别展示了无参和有参调用的使用方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
client.SendCommand(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;getnetworkworkinfo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;无参调用&lt;/span&gt;
client.SendCommand(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;generate&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;);          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;有参调用&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;容易理解，这个重载在内部帮我们构建了RPCRequest对象。&lt;/p&gt;
&lt;p&gt;从响应结果中提取数据&lt;/p&gt;
&lt;p&gt;RPCResponse的ResultString属性返回原始的JSON响应字符串，因此从中提取 数据的一个办法就是将其转换为C#的动态对象，这是最简明直接的方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;dynamic&lt;/span&gt; ret =&lt;span&gt; JsonConvert.DeserializeObject(rsp.ResultString);
Console.WriteLine(ret.networks[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;].name);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另一种提取数据的方法是使用RPCResponse的Result属性，它返回一个&lt;code&gt;JToken&lt;/code&gt;对象， 因此可以非常方便地使用JPath表达式来提取指定路径的数据。&lt;/p&gt;
&lt;p&gt;例如，下面的代码从getnetworkinfo的响应结果中提取并显示节点启用的所有网络 接口名称：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
IEnumerable&amp;lt;JToken&amp;gt; names = rsp.Result.SelectTokens(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;networks[*].name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;JPath表达式&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;); 
&lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; name &lt;span&gt;in&lt;/span&gt; names) Console.WriteLine(name);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果你不熟悉JToken和JPath，那么JToken的使用方法可以访问其 &lt;a href=&quot;https://www.newtonsoft.com/json/help/html/T_Newtonsoft_Json_Linq_JToken.htm&quot; target=&quot;_blank&quot;&gt;官网文档&lt;/a&gt;， 关于JPath表达式可以访问&lt;a href=&quot;https://goessner.net/articles/JsonPath/&quot; target=&quot;_blank&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt; 首先需要引入NBitcoin。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('b2ba4f7c-a550-4ccb-aabc-3db8b55f0db0')&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_b2ba4f7c-a550-4ccb-aabc-3db8b55f0db0&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_b2ba4f7c-a550-4ccb-aabc-3db8b55f0db0&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('b2ba4f7c-a550-4ccb-aabc-3db8b55f0db0',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_b2ba4f7c-a550-4ccb-aabc-3db8b55f0db0&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; NBitcoin;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; NBitcoin.RPC;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Newtonsoft.Json;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; RPCNbitcoin
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            Task.Run(&lt;/span&gt;&lt;span&gt;async&lt;/span&gt; () =&amp;gt;&lt;span&gt; {
                RPCClient client &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; RPCClient(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;usertest:usertest&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:18443&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Network.RegTest);
                RPCRequest req &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RPCRequest
                {
                    Method &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;getnetworkinfo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    Params &lt;/span&gt;=&lt;span&gt; { }
                };
                RPCResponse rsp &lt;/span&gt;= &lt;span&gt;await&lt;/span&gt;&lt;span&gt; client.SendCommandAsync(req);
                &lt;/span&gt;&lt;span&gt;dynamic&lt;/span&gt; ret =&lt;span&gt; JsonConvert.DeserializeObject(rsp.ResultString);
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;network#0 =&amp;gt; {0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, ret.networks[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;].name);

                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; names = rsp.Result.SelectTokens(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;networks[*].name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; name &lt;span&gt;in&lt;/span&gt;&lt;span&gt; names) Console.WriteLine(name);
                Console.ReadLine();
            }).Wait();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733213/201905/733213-20190528212231551-1882705756.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;六、NBitcoin的RPC封装完成度&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在大多数情况下，使用RPCClient的SendCommand或SendCommandAsync方法， 就可以完成比特币的RPC调用工作了。考虑到比特币RPC接口本身的不稳定性， 这是万能的使用方法。&lt;/p&gt;
&lt;p&gt;不过看起来NBitcoin似乎是希望在RPCClient中逐一实现RPC接口，虽然 这一任务还没有完成。例如，对于getbalance调用，其对应的方法为 GetBalance和GetBalanceAsync，因此我们也可以采用如下的方法获取钱包余额：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
Money balance =&lt;span&gt; client.GetBalance();
Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;balance: {0} BTC&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, balance.ToUnit(MoneyUnit.BTC)); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;单位：btc&lt;/span&gt;
Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;balance: {0} SAT&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, balance.Satoshi);               &lt;span&gt;//&lt;/span&gt;&lt;span&gt;单位：sat&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;显然，NBitcoin的预封装方法进行了额外的数据处理以返回一个Money实例， 这比直接使用SendCommand会更方便一些：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/733213/201905/733213-20190528212623635-2106286179.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因此如果NBitcoin已经实现了你需要的那个RPC接口的直接封装，建议首选直接封装方法， 可以在&lt;a href=&quot;https://metacosa.github.io/NBitcoin/api/NBitcoin.RPC.RPCClient.html&quot; target=&quot;_blank&quot;&gt;这里&lt;/a&gt; 查看RCPClient的官方完整参考文档。&lt;/p&gt;
&lt;p&gt;下表列出了部分在RPCClient中已经实现的RPC接口及对应的同步方法名，考虑到空间问题， 表中省去了异步方法名，相信这个清单会随着NBitcoin的开发越来越长：&lt;/p&gt;
&lt;table class=&quot;table table-striped&quot;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;分类&lt;/th&gt;
&lt;th&gt;RPC接口&lt;/th&gt;
&lt;th&gt;RPCClient方法&lt;/th&gt;
&lt;th&gt;备注&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;18&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;P2P网络&lt;/td&gt;
&lt;td&gt;addnode&lt;/td&gt;
&lt;td&gt;AddNode&lt;/td&gt;
&lt;td&gt;添加/删除P2P节点地址&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt; &lt;/td&gt;
&lt;td&gt;getaddednodeinfo&lt;/td&gt;
&lt;td&gt;GetAddedNodeInfo&lt;/td&gt;
&lt;td&gt;获取添加的P2P节点的信息&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt; &lt;/td&gt;
&lt;td&gt;getpeerinfo&lt;/td&gt;
&lt;td&gt;GetPeerInfo&lt;/td&gt;
&lt;td&gt;获取已连接节点的信息&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;区块链&lt;/td&gt;
&lt;td&gt;getblockchaininfo&lt;/td&gt;
&lt;td&gt;GteBlockchainInfo&lt;/td&gt;
&lt;td&gt;获取区块链的当前信息&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt; &lt;/td&gt;
&lt;td&gt;getbestblockhash&lt;/td&gt;
&lt;td&gt;GetBestBlockHash&lt;/td&gt;
&lt;td&gt;获取最优链的最近区块哈希&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt; &lt;/td&gt;
&lt;td&gt;getblockcount&lt;/td&gt;
&lt;td&gt;GetBlockCount&lt;/td&gt;
&lt;td&gt;获取本地最优链中的区块数量&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt; &lt;/td&gt;
&lt;td&gt;getblock&lt;/td&gt;
&lt;td&gt;GetBlock&lt;/td&gt;
&lt;td&gt;获取具有指定块头哈希的区块&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt; &lt;/td&gt;
&lt;td&gt;getblockhash&lt;/td&gt;
&lt;td&gt;GetBlockHash&lt;/td&gt;
&lt;td&gt;获取指定高度区块的块头哈希&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt; &lt;/td&gt;
&lt;td&gt;getrawmempool&lt;/td&gt;
&lt;td&gt;GetRawMemPool&lt;/td&gt;
&lt;td&gt;获取内存池中的交易ID数组&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt; &lt;/td&gt;
&lt;td&gt;gettxout&lt;/td&gt;
&lt;td&gt;GetTxOut&lt;/td&gt;
&lt;td&gt;获取指定的未消费交易输出的详细信息&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;工具类&lt;/td&gt;
&lt;td&gt;estimatefee&lt;/td&gt;
&lt;td&gt;EstimateFee&lt;/td&gt;
&lt;td&gt;估算千字节交易费率&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt; &lt;/td&gt;
&lt;td&gt;estimatesmartfee&lt;/td&gt;
&lt;td&gt;EstimateSmartFee&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;未公开&lt;/td&gt;
&lt;td&gt;invalidateblock&lt;/td&gt;
&lt;td&gt;InvalidateBlock&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;钱包&lt;/td&gt;
&lt;td&gt;backupwallet&lt;/td&gt;
&lt;td&gt;BackupWallet&lt;/td&gt;
&lt;td&gt;备份钱包文件&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt; &lt;/td&gt;
&lt;td&gt;dumpprivkey&lt;/td&gt;
&lt;td&gt;DumpPrivateKey&lt;/td&gt;
&lt;td&gt;导出指定地址的私钥&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt; &lt;/td&gt;
&lt;td&gt;getaccountaddress&lt;/td&gt;
&lt;td&gt;GetAccountAddress&lt;/td&gt;
&lt;td&gt;返回指定账户的当前地址&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt; &lt;/td&gt;
&lt;td&gt;importprivkey&lt;/td&gt;
&lt;td&gt;ImportPrivKey&lt;/td&gt;
&lt;td&gt;导入WIF格式的私钥&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt; &lt;/td&gt;
&lt;td&gt;importaddress&lt;/td&gt;
&lt;td&gt;ImportAddress&lt;/td&gt;
&lt;td&gt;导入地址以监听其相关交易&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt; &lt;/td&gt;
&lt;td&gt;listaccounts&lt;/td&gt;
&lt;td&gt;ListAccounts&lt;/td&gt;
&lt;td&gt;获取账户及对应余额清单&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt; &lt;/td&gt;
&lt;td&gt;listaddressgroupings&lt;/td&gt;
&lt;td&gt;ListAddressGroupings&lt;/td&gt;
&lt;td&gt;获取地址分组清单&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt; &lt;/td&gt;
&lt;td&gt;listunspent&lt;/td&gt;
&lt;td&gt;ListUnspent&lt;/td&gt;
&lt;td&gt;获取钱包内未消费交易输出清单&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt; &lt;/td&gt;
&lt;td&gt;lockunspent&lt;/td&gt;
&lt;td&gt;LockUnspent&lt;/td&gt;
&lt;td&gt;锁定/解锁指定的交易输出&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt; &lt;/td&gt;
&lt;td&gt;walletpassphrase&lt;/td&gt;
&lt;td&gt;WalletPassphrase&lt;/td&gt;
&lt;td&gt;解锁钱包&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt; &lt;/td&gt;
&lt;td&gt;getbalance&lt;/td&gt;
&lt;td&gt;GetBalance&lt;/td&gt;
&lt;td&gt;获取钱包余额&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt; &lt;/td&gt;
&lt;td&gt;getnewaddress&lt;/td&gt;
&lt;td&gt;GetNewAddress&lt;/td&gt;
&lt;td&gt;创建并返回一个新的钱包地址&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;值得指出的是，NBitcoin采用了PASCAL命名规则来生成RPC接口对应的方法名称， 即每个单词的首字母大写。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; NBitcoin;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; NBitcoin.RPC;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; RPCNbitcoinAdvanced
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            RPCClient client &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; RPCClient(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;usertest:usertest&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:18443&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Network.RegTest);

            Money balance &lt;/span&gt;=&lt;span&gt; client.GetBalance();
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;balance =&amp;gt; {0} btc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, balance);

            BitcoinAddress address &lt;/span&gt;=&lt;span&gt; client.GetNewAddress();
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;address =&amp;gt; {0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, address);

            uint256 txid &lt;/span&gt;= client.SendToAddress(address, Money.Coins(&lt;span&gt;0.1m&lt;/span&gt;&lt;span&gt;));
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sent 0.1 btc to above address.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            client.Generate(&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mined a block.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            UnspentCoin[] coins &lt;/span&gt;= client.ListUnspent(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;9999&lt;/span&gt;&lt;span&gt;, address);
            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; coin &lt;span&gt;in&lt;/span&gt;&lt;span&gt; coins)
            {
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;unspent coin =&amp;gt; {0} btc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, coin.Amount);
            }
            Console.ReadLine();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733213/201905/733213-20190528214621675-633382910.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733213/201905/733213-20190528214637962-465546676.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 七、利用UTXO计算钱包余额&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们知道，比特币都在UTXO上存着，因此容易理解，钱包的余额 应该就是钱包内所有的地址相关的UTXO的汇总：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733213/201905/733213-20190528215245658-31528367.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先查看钱包余额：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Money balance = client.getBalance();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后使用&lt;code&gt;listunspent&lt;/code&gt;接口列出钱包内地址相关的UTXO：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
UnspentCoin[] coins = client.ListUnspent(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;listunspent接口封装方法&lt;/span&gt;
&lt;span&gt;long&lt;/span&gt; amount = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; coin &lt;span&gt;in&lt;/span&gt; coins){          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;累加所有utxo的金额&lt;/span&gt;
    amount +=&lt;span&gt; coin.Amount.Satoshi;   
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ListUnspent()方法返回的结果是一个数组，每个成员都是一个UnspentCoin 对象：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733213/201905/733213-20190528215349655-232930369.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后我们比较一下：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if(balance.Satoshi == amount){ Console.WriteLine(&lt;span class=&quot;hljs-string&quot;&gt;&quot;verified!&quot;); }&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('a0e78895-e6c3-4417-90ce-c7abf94fe9c0')&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_a0e78895-e6c3-4417-90ce-c7abf94fe9c0&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_a0e78895-e6c3-4417-90ce-c7abf94fe9c0&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('a0e78895-e6c3-4417-90ce-c7abf94fe9c0',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_a0e78895-e6c3-4417-90ce-c7abf94fe9c0&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; NBitcoin;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; NBitcoin.RPC;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; CalcBalance
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            Task.Run(&lt;/span&gt;&lt;span&gt;async&lt;/span&gt; () =&amp;gt;&lt;span&gt; {
                RPCClient client &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; RPCClient(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;usertest:usertest&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:18443&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Network.RegTest);
                Money balance &lt;/span&gt;= &lt;span&gt;await&lt;/span&gt;&lt;span&gt; client.GetBalanceAsync();
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;getbalance =&amp;gt; {0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, balance.Satoshi);
                UnspentCoin[] coins &lt;/span&gt;= &lt;span&gt;await&lt;/span&gt;&lt;span&gt; client.ListUnspentAsync();
                &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; amount = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; coin &lt;span&gt;in&lt;/span&gt;&lt;span&gt; coins)
                {
                    amount &lt;/span&gt;+=&lt;span&gt; coin.Amount.Satoshi;
                }
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;unspent acc =&amp;gt; {0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, amount);

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (balance.Equals(Money.Satoshis(amount))) Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;verified successfully!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;failed to verify balance&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                Console.ReadLine();
            }).Wait();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733213/201905/733213-20190528215826745-2038424800.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;八、让网站支持比特币支付&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用bitcoind，我们可以非常快速地为网站增加接受比特币支付的功能：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733213/201905/733213-20190528215915894-2095412943.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当用户选择采用比特币支付其订单时，网站将自动提取该订单对应的 比特币地址（如果订单没有对应的比特币地址，则可以使用&lt;code&gt;getnewaddress&lt;/code&gt;创建一个）， 并在支付网页中显示订单信息、支付地址和比特币支付金额。为了方便 使用手机钱包的用户，可以将支付信息以二维码的形式在页面展现出来：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733213/201905/733213-20190528215937865-1510611923.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;用户使用比特币钱包向指定的地址支付指定数量的比特币后，即可点击 [已支付]按钮，提请网站检查支付结果。网站则开始周期性地调用节点 的&lt;code&gt;getreceivedbyaddress&lt;/code&gt;命令来检查订单对应地址的收款情况，一旦 收到足量比特币，即可结束该订单的支付并启动用户产品或服务的交付。 默认情况下，&lt;code&gt;getreceivedbyaddress&lt;/code&gt;将至少需要六个确认才会报告 地址收到的交易。&lt;/p&gt;
&lt;p&gt;除了使用&lt;code&gt;getreceivedbyadress&lt;/code&gt;命令来轮询收款交易，另一种检查 用户支付的方法是使用bitcoind的walletnotify选项。当bitcoind检测 到钱包中的地址发生交易时，将会调用walletnotify选项设置的脚本， 并传入交易id作为参数，因此可以在脚本中进一步获取交易详细信息。 例如在下面的配置文件中，当钱包中的地址发生交易时，将触发 tx-monitor.sh脚本：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
walletnofity=/&lt;span&gt;var&lt;/span&gt;/myshop/tx-monitor.sh %s
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是一个相当朴素的方案，但很容易实现。此外，如果你需要实时进行 法币和比特币的换算，还可以使用&lt;a href=&quot;https://www.blockchain.com/api&quot; target=&quot;_blank&quot;&gt;blockchain.info&lt;/a&gt; 提供的相关api。&lt;/p&gt;

</description>
<pubDate>Wed, 12 Jun 2019 13:35:00 +0000</pubDate>
<dc:creator>社会主义接班人</dc:creator>
<og:description>一、RPC API概述 比特币定义了RPC API来允许第三方应用通过节点软件访问比特币网络。 事实上，bitcoin-cli就是通过这个接口来实现其功能的，也就是说， 我们可以在自己的C#程序中完全</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/5ishare/p/10933399.html</dc:identifier>
</item>
</channel>
</rss>