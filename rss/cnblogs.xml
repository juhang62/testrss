<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>创业码农被公司套路最惨的一次经历 - 锋哥程序十年</title>
<link>http://www.cnblogs.com/bianchengniuren/p/10199644.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bianchengniuren/p/10199644.html</guid>
<description>&lt;p&gt;2018年马上就要过去了，把这一件真人真事写出来，也算是向过去一起努力的兄弟有个交代吧。&lt;/p&gt;
&lt;p&gt;关注我博客的朋友，应该都看过我之前写的一篇文章《记一次被骗去创业的经历》。该文章记录了博主在创业公司里的一段奋斗经历，虽然过程很苦，但是也收获了满满的回忆。尤其是结交了很多生死之交的研发兄弟。这篇文章讲的是博主离职之后发生的事情。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;画饼是会过期的&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;所有创业公司都需要解决一个共同的问题：&lt;strong&gt;员工凭什么为你卖命。&lt;/strong&gt;大多数自作聪明的老板采用的一种手段是：&lt;span&gt;&lt;strong&gt;画饼&lt;/strong&gt;&lt;/span&gt;。心有多大，饼就有多大。画饼是一种能见到立杆见影效果的手段。尤其是对单纯的程序员兄弟来说，公司适当的画饼，能让其立刻激情四射，干几个通宵均不在话下。但是程序员也往往不是好惹的，当他发现你套路他的时候，当心被他删库跑路。&lt;/p&gt;
&lt;p&gt;之前和博主一起进入该公司的几个兄弟，都曾经被老板画饼利诱过。但是随着时间的推移，画饼的效果渐渐消失。当大家都发现是被套路的时候，公司的战斗力可想而知。时间就是金钱，没有迸发出超强战斗力的创业公司，最终都是死路一条。&lt;/p&gt;
&lt;p&gt;很快公司的融资就烧完了，公司陷入生死存亡的阶段。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;员工购买股权&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;老板可能也意识到这样下去，公司可能会完蛋。但是公司的股权也不愿意白白发给员工，怎么办？&lt;/p&gt;
&lt;p&gt;经过一番精心的设计，公司决定要开放股权给公司的核心员工购买。公司的说法是，下一轮融资马上要开启，在股权溢价之前，给员工购买股份是对员工有利的。而且因为是核心成员才能购买，所以不购买的基本上就不是核心成员。&lt;/p&gt;
&lt;p&gt;我同事A君，为了保住他的核心团队成员身份，同时被股权溢价的美好愿望诱惑，花了十几万从公司购买了股权。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;落入更大的圈套&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;大家高高兴兴购买完股权，很快一个月过去了。A君发现，上个月工资一直没有发！A君大吃一惊，赶紧向同事打听。原来所有购买过股权的员工，都没有发上个月的工资。随后老板召开公司股东大会，向大家宣布公司进入艰难时期。所有的股东工资暂停发放，等待业务好转。&lt;/p&gt;
&lt;p&gt;就这样，一转眼半年过去了。&lt;/p&gt;
&lt;p&gt;一天A君找我吃饭，三杯酒下肚之后开始诉苦。A君说，公司原来早就没有钱了，所以开放股权给大家购买。其中有两个目的：1. 向员工融资，来支撑公司的运营。2. 可以堂而皇之的不给持股员工发工资，也不怕持股的核心员工跑路，除非不要股份。&lt;/p&gt;
&lt;p&gt;我听了大吃一惊，原来套路可以成精！！我除了安慰A君之外，也没有想出什么好的办法。ε=(´ο｀*)))唉，还有什么好说的呢，自古真情留不住，惟有套路得人心。&lt;/p&gt;
&lt;p&gt;永远也不要相信馅饼会砸在自己的头上，或许能少吃点亏吧。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;博主的现状&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我自从跳槽之后，去了小米。然后开始写博客，也有开了一个公众号《编程牛人》。我开始回顾自己的12年代码生涯，把自己经历的一些事情写下来，有幸得到程序员朋友们的喜欢，不胜欣喜，一年多的时间，写了一百多篇原创文章，分享自己的技术心得和感悟，同时申请了两项技术发明专利。朋友们有时间可以去我的博客和公众号逛一逛，支持一下博主。&lt;/p&gt;
&lt;p&gt;2018年即将写入历史，心有不甘，然能奈何？祝愿大家2019年越来越好。——2018.12.30&lt;/p&gt;

</description>
<pubDate>Sun, 30 Dec 2018 07:45:00 +0000</pubDate>
<dc:creator>锋哥程序十年</dc:creator>
<og:description>2018年马上就要过去了，把这一件真人真事写出来，也算是向过去一起努力的兄弟有个交代吧。 关注我博客的朋友，应该都看过我之前写的一篇文章《记一次被骗去创业的经历》。该文章记录了博主在创业公司里的一段奋</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bianchengniuren/p/10199644.html</dc:identifier>
</item>
<item>
<title>C++编程知识分享：静态库 - 修语谈谈C/C++</title>
<link>http://www.cnblogs.com/2f3d/p/10199645.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/2f3d/p/10199645.html</guid>
<description>&lt;p&gt;这次分享的宗旨是——让大家学会创建与使用静态库、动态库，知道静态库与动态库的区别，知道使用的时候如何选择。这里不深入介绍静态库、动态库的底层格式，内存布局等，有兴趣的同学，推荐一本书《程序员的自我修养——链接、装载与库》。&lt;/p&gt;
&lt;h4&gt;什么是库&lt;/h4&gt;
&lt;p&gt;库是写好的现有的，成熟的，可以复用的代码。现实中每个程序都要依赖很多基础的底层库，不可能每个人的代码都从零开始，因此库的存在意义非同寻常。&lt;/p&gt;
&lt;p&gt;本质上来说库是一种可执行代码的二进制形式，可以被操作系统载入内存执行。库有两种：静态库（.a、.lib）和动态库（.so、.dll）。&lt;/p&gt;
&lt;p&gt;所谓静态、动态是指链接。回顾一下，将一个程序编译成可执行程序的步骤：&lt;/p&gt;
&lt;div class=&quot;image-package&quot; readability=&quot;7&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/9693047-09c9c6bd5dc442ee.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;&lt;p&gt;有兴趣一起交流c/c++的小伙伴可以加群:941636044&lt;/p&gt;
&lt;/div&gt;
&lt;h4&gt;静态库&lt;/h4&gt;
&lt;p&gt;之所以成为【静态库】，是因为在链接阶段，会将汇编生成的目标文件.o与引用到的库一起链接打包到可执行文件中。因此对应的链接方式称为静态链接。&lt;/p&gt;
&lt;p&gt;试想一下，静态库与汇编生成的目标文件一起链接为可执行文件，那么静态库必定跟.o文件格式相似。其实一个静态库可以简单看成是一组目标文件（.o/.obj文件）的集合，即很多目标文件经过压缩打包后形成的一个文件。静态库特点总结：&lt;/p&gt;
&lt;p&gt; 静态库对函数库的链接是放在编译时期完成的。&lt;/p&gt;
&lt;p&gt; 程序在运行时与函数库再无瓜葛，移植方便。&lt;/p&gt;
&lt;p&gt; 浪费空间和资源，因为所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件。&lt;/p&gt;
&lt;p&gt;下面编写一些简单的四则运算C++类，将其编译成静态库给他人用，头文件如下所示：&lt;/p&gt;
&lt;blockquote readability=&quot;19&quot;&gt;
&lt;p&gt;#pragma once&lt;/p&gt;
&lt;p&gt;class StaticMath&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;public:&lt;/p&gt;
&lt;p&gt;    StaticMath(void);&lt;/p&gt;
&lt;p&gt;    ~StaticMath(void);&lt;/p&gt;

&lt;p&gt;    static double add(double a, double b);//加法&lt;/p&gt;
&lt;p&gt;    static double sub(double a, double b);//减法&lt;/p&gt;
&lt;p&gt;    static double mul(double a, double b);//乘法&lt;/p&gt;
&lt;p&gt;    static double div(double a, double b);//除法&lt;/p&gt;

&lt;p&gt;    void print();&lt;/p&gt;
&lt;p&gt;};&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;inux下使用ar工具、Windows下vs使用lib.exe，将目标文件压缩到一起，并且对其进行编号和索引，以便于查找和检索。一般创建静态库的步骤如图所示：&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/9693047-a7f186b4ec28039b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;
&lt;/div&gt;
&lt;h4&gt;Linux下创建与使用静态库&lt;/h4&gt;
&lt;p&gt;Linux静态库命名规则&lt;/p&gt;
&lt;p&gt;Linux静态库命名规范，必须是”lib[your_library_name].a”：lib为前缀，中间是静态库名，扩展名为.a。&lt;/p&gt;
&lt;p&gt;创建静态库（.a）&lt;/p&gt;
&lt;p&gt;通过上面的流程可以知道，Linux创建静态库过程如下：&lt;/p&gt;
&lt;p&gt;首先，将代码文件编译成目标文件.o（StaticMath.o）&lt;/p&gt;
&lt;p&gt;Shell&lt;/p&gt;
&lt;p&gt;1g++ -c StaticMath.cpp&lt;/p&gt;
&lt;p&gt;注意带参数-c，否则直接编译为可执行文件&lt;/p&gt;
&lt;p&gt; 然后，通过ar工具将目标文件打包成.a静态库文件&lt;/p&gt;
&lt;p&gt;Shell&lt;/p&gt;
&lt;p&gt;1ar -crv libstaticmath.a StaticMath.o&lt;/p&gt;
&lt;p&gt;生成静态库&lt;em&gt;libstaticmath&lt;/em&gt;&lt;em&gt;.a&lt;/em&gt;。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/9693047-1b5ae930bc942a8a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;
&lt;/div&gt;
&lt;p&gt;大一点的项目会编写makefile文件（CMake等等工程管理工具）来生成静态库，输入多个命令太麻烦了。&lt;/p&gt;
&lt;h4&gt;使用静态库&lt;/h4&gt;
&lt;p&gt;编写使用上面创建的静态库的测试代码：&lt;/p&gt;
&lt;blockquote readability=&quot;18&quot;&gt;
&lt;p&gt;#include &quot;StaticMath.h&quot;&lt;/p&gt;
&lt;p&gt;#include &amp;lt;iostream&amp;gt;&lt;/p&gt;
&lt;p&gt;using namespace std;&lt;/p&gt;

&lt;p&gt;int main(int argc, char* argv[])&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;    double a = 10;&lt;/p&gt;
&lt;p&gt;    double b = 2;&lt;/p&gt;

&lt;p&gt;    cout &amp;lt;&amp;lt; &quot;a + b = &quot; &amp;lt;&amp;lt; StaticMath::add(a, b) &amp;lt;&amp;lt; endl;&lt;/p&gt;
&lt;p&gt;    cout &amp;lt;&amp;lt; &quot;a - b = &quot; &amp;lt;&amp;lt; StaticMath::sub(a, b) &amp;lt;&amp;lt; endl;&lt;/p&gt;
&lt;p&gt;    cout &amp;lt;&amp;lt; &quot;a * b = &quot; &amp;lt;&amp;lt; StaticMath::mul(a, b) &amp;lt;&amp;lt; endl;&lt;/p&gt;
&lt;p&gt;    cout &amp;lt;&amp;lt; &quot;a / b = &quot; &amp;lt;&amp;lt; StaticMath::div(a, b) &amp;lt;&amp;lt; endl;&lt;/p&gt;

&lt;p&gt;    StaticMath sm;&lt;/p&gt;
&lt;p&gt;    sm.print();&lt;/p&gt;

&lt;p&gt;    system(&quot;pause&quot;);&lt;/p&gt;
&lt;p&gt;    return 0;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Linux下使用静态库，只需要在编译的时候，指定静态库的搜索路径（-L选项）、指定静态库名（不需要lib前缀和.a后缀，-l选项）。&lt;/p&gt;
&lt;p&gt;# g++ TestStaticLibrary.cpp -L../StaticLibrary -lstaticmath&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/9693047-c4d8e2f55e1436d3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;
&lt;/div&gt;
&lt;p&gt;-L：表示要连接的库所在目录&lt;/p&gt;
&lt;p&gt;-l：指定链接时需要的动态库，编译器查找动态连接库时有隐含的命名规则，即在给出的名字前面加上lib，后面加上.a或.so来确定库的名称。&lt;/p&gt;
&lt;h4&gt;Windows下创建与使用静态库&lt;/h4&gt;
&lt;p&gt;创建静态库（.lib）&lt;/p&gt;
&lt;p&gt;如果是使用VS命令行生成静态库，也是分两个步骤来生成程序：&lt;/p&gt;
&lt;p&gt;首先，通过使用带编译器选项 /c 的 Cl.exe 编译代码 (cl /c StaticMath.cpp)，创建名为“StaticMath.obj”的目标文件。&lt;/p&gt;
&lt;p&gt;然后，使用库管理器 Lib.exe 链接代码 (lib StaticMath.obj)，创建静态库StaticMath.lib。&lt;/p&gt;
&lt;p&gt;当然，我们一般不这么用，使用VS工程设置更方便。创建win32控制台程序时，勾选静态库类型；打开工程“属性面板”→”配置属性”→”常规”，配置类型选择静态库。&lt;/p&gt;
&lt;div class=&quot;image-package&quot; readability=&quot;7&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/9693047-237879b8845b4e96.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;&lt;p&gt;有兴趣一起交流c/c++的小伙伴可以加群:941636044&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Build项目即可生成静态库。&lt;/p&gt;
&lt;h4&gt;使用静态库&lt;/h4&gt;
&lt;p&gt;测试代码Linux下面的一样。有3种使用方法：&lt;/p&gt;
&lt;p&gt;方法一：&lt;/p&gt;
&lt;p&gt;在VS中使用静态库方法：&lt;/p&gt;
&lt;p&gt;工程“属性面板”→“通用属性”→“框架和引用”→”添加引用”，将显示“添加引用”对话框。 “项目”选项卡列出了当前解决方案中的各个项目以及可以引用的所有库。 在“项目”选项卡中，选择 StaticLibrary。 单击“确定”。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/9693047-0bfe46c6b2686f05.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;
&lt;/div&gt;
&lt;p&gt;添加StaticMath.h 头文件目录，必须修改包含目录路径。打开工程“属性面板”→”配置属性”→“C/C++”→” 常规”，在“附加包含目录”属性值中，键入StaticMath.h 头文件所在目录的路径或浏览至该目录。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/9693047-d7556105aae4f2f9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;
&lt;/div&gt;
&lt;p&gt;编译运行OK。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/9693047-0ff1fcade49f3e83.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;
&lt;/div&gt;
&lt;p&gt;如果引用的静态库不是在同一解决方案下的子工程，而是使用第三方提供的静态库lib和头文件，上面的方法设置不了。还有2中方法设置都可行。&lt;/p&gt;
&lt;p&gt;方法二：&lt;/p&gt;
&lt;p&gt;打开工程“属性面板”→”配置属性”→ “链接器”→ ”命令行”，输入静态库的完整路径即可。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/9693047-0213b958812a74fe.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;
&lt;/div&gt;
&lt;p&gt;方法三：&lt;/p&gt;
&lt;p&gt;“属性面板”→”配置属性”→“链接器”→”常规”，附加依赖库目录中输入，静态库所在目录；&lt;/p&gt;
&lt;p&gt;“属性面板”→”配置属性”→“链接器”→”输入”，附加依赖库中输入静态库名StaticLibrary.lib。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/9693047-8a6e504dfa8fcbca.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;
&lt;/div&gt;
</description>
<pubDate>Sun, 30 Dec 2018 07:45:00 +0000</pubDate>
<dc:creator>修语谈谈C/C++</dc:creator>
<og:description>这次分享的宗旨是——让大家学会创建与使用静态库、动态库，知道静态库与动态库的区别，知道使用的时候如何选择。这里不深入介绍静态库、动态库的底层格式，内存布局等，有兴趣的同学，推荐一本书《程序员的自我修养</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/2f3d/p/10199645.html</dc:identifier>
</item>
<item>
<title>Spring boot中自定义Json参数解析器 - 不懂是非</title>
<link>http://www.cnblogs.com/qm-article/p/10199622.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qm-article/p/10199622.html</guid>
<description>&lt;p&gt;&lt;span&gt;转载请注明出处。。。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;用过springMVC/spring boot的都清楚，在controller层接受参数，常用的都是两种接受方式，如下&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;     * 请求路径 &lt;/span&gt;&lt;span&gt;http://127.0.0.1&lt;/span&gt;&lt;span&gt;:8080/test 提交类型为application/json
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;     * 测试参数{&quot;sid&quot;:1,&quot;stuName&quot;:&quot;里斯&quot;}
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; str
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     @RequestMapping(value = &quot;/test&quot;,method =&lt;span&gt; RequestMethod.POST)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testJsonStr(@RequestBody(required = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;) String str){
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        System.out.println(str);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;     * 请求路径 &lt;/span&gt;&lt;span&gt;http://127.0.0.1&lt;/span&gt;&lt;span&gt;:8080/testAcceptOrdinaryParam?str=123
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;     * 测试参数
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; str
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;     @RequestMapping(value = &quot;/testAcceptOrdinaryParam&quot;,method =&lt;span&gt; {RequestMethod.GET,RequestMethod.POST})
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testAcceptOrdinaryParam(String str){
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        System.out.println(str);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;第一个就是前端传json参数，后台使用RequestBody注解来接受参数。第二个就是普通的get/post提交数据，后台进行接受参数的方式，当然spring还提供了参数在路径中的解析格式等，这里不作讨论&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本文主要是围绕前端解析Json参数展开，那@RequestBody既然能接受json参数，那它有什么缺点呢，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;原spring 虽然提供了@RequestBody注解来封装json数据，但局限性也挺大的，对参数要么适用jsonObject或者javabean类，或者string，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、若使用jsonObject 接收，对于json里面的参数，还要进一步获取解析，很麻烦&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、若使用javabean来接收,若接口参数不一样，那么每一个接口都得对应一个javabean若使用string 来接收，那么也得需要自己解析json参数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、所以琢磨了一个和get/post form-data提交方式一样，直接在controller层接口写参数名即可接收对应参数值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;重点来了，那么要完成在spring给controller层方法注入参数前，拦截这些参数，做一定改变，对于此，spring也提供了一个接口来让开发者自己进行扩展。这个接口名为&lt;/span&gt;&lt;span&gt;HandlerMethodArgumentResolver，它呢 是一个接口，它的作用主要是用来提供controller层参数拦截和注入用的。spring 也提供了很多实现类，这里不作讨论，这里介绍它的一个比较特&lt;/span&gt;&lt;span&gt;殊的实现类HandlerMethodArgumentResolverComposite，下面列出该类的一个实现方法&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    @Nullable
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;         HandlerMethodArgumentResolver resolver =&lt;span&gt; getArgumentResolver(parameter);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (resolver == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalArgumentException(
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                     &quot;Unsupported parameter type [&quot; + parameter.getParameterType().getName() + &quot;].&quot; +
&lt;span&gt;10&lt;/span&gt;                             &quot; supportsParameter should be called first.&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; resolver.resolveArgument(parameter, mavContainer, webRequest, binderFactory);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 是不是感到比较惊讶，它自己不去执行自己的resplveArgument方法，反而去执行HandlerMethodArgumentResolver接口其他实现类的方法，具体原因，我不清楚，，，&lt;/span&gt;&lt;span&gt;这个方法就是给controller层方法参数注入值得一个入口。具体的不多说啦！下面看代码&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;要拦截一个参数，肯定得给这个参数一个标记，在拦截的时候，判断有没有这个标记，有则拦截，没有则方向，这也是一种过滤器/拦截器原理，谈到标记，那肯定非注解莫属，于是一个注解类就产生了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@Target(ElementType.PARAMETER)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;@Retention(RetentionPolicy.RUNTIME)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; RequestJson {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;     * 字段名，不填则默认参数名
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     String fieldName() &lt;span&gt;default&lt;/span&gt; &quot;&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;     * 默认值，不填则默认为null。
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;     String defaultValue() &lt;span&gt;default&lt;/span&gt; &quot;&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;这个注解也不复杂，就两个属性，一个是fieldName，一个是defaultValue。有了这个，下一步肯定得写该注解的解析器，而上面又谈到HandlerMethodArgumentResolver接口可以拦截controller层参数，所以这个注解的解析器肯定得写在该接口实现类里，&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; RequestJsonHandler &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; HandlerMethodArgumentResolver {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * json类型
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String JSON_CONTENT_TYPE = &quot;application/json&quot;&lt;span&gt;;


    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; supportsParameter(MethodParameter methodParameter) {
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;只有被reqeustJson注解标记的参数才能进入&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; methodParameter.hasParameterAnnotation(RequestJson.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Object resolveArgument(MethodParameter methodParameter, ModelAndViewContainer modelAndViewContainer, NativeWebRequest nativeWebRequest, WebDataBinderFactory webDataBinderFactory) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 解析requestJson注解的代码&lt;/span&gt;
&lt;span&gt;        
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;一个大致模型搭建好了。要实现的初步效果，这里也说下，如图&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/900767/201812/900767-20181230144851122-1261518723.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;要去解析json参数，那肯定得有一些常用的转换器，把json参数对应的值，转换到controller层参数对应的类型中去，而常用的类型如 八种基本类型及其包装类，String、Date类型，list/set,javabean等，所有可以先去定义一个转换器接口。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Converter {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     * 将value转为clazz类型
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; clazz
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; value
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    Object convert(Type clazz, Object value);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;有了这个接口，那肯定得有几个实现类，在这里，我将这些转换器划分为 ，7个阵营&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、Number类型转换器，负责Byte/Integer/Float/Double/Long/Short 及基础类型，还有BigInteger/BigDecimal两个类&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、Date类型转换器，负责日期类型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、String类型转换器，负责char及包装类，还有string类型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、Collection类型转换器，负责集合类型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5、Boolean类型转换器，负责boolean/Boolean类型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6、javaBean类型转换器，负责普通的的pojo类&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;7、Map类型转换器，负责Map接口&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里要需引入第三方包google，在文章末尾会贴出来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代码在这里就贴Number类型和Date类型，其余完整代码，会在github上给出，地址  &lt;a href=&quot;https://github.com/qm1995/jsonDemo&quot; target=&quot;_blank&quot;&gt;github链接&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Number类型转换器&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; NumberConverter &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Converter{
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object convert(Type type, Object value){
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         Class&amp;lt;?&amp;gt; clazz = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!(type &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; Class)){
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         clazz = (Class&amp;lt;?&amp;gt;&lt;span&gt;) type;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (clazz == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RuntimeException(&quot;类型不能为空&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         }&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (value == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         }&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (value &lt;span&gt;instanceof&lt;/span&gt; String &amp;amp;&amp;amp; &quot;&quot;&lt;span&gt;.equals(String.valueOf(value))){
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         }&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!clazz.isPrimitive() &amp;amp;&amp;amp; clazz.getGenericSuperclass() != Number.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ClassCastException(clazz.getTypeName() + &quot;can not cast Number type!&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (clazz == &lt;span&gt;int&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt; || clazz == Integer.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Integer.valueOf(String.valueOf(value));
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         }&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (clazz == &lt;span&gt;short&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt; || clazz == Short.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Short.valueOf(String.valueOf(value));
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         }&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (clazz == &lt;span&gt;byte&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt; || clazz == Byte.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Byte.valueOf(String.valueOf(value));
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         }&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (clazz == &lt;span&gt;float&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt; || clazz == Float.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Float.valueOf(String.valueOf(value));
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         }&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (clazz == &lt;span&gt;double&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt; || clazz == Double.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Double.valueOf(String.valueOf(value));
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         }&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (clazz == &lt;span&gt;long&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt; || clazz == Long.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Long.valueOf(String.valueOf(value));
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         }&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (clazz == BigDecimal.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BigDecimal(String.valueOf(value));
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         }&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (clazz == BigInteger.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BigDecimal(String.valueOf(value));
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         }&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RuntimeException(&quot;This type conversion is not supported!&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; 
&lt;span&gt;40&lt;/span&gt; 
&lt;span&gt;41&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;Date类型转换器&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * 日期转换器
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt; * 对于日期校验，这里只是简单的做了一下，实际上还有对闰年的校验，
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; * 每个月份的天数的校验及其他日期格式的校验
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt;: qiumin
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt; * @create: 2018-12-30 10:43
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt; *&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DateConverter &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Converter{
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;     * 校验 yyyy-MM-dd HH:mm:ss
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String REGEX_DATE_TIME = &quot;^\\d{4}([-]\\d{2}){2}[ ]([0-1][0-9]|[2][0-4])(:[0-5][0-9]){2}$&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;     * 校验 yyyy-MM-dd
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String REGEX_DATE = &quot;^\\d{4}([-]\\d{2}){2}$&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;     * 校验HH:mm:ss
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String REGEX_TIME = &quot;^([0-1][0-9]|[2][0-4])(:[0-5][0-9]){2}&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;     * 校验 yyyy-MM-dd HH:mm
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String REGEX_DATE_TIME_NOT_CONTAIN_SECOND = &quot;^\\d{4}([-]\\d{2}){2}[ ]([0-1][0-9]|[2][0-4]):[0-5][0-9]$&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt; &lt;span&gt;     * 默认格式
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String DEFAULT_PATTERN = &quot;yyyy-MM-dd HH:mm:ss&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt; &lt;span&gt;     * 存储数据map
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Map&amp;lt;String,String&amp;gt; PATTERN_MAP = &lt;span&gt;new&lt;/span&gt; ConcurrentHashMap&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; 
&lt;span&gt;41&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;         PATTERN_MAP.put(REGEX_DATE,&quot;yyyy-MM-dd&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;         PATTERN_MAP.put(REGEX_DATE_TIME,&quot;yyyy-MM-dd HH:mm:ss&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;         PATTERN_MAP.put(REGEX_TIME,&quot;HH:mm:ss&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;         PATTERN_MAP.put(REGEX_DATE_TIME_NOT_CONTAIN_SECOND,&quot;yyyy-MM-dd HH:mm&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; 
&lt;span&gt;48&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object convert(Type clazz, Object value) {
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (clazz == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RuntimeException(&quot;type must be not null!&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (value == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;         }&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&quot;&quot;&lt;span&gt;.equals(String.valueOf(value))){
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SimpleDateFormat(getDateStrPattern(String.valueOf(value))).parse(String.valueOf(value));
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ParseException e) {
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RuntimeException(e);
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; 
&lt;span&gt;65&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;66&lt;/span&gt; &lt;span&gt;     * 获取对应的日期字符串格式
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; value
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
&lt;span&gt;69&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;70&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String getDateStrPattern(String value){
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (Map.Entry&amp;lt;String,String&amp;gt;&lt;span&gt; m : PATTERN_MAP.entrySet()){
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (value.matches(m.getKey())){
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; m.getValue();
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_PATTERN;
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 具体分析不做过多讨论，详情看代码。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那写完转换器，那接下来，我们肯定要从request中拿到前端传的参数，常用的获取方式有request.getReader()，request.getInputStream()，但值得注意的是，这两者者互斥。即在一次请求中使用了一者，然后另一个就获取不到想要的结果。具体大家可以去试下。如果我们直接在解析requestJson注解的时候使用这两个方法中的一个，那很大可能会出问题，因为我们也保证不了在spring中某个方法有使用到它，那肯定最好结果是不使用它或者包装它(提前获取getReader()/getInputStream()中的数据，将其存入一个byte数组，后续request使用这两个方法获取数据可以直接从byte数组中拿数据)，不使用肯定不行，那得进一步去包装它，在java ee中有提供这样一个类&lt;/span&gt;&lt;span&gt;HttpServletRequestWrapper，它就是httpsevletRequest的一个子实现类，也就是意味httpservletRequest的可以用这个来代替，具体大家可以去看看源码，spring提供了几个HttpServletRequestWrapper的子类，这里就不重复造轮子，这里使用&lt;/span&gt;&lt;span&gt;ContentCachingRequestWrapper类。对request进行包装，肯定得在filter中进行包装&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; RequestJsonFilter &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Filter {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;     * 用来对request中的Body数据进一步包装
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; req
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; response
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; chain
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; IOException
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; ServletException
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; doFilter(ServletRequest req, ServletResponse response, FilterChain chain) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException, ServletException {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         ServletRequest requestWrapper = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(req &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; HttpServletRequest) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             HttpServletRequest request =&lt;span&gt; (HttpServletRequest) req;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;             * 只是为了防止一次请求中调用getReader(),getInputStream(),getParameter()
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;             * 都清楚inputStream 并不具有重用功能，即多次读取同一个inputStream流，
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;             * 只有第一次读取时才有数据，后面再次读取inputStream 没有数据，
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;             * 即，getReader()，只能调用一次，但getParameter()可以调用多次，详情可见ContentCachingRequestWrapper源码
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;               &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;             requestWrapper = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ContentCachingRequestWrapper(request);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         chain.doFilter(requestWrapper == &lt;span&gt;null&lt;/span&gt; ?&lt;span&gt; req : requestWrapper, response);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;实现了过滤器，那肯定得把过滤器注册到spring容器中，&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@Configuration
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;@EnableWebMvc
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; WebConfigure &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; WebMvcConfigurer {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    @Autowired
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; RequestJsonHandler requestJsonHandler;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 把requestJson解析器也交给spring管理&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; addArgumentResolvers(List&amp;lt;HandlerMethodArgumentResolver&amp;gt;&lt;span&gt; resolvers) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         resolvers.add(0&lt;span&gt;,requestJsonHandler);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    @Bean
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; FilterRegistrationBean filterRegister() {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         FilterRegistrationBean registration = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FilterRegistrationBean();
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         registration.setFilter(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; RequestJsonFilter());
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;拦截路径&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;         registration.addUrlPatterns(&quot;/&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;过滤器名称&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;         registration.setName(&quot;requestJsonFilter&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否自动注册 false 取消Filter的自动注册&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;         registration.setEnabled(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;过滤器顺序,需排在第一位&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;         registration.setOrder(1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; registration;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt;     @Bean(name = &quot;requestJsonFilter&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Filter requestFilter(){
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RequestJsonFilter();
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;万事具备，就差解析器的代码了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于前端参数的传过来的json参数格式，大致有两种。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一、{&quot;name&quot;:&quot;张三&quot;}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;二、[{&quot;name&quot;:&quot;张三&quot;},{&quot;name&quot;:&quot;张三1&quot;}]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以解析的时候，要对这两种情况分情况解析。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Object resolveArgument(MethodParameter methodParameter, ModelAndViewContainer modelAndViewContainer, NativeWebRequest nativeWebRequest, WebDataBinderFactory webDataBinderFactory) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt; 
&lt;span&gt;  4&lt;/span&gt;         HttpServletRequest request = nativeWebRequest.getNativeRequest(HttpServletRequest.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt;         String contentType =&lt;span&gt; request.getContentType();
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 不是json&lt;/span&gt;
&lt;span&gt;  7&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;JSON_CONTENT_TYPE.equalsIgnoreCase(contentType)){
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt;         Object obj =&lt;span&gt;  request.getAttribute(Constant.REQUEST_BODY_DATA_NAME);
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt;         &lt;span&gt;synchronized&lt;/span&gt; (RequestJsonHandler.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (obj == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt; &lt;span&gt;                resolveRequestBody(request);
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt;                 obj =&lt;span&gt; request.getAttribute(Constant.REQUEST_BODY_DATA_NAME);
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (obj == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt;         RequestJson requestJson = methodParameter.getParameterAnnotation(RequestJson.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (obj &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; Map){
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt;             Map&amp;lt;String, String&amp;gt; map = (Map&amp;lt;String, String&amp;gt;&lt;span&gt;)obj;
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; dealWithMap(map,requestJson,methodParameter);
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt;         }&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (obj &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; List){
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt;             List&amp;lt;Map&amp;lt;String,String&amp;gt;&amp;gt; list = (List&amp;lt;Map&amp;lt;String,String&amp;gt;&amp;gt;&lt;span&gt;)obj;
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; dealWithArray(list,requestJson,methodParameter);
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt; 
&lt;span&gt; 31&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 32&lt;/span&gt; &lt;span&gt;     * 处理第一层json结构为数组结构的json串
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt; &lt;span&gt;     * 这种结构默认就认为 为类似List&amp;lt;JavaBean&amp;gt; 结构，转json即为List&amp;lt;Map&amp;lt;K,V&amp;gt;&amp;gt; 结构，
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt; &lt;span&gt;     * 其余情况不作处理，若controller层为第一种，则数组里的json，转为javabean结构，字段名要对应，
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt; &lt;span&gt;     * 注意这里defaultValue不起作用
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; list
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; requestJson
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; methodParameter
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
&lt;span&gt; 40&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 41&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; Object dealWithArray(List&amp;lt;Map&amp;lt;String,String&amp;gt;&amp;gt;&lt;span&gt; list,RequestJson requestJson,MethodParameter methodParameter){
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt;         Class&amp;lt;?&amp;gt; parameterType =&lt;span&gt; methodParameter.getParameterType();
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ConverterUtil.getConverter(parameterType).convert(methodParameter.getGenericParameterType(),JsonUtil.convertBeanToStr(list));
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 46&lt;/span&gt; &lt;span&gt;     * 处理{&quot;&quot;:&quot;&quot;}第一层json结构为map结构的json串，
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; map
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; requestJson
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; methodParameter
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
&lt;span&gt; 51&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 52&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; Object dealWithMap(Map&amp;lt;String,String&amp;gt;&lt;span&gt; map,RequestJson requestJson,MethodParameter methodParameter){
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt;         String fieldName =&lt;span&gt; requestJson.fieldName();
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&quot;&quot;&lt;span&gt;.equals(fieldName)){
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt;             fieldName =&lt;span&gt; methodParameter.getParameterName();
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt;         Class&amp;lt;?&amp;gt; parameterType =&lt;span&gt; methodParameter.getParameterType();
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt;         String orDefault = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (map.containsKey(fieldName)){
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt;             orDefault =&lt;span&gt; map.get(fieldName);
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt;         }&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ConverterUtil.isMapType(parameterType)){
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; map;
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt;         }&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (ConverterUtil.isBeanType(parameterType) ||&lt;span&gt; ConverterUtil.isCollectionType(parameterType)){
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt;             orDefault =&lt;span&gt; JsonUtil.convertBeanToStr(map);
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt;         }&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt;             orDefault =&lt;span&gt; map.getOrDefault(fieldName,requestJson.defaultValue());
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ConverterUtil.getConverter(parameterType).convert(methodParameter.getGenericParameterType(),orDefault);
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt; 
&lt;span&gt; 71&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 72&lt;/span&gt; &lt;span&gt;     * 解析request中的body数据
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; request
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 75&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; resolveRequestBody(ServletRequest request){
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;         BufferedReader reader = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt;             reader =&lt;span&gt; request.getReader();
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt;             StringBuilder sb = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuilder();
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt;             String line = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt;             &lt;span&gt;while&lt;/span&gt; ((line = reader.readLine()) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt; &lt;span&gt;                sb.append(line);
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt;             String parameterValues =&lt;span&gt; sb.toString();
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt;             JsonParser parser = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JsonParser();
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;             JsonElement element =&lt;span&gt; parser.parse(parameterValues);
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (element.isJsonArray()){
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt;                 List&amp;lt;Map&amp;lt;String,String&amp;gt;&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt;                 list =&lt;span&gt; JsonUtil.convertStrToBean(list.getClass(),parameterValues);
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt; &lt;span&gt;                request.setAttribute(Constant.REQUEST_BODY_DATA_NAME, list);
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt;             }&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt;                 Map&amp;lt;String, String&amp;gt; map = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt;                 map =&lt;span&gt; JsonUtil.convertStrToBean(map.getClass(), parameterValues);
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt; &lt;span&gt;                request.setAttribute(Constant.REQUEST_BODY_DATA_NAME, map);
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt;         }&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (reader != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;                 &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt; &lt;span&gt;                    reader.close();
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt;                 } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ignore
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;e.printStackTrace();&lt;/span&gt;
&lt;span&gt;105&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;整个代码结构就是上面博文，完整代码在github上，有感兴趣的博友，可以看看地址  &lt;a href=&quot;https://github.com/qm1995/jsonDemo&quot; target=&quot;_blank&quot;&gt;github链接&lt;/a&gt;，最后贴下maven依赖包&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &amp;lt;dependencies&amp;gt;
&lt;span&gt; 2&lt;/span&gt;         &amp;lt;dependency&amp;gt;
&lt;span&gt; 3&lt;/span&gt;             &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
&lt;span&gt; 4&lt;/span&gt;             &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
&lt;span&gt; 5&lt;/span&gt;         &amp;lt;/dependency&amp;gt;
&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;         &amp;lt;dependency&amp;gt;
&lt;span&gt; 8&lt;/span&gt;             &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
&lt;span&gt; 9&lt;/span&gt;             &amp;lt;artifactId&amp;gt;spring-boot-starter-tomcat&amp;lt;/artifactId&amp;gt;
&lt;span&gt;10&lt;/span&gt;             &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;
&lt;span&gt;11&lt;/span&gt;         &amp;lt;/dependency&amp;gt;
&lt;span&gt;12&lt;/span&gt;         &amp;lt;dependency&amp;gt;
&lt;span&gt;13&lt;/span&gt;             &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
&lt;span&gt;14&lt;/span&gt;             &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
&lt;span&gt;15&lt;/span&gt;             &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
&lt;span&gt;16&lt;/span&gt;         &amp;lt;/dependency&amp;gt;
&lt;span&gt;17&lt;/span&gt;         &amp;lt;dependency&amp;gt;
&lt;span&gt;18&lt;/span&gt;             &amp;lt;groupId&amp;gt;com.google.code.gson&amp;lt;/groupId&amp;gt;
&lt;span&gt;19&lt;/span&gt;             &amp;lt;artifactId&amp;gt;gson&amp;lt;/artifactId&amp;gt;
&lt;span&gt;20&lt;/span&gt;             &amp;lt;version&amp;gt;2.8.4&amp;lt;/version&amp;gt;
&lt;span&gt;21&lt;/span&gt;         &amp;lt;/dependency&amp;gt;
&lt;span&gt;22&lt;/span&gt;     &amp;lt;/dependencies&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;----------------------------------------------------------------------------------------------------华丽的分界线------------------------------------------------------------------------------------------------------------&lt;/p&gt;
&lt;p&gt;以后就是本文全部内容，若有不足或错误之处还望指正，谢谢！&lt;/p&gt;

</description>
<pubDate>Sun, 30 Dec 2018 07:40:00 +0000</pubDate>
<dc:creator>不懂是非</dc:creator>
<og:description>转载请注明出处。。。 一、介绍 用过springMVC/spring boot的都清楚，在controller层接受参数，常用的都是两种接受方式，如下 第一个就是前端传json参数，后台使用Reque</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qm-article/p/10199622.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core WebApi中简单像素转换跟踪实现 - 张子浩</title>
<link>http://www.cnblogs.com/ZaraNet/p/10199407.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ZaraNet/p/10199407.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1366751/201812/1366751-20181230144218190-1414474705.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;像素跟踪虽然是最早用于跟踪营销转换的方法，但它仍然被广泛使用，像Facebook这样的大公司仍然将其视为跟踪网页转换的方法之一。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;由于它的简单性，通过像素方法的跟踪转换仍然被广泛使用。&lt;/span&gt;&lt;span&gt;它不需要任何复杂的客户端实现，因为它确保它将在几乎所有可以加载图像的浏览器上执行。&lt;/span&gt;&lt;span&gt;它由&lt;/span&gt;&lt;span&gt;页面上的&lt;/span&gt;&lt;span&gt;一个简单的&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;img&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;标记&lt;/span&gt;&lt;span&gt;组成，该&lt;/span&gt;&lt;span&gt;标记的&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;src&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;属性指向跟踪端点。&lt;/span&gt;&lt;span&gt;端点从HTML页面呈现上的图像标记发起的GET请求中接收参数，并将参数发送到后端。&lt;/span&gt;&lt;span&gt;作为回报，后端发送图像内容，通常是1x1像素透明PNG或GIF内容。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;像素的典型样本将是这样的:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre name=&quot;code&quot; class=&quot;xml&quot;&gt;
&amp;lt;img src=&quot;9102 hello i love uuu&quot; alt=&quot;&quot; width=&quot;1&quot; height=&quot;1&quot; /&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1366751/201812/1366751-20181230144709847-777390354.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由于它是一个简单的GET请求，而不是AJAX调用，因此您无需在后端端启用CORS或其他任何东西，因此使用非常简单方便。&lt;/span&gt;&lt;span&gt;跟踪的逻辑在服务器端，因此我们现在将重点关注如何从请求中获取大部分数据并使用1x1像素图像进行响应。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所有请求的共同点是使用图像内容进行响应，因此我们将首先执行此操作。&lt;/span&gt;&lt;span&gt;我们首先需要的是图像内容，但如果我们在每次请求时继续从磁盘加载图像，这会损害我们的响应速度，因此可能会减慢客户端浏览器中的页面加载速度。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;出于这个原因，我决定将appsettings.json中的图像内容保留为序列化的base64图像内容。&lt;/span&gt;&lt;span&gt;此内容加载到单个字节数组，然后在每个控制器操作请求上提供相同的字节数组实例。&lt;/span&gt;&lt;span&gt;因此，让我们首先将1x1pixel透明图像存储在配置中。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Response&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;PixelContentBase64&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;R0lGODlhAQABAPcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAP8ALAAAAAABAAEAAAgEAP8FBAA7&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;PixelContentType&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;image/gif&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  },
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Logging&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LogLevel&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Default&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Warning&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    }
  },
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AllowedHosts&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;接下来是创建一个从配置中读取的图像内容的字节数组。&lt;/span&gt;&lt;span&gt;这是在ConfigureServices方法的Startup.cs中完成的&lt;/span&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Builder;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Hosting;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Mvc;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.Configuration;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.DependencyInjection;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; DotnetCorePixelSample
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Startup
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Startup(IConfiguration configuration)
        {
            Configuration &lt;/span&gt;=&lt;span&gt; configuration;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IConfiguration Configuration { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; This method gets called by the runtime. Use this method to add services to the container.&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
        {
            services.AddSingleton&lt;/span&gt;&amp;lt;FileContentResult&amp;gt;(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileContentResult(
                    Convert.FromBase64String(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Configuration.GetValue&amp;lt;String&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Response:PixelContentBase64&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)), 
                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Configuration.GetValue&amp;lt;String&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Response:PixelContentType&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                ));

            services.AddMvc();
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; This method gets called by the runtime. Use this method to configure the HTTP request pipeline.&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app, IHostingEnvironment env)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (env.IsDevelopment())
            {
                app.UseDeveloperExceptionPage();
            }

            app.UseMvc();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;在加载图像的字节数组内容后，我们将其存储在  &lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;code-text&quot;&gt;&lt;span&gt;FileContentResult&lt;/span&gt;&lt;span&gt;&lt;span&gt;类实例中，该实例将用于从像素跟踪WebAPI操作返回的响应。&lt;/span&gt;&lt;span&gt;由于它是单音，因此每个请求都会反复使用相同的实例，而不会在请求中添加任何其他处理。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;现在还剩下什么，因为我们从Startup中配置的DI注入的内容是收集数据。&lt;/span&gt;&lt;span&gt;这是通过访问QueryString参数和Header值在控制器操作中完成的，这些参数是每个请求的一部分。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;由于我们不需要等待数据存储完成，我们可以将其包装在Task中并立即返回图像响应。&lt;/span&gt;&lt;span&gt;这是一个性能改进，可能导致整个页面在客户端执行不良。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Mvc;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.Primitives;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; DotnetCorePixelSample.Controllers
{
    [Route(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[controller]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    [ApiController]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TrackController : ControllerBase
    {
        &lt;/span&gt;&lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; FileContentResult pixelResponse;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; TrackController(FileContentResult pixelResponse)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.pixelResponse =&lt;span&gt; pixelResponse;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IActionResult &lt;span&gt;get&lt;/span&gt;&lt;span&gt;()
        {&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; parameters = Request.Query.Keys.ToDictionary(k =&amp;gt; k, k =&amp;gt;&lt;span&gt; Request.Query[k]);
&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; headers = Request.Headers.Keys.ToDictionary(k =&amp;gt; k, k =&amp;gt;&lt;span&gt; Request.Query[k]);

            Task.Factory.StartNew((data) &lt;/span&gt;=&amp;gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; dataDictionary = data &lt;span&gt;as&lt;/span&gt; IDictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, StringValues&amp;gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
            }, parameters.Union(headers).ToDictionary(k&lt;/span&gt;=&amp;gt;k.Key, v=&amp;gt;v.Value)).ConfigureAwait(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; pixelResponse;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;存储数据与此逻辑无关，您可以使用任何存储来保存收集的数据。&lt;/p&gt;
</description>
<pubDate>Sun, 30 Dec 2018 07:02:00 +0000</pubDate>
<dc:creator>张子浩</dc:creator>
<og:description>像素跟踪虽然是最早用于跟踪营销转换的方法，但它仍然被广泛使用，像Facebook这样的大公司仍然将其视为跟踪网页转换的方法之一。 由于它的简单性，通过像素方法的跟踪转换仍然被广泛使用。它不需要任何复杂</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ZaraNet/p/10199407.html</dc:identifier>
</item>
<item>
<title>Flume初始 - 冰魄秋雨</title>
<link>http://www.cnblogs.com/skyice/p/10199154.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/skyice/p/10199154.html</guid>
<description>&lt;h3&gt;一、Flume是什么&lt;/h3&gt;
&lt;p&gt;Flume是一个数据，日志收集的一个组件，可以用于对程序，nginx等日志的收集，而且非常简单，省时的做完收集的工作。Flume是一个分布式、可靠、和高可用的海量日志采集聚合和传输的系统。支持在日志系统中定制各类数据发送方，用于收集日志，同时Flume对日志做简单的处理。&lt;/p&gt;
&lt;p&gt;Flume作为一个非常受欢迎的日志收集工具，有如下几个特点：&lt;/p&gt;
&lt;h4&gt;1. flume的可靠性&lt;/h4&gt;
&lt;p&gt;　flume的某个节点出现故障时，数据不会丢失。flume提供了三种级别的可靠保障，级别从强到弱分别是&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;　end-to-end，收到数据agent首先将event写到磁盘上，当数据传送成功后，再删除；如果数据发送失败，可以重新发送&lt;/li&gt;
&lt;li&gt;　Store on failure 这也是scribe采用的策略，当数据接收方crash时，将数据写到本地，待恢复后，继续发送&lt;/li&gt;
&lt;li&gt;　Besteffort 数据发送到接收方后，不会进行确认&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;2. flume的可恢复性&lt;/h4&gt;
&lt;p&gt;   将数据持久化到磁盘不会丢失，因为存储到了文件中，可以后续重新恢复。&lt;/p&gt;
&lt;h3&gt;二、Flume能够做什么&lt;/h3&gt;
&lt;p&gt;1.作为日志收集的工具，其目的用于日志的收集。web程序的日志收集和nginx写入程序的日志收集的操作：我接触到的日志收集，web程序的日志会在打印的时候被拦截，然后输入到kafka中，但是也有一部分的操作就是将日志直接打印到文件中，然后统一传入到ftp服务，在有程序统一处理。nginx日志分析也是日志打印到一个文件中，后续将其放入到统一位置处理。消息中间件都有日志收集的jar包，例如rocketmq的rocketmq-logappender包，kafka中有类可以直接调用。&lt;/p&gt;
&lt;p&gt;kafka是分布式消息中间件，自带存储，提供push和pull存取数据功能，有Replication功能，能够实现高容错性，kafka收集日志，kafka有一个更小的生产消费者生态&lt;span id=&quot;17KSFindDIV&quot; class=&quot;KSFIND_CLASS_SELECT&quot;&gt;系统，但是整个社区对日志收集支持不太友好。kafka是一个消息中间件，多处理不同系统之间的数据生成 / 消费的速率不同。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;flume专门设计成为日志收集的工具，封装了非常多的接口可供使用，使用简单，flume的agent(数据采集器)，collector（数据简单处理和写入）,storage（存储器）三部分，每一个都可以定制。并提供了简单的数据处理的能力。&lt;/p&gt;
&lt;p&gt;使用建议：&lt;/p&gt;
&lt;p&gt;　　1.如果有很多下游的Consumer,用kafka,而需简要存储大Hadoop，hive时，用flume&lt;/p&gt;
&lt;p&gt;　　2.kafka做为一个做为一个日志缓存系统更合适，flume数据采集更优秀，在考虑场景是，需要给hadoop存储数据时，可以使用kafka+flume模式，如果有多个数据源，可以使用flume+kafka的内容&lt;/p&gt;
&lt;p&gt;　　3.  Kafka 是一个通用型系统。你可以有许多的生产者和消费者分享多个主题。相反地，Flume 被设计成特定用途的工作，特定地向 HDFS 和 HBase 发送出去。Flume 为了更好地为 HDFS 服务而做了特定的优化，并且与 Hadoop 的安全体系整合在了一起。基于这样的结论，Hadoop 开发商 Cloudera 推荐如果数据需要被多个应用程序消费的话，推荐使用 Kafka，如果数据只是面向 Hadoop 的，可以使用 Flume。&lt;/p&gt;
&lt;p&gt;　　4. Flume 拥有许多配置的来源 (sources) 和存储池 (sinks)。然后，Kafka 拥有的是非常小的生产者和消费者环境体系，Kafka 社区并不是非常支持这样。如果你的数据来源已经确定，不需要额外的编码，那你可以使用 Flume 提供的 sources 和 sinks，反之，如果你需要准备自己的生产者和消费者，那你需要使用 Kafka。&lt;/p&gt;
&lt;p&gt;　　5. Flume 可以在拦截器里面实时处理数据。这个特性对于过滤数据非常有用。Kafka 需要一个外部系统帮助处理数据。&lt;/p&gt;
&lt;p&gt;　　6. 无论是 Kafka 或是 Flume，两个系统都可以保证不丢失数据。然后，Flume 不会复制事件。相应地，即使我们正在使用一个可以信赖的文件通道，如果 Flume agent 所在的这个节点宕机了，你会失去所有的事件访问能力直到你修复这个受损的节点。使用 Kafka 的管道特性不会有这样的问题。&lt;/p&gt;
&lt;p&gt;　　7. lume 和 Kafka 可以一起工作的。如果你需要把流式数据从 Kafka 转移到 Hadoop，可以使用 Flume 代理 (agent)，将 kafka 当作一个来源 (source)，这样可以从 Kafka 读取数据到 Hadoop。你不需要去开发自己的消费者，你可以使用 Flume 与 Hadoop、HBase 相结合的特性，使用 Cloudera Manager 平台监控消费者，并且通过增加过滤器的方式处理数据。&lt;/p&gt;
&lt;h3&gt;Flume的核心&lt;/h3&gt;
&lt;h4&gt; 1.核心概念&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;　Client:client生成数据，运行在一个独立的线程&lt;/li&gt;
&lt;li&gt;　Event： 一个数据单元，消息头和消息体组成。（Events可以是日志记录、 avro 对象等。）&lt;/li&gt;
&lt;li&gt;　Flow： Event从源点到达目的点的迁移的抽象。&lt;/li&gt;
&lt;li&gt;&lt;em id=&quot;__mceDel&quot;&gt;  &lt;/em&gt;  Agent： 一个独立的Flume进程，包含组件Source、 Channel、 Sink。（Agent使用JVM 运行Flume。每台机器运行一个agent，但是可以在一个agent中包含多个sources和sinks。）&lt;/li&gt;
&lt;li&gt;　Source： 数据收集组件。（source从Client收集数据，传递给Channel）&lt;/li&gt;
&lt;li&gt;　Channel： 中转Event的一个临时存储，保存由Source组件传递过来的Event。（Channel连接 sources 和 sinks ，这个有点像一个队列。）&lt;/li&gt;
&lt;li&gt;　Sink： 从Channel中读取并移除Event， 将Event传递到FlowPipeline中的下一个Agent（如果有的话）（Sink从Channel收集数据，运行在一个独立线程。）&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt; 2. Agent详解&lt;/h4&gt;
&lt;p&gt;　　Flume运行核心是Agent,一个Agent就是一个JVM,它是一个完整的数据收集工具。Agent包含组件Source、Channel、Sink，通过这些组件 Event 可以从一个地方流向另一个地方，如下图所示。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/999804/201711/999804-20171108130603872-780242084.png&quot; alt=&quot;&quot; width=&quot;540&quot; height=&quot;207&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;webServer产生日志的源&lt;/li&gt;
&lt;li&gt;Source收集日志工具，负责将数据捕获后进行特殊的格式化，将数据封装到事件（event） 里，然后将事件推入Channel中。&lt;/li&gt;
&lt;li&gt;Channel管道，是连接Source和Sink的组件，大家可以将它看做一个数据的缓冲区（数据队列），它可以将事件暂存到内存中也可以持久化到本地磁盘上， 直到Sink处理完该事件。介绍两个较为常用的Channel， MemoryChannel和FileChannel，推荐使用FileChannel。&lt;/li&gt;
&lt;li&gt;Sink从Channel中取出事件，然后将数据发到别处，可以向文件系统、数据库、 hadoop存数据， 也可以是其他agent的Source。在日志数据较少时，可以将数据存储在文件系统中，并且设定一定的时间间隔保存数据。&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;四、Flume的日志收集&lt;/h3&gt;
&lt;p&gt;　　一个简单的例子，nginx产生的日志，flume收集之后，放置到hadoop中，在服务器中部署nginx,flume,hadoop&lt;/p&gt;
&lt;p&gt;　　1.nginx在配置中，需要打开日志输出，并标识出日志输出的路径.&lt;em id=&quot;__mceDel&quot;&gt;　　　&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;http {
    # 配置日志格式
    log_format lf '$remote_addr $msec $http_host 
&lt;span&gt;
    server {
        listen       80&lt;span&gt;;
        server_name localhost;
        location ~*\.(html|js|css|jpg|jpeg|gif|png|swf|ico|json|&lt;span&gt;apk)$ {&lt;br/&gt;　　　　　　　　　# 日志输出路径
               access_log /opt/nginx/log/&lt;span&gt;access.log lf; 
               root html;
               #root /usr/local/extra/nginx-1.9.6/html/&lt;span&gt;;
               #root /usr/local/extra/nginx-1.9.6/html2/&lt;span&gt;;
        }
    }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;flume的配置：&lt;em id=&quot;__mceDel&quot;&gt;flume-conf.properties&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# 配置Agent
agent.sources =&lt;span&gt; r1
agent.sinks =&lt;span&gt; k1
agent.channels =&lt;span&gt; c1

# 配置Source
agent.sources.r1.type =&lt;span&gt; exec
agent.sources.r1.channels =&lt;span&gt; c1
agent.sources.r1.deserializer.outputCharset = UTF-8&lt;span&gt;

# 配置需要监控的日志输出目录
agent.sources.r1.command = tail -f /usr/local/nginx/log/&lt;span&gt;access.log

# 配置Sink
agent.sinks.k1.type =&lt;span&gt; hdfs
agent.sinks.k1.channel =&lt;span&gt; c1
agent.sinks.k1.hdfs.useLocalTimeStamp = true&lt;span&gt;
agent.sinks.k1.hdfs.path = hdfs://localhost:9000/flume/events/%Y-%m
agent.sinks.k1.hdfs.filePrefix = %Y-%m-%d-%&lt;span&gt;H
agent.sinks.k1.hdfs.fileSuffix =&lt;span&gt; .log
agent.sinks.k1.hdfs.minBlockReplicas = 1&lt;span&gt;
agent.sinks.k1.hdfs.fileType =&lt;span&gt; DataStream
agent.sinks.k1.hdfs.writeFormat =&lt;span&gt; Text
agent.sinks.k1.hdfs.rollInterval = 86400&lt;span&gt;
agent.sinks.k1.hdfs.rollSize = 1000000&lt;span&gt;
agent.sinks.k1.hdfs.rollCount = 10000&lt;span&gt;
agent.sinks.k1.hdfs.idleTimeout = 0&lt;span&gt;

# 配置Channel
agent.channels.c1.type =&lt;span&gt; memory
agent.channels.c1.capacity = 1000&lt;span&gt;
agent.channels.c1.transactionCapacity = 100&lt;span&gt;

# 将三者连接
agent.sources.r1.channel =&lt;span&gt; c1
agent.sinks.k1.channel = c1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这些配置之后，启动时会出现错误，原因是，需要一些jar包，flume下的lib是没有这些包，需要如下包（这些包从hadoop中复制过来）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
{HADOOP_HOME}/share/hadoop/common/lib/commons-configuration2-2.1.1&lt;span&gt;.jar
{HADOOP_HOME}/share/hadoop/common/lib/hadoop-auth-3.1.1&lt;span&gt;.jar
{HADOOP_HOME}/share/hadoop/common/hadoop-common-3.1.1&lt;span&gt;.jar
{HADOOP_HOME}/share/hadoop/hdfs/hadoop-hdfs-3.1.1&lt;span&gt;.jar
{HADOOP_HOME}/share/hadoop/common/lib/woodstox-core-5.2.0&lt;span&gt;.jar
{HADOOP_HOME}/share/hadoop/common/lib/ stax2-api-3.1.4&lt;span&gt;.jar
{HADOOP_HOME}/share/hadoop/common/lib/htrace-core4-4.1.0-incubating.jar&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后运行如下命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
bin/flume-ng agent --conf conf/  --name agent --conf-file conf/flume-conf.properties -Dflume.root.logger=DEBUG,console
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在访问ip:80时，服务器日志将写入到hadoop的flume/event/目录下&lt;/p&gt;

</description>
<pubDate>Sun, 30 Dec 2018 05:16:00 +0000</pubDate>
<dc:creator>冰魄秋雨</dc:creator>
<og:description>一、Flume是什么 Flume是一个数据，日志收集的一个组件，可以用于对程序，nginx等日志的收集，而且非常简单，省时的做完收集的工作。Flume是一个分布式、可靠、和高可用的海量日志采集聚合和传</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/skyice/p/10199154.html</dc:identifier>
</item>
<item>
<title>笔耕不辍，无问西东——2018年终小结 - 大史不说话</title>
<link>http://www.cnblogs.com/dashnowords/p/10199126.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dashnowords/p/10199126.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;blockquote readability=&quot;2.125&quot;&gt;
&lt;p&gt;github仓库：&lt;a href=&quot;http://www.github.com/dashnowords&quot; class=&quot;uri&quot;&gt;http://www.github.com/dashnowords&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;博客园地址：&lt;a href=&quot;https://www.cnblogs.com/dashnowords/p/10127926.html&quot;&gt;《大史住在大前端》原创博文目录&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354575/201812/1354575-20181230130359267-1872114269.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2018年5月，我开通了自己的前端技术博客，名为&lt;a href=&quot;https://www.cnblogs.com/dashnowords/p/10127926.html&quot;&gt;【大史住在大前端】&lt;/a&gt;，那时距离2017年8月正式成为前端工程师还不到一年，庆幸地是自己坚持下来了，7个多月来累计共发表前端原创博文&lt;strong&gt;65&lt;/strong&gt;篇，这种被量化了的进步让我觉得很欣慰也很踏实。&lt;/p&gt;
&lt;h3 id=&quot;写作也是一种学习&quot;&gt;写作，也是一种学习&lt;/h3&gt;
&lt;p&gt;被问得最多的问题就是“哪来那么多时间精力”，其实喜欢做的事情，你总有办法挤出时间的不是吗？我喜欢写作，喜欢前端，所以我总有办法拿出时间，可能是你睡觉做梦的时间，可能是你跟别人一起开黑打王者的时间，也可能是你坐在家里吃着零食看娱乐综艺的时间，这并没有什么好坏或者对错之分，每个人都有自己的生活方式，只是选择不同罢了。有朋友说自己也想写，但是不知道写什么，我个人认为这只是个借口罢了。泰勒本沙哈尔在《哈佛幸福课》中有一句很经典的描述对我影响很深，也是我在自己掌握知识及其有限的情况下愿意开始写博客的原因。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;The best way to learn is to teach.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;就是上面的这句话，后来才知道这是心理学上著名的&lt;code&gt;“费曼学习法”&lt;/code&gt;的一种浓缩。你不知道写什么，那总有想学想了解的东西吧（说没有的那个同学你出去），学的过程中如果主动思考了，总会有心得体会的，可能是文中的某个难点，可能是自己做的练习，也可能是某些知识的延伸，这不就是素材么。最初的时候我也担心过不知道写什么可能造成博客断更，但事实证明完全是多虑，有关的东西根本就写不完。我讨厌重复别人写过的东西，觉得那很无聊。看到一些优质的文章时，我会直接把它推荐出来，或者将自己学习别人文章时的收获，疑问，反思等等提炼成文章。&lt;/p&gt;
&lt;h3 id=&quot;一点小秘密&quot;&gt;一点小秘密&lt;/h3&gt;
&lt;p&gt;其实有些文章写成了以后觉得很系统很清晰，但写之前甚至写的过程中我自己都还一脸懵逼，这太正常了。我的写作逻辑是&lt;strong&gt;“想学什么，就去写什么”&lt;/strong&gt;，而不是“我掌握了什么才去分享什么”。&lt;/p&gt;
&lt;h3 id=&quot;意外收获&quot;&gt;意外收获&lt;/h3&gt;
&lt;p&gt;或许就像大家常说的&lt;strong&gt;“因为努力，所以幸运”&lt;/strong&gt;吧，随着持续的写作，自己的基础补的很快（毕竟是半路出家的野生码农），知识体系也梳理地越来越清晰，慢慢开始有公司其他部门的交流活动邀请我去做分享，后来收获了一些粉丝，收到了很多技术社区运营和编辑的入驻邀请，也认识了很多比我更牛也比我更高产的博主，收到了很多猎头发来的职位推荐和面试邀请，也陆续收到几个很有影响力的出版社的编辑的书稿邀约，收到了社区给优秀博主奖励的一台&lt;strong&gt;kindle touch&lt;/strong&gt;，圣诞节的时候还收到粉丝送的花，简直是爆棚了老夫的一颗年近30的少男心。&lt;/p&gt;
&lt;p&gt;写作的初心，不过是写一些学习笔记罢了，并没有太多的期望，无论怎么看，都觉得生活待我不薄。&lt;/p&gt;
&lt;h3 id=&quot;前端的发展方向&quot;&gt;前端的发展方向&lt;/h3&gt;
&lt;p&gt;很多人想问，但我不敢说，不是藏着掖着，而是真的不懂，或者说觉得自己没资格说。记得在大学毕业那年，学校邀请樊登（就是樊登读书会那个樊登）来学校做分享交流，他当时讲了关于“关注圈”和“影响圈”的话题，让我至今都觉得很受益。我们每个人都有自己的“关注圈”和“影响圈”，关注圈发生的事情会影响你但你只能被动接受或者压根跟你没什么关系你只是碰巧接收到了信息的，这些事情对个人而言并没什么价值，而影响圈发生的事情是指一个人有能力去改变现实的一个范围，比如油价涨跌对大部分人来说就是关注圈的事情，因为它或涨或跌，你都得开车通勤，但对于投资石油或者石油公司的决策者来说那就是影响圈的事情，因为信息会影响他们的决策，甚至他们的决策会促进信息的进一步变化。樊登的建议是适当关注“关注圈”，但是一定要持续在“影响圈”来投入精力，因为它可以带来真实的改变，随着你的努力，影响圈会越变越大，而影响圈和关注圈的交集，基本就代表了大多数人对成功的向往。&lt;/p&gt;
&lt;p&gt;回到前端的方向来说，具体的发展，感兴趣的小伙伴可以关注“前端之巅”这个公众号，几乎每1-2周就会将前端的前沿消息推送给你，但正如前面所说，这毕竟是关注圈的事情，几年以内可能都不会跟你有什么关系，而自己该如何进步和成长，才是影响圈的事情，我更在乎后者，或许跟很多人比自己算比较努力的了，但努力的程度还远远达不到去跟别人拼天赋，能做的事情，也不过就是题目中说的那句&lt;strong&gt;“笔耕不辍，无问西东”&lt;/strong&gt;，翻译成大白话就是&lt;strong&gt;“干就完了别BB”&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;年想写什么&quot;&gt;2019年想写什么&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;nodejs&lt;/code&gt;,&lt;code&gt;H5&lt;/code&gt;,&lt;code&gt;WebGL&lt;/code&gt;，这是明年希望专注精进的方向，经过半年多的摸爬滚打，我觉得这是真正能鉴别前端工程师水平的东西，当然如何使用三大框架之一和其周边生态来做好自己的本职工作，那是每个人都应该自觉做好的事情，也就不用多说了。如果你也对此感兴趣，欢迎订阅我的技术博客，一起研究交流。期望新的一年里，看到更多的想变得更好的前端开发者行动起来。&lt;/p&gt;
&lt;h3 id=&quot;最后一句&quot;&gt;最后一句&lt;/h3&gt;
&lt;p&gt;做个厉害的前端，做个温暖的人，这就是我对自己仅有的追求了。&lt;/p&gt;
</description>
<pubDate>Sun, 30 Dec 2018 05:05:00 +0000</pubDate>
<dc:creator>大史不说话</dc:creator>
<og:description>github仓库：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dashnowords/p/10199126.html</dc:identifier>
</item>
<item>
<title>.NET Core单元测试之搞死开发的覆盖率统计（coverlet + ReportGenerator ） - 李国宝</title>
<link>http://www.cnblogs.com/liguobao/p/10199085.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liguobao/p/10199085.html</guid>
<description>&lt;p&gt;这两天在给项目补单元测试，dalao们要求要看一下测试覆盖率&lt;/p&gt;
&lt;p&gt;翻了一波官方test命令覆盖率倒是有支持了，然而某个更新日志里面写着&lt;/p&gt;
&lt;p&gt;【“Support for Linux and Mac will be considered separately in a subsequent effort.”】&lt;/p&gt;
&lt;p&gt;吐血ing。。。&lt;/p&gt;
&lt;p&gt;8102年都要过去了，微软同学你是不有点过分啊。&lt;/p&gt;
&lt;p&gt;然后又翻了一堆资料之后发现，GitHub有dalao自己搞了个&lt;a href=&quot;https://github.com/tonerdo/coverlet&quot;&gt;coverlet&lt;/a&gt;来支持测试覆盖率。&lt;/p&gt;
&lt;p&gt;开源大法拯救世界啊！！！&lt;/p&gt;
&lt;p&gt;star一个再说。&lt;/p&gt;
&lt;h2 id=&quot;coverlet配置和使用&quot;&gt;coverlet配置和使用&lt;/h2&gt;
&lt;p&gt;首先安装一下coverlet.&lt;/p&gt;
&lt;pre class=&quot;sh&quot;&gt;
&lt;code&gt;
dotnet tool install --global coverlet.console
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者和我一样懒的话,直接在项目里面引用 &quot;coverlet.msbuild&quot; 这个包也行.&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;    &amp;lt;PackageReference Include=&quot;coverlet.msbuild&quot; Version=&quot;2.5.0&quot; /&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;引用之后,执行dotnet test 的时候加多三个参数&lt;/p&gt;
&lt;pre class=&quot;sh&quot;&gt;
&lt;code&gt;dotnet test /p:CollectCoverage=true /p:CoverletOutput='./results/' /p:CoverletOutputFormat=opencover&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;CollectCoverage 收集覆盖率&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;CoverletOutput 测试报告数据输出路径&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;CoverletOutputFormat 测试报告格式,支持这些格式json (default)/lcov/opencover/cobertura/teamcity&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其他参数自己看一下文档说明就好.&lt;/p&gt;
&lt;p&gt;执行之后大概会看到这些信息.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/64d1e863gy1fyonjzh7s4j21jk0lk785.jpg&quot; alt=&quot;测试报告&quot;/&gt;&lt;/p&gt;
&lt;p&gt;PS:可怜的个位数覆盖率....&lt;/p&gt;
&lt;p&gt;这个时候Test项目里面的results 文件夹里面就有一个coverage.opencover.xml 文件了.&lt;/p&gt;
&lt;p&gt;打开这个文件大概长这个样.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/64d1e863gy1fyonmcmwt1j21k60cmaf8.jpg&quot; alt=&quot;xml&quot;/&gt;&lt;/p&gt;
&lt;p&gt;大概率这不是人看的东西.&lt;/p&gt;
&lt;p&gt;然后另一个工具又出来了.&lt;/p&gt;
&lt;h2 id=&quot;reportgenerator&quot;&gt;ReportGenerator&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/danielpalme/ReportGenerator&quot; class=&quot;uri&quot;&gt;https://github.com/danielpalme/ReportGenerator&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ReportGenerator converts XML reports generated by OpenCover, PartCover, dotCover, Visual Studio, NCover, Cobertura or JaCoCo into human readable reports in various formats.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这个工具可以讲上面这些不是人看的XML转换成HTML输出.&lt;/p&gt;
&lt;p&gt;美滋滋啊美滋滋啊.&lt;/p&gt;
&lt;p&gt;他们居然还有一个配置指导的页面&lt;a href=&quot;https://danielpalme.github.io/ReportGenerator/usage.html&quot;&gt;ReportGenerator/usage&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;真良心!!!&lt;/p&gt;
&lt;p&gt;我这边简单起见,直接安装 dotnet tool 全局工具算了.&lt;/p&gt;
&lt;pre class=&quot;sh&quot;&gt;
&lt;code&gt;dotnet tool install --global dotnet-reportgenerator-globaltool&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装好了之后,直接在命令行里面使用 reportgenerator 生成对应的测试报告即可.我这边的命令大概是:&lt;/p&gt;
&lt;pre class=&quot;sh&quot;&gt;
&lt;code&gt;reportgenerator '-reports:UnitTests/results/*.xml' '-targetdir:UnitTests/results'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打开UnitTests/results 下面的index.htm就能看到对应的测试报告了.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/64d1e863gy1fyonx8zmjzj22cc11u7bk.jpg&quot; alt=&quot;1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/64d1e863gy1fyony28hz9j22gc12sk04.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;全文完.&lt;/p&gt;
&lt;p&gt;明年见！&lt;/p&gt;
</description>
<pubDate>Sun, 30 Dec 2018 04:47:00 +0000</pubDate>
<dc:creator>李国宝</dc:creator>
<og:description>.NET Core单元测试之搞死开发的覆盖率统计 这两天在给项目补单元测试，dalao们要求要看一下测试覆盖率 翻了一波官方test命令覆盖率倒是有支持了，然而某个更新日志里面写着 【“Suppor</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liguobao/p/10199085.html</dc:identifier>
</item>
<item>
<title>大叔学ML第五：逻辑回归 - 会长</title>
<link>http://www.cnblogs.com/zzy0471/p/logicregression.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zzy0471/p/logicregression.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;基本形式&quot;&gt;基本形式&lt;/h2&gt;
&lt;p&gt;逻辑回归是最常用的分类模型，在线性回归基础之上扩展而来，是一种广义线性回归。下面举例说明什么是逻辑回归：假设我们有样本如下（是我编程生成的数据）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zybuluo.com/zzy0471/mf9lql4ayj303e1fi3f3r6po/image.png&quot; alt=&quot;image.png-9.7kB&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们要做的是找到一个决策边界，把两类样本给分开，当有新数据进来时，就判断它在决策边界的哪一边。设边界线为线性函数&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[h_\theta(\vec x) = \theta_0 + \theta_1x_1 + \theta_2x_2 \tag {1}\]&lt;/span&gt;取0时的直线，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zybuluo.com/zzy0471/rj40mytyqpu0xui8rl83aax5/image.png&quot; alt=&quot;image.png-12.4kB&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们的目标就是根据已知的样本来确定&lt;span class=&quot;math inline&quot;&gt;\(\vec\theta\)&lt;/span&gt;取值&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;上图中，处在边界线左边的为负例（带入（1）式结果小于0），边界线右边的为正例（带入（1）式结果大于0）。&lt;strong&gt;从概率的角度考虑&lt;/strong&gt;：把一个点代入（1）式，如果为正，且越大越离边界线远，它是正例的概率就越大，直到接近1；相反，把一个点代入（1）式，如果为负，且越小离边界线越远，它是正例的概率就越小，直到接近0；此外，把一个点代入（1）式，如果结果正好等于0，那么它在边界线上，为正例和为负例的概率都是0.5。&lt;/p&gt;
&lt;p&gt;为了用数学的方式精确表达上面的概率论述，前人找到一个好用的函数：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[s(z) = \frac{1}{1+e^{-z}} \tag{2}\]&lt;/span&gt;&lt;br/&gt;这个函数叫做&lt;code&gt;sigmoid&lt;/code&gt;（sigmoid：S形状的）函数（下文用S(z)或s(z)表示sigmoid函数），样子如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zybuluo.com/zzy0471/hhk5uzpdkpdr1qy61vlw32cw/image.png&quot; alt=&quot;image.png-11kB&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当&lt;span class=&quot;math inline&quot;&gt;\(z=0\)&lt;/span&gt;时，函数值为0.5，当&lt;span class=&quot;math inline&quot;&gt;\(z &amp;gt; 0\)&lt;/span&gt;时，函数取值&lt;span class=&quot;math inline&quot;&gt;\((0.5, 1)\)&lt;/span&gt;；当&lt;span class=&quot;math inline&quot;&gt;\(z &amp;lt; 0\)&lt;/span&gt;时，函数取值&lt;span class=&quot;math inline&quot;&gt;\((0, 0.5)\)&lt;/span&gt;，如果我们把欲判断点代入决策边界（1）式后得到的结果作为&lt;code&gt;sigmoid&lt;/code&gt;函数的输入，那么输出就可以表示该点是正例的概率，简直完美。其实S型的函数应该还有别的，为什么前人独爱这个呢？那是因为，这个函求导比较简单，用链式法则可以非常容易算出其导数式为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\frac{d}{z}s(z)=s(z)(1 - s(z)) \tag{3}\]&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;simgiod函数求导过程：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\begin{align}\frac{d}{z}s(z)&amp;amp;=-\frac{1}{(1+e^{-z})^2}\cdot e^{-z} \cdot -1 \\ &amp;amp;=\frac{e^{-z}}{(1+e^{-z})^2}\\ &amp;amp;=\frac{1+e^{-z}-1}{(1+e^{-z})^2}\\ &amp;amp;=\frac{1+e^{-z}}{(1+e^{-z})^2} - \frac{1}{(1+e^{-z})^2}\\ &amp;amp;=s(z) - s(z)^2\\ &amp;amp;=s(z)(1-s(z)) \end{align}\]&lt;/span&gt;&lt;br/&gt;第一步用了链式法则。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;代价函数&quot;&gt;代价函数&lt;/h2&gt;
&lt;p&gt;逻辑回归的代价函数可由极大似然估计法得出。我们暂且不管极大似然估计法的证明，直观地理解非常容易：如果你是一个班级的新老师，发现有个孩子考了95.5分，你肯定会认为这个孩子很可能是学霸，虽然学霸有时也会考低分，学渣有时也考高分，但是发生概率很小。更一般的叙述是：有若干事件A、B和C，已知其发生概率为分别为&lt;span class=&quot;math inline&quot;&gt;\(P(A|\theta)\)&lt;/span&gt;、&lt;span class=&quot;math inline&quot;&gt;\(P(B|\theta)\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(P(C|\theta)\)&lt;/span&gt;，如果我们观察到A、B和C已经发生了，那么我们就认为&lt;span class=&quot;math inline&quot;&gt;\(P(ABC|\theta)\)&lt;/span&gt;是个尽可能大的值，如果我们要求&lt;span class=&quot;math inline&quot;&gt;\(\theta\)&lt;/span&gt;，那么&lt;span class=&quot;math inline&quot;&gt;\(\theta\)&lt;/span&gt;应该是使得&lt;span class=&quot;math inline&quot;&gt;\(P(ABC|\theta)\)&lt;/span&gt;最大的那个值。如果A、B和C互相独立，我们所求的就是使得&lt;span class=&quot;math inline&quot;&gt;\(P(A|\theta)P(B|\theta)P(C|\theta)\)&lt;/span&gt;最大化的&lt;span class=&quot;math inline&quot;&gt;\(\theta\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;设&lt;span class=&quot;math inline&quot;&gt;\(t_\theta(\vec x)=s(h_\theta(\vec x))\)&lt;/span&gt;已知：&lt;span class=&quot;math display&quot;&gt;\[P(Y=y) = \begin{cases} t_\theta(\vec x), &amp;amp;\text{如果 y = 1} \\ 1 - t_\theta(\vec x), &amp;amp;\text{如果 y = 0} \end{cases}\]&lt;/span&gt;，写到一起：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[P(Y=y)=t_\theta(\vec x)^y(1-t_\theta(\vec x))^{1-y} \tag{4}\]&lt;/span&gt;，根据（4）式写出极大似然函数：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[l(\vec\theta)=\prod_{i=1}^mt_\theta(\vec x^{(i)})^{y^{(i)}}(1-t_\theta(\vec x^{(i)}))^{1-y^{(i)}} \]&lt;/span&gt;，设代价函数&lt;span class=&quot;math display&quot;&gt;\[j(\vec\theta)=-\frac{1}{m}\ln l(\vec\theta)\]&lt;/span&gt; ，最大化&lt;span class=&quot;math inline&quot;&gt;\(l(\vec\theta)\)&lt;/span&gt;即最小化&lt;span class=&quot;math inline&quot;&gt;\(j(\vec\theta)\)&lt;/span&gt;。求对数是为了方便计算，把乘法转换为加法，把幂运算转换为乘法，单调性不变；前面的负号是为了把求最大值问题转换为求最小值问题，习惯上，应用梯度下降法时都是求最小值，不然叫“梯度上升了法”了，手动滑稽。当然，使用梯度下降法的前提条件是函数是凸的，大叔懒得证明了，这个函数就是个凸函数，不管你们信不信，我反正是信了。进一步对上式化解得：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[j(\vec\theta)=-\frac{1}{m}\sum_{i=1}^m\left[y^{(i)}\ln t_\theta(\vec x^{(i)}) + (1-y^{(i)})\ln(1-t_\theta(\vec x^{(i)}))\right] \tag{5}\]&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;用梯度下降法求vectheta&quot;&gt;用梯度下降法求&lt;span class=&quot;math inline&quot;&gt;\(\vec\theta\)&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;将（5）式对&lt;span class=&quot;math inline&quot;&gt;\(\vec\theta\)&lt;/span&gt;求偏导：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(\frac{\partial}{\partial\theta_0}j(\vec\theta)=\frac{1}{m}\sum_{i=1}^m(t_\theta(\vec x^{(i)})-y^{(i)})x_0^{(i)}\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(\frac{\partial}{\partial\theta_1}j(\vec\theta)=\frac{1}{m}\sum_{i=1}^m(t_\theta(\vec x^{(i)})-y^{(i)})x_1^{(i)}\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(\cdots\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(\frac{\partial}{\partial\theta_n}j(\vec\theta)=\frac{1}{m}\sum_{i=1}^m(t_\theta(\vec x^{(i)})-y^{(i)})x_n^{(i)}\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果读者对矩阵计算非常熟悉的话，应该可以看出，上式可以写成矩阵形式，这样计算更方便：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\frac{\partial}{\partial\vec\theta}=\frac{1}{m}X^T(T-Y)，其中，T=\begin{pmatrix}t_\theta(\vec x^{(1)})\\ t_\theta(\vec x^{(2)})\\ \vdots \\ t_\theta(\vec x^{(m)}) \end{pmatrix}\]&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;对&lt;span class=&quot;math inline&quot;&gt;\(j(\vec\theta)\)&lt;/span&gt;求导的过程如下，多次应用链式法则即可：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\begin{align} \frac{\partial}{\partial\theta_n}j(\vec\theta)&amp;amp;=-\frac{1}{m}\sum_{i=1}^m\left[y^{(i)}\frac{1}{t_\theta(\vec x^{(i)})}t_\theta(\vec x)^\prime+(1-y^{(i)})\frac{1}{1-t_\theta(\vec x^{(i)})}t_\theta(\vec x)^\prime\right]\\ &amp;amp;=-\frac{1}{m}\sum_{i=1}^m\left[y^{(i)}\frac{1}{t_\theta(\vec x^{(i)})}t_\theta(\vec x^{(i)})(1-t_\theta(\vec x^{(i)}))h_\theta(\vec x)^\prime+(1-y^{(i)})\frac{1}{1-t_\theta(\vec x^{(i)})}t_\theta(\vec x^{(i)})(t_\theta(\vec x^{(i)}) - 1)h_\theta(\vec x)^\prime\right]\\ &amp;amp;=-\frac{1}{m}\sum_{i=1}^m\left[y^{(i)}(1-t_\theta(\vec x^{(i)}))h_\theta(\vec x)^\prime + (y^{(i)})t_\theta(\vec x^{(i)} - 1)h_\theta(\vec x)^\prime\right]\\ &amp;amp;=-\frac{1}{m}\sum_{i=1}^m\left[y^{(i)}(1-t_\theta(\vec x^{(i)}))x_n^{(i)} + (y^{(i)})t_\theta(\vec x^{(i)} - 1)x_n^{(i)}\right]\\ &amp;amp;=-\frac{1}{m}\sum_{i=1}^m(y^{(i)} - t_\theta(\vec x^{(i)}))x_n^{(i)}\\ &amp;amp;=\frac{1}{m}\sum_{i=1}^m(t_\theta(\vec x^{(i)}) - y^{(i)})x_n^{(i)} \end{align}\]&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;步骤1用到到了公式：&lt;span class=&quot;math inline&quot;&gt;\(\ln x^\prime = \frac{1}{x}\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;步骤2用到式（3）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;有了偏导式后就可以编程了：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import matplotlib.pyplot as plt
import numpy as np

def sigmoid(z):
    return 1 / (1 + np.e**(-z))

def draw_samples(X, Y, sample_count):
    ''' 绘制正负例. '''
    positiveX1 = []
    positiveX2 = []

    negativeX1 = []
    negativeX2 = []

    for i in range(sample_count):
        if Y[i, 0] == 1:
            positiveX1.append(X[i, 0])
            positiveX2.append(X[i, 1])
        else:
            negativeX1.append(X[i, 0])
            negativeX2.append(X[i, 1])
    
    plt.scatter(positiveX1, positiveX2, marker='+')
    plt.scatter(negativeX1, negativeX2, marker='.')

def draw_border(theta):
    '''绘制边界线'''
    X = []
    Y = []
    for x in range(-2, 12):
        X.append(x)
        Y.append(-theta[0] / theta[2] - theta[1] / theta[2] * x )
    plt.plot(X, Y)

def create_samples(samples_count):
    ''' 生成样本数据'''
    X = np.empty((samples_count, 2))
    Y = np.empty((samples_count, 1))

    for i in range(samples_count):
        x1 = np.random.randint(0, 10)
        x2 = np.random.randint(0, 10)
        y = 0
        if x1 + x2 - 10 &amp;gt; 0:
            y =1
        X[i, 0] = x1
        X[i, 1] = x2
        Y[i, 0] = y

        noise = np.random.normal(0, 0.1, (samples_count, 2))
        X += noise
    return X, Y

def grad(X, Y, samples_count, theta):
    ''' 求代价函数在theta处的梯度. '''
    T = sigmoid(np.dot(X, theta))
    g =  np.dot(X.T, (T - Y)) / samples_count
    return g

def descend(X, Y, samples_count, theta = np.array([[1],[1],[1]]), step = 0.01, threshold = 0.05):
    ''' 梯度下降.
        Args: 
            X: 样本
            Y：样本标记
            theta：初始值
            step：步长
            threshold：阈值
        Returns:
            theta：求出来的最优theta
    '''
    g = grad(X, Y, samples_count, theta)
    norm = np.linalg.norm(g)

    while norm &amp;gt; threshold:
        g = grad(X, Y, samples_count, theta)
        norm = np.linalg.norm(g)
        theta = theta - g * step
        print(norm)

    return theta

samples_count = 100
X, Y = create_samples(samples_count)
MatrixOnes = np.ones((100, 1))
X_with_noes = np.hstack((MatrixOnes, X)) # 添加等于1的x0
theta = descend(X_with_noes, Y, samples_count)

plt.xlabel('$x_1$')
plt.ylabel('$x_2$')

draw_samples(X, Y, samples_count)
draw_border(theta.flatten())
plt.show()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;br/&gt;&lt;img src=&quot;http://static.zybuluo.com/zzy0471/ser00rqcrpndqbkj4gch9aua/image.png&quot; alt=&quot;image.png-14.9kB&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面的代码中，我在样本矩阵中增加了一列为1的元素，这样做是为了计算方便，使得样本矩阵的列数等于欲求&lt;span class=&quot;math inline&quot;&gt;\(\vec\theta\)&lt;/span&gt;的行数，满足矩阵乘法的要求，加上这一列对结果没有影响，请参考&lt;a href=&quot;https://www.cnblogs.com/zzy0471/p/linear_regression.html&quot;&gt;大叔学ML第二：线性回归&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;扩展&quot;&gt;扩展&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;和线性回归一样，逻辑回归也存在过拟合的情况，可以通过添加一范数、二范数正则化来解决&lt;/li&gt;
&lt;li&gt;和线性回归一样，逻辑回归的决策边界可以是曲折的多项式，可参考&lt;a href=&quot;https://www.cnblogs.com/zzy0471/p/polynomial_regression.html&quot;&gt;大叔学ML第三：多项式回归&lt;/a&gt;，依葫芦画瓢来搞定决曲折的决策边界&lt;/li&gt;
&lt;li&gt;和线性回归一样，逻辑回归也可以扩展到多余3维的情况，只是不可以做可视化了，代数原理是一致的&lt;/li&gt;
&lt;li&gt;和线性回归不一样，逻辑回归&lt;strong&gt;应该&lt;/strong&gt;没有“正规方程”，大叔昨天按照线性回归的正规方程的推导思路推导并未得出结果，查资料也未果&lt;/li&gt;
&lt;li&gt;除了梯度下降法，牛顿法和拟牛顿法也是迭代下降算法，而且下降效率更好，大叔稍后将会写一篇博文介绍之&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;祝元旦快乐！&lt;/p&gt;
</description>
<pubDate>Sun, 30 Dec 2018 03:57:00 +0000</pubDate>
<dc:creator>会长</dc:creator>
<og:description>元旦佳节大叔总结了逻辑回归最为基础的知识，帮助自己和园友加深对逻辑回归的理解，同时，也希望园里的高人指点一二，谢谢！</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zzy0471/p/logicregression.html</dc:identifier>
</item>
<item>
<title>我的2018年终总结 - 只喝牛奶的杀手</title>
<link>http://www.cnblogs.com/viaiu/p/10198913.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/viaiu/p/10198913.html</guid>
<description>&lt;p class=&quot;p&quot; align=&quot;justify&quot;&gt;&lt;span&gt;燕子去了，有再来的时候；杨柳枯了，有再青的时候；桃花谢了，有再开的时候。但是，聪明的，你告诉我，我们的日子为什么一去不复返呢？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2018也就过去了，为什么要去总结？总结是为了更好的出发。只要用心写，总会有所获的；我还是很俗的从三个方面去总结一下自己，学习，生活和工作。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;&lt;strong&gt;关于学习&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;马上毕业五年了，尤其是今年特别意识到学习的重要性，工作即使再忙，加班即使再多，也要去学习，我们十八般武艺会了几样？过去自己一直停留在应用层，原理性的东西可能只会看那么一点点，第一次感觉异步编排，&lt;/span&gt;Fork/Join等这些东西这么好玩。今年逐渐在看一些计算机基础一些东西，希望自己不要在浮沙筑高层，沉下来，多学习，弥补一下自己拉下的东西；不要吹牛逼，把一些原理的东西，搞明白；渐渐的觉得某些架构，就是根据计算机的一些基础理论演化而来的，年终的时候，有个大神，建议多看看一些论文，像谷歌三大论文之类的一定要看。学习是没有捷径的，是逆人性的，你需要长期地付出时间和精力。坚持学习是一件更逆人性的东西。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;&lt;strong&gt;关于生活&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;关于生活，想对它说声对不起，因为加班占据了自己很多时间，今年基本上没出去玩过，出去玩过两次，一次是乌镇，一次是迪士尼；好长时间没去运动过，健身卡被搁置了很久，加班熬夜，曾经爱运动的那个大男孩哪去了？加班胖越来越严重。平时到家，对象基本上准备睡了，希望明年能够早点回家，不让对象跟着自己晚睡了。一年没有回家，没怎么陪家人。当然我们有时候的躁动，也是对自己有一种&lt;/span&gt;“恨铁不成钢”的感觉，学会对自己和解。生活就像打怪升级一样，我们要主动去提高我们打怪升级的能力。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;&lt;strong&gt;关于工作&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;工作上有时候不会克制自己的情绪，因为加班过多，导致有时候自己的情绪很差，会很烦，希望以后管理好自己的情绪；因为有时候对别人发火，并不是对这个有情绪，其实有一种&lt;/span&gt;“恨铁不成钢”的感觉。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;其实自己也不是什么钢？工作上整理了一些东西，让下面的人少走弯路；当然也有不少问题，代码规范，幂等性，事物，安全等一些问题层出不穷，当然没做到预知，只是出问题了，才去找问题。希望以后的问题能扼杀在测试环境上。关于团队，多交给他们一些工作上解决问题的套路，放手让他们干，自己看过程和结果。自己越来越解放出来，干一些更重要的事情。希望工作上再提高自己的效率，提高整个&lt;/span&gt;Team的效率，多去思考；最后问大家一个问题，加班和奋斗是什么关系？&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;&lt;span&gt;给朋友聊的时候，当你五年后或者十年后依然对技术、工作和生活保持热情和激情，你就会一个&lt;/span&gt;“大牛”，这样的人会有百分之二十吗？现在我的一些童鞋，做技术的已经对技术麻木了，就是钱了，不管技术，希望我们被生活蹂躏之后，归来依然是个少年，学习上继续实事求是，生活上做一个真实的人，工作上做一个敢说真话的人。永远相信越来越好，相信未来。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;2019希望有几件事能做好&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1，把那谁谁娶了&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2，加深对业务的理解，梳理；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3，多做一中间件，熟练一门脚本语言，提高大家开发效率&lt;/span&gt;&lt;br/&gt;&lt;span&gt;4，继续提高开发效率&lt;/span&gt;&lt;br/&gt;&lt;span&gt;5，多看书，保持输出，多锻炼身体，有时间就带着那谁多出去耍耍&lt;/span&gt;&lt;br/&gt;&lt;span&gt;6，考证&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;strong&gt;&lt;em&gt;&lt;span&gt;&lt;span&gt;竹杖芒鞋轻胜马，谁怕？一蓑烟雨任平生，&lt;/span&gt;2019，加油！&lt;/span&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/810680/201812/810680-20181230114852605-613645943.jpg&quot; alt=&quot;&quot; width=&quot;607&quot; height=&quot;596&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 30 Dec 2018 03:54:00 +0000</pubDate>
<dc:creator>只喝牛奶的杀手</dc:creator>
<og:description>2018也就过去了，为什么要去总结？总结是为了更好的出发。只要用心写，总会有所获的……</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/viaiu/p/10198913.html</dc:identifier>
</item>
<item>
<title>一个数据仓库时代开始--Hive - 隐峯</title>
<link>http://www.cnblogs.com/TFengStorm/p/10198853.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/TFengStorm/p/10198853.html</guid>
<description>&lt;h3 id=&quot;一什么是-apache-hive&quot;&gt;一、什么是 Apache Hive？&lt;/h3&gt;
&lt;p&gt;Apache Hive 是一个基于 Hadoop Haused 构建的开源数据仓库系统，我们使用它来查询和分析存储在 Hadoop 文件中的大型数据集。此外，通过使用 Hive，我们可以在 Hadoop 中处理结构化和半结构化数据。&lt;/p&gt;
&lt;p&gt;换句话说，Hive 是一个数据仓库基础设施，便于查询和管理驻留在分布式存储系统中的大型数据集。它提供了一种类 SQL 的查询语言 HiveQL（Hive Query Language）查询数据的方法。 此外，编译器在内部将 HiveQL 语句转换为 MapReduce、Tez、Spark 等作业。进一步提交给 Hadoop 框架执行。&lt;/p&gt;
&lt;h3 id=&quot;二我们为什么要使用-hive-技术&quot;&gt;二、我们为什么要使用 Hive 技术？&lt;/h3&gt;
&lt;p&gt;随着 Hadoop MapReduce 的出现，极大的简化大数据编程的难度，使得普通程序员也能从事开发大数据编程。但在生产活动中经常要对大数据计算分析是从事商务智能行业（BI）的工程师，他们通常使用 SQL 语言进行大数据统计以及分析，而 Mapreduce 编程是有一定的门槛，如果每次都采用 MapReduce 开发计算分析，这样成本就太高效率太低，那么有没有更简单的办法，可以直接通过 SQL 在大数据平台下运行进行统计分析？有的，答案即是 Hive。&lt;/p&gt;
&lt;p&gt;Hive 主要用于数据查询，统计和分析，提高开发人员的工作效率。Hive 通过内置函数将 SQL 语句生成 DAG（有向无环图），再让 Mapreduce 计算处理。从而得到我们想要的统计结果。而且在处理具有挑战性的复杂分析处理和数据格式时，极大的简化了开发难度。&lt;/p&gt;
&lt;h3 id=&quot;三hive-架构&quot;&gt;三、Hive 架构&lt;/h3&gt;
&lt;p&gt;Hive 能够直接处理我们输入的 HiveQL 语句，调用 MapReduce 计算框架完成数据分析操作。下面是它的架构图，我们结合架构图来看看 Hive 到 MapReduce 整个流程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/roPWrjQ5nUGGflrorReFFXkdgsBBDKNjp6MDftEEsr0rJ28OAbJcrlZ689SDu960AkA76z4Wsia64TiadxS1A3OA/640?wx_fmt=png&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由上图可知，HDFS 和 Mapreduce 是 Hive 架构的根基。Hive 架构主要分为以下几个组件：Client、Metastore、Thrift Server、Driver，下面是各个组件介绍：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Client：&lt;/strong&gt;用户接口组件主要包含 CLI（命令行接口）、JDBC 或 ODBC、WEB GUI（以浏览器访问 Hive）；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Metastore组件：&lt;/strong&gt;元数据服务组件， 记录表名、字段名、字段类型、关联 HDFS 文件路径等这些数据库的元数据信息；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Driver（执行引擎）：&lt;/strong&gt;包括 Complier 、Optimizer 和 Executor，它们的作用是将 HiveQL 语句进行语法分析、语法解析、语法优化，生成执行计划，然后提交给 Hadoop MapReduce 计算框架处理；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Thrift Server：&lt;/strong&gt;Thrift 是 FaceBook 开发的一个软件框架，它用来进行可扩展且跨语言的服务的开发， 通过该服务使不同编程语言调用 Hive 的接口。&lt;/p&gt;
&lt;p&gt;我们通过 CLI 向 Hive 提交 SQL 命令，如果 SQL 是创建数据表的 DDL，Hive 会通过 执行引擎 Driver 将数据表元数据信息存储 Metastore 中，而如果 SQL 是查询分析数据的 DQL，通过 Complier 、Optimizer 和 Executor 进行语法分析、语法解析、语法优化操作，生成执行计划生成一个 MapReduce 的作业，提交给 Hadoop MapReduce 计算框架处理。&lt;/p&gt;
&lt;p&gt;到此 Hive 的整个流程就结束了，相信你对 Hive 的整个流程已经有基本了解。接下来我们探讨一条 SQL 在 MapReduce 是如何统计分析。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;四、SQL如何在Mapreduce执行&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1552768/201812/1552768-20181224104124466-1831801687.png&quot;/&gt;&lt;br/&gt;左边是数据表，右边是结果表，这条 SQL 语句对 age 分组求和，得到右边的结果表，到底一条简单的 SQL 在 MapReduce 是如何被计算， MapReduce 编程模型只包含 map 和 reduce 两个过程，map 是对数据的划分，reduce 负责对 map 的结果进行汇总。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select id,age,count(1) from student_info group by age&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先看 map 函数的输入的 key 和 value，输入主要看 value，value 就是 user_info 表的每一行数据，输入的 value 作为map函数输出的 key，输出的 value 固定为 1，比如&amp;lt;&amp;lt;1,17&amp;gt;,1&amp;gt;。 map 函数的输出经过 shuffle 处理，shuffle 把相同的 key 以及对应的 value 组合成新&amp;lt;key,value集合&amp;gt;，从 user_info 表看出map输出 2 次&amp;lt;&amp;lt;1,17&amp;gt;,1&amp;gt;，那么经过 shuffle 处理后则会输出&amp;lt;&amp;lt;1,17&amp;gt;,&amp;lt;1,1&amp;gt;&amp;gt;，并将输出作为 reduce 函数的输入。&lt;/p&gt;
&lt;p&gt;在 reduce 函数会把所有 value 进行相加后输出结果，&amp;lt;&amp;lt;1,17&amp;gt;,&amp;lt;1,1&amp;gt;&amp;gt;输出为&amp;lt;&amp;lt;1,17&amp;gt;,2&amp;gt;。 这就是一条简单 SQL 在 Mapreduce 执行过程，可能你会有点迷糊，在这里我画了一张流程图，结合流程图你会更加清楚。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1552768/201812/1552768-20181224104147141-207220312.png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;五、Hive 和 RDBMS 之间的区别&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;说到 Hive 跟 RDBMS（传统关系型数据库）相比有哪些区别，很多人可能还是说不清楚，在这里我总结一下关于 Hive 和 RDBMS 之间的区别。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、&lt;/strong&gt;Hive 支持部分 SQL 语法，跟标准 SQL 有一定区别。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、&lt;/strong&gt;传统的数据库在写入数据会严格检验数据格式，对于这种我们成为读时模式，而 Hive 是在查询数据时验证数据，这种验证我们称为写时模式，而且由于每次都是扫描整个表导致高延时；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、&lt;/strong&gt;Hive 是在 Hadoop 上运行的，通常而言 Hive 时一次写入多次读取，而 RDBMS 则是多次读写；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、&lt;/strong&gt;Hive 视图是逻辑存在，而且只读，不接受 LOAD/INSERT/ALTER，而 RDBMS 视图根据表变化而变化；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5、&lt;/strong&gt;Hive 支持多表插入而 RDBMS 是不支持，而且 Hive 对子查询有严格要求，有许多子查询是不支持；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6、&lt;/strong&gt;早期 Hive 只支持 INSERT OVERWRITE\INTO TABLE 插入数据，从 0.14.0 开始支持 INSERT INTO ... VALUE 语句按行添加数据，另外 UPDATE 和 DELETE 也允许被执行；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;7、&lt;/strong&gt;在 Hive 0.7.0 之后 Hive 是支持索引的，只是它跟 RDBMS 不一样，比如它不支持主键和外键，而是支持在某些列上建立索引，以提高 Hive 表指定列的查询速度（但是效果差强人意）；&lt;/p&gt;
&lt;p&gt;其实对于更新、事物和索引，一开始 Hive 是不支持的，因为这样非常影响性能，不符合当初数据仓库的设计，不过后来不断的发展，也不得不妥协，这也导致 Hive 和 RDBMS 在形式上更加相识。&lt;/p&gt;
&lt;p&gt;相信看完这些大家已经对它们之间区别有了一些理解，在这里我还贴出一张表格，你可以对照表格加深印象。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;ANSI SQL&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;不完全支持&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;更新&lt;/td&gt;
&lt;td&gt;UPDATE\INSERT\DELETE&lt;/td&gt;
&lt;td&gt;UPDATE\INSERT\DELETE（0.14.0之后）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;模式&lt;/td&gt;
&lt;td&gt;读时模式&lt;/td&gt;
&lt;td&gt;写时模式&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;数据保存&lt;/td&gt;
&lt;td&gt;磁盘&lt;/td&gt;
&lt;td&gt;HDFS&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;延时&lt;/td&gt;
&lt;td&gt;低&lt;/td&gt;
&lt;td&gt;高&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;多表插入&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;子查询&lt;/td&gt;
&lt;td&gt;完全支持&lt;/td&gt;
&lt;td&gt;支持 From 子句&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;视图&lt;/td&gt;
&lt;td&gt;Updatable&lt;/td&gt;
&lt;td&gt;Read-only&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;索引&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;支持表列(0.7.0之后)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;可扩展性&lt;/td&gt;
&lt;td&gt;低&lt;/td&gt;
&lt;td&gt;高&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;数据规模&lt;/td&gt;
&lt;td&gt;小&lt;/td&gt;
&lt;td&gt;大&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;读写&lt;/td&gt;
&lt;td&gt;一次写入多次读取&lt;/td&gt;
&lt;td&gt;多次读写&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;分析&lt;/td&gt;
&lt;td&gt;OLTP&lt;/td&gt;
&lt;td&gt;OLAP&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;执行&lt;/td&gt;
&lt;td&gt;Excutor&lt;/td&gt;
&lt;td&gt;MapReduced、Spark等&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在实际生产过程中，其实我们不会经常编写 MapReduce 程序，起初在网站的大数据分析基本是通过 SQL 进的，也因此 Hive 在大数据中扮演着非常重要作用。随着 Hive 的普及，我们希望更多的大数据应用场景中使用 SQL 语句进行分析，于是现在越来越多的大数据 SQL 引擎被开发出来。在我看来无论是 Cloudera 的 Impala，还是后来的 Spark ，对大数据中使用 SQL需求越来迫切， 对大数据 SQL 应用场景更多样化，我们只需要通过 SQL 语句就可以轻易得到我们想要的结果。最后说一点，在这些 SQL 引擎基本都是支持类 SQL 语言，但并不像数据库那样支持那样标准 SQL，特别是 Hive 等数据仓库几乎必然会用到嵌套查询 SQL，也就是在 where 条件嵌套 select 子查询，但是几乎所有的大数据 SQL 引擎都不支持。&lt;/p&gt;
</description>
<pubDate>Sun, 30 Dec 2018 03:31:00 +0000</pubDate>
<dc:creator>隐峯</dc:creator>
<og:description>一、什么是 Apache Hive？ Apache Hive 是一个基于 Hadoop Haused 构建的开源数据仓库系统，我们使用它来查询和分析存储在 Hadoop 文件中的大型数据集。此外，通过</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/TFengStorm/p/10198853.html</dc:identifier>
</item>
</channel>
</rss>