<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>kali渗透综合靶机(一)--Lazysysadmin靶机 - 雨中落叶</title>
<link>http://www.cnblogs.com/yuzly/p/10800861.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuzly/p/10800861.html</guid>
<description>&lt;p&gt;&lt;span&gt;kali渗透综合靶机(一)--Lazysysadmin靶机&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Lazysysadmin靶机百度云下载&lt;br data-filtered=&quot;filtered&quot;/&gt;
链接：&lt;a href=&quot;https://pan.baidu.com/s/1pTg38wf3oWQlKNUaT-s7qQ&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;https://pan.baidu.com/s/1pTg38wf3oWQlKNUaT-s7qQ&lt;/a&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;
提取码：q6zo&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一、主机发现(nmap/netdiscover)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;netdiscover -i eth0 -r 192.168.10.0/24&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201905/1592114-20190501212429058-2137009786.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;nmap 192.168.10.0/24 -sn&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201905/1592114-20190501212447991-1759668827.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、端口扫描(masscan/nmap)&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;根据上面主机发现得到的主机,然后依次对每个主机进行快速端口扫描,分析得到自己要攻击的目标主机&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;masscan 192.168.10.152 -p 0-65535 --rate=10000&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201905/1592114-20190501212521951-207048866.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;三、识别端口上对应的服务&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;获取自己要攻击的目标主机上的端口之后,对开放的端口进行对应的服务识别&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201905/1592114-20190501212559009-152104986.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;四、发现服务对应的漏洞并利用&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.首先从ssh服务入手,尝试暴力破解ssh&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.1使用msf的auxiliary/scanner/ssh/ssh_login模块，爆破ssh&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201905/1592114-20190501212618593-278628342.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.2设置参数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201905/1592114-20190501212634719-705116488.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.3开始攻击,下图可以看到成功爆破出用户名密码&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201905/1592114-20190501212651425-188461469.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;尝试使用ssh服务登陆这个用户，成功登陆,查看用户所属组,此用户属于sudo组,具有管理员权限&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201905/1592114-20190501212708149-635321929.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用sudo su root切换到root账户&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201905/1592114-20190501212736060-1099064278.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 目标开启apache服务，在网页中尝试web渗透&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.1通过浏览器访问http://192.168.10.152 , 分析整个网页,发现没有什么可以利用的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201905/1592114-20190501212755876-855978007.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.2利用目录扫描工具(dirb),扫描对应网站的目录&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201905/1592114-20190501212813690-736296700.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.3对扫描出来的目录进行分析&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;扫描出来info.php文件，浏览器访问,下图可以看到目标存在信息泄露漏洞&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201905/1592114-20190501212832430-2115896729.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;扫描出来/phpmyadmin/目录，浏览器访问,可以看到是mysql的后台登录界面,尝试弱口令或者暴力破解&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201905/1592114-20190501212851308-560114012.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;扫描发现wordpress ,浏览器访问，发现其中含有疑似用户名的信息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201905/1592114-20190501212914162-1794224515.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;尝试登录wordpress的默认后台管理页面wp-login.php&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201905/1592114-20190501212932995-698100717.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;尝试输入一些简单的弱口令,提示如下错误信息,发现用户名是admin,此处存在用户名名枚举漏洞,然后尝试暴力破解密码&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201905/1592114-20190501212952439-274085929.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用wpscan扫描&lt;a href=&quot;http://192.168.136.130/wordpress&quot;&gt;http://192.168.136.130/wordpress&lt;/a&gt; 看是否含有漏洞&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; Vp 只枚举有漏洞的插件，vt只枚举存在漏洞的主题，tt列举缩略图相关的文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.&lt;/strong&gt;&lt;strong&gt;尝试从samba服务发现漏洞&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用enum4linux枚举运行samba的主机信息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;enum4linux 192.168.10.152&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;扫描完成后发现存在共享目录，允许空口令&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201905/1592114-20190501213056469-1664365373.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以远程挂载，查看共享目录,发现共享的是网站的根目录&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;mount -t cifs -o username='',password='' //192.168.10.152/share$ /mnt&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201905/1592114-20190501213113442-2094311446.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;或者在windows访问共享&lt;/span&gt;　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201905/1592114-20190501215214410-1187282993.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Cd到wordpress目录,查看配置文件,可以看到wordpress后台的用户名以及密码&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201905/1592114-20190501213130976-758594301.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用得到用户名与密码尝试登录phpmyadmin,成功登录进去&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;尝试查看数据,发现此账户对数据库没有任何权限&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201905/1592114-20190501213146953-730171765.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;尝试用数据库的用户名密码登录wordpress后台,成功登录&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;可以在一个404页面中添加一句话木马留后门,上传这个404页面&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201905/1592114-20190501213204279-668419140.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在浏览器访问一个不存在的页面,可以看到跳转到404页面,这时也就执行了插入其中的一句话木马&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201905/1592114-20190501213222272-1267700133.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;打开菜刀工具,连接url, 成功反弹shell&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201905/1592114-20190501213238430-1563518100.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; 总结：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.信息收集&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.dirb目录爆破&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.ssh爆破&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.wpscan扫描wordpress漏洞&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.文件共享信息泄露&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6.进入后台，Appearance页面404.php挂马，菜刀连接，反弹shell&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 01 May 2019 15:57:00 +0000</pubDate>
<dc:creator>雨中落叶</dc:creator>
<og:description>kali渗透综合靶机(一)--Lazysysadmin靶机 Lazysysadmin靶机百度云下载链接：https://pan.baidu.com/s/1pTg38wf3oWQlKNUaT-s7qQ提</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuzly/p/10800861.html</dc:identifier>
</item>
<item>
<title>大白话5分钟带你走进人工智能-第二十节逻辑回归和Softmax多分类问题(5) - LHBlog</title>
<link>http://www.cnblogs.com/LHWorldBlog/p/10801253.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/LHWorldBlog/p/10801253.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;                                                    大白话5分钟带你走进人工智能-第二十节逻辑回归和Softmax多分类问题(5)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上一节中，我们讲解了逻辑回归的优化，本节的话我们讲解逻辑回归做多分类问题以及传统的多分类问题，我们用什么手段解决。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;先看一个场景，假如我们现在的数据集有3个类别，我们想通过逻辑回归建模给它区分出来。但我们知道逻辑回归本质上是区分二分类的算法模型。难道没有解决办法了吗？办法还是有的，既然想分出3类，我们姑且称这3个类别号为0,1,2。想通过逻辑回归做二分类的话，那么我们就分别判断每一条样本数据属不属于0号类别，属不属于1号类别，属不属于2号类别去判断，这样相当于建立3个逻辑回归的模型，分别训练，既照顾了逻辑回归二分类的本质，也照顾了多分类的需求。假如我们训练出来的3个模型， 第一个模型判断是不是1号类别的概率是0.8  第二个模型判断是不是2号类别的概率是0.1  第三个模型判断是不是3号类别的概率是 0.6 ，综合来看0.8&amp;gt;0.6&amp;gt;0.1,所以我们对这条样本判别为1号类别。剩下的所有样本数据亦如此。这种用逻辑回归解决问题的方式就是&lt;strong&gt;OVR( ovr  one vs rest )&lt;/strong&gt;。这里问个问题，&lt;strong&gt;这三个模型判断出来各自的概率相加结果是1 吗？肯定不是。因为我们是对每个模型单独训练出来的。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;我们先总结一下OVR思路就是：1，修改数据的lable。2，然后训练N个逻辑回归模型。3，根据输出结果概率输出。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里需要注意一个问题就是&lt;strong&gt;样本不均衡的问题。&lt;/strong&gt;逻辑回归就怕样本不均衡，当负例比正例或者正列比负例多很多的时候，模型判断会不准确，&lt;strong&gt;逻辑回归，最喜欢的是1:1的正负例&lt;/strong&gt;。 因为假如有一个训练集只有一条正例，其它的全都是负例，那么哪怕把所有的条目都判断为负例，正确率还是99%。因为在训练过程中，我们是找了一组w带来总的预测正确率最高，但这样情况下当样本不均衡的时候就会对正例特别的不公平，因为它只追求总的预测正确率最高，不管是正例还是负例，都会对少的那一部分很不公平，它会着重的想把多的预测准确了，获得更大的收益，对它来说这个w是更好的w。所以当样本不均衡的时候不一定会不好，但是很有可能的模型会不稳定。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;怎么解决样本不均衡的问题？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;通常的办法是对多的进行降采样&lt;/strong&gt;。 比如说只有30%的正例，有70%是负例，第一对70%的负例里面进行一个降采样，不要全部的负例了。&lt;strong&gt;第二，创造一些新的正例样本，属性随机采样，就是说把正例样本的每个属性对应的值随机采取点出来，组合出一个新的正例样本来&lt;/strong&gt;，这样凡是涉及到人工创建的训练集通常不太好，但是它是没办法的办法，已经不均衡了，没有更多的训练集了。按理说用降采样，但是发现不光负例多，正例还特别少，才几十条正例这会这已经很难了，只要样本少，谁也帮不了，神仙也救不了，唯一能自救的方法就是重采样一下。适当的生成出一些新的训练集，但生成的东西并不一定能代表客观规律，这是没办法的事儿，确实少，也只能试一试。&lt;strong&gt;所以可以通过对少的样本进行重采样，通过对多的样本进行降采样，来一定程度上缓和我们样本不均衡的问题。&lt;/strong&gt;除此之外&lt;strong&gt;，使用决策树的方法。那么它对于样本不均衡，要比逻辑回归要坚固的多&lt;/strong&gt;，鲁棒性要好得多，所以换句话说，需要选择其它的算法来解决这个问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;除此之外，我们引入一种叫softmax的方式，它比OVR对样本不均衡的问题要稍好一些，而且它的分类效果更好。它其实就是一个跟逻辑回归类似的一个专门解决多分类的模型，它有自己的判别函数，也有自己的损失函数，是逻辑回归的一种拓展，&lt;strong&gt;逻辑回归是softmax的一种特例。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果现在只让用一个模型去判断一个5分类任务，这个模型要输出什么？至少得输出5个概率出来，才能判断。只输出两个概率，我怎么判断剩下3个？输出形式一定要出现5个概率。于是它特别简单，它就搞出了5组w，其实就有点神经网络的感觉了。神经网络我们还没讲，不过没关系，你先有个大体的概念。以后我们再会对神经网络里面softmax函数详细解释，因为它很重要。几乎可以说是任何多分类问题最后的一步。&lt;strong&gt;我们这里就直到softmax就是一个单层的神经网络就可以了，以下关于神经网络解释softmax的问题听不懂没关系，后面在神经网络里面会详细说的。&lt;/strong&gt;咱们说五分类，5组模型，W1，W2，W3，W4，W5，现在一个x扔进来之后，要同时交给每组W算出一个结果，得到了W1^Tx，W2^Tx，W3^Tx，W4^Tx，W5^Tx，接下来把得到的每一个结果概率化输出，为:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                                                &lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?%5Cfrac%7Be%5E%7Bw_%7B1%7D%5E%7BT%7Dx%7D%7D%7B%5Csum%20e%5E%7Bw_%7Bi%7D%5E%7BT%7Dx%7D%7D&quot; alt=&quot;\frac{e^{w_{1}^{T}x}}{\sum e^{w_{i}^{T}x}}&quot; data-cke-saved-src=&quot;https://private.codecogs.com/gif.latex?%5Cfrac%7Be%5E%7Bw_%7B1%7D%5E%7BT%7Dx%7D%7D%7B%5Csum%20e%5E%7Bw_%7Bi%7D%5E%7BT%7Dx%7D%7D&quot; data-cke-widget-data=&quot;{}&quot; data-cke-widget-upcasted=&quot;1&quot;/&gt;，&lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?%5Cfrac%7Be%5E%7Bw_%7B2%7D%5E%7BT%7Dx%7D%7D%7B%5Csum%20e%5E%7Bw_%7Bi%7D%5E%7BT%7Dx%7D%7D&quot; alt=&quot;\frac{e^{w_{2}^{T}x}}{\sum e^{w_{i}^{T}x}}&quot; data-cke-saved-src=&quot;https://private.codecogs.com/gif.latex?%5Cfrac%7Be%5E%7Bw_%7B2%7D%5E%7BT%7Dx%7D%7D%7B%5Csum%20e%5E%7Bw_%7Bi%7D%5E%7BT%7Dx%7D%7D&quot; data-cke-widget-data=&quot;{}&quot; data-cke-widget-upcasted=&quot;1&quot;/&gt;，&lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?%5Cfrac%7Be%5E%7Bw_%7B3%7D%5E%7BT%7Dx%7D%7D%7B%5Csum%20e%5E%7Bw_%7Bi%7D%5E%7BT%7Dx%7D%7D&quot; alt=&quot;\frac{e^{w_{3}^{T}x}}{\sum e^{w_{i}^{T}x}}&quot; data-cke-saved-src=&quot;https://private.codecogs.com/gif.latex?%5Cfrac%7Be%5E%7Bw_%7B3%7D%5E%7BT%7Dx%7D%7D%7B%5Csum%20e%5E%7Bw_%7Bi%7D%5E%7BT%7Dx%7D%7D&quot; data-cke-widget-data=&quot;{}&quot; data-cke-widget-upcasted=&quot;1&quot;/&gt;，&lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?%5Cfrac%7Be%5E%7Bw_%7B4%7D%5E%7BT%7Dx%7D%7D%7B%5Csum%20e%5E%7Bw_%7Bi%7D%5E%7BT%7Dx%7D%7D&quot; alt=&quot;\frac{e^{w_{4}^{T}x}}{\sum e^{w_{i}^{T}x}}&quot; data-cke-saved-src=&quot;https://private.codecogs.com/gif.latex?%5Cfrac%7Be%5E%7Bw_%7B4%7D%5E%7BT%7Dx%7D%7D%7B%5Csum%20e%5E%7Bw_%7Bi%7D%5E%7BT%7Dx%7D%7D&quot; data-cke-widget-data=&quot;{}&quot; data-cke-widget-upcasted=&quot;1&quot;/&gt;，&lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?%5Cfrac%7Be%5E%7Bw_%7B5%7D%5E%7BT%7Dx%7D%7D%7B%5Csum%20e%5E%7Bw_%7Bi%7D%5E%7BT%7Dx%7D%7D&quot; alt=&quot;\frac{e^{w_{5}^{T}x}}{\sum e^{w_{i}^{T}x}}&quot; data-cke-saved-src=&quot;https://private.codecogs.com/gif.latex?%5Cfrac%7Be%5E%7Bw_%7B5%7D%5E%7BT%7Dx%7D%7D%7B%5Csum%20e%5E%7Bw_%7Bi%7D%5E%7BT%7Dx%7D%7D&quot; data-cke-widget-data=&quot;{}&quot; data-cke-widget-upcasted=&quot;1&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在 softmax回归中，我们解决的是多分类问题（相对于 logistic 回归解决的二分类问题),类标y可以取k个不同的值（而不是两个）因此，对于训练集&lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?%5Cleft%5C%7B%5Cleft%28x%5E%7B%281%29%7D%2C%20y%5E%7B%281%29%7D%5Cright%29%2C%20%5Cldots%2C%5Cleft%28x%5E%7B%28m%29%7D%2C%20y%5E%7B%28m%29%7D%5Cright%29%5Cright%5C%7D&quot; alt=&quot;\left\{\left(x^{(1)}, y^{(1)}\right), \ldots,\left(x^{(m)}, y^{(m)}\right)\right\}&quot; data-cke-saved-src=&quot;https://private.codecogs.com/gif.latex?%5Cleft%5C%7B%5Cleft%28x%5E%7B%281%29%7D%2C%20y%5E%7B%281%29%7D%5Cright%29%2C%20%5Cldots%2C%5Cleft%28x%5E%7B%28m%29%7D%2C%20y%5E%7B%28m%29%7D%5Cright%29%5Cright%5C%7D&quot; data-cke-widget-data=&quot;{}&quot; data-cke-widget-upcasted=&quot;1&quot;/&gt;，我们有&lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?%24y%5E%7B%28i%29%7D%20%5Cin%5C%7B1%2C2%2C%20%5Cldots%2C%20k%5C%7D%24&quot; alt=&quot;$y^{(i)} \in\{1,2, \ldots, k\}$&quot; data-cke-saved-src=&quot;https://private.codecogs.com/gif.latex?%24y%5E%7B%28i%29%7D%20%5Cin%5C%7B1%2C2%2C%20%5Cldots%2C%20k%5C%7D%24&quot; data-cke-widget-data=&quot;{}&quot; data-cke-widget-upcasted=&quot;1&quot;/&gt;，（注意此处的类别下标从 1 开始，而不是 0）。对于给定的测试输入x，我们想用假设函数针对每一个类别j估算出概率值p(y=j|x),也就是说&lt;strong&gt;，我们想估计x的每一种分类结果出现的概率。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因此，我们的假设函数将要输出一个k维(k个类别)的向量来表示这k个估计的概率值。具体地说，我们的假设函数h(θ）形式如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                             &lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?h_%7B%5Ctheta%7D%5Cleft%28x%5E%7B%28i%29%7D%5Cright%29%3D%5Cleft%5B%20%5Cbegin%7Barray%7D%7Bc%7D%7Bp%5Cleft%28y%5E%7B%28i%29%7D%3D1%20%7C%20x%5E%7B%28i%29%7D%20%3B%20%5Ctheta%5Cright%29%7D%20%5C%5C%20%7Bp%5Cleft%28y%5E%7B%28i%29%7D%3D2%20%7C%20x%5E%7B%28i%29%7D%20%3B%20%5Ctheta%5Cright%29%7D%20%5C%5C%20%7B%5Cvdots%7D%20%5C%5C%20%7Bp%5Cleft%28y%5E%7B%28i%29%7D%3Dk%20%7C%20x%5E%7B%28i%29%7D%20%3B%20%5Ctheta%5Cright%29%7D%5Cend%7Barray%7D%5Cright%5D%3D%5Cfrac%7B1%7D%7B%5Csum_%7Bj%3D1%7D%5E%7Bk%7D%20e%5E%7B%5Ctheta_%7Bj%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D%20%5Cleft%5B%20%5Cbegin%7Barray%7D%7Bc%7D%7Be%5E%7B%5Ctheta_%7B1%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D%20%5C%5C%20%7Be%5E%7B%5Ctheta_%7B2%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D%20%5C%5C%20%7B%5Cvdots%7D%20%5C%5C%20%7Be%5E%7B%5Ctheta_%7Bk%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D%5Cend%7Barray%7D%5Cright%5D&quot; alt=&quot;h_{\theta}\left(x^{(i)}\right)=\left[ \begin{array}{c}{p\left(y^{(i)}=1 | x^{(i)} ; \theta\right)} \\ {p\left(y^{(i)}=2 | x^{(i)} ; \theta\right)} \\ {\vdots} \\ {p\left(y^{(i)}=k | x^{(i)} ; \theta\right)}\end{array}\right]=\frac{1}{\sum_{j=1}^{k} e^{\theta_{j}^{T} x^{(i)}}} \left[ \begin{array}{c}{e^{\theta_{1}^{T} x^{(i)}}} \\ {e^{\theta_{2}^{T} x^{(i)}}} \\ {\vdots} \\ {e^{\theta_{k}^{T} x^{(i)}}}\end{array}\right]&quot; data-cke-saved-src=&quot;https://private.codecogs.com/gif.latex?h_%7B%5Ctheta%7D%5Cleft%28x%5E%7B%28i%29%7D%5Cright%29%3D%5Cleft%5B%20%5Cbegin%7Barray%7D%7Bc%7D%7Bp%5Cleft%28y%5E%7B%28i%29%7D%3D1%20%7C%20x%5E%7B%28i%29%7D%20%3B%20%5Ctheta%5Cright%29%7D%20%5C%5C%20%7Bp%5Cleft%28y%5E%7B%28i%29%7D%3D2%20%7C%20x%5E%7B%28i%29%7D%20%3B%20%5Ctheta%5Cright%29%7D%20%5C%5C%20%7B%5Cvdots%7D%20%5C%5C%20%7Bp%5Cleft%28y%5E%7B%28i%29%7D%3Dk%20%7C%20x%5E%7B%28i%29%7D%20%3B%20%5Ctheta%5Cright%29%7D%5Cend%7Barray%7D%5Cright%5D%3D%5Cfrac%7B1%7D%7B%5Csum_%7Bj%3D1%7D%5E%7Bk%7D%20e%5E%7B%5Ctheta_%7Bj%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D%20%5Cleft%5B%20%5Cbegin%7Barray%7D%7Bc%7D%7Be%5E%7B%5Ctheta_%7B1%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D%20%5C%5C%20%7Be%5E%7B%5Ctheta_%7B2%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D%20%5C%5C%20%7B%5Cvdots%7D%20%5C%5C%20%7Be%5E%7B%5Ctheta_%7Bk%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D%5Cend%7Barray%7D%5Cright%5D&quot; data-cke-widget-data=&quot;{}&quot; data-cke-widget-upcasted=&quot;1&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其中&lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?%24%5Ctheta_%7B1%7D%2C%20%5Ctheta_%7B2%7D%2C%20%5Cldots%2C%20%5Ctheta_%7Bk%7D%20%5Cin%20%5Cmathrm%7BR%7D%20%5Cmathfrak%7Be%7D%5E%7Bn&amp;amp;plus;1%7D%24&quot; alt=&quot;$\theta_{1}, \theta_{2}, \ldots, \theta_{k} \in \mathrm{R} \mathfrak{e}^{n+1}$&quot; data-cke-saved-src=&quot;https://private.codecogs.com/gif.latex?%24%5Ctheta_%7B1%7D%2C%20%5Ctheta_%7B2%7D%2C%20%5Cldots%2C%20%5Ctheta_%7Bk%7D%20%5Cin%20%5Cmathrm%7BR%7D%20%5Cmathfrak%7Be%7D%5E%7Bn&amp;amp;plus;1%7D%24&quot; data-cke-widget-data=&quot;{}&quot; data-cke-widget-upcasted=&quot;1&quot;/&gt;是模型的参数，&lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?%5Cfrac%7B1%7D%7B%5Csum_%7Bj%3D1%7D%5E%7Bk%7D%20e%5E%7B%5Ctheta_%7Bj%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D&quot; alt=&quot;\frac{1}{\sum_{j=1}^{k} e^{\theta_{j}^{T} x^{(i)}}}&quot; data-cke-saved-src=&quot;https://private.codecogs.com/gif.latex?%5Cfrac%7B1%7D%7B%5Csum_%7Bj%3D1%7D%5E%7Bk%7D%20e%5E%7B%5Ctheta_%7Bj%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D&quot; data-cke-widget-data=&quot;{}&quot; data-cke-widget-upcasted=&quot;1&quot;/&gt;这一项对概率分布进行归一化，使得所有概率之和为 1。实际上就是把一个x(i)丢在一个hθ里面要输出一组概率，比如这个例子里面要输出5个概率，每个概率实际上它的判别函数都是它们共用同一个分母，只不过分子部分不同，第一个概率就是第一组w算出来分数扔到e的上面得出来的结果，每一个都是每一组w对于同一个x(i)的运算结果，分母又是所有分子的加和，因此它们总体的加和一定是等于1的。&lt;strong&gt;这个就是softmax的判别函数。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了方便起见，我们同样使用符号θ来表示全部的模型参数，将θ用一个k*n的矩阵来表示，k个类别，n个属性值，每一类这这些属性上面都对应着一组参数。该矩阵是将每组&lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?%24%5Ctheta_%7B1%7D%2C%20%5Ctheta_%7B2%7D%2C%20%5Cldots%2C%20%5Ctheta_%7Bk%7D%24&quot; alt=&quot;$\theta_{1}, \theta_{2}, \ldots, \theta_{k}$&quot; data-cke-saved-src=&quot;https://private.codecogs.com/gif.latex?%24%5Ctheta_%7B1%7D%2C%20%5Ctheta_%7B2%7D%2C%20%5Cldots%2C%20%5Ctheta_%7Bk%7D%24&quot; data-cke-widget-data=&quot;{}&quot; data-cke-widget-upcasted=&quot;1&quot;/&gt;按照行罗列起来得到的。如下所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                                                                       &lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?%5Ctheta%3D%5Cleft%5B%20%5Cbegin%7Barray%7D%7Bc%7D%7B-%5Ctheta_%7B1%7D%5E%7BT%7D-%7D%20%5C%5C%20%7B-%5Ctheta_%7B2%7D%5E%7BT%7D-%7D%20%5C%5C%20%7B%5Cvdots%7D%20%5C%5C%20%7B-%5Ctheta_%7Bk%7D%5E%7BT%7D-%7D%5Cend%7Barray%7D%5Cright%5D&quot; alt=&quot;\theta=\left[ \begin{array}{c}{-\theta_{1}^{T}-} \\ {-\theta_{2}^{T}-} \\ {\vdots} \\ {-\theta_{k}^{T}-}\end{array}\right]&quot; data-cke-saved-src=&quot;https://private.codecogs.com/gif.latex?%5Ctheta%3D%5Cleft%5B%20%5Cbegin%7Barray%7D%7Bc%7D%7B-%5Ctheta_%7B1%7D%5E%7BT%7D-%7D%20%5C%5C%20%7B-%5Ctheta_%7B2%7D%5E%7BT%7D-%7D%20%5C%5C%20%7B%5Cvdots%7D%20%5C%5C%20%7B-%5Ctheta_%7Bk%7D%5E%7BT%7D-%7D%5Cend%7Barray%7D%5Cright%5D&quot; data-cke-widget-data=&quot;{}&quot; data-cke-widget-upcasted=&quot;1&quot;/&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;有了这一组θ，我们的h(x)就可以使用了，那&lt;strong&gt;怎么得到最好的一组θ？还是通过最大似然来推导损失函数。&lt;/strong&gt;我们先来看下示性函数的表示就是1，其取值规则为：1{值为真的表达式}=1，1{值为假的表达式} =0。举例来说，表达式：1{2+2=4}的值为1 ，因为2+2=4是正确的值为真，所以1{2+2=4}的值为1。同理， 1{2+2=5}的值为 0。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;回顾下逻辑回归的损失函数：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                                                &lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?%24-%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%5Cleft%28y%5E%7B%28i%29%7D%20%5Clog%20h_%7B%5Ctheta%7D%5Cleft%28x%5E%7B%28i%29%7D%5Cright%29&amp;amp;plus;%5Cleft%281-y%5E%7B%28i%29%7D%5Cright%29%20%5Clog%20%5Cleft%281-h_%7B%5Ctheta%7D%5Cleft%28x%5E%7B%28i%29%7D%5Cright%29%5Cright%29%5Cright%29%24&quot; alt=&quot;$-\sum_{i=1}^{m}\left(y^{(i)} \log h_{\theta}\left(x^{(i)}\right)+\left(1-y^{(i)}\right) \log \left(1-h_{\theta}\left(x^{(i)}\right)\right)\right)$&quot; data-cke-saved-src=&quot;https://private.codecogs.com/gif.latex?%24-%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%5Cleft%28y%5E%7B%28i%29%7D%20%5Clog%20h_%7B%5Ctheta%7D%5Cleft%28x%5E%7B%28i%29%7D%5Cright%29&amp;amp;plus;%5Cleft%281-y%5E%7B%28i%29%7D%5Cright%29%20%5Clog%20%5Cleft%281-h_%7B%5Ctheta%7D%5Cleft%28x%5E%7B%28i%29%7D%5Cright%29%5Cright%29%5Cright%29%24&quot; data-cke-widget-data=&quot;{}&quot; data-cke-widget-upcasted=&quot;1&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个函数中，虽然每一项加和的部分是两部分yi*log h（x）+(1-yi)*log (1-h（x）)组成，但是因为yi不是0就是1，前面在后面就没了，后面在前面就没了，所以对每一条样本来说就只能存活下来一项，这个是针对二分类来说的。把其写成示性函数的表达就是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                                                &lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?-%24%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20%5Csum_%7Bj%3D0%7D%5E%7B1%7D%201%5Cleft%5C%7By%5E%7B%28i%29%7D%3Dj%5Cright%5C%7D%20%5Clog%20p%5Cleft%28y%5E%7B%28i%29%7D%3Dj%20%7C%20x%5E%7B%28i%29%7D%20%3B%20%5Ctheta%5Cright%29%24&quot; alt=&quot;-$\sum_{i=1}^{m} \sum_{j=0}^{1} 1\left\{y^{(i)}=j\right\} \log p\left(y^{(i)}=j | x^{(i)} ; \theta\right)$&quot; data-cke-saved-src=&quot;https://private.codecogs.com/gif.latex?-%24%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20%5Csum_%7Bj%3D0%7D%5E%7B1%7D%201%5Cleft%5C%7By%5E%7B%28i%29%7D%3Dj%5Cright%5C%7D%20%5Clog%20p%5Cleft%28y%5E%7B%28i%29%7D%3Dj%20%7C%20x%5E%7B%28i%29%7D%20%3B%20%5Ctheta%5Cright%29%24&quot; data-cke-widget-data=&quot;{}&quot; data-cke-widget-upcasted=&quot;1&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解释下：比如一条样本标签真实值yi是0，根据我们上面的描述yi*log h（x）+(1-yi)*log (1-h（x）)这里面只能存在一项就是后面一项。而对于示性函数来说&lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?%24%5Csum_%7Bj%3D0%7D%5E%7B1%7D%201%5Cleft%5C%7By%5E%7B%28i%29%7D%3Dj%5Cright%5C%7D%20%5Clog%20p%5Cleft%28y%5E%7B%28i%29%7D%3Dj%20%7C%20x%5E%7B%28i%29%7D%20%3B%20%5Ctheta%5Cright%29%24&quot; alt=&quot;$\sum_{j=0}^{1} 1\left\{y^{(i)}=j\right\} \log p\left(y^{(i)}=j | x^{(i)} ; \theta\right)$&quot; data-cke-saved-src=&quot;https://private.codecogs.com/gif.latex?%24%5Csum_%7Bj%3D0%7D%5E%7B1%7D%201%5Cleft%5C%7By%5E%7B%28i%29%7D%3Dj%5Cright%5C%7D%20%5Clog%20p%5Cleft%28y%5E%7B%28i%29%7D%3Dj%20%7C%20x%5E%7B%28i%29%7D%20%3B%20%5Ctheta%5Cright%29%24&quot; data-cke-widget-data=&quot;{}&quot; data-cke-widget-upcasted=&quot;1&quot;/&gt;这个里面j是累加到1，两个取值，j先为0的时候，yi=j=0为真。1{值为真的表达式}=1，所以当j为0的时候值保留下来，当j为1的时候yi=j=1≠0，1{值为假的表达式} =0，所以当j为1的时候值没有累加。因此真正每一条样本计算的就是其对应真实y的时候那一部分概率值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而对于多分类来说我们需要像推导逻辑回归损失函数一样，把每一条样本预测正确的概率连乘，使得似然最大。那多分类的每一条样本预测正确的概率就是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                                                      &lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?%5Csum_%7Bj%3D1%7D%5E%7Bk%7D%201%5Cleft%5C%7By%5E%7B%28i%29%7D%3Dj%5Cright%5C%7D%20%5Clog%20%5Cfrac%7Be%5E%7B%5Ctheta_%7Bj%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D%7B%5Csum_%7Bl%3D1%7D%5E%7Bk%7D%20e%5E%7B%5Ctheta_%7Bl%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D&quot; alt=&quot;\sum_{j=1}^{k} 1\left\{y^{(i)}=j\right\} \log \frac{e^{\theta_{j}^{T} x^{(i)}}}{\sum_{l=1}^{k} e^{\theta_{l}^{T} x^{(i)}}}&quot; data-cke-saved-src=&quot;https://private.codecogs.com/gif.latex?%5Csum_%7Bj%3D1%7D%5E%7Bk%7D%201%5Cleft%5C%7By%5E%7B%28i%29%7D%3Dj%5Cright%5C%7D%20%5Clog%20%5Cfrac%7Be%5E%7B%5Ctheta_%7Bj%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D%7B%5Csum_%7Bl%3D1%7D%5E%7Bk%7D%20e%5E%7B%5Ctheta_%7Bl%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D&quot; data-cke-widget-data=&quot;{}&quot; data-cke-widget-upcasted=&quot;1&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在Softmax回归中将x分类为类别j的概率为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                                            &lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?h%28%5Ctheta%29x%3Dp%5Cleft%28y%5E%7B%28i%29%7D%3Dj%20%7C%20x%5E%7B%28i%29%7D%20%3B%20%5Ctheta%5Cright%29%3D%5Cfrac%7Be%5E%7B%5Ctheta_%7Bj%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D%7B%5Csum_%7Bl%3D1%7D%5E%7Bk%7D%20e%5E%7B%5Ctheta_%7Bl%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D&quot; alt=&quot;h(\theta)x=p\left(y^{(i)}=j | x^{(i)} ; \theta\right)=\frac{e^{\theta_{j}^{T} x^{(i)}}}{\sum_{l=1}^{k} e^{\theta_{l}^{T} x^{(i)}}}&quot; data-cke-saved-src=&quot;https://private.codecogs.com/gif.latex?h%28%5Ctheta%29x%3Dp%5Cleft%28y%5E%7B%28i%29%7D%3Dj%20%7C%20x%5E%7B%28i%29%7D%20%3B%20%5Ctheta%5Cright%29%3D%5Cfrac%7Be%5E%7B%5Ctheta_%7Bj%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D%7B%5Csum_%7Bl%3D1%7D%5E%7Bk%7D%20e%5E%7B%5Ctheta_%7Bl%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D&quot; data-cke-widget-data=&quot;{}&quot; data-cke-widget-upcasted=&quot;1&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;举例来说，假如是3分类，这个预测就输出3个概率，也就是3个数，对每一条样本来说，其中第一个概率代表是我预测它最后类别是1的概率，第二个是代表我预测它类别为2的概率，第三个就是我预测它类别为3的概率，它实际的类别假如为1的话，我预测对了的概率是第一个数，第二个数还是第三个数？应该是第一个数。&lt;strong&gt;就从里边挑出应该预测正确的概率放在这，这就是它正确的概率，&lt;/strong&gt;因为对每一个样本来说yi只能取一个值，所以里面的加和也只会存活下来一项。每一条样本yi等于多少其对应的hθ(x)的值就留下来。比如第一个样本真实分类是0，那就保留&lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?%5Cfrac%7Be%5E%7B%5Ctheta_%7B0%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D%7B%5Csum_%7Bl%3D1%7D%5E%7Bk%7D%20e%5E%7B%5Ctheta_%7Bl%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D&quot; alt=&quot;\frac{e^{\theta_{0}^{T} x^{(i)}}}{\sum_{l=1}^{k} e^{\theta_{l}^{T} x^{(i)}}}&quot; data-cke-saved-src=&quot;https://private.codecogs.com/gif.latex?%5Cfrac%7Be%5E%7B%5Ctheta_%7B0%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D%7B%5Csum_%7Bl%3D1%7D%5E%7Bk%7D%20e%5E%7B%5Ctheta_%7Bl%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D&quot; data-cke-widget-data=&quot;{}&quot; data-cke-widget-upcasted=&quot;1&quot;/&gt;这一部分，第二个真实样本类别是1 ，那就保留&lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?%5Cfrac%7Be%5E%7B%5Ctheta_%7B1%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D%7B%5Csum_%7Bl%3D1%7D%5E%7Bk%7D%20e%5E%7B%5Ctheta_%7Bl%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D&quot; alt=&quot;\frac{e^{\theta_{1}^{T} x^{(i)}}}{\sum_{l=1}^{k} e^{\theta_{l}^{T} x^{(i)}}}&quot; data-cke-saved-src=&quot;https://private.codecogs.com/gif.latex?%5Cfrac%7Be%5E%7B%5Ctheta_%7B1%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D%7B%5Csum_%7Bl%3D1%7D%5E%7Bk%7D%20e%5E%7B%5Ctheta_%7Bl%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D&quot; data-cke-widget-data=&quot;{}&quot; data-cke-widget-upcasted=&quot;1&quot;/&gt;这一部分，第三个真实样本分类是2，那就保留&lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?%5Cfrac%7Be%5E%7B%5Ctheta_%7B2%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D%7B%5Csum_%7Bl%3D1%7D%5E%7Bk%7D%20e%5E%7B%5Ctheta_%7Bl%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D&quot; alt=&quot;\frac{e^{\theta_{2}^{T} x^{(i)}}}{\sum_{l=1}^{k} e^{\theta_{l}^{T} x^{(i)}}}&quot; data-cke-saved-src=&quot;https://private.codecogs.com/gif.latex?%5Cfrac%7Be%5E%7B%5Ctheta_%7B2%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D%7B%5Csum_%7Bl%3D1%7D%5E%7Bk%7D%20e%5E%7B%5Ctheta_%7Bl%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D&quot; data-cke-widget-data=&quot;{}&quot; data-cke-widget-upcasted=&quot;1&quot;/&gt;这一部分，损失函数只取决于预测对的那一项的概率，其它的概率其实损失函数角度是不关心的。所以它尽量，想让训练集上全部预测的总正确率最大，就需要把每条数据被预测正确的概率给连乘起来，求最大似然，加个log，连乘变连加，然后加个负号就得到这个损失函数了。最后推导出来的&lt;strong&gt;softmax损失函数如下：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                                                       &lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?J%28%5Ctheta%29%3D-%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20%5Csum_%7Bj%3D1%7D%5E%7Bk%7D%201%5Cleft%5C%7By%5E%7B%28i%29%7D%3Dj%5Cright%5C%7D%20%5Clog%20%5Cfrac%7Be%5E%7B%5Ctheta_%7Bj%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D%7B%5Csum_%7Bl%3D1%7D%5E%7Bk%7D%20e%5E%7B%5Ctheta_%7Bl%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D&quot; alt=&quot;J(\theta)=-\sum_{i=1}^{m} \sum_{j=1}^{k} 1\left\{y^{(i)}=j\right\} \log \frac{e^{\theta_{j}^{T} x^{(i)}}}{\sum_{l=1}^{k} e^{\theta_{l}^{T} x^{(i)}}}&quot; data-cke-saved-src=&quot;https://private.codecogs.com/gif.latex?J%28%5Ctheta%29%3D-%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20%5Csum_%7Bj%3D1%7D%5E%7Bk%7D%201%5Cleft%5C%7By%5E%7B%28i%29%7D%3Dj%5Cright%5C%7D%20%5Clog%20%5Cfrac%7Be%5E%7B%5Ctheta_%7Bj%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D%7B%5Csum_%7Bl%3D1%7D%5E%7Bk%7D%20e%5E%7B%5Ctheta_%7Bl%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D&quot; data-cke-widget-data=&quot;{}&quot; data-cke-widget-upcasted=&quot;1&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;可以看到，Softmax代价函数与logistic 代价函数在形式上非常类似，只是Softmax损失函数中对类标记的k个可能值进行了累加。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于J(θ)的最小化问题，当前还没有闭式解法。因此，我们使用迭代的优化算法（例如梯度下降法，或 L-BFGS）。经过求导，我们得到梯度公式如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                                            &lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?%5Cnabla_%7B%5Ctheta_%7Bj%7D%7D%20J%28%5Ctheta%29%3D-%5Cfrac%7B1%7D%7Bm%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%5Cleft%5Bx%5E%7B%28i%29%7D%5Cleft%281%5Cleft%5C%7By%5E%7B%28i%29%7D%3Dj%5Cright%5C%7D-p%5Cleft%28y%5E%7B%28i%29%7D%3Dj%20%7C%20x%5E%7B%28i%29%7D%20%3B%20%5Ctheta%5Cright%29%5Cright%29%5Cright%5D&quot; alt=&quot;\nabla_{\theta_{j}} J(\theta)=-\frac{1}{m} \sum_{i=1}^{m}\left[x^{(i)}\left(1\left\{y^{(i)}=j\right\}-p\left(y^{(i)}=j | x^{(i)} ; \theta\right)\right)\right]&quot; data-cke-saved-src=&quot;https://private.codecogs.com/gif.latex?%5Cnabla_%7B%5Ctheta_%7Bj%7D%7D%20J%28%5Ctheta%29%3D-%5Cfrac%7B1%7D%7Bm%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%5Cleft%5Bx%5E%7B%28i%29%7D%5Cleft%281%5Cleft%5C%7By%5E%7B%28i%29%7D%3Dj%5Cright%5C%7D-p%5Cleft%28y%5E%7B%28i%29%7D%3Dj%20%7C%20x%5E%7B%28i%29%7D%20%3B%20%5Ctheta%5Cright%29%5Cright%29%5Cright%5D&quot; data-cke-widget-data=&quot;{}&quot; data-cke-widget-upcasted=&quot;1&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有了上面的偏导数公式以后，我们就可以将它代入到梯度下降法等算法中，来最小化J(θ)。例如，在梯度下降法的标准实现中，每一次迭代需要进行如下更新：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                                                            &lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?%24%5Ctheta_%7Bj%7D%20%3A%3D%5Ctheta_%7Bj%7D-%5Calpha%20%5Cnabla_%7B%5Ctheta_%7Bj%7D%7D%20J%28%5Ctheta%29%28j%3D1%2C%20%5Cldots%2C%20k%29%24&quot; alt=&quot;$\theta_{j} :=\theta_{j}-\alpha \nabla_{\theta_{j}} J(\theta)(j=1, \ldots, k)$&quot; data-cke-saved-src=&quot;https://private.codecogs.com/gif.latex?%24%5Ctheta_%7Bj%7D%20%3A%3D%5Ctheta_%7Bj%7D-%5Calpha%20%5Cnabla_%7B%5Ctheta_%7Bj%7D%7D%20J%28%5Ctheta%29%28j%3D1%2C%20%5Cldots%2C%20k%29%24&quot; data-cke-widget-data=&quot;{}&quot; data-cke-widget-upcasted=&quot;1&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;得到一组θ使得模型表现最好。此时得到θ就是softmax训练出来的结果。所以不管它是什么损失函数，你总可以交给sgd或者l-bfgs进行最小化，得到一组θ使得模型表现最好。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;对于softmax，你它的本质是把好几个逻辑回归塞到一起去了，但是它判别函数又变了变，原来是1/{1+exp(-z)}，现在变成了e的z求和，有多少个z就求和多少次，加起来之后当分母，然后分子为对应部分预测的概率，这样它们输出的每个概率就都进行了归一化。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;softmax有一个有趣的特点：&lt;/strong&gt;softmax的形式是有几个分类，就有几组w向量，比如三类，最终训练出来的参数实际上就是θ1，θ2，θ3，原来逻辑回归是一组θ，现在是三组θ。你把这三组θ都减去一个相同的向量φ，比如φ全是1。 假如这θ长度为五，φ是五个1也好，五个2也好，12345也好，只要把每一个θ的向量都减去同一个φ，你就会发现他们预测结果没有任何变化。假如我拿每一个θ都减去了同一个φ，我把θj-φ当作原来的θj，即：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                                                          &lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?%5Cbegin%7Baligned%7D%20p%5Cleft%28y%5E%7B%28i%29%7D%3Dj%20%7C%20x%5E%7B%28i%29%7D%20%3B%20%5Ctheta%5Cright%29%20%26%3D%5Cfrac%7Be%5E%7B%5Cleft%28%5Ctheta_%7Bj%7D-%5Cpsi%5Cright%29%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D%7B%5Csum_%7Bl%3D1%7D%5E%7Bk%7D%20e%5E%7B%5Cleft%28%5Ctheta_%7Bl%7D-%5Cpsi%5Cright%29%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D%20%5C%5C%20%26%3D%5Cfrac%7Be%5E%7B%5Ctheta_%7Bj%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%20e%5E%7B-%5Cpsi%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D%7D%7B%5Csum_%7Bl%3D1%7D%5E%7Bk%7D%20e%5E%7B%5Ctheta_%7Bl%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%20e%5E%7B-%5Cpsi%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D%7D%20%5C%5C%20%26%3D%5Cfrac%7Be%5E%7B%5Ctheta_%7Bl%3D1%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D%7B%5Csum_%7Bl%3D1%7D%5E%7Bk%7D%20e%5E%7B%5Ctheta_%7Bl%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D%20%5Cend%7Baligned%7D&quot; alt=&quot;\begin{aligned} p\left(y^{(i)}=j | x^{(i)} ; \theta\right) &amp;amp;=\frac{e^{\left(\theta_{j}-\psi\right)^{T} x^{(i)}}}{\sum_{l=1}^{k} e^{\left(\theta_{l}-\psi\right)^{T} x^{(i)}}} \\ &amp;amp;=\frac{e^{\theta_{j}^{T} x^{(i)} e^{-\psi^{T} x^{(i)}}}}{\sum_{l=1}^{k} e^{\theta_{l}^{T} x^{(i)} e^{-\psi^{T} x^{(i)}}}} \\ &amp;amp;=\frac{e^{\theta_{l=1}^{T} x^{(i)}}}{\sum_{l=1}^{k} e^{\theta_{l}^{T} x^{(i)}}} \end{aligned}&quot; data-cke-saved-src=&quot;https://private.codecogs.com/gif.latex?%5Cbegin%7Baligned%7D%20p%5Cleft%28y%5E%7B%28i%29%7D%3Dj%20%7C%20x%5E%7B%28i%29%7D%20%3B%20%5Ctheta%5Cright%29%20%26%3D%5Cfrac%7Be%5E%7B%5Cleft%28%5Ctheta_%7Bj%7D-%5Cpsi%5Cright%29%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D%7B%5Csum_%7Bl%3D1%7D%5E%7Bk%7D%20e%5E%7B%5Cleft%28%5Ctheta_%7Bl%7D-%5Cpsi%5Cright%29%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D%20%5C%5C%20%26%3D%5Cfrac%7Be%5E%7B%5Ctheta_%7Bj%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%20e%5E%7B-%5Cpsi%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D%7D%7B%5Csum_%7Bl%3D1%7D%5E%7Bk%7D%20e%5E%7B%5Ctheta_%7Bl%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%20e%5E%7B-%5Cpsi%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D%7D%20%5C%5C%20%26%3D%5Cfrac%7Be%5E%7B%5Ctheta_%7Bl%3D1%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D%7B%5Csum_%7Bl%3D1%7D%5E%7Bk%7D%20e%5E%7B%5Ctheta_%7Bl%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D%20%5Cend%7Baligned%7D&quot; data-cke-widget-data=&quot;{}&quot; data-cke-widget-upcasted=&quot;1&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过上面公式展开，也就是说减φ与不减φ不影响最终的预测结果。这说明softmax参数有冗余，既然随便减一个φ可以，那我都给他减一个θ1，也可以，那么就是把θ1全变成零了，θ2变成θ2-θ1了，θ3变成θ3-θ1了。所以实际上我们只需要保存两组参数就够了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;我们再来看下Softmax回归与Logistic 回归的关系：&lt;/strong&gt;当类别数k=2时，softmax 回归退化为 logistic 回归。这表明 softmax 回归是 logistic 回归的一般形式。具体地说，当k=2时，softmax 回归的假设函数为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                                                                      &lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?h_%7B%5Ctheta%7D%28x%29%3D%5Cfrac%7B1%7D%7Be%5E%7B%5Ctheta_%7B1%7D%5E%7BT%7D%20x%7D&amp;amp;plus;e%5E%7B%5Ctheta_%7B2%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D%20%5Cleft%5B%20%5Cbegin%7Barray%7D%7Bc%7D%7Be%5E%7B%5Ctheta_%7B1%7D%5E%7BT%7D%20x%7D%7D%20%5C%5C%20%7Be%5E%7B%5Ctheta_%7B2%7D%5E%7BT%7D%20x%7D%7D%5Cend%7Barray%7D%5Cright%5D&quot; alt=&quot;h_{\theta}(x)=\frac{1}{e^{\theta_{1}^{T} x}+e^{\theta_{2}^{T} x^{(i)}}} \left[ \begin{array}{c}{e^{\theta_{1}^{T} x}} \\ {e^{\theta_{2}^{T} x}}\end{array}\right]&quot; data-cke-saved-src=&quot;https://private.codecogs.com/gif.latex?h_%7B%5Ctheta%7D%28x%29%3D%5Cfrac%7B1%7D%7Be%5E%7B%5Ctheta_%7B1%7D%5E%7BT%7D%20x%7D&amp;amp;plus;e%5E%7B%5Ctheta_%7B2%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D%20%5Cleft%5B%20%5Cbegin%7Barray%7D%7Bc%7D%7Be%5E%7B%5Ctheta_%7B1%7D%5E%7BT%7D%20x%7D%7D%20%5C%5C%20%7Be%5E%7B%5Ctheta_%7B2%7D%5E%7BT%7D%20x%7D%7D%5Cend%7Barray%7D%5Cright%5D&quot; data-cke-widget-data=&quot;{}&quot; data-cke-widget-upcasted=&quot;1&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;利用softmax回归参数冗余的特点，θ1全置为0，θ2变成θ2-θ1：那么h(x)会输出两个结果。即：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                                                                       &lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?h%28x%29%3D%5Cfrac%7B1%7D%7Be%5E%7B%5Coverrightarrow%7B0%7D%5E%7BT%7D%20x%7D&amp;amp;plus;e%5E%7B%5Cleft%28%5Ctheta_%7B2%7D-%5Ctheta_%7B1%7D%5Cright%29%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D%20%5Cleft%5B%20%5Cbegin%7Barray%7D%7Bc%7D%7Be%5E%7B%5Coverrightarrow%7B0%7D%5E%7BT%7D%20x%7D%7D%20%5C%5C%20%7Be%5E%7B%5Cleft%28%5Ctheta_%7B2%7D-%5Ctheta_%7B1%7D%5Cright%29%5E%7BT%7D%20x%7D%20%5D%7D%5Cend%7Barray%7D%5Cright%5D&quot; alt=&quot;h(x)=\frac{1}{e^{\overrightarrow{0}^{T} x}+e^{\left(\theta_{2}-\theta_{1}\right)^{T} x^{(i)}}} \left[ \begin{array}{c}{e^{\overrightarrow{0}^{T} x}} \\ {e^{\left(\theta_{2}-\theta_{1}\right)^{T} x} ]}\end{array}\right]&quot; data-cke-saved-src=&quot;https://private.codecogs.com/gif.latex?h%28x%29%3D%5Cfrac%7B1%7D%7Be%5E%7B%5Coverrightarrow%7B0%7D%5E%7BT%7D%20x%7D&amp;amp;plus;e%5E%7B%5Cleft%28%5Ctheta_%7B2%7D-%5Ctheta_%7B1%7D%5Cright%29%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D%20%5Cleft%5B%20%5Cbegin%7Barray%7D%7Bc%7D%7Be%5E%7B%5Coverrightarrow%7B0%7D%5E%7BT%7D%20x%7D%7D%20%5C%5C%20%7Be%5E%7B%5Cleft%28%5Ctheta_%7B2%7D-%5Ctheta_%7B1%7D%5Cright%29%5E%7BT%7D%20x%7D%20%5D%7D%5Cend%7Barray%7D%5Cright%5D&quot; data-cke-widget-data=&quot;{}&quot; data-cke-widget-upcasted=&quot;1&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                                                                               &lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?%3D%5Cleft%5B%20%5Cbegin%7Barray%7D%7Bc%7D%7B%5Cfrac%7B1%7D%7B1&amp;amp;plus;e%5E%7B%5Cleft%28%5Ctheta_%7B2%7D-%5Ctheta_%7B1%7D%5Cright%29%5E%7BT%7D%20x%7D%7D%7D%20%5C%5C%20%7B%5Cfrac%7Be%5E%7B%5Cleft%28%5Ctheta_%7B2%7D-%5Ctheta_%7B1%7D%5Cright%29%5E%7BT%7D%20x%7D%7D%7B1&amp;amp;plus;e%5E%7B%5Cleft%28%5Ctheta_%7B2%7D-%5Ctheta_%7B1%7D%5Cright%29%5E%7BT%7D%20x%7D%7D%7D%5Cend%7Barray%7D%5Cright%5D&quot; alt=&quot;=\left[ \begin{array}{c}{\frac{1}{1+e^{\left(\theta_{2}-\theta_{1}\right)^{T} x}}} \\ {\frac{e^{\left(\theta_{2}-\theta_{1}\right)^{T} x}}{1+e^{\left(\theta_{2}-\theta_{1}\right)^{T} x}}}\end{array}\right]&quot; data-cke-saved-src=&quot;https://private.codecogs.com/gif.latex?%3D%5Cleft%5B%20%5Cbegin%7Barray%7D%7Bc%7D%7B%5Cfrac%7B1%7D%7B1&amp;amp;plus;e%5E%7B%5Cleft%28%5Ctheta_%7B2%7D-%5Ctheta_%7B1%7D%5Cright%29%5E%7BT%7D%20x%7D%7D%7D%20%5C%5C%20%7B%5Cfrac%7Be%5E%7B%5Cleft%28%5Ctheta_%7B2%7D-%5Ctheta_%7B1%7D%5Cright%29%5E%7BT%7D%20x%7D%7D%7B1&amp;amp;plus;e%5E%7B%5Cleft%28%5Ctheta_%7B2%7D-%5Ctheta_%7B1%7D%5Cright%29%5E%7BT%7D%20x%7D%7D%7D%5Cend%7Barray%7D%5Cright%5D&quot; data-cke-widget-data=&quot;{}&quot; data-cke-widget-upcasted=&quot;1&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                                                                              &lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?%3D%5Cleft%5B%20%5Cbegin%7Barray%7D%7Bc%7D%7B%5Cfrac%7B1%7D%7B1&amp;amp;plus;e%5E%7B%5Cleft%28%5Ctheta_%7B2%7D-%5Ctheta_%7B1%7D%5Cright%29%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D%7D%20%5C%5C%20%7B1-%5Cfrac%7B1%7D%7B1&amp;amp;plus;e%5E%7B%5Cleft%28%5Ctheta_%7B2%7D-%5Ctheta_%7B1%7D%5Cright%29%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D%7D%5Cend%7Barray%7D%5Cright%5D&quot; alt=&quot;=\left[ \begin{array}{c}{\frac{1}{1+e^{\left(\theta_{2}-\theta_{1}\right)^{T} x^{(i)}}}} \\ {1-\frac{1}{1+e^{\left(\theta_{2}-\theta_{1}\right)^{T} x^{(i)}}}}\end{array}\right]&quot; data-cke-saved-src=&quot;https://private.codecogs.com/gif.latex?%3D%5Cleft%5B%20%5Cbegin%7Barray%7D%7Bc%7D%7B%5Cfrac%7B1%7D%7B1&amp;amp;plus;e%5E%7B%5Cleft%28%5Ctheta_%7B2%7D-%5Ctheta_%7B1%7D%5Cright%29%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D%7D%20%5C%5C%20%7B1-%5Cfrac%7B1%7D%7B1&amp;amp;plus;e%5E%7B%5Cleft%28%5Ctheta_%7B2%7D-%5Ctheta_%7B1%7D%5Cright%29%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D%7D%5Cend%7Barray%7D%5Cright%5D&quot; data-cke-widget-data=&quot;{}&quot; data-cke-widget-upcasted=&quot;1&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们就会发现 softmax 回归器预测其中一个类别的概率为&lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?%5Cfrac%7B1%7D%7B1&amp;amp;plus;e%5E%7B%5Cleft%28%5Ctheta_%7B2%7D-%5Ctheta_%7B1%7D%5Cright%29%5E%7BT%7D%20x%28i%29%7D%7D&quot; alt=&quot;\frac{1}{1+e^{\left(\theta_{2}-\theta_{1}\right)^{T} x(i)}}&quot; data-cke-saved-src=&quot;https://private.codecogs.com/gif.latex?%5Cfrac%7B1%7D%7B1&amp;amp;plus;e%5E%7B%5Cleft%28%5Ctheta_%7B2%7D-%5Ctheta_%7B1%7D%5Cright%29%5E%7BT%7D%20x%28i%29%7D%7D&quot; data-cke-widget-data=&quot;{}&quot; data-cke-widget-upcasted=&quot;1&quot;/&gt;，另一个类别的概率就是&lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?1-%5Cfrac%7B1%7D%7B1&amp;amp;plus;e%5E%7B%5Cleft%28%5Ctheta_%7B2%7D-%5Ctheta_%7B1%7D%5Cright%29%5E%7BT%7D%20x%7D%28i%29%7D&quot; alt=&quot;1-\frac{1}{1+e^{\left(\theta_{2}-\theta_{1}\right)^{T} x}(i)}&quot; data-cke-saved-src=&quot;https://private.codecogs.com/gif.latex?1-%5Cfrac%7B1%7D%7B1&amp;amp;plus;e%5E%7B%5Cleft%28%5Ctheta_%7B2%7D-%5Ctheta_%7B1%7D%5Cright%29%5E%7BT%7D%20x%7D%28i%29%7D&quot; data-cke-widget-data=&quot;{}&quot; data-cke-widget-upcasted=&quot;1&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;此时的softmax回归就是参数为θ2-θ1的逻辑回归&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 01 May 2019 15:33:00 +0000</pubDate>
<dc:creator>LHBlog</dc:creator>
<og:description>大白话5分钟带你走进人工智能-第二十节逻辑回归和Softmax多分类问题(5) 上一节中，我们讲解了逻辑回归的优化，本节的话我们讲解逻辑回归做多分类问题以及传统的多分类问题，我们用什么手段解决。 先看</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/LHWorldBlog/p/10801253.html</dc:identifier>
</item>
<item>
<title>【排序算法】java实现 - Ivo-oo</title>
<link>http://www.cnblogs.com/ivoo/p/10794197.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ivoo/p/10794197.html</guid>
<description>&lt;h3&gt;1.冒泡排序&lt;/h3&gt;
&lt;p&gt;最简单的排序实现，冒泡排序，是一种交换排序，它的基本思想是：两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 //冒泡排序
    private int[] bubbleSort(int&lt;span&gt;[] arr) {
        for (int i = 0; i &amp;lt; arr.length; i++&lt;span&gt;)
            for (int j = arr.length - 1; j &amp;gt; i; j--&lt;span&gt;)
                if (arr[j] &amp;lt; arr[j - 1&lt;span&gt;]) {
                    swap(arr, j, j - 1&lt;span&gt;);
                }
        return&lt;span&gt; arr;
    }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;swap方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
 private void swap(int[] arr, int i, int&lt;span&gt; j) {
        int temp =&lt;span&gt; arr[i];
        arr[i] =&lt;span&gt; arr[j];
        arr[j] =&lt;span&gt; temp;
    }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;冒泡算法的优化（外部循环优化）&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
private int[] bubbleSort1(int&lt;span&gt;[] arr) {
        boolean flag = true;//加入flag指针，若在一次冒泡中，没有交换 则说明可以停止 减少运行时
        for (int i = 0; i &amp;lt; arr.length &amp;amp;&amp;amp; flag; i++&lt;span&gt;) {
            flag = false&lt;span&gt;;
            for (int j = arr.length - 1; j &amp;gt; i; j--&lt;span&gt;) {
                if (arr[j] &amp;lt; arr[j - 1&lt;span&gt;]) {
                    swap(arr, j, j - 1&lt;span&gt;);
                    flag = true&lt;span&gt;;
                }
            }
        }
        return&lt;span&gt; arr;
    }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;代码改动的关键就是在i变量的for循环中，增加了对flag是否为true的判断。经过这样的改进，冒泡排序在性能上就有了一些提升，可以避免因已经有序的情况下的无意义的循环判断。&lt;/p&gt;
&lt;p&gt;优化2：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
private int[] bubbleSort2(int&lt;span&gt;[] arr) {
        boolean flag = true;//加入flag指针，若在一次冒泡中，没有交换 则说明可以停止 减少运行时
        int pos = 0&lt;span&gt;;
        int k = arr.length - 2&lt;span&gt;;
        for (int i = 0; i &amp;lt; arr.length &amp;amp;&amp;amp; flag; i++&lt;span&gt;) {
            flag = false&lt;span&gt;;
            for (int j = arr.length - 1; j &amp;gt; k; j--&lt;span&gt;) {
                if (arr[j] &amp;lt; arr[j - 1&lt;span&gt;]) {
                    swap(arr, j, j - 1&lt;span&gt;);
                    flag = true&lt;span&gt;;
                    pos =&lt;span&gt; i;
                }
                k =&lt;span&gt; pos;
            }
        }
        return&lt;span&gt; arr;
    }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;冒泡排序的复杂度。当最好情况，也就是要排序的表本身就是有序的，那么我们要比较次数，根据改进后的代码，可以判断出就是n-1次比较，没有数据交换，时间复杂度也就是O(n).当最坏情况，即待排序表是逆序的情况，此时需要比较1+2+3+.....+(n-1) = n(n-1)/2次，并作等数量级的移动记录。因此，总的&lt;strong&gt;时间复杂度为O(n&lt;sup&gt;2&lt;/sup&gt;)。&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;2.简单选择排序&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;基本思想：&lt;/strong&gt;每一趟（例如第i趟）在n-i(i=1,2,...,n-1)个记录中选取关键字最小的记录作为有序序列的第i个记录，直到第n-1趟做完，待排序元素只剩1个，就不用再选了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
private int[] selectSort(int&lt;span&gt;[] arr) {
        int&lt;span&gt; min;
        for (int i = 0; i &amp;lt; arr.length - 1; i++) {//共进行n-1趟
            min = i;//记录最小元素位置
            for (int j = i + 1; j &amp;lt; arr.length; j++&lt;span&gt;) {
                if (arr[j] &amp;lt;&lt;span&gt; arr[min]) {
                    min = j;//更新最小元素
&lt;span&gt;                }
            }
            if (min !=&lt;span&gt; i) {
                swap(arr, i, min);
            }
        }
        return&lt;span&gt; arr;
    }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;简单选择排序的思想很简单，代码也很清晰就不多加赘述。&lt;/p&gt;
&lt;p&gt;复杂度： 从简单选择排序的过程来看，它最大的特点就是交换移动数据次数相当少，这样也就节约了相应的时间，分析它的时间复杂度发现，无论最好最差情况，其比较次数都是一样多的，第i趟排序需要进行 n-1 次关键字的比较，此时需要比较n-1+n-2+...+1 = n(n-1)/2次。而对于交换次数而言，当最好情况，交换次数为0，最差情况，也就是逆序时，交换次数n-1次，基于最终的排序时间是比较与交换次数的综合，因此总的时间复杂度依然为O(n&lt;sup&gt;2&lt;/sup&gt;).&lt;/p&gt;
&lt;p&gt;应该说，尽管与冒泡排序同为O(n&lt;sup&gt;2&lt;/sup&gt;),但简单选择排序的性能上还是要略由于冒泡排序的。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;3.直接插入排序&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;基本思想：&lt;/strong&gt;将一个记录插入到已经排序的有序表中，从而得到一个新的、记录数增1的有序表&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
private int[] insertSort(int&lt;span&gt;[] arr) {
        int temp = 0&lt;span&gt;;
        int j = 0&lt;span&gt;;
        for (int i = 1; i &amp;lt; arr.length; i++&lt;span&gt;) {
            temp =&lt;span&gt; arr[i];
            for (j = i; j &amp;gt; 0 &amp;amp;&amp;amp; temp &amp;lt; arr[j-1]; j--&lt;span&gt;) {
                arr[j] = arr[j - 1&lt;span&gt;];// 假如temp比前面的值小，则将前面的值后移
            }
            arr[j] =&lt;span&gt; temp;
        }
        return&lt;span&gt; arr;
    }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;复杂度分析：&lt;/strong&gt;从控件上来看，它只需要一个记录的辅助空间。时间复杂度，O(n&lt;sup&gt;2&lt;/sup&gt;)但是性能比简单选择排序和冒泡排序要好一些。&lt;/p&gt;

&lt;h3&gt;4.希尔排序（缩小增量排序）&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;基本思想&lt;/strong&gt;：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
private int[] shellSort(int&lt;span&gt;[] arr) {
        int&lt;span&gt; j;
        int temp = 0&lt;span&gt;;
        //每次将步长缩小为1/2
        for (int d = arr.length / 2; d &amp;gt; 0; d /= 2&lt;span&gt;) {
            for (int i = d; i &amp;lt; arr.length; i++&lt;span&gt;) {
                temp =&lt;span&gt; arr[i];
                for (j = i; j &amp;gt;= d; j -=&lt;span&gt; d) {
                    if (temp &amp;lt; arr[j -&lt;span&gt; d]) {
                        arr[j] = arr[j -&lt;span&gt; d];
                    } else&lt;span&gt; {
                        break&lt;span&gt;;
                    }
                }
                arr[j] =&lt;span&gt; temp;
            }
        }
        return&lt;span&gt; arr;
    }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;时间复杂度O(n^1.5）&lt;/p&gt;

&lt;h3&gt;5.堆排序&lt;/h3&gt;
&lt;p&gt; 基本思想:堆排序（heap sort）就是利用堆进行排序的方法。将待排序的序列构造成一个堆。此时，整个序列的最大值就是堆顶的根节点。将它移走（其实就是将其与堆数组的末尾元素蒋欢，此时元素末尾就是最大值），然后将剩余的n-1个序列重新构造成一个堆，这样就会得到n个元素中的次大值。如此反复执行，便能得到一个有序序列了。&lt;/p&gt;
&lt;p&gt;按照这个思想来做，那么实际会有两个问题：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如何由一个无需序列构建成一个堆？&lt;/li&gt;
&lt;li&gt;如何再输出堆顶元素后，调整生于元素成为一个新的堆？&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[] heapSort(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] arr) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (i = arr.length / 2; i &amp;gt;= 0; i--) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;把arr构建成大顶堆&lt;/span&gt;
            heapAdjust(arr, i, arr.length - 1&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (i = arr.length - 1; i &amp;gt;= 0; i--&lt;span&gt;) {
            swap(arr, &lt;/span&gt;0, i);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将堆顶元素和当前未经排序子序列的最后一个记录交换&lt;/span&gt;
            heapAdjust(arr, 0, i - 1);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重新调整大顶堆&lt;/span&gt;
&lt;span&gt;        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; arr;
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; heapAdjust(&lt;span&gt;int&lt;/span&gt;[] arr, &lt;span&gt;int&lt;/span&gt; s, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; m) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;已知arr[s...m]中记录的关键字除了arr[s]之外均满足堆的定义
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;本函数调整arr[s]的关键字，使arr[s...m]成为一个大顶堆&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt;&lt;span&gt; temp, j;
        temp &lt;/span&gt;=&lt;span&gt; arr[s];
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (j = 2 * s; j &amp;lt;= m; j *= 2) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;沿关键字较大的孩子节点往下筛选&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (j &amp;lt; m &amp;amp;&amp;amp; arr[j] &amp;lt; arr[j + 1&lt;span&gt;]) {
                &lt;/span&gt;++j;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;j为关键字中较大的记录的下标&lt;/span&gt;
&lt;span&gt;            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (temp &amp;gt;=&lt;span&gt; arr[j]) {
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;应插入在位置s上&lt;/span&gt;
&lt;span&gt;            }
            arr[s] &lt;/span&gt;=&lt;span&gt; arr[j];
            s &lt;/span&gt;=&lt;span&gt; j;
        }
        arr[s] &lt;/span&gt;= temp;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;插入&lt;/span&gt;
    }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 时间复杂度O(nlogn）不适合待排序序列较少的情况&lt;/p&gt;

&lt;h3&gt;6.归并排序&lt;/h3&gt;
&lt;p&gt; 归并排序（merging sort）是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[] mergeSort(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] arr) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; mSort(arr, 0, arr.length - 1&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[] mSort(&lt;span&gt;int&lt;/span&gt;[] arr, &lt;span&gt;int&lt;/span&gt; low, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; high) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; mid = (low + high) / 2&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (low &amp;lt;&lt;span&gt; high) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;左边&lt;/span&gt;
&lt;span&gt;            mSort(arr, low, mid);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;右边&lt;/span&gt;
            mSort(arr, mid + 1&lt;span&gt;, high);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;左右归并&lt;/span&gt;
&lt;span&gt;            merge(arr, low, mid, high);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; arr;
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; merge(&lt;span&gt;int&lt;/span&gt;[] arr, &lt;span&gt;int&lt;/span&gt; low, &lt;span&gt;int&lt;/span&gt; mid, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; high) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;[] temp = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[high - low + 1&lt;span&gt;];
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i = low;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 左指针&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; j = mid + 1;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 右指针&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; k = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 把较小的数先移到新数组中&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt; (i &amp;lt;= mid &amp;amp;&amp;amp; j &amp;lt;=&lt;span&gt; high) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (arr[i] &amp;lt;&lt;span&gt; arr[j]) {
                temp[k&lt;/span&gt;++] = arr[i++&lt;span&gt;];
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                temp[k&lt;/span&gt;++] = arr[j++&lt;span&gt;];
            }
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 把左边剩余的数移入数组&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt; (i &amp;lt;=&lt;span&gt; mid) {
            temp[k&lt;/span&gt;++] = arr[i++&lt;span&gt;];
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 把右边边剩余的数移入数组&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt; (j &amp;lt;=&lt;span&gt; high) {
            temp[k&lt;/span&gt;++] = arr[j++&lt;span&gt;];
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 把新数组中的数覆盖nums数组&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (temp.length &amp;gt;= 0) System.arraycopy(temp, 0&lt;span&gt;, arr, low, temp.length);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;时间复杂度O(nlogn）&lt;/p&gt;
&lt;h3&gt;7.快速排序&lt;/h3&gt;
&lt;p&gt; 基本思想：分治&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[] quickSort(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] arr) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; qSort(arr, 0, arr.length - 1&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[] qSort(&lt;span&gt;int&lt;/span&gt;[] arr, &lt;span&gt;int&lt;/span&gt; low, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; high) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (low &amp;lt;&lt;span&gt; high) {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; pivotPos = partition(arr, low, high);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;划分&lt;/span&gt;
            qSort(arr, low, pivotPos - 1&lt;span&gt;);
            qSort(arr, pivotPos &lt;/span&gt;+ 1&lt;span&gt;, high);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; arr;
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; partition(&lt;span&gt;int&lt;/span&gt;[] arr, &lt;span&gt;int&lt;/span&gt; low, &lt;span&gt;int&lt;/span&gt; high) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;一趟排序过程&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; pivot = arr[low];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将当前表的第一个元素作为枢轴值，对表进行划分&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt; (low &amp;lt; high) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;循环跳出条件&lt;/span&gt;
            &lt;span&gt;while&lt;/span&gt; (low &amp;lt; high &amp;amp;&amp;amp; arr[high] &amp;gt;= pivot) --&lt;span&gt;high;
            arr[low] &lt;/span&gt;= arr[high];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将比pivot小的移到左侧&lt;/span&gt;
            &lt;span&gt;while&lt;/span&gt; (low &amp;lt; high &amp;amp;&amp;amp; arr[low] &amp;lt;= pivot) ++&lt;span&gt;low;
            arr[high] &lt;/span&gt;= arr[low];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将比pivot大的移到右侧&lt;/span&gt;
&lt;span&gt;        }
        arr[low] &lt;/span&gt;= pivot;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;枢轴元素存放到最终位置&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; low;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回枢轴的最终位置&lt;/span&gt;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;时间复杂度O(nlogn）&lt;/p&gt;
&lt;p&gt;快速排序在序列中元素很少时，效率将比较低，不如插入排序，因此一般在序列中元素很少时使用插入排序，这样可以提高整体效率。&lt;/p&gt;

</description>
<pubDate>Wed, 01 May 2019 15:22:00 +0000</pubDate>
<dc:creator>Ivo-oo</dc:creator>
<og:description>1.冒泡排序 最简单的排序实现，冒泡排序，是一种交换排序，它的基本思想是：两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止。 swap方法 冒泡算法的优化（外部循环优化） 代码改动的关</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ivoo/p/10794197.html</dc:identifier>
</item>
<item>
<title>Webpack &amp; The Hot Module Replacement热模块替换原理解析 - 宇的季节</title>
<link>http://www.cnblogs.com/chenkeyu/p/10801197.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenkeyu/p/10801197.html</guid>
<description>&lt;p class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;The Hot Module Replacement(HMR)俗称热模块替换。主要用来当代码产生变化后，可以在不刷新游览器的情况下对局部代码块进行替换更新。这在很多情况下都很有用，例如在处理弹出框时，使用HMR可以及时的看到变化，如果用刷新游览器的方式会回到初始页面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;很多人使用过HMR却不知道它是如何工作的，这里会对HMR实现原理进行解析。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;关于HMR需要知道的一些事&lt;/span&gt;&lt;/h2&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;2&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;HMR是Webpack的一个可选功能，如果想使用需要主动打开。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;需要通过webpack-dev-server方式来管理webpack（另一种方式是CLI）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;HMR只能工作在实现了HMR API的loaders里，例如：‘style-loader’,'react-hot-loader'&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;HMR只能在开发环境中使用，因为HMR会在打包的js中添加了很多额外的代码，并且webpack-dev-server也只用于开发环境。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;HMR工作原理&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;webpack会在打包的js中注入很多js库来让HMR工作，下图展示了当一个文件发生变化是HMR是如何工作的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;15&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;图片颜色说明：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;紫色：发生改变的js或者css文件&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;橘色：发生变化的代码块说明，变化后的代码块内容&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;彩兰色：项目代码&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;绿色：webpack-dev-server相关的库，有图中可以发现，webpack-dev-server主要负责server端和游览器端的通信。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;蓝色：webpack核心和插件库，由图中可以发现，server端代码的监听以及游览器端新代码的替换都是由webpack的不同模块处理。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;红色：react-loader或者style-loader等HMR库&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;/home/chenkeyu/Desktop/webpack-HMR/HMR-work.png&quot;&gt;&lt;img src=&quot;file:///home/chenkeyu/Desktop/webpack-HMR/HMR-work.png?lastModify=1556722872&quot; alt=&quot;&quot; data-local-refresh=&quot;true&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1003414/201905/1003414-20190501230730384-714203554.png&quot; alt=&quot;&quot; width=&quot;1224&quot; height=&quot;905&quot;/&gt; &lt;/p&gt;
&lt;h2&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;执行流程：&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;ol class=&quot;ol-list&quot; start=&quot;&quot; readability=&quot;6&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;当监听到文件发生变化时，webpack 使用HotModuleReplacementPlugin生成一个mainifest（一个json结构描述了发生变化的modules列表）和update file（一个js文件包含修改后的代码内容）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;webpack将上述变化信息告诉webpack-dev-server&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;webpack-dev-server通过webSocket给运行在游览器上的‘webpack-dev-server/client’（在打包时注入的js代码）发送一条‘invalide’信息以及更新后代码的hash值（该hash值本次不会用到，使用上一版本的hash值）.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;’webpack-dev-server/client’会将上一版本代码的hash传递给“hot/dev-server”&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;‘hot/dev-server’使用JsonpRuntime向server端发送带有上版本hash的ajax请求，server端返回一个json，该json包含要所有要更新的模块的hash值。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;JsonpRuntime根据返回的json值使用jsonp请求具体的代码块，jsonp返回的js代码类似下面:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;md-fences md-end-block contain-cm modeLoaded&quot;&gt;
&lt;span&gt;&lt;span class=&quot;cm-variable&quot;&gt;webpackHotUpdate(&lt;span class=&quot;cm-number&quot;&gt;0,&lt;br/&gt;&lt;span&gt;{&lt;br/&gt;&lt;span&gt; &lt;span class=&quot;cm-number cm-property&quot;&gt;82:&lt;br/&gt;&lt;span&gt;  &lt;span class=&quot;cm-keyword&quot;&gt;function(&lt;span class=&quot;cm-def&quot;&gt;module, &lt;span class=&quot;cm-def&quot;&gt;exports, &lt;span class=&quot;cm-def&quot;&gt;__webpack_require__) {&lt;br/&gt;&lt;span&gt;    &lt;span class=&quot;cm-variable-2&quot;&gt;exports &lt;span class=&quot;cm-operator&quot;&gt;= &lt;span class=&quot;cm-variable-2&quot;&gt;module.&lt;span class=&quot;cm-property&quot;&gt;exports &lt;span class=&quot;cm-operator&quot;&gt;= &lt;span class=&quot;cm-variable-2&quot;&gt;__webpack_require__(&lt;span class=&quot;cm-number&quot;&gt;79)();&lt;br/&gt;&lt;span&gt;    &lt;span class=&quot;cm-variable-2&quot;&gt;exports.&lt;span class=&quot;cm-property&quot;&gt;push([&lt;span class=&quot;cm-variable-2&quot;&gt;module.&lt;span class=&quot;cm-property&quot;&gt;id, &lt;span class=&quot;cm-variable&quot;&gt;“input {\&lt;span class=&quot;cm-variable&quot;&gt;n &lt;span class=&quot;cm-variable&quot;&gt;background: &lt;span class=&quot;cm-variable&quot;&gt;pink;\&lt;span class=&quot;cm-variable&quot;&gt;n}&lt;span class=&quot;cm-variable&quot;&gt;”, &lt;span class=&quot;cm-variable&quot;&gt;“”])&lt;br/&gt;&lt;span&gt;  }&lt;br/&gt;&lt;span&gt;})&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;ol class=&quot;ol-list&quot; start=&quot;7&quot; readability=&quot;0.5&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;代码会调用webpackHotUpdate方法并携带module_id和具体修改内容。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;HMR runtime本身并不会处理代码修改，它会将不同文件交给对应的loader runtime处理（例如：react-hot-loader runtime 或者 style-loader runtime）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;如果更新失败，会回退刷新游览器获取最新代码。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;示例&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;当游览器首次加载app时，server端会推送当前代码版本号current_hash。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1003414/201905/1003414-20190501230848097-1235451730.png&quot; alt=&quot;&quot; width=&quot;698&quot; height=&quot;167&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1003414/201905/1003414-20190501230913560-745982165.png&quot; alt=&quot;&quot; width=&quot;695&quot; height=&quot;177&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;/tmp/1556706513655.png&quot;&gt;&lt;img src=&quot;file:///tmp/1556706513655.png?lastModify=1556722872&quot; alt=&quot;&quot; data-local-refresh=&quot;true&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;/tmp/1556706478171.png&quot;&gt;&lt;img src=&quot;file:///tmp/1556706478171.png?lastModify=1556722872&quot; alt=&quot;&quot; data-local-refresh=&quot;true&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;当修改style文件后，server端HotModuleReplacementPlugin会根据更新内容生成manifest和js文件,文件名根据current_hash生成，然后更新current_hash，并将新的hash值推送给游览器端，用作下次更新。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1003414/201905/1003414-20190501231025996-890480559.png&quot; alt=&quot;&quot; width=&quot;639&quot; height=&quot;233&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1003414/201905/1003414-20190501231050296-1892570385.png&quot; alt=&quot;&quot; width=&quot;643&quot; height=&quot;171&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;/tmp/1556706725270.png&quot;&gt;&lt;img src=&quot;file:///tmp/1556706725270.png?lastModify=1556722872&quot; alt=&quot;&quot; data-local-refresh=&quot;true&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;游览器端webpack-dev-server/client接收到新的hash值后，会将previous hash值传递给webpack/hot/dev-server，dev-server根据previous hash请求具体的mainifest和js代码，并使用jsonp更新。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;/tmp/1556706915712.png&quot;&gt;&lt;img src=&quot;file:///tmp/1556706915712.png?lastModify=1556722872&quot; alt=&quot;&quot; data-local-refresh=&quot;true&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1003414/201905/1003414-20190501231131835-2117602168.png&quot; alt=&quot;&quot; width=&quot;660&quot; height=&quot;231&quot;/&gt;&lt;img src=&quot;file:///tmp/1556706838673.png?lastModify=1556722872&quot; alt=&quot;&quot; data-local-refresh=&quot;true&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;参考文档：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://medium.com/@rajaraodv/webpack-hot-module-replacement-hmr-e756a726a07&quot;&gt;&lt;span&gt;Webpack &amp;amp; The Hot Module Replacement&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/30669007&quot;&gt;Webpack HMR原理解析&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 01 May 2019 15:13:00 +0000</pubDate>
<dc:creator>宇的季节</dc:creator>
<og:description>Webpack &amp; The Hot Module Replacement热模块替换原理解析 The Hot Module Replacement(HMR)俗称热模块替换。主要用来当代码产生变化</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenkeyu/p/10801197.html</dc:identifier>
</item>
<item>
<title>软件工程专业毕业到底能做什么工作？考研还是工作？ - 二十四向风</title>
<link>http://www.cnblogs.com/hwtblog/p/10801130.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hwtblog/p/10801130.html</guid>
<description>&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;有很多刚刚踏入软件工程专业的学生或许对该专业还不太熟悉，不知道自己的努力方向，没有想好自己未来的路怎么走，如何走。&lt;/p&gt;
&lt;p&gt;没错，我原来就是其中的一员。当我真正将要踏入社会的那一刻，在写简历的那一刻，我才明白自己的大学生活缺少了什么。以下的内容只是我个人对这个行业的一点理解和一些建议。希望能帮助那些刚刚进入这个专业的学弟学妹们。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;-1&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;该文主要分为三大部分&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;互联网行业相关工作分类及描述&lt;/li&gt;
&lt;li&gt;考研还是工作？&lt;/li&gt;
&lt;li&gt;一些零散的宝贵经验（给学弟学妹们的）&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;-2&quot;&gt;一、互联网行业相关工作分类及描述&lt;/h2&gt;
&lt;p&gt;其他的学校我不知道，我们学校在大三的时候开过一门《职业生涯规划》的课。下面的内容也是我作业的一部分，就是探讨软件工程行业的工作选择的。&lt;/p&gt;
&lt;p&gt;简单分成两大类：技术类和非技术类&lt;/p&gt;
&lt;h3 id=&quot;1&quot;&gt;1、技术类&lt;/h3&gt;
&lt;h4 id=&quot;11&quot;&gt;1.1 前端&lt;/h4&gt;
&lt;p&gt;主要做的工作是用代码写出展示界面和一些特效。需要说明一点，不知道其他公司是怎么分类微信开发的，我们公司把微信开发（小程序开发）归入到了前端部分。总体来说前后端薪资都是差不多的。&lt;/p&gt;
&lt;p&gt;前端联系比较紧密的是&lt;strong&gt;UI设计师&lt;/strong&gt;。但是UI设计师相关的知识软件工程大多是不教的。UI设计师的工作就是设计出比较好看的界面和图标，合理的页面布局等，需要掌握一些专业的设计软件。有兴趣的可以自行谷歌学习。另外，我们在大三的时候学过一门《界面设计》的课，还是很不错的。建议学弟学妹们好好听一听。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pqtjk9wb5.bkt.clouddn.com/2019%E5%B9%B44%E6%9C%8830%E6%97%A5-%E4%BA%92%E8%81%94%E7%BD%91%E8%A1%8C%E4%B8%9A%E5%88%86%E6%9E%901556612005892.png&quot; alt=&quot;1556612005892&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;12&quot;&gt;1.2 后端&lt;/h4&gt;
&lt;p&gt;后端的工作需求也是比较多的，我对后端的理解就是完成系统所需的功能。你可以理解为前端定义了一个东西长得怎么样，后端定义了这个东西有什么功能。&lt;/p&gt;
&lt;p&gt;不想吹Java，但是现实是Java的需求量真的很大。当然也有C++，python工程师，就我们这一届来说，除了Java外这两个方向的职位也有看到，只是比较少罢了。&lt;/p&gt;
&lt;p&gt;因为我现在的职位就是Java后端工程师，虽然是在一个初创型公司，但是开发规范还是不错的，在公司能跟着大佬学习很多。不得不说Java后端需要掌握的东西实在太多了。需要详细了解的可以关注我微信公众号，里面有我的联系方式，希望结交一些小伙伴一起学习努力，哈哈哈&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pqtjk9wb5.bkt.clouddn.com/2019%E5%B9%B44%E6%9C%8830%E6%97%A5-%E4%BA%92%E8%81%94%E7%BD%91%E8%A1%8C%E4%B8%9A%E5%88%86%E6%9E%901556612045223.png&quot; alt=&quot;1556612045223&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;13android&quot;&gt;1.3 Android&lt;/h4&gt;
&lt;p&gt;说一说移动端开发，前几年移动端开发人特别多，导致了需求量过剩。所以到我们这一届，移动端人才特别缺，移动端开发工资特别高。不得不说如果打算就业工作，选对方向真的很重要（2019届算法和后端竞争比较大）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pqtjk9wb5.bkt.clouddn.com/2019%E5%B9%B44%E6%9C%8830%E6%97%A5-%E4%BA%92%E8%81%94%E7%BD%91%E8%A1%8C%E4%B8%9A%E5%88%86%E6%9E%901556707251971.png&quot; alt=&quot;1556707251971&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;14ios&quot;&gt;1.4 IOS&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://pqtjk9wb5.bkt.clouddn.com/2019%E5%B9%B44%E6%9C%8830%E6%97%A5-%E4%BA%92%E8%81%94%E7%BD%91%E8%A1%8C%E4%B8%9A%E5%88%86%E6%9E%901556707279238.png&quot; alt=&quot;1556707279238&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;15&quot;&gt;1.5 游戏开发&lt;/h4&gt;
&lt;p&gt;游戏的开发，我对具体的工作还是了解的不深，有兴趣的可以自己搜索相关资料&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pqtjk9wb5.bkt.clouddn.com/2019%E5%B9%B44%E6%9C%8830%E6%97%A5-%E4%BA%92%E8%81%94%E7%BD%91%E8%A1%8C%E4%B8%9A%E5%88%86%E6%9E%901556707323646.png&quot; alt=&quot;1556707323646&quot;/&gt;&lt;/p&gt;
&lt;p&gt;除了上述的开发的相关工作，一些其他的工作也属于技术岗位，虽然也需要一定的编码水平，但是需要掌握一些其他的特殊技能&lt;/p&gt;
&lt;h4 id=&quot;16&quot;&gt;1.6 人工智能与深度学习工程师&lt;/h4&gt;
&lt;p&gt;感觉这个工作主要招的都是研究生，毕竟是比较高端的技术，对应的薪资也是较高的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pqtjk9wb5.bkt.clouddn.com/2019%E5%B9%B44%E6%9C%8830%E6%97%A5-%E4%BA%92%E8%81%94%E7%BD%91%E8%A1%8C%E4%B8%9A%E5%88%86%E6%9E%901556707496183.png&quot; alt=&quot;1556707496183&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;17&quot;&gt;1.7 运维&lt;/h4&gt;
&lt;p&gt;个人感觉这个工作非常苦逼，枯燥没意思。运维的工作就是把开发好的项目在服务器上部署发布和长期的运行维护，需要精通熟悉linux系统。一般小公司是没有运维的~，没错，你猜对了。在小公司这部分的工作是交给开发来做的，项目无论在线上除了什么故障都来找开发，有点难受。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pqtjk9wb5.bkt.clouddn.com/2019%E5%B9%B44%E6%9C%8830%E6%97%A5-%E4%BA%92%E8%81%94%E7%BD%91%E8%A1%8C%E4%B8%9A%E5%88%86%E6%9E%901556707585657.png&quot; alt=&quot;1556707585657&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;18&quot;&gt;1.8网络安全分析师&lt;/h4&gt;
&lt;p&gt;这个工作呢？需要掌握网络安全的相关知识，但是你要知道在本科阶段学校教给你的东西，在这方面是完全不够的，如果真的对这方面非常感兴趣，可以自己搜索相关知识，多多参加相关比赛，或者是项目等&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pqtjk9wb5.bkt.clouddn.com/2019%E5%B9%B44%E6%9C%8830%E6%97%A5-%E4%BA%92%E8%81%94%E7%BD%91%E8%A1%8C%E4%B8%9A%E5%88%86%E6%9E%901556708034258.png&quot; alt=&quot;1556708034258&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;19&quot;&gt;1.9 软件测试&lt;/h4&gt;
&lt;p&gt;软件测试是一个非常关键的一个工作，其实软件测试的工作分为两种，一种是&lt;strong&gt;测试工程师&lt;/strong&gt;，另一种叫做&lt;strong&gt;测试开发工程师&lt;/strong&gt;，&lt;/p&gt;
&lt;p&gt;其实在本质上这是两个本质不太相同的职位。&lt;/p&gt;
&lt;p&gt;测试工程师是偏重业务逻辑的测试，即功能性测试，说白了就是说某个功能好不好使。写代码能力不强也不要紧。&lt;/p&gt;
&lt;p&gt;测试开发工程师是开发人员，比较偏重自动化测试工具的开发。&lt;/p&gt;
&lt;p&gt;总结：国外的软件行业是把软件测试环节看的非常重要的，软件的测试环节也有一系列的严格的步骤，不知道其他的学校，反正在我们学校会开一门《软件测试》的课，我感觉非常不错，教材使用的也非常好。但是在国内的话只有大厂的测试环节会比较好。总体来说测试也是一个非常好的行业，压力也不是太大（当然是相对于开发来说）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pqtjk9wb5.bkt.clouddn.com/2019%E5%B9%B44%E6%9C%8830%E6%97%A5-%E4%BA%92%E8%81%94%E7%BD%91%E8%A1%8C%E4%B8%9A%E5%88%86%E6%9E%901556708215767.png&quot; alt=&quot;1556708215767&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;2&quot;&gt;2、非技术类&lt;/h3&gt;
&lt;h4 id=&quot;21&quot;&gt;2.1 产品经理&lt;/h4&gt;
&lt;p&gt;产品经理的工作简单的讲就是决定了一个产品的发展。可以把产品经理比作导演，把程序员比作演员。导演决定了一部戏的发展走向，而演员是具体实施者。一个好的产品经理必须是一个好的交流者。说到这里我已经迫不及待的想和产品互怼了(〃'▽'〃)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pqtjk9wb5.bkt.clouddn.com/2019%E5%B9%B44%E6%9C%8830%E6%97%A5-%E4%BA%92%E8%81%94%E7%BD%91%E8%A1%8C%E4%B8%9A%E5%88%86%E6%9E%901556716887356.png&quot; alt=&quot;1556716887356&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;22&quot;&gt;2.2产品运营&lt;/h4&gt;
&lt;p&gt;负责产品的运营，平时和用户沟通的比较多。如果产品运营对现有的系统有不满，需要制定新功能的话，需要和产品经理研究，制定统一的解决方案。之后产品经理需要和技术部门经理讨论方案，选择最优的方案，最后制定开发任务&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pqtjk9wb5.bkt.clouddn.com/2019%E5%B9%B44%E6%9C%8830%E6%97%A5-%E4%BA%92%E8%81%94%E7%BD%91%E8%A1%8C%E4%B8%9A%E5%88%86%E6%9E%901556717453578.png&quot; alt=&quot;1556717453578&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;3&quot;&gt;3、总结&lt;/h3&gt;
&lt;p&gt;简单画一个图来说明一下各个人员在一个产品流程中的角色，当然这只是一个简单的图，现实中可能会有各种问题，大的公司流程可能会更多（如果有误，希望大佬给出宝贵意见）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pqtjk9wb5.bkt.clouddn.com/2019%E5%B9%B44%E6%9C%8830%E6%97%A5-%E4%BA%92%E8%81%94%E7%BD%91%E8%A1%8C%E4%B8%9A%E5%88%86%E6%9E%901556718489667.png&quot; alt=&quot;1556718489667&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;-3&quot;&gt;二、考研还是工作？&lt;/h2&gt;
&lt;p&gt;这个我不想多说，因为我也是刚刚毕业参加工作，没有真正体会到考研和工作的利弊。&lt;/p&gt;
&lt;p&gt;先说下我的观点：&lt;strong&gt;无论选择哪条道路，相信自己的决定是正确的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;直接上知乎大佬的回答，可以做下参考&lt;/p&gt;
&lt;h3 id=&quot;-4&quot;&gt;回答一&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;作者：Shengsheng&lt;/p&gt;
&lt;p&gt;链接：https://www.zhihu.com/question/60462553/answer/193112194&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;谢邀。是这样的，这个要看你怎么选择。&lt;strong&gt;如果你想以后不做开发，想做研究，甚至读博做教授，那么就读研读博吧&lt;/strong&gt;。如果你致力于成为一名软件工程师，想在工业界混，那么又要分情况来说了。&lt;/p&gt;
&lt;p&gt;安徽的211，只有安大和合工大，并不是什么很厉害的大学，跟985高校比起来还是差了一些。所以&lt;strong&gt;如果能够保研或者考研到985高校的，或者有条件出国留学的，可以考虑读研，但是这个只是为了拿到一块厉害一点的敲门砖&lt;/strong&gt;，你读研的成长，绝对比不上在公司里面的成长。有条件出国留学的，真的可以考虑出国留个学，在外面非常锻炼人。&lt;strong&gt;如果考不上985研究生，也没资格保研，也没法出国留学，那么就不要读研了。去公司工作，3年后你同学读研毕业了，但你可能升职了，就算不升值也积攒了3年的工作经验，你的水平会比你那些读研的同学强很多。&lt;/strong&gt;实际上，有了3年的工业界经验，你也不需要985、留学生什么的敲门砖了。另外，楼主说进不了BAT什么的...请充满信心，努力试一把，才知道究竟能不能进BAT啊。&lt;/p&gt;
&lt;p&gt;答主本科也是软件工程专业，虽然现在在读研，但读的是兼职的，白天都在工作，晚上才会抽时间弄一下学业上的事情。&lt;strong&gt;对比我在工作中的收获和在读研中的收获，我觉得读研给我的收获几乎可以忽略不计&lt;/strong&gt;...在工作中我学会了怎么从零开始构建分布式微服务架构，怎么调优接口提高并发量，怎么应对产品上线(表示每次上线都要跟同事奋战到第二天凌晨T^T...)，怎么跟上级、同事沟通，等等等等...&lt;strong&gt;这些东西，不是在工业界做一线开发，根本接触不到，或者不会去想&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我本科同学有不少去985高校读研的，从他们那里我多少了解了一些国内读研的现状。我只想说，国内985研究生好水(当然跟学校有关系)...我同学研一就想出来工作了...&lt;strong&gt;不光教的课比较古董，老师的项目大多也都是以demo为主，很少有真正商用的，团队里面也几乎没有在工业界工作过的人。&lt;/strong&gt;所以我想问，读研除了可以拿一块证书之外，能学到多少真正有用的东西？&lt;/p&gt;
&lt;h3 id=&quot;-5&quot;&gt;回答二&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;作者：菜根谭&lt;/p&gt;
&lt;p&gt;链接：https://www.zhihu.com/question/60462553/answer/186812668&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看到好多小朋友 我就想老司机开车 软件工程 本科 工作十年 一贯的风格是告诉你们很多利弊 但是这次准备直接排序 站在我的经验和判断&lt;/p&gt;
&lt;p&gt;\1. 名校研究生（清华 交大 中科院 中大 北邮） 机器学习和人工智能方向优先 \2. 真实实习 bat一流公司工作 \3. 重点学校研究生&lt;/p&gt;
&lt;p&gt;\4. 实习 毕业 \5. 毕业&lt;/p&gt;
&lt;p&gt;选择要有目的 多提供几个衡量目的的角度&lt;/p&gt;
&lt;p&gt;出国看世界与否？&lt;/p&gt;
&lt;p&gt;一线城市户口否？&lt;/p&gt;
&lt;p&gt;兴趣爱好匹配否？&lt;/p&gt;
&lt;p&gt;女朋友，家庭？&lt;/p&gt;
&lt;p&gt;职业目标IC还是管理还是创业？&lt;/p&gt;
&lt;h2 id=&quot;-6&quot;&gt;三、一些零散的宝贵经验（给学弟学妹们的）&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;大三下学期大公司正在春招，招很多实习生，实习生的岗位相对来说还是比较好得到的。如果能够拿到大公司的实习生岗位，对将来招工作和考研都是比较重要的。但是大公司往往在北上广深，对其他外地学校的学生来说还是不太友好，毕竟大三往往还有课。如果不能去实习的话，建议大三下学期就开始准备找工作的材料，好好准备秋招。&lt;/li&gt;
&lt;li&gt;学好算法，可以在秋招中脱颖而出，建议去刷LeetCode，很多公司的笔试题都是LeetCode的原题。注意！！！不要误认为自己有开发经验就不去准备这一部分。实际情况是如果你过不了笔试，你连面试的机会都没有~ 没错，现实就是如此残酷，我在这方面就吃了很大的亏。另外可以牛客网刷一些题。如果想要了解更多这方面的东西，可以到我公众号里留言私信我，如果人多的话，我就再写一些这方面的东西。&lt;/li&gt;
&lt;li&gt;必须有项目经验，无论项目大小，保证项目的完整性&lt;/li&gt;
&lt;li&gt;多参加学校的技术性比赛，无论是什么样的，你会慢慢在比赛中认识到自己想要什么&lt;/li&gt;
&lt;li&gt;简单总结了一下软件工程专业必备的基本知识素养（如下图），比较惭愧的是一下知识我有大部分都掌握的一般般。希望学弟学妹们不要向我学习&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://pqtjk9wb5.bkt.clouddn.com/2019%E5%B9%B44%E6%9C%8830%E6%97%A5-%E4%BA%92%E8%81%94%E7%BD%91%E8%A1%8C%E4%B8%9A%E5%88%86%E6%9E%90%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%8A%80%E8%83%BD%E5%9B%BE%E8%B0%B1.png&quot; alt=&quot;软件工程技能图谱&quot;/&gt;&lt;/p&gt;

&lt;p&gt;如果想获取上方所有完整的思维导图，可以关注我的公众号回复【思维导图之软件工程】即可获取，有其他想法也可在我公众号里留言大家一起进步学习&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
</description>
<pubDate>Wed, 01 May 2019 14:51:00 +0000</pubDate>
<dc:creator>二十四向风</dc:creator>
<og:description>有很多刚刚踏入软件工程专业的学生或许对该专业还不太熟悉，不知道自己的努力方向，没有想好自己未来的路怎么走，如何走。 没错，我原来就是其中的一员。当我真正将要踏入社会的那一刻，在写简历的那一刻，我才明白</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hwtblog/p/10801130.html</dc:identifier>
</item>
<item>
<title>一种简单高效的音频降噪算法示例(附完整C代码) - cpuimage</title>
<link>http://www.cnblogs.com/cpuimage/p/10800768.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cpuimage/p/10800768.html</guid>
<description>&lt;p&gt;近期比较忙,&lt;/p&gt;
&lt;p&gt;抽空出来5.1开源献礼.&lt;/p&gt;
&lt;p&gt;但凡学习音频降噪算法的朋友,肯定看过一个算法.&lt;/p&gt;
&lt;p&gt;&amp;lt;&amp;lt;语音增强-理论与实践&amp;gt;&amp;gt; 中提及到基于对数的最小均方误差的降噪算法,也就是LogMMSE.&lt;/p&gt;
&lt;p&gt;资料见:&lt;/p&gt;
&lt;p&gt;&amp;lt;&amp;lt;Speech enhancement using a minimum  mean-square error log-spectral amplitude estimator.&amp;gt;&amp;gt; &lt;/p&gt;
&lt;p&gt;-----Ephraim, Y. and Malah, D. (1985)&lt;/p&gt;
&lt;p&gt;之前也是花了不少时间去查阅降噪相关的思路,&lt;/p&gt;
&lt;p&gt;但是最终发现前人的思路,有很多局限性或者说弊端.&lt;/p&gt;
&lt;p&gt;一般都是提出一种数学先验的假设,换句话说,在paper里讲点故事.&lt;/p&gt;
&lt;p&gt;然后最终,故事的结局都是it works.&lt;/p&gt;
&lt;p&gt;但实际应用却差强人意.&lt;/p&gt;

&lt;p&gt; 而一般的图像降噪流程,见图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/824862/201905/824862-20190501222759528-1102983502.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也就是,一个降噪算法的基本组成部分有:&lt;/p&gt;
&lt;p&gt;1.噪声提取(用于提取噪声)&lt;/p&gt;
&lt;p&gt;2.静音检测(一般检测是否为人声,减少误判)&lt;/p&gt;
&lt;p&gt;3.数学先验假设(用于降噪)&lt;/p&gt;

&lt;p&gt;当然最小均方误差的降噪思路,用在图像上一样适用.&lt;/p&gt;

&lt;p&gt;但是,大多数音频降噪算法仅仅适配某种特殊情况(特例).&lt;/p&gt;
&lt;p&gt;工程化应用时,会发现,&lt;/p&gt;
&lt;p&gt;一个坑接着一个坑,&lt;/p&gt;
&lt;p&gt;然后不得不妥协.勉强能用就行,&lt;/p&gt;
&lt;p&gt;要求太高不现实.&lt;/p&gt;

&lt;p&gt;而当年看了logMMSE的思路之后,就很清楚地明白,&lt;/p&gt;
&lt;p&gt;这思路是可行的,但是特别鸡肋.&lt;/p&gt;

&lt;p&gt;话说如此,但是对作为学习信号处理,音频降噪来说,&lt;/p&gt;
&lt;p&gt;这个是一个特别好的入门示例算法.&lt;/p&gt;
&lt;p&gt;至少经过实践之后,你心中能有了个大概的印象.&lt;/p&gt;
&lt;p&gt;音频降噪是一个什么样的工作,会碰到什么样的难点.&lt;/p&gt;

&lt;p&gt; logmmse的各种实现,在github搜索一下,都能找得到.&lt;/p&gt;
&lt;p&gt;这里,并不打算解析logmmse的算法细节.&lt;/p&gt;

&lt;p&gt;只是分享一段非常简单有效的类似logmmse算法的c语言实现.&lt;/p&gt;
&lt;p&gt;说是类似,不如说,&lt;/p&gt;
&lt;p&gt;思路来自logmmse,只是更加的简洁明了.(自我以为)&lt;/p&gt;
&lt;p&gt;自己动手,丰衣足食.&lt;/p&gt;
&lt;p&gt;稍微改进一下,可以进一步适配各种环境和情况,&lt;/p&gt;
&lt;p&gt;当然也不是那么容易,&lt;/p&gt;
&lt;p&gt;例如:&lt;/p&gt;
&lt;p&gt;+vad.&lt;/p&gt;
&lt;p&gt;+延时记忆机制诸如此类&lt;/p&gt;

&lt;p&gt;代码基于本人最近开源的基于傅里叶变换的重采样算法.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/cpuimage/FFTResampler&quot; target=&quot;_blank&quot;&gt;https://github.com/cpuimage/FFTResampler&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;题外话:&lt;/p&gt;
&lt;p&gt;在之前为了找各种重采样算法,费心死了.&lt;/p&gt;
&lt;p&gt;所以,写一个通用简洁的重采样算法是我的一个待办事项.&lt;/p&gt;
&lt;p&gt;重采样算法算是暂时结束了.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/cpuimage/resampler&quot;&gt;https://github.com/cpuimage/resampler&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/cpuimage/FFTResampler&quot; target=&quot;_blank&quot;&gt;https://github.com/cpuimage/FFTResampler&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这两个平时应该是够用了,&lt;/p&gt;
&lt;p&gt;下一步要继续做的话,&lt;/p&gt;
&lt;p&gt;可能就是音频超分辨率算法了.&lt;/p&gt;

&lt;p&gt;除了懒,没别的,能复用就复用了.&lt;/p&gt;
&lt;p&gt;回到主题上,这个简易的算法用来去除平稳噪声或底噪,是非常合适的,&lt;/p&gt;
&lt;p&gt;当然当前开源实现的算法,是非实时的,&lt;/p&gt;
&lt;p&gt;当然稍微改进下可以应用在实时的环境.&lt;/p&gt;

&lt;p&gt;值5.1放假之际,开源出来,给大家参考学习.&lt;/p&gt;
&lt;p&gt;权当抛砖引玉,一起玩耍.&lt;/p&gt;

&lt;p&gt;项目地址:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/cpuimage/SimpleAudioDenoise&quot;&gt;https://github.com/cpuimage/SimpleAudioDenoise&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;br class=&quot;Apple-interchange-newline&quot;/&gt;
若有其他相关问题或者需求也可以邮件联系俺探讨。&lt;/p&gt;
&lt;p&gt;当然一些基础性的问题,一概忽略.&lt;/p&gt;
&lt;p&gt;有时间给我写邮件,不如多看点资料书籍.&lt;/p&gt;

&lt;p&gt;邮箱地址是: &lt;br/&gt;gaozhihan@vip.qq.com&lt;/p&gt;
</description>
<pubDate>Wed, 01 May 2019 14:50:00 +0000</pubDate>
<dc:creator>cpuimage</dc:creator>
<og:description>近期比较忙, 抽空出来5.1开源献礼. 但凡学习音频降噪算法的朋友,肯定看过一个算法. &lt;&lt;语音增强-理论与实践&gt;&gt; 中提及到基于对数的最小均方误差的降噪算法,也就是LogMM</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cpuimage/p/10800768.html</dc:identifier>
</item>
<item>
<title>如何写工程代码——重新认识面向对象 - 暮夜望日</title>
<link>http://www.cnblogs.com/scau-chm/p/10800885.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/scau-chm/p/10800885.html</guid>
<description>&lt;p&gt;工作一年，维护工程项目的同时一直写CURD，最近学习DDD，结合之前自己写的开源项目，深思我们这种CURD的编程方式的弊端，和朋友讨论后，发现我们从来没有面向对象开发，所以写这篇文章，希望更多人去思考面向对象，不只是停留在背书上&lt;/p&gt;
&lt;p&gt;下面以开发一个常规的登录模块为例，模拟实现一个登录功能，一步步地去说明其中的弊端和重新解释面向对象&lt;/p&gt;
&lt;h2 id=&quot;常规的开发方式&quot;&gt;常规的开发方式&lt;/h2&gt;
&lt;p&gt;创建模型&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Data
@NoArgsConstructor
class User{
    private Integer Id;
    private String name;
    private String password;//加密过的密码
  private Integer status;//账号状态
}

class UserRepository{
  User getByName(String name);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们都知道mvc，所以会这么写&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class UserController{
    @RequestMapping(&quot;/login&quot;)
    public void login(String name,String password){
        userService.login(name,password);
    }
}

class UserService{
    public void login(String name,String password);
}

class UserServiceImpl implements UserService{
    public void login(String name,String password){
        //1.查出这个用户
        User user = userRepo.getByName(name);
    //2.检查状态
    if(user.getStatus()!=1){
      //登录失败
    }
    //3.检查密码
    if(!Objects.equals(md5(password),user.getPassword())){
        //登录失败
    }
    //登录后续
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;虽然这个login方法有点丑，这还是没有打点，日志，生成登录态的情况下。我们所有的业务都写在了UserService里面，可能很多人不觉得这样写有什么问题。如果代码写多一点的程序员，可能会把每一步都抽成一个方法&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void login(String name,String password){
  //1.查出这个用户
  User user = userRepo.getByName(name);
  //2.检查状态
  checkUserStatus();
  //3.检查密码
  checkPassword();
  //登录后续
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样看是好看很多，但是换汤不换药，维护过工程项目的同学都会发现，项目里基本都是这种代码，维护起来成本极高：&lt;/p&gt;
&lt;ol readability=&quot;8.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;login方法被抽成几个方法，login方法是简单了，service却臃肿了&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;service臃肿后开始拆分service，再不济开始建立多一层manage之类的&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;复用极其困难，因为checkUserStatus这种方法往往是私有，并且这种抽离对其它业务场景是否合适也不好说&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;在代码开始出现冗余时，会开始写一些带有业务逻辑的Utils，把污染扩散到Utils&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;由于复用极其困难，开始出现多个类似功能的方法，分布在不同类里，后继维护项目的人很难分清类似方法的区别&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;因为不好统一表达语义，DTO等对象会在service层泛滥，controller和service耦合严重，导致分层变得没有意义&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;1，2其实是一个死循环，最后直接反映到项目难以维护上&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;在多数据源，多事务的情况下，难以确定事务边界，容易出现事务不能回滚的情况&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;单元测试的编写是个噩梦，尝试写单测的同学应该深有体会&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;为什么会这样呢？因为我们到这里为止，依然还是面向过程编程，完全没有面向对象的思维。代码其实都是堆起来，责任和边界不清晰，导致复用很难，维护变更的成本很高，所以项目经过多人维护后会变得更严重。唯一像面向对象的代码就是&lt;code&gt;User user = userRepo.getByName(name)这一句了&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;重新认识面向对象&quot;&gt;重新认识面向对象&lt;/h2&gt;
&lt;p&gt;为什么说这一句有面向对象的意味？因为这行含义十分明显，&lt;strong&gt;谁做了什么&lt;/strong&gt;，我觉得这是一个很好的判断原则，在scala里面，是可以把&lt;code&gt;a.do(thing)&lt;/code&gt;写成&lt;code&gt;a do thing&lt;/code&gt;，&lt;strong&gt;主语确定了责任，边界&lt;/strong&gt;。在这里，用户repo获取（生成）一个用户对象。虽然我们一直在说OO，什么封装继承多态，六大原则，张口就来，但是一写起代码就变成过程式开发。很多人说设计模式很难学，用不上，很大原因是连对象是什么都没概念，还怎么谈面向对象设计&lt;/p&gt;
&lt;p&gt;有人会问，上面的User不是对象吗？这个问题我在学校的时候也被别人问过，当时也觉得很疑惑。当时的问题是这样的，你觉得上面的User和下面这个有区别吗&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;struct User
{
   int id;
   char name[50];
   char password[50];
   int status;
} user;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;是的，这是c语言的结构体。你当然不会说这个是对象。这里有个误区，我们平时说的Java对象，其实指的是面向对象语言Java里类的实例，并不等同于面向对象里的对象。所以上面java对象也不见得是真的OO对象&lt;/p&gt;
&lt;p&gt;可以看一下&lt;a href=&quot;https://en.wikipedia.org/wiki/Object_(computer_science)&quot;&gt;维基百科关于对象的说法&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;对象是什么&quot;&gt;对象是什么&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;OO的对象应该是data+behavior&lt;/strong&gt;，所以我们上面的User对象没有行为，只是一个数据结构。试想一下，我是用户，校验密码应该是我自己的事，我用什么加密应该也是我来决定，甚至我加不加密也是我说了算。同样的，我的状态应该也是我来管理，我们的User可以改造成这样&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Data
@NoArgsConstructor
class User{
    private Integer Id;
    private String name;
    private String password;//加密过的密码
  private Integer status;//账号状态
  
  public boolean checkPassword(String pass){
    return Objects.equals(md5(pass),this.password);
  }
  
  public boolean isNormal(){
    return this.status==1
  }
  
  //这里啰嗦一下，有时候我们不太好把行为写到数据库模型类，可以单独建立一个User类，这个User类也就是DDD里面的领域对象。如果持久层使用JPA，JPA的数据模型类即是领域对象，JPA允许通过注解去把领域对象绑定到数据模型上。
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样，Service的代码就简单很多，只需要关注登录的逻辑，不需要关心细节&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void login(String name,String password){
  //1.查出这个用户
  User user = userRepo.getByName(name);
  //2.检查状态
  if(!user.isNormal()){
  
  }
  //3.检查密码
  if(!user.checkPassword(password)){
  
  }
  //登录后续
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;这样做有什么好处呢&quot;&gt;这样做有什么好处呢&lt;/h2&gt;
&lt;p&gt;把固有的逻辑由对象本身负责，责任分明，边界清晰，业务逻辑统一集中，编写单测更容易&lt;/p&gt;
&lt;p&gt;更重要的是，我们的User对象建立起来，有关用户相关的逻辑，方法，我们可以通过User来表达，并且可以在各个分层中传递，&lt;strong&gt;统一业务表达语言&lt;/strong&gt;，可以有效遏制DTO在Service层泛滥的问题。后续会说明一下DTO的问题&lt;/p&gt;
&lt;p&gt;理解了对象是什么后，会更好地反思封装的重要性，进而深入理解六大原则的含义，开始抽象出接口，在实践接口的基础上慢慢地会形成一些手法和技巧，那便是设计模式。而这一切都需要在开发时保持思考，这样写是否流程清晰，边界分明，复用是否容易，最重要的是，是否符合业务的表达，而不是写出service类do anything的过程式代码&lt;/p&gt;
</description>
<pubDate>Wed, 01 May 2019 13:44:00 +0000</pubDate>
<dc:creator>暮夜望日</dc:creator>
<og:description>工作一年，维护工程项目的同时一直写CURD，最近学习DDD，结合之前自己写的开源项目，深思我们这种CURD的编程方式的弊端，和朋友讨论后，发现我们从来没有面向对象开发，所以写这篇文章，希望更多人去思考</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/scau-chm/p/10800885.html</dc:identifier>
</item>
<item>
<title>C语言指针收藏 - 东小东</title>
<link>http://www.cnblogs.com/dongxiaodong/p/10743246.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dongxiaodong/p/10743246.html</guid>
<description>&lt;h2&gt;指针是什么&lt;/h2&gt;
&lt;p&gt;》》每一个内存单元只能同时存储一个数据，如何保证内存单元同时只能存储一个数据，可以使用编号的方式实现内存单元标记，此编号就是指针。&lt;/p&gt;
&lt;p&gt;》》指针是一个变量，指针是存放着一个数据的内存地址而不是数据本身的值，其是查找数据的另一种方式&lt;/p&gt;
&lt;h2&gt;相关运算符&lt;/h2&gt;
&lt;p&gt;【&amp;amp;】在变量中取地址&lt;/p&gt;
&lt;p&gt;【*】在地址中取变量&lt;/p&gt;
&lt;p&gt;测试小程序：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
#include&amp;lt;stdio.h&amp;gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main() {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;10&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义一个变量，并赋初始值为10&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; *p = &amp;amp;i;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义一个指针变量，并赋初始值为i的地址&lt;/span&gt;
    *p = &lt;span&gt;199&lt;/span&gt;&lt;span&gt;;
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d=%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, *p,i);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出199=199&lt;/span&gt;
    printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;---%d---&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, p);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到变量i的地址&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;指针变量的类型&lt;/h2&gt;
&lt;p&gt;》》指针类型：int *、float*、long*、double*、char*等等&lt;/p&gt;
&lt;p&gt;》》指针变量的类型需要与存储的数据类型相同&lt;/p&gt;
&lt;p&gt;》》确定类型可以方便指针变量确定存储数据的大小，为数据寻找到结束符，如int类型占四个字节、char占一个字节。也方便指针使用加1或减1操作，如int加减1会跳动4个字节，char加减1会跳动两个字节。&lt;/p&gt;
&lt;h2&gt;指针的赋值&lt;/h2&gt;
&lt;p&gt;int i=10;  int *p=&amp;amp;i;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485202/201904/1485202-20190430222532918-1492507645.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;int *pp;&lt;/p&gt;
&lt;p&gt;pp=p;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485202/201904/1485202-20190430222600841-144224055.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;指针运算符：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;*p++&lt;/p&gt;
&lt;p&gt;等同于p++;*p;或者*（p++）,运算优先级为从右到左。&lt;/p&gt;
&lt;h2&gt;指针变量作为函数参数&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
#include&amp;lt;stdio.h&amp;gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;int *a1=&amp;amp;b1;&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; fun(&lt;span&gt;int&lt;/span&gt; *a1, &lt;span&gt;int&lt;/span&gt;*&lt;span&gt; a2) {
    
    &lt;/span&gt;*a1 = &lt;span&gt;100&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; ii = &lt;span&gt;99&lt;/span&gt;&lt;span&gt;;
    a2 &lt;/span&gt;= &amp;amp;ii;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;让指针重新指向另外一个地址&lt;/span&gt;
    printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;得到的数据：%d,%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, *a1, *a2);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出100,99&lt;/span&gt;
&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main() {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; b1 = &lt;span&gt;1&lt;/span&gt;, b2 = &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
    fun(&lt;/span&gt;&amp;amp;b1, &amp;amp;&lt;span&gt;b2);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;调用函数后：%d,%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, b1, b2);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出100,2&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出b2的结果并不是相同的值，是因为执行调用函数改变了实参指针变量的值，并不是改变了实参指针变量所指变量的值&lt;/p&gt;
&lt;h2&gt;一维数组指针变量&lt;/h2&gt;
&lt;p&gt;数组名（如arr）代表元素的首地址，数组第一个元素的地址也是这个数组的首地址（如&amp;amp;arr[0]）。&lt;/p&gt;
&lt;p&gt;数组指针中使用加减1将跳到下一个或者上一个数组元素地址，与使用 &amp;amp;arr[n+1] 基本相同。&lt;/p&gt;
&lt;p&gt;如果整数数组名为arr,运行int *p=arr,则*(p+3)、p[3]、*(arr+3）、arr[3]效果均是取出数组arr的第三个元素，在编译时arr[3]实际上是*（arr+3）处理的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
#include&amp;lt;stdio.h&amp;gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main() {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; arr[] = { &lt;span&gt;5&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;&lt;span&gt; };
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; *p =&lt;span&gt; arr;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; *pp = &amp;amp;arr[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, *(p+&lt;span&gt;3&lt;/span&gt;));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出2&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;函数数组参数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
#include&amp;lt;stdio.h&amp;gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;等价于void fun(char a1[]) {&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; fun(&lt;span&gt;char&lt;/span&gt; *&lt;span&gt;a1) {
    &lt;/span&gt;*(a1 + &lt;span&gt;2&lt;/span&gt;) = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;改变第二个值的内容&lt;/span&gt;
&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main() {
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; b1[] = { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123456789&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
    fun(b1);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;调用函数后：%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, b1);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出: 12c456789&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;二维数组指针变量&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
#include&amp;lt;stdio.h&amp;gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main() {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; a1[][&lt;span&gt;3&lt;/span&gt;] = { {&lt;span&gt;10&lt;/span&gt;,&lt;span&gt;11&lt;/span&gt;,&lt;span&gt;12&lt;/span&gt;},{&lt;span&gt;100&lt;/span&gt;,&lt;span&gt;110&lt;/span&gt;,&lt;span&gt;120&lt;/span&gt;&lt;span&gt;} };
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; a[][&lt;span&gt;3&lt;/span&gt;] = { &lt;span&gt;10&lt;/span&gt;,&lt;span&gt;11&lt;/span&gt;,&lt;span&gt;12&lt;/span&gt;,&lt;span&gt;100&lt;/span&gt;,&lt;span&gt;110&lt;/span&gt;,&lt;span&gt;120&lt;/span&gt;&lt;span&gt; };
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;地址：%d==%d==%d==%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, a[&lt;span&gt;0&lt;/span&gt;], &amp;amp;a[&lt;span&gt;0&lt;/span&gt;][&lt;span&gt;0&lt;/span&gt;],*(a+&lt;span&gt;0&lt;/span&gt;),a+&lt;span&gt;0&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出地址&lt;/span&gt;
    printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d===%d==%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, a[&lt;span&gt;0&lt;/span&gt;][&lt;span&gt;1&lt;/span&gt;], *(*(a + &lt;span&gt;0&lt;/span&gt;)+&lt;span&gt;1&lt;/span&gt;),*(a[&lt;span&gt;0&lt;/span&gt;]+&lt;span&gt;1&lt;/span&gt;));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到值&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;指针引用字符串&lt;/h2&gt;
&lt;p&gt;字符串常量【char *ch = &quot;dong xiao dong&quot;;】表示其指向地址的内容不可变，但指向的地址是可变的；&lt;/p&gt;
&lt;p&gt;字符串变量【char ch[] = &quot;dong xiao dong&quot;;】其指向地址的内容可变。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
#include&amp;lt;stdio.h&amp;gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main() {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;char *ch = &quot;dong xiao dong&quot;; &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;字符串常量，不可变 &lt;/span&gt;
    &lt;span&gt;char&lt;/span&gt; ch[] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dong xiao dong&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;字符数组，可变&lt;/span&gt;
    ch[&lt;span&gt;2&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;字符串常量运行这条将报错&lt;/span&gt;
    printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, ch);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可变格式的输出函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
#include&amp;lt;stdio.h&amp;gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main() {
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *ch = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dong xiao %d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    printf(ch, &lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;);
    ch &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xiaoxiao%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    printf(ch, &lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; chh[] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dongdong %d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    printf(ch, &lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;指向函数的指针&lt;/h2&gt;
&lt;p&gt;【int(*p)(int, int);//定义一个函数指针变量p】，第一个int表示返回值类型，第二个int和第三个int表示函数的参数类型。注意*p两侧的括号不能省略，表示p先与*结合，是指针变量，然后再于后面的（）结合，（）表示是函数，即该指针变量不是指向一般的变量，而是指向函数。如果写成“int * p(int,int);”,由于（）优先级高于*,它相当于“int *(p(int,int))”,就成了声明一个p函数，并且这个函数的返回值是指向整型变量的指针。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;返回值为int&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
#include&amp;lt;stdio.h&amp;gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main() {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; minto(&lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;int&lt;/span&gt; b);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;函数声明&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt;(*p)(&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义一个函数指针变量p&lt;/span&gt;
    p = minto;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;函数指针指向函数minto首地址&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; cc = (*p)(&lt;span&gt;11&lt;/span&gt;, &lt;span&gt;55&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用函数&lt;/span&gt;
    printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Min===%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, cc);
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; minto(&lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; b) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(a &amp;gt; b) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; b;
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;return&lt;/span&gt;&lt;span&gt; a;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;无返回值：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
#include&amp;lt;stdio.h&amp;gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main() {
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; fun(&lt;span&gt;int&lt;/span&gt; a);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;函数声明&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; (*p)(&lt;span&gt;int&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义一个函数指针变量p&lt;/span&gt;
    p = fun;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;函数指针指向函数fun首地址&lt;/span&gt;
    (*p)(&lt;span&gt;11&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用函数&lt;/span&gt;
&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; fun(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; a) {
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, a);  
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;指向函数指针作为函数的参数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
#include&amp;lt;stdio.h&amp;gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main() {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; fun(&lt;span&gt;int&lt;/span&gt;(*addpp)(&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;), &lt;span&gt;int&lt;/span&gt; x, &lt;span&gt;int&lt;/span&gt; y);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;函数声明&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; add(&lt;span&gt;int&lt;/span&gt; i, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; j);

    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; ii=fun(add, &lt;span&gt;11&lt;/span&gt;, &lt;span&gt;12&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;传递函数名和参数即可&lt;/span&gt;
    printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;输出相加的值为：%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, ii);
  }

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;int (*addpp)(int,int);addpp=add;&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; fun(&lt;span&gt;int&lt;/span&gt; (*addpp)(&lt;span&gt;int&lt;/span&gt;,&lt;span&gt;int&lt;/span&gt;),&lt;span&gt;int&lt;/span&gt; x,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; y){
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; cc = (*&lt;span&gt;addpp)(x, y);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cc;
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; add(&lt;span&gt;int&lt;/span&gt; i, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; j) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; i +&lt;span&gt; j;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;返回指针的函数&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
#include&amp;lt;stdio.h&amp;gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main() {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;* add(&lt;span&gt;int&lt;/span&gt; i, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; j);
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; *p = add(&lt;span&gt;10&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;&lt;span&gt;);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;输出相加的值为：%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, *&lt;span&gt;p);
  }

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;* add(&lt;span&gt;int&lt;/span&gt; i, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; j) {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; aa = i +&lt;span&gt; j;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &amp;amp;aa;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回地址&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;指针数组&lt;/h2&gt;
&lt;p&gt;一个数组其全部元素都存放着指针，就是指针数组【int * p[5];】&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
#include&amp;lt;stdio.h&amp;gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main() {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指针数组&lt;/span&gt;
    &lt;span&gt;char&lt;/span&gt; * p[] = { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dong1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xiao2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dong3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dong4&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, p[&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]);
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;进阶版&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
#include&amp;lt;stdio.h&amp;gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main() {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指针数组(字符串）&lt;/span&gt;
    &lt;span&gt;char&lt;/span&gt; * p[] = { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dong1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xiao2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dong3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dong4&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; **&lt;span&gt;pp;
    pp &lt;/span&gt;=&lt;span&gt; p;
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, *(pp+&lt;span&gt;1&lt;/span&gt;));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;转换一次就可以拿到对应字符串的首地址通过%s打印

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指针数组（整数）&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; a[&lt;span&gt;5&lt;/span&gt;]= {&lt;span&gt;10&lt;/span&gt;,&lt;span&gt;11&lt;/span&gt;,&lt;span&gt;12&lt;/span&gt;,&lt;span&gt;13&lt;/span&gt;&lt;span&gt; };
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; * ip[] = { &amp;amp;a[&lt;span&gt;0&lt;/span&gt;],&amp;amp;a[&lt;span&gt;1&lt;/span&gt;],&amp;amp;a[&lt;span&gt;2&lt;/span&gt;],&amp;amp;a[&lt;span&gt;3&lt;/span&gt;],&amp;amp;a[&lt;span&gt;4&lt;/span&gt;&lt;span&gt;]};
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; **ppp =&lt;span&gt; ip;
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, *(*ppp+&lt;span&gt;1&lt;/span&gt;));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;转换第一次得到存储的指针，再次转换得到值&lt;/span&gt;
  }
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;错误示范&lt;/h2&gt;
&lt;p&gt;1、&lt;/p&gt;
&lt;p&gt;int *p=10; //等同于：int *p; p=10;&lt;/p&gt;
&lt;p&gt;分析：非法操作，内存地址不能用户自定义。10相当于一个内存地址，该内存地址的值不确定且也不明确该地址是否可以直接访问，正确的应该是使用【&amp;amp;变量名】得到内存地址。&lt;/p&gt;

&lt;p&gt;2、&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; f = &lt;span&gt;12.3&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; *&lt;span&gt;p;
&lt;/span&gt;*p = &amp;amp;f;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;错误1&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; ff = &amp;amp;f; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;错误2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;分析：指针（地址）必须赋值给指针变量&lt;/p&gt;
</description>
<pubDate>Wed, 01 May 2019 13:27:00 +0000</pubDate>
<dc:creator>东小东</dc:creator>
<og:description>指针是什么 》》每一个内存单元只能同时存储一个数据，如何保证内存单元同时只能存储一个数据，可以使用编号的方式实现内存单元标记，此编号就是指针。 》》指针是一个变量，指针是存放着一个数据的内存地址而不是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dongxiaodong/p/10743246.html</dc:identifier>
</item>
<item>
<title>记一次OOM问题排查过程 - lovecindywang</title>
<link>http://www.cnblogs.com/lovecindywang/p/10800593.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lovecindywang/p/10800593.html</guid>
<description>&lt;p&gt;上周运维反馈线上程序出现了OOM，程序日志中的输出为&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Exception in thread &quot;http-nio-8080-exec-1027&quot; java.lang.OutOfMemoryError: Java heap space
Exception in thread &quot;http-nio-8080-exec-1031&quot; java.lang.OutOfMemoryError: Java heap space&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看线程名称应该是tomcat的nio工作线程，线程在处理程序的时候因为无法在堆中分配更多内存出现了OOM，幸好JVM启动参数配置了-XX:+HeapDumpOnOutOfMemoryError，使用MAT打开拿到的hprof文件进行分析。&lt;/p&gt;
&lt;p&gt;第一步就是打开Histogram看看占用内存最大的是什么对象：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/5/1/16a72ff9fbd9513b?w=2336&amp;amp;h=1442&amp;amp;f=png&amp;amp;s=859172&quot;/&gt;&lt;br/&gt;可以看到byte数组占用了接近JVM配置的最大堆的大小也就是8GB，显然这是OOM的原因。&lt;br/&gt;第二步看一下究竟是哪些byte数组，数组是啥内容：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/5/1/16a7303678679c97?w=1638&amp;amp;h=1434&amp;amp;f=png&amp;amp;s=1007057&quot;/&gt;&lt;br/&gt;可以看到很明显这和HTTP请求相关，一个数组大概是10M的大小。&lt;br/&gt;第三步通过查看GC根查看谁持有了数组的引用：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/5/1/16a7307cf3cc41ca?w=1920&amp;amp;h=302&amp;amp;f=png&amp;amp;s=164161&quot;/&gt;&lt;br/&gt;这符合之前的猜测，是tomcat的线程在处理过程中分配了10M的buffer在堆上。至此，马上可以想到一定是什么参数设置的不合理导致了这种情况，一般而言tomcat不可能为每一个请求分配如此大的buffer。&lt;br/&gt;第四步就是检查代码里是否有tomcat或服务器相关配置，看到有这么一个配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;max-http-header-size: 10000000&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至此，基本已经确定了八九不离十就是这个不合理的最大http请求头参数导致的问题。&lt;br/&gt;到这里还有3个疑问：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;即使一个请求分配10M内存，堆有8GB，难道当时有这么多并发吗？800个tomcat线程？&lt;/li&gt;
&lt;li&gt;参数只是设置了最大请求头10M，为什么tomcat就会一次性分配这么大的buffer呢？&lt;/li&gt;
&lt;li&gt;为什么会有如此多的tomcat线程？感觉程序没这么多并发。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;先来看问题1，这个可以通过MAT在dump中继续寻找答案。&lt;br/&gt;可以打开线程视图，搜索一下tomcat的工作线程，发现线程数量的确很多有401个，但是也只是800的一半：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/5/1/16a73127e0a2a49d?w=1722&amp;amp;h=1384&amp;amp;f=png&amp;amp;s=920561&quot;/&gt;&lt;br/&gt;再回到那些大数组的清单，按照堆分配大小排序，往下看：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/5/1/16a731484701e3b8?w=1646&amp;amp;h=1360&amp;amp;f=png&amp;amp;s=834613&quot;/&gt;&lt;br/&gt;可以发现除了有10008192字节的数组还有10000000字节的数组，查看引用路径可以看到这个正好是10M的数组是output buffer，区别于之前看到的input buffer：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/5/1/16a73137db081dc0?w=1468&amp;amp;h=412&amp;amp;f=png&amp;amp;s=217507&quot;/&gt;&lt;br/&gt;好吧，这就对了，一个线程分配了输入输出两个buffer，占用20M内存，一共401个线程，占用8GB，所以OOM了。&lt;br/&gt;还引申出一个问题为啥有这么多工作线程，&lt;/p&gt;
&lt;p&gt;再来看看问题2，这就需要来找一下源码了，首先max-http-header-size是springboot定义的参数，查看springboot代码可以看到这个参数对于tomcat设置的是MaxHttpHeaderSize：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/5/1/16a7326a1b4942de?w=1864&amp;amp;h=392&amp;amp;f=png&amp;amp;s=90147&quot;/&gt;&lt;br/&gt;然后来看看tomcat源码：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/5/1/16a7327bff9ec03a?w=1942&amp;amp;h=768&amp;amp;f=png&amp;amp;s=178901&quot;/&gt;&lt;br/&gt;进一步看一下input buffer：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/5/1/16a7329f8be52b2c?w=1610&amp;amp;h=686&amp;amp;f=png&amp;amp;s=131361&quot;/&gt;&lt;br/&gt;buffer大小是MaxHttpHeaderSize+ReadBuffer大小，这个默认是8192字节：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   &amp;lt;attribute name=&quot;socket.appReadBufSize&quot; required=&quot;false&quot;&amp;gt;
        &amp;lt;p&amp;gt;(int)Each connection that is opened up in Tomcat get associated with
        a read ByteBuffer. This attribute controls the size of this buffer. By
        default this read buffer is sized at &amp;lt;code&amp;gt;8192&amp;lt;/code&amp;gt; bytes. For lower
        concurrency, you can increase this to buffer more data. For an extreme
        amount of keep alive connections, decrease this number or increase your
        heap size.&amp;lt;/p&amp;gt;
      &amp;lt;/attribute&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这也就是为什么之前看到大量的buffer是10008192字节的。至于为什么分配的buffer需要是MaxHttpHeaderSize+ReadBuffer。显然还有一批内容是空的10000000字节的buffer应该是output buffer，源码可以印证这点：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/5/1/16a732d974f231ae?w=1564&amp;amp;h=822&amp;amp;f=png&amp;amp;s=127343&quot;/&gt;&lt;br/&gt;嗯这是一个header buffer，所以正好是10000000字节。&lt;/p&gt;
&lt;p&gt;至于问题3，显然我们的应用程序是配置过最大线程的（查看配置后发现的确，我们配置为了2000，好吧有点大），否则也不会有401个工作线程（默认150），如果当时并发并不大的话就一种可能，请求很慢，虽然并发不大，但是因为请求执行的慢就需要更多线程，比如TPS是100，但是平均RT是4s的话，就是400线程了。这个问题的答案还是可以通过MAT去找，随便看几个线程可以发现很多线程都在等待一个外部服务的返回，这说明外部服务比较慢，去搜索当时的程序日志可以发现有很多&quot;feign.RetryableException: Read timed out executing的日志&quot;。。。。追杀下游去！慢点，我们的feign的timeout也需要再去设置一下，别被外部服务拖死了。&lt;/p&gt;
</description>
<pubDate>Wed, 01 May 2019 12:05:00 +0000</pubDate>
<dc:creator>lovecindywang</dc:creator>
<og:description>上周运维反馈线上程序出现了OOM，程序日志中的输出为 看线程名称应该是tomcat的nio工作线程，线程在处理程序的时候因为无法在堆中分配更多内存出现了OOM，幸好JVM启动参数配置了 XX:+Hea</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lovecindywang/p/10800593.html</dc:identifier>
</item>
<item>
<title>.NET和Docker ，比翼双飞 - 张善友</title>
<link>http://www.cnblogs.com/shanyou/p/10800521.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shanyou/p/10800521.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://www.docker.com/dockercon/&quot;&gt;DockerCon 2019&lt;/a&gt;本周将在旧金山举行 ，DockerCon 是从业者、贡献者、维护者、开发者和容器生态系统学习、网络和创新的一站式活动。 .NET 团队博客发布了《&lt;a href=&quot;https://devblogs.microsoft.com/dotnet/using-net-and-docker-together-dockercon-2019-update/&quot;&gt;一起使用.NET和Docker - DockerCon 2019更新&lt;/a&gt;》，分享.NET团队如何在过去一年中改进使用.NET和Docker的经验。.NET团队去年改进.NET Core Docker体验的大部分工作都集中在.NET Core 3.0上。.NET Core 3.0 是第一个发布实质性运行时更改以使CoreCLR更有效的支持Docker资源限制，并提供更多配置供您调整的版本。&lt;/p&gt;
&lt;p&gt;.NET 团队致力于使.NET Core成为真正的容器运行时。在过去的版本中，我们认为.NET Core是容器友好的。.NET 团队现在正在加强运行时，使其在低内存环境中具有容器感知功能并高效运行。 我们做出的最基本的改变是减少CoreCLR默认使用的内存，在过去的几个版本中，.NET 团队付出了很多努力来改进.NET Core在&lt;a href=&quot;https://www.techempower.com/benchmarks/&quot;&gt;TechEmpower基准测试中的表现&lt;/a&gt;。使用.NET Core 3.0，.NET 团队找到了显着提高性能并减少大量使用内存的方法。.NET 团队现在在容量限制为大约150 MB的容器中运行TechEmpower纯文本基准测试，同时每秒处理数百万个请求，这使我们能够每天验证内存受限的情况。&lt;/p&gt;
&lt;p&gt;说到Docker，我对.NET Core搭配 Docker的使用非常满意，.NET Core 3.0的到来会更加美好，再借助于kubernetes的协调，我们的生活会越来越美好。&lt;/p&gt;
&lt;p&gt;但是长久以来，Docker 和 Java 就像一对“欢喜冤家”。一方面，容器技术的“不可变基础设施”特性为开发者带来了无比宝贵的依赖与环境一致性保证；但另一方面， Linux 容器通过 Cgroups 对应用进行资源限制的方式跟所有依赖于 JVM 进行资源分配的编程语言都产生了本质的冲突。我在客户咨询的过程中经常见到客户的基于java8的应用程序（国内大量的Java应用都是java8）在docker中运行时出现“随机”故障？或者也许是一些奇怪的死机？两者都可能是Java 8（仍广泛使用的）中糟糕的docker支持引起的。Docker使用控制组（cgroups）来限制资源。在容器中运行应用程序时限制内存和CPU绝对是个好主意――它可以阻止应用程序占用整个可用内存及/或CPU，这会导致在同一个系统上运行的其他容器毫无反应。限制资源可提高应用程序的可靠性和稳定性。它还允许为硬件容量作好规划。在Kubernetes或DC/OS之类的编排系统上运行容器时尤为重要。&lt;/p&gt;
&lt;p&gt;JVM可以“看到”系统上的整个内存和可用的所有CPU核心，并确保与资源一致。它默认情况下将最大堆大小（heap size）设置为系统内存的1/4，并将某些线程池大小（比如针对GC）设置为物理核心数量，我们在拥有64GB内存的系统上运行，默认的最大堆大小是物理内存的1/4即16GB。如果我们使用docker cgroups限制内存，会发生什么，JVM进程被杀死了。由于它是一个子进程――容器本身幸存下来，但通常当java是容器（PID 1）内的唯一进程时，容器会崩溃。&lt;/p&gt;
&lt;p&gt;CPU怎么样？ 系统上的确有12个CPU。因此，即使可用处理器的数量限制为1，JVM也会尝试使用12 , Java8和Docker的相杀，但是如果你升级到新的Java版本（10及以上版本）已经内置了docker支持功能。但有时升级不是办法，比如说如果应用程序与新JVM不兼容就不行，而且Oracle在2019年4月更改了Java 8更新的许可证，自Java SE 8 Update 211以来商业使用不再免费。 不过也有好消息，而就在上周，最近发布的OpenJDK 镜像 &lt;strong&gt;openjdk:8u212-jdk&lt;/strong&gt; 终于能够让 Java 8 运行时在容器里面为应用分配出合理的 CPU 数目和堆栈大小了，具体可以参考 &lt;a title=&quot;https://blog.softwaremill.com/docker-support-in-new-java-8-finally-fd595df0ca54?spm=a2c4e.11153940.blogcont700628.17.10fb43bf5u3n1d&quot; href=&quot;https://blog.softwaremill.com/docker-support-in-new-java-8-finally-fd595df0ca54?spm=a2c4e.11153940.blogcont700628.17.10fb43bf5u3n1d&quot;&gt;https://blog.softwaremill.com/docker-support-in-new-java-8-finally-fd595df0ca54?spm=a2c4e.11153940.blogcont700628.17.10fb43bf5u3n1d&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;从Oracle JDK 8 切换到OpenJDK 8 是想继续使用Java的好选择，不过我还是劝告大家可以考虑下.NET Core 了，新的项目可以采用.NET Core 2.2进行开发，半年后就可以转到.NET Core 3.0 .NET Core是以MIT协议开源， Java是GPL协议开源。 Java 8 SDK升级Oracle要收费这件事对于很多小公司是有着重大的影响的。众多没有能力开发维护OpenJDK的公司完全可以转向更具有竞争力的.NET Core，.NET Core从属于.NET基金会，由微软进行官方支持。使用最宽松的MIT和Apache 2开源协议，文档协议遵循CC-BY。这将允许任何人任何组织和企业任意处置，包括使用，复制，修改，合并，发表，分发，再授权，或者销售。唯一的限制是，软件中必须包含上述版 权和许可提示，后者协议将会除了为用户提供版权许可之外，还有专利许可，并且授权是免费，无排他性的(任何个人和企业都能获得授权)并且永久不可撤销，用户使用.NET Core完全不用担心收费问题，你可以很自由的部署在任何地方,。&lt;/p&gt;
&lt;p&gt;现在是云计算时代，.NET Core已经磨练5年时间，准备好了迎接云计算时代的云原生应用开发，云系统中，用更少的硬件为更高密度的用户提供服务是非常重要的。应用程序的占位面积越小，密度越高。容器只包含应用程序及其依赖项。文件大小要小很多倍，启动时间以秒为单位，只有应用程序加载到内存中，容器保证在任何主机上工作。鉴于容器的明显优势，.NET Core的设计决定之一就是使其成为模块化。这意味着你的.NET Core应用程序可以被&quot;发布&quot;，使得它和它的所有依赖关系在一个地方，这很容易放入容器&lt;/p&gt;
</description>
<pubDate>Wed, 01 May 2019 11:33:00 +0000</pubDate>
<dc:creator>张善友</dc:creator>
<og:description>DockerCon 2019本周将在旧金山举行 ，DockerCon 是从业者、贡献者、维护者、开发者和容器生态系统学习、网络和创新的一站式活动。 .NET 团队博客发布了《一起使用.NET和Dock</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shanyou/p/10800521.html</dc:identifier>
</item>
</channel>
</rss>