<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>[springboot 开发单体web shop] 2. Mybatis Generator 生成common mapper - IsaacZhang</title>
<link>http://www.cnblogs.com/zhangpan1244/p/11803023.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangpan1244/p/11803023.html</guid>
<description>&lt;hr/&gt;&lt;p&gt;在我们开启一个新项目的研发后，通常要编写很多的&lt;code&gt;entity/pojo/dto/mapper/dao...&lt;/code&gt;, 大多研发兄弟们都会抱怨，为什么我要重复写&lt;code&gt;CRUD&lt;/code&gt;? 我们为了避免编写一些不必要的重复代码，这节给大家介绍介绍使用一个开源工具，来帮助我们从这种简单枯燥的编码中解救出来。&lt;br/&gt;隆重有请： &lt;a href=&quot;https://github.com/abel533/Mapper&quot;&gt;MyBatis通用Mapper4&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;通用Mapper都可以极大的方便开发人员。可以随意的按照自己的需要选择通用方法，还可以很方便的开发自己的通用方法。&lt;br/&gt;极其方便的使用&lt;strong&gt;MyBatis单表&lt;/strong&gt;的增删改查。&lt;br/&gt;支持单表操作，不支持通用的多表联合查询。&lt;br/&gt;通用 Mapper 支持 &lt;strong&gt;Mybatis-3.2.4&lt;/strong&gt; 及以上版本。&lt;br/&gt;&lt;strong&gt;Tips:&lt;/strong&gt;&lt;br/&gt;各位技术同仁一定要有版本意识哦～&lt;br/&gt;Let's code!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;create-mybatis-generator-tool-module&quot;&gt;Create mybatis-generator-tool Module&lt;/h3&gt;
&lt;p&gt;参考&lt;a href=&quot;https://www.cnblogs.com/zhangpan1244/p/11793065.html#4415077&quot;&gt;上一节&lt;/a&gt;中的Module创建&lt;code&gt;mybatis-generator-tool&lt;/code&gt;.&lt;/p&gt;
&lt;hr/&gt;&lt;ul&gt;&lt;li&gt;添加依赖&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
    &amp;lt;parent&amp;gt;
        &amp;lt;artifactId&amp;gt;expensive-shop&amp;lt;/artifactId&amp;gt;
        &amp;lt;groupId&amp;gt;com.life-runner&amp;lt;/groupId&amp;gt;
        &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;/parent&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

    &amp;lt;artifactId&amp;gt;mybatis-generator-tool&amp;lt;/artifactId&amp;gt;

    &amp;lt;properties&amp;gt;
        &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt;
    &amp;lt;/properties&amp;gt;

    &amp;lt;build&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;!--springboot 构建可执行fat jars必须的插件，如不添加，在生产环境会有问题--&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
            &amp;lt;/plugin&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.mybatis.generator&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;mybatis-generator-maven-plugin&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;1.3.6&amp;lt;/version&amp;gt;
                &amp;lt;configuration&amp;gt;
                    &amp;lt;!-- 设置配置文件路径 --&amp;gt;
                    &amp;lt;configurationFile&amp;gt;
                        ${basedir}/src/main/resources/generator/generatorConfig.xml
                    &amp;lt;/configurationFile&amp;gt;
                    &amp;lt;!--允许覆盖--&amp;gt;
                    &amp;lt;overwrite&amp;gt;true&amp;lt;/overwrite&amp;gt;
                    &amp;lt;verbose&amp;gt;true&amp;lt;/verbose&amp;gt;
                &amp;lt;/configuration&amp;gt;
                &amp;lt;dependencies&amp;gt;
                    &amp;lt;!-- mysql8 驱动--&amp;gt;
                    &amp;lt;dependency&amp;gt;
                        &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
                        &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
                        &amp;lt;version&amp;gt;8.0.16&amp;lt;/version&amp;gt;
                    &amp;lt;/dependency&amp;gt;
                    &amp;lt;!--通用 Mapper--&amp;gt;
                    &amp;lt;dependency&amp;gt;
                        &amp;lt;groupId&amp;gt;tk.mybatis&amp;lt;/groupId&amp;gt;
                        &amp;lt;artifactId&amp;gt;mapper&amp;lt;/artifactId&amp;gt;
                        &amp;lt;version&amp;gt;4.1.5&amp;lt;/version&amp;gt;
                    &amp;lt;/dependency&amp;gt;
                &amp;lt;/dependencies&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt;
&amp;lt;/project&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;ul&gt;&lt;li&gt;编写配置文件&lt;br/&gt;根据我们在pom文件中指定的路径：&lt;code&gt;${basedir}/src/main/resources/generator/generatorConfig.xml&lt;/code&gt;, 我们需要在项目&lt;code&gt;src=&amp;gt;main=&amp;gt;resource&lt;/code&gt;目录下创建&lt;code&gt;generator&lt;/code&gt;文件夹，在文件夹下创建文件&lt;code&gt;generatorConfig.xml&lt;/code&gt;,内容如下：&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;!DOCTYPE generatorConfiguration
  PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;
  &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&amp;gt;

&amp;lt;generatorConfiguration&amp;gt;
  &amp;lt;!--引入数据库配置内容--&amp;gt;
  &amp;lt;properties resource=&quot;generator/config.properties&quot;/&amp;gt;

  &amp;lt;context id=&quot;MysqlContext&quot; targetRuntime=&quot;MyBatis3Simple&quot; defaultModelType=&quot;flat&quot;&amp;gt;
    &amp;lt;!--配置是否使用通用 Mapper 自带的注释扩展，默认 true--&amp;gt;
    &amp;lt;!--&amp;lt;property name=&quot;useMapperCommentGenerator&quot; value=&quot;false&quot;/&amp;gt;--&amp;gt;

    &amp;lt;plugin type=&quot;tk.mybatis.mapper.generator.MapperPlugin&quot;&amp;gt;
      &amp;lt;!--设置Mapper生成的basic,可自定义--&amp;gt;
      &amp;lt;property name=&quot;mappers&quot; value=&quot;tk.mybatis.mapper.common.Mapper&quot;/&amp;gt;
      &amp;lt;!--大小写转换敏感--&amp;gt;
      &amp;lt;property name=&quot;caseSensitive&quot; value=&quot;true&quot;/&amp;gt;
      &amp;lt;!--引入lombok注解--&amp;gt;
      &amp;lt;property name=&quot;lombok&quot; value=&quot;Getter,Setter,ToString&quot;/&amp;gt;
      &amp;lt;!--分隔符定义--&amp;gt;
      &amp;lt;property name=&quot;beginningDelimiter&quot; value=&quot;`&quot;/&amp;gt;
      &amp;lt;property name=&quot;endingDelimiter&quot; value=&quot;`&quot;/&amp;gt;
    &amp;lt;/plugin&amp;gt;

    &amp;lt;!-- 设置数据库配置 --&amp;gt;
    &amp;lt;jdbcConnection driverClass=&quot;${jdbc.driverClass}&quot;
      connectionURL=&quot;${jdbc.url}&quot;
      userId=&quot;${jdbc.user}&quot;
      password=&quot;${jdbc.password}&quot;&amp;gt;
    &amp;lt;/jdbcConnection&amp;gt;

    &amp;lt;!-- 对应生成的pojo所在包 --&amp;gt;
    &amp;lt;javaModelGenerator targetPackage=&quot;com.liferunner.pojo&quot; targetProject=&quot;src/main/java&quot;/&amp;gt;

    &amp;lt;!-- 对应生成的mapper所在目录 --&amp;gt;
    &amp;lt;sqlMapGenerator targetPackage=&quot;mapper&quot; targetProject=&quot;src/main/resources&quot;/&amp;gt;

    &amp;lt;!-- 配置mapper对应的java映射 --&amp;gt;
    &amp;lt;javaClientGenerator targetPackage=&quot;com.liferunner.mapper&quot; targetProject=&quot;src/main/java&quot; type=&quot;XMLMAPPER&quot;/&amp;gt;

    &amp;lt;!-- 数据库表 --&amp;gt;
    &amp;lt;table tableName=&quot;carousel&quot;&amp;gt;&amp;lt;/table&amp;gt;
    &amp;lt;table tableName=&quot;category&quot;&amp;gt;&amp;lt;/table&amp;gt;
    &amp;lt;table tableName=&quot;items&quot;&amp;gt;&amp;lt;/table&amp;gt;
    &amp;lt;table tableName=&quot;items_comments&quot;&amp;gt;&amp;lt;/table&amp;gt;
    &amp;lt;table tableName=&quot;items_img&quot;&amp;gt;&amp;lt;/table&amp;gt;
    &amp;lt;table tableName=&quot;items_param&quot;&amp;gt;&amp;lt;/table&amp;gt;
    &amp;lt;table tableName=&quot;items_spec&quot;&amp;gt;&amp;lt;/table&amp;gt;
    &amp;lt;table tableName=&quot;order_items&quot;&amp;gt;&amp;lt;/table&amp;gt;
    &amp;lt;table tableName=&quot;order_status&quot;&amp;gt;&amp;lt;/table&amp;gt;
    &amp;lt;table tableName=&quot;orders&quot;&amp;gt;&amp;lt;/table&amp;gt;
    &amp;lt;table tableName=&quot;shop_users&quot;&amp;gt;&amp;lt;/table&amp;gt;
    &amp;lt;table tableName=&quot;user_address&quot;&amp;gt;&amp;lt;/table&amp;gt;
    &amp;lt;table tableName=&quot;users&quot;&amp;gt;&amp;lt;/table&amp;gt;
  &amp;lt;/context&amp;gt;
&amp;lt;/generatorConfiguration&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以看到一行配置内容：&lt;code&gt;&amp;lt;properties resource=&quot;generator/config.properties&quot;/&amp;gt;&lt;/code&gt;,这里是为了将我们的数据库连接、账号等信息外置，配置内容如下：&lt;/p&gt;
&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;jdbc.driverClass = com.mysql.cj.jdbc.Driver
jdbc.url = jdbc:mysql://localhost:3306/expensiveshop?characterEncoding=UTF-8&amp;amp;useSSL\
  =false&amp;amp;useUnicode=true&amp;amp;serverTimezone=UTC
jdbc.user = root
jdbc.password = 12345678&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到这里设置的内容就是下属代码中用到的。&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;...
   &amp;lt;jdbcConnection driverClass=&quot;${jdbc.driverClass}&quot;
      connectionURL=&quot;${jdbc.url}&quot;
      userId=&quot;${jdbc.user}&quot;
      password=&quot;${jdbc.password}&quot;&amp;gt;
    &amp;lt;/jdbcConnection&amp;gt;
...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置信息大家可以参考:&lt;a href=&quot;https://github.com/abel533/Mapper/wiki/4.2.codegenerator&quot;&gt;传送门&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;ul&gt;&lt;li&gt;使用maven测试生成&lt;br/&gt;执行以下命令：&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;mybatis-generator-tool&amp;gt;mvn mybatis-generator:generate
[INFO] Scanning for projects...
[INFO]
[INFO] ---------------&amp;lt; com.life-runner:mybatis-generator-tool &amp;gt;---------------
[INFO] Building mybatis-generator-tool 1.0-SNAPSHOT
[INFO] --------------------------------[ jar ]---------------------------------
[INFO]
[INFO] --- mybatis-generator-maven-plugin:1.3.6:generate (default-cli) @ mybatis-generator-tool ---
[INFO] Connecting to the Database
[INFO] Introspecting table carousel
[INFO] Introspecting table category
...
[INFO] Generating Record class for table carousel
[INFO] Generating Mapper Interface for table carousel
[INFO] Generating SQL Map for table carousel
...
[INFO] Saving file CarouselMapper.xml
...
[INFO] Saving file Carousel.java
[INFO] Saving file Users.java
...
[WARNING] Table configuration with catalog null, schema null, and table shop_users did not resolve to any tables
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time:  1.374 s
[INFO] Finished at: 2019-11-05T15:40:07+08:00
[INFO] ------------------------------------------------------------------------
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到执行成功，虽然这里执行成功，但是当我们打开文件的时候会发现：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.liferunner.pojo;

import java.util.Date;
import javax.persistence.*;
import lombok.Getter;
import lombok.Setter;
import lombok.ToString;

@Getter
@Setter
@ToString
@Table(name = &quot;Carousel&quot;)
public class Carousel {
    /**
     * ����id �û�id
     */
    @Id
    private String id;

    /**
     * �û��� �û���
     */
    private String imageUrl;
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里出现了乱码问题，这又是怎么回事呢？&lt;br/&gt;没关系，let's bing... &lt;a href=&quot;https://cn.bing.com/search?q=mybatis+generator+%E7%94%9F%E6%88%90%E6%B3%A8%E9%87%8A%E4%B9%B1%E7%A0%81&amp;amp;qs=n&amp;amp;form=QBRE&amp;amp;sp=-1&amp;amp;pq=mybatis+generator+%E7%94%9F%E6%88%90%E6%B3%A8%E9%87%8A%E4%B9%B1%E7%A0%81&amp;amp;sc=0-24&amp;amp;sk=&amp;amp;cvid=6C3157BC96D3468E830CF5F42ACA29A6&quot;&gt;传送门&lt;/a&gt;，可以看到有265000条结果，那就说明我们的问题已经有太多的人遇到了，随便点开一个：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/48397/201911/48397-20191106082720303-873423331.png&quot; alt=&quot;bug1&quot;/&gt;&lt;br/&gt;可以看到红框里面的内容我们缺失了，在&lt;code&gt;\expensive-shop\mybatis-generator-tool\src\main\resources\generator\generatorConfig.xml&lt;/code&gt;中添加上 &lt;code&gt;&amp;lt;property name=&quot;javaFileEncoding&quot; value=&quot;UTF-8&quot;/&amp;gt;&lt;/code&gt;,重新执行生成命令，可以看到我们的乱码就没有了。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Getter
@Setter
@ToString
@Table(name = &quot;`carousel`&quot;)
public class Carousel {
    /**
     * 主键
     */
    @Id
    @Column(name = &quot;`id`&quot;)
    private String id;

    /**
     * 图片 图片地址
     */
    @Column(name = &quot;`image_url`&quot;)
    private String imageUrl;
    ...&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Tips:&lt;br/&gt;在这一环节先剧透一个bug，否则我担心在后续大家遇到的时候，因为它确实是和Common Mapper生成相关的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们点开生成的&lt;code&gt;Users.java&lt;/code&gt;,可以看到如下所示：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Getter
@Setter
@ToString
@Table(name = &quot;users&quot;)
public class Users {
    @Column(name = &quot;USER&quot;)
    private String user;

    @Column(name = &quot;CURRENT_CONNECTIONS&quot;)
    private Long currentConnections;

    @Column(name = &quot;TOTAL_CONNECTIONS&quot;)
    private Long totalConnections;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可是我们的&lt;code&gt;Users&lt;/code&gt;表不是这样的呀，这是怎么回事？？？&lt;br/&gt;让我们分析分析：&lt;br/&gt;1.既然没有用到我们自己的Users表，但是又确实通过生成器生成了，那么很明显肯定是Mysql数据库中表，这是肯定的。&lt;br/&gt;2.那么问题就来了，它从哪里冒出来的？找它，盘它。&lt;br/&gt;3.到底是哪个数据库中的呢？sys？information_schema？performance_schema？&lt;br/&gt;4.挨个查询，果然：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/48397/201911/48397-20191106082720773-1370779905.png&quot; alt=&quot;bug2&quot;/&gt;&lt;br/&gt;可以看到，在&lt;code&gt;performance_schema&lt;/code&gt;数据库中有一个&lt;code&gt;users&lt;/code&gt;表，那么到底是不是我们生成出来的呢？执行&lt;code&gt;SHOW CREATE TABLE users&lt;/code&gt;, 结果如上图，字段和生成出来的是一致的！&lt;br/&gt;5.抓住它了，怎么盘它？？？&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;很简单，修改jdbc:mysql://localhost:3306/expensiveshop?&lt;strong&gt;nullCatalogMeansCurrent=true&lt;/strong&gt;&amp;amp;characterEncoding=UTF-8&amp;amp;useSSL =false&amp;amp;useUnicode=true&amp;amp;serverTimezone=UTC，新增上加粗部分就可以了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;nullCatalogMeansCurrent&lt;/code&gt; 字面意思很简单，就是说如果是null catalog,我就选择current.因为&lt;code&gt;mysql不支持catalog&lt;/code&gt;,我们需要告知&lt;code&gt;mybatis&lt;/code&gt;这个特性，设置为&lt;code&gt;true&lt;/code&gt;就行了。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;按照SQL标准的解释，在SQL环境下Catalog和Schema都属于抽象概念，主要用来解决命名冲突问题。&lt;br/&gt;从概念上说，一个数据库系统包含多个Catalog，每个Catalog又包含多个Schema，而每个Schema又包含多个数据库对象（表、视图、序列等），反过来讲一个数据库对象必然属于一个Schema，而该Schema又必然属于一个Catalog，这样我们就可以得到该数据库对象的完全限定名称从而解决命名冲突的问题了&lt;br/&gt;从实现的角度来看，各种数据库系统对Catalog和Schema的支持和实现方式千差万别，针对具体问题需要参考具体的产品说明书，比较简单而常用的实现方式是使用数据库名作为Catalog名，Oracle使用用户名作为Schema名.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/48397/201911/48397-20191106082721139-1695559751.png&quot; alt=&quot;bug2-1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可查阅Mysql官网说明:&lt;a href=&quot;https://dev.mysql.com/doc/connector-j/5.1/en/connector-j-reference-configuration-properties.html&quot;&gt;传送门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本节我们讲解了如何生成我们想要的，简单和重要又重复的工作我们可以通过工具实现啦，下一次我们将开始实际业务的编码实现.&lt;br/&gt;gogogo.&lt;/p&gt;
</description>
<pubDate>Wed, 06 Nov 2019 00:27:00 +0000</pubDate>
<dc:creator>IsaacZhang</dc:creator>
<og:description>Mybatis Generator tool 在我们开启一个新项目的研发后，通常要编写很多的 , 大多研发兄弟们都会抱怨，为什么我要重复写 ? 我们为了避免编写一些不必要的重复代码，这节给大家介绍介绍</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhangpan1244/p/11803023.html</dc:identifier>
</item>
<item>
<title>Java 并发编程(四)：如何保证对象的线程安全性 - 沉默王二</title>
<link>http://www.cnblogs.com/qing-gee/p/11802921.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qing-gee/p/11802921.html</guid>
<description>&lt;h3 id=&quot;前言&quot;&gt;01、前言&lt;/h3&gt;
&lt;p&gt;先让我吐一句肺腑之言吧，不说出来会憋出内伤的。《Java 并发编程实战》这本书太特么枯燥了，尽管它被奉为并发编程当中的经典之作，但我还是忍不住。因为第四章“对象的组合”我整整啃了两周的时间，才啃出来点肉丝。&lt;/p&gt;
&lt;p&gt;读者朋友们见谅啊。要怪只能怪我自己的学习能力有限，真读不了这种生硬无趣的技术书。但是为了学习，为了进步，为了将来（口号喊得有点大了），只能硬着头皮上。&lt;/p&gt;
&lt;p&gt;请随我来，我尽量写得有趣点。&lt;/p&gt;
&lt;h3 id=&quot;线程安全类&quot;&gt;02、线程安全类&lt;/h3&gt;
&lt;p&gt;作者说了啊，设计一个线程安全类需要三个步骤：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;1）找出表示对象状态的所有变量&lt;br/&gt;2）对变量进行有效性约束&lt;br/&gt;3）增加类的并发访问策略&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我在作者说的基础上做了微调，读起来更加容易理解。怎么和代码对应起来了，先来看一个普通的计数器类 Counter。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Counter {
    private int value = 0;

    public int getValue() {
        return value;
    }

    public int increment() {
        return ++value;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;1）Counter 的状态变量只有一个，就是 value。&lt;/p&gt;
&lt;p&gt;2）value 的有效性是什么呢，它最大不能超过 &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;，最小只能为 0（计数嘛，总不能记成负数）。换句话说就是，value 的有效范围是 0 ~ &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public int increment() {
    if (value == Integer.MAX_VALUE) {
        throw new IllegalStateException(&quot;counter overflow&quot;);
    }
    return ++value;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3）增加类的并发访问策略，直接上 synchronized。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Counter {
    private int value = 0;

    public synchronized int getValue() {
        return value;
    }

    public synchronized int increment() {
        if (value == Integer.MAX_VALUE) {
            throw new IllegalStateException(&quot;counter overflow&quot;);
        }
        return ++value;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;非线程安全的对象&quot;&gt;03、非线程安全的对象&lt;/h3&gt;
&lt;p&gt;之前我们谈了如何设计一个线程安全的类。如果类是安全的，那么它作为对象使用的时候就是线程安全的。但如果一个类不是线程安全的，它作为对象使用的时候怎么保证是线程安全的呢？&lt;/p&gt;
&lt;p&gt;作者提到了一个名词叫做“封闭机制”：&lt;/p&gt;
&lt;p&gt;1）把对象作为类的私有成员变量；&lt;br/&gt;2）把对象作为方法内部的局部变量；&lt;br/&gt;3）线程 A 把对象传递到 B 线程，而不是与线程 B 共享这个对象；&lt;/p&gt;
&lt;p&gt;大家来看下面这段代码。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class StringList {
    private List&amp;lt;String&amp;gt; myList = new ArrayList&amp;lt;&amp;gt;();
    
    public synchronized void addString(String s) {
        myList.add(s);
    }
    
    public synchronized void removeString(String s) {
        myList.remove(s);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;本身 ArrayList 不是线程安全的，但 myList 是私有的，访问它的两个方法 &lt;code&gt;addString()&lt;/code&gt; 和 &lt;code&gt;removeString()&lt;/code&gt; 都加了关键字 &lt;code&gt;synchronized&lt;/code&gt;，因此 myList 在使用的时候就变成了线程安全的对象，StringList 类就变成了一个线程安全的类——这种方式被称作 Java 监视器模式：可变的状态被封装在一个类中，访问它们只能通过加上锁的方法。&lt;/p&gt;
&lt;p&gt;查看 Vector 的源码，你会发现，它之所以是线程安全的，就是采用的这种监视器模式&lt;/p&gt;
&lt;h3 id=&quot;在已有的线程安全类上追加功能&quot;&gt;04、在已有的线程安全类上追加功能&lt;/h3&gt;
&lt;p&gt;假如现在有一个线程安全的类，比如之前提到的 StringList，它包含了大多数我们需要的功能，但还不够，那么怎么确保我们追加的功能不破坏原有的线程安全性呢？&lt;/p&gt;
&lt;p&gt;最直接的方法当然是修改源码，假如源码掌握在我们自己手里的话。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class StringList {
    private List&amp;lt;String&amp;gt; myList = new ArrayList&amp;lt;&amp;gt;();
    
    public synchronized void addString(String s) {
        myList.add(s);
    }
    
    public synchronized void addIfNotExist(String s) {
        boolean isExist = myList.contains(s);
        if (!isExist) {
            myList.add(s);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们新增了一个 &lt;code&gt;addIfNotExist()&lt;/code&gt; 方法：如果字符串 s 还没有添加到 List 当中，就添加一个。&lt;/p&gt;
&lt;p&gt;新增的方法没有破坏 StringList 的线程安全性，因为当两个线程同时执行 &lt;code&gt;addIfNotExist()&lt;/code&gt; 方法时，需要经过 &lt;code&gt;synchronized&lt;/code&gt; 把守的这道大门。&lt;/p&gt;
&lt;p&gt;但很多时候，我们无法直接修改源码，这时候就只好在原来的基础上进行改造。大家听过之前的“红芯”浏览器吗？在谷歌浏览器的内核上裹了一层层皇帝的新衣。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class StringList {
    protected List&amp;lt;String&amp;gt; myList = new ArrayList&amp;lt;&amp;gt;();
    
    public synchronized void addString(String s) {
        myList.add(s);
    }
}

public class NewStringList extends StringList {
    public synchronized void addIfNotExist(String s) {
        boolean isExist = myList.contains(s);
        if (!isExist) {
            myList.add(s);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;新建一个类 NewStringList，继承自 StringList，然后在 NewStringList 中新增一个方法 &lt;code&gt;addIfNotExist()&lt;/code&gt;。当然了，这样做的前提是父类中的 myList 是 protected 而不是 private 的。因此，这种做法不具有普适性。&lt;/p&gt;
&lt;h3 id=&quot;最后&quot;&gt;05、最后&lt;/h3&gt;
&lt;p&gt;站在我的角度来看，《Java 并发编程实战》的第四章“对象的组合”写得烂透了。导致我在写这篇文章的时候感觉到万分的痛苦。希望下一章不要写的这么烂。&lt;/p&gt;
&lt;p&gt;上一篇：&lt;a href=&quot;https://mp.weixin.qq.com/s/gTAJdfylc19QwDws5I-2FQ&quot;&gt;Java 并发编程(三)：如何保证共享变量的可见性？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;上上篇：&lt;a href=&quot;https://mp.weixin.qq.com/s/HRAabyY-cLcAK_v9x0pMXw&quot;&gt;Java 并发编程(二)：线程安全性&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;上上上篇：&lt;a href=&quot;https://mp.weixin.qq.com/s/ksUUHbt6Nfchy1E00ANg_w&quot;&gt;Java 并发编程(一)：入门篇&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;谢谢大家的阅读，原创不易，喜欢就点个赞，这将是我最强的写作动力。如果你觉得文章对你有所帮助，也蛮有趣的，就微信搜索「&lt;strong&gt;沉默王二&lt;/strong&gt;」，关注后回复关键字《Java 并发编程实战》，即可获取该书的电子版（推荐购买纸质书）。&lt;/p&gt;
</description>
<pubDate>Tue, 05 Nov 2019 21:39:00 +0000</pubDate>
<dc:creator>沉默王二</dc:creator>
<og:description>01、前言 先让我吐一句肺腑之言吧，不说出来会憋出内伤的。《Java 并发编程实战》这本书太特么枯燥了，尽管它被奉为并发编程当中的经典之作，但我还是忍不住。因为第四章“对象的组合”我整整啃了两周的时间</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qing-gee/p/11802921.html</dc:identifier>
</item>
<item>
<title>深入理解.NET Core的基元（二） -  共享框架 - LamondLu</title>
<link>http://www.cnblogs.com/lwqlun/p/11802513.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lwqlun/p/11802513.html</guid>
<description>&lt;blockquote readability=&quot;6.4972375690608&quot;&gt;
&lt;p&gt;原文：Deep-dive into .NET Core primitives, part 2: the shared framework&lt;br/&gt;作者：&lt;a href=&quot;https://natemcmaster.com/&quot;&gt;Nate McMaster&lt;/a&gt;&lt;br/&gt;译文：深入理解.NET Core的基元（二） - 共享框架&lt;br/&gt;作者： Lamond Lu&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本篇是之前翻译过的《&lt;a href=&quot;https://www.cnblogs.com/lwqlun/p/9704702.html&quot;&gt;深入理解.NET Core的基元: deps.json, runtimeconfig.json, dll文件&lt;/a&gt;》的后续，这个系列作者暂时只写了3篇，虽然有一些内容和.NET Core 3.0已经不兼容了，但是大部分的原理还都是相通的，所以后面的第三篇我也会翻译。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201911/65831-20191105232803495-1498779752.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;自.NET Core 1.0起，共享框架(Shared Framework)就已经成为了.NET Core的重要组成部分。自.NET Core 2.1起，ASP.NET Core就已经作为共享框架的第一次出现。你可能从来注意过这一点，但是在设计它的时候，我们经历了许多反复和持续的讨论。在本篇文章中，我们将深入共享框架并讨论一些开发人员经常遇到的一些陷阱。&lt;/p&gt;

&lt;p&gt;.NET Core应用可以在两种模式下运行， 分别是框架依赖模式(Framework - Dependent) 和独立运行模式（Self Contained) 。在我的Macbook上，一个最小的可独立运行的ASP.NET Core网站应用，大约拥有350个文件，文件大小总共是93MB。相对的，一个最小的框架依赖应用，大约5个文件，文件大小总共239KB。&lt;/p&gt;
&lt;p&gt;你可以如下命令行生成基于两种不同模式的应用。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dotnet new web
dotnet publish --runtime osx-x64 --output bin/self_contained_app/
dotnet publish --output bin/framework_dependent_app/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201911/65831-20191105233635217-183879362.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当程序运行的时候，他们的功能是一样的。那么这两种模式有什么区别么？其实正如官网文档中的解释：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;框架依赖部署(framework-dependant deployment) 依赖目标中安装的.NET Core共享组件。独立部署（self-contained deployment）不依赖目标系统中安装的共享组件，程序所需的所有组件都已经包含在当前应用程序中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这篇官方文档（&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/core/deploying/&quot; class=&quot;uri&quot;&gt;https://docs.microsoft.com/en-us/dotnet/core/deploying/&lt;/a&gt;）中很好的解释了不同模式的优势。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;PS: 作者当时写这边文章的时候, 没有引入Framework-dependent executables (FDE)，有兴趣的同学可以自行查看。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这里，简单的说，.NET Core的共享框架就是一个程序集（*.dll文件）集合的目录，这些程序集不需要出现在你的.NET Core的应用目录中。这个目录是.NET Core的共享系统范围版本的一部分，通常你可以在&lt;code&gt;C:\Program Filres\dotnet\shared&lt;/code&gt;中发现它。&lt;/p&gt;
&lt;p&gt;当你运行&lt;code&gt;dotnet.exe WebApi1.dll&lt;/code&gt;命令时，.NET Core宿主程序会&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;尝试发现你的应用依赖的程序集名称和版本&lt;/li&gt;
&lt;li&gt;在某些固定位置中尝试查找该程序集&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这些程序集可以在许多不同的位置被发现了，包含且不限于共享框架。在我之前的文章中，我主要解释了如果通过&lt;code&gt;deps.json&lt;/code&gt;和&lt;code&gt;runtimeconfig.json&lt;/code&gt;文件配置宿主程序的行为。希望了解更多的同学，可以查看那篇文章。&lt;/p&gt;
&lt;p&gt;.NET Core宿主程序会读取&lt;code&gt;*.runtimeconfig.json&lt;/code&gt;文件来确定加载哪个版本的共享框架。这个文件的内容类似：&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
  &quot;runtimeOptions&quot;: {
    &quot;framework&quot;: {
      &quot;name&quot;: &quot;Microsoft.AspNetCore.App&quot;,
      &quot;version&quot;: &quot;2.1.1&quot;
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里，共享框架名称只是一个名字。按照约定，这个名字应该是以&lt;code&gt;.App&lt;/code&gt;结尾的，但是实际上它可以是任何字符串，例如&quot;FooBananaShark&quot;。&lt;/p&gt;
&lt;p&gt;对于共享框架的版本，这里只是配置了一个最低的版本。.NET Core宿主程序会根据配置，加载对应版本的共享框架，或者更高版本的共享框架，但是它永远不会加载比指定版本低的共享框架。&lt;/p&gt;
&lt;h2 id=&quot;那么我到底安装了哪些共享框架呢&quot;&gt;那么，我到底安装了哪些共享框架呢？&lt;/h2&gt;
&lt;p&gt;运行&lt;code&gt;dotnet --list-runtimes&lt;/code&gt;, 你就可以看到你电脑中安装了哪些共享框架，以及它们的版本和文件位置。&lt;/p&gt;
&lt;h2 id=&quot;对比microsoft.netcore.app-aspnetcore.app以及aspnetcore.all&quot;&gt;对比&lt;code&gt;Microsoft.NETCore.App&lt;/code&gt;, &lt;code&gt;AspNetCore.App&lt;/code&gt;以及&lt;code&gt;AspNetCore.All&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;这里，以.NET Core 2.2为例。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;7.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;Microsoft.NETCore.App&lt;/td&gt;
&lt;td&gt;基础运行时。它主要提供了&lt;code&gt;System.Object&lt;/code&gt;、&lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt;、&lt;code&gt;string&lt;/code&gt;类，以及内存管理，文件管理，网络I/O, 线程管理等功能&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;7&quot;&gt;&lt;td&gt;Microsoft.AspNetCore.App&lt;/td&gt;
&lt;td&gt;默认Web运行时。它主要提供了使用API创建Web服务器的功能，这里主要包含Kestral, Mvc, SignalR, Razor, 以及EF Core的部分功能。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;Microsoft.AspNetCore.All&lt;/td&gt;
&lt;td&gt;与第三方的集成库。它追加了EF Core + Sqlite的支持，以及一些扩展功能， 例如Redis, Azure Key Valut等。（在.NET Core 3.0中已经不再使用）&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;共享框架与nuget包的关系&quot;&gt;共享框架与Nuget包的关系&lt;/h2&gt;
&lt;p&gt;.NET Core SDK生成了&lt;code&gt;runtimeconfig.json&lt;/code&gt;文件。在.NET Core 1和2中，SDK使用了项目配置中的两部分来确定&lt;code&gt;runtimeconfig.json&lt;/code&gt;文件中框架部分内容。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;MicrosoftNETPlatformLibrary&lt;/code&gt;属性。对于所有.NET Core项目，它默认是&lt;code&gt;Microsoft.NETCore.App&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;Nuget包管理工具的还原结果集，结果集中可能包含了相同名称的包&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里针对所有的.NET Core项目， .NET Core SDK都会添加一个隐式的包来引用&lt;code&gt;Microsoft.NETCore.App&lt;/code&gt;。ASP.NET Core通过修改默认配置&lt;code&gt;MicrosoftNETPlatformLibrary&lt;/code&gt;, 将其改为&lt;code&gt;Microsoft.AspNetCore.App&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;但是这里需要注意，Nuget包管理工具不提供任何共享框架!不提供任何共享框架! 不提供任何共享框架! 重要的事情说三遍^_^。Nuget包管理工具只提供编译器使用的一些API，以及少量SDK。共享框架的获取来源可以是运行时安装器 &lt;a href=&quot;https://aka.ms/dotnet-download&quot; class=&quot;uri&quot;&gt;https://aka.ms/dotnet-download&lt;/a&gt;， 或者捆绑在Visual Studio中，Docker镜像中，以及一些Azure服务器中。&lt;/p&gt;
&lt;h2 id=&quot;版本前滚策略&quot;&gt;版本前滚策略&lt;/h2&gt;
&lt;p&gt;正如我上面提到的，&lt;code&gt;runtimeconfig.json&lt;/code&gt;只是指定了一个最小版本。实际使用的版本会依赖于一个版本前滚策略（详细内容可以参阅&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/core/versions/selection#framework-dependent-apps-roll-forward&quot;&gt;官方文档&lt;/a&gt;。例如&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果应用使用的共享框架最小版本是2.1.0, 那么程序最高会加载的共享框架版本是2.1.*。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;针对这一部分，可以参见《深入理解.NET Core的基元（三）：深入理解runtimeconfig.json》&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;作者：《深入理解.NET Core的基元（三）：深入理解runtimeconfig.json》后续会补上&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;分层的共享框架&quot;&gt;分层的共享框架&lt;/h2&gt;
&lt;p&gt;在.NET Core 2.1版本中引入了分层共享框架的特性。&lt;/p&gt;
&lt;p&gt;共享框架可以依赖于其他共享框架。引入此特性是为了支持ASP.NET Core, 这个特性可以将程序包的运行时存储转换为一个共享框架。&lt;/p&gt;
&lt;p&gt;如果你查看一下&lt;code&gt;$DOTNET_ROOT/shared/Microsoft.AspNetCore.All/$version/&lt;/code&gt;文件夹，你会发现一个名为&lt;code&gt;Microsoft.AspNetCore.All.runtimeconfig.json&lt;/code&gt;的文件，其内容如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ cat /usr/local/share/dotnet/shared/Microsoft.AspNetCore.All/2.1.2/Microsoft.AspNetCore.All.runtimeconfig.json
{
  &quot;runtimeOptions&quot;: {
    &quot;tfm&quot;: &quot;netcoreapp2.1&quot;,
    &quot;framework&quot;: {
      &quot;name&quot;: &quot;Microsoft.AspNetCore.App&quot;,
      &quot;version&quot;: &quot;2.1.2&quot;
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;多级检索&quot;&gt;多级检索&lt;/h2&gt;
&lt;p&gt;在.NET Core 2.0中引入了多级检索特性。&lt;/p&gt;
&lt;p&gt;宿主程序在启动时会探查多个位置，以寻找合适的共享框架。程序首先会查找dotnet根目录，即包含一个&lt;code&gt;dotnet.exe&lt;/code&gt;可执行文件的目录。这里我们可以通过配置&lt;code&gt;DOTNET_ROOT&lt;/code&gt;的环境变量来覆盖此配置。根据此配置，程序检索的第一个目录是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$DOTNET_ROOT/shared/$name/$version&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果这个目录不存在，宿主程序会尝试使用多级检索机制，检索预定的全局路径列表。这个机制可以通过设置全局变量&lt;code&gt;DOTNET_MULTILEVEL_LOOKUP=0&lt;/code&gt;来关闭。默认情况下，预定的全局路径列表如下：&lt;/p&gt;
&lt;p&gt;最终宿主程序会在找到的全局目录中检索以下目录&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$GLOBAL_DOTNET_ROOT/shared/$name/$version&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;readytorun特性&quot;&gt;ReadyToRun特性&lt;/h2&gt;
&lt;p&gt;共享框架中的程序集，都是经过&lt;code&gt;crossgen&lt;/code&gt;工具预优化过的。使用这个工具可以生成&quot;ReadyToRun&quot;版本的程序集，这些程序集都是针对指定操作系统和CPU架构优化过的。这里主要的性能提升是，减少了JIT在启动时准备代码所花费的时间。&lt;/p&gt;
&lt;blockquote readability=&quot;1.3398058252427&quot;&gt;
&lt;p&gt;Crossgen相关文档：&lt;a href=&quot;https://github.com/dotnet/coreclr/blob/v2.1.3/Documentation/building/crossgen.md&quot; class=&quot;uri&quot;&gt;https://github.com/dotnet/coreclr/blob/v2.1.3/Documentation/building/crossgen.md&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我相信每个.NET Core程序员都会遇到以下陷阱中的一部分。我将尽力解释这些问题是如何产生的。&lt;/p&gt;
&lt;h2 id=&quot;http-error-502.5-process-failure&quot;&gt;Http Error 502.5 Process Failure&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201911/65831-20191105232810335-1400424852.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到目前为止，开发人员，最常遇到的陷阱是在IIS中或者Azure Web Services中托管ASP.NET Core应用程序。这个问题通常发生在开发人员升级了一个项目，或者当应用部署的时候，目标机器没有更新。这个错误的真正原因通常是应用所需版本的共享框架找不到，导致.NET Core应用程序无法正常启动。当&lt;code&gt;dotnet&lt;/code&gt;无法启动应用程序时，IIS会返回HTTP 502.5的错误，但是不会显示内部的错误消息。&lt;/p&gt;
&lt;h2 id=&quot;the-specified-framework-was-not-found&quot;&gt;&quot;The specified framework was not found&quot;&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;It was not possible to find any compatible framework version
The specified framework 'Microsoft.AspNetCore.App', version '2.1.3' was not found.
  - Check application dependencies and target a framework version installed at:
      /usr/local/share/dotnet/
  - Installing .NET Core prerequisites might help resolve this problem:
      http://go.microsoft.com/fwlink/?LinkID=798306&amp;amp;clcid=0x409
  - The .NET Core framework and SDK can be installed from:
      https://aka.ms/dotnet-download
  - The following versions are installed:
      2.1.1 at [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App]
      2.1.2 at [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个错误通常出现在HTTP 502.5错误之后，或者Visual Studio Test Explorer故障。&lt;/p&gt;
&lt;p&gt;如上所述，当&lt;code&gt;runtimeconfig.json&lt;/code&gt;文件指定了一个框架名称和版本，但是经过多级检索特性和前滚策略之后，主机依然无法找到一个合适的框架版本的时候，就会出现以上错误。&lt;/p&gt;
&lt;h2 id=&quot;升级microsoft.aspnetcore.app程序集的nuget包&quot;&gt;升级&lt;code&gt;Microsoft.AspNetCore.App&lt;/code&gt;程序集的Nuget包&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Microsoft.AspNetCore.App&lt;/code&gt;程序集的Nuget包，并不提供共享框架。它只是提供了C#/F#编译器使用的一些API以及少量SDK. 所以你必须要单独下载并安装共享框架。&lt;/p&gt;
&lt;p&gt;同时，由于前滚策略，你并不需要更新Nuget包的版本，来让你的程序运行在新版本的共享框架中。&lt;/p&gt;
&lt;p&gt;这可能是ASP.NET Core团队的一个设计失误，我们无法将共享框架作为Nuget包出现在项目文件中。共享框架所提供的程序包并不是通常意义上的程序包。与大部分程序包不同，它们不是自给自足的。我们希望当项目使用&lt;code&gt;&amp;lt;PackageReference&amp;gt;&lt;/code&gt;时，Nuget能够安装所需的所有引用，但是令人沮丧的是，这些特殊程序包的设计偏离我们期望的模式。当然，现在我们已经得到了各种建议来解决这个问题。我希望它能早日实现。&lt;/p&gt;
&lt;h2 id=&quot;packagereference-includemicrosoft.aspnetcore.app&quot;&gt;&lt;code&gt;&amp;lt;PackageReference Include=&quot;Microsoft.AspNetCore.App&quot; /&amp;gt;&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;在ASP.NET Core 2.1的新项目模板和文档中，微软向开发人员展示了，他们只需要在项目文件中添加如下的一行代码。&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;PackageReference Include=&quot;Microsoft.AspNetCore.App&quot; /&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其他的&lt;code&gt;&amp;lt;PackageReference&amp;gt;&lt;/code&gt;引用代码都必须要包含&lt;code&gt;Version&lt;/code&gt;属性。只有当项目文件是以&lt;code&gt;&amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk.Web&quot;&amp;gt;&lt;/code&gt;开头的，那么以上这句与版本无关的程序包引用才会起作用，并且这里只对&lt;code&gt;Microsoft.AspNetCore.{App, All}&lt;/code&gt;程序集包起作用。Web SDK将根据项中的其他配置, 例如：&lt;code&gt;&amp;lt;TargetFramework&amp;gt;&lt;/code&gt;和&lt;code&gt;&amp;lt;RuntimeIdentifier&amp;gt;&lt;/code&gt;， 来自动选择一个合适的程序包版本。&lt;/p&gt;
&lt;p&gt;如果你在包引用的部分加入的&lt;code&gt;Version&lt;/code&gt;属性，并指定了版本，或者你没有使用Web SDK作为项目文件的开头，则无法使用此功能。这里我很难推荐一个好的解决方案，因为最好的实现方式是基于你对此的理解水平和项目类型的。&lt;/p&gt;
&lt;h2 id=&quot;发布修剪publish-trimming&quot;&gt;发布修剪（Publish Trimming）&lt;/h2&gt;
&lt;p&gt;当你使用&lt;code&gt;dotnet publish&lt;/code&gt;命令发布一个框架依赖的应用时，SDK会使用Nuget的还原结果（restore result)来决定哪些程序集应该出现在发布目录中。有一些程序集是通过Nuget程序集包拷贝的，而有一些就不是，因为他们已经出现在共享框架中。&lt;/p&gt;
&lt;p&gt;这很容易产生一些错误，因为ASP.NET Core作为共享框架和Nuget程序包都是可用的。项目发布修剪特性会尝试通过图形数学来检查依赖传递，以及升级等，并以此选择正确的程序包文件。&lt;/p&gt;
&lt;p&gt;下面我们以如下的项目引用为例：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;PackageReference Include=&quot;Microsoft.AspNetCore.App&quot; Version=&quot;2.1.1&quot; /&amp;gt;
&amp;lt;PackageReference Include=&quot;Microsoft.AspNetCore.Mvc&quot; Version=&quot;2.1.9&quot; /&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;MVC实际上是&lt;code&gt;Microsoft.AspNetCore.App&lt;/code&gt;的一部分，但是当调用&lt;code&gt;dotnet publish&lt;/code&gt;命令发布项目后，你会发现你的项目选用了升级后的&lt;code&gt;Microsoft.AspNetCore.Mvc.dll&lt;/code&gt;程序包，这个程序包比&lt;code&gt;Microsoft.AspNetCore.App&lt;/code&gt;中包含的2.1.1版本要高，所以最终&lt;code&gt;Microsoft.AspNetCore.Mvc.dll&lt;/code&gt;会被拷贝到发布目录中。&lt;/p&gt;
&lt;p&gt;这就不太理想了，因为随着你的应用程序大小不断增长，你永远得不到&lt;code&gt;ReadyToRun&lt;/code&gt;优化版本的&lt;code&gt;Microsoft.AspNetCore.Mvc.dll&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;PS： 这个问题以前很少注意到，不过真的很常见。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;混淆目标框架的别称与共享框架&quot;&gt;混淆目标框架的别称与共享框架&lt;/h2&gt;
&lt;p&gt;如果简单认为&lt;code&gt;&quot;netcoreapp2.0&quot; == &quot;Microsoft.NETCore.App, v2.0.0&quot;&lt;/code&gt;, 你就大错特错了。目标框架别称(Target Framework Moniker简称TFM)只通过项目文件中&lt;code&gt;&amp;lt;TargetFramework&amp;gt;&lt;/code&gt;节点指定的。&quot;netcoreapp2.0&quot;只是希望以人类友好的方式来表达你要使用哪个版本的.NET Core。&lt;/p&gt;
&lt;p&gt;TFM的陷阱在于它的名称太短了。它不能表达出多种共享框架，特定补丁的版本控制，版本前滚，输出类型以及是独立发布还是框架依赖发布等内容。SDK会尝试从TFM推断许多设置，但是无法推断所有内容。&lt;/p&gt;
&lt;p&gt;所以，更准确的说“netcoreapp2.0”意味着&quot;Microsoft.NETCore.App v2.0.0及以上版本&quot;。&lt;/p&gt;
&lt;h2 id=&quot;混淆项目配置&quot;&gt;混淆项目配置&lt;/h2&gt;
&lt;p&gt;最后一个陷阱和项目配置有关。在这里有很多术语和配置名称，它们不总是一致的。这些术语非常令人困惑，因此，如果混淆了这些术语，也没有关系，那不是你的错。&lt;/p&gt;
&lt;p&gt;下面，我就列出一些常见的项目设置及其实际含义。&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;PropertyGroup&amp;gt;
  &amp;lt;TargetFramework&amp;gt;netcoreapp2.1&amp;lt;/TargetFramework&amp;gt;
  &amp;lt;!--
    实际意义:
      * 从Nuget包解析编译引用时使用的API集合的版本
  --&amp;gt;

  &amp;lt;TargetFrameworks&amp;gt;netcoreapp2.1;net471&amp;lt;/TargetFrameworks&amp;gt;
  &amp;lt;!--
    实际意义:
      * 使用两个不同的API集合版本进行编译。但这并不代表多层共享框架
  --&amp;gt;

  &amp;lt;MicrosoftNETPlatformLibrary&amp;gt;Microsoft.AspNetCore.App&amp;lt;/MicrosoftNETPlatformLibrary&amp;gt;
  &amp;lt;!--
    实际意义:
      * 最顶层的共享框架名称
  --&amp;gt;

  &amp;lt;RuntimeFrameworkVersion&amp;gt;2.1.2&amp;lt;/RuntimeFrameworkVersion&amp;gt;
  &amp;lt;!--
    实际意义:
      * 指定了Microsoft.AspNetCore.App程序包的版本，这个版本就是最小的共享框架版本
  --&amp;gt;

  &amp;lt;RuntimeIdentifier&amp;gt;win-x64&amp;lt;/RuntimeIdentifier&amp;gt;
  &amp;lt;!--
    实际意义:
      * 操作系统种类 + CPU架构
  --&amp;gt;

  &amp;lt;RuntimeIdentifiers&amp;gt;win-x64;win-x86&amp;lt;/RuntimeIdentifiers&amp;gt;
  &amp;lt;!--
    实际意义:
      * 运行此项目可能使用的操作系统种类和CPU架构列表，你必须要通过RuntimeIdentifier配置选择其中一个
  --&amp;gt;

&amp;lt;/PropertyGroup&amp;gt;

&amp;lt;ItemGroup&amp;gt;

  &amp;lt;PackageReference Include=&quot;Microsoft.AspNetCore.App&quot; Version=&quot;2.1.2&quot; /&amp;gt;
  &amp;lt;!--
    实际意义:
      * 使用Microsoft.AspNetCore.App作为共享框架
      * 最低版本2.1.2
  --&amp;gt;

  &amp;lt;PackageReference Include=&quot;Microsoft.AspNetCore.Mvc&quot; Version=&quot;2.1.2&quot; /&amp;gt;
  &amp;lt;!--
    实际意义:
      * 引用Microsoft.AspNetCore.Mvc程序包
      * 实际版本2.1.2
  --&amp;gt;

  &amp;lt;FrameworkReference Include=&quot;Microsoft.AspNetCore.App&quot; /&amp;gt;
  &amp;lt;!--
    实际意义:
      * 使用Microsoft.AspNetCore.App作为共享框架.
  --&amp;gt;

&amp;lt;/ItemGroup&amp;gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;共享框架作为.NET Core的可选功能，尽管存在缺陷，但是我认为对于绝大部分用户来说，这是一个合理的默认设置。我依然认为对于.NET Core开发人员来说，了解背后的原理是一件好事，希望本文是对共享框架功能的良好概述。我尽可能的关联了一些官网文档和指南，以便你可以找到更多的信息。如果还有其他问题，请在下面发表评论。&lt;/p&gt;
</description>
<pubDate>Tue, 05 Nov 2019 15:30:00 +0000</pubDate>
<dc:creator>LamondLu</dc:creator>
<og:description>本篇是之前翻译过的《深入理解.NET Core的基元: deps.json, runtimeconfig.json, dll文件》的后续，这个系列作者暂时只写了3篇，虽然有一些内容和.NET Core</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lwqlun/p/11802513.html</dc:identifier>
</item>
<item>
<title>Java对象&quot;后事处理&quot;那点事儿——垃圾回收（一） - 张小云的博客</title>
<link>http://www.cnblogs.com/zhangweicheng/p/11795887.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangweicheng/p/11795887.html</guid>
<description>&lt;p&gt;　　我们都知道对象死亡的时候需要进行垃圾回收来回收这些对象从而释放空间，那么什么样的对象算是死亡呢，有哪些方法可以找出内存中的死亡对象呢？一般来说，我们可以这样认为：如果内存中不存在对当前对象的引用，则此对象一定是死亡状态；但是死亡状态的对象并不一定没有其他对象进行引用（可能存在死亡对象循环引用的情况）。这里需要说明一下，&lt;strong&gt;死亡的对象并不一定会被回收释放占用的空间，&lt;/strong&gt;这种情况就是常称的&lt;strong&gt;&quot;内存泄漏&quot;。&lt;/strong&gt;判定对象存活的算法一般是以下两种。&lt;/p&gt;
&lt;h2&gt;　　1.1 引用计数法&lt;/h2&gt;
&lt;p&gt;　　引用计数法，即在对象内放置一个变量来表示这个对象被引用的次数，如果其他对象引用了当前对象则变量值+1，如果失去引用则-1，当变量值为0的时候表示没有引用，应当回收。此算法并没有被Java采用，因为其存在着一个致命的问题——循环引用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1742516/201911/1742516-20191104223343913-515483303.png&quot; alt=&quot;&quot; width=&quot;579&quot; height=&quot;321&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　如上图中，栈中没有任何堆中两个对象的引用，而堆中的两个对象则互相持有对方的引用，如果使用引用计数法的话引用变量值永远不会为0，从而造成内存泄漏，两个互相引用的对象无法释放空间。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestForGc {

    TestForGc testInstance;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 模拟上图的现象&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        TestForGc testA &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TestForGc();
        TestForGc testB &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TestForGc();
        testA.testInstance &lt;/span&gt;=&lt;span&gt; testB;
        testB.testInstance &lt;/span&gt;=&lt;span&gt; testA;
        testA &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        testB &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 建议垃圾回收器进行回收操作&lt;/span&gt;
&lt;span readability=&quot;2&quot;&gt;        System.gc();
    }
}   &lt;p&gt;然后设置-XX:+PrintGCDetails打印GC日志：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1742516/201911/1742516-20191104225851558-2081986812.png&quot; alt=&quot;&quot; width=&quot;916&quot; height=&quot;193&quot;/&gt;&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;    最终新生代的对象全部被回收，说明JVM使用的&lt;strong&gt;并不是&lt;/strong&gt;使用引用计数法来实现垃圾回收。&lt;/p&gt;
&lt;/div&gt;
&lt;h2&gt;　　1.2 可达性分析算法（GCRoots）&lt;/h2&gt;
&lt;p&gt;　　&lt;strong&gt;GCRoots&lt;/strong&gt;，大意为选中一些特定的对象作为根节点，然后从这些根节点出发寻找可以引用到的所有对象，行程一条&lt;strong&gt;引用链&lt;/strong&gt;（&lt;strong&gt;引用网&lt;/strong&gt;），不在这条链中的对象则标记为死亡，进行回收。根节点的特定对象从下列四种产生：&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;　　&lt;em&gt;1、虚拟机栈中引用的对象。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;　　2、本地方法栈中引用的对象。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;　　3、方法区中静态变量引用的对象。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;　　4、方法区中常量引用的对象。&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; 　　使用GCRoots便不会出现循环引用的问题，如图，虽然A、B相互引用，但是由于不在根节点的引用链中，所以会被标记为可回收对象。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1742516/201911/1742516-20191104231116276-814059232.png&quot; alt=&quot;&quot; width=&quot;479&quot; height=&quot;258&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　在&lt;strong&gt;Hotspot&lt;/strong&gt;虚拟机对GCRoots算法的实现中，大致可以分为三个部分理解。&lt;/p&gt;
&lt;h3&gt;　　1.2.1 枚举根节点&lt;/h3&gt;
&lt;p&gt;　　　　如上所说，根节点的选取对象有四处，如果虚拟机对这些位置进行全盘扫描的话，效率自然要影响不少，所以Hotspot采用一种数据结构来解决这个问题——OopMap。在类加载完成的时候，虚拟机将对象的什么偏移量有什么对象计算出来，在JIT编译过程中在&lt;strong&gt;特定的位置&lt;/strong&gt;记录下栈和寄存器中哪些位置是引用。这样一来GC在扫描的时候就可以直接得到这些引用的信息，从而减少GC的停顿时间。顺便一提，在枚举根节点的时候，为了保持“一致性”，不能再扫描的时候还出现对象引用变化的情况，所以需要暂停所有Java执行线程（被称为&quot;STOP-THE-WORLD&quot;）,即便在具有划时代意义、可以并发执行的CMS收集器中在枚举根节点的时候也需要STW。&lt;/p&gt;
&lt;h3&gt;　　1.2.2 安全点的设置&lt;/h3&gt;
&lt;p&gt;　　　　&lt;strong&gt;OopMap&lt;/strong&gt;数据结构可以说为GC的扫描减少了不少的时间，但是随之而来的还有一个问题，如果每条指令都生成对应的&lt;strong&gt;OopMap&lt;/strong&gt;，那么想必需要大量的额外空间，GC的空间成本将十分巨大，就是何时生成对应&lt;strong&gt;OopMap&lt;/strong&gt;成为当前面临的问题。之前说过在&lt;strong&gt;特定的位置&lt;/strong&gt;会记录下引用的位置，这个特定的位置就是OopMap的生成时机，也就是“&lt;strong&gt;安全点(SafePoint)&lt;/strong&gt;”，在Sop-The-World的时候线程要先跑到安全点才可以进行线程的停顿。那该如何判断这个特定的位置呢？如果设置的太少可能会导致GC时间变长，设置的太多会增大运行时的负荷。Hotspot给出的答案是&lt;strong&gt;以程序“是否具有让程序长时间执行的特征”为标准进行选定&lt;/strong&gt;。&quot;长时间执行&quot;的明显特征就是指令复用，例如&lt;strong&gt;方法调用、循环跳转、异常处理&lt;/strong&gt;等，只有这些指令才能产生安全点。&lt;/p&gt;
&lt;p&gt;　　　　对于安全点来说，另外一个问题就是采用什么样的方式让所有的线程跑到最近的安全点停顿。有两种实现的方式：&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;　　&lt;em&gt;1、&lt;strong&gt;抢先式中断&lt;/strong&gt;：在GC发生的时候首先暂停所有线程，如果发现有线程没在安全点的话，则恢复线程，让其跑到最近的安全点再进行暂停。现在已经很少有使用抢先式的了。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;　　2、&lt;strong&gt;主动式中断&lt;/strong&gt;：GC发生的时候不强制暂停线程，而是设置一个标识变量，线程会去轮询这个标志，如果为&lt;strong&gt;true&lt;/strong&gt;则将自己中断挂起。这个轮询的位置和安全点是重合的，还有创建对象时需要分配内存的地方。&lt;br/&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;　　1.2.3 安全区域&lt;/h3&gt;
&lt;p&gt;　　　　上面安全点的设置几乎已经解决了问题，但是还少了一点，就是建立在线程都是执行状态的时候，那线程不执行的时候呢，例如进入休眠状态的线程，这时候自己不能跑到安全点也不能等待JVM分配时间。此时就需要&lt;strong&gt;安全区域&lt;/strong&gt;来解决这一点。&lt;/p&gt;
&lt;p&gt;　　　　安全区域指的是&lt;strong&gt;在一段代码块中，引用关系不会发生变化&lt;/strong&gt;。当程序走到安全区域的时候，则标识当前线程进入了&lt;strong&gt;安全区域&lt;/strong&gt;。这时候发生GC的时候则可以不用管有安全区域标识的线程，而这些线程在快离开安全区域的时候必须要检查&lt;strong&gt;是否完成了根节点的枚举&lt;/strong&gt;（&lt;strong&gt;或者整个GC的过程&lt;/strong&gt;），如果完成了才可以离开安全区域，否则必须待到完成为止。&lt;/p&gt;

&lt;p&gt; 　　现在我们知道哪些对象是死亡的，哪些对象应该回收，而这个回收有许多种实现的方式（算法），有的算法对死亡对象进行标记最后一并清除、有的算法将内存分块然后将存活对象从一头搬到另一头，还有算法在清除完死亡对象贴心的将存活的对象整放在一块儿，这些都是我们接下来要说的。&lt;/p&gt;
&lt;h2&gt;　　2.1 标记-清除算法&lt;/h2&gt;
&lt;p&gt;　　　正如这个算法的名称一般，其总共有两个阶段——&quot;&lt;strong&gt;标记&lt;/strong&gt;&quot;和&quot;&lt;strong&gt;清除&lt;/strong&gt;&quot;：&lt;strong&gt;首先其会对所有的死亡对象进行标记，最后再一起将这些对象回收。&lt;/strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1742516/201911/1742516-20191105221914329-1374326222.png&quot; alt=&quot;&quot; width=&quot;508&quot; height=&quot;231&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　这个算法是基础的算法，后续的算法都是对其缺点的一些改进。此算法有两个不足的地方，其一从上图也可以看得出来，垃圾回收后的&lt;strong&gt;内存空间不连续，造成许多的内存碎片&lt;/strong&gt;。其二就是其效率问题，标记和清除的效率并不是太高。&lt;/p&gt;
&lt;h2&gt;　　2.2 复制算法&lt;/h2&gt;
&lt;p&gt;　　　为了解决&lt;strong&gt;效率&lt;/strong&gt;和&lt;strong&gt;内存碎片&lt;/strong&gt;的问题，一种称作&quot;copy&quot;的算法出现，这个算法将&lt;strong&gt;内存空间分成两份或以上，一份存放对象，一份空白，当进行垃圾回收的时候将所有的存活对象复制到空白的一份中，然后清空之前存放对象的空间&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1742516/201911/1742516-20191105223827717-1908155300.png&quot; alt=&quot;&quot; width=&quot;486&quot; height=&quot;319&quot;/&gt;&lt;/p&gt;



&lt;p&gt;　　此算法的优点：&lt;strong&gt;一定范围内的高效率&lt;/strong&gt;和&lt;strong&gt;没有内存碎片。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;strong&gt;　缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;em&gt;1、适用于存活对象相较死亡对象少的情况，例如新生代，如果存活的对象较多的话可能得到相反的效果。所以才说是一定范围的高效率。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;　　2、需要划分内存空间。如果本身的内存空间比较小还去划分的话那可能会导致频繁的GC，停顿时间增多，影响用户体验。&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　另：此算法一般用在新生代做垃圾回收算法，并且将新生代分成三个部分——两个&lt;strong&gt;Survivor&lt;/strong&gt;和一个&lt;strong&gt;Eden&lt;/strong&gt;区，其比例默认为1：1：8（可以通过虚拟机参数改变）。当我们生成一个对象（通过关键字&lt;strong&gt;new&lt;/strong&gt;或者反射）的时候，对象首先会分配在&lt;strong&gt;Eden&lt;/strong&gt;区，等到&lt;strong&gt;Eden&lt;/strong&gt;区放不下的时候则触发一次MinorGC，将&lt;strong&gt;Eden&lt;/strong&gt;和其中一个&lt;strong&gt;Survivor&lt;/strong&gt;中的存活对象一起移到另一个&lt;strong&gt;&lt;strong&gt;Survivor&lt;/strong&gt;&lt;/strong&gt;中，然后清空。顺带一提，有存活对象的&lt;strong&gt;&lt;strong&gt;Survivor&lt;/strong&gt;&lt;/strong&gt;总是称作&lt;strong&gt;From&lt;/strong&gt;区，空白的&lt;strong&gt;Suvivor&lt;/strong&gt;总是称作&lt;strong&gt;To&lt;/strong&gt;区，一般新生代存活对象占5%左右。&lt;/p&gt;
&lt;h2&gt;　　2.3 标记-整理法&lt;/h2&gt;
&lt;p&gt;　　　　复制算法是一个非常优秀的算法，但是其只能用于存活对象较少的情况，而对于其他例如年老代中这些存活对象较多的区域则算不上是一个很好的选择。至此，我们需要一个合适的算法——&lt;strong&gt;标记-整理法&lt;/strong&gt;。这个算法基本跟&lt;strong&gt;标记-清除&lt;/strong&gt;一样，但是还多了一个整理的步骤，也就是&lt;strong&gt;标记-清除-整理&lt;/strong&gt;的过程，&lt;strong&gt;不会产生内存碎片&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1742516/201911/1742516-20191105230320788-1782153067.png&quot; alt=&quot;&quot; width=&quot;483&quot; height=&quot;262&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;　　2.4 分代算法&lt;/h2&gt;
&lt;p&gt;　　　　严格来说这不能算是一种算法，应该是一种理念。其把整个内存空间分为两个区域——&lt;strong&gt;新生代&lt;/strong&gt;和&lt;strong&gt;年老代&lt;/strong&gt;(1.8之前还有一个永久代，也就是方法区，但是在1.8之后已经删除)。并且虚拟机对对象定义了&lt;strong&gt;年龄&lt;/strong&gt;的概念，表示该对象熬过了多少次GC，以此来作为对象放在新生代还是年老代的标准之一，默认新生代的对象&lt;strong&gt;15岁之后&lt;/strong&gt;就可以进入年老代了。对于两个区域采用的回收算法也是不同的，&lt;strong&gt;新生代一般采用复制算法，年老代一般采用标记-整理法&lt;/strong&gt;，当然具体还是得看使用的垃圾回收器，如果年老代使用的是CMS的话那么就是&lt;strong&gt;标记-清除&lt;/strong&gt;了。&lt;/p&gt;


&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;It is an honor if I could get some advices or corrections from you guys.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 05 Nov 2019 15:18:00 +0000</pubDate>
<dc:creator>张小云的博客</dc:creator>
<og:description>1、Dead Or Alive 我们都知道对象死亡的时候需要进行垃圾回收来回收这些对象从而释放空间，那么什么样的对象算是死亡呢，有哪些方法可以找出内存中的死亡对象呢？一般来说，我们可以这样认为：如果内</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhangweicheng/p/11795887.html</dc:identifier>
</item>
<item>
<title>Spring Cloud Eureka源码分析---服务注册 - rickiyang</title>
<link>http://www.cnblogs.com/rickiyang/p/11802413.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rickiyang/p/11802413.html</guid>
<description>&lt;p&gt;本篇我们着重分析Eureka服务端的逻辑实现，主要涉及到服务的注册流程分析。&lt;/p&gt;
&lt;p&gt;在Eureka的服务治理中，会涉及到下面一些概念：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;服务注册&lt;/strong&gt;：Eureka Client会通过发送REST请求的方式向Eureka Server注册自己的服务，提供自身的元数据，比如 IP 地址、端口、运行状况指标的URL、主页地址等信息。Eureka Server接收到注册请求后，就会把这些元数据信息存储在一个ConcurrentHashMap中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;服务续约&lt;/strong&gt;：在服务注册后，Eureka Client会维护一个心跳来持续通知Eureka Server，说明服务一直处于可用状态，防止被剔除。Eureka Client在默认的情况下会每隔30秒发送一次心跳来进行服务续约。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;服务同步&lt;/strong&gt;：Eureka Server之间会互相进行注册，构建Eureka Server集群，不同Eureka Server之间会进行服务同步，用来保证服务信息的一致性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;获取服务&lt;/strong&gt;：服务消费者（Eureka Client）在启动的时候，会发送一个REST请求给Eureka Server，获取上面注册的服务清单，并且缓存在Eureka Client本地，默认缓存30秒。同时，为了性能考虑，Eureka Server也会维护一份只读的服务清单缓存，该缓存每隔30秒更新一次。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;服务调用&lt;/strong&gt;：服务消费者在获取到服务清单后，就可以根据清单中的服务列表信息，查找到其他服务的地址，从而进行远程调用。Eureka有Region和Zone的概念，一个Region可以包含多个Zone，在进行服务调用时，优先访问处于同一个Zone中的服务提供者。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;服务下线&lt;/strong&gt;：当Eureka Client需要关闭或重启时，就不希望在这个时间段内再有请求进来，所以，就需要提前先发送REST请求给Eureka Server，告诉Eureka Server自己要下线了，Eureka Server在收到请求后，就会把该服务状态置为下线（DOWN），并把该下线事件传播出去。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;服务剔除&lt;/strong&gt;：有时候，服务实例可能会因为网络故障等原因导致不能提供服务，而此时该实例也没有发送请求给Eureka Server来进行服务下线，所以，还需要有服务剔除的机制。Eureka Server在启动的时候会创建一个定时任务，每隔一段时间（默认60秒），从当前服务清单中把超时没有续约（默认90秒）的服务剔除。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;自我保护&lt;/strong&gt;：既然Eureka Server会定时剔除超时没有续约的服务，那就有可能出现一种场景，网络一段时间内发生了异常，所有的服务都没能够进行续约，Eureka Server就把所有的服务都剔除了，这样显然不太合理。所以，就有了自我保护机制，当短时间内，统计续约失败的比例，如果达到一定阈值，则会触发自我保护的机制，在该机制下，Eureka Server不会剔除任何的微服务，等到正常后，再退出自我保护机制。&lt;/p&gt;
&lt;h4 id=&quot;基本原理&quot;&gt;1. 基本原理：&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;Eureka Server 提供服务注册服务，各个节点启动后，会在Eureka Server中进行注册，这样Eureka Server中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观的看到；&lt;/li&gt;
&lt;li&gt;Eureka Client 是一个Java 客户端，用于简化与Eureka Server的交互，客户端同时也具备一个内置的、使用轮询负载算法的负载均衡器；&lt;/li&gt;
&lt;li&gt;在应用启动后，将会向Eureka Server发送心跳(默认周期为30秒)，如果Eureka Server在多个心跳周期没有收到某个节点的心跳，Eureka Server 将会从服务注册表中把这个服务节点移除(默认90秒)；&lt;/li&gt;
&lt;li&gt;Eureka Server之间将会通过复制的方式完成数据的同步；&lt;/li&gt;
&lt;li&gt;Eureka Client具有缓存的机制，即使所有的Eureka Server 都挂掉的话，客户端依然可以利用缓存中的信息消费其它服务的API；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;上一篇中我们搭建了一个简单的Eureka客户端和服务端。如果你有启动过观看启动日志不难发现：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1607781/201911/1607781-20191105230424367-1039945797.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里有个&lt;code&gt;EurekaServerBootstrap&lt;/code&gt;类，启动日志中给出：&lt;code&gt;Setting the eureka configuration..，Initialized server context&lt;/code&gt;。看起来这个应该是个启动类，跟进去看一下，有个很显眼的方法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1607781/201911/1607781-20191105230549748-1444390294.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个方法的调用先按住不表，我们先从启动类上添加的 &lt;code&gt;EnableEurekaServer&lt;/code&gt;注解着手，看看为什么添加了一个注解就能激活 Rureka。&lt;/p&gt;
&lt;p&gt;从server启动类上的&lt;code&gt;EnableEurekaServer&lt;/code&gt;注解进入：&lt;/p&gt;
&lt;ol readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;接下来引用了&lt;code&gt;EurekaServerMarkerConfiguration&lt;/code&gt;，看到在这个注解上有个注释：启用这个注解的目的是为了激活：EurekaServerAutoConfiguration类；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;进入EurekaServerAutoConfiguration看到在类头部有一个注解：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@ConditionalOnBean(EurekaServerMarkerConfiguration.Marker.class)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;即&lt;code&gt;EurekaServerAutoConfiguration&lt;/code&gt;启动的条件是&lt;code&gt;EurekaServerMarkerConfiguration&lt;/code&gt;注解先加载。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1607781/201911/1607781-20191105230604366-1180405657.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面这一张图标识出了从启动注解到预启动类的流程，但是你会发现实际上 EurekaServerAutoConfiguration 也没有做什么事情：配置初始化，启动一些基本的过滤器。同样在类头部的引用上有一个Import注解：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Import(EurekaServerInitializerConfiguration.class)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以在 EurekaServerAutoConfiguration 初始化的时候，会引用到 EurekaServerInitializerConfiguration，激活它的初始化。EurekaServerInitializerConfiguration 实现了SmartLifecycle.start方法，在spring 初始化的时候会被启动，激活 run 方法。可以看到在 run 方法中调用的就是：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;eurekaServerBootstrap.contextInitialized(EurekaServerInitializerConfiguration.this.servletContext);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;即我们上面截图中的&lt;code&gt;EurekaServerBootstrap.contextInitialized()&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;整体的调用流程如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1607781/201911/1607781-20191105230625107-1022993983.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;具体的初始化信息见下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1607781/201911/1607781-20191105230638561-211396277.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;服务注册实现&quot;&gt;2. 服务注册实现&lt;/h4&gt;
&lt;h5 id=&quot;server端启动时同步别的server上的client&quot;&gt;2.1 server端启动时同步别的server上的client&lt;/h5&gt;
&lt;p&gt;在上面讲到Eureka server启动过程中，启动一个Eureka Client的时候，&lt;code&gt;initEurekaServerContext()&lt;/code&gt;里面会进行服务同步和服务剔除，syncUp()方法所属的类是：PeerAwareInstanceRegistry，即server端的服务注册逻辑都在这里面。因为没有使用AWS的服务器，所以默认实例化的实现类为：PeerAwareInstanceRegistryImpl。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;PeerAwareInstanceRegistry registry;
if (isAws(applicationInfoManager.getInfo())) {
    registry = new AwsInstanceRegistry(
        eurekaServerConfig,
        eurekaClient.getEurekaClientConfig(),
        serverCodecs,
        eurekaClient
    );
    awsBinder = new AwsBinderDelegate(eurekaServerConfig, eurekaClient.getEurekaClientConfig(), registry, applicationInfoManager);
    awsBinder.start();
} else {
    registry = new PeerAwareInstanceRegistryImpl(
        eurekaServerConfig,
        eurekaClient.getEurekaClientConfig(),
        serverCodecs,
        eurekaClient
    );
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;PeerAwareInstanceRegistryImpl 继承了一个抽象类 AbstractInstanceRegistry：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Singleton
public class PeerAwareInstanceRegistryImpl extends AbstractInstanceRegistry implements PeerAwareInstanceRegistry {
    
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;AbstractInstanceRegistry中的实现逻辑是真正的服务注册存储所在地：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public abstract class AbstractInstanceRegistry implements InstanceRegistry {
    private static final Logger logger = LoggerFactory.getLogger(AbstractInstanceRegistry.class);

    private static final String[] EMPTY_STR_ARRAY = new String[0];
    private final ConcurrentHashMap&amp;lt;String, Map&amp;lt;String, Lease&amp;lt;InstanceInfo&amp;gt;&amp;gt;&amp;gt; registry
            = new ConcurrentHashMap&amp;lt;String, Map&amp;lt;String, Lease&amp;lt;InstanceInfo&amp;gt;&amp;gt;&amp;gt;();
    protected Map&amp;lt;String, RemoteRegionRegistry&amp;gt; regionNameVSRemoteRegistry = new HashMap&amp;lt;String, RemoteRegionRegistry&amp;gt;();
    protected final ConcurrentMap&amp;lt;String, InstanceStatus&amp;gt; overriddenInstanceStatusMap = CacheBuilder
            .newBuilder().initialCapacity(500)
            .expireAfterAccess(1, TimeUnit.HOURS)
            .&amp;lt;String, InstanceStatus&amp;gt;build().asMap();

    
 ....
 ....
 ....
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所有的服务实例信息都保存在 server 本地的map当中。所以在server端启动的时候会去拉别的server上存储的client实例，然后存储到本地缓存。&lt;/p&gt;
&lt;h5 id=&quot;client主动注册&quot;&gt;2.2 client主动注册&lt;/h5&gt;
&lt;p&gt;如果是某个client主动发出了注册请求，那么是如何注册到服务端呢？&lt;/p&gt;
&lt;p&gt;还是查看日志：启动服务端，然后再启动客户端，查看服务端日志：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1607781/201911/1607781-20191105230654734-1514487621.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里能看到刚才启动的客户端已经在服务端注册了，注册逻辑走的类是：AbstractInstanceRegistry。&lt;/p&gt;
&lt;p&gt;上面也提到 是服务注册的逻辑实现类，完成保存客户端信息的方法是：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    public void register(InstanceInfo registrant, int leaseDuration, boolean isReplication) {
        ......
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码就不贴了，主要实现的逻辑是保存当前注册的客户端信息。我们知道客户端是发送了一次http请求给服务端，那么真正的注册逻辑应该是从一个http请求的接收处进来的。跟着使用了register方法的地方去找，PeerAwareInstanceRegistryImpl里面有调用：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Override
public void register(final InstanceInfo info, final boolean isReplication) {
    int leaseDuration = Lease.DEFAULT_DURATION_IN_SECS;
    if (info.getLeaseInfo() != null &amp;amp;&amp;amp; info.getLeaseInfo().getDurationInSecs() &amp;gt; 0) {
        leaseDuration = info.getLeaseInfo().getDurationInSecs();
    }
    super.register(info, leaseDuration, isReplication);
    //将新节点信息告诉别的服务端
    replicateToPeers(Action.Register, info.getAppName(), info.getId(), info, null, isReplication);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里没有改写父类的register逻辑，下面还多了一句：replicateToPeers，这里主要做的逻辑是：给兄弟 server节点发送register 请求，告诉他们有客户端来注册。&lt;/p&gt;
&lt;p&gt;继续看谁调用了这里,可以找到：ApplicationResource 的addInstance方法调用了：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@POST
@Consumes({&quot;application/json&quot;, &quot;application/xml&quot;})
public Response addInstance(InstanceInfo info,
                            @HeaderParam(PeerEurekaNode.HEADER_REPLICATION) String isReplication) {
......
  registry.register(info, &quot;true&quot;.equals(isReplication));
  return Response.status(204).build();  // 204 to be backwards compatible
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而这里很显然是一个接口，逻辑就很清晰了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1607781/201911/1607781-20191105230709917-1721907021.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外，我们查看addInstance方法被谁调用的过程中发现：PeerReplicationResource---&amp;gt;batchReplication 方法也调用了注册的逻辑。&lt;/p&gt;
&lt;p&gt;这个方法一看竟然解答了之前我的疑惑：服务端之间是如何发送心跳的。原来实现是在这里。通过dispatch方法来区分当前的调用是何种请求，&lt;/p&gt;
&lt;p&gt;可以看到，服务注册，心跳检测，服务取消，服务下线，服务剔除的入口都在这里：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Path(&quot;batch&quot;)
@POST
public Response batchReplication(ReplicationList replicationList) {
    try {
        ReplicationListResponse batchResponse = new ReplicationListResponse();
        for (ReplicationInstance instanceInfo : replicationList.getReplicationList()) {
            try {
                batchResponse.addResponse(dispatch(instanceInfo));
            } catch (Exception e) {
                batchResponse.addResponse(new ReplicationInstanceResponse(Status.INTERNAL_SERVER_ERROR.getStatusCode(), null));
                logger.error(&quot;{} request processing failed for batch item {}/{}&quot;,
                             instanceInfo.getAction(), instanceInfo.getAppName(), instanceInfo.getId(), e);
            }
        }
        return Response.ok(batchResponse).build();
    } catch (Throwable e) {
        logger.error(&quot;Cannot execute batch Request&quot;, e);
        return Response.status(Status.INTERNAL_SERVER_ERROR).build();
    }
}


private ReplicationInstanceResponse dispatch(ReplicationInstance instanceInfo) {
        ApplicationResource applicationResource = createApplicationResource(instanceInfo);
        InstanceResource resource = createInstanceResource(instanceInfo, applicationResource);

        String lastDirtyTimestamp = toString(instanceInfo.getLastDirtyTimestamp());
        String overriddenStatus = toString(instanceInfo.getOverriddenStatus());
        String instanceStatus = toString(instanceInfo.getStatus());

        Builder singleResponseBuilder = new Builder();
        switch (instanceInfo.getAction()) {
            case Register:
                singleResponseBuilder = handleRegister(instanceInfo, applicationResource);
                break;
            case Heartbeat:
                singleResponseBuilder = handleHeartbeat(serverConfig, resource, lastDirtyTimestamp, overriddenStatus, instanceStatus);
                break;
            case Cancel:
                singleResponseBuilder = handleCancel(resource);
                break;
            case StatusUpdate:
                singleResponseBuilder = handleStatusUpdate(instanceInfo, resource);
                break;
            case DeleteStatusOverride:
                singleResponseBuilder = handleDeleteStatusOverride(instanceInfo, resource);
                break;
        }
        return singleResponseBuilder.build();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从这个入口进去，大家可以跟踪一下感兴趣的逻辑。&lt;/p&gt;
</description>
<pubDate>Tue, 05 Nov 2019 15:08:00 +0000</pubDate>
<dc:creator>rickiyang</dc:creator>
<og:description>本篇我们着重分析Eureka服务端的逻辑实现，主要涉及到服务的注册流程分析。 在Eureka的服务治理中，会涉及到下面一些概念： 服务注册 ：Eureka Client会通过发送REST请求的方式向E</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/rickiyang/p/11802413.html</dc:identifier>
</item>
<item>
<title>Go语言入门：Hello world - Leo_Lei</title>
<link>http://www.cnblogs.com/leiwei/p/11802398.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/leiwei/p/11802398.html</guid>
<description>&lt;blockquote readability=&quot;3.864406779661&quot;&gt;
&lt;p&gt;本文是「vangoleo的Go语言学习笔记」系列文章之一。&lt;br/&gt;官网: &lt;a href=&quot;http://www.vangoleo.com/go/go-hello-world/&quot; class=&quot;uri&quot;&gt;http://www.vangoleo.com/go/go-hello-world/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在上一篇文章&lt;a href=&quot;http://www.vangoleo.com/go/hello-golang&quot;&gt;你好，Go语言&lt;/a&gt;中，我们对Go语言的历史和特点有了认识。接下来，我们就正式进入Go的学习了。&lt;br/&gt;按照大部分编程语言的惯例，我们以经典的“Hello World”开始Go语言的学习之旅。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;经典的“Hello World”案例来自于1978年出版的C语言圣经。很巧合的是该书的作者Brian W. Kernighan也是《Go语言圣经》一书的作者。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本教程中，我会使用最方便的方式Golang Playground来体验Go语言。在浏览器中打开&lt;a href=&quot;https://play.golang.org&quot; class=&quot;uri&quot;&gt;https://play.golang.org&lt;/a&gt;，在页面直接编写Go代码，并运行。使用Golang Playground无需安装Go，无需配置Golang的开发环境(比如环境变量)，无需安装文本编辑器或IDE。&lt;/p&gt;
&lt;p&gt;大部分的Hello World教程都会从如何安装Go，配置环境变量等开始。但是Go语言的安装和开发环境配置其实是一个比较复杂的话题。我希望在大家刚接触Go语言时，能对go语言有一个快速，直观的认识。而不要陷入如何配置Go的开发环境。配置Go的开发环境涉及到Go语言的另外两个概念：GOPATH和Go module。而这又会牵扯到Go语言混乱、悠久的依赖管理发展史。后续会有专门的章节来进行介绍。&lt;/p&gt;

&lt;p&gt;第一步：打开&lt;a href=&quot;https://play.golang.org&quot; class=&quot;uri&quot;&gt;https://play.golang.org&lt;/a&gt;，在编辑框中输入Hello World程序：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package main

import &quot;fmt&quot;

func main() {
    fmt.Println(&quot;Hello world&quot;) 
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如下图所示：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/274170/201911/274170-20191105230604075-1700545063.png&quot; alt=&quot;go-hello-world&quot;/&gt;&lt;br/&gt;第二步：点击“Run”按钮，可以看到程序的输出结果“Hello，world”。&lt;br/&gt;恭喜你，已经编写了第一个Go程序，并正确地输出了结果。&lt;/p&gt;

&lt;p&gt;虽然Hello World程序很简单，但是依然包含了Go语言的一些核心概念。接下来，我们就一行一行地解读Hello World程序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一行&lt;/strong&gt;：&lt;code&gt;package main&lt;/code&gt;&lt;br/&gt;程序的第一行声明了名为main的package。Go语言的代码是通过package来组织的，package的概念和其他语言里的package，module概念类似，是一个逻辑的，包含了相同功能代码的集合。一个package会包含一个或多个&lt;code&gt;.go&lt;/code&gt;源代码文件。每一个源文件都是以package开头。比如我们的例子里是package main。这行声明语句表示该文件是属于哪一个package。&lt;/p&gt;
&lt;p&gt;需要注意，package main是一个比较特殊的package。main package是Go程序的入口。准确说，Go程序的入口是名为main的package中的main方法(即例子中的main方法)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二行&lt;/strong&gt;： import&lt;br/&gt;package声明语句后紧跟着是import语句。import语句会引入其他package到当前文件中，这样就可以在当前文件使用其他package中的变量，常量，类型，方法等。Go的import和Java的import，C++的include类似。&lt;br/&gt;Go标准库已经提供了100多个package，&lt;code&gt;fmt&lt;/code&gt;这个package包含接受输入，格式化输出的各种函数。&lt;code&gt;Println&lt;/code&gt;是其中的一个常用函数，可以格式化地输出一段文本。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第三行&lt;/strong&gt;： func main&lt;br/&gt;第三行声明了一个函数，函数名为main。在Go语言中使用&lt;code&gt;func&lt;/code&gt;关键字来声明一个函数。格式为:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func 函数名(参数名1 参数类型1, 参数名2 参数类型2, ... ) 返回类型1, 返回类型2, ...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;比如下面的方法:&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func sayHello(name string, age int) string&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;声明了一个sayHello方法。接收两个参数：string类型的name和int类型的age。并返回一个string类型的值。&lt;br/&gt;前面也提到了，在main这个package里，main函数也是一个特殊的函数，这是整个程序的入口(其实C系语言差不多都是这样)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第四行&lt;/strong&gt;： fmt.Println&lt;br/&gt;第四行是程序真正执行的逻辑，会输出“Hello world”。fmt是通过import引入的包，是go标准库提供的包。Println是fmt包中定义的一个方法，作用是将文本输出到标准输出。&lt;/p&gt;

&lt;p&gt;通过Hello world，我们可以发现Go语言的一些特点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;语句的结尾不需要分号。这和C系语言，Java等语言不同。&lt;/li&gt;
&lt;li&gt;Go语言不需要显示声明方法或变量的作用范围。即不用显式声明public或private。其实Go语言是通过变量或方法名的首字母是大写还是小写来确定作用范围的。大写字母开头的为public，小写字母开头的为private。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;还有一些Go的特点，由于Hello world程序比较简单，没有体现出来。这里也顺带说一下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Go语言声明变量和方法参数时，名字在前，类型在后。比如&lt;code&gt;var name string&lt;/code&gt;。这和C系语言，Java语言都不同。&lt;/li&gt;
&lt;li&gt;Go语言在代码格式上采取了很强硬的态度。go提供的&lt;code&gt;gofmt&lt;/code&gt;工具会将你的代码格式化为标准格式(这个格式化工具没有任何可以调整代码格式的参数，Go语言就是这么任性)，规定一种标准的代码格式可以规避掉无尽的无意义的圣战(撕逼)(也导致了Go语言的TIOBE排名较低，因为缺少撕逼的话题)。Go的这种哲学可以保证当一个大团队一起开发和维护一个项目时，团队间的协作更加地标准，高效。&lt;/li&gt;
&lt;/ul&gt;&lt;div&gt;&lt;img src=&quot;http://static.codezen.xyz/gongzong-toutiao.png&quot;/&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;2.5757575757576&quot;&gt;
&lt;p&gt;本文由 &lt;a href=&quot;http://www.vangoleo.com&quot;&gt;www.vangoleo.com&lt;/a&gt; 发布&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 05 Nov 2019 15:06:00 +0000</pubDate>
<dc:creator>Leo_Lei</dc:creator>
<og:description>本文是「vangoleo的Go语言学习笔记」系列文章之一。 官网: 'http://www.vangoleo.com/go/go hello world/' 在上一篇文章 '你好，Go语言' 中，我们</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/leiwei/p/11802398.html</dc:identifier>
</item>
<item>
<title>用GitLab Runner自动部署GitBook并不难 - 叶梅树</title>
<link>http://www.cnblogs.com/yemeishu/p/11802357.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yemeishu/p/11802357.html</guid>
<description>&lt;p&gt;相信很多程序员喜欢用 GitBook 来写电子书、教程或者博客，看了不少文章，貌似都缺少说明如何将 GitBook 部署到版本库，并自动在服务器上 build，然后将生成的静态网站部署到云服务器上。&lt;/p&gt;
&lt;p&gt;所以，今天就记录下我是如何一步步将 GitBook 发布到自己的云服务器上的。&lt;/p&gt;
&lt;p&gt;首先需要借助的工具有：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;GitBook&lt;/li&gt;
&lt;li&gt;GitLab&lt;/li&gt;
&lt;li&gt;GitLab Runner&lt;/li&gt;
&lt;li&gt;Nginx&lt;/li&gt;
&lt;li&gt;云服务器 (如：阿里云服务器)&lt;/li&gt;
&lt;li&gt;Docker&lt;/li&gt;
&lt;li&gt;域名&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;本地开发&quot;&gt;本地开发&lt;/h2&gt;
&lt;p&gt;很多教程都写过如何在本地初始化 GitBook 开始写文档。这里简单描述。&lt;/p&gt;
&lt;p&gt;初始化 &lt;code&gt;gitbook init&lt;/code&gt; 后，生成两个文件：&lt;code&gt;README.md&lt;/code&gt; 和 &lt;code&gt;SUMMARY.md&lt;/code&gt;，&lt;code&gt;README.md&lt;/code&gt; 应该不陌生，就是说明文档，而 &lt;code&gt;SUMMARY.md&lt;/code&gt; 其实就是书的章节目录。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://image.coding01.cn/2019/11/03/15727886514222.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有了这两个文件还不够，我们必须要初始化一些我们自己的信息，这时候就需要创建文件：&lt;code&gt;book.json&lt;/code&gt;，看看我的配置文件：&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
  &quot;language&quot;: &quot;zh&quot;,
  &quot;plugins&quot;: [&quot;tbfed-pagefooter&quot;, &quot;sitemap-general&quot;, &quot;rss&quot;, &quot;copy-code-button&quot;, &quot;disqus&quot;, &quot;donate&quot;, &quot;custom-js-css&quot;, &quot;highlight&quot;],
  &quot;pluginsConfig&quot;: {
      &quot;custom-js-css&quot;: {
        &quot;js&quot;: [
          &quot;./bootstrap4/js/bootstrap.bundle.min.js&quot;,
          &quot;./bootstrap4/js/bootstrap.min.js&quot;
        ],
        &quot;css&quot;: [
          &quot;./bootstrap4/css/bootstrap-grid.min.css&quot;,
          &quot;./bootstrap4/css/bootstrap-reboot.min.css&quot;,
          &quot;./bootstrap4/css/bootstrap.min.css&quot;
        ]
      },
    &quot;donate&quot;: {
          &quot;wechat&quot;: &quot;/images/wechat.jpeg&quot;,
          &quot;alipay&quot;: &quot;/images/alipay.jpeg&quot;,
          &quot;title&quot;: &quot;觉得不错点个赞&quot;,
          &quot;button&quot;: &quot;点赞&quot;
        },
        &quot;disqus&quot;: {
            &quot;shortName&quot;: &quot;coding&quot;
        },
        &quot;rss&quot;: {
            &quot;title&quot;: &quot;coding01 自我量化&quot;,
            &quot;description&quot;: &quot;coding01 自我量化&quot;,
            &quot;author&quot;: &quot;叶梅树&quot;,
            &quot;feed_url&quot;: &quot;https://ziwolianghua.coding01.cn/rss&quot;,
            &quot;site_url&quot;: &quot;https://ziwolianghua.coding01.cn/&quot;,
            &quot;managingEditor&quot;: &quot;yemeishu@126.com&quot;,
            &quot;webMaster&quot;: &quot;yemeishu@126.com&quot;,
            &quot;categories&quot;: [
                &quot;ziwolianghua&quot;
            ]
        },
        &quot;sitemap-general&quot;: {
            &quot;prefix&quot;: &quot;https://ziwolianghua.coding01.cn&quot;
        },
        &quot;tbfed-pagefooter&quot;: {
        &quot;copyright&quot;:&quot;Copyright &amp;amp;copy coding01 2018&quot;,
        &quot;modify_label&quot;: &quot;该文件修订时间：&quot;,
        &quot;modify_format&quot;: &quot;2019-11-3 21:20:20&quot;
    }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里主要用到的插件有：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&quot;tbfed-pagefooter&quot;, &quot;sitemap-general&quot;, &quot;rss&quot;, &quot;copy-code-button&quot;, &quot;disqus&quot;, &quot;donate&quot;, &quot;custom-js-css&quot;, &quot;highlight&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这些插件完全可以根据自己的情况而定，当然，我们也选择了一些自定义 &lt;code&gt;js&lt;/code&gt; 和 &lt;code&gt;css&lt;/code&gt;，整个结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://image.coding01.cn/2019/11/03/15727894585734.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以安装插件看看执行效果了：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;gitbook install &amp;amp;&amp;amp; gitbook serve&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://image.coding01.cn/2019/11/03/15727916441353.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来可以写两个文件：简介和开篇。&lt;/p&gt;
&lt;p&gt;看我们的 &lt;code&gt;SUMMARY.md&lt;/code&gt; 文件：&lt;/p&gt;
&lt;pre class=&quot;markdown&quot;&gt;
&lt;code&gt;# Summary

## [介绍](README.md)


## 1. 理论

### 1.1 开篇

* [1.1.1 前言](1.1.1.md)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也可以看看 &lt;code&gt;README.md&lt;/code&gt; 内容：&lt;/p&gt;
&lt;pre class=&quot;markdown&quot;&gt;
&lt;code&gt;# 自动化自我量化

## 关于系统

由于我使用的是 iPhone + rMBP + Apple Watch ，所以本文的大部分内容是基于 Apple 生态下写的，如果你是 Android 生态设备，可以尝试类似的工具和方法论。

## 关于作者

&amp;gt; coding01 自由程序员

## LICENSE

![知识共享许可协议 Figure: 知识共享许可协议](https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png)

[知识共享许可协议 Figure: 知识共享许可协议](http://creativecommons.org/licenses/by-nc-nd/4.0/)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果如下：&lt;br/&gt;&lt;img src=&quot;http://image.coding01.cn/2019/11/03/15727930685232.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里我放了一篇我之前写好的 「前言」，基本满足自定义的样式效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://image.coding01.cn/2019/11/05/15729616685893.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到此，基本的 GitBook 本地制作完成，下一步就看如何部署到服务器上了。&lt;/p&gt;
&lt;p&gt;由于我自己有云服务器，所以推荐使用 GitLab 做代码版本控制，然后把 GitBook 电子书静态文件也部署到自己服务器上，配置自定义域名访问。&lt;/p&gt;
&lt;p&gt;这里重点不是说如何部署 GitLab，而是说另一个问题，因为 GitBook build 之后的实际上是纯静态网站，可以直接使用 Nginx 或其他来配置域名直接访问。&lt;/p&gt;
&lt;p&gt;所以这里的难点是，如何将代码 &lt;code&gt;commit&lt;/code&gt; 到 GitLab 后，直接 &lt;code&gt;gitbook build&lt;/code&gt; 产生静态网站内容，放置指定的路径下，提供 Nginx 等解析。&lt;/p&gt;
&lt;p&gt;这里推荐使用「Gitlab Runner」。&lt;/p&gt;
&lt;h2 id=&quot;gitlab-runner&quot;&gt;Gitlab Runner&lt;/h2&gt;
&lt;p&gt;如果我们自己已经使用Gitlab docker 环境，或者看我之前的 blog，应该知道我是基于 Laradock，所以直接注册一个 Gitlab Runner。&lt;/p&gt;
&lt;p&gt;在注册之前，需要拿到该 Gitlab 项目的 Gitlab Runner token：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://image.coding01.cn/2019/11/03/15727952336991.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后注册一个 Gitlab Runner：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;dc exec gitlab-runner gitlab-runner register&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://image.coding01.cn/2019/11/05/15729429053196.jpg&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注：一样的，你也可以直接进入 Gitlab Runner 容器，在配置文件中添加。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;创建后，即可以在项目设置中看到：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://image.coding01.cn/2019/11/05/15729438149919.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里，我们使用 &lt;code&gt;docker&lt;/code&gt; 模式，创建 &lt;code&gt;node&lt;/code&gt; 镜像，供下文的 GitBook 编译，生成静态网站。&lt;/p&gt;
&lt;p&gt;好了，接下来就是编写 &lt;code&gt;.gitlab-ci.yml&lt;/code&gt; 文件了：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;image: node:latest

build:
    stage: build
    artifacts:
        paths:
         - _book
    script: 
     - npm install gitbook-cli -g
     - gitbook install
     - gitbook build
    tags:
     - build

test:
    stage: test
    script: 
     - echo &quot;no tests.&quot;
    tags:
     - test

deploy:
    stage: deploy
    script:
     - rm -rf /var/www/ziwolianghua/*
     - cd _book
     - cp -rf . /var/www/ziwolianghua
     - echo &quot;发布成功!&quot;
    tags:
     - deploy
    only:
     - master&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里配置了三个 tag：build、test 和 deploy，和 GitLab Runner 设置的 tags 配合使用。当满足 build、test 时，就会触发我们刚才定义的 &lt;code&gt;ziwolianghua_build_test&lt;/code&gt; Runner，也就会执行我们定义好的 &lt;code&gt;build&lt;/code&gt; 和 &lt;code&gt;test&lt;/code&gt; jobs，编译和测试我们网站。&lt;/p&gt;
&lt;p&gt;我们将本地代码 push 到 Gitlab 看看效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://image.coding01.cn/2019/11/05/15729442889827.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://image.coding01.cn/2019/11/05/15729443453411.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;build 和 test 成功后，我们接下来就需要把生成的静态代码部署到指定路径上，这时候不再是 &lt;code&gt;docker&lt;/code&gt; 模式了，改为 &lt;code&gt;shell&lt;/code&gt;，因为我们在相同的服务器部署网站，而且通过 docker 共享 volumn，将文件存放地方和 nginx 共享，这样就可以直接在 nginx 容器下配置访问。&lt;/p&gt;
&lt;p&gt;接下来，配置第二个 「Gitlab-Runner」：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://image.coding01.cn/2019/11/05/15729446713739.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好了，我们再看看 jobs 运行结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://image.coding01.cn/2019/11/05/15729448035268.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://image.coding01.cn/2019/11/05/15729447751625.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;发布成功。&lt;/p&gt;
&lt;p&gt;这时候我们只需配置 ngnix 去访问这个路径即可，这里就不再赘述了。&lt;/p&gt;
&lt;p&gt;直接访问链接 &lt;a href=&quot;https://ziwolianghua.coding01.cn&quot; class=&quot;uri&quot;&gt;https://ziwolianghua.coding01.cn&lt;/a&gt; 看看效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://image.coding01.cn/2019/11/05/15729584012609.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;从本地使用 &lt;code&gt;GitBook init&lt;/code&gt; 开始写 blog 和电子书，然后代码托管到 GitLab 上，再利用 GitLab Runner 自动化编译和部署网站，一气呵成。这样做的好处是，只要写好的 markdown 电子书扔到项目中，在目录文件上添加路径即可，我们可以随时随地更新和提交原始代码，完全不用考虑在本地部署 GitBook 环境了，而生成静态文件的任务交给服务器自动完成。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;「完」&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 05 Nov 2019 14:56:00 +0000</pubDate>
<dc:creator>叶梅树</dc:creator>
<og:description>在哪都可以用 GitBook 写电子书，将发布直接交给GitLab Runner自动化操作。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yemeishu/p/11802357.html</dc:identifier>
</item>
<item>
<title>【C#多线程】1.Thread类的使用及注意要点 - 裤兜</title>
<link>http://www.cnblogs.com/512kd/p/11802321.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/512kd/p/11802321.html</guid>
<description>&lt;p&gt;　　因为在C#中，Thread类在我们的新业务上并不常用了（因为创建一个新线程要比直接从线程池拿线程更加耗费资源），并且在.NET4.0后新增了Task类即Async与await关键字，使得我们基本不再用Thread了，不过在学习多线程前，有必要先了解下Thread类，这里就先随便讲讲Thread。&lt;/p&gt;
&lt;h2&gt;1.使用多线程的几种方式&lt;/h2&gt;
&lt;p&gt;　　多线程Thread类只支持运行两种方法，一种是无参数并且无返回值的方法，第二种是有一个Object类型参数(有且只能有一个参数，并且必须是Object类型）且无返回值的方法。如果想让多线程方法携带多个参数，可以将多个参数放入一个集合或数组中传入方法。&lt;/p&gt;
&lt;p&gt;　　下面例子使用了控制台来演示多线程的简单使用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; ConsoleApplication1
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;无参数无返回值方法&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; DoSomething()
        {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;100&lt;/span&gt;; i++&lt;span&gt;)
            {
                Thread.Sleep(&lt;/span&gt;&lt;span&gt;500&lt;/span&gt;&lt;span&gt;);
            }
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;有参数无返回值方法&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; DoSomethingWithParameter(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; obj)
        {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; (&lt;span&gt;int&lt;/span&gt;)obj; i++&lt;span&gt;)
            {
                Console.WriteLine(Thread.CurrentThread.ManagedThreadId);
                Thread.Sleep(&lt;/span&gt;&lt;span&gt;500&lt;/span&gt;&lt;span&gt;);
            }
        }

   
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取主线程ID&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; currentThreadId =&lt;span&gt; Thread.CurrentThread.ManagedThreadId;
            Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;---------主线程&amp;lt;{currentThreadId}&amp;gt;开始运行---------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;多线程运行无参数方法方式1&lt;/span&gt;
            ThreadStart ts = DoSomething;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ThreadStart是一个无参数，无返回值的委托&lt;/span&gt;
            Thread thread1 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(ts);
            thread1.Start();
            
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;多线程运行无参数方法方式2&lt;/span&gt;
            Thread thread2 = &lt;span&gt;new&lt;/span&gt; Thread(DoSomething);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;可省略ThreadStart&lt;/span&gt;
&lt;span&gt;            thread2.Start();

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;多线程运行有参数方法方式1
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ParameterizedThreadStart是一个有一个Object类型参数，但是无返回值的委托。&lt;/span&gt;
            ParameterizedThreadStart pts =&lt;span&gt; DoSomethingWithParameter;
            Thread thread3 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(pts);
            thread3.Start(&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;);
            
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;多线程运行有参数方法方式2
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;可以省略ParameterizedThreadStart&lt;/span&gt;
            Thread thread4 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(DoSomethingWithParameter);
            thread4.Start(&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;还可以使用lamda表达式简化多线程写法&lt;/span&gt;
            &lt;span&gt;new&lt;/span&gt; Thread(() =&amp;gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;100&lt;/span&gt;; i++&lt;span&gt;)
                {
                    Console.WriteLine(Thread.CurrentThread.ManagedThreadId);
                    Thread.Sleep(&lt;/span&gt;&lt;span&gt;500&lt;/span&gt;&lt;span&gt;);
                }
            }).Start();
            Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;---------主线程&amp;lt;{currentThreadId}&amp;gt;运行结束---------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　运行结果如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1304344/201911/1304344-20191105214211989-263665700.png&quot; alt=&quot;&quot; width=&quot;308&quot; height=&quot;207&quot;/&gt;&lt;/p&gt;



&lt;h2&gt; 2.前台线程与后台线程&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;前台线程&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　如主线程（或称为UI线程）就是前台线程，默认Thread的实例均为前台线程，前台线程的特点是，如果当前应用的前台线程没有全部运行完毕，那么当前应用就无法退出。举个例子，我们知道正常情况下，控制台应用在Main方法结束后会自动结束当前进程，如果我们在Main方法中创建了一个新Thread线程，并使其保持运行，那么即使Main方法执行完毕，控制台进程也无法自动关闭（除非手动右上角点×）。就如下图情况，画红圈的地方表示Main方法执行完毕，可是程序依旧在运行，所以我们一般在用Thread的时候会将Thread设置为后台线程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1304344/201911/1304344-20191105215242914-1292049032.png&quot; alt=&quot;&quot; width=&quot;303&quot; height=&quot;197&quot;/&gt;&lt;/p&gt;



&lt;ul&gt;&lt;li&gt;&lt;strong&gt;后台线程&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　后台线程与前台线程的唯一区别是，它不会去影响程序的生老病死，当程序的前台线程全部关闭（即程序退出），那么即使程序的后台线程依旧在执行任务，那么也会强制关闭。&lt;/p&gt;
&lt;p&gt;　　设置Thread为后台线程的方式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;        Thread tt = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(DoSomething);
        tt.IsBackground &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置tt为后台线程&lt;/span&gt;
        tt.Start();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　前台线程与后台线程对程序的影响效果看似好像不算大，但是如果我们在做Winform或者WPF项目时，若在某窗体内执行一个新线程任务（这个新线程是前台线程），如果在任务执行期间关闭程序，此时会发现，虽然界面都被关闭，但是计算机任务管理器中此程序依旧还在运行（并且如果在新线程中执行的任务异常导致线程无法关闭，那么这个程序就会一直在后台跑下去），再次开启程序可能会导致打不开等后果，这种行为是非常不好的。所以我们一般使用多线程Thread类时，最好顺手将它设置为后台线程。我们可以举个例子。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;        &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取主线程ID&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; currentThreadId =&lt;span&gt; Thread.CurrentThread.ManagedThreadId;
            Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;---------主线程&amp;lt;{currentThreadId}&amp;gt;开始运行---------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行一个大概可以运行50秒的新线程&lt;/span&gt;
            Thread t = &lt;span&gt;new&lt;/span&gt; Thread(() =&amp;gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;100&lt;/span&gt;; i++&lt;span&gt;)
                {
                    Console.WriteLine(Thread.CurrentThread.ManagedThreadId);
                    Thread.Sleep(&lt;/span&gt;&lt;span&gt;500&lt;/span&gt;&lt;span&gt;);
                }
            });
            t.IsBackground &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置t为后台线程&lt;/span&gt;
&lt;span&gt;            t.Start();

            Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;---------主线程&amp;lt;{currentThreadId}&amp;gt;运行结束---------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这个例子的运行结果就不截图了，因为控制台会一闪而过（立即执行完Main方法便关闭），即使后台线程t还在执行任务，但是也会强制关闭。&lt;/p&gt;

&lt;h2&gt;3.让主线程等待新线程执行完成后再继续执行（使用Thread的Join方法）&lt;/h2&gt;
&lt;p&gt;　　直接上代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;        &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取主线程ID&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; currentThreadId =&lt;span&gt; Thread.CurrentThread.ManagedThreadId;
            Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;---------主线程&amp;lt;{currentThreadId}&amp;gt;开始运行---------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行一个大概可以运行50秒的新线程&lt;/span&gt;
            Thread t = &lt;span&gt;new&lt;/span&gt; Thread(() =&amp;gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;20&lt;/span&gt;; i++&lt;span&gt;)
                {
                    Console.WriteLine(Thread.CurrentThread.ManagedThreadId);
                    Thread.Sleep(&lt;/span&gt;&lt;span&gt;500&lt;/span&gt;&lt;span&gt;);
                }
            });
            t.IsBackground &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置t为后台线程&lt;/span&gt;
&lt;span&gt;            t.Start();

            t.Join();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在t线程执行期间，如果主线程调用t线程的Join方法，主线程会卡在这个地方直到t线程执行完毕&lt;/span&gt;
&lt;span&gt;
            Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;---------主线程&amp;lt;{currentThreadId}&amp;gt;运行结束---------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;4.Thread实例的其他常用方法&lt;/h2&gt;
&lt;p&gt;　　直接看代码注释吧：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;        &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行一个大概可以运行50秒的新线程&lt;/span&gt;
            Thread t = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(DoSth);
            t.IsBackground &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置t为后台线程&lt;/span&gt;
&lt;span&gt;            t.Start();

            t.Join();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在t线程执行期间，如果主线程调用t线程的Join方法，主线程会卡在这个地方知道t线程执行完毕&lt;/span&gt;
            t.Priority = ThreadPriority.Normal;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置线程调度的优先级&lt;/span&gt;
            ThreadState rhreadState = t.ThreadState;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取线程运行状态。&lt;/span&gt;
            &lt;span&gt;bool&lt;/span&gt; b = t.IsAlive;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取线程当前是否存活&lt;/span&gt;
            t.Interrupt();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;中断当前线程&lt;/span&gt;
            t.Abort();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;终止线程          &lt;/span&gt;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;5.Thread类的常用方法&lt;/h2&gt;
&lt;p&gt;　　直接看代码注释吧：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;        &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使得当前线程暂停1秒再继续执行,此处会暂停主线程1秒钟
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果写在其他线程执行的方法中，会让执行那个方法的线程暂停1秒再继续执行）&lt;/span&gt;
            Thread.Sleep(&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取当前执行线程的线程实例&lt;/span&gt;
            Thread t =&lt;span&gt; Thread.CurrentThread;             
        }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;下节我们会简单讲讲线程池+同步回调+异步回调+跨线程访问UI。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 05 Nov 2019 14:50:00 +0000</pubDate>
<dc:creator>裤兜</dc:creator>
<og:description>Thread随便讲讲 因为在C#中，Thread类在我们的新业务上并不常用了（因为创建一个新线程要比直接从线程池拿线程更加耗费资源），并且在.NET4.0后新增了Task类即Async与await关键</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/512kd/p/11802321.html</dc:identifier>
</item>
<item>
<title>计算机的运算方法 - 赐我白日梦</title>
<link>http://www.cnblogs.com/ZhuChangwu/p/11802225.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ZhuChangwu/p/11802225.html</guid>
<description>&lt;hr/&gt;&lt;hr/&gt;&lt;h2 id=&quot;计算机的运算方法&quot;&gt;计算机的运算方法&lt;/h2&gt;
&lt;h3 id=&quot;无符号数&quot;&gt;无符号数&lt;/h3&gt;
&lt;p&gt;计算机中的数存放在寄存器中,通常将寄存器的位数称为机器字长, 大家说的无符号数其实就是不区分正负号的数,换句话说,就是没负数,全是正数,大家知道,计算机中的数是以0-1存储的, 假如我们的寄存器16位, 无符号数表示的范围就是0~65535 (2^64=65536), 有符号就是分正负数,总数65536就被分成两半,一半正数,一般负数,范围就是 -32768~32767&lt;/p&gt;
&lt;h3 id=&quot;有符号数&quot;&gt;有符号数&lt;/h3&gt;
&lt;p&gt;有符号数,就是正负数同时存在, 人们固然能区分开整正负数,计算机怎么区分呢?&lt;/p&gt;
&lt;p&gt;前面说了,计算机只认识01这样的数,于是人们规定 0表示正数, 1表示负数, 于是这样符号就被数字化了, 并且规定将其放在真实值前面, 于是有符号数就诞生了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1496926/201911/1496926-20191105223305464-294165544.png&quot; alt=&quot;真值和机器数&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图,按照计算机存数数据的特性将符号数字化, 数字化后的编码方式得到的结果称为&lt;strong&gt;机器数&lt;/strong&gt;, 将带有+-符号的数字称为&lt;strong&gt;真值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;既然现在将有符号数数字化后,新的问题来了,当这些机器数之间需要进行运算时, 符号位怎么办? 符号位能否参加机器数之间的运算呢? 如果说,需要参加运算又需要哪些处理才能消除符号位对计算结果的影响呢? &lt;strong&gt;这一连串问题就引出了符号位和数值位所构成的编码: 原码 , 补码 , 反码 , 移码&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;strong&gt;其实在学习的过程中该一直问自己,自己在干什么??? 就比如现在,我在前面大概说了说计算机是如何表示数字的，于是认识了机器码，机器码之间需要进行运算于为了设计出使机器码运算的方式，人们对机器码进行不同的变形编码，得到了，原码 ， 补码， 反码 ， 移码等， 下面看一下这几种编码的由来，以及他们对实现机器码的可计算的贡献&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;原码&quot;&gt;原码&lt;/h3&gt;
&lt;p&gt;原码是机器码最简单的一种变形，同样的它的符号位0表示正数，1表示负数。 数值位就是真值的绝对值&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;人们为了书写方便已经区分小数和整数，在符号位和数值位之间使用逗号分隔&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;整数的原码&quot;&gt;整数的原码&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1496926/201911/1496926-20191105223305121-728150208.png&quot; alt=&quot;整数原码&quot;/&gt;&lt;/p&gt;
&lt;p&gt;举个例子:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;x= +1110, 那么它的原码就是 0，1110
x= -1110, 原码=1，1110&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;小数的原码&quot;&gt;小数的原码&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1496926/201911/1496926-20191105223304272-1669596046.png&quot; alt=&quot;小数原码&quot;/&gt;&lt;/p&gt;
&lt;p&gt;举个例子&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;x= 0.1101 ,  那么它的原码就是      0.1101
x= -0.1101,  原码=1 - (-0.1101) = 1.1101&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看上面的原码计算方式，显然机器码很容易就转成原码，但是想想如果用原码进行数值运算的话就会带来很多麻烦，我们得先判断两个机器数绝对值的大小然后用大的减去小的，最终的符号再按照绝对值大的算， &lt;strong&gt;而且我们需要设计两套运算流程，一套给加法用，一套给减法用， 但是前辈们很智慧，因为人们找到了一种方式，找到了一个正数去替换原来减数位置的负数，类似像下面这样，实现了在计算机中仅仅设计一套加法器就实现加减法的运算&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;5-3=2
5+(-3)=2&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;上述方法的实现就依赖于下面的补码&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;补码&quot;&gt;补码&lt;/h3&gt;
&lt;p&gt;补码的概念和补数的概念很像， 比如现在时钟六点了，我们想让它指向三点，于是我们可以往回转3（6-3=3）圈时针能回退到3点，也可以往前转9圈（6+9=15），可以前进到三点， 对时钟来说往顺时针还是逆时针的过程不一样，但是对我们来说结果是一样的，都是三点了&lt;/p&gt;
&lt;p&gt;这个过程就类似于，找到一个正数，让这个正数代替负数去参加运算，使用加法运算器也能得到正确的结果&lt;/p&gt;
&lt;p&gt;时钟旋转一圈12小时，在这12小时中是不被显示且自动丢失的，也就是说 15-3=3 点， 于是我们可以说，其实对时钟来说， -3 +9 的作用其实是一致的，结果都是三点， &lt;strong&gt;在数学上我们将12称为模 ，写成mod 12 ， 我们管9 称为是 -3以12为模的补数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;于是我们得知，只要我们确定了模，我们就能求出这个数对这个模的地位相同的补数，或者说当我们想将已知的负数转换成可以替换他的正数的话，借助模就可以完成&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何利用模求补数呢？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;正数的补数是它本身&lt;/li&gt;
&lt;li&gt;负数可以用它的正补数等价替换&lt;/li&gt;
&lt;li&gt;负数的补数= 模+负数本身&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如何进行求模示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;-3    全等于 +7    (mod10)
+7    全等于 +7    (mod10)
-3    全等于 +97   (mod100)

-1011 全等于 +0101    (mod2^4)
2^4=1 0 0 0 0
-     1 0 1 1
---------------
      0 1 0 1
   
+0101  全等于 +0101   (mod2^4)

小数的mod = 2
+0.1001 全等于 +0.1001  (mod2)

-0.1001 全等于 +1.0111  (mod2)
 1 0.0 0 0 0
-  0.1 0 0 1
--------------
   1.0 1 1 1

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;求补码的公式&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1496926/201911/1496926-20191105223303360-106421187.png&quot; alt=&quot;正补公式&quot;/&gt;&lt;/p&gt;
&lt;p&gt;求负数补数的示例&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1496926/201911/1496926-20191105223302754-292866049.png&quot; alt=&quot;正补示例&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其实大家可以看一下,对负数的公式来说,公式中的n就是负数的位数, -1101 一共四位, n=4, 但是取的是n+1位, 换句话说是用一个比原负数多两位的数加上这个负数, &lt;strong&gt;多出来一个符号位&lt;/strong&gt;, &lt;strong&gt;最后的结果中别忘了用 逗号分隔符号位和数值位, 当然这是为了方便我们自己看,让人们一眼看去知道最开始的1是个符号位,后面的数才是 想求的补数结果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;小数求补码的公式&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1496926/201911/1496926-20191105223302127-1384971530.png&quot; alt=&quot;小数补码公式&quot;/&gt;&lt;/p&gt;
&lt;p&gt;举个例子: 求 -0.0110 的补码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1496926/201911/1496926-20191105223301602-807358030.png&quot; alt=&quot;求小数的补码示例&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;此外, +0 -0的补码都是 0&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;从上面的讨论我们知道,之所以想引入补码是为了消除减法运算,即将一个负数转换成它的正数补码,但是根据补码的定义,大家可以看到上面的两个例子,在产生补码的过程中又出现了减法运算,怎么办呢?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;于是我们这样求补码: 先求原码, 然后变换这个原码得到补码, 怎么变换呢? 就是将除了 符号位的原码其它为取反 之后再加1&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;举个例子: 上面的就用 -1101 来说, 如下:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1496926/201911/1496926-20191105223300807-22000225.png&quot; alt=&quot;从原码求补码&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;于是看到这里我们彻底知道了,只为计算机设计一个加法器是完全ok的,下文会介绍如何运算&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;反码&quot;&gt;反码&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;通过上面的运算我们知道下面的运算规则&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;原码(符号位,数值位) =&amp;gt; 除符号位外其他位取反  = 反码
反码+1 = 补码
补码-1 = 反码&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;由此可知,其实这个反码就是原码和补码双方转换时的中间状态&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;小结&quot;&gt;小结&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;原码,反码,补码的最高位都是符号位, 符号位和数值位之间使用.或者逗号分隔(小数用点, 整数用逗号)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;真值为整数时, 原码,反码,补码的表示形式是相同的&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;虽然真值为负数时,原码.反码补码各不相同,但是最高位的符号为都是1, 并且原码求反+1=补码 , 原码每位求反=反码&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;移码&quot;&gt;移码&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;真值转换成补码后,由于符号位和数值位是一起进行编码的,因此人们很难分清补码之间的大小&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;就像下面这样&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;十进制的21  对应二进制为+10101  补码为 0,10101
十进制的-21  对应二进制为-10101  补码为 1,01011
十进制的31  对应二进制为 +11111  补码为 0,11111
十进制的-31  对应二进制为-11111  补码为 1,00001&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;直观上看他们的大小是 101011&amp;gt;010101 100001&amp;gt;011111 而实际上恰恰相反&lt;/p&gt;
&lt;p&gt;于是我们这样, 在每一个真值的基础上加上一个2^n , 情况就发生了变化&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;+10101  加上2^5  得 110101
-10101  加上2^5  得 001011
+11111  加上2^5  得 111111
-11111  加上2^5  得 000001&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样的话不需要借助补码,六位代码本身就能看到出真值的大小&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;更进一步,通过观察可以发现,其实一个数的补码和移码之间就差一个符号位,换句话说,如果我们将补码的符号位从0换为1,或者从1换成0得到的就是它的移码, 在这基础上比较大小得到的结果是准确的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;此外正负零的移码的一样的&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;移位运算&quot;&gt;移位运算&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;计算机中的机器数的字长往往是固定的,当机器数左移n位或者是又移n位时,势必会倒是另外一边出现空位,那么在出现空位的位置到底是补充1还是填充0呢? 这取决于机器数是有符号还是无符号,其中有符号的机器数采取的位移称为算数位移,无符号的唯一称为逻辑位移&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;算数位移的移位规则&quot;&gt;算数位移的移位规则&lt;/h4&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;正数&lt;/td&gt;
&lt;td&gt;原码,补码,反码&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;负数&lt;/td&gt;
&lt;td&gt;原码&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;负数&lt;/td&gt;
&lt;td&gt;原码&lt;/td&gt;
&lt;td&gt;左移添0&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;负数&lt;/td&gt;
&lt;td&gt;补码&lt;/td&gt;
&lt;td&gt;右移添1&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;负数&lt;/td&gt;
&lt;td&gt;反码&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;无论是正数还是负数,移位后的符号位都是不变的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;举几个例子&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
        机器数        十进制
移位前 : 0,0011010      +26
左移1位: 0,0110100      +52
右移1位: 0,0001101      +13&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;左移一位,除符号位外原来的最高位被移走了,右边空出的1位用0补全,但是高位丢失了其实得到的就是错误的结果,但是这个错误的结果恰好是原值的2倍,而且唯一运算速度还快,因此很多框架的底层都青睐使用这个位移运算的特性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;每次右移时,最右边的数就会丢失,精度收到影响&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;左移一位相当于乘以2,右移1位相当于除以2&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;逻辑位移的移位规则&quot;&gt;逻辑位移的移位规则&lt;/h4&gt;
&lt;p&gt;逻辑左移,高位丢失,低位填0, 逻辑右移,低位丢失,高位补0&lt;/p&gt;
&lt;h3 id=&quot;加法与减法运算&quot;&gt;加法与减法运算&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;回到一开始话题,计算机的运算方法,前面通过补码的介绍我们知道了只设计一套加法器其实是可行的,下面具体看一下是如何进行运算的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;即 A-B = A + (-B)&lt;/p&gt;
&lt;p&gt;补码的加法公式&lt;/p&gt;
&lt;pre class=&quot;=&quot;&gt;
&lt;code&gt;整数:  [A]补 + [B]补 = [A+B]补  (mod 2^n+1)
小数:  [A]补 + [B]补 = [A+B]补  (mod 2)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于减法来说&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;整数:  [A-B]补 = [A]+[-B]补  (mod 2^n+1)
小数:  [A-B]补 = [A]+[-B]补  (mod 2)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后看一个例子: 看看计算机如何将减法转换成加法并携带符号位运行得出正确结果&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;假设机器8位(含一位符号位),若A=+15 B=+24, 让我们求 [A-B]补 ,并还原真值&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;A=+15 = +0001111  (算上+号一共八位)           
b=+24 = +0011000  (算上+号一共八位)

A和B都是整数,所以他们的补码就是原码本身:
[A]补 = 0,0001111
[B]补 = 0,0011000

[-B]原码 = 1，0011000
[-B]反码 = 1，1100111  （ 除符号位取反得到反码：）
[-B]补   = 1，1101000   （由反码+1得到）

[A-B]补 = [A]补 + [-B]补  
        = 0,0001111 + 1，1101000
        = 1,1110111
 
那么 A-B = 啥呢? 反着换回去
1，1110111 
1，1110110  （末位减1再取反）
1，0001001 = -0001001 = -9&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 05 Nov 2019 14:34:00 +0000</pubDate>
<dc:creator>赐我白日梦</dc:creator>
<og:description>计算机的运算方法 无符号数 计算机中的数存放在寄存器中,通常将寄存器的位数称为机器字长, 大家说的无符号数其实就是不区分正负号的数,换句话说,就是没负数,全是正数,大家知道,计算机中的数是以0 1存储</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ZhuChangwu/p/11802225.html</dc:identifier>
</item>
<item>
<title>【Leetcode 做题学算法周刊】第二期 - McChen</title>
<link>http://www.cnblogs.com/McChen/p/11801946.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/McChen/p/11801946.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;首发于微信公众号《前端成长记》，写于 2019.11.05&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;
&lt;p&gt;本文记录刷题过程中的整个思考过程，以供参考。主要内容涵盖：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;题目分析设想&lt;/li&gt;
&lt;li&gt;编写代码验证&lt;/li&gt;
&lt;li&gt;查阅他人解法&lt;/li&gt;
&lt;li&gt;思考总结&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;目录&quot;&gt;目录&lt;/h2&gt;
&lt;h2 id=&quot;easy&quot;&gt;Easy&lt;/h2&gt;
&lt;h3 id=&quot;有效的括号&quot;&gt;20.有效的括号&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/valid-parentheses/&quot;&gt;题目地址&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;题目描述&quot;&gt;题目描述&lt;/h4&gt;
&lt;p&gt;给定一个只包括 &lt;code&gt;'('，')'，'{'，'}'，'['，']'&lt;/code&gt; 的字符串，判断字符串是否有效。&lt;/p&gt;
&lt;p&gt;有效字符串需满足：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;左括号必须用相同类型的右括号闭合。&lt;/li&gt;
&lt;li&gt;左括号必须以正确的顺序闭合。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;注意空字符串可被认为是有效字符串。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;输入: &quot;()&quot;
输出: true

输入: &quot;()[]{}&quot;
输出: true

输入: &quot;(]&quot;
输出: false

输入: &quot;([)]&quot;
输出: false

输入: &quot;{[]}&quot;
输出: true&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;题目分析设想&quot;&gt;题目分析设想&lt;/h4&gt;
&lt;p&gt;这道题从题面来看，仍然需要对字符串做遍历处理，找到相互匹配的括号，剔除后继续做处理即可。所以这道题我的解题想法是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用栈来记录，匹配的一对就出栈，最后判断栈是否为空&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;有几点需要注意下，可以减少一些计算量：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;题面说明了字符串只含有三种括号，所以长度为奇数，一定无效&lt;/li&gt;
&lt;li&gt;只要有一对不符合，则可判定一定无效&lt;/li&gt;
&lt;li&gt;堆栈长度超过字符串长度一半，则一定无效&lt;/li&gt;
&lt;li&gt;先找到右括号则一定无效&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;编写代码验证&quot;&gt;编写代码验证&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Ⅰ.记录栈&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;/**
 * @param {string} s
 * @return {boolean}
 */
var isValid = function(s) {
    if (s === '') return true;
    if (s.length % 2) return false;
    // hash 表做好索引
    const hash = {
        '(': ')',
        '[': ']',
        '{': '}'
    }
    let arr = []
    for (let i = 0; i &amp;lt; s.length; i++) {
        if (!hash[s.charAt(i)]) { // 推入的是右括号
            if (!arr.length || hash[arr[arr.length - 1]] !== s.charAt(i)) {
                return false
            } else {
                arr.pop()
            }
        } else {
            if (arr.length &amp;gt;= s / 2) {   // 长度超过一半
                return false
            }
            arr.push(s.charAt(i))
        }
    }
    return !arr.length
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;76/76 cases passed (64 ms)&lt;/li&gt;
&lt;li&gt;Your runtime beats 90.67 % of javascript submissions&lt;/li&gt;
&lt;li&gt;Your memory usage beats 64.59 % of javascript submissions (33.8 MB)&lt;/li&gt;
&lt;li&gt;时间复杂度： &lt;code&gt;O(n)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;查阅他人解法&quot;&gt;查阅他人解法&lt;/h4&gt;
&lt;p&gt;发现一个很暴力的解法，虽然效率不高，但是思路清奇。我们来看看实现：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Ⅰ.暴力正则&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;/**
 * @param {string} s
 * @return {boolean}
 */
var isValid = function(s) {
    if (s === '') return true;
    if (s.length % 2) return false;

    while(s.length) {
        const s_ = s
        s = s.replace('()','').replace('[]','').replace('{}','')
        if (s === s_) return false;
    }
    return true;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;76/76 cases passed (104 ms)&lt;/li&gt;
&lt;li&gt;Your runtime beats 14.95 % of javascript submissions&lt;/li&gt;
&lt;li&gt;Your memory usage beats 19.75 % of javascript submissions (35.7 MB)&lt;/li&gt;
&lt;li&gt;时间复杂度： &lt;code&gt;O(n)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;思考总结&quot;&gt;思考总结&lt;/h4&gt;
&lt;p&gt;就这题而言，我还是更倾向于增加一个辅助栈来做记录。因为一旦去掉只包含括号的限制，那么正则将无法解答。&lt;/p&gt;
&lt;h3 id=&quot;合并两个有序链表&quot;&gt;21.合并两个有序链表&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/merge-two-sorted-lists/&quot;&gt;题目地址&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;题目描述-1&quot;&gt;题目描述&lt;/h4&gt;
&lt;p&gt;将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;输入：1-&amp;gt;2-&amp;gt;4, 1-&amp;gt;3-&amp;gt;4
输出：1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;题目分析设想-1&quot;&gt;题目分析设想&lt;/h4&gt;
&lt;p&gt;这道题从题面上就说明了这是一道链表相关问题，要进行链表合并，无非是修改链表指针指向，或者是链表拼接。所以，这道题我有两种思路的解法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;修改指针，不断取出某一条链表中的数，插入到另外一条链表&lt;/li&gt;
&lt;li&gt;链表拼接，递归比较哪条链表的元素更小，就截取拼接到另一条&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;两种方式的区别很明显，修改指针的方式需要存储和不断修改指针指向，拼接的方式直接做链表拼接。&lt;/p&gt;
&lt;p&gt;当然这里也有一些特殊值需要考虑进来。&lt;/p&gt;
&lt;h4 id=&quot;编写代码验证-1&quot;&gt;编写代码验证&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Ⅰ.修改指针&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var mergeTwoLists = function(l1, l2) {
    if (l1 === null) return l2
    if (l2 === null) return l1
    // 结果链表
    let l = new ListNode(0)
    // 不断更新的当前结点指针，对象赋值为传址，所以下面改指针指向即可
    let cursor = l
    // 会有一个先遍历完，变成 null
    while(l1 !== null &amp;amp;&amp;amp; l2 !== null) {
        if (l1.val &amp;lt;= l2.val) { // 哪个小，指针就指向哪
            cursor.next = l1
            l1 = l1.next
        } else {
            cursor.next = l2
            l2 = l2.next
        }
        // 可以理解为 l.next.next.next ...
        cursor = cursor.next
    }
    // 有一个为空则可以直接拼接
    cursor.next = l1 === null ? l2 : l1
    return l.next
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;208/208 cases passed (60 ms)&lt;/li&gt;
&lt;li&gt;Your runtime beats 99.51 % of javascript submissions&lt;/li&gt;
&lt;li&gt;Your memory usage beats 51.04 % of javascript submissions (35.4 MB)&lt;/li&gt;
&lt;li&gt;时间复杂度 &lt;code&gt;O(m + n)&lt;/code&gt; ，分别代表两个链表长度&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Ⅱ.链表拼接&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var mergeTwoLists = function(l1, l2) {
    if (l1 === null) return l2
    if (l2 === null) return l1
    if (l1.val &amp;lt; l2.val) {
        l1.next = mergeTwoLists(l1.next, l2)
        return l1   // 这个是合并后的了
    } else {
        l2.next = mergeTwoLists(l1, l2.next)
        return l2   // 这个是合并后的了
    }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;208/208 cases passed (68 ms)&lt;/li&gt;
&lt;li&gt;Your runtime beats 96.41 % of javascript submissions&lt;/li&gt;
&lt;li&gt;Your memory usage beats 51.04 % of javascript submissions (35.4 MB)&lt;/li&gt;
&lt;li&gt;时间复杂度 &lt;code&gt;O(m + n)&lt;/code&gt; ，分别代表两个链表长度&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;查阅他人解法-1&quot;&gt;查阅他人解法&lt;/h4&gt;
&lt;p&gt;思路基本上都是这两种，未发现方向不同的解法。&lt;/p&gt;
&lt;p&gt;无非是有些解法额外开辟了新的链表来记录，或者一些细节上的差异。&lt;/p&gt;
&lt;h4 id=&quot;思考总结-1&quot;&gt;思考总结&lt;/h4&gt;
&lt;p&gt;这里的链表拼接解法，有没有发现跟 &lt;a href=&quot;https://github.com/ChenJiaH/blog/issues/44&quot;&gt;上一期&lt;/a&gt; 14题中的分治思路是一样的？对，实际上这个也是分治思路的一个应用。&lt;/p&gt;
&lt;h3 id=&quot;删除排序数组中的重复项&quot;&gt;26.删除排序数组中的重复项&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/&quot;&gt;题目地址&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;题目描述-2&quot;&gt;题目描述&lt;/h4&gt;
&lt;p&gt;给定一个排序数组，你需要在&lt;strong&gt;原地&lt;/strong&gt;删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。&lt;/p&gt;
&lt;p&gt;不要使用额外的数组空间，你必须在&lt;strong&gt;原地&lt;/strong&gt;修改输入数组并在使用 O(1) 额外空间的条件下完成。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;给定数组 nums = [1,1,2],

函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。

你不需要考虑数组中超出新长度后面的元素。

给定 nums = [0,0,1,1,1,2,2,3,3,4],

函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。

你不需要考虑数组中超出新长度后面的元素。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;说明:&lt;/p&gt;
&lt;p&gt;为什么返回数值是整数，但输出的答案是数组呢?&lt;/p&gt;
&lt;p&gt;请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。&lt;/p&gt;
&lt;p&gt;你可以想象内部操作如下:&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
int len = removeDuplicates(nums);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。
for (int i = 0; i &amp;lt; len; i++) {
    print(nums[i]);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;题目分析设想-2&quot;&gt;题目分析设想&lt;/h4&gt;
&lt;p&gt;如果是单纯的数组去重，那有很多种方法可以做。所以题目也加了限制条件，总结一下比较重要的几点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;不要使用额外的数组空间，空间复杂度为 &lt;code&gt;O(1)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;原地删除重复元素&lt;/li&gt;
&lt;li&gt;不需要考虑超过新长度后面的元素&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这意味着不允许使用新的数组来解题，也就是对原数组进行操作。最后一点注意点可以看出，数组项的拷贝复制是一个方向，第二点可以看出数组删除是一个方向。删除元素的话就不会超过，所以不需要考虑两者结合。所以这题我分两个方向来解：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;拷贝数组元素&lt;/li&gt;
&lt;li&gt;删除数组元素&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;编写代码验证-2&quot;&gt;编写代码验证&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Ⅰ.拷贝数组元素&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;/**
 * @param {number[]} nums
 * @return {number}
 */
var removeDuplicates = function(nums) {
    if (nums.length === 0) return 0;
    var len = 1
    for(let i = 1; i &amp;lt; nums.length; i++) {
        if(nums[i] !== nums[i - 1]) { // 后一项不等于前一项
            nums[len++] = nums[i] // 拷贝数组元素
        }
    }
    return len
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;161/161 cases passed (68 ms)&lt;/li&gt;
&lt;li&gt;Your runtime beats 99.81 % of javascript submissions&lt;/li&gt;
&lt;li&gt;Your memory usage beats 77.54 % of javascript submissions (36.6 MB)&lt;/li&gt;
&lt;li&gt;时间复杂度 &lt;code&gt;O(n)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Ⅱ.删除数组元素&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;/**
 * @param {number[]} nums
 * @return {number}
 */
var removeDuplicates = function(nums) {
    if (nums.length === 0) return 0;
    for(let i = 1; i &amp;lt; nums.length;) {
        if(nums[i] === nums[i - 1]) { // 后一项等于前一项
            nums.splice(i, 1)
        } else {
            i++
        }
    }
    return nums.length
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;161/161 cases passed (96 ms)&lt;/li&gt;
&lt;li&gt;Your runtime beats 75.93 % of javascript submissions&lt;/li&gt;
&lt;li&gt;Your memory usage beats 30.85 % of javascript submissions (37.3 MB)&lt;/li&gt;
&lt;li&gt;时间复杂度 &lt;code&gt;O(n)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;查阅他人解法-2&quot;&gt;查阅他人解法&lt;/h4&gt;
&lt;p&gt;这里看见一种很巧妙的解法，双指针法。相当于一个用于计数，一个用于扫描。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Ⅰ.双指针法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;/**
 * @param {number[]} nums
 * @return {number}
 */
var removeDuplicates = function(nums) {
    if (nums.length === 0) return 0;

    let i = 0;
    for(let j = 1; j &amp;lt; nums.length; j++) {
        if (nums[j] !== nums[i]) {
            nums[++i] = nums[j]
        }
    }
    return i + 1  // 下标 +1 为数组长度
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;161/161 cases passed (68 ms)&lt;/li&gt;
&lt;li&gt;Your runtime beats 99.81 % of javascript submissions&lt;/li&gt;
&lt;li&gt;Your memory usage beats 84.03 % of javascript submissions (36.5 MB)&lt;/li&gt;
&lt;li&gt;时间复杂度 &lt;code&gt;O(n)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;思考总结-2&quot;&gt;思考总结&lt;/h4&gt;
&lt;p&gt;就三种解法而言，删除数组元素会频繁修改数组，不建议使用。双指针法和拷贝数组元素代码逻辑相似，但是思路上是截然不同的。&lt;/p&gt;
&lt;h3 id=&quot;移除元素&quot;&gt;27.移除元素&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/remove-element/&quot;&gt;题目地址&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;题目描述-3&quot;&gt;题目描述&lt;/h4&gt;
&lt;p&gt;给定一个数组 &lt;code&gt;nums&lt;/code&gt; 和一个值 &lt;code&gt;val&lt;/code&gt;，你需要&lt;strong&gt;原地&lt;/strong&gt;移除所有数值等于 &lt;code&gt;val&lt;/code&gt; 的元素，返回移除后数组的新长度。&lt;/p&gt;
&lt;p&gt;不要使用额外的数组空间，你必须在&lt;strong&gt;原地&lt;/strong&gt;修改输入数组并在使用 &lt;code&gt;O(1)&lt;/code&gt; 额外空间的条件下完成。&lt;/p&gt;
&lt;p&gt;元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;给定 nums = [3,2,2,3], val = 3,

函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。

你不需要考虑数组中超出新长度后面的元素。

给定 nums = [0,1,2,2,3,0,4,2], val = 2,

函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。

注意这五个元素可为任意顺序。

你不需要考虑数组中超出新长度后面的元素。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;说明:&lt;/p&gt;
&lt;p&gt;为什么返回数值是整数，但输出的答案是数组呢?&lt;/p&gt;
&lt;p&gt;请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。&lt;/p&gt;
&lt;p&gt;你可以想象内部操作如下:&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝
int len = removeElement(nums, val);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。
for (int i = 0; i &amp;lt; len; i++) {
    print(nums[i]);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;题目分析设想-3&quot;&gt;题目分析设想&lt;/h4&gt;
&lt;p&gt;这题跟上一题非常相似，所以我们可以沿用上题的方向来解这道题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;删除数组元素&lt;/li&gt;
&lt;li&gt;双指针法&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;编写代码验证-3&quot;&gt;编写代码验证&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Ⅰ.删除数组元素&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;/**
 * @param {number[]} nums
 * @param {number} val
 * @return {number}
 */
var removeElement = function(nums, val) {
    if (nums.length === 0) return 0;

    for(let i = 0; i &amp;lt; nums.length;) {
        if (nums[i] === val) {
            nums.splice(i, 1)
        } else {
            i++
        }
    }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;113/113 cases passed (64 ms)&lt;/li&gt;
&lt;li&gt;Your runtime beats 89.43 % of javascript submissions&lt;/li&gt;
&lt;li&gt;Your memory usage beats 47.42 % of javascript submissions (33.7 MB)&lt;/li&gt;
&lt;li&gt;时间复杂度 &lt;code&gt;O(n)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Ⅱ.双指针法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;/**
 * @param {number[]} nums
 * @param {number} val
 * @return {number}
 */
var removeElement = function(nums, val) {
    if (nums.length === 0) return 0;

    let i = 0
    for(let j = 0; j &amp;lt; nums.length; j++) {
        if (nums[j] !== val) {
            nums[i++] = nums[j]
        }
    }
    return i
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;113/113 cases passed (60 ms)&lt;/li&gt;
&lt;li&gt;Your runtime beats 95.11 % of javascript submissions&lt;/li&gt;
&lt;li&gt;Your memory usage beats 98.18 % of javascript submissions (33.3 MB)&lt;/li&gt;
&lt;li&gt;时间复杂度 &lt;code&gt;O(n)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;查阅他人解法-3&quot;&gt;查阅他人解法&lt;/h4&gt;
&lt;p&gt;看到两个略有差异的方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;单指针法，使用 &lt;code&gt;const of&lt;/code&gt; 替换一次遍历，只是写法区别，没有本质提升&lt;/li&gt;
&lt;li&gt;交换移除，相同时候与最后一项交换，同时数组长度减1&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Ⅰ.单指针法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;/**
 * @param {number[]} nums
 * @param {number} val
 * @return {number}
 */
var removeElement = function(nums, val) {
    if (nums.length === 0) return 0;

    let i = 0;
    for(const num of nums) {
        if(num !== val) {
            nums[i++] = num;
        }
    }
    return i;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;113/113 cases passed (68 ms)&lt;/li&gt;
&lt;li&gt;Your runtime beats 80.29 % of javascript submissions&lt;/li&gt;
&lt;li&gt;Your memory usage beats 43.35 % of javascript submissions (33.7 MB)&lt;/li&gt;
&lt;li&gt;时间复杂度 &lt;code&gt;O(n)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Ⅱ.交换移除&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;/**
 * @param {number[]} nums
 * @param {number} val
 * @return {number}
 */
var removeElement = function(nums, val) {
    if (nums.length === 0) return 0;

    let i = nums.length;
    for(let j = 0; j &amp;lt; i;) {
        if (nums[j] === val) {
            nums[j] = nums[--i]
        } else {
            j++
        }
    }

    return i;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;113/113 cases passed (68 ms)&lt;/li&gt;
&lt;li&gt;Your runtime beats 80.29 % of javascript submissions&lt;/li&gt;
&lt;li&gt;Your memory usage beats 44.53 % of javascript submissions (33.7 MB)&lt;/li&gt;
&lt;li&gt;时间复杂度 &lt;code&gt;O(n)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;思考总结-3&quot;&gt;思考总结&lt;/h4&gt;
&lt;p&gt;这里开拓下思路：如果要移除的是多项，那么还是使用指针法做处理合适；如果是移除单项，那么使用交互移除法其实遍历次数最少。&lt;/p&gt;
&lt;h3 id=&quot;实现strstr&quot;&gt;28.实现strStr&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/implement-strstr/&quot;&gt;题目地址&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;题目描述-4&quot;&gt;题目描述&lt;/h4&gt;
&lt;p&gt;实现 &lt;code&gt;strStr()&lt;/code&gt; 函数。&lt;/p&gt;
&lt;p&gt;给定一个 &lt;code&gt;haystack&lt;/code&gt; 字符串和一个 &lt;code&gt;needle&lt;/code&gt; 字符串，在 &lt;code&gt;haystack&lt;/code&gt; 字符串中找出 &lt;code&gt;needle&lt;/code&gt; 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 &lt;code&gt;-1&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;输入: haystack = &quot;hello&quot;, needle = &quot;ll&quot;
输出: 2

输入: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;
输出: -1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;说明:&lt;/p&gt;
&lt;p&gt;当 &lt;code&gt;needle&lt;/code&gt; 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。&lt;/p&gt;
&lt;p&gt;对于本题而言，当 &lt;code&gt;needle&lt;/code&gt; 是空字符串时我们应当返回 &lt;code&gt;0&lt;/code&gt; 。这与 &lt;code&gt;C&lt;/code&gt; 语言的 &lt;code&gt;strstr()&lt;/code&gt; 以及 &lt;code&gt;Java&lt;/code&gt; 的 &lt;code&gt;indexOf()&lt;/code&gt; 定义相符。&lt;/p&gt;
&lt;h4 id=&quot;题目分析设想-4&quot;&gt;题目分析设想&lt;/h4&gt;
&lt;p&gt;这道题很明显是一道字符串搜索的题目，估计是在考察算法，但是受限知识面，所以我就先以现有方式实现作答，再来学习算法了。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;IndexOf&lt;/code&gt; 这个是原生方法，考察这个就没有意义了，所以不做详细论述&lt;/li&gt;
&lt;li&gt;遍历匹配，相当于自己实现一个 &lt;code&gt;IndexOf&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;编写代码验证-4&quot;&gt;编写代码验证&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Ⅰ.遍历匹配&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;/**
 * @param {string} haystack
 * @param {string} needle
 * @return {number}
 */
var strStr = function(haystack, needle) {
    if (needle === '') return 0
    if (needle.length &amp;gt; haystack.length) return -1
    if (needle.length === haystack.length &amp;amp;&amp;amp; needle !== haystack) return -1
    for(let i = 0; i &amp;lt; haystack.length; i++) {
        if (i + needle.length &amp;gt; haystack.length) {
            return -1
        } else {
            const str = haystack.substr(i, needle.length)
            if (str === needle) {
                return i
            }
        }
    }
    return -1
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;74/74 cases passed (64 ms)&lt;/li&gt;
&lt;li&gt;Your runtime beats 90.58 % of javascript submissions&lt;/li&gt;
&lt;li&gt;Your memory usage beats 44.22 % of javascript submissions (33.9 MB)&lt;/li&gt;
&lt;li&gt;时间复杂度 &lt;code&gt;O(n)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;查阅他人解法-4&quot;&gt;查阅他人解法&lt;/h4&gt;
&lt;p&gt;首先查阅《算法导论》，看到字符串匹配有以下四种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;朴素字符串匹配算法&lt;/li&gt;
&lt;li&gt;Rabin-Karp 算法&lt;/li&gt;
&lt;li&gt;利用有限自动机进行字符串匹配&lt;/li&gt;
&lt;li&gt;KMP 算法&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;然后再看题解，大概还找到以下三种算法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;BM 算法&lt;/li&gt;
&lt;li&gt;Horspool 算法&lt;/li&gt;
&lt;li&gt;Sunday 算法&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Ⅰ.朴素字符串匹配算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;算法说明：&lt;/p&gt;
&lt;p&gt;通过一个循环找到所有有效便宜，该循环对 &lt;code&gt;n-m+1&lt;/code&gt; 个可能的 &lt;code&gt;s&lt;/code&gt; 值进行检测，看能否满足条件 &lt;code&gt;P[1..m] = T[s+1...s+m]&lt;/code&gt;。其中 &lt;code&gt;n&lt;/code&gt; 是字符串长度， 'm' 是匹配字符串长度。&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;/**
 * @param {string} haystack
 * @param {string} needle
 * @return {number}
 */
var strStr = function(haystack, needle) {
    if (needle === '') return 0
    if (needle.length &amp;gt; haystack.length) return -1
    if (needle.length === haystack.length &amp;amp;&amp;amp; needle !== haystack) return -1

    let i = 0;
    let j = 0;
    while(j &amp;lt; needle.length &amp;amp;&amp;amp; i &amp;lt; haystack.length) {
        if(haystack[i] === needle[j]) { // 同位相等，继续判断下一位
            i++;
            j++;
        } else {
            i = i - j + 1; // i 偏移
            j = 0; // j 重置

            if (i + needle.length &amp;gt; haystack.length) { // 我增加的优化点，减少一些运算
                return -1
            }
        }
    }
    if (j &amp;gt;= needle.length) { // 子串比完了，此时 j 应该等于 needle.length
        return i - needle.length;
    } else {
        return -1
    }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;74/74 cases passed (56 ms)&lt;/li&gt;
&lt;li&gt;Your runtime beats 98.45 % of javascript submissions&lt;/li&gt;
&lt;li&gt;Your memory usage beats 30.12 % of javascript submissions (34.8 MB)&lt;/li&gt;
&lt;li&gt;时间复杂度 &lt;code&gt;O(m*n)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Ⅱ.Rabin-Karp 算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;算法说明：&lt;/p&gt;
&lt;p&gt;进行哈希运算，将字符串转成对应的哈希值进行比对，类似16进制。这里题目是字符串，我就用 &lt;code&gt;ASCII&lt;/code&gt; 值来表示每个字符的哈希值，那么就可以计算出模式串的哈希值，再进行滚动比较。&lt;/p&gt;
&lt;p&gt;每次滚动只需要做固定的 &lt;code&gt;-*+&lt;/code&gt; 三个操作，即可得出滚动串的哈希值了。&lt;/p&gt;
&lt;p&gt;比如计算 &lt;code&gt;bbc&lt;/code&gt; ,哈希值为 &lt;code&gt;hash = (b.charCodeAt() * 128 ^ 2 + b.charCodeAt() * 128 + c.charCodeAt())&lt;/code&gt;，如果要计算后新值 &lt;code&gt;bca&lt;/code&gt; 则为 &lt;code&gt;(hash - b.charCodeAt() * 128 ^ 2) * 128 + c.charCodeAt()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;/**
 * @param {string} haystack
 * @param {string} needle
 * @return {number}
 */
var strStr = function(haystack, needle) {
    if (needle === '') return 0
    if (needle.length &amp;gt; haystack.length) return -1
    if (needle.length === haystack.length &amp;amp;&amp;amp; needle !== haystack) return -1

    let searchHash = 0 // 搜索字符串的hash值
    let startHash = 0 // 字符串起始的hash值

    for(let i = 0; i &amp;lt; needle.length; i++) {
        searchHash += needle.charCodeAt(i) * Math.pow(2, needle.length - i - 1)
        startHash += haystack.charCodeAt(i) * Math.pow(2, needle.length - i - 1)
    }

    if (startHash === searchHash)  return 0

    for(let j = 1; j &amp;lt; haystack.length - needle.length + 1; j++) {
        startHash = (startHash - haystack.charCodeAt(j - 1) * Math.pow(2, needle.length - 1)) * 2 + haystack.charCodeAt(j + needle.length - 1)
        if (startHash === searchHash) {
            return j
        }
    }
    return -1
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;74/74 cases passed (68 ms)&lt;/li&gt;
&lt;li&gt;Your runtime beats 81.31 % of javascript submissions&lt;/li&gt;
&lt;li&gt;Your memory usage beats 16.86 % of javascript submissions (35.4 MB)&lt;/li&gt;
&lt;li&gt;时间复杂度 &lt;code&gt;O(m*n)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注意：这里可能会存在溢出的情况，所以不是所有情况都适用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Ⅲ.利用有限自动机进行字符串匹配&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;算法说明：&lt;/p&gt;
&lt;p&gt;通过对文本字符串 &lt;code&gt;T&lt;/code&gt; 进行扫描，找出模式 &lt;code&gt;P&lt;/code&gt; 的所有出现位置。它们只对每个文本字符检查一次，并且检查每个文本字符时所用的时间为常数。一句话概括：字符输入引起状态机状态变更，通过状态转换图得到预期结果。&lt;/p&gt;
&lt;p&gt;这里主要的核心点是判断每次输入，找到最长的后缀匹配，如果最长时的长度等于查找字符串长度，那就一定包含该查找字符串。&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;/**
 * @param {string} haystack
 * @param {string} needle
 * @return {number}
 */
var strStr = function(haystack, needle) {
    if (needle === '') return 0
    if (needle.length &amp;gt; haystack.length) return -1
    if (needle.length === haystack.length &amp;amp;&amp;amp; needle !== haystack) return -1

    // 查找最大匹配后缀长度
    function findSuffix (Pq) {
        let suffixLen = 0
        let k = 0
        while(k &amp;lt; Pq.length &amp;amp;&amp;amp; k &amp;lt; needle.length) {
            let i = 0;
            for(i = 0; i &amp;lt;= k; i++) {
                // 找needle中的多少项为当前状态对应字符串的匹配项
                if (Pq.charAt(Pq.length - 1 - k + i) !== needle.charAt(i)) {
                    break;
                }
            }

            // 所有项都匹配，即找到了后缀
            if (i - 1 == k) {
                suffixLen = k+1;
             }
            k++
        }
        return suffixLen
    }

    // 获取所有输入的字符集，比如 'abbc' 和 'cd' 合集为 ['a','b','c','d']
    const setArr = Array.from(new Set(haystack + needle)) // 用户输入的可选项

    // 建立状态机
    const hash = {}
    for(let q = 0; q &amp;lt; haystack.length; q++) {
        for(let k = 0; k &amp;lt; setArr.length; k++) {
            const char = haystack.substring(0, q) + setArr[k] // 下个状态的字符
            const nextState = findSuffix(char)
            // 求例如 0.a 0.b 0.c 的值
            if (!hash[q]) {
                hash[q] = {}
            }
            hash[q][char] = nextState
        }
    }

    // 根据状态机求解
    let matchStr = ''
    for(let n = 0; n &amp;lt; haystack.length; n++) {
        const map = hash[n]
        matchStr += haystack[n]
        const nextState = map[matchStr]

        if (nextState === needle.length) {
            return n - nextState + 1
        }
    }
    return -1
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;74/74 cases passed (84 ms)&lt;/li&gt;
&lt;li&gt;Your runtime beats 35.05 % of javascript submissions&lt;/li&gt;
&lt;li&gt;Your memory usage beats 5.05 % of javascript submissions (39.8 MB)&lt;/li&gt;
&lt;li&gt;时间复杂度 &lt;code&gt;O(n)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Ⅳ.KMP 算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;算法说明：&lt;/p&gt;
&lt;p&gt;可以理解为在状态机的基础上，使用了一个前缀函数来进行状态判断。本质上也是前缀后缀的思想。&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// @lc code=start
/**
 * @param {string} haystack
 * @param {string} needle
 * @return {number}
 */
var strStr = function(haystack, needle) {
    if (needle === '') return 0
    if (needle.length &amp;gt; haystack.length) return -1
    if (needle.length === haystack.length &amp;amp;&amp;amp; needle !== haystack) return -1

    // 生成匹配串各个位置下下的最长公共前后缀长度哈希表
    function getHash () {
        let i = 0 // arr[i] 表示 i 前面的字符串的最长公共前后缀长度
        let j = 1
        let hash = {
            0: 0
        }
        while (j &amp;lt; needle.length) {
            if (needle.charAt(i) === needle.charAt(j)) { // 相等直接 i j 都后移
                hash[j++] = ++i
            } else if (i === 0) {   // i 为起点且两者不相等，那么一定为0
                hash[j] = 0
                j++
            } else {
                // 这里解释一下： 因为i前面的字符串与j前面的字符串拥有相同的最长公共前后缀，也就是说i前面字符串的最长公共后缀与j前面字符串的最长公共前缀相同，所以i只需回到i前面字符串最长公共前缀的后一位开始比较
                i = hash[i - 1]
            }
        }
        return hash
    }

    const hash = getHash()
    let i = 0 // 母串中的位置
    let j = 0 // 子串中的位置
    while(i &amp;lt; haystack.length &amp;amp;&amp;amp; j &amp;lt; needle.length) {
        if (haystack.charAt(i) === needle.charAt(j)) {  // 两个匹配，同时后移
            i++
            j++
        } else if (j === 0) { // 两个不匹配，并且j在起点，则母串后移
            i++
        } else {
            j = hash[j - 1]
        }
    }
    if (j === needle.length) {  // 循环完了，说明匹配到了
        return i - j
    } else {
        return -1
    }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;74/74 cases passed (60 ms)&lt;/li&gt;
&lt;li&gt;Your runtime beats 94.74 % of javascript submissions&lt;/li&gt;
&lt;li&gt;Your memory usage beats 23.73 % of javascript submissions (35.1 MB)&lt;/li&gt;
&lt;li&gt;时间复杂度 &lt;code&gt;O(n)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Ⅴ.BM 算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;算法说明：&lt;/p&gt;
&lt;p&gt;基于后缀匹配，匹配从后开始，但移动还是从前开始，只是定义了两个规则：坏字符规则和好后缀规则。&lt;/p&gt;
&lt;p&gt;通俗来讲就是先验证是否为坏字符，然后判断是否在搜索词中进行对应的偏移进行下一步验证。如果匹配的话就从后往前校验，如果仍然匹配，就为好后缀。核心思想是每次位移都在坏字符和好后缀规则中取较大值，由于两个规则都只与匹配项相关，所以可以提前生成规则表。&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;/**
 * @param {string} haystack
 * @param {string} needle
 * @return {number}
 */
var strStr = function(haystack, needle) {
    if (needle === '') return 0
    if (needle.length &amp;gt; haystack.length) return -1
    if (needle.length === haystack.length &amp;amp;&amp;amp; needle !== haystack) return -1

    function makeBadChar (needle) {
        let hash = {}
        for(let i = 0; i &amp;lt; 256; i++) { // ascii 字符长度
            hash[String.fromCharCode(i)] = -1 // 初始化为-1
        }
        for(let i = 0; i &amp;lt; needle.length; i++) {
            hash[needle.charAt(i)] = i  // 最后出现该字符的位置
        }
        return hash
    }

    function makeGoodSuffix (needle) {
        let hashSuffix = {}
        let hashPrefix = {}
        for(let i = 0; i &amp;lt; needle.length; i++) {
            hashSuffix[i] = -1
            hashPrefix[i] = false
        }
        for(let i = 0; i &amp;lt; needle.length - 1; i++) { // needle[0, i]
            let j = i
            k = 0 // 公共后缀子串长度，尾部取k个出来进行比较
            while(j &amp;gt;= 0 &amp;amp;&amp;amp; needle.charAt(j) === needle.charAt(needle.length - 1 - k)) { // needle[0,needle.length - 1]
                --j
                ++k
                hashSuffix[k] = j + 1 // 起始下标
            }

            if (j === -1) { // 说明全部匹配，意味着此时公共后缀子串也是模式的前缀子串
                hashPrefix[k] = true
            }
        }
        return { hashSuffix, hashPrefix }
    }

    function moveGoodSuffix (j, needle) {
        let k = needle.length - 1 - j
        let suffixes = makeGoodSuffix(needle).hashSuffix
        let prefixes = makeGoodSuffix(needle).hashPrefix
        if (suffixes[k] !== -1) { // 找到了跟好后缀一样的子串，获取下标
            return j - suffixes[k] + 1
        }
        for(let r = j + 2; r &amp;lt; needle.length; ++r) {
            if (prefixes[needle.length - r]) { // needle.length 是好后缀子串长度
                return r // 对齐前缀到好后缀
            }
        }
        return needle.length // 全部匹配，直接移动字符串长度
    }

    let badchar = makeBadChar(needle)
    let i = 0;
    while(i &amp;lt; haystack.length - needle.length + 1) {
        let j
        for(j = needle.length - 1; j &amp;gt;= 0; --j) {
            if (haystack.charAt(i + j) != needle[j]) {
                break; // 坏字符，下标为j
            }
        }
        if (j &amp;lt; 0) { // 匹配成功
            return i // 第一个匹配字符的位置
        }
        let moveLen1 = j - badchar[haystack.charAt(i + j)]
        let moveLen2 = 0
        if (j &amp;lt; needle.length -1) { // 如果有好后缀
            moveLen2 = moveGoodSuffix(j, needle)
        }
        i = i + Math.max(moveLen1, moveLen2)
    }

    return -1
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;74/74 cases passed (72 ms)&lt;/li&gt;
&lt;li&gt;Your runtime beats 69.29 % of javascript submissions&lt;/li&gt;
&lt;li&gt;Your memory usage beats 5.05 % of javascript submissions (37 MB)&lt;/li&gt;
&lt;li&gt;时间复杂度 &lt;code&gt;O(n)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Ⅵ.Horspool 算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;算法说明：&lt;/p&gt;
&lt;p&gt;将主串中匹配窗口的最后一个字符跟模式串中的最后一个字符比较。如果相等，继续从后向前对主串和模式串进行比较，直到完全相等或者在某个字符处不匹配为止。如果不匹配，则根据主串匹配窗口中的最后一个字符在模式串中的下一个出现位置将窗口向右移动。&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;/**
 * @param {string} haystack
 * @param {string} needle
 * @return {number}
 */
var strStr = function(haystack, needle) {
    if (needle === '') return 0
    if (needle.length &amp;gt; haystack.length) return -1
    if (needle.length === haystack.length &amp;amp;&amp;amp; needle !== haystack) return -1

    let hash = {}
    for(let i = 0; i &amp;lt; 256; i++) {
        hash[i] = needle.length // 默认初始化为最大偏移量，也就是匹配串长度
    }
    for(let i = 0; i &amp;lt; needle.length - 1; i++) {
        hash[needle.charCodeAt(i)] = needle.length - 1 - i // 每个字符距离右侧的距离
    }

    let pos = 0

    while(pos &amp;lt; (haystack.length - needle.length + 1)) {
        let j = needle.length - 1 // 从右往左
        while(j &amp;gt;= 0 &amp;amp;&amp;amp; haystack.charAt(pos + j) === needle.charAt(j)) {
            j--
        }
        if (j &amp;lt; 0) { // 全部匹配
            return pos
        } else { // 不匹配
            pos += hash[haystack.charCodeAt(pos + needle.length - 1)]
        }
    }

    return -1
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;74/74 cases passed (68 ms)&lt;/li&gt;
&lt;li&gt;Your runtime beats 79.76 % of javascript submissions&lt;/li&gt;
&lt;li&gt;Your memory usage beats 16.14 % of javascript submissions (35.4 MB)&lt;/li&gt;
&lt;li&gt;时间复杂度 &lt;code&gt;O(n)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Ⅶ.Sunday 算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;算法说明：&lt;/p&gt;
&lt;p&gt;它的思想跟 &lt;code&gt;BM 算法&lt;/code&gt; 相似，但是它是从前往后匹配，匹配失败时关注主串内参与匹配的后一位字符。如果该字符不存在匹配字符中，则多偏移一位；如果存在，则偏移匹配串长度减该字符最右出现的位置。&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;74/74 cases passed (56 ms)&lt;/li&gt;
&lt;li&gt;Your runtime beats 98.3 % of javascript submissions&lt;/li&gt;
&lt;li&gt;Your memory usage beats 74.1 % of javascript submissions (33.6 MB)&lt;/li&gt;
&lt;li&gt;时间复杂度 &lt;code&gt;O(n)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;思考总结-4&quot;&gt;思考总结&lt;/h4&gt;
&lt;p&gt;就理解的难易度来讲，我建议先看 &lt;code&gt;Sunday 算法&lt;/code&gt; 和 &lt;code&gt;Horspool 算法&lt;/code&gt;，不过 &lt;code&gt;RMP 算法&lt;/code&gt; 的匹配思路打开了眼界，利用后缀前缀来处理问题。这里把常见的字符串算法都做了一次尝试，整体下来收获颇丰。&lt;/p&gt;
&lt;p&gt;（完）&lt;/p&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;本文为原创文章，可能会更新知识点及修正错误，因此转载请保留原出处，方便溯源，避免陈旧错误知识的误导，同时有更好的阅读体验&lt;br/&gt;如果能给您带去些许帮助，欢迎 ⭐️&lt;strong&gt;star&lt;/strong&gt; 或 ✏️ &lt;strong&gt;fork&lt;/strong&gt;&lt;br/&gt;(转载请注明出处：https://chenjiahao.xyz)&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 05 Nov 2019 13:51:00 +0000</pubDate>
<dc:creator>McChen</dc:creator>
<og:description>首发于微信公众号《前端成长记》，写于 2019.11.05 背景 本文记录刷题过程中的整个思考过程，以供参考。主要内容涵盖： 题目分析设想 编写代码验证 查阅他人解法 思考总结 目录 '20.有效的括</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/McChen/p/11801946.html</dc:identifier>
</item>
</channel>
</rss>