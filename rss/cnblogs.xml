<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>TypeScript 中非代码模块的导入 - 刘哇勇</title>
<link>http://www.cnblogs.com/Wayou/p/import_files_in_typescript.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Wayou/p/import_files_in_typescript.html</guid>
<description>&lt;p&gt;需要理解的是，TypeScript 作为语言，他只处理代码模块。其他类型的文件这种非代码模块的导入，讲道理是通过另外的打包工具来完成的，比如 Web 应用中的图片，样式，JSON 还有 HTML 模板文件。只是我们需要在 TypeScript 层面解决模块解析报错的问题。&lt;/p&gt;
&lt;h2&gt;通配符模块声明&lt;/h2&gt;
&lt;p&gt;直接导入非代码模块，TypeScript 会报错。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-ts&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;/**&lt;/span&gt; 🚨 Cannot find module './index.html'. &lt;span class=&quot;pl-c&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;html&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;./index.html&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;TypeScript 文档中关于这部分的描述是 &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/modules.html&quot; rel=&quot;nofollow&quot;&gt;Wildcard module declarations&lt;/a&gt;，即通过定义通配符模块。与 &lt;a href=&quot;https://github.com/systemjs/systemjs/blob/master/docs/overview.md#plugin-syntax&quot;&gt;SystemJS&lt;/a&gt; 和 &lt;a href=&quot;https://github.com/amdjs/amdjs-api/blob/master/LoaderPlugins.md&quot;&gt;AMD&lt;/a&gt; 一致，在导入时路径上加上定义好的文件类型前后缀，这些路径上的额外信息在编译后可通过运行时实际的加载器中相应的插件来解析处理。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;typings.d.ts&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-ts&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;declare&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;*!text&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; {
    &lt;span class=&quot;pl-k&quot;&gt;&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt;&lt;/span&gt; content&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;string&lt;/span&gt;;
    &lt;span class=&quot;pl-k&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;content&lt;/span&gt;;
}
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; Some do it the other way around.&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;declare&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;json!*&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; {
    &lt;span class=&quot;pl-k&quot;&gt;&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt;&lt;/span&gt; value&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;any&lt;/span&gt;;
    &lt;span class=&quot;pl-k&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;value&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;main.ts&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-ts&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;fileContent&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;./xyz.txt!text&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;;
&lt;span class=&quot;pl-k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;json!http://example.com/data.json&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;;
&lt;span class=&quot;pl-c1&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;data&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;fileContent&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用定义类型前后缀的方式是可以解决代码中 TypeScript 报错的问题，但编译后因为模块地址中的类型前缀或后缀（&lt;code&gt;!text&lt;/code&gt;,&lt;code&gt;json!&lt;/code&gt;）没有去掉，这就需要对 &lt;code&gt;require&lt;/code&gt; 定义相应的插件来处理。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
$ node main.js
internal/modules/cjs/loader.js:670
    throw err&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt;
    ^

Error: Cannot find module &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;./xyz.txt!text&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果你看过 &lt;a href=&quot;https://github.com/Microsoft/vscode/blob/master/src/vs/editor/browser/viewParts/selections/selections.ts#L6&quot;&gt;VSCode 的源码&lt;/a&gt;，会发现里面大量使用了有类似这样的方式导入样式文件：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-ts&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;vs/css!./selections&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里 &lt;code&gt;vs/css!&lt;/code&gt; 便是上面提到的方式，但 VSCode 是使用了&lt;a href=&quot;https://github.com/Microsoft/vscode/blob/master/src/vs/loader.js#L1491&quot;&gt;自定义&lt;/a&gt;的一个模块加载器 &lt;a href=&quot;https://github.com/Microsoft/vscode-loader&quot;&gt;Microsoft/vscode-loader&lt;/a&gt; 来处理。&lt;/p&gt;
&lt;p&gt;还可以像下面这样来进行文件类型的声明：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;typings.d.ts&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-ts&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;declare&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;*.html&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; {
  &lt;span class=&quot;pl-k&quot;&gt;&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt;&lt;/span&gt; value&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;string&lt;/span&gt;;
  &lt;span class=&quot;pl-k&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;value&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后写正常的路径来导入即可，编译后的产出中路径没有改变。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-ts&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;/**&lt;/span&gt; ✅ ojbk &lt;span class=&quot;pl-c&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;html&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;./index.html&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于其他类型的后缀同理。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;typings.d.ts&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-ts&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;declare&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;*.png&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; {
  &lt;span class=&quot;pl-k&quot;&gt;&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt;&lt;/span&gt; value&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;string&lt;/span&gt;;
  &lt;span class=&quot;pl-k&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;value&lt;/span&gt;;
}

&lt;span class=&quot;pl-k&quot;&gt;declare&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;*.scss&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt; {
  &lt;span class=&quot;pl-k&quot;&gt;&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt;&lt;/span&gt; content&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;any&lt;/span&gt;;
  &lt;span class=&quot;pl-k&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;content&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;需要注意的是，这只是解决了 TypeScript 的模块解析报错的问题，实际文件的导入并不是在 TypeScript 中做的，而需要额外的打包工具。Webpack 中则是相应的样式 loader 和 图片 loader 来负责这些文件的解析加载。&lt;/p&gt;
&lt;h2&gt;JSON 文件的导入&lt;/h2&gt;
&lt;p&gt;因为 JSON 格式太过常见，TypeScript 确实在自己的编译器中提供了对其加载的支持，通过相应的编译参数 &lt;code&gt;--resolveJsonModul&lt;/code&gt; 来开启。&lt;/p&gt;
&lt;p&gt;创建 &lt;code&gt;tsconfig.json&lt;/code&gt; 开启对 JSON 文件导入的支持。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;tsconfig.json&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-json&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
{
  &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;compilerOptions&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;: {
    &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;target&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;: &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;es5&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;,
    &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;module&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;: &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;commonjs&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;,
    &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;resolveJsonModule&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;: &lt;span class=&quot;pl-c1&quot;&gt;true&lt;/span&gt;
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后代码中导入 JSON 文件时指定正确的路径，像其他正常的 TypeScript 模块一样。无须前缀，也无须编写额外的声明文件。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;main.ts&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-ts&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;./bar.json&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;;
&lt;span class=&quot;pl-c1&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;data&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当尝试编译上面代码时，你会得到如下的报错：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
$ tsc
error TS5055: Cannot write file &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;/Users/wayou/Documents/dev/github/ts-wildcard-module/bar.json&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt; because it would overwrite input file.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为编译后 JSON 文件也会有一份同名的产出，在没有指定编译输出目录的情况下， tsc 默认输出到当前目录，所以会有上面 JSON 文件会被覆盖的提示。所以解决办法就是添加输出目录的配置。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;tsconfig.json&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-diff&quot; readability=&quot;11&quot;&gt;
&lt;pre&gt;
{
  &quot;compilerOptions&quot;: {
    &quot;target&quot;: &quot;es5&quot;,
    &quot;module&quot;: &quot;commonjs&quot;,
    &quot;resolveJsonModule&quot;: true,
&lt;span class=&quot;pl-mi1&quot;&gt;&lt;span class=&quot;pl-mi1&quot;&gt;+&lt;/span&gt;    &quot;outDir&quot;: &quot;dist&quot;&lt;/span&gt;
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再次编译后可正常运行。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
$ tsc
$ node dist/main.js
{ data: &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;blah&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;配合着 &lt;code&gt;esModuleInterop&lt;/code&gt; 选项可以让导入更加简洁。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;tsconfig.json&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-diff&quot; readability=&quot;12&quot;&gt;
&lt;pre&gt;
{
  &quot;compilerOptions&quot;: {
    &quot;target&quot;: &quot;es5&quot;,
    &quot;module&quot;: &quot;commonjs&quot;,
&lt;span class=&quot;pl-mi1&quot;&gt;&lt;span class=&quot;pl-mi1&quot;&gt;+&lt;/span&gt;    &quot;esModuleInterop&quot;: true,&lt;/span&gt;
    &quot;resolveJsonModule&quot;: true,
    &quot;outDir&quot;: &quot;dist&quot;
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;main.ts&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-diff&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-md&quot;&gt;&lt;span class=&quot;pl-md&quot;&gt;-&lt;/span&gt; import * as data from &quot;./bar.json&quot;;&lt;/span&gt;
&lt;span class=&quot;pl-mi1&quot;&gt;&lt;span class=&quot;pl-mi1&quot;&gt;+&lt;/span&gt; import data from &quot;./bar.json&quot;;&lt;/span&gt;
console.log(data);
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;一般项目中都使用专门的打包工具比如 Webpack，Parcel 等，资源的解析加载都会被很好地处理。只是我们需要解决 TypeScipt 模块解析报错的问题，此时可通过对相应文件编写声明文件的方式。&lt;/p&gt;
&lt;h2&gt;相关资源&lt;/h2&gt;
</description>
<pubDate>Sat, 13 Apr 2019 15:16:00 +0000</pubDate>
<dc:creator>刘哇勇</dc:creator>
<og:description>需要理解的是，TypeScript 作为语言，他只处理代码模块。其他类型的文件这种非代码模块的导入，讲道理是通过另外的打包工具来完成的，比如 Web 应用中的图片，样式，JSON 还有 HTML 模板</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Wayou/p/import_files_in_typescript.html</dc:identifier>
</item>
<item>
<title>springboot中HandlerMethodArgumentResolver的使用 - 祁保义</title>
<link>http://www.cnblogs.com/baoyi/p/springboot_HandlerMethodArgumentResolver.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/baoyi/p/springboot_HandlerMethodArgumentResolver.html</guid>
<description>




&lt;p&gt;springboot项目中在所有的controller方法中想增加token验证，即所有的方法都必须登陆有token之后才能访问。springboot封装了SpringMVC中的HandlerMethodArgumentResolver接口，通过实现HandlerMethodArgumentResolver这个接口可以达到需求。具体操作如下：&lt;/p&gt;
&lt;p&gt;1. 新建了一个类 实现HandlerMethodArgumentResolver接口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/384937/201904/384937-20190413230839731-63704443.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2. 自定义一个注解，后面的所有方法用这个注解。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/384937/201904/384937-20190413230925204-1214532712.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3. 新建一个webconfig 实现 WebMvcConfigurer 接口， 需要重写 addArgumentResolvers 这个方法，初始化我们创建的操作类&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/384937/201904/384937-20190413231243522-1726769213.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 4. 新建一个测试类&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/384937/201904/384937-20190413231308760-1511616593.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这个测试类中，就可以取到我们写的拦截方法中的值。&lt;/p&gt;

</description>
<pubDate>Sat, 13 Apr 2019 15:15:00 +0000</pubDate>
<dc:creator>祁保义</dc:creator>
<og:description>springboot项目中在所有的controller方法中想增加token验证，即所有的方法都必须登陆有token之后才能访问。springboot封装了SpringMVC中的HandlerMeth</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/baoyi/p/springboot_HandlerMethodArgumentResolver.html</dc:identifier>
</item>
<item>
<title>Java之冒泡排序(升序) - 鸿灬嗳</title>
<link>http://www.cnblogs.com/honghuoai/p/10703473.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/honghuoai/p/10703473.html</guid>
<description>&lt;h2 id=&quot;java之冒泡排序&quot;&gt;Java之冒泡排序&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt; * 编辑者：鸿灬嗳
 * 实现功能： 使用冒泡排序对数组：{25，24，12，76，101，96，28} 排序。
 */
package test05;

public class BubbleSort {
    public static void main(String[] args) {
        int[] arr = { 25, 24, 12, 76, 101, 96, 28 };
        System.out.println(&quot;冒泡排序前数组为：&quot;);
        printArray(arr);
        Bubble(arr);
    }

    public static void printArray(int[] arr) {
        for (int i = 0; i &amp;lt; arr.length; i++) {
            System.out.println(arr[i]);
        }
    }

    public static void Bubble(int[] arr) {
        for (int i = 0,count=0; i &amp;lt; arr.length - 1; i++) {
            
            for (int j = 0; j &amp;lt; arr.length - i - 1; j++) {
                if (arr[j] &amp;gt; arr[j + 1]) {
                    int temp;
                    temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                }

            }
            count++;
            System.out.println(&quot;第&quot;+count+&quot;次冒泡排序：&quot;);
            printArray(arr);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;运行结果：&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1635446/201904/1635446-20190413195527209-627960156.png&quot; alt=&quot;bubbleSort&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;冒泡排序难点&quot;&gt;冒泡排序难点:&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;创建排序方法时需要定义外层和内层循环函数&lt;/strong&gt;&lt;br/&gt;&lt;em&gt;外层循环：遍历的长度为&lt;strong&gt;小于arr.length-1,&lt;/strong&gt;而不是&lt;strong&gt;arr.length&lt;/strong&gt;&lt;/em&gt;，&lt;span&gt;原因：外层函数d的循环变量是用来控制多少轮比较，每一轮比较可以确定一个元素的位置，有因为比较是两个数之间，自身不要自身比较，所以需要减去1。&lt;/span&gt;&lt;br/&gt;&lt;em&gt;内层循环：遍历的长度为&lt;strong&gt;小于arr.length-i-1&lt;/strong&gt;而不是&lt;/em&gt;&lt;strong&gt;arr.length&lt;/strong&gt;*,&lt;br/&gt;&lt;span&gt;原因：内层函数是用来控制每轮比较的的次数他被作为角标去比较数组的元素，由于变量在循环过程中是自加的，这样既可以实现所有相邻元素之间的必较，在程序中我定义的是升序交换，所以一轮内循环结束后最大的元素会交换到最后一个，每轮内循环结束都会确定一个元素的位置，如果内循环次数再用length-1的话，就多比较了，造成资源浪费，所以要减去外部循环的已经遍历的值，也就是代码中的i值。&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;编写使用的软件：&lt;a href=&quot;https://www%5B.eclipse.org/downloads/packages/&quot;&gt;eclipse&lt;/a&gt;，Java环境：&lt;a href=&quot;https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html&quot;&gt;Java SE Development Kit 8u201&lt;/a&gt;&lt;/strong&gt;&lt;br/&gt;&lt;em&gt;注意：新手编写请多多关注按照，本代码的bubble方法的外层函数遍历了6边，可以进行优化，本次未优化（图片未拍全），下次将发出优化后的代码。&lt;/em&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 13 Apr 2019 15:11:00 +0000</pubDate>
<dc:creator>鸿灬嗳</dc:creator>
<og:description>Java之冒泡排序 运行结果： 冒泡排序难点: 创建排序方法时需要定义外层和内层循环函数 外层循环：遍历的长度为 小于arr.length 1, 而不是 arr.length ，原因：外层函数d的循环</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/honghuoai/p/10703473.html</dc:identifier>
</item>
<item>
<title>Java中的队列同步器AQS - 风沙迷了眼</title>
<link>http://www.cnblogs.com/fsmly/p/10701109.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fsmly/p/10701109.html</guid>
<description>&lt;p&gt;　　1、队列同步器是用来构建锁或者其他同步组件的基础框架，使用一个int型变量代表同步状态，通过内置的队列来完成线程的排队工作。&lt;/p&gt;
&lt;p&gt;　　2、下面是JDK8文档中对于AQS的部分介绍&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; AbstractQueuedSynchronizer &lt;span&gt;extends&lt;/span&gt; AbstractOwnableSynchronizer &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Serializable
&lt;/span&gt;&lt;span&gt;　　提供一个框架，用于实现依赖先进先出（FIFO）等待队列的阻塞锁和相关同步器（信号量，事件等）。 该类被设计为大多数类型的同步器的有用依据，这些同步器依赖于单个原子int值来表示状&lt;br/&gt;态。子类必须定义改变此状态的protected方法，以及根据该对象被获取或释放来定义该状态的含义。给定这些，这个类中的其他方法执行所有排队和阻塞机制。 子类可以保持其他状态字段，但只以&lt;br/&gt;原子方式更新int使用方法操纵值getState() ， setState(int)和compareAndSetState(int, int)被跟踪相对于同步。 
　　&lt;/span&gt;&lt;span&gt;此类支持默认独占模式和共享模式。 当以独占模式获取时，尝试通过其他线程获取不能成功。 多线程获取的共享模式可能（但不需要）成功。 除了在机械意义上，这个类不理解这些差异，当共享&lt;br/&gt;模式获取成功时，下一个等待线程（如果存在）也必须确定它是否也可以获取。 在不同模式下等待的线程共享相同的FIFO队列。 通常，实现子类只支持这些模式之一，但是两者都可以在&lt;br/&gt;ReadWriteLock中发挥作用。仅支持独占或仅共享模式的子类不需要定义支持未使用模式的方法。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　总结来说就是：&lt;/p&gt;
&lt;p&gt;　　①子类通过&lt;strong&gt;继承AQS&lt;/strong&gt;并实现其抽象方法来管理同步状态，对于同步状态的更改通过提供的&lt;strong&gt;getState()、setState(int state)、compareAndSetState(int expect, int update)&lt;/strong&gt;来进行操作，因为使用CAS操作保证同步状态的改变是&lt;strong&gt;原子的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　②子类被推荐定义为自定义同步组件的静态内部类，同步器本身并没有实现任何的同步接口，仅仅是定义了若干状态获取和释放的方法来提供自定义同步组件的使用。&lt;/p&gt;
&lt;p&gt;　　③同步器既可以支持独占式的获取同步状态，也可以支持共享式的获取同步状态（ReentrantLock、ReentrantReadWriteLock、CountDownLatch等不同类型的同步组件）&lt;/p&gt;
&lt;p&gt;　　3、同步器是实现锁的关键，在锁的实现中聚合同步器，利用同步器实现锁的语义；&lt;/p&gt;

&lt;h3&gt;1、同步器的设计实现原理&lt;/h3&gt;
&lt;p&gt;　　继承同步器并且重写指定的方法，然后将同步器组合在自定义同步组件的实现中，并且调用同步器提供的模板方法（这些模板方法会调用重写的方法）；而重写指定的方法的时候，需要使用&lt;strong&gt;getState()、setState(int state)、compareAndSetState(int expect, int update)&lt;/strong&gt;来访问或者更新同步状态。下面是源码中state变量和三个方法的定义声明实现&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;     * The synchronization state.(同步状态)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; state;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;     * Returns the current value of synchronization state.(返回当前的同步状态)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;     * This operation has memory semantics of a {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; volatile} read.
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;     * 此操作的内存语义为&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; volatile read
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; current state value
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getState() {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; state;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;     * Sets the value of synchronization state.(设置新的同步状态)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;     * This operation has memory semantics of a {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; volatile} write.
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;     * 此操作的内存语义为&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; volatile read
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; newState the new state value
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setState(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; newState) {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         state =&lt;span&gt; newState;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;     * Atomically sets synchronization state to the given updated
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;     * value if the current state value equals the expected value.(如果要更新的状态和期望的状态相同，那就通过原子的方式更新状态)
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;     * This operation has memory semantics of a {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; volatile} read
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;     * and write.( 此操作的内存语义为&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; volatile read 和 write)
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; expect the expected value
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; update the new value
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; true} if successful. False return indicates that the actual
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;     *         value was not equal to the expected value.(如果更新的状态和期望的状态不同就返回false)
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; compareAndSetState(&lt;span&gt;int&lt;/span&gt; expect, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; update) {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; See below for intrinsics setup to support this&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; unsafe.compareAndSwapInt(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, stateOffset, expect, update);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2、下面介绍AQS提供可被重写的方法&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * 独占式的获取同步状态，实现该方法需要查询当前状态并判断同步状态是否符合预期，然后再进行CAS设置同步状态
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt; *
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; tryAcquire(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; arg) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UnsupportedOperationException();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt; * 独占式的释放同步状态，等待获取同步状态的线程可以有机会获取同步状态
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt; *
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; tryRelease(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; arg) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UnsupportedOperationException();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt; * 尝试以共享模式获取。 该方法应该查询对象的状态是否允许在共享模式下获取该对象，如果是这样，就可以获取它。 该方法总是由执行获取的线程调用。
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt; * 如果此方法报告失败，则获取方法可能将线程排队（如果尚未排队），直到被其他线程释放为止。 获取失败时返回负值，如果在获取成共享模式下功但没
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt; * 有后续共享模式获取可以成功，则为零; 并且如果以共享模式获取成功并且随后的共享模式获取可能成功，则为正值，在这种情况下，后续等待线程必须检查可用性。
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; tryAcquireShared(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; arg) {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; UnsupportedOperationException(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果不支持共享模式 ,会抛出该异常&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt; &lt;span&gt; * 尝试将状态设置为以共享模式释放同步状态。 该方法总是由执行释放的线程调用。 
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; tryReleaseShared(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; arg) {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; UnsupportedOperationException(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果不支持共享模式 ,会抛出该异常&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt; &lt;span&gt; * 当前同步器是否在独占模式下被线程占用，一般该方法表示是否被当前线程所独占
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; isHeldExclusively(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; arg) {
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;     &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; UnsupportedOperationException(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果不支持共享模式 ,会抛出该异常&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3、同步器提供的模板方法&lt;/h3&gt;
&lt;p&gt;　　在实现自定义同步组件的时候，需要重写上面的方法，而下面的模板方法会调用上面重写的方法。下面介绍同步器提供的模板方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * 以独占模式获取，忽略中断。 通过调用至少一次tryAcquire(int)实现，成功返回。 否则线 
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt; * 程排队，可能会重复阻塞和解除阻塞，直到成功才调用tryAcquire(int) 
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; acquire(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; arg) {...}
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt; * 以独占方式获得，如果中断，中止。 通过首先检查中断状态，然后调用至少一次
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt; * tryAcquire(int) ，成功返回。 否则线程排队，可能会重复阻塞和解除阻塞，调用
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt; * tryAcquire(int)直到成功或线程中断。
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; acquireInterruptibly(&lt;span&gt;int&lt;/span&gt; arg) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {...}
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt; * 尝试以独占模式获取，如果中断则中止，如果给定的超时时间失败。 首先检查中断状态，然
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt; * 后调用至少一次tryAcquire(int) ，成功返回。 否则，线程排队，可能会重复阻塞和解除阻
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt; * 塞，调用tryAcquire(int)直到成功或线程中断或超时
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; tryAcquireNanos(&lt;span&gt;int&lt;/span&gt; arg, &lt;span&gt;long&lt;/span&gt; nanosTimeout) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {...}
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; &lt;span&gt; * 以共享模式获取，忽略中断。 通过首次调用至少一次执行 tryAcquireShared(int)，成功返
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt; * 回。 否则线程排队，可能会重复阻塞和解除阻塞，直到成功调用tryAcquireShared(int) 。
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; acquireShared(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; arg){...}
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt; &lt;span&gt; * 以共享方式获取，如果中断，中止。 首先检查中断状态，然后调用至少一次
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt; * tryAcquireShared(int) ，成功返回。 否则线程排队，可能会重复阻塞和解除阻塞，调用
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt; * tryAcquireShared(int)直到成功或线程中断。
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; acquireSharedInterruptibly(&lt;span&gt;int&lt;/span&gt; arg) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException{...}
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt; &lt;span&gt; * 尝试以共享模式获取，如果中断则中止，如果给定的时间超过，则失败。 通过首先检查中断 
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt; * 状态，然后调用至少一次tryAcquireShared(int) ，成功返回。 否则，线程排队，可能会重 
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt; * 复阻塞和解除阻塞，调用tryAcquireShared(int)直到成功或线程中断或超时。 
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; tryAcquireSharedNanos(&lt;span&gt;int&lt;/span&gt; arg, &lt;span&gt;long&lt;/span&gt; nanosTimeout) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException{...}
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; 
&lt;span&gt;41&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt; &lt;span&gt; * 独占式的释放同步状态，该方法会在释放同步状态之后，将同步队列中的第一个节点包含的线程唤醒
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; release(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; arg){...}
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; 
&lt;span&gt;46&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;47&lt;/span&gt; &lt;span&gt; * 共享式的释放同步状态
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;49&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; releaseShared(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; arg){...}
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; 
&lt;span&gt;51&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;52&lt;/span&gt; &lt;span&gt; * 获取在等待队列上的线程集合
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;54&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Collection&amp;lt;Thread&amp;gt; getQueuedThreads(){...}
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt; 1、同步队列&lt;/h3&gt;
&lt;p&gt;a)t同步队列的实现原理&lt;/p&gt;
&lt;p&gt;　　AQS内部&lt;strong&gt;维护一个同步队列&lt;/strong&gt;来完成同步状态的管理，当前线程获取同步状态失败的时候，AQS会&lt;strong&gt;将当前线程以及等待状态信息构造成一个结点Node&lt;/strong&gt;并将其加入同步队列中，同时&lt;strong&gt;阻塞当前线程&lt;/strong&gt;，当同步状态由持有线程释放的时候，会将同步队列中的首节点唤醒使其再次尝试获取同步状态。同步队列中的结点用来保存获取同步状态失败的线程的线程引用、等待状态以及前驱结点和后继结点。下面是Node的属性分析&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Node {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 共享模式下构造结点 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Node SHARED = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Node();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 独占模式下构造结点 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Node EXCLUSIVE = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 用于指示线程已经取消的waitStatus值（由于在同步队列中等待的线程等待超时或者发生中断，需要从同步队列中取消等待，结点进入该状态将不会发生变化）&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; CANCELLED =  1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;&lt;span&gt; waitstatus值指示后续线程需要取消等待（后继结点的线程处于等待状态，而当前结点的线程如果释放了同步状态或者CANCELL，将会通知后继结点的线程以运行） &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; SIGNAL    = -1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;waitStatus值表示线程正在等待条件（原本结点在等待队列中，结点线程等待在Condition上，当其他线程对Condition调用了signal()方法之后）该结点会从&lt;br/&gt;　　　　　　　　 等待队列中转移到同步队列中，进行同步状态的获取 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; CONDITION = -2&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;         * waitStatus值表示下一个共享式同步状态的获取应该无条件传播下去
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; PROPAGATE = -3&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;         * 不同的等到状态的int值
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; waitStatus;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;         * 前驱结点，当结点加入同步队列将会被设置前驱结点信息
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;volatile&lt;/span&gt;&lt;span&gt; Node prev;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;         * 后继结点
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;volatile&lt;/span&gt;&lt;span&gt; Node next;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt; &lt;span&gt;         * 当前获取到同步状态的线程
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;volatile&lt;/span&gt;&lt;span&gt; Thread thread;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt; &lt;span&gt;         * 等待队列中的后继结点，如果当前结点是共享的，那么这个字段是一个SHARED常量；也就是说结点类型（独占和共享）和等待队列中的后继结点公用一个字段
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt; &lt;span&gt;        Node nextWaiter;
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; 
&lt;span&gt;43&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt; &lt;span&gt;         * 如果是共享模式下等待，那么返回true（因为上面的Node nextWaiter字段在共享模式下是一个SHARED常量）
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isShared() {
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; nextWaiter ==&lt;span&gt; SHARED;
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; 
&lt;span&gt;50&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt; Node predecessor() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; NullPointerException {
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;             Node p =&lt;span&gt; prev;
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (p == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;                 &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NullPointerException();
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;55&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; p;
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; 
&lt;span&gt;58&lt;/span&gt;         Node() {    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用于建立初始头结点或SHARED标记&lt;/span&gt;
&lt;span&gt;59&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; 
&lt;span&gt;61&lt;/span&gt;         Node(Thread thread, Node mode) {     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用于添加到等待队列&lt;/span&gt;
&lt;span&gt;62&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.nextWaiter =&lt;span&gt; mode;
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.thread =&lt;span&gt; thread;
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt; 
&lt;span&gt;66&lt;/span&gt;         Node(Thread thread, &lt;span&gt;int&lt;/span&gt; waitStatus) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Used by Condition&lt;/span&gt;
&lt;span&gt;67&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.waitStatus =&lt;span&gt; waitStatus;
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.thread =&lt;span&gt; thread;
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;b）同步队列示意图和简单分析&lt;/p&gt;
&lt;p&gt;　　①同步队列示意图：当一个线程获取了同步状态后，其他线程不能获取到该同步状态，就会被构造称为Node然后添加到同步队列之中，这个添加的过程基于CAS保证线程安全性。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201904/1368768-20190413160241164-1504985663.png&quot; alt=&quot;&quot; width=&quot;528&quot; height=&quot;174&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　②同步队列遵循先进先出(FIFO)，首节点是获取到同步状态的结点，首节点的线程在释放同步状态的时候将会唤醒后继结点（然后后继结点就会变成新的首节点等待获取同步状态）&lt;/p&gt;
&lt;h3&gt;2、独占式同步状态的获取和释放&lt;/h3&gt;
&lt;p&gt;　　①前面说过，同步器的acquire()方法会获取同步状态，这个方法对不会响应中断，也就是说当线程获取通同步状态失败后会被构造成结点加入到同步队列中，当线程被中断时不会从同步队列中移除。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * ①首先调用tryAcquire方法尝试获取同步状态，如果获取同步状态失败，就进行下面的操作
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt; * ②获取失败：按照独占式的模式构造同步结点并通过addWaiter方法将结点添加到同步队列的尾部
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; * ③通过acquireQueue方法自旋获取同步状态。
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt; * ④如果获取不到同步状态，就阻塞结点中的线程，而结点中的线程唤醒主要是通过前驱结点的出队或者被中断来实现
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; acquire(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; arg) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!tryAcquire(arg) &amp;amp;&amp;amp;&lt;span&gt; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        selfInterrupt();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　②下面是addWaiter、enq和自旋获取同步状态acquireQueue方法的实现（该方法的主要作用就是将获取同步状态失败的线程构造成结点然后添加到同步队列的队尾）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Node addWaiter(Node mode) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     Node node = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Node(Thread.currentThread(), mode);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;尝试直接放在队尾&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     Node pred = tail; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;直接获取同步器的tail结点&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (pred != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) { 
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         node.prev =&lt;span&gt; pred; 
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (compareAndSetTail(pred, node)) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;队尾结点不为空通过原子操作将构造的结点置为队尾结点&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;             pred.next =&lt;span&gt; node;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; node;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;采用自旋方式保证构造的结点添加到同步队列中&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    enq(node);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; node;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; Node enq(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; Node node) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (;;) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;死循环知道添加成功&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;         Node t =&lt;span&gt; tail;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (t == &lt;span&gt;null&lt;/span&gt;) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Must initialize&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (compareAndSetHead(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Node()))
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                 tail =&lt;span&gt; head;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             node.prev =&lt;span&gt; t;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过CAS方式将结点添加到同步队列之后才会返回，否则就会不断尝试添加(这样实际上就是在并发情况下，把向同步队列添加Node变得串行化了)&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (compareAndSetTail(t, node)) {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                 t.next =&lt;span&gt; node;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; t;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;}    
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt; &lt;span&gt; *     通过tryAcquire()和addWaiter()，表示该线程获取同步状态已经失败，被放入同步        
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt; * 队列尾部了。线程阻塞等待直到其他线程(前驱结点获得同步装填或者被中断)释放同步状
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt; * 态后唤醒自己，自己才能获得。
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; acquireQueued(&lt;span&gt;final&lt;/span&gt; Node node, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; arg) {
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;     &lt;span&gt;boolean&lt;/span&gt; failed = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;         &lt;span&gt;boolean&lt;/span&gt; interrupted = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;线程在死循环的方式中尝试获取同步状态&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;             &lt;span&gt;final&lt;/span&gt; Node p = node.predecessor(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取前驱结点
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;只有前驱接待是头结点的时候才能尝试获取同步状态&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (p == head &amp;amp;&amp;amp;&lt;span&gt; tryAcquire(arg)) {
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;                 setHead(node); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取到同步状态之后，就将自己设置为头结点&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt;                 p.next = &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;前驱结点已经获得同步状态去执行自己的程序了，所以需要释放掉占用的同步队列的资源，由JVM回收&lt;/span&gt;
&lt;span&gt;49&lt;/span&gt;                 failed = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; interrupted;
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果获取同步状态失败，应该自旋等待继续获取并且校验自己的中断标志位信息&lt;/span&gt;
&lt;span&gt;53&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;
&lt;span&gt;54&lt;/span&gt; &lt;span&gt;                parkAndCheckInterrupt())
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;                 interrupted = &lt;span&gt;true&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果被中断，就改变自己的中断标志位状态信息&lt;/span&gt;
&lt;span&gt;56&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;     } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (failed)
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; &lt;span&gt;            cancelAcquire(node);
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　③独占式获取同步状态的整个流程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201904/1368768-20190413171216527-230259265.png&quot; alt=&quot;&quot; width=&quot;517&quot; height=&quot;327&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　④独占式同步器的释放：release方法执行时，会唤醒头结点的后继结点线程&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; release(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; arg) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (tryRelease(arg)) {
        Node h &lt;/span&gt;= head;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;头结点
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;唤醒头结点的后继结点线程&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (h != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; h.waitStatus != 0&lt;span&gt;)
            unparkSuccessor(h);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3、共享式同步状态的获取和释放 &lt;/h3&gt;
&lt;p&gt;　　①共享式获取和独占式获取最主要的区别是能否有多个线程同时获取到同步状态。如图所示简易描述二者的区别（共享式访问的时候，可以允许多个线程访问资源，但是存在独占式访问的时候，同一时刻其他的不管是共享还是独占都会被阻塞）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201904/1368768-20190413204947517-1468253875.png&quot; alt=&quot;&quot; width=&quot;529&quot; height=&quot;131&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;②关于共享式获取同步状态的方法&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * 此方法是共享模式下线程获取共享同步状态的顶层入口。它会尝试去获取同步状态，获取成功则直接返回，
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt; * 获取失败则进入等待队列一直尝试获取(执行doAcquireShared方法体中的内容)，直到获取到资源为止(条件就是tryAcquireShared方法返回值大于等于0)，整个过程忽略中断
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; acquireShared(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; arg) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (tryAcquireShared(arg) &amp;lt; 0&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        doAcquireShared(arg);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;} 
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt; * &quot;自旋&quot;尝试获取同步状态
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; doAcquireShared(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; arg) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;首先将该线程包括线程引用、等待状态、前驱结点和后继结点的信息封装台Node中，然后添加到等待队列里面(一共享模式添加)&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;final&lt;/span&gt; Node node =&lt;span&gt; addWaiter(Node.SHARED);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;boolean&lt;/span&gt; failed = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;boolean&lt;/span&gt; interrupted = &lt;span&gt;false&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前线程的中断标志&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;final&lt;/span&gt; Node p = node.predecessor(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取前驱结点&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (p ==&lt;span&gt; head) {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前驱结点是头结点的时候就会以共享的方式去尝试获取同步状态&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;                 &lt;span&gt;int&lt;/span&gt; r =&lt;span&gt; tryAcquireShared(arg); 
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断tryAcquireShared的返回值&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (r &amp;gt;= 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果返回值大于等于0，表示获取同步状态成功，就修改当前的头结点并将信息传播都后续的结点队列中&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;                    setHeadAndPropagate(node, r);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                     p.next = &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 释放掉已经获取到同步状态的前驱结点的资源&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (interrupted)
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;                         selfInterrupt(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;检查中断标志&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;                     failed = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;
&lt;span&gt;35&lt;/span&gt; &lt;span&gt;                parkAndCheckInterrupt())
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                 interrupted = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;     } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (failed)
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;            cancelAcquire(node);
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;strong&gt;根据源代码我们可以了解共享式获取同步状态的整个过程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　首先同步器会调用tryAcquireShared方法来尝试获取同步状态，然后根据这个返回值来判断是否获取到同步状态（当返回值大于等于0可视为获取到同步状态）；如果第一次获取失败的话，就进入'自旋'状态（执行doAcquireShared方法）一直尝试去获取同步状态；在自旋获取中，如果检查到当前前驱结点是头结点的话，就会尝试获取同步状态，而一旦获取成功（tryAcquireShared方法返回值大于等于0）就可以从自旋状态退出。&lt;/p&gt;
&lt;p&gt;　　另外，还有一点就是上面说到的一个处于等待队列的线程要想开始尝试去获取同步状态，需要满足的条件就是前驱结点是头结点，那么它本身就是整个队列中的第二个结点。当头结点释放掉所有的临界资源之后，我们考虑每个线程运行所需资源的不同数量问题，如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201904/1368768-20190413212110839-1692189423.png&quot; alt=&quot;&quot; width=&quot;708&quot; height=&quot;272&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　③共享式同步状态的释放&lt;/p&gt;
&lt;p&gt;　　对于支持共享式的同步组件(即多个线程同同时访问)，它们和独占式的主要区别就是tryReleaseShared方法必须确保同步状态的释放是线程安全的(CAS的模式来释放同步状态，因为既然是多个线程能够访问，那么释放的时候也会是多个线程的，就需要保证释放时候的线程安全)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * 该方法是共享模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果成功释放且允许唤醒等待线程，它会唤醒等待队列里的其他线程来获取资源。
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; releaseShared(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; arg) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (tryReleaseShared(arg)) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         doReleaseShared(); &lt;span&gt;//
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　1、共享式锁的实现&lt;/p&gt;
&lt;p&gt;　　①、自定义一个同步组件，可以允许两个线程访问（共享式同步组件），超过两个线程就会被阻塞。&lt;/p&gt;
&lt;p&gt;　　②、既然是共享式同步组件，按照前面所说的，组件本身需要使用AQS提供的共享式模板方法acquireShared等；组件的内部类需要实现AQS，并且重写关于共享式获取同步状态的方法(tryAcquireShared()、tryReleaseShared()等共享模式下的方法)。&lt;/p&gt;
&lt;p&gt;　　③、既然是两个线程能够同时访问的话，那么状态数的取值范围就是0、1、2了，每当一个线程获取到同步状态的时候state值减1，反之就会增加1；当state值为0的时候就会阻塞其他想要获取同步状态的线程。对于同步状态的更改需要使用CAS来进行保证原子性。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('6a822a59-1d8c-4d8d-bf75-f5604b09a312')&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_6a822a59-1d8c-4d8d-bf75-f5604b09a312&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_6a822a59-1d8c-4d8d-bf75-f5604b09a312&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('6a822a59-1d8c-4d8d-bf75-f5604b09a312',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_6a822a59-1d8c-4d8d-bf75-f5604b09a312&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.source.concurrent;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.TimeUnit;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.locks.AbstractQueuedSynchronizer;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.locks.Condition;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.locks.Lock;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; TestAQS &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Lock{
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; Sync sync = &lt;span&gt;new&lt;/span&gt; Sync(2&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Sync &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; AbstractQueuedSynchronizer {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         
&lt;span&gt;14&lt;/span&gt;         Sync(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; num) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(num &amp;lt;= 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                 &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RuntimeException(&quot;num需要大于0&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            setState(num);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        @Override
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; tryAcquireShared(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; arg) {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;&lt;span&gt;(; ;) {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                 &lt;span&gt;int&lt;/span&gt; currentState =&lt;span&gt; getState();
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                 &lt;span&gt;int&lt;/span&gt; newState = currentState -&lt;span&gt; arg;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;(newState &amp;lt; 0 ||&lt;span&gt; compareAndSetState(currentState, newState)) {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; newState;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt; &lt;span&gt;        @Override
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; tryReleaseShared(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; arg) {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;&lt;span&gt;(; ;) {
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                 &lt;span&gt;int&lt;/span&gt; currentState =&lt;span&gt; getState();
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                 &lt;span&gt;int&lt;/span&gt; newState = currentState +&lt;span&gt; arg;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(compareAndSetState(currentState, newState)) {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;         
&lt;span&gt;43&lt;/span&gt;         
&lt;span&gt;44&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; lock() {
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;         sync.acquireShared(1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; 
&lt;span&gt;50&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; unlock() {
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;         sync.releaseShared(1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; 
&lt;span&gt;55&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;......&lt;/span&gt;
&lt;span&gt;56&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;共享式锁&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('a4a09db9-53ba-4ab9-8dd2-dcdf4211911e')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_a4a09db9-53ba-4ab9-8dd2-dcdf4211911e&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_a4a09db9-53ba-4ab9-8dd2-dcdf4211911e&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('a4a09db9-53ba-4ab9-8dd2-dcdf4211911e',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_a4a09db9-53ba-4ab9-8dd2-dcdf4211911e&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * 测试结果：输出的线程名称是成对的，保证同一时刻只有两个线程能够获取到锁
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt; *
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;         
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestLockShare {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    @Test
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test() {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         Lock lock = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TestAQS();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;class&lt;/span&gt; Worker &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;                    lock.lock();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                         Thread.sleep(1000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;                        System.out.println(Thread.currentThread().getName());
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                         Thread.sleep(1000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                     } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;                        e.printStackTrace();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                     } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;                        lock.unlock();
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         
&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 8; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             Worker worker = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Worker();
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             worker.setDaemon(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;            worker.start();
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;             
&lt;span&gt;34&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 8; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;                 Thread.sleep(1000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;             } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated catch block&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt; &lt;span&gt;                e.printStackTrace();
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;            System.out.println();
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;共享式锁测试&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　2、独占式锁的实现&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('0dcb2460-0937-4fe5-bd35-c53c1753af4d')&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_0dcb2460-0937-4fe5-bd35-c53c1753af4d&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_0dcb2460-0937-4fe5-bd35-c53c1753af4d&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('0dcb2460-0937-4fe5-bd35-c53c1753af4d',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_0dcb2460-0937-4fe5-bd35-c53c1753af4d&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.source.concurrent;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.TimeUnit;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.locks.AbstractQueuedSynchronizer;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.locks.Condition;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.locks.Lock;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Mutex &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Lock{
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; Sync sync = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Sync();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Sync &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; AbstractQueuedSynchronizer {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;         * 尝试获取资源，立即返回。成功则返回true，否则false。
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        @Override
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; tryAcquire(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; arg) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(compareAndSetState(0, 1)) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;state为0才设置为1，不可重入！&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;                 setExclusiveOwnerThread(Thread.currentThread());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置为当前线程独占资源&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;         * 尝试释放资源，立即返回。成功则为true，否则false。
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;        @Override
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; tryRelease(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; arg) {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(getState() == 0) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;既然来释放，那肯定就是已占有状态了。只是为了保险，多层判断！&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;                 &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalMonitorStateException();
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             setExclusiveOwnerThread(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;             setState(0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; 
&lt;span&gt;39&lt;/span&gt; &lt;span&gt;        @Override
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;         &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isHeldExclusively() {
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断是否锁定状态&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; getState() == 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;         
&lt;span&gt;45&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;     
&lt;span&gt;47&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; lock() {
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;         sync.acquire(1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; 
&lt;span&gt;52&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; tryLock(&lt;span&gt;long&lt;/span&gt; time, TimeUnit unit) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; sync.tryAcquire(1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; 
&lt;span&gt;57&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; unlock() {
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;         sync.release(1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; 
&lt;span&gt;62&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;独占式锁&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('88a2b20a-517d-4b35-8415-812aaf709e5d')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_88a2b20a-517d-4b35-8415-812aaf709e5d&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_88a2b20a-517d-4b35-8415-812aaf709e5d&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('88a2b20a-517d-4b35-8415-812aaf709e5d',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_88a2b20a-517d-4b35-8415-812aaf709e5d&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestMutex {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    @Test
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test() {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         Lock lock = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Mutex();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;class&lt;/span&gt; Worker &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;                    lock.lock();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                         Thread.sleep(1000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;                        System.out.println(Thread.currentThread().getName());
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                         Thread.sleep(1000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                     } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;                        e.printStackTrace();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                     } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;                        lock.unlock();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         
&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 8; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             Worker worker = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Worker();
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             worker.setDaemon(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;            worker.start();
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 8; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                 Thread.sleep(1000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;                e.printStackTrace();
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;            System.out.println();
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;独占式锁测试&lt;/span&gt;&lt;/div&gt;
</description>
<pubDate>Sat, 13 Apr 2019 14:18:00 +0000</pubDate>
<dc:creator>风沙迷了眼</dc:creator>
<og:description>一、AQS概念 1、队列同步器是用来构建锁或者其他同步组件的基础框架，使用一个int型变量代表同步状态，通过内置的队列来完成线程的排队工作。 2、下面是JDK8文档中对于AQS的部分介绍 总结来说就是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fsmly/p/10701109.html</dc:identifier>
</item>
<item>
<title>设计模式之命令模式(行为型) - smileNicky</title>
<link>http://www.cnblogs.com/mzq123/p/10703070.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mzq123/p/10703070.html</guid>
<description>&lt;h3 id=&quot;一模式定义&quot;&gt;一、模式定义&lt;/h3&gt;
&lt;p&gt;命令模式(Command Pattern)：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分离，两者之间通过命令对象进行沟通，方便将命令对象进行储存、传递、调用、增加与管理。命令模式别名为动作(Action)模式或事务(Transaction)模式，属于对象行为型模式。&lt;/p&gt;
&lt;h3 id=&quot;二模式角色&quot;&gt;二、模式角色&lt;/h3&gt;
&lt;p&gt;命令模式包括如下角色：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Client：客户类，负责调用&lt;/li&gt;
&lt;li&gt;Command：抽象命令类，声明执行命令的接口，拥有执行命令的抽象方法 execute()。&lt;/li&gt;
&lt;li&gt;ConcreteCommand：具体命令类，是抽象命令类的具体实现类，它拥有接收者对象，并通过调用接收者的功能来完成命令要执行的操作。&lt;/li&gt;
&lt;li&gt;Invoker：调用者，请求的发送者，通常拥有很多的命令对象，并通过访问命令对象来执行相关请求，它不直接访问接收者。&lt;/li&gt;
&lt;li&gt;Receiver：接收者，执行命令功能的相关操作，是具体命令对象业务的真正实现者。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;三模式分析&quot;&gt;三、模式分析&lt;/h3&gt;
&lt;p&gt;命令模式的本质：是对命令进行封装，将发出命令的责任和执行命令的责任分离。&lt;/p&gt;
&lt;p&gt;命令模式的实际执行者是接收者(Receiver)，调用者和接收者两者之间通过命令对象进行沟通。&lt;/p&gt;
&lt;p&gt;命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否被执行、何时被执行，以及是怎么被执行的。&lt;/p&gt;
&lt;p&gt;典型的命令模式代码&lt;/p&gt;
&lt;p&gt;抽象命令类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public abstract class Command
{
    public abstract void execute();
} 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体命令类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class ConcreteCommand extends Command
{
    private Receiver receiver;
    public void execute()
    {
        receiver.action();
    }
} 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用者Invoker类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Invoker
{
    private Command command;
    
    public Invoker(Command command)
    {
        this.command=command;
    }
    
    public void setCommand(Command command)
    {
        this.command=command;
    }
    
    //业务方法，用于调用命令类的方法
    public void call()
    {
        command.execute();
    }
} &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接收者(Receiver)类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Receiver
{
    public void action()
    {
        //具体操作
    }
} 
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;四典型例子&quot;&gt;四、典型例子&lt;/h3&gt;
&lt;p&gt;例子来自&lt;a href=&quot;https://baike.baidu.com/item/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/19696449&quot;&gt;《设计模式》&lt;/a&gt;一书&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;电视机是请求的接收者，遥控器是请求的发送者，遥控器上有一些按钮，不同的按钮对应电视机的不同操作。抽象命令角色由一个命令接口来扮演，有三个具体的命令类实现了抽象命令接口，这三个具体命令类分别代表三种操作：打开电视机、关闭电视机和切换频道。显然，电视机遥控器就是一个典型的命令模式应用实例。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;抽象命令类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public interface AbstractCommand
{
    public void execute();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体的命令类：&lt;/p&gt;
&lt;p&gt;换台&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class TVChangeCommand implements AbstractCommand
{
    private Television tv;
    public TVChangeCommand()
    {
        tv = new Television();
    }
    public void execute()
    {
        tv.changeChannel();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关机&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class TVCloseCommand implements AbstractCommand
{
    private Television tv;
    public TVCloseCommand()
    {
        tv = new Television();
    }
    public void execute()
    {
        tv.close();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;开机&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class TVOpenCommand implements AbstractCommand
{
    private Television tv;
    public TVOpenCommand()
    {
        tv = new Television();
    }
    public void execute()
    {
        tv.open();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接收者Receiver类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Television
{
    public void open()
    {
        System.out.println(&quot;打开电视机！&quot;);
    }
    
    public void close()
    {
        System.out.println(&quot;关闭电视机！&quot;);       
    }
    
    public void changeChannel()
    {
        System.out.println(&quot;切换电视频道！&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用者(Invoker)类&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Controller
{
    private AbstractCommand openCommand,closeCommand,changeCommand;
    
    public Controller(AbstractCommand openCommand,AbstractCommand closeCommand,AbstractCommand changeCommand)
    {
        this.openCommand=openCommand;
        this.closeCommand=closeCommand;
        this.changeCommand=changeCommand;
    }
    
    public void open()
    {
        openCommand.execute();
    }
    
    public void change()
    {
        changeCommand.execute();
    }   

    public void close()
    {
         closeCommand.execute();    
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;五适用场景&quot;&gt;五、适用场景&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作。&lt;/li&gt;
&lt;li&gt;系统需要将一组操作组合在一起，即支持宏命令。&lt;/li&gt;
&lt;li&gt;系统需要在不同的时间指定请求、将请求排队和执行请求。&lt;/li&gt;
&lt;li&gt;系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Sat, 13 Apr 2019 13:44:00 +0000</pubDate>
<dc:creator>smileNicky</dc:creator>
<og:description>[TOC] 一、模式定义 命令模式(Command Pattern)：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分离，两者之间通过命令对象进行沟通，方便将命令对象进行储存、传递、调用、</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mzq123/p/10703070.html</dc:identifier>
</item>
<item>
<title>你可以不够聪明，但不能没有热爱 - 美码师</title>
<link>http://www.cnblogs.com/littleatp/p/10703011.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/littleatp/p/10703011.html</guid>
<description>&lt;h2 id=&quot;老兵的十年职场之路三&quot;&gt;老兵的十年职场之路(三)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;前文再续&lt;/strong&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/littleatp/p/10587932.html&quot;&gt;老兵的十年职场之路(一)&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/littleatp/p/10645408.html&quot;&gt;老兵的十年职场之路(二)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在前面的文章里，如果说第二段经历是我的小高峰，那么接下来我觉得算是一段平峰期吧。至少在技术成长上面是如此，而财富积累更是进入了黯淡期。&lt;br/&gt;有个词说的好，&lt;strong&gt;遇强则强&lt;/strong&gt;，当你所在的环境让你感到不适的时候，可能就是你成长的时候，当然也可能并不是。但如果你身边都是比你牛的人时，你一定会有很多提升的机会。&lt;/p&gt;
&lt;p&gt;在开始创业之后，我感受到了前所未有的自由，上班不打卡，用什么技术也都是自己说了算，产品呢，也都会自己去做些研究。所有的一切全凭着兴趣和热忱在支撑着。&lt;br/&gt;至于在我后来做自我检讨的时候觉得，对于创业来说这还是远远不够的，有太多的东西会让这些消失殆尽了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201904/242916-20190413212715098-982088589.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;创业团队&quot;&gt;创业团队&lt;/h2&gt;
&lt;p&gt;一个机缘巧合，几位同事跟我组成了一个开发团队，主要想做的是一款开放式的项目管理平台，团队里有一个前端加两个后端程序员，当然我是后端之一，并且主要负责了项目的开发框架搭建及技术把控。也是因为是初次创业吧，基本上大家都是卯足了劲，想着怎么更快的把产品给做出来。当时也没有所谓的 996制度之说，因为基本上除了吃饭睡觉就是写代码了，时间变得很不规律。然后就是项目中出了不少的问题，比如产品定义不清晰，技术选型及实现上产生一些争执等等，这些问题都&lt;strong&gt;体现了作为初创团队的各种不成熟&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;当然，最为关键的可能还是团队对市场的缺乏思考，总希望做一个大而全的东西，因此没过多久，这个项目就夭折了。&lt;br/&gt;与此同时，一位朋友的公司找到我们，希望帮他们完成一个移动外包项目，这时候，为了能继续下去，我们就开始了一边外包，而另一边则做自主产品的日子。&lt;/p&gt;
&lt;h2 id=&quot;摸爬滚打&quot;&gt;摸爬滚打&lt;/h2&gt;
&lt;p&gt;接下来的一段日子里，团队过的非常的辛苦，如果要用最合适的词来形容的话，我只想到了&lt;strong&gt;摸爬滚打这四个字&lt;/strong&gt;。因为一旦进入外包的节奏之后，团队几乎迈入了一个持续的恶性循环中，为了养活团队就得不停的接单，为了完成这些项目你几乎就没有时间精力能进行自主产品的开发。&lt;br/&gt;尽管有些项目看着很大，但其实是多手转包，在支付周期上很容易就把你拖死。&lt;/p&gt;
&lt;h3 id=&quot;微营销的风&quot;&gt;微营销的风&lt;/h3&gt;
&lt;p&gt;然后是大约在2013年的时候，微信营销一度成了炙手可热的风口热点，基于微信公众号开放平台打造的各种营销平台也遍地开花了。那时候觉得这块可能是个突破口，于是也做了一个微营销的产品，然后这也成了一次失败的尝试。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201904/242916-20190413212756867-74325491.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本质上这类产品的技术门槛并不高，不会涉及什么高并发高性能的一些问题，而整个后端基本上是基于微信的开放接口来实现就好，产品上唯一能产生一些识别度的都是一些前端和UI上的事情。很可惜的是，后来发现就是各家的微信营销平台的功能和界面都是&lt;strong&gt;我抄你，你抄我&lt;/strong&gt;，很难区分。&lt;br/&gt;既然技术上不能产生区分，那么这类产品就只能看怎么做好推广和资源整合了。&lt;/p&gt;
&lt;p&gt;最令人印象深刻的是有一次给一家餐厅做微信点餐的功能后，我们一伙人跑到了人家厨房里拍了很多照片，然后给每个餐桌上都贴上了二维码。&lt;br/&gt;而且，&lt;strong&gt;每次都能免费吃上厨师的自创甜点&lt;/strong&gt;…&lt;/p&gt;
&lt;p&gt;如果那会能碰上靠谱的推广合作伙伴兴许还能赚点钱，但我们的运气并不大好，在产品开发出来后只有寥寥可数的客户。&lt;br/&gt;而尽管微信营销很火，但市面上却很少有此类产品成功融资的消息，唯一有一个被认为是微营销领域佼佼者的产品融了100W，相信这也让许多人的心都凉了一截，相比同时期的一些移动互联网产品，这种平台却如此的不值钱。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;这恰如陈皓(左耳朵耗子)的博客里所说的，技术一定要关注价值点，如果都是伪造出来的需求，加上满大街都一样的东西，那可能就是供大于求，你的努力就很难获得回报。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;微信营销有多么火&lt;/strong&gt;&lt;br/&gt;有一次，邻居的一位阿婆问我工作在做什么，我想了一会，就说我的团队最近在做跟手机微信相关的系统。&lt;br/&gt;阿婆立刻就说，&lt;strong&gt;“你们是不是做微信营销，前段时间服装市场就有一个团队在搞微信营销呢，只是做了两个星期人就都散了…”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;那一刻我竟然无言以对，看吧，连老人家都知道微信营销了，确实是烂大街了。&lt;/p&gt;
&lt;p&gt;微营销的经历让人很难忘，而这些活下来的产品演化出了各种花样，就包括那些基于位置的精准营销，微信机器人等等。&lt;br/&gt;现在这些时不时会突然加你微信的美女头像大部分都是出自于营销系统。&lt;/p&gt;
&lt;h3 id=&quot;做不尽的外包&quot;&gt;做不尽的外包&lt;/h3&gt;
&lt;p&gt;外包是整个团队的收入来源，在微营销产品沉寂了之后，基本上我们都在接一些单子过活。在这个期间大大小小的项目接触了许多，大致可以分为下面几类：&lt;/p&gt;
&lt;ul readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;企业项目，这类项目的门槛最高，也就是拿到项目的条件非常苛刻。往往小团队拿到的都是一些模块级的部分，也就是底层框架或是平台接口都已经做好了，只有一些前端或是APP会交给外面的团队。而一般情况下企业对于项目质量，进度的审查方面会把控得很严格，经常需要人员驻场，这样对于创业人员的资源消耗非常的大。有时候你凭着能力提前完成了任务还不能走，企业的外包负责人会要求你一定要在办公室呆着。除此之外，企业项目转包的话在回款上都很拖沓，这令团队非常的难受。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;政府项目，相比企业级的项目来说，这类项目难度都较小，比较多的是一些传统型的系统，比如信息网站，公众号求助系统等等。但是获得这类项目机会需要借助一些资源，在审查方面的工作也得做到位了。很多项目是以招标的形式进行的，为了获得资质往往还得找一些同行进行抱团。当时所接触到的几个项目额度都不大，除了流程比较慢之外，其他方面都还比较顺利。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;创业项目，这类的项目最多，但也是&lt;strong&gt;风险最高&lt;/strong&gt;的。在移动互联网创业热潮中，有&lt;strong&gt;太多的人希望自己能缔造神话&lt;/strong&gt;了。而客户里面有许多来自于传统企业，也是因为如此，客户对于互联网的认识都很浅，提的许多需求点子都来自于一些火爆的产品，这可以用一个词来描述就是：&lt;strong&gt;混搭！&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;就比如，希望做一个熟人社交的产品，希望能搭上支付宝的贷款功能，一个商城APP里面要加个朋友圈，还有地图导航…&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201904/242916-20190413212947069-616443089.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了生存，所以许多项目都会先接下来，尤其是创业类的项目做了很多，基本上这类系统的架构都很简单，基本上是安卓APP一个、苹果APP一个 ，后端挂一个Java Web Server 就可以了。许多基础组件也都可以使用云上的服务，比如极光推送，友盟等，这样开发难度大大降低了。&lt;/p&gt;
&lt;p&gt;但尽管如此，因为同时进行的项目太多，开发团队总是&lt;strong&gt;负重累累&lt;/strong&gt;，最高峰的时候同时启动了8个项目，而开发人员却不足20人，而且团队里面有大量需要培养的应届生，这样一来质量和进度都没办法保证了。在这种状况下人员流动也非常的频繁，许多人干了两三个项目就要提离职了，尽管团队中也有一些比较好的苗子，但始终还是没能留住。&lt;br/&gt;这里提到了压力，人员流动，其中的根源还是来自&lt;strong&gt;成本模式的问题&lt;/strong&gt;。从当时的外包市场上看，团队能拿到的都以创业型项目为主，额度都较小，同时还要忍受来自对手的压价。为了养活团队则需要尽可能接下更多的单子，那么这样就会造成前面所说的研发压力过载，于是乎就会产生许多质量问题，这些都需要&lt;strong&gt;开发团队在后面去兜底&lt;/strong&gt;，长期持续下来就成了恶性循环。&lt;/p&gt;
&lt;h2 id=&quot;辗转&quot;&gt;辗转&lt;/h2&gt;
&lt;p&gt;这些糟糕的状况大约持续了近两年，之后我选择退出，主要的原因还是来源于自己，一方面这段时期内自己基本上没有了收入上的积累，另一方面则是对于自身成长上的焦虑，的确项目是做了非常多，也一直在承担着管理者的角色，但是在个人能力上觉得已经到了瓶颈。&lt;br/&gt;再者就是家里人对于我离职创业这件事情无法理解，也是因为这个事情跟家里的关系闹僵了。&lt;br/&gt;&lt;strong&gt;在我觉得最困难的时候很难得到一些精神上的支持&lt;/strong&gt;，同时还意外发现自己产生了一些焦虑症。为了摆脱这些现状，自己决定去寻找一个新起点。&lt;/p&gt;
&lt;p&gt;在离开团队之后，我先是在一家小公司担任技术负责人，在那边负责开发了一套物联后台系统，主要用于服务其销售的穿戴类设备产品(十万级)。&lt;br/&gt;除了技术选型、架构设计与普通的Web 项目存在较大不同之外，这个也是我觉得会是未来持续增长的一个领域。&lt;br/&gt;只是后来由于市场销售及产品运作方面的问题，这块业务也很快走向了下坡，我也被迫撤离了。&lt;/p&gt;
&lt;h2 id=&quot;寻求深造&quot;&gt;寻求深造&lt;/h2&gt;
&lt;p&gt;此后的时间里，我面试了一些公司，其中不乏一些挂羊头卖狗肉的，但最终我还是去了一家大型企业的物联网业务部门，也就是现在所在的地方，想在这里边继续学习和深造。&lt;/p&gt;
&lt;p&gt;在进入这家公司之时，也听说过其狼性文化和一些混乱不堪的项目管理，其中一点就是加班多且会很累，连身边的朋友也很难理解我做这样的选择。&lt;br/&gt;当然，这些情况在后面的工作中都遇到了，但在适当的调整之后发现并不会造成很大的影响。关键的一点在于&lt;strong&gt;自己要知道为什么自己会做这个选择&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在过去的十年里，我经历了从技术到管理，再回归到技术的路线。而正如许多文章都提到的，技术人到了中年会有很多无奈，除了身体和技能的老化，你的生活压力也会骤增不少。&lt;br/&gt;虽然的确是如此，但是作为一名技术人来说，我认为只要&lt;strong&gt;长期的进行学习，保持住一种工匠精神&lt;/strong&gt;，那么大龄技术人的竞争力就一定还在。&lt;/p&gt;
&lt;p&gt;十年的感悟浓缩为一句：&lt;br/&gt;&lt;strong&gt;你可以不够聪明，但不能没有热爱&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201904/242916-20190413213001761-1748420783.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;(完)&lt;/p&gt;
</description>
<pubDate>Sat, 13 Apr 2019 13:30:00 +0000</pubDate>
<dc:creator>美码师</dc:creator>
<og:description>老兵的十年职场之路(三) 前文再续 '老兵的十年职场之路(一)' '老兵的十年职场之路(二)' 在前面的文章里，如果说第二段经历是我的小高峰，那么接下来我觉得算是一段平峰期吧。至少在技术成长上面是如此</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/littleatp/p/10703011.html</dc:identifier>
</item>
<item>
<title>Kaggle之路，与强者为伍——记Santander交易预测 - 落叶有声</title>
<link>http://www.cnblogs.com/fugeny/p/10702812.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fugeny/p/10702812.html</guid>
<description>&lt;h2 id=&quot;题目-description&quot;&gt;题目 Description&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;预测一个乘客在未来会不会交易，不计交易次数，只要有交易即为1，否则为0.&lt;/p&gt;
&lt;p&gt;Identify which customers will make a specific transaction in the future, irrespective of the amount of money transacted.&lt;/p&gt;
&lt;p&gt;You are provided with an anonymized dataset containing numeric feature variables, the binary &lt;code&gt;target&lt;/code&gt; column, and a string &lt;code&gt;ID_code&lt;/code&gt;column.&lt;/p&gt;
&lt;p&gt;The task is to predict the value of &lt;code&gt;target&lt;/code&gt; column in the test set.&lt;/p&gt;
&lt;h2 id=&quot;data&quot;&gt;Data&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;提供了 &lt;span class=&quot;math inline&quot;&gt;\(200k \times 202\)&lt;/span&gt; 的数据，200维的特征，通过EDA发现特征向量基本服从高斯分布，且各个变量之间是独立的，疑似经过 PCA 处理后的特征。target为0 和 1，其中处于1的占比为 0.1117，不平衡现象明显。&lt;/p&gt;
&lt;p&gt;测试集为 &lt;span class=&quot;math inline&quot;&gt;\(200k \times 201\)&lt;/span&gt;，含有一行ID，与200维数据。目标为预测该用户的target（0/1）&lt;/p&gt;
&lt;h2 id=&quot;nd-解决方法&quot;&gt;1nd 解决方法&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;discussion&lt;a href=&quot;https://www.kaggle.com/c/santander-customer-transaction-prediction/discussion/89003#latest-515846&quot;&gt;链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;共使用600个特征，使用agumentation技巧扩充数据集，2.1NN/1LGBM融合。&lt;/p&gt;
&lt;p&gt;magic特征为unique特征，作者称其通过EDA观察 LGB 树发现其只使用unique特征，从而注重挖掘数据的unique信息。并根据其出现次数构建了5个类别：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;value在 target=1 的train data中出现多次&lt;/li&gt;
&lt;li&gt;value在 target=0 的train data中出现多次&lt;/li&gt;
&lt;li&gt;value在 target=0和target=1 的 train data中都出现多次&lt;/li&gt;
&lt;li&gt;value在train data中只出现一次&lt;/li&gt;
&lt;li&gt;value在train data和test data（仅包含真实数据） 中都是unique&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;由此可以构建200个特征（对每个原始特征transform），另外200个特征是数值特征，其将test+data中的unique数据替换为特征的均值。在没有处理掉fake时，作者用前200个特征用LGBM取得了0.910LB（大致前进0.09），增加后200个特征后取得0.914LB。处理掉fake之后，用LGBM取得0.921LB。&lt;/p&gt;
&lt;p&gt;具体来说：作者使用10折交叉验证，并用不同的seed并在最后进行融合。采用augmentation技巧，即将同样target的行的特征进行shuffle后作为新的数据进行预测，对target=1的数据进行16次shuffle，对target=0的行进行4次shuffle，同时相应打上伪标签（test数据也被加入到里面进行训练，其中前2700个被设为1，后2000个作为0），用LGBM预测，0.92522 LB。&lt;/p&gt;
&lt;p&gt;作者同时训练了一个NN模型，将 val 特征的原始value，unique类与数值特征先映射到embedding，可以构建200个embeddings，然后将200个embedding加权平均在输入到一串全连接网络中导出最终输出。加权的思想类似与attention，加权权重为前置的一个独立NN模块，这样保证最终每个特征用同样的方式训练。训练时对每个batch进行独立的augmentation，结果为0.92497PB，再把 test 加入训练后，0.92546PB。大致扫了下作者的源码，NN的全连接为32层，频繁使用小量的dropout（0.08）和 BN 层。NN的好处是可以提取到特征之间的关系，以及特征内部数据之间的group关系，同时NN需要训练的超参数更少。&lt;/p&gt;
&lt;h2 id=&quot;nd-解决方法-1&quot;&gt;2nd 解决方法&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;discussion&lt;a href=&quot;https://www.kaggle.com/c/santander-customer-transaction-prediction/discussion/88939#latest-515844&quot;&gt;链接&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1. 移除fake测试集，保留100k的真实测试集，真实测试集的定义为其存在仅出现 1 次的特征，fake行是真实行拼凑起来的，会对结果造成影响。
2. 同时对训练集与测试集的各个特征进行标准化处理
3. 构建频率特征，按照小数点精度，构建4种频率特征
4. 将每一个原始特征与其频率特征取出来进行拼接，并增加类别特征（200个类别），构成新的训练集，在这种情况下相当于仅用原始一个特征来进行训练，而原始每个特征都是均等的（独立性假设）
5. 用 lightgbm 训练和预测
6. 将200个预测结果进行拼接，拼接公式见公式5
7. join真测试集的预测结果，将假测试集的结果置为0，进行提交&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该参赛队伍&lt;a href=&quot;https://github.com/KazukiOnodera/santander-customer-transaction-prediction/blob/master/py/990_2nd_place_solution_golf.py&quot;&gt;代码链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对 &lt;strong&gt;#1&lt;/strong&gt; 解释： &lt;strong&gt;magic&lt;/strong&gt;之一，在查看训练集与测试集的unique计数分布时，发现二者存在较大差距，所以测试集由真的测试集与假的测试集组成，假的测试集是防止用户进行LB Probe，真的测试集用来评分。假的测试集是真测试集拼凑的，所以特征不唯一，以此来排除它。运用该magic，大致可以从0.901提升到 LB 0.91，PB 0.907&lt;/p&gt;
&lt;p&gt;对 &lt;strong&gt;#4&lt;/strong&gt; 解释：用单个特征来进行预测，可以有更多的训练数据（&lt;span class=&quot;math inline&quot;&gt;\(200k \times 200\)&lt;/span&gt; 行），训练时对单个特征的关注度也更高，个人理解该方式与比赛期间的augmentation技巧类似。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;原始的单个特征为 value
通过 round+计数 扩展特征，最后再加上 特征类别（200个类别），形成的新的train数据为：
value, count_org, count_2, count_3, count_4, varnum ---&amp;gt; target
test数据集做同样处理&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对 &lt;strong&gt;#6&lt;/strong&gt; 解释：假设单个特征是依 target 独立的，也即满足下述假定：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ f(n)= \begin{cases} P({\bf x} \,|\, y=1)= \prod_i P(x_i \,|\, y=1) \\ P({\bf x} \,|\, y=0)= \prod_i P(x_i \,|\, y=0) \end{cases} \tag 1 \]&lt;/span&gt;&lt;br/&gt;我们的目标是由 &lt;span class=&quot;math inline&quot;&gt;\(P(y=1 \,|\, x_i)\)&lt;/span&gt; 导出 &lt;span class=&quot;math inline&quot;&gt;\(P(y=1 \,|\, {\bf x})\)&lt;/span&gt;，其中 &lt;span class=&quot;math inline&quot;&gt;\({\bf x} = \{x_1, x_2,\dots,x_{200}\}\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \zeta = \frac{P(y=1 \,|\, {\bf x})}{P(y=0 \,|\, {\bf x})} = \frac{P({\bf x} \,|\, y=1)\cdot P(y=1)}{P({\bf x} \,|\, y=0) \cdot P(y=0)}=\frac{P(y=1) \prod_i P(x_i \,|\, y=1)}{P(y=0) \prod_i P(x_i \,|\, y=0)} \tag 2 \]&lt;/span&gt;&lt;br/&gt;按照训练集的统计，可设&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \lambda = \frac {P(y=1)} {P(y=0)} = \frac 1 9 \tag 3 \]&lt;/span&gt;&lt;br/&gt;同时由朴素贝叶斯可知：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{align} &amp;amp;P(x_i \,|\, y=1) = \frac {P(y=1 \,|\, x_i) \cdot P(x_i)}{P(y=1)} \tag 4 \\ \zeta &amp;amp; =\frac 1 9 \cdot \prod_i \frac {P(y=1 \,|\, x_i) \cdot P(y=0)} {P(y=0 \,|\, x_i) \cdot P(y=1)} \\ &amp;amp; =\frac 1 9 \cdot \prod_i \frac {9 \cdot P(y=1 \,|\, x_i)} {P(y=0 \,|\, x_i)} \tag 5 \end{align} \]&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;nd-解决方法-2&quot;&gt;3nd 解决方法&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;先取出测试集fake 数据，再把train和fake拼接在一起，然后做特征工程，其使用了unique计数、密度（count平滑后的结果）、前二者相除，故共800维特征。用LGBM训练，取得0.9225 LB，作者观察到单用一些特征训练的auc接近0.5，对最终的结果没有什么帮助，所以采用 Lasso 来自动削减该类特征。CV时优化了reg_alpha， max_bin， learning_rate， num_leaves 4个参数。&lt;/p&gt;
&lt;p&gt;作者关键性的操作是用 CNN 进行二阶段的训练。将LGBM的预测结果作为一个特征加入到CNN中，对每个特征列保持相同的卷积核，最后再连一个全连接层，在NN里使用BN避免过拟合。最终平均7个CNN的结果作为最终结果。&lt;/p&gt;
&lt;h2 id=&quot;其它magic&quot;&gt;其它magic&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;有看到可以通过将特征列 groupby 后求 方差var，并将方差加减原特征构成新的特征，400维统一放入到 lgb 中训练，当同时考虑加减并消去 fake 后可以取得 0.922的成绩。其实是变相的count，因为在groupby之后，unique的数据方差为0，只有count数较大的值才会有方差，anyway，也是一个比较有趣的思路。&lt;/p&gt;
&lt;h2 id=&quot;收获&quot;&gt;收获&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;第一次尝试参赛，在末尾几天开始入场，自然没打算去取得好成绩，主要是疯狂去追 kernels 和看 Discussion，在比赛时段看和在结束之后看是两种不同的心态。在&lt;strong&gt;比赛结束之前&lt;/strong&gt;，大部分人是比较焦虑的，Discussion 里有很多人发言，但是你也不能确定他们的idea是不是对的，只能用自己的知识和实践去推断，在这一期间，务必要保证自己的理智，多尝试与创新，而不要被误导到去钻牛角尖！在&lt;strong&gt;比赛后&lt;/strong&gt;要做好比赛的回顾，因为比赛后有很多人会公布他们的思路和代码，这个时候就要去潜心学习下比你做的好的人的做法，反思不足，这样才能争取在之后的比赛中更进一步。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;最后推荐几个kernels：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;第一名的 &lt;a href=&quot;https://www.kaggle.com/fl2ooo/nn-wo-pseudo-1-fold-seed&quot;&gt;kernel链接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;号称actual winner的最早fake test提出者：&lt;a href=&quot;https://www.kaggle.com/yag320/list-of-fake-samples-and-public-private-lb-split&quot;&gt;kernel链接&lt;/a&gt; ，可以说比赛时注意到这个kernel，银牌不是问题了&lt;/li&gt;
&lt;li&gt;参赛期间看得一个&lt;a href=&quot;https://www.kaggle.com/hjd810/keras-lgbm-aug-feature-eng-sampling-prediction&quot;&gt;kernel&lt;/a&gt; ，里面包行augmentation，代码风格不错，读起来挺舒服，可以在此基础上做自己的修改与尝试&lt;/li&gt;
&lt;li&gt;第三名的 &lt;a href=&quot;https://www.kaggle.com/nawidsayed/lightgbm-and-cnn-3rd-place-solution&quot;&gt;kernel链接&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Sat, 13 Apr 2019 12:49:00 +0000</pubDate>
<dc:creator>落叶有声</dc:creator>
<og:description>8000多人的Kaggle比赛，寻找magic的比赛，Santander Customer Transaction Prediction前3名算法解读。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fugeny/p/10702812.html</dc:identifier>
</item>
<item>
<title>字体反爬 - 神一样了</title>
<link>http://www.cnblogs.com/shenyiyangle/p/10702693.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shenyiyangle/p/10702693.html</guid>
<description>&lt;h3&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;最近看到字体反爬，试了一下&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;东方财富网&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1581786/201904/1581786-20190413155736655-260747389.png&quot; alt=&quot;&quot; width=&quot;916&quot; height=&quot;366&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;数据内容是方块，右边style的font-family是stonefont，ctrl-F搜索，发现字体文件。&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1581786/201904/1581786-20190413161225540-1655664962.png&quot; alt=&quot;&quot; width=&quot;858&quot; height=&quot;259&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;清除network记录，换一个截至日期，network里只有三条请求，第一条js里有页面上的加载数据和字体类型&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;字体地址等，&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;第三条是字体文件。在源码ctrl-F搜索发现源码里同样有数据，内容和js里是一样的，感觉两种都可以爬。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1581786/201904/1581786-20190413161757998-1116133176.png&quot; alt=&quot;&quot; width=&quot;864&quot; height=&quot;196&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;用requests请求数据，抄一遍headers用post发送拿到数据，数字内容还是乱码，所以接下来需要把乱码改成能显示的数字&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;57&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;#把headers里的querystring抄到dada里用post发送&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;url=&quot;http://dcfm.eastmoney.com/em_mutisvcexpandinterface/api/js&quot;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;headers={&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&quot;Referer&quot;: &quot;http://data.eastmoney.com/bbsj/201903/yjbb.html&quot;,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;data={&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&quot;type&quot;: &quot;YJBB21_YJBB&quot;,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&quot;token&quot;: &quot;70f12f2f4f091e459a279469fe49eca5&quot;,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&quot;st&quot;: &quot;latestnoticedate&quot;,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&quot;sr&quot;: &quot;-1&quot;,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&quot;p&quot;: &quot;1&quot;,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&quot;ps&quot;: &quot;50&quot;,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&quot;js&quot;: &quot;var rIKyuApR={pages:(tp),data: (x),font:(font)}&quot;,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&quot;filter&quot;: &quot;(securitytypecode in ('058001001','058001002'))(reportdate=^2018-09-30^)&quot;,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&quot;rt&quot;: &quot;51838114&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;r=requests.post(url=url,headers=headers,data=data)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;r.encoding=r.apparent_encoding&lt;/span&gt;&lt;br/&gt;&lt;span&gt;print(r.text)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;r.encoding=r.apparent_encoding&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;print&lt;/span&gt;(r.text)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;#用jupyter打开比较方便&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;处理数据，把字符串变成python能处理的字典&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;org_data=r.text[r.text.index(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;):]
json_str &lt;/span&gt;= or_data.replace(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;data:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;data&quot;:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).replace(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;pages:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;pages&quot;:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).replace(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;font:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;font&quot;:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
json_data &lt;/span&gt;= json.loads(json_str)&lt;/span&gt;&lt;p&gt;&lt;span&gt;#拿到字体文件&lt;/span&gt;
&lt;/p&gt;&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;　font_url = json_data['font']['WoffUrl']&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;67.801202806549&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;处理结果：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1581786/201904/1581786-20190413185205608-1450568277.png&quot; alt=&quot;&quot; width=&quot;825&quot; height=&quot;214&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;关于字体&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　字体文件里记录有字形索引和字形的映射关系，保存在字体的cmap表里，有关&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;字体详细资料看下面链接：&lt;/strong&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/shenyiyangle/p/10700156.html&quot;&gt;https://www.cnblogs.com/shenyiyangle/p/10700156.html&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;乱码原因&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;我们在浏览器看到乱码是因为网站加载了自定义字体，字体字形dindex和glphy映射关系和默认字体的映射不一样，网站按照自定义字体里的映射关系来表示数据，而我们抓到的数据用默认字体解析，因为映射关系不同，网站的unicode索引指向默认字体里的其他字形，所以我们看到的数据是错的。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;解决方法&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;解决问题需要建一张关系表，如果字形不变可以让自定义字体的unicode索引与默认字符对应，然后用默认字符替换自定义字体的unicode索引，这样就能在页面上显示正常数据。&lt;/strong&gt;&lt;strong&gt;关系如下图：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1581786/201904/1581786-20190413180247724-2115815292.png&quot; alt=&quot;&quot; width=&quot;606&quot; height=&quot;237&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;找关系&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;用到了TTFont库，可以解析字体&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt;font = requests.get(font_url, headers=header, timeout=30&lt;span&gt;)
font_name &lt;/span&gt;= font_url.split(&quot;/&quot;)[-1]&lt;span&gt;
with codecs.open(font_name, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;wb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) as f:
　　f.write(font.content)
font_map &lt;/span&gt;= TTFont(font_name).getBestCmap()#用getBestCmap()可以得到字体index和glphy的映射关系&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;“”“{120: 'x',
 57960: 'bgldyy',
 57971: 'qqdwzl',
 58817: 'whyhyx',
 59299: 'wqqdzs',
 60397: 'zbxtdyc',
 60633: 'zwdxtdy',
 60650: 'zrwqqdl',
 61125: 'bdzypyc',
 62069: 'sxyzdxn',
 62669: 'nhpdjl'}”“”&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;font_map里的就是自定义字体索引和字形的关系，key是index，value表示字形。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;unicode代码就是字体index进行十六进制转化后将0X'替换成 '&amp;amp;#x'，font_map里的index转换成unicode如下：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;font_index = [hex(key).upper().replace(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0X&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;amp;#x&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) +&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; key &lt;span&gt;in&lt;/span&gt; font_map.keys()]&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;“”“['&amp;amp;#x78;',
 '&amp;amp;#xE268;',
 '&amp;amp;#xE273;',
 '&amp;amp;#xE5C1;',
 '&amp;amp;#xE7A3;',
 '&amp;amp;#xEBED;',
 '&amp;amp;#xECD9;',
 '&amp;amp;#xECEA;',
 '&amp;amp;#xEEC5;',
 '&amp;amp;#xF275;',
 '&amp;amp;#xF4CD;']”“”&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;上面代码得到了自定义字体的关系，还需要unicode索引和和默认字符的关系，东方财富网直接写在页面上了。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　font_mapping = json_data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;font&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;][&lt;span&gt;'&lt;/span&gt;&lt;span&gt;FontMapping&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  font_mapping = {i['code']: str(i['value']) for i in font_map}&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;”“”&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;{'&amp;amp;#xE268;': '7',
 '&amp;amp;#xE273;': '1',
 '&amp;amp;#xE5C1;': '9',
 '&amp;amp;#xE7A3;': '3',
 '&amp;amp;#xEBED;': '4',
 '&amp;amp;#xECD9;': '8',
 '&amp;amp;#xECEA;': '2',
 '&amp;amp;#xEEC5;': '0',
 '&amp;amp;#xF275;': '6',
 '&amp;amp;#xF4CD;': '5'}&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;”“”&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
replace_dict= {hex(k).upper().replace(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0X&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;amp;#x&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: str(font_mapping[hex(k).upper().replace(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0X&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;amp;#x&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;])&lt;span&gt;for&lt;/span&gt; k &lt;span&gt;in&lt;/span&gt;&lt;span&gt; font_map.keys()}
“”“{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;amp;#x78;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
 &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;amp;#xE268;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
 &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;amp;#xE273;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
 &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;amp;#xE5C1;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
 &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;amp;#xE7A3;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
 &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;amp;#xEBED;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
 &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;amp;#xECD9;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
 &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;amp;#xECEA;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
 &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;amp;#xEEC5;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
 &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;amp;#xF275;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
 &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;amp;#xF4CD;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}”“”&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;#最后直接在文章中替换，key换成value。&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt; k, v &lt;span&gt;in&lt;/span&gt; replace_dict.items(): 　　&lt;br/&gt;　　json_str = json_str.replace(k, v) &lt;br/&gt;finall_data = json.loads(json_str)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1581786/201904/1581786-20190413185028523-391376649.png&quot; alt=&quot;&quot; width=&quot;404&quot; height=&quot;369&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;已得到正确数字了。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;最后筛选需要的字段筛选数据并将数据存入数据库，导出数据保存成csv用excel打开结果。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1581786/201904/1581786-20190413190615493-1740607220.png&quot; alt=&quot;&quot; width=&quot;986&quot; height=&quot;241&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 13 Apr 2019 12:14:00 +0000</pubDate>
<dc:creator>神一样了</dc:creator>
<og:description>最近看到字体反爬，试了一下东方财富网 数据内容是方块，右边style的font-family是stonefont，ctrl-F搜索，发现字体文件。 清除network记录，换一个截至日期，networ</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shenyiyangle/p/10702693.html</dc:identifier>
</item>
<item>
<title>搞懂Redis RDB和AOF持久化及工作原理 - GrimMjx</title>
<link>http://www.cnblogs.com/GrimMjx/p/10695512.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/GrimMjx/p/10695512.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;　　因为Redis的数据都储存在内存中，&lt;span&gt;当进程退出时，所有数据都将丢失。&lt;/span&gt;为了保证数据安全，Redis支持&lt;span&gt;RDB&lt;/span&gt;和&lt;span&gt;AOF&lt;/span&gt;两种持久化机制有效避免数据丢失问题。RDB可以看作在某一时刻Redis的快照（snapshot），非常适合灾难恢复。AOF则是写入操作的日志。本文主要讲解RDB、AOF和混合结合使用。&lt;/p&gt;

&lt;h2&gt;一.探索RDB&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;RDB就像是一台给Redis内存数据存储拍照的照相机，生成快照保存到磁盘的过程。&lt;/span&gt;触发RDB持久化分为手动触发和自动触发。Redis重启读取RDB速度快，但是无法做到实时持久化，因此一般用于&lt;span&gt;数据冷备&lt;/span&gt;和&lt;span&gt;复制传输&lt;/span&gt;。&lt;/p&gt;
&lt;h3&gt;手动触发&lt;/h3&gt;
&lt;p&gt;　　使用save命令：此命令会使用Redis的主线程进程同步存储，&lt;span&gt;阻塞当前的Redis服务器，造成服务不可用，直到RDB过程完成。&lt;/span&gt;无论当前服务器数据量大小，&lt;span&gt;线上不要用。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt; save
OK&lt;br/&gt;(1.14s)
&lt;/span&gt;&lt;span&gt;59117&lt;/span&gt;:M &lt;span&gt;13&lt;/span&gt; Apr &lt;span&gt;13&lt;/span&gt;:&lt;span&gt;34&lt;/span&gt;:&lt;span&gt;51.948&lt;/span&gt; * DB saved on disk
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　使用bgsave命令：此命令会通过fork()创建子进程，在后台进程存储。&lt;span&gt;只有fork阶段会阻塞当前Redis服务器，不必到整个RDB过程结束，一般时间很短。&lt;/span&gt;因此Redis内部涉及到RDB都采用bgsave命令。这里注意一点，无论RDB还是AOF，&lt;strong&gt;&lt;span&gt;由于使用了写时复制，fork出来的子进程不需要拷贝父进程的物理内存空间&lt;/span&gt;&lt;/strong&gt;，但是会复制父进程的空间内存页表。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt; bgsave
Background saving started
&lt;/span&gt;&lt;span&gt;59117&lt;/span&gt;:M &lt;span&gt;13&lt;/span&gt; Apr &lt;span&gt;13&lt;/span&gt;:&lt;span&gt;44&lt;/span&gt;:&lt;span&gt;40.312&lt;/span&gt; * Background saving started by pid &lt;span&gt;59180&lt;/span&gt;
&lt;span&gt;59180&lt;/span&gt;:C &lt;span&gt;13&lt;/span&gt; Apr &lt;span&gt;13&lt;/span&gt;:&lt;span&gt;44&lt;/span&gt;:&lt;span&gt;40.314&lt;/span&gt; *&lt;span&gt; DB saved on disk
&lt;/span&gt;&lt;span&gt;59117&lt;/span&gt;:M &lt;span&gt;13&lt;/span&gt; Apr &lt;span&gt;13&lt;/span&gt;:&lt;span&gt;44&lt;/span&gt;:&lt;span&gt;40.317&lt;/span&gt; * Background saving terminated with success
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;自动触发&lt;/h3&gt;
&lt;p&gt;　　一般我们是不会直接用命令生成RDB文件的，&lt;span&gt;Redis支持自动触发RDB持久化机制&lt;/span&gt;，配置都在&lt;span&gt;redis.conf&lt;/span&gt;文件里面，我们先来看一下文件里关于rdb的默认配置，这边都用红色字体标注出来了，英文的文档解释的十分清楚，注释也写的很不错。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;################################ SNAPSHOTTING  ################################
#
# Save the DB on disk:
#
#   save &lt;/span&gt;&amp;lt;seconds&amp;gt; &amp;lt;changes&amp;gt;&lt;span&gt;
#
#   Will save the DB &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; both the given number of seconds and the given
#   number of &lt;/span&gt;&lt;span&gt;write&lt;/span&gt;&lt;span&gt; operations against the DB occurred.
#
#   In the example below the behaviour will be to save:
#   after &lt;/span&gt;&lt;span&gt;900&lt;/span&gt; sec (&lt;span&gt;15&lt;/span&gt; min) &lt;span&gt;if&lt;/span&gt; at least &lt;span&gt;1&lt;/span&gt;&lt;span&gt; key changed
#   after &lt;/span&gt;&lt;span&gt;300&lt;/span&gt; sec (&lt;span&gt;5&lt;/span&gt; min) &lt;span&gt;if&lt;/span&gt; at least &lt;span&gt;10&lt;/span&gt;&lt;span&gt; keys changed
#   after &lt;/span&gt;&lt;span&gt;60&lt;/span&gt; sec &lt;span&gt;if&lt;/span&gt; at least &lt;span&gt;10000&lt;/span&gt;&lt;span&gt; keys changed
#
#   Note: you can disable saving completely by commenting out all &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;save&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; lines.
#
#   It is also possible to remove all the previously configured save
#   points by adding a save directive with a single empty &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt; argument
#   like &lt;/span&gt;&lt;span&gt;in&lt;/span&gt;&lt;span&gt; the following example:
#
#   save &lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;

save 900 1
save 300 10
save 60 10000&lt;/span&gt;&lt;span&gt;

# By default Redis will stop accepting writes &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; RDB snapshots are enabled
# (at least one save point) and the latest background save failed.
# This will &lt;/span&gt;&lt;span&gt;make&lt;/span&gt; the user aware (&lt;span&gt;in&lt;/span&gt;&lt;span&gt; a hard way) that data is not persisting
# on disk properly, otherwise chances are that no one will notice and some
# disaster will happen.
#
# If the background saving process will start working again Redis will
# automatically allow writes again.
#
# However &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; you have setup your proper monitoring of the Redis server
# and persistence, you may want to disable this feature so that Redis will
# continue to work as usual even &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; there are problems with disk,
# permissions, and so forth.
&lt;span&gt;stop&lt;/span&gt;&lt;/span&gt;&lt;span&gt;-writes-on-bgsave-&lt;/span&gt;&lt;span&gt;&lt;span&gt;error yes&lt;/span&gt;

# Compress &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; objects using LZF when dump .rdb databases?&lt;span&gt;
# For default that&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s set to &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;yes&lt;span&gt;'&lt;/span&gt;&lt;span&gt; as it&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s almost always a win.
# If you want to save some CPU &lt;/span&gt;&lt;span&gt;in&lt;/span&gt; the saving child set it to &lt;span&gt;'&lt;/span&gt;&lt;span&gt;no&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; but
# the dataset will likely be bigger &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; you have compressible values or keys.
&lt;span&gt;rdbcompression yes&lt;/span&gt;

# Since version &lt;/span&gt;&lt;span&gt;5&lt;/span&gt; of RDB a CRC64 checksum is placed at the end of the &lt;span&gt;file&lt;/span&gt;&lt;span&gt;.
# This makes the format &lt;/span&gt;&lt;span&gt;more&lt;/span&gt;&lt;span&gt; resistant to corruption but there is a performance
# hit to pay (around &lt;/span&gt;&lt;span&gt;10&lt;/span&gt;%&lt;span&gt;) when saving and loading RDB files, so you can disable it
# &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; maximum performances.
#
# RDB files created with checksum disabled have a checksum of zero that will
# tell the loading code to skip the check.
&lt;span&gt;rdbchecksum yes&lt;/span&gt;

# The filename where to dump the DB
&lt;span&gt;dbfilename dump.rdb&lt;/span&gt;

# The working directory.
#
# The DB will be written inside this directory, with the filename specified
# above using the &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;dbfilename&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; configuration directive.
#
# The Append Only File will also be created inside this directory.
#
# Note that you must specify a directory here, not a &lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt; name.
&lt;/span&gt;&lt;span&gt;dir /usr/local/var/db/redis/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;save m n：代表Redis服务器在m秒内数据存在n次修改时，自动触发rdb。这个参数比较关键。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;stop-writes-on-bgsave-error：如果是yes，当bgsave命令失败时Redis将停止写入操作。&lt;/li&gt;
&lt;li&gt;rdbcompression：是否对RDB文件进行压缩，但是在LZF压缩消耗更多CPU&lt;/li&gt;
&lt;li&gt;rdbchecksum：是否对RDB文件进程校验&lt;/li&gt;
&lt;li&gt;&lt;span&gt;dbfilename：配置文件名称，默认dump.rdb&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;dir：配置rdb文件存放的路劲，这个参数比较重要。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;工作原理&lt;/h3&gt;
&lt;p&gt;　　首先我们来看一下server.h文件内saveparams参数，可以看到，seconds就是秒数，changes就是改变量。是不是就&lt;span&gt;对应着刚刚说的save m n的配置&lt;/span&gt;呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; redisServer {
    ....
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; saveparam *saveparams;   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Save points array for RDB &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    ...
};

&lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; saveparam {
    time_t seconds;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; changes;
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　接下来我们看这个redis.c文件，有个周期性函数，叫做&lt;span&gt;serverCron&lt;/span&gt;，它会周期调用，大概做这几件事情，见注释。用红色标注的说明会触发bgsave和aof rewrite。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; This is our timer interrupt, called server.hz times per second.
 * Here is where we do a number of things that need to be done asynchronously.
 * For instance:
 *
 * - Active expired keys collection (it is also performed in a lazy way on
 *   lookup).
 * - Software watchdog.
 * - Update some statistic.
 * - Incremental rehashing of the DBs hash tables.
&lt;span&gt; * - Triggering BGSAVE / AOF rewrite, and handling of terminated children.&lt;/span&gt;
 * - Clients timeout of different kinds.
 * - Replication reconnection.
 * - Many more...
 *
 * Everything directly called here will be called server.hz times per second,
 * so in order to throttle execution of things we want to do less frequently
 * a macro is used: run_with_period(milliseconds) { .... }
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;int&lt;/span&gt; serverCron(&lt;span&gt;struct&lt;/span&gt; aeEventLoop *eventLoop, &lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; id, &lt;span&gt;void&lt;/span&gt; *clientData) {
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在这个方法里面有这样一段代码，这边单独拿出来，这段代码的意思是&lt;span&gt;判断changes是否满足&lt;/span&gt;并执行save操作。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; If there is not a background saving/rewrite in progress check if
         * we have to save/rewrite now &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
         &lt;span&gt;for&lt;/span&gt; (j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; server.saveparamslen; j++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; saveparam *sp = server.saveparams+&lt;span&gt;j;

            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Save if we reached the given amount of changes,
             * the given amount of seconds, and if the latest bgsave was
             * successful or if, in case of an error, at least
             * CONFIG_BGSAVE_RETRY_DELAY seconds already elapsed. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (server.dirty &amp;gt;= sp-&amp;gt;changes &amp;amp;&amp;amp;&lt;span&gt;
                server.unixtime&lt;/span&gt;-server.lastsave &amp;gt; sp-&amp;gt;seconds &amp;amp;&amp;amp;&lt;span&gt;
                (server.unixtime&lt;/span&gt;-server.lastbgsave_try &amp;gt;&lt;span&gt;
                 CONFIG_BGSAVE_RETRY_DELAY &lt;/span&gt;||&lt;span&gt;
                 server.lastbgsave_status &lt;/span&gt;==&lt;span&gt; C_OK))
            {
                serverLog(LL_NOTICE,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d changes in %d seconds. Saving...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    sp&lt;/span&gt;-&amp;gt;changes, (&lt;span&gt;int&lt;/span&gt;)sp-&amp;gt;&lt;span&gt;seconds);
                &lt;span&gt;rdbSaveBackground(server.rdb_filename);
                &lt;/span&gt;&lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }
         }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　接着继续看这个方法的部分代码片段，在rdb.c文件里。&lt;span&gt;我们可以看到子进程名为&quot;redis-rdb-bgsave&quot;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; rdbSaveBackground(&lt;span&gt;char&lt;/span&gt; *&lt;span&gt;filename) {
    pid_t childpid;
    &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; start;

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (server.aof_child_pid != -&lt;span&gt;1&lt;/span&gt; || server.rdb_child_pid != -&lt;span&gt;1&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; C_ERR;

    server.dirty_before_bgsave &lt;/span&gt;=&lt;span&gt; server.dirty;
    server.lastbgsave_try &lt;/span&gt;=&lt;span&gt; time(NULL);

    start &lt;/span&gt;=&lt;span&gt; ustime();
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((&lt;span&gt;childpid = fork()&lt;/span&gt;) == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; retval;

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Child &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        closeListeningSockets(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;span&gt;        redisSetProcTitle(&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&quot;redis-rdb-bgsave&quot;&lt;/span&gt;&lt;span&gt;&lt;span&gt;);&lt;/span&gt;
        retval &lt;/span&gt;=&lt;span&gt; rdbSave(filename);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (retval ==&lt;span&gt; C_OK) {
            size_t private_dirty &lt;/span&gt;=&lt;span&gt; zmalloc_get_private_dirty();

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (private_dirty) {
                serverLog(LL_NOTICE,
                    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RDB: %zu MB of memory used by copy-on-write&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    private_dirty&lt;/span&gt;/(&lt;span&gt;1024&lt;/span&gt;*&lt;span&gt;1024&lt;/span&gt;&lt;span&gt;));
            }
        }
        exitFromChild((retval &lt;/span&gt;== C_OK) ? &lt;span&gt;0&lt;/span&gt; : &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　最后我们看一下RDB的运作流程图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1465200/201904/1465200-20190413150710994-650893113.png&quot; alt=&quot;&quot; width=&quot;525&quot; height=&quot;434&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;redis执行bgsave命令，Redis判断当前存在正在进行执行的子进程，如RDB/AOF子进程，存在bgsave命令直接返回&lt;/li&gt;
&lt;li&gt;fork出子进程，&lt;span&gt;fork操作中Redis父进程会阻塞&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;fork完成返回　　59117:M 13 Apr 13:44:40.312 * Background saving started by pid 59180&lt;/li&gt;
&lt;li&gt;子进程进程对内存数据生成快找文件&lt;/li&gt;
&lt;li&gt;子进程告诉父进程处理完成&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;探索RDB文件&lt;/h3&gt;
&lt;p&gt; 　　我们可以使用&lt;span&gt;redis-rdb-tools&lt;/span&gt;来分析rdb快照文件，他可以把rdb快照文件生成json文件，看起来比较方便。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
rdb -c memory dump.rdb &amp;gt; testMjx.csv
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后我们看下生成的文件长啥样&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;76&quot;&gt;
&lt;pre&gt;
&lt;span&gt;database,type,key,size_in_bytes,encoding,num_elements,len_largest_element,expiry
&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;string&lt;/span&gt;,mjx3,&lt;span&gt;56&lt;/span&gt;,&lt;span&gt;string&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;string&lt;/span&gt;,mjx5,&lt;span&gt;56&lt;/span&gt;,&lt;span&gt;string&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;string&lt;/span&gt;,mjx2,&lt;span&gt;56&lt;/span&gt;,&lt;span&gt;string&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;string&lt;/span&gt;,mjx,&lt;span&gt;48&lt;/span&gt;,&lt;span&gt;string&lt;/span&gt;,&lt;span&gt;8&lt;/span&gt;,&lt;span&gt;8&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;string&lt;/span&gt;,mjx4,&lt;span&gt;56&lt;/span&gt;,&lt;span&gt;string&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　生成的数据有database（key在Redis的db）、type（key类型）、key（key值）、size_in_bytes（key的内存大小）、encoding（value的存储编码形式）、num_elements（key中的value的个数）、len_largest_element（key中的value的长度）、超时时间。&lt;/p&gt;
&lt;h3&gt;优缺点&lt;/h3&gt;
&lt;p&gt;　　RDB持久化方式的优点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;非常适合&lt;span&gt;全量备份&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;恢复速度比AOF快&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　RDB持久化方式的缺点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;RDB方式&lt;span&gt;没有办法做到实时持久化&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;版本兼容RDB格式问题&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;二.探索AOF&lt;/h2&gt;
&lt;p&gt; 　　RDB方式不能提供强一致性，如果Redis进程崩溃，那么&lt;span&gt;两次RDB之间的数据也随之消失&lt;/span&gt;。那么AOF的出现很好的解决了数据持久化的实时性，AOF以独立日志的方式记录每次写命令，重启时再重新执行AOF文件中的命令来恢复数据。&lt;strong&gt;&lt;span&gt;AOF会先把命令追加在AOF缓冲区，然后根据对应策略写入硬盘（appendfsync）&lt;/span&gt;&lt;/strong&gt;，具体参数后面有讲。接下来介绍一下&lt;span&gt;AOF重写命令&lt;/span&gt;。&lt;/p&gt;
&lt;h3&gt;手动触发&lt;/h3&gt;
&lt;p&gt;　　使用bgrewriteaof命令：&lt;span&gt;Redis主进程fork子进程来执行AOF重写，这个子进程创建新的AOF文件来存储重写结果，防止影响旧文件。&lt;strong&gt;因为fork采用了写时复制机制，子进程不能访问在其被创建出来之后产生的新数据。&lt;/strong&gt;Redis使用“&lt;/span&gt;&lt;span&gt;&lt;strong&gt;AOF重写缓冲区&lt;/strong&gt;”保存这部分新数据，最后父进程将AOF重写缓冲区的数据写入新的AOF文件中然后使用新AOF文件替换老文件。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt; bgrewriteoaf
OK&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;自动触发&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　和RDB一样，配置在redis.conf文件里，当然你也可以通过调用CONFIG SET命令设置。我们先看来看AOF相关配置：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt;############################## APPEND ONLY MODE ###############################

# By default Redis asynchronously dumps the dataset on disk. This mode is
# good enough &lt;/span&gt;&lt;span&gt;in&lt;/span&gt;&lt;span&gt; many applications, but an issue with the Redis process or
# a power outage may result into a few minutes of writes lost (depending on
# the configured save points).
#
# The Append Only File is an alternative persistence mode that provides
# much better durability. For instance using the default data fsync policy
# (see later &lt;/span&gt;&lt;span&gt;in&lt;/span&gt; the config &lt;span&gt;file&lt;/span&gt;) Redis can lose just one second of writes &lt;span&gt;in&lt;/span&gt;&lt;span&gt; a
# dramatic event like a server power outage, or a single &lt;/span&gt;&lt;span&gt;write&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; something
# wrong with the Redis process itself happens, but the operating system is
# still running correctly.
#
# AOF and RDB persistence can be enabled at the same &lt;/span&gt;&lt;span&gt;time&lt;/span&gt;&lt;span&gt; without problems.
# If the AOF is enabled on startup Redis will load the AOF, that is the &lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt;
# with the better durability guarantees.
#
# Please check http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;redis.io/topics/persistence for more information.&lt;/span&gt;
&lt;span&gt;&lt;span&gt;
appendonly no&lt;/span&gt;

# The name of the append only &lt;/span&gt;&lt;span&gt;file&lt;/span&gt; (default: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;appendonly.aof&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

&lt;span&gt;appendfilename &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&quot;appendonly.aof&quot;&lt;/span&gt;&lt;span&gt;

# The fsync() call tells the Operating System to actually &lt;/span&gt;&lt;span&gt;write&lt;/span&gt;&lt;span&gt; data on disk
# instead of waiting &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; &lt;span&gt;more&lt;/span&gt; data &lt;span&gt;in&lt;/span&gt;&lt;span&gt; the output buffer. Some OS will really flush
# data on disk, some other OS will just try to &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt; it ASAP.
#
# Redis supports three different modes:
#
# no: don&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;t fsync, just let the OS flush the data when it wants. Faster.&lt;/span&gt;
# always: fsync after every &lt;span&gt;write&lt;/span&gt;&lt;span&gt; to the append only log. Slow, Safest.
# everysec: fsync only one &lt;/span&gt;&lt;span&gt;time&lt;/span&gt;&lt;span&gt; every second. Compromise.
#
# The default is &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;everysec&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, as that&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s usually the right compromise between&lt;/span&gt;
# speed and data safety. It&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s up to you to understand if you can relax this to&lt;/span&gt;
# &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;no&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; that will let the operating system flush the output buffer when
# it wants, &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; better performances (but &lt;span&gt;if&lt;/span&gt;&lt;span&gt; you can live with the idea of
# some data loss consider the default persistence mode that&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s snapshotting),&lt;/span&gt;
# or on the contrary, use &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;always&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; that&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s very slow but a bit safer than&lt;/span&gt;
&lt;span&gt;# everysec.
#
# More details please check the following article:
# http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;antirez.com/post/redis-persistence-demystified.html&lt;/span&gt;
&lt;span&gt;#
# If unsure, use &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;everysec&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.

# appendfsync always
&lt;span&gt;appendfsync everysec&lt;/span&gt;
# appendfsync no

# When the AOF fsync policy is set to always or everysec, and a background
# saving process (a background save or AOF log background rewriting) is
# performing a lot of I&lt;/span&gt;/O against the disk, &lt;span&gt;in&lt;/span&gt;&lt;span&gt; some Linux configurations
# Redis may block too &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; on the fsync() call. Note that there is no fix &lt;span&gt;for&lt;/span&gt;&lt;span&gt;
# this currently, as even performing fsync &lt;/span&gt;&lt;span&gt;in&lt;/span&gt;&lt;span&gt; a different thread will block
# our synchronous &lt;/span&gt;&lt;span&gt;write&lt;/span&gt;(&lt;span&gt;2&lt;/span&gt;&lt;span&gt;) call.
#
# In order to mitigate this problem it&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s possible to use the following option&lt;/span&gt;
# that will prevent fsync() from being called &lt;span&gt;in&lt;/span&gt; the main process &lt;span&gt;while&lt;/span&gt;&lt;span&gt; a
# BGSAVE or BGREWRITEAOF is &lt;/span&gt;&lt;span&gt;in&lt;/span&gt;&lt;span&gt; progress.
#
# This means that &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; another child is saving, the durability of Redis is
# the same as &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;appendfsync none&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;. In practical terms, this means that it is
# possible to lose up to &lt;/span&gt;&lt;span&gt;30&lt;/span&gt; seconds of log &lt;span&gt;in&lt;/span&gt;&lt;span&gt; the worst scenario (with the
# default Linux settings).
#
# If you have latency problems turn this to &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yes&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;. Otherwise leave it as
# &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;no&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; that is the safest pick from the point of view of durability.

&lt;span&gt;no&lt;/span&gt;&lt;/span&gt;&lt;span&gt;-appendfsync-on-&lt;/span&gt;&lt;span&gt;&lt;span&gt;rewrite no&lt;/span&gt;

# Automatic rewrite of the append only &lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt;.
# Redis is able to automatically rewrite the log &lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt; implicitly calling
# BGREWRITEAOF when the AOF log size grows by the specified percentage.
#
# This is how it works: Redis remembers the size of the AOF &lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt; after the
# latest rewrite (&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; no rewrite has happened since the restart, the size of
# the AOF at startup is used).
#
# This base size is compared to the current size. If the current size is
# bigger than the specified percentage, the rewrite is triggered. Also
# you need to specify a minimal size &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; the AOF &lt;span&gt;file&lt;/span&gt;&lt;span&gt; to be rewritten, this
# is useful to avoid rewriting the AOF &lt;/span&gt;&lt;span&gt;file&lt;/span&gt; even &lt;span&gt;if&lt;/span&gt;&lt;span&gt; the percentage increase
# is reached but it is still pretty small.
#
# Specify a percentage of zero &lt;/span&gt;&lt;span&gt;in&lt;/span&gt;&lt;span&gt; order to disable the automatic AOF
# rewrite feature.

&lt;span&gt;auto&lt;/span&gt;&lt;/span&gt;&lt;span&gt;-aof-rewrite-percentage 100
auto-aof-rewrite-min-&lt;/span&gt;&lt;span&gt;&lt;span&gt;size 64mb&lt;/span&gt;

# An AOF &lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt; may be found to be truncated at the end during the Redis
# startup process, when the AOF data gets loaded back into memory.
# This may happen when the system where Redis is running
# crashes, especially when an ext4 filesystem is mounted without the
# data&lt;/span&gt;=ordered option (however this can&lt;span&gt;'&lt;/span&gt;&lt;span&gt;t happen when Redis itself&lt;/span&gt;
&lt;span&gt;# crashes or aborts but the operating system still works correctly).
#
# Redis can either exit with an error when this happens, or load as much
# data as possible (the default now) and start &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; the AOF &lt;span&gt;file&lt;/span&gt;&lt;span&gt; is found
# to be truncated at the end. The following option controls this behavior.
#
# If aof&lt;/span&gt;-load-truncated is set to yes, a truncated AOF &lt;span&gt;file&lt;/span&gt;&lt;span&gt; is loaded and
# the Redis server starts emitting a log to inform the user of the event.
# Otherwise &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; the option is set to no, the server aborts with an error
# and refuses to start. When the option is set to no, the user requires
# to fix the AOF &lt;/span&gt;&lt;span&gt;file&lt;/span&gt; using the &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;redis-check-aof&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; utility before to restart
# the server.
#
# Note that &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; the AOF &lt;span&gt;file&lt;/span&gt; will be found to be corrupted &lt;span&gt;in&lt;/span&gt;&lt;span&gt; the middle
# the server will still exit with an error. This option only applies when
# Redis will try to read &lt;/span&gt;&lt;span&gt;more&lt;/span&gt; data from the AOF &lt;span&gt;file&lt;/span&gt;&lt;span&gt; but not enough bytes
# will be found.
&lt;span&gt;aof&lt;/span&gt;&lt;/span&gt;&lt;span&gt;-load-&lt;/span&gt;&lt;span&gt;&lt;span&gt;truncated yes&lt;/span&gt;

# When rewriting the AOF &lt;/span&gt;&lt;span&gt;file&lt;/span&gt;, Redis is able to use an RDB preamble &lt;span&gt;in&lt;/span&gt;&lt;span&gt; the
# AOF &lt;/span&gt;&lt;span&gt;file&lt;/span&gt; &lt;span&gt;for&lt;/span&gt;&lt;span&gt; faster rewrites and recoveries. When this option is turned
# on the rewritten AOF &lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt; is composed of two different stanzas:
#
#   [RDB &lt;/span&gt;&lt;span&gt;file&lt;/span&gt;][AOF &lt;span&gt;tail&lt;/span&gt;&lt;span&gt;]
#
# When loading Redis recognizes that the AOF &lt;/span&gt;&lt;span&gt;file&lt;/span&gt; starts with the &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;REDIS&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
# &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; and loads the prefixed RDB &lt;span&gt;file&lt;/span&gt;&lt;span&gt;, and continues loading the AOF
# &lt;/span&gt;&lt;span&gt;tail&lt;/span&gt;&lt;span&gt;.
#
# This is currently turned off by default &lt;/span&gt;&lt;span&gt;in&lt;/span&gt;&lt;span&gt; order to avoid the surprise
# of a format change, but will at some point be used as the default.
&lt;span&gt;aof&lt;/span&gt;&lt;/span&gt;&lt;span&gt;-use-rdb-preamble no&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;appendonly：是否打开AOF持久化功能&lt;/li&gt;
&lt;li&gt;appendfilename：AOF文件名称&lt;/li&gt;
&lt;li&gt;appendfsync：同步频率&lt;/li&gt;
&lt;li&gt;&lt;span&gt;auto-aof-rewrite-min-size：如果文件大小小于此值不会触发AOF，默认64MB&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;auto-aof-rewrite-percentage：Redis记录最近的一次AOF操作的文件大小，如果当前AOF文件大小增长超过这个百分比则触发一次重写，默认100&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　&lt;span&gt;这里介绍一下appendfsync参数的可配置值&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;always：命令写入aof缓冲区后，每一次写入都需要同步，&lt;span&gt;直到写入磁盘（阻塞，系统调用fsync）结束后返回&lt;/span&gt;。显然和Redis高性能背道而驰，不建议配置&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;everysec：命令写入aof缓冲区后，&lt;span&gt;在写入系统缓冲区&lt;strong&gt;直接返回（系统调用write）&lt;/strong&gt;，然后有专门线程每秒执行写入磁盘（阻塞，系统调用fsync）后返回&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;no：命令写入aof缓冲区后，&lt;span&gt;在写入系统缓冲区&lt;strong&gt;直接返回&lt;/strong&gt;（系统调用write）&lt;/span&gt;&lt;/span&gt;。之后写入磁盘（阻塞，系统调用fsync）的操作由操作系统负责，&lt;span&gt;通常最长30s&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;工作原理&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　这里看一段aof.c的代码，&lt;span&gt;我们可以看到fork出名为&quot;redis-aof-rewrite&quot;的子进程&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; This is how rewriting of the append only file in background works:
 *
 * 1) The user calls BGREWRITEAOF
 * 2) Redis calls this function, that forks():
 *    2a) the child rewrite the append only file in a temp file.
 *    2b) the parent accumulates differences in server.aof_rewrite_buf.
 * 3) When the child finished '2a' exists.
 * 4) The parent will trap the exit code, if it's OK, will append the
 *    data accumulated into server.aof_rewrite_buf into the temp file, and
 *    finally will rename(2) the temp file in the actual file name.
 *    The the new file is reopened as the new append only file. Profit!
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; rewriteAppendOnlyFileBackground(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;) {
    pid_t childpid;
    &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; start;

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (server.aof_child_pid != -&lt;span&gt;1&lt;/span&gt; || server.rdb_child_pid != -&lt;span&gt;1&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; C_ERR;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (aofCreatePipes() != C_OK) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; C_ERR;
    start &lt;/span&gt;=&lt;span&gt; ustime();
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;(childpid = fork()&lt;/span&gt;) == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; tmpfile[&lt;span&gt;256&lt;/span&gt;&lt;span&gt;];

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Child &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        closeListeningSockets(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;span&gt;        redisSetProcTitle(&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&quot;redis-aof-rewrite&quot;&lt;/span&gt;&lt;span&gt;&lt;span&gt;);&lt;/span&gt;
        snprintf(tmpfile,&lt;/span&gt;&lt;span&gt;256&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;temp-rewriteaof-bg-%d.aof&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;) getpid());
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (rewriteAppendOnlyFile(tmpfile) ==&lt;span&gt; C_OK) {
            size_t private_dirty &lt;/span&gt;=&lt;span&gt; zmalloc_get_private_dirty();

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (private_dirty) {
                serverLog(LL_NOTICE,
                    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AOF rewrite: %zu MB of memory used by copy-on-write&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    private_dirty&lt;/span&gt;/(&lt;span&gt;1024&lt;/span&gt;*&lt;span&gt;1024&lt;/span&gt;&lt;span&gt;));
            }
            exitFromChild(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            exitFromChild(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
        }
    }&lt;br/&gt;...&lt;br/&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　同样我们也看一下AOF的运作流程图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1465200/201904/1465200-20190413190314966-1704443449.png&quot; alt=&quot;&quot; width=&quot;660&quot; height=&quot;573&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;所有的写入命令追加到&lt;span&gt;aof缓冲区&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;AOF缓冲区&lt;strong&gt;&lt;span&gt;根据对应appendfsync配置向硬盘做同步操作&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;定期对AOF文件进行重写&lt;/li&gt;
&lt;li&gt;Redis重启时，可以加载AOF文件进行数据恢复&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;探索AOF文件&lt;/h3&gt;
&lt;p&gt;　　首先打开aof功能&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt; CONFIG SET appendonly yes
OK

&lt;/span&gt;&lt;span&gt;59117&lt;/span&gt;:M &lt;span&gt;13&lt;/span&gt; Apr &lt;span&gt;19&lt;/span&gt;:&lt;span&gt;24&lt;/span&gt;:&lt;span&gt;53.940&lt;/span&gt; * Background append only &lt;span&gt;file&lt;/span&gt; rewriting started by pid &lt;span&gt;59895&lt;/span&gt;
&lt;span&gt;59117&lt;/span&gt;:M &lt;span&gt;13&lt;/span&gt; Apr &lt;span&gt;19&lt;/span&gt;:&lt;span&gt;24&lt;/span&gt;:&lt;span&gt;53.964&lt;/span&gt; *&lt;span&gt; AOF rewrite child asks to stop sending diffs.
&lt;/span&gt;&lt;span&gt;59895&lt;/span&gt;:C &lt;span&gt;13&lt;/span&gt; Apr &lt;span&gt;19&lt;/span&gt;:&lt;span&gt;24&lt;/span&gt;:&lt;span&gt;53.965&lt;/span&gt; *&lt;span&gt; Parent agreed to stop sending diffs. Finalizing AOF...
&lt;/span&gt;&lt;span&gt;59895&lt;/span&gt;:C &lt;span&gt;13&lt;/span&gt; Apr &lt;span&gt;19&lt;/span&gt;:&lt;span&gt;24&lt;/span&gt;:&lt;span&gt;53.965&lt;/span&gt; * Concatenating &lt;span&gt;0.00&lt;/span&gt; MB of AOF &lt;span&gt;diff&lt;/span&gt;&lt;span&gt; received from parent.
&lt;/span&gt;&lt;span&gt;59895&lt;/span&gt;:C &lt;span&gt;13&lt;/span&gt; Apr &lt;span&gt;19&lt;/span&gt;:&lt;span&gt;24&lt;/span&gt;:&lt;span&gt;53.966&lt;/span&gt; * SYNC append only &lt;span&gt;file&lt;/span&gt;&lt;span&gt; rewrite performed
&lt;/span&gt;&lt;span&gt;59117&lt;/span&gt;:M &lt;span&gt;13&lt;/span&gt; Apr &lt;span&gt;19&lt;/span&gt;:&lt;span&gt;24&lt;/span&gt;:&lt;span&gt;53.996&lt;/span&gt; *&lt;span&gt; Background AOF rewrite terminated with success
&lt;/span&gt;&lt;span&gt;59117&lt;/span&gt;:M &lt;span&gt;13&lt;/span&gt; Apr &lt;span&gt;19&lt;/span&gt;:&lt;span&gt;24&lt;/span&gt;:&lt;span&gt;53.996&lt;/span&gt; * Residual parent &lt;span&gt;diff&lt;/span&gt; successfully flushed to the rewritten AOF (&lt;span&gt;0.00&lt;/span&gt;&lt;span&gt; MB)
&lt;/span&gt;&lt;span&gt;59117&lt;/span&gt;:M &lt;span&gt;13&lt;/span&gt; Apr &lt;span&gt;19&lt;/span&gt;:&lt;span&gt;24&lt;/span&gt;:&lt;span&gt;53.997&lt;/span&gt; * Background AOF rewrite finished successfully
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后我们放一些数据，并执行bgrewriteaof命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt; CONFIG SET appendonly yes
OK
&lt;/span&gt;&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt; set miao &lt;span&gt;24&lt;/span&gt;&lt;span&gt;
OK
&lt;/span&gt;&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt; set miao &lt;span&gt;177&lt;/span&gt;&lt;span&gt;
OK
&lt;/span&gt;&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt; lpush mlist &lt;span&gt;1&lt;/span&gt;&lt;span&gt;
(integer) &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt; lpush mlist &lt;span&gt;2&lt;/span&gt;&lt;span&gt;
(integer) &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;
&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt; lpush mlist &lt;span&gt;3&lt;/span&gt;&lt;span&gt;
(integer) &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;
&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt; keys *
&lt;span&gt;1&lt;/span&gt;) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;miao&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mlist&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　接下来看一下aof文件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
*&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
$&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;
SELECT
$&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;0&lt;/span&gt;
*&lt;span&gt;3&lt;/span&gt;&lt;span&gt;
$&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;
SET
$&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;
miao
$&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;
&lt;span&gt;177&lt;/span&gt;
*&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
$&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;
SELECT
$&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;0&lt;/span&gt;
*&lt;span&gt;3&lt;/span&gt;&lt;span&gt;
$&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;
lpush
$&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;
mlist
$&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;1&lt;/span&gt;
*&lt;span&gt;3&lt;/span&gt;&lt;span&gt;
$&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;
lpush
$&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;
mlist
$&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;
*&lt;span&gt;3&lt;/span&gt;&lt;span&gt;
$&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;
lpush
$&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;
mlist
$&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这时候我们手动执行aof重写命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt; bgrewriteaof
Background append only &lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt; rewriting started

&lt;/span&gt;&lt;span&gt;59117&lt;/span&gt;:M &lt;span&gt;13&lt;/span&gt; Apr &lt;span&gt;19&lt;/span&gt;:&lt;span&gt;29&lt;/span&gt;:&lt;span&gt;31.017&lt;/span&gt; * &lt;span&gt;10&lt;/span&gt; changes &lt;span&gt;in&lt;/span&gt; &lt;span&gt;300&lt;/span&gt;&lt;span&gt; seconds. Saving...
&lt;/span&gt;&lt;span&gt;59117&lt;/span&gt;:M &lt;span&gt;13&lt;/span&gt; Apr &lt;span&gt;19&lt;/span&gt;:&lt;span&gt;29&lt;/span&gt;:&lt;span&gt;31.017&lt;/span&gt; * Background saving started by pid &lt;span&gt;59905&lt;/span&gt;
&lt;span&gt;59905&lt;/span&gt;:C &lt;span&gt;13&lt;/span&gt; Apr &lt;span&gt;19&lt;/span&gt;:&lt;span&gt;29&lt;/span&gt;:&lt;span&gt;31.020&lt;/span&gt; *&lt;span&gt; DB saved on disk
&lt;/span&gt;&lt;span&gt;59117&lt;/span&gt;:M &lt;span&gt;13&lt;/span&gt; Apr &lt;span&gt;19&lt;/span&gt;:&lt;span&gt;29&lt;/span&gt;:&lt;span&gt;31.120&lt;/span&gt; *&lt;span&gt; Background saving terminated with success
&lt;/span&gt;&lt;span&gt;59117&lt;/span&gt;:M &lt;span&gt;13&lt;/span&gt; Apr &lt;span&gt;19&lt;/span&gt;:&lt;span&gt;29&lt;/span&gt;:&lt;span&gt;49.409&lt;/span&gt; * Background append only &lt;span&gt;file&lt;/span&gt; rewriting started by pid &lt;span&gt;59906&lt;/span&gt;
&lt;span&gt;59117&lt;/span&gt;:M &lt;span&gt;13&lt;/span&gt; Apr &lt;span&gt;19&lt;/span&gt;:&lt;span&gt;29&lt;/span&gt;:&lt;span&gt;49.433&lt;/span&gt; *&lt;span&gt; AOF rewrite child asks to stop sending diffs.
&lt;/span&gt;&lt;span&gt;59906&lt;/span&gt;:C &lt;span&gt;13&lt;/span&gt; Apr &lt;span&gt;19&lt;/span&gt;:&lt;span&gt;29&lt;/span&gt;:&lt;span&gt;49.433&lt;/span&gt; *&lt;span&gt; Parent agreed to stop sending diffs. Finalizing AOF...
&lt;/span&gt;&lt;span&gt;59906&lt;/span&gt;:C &lt;span&gt;13&lt;/span&gt; Apr &lt;span&gt;19&lt;/span&gt;:&lt;span&gt;29&lt;/span&gt;:&lt;span&gt;49.434&lt;/span&gt; * Concatenating &lt;span&gt;0.00&lt;/span&gt; MB of AOF &lt;span&gt;diff&lt;/span&gt;&lt;span&gt; received from parent.
&lt;/span&gt;&lt;span&gt;59906&lt;/span&gt;:C &lt;span&gt;13&lt;/span&gt; Apr &lt;span&gt;19&lt;/span&gt;:&lt;span&gt;29&lt;/span&gt;:&lt;span&gt;49.434&lt;/span&gt; * SYNC append only &lt;span&gt;file&lt;/span&gt;&lt;span&gt; rewrite performed
&lt;/span&gt;&lt;span&gt;59117&lt;/span&gt;:M &lt;span&gt;13&lt;/span&gt; Apr &lt;span&gt;19&lt;/span&gt;:&lt;span&gt;29&lt;/span&gt;:&lt;span&gt;49.533&lt;/span&gt; *&lt;span&gt; Background AOF rewrite terminated with success
&lt;/span&gt;&lt;span&gt;59117&lt;/span&gt;:M &lt;span&gt;13&lt;/span&gt; Apr &lt;span&gt;19&lt;/span&gt;:&lt;span&gt;29&lt;/span&gt;:&lt;span&gt;49.533&lt;/span&gt; * Residual parent &lt;span&gt;diff&lt;/span&gt; successfully flushed to the rewritten AOF (&lt;span&gt;0.00&lt;/span&gt;&lt;span&gt; MB)
&lt;/span&gt;&lt;span&gt;59117&lt;/span&gt;:M &lt;span&gt;13&lt;/span&gt; Apr &lt;span&gt;19&lt;/span&gt;:&lt;span&gt;29&lt;/span&gt;:&lt;span&gt;49.534&lt;/span&gt; * Background AOF rewrite finished successfully
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后再看一下文件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
*&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
$&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;
SELECT
$&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;0&lt;/span&gt;
*&lt;span&gt;3&lt;/span&gt;&lt;span&gt;
$&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;
SET
$&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;
miao
$&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;
&lt;span&gt;177&lt;/span&gt;
*&lt;span&gt;5&lt;/span&gt;&lt;span&gt;
$&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;
RPUSH
$&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;
mlist
$&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;&lt;span&gt;
$&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
$&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　为什么AOF文件会变小？为了解决AOF文件会越来越大，Redis引入重写机制来缩小文件体积，体积变小因为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;多条写入命令可以合并成一条&lt;/span&gt;。比如上面的lpush命令了3次，最后合并成1条&lt;/li&gt;
&lt;li&gt;重写后AOF文件&lt;span&gt;只保留最终数据的写入命令&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;优缺点&lt;/h3&gt;
&lt;p&gt;　　AOF持久化方式的优点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;做到最多丢失1-2s内的数据（&lt;span&gt;最多丢失2s数据，因为&lt;strong&gt;AOF追加阻塞&lt;/strong&gt;&lt;/span&gt;）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　AOF持久化方式的缺点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;AOF文件比RDB文件大&lt;/li&gt;
&lt;li&gt;可能导致&lt;strong&gt;&lt;span&gt;追加阻塞&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;书籍参考和上文一样&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/huangxincheng/p/5010795.html&quot;&gt;https://www.cnblogs.com/huangxincheng/p/5010795.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 13 Apr 2019 12:01:00 +0000</pubDate>
<dc:creator>GrimMjx</dc:creator>
<og:description>前言 因为Redis的数据都储存在内存中，当进程退出时，所有数据都将丢失。为了保证数据安全，Redis支持RDB和AOF两种持久化机制有效避免数据丢失问题。RDB可以看作在某一时刻Redis的快照（</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/GrimMjx/p/10695512.html</dc:identifier>
</item>
<item>
<title>MySQL自定义函数与存储过程 - 秦无殇</title>
<link>http://www.cnblogs.com/webDepOfQWS/p/10691557.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/webDepOfQWS/p/10691557.html</guid>
<description>&lt;h3 id=&quot;前置条件&quot;&gt;1、前置条件&lt;/h3&gt;
&lt;p&gt;MySQL数据库中存在表user_info，其结构和数据如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; desc  user_info;
+-----------+----------+------+-----+---------+-------+
| Field     | Type     | Null | Key | Default | Extra |
+-----------+----------+------+-----+---------+-------+
| id        | int(10)  | NO   | PRI | NULL    |       |
| name      | char(20) | NO   |     | NULL    |       |
| passwd    | char(40) | NO   |     | NULL    |       |
| email     | char(20) | NO   |     | NULL    |       |
| phone     | char(20) | NO   |     | NULL    |       |
| role      | char(10) | NO   |     | NULL    |       |
| sex       | char(10) | NO   |     | NULL    |       |
| status    | int(10)  | NO   |     | NULL    |       |
| createAt  | datetime | NO   |     | NULL    |       |
| exprAt    | datetime | NO   |     | NULL    |       |
| validDays | int(10)  | NO   |     | NULL    |       |
| delAt     | datetime | YES  |     | NULL    |       |
+-----------+----------+------+-----+---------+-------+
12 rows in set (0.10 sec)

mysql&amp;gt; select  * from  user_info;
+----+--------------+----------+------------+-------------+--------+------+--------+---------------------+---------------------+-----------+-------+
| id | name         | passwd   | email      | phone       | role   | sex  | status | createAt            | exprAt              | validDays | delAt |
+----+--------------+----------+------------+-------------+--------+------+--------+---------------------+---------------------+-----------+-------+
|  1 | StephenWang7 | py123456 | 123@qq.com | 15103887470 | admin  | male |    200 | 2019-04-12 20:11:30 | 2019-04-19 20:11:30 |        30 | NULL  |
|  2 | StephenWang8 | 123456   | 123@qq.com | 15103887470 | viewer | male |    200 | 2019-04-12 20:11:30 | 2019-04-19 20:11:30 |        30 | NULL  |
+----+--------------+----------+------------+-------------+--------+------+--------+---------------------+---------------------+-----------+-------+
2 rows in set (0.00 sec)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;自定义函数&quot;&gt;2、自定义函数&lt;/h3&gt;
&lt;p&gt;函数：可以完成特定功能的一段SQL集合。MySQL支持自定义函数来完成特定的业务功能。&lt;br/&gt;创建自定义函数（User Defined Function 简称UDF）的语法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;create function &amp;lt;函数名称&amp;gt; （[参数1] [类型1], [参数N] [类型N]）
returns &amp;lt;类型&amp;gt;
return 
&amp;lt;函数主体&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用UDF的语法如下：&lt;br/&gt;&lt;code&gt;select &amp;lt;函数名称&amp;gt; ([参数])&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;创建无参的udf&quot;&gt;创建无参的UDF&lt;/h4&gt;
&lt;p&gt;示例1：查询user_info表中有多少条记录&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#定义函数
mysql&amp;gt; create function  user_info_count()
    -&amp;gt; returns int(10)
    -&amp;gt; return
    -&amp;gt; (select  count(*) from user_info);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用函数user_info_count()&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; select  user_info_count();
+-------------------+
| user_info_count() |
+-------------------+
|                 2 |
+-------------------+
1 row in set (0.00 sec)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;创建有参udf&quot;&gt;创建有参UDF&lt;/h4&gt;
&lt;p&gt;示例2：根据id查询用户name。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#定义函数
mysql&amp;gt; create function  queryNameById(uid int(10))
    -&amp;gt; returns char(20)
    -&amp;gt; return
    -&amp;gt; (select  name  from   user_info  where id=uid);
Query OK, 0 rows affected (0.01 sec)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用函数，查询id为1的用户名称。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; select  queryNameById(1);
+------------------+
| queryNameById(1) |
+------------------+
| StephenWang7     |
+------------------+
1 row in set (0.00 sec)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;查看udf&quot;&gt;查看UDF&lt;/h4&gt;
&lt;p&gt;查询系统中所有的UDF&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;show function status;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查询指定的UDF&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#
show   create function   函数名称;
mysql&amp;gt; show  function   queryNameById;
ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'queryNameById' at line 1
mysql&amp;gt; show  function   queryNameById();
ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'queryNameById()' at line 1
mysql&amp;gt; show   create function   queryNameById();
ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near '()' at line 1
mysql&amp;gt; show   create function   queryNameById;
+---------------+-------------------------------------------------------------------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------+----------------------+--------------------+
| Function      | sql_mode                                                                                                                                  | Create Function                                                                                                                                               | character_set_client | collation_connection | Database Collation |
+---------------+-------------------------------------------------------------------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------+----------------------+--------------------+
| queryNameById | ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION | CREATE DEFINER=`root`@`localhost` FUNCTION `queryNameById`(uid int(10)) RETURNS char(20) CHARSET latin1
return (select  name  from   user_info  where id=uid) | utf8                 | utf8_general_ci      | latin1_swedish_ci  |
+---------------+-------------------------------------------------------------------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------+----------------------+--------------------+
1 row in set (0.00 sec
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;修改udf&quot;&gt;修改UDF&lt;/h4&gt;
&lt;p&gt;如果想要修改函数的内容，先删除后再重新创建。&lt;/p&gt;
&lt;h4 id=&quot;删除udf&quot;&gt;删除UDF&lt;/h4&gt;
&lt;p&gt;删除UDF语法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;drop function  &amp;lt;函数名称&amp;gt;;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;示例3：删除函数queryNameId后再次调用并观察现象。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; drop  function queryNameById;
Query OK, 0 rows affected (0.45 sec)

mysql&amp;gt; select queryNameById(1);
ERROR 1305 (42000): FUNCTION rms.queryNameById does not exist
mysql&amp;gt; 

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;存储过程&quot;&gt;3、存储过程&lt;/h3&gt;
&lt;p&gt;存储功能和自定义函数相似，也是一组完成特定功能的SQL语句集合。把复杂或频繁调用的SQL提前写好并指定一个名称。待到要使用时，直接调用即可。&lt;br/&gt;定义存储过程的语法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;CREATE PROCEDURE &amp;lt;过程名&amp;gt; ( [过程参数[,…] ] ) &amp;lt;过程体&amp;gt;
[过程参数[,…] ] 格式
[ IN | OUT | INOUT ] &amp;lt;参数名&amp;gt; &amp;lt;类型&amp;gt;
#语法定义来自：http://c.biancheng.net/view/2593.html&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;创建无参的存储过程&quot;&gt;创建无参的存储过程&lt;/h4&gt;
&lt;p&gt;示例4：查询用户name。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; DELIMITER //
mysql&amp;gt; craete procedure queryName()
    -&amp;gt; begin
    -&amp;gt; select  name from user_info;
    -&amp;gt; end //&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关于DELIMITER命令，修改MySQL结束命令的字符。默认的结束命令字符为分号，当存储过程中包含多条语句时，遇到第一个分号会作为存储过程结束的标志。这样不符合预期，因此需要修改默认结束命令字符。 DELIMITER //就是将结束命令字符修改为//。调用存储过程的命令为：call 存储过程名称。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#此时的命令的结束符号为// 不是;
mysql&amp;gt; call  queryName()//
+--------------+
| name         |
+--------------+
| StephenWang7 |
| StephenWang8 |
+--------------+
2 rows in set (0.00 sec)

Query OK, 0 rows affected (0.00 sec)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;创建带参数的存储过程&quot;&gt;创建带参数的存储过程&lt;/h4&gt;
&lt;p&gt;示例5：根据id查询name。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; create procedure  queryNameById
    -&amp;gt; (In uid int(15))
    -&amp;gt; begin
    -&amp;gt; select  name  from  user_info where id=uid;
    -&amp;gt; end
    -&amp;gt; //
Query OK, 0 rows affected (0.03 sec)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用存储过程queryNameById&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; call queryNameById(1);
    -&amp;gt; //
+--------------+
| name         |
+--------------+
| StephenWang7 |
+--------------+
1 row in set (0.03 sec)

Query OK, 0 rows affected (0.04 sec)&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;修改存储过程&quot;&gt;修改存储过程&lt;/h4&gt;
&lt;p&gt;如果想创建存储过程的内容可以先删除再重新创建存储过程。&lt;/p&gt;
&lt;h4 id=&quot;查看存储过程&quot;&gt;查看存储过程&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;show create procedure &amp;lt;过程名称&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;mysql&amp;gt; show create procedure queryNameById; -&amp;gt; // +---------------+-------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------+----------------------+----------------------+--------------------+ | Procedure | sql_mode | Create Procedure | character_set_client | collation_connection | Database Collation | +---------------+-------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------+----------------------+----------------------+--------------------+ | queryNameById | ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION | CREATE DEFINER=`root`@`localhost` PROCEDURE `queryNameById`(In uid int(15)) begin select name from user_info where id=uid; end | utf8 | utf8_general_ci | latin1_swedish_ci | +---------------+-------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------+----------------------+----------------------+--------------------+ 1 row in set (0.04 sec)&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;删除存储过程&quot;&gt;删除存储过程&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;drop procedure &amp;lt;过程名称&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;删除存储过程queryNameById&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; drop procedure  queryNameById//
Query OK, 0 rows affected (0.02 sec)


mysql&amp;gt; call  queryNameById(1)//
ERROR 1305 (42000): PROCEDURE rms.queryNameById does not exist
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;总结&quot;&gt;4、总结&lt;/h3&gt;
&lt;p&gt;自定义函数和存储过程都是完成特定功能的SQL集合，那么他们有什么不同呢？&lt;br/&gt;a、调用方式不同&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#自定义函数
select  &amp;lt;函数名&amp;gt;
#存储过程
call &amp;lt;存储过程名&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;b、自定义函数不能有输出参数，而存储过程可以。&lt;br/&gt;c、自定义函数必须要包含return语句，而存储过程则不需要。&lt;/p&gt;
</description>
<pubDate>Sat, 13 Apr 2019 12:01:00 +0000</pubDate>
<dc:creator>秦无殇</dc:creator>
<og:description>MySQL自定义函数的创建与使用；存储过程的创建与调用。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/webDepOfQWS/p/10691557.html</dc:identifier>
</item>
</channel>
</rss>