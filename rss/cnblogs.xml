<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>kubernetes之PDB - 周国通</title>
<link>http://www.cnblogs.com/tylerzhou/p/10987576.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tylerzhou/p/10987576.html</guid>
<description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/tylerzhou/p/10969041.html&quot;&gt;系列目录&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上一节我们讲到了由于一些人为的或者不可避免的原因,pod可能会中断,而使用&lt;code&gt;Pod Disruption Budget&lt;/code&gt;可以最大限度地保证在pod中断发生时集群仍然保持能够接受的状态.&lt;/p&gt;
&lt;p&gt;一句话,PDB能够限制同时中断的pod的数量,以保证集群的高可用性.&lt;/p&gt;
&lt;h2 id=&quot;使用poddisruptionbudget来保护集群&quot;&gt;使用PodDisruptionBudget来保护集群&lt;/h2&gt;
&lt;p&gt;1) 确定你想要使用&lt;code&gt;PodDisruptionBudget (PDB)&lt;/code&gt;来保护的集群&lt;/p&gt;
&lt;p&gt;2) 考虑集群如何影响中断&lt;/p&gt;
&lt;p&gt;3) 使用yaml文件创建PDB定义&lt;/p&gt;
&lt;p&gt;4) 使用yaml文件创建PDB对象&lt;/p&gt;
&lt;h2 id=&quot;确定想要保护的应用对象&quot;&gt;确定想要保护的应用对象&lt;/h2&gt;
&lt;p&gt;最常见的要保护的对象是是以下kubernetes内置的controller创建的应用对象之一:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Deployment&lt;/li&gt;
&lt;li&gt;ReplicationController&lt;/li&gt;
&lt;li&gt;ReplicaSet&lt;/li&gt;
&lt;li&gt;StatefulSet&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;考虑集群如何响应中断&quot;&gt;考虑集群如何响应中断&lt;/h2&gt;
&lt;p&gt;决定在短时间内有多少个实例可能会被宕掉(由于自愿中断,前面一节我们讲到过何为自愿中断,非自愿中断不被PDB控制)&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;无状态的前端&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;关注点:服务能力不能减少超过10%&lt;/p&gt;
&lt;p&gt;解决方案: 使用一个包含&lt;code&gt;minAvailable 90%&lt;/code&gt;值的PDB&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;单实例有状态应用&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;关注点:不要在不知情情况下中断&lt;/p&gt;
&lt;p&gt;可能的解决方案1:不使用PDB,容易偶尔的宕机&lt;/p&gt;
&lt;p&gt;可能的解决方案2:使用PDB,设置&lt;code&gt;maxUnavailable=0&lt;/code&gt;.当集群管理员想要终止pod的时候,他需要联系你,然后删除掉PDB以准备应对中断,然后重新创建.(如果maxUnavailable=0则不能进行自愿中断操作)&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;多实例有状态应用,例如zookeeper,etcd,consul等&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;关注点:运行的实例数不能低于法定数量&lt;/p&gt;
&lt;p&gt;可能的解决方案1:把maxUnavailable to 1(根据不同集群要求不同,可以设置为不同的值)&lt;br/&gt;可能的解决方案2:把minAvailable设置为法定数量.&lt;/p&gt;
&lt;h2 id=&quot;指定一个poddisruptionbudget&quot;&gt;指定一个PodDisruptionBudget&lt;/h2&gt;
&lt;p&gt;一个PDB有三个字段:&lt;/p&gt;
&lt;p&gt;1) 一个label选择器&lt;code&gt;.spec.selector&lt;/code&gt;,用来指定要选择的pod集合,此为必选项&lt;/p&gt;
&lt;p&gt;2) &lt;code&gt;.spec.minAvailable&lt;/code&gt;,在pod被驱离的情况下,必须保证的最小可用的pod数量.&lt;code&gt;minAvailable&lt;/code&gt;可以是一个绝对数值或者一个百分数&lt;/p&gt;
&lt;p&gt;3) &lt;code&gt;.spec.maxUnavailable&lt;/code&gt;(kubernetes 1.7以后版本),在发生驱离的情况下,最大的不可用副本的数量,值可以是绝对数值或者一个百分比.&lt;/p&gt;
&lt;p&gt;在一个PDB定义中,只能指定&lt;code&gt;minAvailable&lt;/code&gt;或&lt;code&gt;maxUnavailable&lt;/code&gt;其一.&lt;code&gt;maxUnavailable&lt;/code&gt;中能用于有控制器控制的pod的驱离.&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;maxUnavailable 值为 0% (或 0),或者minAvailable值为100%(或者与replicas的值相等)则会完全阻止pod驱离.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以下示例的PDB会选择labels值包含&lt;code&gt;app: zookeeper&lt;/code&gt;的pod&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用&lt;code&gt;minAvailable&lt;/code&gt;的示例&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;yml&quot;&gt;
&lt;code&gt;apiVersion: policy/v1beta1
kind: PodDisruptionBudget
metadata:
  name: zk-pdb
spec:
  minAvailable: 2
  selector:
    matchLabels:
      app: zookeeper&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;使用&lt;code&gt;maxUnavailable&lt;/code&gt;的示例&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;yml&quot;&gt;
&lt;code&gt;apiVersion: policy/v1beta1
kind: PodDisruptionBudget
metadata:
  name: zk-pdb
spec:
  maxUnavailable: 1
  selector:
    matchLabels:
      app: zookeeper&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例如以上&lt;code&gt;zk-pdb&lt;/code&gt;对象选择了一个pod数量为3的有状态集合,上面两种定义意义完全相同,推荐使用&lt;code&gt;maxUnavailable&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;创建pdb对象&quot;&gt;创建PDB对象&lt;/h2&gt;
&lt;p&gt;你可以使用&lt;code&gt;kubectl apply -f xxx.yaml&lt;/code&gt;来创建一个PDB对象&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;PDB对象不能被更新,你只能够删除它然后重新创建.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;检测ｐｄｂ的状态&quot;&gt;检测ＰＤＢ的状态&lt;/h2&gt;
&lt;p&gt;使用kubectl来检测pdb是否被创建.&lt;/p&gt;
&lt;p&gt;假设没有pod匹配&lt;code&gt;app: zookeeper&lt;/code&gt;,你将会看到如下信息&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;kubectl get poddisruptionbudgets&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;NAME      MIN-AVAILABLE   ALLOWED-DISRUPTIONS   AGE
zk-pdb    2               0                     7s&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果有匹配的pod(比如说3个),则你看到的信息将类似如下&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;kubectl get poddisruptionbudgets&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;NAME      MIN-AVAILABLE   ALLOWED-DISRUPTIONS   AGE
zk-pdb    2               1                     7s&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ALLOWED-DISRUPTIONS&lt;/code&gt;值不为0意味着中断控制器已经发现pod,计算了匹配的pod数量,然后更新了PDB的状态&lt;/p&gt;
&lt;p&gt;你可以使用以下命令获取更多PDB的状态信息&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;kubectl get poddisruptionbudgets zk-pdb -o yaml&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;yml&quot;&gt;
&lt;code&gt;apiVersion: policy/v1beta1
kind: PodDisruptionBudget
metadata:
  creationTimestamp: 2017-08-28T02:38:26Z
  generation: 1
  name: zk-pdb
...
status:
  currentHealthy: 3
  desiredHealthy: 3
  disruptedPods: null
  disruptionsAllowed: 1
  expectedPods: 3
  observedGeneration: 1&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 07 Jun 2019 00:40:00 +0000</pubDate>
<dc:creator>周国通</dc:creator>
<og:description>'系列目录' 上一节我们讲到了由于一些人为的或者不可避免的原因,pod可能会中断,而使用 可以最大限度地保证在pod中断发生时集群仍然保持能够接受的状态. 一句话,PDB能够限制同时中断的pod的数量</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tylerzhou/p/10987576.html</dc:identifier>
</item>
<item>
<title>记一次前端面试~终于拿到理想中的offer！ - dora_zc</title>
<link>http://www.cnblogs.com/dora-zc/p/10987560.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dora-zc/p/10987560.html</guid>
<description>&lt;p&gt;2019年已经过去一半，终于拿到一直想去的公司offer，也算是实现了今年的一个小目标。&lt;/p&gt;
&lt;p&gt;由于这家公司是我从去年到现在最想去的公司，本次换工作一直没有投，希望先积累下面试经验再投。&lt;/p&gt;
&lt;p&gt;没有想到居然先在boss直聘上接到这家公司的技术经理的面试邀请，真的非常意外也非常兴奋😄&lt;/p&gt;
&lt;p&gt;那个时候我手上已经有比较理想的offer，所以心态也还不错，没有太多担心和顾虑。整个面试过程虽然有点虐，但是自认为面试过程中心态和交流状态都非常积极，遇到不会的问题时我的求生欲格外的强，面试官都几乎要被逗笑了😢&lt;/p&gt;
&lt;p&gt;这家公司也是我所经历的所有面试中体验最好的，每一轮面试官都非常专业，态度很友好，针对你不会的问题会启发和引导，最后答完会给你做知识的总结和梳理。当时我就想，即使没有被录取也算是一次很好的学习机会吧，三轮面试4个多小时，赚了赚了😝&lt;/p&gt;
&lt;p&gt;面试第二天接到hrbp的电话面试，了解了下个人情况，同样很nice。第三天接到薪酬hr的电话，最后给到我期望薪酬，没有压价，耶！&lt;/p&gt;
&lt;p&gt;下面是面试中问到的问题，还记得的列出来了，好多都忘了…...&lt;/p&gt;
&lt;p&gt;希望半年以后的我，对这些问题能有新的理解和回答。&lt;/p&gt;
&lt;h3 id=&quot;面试题&quot;&gt;面试题&lt;/h3&gt;
&lt;p&gt;3轮技术面，一共4个小时；hr面是通过电话面试；一共4轮，然后定薪酬，发offer。&lt;/p&gt;
&lt;h4 id=&quot;一面---技术经理面&quot;&gt;一面 - 技术经理面&lt;/h4&gt;
&lt;p&gt;什么是w3c规范&lt;/p&gt;
&lt;p&gt;如何阻塞操作，例如频繁请求，如果控制2秒请求一次&lt;/p&gt;
&lt;p&gt;倒计时插件如何封装&lt;/p&gt;
&lt;p&gt;为什么setTimeout设置的时间不准确&lt;/p&gt;
&lt;p&gt;如何使setTimeout时间精确&lt;/p&gt;
&lt;p&gt;如何清除页面上所有的定时器&lt;/p&gt;
&lt;p&gt;vue filter的用法和实现原理&lt;/p&gt;
&lt;p&gt;vue router如何实现登录校验&lt;/p&gt;
&lt;p&gt;vue router afterEach是用来干什么的&lt;/p&gt;
&lt;p&gt;elementUI的badge组件，进度条组件，上传组件的使用&lt;/p&gt;
&lt;p&gt;vuex的用法，核心api，什么时候需要用vuex&lt;/p&gt;
&lt;p&gt;对koa的理解，最复杂的项目做到什么程度&lt;/p&gt;
&lt;p&gt;设计模式知道哪些&lt;/p&gt;
&lt;p&gt;手写观察者模式，什么是观察者模式，使用场景是什么&lt;/p&gt;
&lt;p&gt;算法题：从一个数组中截取m个数，并让顺序是随机的，如何做&lt;/p&gt;
&lt;p&gt;常用sql语句&lt;/p&gt;
&lt;h4 id=&quot;二面---技术经理主管面&quot;&gt;二面 - 技术经理/主管面&lt;/h4&gt;
&lt;p&gt;用react重构vue项目，只重构了页面的一部分，如何正常展示整个页面&lt;/p&gt;
&lt;p&gt;正则表达式过滤一堆资源文件中不包括js的文件&lt;/p&gt;
&lt;p&gt;手写数组去重&lt;/p&gt;
&lt;p&gt;50万条数据去重的时间复杂度&lt;/p&gt;
&lt;p&gt;shell命令用过哪些，使用场景&lt;/p&gt;
&lt;h4 id=&quot;三面---技术总监面&quot;&gt;三面 - 技术总监面&lt;/h4&gt;
&lt;p&gt;web安全的方式及解决方案&lt;/p&gt;
&lt;p&gt;登录的前后端处理过程&lt;/p&gt;
&lt;p&gt;有没有出现过页面访问越来越卡的情况&lt;/p&gt;
&lt;p&gt;什么是内存泄漏，如何排查内存泄漏问题，由什么引起的&lt;/p&gt;
&lt;p&gt;项目中的难点&lt;/p&gt;
&lt;p&gt;出现的线上问题如何排查&lt;/p&gt;
&lt;p&gt;http和https的区别&lt;/p&gt;
&lt;p&gt;如何存储用户密码，如何保证安全性&lt;/p&gt;
&lt;p&gt;读过哪些源码，读完之后有什么思考和理解&lt;/p&gt;
&lt;p&gt;localstorage是存储在哪里；token是存储在哪里，前端如何获取的；cookie是存储在哪里&lt;/p&gt;
&lt;p&gt;主要考察：安全，http，项目经验，解决问题的能力&lt;/p&gt;
</description>
<pubDate>Fri, 07 Jun 2019 00:04:00 +0000</pubDate>
<dc:creator>dora_zc</dc:creator>
<og:description>2019年已经过去一半，终于拿到一直想去的公司offer，也算是实现了今年的一个小目标。 由于这家公司是我从去年到现在最想去的公司，本次换工作一直没有投，希望先积累下面试经验再投。 没有想到居然先在b</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/dora-zc/p/10987560.html</dc:identifier>
</item>
<item>
<title>Python笔记003-生成器和生成器表达式 - 科技老丁哥</title>
<link>http://www.cnblogs.com/RayDean/p/10987551.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/RayDean/p/10987551.html</guid>
<description>&lt;h2 id=&quot;python笔记003-生成器和生成器表达式&quot;&gt;Python笔记003-生成器和生成器表达式&lt;/h2&gt;
&lt;p&gt;以下是我学习《流畅的Python》后的个人笔记，现在拿出来和大家共享，希望能帮到各位Python学习者。&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4 id=&quot;首次发表于-微信公众号科技老丁哥id-techding敬请关注&quot;&gt;首次发表于: 微信公众号：科技老丁哥，ID: TechDing，敬请关注。&lt;/h4&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;本篇主要知识点&quot;&gt;本篇主要知识点：&lt;/h3&gt;
&lt;ol readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;生成器使用yield做关键字，一次只返回一个值给调用者，然后暂停执行，其作用是：节省内存空间。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;生成器可以用next()函数，也可以用for迭代的方式获取元素值，中间还可以用close()来随时终止生成器。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;生成器表达式可以认为是一种特殊的生成器，其代码更简洁，更容易理解，且和别的函数结合会更加灵活。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;生成器&quot;&gt;1. 生成器&lt;/h3&gt;
&lt;p&gt;生成器是Python中一个特殊的程序，用于控制循环的迭代行为。相对于一般函数用return来一次性返回所有值，生成器使用yield关键字，一次只返回一个值。&lt;/p&gt;
&lt;p&gt;这样的设计有很大的好处：在数据处理时，如果函数return出来的是一个非常大的数组，那么会非常占用内存，有时会报MemoryError的错误，而使用yield后一次仅仅返回一个元素值，可以优化内存占用的情况。&lt;/p&gt;
&lt;p&gt;从这种角度来讲，生成器函数每一次调用都返回一个元素值，这种特性使得生成器长得像函数，但行为却像迭代器。&lt;/p&gt;
&lt;pre class=&quot;py&quot;&gt;
&lt;code&gt;def squares(x): # 计算0-x的所有数的平方
#     return [i*i for i in range(x)] # 普通写法，一次返回一个list，包含所有元素
    for i in range(x):
        yield i*i # 生成器：一次只返回一个值
print(squares(5)) # &amp;lt;generator object squares at 0x00000157DBD16830&amp;gt;
# 获取生成器中的元素值
for value in squares(5): # 行为类似于迭代器，循环获取元素值
    print('value: ',value)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;生成器并不像一般的函数，它返回一个值后，生成器函数会自动挂起，等到下一次调用时（使用其内部成员方法&lt;code&gt;__next__&lt;/code&gt;来实现），再返回到这个函数中继续执行。&lt;/p&gt;
&lt;p&gt;所以要想获取生成器的元素值，需要通过成员方法next()来进行，比如：&lt;/p&gt;
&lt;pre class=&quot;py&quot;&gt;
&lt;code&gt;square_five=squares(5)
print(next(square_five)) # 0
print(next(square_five)) # 1
print(next(square_five)) # 4
print(next(square_five)) # 9
print(next(square_five)) # 16
print(next(square_five)) # 报错：StopIteration: 超过yield的所有元素&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;next()函数每次执行时，都会继续执行挂起的生成器函数，直到执行完毕。&lt;/p&gt;
&lt;p&gt;生成器的这种特点被称为&quot;延迟计算&quot;或&quot;惰性求值(Lazy evaluation)&quot;，可以有效的节省内存。惰性求值实际上是体现了协同程序的思想。&lt;/p&gt;
&lt;p&gt;虽然生成器的这种行为类似于迭代器，但两者有较大差别，迭代器不具备这种执行-暂停-再执行-再暂停的特性，所以迭代器不具有延迟计算，没有协同程序的思想。&lt;/p&gt;
&lt;p&gt;使用延迟计算后，可以极大的节省内存，比如对大文件进行读取操作时，可以用下列生成器方法：&lt;/p&gt;
&lt;pre class=&quot;py&quot;&gt;
&lt;code&gt;## 读取大文件的生成器方法：
def load_big_file(file_path):
    BLOCK_SIZE = 1024
    with open(file_path, 'rb') as f:
        while True:
            block = f.read(BLOCK_SIZE)
            if block:
                yield block # 一次只加载一个block到内存中，避免MemoryError
            else:
                return&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;生成器除了用next()函数来处理之外，还可以用close()来随时退出生成器。如下代码：&lt;/p&gt;
&lt;pre class=&quot;py&quot;&gt;
&lt;code&gt;## 使用close()可以随时退出生成器
square_five=squares(5)
print(next(square_five)) # 0
print(next(square_five)) # 1
print(next(square_five)) # 4
square_five.close() # 退出生成器
print(next(square_five)) # Error: StopIteration:
print(next(square_five)) # Error: StopIteration:&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;生成器表达式&quot;&gt;2. 生成器表达式&lt;/h3&gt;
&lt;p&gt;从形式上来看，生成器表达式和列表推导式很像，仅仅是将列表推导式中的[]替换为()，但是两者差别挺大，生成器表达式可以说组合了迭代功能和列表解析功能。&lt;/p&gt;
&lt;p&gt;生成器表达式可以认为是一种特殊的生成器函数，类似于lambda表达式和普通函数。但是和生成器一样，生成器表达式也是返回生成器generator对象，一次只返回一个值。&lt;/p&gt;
&lt;pre class=&quot;py&quot;&gt;
&lt;code&gt;# 上面的squares函数可以改写为：
# 列表推导式的写法是：
squares_list=[i*i for i in range(5)] # 一次性返回整个list
print('列表推导式：',squares_list) # 列表推导式： [0, 1, 4, 9, 16]
# 生成器表达式：
squares2=(i*i for i in range(5)) # 生成器表达式一次返回一个值
print('生成器表达式：',squares2) # 生成器表达式： &amp;lt;generator object ..
print(next(squares2)) # 0
print(next(squares2)) # 1
print(next(squares2)) # 4&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;生成器表达式是一种特殊的生成器，所以它也有生成器的特性，可以使用for循环来获取元素值，for循环内部自动调用了next()函数来执行。&lt;/p&gt;
&lt;pre class=&quot;py&quot;&gt;
&lt;code&gt;# generator对象可以直接用for来获取所有元素值
squares2=(i*i for i in range(5)) # 生成器表达式就是一个generator对象
for i in squares2:
    print('i: ',i)

# 上面可以简写为：
[print('i: ',i) for i in (i*i for i in range(5))]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;生成器表达式如果作为某个函数的参数，则可以省略掉()，直接使用即可，eg:&lt;/p&gt;
&lt;pre class=&quot;py&quot;&gt;
&lt;code&gt;## 如果生成器表达式整个作为某个函数的参数，可以省略掉()
max_value=max(i*i for i in range(5))  # 计算生成器的所有元素中的最大值
print(max_value) # 16&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;4.5918367346939&quot;&gt;
&lt;h4 id=&quot;首次发表于-微信公众号科技老丁哥id-techding敬请关注-1&quot;&gt;首次发表于: 微信公众号：科技老丁哥，ID: TechDing，敬请关注。&lt;/h4&gt;
&lt;p&gt;本文所有代码都已经上传到&lt;a href=&quot;https://github.com/RayDean/PythonNotes&quot;&gt;我的github&lt;/a&gt;，欢迎下载&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;《流畅的Python》，Luciano Ramalho (作者) 安道 , 吴珂 (译者)。&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Thu, 06 Jun 2019 23:41:00 +0000</pubDate>
<dc:creator>科技老丁哥</dc:creator>
<og:description>Python笔记003 生成器和生成器表达式 以下是我学习《流畅的Python》后的个人笔记，现在拿出来和大家共享，希望能帮到各位Python学习者。 首次发表于: 微信公众号：科技老丁哥，ID: T</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/RayDean/p/10987551.html</dc:identifier>
</item>
<item>
<title>一文读懂链路追踪 - 了不起的厂长</title>
<link>http://www.cnblogs.com/enochzzg/p/10987438.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/enochzzg/p/10987438.html</guid>
<description>&lt;h2 id=&quot;背景介绍&quot;&gt;背景介绍&lt;/h2&gt;
&lt;p&gt;在微服务横行的时代，服务化思维逐渐成为了程序员的基本思维模式，但是，由于绝大部分项目只是一味地增加服务，并没有对其妥善管理，当接口出现问题时，很难从错综复杂的服务调用网络中找到问题根源，从而错失了止损的黄金时机。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13711841-7479bc37bd360990?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而链路追踪的出现正是为了解决这种问题，它可以在复杂的服务调用中定位问题，还可以在新人加入后台团队之后，让其清楚地知道自己所负责的服务在哪一环。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13711841-20f0fc344be9a6ca?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;除此之外，如果某个接口突然耗时增加，也不必再逐个服务查询耗时情况，我们可以直观地分析出服务的性能瓶颈，方便在流量激增的情况下精准合理地扩容。&lt;/p&gt;
&lt;h2 id=&quot;链路追踪&quot;&gt;链路追踪&lt;/h2&gt;
&lt;p&gt;“链路追踪”一词是在2010年提出的，当时谷歌发布了一篇Dapper论文，介绍了谷歌自研的分布式链路追踪的实现原理，还介绍了他们是怎么低成本实现对应用透明的。&lt;/p&gt;
&lt;p&gt;其实Dapper一开始只是一个独立的调用链路追踪系统，后来逐渐演化成了监控平台，并且基于监控平台孕育出了很多工具，比如实时预警、过载保护、指标数据查询等。&lt;/p&gt;
&lt;p&gt;除了谷歌的dapper，还有一些其他比较有名的产品，比如阿里的鹰眼、大众点评的CAT、Twitter的Zipkin、Naver（著名社交软件LINE的母公司）的pinpoint以及国产开源的skywalking等。&lt;/p&gt;
&lt;h2 id=&quot;基本实现原理&quot;&gt;基本实现原理&lt;/h2&gt;
&lt;p&gt;如果想知道一个接口在哪个环节出现了问题，就必须清楚该接口调用了哪些服务，以及调用的顺序，如果把这些服务串起来，看起来就像链条一样，我们称其为调用链。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13711841-1b0b334408943a05?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;想要实现调用链，就要为每次调用做个标识，然后将服务按标识大小排列，可以更清晰地看出调用顺序，我们暂且将该标识命名为spanid。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13711841-6435a5ac2f63918b?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;实际场景中，我们需要知道某次请求调用的情况，所以只有spanid还不够，得为每次请求做个唯一标识，这样才能根据标识查出本次请求调用的所有服务，而这个标识我们命名为traceid。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13711841-545e1f55f60cb9eb?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在根据spanid可以轻易地知道被调用服务的先后顺序，但无法体现调用的层级关系，正如下图所示，多个服务可能是逐级调用的链条，也可能是同时被同一个服务调用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13711841-01776cda2c7724d9?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以应该每次都记录下是谁调用的，我们用parentid作为这个标识的名字。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13711841-b2f7ec0dc2ab3226?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到现在，已经知道调用顺序和层级关系了，但是接口出现问题后，还是不能找到出问题的环节，如果某个服务有问题，那个被调用执行的服务一定耗时很长，要想计算出耗时，上述的三个标识还不够，还需要加上时间戳，时间戳可以更精细一点，精确到微秒级。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13711841-fff91381098d9329?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;只记录发起调用时的时间戳还算不出耗时，要记录下服务返回时的时间戳，有始有终才能算出时间差，既然返回的也记了，就把上述的三个标识都记一下吧，不然区分不出是谁的时间戳。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13711841-d32ae8fbedded827?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;虽然能计算出从服务调用到服务返回的总耗时，但是这个时间包含了服务的执行时间和网络延迟，有时候我们需要区分出这两类时间以方便做针对性优化。那如何计算网络延迟呢？我们可以把调用和返回的过程分为以下四个事件。&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Client Sent简称cs，客户端发起调用请求到服务端。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Server Received简称sr，指服务端接收到了客户端的调用请求。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Server Sent简称ss，指服务端完成了处理，准备将信息返给客户端。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Client Received简称cr，指客户端接收到了服务端的返回信息。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13711841-85516824f0f6b51c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;假如在这四个事件发生时记录下时间戳，就可以轻松计算出耗时，比如sr减去cs就是调用时的网络延迟，ss减去sr就是服务执行时间，cr减去ss就是服务响应的延迟，cr减cs就是整个服务调用执行的时间。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13711841-144e8c430510cc48?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其实span块内除了记录这几个参数之外，还可以记录一些其他信息，比如发起调用服务名称、被调服务名称、返回结果、IP、调用服务的名称等，最后，我们再把相同spanid的信息合成一个大的span块，就完成了一个完整的调用链。感兴趣的同学可以去深入了解一下链路追踪，希望本文对你有所帮助。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13711841-9b266a8eb936a89c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 06 Jun 2019 16:56:00 +0000</pubDate>
<dc:creator>了不起的厂长</dc:creator>
<og:description>背景介绍 在微服务横行的时代，服务化思维逐渐成为了程序员的基本思维模式，但是，由于绝大部分项目只是一味地增加服务，并没有对其妥善管理，当接口出现问题时，很难从错综复杂的服务调用网络中找到问题根源，从而</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/enochzzg/p/10987438.html</dc:identifier>
</item>
<item>
<title>java简单实现用语音读txt文档 - java小新人</title>
<link>http://www.cnblogs.com/wyq1995/p/10987420.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wyq1995/p/10987420.html</guid>
<description>&lt;p&gt;　　最近比较无聊，随便翻着博客，无意中看到了有的人用VBS读文本内容，也就是读几句中文，emmm,挺有趣的，实现也很简单，都不需要安装什么环境，直接新建txt文件，输入一些简单的vbs读文本的代码，然后将新建的文件后缀改为.vbs,然后双击一下就可以有效果了。。。。&lt;/p&gt;
&lt;p&gt;　　于是我就想啊，java行不行呢？查了一些资料，还真的行，我就将我试验的过程说一下，就当作娱乐娱乐！&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.依赖&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　随便新建一个maven项目，导入依赖&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;com.hynnet&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;jacob&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.18&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　只导入依赖还不行，还要导入一个.dll文件，百度云链接：链接：https://pan.baidu.com/s/1YYYPIoPxrtuyKebJzabhlw    提取码：s62o ，可以看到有两个dll文件，由于我的电脑是64位的，于是我将上面那个dll文件复制一份到当前使用jdk的bin目录下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201906/1368608-20190606235611675-580785528.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201906/1368608-20190606235800680-423726905.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.java代码实现&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　一个很简单的java代码实现，运行之后就会读出来了；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.wyq.day66;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.jacob.activeX.ActiveXComponent;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.jacob.com.Dispatch;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.jacob.com.Variant;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Speak02 {
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用电脑自带的语音读字符串str&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
         String str &lt;/span&gt;= &quot;你好，我是java小新人！请叫我最帅的帅锅&quot;&lt;span&gt;;
         
         ActiveXComponent sap &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ActiveXComponent(&quot;Sapi.SpVoice&quot;&lt;span&gt;);
         Dispatch sapo &lt;/span&gt;=&lt;span&gt; sap.getObject();
         &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
             &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 音量 0-100&lt;/span&gt;
             sap.setProperty(&quot;Volume&quot;, &lt;span&gt;new&lt;/span&gt; Variant(100&lt;span&gt;));
             &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 语音朗读速度 -10 到 +10&lt;/span&gt;
             sap.setProperty(&quot;Rate&quot;, &lt;span&gt;new&lt;/span&gt; Variant(0&lt;span&gt;));
             &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行朗读 &lt;/span&gt;
              Dispatch.call(sapo, &quot;Speak&quot;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Variant(str));
              
         } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
             e.printStackTrace();
         } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
             sapo.safeRelease();
             sap.safeRelease();
         }
         
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.输出音频文件&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　按理说到上面已经实现了功能，但是我还想着能不能把读的音频文件该输出一下呢？查了查资料，居然还真行，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.wyq.day66;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.jacob.activeX.ActiveXComponent;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.jacob.com.Dispatch;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.jacob.com.Variant;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; JavaSpeak {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定文件音频输出文件位置&lt;/span&gt;
        String output = &quot;E:\\test.wav&quot;&lt;span&gt;;
        
        ActiveXComponent ax &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        String str&lt;/span&gt;=&quot;我是java小新人，我要将这段话的音频输出一下&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            ax &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ActiveXComponent(&quot;Sapi.SpVoice&quot;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;运行时输出语音内容&lt;/span&gt;
            Dispatch spVoice =&lt;span&gt; ax.getObject();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 音量 0-100&lt;/span&gt;
            ax.setProperty(&quot;Volume&quot;, &lt;span&gt;new&lt;/span&gt; Variant(100&lt;span&gt;));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 语音朗读速度 -10 到 +10&lt;/span&gt;
            ax.setProperty(&quot;Rate&quot;, &lt;span&gt;new&lt;/span&gt; Variant(-3&lt;span&gt;));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 进行朗读&lt;/span&gt;
            Dispatch.call(spVoice, &quot;Speak&quot;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Variant(str));

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;下面是构建文件流把生成语音文件&lt;/span&gt;
&lt;span&gt;
            ax &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ActiveXComponent(&quot;Sapi.SpFileStream&quot;&lt;span&gt;);
            Dispatch spFileStream &lt;/span&gt;=&lt;span&gt; ax.getObject();

            ax &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ActiveXComponent(&quot;Sapi.SpAudioFormat&quot;&lt;span&gt;);
            Dispatch spAudioFormat &lt;/span&gt;=&lt;span&gt; ax.getObject();

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置音频流格式&lt;/span&gt;
            Dispatch.put(spAudioFormat, &quot;Type&quot;, &lt;span&gt;new&lt;/span&gt; Variant(22&lt;span&gt;));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置文件输出流格式&lt;/span&gt;
            Dispatch.putRef(spFileStream, &quot;Format&quot;&lt;span&gt;, spAudioFormat);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用输出 文件流打开方法，在指定位置输出一个.wav文件&lt;/span&gt;
            Dispatch.call(spFileStream, &quot;Open&quot;, &lt;span&gt;new&lt;/span&gt; Variant(output), &lt;span&gt;new&lt;/span&gt; Variant(3), &lt;span&gt;new&lt;/span&gt; Variant(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置声音对象的音频输出流为输出文件对象&lt;/span&gt;
            Dispatch.putRef(spVoice, &quot;AudioOutputStream&quot;&lt;span&gt;, spFileStream);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置音量 0到100&lt;/span&gt;
            Dispatch.put(spVoice, &quot;Volume&quot;, &lt;span&gt;new&lt;/span&gt; Variant(100&lt;span&gt;));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置朗读速度&lt;/span&gt;
            Dispatch.put(spVoice, &quot;Rate&quot;, &lt;span&gt;new&lt;/span&gt; Variant(-2&lt;span&gt;));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开始朗读&lt;/span&gt;
            Dispatch.call(spVoice, &quot;Speak&quot;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Variant(str));

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭输出文件&lt;/span&gt;
            Dispatch.call(spFileStream, &quot;Close&quot;&lt;span&gt;);
            Dispatch.putRef(spVoice, &lt;/span&gt;&quot;AudioOutputStream&quot;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);

            spAudioFormat.safeRelease();
            spFileStream.safeRelease();
            spVoice.safeRelease();
            ax.safeRelease();

            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
                e.printStackTrace();
            }
    
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　直接运行我们就可以听到朗读的声音，而且在指定目录还可以找到音频文件；&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.调用百度AI来读文本&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　又按理说到上面应该就差不多了，但是我总是感觉电脑自带的语音库声音不好听，我要用百度AI的那个比较可爱的声音，我还是去查了查资料，居然可以，而且很容易！&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;4.1.申请一下百度语音api权限&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　由于我们是要去调用百度的api进行语音识别，那么我们要先去申请一下权限，不然会一直报错（这个地方卡了好久，最后终于被我查出来为什么报错了。。。），链接：http://ai.baidu.com/&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201906/1368608-20190607001456966-1885040448.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　然后会让你登录一下，直接用qq登录就行；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201906/1368608-20190607001631133-346537092.png&quot; alt=&quot;&quot; width=&quot;784&quot; height=&quot;206&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201906/1368608-20190607001845068-982595532.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201906/1368608-20190607001943316-871253429.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　创建完毕之后查看一下应用详情：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201906/1368608-20190607002142144-704612690.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　&lt;span&gt;&lt;strong&gt;　4.2.代码实现&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　做了这么多是操作就是为了得到这三个字符串，现在我们还要导入百度语音的依赖：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;!--百度语音播报sdk--&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;com.baidu.aip&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;java-sdk&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;4.4.1&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    
    &amp;lt;!-- https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;mvnrepository.com/artifact/org.json/json --&amp;gt;&lt;/span&gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.json&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;json&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;20160810&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　桌面上记事本中的内容：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201906/1368608-20190607003129619-1290500712.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　java代码实现如下，其实就是利用百度AI读取我们计算机中的一个txt文档，输出MP3文件保存并到指定位置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.wyq.day66;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.File;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.FileInputStream;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.FileNotFoundException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.UnsupportedEncodingException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.HashMap;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.json.JSONObject;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.baidu.aip.speech.AipSpeech;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.baidu.aip.speech.TtsResponse;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.baidu.aip.util.Util;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Speak03 {
    &lt;/span&gt;&lt;strong&gt;&lt;span&gt;//设置APPID/AK/SK，这三个参数是需要我们去百度AI平台申请的（也就是上面说的那三个字符串）&lt;/span&gt;&lt;/strong&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String APP_ID = &quot;16447127&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String API_KEY = &quot;8GO31sOIffR1oll5mPFKgtR9&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String SECRET_KEY = &quot;jWsoNGlfzfRGSQ30****NOxz9ZpjMbc&quot;&lt;span&gt;;
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;readFile是我们的txt文档，writeFile是输出的MP3格式&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String readFile = &quot;C:\\Users\\asus\\Desktop\\says.txt&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String writeFile = &quot;E:\\output.mp3&quot;&lt;span&gt;;


    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;可以直接输入字符串也行，内容比较多的话还是用txt文档比较好一点
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;convertMP3(&quot;你好！我是百度AI智能,java小新人，很高兴和你见面，我们一定能成为很好的朋友的&quot;);
        
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用readToString方法将一个txt文档中的数据读取出来变成一个字符串&lt;/span&gt;
        String string =&lt;span&gt; readToString(readFile);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将这个字符串用百度AI读一下输出MP3格式&lt;/span&gt;
&lt;span&gt;        convertMP3(string);

    }
     &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; convertMP3(String str) {
            AipSpeech client &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AipSpeech(APP_ID, API_KEY, SECRET_KEY);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 可选：设置网络连接参数，就是超时时间&lt;/span&gt;
            client.setConnectionTimeoutInMillis(2000&lt;span&gt;);
            client.setSocketTimeoutInMillis(&lt;/span&gt;60000&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置一些可选参数&lt;/span&gt;
            HashMap&amp;lt;String, Object&amp;gt; options = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;String, Object&amp;gt;&lt;span&gt;();
            options.put(&lt;/span&gt;&quot;spd&quot;, &quot;5&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;语速，取值0-9，默认为5中语速      非必选&lt;/span&gt;
            options.put(&quot;pit&quot;, &quot;5&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;音调，取值0-9，默认为5中语调      非必选&lt;/span&gt;
            options.put(&quot;per&quot;, &quot;4&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;发音人选择, 0为女声，1为男声，3为情感合成-度逍遥，4为情感合成-度丫丫，默认为普通女 非必选
            
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;百度AI开始读取传入的str字符串&lt;/span&gt;
            TtsResponse res = client.synthesis(str, &quot;zh&quot;, 1&lt;span&gt;, options);
            
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;服务器返回的内容，合成成功时为null,失败时包含error_no等信息&lt;/span&gt;
            JSONObject result =&lt;span&gt; res.getResult();   
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (result != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                System.out.printf(&lt;/span&gt;&quot;error：&quot; + result.toString()+&quot;----------&quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }
           &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;生成的音频数据&lt;/span&gt;
            &lt;span&gt;byte&lt;/span&gt;[] data =&lt;span&gt; res.getData();            
            JSONObject res1 &lt;/span&gt;=&lt;span&gt; res.getResult();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (data != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将生成的音频输出到指定位置&lt;/span&gt;
&lt;span&gt;                    Util.writeBytesToFileSystem(data, writeFile);
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                    e.printStackTrace();
                }
            }
            
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (res1 != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                System.out.println(res1.toString());
            }
        }
     
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个方法就是根据输入的文件路径，读取该文件内容返回一个很长的字符串，由于txt是gbk编码，所以我们变成字符串的时候也要用gbk
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;其实就是最基本的流操作&lt;/span&gt;
     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; String readToString(String fileName) {  
            String encoding &lt;/span&gt;= &quot;gbk&quot;&lt;span&gt;;  
            File file &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; File(fileName);  
            Long filelength &lt;/span&gt;=&lt;span&gt; file.length();  
            &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] filecontent = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[filelength.intValue()];  
            
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {  
                FileInputStream in &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileInputStream(file);  
                in.read(filecontent);  
                in.close();  
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (FileNotFoundException e) {  
                e.printStackTrace();  
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {  
                e.printStackTrace();  
            }  
            
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {  
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; String(filecontent, encoding);  
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (UnsupportedEncodingException e) {  
                System.err.println(&lt;/span&gt;&quot;The OS does not support &quot; +&lt;span&gt; encoding);  
                e.printStackTrace();  
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;  
            }  
        }
    

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　输出的音频文件： &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201906/1368608-20190607002940780-241831496.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;5.总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　感觉还是有点儿意思的，没事的时候用java玩一玩这些东西就当是打发时间！总是看一些框架原理啊什么的，时间长了也是比较无聊的，可以挖掘一下java的其他功能也不错！&lt;/p&gt;
</description>
<pubDate>Thu, 06 Jun 2019 16:49:00 +0000</pubDate>
<dc:creator>java小新人</dc:creator>
<og:description>最近比较无聊，随便翻着博客，无意中看到了有的人用VBS读文本内容，也就是读几句中文，emmm,挺有趣的，实现也很简单，都不需要安装什么环境，直接新建txt文件，输入一些简单的vbs读文本的代码，然后将</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wyq1995/p/10987420.html</dc:identifier>
</item>
<item>
<title>解密httpclient,dbcp,jedis,c3p0,druid,okhttp都在使用的连接池技术 - 猿界汪汪队</title>
<link>http://www.cnblogs.com/donlianli/p/10987063.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/donlianli/p/10987063.html</guid>
<description>&lt;p align=&quot;left&quot;&gt;最近在连接池上面栽了个跟头（参见&lt;a href=&quot;https://www.cnblogs.com/donlianli/p/10917499.html&quot; target=&quot;_blank&quot;&gt;这里&lt;/a&gt;），引起我对池技术的强烈关注，这几天总结了一下很多场景都会使用的池技术；&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;池概念&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;pool，中文翻译为水池，但是在英文中，还有一种解释是&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;an organization of people or resources that can be shared；&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;不知道古代中文是否包含共享资源的意思，欧美语言中，池就是有资源共享的意思；&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;为什么要采用池技术&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;精确的说，应该是为什么要使用连接池技术；我们先看看这些使用池技术的组件都有哪些，httpclient HTTP协议组件,dbcp数据库连接池,jedis redis客户端；可以说代表了三种截然不同的应用场景；但是他们背后，却都有一个共同点，那就是TCP长连接；&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;综上，我个人认为主要是出于以下几方面&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;1、TCP连接每次建立和释放都比较耗时，特别是对于小的HTTP请求，如果能在业务调用时省去这段时间，则业务代码性能更好，这就需要提前建立TCP连接或者事后释放TCP连接；&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;2、业务代码会存在多次资源调用，但是不希望TCP连接对象在多次调用之间传来传去，这样会让代码变的复杂；&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;3、组件希望提供更友好的接口，而将底层的TCP技术使用池进行了封装；&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;有些人可能对长短连接概念不是很清楚，大家可以简单的认为，像HTTP协议请求完就会与服务器的连接断掉是短连接，通常我们上网都是短连接。像开发过程中使用的数据库客户端，一般会长时间与数据库维持一个TCP连接，这个可以就认为是长连接。除了DB,还有redis，java中的RMI等协议都是长连接；&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;长连接比短连接各有优劣：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;好处：省去每次TCP3次握手和4次挥手的过程，发送请求和响应耗时更短；&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;坏处：服务器切换影响比较大，通常只能通过强制手段让客户端重新建立连接才能完成后端服务的切换；单纯从运维角度看，长连接非常不提倡；&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;池抽象&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;如果画一张图，我想应该是这样&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/544558/201906/544558-20190606220413250-1826370229.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;就是在一个大池子里面，有好多资源。这些资源随时可能被拿出去占用或者随时有新的资源被归还，好借好还，再借不难；正常情况应该是这样&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/544558/201906/544558-20190606220424853-1831845369.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;这就是池技术的基本原理，这个模型很重要，httpclient,dbcp,jedis,c3p0,druid，okhttp这些组件都使用到了池技术，大家可以自行去官网查看；下面我再抽几个重点场景给大家几个常见的重要配置参数；&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;连接池总资源数&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;既然是池，其容量总是有限制的，并且不同的组件，其总量限制默认都很低。&lt;/p&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;组件&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;最大资源数属性&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;默认最大资源数&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;httpclient4&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;MaxTotal&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;20&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;jedis2&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;maxTotal&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt; 8&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;druid&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;maxActive&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt; 8&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;c3p0&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;maxPoolSize&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;15&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p align=&quot;left&quot;&gt;关于httpclient,还要特殊说明一下，这个maxTotal，存在误区，可以参见&lt;a href=&quot;https://www.cnblogs.com/donlianli/p/10954716.html&quot; target=&quot;_blank&quot;&gt;这里&lt;/a&gt;；&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; 那么问题来了，如果TCP连接的另外一端响应突然变慢，导致租户无法及时归还资源，新的用户又要借用，但连接池中没有资源了，组件会如何处理？&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;答案是&lt;strong&gt;等&lt;/strong&gt;；而且，如果你没有修改默认设置的话，默认是无限的等；你可能会说，我不相等，我想让系统有自我保护功能，当后端依赖出现问题的时候，我们尽快的反馈给调用方，而不是把自己耗死；OK,你的想法很不错，但是你需要修改配置，让调用方不是无限等，可以设置调用方不等或者等待有限时间&lt;/p&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;组件&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;属性&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;httpclient4&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;RequestConfig.ConnectionRequestTimeout&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;jedis2&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;MaxWaitMillis&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;druid&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;maxWait&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;c3p0&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;breakAfterAcquireFailure &lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;dbcp&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;maxWaitMillis&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;TCP&lt;/strong&gt;&lt;strong&gt;连接的问题&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;因为网络协议太复杂了，当组件采用池技术后，一系列后遗症也逐渐暴露出来；有时发现从池中取出连接使用时，发现连接已经被服务器端关闭了；并且这种情况，各种池组件无法感知（这个说起来又能说一篇），这些连接在英文中称为stale；针对这种情况，各种组件基本上围绕使用流程在使用前，使用后以及定时任务清理三种策略来避免这种情况；&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;使用前&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;组件通常采用在用户代码请求时，组件先自己测试TCP连接是否还可用，但是这种手段通常仅对DB连接池组件有效；如dbcp组件，通常会向服务器端发送一个测试sql来测试连接是否还可用；&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;使用后&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;同使用前检测一样，这种方法也是通常应用在数据库连接池中；在数据库出现问题时，通常连接已经不可用，这个时候再return给连接池，也会给其他后申请者造成影响，不如直接释放连接，后续再建立新的连接；&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;定期检测&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;通常连接池在不同的时间，池中空闲的连接数量是不同的，在业务低峰期，长时间维持一些没用的连接也是一种浪费。通常这个时候会有一个定时任务来定期清理长期不活跃的连接。具体的清理策略各式各样，有按照连接时长清理的，有按照长时间没有活动清理的。这个清理又会涉及很多参数设置，大家可以自行阅读参考；&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;另外，在数据库连接池中针对低峰期空闲连接多的问题（通常会导致系统time_wait多的问题），连接池通常还有一个最大空闲连接数（maxIdle)和最小空闲连接数(minIdle)两个参数，这两个参数的含义如下：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;minIdle&lt;/strong&gt;:保证池中最少要有minIdle个空闲的连接可用。如果少于这个数，则开始预创建连接；&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;maxIdle&lt;/strong&gt;:保证池中最多有maxIdle个空闲的连接，当连接池被不断归还时，如果空闲连接数超过maxIdle，则开始对空闲的连接数进行释放。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;最后还有一点，druid,dbcp和jedis池技术都是采用或者参考的apache的common-pool，很多参数都跟common-pool一样。okhttp是后起之秀，虽然也使用了池技术，但是在同步调用中，并没有对池的大小设置闲置，可以认为，okhttp是一个无限制的连接池；&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; 搜索公众号“猿界汪汪队”，关注更多有深度的文章；&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/544558/201906/544558-20190606220525847-1385970338.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;参考资料：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;a href=&quot;http://hc.apache.org/httpcomponents-client-ga/tutorial/html/index.html&quot;&gt;http://hc.apache.org/httpcomponents-client-ga/tutorial/html/index.html&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;a href=&quot;http://commons.apache.org/proper/commons-dbcp/configuration.html&quot;&gt;http://commons.apache.org/proper/commons-dbcp/configuration.html&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;a href=&quot;https://www.mchange.com/projects/c3p0/#configuration_properties&quot;&gt;https://www.mchange.com/projects/c3p0/#configuration_properties&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 06 Jun 2019 14:09:00 +0000</pubDate>
<dc:creator>猿界汪汪队</dc:creator>
<og:description>最近在连接池上面栽了个跟头（参见这里），引起我对池技术的强烈关注，这几天总结了一下很多场景都会使用的池技术； 池概念 pool，中文翻译为水池，但是在英文中，还有一种解释是 an organizati</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/donlianli/p/10987063.html</dc:identifier>
</item>
<item>
<title>【tf.keras】tf.keras使用tensorflow中定义的optimizer - wuliytTaotao</title>
<link>http://www.cnblogs.com/wuliytTaotao/p/10986952.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wuliytTaotao/p/10986952.html</guid>
<description>&lt;p&gt;我的 tensorflow+keras 版本：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;print(tf.VERSION)    # '1.10.0'
print(tf.keras.__version__)    # '2.1.6-tf'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;tf.keras 没有实现 AdamW，即 Adam with Weight decay。论文《DECOUPLED WEIGHT DECAY REGULARIZATION》提出，在使用 Adam 时，weight decay 不等于 L2 regularization。具体可以参见 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzA3MzI4MjgzMw==&amp;amp;mid=2650744672&amp;amp;idx=1&amp;amp;sn=969f9f655b6fa97baa79db079ec8eb18&amp;amp;scene=0#wechat_redirect&quot;&gt;当前训练神经网络最快的方式：AdamW优化算法+超级收敛&lt;/a&gt; 或 &lt;a href=&quot;https://zhuanlan.zhihu.com/p/40814046&quot;&gt;L2正则=Weight Decay？并不是这样&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;keras 中没有实现 AdamW 这个 optimizer，而 tensorflow 中实现了，所以在 tf.keras 中引入 tensorflow 的 optimizer 就好。&lt;/p&gt;
&lt;p&gt;如下所示：&lt;/p&gt;
&lt;pre class=&quot;python3&quot;&gt;
&lt;code&gt;import tensorflow as tf
from tensorflow.contrib.opt import AdamWOptimizer

mnist = tf.keras.datasets.mnist

(x_train, y_train),(x_test, y_test) = mnist.load_data()
x_train, x_test = x_train / 255.0, x_test / 255.0

model = tf.keras.models.Sequential([
  tf.keras.layers.Flatten(input_shape=(28, 28)),
  tf.keras.layers.Dense(512, activation=tf.nn.relu),
  tf.keras.layers.Dropout(0.2),
  tf.keras.layers.Dense(10, activation=tf.nn.softmax)
])

# adam = tf.train.AdamOptimizer()

# adam with weight decay
adamw = AdamWOptimizer(weight_decay=1e-4)

model.compile(optimizer=adamw,
              loss='sparse_categorical_crossentropy',
              metrics=['accuracy'])

model.fit(x_train, y_train, epochs=10, validation_split=0.1)
print(model.evaluate(x_test, y_test))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果只是像上面这样使用的话，已经没问题了。但是如果要加入 tf.keras.callbacks 中的某些元素，如 tf.keras.callbacks.ReduceLROnPlateau()，可能就会出现异常 AttributeError: 'TFOptimizer' object has no attribute 'lr'。&lt;/p&gt;
&lt;p&gt;以下代码将出现 &lt;span&gt;AttributeError: 'TFOptimizer' object has no attribute 'lr'&lt;/span&gt;，就是因为加入了 tf.keras.callbacks.ReduceLROnPlateau()，其它两个 callbacks 不会引发异常。&lt;/p&gt;
&lt;pre class=&quot;python3&quot;&gt;
&lt;code&gt;import tensorflow as tf
from tensorflow.contrib.opt import AdamWOptimizer

mnist = tf.keras.datasets.mnist

(x_train, y_train),(x_test, y_test) = mnist.load_data()
x_train, x_test = x_train / 255.0, x_test / 255.0

model = tf.keras.models.Sequential([
  tf.keras.layers.Flatten(input_shape=(28, 28)),
  tf.keras.layers.Dense(512, activation=tf.nn.relu),
  tf.keras.layers.Dropout(0.2),
  tf.keras.layers.Dense(10, activation=tf.nn.softmax)
])

# 按照 val_acc 的值来保存模型的参数，val_acc 有提升才保存新的参数
ck_callback = tf.keras.callbacks.ModelCheckpoint('checkpoints/weights-improvement-{epoch:02d}-{val_acc:.2f}.hdf5', monitor='val_acc', mode='max',
                                                verbose=1, save_best_only=True, save_weights_only=True)
# 使用 tensorboard 监控训练过程
tb_callback = tf.keras.callbacks.TensorBoard(log_dir='logs')
# 在 patience 个 epochs 内，被监控的 val_loss 都没有下降，那么就降低 learning rate，新的值为 lr = factor * lr_old
lr_callback = tf.keras.callbacks.ReduceLROnPlateau(patience=3)

adam = tf.train.AdamOptimizer()

# adam with weight decay
# adamw = AdamWOptimizer(weight_decay=1e-4)

model.compile(optimizer=adam,
              loss='sparse_categorical_crossentropy',
              metrics=['accuracy'])

model.fit(x_train, y_train, epochs=10, validation_split=0.1, callbacks=[ck_callback, tb_callback, lr_callback])
print(model.evaluate(x_test, y_test))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解决办法如下所示：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import tensorflow as tf
from tensorflow.contrib.opt import AdamWOptimizer
from tensorflow.keras import backend as K
from tensorflow.python.keras.optimizers import TFOptimizer

mnist = tf.keras.datasets.mnist

(x_train, y_train),(x_test, y_test) = mnist.load_data()
x_train, x_test = x_train / 255.0, x_test / 255.0

model = tf.keras.models.Sequential([
  tf.keras.layers.Flatten(input_shape=(28, 28)),
  tf.keras.layers.Dense(512, activation=tf.nn.relu),
  tf.keras.layers.Dropout(0.2),
  tf.keras.layers.Dense(10, activation=tf.nn.softmax)
])

# 按照 val_acc 的值来保存模型的参数，val_acc 有提升才保存新的参数
ck_callback = tf.keras.callbacks.ModelCheckpoint('checkpoints/weights-improvement-{epoch:02d}-{val_acc:.2f}.hdf5', monitor='val_acc', mode='max',
                                                verbose=1, save_best_only=True, save_weights_only=True)
# 使用 tensorboard 监控训练过程
tb_callback = tf.keras.callbacks.TensorBoard(log_dir='logs')
# 在 patience 个 epochs 内，被监控的 val_loss 都没有下降，那么就降低 learning rate，新的值为 lr = factor * lr_old
lr_callback = tf.keras.callbacks.ReduceLROnPlateau(patience=3)

learning_rate = 0.001
learning_rate = K.variable(learning_rate)

# adam = tf.train.AdamOptimizer()
# # 在 tensorflow 1.10 版中，TFOptimizer 在 tensorflow.python.keras.optimizers 中可以找到，而 tensorflow.keras.optimizers 中没有
# adam = TFOptimizer(adam)
# adam.lr = learning_rate

# adam with weight decay
adamw = AdamWOptimizer(weight_decay=1e-4)
adamw = TFOptimizer(adamw)
adamw.lr = learning_rate

model.compile(optimizer=adamw,
              loss='sparse_categorical_crossentropy',
              metrics=['accuracy'])

model.fit(x_train, y_train, epochs=10, validation_split=0.1, callbacks=[ck_callback, tb_callback, lr_callback])
print(model.evaluate(x_test, y_test))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用 TFOptimizer 包裹一层就行了，这样在使用 tf.keras.callbacks.ReduceLROnPlateau() 时也没有问题了。&lt;/p&gt;
&lt;p&gt;在导入 TFOptimizer 时，注意它所在的位置。1.10 版本的 tensorflow 导入 keras 就有两种方式——tensorflow.keras 和 tensorflow.python.keras，这样其实有点混乱，而 TFOptimizer 的导入只在后者能找到。（有点神奇。。。似乎 1.14 版本 tensorflow 去掉了第一种导入方式，但 tensorflow 2.0 又有了。。。）&lt;/p&gt;
&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzA3MzI4MjgzMw==&amp;amp;mid=2650744672&amp;amp;idx=1&amp;amp;sn=969f9f655b6fa97baa79db079ec8eb18&amp;amp;scene=0#wechat_redirect&quot;&gt;当前训练神经网络最快的方式：AdamW优化算法+超级收敛 -- 机器之心&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/40814046&quot;&gt;L2正则=Weight Decay？并不是这样 -- 杨镒铭&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://github.com/tensorflow/tensorflow/issues/20619&quot;&gt;ReduceLROnPlateau with native optimizer: 'TFOptimizer' object has no attribute 'lr' #20619&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 06 Jun 2019 14:00:00 +0000</pubDate>
<dc:creator>wuliytTaotao</dc:creator>
<og:description>tf.keras 使用 tensorflow 中定义的 optimizer，同时如果使用 ReduceLROnPlateau() callbacks，会出现错误 AttributeError: 'TF</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wuliytTaotao/p/10986952.html</dc:identifier>
</item>
<item>
<title>Java入门教程八(面向对象) - 韭菜Java</title>
<link>http://www.cnblogs.com/lilinfeng/p/10986993.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lilinfeng/p/10986993.html</guid>
<description>&lt;p&gt;一切皆是对象。把现实世界中的对象抽象地体现在编程世界中，一个对象代表了某个具体的操作。一个个对象最终组成了完整的程序设计，这些对象可以是独立存在的，也可以是从别的对象继承过来的。对象之间通过相互作用传递信息，实现程序开发。对象有以下特点：对象具有属性和行为。对象具有变化的状态。对象具有唯一性。对象都是某个类别的实例。&lt;/p&gt;

&lt;h2 id=&quot;封装&quot;&gt;封装&lt;/h2&gt;
&lt;p&gt;封装是将代码及其处理的数据绑定在一起的一种编程机制，该机制保证了程序和数据都不受外部干扰且不被误用。&lt;br/&gt;Java 语言的基本封装单位是类。由于类的用途是封装复杂性，所以类的内部有隐藏实现复杂性的机制。Java 提供了私有和公有的访问模式，类的公有接口代表外部的用户应该知道或可以知道的每件东西，私有的方法数据只能通过该类的成员代码来访问。&lt;/p&gt;
&lt;h2 id=&quot;继承&quot;&gt;继承&lt;/h2&gt;
&lt;p&gt;如同生活中的子女继承父母拥有的所有财产，程序中的继承性是指子类拥有父类数据结构的方法和机制，这是类之间的一种关系；继承只能是单继承&lt;/p&gt;
&lt;h2 id=&quot;多态&quot;&gt;多态&lt;/h2&gt;
&lt;p&gt;面向对象的多态性，即“一个接口，多个方法”。多态性体现在父类中定义的属性和方法被子类继承后，可以具有不同的属性或表现方式。多态性允许一个接口被多个同类使用，弥补了单继承的不足。&lt;/p&gt;

&lt;p&gt;具有相同特性（数据元素）和行为（功能）的对象的抽象就是类，因此对象的抽象是类，类的具体化就是对象，也可以说类的实例是对象。例如：人是一个类，你我就是对象。人类具有身高、体重等属性和说话、走路等方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;人类：对象你我他&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;类是构造面向对象程序的基本单位，是抽取了同类对象的共同属性和方法所形成的对象或实体的“模板”。而对象是现实世界中实体的描述，对象要创建才存在，有了对象才能对对象进行操作。类是对象的模板，对象是类的实例&lt;/p&gt;
&lt;h2 id=&quot;类的定义&quot;&gt;类的定义&lt;/h2&gt;
&lt;p&gt;在 Java 中定义一个类，需要使用 class 关键字、一个自定义的类名和一对表示程序体的大括号，类名应该以下划线（&lt;em&gt;）或字母开头，最好以字母开头；第一个字母最好大写，如果类名由多个单词组成，则每个单词的首字母最好都大写；类名不能为 Java 中的关键字，例如 boolean、this、int 等；类名不能包含任何嵌入的空格或点号以及除了下划线（&lt;/em&gt;）和美元符号（$）字符之外的特殊字符&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Person{
    private int age;//年龄属性
    private String name;//姓名属性
    public void speak(){//说话方法
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;常用关键字&quot;&gt;常用关键字&lt;/h2&gt;
&lt;p&gt;public：表示“共有”的意思。如果使用 public 修饰，则可以被其他类和程序访问。每个 Java 程序的主类都必须是 public 类，作为公共工具供其他类和程序使用的类应定义为 public 类。&lt;br/&gt;abstract：如果类被 abstract 修饰，则该类为抽象类，抽象类不能被实例化，但抽象类中可以有抽象方法（使用 abstract 修饰的方法）和具体方法（没有使用 abstract 修饰的方法）。继承该抽象类的所有子类都必须实现该抽象 类中的所有抽象方法（除非子类也是 抽象类）。&lt;br/&gt;final：如果类被 final 修饰，则不允许被继承。&lt;br/&gt;extends：表示继承其他类。&lt;br/&gt;implements：表示实现某些接口。&lt;/p&gt;
&lt;h2 id=&quot;对象&quot;&gt;对象&lt;/h2&gt;
&lt;p&gt;对象是对类的实例化。对象具有状态和行为，变量用来表明对象的状态，方法表明对象所具有的行为，使用 new 关键字创建对象&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;类名 对象名=new 类名()；&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;//人类
public class Person{
    public int age;//年龄属性
    public String name;//姓名属性
    public void speak(){//说话方法
    }
}
//创建类的对象
Person person = new Person();
person.age=20;
person.name=&quot;Hello World&quot;;
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;对象使用完之后需要对其进行清除。对象的清除是指释放对象占用的内存。在创建对象时，用户必须使用 new 操作符为对象分配内存。不过，在清除对象时，由系统自动进行内存回收，Java 语言的内存自动回收称为垃圾回收（Garbage Collection）机制，简称 GC。垃圾回收机制是指 JVM 用于释放那些不再使用的对象所占用的内存。&lt;br/&gt;一个对象被当作垃圾回收的情况主要如下两种：&lt;/p&gt;
&lt;h2 id=&quot;对象的引用超过其作用范围&quot;&gt;对象的引用超过其作用范围&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;{
    Object o=new Object();    //对象o的作用范围，超过这个范围对象将被视为垃圾
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;对象被赋值为-null&quot;&gt;对象被赋值为 null&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;{
    Object o=new Object();
    o=null;    //对象被赋值为null将被视为垃圾
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 Java 的 Object 类中还提供了一个 protected 类型的 finalize() 方法，因此任何 Java 类都可以覆盖这个方法，在这个方法中进行释放对象所占有的相关资源的操作&lt;br/&gt;在 Java 虚拟机的堆区，每个对象都可能处于以下三种状态之一。&lt;/p&gt;
&lt;p&gt;可触及状态：当一个对象被创建后，只要程序中还有引用变量引用它，那么它就始终处于可触及状态。&lt;/p&gt;
&lt;p&gt;可复活状态：当程序不再有任何引用变量引用该对象时，该对象就进入可复活状态。在这个状态下，垃圾回收器会准备释放它所占用的内存，在释放之前，会调用它及其他处于可复活状态的对象的 finalize() 方法，这些 finalize() 方法有可能使该对象重新转到可触及状态。&lt;/p&gt;
&lt;p&gt;不可触及状态：当 Java 虚拟机执行完所有可复活对象的 finalize() 方法后，如果这些方法都没有使该对象转到可触及状态，垃圾回收器才会真正回收它占用的内存。&lt;/p&gt;

&lt;p&gt;构造方法是类的一种特殊方法，用来初始化类的一个新的对象。Java 中的每个类都有一个默认的构造方法，它必须具有和类名相同的名称，而且没有返回类型。构造方法的默认返回类型就是对象类型本身，并且构造方法不能被 static、final、synchronized、abstract 和 native 修饰&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class class_name
{
    public class_name(){}    //默认无参构造方法
    public ciass_name([paramList]){}    //定义构造方法
    …
    //类主体
}

public class MyClass
{
    private int m;    //定义私有变量
    MyClass()
    {
        //定义无参的构造方法
        m=0;
    }
    MyCiass(int m)
    {
        //定义有参的构造方法
        this.m=m;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;类的构造方法不是要求必须定义的。如果在类中没有定义任何一个构造方法，则 Java 会自动为该类生成一个默认的构造方法。默认的构造方法不包含任何参数，并且方法体为空。如果类中显式地定义了一个或多个构造方法，则 Java 不再提供默认构造方法。&lt;/p&gt;

&lt;p&gt;析构方法与构造方法相反，当对象脱离其作用域时（例如对象所在的方法已调用完毕），系统自动执行析构方法。析构方法往往用来做清理垃圾碎片的工作，例如在建立对象时用 new 开辟了一片内存空间，应退出前在析构方法中将其释放。在 Java 的 Object 类中还提供了一个 protected 类型的 finalize() 方法，因此任何 Java 类都可以覆盖这个方法，在这个方法中进行释放对象所占有的相关资源的操作&lt;br/&gt;对象的 finalize() 方法具有如下特点：&lt;br/&gt;垃圾回收器是否会执行该方法以及何时执行该方法，都是不确定的。&lt;br/&gt;finalize() 方法有可能使用对象复活，使对象恢复到可触及状态。&lt;br/&gt;垃圾回收器在执行 finalize() 方法时，如果出现异常，垃圾回收器不会报告异常，程序继续正常运行。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;protected void finalize()
{
    //对象的清理工作
}

public class Counter
{
    private static int count=0;    //计数器变量
    public Counter()//构造方法
    {
        this.count++;    //创建实例时增加值
    }
    public int getCount()        //获取计数器的值
    {
        return this.count;
    }
    protected void finalize()//析构方法
    {
        this.count--;    //实例销毁时减少值
        System.out.println(&quot;对象销毁&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;在编写 Java 程序时，随着程序架构越来越大，类的个数也越来越多，这时就会发现管理程序中维护类名称也是一件很麻烦的事，尤其是一些同名问题的发生。有时，开发人员还可能需要将处理同一方面的问题的类放在同一个目录下，以便于管理。Java 为了解决上述问题，提供了包机制&lt;/p&gt;
&lt;h2 id=&quot;系统包&quot;&gt;系统包&lt;/h2&gt;
&lt;p&gt;包允许将类组合成较小的单元（类似文件夹），它基本上隐藏了类，并避免了名称上的冲突。包允许在更广泛的范围内保护类、数据和方法，可以在包内定义类，而在包外的代码不能访问该类，常用系统包：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Java.lang   Java 的核心类库，包含运行 Java 程序必不可少的系统类，如基本数据类型、基本数学函数、
字符串处理、异常处理和线程类等，系统默认加载这个包
java.io Java 语言的标准输入/输出类库，如基本输入/输出流、文件输入/输出、过滤输入/输出流等
java.util   包含如处理时间的 Date 类，处理动态数组的 Vector 类，以及 Stack 和 HashTable 类
java.awt    构建图形用户界面（GUI）的类库，低级绘图操作 Graphics 类、图形界面组件和布局管理
（如 Checkbox 类、Container 类、LayoutManger 接口等），以及用 户界面交互控制和事
件响应（如 Event 类）
java.awt.image  处理和操纵来自网上的图片的 java 工具类库
java.wat.peer   很少在程序中直接用到，使得同一个 Java 程序在不同的软硬件平台上运行
java.net    实现网络功能的类库有 Socket 类、ServerSocket 类
java.lang.reflect   提供用于反射对象的工具
java.util.zip   实现文件压缩功能
java.awt.datatransfer   处理数据传输的工具类，包括剪贴板、字符串发送器等
java.sql    实现 JDBC 的类库
java.rmi    提供远程连接与载入的支持
java. security  提供安全性方面的有关支持&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;自定义包&quot;&gt;自定义包&lt;/h2&gt;
&lt;p&gt;Java 的系统包无须定义可以直接调用，也可以自定义包&lt;/p&gt;
&lt;h3 id=&quot;声明&quot;&gt;声明&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;package 包名;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;使用&quot;&gt;使用&lt;/h3&gt;
&lt;p&gt;在要引用的类名前带上包名作为修饰符,bookexample 是包名，Test 是包中的类名，test 是类的对象&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;bookexample.Test test = new bookexampie.Test();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在文件开头使用 import 引用包中的类&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import bookexample.Test;&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 06 Jun 2019 13:37:00 +0000</pubDate>
<dc:creator>韭菜Java</dc:creator>
<og:description>对象概念 一切皆是对象。把现实世界中的对象抽象地体现在编程世界中，一个对象代表了某个具体的操作。一个个对象最终组成了完整的程序设计，这些对象可以是独立存在的，也可以是从别的对象继承过来的。对象之间通过</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lilinfeng/p/10986993.html</dc:identifier>
</item>
<item>
<title>跨域请求中常见的几个问题 - guoew</title>
<link>http://www.cnblogs.com/guoew/p/10986125.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/guoew/p/10986125.html</guid>
<description>&lt;p&gt;&lt;strong&gt;CORS:&lt;/strong&gt; 跨域资源共享(CORS) 是一种机制，它使用额外的 HTTP头来告诉浏览器  让运行在一个 origin (domain) 上的Web应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器不同的域、协议或端口请求一个资源时，资源会发起一个跨域 HTTP 请求。&lt;/p&gt;
&lt;p&gt;出于安全原因，浏览器限制从脚本内发起的跨源HTTP请求。 例如，XMLHttpRequest和Fetch API遵循同源策略。 这意味着使用这些API的Web应用程序只能从加载应用程序的同一个域请求HTTP资源，除非响应报文包含了正确CORS响应头。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;origin：&lt;/strong&gt; web的origin 被定义为由协议，域和端口组成的 URL访问。仅当协议，域和端口全部匹配，两对象才具有相同的origin。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Access-Control-Allow-Origin：&lt;/strong&gt; 该响应是否可以与来自给定的请求代码共享origin。  &lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Access-Control-Allow-Origin：*  #允许任何源的代码访问资源
Access-Control-Allow-Origin: https://developer.mozilla.org  #允许请求来自https://developer.mozilla.org 的代码访问资源。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Access-Control-Allow-Methods:&lt;/strong&gt; 在对preflight request(预检请求)的应答中明确了客户端所要访问的资源允许使用的方法或方法列表&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Access-Control-Allow-Methods POST,GET,OPTIONS,PUT&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Access-Control-Allow-Headers:&lt;/strong&gt;  用于preflight request(预检请求)种，列出了将会在正式请求的Access-Control-Expose-Headers 字段中出现的首部信息，用于响应包含在Access-Control-Request-Headers 首部的预检请求。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Access-Control-Allow-Headers Content-Type,access-control-allow-credentials,access-control-allow-origin&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Access-Control-Max-Age:&lt;/strong&gt; 这个响应首部表示preflight request(预检请求)的返回结果（即 Access-Control-Allow-Methods 和Access-Control-Allow-Headers 提供的信息） 可以被缓存多久。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Access-Control-Max-Age: 600 #&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;CORS中的预检请求（option）:&lt;/strong&gt; 在 CORS 中，可以使用 OPTIONS 方法发起一个预检请求(一般都是浏览检测到请求跨域时，会自动发起)，以检测实际请求是否可以被服务器所接受。预检请求报文中的 Access-Control-Request-Method首部字段告知服务器实际请求所使用的 HTTP 方法；Access-Control-Request-Headers 首部字段告知服务器实际请求所携带的自定义首部字段。服务器基于从预检请求获得的信息来判断，是否接受接下来的实际请求。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;OPTIONS /resources/post-here/ HTTP/1.1
Host: bar.other
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-us,en;q=0.5
Accept-Encoding: gzip,deflate
Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7
Connection: keep-alive
Origin: http://foo.example
Access-Control-Request-Method: POST
Access-Control-Request-Headers: X-PINGOTHER, Content-Type&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;服务器所返回的 Access-Control-Allow-Methods 首部字段将所有允许的请求方法告知客户端。该首部字段与 Allow 类似，但只能用于涉及到 CORS 的场景中。&lt;/p&gt;
&lt;p&gt;想要了解更多的http header信息 请访问 &lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers&quot; class=&quot;uri&quot;&gt;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;二.-跨域常见问题排查cors场景&quot;&gt;二. 跨域常见问题排查(CORS场景)&lt;/h2&gt;
&lt;h3 id=&quot;未配置access-control-allow-origin&quot;&gt;2.1. 未配置 Access-Control-Allow-Origin。&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;Access to XMLHttpRequest at 'http://foo1.example.com/' from origin 'http://foo2.example.com/' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解决方法： 在域为foo1.example.com 的虚拟主机添加 Access-Control-Allow-Origin 值为http://foo2.example.com。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;server {
    ...
    server_name foo1.example.com;
    ...
    add_header 'Access-Control-Allow-Origin' 'http://foo2.example.com';
    add_header Access-Control-Allow-Methods 'GET, POST, OPTIONS';

    if ($request_method = &quot;OPTIONS&quot;)  {
        return 204;
    }
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;跨域访问&quot;&gt;2.2. 跨域访问&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;Access to XMLHttpRequest at 'http://foo1.example.com/' from origin 'http://foo3.example.com/' has been blocked by CORS policy: The 'Access-Control-Allow-Origin' header has a value 'http://foo2.example.com/' that is not equal to the supplied origin.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt; 解决方法：请注意观察上述报错, Access-Control-Allow-Origin 已经至少有一个值为http://foo2.example.com 的设定。所以现在配置一个允许多源访问的配置。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;server {
    ...
    server_name foo1.example.com;
    ...
    if ( $http_origin ~ .*.(example|aldwx).(net|com)) {
        set $other_domain $http_origin;
    }

    add_header Access-Control-Allow-Origin $other_domain;
    add_header Access-Control-Allow-Methods 'GET, POST, OPTIONS';

    if ($request_method = &quot;OPTIONS&quot;)  {
        return 204;
    }
    ...
}&lt;/code&gt;
&lt;/pre&gt;

&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;Access to XMLHttpRequest at 'http://foo1.example.com/' from origin 'http://foo2.example.com/' has been blocked by CORS policy: Request header field &amp;lt;u&amp;gt;cookies&amp;lt;/u&amp;gt; is not allowed by Access-Control-Allow-Headers in preflight response.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解决方法： 遇到这一类的问题时，需要仔细阅读报错，在报错里面基本已经写明了答案。例如上面的这个报错信息。域foo2.example.com 请求域foo1.example.com 时，因首部cookies 未包含在 Access-Control-Allow-Headers 中，所有foo1无法响应客户端请求。并且这一类问题可能同时会出现几个首部缺失的请求，但是报错是单个出现，所以呢，要仔细阅读错误。下面也是其中一个报错&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;Access to XMLHttpRequest at 'http://foo1.example.com/' from origin 'http://foo2.example.com/' has been blocked by CORS policy: Request header field &amp;lt;u&amp;gt;access-control-allow-credentials&amp;lt;/u&amp;gt; is not allowed by Access-Control-Allow-Headers in preflight response.&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;server {
    ...
    server_name foo1.example.com;
    ...
     
    if ( $http_origin ~ .*.(example|aldwx).(net|com)) {
        set $other_domain $http_origin;
    }

    add_header Access-Control-Allow-Origin $other_domain;
    add_header Access-Control-Allow-Methods 'GET, POST, OPTIONS';
    add_header Access-Control-Allow-Headers 'access-control-allow-credentials,cookies,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization';

    if ($request_method = &quot;OPTIONS&quot;)  {
        return 204;
    }
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;参考文章：&lt;br/&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000012550346&quot;&gt;Nginx配置跨域请求 Access-Control-Allow-Origin *&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers&quot; class=&quot;uri&quot;&gt;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 06 Jun 2019 10:43:00 +0000</pubDate>
<dc:creator>guoew</dc:creator>
<og:description>一. Header相关的几个概念 CORS: 跨域资源共享(CORS) 是一种机制，它使用额外的 HTTP头来告诉浏览器 让运行在一个 origin (domain) 上的Web应用被准许访问来自不同</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/guoew/p/10986125.html</dc:identifier>
</item>
<item>
<title>解决基于TypeScript 的 RN项目相对路径引入组件的问题 - 沉淀的风</title>
<link>http://www.cnblogs.com/xyb0226/p/10986338.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xyb0226/p/10986338.html</guid>
<description>&lt;p&gt;&lt;span&gt;在开发RN项目时，经常会要使用这样的方式(../../../)来引入组件，感觉非常繁琐，如果项目结构层级比较多，引入的头部更加分不清. 那有没有一种方案和vue项目一样，经过配置后简写路径，在引入的时候，直接使用，例如vue项目中 @ 符号表示 src目录. 经过百度后，发现还是有这种类似的配置. 但尝试过网上的几种方案，都没起作用，主要是由于我的项目是基于 RN(0.59.5) + TypeScript搭建的。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;1. 在文件夹中加入 package.json&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;例如你想引入utils里面的文件，不想../../../..，这样引入，而是想@utils/.....这样引入，那么你就可以在utils文件中放一个package.json，里面如下&lt;strong&gt;：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;
&lt;p&gt;&lt;span&gt;{&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;     name:&quot;&lt;span&gt;@utils&lt;/span&gt;&quot;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;该方案，我尝试之后没有成功，项目中的 ts文件有规则校验，会有错误提示，找不到该模块。 如果不是用TypeScript构建的项目，我想是可以的。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;2. &lt;span&gt;安装 babel-plugin-root-import&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;这种方案，网上搜索是最多的. 网上所描述的具体实现，这里不撰写了，反正我按照网上的步骤配置，没有成功。估计也是只适合于ES6构建的项目。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;以上两种方案，参考 &lt;a href=&quot;https://www.cnblogs.com/c2016c/articles/9586161.html&quot;&gt;react-native 相对项目路径导入组件&lt;/a&gt;, 感谢&lt;a href=&quot;https://www.cnblogs.com/c2016c/articles/9586161.html&quot;&gt;暖暖的风儿&lt;/a&gt; 给我提供了些思路&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;3. 使用@providesModule&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;在文件的顶部，嵌套一个多行注释，把@providesModule放在注释里,@providesModule后添加类名,以后就直接使用类名就能导入了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意，带有@providesModule的多行注释，一定要是文件的第一个多行注释。如:&lt;/span&gt;&lt;/p&gt;
&lt;ol readability=&quot;3&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;span&gt;/**&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt; * @providesModule Common&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt; */&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;import {&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    Dimensions&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;} from 'react-native';&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;export &lt;span&gt;default&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Common {&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;static&lt;/span&gt; bgColor = 'rgb(232,232,232)';&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;static&lt;/span&gt; screenW = Dimensions.&lt;span&gt;get&lt;/span&gt;('window').width;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;static&lt;/span&gt; screenH = Dimensions.&lt;span&gt;get&lt;/span&gt;('window').height;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;外部使用Common&lt;/span&gt;&lt;/p&gt;
&lt;ol readability=&quot;2.1696696696697&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;// 以前需要这样&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;// import Common from './../Common/Common'&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;

&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;// 现在可以直接用类名&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3.2380952380952&quot;&gt;
&lt;p&gt;&lt;span&gt;import Common from 'Common'&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;尝试之后，ts的校验，还是会报错. 这种方案主要是参考&lt;a href=&quot;https://www.jianshu.com/p/810abc8792be&quot;&gt;ReactNative之解决文件导入路径问题&lt;/a&gt;, 这篇文章中有介绍@providesModule的原理，有兴趣的同学，请拜读。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;4. 使用typescript path mapping设置相对路径&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;因为项目是用TypeScript构建的，在尝试几种错误思路后，然后想TypeScript是不是本来就支持路径设置？确实，TypeScript是支持设置相对路径的. 网上提供的方案&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在 tsconfig.json 中设置&lt;/span&gt;&lt;/p&gt;
&lt;ol readability=&quot;-0.5&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;span&gt;{&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;  &quot;&lt;span&gt;baseUrl&lt;/span&gt;&quot;: &quot;&lt;span&gt;./&lt;/span&gt;&quot;,&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;  &quot;&lt;span&gt;path&lt;/span&gt;&quot;: {&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;    &quot;&lt;span&gt;@http/*&lt;/span&gt;&quot;: [&quot;&lt;span&gt;src/http/*&lt;/span&gt;&quot;],&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &quot;&lt;span&gt;@utils/*&lt;/span&gt;&quot;: [&quot;&lt;span&gt;src/utils/*&lt;/span&gt;&quot;]&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;  }&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;这样在 import 的时候就不用使用一长串的 ../../../.. 这种形式了，直接使用相对短路径&lt;/span&gt;&lt;/p&gt;
&lt;ol readability=&quot;2.3705179282869&quot;&gt;&lt;li readability=&quot;7.5856573705179&quot;&gt;
&lt;p&gt;&lt;span&gt;import {AuthService} from '@http/Auth';&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;采用这种方案之后，在ts文件中的校验不报错了，也能直接链接到对应的申明。但编译为javascript后，路径并没有映射过去，生成apk的时候报错，提示找不到对应的模块。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;至此，我已发现，只要解决此编译问题，那么就能解决了。但是发现没有这么简单，后又尝试了引入 &lt;a href=&quot;https://www.npmjs.com/package/module-alias&quot;&gt;module-alias&lt;/a&gt;, &lt;a href=&quot;https://www.npmjs.com/package/@momothepug/tsmodule-alias&quot;&gt;tsmodule-alias&lt;/a&gt;等插件来解决此编译问题都没有成功，估计是没有用正确。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;span&gt;轮番尝试以上的几种错误方案后，反复搞了一天，心累了。哎，还好没有最终放弃，在上述的第2种方案中，我引入了&lt;span&gt;babel-plugin-root-import插件， 发现可以使用某个符号替代路径.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;1.安装 babel-plugin-root-import&lt;/span&gt;&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span&gt;&lt;span&gt;npm install babel-plugin-root-import --save-dev  &lt;/span&gt;或&lt;span&gt; yarn add babel-plugin-root-import –dev
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;span&gt;如果 npm 没有安装成功，就用 yarn (我是使用yarn 才安装成功)&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;2.babel.config.js 增加如下配置&lt;/span&gt;&lt;/h2&gt;
&lt;ol readability=&quot;1&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;span&gt;module.exports = {&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;  plugins: [&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    [&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;      'babel-plugin-root-import',&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;      {&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;        rootPathPrefix: '~', &lt;span&gt;// `~` 默认&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;        rootPathSuffix: 'src'&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;      }&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    ]&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;  ]&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;这里，我尝试过rootPathPrefix 用 @ ， 在编译的时候会报错。所以不得不放弃使用@ (有些强迫症，想要用@, 因为vue项目中就是@表示src目录)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/575819/201906/575819-20190606180405750-850225949.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;3.执行npm start -- --reset-cache命令&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;已有项目，记得执行此命令清理缓存，这点非常重要，我在调试的过程中，变更过几次符号的配置，如果变更配置后没有执行该命令，则配置不起作用&lt;/span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;4.&lt;/span&gt; 设置typescript相对路径&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;在 tsconfig.json 中设置&lt;/span&gt;&lt;/p&gt;
&lt;ol readability=&quot;-1.5&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;span&gt; {&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt; &quot;&lt;span&gt;baseUrl&lt;/span&gt;&quot;: &quot;&lt;span&gt;./&lt;/span&gt;&quot;,&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;  &quot;&lt;span&gt;path&lt;/span&gt;&quot;: {&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;    &quot;&lt;span&gt;~/*&lt;/span&gt;&quot;: [&quot;&lt;span&gt;src /*&lt;/span&gt;&quot;],&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;  }&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;注意:变更设置之后，最好重启下VSCode&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;至此，我们在项目中引入文件可以用以下优雅的方式&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;import { UserAccount } from '&lt;span&gt;~/constants/const&lt;/span&gt;'&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;import MyTheme from '&lt;span&gt;~/assets/commonStyle&lt;/span&gt;'&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;span&gt;项目是使用 TypeScript + Dva构建的RN项目，该问题网上给出的一些方案都是基于 ES6构建的RN项目，所以之前的解决方案，都不适应。再加上我学习TypeScript 和 RN的时间不长，很多理论知识学习不到位。所以花了比较长的时间。我正在搭建基于TypeScript + Dva + RN + React-Navigation 的App开发框架，欢迎有兴趣的同学一起交流。后续，也会把我搭建的项目框架，进行开源, 目前还只实现了一些基础建设，哈哈~~。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以下是我项目框架的目录:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/575819/201906/575819-20190606180406526-59896496.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 06 Jun 2019 10:04:00 +0000</pubDate>
<dc:creator>沉淀的风</dc:creator>
<og:description>一、前言 在开发RN项目时，经常会要使用这样的方式(../../../)来引入组件，感觉非常繁琐，如果项目结构层级比较多，引入的头部更加分不清. 那有没有一种方案和vue项目一样，经过配置后简写路径，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xyb0226/p/10986338.html</dc:identifier>
</item>
</channel>
</rss>