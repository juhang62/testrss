<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>跟我学SpringCloud | 第二十章：Spring Cloud 之 okhttp - 极客挖掘机</title>
<link>http://www.cnblogs.com/babycomeon/p/11588751.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/babycomeon/p/11588751.html</guid>
<description>&lt;h2 id=&quot;什么是-okhttp&quot;&gt;1. 什么是 okhttp ？&lt;/h2&gt;
&lt;p&gt;okhttp 是由 square 公司开源的一个 http 客户端。在 Java 平台上，Java 标准库提供了 HttpURLConnection 类来支持 HTTP 通讯。不过 HttpURLConnection 本身的 API 不够友好，所提供的功能也有限。大部分 Java 程序都选择使用 Apache 的开源项目 HttpClient 作为 HTTP 客户端。Apache HttpClient 库的功能强大，使用率也很高。&lt;/p&gt;
&lt;h2 id=&quot;为什么要使用-okhttp&quot;&gt;2. 为什么要使用 okhttp ？&lt;/h2&gt;
&lt;p&gt;okhttp 的设计初衷就是简单和高效，这也是我们选择它的重要原因之一。它的优势如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;支持 HTTP/2 协议。&lt;/li&gt;
&lt;li&gt;允许连接到同一个主机地址的所有请求，提高请求效率。&lt;/li&gt;
&lt;li&gt;共享Socket，减少对服务器的请求次数。&lt;/li&gt;
&lt;li&gt;通过连接池，减少了请求延迟。&lt;/li&gt;
&lt;li&gt;缓存响应数据来减少重复的网络请求。&lt;/li&gt;
&lt;li&gt;减少了对数据流量的消耗。&lt;/li&gt;
&lt;li&gt;自动处理GZip压缩。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;实战目标&quot;&gt;3. 实战目标&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Feign 中使用 okhttp 替代 httpclient&lt;/li&gt;
&lt;li&gt;Zuul 中使用 okhttp 替代 httpclient&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;在-feign-中使用-okhttp&quot;&gt;4. 在 Feign 中使用 okhttp&lt;/h2&gt;
&lt;p&gt;首先介绍一下工程结构，本演示工程包含 provider-server、consumer-server、eureka-server 和 zuul-server 。&lt;/p&gt;
&lt;h3 id=&quot;consumer-server-依赖-pom.xml-如下&quot;&gt;4.1 consumer-server 依赖 pom.xml 如下：&lt;/h3&gt;
&lt;p&gt;代码清单：chapter19/consumer-server/pom.xml&lt;br/&gt;***&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-client&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-cloud-starter-openfeign&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;io.github.openfeign&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;feign-okhttp&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;feign-okhttp&lt;/code&gt; 这里无需指定版本，目前引入的 &lt;code&gt;feign-okhttp&lt;/code&gt; 版本为 10.2.3 ，而 &lt;code&gt;okhttp&lt;/code&gt; 的版本为 3.8.1 ,如图：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201909/908359-20190926084533649-1883163436.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;配置文件-application.yml&quot;&gt;4.2 配置文件 application.yml&lt;/h3&gt;
&lt;p&gt;代码清单：chapter19/consumer-server/src/main/resources/application.yml&lt;br/&gt;***&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;feign:
  httpclient:
    enabled: false
  okhttp:
    enabled: true&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;在配置文件中需关闭 feign 对 httpclient 的使用并开启 okhttp 。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;配置类-okhttpconfig.java&quot;&gt;4.3 配置类 OkHttpConfig.java&lt;/h3&gt;
&lt;p&gt;代码清单：chapter19/consumer-server/src/main/java/com/springcloud/consumerserver/config/OkHttpConfig.java&lt;br/&gt;***&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Configuration
@ConditionalOnClass(Feign.class)
@AutoConfigureBefore(FeignAutoConfiguration.class)
public class OkHttpConfig {

    @Bean
    public OkHttpClient okHttpClient(){
        return new OkHttpClient.Builder()
                .connectTimeout(30, TimeUnit.SECONDS)
                .readTimeout(30, TimeUnit.SECONDS)
                .writeTimeout(30, TimeUnit.SECONDS)
                .retryOnConnectionFailure(true)
                .connectionPool(new ConnectionPool(10 , 5L, TimeUnit.MINUTES))
                .addInterceptor(new OkHttpLogInterceptor())
                .build();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;在配置类中将 &lt;code&gt;OkHttpClient&lt;/code&gt; 注入 Spring 的容器中，这里我们指定了连接池的大小，最大保持连接数为 10 ，并且在 5 分钟不活动之后被清除。&lt;/li&gt;
&lt;li&gt;笔者这里配置了一个 okhttp 的日志拦截器。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;日志拦截器-okhttploginterceptor.java&quot;&gt;4.4 日志拦截器 OkHttpLogInterceptor.java&lt;/h3&gt;
&lt;p&gt;代码清单：&lt;br/&gt;***&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Slf4j
public class OkHttpLogInterceptor implements Interceptor {
    @Override
    public Response intercept(Chain chain) throws IOException {
        log.info(&quot;OkHttpUrl : &quot; + chain.request().url());
        return chain.proceed(chain.request());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;这里实现的接口是 &lt;code&gt;okhttp3.Interceptor&lt;/code&gt; ，并不是 Spring Boot 中的 Interceptor。&lt;/li&gt;
&lt;li&gt;笔者这里仅简单打印了 okhttp 请求的路径，如果有业务校验权限等需求可以放在拦截器中实现。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;远程 Feign 调用代码略过，有需要的读者可以访问 Github 仓库获取。&lt;/p&gt;
&lt;h2 id=&quot;在-zuul-中使用-okhttp&quot;&gt;5. 在 Zuul 中使用 okhttp&lt;/h2&gt;
&lt;h3 id=&quot;pom.xml-加入-okhttp-依赖&quot;&gt;5.1 pom.xml 加入 okhttp 依赖&lt;/h3&gt;
&lt;p&gt;代码清单：chapter19/zuul-server/pom.xml&lt;br/&gt;***&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;io.github.openfeign&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;feign-okhttp&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;配置文件开启-okhttp&quot;&gt;5.2 配置文件开启 okhttp&lt;/h3&gt;
&lt;p&gt;代码清单：chapter19/zuul-server/src/main/resources/application.yml&lt;br/&gt;***&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ribbon:
  http:
    client:
      enabled: false
  okhttp:
    enabled: true&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;因为 Zuul 的负载均衡实现是通过 Ribbon 实现的，所以 Http 客户端的配置自然也是对 Ribbon 组件的配置。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;测试&quot;&gt;6. 测试&lt;/h2&gt;
&lt;p&gt;我们修改 idea 启动配置，分别在 8000 和 8001 端口启动 provider-server ，并且顺次启动其余工程，打开浏览器访问链接：http://localhost:8080/consumer/hello ，多次刷新，可以看到 &lt;code&gt;Hello Spring Cloud! Port : 8000&lt;/code&gt; 和 &lt;code&gt;Hello Spring Cloud! Port : 8001&lt;/code&gt; 交替书出现，可以证明负载均衡已经成功，可以查看 consumer-server 的日志，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;2019-09-23 23:15:27.097  INFO 10536 --- [nio-9000-exec-5] c.s.c.intercepter.OkHttpLogInterceptor   : OkHttpUrl : http://host.docker.internal:8001/hello
2019-09-23 23:15:27.593  INFO 10536 --- [nio-9000-exec-6] c.s.c.intercepter.OkHttpLogInterceptor   : OkHttpUrl : http://host.docker.internal:8000/hello
2019-09-23 23:15:27.942  INFO 10536 --- [nio-9000-exec-7] c.s.c.intercepter.OkHttpLogInterceptor   : OkHttpUrl : http://host.docker.internal:8001/hello
2019-09-23 23:15:28.251  INFO 10536 --- [nio-9000-exec-9] c.s.c.intercepter.OkHttpLogInterceptor   : OkHttpUrl : http://host.docker.internal:8000/hello
2019-09-23 23:15:47.877  INFO 10536 --- [nio-9000-exec-8] c.s.c.intercepter.OkHttpLogInterceptor   : OkHttpUrl : http://host.docker.internal:8001/hello&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到我们刚才自定义的日志正常打印，证明现在访问确实是通过 okhttp 来进行访问的。&lt;/p&gt;
&lt;h2 id=&quot;示例代码&quot;&gt;7. 示例代码&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/meteor1993/SpringCloudLearning/tree/master/chapter19&quot; title=&quot;示例代码-Github&quot;&gt;示例代码-Github&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/inwsy/SpringCloudLearning/tree/master/chapter19&quot; title=&quot;示例代码-Gitee&quot;&gt;示例代码-Gitee&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 26 Sep 2019 00:46:00 +0000</pubDate>
<dc:creator>极客挖掘机</dc:creator>
<og:description>1. 什么是 okhttp ？ okhttp 是由 square 公司开源的一个 http 客户端。在 Java 平台上，Java 标准库提供了 HttpURLConnection 类来支持 HTTP</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/babycomeon/p/11588751.html</dc:identifier>
</item>
<item>
<title>Spring Boot(二) 配置文件 - 崖边小生</title>
<link>http://www.cnblogs.com/hunternet/p/11588734.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hunternet/p/11588734.html</guid>
<description>&lt;h4 id=&quot;文章导航-readme&quot;&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/hunternet/p/11582577.html&quot;&gt;文章导航-readme&lt;/a&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;h3 id=&quot;一配置spring-boot热部署&quot;&gt;一、配置Spring Boot热部署&lt;/h3&gt;
&lt;p&gt;    技术的发展总是因为人们想偷懒的心理，如果我们不想每次修改了代码，都必须重启一下服务器，并重新运行代码。那么可以配置一下热部署。有了它之后，修改了代码只需要重新build一下，就可以看到效果了，不需要重启服务器。&lt;/p&gt;
&lt;h4 id=&quot;配置热部署&quot;&gt;1.配置热部署&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;pom.xml文件中添加如下依赖：&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-devtools&amp;lt;/artifactId&amp;gt;                                        &amp;lt;optional&amp;gt;true&amp;lt;/optional&amp;gt;
        &amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;修改pom.xml文件&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt; &amp;lt;build&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
                &amp;lt;configuration&amp;gt;
                    &amp;lt;!--开启热部署--&amp;gt;
                    &amp;lt;fork&amp;gt;true&amp;lt;/fork&amp;gt;
                &amp;lt;/configuration&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改pom.xml文件后，idea会弹出一个让你自动导入包的文件，点击&lt;code&gt;Import Changes&lt;/code&gt;。就会自动将jar包下载到依赖库中。&lt;/p&gt;
&lt;p&gt;如此，就实现了Spring Boot的热部署，此时修改我们的代码，只需重新Build一下就可以了。&lt;/p&gt;
&lt;h4 id=&quot;配置自动build&quot;&gt;2. 配置自动build&lt;/h4&gt;
&lt;p&gt;当然，如果你更懒的话，练build都不想做，也可以在Idea中配置自动Build(自动Build仅支持Spring Boot项目)。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;打开Idea-&amp;gt;File-&amp;gt;Settings...可以看到如下界面&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://hunter-image.oss-cn-beijing.aliyuncs.com/spring-boot/Spring%20Boot%28%E4%BA%8C%29%20%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/1.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选中上图中的&lt;code&gt;Build Project automatical&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;按组合键&lt;code&gt;Shift+ALT+Ctrl+/&lt;/code&gt;选择&lt;code&gt;Registry&lt;/code&gt;可以看到如下界面&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://hunter-image.oss-cn-beijing.aliyuncs.com/spring-boot/Spring%20Boot%28%E4%BA%8C%29%20%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/2.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选中上图中的&lt;code&gt;complier.automake.allow.when.app.running&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如此，修改我们的代码后，无需重新build也无需重新重启。&lt;/p&gt;
&lt;h3 id=&quot;二spring-boot读取配置文件&quot;&gt;二、Spring Boot读取配置文件&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;修改我们的配置文件&lt;code&gt;application.properties&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;server.port=8888

&amp;lt;!--网站配置--&amp;gt;
website.name=Loading
website.domin=www.loading.ink
website.title=我的博客网站
website.description=分享我的生活和技术&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;新建配置文件类&lt;code&gt;WebSiteConfig&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package spring.boot.web.config;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.PropertySource;

import java.text.MessageFormat;

@Configuration
//@ConfigurationProperties(prefix = &quot;website&quot;)
//要读取的配置文件地址
@PropertySource(value = &quot;classpath:application.properties&quot;)
public class WebSiteConfig {
    @Value(&quot;${website.title}&quot;)
    private String title;
    @Value(&quot;${website.domain}&quot;)
    private String domain;
    @Value(&quot;${website.description}&quot;)
    private String description;

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public String getDomain() {
        return domain;
    }

    public void setDomain(String domain) {
        this.domain = domain;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    @Override
    public String toString() {
        return MessageFormat.format(&quot;Title:{0} Domin:{1} Description:{2}&quot;, title, domain, description);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;读取配置文件中的配置有两种方式&lt;/p&gt;
&lt;p&gt;1.&lt;code&gt;@ConfigurationProperties(prefix = &quot;website&quot;)&lt;/code&gt;用于绑定属性，其中prefix表示所绑定的属性的前缀。如果配置文件中的配置和属性名一致可以用此种方式&lt;/p&gt;
&lt;p&gt;2.&lt;code&gt;@Value(&quot;${website.title}&quot;)&lt;/code&gt; 绑定配置文件中的属性&lt;/p&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;p&gt;注解&lt;code&gt;@Configuration&lt;/code&gt;用于定义配置类&lt;/p&gt;
&lt;p&gt;注解&lt;code&gt;@PropertySource(value = &quot;classpath:application.properties&quot;)&lt;/code&gt;代表要读取配置文件的路径当配置文件是&lt;code&gt;application.properties&lt;/code&gt;时，这个注解可以省略不写&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;新建&lt;code&gt;WebSiteController&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package spring.boot.web.controller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RestController;
import spring.boot.web.config.WebSiteConfig;

@RequestMapping(&quot;/website&quot;)
@RestController
public class WebSiteController {

    //通过@Autowired注解注入bean
    @Autowired
    private WebSiteConfig webSiteConfig;

    @RequestMapping(method = RequestMethod.GET)
    public String get() {
        return webSiteConfig.toString();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;测试运行&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://hunter-image.oss-cn-beijing.aliyuncs.com/spring-boot/Spring%20Boot%28%E4%BA%8C%29%20%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/4.png&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;注意,如果第一次运行时遇到读取配置文件里的中文乱码的问题。其主要原因可能是因为配置文件的格式并不是utf-8的格式。此时可在idea中进行设置。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://hunter-image.oss-cn-beijing.aliyuncs.com/spring-boot/Spring%20Boot%28%E4%BA%8C%29%20%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/3.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图所示更改为&lt;code&gt;uft-8&lt;/code&gt;，注意后面的一定要勾选上。&lt;/p&gt;
&lt;p&gt;通过上面配置后如果还不行，可以将配置文件删除后重新建一个，问题就可以解决！&lt;/p&gt;
&lt;h3 id=&quot;三spring-boot-profile&quot;&gt;三、Spring Boot Profile&lt;/h3&gt;
&lt;p&gt;    Spring Boot 使用一个全局的配置文件 &lt;code&gt;application.properties&lt;/code&gt; ，Spring Boot 的全局配置文件的作用是对一些默认配置的配置值进行修改。&lt;/p&gt;
&lt;p&gt;    在日常开发中，我们常常会遇到一个问题。就是在不同的环境使用不同的配置。比如生产、开发、测试三个不同的环境，我们的配置肯定不一样。这时，我们就要用到Profile。&lt;/p&gt;
&lt;p&gt;    &lt;code&gt;Profile&lt;/code&gt; 是 Spring 用来针对不同的环境对不同的配置提供支持的，全局 &lt;code&gt;Profile&lt;/code&gt; 配置使用 &lt;code&gt;application-{profile}.properties&lt;/code&gt;（如 &lt;code&gt;application-dev.properties&lt;/code&gt;）。通过在 &lt;code&gt;application.properties&lt;/code&gt; 中设置 &lt;code&gt;spring.profiles.active = dev&lt;/code&gt; 来指定活动的 &lt;code&gt;Profile&lt;/code&gt;。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;依次再目录下面新建三个配置文件，&lt;code&gt;application-dev.properties&lt;/code&gt;、&lt;code&gt;application-test.properties&lt;/code&gt;、&lt;code&gt;application-prod.properties&lt;/code&gt;。它们分别代表开发环境、测试环境、生产环境的配置文件。&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;server.port=8887

website.title=我的博客网站--Dev
website.domain=www.loading.ink
website.description=分享我的技术与生活&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;server.port=8886

website.title=我的博客网站--test
website.domain=www.loading.ink
website.description=分享我的技术与生活&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;server.port=8885

website.title=我的博客网站--prod
website.domain=www.loading.ink
website.description=分享我的技术与生活&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;接下来修改&lt;code&gt;application.properties&lt;/code&gt;：表示，将采用application-dev.properties这个配置文件。&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;spring.profiles.active=dev
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试运行我们可以看到会启动开发环境配置文件的端口8887&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：配置文件会优先获取&lt;code&gt;Profile&lt;/code&gt;中的配置，如果&lt;code&gt;Profile&lt;/code&gt;中没有的配置项， 那么会直接取&lt;code&gt;application.properties中&lt;/code&gt;的配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/hunter-droid/spring-boot-examples&quot;&gt;示例代码&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 26 Sep 2019 00:40:00 +0000</pubDate>
<dc:creator>崖边小生</dc:creator>
<og:description>'文章导航 readme' 一、配置Spring Boot热部署 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;技术的发展总是因为人们想偷懒的心理，如果我们不想每次修改了代码，都必须重启一下服务器，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hunternet/p/11588734.html</dc:identifier>
</item>
<item>
<title>使用gdb调试c++程序 - 高胖</title>
<link>http://www.cnblogs.com/gaopang/p/11588683.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gaopang/p/11588683.html</guid>
<description>&lt;p class=&quot;Publishwithline&quot;&gt;&lt;span class=&quot;MsoPlaceholderText&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;上篇(&lt;a href=&quot;https://www.cnblogs.com/gaopang/p/11243367.html&quot; target=&quot;_blank&quot;&gt;使用c++开发跨平台程序&lt;/a&gt;)说到&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;span&gt;我不怕造东西&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;span&gt;我怕的是造出来的东西&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;span&gt;如果出了问题&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;span&gt;我却不知道原因&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;span&gt;所以调试分析是一个重要的手段&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;C++&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;调试是一个复杂的活&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;span&gt;虽然大部分调试可以通过&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;IDE&lt;/span&gt;&lt;span&gt;在开发期间就解决了&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;span&gt;但是必然的&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;span&gt;还有很多东西需要在生产环境中还原它&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;span&gt;分析它&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;span&gt;然后解决它&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.gdb&lt;/span&gt;&lt;span&gt;是一个成熟的工具&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;span&gt;围绕着它有很多的工具可以选择&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;span&gt;不过这么多工具的根本还是命令行模式下的&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;gdb.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;废话不多说&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;span&gt;现在我就用&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;gdb&lt;/span&gt;&lt;span&gt;来分析调试一下吧&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;MsoNoSpacing&quot;&gt;&lt;span class=&quot;2&quot;&gt;&lt;span&gt;&lt;span&gt;生成&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span class=&quot;2&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;dump&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;2&quot;&gt;&lt;span&gt;&lt;span&gt;文件&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;:&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;在&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;shell&lt;/span&gt;&lt;span&gt;中输入命令&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;ulimit -c unlimited;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;然后运行自己的程序&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;span&gt;如果程序此时崩溃&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;span&gt;就会在目录生成一个名为&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;core&lt;/span&gt;&lt;span&gt;的文件&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.(&lt;/span&gt;&lt;span&gt;这个也看系统配置&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;.)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;使用命令&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;gdb Test1 core&lt;/span&gt;&lt;span&gt;加载文件&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;span&gt;或者它的详细命令&lt;/span&gt;&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;gdb -c core -e Test1 --symbols Test1 --readnow&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;下面是一个命令行输出的截图&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1214816/201909/1214816-20190926080256932-1721526646.jpg&quot;&gt;&lt;img title=&quot;clip_image002[10]&quot; src=&quot;https://img2018.cnblogs.com/blog/1214816/201909/1214816-20190926080257388-747959876.jpg&quot; alt=&quot;clip_image002[10]&quot; width=&quot;660&quot; height=&quot;542&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;上图中可以解释的不多&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;span&gt;因为我们现在刚要入门&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;span&gt;所以只能注意上图中的三个红框&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;红框&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;1:&lt;/span&gt;&lt;span&gt;命令行其中&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;app7&lt;/span&gt;&lt;span&gt;是可执行文件&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;span&gt;而&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;core&lt;/span&gt;&lt;span&gt;是&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;dump&lt;/span&gt;&lt;span&gt;文件&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;红框&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;2:&lt;/span&gt;&lt;span&gt;标明&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;gdb&lt;/span&gt;&lt;span&gt;在&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;app7&lt;/span&gt;&lt;span&gt;中找到了它对应的&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;symbol.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;红框&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;3:&lt;/span&gt;&lt;span&gt;标明&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;core&lt;/span&gt;&lt;span&gt;文件是经由&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;app7&lt;/span&gt;&lt;span&gt;产生的&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;span&gt;这里是为了防止载入了错误的可执行文件&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;注意一下几点&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;如果使用&lt;em&gt;&lt;span lang=&quot;EN-US&quot;&gt;sanitize&lt;/span&gt;&lt;/em&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;请取消&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;不然不会在崩溃时产生&lt;span lang=&quot;EN-US&quot;&gt;dump&lt;/span&gt;文件&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;反而是一个错误报告&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;在生成可执行文件的时候&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;应该用&lt;span lang=&quot;EN-US&quot;&gt;debug&lt;/span&gt;模式&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;也可以用&lt;span lang=&quot;EN-US&quot;&gt;RelWithDebInfo&lt;/span&gt;模式&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;主要目的是能够获得程序的调试符号&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;如果没有&lt;span lang=&quot;EN-US&quot;&gt;symbol&lt;/span&gt;信息&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;也可以调试&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;但是过程将会难上很多倍&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;毕竟我们是调试&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;不是破解&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;不过&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;span&gt;还别说&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,gdb&lt;/span&gt;&lt;span&gt;调试跟破解其实还是有点相通的&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;由于&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;gdb&lt;/span&gt;&lt;span&gt;调试有非常多指令&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;span&gt;从时效性上来说&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;span&gt;不需要记住全部指令&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;span&gt;只需要知道常用的指令就好&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;span&gt;就算有人费事费力记住了所有指令&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;span&gt;时间一长&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;span&gt;如果不用的话也是会忘记的&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;span&gt;所以能看到英文文档&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;span&gt;我觉得比记住指令更有用&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;大部分错误在&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;IDE&lt;/span&gt;&lt;span&gt;开发期间就已经被解决了&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;span&gt;需要调试&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;core dump&lt;/span&gt;&lt;span&gt;文件的情况一般都是运行的时候出现的错误&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;我这里简单介绍以下几类&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;指针为&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;NULL.&lt;/span&gt;&lt;span&gt;栈溢出&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;span&gt;除数为&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;0,&lt;/span&gt;&lt;span&gt;死锁&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;span&gt;调试指针为&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;NULL&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;下面给定一个程序&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;span&gt;程序的内容如下&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
#include &amp;lt;stdlib.h&amp;gt;
void bar(int* p)
{
    int aa=*p;
}
void foo()
{
    int* p=NULL;
    bar(p);
}
int main(int argc, const char * argv[])
{
    foo();
    return 0;
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;编译后假设输出是&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;app0,&lt;/span&gt;&lt;span&gt;运行&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;app0&lt;/span&gt;&lt;span&gt;后会有&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;core&lt;/span&gt;&lt;span&gt;文件&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;span&gt;现在我来加载这个&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;core&lt;/span&gt;&lt;span&gt;文件&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;span&gt;截图如下&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1214816/201909/1214816-20190926080257639-1138443168.jpg&quot;&gt;&lt;img title=&quot;clip_image004[10]&quot; src=&quot;https://img2018.cnblogs.com/blog/1214816/201909/1214816-20190926080257816-1366963258.jpg&quot; alt=&quot;clip_image004[10]&quot; width=&quot;554&quot; height=&quot;36&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1214816/201909/1214816-20190926080258010-702682280.jpg&quot;&gt;&lt;img title=&quot;clip_image006[10]&quot; src=&quot;https://img2018.cnblogs.com/blog/1214816/201909/1214816-20190926080258239-1777481433.jpg&quot; alt=&quot;clip_image006[10]&quot; width=&quot;554&quot; height=&quot;281&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;加载完毕以后&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;span&gt;可以看到&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;gdb&lt;/span&gt;&lt;span&gt;已经指出来了&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;app0.cpp&lt;/span&gt;&lt;span&gt;地&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;15&lt;/span&gt;&lt;span&gt;行有问题&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;然后我们回到源码&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;span&gt;查看第&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;15&lt;/span&gt;&lt;span&gt;行&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;span&gt;的确是有问题&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;span&gt;所有&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;null&lt;/span&gt;&lt;span&gt;问题已经解决&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;span&gt;是不是简单无比&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;?&lt;/span&gt;&lt;strong&gt;&lt;span&gt;呵呵&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;但是我们要更进一&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;span&gt;看看到底为什么&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;1.&lt;span&gt;&lt;span&gt;      &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;我使用&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;p p,(&lt;/span&gt;&lt;span&gt;第一个&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;p&lt;/span&gt;&lt;span&gt;是&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;print,&lt;/span&gt;&lt;span&gt;是&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;gdb&lt;/span&gt;&lt;span&gt;指令&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;span&gt;第二个&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;p&lt;/span&gt;&lt;span&gt;是参数&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;p);&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1214816/201909/1214816-20190926080258432-1974452178.jpg&quot;&gt;&lt;img title=&quot;clip_image008[10]&quot; src=&quot;https://img2018.cnblogs.com/blog/1214816/201909/1214816-20190926080258629-1001035003.jpg&quot; alt=&quot;clip_image008[10]&quot; width=&quot;189&quot; height=&quot;38&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span&gt;这说明&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;p&lt;/span&gt;&lt;span&gt;是一个&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;0.&lt;/span&gt;&lt;span&gt;所以这里会出错&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;2.&lt;span&gt;&lt;span&gt;      &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;按理说&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;span&gt;以上的分析可以得出结论了&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;span&gt;不过这里我想再进一步&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span&gt;首先我列出&lt;/span&gt; &lt;span&gt;所有线程&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;info thread&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1214816/201909/1214816-20190926081114278-1553892715.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span&gt;就只有一个线程&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;span&gt;很好&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span&gt;其次&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;span&gt;我看看堆栈&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;bt&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1214816/201909/1214816-20190926081136161-489031787.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span&gt;可以看到调用堆栈&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;span&gt;是从&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;foo&lt;/span&gt;&lt;span&gt;函数调用的&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;bar&lt;/span&gt;&lt;span&gt;函数&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;span&gt;所以参数&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;p&lt;/span&gt;&lt;span&gt;是从&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;foo&lt;/span&gt;&lt;span&gt;里产生的&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;　  可以看出&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;span&gt;空引用虽然解决了&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;span&gt;回头考虑一下的话&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;span&gt;这里有点事后诸葛的意思&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;span&gt;有人会问&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;”&lt;/span&gt;&lt;span&gt;你是已经事先知道空引用了&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;span&gt;然后去分析的&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;span&gt;这谁不会&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;…”,&lt;/span&gt;&lt;span&gt;真正的现实当中的空引用的确分析起来比这个困难一点&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;span&gt;不过这个系列是让人们基本会用&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;gdb.&lt;/span&gt;&lt;span&gt;知道每种类型大体长什么样子&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;span&gt;在现实问题中&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;span&gt;分析的时候好有个方向&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;具体工作当中的问题&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;span&gt;只能到时再分析&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;span&gt;调试栈溢出&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;栈溢出一般递归函数退出条件没有达成&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;span&gt;导致的循环调用&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;span&gt;栈溢出调试比较简单&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;span&gt;特征也很明显&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;下面我借用一个例子来说明一下&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;span&gt;这个例子的作者是一个外国人&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;span&gt;具体是谁&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;span&gt;我忘记了&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;49&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;pthread.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
void procF(int i)
{
    int buffer[128] = {-1, 0, i+1, 0, -1};
    procF(buffer[2]);
}
void procE()
{
    procF(1);
}
#define THREAD_DECLARE(num,func) void bar_##num()\
{\
sleep(3);\
func;\
}\
\
void foo_##num()\
{\
bar_##num();\
}\
\
void * thread_##num (void *arg)\
{\
foo_##num();\
\
return 0;\
}
THREAD_DECLARE(one,procE())
THREAD_DECLARE(two,sleep(-1))
THREAD_DECLARE(three,sleep(-1))
THREAD_DECLARE(four,sleep(-1))
THREAD_DECLARE(five,sleep(-1))
#define THREAD_CREATE(num) {pthread_t threadID_##num; pthread_create (&amp;amp;threadID_##num, NULL,thread_##num, NULL);}
int main(int argc, const char * argv[])
{
    THREAD_CREATE(one)
    THREAD_CREATE(two)
    THREAD_CREATE(three)
    THREAD_CREATE(four)
    THREAD_CREATE(five)
    sleep(-1);
    return 0;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt; &lt;/p&gt;

&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;以上文件很简单&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;span&gt;定义了一个宏&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;span&gt;然后使用这个宏&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;span&gt;复制生成了&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;5&lt;/span&gt;&lt;span&gt;个线程&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;span&gt;其中&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;thread_one&lt;/span&gt;&lt;span&gt;这个线程&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;span&gt;会陷入死循环&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;它会在&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;procF&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;中循环调用&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;span&gt;导致一个堆栈溢出&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;我们来看看它长什么样子&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;span&gt;具体怎么加载&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;core&lt;/span&gt;&lt;span&gt;我这里就略过了&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;span&gt;直接看&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;gdb&lt;/span&gt;&lt;span&gt;内容吧&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1214816/201909/1214816-20190926080259579-707089700.jpg&quot;&gt;&lt;img title=&quot;clip_image014[10]&quot; src=&quot;https://img2018.cnblogs.com/blog/1214816/201909/1214816-20190926080259799-1848286310.jpg&quot; alt=&quot;clip_image014[10]&quot; width=&quot;1098&quot; height=&quot;118&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;上面说&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;cannot access memory at address xxx,&lt;/span&gt;&lt;span&gt;然后列出最近执行具体位置是一个大括号,没有什么参考意义&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;1.&lt;span&gt;&lt;span&gt;      &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;我先看看所有线程&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1214816/201909/1214816-20190926080300033-601925763.jpg&quot;&gt;&lt;img title=&quot;clip_image016[10]&quot; src=&quot;https://img2018.cnblogs.com/blog/1214816/201909/1214816-20190926080300329-2021340376.jpg&quot; alt=&quot;clip_image016[10]&quot; width=&quot;918&quot; height=&quot;230&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;6&lt;/span&gt;&lt;span&gt;个线程&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;span&gt;除去第一个是不能能读取内存的错误以为&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;span&gt;其余的都在&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;sleep.&lt;/span&gt;&lt;span&gt;这里按照&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;gdb&lt;/span&gt;&lt;span&gt;的提示(它说procF有问题)&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;span&gt;我先看看&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;thread 1,因为只有它停留在了procF;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;2.&lt;span&gt;&lt;span&gt;      &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;指令&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;thread 1&lt;/span&gt; &lt;span&gt;表示切换到线程&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;1.&lt;/span&gt;&lt;span&gt;然后查看它的堆栈&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;span&gt;看看是如何到达这个procF的&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1214816/201909/1214816-20190926080300601-672093738.jpg&quot;&gt;&lt;img title=&quot;clip_image018[10]&quot; src=&quot;https://img2018.cnblogs.com/blog/1214816/201909/1214816-20190926080300863-484842415.jpg&quot; alt=&quot;clip_image018[10]&quot; width=&quot;1087&quot; height=&quot;235&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span&gt;到这里发现&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;procF&lt;/span&gt;&lt;span&gt;自己调用自己&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;span&gt;按照经验&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;span&gt;这里应该是栈溢出了&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;span&gt;但是为了确认一下&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;span&gt;我决定看看它调用了多少层&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;3.&lt;span&gt;&lt;span&gt;      &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;指令&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;bt&lt;/span&gt;&lt;span&gt;是打印调用堆栈了&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.bt -20&lt;/span&gt;&lt;span&gt;是打印最底层的&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;20&lt;/span&gt;&lt;span&gt;个调用&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1214816/201909/1214816-20190926080301168-87834863.jpg&quot;&gt;&lt;img title=&quot;clip_image020[10]&quot; src=&quot;https://img2018.cnblogs.com/blog/1214816/201909/1214816-20190926080301450-1802706247.jpg&quot; alt=&quot;clip_image020[10]&quot; width=&quot;474&quot; height=&quot;315&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span&gt;发现它调用了&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;15000&lt;/span&gt;&lt;span&gt;次&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;..&lt;/span&gt;&lt;span&gt;这里还有一个好处就是&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;span&gt;可以看到来源&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;span&gt;是从&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;procE&lt;/span&gt;&lt;span&gt;来的&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span&gt;下一步就可以去查看&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;proceE&lt;/span&gt;&lt;span&gt;的内容了&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;span&gt;在&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;gdb&lt;/span&gt;&lt;span&gt;中也是可以做到的&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;span&gt;如下图&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1214816/201909/1214816-20190926080301693-1444780091.jpg&quot;&gt;&lt;img title=&quot;clip_image022[10]&quot; src=&quot;https://img2018.cnblogs.com/blog/1214816/201909/1214816-20190926080301882-759314223.jpg&quot; alt=&quot;clip_image022[10]&quot; width=&quot;446&quot; height=&quot;189&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span&gt;好了&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;span&gt;到此调用栈溢出就解决了&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span&gt;但是&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;span&gt;还是可以在这里展开一下&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;span&gt;我们知道函数的调用是放置在线程的占空间的&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;span&gt;我们从占空间中看看&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;span&gt;有没有什么规律&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span&gt;为了显示栈空间&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;span&gt;需要用到&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;gdb&lt;/span&gt;&lt;span&gt;的一个指令&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;x(&lt;/span&gt;&lt;span&gt;查看&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span&gt;详细观察&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt; bt -20&lt;/span&gt;&lt;span&gt;返回的结果&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;span&gt;可以看到类似如下&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;#14971 0x00005636f87b2c91 in procF (i=1) at /root/clionproject/Test1/dump/app6.cpp:16&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;#14972 0x00005636f87b2cb6 in procE () at /root/clionproject/Test1/dump/app6.cpp:20&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span&gt;其中&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;#14971&lt;/span&gt;&lt;span&gt;是&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;frame&lt;/span&gt;&lt;span&gt;的编号&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span&gt;后边的&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;0x00005636f87b2c91,&lt;/span&gt;&lt;span&gt;是代码在内存中的位置&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;span&gt;即&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;app6.cpp:16&lt;/span&gt;&lt;span&gt;这行所对应的二进制代码就在内存的此位置&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span&gt;gdb搞起&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1214816/201909/1214816-20190926080302092-455454567.jpg&quot;&gt;&lt;img title=&quot;clip_image024[10]&quot; src=&quot;https://img2018.cnblogs.com/blog/1214816/201909/1214816-20190926080302297-1490528640.jpg&quot; alt=&quot;clip_image024[10]&quot; width=&quot;622&quot; height=&quot;136&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;p $rsp&lt;/span&gt; &lt;span&gt;和&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;info r $rsp&lt;/span&gt; &lt;span&gt;代表打印寄存器&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;rsp&lt;/span&gt;&lt;span&gt;里面的值&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;. $rsp&lt;/span&gt;&lt;span&gt;是指向栈顶端的寄存器&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;span&gt;所以它的值就一定是栈顶端&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span&gt;我来检查一下这个栈&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1214816/201909/1214816-20190926080302528-1174216753.jpg&quot;&gt;&lt;img title=&quot;clip_image026[10]&quot; src=&quot;https://img2018.cnblogs.com/blog/1214816/201909/1214816-20190926080302786-1528844793.jpg&quot; alt=&quot;clip_image026[10]&quot; width=&quot;505&quot; height=&quot;649&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;这里主要是引出&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;x&lt;/span&gt;&lt;span&gt;指令&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.x&lt;/span&gt;&lt;span&gt;是查看指定地址的指令&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;span&gt;除数为&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;除数为&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;0&lt;/span&gt;&lt;span&gt;是一个简单的问题&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;span&gt;代码我就不上了&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;载入&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;core&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;文件就会显示&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1214816/201909/1214816-20190926080303043-670747787.jpg&quot;&gt;&lt;img title=&quot;clip_image028[10]&quot; src=&quot;https://img2018.cnblogs.com/blog/1214816/201909/1214816-20190926080303231-504693107.jpg&quot; alt=&quot;clip_image028[10]&quot; width=&quot;476&quot; height=&quot;35&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;说这是一个算术问题&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;span&gt;发生在&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;procD&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;函数中&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;现在我检查一下&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;procD&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;是什么东西&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1214816/201909/1214816-20190926080303441-457719313.jpg&quot;&gt;&lt;img title=&quot;clip_image030[10]&quot; src=&quot;https://img2018.cnblogs.com/blog/1214816/201909/1214816-20190926080303658-1787387935.jpg&quot; alt=&quot;clip_image030[10]&quot; width=&quot;425&quot; height=&quot;200&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;Disass&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;是&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;disassembly&lt;/span&gt; &lt;span&gt;的意思&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;span&gt;指令是打印对应地址的反汇编代码&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;上图中红框处&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;span&gt;就是现在指令所运行的位置&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;span&gt;系统认为在这个位置出错了&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;span&gt;看&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;idivl&lt;/span&gt; &lt;span&gt;它显然是一个除法&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;span&gt;到这里十有八九是除数为零了&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;看到汇编指令&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;idivl&lt;span&gt; &lt;/span&gt; -0x8(%rbp),&lt;/span&gt;&lt;span&gt;其中的&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;-x8(%rbp),&lt;/span&gt;&lt;span&gt;代表一个值&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;span&gt;这个值就是除数&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;span&gt;所以我要把它代表的值找到&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;首先查看一下&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;rbp&lt;/span&gt;&lt;span&gt;是什么东东&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,rbp&lt;/span&gt;&lt;span&gt;是一个寄存器&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;span&gt;它指向了一个&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;base point,&lt;/span&gt;&lt;span&gt;你可以简单的认为所有函数内部申请的栈变量&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;(&lt;/span&gt;&lt;span&gt;比如&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;int a=0&lt;/span&gt;&lt;span&gt;等等&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;),&lt;/span&gt;&lt;span&gt;都是通过&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;rbp&lt;/span&gt;&lt;span&gt;换算的&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1214816/201909/1214816-20190926080303842-1028485685.jpg&quot;&gt;&lt;img title=&quot;clip_image032[10]&quot; src=&quot;https://img2018.cnblogs.com/blog/1214816/201909/1214816-20190926080304023-435706116.jpg&quot; alt=&quot;clip_image032[10]&quot; width=&quot;229&quot; height=&quot;33&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;其次查看一下这个地址&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;-8&lt;/span&gt;&lt;span&gt;是啥&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1214816/201909/1214816-20190926080304204-250593498.jpg&quot;&gt;&lt;img title=&quot;clip_image034[10]&quot; src=&quot;https://img2018.cnblogs.com/blog/1214816/201909/1214816-20190926080304432-932593159.jpg&quot; alt=&quot;clip_image034[10]&quot; width=&quot;222&quot; height=&quot;32&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;既然&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;$rbp-0x8&lt;/span&gt;&lt;span&gt;是一个变量的地址&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;span&gt;那么我们就看看这个地址写的什么值&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1214816/201909/1214816-20190926080304618-318219460.jpg&quot;&gt;&lt;img title=&quot;clip_image036[10]&quot; src=&quot;https://img2018.cnblogs.com/blog/1214816/201909/1214816-20190926080304785-1862198603.jpg&quot; alt=&quot;clip_image036[10]&quot; width=&quot;211&quot; height=&quot;74&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;可以看到它的确是写的&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;0.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;除数为&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;0,&lt;/span&gt;&lt;span&gt;就结束了&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;span&gt;死锁&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;死锁也是一个常见的问题&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;span&gt;不过死锁有个特点&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;span&gt;并不是每一个死锁都会被&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;dump&lt;/span&gt;&lt;span&gt;下来&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;span&gt;所以在遇到死锁的时候&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;span&gt;有时候需要使用在线调试的办法&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;span&gt;不过这个办法&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;现在我使用以下代码 &lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;51&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;pthread.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;mutex&amp;gt;

static int sequence1 = 0;
static int sequence2 = 0;

std::mutex lock1;
std::mutex lock2;

int func1()
{
    lock1.lock();
    sleep(1);
    sequence1++;
    lock2.lock();
    sequence2++;
    lock1.unlock();
    lock2.unlock();
    return sequence1;
}

int func2()
{
    lock2.lock();
    sleep(1);
    sequence2++;
    lock1.lock();
    sequence1++;
    lock2.unlock();
    lock1.unlock();
    return sequence1;
}


void* thread1(void *arg)
{
    int rev = 0;
    while(1)
    {
        rev = func1();

        if (rev == 100000)
        {
            pthread_exit(NULL);
        }
    }
}

void* thread2(void *arg)
{
    int rev = 0;
    while(1)
    {
        rev = func2();

        if (rev == 100000)
        {
            pthread_exit(NULL);
        }
    }
}

void* thread3(void *arg)
{
    int count = 0;
    while(1)
    {
        sleep(1);
        if ( count++ &amp;gt; 10000)
        {
            pthread_exit(NULL);
        }
    }
}

void* thread4(void *arg)
{
    int count = 0;
    while(1)
    {
        sleep(1);
        if ( count++ &amp;gt; 10000)
        {
            pthread_exit(NULL);
        }
    }
}



int main()
{
    pthread_t tid[4];
    if(pthread_create(&amp;amp;tid[0], NULL, &amp;amp; thread1, NULL) != 0)
    {
        _exit(1);
    }
    if(pthread_create(&amp;amp;tid[1], NULL, &amp;amp; thread2, NULL) != 0)
    {
        _exit(1);
    }

    if(pthread_create(&amp;amp;tid[2], NULL, &amp;amp; thread3, NULL) != 0)
    {
        _exit(1);
    }

    if(pthread_create(&amp;amp;tid[3], NULL, &amp;amp; thread4, NULL) != 0)
    {
        _exit(1);
    }
    sleep(5);
    pthread_join(tid[0], NULL);
    pthread_join(tid[1], NULL);
    pthread_join(tid[2], NULL);
    pthread_join(tid[3], NULL);
    return 0;
}

 

 
&lt;/pre&gt;&lt;/div&gt;

&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;以上代码主要集中在&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;func1&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;func2&lt;/span&gt;&lt;span&gt;中&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;span&gt;他们相互等待就有可能会死锁&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;span&gt;现在我编译它运行以下&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1214816/201909/1214816-20190926080304970-1801202733.jpg&quot;&gt;&lt;img title=&quot;clip_image038[10]&quot; src=&quot;https://img2018.cnblogs.com/blog/1214816/201909/1214816-20190926080305177-1814155344.jpg&quot; alt=&quot;clip_image038[10]&quot; width=&quot;579&quot; height=&quot;38&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;由于它只是死锁&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;span&gt;所有在我机器上并没有&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;dump&lt;/span&gt;&lt;span&gt;下来&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;span&gt;我要用&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;gdb,&lt;/span&gt;&lt;span&gt;在线调试它&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;截图如下&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1214816/201909/1214816-20190926080305425-1896574927.jpg&quot;&gt;&lt;img title=&quot;clip_image040[10]&quot; src=&quot;https://img2018.cnblogs.com/blog/1214816/201909/1214816-20190926080305679-276373276.jpg&quot; alt=&quot;clip_image040[10]&quot; width=&quot;1074&quot; height=&quot;457&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;我先用&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;ps&lt;/span&gt;&lt;span&gt;找到了进程&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;id&lt;/span&gt;&lt;span&gt;是&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;14661,&lt;/span&gt;&lt;span&gt;用&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;gdb&lt;/span&gt; &lt;span&gt;附着了它&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;span&gt;现在开始调试了&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;先看&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;thread&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1214816/201909/1214816-20190926080305965-1912792923.jpg&quot;&gt;&lt;img title=&quot;clip_image042[10]&quot; src=&quot;https://img2018.cnblogs.com/blog/1214816/201909/1214816-20190926080306197-1120565854.jpg&quot; alt=&quot;clip_image042[10]&quot; width=&quot;1282&quot; height=&quot;177&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;这两个线程有可能死锁&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;span&gt;先看看&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;thread 2&lt;/span&gt; &lt;span&gt;是如何调用的&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;span&gt;调用堆栈搞起&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1214816/201909/1214816-20190926080306449-186332252.jpg&quot;&gt;&lt;img title=&quot;clip_image044[10]&quot; src=&quot;https://img2018.cnblogs.com/blog/1214816/201909/1214816-20190926080306707-57088559.jpg&quot; alt=&quot;clip_image044[10]&quot; width=&quot;1004&quot; height=&quot;233&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;它是调用了&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;func1,&lt;/span&gt;&lt;span&gt;我看看&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;func1&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;的内容&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1214816/201909/1214816-20190926080306941-2096046079.jpg&quot;&gt;&lt;img title=&quot;clip_image046[10]&quot; src=&quot;https://img2018.cnblogs.com/blog/1214816/201909/1214816-20190926080307159-764126086.jpg&quot; alt=&quot;clip_image046[10]&quot; width=&quot;419&quot; height=&quot;203&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;它提示有两个变量分别是&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;lock1&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;lock2.&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;所以我想看看这两个变量&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1214816/201909/1214816-20190926080307364-925404016.jpg&quot;&gt;&lt;img title=&quot;clip_image048[10]&quot; src=&quot;https://img2018.cnblogs.com/blog/1214816/201909/1214816-20190926080307579-1490332916.jpg&quot; alt=&quot;clip_image048[10]&quot; width=&quot;1143&quot; height=&quot;118&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;提示&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;span&gt;这两个锁&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;span&gt;被不同的线程持有&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;再回头看看&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;thread 2&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;的调用堆栈&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1214816/201909/1214816-20190926080307806-197079799.jpg&quot;&gt;&lt;img title=&quot;clip_image050[10]&quot; src=&quot;https://img2018.cnblogs.com/blog/1214816/201909/1214816-20190926080308077-782074650.jpg&quot; alt=&quot;clip_image050[10]&quot; width=&quot;1020&quot; height=&quot;214&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;可以看到&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;span&gt;它提示线程&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;14662&lt;/span&gt; &lt;span&gt;停在了&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;lock2.lock()&lt;/span&gt;&lt;span&gt;方法那里了这个线程想要获得锁的所有权&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt; &lt;span&gt;而&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;lock2,&lt;/span&gt;&lt;span&gt;按照上一个截图&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;span&gt;已经被&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;14663&lt;/span&gt;&lt;span&gt;持有了&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;用相同的办法也可以得到&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;lock1&lt;/span&gt;&lt;span&gt;的细节&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;span&gt;我这里就不复述了&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;所以这个死锁就被我找到了原因&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;span&gt;小结&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;真正现实当中遇到的问题&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;span&gt;不会像这样就很快的被找到&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;span&gt;因为这里是创造问题然后去解决&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;span&gt;有点事后诸葛的意思&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;span&gt;比如现实当中的死锁&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;span&gt;找到对应的锁变量这一步就不会那么容易&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;span&gt;需要耐心和运气&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;span&gt;不过使用&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;gdb&lt;/span&gt;&lt;span&gt;的第一步就是首先熟悉出问题的时候大体的调用堆栈模式&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;span&gt;然后再去尝试可能的出错方向&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;span&gt;进而解决它&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;span&gt;如果只是记得冷冰冰&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;gdb&lt;/span&gt;&lt;span&gt;指令&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;span&gt;在我眼里就如同多记住了几个英文单词而已&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;span&gt;我认为意义不大&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 26 Sep 2019 00:07:00 +0000</pubDate>
<dc:creator>高胖</dc:creator>
<og:description>上篇(使用c++开发跨平台程序)说到,我不怕造东西,我怕的是造出来的东西,如果出了问题,我却不知道原因.所以调试分析是一个重要的手段. C++调试是一个复杂的活.虽然大部分调试可以通过IDE在开发期间</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/gaopang/p/11588683.html</dc:identifier>
</item>
<item>
<title>Redis集群 - 啊驼</title>
<link>http://www.cnblogs.com/cxyAtuo/p/11588691.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cxyAtuo/p/11588691.html</guid>
<description>&lt;p&gt; 这节介绍Redis的集群模式&lt;/p&gt;
&lt;p&gt; 主从模式提供了读写分离的支持，Sentinel提供了高可用的保障，满足了读模式下的横向扩展，但主节点只有一个，集中式的写模式无法应对不断增长的写需求。&lt;/p&gt;
&lt;p&gt; Redis 3.x 版本提供了Redis &lt;code&gt;cluster&lt;/code&gt;功能，服务端sharding使用槽作为分布式的解决方案。对于 2.x版本，则通过客户端API提供的客户端sharding方式，使用一致性哈希来实现数据分片。此外，twiter开源的&lt;code&gt;twemproxy&lt;/code&gt; 和豌豆荚的&lt;code&gt;codis&lt;/code&gt;，则采用代理模式来实现。&lt;/p&gt;
&lt;h4 id=&quot;服务端模式&quot;&gt;1 服务端模式&lt;/h4&gt;
&lt;p&gt; 对于客户端来说，整个集群被看做一个整体，客户端可以连接任意一个节点进行操作，就像操作单一Redis数据库一样。当客户端操作的key没有分配到该节点上时，会返回转向指令，指向正确的节点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1812801/201909/1812801-20190926075155701-412409776.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;集群的建立&quot;&gt;1.1 集群的建立&lt;/h5&gt;
&lt;p&gt; 3.x 版本的Redis节点可以通过打开&lt;code&gt;clustrer-enabled&lt;/code&gt;选项来开启服务器的集群模式，再通过&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    CLUSTER MEET    &amp;lt;ip&amp;gt;      &amp;lt;port&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;命令连接其他节点。&lt;/p&gt;
&lt;p&gt; 新加入的节点B通过&lt;code&gt;CLUSTER MEET&lt;/code&gt;命令同节点A建立连接后，节点A会通过&lt;code&gt;Gossip协议&lt;/code&gt;将节点B的信息传播给集群中的其他节点，当其他节点发现新加入的节点B后也会主动同它建立连接。处于集群状态的节点同单机模式下的服务器实例没什么区别，只是只能使用&lt;code&gt;db 0&lt;/code&gt; 数据库，同时除了执行单机模式下的任务外还会执行集群所需的任务，如Gossip的消息的传播。&lt;/p&gt;
&lt;h5 id=&quot;槽指派&quot;&gt;1.2 槽指派&lt;/h5&gt;
&lt;p&gt; Redis集群使用槽来存储分片信息，集群中的每个节点负责处理16384个槽中的一部分。对于每个写操作，通过计算&lt;code&gt;crc(key)%16384&lt;/code&gt;对key值进行hashing，分配到16384个槽中的一个，然后由对应的节点处理。&lt;/p&gt;
&lt;p&gt; 节点负责哪些槽信息可以通过向节点发送&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    CLUSTER ADDSLOTS      &amp;lt;slot&amp;gt;  [slot …]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;来指派。分配完槽信息后，该节点会将自身的信息传播给集群中的机器节点，使得集群中的所有节点都有全部的槽分配信息。当16384个槽都有节点在处理时，节点处于上线状态；相反的，如果有任何一个槽没有得到处理，那么集群处于下线状态。&lt;/p&gt;
&lt;p&gt; 集群中的某个节点在收到一个请求时，会先判断是否由自己来处理，如果不是，则会向客户端返回&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    MOVE &amp;lt;slot&amp;gt; &amp;lt;ip&amp;gt;:&amp;lt;port&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;错误命令，该命令给出了请求所属的槽以及对应节点的ip和端口号。客户端在收到&lt;code&gt;MOVE&lt;/code&gt;错误时，会转到对应的节点重新发送之前的命令。注意，需要使用客户端的集群模式才会自动跳转,如下：&lt;/p&gt;
&lt;p&gt;`&lt;code&gt;redis-cli -c -h xxx -p xxx&lt;/code&gt;&lt;/p&gt;
&lt;p&gt; 当动态添加或者减少节点时，需要将16384个槽做重新分片，槽中的键值也要迁移。重新分片可以在线执行，使用自带的&lt;code&gt;redis-trib&lt;/code&gt;工具。&lt;/p&gt;
&lt;h5 id=&quot;高可用和故障转移&quot;&gt;1.3 高可用和故障转移&lt;/h5&gt;
&lt;p&gt; Redis集群，要保证&lt;code&gt;16384&lt;/code&gt;个槽对应的节点都正常工作，如果某个节点发生故障，那它负责的槽也就失效，整个集群将不能工作。可以使&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    CLUSTER REPLICATE &amp;lt;node_id&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将节点配置成主从结构来增加节点的可用行。&lt;/p&gt;
&lt;p&gt; 集群中的每个节点会定期的向其他节点发送PING消息来检测对方的状态，一个节点的状态可以为&lt;code&gt;在线&lt;/code&gt;，&lt;code&gt;疑似下线&lt;/code&gt;和&lt;code&gt;下线&lt;/code&gt;。当某个节点n发现半数以上负责处理槽的主节点都将某个主节点x标记为疑似下线状态时，节点n将节点x标记为下线状态，并向集群广播消息。&lt;/p&gt;
&lt;p&gt; 当节点x的从节点收到主节点下线的消息时，会对该节点进行故障转移。同Sentinel选举新的leader Sentinel节点一样，节点x的从节点会向集群中负责处理槽的其余主节点获取选票，以在节点x的从节点中选出新的主节点。新的主节点会撤销已下线主节点的槽指派，并分配给自己，然后向集群中的其他节点广播自己为新主节点的消息。&lt;/p&gt;
&lt;h4 id=&quot;客户端模式&quot;&gt;2 客户端模式&lt;/h4&gt;
&lt;p&gt; 客户端模式下每个节点都是单一的实例，需要由客户端应用自己管理key所在的分片，以及处理节点的故障转移，Redis的客户端Jedis提供了分片的支持。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1812801/201909/1812801-20190926075156007-920219248.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt; Jedis对Sharded的实现主要是在&lt;code&gt;ShardedJedis.java&lt;/code&gt;和&lt;code&gt;ShardedJedisPool.java&lt;/code&gt;中,可以见&lt;a href=&quot;https://segmentfault.com/a/1190000002691429&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt; Jedis的Redis Sharding实现具有如下特点：&lt;/p&gt;
&lt;ol readability=&quot;3.9170779861797&quot;&gt;&lt;li readability=&quot;1.8806818181818&quot;&gt;
&lt;p&gt;采用&lt;a href=&quot;http://www.cnblogs.com/lpfuture/p/5796398.html&quot;&gt;一致性哈希算法&lt;/a&gt;，将key和节点name同时hashing，然后进行映射匹配，采用的算法是&lt;code&gt;MURMUR_HASH&lt;/code&gt;。采用一致性哈希而不是采用简单类似哈希求模映射的主要原因是当增加或减少节点时，不会产生由于重新匹配造成的rehashing。一致性哈希只影响相邻节点key分配，影响量小。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;为了避免一致性哈希只影响相邻节点造成节点分配压力，ShardedJedis会对每个Redis节点根据名字(没有的话，Jedis会赋予缺省名字)会虚拟化出160个虚拟节点进行散列。根据权重也可虚拟化出160倍数的虚拟节点。用虚拟节点做映射匹配，可以在增加或减少Redis节点时，key在各 Redis节点移动再分配更均匀，而不是只有相邻节点受影响。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;Sharded Jedis支持&lt;code&gt;keyTagPattern&lt;/code&gt;模式，即抽取key的一部分keyTag做sharding，这样通过合理命名key，可以将一组相关联的key放入同一个Redis节点，这在避免跨节点访问相关数据时很重要。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;代理模式&quot;&gt;3 代理模式&lt;/h4&gt;
&lt;p&gt; 通过在客户端和实际Redis服务中间增加代理层，代理模块实现Redis协议，客户端连接代理和连接原生的Redis实例没有什么区别，上层应用可以像使用单机的Redis一样使用，代理会处理请求的转发，不停机的数据迁移等工作，所有后边的一切事情，对于前面客户端来说是透明的，可以简单的认为后边连接是一个内存无限大的Redis服务。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1812801/201909/1812801-20190926075156545-2135693522.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt; Twitter的&lt;code&gt;twemproxy&lt;/code&gt;和豌豆荚的&lt;code&gt;codis&lt;/code&gt;就是该模式的实现。关于&lt;code&gt;codis&lt;/code&gt;的介绍，可以看&lt;a href=&quot;http://www.cnblogs.com/wangdaijun/p/6156397.html&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt; 同前面两种模式相比，代理模式的好处在于，客户端和服务端无需作出变更，主要维护工作在于代理模块中；同后端实际实例的连接数落在了代理上，能够有效的控制客户端过多造成的连接数暴增；提供sharding功能，支持服务器集群水平扩展。同时，由于增加了代理，客户端到真正的实例服务器需要走两次网络。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1812801/201909/1812801-20190926075157381-574783748.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;个人公众号：啊驼&lt;/p&gt;
</description>
<pubDate>Wed, 25 Sep 2019 23:52:00 +0000</pubDate>
<dc:creator>啊驼</dc:creator>
<og:description>&amp;emsp;这节介绍Redis的集群模式 &amp;emsp;主从模式提供了读写分离的支持，Sentinel提供了高可用的保障，满足了读模式下的横向扩展，但主节点只有一个，集中式的写模式无法应对不断增长的写需</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cxyAtuo/p/11588691.html</dc:identifier>
</item>
<item>
<title>AWS加入.NET Foundation企业赞助商计划 - 张善友</title>
<link>http://www.cnblogs.com/shanyou/p/11588674.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shanyou/p/11588674.html</guid>
<description>&lt;p&gt;.NET 走向开源，MIT许可协议。 微软为了推动.NET开源社区的发展，2014年联合社区成立了.NET基金会。&lt;/p&gt;
&lt;p&gt;.NET基金会是一个独立的组织，支持.NET社区和开源，旨在拓宽和加强.NET生态系统和社区。这可以通过多种方式完成，包括项目指导，指导，法律和营销帮助，技术和财务支持设置等. 2014年以来已经有众多知名公司加入.NET基金会, 仅在平台项目中，.NET平台上有87％贡献者其实不在Microsoft工作。在.net conf 2019 AWS加入了支持.NET Foundation的.NET开源生态系统中越来越多的行业领导者，这些成员包括Microsoft，Google，Red Hat，JetBrains，Unity，三星，Pivotal，Insight和Telerik。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://dnfwebsitewusproduction.blob.core.windows.net/media/Default/Blog/corporate-sponsors-with-aws.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;多年来，AWS一直是.NET生态系统的积极贡献者，通过加入.NET Foundation，他们可以更深入地参与其中。他们还显示出他们对.NET开源社区的支持，因为他们的捐款用于支持开源项目，全球Meetups，我们的成员行动小组以及新计划。.NET基金会还将从他们的专业知识中受益，因为他们将帮助制定未来的增长计划。下面是来自AWS团队的官方通告：&lt;a href=&quot;https://aws.amazon.com/cn/blogs/opensource/aws-joins-the-net-foundation/&quot;&gt;https://aws.amazon.com/cn/blogs/opensource/aws-joins-the-net-foundation/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;AWS代表.NET Foundation的Norm Johanson讲了几句话：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Fred和我在构建可扩展的高性能系统方面有着悠久的历史。我很高兴在.NET Foundation中代表AWS。作为企业赞助商加入.NET Foundation是AWS旅程中的重要时刻，这一旅程可以追溯到2008年。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;我记得.NET 1.0第一次发布的时候。我为可以构建的未来感到非常兴奋。我于2010年加入AWS，领导AWS的.NET开发工作。AWS理解了.NET的重要性，而适用于.NET的AWS开发工具包实际上是AWS于2009年11月发布的第一个统一的AWS开发工具包。从那时起，我就有机会与.NET社区的无数成员合作， GitHub，Twitter和在会议上的演讲，以帮助他们建立在AWS上，并更好地了解.NET开发人员对AWS的期望。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;在.NET Core处于早期开发期间，我们知道这就是.NET的未来。我们迅速开始建立对.NET Core的支持，并能够在.NET Core的早期测试版中添加支持。.NET Core 1.0发布仅几个月后，我们还发布了第一个针对无服务器应用程序的AWS Lambda .NET Core运行时。像.NET Foundation一样，我们知道公开进行这项工作很重要，因此AWS .NET团队使用我们构建的库和工具在&lt;a href=&quot;https://github.com/aws/dotnet&quot;&gt;GitHub.github.com/aws/dotnet&lt;/a&gt;上公开工作。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;AWS Windows和Enterprise总经理Fred Wurden的几句话：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;许多人没有意识到我们开始多久之前以及我们对AWS的承诺水平有多高，从而为客户提供了出色的.NET体验。Norm是AWS的完美代表，可以指导和代表整个AWS的许多工程师在支持.NET Foundation方面的工作。我们的客户对.NET具有长期的长期投资。他们告诉我们，他们希望AWS在云上转变业务时完全支持其现代化系统，数据库和应用程序的旅程。我们对.NET Foundation的赞助是将我们的承诺扩展到.NET客户的重要一步。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;AWS将继续倾听客户的意见，增加投资并为社区做出贡献。我们期待与.NET Foundation，整个.NET社区以及我们的.NET客户合作，以​​支持.NET的未来。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;自此，美国三大云厂商聚首.NET Foundation, 云计算领域版图之中美大格局，我真心希望中国的阿里云，腾讯云，华为云能够认真评估.NET的重要性，你们可以参照AWS。今年中国地区的.NET社区民间正在筹备11月份的峰会，期待更多的社区参与进来。&lt;/p&gt;
</description>
<pubDate>Wed, 25 Sep 2019 23:15:00 +0000</pubDate>
<dc:creator>张善友</dc:creator>
<og:description>.NET 走向开源，MIT许可协议。 微软为了推动.NET开源社区的发展，2014年联合社区成立了.NET基金会。.NET基金会是一个独立的组织，支持.NET社区和开源，旨在拓宽和加强.NET生态系统</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/shanyou/p/11588674.html</dc:identifier>
</item>
<item>
<title>C++ 变量判定的螺旋法则 - 刘哇勇</title>
<link>http://www.cnblogs.com/Wayou/p/cpp_clockwise_spiral_rule.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Wayou/p/cpp_clockwise_spiral_rule.html</guid>
<description>&lt;p&gt;C++ 中一个标识符配合着各种修饰界定符，使得标识符的本意不那么直观一眼就能看出，甚至需要仔细分析，才能知道该标识符的具体你含义。&lt;/p&gt;
&lt;p&gt;比如：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-c++&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;void&lt;/span&gt; (*&lt;span class=&quot;pl-en&quot;&gt;signal&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;void&lt;/span&gt; (*fp)(&lt;span class=&quot;pl-k&quot;&gt;int&lt;/span&gt;)))(&lt;span class=&quot;pl-k&quot;&gt;int&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中 &lt;code&gt;signal&lt;/code&gt; 是什么？&lt;/p&gt;
&lt;h2&gt;螺旋法则&lt;/h2&gt;
&lt;p&gt;对于如何进行变量的辩识，有个非官方的 “顺时针/螺旋法则（Clockwise/Spiral Rule）” 可用来帮助辩识。&lt;/p&gt;
&lt;p&gt;该法则的内容，简单来说，为了搞清楚一个未知标识符的含义，我们可以：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;从我们需要判定的标识符开始，顺时针画圈，遇到如下符号时，用对应的语义替换：&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;[x]&lt;/code&gt; 或 &lt;code&gt;[]&lt;/code&gt; =&amp;gt; 容量为 &lt;code&gt;x&lt;/code&gt; 的数组或数组&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(type1,type2...)&lt;/code&gt; =&amp;gt; 接收 &lt;code&gt;type1&lt;/code&gt;、&lt;code&gt;type2&lt;/code&gt;... 的函数，返回值为（待定）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;*&lt;/code&gt; =&amp;gt; 指向（类型待定）的指针&lt;/li&gt;
&lt;/ul&gt;&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;重复上面的步骤直到语句中所有符号都被遍历过。&lt;/li&gt;
&lt;li&gt;始终优先解析括号括起来的部分。&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;实地演练&lt;/h2&gt;
&lt;h3&gt;一个简单的示例&lt;/h3&gt;
&lt;p&gt;先从一个简单的开始，判定如下语句中 &lt;code&gt;str&lt;/code&gt; 的含义：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-c++&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
                     +-------+
                     | +-+   |
                     | ^ |   |
                &lt;span class=&quot;pl-k&quot;&gt;char&lt;/span&gt; *str[&lt;span class=&quot;pl-c1&quot;&gt;10&lt;/span&gt;];
                 ^   ^   |   |
                 |   +---+   |
                 +-----------+
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;根据螺旋法则，如上面线图标识所示，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;从 &lt;code&gt;str&lt;/code&gt; 这个需要被判定的对象出发。&lt;/li&gt;
&lt;li&gt;螺旋路径上第一次遇到的是 &lt;code&gt;[&lt;/code&gt; 左方括号，由此我们知道，&lt;code&gt;str&lt;/code&gt; 是一个尺寸为 10 的数组。&lt;/li&gt;
&lt;li&gt;继续旋转，遇到 &lt;code&gt;*&lt;/code&gt;，所以 &lt;code&gt;str&lt;/code&gt; 是一个尺寸为 10 的数组，数组元素为指针。&lt;/li&gt;
&lt;li&gt;继续，遇到 &lt;code&gt;;&lt;/code&gt; 标识语句的结束。&lt;/li&gt;
&lt;li&gt;再继续，遇到 &lt;code&gt;char&lt;/code&gt;，所以 &lt;code&gt;str&lt;/code&gt; 是一个尺寸为 10 的数组，数组元素为指向 &lt;code&gt;char&lt;/code&gt; 类型的指针。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;进阶&lt;/h3&gt;
&lt;p&gt;回到文章开头那个语句，来判定其中 &lt;code&gt;signal&lt;/code&gt; 的含义。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-c++&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
                      +-----------------------------+
                      |                  +---+      |
                      |  +---+           |+-+|      |
                      |  ^   |           |^ ||      |
                &lt;span class=&quot;pl-en&quot;&gt;void&lt;/span&gt; (*&lt;span class=&quot;pl-en&quot;&gt;signal&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;void&lt;/span&gt; (*fp)(&lt;span class=&quot;pl-k&quot;&gt;int&lt;/span&gt;)))(&lt;span class=&quot;pl-k&quot;&gt;int&lt;/span&gt;);
                 ^    ^      |      ^    ^  ||      |
                 |    +------+      |    +--+|      |
                 |                  +--------+      |
                 +----------------------------------+
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由螺旋法则画出如上的线图，进而可分析：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;从要判定的 &lt;code&gt;signal&lt;/code&gt; 出发首次遇到 &lt;code&gt;(&lt;/code&gt; 左括号，表示 &lt;code&gt;signal&lt;/code&gt; 是一个函数，入参为 &lt;code&gt;int&lt;/code&gt; 和 ...&lt;/li&gt;
&lt;li&gt;此处需要需要进一步运用螺旋法则先确定 &lt;code&gt;fp&lt;/code&gt; 的含义，才能进而确认 &lt;code&gt;signal&lt;/code&gt; 这个函数的完整入参。所以从 &lt;code&gt;fp&lt;/code&gt; 了发进行一次子螺旋。&lt;/li&gt;
&lt;li&gt;因为需要优先解析括号括起来的部分，所以转一圈回来首次遇到的是 &lt;code&gt;*&lt;/code&gt;，由此 &lt;code&gt;fp&lt;/code&gt; 是一个指针。&lt;/li&gt;
&lt;li&gt;继续解析 &lt;code&gt;fp&lt;/code&gt;，遇到 &lt;code&gt;(&lt;/code&gt;，所以 &lt;code&gt;fp&lt;/code&gt; 是一个指向函数的指针，这个函数接收一个 &lt;code&gt;int&lt;/code&gt; 类型的入参。&lt;/li&gt;
&lt;li&gt;继续下去，遇到 &lt;code&gt;void&lt;/code&gt;，所以 &lt;code&gt;fp&lt;/code&gt; 是一个指向函数的指针，这个函数接收一个 &lt;code&gt;int&lt;/code&gt; 类型的入参并且返回值为空。&lt;/li&gt;
&lt;li&gt;至此完成了 &lt;code&gt;fp&lt;/code&gt; 的解析，可以知道 &lt;code&gt;signal&lt;/code&gt; 的类型为：
&lt;ul&gt;&lt;li&gt;是一个函数，入参为：
&lt;ul&gt;&lt;li&gt;一个 int 类型&lt;/li&gt;
&lt;li&gt;一个指向函数的指针，这个函数接收一个 &lt;code&gt;int&lt;/code&gt; 类型的入参并且返回值为空&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;路径跑到 &lt;code&gt;signal&lt;/code&gt; 的螺旋中，遇到 &lt;code&gt;*&lt;/code&gt;（紧邻 &lt;code&gt;signal&lt;/code&gt; 左边），所以 &lt;code&gt;signal&lt;/code&gt; 是
&lt;ul&gt;&lt;li&gt;一个函数，入参为：
&lt;ul&gt;&lt;li&gt;一个 int 类型&lt;/li&gt;
&lt;li&gt;一个指向函数的指针，这个函数接收一个 &lt;code&gt;int&lt;/code&gt; 类型的入参并且返回值为空&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;返回值为指针&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;再继续，遇到 &lt;code&gt;(&lt;/code&gt;，接上面，返回值为指向另一函数的指针，被指向的这个函数接收一个 &lt;code&gt;int&lt;/code&gt; 入参。&lt;/li&gt;
&lt;li&gt;最后，遇到 &lt;code&gt;void&lt;/code&gt;，&lt;code&gt;signal&lt;/code&gt; 返回值指向的这个函数的返回值为空。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;最后捋一下 &lt;code&gt;signal&lt;/code&gt; 的完整类型为：接收一个 &lt;code&gt;int&lt;/code&gt;，一个指向接收一个 &lt;code&gt;int&lt;/code&gt; 并且返回值为空的函数的指针，这两个参数的函数，并且返回值为指向一个接收 &lt;code&gt;int&lt;/code&gt; 型返回为空的函数...Orz。&lt;/p&gt;
&lt;h3&gt;成员函数的判定&lt;/h3&gt;
&lt;p&gt;螺旋施法没有给出在 &lt;code&gt;const&lt;/code&gt; 参与的情况下的判定，不过&lt;strong&gt;因为 &lt;code&gt;const&lt;/code&gt; 默认修饰紧邻其左边的元素，如果右边无元素，则修饰左边的元素&lt;/strong&gt;。因此只需要将 const 和它修饰的元素作为整体来看，就还是可以使用螺旋法则的。&lt;/p&gt;
&lt;p&gt;考察如下语句：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-c++&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;int&lt;/span&gt;*&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Method3&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;int&lt;/span&gt;*&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt;&amp;amp;) &lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当函数后面紧跟一个 &lt;code&gt;const&lt;/code&gt; 时，表示该成员函数的作用域内 &lt;code&gt;*this&lt;/code&gt; 是常量，即无法在该函数体内对所类的实体进行修改。&lt;/p&gt;
&lt;p&gt;下面对上面的语句进行分析：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;从 &lt;code&gt;Method3&lt;/code&gt; 出发，遇到 &lt;code&gt;(&lt;/code&gt;，所以 &lt;code&gt;Method3&lt;/code&gt; 是一个函数，接收一个引用作为入参 &lt;code&gt;const int*const&amp;amp;&lt;/code&gt; 部分。&lt;/li&gt;
&lt;li&gt;该引用的类型是 &lt;code&gt;const int*const&lt;/code&gt;，指向整形常量的常量指针。&lt;/li&gt;
&lt;li&gt;继续遇到 &lt;code&gt;*const&lt;/code&gt;，所以函数的返回值为常量指针。指针指向的类型为 &lt;code&gt;const int&lt;/code&gt; 整形常量。&lt;/li&gt;
&lt;li&gt;函数末尾的 &lt;code&gt;const&lt;/code&gt; 如前所述，标识函数体内不修改实例。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;相关资源&lt;/h2&gt;
</description>
<pubDate>Wed, 25 Sep 2019 15:47:00 +0000</pubDate>
<dc:creator>刘哇勇</dc:creator>
<og:description>C++ 中一个标识符配合着各种修饰界定符，使得标识符的本意不那么直观一眼就能看出，甚至需要仔细分析，才能知道该标识符的具体你含义。 比如： void ( signal(int, void ( fp)(</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Wayou/p/cpp_clockwise_spiral_rule.html</dc:identifier>
</item>
<item>
<title>RabbitMQ的六种工作模式总结 - 侧身左睡</title>
<link>http://www.cnblogs.com/xyfer1018/p/11581511.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xyfer1018/p/11581511.html</guid>
<description>&lt;p&gt;最近学习RabbitMQ的使用方式，记录下来，方便以后使用，也方便和大家共享，相互交流。&lt;/p&gt;
&lt;p&gt;RabbitMQ的六种工作模式：&lt;/p&gt;
&lt;p&gt;1、Work queues&lt;br/&gt;2、Publish/subscribe&lt;br/&gt;3、Routing&lt;br/&gt;4、Topics&lt;br/&gt;5、Header 模式&lt;br/&gt;6、RPC&lt;/p&gt;
&lt;p&gt;一、Work queues&lt;/p&gt;
&lt;p&gt;多个消费端消费同一个队列中的消息，队列采用轮询的方式将消息是平均发送给消费者；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1553771/201909/1553771-20190924215139078-298897177.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 特点：&lt;/p&gt;
&lt;p&gt;1、一条消息只会被一个消费端接收；&lt;/p&gt;
&lt;p&gt;2、队列采用轮询的方式将消息是平均发送给消费者的；&lt;/p&gt;
&lt;p&gt;3、消费者在处理完某条消息后，才会收到下一条消息&lt;/p&gt;
&lt;p&gt;生产端：&lt;/p&gt;
&lt;p&gt;1、声明队列&lt;/p&gt;
&lt;p&gt;2、创建连接&lt;/p&gt;
&lt;p&gt;3、创建通道&lt;/p&gt;
&lt;p&gt;4、通道声明队列&lt;/p&gt;
&lt;p&gt;5、制定消息&lt;/p&gt;
&lt;p&gt;6、发送消息，使用默认交换机&lt;/p&gt;
&lt;p&gt;消费端：&lt;/p&gt;
&lt;p&gt;1、声明队列&lt;/p&gt;
&lt;p&gt;2、创建连接&lt;/p&gt;
&lt;p&gt;3、创建通道&lt;/p&gt;
&lt;p&gt;4、通道声明队列&lt;/p&gt;
&lt;p&gt;5、重写消息消费方法&lt;/p&gt;
&lt;p&gt;6、执行消息方法&lt;/p&gt;
&lt;p&gt;新建两个maven工程，生产消息的生产端，消费消息的消费端；&lt;/p&gt;
&lt;p&gt;pom.xml文件中依赖坐标如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-logging&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2.1.0.RELEASE&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.rabbitmq&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;amqp-client&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;5.7.0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 生产端的代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.xyfer;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.rabbitmq.client.BuiltinExchangeType;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.rabbitmq.client.Channel;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.rabbitmq.client.Connection;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.rabbitmq.client.ConnectionFactory;


&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.TimeoutException;
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
1、声明队列
2、创建连接
3、创建通道
4、通道声明队列
5、制定消息
6、发送消息，使用默认交换机
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Producer02 {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明队列&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String QUEUE =&quot;queue&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        Connection connection &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        Channel channel &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            ConnectionFactory connectionFactory &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConnectionFactory();
            connectionFactory.setHost(&lt;/span&gt;&quot;127.0.0.1&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;mq服务ip地址&lt;/span&gt;
            connectionFactory.setPort(5672);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;mq client连接端口&lt;/span&gt;
            connectionFactory.setUsername(&quot;guest&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;mq登录用户名&lt;/span&gt;
            connectionFactory.setPassword(&quot;guest&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;mq登录密码&lt;/span&gt;
            connectionFactory.setVirtualHost(&quot;/&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;rabbitmq默认虚拟机名称为“/”，虚拟机相当于一个独立的mq服务器
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建与RabbitMQ服务的TCP连接&lt;/span&gt;
            connection =&lt;span&gt; connectionFactory.newConnection();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建与Exchange的通道，每个连接可以创建多个通道，每个通道代表一个会话任务&lt;/span&gt;
            channel =&lt;span&gt; connection.createChannel();

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通道绑定队列&lt;/span&gt;
            &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
             * 声明队列，如果Rabbit中没有此队列将自动创建
             * param1:队列名称
             * param2:是否持久化
             * param3:队列是否独占此连接
             * param4:队列不再使用时是否自动删除此队列
             * param5:队列参数
             * String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&amp;lt;String, Object&amp;gt; arguments
             *
             &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            channel.queueDeclare(QUEUE,&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;,&lt;span&gt;false&lt;/span&gt;,&lt;span&gt;false&lt;/span&gt;,&lt;span&gt;null&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通道绑定邮件队列&lt;/span&gt;

            &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = 0;i&amp;lt;10;i++&lt;span&gt;){
                String message &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; String(&quot;mq 发送消息。。。&quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
                  * 消息发布方法
                  * param1：Exchange的名称，如果没有指定，则使用Default Exchange
                  * param2:routingKey,消息的路由Key，是用于Exchange（交换机）将消息转发到指定的消息队列
                  * param3:消息包含的属性
                  * param4：消息体
                  * 这里没有指定交换机，消息将发送给默认交换机，每个队列也会绑定那个默认的交换机，但是不能显示绑定或解除绑定
                  * 默认的交换机，routingKey等于队列名称
                 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;String exchange, String routingKey, BasicProperties props, byte[] body&lt;/span&gt;
                channel.basicPublish(&quot;&quot;,QUEUE,&lt;span&gt;null&lt;/span&gt;,message.getBytes(&quot;utf-8&quot;&lt;span&gt;));
                System.out.println(&lt;/span&gt;&quot;mq消息发送成功！&quot;&lt;span&gt;);
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                channel.close();
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                e.printStackTrace();
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (TimeoutException e) {
                e.printStackTrace();
            }
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                connection.close();
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                e.printStackTrace();
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;消费端的代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.xyfer;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; com.rabbitmq.client.*&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.TimeoutException;
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
1、声明队列
2、创建连接
3、创建通道
4、通道声明队列
5、重写消息消费方法
6、执行消息方法
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Consumer02 {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String QUEUE =&quot;queue&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        Connection connection &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        Channel channel &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            ConnectionFactory connectionFactory &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConnectionFactory();
            connectionFactory.setHost(&lt;/span&gt;&quot;127.0.0.1&quot;&lt;span&gt;);
            connectionFactory.setPort(&lt;/span&gt;5672&lt;span&gt;);
            connection &lt;/span&gt;=&lt;span&gt; connectionFactory.newConnection();
            channel &lt;/span&gt;=&lt;span&gt; connection.createChannel();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通道绑定队列&lt;/span&gt;
            &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
             * 声明队列，如果Rabbit中没有此队列将自动创建
             * param1:队列名称
             * param2:是否持久化
             * param3:队列是否独占此连接
             * param4:队列不再使用时是否自动删除此队列
             * param5:队列参数
             * String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&amp;lt;String, Object&amp;gt; arguments
             *
             &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            channel.queueDeclare(QUEUE,&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;,&lt;span&gt;false&lt;/span&gt;,&lt;span&gt;false&lt;/span&gt;,&lt;span&gt;null&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通道绑定邮件队列

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;String consumerTag, Envelope envelope, BasicProperties properties, byte[] body&lt;/span&gt;
            DefaultConsumer consumer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultConsumer(channel) {
                &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
                  * 消费者接收消息调用此方法
                  * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; consumerTag 消费者的标签，在channel.basicConsume()去指定
                  * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; envelope 消息包的内容，可从中获取消息id，消息routingkey，交换机，消息和重传标志
                    (收到消息失败后是否需要重新发送)
                  * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; properties
                  * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; body
                  * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; IOException
                 * String consumerTag, Envelope envelope, BasicProperties properties, byte[] body
                 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
                @Override
                &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, &lt;span&gt;byte&lt;/span&gt;[] body) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;交换机&lt;/span&gt;
                    String exchange =&lt;span&gt; envelope.getExchange();
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;路由key&lt;/span&gt;
                    String routingKey =&lt;span&gt; envelope.getRoutingKey();
                    envelope.getDeliveryTag();
                    String msg &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; String(body,&quot;utf-8&quot;&lt;span&gt;);
                    System.out.println(&lt;/span&gt;&quot;mq收到的消息是：&quot;+&lt;span&gt;msg );
                }

            };
            System.out.println(&lt;/span&gt;&quot;消费者启动成功！&quot;&lt;span&gt;);
            channel.basicConsume(QUEUE,&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,consumer);

        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (TimeoutException e) {
            e.printStackTrace();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;生产端启动后，控制台打印信息如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1553771/201909/1553771-20190924220925081-256250887.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; RabbitMQ中的已有消息：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1553771/201909/1553771-20190924221109461-896449363.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; queue中的消息正是生产端发送的消息：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1553771/201909/1553771-20190924221324440-2081392705.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 二、Publish/subscribe 模式&lt;/p&gt;
&lt;p&gt;这种模式又称为发布订阅模式，相对于Work queues模式，该模式多了一个交换机，生产端先把消息发送到交换机，再由交换机把消息发送到绑定的队列中，每个绑定的队列都能收到由生产端发送的消息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1553771/201909/1553771-20190924232330370-1410743243.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;发布订阅模式：&lt;/p&gt;
&lt;p&gt;1、每个消费者监听自己的队列；&lt;/p&gt;
&lt;p&gt;2、生产者将消息发给broker，由交换机将消息转发到绑定此交换机的每个队列，每个绑定交换机的队列都将接收&lt;br/&gt;到消息&lt;/p&gt;
&lt;p&gt;应用场景：用户通知，当用户充值成功或转账完成系统通知用户，通知方式有短信、邮件多种方法；&lt;/p&gt;
&lt;p&gt;生产端：&lt;/p&gt;
&lt;p&gt;1、声明队列，声明交换机&lt;/p&gt;
&lt;p&gt;2、创建连接&lt;/p&gt;
&lt;p&gt;3、创建通道&lt;/p&gt;
&lt;p&gt;4、通道声明交换机&lt;/p&gt;
&lt;p&gt;5、通道声明队列&lt;/p&gt;
&lt;p&gt;6、通过通道使队列绑定到交换机&lt;/p&gt;
&lt;p&gt;7、制定消息&lt;/p&gt;
&lt;p&gt;8、发送消息&lt;/p&gt;
&lt;p&gt;消费端：&lt;/p&gt;
&lt;p&gt;1、声明队列，声明交换机&lt;/p&gt;
&lt;p&gt;2、创建连接&lt;/p&gt;
&lt;p&gt;3、创建通道&lt;/p&gt;
&lt;p&gt;4、通道声明交换机&lt;/p&gt;
&lt;p&gt;5、通道声明队列&lt;/p&gt;
&lt;p&gt;6、通过通道使队列绑定到交换机&lt;/p&gt;
&lt;p&gt;7、重写消息消费方法&lt;/p&gt;
&lt;p&gt;8、执行消息方法&lt;/p&gt;
&lt;p&gt;Publish/subscribe 模式绑定两个消费端，因此需要有两个消费端，一个邮件消费端，一个短信消费端；&lt;/p&gt;
&lt;p&gt;生产端的代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.xyfer;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.rabbitmq.client.BuiltinExchangeType;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.rabbitmq.client.Channel;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.rabbitmq.client.Connection;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.rabbitmq.client.ConnectionFactory;


&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.TimeoutException;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Producer01 {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明两个队列和一个交换机
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Publish/subscribe发布订阅模式&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String QUEUE_EMAIL =&quot;queueEmail&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String QUEUE_SMS =&quot;queueSms&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String EXCHANGE = &quot;messageChange&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        Connection connection &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        Channel channel &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            ConnectionFactory connectionFactory &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConnectionFactory();
            connectionFactory.setHost(&lt;/span&gt;&quot;127.0.0.1&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;mq服务ip地址&lt;/span&gt;
            connectionFactory.setPort(5672);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;mq client连接端口&lt;/span&gt;
            connectionFactory.setUsername(&quot;guest&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;mq登录用户名&lt;/span&gt;
            connectionFactory.setPassword(&quot;guest&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;mq登录密码&lt;/span&gt;
            connectionFactory.setVirtualHost(&quot;/&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;rabbitmq默认虚拟机名称为“/”，虚拟机相当于一个独立的mq服务器
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建与RabbitMQ服务的TCP连接&lt;/span&gt;
            connection =&lt;span&gt; connectionFactory.newConnection();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建与Exchange的通道，每个连接可以创建多个通道，每个通道代表一个会话任务&lt;/span&gt;
            channel =&lt;span&gt; connection.createChannel();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通道绑定交换机&lt;/span&gt;
            &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
              * 参数明细
              * 1、交换机名称
              * 2、交换机类型，fanout、topic、direct、headers
              &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Publish/subscribe发布订阅模式&lt;/span&gt;
&lt;span&gt;            channel.exchangeDeclare(EXCHANGE, BuiltinExchangeType.FANOUT);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通道绑定队列&lt;/span&gt;
            &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
             * 声明队列，如果Rabbit中没有此队列将自动创建
             * param1:队列名称
             * param2:是否持久化
             * param3:队列是否独占此连接
             * param4:队列不再使用时是否自动删除此队列
             * param5:队列参数
             * String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&amp;lt;String, Object&amp;gt; arguments
             *
             &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            channel.queueDeclare(QUEUE_EMAIL,&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;,&lt;span&gt;false&lt;/span&gt;,&lt;span&gt;false&lt;/span&gt;,&lt;span&gt;null&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通道绑定邮件队列&lt;/span&gt;
            channel.queueDeclare(QUEUE_SMS,&lt;span&gt;true&lt;/span&gt;,&lt;span&gt;false&lt;/span&gt;,&lt;span&gt;false&lt;/span&gt;,&lt;span&gt;null&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通道绑定短信队列
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;交换机和队列绑定&lt;/span&gt;
            &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
             * 参数明细
             * 1、队列名称
             * 2、交换机名称
             * 3、路由key
             &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Publish/subscribe发布订阅模式&lt;/span&gt;
            channel.queueBind(QUEUE_EMAIL,EXCHANGE,&quot;&quot;&lt;span&gt;);
            channel.queueBind(QUEUE_SMS,EXCHANGE,&lt;/span&gt;&quot;&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = 0;i&amp;lt;10;i++&lt;span&gt;){
                String message &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; String(&quot;mq 发送消息。。。&quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
                  * 消息发布方法
                  * param1：Exchange的名称，如果没有指定，则使用Default Exchange
                  * param2:routingKey,消息的路由Key，是用于Exchange（交换机）将消息转发到指定的消息队列
                  * param3:消息包含的属性
                  * param4：消息体
                  * 这里没有指定交换机，消息将发送给默认交换机，每个队列也会绑定那个默认的交换机，但是不能显示绑定或解除绑定
                  * 默认的交换机，routingKey等于队列名称
                 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;String exchange, String routingKey, BasicProperties props, byte[] body
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Publish/subscribe发布订阅模式&lt;/span&gt;
                channel.basicPublish(EXCHANGE,&quot;&quot;,&lt;span&gt;null&lt;/span&gt;&lt;span&gt;,message.getBytes());
                System.out.println(&lt;/span&gt;&quot;mq消息发送成功！&quot;&lt;span&gt;);
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                channel.close();
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                e.printStackTrace();
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (TimeoutException e) {
                e.printStackTrace();
            }
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                connection.close();
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                e.printStackTrace();
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;邮件消费端的代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.xyfer;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; com.rabbitmq.client.*&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.TimeoutException;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Consumer01 {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Publish/subscribe发布订阅模式&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String QUEUE_EMAIL =&quot;queueEmail&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String EXCHANGE = &quot;messageChange&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        Connection connection &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        Channel channel &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            ConnectionFactory connectionFactory &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConnectionFactory();
            connectionFactory.setHost(&lt;/span&gt;&quot;127.0.0.1&quot;&lt;span&gt;);
            connectionFactory.setPort(&lt;/span&gt;5672&lt;span&gt;);
            connection &lt;/span&gt;=&lt;span&gt; connectionFactory.newConnection();
            channel &lt;/span&gt;=&lt;span&gt; connection.createChannel();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通道绑定交换机&lt;/span&gt;
            &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
              * 参数明细
              * 1、交换机名称
              * 2、交换机类型，fanout、topic、direct、headers
              &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Publish/subscribe发布订阅模式&lt;/span&gt;
&lt;span&gt;            channel.exchangeDeclare(EXCHANGE, BuiltinExchangeType.FANOUT);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通道绑定队列&lt;/span&gt;
            &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
             * 声明队列，如果Rabbit中没有此队列将自动创建
             * param1:队列名称
             * param2:是否持久化
             * param3:队列是否独占此连接
             * param4:队列不再使用时是否自动删除此队列
             * param5:队列参数
             * String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&amp;lt;String, Object&amp;gt; arguments
             *
             &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            channel.queueDeclare(QUEUE_EMAIL,&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;,&lt;span&gt;false&lt;/span&gt;,&lt;span&gt;false&lt;/span&gt;,&lt;span&gt;null&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通道绑定邮件队列
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;交换机和队列绑定&lt;/span&gt;
            &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
             * 参数明细
             * 1、队列名称
             * 2、交换机名称
             * 3、路由key
             &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Publish/subscribe发布订阅模式&lt;/span&gt;
            channel.queueBind(QUEUE_EMAIL,EXCHANGE,&quot;&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;String consumerTag, Envelope envelope, BasicProperties properties, byte[] body&lt;/span&gt;
            DefaultConsumer consumer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultConsumer(channel) {
            &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
              * 消费者接收消息调用此方法
              * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; consumerTag 消费者的标签，在channel.basicConsume()去指定
              * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; envelope 消息包的内容，可从中获取消息id，消息routingkey，交换机，消息和重传标志
                (收到消息失败后是否需要重新发送)
              * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; properties
              * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; body
              * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; IOException
              * String consumerTag, Envelope envelope, BasicProperties properties, byte[] body
              &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, &lt;span&gt;byte&lt;/span&gt;[] body) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;交换机&lt;/span&gt;
                String exchange =&lt;span&gt; envelope.getExchange();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;路由key&lt;/span&gt;
                String routingKey =&lt;span&gt; envelope.getRoutingKey();
                envelope.getDeliveryTag();
                String msg &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; String(body,&quot;utf-8&quot;&lt;span&gt;);
                System.out.println(&lt;/span&gt;&quot;mq收到的消息是：&quot;+&lt;span&gt;msg );
            }
            };
            System.out.println(&lt;/span&gt;&quot;消费者启动成功！&quot;&lt;span&gt;);
            channel.basicConsume(QUEUE_EMAIL,&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,consumer);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (TimeoutException e) {
            e.printStackTrace();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;短信消费端的代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; xyfer;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; com.rabbitmq.client.*&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.TimeoutException;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Consumer01 {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Publish/subscribe发布订阅模式&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String QUEUE_SMS =&quot;queueSms&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String EXCHANGE = &quot;messageChange&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        Connection connection &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        Channel channel &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            ConnectionFactory connectionFactory &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConnectionFactory();
            connectionFactory.setHost(&lt;/span&gt;&quot;127.0.0.1&quot;&lt;span&gt;);
            connectionFactory.setPort(&lt;/span&gt;5672&lt;span&gt;);
            connection &lt;/span&gt;=&lt;span&gt; connectionFactory.newConnection();
            channel &lt;/span&gt;=&lt;span&gt; connection.createChannel();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通道绑定交换机&lt;/span&gt;
            &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
              * 参数明细
              * 1、交换机名称
              * 2、交换机类型，fanout、topic、direct、headers
              &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Publish/subscribe发布订阅模式&lt;/span&gt;
&lt;span&gt;            channel.exchangeDeclare(EXCHANGE, BuiltinExchangeType.FANOUT);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通道绑定队列&lt;/span&gt;
            &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
             * 声明队列，如果Rabbit中没有此队列将自动创建
             * param1:队列名称
             * param2:是否持久化
             * param3:队列是否独占此连接
             * param4:队列不再使用时是否自动删除此队列
             * param5:队列参数
             * String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&amp;lt;String, Object&amp;gt; arguments
             *
             &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            channel.queueDeclare(QUEUE_SMS,&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;,&lt;span&gt;false&lt;/span&gt;,&lt;span&gt;false&lt;/span&gt;,&lt;span&gt;null&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通道绑定短信队列
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;交换机和队列绑定&lt;/span&gt;
            &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
             * 参数明细
             * 1、队列名称
             * 2、交换机名称
             * 3、路由key
             &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Publish/subscribe发布订阅模式&lt;/span&gt;
            channel.queueBind(QUEUE_SMS,EXCHANGE,&quot;&quot;&lt;span&gt;);
            DefaultConsumer consumer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultConsumer(channel) {
            &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
              * 消费者接收消息调用此方法
              * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; consumerTag 消费者的标签，在channel.basicConsume()去指定
              * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; envelope 消息包的内容，可从中获取消息id，消息routingkey，交换机，消息和重传标志
                (收到消息失败后是否需要重新发送)
              * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; properties
              * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; body
              * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; IOException
              * String consumerTag, Envelope envelope, BasicProperties properties, byte[] body
              &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, &lt;span&gt;byte&lt;/span&gt;[] body) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;交换机&lt;/span&gt;
                String exchange =&lt;span&gt; envelope.getExchange();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;路由key&lt;/span&gt;
                String routingKey =&lt;span&gt; envelope.getRoutingKey();
                envelope.getDeliveryTag();
                String msg &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; String(body,&quot;utf-8&quot;&lt;span&gt;);
                System.out.println(&lt;/span&gt;&quot;mq收到的消息是：&quot;+&lt;span&gt;msg );
            }

            };
            System.out.println(&lt;/span&gt;&quot;消费者启动成功！&quot;&lt;span&gt;);
            channel.basicConsume(QUEUE_SMS,&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,consumer);

        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (TimeoutException e) {
            e.printStackTrace();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;三、Routing 路由模式&lt;/p&gt;
&lt;p&gt;Routing 模式又称路由模式，该种模式除了要绑定交换机外，发消息的时候还要制定routing key，即路由key，队列通过通道绑定交换机的时候，需要指定自己的routing key，这样，生产端发送消息的时候也会指定routing key，通过routing key就可以把相应的消息发送到绑定相应routing key的队列中去。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1553771/201909/1553771-20190924233630696-1935170955.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;路由模式：&lt;/p&gt;
&lt;p&gt;1、每个消费者监听自己的队列，并且设置routingkey；&lt;br/&gt;2、生产者将消息发给交换机，由交换机根据routingkey来转发消息到指定的队列；&lt;/p&gt;
&lt;p&gt;应用场景：用户通知，当用户充值成功或转账完成系统通知用户，通知方式有短信、邮件多种方法；&lt;/p&gt;
&lt;p&gt;生产端：&lt;/p&gt;
&lt;p&gt;1、声明队列，声明交换机&lt;/p&gt;
&lt;p&gt;2、创建连接&lt;/p&gt;
&lt;p&gt;3、创建通道&lt;/p&gt;
&lt;p&gt;4、通道声明交换机&lt;/p&gt;
&lt;p&gt;5、通道声明队列&lt;/p&gt;
&lt;p&gt;6、通过通道使队列绑定到交换机并指定该队列的routingkey&lt;/p&gt;
&lt;p&gt;7、制定消息&lt;/p&gt;
&lt;p&gt;8、发送消息并指定routingkey&lt;/p&gt;
&lt;p&gt;消费端：&lt;/p&gt;
&lt;p&gt;1、声明队列，声明交换机&lt;/p&gt;
&lt;p&gt;2、创建连接&lt;/p&gt;
&lt;p&gt;3、创建通道&lt;/p&gt;
&lt;p&gt;4、通道声明交换机&lt;/p&gt;
&lt;p&gt;5、通道声明队列&lt;/p&gt;
&lt;p&gt;6、通过通道使队列绑定到交换机并指定routingkey&lt;/p&gt;
&lt;p&gt;7、重写消息消费方法&lt;/p&gt;
&lt;p&gt;8、执行消息方法&lt;/p&gt;
&lt;p&gt;按照假设的应用场景，同样，Routing 路由模式也是一个生产端，两个消费端，所不同的是，声明交换机的类型不同，队列绑定交换机的时候需要指定Routing key，发送消息的时候也需要指定Routing key，这样根据Routing key就能把相应的消息发送到相应的队列中去。&lt;/p&gt;
&lt;p&gt;生产端的代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.xyfer;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.rabbitmq.client.BuiltinExchangeType;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.rabbitmq.client.Channel;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.rabbitmq.client.Connection;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.rabbitmq.client.ConnectionFactory;


&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.TimeoutException;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Producer03 {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明两个队列和一个交换机
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Routing 路由模式&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String QUEUE_EMAIL =&quot;queueEmail&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String QUEUE_SMS =&quot;queueSms&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String EXCHANGE = &quot;messageChange&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        Connection connection &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        Channel channel &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            ConnectionFactory connectionFactory &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConnectionFactory();
            connectionFactory.setHost(&lt;/span&gt;&quot;127.0.0.1&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;mq服务ip地址&lt;/span&gt;
            connectionFactory.setPort(5672);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;mq client连接端口&lt;/span&gt;
            connectionFactory.setUsername(&quot;guest&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;mq登录用户名&lt;/span&gt;
            connectionFactory.setPassword(&quot;guest&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;mq登录密码&lt;/span&gt;
            connectionFactory.setVirtualHost(&quot;/&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;rabbitmq默认虚拟机名称为“/”，虚拟机相当于一个独立的mq服务器
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建与RabbitMQ服务的TCP连接&lt;/span&gt;
            connection =&lt;span&gt; connectionFactory.newConnection();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建与Exchange的通道，每个连接可以创建多个通道，每个通道代表一个会话任务&lt;/span&gt;
            channel =&lt;span&gt; connection.createChannel();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通道绑定交换机&lt;/span&gt;
            &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
             * 参数明细
             * 1、交换机名称
             * 2、交换机类型，fanout、topic、direct、headers
             &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Routing 路由模式&lt;/span&gt;
&lt;span&gt;            channel.exchangeDeclare(EXCHANGE, BuiltinExchangeType.DIRECT);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通道绑定队列&lt;/span&gt;
            &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
             * 声明队列，如果Rabbit中没有此队列将自动创建
             * param1:队列名称
             * param2:是否持久化
             * param3:队列是否独占此连接
             * param4:队列不再使用时是否自动删除此队列
             * param5:队列参数
             * String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&amp;lt;String, Object&amp;gt; arguments
             *
             &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            channel.queueDeclare(QUEUE_EMAIL,&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;,&lt;span&gt;false&lt;/span&gt;,&lt;span&gt;false&lt;/span&gt;,&lt;span&gt;null&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通道绑定邮件队列&lt;/span&gt;
            channel.queueDeclare(QUEUE_SMS,&lt;span&gt;true&lt;/span&gt;,&lt;span&gt;false&lt;/span&gt;,&lt;span&gt;false&lt;/span&gt;,&lt;span&gt;null&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通道绑定短信队列
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;交换机和队列绑定&lt;/span&gt;
            &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
             * 参数明细
             * 1、队列名称
             * 2、交换机名称
             * 3、路由key
             &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Routing 路由模式&lt;/span&gt;
&lt;span&gt;            channel.queueBind(QUEUE_EMAIL,EXCHANGE,QUEUE_EMAIL);
            channel.queueBind(QUEUE_SMS,EXCHANGE,QUEUE_SMS);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;给email队列发消息&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = 0;i&amp;lt;10;i++&lt;span&gt;){
                String message &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; String(&quot;mq 发送email消息。。。&quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
                  * 消息发布方法
                  * param1：Exchange的名称，如果没有指定，则使用Default Exchange
                  * param2:routingKey,消息的路由Key，是用于Exchange（交换机）将消息转发到指定的消息队列
                  * param3:消息包含的属性
                  * param4：消息体
                  * 这里没有指定交换机，消息将发送给默认交换机，每个队列也会绑定那个默认的交换机，但是不能显示绑定或解除绑定
                  * 默认的交换机，routingKey等于队列名称
                 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;String exchange, String routingKey, BasicProperties props, byte[] body
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Routing 路由模式&lt;/span&gt;
                channel.basicPublish(EXCHANGE,QUEUE_EMAIL,&lt;span&gt;null&lt;/span&gt;&lt;span&gt;,message.getBytes());
                System.out.println(&lt;/span&gt;&quot;mq消息发送成功！&quot;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;给sms队列发消息&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = 0;i&amp;lt;10;i++&lt;span&gt;){
                String message &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; String(&quot;mq 发送sms消息。。。&quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
                  * 消息发布方法
                  * param1：Exchange的名称，如果没有指定，则使用Default Exchange
                  * param2:routingKey,消息的路由Key，是用于Exchange（交换机）将消息转发到指定的消息队列
                  * param3:消息包含的属性
                  * param4：消息体
                  * 这里没有指定交换机，消息将发送给默认交换机，每个队列也会绑定那个默认的交换机，但是不能显示绑定或解除绑定
                  * 默认的交换机，routingKey等于队列名称
                 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;String exchange, String routingKey, BasicProperties props, byte[] body
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Routing 路由模式&lt;/span&gt;
                channel.basicPublish(EXCHANGE,QUEUE_SMS,&lt;span&gt;null&lt;/span&gt;&lt;span&gt;,message.getBytes());
                System.out.println(&lt;/span&gt;&quot;mq消息发送成功！&quot;&lt;span&gt;);
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                channel.close();
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                e.printStackTrace();
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (TimeoutException e) {
                e.printStackTrace();
            }
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                connection.close();
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                e.printStackTrace();
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;邮件消费端的代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.xyfer;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; com.rabbitmq.client.*&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.TimeoutException;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Consumer03 {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Routing 路由模式&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String QUEUE_EMAIL =&quot;queueEmail&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String EXCHANGE = &quot;messageChange&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        Connection connection &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        Channel channel &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            ConnectionFactory connectionFactory &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConnectionFactory();
            connectionFactory.setHost(&lt;/span&gt;&quot;127.0.0.1&quot;&lt;span&gt;);
            connectionFactory.setPort(&lt;/span&gt;5672&lt;span&gt;);
            connection &lt;/span&gt;=&lt;span&gt; connectionFactory.newConnection();
            channel &lt;/span&gt;=&lt;span&gt; connection.createChannel();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通道绑定交换机&lt;/span&gt;
            &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
              * 参数明细
              * 1、交换机名称
              * 2、交换机类型，fanout、topic、direct、headers
              &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Routing 路由模式&lt;/span&gt;
&lt;span&gt;            channel.exchangeDeclare(EXCHANGE, BuiltinExchangeType.DIRECT);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通道绑定队列&lt;/span&gt;
            &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
             * 声明队列，如果Rabbit中没有此队列将自动创建
             * param1:队列名称
             * param2:是否持久化
             * param3:队列是否独占此连接
             * param4:队列不再使用时是否自动删除此队列
             * param5:队列参数
             * String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&amp;lt;String, Object&amp;gt; arguments
             *
             &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            channel.queueDeclare(QUEUE_EMAIL,&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;,&lt;span&gt;false&lt;/span&gt;,&lt;span&gt;false&lt;/span&gt;,&lt;span&gt;null&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通道绑定邮件队列
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;交换机和队列绑定&lt;/span&gt;
            &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
             * 参数明细
             * 1、队列名称
             * 2、交换机名称
             * 3、路由key
             &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Routing 路由模式&lt;/span&gt;
&lt;span&gt;            channel.queueBind(QUEUE_EMAIL,EXCHANGE,QUEUE_EMAIL);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;String consumerTag, Envelope envelope, BasicProperties properties, byte[] body&lt;/span&gt;
            DefaultConsumer consumer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultConsumer(channel) {
                &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
                  * 消费者接收消息调用此方法
                  * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; consumerTag 消费者的标签，在channel.basicConsume()去指定
                  * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; envelope 消息包的内容，可从中获取消息id，消息routingkey，交换机，消息和重传标志
                    (收到消息失败后是否需要重新发送)
                  * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; properties
                  * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; body
                  * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; IOException
                 * String consumerTag, Envelope envelope, BasicProperties properties, byte[] body
                 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
                @Override
                &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, &lt;span&gt;byte&lt;/span&gt;[] body) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;交换机&lt;/span&gt;
                    String exchange =&lt;span&gt; envelope.getExchange();
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;路由key&lt;/span&gt;
                    String routingKey =&lt;span&gt; envelope.getRoutingKey();
                    envelope.getDeliveryTag();
                    String msg &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; String(body,&quot;utf-8&quot;&lt;span&gt;);
                    System.out.println(&lt;/span&gt;&quot;mq收到的消息是：&quot;+&lt;span&gt;msg );
                }

            };
            System.out.println(&lt;/span&gt;&quot;消费者启动成功！&quot;&lt;span&gt;);
            channel.basicConsume(QUEUE_EMAIL,&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,consumer);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (TimeoutException e) {
            e.printStackTrace();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;短信消费端的代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; xyfer;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; com.rabbitmq.client.*&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.TimeoutException;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Consumer03 {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Routing 路由模式&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String QUEUE_SMS =&quot;queueSms&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String EXCHANGE = &quot;messageChange&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        Connection connection &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        Channel channel &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            ConnectionFactory connectionFactory &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConnectionFactory();
            connectionFactory.setHost(&lt;/span&gt;&quot;127.0.0.1&quot;&lt;span&gt;);
            connectionFactory.setPort(&lt;/span&gt;5672&lt;span&gt;);
            connection &lt;/span&gt;=&lt;span&gt; connectionFactory.newConnection();
            channel &lt;/span&gt;=&lt;span&gt; connection.createChannel();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通道绑定交换机&lt;/span&gt;
            &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
              * 参数明细
              * 1、交换机名称
              * 2、交换机类型，fanout、topic、direct、headers
              &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Routing 路由模式&lt;/span&gt;
&lt;span&gt;            channel.exchangeDeclare(EXCHANGE, BuiltinExchangeType.DIRECT);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通道绑定队列&lt;/span&gt;
            &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
             * 声明队列，如果Rabbit中没有此队列将自动创建
             * param1:队列名称
             * param2:是否持久化
             * param3:队列是否独占此连接
             * param4:队列不再使用时是否自动删除此队列
             * param5:队列参数
             * String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&amp;lt;String, Object&amp;gt; arguments
             *
             &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            channel.queueDeclare(QUEUE_SMS,&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;,&lt;span&gt;false&lt;/span&gt;,&lt;span&gt;false&lt;/span&gt;,&lt;span&gt;null&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通道绑定短信队列
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;交换机和队列绑定&lt;/span&gt;
            &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
             * 参数明细
             * 1、队列名称
             * 2、交换机名称
             * 3、路由key
             &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Routing 路由模式&lt;/span&gt;
&lt;span&gt;            channel.queueBind(QUEUE_SMS,EXCHANGE,QUEUE_SMS);
            DefaultConsumer consumer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultConsumer(channel) {
                &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
                  * 消费者接收消息调用此方法
                  * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; consumerTag 消费者的标签，在channel.basicConsume()去指定
                  * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; envelope 消息包的内容，可从中获取消息id，消息routingkey，交换机，消息和重传标志
                    (收到消息失败后是否需要重新发送)
                  * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; properties
                  * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; body
                  * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; IOException
                 * String consumerTag, Envelope envelope, BasicProperties properties, byte[] body
                 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
                @Override
                &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, &lt;span&gt;byte&lt;/span&gt;[] body) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;交换机&lt;/span&gt;
                    String exchange =&lt;span&gt; envelope.getExchange();
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;路由key&lt;/span&gt;
                    String routingKey =&lt;span&gt; envelope.getRoutingKey();
                    envelope.getDeliveryTag();
                    String msg &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; String(body,&quot;utf-8&quot;&lt;span&gt;);
                    System.out.println(&lt;/span&gt;&quot;mq收到的消息是：&quot;+&lt;span&gt;msg );
                }
            };
            System.out.println(&lt;/span&gt;&quot;消费者启动成功！&quot;&lt;span&gt;);
            channel.basicConsume(QUEUE_SMS,&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,consumer);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (TimeoutException e) {
            e.printStackTrace();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;四、Topics 模式&lt;/p&gt;
&lt;p&gt;Topics 模式和Routing 路由模式最大的区别就是，Topics 模式发送消息和消费消息的时候是通过通配符去进行匹配的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1553771/201909/1553771-20190924234725112-169779072.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;路由模式：&lt;/p&gt;
&lt;p&gt;1、每个消费者监听自己的队列，并且设置带统配符的routingkey&lt;/p&gt;
&lt;p&gt;2、生产者将消息发给broker，由交换机根据routingkey来转发消息到指定的队列&lt;/p&gt;
&lt;p&gt;应用场景：用户通知，当用户充值成功或转账完成系统通知用户，通知方式有短信、邮件多种方法；&lt;/p&gt;
&lt;p&gt;生产端：&lt;/p&gt;
&lt;p&gt;1、声明队列，声明交换机&lt;/p&gt;
&lt;p&gt;2、创建连接&lt;/p&gt;
&lt;p&gt;3、创建通道&lt;/p&gt;
&lt;p&gt;4、通道声明交换机&lt;/p&gt;
&lt;p&gt;5、通道声明队列&lt;/p&gt;
&lt;p&gt;6、通过通道使队列绑定到交换机并指定该队列的routingkey（通配符）&lt;/p&gt;
&lt;p&gt;7、制定消息&lt;/p&gt;
&lt;p&gt;8、发送消息并指定routingkey（通配符）&lt;/p&gt;
&lt;p&gt;消费端：&lt;/p&gt;
&lt;p&gt;1、声明队列，声明交换机&lt;/p&gt;
&lt;p&gt;2、创建连接&lt;/p&gt;
&lt;p&gt;3、创建通道&lt;/p&gt;
&lt;p&gt;4、通道声明交换机&lt;/p&gt;
&lt;p&gt;5、通道声明队列&lt;/p&gt;
&lt;p&gt;6、通过通道使队列绑定到交换机并指定routingkey（通配符）&lt;/p&gt;
&lt;p&gt;7、重写消息消费方法&lt;/p&gt;
&lt;p&gt;8、执行消息方法&lt;/p&gt;
&lt;p&gt;按照假设的应用场景，Topics 模式也是一个生产端，两个消费端，生产端队列绑定交换机的时候，需要指定的routingkey是通配符，发送消息的时候绑定的routingkey也是通配符，消费端队列绑定交换机的时候routingkey也是通配符，这样就能根据通配符匹配到消息了。&lt;/p&gt;
&lt;p&gt;生产端的代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;74&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.xyfer;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.rabbitmq.client.BuiltinExchangeType;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.rabbitmq.client.Channel;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.rabbitmq.client.Connection;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.rabbitmq.client.ConnectionFactory;


&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.TimeoutException;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Producer04 {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明两个队列和一个交换机
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Topics 模式&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String QUEUE_EMAIL =&quot;queueEmail&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String QUEUE_SMS =&quot;queueSms&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String EXCHANGE = &quot;messageChange&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        Connection connection &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        Channel channel &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            ConnectionFactory connectionFactory &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConnectionFactory();
            connectionFactory.setHost(&lt;/span&gt;&quot;127.0.0.1&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;mq服务ip地址&lt;/span&gt;
            connectionFactory.setPort(5672);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;mq client连接端口&lt;/span&gt;
            connectionFactory.setUsername(&quot;guest&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;mq登录用户名&lt;/span&gt;
            connectionFactory.setPassword(&quot;guest&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;mq登录密码&lt;/span&gt;
            connectionFactory.setVirtualHost(&quot;/&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;rabbitmq默认虚拟机名称为“/”，虚拟机相当于一个独立的mq服务器
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建与RabbitMQ服务的TCP连接&lt;/span&gt;
            connection =&lt;span&gt; connectionFactory.newConnection();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建与Exchange的通道，每个连接可以创建多个通道，每个通道代表一个会话任务&lt;/span&gt;
            channel =&lt;span&gt; connection.createChannel();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通道绑定交换机&lt;/span&gt;
            &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
              * 参数明细
              * 1、交换机名称
              * 2、交换机类型，fanout、topic、direct、headers
              &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Topics 模式&lt;/span&gt;
&lt;span&gt;            channel.exchangeDeclare(EXCHANGE, BuiltinExchangeType.TOPIC);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通道绑定队列&lt;/span&gt;
            &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
             * 声明队列，如果Rabbit中没有此队列将自动创建
             * param1:队列名称
             * param2:是否持久化
             * param3:队列是否独占此连接
             * param4:队列不再使用时是否自动删除此队列
             * param5:队列参数
             * String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&amp;lt;String, Object&amp;gt; arguments
             *
             &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            channel.queueDeclare(QUEUE_EMAIL,&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;,&lt;span&gt;false&lt;/span&gt;,&lt;span&gt;false&lt;/span&gt;,&lt;span&gt;null&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通道绑定邮件队列&lt;/span&gt;
            channel.queueDeclare(QUEUE_SMS,&lt;span&gt;true&lt;/span&gt;,&lt;span&gt;false&lt;/span&gt;,&lt;span&gt;false&lt;/span&gt;,&lt;span&gt;null&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通道绑定短信队列
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;交换机和队列绑定&lt;/span&gt;
            &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
             * 参数明细
             * 1、队列名称
             * 2、交换机名称
             * 3、路由key
             &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            channel.queueBind(QUEUE_EMAIL,EXCHANGE,&lt;/span&gt;&quot;inform.#.email.#&quot;&lt;span&gt;);
            channel.queueBind(QUEUE_SMS,EXCHANGE,&lt;/span&gt;&quot;inform.#.sms.#&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;给email队列发消息&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = 0;i&amp;lt;10;i++&lt;span&gt;){
                String message &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; String(&quot;mq 发送email消息。。。&quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
                  * 消息发布方法
                  * param1：Exchange的名称，如果没有指定，则使用Default Exchange
                  * param2:routingKey,消息的路由Key，是用于Exchange（交换机）将消息转发到指定的消息队列
                  * param3:消息包含的属性
                  * param4：消息体
                  * 这里没有指定交换机，消息将发送给默认交换机，每个队列也会绑定那个默认的交换机，但是不能显示绑定或解除绑定
                  * 默认的交换机，routingKey等于队列名称
                 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;String exchange, String routingKey, BasicProperties props, byte[] body&lt;/span&gt;
                channel.basicPublish(EXCHANGE,&quot;inform.email&quot;,&lt;span&gt;null&lt;/span&gt;&lt;span&gt;,message.getBytes());
                System.out.println(&lt;/span&gt;&quot;mq email 消息发送成功！&quot;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;给sms队列发消息&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = 0;i&amp;lt;10;i++&lt;span&gt;){
                String message &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; String(&quot;mq 发送sms消息。。。&quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
                  * 消息发布方法
                  * param1：Exchange的名称，如果没有指定，则使用Default Exchange
                  * param2:routingKey,消息的路由Key，是用于Exchange（交换机）将消息转发到指定的消息队列
                  * param3:消息包含的属性
                  * param4：消息体
                  * 这里没有指定交换机，消息将发送给默认交换机，每个队列也会绑定那个默认的交换机，但是不能显示绑定或解除绑定
                  * 默认的交换机，routingKey等于队列名称
                 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;String exchange, String routingKey, BasicProperties props, byte[] body&lt;/span&gt;
                channel.basicPublish(EXCHANGE,&quot;inform.sms&quot;,&lt;span&gt;null&lt;/span&gt;&lt;span&gt;,message.getBytes());
                System.out.println(&lt;/span&gt;&quot;mq sms 消息发送成功！&quot;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;给email和sms队列发消息&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = 0;i&amp;lt;10;i++&lt;span&gt;){
                String message &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; String(&quot;mq 发送email sms消息。。。&quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
                  * 消息发布方法
                  * param1：Exchange的名称，如果没有指定，则使用Default Exchange
                  * param2:routingKey,消息的路由Key，是用于Exchange（交换机）将消息转发到指定的消息队列
                  * param3:消息包含的属性
                  * param4：消息体
                  * 这里没有指定交换机，消息将发送给默认交换机，每个队列也会绑定那个默认的交换机，但是不能显示绑定或解除绑定
                  * 默认的交换机，routingKey等于队列名称
                 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;String exchange, String routingKey, BasicProperties props, byte[] body&lt;/span&gt;
                channel.basicPublish(EXCHANGE,&quot;inform.email.sms&quot;,&lt;span&gt;null&lt;/span&gt;&lt;span&gt;,message.getBytes());
                System.out.println(&lt;/span&gt;&quot;mq email sms 消息发送成功！&quot;&lt;span&gt;);
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                channel.close();
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                e.printStackTrace();
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (TimeoutException e) {
                e.printStackTrace();
            }
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                connection.close();
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                e.printStackTrace();
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;邮件消费端的代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.xyfer;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; com.rabbitmq.client.*&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.TimeoutException;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Consumer04 {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String QUEUE_EMAIL =&quot;queueEmail&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String EXCHANGE = &quot;messageChange&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        Connection connection &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        Channel channel &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            ConnectionFactory connectionFactory &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConnectionFactory();
            connectionFactory.setHost(&lt;/span&gt;&quot;127.0.0.1&quot;&lt;span&gt;);
            connectionFactory.setPort(&lt;/span&gt;5672&lt;span&gt;);
            connection &lt;/span&gt;=&lt;span&gt; connectionFactory.newConnection();
            channel &lt;/span&gt;=&lt;span&gt; connection.createChannel();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通道绑定交换机&lt;/span&gt;
            &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
              * 参数明细
              * 1、交换机名称
              * 2、交换机类型，fanout、topic、direct、headers
              &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            channel.exchangeDeclare(EXCHANGE, BuiltinExchangeType.TOPIC);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通道绑定队列&lt;/span&gt;
            &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
             * 声明队列，如果Rabbit中没有此队列将自动创建
             * param1:队列名称
             * param2:是否持久化
             * param3:队列是否独占此连接
             * param4:队列不再使用时是否自动删除此队列
             * param5:队列参数
             * String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&amp;lt;String, Object&amp;gt; arguments
             *
             &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            channel.queueDeclare(QUEUE_EMAIL,&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;,&lt;span&gt;false&lt;/span&gt;,&lt;span&gt;false&lt;/span&gt;,&lt;span&gt;null&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通道绑定邮件队列
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;交换机和队列绑定&lt;/span&gt;
            &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
             * 参数明细
             * 1、队列名称
             * 2、交换机名称
             * 3、路由key
             &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            channel.queueBind(QUEUE_EMAIL,EXCHANGE,&lt;/span&gt;&quot;inform.#.email.#&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;String consumerTag, Envelope envelope, BasicProperties properties, byte[] body&lt;/span&gt;
            DefaultConsumer consumer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultConsumer(channel) {
                &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
                  * 消费者接收消息调用此方法
                  * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; consumerTag 消费者的标签，在channel.basicConsume()去指定
                  * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; envelope 消息包的内容，可从中获取消息id，消息routingkey，交换机，消息和重传标志
                    (收到消息失败后是否需要重新发送)
                  * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; properties
                  * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; body
                  * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; IOException
                 * String consumerTag, Envelope envelope, BasicProperties properties, byte[] body
                 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
                @Override
                &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, &lt;span&gt;byte&lt;/span&gt;[] body) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;交换机&lt;/span&gt;
                    String exchange =&lt;span&gt; envelope.getExchange();
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;路由key&lt;/span&gt;
                    String routingKey =&lt;span&gt; envelope.getRoutingKey();
                    envelope.getDeliveryTag();
                    String msg &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; String(body,&quot;utf-8&quot;&lt;span&gt;);
                    System.out.println(&lt;/span&gt;&quot;mq收到的消息是：&quot;+&lt;span&gt;msg );
                }

            };
            System.out.println(&lt;/span&gt;&quot;消费者启动成功！&quot;&lt;span&gt;);
            channel.basicConsume(QUEUE_EMAIL,&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,consumer);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (TimeoutException e) {
            e.printStackTrace();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;短信消费端的代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; xyfer;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; com.rabbitmq.client.*&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.TimeoutException;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Consumer04 {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String QUEUE_SMS =&quot;queueSms&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String EXCHANGE = &quot;messageChange&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        Connection connection &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        Channel channel &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            ConnectionFactory connectionFactory &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConnectionFactory();
            connectionFactory.setHost(&lt;/span&gt;&quot;127.0.0.1&quot;&lt;span&gt;);
            connectionFactory.setPort(&lt;/span&gt;5672&lt;span&gt;);
            connection &lt;/span&gt;=&lt;span&gt; connectionFactory.newConnection();
            channel &lt;/span&gt;=&lt;span&gt; connection.createChannel();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通道绑定交换机&lt;/span&gt;
            &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
              * 参数明细
              * 1、交换机名称
              * 2、交换机类型，fanout、topic、direct、headers
              &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            channel.exchangeDeclare(EXCHANGE, BuiltinExchangeType.TOPIC);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通道绑定队列&lt;/span&gt;
            &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
             * 声明队列，如果Rabbit中没有此队列将自动创建
             * param1:队列名称
             * param2:是否持久化
             * param3:队列是否独占此连接
             * param4:队列不再使用时是否自动删除此队列
             * param5:队列参数
             * String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&amp;lt;String, Object&amp;gt; arguments
             *
             &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            channel.queueDeclare(QUEUE_SMS,&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;,&lt;span&gt;false&lt;/span&gt;,&lt;span&gt;false&lt;/span&gt;,&lt;span&gt;null&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通道绑定邮件队列
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;交换机和队列绑定&lt;/span&gt;
            &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
             * 参数明细
             * 1、队列名称
             * 2、交换机名称
             * 3、路由key
             &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            channel.queueBind(QUEUE_SMS,EXCHANGE,&lt;/span&gt;&quot;inform.#.sms.#&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;String consumerTag, Envelope envelope, BasicProperties properties, byte[] body&lt;/span&gt;
            DefaultConsumer consumer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultConsumer(channel) {
                &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
                  * 消费者接收消息调用此方法
                  * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; consumerTag 消费者的标签，在channel.basicConsume()去指定
                  * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; envelope 消息包的内容，可从中获取消息id，消息routingkey，交换机，消息和重传标志
                    (收到消息失败后是否需要重新发送)
                  * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; properties
                  * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; body
                  * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; IOException
                 * String consumerTag, Envelope envelope, BasicProperties properties, byte[] body
                 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
                @Override
                &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, &lt;span&gt;byte&lt;/span&gt;[] body) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;交换机&lt;/span&gt;
                    String exchange =&lt;span&gt; envelope.getExchange();
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;路由key&lt;/span&gt;
                    String routingKey =&lt;span&gt; envelope.getRoutingKey();
                    envelope.getDeliveryTag();
                    String msg &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; String(body,&quot;utf-8&quot;&lt;span&gt;);
                    System.out.println(&lt;/span&gt;&quot;mq收到的消息是：&quot;+&lt;span&gt;msg );
                }

            };
            System.out.println(&lt;/span&gt;&quot;消费者启动成功！&quot;&lt;span&gt;);
            channel.basicConsume(QUEUE_SMS,&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,consumer);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (TimeoutException e) {
            e.printStackTrace();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于生产端同时发送了email的消息（10条），sms的消息（10条），email和sms同时收到的消息（10条），所以每个消费端都应收到各自的10条消息，加上同时都能收到的10条消息，每个消费端应该收到20条消息；&lt;/p&gt;
&lt;p&gt;生产端控制台打印：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1553771/201909/1553771-20190925214416976-723844054.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 邮件消费端控制台打印：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1553771/201909/1553771-20190925214458460-1385026790.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 短信消费端的控制台打印：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1553771/201909/1553771-20190925214546788-1389134545.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 生产端执行后，RabbitMQ上的消息队列情况：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1553771/201909/1553771-20190925213840213-2071788258.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 两个消费端执行完后，RabbitMQ上的消息队列情况：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1553771/201909/1553771-20190925214036566-1514168709.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 五、Header 模式&lt;/p&gt;
&lt;p&gt;header模式与routing不同的地方在于，header模式取消routingkey，使用header中的 key/value（键值对）匹配队列。&lt;/p&gt;
&lt;p&gt;案例：&lt;/p&gt;
&lt;p&gt;根据用户的通知设置去通知用户，设置接收Email的用户只接收Email，设置接收sms的用户只接收sms，设置两种通知类型都接收的则两种通知都有效。&lt;/p&gt;
&lt;p&gt;根据假设使用场景，需要一个生产端，两个消费端，不同的是，生产端声明交换机时，交换机的类型不同，是headers类型，生产端队列绑定交换机时，不使用routingkey，而是使用header中的 key/value（键值对）匹配队列，发送消息时也是使用header中的 key/value（键值对）匹配队列。&lt;/p&gt;
&lt;p&gt;消费端同样是声明交换机时，交换机的类型不同，是headers类型，消费端队列绑定交换机时，不使用routingkey，而是使用header中的 key/value（键值对）匹配队列，消费消息时也是使用header中的 key/value（键值对）匹配队列。&lt;/p&gt;
&lt;p&gt;生产端的代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;85&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.xyfer;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; com.rabbitmq.client.*&lt;span&gt;;


&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Hashtable;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Map;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.TimeoutException;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Producer05 {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明两个队列和一个交换机
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Header 模式&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String QUEUE_EMAIL =&quot;queueEmail&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String QUEUE_SMS =&quot;queueSms&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String EXCHANGE = &quot;messageChange&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        Connection connection &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        Channel channel &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            ConnectionFactory connectionFactory &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConnectionFactory();
            connectionFactory.setHost(&lt;/span&gt;&quot;127.0.0.1&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;mq服务ip地址&lt;/span&gt;
            connectionFactory.setPort(5672);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;mq client连接端口&lt;/span&gt;
            connectionFactory.setUsername(&quot;guest&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;mq登录用户名&lt;/span&gt;
            connectionFactory.setPassword(&quot;guest&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;mq登录密码&lt;/span&gt;
            connectionFactory.setVirtualHost(&quot;/&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;rabbitmq默认虚拟机名称为“/”，虚拟机相当于一个独立的mq服务器
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建与RabbitMQ服务的TCP连接&lt;/span&gt;
            connection =&lt;span&gt; connectionFactory.newConnection();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建与Exchange的通道，每个连接可以创建多个通道，每个通道代表一个会话任务&lt;/span&gt;
            channel =&lt;span&gt; connection.createChannel();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通道绑定交换机&lt;/span&gt;
            &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
              * 参数明细
              * 1、交换机名称
              * 2、交换机类型，fanout、topic、direct、headers
              &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Header 模式&lt;/span&gt;
&lt;span&gt;            channel.exchangeDeclare(EXCHANGE, BuiltinExchangeType.HEADERS);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通道绑定队列&lt;/span&gt;
            &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
             * 声明队列，如果Rabbit中没有此队列将自动创建
             * param1:队列名称
             * param2:是否持久化
             * param3:队列是否独占此连接
             * param4:队列不再使用时是否自动删除此队列
             * param5:队列参数
             * String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&amp;lt;String, Object&amp;gt; arguments
             *
             &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            channel.queueDeclare(QUEUE_EMAIL,&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;,&lt;span&gt;false&lt;/span&gt;,&lt;span&gt;false&lt;/span&gt;,&lt;span&gt;null&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通道绑定邮件队列&lt;/span&gt;
            channel.queueDeclare(QUEUE_SMS,&lt;span&gt;true&lt;/span&gt;,&lt;span&gt;false&lt;/span&gt;,&lt;span&gt;false&lt;/span&gt;,&lt;span&gt;null&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通道绑定短信队列
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;交换机和队列绑定&lt;/span&gt;
            &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
             * 参数明细
             * 1、队列名称
             * 2、交换机名称
             * 3、路由key
             * 4、
             * String queue, String exchange, String routingKey, Map&amp;lt;String, Object&amp;gt; arguments
             &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            Map&lt;/span&gt;&amp;lt;String,Object&amp;gt; headers_email = &lt;span&gt;new&lt;/span&gt; Hashtable&amp;lt;String,Object&amp;gt;&lt;span&gt;();
            headers_email.put(&lt;/span&gt;&quot;inform_type&quot;,&quot;email&quot;&lt;span&gt;);
            Map&lt;/span&gt;&amp;lt;String,Object&amp;gt; headers_sms = &lt;span&gt;new&lt;/span&gt; Hashtable&amp;lt;String, Object&amp;gt;&lt;span&gt;();
            headers_sms.put(&lt;/span&gt;&quot;inform_type&quot;,&quot;sms&quot;&lt;span&gt;);
            channel.queueBind(QUEUE_EMAIL,EXCHANGE,&lt;/span&gt;&quot;&quot;&lt;span&gt;,headers_email);
            channel.queueBind(QUEUE_SMS,EXCHANGE,&lt;/span&gt;&quot;&quot;&lt;span&gt;,headers_sms);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;给email队列发消息&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = 0;i&amp;lt;10;i++&lt;span&gt;){
                String message &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; String(&quot;mq 发送email消息。。。&quot;&lt;span&gt;);
                Map&lt;/span&gt;&amp;lt;String,Object&amp;gt; headers = &lt;span&gt;new&lt;/span&gt; Hashtable&amp;lt;String,Object&amp;gt;&lt;span&gt;();
                headers.put(&lt;/span&gt;&quot;inform_type&quot;,&quot;email&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;匹配email通知消费者绑定的header&lt;/span&gt;
                &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
                  * 消息发布方法
                  * param1：Exchange的名称，如果没有指定，则使用Default Exchange
                  * param2:routingKey,消息的路由Key，是用于Exchange（交换机）将消息转发到指定的消息队列
                  * param3:消息包含的属性
                  * param4：消息体
                  * 这里没有指定交换机，消息将发送给默认交换机，每个队列也会绑定那个默认的交换机，但是不能显示绑定或解除绑定
                  * 默认的交换机，routingKey等于队列名称
                 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;String exchange, String routingKey, BasicProperties props, byte[] body&lt;/span&gt;
                AMQP.BasicProperties.Builder properties = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AMQP.BasicProperties.Builder();
                properties.headers(headers);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Email通知&lt;/span&gt;
                channel.basicPublish(EXCHANGE,&quot;&quot;&lt;span&gt;,properties.build(),message.getBytes());
                System.out.println(&lt;/span&gt;&quot;mq email 消息发送成功！&quot;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;给sms队列发消息&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = 0;i&amp;lt;10;i++&lt;span&gt;){
                String message &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; String(&quot;mq 发送sms消息。。。&quot;&lt;span&gt;);
                Map&lt;/span&gt;&amp;lt;String,Object&amp;gt; headers = &lt;span&gt;new&lt;/span&gt; Hashtable&amp;lt;String,Object&amp;gt;&lt;span&gt;();
                headers.put(&lt;/span&gt;&quot;inform_type&quot;,&quot;sms&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;匹配sms通知消费者绑定的header&lt;/span&gt;
                &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
                  * 消息发布方法
                  * param1：Exchange的名称，如果没有指定，则使用Default Exchange
                  * param2:routingKey,消息的路由Key，是用于Exchange（交换机）将消息转发到指定的消息队列
                  * param3:消息包含的属性
                  * param4：消息体
                  * 这里没有指定交换机，消息将发送给默认交换机，每个队列也会绑定那个默认的交换机，但是不能显示绑定或解除绑定
                  * 默认的交换机，routingKey等于队列名称
                 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;String exchange, String routingKey, BasicProperties props, byte[] body&lt;/span&gt;
                AMQP.BasicProperties.Builder properties = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AMQP.BasicProperties.Builder();
                properties.headers(headers);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;sms通知&lt;/span&gt;
                channel.basicPublish(EXCHANGE,&quot;&quot;&lt;span&gt;,properties.build(),message.getBytes());
                System.out.println(&lt;/span&gt;&quot;mq sms 消息发送成功！&quot;&lt;span&gt;);
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                channel.close();
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                e.printStackTrace();
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (TimeoutException e) {
                e.printStackTrace();
            }
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                connection.close();
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                e.printStackTrace();
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;邮件消费端的代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.xyfer;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; com.rabbitmq.client.*&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Hashtable;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Map;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.TimeoutException;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Consumer05 {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String QUEUE_EMAIL =&quot;queueEmail&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String EXCHANGE = &quot;messageChange&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        Connection connection &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        Channel channel &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            ConnectionFactory connectionFactory &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConnectionFactory();
            connectionFactory.setHost(&lt;/span&gt;&quot;127.0.0.1&quot;&lt;span&gt;);
            connectionFactory.setPort(&lt;/span&gt;5672&lt;span&gt;);
            connection &lt;/span&gt;=&lt;span&gt; connectionFactory.newConnection();
            channel &lt;/span&gt;=&lt;span&gt; connection.createChannel();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通道绑定交换机&lt;/span&gt;
            &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
                          * 参数明细
                          * 1、交换机名称
                          * 2、交换机类型，fanout、topic、direct、headers
                          &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            channel.exchangeDeclare(EXCHANGE, BuiltinExchangeType.HEADERS);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通道绑定队列&lt;/span&gt;
            &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
             * 声明队列，如果Rabbit中没有此队列将自动创建
             * param1:队列名称
             * param2:是否持久化
             * param3:队列是否独占此连接
             * param4:队列不再使用时是否自动删除此队列
             * param5:队列参数
             * String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&amp;lt;String, Object&amp;gt; arguments
             *
             &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            channel.queueDeclare(QUEUE_EMAIL,&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;,&lt;span&gt;false&lt;/span&gt;,&lt;span&gt;false&lt;/span&gt;,&lt;span&gt;null&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通道绑定邮件队列
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;交换机和队列绑定&lt;/span&gt;
            &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
             * 参数明细
             * 1、队列名称
             * 2、交换机名称
             * 3、路由key
             * 4、
             * String queue, String exchange, String routingKey, Map&amp;lt;String, Object&amp;gt; arguments
             &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            Map&lt;/span&gt;&amp;lt;String,Object&amp;gt; headers_email = &lt;span&gt;new&lt;/span&gt; Hashtable&amp;lt;String,Object&amp;gt;&lt;span&gt;();
            headers_email.put(&lt;/span&gt;&quot;inform_email&quot;,&quot;email&quot;&lt;span&gt;);
            channel.queueBind(QUEUE_EMAIL,EXCHANGE,&lt;/span&gt;&quot;&quot;&lt;span&gt;,headers_email);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;String consumerTag, Envelope envelope, BasicProperties properties, byte[] body&lt;/span&gt;
            DefaultConsumer consumer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultConsumer(channel) {
                &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
                  * 消费者接收消息调用此方法
                  * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; consumerTag 消费者的标签，在channel.basicConsume()去指定
                  * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; envelope 消息包的内容，可从中获取消息id，消息routingkey，交换机，消息和重传标志
                    (收到消息失败后是否需要重新发送)
                  * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; properties
                  * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; body
                  * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; IOException
                 * String consumerTag, Envelope envelope, BasicProperties properties, byte[] body
                 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
                @Override
                &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, &lt;span&gt;byte&lt;/span&gt;[] body) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;交换机&lt;/span&gt;
                    String exchange =&lt;span&gt; envelope.getExchange();
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;路由key&lt;/span&gt;
                    String routingKey =&lt;span&gt; envelope.getRoutingKey();
                    envelope.getDeliveryTag();
                    String msg &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; String(body,&quot;utf-8&quot;&lt;span&gt;);
                    System.out.println(&lt;/span&gt;&quot;mq收到的消息是：&quot;+&lt;span&gt;msg );
                }

            };
            System.out.println(&lt;/span&gt;&quot;消费者启动成功！&quot;&lt;span&gt;);
            channel.basicConsume(QUEUE_EMAIL,&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,consumer);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (TimeoutException e) {
            e.printStackTrace();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;短信消费端的代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; xyfer;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; com.rabbitmq.client.*&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Hashtable;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Map;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.TimeoutException;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Consumer05 {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String QUEUE_SMS =&quot;queueSms&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String EXCHANGE = &quot;messageChange&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        Connection connection &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        Channel channel &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            ConnectionFactory connectionFactory &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConnectionFactory();
            connectionFactory.setHost(&lt;/span&gt;&quot;127.0.0.1&quot;&lt;span&gt;);
            connectionFactory.setPort(&lt;/span&gt;5672&lt;span&gt;);
            connection &lt;/span&gt;=&lt;span&gt; connectionFactory.newConnection();
            channel &lt;/span&gt;=&lt;span&gt; connection.createChannel();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通道绑定交换机&lt;/span&gt;
            &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
              * 参数明细
              * 1、交换机名称
              * 2、交换机类型，fanout、topic、direct、headers
              &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            channel.exchangeDeclare(EXCHANGE, BuiltinExchangeType.HEADERS);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通道绑定队列&lt;/span&gt;
            &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
             * 声明队列，如果Rabbit中没有此队列将自动创建
             * param1:队列名称
             * param2:是否持久化
             * param3:队列是否独占此连接
             * param4:队列不再使用时是否自动删除此队列
             * param5:队列参数
             * String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&amp;lt;String, Object&amp;gt; arguments
             *
             &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            channel.queueDeclare(QUEUE_SMS,&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;,&lt;span&gt;false&lt;/span&gt;,&lt;span&gt;false&lt;/span&gt;,&lt;span&gt;null&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通道绑定邮件队列
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;交换机和队列绑定&lt;/span&gt;
            &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
             * 参数明细
             * 1、队列名称
             * 2、交换机名称
             * 3、路由key
             * 4、
             * String queue, String exchange, String routingKey, Map&amp;lt;String, Object&amp;gt; arguments
             &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            Map&lt;/span&gt;&amp;lt;String,Object&amp;gt; headers_email = &lt;span&gt;new&lt;/span&gt; Hashtable&amp;lt;String,Object&amp;gt;&lt;span&gt;();
            headers_email.put(&lt;/span&gt;&quot;inform_email&quot;,&quot;sms&quot;&lt;span&gt;);
            channel.queueBind(QUEUE_SMS,EXCHANGE,&lt;/span&gt;&quot;&quot;&lt;span&gt;,headers_email);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;String consumerTag, Envelope envelope, BasicProperties properties, byte[] body&lt;/span&gt;
            DefaultConsumer consumer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultConsumer(channel) {
                &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
                  * 消费者接收消息调用此方法
                  * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; consumerTag 消费者的标签，在channel.basicConsume()去指定
                  * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; envelope 消息包的内容，可从中获取消息id，消息routingkey，交换机，消息和重传标志
                    (收到消息失败后是否需要重新发送)
                  * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; properties
                  * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; body
                  * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; IOException
                 * String consumerTag, Envelope envelope, BasicProperties properties, byte[] body
                 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
                @Override
                &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, &lt;span&gt;byte&lt;/span&gt;[] body) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;交换机&lt;/span&gt;
                    String exchange =&lt;span&gt; envelope.getExchange();
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;路由key&lt;/span&gt;
                    String routingKey =&lt;span&gt; envelope.getRoutingKey();
                    envelope.getDeliveryTag();
                    String msg &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; String(body,&quot;utf-8&quot;&lt;span&gt;);
                    System.out.println(&lt;/span&gt;&quot;mq收到的消息是：&quot;+&lt;span&gt;msg );
                }

            };
            System.out.println(&lt;/span&gt;&quot;消费者启动成功！&quot;&lt;span&gt;);
            channel.basicConsume(QUEUE_SMS,&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,consumer);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (TimeoutException e) {
            e.printStackTrace();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;生产端启动后RabbitMQ上面的消息队列情况：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1553771/201909/1553771-20190925224555584-1586624696.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;六、RPC 模式&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1553771/201909/1553771-20190925224642089-423222692.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; RPC即客户端远程调用服务端的方法 ，使用MQ可以实现RPC的异步调用，基于Direct交换机实现，流程如下：&lt;/p&gt;
&lt;p&gt;1、客户端即是生产者也是消费者，向RPC请求队列发送RPC调用消息，同时监听RPC响应队列。&lt;/p&gt;
&lt;p&gt;2、服务端监听RPC请求队列的消息，收到消息后执行服务端的方法，得到方法返回的结果。&lt;/p&gt;
&lt;p&gt;3、服务端将RPC方法 的结果发送到RPC响应队列。&lt;/p&gt;
&lt;p&gt;4、客户端（RPC调用方）监听RPC响应队列，接收到RPC调用结果。&lt;/p&gt;

&lt;p&gt;至此，RabbitMQ的六种工作模式已经介绍完毕，手动代码实现，实际体验六种工作模式的不同。&lt;/p&gt;

</description>
<pubDate>Wed, 25 Sep 2019 14:54:00 +0000</pubDate>
<dc:creator>侧身左睡</dc:creator>
<og:description>最近学习RabbitMQ的使用方式，记录下来，方便以后使用，也方便和大家共享，相互交流。 RabbitMQ的六种工作模式： 1、Work queues2、Publish/subscribe3、Rout</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xyfer1018/p/11581511.html</dc:identifier>
</item>
<item>
<title>Spring框架学习笔记（2）——面向切面编程AOP - Stars-one</title>
<link>http://www.cnblogs.com/kexing/p/11588066.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kexing/p/11588066.html</guid>
<description>&lt;h2 id=&quot;介绍&quot;&gt;介绍&lt;/h2&gt;
&lt;h3 id=&quot;概念&quot;&gt;概念&lt;/h3&gt;
&lt;p&gt;面向切面编程AOP与面向对象编程OOP有所不同，AOP不是对OOP的替换，而是对OOP的一种补充，AOP增强了OOP。&lt;/p&gt;
&lt;p&gt;假设我们有几个业务代码，都调用了某个方法，按照OOP的思想，我们就会将此方法封装在一个类中，之后通过&lt;code&gt;对象.方法名&lt;/code&gt;调用&lt;/p&gt;
&lt;p&gt;我们可以看作我们的业务代码被其他代码入侵或者是业务代码被其他与业务不相关的代码入侵了&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这个时候，如果我们使用AOP进行编写代码，我们的业务代码就可以不需要写其他与业务相关的代码，这样就可以保证业务代码的纯洁性&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;aop运行流程&quot;&gt;AOP运行流程&lt;/h3&gt;
&lt;p&gt;通过配置文件，给各个业务方法标识切入点（PointCut），即切入点方法。&lt;br/&gt;之后当程序运行到切入点方法的时候，就会发出一个通知（Advice），去通知执行某个切面方法（Aspect）&lt;/p&gt;
&lt;h3 id=&quot;专业术语&quot;&gt;专业术语&lt;/h3&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;10&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&lt;strong&gt;Aspect&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;一个模块具有一组提供横切需求的 APIs。例如，一个日志模块为了记录日志将被 AOP 方面调用。应用程序可以拥有任意数量的方面，这取决于需求。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&lt;strong&gt;Join point&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;在你的应用程序中它代表一个点，你可以在插件 AOP 方面。你也能说，它是在实际的应用程序中，其中一个操作将使用 Spring AOP 框架。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&lt;strong&gt;Advice&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;这是实际行动之前或之后执行的方法。这是在程序执行期间通过 Spring AOP 框架实际被调用的代码。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&lt;strong&gt;Pointcut&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;这是一组一个或多个连接点，通知应该被执行。你可以使用表达式或模式指定切入点正如我们将在 AOP 的例子中看到的。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Introduction&lt;/td&gt;
&lt;td&gt;引用允许你添加新方法或属性到现有的类中。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&lt;strong&gt;Target object&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;被一个或者多个方面所通知的对象，这个对象永远是一个被代理对象。也称为被通知对象。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;Weaving&lt;/td&gt;
&lt;td&gt;Weaving 把方面连接到其它的应用程序类型或者对象上，并创建一个被通知的对象。这些可以在编译时，类加载时和运行时完成。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;advice通知&quot;&gt;Advice通知&lt;/h3&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;10&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;前置通知（Before Advice）&lt;/td&gt;
&lt;td&gt;在切入点方法执行之前，执行通知&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;环绕通知（Around Advice）&lt;/td&gt;
&lt;td&gt;在切入点方法执行的整个过程都可以执行通知&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;后置通知（After Returning Advice）&lt;/td&gt;
&lt;td&gt;在切入点方法执行之后，只有在方法成功执行时，才能执行通知。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;最终通知（After Finally Advices）&lt;/td&gt;
&lt;td&gt;在一个方法执行之后，不管是方法是否成功执行 ，执行通知&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;异常通知（After Throwing Advice）&lt;/td&gt;
&lt;td&gt;在一个方法执行之后，只有在方法退出抛出异常时，才能执行通知。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;PS：其实，这些通知就是相当于你可以在业务方法的&lt;strong&gt;执行前（前置通知）、执行中（环绕通知）、执行成功之后（后置通知）、发生异常（异常通知）、不管方法是发生异常还是执行成功（最终通知）&lt;/strong&gt;，执行某些与业务功能无关的功能代码。&lt;/p&gt;
&lt;p&gt;这样就可以降低业务功能代码的入侵和污染&lt;/p&gt;
&lt;p&gt;下面使用两种不同的方式来实现一个方法日志打印的简单例子&lt;/p&gt;
&lt;h2 id=&quot;后置通知例子&quot;&gt;后置通知例子&lt;/h2&gt;
&lt;p&gt;下面的通知是基于xml配置的&lt;/p&gt;
&lt;h3 id=&quot;添加依赖&quot;&gt;1.添加依赖&lt;/h3&gt;
&lt;p&gt;除了之前的spring的jar包，还需要两个jar包，&lt;code&gt;aopalliance.jar&lt;/code&gt;和&lt;code&gt;aspectjweaver.jar&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;4.11&amp;lt;/version&amp;gt;
    &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;commons-logging&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;commons-logging&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;RELEASE&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-context&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;RELEASE&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-test&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;RELEASE&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-core&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;RELEASE&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-beans&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;RELEASE&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-aop&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;RELEASE&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-expression&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;RELEASE&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;!-- aop需要的jar --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.aspectj&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;aspectjweaver&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;RELEASE&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;aopalliance&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;aopalliance&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;RELEASE&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;业务代码&quot;&gt;2.业务代码&lt;/h3&gt;
&lt;p&gt;我编写了一个TeacherDao类，里面只有add和delete方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.wan;

/**
 * @author StarsOne
 * @date Create in  2019/9/25 0025 16:34
 * @description
 */
public class TeacherDao {
    public void add(Teacher teacher) {
        System.out.println(&quot;往数据库中插入一条数据&quot;);
    }

    public void delete(Teacher teacher) {
        System.out.println(&quot;从数据库中删除一条数据&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;编写mylogging.java&quot;&gt;3.编写MyLogging.java&lt;/h3&gt;
&lt;p&gt;前面说过了通知具有五种类型，我们根据需要，选择合适的通知类型，让某个类实现通知对应的接口，这里其实就是相当于编写切面方法&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;13.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;8&quot;&gt;&lt;td&gt;前置通知&lt;/td&gt;
&lt;td&gt;org.springframework.aop.MethodBeforeAdvice&lt;/td&gt;
&lt;td&gt;before(Method method, Object[] args, Object target)&lt;/td&gt;
&lt;td&gt;method是方法，args是方法的参数，target是目标对象&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;6&quot;&gt;&lt;td&gt;环绕通知&lt;/td&gt;
&lt;td&gt;org.aopalliance.intercept.MethodInterceptor&lt;/td&gt;
&lt;td&gt;invoke(MethodInvocation invocation)&lt;/td&gt;
&lt;td&gt;invocation对象中包含有method，方法参数和目标对象&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;9&quot;&gt;&lt;td&gt;后置通知&lt;/td&gt;
&lt;td&gt;org.springframework.aop.AfterReturningAdvice&lt;/td&gt;
&lt;td&gt;afterReturning(Object returnValue, Method method, Object[] args, Object target)&lt;/td&gt;
&lt;td&gt;returnValue是方法的返回值，其他的参数和前置通知一样&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;最终通知&lt;/td&gt;
&lt;td&gt;org.springframework.aop.AfterAdvice&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;异常通知&lt;/td&gt;
&lt;td&gt;org.springframework.aop.ThrowsAdvice&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;我们日志输出，选择后置通知，也就是方法执行完成之后调用&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MyLogging.java&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.wan;

import org.aopalliance.intercept.MethodInterceptor;
import org.aopalliance.intercept.MethodInvocation;
import org.springframework.aop.AfterReturningAdvice;
import org.springframework.aop.MethodBeforeAdvice;

import java.lang.reflect.Method;

/**
 * @author StarsOne
 * @date Create in  2019/9/25 0025 16:53
 * @description
 */
public class MyLogging implements AfterReturningAdvice {

    @Override
    public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable {
        String methodName = method.getName();//方法名
        int size = args.length;//参数个数
        System.out.println(&quot;调用了&quot;+target+&quot;的&quot;+methodName+&quot;方法，该方法的参数个数有&quot;+size+&quot;个&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;xml配置&quot;&gt;4.xml配置&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&amp;gt;

    &amp;lt;bean id=&quot;mylog&quot; class=&quot;com.wan.MyLogging&quot;/&amp;gt;
    &amp;lt;bean id=&quot;teacherdao&quot; class=&quot;com.wan.TeacherDao&quot;/&amp;gt;

    &amp;lt;aop:config&amp;gt;
        &amp;lt;aop:pointcut id=&quot;mypointcut&quot; expression=&quot;execution(public void add(com.wan.Teacher))&quot;/&amp;gt;
        &amp;lt;aop:advisor advice-ref=&quot;mylog&quot; pointcut-ref=&quot;mypointcut&quot;/&amp;gt;
    &amp;lt;/aop:config&amp;gt;
&amp;lt;/beans&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里和之前一样，也需要引用&lt;code&gt;aop&lt;/code&gt;命名空间，IDEA可以智能帮我们导入，输入&lt;code&gt;&amp;lt;aop:&lt;/code&gt;，之后就会弹出提示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1210268/201909/1210268-20190925205450294-2062697733.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;各元素和属性说明：&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;aop:pointcut&lt;/td&gt;
&lt;td&gt;切入点，当执行当切入点方法的时候，就会根据通知（Advice）的类型，从而执行非业务功能的代码&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;id&lt;/td&gt;
&lt;td&gt;切入点的唯一表示，下面pointcut-ref属性需要引用此id&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;expression&lt;/td&gt;
&lt;td&gt;表达式，只要是符合此表达式的方法，都会被当作切入点&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;aop:advisor&lt;/td&gt;
&lt;td&gt;通知&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;pointcut-ref&lt;/td&gt;
&lt;td&gt;引用切入点的id&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;advice-ref&lt;/td&gt;
&lt;td&gt;引用切入点接口类的bean的id&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;补充，关于expression的例子：&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;13.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;public boolean addTeacher(com.wan.Teacher)&lt;/td&gt;
&lt;td&gt;所有返回类型为boolean，参数类型为com.wan.Teacher，方法名为addTeacher的方法&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;public void com.wan.TeacherDao.add(com.wan.Teacher)&lt;/td&gt;
&lt;td&gt;方法存在TeacherDao类中，返回类型为空，参数类型为Teacher，方法名为add的方法&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;public * addTeacher(com.wan.Teacher)&lt;/td&gt;
&lt;td&gt;所有返回类型为任意类型，参数类型为com.wan.Teacher，方法名为addTeacher的方法&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;public boolean *(com.wan.Teacher)&lt;/td&gt;
&lt;td&gt;所有返回类型为任意类型，参数类型为Teacher,方法名任意的方法&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;public boolean addTeacher(..)&lt;/td&gt;
&lt;td&gt;所有返回类型为任意类型，参数类型和个数不限，方法名为addTeacher的方法&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;* com.wan.*.*(..)&lt;/td&gt;
&lt;td&gt;在com.wan包下面的所有方法（不包括子包）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;* com.wan..*.*(..)&lt;/td&gt;
&lt;td&gt;在com.wan包下面的所有方法（包括子包）&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;表达式要写在execution()的括号里面，多个条件可以使用or连接&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;测试&quot;&gt;5.测试&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring-config.xml&quot;);
TeacherDao teacherdao = (TeacherDao) context.getBean(&quot;teacherdao&quot;);
teacherdao.add(new Teacher());&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1210268/201909/1210268-20190925212138317-673948363.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;其他类型通知advice使用&quot;&gt;其他类型通知Advice使用&lt;/h2&gt;
&lt;h3 id=&quot;前置通知&quot;&gt;前置通知&lt;/h3&gt;
&lt;p&gt;前置通知和后置通知一样，也是实现对应的接口，然后重写before方法，这里就不过多说明了&lt;/p&gt;
&lt;h3 id=&quot;异常通知&quot;&gt;异常通知&lt;/h3&gt;
&lt;p&gt;异常通知有点特殊，因为此接口是不需要重写方法的，但是，我们想要实现异常通知，得按照它定义的规则来&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;afterThrowing([Method method,Object[] args,Object target],Throwable ex)&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;方法名必须是afterThrowing&lt;/li&gt;
&lt;li&gt;参数列表中的最后一个参数必须存在，可以是Throwable或者Throwable的子类&lt;/li&gt;
&lt;li&gt;方法列表的前三个参数要么都存在，要么一个都不存在&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;环绕通知&quot;&gt;环绕通知&lt;/h3&gt;
&lt;p&gt;此通知是spring的最强扩展，因为环绕通知可以拦截方法，对方法的传入参数的数值、返回值进行更改，或者是决定方法是否执行，也可以对目标进行异常处理。&lt;/p&gt;
&lt;p&gt;如果对破解有所了解的话，环绕通知还可以被称为hook，像Android的Xposed框架就是通过hook原理，来达到自由更改系统目的。&lt;br/&gt;实现MethodInterceptor接口，重写其的invoke方法&lt;/p&gt;
&lt;p&gt;invoke方法可以获得像之前的前置通知的三个参数，&lt;code&gt;method&lt;/code&gt;，&lt;code&gt;target&lt;/code&gt;，&lt;code&gt;args&lt;/code&gt;，也可以获得返回值&lt;code&gt;returnValue&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.wan;

import org.aopalliance.intercept.MethodInterceptor;
import org.aopalliance.intercept.MethodInvocation;
import org.springframework.aop.AfterReturningAdvice;
import org.springframework.aop.MethodBeforeAdvice;

import java.lang.reflect.Method;

/**
 * @author StarsOne
 * @date Create in  2019/9/25 0025 16:53
 * @description
 */
public class MyLogging implements MethodInterceptor {

    @Override
    public Object invoke(MethodInvocation invocation) throws Throwable {
        Object target = invoke.getThis();
        Method method = invoke.getMethod();
        Object[] args = invoke.getArguments();
        //执行方法，获得返回值
        Object returnValue = invoke.proceed();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;基于注解配置使用&quot;&gt;基于注解配置使用&lt;/h2&gt;
&lt;p&gt;上面说的几个例子都是基于xml配置文件，我们可以使用注解，从而达到简化的目的&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;@Aspect&lt;/td&gt;
&lt;td&gt;标注切入点&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;@Before&lt;/td&gt;
&lt;td&gt;标注前置通知&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;@Around&lt;/td&gt;
&lt;td&gt;标注环绕通知&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;@AfterReturning&lt;/td&gt;
&lt;td&gt;标注后置通知&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;@After&lt;/td&gt;
&lt;td&gt;标注最终通知&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;@AfterThrowing&lt;/td&gt;
&lt;td&gt;标注异常通知&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;步骤&quot;&gt;步骤&lt;/h3&gt;
&lt;h4 id=&quot;导入相关jar之前导入的那两个jar包&quot;&gt;1. 导入相关jar（之前导入的那两个jar包）&lt;/h4&gt;
&lt;h4 id=&quot;使用注解标注类和方法&quot;&gt;2. 使用注解，标注类和方法&lt;/h4&gt;
&lt;h4 id=&quot;xml中开启配置&quot;&gt;3. xml中开启配置&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&amp;gt;

    &amp;lt;bean id=&quot;teacherdao&quot; class=&quot;com.wan.TeacherDao&quot;/&amp;gt;

    &amp;lt;aop:aspectj-autoproxy/&amp;gt;
    &amp;lt;bean class=&quot;com.wan.MyLogging&quot;/&amp;gt;
&amp;lt;/beans&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;之后的测试代码和之前的一样&lt;/p&gt;
&lt;h3 id=&quot;前置通知-1&quot;&gt;前置通知&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;package com.wan;

import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;

/**
 * @author StarsOne
 * @date Create in  2019/9/25 0025 16:53
 * @description
 */
@Aspect
public class MyLogging  {
    @Before(&quot;execution(public void add(com.wan.Teacher))&quot;)
    public void sayHello() {
        System.out.println(&quot;这是前置通知&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注解使用挺简单的，大概看一下示例代码就能知道怎么使用了&lt;/p&gt;
&lt;h3 id=&quot;获得三个参数targetargsmethod&quot;&gt;获得三个参数target、args、method&lt;/h3&gt;
&lt;p&gt;AOP中有个JoinPoint的接口，此接口可以获得&lt;code&gt;target&lt;/code&gt;、&lt;code&gt;args&lt;/code&gt;、&lt;code&gt;method&lt;/code&gt;这三个参数&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;getTarget()&lt;/td&gt;
&lt;td&gt;获得目标对象&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;getSignature()&lt;/td&gt;
&lt;td&gt;获得目标方法的Signature对象，由此对象的getName可以获得方法名&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;getArgs()&lt;/td&gt;
&lt;td&gt;获得参数列表&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;pre&gt;
&lt;code&gt;package com.wan;

import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;

/**
 * @author StarsOne
 * @date Create in  2019/9/25 0025 16:53
 * @description
 */
@Aspect
public class MyLogging  {
    @AfterReturning(pointcut=&quot;execution(public boolean add(com.wan.Teacher))&quot;,returning=&quot;returnValue&quot;)
    public void test(JoinPoint jp,Object returnValue) {
        //上面的注解的returning属性把方法的返回值赋值给了参数returnValue
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;环绕通知-1&quot;&gt;环绕通知&lt;/h3&gt;
&lt;p&gt;环绕通知有个特殊的接口&lt;code&gt;ProceedingJoinPoint&lt;/code&gt;，此接口是&lt;code&gt;JoinPoint&lt;/code&gt;的子接口，比JoinPoint接口多了一个proceed方法，用于执行目的对象的方法获得返回值&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.wan;

import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;

/**
 * @author StarsOne
 * @date Create in  2019/9/25 0025 16:53
 * @description
 */
@Aspect
public class MyLogging  {
    @Around(&quot;execution(public boolean add(com.wan.Teacher))&quot;)
    public void test(ProceedingJoinPoint jp) {
        Object returnValue = jp.proceed();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;异常通知-1&quot;&gt;异常通知&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;package com.wan;

import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;

/**
 * @author StarsOne
 * @date Create in  2019/9/25 0025 16:53
 * @description
 */
@Aspect
public class MyLogging  {
    @AfterThorwing(pointcut=&quot;execution(public boolean add(com.wan.Teacher))&quot;,throwing=&quot;e&quot;)
    public void test(JoinPoint jp,NullPointException e) {
        //上面的注解的throwing属性把异常赋值给了参数e
        //参数中指定了异常为空指针异常，所有，发生异常为空指针异常时候，异常通知才会调用此方法
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;PS：除以上两种方式可以实现AOP，还有一种使用Schema进行配置，我看了一下步骤，觉得比上面两种还要繁琐，在这里就补充了&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 25 Sep 2019 14:26:00 +0000</pubDate>
<dc:creator>Stars-one</dc:creator>
<og:description>介绍 概念 面向切面编程AOP与面向对象编程OOP有所不同，AOP不是对OOP的替换，而是对OOP的一种补充，AOP增强了OOP。 假设我们有几个业务代码，都调用了某个方法，按照OOP的思想，我们就会</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kexing/p/11588066.html</dc:identifier>
</item>
<item>
<title>Docker下实战zabbix三部曲之一：极速体验 - zq2599</title>
<link>http://www.cnblogs.com/bolingcavalry/p/11587980.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bolingcavalry/p/11587980.html</guid>
<description>&lt;p&gt;对于想学习和实践zabbix的读者来说，在真实环境搭建一套zabbix系统是件费时费力的事情，本文内容就是用docker来缩减搭建时间，目标是让读者们尽快投入zabbix系统的体验和实践；&lt;/p&gt;
&lt;h3 id=&quot;环境信息&quot;&gt;环境信息&lt;/h3&gt;
&lt;p&gt;以下是本次操作的环境：&lt;/p&gt;
&lt;ol readability=&quot;-0.83809523809524&quot;&gt;&lt;li&gt;操作系统：MacBook Pro&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Docker：19.03.2&lt;/p&gt;
&lt;h3 id=&quot;全系列文章链接&quot;&gt;全系列文章链接：&lt;/h3&gt;
三部曲系列一共三篇文章，链接如下：&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/76857936&quot;&gt;《Docker下实战zabbix三部曲之一：极速体验》&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/77095153&quot;&gt;《Docker下实战zabbix三部曲之二：监控其他机器》&lt;/a&gt;；&lt;/li&gt;
&lt;li readability=&quot;-0.045454545454545&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/77410178&quot;&gt;《Docker下实战zabbix三部曲之三：自定义监控项》&lt;/a&gt;；&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;创建docker-compose.yml文件&quot;&gt;创建docker-compose.yml文件&lt;/h3&gt;
&lt;p&gt;首先创建一份docker-compose.yml文件，内容如下：&lt;/p&gt;
&lt;pre class=&quot;yml&quot;&gt;
&lt;code&gt;version: '2'
services:
  zabbix-mysql: 
    image: daocloud.io/library/mysql:8
    container_name: zabbix-mysql
    environment:
      - MYSQL_ROOT_PASSWORD=888888
    restart: always
  zabbix-server:
    image: monitoringartist/zabbix-xxl
    links: 
      - zabbix-mysql:mysqlhost
    container_name: zabbix-server
    restart: always
    depends_on:
      - zabbix-mysql
    ports:
      - &quot;8888:80&quot;
    environment:
      - ZS_DBHost=mysqlhost
      - ZS_DBUser=root
      - ZS_DBPassword=888888&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;创建容器&quot;&gt;创建容器&lt;/h3&gt;
&lt;p&gt;打开命令行，在刚才创建的docker-compose.yml目录下，执行&lt;span&gt;docker-compose up -d&lt;/span&gt;，这样就会先后启动mysql和zabbix server两个服务的容器，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/485422/201909/485422-20190925220752384-7653659.jpg&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;等待zabbix-server初始化&quot;&gt;等待zabbix server初始化&lt;/h3&gt;
&lt;p&gt;在命令行输入命令&lt;span&gt;docker logs -f zabbix-server-service&lt;/span&gt;，查看zabbix server的日志输出，下图是部分日志的截图，可以看到有数据库初始化的操作：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/485422/201909/485422-20190925220754521-1020088632.jpg&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;登录zabbix管理页面体验&quot;&gt;登录zabbix管理页面体验&lt;/h3&gt;
&lt;p&gt;等待大约一分钟之后，zabbix server的日志不再滚动，表示初始化已经完成，打开浏览器输入http://localhost:8888，可以看到zabbix的管理系统的登录页面，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/485422/201909/485422-20190925220755377-622436654.jpg&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输入用户名&lt;span&gt;admin&lt;/span&gt;，密码&lt;span&gt;zabbix&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;登录后即可看到管理系统了，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/485422/201909/485422-20190925220759060-553179872.jpg&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;按照下图的操作，查看已经监控的主机情况，如图，目前只能看到一台机器的信息，就是zabbix server自己这台机器，从列表的几列信息中可以看到有64个监控项，43个触发器，10个图形：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/485422/201909/485422-20190925220803258-1101521909.jpg&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图右侧的红框中显示的status是&quot;Disabled&quot;，表示这个host的监控还没有启动，点击这个&quot;Disabled&quot;就能启动监控，将状态变为&quot;Enabled&quot;，大约1分钟后再刷新页面，可以看到展示如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/485422/201909/485422-20190925220804795-1498928709.jpg&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;除了状态变为&quot;Enabled&quot;,右侧原本灰色的&quot;ZBX&quot;也变成了绿色，表示该机器的监控状态是正常的；&lt;/p&gt;
&lt;h3 id=&quot;体验监控图形&quot;&gt;体验监控图形&lt;/h3&gt;
&lt;p&gt;按照下图的红框和箭头操作，可以看到zabbix server所在机器的cpu load的曲线图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/485422/201909/485422-20190925220809605-464163537.jpg&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;显示中文&quot;&gt;显示中文&lt;/h3&gt;
&lt;p&gt;按照下图的箭头依次点击红框中的内容：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/485422/201909/485422-20190925220812524-531762854.jpg&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在打开后的页面中按照下图的箭头依次选择和点击：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/485422/201909/485422-20190925220814343-623219366.jpg&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这时候再点击右上角的&quot;注销&quot;按钮，退出重现登录，如下图红框所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/485422/201909/485422-20190925220816288-964449429.jpg&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再重新登录后，就能看见页面已经全部中文显示了，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/485422/201909/485422-20190925220819188-1787445569.jpg&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以上就是Docker下实战zabbix的第一部分，快速体验zabbix系统和服务，但只有一个zabbix server服务器意义不大，毕竟实际场景是要通过zabbix系统去监控其他机器和服务，下一章我们尝试把zabbix agent加入进来，以更接近实际场景的方式来继续学习zabbix。&lt;/p&gt;
&lt;h3 id=&quot;欢迎关注我的公众号程序员欣宸&quot;&gt;欢迎关注我的公众号：程序员欣宸&lt;/h3&gt;
</description>
<pubDate>Wed, 25 Sep 2019 14:08:00 +0000</pubDate>
<dc:creator>zq2599</dc:creator>
<og:description>对于想学习和实践zabbix的读者来说，在真实环境搭建一套zabbix系统是件费时费力的事情，本文内容就是用docker来缩减搭建时间，目标是让读者们尽快投入zabbix系统的体验和实践； 环境信息</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bolingcavalry/p/11587980.html</dc:identifier>
</item>
<item>
<title>前端初探 Gitlab CI/CD - 渴望做梦</title>
<link>http://www.cnblogs.com/kwzm/p/11587845.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kwzm/p/11587845.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;纵观人类历史的发展以及三次工业革命，你会发现利用机器来替代部分人力劳动，将重复的工作自动化从而解放生产力都是发展的必然趋势，在软件工程领域也不例外，其中 CI/CD 就是其中一项，那么什么是 CI/CD 呢，网上的解释不要太多，这里我就直接放一幅 Gitlab 官网的工作流程图好了：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/9/25/16d66a2af2890c40?w=3420&amp;amp;h=1894&amp;amp;f=png&amp;amp;s=70061&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;准备条件&quot;&gt;准备条件&lt;/h2&gt;
&lt;ol readability=&quot;-1.7977528089888&quot;&gt;&lt;li&gt;&lt;a href=&quot;https://docs.gitlab.com/ee/ci/runners/README.html&quot;&gt;Gitlab runner&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.gitlab.com/ee/ci/yaml/README.html&quot;&gt;.gitlab-ci.yml&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;gitlab-runner&quot;&gt;Gitlab runner&lt;/h2&gt;
Gitlab runner 是整个 CI/CD 的执行器，它是执行你写的 .gitlab-ci.yml 文件的虚拟机。&lt;br/&gt;Gitlab runner 分为两种：&lt;/li&gt;
&lt;li&gt;特定的 runner：只能当前项目使用&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;共享的 runner：所有项目都可以使用&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;找到你的项目在 &lt;strong&gt;设置&lt;/strong&gt;&amp;gt;&lt;strong&gt;Runners&lt;/strong&gt; 里&lt;br/&gt;你可以看到如下界面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/9/25/16d6708355b4c2f1?w=1308&amp;amp;h=467&amp;amp;f=png&amp;amp;s=52910&quot;/&gt;&lt;br/&gt;左侧就是特定的 runners 右侧就是共享的 runners，只要确保有其一就行。&lt;br/&gt;关于 runner 的安装我不想过多赘述，官网写的很清楚，只要按照步骤一步一步搭建就好了。&lt;/p&gt;
&lt;h2 id=&quot;gitlab-ci.yml&quot;&gt;.gitlab-ci.yml&lt;/h2&gt;
&lt;p&gt;当你有了 runner 就可以开始着手写 .gitlab-ci.yml 文件了，.gitlab-ci.yml 文件是对于整个 CI/CD 流程的描述文件，它告诉 runner 应该怎样执行具体的操作。&lt;br/&gt;在具体介绍配置之前，我想先明确整个 .gitlab-ci.yml 里面的几个重要名词：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;job: job 是整个 CI/CD 的核心单元，它定义了在什么条件下应该执行什么任务，每个 job 都是相互隔离的。&lt;/li&gt;
&lt;li&gt;script: job 下的属性，用于描述 job 要执行的任务。&lt;/li&gt;
&lt;li&gt;stages: 定义 job 的分组，不同 job 可以所属于不同的阶段，一共有三个阶段可供选择：test build deploy，stage 的执行是按顺序的，但是 stage 下面的 job 是并行执行的，只有前一个 stage 执行成功才会执行下一个 stage，一旦上一个 stage 中任何一个 job 执行失败都会导致整个流水线失败。&lt;/li&gt;
&lt;li&gt;pipeline: 上面的整个流程就是一个流水线。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;下面是我的一个前端项目的 .gitlab-ci.yml 文件，以它来作为示例：&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;image: node:10.13
      
stages:
  - test
  - build
  - deploy
  
cache:
  paths:
    - node_modules/
    
before_script:
  ## set proxy
  - export http_proxy=http://10.2.3.63:3128/
  - export https_proxy=http://10.2.3.63:3128/

test:
  stage: test
  tags:
    - sams
  script:
    - npm install --no-optional --registry=https://registry.npm.taobao.org
    - npm run lint
  only:
    - master
    - dev

build:
  stage: build
  tags: 
    - sams
  script:
    - npm run build
  artifacts:
    paths:
      - $SOURCE_DIR
    expire_in: 2 mins
  only:
    - master

deploy:
  stage: deploy
  tags: 
    - sams
  before_script:
    ## set debian mirros
    - echo 'deb http://mirrors.aliyun.com/debian/ stretch main non-free contrib' &amp;gt; /etc/apt/sources.list
    - echo 'deb-src http://mirrors.aliyun.com/debian/ stretch main non-free contrib' &amp;gt;&amp;gt; /etc/apt/sources.list
    - echo 'deb http://mirrors.aliyun.com/debian-security stretch/updates main' &amp;gt;&amp;gt; /etc/apt/sources.list
    - echo 'deb-src http://mirrors.aliyun.com/debian-security stretch/updates main' &amp;gt;&amp;gt; /etc/apt/sources.list
    - echo 'deb http://mirrors.aliyun.com/debian/ stretch-updates main non-free contrib' &amp;gt;&amp;gt; /etc/apt/sources.list
    - echo 'deb-src http://mirrors.aliyun.com/debian/ stretch-updates main non-free contrib' &amp;gt;&amp;gt; /etc/apt/sources.list
    - echo 'deb http://mirrors.aliyun.com/debian/ stretch-backports main non-free contrib' &amp;gt;&amp;gt; /etc/apt/sources.list
    - echo 'deb-src http://mirrors.aliyun.com/debian/ stretch-backports main non-free contrib' &amp;gt;&amp;gt; /etc/apt/sources.list
    ## Using SSH keys with GitLab CI/CD
    ## https://docs.gitlab.com/ee/ci/ssh_keys/README.html
    - 'which ssh-agent || ( apt-get update -y &amp;amp;&amp;amp; apt-get install openssh-client -y )'
    - eval $(ssh-agent -s)
    - echo &quot;$SSH_PRIVATE_KEY&quot; | tr -d '\r' | ssh-add -
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - echo &quot;$SSH_KNOWN_HOSTS&quot; &amp;gt; ~/.ssh/known_hosts
    - chmod 644 ~/.ssh/known_hosts
  script:
    - scp -r $SOURCE_DIR $DEPLOY_SERVER_USER@$DEPLOY_SERVER_IP:$TARGET_DIR
  only:
    - master
  environment: test&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;全局配置&quot;&gt;全局配置&lt;/h3&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li&gt;image: 要使用的 docker 镜像它会根据你写的镜像名从 &lt;a href=&quot;https://hub.docker.com/&quot;&gt;docker hub&lt;/a&gt; 上面拉取镜像，因为我们的项目是前端项目，所以这里配置的镜像是 node，最终你的 script 指定的脚本会跑在 node 的 docker 环境下，这样就保证你有了必要的环境依赖（node）&lt;/li&gt;
&lt;li&gt;stages: 定义整个流水线的各个阶段，这里我三个阶段都定义了，但是你可以根据你自己项目的实际情况定义，定义好后流水线将按照你定义的顺序依次执行。&lt;/li&gt;
&lt;li&gt;cache: 定义 job 之间要缓存的文件，通常我们都会把项目的安装依赖作为缓存，这样下一个 job 就不用重新安装依赖了&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;before_script: 定义所有 job script 执行前需要执行的脚本，这里我设置了代理。&lt;/p&gt;
&lt;h3 id=&quot;job-的配置&quot;&gt;job 的配置&lt;/h3&gt;
&lt;/li&gt;
&lt;li&gt;stage: 定义该 job 所属的 stage&lt;/li&gt;
&lt;li&gt;tags: 指定该 job 使用的 runner&lt;/li&gt;
&lt;li&gt;script: 该 job 需要执行的脚本&lt;/li&gt;
&lt;li&gt;only: 该 job 的约束条件，你可以指定该 job 在哪些情况下会触发，比如只有 master 分支和 develop 分支才会执行 deploy 的 job，与此相对的还有一个 except 属性表示什么条件下不执行该 job&lt;/li&gt;
&lt;li&gt;artifacts: 用于在不同 stage 之间传递结果，通用的做法是将 build 阶段打包出来的文件定义为 artifacts，这样在 deploy 阶段就可以直接使用了，这里你可能会对 artifacts 和 cache 有些搞不清，这里推荐看官方的&lt;a href=&quot;https://docs.gitlab.com/ee/ci/caching/#cache-vs-artifacts&quot;&gt;说明&lt;/a&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;environment: 用于定义 job 部署的环境，这里需要结合 Gitlab 项目的 UI 界面，比如这里我设置的名称叫 test，每次部署成功之后 test 环境下就会多一个部署条目，你可以重新部署甚至回滚到某个部署，如下图所示：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/9/25/16d66e200a793224?w=1309&amp;amp;h=516&amp;amp;f=png&amp;amp;s=58035&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;另外 environment 下还有一个 url 属性可以定义部署到的服务器地址，这样你可以在 UI 界面通过点击按钮直接跳转到项目，如果你的 Gitlab 低于 8.11 那只能通过在 UI 界面（上图）手动配置了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;ssh-keys-实现免密登录&quot;&gt;ssh keys 实现免密登录&lt;/h3&gt;
&lt;p&gt;一般来讲你部署项目的时候不可避免会用到 ssh 协议，但是 ssh 协议需要你手动输入用户名和密码，这样不就无法实现自动化部署了？ 别急，Gitlab 已经帮我们想到了这一点，仔细阅读官网上的 &lt;a href=&quot;https://docs.gitlab.com/ee/ci/ssh_keys/README.html#using-ssh-keys-with-gitlab-cicd&quot;&gt;Using SSH keys with GitLab CI/CD&lt;/a&gt; 这篇文章你就能找到解决方案，或者参考我的实例代码：&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;## Using SSH keys with GitLab CI/CD
## https://docs.gitlab.com/ee/ci/ssh_keys/README.html
- 'which ssh-agent || ( apt-get update -y &amp;amp;&amp;amp; apt-get install openssh-client -y )'
- eval $(ssh-agent -s)
- echo &quot;$SSH_PRIVATE_KEY&quot; | tr -d '\r' | ssh-add -
- mkdir -p ~/.ssh
- chmod 700 ~/.ssh
- echo &quot;$SSH_KNOWN_HOSTS&quot; &amp;gt; ~/.ssh/known_hosts
- chmod 644 ~/.ssh/known_hosts&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我还是要简单说一下其实现原理，Gitlab 首先让你生成一对 ssh 的公钥和私钥，在每次执行 CI/CD 时将私钥（此时已添加到环境变量里）通过 ssh-add 添加到 ssh-agent 里面进行管理，并将设置好的 $SSH_KNOWN_HOSTS (里面就包含了你要 shh 的主机) 也添加到 known_hosts 文件中，这样在执行 ssh 命令时远程机器就能识别你的身份从而实现免密登录，本质上和你本地实现免密登录的道理是一样的。&lt;/p&gt;
&lt;h2 id=&quot;其它&quot;&gt;其它&lt;/h2&gt;
&lt;h3 id=&quot;环境变量&quot;&gt;环境变量&lt;/h3&gt;
&lt;p&gt;类似于编程中的变量，环境变量可以存储一些要要变化的或是比较私密的信息，环境变量配置好后可以通过 &lt;strong&gt;$ + 变量名&lt;/strong&gt; 在 script 里面进行调用&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/9/25/16d66f4c0044aa11?w=1308&amp;amp;h=457&amp;amp;f=png&amp;amp;s=43890&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;查看流水线状态&quot;&gt;查看流水线状态&lt;/h3&gt;
&lt;p&gt;在 Gitlab 主页找到流水线页签，打开之后就能看到所有流水线的运行情况&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/9/25/16d66f72c5a05bb2?w=1329&amp;amp;h=438&amp;amp;f=png&amp;amp;s=53552&quot;/&gt;&lt;br/&gt;点击进入具体的 stage 你可以看到其执行细节，如果失败也可以重新执行&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/9/25/16d66f8ee9d09638?w=1351&amp;amp;h=521&amp;amp;f=png&amp;amp;s=62355&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
&lt;p&gt;https://docs.gitlab.com/ee/ci/README.html&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;这次也是我初次尝试使用 Gitlab CI/CD ，每次任务大概执行需要 8 分钟，如果你像之前手动去做这些工作那你每次都至少需要花费 8 分钟时间，不要小瞧这 8 分钟，日积月累也是一笔不小的开支，更重要的是机器很少出错的，但是人的话就没法保证了，而且就像我在开篇所说简单重复性的工作必然会被机器取代，这是不可避免的历史规律，不管你用不用它，技术的潮流都会不断向前推动，所以还不如提前拥抱它。&lt;br/&gt;另外此次只介绍了整个 Gitlab CI/CD 功能的冰山一角，Gitlab 还提供很多优秀的功能，比如在 merge request 的时候进行 CI/CD，所以更多的功能还有待挖掘，如果你感兴趣可以去官方文档上找寻，如果有什么不对的地方还请您指正，最后感谢您的阅读！&lt;/p&gt;
</description>
<pubDate>Wed, 25 Sep 2019 13:52:00 +0000</pubDate>
<dc:creator>渴望做梦</dc:creator>
<og:description>前言 纵观人类历史的发展以及三次工业革命，你会发现利用机器来替代部分人力劳动，将重复的工作自动化从而解放生产力都是发展的必然趋势，在软件工程领域也不例外，其中 CI/CD 就是其中一项，那么什么是 C</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kwzm/p/11587845.html</dc:identifier>
</item>
</channel>
</rss>