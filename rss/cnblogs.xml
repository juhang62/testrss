<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>网络爬虫之使用pyppeteer替代selenium完美绕过webdriver检测 - 奥辰</title>
<link>http://www.cnblogs.com/chenhuabin/p/10989895.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenhuabin/p/10989895.html</guid>
<description>&lt;p&gt;曾经使用模拟浏览器操作（selenium + webdriver）来写爬虫，但是稍微有点反爬的网站都会对selenium和webdriver进行识别，网站只需要在前端js添加一下判断脚本，很容易就可以判断出是真人访问还是webdriver。虽然也可以通过中间代理的方式进行js注入屏蔽webdriver检测，但是webdriver对浏览器的模拟操作（输入、点击等等）都会留下webdriver的标记，同样会被识别出来，要绕过这种检测，只有重新编译webdriver，麻烦自不必说，难度不是一般大。&lt;/p&gt;
&lt;p&gt;作为selenium+webdriver的优秀替代，pyppeteer就是一个很好的选择。&lt;/p&gt;

&lt;p&gt;通过pip使用豆瓣源加速安装pyppeteer：&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
pip install -i https://pypi.douban.com/simple pypeteer
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;按照官方手册，先来感受一下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; asyncio
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; pyppeteer &lt;span&gt;import&lt;/span&gt;&lt;span&gt; launch
 
async &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; main():
browser &lt;/span&gt;= await launch(headless=&lt;span&gt;False)
page &lt;/span&gt;=&lt;span&gt; await browser.newPage()
await page.goto(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://www.baidu.com/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
await asyncio.sleep(&lt;/span&gt;100&lt;span&gt;)
await browser.close()
 
asyncio.get_event_loop().run_until_complete(main())&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;pyppeteer第一次运行时，会自动下载chromium浏览器，时间可能会有些长。不过，我第一次运行时，直接报错：&lt;/p&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
ssl.SSLCertVerificationError: [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed: unable to get local issuer certificate (_ssl.c:1056)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;尝试多种方法无果，无奈只能手动下载，但手动下载的方法网上资料也几乎没有，让我来做这个先行者吧。&lt;/p&gt;
&lt;p&gt;上面代码运行虽然报错，但是控制台前两行却提供了很有用的信息：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[W:pyppeteer.chromium_downloader] start chromium download.
Download may take a few minutes.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到，下载功能是由pyppeteer.chromium_downloader模块完成的，那么我们进入这个模块查看源码。&lt;/p&gt;
&lt;div readability=&quot;13.5&quot;&gt;
&lt;p&gt;在这个模块源码中，我们可以看到downloadURLs、chromiumExecutable等变量，很明显指的就是下载链接和chromium的可执行文件路径。我们重点关注一下可执行文件路径&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;chromiumExecutable：
chromiumExecutable &lt;/span&gt;=&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;linux&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: DOWNLOADS_FOLDER / REVISION / &lt;span&gt;'&lt;/span&gt;&lt;span&gt;chrome-linux&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; / &lt;span&gt;'&lt;/span&gt;&lt;span&gt;chrome&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;mac&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: (DOWNLOADS_FOLDER / REVISION / &lt;span&gt;'&lt;/span&gt;&lt;span&gt;chrome-mac&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; / &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Chromium.app&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; /
&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Contents&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; / &lt;span&gt;'&lt;/span&gt;&lt;span&gt;MacOS&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; / &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Chromium&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;win32&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: DOWNLOADS_FOLDER / REVISION / &lt;span&gt;'&lt;/span&gt;&lt;span&gt;chrome-win32&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; / &lt;span&gt;'&lt;/span&gt;&lt;span&gt;chrome.exe&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;win64&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: DOWNLOADS_FOLDER / REVISION / &lt;span&gt;'&lt;/span&gt;&lt;span&gt;chrome-win32&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; / &lt;span&gt;'&lt;/span&gt;&lt;span&gt;chrome.exe&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;可见，无论在哪个平台下，chromiumExecutable都是由是4个部分组成，其中 DOWNLOADS_FOLDER 和 REVISION是定义好的变量：&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
DOWNLOADS_FOLDER = Path(&lt;span&gt;__pyppeteer_home__&lt;/span&gt;) / &lt;span&gt;'&lt;/span&gt;&lt;span&gt;local-chromium&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;进一步查看可以发现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;__pyppeteer_home__&lt;/span&gt; = os.environ.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;PYPPETEER_HOME&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, AppDirs(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;pyppeteer&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).user_data_dir)
REVISION &lt;/span&gt;= os.environ.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;PYPPETEER_CHROMIUM_REVISION&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;__chromium_revision__&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所以，DOWNLOADS_FOLDER 和 REVISION都是读取对应环境变量设置好的值，如果没有设置，就使用默认值。我们来输出一下，看看默认值：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; pyppeteer.chromium_downloader
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;默认版本是：{}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.format(pyppeteer.&lt;span&gt;__chromium_revision__&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;可执行文件默认路径：{}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.format(pyppeteer.chromium_downloader.chromiumExecutable.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;win64&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;win64平台下载链接为：{}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.format(pyppeteer.chromium_downloader.downloadURLs.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;win64&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
默认版本是：575458
可执行文件默认路径：C:\Users\Administrator\AppData\Local\pyppeteer\pyppeteer\local-chromium\575458\chrome-win32\chrome.exe
win64平台下载链接为：https://storage.googleapis.com/chromium-browser-snapshots/Win_x64/575458/chrome-win32.zip
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span&gt;在使用上面代码的时候，你可以将win64换成你的平台就好了，有了上面的下载链接，这个时候就可以先开始下载着chromium浏览器（有些慢），然后继续往下看。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;对于版本，没什么好说的，是用默认的就好了。但是，对于chromium的可执行文件路径，默认是在C盘，对于有C盘洁癖的我，咋看咋不舒服，那就改了吧。从上面的分析中我们可以知道，C:\Users\Administrator\AppData\Local\pyppeteer\pyppeteer这一部分读取的是环境变量或者默认值，所以，我们可以通过配置环境变量改这一部分（或者也可以直接改源码，读取环境变量那一行，直接设为固定值），通过os.environ添加PYPPETEER_HOME这一变量值，例如我想把我的chromium放在D盘的Program Files文件夹下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; os
os.environ[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;PYPPETEER_HOME&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;D:\Program Files&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; pyppeteer.chromium_downloader
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;默认版本是：{}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.format(pyppeteer.&lt;span&gt;__chromium_revision__&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;可执行文件默认路径：{}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.format(pyppeteer.chromium_downloader.chromiumExecutable.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;win64&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;win64平台下载链接为：{}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.format(pyppeteer.chromium_downloader.downloadURLs.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;win64&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
默认版本是：575458
可执行文件默认路径：D:\Program Files\local-chromium\575458\chrome-win32\chrome.exe
win64平台下载链接为：https://storage.googleapis.com/chromium-browser-snapshots/Win_x64/575458/chrome-win32.zip
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;strong&gt;特别提醒：上面设置环境变量的那一行，必须在导入pyppeteer这一行千米，否则设置无效。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上面这种方法你需要在每次使用pypeeteer之前通过这行代码设置一下，实在麻烦，所以，我还是更愿意直接在windows系统里面添加这个变量：&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1539768/201906/1539768-20190608081341224-1765866752.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;虽然我们把环境变量设置为D:\Program Files，但是层层文件夹之后，才到真正的可执行文件chrome.exe，下载好的压缩包解压后，所有文件都在名为chrome-win的文件夹中，所以，我们需要在D:\Program Files创建local-chromium\575458这两个文件夹（575458是上面的版本号，记得修改为你的版本号），然后将解压得到的chrome-win文件夹，重命名为chrome-win32，然后直接拷贝进去就好，整个安装过程就完成了。&lt;/p&gt;
&lt;p&gt;再来试试最初（最上面）的代码，你会看到，已经可以成功运行。&lt;/p&gt;
&lt;p&gt;我相信，大多数阅读这篇博文的读者都是用pyppeteer来开发爬虫（别说维护世界和平，我不信)，那么接下来，重点来说说爬虫中要用到的一些主要操作。&lt;/p&gt;

&lt;h2&gt;3.1 打开浏览器&lt;/h2&gt;
&lt;p&gt;打开浏览器是通过pyppeteer.launcher.launch(options: dict = None, **kwargs) 方法，运行该函数后，会得到一个pyppeteer.browser.Browser实例，也就是说浏览器对象实例。launch方法是必须使用的方法，所以，详细学学它的参数，你也直接阅读&lt;a href=&quot;https://miyakogi.github.io/pyppeteer/reference.html#launcher&quot; target=&quot;_blank&quot;&gt;官方文档&lt;/a&gt;，因为我也是直接翻译的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;ignoreHTTPSErrors (bool): 是否HTTPS错误，某人情况下为False.&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;headless (bool): 是否以无头模式（无界面模式）执行，默认为True，为True时是不会弹出可视界面的，所以，上面代码运行时设置headless=False。注意，下面还有个devtools参数，表示是否出现打开调试窗口，如果devtools设置为True，headless就算设置为False也会弹出可视界面。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;executablePath (str): Chromium或Chrome浏览器的可执行文件路径，如果设置，则使用设置的这个路径，不使用默认设置.&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;slowMo (int|float): 设置这个参数可以延迟pyppeteer的操作，单位是毫秒.&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;args (List[str]): 要传递给浏览器进程的一些其他参数.&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;ignoreDefaultArgs (bool): 如果有些参数你不想使用默认值，那么，通过这个参数设置，不过，孩子，最好别用，有危险（电脑会爆炸）.&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;handleSIGINT (bool): &lt;span&gt;是否响应 SIGINT 信号，&lt;span&gt;是否允许通过快捷键Ctrl+C来终止浏览器进程，默认值为True，也就是允许.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;handleSIGTERM (bool): &lt;span&gt;是否响应 SIGTERM 信号，也就是说kill命令关闭浏览器，&lt;span&gt;，默认值为True，也就是允许.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;handleSIGHUP (bool): &lt;span&gt;是否响应 SIGHUP 信号，即挂起信号&lt;span&gt;，默认值为True，也就是允许.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;dumpio (bool): 是要将浏览器进程的输出传递给&lt;span&gt;process.stdout 和 process.stderr 对象，默认为False不传递。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;userDataDir (str): 用户数据文件目录.&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;env (dict): 以字典的形式传递给浏览器环境变量.&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;devtools (bool): 是否打开调试窗口，上面介绍headless参数是说过，默认值为False不打开.&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;logLevel (int|str): 日志级别，&lt;span&gt;默认和 root logger 对象的级别相同&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;autoClose (bool): 当所有操作都执行完后，是否自动关闭浏览器，默认True，自动关闭.&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;loop (asyncio.AbstractEventLoop): 时间循环。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;appMode (bool): Deprecated.&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;打开浏览器操作简单，看参数就行，不多介绍。&lt;/p&gt;

&lt;p&gt;如果你运行了上面的代码，你会发现，打开的页面只在窗口左上角一小块显示，看着很别扭，这是因为pyppeteer默认窗口大小是800*600，所以，调整一下吧。调整窗口大小通过方法实现，看下面代码，最大化窗口：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; asyncio
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; pyppeteer &lt;span&gt;import&lt;/span&gt;&lt;span&gt; launch
 
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; screen_size():
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;使用tkinter获取屏幕大小&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;import&lt;/span&gt;&lt;span&gt; tkinter
    tk &lt;/span&gt;=&lt;span&gt; tkinter.Tk()
    width &lt;/span&gt;=&lt;span&gt; tk.winfo_screenwidth()
    height &lt;/span&gt;=&lt;span&gt; tk.winfo_screenheight()
    tk.quit()
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; width, height
 
async &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; main():
    browser &lt;/span&gt;= await launch(headless=&lt;span&gt;False)
    page &lt;/span&gt;=&lt;span&gt; await browser.newPage()
    width, height &lt;/span&gt;=&lt;span&gt; screen_size()
    await page.setViewport({ &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 最大化窗口&lt;/span&gt;
        &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;width&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: width,
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;height&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: height
    })
await page.goto(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://www.baidu.com/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
await asyncio.sleep(&lt;/span&gt;100&lt;span&gt;)
await browser.close()
 
asyncio.get_event_loop().run_until_complete(main())    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3.3 设置userAgent&lt;/h2&gt;
&lt;p&gt;常规操作，不多说，上代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; asyncio
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; pyppeteer &lt;span&gt;import&lt;/span&gt;&lt;span&gt; launch
 
async &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; main():
browser &lt;/span&gt;= await launch(headless=&lt;span&gt;False)
page &lt;/span&gt;=&lt;span&gt; await browser.newPage()
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置请求头userAgent&lt;/span&gt;
await page.setUserAgent(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.169 Mobile Safari/537.36&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
await page.goto(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://www.baidu.com/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
await asyncio.sleep(&lt;/span&gt;100&lt;span&gt;)
await browser.close()
 
asyncio.get_event_loop().run_until_complete(main())&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3.4 执行js脚本&lt;/h2&gt;
&lt;p&gt;有时候，为了达成某些目的（例如屏蔽网站原有js），我们不可避免得需要执行一些js脚本。执行js脚本通过evaluate方法。如下所示，我们通过js来修改window.navigator.webdriver属性的值，由此绕过网站对webdriver的检测：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; asyncio
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; pyppeteer &lt;span&gt;import&lt;/span&gt;&lt;span&gt; launch
 
async &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; main():
js1 &lt;/span&gt;= &lt;span&gt;'''&lt;/span&gt;&lt;span&gt;() =&amp;gt;{
 
    Object.defineProperties(navigator,{
    webdriver:{
        get: () =&amp;gt; false
        }
    })
}&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
 
js2 &lt;/span&gt;= &lt;span&gt;'''&lt;/span&gt;&lt;span&gt;() =&amp;gt; {
    alert (
        window.navigator.webdriver
    )
}&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
browser &lt;/span&gt;= await launch({&lt;span&gt;'&lt;/span&gt;&lt;span&gt;headless&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:False, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;args&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;--no-sandbox&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;],})
 
page &lt;/span&gt;=&lt;span&gt; await browser.newPage()
await page.goto(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://h5.ele.me/login/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
await page.evaluate(js1)
await page.evaluate(js2)
 
asyncio.get_event_loop().run_until_complete(main())&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在上面代码中，通过page.evalute方法执行了两段js脚本，第一段脚本将webdriver的属性值设为false，第二段代码在此读取 webdriver属性值，输出为false。&lt;/p&gt;
&lt;h2&gt;3.5 模拟操作&lt;/h2&gt;
&lt;p&gt;pyppeteer提供了Keyboard和Mouse两个类来实现模拟操作，前者是用来实现键盘模拟，后者实现鼠标模拟（还有其他触屏之类的就不说了）。&lt;/p&gt;
&lt;p&gt;主要来说说输入和点击：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; os
os.environ[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;PYPPETEER_HOME&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;D:\Program Files&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; asyncio
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; pyppeteer &lt;span&gt;import&lt;/span&gt;&lt;span&gt; launch
 
async &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; main():
browser &lt;/span&gt;= await launch(headless=False, args=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;--disable-infobars&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
page &lt;/span&gt;=&lt;span&gt; await browser.newPage()
await page.goto(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://h5.ele.me/login/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
await page.type(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;form section input&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;12345678999&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 模拟键盘输入手机号&lt;/span&gt;
await page.click(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;form section button&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 模拟鼠标点击获取验证码&lt;/span&gt;
await asyncio.sleep(200&lt;span&gt;)
await browser.close()
 
asyncio.get_event_loop().run_until_complete(main())&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的模拟操作中，无论是模拟键盘输入还是鼠标点击定位都是通过css选择器，似乎pyppeteer的type和click直接模拟操作定位都只能通过css选择器（或者是我在官方文档中没找到方法），当然，要间接通过xpath先定位，然后再模拟操作也是可以的。下一小节中模拟登陆外卖平台就是用这种方法，不过，这种方法要麻烦一些，不推荐。&lt;/p&gt;
&lt;h2&gt; 3.6 某电商平台模拟登陆&lt;/h2&gt;
&lt;p&gt;我曾经用selenium + chrome 实现了模拟登陆这个电商平台，但是实在是有些麻烦，绕过对webdriver的检测不难，但是，通过webdriver对浏览器的每一步操作都会留下特殊的痕迹，会被平台识别，这个必须通过重新编译chrome的webdriver才能实现，麻烦得让人想哭。不说了，都是泪，下面直接上用pyppeteer实现的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; os
os.environ[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;PYPPETEER_HOME&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;D:\Program Files&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; asyncio
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; pyppeteer &lt;span&gt;import&lt;/span&gt;&lt;span&gt; launch
 
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; screen_size():
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;使用tkinter获取屏幕大小&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;import&lt;/span&gt;&lt;span&gt; tkinter
    tk &lt;/span&gt;=&lt;span&gt; tkinter.Tk()
    width &lt;/span&gt;=&lt;span&gt; tk.winfo_screenwidth()
    height &lt;/span&gt;=&lt;span&gt; tk.winfo_screenheight()
    tk.quit()
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; width, height
 
 
async &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; main():
    js1 &lt;/span&gt;= &lt;span&gt;'''&lt;/span&gt;&lt;span&gt;() =&amp;gt;{
 
        Object.defineProperties(navigator,{
        webdriver:{
            get: () =&amp;gt; false
            }
        })
    }&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
 
    js2 &lt;/span&gt;= &lt;span&gt;'''&lt;/span&gt;&lt;span&gt;() =&amp;gt; {
        alert (
            window.navigator.webdriver
        )
    }&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
    browser &lt;/span&gt;= await launch({&lt;span&gt;'&lt;/span&gt;&lt;span&gt;headless&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:False, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;args&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;--no-sandbox&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;],})
 
    page &lt;/span&gt;=&lt;span&gt; await browser.newPage()
    width, height &lt;/span&gt;=&lt;span&gt; screen_size()
    await page.setViewport({ &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 最大化窗口&lt;/span&gt;
        &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;width&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: width,
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;height&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: height
    })
    await page.goto(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://h5.ele.me/login/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    await page.evaluate(js1)
    await page.evaluate(js2)
    input_sjh &lt;/span&gt;= await page.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//form/section[1]/input[1]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    click_yzm &lt;/span&gt;= await page.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//form/section[1]/button[1]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    input_yzm &lt;/span&gt;= await page.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//form/section[2]/input[1]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    but &lt;/span&gt;= await page.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//form/section[2]/input[1]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(input_sjh)
    await input_sjh[0].type(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;*****手机号********&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    await click_yzm[0].click()
    ya &lt;/span&gt;= input(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;请输入验证码：&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    await input_yzm[0].type(str(ya))
    await but[0].click()
    await asyncio.sleep(&lt;/span&gt;3&lt;span&gt;)
    await page.goto(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://www.ele.me/home/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    await asyncio.sleep(&lt;/span&gt;100&lt;span&gt;)
    await browser.close()
 
asyncio.get_event_loop().run_until_complete(main())&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;登录时，由于等待时间过长（我猜的）导致出现以下错误：&lt;/p&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
pyppeteer.errors.NetworkError: Protocol Error (Runtime.callFunctionOn): Session closed. Most likely the page has been closed.
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;在github上找到了解决方法，似乎只能改源码，找到pyppeteer包下的connection.py模块，在其43行和44行改为下面这样：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
self._ws =&lt;span&gt; websockets.client.connect(
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; self._url, max_size=None, loop=self._loop)&lt;/span&gt;
self._url, max_size=None, loop=self._loop, ping_interval=None, ping_timeout=None)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再次运行就没问题了。可以成功绕过官方对webdriver的检测，登录成功，诸位可以自己尝试一下。&lt;/p&gt;

&lt;p&gt;当使用selenium+webdriver写爬虫被检测到时，pyppeteer是你得不二选择，几乎所有能在人工操作浏览器进行的操作通过pyppeteer都能实现，且能完美避开官方对webdriver的检测。pyppeteer涉及的使用方法还很多，本文只介绍了常用方法的很小很小一部分，需要一说的是，pyppeteer的中文资料真的很少，多看看&lt;a href=&quot;https://miyakogi.github.io/pyppeteer/reference.html&quot; target=&quot;_blank&quot;&gt;官方文档&lt;/a&gt;吧。&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;


</description>
<pubDate>Sat, 08 Jun 2019 00:25:00 +0000</pubDate>
<dc:creator>奥辰</dc:creator>
<og:description>当使用selenium+webdriver写爬虫被检测到时，pyppeteer是你得不二选择，几乎所有能在人工操作浏览器进行的操作通过pyppeteer都能实现，且能完美避开官方对webdriver的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chenhuabin/p/10989895.html</dc:identifier>
</item>
<item>
<title>工作三年心路历程 - 当代唐寅</title>
<link>http://www.cnblogs.com/mxlandxt/p/10989217.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mxlandxt/p/10989217.html</guid>
<description>&lt;h2 id=&quot;三年&quot;&gt;三年&lt;/h2&gt;
&lt;p&gt;三年前的端午节，那是我毕业上班第一天，一名初入职场的程序员小白，到今天已经整整工作三年了，从此也贴上了&lt;code&gt;工作三到五年的程序员&lt;/code&gt;标签（^_^），想总结些东西，毕竟三年对于一个程序员来说是一个里程碑，也是程序员之间拉开差距的分水岭。&lt;/p&gt;
&lt;h2 id=&quot;经历&quot;&gt;经历&lt;/h2&gt;
&lt;p&gt;现在上班的公司是我的第三家公司，也就是说我换过两次工作，两家公司风格迥异，第一家是个日活很低的电商，第二家是做NFC支付的。但无论是要死不活的电商，还是现在烂大街的第三方支付商家，这三年对我而言都意义非凡。&lt;/p&gt;
&lt;p&gt;先说说第一家要死不活的电商，之所以说它要死不活是因为这个公司全靠吹牛批骗投资，根本没有什么有价值的产品拿得出手。但是对于初入职场的我来说，这家公司反而带给了《职场三十六计》中最重要的一计——拍马屁，我也从打死不做舔狗的天真大学生变成了自己曾经最讨厌的那种人，意识到学不到啥干货，所以只待了一年就草草离职了。&lt;/p&gt;
&lt;p&gt;第二家公司是个创业型公司，加班是常态，比起上一家公司可以说是相当充实了。但是由于在上家公司只学会了拍马屁使得自己的专业技能和同事差距蛮大，专业技能不足使我很沮丧，像网络编程（当时是一片空白，压根没有这个概念），微服务（也是一片空白），甚至代码也被贴在群里当反面教材（真的是当着整个研发部批评，这让我非常非常的难过）。于是我开始疯狂提升自己的知识储备，开始习惯无偿加班，开始慢慢放弃自己的爱好（自己做的孽自己来还）。但其实还是感到蛮庆幸的，不然我可能到现在也不能认清自己，更不知道自己想要的是什么，也没有明确的职业规划，也不知道自己到底想要成为哪种人，价值观也很偏激，工作态度也就那样吊儿郎当（到现在看来我当时这些问题真的是条条致命），感觉就像现在的00后那样不成熟但很狂悖（就自己觉得自己很牛批的那样）。所以我感谢在第二家公司的那两年，也感恩周围同事对我的帮助。&lt;/p&gt;
&lt;p&gt;现在我在一家互联网公司带领着一个由5人实习生组成的团队，看着他们初入职场的拼劲再想想当年的自己真的很惭愧。我也经常和组员分享&lt;code&gt;工作态度&lt;/code&gt;，&lt;code&gt;责任感&lt;/code&gt;，我希望每个初入职场的人都能遇到那个能让你成长，能让你进步的人。&lt;/p&gt;
&lt;h2 id=&quot;我总结了一些&quot;&gt;我总结了一些&lt;/h2&gt;
&lt;h3 id=&quot;保持学习&quot;&gt;保持学习&lt;/h3&gt;
&lt;p&gt;不要只局限于工作上用的技术栈，这样一直待在舒适区会让自己的知识域变的非常的狭窄。建议每天花至少一小时学习，看书也好，逛论坛看微信公众号推文都可以，需要一直保持在这种状态。然后学习也要有方法，提升&lt;code&gt;学习效率&lt;/code&gt;，这很重要。之前看某个视频的时候有个老师讲过一句话我印象很深，他说&lt;code&gt;思想上的觉悟比埋头苦干要强的多&lt;/code&gt;。我很喜欢这句话。&lt;/p&gt;
&lt;h3 id=&quot;职业规划&quot;&gt;职业规划&lt;/h3&gt;
&lt;p&gt;一定要制定自己的职业规划。如果你不知道怎么制定自己的职业规划，也不知道以后到底想干嘛，你很迷茫，每天都是机械式的造轮子，不知道想要成为什么样的人。那你可以找你的leader，或者公司的架构，CTO好好聊聊，他们都是过来人，把你的疑惑告诉他们，他们会很乐意解答你的这些问题。&lt;/p&gt;
&lt;h3 id=&quot;多输出文档&quot;&gt;多输出文档&lt;/h3&gt;
&lt;p&gt;两年前我对写文档嗤之以鼻，程序员代码写好就行了，干嘛要写文档。后来我老大用强迫的方式让我写文档（现在想想自己还是很幸运的），再后来我得知原来写好文档就是每个优秀程序员必备技能，你的文档阅读对象是谁，时序图，拓扑图画的好不好，都决定一份文档能否起到作用。那如果写的文档大家都看不懂，看完之后还是得跑过了打断你写代码问问题，那这份文档和不写没啥区别。写文档好处真的太多了，写好一份文档可以考察你对当前系统的了解程度，如果你写的文档别人看了之后不需要再找你问问题，文档内容就能解决所有问题，那岂不是减少了很多沟通成本吗？所以我现在还是保持一个习惯，每接手一个工程我都会重新照着自己的思路输出一份文档，然后给组内成员review，如果大家对于这个系统的问题答案都在文档上可以找到，那这份文档可以说了相当成功了，如果后续这个工程需要交接给其他同事，这份文档可以说是雪中送炭了。&lt;/p&gt;
&lt;h3 id=&quot;沟通&quot;&gt;沟通&lt;/h3&gt;
&lt;p&gt;我再刚入职的时候经常会有这样的毛病，无论是和产品经理，还是和组内同事沟通总是抓不到重点，所以每次开会总是吵起来。大致过程如下，产品：这个需求可以做吗？我：这个需求需要A组同事提供一个接口，我通过这个接口拿到订单详情，然后.... 产品：这个需求可以做吗？ 我：？？？？ 然后就吵起来了，其实你只需要告诉产品可以做或者不可以做就行了，他问可不可以，你只需要告诉他可以or不可以就行了，这才是产品想要的答复，这才是这次谈话的重点。所以每当产品问可不可以？是不是？有没有？能不能做？的时候就直接回答是或否就ok了。抓住谈话的重点，沟通才会更加高效。&lt;/p&gt;
&lt;h3 id=&quot;关于加班&quot;&gt;关于加班&lt;/h3&gt;
&lt;p&gt;由于在第二家公司的加班时间已经超过1000+小时，时常凌晨2点到家，甚至通宵（我身体很健康，发量也很浓密，周六周末都会跑步，打篮球），所以现在我对加班已经没有感觉了，我总觉得九点才是我正常下班的时间，所以我对加班是可以接受的，我虽然不是996，但是每周工时也是60小时左右。&lt;/p&gt;
&lt;h3 id=&quot;责任心&quot;&gt;责任心&lt;/h3&gt;
&lt;p&gt;责任心，工作态度，是我招人最看重的两个点。我觉得每个优秀程序员都必须有&lt;code&gt;强大的责任心&lt;/code&gt;和非常&lt;code&gt;端正的工作态度&lt;/code&gt;，我不喜欢工作态度吊儿郎当，干活浮躁的人。哪怕你是技术大牛，你也应该有&lt;code&gt;程序员最基本的素养&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;专注&quot;&gt;专注&lt;/h3&gt;
&lt;p&gt;我身边就有很多喜欢跟风的朋友，今天golang很火，然后专攻golang，又过了一段时间看到大数据工资高就开始专攻大数据，然后几年过去了，啥都摸过，啥都不精通，典型的败絮其外金玉其中，然后还在简历上写着“全栈”。最后回到java，写的代码质量不高，年纪又不小了，还老抱怨自己工资低。之前就有个同事给我讲过一句话，他说&lt;code&gt;你不要想的太远，你只需要想好你往后的五年需要干什么，等到了五年后你再想下个五年你需要做什么，把握好眼前，沉下心来专注一件事情就够了&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;就说这么多吧，其实还有很多想说的，但是太累了（上周每天回家都是深夜），想好好睡一觉。&lt;/p&gt;
&lt;h2 id=&quot;最后祝大家端午节快乐好好学习天天向上&quot;&gt;最后祝大家端午节快乐，好好学习，天天向上。&lt;/h2&gt;
</description>
<pubDate>Fri, 07 Jun 2019 15:10:00 +0000</pubDate>
<dc:creator>当代唐寅</dc:creator>
<og:description>三年 三年前的端午节，那是我毕业上班第一天，一名初入职场的程序员小白，到今天已经整整工作三年了，从此也贴上了 标签（^_^），想总结些东西，毕竟三年对于一个程序员来说是一个里程碑，也是程序员之间拉开差</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mxlandxt/p/10989217.html</dc:identifier>
</item>
<item>
<title>做前端的你还没用这些软件？？ out 啦 - 爱看星星的稻草人</title>
<link>http://www.cnblogs.com/chase-star/p/10989495.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chase-star/p/10989495.html</guid>
<description>&lt;h2&gt;1、 编译器&lt;/h2&gt;
&lt;p&gt;写代码只是生产软件过程中的一环。无论是数据结构、编译原理、操作系统还是组成原理都是编码的重要基础，试问没有学过编译原理的人能够针对性地进行编译优化吗？不懂操作系统的人能玩得转linux吗？当然 nonono咯&lt;/p&gt;
&lt;p&gt;对于编译器来说这就好像一个木匠，只会使用斧子、锯子这些工具，是做不出好的家具一样。接来下我们谈谈前端开发的一些惊天利器。&lt;/p&gt;
&lt;p&gt;话说大家还在用那么古老的什么DW（全称：Adobe Dreamweaver CC，软件名这么长我都不想用.....）啦，其实小编我没用过....几款编译器（也就DW啦，HB啦，webstorm啦，VS code啦，sublime text啦，咳咳咳，这里有装逼嫌疑），&lt;/p&gt;
&lt;p&gt;但也只是在摸索阶段。&lt;/p&gt;
&lt;p&gt;从使用情况上来说对新手最友好的是&lt;span&gt;Hbuild&lt;/span&gt;，俗称写起代码来像飞一样的、并且是国产软件噢，友好程度不能再高了，代码的提示也是有的，而且非常适配vue进行开发。&lt;/p&gt;
&lt;p&gt;二阶段可以用用 &lt;span&gt;webstorm&lt;/span&gt; 虽然笨重了点。但是功能非常齐全，但是....可能需要花点钱或者花点精力（破解一下...小编建议有钱了还是买版权噢。毕竟咱们写的软件也肯定喊着要版权嘛，穷可以免费用用，有钱了还白嫖那也太恶心了点...）&lt;/p&gt;
&lt;p&gt;三阶段个人觉得应该使用这个神级软件 &lt;span&gt;VS code&lt;/span&gt;（微软大哥出品，必数精品），稍微安装点插件就OK。&lt;/p&gt;
&lt;p&gt;四阶段你完全可以走小清新大佬风，&lt;span&gt;sublime text&lt;/span&gt;，这绝对是你想让你的编译器是哪样的就是哪样的，大牛必备。完全可以一个文本模式写到底。&lt;/p&gt;
&lt;h2&gt;2、思维导图&lt;/h2&gt;
&lt;p&gt;工作之余，学习之余，相信每个进入这行的都有点自制力，喜欢钻研一些东西的。必备思维导图 &lt;span&gt;Xmind &lt;/span&gt;这个玩意，提高思维能力，多多总结。不想当大佬的程序猿不是一个好的程序猿不是。兴许做着做着就成了一个产品经理。谁叫你思维这么敏捷，技术总结，技术分享头头是道，不是你还有谁呢~~&lt;/p&gt;
&lt;h2&gt;3、技术总结&lt;/h2&gt;
&lt;p&gt;这个小编觉得还是很有必要的。不管是公司需要做每周技术总结还是自己。都需要给自己一个交代。自己用过什么，学了什么，而不是很懵逼的搬搬砖。这年头搬砖的不稀奇。没有头发的搬砖的才稀奇....经常性的技术总结非常有利于自己技术的提升。这里又是一个神级软件 &lt;span&gt;Typora &lt;/span&gt;。 这里不做介绍，小编相信如果你搜了这个软件不安装一下内心还有点小小的不安哈哈。&lt;/p&gt;
&lt;h2&gt;4、奇奇怪怪的小软件&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;Ghostlab&lt;/span&gt;，电脑端连手机端实时调控，暂时没见到有这么方便和好用的调试软件，&lt;/p&gt;
&lt;p&gt;标尺,, 很重要，量尺寸有没有，别再被 ui 小姐姐说你这里那里距离不对了&lt;/p&gt;
&lt;p&gt;&lt;span&gt;PS&lt;/span&gt;，相信每个人都有的。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;PxCook&lt;/span&gt;，和PS一样与 ui 小姐姐有共同话题的必备软件哟。&lt;/p&gt;
&lt;p&gt;好啦~ 今天一些软件小编暂时分享到这里，下次再分享一些接触前端2年以来的一些神级网站噢。。&lt;/p&gt;

&lt;p&gt;---------------------------------------------------------分割线---------------------------------------------------&lt;/p&gt;

&lt;p&gt;小编码字找图不易，希望小编的分享能对大家有所启发。大家有不同的意见或建议可以在下面的留言区跟我交流。觉得好可以关注，后续还有继续推文噢~　&lt;/p&gt;
</description>
<pubDate>Fri, 07 Jun 2019 15:01:00 +0000</pubDate>
<dc:creator>爱看星星的稻草人</dc:creator>
<og:description>1、 编译器 写代码只是生产软件过程中的一环。无论是数据结构、编译原理、操作系统还是组成原理都是编码的重要基础，试问没有学过编译原理的人能够针对性地进行编译优化吗？不懂操作系统的人能玩得转linux吗</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chase-star/p/10989495.html</dc:identifier>
</item>
<item>
<title>ActiveMQ入门系列二：入门代码实例（点对点模式） - JAVA开发老菜鸟</title>
<link>http://www.cnblogs.com/sam-uncle/p/10988930.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sam-uncle/p/10988930.html</guid>
<description>&lt;p&gt;在上一篇《&lt;a href=&quot;https://www.cnblogs.com/sam-uncle/p/10979049.html&quot; target=&quot;_blank&quot;&gt;ActiveMQ入门系列一：认识并安装ActiveMQ（Windows下）&lt;/a&gt;》中，大致介绍了ActiveMQ和一些概念，并下载、安装、启动他，还访问了他的控制台页面。&lt;/p&gt;
&lt;p&gt;这篇，就用代码实例说下如何实现消息的生产和消费。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、理论基础&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;同&lt;a href=&quot;https://www.cnblogs.com/sam-uncle/p/9234927.html&quot; target=&quot;_blank&quot;&gt;RabbitMQ&lt;/a&gt;一样，ActiveMQ中也是有两种模式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;点对点模式（Point to Point，简写为PTP）&lt;/li&gt;
&lt;li&gt;发布/订阅模式（Publish &amp;amp; Subscribe，简写为Pub &amp;amp; Sub）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;通过&lt;a href=&quot;https://www.cnblogs.com/sam-uncle/p/10979049.html&quot; target=&quot;_blank&quot;&gt;上一篇&lt;/a&gt;我们知道了制造消息的应用叫生产者（Producer），生产者在生产了消息后会发送消息到目的地（Destination），到达消费和处理消息的应用（也就是消费者Consumer）。这里的两种模式就通过对应不同的消息目的地（Destination）来实现，PTP对应Queue（队列）、Pub&amp;amp;Sub对应Topic（主题）。&lt;/p&gt;
&lt;p&gt;今天就详细介绍下PTP和Queue，下一篇介绍Pub &amp;amp; Sub和Topic。&lt;/p&gt;
&lt;p&gt;在PTP模式的示意图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1345071/201906/1345071-20190607184856062-214964275.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;消息生产者生产消息发送到queue中，然后消息消费者从queue中取出并且消费消息。&lt;/li&gt;
&lt;li&gt;消息被消费以后，queue中不再有存储，所以消息消费者不可能消费到已经被消费的消息。&lt;/li&gt;
&lt;li&gt;Queue支持存在多个消费者，但是对一个消息而言，只会有一个消费者可以消费、其它的则不能消费此消息了。&lt;/li&gt;
&lt;li&gt;当消费者不存在时，消息会一直保存，直到有消费消费。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在PTP中，代码实现有两种方式：消费者主动消费和消费者监听消费，下面就分别说下。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、消费者主动消费&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;主动消费是最基本也是最简单的消费方式，先上代码：&lt;/p&gt;
&lt;ol&gt;&lt;li readability=&quot;-1.5&quot;&gt;创建maven工程并引入依赖
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.apache.activemq&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;activemq-core&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;5.7.0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;1.5&quot;&gt;实现生产者
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.sam.ptp;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.activemq.ActiveMQConnectionFactory;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; javax.jms.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; JAVA开发老菜鸟
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Producer {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;  String QUEUE_NAME = &quot;ptp-demo&quot;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;队列名&lt;/span&gt;

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; producer(String message) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; JMSException {
        ConnectionFactory factory &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        Connection connection &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        Session session &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        MessageProducer producer &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
             * 1.创建连接工厂
             * 创建工厂，构造方法有三个参数：分别是用户名、密码、连接地址
             * 无参构造：有默认的连接地址，localhost
             * 一个参数：无验证模式，无用户的认证
             * 三个参数：有认证和连接地址，我这里使用三个参数的构造方法
             &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            factory &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ActiveMQConnectionFactory(&quot;admin&quot;,&quot;admin&quot;,&quot;tcp://localhost:61616&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
             * 2.创建连接，有两个方法（我这里使用无参数的）
             * 无参数
             * 有参数：用户名、密码；
             &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            connection &lt;/span&gt;=&lt;span&gt; factory.createConnection();
            &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
             * 3.启动连接
             * 生产者可以不用调用start()方法启动，因为在发送消息的时候回进行检查
             * 如果未启动连接，会自动启动。
             * 如果有特殊配置，需要配置完成后再启动连接
             &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            connection.start();
            &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
             * 4.用连接创建会话
             * 有两个参数：是否需要事务、消息确认机制
             * 如果支持事务，对于生产者来说第二个参数就无效了，这个时候第二个参数建议传入Session.SESSION_TRANSACTED
             * 如果不支持事务，第二个参数有效且必须传递
             *
             * AUTO_ACKNOWLEDGE：自动确认，消息处理后自动确认（商业开发不推荐）
             * CLIENT_ACKNOWLEDGE：客户端手动确认，消费者处理后必须手动确认
             * DUPS_OK_ACKNOWLEDGE：有副本的客户端手动确认，消息可以多次处理（不建议）
             &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            session &lt;/span&gt;= connection.createSession(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;, Session.AUTO_ACKNOWLEDGE);
            &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
             * 5.用会话创建目的地（队列）、生产者、消息
             * 队列名是队列的唯一标记
             * 创建生产者的时候可以指定目的地，也可以在发送消息的时候再指定
             &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            Destination destination &lt;/span&gt;=&lt;span&gt; session.createQueue(QUEUE_NAME);
            producer &lt;/span&gt;=&lt;span&gt; session.createProducer(destination);
            TextMessage textMessage &lt;/span&gt;=&lt;span&gt; session.createTextMessage(message);
            &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
             * 6.生产者发送消息到目的地
             &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            producer.send(textMessage);
            System.out.println(&lt;/span&gt;&quot;消息发送成功&quot;&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(Exception ex){
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; ex;
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
             * 7.释放资源
             &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;(producer != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                producer.close();
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(session != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                session.close();
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(connection != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                connection.close();
            }
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
        Producer producer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Producer();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
            producer.producer(&lt;/span&gt;&quot;hello, activemq&quot;&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex){
            ex.printStackTrace();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;实现消费者
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.sam.ptp;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.activemq.ActiveMQConnectionFactory;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; javax.jms.*&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; JAVA开发老菜鸟
 *
 * 主动消费
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Consumer {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String consumer() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; JMSException {
        ConnectionFactory factory &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        Connection connection &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        Session session &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        MessageConsumer consumer &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            factory &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ActiveMQConnectionFactory(&quot;admin&quot;,&quot;admin&quot;,&quot;tcp://localhost:61616&quot;&lt;span&gt;);
            connection &lt;/span&gt;=&lt;span&gt; factory.createConnection();
            &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
             * 消费者必须启动连接，否则无法消费
             &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            connection.start();
            session &lt;/span&gt;= connection.createSession(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;, Session.AUTO_ACKNOWLEDGE);
            Destination destination &lt;/span&gt;=&lt;span&gt; session.createQueue(Producer.QUEUE_NAME);
            consumer &lt;/span&gt;=&lt;span&gt; session.createConsumer(destination);
            &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
             * 获取队列消息
             &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            Message message &lt;/span&gt;=&lt;span&gt; consumer.receive();
            String text &lt;/span&gt;=&lt;span&gt; ((TextMessage) message).getText();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; text;
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(Exception ex){
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; ex;
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
             * 7.释放资源
             &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;(consumer != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                consumer.close();
            }
            
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(session != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                session.close();
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(connection != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                connection.close();
            }
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
        Consumer consumer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Consumer();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
            String message &lt;/span&gt;=&lt;span&gt; consumer.consumer();
            System.out.println(&lt;/span&gt;&quot;消息消费成功：&quot; +&lt;span&gt; message);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex){
            ex.printStackTrace();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;好，这样代码就写好了，我们来测试下。&lt;/p&gt;
&lt;p&gt;1.先运行生产者，我发现报错了。。。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1345071/201906/1345071-20190607214004981-2095591563.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好吧，原来是我这次没有启动ActiveMQ，被自己蠢哭了。。。&lt;/p&gt;
&lt;p&gt;启动ActiveMQ之后，再运行生产者，成功了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1345071/201906/1345071-20190607214200220-880205019.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;去看下控制台页面的变化，队列里面多了个“ptp-demo”队列，这个就是我们生产者代码里面的队列名，并且能看到该队列的基本情况：&lt;/p&gt;
&lt;p&gt;从左到右依次为，有待消费的消息1条、消费者0个、已经发送的消息1条、已经消费的消息0条&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1345071/201906/1345071-20190607214350497-575367586.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.接下来运行消费者，成功&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1345071/201906/1345071-20190607214845152-521833124.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再去看下控制台页面，发现队列信息变了，从左到右依次为：有待消费的消息0条、消费者0个、已经发送的消息1条、已经消费的消息1条&lt;/p&gt;
&lt;p&gt;也就是说，消息真的被消费了！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1345071/201906/1345071-20190607214943617-220973800.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 代码写完了，也按照预期执行完了，我们现在再回过头来分析下消费者的代码，会发现他在consumer.receive()之后不会再消费其他消息了，即便后面再有消息被生产出来也不会再消费。也就是说只能在运行后消费一次消息，这个就是主动消费。&lt;/p&gt;
&lt;p&gt;如果想要循环消费多次产生的消息的话，怎么办呢？请用下面的监听消费&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、消费者监听消费&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;还是先上代码，代码结构同主动消费类似，有细微差别，具体代码不贴了，可以到我的&lt;a href=&quot;https://github.com/sam-uncle/activemq-demo&quot; target=&quot;_blank&quot;&gt;GitHub&lt;/a&gt;或&lt;a href=&quot;https://gitee.com/sam-uncle/activemq-demo&quot; target=&quot;_blank&quot;&gt;码云&lt;/a&gt;上获取源码&lt;/p&gt;
&lt;ol&gt;&lt;li readability=&quot;-2&quot;&gt;首先为了区分，我把队列名改了
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;  String QUEUE_NAME = &quot;ptp-listener-demo&quot;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;队列名&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li readability=&quot;-1.4575971731449&quot;&gt;生产者和消费者的消息确认方式都改成了客户端手动确认，不再自动确认，手动确认有个好处就是可以防止消息没有被正常消费而丢失，这个同&lt;a href=&quot;https://www.cnblogs.com/sam-uncle/p/9202933.html&quot; target=&quot;_blank&quot;&gt;RabbitMQ&lt;/a&gt;机制一样
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
session = connection.createSession(&lt;span&gt;false&lt;/span&gt;, Session.CLIENT_ACKNOWLEDGE);
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;生产者生产消息的时候，为了方便我改成了一次性发送10条
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
             * 6.创建消息并且生产者发送消息到目的地
             &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; num = 0; num &amp;lt; 10; num++&lt;span&gt;){
                TextMessage textMessage &lt;/span&gt;= session.createTextMessage(message +&lt;span&gt; num);
                producer.send(textMessage);
                System.out.println(&lt;/span&gt;&quot;消息发送成功&quot;+&lt;span&gt;textMessage.getText());
            }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li readability=&quot;-0.5&quot;&gt;关键点来了，在&lt;strong&gt;消费者上加了一个监听器&lt;/strong&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
             * 注册监听器，队列中的消息变化会自动触发监听器，接收并自动处理消息
             *
             * 监听器一旦注册，永久有效，一直到程序关闭
             * 监听器可以注册多个，相当于集群
             * activemq自动轮询多个监听器，实现并行处理
             &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            consumer.setMessageListener(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MessageListener() {
                @Override
                &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onMessage(Message message) {

                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;需要手动确认消息&lt;/span&gt;
&lt;span&gt;                        message.acknowledge();
                        TextMessage om &lt;/span&gt;=&lt;span&gt; (TextMessage) message;
                        String data &lt;/span&gt;=&lt;span&gt; om.getText();
                        System.out.println(data);
                    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (JMSException e) {
                        e.printStackTrace();
                    }
                }
            });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;执行生产者：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1345071/201906/1345071-20190607222749219-2131818282.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;执行消费者，消息全部被消费了：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1345071/201906/1345071-20190607222805473-318535608.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再执行2遍生产者，消息同样都被消费了。 &lt;/p&gt;
&lt;p&gt;控制台页面多了个队列，由于监听中的消费者没有关闭，因此这里能看到消费者数量为1，我执行了三遍生产者，因此消息有30条。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1345071/201906/1345071-20190607222847607-1264325830.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还没完，继续...&lt;/p&gt;
&lt;p&gt;我们这次先启动2个消费者，然后启动生产者&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1345071/201906/1345071-20190607223411354-692253597.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1345071/201906/1345071-20190607223434326-1350693471.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;两个生产者分别消费了消息0,2,4,6,8和1,3,5,7,9&lt;/p&gt;
&lt;p&gt;也就是说两个消费者都监听到了消息，并且activemq自动轮询两个监听器发送消息。&lt;/p&gt;

&lt;p&gt;好，到这里，ActiveMQ的点对点模式就介绍完了。下一篇介绍发布订阅模式，敬请期待&lt;/p&gt;
</description>
<pubDate>Fri, 07 Jun 2019 14:40:00 +0000</pubDate>
<dc:creator>JAVA开发老菜鸟</dc:creator>
<og:description>在上一篇《ActiveMQ入门系列一：认识并安装ActiveMQ（Windows下）》中，大致介绍了ActiveMQ和一些概念，并下载、安装、启动他，还访问了他的控制台页面。 这篇，就用代码实例说下如</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sam-uncle/p/10988930.html</dc:identifier>
</item>
<item>
<title>ES6函数参数默认值作用域的模拟原理实现与个人的一些推测 - 听风是风</title>
<link>http://www.cnblogs.com/echolun/p/10983436.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/echolun/p/10983436.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;一、函数参数默认值中模糊的独立作用域&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我在ES6入门学习函数拓展这一篇博客中有记录，当函数的参数使用默认值时，参数会在初始化过程中产生一个独立的作用域，初始化完成作用域会消失；如果不使用参数默认值，不会产生这个作用域；产生疑问是因为这段代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; x = 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt; foo(x, y = &lt;span&gt;function&lt;/span&gt; () {x = 2&lt;span&gt;;}) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; x = 3&lt;span&gt;;
    y();
    console.log(x);
};
foo();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;
foo(4);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;
console.log(x);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;老实说，关于这个独立作用域的描述十分抽象，当我的同事对于这问题述向我提出疑问时，我发现确实不能很好的给他解释这个问题，原因很简单，我也似懂非懂。对此我做了一些测试，并尝试去模拟实现这个作用域，便于说服同事以及我自己。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为什么var x=3始终输出3，为什么去掉var后始终输出2，这个独立的作用域到底是怎么回事？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果你对于这个问题了如指掌，相关笔试题轻松解答，这篇文章就不那么重要了；但如果你对这个作用域跟我一样有一些疑虑，那可以跟着我的思路来理一理，那么本文开始。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、ES6带来的块级作用域&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在改写这段代码前，有必要先把块级作用域说清楚。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们都知道，在ES6之前JavaScript只存在&lt;span&gt;全局作用域&lt;/span&gt;与&lt;span&gt;函数作用域&lt;/span&gt;这两类，更有趣的是当我们使用var去声明一个变量或者一个函数，本质上是在往window对象上新增属性：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; name = &quot;听风是风&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; age = 26&lt;span&gt;;
window.name; &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;'听风是风'&lt;/span&gt;
window.age; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这自然是不太好的做法，我们本想声明几个变量，结果原本干净的window对象被弄的一团糟，为了让变量声明与window对象不再有牵连，也是弥补变量提升等一些缺陷，ES6正式引入了let声明。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;delete&lt;/span&gt;&lt;span&gt; window.name;
let name &lt;/span&gt;= &quot;听风是风&quot;&lt;span&gt;;
window.name; &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;undefined&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;let还带来了一个比较重要的概念，&lt;span&gt;块级作用域&lt;/span&gt;，当我们在一个花括号中使用let去声明一个变量，这个花括号就是一个块级作用域，块级作用域外无权访问这个变量。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    let x &lt;/span&gt;= 1&lt;span&gt;;
}
console.log(x)&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;报错，x未声明&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;当你在这个块级作用域&lt;span&gt;外层&lt;/span&gt;再次声明x时，外层作用域中的x与块级作用域中的x就是不同的两个x了，互不影响：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
let x = 2&lt;span&gt;; 
{
    let x &lt;/span&gt;= 1&lt;span&gt;;
    console.log(x); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;}
console.log(x) &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;

&lt;span&gt;var&lt;/span&gt; y = 1&lt;span&gt;; 
{
    let y &lt;/span&gt;= 2&lt;span&gt;
}
console.log(y) &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;但你不可以在&lt;span&gt;同层&lt;/span&gt;作用域中使用let声明一个变量后再次var 或者再次let相同变量：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
let x = 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; x; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;报错,x已声明&lt;/span&gt;
&lt;span&gt;
let y &lt;/span&gt;= 1&lt;span&gt;;
let y; &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;报错，y已声明&lt;/span&gt;

&lt;span&gt;var&lt;/span&gt; z = 1&lt;span&gt;;
let z; &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;报错，z已声明&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;块级作用域依旧存在&lt;span&gt;作用域链&lt;/span&gt;，并不是说你变成了块级作用域就六亲不认了，谁也别想用我块级里面的变量：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;父作用域&lt;/span&gt;
    let x = 1&lt;span&gt;;
    let y &lt;/span&gt;= 1&lt;span&gt;; 
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;子作用域&lt;/span&gt;
        console.log(x); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
        x = 2&lt;span&gt;;
        let y &lt;/span&gt;= 2&lt;span&gt;;
        console.log(y); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;
&lt;span&gt;    }
    console.log(x); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;
    console.log(y);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;上述代码中子作用域中没let x，父作用域还是允许子作用域中访问修改自己的x；父子作用域中都let y，那两个作用域中的y就是完全不相关的变量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最后一点，很多概念都说，外(上)层作用域是无权访问块级作用域的变量，这句话其实有歧义，准确来说，是&lt;span&gt;无权访问块级作用域中使用了let的变量&lt;/span&gt;，我的同事就误会了这点：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    let x &lt;/span&gt;= 1&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; y = 2&lt;span&gt;;
    z &lt;/span&gt;= 3&lt;span&gt;;
}
console.log(y);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;
console.log(z);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;
console.log(x);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;报错,x未定义&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;let x确实产生了一个块级作用域，但你只能限制外层访问产生块级作用域的x，我y用的var，z直接就全局，你们抓周树人跟我鲁迅有什么关系？这点千万要理解清楚。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1213309/201906/1213309-20190607175339343-24940257.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;介绍let可能花了点时间，明明是介绍函数参数默认值的作用域，怎么聊到let了。这是因为我在给同事说我的推测时，我发现他对于let存在部分误解，所以在理解我的思路上也花了一些时间。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; 三、关于函数参数默认值独立作用域的推测与我的代码&lt;strong&gt;模拟&lt;/strong&gt;思路&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.改写函数参数&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们都知道，函数的参数其实等同于在函数内部声明了一个局部变量，只是这个变量在函数调用时能与传递的参数一一对应进行赋值：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; fn(x) {
    console.log(x);
};
fn(&lt;/span&gt;1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;等用于&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; fn() {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;函数内部声明了一个变量，传递的值会赋予给它&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; x = 1&lt;span&gt;;
};
fn()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;所以第一步，我将文章开头那段代码中的函数进行改写，将形参改写进函数内部：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; foo() {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; x;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; y = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        x &lt;/span&gt;= 2&lt;span&gt;;
    };
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; x = 3&lt;span&gt;;
    y();
    console.log(x);
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.模拟形参的独立作用域&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;改写后有个问题，此时形参与函数内部代码处于同一层作用域，这与我们得知的概念不太相符，概念传达的意思是，&lt;span&gt;函数参数使用默认值，会拥有独立的作用域&lt;/span&gt;，所以我们用一个花括号将函数内代码隔离起来：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; foo() {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; x;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; y = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        x &lt;/span&gt;= 2&lt;span&gt;;
    };
    {
        var x &lt;/span&gt;= 3&lt;span&gt;;
        y();
        console.log(x);
    }
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;其次，由文章开头的代码结果我们已经得知，var x =3这一行代码，如果带了var ，函数体内x变量就与参数内的x互不影响了，永远输出3；如果把var去掉呢，就能继承并修改参数中的变量x了，此时x始终输出2，这个效果可以自己复制文章开头的原代码测试。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我在上文介绍let块级作用域时有提到块级作用域也是有作用域链的；父子块级作用域，如果子作用域自己let一个父作用域已声明的变量，那么两者就互不影响，如果子不声明这个变量，还是可以继承使用和修改父作用域的此变量。这个情况不就是示例代码的除去var和不除去var效果吗，只是我们还缺个块级作用域才能满足这个条件，所以我将var x =3前面的var修改成了let，整个代码修改完毕：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; foo() {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;父作用域&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; x;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; y = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        x &lt;/span&gt;= 2&lt;span&gt;;
    };
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 子块级作用域&lt;/span&gt;
        let x = 3&lt;span&gt;;
        y();
        console.log(x);
    }
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;你肯定要问，我为什么要把var改为let？并不是我根据结论强行倒推理，我在断点时发现了一个问题，带var的情况：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1213309/201906/1213309-20190607205120508-786210260.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意观察右边Scope的变化，当断点跑到var x = 3时，显示在&lt;span&gt;block（块级作用域）&lt;/span&gt;下x是undefined，然后被赋值成了3，最后断点跑到console时，也是输出了block作用域下的x，而且在&lt;span&gt;block作用域&lt;/span&gt;和&lt;span&gt;local作用域&lt;/span&gt;中分别存在2个变量x，如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1213309/201906/1213309-20190607210128317-1102268786.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;函数内部明明没用let，也就是说，函数执行时，隐性创建了一个块级作用域包裹住了函数体内代码。当我把var去掉时，再看截图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1213309/201906/1213309-20190607205855556-655964819.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以看到，当去掉var时，整个代码执行完，全程都不存在block作用域，而且从头到尾都只有local作用域下的一个x。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;由此&lt;/span&gt;&lt;strong&gt;我推断var是产生块级作用域的原因&lt;/strong&gt;，所以将x变量前的var改为了let。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.模拟代码测试阶段：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们最终修改后的代码就是这样：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; x = 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; foo() {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; x;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; y = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        x &lt;/span&gt;= 2&lt;span&gt;;
    }; 
    {
        let x &lt;/span&gt;= 3&lt;span&gt;;
        y();
        console.log(x);
    }
};
foo(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;
foo(4); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;
console.log(x); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;带var分别输出3 3 1，我们把var 改成了let，也是输出3 3 1。去var输出2 2 1，我们把let去掉也是输出2 2 1，效果一模一样。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们对比了修改前后，代码执行时scope的变化，是一模一样的，可以说模拟还算成功。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.最终模拟版本&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后我又发现了一个改写的大问题：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt; fn(x=&lt;span&gt;x){
    
};
fn();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;报错&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这段代码是会报错的，它会提示你，x未声明就使用了，这是let声明常见的错误。但是如果按照我前面说的将形参移到函数体内用var声明，那就不会报错了：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; fn(){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; x =&lt;span&gt; x;
};
fn()&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不报错&lt;/span&gt;

&lt;span&gt;function&lt;/span&gt;&lt;span&gt; fn(){
    let x &lt;/span&gt;=&lt;span&gt; x;
};
fn()&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;报错&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;所以我上面的初始代码改写后的最终版本是这样：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; x = 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; foo() {
    let x;
    let y &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        x &lt;/span&gt;= 2&lt;span&gt;;
    }; 
    {
        let x &lt;/span&gt;= 3&lt;span&gt;;
        y();
        console.log(x);
    }
};
foo(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;
foo(4); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;
console.log(x); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这是执行效果图，仔细观察可以发现scope变化以及执行结果与没改之前一样，只是我觉得这样改写更为严谨。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1213309/201906/1213309-20190607212954747-38676.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;四、最终结论与个人推测&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以我得到的最终结论是，并不是函数形参使用了默认值会产生独立的作用域，而是&lt;span&gt;&lt;strong&gt;&lt;span&gt;函数形参使用了默认值时，会让函数体内的var声明隐性产生一个块级作用域，从而变相导致了函数参数所在作用域被隔离。不使用参数默认值或函数体内不使用var声明不会产生此作用域&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我的改写模拟思路是这样：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一步，&lt;span&gt;形参如果用了默认值，将形参移到函数体内并用let声明它们&lt;/span&gt;；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第二步，&lt;span&gt;如果此时没报错，再用花括号将原本的函数体代码包裹起来，再将花括号中的var声明修改成let声明&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt; fn(x, y =&lt;span&gt; x) {
    let x &lt;/span&gt;= 1&lt;span&gt;;
    console.log(x);
};
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第一步：&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; fn() {
    let x;
    let y &lt;/span&gt;=&lt;span&gt; x;
    let x &lt;/span&gt;= 1&lt;span&gt;;
    console.log(x);
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;比如上述这段代码，形参移动到函数体内其实你就已经会报错了，x变量被反复申明了，所以就没必要再用花括号包裹执行体代码了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;我大概总结出了以下几个规律&lt;/span&gt;(可以按照我的思路改写，方便理解)：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.当函数形参声明了x，函数体内不能使用let再次声明x，否则会报错，原因参照函数改写步骤1。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; x = 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; fn(x){
    let x &lt;/span&gt;=1&lt;span&gt;;//报错
};
fn();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2.当函数形参声明了x，函数体内再次使用var声明x时，函数体内会隐性创建一个块级作用域，这个作用域会包裹执行体代码，也变相导致参数有了一个独立的作用域，此时两个x互不影响，原因参照函数改写步骤2。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt; fn(x =1&lt;span&gt;){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; x =2&lt;span&gt;;
    console.log(x);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;
&lt;span&gt;};
fn();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;3.当函数形参声明了x，函数体内未使用var或者let去声明x，函数体内可以直接修改和使用参数x的，此时共用的是同一个变量x，块级作用域也存在作用域链。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; x =2&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt; fn(y =&lt;span&gt; x){
    x &lt;/span&gt;=3&lt;span&gt;;
    console.log(y);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;
&lt;span&gt;};
fn();
x&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;4.当函数形参未声明x，但是参数内又有参数默认值使用了x，此时会从全局作用域继承x。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; x = 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt; fn(y=&lt;span&gt;x){
    console.log(y);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;};
fn();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;那么到这里，我大概模拟了函数参数默认值时产生独立作用域的过程，同时按照我的理解去解释了它。也许我的推测与底层代码实现有所偏差，但是这个模拟过程能够很直观的去推测正确的执行结果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我写这篇文章也是为了两个目的，第一如果在面试中遇到，我能更好的解释它，而不是似懂非懂；其次，在日常开发中使用函数参数默认值时，我能更清晰的写出符合我预期结果的代码，此时的你应该也能做到这两点了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本文中所有的代码都是可测的，若有问题，或者更好的推测欢迎留言讨论。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么就写到这里了，端午节快乐！&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 07 Jun 2019 14:07:00 +0000</pubDate>
<dc:creator>听风是风</dc:creator>
<og:description>一、函数参数默认值中模糊的独立作用域 我在ES6入门学习函数拓展这一篇博客中有记录，当函数的参数使用默认值时，参数会在初始化过程中产生一个独立的作用域，初始化完成作用域会消失；如果不使用参数默认值，不</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/echolun/p/10983436.html</dc:identifier>
</item>
<item>
<title>【朝花夕拾】Android自定义View篇之（五）Android事件分发及传递机制 - 宋者为王</title>
<link>http://www.cnblogs.com/andy-songwei/p/10989172.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/andy-songwei/p/10989172.html</guid>
<description>&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       在自定义View中，经常需要处理Android事件分发的问题，尤其在有多个输入设备（如遥控、鼠标、游戏手柄等）时，事件处理问题尤为突出。Android事件分发机制，一直以来都是一个让众多开发者困扰的难点，至少笔者在工作的前几年中，没有特意研究它之前，就经常云里雾里。实际上，该问题的“七寸”就是dispatchTouchEvent(MotionEvent ev)、onInterceptTouchEvent(MotionEvent ev)、onTouchEvent(MotionEvent ev)这三个方法和MotionEvent事件实体，咱们这里索性称它们为“四大恶人”吧。本文将主要通过示例演示的方式来打这个“七寸”吧。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一、事件分发机制与生活场景的类比&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       Android的事件分发机制和生活中的很多场景有着相似之处，可能Android的很多设计灵感就是来源于生活吧。&lt;/p&gt;

&lt;p&gt;  1、示例中的四个角色&lt;/p&gt;
&lt;p&gt;       在众多示例当中，有一个经常被拿来举例的经典场景就是PM（项目经理）、Team Leader、Programmer之间工作安排的问题，咱们这里也用这个场景来类比，另外再加一个Boss的角色，以便于理解。现在这个公司中四个角色职位从高到低依次为，Boss &amp;gt; PM &amp;gt; Team Leader &amp;gt; Programmer。&lt;/p&gt;

&lt;p&gt;  2、可能出现的场景&lt;/p&gt;
&lt;p&gt;       一般来说，一个寻常的工作流程是：Boss想到有个功能很流行，就会指示PM去办，PM会分发给Team Leader，而Team Leader会安排Proggrammer去编程实现。Boss是决策者，事件来源于他；PM和Team Leader是管理者，负责一层层把任务派发给自己的下属；Programmer是具体来做开发的，所以事件最后落在他的身上了，最后由他来完成。但是现实工作中，工作并不总是这个流程，还有很多其它场景，比如：&lt;/p&gt;
&lt;p&gt;    （1）市面上出现了一很火的行业，做智能手机。本公司是否需要也涉足这个行业，需要Boss自己开董事会来做决策。那么这个事情就是Boss应该处理的事情，他就不会派发给PM，Boss以下的员工看来，就跟没有任何事情一样。&lt;/p&gt;
&lt;p&gt;    （2）Boss确定了智能手机是一个很有前景的行业，确定了要做，于是就召集PM，做好立项工作。那这个立项工作就是这个PM的工作了，如何立项，需要招聘什么样人等各项准备工作，PM就得自己做好整个计划，事情就到他这里为止了，不会再往下派发。&lt;/p&gt;
&lt;p&gt;    （3）做手机挣了钱，Boss决定奖励一些表现优异的Programmer。这需要先安排PM，PM然后安排下面的Team Leader对下面的Programmer们做综合考量，将优秀者报上去。这就是Team Leader需要完成的工作，他也无法再传下去。&lt;/p&gt;
&lt;p&gt;    （4）如前面说到的，Boss要求做一个市面上很流行的功能，经过PM和Team Leader层层派发到了Programmer手上。虽然事情派发到了Programmer手上，但也有两种情形：&lt;/p&gt;
&lt;p&gt;          1）在Programmer能力范围内，做得很完美。这种情况事情就在这里被处理掉了，无需再传递出去了。后续Boss一系列的类似功能也会继续派发下来，也以这样的流程来走下去。&lt;/p&gt;
&lt;p&gt;          2）Programmer能力有限，做不了。这种情况下，他就需要告诉Team Leader这一情况，把这个任务再依次传递给自己的领导。这样又有两种情况：①Team Leader 或者PM本身也是研发出身，开发能力也很强，就把这个开发任务给完成了，这样事情也就到此为止不再传递了。在Boss看来，下面的团队有能力开发好这类需求，于是后续Boss一系列的类似功能也会继续派发下来，仍然以这样的流程来走下去，到能处理这个事情的责任人处理完为止。②Team Leader和PM都是管理出身，这个功能他们也不会做。于是就层层往上报，最后到老板那里，老板自己处理，是不了了之还是再找招人，或者自己也是个大牛程序员自己可以开发出来，这个决策由老板来做。老板知道自己下面的团队完成不了这一系列任务，后续一系列这类功能，就不再派发下去了。&lt;/p&gt;
&lt;p&gt;    ......&lt;/p&gt;
&lt;p&gt;       上述列出了一些比较有代表性的可能情况，下面咱们根据这些情况，来理解事件的分发机制。其实这里PM和Team Leader可以整体作为一个角色来看，只是为了后面看代码和日志方便对应，才分开为两个角色的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二、MotionEvent简介&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       在讲Android事件分发机制前，先简单了解一些MotionEvent，因为它就是这个“事件”。以下截取了部分源码中的描述：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;......
&lt;/span&gt;&lt;span&gt; 2  * &amp;lt;p&amp;gt;
 3  * Motion events describe movements in terms of an action code and a set of axis values.
 4  * The action code specifies the state change that occurred such as a pointer going
 5  * down or up.  The axis values describe the position and other movement properties.
 6  * &amp;lt;/p&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;......
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MotionEvent &lt;span&gt;extends&lt;/span&gt; InputEvent &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Parcelable {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; ACTION_DOWN  = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; ACTION_UP  = 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; ACTION_MOVE  = 2&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    ......
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       MotionEvent，顾名思义，动作事件的意思。它通过一个action码和一套坐标值来描述动作。action码指定了当如指针按下或者抬起等事件发生时的状态改变，坐标值则描述了事件在屏幕中的位置和其它动作属性值。如下内容为MotionEvent的toString方法打印出来的结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;MotionEvent { action=ACTION_DOWN, actionButton=0, id[0]=0, x[0]=173.0, y[0]=138.0, toolType[0]=TOOL_TYPE_FINGER, buttonState=0, metaState=0, flags=0x2, edgeFlags=0x0, pointerCount=1, historySize=0, eventTime=34268429, downTime=34268429, deviceId=8, source=0x1002 }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从这里可以看到，事件发生的action，时间，坐标等很多信息。本文中暂时只关注aciton这个字段，“action=ACTION_DOWN”表示了按下事件。&lt;/p&gt;
&lt;p&gt;       平时触摸屏幕时，一个最简单的事件包括了“ACTION_DOWN”和“ACTION_UP”，“ACTION_DOWN”表示手指按下，而““ACTION_UP”表示手指抬起来，这两个action才构成了一个完整的事件。如果手指在屏幕上有移动，还会包含“ACTION_MOVE”，此时一个完整的事件就包括“ACTION_DOWN”，多个“ACTION_MOVE”，“ACTION_UP”。当然，实际工作中会有很多复杂的情况出现，可能会出现一些其它的aciton，本文为了演示的方便，只考虑“ACTION_DOWN”和“ACTION_UP”的场景。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;三、代码示例及默认场景分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       为了演示事件分发机制的工作流程，这里编写一个示例来进行演示。整个Acitivity模拟Boss角色；在其界面中的最外层模拟PM，继承自RelativeLayout，是一个父布局；PM下嵌套一层，也是一个父布局，继承自RelativeLayout，用于模拟Team Leader；最里面一层是一个叶子View，继承自Button，模拟Programmer。效果图及对应代码分别如下。&lt;/p&gt;

&lt;p&gt;  1、演示界面    &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201906/472002-20190607134526583-1634913767.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;  2、默认场景下的代码示例&lt;/p&gt;
&lt;p&gt;       如下的代码中，需要重写的方法dispatchTouchEvent(MotionEvent ev)、onInterceptTouchEvent(MotionEvent ev)、onTouchEvent(MotionEvent ev)均返回默认值，即super.xxx。平时咱们使用系统原生控件时，无法修改它们的源码，所以系统给的默认场景就是这样的。&lt;/p&gt;
&lt;p&gt;    （1）Boss：EventDemoActivity&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; EventDemoActivity &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; AppCompatActivity {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onCreate(Bundle savedInstanceState) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onCreate(savedInstanceState);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        setContentView(R.layout.activity_event_demo);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; dispatchTouchEvent(MotionEvent ev) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         Log.i(&quot;songzheweiwang&quot;,&quot;[EventDemoActivity--&amp;gt;dispatchTouchEvent]ev=&quot;+&lt;span&gt;EventUtil.parseAction(ev.getAction()));
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.dispatchTouchEvent(ev);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; onTouchEvent(MotionEvent event) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         Log.i(&quot;songzheweiwang&quot;,&quot;[EventDemoActivity--&amp;gt;onTouchEvent]event=&quot;+&lt;span&gt;EventUtil.parseAction(event.getAction()));
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onTouchEvent(event);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 该Activity的布局文件为&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//==========================activity_event_demo.xml===========================
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;RelativeLayout &lt;/span&gt;&lt;span&gt;xmlns:android&lt;/span&gt;&lt;span&gt;=&quot;http://schemas.android.com/apk/res/android&quot;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;com.example.demos.customviewdemo.ViewGroupOuter
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;300dp&quot;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;300dp&quot;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        android:layout_centerInParent&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        android:background&lt;/span&gt;&lt;span&gt;=&quot;@android:color/holo_orange_dark&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;com.example.demos.customviewdemo.ViewGroupMiddle
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;200dp&quot;&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;200dp&quot;&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            android:layout_centerInParent&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;            android:background&lt;/span&gt;&lt;span&gt;=&quot;@android:color/holo_blue_dark&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;com.example.demos.customviewdemo.ViewInner
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                 &lt;span&gt;android:id&lt;/span&gt;&lt;span&gt;=&quot;@+id/viewInner&quot;&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;                android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;100dp&quot;&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;                android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;100dp&quot;&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;                android:layout_centerInParent&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;                android:background&lt;/span&gt;&lt;span&gt;=&quot;@android:color/holo_green_dark&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;com.example.demos.customviewdemo.ViewGroupMiddle&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;com.example.demos.customviewdemo.ViewGroupOuter&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;RelativeLayout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;     （2）PM：ViewGroupOuter&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ViewGroupOuter &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; RelativeLayout {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ViewGroupOuter(Context context, @Nullable AttributeSet attrs) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;super&lt;/span&gt;&lt;span&gt;(context, attrs);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; dispatchTouchEvent(MotionEvent ev) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         Log.i(&quot;songzheweiwang&quot;,&quot;[ViewGroupOuter--&amp;gt;dispatchTouchEvent]ev=&quot;+&lt;span&gt;EventUtil.parseAction(ev.getAction()));
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.dispatchTouchEvent(ev);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; onInterceptTouchEvent(MotionEvent ev) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         Log.i(&quot;songzheweiwang&quot;,&quot;[ViewGroupOuter--&amp;gt;onInterceptTouchEvent]ev=&quot;+&lt;span&gt;EventUtil.parseAction(ev.getAction()));
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onInterceptTouchEvent(ev);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; onTouchEvent(MotionEvent event) {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         Log.i(&quot;songzheweiwang&quot;,&quot;[ViewGroupOuter--&amp;gt;onTouchEvent]event=&quot;+&lt;span&gt;EventUtil.parseAction(event.getAction()));
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onTouchEvent(event);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    （3）Team Leader：ViewGroupMiddle&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ViewGroupMiddle &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; RelativeLayout {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ViewGroupMiddle(Context context, @Nullable AttributeSet attrs) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;super&lt;/span&gt;&lt;span&gt;(context, attrs);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; dispatchTouchEvent(MotionEvent ev) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         Log.i(&quot;songzheweiwang&quot;,&quot;[ViewGroupMiddle--&amp;gt;dispatchTouchEvent]ev=&quot;+&lt;span&gt;EventUtil.parseAction(ev.getAction()));
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.dispatchTouchEvent(ev);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; onInterceptTouchEvent(MotionEvent ev) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         Log.i(&quot;songzheweiwang&quot;,&quot;[ViewGroupMiddle--&amp;gt;onInterceptTouchEvent]ev=&quot;+&lt;span&gt;EventUtil.parseAction(ev.getAction()));
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onInterceptTouchEvent(ev);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; onTouchEvent(MotionEvent event) {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         Log.i(&quot;songzheweiwang&quot;,&quot;[ViewGroupMiddle--&amp;gt;onTouchEvent]event=&quot;+&lt;span&gt;EventUtil.parseAction(event.getAction()));
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onTouchEvent(event);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    （4）Programmer：ViewInner  &lt;/p&gt;
&lt;p&gt;       这里先以Button为例，因为Button默认是可以处理Touch事件的，也就是说，事件传到这里时，能被完美地处理掉。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; @SuppressLint(&quot;AppCompatCustomView&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ViewInner &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Button{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ViewInner(Context context, AttributeSet attrs) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;super&lt;/span&gt;&lt;span&gt;(context, attrs);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; dispatchTouchEvent(MotionEvent event) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         Log.i(&quot;songzheweiwang&quot;,&quot;[ViewInner--&amp;gt;dispatchTouchEvent]event=&quot;+&lt;span&gt;EventUtil.parseAction(event.getAction()));
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.dispatchTouchEvent(event);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; onTouchEvent(MotionEvent event) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         Log.i(&quot;songzheweiwang&quot;,&quot;[ViewInner--&amp;gt;onTouchEvent]event=&quot;+&lt;span&gt;EventUtil.parseAction(event.getAction()));
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onTouchEvent(event);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    （5）辅助类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; EventUtil {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String parseAction(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; action) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         String actionName = &quot;Unknow:action=&quot; +&lt;span&gt; action;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (action) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;case&lt;/span&gt;&lt;span&gt; MotionEvent.ACTION_DOWN:
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                 actionName = &quot;ACTION_DOWN&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;case&lt;/span&gt;&lt;span&gt; MotionEvent.ACTION_MOVE:
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 actionName = &quot;ACTION_MOVE&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;case&lt;/span&gt;&lt;span&gt; MotionEvent.ACTION_UP:
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 actionName = &quot;ACTION_UP&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;            &lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; actionName;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;  3、日志&lt;/p&gt;
&lt;p&gt;      点击上图中不同的区域，会有不同的结果。这里点击最中间的View，点击其他区域的结果及分析，我们在后面再介绍。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 1 06-07 13:35:23.483 18298-18298/com.example.demos I/songzheweiwang: [EventDemoActivity--&amp;gt;dispatchTouchEvent]ev=&lt;span&gt;ACTION_DOWN
 2 06-07 13:35:23.483 18298-18298/com.example.demos I/songzheweiwang: [ViewGroupOuter--&amp;gt;dispatchTouchEvent]ev=&lt;span&gt;ACTION_DOWN
 3 06-07 13:35:23.483 18298-18298/com.example.demos I/songzheweiwang: [ViewGroupOuter--&amp;gt;onInterceptTouchEvent]ev=&lt;span&gt;ACTION_DOWN
 4 06-07 13:35:23.483 18298-18298/com.example.demos I/songzheweiwang: [ViewGroupMiddle--&amp;gt;dispatchTouchEvent]ev=&lt;span&gt;ACTION_DOWN
 5 06-07 13:35:23.483 18298-18298/com.example.demos I/songzheweiwang: [ViewGroupMiddle--&amp;gt;onInterceptTouchEvent]ev=&lt;span&gt;ACTION_DOWN
 6 06-07 13:35:23.483 18298-18298/com.example.demos I/songzheweiwang: [ViewInner--&amp;gt;dispatchTouchEvent]event=&lt;span&gt;ACTION_DOWN
 7 06-07 13:35:23.483 18298-18298/com.example.demos I/songzheweiwang: [ViewInner--&amp;gt;onTouchEvent]event=&lt;span&gt;ACTION_DOWN
 8 06-07 13:35:23.524 18298-18298/com.example.demos I/songzheweiwang: [EventDemoActivity--&amp;gt;dispatchTouchEvent]ev=&lt;span&gt;ACTION_UP
 9 06-07 13:35:23.525 18298-18298/com.example.demos I/songzheweiwang: [ViewGroupOuter--&amp;gt;dispatchTouchEvent]ev=&lt;span&gt;ACTION_UP
10 06-07 13:35:23.525 18298-18298/com.example.demos I/songzheweiwang: [ViewGroupOuter--&amp;gt;onInterceptTouchEvent]ev=&lt;span&gt;ACTION_UP
11 06-07 13:35:23.525 18298-18298/com.example.demos I/songzheweiwang: [ViewGroupMiddle--&amp;gt;dispatchTouchEvent]ev=&lt;span&gt;ACTION_UP
12 06-07 13:35:23.525 18298-18298/com.example.demos I/songzheweiwang: [ViewGroupMiddle--&amp;gt;onInterceptTouchEvent]ev=&lt;span&gt;ACTION_UP
13 06-07 13:35:23.525 18298-18298/com.example.demos I/songzheweiwang: [ViewInner--&amp;gt;dispatchTouchEvent]event=&lt;span&gt;ACTION_UP
14 06-07 13:35:23.525 18298-18298/com.example.demos I/songzheweiwang: [ViewInner--&amp;gt;onTouchEvent]event=ACTION_UP&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;  4、结果分析&lt;/p&gt;
&lt;p&gt;       该事件包含了两action：ACTION_DOWN和ACTION_UP。前我们说过，Programmer完美处理好了事件，本次流程就到这里为止了，不再传递，Boss认为团队有能力处理这类任务，所以类似的任务也会同样会交给手下的团队，所以ACTION_UP也走了类似的流程，那么整个事件就算完成了，由Programmer完美完成。整个事件的序列图如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201906/472002-20190607145237550-42782247.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;  5、ViewInner没有能力处理的情况&lt;/p&gt;
&lt;p&gt;       上面的例子中，ViewInner是一个Button，它默认是有能力处理这次Touch事件的。但是如果这是一个默认没有能力处理该时间的控件，又会是一种怎样的情形呢？咱们把ViewInner改为继承View再看看结果（仍然点击中间的ViewInner）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 1 06-07 15:04:25.815 19652-19652/com.example.demos I/songzheweiwang: [EventDemoActivity--&amp;gt;dispatchTouchEvent]ev=&lt;span&gt;ACTION_DOWN
 2 06-07 15:04:25.815 19652-19652/com.example.demos I/songzheweiwang: [ViewGroupOuter--&amp;gt;dispatchTouchEvent]ev=&lt;span&gt;ACTION_DOWN
 3 06-07 15:04:25.815 19652-19652/com.example.demos I/songzheweiwang: [ViewGroupOuter--&amp;gt;onInterceptTouchEvent]ev=&lt;span&gt;ACTION_DOWN
 4 06-07 15:04:25.815 19652-19652/com.example.demos I/songzheweiwang: [ViewGroupMiddle--&amp;gt;dispatchTouchEvent]ev=&lt;span&gt;ACTION_DOWN
 5 06-07 15:04:25.815 19652-19652/com.example.demos I/songzheweiwang: [ViewGroupMiddle--&amp;gt;onInterceptTouchEvent]ev=&lt;span&gt;ACTION_DOWN
 6 06-07 15:04:25.815 19652-19652/com.example.demos I/songzheweiwang: [ViewInner--&amp;gt;dispatchTouchEvent]event=&lt;span&gt;ACTION_DOWN
 7 06-07 15:04:25.815 19652-19652/com.example.demos I/songzheweiwang: [ViewInner--&amp;gt;onTouchEvent]event=&lt;span&gt;ACTION_DOWN
 8 06-07 15:04:25.816 19652-19652/com.example.demos I/songzheweiwang: [ViewGroupMiddle--&amp;gt;onTouchEvent]event=&lt;span&gt;ACTION_DOWN
 9 06-07 15:04:25.816 19652-19652/com.example.demos I/songzheweiwang: [ViewGroupOuter--&amp;gt;onTouchEvent]event=&lt;span&gt;ACTION_DOWN
10 06-07 15:04:25.816 19652-19652/com.example.demos I/songzheweiwang: [EventDemoActivity--&amp;gt;onTouchEvent]event=&lt;span&gt;ACTION_DOWN&lt;br/&gt;11 06-07 15:04:25.865 19652-19652/com.example.demos I/songzheweiwang: [EventDemoActivity--&amp;gt;dispatchTouchEvent]ev=&lt;span&gt;ACTION_UP
12 06-07 15:04:25.865 19652-19652/com.example.demos I/songzheweiwang: [EventDemoActivity--&amp;gt;onTouchEvent]event=ACTION_UP&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时，整个事件的流程就变成了现在这样，直观地表现为如下的流程图：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201906/472002-20190607151521390-2098785608.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       为什么是这种结果呢？因为ViewInner继承自View，其默认情况下，是没有处理Touch事件的能力的。所以Programmer处理不了了，就一层一层网上报告，由于ViewGroupMiddle和ViewGroupOuter都继承自RelativeLayout，默认也是没有处理Touch事件的能力的，所以最后ACTION_DOWN事件就回到了Boss这里，由Boss自己来处理。Boss发现自己首先的团队无法处理这类事件，所以后面的ACTION_UP事件就自己处理了，而没有再往下派发了。这一点，和第二节中的第（4）点的第2）小点的情况②的场景是一致的。&lt;/p&gt;
&lt;p&gt;       如果在activity_event_demo.xml中为各个控件（包括父布局）加上属性[android:clickable=&quot;true&quot;]，或者在Activity中为对应控件添加监听点击事件，那么这个控件就有了处理Touch事件的能力了，就和之前使用Button的场景一样的。读者还可以试试在ViewInnner为View时，其父布局有处理Touch事件的能力时的场景（注意，要点击ViewInner来测试），那么这就是和第二节中的第（4）点的第2）小点的情况①的场景是一致的，这里咱们不再分析日志画流程图了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;四、Touch事件主要方法说明&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       前面一直提到Touch事件的3个主要方法：dispatchTouchEvent(MotionEvent ev)、onInterceptTouchEvent(MotionEvent ev)和onTouchEvent(MotionEvent ev)，那么这三个方法的功能究竟是说明呢？在哪里可以用，在哪里不能用呢？这里可以看看下面的表格：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201906/472002-20190607160413179-1971356322.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       其实我们可用从函数名称来大致判断其功能，dispatchTouchEvent，分发触摸事件，就是把事件传递下去，准确来说就是是否要传递到子View以及自己的onInterceptTouchEvent方法和onTouchEvent方法，也就是说，不仅管子Viiew，还管自身剩下的俩个回调方法。onInterceptTouchEvent，事件拦截，它只管自身子View，而不会影响到自身后面两个方法的执行，如果拦截了，可以记忆为让自己的手下们无事可做。这两个方法容易混淆，需要重点理解和记忆。&lt;/p&gt;
&lt;p&gt;       在上述表格中还可以看到，Activity是无法回调onIntercepTouchEvent方法的，因为这个方法是ViewGroup中的方法，而Activity也不是View体系中，不是视图类，所以没有这个方法。我们可以这样记忆，Activity是Boss，不是打工行列中的一员，自己的任务就是让下面的打工者没去做事情，所有该方法对他来说，没有意义。叶子View也没有这个方法，因为自己没有子View了，也没有拦截的意义。&lt;/p&gt;
&lt;p&gt;        由于这三个方法都是boolean值，再加上默认情形下会返回super.xxx，这样，每一个方法都会有三种可选值。咱们这里先了解一下没一种取值会产生怎么样的结果。&lt;/p&gt;
&lt;p&gt;    （1）事件分发：public boolean dispatchTouchEvent(MotionEvent ev)&lt;/p&gt;
&lt;p&gt;       Touch事件发生时，Activity的dispatchTouchEvent方法会将事件传递给最外层控件的dispatchTouchEvent方法，并由该控件进行分发下去。从根元素依次往下传递，一直到最里面的叶子View，或者中途被某个控件终止，才结束这个派发过程。其分发逻辑如下：&lt;/p&gt;
&lt;p&gt;      1）如果 return true，事件会分发到当前控件的dispatchTouchEvent方法中处理。同时事件停止往下派发，且当前控件的onInterceptTouchEvent和onTouchEvent都不会执行。（这里笔者也不清楚事件是被处理了，还是不了了之了。从打印的log上看，和被处理掉的情形很相似，本次事件，如ACTION_DOWN，到此为止，然后Activity继续给出后续事件，如ACTION_UP，继续走到当前控件的这个方法中，知道这一系列事件全部走完。但是从实验结果看，如果在acitivty中给该控件添加了点击事件，发现点击后没有响应，说明这个时间没有被处理。所以笔者很纳闷，暂时还没有找到权威的说法。）&lt;/p&gt;
&lt;p&gt;      2）如果 return false，事件停止往下派发，且当前控件的onInterceptTouchEvent和onTouchEvent也都不会执行。同时将事件返回给上一级的onTouchEvent事件，由上一级去决定处理还是继续往上传递，自己不处理。&lt;/p&gt;
&lt;p&gt;      3）返回默认的super.dispatchTouchEvent，事件会自动分发给当前View的onInterceptTouchEvent。&lt;/p&gt;
&lt;p&gt;    （2）事件拦截：public boolean onInterceptTouchEvent(MotionEvent ev) &lt;/p&gt;
&lt;p&gt;       在当前控件的dispatchTouchEvent方法返回默认的方式时，其拦截逻辑如下：&lt;/p&gt;
&lt;p&gt;        1）return true，表示将事件进行拦截，并将拦截到的事件交给当前控件的onTouchEvent来处理。&lt;/p&gt;
&lt;p&gt;        2）return false，表示将事件放行，事件会被传递到子View上，并由子View的dispatchTouchEvent方法继续派发。&lt;/p&gt;
&lt;p&gt;        3）return super.onInterceptTouchEvent(ev)，和返回false的逻辑一样。&lt;/p&gt;
&lt;p&gt;    （3）事件响应：public boolean onTouchEvent(MotionEvent ev)&lt;/p&gt;
&lt;p&gt;       该事件会响应的情形有如下两种：1）子View没有处理事件，将事件返回来；2）当前控件中dispatchTouchEvent返回默认的super.dispatchTouchEvent的情况下，且该控件的onInterceptTouchEvent返回false或者默认的super.onInterceptTouchEvent时。onTouchEvent事件响应逻辑如下：&lt;/p&gt;
&lt;p&gt;        1）返回true，当前事件会被处理掉。&lt;/p&gt;
&lt;p&gt;        2）返回false，当前事件不会被处理，返回给上一级的onTouchEvent方法来处理。&lt;/p&gt;
&lt;p&gt;        3）返回super.onTouchEvent，如果自己有能力处理该事件，则会处理，super.onTouchEvent的值为true；否则，如果自己没有能力处理该事件，则将事件返回到上一级中的onTouchEvent方法中处理，当前super.onTouchEvent的值为false。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;五、Touch的3个主要方法返回值对事件分发影响的案例分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       上一节中介绍了Touch的3个主要方法的返回值下，对事件分发的处理逻辑。本节中，咱们通过修改签名实例中的返回值，来看看事件的分发流程（注意：以下情况下均点击中间的ViewInner控件）。&lt;/p&gt;

&lt;p&gt;  1、ViewGroupMiddle中dispatchTouchEvent返回true，其它均返回默认值时。  &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201906/472002-20190607190932814-1774134879.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
1 06-07 19:15:53.220 25298-25298/com.example.demos I/songzheweiwang: [EventDemoActivity--&amp;gt;dispatchTouchEvent]ev=&lt;span&gt;ACTION_DOWN
2 06-07 19:15:53.221 25298-25298/com.example.demos I/songzheweiwang: [ViewGroupOuter--&amp;gt;dispatchTouchEvent]ev=&lt;span&gt;ACTION_DOWN
3 06-07 19:15:53.221 25298-25298/com.example.demos I/songzheweiwang: [ViewGroupOuter--&amp;gt;onInterceptTouchEvent]ev=&lt;span&gt;ACTION_DOWN
4 06-07 19:15:53.222 25298-25298/com.example.demos I/songzheweiwang: [ViewGroupMiddle--&amp;gt;dispatchTouchEvent]ev=&lt;span&gt;ACTION_DOWN6 06-07 19:15:53.237 25298-25298/com.example.demos I/songzheweiwang: [EventDemoActivity--&amp;gt;dispatchTouchEvent]ev=&lt;span&gt;ACTION_UP
7 06-07 19:15:53.237 25298-25298/com.example.demos I/songzheweiwang: [ViewGroupOuter--&amp;gt;dispatchTouchEvent]ev=&lt;span&gt;ACTION_UP
8 06-07 19:15:53.237 25298-25298/com.example.demos I/songzheweiwang: [ViewGroupOuter--&amp;gt;onInterceptTouchEvent]ev=&lt;span&gt;ACTION_UP
9 06-07 19:15:53.238 25298-25298/com.example.demos I/songzheweiwang: [ViewGroupMiddle--&amp;gt;dispatchTouchEvent]ev=ACTION_UP&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       参照第四节中的结论，ViewGroupMiddle的dispatchTouchEvent返回true，事件从Acitivty，经过ViewGroupOuter分发到ViewGroupMiddle中，在其dispatchTouchEvent方法中处理。ViewGroupMiddle的onInterceptTouchEvent和onTouchEvent均不会被调用，且事件也不会再往ViewInner中传递。既然事件是在ViewGroupMiddle的dispatchTouchEvent中被处理了，在Boss  EventDemoActivity看来，自己手下的团队有能力处理这类事件，所以ACTION_UP也被派发下来，走同样的流程，直到所有事件处理完毕。&lt;/p&gt;

&lt;p&gt;  2、ViewGroupMiddle中dispatchTouchEvent返回false，其它均返回默认值时&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201906/472002-20190607192951590-317633292.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
1 06-07 19:31:50.093 25668-25668/com.example.demos I/songzheweiwang: [EventDemoActivity--&amp;gt;dispatchTouchEvent]ev=&lt;span&gt;ACTION_DOWN
2 06-07 19:31:50.094 25668-25668/com.example.demos I/songzheweiwang: [ViewGroupOuter--&amp;gt;dispatchTouchEvent]ev=&lt;span&gt;ACTION_DOWN
3 06-07 19:31:50.094 25668-25668/com.example.demos I/songzheweiwang: [ViewGroupOuter--&amp;gt;onInterceptTouchEvent]ev=&lt;span&gt;ACTION_DOWN
4 06-07 19:31:50.094 25668-25668/com.example.demos I/songzheweiwang: [ViewGroupMiddle--&amp;gt;dispatchTouchEvent]ev=&lt;span&gt;ACTION_DOWN
5 06-07 19:31:50.094 25668-25668/com.example.demos I/songzheweiwang: [ViewGroupOuter--&amp;gt;onTouchEvent]event=&lt;span&gt;ACTION_DOWN
6 06-07 19:31:50.094 25668-25668/com.example.demos I/songzheweiwang: [EventDemoActivity--&amp;gt;onTouchEvent]event=&lt;span&gt;ACTION_DOWN
7 06-07 19:31:50.151 25668-25668/com.example.demos I/songzheweiwang: [EventDemoActivity--&amp;gt;dispatchTouchEvent]ev=&lt;span&gt;ACTION_UP
8 06-07 19:31:50.151 25668-25668/com.example.demos I/songzheweiwang: [EventDemoActivity--&amp;gt;onTouchEvent]event=ACTION_UP&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       参照第四节中的结论，ViewGroupMiddle的dispatchTouchEvent返回true，事件从Acitivty，经过ViewGroupOuter分发到ViewGroupMiddle中，且在dispatchTouchEvent方法中不处理此事件。ViewGroupMiddle的onInterceptTouchEvent和onTouchEvent均不会被调用，且事件也不会再往ViewInner中传递。自己处理不了事件，传递给上一级的onTouchEvent来处理，上一级也没能力处理，最后传给了EventDemoActivity的onTouchEvent。此时，在Boss看来，自己手下团队处理不了这类事件，所以后面的事件就不再传递下去，都有自己来处理。&lt;/p&gt;

&lt;p&gt;  3、ViewGroupMiddle中onInterceptTouchEvent返回true，其它均返回默认值时&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201906/472002-20190607193916789-2122155014.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 1 06-07 19:41:08.894 26055-26055/com.example.demos I/songzheweiwang: [EventDemoActivity--&amp;gt;dispatchTouchEvent]ev=&lt;span&gt;ACTION_DOWN
 2 06-07 19:41:08.894 26055-26055/com.example.demos I/songzheweiwang: [ViewGroupOuter--&amp;gt;dispatchTouchEvent]ev=&lt;span&gt;ACTION_DOWN
 3 06-07 19:41:08.894 26055-26055/com.example.demos I/songzheweiwang: [ViewGroupOuter--&amp;gt;onInterceptTouchEvent]ev=&lt;span&gt;ACTION_DOWN
 4 06-07 19:41:08.894 26055-26055/com.example.demos I/songzheweiwang: [ViewGroupMiddle--&amp;gt;dispatchTouchEvent]ev=&lt;span&gt;ACTION_DOWN
 5 06-07 19:41:08.894 26055-26055/com.example.demos I/songzheweiwang: [ViewGroupMiddle--&amp;gt;onInterceptTouchEvent]ev=&lt;span&gt;ACTION_DOWN
 6 06-07 19:41:08.894 26055-26055/com.example.demos I/songzheweiwang: [ViewGroupMiddle--&amp;gt;onTouchEvent]event=&lt;span&gt;ACTION_DOWN
 7 06-07 19:41:08.894 26055-26055/com.example.demos I/songzheweiwang: [ViewGroupOuter--&amp;gt;onTouchEvent]event=&lt;span&gt;ACTION_DOWN
 8 06-07 19:41:08.895 26055-26055/com.example.demos I/songzheweiwang: [EventDemoActivity--&amp;gt;onTouchEvent]event=&lt;span&gt;ACTION_DOWN
 9 06-07 19:41:08.900 26055-26055/com.example.demos I/songzheweiwang: [EventDemoActivity--&amp;gt;dispatchTouchEvent]ev=&lt;span&gt;ACTION_UP
10 06-07 19:41:08.901 26055-26055/com.example.demos I/songzheweiwang: [EventDemoActivity--&amp;gt;onTouchEvent]event=ACTION_UP&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;        事件在ViewGroupMiddle中被拦截了，事件不再派发到ViewInner中，而是交给自己的onTouchEvent来处理。前面说过，ViewGroupMiddle继承自RelativeLayout，默认是没有能力处理Touch事件的，于是就传递到上一级的onTouchEvent中，直到EventDemoActivity中的onTouchEvent方法。此时，在Boss看来，自己手下团队处理不了这类事件，所以后面的事件就不再传递下去，都有自己来处理。&lt;/p&gt;

&lt;p&gt;4、ViewGroupMiddle中onInterceptTouchEvent返回false，其它均返回默认值时&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201906/472002-20190607194737200-1274601665.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 1 06-07 19:48:58.130 26400-26400/com.example.demos I/songzheweiwang: [EventDemoActivity--&amp;gt;dispatchTouchEvent]ev=&lt;span&gt;ACTION_DOWN
 2 06-07 19:48:58.130 26400-26400/com.example.demos I/songzheweiwang: [ViewGroupOuter--&amp;gt;dispatchTouchEvent]ev=&lt;span&gt;ACTION_DOWN
 3 06-07 19:48:58.130 26400-26400/com.example.demos I/songzheweiwang: [ViewGroupOuter--&amp;gt;onInterceptTouchEvent]ev=&lt;span&gt;ACTION_DOWN
 4 06-07 19:48:58.130 26400-26400/com.example.demos I/songzheweiwang: [ViewGroupMiddle--&amp;gt;dispatchTouchEvent]ev=&lt;span&gt;ACTION_DOWN
 5 06-07 19:48:58.130 26400-26400/com.example.demos I/songzheweiwang: [ViewGroupMiddle--&amp;gt;onInterceptTouchEvent]ev=&lt;span&gt;ACTION_DOWN
 6 06-07 19:48:58.130 26400-26400/com.example.demos I/songzheweiwang: [ViewInner--&amp;gt;dispatchTouchEvent]event=&lt;span&gt;ACTION_DOWN
 7 06-07 19:48:58.131 26400-26400/com.example.demos I/songzheweiwang: [ViewInner--&amp;gt;onTouchEvent]event=&lt;span&gt;ACTION_DOWN
 8 06-07 19:48:58.131 26400-26400/com.example.demos I/songzheweiwang: [ViewGroupMiddle--&amp;gt;onTouchEvent]event=&lt;span&gt;ACTION_DOWN
 9 06-07 19:48:58.131 26400-26400/com.example.demos I/songzheweiwang: [ViewGroupOuter--&amp;gt;onTouchEvent]event=&lt;span&gt;ACTION_DOWN
10 06-07 19:48:58.131 26400-26400/com.example.demos I/songzheweiwang: [EventDemoActivity--&amp;gt;onTouchEvent]event=&lt;span&gt;ACTION_DOWN
11 06-07 19:48:58.162 26400-26400/com.example.demos I/songzheweiwang: [EventDemoActivity--&amp;gt;dispatchTouchEvent]ev=&lt;span&gt;ACTION_UP
12 06-07 19:48:58.162 26400-26400/com.example.demos I/songzheweiwang: [EventDemoActivity--&amp;gt;onTouchEvent]event=ACTION_UP&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       这种情况下，和使用默认super.onInterceptTouchEvent时是一样的，Log中中的日志也验证了这一点。事件派发流程在第三节中详细讲解过，这里就不再赘述了。&lt;/p&gt;

&lt;p&gt;5、ViewGroupMiddle中onTouchEvent为true，其它均返回默认值时&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201906/472002-20190607195755996-361596700.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 1 06-07 19:53:51.516 26711-26711/com.example.demos I/songzheweiwang: [EventDemoActivity--&amp;gt;dispatchTouchEvent]ev=&lt;span&gt;ACTION_DOWN
 2 06-07 19:53:51.517 26711-26711/com.example.demos I/songzheweiwang: [ViewGroupOuter--&amp;gt;dispatchTouchEvent]ev=&lt;span&gt;ACTION_DOWN
 3 06-07 19:53:51.517 26711-26711/com.example.demos I/songzheweiwang: [ViewGroupOuter--&amp;gt;onInterceptTouchEvent]ev=&lt;span&gt;ACTION_DOWN
 4 06-07 19:53:51.517 26711-26711/com.example.demos I/songzheweiwang: [ViewGroupMiddle--&amp;gt;dispatchTouchEvent]ev=&lt;span&gt;ACTION_DOWN
 5 06-07 19:53:51.517 26711-26711/com.example.demos I/songzheweiwang: [ViewGroupMiddle--&amp;gt;onInterceptTouchEvent]ev=&lt;span&gt;ACTION_DOWN
 6 06-07 19:53:51.517 26711-26711/com.example.demos I/songzheweiwang: [ViewInner--&amp;gt;dispatchTouchEvent]event=&lt;span&gt;ACTION_DOWN
 7 06-07 19:53:51.517 26711-26711/com.example.demos I/songzheweiwang: [ViewInner--&amp;gt;onTouchEvent]event=&lt;span&gt;ACTION_DOWN
 8 06-07 19:53:51.517 26711-26711/com.example.demos I/songzheweiwang: [ViewGroupMiddle--&amp;gt;onTouchEvent]event=&lt;span&gt;ACTION_DOWN
 9 06-07 19:53:51.582 26711-26711/com.example.demos I/songzheweiwang: [EventDemoActivity--&amp;gt;dispatchTouchEvent]ev=&lt;span&gt;ACTION_UP
10 06-07 19:53:51.583 26711-26711/com.example.demos I/songzheweiwang: [ViewGroupOuter--&amp;gt;dispatchTouchEvent]ev=&lt;span&gt;ACTION_UP
11 06-07 19:53:51.583 26711-26711/com.example.demos I/songzheweiwang: [ViewGroupOuter--&amp;gt;onInterceptTouchEvent]ev=&lt;span&gt;ACTION_UP
12 06-07 19:53:51.583 26711-26711/com.example.demos I/songzheweiwang: [ViewGroupMiddle--&amp;gt;dispatchTouchEvent]ev=&lt;span&gt;ACTION_UP
13 06-07 19:53:51.583 26711-26711/com.example.demos I/songzheweiwang: [ViewGroupMiddle--&amp;gt;onTouchEvent]event=ACTION_UP&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;        事件依次传递到ViewInner的onTouchEvent方法中，ViewInner默认没有能力处理该事件，传递到上一级ViewGroupMiddle中的onTouchEvent来处理。返回true表示被处理了，本次事件在此中止了。在Boss看来，手下团队有能力处理这类事件，且在ViewGroupMiddle的onTouchEvent中完成，说明ViewInner没有能力处理，所以下一个事件ACTION_UP时，ViewGroupMiddle就没有把事件派发到ViewInner中，而是直接给自己的onTouchEvent方法中来处理。&lt;/p&gt;

&lt;p&gt;  5、ViewGroupMiddle中onTouchEvent为false，其它均返回默认值时&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201906/472002-20190607201041763-861468756.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 1 06-07 20:09:49.746 27357-27357/com.example.demos I/songzheweiwang: [EventDemoActivity--&amp;gt;dispatchTouchEvent]ev=&lt;span&gt;ACTION_DOWN
 2 06-07 20:09:49.746 27357-27357/com.example.demos I/songzheweiwang: [ViewGroupOuter--&amp;gt;dispatchTouchEvent]ev=&lt;span&gt;ACTION_DOWN
 3 06-07 20:09:49.746 27357-27357/com.example.demos I/songzheweiwang: [ViewGroupOuter--&amp;gt;onInterceptTouchEvent]ev=&lt;span&gt;ACTION_DOWN
 4 06-07 20:09:49.746 27357-27357/com.example.demos I/songzheweiwang: [ViewGroupMiddle--&amp;gt;dispatchTouchEvent]ev=&lt;span&gt;ACTION_DOWN
 5 06-07 20:09:49.746 27357-27357/com.example.demos I/songzheweiwang: [ViewGroupMiddle--&amp;gt;onInterceptTouchEvent]ev=&lt;span&gt;ACTION_DOWN
 6 06-07 20:09:49.746 27357-27357/com.example.demos I/songzheweiwang: [ViewInner--&amp;gt;dispatchTouchEvent]event=&lt;span&gt;ACTION_DOWN
 7 06-07 20:09:49.746 27357-27357/com.example.demos I/songzheweiwang: [ViewInner--&amp;gt;onTouchEvent]event=&lt;span&gt;ACTION_DOWN
 8 06-07 20:09:49.746 27357-27357/com.example.demos I/songzheweiwang: [ViewGroupMiddle--&amp;gt;onTouchEvent]event=&lt;span&gt;ACTION_DOWN
 9 06-07 20:09:49.747 27357-27357/com.example.demos I/songzheweiwang: [ViewGroupOuter--&amp;gt;onTouchEvent]event=&lt;span&gt;ACTION_DOWN
10 06-07 20:09:49.747 27357-27357/com.example.demos I/songzheweiwang: [EventDemoActivity--&amp;gt;onTouchEvent]event=&lt;span&gt;ACTION_DOWN
11 06-07 20:09:49.803 27357-27357/com.example.demos I/songzheweiwang: [EventDemoActivity--&amp;gt;dispatchTouchEvent]ev=&lt;span&gt;ACTION_UP
12 06-07 20:09:49.803 27357-27357/com.example.demos I/songzheweiwang: [EventDemoActivity--&amp;gt;onTouchEvent]event=ACTION_UP&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;        这里在activity_event_demo.xml中使用ViewGroupMiddle时添加[android:clickable=&quot;true&quot;]，将ViewGroupMiddle设置为默认可以处理Touch事件。当设置为false值时，从日志来看，表明ViewGroupMiddle中确实没有处理事件，而是传给了上级。&lt;/p&gt;

&lt;p&gt;  6， 均为默认值时&lt;/p&gt;
&lt;p&gt;       当ViewGroupMiddle中onTouchEvent返回默认的super.onTouchEvent时，我们在第三节中分析过ViewInner有能处理和没有能力处理两种情况下的事件处理逻辑，这里笔者不再赘述。现在还有一个结论需要读者验证，就是都在返回默认super.xxx情况下，可以在ViewGroupMiddle中onTouchEvent方法中打印出super.onTouchEvent的值。可以发现，如果ViewGroupMiddle中onTouchEvent方法可以处理事件，则值为true，如果没有处理Touch事件的能力，则会返回false。这一点在第四节中讲过。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;六、当触摸其它区域时分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        在前面分析打印log结果的时候，笔者都着重强调了要点击正中心的ViewInner。这是因为点击不同的区域，会产生不同的逻辑处理结果。那么点击区域和事件分发结果有什么样的关系呢？下面将第三节中的例子，3个主要方法都返回默认的super.xxx方法，由外到内依次点击Boss，PM，Team Leader，Programmer四个区域。得到了如下的log信息：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 1 06-07 20:27:44.390 28523-28523/com.example.demos I/songzheweiwang: [EventDemoActivity--&amp;gt;dispatchTouchEvent]ev=&lt;span&gt;ACTION_DOWN
 2 06-07 20:27:44.391 28523-28523/com.example.demos I/songzheweiwang: [EventDemoActivity--&amp;gt;onTouchEvent]event=&lt;span&gt;ACTION_DOWN
 3 06-07 20:27:44.405 28523-28523/com.example.demos I/songzheweiwang: [EventDemoActivity--&amp;gt;dispatchTouchEvent]ev=&lt;span&gt;ACTION_UP
 4 06-07 20:27:44.405 28523-28523/com.example.demos I/songzheweiwang: [EventDemoActivity--&amp;gt;onTouchEvent]event=&lt;span&gt;ACTION_UP
 5 
 6 06-07 20:27:48.298 28523-28523/com.example.demos I/songzheweiwang: [EventDemoActivity--&amp;gt;dispatchTouchEvent]ev=&lt;span&gt;ACTION_DOWN
 7 06-07 20:27:48.299 28523-28523/com.example.demos I/songzheweiwang: [ViewGroupOuter--&amp;gt;dispatchTouchEvent]ev=&lt;span&gt;ACTION_DOWN
 8 06-07 20:27:48.299 28523-28523/com.example.demos I/songzheweiwang: [ViewGroupOuter--&amp;gt;onInterceptTouchEvent]ev=&lt;span&gt;ACTION_DOWN
 9 06-07 20:27:48.299 28523-28523/com.example.demos I/songzheweiwang: [ViewGroupOuter--&amp;gt;onTouchEvent]event=&lt;span&gt;ACTION_DOWN
10 06-07 20:27:48.299 28523-28523/com.example.demos I/songzheweiwang: [EventDemoActivity--&amp;gt;onTouchEvent]event=&lt;span&gt;ACTION_DOWN
11 06-07 20:27:48.338 28523-28523/com.example.demos I/songzheweiwang: [EventDemoActivity--&amp;gt;dispatchTouchEvent]ev=&lt;span&gt;ACTION_UP
12 06-07 20:27:48.339 28523-28523/com.example.demos I/songzheweiwang: [EventDemoActivity--&amp;gt;onTouchEvent]event=&lt;span&gt;ACTION_UP
13 
14 06-07 20:27:52.681 28523-28523/com.example.demos I/songzheweiwang: [EventDemoActivity--&amp;gt;dispatchTouchEvent]ev=&lt;span&gt;ACTION_DOWN
15 06-07 20:27:52.681 28523-28523/com.example.demos I/songzheweiwang: [ViewGroupOuter--&amp;gt;dispatchTouchEvent]ev=&lt;span&gt;ACTION_DOWN
16 06-07 20:27:52.681 28523-28523/com.example.demos I/songzheweiwang: [ViewGroupOuter--&amp;gt;onInterceptTouchEvent]ev=&lt;span&gt;ACTION_DOWN
17 06-07 20:27:52.681 28523-28523/com.example.demos I/songzheweiwang: [ViewGroupMiddle--&amp;gt;dispatchTouchEvent]ev=&lt;span&gt;ACTION_DOWN
18 06-07 20:27:52.681 28523-28523/com.example.demos I/songzheweiwang: [ViewGroupMiddle--&amp;gt;onInterceptTouchEvent]ev=&lt;span&gt;ACTION_DOWN
19 06-07 20:27:52.682 28523-28523/com.example.demos I/songzheweiwang: [ViewGroupMiddle--&amp;gt;onTouchEvent]event=&lt;span&gt;ACTION_DOWN
20 06-07 20:27:52.682 28523-28523/com.example.demos I/songzheweiwang: [ViewGroupOuter--&amp;gt;onTouchEvent]event=&lt;span&gt;ACTION_DOWN
21 06-07 20:27:52.682 28523-28523/com.example.demos I/songzheweiwang: [EventDemoActivity--&amp;gt;onTouchEvent]event=&lt;span&gt;ACTION_DOWN
22 06-07 20:27:52.749 28523-28523/com.example.demos I/songzheweiwang: [EventDemoActivity--&amp;gt;dispatchTouchEvent]ev=&lt;span&gt;ACTION_UP
23 06-07 20:27:52.749 28523-28523/com.example.demos I/songzheweiwang: [EventDemoActivity--&amp;gt;onTouchEvent]event=&lt;span&gt;ACTION_UP
24 
25 06-07 20:27:57.448 28523-28523/com.example.demos I/songzheweiwang: [EventDemoActivity--&amp;gt;dispatchTouchEvent]ev=&lt;span&gt;ACTION_DOWN
26 06-07 20:27:57.449 28523-28523/com.example.demos I/songzheweiwang: [ViewGroupOuter--&amp;gt;dispatchTouchEvent]ev=&lt;span&gt;ACTION_DOWN
27 06-07 20:27:57.449 28523-28523/com.example.demos I/songzheweiwang: [ViewGroupOuter--&amp;gt;onInterceptTouchEvent]ev=&lt;span&gt;ACTION_DOWN
28 06-07 20:27:57.449 28523-28523/com.example.demos I/songzheweiwang: [ViewGroupMiddle--&amp;gt;dispatchTouchEvent]ev=&lt;span&gt;ACTION_DOWN
29 06-07 20:27:57.449 28523-28523/com.example.demos I/songzheweiwang: [ViewGroupMiddle--&amp;gt;onInterceptTouchEvent]ev=&lt;span&gt;ACTION_DOWN
30 06-07 20:27:57.449 28523-28523/com.example.demos I/songzheweiwang: [ViewInner--&amp;gt;dispatchTouchEvent]event=&lt;span&gt;ACTION_DOWN
31 06-07 20:27:57.449 28523-28523/com.example.demos I/songzheweiwang: [ViewInner--&amp;gt;onTouchEvent]event=&lt;span&gt;ACTION_DOWN
32 06-07 20:27:57.449 28523-28523/com.example.demos I/songzheweiwang: [ViewGroupMiddle--&amp;gt;onTouchEvent]event=&lt;span&gt;ACTION_DOWN
33 06-07 20:27:57.449 28523-28523/com.example.demos I/songzheweiwang: [ViewGroupOuter--&amp;gt;onTouchEvent]event=&lt;span&gt;ACTION_DOWN
34 06-07 20:27:57.450 28523-28523/com.example.demos I/songzheweiwang: [EventDemoActivity--&amp;gt;onTouchEvent]event=&lt;span&gt;ACTION_DOWN
35 06-07 20:27:57.514 28523-28523/com.example.demos I/songzheweiwang: [EventDemoActivity--&amp;gt;dispatchTouchEvent]ev=&lt;span&gt;ACTION_UP
36 06-07 20:27:57.515 28523-28523/com.example.demos I/songzheweiwang: [EventDemoActivity--&amp;gt;onTouchEvent]event=ACTION_UP&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 这四次触摸事件的日志结果用空格隔开，分析该log可以发现：当点击Boss区域时，里面的三个控件均未触发事件；当点击PM区域时，Team Leader和Programmer中的没有任何动作；点击Team Leader区域时，只有Programmer没有触发任何事件；当点击Programmer区域时，4个角色均被触发。那么这个结论就很显而易见了：当点击到View系统的某一层时，事件从外往内传递时，只到被点击的那一层为止，不会再派发到其子View中。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;结语&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       到目前为止，Android的事件分发和传递机制就分析完了。本文中Touch事件的3个主要方法返回值均有3种情形，所以会有多种逻辑处理组合。这里选取了中间层ViewGroupMiddle来举例，只是作为代表来分析，笔者完全可以通过其它的组合来分析更多的可能情况。如果分析中有不妥当或者不准确的地方，欢迎来拍砖。&lt;/p&gt;

</description>
<pubDate>Fri, 07 Jun 2019 13:02:00 +0000</pubDate>
<dc:creator>宋者为王</dc:creator>
<og:description>在自定义View中，经常需要处理Android事件分发的问题，尤其在有多个输入设备（如遥控、鼠标、游戏手柄等）时，事件处理问题尤为突出。Android事件分发机制，一直以来都是一个让众多开发者困扰的难</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/andy-songwei/p/10989172.html</dc:identifier>
</item>
<item>
<title>Mysql安装与配置_win10 - Zander_Zhao</title>
<link>http://www.cnblogs.com/ZanderZhao/p/10988895.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ZanderZhao/p/10988895.html</guid>
<description>&lt;h2&gt;1.1下载地址&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://downloads.mysql.com/archives/community/&quot; target=&quot;_blank&quot;&gt;下载地址  https://downloads.mysql.com/archives/community/&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;1.2 选择适合自己的版本并下载&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1427277/201906/1427277-20190607183737828-598785747.bmp&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;1.3 将下载文件解压至自定义路径&lt;/h2&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1427277/201906/1427277-20190607183834930-955626590.bmp&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;1.4 添加配置文件&lt;/h2&gt;
&lt;p&gt;在解压的路径下查看是否含有my.ini的文件，如果没有则新建一个，&lt;/p&gt;
&lt;p&gt;具体步骤为&lt;/p&gt;
&lt;p&gt;1.新建一个txt，&lt;/p&gt;
&lt;p&gt;2.重命名为my.ini，注意连扩展名一起改&lt;/p&gt;
&lt;p&gt;3.用记事本打开my.ini&lt;/p&gt;
&lt;p&gt;4.将下面内容复制到里面，并保存关闭，注意里面自定义路径要更改&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[&lt;/span&gt;&lt;span&gt;mysqld&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;
# 设置3306端口
port&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;3306&lt;/span&gt;&lt;span&gt;
# 设置mysql的安装目录
basedir&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;C:\IDE\mysql&lt;span&gt;-&lt;/span&gt;&lt;span&gt;5.7&lt;/span&gt;.&lt;span&gt;26&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;winx64
# 设置mysql数据库的数据的存放目录
datadir&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;C:\IDE\mysql&lt;span&gt;-&lt;/span&gt;&lt;span&gt;5.7&lt;/span&gt;.&lt;span&gt;26&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;winx64\data
# 允许最大连接数
max_connections&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;200&lt;/span&gt;&lt;span&gt;
# 允许连接失败的次数。这是为了防止有人从该主机试图攻击数据库系统
max_connect_errors&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;
# 服务端使用的字符集默认为UTF8
&lt;/span&gt;&lt;span&gt;character&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;server&lt;span&gt;=&lt;/span&gt;&lt;span&gt;utf8
# 创建新表时将使用的默认存储引擎
&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;storage&lt;span&gt;-&lt;/span&gt;engine&lt;span&gt;=&lt;/span&gt;&lt;span&gt;INNODB
# 默认使用“mysql_native_password”插件认证
default_authentication_plugin&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;mysql_native_password
&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;mysql&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;
# 设置mysql客户端默认字符集
&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;character&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;utf8
&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;client&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;
# 设置mysql客户端连接服务端时默认使用的端口
port&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;3306&lt;/span&gt;
&lt;span&gt;default&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;character&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;utf8
&lt;/pre&gt;&lt;/div&gt;

&lt;hr/&gt;&lt;hr/&gt;
&lt;h2&gt;2.1复制路径&lt;/h2&gt;
&lt;p&gt;进入解压目录下的bin目录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1427277/201906/1427277-20190607175535487-2104986886.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;右击复制&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1427277/201906/1427277-20190607183923774-1178836681.bmp&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;2.2 配置环境变量&lt;/h2&gt;
&lt;p&gt;打开控制面板--系统--高级系统设置--环境变量--找到系统变量（S）中的path变量---编辑--新建---control+V---确定---确定&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1427277/201906/1427277-20190607184005412-190063981.bmp&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;hr/&gt;&lt;hr/&gt;
&lt;p&gt;如果没进行2则要进行3.1&lt;/p&gt;
&lt;h2&gt;3.1 进入bin目录&lt;/h2&gt;
&lt;p&gt;以管理员进入dos界面，切换到解压的bin目录下，&lt;/p&gt;
&lt;p&gt;具体操作：鼠标移到左下角--搜索命令提示符---右击以管理员身份运行&lt;/p&gt;
&lt;p&gt;输入cd 自定义路径   如： cd C:\IDE\mysql-5.7.26-winx64\bin&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1427277/201906/1427277-20190607184026948-775142496.bmp&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;3.2  输入mysqld install&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1427277/201906/1427277-20190607185928716-1302179484.bmp&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3.2.1 修复&lt;/h3&gt;
&lt;p&gt;显示下图，&lt;a href=&quot;https://blog.csdn.net/vbcom/article/details/7245186&quot; target=&quot;_blank&quot;&gt;点此下载DirectX修复工具增强版&lt;/a&gt;，然后修复，然后进行3.2.2&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1427277/201906/1427277-20190607190107794-804539231.bmp&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3.2.1如果显示下图，到这一步表示安装成功&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1427277/201906/1427277-20190607190422823-460672209.bmp&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;3.3 输入mysqld --initialize --console 初始化&lt;/h3&gt;
&lt;p&gt;其中标红的为数据库root用户的初始密码，一定要牢记，后面登录需要用到，&lt;/p&gt;
&lt;p&gt;要是不小心关掉了或者没记住，删掉初始化的 data目录，再执行一遍初始化命令又会重新生成。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1427277/201906/1427277-20190607191456940-2123735104.bmp&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt; 3.4输入mysqld --install安装mysql服务&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1427277/201906/1427277-20190607193752177-437015496.bmp&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3.5输入net start mysql启动服务&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1427277/201906/1427277-20190607193856008-1215246609.bmp&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;备注：mysqld --remove是卸载MySQL服务，net stop mysql是停止服务。&lt;/p&gt;

&lt;hr/&gt;&lt;hr/&gt;

&lt;h2&gt;4.1进入&lt;/h2&gt;
&lt;p&gt;输入mysql -u root -p后会让你输入密码，密码为前面让你记住的密码，输入正确后就会出现如下界面，表示进入了MySQL命令模式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1427277/201906/1427277-20190607195115411-103801836.bmp&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;4.2 更改密码&lt;/h2&gt;
&lt;p&gt;接着更改密码，输入&lt;/p&gt;
&lt;p&gt;ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '123456'; &lt;/p&gt;
&lt;p&gt;其中123456为新密码，出现如下界面表示更改成功。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1427277/201906/1427277-20190607195450977-1857094045.bmp&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 至此安装完成&lt;/p&gt;

&lt;hr/&gt;&lt;hr/&gt;

&lt;h2&gt;5.1连接本地数据库&lt;/h2&gt;
&lt;h3&gt;5.1.1下载并打开navicat&lt;/h3&gt;
&lt;p&gt;按照下图配置，密码为4.2步设置的mysql密码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1427277/201906/1427277-20190607201423891-2127720078.bmp&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;5.1.2再次双击变成绿色即连接上&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1427277/201906/1427277-20190607201554301-1454074506.bmp&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;5.2 连接云端数据库&lt;/h2&gt;
&lt;h3&gt;5.2.1服务器端设置&lt;/h3&gt;
&lt;p&gt;对数据库进行远程登录的授权，这时我们可以进入服务器后台，在MySQL命令行中输入以下命令&lt;br/&gt;GRANT ALL PRIVILEGES ON *.* TO 'myuser'@'%' IDENTIFIED BY 'mypassword' WITH GRANT OPTION;&lt;br/&gt;myuser 改为你的数据库用户名 一般为root&lt;br/&gt;mypassword 改为数据库登录密码&lt;/p&gt;
&lt;h3&gt;5.2.2直接使用IP进行连接&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1427277/201906/1427277-20190607203318800-19715439.bmp&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1427277/201906/1427277-20190607203331265-1213072202.bmp&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;hr/&gt;&lt;hr/&gt;


&lt;h2&gt;6.1 停止MySQL服务&lt;/h2&gt;
&lt;p&gt;开始-》所有应用-》Windows管理工具-》服务，将MySQL服务停止&lt;/p&gt;
&lt;h2&gt;&lt;br/&gt;6.2 卸载mysql server&lt;/h2&gt;
&lt;p&gt;控制面板\所有控制面板项\程序和功能，将mysql server卸载掉&lt;/p&gt;
&lt;h2&gt;&lt;br/&gt;6.3 将MySQL安装目录下的MySQL文件夹删除&lt;/h2&gt;
&lt;h2&gt;&lt;br/&gt;6.4 运行“regedit”文件，打开注册表&lt;/h2&gt;
&lt;p&gt;删除HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\Eventlog\Application\MySQL文件夹&lt;br/&gt;删除HKEY_LOCAL_MACHINE\SYSTEM\ControlSet002\Services\Eventlog\Application\MySQL文件夹&lt;br/&gt;删除HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Eventlog\Application\MySQL的文件夹&lt;br/&gt;如果没有相应的文件夹，就不用删除了&lt;/p&gt;
&lt;h2&gt;&lt;br/&gt;6.5 删除C盘下的“C:\ProgramData\MySQL ”文件夹&lt;/h2&gt;
&lt;p&gt;该programData文件默认是隐藏的，设置显示后即可见&lt;/p&gt;
&lt;p&gt;或者直接复制 C:\ProgramData 到地址栏回车即可进入&lt;/p&gt;
&lt;p&gt;将整个MySQL文件夹删除掉&lt;/p&gt;

&lt;h2&gt;6.6 删除服务&lt;/h2&gt;
&lt;p&gt;如果已经将MySQL卸载，但通过“开始-》所有应用-》Windows管理工具-》服务”查看到MySQL服务仍然残留在系统服务里&lt;br/&gt;只要在CMD里输入一条命令就可以将服务删除：&lt;br/&gt;sc delete mysql    //这里的mysql是你要删除的服务名&lt;/p&gt;
&lt;p&gt;mysqld --remove  //也可卸载服务&lt;br/&gt;服务就被删除了&lt;/p&gt;
&lt;p&gt;卸载完成&lt;/p&gt;


&lt;p&gt;参考&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/missing2011/article/details/81474857&quot; target=&quot;_blank&quot;&gt;配置1：https://blog.csdn.net/missing2011/article/details/81474857&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/sunboy520555/article/details/80918407&quot; target=&quot;_blank&quot;&gt;配置2：https://blog.csdn.net/sunboy520555/article/details/80918407&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/sinat_36306474/article/details/82084049&quot; target=&quot;_blank&quot;&gt;远程1：https://blog.csdn.net/sinat_36306474/article/details/82084049&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.2cto.com/database/201702/594659.html&quot; target=&quot;_blank&quot;&gt;远程2：https://www.2cto.com/database/201702/594659.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/liuhailiuhai12/article/details/64124637&quot; target=&quot;_blank&quot;&gt;远程3：https://blog.csdn.net/liuhailiuhai12/article/details/64124637&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jb51.net/article/42441.htm&quot; target=&quot;_blank&quot;&gt;远程4：https://www.jb51.net/article/42441.htm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/jpfss/p/6652701.html&quot; target=&quot;_blank&quot;&gt;卸载1：https://www.cnblogs.com/jpfss/p/6652701.html&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 07 Jun 2019 13:00:00 +0000</pubDate>
<dc:creator>Zander_Zhao</dc:creator>
<og:description>1 下载 1.1下载地址 下载地址 https://downloads.mysql.com/archives/community/ 1.2 选择适合自己的版本并下载 1.3 将下载文件解压至自定义路径</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ZanderZhao/p/10988895.html</dc:identifier>
</item>
<item>
<title>基于opencv 识别、定位二维码 （c++版） - 源之缘</title>
<link>http://www.cnblogs.com/yuanchenhui/p/opencv_qr.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuanchenhui/p/opencv_qr.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/span&gt; 因工作需要，需要定位图片中的二维码；我遂查阅了相关资料，也学习了opencv开源库。通过一番努力，终于很好的实现了二维码定位。本文将讲解如何使用opencv定位二维码。&lt;/p&gt;
&lt;p&gt;定位二维码不仅仅是为了识别二维码；还可以通过二维码对图像进行水平纠正以及相邻区域定位。定位二维码，不仅需要图像处理相关知识，还需要分析二维码的特性，本文先从二维码的特性讲起。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;1 二维码特性&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;二维码在设计之初就考虑到了识别问题，所以二维码有一些特征是非常明显的。&lt;/p&gt;
&lt;p&gt;二维码有三个“回“”字形图案，这一点非常明显。中间的一个点位于图案的左上角，如果图像偏转，也可以根据二维码来纠正。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/245753/201906/245753-20190607193711542-878353158.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;思考题：&lt;/strong&gt;&lt;/span&gt;为什么是三个点，而不是一个、两个或四个点。&lt;/p&gt;
&lt;p&gt;一个点：特征不明显，不易定位。不易定位二维码倾斜角度。&lt;/p&gt;
&lt;p&gt;两个点：两个点的次序无法确认，很难确定二维码是否放正了。&lt;/p&gt;
&lt;p&gt;四个点：无法确定4个点的次序，从而无法确定二维码是否放正了。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;识别二维码，就是识别二维码的三个点，逐步分析一下这三个点的特性&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 1 每个点有两个轮廓。就是两个口，大“口”内部有一个小“口”，所以是两个轮廓。&lt;/p&gt;
&lt;p&gt; 2 如果把这个“回”放到一个白色的背景下，从左到右，或从上到下画一条线。这条线经过的图案黑白比例大约为：黑白比例为1:1:3:1:1。&lt;/p&gt;
&lt;p&gt; 3 如何找到左上角的顶点？这个顶点与其他两个顶点的夹角为90度。&lt;/p&gt;
&lt;p&gt;通过上面几个步骤，就能识别出二维码的三个顶点，并且识别出左上角的顶点。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2 使用opencv识别二维码&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 1) 查找轮廓,筛选出三个二维码顶点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;opencv一个非常重要的函数就是查找轮廓，就是可以找到一个图中的缩所有的轮廓，“回”字形图案是一个非常的明显的轮廓，很容易找到。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; QrParse::FindQrPoint(Mat&amp;amp; srcImg, vector&amp;lt;vector&amp;lt;Point&amp;gt;&amp;gt;&amp;amp;&lt;span&gt; qrPoint)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;彩色图转灰度图&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    Mat src_gray;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    cvtColor(srcImg, src_gray, CV_BGR2GRAY);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     namedWindow(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;src_gray&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     imshow(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;src_gray&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, src_gray);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;二值化&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    Mat threshold_output;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     threshold(src_gray, threshold_output, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;255&lt;/span&gt;, THRESH_BINARY |&lt;span&gt; THRESH_OTSU);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     Mat threshold_output_copy =&lt;span&gt; threshold_output.clone();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     namedWindow(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Threshold_output&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     imshow(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Threshold_output&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, threshold_output);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用查找轮廓函数&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;     vector&amp;lt;vector&amp;lt;Point&amp;gt; &amp;gt;&lt;span&gt; contours;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     vector&amp;lt;Vec4i&amp;gt;&lt;span&gt; hierarchy;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     findContours(threshold_output, contours, hierarchy, CV_RETR_TREE, CHAIN_APPROX_NONE, Point(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过黑色定位角作为父轮廓，有两个子轮廓的特点，筛选出三个定位角&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; parentIdx = -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; ic = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; contours.size(); i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (hierarchy[i][&lt;span&gt;2&lt;/span&gt;] != -&lt;span&gt;1&lt;/span&gt; &amp;amp;&amp;amp; ic == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             parentIdx =&lt;span&gt; i;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             ic++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (hierarchy[i][&lt;span&gt;2&lt;/span&gt;] != -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             ic++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (hierarchy[i][&lt;span&gt;2&lt;/span&gt;] == -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;             ic = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;             parentIdx = -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; 
&lt;span&gt;43&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;有两个子轮廓才是二维码的顶点&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (ic &amp;gt;= &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;             &lt;span&gt;bool&lt;/span&gt; isQr =&lt;span&gt; QrParse::IsQrPoint(contours[parentIdx], threshold_output_copy);
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; 
&lt;span&gt;48&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存找到的三个黑色定位角&lt;/span&gt;
&lt;span&gt;49&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isQr)
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;                qrPoint.push_back(contours[parentIdx]);
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; 
&lt;span&gt;52&lt;/span&gt;             ic = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;             parentIdx = -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; 
&lt;span&gt;57&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;找到了两个轮廓的图元，需要进一步分析是不是二维码顶点，用到如下函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;bool&lt;/span&gt; QrParse::IsQrPoint(vector&amp;lt;Point&amp;gt;&amp;amp; contour, Mat&amp;amp;&lt;span&gt; img)
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;最小大小限定&lt;/span&gt;
    RotatedRect rotatedRect =&lt;span&gt; minAreaRect(contour);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (rotatedRect.size.height &amp;lt; &lt;span&gt;10&lt;/span&gt; || rotatedRect.size.width &amp;lt; &lt;span&gt;10&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将二维码从整个图上抠出来&lt;/span&gt;
    cv::Mat cropImg =&lt;span&gt; CropImage(img, rotatedRect);
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; flag = i++&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;横向黑白比例1:1:3:1:1&lt;/span&gt;
    &lt;span&gt;bool&lt;/span&gt; result =&lt;span&gt; IsQrColorRate(cropImg, flag);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;黑白比例判断函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;横向和纵向黑白比例判断&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; QrParse::IsQrColorRate(cv::Mat&amp;amp; image, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; flag)
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt;     &lt;span&gt;bool&lt;/span&gt; x =&lt;span&gt; IsQrColorRateX(image, flag);
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;x)
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt;     &lt;span&gt;bool&lt;/span&gt; y =&lt;span&gt; IsQrColorRateY(image, flag);
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; y;
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;横向黑白比例判断&lt;/span&gt;
&lt;span&gt; 11&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; QrParse::IsQrColorRateX(cv::Mat&amp;amp; image, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; flag)
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; nr = image.rows / &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; nc = image.cols *&lt;span&gt; image.channels();
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt; 
&lt;span&gt; 16&lt;/span&gt;     vector&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt; vValueCount;
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt;     vector&amp;lt;uchar&amp;gt;&lt;span&gt; vColor;
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; count = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt;     uchar lastColor = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; 
&lt;span&gt; 21&lt;/span&gt;     uchar* data = image.ptr&amp;lt;uchar&amp;gt;&lt;span&gt;(nr);
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; nc; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt; &lt;span&gt;        vColor.push_back(data[i]);
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt;         uchar color =&lt;span&gt; data[i];
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (color &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt;             color = &lt;span&gt;255&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt; 
&lt;span&gt; 29&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (i == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt;             lastColor =&lt;span&gt; color;
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt;             count++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;
&lt;span&gt; 35&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (lastColor !=&lt;span&gt; color)
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt; &lt;span&gt;                vValueCount.push_back(count);
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt;                 count = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt;             count++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt;             lastColor =&lt;span&gt; color;
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt; 
&lt;span&gt; 46&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (count != &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt; &lt;span&gt;        vValueCount.push_back(count);
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt; 
&lt;span&gt; 49&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (vValueCount.size() &amp;lt; &lt;span&gt;5&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt; 
&lt;span&gt; 52&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;横向黑白比例1:1:3:1:1&lt;/span&gt;
&lt;span&gt; 53&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; index = -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; maxCount = -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; vValueCount.size(); i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (i == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt;             index =&lt;span&gt; i;
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt;             maxCount =&lt;span&gt; vValueCount[i];
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;
&lt;span&gt; 63&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (vValueCount[i] &amp;gt;&lt;span&gt; maxCount)
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt;                 index =&lt;span&gt; i;
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt;                 maxCount =&lt;span&gt; vValueCount[i];
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt; 
&lt;span&gt; 72&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;左边 右边 都有两个值，才行&lt;/span&gt;
&lt;span&gt; 73&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (index &amp;lt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; ((vValueCount.size() - index) &amp;lt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt; 
&lt;span&gt; 78&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;黑白比例1:1:3:1:1&lt;/span&gt;
&lt;span&gt; 79&lt;/span&gt;     &lt;span&gt;float&lt;/span&gt; rate = ((&lt;span&gt;float&lt;/span&gt;)maxCount) / &lt;span&gt;3.00&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt; 
&lt;span&gt; 81&lt;/span&gt;     cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;flag:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; flag &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt; 
&lt;span&gt; 83&lt;/span&gt;     &lt;span&gt;float&lt;/span&gt; rate2 = vValueCount[index - &lt;span&gt;2&lt;/span&gt;] /&lt;span&gt; rate;
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt;     cout &amp;lt;&amp;lt; rate2 &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;IsQrRate(rate2))
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt; 
&lt;span&gt; 88&lt;/span&gt;     rate2 = vValueCount[index - &lt;span&gt;1&lt;/span&gt;] /&lt;span&gt; rate;
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt;     cout &amp;lt;&amp;lt; rate2 &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;IsQrRate(rate2))
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt; 
&lt;span&gt; 93&lt;/span&gt;     rate2 = vValueCount[index + &lt;span&gt;1&lt;/span&gt;] /&lt;span&gt; rate;
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt;     cout &amp;lt;&amp;lt; rate2 &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;IsQrRate(rate2))
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt; 
&lt;span&gt; 98&lt;/span&gt;     rate2 = vValueCount[index + &lt;span&gt;2&lt;/span&gt;] /&lt;span&gt; rate;
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;     cout &amp;lt;&amp;lt; rate2 &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;IsQrRate(rate2))
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt; 
&lt;span&gt;103&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;纵向黑白比例判断 省略&lt;/span&gt;
&lt;span&gt;106&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; QrParse::IsQrColorRateY(cv::Mat&amp;amp; image, &lt;span&gt;int&lt;/span&gt; flag)
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;bool&lt;/span&gt; QrParse::IsQrRate(&lt;span&gt;float&lt;/span&gt;&lt;span&gt; rate)
{
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;大概比例 不能太严格&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; rate &amp;gt; &lt;span&gt;0.6&lt;/span&gt; &amp;amp;&amp;amp; rate &amp;lt; &lt;span&gt;1.9&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;2） 确定三个二维码顶点的次序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 通过如下原则确定左上角顶点：二维码左上角的顶点与其他两个顶点的夹角为90度。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; pointDest存放调整后的三个点，三个点的顺序如下
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; pt0----pt1
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;//&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; pt2&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; QrParse::AdjustQrPoint(Point* pointSrc, Point*&lt;span&gt; pointDest)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; clockwise;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; index1[&lt;span&gt;3&lt;/span&gt;] = { &lt;span&gt;2&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;&lt;span&gt; };
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; index2[&lt;span&gt;3&lt;/span&gt;] = { &lt;span&gt;0&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;&lt;span&gt; };
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; index3[&lt;span&gt;3&lt;/span&gt;] = { &lt;span&gt;0&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;&lt;span&gt; };
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;3&lt;/span&gt;; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; *n =&lt;span&gt; index1;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(i==&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             n =&lt;span&gt; index1;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (i == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             n =&lt;span&gt; index2;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;             n =&lt;span&gt; index3;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;double&lt;/span&gt; angle = QrParse::Angle(pointSrc[n[&lt;span&gt;0&lt;/span&gt;]], pointSrc[n[&lt;span&gt;1&lt;/span&gt;]], pointSrc[n[&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]], clockwise);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (angle &amp;gt; &lt;span&gt;80&lt;/span&gt; &amp;amp;&amp;amp; angle &amp;lt; &lt;span&gt;99&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             pointDest[&lt;span&gt;0&lt;/span&gt;] = pointSrc[n[&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]];
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (clockwise)
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                 pointDest[&lt;span&gt;1&lt;/span&gt;] = pointSrc[n[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]];
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;                 pointDest[&lt;span&gt;2&lt;/span&gt;] = pointSrc[n[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]];
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                 pointDest[&lt;span&gt;1&lt;/span&gt;] = pointSrc[n[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]];
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;                 pointDest[&lt;span&gt;2&lt;/span&gt;] = pointSrc[n[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]];
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;3）通过二维码对图片矫正。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;图片有可能是倾斜的，倾斜夹角可以通过pt0与pt1连线与水平线之间的夹角确定。二维码的倾斜角度就是整个图片的倾斜角度，从而可以对整个图片进行水平矫正。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;二维码倾斜角度&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; Point hor(pointAdjust[&lt;span&gt;0&lt;/span&gt;].x+&lt;span&gt;300&lt;/span&gt;,pointAdjust[&lt;span&gt;0&lt;/span&gt;].y); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;水平线&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; qrAngle = QrParse::Angle(pointAdjust[&lt;span&gt;1&lt;/span&gt;], hor, pointAdjust[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;], clockwise);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; 
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;以二维码左上角点为中心 旋转&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt;     Mat drawingRotation =&lt;span&gt; Mat::zeros(Size(src.cols,src.rows), CV_8UC3);
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;     &lt;span&gt;double&lt;/span&gt; rotationAngle = clockwise? -&lt;span&gt;qrAngle:qrAngle;
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;     Mat affine_matrix = getRotationMatrix2D(pointAdjust[&lt;span&gt;0&lt;/span&gt;], rotationAngle, &lt;span&gt;1.0&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;求得旋转矩阵&lt;/span&gt;
&lt;span&gt;9&lt;/span&gt;     warpAffine(src, drawingRotation, affine_matrix, drawingRotation.size());
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;4）二维码相邻区域定位&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一般情况下，二维码在整个图中的位置是确定的。识别出二维码后，根据二维码与其他图的位置关系，可以很容易的定位别的图元。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/245753/201906/245753-20190607194439344-725362793.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;后记&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;作者通过查找大量资料，仔细研究了二维码的特征，从而找到了识别二维码的方法。网上也有许多识别二维码的方法，但是不够严谨。本文是将二维码的多个特征相结合来识别，这样更准确。这种识别方法已应用在公司的产品中，识别效果还是非常好的。&lt;/p&gt;
</description>
<pubDate>Fri, 07 Jun 2019 11:51:00 +0000</pubDate>
<dc:creator>源之缘</dc:creator>
<og:description>前言 因工作需要，需要定位图片中的二维码；我遂查阅了相关资料，也学习了opencv开源库。通过一番努力，终于很好的实现了二维码定位。本文将讲解如何使用opencv定位二维码。 定位二维码不仅仅是为了识</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yuanchenhui/p/opencv_qr.html</dc:identifier>
</item>
<item>
<title>.Net Core 微服务容器系列基础目录篇 - 名字都被注册了</title>
<link>http://www.cnblogs.com/weiBlog/p/10988022.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/weiBlog/p/10988022.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.开场白&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;HI，各位老铁，大家端午好，之前写了些关于.net core商城系列的文章，有点乱，今天心血来潮想着整理一下（今天只是先把目录列出来，后面的每篇文章这两天会进行重新修改的，目前先将就看下）。&lt;/p&gt;
&lt;p&gt;简单介绍一下，博主目前就职于某电商公司，目前工作用的是.net core，业余时间也会看下Java，公司内部目前也是多语言并存，毕竟很多工具和技术对于这两种语言都是相通的，所以多了解下哈。&lt;/p&gt;
&lt;p&gt;本系列项目将会以.net core+Docker+K8s来搭建，当然你用java来改写一下也是没问题的，因为并没有什么业务代码，很简单哈。如果你学习完整个系列，最终会得到什么呢？最终会得到一个运行在k8s中的简单商城网站，其目的是帮助各位同学了解目前互联网行业中小型公司的现有技术架构，同时着眼于未来，容器技术和DevOps一定是以后的流行趋势。另外一点是，当我们学习某个新技术时，通常是先了解一下理论，然后做两个小Demo，但我总觉得这样不够，一方面Demo太简单很容易遗忘，另一方面没有实际项目来巩固。所以我们需要把它用在真实的项目里，毕竟技术最终是要放在项目中来实践的，而本系列的项目就是这种对多技术的整合的大Demo（说来说去还是Demo，哈哈哈哈哈嗝）。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;GitHub地址：&lt;a href=&quot;https://github.com/DeepMountainMoose/MI.K8s.Service&quot;&gt;https://github.com/DeepMountainMoose/MI.K8s.Service&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.目录&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（1）&lt;a href=&quot;https://www.cnblogs.com/weiBlog/p/9822416.html&quot;&gt;使用IdentityServer4构建基础登录验证&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;（2）&lt;a href=&quot;https://www.cnblogs.com/weiBlog/p/9833807.html&quot;&gt;.Net Core 商城微服务项目系列（二）：使用Ocelot + Consul构建具备服务注册和发现功能的网关&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;（3）&lt;a href=&quot;https://www.cnblogs.com/weiBlog/p/9906294.html&quot;&gt;.Net Core 商城微服务项目系列（五）：使用Polly处理服务错误&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;（4）&lt;a href=&quot;https://www.cnblogs.com/weiBlog/p/9953062.html&quot;&gt;.Net Core 商城微服务项目系列（六）：搭建自己的Nuget包服务器&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;（5）&lt;a href=&quot;https://www.cnblogs.com/weiBlog/p/10133894.html&quot;&gt;.Net Core 商城微服务项目系列（七）：使用消息队列(RabbitMQ)实现服务异步通信&lt;/a&gt; （未完成）&lt;/p&gt;
&lt;p&gt;（6）&lt;a href=&quot;https://www.cnblogs.com/weiBlog/p/10447945.html&quot;&gt;.Net Core 商城微服务项目系列（十）：使用SkyWalking构建调用链监控&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;（7）&lt;a href=&quot;https://www.cnblogs.com/weiBlog/p/10771969.html&quot;&gt;.Net Core 商城微服务项目系列（十四）：分布式部署携程Apollo构建配置中心&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;（8）&lt;a href=&quot;https://www.cnblogs.com/weiBlog/p/10503779.html&quot;&gt;Kubernetes 系列（一）：本地k8s集群搭建&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;（9）&lt;a href=&quot;https://www.cnblogs.com/weiBlog/p/10743201.html&quot;&gt;.Net Core 商城微服务项目系列（十三）：搭建Log4net+ELK+Kafka日志框架&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;（10）&lt;a href=&quot;https://www.cnblogs.com/weiBlog/p/10665716.html&quot;&gt;.Net Core自动化部署系列（二）：使用Jenkins打造镜像发布流水线&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;（11）&lt;a href=&quot;https://www.cnblogs.com/weiBlog/p/10467971.html&quot;&gt;Kubernetes 系列（三）：Kubernetes使用Traefik Ingress暴露服务&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;（12）&lt;a href=&quot;https://www.cnblogs.com/weiBlog/p/10629966.html&quot;&gt;Kubernetes 系列（六）:Kubernetes部署Prometheus监控&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;（13）使用Quartz搭建定时任务自动调度系统（正在开发）&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.项目截图&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Web:&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1036828/201906/1036828-20190607173028994-153104155.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;K8s:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1036828/201906/1036828-20190607173115585-389288306.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1036828/201906/1036828-20190607181440691-1735490308.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; Traefik:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1036828/201906/1036828-20190607173212148-436634272.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Promethus:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1036828/201906/1036828-20190607173310109-681149722.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Grafana:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1036828/201906/1036828-20190607181847439-1536116009.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;ELK:&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1036828/201906/1036828-20190607172703847-1726676151.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Consul:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1036828/201906/1036828-20190607190351416-1221810101.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 07 Jun 2019 11:05:00 +0000</pubDate>
<dc:creator>名字都被注册了</dc:creator>
<og:description>1.开场白 HI，各位老铁，大家端午好，之前写了些关于.net core商城系列的文章，有点乱，今天心血来潮想着整理一下（今天只是先把目录列出来，后面的每篇文章这两天会进行重新修改的，目前先将就看下）</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/weiBlog/p/10988022.html</dc:identifier>
</item>
<item>
<title>Manacher算法详解 - 回首不知身是客</title>
<link>http://www.cnblogs.com/cloudplankroader/p/10988844.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cloudplankroader/p/10988844.html</guid>
<description>&lt;p&gt;**Manacher算法是一个用来查找一个字符串中的最长回文子串(不是最长回文序列)的线性算法。它的优点就是把时间复杂度为O(n*n)的暴力算法优化到了O(n)。首先先让我们来看看最原始的暴力扩展，分析其存在的弊端，以此来更好的理解Manacher算法。**&lt;/p&gt;
&lt;h2 id=&quot;暴力匹配&quot;&gt;暴力匹配&lt;/h2&gt;
&lt;p&gt;暴力匹配算法的原理很简单，就是从原字符串的首部开始，依次向尾部进行遍历，每访问一个字符，就以此字符为中心向两边扩展，记录该点的最长回文长度。那么我们可以想想，这样做存在什么弊端，是不是可以求出真正的最长回文子串？&lt;/p&gt;
&lt;p&gt;答案是显然不行的，我们从两个角度来分析这个算法&lt;/p&gt;
&lt;p&gt;1.不适用于偶数回文串&lt;/p&gt;
&lt;p&gt;我们举两个字符串做例子，它们分别是 &quot;aba&quot;，&quot;abba&quot;，我们通过肉眼可以观察出，它们对应的最长回文子串长度分别是3和4，然而我们要是用暴力匹配的方法去对这两个字符串进行操作就会发现，&quot;aba&quot; 对应的最长回文长是 &quot;131&quot;，&quot;abba&quot; 对应的最长回文长度是 &quot;1111&quot;，我们对奇数回文串求出了正确答案，但是在偶数回文串上并没有得到我们想要的结果，通过多次测试我们发现，这种暴力匹配的方法不适用于偶数回文串&lt;/p&gt;
&lt;p&gt;2.时间复杂度O(n*n)&lt;/p&gt;
&lt;p&gt;这里的时间复杂度是一个平均时间复杂度，并不代表每一个字符串都是这个复杂度，但因为每到一个新位置就需要向两边扩展比对，所以平均下来时间复杂度达到了O(n*n)。&lt;/p&gt;
&lt;h3 id=&quot;manacher算法本质上也是基于暴力匹配的方法只不过做了一点简单的预处理且在扩展时提供了加速&quot;&gt;Manacher算法本质上也是基于暴力匹配的方法，只不过做了一点简单的预处理，且在扩展时提供了加速&lt;/h3&gt;
&lt;h2 id=&quot;manacher对字符串的预处理&quot;&gt;Manacher对字符串的预处理&lt;/h2&gt;
&lt;p&gt;我们知道暴力匹配是无法解决偶数回文串的，可Manacher算法也是一种基于暴力匹配的算法，那它是怎么来实现暴力匹配且又不出错的呢？它用来应对偶数字符串的方法就是——做出预处理，这个预处理可以巧妙的让所有字符串都变为奇数回文串，不论它原本是什么。操作实现也很简单，就是将原字符串的首部和尾部以及每两个字符之间插入一个特殊字符，这个字符是什么不重要，不会影响最终的结果(具体原因会在后面说)，这一步预处理操作后的效果就是原字符串的长度从n改变成了2*n+1，也就得到了我们需要的可以去做暴力扩展的字符串，并且从预处理后的字符串得到的最长回文字符串的长度除以2就是原字符串的最长回文子串长度，也就是我们想要得到的结果。&lt;/p&gt;
&lt;p&gt;这里解释一下为什么预处理后不会影响对字符串的扩展匹配&lt;/p&gt;
&lt;p&gt;比如我们的原字符串是 &quot;aa&quot;，假设预处理后的字符串是 &quot;#a#a#&quot;，我们在任意一个点，比如字符 '#'，向两端匹配只会出现 'a' 匹配 'a'，'#' 匹配 '#' 的情况，不会出现原字符串字符与特殊字符匹配的情况，这样就能保证我们不会改变原字符串的匹配规则。通过这个例子，你也可以发现实际得到的结果与上述符合。&lt;/p&gt;
&lt;h2 id=&quot;manacher算法核心&quot;&gt;Manacher算法核心&lt;/h2&gt;
&lt;p&gt;Manacher算法的核心部分在于它巧妙的令人惊叹的加速，这个加速一下把时间复杂度提升到了线性，让我们从暴力的算法中解脱出来，我们先引入概念，再说流程，最后提供实现代码。&lt;/p&gt;
&lt;h3 id=&quot;概念&quot;&gt;概念：&lt;/h3&gt;
&lt;p&gt;ManacherString：经过Manacher预处理的字符串，以下的概念都是基于ManasherString产生的。&lt;/p&gt;
&lt;p&gt;回文半径和回文直径：因为处理后回文字符串的长度一定是奇数，所以回文半径是包括回文中心在内的回文子串的一半的长度，回文直径则是回文半径的2倍减1。比如对于字符串 &quot;aba&quot;，在字符 'b' 处的回文半径就是2，回文直径就是3。&lt;/p&gt;
&lt;p&gt;最右回文边界R：在遍历字符串时，每个字符遍历出的最长回文子串都会有个右边界，而R则是所有已知右边界中最靠右的位置，也就是说R的值是只增不减的。&lt;/p&gt;
&lt;p&gt;回文中心C：取得当前R的第一次更新时的回文中心。由此可见R和C时伴生的。&lt;/p&gt;
&lt;p&gt;半径数组：这个数组记录了原字符串中每一个字符对应的最长回文半径。&lt;/p&gt;
&lt;h3 id=&quot;流程&quot;&gt;流程：&lt;/h3&gt;
&lt;p&gt;步骤1：预处理原字符串&lt;/p&gt;
&lt;p&gt;先对原字符串进行预处理，预处理后得到一个新的字符串，这里我们称为S，为了更直观明了的让大家理解Manacher的流程操作，我们在下文的S中不显示特殊字符(这样并不影响结果)。&lt;/p&gt;
&lt;p&gt;步骤2：R和C的初始值为-1，创建半径数组pArr&lt;/p&gt;
&lt;p&gt;这里有点与概念相差的小偏差，就是R实际是最右边界位置的右一位。&lt;/p&gt;
&lt;p&gt;步骤3：开始从下标 i = 0去遍历字符串S&lt;/p&gt;
&lt;p&gt;分支1：i &amp;gt; R ，也就是i在R外，此时没有什么花里胡哨的方法，直接暴力匹配，此时记得看看C和R要不要更新。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1520224/201906/1520224-20190607181325011-391201367.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;分支2：i &amp;lt;= R，也就是i在R内，此时分三种情况，在讨论这三个情况前，我们先构建一个模型&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1520224/201906/1520224-20190607181341311-1732200825.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;L是当前R关于C的对称点，i'是i关于C的对称点，可知 i' = 2*C - i，并且我们会发现，i'的回文区域是我们已经求过的，从这里我们就可以开始判断是不是可以进行加速处理了&lt;/p&gt;
&lt;p&gt;情况1：i'的回文区域在L-R的内部，此时i的回文直径与 i' 相同，我们可以直接得到i的回文半径，下面给出证明&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1520224/201906/1520224-20190607181356312-1391152633.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;红线部分是 i' 的回文区域，因为整个L-R就是一个回文串，回文中心是C，所以i形成的回文区域和i'形成的回文区域是关于C对称的。&lt;/p&gt;
&lt;p&gt;情况2：i'的回文区域左边界超过了L，此时i的回文半径则是i到R,下面给出证明&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1520224/201906/1520224-20190607181408126-473486755.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先我们设L点关于i'对称的点为L'，R点关于i点对称的点为R'，L的前一个字符为x，L’的后一个字符为y，k和z同理，此时我们知道L - L'是i'回文区域内的一段回文串，故可知R’ - R也是回文串，因为L - R是一个大回文串。所以我们得到了一系列关系，x = y，y = k，x != z，所以 k != z。这样就可以验证出i点的回文半径是i - R。&lt;/p&gt;
&lt;p&gt;情况3：i' 的回文区域左边界恰好和L重合，此时i的回文半径最少是i到R，回文区域从R继续向外部匹配，下面给出证明&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1520224/201906/1520224-20190607181418434-554360226.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为 i' 的回文左边界和L重合，所以已知的i的回文半径就和i'的一样了，我们设i的回文区域有边界的下一个字符是y，i的回文区域左边界的上一个字符是x，现在我们只需要从x和y的位置开始暴力匹配，看是否能把i的回文区域扩大即可。&lt;/p&gt;
&lt;p&gt;总结一下，Manacher算法的具体流程就是先匹配 -&amp;gt; 通过判断i与R的关系进行不同的分支操作 -&amp;gt; 继续遍历直到遍历完整个字符串&lt;/p&gt;
&lt;h3 id=&quot;时间复杂度&quot;&gt;时间复杂度：&lt;/h3&gt;
&lt;p&gt;我们可以计算出时间复杂度为何是线性的，分支一的情况下时间时间复杂度是O(n)，分支二的前两种情况都是O(1)，分支二的第三种情况，我们可能会出现O(1)——无法从R继续向后匹配，也可能出现O(n)——可以从R继续匹配，即使可以继续匹配，R的值也会增大，这样会影响到后续的遍历匹配复杂度，所以综合起来整个算法的时间复杂度就是线性的，也就是O(n)。&lt;/p&gt;
&lt;h3 id=&quot;实现代码&quot;&gt;实现代码：&lt;/h3&gt;
&lt;p&gt;整个代码并不是对上述流程的生搬硬套(那样会显得代码冗长)，代码进行了精简优化，具体如何我会在代码中进行注释&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;string&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;vector&amp;gt;
#include&amp;lt;cmath&amp;gt;
using namespace std;
//算法主体
int maxLcsplength(string str) {
    //空字符串直接返回0
    if (str.length() == 0) {
        return 0;
    }
    //记录下原始字符串的长度，方便后面使用
    int len = (int)(str.length() * 2 + 1);
    //开辟动态数组chaArr记录manacher化的字符串
    //开辟动态数组pArr记录每个位置的回文半径
    char *chaArr = new char[len];
    int* pArr = new int[len];
    int index = 0;
    for (int i = 0; i &amp;lt; len;i++) {
        chaArr[i] = (i &amp;amp; 1) == 0 ? '#' : str[index++];
    }
    //到此完成对原字符串的manacher化
    //R是最右回文边界，C是R对应的最左回文中心，maxn是记录的最大回文半径
    int R = -1;
    int C = -1;
    int maxn = 0;
    //开始从左到右遍历
    for (int i = 0; i &amp;lt; len; i++) {
        //第一步直接取得可能的最短的回文半径，当i&amp;gt;R时，最短的回文半径是1，反之，最短的回文半径可能是i对应的i'的回文半径或者i到R的距离
        pArr[i] = R &amp;gt; i ? min(R - i, pArr[2 * C - i]) : 1;
        //取最小值后开始从边界暴力匹配，匹配失败就直接退出
        while (i + pArr[i]&amp;lt;len &amp;amp;&amp;amp; i + pArr[i]&amp;gt;-1) {
            if (chaArr[i + pArr[i]] == chaArr[i - pArr[i]]) {
                pArr[i]++;
            }
            else {
                break;
            }
        }
        //观察此时R和C是否能够更新
        if (i + pArr[i] &amp;gt; R) {
            R = i + pArr[i];
            C = i;
        }
        //更新最大回文半径的值
        maxn = max(maxn, pArr[i]);
    }
    //记得清空动态数组哦
    delete[] chaArr;
    delete[] pArr;
    //这里解释一下为什么返回值是maxn-1，因为manacherstring的长度和原字符串不同，所以这里得到的最大回文半径其实是原字符串的最大回文子串长度加1，有兴趣的可以自己验证试试
    return maxn - 1;
}
int main()
{
    string s1 = &quot;&quot;;
    cout &amp;lt;&amp;lt; maxLcsplength(s1) &amp;lt;&amp;lt; endl;
    string s2 = &quot;abbbca&quot;;
    cout &amp;lt;&amp;lt; maxLcsplength(s2) &amp;lt;&amp;lt; endl;
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面附上java代码&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Manacher {

    public static char[] manacherString(String str) {
        char[] charArr = str.toCharArray();
        char[] res = new char[str.length() * 2 + 1];
        int index = 0;
        for (int i = 0; i != res.length; i++) {
            res[i] = (i &amp;amp; 1) == 0 ? '#' : charArr[index++];
        }
        return res;
     }

    public static int maxLcpsLength(String str) {
        if (str == null || str.length() == 0) {
            return 0;
        }
        char[] charArr = manacherString(str);
        int[] pArr = new int[charArr.length];
        int C = -1;
        int R = -1;
        int max = Integer.MIN_VALUE;
        for (int i = 0; i != charArr.length; i++) {
            pArr[i] = R &amp;gt; i ? Math.min(pArr[2 * C - i], R - i) : 1;
            while (i + pArr[i] &amp;lt; charArr.length &amp;amp;&amp;amp; i - pArr[i] &amp;gt; -1) {
                if (charArr[i + pArr[i]] == charArr[i - pArr[i]])
                    pArr[i]++;
                else {
                    break;
                }
            }
            if (i + pArr[i] &amp;gt; R) {
                R = i + pArr[i];
                C = i;
            }
            max = Math.max(max, pArr[i]);
        }
        return max - 1;
    }

    public static void main(String[] args) {
        String str1 = &quot;abc123321cba&quot;;
        System.out.println(maxLcpsLength(str1));
    }

}
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 07 Jun 2019 10:21:00 +0000</pubDate>
<dc:creator>回首不知身是客</dc:creator>
<og:description>Manacher Manacher算法是一个用来查找一个字符串中的最长回文子串(不是最长回文序列)的线性算法。它的优点就是把时间复杂度为O(n n)的暴力算法优化到了O(n)。首先先让我们来看看最原始</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cloudplankroader/p/10988844.html</dc:identifier>
</item>
</channel>
</rss>