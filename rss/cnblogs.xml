<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>你不需要 jQuery，但你需要一个 DOM 库 - 叙帝利</title>
<link>http://www.cnblogs.com/nzbin/p/10230272.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nzbin/p/10230272.html</guid>
<description>&lt;p&gt;写这篇文章的目的，一方面是介绍一下自己编写的模块化 DOM 库 domq.js，另一方面是希望大家对 jQuery 有一个正确的认识，即使 jQuery 已经退出历史舞台，但是它的 API 会以另外一种形式存在下去。&lt;/p&gt;
&lt;blockquote readability=&quot;1.4301075268817&quot;&gt;
&lt;p&gt;GitHub：&lt;a href=&quot;https://github.com/nzbin/domq&quot; class=&quot;uri&quot;&gt;https://github.com/nzbin/domq&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文档：&lt;a href=&quot;https://nzbin.gitbooks.io/domq-api/usage.html&quot; class=&quot;uri&quot;&gt;https://nzbin.gitbooks.io/domq-api/usage.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;jquery-不会死去&quot;&gt;jQuery 不会死去&lt;/h2&gt;
&lt;p&gt;从 GitHub 放弃 jQuery，再到 Bootstrap 5 宣布移除 jQuery，看来一个时代终究要落下帷幕。&lt;/p&gt;
&lt;p&gt;为什么我们会放弃 jQuery 呢？原因无非这样几个：不需要再进行浏览器的兼容，原生 DOM 查找已经很方便，AJAX 请求有更好的替代方式等等。&lt;/p&gt;
&lt;p&gt;在我看来 jQuery 最大的弊端是无法分模块引入，直接引入整个库实在有些不妥，毕竟太多功能已经没有用武之地。但是 jQuery 的 DOM 操作依然很有必要。很多人对我的这个观点有些疑问。其实在使用 MVVM 框架的时候，DOM 操作确实已经很少。但是我们也不可能总是做一些 CRUD 的功能。对于复杂的业务需求仍然需要一些 DOM 操作。&lt;/p&gt;
&lt;p&gt;假如 jQuery 可以把 DOM 操作相关的功能模块分离出来，或许还有很大的使用空间。&lt;/p&gt;
&lt;h2 id=&quot;原生当道&quot;&gt;原生当道&lt;/h2&gt;
&lt;p&gt;在平时的项目中，越来越多的人选择用原生 JS 去操作对象，比如获取元素属性，宽高，定位等等。&lt;/p&gt;
&lt;p&gt;早在几年前，github 上就有很多文章介绍如何用原生代替 jQuery，比如 &lt;a href=&quot;https://github.com/nefe/You-Dont-Need-jQuery&quot;&gt;YouDontNeedJQuery&lt;/a&gt;，&lt;a href=&quot;https://github.com/HubSpot/youmightnotneedjquery&quot;&gt;YouMightNotNeedjQuery&lt;/a&gt;等。就我个人而言，纯 JS 操作确实很简单，但是并不是很优雅，复杂一点的操作还要经常翻 mdn。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// jquery
$('.my #awesome selector');&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// js
document.querySelectorAll('.my #awesome selector');&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上是 jQuery 和原生 js 对比的一个缩影，结果显而易见，jQuery 的 API 更加简洁。除此之外，jQuery 的 API 不仅简洁，而且使用形式也非常统一。相反，原生 JS 的 API 使用方式就比较多样了，比如赋值、传参的形式等。另外原生 JS 的 API 名称冗长，不方便记忆。这也是很多 JS 库诞生的意义。&lt;/p&gt;
&lt;p&gt;很多插件一般都会有一个 &lt;code&gt;utils&lt;/code&gt; 的文件，基本会对原生方法做一个简单封装并提供一些工具方法。&lt;/p&gt;
&lt;h2 id=&quot;zepto-的优势与弱点&quot;&gt;Zepto 的优势与弱点&lt;/h2&gt;
&lt;p&gt;Zepto 是一个思想超前的库，为什么我会有这样的结论？Zepto 对原生方法做了进一步的抽象，使用更简单。正如我在上文说过的，既然 jQuery 的 API 简洁易用，而且我们也更加熟悉，那我们为什么不将 jQuery 和原生 JS 结合起来呢？令人惊讶的是，早在 2010 年，Zepto 的作者就已经这样去做了。用原生 JS 实现了 jQuery 的大部分 API，可替代率接近九成吧，至少在我编写的插件中，几乎可以替换掉所有的 jQuery API。而且 Zepto 也不是一味的使用 &lt;code&gt;document.querySelector&lt;/code&gt; 方法，而是根据性能优劣，有选择的使用 &lt;code&gt;document.getElementById&lt;/code&gt; 以及 &lt;code&gt;document.querySelector&lt;/code&gt; 等。&lt;/p&gt;
&lt;p&gt;但是 Zepto 也有一些显而易见的缺陷，毕竟还是上个时代的产物，首先就是无法按需加载，现在我们在写项目的时候更愿意根据自己的需要引入某些方法，而不是将整个库全部引入，虽然 Zepto 的体积不大，但是作为强迫症还是有一些厌恶。另外就是 Zepto 本身也有一些 bug，比如 &lt;code&gt;scrollTop&lt;/code&gt;、&lt;code&gt;scrollLeft&lt;/code&gt; 方法。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;scrollTop: function(value) {
    if (!this.length) return
    var hasScrollTop = 'scrollTop' in this[0]
    if (value === undefined) return hasScrollTop ? this[0].scrollTop : this[0].pageYOffset
    return this.each(hasScrollTop ?
        function() { this.scrollTop = value } :
        function() { this.scrollTo(this.scrollX, value) })
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;document&lt;/code&gt; 元素无法获得正确的值，我对这个问题提过 pr 但是没有回应，Zepto 目前基本已经停止维护。正确的方法如下：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;function scrollTop(value) {
    if (!this.length) return
    var hasScrollTop = 'scrollTop' in this[0]
    if (value === undefined) return hasScrollTop
        ? this[0].scrollTop
        : isWindow(this[0])
            ? this[0].pageYOffset
            : this[0].defaultView.pageYOffset;
    return this.each(hasScrollTop ?
        function () { this.scrollTop = value } :
        function () { this.scrollTo(this.scrollX, value) })
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;domq-的使命&quot;&gt;Domq 的使命&lt;/h2&gt;
&lt;p&gt;形如 jQuery 的 DOM 操作库有很多，比如 &lt;a href=&quot;https://github.com/ded/bonzo&quot;&gt;bonzo&lt;/a&gt;、&lt;a href=&quot;https://github.com/julienw/dollardom&quot;&gt;$dom&lt;/a&gt;，但是在我重构 jQuery 插件时，我发现没有办法用这些库直接替换 jQuery，只有 Zepto 相对完美，但是我又不希望引入额外的无用的方法。&lt;/p&gt;
&lt;p&gt;最后我决定改造 Zepto，使之更符合现在的使用习惯。多说一点，个人觉得 Zepto 的核心函数稍显凌乱，命名空间既有 &lt;code&gt;zepto&lt;/code&gt;、又有 &lt;code&gt;$&lt;/code&gt;、&lt;code&gt;Z&lt;/code&gt;，感觉非常混乱，而 domq 的核心函数只有 &lt;code&gt;D&lt;/code&gt; 这一个命名空间，形态及功能和 jQuery 的核心函数几乎一样，可以认为是一个 mini 版的 jQuery。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// Zepto 核心方法
var Zepto = (function() {
    var zepto = {};
    ...
    zepto.Z = function(dom, selector) {
        return new Z(dom, selector)
    }
    ...
    $ = function(selector, context) {
        return zepto.init(selector, context)
    }
    ...
})()&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// Domq 核心方法
var D = function (selector, context) {
    return new D.fn.init(selector, context);
}

D.fn = D.prototype = {
    ...
    init: function(){
        ...
    }
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然， Domq 最关键的还是按需加载，根据需要挂载方法，尽量减少不必要的代码。使用方式很简单，但是你需要创建一个独立文件，重新挂载需要的方法到 &lt;code&gt;D&lt;/code&gt; 命名空间上，这在编写插件时非常有用。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;import {
  D,
  isArray,
  addClass
} from 'domq.js/src/domq.modular';

// 静态方法
const methods = {
  isArray
}

// 原型方法
const fnMethods = {
  addClass
}

D.extend(methods);
D.fn.extend(fnMethods);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另外，在做项目时经常会用到一些工具方法，这时候用一个工具库暴露这些方法或许是最好的方式。Domq 也有一些常用的工具方法，不过还需要再迭代一下。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;D.type()
D.contains()
D.camelCase()
D.isFunction()
D.isWindow()
D.isEmptyObject()
D.isPlainObject()
D.isNumeric()
D.isArray()
D.inArray()
...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Domq 没有太多新的东西，所以也没有太多可以介绍的，它已经在插件以及实际项目中得到验证，欢迎大家下载使用。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;这是一个好的时代，也是一个坏的时代，jQuery 的落幕确实让人感叹，但是我们完全没必要因为 jQuery 的落幕而放弃 jQuery 的使用方式。正如前文所说，jQuery 的 DOM 操作在我看来依然是最好用的，所以，你不需要 jQuery，但你需要一个 DOM 库。&lt;/p&gt;
&lt;blockquote readability=&quot;1.1842105263158&quot;&gt;
&lt;p&gt;GitHub：&lt;a href=&quot;https://github.com/nzbin/domq&quot; class=&quot;uri&quot;&gt;https://github.com/nzbin/domq&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 25 Mar 2019 23:54:00 +0000</pubDate>
<dc:creator>叙帝利</dc:creator>
<og:description>写这篇文章的目的，一方面是介绍一下自己编写的模块化 DOM 库 domq.js，另一方面是希望大家对 jQuery 有一个正确的认识，即使 jQuery 已经退出历史舞台，但是它的 API 会以另外一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nzbin/p/10230272.html</dc:identifier>
</item>
<item>
<title>一位90后的自述：如何从年薪3w到30w - 上海小胖</title>
<link>http://www.cnblogs.com/moonhmily/p/10597905.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/moonhmily/p/10597905.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/649191/201903/649191-20190304223853444-2062628373.png&quot; alt=&quot;路飞&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;作者介绍：90后生人/男/二本本科/世界500强技术主管&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;上海小胖，曾就职于pwc（普华永道）担任TechLeader，带领DS（Data Scientist）团队完成全美医疗保险大数据项目的一期开发。「红色警戒：复兴」的联合创始人，MongoDB Professional 中国第15位获得者，MongoDB大中华区核心成员。&lt;/p&gt;
&lt;p&gt;目前创业，方向大数据产品，担任解决方案架构师，帮助客户解决生产环境的痛点及瓶颈，给出有效的POC方案来验证产品的可行性。&lt;/p&gt;

&lt;p&gt;引用赵真老师的一首歌《过去不是错》中的一句话：过去不是过错，毕竟我们也开心过。过去不是过错，何必愧疚不知所措。&lt;/p&gt;
&lt;p&gt;我们这一代人，我相信多少都会有人和我一样，坚持过一个游戏，叫DOTA吧？&lt;/p&gt;
&lt;p&gt;曾经一起去网吧通宵开黑的日子还记得吗？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/649191/201903/649191-20190304223920862-1773368174.png&quot; alt=&quot;dota开黑&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一人被GANK，4张TP落下的瞬间，可曾有过感动？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/649191/201903/649191-20190304223942782-2095972615.png&quot; alt=&quot;dota&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还记得那句：“团战可以输，影魔必须死”吗？&lt;/p&gt;
&lt;p&gt;是否有过一句“来张TP”，鸟里瞬间4张TP的时候？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/649191/201903/649191-20190304224021922-1787309535.png&quot; alt=&quot;dota&quot;/&gt;&lt;/p&gt;
&lt;p&gt;附上一段纪念DOTA青春的视频：&lt;a href=&quot;http://v.youku.com/v_show/id_XNzA4Njk0MTUy.html&quot; class=&quot;uri&quot;&gt;http://v.youku.com/v_show/id_XNzA4Njk0MTUy.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;还记得09，8老板，Pis，蛛丝马迹，B神，zhou，LGD，EHOME吗？我相信，我们这一代人，DOTA于我们，已经不是一种游戏了，是一种兄弟情，一种信仰，一份坚持，一次承诺。&lt;/p&gt;

&lt;p&gt;然而到了大四那年，面对的不再是5杀，钢琴手了，论文、毕业、就业的现实摆在了我的面前，我需要踏入社会，找一份工作，让自己能够生活下去。&lt;/p&gt;
&lt;p&gt;这个时候边上一句“叫你天天打游戏呀”，我无言以对。&lt;/p&gt;
&lt;p&gt;学校的招聘市场，人是茫茫多，拿着自己的简历， 都不敢投，什么都没有啊，难道我要写天梯1800分？精通地补师的出装、GANK、combo？还是说我有一双钢琴手？&lt;/p&gt;
&lt;p&gt;在一次次的学校招聘无果后，我来到了社会人才招聘市场，这人更是多的lai。。。没办法啊，一家家看，人家要什么，我没什么，我有什么（钢琴手），人家不要啊。&lt;/p&gt;
&lt;p&gt;路过一个企业在招聘运维工程师（当初不知道是干嘛的），月薪6k起步，入职后有入岗培训。我心想，6k？2012年啊，小伙伴们，这不起飞了？天天大宝剑了啊可以。我就去问了，一堆寒暄后（家庭条件啊，什么学校，会什么啊），跟我来了一句，“恭喜你，初试通过，进入复试环节了”。当时并没有全场懵逼这个说法，但我肯定是懵了。&lt;/p&gt;
&lt;p&gt;过了几天，到了复试时间，我就如约而至来到了某某写字楼里，进入他们的公司后，让我做题目了（脑筋急转弯？小明15年前15岁，15年后几岁了？）然后说我通过复试了，但是balabal，要交钱？我丫的不是进了传销了吧？（你们肯定在6k的时候，就觉得我进传销了对伐……）那我起身就准备溜啊，我还年轻啊，我不行可以去打职业啊……，然而被挽留了。。。原来是个培训机构，做Oracle运维。&lt;/p&gt;
&lt;p&gt;给我吹了一通后，我感觉被洗脑了，当年Oracle DBA还是很吃香的啊，传闻1年OracleDBA 月入1w。回到家和家人一商量，随我，那我就试试呗？反正啥也不会。&lt;/p&gt;
&lt;p&gt;以我现在的工作经验和讲师经验（鄙人也做了几年Python和数据库的培训），当初的培训机构真是扯淡。我就不曝光了（认怂）。和现在市面上口碑做得好的真是没法比。&lt;/p&gt;
&lt;p&gt;4个月脱产，我每天带饭（省钱），别人学到后面不来了，我来。别人上课时候DOTA了，我忍住了。我都要被自己感动哭了啊。所谓天道酬勤，上善若水，光明就在前方了啊。&lt;/p&gt;

&lt;p&gt;带着我的自信投起了简历，一路GG，无人问津啊。当时就想，时间浪费了，还背了一身债（家里条件不好，学费分期，现在想想简直就是高利贷啊，每个月还1000，还1年多）。上善呢？还有若水呢？我没被淹死我去。&lt;/p&gt;
&lt;p&gt;一个偶然的机会，一家初创公司给我发来贺电，邀我面谈，我就去了。做的是运维（初创公司吗，啥都干，网管咯，SRE咯，DBA咯，都做），工资3.5k，做呗，不做就没饭吃了啊。&lt;/p&gt;
&lt;p&gt;每天的工作就是发布代码，还是windows的，那个时候没什么技能点，所以都得靠手活，钢琴手这个时候倒是派上用处了，但是有什么用呢？再快也就快一倍？十几台机器就挡不住了，别说几十台，几百台了。&lt;/p&gt;
&lt;p&gt;那个时候是做六休一，平时半夜接到电话，要代码发布，你就得起来啊，做的事情就是等Developer给我代码，我传上去。要么就是干脆不回家，一陪到天亮。自己学，真的是天昏地暗啊，你都不知道学什么。&lt;/p&gt;
&lt;p&gt;这个时候每天都在想，这点钱干什么不好啊，天天通宵，苦死了，有种早更30年的感觉。每天都浮躁啊，我是第一批90后啊，我头上有2个玄啊（不知道的，可以查一下，说法很多，但我只知道，我有2个玄，肯定不一样）！我有上善和若水啊。&lt;/p&gt;

&lt;p&gt;就这样度过了大半年。浑浑噩噩，每天就在维护代码，半夜更新的状态下度过。感觉不知道以后要干嘛，能干嘛。&lt;/p&gt;
&lt;p&gt;突然有一天qq里有一条招聘信息，招聘MongoDB DBA（这是什么数据库？）不管啊，先聊聊，开了薪资8-12k！这不是能天天大保健了啊！不管了，这就上了啊。&lt;/p&gt;
&lt;p&gt;聊了几句，约了个时间，那天是周一，我和他们约了周五。这样我就有时间做准备了。&lt;/p&gt;
&lt;p&gt;周二周三早上8点到公司，看到晚上11点，到家洗澡就睡觉，这样保证第二天还有精力看书。周四看了一天关于MongoDB的内容，面试点，trouble shooting。周五面试的时候到了，虽然历经坎坷、饱经沧桑，最后还是面试通过了（这里就不赘述面试过程了，感兴趣的小伙伴，之后可以等我的面试技巧篇）。&lt;/p&gt;
&lt;p&gt;人生的转折点真的很多，所以这个转折点显然不是我的第一个转折点，也不会是最后一个。但我可以肯定的是，是我职业发展中最重要的一个转折点。每每和小伙伴聊起这一段，我都滔滔不绝，因为在新的公司，我遇到了我的职业导师也是生活中到目前很好的益友。&lt;/p&gt;
&lt;p&gt;暂时就叫他菠萝同学吧，菠萝同学每天在空下来的时候就教我写C#，是他告诉我，运维不会开发，永远无法提升自我，只能在外面转，只能用别人的工具，而不能自我满足。有一段时间，每天教到7点才下班。还带着我做项目，带我零基础入门编程的世界，改变了我对IT的认知。是的，如果没有菠萝同学，也许就没有这篇文章了，我也还是做着每天发布的事情，借此，还是感谢菠萝同学对我孜孜不倦的教导。&lt;/p&gt;

&lt;p&gt;好了，到了这里，我已经可以天天去大保健了，但我想去“学英语”怎么办，我还得学。离开了菠萝同学后，我来到了一家互联网企业，在那里也遇到了许多志同道合的小伙伴，开发、测试、产品、客服、市场，菠萝同学一直告诫我，不要只顾着代码，要去了解客户需求、产品定位，这些才是根本。&lt;/p&gt;

&lt;p&gt;故事到这里，已经快要结束了，我希望通过自身的故事告诉大家一件事情：努力，什么时候都不晚，只要你想变好，那么离成功已经近了一步，剩下的只是把路走完。&lt;/p&gt;
&lt;p&gt;人生的导师可遇不可求，现在没有只是时间没到，相信我，过不了多久，你的那位菠萝同学就会出现。&lt;/p&gt;
&lt;p&gt;不要满足于现状，要勇于走出舒适区，尝试不同的东西。比如我现在在做的公众号。并不因我是IT从业人员，而抵触自媒体，相反，我希望通过公众号，能够结交更多志同道合的兄弟们，一起努力、成长。&lt;/p&gt;
&lt;p&gt;多接触不同的东西，而不仅仅是Code，产品、市场，哪怕是客服，都会让你对所做的东西有更深的了解。&lt;/p&gt;
&lt;p&gt;欢迎关注公众号「&lt;strong&gt;Python专栏&lt;/strong&gt;」，后台回复「&lt;strong&gt;腾讯架构资源&lt;/strong&gt;」获取腾讯架构师整理的大数据学习资源，和一群志同道合的兄弟姐妹们努力。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/649191/201902/649191-20190228222044609-1976101388.jpg&quot; width=&quot;300&quot; height=&quot;300&quot; alt=&quot;Python专栏二维码&quot;/&gt;&lt;/p&gt;
&lt;center&gt;改变自己，永远不晚！&lt;/center&gt;
</description>
<pubDate>Mon, 25 Mar 2019 21:41:00 +0000</pubDate>
<dc:creator>上海小胖</dc:creator>
<og:description>人生的导师可遇不可求，现在没有只是时间没到，相信我，过不了多久，你的那位菠萝同学就会出现。 不要满足于现状，要勇于走出舒适区，尝试不同的东西。比如我现在在做的公众号。并不因我是IT从业人员，而抵</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/moonhmily/p/10597905.html</dc:identifier>
</item>
<item>
<title>受用一生的高效 PyCharm 使用技巧（一） - 站在两个世界的边缘</title>
<link>http://www.cnblogs.com/wongbingming/p/10597686.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wongbingming/p/10597686.html</guid>
<description>&lt;p&gt;PyCharm 是大多数 Python 开发者的首选 IDE，每天我们都在上面敲着熟悉的代码，写出一个又一个奇妙的功能。&lt;/p&gt;
&lt;p&gt;一个每天都在使用的工具，如果能掌握一些高效的使用技巧，肯定会给我们的开发效率带来质的提升。今天我就来写一写我在平时开发中一直在用的，可以明显改善开发效率的使用技巧，一旦学会，受用一生。&lt;/p&gt;
&lt;h2 id=&quot;代码排版自动pep8&quot;&gt;01. 代码排版，自动PEP8&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;pep8&lt;/code&gt; 是Python 语言的一个代码编写规范。如若你是新手，目前只想快速掌握基础，而不想过多去注重代码的的编写风格（虽然这很重要），那你可以尝试一下这个工具 - &lt;code&gt;autopep8&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;首先在全局环境中（不要在虚拟环境中安装），安装一下这个工具。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;sudo pip install autopep8&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在 Pycharm 里导入这个工具。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Name: AutoPep8
Description: autopep8 your code
Program: autopep8
Arguments: --in-place --aggressive --aggressive $FilePath$
Working directory: $ProjectFileDir$
Output filters: $FILE_PATH$\:$LINE$\:$COLUMN$\:.*&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/3/25/169b583059b1d2e7?w=1696&amp;amp;h=1164&amp;amp;f=png&amp;amp;s=239356&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我随意写了一段不符合 pep8 规范的代码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/3/25/169b58305a6ece3e?w=1316&amp;amp;h=286&amp;amp;f=png&amp;amp;s=55155&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击右键，选择 &lt;code&gt;External Tools&lt;/code&gt; -&amp;gt; &lt;code&gt;AutoPep8&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/3/25/169b5830594b3b49?w=1084&amp;amp;h=314&amp;amp;f=png&amp;amp;s=35183&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看一下效果，还是挺明显的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/3/25/169b583059a773b4?w=1584&amp;amp;h=796&amp;amp;f=png&amp;amp;s=237658&quot;/&gt;&lt;/p&gt;
&lt;p&gt;你可能会说，Pycharm 本身就自带这个功能了呀，快捷键 &lt;code&gt;Command&lt;/code&gt;+&lt;code&gt;Option&lt;/code&gt;+&lt;code&gt;L&lt;/code&gt; ，就可以实现一键pep8了。你可以对比一下，Pycharm 自带的代码 pep8 化功能 并没有像这个&lt;code&gt;autopep8&lt;/code&gt; 来得彻底。 我相信你最终的选择肯定是后者。&lt;/p&gt;
&lt;p&gt;经群友推荐，还有更为智能的方法，就是使用 File Watchers，一旦你更新文件，这个插件就会检测，不符合pep8规范就给你转换并刷新文件，真正做到零操作自动化。&lt;/p&gt;
&lt;p&gt;首先先安装 &lt;code&gt;black&lt;/code&gt; 这个工具（&lt;a href=&quot;https://github.com/ambv/black&quot;&gt;Github&lt;/a&gt;)（不支持在 python2中安装，但也可以格式化 python2的代码）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;pip3 install black&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后直接在 PyCharm 里添加这个插件，重启后即可生效。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/3/25/169b58305f316324?w=2020&amp;amp;h=1114&amp;amp;f=png&amp;amp;s=150645&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;误删文件一秒找回&quot;&gt;02. 误删文件，一秒找回&lt;/h2&gt;
&lt;p&gt;上周，由于自己的误操作，在没有任何备份的情况下，将一个自己写了两个星期的项目给删除了。待我回头神来的时候，我甚至都记不起是何时进行的删除操作。&lt;/p&gt;
&lt;p&gt;做为一名老司机，当然是临危不惧地打开了回收站，进行一番搜寻，几个月没有清理过的回收站，真是一片狼藉，什么 jpg，avi 都有，不堪入目呀。&lt;/p&gt;
&lt;p&gt;我用一分钟快速浏览了一下，没有发现我要找的那几个 py 文件，我心想，应该是文件太多了，看叉掉了。由于项目是最近写的，文件名我还清楚地记得，既然有文件名，那就利用windows 自带的搜索功能，结果还是没有，这下我才开始意识到事态的严重性，文件可能真的「没了」。&lt;/p&gt;
&lt;p&gt;我已经很久没有清理过回收站了，为什么回收站里会没有我的文件呢？&lt;/p&gt;
&lt;p&gt;我想这可能是一次非同寻常的 delete，会不会是在 Pycharm 里的 发起删除操作，不会往回收站里丢呢？经过一番测试，在回收站还真的找不着，但是这次尝试也无意中发现了 Pycharm 的隐藏的一个功能 &lt;code&gt;Local History&lt;/code&gt;，它会保存你对文件的所有操作记录。&lt;/p&gt;
&lt;p&gt;就拿我的刚刚测试的文件来举例，我先是新建了一个文件，然后对在这个文件里添加了几行代码。最后我将这个文件删除了。&lt;/p&gt;
&lt;p&gt;此时你可以在你的项目目录里，点击右键，有个 &lt;code&gt;Local History&lt;/code&gt; 的选项，再点击子选项 &lt;code&gt;Show History&lt;/code&gt;，你可以看到这里有个记录板。如果你想恢复删除的文件，就在删除的记录项点击右键，选择 &lt;code&gt;Revert&lt;/code&gt; 即可恢复。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/3/25/169b58305c4197f7?w=1070&amp;amp;h=386&amp;amp;f=png&amp;amp;s=64276&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;拥抱vim远离鼠标&quot;&gt;03. 拥抱Vim，远离鼠标&lt;/h2&gt;
&lt;p&gt;在大多数场景之下，使用鼠标的效率和精准度，是远不如键盘快捷键的（前提是你已经相当熟练的掌握了快捷键），这个你得承认吧。&lt;/p&gt;
&lt;p&gt;Vi 可以满足你对文本操作的所有需求，比可视化界面更加效率，更加 geek。如果你和我一样，是忠实的 vim 粉。在安装完 Pycharm 完后，肯定会第一时间将 &lt;code&gt;ideaVim&lt;/code&gt; 这个插件也装上，它可以让我们在 Pycharm 中 使用 vim 来编辑代码。&lt;/p&gt;
&lt;p&gt;安装方法如下，安装完后需要重启 Pycharm 生效。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/3/25/169b583085206944?w=1886&amp;amp;h=1022&amp;amp;f=png&amp;amp;s=179176&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;代码模板效率编码&quot;&gt;04. 代码模板，效率编码&lt;/h2&gt;
&lt;p&gt;Pycharm 提供的这个代码模板，可以说是相当实用的一个功能了。它可以在你新建一个文件时，按照你预设的模板给你生成一段内容，比如解释器路径，编码方法，作者详细信息等&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/3/25/169b583086892a52?w=1582&amp;amp;h=742&amp;amp;f=png&amp;amp;s=153737&quot;/&gt;&lt;/p&gt;
&lt;p&gt;按照上图模板，生成的效果如下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/3/25/169b58308727343c?w=858&amp;amp;h=410&amp;amp;f=png&amp;amp;s=43892&quot;/&gt;&lt;/p&gt;
&lt;p&gt;除了新建文件时可以初始化文件，在开发编写代码时，也同样使用 Pycharm 中自带的实用的代码模板，提高你的编码效率。&lt;/p&gt;
&lt;p&gt;当你在键盘中敲入 &lt;code&gt;Command&lt;/code&gt; + &lt;code&gt;J&lt;/code&gt; 时，就可以调出一个面板，从下图可以看出里面有许多预设的模板。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/3/25/169b583089dfd3e6?w=854&amp;amp;h=434&amp;amp;f=png&amp;amp;s=52162&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果我们想选择最后一个 main ，可以继续键入 main，然后就可以直接生成如下这段平时都要手动敲入的代码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/3/25/169b583095b5a006?w=798&amp;amp;h=454&amp;amp;f=gif&amp;amp;s=702167&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里再举个例子，for 循环 可以这样写。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/3/25/169b5830ac1cead8?w=734&amp;amp;h=386&amp;amp;f=gif&amp;amp;s=1173386&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;使用书签快速定位&quot;&gt;05. 使用书签，快速定位&lt;/h2&gt;
&lt;p&gt;都我在看框架的源代码时，最常使用的是 &lt;code&gt;Command&lt;/code&gt; + &lt;code&gt;B&lt;/code&gt; （也就是 command + 鼠标左键 ）一层一层地往里深入，但是当源代码比较多，可能一整个事件过程涉及十几文件，函数调用错综复杂，对于一个庞大的项目来说，有用的可能就几个关键函数，每次要找到这几个函数，都要重头从源函数再一层一层的找下去，这样实在太麻烦了，我常常因此把自己给看晕了。&lt;/p&gt;
&lt;p&gt;直到后来我发现了 Pycharm 这个书签功能。&lt;/p&gt;
&lt;p&gt;使用书签功能，我可以在在关键的位置打上书签，想看的时候，调用书签，快速定位即可。&lt;/p&gt;
&lt;p&gt;使用它，你需要记住下面下两个快捷键&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Command + F11    打上书签
Shift + F11      展示所有书签&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在你要打书签的位置，按下 &lt;code&gt;Command&lt;/code&gt; + &lt;code&gt;F11&lt;/code&gt; ，你可以给这个位置加个序号，可以是数字也可以是字母，假如在下面这个位置 加了 &lt;code&gt;1&lt;/code&gt; 这个序号，下次你就可以使用 &lt;code&gt;Control&lt;/code&gt; + &lt;code&gt;1&lt;/code&gt; 直接跳转到这个位置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/3/25/169b5830ad6c79f0?w=1582&amp;amp;h=798&amp;amp;f=png&amp;amp;s=276753&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然你也可以不加，不加的话就是匿名书签了。你可以使用 &lt;code&gt;Shift&lt;/code&gt; + &lt;code&gt;F11&lt;/code&gt; 展示所有的书签，再进行跳转。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/3/25/169b5844a56c279d?w=1080&amp;amp;h=368&amp;amp;f=jpeg&amp;amp;s=163968&quot; alt=&quot;关注公众号，获取最新干货！&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 25 Mar 2019 15:47:00 +0000</pubDate>
<dc:creator>站在两个世界的边缘</dc:creator>
<og:description>PyCharm 是大多数 Python 开发者的首选 IDE，每天我们都在上面敲着熟悉的代码，写出一个又一个奇妙的功能。 一个每天都在使用的工具，如果能掌握一些高效的使用技巧，肯定会给我们的开发效率带</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wongbingming/p/10597686.html</dc:identifier>
</item>
<item>
<title>C# 曲线上的点（一） 获取指定横坐标对应的纵坐标值 - 唐宋元明清2188</title>
<link>http://www.cnblogs.com/kybs0/p/10596426.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kybs0/p/10596426.html</guid>
<description>&lt;p&gt;获取直线上的点，很容易，那曲线呢？二阶贝塞尔、三阶贝塞尔、多段混合曲线，如何获取指定横坐标对应的纵坐标？&lt;/p&gt;
&lt;p&gt;如下图形：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/685541/201903/685541-20190325213328671-1975814710.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt; 实现方案&lt;/h2&gt;
&lt;h3&gt;曲线上的点集&lt;/h3&gt;
&lt;p&gt;Geometry提供了一个函数GetFlattenedPathGeometry，可以获取其绘制后显示的多边形。&lt;/p&gt;
&lt;p&gt;我们可以通过其Figures -&amp;gt; PathSegment -&amp;gt; Point，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; List&amp;lt;Point&amp;gt;&lt;span&gt; GetPointsOnPath(Geometry geometry)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         List&amp;lt;Point&amp;gt; points = &lt;span&gt;new&lt;/span&gt; List&amp;lt;Point&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         PathGeometry pathGeometry =&lt;span&gt; geometry.GetFlattenedPathGeometry();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; figure &lt;span&gt;in&lt;/span&gt;&lt;span&gt; pathGeometry.Figures)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; ordinateOnPathFigureByAbscissa =&lt;span&gt; GetOrdinateOnPathFigureByAbscissa(figure);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;            points.AddRange(ordinateOnPathFigureByAbscissa);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; points;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; List&amp;lt;Point&amp;gt;&lt;span&gt; GetOrdinateOnPathFigureByAbscissa(PathFigure figure)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         List&amp;lt;Point&amp;gt; outputPoints = &lt;span&gt;new&lt;/span&gt; List&amp;lt;Point&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         Point current =&lt;span&gt; figure.StartPoint;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;foreach&lt;/span&gt; (PathSegment s &lt;span&gt;in&lt;/span&gt;&lt;span&gt; figure.Segments)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             PolyLineSegment segment = s &lt;span&gt;as&lt;/span&gt;&lt;span&gt; PolyLineSegment;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             LineSegment line = s &lt;span&gt;as&lt;/span&gt;&lt;span&gt; LineSegment;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;            Point[] points;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (segment != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                 points =&lt;span&gt; segment.Points.ToArray();
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (line != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                 points = &lt;span&gt;new&lt;/span&gt;&lt;span&gt;[] { line.Point };
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                 &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; InvalidOperationException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;尼玛！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;             &lt;span&gt;foreach&lt;/span&gt; (Point next &lt;span&gt;in&lt;/span&gt;&lt;span&gt; points)
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; ellipse = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Ellipse()
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;                     Width = &lt;span&gt;6&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                     Height = &lt;span&gt;6&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;                     Fill =&lt;span&gt; Brushes.Blue
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;                };
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;                Canvas.SetTop(ellipse, next.Y);
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;                Canvas.SetLeft(ellipse, next.X);
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;                ContentCanvas.Children.Add(ellipse);
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;                 current =&lt;span&gt; next;
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; outputPoints;
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最终界面显示，获取的点集是如下布局的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/685541/201903/685541-20190325220121639-1366721564.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;曲线上的点&lt;/h3&gt;
&lt;p&gt;我们发现，拐角越大，获取的点越密集。所以可以看出，角度变化越大，需要的点越密集。&lt;/p&gt;
&lt;p&gt;直线通过斜率很容易获取横坐标对应的纵坐标，那么这有如此多点的曲线呢？&lt;/p&gt;
&lt;p&gt;我们是不是可以曲线救国，通过相邻的俩个点画直接，从而获取俩点间的点坐标呢？我们来尝试下~&lt;/p&gt;
&lt;p&gt;还是原来的代码，传入一个X坐标参数即可。&lt;/p&gt;
&lt;p&gt;然后俩点之间，获取X坐标对应的Y坐标：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; TryGetOrdinateOnVectorByAbscissa(Point start, Point end, &lt;span&gt;double&lt;/span&gt; abscissa, &lt;span&gt;out&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; ordinate)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             ordinate = &lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; ((start.X &amp;lt; end.X &amp;amp;&amp;amp; abscissa &amp;gt;= start.X &amp;amp;&amp;amp; abscissa &amp;lt;= end.X) ||
&lt;span&gt; 5&lt;/span&gt;                 (start.X &amp;gt; end.X &amp;amp;&amp;amp; abscissa &amp;lt;= start.X &amp;amp;&amp;amp; abscissa &amp;gt;=&lt;span&gt; end.X))
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; xRatio = (abscissa - start.X) / (end.X -&lt;span&gt; start.X);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; yLength = end.Y -&lt;span&gt; start.Y;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; y = yLength * xRatio +&lt;span&gt; start.Y;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 ordinate =&lt;span&gt; y;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;点击窗口，在曲线上，获取点击处X坐标对应的点。效果图如下：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/685541/201903/685541-20190325215739688-230211013.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; Github： &lt;a href=&quot;https://github.com/Kybs0/PointOnGeometryDemo&quot; target=&quot;_blank&quot;&gt;Demo&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 25 Mar 2019 14:37:00 +0000</pubDate>
<dc:creator>唐宋元明清2188</dc:creator>
<og:description>获取直线上的点，很容易，那曲线呢？二阶贝塞尔、三阶贝塞尔、多段混合曲线，如何获取指定横坐标对应的纵坐标？ 如下图形： 实现方案 曲线上的点集 Geometry提供了一个函数GetFlattenedPa</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kybs0/p/10596426.html</dc:identifier>
</item>
<item>
<title>JavaIO流中的拷贝 - 吴永吉</title>
<link>http://www.cnblogs.com/wuyongji/p/10597200.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wuyongji/p/10597200.html</guid>
<description>&lt;p&gt;　　JavaIO流中对数据的操作尤为重要，掌握了基本的拷贝操作，才能将各种数据源的操作联系起来。&lt;/p&gt;
&lt;p&gt;　　先来看看对文件夹的拷贝吧：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * 利用递归实现文件夹的拷贝操作
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt; * 分析：判断
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; *     是文件：调用拷贝文件的方法fileCopy(...)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt; *     是文件夹：创建文件夹，并使用递归实现子文件夹/子文件的判断及操作
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; src：要拷贝的文件夹源头
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; dest：要拷贝到的文件夹源头
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; dirCopy(File src,File dest) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(src.isFile()) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;是文件&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        fileCopy(src, dest);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     }&lt;span&gt;else&lt;/span&gt; { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;是文件夹&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        dest.mkdirs();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(File subSrc:src.listFiles()) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历子文件夹/子文件&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;             dirCopy(subSrc, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; File(dest,subSrc.getName()));
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　对文件的拷贝，我们可以这样写：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * 实现文件的拷贝
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt; *     输入流读取的同时输出流进行写出
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; src：要拷贝的文件源头
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; dest：要拷贝到的文件源头
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; fileCopy(File src,File dest) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.创建源
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.选择流&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     InputStream is = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     OutputStream os = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         is = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileInputStream(src);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         os = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileOutputStream(dest);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;3.操作：分段读取并写出&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; len; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;接收长度&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;byte&lt;/span&gt;[] flush = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[1024]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;缓冲容器，一次读写1k&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt;((len=is.read(flush))!=-1&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             os.write(flush, 0&lt;span&gt;, len);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         os.flush(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;写完手动刷新，避免数据在缓冲容器中（当然当流关闭时会自动刷新）&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;     }&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(FileNotFoundException e) {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        e.printStackTrace();
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     }&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(IOException e) {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        e.printStackTrace();
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     }&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;4.关闭流，分别关闭，先打开的后关闭&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(os!=&lt;span&gt;null&lt;/span&gt;) {    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断是否为空，避免空指针异常&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;                os.close();
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         }&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(IOException e) {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(is!=&lt;span&gt;null&lt;/span&gt;) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断是否为空，避免空指针异常&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt; &lt;span&gt;                is.close();
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         }&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(IOException e) {
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　以上代码只能实现对文件的拷贝操作，当然适合于拷贝任何格式的数据文件，包括视频、音频、图片等等。但是如果我想将一张图片拷贝到字节数组中呢（这里的字节数组相当于内存），也就是说从文件到字节数组，或着是从字节数组到文件。那么以上代码就具有局限性了，也不易于扩展，来看以下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * 对接流
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; is：输入流
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; os：输出流
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; copy(InputStream is,OutputStream os) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.创建源
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.选择流&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;3.操作&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;byte&lt;/span&gt;[] flush = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[1024]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;缓冲容器&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; len; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;接收长度&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt;((len=is.read(flush))!=-1&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             os.write(flush, 0&lt;span&gt;, len);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        os.flush();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     }&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(FileNotFoundException e) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        e.printStackTrace();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     }&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(IOException e) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        e.printStackTrace();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     }&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(os!=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;                os.close();
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         }&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(IOException e) {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(is!=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;                is.close();
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         }&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(IOException e) {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　嗯，这样就可以实现以上要求了，但是我们发现：关闭资源的操作一直在，而且都一样，我们可以封装一下，这样在finally中就可以直接调用了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * 关闭的方法
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; is：输入流
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; os：输出流
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; close(InputStream is,OutputStream os) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(os!=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            os.close();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     }&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(IOException e) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        e.printStackTrace();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(is!=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            is.close();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     }&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(IOException e) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        e.printStackTrace();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　好了，看看封装的代码，幸亏只有两个流，要是流很多咋办，形参太多，但是我们发现输入流InputStream和输出流OutputStream都实现了同一个接口：Closeable。嗯，这样，我们可以试试JDK1.5的新特性：可变参数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * 封装的关闭方法
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; ios：要关闭的流
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; close(Closeable... ios) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Closeable io:ios) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(io!=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;                io.close();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         }&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(IOException e) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　现在看似完美了，但我还不太满意，有时候，我觉得手动关闭资源太麻烦了。别急，来看看JDK1.7的新特性：try...with...resources(自动关闭资源)。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * JDK1.7之后的新特性 try...with...resources:自动关闭资源
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt; * 文件的拷贝
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; srcPath：要拷贝的源头
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; destPath：要拷贝到的目的地
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; copy1(String srcPath,String destPath) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.创建源&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     File src = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; File(srcPath);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     File dest = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; File(destPath);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.选择流&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;(InputStream is = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileInputStream(src);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         OutputStream os = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileOutputStream(dest)) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;3.操作&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;byte&lt;/span&gt;[] flush = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[1024]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;缓冲容器&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; len; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;接收长度&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt;((len=is.read(flush))!=-1&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             os.write(flush, 0&lt;span&gt;, len);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        os.flush();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     }&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(FileNotFoundException e) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        e.printStackTrace();
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     }&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(IOException e) {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        e.printStackTrace();
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　大家发现：try里面写的好繁琐，别急，看看JDK1.9的改进版（不过要求你所要关闭的资源是final或等效于final的变量）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * JDK1.9之后对 try...with...resources的改进
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt; * 对接流
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; is：输入流
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; os：输出流
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; copy2(InputStream is,OutputStream os) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.创建源
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.选择流&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt;(is;os) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;3.操作&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;byte&lt;/span&gt;[] flush = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[1024]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;缓冲容器&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; len; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;接收长度&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt;((len=is.read(flush))!=-1&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             os.write(flush, 0&lt;span&gt;, len);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        os.flush();
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     }&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(FileNotFoundException e) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        e.printStackTrace();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     }&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(IOException e) {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        e.printStackTrace();
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　哈哈，看上去是不是简洁很多。对的，随着JDK的新版本发布，越来越多的新技术，也使得代码看起来越简洁，不过对我们的要求也只会越来越高。前段时间JDK12已经出来了，还没用，不过我相信肯定会有好多的新特性，期待，也看好Java，加油。&lt;/p&gt;
</description>
<pubDate>Mon, 25 Mar 2019 14:24:00 +0000</pubDate>
<dc:creator>吴永吉</dc:creator>
<og:description>JavaIO流中对数据的操作尤为重要，掌握了基本的拷贝操作，才能将各种数据源的操作联系起来。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wuyongji/p/10597200.html</dc:identifier>
</item>
<item>
<title>自制操作系统Antz(15)——实现启动界面 - AntzUhl</title>
<link>http://www.cnblogs.com/LexMoon/p/antz15.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/LexMoon/p/antz15.html</guid>
<description>&lt;p&gt;🎓 The language executed in the Antz system.&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;本节不涉及OS底层内容，只是关于图片放大显示时效果处理的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h6 id=&quot;antz系统更新地址&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/LexMoon/category/1262287.html&quot;&gt;Antz系统更新地址&lt;/a&gt;&lt;/h6&gt;
&lt;h6 id=&quot;antz项目地址&quot;&gt;&lt;a href=&quot;https://github.com/CasterWx/AntzOS&quot;&gt;Antz项目地址&lt;/a&gt;&lt;/h6&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&lt;img src=&quot;https://github.com/CasterWx/AntzOS/raw/master/screen/runShow.gif&quot;/&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;图片来源:&lt;a href=&quot;https://github.com/phodal/daily&quot;&gt;phodal/daily&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;(orz左上角是在处理原图时自己签的名)&lt;/p&gt;
&lt;p&gt;为了节省镜像空间，我将图片从2000乘800左右图片压缩为108乘60的24色大小的图片，计算为RGB值之后也有近6400左右像素点。但是要将它写入显存，展现在用户眼中，效果表明是很差的，我们的分辨率为1080x768，数十倍于这张图片。&lt;/p&gt;
&lt;p&gt;为了解决显示效果的问题，这里有两种解决方法。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;一.-像素点区域化&quot;&gt;一. 像素点区域化&lt;/h2&gt;
&lt;p&gt;这个方法是我自己起的名字，大致意思也如标题所示，就是将一个本来应该显示在(x1,y1)位置的像素点区域化显示，将其RGB值覆盖在(x1,y1)至(x1+x,y1+y)的这片区域。这个方法实现起来非常简单，但是效果&lt;code&gt;极差&lt;/code&gt;，最后显示出来的效果就好像是&lt;code&gt;我的世界&lt;/code&gt;中的超大像素点效果。&lt;/p&gt;
&lt;p&gt;图示大概如这样:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/LexMoon/1246510/o_12310.png&quot; alt=&quot;123&quot;/&gt;&lt;/p&gt;
&lt;p&gt;附上简单实现。&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;void to_show(){
int i, x, y ;
int k ;
k = 0 ;
for (y = 0; y &amp;lt; 60; y++) {
for (x = 0; x &amp;lt; 108; x++){
// 在(x*10,y*13)至(x*10+10,y*13+13)这片区域填充RGB值bmp[k]
print_image(x*10,y*13,x*10+10,y*13+13,bmp[k]);
k++;
}
}
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在虚拟机中效果如下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/CasterWx/AntzOS/raw/master/screen/my.gif&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;二.-双线性插值&quot;&gt;二. 双线性插值&lt;/h2&gt;
&lt;p&gt;在使用第一种粗略暴力的方式实现启动动画之后，第二天的数字图像处理课程中，听到老师讲matlab中的图片放大缩小函数的原理，了解了&lt;code&gt;双线性插值&lt;/code&gt;这个算法，于是想到用这个方法来重新实现启动界面。&lt;/p&gt;
&lt;p&gt;双线性插值的基本原理是，假设源图像大小为MxN，目标图像为AxB。那么两幅图像的边长比分别为：M/A和N/B。这两个比例值一般是浮点数。目标图像的第（i,j）个像素点（i行j列）可以通过边长比对应回源图像。其对应坐标为（i&lt;em&gt;m/a,j&lt;/em&gt;n/b）。显然，这个对应坐标一般来说不是整数，而非整数的坐标是无法在图像这种离散数据上使用的。双线性插值通过寻找距离这个对应坐标最近的四个像素点，来计算该点的值（灰度值或者RGB值）。&lt;/p&gt;
&lt;p&gt;其实可以理解为通过其周围的四个点，&lt;code&gt;中和&lt;/code&gt;出这片区域中的其他点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/LexMoon/1246510/o_213123.png&quot; alt=&quot;2123&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/CasterWx/AntzOS/blob/master/screen/1.png?raw=true&quot; alt=&quot;s&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们想得到一张放大的图片，现在有&lt;code&gt;原图像&lt;/code&gt;和&lt;code&gt;目标图像&lt;/code&gt;。那么，有一个最基本的问题摆在我们面前：是遍历&lt;code&gt;原图像&lt;/code&gt;呢，还是遍历&lt;code&gt;目标图像&lt;/code&gt;呢？&lt;/p&gt;
&lt;p&gt;在实践的过程中，通常都是遍历&lt;code&gt;目标图像&lt;/code&gt;的。因为这样可以确保&lt;code&gt;目标图像&lt;/code&gt;的每一个像素都是有值的。&lt;/p&gt;
&lt;p&gt;就拿上图的例子来说，右图&lt;code&gt;目标图像&lt;/code&gt;中的 [0,0] 点很顺利的找到了左图&lt;code&gt;原图像&lt;/code&gt;中与自己对应的 [0,0] 点。然后 [0,1] 点就懵逼了，它应该找[0,0.33]点吗？没有这个点啊，所以[0,0.33]的值是需要四个点来进行拟态的。&lt;/p&gt;
&lt;p&gt;插值法除了双线性插值还有最临近插值，线性插值。&lt;/p&gt;
&lt;p&gt;最临近插值可以理解为取值为最近的一个像素点，线性插值是在周围两个像素点中取一个(根据两边距离决定)折中值，很明显它们的作用范围均是线性一维。&lt;/p&gt;
&lt;p&gt;再来说双线性插值，它可以取空间中的四个点来做拟态取值。&lt;/p&gt;
&lt;p&gt;大概理解就是如此，具体实现可以借助公式,下面给出百度百科的公式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=b1170590fc039245b5b8e95de6fdcfa7/54fbb2fb43166d223d93e6c9462309f79152d283.jpg&quot; alt=&quot;2&quot;/&gt;&lt;/p&gt;
&lt;p&gt;已知的红色数据点与待插值得到的绿色点&lt;/p&gt;
&lt;p&gt;假如我们想得到未知函数f在点P= (x,y) 的值，假设我们已知函数f在Q11 = (x1,y1)、Q12 = (x1,y2),Q21 = (x2,y1) 以及Q22 = (x2,y2) 四个点的值。&lt;/p&gt;
&lt;p&gt;首先在x方向进行线性插值，得到R1和R2，然后在y方向进行线性插值，得到P.&lt;br/&gt;这样就得到所要的结果f(x,y).&lt;/p&gt;
&lt;p&gt;其中红色点Q11,Q12,Q21,Q22为已知的4个像素点.&lt;/p&gt;
&lt;p&gt;第一步：X方向的线性插值，在Q12,Q22中插入蓝色点R2，Q11，Q21中插入蓝色点R1；&lt;/p&gt;
&lt;p&gt;第二步 ：Y方向的线性插值 ,通过第一步计算出的R1与R2在y方向上插值计算出P点。&lt;/p&gt;
&lt;p&gt;线性插值的结果与插值的顺序无关。首先进行y方向的插值，然后进行x方向的插值，所得到的结果是一样的。双线性插值的结果与先进行哪个方向的插值无关。&lt;/p&gt;
&lt;p&gt;如果选择一个坐标系统使得 的四个已知点坐标分别为 (0, 0)、(0, 1)、(1, 0) 和 (1, 1)，那么插值公式就可以化简为&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;f(x,y)=f(0,0)(1-x)(1-y)+f(1,0)x(1-y)+f(0,1)(1-x)y+f(1,1)xy&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在x与y方向上，z值成单调性特性的应用中，此种方法可以做外插运算，即可以求解Q1~Q4所构成的正方形以外的点的值。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike60%2C5%2C5%2C60%2C20/sign=afc7c8991bd5ad6ebef46cb8e0a252be/0df3d7ca7bcb0a468fc378646b63f6246a60af8e.jpg&quot; alt=&quot;233&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;f(x,y1) ≈ (x2−x / x2−x1) * f(Q11) + (x−x1 / x2−x1) * f(Q21),
f(x,y2) ≈ (x2−x / x2−x1) * f(Q12) + (x−x1 / x2−x1) * f(Q22).
f(x,y) ≈ (y2−y / y2−y1) * f(x,y1) + (y−y1 / y2−y1) * f(x,y2)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;int index = 0 ;
for(y=0;y&amp;lt;768;y++){
for(x=0;x&amp;lt;1080;x++){
for(int i=0;i&amp;lt;60;i++){
for(int j=0;j&amp;lt;108;j++){
int getx1 = ((108+13-y)/13)*bmp[index*108+60] + (y/13)*bmp[index*108+60+1] ;
int getx2 = ((108+13-y)/13)*bmp[(index+1)*108+60] + (y/13)*bmp[(index+1)*108+60+1] ;
int getRgb = (i/10)*getx1 + ((60-i)/10)*getx2 ;
print_image(x,y,getRgb);
}
}
}
index ++ ;
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 25 Mar 2019 14:16:00 +0000</pubDate>
<dc:creator>AntzUhl</dc:creator>
<og:description>AntzScript 🎓 The language executed in the Antz system. 本节不涉及OS底层内容，只是关于图片放大显示时效果处理的。 'Antz系统更新地址' '</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/LexMoon/p/antz15.html</dc:identifier>
</item>
<item>
<title>.NET Core 给使用.NET的公司所带来的机遇 - 张善友</title>
<link>http://www.cnblogs.com/shanyou/p/10597046.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shanyou/p/10597046.html</guid>
<description>&lt;h4&gt;&lt;span&gt;今晚在余晟的微信公众号看到了一篇文章《 从.NET/C#开发的“后继无人”说起：&lt;/span&gt; &lt;a title=&quot;https://mp.weixin.qq.com/s/rO2d0xZ58Z2syqT7AaNT3w&quot; href=&quot;https://mp.weixin.qq.com/s/rO2d0xZ58Z2syqT7AaNT3w&quot;&gt;&lt;span&gt;https://mp.weixin.qq.com/s/rO2d0xZ58Z2syqT7AaNT3w&lt;/span&gt;&lt;/a&gt;&lt;span&gt;》。 这篇文章以从.NET/C#开发的“后继无人” 引出了推广极客时间的课程 刘超的《趣谈Linux操作系统》，通篇看下来这明显是 刘超的《趣谈Linux操作系统》的软文。&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/510/201903/510-20190325220422764-1277947783.png&quot;&gt;&lt;img width=&quot;576&quot; height=&quot;297&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/510/201903/510-20190325220423260-1832302018.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;推广无可厚非，但是这种以标题党形式贬低.NET，让几十万的.NETer 蒙羞是一种无耻的操作，何况余晟 是一位小有名气的博主，这篇文章转发在朋友圈，光是这个标题就够有杀伤力的了。这也是我看到这篇文章特别想写一篇短文来表达一下心中的999个伤害。&lt;/p&gt;
&lt;p&gt;我也有一个公众号“dotnet跨平台”，其中的主题就是微软在2014年开始开源的.NET Core, 即将在今年发布3.0版本， .NET Core是开源跨平台的.NET ,而且他的兄弟Mono也是开源的，至今已经有17年历史，大名鼎鼎的Unity3d 就是基于Mono。.NET Core/Mono早就可以跨平台运行于Linux/Mac系统之下，而且微软把Linux 作为一等公民对待。目前我就是使用Windows 10作为开发工具，使用.NET Core开发的系统通过容器化运行于k8s 之下。微软的Visual Studio 和Visual Studio Code 为容器化应用程序开发提供了一流的体验。&lt;/p&gt;
&lt;p&gt;余晟完全可以这么写： 如果要把技术栈从.NET/c#切换为.NET Core/C#, 可以完美运行于Linux 之下，借助于kubernetes 容器调度，最主要有什么困难。&lt;/p&gt;
&lt;p&gt;接下来想针对《 从.NET/C#开发的“后继无人”说起》里面的一些逻辑错误给大家分享下：&lt;/p&gt;
&lt;p&gt;市场上招不到多少.NET/C#的开发新人： 这是一个毫无根据的主观臆断。据我所知，还是有不少学校开设了C#编程的，至少我就知道有好几个学校，社会上的培训机构也有不少培训以Unity3d编程为背景的c#培训，培训机构确实很少批量生产快餐式的.NET程序员了，这些培训机构都一窝蜂的涌向Java培训，导致的结果是现在Java快餐式程序员满大街都是，这些快餐式程序员也不是很多公司所期望的。倒是有不少.NET 程序员质量非常高，他们通过参与开源项目进行着高质量的自我成长，身边有不少95后程序员新人，他们的水平都是很不错的。&lt;/p&gt;
&lt;p&gt;微软自己的Azure 云服务，也不强调Windows特性了： 微软从2014年新的CEO 萨提亚•纳德拉上台以来，在他第一本书《刷新：重新发现商业与未来》全景回顾了萨提亚的变革路径，如在硬件Surface电脑上的投入，在混合现实、人工智能和量子计算三大领域的战略布局等；系统总结了他的核心管理思想，即任何组织和个人，达到某个临界点时，都需要自我刷新。 微软自我刷新，今天微软的市值已经突破9000亿美元，继续向一万亿进军，这里最重要的一个平台就是Azure 云服务，微软Azure 拥抱开源，Azure 可以运行主流的开源解决方案，我们已经从跨平台进入跨云时代，我们开发的应用系统都是针对跨多个云为要求的，Windows 服务器和Linux服务器一样已经下沉为云服务的底层一个组件，云平台已经上升为新时代的操作系统。&lt;/p&gt;
&lt;p&gt;如果把技术栈从.NET/C#切换到Java： .NET/C# 目前已经在跨平台这条道理上走过了10多年，.NET Core更是把.NET 的跨平台推向一个新的高度，.NET Core借鉴了.NET Framework的最佳实践，并将软件工程的最新进展结合在一起。这些是.NET Core的一些显着特征。 同一个库可以在后台服务“本地”或云中运行，也可以在手机，平板电脑或桌面上运行的客户端应用程序中运行。与其为iOS，Android和Windows构建单独的应用程序，您可以构建一个适用于所有平台的应用程序。.NET Core是小型和完美的容器，可以轻松扩展并缩短开发时间。 .NET Core和.NET Standard Library建立了一个通用平台。过去，当新版本的操作系统或新设备出现时，开发人员有责任重新构建新平台的应用程序或库，并分发更新。使用.NET Core，不需要重建和重新分配。只要新的平台支持你所有的依赖库，它就支持你的应用程序。采用.NET Core让你在以往在.NET上的投资更有价值，我们来看最新asp.net core 性能已经跨入顶级序列，最新一期的TechEmpower基准测试&lt;a href=&quot;https://www.techempower.com/benchmarks/#section=data-r17&amp;amp;hw=ph&amp;amp;test=plaintext&quot;&gt;第十七轮测试&lt;/a&gt;：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/510/201903/510-20190325220423826-2026307556.png&quot;&gt;&lt;img width=&quot;595&quot; height=&quot;319&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/510/201903/510-20190325220424397-387772881.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET Core和Java都是开源跨平台的，我们可以来比较一下.NET Core和Java的开源协议，.NET Core是以MIT协议开源， Java是GPL协议开源。 Java 8 SDK升级Oracle要收费这件事对于很多小公司是有着重大的影响的。众多没有能力开发维护OpenJDK的公司完全可以转向更具有竞争力的.NET Core，.NET Core从属于.NET基金会，由微软进行官方支持。使用最宽松的MIT和Apache 2开源协议，文档协议遵循CC-BY。这将允许任何人任何组织和企业任意处置，包括使用，复制，修改，合并，发表，分发，再授权，或者销售。唯一的限制是，软件中必须包含上述版 权和许可提示，后者协议将会除了为用户提供版权许可之外，还有专利许可，并且授权是免费，无排他性的(任何个人和企业都能获得授权)并且永久不可撤销，用户使用.NET Core完全不用担心收费问题，你可以很自由的部署在任何地方,。&lt;/p&gt;
&lt;p&gt;现在是云计算时代，.NET Core已经磨练5年时间，准备好了迎接云计算时代的云原生应用开发，云系统中，用更少的硬件为更高密度的用户提供服务是非常重要的。应用程序的占位面积越小，密度越高。容器只包含应用程序及其依赖项。文件大小要小很多倍，启动时间以秒为单位，只有应用程序加载到内存中，容器保证在任何主机上工作。鉴于容器的明显优势，.NET Core的设计决定之一就是使其成为模块化。这意味着你的.NET Core应用程序可以被&quot;发布&quot;，使得它和它的所有依赖关系在一个地方，这很容易放入容器。&lt;/p&gt;
&lt;p&gt;2018年年末的听到大量的互联网公司裁员消息，但是我服务这几家客户都有很强烈的招聘.NET Core开发人员的需求，这是大量学习Java的同学转向.NET Core平台的好时机，我一直认为做Java开发的同学比做传统.NET的人员更容易用好.NET Core, Java相比C#，在使用了C#后你不会再去想用Java，而且.NET Core有你非常熟悉的Spring Cloud那一套约定的编程范式，然而见过很多.NET 开发人员， 依赖注入都没用过，更别说用Linux了。在这里我没有贬低.NET开发人员的意思，技术更多的还是要靠自己的努力，我们努力一起成为一群不被时代抛弃的程序猿。&lt;/p&gt;
</description>
<pubDate>Mon, 25 Mar 2019 14:04:00 +0000</pubDate>
<dc:creator>张善友</dc:creator>
<og:description>今晚在余晟的微信公众号看到了一篇文章《 从.NET/C#开发的“后继无人”说起： https://mp.weixin.qq.com/s/rO2d0xZ58Z2syqT7AaNT3w》。 这篇文章以从.</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shanyou/p/10597046.html</dc:identifier>
</item>
<item>
<title>HashMap源码分析 - 炭烧生蚝</title>
<link>http://www.cnblogs.com/tanshaoshenghao/p/10596919.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tanshaoshenghao/p/10596919.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;本文按以下顺序叙述:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;把源码啃下来有一种很爽的感觉, 相信你读完后也能体会到~ 如发现有误, 欢迎指出.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr/&gt;&lt;h3 id=&quot;1&quot;&gt;在开始之前, 先通过图例对HashMap建立感性认识&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;如果不清楚哈希表是一种什么样的数据结构的话, 可以先看书了解一下, 如果觉得看书麻烦, 推荐看一下浙大数据公开课中的&lt;a href=&quot;https://www.icourse163.org/course/zju0901-93001?from=study&quot;&gt;第十一讲 散列查找&lt;/a&gt;, 了解了这种数据结构后理解HashMap就没有问题了.&lt;/li&gt;
&lt;/ul&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/tanshaoshenghao/1426602/o_HashMap1.png&quot;/&gt;&lt;ul&gt;&lt;li&gt;HashMap由一个数组组成, 对于每个键值对, 会通过对键进行哈希计算, 直接得出该键值对存储的位置, 保证了存取键值的操作拥有极其优良的时间性能.&lt;/li&gt;
&lt;li&gt;当两个键值对存储的位置发生冲突时, 会通过链表把键值对在对应的位置上用链表连起来. 如果链太长的话, (在JDK1.8后)会把链表转换为存取效率更高的红黑树, 以保证HashMap的整体存取效率.&lt;/li&gt;
&lt;li&gt;HashMap中有专门记录容量的参数, 如果容量增大到一定的值会进行扩容, 使得HashMap散列更均匀, 整体存取效率更高.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr/&gt;&lt;h3 id=&quot;2&quot;&gt;下面是基于官方文档的粗糙翻译&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;HashMap和Hashtable是相似的, 只不过它是线程不安全的, 并且允许null值. 它不能保证键值对的有序性, 键值对的顺序甚至会在使用的过程中发生变化 (扩容等操作会重新进行哈希操作, 键值对的位置发生变化).&lt;/li&gt;
&lt;li&gt;在哈希函数能散列均匀的前提下, 它能保证put和get两个基本操作有稳定的时间性能.&lt;/li&gt;
&lt;li&gt;遍历HashMap所需要的时间和它的容量是成正比的, 如果迭代性能很重要, 请不要把初始容量设置得过高(或把负载因子设置得过小, 过小则会经常进行重新哈希的操作).&lt;/li&gt;
&lt;li&gt;两个参数影响着HashMap的性能: 初始容量和负载因子. 这里的初始容量指创建Hash表时所开辟的内存空间. 负载因子是一个小数, 用于判断HashMap是否已经满了. 当map中的元素超过了负载因子和当前容量的乘积后, HashMap会进行扩容, 大概扩为原来大小的两倍. (比如说负载因子是0.75, 初始容量是100, 当实际容量达到&lt;code&gt;0.75*100=75&lt;/code&gt;时, HashMap就会进行扩容)&lt;/li&gt;
&lt;li&gt;一般来说, 默认负载因子(0.75)在时间和空间成本之间提供了很好的平衡。设置一个更大的负载因子值虽然节省了空间，但是增加了查找的时间成本(查找时间的增加会影响HashMap的大部分操作，包括get和set)，所以在设置HashMap的初始容量的时候要考虑map中预期的装填元素数量和负载因子的大小，以最大限度减少扩容的次数.&lt;/li&gt;
&lt;li&gt;要注意的是HashMap是线程不安全的, 官方建议从外部实现对HashMap的同步操作, 官方给出的建议是&lt;br/&gt;&lt;code&gt;Map m = Collections.synchronizedMap(new HashMap(...));&lt;/code&gt;&lt;br/&gt;当然也可以用&lt;code&gt;ConcurrentHashMap&lt;/code&gt;替代.&lt;/li&gt;
&lt;li&gt;使用iterator迭代器遍历HashMap时有一个fail-fast快速容错机制. 在使用迭代器遍历容器的过程中, 任何对HashMap结构进行修改的都会导致&lt;code&gt;ConcurrentModificationException&lt;/code&gt;并发修改异常. 如果不想这个异常出现, 但又想删除某个元素, 就要调用iterator迭代器自身的&lt;code&gt;remove&lt;/code&gt;方法. 如果没有这个机制, 在迭代的过程中增删元素可能会导致HashMap结构的变更(比如扩容), 继续遍历的时候便会出错, 这一机制把这种风险扼杀在摇篮中.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr/&gt;&lt;h3 id=&quot;3&quot;&gt;源码分析&lt;/h3&gt;
&lt;h4 id=&quot;hashmap的创建&quot;&gt;1. HashMap的创建&lt;/h4&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在创建HashMap之前, 先看看它的几个基本属性&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;static final int DEFAULT_INITIAL_CAPACITY = 1 &amp;lt;&amp;lt; 4; // aka 16, HashMap的默认初始容量

static final int MAXIMUM_CAPACITY = 1 &amp;lt;&amp;lt; 30;//最大容量, 如果在创建HashMap时显示指定HashMap的大小, 则不能超过这个值, 否则会默认使用这个值

static final float DEFAULT_LOAD_FACTOR = 0.75f;//默认负载因子

static final int MIN_TREEIFY_CAPACITY = 64;//当HashMap的容量大于这个值, 一个位置冲突过多时才能转为红黑树, 否则解决冲突过多的方式是扩容

static final int TREEIFY_THRESHOLD = 8;//冲突时元素会用链表连起来, 当链表的长度达到了这个值, 就会转换为红黑树

static final int UNTREEIFY_THRESHOLD = 6;//当红黑树的结点数量少于这个值的时候, 会转换回链表. 

/**
 * The next size value at which to resize (capacity * load factor).
 */
int threshold;  //当前容量与负载因子的乘积, 用于判断是否要扩容.&lt;/code&gt;
&lt;/pre&gt;

&lt;ul&gt;&lt;li&gt;HashMap一共有4个构造器. 这里只给出了无参构造, 如果清楚HashMap的使用环境, 可以使用其他有参构造设定初始容量和负载因子.&lt;/li&gt;
&lt;li&gt;如果使用无参构造创建HashMap, 会把负载因子设置为0.75, 其他额外的属性都按照默认值进行初始化.&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * The load factor used when none specified in constructor.
 */
static final float DEFAULT_LOAD_FACTOR = 0.75f;

/**
 * The load factor for the hash table.
 *
 * @serial
 */
final float loadFactor;

//无参构造
public HashMap() {
    this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;至此, HashMap创建完毕. 在创建HashMap的时候, 并没有为数组分配空间, 那么这些必要步骤什么时候做呢? 请继续看...&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;hashmap的使用&quot;&gt;2. HashMap的使用&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;HashMap的使用, 无非就是键值对的存储了, 先看存的代码.&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public V put(K key, V value) {
    return putVal(hash(key), key, value, false, true);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;我们发现在调用&lt;code&gt;put()&lt;/code&gt;方法的时候其实调用的是&lt;code&gt;putVal()&lt;/code&gt;方法.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;putVal()&lt;/code&gt;是个重要的方法, 通过方法, 我们能对HashMap有个深入的理解.&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * Implements Map.put and related methods
 *
 * @param hash hash for key                 key的hash code经过再次计算后得出hash值.
 * @param key the key                       key值
 * @param value the value to put            value值
 * @param onlyIfAbsent if true, don't change existing value     
 * @param evict if false, the table is in creation mode.
 * @return previous value, or null if none
 */
final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
               boolean evict) {
    Node&amp;lt;K,V&amp;gt;[] tab; Node&amp;lt;K,V&amp;gt; p; int n, i;  
    if ((tab = table) == null || (n = tab.length) == 0)
        n = (tab = resize()).length;
    if ((p = tab[i = (n - 1) &amp;amp; hash]) == null)
        tab[i] = newNode(hash, key, value, null);
    else {
        Node&amp;lt;K,V&amp;gt; e; K k;
        if (p.hash == hash &amp;amp;&amp;amp;
            ((k = p.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
            e = p;
        else if (p instanceof TreeNode)
            e = ((TreeNode&amp;lt;K,V&amp;gt;)p).putTreeVal(this, tab, hash, key, value);
        else {
            for (int binCount = 0; ; ++binCount) {
                if ((e = p.next) == null) {
                    p.next = newNode(hash, key, value, null);
                    if (binCount &amp;gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                        treeifyBin(tab, hash);
                    break;
                }
                if (e.hash == hash &amp;amp;&amp;amp;
                    ((k = e.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
                    break;
                p = e;
            }
        }
        if (e != null) { // existing mapping for key
            V oldValue = e.value;
            if (!onlyIfAbsent || oldValue == null)
                e.value = value;
            afterNodeAccess(e);
            return oldValue;
        }
    }
    ++modCount;
    if (++size &amp;gt; threshold)
        resize();
    afterNodeInsertion(evict);
    return null;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;分析如下:&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Node&amp;lt;K,V&amp;gt;[] tab; Node&amp;lt;K,V&amp;gt; p; int n, i;
if ((tab = table) == null || (n = tab.length) == 0)
    n = (tab = resize()).length;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;首先判断table是否为空, 如果为空的话会调用&lt;code&gt;resize()&lt;/code&gt;方法, 完成对HashMap的初始化, 为HashMap中的数组分配内存空间.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;resize()&lt;/code&gt;有两个作用: 1. 对HashMap进行初始化; 2. 进行两倍的扩容.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr/&gt;&lt;h5 id=&quot;这里插入resize方法的分析-如需跳过-点击这里&quot;&gt;这里插入&lt;code&gt;resize()&lt;/code&gt;方法的分析, 如需跳过, &lt;a href=&quot;http://www.cnblogs.com/tanshaoshenghao/p/10596919.html#4&quot;&gt;点击这里&lt;/a&gt;&lt;/h5&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    final Node&amp;lt;K,V&amp;gt;[] resize() {
        Node&amp;lt;K,V&amp;gt;[] oldTab = table;
        int oldCap = (oldTab == null) ? 0 : oldTab.length;
        int oldThr = threshold;
        int newCap, newThr = 0;
        if (oldCap &amp;gt; 0) {
            if (oldCap &amp;gt;= MAXIMUM_CAPACITY) {
                threshold = Integer.MAX_VALUE;
                return oldTab;
            }
            else if ((newCap = oldCap &amp;lt;&amp;lt; 1) &amp;lt; MAXIMUM_CAPACITY &amp;amp;&amp;amp;
                     oldCap &amp;gt;= DEFAULT_INITIAL_CAPACITY)
                newThr = oldThr &amp;lt;&amp;lt; 1; // double threshold
        }
        else if (oldThr &amp;gt; 0) // initial capacity was placed in threshold
            newCap = oldThr;
        else {               // zero initial threshold signifies using defaults
            newCap = DEFAULT_INITIAL_CAPACITY;
            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
        }
        if (newThr == 0) {
            float ft = (float)newCap * loadFactor;
            newThr = (newCap &amp;lt; MAXIMUM_CAPACITY &amp;amp;&amp;amp; ft &amp;lt; (float)MAXIMUM_CAPACITY ?
                      (int)ft : Integer.MAX_VALUE);
        }
        threshold = newThr;
        @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;})
            Node&amp;lt;K,V&amp;gt;[] newTab = (Node&amp;lt;K,V&amp;gt;[])new Node[newCap];
        table = newTab; //如果是初始化HashMap, 到这里就够了, 会跳过if判断并返回
        if (oldTab != null) {
            for (int j = 0; j &amp;lt; oldCap; ++j) {
                Node&amp;lt;K,V&amp;gt; e;
                if ((e = oldTab[j]) != null) {
                    oldTab[j] = null;
                    if (e.next == null)
                        newTab[e.hash &amp;amp; (newCap - 1)] = e;
                    else if (e instanceof TreeNode)
                        ((TreeNode&amp;lt;K,V&amp;gt;)e).split(this, newTab, j, oldCap);
                    else { // preserve order    般动数据
                        Node&amp;lt;K,V&amp;gt; loHead = null, loTail = null;
                        Node&amp;lt;K,V&amp;gt; hiHead = null, hiTail = null;
                        Node&amp;lt;K,V&amp;gt; next;
                        do {
                            next = e.next;
                            if ((e.hash &amp;amp; oldCap) == 0) {
                                if (loTail == null)
                                    loHead = e;
                                else
                                    loTail.next = e;
                                loTail = e;
                            }
                            else {
                                if (hiTail == null)
                                    hiHead = e;
                                else
                                    hiTail.next = e;
                                hiTail = e;
                            }
                        } while ((e = next) != null);
                        if (loTail != null) {
                            loTail.next = null;
                            newTab[j] = loHead;
                        }
                        if (hiTail != null) {
                            hiTail.next = null;
                            newTab[j + oldCap] = hiHead;
                        }
                    }
                }
            }
        }
        return newTab;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;首先判断HashMap容量是否超过了默认的最大值, 如果是就不会进行扩容, 并返回原表.&lt;/li&gt;
&lt;li&gt;然后确定新表的大小&lt;code&gt;newCap&lt;/code&gt;, 确定新表的threshold值(用于判断是否要扩容)&lt;code&gt;newThr&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;确定好这两个值后, 如果是初始化HashMap, 由于原表为空&lt;code&gt;oldTab == null&lt;/code&gt;, &lt;code&gt;resize()&lt;/code&gt;函数也就结束了, 返回初始好的新表.&lt;/li&gt;
&lt;li&gt;如果&lt;code&gt;oldTab != null&lt;/code&gt;, 也就说这次调用&lt;code&gt;resize()&lt;/code&gt;是进行扩容, 那么在创建好新表后, 就要把原来的数据重新计算并搬运到新表中.&lt;/li&gt;
&lt;li&gt;搬运数据的过程还是蛮有意思的, 分析如下:&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;在HashMap中计算元素存放位置的代码是 (n - 1) &amp;amp; hash
其中n是哈希表数组的长度, 这行代码保证了元素能落在数组的下标范围内
现在我们要进行扩容, 假设hash值为101010
初始容量 n = 16 , 计算地址: (n - 1) &amp;amp; hash = 1111  &amp;amp; 101010 = 001010
扩后容量 n = 32 , 计算地址: (n - 1) &amp;amp; hash = 11111 &amp;amp; 101010 = 001010
我们发现hash值为101010的时候计算出来的地址是一样的, 那么这个元素就不用挪位了. 

再举例:
假设当前元素hash值为1010101
初始容量 n = 16 , 计算地址: (n - 1) &amp;amp; hash = 1111  &amp;amp; 1010101 = 0000101
扩后容量 n = 32 , 计算地址: (n - 1) &amp;amp; hash = 11111 &amp;amp; 1010101 = 0010101
我们发现这时两个地址不相等, 新地址为: 原地址 + 原长度 (0000101 + 16) = 0010101

这是一个精心的设计, 是这样的:
原来计算地址时 : (n - 1) = 1111 一共有4位
扩容后计算地址 : (n - 1) = 11111 多了一位, 多在了第五位
回头看hash值
第一个hash值: 101010. 第五位为0
第二个hash值: 1010101. 第五位为1
设计的原理就是: 在计算地址的时候, (n - 1)会比原来多了一位, 假设多的是第n位. 
如果hash值的第n位为0那么元素就不用移动, 如果为1, 就要移动到新位置. 

所以从严谨的角度看, 扩容的时候不是对每个元素重新计算哈希, 
而是把每个位置上的元素分成两类调整位置. 


else { // preserve order
    Node&amp;lt;K,V&amp;gt; loHead = null, loTail = null;
    Node&amp;lt;K,V&amp;gt; hiHead = null, hiTail = null;
    Node&amp;lt;K,V&amp;gt; next;
    do {
        next = e.next;
        if ((e.hash &amp;amp; oldCap) == 0) {//判断第n位是否为0
            if (loTail == null)//不用移动的串在一条链上
                loHead = e;
            else
                loTail.next = e;
            loTail = e;
        }
        else {//需要移动的串在另一条链上
            if (hiTail == null)
                hiHead = e;
            else
                hiTail.next = e;
            hiTail = e;
        }
    } while ((e = next) != null);
    if (loTail != null) {
        loTail.next = null;
        newTab[j] = loHead;//在原位放好不用动的
    }
    if (hiTail != null) {
        hiTail.next = null;
        newTab[j + oldCap] = hiHead;//移动的位置: 原位置 + 原长度
    }
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;hr/&gt;&lt;h5 id=&quot;4&quot;&gt;下面继续是`putVal()`的分析&lt;/h5&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;if ((p = tab[i = (n - 1) &amp;amp; hash]) == null)
    tab[i] = newNode(hash, key, value, null);&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;拿到数组后, 根据hash值计算插入地址&lt;code&gt;tab[i = (n - 1) &amp;amp; hash]&lt;/code&gt;, 如果该地址中没有元素, 就直接插入. 插入完判断需不需要扩容&lt;code&gt;if (++size &amp;gt; threshold)&lt;/code&gt;, 如果需要就扩容, 不需要的话本次&lt;code&gt;put()&lt;/code&gt;方法就结束了, 返回null.&lt;/li&gt;
&lt;li&gt;如果插入的地方已经有元素了, 也就是发生了冲突.&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;if (p.hash == hash &amp;amp;&amp;amp;
    ((k = p.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
    e = p;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;首先会判断Key是否相同, 如果相同, 就就行判断是否能替换值, 能就替换&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;if (e != null) { // existing mapping for key
    V oldValue = e.value;
    if (!onlyIfAbsent || oldValue == null)//在日常使用中, 基本新value都会替换旧value
        e.value = value;
    afterNodeAccess(e);
    return oldValue;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;如果不相同, 就要寻找插入的位置, 如果当前桶里装的是链表, 则遍历链表(遍历的过程中仍会判断是否有相同的key), 如果装的是红黑树, 则按照红黑树的策略寻找插入点(期间仍会判断是否有相同的key).&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;            else if (p instanceof TreeNode)
                e = ((TreeNode&amp;lt;K,V&amp;gt;)p).putTreeVal(this, tab, hash, key, value);
            else {
                for (int binCount = 0; ; ++binCount) {
                    if ((e = p.next) == null) {
                        p.next = newNode(hash, key, value, null);
                        if (binCount &amp;gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                            treeifyBin(tab, hash);
                        break;
                    }
                    if (e.hash == hash &amp;amp;&amp;amp;
                        ((k = e.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
                        break;
                    p = e;
                }
            }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;补充: 在桶里装链表的情况下, 插入元素后会判断链表的长度有没有达到转换为红黑树的要求. 如果达到了就调用&lt;code&gt;treeifyBin()&lt;/code&gt;方法.&lt;/li&gt;
&lt;li&gt;但注意: 并不是调用了&lt;code&gt;treeifyBin()&lt;/code&gt;就会把桶中的结构转换为红黑树. 回想一下文章开头提及的基本参数, 有一个参数是&lt;code&gt;MIN_TREEIFY_CAPACITY&lt;/code&gt;, 如果当前数组长度还没有达到这个参数的值, 是不会转换结构的, 会进行扩容&lt;code&gt;resize()&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;blockquote&gt;
&lt;p&gt;结束&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;看到这里, HashMap在你的面前应该是没有什么秘密了.&lt;/li&gt;
&lt;li&gt;曾经看过一个有关HashMap并发造成死循环的问题. 左耳朵耗子的博客中有详细的描述, &lt;a href=&quot;https://coolshell.cn/articles/9606.html&quot;&gt;点此跳转&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;但是这个问题在JDK1.8中已经处理了. 造成死循环的原因是扩容时重新插入链表时是倒序插入的, JDK1.8中用了两条链表分别操作, 保证了链表插入到Map时还是按顺序插入的, 避免了死循环.&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Mon, 25 Mar 2019 13:53:00 +0000</pubDate>
<dc:creator>炭烧生蚝</dc:creator>
<og:description>本文按以下顺序叙述: 'HashMap的感性认识.' '官方文档中对HashMap介绍的解读.' '到源码中看看HashMap这些特性到底是如何实现的.' 把源码啃下来有一种很爽的感觉, 相信你读完后</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tanshaoshenghao/p/10596919.html</dc:identifier>
</item>
<item>
<title>对称密码——DES加密算法 - SakuraOne</title>
<link>http://www.cnblogs.com/myworld7/p/10596869.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/myworld7/p/10596869.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;本篇博文将介绍对称密码算法中的DES密码的算法原理与代码实现（Java）&lt;/p&gt;
&lt;h2 id=&quot;des算法原理&quot;&gt;DES算法原理&lt;/h2&gt;
&lt;p&gt;DES加密算法是&lt;strong&gt;对称加密&lt;/strong&gt;算法（加密和解密使用同一个密钥）中的一种，DES也是&lt;strong&gt;分组密码&lt;/strong&gt;，以64位为分组对明文进行加密。&lt;/p&gt;
&lt;p&gt;DES算法会对明文进行16轮的迭代加密，具体的算法过程可以看下面这图（来自文末参考博文中的图，做了一些修改）。看一遍有点绕就那笔跟着走一遍。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1099419/201903/1099419-20190325213312649-1349688376.png&quot; width=&quot;800&quot; height=&quot;720&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面这张图是每次迭代的的一个提取，我们从中可以直接观察到的就是&lt;strong&gt;迭代的两个规律&lt;/strong&gt;：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Li = Ri-1
Ri = Li-1 ^ F(Ri-1, Ki)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上一轮的输出作为下一轮加密的输入（也就是迭代的过程）。同样，&lt;strong&gt;子密钥也是迭代产生&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1099419/201903/1099419-20190325213456344-1886971709.png&quot; width=&quot;600&quot; height=&quot;480&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在总体概览了一遍后，我们可以将DES算法分为3部分来讲解。从第一张图从右往左，轮子密钥（子密钥）的生成、F函数的实现以及16次迭代的过程。&lt;/p&gt;
&lt;h3 id=&quot;子密钥的产生&quot;&gt;子密钥的产生&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1099419/201903/1099419-20190325213603683-1374599933.png&quot; width=&quot;480&quot; height=&quot;480&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如图上的流程图所示，将所给的&lt;strong&gt;初始64位密钥（若是密钥不足64位则前面加0补充至64位），经过PC-1置换压缩成56位&lt;/strong&gt;。然后&lt;strong&gt;分成左右28位&lt;/strong&gt;，表示成C0， D0。C0和D0按照循环左移表来分别循环左移，此处是第一次循环，所以循环左移1次，生成C1和D1。然后C1和D1合并成56位密钥&lt;strong&gt;经过PC-2置换压缩成48位&lt;/strong&gt;的K1。&lt;/p&gt;
&lt;p&gt;K2的生成过程：C1和D1分别循环左移1次，然后合并经过PC-2置换压缩成K2。Ki的生成就为Ci-1和Di-1分别循环左移，然后合并经过PC-2置换压缩而成。&lt;/p&gt;
&lt;p&gt;PC-1 置换表 PC-2置换表 循环左移表&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//PC-1置换表
private int[] PC1={
    57,49,41,33,25,17,9,
    1,58,50,42,34,26,18,
    10,2,59,51,43,35,27,
    19,11,3,60,52,44,36,
    63,55,47,39,31,23,15,
    7,62,54,46,38,30,22,
    14,6,61,53,45,37,29,
    21,13,5,28,20,12,4};

//PC-2置换表    
private int[] PC2={
    14,17,11,24,1,5,3,28,
    15,6,21,10,23,19,12,4,
    26,8,16,7,27,20,13,2,
    41,52,31,37,47,55,30,40,
    51,45,33,48,44,49,39,56,
    34,53,46,42,50,36,29,32};

//循环左移次数表
private int[] leftTable = {1,1,2,2,2,2,2,2,1,2,2,2,2,2,2,1};&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;f函数的原理&quot;&gt;F函数的原理&lt;/h3&gt;
&lt;p&gt;F函数的内部还是比较复杂，不过问题不大。我们按照F函数内部执行顺序来可以分为以下几步：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Ri-1做一个E扩展，从&lt;strong&gt;32位扩展成48位&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Ri-1与Ki异或运算，然后将异或运算的结果&lt;strong&gt;经过S盒选择压缩成32位&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;从S盒出来的32位结果再经过P置换，就得到最终的32位Ri&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Ri-1做扩散选择的表如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//E扩展
private int[] ETable={
    32,1,2,3,4,5,
    4,5,6,7,8,9,
    8,9,10,11,12,13,
    12,13,14,15,16,17,
    16,17,18,19,20,21,
    20,21,22,23,24,25,
    24,25,26,27,28,29,
    28,29,30,31,32,1};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从S盒出来的32位结果经过的P表如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//P置换
private int[] P={
    16,7,20,21,29,12,28,17,
    1,15,23,26,5,18,31,10,
    2,8,24,14,32,27,3,9,
    19,13,30,6,22,11,4,25};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这三步中最为机密的就是S盒的选择压缩了。S盒是如何实现选择压缩呢？我们就要知道S的结构了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;S盒的结构&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1099419/201903/1099419-20190325213709963-1354635534.png&quot; width=&quot;600&quot; height=&quot;300&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以看出，进入S盒后将Ri-1与Ki异或的值分成8组，每组6位，分别进入S1-S8盒，然后从每个盒中出4位，合并成32位的结果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;若是还想探究6位变成4位是如何的变换的&lt;/strong&gt;，就需要看下面这点介绍：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1099419/201903/1099419-20190325213813363-1131352591.png&quot; width=&quot;600&quot; height=&quot;800&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们以进入S!盒为例，假设进入的6位二进制数为101001，我们一般将&lt;strong&gt;第一位和最后一位（从左到右）作为行坐标，中间四位作为纵坐标&lt;/strong&gt;找值。11即3行，0100即4列（从0开始编号），最后选出的值就为4，四位二进制表示则为0100。&lt;/p&gt;
&lt;h3 id=&quot;次的迭代加密&quot;&gt;16次的迭代加密&lt;/h3&gt;
&lt;p&gt;最初我们需要将初始的明文做一个IP置换，然后分成左右各32位即L0 R0，带入L0、R0去计算L1和R1。&lt;/p&gt;
&lt;p&gt;16次迭代的规律为：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Li = Ri-1
Ri = Li-1 ^ F(Ri-1, Ki)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后，L16与R16直接交换赋给L17和R17(L17=R16, R17=L16)，然后L17与R17合并后通过IP逆置换生成最终的密文。&lt;/p&gt;
&lt;p&gt;以上，便是加密过程，解密可以说是加密的逆向过程。解密为何反向就可以解密，还需要各位看官另觅资料~&lt;/p&gt;
&lt;h2 id=&quot;des算法java实现完整&quot;&gt;DES算法Java实现（完整）&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package symmetricipher;
/**   
* @description: 代码实现Des算法加解密
* @author sakura  
* @date 2019年3月25日 下午12:52:21  
*/

/*
 * 1.主要的一个迭代公式  Li=Ri Ri = Li-1 ⊕F(Li-1,Ki)
 * 2.整体可以分为 加解密运算  F函数的处理  子密钥的产生
 * 3.子秘钥产生：64位经过PC-1密钥置换成56位 分为Ci Di左右各28为位 然后根据循环左移表来左移  最后经过PC-2置换成48位的密钥Ki
 * 4.F函数的处理：Li-1（32位）经过E盒扩展成48位； 48位的Li-1与 子秘钥Ki进行异或  ；
 *      异或的结果经过S盒（8个盒子 6进4出）生成32位；32位再经过P盒转换成最后32位F函数处理后的结果
 * 5.加解密运算这边：先将明文做一个IP置换，然后将64位分成左右32位L0,R0 然后开始迭代 ；到第16次，做IP逆置换生成最终的密文
 * 
 * 6.解密运算：
 *      加密反过来
 * 
 */

public class DES {
    //初始IP置换
     private int[] IP={
             58,50,42,34,26,18,10,2,
             60,52,44,36,28,20,12,4,
             62,54,46,38,30,22,14,6,
             64,56,48,40,32,24,16,8,
             57,49,41,33,25,17,9,1,
             59,51,43,35,27,19,11,3,
             61,53,45,37,29,21,13,5,
             63,55,47,39,31,23,15,7};
     //IP逆置换
     private int[] IP1={
             40,8,48,16,56,24,64,32,
             39,7,47,15,55,23,63,31,
             38,6,46,14,54,22,62,30,
             37,5,45,13,53,21,61,29,
             36,4,44,12,52,20,60,28,
             35,3,43,11,51,19,59,27,
             34,2,42,10,50,18,58,26,
             33,1,41,9,49,17,57,25};
     
     //E扩展
     private int[] ETable={
             32,1,2,3,4,5,
             4,5,6,7,8,9,
             8,9,10,11,12,13,
             12,13,14,15,16,17,
             16,17,18,19,20,21,
             20,21,22,23,24,25,
             24,25,26,27,28,29,
             28,29,30,31,32,1};
     
     //P置换
     private int[] P={
             16,7,20,21,29,12,28,17,
             1,15,23,26,5,18,31,10,
             2,8,24,14,32,27,3,9,
             19,13,30,6,22,11,4,25};    

     //S盒
     private static final int[][][] SBox = {
            {
                    { 14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7 },
                    { 0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8 },
                    { 4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0 },
                    { 15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13 } },
            { 
                    { 15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10 },
                    { 3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5 },
                    { 0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15 },
                    { 13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9 } },
            { 
                    { 10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8 },
                    { 13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1 },
                    { 13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7 },
                    { 1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12 } },
            { 
                    { 7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15 },
                    { 13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9 },
                    { 10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4 },
                    { 3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14 } },
            { 
                    { 2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9 },
                    { 14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6 },
                    { 4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14 },
                    { 11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3 } },
            { 
                    { 12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11 },
                    { 10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8 },
                    { 9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6 },
                    { 4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13 } },
            { 
                    { 4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1 },
                    { 13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6 },
                    { 1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2 },
                    { 6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12 } },
            { 
                    { 13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7 },
                    { 1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2 },
                    { 7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8 },
                    { 2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11 } }
     };
     
     //PC-1置换表
     private int[] PC1={
             57,49,41,33,25,17,9,
             1,58,50,42,34,26,18,
             10,2,59,51,43,35,27,
             19,11,3,60,52,44,36,
             63,55,47,39,31,23,15,
             7,62,54,46,38,30,22,
             14,6,61,53,45,37,29,
             21,13,5,28,20,12,4};
     
     //PC-2置换表    
     private int[] PC2={
             14,17,11,24,1,5,3,28,
             15,6,21,10,23,19,12,4,
             26,8,16,7,27,20,13,2,
             41,52,31,37,47,55,30,40,
             51,45,33,48,44,49,39,56,
             34,53,46,42,50,36,29,32};
     
     //循环左移次数表
     private int[] leftTable = {1,1,2,2,2,2,2,2,1,2,2,2,2,2,2,1};
     
     //加密轮数16轮
     private static final int LOOP = 16;
     private String[] keys = new String[LOOP];
     private String[] pContent;
     private String[] cContent;
     private int originLength;  //初始明文长度
     
     //16个子密钥
     private int[][] subKey = new int[16][48];      //存储16次的子密钥
     private String content;
     private int pOriginLegth;  //明文初始长度？
     
     //构造函数
    public DES(String key, String content) {
        this.content = content;
        pOriginLegth = content.getBytes().length;
        generateSubKey(key);
    }
    
    //主函数入口
    public static void main(String[] args) {
        String plainText = &quot;SakuraOne&quot;;
        System.out.println(&quot;明文： \n&quot; + plainText);
        String key = &quot;IAMKEY&quot;;
        
        DES des = new DES(key,plainText);
        
        byte[] c = des.group(plainText.getBytes(), true);//加密
        System.out.println(&quot;密文：\n&quot; + new String(c));
        
        byte[] p = des.group(c, false); //解密
        byte[] pd = new byte[plainText.getBytes().length];
        System.arraycopy(p, 0, pd, 0, plainText.getBytes().length);
        System.out.println(&quot;解密后的明文：\n&quot; + new String(pd));
    
    }
    
    /**
     *拆分分组
     */
    public byte[] group(byte[] plainText, boolean decryption) {
        //填充明文长度为64位的整数
        originLength = plainText.length;
        int gNum;
        int rNum;
        gNum = originLength/8;
        rNum = 8-(originLength-gNum*8);
        byte[] pPadding;
        if(rNum&amp;lt;8) {
            pPadding = new byte[originLength+rNum];
            System.arraycopy(plainText, 0, pPadding, 0, originLength);
            for(int i=0; i&amp;lt;rNum; i++) {
                pPadding[originLength+1]=(byte)rNum;
            }
        }else {
            pPadding = plainText;
        }
        
        gNum = pPadding.length/8;
        
        byte[] groupPT = new byte[8];   //64位分组单位
        byte[] resultData = new byte[pPadding.length];
        
        for(int i=0; i&amp;lt;gNum; i++) {
            System.arraycopy(pPadding, i*8, groupPT, 0, 8);
            System.arraycopy(encryptUnit(groupPT, subKey, decryption), 0, resultData, i*8, 8);
        }
        
        //如果是解密   这里感觉什么也没有做呢？？
        if(decryption == false) {
            byte[] pResultData = new byte[pOriginLegth];
            System.arraycopy(resultData, 0, pResultData, 0, pOriginLegth);
            return pResultData;
        }
        
        return resultData;  
    }
    
    /**
     *加密一个64位分组
     *
     */
    public byte[] encryptUnit(byte[]unit, int keysArray[][], boolean decryption) {
        //得到明文的01字符串
        StringBuilder sb = new StringBuilder();
        for(int i=0; i&amp;lt;8; i++) {
            String tmpBit = Integer.toBinaryString(unit[i] &amp;amp; 0xff);
            while(tmpBit.length()%8!=0) {
                tmpBit=&quot;0&quot;+tmpBit;
            }
            sb.append(tmpBit);
        }
        
        //将明文01字符串转换为数字01存放在数组中
        int[] pBit = new int[64];
        String pStr = sb.toString();
        for(int i=0; i&amp;lt;64; i++) {
            int bit = Integer.valueOf(pStr.charAt(i));
            if(bit == 48) {
                bit = 0;
            }else if(bit == 49){
                bit = 1;
            }else {
                System.out.println(&quot;To bit error&quot;);
            }
            pBit[i] = bit;
        }
        
        /*=========IP置换==========*/
        int[] pIP = new int[64];
        for(int i=0; i&amp;lt;64; i++) {
            pIP[i] = pBit[IP[i]-1];
        }
        
        //加密
        if(decryption) {
            //迭代16次
            for(int i=0; i&amp;lt;16; i++) {
                loop(pIP, i, decryption, keysArray[i]);
            }
        }else {             //解密  反向迭代
            for(int i=15; i&amp;gt;-1; i--) {
                loop(pIP, i, decryption, keysArray[i]);
            }
        }
        
        /*===========IP逆置换=============*/
        int[] c = new int[64];
        for(int i=0; i&amp;lt;IP1.length; i++) {
            c[i] = pIP[IP1[i]-1];
        }
        
        byte[] cByte = new byte[8];
        for(int i=0; i&amp;lt;8; i++) {
            cByte[i] = (byte)((c[8*i]&amp;lt;&amp;lt;7)+(c[8*i+1]&amp;lt;&amp;lt;6)+(c[8*i+2]&amp;lt;&amp;lt;5)+(c[8*i+3]&amp;lt;&amp;lt;4)+(c[8*i+4]&amp;lt;&amp;lt;3)+(c[8*i+5]&amp;lt;&amp;lt;2)+(c[8*i+6]&amp;lt;&amp;lt;1)+(c[8*i+7]));
        }
        return cByte;   //最终的密码字节数组
    }
    
    //依次迭代过程
    public void loop(int[] median, int times, boolean decryption, int[]keyArray ) {
        int[] l0 = new int[32];
        int[] r0 = new int[32];
        int[] l1 = new int[32];
        int[] r1 = new int[32];
        int[] f = new int[32];      //调用F函数后生成的结果
        
        System.arraycopy(median, 0, l0, 0, 32);
        System.arraycopy(median, 32, r0, 0, 32);
        
        l1 = r0;
        f = fFunction(r0, keyArray);    //调用F函数
        
        for(int i=0; i&amp;lt;32; i++) {
            r1[i] = l0[i]^f[i];     //ri = li-1 ^ f[i]
            if(((decryption==false) &amp;amp;&amp;amp; (times==0)) || ((decryption==true) &amp;amp;&amp;amp; (times==15))) {
                median[i] = r1[i];
                median[i+32] = l1[i];
            }else {
                median[i] = l1[i];
                median[i+32] = r1[i];
            }
        }
    }
    
    /**
     *  F函数
     */
    public int[] fFunction(int[] rContent, int[] key) {
        int[] result = new int[32];
        int[] rXORkey = new int[48];
        
        //ri扩展 与 keyi异或
        for(int i=0; i&amp;lt;ETable.length; i++) {
            rXORkey[i] = rContent[ETable[i]-1]^key[i];
        }
        
        /*=============S-box替换 将48位变成32位==============*/
        int[][] s= new int[8][6];
        int[] sAfter = new int[32];
        
        for(int i=0; i&amp;lt;8; i++) {
            System.arraycopy(rXORkey, i*6, s[i], 0, 6);
            int r = (s[i][0]&amp;lt;&amp;lt;1)+s[i][5];   //横坐标
            int c = (s[i][1]&amp;lt;&amp;lt;3) + (s[i][2]&amp;lt;&amp;lt;2) + (s[i][1]&amp;lt;&amp;lt;1) + s[i][4]; //纵坐标
            String str = Integer.toBinaryString(SBox[i][r][c]);
            while(str.length() &amp;lt; 4) {
                str = &quot;0&quot;+str;
            }
            
            for(int j=0; j&amp;lt;4; j++) {
                int p=Integer.valueOf(str.charAt(j));
                if(p==48) {
                    p=0;
                }else if(p==49) {
                    p=1;
                }else {
                    System.out.println(&quot;To bit error!&quot;);
                }
                sAfter[4*i+j] = p;
            }   
        }
        
        /*===============P盒替换=====================*/
        for(int i=0; i&amp;lt;P.length; i++) {
            result[i] = sAfter[P[i]-1];
        }
        return result;
    }
    
    
    /**
     * description:生成子密钥
     * 
     * @param key 密钥
     *    
     */
    public void generateSubKey(String key) {
        //当key的长度小于64位时要扩展至64位
        while(key.length()&amp;lt;8) {
            key = key + key;
        }
        key = key.substring(0, 8);
        
        //将字符密钥转换成二进制形式
        byte[] keys = key.getBytes();
        int[] kBit = new int[64];
        
        for(int i=0; i&amp;lt;8; i++) {
            //每个字节即每8位&amp;amp;0000 0000
            String kStr = Integer.toBinaryString(keys[i] &amp;amp; 0xff);
            //补齐8位
            if(kStr.length()&amp;lt;8) {
                for(int t=0; t&amp;lt;8-kStr.length(); t++) {
                    kStr = &quot;0&quot; + kStr;
                }
            }
            
            //将01字符串转换成二进制01
            for(int j=0; j&amp;lt;8; j++) {
                int p = Integer.valueOf(kStr.charAt(j));
                if(p == 48) {
                    p=0;
                }else if(p == 49) {
                    p=1;
                }else {
                    System.out.println(&quot;To bit error!&quot;);
                }
                kBit[i*8+j] = p;
            }
        }
        
        //得到kBit 初始化的64位密钥 然后进行PC-1压缩成56位
        
        /*==============PC-1压缩===============*/
        int[] kNewBit = new int[56];
        for(int i=0; i&amp;lt;PC1.length; i++) {
            kNewBit[i] = kBit[PC1[i]-1];
        }
        
        /*================初始密钥分组=============*/
        int[] c0 = new int[28];
        int[] d0 = new int[28];
        System.arraycopy(kNewBit, 0, c0, 0, 28);
        System.arraycopy(kNewBit, 28, d0, 0, 28);
        
        //生成16个子密钥
        for(int i=0; i&amp;lt;16; i++) {
            int[] c1 = new int[28];
            int[] d1 = new int[28];
            
            /*============ci、di分别循环左移===========*/
            if(leftTable[i] == 1) {
                System.arraycopy(c0, 1, c1, 0, 27);
                c1[27]=c0[0];
                System.arraycopy(d0, 1, d1, 0, 27);
                d1[27]=d0[0];
            }else if(leftTable[i] == 2) {
                System.arraycopy(c0, 2, c1, 0, 26);
                c1[26]=c0[0];
                c1[27]=c0[1];
                
                System.arraycopy(d0, 2, d1, 0, 26);
                d1[26]=d0[0];
                d1[27]=d0[1];
            }else {
                System.out.println(&quot;leftTable error!&quot;);
            }
            
            /*================ci、di合并 PC-2压缩置换=============*/
            int[] tmp = new int[56];
            System.arraycopy(c1, 0, tmp, 0, 28);
            System.arraycopy(d1, 0, tmp, 28, 28);
            for(int j=0; j&amp;lt;PC2.length; j++) {
                subKey[i][j] = tmp[PC2[j]-1];
            }
            c0 = c1;
            d0 = d1;
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1099419/201903/1099419-20190325222026625-1566145031.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;这学期在上密码学的课程，课堂上听老师讲了对称加密算法中的DES算法，一直觉得挺绕。在上完实验课后勉强对其算法流程有了一个清晰认识。后面想着用算法实现或许会更明了， 于是写代码实现。确实，自己实现一遍后对算法会更理解。粗糙地记录了下DES加解密的实现，以供参考。解密算法的验证需要大家另觅资料，本篇博文就不再介绍了~&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;DES算法原理与Java实现&lt;a href=&quot;https://blog.csdn.net/android_jiangjun/article/details/79654940&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/android_jiangjun/article/details/79654940&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 25 Mar 2019 13:41:00 +0000</pubDate>
<dc:creator>SakuraOne</dc:creator>
<og:description>前言 本篇博文将介绍对称密码算法中的DES密码的算法原理与代码实现（Java） DES算法原理 DES加密算法是 对称加密 算法（加密和解密使用同一个密钥）中的一种，DES也是 分组密码 ，以64位为</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/myworld7/p/10596869.html</dc:identifier>
</item>
<item>
<title>Nginx 安装详细（一） - 拿着保温瓶的年轻人</title>
<link>http://www.cnblogs.com/l-hh/p/10594415.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/l-hh/p/10594415.html</guid>
<description>&lt;blockquote readability=&quot;8.8343558282209&quot;&gt;
&lt;p&gt;&lt;span&gt;Nginx是一款自由的、开源的、高性能的HTTP服务器和反向代理服务器；同时也是一个IMAP、POP3、SMTP代理服务器；Nginx可以作为一个HTTP服务器进行网站的发布处理，另外Nginx可以作为反向代理进行负载均衡的实现。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;更多关于Nginx介绍以及作用请自行&lt;a href=&quot;https://www.baidu.com/&quot; target=&quot;_blank&quot;&gt;百度&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@nginx ~]# yum install gcc gcc-c++ pcre-devel zlib-devel openssl-devel  -y &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;span&gt; 3.1 &lt;strong&gt;下载&lt;span lang=&quot;EN-US&quot;&gt;nginx稳定版&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;注：进入&lt;a href=&quot;http://nginx.org/download/&quot; target=&quot;_blank&quot;&gt;Nginx安装包下载地址&lt;/a&gt;复制您想要的版本链接，我这里以Nginx-1.14.0为例。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@nginx~]# cd /usr/local/src/&lt;span&gt;                      
[root@ nginx src]# wget http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;nginx.org/download/nginx-1.14.0.tar.gz &lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt; 3.2 下载nginx-sticky模块&lt;span&gt;（可选安装，应用于集群）&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;作用：后端做负载均衡解决session sticky问题。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@nginx src]# wget https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;bitbucket.org/nginx-goodies/nginx-sticky-module-ng/get/master.tar.gz&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt; 3.3 下载ngx_cache_purge模块&lt;span&gt;（可选安装）&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt; 作用：将ngx_cache_purge编译到到Nginx中,用来清除指定URL的缓存。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; （&lt;a href=&quot;http://labs.frickle.com/nginx_ngx_cache_purge/&quot; target=&quot;_blank&quot;&gt;官网地址&lt;/a&gt;：http://labs.frickle.com/nginx_ngx_cache_purge/）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@nginx src]# wget http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;labs.frickle.com/files/ngx_cache_purge-2.3.tar.gz&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1418489/201903/1418489-20190325173641933-678865088.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@nginx ~&lt;span&gt;]# groupadd www                             
[root@nginx &lt;/span&gt;~]# useradd -g www www -s /sbin/nologin&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;注：创建nginx运行用户www并加入到www组，不允许www用户直接登录系统。&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@nginx src]# tar zxf nginx-&lt;span&gt;1.14&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;&lt;span&gt;.tar.gz     &lt;br/&gt;# 注意3.2的可选项        
[root@nginx src]# tar zxf ngx_cache_purge&lt;/span&gt;-&lt;span&gt;2.3&lt;/span&gt;&lt;span&gt;.tar.gz      &lt;br/&gt;# 注意3.3的可选项
[root@nginx src]# tar zxf nginx&lt;/span&gt;-goodies-nginx-sticky-module-ng-&lt;span&gt;08a395c66e42.tar.gz                                            
[root@nginx src]# cd nginx&lt;/span&gt;-&lt;span&gt;1.14&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 注：&lt;span&gt;‘=’&lt;/span&gt;号后面是自己安装包的绝对路径，和配置文件路径。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@nginx-master nginx-&lt;span&gt;1.14&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;]# ./configure --prefix=/usr/local/&lt;span&gt;nginx             
&lt;/span&gt;&amp;gt; --user=www --group=&lt;span&gt;www                                                  
&lt;/span&gt;&amp;gt; --with-&lt;span&gt;http_stub_status_module                                               
&lt;/span&gt;&amp;gt; --with-http_realip_module --with-&lt;span&gt;http_ssl_module                               
&lt;/span&gt;&amp;gt; --with-&lt;span&gt;http_gzip_static_module                                               
&lt;/span&gt;&amp;gt; --http-client-body-temp-path=/&lt;span&gt;var&lt;/span&gt;/tmp/nginx/&lt;span&gt;client                             
&lt;/span&gt;&amp;gt; --http-proxy-temp-path=/&lt;span&gt;var&lt;/span&gt;/tmp/nginx/&lt;span&gt;proxy                                  
&lt;/span&gt;&amp;gt; --http-fastcgi-temp-path=/&lt;span&gt;var&lt;/span&gt;/tmp/nginx/&lt;span&gt;fcgi&lt;br/&gt;# 注意3.2的可选项                             
&lt;/span&gt;&amp;gt; --with-pcre --add-module=/usr/local/src/ngx_cache_purge-&lt;span&gt;2.3&lt;/span&gt;   &lt;br/&gt;# 注意3.3的可选项                 
&amp;gt; --add-module=/usr/local/src/nginx-goodies-nginx-sticky-module-ng-08a395c66e42&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1418489/201903/1418489-20190325174815331-499371485.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;执行完编译后：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1418489/201903/1418489-20190325174852132-276896470.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@nginx nginx-&lt;span&gt;1.14&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;]# make &amp;amp;&amp;amp; make install&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;注：Nginx的所有模块必须在编译的时候添加，不能再运行的时候动态加载。&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@nginx nginx-&lt;span&gt;1.14&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;]# ln -s /usr/local/nginx/sbin/nginx /usr/local/sbin/&lt;span&gt;  
[root@nginx nginx&lt;/span&gt;-&lt;span&gt;1.14&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;]# nginx -t&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如果出现以下问题：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1418489/201903/1418489-20190325175237953-598835128.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;需要创建此目录：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@nginx nginx-&lt;span&gt;1.14&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;]# mkdir -p /&lt;span&gt;var&lt;/span&gt;/tmp/nginx/client &lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1418489/201903/1418489-20190325175401305-735189543.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;原始管理nginx的命令，不是很方便！&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@nginx-master ~&lt;span&gt;]# nginx              启动nginx
[root@nginx&lt;/span&gt;-master ~]# nginx -&lt;span&gt;s reload    重启nginx
[root@nginx&lt;/span&gt;-master ~]# nginx -s stop      停止nginx&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;接下来设置常用的管理命令：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1） 创建开机启动命令脚本文件：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@nginx ~]# vim /etc/init.d/nginx&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2） 在这个Nginx文件中插入一下启动脚本代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;-----------------------------------脚本如下 -----------------------------------&lt;span&gt;
#&lt;/span&gt;! /bin/&lt;span&gt;bash
# chkconfig: &lt;/span&gt;- &lt;span&gt;85&lt;/span&gt; &lt;span&gt;15&lt;/span&gt;&lt;span&gt;
PATH&lt;/span&gt;=/usr/local/&lt;span&gt;nginx
DESC&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;nginx daemon&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
NAME&lt;/span&gt;=&lt;span&gt;nginx
DAEMON&lt;/span&gt;=$PATH/sbin/&lt;span&gt;$NAME
CONFIGFILE&lt;/span&gt;=$PATH/conf/&lt;span&gt;$NAME.conf
PIDFILE&lt;/span&gt;=$PATH/logs/&lt;span&gt;$NAME.pid
scriptNAME&lt;/span&gt;=/etc/init.d/&lt;span&gt;$NAME
&lt;/span&gt;&lt;span&gt;set&lt;/span&gt; -&lt;span&gt;e
[ &lt;/span&gt;-x &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$DAEMON&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ] || exit &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
do_start() {
$DAEMON &lt;/span&gt;-c $CONFIGFILE || echo -n &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;nginx already running&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
}
do_stop() {
$DAEMON &lt;/span&gt;-s stop || echo -n &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;nginx not running&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
}
do_reload() {
$DAEMON &lt;/span&gt;-s reload || echo -n &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;nginx can't reload&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
}
&lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;span&gt;
start)
echo &lt;/span&gt;-n &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Starting $DESC: $NAME&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
do_start
echo &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
;;
stop)
echo &lt;/span&gt;-n &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Stopping $DESC: $NAME&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
do_stop
echo &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
;;
reload&lt;/span&gt;|&lt;span&gt;graceful)
echo &lt;/span&gt;-n &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Reloading $DESC configuration...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
do_reload
echo &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
;;
restart)
echo &lt;/span&gt;-n &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Restarting $DESC: $NAME&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
do_stop
do_start
echo &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
;;
&lt;/span&gt;*&lt;span&gt;)
echo &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Usage: $scriptNAME {start|stop|reload|restart}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;gt;&amp;amp;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
exit &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;
;;
esac
exit &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@nginx ~]# cd /etc/init.d/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;3） 设置所有人都有对这个启动脚本nginx文件的执行权限：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@nginx init.d]# chmod a+x nginx&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;4） 把nginx加入系统服务中：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@nginx init.d]# chkconfig --add nginx&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;5） 把服务设置为开机启动：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@nginx init.d]# chkconfig nginx on&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;注：reboot重启系统生效！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6） 重启后，就可以执行如下命令进行管理了&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;systemctl start   nginx.service         # 启动nginx
systemctl stop    nginx.service         # 结束nginx
systemctl restart nginx.service         # 重启nginx
systemctl enable  nginx.service         # 开机启动&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt; 1） 如果之前安装过httpd，侧需要先卸载httpd，否则启动失败，除非修改Nginx启动端口。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@nginx ~]# yum remove httpd -y&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 2） 如果还是启动不来，再试试这个方法：杀死Nginx相关的进程之后，启动Nginx&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@nginx ~]#ps -A |&lt;span&gt; grep nginx                                         
[root@nginx &lt;/span&gt;~]#kill -&lt;span&gt;9&lt;/span&gt;&lt;span&gt; pid1                                              
[root@nginx &lt;/span&gt;~]#kill -&lt;span&gt;9&lt;/span&gt; pid2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 3）  如果还是不行，查看日志信息解决。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1418489/201903/1418489-20190325211247518-368177840.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;注：后续继续更新Nginx优化及反向代理功能！&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

</description>
<pubDate>Mon, 25 Mar 2019 13:26:00 +0000</pubDate>
<dc:creator>拿着保温瓶的年轻人</dc:creator>
<og:description>1. 老规矩，来点开场白：Nginx简单介绍 Nginx是一款自由的、开源的、高性能的HTTP服务器和反向代理服务器；同时也是一个IMAP、POP3、SMTP代理服务器；Nginx可以作为一个HTTP</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/l-hh/p/10594415.html</dc:identifier>
</item>
</channel>
</rss>