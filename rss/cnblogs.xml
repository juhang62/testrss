<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>golang高并发的理解 - 飞翔码农</title>
<link>http://www.cnblogs.com/feixiangmanon/p/10504081.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/feixiangmanon/p/10504081.html</guid>
<description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;GO语言在WEB开发领域中的使用越来越广泛，Hired 发布的《2019 软件工程师状态》报告中指出，具有 Go 经验的候选人是迄今为止最具吸引力的。平均每位求职者会收到9 份面试邀请。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1557931/201903/1557931-20190310074325881-1582324426.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;想学习go，最基础的就要理解go是怎么做到高并发的。&lt;br/&gt;那么什么是高并发？&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;高并发（High Concurrency）是互联网分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计保证系统能够同时并行处理很多请求。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;严格意义上说，单核的CPU是没法做到并行的，只有多核的CPU才能做到严格意义上的并行，因为一个CPU同时只能做一件事。那为什么是单核的CPU也能做到高并发。这就是操作系统进程线程调度切换执行，感觉上是并行处理了。所以只要进程线程足够多，就能处理C1K C10K的请求，但是进程线程的数量又受到操作系统内存等资源的限制。每个线程必须分配8M大小的栈内存，不管是否使用。每个php-fpm需要占用大约20M的内存。所以目前有线程的Java就比只有进程的PHP的并发处理能力高。当然了，软件的处理能力不仅仅跟内存有关，还有是否阻塞，是否异步处理，CPU等等。Nginx作为单线程的模型却可以承担几万甚至几十万的并发请求，Nginx的话题说起来也就更多了。&lt;br/&gt;我们继续聊我们的Go，那么是不是可以有一种语言使用更小的处理单元，占用内存比线程更小，那么它的并发处理能力就可以更高。所以Google就做了这件事，就有了golang语言,golang从语言层面就支持了高并发。&lt;/p&gt;
&lt;h3 id=&quot;go为什么能做到高并发&quot;&gt;go为什么能做到高并发&lt;/h3&gt;
&lt;p&gt;goroutine是Go并行设计的核心。goroutine说到底其实就是协程，但是它比线程更小，几十个goroutine可能体现在底层就是五六个线程，Go语言内部帮你实现了这些goroutine之间的内存共享。执行goroutine只需极少的栈内存(大概是4~5KB)，当然会根据相应的数据伸缩。也正因为如此，可同时运行成千上万个并发任务。goroutine比thread更易用、更高效、更轻便。&lt;/p&gt;
&lt;p&gt;一些高并发的处理方案基本都是使用协程，openresty也是利用lua语言的协程做到了高并发的处理能力，PHP的高性能框架Swoole目前也在使用PHP的协程。&lt;br/&gt;&lt;strong&gt;协程更轻量，占用内存更小，这是它能做到高并发的前提。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;go-web开发中怎么做到高并发的能力&quot;&gt;go web开发中怎么做到高并发的能力&lt;/h3&gt;
&lt;p&gt;学习go的HTTP代码。先创建一个简单的web服务。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package main

import (
    &quot;fmt&quot;
    &quot;log&quot;
    &quot;net/http&quot;
)

func response(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, &quot;Hello world!&quot;) //这个写入到w的是输出到客户端的
}

func main() {
    http.HandleFunc(&quot;/&quot;, response)
    err := http.ListenAndServe(&quot;:9000&quot;, nil)
    if err != nil {
        log.Fatal(&quot;ListenAndServe: &quot;, err)
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后编译&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;go build -o test_web.gobin
./test_web.gobin&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后访问&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;curl 127.0.0.1:9000
Hello world!&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样简单的一个WEB服务就搭建起来。接下来我们一步一步理解这个Web服务是怎么运行的，怎么做到高并发的。&lt;br/&gt;我们顺着http.HandleFunc(&quot;/&quot;, response)方法顺着代码一直往上看。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {
    DefaultServeMux.HandleFunc(pattern, handler)
}
var DefaultServeMux = &amp;amp;defaultServeMux
var defaultServeMux ServeMux

type ServeMux struct {
    mu    sync.RWMutex//读写锁。并发处理需要的锁
    m     map[string]muxEntry//路由规则map。一个规则一个muxEntry
    hosts bool //规则中是否带有host信息
}
一个路由规则字符串，对应一个handler处理方法。
type muxEntry struct {
    h       Handler
    pattern string
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面是DefaultServeMux的定义和说明。我们看到ServeMux结构体，里面有个读写锁，处理并发使用。muxEntry结构体，里面有handler处理方法和路由字符串。&lt;br/&gt;接下来我们看下，http.HandleFunc函数，也就是DefaultServeMux.HandleFunc做了什么事。我们先看mux.Handle第二个参数HandlerFunc(handler)&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {
    mux.Handle(pattern, HandlerFunc(handler))
}
type Handler interface {
    ServeHTTP(ResponseWriter, *Request)  // 路由实现器
}
type HandlerFunc func(ResponseWriter, *Request)
func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {
    f(w, r)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们看到，我们传递的自定义的response方法被强制转化成了HandlerFunc类型，所以我们传递的response方法就默认实现了ServeHTTP方法的。&lt;/p&gt;
&lt;p&gt;我们接着看mux.Handle第一个参数。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func (mux *ServeMux) Handle(pattern string, handler Handler) {
    mux.mu.Lock()
    defer mux.mu.Unlock()

    if pattern == &quot;&quot; {
        panic(&quot;http: invalid pattern&quot;)
    }
    if handler == nil {
        panic(&quot;http: nil handler&quot;)
    }
    if _, exist := mux.m[pattern]; exist {
        panic(&quot;http: multiple registrations for &quot; + pattern)
    }

    if mux.m == nil {
        mux.m = make(map[string]muxEntry)
    }
    mux.m[pattern] = muxEntry{h: handler, pattern: pattern}

    if pattern[0] != '/' {
        mux.hosts = true
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将路由字符串和处理的handler函数存储到ServeMux.m 的map表里面，map里面的muxEntry结构体，上面介绍了，一个路由对应一个handler处理方法。&lt;br/&gt;接下来我们看看，http.ListenAndServe(&quot;:9000&quot;, nil)做了什么&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func ListenAndServe(addr string, handler Handler) error {
    server := &amp;amp;Server{Addr: addr, Handler: handler}
    return server.ListenAndServe()
}

func (srv *Server) ListenAndServe() error {
    addr := srv.Addr
    if addr == &quot;&quot; {
        addr = &quot;:http&quot;
    }
    ln, err := net.Listen(&quot;tcp&quot;, addr)
    if err != nil {
        return err
    }
    return srv.Serve(tcpKeepAliveListener{ln.(*net.TCPListener)})
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;net.Listen(&quot;tcp&quot;, addr)，就是使用端口addr用TCP协议搭建了一个服务。tcpKeepAliveListener就是监控addr这个端口。&lt;br/&gt;接下来就是关键代码，HTTP的处理过程&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func (srv *Server) Serve(l net.Listener) error {
    defer l.Close()
    if fn := testHookServerServe; fn != nil {
        fn(srv, l)
    }
    var tempDelay time.Duration // how long to sleep on accept failure

    if err := srv.setupHTTP2_Serve(); err != nil {
        return err
    }

    srv.trackListener(l, true)
    defer srv.trackListener(l, false)

    baseCtx := context.Background() // base is always background, per Issue 16220
    ctx := context.WithValue(baseCtx, ServerContextKey, srv)
    for {
        rw, e := l.Accept()
        if e != nil {
            select {
            case &amp;lt;-srv.getDoneChan():
                return ErrServerClosed
            default:
            }
            if ne, ok := e.(net.Error); ok &amp;amp;&amp;amp; ne.Temporary() {
                if tempDelay == 0 {
                    tempDelay = 5 * time.Millisecond
                } else {
                    tempDelay *= 2
                }
                if max := 1 * time.Second; tempDelay &amp;gt; max {
                    tempDelay = max
                }
                srv.logf(&quot;http: Accept error: %v; retrying in %v&quot;, e, tempDelay)
                time.Sleep(tempDelay)
                continue
            }
            return e
        }
        tempDelay = 0
        c := srv.newConn(rw)
        c.setState(c.rwc, StateNew) // before Serve can return
        go c.serve(ctx)
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;for里面l.Accept()接受TCP的连接请求，c := srv.newConn(rw)创建一个Conn，Conn里面保存了该次请求的信息(srv,rw)。启动goroutine，把请求的参数传递给c.serve，让goroutine去执行。&lt;br/&gt;&lt;strong&gt;这个就是GO高并发最关键的点。每一个请求都是一个单独的goroutine去执行。&lt;/strong&gt;&lt;br/&gt;那么前面设置的路由是在哪里匹配的？是在c.serverde的c.readRequest(ctx)里面分析出URI METHOD等，执行serverHandler{c.server}.ServeHTTP(w, w.req)做的。看下代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func (sh serverHandler) ServeHTTP(rw ResponseWriter, req *Request) {
    handler := sh.srv.Handler
    if handler == nil {
        handler = DefaultServeMux
    }
    if req.RequestURI == &quot;*&quot; &amp;amp;&amp;amp; req.Method == &quot;OPTIONS&quot; {
        handler = globalOptionsHandler{}
    }
    handler.ServeHTTP(rw, req)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;handler为空，就我们刚开始项目中的ListenAndServe第二个参数。我们是nil，所以就走DefaultServeMux，我们知道开始路由我们就设置的是DefaultServeMux，所以在DefaultServeMux里面我一定可以找到请求的路由对应的handler，然后执行ServeHTTP。前边已经介绍过，我们的reponse方法为什么具有ServeHTTP的功能。流程大概就是这样的。&lt;/p&gt;
&lt;p&gt;我们看下流程图&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1557931/201903/1557931-20190310072019100-1823662557.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;结语&quot;&gt;结语&lt;/h2&gt;
&lt;p&gt;我们基本已经学习忘了GO 的HTTP的整个工作原理，了解到了它为什么在WEB开发中可以做到高并发，这些也只是GO的冰山一角，还有Redis MySQL的连接池。要熟悉这门语言还是多写多看，才能掌握好它。灵活熟练的使用。&lt;/p&gt;
</description>
<pubDate>Sat, 09 Mar 2019 23:22:00 +0000</pubDate>
<dc:creator>飞翔码农</dc:creator>
<og:description>前言 GO语言在WEB开发领域中的使用越来越广泛，Hired 发布的《2019 软件工程师状态》报告中指出，具有 Go 经验的候选人是迄今为止最具吸引力的。平均每位求职者会收到9 份面试邀请。 想学习</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/feixiangmanon/p/10504081.html</dc:identifier>
</item>
<item>
<title>Python高级应用（3）—— 为你的项目添加验证码 - yangeek</title>
<link>http://www.cnblogs.com/yangva/p/10500669.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yangva/p/10500669.html</guid>
<description>&lt;h2&gt;&lt;span&gt;验证码 &lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;验证码的作用：&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;验证码在现在来说，是很常见的东西，可以一定程度的保护网站，比如防止网络爬虫恶意爬取网站数据啊，减少低级的攻击啊什么的。但是高级点的骚操作还是不太好防范，所以现在的验证码平台也在升级强化，为了把人和机器严格分开。但是这东西，永远都是看哪一方技术高低的，谁的技术高级，谁就能干倒另一方了。详细的就不说了，总而言之，验证码可以说是目前所有的面向用户的平台都会用到的，所以这项技能必须得会啊。当然不是自己写一个验证码平台&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1249183/201903/1249183-20190309215146462-831913978.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt; 常用的验证码平台：&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;腾讯云和阿里云分别都有自己的验证码，然后就极验，还有一些其他的我叫不上名的，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;本教程按极验的官方文档gt3作为案例解析&lt;/strong&gt;&lt;span&gt;     &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;a href=&quot;https://www.geetest.com/&quot; target=&quot;_blank&quot;&gt;极验官网&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;就这博客园的验证码好像也是用的极验，小米官网貌似也用的极验，我感觉极验挺好的，所以采用他们的&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;前提：&lt;/span&gt;&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;环境：后端：Python3的django2&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;安装：&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;1.使用官方教程安装：&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;按照极验的 &lt;a href=&quot;https://docs.geetest.com/install/deploy/server/python&quot; target=&quot;_blank&quot;&gt;官方文档&lt;/a&gt; 来，下载sdk包，解压得：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1249183/201903/1249183-20190309162753322-628457460.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后进入解压的目录，使用python setup.py install安装，但是会报如下错误：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1249183/201903/1249183-20190309134220925-2113476248.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;这是一个坑，官方文档并没有做注明&lt;/strong&gt;&lt;/span&gt;，打开setup文件：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1249183/201903/1249183-20190309134324454-178080091.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;看到了吧，Python中根本没有utf8的编码，改成【utf-8】即可，保存，重新使用命令安装：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1249183/201903/1249183-20190309134500315-1740999339.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 最后提示安装完成：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1249183/201903/1249183-20190309134525658-1656591416.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由极验的官方文档可知，极验支持Python的django ，flask，Tornado 三个框架，这里我使用django简单创建一个示例看是否安装成功，项目名为gtdemo，app名为gtapp:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1249183/201903/1249183-20190309135922214-1699496267.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;按照官方文档，直接导入用使用，但会报错，根本找不到包：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1249183/201903/1249183-20190309164700182-1444572842.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是查看安装的包确实存在的：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1249183/201903/1249183-20190309164804313-2011630708.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;这又是一个坑&lt;/strong&gt;&lt;/span&gt;，此时需要这样，找到刚才那个解压目录下的这了：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1249183/201903/1249183-20190309164617303-226458408.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;将geetest.py文件复制到项目的目录里，我这创建了一个utils文件夹，放到此文件夹里：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1249183/201903/1249183-20190309162954901-1804814180.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;同样的，记得改这里的编码：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1249183/201903/1249183-20190309164944904-1459660042.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后再使用导包命令并运行测试：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1249183/201903/1249183-20190309165127704-397900747.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 没报错，这才是完事儿了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;还有就是此时用的geetest文件并不是安装包根目录的geetest.py文件，这两个文件虽然名字一样，但是是完全不同的，根目录那个文件内容，它只是辅助的安装文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1249183/201903/1249183-20190309165516084-1104930519.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 此时我们用到的文件，全部代码就不展示了，看我勾选的部分，就是我们准备导入的模块：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1249183/201903/1249183-20190309165644588-1145009291.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以这个文件才是对的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2.使用pip安装&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;由于我电脑装了Python2和3，3刚才是按官方文档手动安装的且已经安装了，所以这里在Python2下用pip安装：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1249183/201903/1249183-20190309172803394-1745585855.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注：这里安装之后能不能直接用要自己去试验，我的是可以导包，但是具体开发没有测试，有时间的朋友可以自己测试，我感觉这样安装更方便，但有没有问题就不好说了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1249183/201903/1249183-20190309173340851-1051129672.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;还要一个坑&lt;/strong&gt;&lt;/span&gt;，如果运行django跑不起来，提示要social_django:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1249183/201903/1249183-20190309175418756-1550138231.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;需要安装这个模块 &lt;strong&gt;social-auth-app-django&lt;/strong&gt; 才行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1249183/201903/1249183-20190309175347119-1616751712.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这时会安装一大堆东西，安装完就可以用了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;注册账号&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用别人的东西肯定要有一个账号才行，去极验官网注册一个账号，极验的账号分了个人和公司，按情况来定，我这注册的是个人号，然后完成后面的操作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注册完账号之后登陆极验的后台，这些步骤不用展示了，电脑常识就不啰嗦了，登陆之后选行为验证：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1249183/201903/1249183-20190309170419598-176393112.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;新增一个验证：&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1249183/201903/1249183-20190309170511776-12457795.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;根据情况来填：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1249183/201903/1249183-20190309170534818-1421759642.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;部署：&lt;/span&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;span&gt;部署服务端&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1249183/201903/1249183-20190309170744184-1267988206.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;点这里的指引也可以去官方文档&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1249183/201903/1249183-20190309170803723-1857466914.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在点左边的管理设置，拿到id和key，这是创建验证时自动生成的，这两个参数在代码部署会用到&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1249183/201903/1249183-20190309170942548-493758593.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 现在终于开始代码编写了，后续步骤按照官方文档没什么大的坑了，可以跟着官方文档走了，当然你也可以接着看我的教程，主要就根据实际情况来规划代码怎么编写了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;部署客户端：&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;官方文档里有相关的参数配置：&lt;a href=&quot;https://docs.geetest.com/install/deploy/client/web&quot; target=&quot;_blank&quot;&gt;点我查看&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具体就自己研究了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面给一个实例&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;示例使用&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;创建一个django项目&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;当然在下载geetest时，解压目录里其实有模板，可以直接用那个，当然你也可以自定义，我这就直接用极验官方给的模板&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1249183/201903/1249183-20190309212447889-1247924453.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是注意，官方给的是django1的，如果你的django是1那么直接可以用，如果你的跟我一样是django2，那必须做如下修改才行，我给的都是修改过后的，修改之前直接看给的模板：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;url：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1249183/201903/1249183-20190309212618138-178450457.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;view:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1249183/201903/1249183-20190309212728319-1473601442.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;配置文件里其他不用改，添加这个TEMPLATES参数：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1249183/201903/1249183-20190309212903277-2033129161.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('402b3d28-5081-47f8-9c5a-3cb981672e68')&quot; readability=&quot;38&quot;&gt;&lt;span&gt;&lt;img id=&quot;code_img_closed_402b3d28-5081-47f8-9c5a-3cb981672e68&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_402b3d28-5081-47f8-9c5a-3cb981672e68&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('402b3d28-5081-47f8-9c5a-3cb981672e68',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;
&lt;div id=&quot;cnblogs_code_open_402b3d28-5081-47f8-9c5a-3cb981672e68&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;71&quot;&gt;
&lt;pre&gt;
&lt;span&gt;TEMPLATES =&lt;span&gt; [
    {
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;BACKEND&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;django.template.backends.django.DjangoTemplates&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;DIRS&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: [os.path.join(BASE_DIR, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;templates&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)]
        ,
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;APP_DIRS&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: True,
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;OPTIONS&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: {
            &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;context_processors&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: [
                &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;django.template.context_processors.debug&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;django.template.context_processors.request&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;django.contrib.auth.context_processors.auth&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;django.contrib.messages.context_processors.messages&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
            ],
        },
    },
]&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;把根目录的static文件改成templates：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1249183/201903/1249183-20190309213010670-1753117826.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;启动项目：&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;访问/home:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1249183/201903/1249183-20190309213106552-1388443586.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;点击提交又报错了：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1249183/201903/1249183-20190309213453773-721558526.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;这里又有一个坑&lt;/strong&gt;&lt;/span&gt;，没用过django1和Django2的朋友可能在这里就迷糊了，这里说的意思是WSGIRequest对象没有session属性，我打开wsgi发现根本没啥可改的，经查，还是配置文件的问题，&lt;strong&gt;把MIDDLEWARE_CLASS（这是django1的写法）改成MIDDLEWARE即可&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1249183/201903/1249183-20190309214708122-527486779.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;然后下面这个中间件也要注释掉，不然一样报错&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1249183/201903/1249183-20190309214935673-1448391477.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;调整后测试&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;改好重启，访问/home页面，点击提交，终于有了我们想要的验证了：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1249183/201903/1249183-20190309215033423-1289373958.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;极验提供的验证码，下面还有两个：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1249183/201903/1249183-20190309215416523-1225495061.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1249183/201903/1249183-20190309215446493-1972290084.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 测试了几次之后没有问题&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这几个组件就是极验官方提供的模板，index.html文件里的：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1249183/201903/1249183-20190309220831178-1084542655.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;index.html全部代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('8c775f66-ddea-4419-97ab-3a6a9607b5f5')&quot; readability=&quot;56&quot;&gt;&lt;span&gt;&lt;img id=&quot;code_img_closed_8c775f66-ddea-4419-97ab-3a6a9607b5f5&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_8c775f66-ddea-4419-97ab-3a6a9607b5f5&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('8c775f66-ddea-4419-97ab-3a6a9607b5f5',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;
&lt;div id=&quot;cnblogs_code_open_8c775f66-ddea-4419-97ab-3a6a9607b5f5&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;107&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&amp;gt;
    &amp;lt;title&amp;gt;gt-python-django-demo&amp;lt;/title&amp;gt;
    &amp;lt;style&amp;gt;&lt;span&gt;
        body {
            margin: 50px &lt;/span&gt;0&lt;span&gt;;
            text&lt;/span&gt;-&lt;span&gt;align: center;
        }
        .inp {
            border: 1px solid gray;
            padding: &lt;/span&gt;0&lt;span&gt; 10px;
            width: 200px;
            height: 30px;
            font&lt;/span&gt;-&lt;span&gt;size: 18px;
        }
        .btn {
            border: 1px solid gray;
            width: 100px;
            height: 30px;
            font&lt;/span&gt;-&lt;span&gt;size: 18px;
            cursor: pointer;
        }
        #embed&lt;/span&gt;-&lt;span&gt;captcha {
            width: 300px;
            margin: &lt;/span&gt;0&lt;span&gt; auto;
        }
        .show {
            display: block;
        }
        .hide {
            display: none;
        }
        #notice {
            color: red;
        }
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 以下遮罩层为demo.用户可自行设计实现 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        #mask {
            display: none;
            position: fixed;
            text&lt;/span&gt;-&lt;span&gt;align: center;
            left: &lt;/span&gt;0&lt;span&gt;;
            top: &lt;/span&gt;0&lt;span&gt;;
            width: &lt;/span&gt;100%&lt;span&gt;;
            height: &lt;/span&gt;100%&lt;span&gt;;
            background&lt;/span&gt;-color: rgba(0, 0, 0, 0.5&lt;span&gt;);
            overflow: auto;
        }
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 可自行设计实现captcha的位置大小 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        .popup&lt;/span&gt;-&lt;span&gt;mobile {
            position: relative;
        }
        #popup&lt;/span&gt;-captcha-&lt;span&gt;mobile {
            position: fixed;
            display: none;
            left: &lt;/span&gt;50%&lt;span&gt;;
            top: &lt;/span&gt;50%&lt;span&gt;;
            transform: translate(&lt;/span&gt;-50%, -50%&lt;span&gt;);
            &lt;/span&gt;-webkit-transform: translate(-50%, -50%&lt;span&gt;);
            z&lt;/span&gt;-index: 9999&lt;span&gt;;
        }
    &lt;/span&gt;&amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;h1&amp;gt;极验验证SDKDemo&amp;lt;/h1&amp;gt;
&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;
&amp;lt;hr&amp;gt;
&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;

&amp;lt;!-- 为使用方便，直接使用jquery.js库，如您代码中不需要，可以去掉 --&amp;gt;
&amp;lt;script src=&quot;http://code.jquery.com/jquery-1.12.3.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;!-- 引入封装了failback的接口--initGeetest --&amp;gt;
&amp;lt;script src=&quot;http://static.geetest.com/static/tools/gt.js&quot;&amp;gt;&amp;lt;/script&amp;gt;

&amp;lt;!-- 若是https，使用以下接口 --&amp;gt;
&amp;lt;!-- &amp;lt;script src=&quot;https://code.jquery.com/jquery-1.12.3.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt; --&amp;gt;
&amp;lt;!-- &amp;lt;script src=&quot;https://static.geetest.com/static/tools/gt.js&quot;&amp;gt;&amp;lt;/script&amp;gt; --&amp;gt;

&amp;lt;div class=&quot;popup&quot;&amp;gt;
    &amp;lt;h2&amp;gt;弹出式Demo，使用ajax形式提交二次验证码所需的验证结果值&amp;lt;/h2&amp;gt;
    &amp;lt;br&amp;gt;
    &amp;lt;p&amp;gt;
        &amp;lt;labe&amp;gt;用户名：&amp;lt;/labe&amp;gt;
        &amp;lt;input id=&quot;username1&quot; class=&quot;inp&quot; type=&quot;text&quot; value=&quot;极验验证&quot;&amp;gt;
    &amp;lt;/p&amp;gt;
    &amp;lt;br&amp;gt;
    &amp;lt;p&amp;gt;
        &amp;lt;label&amp;gt;密&amp;amp;nbsp;&amp;amp;nbsp;&amp;amp;nbsp;&amp;amp;nbsp;码：&amp;lt;/label&amp;gt;
        &amp;lt;input id=&quot;password1&quot; class=&quot;inp&quot; type=&quot;password&quot; value=&quot;123456&quot;&amp;gt;
    &amp;lt;/p&amp;gt;

    &amp;lt;br&amp;gt;
    &amp;lt;input class=&quot;btn&quot; id=&quot;popup-submit&quot; type=&quot;submit&quot; value=&quot;提交&quot;&amp;gt;

    &amp;lt;div id=&quot;popup-captcha&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;script&amp;gt;
    &lt;span&gt;var&lt;/span&gt; handlerPopup = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (captchaObj) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 成功的回调&lt;/span&gt;
        captchaObj.onSuccess(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; validate =&lt;span&gt; captchaObj.getValidate();
            $.ajax({
                url: &lt;/span&gt;&quot;/pc-geetest/ajax_validate&quot;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 进行二次验证&lt;/span&gt;
                type: &quot;post&quot;&lt;span&gt;,
                dataType: &lt;/span&gt;&quot;json&quot;&lt;span&gt;,
                data: {
                    username: $(&lt;/span&gt;'#username1'&lt;span&gt;).val(),
                    password: $(&lt;/span&gt;'#password1'&lt;span&gt;).val(),
                    geetest_challenge: validate.geetest_challenge,
                    geetest_validate: validate.geetest_validate,
                    geetest_seccode: validate.geetest_seccode
                },
                success: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (data) {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (data &amp;amp;&amp;amp; (data.status === &quot;success&quot;&lt;span&gt;)) {
                        $(document.body).html(&lt;/span&gt;'&amp;lt;h1&amp;gt;登录成功&amp;lt;/h1&amp;gt;'&lt;span&gt;);
                    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                        $(document.body).html(&lt;/span&gt;'&amp;lt;h1&amp;gt;登录失败&amp;lt;/h1&amp;gt;'&lt;span&gt;);
                    }
                }
            });
        });
        $(&lt;/span&gt;&quot;#popup-submit&quot;).click(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
            captchaObj.show();
        });
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将验证码加到id为captcha的元素里&lt;/span&gt;
        captchaObj.appendTo(&quot;#popup-captcha&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 更多接口参考：http://www.geetest.com/install/sections/idx-client-sdk.html&lt;/span&gt;
&lt;span&gt;    };
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 验证开始需要向网站主后台获取id，challenge，success（是否启用failback）&lt;/span&gt;
&lt;span&gt;    $.ajax({
        url: &lt;/span&gt;&quot;/pc-geetest/register?t=&quot; + (&lt;span&gt;new&lt;/span&gt; Date()).getTime(), &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 加随机数防止缓存&lt;/span&gt;
        type: &quot;get&quot;&lt;span&gt;,
        dataType: &lt;/span&gt;&quot;json&quot;&lt;span&gt;,
        success: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (data) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用initGeetest接口&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 参数1：配置参数&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 参数2：回调，回调的第一个参数验证码对象，之后可以使用它做appendTo之类的事件&lt;/span&gt;
&lt;span&gt;            initGeetest({
                gt: data.gt,
                challenge: data.challenge,
                product: &lt;/span&gt;&quot;popup&quot;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 产品形式，包括：float，embed，popup。注意只对PC版验证码有效&lt;/span&gt;
                offline: !data.success &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 表示用户后台检测极验服务器是否宕机，一般不需要关注&lt;/span&gt;
                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 更多配置参数请参见：http://www.geetest.com/install/sections/idx-client-sdk.html#config&lt;/span&gt;
&lt;span&gt;            }, handlerPopup);
        }
    });
&lt;/span&gt;&amp;lt;/script&amp;gt;
&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;
&amp;lt;hr&amp;gt;
&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;
&amp;lt;form class=&quot;popup&quot; action=&quot;/pc-geetest/validate&quot; method=&quot;post&quot;&amp;gt;
    &amp;lt;h2&amp;gt;嵌入式Demo，使用表单形式提交二次验证所需的验证结果值&amp;lt;/h2&amp;gt;
    &amp;lt;br&amp;gt;
    &amp;lt;p&amp;gt;
        &amp;lt;label &lt;span&gt;for&lt;/span&gt;=&quot;username2&quot;&amp;gt;用户名：&amp;lt;/label&amp;gt;
        &amp;lt;input class=&quot;inp&quot; id=&quot;username2&quot; type=&quot;text&quot; value=&quot;极验验证&quot;&amp;gt;
    &amp;lt;/p&amp;gt;
    &amp;lt;br&amp;gt;
    &amp;lt;p&amp;gt;
        &amp;lt;label &lt;span&gt;for&lt;/span&gt;=&quot;password2&quot;&amp;gt;密&amp;amp;nbsp;&amp;amp;nbsp;&amp;amp;nbsp;&amp;amp;nbsp;码：&amp;lt;/label&amp;gt;
        &amp;lt;input class=&quot;inp&quot; id=&quot;password2&quot; type=&quot;password&quot; value=&quot;123456&quot;&amp;gt;
    &amp;lt;/p&amp;gt;

    &amp;lt;div id=&quot;embed-captcha&quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;p id=&quot;wait&quot; class=&quot;show&quot;&amp;gt;正在加载验证码......&amp;lt;/p&amp;gt;
    &amp;lt;p id=&quot;notice&quot; class=&quot;hide&quot;&amp;gt;请先拖动验证码到相应位置&amp;lt;/p&amp;gt;

    &amp;lt;br&amp;gt;
    &amp;lt;input class=&quot;btn&quot; id=&quot;embed-submit&quot; type=&quot;submit&quot; value=&quot;提交&quot;&amp;gt;
&amp;lt;/form&amp;gt;

&amp;lt;script&amp;gt;
    &lt;span&gt;var&lt;/span&gt; handlerEmbed = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (captchaObj) {
        $(&lt;/span&gt;&quot;#embed-submit&quot;).click(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (e) {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; validate =&lt;span&gt; captchaObj.getValidate();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;validate) {
                $(&lt;/span&gt;&quot;#notice&quot;)[0].className = &quot;show&quot;&lt;span&gt;;
                setTimeout(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
                    $(&lt;/span&gt;&quot;#notice&quot;)[0].className = &quot;hide&quot;&lt;span&gt;;
                }, &lt;/span&gt;2000&lt;span&gt;);
                e.preventDefault();
            }
        });
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将验证码加到id为captcha的元素里，同时会有三个input的值：geetest_challenge, geetest_validate, geetest_seccode&lt;/span&gt;
        captchaObj.appendTo(&quot;#embed-captcha&quot;&lt;span&gt;);
        captchaObj.onReady(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
            $(&lt;/span&gt;&quot;#wait&quot;)[0].className = &quot;hide&quot;&lt;span&gt;;
        });
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 更多接口参考：http://www.geetest.com/install/sections/idx-client-sdk.html&lt;/span&gt;
&lt;span&gt;    };
    $.ajax({
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取id，challenge，success（是否启用failback）&lt;/span&gt;
        url: &quot;/pc-geetest/register?t=&quot; + (&lt;span&gt;new&lt;/span&gt; Date()).getTime(), &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 加随机数防止缓存&lt;/span&gt;
        type: &quot;get&quot;&lt;span&gt;,
        dataType: &lt;/span&gt;&quot;json&quot;&lt;span&gt;,
        success: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (data) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用initGeetest接口&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 参数1：配置参数&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 参数2：回调，回调的第一个参数验证码对象，之后可以使用它做appendTo之类的事件&lt;/span&gt;
&lt;span&gt;            initGeetest({
                gt: data.gt,
                challenge: data.challenge,
                product: &lt;/span&gt;&quot;embed&quot;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 产品形式，包括：float，embed，popup。注意只对PC版验证码有效&lt;/span&gt;
                offline: !data.success &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 表示用户后台检测极验服务器是否宕机，一般不需要关注&lt;/span&gt;
                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 更多配置参数请参见：http://www.geetest.com/install/sections/idx-client-sdk.html#config&lt;/span&gt;
&lt;span&gt;            }, handlerEmbed);
        }
    });
&lt;/span&gt;&amp;lt;/script&amp;gt;
&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;
&amp;lt;hr&amp;gt;
&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;
&amp;lt;div class=&quot;popup-mobile&quot;&amp;gt;
    &amp;lt;h2&amp;gt;移动端手动实现弹出式Demo&amp;lt;/h2&amp;gt;
    &amp;lt;br&amp;gt;
    &amp;lt;p&amp;gt;
        &amp;lt;labe &lt;span&gt;for&lt;/span&gt;=&quot;username3&quot;&amp;gt;用户名：&amp;lt;/labe&amp;gt;
        &amp;lt;input id=&quot;username3&quot; class=&quot;inp&quot; type=&quot;text&quot; value=&quot;极验验证&quot;&amp;gt;
    &amp;lt;/p&amp;gt;
    &amp;lt;br&amp;gt;
    &amp;lt;p&amp;gt;
        &amp;lt;label &lt;span&gt;for&lt;/span&gt;=&quot;password3&quot;&amp;gt;密&amp;amp;nbsp;&amp;amp;nbsp;&amp;amp;nbsp;&amp;amp;nbsp;码：&amp;lt;/label&amp;gt;
        &amp;lt;input id=&quot;password3&quot; class=&quot;inp&quot; type=&quot;password&quot; value=&quot;123456&quot;&amp;gt;
    &amp;lt;/p&amp;gt;
    &amp;lt;br&amp;gt;
    &amp;lt;input class=&quot;btn&quot; id=&quot;popup-submit-mobile&quot; type=&quot;submit&quot; value=&quot;提交&quot;&amp;gt;
    &amp;lt;div id=&quot;mask&quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div id=&quot;popup-captcha-mobile&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;script&amp;gt;&lt;span&gt;
    $(&lt;/span&gt;&quot;#mask&quot;).click(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        $(&lt;/span&gt;&quot;#mask, #popup-captcha-mobile&quot;&lt;span&gt;).hide();
    });
    $(&lt;/span&gt;&quot;#popup-submit-mobile&quot;).click(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        $(&lt;/span&gt;&quot;#mask, #popup-captcha-mobile&quot;&lt;span&gt;).show();
    });
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; handlerPopupMobile = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (captchaObj) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将验证码加到id为captcha的元素里&lt;/span&gt;
&lt;span&gt;
        captchaObj.appendTo(&lt;/span&gt;&quot;#popup-captcha-mobile&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;拖动验证成功后两秒(可自行设置时间)自动发生跳转等行为&lt;/span&gt;
        captchaObj.onSuccess(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; validate =&lt;span&gt; captchaObj.getValidate();
            $.ajax({
                url: &lt;/span&gt;&quot;/mobile-geetest/ajax_validate&quot;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 进行二次验证&lt;/span&gt;
                type: &quot;post&quot;&lt;span&gt;,
                dataType: &lt;/span&gt;&quot;json&quot;&lt;span&gt;,
                data: {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 二次验证所需的三个值&lt;/span&gt;
                    username: $('#username3'&lt;span&gt;).val(),
                    password: $(&lt;/span&gt;'#password3'&lt;span&gt;).val(),
                    geetest_challenge: validate.geetest_challenge,
                    geetest_validate: validate.geetest_validate,
                    geetest_seccode: validate.geetest_seccode
                },
                success: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (data) {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (data &amp;amp;&amp;amp; (data.status === &quot;success&quot;&lt;span&gt;)) {
                        $(document.body).html(&lt;/span&gt;'&amp;lt;h1&amp;gt;登录成功&amp;lt;/h1&amp;gt;'&lt;span&gt;);
                    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                        $(document.body).html(&lt;/span&gt;'&amp;lt;h1&amp;gt;登录失败&amp;lt;/h1&amp;gt;'&lt;span&gt;);
                    }
                }
            });
        });
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 更多接口参考：http://www.geetest.com/install/sections/idx-client-sdk.html&lt;/span&gt;
&lt;span&gt;    };
    $.ajax({
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取id，challenge，success（是否启用failback）&lt;/span&gt;
        url: &quot;/mobile-geetest/register?t=&quot; + (&lt;span&gt;new&lt;/span&gt; Date()).getTime(), &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 加随机数防止缓存&lt;/span&gt;
        type: &quot;get&quot;&lt;span&gt;,
        dataType: &lt;/span&gt;&quot;json&quot;&lt;span&gt;,
        success: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (data) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用initGeetest接口&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 参数1：配置参数&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 参数2：回调，回调的第一个参数验证码对象，之后可以使用它做appendTo之类的事件&lt;/span&gt;
&lt;span&gt;            initGeetest({
                gt: data.gt,
                challenge: data.challenge,
                offline: &lt;/span&gt;!data.success &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 表示用户后台检测极验服务器是否宕机，一般不需要关注&lt;/span&gt;
                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 更多配置参数请参见：http://www.geetest.com/install/sections/idx-client-sdk.html#config&lt;/span&gt;
&lt;span&gt;            }, handlerPopupMobile);
        }
    });
&lt;/span&gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;index.html&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;官方文档里还有很多验证组件：&lt;a href=&quot;https://docs.geetest.com/install/deploy/client/web&quot; target=&quot;_blank&quot;&gt;点我查看&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;感兴趣自己去研究了，实际开发的话，就根据自己的情况稍微改改就行了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;实际案例：&lt;/span&gt;&lt;/h2&gt;

&lt;p&gt;&lt;span&gt;本次选用的验证组件时最常用的先滑动认证，再提交表单的：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1249183/201903/1249183-20190309223526729-1545741435.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;做一个简单的登录验证平台，但是不完全用极验官方的，业务代码自己做，毕竟这东西要拿到我们实际开发中，不可能只用用官方给的几个小demo就完事儿了，开发环境是Python的django2：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;创建一个django项目：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1249183/201903/1249183-20190309222743878-492725627.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后配置：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;url，注意关于两个极验的url都指向的是一个视图类：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1249183/201903/1249183-20190310003628915-346003488.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;view:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1249183/201903/1249183-20190310003954907-1476889300.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;html:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;标签元素部分：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1249183/201903/1249183-20190310004034019-896535290.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;js部分：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1249183/201903/1249183-20190310004113049-1393826531.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意，&lt;span&gt;&lt;strong&gt;这里还有一个坑&lt;/strong&gt;&lt;/span&gt;，玛德，在这耗了有点久，因为geetest调用了request.session，所以，使用django默认的数据库表django_session，必须要先迁移数据库，再启动项目访问，不然报如下错：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;django.db.utils.OperationalError: no such table: django_session&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最后启动访问：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1249183/201903/1249183-20190310004302883-2061706921.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;点击验证：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1249183/201903/1249183-20190310004329596-79352379.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 验证成功的，后面的结果就不展示了&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;详细的代码，其实都没改多少，就只是把自己的业务逻辑加上去了，其他的都是直接用极验官方的&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('8f44d67f-a2fd-4e2f-ba5d-653d523a0055')&quot; readability=&quot;37&quot;&gt;&lt;span&gt;&lt;img id=&quot;code_img_closed_8f44d67f-a2fd-4e2f-ba5d-653d523a0055&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_8f44d67f-a2fd-4e2f-ba5d-653d523a0055&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('8f44d67f-a2fd-4e2f-ba5d-653d523a0055',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;
&lt;div id=&quot;cnblogs_code_open_8f44d67f-a2fd-4e2f-ba5d-653d523a0055&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;69&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;from&lt;/span&gt; django.contrib &lt;span&gt;import&lt;/span&gt;&lt;span&gt; admin
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; django.urls &lt;span&gt;import&lt;/span&gt;&lt;span&gt; re_path, path
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; generic.views &lt;span&gt;import&lt;/span&gt;&lt;span&gt; AuthView
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; generic.views &lt;span&gt;import&lt;/span&gt;&lt;span&gt; GtView

urlpatterns &lt;/span&gt;=&lt;span&gt; [
    path(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;admin/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, admin.site.urls),
    path(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;auth/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, AuthView.as_view()),
    re_path(r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;^pc-geetest/register&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, GtView.as_view()),
    re_path(r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;^pc-geetest/validate$&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, GtView.as_view()),
]&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;url&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('e53c218a-bf23-4d92-9992-a8fe99d1bc34')&quot; readability=&quot;39.5&quot;&gt;&lt;span&gt;&lt;img id=&quot;code_img_closed_e53c218a-bf23-4d92-9992-a8fe99d1bc34&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_e53c218a-bf23-4d92-9992-a8fe99d1bc34&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('e53c218a-bf23-4d92-9992-a8fe99d1bc34',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;
&lt;div id=&quot;cnblogs_code_open_e53c218a-bf23-4d92-9992-a8fe99d1bc34&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;74&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; coding:utf-8&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; django.shortcuts &lt;span&gt;import&lt;/span&gt;&lt;span&gt; render
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; django.http &lt;span&gt;import&lt;/span&gt;&lt;span&gt; HttpResponse
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; django.views &lt;span&gt;import&lt;/span&gt;&lt;span&gt; View
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; utils.geetest &lt;span&gt;import&lt;/span&gt;&lt;span&gt; GeetestLib

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这个id和key是官方的demo里的，用于展示测试，最好还是注册一个好点，详细步骤看上面的教程&lt;/span&gt;
&lt;span&gt;
pc_geetest_id &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;b46d1900d0a894591916ea94ea91bd2c&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
pc_geetest_key &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;36fc3fe98530eea08dfc6ce76e3d24c4&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;


&lt;span&gt;class&lt;/span&gt;&lt;span&gt; AuthView(View):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get(self, request):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; render(request, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;index.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; GtView(View):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get(self, request):
        user_id &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        gt &lt;/span&gt;=&lt;span&gt; GeetestLib(pc_geetest_id, pc_geetest_key)
        status &lt;/span&gt;=&lt;span&gt; gt.pre_process(user_id)
        request.session[gt.GT_STATUS_SESSION_KEY] &lt;/span&gt;=&lt;span&gt; status
        request.session[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user_id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] =&lt;span&gt; user_id
        response_str &lt;/span&gt;=&lt;span&gt; gt.get_response_str()
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; HttpResponse(response_str)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; post(self, request):
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; request.method == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;POST&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
            gt &lt;/span&gt;=&lt;span&gt; GeetestLib(pc_geetest_id, pc_geetest_key)
            challenge &lt;/span&gt;= request.POST.get(gt.FN_CHALLENGE, &lt;span&gt;''&lt;/span&gt;&lt;span&gt;)
            validate &lt;/span&gt;= request.POST.get(gt.FN_VALIDATE, &lt;span&gt;''&lt;/span&gt;&lt;span&gt;)
            seccode &lt;/span&gt;= request.POST.get(gt.FN_SECCODE, &lt;span&gt;''&lt;/span&gt;&lt;span&gt;)
            status &lt;/span&gt;=&lt;span&gt; request.session[gt.GT_STATUS_SESSION_KEY]
            user_id &lt;/span&gt;= request.session[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user_id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; status:
                result &lt;/span&gt;=&lt;span&gt; gt.success_validate(challenge, validate, seccode, user_id)
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                result &lt;/span&gt;=&lt;span&gt; gt.failback_validate(challenge, validate, seccode)
            result &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;&amp;lt;h1&amp;gt;登录成功&amp;lt;/h1&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; result &lt;span&gt;else&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;&amp;lt;h1&amp;gt;登录失败&amp;lt;/h1&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; HttpResponse(result)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; HttpResponse(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;error&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;views&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('c61ad803-4513-46d3-8abe-a2c4a4598ccc')&quot; readability=&quot;38&quot;&gt;&lt;span&gt;&lt;img id=&quot;code_img_closed_c61ad803-4513-46d3-8abe-a2c4a4598ccc&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_c61ad803-4513-46d3-8abe-a2c4a4598ccc&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('c61ad803-4513-46d3-8abe-a2c4a4598ccc',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;
&lt;div id=&quot;cnblogs_code_open_c61ad803-4513-46d3-8abe-a2c4a4598ccc&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;71&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;meta name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;viewport&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; content=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;width=device-width, initial-scale=1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;title&amp;gt;gt-python-django-demo&amp;lt;/title&amp;gt;
    &amp;lt;style&amp;gt;&lt;span&gt;
        body {
            margin: 50px 0;
            text&lt;/span&gt;-&lt;span&gt;align: center;
        }
        .inp {
            border: 1px solid gray;
            padding: 0 10px;
            width: 200px;
            height: 30px;
            font&lt;/span&gt;-&lt;span&gt;size: 18px;
        }
        .btn {
            border: 1px solid gray;
            width: 100px;
            height: 30px;
            font&lt;/span&gt;-&lt;span&gt;size: 18px;
            cursor: pointer;
        }
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;embed-captcha {&lt;/span&gt;
&lt;span&gt;            width: 300px;
            margin: 0 auto;
        }
        .show {
            display: block;
        }
        .hide {
            display: none;
        }
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;notice {&lt;/span&gt;
&lt;span&gt;            color: red;
        }


    &lt;/span&gt;&amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;h1&amp;gt;请登录&amp;lt;/h1&amp;gt;
&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;

&amp;lt;!-- 为使用方便，直接使用jquery.js库，如您代码中不需要，可以去掉 --&amp;gt;
&amp;lt;script src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://code.jquery.com/jquery-1.12.3.min.js&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;!-- 引入封装了failback的接口--initGeetest --&amp;gt;
&amp;lt;script src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://static.geetest.com/static/tools/gt.js&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;


&amp;lt;form &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;popup&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; action=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/pc-geetest/validate&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; method=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;post&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;p&amp;gt;
        &amp;lt;label &lt;span&gt;for&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;username2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;用户名：&amp;lt;/label&amp;gt;
        &amp;lt;input &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;inp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;username2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;极验验证&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;/p&amp;gt;
    &amp;lt;br&amp;gt;
    &amp;lt;p&amp;gt;
        &amp;lt;label &lt;span&gt;for&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;password2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;密&amp;amp;nbsp;&amp;amp;nbsp;&amp;amp;nbsp;&amp;amp;nbsp;码：&amp;lt;/label&amp;gt;
        &amp;lt;input &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;inp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;password2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;password&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123456&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;/p&amp;gt;

    &amp;lt;div id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;embed-captcha&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;p id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wait&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;show&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;正在加载验证码......&amp;lt;/p&amp;gt;
    &amp;lt;p id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;notice&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hide&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;请先拖动验证码到相应位置&amp;lt;/p&amp;gt;

    &amp;lt;br&amp;gt;
    &amp;lt;input &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;btn&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;embed-submit&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;submit&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;提交&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&amp;lt;/form&amp;gt;

&amp;lt;script&amp;gt;&lt;span&gt;
    var handlerEmbed &lt;/span&gt;=&lt;span&gt; function (captchaObj) {
        $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#embed-submit&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).click(function (e) {
            var validate &lt;/span&gt;=&lt;span&gt; captchaObj.getValidate();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (!validate) {
                $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#notice&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)[0].className = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;show&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                setTimeout(function () {
                    $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#notice&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)[0].className = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hide&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                }, &lt;/span&gt;2000&lt;span&gt;);
                e.preventDefault();
            }
        });
        &lt;/span&gt;//&lt;span&gt; 将验证码加到id为captcha的元素里，同时会有三个input的值：geetest_challenge, geetest_validate, geetest_seccode
        captchaObj.appendTo(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#embed-captcha&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        captchaObj.onReady(function () {
            $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#wait&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)[0].className = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hide&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        });
        &lt;/span&gt;// 更多接口参考：http://www.geetest.com/install/sections/idx-client-&lt;span&gt;sdk.html
    };
    $.ajax({
        &lt;/span&gt;//&lt;span&gt; 获取id，challenge，success（是否启用failback）
        url: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/pc-geetest/register?t=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + (new Date()).getTime(), //&lt;span&gt; 加随机数防止缓存
        type: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        dataType: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        success: function (data) {
            &lt;/span&gt;//&lt;span&gt; 使用initGeetest接口
            &lt;/span&gt;//&lt;span&gt; 参数1：配置参数
            &lt;/span&gt;//&lt;span&gt; 参数2：回调，回调的第一个参数验证码对象，之后可以使用它做appendTo之类的事件
            initGeetest({
                gt: data.gt,
                challenge: data.challenge,
                product: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;embed&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, //&lt;span&gt; 产品形式，包括：float，embed，popup。注意只对PC版验证码有效
                offline: !data.success &lt;/span&gt;//&lt;span&gt; 表示用户后台检测极验服务器是否宕机，一般不需要关注
                &lt;/span&gt;// 更多配置参数请参见：http://www.geetest.com/install/sections/idx-client-sdk.html&lt;span&gt;#&lt;/span&gt;&lt;span&gt;config&lt;/span&gt;
&lt;span&gt;            }, handlerEmbed);
        }
    });
&lt;/span&gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;html模板文件&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;总结：&lt;/span&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;1.根据官方文档的步骤来，然后遇到像我这样的问题就可以试试我的解决方法，还不行自己多研究&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;2.多看官方文档，感觉还是挺简单的&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;3.注意我提到的那几个坑&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;4.自建的项目，一定要迁移数据库，再运行项目&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;





&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 09 Mar 2019 17:02:00 +0000</pubDate>
<dc:creator>yangeek</dc:creator>
<og:description>验证码的作用： 验证码在现在来说，是很常见的东西，可以一定程度的保护网站，减少低级的攻击，但是高级的还是不太好防范，所以现在的验证码平台也在升级强化，为了把人和机器严格分开，但是这东西，永远都是看哪</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yangva/p/10500669.html</dc:identifier>
</item>
<item>
<title>从零开始搭建etcd分布式存储系统+web管理界面 - 雪山飞猪</title>
<link>http://www.cnblogs.com/chenqionghe/p/10503840.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenqionghe/p/10503840.html</guid>
<description>&lt;p&gt;随着CoreOS和Kubernetes等项目在开源社区日益火热，它们项目中都用到的etcd组件作为一个高可用、强一致性的服务发现存储仓库，渐渐为开发人员所关注。&lt;br/&gt;在云计算时代，如何让服务快速透明地接入到计算集群中，如何让共享配置信息快速被集群中的所有机器发现，&lt;br/&gt;更为重要的是，如何构建这样一套高可用、安全、易于部署以及响应快速的服务集群，已经成为了迫切需要解决的问题。&lt;br/&gt;etcd为解决这类问题带来了福音，它是一个高可用的 Key/Value 存储系统，内部采用raft协议作为一致性算法。&lt;br/&gt;准备好了吗，干货要来了，are you ok ?&lt;/p&gt;
&lt;h2 id=&quot;本飞猪教程内容简介&quot;&gt;本飞猪教程内容简介&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;1.etcd的安装&lt;/li&gt;
&lt;li&gt;2.搭建单机版&lt;/li&gt;
&lt;li&gt;3.搭建集群版&lt;/li&gt;
&lt;li&gt;4.使用监听功能watch(服务发现)&lt;/li&gt;
&lt;li&gt;5.使用rest api&lt;/li&gt;
&lt;li&gt;6.搭建WEB界面并使用&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;下载地址httpsgithub.comcoreosetcdreleases&quot;&gt;下载地址：&lt;a href=&quot;https://github.com/coreos/etcd/releases/&quot; class=&quot;uri&quot;&gt;https://github.com/coreos/etcd/releases/&lt;/a&gt;&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;mkdir -p /home/chenqionghe/test/etcd/
cd !$
# 下载
wget https://github.com/etcd-io/etcd/releases/download/v3.3.12/etcd-v3.3.12-linux-amd64.tar.gz
# 解压安装
tar zxvf etcd-v3.3.12-linux-amd64.tar.gz
cd etcd-v3.3.12-linux-amd64
## 将启动文件和命令管理文件拷贝到 PATH找到的路径中
cp etcd /usr/local/bin
cp etcdctl /usr/local/bin
cp -r etcd-v3.2.5-linux-amd64 /usr/local/etcd  #将软件放置到常用目录下&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;启动参数解释&quot;&gt;启动参数解释&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;--name
etcd集群中的节点名，这里可以随意，可区分且不重复就行  
--listen-peer-urls
监听的用于节点之间通信的url，可监听多个，集群内部将通过这些url进行数据交互(如选举，数据同步等)
--initial-advertise-peer-urls 
建议用于节点之间通信的url，节点间将以该值进行通信。
--listen-client-urls
监听的用于客户端通信的url,同样可以监听多个。
--advertise-client-urls
建议使用的客户端通信url,该值用于etcd代理或etcd成员与etcd节点通信。
--initial-cluster-token etcd-cluster-1
节点的token值，设置该值后集群将生成唯一id,并为每个节点也生成唯一id,当使用相同配置文件再启动一个集群时，只要该token值不一样，etcd集群就不会相互影响。
--initial-cluster
也就是集群中所有的initial-advertise-peer-urls 的合集
--initial-cluster-state new
新建集群的标志&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;直接启动&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;etcd&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;etcd默认监听的是localhost的2379端口，既只监听了lo设备，这样会导致启动后集群中的其他机器无法访问&lt;br/&gt;因此我们可以在启动的时候将默认的localhost改成0.0.0.0,确保etcd监听了所有网卡。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;etcd -listen-client-urls=&quot;http://0.0.0.0:2379&quot; --advertise-client-urls=&quot;http://0.0.0.0:2379&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：etcd有要求，如果--listen-client-urls被设置了，那么就必须同时设置--advertise-client-urls，所以即使设置和默认相同，也必须显式设置&lt;br/&gt;我们来使用curl来测试一下，是否可以远程访问，这里我的机器IP是10.211.55.25&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;➜  ~ curl -L  http://10.211.55.25:2379/version
{&quot;etcdserver&quot;:&quot;3.3.12&quot;,&quot;etcdcluster&quot;:&quot;3.3.0&quot;}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然，我们也可以通过docker运行，这里给出启动脚本&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#!/usr/bin/env bash
ETCD_NAME=&quot;etcd&quot;
ETCD_VERSION=&quot;v3.3.1&quot;
ETCD_PORT_CLIENT=2379
ETCD_PORT_NODE=2380
docker run -d \
  -p ${ETCD_PORT_CLIENT}:2379 \
  -p ${ETCD_PORT_NODE}:2380 \
  --name ${ETCD_NAME} quay.io/coreos/etcd:${ETCD_VERSION} \
  /usr/local/bin/etcd \
  --data-dir=/etcd-data --name node1 \
  --initial-advertise-peer-urls http://0.0.0.0:2380 --listen-peer-urls http://0.0.0.0:2380 \
  --advertise-client-urls http://0.0.0.0:2379 --listen-client-urls http://0.0.0.0:2379 \
  --initial-cluster node1=http://0.0.0.0:2380&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;Etcd构建自身高可用集群主要有三种形式:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;静态发现: 预先已知 Etcd 集群中有哪些节点，在启动时直接指定好Etcd的各个node节点地址&lt;/li&gt;
&lt;li&gt;Etcd动态发现: 通过已有的Etcd集群作为数据交互点，然后在扩展新的集群时实现通过已有集群进行服务发现的机制&lt;/li&gt;
&lt;li&gt;DNS动态发现: 通过DNS查询方式获取其他节点地址信息&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里我们采用Static方式，准备三台机器，ip如下(都已经安装etcd)&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;node1 10.211.55.2
node2 10.211.55.25
node3 10.211.55.26&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;进入node1创建并运行run.sh脚本内容如下&quot;&gt;进入node1，创建并运行run.sh,脚本内容如下&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;#!/usr/bin/env bash
#节点名称
ETCD_NAME=node-1
#本机IP地址
LOCAL_IP=10.211.55.2
#ETCD存储目录
ETCD_DATA_DIR=/usr/local/etcd/data
#初始化名称
INITIAL_CLUSTER_TOKEN=cqh-test-cluster
#初始化群集列表
INITIAL_CLUSTER=&quot;node-1=http://10.211.55.2:2380,node-2=http://10.211.55.25:2380,node-3=http://10.211.55.26:2380&quot;
#初始化状态
INITIAL_CLUSTER_STATE=new

#开始运行
etcd --name ${ETCD_NAME} --data-dir ${ETCD_DATA_DIR} \
    --initial-advertise-peer-urls http://${LOCAL_IP}:2380 \
    --listen-peer-urls http://${LOCAL_IP}:2380 \
    --listen-client-urls http://${LOCAL_IP}:2379,http://127.0.0.1:2379 \
    --advertise-client-urls http://${LOCAL_IP}:2379 \
    --initial-cluster-token ${INITIAL_CLUSTER_TOKEN} \
    --initial-cluster ${INITIAL_CLUSTER} \
    --initial-cluster-state ${INITIAL_CLUSTER_STATE}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;进入node2创建并运行run.sh脚本内容和node1差不多只修改了etcd_name和local_ip&quot;&gt;进入node2，创建并运行run.sh,脚本内容和node1差不多(只修改了ETCD_NAME和LOCAL_IP)&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;#!/usr/bin/env bash
#节点名称
ETCD_NAME=node-2
#本机IP地址
LOCAL_IP=10.211.55.25
#ETCD存储目录
ETCD_DATA_DIR=/usr/local/etcd/data
#初始化名称
INITIAL_CLUSTER_TOKEN=cqh-test-cluster
#初始化群集列表
INITIAL_CLUSTER=&quot;node-1=http://10.211.55.2:2380,node-2=http://10.211.55.25:2380,node-3=http://10.211.55.26:2380&quot;
#初始化状态
INITIAL_CLUSTER_STATE=new

#开始运行
etcd --name ${ETCD_NAME} --data-dir ${ETCD_DATA_DIR} \
    --initial-advertise-peer-urls http://${LOCAL_IP}:2380 \
    --listen-peer-urls http://${LOCAL_IP}:2380 \
    --listen-client-urls http://${LOCAL_IP}:2379,http://127.0.0.1:2379 \
    --advertise-client-urls http://${LOCAL_IP}:2379 \
    --initial-cluster-token ${INITIAL_CLUSTER_TOKEN} \
    --initial-cluster ${INITIAL_CLUSTER} \
    --initial-cluster-state ${INITIAL_CLUSTER_STATE}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;进入node3创建并运行run.sh&quot;&gt;进入node3，创建并运行run.sh&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;#!/usr/bin/env bash
#节点名称
ETCD_NAME=node-3
#本机IP地址
LOCAL_IP=10.211.55.26
#ETCD存储目录
ETCD_DATA_DIR=/usr/local/etcd/data
#初始化名称
INITIAL_CLUSTER_TOKEN=cqh-test-cluster
#初始化群集列表
INITIAL_CLUSTER=&quot;node-1=http://10.211.55.2:2380,node-2=http://10.211.55.25:2380,node-3=http://10.211.55.26:2380&quot;
#初始化状态
INITIAL_CLUSTER_STATE=new

#开始运行
etcd --name ${ETCD_NAME} --data-dir ${ETCD_DATA_DIR} \
    --initial-advertise-peer-urls http://${LOCAL_IP}:2380 \
    --listen-peer-urls http://${LOCAL_IP}:2380 \
    --listen-client-urls http://${LOCAL_IP}:2379,http://127.0.0.1:2379 \
    --advertise-client-urls http://${LOCAL_IP}:2379 \
    --initial-cluster-token ${INITIAL_CLUSTER_TOKEN} \
    --initial-cluster ${INITIAL_CLUSTER} \
    --initial-cluster-state ${INITIAL_CLUSTER_STATE}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们看到3台都启动成功了&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/662544/201903/662544-20190309162729328-247703802.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后我们在node2上面执行操作&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;root@ubuntu:~# etcdctl member list
2033c1336b929ca7: name=node-3 peerURLs=http://10.211.55.26:2380 clientURLs=http://10.211.55.26:2379 isLeader=true
edc51d36208cfbcf: name=node-2 peerURLs=http://10.211.55.25:2380 clientURLs=http://10.211.55.25:2379 isLeader=false
f09a9dba19a725e2: name=node-1 peerURLs=http://10.211.55.2:2380 clientURLs=http://10.211.55.2:2379 isLeader=false&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到集群已经生效了，我们再来测试一下，在ndoe2上执行操作&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;etcdctl set /cqh muscle&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看看node1和node3是否能保持数据一致&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/662544/201903/662544-20190309162747867-909035441.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到在node1和node3中都能能够正确的获取/cqh的值&lt;/p&gt;

&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;etcdctl watch key&lt;br/&gt;观察一个值的变化，观察到变化后，打印值并watch退出&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/662544/201903/662544-20190309162954577-640581995.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;etcdctl watch key -f&lt;br/&gt;永久观察值的变化，观察到变化后，打印直到Ctrl+C退出&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/662544/201903/662544-20190309162808158-1002263230.png&quot;/&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;etcdctl exec-watch key -- sh -c 'pwd'&lt;br/&gt;监听到值有变化，就执行指定的命令（且不退出执行的可以是shell命令）&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/662544/201903/662544-20190309163638750-1500965517.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;&lt;li&gt;创建键值&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;➜  ~ curl http://10.211.55.25:2379/v2/keys/cqh -XPUT -d value=&quot;陈琼和1&quot;
{&quot;action&quot;:&quot;set&quot;,&quot;node&quot;:{&quot;key&quot;:&quot;/cqh&quot;,&quot;value&quot;:&quot;陈琼和&quot;,&quot;modifiedIndex&quot;:14,&quot;createdIndex&quot;:14},&quot;prevNode&quot;:{&quot;key&quot;:&quot;/cqh&quot;,&quot;value&quot;:&quot;陈琼和&quot;,&quot;modifiedIndex&quot;:13,&quot;createdIndex&quot;:13}}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;创建目录&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;➜  ~ curl http://10.211.55.25:2379/v2/keys/gym -XPUT -d dir=true
{&quot;action&quot;:&quot;set&quot;,&quot;node&quot;:{&quot;key&quot;:&quot;/gym&quot;,&quot;dir&quot;:true,&quot;modifiedIndex&quot;:12,&quot;createdIndex&quot;:12}}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;获取键值&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;➜  ~ curl http://10.211.55.25:2379/v2/keys/cqh
{&quot;action&quot;:&quot;get&quot;,&quot;node&quot;:{&quot;key&quot;:&quot;/cqh&quot;,&quot;value&quot;:&quot;陈琼和&quot;,&quot;modifiedIndex&quot;:14,&quot;createdIndex&quot;:14}}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;创建键值带ttl&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;➜  ~ curl http://10.211.55.25:2379/v2/keys/hero -XPUT -d value=&quot;超人&quot; -d ttl=5&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;创建有序键值&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;curl http://10.211.55.25:2379/v2/keys/fitness -XPOST -d value=&quot;bench_press&quot;
curl http://10.211.55.25:2379/v2/keys/fitness -XPOST -d value=&quot;dead_lift&quot;
curl http://10.211.55.25:2379/v2/keys/fitness -XPOST -d value=&quot;deep_squat&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;获取刚创建的fitness&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;curl http://10.211.55.25:2379/v2/keys/fitness
{&quot;action&quot;:&quot;create&quot;,&quot;node&quot;:{&quot;key&quot;:&quot;/fitness/00000000000000000020&quot;,&quot;value&quot;:&quot;bench_press&quot;,&quot;modifiedIndex&quot;:20,&quot;createdIndex&quot;:20}}
{&quot;action&quot;:&quot;create&quot;,&quot;node&quot;:{&quot;key&quot;:&quot;/fitness/00000000000000000021&quot;,&quot;value&quot;:&quot;dead_lift&quot;,&quot;modifiedIndex&quot;:21,&quot;createdIndex&quot;:21}}
{&quot;action&quot;:&quot;create&quot;,&quot;node&quot;:{&quot;key&quot;:&quot;/fitness/00000000000000000022&quot;,&quot;value&quot;:&quot;deep_squat&quot;,&quot;modifiedIndex&quot;:22,&quot;createdIndex&quot;:22}}
{&quot;action&quot;:&quot;get&quot;,&quot;node&quot;:{&quot;key&quot;:&quot;/fitness&quot;,&quot;dir&quot;:true,&quot;nodes&quot;:[{&quot;key&quot;:&quot;/fitness/00000000000000000022&quot;,&quot;value&quot;:&quot;deep_squat&quot;,&quot;modifiedIndex&quot;:22,&quot;createdIndex&quot;:22},{&quot;key&quot;:&quot;/fitness/00000000000000000020&quot;,&quot;value&quot;:&quot;bench_press&quot;,&quot;modifiedIndex&quot;:20,&quot;createdIndex&quot;:20},{&quot;key&quot;:&quot;/fitness/00000000000000000021&quot;,&quot;value&quot;:&quot;dead_lift&quot;,&quot;modifiedIndex&quot;:21,&quot;createdIndex&quot;:21}],&quot;modifiedIndex&quot;:20,&quot;createdIndex&quot;:20}}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;curl http://10.211.55.25:2379/v2/keys/cqh -XDELETE&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;列出所有集群成员&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;curl http://10.211.55.25:2379/v2/members&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;统计信息-查看leader&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;curl http://10.211.55.25:2379/v2/stats/leader&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;节点自身信息&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;curl http://10.211.55.26:2379/v2/stats/self&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;查看集群运行状态&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;curl http://10.211.55.26:2379/v2/stats/store&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;这里分别演示搭建etcd-browser和etcdkeeper，两者功能大同小异，不同的是etcdkeeper支持v3的api&lt;/p&gt;
&lt;h2 id=&quot;搭建etcd-browser&quot;&gt;1.搭建etcd-browser&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;docker run --rm  -d --name etcd-browser \
-p 8000:8000 \
--env ETCD_HOST=10.211.55.25 \
--env ETCD_PORT=2379 \
buddho/etcd-browser&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行后访问http://10.211.55.25:8000/&lt;br/&gt;看到如下界面，可以看到上面添加的所有数据，这里我使用界面添加了漫威和DC的英雄&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/662544/201903/662544-20190310005837251-1081163058.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;搭建etcdkeeper&quot;&gt;2.搭建etcdkeeper&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;docker run -it -d --name etcdkeeper \
-p 8080:8080 \
deltaprojects/etcdkeeper&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;访问http://10.211.55.25:8080/etcdkeeper/，输入etcd的地址,看到如下界面&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/662544/201903/662544-20190310005821534-487981485.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到这里，etcd的单机版搭建、集群版、客户端使用、rest api web管理界面等功能都介绍了，你还在等什么，赶紧high起来&lt;/p&gt;
</description>
<pubDate>Sat, 09 Mar 2019 17:00:00 +0000</pubDate>
<dc:creator>雪山飞猪</dc:creator>
<og:description>什么是ETCD 随着CoreOS和Kubernetes等项目在开源社区日益火热，它们项目中都用到的etcd组件作为一个高可用、强一致性的服务发现存储仓库，渐渐为开发人员所关注。 在云计算时代，如何让服</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenqionghe/p/10503840.html</dc:identifier>
</item>
<item>
<title>TensorFlow中的通信机制——Rendezvous（二）gRPC传输 - DeepLearningStack</title>
<link>http://www.cnblogs.com/deep-learning-stacks/p/10355770.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/deep-learning-stacks/p/10355770.html</guid>
<description>&lt;p&gt;[作者：&lt;a href=&quot;https://www.cnblogs.com/deep-learning-stacks&quot; target=&quot;_blank&quot;&gt;DeepLearningStack&lt;/a&gt;，阿里巴巴算法工程师，开源TensorFlow Contributor]&lt;/p&gt;
&lt;p&gt;本篇是TensorFlow通信机制系列的第二篇文章，主要梳理使用gRPC网络传输部分模块的结构和源码。如果读者对TensorFlow中Rendezvous部分的基本结构和原理还不是非常了解，那么建议先从&lt;a href=&quot;https://www.cnblogs.com/deep-learning-stacks/p/10354258.html&quot; target=&quot;_blank&quot;&gt;这篇文章&lt;/a&gt;开始阅读。TensorFlow在最初被开源时还只是个单机的异构训练框架，在迭代到0.8版本开始正式支持多机分布式训练。与其他分布式训练框架不同，Google选用了开源项目gRPC作为TensorFlow的跨机通信协议作为支持。gRPC的编程和使用其实是相对复杂的，TensorFlow为了能让gRPC的调用更加平滑，在调用链封装和抽象上面做了较多工作，甚至有些工作例如创建和管理gRPC channel涉及到了GrpcSession模块。从个人角度来看，利用gRPC进行Tensor通信的过程已经足够丰富，所以我们只针对gRPC传输Tensor过程进行梳理，至于涉及到gRPC管理方面的内容会在另一篇介绍分布式Session创建和管理的文章中集中梳理。&lt;/p&gt;

&lt;p&gt;根据之前写博客的经验，直接介绍类图结构和源码部分可能会让人懵圈，还是先从逻辑上把通信过程梳理清楚更能做到深入浅出。其实对于不是非常了解分布式系统或大规模并发系统的读者而言，TensorFlow中通信过程是有些“别扭”的。那么有的读者可能会觉得诧异，跨进程通信过程不就是一方做Send，另一方做Recv吗？这是一个理所当然的过程，为什么会“别扭”呢？是的，整个过程依然是一方做Send，另一方做Recv。而它的“别扭”之处就在于——&lt;strong&gt;真正的通信过程由Recv方触发，而不是Send方&lt;/strong&gt;！这就是理解TensorFlow中使用gRPC传输Tensor过程的最关键点。&lt;/p&gt;
&lt;p&gt;前一篇文章分析过在本地传输的场景下Tensor通信的大体过程，从机制和逻辑上来说，跨进程传输过程和本地传输没有很大的差异：TensorFlow使用Rendezvous通信Tensor，借助一个类似Table的数据结构作为传输的中转，并且Send方和Recv方依靠ParsedKey这一唯一传输标识符，跨进程通信也是如此。如果读者对这部分内容不了解，可以参考这篇文章。&lt;/p&gt;
&lt;h2&gt;Send方——将Ready的Tensor挂入本地Table&lt;/h2&gt;
&lt;p&gt;和本地传输场景下的Send过程相同，本地Tensor处于Ready状态后就被放挂了本地Worker的Table中，至此Send过程就全部完成了。所以Send过程完全没有涉及到任何跨网络传输的内容，并且Send过程是非阻塞的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1437153/201903/1437153-20190303182118168-1774381728.png&quot; alt=&quot;&quot; width=&quot;585&quot; height=&quot;304&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;Recv方——向Send方主动发出请求，触发通信过程&lt;/h2&gt;
&lt;p&gt;Recv方是Tensor的接收方，它的处理过程是：将所需要的Tensor对应的ParsedKey拼出后，主动向Send方主动发出Request，Send方在接收到Request后立即在本地Table中查找方所需要的Tensor，找到后将Tensor封装成Response发送回Recv方。在这个过程中，Recv方可以认为是Client，Send方可以认为是Server，通过发送Request和Response来完成Tensor的传输。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1437153/201903/1437153-20190303210140362-376628584.png&quot; alt=&quot;&quot; width=&quot;771&quot; height=&quot;371&quot;/&gt;&lt;/p&gt;

&lt;p&gt;建议读者在阅读本节时适当翻开TensorFlow C++部分源码，但只需要理解结构关系即可（比如类之间的继承、组合、依赖关系），暂时不要阅读类的实现内容。因为RemoteRendezvous部分涉及到的类结构非常多，直接陷入细节的阅读会深陷其中不能自拔，甚至弄得一头雾水十分疲惫。在梳理结构时一边参照下文中的类图结构，一边从设计模式和架构的角度尝试去理解每个模块的司职是理解本篇细节的关键。先理解宏观结构看懂架子，再去深入理解实现细节尝试去优化是读任何代码的正确顺序。&lt;/p&gt;
&lt;p&gt;任何场景下，通信过程几乎都是可以通过简单的图将功能描述清楚的。但是不可否认的是，任何涉及到分布式通信的系统在架构上都会对通信层做相对复杂的封装。一方面是因为通信虽然功能简单，但其实现本身具有相对较高的复杂性（大家可以尝试阅读gRPC源码感受下底层软件的复杂度）。另一方面，应用层也需要与通信底层通过抽象尽量实现较好的解耦，这样也方便将应用层模块被其他团队扩展编写。下面我们一起来探究TensorFlow中涉及到跨进程通信的Rendezvous系列。&lt;/p&gt;
&lt;h2&gt;两层抽象继承关系——RemoteRendezvous与BaseRemoteRendezvous&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/deep-learning-stacks/p/10354258.html&quot; target=&quot;_blank&quot;&gt;前一篇&lt;/a&gt;在介绍本地传输时我们熟悉了Rendezvous模块中与本地传输相关的类，例如LocalRendezvousImpl，IntraProcessRendezvous和SimpleRendezvous。对应地，跨进程传输也有不同的Rendezvous，从根源上来说，它们也继承于Rendezvous接口，并且不同的传输协议也有各自的Rendezvous。在这里，我们再次将前文中展示的总体类结构图展示出来，这次我们将涉及到远程传输的类用特殊颜色标出，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1437153/201903/1437153-20190303212234118-2071672503.png&quot; alt=&quot;&quot; width=&quot;623&quot; height=&quot;892&quot;/&gt;&lt;/p&gt;
&lt;p&gt;综合来看，从Rendezvous的继承结构来看，涉及到跨进程传输的Rendezvous有层：&lt;/p&gt;
&lt;p&gt;1. RemoteRendezvous：只增加了一个Initialize方法，并标记为纯虚函数。这是因为跨进程Rendezvous需要借助Session做一些初始化工作，所以TensorFlow中所有涉及到跨进程通信的Rendezvous都需要重写Initialize函数，使用前也必须强制调用该函数。&lt;/p&gt;
&lt;p&gt;2. 各种具体协议Rendezvous的基类——BaseRemoteRendezvous：既然所有涉及跨进程通信的Rendezvous都需要提供各自协议下实现的Initialize函数，那么没有比在RemoteRendezvous和真正特化的Rendezvous之间再添加一层继承关系更合适的做法了。事实上TensorFlow在此处也是这么设计的，这个承上启下的类就是BaseRemoteRendezvous。它还提供了公共的Send和Recv方法，这可以让继承它的特化Rendezvous尽最大可能做到代码复用。&lt;/p&gt;
&lt;p&gt;BaseRecvTensorCall是通信的实体抽象，后面分析时会有更深的体会，在这里先有个印象即可。&lt;/p&gt;
&lt;h2&gt;开始特化——各种各样的RemoteRendezvous&lt;/h2&gt;
&lt;p&gt;TensorFlow目标是通用可扩展，所以被设计成允许底层支持多种通信协议的结构。事实上到目前为止，算上contrib目录的内容（contrib目录是广大TensorFlow贡献者添加的内容），TensorFlow已经支持包括gRPC，RDMA（Remote Direct Memroy Access），GDR（GPU Dirrect）和MPI四种通信协议，因此包含了四种对应的Rendezvous，他们分别是RpcRemoteRendezvous，RDMARemoteRendezvous，GdrRemoteRendezvous和MPIRemoteRendezvous。每种通信协议各有其特点，有时候其可用性也取决于硬件和软件条件（比如RDMA需要支持RDMA协议的网卡，通常跑在Infiniband和RoCE网络上，如果没有硬件支持，那么RDMA将无法使用，GDR也是这个道理）。从代码中可以看出，实现每种具体的RemoteRendezvous都有一定的复杂性，所以很难想象在没有封装抽象和代码复用的结构里如何实现这些内容。在本篇我们关注RpcRemoteRendezvous，它是gRPC协议实现的RemoteRendezvous。 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1437153/201903/1437153-20190303212002084-1492921970.png&quot; alt=&quot;&quot; width=&quot;858&quot; height=&quot;525&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;令人熟悉的管理器模式——RendezvousMgr&lt;/h2&gt;
&lt;p&gt;为了更好地管理RemoteRendezvous，TensorFlow设计了相应的管理器——RendezvousMgr相关类，并为每种具体的RemoteRendevzous做了特化。熟悉设计模式的读者都知道，管理器是一种经典的设计模式，它能使管理职责的变化独立于类本身。RendezvousMgr主要负责RemoteRendezvous的创建和销毁，它也定义了两个本地版本的Recv接口。有的读者可能会问，管理器为什么还允许做Recv？并且只能做本地的Recv？我个人判断添加这两个接口纯粹是为了方便某些地方的使用。至于RendezvousMgr的创建时机和RemoteRendezvous的初始化过程并不是本篇解析的范畴，因为这涉及到分布式场景下创建Server的较长链路，这部分内容会在以后的博客中详细解析。下面是RendezvousMgr相关的类图结构，我们可以看到其接口类中已经定义了Recv接口。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1437153/201903/1437153-20190309140900746-1610132755.png&quot; alt=&quot;&quot; width=&quot;856&quot; height=&quot;580&quot;/&gt;&lt;/p&gt;

&lt;p&gt;上一小节中对RemoteRendezvous相关类结构和类间的关系做了解析，旨在从架构层面帮助读者理解各个类的职能。虽然涉及到的内容比较多，但是整体的结构和逻辑还是非常清晰的。如果读者尝试通过阅读源码辅助理解上述内容之后仍然感觉有些眼花缭乱，没有关系，我们在这里暂时做一个简单地梳理，将重点内容梳理到以下几条。&lt;/p&gt;
&lt;p&gt;1.  本地Rendezvous和RemoteRendezvous共同继承了同一个接口；&lt;/p&gt;
&lt;p&gt;2. RemoteRendezvous需要支持不同的通信协议，因此派生了各种各样的实现类；&lt;/p&gt;
&lt;p&gt;3. RemoteRendezvous的使用较为复杂，为此引入了管理器模式——RendezvousMgr，它负责RemoteRendezvous的创建和销毁，并添加了两个额外的Recv接口方便某些场景直接调用；&lt;/p&gt;
&lt;p&gt;4. RemoteRendezvous做了两层继承结构只是为了添加一个Initialize方法。&lt;/p&gt;
&lt;p&gt;本篇我们梳理使用gRPC协议的部分，从上文中梳理的结构中不难看出，这部分涉及到的类并不多。&lt;/p&gt;
&lt;p&gt;1. Rendezvous相关类——RemoteRendezvous，BaseRemoteRendezvous，RpcRemoteRendezvous；&lt;/p&gt;
&lt;p&gt;2. 管理器——BaseRendezvousMgr，RpcRendezvousMgr&lt;/p&gt;
&lt;p&gt;3. 其他类——BaseRecvTensorCall，RpcRecvTensorCall和DefferedCall&lt;/p&gt;
&lt;p&gt;毕竟是涉及到了gRPC协议本身的使用，所以有必要在梳理源码之前从宏观上对gRPC的工作流程做一个简单地梳理。&lt;/p&gt;
&lt;h2&gt;gRPC编程中的代理模式——Stub与Service&lt;/h2&gt;
&lt;p&gt;在此我们假设同学们对gRPC的原理和使用有一些基本的了解，比如需要使用Protobuf预先定义Service接口，并且区分Stub和Service等。对此不了解的同学还是建议先认真阅读一下gRPC的使用文档和范例，下面这段文字只对gRPC做一个非常简单的描述。&lt;/p&gt;
&lt;p&gt;在一次RPC调用中，客户端需要调用服务端的服务，然后将处理结果返回给客户端。而gRPC做到了“让客户端调用远端函数时就像调用本地函数一样”的体验，这得益于一种经典的设计模式——代理模式。负责为客户端代理的节点（gRPC中称之为Stub）会将请求和参数传到服务端，并由Service进行实际的处理，然后将结果返回给Stub，最终返回到客户端中。我们甚至可以认为负责代理的Stub就是客户端，因为它的职责就是与远端交互并取得结果。另外，为了能够让传输量尽可能少，也为了能够让传输不受客户端和服务端具体的类型限制，gRPC在做跨网络传输前将消息统一序列化成Protobuf格式。下图是从gRPC官网教程中摘出的工作原理图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1437153/201903/1437153-20190309194009346-76349197.png&quot; alt=&quot;&quot; width=&quot;492&quot; height=&quot;317&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;Send过程&lt;/h2&gt;
&lt;p&gt;因为Send过程并不涉及跨进程传输，只是将Ready的Tensor挂入本地Table之中，所以它和LocalRendezvousImpl的Send完全相同。不仅如此，TensorFlow中的任何RemoteRendezvous的Send过程都要遵循这样的原理，基于代码复用的考虑，将这部分内容都被抽象到了公共基类BaseRemoteRendezvous的Send函数里是一个很好的设计。事实上，BaseRemoteRendezvous的Send过程就是调用了LocalRendezvousImpl的Send过程，所以LocalRendezvousImpl必须要作为BaseRemoteRendezvous的成员之一。下面的代码展示了这一过程。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; Status BaseRemoteRendezvous::Send(&lt;span&gt;const&lt;/span&gt; Rendezvous::ParsedKey&amp;amp;&lt;span&gt; parsed,
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;                                   &lt;span&gt;const&lt;/span&gt; Rendezvous::Args&amp;amp;&lt;span&gt; args,
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;                                   &lt;span&gt;const&lt;/span&gt; Tensor&amp;amp; val, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; is_dead) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;   VLOG(&lt;span&gt;1&lt;/span&gt;) &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BaseRemoteRendezvous Send &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;this&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; parsed.FullKey();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;  {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    mutex_lock l(mu_);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!status_.ok()) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; status_;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    DCHECK(is_initialized_locked());
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!IsLocalDevice(session_-&amp;gt;&lt;span&gt;worker_name, parsed.src_device)) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;       &lt;span&gt;return&lt;/span&gt;&lt;span&gt; errors::InvalidArgument(
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;           &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Invalid rendezvous key (src): &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, parsed.FullKey(), &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; @ &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;           session_-&amp;gt;&lt;span&gt;worker_name);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Buffers &quot;val&quot; and &quot;device_context&quot; in local_.&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;   &lt;span&gt;return&lt;/span&gt; local_-&amp;gt;&lt;span&gt;Send(parsed, args, val, is_dead);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Recv过程&lt;/h2&gt;
&lt;p&gt;Recv过程就非常复杂了，因为每种RemoteRendezvous都涉及到不同的通信协议以及管理方式，所以Recv函数是真正需要继承重写的模块。在看RpcRemoteRendezvous具体的实现之前，我们必须先将gRPC定义服务的接口部分梳理清楚。&lt;/p&gt;
&lt;h3&gt;gRPC的服务定义接口文件&lt;/h3&gt;
&lt;p&gt;在TensorFlow的core/protobuf文件中，我们需要研究一下worker_service.proto文件，这个文件中定义了若干RPC Service接口。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1437153/201903/1437153-20190309213144099-2040259095.jpg&quot; alt=&quot;&quot; width=&quot;393&quot; height=&quot;524&quot;/&gt;&lt;/p&gt;
&lt;p&gt;虽然它定义了很多RPC服务接口，但是我们只需要关注和Tensor接收相关的接口定义即可。准确地说，目前我们必须要知道的是下面这个Service定义。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
  // See worker.proto for details.
  rpc RecvTensor(RecvTensorRequest) returns (RecvTensorResponse) {
    // RecvTensor Method
  }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;显然，这是一个让服务端处理“接收Tensor”的服务（&lt;strong&gt;注意是让服务端处理名为“接收Tensor”的服务，而不是让服务端去接收Tensor。因为客户端有接收Tensor的需求，但需要服务端发送Tensor，为客户端发送Tensor的服务被称之为“接收Tensor”&lt;/strong&gt;），按照注释提示，我们可以在worker.proto中找到RecvTensorRequest和RecvTensorResponse的数据结构，这部分结构读者可以自己查阅，非常容易理解。在编译时，扩展的Protobuf编译器会对worker_service.proto中的rpc接口生成C++服务接口代码和Stub代码（毕竟Stub代码比较纯粹并且和业务逻辑无关，它只是一个向对应Service端发送处理请求的过程），TensorFlow只需要对具体的Service提供实现即可。&lt;/p&gt;
&lt;h3&gt;与gRPC生成的代码联系起来&lt;/h3&gt;
&lt;p&gt;gRPC会为worker_service.proto中每一个rpc服务生成C++接口代码，为了区分多个rpc服务，特意为每个服务生成了特殊的名字。比如RecvTensor服务的名字就是/tensorflow.WorkerService/RecvTensor。为了不直接使用冗长的字符串，TensorFlow为worker_service.proto中的每个服务都做了enumeration的映射，这部分代码在tensorflow/core/distributed_runtime/grpc_worker_service_impl.h和同名实现文件中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Names of worker methods.&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; GrpcWorkerMethod {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;  kGetStatus,
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;  kCreateWorkerSession,
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;  kDeleteWorkerSession,
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;  kRegisterGraph,
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;  kDeregisterGraph,
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;  kRunGraph,
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;  kCleanupGraph,
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;  kCleanupAll,
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;  kRecvTensor,
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;  kRecvBuf,
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;  kLogging,
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;  kTracing,
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;  kCompleteGroup,
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;  kCompleteInstance,
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;  kGetStepSequence,
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; };
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面是从enumeration类型映射到具体字符串的函数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; GrpcWorkerMethodName(GrpcWorkerMethod id) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;   &lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (id) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;case&lt;/span&gt;&lt;span&gt; GrpcWorkerMethod::kGetStatus:
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;       &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/tensorflow.WorkerService/GetStatus&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;case&lt;/span&gt;&lt;span&gt; GrpcWorkerMethod::kCreateWorkerSession:
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;       &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/tensorflow.WorkerService/CreateWorkerSession&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;case&lt;/span&gt;&lt;span&gt; GrpcWorkerMethod::kDeleteWorkerSession:
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;       &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/tensorflow.WorkerService/DeleteWorkerSession&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;case&lt;/span&gt;&lt;span&gt; GrpcWorkerMethod::kRegisterGraph:
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;       &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/tensorflow.WorkerService/RegisterGraph&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;case&lt;/span&gt;&lt;span&gt; GrpcWorkerMethod::kDeregisterGraph:
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;       &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/tensorflow.WorkerService/DeregisterGraph&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;case&lt;/span&gt;&lt;span&gt; GrpcWorkerMethod::kRunGraph:
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;       &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/tensorflow.WorkerService/RunGraph&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;case&lt;/span&gt;&lt;span&gt; GrpcWorkerMethod::kCleanupGraph:
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;       &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/tensorflow.WorkerService/CleanupGraph&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;case&lt;/span&gt;&lt;span&gt; GrpcWorkerMethod::kCleanupAll:
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;       &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/tensorflow.WorkerService/CleanupAll&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;case&lt;/span&gt;&lt;span&gt; GrpcWorkerMethod::kRecvTensor:
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;       &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/tensorflow.WorkerService/RecvTensor&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;case&lt;/span&gt;&lt;span&gt; GrpcWorkerMethod::kRecvBuf:
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;       &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/tensorflow.WorkerService/RecvBuf&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;case&lt;/span&gt;&lt;span&gt; GrpcWorkerMethod::kLogging:
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;       &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/tensorflow.WorkerService/Logging&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;case&lt;/span&gt;&lt;span&gt; GrpcWorkerMethod::kTracing:
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;       &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/tensorflow.WorkerService/Tracing&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;case&lt;/span&gt;&lt;span&gt; GrpcWorkerMethod::kCompleteGroup:
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;       &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/tensorflow.WorkerService/CompleteGroup&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;case&lt;/span&gt;&lt;span&gt; GrpcWorkerMethod::kCompleteInstance:
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;       &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/tensorflow.WorkerService/CompleteInstance&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;case&lt;/span&gt;&lt;span&gt; GrpcWorkerMethod::kGetStepSequence:
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;       &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/tensorflow.WorkerService/GetStepSequence&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Shouldn't be reached.&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;   LOG(FATAL) &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Invalid id: this line shouldn't be reached.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;invalid id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另外，还需要为每个RPC服务注册为异步服务，这需要使用gRPC自带的AddMethod接口和MarkMethodAsync接口，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;WorkerService::AsyncService::AsyncService() {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;   &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; kGrpcNumWorkerMethods; ++&lt;span&gt;i) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     AddMethod(&lt;span&gt;new&lt;/span&gt; ::grpc::&lt;span&gt;internal&lt;/span&gt;&lt;span&gt;::RpcServiceMethod(
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         GrpcWorkerMethodName(static_cast&amp;lt;GrpcWorkerMethod&amp;gt;&lt;span&gt;(i)),
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         ::grpc::&lt;span&gt;internal&lt;/span&gt;&lt;span&gt;::RpcMethod::NORMAL_RPC, nullptr));
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;    ::grpc::Service::MarkMethodAsync(i);
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;好了，接下来就是解析源码中具体的交互过程了。其实TensorFlow在框架层面对gRPC的使用了一些Best Practice，比如异步处理请求的架构和多线程轮询Completion Queue等。将这些连在一起梳理需要更多的篇幅，一次性展示大量的内容也不利于阅读，所以我们只对发送和接收过程做一个梳理。&lt;/p&gt;
&lt;h3&gt;Client端的调用链&lt;/h3&gt;
&lt;p&gt;从BaseRemoteRendeezvous的RecvAsync出发，逐渐深入调用链底层。时序图是分析调用链的最好工具，下面给出了Client端到Stub的调用过程，这里面涉及到了几个新的类。&lt;/p&gt;
&lt;p&gt;1. RpcRecvTensorCall：这是一次gRPC调用的抽象，继承了BaseRecvTensorCall这个抽象基类，它封装了复杂的后续调用链。&lt;/p&gt;
&lt;p&gt;2. GrpcRemoteWorker：它也是client端的内容，只不过它是Remote端的代理。&lt;/p&gt;
&lt;p&gt;3. RpcState：这是真正封装了一次RPC调用及状态的类，它会直接对Stub以及GenericClientAsyncResponseReader进行管理，比如向服务端发送异步请求并等待结果等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1437153/201903/1437153-20190309234030028-935794397.png&quot; alt=&quot;&quot; width=&quot;1019&quot; height=&quot;487&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Client端是一个虚拟角色，它可以是调用RpcRemoteRendezvous的任何一个模块。我们可以看到，RpcRemoteRendezvous的一次RecvRemoteAsync过程非常长，并且Stub的调用时异步的。这里的代码确实有些多，所以我们只展示一下关键代码段，但是建议读者打开源码仔细阅读每个调用链。&lt;/p&gt;
&lt;p&gt;下面是RecvRemoteAsync的代码段，主要做了RpcRecvTensorCall的初始化，注册以及启动工作。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;69&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; RpcRemoteRendezvous::RecvFromRemoteAsync(
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;const&lt;/span&gt; Rendezvous::ParsedKey&amp;amp; parsed, &lt;span&gt;const&lt;/span&gt; Rendezvous::Args&amp;amp;&lt;span&gt; recv_args,
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    DoneCallback done) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;  CHECK(is_initialized());
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;  Status s;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Prepare a RecvTensor call that can handle being aborted.&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;   RpcRecvTensorCall* call = get_call_freelist()-&amp;gt;&lt;span&gt;New();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; key.src_device identifies a remote device.&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; (!DeviceNameUtils::SplitDeviceName(parsed.src_device, &amp;amp;call-&amp;gt;&lt;span&gt;src_worker_,
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                                         &amp;amp;call-&amp;gt;&lt;span&gt;src_rel_device_)) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     s =&lt;span&gt; errors::Internal(parsed.src_device,
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                          &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; is invalid remote source device.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;   WorkerSession* sess =&lt;span&gt; session();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;   WorkerInterface* rwi = sess-&amp;gt;worker_cache-&amp;gt;CreateWorker(call-&amp;gt;&lt;span&gt;src_worker_);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; (s.ok() &amp;amp;&amp;amp; rwi ==&lt;span&gt; nullptr) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     s = errors::Internal(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;No worker known as &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, call-&amp;gt;&lt;span&gt;src_worker_);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;   Device*&lt;span&gt; dst_device;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (s.ok()) {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     s = sess-&amp;gt;device_mgr()-&amp;gt;LookupDevice(parsed.dst_device, &amp;amp;&lt;span&gt;dst_device);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;s.ok()) {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (rwi !=&lt;span&gt; nullptr) {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;       sess-&amp;gt;worker_cache-&amp;gt;ReleaseWorker(call-&amp;gt;&lt;span&gt;src_worker_, rwi);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     get_call_freelist()-&amp;gt;Release(call, sess-&amp;gt;worker_cache.&lt;span&gt;get&lt;/span&gt;&lt;span&gt;());
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     done(s, Args(), recv_args, Tensor{}, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt;   call-&amp;gt;&lt;span&gt;Init(rwi, step_id_, parsed.FullKey(), recv_args.alloc_attrs, dst_device,
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;             recv_args, std::move(done));
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Record &quot;call&quot; in active_ so that it can be aborted cleanly.&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt; &lt;span&gt;  RegisterCall(call);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; 
&lt;span&gt;41&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; RendezvousMgr already aborted, shouldn't send RPC call any more&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; (!call-&amp;gt;&lt;span&gt;status().ok()) {
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;     call-&amp;gt;done()(call-&amp;gt;status(), Args(), Args(), Tensor(), &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;     session()-&amp;gt;worker_cache-&amp;gt;ReleaseWorker(call-&amp;gt;src_worker_, call-&amp;gt;&lt;span&gt;wi_);
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;     call-&amp;gt;wi_ =&lt;span&gt; nullptr;
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;     get_call_freelist()-&amp;gt;Release(call, session()-&amp;gt;worker_cache.&lt;span&gt;get&lt;/span&gt;&lt;span&gt;());
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; 
&lt;span&gt;50&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Start &quot;call&quot;.&lt;/span&gt;
&lt;span&gt;51&lt;/span&gt; &lt;span&gt;  Ref();
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;   call-&amp;gt;Start([&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, call]() {
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Removes &quot;call&quot; from active_. Prevent StartAbort().&lt;/span&gt;
&lt;span&gt;54&lt;/span&gt; &lt;span&gt;    DeregisterCall(call);
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; If StartAbort was called prior to DeregisterCall, then the
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; current status should be bad.&lt;/span&gt;
&lt;span&gt;57&lt;/span&gt;     Status s = call-&amp;gt;&lt;span&gt;status();
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;     call-&amp;gt;done()(s, Args(), call-&amp;gt;recv_args(), call-&amp;gt;tensor(), call-&amp;gt;&lt;span&gt;is_dead());
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;     session()-&amp;gt;worker_cache-&amp;gt;ReleaseWorker(call-&amp;gt;src_worker_, call-&amp;gt;&lt;span&gt;wi_);
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;     call-&amp;gt;wi_ =&lt;span&gt; nullptr;
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;     get_call_freelist()-&amp;gt;Release(call, session()-&amp;gt;worker_cache.&lt;span&gt;get&lt;/span&gt;&lt;span&gt;());
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; &lt;span&gt;    Unref();
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; &lt;span&gt;  });
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面是GrpcRemoteWorker调用RPCState的过程，最后的IssueRequest即开始创建RPCState并触发stub的调用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; RecvTensorAsync(CallOptions* call_opts, &lt;span&gt;const&lt;/span&gt; RecvTensorRequest*&lt;span&gt; request,
                       TensorResponse&lt;/span&gt;* response, StatusCallback done) &lt;span&gt;override&lt;/span&gt;&lt;span&gt; {
    VLOG(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;) &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RecvTensorAsync req: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; request-&amp;gt;&lt;span&gt;DebugString();
    int64 start_usec &lt;/span&gt;= Env::Default()-&amp;gt;&lt;span&gt;NowMicros();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Type-specialized logging for this method.&lt;/span&gt;
    &lt;span&gt;bool&lt;/span&gt; logging_active = logger_-&amp;gt;LoggingActive() || VLOG_IS_ON(&lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
    StatusCallback wrapper_done;
    &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; StatusCallback*&lt;span&gt; cb_to_use;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;logging_active) {
      cb_to_use &lt;/span&gt;= &amp;amp;done;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; No additional work to do, so just use done directly&lt;/span&gt;
    } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      wrapper_done &lt;/span&gt;= [&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, request, response, done, start_usec](Status s) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (logger_-&amp;gt;&lt;span&gt;LoggingActive()) {
          int64 end_usec &lt;/span&gt;= Env::Default()-&amp;gt;&lt;span&gt;NowMicros();
          int64 step_id &lt;/span&gt;= request-&amp;gt;&lt;span&gt;step_id();
          int64 bytes &lt;/span&gt;= response-&amp;gt;&lt;span&gt;tensor().TotalBytes();
          int64 send_start_usec &lt;/span&gt;=&lt;span&gt; start_usec;
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; If a send start time was reported by the other side, use
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; that instead.  Maybe we should mark the display if we're using
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; our local time instead of the remote start time?&lt;/span&gt;
          &lt;span&gt;if&lt;/span&gt; (response-&amp;gt;&lt;span&gt;metadata().send_start_micros()) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; send_start_micros is the timestamp taken when the
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; remote machine began to send the RecvTensor response.
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Due to clock skew between source and dest machines, it
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; is possible that send_start_micros can be larger than
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; end_usec or less than start_usec.
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; To respect causality, we enforce the invariants that
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; the RecvTensor response can not have been sent before
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; the RecvTensor request, and must have been sent before
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; it was received.&lt;/span&gt;
            send_start_usec =&lt;span&gt; std::max(
                start_usec,
                static_cast&lt;/span&gt;&amp;lt;int64&amp;gt;(response-&amp;gt;&lt;span&gt;metadata().send_start_micros()));
            send_start_usec &lt;/span&gt;= std::min(send_start_usec, end_usec - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
          }
          &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&amp;amp; key = request-&amp;gt;&lt;span&gt;rendezvous_key();
          std::vector&lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; key_parts = str_util::Split(key, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (key_parts.size() != &lt;span&gt;5&lt;/span&gt;&lt;span&gt;) {
            LOG(WARNING) &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Bad key: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; key;
          } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            logger_&lt;/span&gt;-&amp;gt;&lt;span&gt;RecordRecvTensor(step_id, send_start_usec, end_usec,
                                      key_parts[&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;],  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; tensor name&lt;/span&gt;
                                      key_parts[&lt;span&gt;0&lt;/span&gt;],  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; src_device&lt;/span&gt;
                                      key_parts[&lt;span&gt;2&lt;/span&gt;],  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; dst_device&lt;/span&gt;
&lt;span&gt;                                      bytes);
          }
        }
        VLOG(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;) &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;done callback, req: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; request-&amp;gt;&lt;span&gt;DebugString()
                &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; response &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; response-&amp;gt;&lt;span&gt;metadata().DebugString();
        done(s);
      };
      cb_to_use &lt;/span&gt;= &amp;amp;&lt;span&gt;wrapper_done;
    }

    IssueRequest(request, response, recvtensor_, &lt;/span&gt;*&lt;span&gt;cb_to_use, call_opts);
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后展示一下Stub的触发位置，这个函数在RPCState类中，并且在创建RPCState对象时立即被调用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; StartCall() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     context_.reset(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ::grpc::ClientContext());
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     context_-&amp;gt;&lt;span&gt;set_fail_fast(fail_fast_);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (timeout_in_ms_ &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;       context_-&amp;gt;&lt;span&gt;set_deadline(
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;          gpr_time_from_millis(timeout_in_ms_, GPR_TIMESPAN));
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (call_opts_) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;       call_opts_-&amp;gt;SetCancelCallback([&lt;span&gt;this&lt;/span&gt;]() { context_-&amp;gt;&lt;span&gt;TryCancel(); });
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     VLOG(&lt;span&gt;2&lt;/span&gt;) &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Starting call: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; method_;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     call_ =&lt;span&gt; std::move(
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         stub_-&amp;gt;PrepareUnaryCall(context_.&lt;span&gt;get&lt;/span&gt;&lt;span&gt;(), method_, request_buf_, cq_));
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     call_-&amp;gt;&lt;span&gt;StartCall();
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     call_-&amp;gt;Finish(&amp;amp;response_buf_, &amp;amp;status_, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;   }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Server端负责查找Tensor的Service&lt;/h3&gt;
&lt;p&gt;如果我们把异步处理请求的架构和多线程轮询Completion Queue的Best Practice去除，那么Service端其实并不复杂，调用链相对Client端短了很多，下面的时序图展示了自Server端接收请求后的调用过程，这里面也涉及到了几个新的类。&lt;/p&gt;
&lt;p&gt;1. GrpcWorkerServiceThread：这是服务端处理请求的线程类。&lt;/p&gt;
&lt;p&gt;2. GrpcWorker：这是真正负责处理请求的Worker，是GrpcRemoteWorker的服务端版本；&lt;/p&gt;
&lt;p&gt;3. WorkerCall：这是服务端处理一次gRPC请求和响应的类，抽象为WorkerCall，其实这也是个别名，真实的名称较长；&lt;/p&gt;
&lt;p&gt;4. ServerAsyncResponseWriter：这是gRPC为用户端提供的Response writer，是承载响应的实体。&lt;/p&gt;
&lt;p&gt;5. Utils：这其实不是一个类，而是多个工具的组合，为了在时序图表达方便，统称为Utils。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1437153/201903/1437153-20190310000922359-421517234.png&quot; alt=&quot;&quot; width=&quot;953&quot; height=&quot;496&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看出，服务端接收到请求后，会调用RecvLocalAsync在本地将客户端所需要的Tensor查找出来，然后拷贝到CPU上，最后利用gRPC发送回客户端。同样，我们展示关键代码段。&lt;/p&gt;
&lt;p&gt;下面是GrpcWorker调用RendezvousMgr的RecvLocalAsync为客户端寻找真正Tensor的过程。回调函数中能够看出，在找到对应Tensor后，需要将Tensor做Encode，然后拷贝到CPU端。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;  env_-&amp;gt;rendezvous_mgr-&amp;gt;&lt;span&gt;RecvLocalAsync(
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;      step_id, parsed,
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;      [opts, response, done, src_dev, request](
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;           &lt;span&gt;const&lt;/span&gt; Status&amp;amp; status, &lt;span&gt;const&lt;/span&gt; Rendezvous::Args&amp;amp;&lt;span&gt; send_args,
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;           &lt;span&gt;const&lt;/span&gt; Rendezvous::Args&amp;amp; recv_args, &lt;span&gt;const&lt;/span&gt; Tensor&amp;amp;&lt;span&gt; val,
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;           &lt;span&gt;const&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; is_dead) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         opts-&amp;gt;&lt;span&gt;ClearCancelCallback();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (status.ok()) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;           &lt;span&gt;//&lt;/span&gt;&lt;span&gt; DMA can only be used for Tensors that do not fall into
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;           &lt;span&gt;//&lt;/span&gt;&lt;span&gt; the following three odd edge cases: 1) a zero-size
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;           &lt;span&gt;//&lt;/span&gt;&lt;span&gt; buffer, 2) a dead tensor which has an uninit value, and
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;           &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3) the tensor has the on_host allocation attribute,
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;           &lt;span&gt;//&lt;/span&gt;&lt;span&gt; i.e. it's in CPU RAM *independent of its assigned
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;           &lt;span&gt;//&lt;/span&gt;&lt;span&gt; device type*.&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;           &lt;span&gt;const&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; on_host =&lt;span&gt; send_args.alloc_attrs.on_host();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;          {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Non-DMA cases.&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (src_dev-&amp;gt;tensorflow_gpu_device_info() &amp;amp;&amp;amp; (!&lt;span&gt;on_host)) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;               DeviceContext* send_dev_context =&lt;span&gt; send_args.device_context;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;              AllocatorAttributes alloc_attrs;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;               alloc_attrs.set_gpu_compatible(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;               alloc_attrs.set_on_host(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;               Allocator* alloc = src_dev-&amp;gt;&lt;span&gt;GetAllocator(alloc_attrs);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;               Tensor* copy = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Tensor(alloc, val.dtype(), val.shape());
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;              CHECK(send_dev_context)
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                   &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;send dev name: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; src_dev-&amp;gt;&lt;span&gt;name()
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                   &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; gpu_info: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; src_dev-&amp;gt;&lt;span&gt;tensorflow_gpu_device_info();
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;               &lt;span&gt;//&lt;/span&gt;&lt;span&gt; &quot;val&quot; is on an accelerator device. Uses the device_context to
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;               &lt;span&gt;//&lt;/span&gt;&lt;span&gt; fill the copy on host.&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;               StatusCallback copy_ready =&lt;span&gt; [response, done, copy,
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                                            is_dead](&lt;span&gt;const&lt;/span&gt; Status&amp;amp;&lt;span&gt; s) {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; The value is now ready to be returned on the wire.&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;                 grpc::EncodeTensorToByteBuffer(is_dead, *&lt;span&gt;copy, response);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;                done(s);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                 &lt;span&gt;delete&lt;/span&gt;&lt;span&gt; copy;
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;              };
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt;               send_dev_context-&amp;gt;&lt;span&gt;CopyDeviceTensorToCPU(
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;                   &amp;amp;val, request-&amp;gt;&lt;span&gt;rendezvous_key(), src_dev, copy, copy_ready);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;             } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;              grpc::EncodeTensorToByteBuffer(is_dead, val, response);
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;              done(Status::OK());
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;          }
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;  !s.ok()&lt;/span&gt;
&lt;span&gt;47&lt;/span&gt; &lt;span&gt;          done(status);
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;       });
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;至此，我们的Rendezvous之gRPC传输之旅就圆满结束了，在阅读本篇时还是希望读者能够在理解结构设计后，对照C++源码仔细阅读反复推敲里面的每一个细节，这样才能有更深的理解。&lt;/p&gt;

&lt;p&gt;是的，确实很低效。为什么？从设计哲学上说，gRPC本身设计并不适合深度学习训练场景。从细节上来说它有以下几个缺陷：&lt;/p&gt;
&lt;p&gt;1. gRPC发送Tensor前，接收Tensor后必须要做序列化，在Tensor很大的时候这是一个非常讨厌的overhead，发送接收延迟过大；&lt;/p&gt;
&lt;p&gt;2. 序列化根本没有对数据做任何压缩，这是因为Tensor都是稠密的，所以序列化没有意义；&lt;/p&gt;
&lt;p&gt;3. 不能支持RDMA和GPU Direct。虽然这依赖于硬件，但是gRPC在软件层面也并没有做这些适配。&lt;/p&gt;
&lt;p&gt;所以大部分人使用TensorFlow分布式时都会对性能有很大的抱怨，这里面很大的原因和gRPC有关。如果你使用NCCL或者MPI，那么你会得到不一样的性能。&lt;/p&gt;

&lt;p&gt;本篇文章篇幅较长，是Rendezvous机制系列的第二篇，主要梳理了涉及到gRPC传输的模块架构设计和源码细节，并且详细梳理了通信过程。理解TensorFlow跨机传输的关键在于理解一个事实：&lt;strong&gt;真正的通信过程由Recv方触发，而不是Send方&lt;/strong&gt;！Send依然将Ready的Tensor挂入本地Table中，而Recv会向Send端发送gRPC请求查询所需要的Tensor，然后返回所需要的结果，这个过程虽然有些别扭，但逻辑上并不稀奇。从结构设计上来说，RemoteRendezvous沿用了Rendezvous接口，并且完全复用了LocalRendezvousImpl的Send代码，而Recv由于涉及到具体的通信细节和管理机制，则各有各的不同。另外，RemoteRendezvous相对LocalRendezvous复杂很多，需要管理器进行管理。最后一大部分是Send和Recv的源码细节展示，因为无论是客户端还是服务端，其调用链都比较长，所以以时序图的形式展示各个类之间的调用关系和协作关系较为清晰，具体每个调用的细节建议读者结合源码逐一分析，并连同本篇文章一起理解较为深刻。最后，我们总结了gRPC传输Tensor的明显缺陷，当然这也是为性能优化开辟了新的空间。&lt;/p&gt;
</description>
<pubDate>Sat, 09 Mar 2019 16:53:00 +0000</pubDate>
<dc:creator>DeepLearningStack</dc:creator>
<og:description>背景 [作者：DeepLearningStack，阿里巴巴算法工程师，开源TensorFlow Contributor] 本篇是TensorFlow通信机制系列的第二篇文章，主要梳理使用gRPC网络传</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/deep-learning-stacks/p/10355770.html</dc:identifier>
</item>
<item>
<title>Java数据库操作（MySQL与SQLserver） - 东小东</title>
<link>http://www.cnblogs.com/dongxiaodong/p/10468635.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dongxiaodong/p/10468635.html</guid>
<description>&lt;p&gt;在java编程开发中，数据库的开发是重头戏。&lt;/p&gt;
&lt;p&gt;MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，目前属于 Oracle 旗下产品；&lt;/p&gt;
&lt;p&gt;SQL Server是由Microsoft开发和推广的关系数据库管理系统（DBMS）。&lt;/p&gt;
&lt;h2&gt;Jar包下载&lt;/h2&gt;
&lt;p&gt;java数据库的连接需要依赖外部jar包，所以需要下载后进行：构建路径-&amp;gt;配置构建路径-&amp;gt;库-&amp;gt;添加JAR-&amp;gt;应用-&amp;gt;确定&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SQLserver：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;https://blog-static.cnblogs.com/files/dongxiaodong/sqlserverdb.zip&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MySQL：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;https://blog-static.cnblogs.com/files/dongxiaodong/mysqldb.zip&lt;/p&gt;
&lt;h2&gt;连接储备&lt;/h2&gt;
&lt;p&gt;连接数据库最重要的地方就是确定其数据库驱动和URL&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SQLserver：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;String&lt;/span&gt; forn=&quot;com.microsoft.sqlserver.jdbc.SQLServerDriver&quot;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据库驱动&lt;/span&gt;
&lt;span&gt;String&lt;/span&gt; url = &quot;jdbc:sqlserver://172_16_0_6:1433;databaseName=mydbname &quot;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;连接的url&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;MySQL：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;String&lt;/span&gt; forn=&quot;com.mysql.jdbc.Driver&quot;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据库驱动&lt;/span&gt;
&lt;span&gt;String&lt;/span&gt; url = &quot;jdbc:mysql://localhost:3306/mydbname &quot;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;连接的url&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;数据库连接&lt;/h2&gt;
&lt;p&gt;导入模块&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
import java.sql.*
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;创建类属性&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; Connection ct=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Statement st=&lt;span&gt;null&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;数据库连接函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Db(){
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         String forn=&quot;com.mysql.jdbc.Driver&quot;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据库驱动&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;         String url = &quot;jdbc:mysql://localhost:3306/db_library&quot;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;连接的url&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         String user=&quot;root&quot;;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;用户名&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         String password=&quot;root&quot;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;密码&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             Class.forName(forn);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注册、加载特定的驱动程序&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ClassNotFoundException e) { 
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             JOptionPane.showMessageDialog(&lt;span&gt;null&lt;/span&gt;,&quot;加载数据库失败01&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             System.exit(0);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭整个应用&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             ct=DriverManager.getConnection(url,user,password);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建连接，创建连接Connection对象&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (SQLException e1) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             JOptionPane.showMessageDialog(&lt;span&gt;null&lt;/span&gt;,&quot;加载数据库失败02&quot;+&lt;span&gt;e1.toString());
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             System.exit(0);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭整个应用&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            e1.printStackTrace();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             st=ct.createStatement();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建会话对象，用Connection对象生成Statement对象&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (SQLException e3) {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             JOptionPane.showMessageDialog(&lt;span&gt;null&lt;/span&gt;,&quot;加载数据库失败03&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             System.exit(0);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭整个应用&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;            e3.printStackTrace();
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         JOptionPane.showMessageDialog(&lt;span&gt;null&lt;/span&gt;,&quot;连接数据库成功了&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;数据库基本操作&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;查询操作：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;获取结果第一条&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行SQL语句&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;         ResultSet rex = st.executeQuery(&quot;select *from tb_books where b_id=1&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断是否查询到值&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(rex.next()){ 
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             String ss=rex.getString(&quot;字段名&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             JOptionPane.showMessageDialog(&lt;span&gt;null&lt;/span&gt;,&quot;字段数据为:&quot;+&lt;span&gt;ss);    
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (SQLException e1) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        e1.printStackTrace();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;获取全部结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行SQL语句&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;         ResultSet rex = st.executeQuery(&quot;select *from tb_books where b_id=1&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断是否查询到值&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt;&lt;span&gt;(rex.next()){
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             String ss=rex.getString(&quot;字段名&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             JOptionPane.showMessageDialog(&lt;span&gt;null&lt;/span&gt;,&quot;字段数据为:&quot;+&lt;span&gt;ss);    
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (SQLException e1) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        e1.printStackTrace();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;更新操作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;executeUpdate可以执行插入、更新、删除的SQL语句，并返回影响行数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置更新的SQL语句&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;         String sql2=&quot;update tb_test set text1='123',text2='1234' where id='1'&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; ii = st.executeUpdate(sql2);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回影响行数&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;         JOptionPane.showConfirmDialog(&lt;span&gt;null&lt;/span&gt;,&quot;影响行数为：&quot;+&lt;span&gt;ii);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (SQLException e1) {
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;       e1.printStackTrace();
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; }    
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Sat, 09 Mar 2019 16:41:00 +0000</pubDate>
<dc:creator>东小东</dc:creator>
<og:description>在java编程开发中，数据库的开发是重头戏。 MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，目前属于 Oracle 旗下产品； SQL Server是由Microsoft开发</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dongxiaodong/p/10468635.html</dc:identifier>
</item>
<item>
<title>【线性代数】四个基本子空间 - shayue111</title>
<link>http://www.cnblogs.com/shayue/p/10503873.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shayue/p/10503873.html</guid>
<description>&lt;p&gt;矩阵A一共对应着4个基本子空间，分别是列空间、行空间、零空间以及左零空间&lt;/p&gt;
&lt;h3 id=&quot;行空间&quot;&gt;行空间&lt;/h3&gt;
&lt;p&gt;设一m行n列实元素矩阵为&lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt;(mxn),则其行空间(Row Space)是由矩阵A的所有行向量所生成的&lt;span class=&quot;math inline&quot;&gt;\(R^n\)&lt;/span&gt;上的子空间，记作&lt;span class=&quot;math inline&quot;&gt;\(C(A^{\mathrm{T}})\)&lt;/span&gt;或&lt;span class=&quot;math inline&quot;&gt;\(R(A)\)&lt;/span&gt;。其中，矩阵&lt;span class=&quot;math inline&quot;&gt;\(A^{\mathrm{T}}\)&lt;/span&gt;是矩阵A的转置。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;矩阵A的行空间中的所有向量均为矩阵A的行向量的某种线性组合，都为&lt;span class=&quot;math inline&quot;&gt;\(R^n\)&lt;/span&gt;上的向量（即n维向量）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;矩阵A对应的行空间维度等于矩阵A的行秩，最大为min(m,n)。即：&lt;/p&gt;
&lt;p&gt;dim &lt;span class=&quot;math inline&quot;&gt;\(C(A^{\mathrm{T}})\)&lt;/span&gt; = dim &lt;span class=&quot;math inline&quot;&gt;\(R(A)\)&lt;/span&gt; = rank(&lt;span class=&quot;math inline&quot;&gt;\(A^{\mathrm{T}}\)&lt;/span&gt;) ≤ min(m,n)&lt;/p&gt;
&lt;p&gt;行空间&lt;span class=&quot;math inline&quot;&gt;\(C(A^{\mathrm{T}})\)&lt;/span&gt;的一组自然基底是矩阵A的行向量的最大线性无关组。&lt;/p&gt;
&lt;h3 id=&quot;列空间&quot;&gt;列空间&lt;/h3&gt;
&lt;p&gt;既然行空间是矩阵A所有行向量的线性组合，那么可以想到A对应的列空间应该是所有列向量的线性组合。&lt;/p&gt;
&lt;p&gt;设一m行n列实元素矩阵为&lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt;(mxn),则其行空间(Col Space)是由矩阵A的所有列向量生成的&lt;span class=&quot;math inline&quot;&gt;\(R^m\)&lt;/span&gt;上的子空间，记作&lt;span class=&quot;math inline&quot;&gt;\(C(A)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;矩阵A的列空间&lt;span class=&quot;math inline&quot;&gt;\(C(A)\)&lt;/span&gt;中的所有向量均为矩阵A中列向量的某种线性组合，都为&lt;span class=&quot;math inline&quot;&gt;\(R^m\)&lt;/span&gt;上的向量（即m维向量）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(C(A)\)&lt;/span&gt;的维度等于矩阵A的列秩，最大为min(m,n)。即：&lt;/p&gt;
&lt;p&gt;dim &lt;span class=&quot;math inline&quot;&gt;\(C(A)\)&lt;/span&gt; = rank(&lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt;) ≤ min(m,n)&lt;/p&gt;
&lt;p&gt;列空间&lt;span class=&quot;math inline&quot;&gt;\(C(A)\)&lt;/span&gt;的一组自然基底是矩阵A的列向量的最大线性无关组。&lt;/p&gt;
&lt;h3 id=&quot;零空间&quot;&gt;零空间&lt;/h3&gt;
&lt;p&gt;在数学中，一个矩阵A的零空间是方程&lt;span class=&quot;math inline&quot;&gt;\(Ax = 0\)&lt;/span&gt;的所有解&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;的集合。它也叫做A的核, 核空间，记为&lt;span class=&quot;math inline&quot;&gt;\(Null(A)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;想像一下，方程&lt;span class=&quot;math inline&quot;&gt;\(Ax = 0\)&lt;/span&gt;的解通常有哪种可能？我想大概分为两种可能：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(Null(A)\)&lt;/span&gt;仅有零解&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(Null(A)\)&lt;/span&gt;包含零解和无穷多个非零解&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;所以，不管怎么样，&lt;span class=&quot;math inline&quot;&gt;\(Null(A)\)&lt;/span&gt;都至少包含零向量&lt;/p&gt;
&lt;h3 id=&quot;左零空间&quot;&gt;左零空间&lt;/h3&gt;
&lt;p&gt;与零空间类似，只不过A的左零空间是方程&lt;span class=&quot;math inline&quot;&gt;\(A^{\mathrm{T}}x = 0\)&lt;/span&gt;的所有解&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;的集合。记为&lt;span class=&quot;math inline&quot;&gt;\(Null(A^{\mathrm{T}})\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;同样的，解集同样至少包含零解&lt;/p&gt;
&lt;h3 id=&quot;四个基本子空间的性质&quot;&gt;四个基本子空间的性质&lt;/h3&gt;
&lt;p&gt;对于一个mxn矩阵&lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt;来说：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;行空间与零空间正交&lt;/li&gt;
&lt;li&gt;列空间与左零空间正交&lt;/li&gt;
&lt;li&gt;dim &lt;span class=&quot;math inline&quot;&gt;\(R(A)\)&lt;/span&gt; + dim &lt;span class=&quot;math inline&quot;&gt;\(Null(A)\)&lt;/span&gt; = m，即行空间的维度+零空间的维度=行数&lt;/li&gt;
&lt;li&gt;dim &lt;span class=&quot;math inline&quot;&gt;\(C(A)\)&lt;/span&gt; + dim &lt;span class=&quot;math inline&quot;&gt;\(Null(A^{\mathrm{T}})\)&lt;/span&gt; = n，即列空间的维度+左零空间的维度=列数&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;性质证明&quot;&gt;性质证明&lt;/h3&gt;
&lt;p&gt;要证明两个子空间正交，先来给定子空间正交的定义是什么：若(内积空间)的子空间A和B满足一者中的每个向量都与另一者正交，那么它们互为正交子空间。其中内积空间是添加了内积运算的向量空间。&lt;/p&gt;
&lt;p&gt;好吧，反正就是证明矩阵A对应的行空间中的每个向量都与零空间中每个向量正交即可。有mxn矩阵&lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt;，将它写为下面这个形式:&lt;span class=&quot;math display&quot;&gt;\[ \left[ \begin{matrix} row &amp;amp; 1 &amp;amp; of &amp;amp; A \\ row &amp;amp; 2 &amp;amp; of &amp;amp; A \\ row &amp;amp; 3 &amp;amp; of &amp;amp; A \\ &amp;amp;\ .\\ &amp;amp;\ . \\ &amp;amp;\ . \\ row &amp;amp; m &amp;amp; of &amp;amp; A \end{matrix} \right] \]&lt;/span&gt;&lt;br/&gt;我们要求&lt;span class=&quot;math inline&quot;&gt;\(Ax = 0\)&lt;/span&gt;，让我们用上面这种形式写一遍：&lt;span class=&quot;math display&quot;&gt;\[ \begin{equation} \left[ \begin{matrix} row &amp;amp; 1 &amp;amp; of &amp;amp; A \\ row &amp;amp; 2 &amp;amp; of &amp;amp; A \\ row &amp;amp; 3 &amp;amp; of &amp;amp; A \\ &amp;amp;\ .\\ &amp;amp;\ . \\ &amp;amp;\ . \\ row &amp;amp; m &amp;amp; of &amp;amp; A \end{matrix} \right] \left[ \begin{matrix} x_1\\ x_2\\ x_3\\ .\\ .\\ .\\ x_n \end{matrix} \right]=\left[ \begin{matrix} 0\\ 0\\ 0\\ .\\ .\\ .\\ 0 \end{matrix} \right] \end{equation} \]&lt;/span&gt;&lt;br/&gt;所以，如果有一个向量&lt;span class=&quot;math inline&quot;&gt;\(v\)&lt;/span&gt;属于&lt;span class=&quot;math inline&quot;&gt;\(Null(A)\)&lt;/span&gt;，显然，将&lt;span class=&quot;math inline&quot;&gt;\(v\)&lt;/span&gt;带入(1)式是成立的。所以A中的每一行，即每个行向量都与向量&lt;span class=&quot;math inline&quot;&gt;\(v\)&lt;/span&gt;都正交。而A的行空间是行向量们的线性组合，所以&lt;span class=&quot;math inline&quot;&gt;\(v\)&lt;/span&gt;与A的行空间是正交的。同理，对于&lt;span class=&quot;math inline&quot;&gt;\(Null(A)\)&lt;/span&gt;中的其他向量，也和&lt;span class=&quot;math inline&quot;&gt;\(v\)&lt;/span&gt;一样与A的行空间是正交。因此，足以证明A行空间与零空间正交。&lt;/p&gt;
&lt;p&gt;同样的，可以证明A的列空间与左零空间正交，这里不再赘述。&lt;/p&gt;
&lt;h3 id=&quot;举例&quot;&gt;举例&lt;/h3&gt;
&lt;p&gt;好吧，举个实际的例子，这样以后看到也能马上想起来，哦，确实是这样。&lt;br/&gt;给出一个3x2的矩阵&lt;span class=&quot;math display&quot;&gt;\[A= \left[ \begin{matrix} 2 &amp;amp; 4 &amp;amp; 1 \\ 3 &amp;amp; 1 &amp;amp; 2 \end{matrix} \right]\]&lt;/span&gt;&lt;br/&gt;这个矩阵是我胡编的，让我们分别求一下A对应的行空间、列空间、零空间以及左零空间&lt;/p&gt;
&lt;h4 id=&quot;求解行空间&quot;&gt;求解行空间&lt;/h4&gt;
&lt;p&gt;显然，在A矩阵里有两个行向量&lt;span class=&quot;math inline&quot;&gt;\(\overrightarrow{r_1}, \overrightarrow{r_2}\)&lt;/span&gt;，它们分别是&lt;span class=&quot;math display&quot;&gt;\[ \overrightarrow{r_1}=\left[ \begin{matrix} 2\\ 4\\ 1 \end{matrix} \right] \ \ \ \ \ \ \ \ \ \ \ \overrightarrow{r_2}=\left[ \begin{matrix} 3\\ 1\\ 2 \end{matrix} \right] \]&lt;/span&gt;&lt;br/&gt;它们线性无关，所以&lt;span class=&quot;math inline&quot;&gt;\(\overrightarrow{r_1}, \overrightarrow{r_2}\)&lt;/span&gt;可以作为行空间中的一组基。它俩张成了A的行空间，&lt;span class=&quot;math inline&quot;&gt;\(R(A)\)&lt;/span&gt;中的任意一个向量都可以表示为&lt;span class=&quot;math display&quot;&gt;\[ \begin{equation} λ_1*\left[ \begin{matrix} 2\\ 4\\ 1 \end{matrix} \right]+ λ_2*\left[ \begin{matrix} 3\\ 1\\ 2 \end{matrix} \right]，其中λ_1、λ_2是任意实数 \end{equation} \]&lt;/span&gt;&lt;br/&gt;我们已经求得了A的行空间&lt;span class=&quot;math inline&quot;&gt;\(R(A)\)&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;求解列空间&quot;&gt;求解列空间&lt;/h4&gt;
&lt;p&gt;显然，在A矩阵里有三个列向量&lt;span class=&quot;math inline&quot;&gt;\(\overrightarrow{r_1}, \overrightarrow{r_2}, \overrightarrow{r_3}\)&lt;/span&gt;，它们分别是&lt;span class=&quot;math display&quot;&gt;\[ \overrightarrow{r_1}= \begin{equation} \left[ \begin{matrix} 2\\ 3 \end{matrix} \right] \ \ \ \ \ \ \ \ \ \ \ \overrightarrow{r_2}=\left[ \begin{matrix} 4\\ 1 \end{matrix} \right] \ \ \ \ \ \ \ \ \ \ \ \overrightarrow{r_3}=\left[ \begin{matrix} 1\\ 2 \end{matrix} \right] \end{equation}\]&lt;/span&gt;&lt;br/&gt;它们线性无关，所以&lt;span class=&quot;math inline&quot;&gt;\(\overrightarrow{r_1}, \overrightarrow{r_2}, \overrightarrow{r_3}\)&lt;/span&gt;可以作为行空间中的一组基，张成了A的列空间，&lt;span class=&quot;math inline&quot;&gt;\(C(A)\)&lt;/span&gt;中的任意一个向量都可以表示为&lt;span class=&quot;math display&quot;&gt;\[ λ_1*\left[ \begin{matrix} 2\\ 3 \end{matrix} \right]+ λ_2*\left[ \begin{matrix} 4\\ 1 \end{matrix} \right]+ λ_3*\left[ \begin{matrix} 1\\ 2 \end{matrix} \right]，其中λ_1、λ_2、λ_3是任意实数 \]&lt;/span&gt;&lt;br/&gt;我们已经求得了A的列空间&lt;span class=&quot;math inline&quot;&gt;\(R(A)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这里的行空间与列空间刚好由矩阵A的每行每列表示是因为我选的矩阵恰好是行满秩与列满秩，行空间由行向量组成的极大线性无关组表示，同理，列空间由列向量组成的极大线性无关组表示&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;求解零空间&quot;&gt;求解零空间&lt;/h4&gt;
&lt;p&gt;那就是求解&lt;span class=&quot;math display&quot;&gt;\[ \begin{equation} \left[ \begin{matrix} 2 &amp;amp; 4 &amp;amp; 1 \\ 3 &amp;amp; 1 &amp;amp; 2 \end{matrix} \right] \left[ \begin{matrix} x_1 \\ x_2 \\ x_3 \end{matrix} \right] =\left[ \begin{matrix} 0 \\ 0 \\ 0 \end{matrix} \right] \end{equation}\]&lt;/span&gt;&lt;br/&gt;使用高斯消元等到A矩阵的行最简形&lt;span class=&quot;math display&quot;&gt;\[ U=\begin{equation} \left[ \begin{matrix} -1 &amp;amp; -3 &amp;amp; 1 \\ 0 &amp;amp; 10 &amp;amp; -1 \end{matrix} \right] \end{equation} \]&lt;/span&gt;&lt;br/&gt;可以得到解的集合为&lt;span class=&quot;math display&quot;&gt;\[ x=k \begin{equation} \left[ \begin{matrix} 14 \\ -1 \\ 10 \end{matrix} \right] \end{equation} \]&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;求解左零空间&quot;&gt;求解左零空间&lt;/h4&gt;
&lt;p&gt;将矩阵A转置有&lt;span class=&quot;math display&quot;&gt;\[ A^{\mathrm{T}}= \begin{equation} \left[ \begin{matrix} 2 &amp;amp; 3 \\ 4 &amp;amp; 1 \\ 1 &amp;amp; 2 \end{matrix} \right] \end{equation} \]&lt;/span&gt;&lt;br/&gt;求解&lt;span class=&quot;math display&quot;&gt;\[ \begin{equation} \left[ \begin{matrix} 2 &amp;amp; 3 \\ 4 &amp;amp; 1 \\ 1 &amp;amp; 2 \end{matrix} \right] \left[ \begin{matrix} x_1 \\ x_2 \end{matrix} \right] =\left[ \begin{matrix} 0 \\ 0 \end{matrix} \right] \end{equation}\]&lt;/span&gt;&lt;br/&gt;以我多年的做题经验（笑），这个应该只有零解。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;四个空间都求出来了，加加它们的维度也是满足之前给出的子空间的性质，不同空间对应的基包含的向量也是相互正交的。&lt;/p&gt;
</description>
<pubDate>Sat, 09 Mar 2019 16:20:00 +0000</pubDate>
<dc:creator>shayue111</dc:creator>
<og:description>矩阵A一共对应着4个基本子空间，分别是列空间、行空间、零空间以及左零空间 行空间 设一m行n列实元素矩阵为$A$(mxn),则其行空间(Row Space)是由矩阵A的所有行向量所生成的$R^n$上的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shayue/p/10503873.html</dc:identifier>
</item>
<item>
<title>spring之旅第四篇-注解配置详解 - 茶底世界</title>
<link>http://www.cnblogs.com/yuanqinnan/p/10503859.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuanqinnan/p/10503859.html</guid>
<description>&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;一、引言&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;最近因为找工作，导致很长时间没有更新，找工作的时候你会明白浪费的时间后面都是要还的，现在的每一点努力，将来也会给你回报的，但行好事，莫问前程！努力总不会有错的。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;上一篇spring的配置博客评论中有园友指出现在很少用xml类配置SpringBean了,都是用注解的方式来进行配置，那么这篇就来讲注解配置。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;使用.xml文件来对bean进行注入的缺点很明显：文件会十分庞大，如果分多模块去配置，文件又特别的多，这些会导致可读性和可维护性变差。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;为了解决这两个问题，Spring引入了注解，通过&quot;@XXX&quot;的方式，让注解与Java Bean紧密结合，既大大减少了配置文件的体积，又增加了Java Bean的可读性与内聚性。&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;二、&lt;/span&gt;&lt;span class=&quot;md-expand&quot;&gt;将对象注册到容器&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;注解如何使用呢，分为三步&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;strong&gt;第一步：在 applicationContext.xml 中引入命名空间&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201903/1113901-20190309235937105-1701515761.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-meta md-before&quot;&gt;&lt;strong&gt;&lt;span&gt;第二步：在 applicationContext.xml 文件中引入注解扫描器&lt;/span&gt;&lt;/strong&gt;&lt;span class=&quot;md-meta md-after&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;context:component-scan &lt;/span&gt;&lt;span&gt;base-package&lt;/span&gt;&lt;span&gt;=&quot;com.yuanqinnan.test&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;context:component-scan&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;base-package：表示含有注解类的包名&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;如果扫描多个包，则上面的代码书写多行，改变 base-package 里面的内容即可！&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;如果使用Idea引入注解扫描器，就会直接引入命名空间&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-meta md-before&quot;&gt;&lt;strong&gt;&lt;span&gt;第三步：在 Car 类中添加注解@Component&lt;/span&gt;&lt;/strong&gt;&lt;span class=&quot;md-meta md-after&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Car {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String Color;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getColor() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Color;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setColor(String color) {
        Color &lt;/span&gt;=&lt;span&gt; color;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;Car{&quot; +
                &quot;Color='&quot; + Color + '\'' +
                '}'&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;md-meta md-before&quot;&gt;&lt;strong&gt;&lt;span&gt;第四步：测试&lt;/span&gt;&lt;/strong&gt;&lt;span class=&quot;md-meta md-after&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
          ApplicationContext ctx=&lt;span&gt;new&lt;/span&gt; ClassPathXmlApplicationContext(&quot;META-INF/applicationContext.xml&quot;&lt;span&gt;);
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取bean的实例&lt;/span&gt;
          Car car=(Car) ctx.getBean(&quot;car&quot;&lt;span&gt;);
          System.out.println(car.toString());&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;结果：&lt;/strong&gt;&lt;span class=&quot;md-meta md-before&quot;&gt;Car{Color='null'}&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span class=&quot;md-meta md-before&quot;&gt;三、&lt;/span&gt;&lt;span class=&quot;md-expand&quot;&gt;值类型注入&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
@Value(&quot;yellow&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setColor(String color) {
    Color &lt;/span&gt;=&lt;span&gt; color;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果：Car{Color='yellow'}&lt;/p&gt;
&lt;h2&gt;四、&lt;span class=&quot;md-expand&quot;&gt;引用类型注入&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;引用类型分为自动装配@Autowired和手动注入@Resource&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span class=&quot;md-expand&quot;&gt;4.1 @&lt;/span&gt;&lt;span class=&quot;md-expand&quot;&gt;Autowired&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;顾名思义，就是自动装配，其作用是为了消除代码Java代码里面的getter/setter与bean属性中的property。当然，getter看个人需求，如果私有属性需要对外提供的话，应当予以保留。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;@Autowired默认按类型匹配的方式，在容器查找匹配的Bean，当&lt;span&gt;&lt;strong&gt;有且仅有一个匹配的Bean&lt;/strong&gt;&lt;span&gt;时，Spring将其注入@Autowired标注的变量中。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;创建一个新类Boss&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Boss {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;自动装配&lt;/span&gt;
&lt;span&gt;    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Car car;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
    @Value(&lt;/span&gt;&quot;袁帅&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setName(String name) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;Boss{&quot; +
                &quot;car=&quot; + car.getColor() +
                &quot;, name='&quot; + name + '\'' +
                '}'&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;测试：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Boss boss=(Boss)ctx.getBean(&quot;boss&quot;&lt;span&gt;);
System.out.println(boss.toString());&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;结果：&lt;/strong&gt;Boss{car=yellow, name='袁帅'}&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;这种方式存在匹配到多个类型一致的的情况，这种情况需要&lt;span&gt;&lt;strong&gt;&lt;span&gt;Qualifier&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;来解决&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;定义一个Car接口：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; ICar {
     String getCarName();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;两个实现类BMWCar和BenzCar：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
@Component(&quot;benzCar&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BenzCar &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; ICar {

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getCarName() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;奔驰&quot;&lt;span&gt;;
    }
}
@Component(&lt;/span&gt;&quot;bmwCar&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BMWCar &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; ICar {
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getCarName() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;宝马&quot;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;工厂类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
@Component(&quot;cf&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CarFactory {
    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; ICar iCar;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; iCar.getCarName();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;很明显这种写法会报错，&lt;/p&gt;
&lt;pre&gt;
No unique bean of type [com.spring.service.ICar] is defined: expected single matching bean but found 2: [bmwCar, benz]
&lt;/pre&gt;
&lt;p&gt;很明显这种写法会报错，因为Spring并不知道应当引用哪个实现类，这个时候使用@Qualifie&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Autowired
@Qualifier(&lt;/span&gt;&quot;bmwCar&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; ICar iCar;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;结果：&lt;/strong&gt;宝马&lt;/p&gt;
&lt;h3&gt;4.2 &lt;span class=&quot;md-expand&quot;&gt;@Resource&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;@Resource注解与@Autowired注解作用非常相似，这个就简单说了，看例子：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
@Resource(type = BenzCar.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; ICar iCar2;

@Resource(name &lt;/span&gt;= &quot;benzCar&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; ICar iCar3;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;五、&lt;span class=&quot;md-expand&quot;&gt;常用注解总结&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;最后介绍常用的注解&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;@Configuration把一个类作为一个IoC容器，它的某个方法头上如果注册了&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;@Bean，就会作为这个Spring容器中的Bean。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;@Scope注解 作用域 &lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;@Lazy(true) 表示延迟初始化&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;@Service用于标注业务层组件、&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;@Controller用于标注控制层组件（如struts中的action）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;@Repository用于标注数据访问组件，即DAO组件。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;@Component泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;@Scope用于指定scope作用域的（用在类上）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;@PostConstruct用于指定初始化方法（用在方法上）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;@PreDestory用于指定销毁方法（用在方法上）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;@DependsOn：定义Bean初始化及销毁时的顺序&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;@Primary：自动装配时当出现多个Bean候选者时，被注解为@Primary的Bean将作为首选者，否则将抛出异常 &lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;@Autowired 默认按类型装配，如果我们想使用按名称装配，可以结合@Qualifier注解一起使用。如下： &lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;@Autowired @Qualifier(&quot;personDaoBean&quot;) 存在多个实例配合使用 &lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;@Resource默认按名称装配，当找不到与名称匹配的bean才会按类型装配。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;@PostConstruct 初始化注解&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;@PreDestroy 摧毁注解 默认 单例 启动就加载&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;@Async异步方法调用&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;




&lt;p class=&quot;md-end-block md-focus&quot;&gt; &lt;/p&gt;
</description>
<pubDate>Sat, 09 Mar 2019 16:15:00 +0000</pubDate>
<dc:creator>茶底世界</dc:creator>
<og:description>一、引言 最近因为找工作，导致很长时间没有更新，找工作的时候你会明白浪费的时间后面都是要还的，现在的每一点努力，将来也会给你回报的，但行好事，莫问前程！努力总不会有错的。 上一篇spring的配置博客</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuanqinnan/p/10503859.html</dc:identifier>
</item>
<item>
<title>为Qt视图中的文字添加彩虹渐变效果 - apocelipes</title>
<link>http://www.cnblogs.com/apocelipes/p/10503835.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/apocelipes/p/10503835.html</guid>
<description>&lt;p&gt;将view中的文本内容用自定义的颜色显示是一种十分常见的需求。今天我们稍微改变些“花样”。&lt;/p&gt;
&lt;blockquote id=&quot;bookmark&quot;&gt;
&lt;h4&gt;本文索引&lt;/h4&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;需求定义&quot;&gt;需求定义&lt;/h2&gt;
&lt;p&gt;我们的需求很简单，现在有一些在view中的text内容需要使用彩色显示，而且不使用单一的一种颜色，而是多种颜色渐变实现的彩虹效果。&lt;/p&gt;
&lt;p&gt;文字描述可能比较抽象，所以我们先给出预想的效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1434464/201903/1434464-20190310000730318-1558683844.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在让我们想办法实现图中的效果。&lt;/p&gt;
&lt;h2 id=&quot;需求分析&quot;&gt;需求分析&lt;/h2&gt;
&lt;p&gt;好在Qt的Model/View机制对于用户自定义的外观控制提供了极为丰富的支持，因此我们可以轻松地实现许多独特的显示效果。&lt;/p&gt;
&lt;p&gt;通常情况下，对于像按特定颜色显示内容的需求只需要在model的data接口中根据调用时的&lt;code&gt;Qt::ItemDataRole&lt;/code&gt;返回对应的数据即可，比如控制文本颜色时我们只需要对&lt;code&gt;Qt::ForegroundRole&lt;/code&gt;返回指定的&lt;code&gt;QBrush&lt;/code&gt;对象就可以。&lt;/p&gt;
&lt;p&gt;但是仔细思考之后你就会发现这种办法并不能解决我们的需求。&lt;/p&gt;
&lt;p&gt;我们想要实现渐变效果是不能只返回单一的一种颜色的，需要用到&lt;code&gt;QLinearGradient&lt;/code&gt;，并且需要指定线性填充的坐标及大小。而我们光从&lt;code&gt;Qt::ItemDataRole&lt;/code&gt;是拿不到文字的显示范围的，因此我们就不能指定渐变填充的范围了。&lt;/p&gt;
&lt;p&gt;不过正如本节开头所说，Qt提供了足够多的途径让你控制元素的外观。所以我们很快就把目光投向了delegate，一种经常用来控制model中数据显示的工具。&lt;/p&gt;
&lt;p&gt;虽然delegate更多的是充当了显示非文本数据以及控制显示格式的责任，但是只要实现了它的&lt;code&gt;paint&lt;/code&gt;方法。我们一样可以绘制想要的效果。特别的，&lt;code&gt;paint&lt;/code&gt;方法还会将待绘制区域的信息从参数中传入，因此我们有充足的条件使用&lt;code&gt;QLinearGradient&lt;/code&gt;实现文字的渐变效果了。&lt;/p&gt;
&lt;p&gt;现在已经清楚实现我们的需求的思路了，接下来我们看看如何用代码实现它。&lt;/p&gt;
&lt;h2 id=&quot;代码实现&quot;&gt;代码实现&lt;/h2&gt;
&lt;p&gt;我们只需要继承&lt;code&gt;QStyledItemDelegate&lt;/code&gt;并重写它的&lt;code&gt;paint&lt;/code&gt;和&lt;code&gt;sizeHint&lt;/code&gt;方法：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;class ColorDelegate : public QStyledItemDelegate {
public:
    void paint(QPainter *painter, const QStyleOptionViewItem &amp;amp;option,
               const QModelIndex &amp;amp;index) const override;

    QSize sizeHint(const QStyleOptionViewItem &amp;amp;option,
                   const QModelIndex &amp;amp;index) const override;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中&lt;code&gt;paint&lt;/code&gt;用来绘制我们的显示效果，而&lt;code&gt;sizeHint&lt;/code&gt;则返回item的大小。&lt;/p&gt;
&lt;p&gt;对于&lt;code&gt;sizeHint&lt;/code&gt;没有什么特别的操作，单纯计算文字的长度和高度，然后基于这连个值指定item的大小：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;QSize ColorDelegate::sizeHint(const QStyleOptionViewItem &amp;amp;option,
                              const QModelIndex &amp;amp;index) const {
    auto text = index.data().toString();
    auto width = option.fontMetrics.width(text) + 20;
    return QSize{width, option.fontMetrics.height()};
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面就要进入重点了：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void ColorDelegate::paint(QPainter *painter, const QStyleOptionViewItem &amp;amp;option,
                          const QModelIndex &amp;amp;index) const {
    auto text = index.data().toString();
    auto myOpt = option;
    myOpt.displayAlignment = Qt::AlignCenter;
    auto sWidth = myOpt.fontMetrics.width(text);
    auto sHeight = myOpt.fontMetrics.height();
    // 计算文字所在的范围，因为是居中对齐，所以需要计算相应的起始位置
    auto sRect = QRectF(myOpt.rect.x() + (myOpt.rect.width() - sWidth) / 2.0,
                        myOpt.rect.y() + ((myOpt.rect.height() - sHeight) / 2.0), sWidth, sHeight);

    // 将渐变填充的范围设置成文字所在的范围
    QLinearGradient l(sRect.x(), sRect.y(), sRect.x() + sRect.width(),
                      sRect.y() + sRect.height());

    // 设置彩虹色渐变效果，彩虹由赤橙黄绿青蓝紫的颜色组成
    // 因此我们除去起始点为红色，每隔1/6就设置一种颜色
    l.setColorAt(0, Qt::red);
    l.setColorAt(1.0 / 6, QColor(255, 97, 0));
    l.setColorAt(2.0 / 6, QColor(255, 255, 0));
    l.setColorAt(3.0 / 6, Qt::green);
    l.setColorAt(4.0 / 6, Qt::cyan);
    l.setColorAt(5.0 / 6, Qt::blue);
    l.setColorAt(1, QColor(255, 0, 255));

    // 这里并不使用painter，只需要QStyle即可实现效果
    // QPalette::Text为文本显示效果的role
    auto role = QPalette::Text;
    if (option.state &amp;amp; QStyle::State_Selected) {
        // 当前item被选中时绘制高亮的选中框
        role = QPalette::HighlightedText;
        painter-&amp;gt;fillRect(option.rect, option.palette.highlight());
    }
    myOpt.palette.setBrush(role, QBrush(l));
    // 注意最后一个参数role，只有设置了它才能让QStyle正确地绘制自定义的文本显示效果
    QApplication::style()-&amp;gt;drawItemText(painter, myOpt.rect, myOpt.displayAlignment,
                                        myOpt.palette, true, text, role);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要注意的都已经在注释中说明，可以看到&lt;code&gt;paint&lt;/code&gt;的逻辑实际上并不复杂，只需要正确计算文字的显示范围后调用相应的绘制接口即可。&lt;/p&gt;
&lt;p&gt;可能你会有些疑惑，为什么要计算文本的范围？答案是因为如果将整个item作为填充范围的话，那么文本之外的空白部分也会被计算进去，因此文本的显示效果会被view的拉伸的缩小所影响，显然不是我们希望的结果，因此只填充文本所在的范围就很有必要了。&lt;/p&gt;
&lt;p&gt;至于delegate的其他功能，我们选择继续使用父类的默认实现，因为我们只是使用delegate控制显示效果的功能，并不需要实现和数据的交互。&lt;/p&gt;
&lt;p&gt;下面我们测试下自定义的&lt;code&gt;ColorDelegate&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;QApplication&amp;gt;
#include &amp;lt;QStandardItemModel&amp;gt;
#include &amp;lt;QListView&amp;gt;
#include &amp;lt;QVBoxLayout&amp;gt;

#include &quot;ColorDelegate.h&quot;

int main(int argc, char **argv) {
    QApplication app(argc, argv);

    auto win = new QWidget{};
    auto model = new QStandardItemModel{win};
    model-&amp;gt;appendRow(new QStandardItem{&quot;C++&quot;});
    model-&amp;gt;appendRow(new QStandardItem{&quot;GoLang&quot;});
    model-&amp;gt;appendRow(new QStandardItem{&quot;JavaScript&quot;});
    model-&amp;gt;appendRow(new QStandardItem{&quot;Object C&quot;});
    model-&amp;gt;appendRow(new QStandardItem{&quot;Rust&quot;});
    model-&amp;gt;appendRow(new QStandardItem{&quot;这是一串非常非常长的被作为测试用例的样本字符串。&quot;});
    model-&amp;gt;appendRow(new QStandardItem{&quot;██████████████████&quot;});
    auto view = new QListView{};
    view-&amp;gt;setModel(model);
    view-&amp;gt;setItemDelegate(new ColorDelegate{}); // 设置自定义delegate

    auto layout = new QVBoxLayout{};
    layout-&amp;gt;addWidget(view);
    win-&amp;gt;setLayout(layout);
    win-&amp;gt;show();

    app.exec();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行之后你就会看到如下图的界面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1434464/201903/1434464-20190310000616759-1693934536.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;虽然文字较短时某些位于边缘的颜色有些难以辨认，但整体的彩虹色渐变效果是很明显的。这样我们就实现了文字的彩虹渐变效果。&lt;/p&gt;
&lt;h2 id=&quot;思考题&quot;&gt;思考题&lt;/h2&gt;
&lt;p&gt;最后我们留下一点思考。&lt;/p&gt;
&lt;p&gt;虽然我们实现了需求，但是我们的delegate只能处理文字居中的情况，那么其他对齐的情况下呢？&lt;/p&gt;
&lt;p&gt;或者如果我们已经在model设置了对齐方式，在delegate中不想改变它，这时候有办法让我们的delegate正常工作吗？&lt;/p&gt;
&lt;p&gt;答案是肯定的，只需要将文本范围的计算逻辑做一些修改，因此各位读者不防将其作为一个小练习：）。&lt;/p&gt;
</description>
<pubDate>Sat, 09 Mar 2019 16:08:00 +0000</pubDate>
<dc:creator>apocelipes</dc:creator>
<og:description>将view中的文本内容用自定义的颜色显示是一种十分常见的需求。今天我们稍微改变些“花样”。 本文索引 需求定义 需求分析 代码实现 思考题 需求定义 我们的需求很简单，现在有一些在view中的text</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/apocelipes/p/10503835.html</dc:identifier>
</item>
<item>
<title>纪念 Vamei - 豌豆花下猫</title>
<link>http://www.cnblogs.com/pythonista/p/10503790.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pythonista/p/10503790.html</guid>
<description>&lt;p&gt;偶然在某公众号里看到一篇文章，得知 Vamei 去世的消息。&lt;/p&gt;
&lt;p&gt;看到它之前，我并不知道这位“知名的 Python 技术博主”。我写 Python 技术文章有一小段时间了，也认识了很多圈内的博主。但是，这个 Vamei 是谁呢？竟不认识。我很好奇。&lt;/p&gt;
&lt;p&gt;因为消息是从豆瓣里传出来的，我就去搜他的豆瓣。然后，一路看到了他的知乎，他的书，他的技术博客，他的演讲，他的微博，甚至他的公众号，也看到了一些友人的纪念文章。&lt;/p&gt;
&lt;p&gt;看得越多，我就越放不下了。正好我在写一篇荐书栏目，就发现他跟我恰巧同时在读着一本未上市的新书。这个难得的巧合让我更不能释怀，我自以为这是一个神秘主义的讯息。&lt;/p&gt;
&lt;p&gt;该拿他怎么办呢？我决定就写下这篇东西，以作纪念吧。&lt;/p&gt;
&lt;h2 id=&quot;h1&quot;&gt;（1）一首诗&lt;/h2&gt;
&lt;p&gt;他在豆瓣的最后一篇日记是一首诗：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;《寻影》&lt;/p&gt;
&lt;p&gt;远处的光臆造身前的影。&lt;/p&gt;
&lt;p&gt;影高而大，&lt;/p&gt;
&lt;p&gt;噬我，缠绕我，御我为奴。&lt;/p&gt;
&lt;p&gt;我与影欢歌。&lt;/p&gt;
&lt;p&gt;倏忽，&lt;/p&gt;
&lt;p&gt;光灭影消。&lt;/p&gt;
&lt;p&gt;黑漆漆的我，&lt;/p&gt;
&lt;p&gt;不知何处寻影。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;发布时间 2 月 21 日，距离世日期仅一周。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;http://ww1.sinaimg.cn/large/68b02e3bgy1g0wy6ejeipj20u00u0754.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一个臆造的高大的影，吃人奴役人，然而他说，与影欢歌。这是哪种的乐？是愚者后知后觉，还是英雄苦中寻乐？&lt;/p&gt;
&lt;p&gt;光灭影消，不去寻光，却要找影，为什么？是因为没有了光，还是他离不开影？&lt;/p&gt;
&lt;p&gt;黑漆漆的 Vamei，他的外号是“挖煤”。&lt;/p&gt;
&lt;p&gt;挖煤，挖煤，挖的是什么煤？&lt;/p&gt;
&lt;p&gt;挖出来知识的煤、技术的煤，照亮了读者。可是没有挖出生命的煤，又或者是，挖出的那生命的煤已烧干净了呢，没办法再继续照亮他自己？&lt;/p&gt;
&lt;h2 id=&quot;h2&quot;&gt;（2）他是谁？&lt;/h2&gt;
&lt;p&gt;他生于 1988 年，本科毕业于中科大，博士毕业于南洋理工。&lt;/p&gt;
&lt;p&gt;他出版了两本纸书《从Python开始学编程》和《树莓派开始，玩转Linux》，在豆瓣读书上出了 6 本电子书，内容既有网络协议、新加坡考古、气象人物与历史，还有手机摄影，以及一本中篇科幻小说。&lt;/p&gt;
&lt;p&gt;他写技术博客，内容有 Python/Linux/网络协议/算法/Java/数据科学的系列文章，200 多篇，据统计，总阅读量超过 800 万。按照积分排名，他是 156 名。&lt;/p&gt;
&lt;p&gt;他是某智能农业公司的首席技术官，因 AI 养猪而闻名，被邀请上《一席》节目做过分享。他演讲时幽默风趣，堪称程序员界的段子手。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;Vamei制服一头猪&quot; src=&quot;http://ww1.sinaimg.cn/large/68b02e3bgy1g0wxw14l05j20p20hm1b9.jpg&quot; alt=&quot;Vamei制服一头猪&quot;/&gt;Vamei制服一头猪&lt;/p&gt;
&lt;p&gt;他兴趣广泛，学识渊博，从电影中聊历史，从名画中聊天气，写过科普，写过手机摄影教程。有作品发表在南方人物周刊、国家人文历史、澎湃新闻、果壳网这样的主流媒体上。&lt;/p&gt;
&lt;p&gt;他研究过创伤心理学，写过一篇《没有杀死我的》。语自尼采——&lt;strong&gt;没有杀死我的让我更强大。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在这篇文章的末尾，他写道：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;我的记忆中有一些窘迫或者恐惧的片段，希望有一天能够淡然看待这些。&lt;/p&gt;
&lt;p&gt;痛并快乐着，送给所有努力和创伤斗争的朋友。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;h3&quot;&gt;（3）什么杀了他？&lt;/h2&gt;
&lt;p&gt;我想在他留下来的痕迹里找出一个解释：这么一个有趣的人，是什么杀了他？&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;一个友人的豆瓣广播&quot; src=&quot;http://ww1.sinaimg.cn/large/68b02e3bgy1g0wv9p3qnhj20q00eago3.jpg&quot; alt=&quot;一个友人的豆瓣广播&quot;/&gt;一个友人的豆瓣广播&lt;/p&gt;
&lt;p&gt;所有认识他的人都表示震惊，一个阳光男孩，一个风趣博主，怎么说走就走了呢？&lt;/p&gt;
&lt;p&gt;一个插画师说：“回来吧 你书稿还没写完啊”。&lt;/p&gt;
&lt;p&gt;一个朋友说：“记得几个月前还在问我办理准生证的事”。另一个朋友说：“我还以为他忙于工作和照看婴儿，像我在我女儿刚出生那时一样，无暇顾及社交”。&lt;/p&gt;
&lt;p&gt;大家都没想到。没有任何迹象，除了那首短诗。&lt;/p&gt;
&lt;p&gt;人们常说，女性可能会得产后抑郁。可是，作为一个新晋爸爸，他怎么也抑郁了呢？那到底是多重的抑郁，才会使一个丈夫、一个爸爸，抛家弃子，纵身跃下高楼？&lt;/p&gt;
&lt;p&gt;Vamei 写下了很多文字，但几乎没有写过家庭和家人。我做了一番侦探工作，才仅仅获得几条零碎的线索。最近的一条是 2015 年的年终回顾，他写到：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;最先浮现的是一些快乐的孤点。和太太躲在阳台上吃自制的麻辣香锅，被辣得快要晕过去。生日那天被忽悠到公园，在亭子里意外收到一堆生日礼物。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;往前一年，他得意地晒出“挖夫人送给挖煤君的生日礼物”，那是一本手工相册，贴了他的摄影作品。相册背部依稀写着“By Vivian With love”。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;http://ww1.sinaimg.cn/large/68b02e3bgy1g0wya6scj1j20u00u0wkv.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再往前一年，是他们相识的第三年，大概正是那时，婚姻、蜜月、搬家，和乐融融。&lt;/p&gt;
&lt;p&gt;其它时候，其它家人，没有踪迹可寻。他全部的世界似乎都在几大网络平台中，豆瓣、微博、博客园、知乎，身份始终是网红、科普达人、技术达人、撰稿人和文青。&lt;/p&gt;
&lt;p&gt;他的豆瓣签名解释了自己的身份：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Vamei 是赤道附近一个台风的名字。按照气象规律，台风不常出现在赤道。所以，Vamei 是一个离群的风，无所顾忌地生长，不着边际地游荡。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;抑郁症的倾向深深地隐藏在其中，你甚至可能怀疑，这样一个高智商的、自由的、成功的、热爱生活的人，绝对不会做出那种事来。&lt;/p&gt;
&lt;p&gt;可是，越是聪明而理智的人，越是善于藏住自己的阴郁，所以，即使是他的深夜自白中，你也看不出文字的密码：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;我也提笔写文，作一些历史与自然的文章，用一知半解和胡思乱想编织成一个自己的精神世界。然而骗得了他人，却开解不了自己：那些文章，只不过是为了安放无处可去的自己。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那些试图并且成功杀死了他的东西，究竟是什么呢？我仍不得而知。&lt;/p&gt;
&lt;p&gt;继续读那篇《没有杀死我的》。他为什么会关心创伤心理学呢？&lt;/p&gt;
&lt;p&gt;他在说创伤是一种财富，说创伤是一个成长的机会，说要不断体验创伤造成的痛苦，来达到自我的实现，这个时候，他说的是自我疗伤的经验，还是仅仅在作一份科普呢？&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;http://ww1.sinaimg.cn/large/68b02e3bgy1g0wy7q0wnxj20qo0qo75q.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;没有杀死我的让我更强大，可是，我变强大，那杀人犯也在变强大啊。那想要杀我的东西，并不是一把痛快的刀，而是一把吱呀吱呀的锯子，磨啊磨，等你麻木了的时候，时间就站到了死神的一边。&lt;/p&gt;
&lt;p&gt;Vamei 啊，Vamei 啊，你要指出我的错谬么？&lt;/p&gt;
&lt;p&gt;愿在天国，仍有撰稿创作的平台，有代码和猪。&lt;/p&gt;
&lt;p&gt;愿在天国，没有抑郁症。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;相关文章：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一席演讲：https://mp.weixin.qq.com/s/usQ3vBg0EqAiHiysJ5ZRjQ&lt;/p&gt;
&lt;p&gt;没有杀死我的：https://www.cnblogs.com/vamei/archive/2013/01/15/2861928.html&lt;/p&gt;
&lt;p&gt;朋友纪念1：https://mp.weixin.qq.com/s/BsP8pCtuIjD7mOPQThlWzg&lt;/p&gt;
&lt;p&gt;朋友纪念2：https://mp.weixin.qq.com/s/_S8P0uxU_jT81lNfJzRztA&lt;/p&gt;
&lt;p&gt;技术圈纪念1：https://mp.weixin.qq.com/s/mKqrqt0gFfpifEnTzccYbQ&lt;/p&gt;
&lt;p&gt;技术圈纪念2：https://mp.weixin.qq.com/s/EOhJXsXO8tgibZ9PDZXLfg&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;http://ww1.sinaimg.cn/large/68b02e3bgy1g0wy5wiwu6j20u00u0n0r.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;PS：除驯猪图，其它照片皆 Vamei 所摄，取自豆瓣&lt;/p&gt;
</description>
<pubDate>Sat, 09 Mar 2019 15:55:00 +0000</pubDate>
<dc:creator>豌豆花下猫</dc:creator>
<og:description>偶然在某公众号里看到一篇文章，得知 Vamei 去世的消息。 看到它之前，我并不知道这位“知名的 Python 技术博主”。我写 Python 技术文章有一小段时间了，也认识了很多圈内的博主。但是，这</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pythonista/p/10503790.html</dc:identifier>
</item>
<item>
<title>Linux内核 - |瑾诺学长|</title>
<link>http://www.cnblogs.com/jin-nuo/p/10503774.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jin-nuo/p/10503774.html</guid>
<description>&lt;p&gt;今天，我来为大家解读一幅来自 TurnOff.us 的漫画 “InSide The &lt;a href=&quot;https://mb.yidianzixun.com/channel/w/linux&quot;&gt;Linux&lt;/a&gt; Kernel” 。 TurnOff.us 是一个极客漫画网站，作者Daniel Stori 画了一些非常有趣的关于编程语言、Web、云计算、Linux 相关的漫画。今天解读的便是其中的一篇。&lt;/p&gt;
&lt;p&gt;在开始，我们先来看看这幅漫画的全貌！&lt;/p&gt;
&lt;div&gt;&lt;span class=&quot;a-image&quot;&gt;&lt;span class=&quot;a-image&quot;&gt;&lt;img src=&quot;https://i1.go2yd.com/image.php?url=0LOyG05fVJ&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;
&lt;p&gt;这幅漫画是以一个房子的侧方刨面图来绘画的。使用这样的一个房子来代表 Linux 内核。&lt;/p&gt;
&lt;h2&gt;地基&lt;/h2&gt;
&lt;p&gt;作为一个房子，最重要的莫过于其地基，在这个图片里，我们也从最下面的地基开始看起：&lt;/p&gt;
&lt;div&gt;&lt;span class=&quot;a-image&quot;&gt;&lt;span class=&quot;a-image&quot;&gt;&lt;img src=&quot;https://i1.go2yd.com/image.php?url=0LOyG0W7LA&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;
&lt;p&gt;&lt;em&gt;地基&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;地基（底层）由一排排的文件柜组成，井然有序，文件柜里放置着“文件”——&lt;a href=&quot;https://mb.yidianzixun.com/channel/w/%E7%94%B5%E8%84%91&quot;&gt;电脑&lt;/a&gt;中的文件。左上角，有一只胸前挂着 421 号牌的小企鹅，它表示着 PID（进程 IDProcess ID） 为 421 的进程，它正在查看文件柜中的文件，这代表系统中正有一个进程在访问文件系统。在右下角有一只小狗，它是&lt;a href=&quot;https://mb.yidianzixun.com/channel/w/%E7%9C%8B%E9%97%A8%E7%8B%97watchdog&quot;&gt;看门狗watchdog&lt;/a&gt; ，这代表对文件系统的监控。&lt;/p&gt;
&lt;div&gt;&lt;span class=&quot;a-image&quot;&gt;&lt;span class=&quot;a-image&quot;&gt;&lt;img src=&quot;https://i1.go2yd.com/image.php?url=0LOyG0uETA&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;
&lt;p&gt;&lt;em&gt;一层（地面层）&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;一层（地面层）&lt;/h2&gt;
&lt;p&gt;看完了地基，接下来我们来看地基上面的一层，都有哪些东西。&lt;/p&gt;
&lt;div&gt;&lt;span class=&quot;a-image&quot;&gt;&lt;span class=&quot;a-image&quot;&gt;&lt;img src=&quot;https://i1.go2yd.com/image.php?url=0LOyG07ZMM&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;
&lt;p&gt;&lt;em&gt;进程表&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;这一层，最引人瞩目的莫过于中间的一块垫子，众多小企鹅在围着着桌子坐着。这个垫子的区域代表进程表。&lt;/p&gt;
&lt;p&gt;左上角有一个小企鹅，站着，仿佛在说些什么这显然是一位家长式的人物，不过看起来周围坐的那些小企鹅不是很听话——你看有好多走神、自顾自聊天的——“喂喂，说你呢，哇塞娃（171），转过身来”。它代表着 &lt;a href=&quot;https://mb.yidianzixun.com/channel/w/linux&quot;&gt;Linux&lt;/a&gt; 内核中的初始化（init）进程，也就是我们常说的 PID 为 1 的进程。桌子上坐的小企鹅都在等待状态wait中，等待工作任务。&lt;/p&gt;
&lt;div&gt;&lt;span class=&quot;a-image&quot;&gt;&lt;span class=&quot;a-image&quot;&gt;&lt;img src=&quot;https://i1.go2yd.com/image.php?url=0LOyG0d203&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;
&lt;p&gt;&lt;em&gt;看门狗&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;瞧瞧，垫子（进程表）两旁有两只小狗，它会监控小企鹅的状态（监控进程），当小企鹅们不听话时，它就会汪汪地叫喊起来。&lt;/p&gt;
&lt;div&gt;&lt;span class=&quot;a-image&quot;&gt;&lt;span class=&quot;a-image&quot;&gt;&lt;img src=&quot;https://i1.go2yd.com/image.php?url=0LOyG0QTCH&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;
&lt;p&gt;&lt;em&gt;http 进程&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;在这层的左侧，有一只号牌为 1341 的小企鹅，守在门口，门上写着 80，说明这个 PID 为 1341 的小企鹅负责接待 80 端口，也就是我们常说的 HTTP （网站）的端口。小企鹅头上有一片羽毛，这片羽毛大有来历，它是著名的 HTTP 服务器 &lt;a href=&quot;https://mb.yidianzixun.com/channel/w/apache&quot;&gt;Apache&lt;/a&gt; 的 Logo。喏，就是这只：&lt;/p&gt;
&lt;div&gt;&lt;span class=&quot;a-image&quot;&gt;&lt;span class=&quot;a-image&quot;&gt;&lt;img src=&quot;https://i1.go2yd.com/image.php?url=0LOyG0F1mE&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;
&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://mb.yidianzixun.com/channel/w/apache&quot;&gt;apache&lt;/a&gt; logo&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;向右看，我们可以看到这里仍有一扇门，门上写着 21，但是，看起来这扇门似乎年久失修，上面的门牌号都歪了，门口也没人守着。看起来这个 21 端口的 FTP 协议有点老旧了，目前用的人也比以前少了，以至于这里都没人接待了。&lt;/p&gt;
&lt;div&gt;&lt;span class=&quot;a-image&quot;&gt;&lt;span class=&quot;a-image&quot;&gt;&lt;img src=&quot;https://i1.go2yd.com/image.php?url=0LOyG0yPZt&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;
&lt;p&gt;&lt;em&gt;无人看守的 FTP 进程&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;而在最右侧的一个门牌号 22 的们的待遇就大为不同，居然有一只带着墨镜的小企鹅在守着，看起来好酷啊，它是黑衣人叔叔吗？为什么要这么酷的一个企鹅呢，因为 22 端口是 &lt;a href=&quot;https://mb.yidianzixun.com/channel/w/ssh&quot;&gt;SSH&lt;/a&gt; 端口，是一个非常重要的&lt;a href=&quot;https://mb.yidianzixun.com/channel/w/%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5&quot;&gt;远程连接&lt;/a&gt;端口，通常通过这个端口进行远程管理，所以对这个端口进来的人要仔细审查。&lt;/p&gt;
&lt;div&gt;&lt;span class=&quot;a-image&quot;&gt;&lt;span class=&quot;a-image&quot;&gt;&lt;img src=&quot;https://i1.go2yd.com/image.php?url=0LOyG091um&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;
&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://mb.yidianzixun.com/channel/w/ssh&quot;&gt;SSH&lt;/a&gt; 守护进程&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;它的身上写着 52，说明它是第 52 个小企鹅。&lt;/p&gt;
&lt;div&gt;&lt;span class=&quot;a-image&quot;&gt;&lt;span class=&quot;a-image&quot;&gt;&lt;img src=&quot;https://i1.go2yd.com/image.php?url=0LOyG0PdjT&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;
&lt;p&gt;&lt;em&gt;到达文件系统&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;在图片的左上角，有一个向下台阶。这个台阶是底层（地基）的文件系统中的，进程们可以通过这个台阶，到文件系统中去读取文件，进行操作。&lt;/p&gt;
&lt;div&gt;&lt;span class=&quot;a-image&quot;&gt;&lt;span class=&quot;a-image&quot;&gt;&lt;img src=&quot;https://i1.go2yd.com/image.php?url=0LOyG0d2BJ&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;
&lt;p&gt;&lt;em&gt;cron 任务&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;在这一层中，有一个身上写着 217 的小企鹅，他正满头大汗地看着自己的手表。这只小企鹅就是定时任务（&lt;a href=&quot;https://mb.yidianzixun.com/channel/w/crontab&quot;&gt;Crontab&lt;/a&gt;），他会时刻关注时间，查看是否要去做某个工作。&lt;/p&gt;
&lt;div&gt;&lt;span class=&quot;a-image&quot;&gt;&lt;span class=&quot;a-image&quot;&gt;&lt;img src=&quot;https://i1.go2yd.com/image.php?url=0LOyG0me1k&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;
&lt;p&gt;&lt;em&gt;管道&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;在图片的中部，有两个小企鹅扛着管道（&lt;a href=&quot;https://mb.yidianzixun.com/channel/w/pipeline&quot;&gt;PipeLine&lt;/a&gt;）在行走，一只小企鹅可以把自己手上的东西通过这个管道，传递给后面的小企鹅。不过怎么看起来前面这种（男？）企鹅累得满头大汗，而后面那只（女？）企鹅似乎游刃有余——喂喂，前面那个，裤子快掉了~&lt;/p&gt;
&lt;div&gt;&lt;span class=&quot;a-image&quot;&gt;&lt;span class=&quot;a-image&quot;&gt;&lt;img src=&quot;https://i1.go2yd.com/image.php?url=0LOyG0yq1V&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;
&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://mb.yidianzixun.com/channel/w/wine&quot;&gt;Wine&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;在这一层还有另外的一个小企鹅，它手上拿着一杯红酒，身上写着 411，看起来有点不胜酒力。它就是红酒（&lt;a href=&quot;https://mb.yidianzixun.com/channel/w/wine&quot;&gt;Wine&lt;/a&gt;）小企鹅,它可以干（执行）一些来自 Windows 的任务。&lt;/p&gt;
&lt;h2&gt;跃层&lt;/h2&gt;
&lt;p&gt;在一层之上，还有一个跃层，这里有很多不同的屏幕，每个屏幕上写着 TTY（这就是对外的终端）。比如说最左边 tty4 上输入了“fre”——这是想输入“freshmeat…”么 ：d ；它旁边的 tty2 和 tty3 就正常多了，看起来是比较正常的命令；tty7 显示的图形界面嗳，对，图形界面（X Window）一般就在 7 号终端；tty5 和 tty6 是空的，这表示这两个终端没人用。等等，tty1 呢？&lt;/p&gt;
&lt;div&gt;&lt;span class=&quot;a-image&quot;&gt;&lt;span class=&quot;a-image&quot;&gt;&lt;img src=&quot;https://i1.go2yd.com/image.php?url=0LOyG08k2u&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;
&lt;p&gt;&lt;em&gt;跃层&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;tty（终端）是对外沟通的渠道之一，但是，不是每一个进程都需要 tty，某些进程可以直接通过其他途径（比如端口）来和外部进行通信，对外提供服务的，所以，这一层不是完整的一层，只是个跃层。&lt;/p&gt;
&lt;p&gt;好了，我们有落下什么吗？&lt;/p&gt;
&lt;div&gt;&lt;span class=&quot;a-image&quot;&gt;&lt;span class=&quot;a-image&quot;&gt;&lt;img src=&quot;https://i1.go2yd.com/image.php?url=0LOyG0flqf&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;
&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://mb.yidianzixun.com/channel/w/%E5%B0%8F%E4%B8%91&quot;&gt;小丑&lt;/a&gt;？&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;这&lt;a href=&quot;https://mb.yidianzixun.com/channel/w/%E5%B0%8F%E4%B8%91&quot;&gt;小丑&lt;/a&gt;是谁啊？&lt;/p&gt;
&lt;p&gt;啊哈，我也不知道，或许是病毒&lt;/p&gt;
</description>
<pubDate>Sat, 09 Mar 2019 15:49:00 +0000</pubDate>
<dc:creator>|瑾诺学长|</dc:creator>
<og:description>今天，我来为大家解读一幅来自 TurnOff.us 的漫画 “InSide The Linux Kernel” 。 TurnOff.us 是一个极客漫画网站，作者Daniel St</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jin-nuo/p/10503774.html</dc:identifier>
</item>
</channel>
</rss>