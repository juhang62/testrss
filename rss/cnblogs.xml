<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>【CF1425H】Huge Boxes of Animal Toys 题解 - 喵乖乖喵</title>
<link>http://www.cnblogs.com/Qing-LKY/p/CF1425H-solutionH.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Qing-LKY/p/CF1425H-solutionH.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://codeforces.ml/problemset/problem/1425/H&quot;&gt;原题链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;题意简介：&lt;/p&gt;
&lt;p&gt;已知分别处在 &lt;span class=&quot;math inline&quot;&gt;\((-\infty,-1]\)&lt;/span&gt; H、&lt;span class=&quot;math inline&quot;&gt;\((-1,0)\)&lt;/span&gt; 、&lt;span class=&quot;math inline&quot;&gt;\((0,1)\)&lt;/span&gt; 、&lt;span class=&quot;math inline&quot;&gt;\([1,\infty)\)&lt;/span&gt; 的实数的数量(下记为集合 &lt;span class=&quot;math inline&quot;&gt;\(A,B,C,D\)&lt;/span&gt; )，试问：把这些数乘起来后，答案的可能出现在那个范围中？&lt;/p&gt;
&lt;p&gt;题解：&lt;/p&gt;
&lt;p&gt;首先，我们不难发现，如果负数的个数为奇数，那么答案必然在 &lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(B\)&lt;/span&gt; 中，否则，将出现在 &lt;span class=&quot;math inline&quot;&gt;\(C\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(D\)&lt;/span&gt; 中。&lt;/p&gt;
&lt;p&gt;确定了这一点后，我们将符号全部视为正，试着探索答案能否出现在 &lt;span class=&quot;math inline&quot;&gt;\(C\)&lt;/span&gt; 或 &lt;span class=&quot;math inline&quot;&gt;\(D\)&lt;/span&gt; 中。&lt;/p&gt;
&lt;p&gt;显然，由于我们可以给这些数随便赋一个范围内的值，那么我们只需要考虑极端情况即可。&lt;/p&gt;
&lt;p&gt;只要原本有一个数绝对值在 &lt;span class=&quot;math inline&quot;&gt;\(D\)&lt;/span&gt; 里，只要把这个数取到无限大，其它在 &lt;span class=&quot;math inline&quot;&gt;\(C\)&lt;/span&gt; 中的取无限接近于 &lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt; ，最终答案就会在 &lt;span class=&quot;math inline&quot;&gt;\(D\)&lt;/span&gt; 里。&lt;/p&gt;
&lt;p&gt;同理，只要原本有一个数绝对值在 &lt;span class=&quot;math inline&quot;&gt;\(C\)&lt;/span&gt; 里，只要把这个数取到无限趋近于 &lt;span class=&quot;math inline&quot;&gt;\(0\)&lt;/span&gt; ，其它在 &lt;span class=&quot;math inline&quot;&gt;\(D\)&lt;/span&gt; 中的取 &lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt; ，最终答案就会在 &lt;span class=&quot;math inline&quot;&gt;\(C\)&lt;/span&gt; 里。&lt;/p&gt;
&lt;p&gt;签到题之一。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;#include &amp;lt;cstdio&amp;gt;
int t,A,B,C,D;
inline void out(bool x){
    printf(x?&quot;Ya &quot;:&quot;Tidak &quot;);
}
int main(){
    scanf(&quot;%d&quot;,&amp;amp;t);
    while(t--){
        scanf(&quot;%d%d%d%d&quot;,&amp;amp;A,&amp;amp;B,&amp;amp;C,&amp;amp;D);
        if((A+B)&amp;amp;1){
            if(D||A) A=1,D=0;
            if(B||C) B=1,C=0;
        }else{
            if(D||A) A=0,D=1;
            if(B||C) B=0,C=1;
        }
        out(A); out(B); out(C); out(D);
        putchar('\n');
    }
    return 0;
}
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 01 Oct 2020 00:08:00 +0000</pubDate>
<dc:creator>喵乖乖喵</dc:creator>
<og:description>水 分类讨论 极端思维</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Qing-LKY/p/CF1425H-solutionH.html</dc:identifier>
</item>
<item>
<title>Spring AOP系列（五）—反射 - CleverZiv</title>
<link>http://www.cnblogs.com/cleverziv/p/13757132.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cleverziv/p/13757132.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;前面我们进行了代理模式、静态代理、动态代理的学习。而动态代理就是利用Java的反射技术(Java Reflection)，在运行时创建一个实现某些给定接口的新类（也称“动态代理类”）及其实例（对象）。所以接下来我们有必要学习一下Java中的反射。&lt;/p&gt;
&lt;h2 id=&quot;一、基础知识&quot;&gt;一、基础知识&lt;/h2&gt;
&lt;h3 id=&quot;11-反射是什么？&quot;&gt;1.1 反射是什么？&lt;/h3&gt;
&lt;p&gt;在讲反射之前，先提一个问题：假如现在有一个类&lt;code&gt;User&lt;/code&gt;，我想创建一个&lt;code&gt;User&lt;/code&gt;对象并且获取到其&lt;code&gt;name&lt;/code&gt;属性，我该怎么做呢？&lt;br/&gt;&lt;code&gt;User.java&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.reflect;

/**
 * @author: create by lengzefu
 * @description: com.reflect
 * @date:2020-09-29
 */
public class User {
    private String name = &quot;小明&quot;;
    
    Integer age = 18;
    
    public User(){
        
    }
    
    public User(String name, Integer age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;方式很简单：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;import com.reflect.User;

public class Main {

    public static void main(String[] args) {
        User user = new User();
        System.out.println(user.getName());
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种方式是我们日常在写代码时经常用到的一种方式。这是因为我们在使用某个对象时，总是&lt;strong&gt;预先&lt;/strong&gt;知道自己需要使用到哪个类，因此可以使用直接 new 的方式获取类的对象，进而调用类的方法。&lt;br/&gt;那假设我们预先并不知道自己要使用的类是什么呢？这种场景其实很常见，比如动态代理，我们事先并不知道代理类是什么，代理类是在运行时才生成的。这种情况我们就要用到今天的主角：&lt;strong&gt;反射&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;111-反射的定义&quot;&gt;1.1.1 反射的定义&lt;/h4&gt;
&lt;p&gt;JAVA反射机制是指在&lt;span&gt;&lt;strong&gt;运行状态&lt;/strong&gt;&lt;/span&gt;中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。&lt;br/&gt;注意：这里特别强调的是&lt;span&gt;&lt;strong&gt;运行状态&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;h3 id=&quot;12-反射能做什么？&quot;&gt;1.2 反射能做什么？&lt;/h3&gt;
&lt;p&gt;定义已经给了我们答案。反射可以使得程序在运行时可以获取到任意类的任意属性和方法并调用。&lt;/p&gt;
&lt;h3 id=&quot;13-反射为什么能做到？&quot;&gt;1.3 反射为什么能做到？&lt;/h3&gt;
&lt;p&gt;这里我们需要讲一个“类对象”的概念。java中“面向对象”的理念贯彻的比较彻底，它强调“万事万物皆对象”。那么“类”是不是也可以认为是一个对象呢？java中有一种特殊的类：&lt;code&gt;Class&lt;/code&gt;，它的对象是“类”，比如“String”类，“Thread”类都是它的对象。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;java.lang.Class是访问类型元数据的接口，也是实现反射的关键数据。通过Class提供的接口，可以访问一个类型的方法、字段等信息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以上已经解答了“反射为什么能做到可以使得程序在运行时可以获取到任意类的任意属性和方法并调用”的问题，它是依赖.class字节码文件做到的。那么首先我们需要解决的问题是如何获取字节码文件对象（Class对象）。&lt;/p&gt;
&lt;h4 id=&quot;131-获取class对象&quot;&gt;1.3.1 获取Class对象&lt;/h4&gt;
&lt;p&gt;对于一个类，如上文的&lt;code&gt;User&lt;/code&gt;，我想获取&lt;code&gt;User&lt;/code&gt;的相关信息（由于&lt;code&gt;Users&lt;/code&gt;属于&lt;code&gt;Class&lt;/code&gt;类的对象，所以一般称该行为为“获取类对象”），该怎么做呢？&lt;br/&gt;有以下三种方式&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;import com.reflect.User;

public class Main {

    public static void main(String[] args) throws ClassNotFoundException {
        // 1.已实例化的对象可调用 getClass() 方法来获取,通常应用在：传过来一个 Object类型的对象，不知道具体是什么类，用这种方法
        User user = new User();
        Class clz1 = user.getClass();

        // 2.类名.class 的方式得到,该方法最为安全可靠，程序性能更高，这说明任何一个类都有一个隐含的静态成员变量 class
        Class clz2 = User.class;

        // 通过类的全路径名获取Class对象，用的最多，如果根据类路径找不到这个类那么就会抛出 ClassNotFoundException异常。
        Class clz3 = Class.forName(&quot;com.reflect.User&quot;);

        // 一个类在 JVM 中只会有一个 Class 实例,即我们对上面获取的 clz1,clz2,clz3进行 equals 比较，发现都是true。
        System.out.println(clz1.equals(clz2));
        System.out.println(clz2.equals(clz3));
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;132-class-api&quot;&gt;1.3.2 Class API&lt;/h4&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;获取公共构造器 getConstructors()&lt;br/&gt;获取所有构造器 getDeclaredConstructors()&lt;br/&gt;获取该类对象 newInstance()&lt;br/&gt;获取类名包含包路径 getName()&lt;br/&gt;获取类名不包含包路径 getSimpleName()&lt;br/&gt;获取类公共类型的所有属性 getFields()&lt;br/&gt;获取类的所有属性　getDeclaredFields()&lt;br/&gt;获取类公共类型的指定属性 getField(String name)&lt;br/&gt;获取类全部类型的指定属性 getDeclaredField(String name)&lt;br/&gt;获取类公共类型的方法 getMethods()&lt;br/&gt;获取类的所有方法 getDeclaredMethods()&lt;br/&gt;获得类的特定公共类型方法: getMethod(String name, Class[] parameterTypes)&lt;br/&gt;获取内部类 getDeclaredClasses()&lt;br/&gt;获取外部类 getDeclaringClass()&lt;br/&gt;获取修饰符 getModifiers()&lt;br/&gt;获取所在包 getPackage()&lt;br/&gt;获取所实现的接口 getInterfaces()&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;具体如何使用不再赘述&lt;/p&gt;
&lt;h2 id=&quot;二、反射原理解析&quot;&gt;二、反射原理解析&lt;/h2&gt;
&lt;h3 id=&quot;21-反射与类加载的关系&quot;&gt;2.1 反射与类加载的关系&lt;/h3&gt;
&lt;p&gt;java类的执行需要经历以下过程，&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;编译&lt;/strong&gt;：java文件编译后生成.class字节码文件&lt;br/&gt;&lt;strong&gt;加载&lt;/strong&gt;：类加载器负责根据一个类的全限定名来读取此类的二进制字节流到 JVM 内部，并存储在运行时内存区的方法区，然后将其转换为一个与目标类型对应的 java.lang.Class 对象实例&lt;br/&gt;&lt;strong&gt;链接&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;验证：格式（class文件规范） 语义（final类是否有子类） 操作&lt;/li&gt;
&lt;li&gt;准备：静态变量赋初值和内存空间，final修饰的内存空间直接赋原值，此处不是用户指定的初值。&lt;/li&gt;
&lt;li&gt;解析：符号引用转化为直接引用，分配地址&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;初始化&lt;/strong&gt;：有父类先初始化父类，然后初始化自己；将static修饰代码执行一遍，如果是静态变量，则用用户指定值覆盖原有初值；如果是代码块，则执行一遍操作。&lt;/p&gt;
&lt;p&gt;Java的反射就是利用上面&lt;span&gt;第二步加载到jvm中的.class文件来进行操作的。.&lt;/span&gt;第二步加载到jvm中的.class文件来进行操作的。.class文件中包含java类的所有信息，当你不知道某个类具体信息时，可以使用反射获取class，然后进行各种操作。&lt;/p&gt;
&lt;p&gt;首先我们来看看如何使用反射来实现方法的调用的：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Main {
    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {
        // 1.获取类对象
        Class clz3 = Class.forName(&quot;com.reflect.User&quot;);
        // 2.获取类的构造函数
        Constructor constructor = clz3.getConstructor(String.class, Integer.class);
        // 3.创建一个对象
        User user = (User)constructor.newInstance(&quot;璐璐&quot;, 17);
        // 4.获取方法getName
        Method method = clz3.getMethod(&quot;getName&quot;);
        // 5.调用该方法
        String name = (String) method.invoke(user);

        System.out.println(name);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来主要解析4，5两个过程：获取Method对象和Methode.invoke&lt;/p&gt;
&lt;h3 id=&quot;22-获取-method-对象&quot;&gt;2.2 获取 Method 对象&lt;/h3&gt;
&lt;h4 id=&quot;221-获取-method-的api介绍&quot;&gt;2.2.1 获取 Method 的API介绍&lt;/h4&gt;
&lt;p&gt;Class API中关于获取Method对象的方法有如下几个：&lt;br/&gt;&lt;code&gt;getMethod/getMethods&lt;/code&gt; 和 &lt;code&gt;getDeclaredMethod/getDeclaredMethod&lt;/code&gt;&lt;br/&gt;&lt;strong&gt;后缀有无“s”的区别&lt;/strong&gt;&lt;br/&gt;有“s”表示获取的所有的，无“s”表示获取的是特定的（由方法参数指定）。&lt;br/&gt;&lt;strong&gt;&lt;code&gt;getMethod&lt;/code&gt;和&lt;code&gt;getDeclaredMethod&lt;/code&gt;的区别&lt;/strong&gt;&lt;br/&gt;Method对应的是&lt;code&gt;Member.PUBLIC&lt;/code&gt;，DeclaredMethod对应的是&lt;code&gt;Member.DECLARED&lt;/code&gt;&lt;br/&gt;两者定义如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public
interface Member {

    /**
     * Identifies the set of all public members of a class or interface,
     * including inherited members.
     * 标识类或接口的所有公共成员的集合，包括父类的公共成员。
     */
    public static final int PUBLIC = 0;

    /**
     * Identifies the set of declared members of a class or interface.
     * Inherited members are not included.
     * 标识类或接口所有声明的成员的集合（public、protected,private），但是不包括父类成员
     */
    public static final int DECLARED = 1;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实不管是&lt;code&gt;getMethod&lt;/code&gt;还是&lt;code&gt;getDeclaredMethod&lt;/code&gt;，底层都调用了同一个方法：&lt;code&gt;privateGetDeclaredMethods&lt;/code&gt;，因此我们只分析其中一个方法即可。&lt;/p&gt;
&lt;h4 id=&quot;222-getmethod-方法源码分析&quot;&gt;2.2.2 getMethod 方法源码分析&lt;/h4&gt;
&lt;h5 id=&quot;seq1&quot;&gt;seq1&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 4.获取方法getName
Method method = clz3.getMethod(&quot;getName&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;客户端调用Class.getMethod()方法。&lt;/p&gt;
&lt;h5 id=&quot;seq2&quot;&gt;seq2&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;       // 参数“name”为方法名，参数“parameterTypes”为方法的参数，由于参数可能有多个且类型不同，所以这里使用到了泛型及可变参数的设定
    public Method getMethod(String name, Class&amp;lt;?&amp;gt;... parameterTypes)
        throws NoSuchMethodException, SecurityException {
        // 权限安全检查，无权限则抛出 SecurityException
        checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), true);
        Method method = getMethod0(name, parameterTypes, true);
        // 获取到的method为空，抛出 NoSuchMethodException 异常
        if (method == null) {
            throw new NoSuchMethodException(getName() + &quot;.&quot; + name + argumentTypesToString(parameterTypes));
        }
        return method;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该方法的核心方法是 &lt;code&gt;getMethod0&lt;/code&gt;。&lt;/p&gt;
&lt;h5 id=&quot;seq3&quot;&gt;seq3&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private Method getMethod0(String name, Class&amp;lt;?&amp;gt;[] parameterTypes, boolean includeStaticMethods) {
                // 保存接口中的方法，最多只有1个，但MethodArray初始化大小至少为2
        MethodArray interfaceCandidates = new MethodArray(2);
        // 递归获取方法，之所以递归，正是因为getMethod是需要获取父类中的方法，与前面关于getMethod的介绍对应
        Method res =  privateGetMethodRecursive(name, parameterTypes, includeStaticMethods, interfaceCandidates);
        // 获取到本类或父类中的方法，直接返回结果
        if (res != null)
            return res;

        // Not found on class or superclass directly
        // 在本类或父类中没有找到对应的方法，则尝试去接口中的方法寻找
        // removeLessSpecifics：移除更不具体的方法，保留具有更具体实现的方法
        interfaceCandidates.removeLessSpecifics();
        return interfaceCandidates.getFirst(); // may be null
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来分析&lt;code&gt;privateGetMethodRecursive&lt;/code&gt;&lt;/p&gt;
&lt;h5 id=&quot;seq4&quot;&gt;seq4&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt; private Method privateGetMethodRecursive(String name,
            Class&amp;lt;?&amp;gt;[] parameterTypes,
            boolean includeStaticMethods,
            MethodArray allInterfaceCandidates) {
        // Must _not_ return root methods
        Method res;
        // Search declared public methods 搜索本来中声明的公共方法
        if ((res = searchMethods(privateGetDeclaredMethods(true),
                                 name,
                                 parameterTypes)) != null) {
            if (includeStaticMethods || !Modifier.isStatic(res.getModifiers()))
            // res 不为空，返回
                return res;
        }
        // Search superclass's methods res为空，继续向父类搜索
        if (!isInterface()) { // 接口必然无父类
            Class&amp;lt;? super T&amp;gt; c = getSuperclass();
            if (c != null) {
                    // 递归调用getMethod0，获取父类的方法实现
                if ((res = c.getMethod0(name, parameterTypes, true)) != null) {
                    return res;
                }
            }
        }
        // Search superinterfaces' methods res仍然为空，继续向接口搜索
        Class&amp;lt;?&amp;gt;[] interfaces = getInterfaces();
        for (Class&amp;lt;?&amp;gt; c : interfaces)
                    // 递归调用getMethod0，获取接口的方法实现
            if ((res = c.getMethod0(name, parameterTypes, false)) != null)
                allInterfaceCandidates.add(res);
        // Not found
        return null;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该方法原英文注释翻译之后的大概意思为：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;注意：该例程（作用类似于函数，含义比函数更广）使用的搜索算法的目的是等效于&lt;code&gt;privateGetPublicMethods&lt;/code&gt;方法的施加顺序。它仅获取每个类的已声明公共方法，但是，以减少在要查询的类中声明了所请求方法，常见情况下必须创建的Method对象的数量。 由于使用默认方法，除非在超类上找到方法，否则需要考虑在任何超级接口中声明的方法。 收集所有InterfaceCandidates的超级接口中声明的所有候选对象，如果未在超类上找到匹配项，则选择最具体的候选者。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;原文的英语注释中各种从句真的很多，自己翻译完感觉还是有点问题。简单来说，我觉得比较重要的一点应该是还是能理解到：&lt;br/&gt;&lt;span&gt;获取该类已声明的方法，如果使用的是默认方法，则从父类中寻找该方法。否则去接口中寻找实现最具体的候选方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;接下来分析&lt;code&gt;searchMethods&lt;/code&gt;&lt;/p&gt;
&lt;h5 id=&quot;seq5&quot;&gt;seq5&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    private static Method searchMethods(Method[] methods,
                                        String name,
                                        Class&amp;lt;?&amp;gt;[] parameterTypes)
    {
        Method res = null;
        String internedName = name.intern();
        for (int i = 0; i &amp;lt; methods.length; i++) {
            Method m = methods[i];
            if (m.getName() == internedName // 比较方法名字
                    // 比较方法参数
                &amp;amp;&amp;amp; arrayContentsEq(parameterTypes, m.getParameterTypes())
                // 比较方法返回值
                &amp;amp;&amp;amp; (res == null
                    || res.getReturnType().isAssignableFrom(m.getReturnType())))
                res = m;
        }

        return (res == null ? res : getReflectionFactory().copyMethod(res));
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;searchMethods&lt;/code&gt;的实现逻辑比较简单，详细如注释。这里关键是方法参数&lt;code&gt;Method[] methods&lt;/code&gt;是怎么得到的，我们回到&lt;code&gt;searchMethods&lt;/code&gt;的方法调用处：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;searchMethods(privateGetDeclaredMethods(true),
                                 name,
                                 parameterTypes)) != null)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;methods&lt;/code&gt;通过方法&lt;code&gt;privateGetDeclaredMethods(true)&lt;/code&gt;得到&lt;/p&gt;
&lt;h5 id=&quot;seq6&quot;&gt;seq6&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private Method[] privateGetDeclaredMethods(boolean publicOnly) {
        checkInitted();
        Method[] res;
        // 1.ReflectionData 存储反射数据的缓存结构
        ReflectionData&amp;lt;T&amp;gt; rd = reflectionData();
        if (rd != null) {
                // 2.先从缓存中获取methods
            res = publicOnly ? rd.declaredPublicMethods : rd.declaredMethods;
            if (res != null) return res;
        }
        // No cached value available; request value from VM
        // 3.没有缓存，通过 JVM 获取
        res = Reflection.filterMethods(this, getDeclaredMethods0(publicOnly));
        if (rd != null) {
            if (publicOnly) {
                rd.declaredPublicMethods = res;
            } else {
                rd.declaredMethods = res;
            }
        }
        return res;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;先看看&lt;code&gt;ReflectionData&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt; // reflection data that might get invalidated when JVM TI RedefineClasses() is called
    private static class ReflectionData&amp;lt;T&amp;gt; {
        volatile Field[] declaredFields;
        volatile Field[] publicFields;
        volatile Method[] declaredMethods;
        volatile Method[] publicMethods;
        volatile Constructor&amp;lt;T&amp;gt;[] declaredConstructors;
        volatile Constructor&amp;lt;T&amp;gt;[] publicConstructors;
        // Intermediate results for getFields and getMethods
        volatile Field[] declaredPublicFields;
        volatile Method[] declaredPublicMethods;
        volatile Class&amp;lt;?&amp;gt;[] interfaces;

        // Value of classRedefinedCount when we created this ReflectionData instance
        final int redefinedCount;

        ReflectionData(int redefinedCount) {
            this.redefinedCount = redefinedCount;
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ReflectionData&amp;lt;T&amp;gt;&lt;/code&gt;是类&lt;code&gt;Class&lt;/code&gt;的静态内部类，&lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt;表示泛型，为具体的类对象。该缓存数据结构中存储了类的所有信息。&lt;code&gt;redefinedCount&lt;/code&gt;是类的重定义次数，可以理解为缓存的版本号。&lt;br/&gt;注意最上面的一行注释：reflection data that might get invalidated when JVM TI RedefineClasses() is called。意思是 当 JVM TI（工具接口）&lt;code&gt;RedefineClasses()&lt;/code&gt;被调用时，缓存数据可能会失效。&lt;/p&gt;
&lt;p&gt;通过以上分析，我们知道，每一个类对象理论上都会有（被垃圾回收或从来没被加载过就没没有）一个&lt;code&gt;ReflectionData&amp;lt;T&amp;gt;&lt;/code&gt;的缓存，那么如何获取它呢？&lt;/p&gt;
&lt;p&gt;这就要用到 &lt;code&gt;reflectionData&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    // Lazily create and cache ReflectionData
    private ReflectionData&amp;lt;T&amp;gt; reflectionData() {
            // 获取当前 reflectionData 缓存
        SoftReference&amp;lt;ReflectionData&amp;lt;T&amp;gt;&amp;gt; reflectionData = this.reflectionData;
        // 当前缓存版本号
        int classRedefinedCount = this.classRedefinedCount;
        ReflectionData&amp;lt;T&amp;gt; rd;
        // 可以使用缓存&amp;amp;&amp;amp;缓存不为空&amp;amp;&amp;amp;缓存中版本号与类中记录的版本号一致则直接返回缓存
        if (useCaches &amp;amp;&amp;amp;
            reflectionData != null &amp;amp;&amp;amp;
            (rd = reflectionData.get()) != null &amp;amp;&amp;amp;
            rd.redefinedCount == classRedefinedCount) {
            return rd;
        }
        // else no SoftReference or cleared SoftReference or stale ReflectionData
        // -&amp;gt; create and replace new instance
        // 创建新的缓存数据
        return newReflectionData(reflectionData, classRedefinedCount);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看看&lt;code&gt;newReflectionData&lt;/code&gt;的实现&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    private ReflectionData&amp;lt;T&amp;gt; newReflectionData(SoftReference&amp;lt;ReflectionData&amp;lt;T&amp;gt;&amp;gt; oldReflectionData,
                                                int classRedefinedCount) {
        // 不使用缓存则直接返回null
        if (!useCaches) return null;

                // 使用while+CAS方式更新数据，创建一个新的ReflectionData，如果更新成功直接返回
        while (true) {
            ReflectionData&amp;lt;T&amp;gt; rd = new ReflectionData&amp;lt;&amp;gt;(classRedefinedCount);
            // try to CAS it...
            if (Atomic.casReflectionData(this, oldReflectionData, new SoftReference&amp;lt;&amp;gt;(rd))) {
                return rd;
            }
            // else retry
            // 获取到旧的reflectionData和classRedefinedCount的值，如果旧的值不为null, 并且缓存未失效，说明其他线程更新成功了，直接返回 
            oldReflectionData = this.reflectionData;
            classRedefinedCount = this.classRedefinedCount;
            if (oldReflectionData != null &amp;amp;&amp;amp;
                (rd = oldReflectionData.get()) != null &amp;amp;&amp;amp;
                rd.redefinedCount == classRedefinedCount) {
                return rd;
            }
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在我们回到&lt;code&gt;privateGetDeclaredMethods&lt;/code&gt;方法的实现，对于第3步：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;  // 3.没有缓存，通过 JVM 获取
        res = Reflection.filterMethods(this, getDeclaredMethods0(publicOnly));
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用的是native方法，此处不再赘述。&lt;br/&gt;在获取到对应方法以后，并不会直接返回，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt; return (res == null ? res : getReflectionFactory().copyMethod(res));
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;seq7&quot;&gt;seq7&lt;/h5&gt;
&lt;p&gt;通过单步调试可发现&lt;code&gt;getReflectionFactory().copyMethod(res)&lt;/code&gt;最终调用的是&lt;code&gt;Method#copy&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    Method copy() {
            // 1.该对象的root为null时，表明是 基本方法对象
        if (this.root != null)
                // 2.只能拷贝基本方法对象即root为null的对象
            throw new IllegalArgumentException(&quot;Can not copy a non-root Method&quot;);
                // 3.新建一个与基本方法对象具有相同性质的方法对象
        Method res = new Method(clazz, name, parameterTypes, returnType,
                                exceptionTypes, modifiers, slot, signature,
                                annotations, parameterAnnotations, annotationDefault);
        // 4.res作为this的拷贝，其root属性必须指向this
        res.root = this;
        // Might as well eagerly propagate this if already present
        // 5.所有的Method的拷贝都会使用同一份methodAccessor
        res.methodAccessor = methodAccessor;
        return res;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意以下几点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;root 属性&lt;/strong&gt;：可以理解为每一个 java方法都有唯一的一个Method对象，这个对象就是root，它相当于根对象，对用户不可见。这个root是不会暴露给用户的，当我们通过反射获取Method对象时，新创建Method对象把root包装起来再给用户，我们代码中获得的Method对象都相当于它的副本（或引用）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;methodAccessor&lt;/strong&gt;：root 对象持有一个 MethodAccessor 对象，所以所有获取到的 Method对象都共享这一个 MethodAccessor 对象，因此必须保证它在内存中的可见性。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;res.root = this&lt;/code&gt;：res 作为 this 的拷贝，其 root 属性必须指向 this。&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;小结&quot;&gt;小结&lt;/h5&gt;
&lt;p&gt;getMethod方法时序图&lt;br/&gt;&lt;img src=&quot;https://myblog-1258060977.cos.ap-beijing.myqcloud.com/cnblog/JVM/getMethod%E6%97%B6%E5%BA%8F%E5%9B%BE.png&quot; alt=&quot;Alt&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;23-methodinvoke&quot;&gt;2.3 Method.invoke&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    public Object invoke(Object obj, Object... args)
        throws IllegalAccessException, IllegalArgumentException,
           InvocationTargetException
    {
        if (!override) {
                // 1.检查权限
            if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) {
                Class&amp;lt;?&amp;gt; caller = Reflection.getCallerClass();
                checkAccess(caller, clazz, obj, modifiers);
            }
        }
        // 2.获取 MethodAccessor
        MethodAccessor ma = methodAccessor;             // read volatile
        if (ma == null) {
                // 2.1为空时创建MethodAccessor
            ma = acquireMethodAccessor();
        }
        // 3.调用 MethodAccessor.invoke
        return ma.invoke(obj, args);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;231-检查权限&quot;&gt;2.3.1 检查权限&lt;/h4&gt;
&lt;p&gt;这里对 override 变量进行判断，如果 override == true，就跳过检查 我们通常在 Method#invoke 之前，会调用 Method#setAccessible(true)，就是设置 override 值为 true。&lt;/p&gt;
&lt;h4 id=&quot;232-获取-methodaccessor&quot;&gt;2.3.2 获取 MethodAccessor&lt;/h4&gt;
&lt;p&gt;在上面获取 Method 的时候我们讲到过，Method#copy 会给 Method 的 methodAccessor 赋值。所以这里的 methodAccessor 就是拷贝时使用的 MethodAccessor。如果 ma 为空，就去创建 MethodAccessor。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    /*
     注意这里没有使用synchronization。 为给定方法生成一个以上的MethodAccessor是正确的（尽管效率不高）。 但是，避免同步可能会使实现更具可伸缩性。
     */
    private MethodAccessor acquireMethodAccessor() {
        // First check to see if one has been created yet, and take it
        // if so
        MethodAccessor tmp = null;
        if (root != null) tmp = root.getMethodAccessor();
        if (tmp != null) {
            methodAccessor = tmp;
        } else {
            // Otherwise fabricate one and propagate it up to the root
            tmp = reflectionFactory.newMethodAccessor(this);
            setMethodAccessor(tmp);
        }

        return tmp;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里会先查找 root 的 MethodAccessor，这里的 root 在上面 Method#copy 中设置过。如果还是没有找到，就去创建 MethodAccessor。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;class ReflectionFactory {
    public MethodAccessor newMethodAccessor(Method method) {
        // 其中会对 noInflation 进行赋值
        checkInitted();
        // ...
        if (noInflation &amp;amp;&amp;amp; !ReflectUtil.isVMAnonymousClass(method.getDeclaringClass())) {
            // 生成的是 MethodAccessorImpl
            return new MethodAccessorGenerator().
                generateMethod(method.getDeclaringClass(),
                               method.getName(),
                               method.getParameterTypes(),
                               method.getReturnType(),
                               method.getExceptionTypes(),
                               method.getModifiers());
        } else {
            NativeMethodAccessorImpl acc =
                new NativeMethodAccessorImpl(method);
            DelegatingMethodAccessorImpl res =
                new DelegatingMethodAccessorImpl(acc);
            acc.setParent(res);
            return res;
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里可以看到，一共有三种 MethodAccessor。MethodAccessorImpl，NativeMethodAccessorImpl，DelegatingMethodAccessorImpl。采用哪种 MethodAccessor 根据 noInflation 进行判断，noInflation 默认值为 false，只有指定了 sun.reflect.noInflation 属性为 true，才会 采用 MethodAccessorImpl。所以默认会调用 NativeMethodAccessorImpl。&lt;/p&gt;
&lt;p&gt;MethodAccessorImpl 是通过动态生成字节码来进行方法调用的，是 Java 版本的 MethodAccessor，字节码生成比较复杂，这里不放代码了。大家感兴趣可以看这里的 generate 方法。&lt;/p&gt;
&lt;p&gt;DelegatingMethodAccessorImpl 就是单纯的代理，真正的实现还是 NativeMethodAccessorImpl。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;class DelegatingMethodAccessorImpl extends MethodAccessorImpl {
    private MethodAccessorImpl delegate;
 
    DelegatingMethodAccessorImpl(MethodAccessorImpl delegate) {
        setDelegate(delegate);
    }
 
    public Object invoke(Object obj, Object[] args)
        throws IllegalArgumentException, InvocationTargetException
    {
        return delegate.invoke(obj, args);
    }
 
    void setDelegate(MethodAccessorImpl delegate) {
        this.delegate = delegate;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;NativeMethodAccessorImpl 是 Native 版本的 MethodAccessor 实现。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;class NativeMethodAccessorImpl extends MethodAccessorImpl {
    public Object invoke(Object obj, Object[] args)
        throws IllegalArgumentException, InvocationTargetException
    {
        // We can't inflate methods belonging to vm-anonymous classes because
        // that kind of class can't be referred to by name, hence can't be
        // found from the generated bytecode.
        if (++numInvocations &amp;gt; ReflectionFactory.inflationThreshold()
                &amp;amp;&amp;amp; !ReflectUtil.isVMAnonymousClass(method.getDeclaringClass())) {
            // Java 版本的 MethodAccessor
            MethodAccessorImpl acc = (MethodAccessorImpl)
                new MethodAccessorGenerator().
                    generateMethod(method.getDeclaringClass(),
                                   method.getName(),
                                   method.getParameterTypes(),
                                   method.getReturnType(),
                                   method.getExceptionTypes(),
                                   method.getModifiers());
            parent.setDelegate(acc);
        }
        // Native 版本调用
        return invoke0(method, obj, args);
    }
 
    private static native Object invoke0(Method m, Object obj, Object[] args);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 NativeMethodAccessorImpl 的实现中，我们可以看到，有一个 numInvocations 阀值控制，numInvocations 表示调用次数。如果 numInvocations 大于 15（默认阀值是 15），那么就使用 Java 版本的 MethodAccessorImpl。&lt;br/&gt;为什么采用这个策略呢，可以 JDK 中的注释：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;pre&gt;
&lt;code&gt;// &quot;Inflation&quot; mechanism. Loading bytecodes to implement
&lt;/code&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;// Method.invoke() and Constructor.newInstance() currently costs
// 3-4x more than an invocation via native code for the first
// invocation (though subsequent invocations have been benchmarked
// to be over 20x faster). Unfortunately this cost increases
// startup time for certain applications that use reflection
// intensively (but only once per class) to bootstrap themselves.
// To avoid this penalty we reuse the existing JVM entry points
// for the first few invocations of Methods and Constructors and
// then switch to the bytecode-based implementations.
//
// Package-private to be accessible to NativeMethodAccessorImpl
// and NativeConstructorAccessorImpl
private static boolean noInflation        = false;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Java 版本的 MethodAccessorImpl 调用效率比 Native 版本要快 20 倍以上，但是 Java 版本加载时要比 Native 多消耗 3-4 倍资源，所以默认会调用 Native 版本，如果调用次数超过 15 次以后，就会选择运行效率更高的 Java 版本。那为什么 Native 版本运行效率会没有 Java 版本高呢？从 R 大博客来看，是因为 这是HotSpot的优化方式带来的性能特性，同时也是许多虚拟机的共同点：跨越native边界会对优化有阻碍作用，它就像个黑箱一样让虚拟机难以分析也将其内联，于是运行时间长了之后反而是托管版本的代码更快些。&lt;/p&gt;
&lt;h4 id=&quot;233-调用-methodaccessorinvoke-实现方法的调用&quot;&gt;2.3.3 调用 MethodAccessor#invoke 实现方法的调用&lt;/h4&gt;
&lt;p&gt;在生成 MethodAccessor 以后，就调用其 invoke 方法进行最终的反射调用。这里我们对 Java 版本的 MethodAccessorImpl 做个简单的分析，Native 版本暂时不做分析。在前面我们提到过 MethodAccessorImpl 是通过 MethodAccessorGenerator#generate 生成动态字节码然后动态加载到 JVM 中的。&lt;br/&gt;到此，基本上 Java 方法反射的原理就介绍完了。&lt;/p&gt;
&lt;h2 id=&quot;三、反射为什么慢？&quot;&gt;三、反射为什么慢？&lt;/h2&gt;
&lt;h3 id=&quot;31-为什么慢？&quot;&gt;3.1 为什么慢？&lt;/h3&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Java实现的版本在初始化时需要较多时间，但长久来说性能较好；native版本正好相反，启动时相对较快，但运行时间长了之后速度就比不过Java版了。这是HotSpot的优化方式带来的性能特性，同时也是许多虚拟机的共同点：跨越native边界会对优化有阻碍作用，它就像个黑箱一样让虚拟机难以分析也将其内联，于是运行时间长了之后反而是托管版本的代码更快些。 为了权衡两个版本的性能，Sun的JDK使用了“inflation”的技巧：让Java方法在被反射调用时，开头若干次使用native版，等反射调用次数超过阈值时则生成一个专用的MethodAccessor实现类，生成其中的invoke()方法的字节码，以后对该Java方法的反射调用就会使用Java版。 当该反射调用成为热点时，它甚至可以被内联到靠近Method.invoke()的一侧，大大降低了反射调用的开销。而native版的反射调用则无法被有效内联，因而调用开销无法随程序的运行而降低。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;总结来说，原因如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;jit 无法优化反射&lt;/strong&gt; 。 JIT编译器无法对反射有效做优化，引用一段java doc中的解释：&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;由于反射涉及动态解析的类型，导致无法执行某些Java虚拟机优化。所以，反射操作的性能比非反射操作慢，因此应避免在对性能敏感的应用程序中使用反射&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;&lt;strong&gt;参数的封装/解封和方法的校验&lt;/strong&gt;。invoke方法是传Object类型的，如果是简单类型如long，在接口处必须封装成object，从而生成大量的Long的Object，导致了额外的不必要的内存浪费，甚至有可能导致GC；需要进行参数校验和方法的可见性校验。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;难以内联&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;32-反射慢为什么还要用它？&quot;&gt;3.2 反射慢为什么还要用它？&lt;/h3&gt;
&lt;p&gt;反射这种技术被广泛应用于框架的设计中，但反射的确带来了一定的性能损耗，既然如此为什么还要用反射呢？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;绝大部分系统的性能瓶颈还远远没有到需要考虑反射这里，逻辑层和数据层上的优化对性能的提升比优化反射高n个数量级。&lt;/li&gt;
&lt;li&gt;框架的设计是性能、标准和开发效率等多个方面的权衡。&lt;/li&gt;
&lt;li&gt;反射多少会有性能损耗，但一般可以忽略，而java对javabean方面的反射支持，java底层都有PropertyDescriptor和MethodDescriptor支持，可以一定程度的减少反射消耗。 AOP方面，cglib是通过类的字节码生成其子类去操作的，一旦子类生成就是纯粹的反射调用，不再操作字节码了，而一般AOP调用是在单例上，不会频繁的去用cglib生成子类。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;关于反射性能的具体测试数据，可参考：&lt;a href=&quot;https://www.jianshu.com/p/4e2b49fa8ba1&quot;&gt;https://www.jianshu.com/p/4e2b49fa8ba1&lt;/a&gt;&lt;br/&gt;其实通过以上数据可以看出，当量非常大的时候，反射确实是会影响性能。但一般的应用，即使不借助高性能工具包也不会是程序掣肘。当然，这也不是意味着可以随意使用，还是要结合实际的应用来。&lt;/p&gt;
&lt;h2 id=&quot;四、反射优缺点&quot;&gt;四、反射优缺点&lt;/h2&gt;
&lt;h3 id=&quot;41-反射的优点&quot;&gt;4.1 反射的优点&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;赋予程序在运行时可以操作对象的能力。&lt;/li&gt;
&lt;li&gt;解耦，提高程序的可扩展性。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;42-反射的缺点&quot;&gt;4.2 反射的缺点&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;**&lt;em&gt;性能开销&lt;/em&gt;&lt;br/&gt;反射涉及类型动态解析，所以JVM无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。我们应该避免在经常被执行的代码或对性能要求很高的程序中使用反射。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;安全限制&lt;/strong&gt;&lt;br/&gt;使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如Applet，那么这就是个问题了。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内部曝光&lt;/strong&gt;&lt;br/&gt;由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用－－代码有功能上的错误，降低可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;43-原则&quot;&gt;4.3 原则&lt;/h3&gt;
&lt;p&gt;如果使用常规方法能够实现，那么就不要用反射。&lt;/p&gt;
&lt;h2 id=&quot;五、参考文献&quot;&gt;五、参考文献&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/607ff4e79a13&quot;&gt;https://www.jianshu.com/p/607ff4e79a13&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/chanshuyi/p/head_first_of_reflection.html&quot;&gt;https://www.cnblogs.com/chanshuyi/p/head_first_of_reflection.html&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/zhenghongcs/article/details/103143144&quot;&gt;https://blog.csdn.net/zhenghongcs/article/details/103143144&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 30 Sep 2020 19:34:00 +0000</pubDate>
<dc:creator>CleverZiv</dc:creator>
<og:description>前言 前面我们进行了代理模式、静态代理、动态代理的学习。而动态代理就是利用Java的反射技术(Java Reflection)，在运行时创建一个实现某些给定接口的新类（也称“动态代理类”）及其实例（对</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cleverziv/p/13757132.html</dc:identifier>
</item>
<item>
<title>Laravel Event的分析和使用 - alwayslinger</title>
<link>http://www.cnblogs.com/alwayslinger/p/13756847.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/alwayslinger/p/13756847.html</guid>
<description>&lt;h3 id=&quot;laravel-event的分析和使用&quot;&gt;Laravel Event的分析和使用&lt;/h3&gt;
&lt;blockquote readability=&quot;6.3786982248521&quot;&gt;
&lt;p&gt;第一部分 概念解释 请自行查看&lt;a href=&quot;https://learnku.com/docs/php-design-patterns/2018/Observer/1513&quot;&gt;观察者模式&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;第二部分 源码分析 （逻辑较长，不喜欢追代码可以直接看使用部分）&lt;/p&gt;
&lt;p&gt;第三部分 使用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;第一部分-解释&quot;&gt;第一部分 解释&lt;/h4&gt;
&lt;blockquote readability=&quot;19&quot;&gt;
&lt;p&gt;当一个用户阅读了一篇文章，可能需要给文章增加点击量，给阅读的用户增加积分，给文章作者发送通知等功能。对于以上操作，&lt;/p&gt;
&lt;p&gt;我们可以使用laravel提供的事件机制进行良好的解耦。以上的用户阅读一篇文章，就是laravel中的一个事件，用户阅读文章后触&lt;/p&gt;
&lt;p&gt;发的一系列操作就是此事件的监听者，他们会被逐个执行。实际上laravel的事件服务是观察者模式的一个实现，&lt;/p&gt;
&lt;p&gt;触发了一个事件，就好象推倒了多米诺骨牌的地一块，剩下的操作就骄傲给提前摆好的阵型自行完成了。不同的是现实中我们很难让骨牌&lt;/p&gt;
&lt;p&gt;停止倒塌, 但在laravel中我们可以很方便的停止事件的传播，即终止监听者的调用链。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;第二部分-追源码&quot;&gt;第二部分 追源码&lt;/h4&gt;
&lt;h5 id=&quot;事件服务的注册&quot;&gt;事件服务的注册&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-php&quot;&gt;# laravel中每个服务，需要先注册再启动，其中注册是一定的，启动过程可以没有。事件服务也不例外。但事件服务的注册位置较为特殊，
# 位于Application.php
protected function registerBaseServiceProviders()
{       
    # 事件服务就是在此注册的
    # 注意application的register方法实际上调用了服务提供者的register方法
    $this-&amp;gt;register(new EventServiceProvider($this));
    $this-&amp;gt;register(new LogServiceProvider($this));
    $this-&amp;gt;register(new RoutingServiceProvider($this));
}

# 事件服务提供者 Illuminate\Events\EventServiceProvider
public function register()
{
    # 注意此处的singleton绑定 后面会使用到
    $this-&amp;gt;app-&amp;gt;singleton('events', function ($app) {
        // 绑定的是一个disaptcher实例 并为事件服务设置了队列解析器
        // 注意此闭包是在我们尝试从容器中解析事件服务的时候才会执行
        return (new Dispatcher($app))-&amp;gt;setQueueResolver(function () use ($app) {
            return $app-&amp;gt;make(QueueFactoryContract::class);
        });
    });
}

# 看Illuminate\Events\Dispatcher类
# 简单的构造方法
public function __construct(ContainerContract $container = null)
{
    $this-&amp;gt;container = $container ?: new Container;
}

# setQueueResolver方法 一个简单的set
public function setQueueResolver(callable $resolver)
{
    $this-&amp;gt;queueResolver = $resolver;

    return $this;
}

# 可以看到事件服务的注册实际上是向容器中注册了一个事件的分发器
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;事件服务的启动一（获取所有的事件和监听者）&quot;&gt;事件服务的启动一（获取所有的事件和监听者）&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-php&quot;&gt;# 框架启动的过程中会调用app/Providers下所有服务提供者的boot方法，事件服务也不例外。
App\Providers\EventServiceProvider文件
class EventServiceProvider extends ServiceProvider
{
        # 此数组键为事件名，值为事件的监听者
    # 事件服务的启动阶段会读取此配置，将所有的事件和事件监听者对应起来并挂载到事件分发器Dispatcher上
    protected $listen = [
        Registered::class =&amp;gt; [
            SendEmailVerificationNotification::class,
        ],
    ];
        
    # 事件服务启动真正调用的方法 可以看到调用了父类的boot方法
    # 也可以在boot方法中向事件分发器中自行绑定事件和监听者
    public function boot()
    {
        parent::boot();

        //
    }
}

# EventServiceProvider的父类
# 注册事件监听器
public function boot()
{       
    // getEvents方法 获取事件和监听器
    $events = $this-&amp;gt;getEvents();
        
    foreach ($events as $event =&amp;gt; $listeners) {
        foreach (array_unique($listeners) as $listener) {
            // 此处Event facade对应的是Dispatcher的listen方法
            // facade的原理和使用之前介绍过
            Event::listen($event, $listener);
        }
    }

    foreach ($this-&amp;gt;subscribe as $subscriber) {
        // 调用的是Dispatcher的subscribe方法
        Event::subscribe($subscriber);
    }
}

# getEvents方法
public function getEvents()
{
    if ($this-&amp;gt;app-&amp;gt;eventsAreCached()) {
        $cache = require $this-&amp;gt;app-&amp;gt;getCachedEventsPath();

        return $cache[get_class($this)] ?? [];
    } else {
        return array_merge_recursive(
            // 如果事件非常多，也可以设置事件和监听者的目录，让框架自行帮助查找
            // 如果需要开启discoveredEvents功能，需要在App\Providers\EventServiceProvider中
                // 重写shouldDiscoverEvents方法 并返回true 代表开启事件自动发现
                // 如果需要指定事件和监听者的目录，需要重写discoverEventsWithin方法，其中返回目录数组
                // 当然你也可以全部写在listen属性中
            // 当重写了以上两个方法的时候 返回的数组和$listen属性的格式是完全一致的 以事件名称为key 监听者为value
            $this-&amp;gt;discoveredEvents(),
            
            // 返回的就是App\Providers\EventServiceProvider下的listen数组
            $this-&amp;gt;listens()
        );
    }
}

# discoveredEvents方法 此方法触发的前提是重写了shouldDiscoverEvents方法
public function discoverEvents()
{       
    // 使用了laravel提供的collect辅助函数 文档有详细章节介绍
    // collect函数返回collection集合实例方便我们链式操作
    // reject方法的作用是 回调函数返回 true 就会把对应的集合项从集合中移除
    // reduce方法的作用是 将每次迭代的结果传递给下一次迭代直到集合减少为单个值
    return collect($this-&amp;gt;discoverEventsWithin())
        // discoverEventsWithin方法返回查找事件监听者的目录数组
        // 默认返回 (array) $this-&amp;gt;app-&amp;gt;path('Listeners')
        // 我们自然可以重写discoverEventsWithin方法，返回我们指定的监听者目录
        -&amp;gt;reject(function ($directory) {
            // 移除集合中不是目录的元素
            return ! is_dir($directory);
        })
        -&amp;gt;reduce(function ($discovered, $directory) {
            return array_merge_recursive(
                $discovered,
                // 使用Symfony的Finder组件查找Listener文件
                DiscoverEvents::within($directory, base_path())
            );
        }, []);
}

# Illuminate\Foundation\Events\DiscoverEvents::within方法
# 提取给定目录中的全部监听者
public static function within($listenerPath, $basePath)
{
    return collect(static::getListenerEvents(
        (new Finder)-&amp;gt;files()-&amp;gt;in($listenerPath), $basePath
    ))-&amp;gt;mapToDictionary(function ($event, $listener) {
        return [$event =&amp;gt; $listener];
    })-&amp;gt;all();
}

protected static function getListenerEvents($listeners, $basePath)
{
    $listenerEvents = [];
        // $listeners是Finder组件返回指定目录下的迭代器，遍历可以拿到目录下的所有文件
    foreach ($listeners as $listener) {
        try {
            $listener = new ReflectionClass(
                // 将绝对路径转换为类名
                static::classFromFile($listener, $basePath)
            );
        } catch (ReflectionException $e) {
            continue;
        }

        if (! $listener-&amp;gt;isInstantiable()) {
            continue;
        }

        // dump($listener-&amp;gt;getMethods(ReflectionMethod::IS_PUBLIC));

        foreach ($listener-&amp;gt;getMethods(ReflectionMethod::IS_PUBLIC) as $method) {
            // 代表着一个监听者类中 可以设置多个监听器
            if (! Str::is('handle*', $method-&amp;gt;name) ||
                ! isset($method-&amp;gt;getParameters()[0])) {
                continue;
            }
                        
            $listenerEvents[$listener-&amp;gt;name.'@'.$method-&amp;gt;name] =
                // 可以认为此处返回的是事件名
                // 写在handle*方法中的参数 我建议一定要加上类型提示，并且将类型名参数作为第一个参数传入
                Reflector::getParameterClassName($method-&amp;gt;getParameters()[0]);
        }
    }
        
    // 过滤事件参数名为空的监听器并返回
    return array_filter($listenerEvents);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;事件服务的启动二（注册事件监听者）&quot;&gt;事件服务的启动二（注册事件监听者）&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-php&quot;&gt;# 上面获取了全部的事件监听者 下面就要注册这些事件监听者了
# 继续看EventServiceProvider::boot方法
# 使用php artisan event:list 可以查看框架中已经注册的事件
# php artisan event:cache php artisan event:clear
public function boot()
{       
    # 拿到了$listen属性和要求自动发现的所有事件(如果开启了自动发现的话)
    $events = $this-&amp;gt;getEvents();
        // dump($events);
    
    foreach ($events as $event =&amp;gt; $listeners) {
        foreach (array_unique($listeners) as $listener) {
            // 调用dispatcher的listen方法
            // 事件名为key 事件监听者为value 进行事件的注册监听
            Event::listen($event, $listener);
        }
    }

    foreach ($this-&amp;gt;subscribe as $subscriber) {
        // subscribe方法请自行查看
        Event::subscribe($subscriber);
    }
}

# Dispatcher::listen方法
# 遍历getEvents中所有的事件和监听者 通过实际调用Dispatcher的makeListener创建监听者
# 以event名为键 创建的监听者闭包为值 保存在数组属性中 供事件触发的时候查找调用
// 向调度器注册事件监听器
public function listen($events, $listener)
{
    // dump($events, $listener);
    foreach ((array) $events as $event) {
        // 如果事件名称中包含*
        if (Str::contains($event, '*')) {
            $this-&amp;gt;setupWildcardListen($event, $listener);
        } else {
            // 正常事件名
            $this-&amp;gt;listeners[$event][] = $this-&amp;gt;makeListener($listener);
        }
    }
}

# 绑定事件和监听者闭包的映射
protected function setupWildcardListen($event, $listener)
{   
    // 当一系列的事件都想触发指定的监听者的时候 就可以使用*进行匹配
    $this-&amp;gt;wildcards[$event][] = $this-&amp;gt;makeListener($listener, true);
    // 每次更新了通配事件后 都清除缓存
    $this-&amp;gt;wildcardsCache = [];
}

# 官方注释表名此方法向事件分发器中注册一个事件监听者
# 其实就是返回事件触发时执行的监听者闭包
# 传入的listener可以使App\Listener\MyListener 或 App\Listener\MyListener@myHandle这种字符串
# 或者是一个接收两个参数的闭包
public function makeListener($listener, $wildcard = false)
{   
    if (is_string($listener)) {
        // 如果传递的是一个字符串的话 调用createClassListener放回闭包
        return $this-&amp;gt;createClassListener($listener, $wildcard);
    }

    // 如果listener是个闭包 那么直接将事件对象作为参数传入监听者
    // 事件触发的时候 直接执行此闭包
    return function ($event, $payload) use ($listener, $wildcard) {
        if ($wildcard) {
            return $listener($event, $payload);
        }

        // 可变数量的参数列表
        return $listener(...array_values($payload));
    };
}

# createClassListener方法
public function createClassListener($listener, $wildcard = false)
{   
    // 当传递的是一个class名或者是带@method的字符串的时候
    return function ($event, $payload) use ($listener, $wildcard) {
        if ($wildcard) {
            // createClassCallable返回一个数组 第一个参数是$listener的实例 第二个参数是method
            return call_user_func($this-&amp;gt;createClassCallable($listener), $event, $payload);
        }

        return call_user_func_array(
            $this-&amp;gt;createClassCallable($listener), $payload
        );
    };
}

# createClassCallable方法
protected function createClassCallable($listener)
{
    // 从字符串中获取类名和方法名
    [$class, $method] = $this-&amp;gt;parseClassCallable($listener);

    // 判断是否需要队列化监听器
    if ($this-&amp;gt;handlerShouldBeQueued($class)) {
        // class类名 method 方法名
        return $this-&amp;gt;createQueuedHandlerCallable($class, $method);
    }
        
    // 如果不需要异步化执行监听者 直接返回[$listener, 'method']数组
    // class通过container获得 意味着我们可以利用容器方便的注入listner需要的依赖
    // 注意此处返回的是listener的实例 和 调用监听者时执行的方法名
    return [$this-&amp;gt;container-&amp;gt;make($class), $method];
}

# handlerShouldBeQueued方法 判断如果一个监听者实现了ShouldQueue接口 就认为此监听者需要队列化执行
protected function handlerShouldBeQueued($class)
{   
    // 检查监听者是否实现了ShouldQueue接口
    // 是否使用队列处理事件
    try {
        return (new ReflectionClass($class))-&amp;gt;implementsInterface(
            ShouldQueue::class
        );
    } catch (Exception $e) {
        return false;
    }
}

# createQueuedHandlerCallable方法
protected function createQueuedHandlerCallable($class, $method)
{
    return function () use ($class, $method) {
        $arguments = array_map(function ($a) {
            return is_object($a) ? clone $a : $a;
        }, func_get_args());
                // handlerWantsToBeQueued方法 动态判断监听者是否需要投递到队列执行
        if ($this-&amp;gt;handlerWantsToBeQueued($class, $arguments)) {
            $this-&amp;gt;queueHandler($class, $method, $arguments);
        }
    };
}

# handlerWantsToBeQueued
protected function handlerWantsToBeQueued($class, $arguments)
{
    $instance = $this-&amp;gt;container-&amp;gt;make($class);

    // 动态判断是否需要异步化事件处理
    // 需要我们在监听器shouldQueue方法中return bool值
    if (method_exists($instance, 'shouldQueue')) {
        // 可以在监听者的shouldQueue方法中返回bool值 动态判断是否需要异步化
        return $instance-&amp;gt;shouldQueue($arguments[0]);
    }

    return true;
}

# queueHandler方法
// 判断listener的各种属性 将监听者投递到队列
// laravel 队列以后会单独讲解 此篇先到这里
protected function queueHandler($class, $method, $arguments)
{
    [$listener, $job] = $this-&amp;gt;createListenerAndJob($class, $method, $arguments);
        // resolveQueue获取注册事件服务时设置的queueResolver
    $connection = $this-&amp;gt;resolveQueue()-&amp;gt;connection(
        $listener-&amp;gt;connection ?? null
    );

    $queue = $listener-&amp;gt;queue ?? null;

    isset($listener-&amp;gt;delay)
        ? $connection-&amp;gt;laterOn($queue, $listener-&amp;gt;delay, $job)
        : $connection-&amp;gt;pushOn($queue, $job);
}

# 以上便是事件注册的基本代码 总体来说 我们看到调用Dispatcher的listen方法 可以注册监听者和事件的绑定
# 监听者都已闭包的形式进行包裹 这样的好处是可以保存上下文变量
# 涉及到的异步处理 其他文章会进行讲解
# 值得注意的是 注册好的闭包 并不会执行 当触发相应的事件时才会执行
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;事件的触发&quot;&gt;事件的触发&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-php&quot;&gt;# 业务代码中调用event()方法就可以触发一个事件了 执行的就是Dispatch::dispatch方法
public function dispatch($event, $payload = [], $halt = false)
{
    // 传递事件对象本身作为disaptch的参数 会将对象类名作为事件名 并将事件对象作为payload传递到监听者
    // 参考使用方式 event(new SomeEvent()) Event::disaptch(new SomeEvent())
    [$event, $payload] = $this-&amp;gt;parseEventAndPayload(
        $event, $payload
    );

    if ($this-&amp;gt;shouldBroadcast($payload)) {
        $this-&amp;gt;broadcastEvent($payload[0]);
    }

    $responses = [];

    foreach ($this-&amp;gt;getListeners($event) as $listener) {
        // 执行每个监听者闭包
        $response = $listener($event, $payload);

        if ($halt &amp;amp;&amp;amp; ! is_null($response)) {
            // 直接返回结果给事件触发
            return $response;
        }

        // 如果某个监听者返回了false 那么终止后续监听者的执行
        if ($response === false) {
            break;
        }

        $responses[] = $response;
    }
    // 返回结果给事件触发
    return $halt ? null : $responses;
}

# parseEventAndPayload方法
protected function parseEventAndPayload($event, $payload)
{   
    // 如果传递的是一个事件对象
    if (is_object($event)) {
        [$payload, $event] = [[$event], get_class($event)];
    }

    // 如果event是一个字符串 那么直接包装payload
    return [$event, Arr::wrap($payload)];
}

// 获取所有事件监听者
public function getListeners($eventName)
{
    $listeners = $this-&amp;gt;listeners[$eventName] ?? [];

    $listeners = array_merge(
        $listeners,
        $this-&amp;gt;wildcardsCache[$eventName] ?? $this-&amp;gt;getWildcardListeners($eventName)
    );
        
    // 如果插入的event类存在
    return class_exists($eventName, false)
        ? $this-&amp;gt;addInterfaceListeners($eventName, $listeners)
        : $listeners;
}

# addInterfaceListeners方法
protected function addInterfaceListeners($eventName, array $listeners = [])
{
    foreach (class_implements($eventName) as $interface) {
        // 判断事件或者其父类实现的接口是否绑定了监听器
        if (isset($this-&amp;gt;listeners[$interface])) {
            foreach ($this-&amp;gt;listeners[$interface] as $names) {
                $listeners = array_merge($listeners, (array) $names);
            }
        }
    }
    // 返回合并后的监听者
    return $listeners;
}

# 部分其他方法
# until方法 
# 触发事件 并返回第一个不为null的监听器结果
public function until($event, $payload = [])
{   
    return $this-&amp;gt;dispatch($event, $payload, true);
}

# push方法
# 调用的还是listen方法 只不过指定了payload参数
public function push($event, $payload = [])
{
    $this-&amp;gt;listen($event.'_pushed', function () use ($event, $payload) {
        $this-&amp;gt;dispatch($event, $payload);
    });
}

# flush方法 调用push注册的监听者
public function flush($event)
{
    $this-&amp;gt;dispatch($event.'_pushed');
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;第三部分-使用&quot;&gt;第三部分 使用&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;使用一 通过触发事件给监听者传参&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-php&quot;&gt;1 在App\Porviders\EventServiceProvider的listen属性中绑定事件和监听者映射关系
...
use App\Events\TestEvent1;
use App\Listeners\TestListener1;
use App\Listeners\TestListener2;
...
protected $listen = [
        ...
    TestEvent1::class =&amp;gt; [
        TestListener1::class,
        // 自定义监听者闭包调用的方法myHandle
        TestListener2::class . '@myHandle'
    ]
];
...
    
2 php artisan event:generate 按照listen数组的事件监听者映射生成
    
3 我们不在TestEvent1事件中做过多处理 在本示例中保持原样即可

4 编写TestListener1文件
&amp;lt;?php

namespace App\Listeners;

use App\Components\Log\LogManager;
use App\Events\TestEvent1;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Queue\InteractsWithQueue;
use App\Providers\LogManagerServiceProvider;

class TestListener1
{   
    protected $logger;
        // 通过上面的分析 我们知道监听者时通过容器解析出来的 所以可以尽情的注入
    public function __construct(LogManager $logger)
    {
        $this-&amp;gt;logger = $logger;
    }   
        // 自定义传参给事件监听者
    public function handle(TestEvent1 $event, string $type)
    {
        // dump($type);
        // dump(debug_backtrace());
        $this-&amp;gt;logger-&amp;gt;driver($type)-&amp;gt;logCertains('emergency', 'something emergency');
    }
}

5 编写TestListener2文件
&amp;lt;?php

namespace App\Listeners;

use App\Events\TestEvent1;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Queue\InteractsWithQueue;

class TestListener2
{
    /**
     * Create the event listener.
     *
     * @return void
     */
    public function __construct()
    {
        //
    }
        
    // 其实指定了myHandle方法之后 原生的handle方法就可以注释或者什么都不写了
    // 通过上面的分析我们知道 框架会执行监听者中所有以handle开头的方法
    // public function handle(TestEvent1 $event)
    // {   
    //     echo '345';
    // }

    // 此方法也是会执行的
    // public function handleabc(TestEvent1 $event)
    // {   
    //     echo 'abc';
    // }
        
    public function myHandle(TestEvent1 $event)
    {
        dump('do whatever you like');
    }
}

6 编写测试路由 触发事件
Route::get('event1', function () {
    // 情况一 传递的是事件实例 如果你需要在事件实例中注入依赖 当然可以使用容器解析事件对象
    // 当注入的是一个事件对象的时候 会触发事件类名这个事件 并且将事件对象作为payload传递给handle方法
    // Event::dispatch(new \App\Events\TestEvent1());

    // 情况二 传递的是事件名 第二个参数生效
    // 演示如何不依赖事件对象 传递参数
    Event::dispatch(TestEvent1::class, [new TestEvent1(), 'stream']);
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;使用二 设置事件自动发现&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-php&quot;&gt;1 在App\Porviders\EventServiceProvider中重写shouldDiscoverEvents方法 启用事件发现
// 启用事件自动发现
public function shouldDiscoverEvents()
{
    return true;
}

2 我们更近一步 设置自动监听者所在目录 重写discoverEventsWithin方法 指定自动发现目录
// 指定自动发现目录
// 默认的就是app_path('Listeners')
public function discoverEventsWithin()
{
    return [
        // 这里可以注释掉Listeners目录为了避免和上面的listen属性重复 导致所有的监听者都会执行两遍
        // app_path('Listeners'),
        app_path('MyListeners')
    ];
}

3 编写事件App\Events\TestEvent2文件 我这里的代码没有任何的实际意义
&amp;lt;?php

namespace App\Events;

class TestEvent2
{   
    protected $name = 'xy';

    public function __construct()
    {
        // 随意发挥
    }

    public function getName()
    {
        return $this-&amp;gt;name;
    }
}

4 手动创建App\MyListeners\Listener1文件
# 通过上面的源码分析 我们知道laravel会将所有以handle开头的方法参数遍历
# 然后将第一个参数的类名作为要触发的事件名，将事件参数作为payload传入
&amp;lt;?php

namespace App\MyListeners;

use App\Events\TestEvent2;

class MyListener1
{
    public function handle(TestEvent2 $evt)
    {
        dump($evt-&amp;gt;getName(), 'abc');
        return false; // 如果不注释掉此行代码，事件的调用链到此终结
    }

    public function handleAbc(TestEvent2 $evt)
    {
        dump($evt-&amp;gt;getName());
    }
}

5 手动创建App\MyListeners\Listener2文件
&amp;lt;?php

namespace App\MyListeners;

use App\Events\TestEvent2;

class MyListener2
{ 
    public function handle(TestEvent2 $evt)
    {
        dump($evt-&amp;gt;getName());
    }
}

6 创建事件自动发现路由
// 测试自动发现
Route::get('event2', function(){
    Event::dispatch(new TestEvent2());
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;使用三 implement的使用 当事件实现了其他事件接口，会自动触发其他事件绑定的监听者&lt;/p&gt;
&lt;p&gt;对应的方法为Dispatcher::addInterfaceListeners 请看第二部分&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-php&quot;&gt;1 创建事件接口
&amp;lt;?php

namespace App\Events;

interface TestEvent3
{ }

&amp;lt;?php

namespace App\Events;

interface TestEvent4
{ }


2 创建监听者
&amp;lt;?php

namespace App\Listeners;

class TestListener3
{
    public function handle()
    {
        dump('listener3 added by event interface3');
    }
}

&amp;lt;?php

namespace App\Listeners;

class TestListener4
{
    public function handle()
    {
        dump('listener3 added by event interface4');
    }
}
    
&amp;lt;?php

namespace App\Listeners;

class TestListener5 implements TestEvent3, TestEvent4
{
    public function handle()
    {
        dump('five own listener');
    }
}

3 事件实现上面的两个接口
&amp;lt;?php

namespace App\Events;

class TestEvent5 implements TestEvent3, TestEvent4
{ }

4 注册事件监听者
protected $listen = [
    ...
    TestEvent3::class =&amp;gt; [
        TestListener3::class
    ],
    TestEvent4::class =&amp;gt; [
        TestListener4::class
    ],
    # 甚至可以注释掉下面3行 只需要TestEvent5实现上面两个接口即可触发上面注册的监听者
    TestEvent5::class =&amp;gt; [
        TestListener5::class
    ]
]; 

5 最重要的一步 force and brutal 改源码 没错 就是改源码
# Dispatcher::getListeners方法
...    
// return class_exists($eventName, false)
    return class_exists($eventName)
        ? $this-&amp;gt;addInterfaceListeners($eventName, $listeners)
        : $listeners;
...
6 创建测试路由
Route::get('event5', function () {
    Event::dispatch(TestEvent5::class);
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;使用四 until和flush&lt;/p&gt;
&lt;p&gt;until方法默认调用dispatch方法 当时间监听者返回不为null则停止执行后面的监听者 并返回结果给事件触发位置&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-php&quot;&gt;1 配置时间监听者
protected $listen = [
...
    TestEvent6::class =&amp;gt; [
        TestListener6::class,
        TestListener7::class,
        TestListener8::class
    ]
];

2 php artisan event:generate
    
3 简单编写事件监听者
# listener6
public function handle(TestEvent6 $event)
{
    dump('return null');
}
# listener7
public function handle(TestEvent6 $event)
{       
    // 注意此监听者是有返回值的
    return 123;
}
# listener8
public function handle(TestEvent6 $event)
{       
        // 并不会执行7后面的监听者 根本就不会执行
    return 'return something in vain';
}

4 编写测试路由
Route::get('event6', function () {
    $res = Event::until(new TestEvent6());
    // 可以看到监听者8并没有执行 因为7返回的不是null
    dump($res);
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;使用五 push&amp;amp;flush 请查看上面的源码分析&lt;/p&gt;
&lt;p&gt;push方法就是提前将event和payload注册好 供flush调用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-php&quot;&gt;1 在App\Providers\EventServiceProvider::boot方法中注册(这里只是举例在boot中进行注册，你可以在你喜欢的任何地方注册)
public function boot()
{
    parent::boot();
        // 注册一个保存了payload的事件监听者
    Event::push('longAssEventName', ['type' =&amp;gt; 'redis']);
    Event::listen('longAssEventName', function ($type) {
        dump($type);
    });
}

2 创建测试路由
Route::get('event7', function () {
    Event::flush('longAssEventName');
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上用法没那么常见，这里只是简单演示下，细节还需各位自行尝试，常见使用还要各位仔细查阅文档。&lt;/p&gt;
&lt;p&gt;至于监听者的异步化，只需要监听者实现ShouldQueue接口，然后简单配置就可以了。大家可以先行查看文档事件部分，&lt;br/&gt;具体使用会在laravel队列篇章讲解。如有错误，劳烦指正，感谢。&lt;/p&gt;
&lt;p&gt;最后，祝各位十一快乐！！！&lt;/p&gt;
</description>
<pubDate>Wed, 30 Sep 2020 15:17:00 +0000</pubDate>
<dc:creator>alwayslinger</dc:creator>
<og:description>Laravel Event的分析和使用 第一部分 概念解释 请自行查看观察者模式 第二部分 源码分析 （逻辑较长，不喜欢追代码可以直接看使用部分） 第三部分 使用 第一部分 解释 当一个用户阅读了一篇</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/alwayslinger/p/13756847.html</dc:identifier>
</item>
<item>
<title>理解pytorch几个高级选择函数（如gather） - jianli-Alex</title>
<link>http://www.cnblogs.com/liangjianli/p/13754817.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liangjianli/p/13754817.html</guid>
<description>&lt;h3 id=&quot;1-引言&quot;&gt;1. 引言&lt;/h3&gt;
&lt;p&gt;  最近在刷开源的Pytorch版动手学深度学习，里面谈到几个高级选择函数，如index_select，masked_select，gather等。这些函数大多很容易理解，但是对于gather函数，确实有些难理解，官方文档开始也看得一脸懵，感觉不太直观。下面谈谈我对这几个函数的一些理解。&lt;/p&gt;
&lt;h3 id=&quot;2-维度的理解&quot;&gt;2. 维度的理解&lt;/h3&gt;
&lt;p&gt;  对于numpy和pytorch，其数组在做维度运算上刚开始可能会给人一种直观上的误解，以numpy求矩阵某个维度的最大值为例（pytorch的理解也是一样的）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import numpy as np
a = np.arange(1, 13).reshape(3, 4)
&quot;&quot;&quot;
result:
a = [[1, 2, 3, 4],
      [5, 6, 7, 8,],
      [9, 10, 11, 12]]
&quot;&quot;&quot;

# 对a维度0求最大值
a.max(axis = 0)
&quot;&quot;&quot;
result:
[9, 10, 11, 12]
&quot;&quot;&quot;

# 对a维度1求最大值
a.max(axis = 1)
&quot;&quot;&quot;
result:
[4, 8, 12]
&quot;&quot;&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  如果对a矩阵在维度0上找最大值，根据我们直观上的经验应该是[4, 8, 12]。即从[1, 2, 3, 4]找到4，从[5, 6, 7, 8]找到8，从[9, 10, 11, 12]找到12。但是从上面结果来看，numpy运算却给了我们直观上认为是列最大值的结果[9, 10, 11, 12]。&lt;br/&gt;  实际numpy（pytorch）运算应该理解为&lt;strong&gt;往给定的维度进行移动运算&lt;/strong&gt;。还是以维度0为例，维度0上有3个向量，分别为[1, 2, 3, 4]，[5, 6, 7, 8]和[9, 10, 11, 12]。往维度0移动，即[1, 2, 3, 4]和[5, 6, 7, 8]逐元素计算最大值，得到[5, 6, 7, 8]，再和[9, 10, 11, 12]运算得到结果[9, 10, 11, 12]。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img alt=&quot;维度运算图1&quot; src=&quot;https://img2020.cnblogs.com/blog/1684731/202009/1684731-20200930160844593-2067583483.jpg&quot; height=&quot;80%,&quot; width=&quot;80%&quot;/&gt;&lt;/div&gt;
  另外，对于维度为3的数组，在numpy和pytorch中，应该把维度0理解为通道数，维度1和维度2才是对应高和宽。如果是3维数组对应着用于多输入通道和单输出通道的卷积核（维度为U x V x D），那么4维数组就对应着用于多输入通道和多输出通道的卷积核（维度为U x V x D x P），此时，维度0则为多通道卷积核数量的方向，维度1为通道数，维度2和3才是分别对应高和宽。
&lt;div align=&quot;center&quot;&gt;&lt;img alt=&quot;维度运算图2&quot; src=&quot;https://img2020.cnblogs.com/blog/1684731/202009/1684731-20200930165551793-2033960585.jpg&quot; height=&quot;70%,&quot; width=&quot;70%&quot;/&gt;&lt;/div&gt;
&lt;h3 id=&quot;3-gather函数&quot;&gt;3. gather函数&lt;/h3&gt;
&lt;p&gt;pytorch和numpy中许多函数都涉及维度运算，&lt;code&gt;gather&lt;/code&gt;也不例外，但是它相对于其他函数更难理解。依然先来看一个例子&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import torch
a = torch.arange(1, 16).reshape(5, 3)
&quot;&quot;&quot;
result:
a = [[1, 2, 3],
      [4, 5, 6],
      [7, 8, 9],
      [10, 11, 12],
      [13, 14, 15]]
&quot;&quot;&quot;

# 定义两个index
b = torch.tensor([[0, 1, 2], [2, 3, 4], [0, 2, 4]])
c = torch.tensor([[1, 2, 0, 2, 1], [1, 2, 1, 0, 0]])

# axis=0
output1 = a.gather(0, b)
&quot;&quot;&quot;
result:
[[1, 5, 9],
[7, 11, 15],
[1, 8, 15]]
&quot;&quot;&quot;

# axis=1
output2 = a.gather(1, c)
&quot;&quot;&quot;
result:
[[2, 3, 1, 3, 2],
[5, 6, 5, 4, 4]]
&quot;&quot;&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的例子看起来可能有点复杂，我们来一步步的分析它，先从gather维度为0开始讲起。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;a.gather(0, b)&lt;/code&gt;分为3个部分，&lt;code&gt;a&lt;/code&gt;是需要被提取元素的矩阵，&lt;code&gt;0&lt;/code&gt;代表的是提取的维度为0，&lt;code&gt;b&lt;/code&gt;是提取元素的索引
&lt;ul&gt;&lt;li&gt;其中规定b和a是同维张量，即a是2维张量，b也必须是2维张量&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0&lt;/code&gt;除了代表往维度0的方向提取元素外，还有一个特权---提取结果output可以在这个维度上的长度与a不同。打个比方，a现在的shape为(5, 3)，那么提取结果output1的shape可以是(1,3)，(2, 3)，甚至(n, 3)。具体维度0的长度到底为多少由b来决定。&lt;/li&gt;
&lt;li&gt;根据&lt;code&gt;0&lt;/code&gt;的特权，导致了给定的b张量除了维度0外，其他的维度大小必须和a一样。其中张量&lt;code&gt;b&lt;/code&gt;实际上包含以下两个信息
&lt;ul&gt;&lt;li&gt;b可以利用除用于gather的维度（此处为维度0）外的维度来定位出唯一一个向量，也就是a[:, ?]（三维度也是同理的，有a[:, ?1, ?2]）,?的取值范围为a同维度的index。&lt;/li&gt;
&lt;li&gt;对于上述定位出的向量，通过b中的元素来定位提取向量中的哪一个元素。&lt;/li&gt;
&lt;li&gt;上面说得可能有点抽象，实际上b中的每个元素都能在a中提取出一个元素。举个具体点的例子，按照上面所说的，b[0, 0]可以提取a中的一个元素。对于b[0,0]，除了维度0外，可以通过维度1来定位出唯一一个向量a[:, 0]。因为b[0, 0]的元素为0，即提取的是a[:, 0]的第0个元素---1，并将其作为output1[0, 0]的提取结果。&lt;br/&gt;下图给出了维度0和维度1，gather运算的图示&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;div align=&quot;center&quot;&gt;&lt;img alt=&quot;gather 2维度&quot; src=&quot;https://img2020.cnblogs.com/blog/1684731/202009/1684731-20200930211337873-282119057.jpg&quot; height=&quot;80%,&quot; width=&quot;80%&quot;/&gt;&lt;/div&gt;
对于3维或者更高维度的张量gather的原理也是一样的
&lt;div align=&quot;center&quot;&gt;&lt;img alt=&quot;gather 2维度&quot; src=&quot;https://img2020.cnblogs.com/blog/1684731/202009/1684731-20200930211725799-984888806.jpg&quot; height=&quot;80%,&quot; width=&quot;80%&quot;/&gt;&lt;/div&gt;
&lt;h3 id=&quot;4-index_select函数&quot;&gt;4. index_select函数&lt;/h3&gt;
&lt;p&gt;其他的高级选择函数都比较容易理解，这里简单的提一下。torch.index_select主要是根据传入的tensor来往给定的axis方向来选取张量&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import torch
a = torch.arange(9).reshape(3, 3)
torch.index_select(a, 0, torch.tensor([0, 2]))
&quot;&quot;&quot;
result:
[[0, 1, 2],
[6, 7, 8]]
&quot;&quot;&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;5-masked_select函数&quot;&gt;5. masked_select函数&lt;/h3&gt;
&lt;p&gt;实际上就是通过掩码条件来选择元素，像torch.masked_select(x, x&amp;gt;0.5)，实际上是和x[x&amp;gt;0.5]等价的，最后返回的是一维张量&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import torch
a = torch.rand(5, 3)

# 结果和a[a &amp;gt; 0.5]等价
torch.masked_select(a, a&amp;gt;0.5)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;6-nonzero函数&quot;&gt;6. nonzero函数&lt;/h3&gt;
&lt;p&gt;找到非零元素的index&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import torch
a = torch.eye(3)
torch.nonzero(a)

&quot;&quot;&quot;
result: 对应着非零元素的index
[[0, 0],
[1, 1],
[2, 2]]
&quot;&quot;&quot;
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 30 Sep 2020 13:43:00 +0000</pubDate>
<dc:creator>jianli-Alex</dc:creator>
<og:description>1. 引言 最近在刷开源的Pytorch版动手学深度学习，里面谈到几个高级选择函数，如index_select，masked_select，gather等。这些函数大多很容易理解，但是对于gather</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/liangjianli/p/13754817.html</dc:identifier>
</item>
<item>
<title>一种统计ListView滚动距离的方法 - woodWu</title>
<link>http://www.cnblogs.com/WoodJim/p/13756366.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/WoodJim/p/13756366.html</guid>
<description>&lt;p&gt;本文从实际使用的场景出发，提出了一个可记录ListView滚动距离的实际方案，该方案可精确统计各种场景下ListView的实际滚动距离，并兼容了常见的边界统计的问题。是目前可直接运用于实际的生产环境的最优方案，没有之一。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;153.00224778527&quot;&gt;
&lt;p&gt;&lt;strong&gt;注：本文同步发布于微信公众号：stringwu的互联网杂谈&lt;/strong&gt; &lt;a href=&quot;https://mp.weixin.qq.com/s/sAHg4yU2g4Vw45uZgObhWg&quot;&gt;一种统计ListView滚动距离的方法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ListView&lt;/code&gt;做为&lt;code&gt;Android&lt;/code&gt;中最常使用的列表控件,主要用来显示同一类的数据，如应用列表，商品列表等。&lt;code&gt;ListView&lt;/code&gt;的详细使用与介绍可查阅官方文档&lt;a href=&quot;https://developer.android.com/reference/android/widget/ListView&quot;&gt;ListView&lt;/a&gt;。这里不再展示叙述。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ListView&lt;/code&gt;在屏幕上会固定一定长度，如果内容超过这个长度，一般是通过滑动来向下浏览更多的内容。此时有产品就想统计出用户在某一次浏览中是否有滑动，并且想实际量化该滑动距离。虽然觉得这个需求很扯淡，但做为开发的我还是老老实实去寻找实际的统计解决方案。但搜索了一圈并没有找到一个满足需求的解决方案。于是就有了此文。&lt;/p&gt;


&lt;p&gt;&lt;code&gt;ListView&lt;/code&gt;提供了一个&lt;code&gt;setOnScrollListener&lt;/code&gt;的接口来接收List的滚动事件：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class AbsListView{
 .....
  /**
     * Set the listener that will receive notifications every time the list scrolls.
     *
     * @param l the scroll listener
     */
    public void setOnScrollListener(OnScrollListener l) {
        mOnScrollListener = l;
        invokeOnItemScrollListener();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中，&lt;code&gt;OnScrollListener&lt;/code&gt;的接口为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class AbsListView{
 public interface OnScrollListener {
  ....
   /**
         * Callback method to be invoked while the list view or grid view is being scrolled. If the
         * view is being scrolled, this method will be called before the next frame of the scroll is
         * rendered. In particular, it will be called before any calls to
         * {@link Adapter#getView(int, View, ViewGroup)}.
         *
         * @param view The view whose scroll state is being reported
         *
         * @param scrollState The current scroll state. One of
         * {@link #SCROLL_STATE_TOUCH_SCROLL} or {@link #SCROLL_STATE_IDLE}.
         */
        public void onScrollStateChanged(AbsListView view, int scrollState);

        /**
         * Callback method to be invoked when the list or grid has been scrolled. This will be
         * called after the scroll has completed
         * @param view The view whose scroll state is being reported
         * @param firstVisibleItem the index of the first visible cell (ignore if
         * visibleItemCount == 0)
         * @param visibleItemCount the number of visible cells
         * @param totalItemCount the number of items in the list adapter
         */
        public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount,
                int totalItemCount);
 }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从&lt;code&gt;OnScrollListener&lt;/code&gt;的回调方法&lt;code&gt;onScroll&lt;/code&gt;的参数里我们可以看到，这里并没有实际滚动了多少距离的参数变量，如果想统计实际滚动的距离，则需要自定义一个&lt;code&gt;ScrollListener&lt;/code&gt;来处理，在接收到滚动回调时进行自行处理。&lt;/p&gt;
&lt;h2 id=&quot;22-统计方案&quot;&gt;2.2 统计方案&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;核心方案：通过第一个可见item的变化来统计判断实际滑动的距离，离开时通过累加初始时可见item到离开时可见item的高度来统计实现&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一次进来时（收到滚动回调）时，记录下此时第一个可见item的index 为 mInitPosition;&lt;/li&gt;
&lt;li&gt;每次收到滚动回调时，更新已滚动的第一个可见item的 index,并记录下第一个item的最大的index 为：mMaxPosition;&lt;/li&gt;
&lt;li&gt;每次收到滚动回调时，根据第一个item的变化，记录下当前已滚动的最大距离；&lt;/li&gt;
&lt;li&gt;每次回调时，如果第一个item的最大index发生变化，则会累加上一个item的距离；&lt;/li&gt;
&lt;li&gt;离开时，通过 mMaxPosition 和 mInitPosition计算出当次滚动的最大距离；&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//初次回调时
mInitPosition = getFirstItemPosition();
.....
//其他回调时
mCurPosition = getFirstItemPosition();
mMaxPosition = Max(mCurPosition,mMaxPosition);
.....
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;整个统计方案需要解决以下几个关键问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;滚动不超过一个item时的距离统计；&lt;/li&gt;
&lt;li&gt;进来时停留在某一个item时的滚动距离统计；&lt;/li&gt;
&lt;li&gt;快速滑动时的距离的统计；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;221-滚动不超过一个item时的统计&quot;&gt;2.2.1 滚动不超过一个item时的统计&lt;/h3&gt;
&lt;p&gt;因为我们整体的方案是通过累加item的高度来判断当前滚动了多少距离，大方案只能统计滚动刚好超过item时滚动距离，但如果滚动未超过一个item时，其滚动距离则不能累加item的高度来处理，比如：&lt;br/&gt;&lt;img src=&quot;http://i.gtimg.cn/open/appstore/imgupload/202009/598309908_1601003924122458.png&quot; alt=&quot;滚动不超过一个item时的统计&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;实际滚动距离为红色部分，并没有超过一个item的高度，此时应该怎样统计该部分的距离呢？这肯定没有办法直接通过item的高度来计算得到。这里核心是通过系统提供的&lt;code&gt;View&lt;/code&gt;的方法&lt;code&gt;getTop&lt;/code&gt;来拿到该&lt;code&gt;View&lt;/code&gt;最顶部距离其&lt;code&gt;Parent&lt;/code&gt;的距离：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    /**
     * Top position of this view relative to its parent.
     *
     * @return The top of this view, in pixels.
     */
    @ViewDebug.CapturedViewProperty
    public final int getTop() {
        return mTop;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在该item第一次变成第一个可见item时，记录下此时通过&lt;code&gt;getTop&lt;/code&gt;拿到的初始值：&lt;code&gt;mInitTop&lt;/code&gt; ，在离开时，获取当前停留的&lt;code&gt;top&lt;/code&gt;值：&lt;code&gt;mCurTop&lt;/code&gt;。在拿到这两个阶段的&lt;code&gt;top&lt;/code&gt;值时，我们就可以通过p这两个值来计算出红色部分的实际滚动距离：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//这里大家可以思考下为什么可以通过减掉当前的top值就能获取到当前实际滚动的距离的；
int itemHeight = mInitTop - mCurTop;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;222-进来时停留在某一个item时的滚动距离统计；&quot;&gt;2.2.2 进来时停留在某一个item时的滚动距离统计；&lt;/h3&gt;
&lt;p&gt;如果是从当前页面A跳到其他页面B后，再跳转回来，此时当前页面A正常是停留在上一次浏览的位置（前提是页面A未被回收掉），此时有可能是停留在某个位置上的，如图：&lt;br/&gt;&lt;img src=&quot;http://i.gtimg.cn/open/appstore/imgupload/202009/1671770941_1601003866030737.png&quot; alt=&quot;进来时滚动位置&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;此时向下滚动时，&lt;code&gt;item1&lt;/code&gt;的滚动距离为红色部分，这部分的距离可以怎样计算得到呢？在进入该页面时，我们通过该itemView的&lt;code&gt;getTop&lt;/code&gt;方法拿到的初始值：&lt;code&gt;mInitTop&lt;/code&gt;，该值的绝对值就为橙色部分的高度。而 橙色部分高度 + 红色部分高度 = 该item的实际高度，进而我们可以通过item的高度 - 橙色部分高度来得到红色部分的高度：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//进来时，记录下该item的初始top
mInitTop = item1View.getTop();
.......
//item1的实际滚动距离scrollDistance
int scrollDistance = item1View.getHeight() + mInitTop;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;223-快速滑动时的距离的统计&quot;&gt;2.2.3 快速滑动时的距离的统计&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;ListView&lt;/code&gt;在快速滑动时的滚动回调并不会每次都回调给注册了滚动监听的对象，有可能是隔几次才会回调一次，这样会导致我们在收到滚动回调时时记录的当前最大滚动距离不准？这里有没有办法兼容快速滑动这种场景下的统计？笔者在实践中采用了一种补偿机制的方案：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;记录下当前可见页面的所有item的高度；&lt;/li&gt;
&lt;li&gt;每次更新最大滚动距离时，同步记录下已更新到最大滚动距离的itemIndex;&lt;/li&gt;
&lt;li&gt;最终获取最大滚动距离时，会判断是否有漏掉item的高度，如果有漏掉item，则会记录的所有item的高度进行一次补偿；&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//记录下最大滚动距离里记录的itemIndex;
private List&amp;lt;Integer&amp;gt; mFistVisibleItem = new ArrayList&amp;lt;&amp;gt;();
//记录下当前所有item的高度情况
private SparseIntArray mItemHeight = new SparseIntArray();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最终获取时会根据是否有漏掉记录，根据记录的&lt;code&gt;mItemHeight&lt;/code&gt;的值进行一个补偿：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;boolean isMissing(){
int count = mMaxPosition -mInitPosition;
if (mFistVisibleItem.size() &amp;lt; count) {
    return true;
}
return false;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;23-使用&quot;&gt;2.3 使用&lt;/h2&gt;
&lt;p&gt;实际使用时，我们需要把自定义的&lt;code&gt;ScrollListener&lt;/code&gt;设置给对应的&lt;code&gt;ListView&lt;/code&gt;就能统计到具体的滚动距离：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;ListView mList = findViewById(R.id.list_view);
mList.setOnScrollListener(new ScrollListener());

&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;本文从实际使用的场景出发，提出了一个可记录&lt;code&gt;ListView&lt;/code&gt;滚动距离的实际方案，该方案可精确统计各种场景下&lt;code&gt;ListView&lt;/code&gt;的实际滚动距离，并兼容了常见的边界统计的问题。是目前可直接运用于实际的生产环境的最优方案，没有之一，就是这么自信的。&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Wed, 30 Sep 2020 12:33:00 +0000</pubDate>
<dc:creator>woodWu</dc:creator>
<og:description>本文从实际使用的场景出发，提出了一个可记录ListView滚动距离的实际方案，该方案可精确统计各种场景下ListView的实际滚动距离，并兼容了常见的边界统计的问题。是目前可直接运用于实际的生产环境的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/WoodJim/p/13756366.html</dc:identifier>
</item>
<item>
<title>依赖注入在 dotnet core 中实现与使用：4. 集成 Autofac - 冠军</title>
<link>http://www.cnblogs.com/haogj/p/13683730.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/haogj/p/13683730.html</guid>
<description>&lt;p&gt;本文介绍了在 ASP.NET Core 应用中集成 Autofac 依赖注入容器，并介绍了拦截器的使用。 本文示例基于 .net core 5 实现。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;195.23518164436&quot;&gt;
&lt;p&gt;本示例使用 &lt;a href=&quot;https://dotnet.microsoft.com/download/dotnet/5.0&quot;&gt;.net core 5 rc-1&lt;/a&gt; 实现。&lt;/p&gt;
&lt;h3 id=&quot;1-添加-nuget-包引用&quot;&gt;1. 添加 Nuget 包引用&lt;/h3&gt;
&lt;p&gt;使用 Autofac 当然要添加 Autofac 的 Nuget 包，主要涉及到两个：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Autofac.Extensions.DependencyInjection 核心支持包&lt;/li&gt;
&lt;li&gt;Autofac.Extras.DynamicProxy2 AOP 动态代理支持&lt;br/&gt;如果不需要动态代理的话，只需要添加第一个即可。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;dotnet add package Autofac.Extensions.DependencyInjection
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;2-配置-autofac&quot;&gt;2. 配置 Autofac&lt;/h3&gt;
&lt;p&gt;首先需要需要配置 Autofac 的容器工厂。&lt;/p&gt;
&lt;p&gt;由于需要使用 Autofac 的容器，所以在构建应用程序的时候，需要使用 Autofac 的服务工厂。主程序 Program 中的 CreateHostBuilder() 方法需要增加一行，修改之后如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt; public static IHostBuilder CreateHostBuilder (string[] args) =&amp;gt;
            Host.CreateDefaultBuilder (args)
            .UseServiceProviderFactory (new AutofacServiceProviderFactory ())
            .ConfigureWebHostDefaults (webBuilder =&amp;gt; {
                webBuilder.UseStartup&amp;lt;Startup&amp;gt; ();
            });
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后，需要在 Startup() 中配置服务注册。&lt;/p&gt;
&lt;p&gt;Autofac 的服务工厂会在调用 ConfigureServices() 之后，自动调用名为 ConfigureContainer() 的方法，一般情况下，我们会在这个方法里面使用 Autofac 来注册服务。&lt;/p&gt;
&lt;p&gt;在 Startup 文件中，添加如下的 ConfigureContainer() 方法。ContainerBuilder 是定义在命名空间 Autofac 中的，注意添加对该命名空间的引用。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;using Autofac;

public void ConfigureContainer (ContainerBuilder builder) {
      ......
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Autofac 提供了各种注册服务的方法，不是微软的 Addxxx() 方式，而是 Registerxxx() 方式。&lt;br/&gt;例如，如果我们已经定义了一个 IDbService 接口，而它的实现类型是 DbService。那么，注册服务的形式如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt; // register type, and enable interceptor injection
 builder.RegisterType&amp;lt;DbService&amp;gt; ().As&amp;lt;IDbService&amp;gt; ()
            .InstancePerLifetimeScope ();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;DbService 是注册在容器中的实现类型，而 As&amp;lt;IDbService&amp;gt; 是在容器中注册的类型。注入的时候需要使用这个接口类型。InstancePerLifetimeScope() 则是说明它的生命周期是 Scope 类型的。&lt;br/&gt;可以看到，在 Autofac 中，使用链式调用的方式来完成服务注册。&lt;/p&gt;
&lt;h3 id=&quot;3-使用-autofac-module-进行注册&quot;&gt;3. 使用 Autofac Module 进行注册&lt;/h3&gt;
&lt;p&gt;Autofac 提供了一个名为 Module 的概念，它支持将一组相关的服务注册过程进行打包，以简化配置和部署。&lt;br/&gt;Autofac 提供了名为 Autofac.IModule 接口，以及一个它的抽象实现类型 Autofac.Module。它的核心是 Load() 方法，用来完成服务的注册。我们可以重载它以实现自定义的服务注册，该方法的签名如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;protected virtual void Load(
        ContainerBuilder builder
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到该方法提供同样的 ContainerBuilder 参数来提供服务注册的支持。&lt;br/&gt;这样的话，前面的服务注册可以转移到一个 Autofac 的 Module 中来。&lt;br/&gt;我们可以定义一个服务注册类，如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;using Autofac;
using Microsoft.AspNetCore.Mvc;

public class ServiceAutofacModule : Autofac.Module {
    protected override void Load (ContainerBuilder builder) {
           // register type, and enable interceptor injection
           builder.RegisterType&amp;lt;DbService&amp;gt; ().As&amp;lt;IDbService&amp;gt; ()
              .InstancePerLifetimeScope ();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后，将 Startup() 中的 ConfigureContainer() 调整为如下形式，使用 Module 的方式完成服务注册。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public void ConfigureContainer (ContainerBuilder builder) {

            // use autofac module 
            builder.RegisterModule&amp;lt;ServiceAutofacModule&amp;gt;();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Module 的使用详见：&lt;a href=&quot;https://autofaccn.readthedocs.io/en/latest/configuration/modules.html&quot;&gt;https://autofaccn.readthedocs.io/en/latest/configuration/modules.html&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;4-常见的注册方式&quot;&gt;4. 常见的注册方式&lt;/h3&gt;
&lt;h4 id=&quot;1-按照类型进行注册&quot;&gt;1. 按照类型进行注册&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;// register type, and enable interceptor injection
        builder.RegisterType&amp;lt;DbService&amp;gt; ().As&amp;lt;IDbService&amp;gt; ()
            .InstancePerLifetimeScope ();
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;2-按已经引用的程序集注册&quot;&gt;2. 按已经引用的程序集注册&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;var assembly = assembly.Load (&quot;Domain.Services&quot;);
        builder.registerAssemblyType (assembly)
            .AsImplementedInterfaces ()
            .InstancePerLifetimeScope ();
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;3-注册程序集中的某些服务&quot;&gt;3. 注册程序集中的某些服务&lt;/h4&gt;
&lt;p&gt;下面的代码中，先取得了 ControllerBase 的类型，然后在当前程序集中查找所有派生自 ControllerBase 的 Api 控制器&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;    builder.RegisterAssemblyTypes(typeof(Program).Assembly)
        .Where(t =&amp;gt; t.Name.EndsWith(&quot;Service&quot;))
        .AsImplementedInterfaces()
        .InstancePerLifetimeScope();
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;5-使用属性注入&quot;&gt;5. 使用属性注入&lt;/h3&gt;
&lt;p&gt;Autofac 除了支持构造函数注入，还支持属性注入，属性注入会在构造函数注入之后进行。&lt;br/&gt;必须要注意的是，必须在使用属性注入的服务上进行声明，&lt;br/&gt;例如，如果 DbService 需要支持属性注入，那么需要在注册该服务的时候进行声明。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;        builder.RegisterType&amp;lt;DbService&amp;gt; ().As&amp;lt;IDbService&amp;gt; ()
            .PropertiesAutowired()
            .InstancePerLifetimeScope ();
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;aspnet-core-中，对控制器进行属性注入的特殊处理&quot;&gt;ASP.NET Core 中，对控制器进行属性注入的特殊处理&lt;/h4&gt;
&lt;p&gt;默认情况下，ASP.NET Core 对于控制器并不是从容器中创建的，所以如果你检查容器中的注册，是看不到控制器的注册的。&lt;br/&gt;为了支持属性注入，需要让 ASP.NET Core 将控制器也注册到容器中。这可以在 AddControllers() 方法之后，调用 AddControllersAsServices() 来实现。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt; public void ConfigureServices (IServiceCollection services) {

            services.AddControllers()
                .AddControllersAsServices();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后，我们需要对控制器添加支持属性注入的声明。&lt;/p&gt;
&lt;p&gt;既可以针对单个的控制器类&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;// make property autowire at one controller
builder.RegisterType&amp;lt;WeatherForecastController&amp;gt;()
            .PropertiesAutowired();

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也可以针对所有的控制器。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt; // make property autowire at all api controller
 var controllerBaseType = typeof (ControllerBase);
 builder.RegisterAssemblyTypes (typeof (Program).Assembly)
            .Where (t =&amp;gt; controllerBaseType.IsAssignableFrom (t) &amp;amp;&amp;amp;
                t != controllerBaseType)
            .PropertiesAutowired ();

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;6-使用-aop-动态代理&quot;&gt;6. 使用 AOP 动态代理&lt;/h3&gt;
&lt;p&gt;使用 AOP 需要如下的 4 个步骤。&lt;/p&gt;
&lt;h4 id=&quot;1-定义拦截器&quot;&gt;1. 定义拦截器&lt;/h4&gt;
&lt;p&gt;拦截器的接口 IInterceptor 定义在命名空间 Castle.DynamicProxy 中，需要注意的是，它需要添加对 NuGet 包 Autofac.Extras.DynamicProxy 的引用。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;dotnet add package Autofac.Extras.DynamicProxy
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实现 IInterceptor 接口。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;using Castle.DynamicProxy;
using System;

 public class DbServiceInterceptor:IInterceptor  
    {  
        public virtual void Intercept(IInvocation invocation)  
        {  
            Console.WriteLine($&quot;{DateTime.Now}: Before method execting. &quot;);  
            invocation.Proceed();  
            Console.WriteLine($&quot;{DateTime.Now}: After method exected.&quot;);  
        }  
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;2-注册拦截器&quot;&gt;2. 注册拦截器&lt;/h4&gt;
&lt;p&gt;拦截器也同样需要注册到容器中。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;// register interceptor
builder.RegisterType&amp;lt;DbServiceInterceptor&amp;gt; ();
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;3-启用拦截器&quot;&gt;3. 启用拦截器&lt;/h4&gt;
&lt;p&gt;需要支持拦截器的服务需要启用拦截器，然后才能使用拦截器。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;        // register type, and enable interceptor injection
        builder.RegisterType&amp;lt;DbService&amp;gt; ().As&amp;lt;IDbService&amp;gt; ()
            .EnableInterfaceInterceptors ()
            .InstancePerLifetimeScope ();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以使用 EnableInterfaceInterceptors() 或者 EnableClassInterceptors() 扩展方法来启用拦截器。&lt;/p&gt;
&lt;p&gt;EnableInterfaceInterceptors() 创建接口代理来执行拦截，而 EnableClassInterceptors() 则创建目标组件的子类来执行拦截。&lt;/p&gt;
&lt;h4 id=&quot;4-使用拦截器&quot;&gt;4. 使用拦截器&lt;/h4&gt;
&lt;p&gt;第一种方式是在使用拦截器的服务上，通过特性来声明使用的拦截器。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;using Autofac.Extras.DynamicProxy;
using Castle.DynamicProxy;

[Intercept (typeof (DbServiceInterceptor))]
public class DbService : IDbService {

    public string Say () {
        return &quot;Hello&quot;;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当使用特性来关联拦截器的时候，不需要在注册服务的时候指定拦截器。你只需要启用，实际的拦截器将被自动发现。&lt;/p&gt;
&lt;p&gt;第二种方式是在注册服务的时候指定，使用 InterceptedBy() 扩展方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;builder.RegisterType&amp;lt;SomeType&amp;gt;()
       .EnableClassInterceptors()
       .InterceptedBy(typeof(CallLogger));
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用公共接口&lt;/li&gt;
&lt;li&gt;类拦截要求被拦截的方法是虚方法，因为使用了子类代理技术。&lt;/li&gt;
&lt;li&gt;通过表达式创建的服务，或者使用实例注册的服务，不能使用子类方式代理，此时，要使用接口代理。&lt;/li&gt;
&lt;li&gt;要使用接口代理，服务必须仅仅通过接口提供服务，为了最佳的性能，所有此类服务接口必须是注册的一部分，例如使用 .As 子句。&lt;/li&gt;
&lt;li&gt;如果通过 EnableClassInterceptors() 使用了类拦截，则避免使用构造函数选择器 UsingConstructor()。在使用类拦截的时候，会为代理类生成新的构造函数以获取你希望使用的拦截器。如果你使用了 UsingConstructor()，就会跳过此逻辑。导致拦截器不能被使用。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;已知问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;同步方法拦截。Castle 拦截器仅仅支持同步方法拦截。不支持显式的 async/await 方法。但是，async/await 是 Task 的语法糖，你可以在拦截器中使用 Task 和 ContinueWith() 之类的方法。 &lt;a href=&quot;https://github.com/castleproject/Core/issues/107&quot;&gt;This issue&lt;/a&gt; 展示了用法。另外，&lt;a href=&quot;https://github.com/JSkimming/Castle.Core.AsyncInterceptor&quot;&gt;这些助手类&lt;/a&gt; 也使得 async 工作更容易一点。&lt;/li&gt;
&lt;li&gt;Castle.Core 版本问题。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;参考资料&quot;&gt;参考资料&lt;/h3&gt;
&lt;/div&gt;</description>
<pubDate>Wed, 30 Sep 2020 11:47:00 +0000</pubDate>
<dc:creator>冠军</dc:creator>
<og:description>本文介绍了在 ASP.NET Core 应用中集成 Autofac 依赖注入容器，并介绍了拦截器的使用。 本文示例基于 .net core 5 实现。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/haogj/p/13683730.html</dc:identifier>
</item>
<item>
<title>Docker系列——利用gogs搭建属于自己的git服务 - 温一壶清酒</title>
<link>http://www.cnblogs.com/hong-fithing/p/13719941.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hong-fithing/p/13719941.html</guid>
<description>&lt;p&gt;Gogs的目标是打造一个最简单、最快速和最轻松的方式搭建自助Git服务。使用Go语言开发使得Gogs能够通过独立的二进制分发，并且支持Go语言支持的所有平台，包括 Linux、Mac OS X、Windows 以及 ARM 平台。&lt;/p&gt;
&lt;h2 id=&quot;功能特性&quot;&gt;功能特性&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;支持活动时间线&lt;/li&gt;
&lt;li&gt;支持 SSH 以及 HTTP/HTTPS 协议&lt;/li&gt;
&lt;li&gt;支持 SMTP、LDAP 和反向代理的用户认证&lt;/li&gt;
&lt;li&gt;支持反向代理子路径&lt;/li&gt;
&lt;li&gt;支持用户、组织和仓库管理系统&lt;/li&gt;
&lt;li&gt;支持添加和删除仓库协作者&lt;/li&gt;
&lt;li&gt;支持仓库和组织级别 Web 钩子（包括 Slack 集成）&lt;/li&gt;
&lt;li&gt;支持仓库 Git 钩子和部署密钥&lt;/li&gt;
&lt;li&gt;支持仓库工单（Issue）、合并请求（Pull Request）、Wiki 以及保护分支&lt;/li&gt;
&lt;li&gt;支持迁移和镜像仓库以及它的 Wiki&lt;/li&gt;
&lt;li&gt;支持在线编辑仓库文件和 Wiki&lt;/li&gt;
&lt;li&gt;支持自定义源的 Gravatar 和 Federated Avatar&lt;/li&gt;
&lt;li&gt;支持 Jupyter Notebook&lt;/li&gt;
&lt;li&gt;支持邮件服务&lt;/li&gt;
&lt;li&gt;支持后台管理面板&lt;/li&gt;
&lt;li&gt;支持 MySQL、PostgreSQL、SQLite3、MSSQL 和 TiDB（实验性支持） 数据库&lt;/li&gt;
&lt;li&gt;支持多语言本地化（22 种语言）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;拉取镜像&quot;&gt;拉取镜像&lt;/h2&gt;
&lt;p&gt;通过docker命令拉取gogs镜像&lt;/p&gt;
&lt;p&gt;使用命令操作如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;docker pull gogs/gogs&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;命令行操作如下所示：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1242227/202009/1242227-20200923175237763-212070323.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;新建gogs目录&quot;&gt;新建gogs目录&lt;/h2&gt;
&lt;p&gt;在/home/software下新建文件夹gogs&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1242227/202009/1242227-20200923175333679-35447870.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;进入/home/software路径下新建，命令如下：&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;p&gt;mkdir gogs&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;在根目录下直接新建，命令如下：&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;p&gt;mkdir home/software/gogs&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;创建多级目录，命令如下：&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;p&gt;mkdir -p software/gogs&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;开放服务器端口&quot;&gt;开放服务器端口&lt;/h2&gt;
&lt;p&gt;配置端口在服务器的安全组中进行配置，开放的端口，用于gogs/docker服务端口进行映射。&lt;/p&gt;
&lt;h2 id=&quot;启动服务&quot;&gt;启动服务&lt;/h2&gt;
&lt;p&gt;启动服务命令如下：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;docker run --name=gogs -p 8234:22 -p 8235:3000 -v /home/software/gogs:/data gogs/gogs&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;参数说明:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;-p: 端口映射,将容器的22端口映射到宿主机的1006端口,将容器的3000端口映射到宿主机的1007端口&lt;/li&gt;
&lt;li&gt;-name: 指定容器名称&lt;/li&gt;
&lt;li&gt;-net: 将容器加入backend网络,目的是为了能够连接backend网络中的mysql数据库&lt;/li&gt;
&lt;li&gt;-v: 数据卷挂载, 用于将容器和数据分离&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;启动操作如下所示：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1242227/202009/1242227-20200923175400311-557724600.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;安装配置&quot;&gt;安装配置&lt;/h2&gt;
&lt;p&gt;通过地址访问，格式为：&lt;a href=&quot;http://xn--ip+-4w2er1dq0gkxmslu12br43g/install%EF%BC%8C&quot;&gt;http://服务器ip+映射端口/install，&lt;/a&gt;&lt;br/&gt;如：&lt;a href=&quot;http://101.111.22.31:8235/install%EF%BC%8C&quot;&gt;http://101.111.22.31:8235/install，&lt;/a&gt;&lt;br/&gt;访问进入如下页面，进行配置数据：&lt;/p&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;配置数据库&lt;br/&gt;数据库类型选择为SQLite3，免配置，直接使用。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1242227/202009/1242227-20200923175440904-1517304354.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;基本信息配置&lt;br/&gt;基本信息中，配置信息如下所示：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1242227/202009/1242227-20200923175454690-758451546.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1242227/202009/1242227-20200923180044012-1899461049.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;应用名称：支持自定义，可维护成自己的专属名称&lt;/li&gt;
&lt;li&gt;仓库根目录：默认即可&lt;/li&gt;
&lt;li&gt;运行系统用户：也默认即可&lt;/li&gt;
&lt;li&gt;域名：服务器的公网地址，如：&lt;a href=&quot;http://101.111.22.31&quot;&gt;http://101.111.22.31&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;SSH端口号：服务器的映射端口，如：8234&lt;/li&gt;
&lt;li&gt;HTTP端口：监听端口默认为3000&lt;/li&gt;
&lt;li&gt;应用URL：公网地址+映射端口，如：&lt;a href=&quot;http://101.111.22.31:8235&quot;&gt;http://101.111.22.31:8235&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;日志路径：默认即可&lt;/li&gt;
&lt;/ul&gt;&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;可选配置&lt;br/&gt;可选配置，看个人所需，其他暂时不配置，配置管理员账号即可。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;配置完成后，访问地址，进入到登录页，如下所示：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1242227/202009/1242227-20200925170726936-371018642.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;注册登录&quot;&gt;注册&amp;amp;登录&lt;/h2&gt;
&lt;p&gt;在之前配置基础信息时，没配置管理员账号的话，在登录页，注册个账号便可以登录；如果有配置管理员账号，使用配置的账号直接登录即可。注册页面如下：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1242227/202009/1242227-20200925170908271-74012933.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;控制面板&quot;&gt;控制面板&lt;/h2&gt;
&lt;p&gt;控制面板界面如下所示：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1242227/202009/1242227-20200925175600999-799240120.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;左侧：个人的操作记录，比如：提交代码，创建合并请求，请求关闭...&lt;/li&gt;
&lt;li&gt;右侧：我的仓库：属于自己的仓库，拥有管理权限&lt;/li&gt;
&lt;li&gt;右侧：参与协作的仓库：参与的仓库，没有所有权，权限按仓库所属人进行分配&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;仓库管理&quot;&gt;仓库管理&lt;/h2&gt;
&lt;p&gt;仓库管理界面如下所示：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1242227/202009/1242227-20200925180022782-16795481.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在该页面，可以操作如下设置：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;基本设置，可配置仓库名称、可见性等&lt;/li&gt;
&lt;li&gt;管理协作者，添加仓库的协作者，一起维护仓库内容&lt;/li&gt;
&lt;li&gt;管理分支，配置默认分支和保护分支&lt;/li&gt;
&lt;li&gt;管理Web钩子，Gogs上发生指定事件时对指定 URL 发送 POST 通知&lt;/li&gt;
&lt;li&gt;管理Git钩子&lt;/li&gt;
&lt;li&gt;管理部署密钥&lt;/li&gt;
&lt;li&gt;转移仓库所有权&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;工单管理&quot;&gt;工单管理&lt;/h2&gt;
&lt;p&gt;工单管理界面如下所示：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1242227/202009/1242227-20200925180714406-1227710315.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在该页面，可以查看自己的以及指派给自己的工单，也可以查看工单状态，便捷管理。&lt;/p&gt;
&lt;h2 id=&quot;合并请求&quot;&gt;合并请求&lt;/h2&gt;
&lt;p&gt;合并请求界面如下所示：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1242227/202009/1242227-20200925180911248-1799155556.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在该页面，可以查看合并请求的状态。&lt;/p&gt;
&lt;h2 id=&quot;创建仓库&quot;&gt;创建仓库&lt;/h2&gt;
&lt;p&gt;创建仓库界面如下所示：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1242227/202009/1242227-20200925181232433-1685863794.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击面板中的+号，选择创建仓库，即可进入到该页面。具体创建自己操作一波就可以了，很简单。&lt;/p&gt;
&lt;h2 id=&quot;代码操作&quot;&gt;代码操作&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;克隆代码&lt;br/&gt;使用如下命令操作：&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;0.81967213114754&quot;&gt;
&lt;p&gt;git clone &lt;a href=&quot;http://101.111.22.31:8235/yihuqingjiu/Auto_Test.git&quot;&gt;http://101.111.22.31:8235/yihuqingjiu/Auto_Test.git&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;截图如下：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1242227/202009/1242227-20200930170942749-620816585.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;提交代码&lt;br/&gt;提交代码的操作，可以祥见这篇博文：&lt;a href=&quot;https://www.cnblogs.com/hong-fithing/p/12938287.html&quot;&gt;Git基本操作命令合集&lt;/a&gt;，这里就不赘述了。提交代码后，可以在面板中查看，如下所示：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1242227/202009/1242227-20200930171528695-396940421.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;配置gogs基础信息时，想使用本地的Mysql数据库，但一直提示权限错误，没能解决，最终还是使用了免配置的sqlite3。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;想使用ssh方式拉取代码，在服务器端，生成的公钥，一直提示失败，也没能解决，报错提示信息：invalid key format: illegal base64 data at input byte 171。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;以上就是今天分享的内容，如有博友遇到如上2个问题，望告知一二，祝大家双节快乐。&lt;/p&gt;
</description>
<pubDate>Wed, 30 Sep 2020 09:23:00 +0000</pubDate>
<dc:creator>温一壶清酒</dc:creator>
<og:description>gogs简介 Gogs的目标是打造一个最简单、最快速和最轻松的方式搭建自助Git服务。使用Go语言开发使得Gogs能够通过独立的二进制分发，并且支持Go语言支持的所有平台，包括 Linux、Mac O</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hong-fithing/p/13719941.html</dc:identifier>
</item>
<item>
<title>深度学习中“过拟合”的产生原因和解决方法 - 凌逆战</title>
<link>http://www.cnblogs.com/LXP-Never/p/13755354.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/LXP-Never/p/13755354.html</guid>
<description>&lt;p&gt;过拟合定义：模型在训练集上的表现很好，但在测试集和新数据上的表现很差。&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;训练集上的表现&lt;/td&gt;
&lt;td&gt;测试集上的表现&lt;/td&gt;
&lt;td&gt;结论&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;不好&lt;/td&gt;
&lt;td&gt;不好&lt;/td&gt;
&lt;td&gt;欠拟合&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;好&lt;/td&gt;
&lt;td&gt;不好&lt;/td&gt;
&lt;td&gt;过拟合&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;好&lt;/td&gt;
&lt;td&gt;好&lt;/td&gt;
&lt;td&gt;适度拟合&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;训练数据集太小，过拟合出现的原因：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;模型复杂度过高，参数过多&lt;/li&gt;
&lt;li&gt;数量数据比较小&lt;/li&gt;
&lt;li&gt;训练集和测试集分布不一致
&lt;ol&gt;&lt;li&gt;样本里面的噪声数据干扰过大，导致模型过分记住了噪声特征，反而忽略了真实的输入输出特征&lt;/li&gt;
&lt;li&gt;训练集和测试集特征分布不一样（如果训练集和测试集使用了不同类型的数据集会出现这种情况）&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、降低模型复杂度&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　处理过拟合的第一步就是降低模型复杂度。为了降低复杂度，我们可以简单地移除层或者减少神经元的数量使得网络规模变小。与此同时，计算神经网络中不同层的输入和输出维度也十分重要。虽然移除层的数量或神经网络的规模并无通用的规定，但如果你的神经网络发生了过拟合，就尝试缩小它的规模。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、增加更多数据&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　使用大数据集训练模型&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3、数据增强&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　使用数据增强可以生成多幅相似图像。这可以帮助我们增加数据集规模从而减少过拟合。因为随着数据量的增加，模型无法过拟合所有样本，因此不得不进行泛化。计算机视觉领域通常的做法有：翻转、平移、旋转、缩放、改变亮度、添加噪声等等&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4、&lt;a href=&quot;https://blog.csdn.net/u010899985/article/details/79471909?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param&amp;amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;正则化&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　在损失函数后面加一个正则化项，常见的有L1正则化和L2正则化&lt;/p&gt;
&lt;p&gt;L1惩罚项的目的是使权重绝对值最小化。公式如下：&lt;/p&gt;
&lt;p&gt;$$L(x, y) \equiv \sum_{i=1}^{n}\left(y_{i}-h_{\theta}\left(x_{i}\right)\right)^{2}+\lambda \sum_{i=1}^{n}\left|\theta_{i}\right|$$&lt;/p&gt;
&lt;p&gt;L2惩罚项的目的是使权重的平方最小化。公式如下：&lt;/p&gt;
&lt;p&gt;$$L(x, y) \equiv \sum_{i=1}^{n}\left(y_{i}-h_{\theta}\left(x_{i}\right)\right)^{2}+\lambda \sum_{i=1}^{n} \theta_{i}^{2}$$&lt;/p&gt;
&lt;p&gt;以下表格对两种正则化方法进行了对比:&lt;/p&gt;
&lt;table cellspacing=&quot;0&quot;&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;277&quot;&gt;L1正则化&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;277&quot;&gt;L2正则化&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;277&quot;&gt;1. L1惩罚权重绝对值的总和&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;277&quot;&gt;1. L2惩罚权重平方和的总和&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;277&quot;&gt;2. L1生成简单、可解释的模型&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;277&quot;&gt;2. L2正则化能够学习复杂数据模式&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;277&quot;&gt;3. L1受极端值影响较小&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;277&quot;&gt;3. L2受极端值影响较大&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;　　如果数据过于复杂以至于无法准确地建模，那么L2是更好的选择，因为它能够学习数据中呈现的内在模式。而当数据足够简单，可以精确建模的话，L1更合适。对于我遇到的大多数计算机视觉问题，L2正则化几乎总是可以给出更好的结果。然而L1不容易受到离群值的影响。所以正确的正则化选项取决于我们想要解决的问题。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;5、dropout&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　dropout 是一种避免神经网络过拟合的正则化技术。像L1和L2这样的正则化技术通过修改代价函数来减少过拟合。而丢弃法修改神经网络本身。它在训练的每一次迭代过程中随机地丢弃神经网络中的神经元。当我们丢弃不同神经元集合的时候，就等同于训练不同的神经网络。不同的神经网络会以不同的方式发生过拟合，所以丢弃的净效应将会减少过拟合的发生。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1433301/202009/1433301-20200930170004003-479276499.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　如上图所示，丢弃法被用于在训练神经网络的过程中随机丢弃神经网络中的神经元。这种技术被证明可以减少很多问题的过拟合，这些问题包括图像分类、图像切割、词嵌入、语义匹配等问题。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;6、早停&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1433301/202009/1433301-20200930170321635-1054534217.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　如上图所示，在几次迭代后，即使训练误差仍然在减少，但测验误差已经开始增加了。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;7、重新清洗数据&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　把明显异常的数据剔除&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;8、使用集成学习方法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　把多个模型集成在一起，降低单个模型的过拟合风险&lt;/p&gt;

</description>
<pubDate>Wed, 30 Sep 2020 09:09:00 +0000</pubDate>
<dc:creator>凌逆战</dc:creator>
<og:description>过拟合定义：模型在训练集上的表现很好，但在测试集和新数据上的表现很差。 训练集上的表现 测试集上的表现 结论 不好 不好 欠拟合 好 不好 过拟合 好 好 适度拟合 原因 训练数据集太小，过拟合出现的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/LXP-Never/p/13755354.html</dc:identifier>
</item>
<item>
<title>腾讯云Elasticsearch集群规划及性能优化实践 - 腾讯云+社区</title>
<link>http://www.cnblogs.com/qcloud1001/p/13755469.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qcloud1001/p/13755469.html</guid>
<description>
&lt;p&gt;随着腾讯云 Elasticsearch 云产品功能越来越丰富，ES 用户越来越多，云上的集群规模也越来越大。我们在日常运维工作中也经常会遇到一些由于前期集群规划不到位，导致后期业务增长集群规模大了之后带来的各种各样的集群可用性及稳定性问题。&lt;/p&gt;

&lt;p&gt;这里列举下其中比较典型的几种集群规划问题：&lt;/p&gt;

&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;节点规格规划问题：集群数量很大，但是每个节点的配置很低；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;索引分片规划问题：索引很小，但是设置了几十个分片，或者索引很大，只设置了两三个分片；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;分片数量规划问题：集群中包含 10万+ 的分片。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;正所谓磨刀不误砍柴工，只有前期做好充分的集群评估规划工作，后期才能省去大量的运维工作。且能够长期保证集群的高可用和高稳定性。&lt;/p&gt;

&lt;p&gt;本文结合我们在给腾讯云 ES 集群日常运维工作中遇到的各种集群问题及总结沉淀的一些运维经验，来介绍下如何规划好集群容量及索引配置，以及所遵循的一些原则和经验。文章作者：吴容，腾讯云Elasticsearch研发工程师。&lt;/p&gt;




&lt;h2&gt;1. 集群规模评估&lt;/h2&gt;

&lt;h3&gt;（1）评估什么？&lt;/h3&gt;

&lt;p&gt;集群规模的评估主要评估以下三个方面：&lt;/p&gt;

&lt;p&gt;第一，计算资源评估，计算资源的评估主要是评估单节点的CPU和内存。&lt;/p&gt;

&lt;p&gt;ES的计算资源一般消耗在写入和查询过程，经过总结大量ES集群的运维经验，2C8G 的配置大概能支持 5k doc/s 的写入，32C64G 的配置大概能支撑 5w doc/s的写入能力。&lt;/p&gt;

&lt;p&gt;第二，存储资源评估，存储资源的评估主要是评估磁盘的类型及容量大小。&lt;/p&gt;

&lt;p&gt;例如ES集群使用什么类型的磁盘，SSD或者高性能云盘。以及每块盘的容量大小，是选择单盘多容量，还是多盘少容量。而对于冷热分离的集群，则默认使用SSD作为热节点，高性能云盘作为温节点。&lt;/p&gt;

&lt;p&gt;另外腾讯云ES支持单节点挂载多块云硬盘，且经过性能压测，3块盘相比于1块盘，吞吐量大约有2.8倍的提升。因此如果对写入速度及IO性能要求较高，可选择挂载多块 SSD 磁盘。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-5550c899335c6f64c07add185a5e8ce1d51.png&quot; alt=&quot;&quot; width=&quot;638&quot; height=&quot;593&quot; class=&quot;zoom-in-cursor&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;ES冷热分离多盘集群示意图&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;第三，节点数量评估，节点数量的评估主要是评估集群数据节点的数量。&lt;/p&gt;

&lt;p&gt;在同等集群性能的情况下，建议优先选择高配置少节点的集群。例如 32C64G*3 节点的集群相比于 8C16G*12 节点的集群，在集群稳定性和扩容的便捷性上都有一定的优势。&lt;/p&gt;

&lt;p&gt;因为高配置的集群如果遇到性能瓶颈需要扩容，则只需要横向扩容，即向集群中加入更多同等配置的节点即可；而低配置的集群在扩容节点配置时，则需要纵向扩容。&lt;/p&gt;

&lt;p&gt;目前云上的纵向扩容方式有两种：&lt;/p&gt;

&lt;p&gt;第一种是滚动重启方式扩容，这对集群稳定性会有一定的影响。&lt;/p&gt;

&lt;p&gt;第二种是数据迁移方式扩容，其原理是先向集群中加入同等数量的高配置节点，然后将低配置节点上的数据迁移到新节点上，最后再将低配置节点剔除集群，所以这种扩容流程时间会比较长，且成本较高。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-d333d2cd81346f053901016ebc83f41d6d3.png&quot; alt=&quot;&quot; width=&quot;765&quot; height=&quot;321&quot; class=&quot;zoom-in-cursor&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;数据迁移方式纵向扩容示意图&lt;/em&gt;&lt;/p&gt;

&lt;h3&gt;（2）根据什么评估？&lt;/h3&gt;

&lt;p&gt;集群规模评估主要根据以下三点来评估：&lt;/p&gt;

&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;（3）集群规模评估准则&lt;/h3&gt;

&lt;p&gt;这里结合我们的运维经验，给出集群规模评估的几点参考建议：&lt;/p&gt;

&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;32C64G单节点配置通常可承载5W次/s的写入；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;写入量和数据量较大时，优先选择32C64G的节点配置；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;1T的数据量预计需消耗2-4GB的内存空间；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;搜索场景优先选择大内存节点配置；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;存储容量 = 源数据 * (1 + 副本数量) * 1.45 * （1 + 预留空间） ≈ 源数据 * (1 + 副本数量) * 2.2.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;2. 索引配置评估&lt;/h2&gt;

&lt;h3&gt;（1）评估什么？&lt;/h3&gt;

&lt;p&gt;索引配置的评估主要评估两点：&lt;/p&gt;

&lt;p&gt;第一，如何划分索引？&lt;/p&gt;

&lt;p&gt;在使用 index 时，建议做好定期切换索引的计划。对于日志场景来说，写入不大的情况下建议按天创建索引，而写入较大的情况下，则建议按小时创建索引。&lt;/p&gt;

&lt;p&gt;定期滚动索引的好处主要包括：能够控制单个索引的大小，提升读写性能；同时能够方式单个索引太大，影响故障恢复的时间；另外也能避免热索引过大，从而影响快照备份恢复的时间。&lt;/p&gt;

&lt;p&gt;第二，如何设置索引主分片数？&lt;/p&gt;

&lt;p&gt;云上的索引主分片数默认是5个，具体的大小则需要业务根据具体的场景及数据量来优化。下面会给出具体的一些准则和经验。&lt;/p&gt;

&lt;h3&gt;（2）根据什么评估？&lt;/h3&gt;

&lt;p&gt;索引配置的评估同样也要结合具体的业务场景及索引的数据量来评估，尤其是单日新增的数据量。&lt;/p&gt;

&lt;h3&gt;（3）索引配置评估准则&lt;/h3&gt;

&lt;p&gt;索引配置的评估可根据下面几点准则进行评估：&lt;/p&gt;

&lt;ul readability=&quot;5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;单个分片大小控制在 30-50GB；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;集群总分片数量控制在 3w 以内；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;1GB 的内存空间支持 20-30 个分片为佳；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;一个节点建议不超过 1000 个分片；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;索引分片数量建议和节点数量保持一致；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;集群规模较大时建议设置专用主节点；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;专用主节点配置建议在 8C16G 以上；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如果是时序数据，建议结合冷热分离+ILM 索引生命周期管理。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;特别需要说明的是集群分片总数的大小控制上，我们经过一些性能测试发现：当集群的总分片数超过 10w 个以后，创建索引时间会增长到分钟级。&lt;/p&gt;

&lt;p&gt;尤其是对于写入量在百万 qps 以上的集群，如果总分片数在 10W+，且索引是自动创建的，那么就经常会在每次切换新索引时候，出现写入陡降、集群不可用的情况。&lt;/p&gt;

&lt;p&gt;下面这张图是云上一个 100个节点，总分片数在 11W+ 的集群。每天 8点切换新索引时，写入直接掉0，集群不可用时间在数小时不等。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-ed0f45a95a9ca66c2f1d440b95e27499d7b.png&quot; alt=&quot;&quot; width=&quot;1620&quot; height=&quot;527&quot; class=&quot;zoom-in-cursor&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;集群每天8点写入性能受到影响&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;对于这种问题，我们腾讯云ES团队也有一些非常成熟的优化方案。&lt;/p&gt;

&lt;p&gt;其中对于每天八点切换新索引时写入陡降的问题，可通过提前创建索引来解决，且建议使用固定的 index mapping，避免大量的 put-mapping 元数据更新操作。因为对于这种节点数量和总分片数量都很大的集群来说，更新元数据是一个非常消耗性能的操作。&lt;/p&gt;

&lt;p&gt;对于总分片数超过 10W 的问题，这种一般在日志分析场景中较为常见，如果历史数据不是很重要，则可定期删除历史索引即可。&lt;/p&gt;

&lt;p&gt;而对于历史数据较为重要，任何数据都不能删除的场景，则可通过冷热分离架构+索引生命周期管理功能，将7天之前的数据存储到温节点，且在索引数据从热节点迁移到温节点时，通过 Shrink 来将主分片个数降低到一个较小的值，并且可将温节点数据通过快照方式备份到腾讯云COS中，然后将温节点上索引的副本设置为0，这样便可进一步降低集群中的总分片数量。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-4a2264364df3731905d96701a5f2ec9edcd.png&quot; alt=&quot;&quot; width=&quot;758&quot; height=&quot;369&quot; class=&quot;zoom-in-cursor&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;冷热分离+ILM+COS备份集群架构&lt;/em&gt;&lt;/p&gt;


&lt;p&gt;&lt;br/&gt; &lt;/p&gt;
&lt;p&gt;ES集群的写入性能受到很多因素的影响，下面是一些写入性能方面的优化建议：&lt;/p&gt;

&lt;h2&gt;1. 写入数据不指定doc_id，让 ES 自动生成&lt;/h2&gt;

&lt;p&gt;索引中每一个 doc 都有一个全局唯一的 doc_id，这个 doc_id 可自定义，也可以让ES自动生成。&lt;/p&gt;

&lt;p&gt;如果自定义的话，则ES在写入过程中会多一步判断的过程，即先Get下该 doc_id 是否已经存在。如果存在的话则执行 Update 操作，不存在则创建新的 doc。&lt;/p&gt;

&lt;p&gt;因此如果我们对索引 doc_id 没有特别要求，则建议让ES自动生成 doc_id，这样可提升一定的写入性能。&lt;/p&gt;

&lt;h2&gt;2. 对于规模较大的集群，建议提前创建好索引，且使用固定的 Index mapping&lt;/h2&gt;

&lt;p&gt;这一条优化建议在上面也提到了，因为创建索引及新加字段都是更新元数据操作，需要 master 节点将新版本的元数据同步到所有节点。&lt;/p&gt;

&lt;p&gt;因此在集群规模比较大，写入qps较高的场景下，特别容易出现master更新元数据超时的问题，这可导致 master 节点中有大量的 pending_tasks 任务堆积，从而造成集群不可用，甚至出现集群无主的情况。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-2af5d2c7a95f4ee13c2658db2200b9a92d1.png&quot; alt=&quot;&quot; width=&quot;1620&quot; height=&quot;482&quot; class=&quot;zoom-in-cursor&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;更新集群元数据超时&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-1fbde551f24f74fc5d5e8406423c05c7a44.png&quot; alt=&quot;&quot; width=&quot;1190&quot; height=&quot;794&quot; class=&quot;zoom-in-cursor&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;集群大量pending_tasks任务堆积&lt;/em&gt;&lt;/p&gt;

&lt;h2&gt;3. 对于数据实时性要求不高的场景，适当增加 refresh_interval 时间&lt;/h2&gt;

&lt;p&gt;ES默认的 refresh_interval 是1s，即 doc 写入1s后即可被搜索到。&lt;/p&gt;

&lt;p&gt;如果业务对数据实时性要求不高的话，如日志场景，可将索引模版的 refresh_interval 设置成30s，这能够避免过多的小 segment 文件的生成及段合并的操作。&lt;/p&gt;

&lt;h2&gt;4. 对于追求写入效率的场景，可以将正在写入的索引设置为单副本，写入完成后打开副本&lt;/h2&gt;

&lt;p&gt;越来越多的外部客户正选择将自建的ES集群迁移到腾讯云上来，客户通常是使用 logstash 来迁移数据，由于自建集群中完整保留了数据，因此这时候可以将云上的正在写入的索引副本设置为0， 这样可最快完成集群迁移工作。数据迁移完成后再将副本打开即可。&lt;/p&gt;

&lt;h2&gt;5. 使用 Bulk 接口批量写入数据，每次 bulk 数据量大小控制在 10M 左右&lt;/h2&gt;

&lt;p&gt;ES为了提升写入性能，提供了 Bulk 批量写入的API，通常客户端会准备好一批数据往ES中写入，ES收到 Bulk 请求后则根据routing 值进行分发，将该批数据组装成若干分子集，然后异步得发送给各分片所在的节点。&lt;/p&gt;

&lt;p&gt;这样能够大大降低写入请求时的网络交互和延迟。通常我们建议一次Bulk的数据量控制在10M以下，一次Bulk的doc数在 10000 上下浮动。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-0a1e8c2bf41c7e1520078bf069f37f49900.png&quot; alt=&quot;&quot; width=&quot;454&quot; height=&quot;373&quot; class=&quot;zoom-in-cursor&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;ES Bulk请求示意图&lt;/em&gt;&lt;/p&gt;

&lt;h2&gt;6. 使用自定义 routing 功能，尽量将请求转发到较少的分片&lt;/h2&gt;

&lt;p&gt;上面我们提到ES提供了Bulk接口支持将数据批量写入到索引，虽然协调节点是异步得将数据发送给所有的分片，但是却需要等待所有的分片响应后才能返回给客户端，因此一次Bulk的延迟则取决于响应最慢的那个分片所在的节点。这就是分布式系统的长尾效应。&lt;/p&gt;

&lt;p&gt;因此，我们可以自定义 routing 值，将一次Bulk尽量转发到较少的分片上。  &lt;/p&gt;
&lt;pre class=&quot;hljs properties&quot;&gt;
&lt;code&gt;&lt;span class=&quot;hljs-attr&quot;&gt;POST &lt;span class=&quot;hljs-string&quot;&gt;_bulk?routing=user_id&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-15816a8a20541d5787f1cb6849b591bf2cc.png&quot; alt=&quot;&quot; width=&quot;557&quot; height=&quot;452&quot; class=&quot;zoom-in-cursor&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;自定义routing&lt;/em&gt;&lt;/p&gt;

&lt;h2&gt;7. 尽量选择 SSD 磁盘类型，并且可选择挂载多块云硬盘&lt;/h2&gt;

&lt;p&gt;云上目前提供多种类型的磁盘可用选择，其中1T的 SSD 云盘吞吐量为 260M/s，高性能云盘为 150M/s。因此使用SSD磁盘对于写入性能和IO性能都会有一定的提升。&lt;/p&gt;

&lt;p&gt;另外腾讯云现在也提供了多盘的能力，相对于单盘节点来说，3块盘的吞吐量大约有2.8倍的提升。&lt;/p&gt;

&lt;h2&gt;8. 冻结历史索引，释放更多的内存空间&lt;/h2&gt;

&lt;p&gt;我们知道ES的索引有三种状态，分别是 Open状态、Frozen状态和 Close状态。如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-022fa9d18a492ce61e9ca2a3f14c068bcd0.png&quot; alt=&quot;&quot; width=&quot;928&quot; height=&quot;338&quot; class=&quot;zoom-in-cursor&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;ES索引的三种状态&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Open状态的索引由于是通过将倒排索引以FST数据结构的方式加载进内存中，因此索引是能够被快速搜索的，且搜索速度也是最快的。&lt;/p&gt;

&lt;p&gt;但是需要消耗大量的内存空间，且这部分内存为常驻内存，不会被GC的。1T的索引预计需要消耗2-4GB的JVM堆内存空间。&lt;/p&gt;

&lt;p&gt;Frozen状态的索引特点是可被搜索，但是由于它不占用内存，只是存储在磁盘上，因此冻结索引的搜索速度是相对比较慢的。如果我们集群中的数据量比较大，历史数据也不能被删除，则可以考虑使用下面的API将历史索引冻结起来，这样便可释放出较多的内存空间。&lt;/p&gt;
&lt;pre class=&quot;hljs properties&quot;&gt;
&lt;code&gt;&lt;span class=&quot;hljs-attr&quot;&gt;POST &lt;span class=&quot;hljs-string&quot;&gt;/index_name/_freeze&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;对于冻结索引的搜索，可以在API中指定 ignore_throttled=false 参数：&lt;/p&gt;

&lt;pre class=&quot;hljs rust&quot;&gt;
&lt;code&gt;GET /index_name/_search?ignore_throttled=&lt;span class=&quot;hljs-literal&quot;&gt;false
{
 &lt;span class=&quot;hljs-string&quot;&gt;&quot;query&quot;: {
   &lt;span class=&quot;hljs-string&quot;&gt;&quot;match&quot;: {
     &lt;span class=&quot;hljs-string&quot;&gt;&quot;name&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;wurong&quot;
   }
 }
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;上面介绍了一些较为常见的写入性能优化的建议和经验，但是更为高效的优化还需要结合具体的业务场景和集群规模。&lt;/p&gt;




&lt;h2&gt;1. 查看集群健康状态&lt;/h2&gt;

&lt;p&gt;ES集群的健康状态分为三种，分别是Green、Yellow和Red。&lt;/p&gt;

&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Green(绿色)：全部主&amp;amp;副本分片分配成功；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Yellow(黄色)：至少有一个副本分片未分配成功；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Red(红色)：至少有一个主分片未分配成功。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们可以通过下面的API来查询集群的健康状态及未分配的分片个数：&lt;/p&gt;

&lt;pre class=&quot;hljs yaml&quot;&gt;
&lt;code&gt;&lt;span class=&quot;hljs-string&quot;&gt;GET &lt;span class=&quot;hljs-string&quot;&gt;_cluster/health
&lt;span class=&quot;hljs-string&quot;&gt;{
  &lt;span class=&quot;hljs-attr&quot;&gt;&quot;cluster_name&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;es-xxxxxxx&quot;&lt;span class=&quot;hljs-string&quot;&gt;,
  &lt;span class=&quot;hljs-attr&quot;&gt;&quot;status&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;yellow&quot;&lt;span class=&quot;hljs-string&quot;&gt;,
  &lt;span class=&quot;hljs-attr&quot;&gt;&quot;timed_out&quot;: &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;span class=&quot;hljs-string&quot;&gt;,
  &lt;span class=&quot;hljs-attr&quot;&gt;&quot;number_of_nodes&quot;: &lt;span class=&quot;hljs-number&quot;&gt;103&lt;span class=&quot;hljs-string&quot;&gt;,
  &lt;span class=&quot;hljs-attr&quot;&gt;&quot;number_of_data_nodes&quot;: &lt;span class=&quot;hljs-number&quot;&gt;100&lt;span class=&quot;hljs-string&quot;&gt;,
  &lt;span class=&quot;hljs-attr&quot;&gt;&quot;active_primary_shards&quot;: &lt;span class=&quot;hljs-number&quot;&gt;4610&lt;span class=&quot;hljs-string&quot;&gt;,
  &lt;span class=&quot;hljs-attr&quot;&gt;&quot;active_shards&quot;: &lt;span class=&quot;hljs-number&quot;&gt;9212&lt;span class=&quot;hljs-string&quot;&gt;,
  &lt;span class=&quot;hljs-attr&quot;&gt;&quot;relocating_shards&quot;: &lt;span class=&quot;hljs-number&quot;&gt;0&lt;span class=&quot;hljs-string&quot;&gt;,
  &lt;span class=&quot;hljs-attr&quot;&gt;&quot;initializing_shards&quot;: &lt;span class=&quot;hljs-number&quot;&gt;0&lt;span class=&quot;hljs-string&quot;&gt;,
  &lt;span class=&quot;hljs-attr&quot;&gt;&quot;unassigned_shards&quot;: &lt;span class=&quot;hljs-number&quot;&gt;8&lt;span class=&quot;hljs-string&quot;&gt;,
  &lt;span class=&quot;hljs-attr&quot;&gt;&quot;delayed_unassigned_shards&quot;: &lt;span class=&quot;hljs-number&quot;&gt;0&lt;span class=&quot;hljs-string&quot;&gt;,
  &lt;span class=&quot;hljs-attr&quot;&gt;&quot;number_of_pending_tasks&quot;: &lt;span class=&quot;hljs-number&quot;&gt;0&lt;span class=&quot;hljs-string&quot;&gt;,
  &lt;span class=&quot;hljs-attr&quot;&gt;&quot;number_of_in_flight_fetch&quot;: &lt;span class=&quot;hljs-number&quot;&gt;0&lt;span class=&quot;hljs-string&quot;&gt;,
  &lt;span class=&quot;hljs-attr&quot;&gt;&quot;task_max_waiting_in_queue_millis&quot;: &lt;span class=&quot;hljs-number&quot;&gt;0&lt;span class=&quot;hljs-string&quot;&gt;,
  &lt;span class=&quot;hljs-attr&quot;&gt;&quot;active_shards_percent_as_number&quot;: &lt;span class=&quot;hljs-number&quot;&gt;99.91323210412148
&lt;span class=&quot;hljs-string&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;其中需要重点关注的几个字段有 status、number_of_nodes、unassigned_shards 和 number_of_pending_tasks。&lt;/p&gt;

&lt;p&gt;number_of_pending_tasks 这个字段如果很高的话，通常是由于 master 节点触发的元数据更新操作，部分节点响应超时导致的大量的任务堆积。&lt;/p&gt;

&lt;p&gt;我们可以通过下面的API来查看具体有那些 task 需要执行：&lt;/p&gt;

&lt;pre class=&quot;hljs sql&quot;&gt;
&lt;code&gt;GET /_cat/pending_tasks
insertOrder timeInQueue priority source
       1685       855ms HIGH     &lt;span class=&quot;hljs-keyword&quot;&gt;update-&lt;span class=&quot;hljs-keyword&quot;&gt;mapping [foo][t]
       &lt;span class=&quot;hljs-number&quot;&gt;1686       &lt;span class=&quot;hljs-number&quot;&gt;843ms &lt;span class=&quot;hljs-keyword&quot;&gt;HIGH     &lt;span class=&quot;hljs-keyword&quot;&gt;update-&lt;span class=&quot;hljs-keyword&quot;&gt;mapping [foo][t]
       &lt;span class=&quot;hljs-number&quot;&gt;1693       &lt;span class=&quot;hljs-number&quot;&gt;753ms &lt;span class=&quot;hljs-keyword&quot;&gt;HIGH     &lt;span class=&quot;hljs-keyword&quot;&gt;refresh-&lt;span class=&quot;hljs-keyword&quot;&gt;mapping [foo][[t]]
       &lt;span class=&quot;hljs-number&quot;&gt;1688       &lt;span class=&quot;hljs-number&quot;&gt;816ms &lt;span class=&quot;hljs-keyword&quot;&gt;HIGH     &lt;span class=&quot;hljs-keyword&quot;&gt;update-&lt;span class=&quot;hljs-keyword&quot;&gt;mapping [foo][t]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;其中 priority 字段则表示该 task 的优先级，翻看 ES 的源码可以看到一共有六种优先级：&lt;/p&gt;

&lt;pre class=&quot;hljs less&quot;&gt;
&lt;code&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;IMMEDIATE((byte) &lt;span class=&quot;hljs-number&quot;&gt;0),
&lt;span class=&quot;hljs-selector-tag&quot;&gt;URGENT((byte) &lt;span class=&quot;hljs-number&quot;&gt;1),
&lt;span class=&quot;hljs-selector-tag&quot;&gt;HIGH((byte) &lt;span class=&quot;hljs-number&quot;&gt;2),
&lt;span class=&quot;hljs-selector-tag&quot;&gt;NORMAL((byte) &lt;span class=&quot;hljs-number&quot;&gt;3),
&lt;span class=&quot;hljs-selector-tag&quot;&gt;LOW((byte) &lt;span class=&quot;hljs-number&quot;&gt;4),
&lt;span class=&quot;hljs-selector-tag&quot;&gt;LANGUID((byte) &lt;span class=&quot;hljs-number&quot;&gt;5);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;h2&gt;2. 查看分片未分配原因&lt;/h2&gt;

&lt;p&gt;当集群Red时候，我们可以通过下面的API来查看分片未分配的原因：&lt;/p&gt;

&lt;pre class=&quot;hljs properties&quot;&gt;
&lt;code&gt;&lt;span class=&quot;hljs-attr&quot;&gt;GET &lt;span class=&quot;hljs-string&quot;&gt;_cluster/allocation/explain&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-2aa7bd6715f7b24344cd32db58abf838e78.png&quot; alt=&quot;&quot; width=&quot;959&quot; height=&quot;480&quot; class=&quot;zoom-in-cursor&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;查看分片未分配的原因&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;其中 index和shard 列出了具体哪个索引的哪个分片未分配成功。reason 字段则列出了哪种原因导致的分片未分配。这里也将所有可能的原因列出来：&lt;/p&gt;

&lt;pre class=&quot;hljs properties&quot;&gt;
&lt;code&gt;&lt;span class=&quot;hljs-attr&quot;&gt;INDEX_CREATED：由于创建索引的API导致未分配。

&lt;span class=&quot;hljs-attr&quot;&gt;CLUSTER_RECOVERED &lt;span class=&quot;hljs-string&quot;&gt;：由于完全集群恢复导致未分配。

&lt;span class=&quot;hljs-attr&quot;&gt;INDEX_REOPENED &lt;span class=&quot;hljs-string&quot;&gt;：由于打开open或关闭close一个索引导致未分配。

&lt;span class=&quot;hljs-attr&quot;&gt;DANGLING_INDEX_IMPORTED &lt;span class=&quot;hljs-string&quot;&gt;：由于导入dangling索引的结果导致未分配。

&lt;span class=&quot;hljs-attr&quot;&gt;NEW_INDEX_RESTORED &lt;span class=&quot;hljs-string&quot;&gt;：由于恢复到新索引导致未分配。

&lt;span class=&quot;hljs-attr&quot;&gt;EXISTING_INDEX_RESTORED &lt;span class=&quot;hljs-string&quot;&gt;：由于恢复到已关闭的索引导致未分配。

&lt;span class=&quot;hljs-attr&quot;&gt;REPLICA_ADDED：由于显式添加副本分片导致未分配。

&lt;span class=&quot;hljs-attr&quot;&gt;ALLOCATION_FAILED &lt;span class=&quot;hljs-string&quot;&gt;：由于分片分配失败导致未分配。

&lt;span class=&quot;hljs-attr&quot;&gt;NODE_LEFT &lt;span class=&quot;hljs-string&quot;&gt;：由于承载该分片的节点离开集群导致未分配。

&lt;span class=&quot;hljs-attr&quot;&gt;REINITIALIZED &lt;span class=&quot;hljs-string&quot;&gt;：由于当分片从开始移动到初始化时导致未分配（例如，使用影子shadow副本分片）。

&lt;span class=&quot;hljs-attr&quot;&gt;REROUTE_CANCELLED &lt;span class=&quot;hljs-string&quot;&gt;：作为显式取消重新路由命令的结果取消分配。

&lt;span class=&quot;hljs-attr&quot;&gt;REALLOCATED_REPLICA &lt;span class=&quot;hljs-string&quot;&gt;：确定更好的副本位置被标定使用，导致现有的副本分配被取消，出现未分配。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;detail 字段则列出了更为详细的未分配的原因。下面我会总结下在日常运维工作中常见的几种原因。&lt;/p&gt;

&lt;p&gt;如果未分配的分片比较多的话，我们也可以通过下面的API来列出所有未分配的索引和主分片：&lt;/p&gt;
&lt;pre class=&quot;hljs properties&quot;&gt;
&lt;code&gt;&lt;span class=&quot;hljs-attr&quot;&gt;GET &lt;span class=&quot;hljs-string&quot;&gt;/_cat/indices?v&amp;amp;health=red&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;h2&gt;3. 常见分片未分配原因总结&lt;/h2&gt;

&lt;h3&gt;（1）磁盘满了&lt;/h3&gt;
&lt;pre class=&quot;hljs less&quot;&gt;
&lt;code&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;the &lt;span class=&quot;hljs-selector-tag&quot;&gt;node &lt;span class=&quot;hljs-selector-tag&quot;&gt;is &lt;span class=&quot;hljs-selector-tag&quot;&gt;above &lt;span class=&quot;hljs-selector-tag&quot;&gt;the &lt;span class=&quot;hljs-selector-tag&quot;&gt;high &lt;span class=&quot;hljs-selector-tag&quot;&gt;watermark &lt;span class=&quot;hljs-selector-tag&quot;&gt;cluster &lt;span class=&quot;hljs-selector-tag&quot;&gt;setting &lt;span class=&quot;hljs-selector-attr&quot;&gt;[cluster.routing.allocation.disk.watermark.high=95%], &lt;span class=&quot;hljs-selector-tag&quot;&gt;using &lt;span class=&quot;hljs-selector-tag&quot;&gt;more &lt;span class=&quot;hljs-selector-tag&quot;&gt;disk &lt;span class=&quot;hljs-selector-tag&quot;&gt;space &lt;span class=&quot;hljs-selector-tag&quot;&gt;than &lt;span class=&quot;hljs-selector-tag&quot;&gt;the &lt;span class=&quot;hljs-selector-tag&quot;&gt;maximum &lt;span class=&quot;hljs-selector-tag&quot;&gt;allowed &lt;span class=&quot;hljs-selector-attr&quot;&gt;[95.0%], &lt;span class=&quot;hljs-selector-tag&quot;&gt;actual &lt;span class=&quot;hljs-selector-tag&quot;&gt;free: &lt;span class=&quot;hljs-selector-attr&quot;&gt;[4.055101177689788%]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;当我们执行 _cluster/allocation/explain 命令后看到上面的一行语句的话，则可以判断是该索引主分片所在的节点磁盘满了。&lt;/p&gt;

&lt;p&gt;解决方法：扩容磁盘提升磁盘容量或者删除历史数据释放磁盘空间。&lt;/p&gt;

&lt;p&gt;通常如果磁盘满了，ES为了保证集群的稳定性，会将该节点上所有的索引设置为只读。ES 7.x版本之后当磁盘空间提升后可自动解除，但是7.x版本之前则需要手动执行下面的API来解除只读模式：&lt;/p&gt;

&lt;pre class=&quot;hljs yaml&quot;&gt;
&lt;code&gt;&lt;span class=&quot;hljs-string&quot;&gt;PUT &lt;span class=&quot;hljs-string&quot;&gt;index_name/_settings
&lt;span class=&quot;hljs-string&quot;&gt;{
 &lt;span class=&quot;hljs-attr&quot;&gt;&quot;index&quot;: &lt;span class=&quot;hljs-string&quot;&gt;{
   &lt;span class=&quot;hljs-attr&quot;&gt;&quot;blocks&quot;: &lt;span class=&quot;hljs-string&quot;&gt;{
     &lt;span class=&quot;hljs-attr&quot;&gt;&quot;read_only_allow_delete&quot;: &lt;span class=&quot;hljs-literal&quot;&gt;null
    &lt;span class=&quot;hljs-string&quot;&gt;}
  &lt;span class=&quot;hljs-string&quot;&gt;}
&lt;span class=&quot;hljs-string&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3&gt;（2）分片的文档数超过了21亿条限制&lt;/h3&gt;

&lt;pre class=&quot;hljs properties&quot;&gt;
&lt;code&gt;&lt;span class=&quot;hljs-attr&quot;&gt;failure &lt;span class=&quot;hljs-string&quot;&gt;IllegalArgumentException[number of documents in the index cannot exceed 2147483519&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;该限制是分片维度而不是索引维度的。因此出现这种异常，通常是由于我们的索引分片设置的不是很合理。&lt;/p&gt;

&lt;p&gt;解决方法：切换写入到新索引，并修改索引模版，合理设置主分片数。&lt;/p&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;（3）主分片所在节点掉线&lt;/h3&gt;

&lt;pre class=&quot;hljs nginx&quot;&gt;
&lt;code&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;cannot allocate because a previous copy of the primary shard existed but can &lt;span class=&quot;hljs-literal&quot;&gt;no longer be found &lt;span class=&quot;hljs-literal&quot;&gt;on the nodes in the cluster&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;这种情况通常是由于某个节点故障或者由于负载较高导致的掉线。&lt;/p&gt;

&lt;p&gt;解决方法：找到节点掉线原因并重新启动节点加入集群，等待分片恢复。&lt;/p&gt;

&lt;h3&gt;（4）索引所需属性和节点属性不匹配&lt;/h3&gt;

&lt;pre class=&quot;hljs bash&quot;&gt;
&lt;code&gt;node does not match index setting [index.routing.allocation.require] filters [temperature:\&quot;warm\&quot;,_id:\&quot;comdNq4ZSd2Y6ycB9Oubsg\&quot;]&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;解决方法：重新设置索引所需的属性，和节点保持一致。因为如果重新设置节点属性，则需要重启节点，代价较高。&lt;/p&gt;

&lt;p&gt;例如通过下面的API来修改索引所需要分配节点的温度属性：&lt;/p&gt;

&lt;pre class=&quot;hljs python&quot;&gt;
&lt;code&gt;PUT /index_name/_settings
{
  &lt;span class=&quot;hljs-string&quot;&gt;&quot;index&quot;: {
    &lt;span class=&quot;hljs-string&quot;&gt;&quot;routing&quot;: {
      &lt;span class=&quot;hljs-string&quot;&gt;&quot;allocation&quot;: {
        &lt;span class=&quot;hljs-string&quot;&gt;&quot;require&quot;: {
          &lt;span class=&quot;hljs-string&quot;&gt;&quot;temperature&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;warm&quot;
        }
      }
    }
  }
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;h3&gt;（5）节点长时间掉线后重新加入集群，引入了脏数据&lt;/h3&gt;

&lt;pre class=&quot;hljs properties&quot;&gt;
&lt;code&gt;&lt;span class=&quot;hljs-attr&quot;&gt;cannot &lt;span class=&quot;hljs-string&quot;&gt;allocate because all found copies of the shard are either stale or corrupt&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;解决方法：通过reroute API来重新分配一个主分片：&lt;/p&gt;

&lt;pre class=&quot;hljs perl&quot;&gt;
&lt;code&gt;POST _cluster/reroute?pretty&lt;span class=&quot;hljs-string&quot;&gt;&quot; -d '{
    &quot;commands&lt;span class=&quot;hljs-string&quot;&gt;&quot; : [
        {
          &quot;allocate_stale_primary&lt;span class=&quot;hljs-string&quot;&gt;&quot; : {
              &quot;&lt;span class=&quot;hljs-keyword&quot;&gt;index&lt;span class=&quot;hljs-string&quot;&gt;&quot; : &quot;article&lt;span class=&quot;hljs-string&quot;&gt;&quot;, 
              &quot;shard&lt;span class=&quot;hljs-string&quot;&gt;&quot; : 1,
              &quot;node&lt;span class=&quot;hljs-string&quot;&gt;&quot; : &quot;&lt;span class=&quot;hljs-number&quot;&gt;98365000222032&lt;span class=&quot;hljs-string&quot;&gt;&quot;,
              &quot;accept_data_loss&lt;span class=&quot;hljs-string&quot;&gt;&quot;: true
          }
        }
    ]
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;h3&gt;（6）未分配分片太多，达到了分片恢复的阈值，其他分片排队等待&lt;/h3&gt;

&lt;pre class=&quot;hljs less&quot;&gt;
&lt;code&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;reached &lt;span class=&quot;hljs-selector-tag&quot;&gt;the &lt;span class=&quot;hljs-selector-tag&quot;&gt;limit &lt;span class=&quot;hljs-selector-tag&quot;&gt;of &lt;span class=&quot;hljs-selector-tag&quot;&gt;incoming &lt;span class=&quot;hljs-selector-tag&quot;&gt;shard &lt;span class=&quot;hljs-selector-tag&quot;&gt;recoveries &lt;span class=&quot;hljs-selector-attr&quot;&gt;[2], &lt;span class=&quot;hljs-selector-tag&quot;&gt;cluster &lt;span class=&quot;hljs-selector-tag&quot;&gt;setting &lt;span class=&quot;hljs-selector-attr&quot;&gt;[cluster.routing.allocation.node_concurrent_incoming_recoveries=2] (can also be set via [cluster.routing.allocation.node_concurrent_recoveries])&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;这种情况通常出现在集群重启，或者某一个节点重启后。且由于设置的分片并发恢复的值较低导致。为了尽快恢复集群健康状态。&lt;/p&gt;

&lt;p&gt;解决方法：可以通过调用下面的API来提升分片恢复的速度和并发度：&lt;/p&gt;

&lt;pre class=&quot;hljs python&quot;&gt;
&lt;code&gt;PUT /_cluster/settings
{
    &lt;span class=&quot;hljs-string&quot;&gt;&quot;transient&quot; : {
        &lt;span class=&quot;hljs-string&quot;&gt;&quot;cluster.routing.allocation.node_concurrent_recoveries&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;20&quot;,
        &lt;span class=&quot;hljs-string&quot;&gt;&quot;indices.recovery.max_bytes_per_sec&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;100mb&quot;
    }
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;



&lt;p&gt;本文介绍了集群规模和索引配置规划的评估准则，依据这些准则提前规划集群，可以保证集群的稳定性和可用性，简化复杂的运维工作。&lt;/p&gt;

&lt;p&gt;另外介绍了一些常见的写入性能优化的建议和方法。能够进一步提升集群的写入性能和稳定性。最后介绍了日常运维工作中常见的排查集群问题的方法和思路。希望本文能够帮助到腾讯云的每一个ES客户。&lt;/p&gt;
</description>
<pubDate>Wed, 30 Sep 2020 09:01:00 +0000</pubDate>
<dc:creator>腾讯云+社区</dc:creator>
<og:description>​一、引言 随着腾讯云 Elasticsearch 云产品功能越来越丰富，ES 用户越来越多，云上的集群规模也越来越大。我们在日常运维工作中也经常会遇到一些由于前期集群规划不到位，导致后期业务增长集群</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qcloud1001/p/13755469.html</dc:identifier>
</item>
<item>
<title>上手深度学习之前，我们先聊聊“数学” - 华为云开发者社区</title>
<link>http://www.cnblogs.com/huaweiyun/p/13755310.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huaweiyun/p/13755310.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;摘要：深度神经网络是建立在微积分和一些统计学的基础之上的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;深度神经网络（Deep neural network，DNN）本质上是由具有多个连接的感知器形成的，其中一个感知器是单个神经元。我们可以将人工神经网络（Artificial neural network，ANN）看作一个包含一组沿着加权路径馈送的输入系统。然后对这些输入进行处理，并产生一个输出来执行某些任务。随着时间的推移，人工神经网络将会“学习”，并发展出不同的路径。各种路径可以具有不同的权重，并且被认为更重要（或产生更理想结果）的路径在模型内被分配的权重比那些产生较少理想结果的路径更高。&lt;/p&gt;
&lt;p&gt;在深度神经网络中，如果所有的输入都密集地连接到所有的输出，那么这些层就称为 密集层（Dense layers）。此外，深度神经网络可以包含多个 隐藏层（Hidden layer）。隐藏层基本上是神经网络输入和输出之间的点，激活函数在这里对输入的信息进行转换。它之所以被称为隐藏层，是因为它不能直接从系统的输入和输出中观察到。神经网络的深度越深，网络能从数据中识别的信息就越多。&lt;/p&gt;
&lt;p&gt;然而，尽管从数据中学习尽可能多的信息是我们的目标，但深度学习模型可能会受到过拟合的影响。当模型从训练数据中学习了太多的信息，包括随机噪声时，就会出现这种情况。&lt;/p&gt;
&lt;p&gt;模型能够确定数据中非常复杂的模式，但这会对新数据的性能产生负面影响。训练数据中接收到的噪声并不适用于新的或未见过的数据，并且模型无法对所发现的模式进行泛化。非线性在深度学习模型中也是非常重要的。虽然模型会因为拥有多个隐藏层而学到很多信息，但将线性形式应用于非线性问题会导致性能低下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://picb.zhimg.com/80/v2-1a7caa3543338e70e87219024f7eca1c_720w.jpg&quot; width=&quot;875&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;875&quot; data-rawheight=&quot;423&quot; data-original=&quot;https://picb.zhimg.com/v2-1a7caa3543338e70e87219024f7eca1c_r.jpg&quot; data-actualsrc=&quot;https://picb.zhimg.com/v2-1a7caa3543338e70e87219024f7eca1c_b.jpg&quot; data-lazy-status=&quot;ok&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在，问题来了，“这些层是如何学习的？”那么，让我们将人工神经网络应用到一个真实的场景中去解决问题，以了解如何训练模型来完成目标。在目前全球新冠肺炎疫情之下，很多学校都过渡到了虚拟学习，这使得一些学生担心他们通过课程的机会。任何人工智能系统都应该能够解决“我能否通过这门课程”这种问题。&lt;/p&gt;
&lt;p&gt;为简单起见，让我们设想此模型只有 3 个输入：学生听课次数、花在作业上的时间，以及在整个授课过程中网络掉线的次数。这个模型的输出将是一个二元分类；学生要么通过课程，要么没通过课程。现在是学期末，学生 A 听了 21 堂课，花了 90 个小时完成作业，并且在这个学期中，网络掉线 7 次。这些输入被输入到模型中，输出预测学生有 5% 的机会通过课程。一个星期后，期末成绩公布，学生 A 通过了这门课程。那么，这个模型的预测出了什么问题呢？&lt;/p&gt;
&lt;p&gt;从技术上来说，并没有出问题。该模型本来可以按照目前开发的模型工作。但问题是，模型并不知道发生了什么。我们本来只是在路径上对一些权重进行了初始化，但模型目前并不知道什么是对的，什么是错的；因此，权重是不正确的。这就是学习的意义所在。我们的想法是，模型需要了解什么时候是错误的，我们通过计算某种形式的 &quot;损失 &quot;来实现这一点。计算的损失取决于当前的问题，但它通常涉及最小化预测输出和实际输出之间的差异。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://picb.zhimg.com/80/v2-712529bb632386900a6fd8ff3c887dab_720w.jpg&quot; width=&quot;875&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;875&quot; data-rawheight=&quot;553&quot; data-original=&quot;https://picb.zhimg.com/v2-712529bb632386900a6fd8ff3c887dab_r.jpg&quot; data-actualsrc=&quot;https://picb.zhimg.com/v2-712529bb632386900a6fd8ff3c887dab_b.jpg&quot; data-lazy-status=&quot;ok&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在上面的场景中，只有一个学生和一个误差点需要最小化。然而，通常情况却并非如此。现在，考虑到有多个学生和多个差异最小化。因此，总损失通常计算为所有预测值与实际观测值之差的平均值。&lt;/p&gt;
&lt;p&gt;回想一下，我在前面提到的被计算的损失取决于当前的问题。因此，由于我们当前的问题是二元分类，适当的损失计算将是 交叉熵损失。这个函数背后的想法是，它将学生是否会通过课程的预测分布与实际分布进行比较，并试图将这些分布之间的差异最小化。&lt;/p&gt;
&lt;p&gt;假设我们不再想预测学生是否能通过这门课程，而是现在想预测他们这门课的成绩。交叉熵损失将不再是一个合适的方法，相反，均方误差损失 将更合适。相反，均方误差损失会更合适。这种方法适用于回归问题，其想法是它将尝试最小化实际值和预测值之间的平方差。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pic3.zhimg.com/80/v2-ece1c03c9b4b77b8fad8a31d99459dc8_720w.jpg&quot; width=&quot;875&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;875&quot; data-rawheight=&quot;1099&quot; data-original=&quot;https://pic3.zhimg.com/v2-ece1c03c9b4b77b8fad8a31d99459dc8_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-ece1c03c9b4b77b8fad8a31d99459dc8_b.jpg&quot; data-lazy-status=&quot;ok&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在，我们了解了一些损失函数，就可以进入损失优化和模型训练了。拥有良好的深度神经网络的一个关键因素是拥有合适的权重。损失优化应该是土找到一组权重 $W$，它将使计算的损失最小化。如果只有一个权重分量，则可以在二维图上绘制权重和损失，然后选择使损失最小的权重。然而，大多数深度神经网络具有多个权重分量，将一个 $n$ 维图进行可视化是非常困难的。&lt;/p&gt;
&lt;p&gt;取而代之的是，计算损失函数相对于所有权重的导数来确定最大上升方向。既然模型现在已经理解上行和下行的方向，它就会向下行进，直到在局部最小值处到达收敛点。一旦这个下降点完成，就会返回一组最优权重，这就是深度神经网络应该使用的权重（假设模型开发得很好）。&lt;/p&gt;
&lt;p&gt;计算这个导数的过程被称为 反向传播（Back propagation），它本质上是微积分的链式法则。考虑到上面显示的神经网络，第一组权重的微小变化是如何影响最终损失的？这就是导数或梯度试图解释的内容。但是，第一组权值被输入到一个隐藏层，然后隐藏层有另一组权值导致预测的输出和损失。因此，也应该考虑权重变化对隐藏层的影响。这是网络中仅有的两个部分。但是，如果有更多的权重需要考虑，这个过程可以通过将链式规则从输出应用到输入来继续这一过程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pic2.zhimg.com/80/v2-e7c09f5326beb1da343382f61c178bfa_720w.jpg&quot; width=&quot;875&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;875&quot; data-rawheight=&quot;764&quot; data-original=&quot;https://pic2.zhimg.com/v2-e7c09f5326beb1da343382f61c178bfa_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-e7c09f5326beb1da343382f61c178bfa_b.jpg&quot; data-lazy-status=&quot;ok&quot;/&gt;&lt;/p&gt;
&lt;p&gt;训练深度神经网络时要考虑的另一个重要因素是学习率。当模型在寻找一个最优的权值集时，它需要通过一些因子来更新它的权重。虽然这看起来微不足道，但是决定模型应该移动的因子是相当困难的。如果因子太小，那么模型可能会运行一段指数级的时间，或者陷入某个不是全局最小值的地方。如果因子太大，那么模型可能会完全偏离目标点，进而发散。&lt;/p&gt;
&lt;p&gt;虽然固定的学习率可能是理想的，但 自适应学习率（Adaptive learning rate）会减少出现前文所提到的问题的机会。也就是说，因子将根据当前梯度、当前权重的大小或可能影响模型下一步查找最佳权重的位置的某些其他因素而发生变化。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pic4.zhimg.com/80/v2-69efe15332d710c12ab6c4a130c67de8_720w.jpg&quot; width=&quot;499&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;499&quot; data-rawheight=&quot;536&quot; data-original=&quot;https://pic4.zhimg.com/v2-69efe15332d710c12ab6c4a130c67de8_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-69efe15332d710c12ab6c4a130c67de8_b.jpg&quot; data-lazy-status=&quot;ok&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看出，深度神经网络是建立在微积分和一些统计学的基础之上的。评估这些过程背后的数学非常有用，因为它可以帮助人们了解模型内部真正发生的事情，这可以导致开发更好的整体模型。但是，即使这些概念不容易理解，大多数程序都附带了自动微分等工具，所以不用担心。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a title=&quot;&quot; href=&quot;https://bbs.huaweicloud.com/blogs?utm_source=juejin&amp;amp;utm_medium=bbs-ex&amp;amp;utm_campaign=other&amp;amp;utm_content=content&quot; data-type=&quot;link&quot; data-id=&quot;link534533&quot;&gt;点击关注，第一时间了解华为云新鲜技术~&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 30 Sep 2020 08:42:00 +0000</pubDate>
<dc:creator>华为云开发者社区</dc:creator>
<og:description>摘要：深度神经网络是建立在微积分和一些统计学的基础之上的。 深度神经网络（Deep neural network，DNN）本质上是由具有多个连接的感知器形成的，其中一个感知器是单个神经元。我们可以将人</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/huaweiyun/p/13755310.html</dc:identifier>
</item>
</channel>
</rss>