<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>营口6378.7939(薇)xiaojie:营口哪里有xiaomei - 德云社</title>
<link>http://www.cnblogs.com/bvfnn/p/13824384.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bvfnn/p/13824384.html</guid>
<description>[unable to retrieve full-text content]营口哪里有小姐服务大保健【微信:6378.7939倩儿小妹【营口叫小姐服务√o服务微信:6378.7939倩儿小妹【营口叫小姐服务】【十微信:6378.7939倩儿小妹】【营口叫小姐包夜服务】【十微信:6378.7939倩儿小妹】【营口小姐多少钱一晚】【红灯区上门服务微信:6378.7939倩儿小妹</description>
<pubDate>Fri, 16 Oct 2020 00:39:00 +0000</pubDate>
<dc:creator>德云社</dc:creator>
<dc:identifier>http://www.cnblogs.com/bvfnn/p/13824384.html</dc:identifier>
</item>
<item>
<title>Java9系列第三篇-同一个Jar支持多JDK版本运行 - 字母哥博客</title>
<link>http://www.cnblogs.com/zimug/p/13824215.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zimug/p/13824215.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202010/1815316-20201016080715810-604102463.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我计划在后续的一段时间内，写一系列关于java 9的文章，虽然java 9 不像Java 8或者Java 11那样的核心java版本，但是还是有很多的特性值得关注。期待您能关注我，我将把java 9 写成一系列的文章，大概十篇左右。&lt;/p&gt;
&lt;p&gt;本文内容：在Java 9增强了JAR多版本字节码文件格式的支持，同一个Jar包可以包含多个Java版本的class文件。使用这个功能，我们可以将应用程序/库升级到新的Java版本，而不必强迫用户升级到相同的Java版本。&lt;/p&gt;
&lt;h2 id=&quot;一、基本使用方法&quot;&gt;一、基本使用方法&lt;/h2&gt;
&lt;p&gt;多版本的字节码发行jar包，需要在其MANIFEST.MF中做以下的声明：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Multi-Release: true
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在jar包的&lt;code&gt;META-INF/versions&lt;/code&gt;文件目录里面可以包含多个版本的class文件，编译结果目录结构如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;jar root
  - A.class
  - B.class
  - META-INF
     - versions
        - 9
           - A.class
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;假设上文中的根目录是使用java 8 或之前版本编译的字节码文件A.calss。&lt;code&gt;META-INF/versions/9/&lt;/code&gt; 是使用java 9 编写的java代码的编译结果A.class。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果jar包是在JDK 8的运行时环境下运行，将使用根目录下面的class文件进行程序运行。&lt;/li&gt;
&lt;li&gt;如果jar包是在JDK 9的运行时环境下运行，将使用&lt;code&gt;META-INF/versions/9/&lt;/code&gt; 下面的class文件进行程序运行。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;假设未来这个项目升级JDK 10，决定在A.java中使用Java 10的一些新特性，可以单独针对A.class进行语法升级，并将编译结果a.class放置在&lt;code&gt;META-INF/versions/10/&lt;/code&gt; 下面&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;jar root
  - A.class
  - B.class
  - META-INF
     - versions
        - 9
           - A.class
        - 10
           - A.class
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在，上面的jar包含了可以以三种Java版本运行的字节码文件，A.class兼容JDK 8、9、10。&lt;/p&gt;
&lt;h2 id=&quot;二、真实的例子&quot;&gt;二、真实的例子&lt;/h2&gt;
&lt;h3 id=&quot;java-8代码&quot;&gt;java 8代码&lt;/h3&gt;
&lt;p&gt;下面的类文件代码我们让它运行在Java 8的环境下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.example;

public class IOUtil {
  public static String convertToString(InputStream inputStream) throws IOException {
      System.out.println(&quot;IOUtil 使用java 8 版本&quot;);
      Scanner scanner = new Scanner(inputStream, &quot;UTF-8&quot;);
      String str = scanner.useDelimiter(&quot;\\A&quot;).next();
      scanner.close();
      return str;
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;增加一个Main.java的应用程序入口文件，调用IOUtil.convertToString方法将InputStream转换成String。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.example;

public class Main {
  public static void main(String[] args) throws IOException {
          InputStream inputStream = new ByteArrayInputStream(&quot;测试字符串&quot;.getBytes());
          String result = IOUtil.convertToString(inputStream);
          System.out.println(result);
      }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;java-9代码&quot;&gt;Java 9代码&lt;/h3&gt;
&lt;p&gt;在Java 9 发布之后，我们决定使用Java 9 的新的语法重写IOUtil.convertToString方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.example;

public class IOUtil {
  public static String convertToString(InputStream inputStream) throws IOException {
      System.out.println(&quot;IOUtil 使用java 9 版本&quot;);
      try (inputStream) {  //Java9版本的增强try-with-resources
          String str = new String(inputStream.readAllBytes());
          return str;
      }
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上的代码所示，我们使用了Java 9的两个新特性带有inputStream引用的try-with-resource块和新的InputStream.readAllBytes()方法。&lt;/p&gt;
&lt;h3 id=&quot;编译&quot;&gt;编译&lt;/h3&gt;
&lt;p&gt;将Java8 、Java9的IOUtil.java代码分别在JDK8、JDK9的版本下分别编译成class字节码文件，并将class文件按照如下的目录结构打成保存，并打jar包。（先按java8版本打成jar包，然后修改MANIFEST.MF文件，添加java 9字节码class文件即可）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;D:\multi-release-jar-example\my-lib-jar&amp;gt;tree /A /F
+---com
|   \---example
|           IOUtil.class
|           Main.class
|           
\---META-INF
    |   MANIFEST.MF
    |   
    \---versions
        \---9
            \---com
                \---example
                        IOUtil.class
                        

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;运行-main-class&quot;&gt;运行 Main class&lt;/h3&gt;
&lt;p&gt;在JDK 9的环境下运行这个jar包&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;D:\multi-release-jar-example&amp;gt;java -cp my-lib.jar com.example.Main
IOUtil 使用java 9 版本
测试字符串
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在JDK 8的环境下运行这个jar包&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;D:\multi-release-jar-example&amp;gt;C:\jdk1.8.0_151\bin\java -cp my-lib.jar com.example.Main
IOUtil 使用java 8 版本
测试字符串
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;欢迎关注我的博客，里面有很多精品合集&quot;&gt;欢迎关注我的博客，里面有很多精品合集&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;本文转载注明出处（必须带连接，不能只转文字）：&lt;a href=&quot;http://www.zimug.com&quot;&gt;字母哥博客&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;觉得对您有帮助的话，帮我点赞、分享！您的支持是我不竭的创作动力！&lt;/strong&gt; 。另外，笔者最近一段时间输出了如下的精品内容，期待您的关注。&lt;/p&gt;
</description>
<pubDate>Fri, 16 Oct 2020 00:07:00 +0000</pubDate>
<dc:creator>字母哥博客</dc:creator>
<og:description>我计划在后续的一段时间内，写一系列关于java 9的文章，虽然java 9 不像Java 8或者Java 11那样的核心java版本，但是还是有很多的特性值得关注。期待您能关注我，我将把java 9</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zimug/p/13824215.html</dc:identifier>
</item>
<item>
<title>ansible2.4安装和体验 - 程序员欣宸</title>
<link>http://www.cnblogs.com/bolingcavalry/p/13824192.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bolingcavalry/p/13824192.html</guid>
<description>&lt;h3 id=&quot;欢迎访问我的github&quot;&gt;欢迎访问我的GitHub&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;内容：所有原创文章分类汇总及配套源码，涉及Java、Docker、Kubernetes、DevOPS等；&lt;/p&gt;
&lt;h3 id=&quot;关于ansible&quot;&gt;关于ansible&lt;/h3&gt;
&lt;p&gt;ansible是常用的开源配置管理工具，简单易用，可以高效的帮助我们对服务器进行远程操作，下图来自ansible官网，可见一台安装了ansible的机器可以远程控制亚马逊的EC2、S3服务器：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201016075000275-796081439.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;官方文档：&lt;a href=&quot;https://docs.ansible.com&quot;&gt;https://docs.ansible.com&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;环境&quot;&gt;环境&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;操作系统：CentOS Linux release 7.7.1908&lt;/li&gt;
&lt;li&gt;ansible版本：2.4.2.0&lt;/li&gt;
&lt;li&gt;本次实战用到两台机器，信息如下：&lt;/li&gt;
&lt;/ol&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;hostname&lt;/th&gt;
&lt;th&gt;IP地址&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;ansible&lt;/td&gt;
&lt;td&gt;192.168.133.160&lt;/td&gt;
&lt;td&gt;装了ansible，在此机器执行ansible命令操作cdh002机器&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;cdh002&lt;/td&gt;
&lt;td&gt;192.168.133.162&lt;/td&gt;
&lt;td&gt;从ansible机器上，通过ansible命令和脚本，操作cdh002&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;安装&quot;&gt;安装&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;root账号登录ansible机器，一行命令安装：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;yum install -y ansible
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;查看版本：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;[root@ansible playbooks]# ansible --version

ansible 2.4.2.0

  config file = /root/playbooks/ansible.cfg

  configured module search path = [u'/root/.ansible/plugins/modules', u'/usr/share/ansible/plugins/modules']

  ansible python module location = /usr/lib/python2.7/site-packages/ansible

  executable location = /usr/bin/ansible

  python version = 2.7.5 (default, Aug  7 2019, 00:51:29) [GCC 4.8.5 20150623 (Red Hat 4.8.5-39)]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装成功，接下来开始体验；&lt;/p&gt;
&lt;h3 id=&quot;配置机器信息&quot;&gt;配置机器信息&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;root&lt;/span&gt;账号登录ansible机器，创建文件夹&lt;span&gt;playbooks&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;&lt;span&gt;playbooks&lt;/span&gt;目录下创建名为hosts的文件，内容如下，&lt;span&gt;cdh-group&lt;/span&gt;是群组名，该群组内有一个机器配置信息，包含名称、IP地址，SSH端口，SSH账号密码等：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;[cdh-group]
cdh002 ansible_host=192.168.133.162 ansible_port=22 ansible_user=root ansible_password=888888
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;&lt;span&gt;playbooks&lt;/span&gt;目录下创建名为&lt;span&gt;ansible.cfg&lt;/span&gt;的文件，内容如下，这是个ansible的配置文件，执行ansible命令时用到，这里面指定了主机信息在hosts文件中查找：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;[defaults]
inventory = ~/playbooks/hosts
host_key_checking = False
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;体验&quot;&gt;体验&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;root账号登录ansible机器，执行命令ansible cdh002 -m command -a &quot;free -m&quot;，如下所示，成功的输出了cdh002的内存信息：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;[root@centos7 playbooks]# ansible cdh002 -m command -a &quot;free -m&quot;
cdh002 | SUCCESS | rc=0 &amp;gt;&amp;gt;
              total        used        free      shared  buff/cache   available
Mem:          15866        9047        3674          21        3145        6500
Swap:          2047           0        2047
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;上述命令中，&lt;span&gt;-m command&lt;/span&gt;是指使用command模块， &lt;span&gt;-a &quot;free -m&quot;&lt;/span&gt;是要在test机器上执行的命令；&lt;/li&gt;
&lt;li&gt;也可以省略&lt;span&gt;-m command&lt;/span&gt;：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;[root@centos7 playbooks]# ansible cdh002 -a &quot;free -m&quot;
cdh002 | SUCCESS | rc=0 &amp;gt;&amp;gt;
              total        used        free      shared  buff/cache   available
Mem:          15866        9066        3648          21        3151        6480
Swap:          2047           0        2047
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;playbook实战&quot;&gt;playbook实战&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;直接执行ansible命令虽然操作简单，但是不适合复杂的远程操作，这时候用脚本来配置和执行更合适，接下来编写一个脚本文件，再用ansible执行这个脚本文件，达到给cdh002机器安装应用&lt;span&gt;redhat-lsb&lt;/span&gt;的目标；&lt;/li&gt;
&lt;li&gt;在&lt;span&gt;/root/playbooks&lt;/span&gt;文件夹下创建文件&lt;span&gt;test_install.yml&lt;/span&gt;，内容如下：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;- name: test cdh-group
  hosts: cdh-group
  gather_facts: True
  tasks:
  - debug: var=ansible_distribution
  - name: install redhat-lsb
    yum: name=redhat-lsb state=present
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;执行命令&lt;span&gt;ansible-playbook test_install.yml&lt;/span&gt;，控制台信息如下，表示执行成功（changed=0表示本次实际上没有安装，因为该应用已经存在了）：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201016075000766-456172897.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;验证&lt;span&gt;redhat-lsb&lt;/span&gt;应用是否已在cdh002机器安装成功，如下图，操作系统信息成功输出，表示redhat-lsb安装成功：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201016075001285-1258068632.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;更多命令&quot;&gt;更多命令&lt;/h3&gt;
&lt;p&gt;ansible支持丰富的命令，参考官方文档：&lt;a href=&quot;https://docs.ansible.com/ansible/latest/modules/modules_by_category.html&quot;&gt;https://docs.ansible.com/ansible/latest/modules/modules_by_category.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;至此，ansible2.4版本安装和体验都完成了，如果您想尝试ansible，希望本文能给您一些参考&lt;/p&gt;
&lt;h3 id=&quot;欢迎关注公众号：程序员欣宸&quot;&gt;欢迎关注公众号：程序员欣宸&lt;/h3&gt;
&lt;blockquote readability=&quot;4.258064516129&quot;&gt;
&lt;p&gt;微信搜索「程序员欣宸」，我是欣宸，期待与您一同畅游Java世界...&lt;br/&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 15 Oct 2020 23:50:00 +0000</pubDate>
<dc:creator>程序员欣宸</dc:creator>
<og:description>欢迎访问我的GitHub https://github.com/zq2599/blog_demos 内容：所有原创文章分类汇总及配套源码，涉及Java、Docker、Kubernetes、DevOPS</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bolingcavalry/p/13824192.html</dc:identifier>
</item>
<item>
<title>代码质量管理平台之SonarQube安装部署 - Linux-1874</title>
<link>http://www.cnblogs.com/qiuhom-1874/p/13822428.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qiuhom-1874/p/13822428.html</guid>
<description>&lt;p&gt;　　一、简介&lt;/p&gt;
&lt;p&gt;　　Sonar是一个用于代码质量管理的开放平台，通过插件机制，sonar可以收集不同的测试工具，代码分析工具，以及持续集成工具。与持续集成工具（比如jenkins）不同，sonar并不是简单地把不同的代码检查工具结果直接显示在web页面，而是通过不同的插件对这些结果进行加工处理，通过量化的方式度量代码质量的变化，从而可以方便地对不同规模和种类的工程进行代码质量管理。在对其他工具的支持方面，sonar不仅提供了对IDE的支持，可以在Eclipse和Intellij IDEA这些工具里联机查看结果；同时sonar还对大量的持续集成工具提供了接口支持，可以很方便地在持续集成中使用sonar，此外，sonar的插件还可以对java以外的其他编程语言提供支持，对国际化及报告文档也有很良好的支持；官方网站&lt;a href=&quot;https://www.sonarqube.org&quot; target=&quot;_blank&quot;&gt;https://www.sonarqube.org&lt;/a&gt;；&lt;/p&gt;
&lt;p&gt;　　二、sonar平台部署&lt;/p&gt;
&lt;p&gt;　　sonarqube是一款用java语言编写的程序，它主要作用是提供一个web界面，展示扫描分析结果以及系统管理，插件管理等；扫描代码还是sonar-scanner这个插件做的，它的工作原理是sonar-scanner通过识别项目中的sonar-project.properties配置文件中定义的内容，把对应的项目源码进行扫描，把扫描后的结果保存到指定的数据库；然后sonarqube通过连接配置的数据库，把sonar-scanner存入数据库中的数据加载到web界面，从而用户就可以通过web界面查看扫描的项目源码的结果；&lt;/p&gt;
&lt;p&gt;　　1、安装数据库&lt;/p&gt;
&lt;p&gt;　　上传mysql5.6安装包和脚本&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node03 ~]# rz
rz waiting to receive.
 zmodem trl+C ȡ

  100%     256 bytes  256 bytes/s 00:00:01       0 Errors
  100%  321268 KB 35696 KB/s 00:00:09       0 Errors.gz...
  100%       1 KB    1 KB/s 00:00:01       0 Errors

[root@node03 ~]# ll
total 321280
-rw-r--r-- 1 root root       256 Aug 20  2019 my.cnf
-rw-r--r-- 1 root root 328979165 Aug 20  2019 mysql-5.6.42-linux-glibc2.12-x86_64.tar.gz
-rw-r--r-- 1 root root      1470 Aug 20  2019 mysql-install.sh
[root@node03 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　安装脚本&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_bbb7b72b-7e93-41fb-8810-24c91bed2919&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_bbb7b72b-7e93-41fb-8810-24c91bed2919&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_bbb7b72b-7e93-41fb-8810-24c91bed2919&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
#!/bin/&lt;span&gt;bash
DIR&lt;/span&gt;=`&lt;span&gt;pwd&lt;/span&gt;&lt;span&gt;`
NAME&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mysql-5.6.42-linux-glibc2.12-x86_64.tar.gz&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
FULL_NAME&lt;/span&gt;=${DIR}/&lt;span&gt;${NAME}
DATA_DIR&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/data/mysql&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;yum&lt;/span&gt; &lt;span&gt;install&lt;/span&gt; vim &lt;span&gt;gcc&lt;/span&gt; &lt;span&gt;gcc&lt;/span&gt;-c++ &lt;span&gt;wget&lt;/span&gt; autoconf  net-tools lrzsz iotop lsof iotop bash-completion -&lt;span&gt;y
&lt;/span&gt;&lt;span&gt;yum&lt;/span&gt; &lt;span&gt;install&lt;/span&gt; curl policycoreutils openssh-server openssh-clients postfix -&lt;span&gt;y

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; [ -f ${FULL_NAME} ];&lt;span&gt;then&lt;/span&gt;
    &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;安装文件存在&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;else&lt;/span&gt;
    &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;安装文件不存在&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    exit &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;
&lt;span&gt;fi&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; [ -h /usr/local/mysql ];&lt;span&gt;then&lt;/span&gt;
    &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mysql 已经安装&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    exit &lt;/span&gt;&lt;span&gt;3&lt;/span&gt; 
&lt;span&gt;else&lt;/span&gt;
    &lt;span&gt;tar&lt;/span&gt; xvf ${FULL_NAME}   -C /usr/local/&lt;span&gt;src
    &lt;/span&gt;&lt;span&gt;ln&lt;/span&gt; -sv /usr/local/src/mysql-&lt;span&gt;5.6&lt;/span&gt;.&lt;span&gt;42&lt;/span&gt;-linux-glibc2.&lt;span&gt;12&lt;/span&gt;-x86_64  /usr/local/&lt;span&gt;mysql
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;  mysql;&lt;span&gt;then&lt;/span&gt;
        &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mysql 用户已经存在，跳过创建用户过程&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
    &lt;span&gt;fi&lt;/span&gt;&lt;span&gt;
        useradd  mysql  &lt;/span&gt;-s /sbin/&lt;span&gt;nologin
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;  &lt;span&gt;id&lt;/span&gt;  mysql;&lt;span&gt;then&lt;/span&gt;
        &lt;span&gt;chown&lt;/span&gt;  -R mysql.mysql  /usr/local/mysql&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; -R
        if [ ! -d  /data/mysql ];then
            mkdir -pv /data/mysql /var/lib/mysql &amp;amp;&amp;amp; chown  -R mysql.mysql  /data   -R
            /usr/local/mysql/scripts/mysql_install_db  --user=mysql --datadir=/data/mysql  --basedir=/usr/local/mysql/
        cp  /usr/local/src/mysql-5.6.42-linux-glibc2.12-x86_64/support-files/mysql.server /etc/init.d/mysqld
        chmod a+x /etc/init.d/mysqld
         cp ${DIR}/my.cnf   /etc/my.cnf
        ln -sv /usr/local/mysql/bin/mysql  /usr/bin/mysql
            ln -sv /data/mysql/mysql.sock  /var/lib/mysql/mysql.sock
        /etc/init.d/mysqld start
    else
            echo &quot;MySQL数据目录已经存在,&quot;
            exit 3
    fi
    fi
fi&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　安装mysql&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node03 ~]# bash mysql-install.sh 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202010/1503305-20201015232831279-1798457074.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：自动安装脚本执行完成后，它会自动启动mysql，如果启动成功，说明mysql已经安装完成；&lt;/p&gt;
&lt;p&gt;　　验证：查看msyql是否启动，是否可以连接到mysql数据库?&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202010/1503305-20201015233011052-1395278822.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　创建数据库和用户授权&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
mysql&amp;gt;  CREATE DATABASE sonar CHARACTER SET utf8 COLLATE utf8_general_ci;
Query OK, 1 row affected (0.05 sec)

mysql&amp;gt; GRANT ALL ON sonar.* TO sonar@&quot;192.168.0.%&quot; IDENTIFIED BY &quot;admin&quot;; 
Query OK, 0 rows affected (0.02 sec)

mysql&amp;gt; FLUSH PRIVILEGES;
Query OK, 0 rows affected (0.00 sec)

mysql&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　验证：使用创建的用户连接数据库，看看是否可以连接？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node03 ~]# mysql -usonar -padmin -h192.168.0.43
Warning: Using a password on the command line interface can be insecure.
ERROR 1045 (28000): Access denied for user 'sonar'@'node03.test.org' (using password: YES)
[root@node03 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：这里主要是mysql把ip地址反解成主机名了；&lt;/p&gt;
&lt;p&gt;　　配置mysql，忽略ip地址反解成主机名&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202010/1503305-20201015233429371-451851202.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　重启mysql，再次测试新建的用户是否能够连接到mysql？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202010/1503305-20201015233610566-1484979825.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　到此mysql安装和测试就完成了&lt;/p&gt;
&lt;p&gt;　　2、安装jdk&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node03 ~]# yum install -y java-1.8.0-openjdk-devel
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　验证java版本&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node03 ~]# java -version
openjdk version &quot;1.8.0_262&quot;
OpenJDK Runtime Environment (build 1.8.0_262-b10)
OpenJDK 64-Bit Server VM (build 25.262-b10, mixed mode)
[root@node03 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：sonar 依赖于 java 环境，而且 java 版本必须是 1.8 版本或更高，否则 sonar 启动失败；&lt;/p&gt;
&lt;p&gt;　　3、上传sonarqube安装包，安装sonarqube&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202010/1503305-20201015233921341-1966432771.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：在官方下载太慢了，我这里下载好了，直接传上来的；现在最新版本7.9不支持mysql；&lt;/p&gt;
&lt;p&gt;　　解压压缩包&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node03 src]# unzip sonarqube-6.5.zip 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　新建软连接&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node03 src]# ll
total 139932
drwxr-xr-x 13 root root       205 Oct 15 23:27 mysql-5.6.42-linux-glibc2.12-x86_64
drwxr-xr-x 10 root root       120 Aug  1  2017 sonarqube-6.5
-rw-r--r--  1 root root 143286376 Aug 20  2019 sonarqube-6.5.zip
[root@node03 src]# ln -sv /usr/local/src/sonarqube-6.5 /usr/local/sonaqube
‘/usr/local/sonaqube’ -&amp;gt; ‘/usr/local/src/sonarqube-6.5’
[root@node03 src]# ll /usr/local/
total 0
drwxr-xr-x. 2 root root  6 Nov  5  2016 bin
drwxr-xr-x. 2 root root  6 Nov  5  2016 etc
drwxr-xr-x. 2 root root  6 Nov  5  2016 games
drwxr-xr-x. 2 root root  6 Nov  5  2016 include
drwxr-xr-x. 2 root root  6 Nov  5  2016 lib
drwxr-xr-x. 2 root root  6 Nov  5  2016 lib64
drwxr-xr-x. 2 root root  6 Nov  5  2016 libexec
lrwxrwxrwx  1 root root 50 Oct 15 23:27 mysql -&amp;gt; /usr/local/src/mysql-5.6.42-linux-glibc2.12-x86_64
drwxr-xr-x. 2 root root  6 Nov  5  2016 sbin
drwxr-xr-x. 5 root root 49 Sep 15 20:33 share
lrwxrwxrwx  1 root root 28 Oct 15 23:39 sonaqube -&amp;gt; /usr/local/src/sonarqube-6.5
drwxr-xr-x. 4 root root 95 Oct 15 23:39 src
[root@node03 src]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　配置sonarqube连接192.168.0.43上的数据库，并让其web端口监听在本机所有地址的9000端口&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node03 sonaqube]# grep ^[a-z] conf/sonar.properties
sonar.jdbc.username=sonar
sonar.jdbc.password=admin
sonar.jdbc.url=jdbc:mysql://192.168.0.43:3306/sonar?useUnicode=true&amp;amp;characterEncoding=utf8&amp;amp;rewriteBatchedStatements=true&amp;amp;useConfigs=maxPerformance&amp;amp;useSSL=false
sonar.web.host=0.0.0.0
sonar.web.port=9000
[root@node03 sonaqube]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：sonar.jdbc.username是指连接数据库的用户名；sonar.jdbc.password指连接数据库的用户名密码；sonar.jdbc.url指连接数据库的驱动名以及数据库地址，端口和数据库名称，后面是指定的参数保持默认即可；sonar.web.host用于指定监听的ip地址，0.0.0.0表示监听本机所有可用地址；sonar.web.port指定监听的端口；&lt;/p&gt;
&lt;p&gt;　　启动sonarqube&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node03 sonaqube]# bin/linux-x86-64/sonar.sh --help
Usage: bin/linux-x86-64/sonar.sh { console | start | stop | restart | status | dump }
[root@node03 sonaqube]# bin/linux-x86-64/sonar.sh start
Starting SonarQube...
Started SonarQube.
[root@node03 sonaqube]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　验证：查看9000端口是否处于监听？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node03 ~]# ss -tnl
State      Recv-Q Send-Q         Local Address:Port                        Peer Address:Port              
LISTEN     0      128                        *:22                                     *:*                  
LISTEN     0      100                127.0.0.1:25                                     *:*                  
LISTEN     0      128                       :::22                                    :::*                  
LISTEN     0      100                      ::1:25                                    :::*                  
LISTEN     0      128                       :::3306                                  :::*                  
[root@node03 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：9000端口并没有监听；&lt;/p&gt;
&lt;p&gt;　　查看日志&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202010/1503305-20201015234848285-895379809.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：日志里提示说内存不足；&lt;/p&gt;
&lt;p&gt;　　查看内存使用情况&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node03 sonaqube]# free -m
              total        used        free      shared  buff/cache   available
Mem:           1823        1662          73           0          87          30
Swap:          1023         687         336
[root@node03 sonaqube]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：2G内存还剩73M，交换分区还是用了687M，内存的确有点小；解决办法只有重新分配内存；我这里是虚拟机，直接调整内存即可；&lt;/p&gt;
&lt;p&gt;　　调整好内存后，在启动sonarqube，看看是否启动起来？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202010/1503305-20201015235739436-1971666676.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：调整内存为4G，勉强启动起来；所以如果数据库和sonarqube在一台主机上，建议将内存调到8G，甚至更高；&lt;/p&gt;
&lt;p&gt;　　访问9000端口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202010/1503305-20201016000041089-826180991.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　登录试试&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202010/1503305-20201016000140015-1857024858.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：点击登录，弹出一个输入token的界面，我们可以忽略它，直接进入即可；到此sonarqube服务就正常跑起来了；&lt;/p&gt;
&lt;p&gt;　　4、安装扫描器 sonar-scanner&lt;/p&gt;
&lt;p&gt;　　上传安装包，并解压&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node03 ~]# cd /usr/local/src/
[root@node03 src]# rz
rz waiting to receive.
 zmodem trl+C ȡ

  100%     489 KB  489 KB/s 00:00:01       0 Errorsp...

[root@node03 src]# ll
total 140424
drwxr-xr-x 13 root root       205 Oct 15 23:27 mysql-5.6.42-linux-glibc2.12-x86_64
drwxr-xr-x 10 root root       146 Oct 15 23:43 sonarqube-6.5
-rw-r--r--  1 root root 143286376 Aug 20  2019 sonarqube-6.5.zip
-rw-r--r--  1 root root    501750 Aug 20  2019 sonar-scanner-2.6.1.zip
[root@node03 src]# unzip sonar-scanner-2.6.1.zip 
Archive:  sonar-scanner-2.6.1.zip
   creating: sonar-scanner-2.6.1/bin/
  inflating: sonar-scanner-2.6.1/bin/sonar-scanner  
  inflating: sonar-scanner-2.6.1/bin/sonar-runner  
   creating: sonar-scanner-2.6.1/conf/
  inflating: sonar-scanner-2.6.1/conf/sonar-scanner.properties  
   creating: sonar-scanner-2.6.1/lib/
  inflating: sonar-scanner-2.6.1/lib/sonar-scanner-cli-2.6.1.jar  
  inflating: sonar-scanner-2.6.1/bin/sonar-runner.bat  
  inflating: sonar-scanner-2.6.1/bin/sonar-scanner.bat  
[root@node03 src]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　创建软连接&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202010/1503305-20201016001028254-958969457.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　配置 sonar-scanner&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202010/1503305-20201016001253373-119073701.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：扫描器主要配置它需要连接的数据相关配置，以及soanrqube服务的地址；扫描器不需要启动，它的工作方式是在对应项目里sonar-porject.properties配置文件所在目录运行sonar-scanner，它默认会去找项目中的sonar-porject.properties配置文件，进行扫描项目源代码；&lt;/p&gt;
&lt;p&gt;　　测试：上传测试代码进行扫描&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202010/1503305-20201016001656677-1939782353.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　解压，并进入到项目目录，进入sonar-project.properties文件所在目录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202010/1503305-20201016001836640-351561989.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：sonar.projectKey、sonar.projectName、sonar.projectVersion这三个可以根据自己的项目实际情况来定，这个只是标记项目的，不影响扫描结果；最重要的是要告诉扫描器去哪里找源码；sonar.sources用来指定源码位置，通常这里都是一个相对当前目录的目录；sonar.language这个是指定项目的语言，扫描器通过这里的配置，确定用哪种插件去扫描；sonar.sourceEncoding这个是指定源码的编码；&lt;/p&gt;
&lt;p&gt;　　在sonar-project.properties配置文件所在目录执行sonar-scanner命令进行扫描&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node03 python-sonar-runner]# ll
total 12
-rw-r--r-- 1 root root 461 Jul 25  2016 README.md
-rw-r--r-- 1 root root 338 Jul 25  2016 sonar-project.properties
drwxr-xr-x 5 root root  93 Jul 25  2016 src
-rw-r--r-- 1 root root 290 Jul 25  2016 validation.txt
[root@node03 python-sonar-runner]# /usr/local/sonar-scanner/bin/sonar-scanner 
INFO: Scanner configuration file: /usr/local/sonar-scanner/conf/sonar-scanner.properties
INFO: Project root configuration file: /root/sonar-examples-master/projects/languages/python/python-sonar-runner/sonar-project.properties
INFO: SonarQube Scanner 2.6.1
INFO: Java 1.8.0_262 Oracle Corporation (64-bit)
INFO: Linux 3.10.0-693.el7.x86_64 amd64
INFO: User cache: /root/.sonar/cache
INFO: Load global settings
INFO: Load global settings (done) | time=148ms
WARN: Property 'sonar.jdbc.url' is not supported any more. It will be ignored. There is no longer any DB connection to the SQ database.
WARN: Property 'sonar.jdbc.username' is not supported any more. It will be ignored. There is no longer any DB connection to the SQ database.
WARN: Property 'sonar.jdbc.password' is not supported any more. It will be ignored. There is no longer any DB connection to the SQ database.
INFO: User cache: /root/.sonar/cache
INFO: Load plugins index
INFO: Load plugins index (done) | time=80ms
INFO: Download sonar-csharp-plugin-5.10.1.1411.jar
INFO: Download sonar-python-plugin-1.8.0.1496.jar
INFO: Download sonar-java-plugin-4.12.0.11033.jar
INFO: Download sonar-scm-git-plugin-1.2.jar
INFO: Download sonar-flex-plugin-2.3.jar
INFO: Download sonar-xml-plugin-1.4.3.1027.jar
INFO: Download sonar-php-plugin-2.10.0.2087.jar
INFO: Download sonar-scm-svn-plugin-1.5.0.715.jar
INFO: Download sonar-javascript-plugin-3.1.1.5128.jar
INFO: SonarQube server 6.5.0
INFO: Default locale: &quot;en_US&quot;, source code encoding: &quot;UTF-8&quot;
INFO: Process project properties
INFO: Load project repositories
INFO: Load project repositories (done) | time=41ms
INFO: Load quality profiles
INFO: Load quality profiles (done) | time=42ms
INFO: Load active rules
INFO: Load active rules (done) | time=782ms
INFO: Load metrics repository
INFO: Load metrics repository (done) | time=86ms
WARN: SCM provider autodetection failed. No SCM provider claims to support this project. Please use sonar.scm.provider to define SCM of your project.
INFO: Publish mode
INFO: Project key: org.sonarqube:python-simple-sonar-scanner
INFO: -------------  Scan Python :: Simple Project : SonarQube Scanner
INFO: Load server rules
INFO: Load server rules (done) | time=49ms
INFO: Language is forced to py
INFO: Base dir: /root/sonar-examples-master/projects/languages/python/python-sonar-runner
INFO: Working dir: /root/sonar-examples-master/projects/languages/python/python-sonar-runner/.sonar
INFO: Source paths: src
INFO: Source encoding: UTF-8, default locale: en_US
INFO: Index files
INFO: 9 files indexed
INFO: Quality profile for py: Sonar way
INFO: Sensor PythonXUnitSensor [python]
INFO: Sensor PythonXUnitSensor [python] (done) | time=7ms
INFO: Sensor Python Squid Sensor [python]
INFO: Python unit test coverage
INFO: Python integration test coverage
INFO: Python overall test coverage
INFO: Sensor Python Squid Sensor [python] (done) | time=218ms
INFO: Sensor SonarJavaXmlFileSensor [java]
INFO: Sensor SonarJavaXmlFileSensor [java] (done) | time=1ms
INFO: Sensor Analyzer for &quot;php.ini&quot; files [php]
INFO: Sensor Analyzer for &quot;php.ini&quot; files [php] (done) | time=2ms
INFO: Sensor Zero Coverage Sensor
INFO: Sensor Zero Coverage Sensor (done) | time=11ms
INFO: Sensor CPD Block Indexer
INFO: Sensor CPD Block Indexer (done) | time=14ms
INFO: No SCM system was detected. You can use the 'sonar.scm.provider' property to explicitly specify it.
INFO: 5 files had no CPD blocks
INFO: Calculating CPD for 4 files
INFO: CPD calculation finished
INFO: Analysis report generated in 50ms, dir size=54 KB
INFO: Analysis reports compressed in 11ms, zip size=27 KB
INFO: Analysis report uploaded in 520ms
INFO: ANALYSIS SUCCESSFUL, you can browse http://192.168.0.43:9000/dashboard/index/org.sonarqube:python-simple-sonar-scanner
INFO: Note that you will be able to access the updated dashboard once the server has processed the submitted analysis report
INFO: More about the report processing at http://192.168.0.43:9000/api/ce/task?id=AXUtFHMGxcHkiMKcN6ov
INFO: Task total time: 3.414 s
INFO: ------------------------------------------------------------------------
INFO: EXECUTION SUCCESS
INFO: ------------------------------------------------------------------------
INFO: Total time: 6.631s
INFO: Final Memory: 47M/181M
INFO: ------------------------------------------------------------------------
[root@node03 python-sonar-runner]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　扫描结果如上所示&lt;/p&gt;
&lt;p&gt;　　查看扫描结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202010/1503305-20201016002706526-1201459029.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202010/1503305-20201016002724827-33281485.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202010/1503305-20201016002808168-2067378519.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　安装中文支持&lt;/p&gt;
&lt;p&gt;　　上传插件到sonarqube的插件目录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202010/1503305-20201016003326417-426001192.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　重启sonarqube，让插件生效&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node03 plugins]# /usr/local/sonaqube/bin/linux-x86-64/sonar.sh restart
Stopping SonarQube...
Stopped SonarQube.
Starting SonarQube...
Started SonarQube.
[root@node03 plugins]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　验证：重新刷新web页面，看看是否有中文支持了？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202010/1503305-20201016003515083-1174076786.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在线安装插件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202010/1503305-20201016003928409-1292141542.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：它这个安装插件的方式和jenkins安装插件的方式一样，你把需要的安装的插件，在availabe中进行搜索；然后点击后面的install即可；&lt;/p&gt;
&lt;p&gt;　　到此，代码管理平台sonarqube+sonar-scanner的部署和测试就完成了；&lt;/p&gt;
</description>
<pubDate>Thu, 15 Oct 2020 16:57:00 +0000</pubDate>
<dc:creator>Linux-1874</dc:creator>
<og:description>一、简介 Sonar是一个用于代码质量管理的开放平台，通过插件机制，sonar可以收集不同的测试工具，代码分析工具，以及持续集成工具。与持续集成工具（比如jenkins）不同，sonar并不是简单地把</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qiuhom-1874/p/13822428.html</dc:identifier>
</item>
<item>
<title>12张图带你彻底理解分布式事务产生的场景和解决方案！！ - 冰河团队</title>
<link>http://www.cnblogs.com/binghe001/p/13823965.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/binghe001/p/13823965.html</guid>
<description>&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;写这篇文章的背景是有个跟我关系不错的小伙伴去某大型互联网公司面试，面试官问了他关于分布式事务的问题，不巧的是他确实对分布式事务掌握的不是很深入，面试的结果挺遗憾的。不过，这位小伙伴还是挺乐观的，让我写写关于【分布式事务】的系列文章，他想提升自己关于分布式事务的短板，那我就写一个【分布式事务】专题吧，专题的内容计划是从原理、框架源码到企业级实现，这篇文章也算是整个专题的开篇吧。希望能够为小伙伴们带来实质性的帮助。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;本地事务&quot;&gt;本地事务&lt;/h2&gt;
&lt;h3 id=&quot;本地事务流程&quot;&gt;本地事务流程&lt;/h3&gt;
&lt;p&gt;在介绍分布式事务之前，我们先来看看本地事务。首先，我们先来一张图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201015110610109.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由上图，我们可以看出，本地事务由资源管理器（比如DBMS，数据库管理系统）在本地进行管理。&lt;/p&gt;
&lt;h3 id=&quot;本地事务的优缺点&quot;&gt;本地事务的优缺点&lt;/h3&gt;
&lt;p&gt;本地事务具备相应的优点，也有其不足。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;支持严格的ACID属性。&lt;/li&gt;
&lt;li&gt;可靠，事务实现的效率高（只是在本地操作）。&lt;/li&gt;
&lt;li&gt;可以只在RM（资源管理器）中操作事务。&lt;/li&gt;
&lt;li&gt;编程模型简单。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;缺乏分布式事务的处理能力。&lt;/li&gt;
&lt;li&gt;数据隔离的最小单元由RM（资源管理器决定），开发人员无法决定数据隔离的最小单元。比如：数据库中的一条记录等。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;acid属性&quot;&gt;ACID属性&lt;/h3&gt;
&lt;p&gt;说起事务，我们不得不提的就是事务的ACID属性。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201015110620932.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;A（Atomic）：原子性，构成事务的所有操作，要么都执行完成，要么全部不执行，不可能出现部分成功部分失&lt;br/&gt;败的情况。&lt;/li&gt;
&lt;li&gt;C（Consistency）：一致性，在事务执行前后，数据库的一致性约束没有被破坏。比如：张三向李四转100元，&lt;br/&gt;转账前和转账后的数据的正确状态叫作一致性，如果出现张三转出100元，李四账户没有增加100元这就出现了数&lt;br/&gt;据错误，就没有达到一致性。&lt;/li&gt;
&lt;li&gt;I（Isolation）：隔离性，数据库中的事务一般都是并发的，隔离性是指并发的两个事务的执行互不干扰，一个事&lt;br/&gt;务不能看到其他事务运行过程的中间状态。通过配置事务隔离级别可以避脏读、重复读等问题。&lt;/li&gt;
&lt;li&gt;D（Durability）：持久性，事务完成之后，该事务对数据的更改会被持久化到数据库，且不会被回滚。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;分布式事务&quot;&gt;分布式事务&lt;/h2&gt;
&lt;p&gt;随着业务的快速发展，网站系统往往由单体架构逐渐演变为分布式、微服务架构，而对于数据库则由单机数据库架构向分布式数据库架构转变。此时，我们会将一个大的应用系统拆分为多个可以独立部署的应用服务，需要各个服务之间进行远程协作才能完成事务操作。&lt;/p&gt;
&lt;p&gt;我们可以使用下图来表示刚开始我们系统的单体架构。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201015110631848.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图中，我们将同一个项目中的不同模块组织成不同的包来进行管理，所有的程序代码仍然是放在同一个项目中。&lt;/p&gt;
&lt;p&gt;后续由于业务的发展，我们将其扩展为分布式、微服务架构。此时，我们将一个大的项目拆分为一个个小的可以独立部署的微服务，每个微服务都有自己的数据库，如下所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201015110641822.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;又比如，在我们的程序中，经常会在同一个事务中执行类似如下的代码来完成我们的需求。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Transactional(rollbackFor = Exception.class)
public void submitOrder() {
    orderDao.update(); // 更新订单信息
    accountService.update(); // 修改资金账户的金额
    pointService.update(); //  修改积分
    accountingService.insert(); // 插入交易流水
    merchantNotifyService.notify(); // 通知支付结果
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述代码中的业务，仅仅在submitOrder()方法上添加了一个@Transactional注解，这能够在分布式场景下避免分布式事务的问题吗？很显然是不行的。&lt;/p&gt;
&lt;p&gt;如果上述代码所对应的：订单信息、资金账户信息、积分信息、交易流水等信息分别存储在不同的数据里，而支付完成后，通知的目标系统的数据同样是存储在不同的数据库中。此时就会产生分布式事务问题。&lt;/p&gt;
&lt;h2 id=&quot;分布式事务产生的场景&quot;&gt;分布式事务产生的场景&lt;/h2&gt;
&lt;h3 id=&quot;跨jvm进程&quot;&gt;跨JVM进程&lt;/h3&gt;
&lt;p&gt;当我们将单体项目拆分为分布式、微服务项目之后，各个服务之间通过远程REST或者RPC调用来协同完成业务操作。典型的场景就是：商城系统中的订单微服务和库存微服务，用户在下单时会访问订单微服务，订单微服务在生成订单记录时，会调用库存微服务来扣减库存。各个微服务是部署在不同的JVM进程中的，此时，就会产生因跨JVM进程而导致的分布式事务问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201015110653393.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;跨数据库实例&quot;&gt;跨数据库实例&lt;/h3&gt;
&lt;p&gt;单体系统访问多个数据库实例，也就是跨数据源访问时会产生分布式事务。例如，我们的系统中的订单数据库和交易数据库是放在不同的数据库实例中，当用户发起退款时，会同时操作用户的订单数据库和交易数据库，在交易数据库中执行退款操作，在订单数据库中将订单的状态变更为已退款。由于数据分布在不同的数据库实例，需要通过不同的数据库连接会话来操作数据库中的数据，此时，就产生了分布式事务。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/202010151107049.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;多服务单数据库&quot;&gt;多服务单数据库&lt;/h3&gt;
&lt;p&gt;多个微服务访问同一个数据库。例如，订单微服务和库存微服务访问同一个数据库也会产生分布式事务，原因是：多个微服务访问同一个数据库，本质上也是通过不同的数据库会话来操作数据库，此时就会产生分布式事务。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201015110715478.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：跨数据库实例场景和多服务单数据库场景，本质上都是因为会产生不同的数据库会话来操作数据库中的数据，进而产生分布式事务。这两种场景是大家比较容易忽略的。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;分布式事务解决方案&quot;&gt;分布式事务解决方案&lt;/h2&gt;
&lt;p&gt;知道了分布式事务产生的场景后，接下来，我们就聊聊分布式事务具体有哪些解决方案。&lt;/p&gt;
&lt;h3 id=&quot;2pc方案&quot;&gt;2PC方案&lt;/h3&gt;
&lt;p&gt;2PC即两阶段提交协议，是将整个事务流程分为两个阶段，准备阶段（Prepare phase）、提交阶段（commit&lt;br/&gt;phase），2是指两个阶段，P是指准备阶段，C是指提交阶段。&lt;/p&gt;
&lt;p&gt;这里，我们用MySQL数据库举例，MySQL数据库支持两阶段提交协议，可以分为成功和失败两种情况。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;成功情况&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201015110728350.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;失败情况&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201015110739824.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;具体流程如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;准备阶段（Prepare phase）：&lt;/strong&gt; 事务管理器给每个参与者发送Prepare消息，每个数据库参与者在本地执行事&lt;br/&gt;务，并写本地的Undo/Redo日志，此时事务没有提交。&lt;br/&gt;（Undo日志是记录修改前的数据，用于数据库回滚，Redo日志是记录修改后的数据，用于提交事务后写入数&lt;br/&gt;据文件）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;提交阶段（commit phase）：&lt;/strong&gt; 如果事务管理器收到了参与者的执行失败或者超时消息时，直接给每个参与者&lt;br/&gt;发送回滚(Rollback)消息；否则，发送提交(Commit)消息；参与者根据事务管理器的指令执行提交或者回滚操&lt;br/&gt;作，并释放事务处理过程中使用的锁资源。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用2PC方案时，需要注意的是：必须在最后阶段释放锁资源。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;可靠消息最终一致性方案&quot;&gt;可靠消息最终一致性方案&lt;/h3&gt;
&lt;p&gt;可靠消息最终一致性方案是指当事务发起方执行完成本地事务后并发出一条消息，事务参与方(消息消费者)一定能&lt;br/&gt;够接收消息并处理事务成功，此方案强调的是只要消息发给事务参与方最终事务要达到一致。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201015110753518.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;事务发起方（消息生产方）将消息发给消息中间件，事务参与方从消息中间件接收消息，事务发起方和消息中间件&lt;br/&gt;之间，事务参与方（消息消费方）和消息中间件之间都是通过网络通信，由于网络通信的不确定性会导致分布式事&lt;br/&gt;务问题。 所以，我们在具体方案中会引入消息确认服务和消息恢复服务。&lt;/p&gt;
&lt;p&gt;使用可靠消息最终一致性方案时需要注意几个问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;本地事务与消息发送的原子性问题。&lt;/li&gt;
&lt;li&gt;事务参与方接收消息的可靠性问题。&lt;/li&gt;
&lt;li&gt;消息重复消费的问题（需要实现幂等）。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;tcc方案&quot;&gt;TCC方案&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;TCC分为三个阶段：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Try 阶段&lt;/strong&gt; 是做业务检查(一致性)及资源预留(隔离)，此阶段仅是一个初步操作，它和后续的Confirm 一起才能&lt;br/&gt;真正构成一个完整的业务逻辑。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Confirm 阶段&lt;/strong&gt; 是做确认提交，Try阶段所有分支事务执行成功后开始执行 Confirm。通常情况下，采用TCC则&lt;br/&gt;认为 Confirm阶段是不会出错的。即：只要Try成功，Confirm一定成功。若Confirm阶段真的出错了，需引&lt;br/&gt;入重试机制或人工处理。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Cancel 阶段&lt;/strong&gt; 是在业务执行错误需要回滚的状态下执行分支事务的业务取消，预留资源释放。通常情况下，采&lt;br/&gt;用TCC则认为Cancel阶段也是一定成功的。若Cancel阶段真的出错了，需引入重试机制或人工处理。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201015110805694.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用TCC分布式解决方案时需要注意空回滚、幂等、悬挂等问题。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;最大努力通知型方案&quot;&gt;最大努力通知型方案&lt;/h3&gt;
&lt;p&gt;此种方案主要用于多个不同系统之前保证数据的最终一致性，大体如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020101511081636.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用最大努力通知型方案需要注意幂等和数据的回查操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;好了，今天就到这儿吧，后续我们会针对每种分布式事务解决方案进行具体介绍，下期见！！&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;重磅福利&quot;&gt;重磅福利&lt;/h2&gt;
&lt;p&gt;微信搜一搜【冰河技术】微信公众号，关注这个有深度的程序员，每天阅读超硬核技术干货，公众号内回复【PDF】有我准备的一线大厂面试资料和我原创的超硬核PDF技术文档，以及我为大家精心准备的多套简历模板（不断更新中），希望大家都能找到心仪的工作，学习是一条时而郁郁寡欢，时而开怀大笑的路，加油。如果你通过努力成功进入到了心仪的公司，一定不要懈怠放松，职场成长和新技术学习一样，不进则退。如果有幸我们江湖再见！&lt;/p&gt;
&lt;p&gt;另外，我开源的各个PDF，后续我都会持续更新和维护，感谢大家长期以来对冰河的支持！！&lt;/p&gt;
</description>
<pubDate>Thu, 15 Oct 2020 16:26:00 +0000</pubDate>
<dc:creator>冰河团队</dc:creator>
<og:description>写在前面 写这篇文章的背景是有个跟我关系不错的小伙伴去某大型互联网公司面试，面试官问了他关于分布式事务的问题，不巧的是他确实对分布式事务掌握的不是很深入，面试的结果挺遗憾的。不过，这位小伙伴还是挺乐观</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/binghe001/p/13823965.html</dc:identifier>
</item>
<item>
<title>一文看懂Vue3.0的优化 - 小磊哥er</title>
<link>http://www.cnblogs.com/yzsunlei/p/13823927.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yzsunlei/p/13823927.html</guid>
<description>&lt;p&gt;Vue.js 2.x 的源码托管在 src 目录，然后依据功能拆分出了 compiler（模板编译的相关代码）、core（与平台无关的通用运行时代码）、platforms（平台专有代码）、server（服务端渲染的相关代码）、sfc（.vue 单文件解析相关代码）、shared（共享工具代码）等目录。&lt;/p&gt;
</description>
<pubDate>Thu, 15 Oct 2020 16:08:00 +0000</pubDate>
<dc:creator>小磊哥er</dc:creator>
<og:description>1.源码优化： a.使用monorepo来管理源码 Vue.js 2.x 的源码托管在 src 目录，然后依据功能拆分出了 compiler（模板编译的相关代码）、core（与平台无关的通用运行时代码</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yzsunlei/p/13823927.html</dc:identifier>
</item>
<item>
<title>golang常用库：字段参数验证库-validator使用 - 九卷</title>
<link>http://www.cnblogs.com/jiujuan/p/13823864.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jiujuan/p/13823864.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/jiujuan/p/12768907.html&quot;&gt;golang常用库：gorilla/mux-http路由库使用&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/jiujuan/p/13799976.html&quot;&gt;golang常用库：配置文件解析库-viper使用&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/jiujuan/p/12676195.html&quot;&gt;golang常用库：操作数据库的orm框架-gorm基本使用&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/jiujuan/p/13823864.html&quot;&gt;golang常用库：字段参数验证库-validator使用&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、背景&quot;&gt;一、背景&lt;/h2&gt;
&lt;p&gt;在平常开发中，特别是在web应用开发中，为了验证输入字段的合法性，都会做一些验证操作。比如对用户提交的表单字段进行验证，或者对请求的API接口字段进行验证，验证字段的合法性，保证输入字段值的安全，防止用户的恶意请求。&lt;/p&gt;
&lt;p&gt;一般的做法是用正则表达式，一个字段一个字段的进行验证。一个一个字段验证的话，写起来比较繁琐。那有没更好的方法，进行字段的合法性验证？有， 这就是下面要介绍的 &lt;a href=&quot;https://github.com/go-playground/validator&quot;&gt;validator&lt;/a&gt; 这个验证组件。&lt;/p&gt;
&lt;p&gt;代码地址：&lt;br/&gt;&lt;a href=&quot;https://github.com/go-playground/validator&quot;&gt;https://github.com/go-playground/validator&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文档地址：&lt;br/&gt;&lt;a href=&quot;https://github.com/go-playground/validator/blob/master/README.md&quot;&gt;https://github.com/go-playground/validator/blob/master/README.md&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;二、功能介绍&quot;&gt;二、功能介绍&lt;/h2&gt;
&lt;p&gt;这个验证包 &lt;a href=&quot;https://github.com/go-playground/validator&quot;&gt;github.com/go-playground/validator&lt;/a&gt; 验证功能非常多。&lt;/p&gt;
&lt;h3 id=&quot;标记之间特殊符号说明&quot;&gt;标记之间特殊符号说明&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;逗号( &lt;code&gt;,&lt;/code&gt; )：把多个验证标记隔开。&lt;code&gt;注意&lt;/code&gt;：隔开逗号之间不能有空格, &lt;code&gt;validate:&quot;lt=0,gt=100&quot;&lt;/code&gt;，逗号那里不能有空格，否则panic&lt;/li&gt;
&lt;li&gt;横线( &lt;code&gt;-&lt;/code&gt; )：跳过该字段不验证&lt;/li&gt;
&lt;li&gt;竖线( &lt;code&gt;|&lt;/code&gt; )：使用多个验证标记，但是只需满足其中一个即可&lt;/li&gt;
&lt;li&gt;required：表示该字段值必输设置，且不能为默认值&lt;/li&gt;
&lt;li&gt;omitempty：如果字段未设置，则忽略它&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;范围比较验证&quot;&gt;范围比较验证&lt;/h3&gt;
&lt;blockquote readability=&quot;0.30864197530864&quot;&gt;
&lt;p&gt;doc: &lt;a href=&quot;https://github.com/go-playground/validator/blob/master/README.md#comparisons&quot;&gt;https://github.com/go-playground/validator/blob/master/README.md#comparisons&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;范围验证: 切片、数组和map、字符串，验证其长度；数值，验证大小范围&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;lte：小于等于参数值，&lt;code&gt;validate:&quot;lte=3&quot;&lt;/code&gt; (小于等于3)&lt;/li&gt;
&lt;li&gt;gte：大于等于参数值，&lt;code&gt;validate:&quot;lte=0,gte=120&quot;&lt;/code&gt; (大于等于0小于等于120)&lt;/li&gt;
&lt;li&gt;lt：小于参数值，&lt;code&gt;validate:&quot;lt=3&quot;&lt;/code&gt; (小于3)&lt;/li&gt;
&lt;li&gt;gt：大于参数值，&lt;code&gt;validate:&quot;lt=0,gt=120&quot;&lt;/code&gt; (大于0小于120)&lt;/li&gt;
&lt;li&gt;len：等于参数值，&lt;code&gt;validate:&quot;len=2&quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;max：大于等于参数值，&lt;code&gt;validate:&quot;max=2&quot;&lt;/code&gt; (大于等于2)&lt;/li&gt;
&lt;li&gt;min：小于等于参数值，&lt;code&gt;validate:&quot;min=2,max=10&quot;&lt;/code&gt; (大于等于2小于等于10)&lt;/li&gt;
&lt;li&gt;ne：不等于，&lt;code&gt;validate:&quot;ne=2&quot;&lt;/code&gt; (不等于2)&lt;/li&gt;
&lt;li&gt;oneof：只能是列举出的值其中一个，这些值必须是数值或字符串，以空格分隔，如果字符串中有空格，将字符串用单引号包围，&lt;code&gt;validate:&quot;oneof=red green&quot;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;type User struct {
    Name string `json:&quot;name&quot; validate:&quot;min=0,max=35&quot;`
    Age  unit8  `json:&quot;age&quot; validate:&quot;lte=0,gte=90&quot;`
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;更多功能请参看文档 &lt;a href=&quot;https://github.com/go-playground/validator/blob/master/README.md#comparisons&quot;&gt;validator comparisons doc&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;字符串验证&quot;&gt;字符串验证&lt;/h3&gt;
&lt;blockquote readability=&quot;0.32467532467532&quot;&gt;
&lt;p&gt;doc: &lt;a href=&quot;https://github.com/go-playground/validator/blob/master/README.md#strings&quot;&gt;https://github.com/go-playground/validator/blob/master/README.md#strings&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;contains：包含参数子串，&lt;code&gt;validate:&quot;contains=tom&quot;&lt;/code&gt; (字段的字符串值包含tom)&lt;/li&gt;
&lt;li&gt;excludes：包含参数子串，&lt;code&gt;validate:&quot;excludes=tom&quot;&lt;/code&gt; (字段的字符串值不包含tom)&lt;/li&gt;
&lt;li&gt;startswith：以参数子串为前缀，&lt;code&gt;validate:&quot;startswith=golang&quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;endswith：以参数子串为后缀，&lt;code&gt;validate:&quot;startswith=world&quot;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;type User struct { 
    Name string `validate:&quot;contains=tom&quot;` 
    Age int `validate:&quot;min=1&quot;`
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;更多功能请参看文档 &lt;a href=&quot;https://github.com/go-playground/validator/blob/master/README.md#strings&quot;&gt;validator strings doc&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;字段验证&quot;&gt;字段验证&lt;/h3&gt;
&lt;blockquote readability=&quot;0.32894736842105&quot;&gt;
&lt;p&gt;doc: &lt;a href=&quot;https://github.com/go-playground/validator/blob/master/README.md#fields&quot;&gt;https://github.com/go-playground/validator/blob/master/README.md#fields&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;eqcsfield：跨不同结构体字段验证，比如说 Struct1 Filed1，与结构体Struct2 Field2相等，&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;type Struct1 struct {
    Field1 string `validate:eqcsfield=Struct2.Field2`
    Struct2 struct {
        Field2 string 
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;type User struct { 
    Name string `validate:&quot;lte=4&quot;` 
    Age int `validate:&quot;min=20&quot;` 
    Password string `validate:&quot;min=10&quot;`
    Password2 string `validate:&quot;eqfield=Password&quot;`
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;nefield：同一结构体字段验证不相等&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;type User struct {
    Name string `validate:&quot;lte=4&quot;` 
    Age int `validate:&quot;min=20&quot;` 
    Password string `validate:&quot;min=10,nefield=Name&quot;`
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;gtefield：大于等于同一结构体字段，&lt;code&gt;validate:&quot;gtefiled=Field2&quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;ltefield：小于等于同一结构体字段&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;更多功能请参看文档：&lt;a href=&quot;https://github.com/go-playground/validator/blob/master/README.md#fields&quot;&gt;validator Fields DOC&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;网络验证&quot;&gt;网络验证&lt;/h3&gt;
&lt;blockquote readability=&quot;0.32467532467532&quot;&gt;
&lt;p&gt;doc: &lt;a href=&quot;https://github.com/go-playground/validator/blob/master/README.md#network&quot;&gt;https://github.com/go-playground/validator/blob/master/README.md#network&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;ip：字段值是否包含有效的IP地址，&lt;code&gt;validate:&quot;ip&quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;ipv4：字段值是否包含有效的ipv4地址，&lt;code&gt;validate:&quot;ipv4&quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;ipv6：字段值是否包含有效的ipv6地址，&lt;code&gt;validate:&quot;ipv6&quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;uri：字段值是否包含有效的uri，&lt;code&gt;validate:&quot;uri&quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;url：字段值是否包含有效的uri，&lt;code&gt;validate:&quot;url&quot;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;更多功能请参看文档：&lt;a href=&quot;https://github.com/go-playground/validator/blob/master/README.md#network&quot;&gt;validator network DOC&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;format&quot;&gt;Format&lt;/h3&gt;
&lt;blockquote readability=&quot;0.32894736842105&quot;&gt;
&lt;p&gt;doc: &lt;a href=&quot;https://github.com/go-playground/validator/blob/master/README.md#format&quot;&gt;https://github.com/go-playground/validator/blob/master/README.md#format&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;base64：字段值是否包含有效的base64值&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;更多功能请参看文档 &lt;a href=&quot;https://github.com/go-playground/validator/blob/master/README.md#strings&quot;&gt;validator strings doc&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;其他&quot;&gt;其他&lt;/h3&gt;
&lt;blockquote readability=&quot;0.97701149425287&quot;&gt;
&lt;p&gt;请参看文档: &lt;a href=&quot;https://github.com/go-playground/validator/blob/master/README.md#other&quot;&gt;https://github.com/go-playground/validator/blob/master/README.md#other&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;三、安装&quot;&gt;三、安装&lt;/h2&gt;
&lt;p&gt;go get:&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;go get github.com/go-playground/validator/v10&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在文件中引用validator包：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;import &quot;github.com/go-playground/validator/v10&quot;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;四、validator使用&quot;&gt;四、validator使用&lt;/h2&gt;
&lt;blockquote readability=&quot;0.54878048780488&quot;&gt;
&lt;p&gt;文档：&lt;a href=&quot;https://github.com/go-playground/validator/blob/master/README.md#examples&quot;&gt;https://github.com/go-playground/validator/blob/master/README.md#examples&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;例子1：验证单个字段变量值&quot;&gt;例子1：验证单个字段变量值&lt;/h3&gt;
&lt;p&gt;validation1.go&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;package main

import (
        &quot;fmt&quot;

        &quot;github.com/go-playground/validator/v10&quot;
)

func main() {
        validate := validator.New()

        var boolTest bool
        err := validate.Var(boolTest, &quot;required&quot;)
        if err != nil {
                fmt.Println(err)
        }
        var stringTest string = &quot;&quot;
        err = validate.Var(stringTest, &quot;required&quot;)
        if err != nil {
                fmt.Println(err)
        }

        var emailTest string = &quot;test@126.com&quot;
        err = validate.Var(emailTest, &quot;email&quot;)
        if err != nil {
                fmt.Println(err)
        } else {
                fmt.Println(&quot;success&quot;) // 输出： success。 说明验证成功
        }

        emailTest2 := &quot;test.126.com&quot;
        errs := validate.Var(emailTest2, &quot;required,email&quot;)
        if errs != nil {
                fmt.Println(errs) // 输出: Key: &quot;&quot; Error:Field validation for &quot;&quot; failed on the &quot;email&quot; tag。验证失败
        }

        fmt.Println(&quot;\r\nEnd!!&quot;)
    
    
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行输出：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;go run simple1.go&lt;br/&gt;Key: '' Error:Field validation for '' failed on the 'required' tag&lt;br/&gt;Key: '' Error:Field validation for '' failed on the 'required' tag&lt;br/&gt;success&lt;br/&gt;Key: '' Error:Field validation for '' failed on the 'email' tag&lt;/p&gt;
&lt;p&gt;End!!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;例子2：验证结构体struct&quot;&gt;例子2：验证结构体struct&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;from：&lt;a href=&quot;https://github.com/go-playground/validator/blob/master/_examples/simple/main.go&quot;&gt;struct validate&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;validation_struct.go，这个程序还列出了效验出错字段的一些信息，&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;package main

import (
        &quot;fmt&quot;

        &quot;github.com/go-playground/validator/v10&quot;
)

type User struct {
        FirstName string     `validate:&quot;required&quot;`
        LastName  string     `validate:&quot;required&quot;`
        Age       uint8      `validate:&quot;gte=0,lte=130&quot;`
        Email     string     `validate:&quot;required,email&quot;`
        Addresses []*Address `validate:&quot;required,dive,required&quot;`
}

type Address struct {
        Street string `validate:&quot;required&quot;`
        City   string `validate:&quot;required&quot;`
        Planet string `validate:&quot;required&quot;`
        Phone  string `validate:&quot;required&quot;`
}

func main() {
        address := &amp;amp;Address{
                Street: &quot;Eavesdown Docks&quot;,
                Planet: &quot;Persphone&quot;,
                Phone:  &quot;none&quot;,
        }

        user := &amp;amp;User{
                FirstName: &quot;Badger&quot;,
                LastName:  &quot;Smith&quot;,
                Age:       135,
                Email:     &quot;Badger.Smith@gmail.com&quot;,
                Addresses: []*Address{address},
        }

        validate := validator.New()
        err := validate.Struct(user)
        if err != nil {
                fmt.Println(&quot;=== error msg ====&quot;)
                fmt.Println(err)

                if _, ok := err.(*validator.InvalidValidationError); ok {
                        fmt.Println(err)
                        return
                }

                fmt.Println(&quot;\r\n=========== error field info ====================&quot;)
                for _, err := range err.(validator.ValidationErrors) {
           // 列出效验出错字段的信息
                        fmt.Println(&quot;Namespace: &quot;, err.Namespace())
                        fmt.Println(&quot;Fild: &quot;, err.Field())
                        fmt.Println(&quot;StructNamespace: &quot;, err.StructNamespace())
                        fmt.Println(&quot;StructField: &quot;, err.StructField())
                        fmt.Println(&quot;Tag: &quot;, err.Tag())
                        fmt.Println(&quot;ActualTag: &quot;, err.ActualTag())
                        fmt.Println(&quot;Kind: &quot;, err.Kind())
                        fmt.Println(&quot;Type: &quot;, err.Type())
                        fmt.Println(&quot;Value: &quot;, err.Value())
                        fmt.Println(&quot;Param: &quot;, err.Param())
                        fmt.Println()
                }

                // from here you can create your own error messages in whatever language you wish
                return
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行 输出：&lt;/p&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;$ go run validation_struct.go&lt;br/&gt;=== error msg ====&lt;br/&gt;Key: 'User.Age' Error:Field validation for 'Age' failed on the 'lte' tag&lt;br/&gt;Key: 'User.Addresses[0].City' Error:Field validation for 'City' failed on the 'required' tag&lt;/p&gt;
&lt;p&gt;=========== error field info ====================&lt;br/&gt;Namespace: User.Age&lt;br/&gt;Fild: Age&lt;br/&gt;StructNamespace: User.Age&lt;br/&gt;StructField: Age&lt;br/&gt;Tag: lte&lt;br/&gt;ActualTag: lte&lt;br/&gt;Kind: uint8&lt;br/&gt;Type: uint8&lt;br/&gt;Value: 135&lt;br/&gt;Param: 130&lt;/p&gt;
&lt;p&gt;Namespace: User.Addresses[0].City&lt;br/&gt;Fild: City&lt;br/&gt;StructNamespace: User.Addresses[0].City&lt;br/&gt;StructField: City&lt;br/&gt;Tag: required&lt;br/&gt;ActualTag: required&lt;br/&gt;Kind: string&lt;br/&gt;Type: string&lt;br/&gt;Value:&lt;br/&gt;Param:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;还可以给字段加一些其他tag信息，方面form，json的解析，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;type User struct {
    FirstName string     `form:&quot;firstname&quot; json:&quot;firstname&quot; validate:&quot;required&quot;`
        LastName  string     `form:&quot;lastname&quot; json:&quot;lastname&quot; validate:&quot;required&quot;`
        Age       uint8      ` form:&quot;age&quot; json:&quot;age&quot;validate:&quot;gte=0,lte=130&quot;`
        Email     string     ` form:&quot;email&quot; json:&quot;email&quot; validate:&quot;required,email&quot;`
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;用户自定义函数验证&quot;&gt;用户自定义函数验证&lt;/h3&gt;
&lt;p&gt;用户自定义函数验证字段是否合法，效验是否正确。&lt;/p&gt;
&lt;h3 id=&quot;例子3-通过字段tag自定义函数&quot;&gt;例子3: 通过字段tag自定义函数&lt;/h3&gt;
&lt;h5 id=&quot;validateregistervalidation&quot;&gt;validate.RegisterValidation&lt;/h5&gt;
&lt;p&gt;customer_tag.go：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;package main

import (
        &quot;fmt&quot;

        &quot;github.com/go-playground/validator/v10&quot;
)

type User struct {
        Name string `form:&quot;name&quot; json:&quot;name&quot; validate:&quot;required,CustomerValidation&quot;` //注意：required和CustomerValidation之间不能有空格，否则panic。CustomerValidation：自定义tag-函数标签
        Age  uint8  ` form:&quot;age&quot; json:&quot;age&quot; validate:&quot;gte=0,lte=80&quot;`                 //注意：gte=0和lte=80之间不能有空格，否则panic
}

var validate *validator.Validate

func main() {
        validate = validator.New()
        validate.RegisterValidation(&quot;CustomerValidation&quot;, CustomerValidationFunc) //注册自定义函数，前一个参数是struct里tag自定义，后一个参数是自定义的函数

        user := &amp;amp;User{
                Name: &quot;jimmy&quot;,
                Age:  86,
        }

        fmt.Println(&quot;first value: &quot;, user)
        err := validate.Struct(user)
        if err != nil {
                fmt.Printf(&quot;Err(s):\n%+v\n&quot;, err)
        }

        user.Name = &quot;tom&quot;
        user.Age = 29
        fmt.Println(&quot;second value: &quot;, user)
        err = validate.Struct(user)
        if err != nil {
                fmt.Printf(&quot;Err(s):\n%+v\n&quot;, err)
        }
}

// 自定义函数
func CustomerValidationFunc(f1 validator.FieldLevel) bool {
    // f1 包含了字段相关信息
    // f1.Field() 获取当前字段信息
    // f1.Param() 获取tag对应的参数
    // f1.FieldName() 获取字段名称
    
        return f1.Field().String() == &quot;jimmy&quot;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行输出：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;$ go run customer.go&lt;br/&gt;first value: &amp;amp;{jimmy 86}&lt;br/&gt;Err(s):&lt;br/&gt;Key: 'User.Age' Error:Field validation for 'Age' failed on the 'lte' tag&lt;br/&gt;second value: &amp;amp;{tom 29}&lt;br/&gt;Err(s):&lt;br/&gt;Key: 'User.Name' Error:Field validation for 'Name' failed on the 'CustomerValidation' tag&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;u&gt;**注意&lt;/u&gt;：&lt;/p&gt;
&lt;p&gt;上面代码&lt;code&gt;user struct&lt;/code&gt;定义中 ，&lt;code&gt;validate&lt;/code&gt;里的required和CustomerValidation之间不能有空格，否则运行时报panic错误：&lt;code&gt;panic: Undefined validation function ' CustomerValidation' on field 'Name'&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;例子4：自定义函数-直接注册函数1&quot;&gt;例子4：自定义函数-直接注册函数1&lt;/h3&gt;
&lt;p&gt;不通过字段tag自定义函数，直接注册函数。&lt;/p&gt;
&lt;h5 id=&quot;registerstructvalidation&quot;&gt;RegisterStructValidation&lt;/h5&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/go-playground/validator/blob/master/_examples/struct-level/main.go&quot;&gt;https://github.com/go-playground/validator/blob/master/_examples/struct-level/main.go&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;customer1.go&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;package main

import (
        &quot;fmt&quot;

        &quot;github.com/go-playground/validator/v10&quot;
)

type User struct {
        FirstName      string `json:firstname`
        LastName       string `json:lastname`
        Age            uint8  `validate:&quot;gte=0,lte=130&quot;`
        Email          string `validate:&quot;required,email&quot;`
        FavouriteColor string `validate:&quot;hexcolor|rgb|rgba&quot;`
}

var validate *validator.Validate

func main() {
        validate = validator.New()

        validate.RegisterStructValidation(UserStructLevelValidation, User{})

        user := &amp;amp;User{
                FirstName:      &quot;&quot;,
                LastName:       &quot;&quot;,
                Age:            30,
                Email:          &quot;TestFunc@126.com&quot;,
                FavouriteColor: &quot;#000&quot;,
        }

        err := validate.Struct(user)
        if err != nil {
                fmt.Println(err)
        }
}

func UserStructLevelValidation(sl validator.StructLevel) {
        user := sl.Current().Interface().(User)

        if len(user.FirstName) == 0 &amp;amp;&amp;amp; len(user.LastName) == 0 {
                sl.ReportError(user.FirstName, &quot;FirstName&quot;, &quot;firstname&quot;, &quot;firstname&quot;, &quot;&quot;)
                sl.ReportError(user.LastName, &quot;LastName&quot;, &quot;lastname&quot;, &quot;lastname&quot;, &quot;&quot;)
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行输出：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;$ go run customer1.go&lt;br/&gt;Key: 'User.FirstName' Error:Field validation for 'FirstName' failed on the 'firstname' tag&lt;br/&gt;Key: 'User.LastName' Error:Field validation for 'LastName' failed on the 'lastname' tag&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;例子5：自定义函数-直接注册函数2&quot;&gt;例子5：自定义函数-直接注册函数2&lt;/h3&gt;
&lt;h5 id=&quot;registercustomtypefunc&quot;&gt;RegisterCustomTypeFunc&lt;/h5&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/go-playground/validator/blob/master/_examples/custom/main.go&quot;&gt;https://github.com/go-playground/validator/blob/master/_examples/custom/main.go&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/go-playground/validator/blob/d6b17fd90bd4dd9d16a594c3035ceadc3de0193a/validator_instance.go#L241%22&quot;&gt;validate.RegisterCustomTypeFunc&lt;/a&gt;：验证类型的自定义函数&lt;/p&gt;
&lt;p&gt;customer2.go：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;package main

import (
        &quot;database/sql&quot;
        &quot;database/sql/driver&quot;
        &quot;fmt&quot;
        &quot;reflect&quot;

        &quot;github.com/go-playground/validator/v10&quot;
)

type DbBackedUser struct {
        Name sql.NullString `validate:&quot;required&quot;`
        Age  sql.NullInt64  `validate:&quot;required&quot;`
}

var validate *validator.Validate

func main() {
        validate = validator.New()

        validate.RegisterCustomTypeFunc(ValidateValuer, sql.NullString{}, sql.NullInt64{}, sql.NullBool{}, sql.NullFloat64{})

        // build object for validation
        x := DbBackedUser{Name: sql.NullString{String: &quot;&quot;, Valid: true}, Age: sql.NullInt64{Int64: 0, Valid: false}}

        err := validate.Struct(x)
        if err != nil {
                fmt.Printf(&quot;Err(s):\n%+v\n&quot;, err)
        }
}

func ValidateValuer(field reflect.Value) interface{} {
        if valuer, ok := field.Interface().(driver.Valuer); ok {
                val, err := valuer.Value()
                if err == nil {
                        return val
                }
                // handle the error how you want
        }
        return nil
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行输出：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;$ go run customer.go&lt;br/&gt;Err(s):&lt;br/&gt;Key: 'DbBackedUser.Name' Error:Field validation for 'Name' failed on the 'required' tag&lt;br/&gt;Key: 'DbBackedUser.Age' Error:Field validation for 'Age' failed on the 'required' tag&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;u&gt;注意，这个函数&lt;/u&gt;&lt;/strong&gt;：&lt;br/&gt;&lt;a href=&quot;https://github.com/go-playground/validator/blob/d6b17fd90bd4dd9d16a594c3035ceadc3de0193a/validator_instance.go#L241%22&quot;&gt;RegisterCustomTypeFunc&lt;/a&gt;，它上面有2行注释：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;// RegisterCustomTypeFunc registers a CustomTypeFunc against a number of types&lt;br/&gt;//&lt;br/&gt;// NOTE: this method is not thread-safe it is intended that these all be registered prior to any validation&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;它是一个验证数据类型自定义函数，NOTE:这个方法不是线程安全的&lt;/p&gt;
&lt;h2 id=&quot;五、参考&quot;&gt;五、参考&lt;/h2&gt;
</description>
<pubDate>Thu, 15 Oct 2020 15:42:00 +0000</pubDate>
<dc:creator>九卷</dc:creator>
<og:description>golang常用库：gorilla/mux-http路由库使用 golang常用库：配置文件解析库-viper使用 golang常用库：操作数据库的orm框架-gorm基本使用 golang常用库：字</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jiujuan/p/13823864.html</dc:identifier>
</item>
<item>
<title>Mock测试你的Spring MVC接口 - 码农小胖哥</title>
<link>http://www.cnblogs.com/felordcn/p/13823833.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/felordcn/p/13823833.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1739473/202010/1739473-20201015233242368-1702529251.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-前言&quot;&gt;1. 前言&lt;/h2&gt;
&lt;p&gt;在Java开发中接触的开发者大多数不太注重对接口的测试，结果在联调对接中出现各种问题。也有的使用Postman等工具进行测试，虽然在使用上没有什么问题，如果接口增加了权限测试起来就比较恶心了。所以建议在单元测试中测试接口，保证在交付前先自测接口的健壮性。今天就来分享一下胖哥在开发中是如何对Spring MVC接口进行测试的。&lt;/p&gt;
&lt;p&gt;在开始前请务必确认添加了&lt;strong&gt;Spring Boot Test&lt;/strong&gt;相关的组件，在最新的版本中应该包含以下依赖：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
    &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
    &amp;lt;exclusions&amp;gt;
        &amp;lt;exclusion&amp;gt;
            &amp;lt;groupId&amp;gt;org.junit.vintage&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;junit-vintage-engine&amp;lt;/artifactId&amp;gt;
        &amp;lt;/exclusion&amp;gt;
    &amp;lt;/exclusions&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;本文是在&lt;strong&gt;Spring Boot 2.3.4.RELEASE&lt;/strong&gt;下进行的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;2-单独测试控制层&quot;&gt;2. 单独测试控制层&lt;/h2&gt;
&lt;p&gt;如果我们只需要对控制层接口(Controller)进行测试，且该接口不依赖&lt;code&gt;@Service&lt;/code&gt;、&lt;code&gt;@Component&lt;/code&gt;等注解声明的Spring Bean时，可以借助&lt;code&gt;@WebMvcTest&lt;/code&gt;来启用只针对Web控制层的测试，例如&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@WebMvcTest
class CustomSpringInjectApplicationTests {
    @Autowired
    MockMvc mockMvc;

    @SneakyThrows
    @Test
    void contextLoads() {
        mockMvc.perform(MockMvcRequestBuilders.get(&quot;/foo/map&quot;))
                .andExpect(ResultMatcher.matchAll(status().isOk(),
                        content().contentType(MediaType.APPLICATION_JSON),
                        jsonPath(&quot;$.test&quot;, Is.is(&quot;hello&quot;))))
                .andDo(MockMvcResultHandlers.print());
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种方式要快的多，它只加载了应用程序的一小部分。但是如果你涉及到服务层这种方式是不凑效的，我们就需要另一种方式了。&lt;/p&gt;
&lt;h2 id=&quot;3-整体测试&quot;&gt;3. 整体测试&lt;/h2&gt;
&lt;p&gt;大多数Spring Boot下的接口测试是整体而又全面的测试，涉及到控制层、服务层、持久层等方方面面，所以需要加载比较完整的Spring Boot上下文。这时我们可以这样做，声明一个抽象的测试基类：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package cn.felord.custom;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.web.servlet.MockMvc;


/**
 * 测试基类，
 * @author felord.cn
 */
@SpringBootTest
@AutoConfigureMockMvc
abstract class CustomSpringInjectApplicationTests {
    /**
     * The Mock mvc.
     */
    @Autowired
    MockMvc mockMvc;
    // 其它公共依赖和处理方法 
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;只有当&lt;code&gt;@AutoConfigureMockMvc&lt;/code&gt;存在时&lt;code&gt;MockMvc&lt;/code&gt;才会被注入Spring IoC。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然后针对具体的控制层进行如下测试代码的编写：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package cn.felord.custom;

import lombok.SneakyThrows;
import org.hamcrest.core.Is;
import org.junit.jupiter.api.Test;
import org.springframework.http.MediaType;
import org.springframework.test.web.servlet.ResultMatcher;
import org.springframework.test.web.servlet.request.MockMvcRequestBuilders;
import org.springframework.test.web.servlet.result.MockMvcResultHandlers;

import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

/**
 * 测试FooController.
 *
 * @author felord.cn
 */
public class FooTests extends CustomSpringInjectApplicationTests {
    /**
     * /foo/map接口测试.
     */
    @SneakyThrows
    @Test
    void contextLoads() {
        mockMvc.perform(MockMvcRequestBuilders.get(&quot;/foo/map&quot;))
                .andExpect(ResultMatcher.matchAll(status().isOk(),
                        content().contentType(MediaType.APPLICATION_JSON),
                        jsonPath(&quot;$.test&quot;, Is.is(&quot;bar&quot;))))
                .andDo(MockMvcResultHandlers.print());
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;4-mockmvc测试&quot;&gt;4. MockMvc测试&lt;/h2&gt;
&lt;p&gt;集成测试时，希望能够通过输入URL对Controller进行测试，如果通过启动服务器，建立http client进行测试，这样会使得测试变得很麻烦，比如，启动速度慢，测试验证不方便，依赖网络环境等，为了可以对Controller进行测试就引入了&lt;code&gt;MockMvc&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MockMvc&lt;/code&gt;实现了对Http请求的模拟，能够直接使用网络的形式，转换到Controller的调用，这样可以使得测试速度快、不依赖网络环境，而且提供了一套验证的工具，这样可以使得请求的验证统一而且很方便。接下来我们来一步步构造一个测试的模拟请求，假设我们存在一个下面这样的接口：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@RestController
@RequestMapping(&quot;/foo&quot;)
public class FooController {
    @Autowired
    private MyBean myBean;

    @GetMapping(&quot;/user&quot;)
    public Map&amp;lt;String, String&amp;gt; bar(@RequestHeader(&quot;Api-Version&quot;) String apiVersion, User user) {
        Map&amp;lt;String, String&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
        map.put(&quot;test&quot;, myBean.bar());
        map.put(&quot;version&quot;, apiVersion);
        map.put(&quot;username&quot;, user.getName());
        //todo your business
        return map;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数设定为&lt;code&gt;name=felord.cn&amp;amp;age=18&lt;/code&gt;，那么对应的HTTP报文是这样的：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-http&quot;&gt;GET /foo/user?name=felord.cn&amp;amp;age=18 HTTP/1.1
Host: localhost:8888
Api-Version: v1
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以预见的返回值为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;{
    &quot;test&quot;: &quot;bar&quot;,
    &quot;version&quot;: &quot;v1&quot;,
    &quot;username&quot;: &quot;felord.cn&quot;
}       
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;事实上对接口的测试可以分为以下几步。&lt;/p&gt;
&lt;h3 id=&quot;构建请求&quot;&gt;构建请求&lt;/h3&gt;
&lt;p&gt;构建请求由&lt;code&gt;MockMvcRequestBuilders&lt;/code&gt;负责，他提供了请求方法（Method），请求头(Header)，请求体(Body)，参数（Parameters），会话（Session）等所有请求的属性构建。&lt;code&gt;/foo/user&lt;/code&gt;接口的请求可以转换为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;MockMvcRequestBuilders.get(&quot;/foo/user&quot;)
                .param(&quot;name&quot;, &quot;felord.cn&quot;)
                .param(&quot;age&quot;, &quot;18&quot;)
                .header(&quot;Api-Version&quot;, &quot;v1&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;执行mock请求&quot;&gt;执行Mock请求&lt;/h3&gt;
&lt;p&gt;然后由&lt;code&gt;MockMvc&lt;/code&gt;执行Mock请求：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;mockMvc.perform(MockMvcRequestBuilders.get(&quot;/foo/user&quot;)
                .param(&quot;name&quot;, &quot;felord.cn&quot;)
                .param(&quot;age&quot;, &quot;18&quot;)
                .header(&quot;Api-Version&quot;, &quot;v1&quot;))
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;对结果进行处理&quot;&gt;对结果进行处理&lt;/h3&gt;
&lt;p&gt;请求结果被封装到&lt;code&gt;ResultActions&lt;/code&gt;对象中，它封装了多种让我们对Mock请求结果进行处理的方法。&lt;/p&gt;
&lt;h4 id=&quot;对结果进行预期期望&quot;&gt;对结果进行预期期望&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;ResultActions#andExpect(ResultMatcher matcher)&lt;/code&gt;方法负责对响应的结果的进行预期期望，看看是否符合测试的期望值。参数&lt;code&gt;ResultMatcher&lt;/code&gt;负责从响应对象中提取我们需要期望的部位进行预期比对。&lt;/p&gt;
&lt;p&gt;假如我们期望接口&lt;code&gt;/foo/user&lt;/code&gt;返回的是&lt;code&gt;JSON&lt;/code&gt;，并且HTTP状态为&lt;code&gt;200&lt;/code&gt;，同时响应体包含了&lt;code&gt;version=v1&lt;/code&gt;的值，我们应该这么声明：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;   ResultMatcher.matchAll(MockMvcResultMatchers.status().isOk(),
                MockMvcResultMatchers.content().contentType(MediaType.APPLICATION_JSON),
                MockMvcResultMatchers.jsonPath(&quot;$.version&quot;, Is.is(&quot;v1&quot;)));
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;JsonPath&lt;/strong&gt;是一个强大的JSON解析类库，请通过其项目仓库https://github.com/json-path/JsonPath了解。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;对响应进行处理&quot;&gt;对响应进行处理&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;ResultActions#andDo(ResultHandler handler)&lt;/code&gt;方法负责对整个&lt;strong&gt;请求/响应&lt;/strong&gt;进行打印或者log输出、流输出，由&lt;code&gt;MockMvcResultHandlers&lt;/code&gt;工具类提供这些方法。我们可以通过以上三种途径来查看请求响应的细节。&lt;/p&gt;
&lt;p&gt;例如&lt;code&gt;/foo/user&lt;/code&gt;接口：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;MockHttpServletRequest:
      HTTP Method = GET
      Request URI = /foo/user
       Parameters = {name=[felord.cn], age=[18]}
          Headers = [Api-Version:&quot;v1&quot;]
             Body = null
    Session Attrs = {}

Handler:
             Type = cn.felord.xbean.config.FooController
           Method = cn.felord.xbean.config.FooController#urlEncode(String, Params)

Async:
    Async started = false
     Async result = null

Resolved Exception:
             Type = null

ModelAndView:
        View name = null
             View = null
            Model = null

FlashMap:
       Attributes = null

MockHttpServletResponse:
           Status = 200
    Error message = null
          Headers = [Content-Type:&quot;application/json&quot;]
     Content type = application/json
             Body = {&quot;test&quot;:&quot;bar&quot;,&quot;version&quot;:&quot;v1&quot;,&quot;username&quot;:&quot;felord.cn&quot;}
    Forwarded URL = null
   Redirected URL = null
          Cookies = []
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;获取返回结果&quot;&gt;获取返回结果&lt;/h4&gt;
&lt;p&gt;如果你希望进一步处理响应的结果，也可以通过&lt;code&gt;ResultActions#andReturn()&lt;/code&gt;拿到&lt;code&gt;MvcResult&lt;/code&gt; 类型的结果进行进一步的处理。&lt;/p&gt;
&lt;h3 id=&quot;完整的测试过程&quot;&gt;完整的测试过程&lt;/h3&gt;
&lt;p&gt;通常&lt;code&gt;andExpect&lt;/code&gt;是我们必然会选择的，而&lt;code&gt;andDo&lt;/code&gt;和&lt;code&gt;andReturn&lt;/code&gt;在某些场景下会有用，它们两个是可选的。我们把上面的连在一起。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Autowired
MockMvc mockMvc;

@SneakyThrows
@Test
void contextLoads() {

     mockMvc.perform(MockMvcRequestBuilders.get(&quot;/foo/user&quot;)
            .param(&quot;name&quot;, &quot;felord.cn&quot;)
            .param(&quot;age&quot;, &quot;18&quot;)
            .header(&quot;Api-Version&quot;, &quot;v1&quot;))
            .andExpect(ResultMatcher.matchAll(status().isOk(),
                    content().contentType(MediaType.APPLICATION_JSON),
                    jsonPath(&quot;$.version&quot;, Is.is(&quot;v1&quot;))))
            .andDo(MockMvcResultHandlers.print());
            
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种流式的接口单元测试从语义上看也是比较好理解的，你可以使用各种断言、正例、反例测试你的接口，最终让你的接口更加健壮。&lt;/p&gt;
&lt;h2 id=&quot;5-总结&quot;&gt;5. 总结&lt;/h2&gt;
&lt;p&gt;一旦你熟练了这种方式，你编写的接口将更加具有权威性而不会再漏洞百出，甚至有时候你也可以使用Mock来设计接口，使之更加贴合业务。所以CRUD不是完全没有技术含量，高质量高效率的CRUD往往需要这种工程化的单元测试来支撑。好了今天的分享就到这里，我是：&lt;strong&gt;码农小胖哥&lt;/strong&gt;，多多关注，多多支持。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;关注公众号：Felordcn 获取更多资讯&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://felord.cn&quot;&gt;个人博客：https://felord.cn&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 15 Oct 2020 15:33:00 +0000</pubDate>
<dc:creator>码农小胖哥</dc:creator>
<og:description>1. 前言 在Java开发中接触的开发者大多数不太注重对接口的测试，结果在联调对接中出现各种问题。也有的使用Postman等工具进行测试，虽然在使用上没有什么问题，如果接口增加了权限测试起来就比较恶心</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/felordcn/p/13823833.html</dc:identifier>
</item>
<item>
<title>Git hub加载慢？下载慢？浏览慢？几个小技巧让你一键起飞！ - 落阳呀</title>
<link>http://www.cnblogs.com/hsluoyang/p/13823748.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hsluoyang/p/13823748.html</guid>
<description>&lt;p&gt;记得，那是一个风和日丽，艳阳高照的夜晚，只因为当初的一次回眸，于是便决然走向了程序员的道路，从此，CV大法心中记，代码伴我身。&lt;/p&gt;
&lt;p&gt;这一天，正当我打开电脑准备开开心心的使用CV大法完成任务的时候，却恼人的发现今天Git hub打开的速度慢的令人无法忍受。&lt;/p&gt;
&lt;p&gt;点开目录寻找源代码的时间够我看完一部电视剧。别问为什么不整个下载下来，问就是，整个下载需要的时间够人类移居到火星上去。&lt;/p&gt;
&lt;p&gt;又等了一会儿，看着电脑吃大圆饼的我实在是等不了了，把饼塞到兜里，就打开浏览器在键盘上啪嗒啪嗒一顿操作——嘿，你别说，可真让我找着了几个特别实用的方法。&lt;/p&gt;
&lt;p&gt;吃完剩下的饼，我把这几个方法一一告诉大家，经过我的长久使用，我保证肯定靠谱，如果不靠谱诅咒我代码天天有BUG。&lt;/p&gt;
&lt;ol readability=&quot;4&quot;&gt;&lt;li readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;strong&gt;杀手锏——码云大法好&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Git hub之所以慢的让人难以忍受，是因为它是部署在国外的服务器上的网站，咱国内嘛，因为一些特别的原因，无法访问或者是极慢速访问国外网站。如果我们把Git hub的项目转到了国内的代码托管平台——码云上的话，问题迎刃而解。&lt;/p&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;首先，打开码云的官网&lt;code&gt;https://gitee.com/&lt;/code&gt;注册一个账户并登录。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;鼠标移动到右上角的&lt;code&gt;+&lt;/code&gt;号，会下拉出一个列表框，点击其中的 &lt;code&gt;从 GitHub / GitLab 导入仓库&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;在出现的界面当中把需要下载的Git hub仓库的地址复制进去，仓库名称和路径会自动生成，然后点击导入就可。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;最后，在生成的仓库页面，直接点击下载，你所需要的项目就会飞快地向你电脑飞奔过来啦~&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以下是部分操作截图:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201015224246153.png&quot; alt=&quot;步骤1&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201015224309327.png&quot; alt=&quot;步骤2&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201015224309324.png&quot; alt=&quot;步骤3&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;2. 谷歌插件——&lt;code&gt;Octotree - GitHub code tree&lt;/code&gt;与&lt;code&gt;GitZip for github&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;两个插件辅助使用，可以让你的Git hub 使用体检瞬间提升，先上个我使用这两个插件的图片：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201015224353707.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图中有个三个圆圈，第一个为一个目录树，由插件&lt;code&gt;Octotree - GitHub code tree&lt;/code&gt;加载，可以快速加载出此仓库的文件目录，免去一个个点击进去查看等待的烦恼。&lt;/p&gt;
&lt;p&gt;第二和第三个圆圈是可以选择仓库中某一个或者几个文件/文件夹下载，可以不用因为下载不需要的文件耽误时间，由插件&lt;code&gt;GitZip for github&lt;/code&gt;加载。&lt;/p&gt;
&lt;p&gt;这两个插件配合使用体验感极佳，让你的Git hub和你朋友的从此不一样，在我的公众号我会给出两个插件的下载链接，只需要回复&lt;strong&gt;Github插件兄弟&lt;/strong&gt;。供需要的朋友下载（不用翻墙）。&lt;/p&gt;
&lt;ol start=&quot;3&quot; readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;一本万利的办法——科学&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个办法虽然可能是难度最高的，但是却是最一本万利的办法。&lt;/p&gt;
&lt;p&gt;如果有好的科学网络，下Git hub完全不成问题，同时也可以使用谷歌搜索方便我们查找资料（CV代码），会给我们的程序生活带来很多的便利。&lt;/p&gt;
&lt;p&gt;鉴于一些原因，这个办法请大家自行探索。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;以上技巧，本人用的最多的办法就是码云大法啦，便捷快速，赏心悦目。&lt;/p&gt;
&lt;p&gt;第二个技巧中的目录树也会经常用到，在需要查看Git hub代码而又不用下载的时候，这个目录树就嘿方便。&lt;/p&gt;
&lt;p&gt;这几个Git hub快速下载/浏览技巧，你Get到了嘛？关注我的公众号【程序小员】，给你的程序生涯带来更多的轻松与快乐！&lt;/p&gt;
&lt;p&gt;我是落阳，谢谢你的到访！&lt;/p&gt;
</description>
<pubDate>Thu, 15 Oct 2020 15:07:00 +0000</pubDate>
<dc:creator>落阳呀</dc:creator>
<og:description>记得，那是一个风和日丽，艳阳高照的夜晚，只因为当初的一次回眸，于是便决然走向了程序员的道路，从此，CV大法心中记，代码伴我身。 这一天，正当我打开电脑准备开开心心的使用CV大法完成任务的时候，却恼人的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hsluoyang/p/13823748.html</dc:identifier>
</item>
<item>
<title>如何优雅的搞垮服务器，再优雅的救活 - 天下技术</title>
<link>http://www.cnblogs.com/mysqlcskdpl/p/13823710.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mysqlcskdpl/p/13823710.html</guid>
<description>&lt;p&gt;新开发的jar包部署在老服务器上，版本是Red Hat Enterprise Linux AS release 4 (Nahant Update 5)，提示需要高版本jdk,高版本jdk提示glibc版本太低得升级，是的，就像套娃。&lt;br/&gt;使用编译源码的方式将glibc由2.3升级到2.9，升级完ls命令不好使了。 用LD_PRELOAD方法解决了ls命令不好使的问题后还挺有成就感的呢！&lt;br/&gt;轻度强迫症的我当然要重启，然后&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#reboot
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;就没有然后了。。&lt;br/&gt;操作系统起不来了。各种尝试，最好的结果是卡死在&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Starting cups-config-daemon:
Starting HAL daemon:
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再也不往下走了。007的服务器被996的程序员干进了ICU。&lt;br/&gt;看到了吧，搞垮服务器可以显得很无辜。删库显得太刻意了，会被人指责性格有问题。&lt;/p&gt;

&lt;p&gt;像《信条》一样进行一次逆过程，把glibc相关的静态库、动态库都用原来的低版本覆盖回来。cp覆盖和安装rpm覆盖一起上。&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;能进机房，直接操作服务器，因为ssh此时已经连不上了。&lt;/li&gt;
&lt;li&gt;有相同版本的Linux系统光盘，Linux抢救模式需要光盘引导。&lt;/li&gt;
&lt;li&gt;有相同版本的Linux系统的iso镜像文件，用来获取rpm 【或者替代方法】&lt;/li&gt;
&lt;li&gt;有相同版本的Linux系统的服务器或者虚拟机，用来下载.a文件 【或者替代方法】&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;rpm安装包&quot;&gt;rpm安装包&lt;/h2&gt;
&lt;p&gt;将iso文件解压，在&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;RHEL4.6-i386-AS-DVD\RedHat\RPMS
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;目录下就包括所有需要的rpm包。&lt;br/&gt;需要准备的安装包是下面这些：&lt;br/&gt;&lt;img src=&quot;https://gitee.com/xllntl/picture/raw/master/2020-10-15/1602724830572-image001.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;a静态库文件&quot;&gt;.a静态库文件&lt;/h2&gt;
&lt;p&gt;到好用的版本一致的服务器对应目录下载下面的库文件&lt;br/&gt;目录/lib&lt;br/&gt;&lt;img src=&quot;https://gitee.com/xllntl/picture/raw/master/2020-10-15/1602724850882-image003.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;目录/usr/lib&lt;br/&gt;&lt;img src=&quot;https://gitee.com/xllntl/picture/raw/master/2020-10-15/1602724874361-image005.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;将这些安装包和静态库放入一个U盘中，U盘插到服务器上。&lt;/p&gt;

&lt;h2 id=&quot;进入光盘系统&quot;&gt;进入光盘系统&lt;/h2&gt;
&lt;p&gt;将光盘放入光驱。&lt;br/&gt;开机快速按F2，进入&lt;br/&gt;&lt;img src=&quot;https://gitee.com/xllntl/picture/raw/master/2020-10-15/1602724902867-image007.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;通过+-号调整开机启动顺序，将CD-ROM调整到最上面&lt;br/&gt;&lt;img src=&quot;https://gitee.com/xllntl/picture/raw/master/2020-10-15/1602724924172-image009.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;按回车，系统重新启动，进入光盘引导界面&lt;br/&gt;&lt;img src=&quot;https://gitee.com/xllntl/picture/raw/master/2020-10-15/1602724947905-image011.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;按F5，进入&lt;br/&gt;&lt;img src=&quot;https://gitee.com/xllntl/picture/raw/master/2020-10-15/1602724971166-image013.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;输入 linux rescue&lt;br/&gt;&lt;img src=&quot;https://gitee.com/xllntl/picture/raw/master/2020-10-15/1602724995702-image015.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;按回车，稍等一会，进入&lt;br/&gt;&lt;img src=&quot;https://gitee.com/xllntl/picture/raw/master/2020-10-15/1602725020827-image017.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;按回车，进入&lt;br/&gt;&lt;img src=&quot;https://gitee.com/xllntl/picture/raw/master/2020-10-15/1602725042774-image019.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;按回车，进入&lt;br/&gt;&lt;img src=&quot;https://gitee.com/xllntl/picture/raw/master/2020-10-15/1602725064119-image021.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;按回车，进入&lt;br/&gt;&lt;img src=&quot;https://gitee.com/xllntl/picture/raw/master/2020-10-15/1602725094439-image023.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;将光标移动到No，按回车，进入&lt;br/&gt;&lt;img src=&quot;https://gitee.com/xllntl/picture/raw/master/2020-10-15/1602725114114-image025.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;按回车，进入&lt;br/&gt;&lt;img src=&quot;https://gitee.com/xllntl/picture/raw/master/2020-10-15/1602725135289-image027.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;提示原有系统已经挂载到/mnt/sysimage，按回车进入，目前所处的就是光盘抢救模式（rescue mode），环境是光盘系统，原系统所有文件都在光盘系统的子目录/mnt/sysimage里。&lt;br/&gt;&lt;img src=&quot;https://gitee.com/xllntl/picture/raw/master/2020-10-15/1602725161804-image029.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;可以看到原有系统的所有目录结构在/mnt/sysimage下都是可以看见的。&lt;/p&gt;
&lt;h2 id=&quot;挂载u盘&quot;&gt;挂载U盘&lt;/h2&gt;
&lt;p&gt;首先将U盘挂载到光盘系统，&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mount -t vfat /dev/sdb1 /mnt/usb/
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;不同环境中U盘的标识符不一定是sdb1，在物理机上可能是sda1， 可以通过&lt;br/&gt;fdisk –l 命令看各个目录容量大小来判定哪个是U盘。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果挂载U盘提示格式错误，U盘可能是fat16格式，执行&lt;br/&gt;mount -t msdos /dev/sdb1 /mnt/usb/ 试试&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;此时，U盘里的文件都在/mnt/usb/目录下， 原系统所有文件都在/mnt/sysimage下。将usb目录下的文件拷贝到/mnt/sysimage下面你能记住的任意目录，本文拷贝到/mnt/sysimage/home下。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cp /mnt/usb/* /mnt/sysimage/home
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;切换到原系统&quot;&gt;切换到原系统&lt;/h2&gt;
&lt;p&gt;执行&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#chroot  /mnt/sysimage
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个指令使你由当前光盘系统切换到原系统(就是我们要抢救的那个系统)，执行pwd和ls可以看到，你所处的目录就是原系统的根目录，账号是原系统的root账号。&lt;br/&gt;&lt;img src=&quot;https://gitee.com/xllntl/picture/raw/master/2020-10-15/1602725208801-image031.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;一句话，原系统直接进进不去，但是从光盘系统跳，是能跳进去的。&lt;/p&gt;
&lt;h2 id=&quot;安装rpm&quot;&gt;安装rpm&lt;/h2&gt;
&lt;p&gt;进入/home，&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;rpm -ivh --force rpm包名
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一个一个安装U盘的rpm包。装失败的就等把成功的都装完了回头重试，和答卷子题不会一个玩法，都是依赖关系导致失败的。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;rpm最好自己重新命名，改成简短的名字（glibccomm.rpm这种），一定要去掉“-”。我当时看见显示器上显示的名字包括乱码和问号，靠猜来判断是哪个包，后悔之前没重命名。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;替换静态库文件&quot;&gt;替换静态库文件&lt;/h2&gt;
&lt;p&gt;然后手动cp指令替换/lib 和 /usr/lib的静态库（*.a文件）。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cp /home/libpthread.a  /lib
cp /home/*.a  /usr/lib
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;修改动态库软连接&quot;&gt;修改动态库软连接&lt;/h2&gt;
&lt;p&gt;手动修改动态库的软连接&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;无论安装rpm包时是否自动修改过软连接，都最好手动修改一遍。&lt;br/&gt;到/lib目录里，先&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;rm  *2.9*  #删除高版本的库
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ln -sf libutil-2.3.4.solibutil.so.1  
ln -sf libresolv-2.3.4.solibresolv.so.2  
ln -sf libnss_nis-2.3.4.solibnss_nis.so.2  
ln -sf libnss_nisplus-2.3.4.solibnss_nisplus.so.2  
ln -sf libnss_hesiod-2.3.4.solibnss_hesiod.so.2  
ln -sf libnss_files-2.3.4.so  libnss_files.so.2  
ln -sf libnss_dns-2.3.4.so  libnss_dns.so.2  
ln -sf libnss_compat-2.3.4.solibnss_compat.so.2  
ln -sf libnsl-2.3.4.solibnsl.so.1  
ln -sf libdl-2.3.4.solibdl.so.2  
ln -sf libcrypt-2.3.4.solibcrypt.so.1  
ln -sf libBrokenLocale-2.3.4.solibBrokenLocale.so.1  
ln -sf libanl-2.3.4.solibanl.so.1  
ln -sf libc-2.3.4.solibc.so.6  
ln -sf librt-2.3.4.solibrt.so.1  
ln -sf libpthread-0.10.so libpthread.so.0  
ln -sf libm-2.3.4.solibm.so.6  
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;跳回光盘系统&quot;&gt;跳回光盘系统&lt;/h2&gt;
&lt;p&gt;执行exit跳回到光盘系统，&lt;br/&gt;&lt;img src=&quot;https://gitee.com/xllntl/picture/raw/master/2020-10-15/1602725257720-image033.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;在上图光标处再一次输入exit，按回车 ，系统会重新启动。&lt;br/&gt;立刻修改BIOS，设置系统从硬盘启动，原系统可以正常启动了。&lt;/p&gt;

&lt;p&gt;抢救成功还挺有成就感的呢！其它操作搞垮服务器，也可以试试，只要那个操作能逆向来一遍，问题都不大。&lt;br/&gt;为什么不重装？上面部署的东西是多年前放的，物是人非，没办法重头再来。&lt;br/&gt;为什么敢升级？亲眼看见过别人把RHEL6.6的glibc升级了没出事。真不知道会出这么严重的问题。&lt;br/&gt;如果没有版本一致的光盘，接近的也可以。我实际用的光盘是RHEL4.6，和原系统差了一个小号。&lt;br/&gt;rpm和.a文件能拿到就行，不用非按本文方法。&lt;br/&gt;网友提供的替换so的方案不靠谱，必须rpm安装。&lt;br/&gt;2.3升级到2.9不可以，不代表升级到2.4也不可以，版本离的近可能成功。&lt;br/&gt;这个服务器至今还在跑着，那些jar包部署到别的服务器上了。&lt;/p&gt;
</description>
<pubDate>Thu, 15 Oct 2020 14:56:00 +0000</pubDate>
<dc:creator>天下技术</dc:creator>
<og:description>升级glibc后 Linux无法启动怎么办</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mysqlcskdpl/p/13823710.html</dc:identifier>
</item>
</channel>
</rss>