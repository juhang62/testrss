<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Javaer 进阶必看的 RocketMQ ，就这篇了 - yes的练级攻略</title>
<link>http://www.cnblogs.com/yescode/p/13832211.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yescode/p/13832211.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;每个时代，都不会亏待会学习的人。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;大家好，我是 yes。&lt;/p&gt;
&lt;p&gt;继上一篇 &lt;a href=&quot;https://mp.weixin.qq.com/s/rsy1Tl-E2Jl8l8hwqW62zQ&quot;&gt;头条终面：写个消息中间件&lt;/a&gt; ，我提到实现消息中间件的一些关键点，今天就和大家一起深入生产级别消息中间件 - RocketMQ 的内核实现，来看看真正落地能支撑万亿级消息容量、低延迟的消息队列到底是如何设计的。&lt;/p&gt;
&lt;p&gt;这篇文章我会先介绍整体的架构设计，然后再深入各核心模块的详细设计、核心流程的剖析。&lt;/p&gt;
&lt;p&gt;还会提及使用的一些注意点和最佳实践。&lt;/p&gt;
&lt;p&gt;对于消息队列的用处和一些概念不太清楚的同学强烈建议先看&lt;a href=&quot;https://mp.weixin.qq.com/s/nHKok3sG0ueg5EgVHwWnLg&quot;&gt;消息队列面试连环问&lt;/a&gt;，这篇文章介绍了消息队列的使用场景、基本概念和常见面试题。&lt;/p&gt;
&lt;p&gt;话不多说，上车。&lt;/p&gt;
&lt;h2 id=&quot;rocketmq-整体架构设计&quot;&gt;RocketMQ 整体架构设计&lt;/h2&gt;
&lt;p&gt;整体的架构设计主要分为四大部分，分别是：Producer、Consumer、Broker、NameServer。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/f31c3358070fdf51a465810e6731ad14.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了更贴合实际，我画的都是集群部署，像 Broker 我还画了主从。&lt;/p&gt;
&lt;ul readability=&quot;5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;Producer：就是消息生产者，可以集群部署。它会先和 NameServer 集群中的随机一台建立长连接，得知当前要发送的 Topic 存在哪台 Broker Master上，然后再与其建立长连接，支持多种负载平衡模式发送消息。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;Consumer：消息消费者，也可以集群部署。它也会先和 NameServer 集群中的随机一台建立长连接，得知当前要消息的 Topic 存在哪台 Broker Master、Slave上，然后它们建立长连接，支持集群消费和广播消费消息。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;Broker：主要负责消息的存储、查询消费，支持主从部署，一个 Master 可以对应多个 Slave，Master 支持读写，Slave 只支持读。&lt;strong&gt;Broker 会向集群中的每一台 NameServer 注册自己的路由信息。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;NameServer：是一个很简单的 Topic 路由注册中心，支持 Broker 的动态注册和发现，保存 Topic 和 Borker 之间的关系。通常也是集群部署，但是&lt;strong&gt;各 NameServer 之间不会互相通信， 各 NameServer 都有完整的路由信息&lt;/strong&gt;，即无状态。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我再用一段话来概括它们之间的交互：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/990f68d90ca6d13f56b2b85718ffd2a1.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;先启动 NameServer 集群，各 NameServer 之间无任何数据交互，Broker 启动之后会向所有 NameServer 定期（每 30s）发送心跳包，包括：IP、Port、TopicInfo，NameServer 会定期扫描 Broker 存活列表，如果超过 120s 没有心跳则移除此 Broker 相关信息，代表下线。&lt;/p&gt;
&lt;p&gt;这样每个 NameServer 就知道集群所有 Broker 的相关信息，此时 Producer 上线从 NameServer 就可以得知它要发送的某 Topic 消息在哪个 Broker 上，和对应的 Broker （Master 角色的）建立长连接，发送消息。&lt;/p&gt;
&lt;p&gt;Consumer 上线也可以从 NameServer 得知它所要接收的 Topic 是哪个 Broker ，和对应的 Master、Slave 建立连接，接收消息。&lt;/p&gt;
&lt;p&gt;简单的工作流程如上所述，相信大家对整体数据流转已经有点印象了，我们再来看看每个部分的详细情况。&lt;/p&gt;
&lt;h2 id=&quot;nameserver&quot;&gt;NameServer&lt;/h2&gt;
&lt;p&gt;它的特点就是轻量级，无状态。角色类似于 Zookeeper 的情况，从上面描述知道其主要的两个功能就是：Broker 管理、路由信息管理。&lt;/p&gt;
&lt;p&gt;总体而言比较简单，我再贴一些字段，让大家有更直观的印象知道它存储了些什么。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/3e0c0e863be79aef7cc64b31e94d16eb.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;producer&quot;&gt;Producer&lt;/h2&gt;
&lt;p&gt;Producer 无非就是消息生产者，那首先它得知道消息要发往哪个 Broker ，于是每 30s 会从某台 NameServer 获取 Topic 和 Broker 的映射关系存在本地内存中，如果发现新的 Broker 就会和其建立长连接，每 30s 会发送心跳至 Broker 维护连接。&lt;/p&gt;
&lt;p&gt;并且会&lt;strong&gt;轮询当前可以发送的 Broker 来发送消息&lt;/strong&gt;，达到负载均衡的目的，在&lt;strong&gt;同步发送情况&lt;/strong&gt;下如果发送失败会默认重投两次（retryTimesWhenSendFailed = 2），并且不会选择上次失败的 broker，会向其他 broker 投递。&lt;/p&gt;
&lt;p&gt;在&lt;strong&gt;异步发送&lt;/strong&gt;失败的情况下也会重试，默认也是两次 （retryTimesWhenSendAsyncFailed = 2），但是仅在同一个 Broker 上重试。&lt;/p&gt;
&lt;h3 id=&quot;producer-启动流程&quot;&gt;Producer 启动流程&lt;/h3&gt;
&lt;p&gt;然后我们再来看看 Producer 的启动流程看看都干了些啥。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/b7d84fa1fafe58266a4d2509461e6954.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;大致启动流程图中已经表明的很清晰的，但是有些细节可能还不清楚，比如重平衡啊，TBW102 啥玩意啊，有哪些定时任务啊，别急都会提到的。&lt;/p&gt;
&lt;p&gt;有人可能会问这生产者为什么要启拉取服务、重平衡？&lt;/p&gt;
&lt;p&gt;因为 Producer 和 Consumer 都需要用 MQClientInstance，而同一个 clientId 是共用一个 MQClientInstance 的， clientId 是通过本机 IP 和 instanceName（默认值 default）拼起来的，所以多个 Producer 、Consumer 实际用的是一个MQClientInstance。&lt;/p&gt;
&lt;p&gt;至于有哪些定时任务，请看下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/36760fdfbd251df05e703f4e2c0a3840.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;producer-发消息流程&quot;&gt;Producer 发消息流程&lt;/h3&gt;
&lt;p&gt;我们再来看看发消息的流程，大致也不是很复杂，无非就是找到要发送消息的 Topic 在哪个 Broker 上，然后发送消息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/5ccfee59837589b74ae104dc0451aa7a.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在就知道 TBW102 是啥用的，就是接受自动创建主题的 Broker 启动会把这个默认主题登记到 NameServer，这样当 Producer 发送新 Topic 的消息时候就得知哪个 Broker 可以自动创建主题，然后发往那个 Broker。&lt;/p&gt;
&lt;p&gt;而 Broker 接受到这个消息的时候发现没找到对应的主题，但是它接受创建新主题，这样就会创建对应的 Topic 路由信息。&lt;/p&gt;
&lt;h2 id=&quot;自动创建主题的弊端&quot;&gt;自动创建主题的弊端&lt;/h2&gt;
&lt;p&gt;自动创建主题那么有可能该主题的消息都只会发往一台 Broker，起不到负载均衡的作用。&lt;/p&gt;
&lt;p&gt;因为创建新 Topic 的请求到达 Broker 之后，Broker 创建对应的路由信息，但是心跳是每 30s 发送一次，所以说 NameServer 最长需要 30s 才能得知这个新 Topic 的路由信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;假设此时发送方还在连续快速的发送消息&lt;/strong&gt;，那 NameServer 上其实还没有关于这个 Topic 的路由信息，所以&lt;strong&gt;有机会&lt;/strong&gt;让别的允许自动创建的 Broker 也创建对应的 Topic 路由信息，这样集群里的 Broker 就能接受这个 Topic 的信息，达到负载均衡的目的，但也有个别 Broker 可能，没收到。&lt;/p&gt;
&lt;p&gt;如果发送方这一次发了之后 30s 内一个都不发，之前的那个 Broker 随着心跳把这个路由信息更新到 NameServer 了，那么之后发送该 Topic 消息的 Producer 从 NameServer 只能得知该 Topic 消息只能发往之前的那台 Broker ，这就不均衡了，如果这个新主题消息很多，那台 Broker 负载就很高了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以不建议线上开启允许自动创建主题，即 autoCreateTopicEnable 参数。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;发送消息故障延迟机制&quot;&gt;发送消息故障延迟机制&lt;/h2&gt;
&lt;p&gt;有一个参数是 sendLatencyFaultEnable，默认不开启。这个参数的作用是对于之前发送超时的 Broker 进行一段时间的退避。&lt;/p&gt;
&lt;p&gt;发送消息会记录此时发送消息的时间，如果超过一定时间，那么此 Broker 就在一段时间内不允许发送。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/c5175465dce2cf50ead77e250d4895d4.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;比如发送时间超过 15000ms 则在 600000 ms 内无法向该 Broker 发送消息。&lt;/p&gt;
&lt;p&gt;这个机制其实很关键，发送超时大概率表明此 Broker 负载高，所以先避让一会儿，让它缓一缓，这也是实现消息发送高可用的关键。&lt;/p&gt;
&lt;h2 id=&quot;小结一下&quot;&gt;小结一下&lt;/h2&gt;
&lt;p&gt;Producer 每 30s 会向 NameSrv 拉取路由信息更新本地路由表，有新的 Broker 就和其建立长连接，每隔 30s 发送心跳给 Broker 。&lt;/p&gt;
&lt;p&gt;不要在生产环境开启 autoCreateTopicEnable。&lt;/p&gt;
&lt;p&gt;Producer 会通过重试和延迟机制提升消息发送的高可用。&lt;/p&gt;
&lt;h2 id=&quot;broker&quot;&gt;Broker&lt;/h2&gt;
&lt;p&gt;Broker 就比较复杂一些了，但是非常重要。大致分为以下五大模块，我们来看一下官网的图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/3e5f411a1ab5e0005b9bacefde6650b1.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Remoting 远程模块，处理客户请求。&lt;/li&gt;
&lt;li&gt;Client Manager 管理客户端，维护订阅的主题。&lt;/li&gt;
&lt;li&gt;Store Service 提供消息存储查询服务。&lt;/li&gt;
&lt;li&gt;HA Serivce，主从同步高可用。&lt;/li&gt;
&lt;li&gt;Index Serivce，通过指定key 建立索引，便于查询。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;有几个模块没啥可说的就不分析了，先看看存储的。&lt;/p&gt;
&lt;h2 id=&quot;broker-的存储&quot;&gt;Broker 的存储&lt;/h2&gt;
&lt;p&gt;RocketMQ 存储用的是本地文件存储系统，效率高也可靠。&lt;/p&gt;
&lt;p&gt;主要涉及到三种类型的文件，分别是 CommitLog、ConsumeQueue、IndexFile。&lt;/p&gt;
&lt;h3 id=&quot;commitlog&quot;&gt;CommitLog&lt;/h3&gt;
&lt;p&gt;RocketMQ 的所有主题的消息都存在 CommitLog 中，单个 CommitLog 默认 1G，并且文件名以起始偏移量命名，固定 20 位，不足则前面补 0，比如 00000000000000000000 代表了第一个文件，第二个文件名就是 00000000001073741824，表明起始偏移量为 1073741824，以这样的方式命名用偏移量就能找到对应的文件。&lt;/p&gt;
&lt;p&gt;所有消息都是顺序写入的，超过文件大小则开启下一个文件。&lt;/p&gt;
&lt;h3 id=&quot;consumequeue&quot;&gt;ConsumeQueue&lt;/h3&gt;
&lt;p&gt;ConsumeQueue 消息消费队列，可以认为是 CommitLog 中消息的索引，因为 CommitLog 是糅合了所有主题的消息，所以通过索引才能更加高效的查找消息。&lt;/p&gt;
&lt;p&gt;ConsumeQueue 存储的条目是固定大小，只会存储 8 字节的 commitlog 物理偏移量，4 字节的消息长度和 8 字节 Tag 的哈希值，固定 20 字节。&lt;/p&gt;
&lt;p&gt;在实际存储中，ConsumeQueue 对应的是一个Topic 下的某个 Queue，每个文件约 5.72M，由 30w 条数据组成。&lt;/p&gt;
&lt;p&gt;消费者是先从 ConsumeQueue 来得到消息真实的物理地址，然后再去 CommitLog 获取消息。&lt;/p&gt;
&lt;h3 id=&quot;indexfile&quot;&gt;IndexFile&lt;/h3&gt;
&lt;p&gt;IndexFile 就是索引文件，是额外提供查找消息的手段，不影响主流程。&lt;/p&gt;
&lt;p&gt;通过 Key 或者时间区间来查询对应的消息，文件名以创建时间戳命名，固定的单个 IndexFile 文件大小约为400M，一个 IndexFile 存储 2000W个索引。&lt;/p&gt;
&lt;p&gt;我们再来看看以上三种文件的内容是如何生成的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/81f4f16a79883cb623a638e848138d42.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;消息到了先存储到 Commitlog，然后会有一个 ReputMessageService 线程接近实时地将消息转发给消息消费队列文件与索引文件，也就是说是异步生成的。&lt;/p&gt;
&lt;h2 id=&quot;消息刷盘机制&quot;&gt;消息刷盘机制&lt;/h2&gt;
&lt;p&gt;RocketMQ 提供消息同步刷盘和异步刷盘两个选择，关于刷盘我们都知道效率比较低，单纯存入内存中的话效率是最高的，但是可靠性不高，影响消息可靠性的情况大致有以下几种：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Broker 被暴力关闭，比如 kill -9&lt;/li&gt;
&lt;li&gt;Broker 挂了&lt;/li&gt;
&lt;li&gt;操作系统挂了&lt;/li&gt;
&lt;li&gt;机器断电&lt;/li&gt;
&lt;li&gt;机器坏了，开不了机&lt;/li&gt;
&lt;li&gt;磁盘坏了&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如果都是 1-4 的情况，同步刷盘肯定没问题，异步的话就有可能丢失部分消息，5 和 6就得依靠副本机制了，如果同步双写肯定是稳的，但是性能太差，如果异步则有可能丢失部分消息。&lt;/p&gt;
&lt;p&gt;所以需要看场景来使用同步、异步刷盘和副本双写机制。&lt;/p&gt;
&lt;h2 id=&quot;页缓存与内存映射&quot;&gt;页缓存与内存映射&lt;/h2&gt;
&lt;p&gt;Commitlog 是混合存储的，所以所有消息的写入就是顺序写入，对文件的顺序写入和内存的写入速度基本上没什么差别。&lt;/p&gt;
&lt;p&gt;并且 RocketMQ 的文件都利用了内存映射即 Mmap，将程序虚拟页面直接映射到页缓存上，无需有内核态再往用户态的拷贝，来看一下我之前文章画的图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/cedb46c42f71ad431bebead692249f6b.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;页缓存其实就是操作系统对文件的缓存，用来加速文件的读写，也就是说对文件的写入先写到页缓存中，操作系统会不定期刷盘（时间不可控），对文件的读会先加载到页缓存中，并且根据局部性原理还会预读临近块的内容。&lt;/p&gt;
&lt;p&gt;其实也是因为使用内存映射机制，所以 RocketMQ 的文件存储都使用定长结构来存储，方便一次将整个文件映射至内存中。&lt;/p&gt;
&lt;h2 id=&quot;文件预分配和文件预热&quot;&gt;文件预分配和文件预热&lt;/h2&gt;
&lt;p&gt;而内存映射也只是做了映射，只有当真正读取页面的时候产生缺页中断，才会将数据真正加载到内存中，所以 RocketMQ 做了一些优化，防止运行时的性能抖动。&lt;/p&gt;
&lt;h3 id=&quot;文件预分配&quot;&gt;文件预分配&lt;/h3&gt;
&lt;p&gt;CommitLog 的大小默认是1G，当超过大小限制的时候需要准备新的文件，而 RocketMQ 就起了一个后台线程 AllocateMappedFileService，不断的处理 AllocateRequest，AllocateRequest 其实就是预分配的请求，会提前准备好下一个文件的分配，防止在消息写入的过程中分配文件，产生抖动。&lt;/p&gt;
&lt;h3 id=&quot;文件预热&quot;&gt;文件预热&lt;/h3&gt;
&lt;p&gt;有一个 warmMappedFile 方法，它会把当前映射的文件，每一页遍历多去，写入一个0字节，然后再调用mlock 和 madvise(MADV_WILLNEED)。&lt;/p&gt;
&lt;p&gt;mlock：可以将进程使用的部分或者全部的地址空间锁定在物理内存中，防止其被交换到 swap 空间。&lt;/p&gt;
&lt;p&gt;madvise：给操作系统建议，说这文件在不久的将来要访问的，因此，提前读几页可能是个好主意。&lt;/p&gt;
&lt;h2 id=&quot;小结一下-2&quot;&gt;小结一下&lt;/h2&gt;
&lt;p&gt;CommitLog 采用混合型存储，也就是所有 Topic 都存在一起，顺序追加写入，文件名用起始偏移量命名。&lt;/p&gt;
&lt;p&gt;消息先写入 CommitLog 再通过后台线程分发到 ConsumerQueue 和 IndexFile 中。&lt;/p&gt;
&lt;p&gt;消费者先读取 ConsumerQueue 得到真正消息的物理地址，然后访问 CommitLog 得到真正的消息。&lt;/p&gt;
&lt;p&gt;利用了 mmap 机制减少一次拷贝，利用文件预分配和文件预热提高性能。&lt;/p&gt;
&lt;p&gt;提供同步和异步刷盘，根据场景选择合适的机制。&lt;/p&gt;
&lt;h2 id=&quot;broker-的-ha&quot;&gt;Broker 的 HA&lt;/h2&gt;
&lt;p&gt;从 Broker 会和主 Broker 建立长连接，然后获取主 Broker commitlog 最大偏移量，开始向主 Broker 拉取消息，主 Broker 会返回一定数量的消息，循环进行，达到主从数据同步。&lt;/p&gt;
&lt;p&gt;消费者消费消息会先请求主 Broker ，如果主 Broker 觉得现在压力有点大，则会返回从 Broker 拉取消息的建议，然后消费者就去从服务器拉取消息。&lt;/p&gt;
&lt;h2 id=&quot;consumer&quot;&gt;Consumer&lt;/h2&gt;
&lt;p&gt;消费有两种模式，分别是广播模式和集群模式。&lt;/p&gt;
&lt;p&gt;广播模式：一个分组下的每个消费者都会消费完整的Topic 消息。&lt;/p&gt;
&lt;p&gt;集群模式：一个分组下的消费者瓜分消费Topic 消息。&lt;/p&gt;
&lt;p&gt;一般我们用的都是集群模式。&lt;/p&gt;
&lt;p&gt;而消费者消费消息又分为推和拉模式，详细看我这篇文章&lt;a href=&quot;https://mp.weixin.qq.com/s/Afeg3EyvGI3KjSpjKEncZQ&quot;&gt;消息队列推拉模式&lt;/a&gt;，分别从源码级别分析了 RokcetMQ 和 Kafka 的消息推拉，以及推拉模式的优缺点。&lt;/p&gt;
&lt;h2 id=&quot;consumer-端的负载均衡机制&quot;&gt;Consumer 端的负载均衡机制&lt;/h2&gt;
&lt;p&gt;Consumer 会定期的获取 Topic 下的队列数，然后再去查找订阅了该 Topic 的同一消费组的所有消费者信息，默认的分配策略是类似分页排序分配。&lt;/p&gt;
&lt;p&gt;将队列排好序，然后消费者排好序，比如队列有 9 个，消费者有 3 个，那消费者-1 消费队列 0、1、2 的消息，消费者-2 消费队列 3、4、5，以此类推。&lt;/p&gt;
&lt;p&gt;所以如果负载太大，那么就加队列，加消费者，通过负载均衡机制就可以感知到重平衡，均匀负载。&lt;/p&gt;
&lt;h2 id=&quot;consumer-消息消费的重试&quot;&gt;Consumer 消息消费的重试&lt;/h2&gt;
&lt;p&gt;难免会遇到消息消费失败的情况，所以需要提供消费失败的重试，而一般的消费失败要么就是消息结构有误，要么就是一些暂时无法处理的状态，所以立即重试不太合适。&lt;/p&gt;
&lt;p&gt;RocketMQ 会给&lt;strong&gt;每个消费组&lt;/strong&gt;都设置一个重试队列，Topic 是 &lt;code&gt;%RETRY%+consumerGroup&lt;/code&gt;，并且设定了很多重试级别来延迟重试的时间。&lt;/p&gt;
&lt;p&gt;为了利用 RocketMQ 的延时队列功能，重试的消息会先保存在 Topic 名称为“SCHEDULE_TOPIC_XXXX”的延迟队列，在消息的扩展字段里面会存储原来所属的 Topic 信息。&lt;/p&gt;
&lt;p&gt;delay 一段时间后再恢复到重试队列中，然后 Consumer 就会消费这个重试队列主题，得到之前的消息。&lt;/p&gt;
&lt;p&gt;如果超过一定的重试次数都消费失败，则会移入到死信队列，即 Topic &lt;code&gt;%DLQ%&quot; + ConsumerGroup&lt;/code&gt; 中，存储死信队列即认为消费成功，因为实在没辙了，暂时放过。&lt;/p&gt;
&lt;p&gt;然后我们可以通过人工来处理死信队列的这些消息。&lt;/p&gt;
&lt;h2 id=&quot;消息的全局顺序和局部顺序&quot;&gt;消息的全局顺序和局部顺序&lt;/h2&gt;
&lt;p&gt;全局顺序就是消除一切并发，一个 Topic 一个队列，Producer 和 Consuemr 的并发都为一。&lt;/p&gt;
&lt;p&gt;局部顺序其实就是指某个队列顺序，多队列之间还是能并行的。&lt;/p&gt;
&lt;p&gt;可以通过 MessageQueueSelector 指定 Producer 某个业务只发这一个队列，然后 Comsuer 通过MessageListenerOrderly 接受消息，其实就是加锁消费。&lt;/p&gt;
&lt;p&gt;在 Broker 会有一个 mqLockTable ，顺序消息在创建拉取消息任务的时候需要在 Broker 锁定该消息队列，之后加锁成功的才能消费。&lt;/p&gt;
&lt;p&gt;而严格的顺序消息其实很难，假设现在都好好的，如果有个 Broker 宕机了，然后发生了重平衡，队列对应的消费者实例就变了，就会有可能会出现乱序的情况，如果要保持严格顺序，那此时就只能让整个集群不可用了。&lt;/p&gt;
&lt;h2 id=&quot;一些注意点&quot;&gt;一些注意点&lt;/h2&gt;
&lt;p&gt;1、订阅消息是以 ConsumerGroup 为单位存储的，所以ConsumerGroup 中的每个 Consumer 需要有相同的订阅。&lt;/p&gt;
&lt;p&gt;因为订阅消息是随着心跳上传的，如果一个 ConsumerGroup 中 Consumer 订阅信息不一样，那么就会出现互相覆盖的情况。&lt;/p&gt;
&lt;p&gt;比如消费者 A 订阅 Topic a，消费者 B 订阅 Topic b，此时消费者 A 去 Broker 拿消息，然后 B 的心跳包发出了，Broker 更新了，然后接到 A 的请求，一脸懵逼，没这订阅关系啊。&lt;/p&gt;
&lt;p&gt;2、RocketMQ 主从读写分离&lt;/p&gt;
&lt;p&gt;从只能读，不能写，并且只有当前客户端读的 offset 和 当前 Broker 已接受的最大 offset 超过限制的物理内存大小时候才会去从读，所以&lt;strong&gt;正常情况下从分担不了流量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;3、单单加机器提升不了消费速度，队列的数量也需要跟上。&lt;/p&gt;
&lt;p&gt;4、之前提到的，不要允许自动创建主题&lt;/p&gt;
&lt;h2 id=&quot;rocketmq-的最佳实践&quot;&gt;RocketMQ 的最佳实践&lt;/h2&gt;
&lt;p&gt;这些最佳实践部分参考自官网。&lt;/p&gt;
&lt;h3 id=&quot;tags的使用&quot;&gt;Tags的使用&lt;/h3&gt;
&lt;p&gt;建议一个应用一个 Topic，利用 tages 来标记不同业务，因为 tages 设置比较灵活，且一个应用一个 Topic 很清晰，能直观的辨别。&lt;/p&gt;
&lt;h3 id=&quot;keys的使用&quot;&gt;Keys的使用&lt;/h3&gt;
&lt;p&gt;如果有消息业务上的唯一标识，请填写到 keys 字段中，方便日后的定位查找。&lt;/p&gt;
&lt;h2 id=&quot;提高-consumer-的消费能力&quot;&gt;提高 Consumer 的消费能力&lt;/h2&gt;
&lt;p&gt;1、提高消费并行度：增加队列数和消费者数量，提高单个消费者的并行消费线程，参数 consumeThreadMax。&lt;/p&gt;
&lt;p&gt;2、批处理消费，设置 consumeMessageBatchMaxSize 参数，这样一次能拿到多条消息，然后比如一个 update语句之前要执行十次，现在一次就执行完。&lt;/p&gt;
&lt;p&gt;3、跳过非核心的消息，当负载很重的时候，为了保住那些核心的消息，设置那些非核心的消息，例如此时消息堆积 1W 条了之后，就直接返回消费成功，跳过非核心消息。&lt;/p&gt;
&lt;h2 id=&quot;nameserver-的寻址&quot;&gt;NameServer 的寻址&lt;/h2&gt;
&lt;p&gt;请使用 HTTP 静态服务器寻址（默认），这样 NameServer 就能动态发现。&lt;/p&gt;
&lt;h2 id=&quot;jvm选项&quot;&gt;JVM选项&lt;/h2&gt;
&lt;p&gt;以下抄自官网：&lt;/p&gt;
&lt;p&gt;如果不关心 RocketMQ Broker的启动时间，通过“预触摸” Java 堆以确保在 JVM 初始化期间每个页面都将被分配。&lt;/p&gt;
&lt;p&gt;那些不关心启动时间的人可以启用它：​ -XX:+AlwaysPreTouch&lt;br/&gt;禁用偏置锁定可能会减少JVM暂停，​ -XX:-UseBiasedLocking&lt;br/&gt;至于垃圾回收，建议使用带JDK 1.8的G1收集器。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;-XX:+UseG1GC -XX:G1HeapRegionSize=16m&lt;br/&gt;-XX:G1ReservePercent=25&lt;br/&gt;-XX:InitiatingHeapOccupancyPercent=30&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;另外不要把-XX:MaxGCPauseMillis的值设置太小，否则JVM将使用一个小的年轻代来实现这个目标，这将导致非常频繁的minor GC，所以建议使用rolling GC日志文件:&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;-XX:+UseGCLogFileRotation&lt;br/&gt;-XX:NumberOfGCLogFiles=5&lt;br/&gt;-XX:GCLogFileSize=30m&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;linux内核参数&quot;&gt;Linux内核参数&lt;/h2&gt;
&lt;p&gt;以下抄自官网：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;vm.extra_free_kbytes&lt;/strong&gt;，告诉VM在后台回收（kswapd）启动的阈值与直接回收（通过分配进程）的阈值之间保留额外的可用内存。RocketMQ使用此参数来避免内存分配中的长延迟。（与具体内核版本相关）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;vm.min_free_kbytes&lt;/strong&gt;，如果将其设置为低于1024KB，将会巧妙的将系统破坏，并且系统在高负载下容易出现死锁。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;vm.max_map_count&lt;/strong&gt;，限制一个进程可能具有的最大内存映射区域数。RocketMQ将使用mmap加载CommitLog和ConsumeQueue，因此建议将为此参数设置较大的值。（agressiveness --&amp;gt; aggressiveness）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;vm.swappiness&lt;/strong&gt;，定义内核交换内存页面的积极程度。较高的值会增加攻击性，较低的值会减少交换量。建议将值设置为10来避免交换延迟。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;File descriptor limits&lt;/strong&gt;，RocketMQ需要为文件（CommitLog和ConsumeQueue）和网络连接打开文件描述符。我们建议设置文件描述符的值为655350。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Performance_Tuning_Guide/ch06s04s02.html&quot;&gt;Disk scheduler&lt;/a&gt;，RocketMQ建议使用I/O截止时间调度器，它试图为请求提供有保证的延迟。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;最后&quot;&gt;最后&lt;/h2&gt;
&lt;p&gt;其实还有很多没讲，比如流量控制、消息的过滤、定时消息的实现，包括底层通信 1+N+M1+M2 的 Reactor 多线程设计等等。&lt;/p&gt;
&lt;p&gt;主要是内容太多了，而且也不太影响主流程，所以还是剥离出来之后写吧，大致的一些实现还是讲了的。&lt;/p&gt;
&lt;p&gt;包括元信息的交互、消息的发送、存储、消费等等。&lt;/p&gt;
&lt;p&gt;关于事务消息的那一块我之前文章也分析过了，所以这个就不再贴了。&lt;/p&gt;
&lt;p&gt;可以看到要实现一个生产级别的消息队列还是有很多很多东西需要考虑的，不过大致的架构和涉及到的模块差不多就这些了。&lt;/p&gt;
&lt;p&gt;至于具体的细节深入，还是得靠大家自行研究了，我就起个抛砖引玉的作用。&lt;/p&gt;
&lt;p&gt;最后个人能力有限，如果哪里有纰漏请抓紧联系鞭挞我，可看网页公告联系我。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;我是 yes，从一点点到亿点点，我们下篇见&lt;/strong&gt;。&lt;/p&gt;
</description>
<pubDate>Fri, 20 Nov 2020 00:36:00 +0000</pubDate>
<dc:creator>yes的练级攻略</dc:creator>
<og:description>每个时代，都不会亏待会学习的人。 大家好，我是 yes。 继上一篇 头条终面：写个消息中间件 ，我提到实现消息中间件的一些关键点，今天就和大家一起深入生产级别消息中间件 - RocketMQ 的内核实</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yescode/p/13832211.html</dc:identifier>
</item>
<item>
<title>图解内存池内部结构，看它是如何克服内存碎片化的？ - fasionchan</title>
<link>http://www.cnblogs.com/fasionchan/p/python-memory-pool.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fasionchan/p/python-memory-pool.html</guid>
<description>&lt;p&gt;内存是软件系统必不可少的物理资源，精湛的内存管理技术是确保内存使用效率的关键，也是进阶高级研发的必备技巧。为提高内存分配效率，Python 内部做了很多殚心竭虑的优化，从中我们可以获得一些启发。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;297&quot;&gt;
&lt;p&gt;内存是软件系统必不可少的物理资源，精湛的内存管理技术是确保内存使用效率的关键，也是进阶高级研发的必备技巧。为提高内存分配效率，&lt;em&gt;Python&lt;/em&gt; 内部做了很多殚心竭虑的优化，从中我们可以获得一些启发。&lt;/p&gt;
&lt;p&gt;开始研究 &lt;em&gt;Python&lt;/em&gt; 内存池之前，我们先大致了解下 &lt;em&gt;Python&lt;/em&gt; 内存管理层次：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.fasionchan.com/course/python-source/memory-pool/0e1a9a83b21393eb1b4215b24d8e248a.svg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;众所周知，计算机硬件资源由操作系统负责管理，内存资源也不例外。应用程序通过 &lt;strong&gt;系统调用&lt;/strong&gt; 向操作系统申请内存，而 &lt;em&gt;C&lt;/em&gt; 库函数则进一步将系统调用封装成通用的 &lt;strong&gt;内存分配器&lt;/strong&gt; ，并提供了 &lt;em&gt;malloc&lt;/em&gt; 系列函数。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;C&lt;/em&gt; 库函数实现的通用目的内存管理器是一个重要的分水岭，即内存管理层次中的 &lt;strong&gt;第0层&lt;/strong&gt; 。此层之上是应用程序自己的内存管理，此层之下则是隐藏在冰山下方的操作系统部分。&lt;/p&gt;
&lt;p&gt;操作系统内部是一个基于页表的虚拟内存管理器(&lt;strong&gt;第-1层&lt;/strong&gt;)，以 &lt;strong&gt;页&lt;/strong&gt; ( &lt;em&gt;page&lt;/em&gt; )为单位管理内存，&lt;em&gt;CPU&lt;/em&gt; &lt;strong&gt;内存管理单元&lt;/strong&gt;( &lt;em&gt;MMU&lt;/em&gt; )在这个过程中发挥重要作用。虚拟内存管理器下方则是底层存储设备(&lt;strong&gt;第-2层&lt;/strong&gt;)，直接管理物理内存以及磁盘等二级存储设备。&lt;/p&gt;
&lt;p&gt;绿色部分则是 &lt;em&gt;Python&lt;/em&gt; 自己的内存管理，分为 &lt;em&gt;3&lt;/em&gt; 层：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第 &lt;em&gt;1&lt;/em&gt; 层，是一个内存分配器，接管一切内存分配，内部是本文的主角—— &lt;strong&gt;内存池&lt;/strong&gt; ；&lt;/li&gt;
&lt;li&gt;第 &lt;em&gt;2&lt;/em&gt; 层，在第 1 层提供的统一 &lt;em&gt;PyMem_XXXX&lt;/em&gt; 接口基础上，实现统一的对象内存分配( &lt;em&gt;object.tp_alloc&lt;/em&gt; )；&lt;/li&gt;
&lt;li&gt;第 &lt;em&gt;3&lt;/em&gt; 层，为特定对象服务，例如前面章节介绍的 &lt;em&gt;float&lt;/em&gt; 空闲对象缓存池；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;那么，&lt;em&gt;Python&lt;/em&gt; 为什么不直接使用 &lt;em&gt;malloc&lt;/em&gt; 系列函数，而是自己折腾一遍呢？原因主要是以下几点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;引入内存池，可化解对象频繁创建销毁带来的内存分配压力；&lt;/li&gt;
&lt;li&gt;最大程度避免内存碎片化，提升内存利用效率；&lt;/li&gt;
&lt;li&gt;&lt;em&gt;malloc&lt;/em&gt; 有很多实现版本，不同实现性能千差万别；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;内存碎片化&lt;/strong&gt; 是困扰经典内存分配器的一大难题，碎片化导致的结果也是惨重的。这是一个典型的内存碎片化例子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.fasionchan.com/course/python-source/memory-pool/595b7643af41e5095116cb966edd83f3.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;虽然还有 &lt;em&gt;1900K&lt;/em&gt; 的空闲内存，但都分散在一系列不连续的碎片上，甚至无法成功分配出 &lt;em&gt;1000K&lt;/em&gt; 。&lt;/p&gt;
&lt;p&gt;那么，如何避免内存碎片化呢？想要解决问题，必先分析导致问题的根源。&lt;/p&gt;
&lt;p&gt;我们知道，应用程序请求内存块尺寸是不确定的，有大有小；释放内存的时机也是不确定的，有先有后。经典内存分配器将不同尺寸内存块混合管理，按照先来后到的顺序分配：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.fasionchan.com/course/python-source/memory-pool/67b0a71b54156ddd4927cbc72d705b70.svg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当大块内存回收后，可以被分为更小的块，然后分配出去：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.fasionchan.com/course/python-source/memory-pool/3b204b5bc3862031657bc4da7c37a6a0.svg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而先分配的内存块未必先释放，慢慢地空洞就出现了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.fasionchan.com/course/python-source/memory-pool/e50f22d27795bd3c1e72b92ffe806e8e.svg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;随着时间的推移，碎片化会越来越严重，最终变得支离破碎：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.fasionchan.com/course/python-source/memory-pool/2a0fa7ec31078a54d512acf9ec281359.svg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由此可见，将不同尺寸内存块混合管理，将大块内存切分后再次分配的做法是罪魁祸首。&lt;/p&gt;

&lt;p&gt;揪出内存碎片根源后，解决方案也就浮出水面了——根据内存块尺寸，将内存空间划分成不同区域，独立管理。举个最简单的例子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.fasionchan.com/course/python-source/memory-pool/6456bb96320f0662681f9ceccadb4fa3.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如图，内存被划分成小、中、大三个不同尺寸的区域，区域可由若干内存页组成，每个页都划分为统一规格的内存块。这样一来，小块内存的分配，不会影响大块内存区域，使其碎片化。&lt;/p&gt;
&lt;p&gt;每个区域的碎片仍无法完全避免，但这些碎片都是可以被重新分配出去的，影响不大。此外，通过优化分配策略，碎片还可被进一步合并。以小块内存为例，新内存优先从内存页 &lt;em&gt;1&lt;/em&gt; 分配，内存页 &lt;em&gt;2&lt;/em&gt; 将慢慢变空，最终将被整体回收。&lt;/p&gt;
&lt;p&gt;在 &lt;em&gt;Python&lt;/em&gt; 虚拟机内部，时刻有对象创建、销毁，这引发频繁的内存申请、释放动作。这类内存尺寸一般不大，但分配、释放频率非常高，因此 &lt;em&gt;Python&lt;/em&gt; 专门设计 &lt;strong&gt;内存池&lt;/strong&gt; 对此进行优化。&lt;/p&gt;
&lt;p&gt;那么，尺寸多大的内存才会动用内存池呢？&lt;em&gt;Python&lt;/em&gt; 以 &lt;em&gt;512&lt;/em&gt; 字节为限，小于 &lt;em&gt;512&lt;/em&gt; 的内存分配才会被内存池接管：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;em&gt;0&lt;/em&gt; ，直接调用 &lt;em&gt;malloc&lt;/em&gt; 函数；&lt;/li&gt;
&lt;li&gt;&lt;em&gt;1&lt;/em&gt; ~ &lt;em&gt;512&lt;/em&gt; ，由专门的内存池负责分配，内存池以内存尺寸进行划分；&lt;/li&gt;
&lt;li&gt;&lt;em&gt;512&lt;/em&gt; 以上，直接调动 &lt;em&gt;malloc&lt;/em&gt; 函数；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;那么，&lt;em&gt;Python&lt;/em&gt; 是否为每个尺寸的内存都准备一个独立内存池呢？答案是否定的，愿意有几个：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;内存规格有 &lt;em&gt;512&lt;/em&gt; 种之多，如果内存池分也分 &lt;em&gt;512&lt;/em&gt; 种，徒增复杂性；&lt;/li&gt;
&lt;li&gt;内存池种类越多，额外开销越大；&lt;/li&gt;
&lt;li&gt;如果某个尺寸内存只申请一次，将浪费内存页内其他空闲内存；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;相反，&lt;em&gt;Python&lt;/em&gt; 以 &lt;em&gt;8&lt;/em&gt; 字节为梯度，将内存块分为：&lt;em&gt;8&lt;/em&gt; 字节、&lt;em&gt;16&lt;/em&gt; 字节、&lt;em&gt;24&lt;/em&gt; 字节，以此类推。总共 &lt;em&gt;64&lt;/em&gt; 种：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;strong&gt;请求大小&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;分配内存块大小&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;类别编号&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;1 ~ 8&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;9 ~ 16&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;17 ~ 24&lt;/td&gt;
&lt;td&gt;24&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;25 ~ 32&lt;/td&gt;
&lt;td&gt;32&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;...&lt;/td&gt;
&lt;td&gt;...&lt;/td&gt;
&lt;td&gt;...&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;497 ~ 504&lt;/td&gt;
&lt;td&gt;504&lt;/td&gt;
&lt;td&gt;62&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;505 ~ 512&lt;/td&gt;
&lt;td&gt;512&lt;/td&gt;
&lt;td&gt;63&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;以 &lt;em&gt;8&lt;/em&gt; 字节内存块为例，内存池由多个 &lt;strong&gt;内存页&lt;/strong&gt; ( &lt;em&gt;page&lt;/em&gt; ，一般是 &lt;em&gt;4K&lt;/em&gt; )构成，每个内存页划分为若干 &lt;em&gt;8&lt;/em&gt; 字节内存块：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.fasionchan.com/course/python-source/memory-pool/59cd7a288716ec6a99484d256e6d6468.svg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图表示一个内存页，每个小格表示 &lt;em&gt;1&lt;/em&gt; 字节，&lt;em&gt;8&lt;/em&gt; 个字节组成一个块( &lt;em&gt;block&lt;/em&gt; )。灰色表示空闲内存块，蓝色表示已分配内存块，深蓝色表示应用内存请求大小。&lt;/p&gt;
&lt;p&gt;只要请求的内存大小不超过 &lt;em&gt;8&lt;/em&gt; 字节，&lt;em&gt;Python&lt;/em&gt; 都在这个内存池为其分配一块 &lt;em&gt;8&lt;/em&gt; 字节内存，就算只申请 1 字节内存也是如此。&lt;/p&gt;
&lt;p&gt;这种做法好处显而易见，前面提到的问题均得到解决，还带来另一个好处：内存起始地址均以计算机字为单位对齐。计算机以 &lt;strong&gt;字&lt;/strong&gt; ( &lt;em&gt;word&lt;/em&gt; )为单位访问内存，因此内存以字对齐可提升内存读写速度。字大小从早期硬件的 &lt;em&gt;2&lt;/em&gt; 字节、&lt;em&gt;4&lt;/em&gt; 字节，慢慢发展到现在的 &lt;em&gt;8&lt;/em&gt; 字节，甚至 &lt;em&gt;16&lt;/em&gt; 字节。&lt;/p&gt;
&lt;p&gt;当然了，有得必有失，内存利用率成了被牺牲的因素，平均利用率为 &lt;em&gt;(1+8)/2/8*100%&lt;/em&gt; ，大约只有 &lt;em&gt;56.25%&lt;/em&gt; 。&lt;/p&gt;
&lt;p&gt;乍然一看，内存利用率有些惨不忍睹，但这只是 &lt;em&gt;8&lt;/em&gt; 字节内存块的平均利用率。如果考虑所有内存块的平均利用率，其实数值并不低——可以达到 &lt;em&gt;98.65%&lt;/em&gt; 呢！计算方法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 请求内存总量
total_requested = 0
# 实际分配内存总量
total_allocated = 0

# 请求内存从1到512字节
for i in range(1, 513):
    total_requested += i
    # 实际分配内存为请求内存向上对齐为8的整数倍
    total_allocated += (i+7)//8*8

print('{:.2f}%'.format(total_requested/total_allocated*100))
# 98.65%
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;pool&quot;&gt;pool&lt;/h2&gt;
&lt;p&gt;铺垫了这么多，终于可以开始研究源码，窥探 &lt;em&gt;Python&lt;/em&gt; 内存池实现的秘密了，源码位于 &lt;em&gt;Objects/obmalloc.c&lt;/em&gt; 。在源码中，我们发现对于 &lt;em&gt;64&lt;/em&gt; 位系统，&lt;em&gt;Python&lt;/em&gt; 将内存块大小定义为 &lt;em&gt;16&lt;/em&gt; 字节的整数倍，而不是上述的 &lt;em&gt;8&lt;/em&gt; 字节：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;#if SIZEOF_VOID_P &amp;gt; 4
#define ALIGNMENT              16               /* must be 2^N */
#define ALIGNMENT_SHIFT         4
#else
#define ALIGNMENT               8               /* must be 2^N */
#define ALIGNMENT_SHIFT         3
#endif
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为画图方便，我们仍然假设内存块为 8 字节的整数倍，即(实际上，这些宏定义也是可配置的)：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;#define ALIGNMENT               8
#define ALIGNMENT_SHIFT         3
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面这个宏将类别编号转化成块大小，例如将类别 &lt;em&gt;1&lt;/em&gt; 转化为块大小 &lt;em&gt;16&lt;/em&gt; ：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;#define INDEX2SIZE(I) (((uint)(I) + 1) &amp;lt;&amp;lt; ALIGNMENT_SHIFT)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;Python&lt;/em&gt; 每次申请一个 &lt;strong&gt;内存页&lt;/strong&gt; ( &lt;em&gt;page&lt;/em&gt; )，然后将其划分为统一尺寸的 &lt;strong&gt;内存块&lt;/strong&gt; ( &lt;em&gt;block&lt;/em&gt; )，一个内存页大小是 &lt;em&gt;4K&lt;/em&gt; ：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;#define SYSTEM_PAGE_SIZE        (4 * 1024)
#define SYSTEM_PAGE_SIZE_MASK   (SYSTEM_PAGE_SIZE - 1)

#define POOL_SIZE               SYSTEM_PAGE_SIZE
#define POOL_SIZE_MASK          SYSTEM_PAGE_SIZE_MASK
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;Python&lt;/em&gt; 将内存页看做是由一个个内存块组成的池子( &lt;em&gt;pool&lt;/em&gt; )，内存页开头是一个 &lt;em&gt;pool_header&lt;/em&gt; 结构，用于组织当前页，并记录页中的空闲内存块：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;/* Pool for small blocks. */
struct pool_header {
    union { block *_padding;
            uint count; } ref;          /* number of allocated blocks    */
    block *freeblock;                   /* pool's free list head         */
    struct pool_header *nextpool;       /* next pool of this size class  */
    struct pool_header *prevpool;       /* previous pool       &quot;&quot;        */
    uint arenaindex;                    /* index into arenas of base adr */
    uint szidx;                         /* block size class index        */
    uint nextoffset;                    /* bytes to virgin block         */
    uint maxnextoffset;                 /* largest valid nextoffset      */
};

&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;em&gt;count&lt;/em&gt; ，已分配出去的内存块个数；&lt;/li&gt;
&lt;li&gt;&lt;em&gt;freeblock&lt;/em&gt; ，指向空闲块链表的第一块；&lt;/li&gt;
&lt;li&gt;&lt;em&gt;nextpool&lt;/em&gt; ，用于将 &lt;em&gt;pool&lt;/em&gt; 组织成链表的指针，指向下一个 &lt;em&gt;pool&lt;/em&gt; ；&lt;/li&gt;
&lt;li&gt;&lt;em&gt;prevpool&lt;/em&gt; ，用于将 &lt;em&gt;pool&lt;/em&gt; 组织成链表的指针，指向上一个 &lt;em&gt;pool&lt;/em&gt; ；&lt;/li&gt;
&lt;li&gt;&lt;em&gt;szidx&lt;/em&gt; ，尺寸类别编号；&lt;/li&gt;
&lt;li&gt;&lt;em&gt;nextoffset&lt;/em&gt; ，下一个未初始化内存块的偏移量；&lt;/li&gt;
&lt;li&gt;&lt;em&gt;maxnextoffset&lt;/em&gt; ，合法内存块最大偏移量；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当 &lt;em&gt;Python&lt;/em&gt; 通过内存池申请内存时，如果没有可用 &lt;em&gt;pool&lt;/em&gt; ，内存池将新申请一个 &lt;em&gt;4K&lt;/em&gt; 页，并进行初始化。注意到，由于新内存页总是由内存请求触发，因此初始化时第一个内存块便已经被分配出去了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.fasionchan.com/course/python-source/memory-pool/eed45d8a0fa10e66d23ffbf1053f3a46.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;随着内存分配请求的发起，空闲块将被分配出去。&lt;em&gt;Python&lt;/em&gt; 将从灰色区域取出下一个作为空闲块，直到灰色块用光：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.fasionchan.com/course/python-source/memory-pool/cf9bbeda05da734ea4ad36ff8c442e64.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当有内存块被释放时，比如第一块，&lt;em&gt;Python&lt;/em&gt; 将其链入空闲块链表头。请注意空闲块链表的组织方式——每个块头部保存一个 &lt;em&gt;next&lt;/em&gt; 指针，指向下一个空闲块：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.fasionchan.com/course/python-source/memory-pool/ef9a156f761e9f67db201bc644454440.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样一来，一个 &lt;em&gt;pool&lt;/em&gt; 在其生命周期内，可能处于以下 &lt;em&gt;3&lt;/em&gt; 种状态(空闲内存块链表结构被省略，请自行脑补)：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.fasionchan.com/course/python-source/memory-pool/3b90253f3290cc4d139ea47ba78b1fe3.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;em&gt;empty&lt;/em&gt; ，&lt;strong&gt;完全空闲&lt;/strong&gt; 状态，内部所有内存块都是空闲的，没有任何块已被分配，因此 &lt;em&gt;count&lt;/em&gt; 为 &lt;em&gt;0&lt;/em&gt; ；&lt;/li&gt;
&lt;li&gt;&lt;em&gt;used&lt;/em&gt; ，&lt;strong&gt;部分使用&lt;/strong&gt; 状态，内部内存块部分已被分配，但还有另一部分是空闲的；&lt;/li&gt;
&lt;li&gt;&lt;em&gt;full&lt;/em&gt; ，&lt;strong&gt;完全用满&lt;/strong&gt; 状态，内部所有内存块都已被分配，没有任何空闲块，因此 &lt;em&gt;freeblock&lt;/em&gt; 为 &lt;em&gt;NULL&lt;/em&gt; ；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;为什么要讨论 &lt;em&gt;pool&lt;/em&gt; 状态呢？——因为 &lt;em&gt;pool&lt;/em&gt; 的状态决定 &lt;em&gt;Python&lt;/em&gt; 对它的处理策略：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果 &lt;em&gt;pool&lt;/em&gt; 完全空闲，&lt;em&gt;Python&lt;/em&gt; 可以将它占用的内存页归还给操作系统，或者缓存起来，后续需要分配新 &lt;em&gt;pool&lt;/em&gt; 时直接拿来用；&lt;/li&gt;
&lt;li&gt;如果 &lt;em&gt;pool&lt;/em&gt; 完全用满，&lt;em&gt;Python&lt;/em&gt; 就无须关注它了，将它丢到一边；&lt;/li&gt;
&lt;li&gt;如果 &lt;em&gt;pool&lt;/em&gt; 只是部分使用，说明它还有内存块未分配，&lt;em&gt;Python&lt;/em&gt; 则将它们以 &lt;strong&gt;双向循环链表&lt;/strong&gt; 的形式组织起来；&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;可用-pool-链表&quot;&gt;可用 pool 链表&lt;/h2&gt;
&lt;p&gt;由于 &lt;em&gt;used&lt;/em&gt; 状态的 &lt;em&gt;pool&lt;/em&gt; 只是部分使用，内部还有内存块未分配，将它们组织起来可供后续分配。&lt;em&gt;Python&lt;/em&gt; 通过 &lt;em&gt;pool_header&lt;/em&gt; 结构体中的 &lt;em&gt;nextpool&lt;/em&gt; 和 &lt;em&gt;prevpool&lt;/em&gt; 指针，将他们连成一个双向循环链表：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.fasionchan.com/course/python-source/memory-pool/4049c2218b3c0adc75279278cc030430.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意到，同个可用 &lt;em&gt;pool&lt;/em&gt; 链表中的内存块大小规格都是一样的，上图以 &lt;em&gt;16&lt;/em&gt; 字节类别为例。另外，为了简化链表处理逻辑，&lt;em&gt;Python&lt;/em&gt; 引入了一个虚拟节点，这是一个常见的 &lt;em&gt;C&lt;/em&gt; 语言链表实现技巧。一个空的 &lt;em&gt;pool&lt;/em&gt; 链表是这样的，判断条件是 &lt;code&gt;pool-&amp;gt;nextpool == pool&lt;/code&gt; ：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.fasionchan.com/course/python-source/memory-pool/b5b77e125d106cf4c4c4ea80f70f9d56.svg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;虚拟节点只参与链表维护，并不实际管理内存块。因此，无须为虚拟节点分配一个完整的 &lt;em&gt;4K&lt;/em&gt; 内存页，&lt;em&gt;64&lt;/em&gt; 字节的 &lt;em&gt;pool_header&lt;/em&gt; 结构体足矣。实际上，&lt;em&gt;Python&lt;/em&gt; 作者们更抠，只分配刚好足够 &lt;em&gt;nextpool&lt;/em&gt; 和 &lt;em&gt;prevpool&lt;/em&gt; 指针用的内存，手法巧妙得令人瞠目结舌，我们稍后再表。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Python&lt;/em&gt; 优先从链表第一个 &lt;em&gt;pool&lt;/em&gt; 分配内存块，如果 &lt;em&gt;pool&lt;/em&gt; 用满则将其从链表中剔除：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.fasionchan.com/course/python-source/memory-pool/8539da814d614308ed4c45091bbe1fe5.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当一个内存块( &lt;em&gt;block&lt;/em&gt; )被回收，&lt;em&gt;Python&lt;/em&gt; 根据块地址计算得到 &lt;em&gt;pool&lt;/em&gt; 地址。计算方法是大概是这样的：将 &lt;em&gt;block&lt;/em&gt; 地址对齐为内存页( &lt;em&gt;pool&lt;/em&gt; )尺寸的整数倍，便得到 &lt;em&gt;pool&lt;/em&gt; 地址，具体请参看源码中的宏定义 &lt;em&gt;POOL_ADDR&lt;/em&gt; 。&lt;/p&gt;
&lt;p&gt;得到 &lt;em&gt;pool&lt;/em&gt; 地址后，&lt;em&gt;Python&lt;/em&gt; 将空闲内存块插到空闲内存块链表头部。如果 &lt;em&gt;pool&lt;/em&gt; 状态是由 &lt;strong&gt;完全用满&lt;/strong&gt; ( &lt;em&gt;full&lt;/em&gt; )变为 &lt;strong&gt;可用&lt;/strong&gt; ( &lt;em&gt;used&lt;/em&gt; )，&lt;em&gt;Python&lt;/em&gt; 还会将它插回可用 &lt;em&gt;pool&lt;/em&gt; 链表头部：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.fasionchan.com/course/python-source/memory-pool/8147cc9f4399015a3aa3e4a621f1f320.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;插到可用 &lt;em&gt;pool&lt;/em&gt; 链表头部是为了保证比较满的 &lt;em&gt;pool&lt;/em&gt; 在链表前面，以便优先使用。位于尾部的 &lt;em&gt;pool&lt;/em&gt; 被使用的概率很低，随着时间的推移，更多的内存块被释放出来，慢慢变空。因此，&lt;em&gt;pool&lt;/em&gt; 链表明显头重脚轻，靠前的 &lt;em&gt;pool&lt;/em&gt; 比较满，而靠后的 &lt;em&gt;pool&lt;/em&gt; 比较空，正如上图所示。&lt;/p&gt;
&lt;p&gt;当一个 &lt;em&gt;pool&lt;/em&gt; 所有内存块( &lt;em&gt;block&lt;/em&gt; )都被释放，状态就变为 &lt;strong&gt;完全空闲&lt;/strong&gt;( &lt;em&gt;empty&lt;/em&gt; )。&lt;em&gt;Python&lt;/em&gt; 会将它移出链表，内存页可能直接归还给操作系统，或者缓存起来以备后用：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.fasionchan.com/course/python-source/memory-pool/505655a7f313511e66135cbc7f771f93.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;实际上，&lt;em&gt;pool&lt;/em&gt; 链表任一节点均有机会完全空闲下来。这由概率决定，尾部节点概率最高，因此上图就这么画了。&lt;/p&gt;
&lt;h2 id=&quot;pool-链表数组&quot;&gt;pool 链表数组&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;Python&lt;/em&gt; 内存池管理内存块，按照尺寸分门别类进行。因此，每种规格都需要维护一个独立的可用 &lt;em&gt;pool&lt;/em&gt; 链表。如果以 &lt;em&gt;8&lt;/em&gt; 字节为梯度，内存块规格可分 &lt;em&gt;64&lt;/em&gt; 种之多(见上表)。&lt;/p&gt;
&lt;p&gt;那么，如何组织这么多 &lt;em&gt;pool&lt;/em&gt; 链表呢？最直接的方法是分配一个长度为 &lt;em&gt;64&lt;/em&gt; 的虚拟节点数组：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.fasionchan.com/course/python-source/memory-pool/8908fa5506f64e8bb06565ed36b6a931.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果程序请求 &lt;em&gt;5&lt;/em&gt; 字节，&lt;em&gt;Python&lt;/em&gt; 将分配 &lt;em&gt;8&lt;/em&gt; 字节内存块，通过数组第 &lt;em&gt;0&lt;/em&gt; 个虚拟节点即可找到 &lt;em&gt;8&lt;/em&gt; 字节 &lt;em&gt;pool&lt;/em&gt; 链表；如果程序请求 &lt;em&gt;56&lt;/em&gt; 字节，&lt;em&gt;Python&lt;/em&gt; 将分配 &lt;em&gt;64&lt;/em&gt; 字节内存块，则需要从数组第 &lt;em&gt;7&lt;/em&gt; 个虚拟节点出发；其他以此类推。&lt;/p&gt;
&lt;p&gt;那么，虚拟节点数组需要占用多少内存呢？这不难计算：&lt;/p&gt;
&lt;p&gt;$$48 \times 64 = 3072 = 3K$$&lt;/p&gt;
&lt;p&gt;哟，看上去还不少！&lt;em&gt;Python&lt;/em&gt; 作者们可没这么大方，他们还从中抠出三分之二，具体是如何做到的呢？&lt;/p&gt;
&lt;p&gt;您可能已经注意到了，虚拟节点只参与维护链表结构，并不管理内存页。因此，虚拟节点其实只使用 &lt;em&gt;pool_header&lt;/em&gt; 结构体中参与链表维护的 &lt;em&gt;nextpool&lt;/em&gt; 和 &lt;em&gt;prevpool&lt;/em&gt; 这两个指针字段：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.fasionchan.com/course/python-source/memory-pool/81646a6012ae4630dc5b47d51739e0b4.svg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为避免浅蓝色部分内存浪费，&lt;em&gt;Python&lt;/em&gt; 作者们将虚拟节点想象成一个个卡片，将深蓝色部分首尾相接，最终转换成一个纯指针数组。数组在 &lt;em&gt;Objects/obmalloc.c&lt;/em&gt; 中定义，即 &lt;em&gt;usedpools&lt;/em&gt; 。每个虚拟节点对应数组里面的两个指针：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.fasionchan.com/course/python-source/memory-pool/9309064f7c7ec70857dc136b46b52685.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来的一切交给想象力——将两个指针前后的内存空间想象成自己的，这样就得到一个虚无缥缈的却非常完整的 &lt;em&gt;pool_header&lt;/em&gt; 结构体（如下图左边虚线部分），我们甚至可以使用这个 &lt;em&gt;pool_header&lt;/em&gt; 结构体的地址！由于我们不会访问除了 &lt;em&gt;nextpool&lt;/em&gt; 和 &lt;em&gt;prevpool&lt;/em&gt; 指针以外的字段，因此虽有内存越界，却也无伤大雅。&lt;/p&gt;
&lt;p&gt;下图以一个代表空链表的虚拟节点为例，&lt;em&gt;nextpool&lt;/em&gt; 和 &lt;em&gt;prevpool&lt;/em&gt; 指针均指向 &lt;em&gt;pool_header&lt;/em&gt; 自己。虽然实际上 &lt;em&gt;nextpool&lt;/em&gt; 和 &lt;em&gt;prevpool&lt;/em&gt; 都指向了数组中的其他虚拟节点，但逻辑上可以想象成指向当前的 &lt;em&gt;pool_header&lt;/em&gt; 结构体：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.fasionchan.com/course/python-source/memory-pool/c2defcb074392f3efa53c244e47ff788.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;卧槽，这移花接木大法也太牛逼了吧！非常享受研究源码的过程，当年研究 &lt;em&gt;Linux&lt;/em&gt; 内核数据结构中的链表实现时，也是大开眼界！&lt;/p&gt;
&lt;p&gt;经过这般优化，数组只需 &lt;em&gt;16*64 = 1024&lt;/em&gt; 字节的内存空间即可，折合 &lt;em&gt;1K&lt;/em&gt; ，节省了三分之二。为了节约这 &lt;em&gt;2K&lt;/em&gt; 内存，代码变得难以理解。我第一次阅读源码时，在纸上花了半天才完全弄懂这个思路。&lt;/p&gt;
&lt;p&gt;效率与代码可读性经常是一对矛盾，如何选择见仁见智。不过，如果是日常项目，我多半不会为了 &lt;em&gt;2K&lt;/em&gt; 内存而引入复杂性。&lt;em&gt;Python&lt;/em&gt; 作为基础工具，能省则省。当然这个思路也有可能是在内存短缺的年代引入的，然后就这么一直用着。&lt;/p&gt;
&lt;p&gt;不管怎样，我还是决定将它写出来。如果你有兴趣研究 &lt;em&gt;Objects/obmalloc.c&lt;/em&gt; 中的源码，就不用像我一样费劲，瞎耽误功夫。&lt;/p&gt;
&lt;p&gt;因篇幅关系，源码无法一一列举。对源码感兴趣的同学，请自己动手，丰衣足食。结合图示阅读，应该可以做到事半功倍。什么，不知道从何入手？——那就紧紧抓住这两个函数吧，一个负责分配，一个负责释放：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;em&gt;pymalloc_alloc&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;pymalloc_free&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;虽然本节研究了很多东西，但还无法涵盖 &lt;em&gt;Python&lt;/em&gt; 内存池的全部秘密，&lt;em&gt;pool&lt;/em&gt; 的管理同样因篇幅关系无法展开。后续有机会我会接着写，感兴趣的童鞋请关注我。等不及？——源码欢迎您！&lt;/p&gt;
&lt;p&gt;如果觉得我写得还行，记得点赞关注哟~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.fasionchan.com/coding-fan-wechat-soso-qrcode.png?x-oss-process=image/resize,w_400&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Fri, 20 Nov 2020 00:26:00 +0000</pubDate>
<dc:creator>fasionchan</dc:creator>
<og:description>内存是软件系统必不可少的物理资源，精湛的内存管理技术是确保内存使用效率的关键，也是进阶高级研发的必备技巧。为提高内存分配效率，Python 内部做了很多殚心竭虑的优化，从中我们可以获得一些启发。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/fasionchan/p/python-memory-pool.html</dc:identifier>
</item>
<item>
<title>5分钟轻松学正则表达式 - dongfanger</title>
<link>http://www.cnblogs.com/df888/p/14008394.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/df888/p/14008394.html</guid>
<description>&lt;p&gt;正则表达式，是一个表达式，用少量的简单字符，来表示复杂的长字符串。&lt;/p&gt;
&lt;p&gt;实际工作用到很多，比如日志搜索、查找替换、JMeter 响应数据提取等。&lt;/p&gt;
&lt;p&gt;先看一个例子，用户名包含字符、数字、下划线和连字符，并限制字符的个数：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202011/1629545-20201119223613127-1397208862.png&quot;/&gt;&lt;/center&gt;
&lt;p&gt;这个表达式可以接受 &lt;code&gt;john_doe&lt;/code&gt;、&lt;code&gt;jo-hn_doe&lt;/code&gt;、&lt;code&gt;john12_as&lt;/code&gt;，但是无法匹配到 &lt;code&gt;Jo&lt;/code&gt;，因为它包含了大写的字母而且太短了。&lt;/p&gt;

&lt;p&gt;正则表达式之所以强大，是因为通过一些特殊字符，能让它匹配到更多字符串。&lt;/p&gt;
&lt;h2 id=&quot;&quot;&gt;.&lt;/h2&gt;
&lt;p&gt;匹配任意单个字符除了换行符。&lt;/p&gt;
&lt;p&gt;例：.ar =&amp;gt; The &lt;span&gt;car&lt;/span&gt; &lt;span&gt;par&lt;/span&gt;ked in the &lt;span&gt;gar&lt;/span&gt;age.&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;[ ]&lt;/h2&gt;
&lt;p&gt;字符集。匹配方括号内的任意字符。并且字符是无先后顺序的。&lt;/p&gt;
&lt;p&gt;例：[Tt]he =&amp;gt; &lt;span&gt;The&lt;/span&gt; car parked in &lt;span&gt;the&lt;/span&gt; garage.&lt;/p&gt;
&lt;p&gt;方括号的句号就表示句号。&lt;/p&gt;
&lt;p&gt;例：ar[.] =&amp;gt; A garage is a good place to park a c&lt;span&gt;ar.&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;--2&quot;&gt;[^ ]&lt;/h2&gt;
&lt;p&gt;否定的字符集。匹配除了方括号里的任意字符。&lt;/p&gt;
&lt;p&gt;例：[^c]ar =&amp;gt; The &lt;span&gt;car&lt;/span&gt; &lt;span&gt;par&lt;/span&gt;ked in the &lt;span&gt;gar&lt;/span&gt;age.&lt;/p&gt;
&lt;h2 id=&quot;-2&quot;&gt;*&lt;/h2&gt;
&lt;p&gt;匹配 &amp;gt;= 0 个重复的在 * 号之前的字符。&lt;/p&gt;
&lt;p&gt;例：a* =&amp;gt; b&lt;span&gt;a&lt;/span&gt;b&lt;span&gt;aa&lt;/span&gt;123.&lt;/p&gt;
&lt;p&gt;例：[a-z]* =&amp;gt; T&lt;span&gt;he car parked in the garage&lt;/span&gt; #21.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;*&lt;/code&gt; 字符和 &lt;code&gt;.&lt;/code&gt; 字符搭配可以匹配所有的字符 &lt;code&gt;.*&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;-3&quot;&gt;+&lt;/h2&gt;
&lt;p&gt;匹配 &amp;gt;= 1个重复的 + 号前的字符。&lt;/p&gt;
&lt;p&gt;例：c.+t =&amp;gt; The fat &lt;span&gt;cat sat on the mat&lt;/span&gt;.&lt;/p&gt;
&lt;h2 id=&quot;-4&quot;&gt;?&lt;/h2&gt;
&lt;p&gt;标记 ? 之前的字符为可选，即出现 0 或 1 次。&lt;/p&gt;
&lt;p&gt;例：[T]?he =&amp;gt; &lt;span&gt;The&lt;/span&gt; car is parked in t&lt;span&gt;he&lt;/span&gt; garage.&lt;/p&gt;
&lt;h2 id=&quot;nm&quot;&gt;{n,m}&lt;/h2&gt;
&lt;p&gt;匹配 num 个大括号之前的字符或字符集 (n &amp;lt;= num &amp;lt;= m)。&lt;/p&gt;
&lt;p&gt;例：[0-9]{2,3} =&amp;gt; The number was 9.&lt;span&gt;999&lt;/span&gt;7 but we rounded it off to &lt;span&gt;10&lt;/span&gt;.0.&lt;/p&gt;
&lt;p&gt;可以省略第二个参数，表示至少。&lt;/p&gt;
&lt;p&gt;例：[0-9]{2,} =&amp;gt; The number was 9.&lt;span&gt;9997&lt;/span&gt; but we rounded it off to &lt;span&gt;10&lt;/span&gt;.0.&lt;/p&gt;
&lt;p&gt;逗号也省略掉则表示重复固定的次数。&lt;/p&gt;
&lt;p&gt;例：[0-9]{3} =&amp;gt; The number was 9.&lt;span&gt;999&lt;/span&gt;7 but we rounded it off to 10.0.&lt;/p&gt;
&lt;h2 id=&quot;xyz&quot;&gt;(xyz)&lt;/h2&gt;
&lt;p&gt;字符集，匹配与 xyz 完全相等的字符串，括号内的被视为一个整体。&lt;/p&gt;
&lt;p&gt;JMeter 中，通过小括号来提取字符串中的子字符串。&lt;/p&gt;
&lt;p&gt;例：&quot;token&quot;:&quot;(.*?)&quot;,&quot;expired_at&quot; =&amp;gt; &quot;token&quot;:&quot;&lt;span&gt;123&lt;/span&gt;&quot;,&quot;expired_at&quot;&lt;/p&gt;
&lt;h2 id=&quot;-5&quot;&gt;|&lt;/h2&gt;
&lt;p&gt;或运算符，匹配符号前或后的字符。&lt;/p&gt;
&lt;p&gt;例：&quot;(T|t)he|car&quot; =&amp;gt; &lt;span&gt;The car&lt;/span&gt; is parked in &lt;span&gt;the&lt;/span&gt; garage.&lt;/p&gt;
&lt;h2 id=&quot;-6&quot;&gt;^&lt;/h2&gt;
&lt;p&gt;字符串开头。&lt;/p&gt;
&lt;p&gt;例：&quot;^(T|t)he&quot; =&amp;gt; &lt;span&gt;The&lt;/span&gt; car is parked in &lt;span&gt;the&lt;/span&gt; garage.&lt;/p&gt;
&lt;h2 id=&quot;-7&quot;&gt;$&lt;/h2&gt;
&lt;p&gt;字符串结尾。&lt;/p&gt;
&lt;p&gt;例：&quot;(at.)$&quot; =&amp;gt; The fat c&lt;span&gt;at.&lt;/span&gt; s&lt;span&gt;at.&lt;/span&gt; on the m&lt;span&gt;at.&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;转义&quot;&gt;转义&lt;/h2&gt;
&lt;p&gt;对于正则表达式的这些特殊字符：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{ } [ ] ( ) / \ + * . $ ^ | ?
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果需要匹配，那么需要使用反斜杠 &lt;code&gt;\&lt;/code&gt; 进行转义。&lt;/p&gt;
&lt;p&gt;例：&quot;(f|c|m)at\.?&quot; =&amp;gt; The &lt;span&gt;fat cat&lt;/span&gt; sat on the &lt;span&gt;mat.&lt;/span&gt;&lt;/p&gt;

&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;简写&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;8&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;.&lt;/td&gt;
&lt;td&gt;除换行符外的所有字符&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;\w&lt;/td&gt;
&lt;td&gt;匹配所有字母数字，等同于 &lt;code&gt;[a-zA-Z0-9_]&lt;/code&gt;，&lt;strong&gt;w是word首字母&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;\W&lt;/td&gt;
&lt;td&gt;匹配所有非字母数字，即符号，等同于： &lt;code&gt;[^\w]&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;\d&lt;/td&gt;
&lt;td&gt;匹配数字： &lt;code&gt;[0-9]&lt;/code&gt;，&lt;strong&gt;d是digital首字母&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;\D&lt;/td&gt;
&lt;td&gt;匹配非数字： &lt;code&gt;[^\d]&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;\s&lt;/td&gt;
&lt;td&gt;匹配所有空格字符，等同于： &lt;code&gt;[\t\n\f\r\p{Z}]&lt;/code&gt;，&lt;strong&gt;s是space首字母&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;\S&lt;/td&gt;
&lt;td&gt;匹配所有非空格字符： &lt;code&gt;[^\s]&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;\f&lt;/td&gt;
&lt;td&gt;匹配一个换页符&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;\n&lt;/td&gt;
&lt;td&gt;匹配一个换行符&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;\r&lt;/td&gt;
&lt;td&gt;匹配一个回车符&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;\t&lt;/td&gt;
&lt;td&gt;匹配一个制表符&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;\v&lt;/td&gt;
&lt;td&gt;匹配一个垂直制表符&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;\p&lt;/td&gt;
&lt;td&gt;匹配 CR/LF（等同于 &lt;code&gt;\r\n&lt;/code&gt;），用来匹配 DOS 行终止符&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;正则表达式默认是贪婪匹配，也就是会尽可能多的匹配字符串。可以使用 &lt;code&gt;?&lt;/code&gt; 将贪婪匹配模式转化为非贪婪匹配模式。&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;p&gt;默认贪婪：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202011/1629545-20201119223613621-1309046752.png&quot;/&gt;&lt;/center&gt;
&lt;p&gt;使用 &lt;code&gt;?&lt;/code&gt; 转为非贪婪：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202011/1629545-20201119223613962-1083828057.png&quot;/&gt;&lt;/center&gt;

&lt;p&gt;不同编程语言写法不同，比如 Python 可以通过 &lt;code&gt;re.compile('pattern', re.I)&lt;/code&gt; 来忽略大小写。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://tool.oschina.net/regex/&quot;&gt;https://tool.oschina.net/regex/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;本文首先通过一个例子介绍了正则表达式是什么样子的，接着对字符匹配的特殊字符进行了讲解和示例说明，然后给出了简写字符集。正则表达式默认是贪婪模式，可以使用 &lt;code&gt;?&lt;/code&gt; 来转为非贪婪。也可以添加参数，让正则表达式忽略大小写等。最后给出了在线测试正则表达式地址，方便调试看结果。本文内容已经足够在工作中使用，更多高级用法可以通过参考资料进一步阅读。&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Regular_expression&quot;&gt;https://en.wikipedia.org/wiki/Regular_expression&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.python.org/3/library/re.html&quot;&gt;https://docs.python.org/3/library/re.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/ziishaned/learn-regex&quot;&gt;https://github.com/ziishaned/learn-regex&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/huxi/archive/2010/07/04/1771073.html&quot;&gt;https://www.cnblogs.com/huxi/archive/2010/07/04/1771073.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 19 Nov 2020 23:52:00 +0000</pubDate>
<dc:creator>dongfanger</dc:creator>
<og:description>‍分分钟包学包会。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/df888/p/14008394.html</dc:identifier>
</item>
<item>
<title>asp.net core 使用 TestServer 来做集成测试 - WeihanLi</title>
<link>http://www.cnblogs.com/weihanli/p/14007959.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/weihanli/p/14007959.html</guid>
<description>&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;/h2&gt;
&lt;p&gt;之前我的项目里的集成测试是随机一个端口，每次都真实的启动一个 WebServer，之前也有看到过微软文档上 &lt;code&gt;TestServer&lt;/code&gt; 的介绍，当时没仔细看过以为差不多就没用，一直是启动了一个真正的 WebServer 去跑集成测试的，上次分享 &lt;code&gt;Xunit.DependencyInjection&lt;/code&gt; 改造测试项目的时候，写的烂代码被大师看到了之后， 大师建议用 &lt;code&gt;TestServer&lt;/code&gt; 来做集成测试，使用 &lt;code&gt;TestServer&lt;/code&gt; 不会真正的占用端口号，不会出现权限问题，于是扒了扒 TestServer 的源码，并用 &lt;code&gt;TestServer&lt;/code&gt; 改进了集成测试项目，感谢大师[献花鲜花]~~&lt;/p&gt;
&lt;h2 id=&quot;sample&quot;&gt;Sample&lt;/h2&gt;
&lt;p&gt;之前的集成测试监听了一个端口号，使用了一个真实的 WebServer，下面改成使用 &lt;code&gt;TestServer&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;TestServer&lt;/code&gt; 现在是在 &lt;code&gt;Microsoft.AspNetCore.TestHost&lt;/code&gt; 这个 Nuget 包中，引用这个包就可以使用了&lt;/p&gt;
&lt;p&gt;在服务注册的时候调用 &lt;code&gt;UseTestServer&lt;/code&gt; 这一扩展方法就可以注入 &lt;code&gt;TestServer&lt;/code&gt; 了，集成测试一般会用 &lt;code&gt;HttpClient&lt;/code&gt; 来请求服务器端的 API 地址或页面，&lt;code&gt;TestServer&lt;/code&gt; 提供了一个方便的 &lt;code&gt;CreateClient&lt;/code&gt; 的方法可以很方便的创建一个用来请求 &lt;code&gt;TestServer&lt;/code&gt; 的 &lt;code&gt;HttpClient&lt;/code&gt;，微软也提供了一些比较方便的扩展方法，可以使用 &lt;code&gt;IHost&lt;/code&gt; 的 &lt;code&gt;GetTestClient&lt;/code&gt; 扩展方法来获取 &lt;code&gt;HttpClient&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;改成使用 &lt;code&gt;TestServer&lt;/code&gt; 很简单，引用 nuget 包 &lt;code&gt;Microsoft.AspNetCore.TestHost&lt;/code&gt;，变更对比如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/489462/202011/489462-20201119210919398-1891543584.png&quot; alt=&quot;diff&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;源码概览&quot;&gt;源码概览&lt;/h2&gt;
&lt;p&gt;TestServer 在启动的时候并没有监听端口，可以参考源码 &lt;code&gt;IServer&lt;/code&gt; 的 &lt;code&gt;Start&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/489462/202011/489462-20201120003404219-306703927.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;TestServer 通过 &lt;code&gt;CreateClient&lt;/code&gt; 方法来创建调用 TestServer 接口的 HttpClient&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/489462/202011/489462-20201120003619956-1048257741.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过上面的代码可以看的出来核心代码是在 &lt;code&gt;ClientHandler&lt;/code&gt; 中定义的，源码有点多，详细可以直接看源码 &lt;a href=&quot;https://github.com/dotnet/aspnetcore/blob/v5.0.0/src/Hosting/TestHost/src/ClientHandler.cs#L58&quot;&gt;https://github.com/dotnet/aspnetcore/blob/v5.0.0/src/Hosting/TestHost/src/ClientHandler.cs#L58&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/489462/202011/489462-20201120004828313-940272603.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ClientHandler&lt;/code&gt; 重写了 HttpClientHandler 的 &lt;code&gt;SendAsync&lt;/code&gt; 方法，使得请求直接拦截掉，不会真正的发生 Http 请求，实际的请求过程首先将 Http 请求的信息转换成 HttpRquestFeature 然后直接交给 TestServer 处理，其实也就是直接交给 asp.net core 的请求管道去处理，请求处理结束之后，获取 HttpContext 响应，获取 HttpResponseFeature 然后转换成 HttpClient 需要的 HttpResponseMessage.&lt;/p&gt;
&lt;h2 id=&quot;more&quot;&gt;More&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;TestServer&lt;/code&gt; 不仅仅可以支持 HTTP 请求的处理，还支持 WebSocket 的处理，WebSocket 的集成测试也可以使用 &lt;code&gt;TestServer&lt;/code&gt; 来处理。&lt;/p&gt;
&lt;p&gt;你如果还是比较怀疑是否真的没有 HTTP 请求，可以用 Fildder 之类的 HTTP 抓包工具监控在跑测试的期间是否真的有 HTTP 请求，如果是真正的 WebServer 会有 HTTP 请求，TestServer 不会有 HTTP 请求。&lt;/p&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
</description>
<pubDate>Thu, 19 Nov 2020 23:43:00 +0000</pubDate>
<dc:creator>WeihanLi</dc:creator>
<og:description>asp.net core 使用 TestServer 做集成测试</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/weihanli/p/14007959.html</dc:identifier>
</item>
<item>
<title>HotSpot源码分析之类模型 - HotSpot-Researcher</title>
<link>http://www.cnblogs.com/mazhimazhi/p/14008940.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mazhimazhi/p/14008940.html</guid>
<description>&lt;p&gt;HotSpot采用了OOP-Klass模型描述Java的类和对象。Klass模型采用Klass类及相关子类的对象来描述具体的Java类。一般HotSpot JVM 在加载Java的Class 文件时，会在方法区创建 Klass ，用来保存Java类的元数据，包括常量池、字段、方法等。&lt;/p&gt;
&lt;p&gt;Klass模型中相关类的继承体系如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1236123/202007/1236123-20200702065856028-1709938581.png&quot; alt=&quot;&quot; width=&quot;771&quot; height=&quot;247&quot; loading=&quot;lazy&quot;/&gt;  &lt;/p&gt;
&lt;p&gt;Metadata是元数据类的基础类型，除了Klass会直接继承外，表示方法的Method与表示常量池的ConstantPool也会继承，这里只讨论Klass继承体系中涉及到的相关类。&lt;/p&gt;
&lt;p&gt;整个Klass模型中涉及到的C++类主要提供了2个功能： &lt;/p&gt;
&lt;p&gt;（1）提供C++层面的Java类型（包括Java类和Java数组）表示，也就是用C++类的对象来描述Java类型。&lt;/p&gt;
&lt;p&gt;（2）方法分派 &lt;/p&gt;
&lt;p&gt;这一篇文章重点介绍一下Klass这个基础类型。&lt;/p&gt;
&lt;p&gt;一个Klass对象（注意是Klass对象表示Java类的元数据，所以不同的Java类就用不同的Klass对象表示）代表一个Java类的元数据（相当于&lt;code&gt;java.lang.Class&lt;/code&gt;对象）。所以Klass中要有描述Java类中常量池、字段、方法的能力，也就是能保存这些信息，同时还能提供一些方法供HotSpot JVM的开发者操作这些信息。&lt;/p&gt;
&lt;p&gt;Klass类及重要属性的定义如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;69&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot; readability=&quot;29&quot;&gt;
源代码位置：hotspot/src/share/vm/oops/klass.hpp&lt;p&gt;class Klass : public Metadata {
 // ...
 protected:
  // note: put frequently-used fields together at start of klass structure
  // for better cache behavior (may not make much of a difference but sure won't hurt)
  enum { _primary_super_limit = 8 };
 
  // The &quot;layout helper&quot; is a combined descriptor of object layout.
  // For klasses which are neither instance nor array, the value is zero.
  //
  // For instances, layout helper is a positive number, the instance size.
  // This size is already passed through align_object_size and scaled to bytes.
  // The low order bit is set if instances of this class cannot be
  // allocated using the fastpath.
  //
  // For arrays, layout helper is a negative number, containing four
  // distinct bytes, as follows:
  //    MSB:[tag, hsz, ebt, log2(esz)]:LSB
  // where:
  //    tag is 0x80 if the elements are oops, 0xC0 if non-oops
  //    hsz is array header size in bytes (i.e., offset of first element)
  //    ebt is the BasicType of the elements
  //    esz is the element size in bytes
  // This packed word is arranged so as to be quickly unpacked by the
  // various fast paths that use the various subfields.
  //
  // The esz bits can be used directly by a SLL instruction, without masking.
  //
  // Note that the array-kind tag looks like 0x00 for instance klasses,
  // since their length in bytes is always less than 24Mb.
  //
  // Final note:  This comes first, immediately after C++ vtable,
  // because it is frequently queried.
  jint        _layout_helper;
 
  // The fields _super_check_offset, _secondary_super_cache, _secondary_supers
  // and _primary_supers all help make fast subtype checks.  See big discussion
  // in doc/server_compiler/checktype.txt
  //
  // Where to look to observe a supertype (it is &amp;amp;_secondary_super_cache for
  // secondary supers, else is &amp;amp;_primary_supers[depth()].
  juint       _super_check_offset;
 
  // Class name.  Instance classes: java/lang/String, etc.  Array classes: [I,
  // [Ljava/lang/String;, etc.  Set to zero for all other kinds of classes.
  Symbol*     _name;
 
  // Cache of last observed secondary supertype
  Klass*      _secondary_super_cache;
  // Array of all secondary supertypes
  Array&amp;lt;Klass*&amp;gt;* _secondary_supers;
  // Ordered list of all primary supertypes
  Klass*      _primary_supers[_primary_super_limit];
  // java/lang/Class instance mirroring this class
  oop         _java_mirror;
  // Superclass
  Klass*      _super;
  // First subclass (NULL if none); _subklass-&amp;gt;next_sibling() is next one
  Klass*      _subklass;
  // Sibling link (or NULL); links all subklasses of a klass
  Klass*      _next_sibling;
 
  // All klasses loaded by a class loader are chained through these links
  Klass*      _next_link;
 
  // The VM's representation of the ClassLoader used to load this class.
  // Provide access the corresponding instance java.lang.ClassLoader.
  ClassLoaderData* _class_loader_data;
 
  AccessFlags _access_flags;    // Access flags. The class/interface distinction is stored here.
 
  markOop  _prototype_header;   // Used when biased locking is both enabled and disabled for this type
  
  ...
}
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下表对各个属性进行了简单的介绍。 &lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;20.5&quot;&gt;&lt;tr&gt;&lt;td&gt;字段名&lt;/td&gt;
&lt;td&gt;作用&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;11&quot;&gt;&lt;td&gt;_layout_helper&lt;/td&gt;
&lt;td readability=&quot;15&quot;&gt;
&lt;p&gt;对象布局的综合描述符。如果不是InstanceKlass或ArrayKlass，值为0。如果是InstantceKlass或&lt;/p&gt;
&lt;p&gt;ArrayKlass时，这个值是个组合数字。&lt;/p&gt;
&lt;p&gt;（1）对InstanceKlass而言，组合数字中包含有表示对象的、以字节为单位的内存占用大小，也就是说InstanceKlass对象表示Java类，由这个Java类创建的对象所需要的大小。&lt;/p&gt;
&lt;p&gt;（2）对ArrayKlass而言，该值是一个组合数字，包含4部分，具体怎么组合和解析由子类实现：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;tag：如果数组元素的类型为对象类型，值为0x80；否则值为0xC0，表示数组元素的类型为Java基本类型。&lt;/li&gt;
&lt;li&gt;sz:：数组头元素的字节数&lt;/li&gt;
&lt;li&gt;ebt：数组元素的类型，枚举值BasicType&lt;/li&gt;
&lt;li&gt;esz：数组元素大小，以字节为单位&lt;/li&gt;
&lt;/ul&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;_name&lt;/td&gt;
&lt;td&gt;类名，如java/lang/String，[Ljava/lang/String&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;13&quot;&gt;&lt;td&gt;_primary_supers&lt;/td&gt;
&lt;td readability=&quot;15&quot;&gt;
&lt;p&gt;_primary_supers代表了这个类的父类，其类型是个Klass指针数组，大小固定为8。例如IOException是Exception的子类，&lt;/p&gt;
&lt;p&gt;而Exception又是Throwable的子类。所以表示IOException类的_primary_supers属性值为：&lt;/p&gt;
&lt;p&gt;[Throwable, Exception, IOException]。如果继承链过长，也就是当前类加上继承的类多于8个（默认值，可通过命令更改）时，&lt;/p&gt;
&lt;p&gt;会将多出来的类存储到secondary_supers数组中&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td&gt; _super_check_offset &lt;/td&gt;
&lt;td readability=&quot;9&quot;&gt;
&lt;p&gt;快速查找supertype的一个偏移量，这个偏移量是相对于Klass对象起始地址的偏移量。如果当前类是IOException，&lt;/p&gt;
&lt;p&gt;那么这个属性就指向_primary_supers数组中存储IOException的位置。当存储的类多于8个时，值与secondary_super_cache&lt;/p&gt;
&lt;p&gt;相等&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;_secondary_supers&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;Klass指针数组，一般存储Java类实现的接口，偶尔还会存储Java类的父类&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;_secondary_super_cache&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;Klass指针，保存上一次查询父类的结果&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;_java_mirror&lt;/td&gt;
&lt;td&gt;oopDesc类型的指针，保存的是当前Klass对象表示的Java类所对应的java.lang.Class对象，可以据此访问类的静态属性&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;_super&lt;/td&gt;
&lt;td&gt;Klass指针，指向Java类的直接父类 &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;_subklass&lt;/td&gt;
&lt;td&gt;Klass指针，指向Java类的直接子类，由于直接子类可能有多个，所以通过_next_sibling连接起来&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;_next_sibling&lt;/td&gt;
&lt;td&gt;Klass指针，该类的下一个子类，也就是通过_subklass-&amp;gt;next_sibling()获取_subklass的兄弟子类&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;_next_link&lt;/td&gt;
&lt;td&gt;Klass指针，ClassLoader加载的下一个Klass&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;_class_loader_data&lt;/td&gt;
&lt;td&gt;ClassLoaderData指针，可以通过此属性找到加载该Java类的ClassLoader&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;_access_flags&lt;/td&gt;
&lt;td&gt;获取Java类的修饰符，如private、final、static、abstract 、native等&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;_prototype_header&lt;/td&gt;
&lt;td&gt;在锁的实现过程中非常重要，后续在介绍锁时会介绍 &lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;可以看到，能够通过Klass类中的相关属性保存Java类定义的一些信息，如_name保存Java类的名称、_super保存Java类实现的类型等。Klass类是Klass模型中定义的C++类的基类，所以此类对象只保存了Java类的一些必要信息，其它如常量池、方法、字段等会通过Klass类的具体子类的相关属性来保存。 &lt;/p&gt;
&lt;p&gt;类的属性比较多，我们在后面解释类的过程中可以看到对相关属性的赋值操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、_layout_helper&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;_layout_helper是一个组合属性。如果当前的类表示一个Java数组类型时，这个属性的值比较复杂。通常会调用如下函数生成值：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
jint Klass::array_layout_helper(BasicType etype) {
  assert(etype &amp;gt;= T_BOOLEAN &amp;amp;&amp;amp; etype &amp;lt;= T_OBJECT, &quot;valid etype&quot;);

  bool  isobj = (etype == T_OBJECT);
  int   tag   =  isobj ? _lh_array_tag_obj_value : _lh_array_tag_type_value;
   // Note that T_ARRAY is not allowed here.
  // 在64位系统下，存放_metadata的空间大小是8字节，_mark是8字节，
  // length是4字节，对象头为20字节，由于要按8字节对齐，所以会填充4字节，最终占用24字节
  int   hsize = arrayOopDesc::base_offset_in_bytes(etype); // hsize表示数组头部大小
  int   esize = type2aelembytes(etype); // Java基本类型元素需要占用的字节数
  int   esz = exact_log2(esize); // 例如Java基本类型元素占用4个字节，则存储的是2
  int   lh = array_layout_helper(tag, hsize, etype, esz);

  return lh;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中用到2个枚举常量，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
_lh_array_tag_type_value    = ~0x00, 
_lh_array_tag_obj_value     = ~0x01   
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;_lh_array_tag_type_value的二进制表示为32个1：11111111111111111111111111111111，其实也就是0xC0000000 &amp;gt;&amp;gt; 30，做算术右移，负数的最高位补1。&lt;/p&gt;
&lt;p&gt;_lh_array_tag_obj_value的二进制表示为最高位31个1：11111111111111111111111111111110，其实也就是0x80000000 &amp;gt;&amp;gt; 30，做自述右移，负数的最高位补1。&lt;/p&gt;
&lt;p&gt;调用的arrayOopDesc::base_offset_in_bytes()函数及调用的相关函数的实现如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
// Returns the offset of the first element.
static int base_offset_in_bytes(BasicType type) {
    return header_size(type) * HeapWordSize;
}

// Should only be called with constants as argument (will not constant fold otherwise)
// Returns the header size in words aligned to the requirements of the array object type.
static int header_size(BasicType type) {
    size_t  typesize_in_bytes = header_size_in_bytes();
    if( Universe::element_type_should_be_aligned(type) ){
        return (int)align_object_offset( typesize_in_bytes/HeapWordSize );
    }else {
        return (int)typesize_in_bytes/HeapWordSize;
    }
}

// 在64位系统下，存放_metadata的空间大小是8字节，_mark是8字节，length是4字节，对象头为20字节，
// 由于要按8字节对齐，所以会填充4字节，最终占用24字节
static int header_size_in_bytes() {
    intptr_t  temp =  length_offset_in_bytes() + sizeof(int); // sizeof(int)
    size_t    hs = align_size_up(temp,HeapWordSize);
    return (int)hs;
}

// The _length field is not declared in C++.  It is allocated after the
// declared nonstatic fields in arrayOopDesc if not compressed, otherwise
// it occupies the second half 下半场 of the _klass field in oopDesc.
static int length_offset_in_bytes() {
        if(UseCompressedClassPointers){
                return klass_gap_offset_in_bytes();
        }else{
                 sizeof(arrayOopDesc);
        }
}
　　
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码的逻辑非常清晰，这里不过多介绍。最终会在Klass::array_layout_helper()函数中调用array_layout_helper()函数完成属性值的计算。这个函数的实现如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
static jint array_layout_helper(jint tag, int hsize, BasicType etype, int log2_esize) {
    return (tag        &amp;lt;&amp;lt; _lh_array_tag_shift)           // 左移30位
      |     (hsize      &amp;lt;&amp;lt; _lh_header_size_shift)         // 左移16位
      |     ((int)etype &amp;lt;&amp;lt; _lh_element_type_shift)       // 左移1位
      |     (log2_esize &amp;lt;&amp;lt; _lh_log2_element_size_shift);  // 左移0位
  }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对_lh_array_tag_type_value与_lh_array_tag_obj_value值左移30位后，第32位上肯定为1，所以最终计算出的值是一个小于0的数。而非数组类型，一般由InstanceKlass对象表示的Java类来说，计算的属性值如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
 static jint instance_layout_helper(jint size, bool slow_path_flag) {
          if(slow_path_flag){
                  return  (size &amp;lt;&amp;lt; LogHeapWordSize)  | _lh_instance_slow_path_bit;
          }else{
                  return  (size &amp;lt;&amp;lt; LogHeapWordSize)  | 0; // LogHeapWordSize=3
          }
  }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;size为对象的、以字节为单位的内存占用大小，所以肯定是一个正数。这样就可以通过_layout_helper来判断类型了。　&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、_primary_supers、_super_check_offset、_secondary_supers与_secondary_super_cache&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这几个属性完全是为了加快判定父子关系等逻辑而加入的。下面看initialize_supers()函数中是如何初始化这几个属性的。函数的第1部分实现如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
源代码位置：hotspot/src/share/vm/oops/klass.cpp 

void Klass::initialize_supers(Klass* k, TRAPS) { // 
  // 当前类的父类k可能为NULL，例如Object的父类为NULL
  if (k == NULL) {
    set_super(NULL);           
    _primary_supers[0] = this;
  } 
  // k就是当前类的直接父类，如果有父类，那么super()一般为NULL，如果k为NULL，那么就是Object类，从下面的断言也可以看出
  else if (k != super() || k == SystemDictionary::Object_klass()) {

    set_super(k);    // 设置Klass的_super属性
    Klass* sup = k;

    int sup_depth = sup-&amp;gt;super_depth();
    juint my_depth  = MIN2(sup_depth + 1, (int)primary_super_limit()); // primary_super_limit()方法得到的值一般默认为8
    // 当父类的的继承链长度大于等于primary_super_limit()时，当前的深度只能是primary_super_limit()，也就是8,因为_primary_supers中只存储8个类
    if (!can_be_primary_super_slow()){
      my_depth = primary_super_limit(); // 8
    }
    for (juint i = 0; i &amp;lt; my_depth; i++) { // my_depth默认的值为8
       _primary_supers[i] = sup-&amp;gt;_primary_supers[i];
    }

    Klass* *super_check_cell;
    if (my_depth &amp;lt; primary_super_limit()) { // primary_super_limit()的默认为8
       _primary_supers[my_depth] = this;
       super_check_cell = &amp;amp;_primary_supers[my_depth];
    } else {
       // Overflow of the primary_supers array forces me to be secondary.
       super_check_cell = &amp;amp;_secondary_super_cache;
    }
    // 通过_super_check_offset这个偏移量可以快速定义到当前在_primary_supers中的位置
    juint  _super_check_offset = (address)super_check_cell - (address) this;
    set_super_check_offset( _super_check_offset ); // 设置Klass中的_super_check_offset属性
  }

  // 第2部分代码在下面
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在设置当前类的父类时通常都会调用initialize_supers方法，同时也会设置_primary_supers、super_check_offset，如果继承链过长，还有可能设置secondary_supers、secondary_super_cache等值。这此属性中存储继承链中涉及到的类以方便快速的进行类关系之间的判断，例如父子关系的判断。　　&lt;/p&gt;
&lt;p&gt;方法的第2部分代码实现如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
if (secondary_supers() == NULL) {
    KlassHandle this_kh (THREAD, this);

    // Now compute the list of secondary supertypes.
    // Secondaries can occasionally be on the super chain,
    // if the inline &quot;_primary_supers&quot; array overflows.
    int extras = 0;
    Klass* p;
    for (p = super();
           // 当p不为NULL并且p已经存储在了_secondary_supers数组中时，条件为true
           // 也就是当前类的父类多于8个，将多出来的存储到了_secondary_supers数组中了
          !(p == NULL || p-&amp;gt;can_be_primary_super());  
          p = p-&amp;gt;super()) {
      ++extras;
    }

    // 计算secondaries需要的大小，因为secondaries数组中还需要存储当前类的所有实现接口（包括直接和间接实现的接口）
    // Compute the &quot;real&quot; non-extra secondaries.
    GrowableArray&amp;lt;Klass*&amp;gt;* secondaries = compute_secondary_supers(extras);
    if (secondaries == NULL) { // extras为0时直接返回，不需要额外的处理
      // secondary_supers set by compute_secondary_supers
      return;
    }

    GrowableArray&amp;lt;Klass*&amp;gt;* primaries = new GrowableArray&amp;lt;Klass*&amp;gt;(extras);
    for ( p = this_kh-&amp;gt;super();
          !(p == NULL || p-&amp;gt;can_be_primary_super());  
          p = p-&amp;gt;super()
    ){
      primaries-&amp;gt;push(p);
    }

    // Combine the two arrays into a metadata object to pack the array.
    // The primaries are added in the reverse order, then the secondaries.
    int new_length = primaries-&amp;gt;length() + secondaries-&amp;gt;length();
    Array&amp;lt;Klass*&amp;gt;* s2 = MetadataFactory::new_array&amp;lt;Klass*&amp;gt;(class_loader_data(), new_length, CHECK);
    int fill_p = primaries-&amp;gt;length();
    for (int j = 0; j &amp;lt; fill_p; j++) {
       s2-&amp;gt;at_put(j, primaries-&amp;gt;pop());  // add primaries in reverse order.也就是父类永远在数组前，子类永远在数组后
    }
    for( int j = 0; j &amp;lt; secondaries-&amp;gt;length(); j++ ) {
       s2-&amp;gt;at_put(j+fill_p, secondaries-&amp;gt;at(j));  // add secondaries on the end.
    }

    this_kh-&amp;gt;set_secondary_supers(s2); // 设置_secondary_supers属性
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到，会将父亲继承链中多于8个的父类存储到secondary_supers数组中，不过因为继承链一般都不会多于8个，所以设置了默认值为8。　　&lt;/p&gt;
&lt;p&gt;下面举个例子，看看这几个属性是如何存储值的，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
interface IA{}
interface IB{}

class A{}
class B extends A{}
class C extends B{}
class D extends C{}
public class Test extends D implements IA,IB {}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;配置-XX:FastSuperclassLimit=3后，_primary_supers数组中就最多只能存储3个类了。值如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
_primary_supers[Object,A,B]
_secondary_supers[C,D,Test,IA,IB]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于当前类Test的继承链过长，导致C、D和Test只能存储到_secondary_supers。所以此时_super_check_offset会指向C，也就是_secondary_supers中存储的第1个元素。&lt;/p&gt;
&lt;p&gt;下面举个例子，看一下这几个属性如何应用。例如is_subtype_of()方法，实现如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
// subtype check: true if is_subclass_of, or if k is interface and receiver implements it
bool is_subtype_of(Klass* k) const { // 判断当前类是否为k的子类
    juint    off = k-&amp;gt;super_check_offset();
    Klass*   sup = *(Klass**)( (address)this + off );

    const juint secondary_offset = in_bytes(secondary_super_cache_offset());

    if (sup == k) {
      return true;
    } else if (off != secondary_offset) { 
      return false;
    } else {
      return search_secondary_supers(k);
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当通过_super_check_offset获取到的类与k相同时，那么k存在于当前类的继承链上，肯定有父子关系。&lt;/p&gt;
&lt;p&gt;如果k存在于_primary_supers数组中，那么通过_super_check_offset就可快速判断，如果k存在于_secondary_supers中，那么需要调用search_secondary_supers()来判断。&lt;/p&gt;
&lt;p&gt;调用的search_secondary_supers()方法的实现如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
bool Klass::search_secondary_supers(Klass* k) const {
  // Put some extra logic here out-of-line, before the search proper.
  // This cuts down the size of the inline method.

  // This is necessary, since I am never in my own secondary_super list.
  if (this == k){
    return true;
  }
  // Scan the array-of-objects for a match
  int cnt = secondary_supers()-&amp;gt;length();
  for (int i = 0; i &amp;lt; cnt; i++) {
    if (secondary_supers()-&amp;gt;at(i) == k) {
      ((Klass*)this)-&amp;gt;set_secondary_super_cache(k); // 设置_secondary_super_cache属性，保存这次查询的结果
      return true;
    }
  }
  return false;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到，属性_secondary_super_cache保存了这一次父类查询的结果。查询的逻辑很简单，遍历_secondary_supers数组中的值并比较即可。　&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、_super、_subklass、_next_sibling　&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于Java类是单继承，所以可通过_super、_subklass、_next_sibling属性可直接找到当前类的父类或所有子类。调用Klass::append_to_sibling_list()函数设置_next_sibling与_subklass的值，方法的实现如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
void Klass::append_to_sibling_list() {  

  // add ourselves to superklass' subklass list
  InstanceKlass* super = superklass(); // 获取到_super属性的值
  if (super == NULL)
          return;   // special case: class Object

  Klass* prev_first_subklass = super-&amp;gt;subklass_oop(); // 获取_subklass属性的值
  if (prev_first_subklass != NULL) {
    // set our sibling to be the superklass' previous first subklass
    set_next_sibling(prev_first_subklass); // 设置_next_sibling属性的值
  }
  // make ourselves the superklass' first subklass
  super-&amp;gt;set_subklass(this); // 设置_subklass属性的值
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;方法的实现逻辑很简单，这里不过多介绍。　　&lt;/p&gt;
&lt;p&gt;其它文章：&lt;/p&gt;
&lt;p&gt;1、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13983301.html&quot; target=&quot;_blank&quot;&gt;在Ubuntu 16.04上编译OpenJDK8的源代码（配视频）&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;2、&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2 vertical-middle&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13992240.html&quot;&gt;调试HotSpot源代码（配视频）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3、&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2 vertical-middle&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13222664.html&quot;&gt;HotSpot项目结构&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4、&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2 vertical-middle&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13997925.html&quot;&gt;HotSpot的启动过程（配视频进行源码分析）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;5、&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2 vertical-middle&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/14003295.html&quot;&gt;HotSpot源码分析之C++对象的内存布局&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;搭建过程中如果有问题可直接评论留言或加作者微信mazhimazh。&lt;/p&gt;
&lt;p&gt;作者持续维护的个人博客  &lt;a href=&quot;http://classloading.com/&quot; target=&quot;_blank&quot;&gt;classloading.com&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;B站上有HotSpot源码分析相关视频 &lt;a href=&quot;https://space.bilibili.com/27533329&quot;&gt;https://space.bilibili.com/27533329&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;关注公众号，有HotSpot源码剖析系列文章！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1236123/202006/1236123-20200630200021532-955264784.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;  &lt;/p&gt;

</description>
<pubDate>Thu, 19 Nov 2020 22:44:00 +0000</pubDate>
<dc:creator>HotSpot-Researcher</dc:creator>
<og:description>HotSpot采用了OOP-Klass模型描述Java的类和对象。Klass模型采用Klass类及相关子类的对象来描述具体的Java类。一般HotSpot JVM 在加载Java的Class 文件时，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mazhimazhi/p/14008940.html</dc:identifier>
</item>
<item>
<title>分布式监控系统之Zabbix基础使用 - Linux-1874</title>
<link>http://www.cnblogs.com/qiuhom-1874/p/14007342.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qiuhom-1874/p/14007342.html</guid>
<description>&lt;p&gt;　　前文我们了解了分布式监控系统zabbix的相关组件的作用和zabbix的部署，回顾请参考&lt;a href=&quot;https://www.cnblogs.com/qiuhom-1874/p/13997582.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/qiuhom-1874/p/13997582.html&lt;/a&gt;；今天我们来了解下zabbix的基础使用；&lt;/p&gt;
&lt;p&gt;　　在开始使用zabbix之前，我们先来了解下zabbix的一些术语&lt;/p&gt;
&lt;p&gt;　　1、监控项（item）：什么是监控项？&lt;/p&gt;
&lt;p&gt;　　在zabbix中监控项（item）是一个核心的东西，所有监控都是围绕监控项展开的，可以说没有监控项就没有我们想要的指标数据；所以简单讲监控项就是被监控对象的指标数据，通常这个被监控的对象我们称为主机（host），它可以是一个网络设备或一台服务器，用ip地址或dns域名指定；一台主机可以是属于一个或多个主机组（host group），所谓主机组就是多台主机的相同集合，用来逻辑的将主机分组，方便统一标识和管理；比如一台server它可以是tomcat主机组，也可以是nginx主机组，不同主机组可能有不同的监控项；同时对于监控项来讲也有类似组的概念，在zabbix中多个监控项逻辑的划分在一起就是监控项组，但通常我们不叫监控项组，而是叫application；所以application就是多个监控项的逻辑组，一个监控项通常属于一个或多个application，这个和主机组的逻辑是一样的；&lt;/p&gt;
&lt;p&gt;　　2、触发器（trigger）：什么是触发器？&lt;/p&gt;
&lt;p&gt;　　所谓触发器就是一个表达式，这个表达式主要用来评判我们采集的数据是否处于合理范围内？如果我们采集的数据是一个非合理范围，则该表达式就返回true;所以在zabbix中触发器就是用来定义我们采集到的数据的非合理区间，用于评估某监控对象的某些特定item内所接收到的数据是否在合理范围内（即阈值），如果接收到的数据大于指定的阈值，此时触发状态就会从OK状态转变为problem状态；当数据量再次回归到合理范围时，此时触发器又会从problem状态回归ok状态；简单讲触发器就是用来评估某些监控项采集到数据是否合理，如果不合理，就生成一个触发器事件（event），而这个事件会被其他组件监听，一旦监听到对应的事件产生，其他组件随之就会采取一定的措施；比如发短信、发邮件或者重启服务等等操作；&lt;/p&gt;
&lt;p&gt;　　3、动作（action）：什么是action？&lt;/p&gt;
&lt;p&gt;　　action指当特定的事件产生时，对应该采取的措施，比如当我们监控到nginx服务宕机了，此时我们应该采取什么措施？重启服务，发送短信通知管理员等等；所以action就是指对于特定事件事先定义的处理方法，通过包含操作（如发送通知）和条件（何时执行操作）；&lt;/p&gt;
&lt;p&gt;　　4、图像（graphs）：什么是graph？&lt;/p&gt;
&lt;p&gt;　　graph就是指把对应一个或多个监控项的历史数据通过图像的方式展示出来，主要方便我们来查看过去一段时间对应监控项的数据变化情况；我们把一个或多个监控项组合在一起显示就叫做一个graph；多个graph组成一个屏幕（screen），多个screen组成一个slide show；&lt;/p&gt;
&lt;p&gt;　　了解了以上术语，接下来我们来添加一个主机到zabbix上&lt;/p&gt;
&lt;p&gt;　　复制zabbix yum仓库文件到被监控主机之上&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node03 ~]# scp /etc/yum.repos.d/zabbix.repo  node04:/etc/yum.repos.d/
zabbix.repo                                                                   100%  242    98.5KB/s   00:00    
[root@node03 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在被监控主机之上安装zabbix-agent&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node04 ~]# yum install -y zabbix-agent 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　配置zabbix-agent &lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node04 ~]# grep -Ei ^[^#] /etc/zabbix/zabbix_agentd.conf
PidFile=/var/run/zabbix/zabbix_agentd.pid
LogFile=/var/log/zabbix/zabbix_agentd.log
LogFileSize=0
Server=192.168.0.43
ListenPort=10050
ListenIP=0.0.0.0
StartAgents=3
ServerActive=192.168.0.43
HostnameItem=system.hostname
Include=/etc/zabbix/zabbix_agentd.d/*.conf
[root@node04 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　启动zabbix-agent&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node04 ~]# systemctl start zabbix-agent.service 
[root@node04 ~]# ss -tnl
State      Recv-Q Send-Q           Local Address:Port                          Peer Address:Port              
LISTEN     0      128                          *:22                                       *:*                  
LISTEN     0      100                  127.0.0.1:25                                       *:*                  
LISTEN     0      128                          *:10050                                    *:*                  
LISTEN     0      128                         :::22                                      :::*                  
LISTEN     0      100                        ::1:25                                      :::*                  
[root@node04 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：请确保10050正常监听并能够和zabbix正常通信；&lt;/p&gt;
&lt;p&gt;　　创建主机组&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201119180733822-36648505.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：登录zabbix web，找到configuration菜单----&amp;gt;Host groups ----&amp;gt; create host group；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201119181035353-1503884070.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：填写对应要创建的主机组名称，点击add即可；&lt;/p&gt;
&lt;p&gt;　　添加主机&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201119180114163-572312255.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：找到configuration菜单----&amp;gt;Hosts----&amp;gt;create host；默认zabbix把zabbixserver是添加了的，这个也是我们为什么要在zabbixserver上装zabbix agent的原因；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201119181255099-215428694.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：填写要添加主机的主机名，选择要归属地主机组，以及使用哪种信道去采集数据；在zabbix支持4中信道去采集数据，第一种是agent，就是用zabbix agen采集数据；第二种是snmp，这种常用于那些不能安装agent的场景中，比如监控网络设备；第三种是jmx，这种专用于监控java虚拟机的专有信道；第四种是ipmi，这个必须得硬件支持ipmi协议；选择对应的信道填写对应的信息即可；当然一个主机也可以通过多个信道去采集数据；同一种类型的信道也可以添加多个；填写好以上内容点击add就把node04添加到zabbix监控系统中了；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201119182926267-979635892.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：添加好主机以后，在hosts列表中就能看到我们刚才添加到主机，但是它上面的4个信道没有显示为绿色；这是因为在我们添加到主机上没有任何的监控项，所以没有数据采集，对应的信道也不会变绿，只有添加了监控项，有数据采集了，对应信道就会变绿；&lt;/p&gt;
&lt;p&gt;　　添加item&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201119183246945-1182605635.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：在configuration---&amp;gt;Hosts找到对应主机的items，然后点击进去，找到create item；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201119183823090-1998829166.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：在zabbix中内置了很多item，每个item对应有一个key，这个key就是用来标识监控项的，不同的监控项对应使用的采集方式不同，所以监控项就是定义如何去采集数据，怎么采集数据的一个函数，我们在应用时，只需要指定key名，以及传递必要的参数即可；内置监控项的使用说明请查看官方文档&lt;a href=&quot;https://www.zabbix.com/documentation/4.0/manual/config/items/itemtypes/zabbix_agent&quot; target=&quot;_blank&quot;&gt;https://www.zabbix.com/documentation/4.0/manual/config/items/itemtypes/zabbix_agent&lt;/a&gt;；填写了对应的信息以后，这里需要注意对应监控项采集到数据到底是一个什么数据，是一个不断累加的值？还是变化值？我们要怎么显示它？对于cpu上下文切换次数这个监控项采集到的是一个不断累加的值，相比我们不是想了解这个监控项采集到数据是多少，而是想要它显示和上一次数据的变化值，所以我们还可设置监控项预处理方案；&lt;/p&gt;
&lt;p&gt;　　点击左上角的preprocessing&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201119184832009-906543496.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：选择好对应预处理方式以后，点击最下面的add就可以成功将对应监控项添加到对应主机上；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201119185003136-300128360.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　查看对应监控项是否采集到数据？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201119185227533-911971462.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：在monitoring----&amp;gt;Latest data 选择对应主机名称点击apply查找；如果对应主机上的监控项在指定时间内采集的有数据，则说明我们配置的监控项没有问题；从上面图片可以看到对应主机cpu上下文切换次数，最新一次数据是26次，比上一次少一次；&lt;/p&gt;
&lt;p&gt;　　查看对应监控项图形&lt;/p&gt;
&lt;p&gt;　　点击对应监控项后面的graph按钮即可显示对应监控项的图像&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201119185645255-1504989437.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　到此，一个监控项就这样定义好了；要添加第二个监控项也是以上的步骤；&lt;/p&gt;
&lt;p&gt;　　克隆监控项&lt;/p&gt;
&lt;p&gt;　　在对应主机的item列表中点击要克隆的监控项&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201119191125185-1815819844.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201119191205283-616945080.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：找到最下面的clone点击即可；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201119191357674-2142029562.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：修改对应名称和key，点击添加即可；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201119191452187-100158355.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：监控项克隆主要针对监控同类数据的不同指标用到比较多，像上面就是监控ens33这张网卡的进站报文数和出站报文数；这也是一种快速添加监控项的方式；&lt;/p&gt;
&lt;p&gt;　　添加触发器&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201119192247363-473966821.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：在configuration---&amp;gt;Hosts找到对应主机的Triggers，点击进去，然后找到create trigger按钮，点击进入创建触发器的页面；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201119194043201-1608415792.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：触发器就是一个表达式，该表达式主要来评判对应item采集到数据是否在合理范围，如果不在合理范围该表达式返回true；书写触发器表达式可以点击后面的add来选择；如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201119193902644-550066338.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：这个主要用于辅助我们生存触发器表达式；首先选择一个item，然后选择评判的函数，这个函数有很多，默认是last{}函数，这个函数表示取最近几次或某个时间段的数据来做评判标准，如果是次数，在last of （T） 填写对应的次数即可；如果是时间，在time shift填写时间，默认是秒为单位；result是对应评判的标准，比如500，就表示对应触发器表达式会把item采集的数据和500做对比，如果大于500 就会触发一个触发器事件；选择好条件以后点击inset 就可以自动生成我们定义的触发器表达式，定义好触发器以后，点击最下面的add即可添加触发器到指定主机上；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201119194123959-254868484.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　查看对应监控项的graph,看看是否有触发器呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201119194740466-723594724.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：可以看到对应的item上就可以看到有一个水平线，超过这个线就表示采集到数据不在合理区间，此时就会产生触发器事件；&lt;/p&gt;
&lt;p&gt;　　查看触发器事件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201119195018690-300334727.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：在Monitoring---&amp;gt;Problems中就能查看到对应触发器事件，这里显示该事件已经恢复了；&lt;/p&gt;
&lt;p&gt;　　添加action&lt;/p&gt;
&lt;p&gt;　　为了演示能看出效果，先在node04上添加一个监控nginx是否存活的监控项&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201119212215576-1948808445.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　添加nginx down触发器&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201119212834378-2114094943.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：以上表达式表示监控nginx状态最近3次都是down的状态就生成触发器事件；&lt;/p&gt;
&lt;p&gt;　　添加action&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201119213247129-582741935.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：action是针对整个zabbix全局而设定的，只要有对应事件产生，监听该事件的action就会执行相应的操作，常用的操作有发邮件和远程执行命令；&lt;/p&gt;
&lt;p&gt;　　zabbix监控nginx是否启动，如果没有启动就远程执行命令，让其启动&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201119225116015-835101183.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：action常用的操作有两个，第一个是当触发器从ok状态到problem状态，第二个是从problem到ok状态&lt;/p&gt;
&lt;p&gt;　　定义operations操作&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201119210312761-1278411096.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201119214131484-345523768.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：选择remote command，添加targetlist为当前主机，type为ssh，填写对应的ssh用户密码端口以及执行的命令，点击add,最后点击add；这里需要注意一点，通常我们使用ssh远程执行命令，不建议直接使用root执行，如果是其他普通用户需要注意执行命令是否有权限，如果没有还需要注意授权问题；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201119214219103-1041633855.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　到此一个远程执行命令的action就定义好了；&lt;/p&gt;
&lt;p&gt;　　测试：在node04上把nginx停掉，看看它是否会自动执行命令将nginx启动起来呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node04 ~]# systemctl stop nginx
[root@node04 ~]# ss -tnl
State      Recv-Q Send-Q           Local Address:Port                          Peer Address:Port              
LISTEN     0      128                          *:22                                       *:*                  
LISTEN     0      100                  127.0.0.1:25                                       *:*                  
LISTEN     0      128                          *:10050                                    *:*                  
LISTEN     0      128                         :::22                                      :::*                  
LISTEN     0      100                        ::1:25                                      :::*                  
[root@node04 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　到zabbix上查看对应监控项的状态&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201119214539500-1189138109.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　查看是否产生了触发器事件呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201119214639742-1995736020.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：可以看到对应触发器时间已经产生；我们等待3个检查周期，看看它是否会触发我们定义的action呢&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201119214845495-1267568922.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：再次查看该事件已经恢复；&lt;/p&gt;
&lt;p&gt;　　在node04上查看nginx是否启动？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node04 ~]# ss -tnl
State      Recv-Q Send-Q           Local Address:Port                          Peer Address:Port              
LISTEN     0      128                          *:80                                       *:*                  
LISTEN     0      128                          *:22                                       *:*                  
LISTEN     0      100                  127.0.0.1:25                                       *:*                  
LISTEN     0      128                          *:10050                                    *:*                  
LISTEN     0      128                         :::80                                      :::*                  
LISTEN     0      128                         :::22                                      :::*                  
LISTEN     0      100                        ::1:25                                      :::*                  
[root@node04 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到80端口已经正常处于监听状态；这说明我们刚才定义的action生效了；&lt;/p&gt;
&lt;p&gt;　　定义action发送邮件&lt;/p&gt;
&lt;p&gt;　　添加发送邮件的媒介&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201119220049243-578359752.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：默认有3个媒介，这三个媒介是zabbix默认的，建议不使用，直接自己添加；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201119221238091-45616270.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：这个邮箱的密码填写开启smtp后自动生成的密码；填写好对应的邮箱相关信息后点击add即可；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201119221339780-1647106231.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　编辑admin用户，配置接收邮件地址&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201119222631416-1213118411.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201119222709857-468745349.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：这里要选择我们刚才添加媒介类型；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201119222757869-1409546186.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　编辑nginx down action&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201119221817228-1488970854.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：选择send massage，添加邮件接收人，以及发送邮件的媒介点击update，最后点击最下面的update;&lt;/p&gt;
&lt;p&gt;　　测试：在node04上把nginx服务停掉，看看是否会给linux-1874@qq.com发送邮件呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node04 ~]# systemctl stop nginx
[root@node04 ~]# ss -tnl
State      Recv-Q Send-Q           Local Address:Port                          Peer Address:Port              
LISTEN     0      128                          *:22                                       *:*                  
LISTEN     0      100                  127.0.0.1:25                                       *:*                  
LISTEN     0      128                          *:10050                                    *:*                  
LISTEN     0      128                         :::22                                      :::*                  
LISTEN     0      100                        ::1:25                                      :::*                  
[root@node04 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　查看是否产生了触发器事件？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201119223303611-1945278068.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：可以看到对应的事件已经产生，也执行了邮件发送；&lt;/p&gt;
&lt;p&gt;　　登录对应接收邮件的邮箱，查看是否有收到邮件呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201119223446326-608897131.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：可以看到在对应接收邮件里有一份zab_server@126.com发送过来的邮件，告诉我们说node04上的nginx down掉了；我上面只是配置了触发器从ok到problem状态时发送邮件，从problem到ok状态没有配置发送邮件，生产中可以配置上；&lt;/p&gt;
&lt;p&gt;　　除了以上通过配置媒介的方式使用互联网邮箱发邮件，还可以使用脚本方式发邮件&lt;/p&gt;
&lt;p&gt;　　查看zabbix server存放告警脚本路径&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201119233930066-405092974.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：默认存放告警路径为：/usr/lib/zabbix/alertscripts/目录下&lt;/p&gt;
&lt;p&gt;　　在zabbixserver的/usr/lib/zabbix/alertscripts/目录下创建sendmail.py脚本&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;50&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node03 ~]# cat /usr/lib/zabbix/alertscripts/sendmail.py 
#!/usr/bin/python
#coding:utf-8

import smtplib
from email.mime.text import MIMEText
from email.header import Header
from email.utils import parseaddr,formataddr
import sys

def formatAddr(s):
    name,addr = parseaddr(s)
    return formataddr((Header(name,'utf-8').encode(),addr))

def send_mail(to_list,subject,content):
    mail_host = 'smtp.126.com'
    mail_user = 'zab_server@126.com'
    mail_pass = 'XIAEYNSCRHLYFADN'
    msg = MIMEText(content,'','utf-8')
    msg['Subject'] = Header(subject,'utf-8')
    msg['From'] = formatAddr('zabbix监控&amp;lt;%s&amp;gt;' %mail_user).encode()
    msg['to'] = to_list

    try:
        s = smtplib.SMTP()
        s.connect(mail_host)
        s.login(mail_user,mail_pass)
        s.sendmail(mail_user,to_list,msg.as_string())
        s.close()
        return True
    except Exception,e:
        print str(e)
        return False
if __name__ == &quot;__main__&quot;:
    send_mail(sys.argv[1],sys.argv[2],sys.argv[3])

[root@node03 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：调用此脚本时需要传递三个参数给脚本，第一个参数是接收人的邮件地址，在zabbix中用内建宏{ALERT.SENDTO}表示，第二个参数是邮件标题，内建宏为{ALERT.SUBJECT}；第三个参数是邮件正文，内建宏{ALERT.MESSAGE}；&lt;/p&gt;
&lt;p&gt;　　赋予脚本执行权限&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node03 alertscripts]# chmod +x sendmail.py 
[root@node03 alertscripts]# ll
total 4
-rwxr-xr-x 1 root root 909 Nov 19 23:31 sendmail.py
[root@node03 alertscripts]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　测试：手动传递参数，看看脚本是否能够正常给我们发邮件？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node03 alertscripts]# python sendmail.py 'linux_test01@126.com' 'test' 'this is test mail'
[root@node03 alertscripts]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　登录linux_test01@126.com，看看是否有收到邮件？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201120002650044-525256972.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：在测试邮箱里能够看到我们发送到邮件，说明脚本没有问题；&lt;/p&gt;
&lt;p&gt;　　创建脚本媒介&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201120004430730-1176803026.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：创建媒介类型时，选择script，写上脚本名称和脚本需要传递参数内建宏，然后点击add即可；有关zabbix内建宏的说明请参考官方文档说明&lt;a href=&quot;https://www.zabbix.com/documentation/4.0/manual/appendix/macros/supported_by_location&quot; target=&quot;_blank&quot;&gt;https://www.zabbix.com/documentation/4.0/manual/appendix/macros/supported_by_location&lt;/a&gt;；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201120004552686-1514628048.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　编辑nginx down action，调用脚本来发送邮件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201119234326570-73396078.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　更改admin用户的媒介类型为我们创建的sendmail_script&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201120002932664-439899829.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　测试：停掉node04上的nginx，看看是否会产生触发器事件？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node04 ~]# systemctl stop nginx
[root@node04 ~]# ss -tnl
State      Recv-Q Send-Q           Local Address:Port                          Peer Address:Port              
LISTEN     0      128                          *:22                                       *:*                  
LISTEN     0      100                  127.0.0.1:25                                       *:*                  
LISTEN     0      128                          *:10050                                    *:*                  
LISTEN     0      128                         :::22                                      :::*                  
LISTEN     0      100                        ::1:25                                      :::*                  
[root@node04 ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　查看是否有触发器事件产生？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201120010248578-1030495093.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　查看对应接收邮箱里是否收到邮件呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201120013155567-2059171741.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：这个邮件可能收到会有延迟，如果上面显示已经发送成功，基本上都可以收到；&lt;/p&gt;
&lt;p&gt;　　配置graph&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201120010817821-932552454.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：configuration---&amp;gt; Hosts找到对应主机中的Graphs，点击进去，找到create graph按钮进入graph创建界面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201120011142603-1099369826.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：选择好对应item和其他显示选项，点击add即可；&lt;/p&gt;
&lt;p&gt;　　预览graph&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201120011307295-667234549.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　添加多个item到一个graph中&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201120011428223-1684729762.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　预览&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201120011529935-1316373081.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　添加多个graph为一个screen&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201120011953720-917235431.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：默认点击Monitoring ---&amp;gt;Screens它显示的是zabbix server默认的屏幕，我们需要点击allscreens回到上图位置；点击create screen进入创建屏幕页面；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201120012244346-431721959.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201120012325382-963210901.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　点击创建好的屏幕，编辑screen,添加graph&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201120012449104-537692396.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201120012510649-1737608690.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201120012549128-759303216.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201120012616211-1400800020.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：按照以上示例，添加其他graph到其他位置即可；&lt;/p&gt;
&lt;p&gt;　　预览screen&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201120012800694-1703098446.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　创建slide show &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201120014013608-1197241116.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201120014254926-1852701614.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　预览&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201120014343340-277309398.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201120014918266-1346783976.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　到此，zabbix基础使用就到此结束了！！&lt;/p&gt;
</description>
<pubDate>Thu, 19 Nov 2020 18:00:00 +0000</pubDate>
<dc:creator>Linux-1874</dc:creator>
<og:description>前文我们了解了分布式监控系统zabbix的相关组件的作用和zabbix的部署，回顾请参考https://www.cnblogs.com/qiuhom-1874/p/13997582.html；今天我们</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qiuhom-1874/p/14007342.html</dc:identifier>
</item>
<item>
<title>【Redis】利用 Redis 实现分布式锁 - 周二鸭</title>
<link>http://www.cnblogs.com/jojop/p/14008824.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jojop/p/14008824.html</guid>
<description>&lt;h2 id=&quot;技术背景&quot;&gt;技术背景&lt;/h2&gt;
&lt;p&gt;首先我们需要先来了解下什么是分布式锁，以及为什么需要分布式锁。&lt;/p&gt;
&lt;p&gt;对于这个问题，我们可以简单将锁分为两种——内存级锁以及分布式锁，内存级锁即我们在 Java 中的 synchronized 关键字（或许加上进程级锁修饰更恰当些），而分布式锁则是应用在分布式系统中的一种锁机制。分布式锁的应用场景举例以下几种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;互联网秒杀&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;抢优惠卷&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;接口幂等校验&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们接下来以一段简单的秒杀系统中的判断库存及减库存来描述下为什么需要到分布式锁：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public String deductStock() throws InterruptedException {
    
    // 1.从 Redis 中获取库存值
    int stock = Integer.parseInt(stringRedisTemplate.opsForValue().get(&quot;stock&quot;));
    // 2.判断库存
    if (stock &amp;gt; 0) {
        int readStock = stock - 1;
        // 3.从新设置库存
        stringRedisTemplate.opsForValue().set(&quot;stock&quot;, realStock + &quot;&quot;); 
        System.out.println(&quot;扣减成功，剩余库存：&quot; + readStock + &quot;&quot;);
    } else {
        System.out.println(&quot;扣减失败，库存不足&quot;);
    }
    
    return &quot;end&quot;;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面这段代码中，实现了电商系统中的一个简单小需求，即判断商品的剩余数量是否充足，充足则可以成功卖出商品，并将库存减去 1。我们很容易了解这段代码的目的。接下来我们就来一步一步地分析这段代码的缺陷。&lt;/p&gt;
&lt;h2 id=&quot;基本实现&quot;&gt;基本实现&lt;/h2&gt;
&lt;h3 id=&quot;原子性问题&quot;&gt;原子性问题&lt;/h3&gt;
&lt;p&gt;上面代码中的注释1~3部分，并没有实现原子性的逻辑。所以假设现在如果只剩下一件商品，那么可能会出现以下情况：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;线程 A 运行到代码2，判断库存大于0，进入条件体中将 &lt;code&gt;stock - 1&lt;/code&gt; 赋值给 readStock，在执行代码 3 前停止了下来；&lt;/li&gt;
&lt;li&gt;线程 B 同样运行到代码2，判断出库存大于0（线程A并没有写回Redis），之后并没有停止，而是继续执行到方法结束；&lt;/li&gt;
&lt;li&gt;线程 A 此时恢复执行，执行完代码 3，将库存写回 Redis。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;现在我们就发现了问题，明明只有一件商品，却被两个线程卖出去了两次，这就是没有保证这部分代码的原子性所带来的安全问题。&lt;/p&gt;
&lt;p&gt;那对于这个问题如何解决呢？&lt;/p&gt;
&lt;p&gt;常规的方式自然就是加锁以保证并发安全。那么以我们 Java 自带的锁去保证并发安全，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public Synchronized String deductStock() throws InterruptedException {    
    // 业务逻辑...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们知道 synchronized 和 Lock 支持 JVM 内同一进程内的线程互斥，所以如果我们的项目是单机部署的话，到这里也就能保证这段代码的原子性了。不过以互联网项目来说，为了避免单点故障以及并发量的问题，一般都是以分布式的形式部署的，很少会以单机部署，这种情况就会带来新的问题。&lt;/p&gt;
&lt;h3 id=&quot;分布式问题&quot;&gt;分布式问题&lt;/h3&gt;
&lt;p&gt;刚刚我们将到了如果项目分布式部署的话，那么就会产生新的并发问题。接下来我们以 Nginx 配置负载均衡为例来演示并发问题，同样的请求可能会被分发到多台服务器上，那么我们刚刚所讲的 synchronized 或者 Lock 在此时就失效了。同样的代码，在 A 服务器上确实可以避免其他线程去竞争资源，但是此时 A 服务器上的那段 synchronized 修饰的方法并不能限制 B 服务器上的程序去访问那段代码，所以依旧会产生我们一开始所讲到的线程并发问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1614350/202011/1614350-20201120002833860-2019224698.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么如何解决掉这个问题呢？这个是否就需要 Redis 上场了，Redis 中有一个命令&lt;code&gt;SETNX key value&lt;/code&gt;，&lt;code&gt;SETNX&lt;/code&gt; 是 “SET if not exists” （如果不存在，则 SET）的缩写。那么这条指令只在 &lt;code&gt;key&lt;/code&gt; 不存在的情况下，将键 &lt;code&gt;key&lt;/code&gt; 的值设置为 &lt;code&gt;value&lt;/code&gt;。若键 &lt;code&gt;key&lt;/code&gt; 已经存在，则 &lt;code&gt;SETNX&lt;/code&gt; 命令不做任何动作。&lt;/p&gt;
&lt;p&gt;有了上面命令做支撑，同时我们了解到 Redis 是单线程模型（不要去计较它的网络读写和备份状态下的多线程）。那么我们就可以这么实现，当一个服务器成功的向 Redis 中设置了该命令，那么就认定为该服务器获得了当前的分布式锁，而其他服务器此时就只能一直等待该服务器释放了锁为止。我们来看下代码实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 为了演示方便，这里简单定义了一个常量作为商品的id
public static final String PRODUCT_ID = &quot;100001&quot;;

public String deductStock() throws InterruptedException {

    // 通过 stringRedisTemplate 来调用 Redis 的 SETNX 命令，key 为商品的id，value的值在这不重要
    Boolean result = stringRedisTemplate.opsForValue().setIfAbsent(RODUCT_ID, &quot;jojo&quot;);
    if (!result) {
        return &quot;error&quot;;
    }

    int stock = Integer.parseInt(stringRedisTemplate.opsForValue().get(&quot;stock&quot;));
    if (stock &amp;gt; 0) {
        int readStock = stock - 1;
        stringRedisTemplate.opsForValue().set(&quot;stock&quot;, realStock + &quot;&quot;); 
        System.out.println(&quot;扣减成功，剩余库存：&quot; + readStock + &quot;&quot;);
    } else {
        System.out.println(&quot;扣减失败，库存不足&quot;);
    }

    // 业务执行完成，删除PRODUCT_ID key
    stringRedisTemplate.delete(PRODUCT_ID);
    
    return &quot;end&quot;;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到这里我们就成功地利用 Redis 实现了一把简单的分布式锁，那么这样实现是否就没有问题了呢？&lt;/p&gt;
&lt;h3 id=&quot;锁释放问题&quot;&gt;锁释放问题&lt;/h3&gt;
&lt;p&gt;生产环境比我们想象中要复杂得多，上面代码并不能正真地运用在我们的生产环境中，我们可以试想一下，如果服务器 A 中的程序成功地给线程加锁，并且执行完了减库存的逻辑，但是最终却没有安全地运行&lt;code&gt;stringRedisTemplate.delete(PRODUCT_ID)&lt;/code&gt;这行代码，也就是没有成功释放锁，那其他服务器就永远无法拿到 Redis 中的分布式锁了，也就会陷入死锁的状态。&lt;/p&gt;
&lt;p&gt;解决这个方法，可能许多人都会想到想到——&lt;code&gt;try-finally&lt;/code&gt;语句块，像下面代码这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public String deductStock() throws InterruptedException {

    Boolean result = stringRedisTemplate.opsForValue().setIfAbsent(RODUCT_ID, &quot;jojo&quot;);
    if (!result) {
        return &quot;error&quot;;
    }

    try {
        int stock = Integer.parseInt(stringRedisTemplate.opsForValue().get(&quot;stock&quot;));
        if (stock &amp;gt; 0) {
            int readStock = stock - 1;
            stringRedisTemplate.opsForValue().set(&quot;stock&quot;, realStock + &quot;&quot;); 
            System.out.println(&quot;扣减成功，剩余库存：&quot; + readStock + &quot;&quot;);
        } else {
            System.out.println(&quot;扣减失败，库存不足&quot;);
        }
    } finally {
        //业务执行完成，删除PRODUCT_ID key
        stringRedisTemplate.delete(PRODUCT_ID);
    }

    return &quot;end&quot;;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是上面代码是否正真解决问题了呢？单看代码本身是没什么问题的，但是前面提到，生产环境是非常复杂的。我们假设这种情况：当线程在成功加锁之后，执行业务代码时，还没来得及删除 Redis 中的锁标志，此时，这台服务器宕机了，程序并没有想我们想象中地去执行 finally 块中的代码。这种情况也会使得其他服务器或者进程在后续过程中无法去获取到锁，从而导致死锁，最终导致业务崩溃的情况。所以说，对于锁释放问题来说，&lt;code&gt;try-finally&lt;/code&gt; 语句块在这里还不够，那么我们就需要新的方法来解决这个问题了。&lt;/p&gt;
&lt;h3 id=&quot;redis-超时机制&quot;&gt;Redis 超时机制&lt;/h3&gt;
&lt;p&gt;Redis 中允许我们设置缓存的自动过期时间，我们可以将其引入我们上面的锁机制中，这样就算 finally 语句块中的释放语句没有被正确执行，Redis 中的缓存也能在设定时间内自动过期，不会形成死锁：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 设置过期时间
stringRedisTemplate.expire(lockKey, 10, TimeUnit.SECONDS);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然如果只是简单的在代码中加入上述语句的话，还是有可能产生死锁的，因为加锁以及设置过期时间是分开来执行的，并不能保证原子性。所以为了解决这个问题，Redis 中也提供了将设置值与设置过期时间合一的操作，对于 Java 代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 将设置值与设置过期时间合一
stringRedisTemplate.opsForValue().opsForValue().setIfAbsent(lockKey, &quot;jojo&quot;, 10, TimeUnit.SECONDS);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到这一步，我们可以确保 Redis 中我们上的锁，最终无论如何都能成功地被释放掉，避免了造成死锁的情况。但是以当前的代码实现来看，在一些高并发场景下还是可能产生锁失效的情况。我们可以试想一下，上面代码我们设置的过期时间为 10s，那么如果这个进程在 10s 内并没有完成这段业务逻辑，会产生什么样的情况？不过在此之前我们先将代码的公共部分抽出作一个组件类，这样有助于我们关注锁的逻辑。&lt;/p&gt;
&lt;h2 id=&quot;代码集成&quot;&gt;代码集成&lt;/h2&gt;
&lt;h3 id=&quot;公共方法的提取&quot;&gt;公共方法的提取&lt;/h3&gt;
&lt;p&gt;我们这里先定义一个 &lt;code&gt;RedisLock&lt;/code&gt; 接口，代码如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface RedisLock {
    /**
     * 尝试加锁
     */
    boolean tryLock(String key, long timeout, TimeUnit unit);
    
    /**
     * 解锁操作
     */
    void releaseLock(String key);
    
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来，我们基于上面已经实现的分布式锁的思路，来实现这个接口，代码如果所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class RedisLockImpl implements RedisLock {
    
    @Autowired
    private StringRedisTemplate stringRedisTemplate;
    
    @Override
    public boolean tryLock(String key, long timeout, TimeUnit unit) {
        return stringRedisTemplate.opsForValue().setIfAbsent(key, &quot;jojo&quot;, timeout, unit);
    }
    
    @Override
    public void releaseLock(String key) {
        stringRedisTemplate.delete(key);
    }
    
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;加锁解锁的归一化&quot;&gt;加锁&amp;amp;解锁的归一化&lt;/h3&gt;
&lt;p&gt;我们先来继续分析上面代码。从开发的角度来说，当一个线程从上到下执行一个需要加分布式锁的业务时，它首先需要进行加锁操作，当业务执行完毕后，再进行释放锁的操作。也就是先调用 &lt;code&gt;tryLock()&lt;/code&gt; 函数再调用 &lt;code&gt;releaseLock()&lt;/code&gt; 函数。&lt;/p&gt;
&lt;p&gt;但是真正可靠代码并不依靠人性，其他开发人员有可能在编写代码的时候并没有调用 &lt;code&gt;tryLock()&lt;/code&gt; 方法，而是直接调用了 &lt;code&gt;releaseLock()&lt;/code&gt; 方法，并且可能在调用 &lt;code&gt;releaseLock()&lt;/code&gt; 时传入的 Key 值与你调用 &lt;code&gt;tryLock()&lt;/code&gt; 时传入的 Key 值是相同的，那么此时就可能出现问题：另一段代码在运行时，硬生生将你代码中加的锁给释放掉了，那么此时的锁就失效了。所以上述代码依旧是有不可靠的地方，锁的可能误删操作会使得程序存在很严重的问题。&lt;/p&gt;
&lt;p&gt;那么针对这一问题，我们就需要实现加锁&amp;amp;解锁的归一化。&lt;/p&gt;
&lt;p&gt;首先我们解释一下什么叫做加锁和解锁的归一化，简单来说，就是一个线程执行了加锁操作后，后续的解锁操作只能由该线程来执行，即加锁操作和解锁只能由同一线程来进行。&lt;/p&gt;
&lt;p&gt;这里我们使用 ThreadLocal 和 UUID 来实现，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class RedisLockImpl implements RedisLock {
    
    @Autowired
    private StringRedisTemplate stringRedisTemplate;
    
    private ThreadLock&amp;lt;string&amp;gt; threadLock = new ThreadLock&amp;lt;&amp;gt;();
    
    @Override
    public boolean tryLock(String key, long timeout, TimeUnit unit) {
        String uuid = UUID.randomUUID().toString();
        threadlocal.set(uuid);
        return stringRedisTemplate.opsForValue().setIfAbsent(key, uuid, timeout, unit);
    }
    
    @Override
    public void releaseLock(String key) {
        if (threadLocal.get().equals(stringRedisTemplate.opsForValue().get(key))) {
            stringRedisTemplate.delete(key);
        }
    }
    
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;可重入发布式锁实现&quot;&gt;可重入发布式锁实现&lt;/h3&gt;
&lt;p&gt;上面的代码实现，可以保证当一个线程成功在 Redis 中设置了锁标志位后，其他线程再设置锁标志位时，返回 false。但是在一些场景下我们需要实现线程的重入，即相同的线程能够多次获取同一把锁，不需要等待锁释放后再去加锁。所以我们需要利用一些方式来实现分布式锁的可重入型，在 JDK 1.6 之后提供的内存级锁很多都支持可重入型，比如 synchronized 和 J.U.C 下的 Lock，其本质都是一样的，比对已经获得锁的线程是否与当前线程相同，是则重入，当释放锁时则需要根据重入的次数，来判断此时锁是否真正释放掉了。那么我们就按照这个思路来实现一个可重入的分布式锁：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class RedisLockImpl implements RedisLock {
    
    @Autowired
    private StringRedisTemplate stringRedisTemplate;
    
    private ThreadLocal&amp;lt;String&amp;gt; threadLocal = new ThreadLocal&amp;lt;String&amp;gt;();
    
    private ThreadLocal&amp;lt;Integer&amp;gt; threadLocalInteger = new ThreadLocal&amp;lt;Integer&amp;gt;();
    
    @Override
    public boolean tryLock(String key, long timeout, TimeUnit unit) {
        Boolean isLocked = false;
        if (threadLocal.get() == null) {
            String uuid = UUID.randomUUID().toString();
            threadLocal.set(uuid);
            isLocked = stringRedisTemplate.opsForValue().setIfAbsent(key, uuid, timeout, unit);
        } else {
            isLocked = true;
        }
        
        // 重入次数加1
        if (isLocked) {
            Integer count = threadLocalInteger.get() == null ? 0 : threadLocalInteger.get();
            threadLocalInteger.set(count++);
        }
        
        return isLocked;
    }
    
    @Override
    public void releaseLock(String key) {
        // 判断当前线程所对应的uuid是否与Redis对应的uuid相同，再执行删除锁操作
        if (threadLocal.get().equals(stringRedisTemplate.opsForValue().get(key))) {
            Integer count = threadLocalInteger.get();
            // 计数器减为0时才能释放锁
            if (count == null || --count &amp;lt;= 0) {
                stringRedisTemplate.delete(key);
            }
        }
    }
    
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;分布式自旋锁实现&quot;&gt;分布式自旋锁实现&lt;/h3&gt;
&lt;p&gt;上面代码实现中，加入我们不能一次性获取到锁，那么就会直接返回失败，这对业务来说是十分不友好的，假设用户此时下单，刚好有另外一个用户也在下单，而且获取到了锁资源，那么该用户尝试获取锁之后失败，就只能直接返回“下单失败”的提示信息的。所以我们需要实现以自旋的形式来获取到锁，即不停的重试，基于这个想法，实现代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class RedisLockImpl implements RedisLock {
    
    @Autowired
    private StringRedisTemplate stringRedisTemplate;
    
    private ThreadLocal&amp;lt;String&amp;gt; threadLocal = new ThreadLocal&amp;lt;&amp;gt;();
    
    private ThreadLocal&amp;lt;Integer&amp;gt; threadLocalInteger = new ThreadLocal&amp;lt;&amp;gt;();
    
    @Override
    public boolean tryLock(String key, long timeout, TimeUnit unit) {
        Boolean isLocked = false;
        
        if (threadLocal.get() == null) {
            String uuid = UUID.randomUUID().toString();
            threadLocal.set(uuid);
            isLocked = stringRedisTemplate.opsForValue().setIfAbsent(key, uuid, timeout, unit);
            // 尝试获取锁失败，则自旋获取锁直至成功
            if (!isLocked) {
                for (;;) {
                    isLocked = stringRedisTemplate.opsForValue().setIfAbsent(key, uuid, timeout, unit);
                    if (isLocked) {
                        break;
                    }
                }
            }
        } else {
            isLocked = true;
        }
        // 重入次数加1
        if (isLocked) {
            Integer count = threadLocalInteger.get() == null ? 0 : threadLocalIntger.get();
            threadLocalInteger.set(count++);
        }
        
        return isLocked;
    }
    
    @Override
    public void releaseLock(String key) {
        // 判断当前线程所对应的uuid是否与Redis对应的uuid相同，再执行删除锁操作
        if (threadLocal.get().equals(stringRedisTemplate.opsForValue().get(key))) {
            Integer count = threadLocalInteger.get();
            // 计数器减为0时才能释放锁
            if (count == null || --count &amp;lt;= 0) {
                stringRedisTemplate.delete(key);
            }
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;基础优化&quot;&gt;基础优化&lt;/h2&gt;
&lt;h3 id=&quot;超时问题&quot;&gt;超时问题&lt;/h3&gt;
&lt;p&gt;在高并发场景下，一把锁可能会被 N 多的进程竞争，获取锁后的业务代码也可能十分复杂，其运行时间可能偶尔会超过我们设置的过期时间，那么这个时候锁就会自动释放，而其他的进程就有可能来争抢这把锁，而此时原来获得锁的进程也在同时运行，这就有可能导致超卖现象或者其他并发安全问题。&lt;/p&gt;
&lt;p&gt;那么如何解决这个问题呢？思路很简单，就是每隔一段时间去检查当前线程是否还在运行，如果还在运行，那么就继续更新锁的占有时长，而在释放锁的时候。具体的实现稍微复杂些，这里给出简易的代码实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class RedisLockImpl implements RedisLock {
    
    @Autowired
    private StringRedisTemplate stringRedisTemplate;
    
    private ThreadLocal&amp;lt;String&amp;gt; threadLocal = new ThreadLocal&amp;lt;&amp;gt;();
    
    private ThreadLocal&amp;lt;Integer&amp;gt; threadLocalInteger = new ThreadLocal&amp;lt;&amp;gt;();
    
    @Override
    public boolean tryLock(String key, long timeout, TimeUnit unit) {
        Boolean isLocked = false;
        if (threadLocal.get() == null) {
            String uuid = UUID.randomUUID().toString();
            threadLocal.set(uuid);
            isLocked = stringRedisTemplate.opsForValue().setIfAbsent(key, uuid, timeout, unit);
            // 尝试获取锁失败，则自旋获取锁直至成功
            if (!isLocked) {
                for (;;) {
                    isLocked = stringRedisTemplate.opsForValue().setIfAbsent(key, uuid, timeout, unit);
                    if (isLocked) {
                        break;
                    }
                }
            }
            // 启动新的线程来定期检查当前线程是否执行完成，并更新过期时间
            new Thread(new UpdateLockTimeoutTask(uuid, stringRedisTemplate, key)).start();
        } else {
            isLocked = true;
        }
        // 重入次数加1
        if (isLocked) {
            Integer count = threadLocalInteger.get() == null ? 0 :threadLocalInteger.get();
            threadLocalInteger.set(count++);
        }
        
        return isLocked;
    }
    
    @Override
    public void releaseLock(String key) {
        // 判断当前线程所对应的uuid是否与Redis对应的uuid相同，再执行删除锁操作
        if (threadLocal.get().equals(stringRedisTemplate.opsForValue().get(key))) {
            Integer count = threadLocalInteger.get();
            // 计数器减为0时才能释放锁
            if (count == null || --count &amp;lt;= 0) {
                stringRedisTemplate.delete(key);
                // 获取更新锁超时时间的线程并中断
                long threadId = stringRedisTemplate.opsForValue().get(uuid);
                Thread updateLockTimeoutThread = ThreadUtils.getThreadByThreadId(threadId);
                if (updateLockTimeoutThread != null) {
                    // 中断更新锁超时时间的线程
                    updateLockTimeoutThread.interrupt();
                    stringRedisTemplate.delete(uuid);
                }
            }
        }
    }
    
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来我们就创建 &lt;code&gt;UpdateLockTimeoutTask&lt;/code&gt; 类来执行更新锁超时的时间。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class UpdateLockTimeoutTask implements Runnable {
    
    private long uuid;
    private String key;
    private StringRedisTemplate stringRedisTemplate;
    
    public UpdateLockTimeoutTask(long uuid, StringRedisTemplate stringRedisTemplate, String key) {
        this.uuid = uuid;
        this.key = key;
        this.stringRedisTemplate = stringRedisTemplate;
    }
    
    @Override
    public void run() {
        // 将以uuid为Key，当前线程Id为Value的键值对保存到Redis中
        stringRedisTemplate.opsForValue().set(uuid, Thread.currentThread().getId());
        // 定期更新锁的过期时间
        while (true) {
            stringRedisTemplate.expire(key, 10, TimeUnit.SECONDS);
            try{
                // 每隔3秒执行一次
                Thread.sleep(10000);
            }catch (InterruptedException e){
                e.printStackTrace();
            }
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后，我们定义一个 &lt;code&gt;ThreadUtils&lt;/code&gt; 工具类，这个工具类中我们定义一个根据线程 id 获取线程的方法 &lt;code&gt;getThreadByThreadId(long threadId)&lt;/code&gt;，代码如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class ThreadUtils {
    
    // 根据线程 id 获取线程句柄
    public static Thread getThreadByThreadId(long threadId) {
        ThreadGroup group = Thread.currentThread().getThreadGroup();
        while(group != null){
            Thread[] threads = new Thread[(int)(group.activeCount() * 1.2)];
            int count = group.enumerate(threads, true);
            for (int i = 0; i &amp;lt; count; i++){
                if (threadId == threads[i].getId()) {
                    return threads[i];
                }
            }
        }
    }
    
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述解决分布式锁失效的方案在分布式锁领域有一个专业的术语叫做 &lt;strong&gt;“异步续命”&lt;/strong&gt; 。需要注意的是：当业务代码执行完毕后，我们需要停止更新锁超时时间的线程。所以，这里，我对程序的改动是比较大的，首先，将更新锁超时的时间任务重新定义为一个 &lt;code&gt;UpdateLockTimeoutTask&lt;/code&gt; 类，并将 &lt;code&gt;uuid&lt;/code&gt; 和&lt;code&gt;StringRedisTemplate&lt;/code&gt; 注入到任务类中，在执行定时更新锁超时时间时，首先将当前线程保存到Redis中，其中Key为传递进来的 &lt;code&gt;uuid&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;高并发&quot;&gt;高并发&lt;/h3&gt;
&lt;blockquote readability=&quot;1.6438356164384&quot;&gt;
&lt;p&gt;以下部分引用自：&lt;a href=&quot;https://www.cnblogs.com/binghe001/p/12778853.html&quot;&gt;https://www.cnblogs.com/binghe001/p/12778853.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果我们系统中利用 Redis 来实现分布式锁，而 Redis 的读写并发量约合 5 万左右。假设现在一个秒杀业务需要支持的并发量超过百万级别，那么如果这 100万的并发全部打入 Redis 中去请求锁资源，Redis 将会直接挂掉。所以我们现在应该来考虑如何解决这个问题，即如何在高并发的环境下保证 Redis 实现的分布式锁的可用性，接下来我们就来考虑一下这个问题。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;在高并发的商城系统中，如果采用 Redis 缓存数据，则 Redis 缓存的并发能力是关键，因为很多的前缀操作都需要访问 Redis。而异步削峰只是基本操作，关键还是要保证 Redis 的并发处理能力。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;解决这个问题的关键思想就是：分而治之，将商品库存分开放。&lt;/p&gt;
&lt;p&gt;我们在 Redis 中存储商品的库存数量时，可以将商品的库存进行“分割”存储来提升 Redis 的读写并发量。&lt;/p&gt;
&lt;p&gt;例如，原来的商品的 id 为 10001，库存为1000件，在Redis中的存储为(10001, 1000)，我们将原有的库存分割为5份，则每份的库存为200件，此时，我们在Redis 中存储的信息为(10001_0, 200)，(10001_1, 200)，(10001_2, 200)，(10001_3, 200)，(10001_4, 200)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1614350/202011/1614350-20201120002921521-1232725166.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时，我们将库存进行分割后，每个分割的库存使用商品 id 加上一个数字标识来存储，这样，在对存储商品库存的每个 key 进行 Hash 运算时，得出的 Hash 结果是不同的，这就说明，存储商品库存的 Key 有很大概率不在 Redis 的同一个槽位中，这就能够提升 Redis 处理请求的性能和并发量。&lt;/p&gt;
&lt;p&gt;分割库存后，我们还需要在 Redis 中存储一份商品 ID 和 分割库存后的 Key 的映射关系，此时映射关系的 Key 为商品的 ID，也就是 10001，Value 为分割库存后存储库信息的 Key，也就是 10001_0，10001_1，10001_2，10001_3，10001_4。在 Redis 中我们可以使用 List 来存储这些值。&lt;/p&gt;
&lt;p&gt;在真正处理库存信息时，我们可以先从 Redis 中查询出商品对应的分割库存后的所有 Key，同时使用 AtomicLong 来记录当前的请求数量，使用请求数量对从Redis 中查询出的商品对应的分割库存后的所有Key的长度进行求模运算，得出的结果为0，1，2，3，4。再在前面拼接上商品id就可以得出真正的库存缓存的Key。此时，就可以根据这个Key直接到Redis中获取相应的库存信息。&lt;/p&gt;
&lt;p&gt;同时，我们可以将分隔的不同的库存数据分别存储到不同的 Redis 服务器中，进一步提升 Redis 的并发量。&lt;/p&gt;
&lt;h2 id=&quot;基础升级&quot;&gt;基础升级&lt;/h2&gt;
&lt;h3 id=&quot;移花接木&quot;&gt;移花接木&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;在高并发业务场景中，我们可以直接使用 Lua 脚本库（OpenResty）从负载均衡层直接访问缓存。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里，我们思考一个场景：如果在高并发业务场景中，商品被瞬间抢购一空。此时，用户再发起请求时，如果系统由负载均衡层请求应用层的各个服务，再由应用层的各个服务访问缓存和数据库，其实，本质上已经没有任何意义了，因为商品已经卖完了，再通过系统的应用层进行层层校验已经没有太多意义了！而应用层的并发访问量是以百为单位的，这又在一定程度上会降低系统的并发度。&lt;/p&gt;
&lt;p&gt;为了解决这个问题，此时，我们可以在系统的负载均衡层取出用户发送请求时携带的用户Id，商品id和活动Id等信息，直接通过 Lua 脚本等技术来访问缓存中的库存信息。如果商品的库存小于或者等于 0，则直接返回商品已售完的提示信息，而不用再经过应用层的层层校验了。&lt;/p&gt;
&lt;h3 id=&quot;数据同步&quot;&gt;数据同步&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1614350/202011/1614350-20201120002939366-560252613.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;假设我们使用 Redis 来实现分布式锁，我们知道 Redis 是基于 CAP 中 AP 来实现的，那么就可能存在数据未同步的问题。具体的场景就是，我在 Redis 的 Master 上设置了锁标志，然而在 Redis 的主从节点上还未完全同步之时，Redis 主节点宕机了，那么此时从节点上就没有锁标志，从而导致并发安全问题。对于这个问题，常见的解法有两种，基于 Zookeeper 来实现分布式锁（废话），而另外一种就是 RedLock 了。&lt;/p&gt;
&lt;p&gt;Redlock 同很多的分布式算法一样，也使用“大多数机制”。加锁时，它会向过半节点发送 &lt;code&gt;set(key, value, nx=True, ex=xxx)&lt;/code&gt; 指令，只要过半节点 set 成功，就认为加锁成功。释放锁时，需要向所有节点发送 del 指令。不过 Redlock 算法还需要考虑出错重试、时钟漂移等很多细节，同时因为 RedLock 需要向多个节点进行读写，意味着其相比单实例 Redis 的性能会下降一些。&lt;/p&gt;
&lt;p&gt;如果你很在乎高可用性，希望即使挂了一台 Redis 也完全不受影响，就应该考虑 Redlock。不过代价也是有的，需要更多的 Redis 实例，性能也下降了，代码上还需要引入额外的 library，运维上也需要特殊对待，这些都是需要考虑的成本。&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;《Redis深度历险-核心原理与应用实践》- 钱文品&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Thu, 19 Nov 2020 16:30:00 +0000</pubDate>
<dc:creator>周二鸭</dc:creator>
<og:description>技术背景 首先我们需要先来了解下什么是分布式锁，以及为什么需要分布式锁。 对于这个问题，我们可以简单将锁分为两种——内存级锁以及分布式锁，内存级锁即我们在 Java 中的 synchronized 关</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jojop/p/14008824.html</dc:identifier>
</item>
<item>
<title>Java学习之AWT GUI编程 - nice_0e3</title>
<link>http://www.cnblogs.com/nice0e3/p/14008800.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nice0e3/p/14008800.html</guid>
<description>&lt;h2 id=&quot;0x00-前言&quot;&gt;0x00 前言&lt;/h2&gt;
&lt;p&gt;既然前面提到了要重写冰蝎和一些反序列化工具，当然就不能随便说说而已。在编写这些工具还是要使用图形化工具来的方便一些，所以提前把GUI的框架给学习一遍。&lt;/p&gt;
&lt;p&gt;其实重写webshell工具这个也就是实现部分，现在就差个gui框架。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202011/1993669-20201120001520276-1989281962.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里其实是已经完善了单向加密和双向加密的功能，并且服务端aes动态密钥加密也写好了，且可以定义128和256位aes的加密。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202011/1993669-20201120001529387-1765054782.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202011/1993669-20201120001547685-1419420377.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/nice0e3/p/13998892.html&quot;&gt;Java安全之JSP动静态免杀思路实现与服务端编写&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;0x01-awt概述&quot;&gt;0x01 AWT概述&lt;/h2&gt;
&lt;p&gt;当 JDK 1.0发布时， Sun 提供了 一套基本的GUI类库，这个GUI类库希望可以在所有平台下都能运行 ， 这套基本类库被称为&quot;抽象窗口工具集 CAbstract Window Toolkit )&quot;，它为Java应用程序提供了基本的图形组件 。 AWT是窗口框架，它从不同平台的窗口系统中抽取出共同组件 ， 当程序运行时，将这些组件的创建和动作委托给程序所在的运行平台 。 简而言之 ，当使用 AWT 编写图形界面应用 时， 程序仅指定了界面组件的位置和行为，并未提供真正的实现，JVM调用操作系统本地的图形界面来创建和平台 一致的对等体 。&lt;/p&gt;
&lt;p&gt;​ 使用AWT创建的图形界面应用和所在的运行平台有相同的界面风格 ， 比如在 Windows 操作系统上，它就表现出 Windows 风格 ; 在 UNIX 操作系统上，它就表现出UNIX 风格 。 Sun 希望采用这种方式来实现 &quot; Write Once, Run Anywhere &quot;（一次编写多次运行） 的目标 。&lt;/p&gt;
&lt;h2 id=&quot;0x02--awt体系&quot;&gt;0x02 AWT体系&lt;/h2&gt;
&lt;p&gt;所有和 AWT 编程相关的类都放在 java.awt 包以及它的子包中， AWT 编程中有两个基类 :Component和 MenuComponent。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Component：代表一个能以图形化方式显示出来，并可与用户交互的对象，例如 Button 代表一个按钮，TextField 代表 一个文本框等；

MenuComponent：则代表图形界面的菜单组件，包括 MenuBar (菜单条)、 Menultem (菜单项)等子类。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202011/1993669-20201120001602176-865315983.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;多的体系什么的就不看了，主要是实用为主。&lt;/p&gt;
&lt;h2 id=&quot;0x03-awt代码实现&quot;&gt;0x03 AWT代码实现&lt;/h2&gt;
&lt;h3 id=&quot;frame&quot;&gt;Frame&lt;/h3&gt;
&lt;h4 id=&quot;第一个gui界面&quot;&gt;第一个GUI界面&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.test;

import java.awt.*;

public class test {
    public static void main(String[] args) {
        Frame frame = new Frame(&quot;nwebshell&quot;);
        frame.setVisible(true);
        frame.setSize(400,400);
        frame.setLocation(500,500);
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202011/1993669-20201120001612875-805438250.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;panel面板&quot;&gt;Panel面板&lt;/h3&gt;
&lt;p&gt;Panel可以看成是一个面板，简单来说就是一个容器。&lt;/p&gt;
&lt;h4 id=&quot;代码实例：&quot;&gt;代码实例：&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.test;

import javax.swing.*;
import java.awt.*;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;

public class test {
    public static void main(String[] args) {
        Frame frame = new Frame(&quot;nwebshell&quot;);
        //设置布局
        frame.setLayout(null);
        //窗口可见
        frame.setVisible(true);
        //设置坐标
        frame.setBounds(300,300,500,500);

        Panel panel = new Panel();
        //设置panel坐标，相对于frame
        panel.setBounds(50,50,400,400);
        panel.setBackground(new Color(219, 185, 185));
        frame.add(panel);
        //
        frame.addWindowListener(new WindowAdapter() {
            @Override
            public void windowClosing(WindowEvent e) {
                //结束程序
                System.exit(0);
            }
        });



    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202011/1993669-20201120001623396-866172505.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;布局管理器&quot;&gt;布局管理器&lt;/h3&gt;
&lt;h4 id=&quot;流式布局&quot;&gt;流式布局&lt;/h4&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.test;

import javax.swing.*;
import java.awt.*;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;

public class test {
    public static void main(String[] args) {
        Frame frame = new Frame(&quot;nwebshell&quot;);
        Button button1 = new Button(&quot;submit&quot;);
        Button button2 = new Button(&quot;submit&quot;);
        Button button3 = new Button(&quot;submit&quot;);

        frame.setSize(500,500);
        //设置布局
        frame.setLayout(null);
        //窗口可见
        frame.setVisible(true);

        //设置流式布局
        frame.setLayout(new FlowLayout(FlowLayout.RIGHT));


        //添加按钮
        frame.add(button1);
        frame.add(button2);
        frame.add(button3);






    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202011/1993669-20201120001634941-379862727.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;东西南北中布局&quot;&gt;东西南北中布局&lt;/h4&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.test;

import javax.swing.*;
import java.awt.*;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;

public class test {
    public static void main(String[] args) {
        Frame frame = new Frame(&quot;nwebshell&quot;);
        Button button1 = new Button(&quot;submit&quot;);
        Button button2 = new Button(&quot;submit&quot;);
        Button button3 = new Button(&quot;submit&quot;);
        Button button4 = new Button(&quot;submit&quot;);
        Button button5 = new Button(&quot;submit&quot;);

        frame.setSize(500,500);



        //添加按钮
        frame.add(button1,BorderLayout.EAST);
        frame.add(button2,BorderLayout.WEST);
        frame.add(button3,BorderLayout.SOUTH);
        frame.add(button4,BorderLayout.NORTH);
        frame.add(button5,BorderLayout.CENTER);
        frame.setVisible(true);







    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202011/1993669-20201120001646601-1902303013.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;表格布局&quot;&gt;表格布局&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.test;

import javax.swing.*;
import java.awt.*;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;

public class test {
    public static void main(String[] args) {
        Frame frame = new Frame(&quot;nwebshell&quot;);
        Button button1 = new Button(&quot;submit&quot;);
        Button button2 = new Button(&quot;submit&quot;);
        Button button3 = new Button(&quot;submit&quot;);
        Button button4 = new Button(&quot;submit&quot;);
        Button button5 = new Button(&quot;submit&quot;);

        frame.setSize(500,500);


//设置表格布局
        frame.setLayout(new GridLayout(3,2));
        frame.add(button1);
        frame.add(button2);
        frame.add(button3);
        frame.add(button4);
        frame.add(button5);
        //自动布局
        frame.pack();
        frame.setVisible(true);






    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202011/1993669-20201120001656142-1078989728.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;文本框&quot;&gt;文本框&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.test;

import javax.swing.*;
import java.awt.*;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;

public class test {
    public static void main(String[] args) {
        Frame frame = new Frame(&quot;nwebshell&quot;);
        Panel panel=new Panel();
        Button button = new Button(&quot;submit&quot;);
        TextField textField = new TextField();
        textField.setText(&quot;普通文本框&quot;);
        textField.setVisible(true);
        frame.setVisible(true);
        frame.setSize(500,500);
        panel.add(button);
        panel.add(textField);

        frame.add(panel);



    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202011/1993669-20201120001707167-1660489636.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;常用组件&quot;&gt;常用组件&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;组件名&lt;/th&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;9.5&quot;&gt;&lt;tr&gt;&lt;td&gt;Button&lt;/td&gt;
&lt;td&gt;Button&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Canvas&lt;/td&gt;
&lt;td&gt;用于绘图的画布&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Checkbox&lt;/td&gt;
&lt;td&gt;复选框组件（也可当做单选框组件使用）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;CheckboxGroup&lt;/td&gt;
&lt;td&gt;用于将多个Checkbox 组件组合成一组， 一组 Checkbox 组件将只有一个可以 被选中 ， 即全部变成单选框组件&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Choice&lt;/td&gt;
&lt;td&gt;下拉选择框&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Frame&lt;/td&gt;
&lt;td&gt;窗口 ， 在 GUI 程序里通过该类创建窗口&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Label&lt;/td&gt;
&lt;td&gt;标签类，用于放置提示性文本&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;List&lt;/td&gt;
&lt;td&gt;JU表框组件，可以添加多项条目&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Panel&lt;/td&gt;
&lt;td&gt;不能单独存在基本容器类，必须放到其他容器中&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;Scrollbar&lt;/td&gt;
&lt;td&gt;滑动条组件。如果需要用户输入位于某个范围的值 ， 就可以使用滑动条组件 ，比如调 色板中设置 RGB 的三个值所用的滑动条。当创建一个滑动条时，必须指定它的方向、初始值、 滑块的大小、最小值和最大值。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;ScrollPane&lt;/td&gt;
&lt;td&gt;带水平及垂直滚动条的容器组件&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;TextArea&lt;/td&gt;
&lt;td&gt;多行文本域&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;TextField&lt;/td&gt;
&lt;td&gt;单行文本框&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;对话框-dialog&quot;&gt;对话框 Dialog&lt;/h4&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;方法名称&lt;/th&gt;
&lt;th&gt;方法功能&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3.5&quot;&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td&gt;Dialog(Frame owner, String title, boolean modal)&lt;/td&gt;
&lt;td&gt;创建一个对话框对象：&lt;br/&gt;owner:当前对话框的父窗口&lt;br/&gt;title:当前对话框的标题&lt;br/&gt;modal：当前对话框是否是模式对话框，true/false&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.test;


import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;

public class test {
    public static void main(String[] args) {
        Frame frame = new Frame(&quot;nwebshell&quot;);

        final Dialog d1 = new Dialog(frame, &quot;command&quot;, true);
        final Dialog d2 = new Dialog(frame, &quot;connection&quot;, true);
//        往对话框中添加内容
        Box vBox = Box.createVerticalBox();
        vBox.add(new TextField(15));
        vBox.add(new Button(&quot;submit&quot;));
        d1.add(vBox);
//        设置对话框大小
        Button b1 = new Button(&quot;open&quot;);
        Button b2 = new Button(&quot;close&quot;);
//        给b1按钮绑定事件
        d1.setBounds(20,30,300,100);
        d2.setBounds(20,30,300,400);

        b1.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                d1.setVisible(true);
            }
        });
        b2.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                d2.setVisible(true);
            }
        });
        //把按钮添加到frame中
        frame.add(b1);
        frame.add(b2,BorderLayout.SOUTH);
        //设置frame最佳大小并可见
        frame.pack();
        frame.setVisible(true);
        frame.setSize(1024,700);




    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202011/1993669-20201120001725146-44532713.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202011/1993669-20201120001734922-553249788.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;filedialog&quot;&gt;FileDialog&lt;/h4&gt;
&lt;p&gt;Dialog 类还有 一个子类 : FileDialog ，它代表一个文件对话框，用于打开或者保存 文件,需要注意的是FileDialog无法指定模态或者非模态，这是因为 FileDialog 依赖于运行平台的实现，如果运行平台的文件对话框是模态的，那么 FileDialog 也是模态的;否则就是非模态的 。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;方法名称&lt;/th&gt;
&lt;th&gt;方法功能&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;6.5&quot;&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td&gt;FileDialog(Frame parent, String title, int mode)&lt;/td&gt;
&lt;td&gt;创建一个文件对话框：&lt;br/&gt;parent:指定父窗口&lt;br/&gt;title:对话框标题&lt;br/&gt;mode:文件对话框类型，如果指定为FileDialog.load，用于打开文件，如果指定为FileDialog.SAVE,用于保存文件&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;String getDirectory()&lt;/td&gt;
&lt;td&gt;获取被打开或保存文件的绝对路径&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;String getFile()&lt;/td&gt;
&lt;td&gt;获取被打开或保存文件的文件名&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.test;


import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;

public class test {
    public static void main(String[] args) {
        Frame frame = new Frame(&quot;nwebshell&quot;);
//        加载文件
        final FileDialog load_file = new FileDialog(frame, &quot;load_file&quot;, FileDialog.LOAD);
        final FileDialog save_file = new FileDialog(frame, &quot;save_file&quot;, FileDialog.SAVE);
        Button open_file_b = new Button(&quot;open_file&quot;);
        Button save_file_b = new Button(&quot;save_file&quot;);
        //给按钮添加事件

        open_file_b.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                load_file.setVisible(true);
//                打印用户选择的文件路径和名称
                System.out.println(load_file.getDirectory());
                System.out.println(load_file.getFile());

            }
        });
        save_file_b.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                System.out.println(save_file.getDirectory());
                System.out.println(save_file.getFile());

            }
        });
//        配置完按钮事件，将按钮添加到frame中
        frame.add(open_file_b);
        frame.add(save_file_b,BorderLayout.SOUTH);
        frame.pack();
        frame.setVisible(true);

    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202011/1993669-20201120001750285-2048170869.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;事件监听器&quot;&gt;事件监听器&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;定义：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​ 当在某个组件上发生某些操作的时候，会自动的触发一段代码的执行。&lt;/p&gt;
&lt;p&gt;在GUI事件处理机制中涉及到4个重要的概念需要理解：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;事件源(Event Source)&lt;/strong&gt;：操作发生的场所，通常指某个组件，例如按钮、窗口等；&lt;br/&gt;&lt;strong&gt;事件（Event）&lt;/strong&gt;：在事件源上发生的操作可以叫做事件，GUI会把事件都封装到一个Event对象中，如果需要知道该事件的详细信息，就可以通过Event对象来获取。&lt;br/&gt;&lt;strong&gt;事件监听器(Event Listener)&lt;/strong&gt;:当在某个事件源上发生了某个事件，事件监听器就可以对这个事件进行处理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注册监听&lt;/strong&gt;：把某个事件监听器(A)通过某个事件(B)绑定到某个事件源(C)上，当在事件源C上发生了事件B之后，那么事件监听器A的代码就会自动执行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202011/1993669-20201120001802790-1751755729.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.test;


import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;

public class test {
    Frame frame = new Frame(&quot;nwebshell&quot;);


    Button button = new Button(&quot;submit&quot;);
    TextField textField = new TextField(30);
    public void init(){

        button.addActionListener(new MyActionLitst());
        frame.add(textField);
        frame.add(button,BorderLayout.SOUTH);
        frame.pack();
        frame.setVisible(true);

    }
    private class MyActionLitst implements ActionListener{

        @Override
        public void actionPerformed(ActionEvent e) {
            textField.setText(&quot;Hello World&quot;);
        }


    }

    public static void main(String[] args) {
        new test().init();
    }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202011/1993669-20201120001817905-339752724.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码二：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.test;


import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

public class test {
    public static void main(String[] args) {
        Frame frame = new Frame(&quot;nwebshell&quot;);
        final TextField textField = new TextField(30);
        textField.addTextListener(new TextListener() {
            @Override
            public void textValueChanged(TextEvent e) {
                System.out.println(textField.getText());
            }
        });
        frame.add(textField);
        frame.pack();
        frame.setVisible(true);
    }





    }


&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202011/1993669-20201120001830892-1413542784.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;菜单组件&quot;&gt;菜单组件&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

public class SimpleMenu {
    //创建窗口
    private Frame frame = new Frame(&quot;这里测试菜单相关组件&quot;);
    //创建菜单条组件
    private MenuBar menuBar = new MenuBar();
    //创建文件菜单组件
    private Menu fileMenu = new Menu(&quot;文件&quot;);
    //创建编辑菜单组件
    private Menu editMenu = new Menu(&quot;编辑&quot;);
    //创建新建菜单项
    private MenuItem newItem = new MenuItem(&quot;新建&quot;);
    //创建保存菜单项
    private MenuItem saveItem = new MenuItem(&quot;保存&quot;);
    //创建退出菜单项
    private MenuItem exitItem = new MenuItem(&quot;退出&quot;);

    //创建自动换行选择框菜单项
    private CheckboxMenuItem autoWrap = new CheckboxMenuItem(&quot;自动换行&quot;);

    //创建复制菜单项
    private MenuItem copyItem = new MenuItem(&quot;复制&quot;);

    //创建粘贴菜单项
    private MenuItem pasteItem = new MenuItem(&quot;粘贴&quot;);

    //创建格式菜单
    private Menu formatMenu = new Menu(&quot;格式&quot;);

    //创建注释菜单项
    private MenuItem commentItem = new MenuItem(&quot;注释&quot;);
    //创建取消注释菜单项
    private MenuItem cancelItem = new MenuItem(&quot;取消注释&quot;);

    //创建一个文本域
    private TextArea ta = new TextArea(6, 40);

    public void init(){


        //定义菜单事件监听器
        ActionListener listener = new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                String command = e.getActionCommand();
                ta.append(&quot;单击“&quot;+command+&quot;”菜单\n&quot;);
                if (command.equals(&quot;退出&quot;)){
                    System.exit(0);
                }
            }
        };

        //为注释菜单项和退出菜单项注册监听器
        commentItem.addActionListener(listener);
        exitItem.addActionListener(listener);

        //为文件菜单fileMenu添加菜单项
        fileMenu.add(newItem);
        fileMenu.add(saveItem);
        fileMenu.add(exitItem);

        //为编辑菜单editMenu添加菜单项
        editMenu.add(autoWrap);
        editMenu.add(copyItem);
        editMenu.add(pasteItem);

        //为格式化菜单formatMenu添加菜单项
        formatMenu.add(commentItem);
        formatMenu.add(cancelItem);

        //将格式化菜单添加到编辑菜单中，作为二级菜单
        editMenu.add(new MenuItem(&quot;-&quot;));
        editMenu.add(formatMenu);


        //将文件菜单和编辑菜单添加到菜单条中
        menuBar.add(fileMenu);
        menuBar.add(editMenu);


        //把菜单条设置到frame窗口上
        frame.setMenuBar(menuBar);

        //把文本域添加到frame中
        frame.add(ta);

        //设置frame最佳大小并可见
        frame.pack();
        frame.setVisible(true);
    }


    public static void main(String[] args) {
        new SimpleMenu().init();
    }
}

&lt;/code&gt;
&lt;/pre&gt;

&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;

public class PopupMenuTest {

    private Frame frame = new Frame(&quot;这里测试PopupMenu&quot;);

    //创建PopubMenu菜单
    private PopupMenu popupMenu = new PopupMenu();

    //创建菜单条

    private MenuItem commentItem = new MenuItem(&quot;注释&quot;);
    private MenuItem cancelItem = new MenuItem(&quot;取消注释&quot;);
    private MenuItem copyItem = new MenuItem(&quot;复制&quot;);
    private MenuItem pasteItem = new MenuItem(&quot;保存&quot;);


    //创建一个文本域
    private TextArea ta = new TextArea(&quot;！！！&quot;, 6, 40);

    //创建一个Panel
    private  Panel panel = new Panel();

    public void init(){

        //把菜单项添加到PopupMenu中
        popupMenu.add(commentItem);
        popupMenu.add(cancelItem);
        popupMenu.add(copyItem);
        popupMenu.add(pasteItem);

        //设置panel大小
        panel.setPreferredSize(new Dimension(300,100));

        //把PopupMenu添加到panel中
        panel.add(popupMenu);

        //为panel注册鼠标事件
        panel.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseReleased(MouseEvent e) {
                boolean flag = e.isPopupTrigger();
                //判断当前鼠标操作是不是触发PopupMenu的操作
                if (flag){
                    //让PopupMenu显示在panel上，并且跟随鼠标事件发生的地方显示
                    popupMenu.show(panel,e.getX(),e.getY());
                }
            }
        });

        //把ta添加到frame中间区域中

        frame.add(ta);

        //把panel添加到frame底部
        frame.add(panel,BorderLayout.SOUTH);

        //设置frame最佳大小，并可视；
        frame.pack();
        frame.setVisible(true);

    }

    public static void main(String[] args) {
        new PopupMenuTest().init();
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;0x04-结尾&quot;&gt;0x04 结尾&lt;/h2&gt;
&lt;p&gt;其实，在开发中会发现，Java写gui界面真挺繁杂的。配置页面都得手工去适配，就没有像C#这些这么方便，直接画框，配置事件就完事了。AWT这个类其实不能够做到跨平台，因为他是借助windows的界面。后面会接着学习Swing框架。&lt;/p&gt;
</description>
<pubDate>Thu, 19 Nov 2020 16:20:00 +0000</pubDate>
<dc:creator>nice_0e3</dc:creator>
<og:description>Java学习之AWT GUI编程 0x00 前言 既然前面提到了要重写冰蝎和一些反序列化工具，当然就不能随便说说而已。在编写这些工具还是要使用图形化工具来的方便一些，所以提前把GUI的框架给学习一遍。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/nice0e3/p/14008800.html</dc:identifier>
</item>
<item>
<title>架构设计：微服务模式下，实现灰度发布模式 - 知了一笑</title>
<link>http://www.cnblogs.com/cicada-smile/p/14008728.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cicada-smile/p/14008728.html</guid>
<description>&lt;p&gt;配置版本号，区分灰度版本和默认正常版本； 自定义拦截器，管理版本号或其他标识参数在请求中传递； 自定义服务选中策略，基于版本标识路由服务； 如果灰度服务不存在，则基于规则选中默认服务；&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;110.31615873712&quot;&gt;
&lt;p&gt;本文源码：&lt;a href=&quot;https://github.com/cicadasmile/data-manage-parent&quot;&gt;GitHub·点这里&lt;/a&gt; || &lt;a href=&quot;https://gitee.com/cicadasmile/data-manage-parent&quot;&gt;GitEE·点这里&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;请求通过8001服务，在灰度规则中，会读取下次请求的服务列表，根据版本号参数规则，选中路由的服务。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1691717/202011/1691717-20201119233158200-218463416.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;配置版本号，区分灰度版本和默认正常版本；&lt;br/&gt;自定义拦截器，管理版本号或其他标识参数在请求中传递；&lt;br/&gt;自定义服务选中策略，基于版本标识路由服务；&lt;br/&gt;如果灰度服务不存在，则基于规则选中默认服务；&lt;/p&gt;

&lt;p&gt;在node12-server集群配置两个服务：在8002端口配置版本v7.0.0,在8003端口配置版本v7.0.1，用来测试灰度版本选择。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;8002服务&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;eureka:
    metadata-map:
      version: v7.0.0
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;8003服务&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;eureka:
    metadata-map:
      version: v7.0.1
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Eureka注册中心，服务列表：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1691717/202011/1691717-20201119233214482-415016611.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;微服务下通过实现RequestInterceptor接口，管理服务之间的Feign请求拦截器，在请求路由到服务前，可以对请求执行一些处理操作，常见操作例如传递版本号，用户Token等请求头等属性。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * 请求拦截器
 */
@Component
public class GrayReqInterceptor implements RequestInterceptor {

    private static final String VERSION_KEY = &quot;versionId&quot; ;

    /**
     * 处理请求头参数携带问题
     */
    @Override
    public void apply(RequestTemplate requestTemplate) {
        HttpServletRequest request =
                ((ServletRequestAttributes)
                RequestContextHolder.getRequestAttributes()).getRequest();

        String versionId = request.getHeader(VERSION_KEY);

        if (StringUtils.isNotEmpty(versionId)){
            requestTemplate.header(VERSION_KEY,versionId);
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里就传递一个versionId参数，作为下次请求路由服务的核心标识。&lt;/p&gt;

&lt;p&gt;在请求头的Header中添加要访问的版本号，如果有匹配的服务，则路由所有请求的灰度服务，如果没有则返回默认服务。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Configuration
public class GrayRule extends ZoneAvoidanceRule {

    @Bean
    public GrayReqInterceptor grayReqInterceptor(){
        return new GrayReqInterceptor();
    }

    private static final String VERSION_KEY = &quot;versionId&quot; ;

    @Override
    public Server choose(Object key) {

        HttpServletRequest request =
                ((ServletRequestAttributes)
                RequestContextHolder.getRequestAttributes()).getRequest();

        String versionId = request.getHeader(VERSION_KEY);

        // 服务匹配
        List&amp;lt;Server&amp;gt; serverList = this.getPredicate().getEligibleServers(this.getLoadBalancer().getAllServers(), key);
        Server toServer = getServer(serverList,versionId);
        if (toServer != null){
            return toServer ;
        } else {
            return getServer(serverList,GrayConstant.VERSION_DEF);
        }
    }

    private Server getServer (List&amp;lt;Server&amp;gt; serverList,String version){
        Server toServer = null ;
        for (Server server : serverList) {
            Map&amp;lt;String, String&amp;gt; metadata = ((DiscoveryEnabledServer) server).getInstanceInfo().getMetadata();

            String metaVersion = metadata.get(&quot;version&quot;);
            if (!StringUtils.isEmpty(metaVersion)) {
                if (metaVersion.equals(version)) {
                    toServer = server;
                }
            }
        }
        return toServer ;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在实际的过程中，服务的选择是十分复杂的，如果没有灰度服务，需要根据实际情况制定服务匹配的规则，例如根据响应时间，或者默认轮询等。&lt;/p&gt;
&lt;p&gt;更需要注意的一点是，一旦使用底层API的二次封装，项目的整体就会受到框架版本升级的影响，需要持续关注框架的环境。&lt;/p&gt;

&lt;p&gt;1.启动相关服务，观察注册中心服务列表；&lt;/p&gt;
&lt;p&gt;2.请求8001服务的接口，并带上版本号；&lt;/p&gt;
&lt;p&gt;3.观察不同版本号的路由服务；&lt;/p&gt;
&lt;p&gt;4.不携带版本号，观察默认服务选择；&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;GitHub地址：知了一笑
https://github.com/cicadasmile/spring-cloud-base
GitEE地址：知了一笑
https://gitee.com/cicadasmile/spring-cloud-base
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;推荐阅读：编程体系整理&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Thu, 19 Nov 2020 15:54:00 +0000</pubDate>
<dc:creator>知了一笑</dc:creator>
<og:description>配置版本号，区分灰度版本和默认正常版本； 自定义拦截器，管理版本号或其他标识参数在请求中传递； 自定义服务选中策略，基于版本标识路由服务； 如果灰度服务不存在，则基于规则选中默认服务；</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cicada-smile/p/14008728.html</dc:identifier>
</item>
<item>
<title>痞子衡嵌入式：JLink Script文件基础及其在IAR下调用方法 - 痞子衡</title>
<link>http://www.cnblogs.com/henjay724/p/14008691.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/henjay724/p/14008691.html</guid>
<description>&lt;p&gt;为什么需要JLink Script文件？有些情况下，需要定制J-Link执行的某些操作，比如J-Link连接顺序或者执行复位的方式等，或者一些定制的硬件板需要一些特殊处理，这些动作没法直接集成到J-Link软件的通用处理里，因此需要被放在单独的JLink Script文件里，根据连接的具体目标对象来指定加载执行。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;139.80831805683&quot;&gt;
&lt;hr/&gt;&lt;p&gt;　　大家好，我是痞子衡，是正经搞技术的痞子。今天痞子衡给大家分享的是&lt;strong&gt;JLink Script文件基础及其在IAR下调用方法&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　JLink可以说是MCU开发者最熟悉的调试工具了，相比于其他调试器（比如DAPLink、ST-LINK、I-jet等），JLink除了性能强大之外，还胜在其配套各种软件小工具相当方便易用。JLink工具玩得熟的老司机一定在J-Link Commander命令行工具(即\SEGGER\JLink_Vxxx\JLink.exe)下敲过命令，读写内存、下载文件、操控内核无所不能。这个底层工具其实也是JLink精华所在，今天痞子衡要讲的JLink Script文件主题其实就是依赖这个工具。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/cnblogs/JLinkScriptFile_commander_snap.PNG&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;一、jlink-script作用&quot;&gt;一、JLink Script作用&lt;/h3&gt;
&lt;p&gt;　　如果你有脚本语言经验（比如Python），你应该很熟悉脚本语言那一套规则，脚本语言不同于一般编译型语言（比如C），编译型语言经过编译链接生成的二进制机器码被CPU直接识别执行，但脚本不需要预编译，它是由配套解释器动态翻译执行的，而CPU负责执行的是脚本解释器。&lt;/p&gt;
&lt;p&gt;　　基于上述概念JLink.exe就是一个解释器，它能解释执行JLink Script文件，其命令格式如下，使用-JLinkScriptFile参数指定JLink Script文件路径便可执行JLink Script文件里的语句。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;命令格式： JLink.exe -JLinkScriptFile MyFile.JLinkScript&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;　　为什么需要JLink Script文件？有些情况下，需要定制J-Link执行的某些操作，比如J-Link连接顺序或者执行复位的方式等，或者一些定制的硬件板需要一些特殊处理，这些动作没法直接集成到J-Link软件的通用处理里，因此需要被放在单独的JLink Script文件里，根据连接的具体目标对象来指定加载执行。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;Note：其实除了常见的明文脚本(.JLinkScript)文件之外，JLink Script文件还有另外一种经过预编译的文件形式(.pex)，这种格式是纯二进制的，可以保护脚本内容。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;二、jlink-script文件基础&quot;&gt;二、JLink Script文件基础&lt;/h3&gt;
&lt;p&gt;　　JLink Script这一套东西整体上由五大部分组成：基本语法、全局DLL变量、全局DLL常量、系统API接口、用户自定义动作集。&lt;/p&gt;
&lt;h4 id=&quot;21-脚本基础语法&quot;&gt;2.1 脚本基础语法&lt;/h4&gt;
&lt;p&gt;　　JLink Script并不是一个通用的脚本语言，因此其并不像你熟知的那些Python之类的脚本语言那样语法完善，它仅是为了配合JLink完成一些必要操作。JLink Script语法跟C语言类似，支持C语言中允许的大多数语句（if else，while，变量声明，…），但不是所有的语句。&lt;/p&gt;
&lt;p&gt;　　此外，还有一些语句是特定于JLink Script的，JLink Script已经尽可能允许最大的灵活性，因此几乎任何必要的目标初始化操作都可以得到支持。&lt;/p&gt;
&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;22-全局dll常变量&quot;&gt;2.2 全局DLL常/变量&lt;/h4&gt;
&lt;p&gt;　　JLink Script在被解释执行时，其实是和JLink DLL（即\SEGGER\JLink_Vxxx\JLinkARM.dll）联动的，DLL里存放了JLink各种底层功能集合，同时也默认预定义一些全局变量，这些变量用于DLL配置，需要在JLink Script中被赋值。比如最基础的变量CPU，用于指示连接的目标内核类型，而支持的全部CPU类型都定义在全局常量里。&lt;/p&gt;
&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;23-系统内置的api接口&quot;&gt;2.3 系统内置的API接口&lt;/h4&gt;
&lt;p&gt;　　JLink DLL中实现了很多基础操作功能，这些功能通过API函数接口形式开放给JLink Script来调用，这些API全部以JLINK_为前缀。举一个比较常用的API函数JLINK_TARGET_Halt()，这个函数功能就是挂起目标内核。&lt;/p&gt;
&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;24-用户可自定义动作集&quot;&gt;2.4 用户可自定义动作集&lt;/h4&gt;
&lt;p&gt;　　终于要讲到JLink Script最关键的部分了，前面都是基础，而JLink Script最核心的功能其实在用户自定义动作集合里，这些动作由JLink预先定义，但是内部具体操作可由用户来编写。在IDE在线下载调试过程中按规定触发条件来调用执行这些动作，下表列出了全部动作，其中蓝框标出的四个动作最常用。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;InitTarget()：替换J-Link DLL的目标CPU自动查找过程。对于默认情况下不可访问且需要执行一些特殊步骤才能成功执行常规调试连接过程的目标CPU非常有用。&lt;/li&gt;
&lt;li&gt;SetupTarget()：在InitTarget()以及JLink常规调试连接序列之后被调用，通常用于更高级别的CPU调试设置，如写入某些内存位置、初始化PLL以加快下载速度等。&lt;/li&gt;
&lt;li&gt;ResetTarget()：替换DLL的复位策略。无论在DLL中选择了什么复位类型，如果存在此函数，将调用它而不是DLL内部复位。&lt;/li&gt;
&lt;li&gt;AfterResetTarget()：在ResetTarget()之后调用。复位结束后，用于初始化一些必要外设（比如看门狗）。除此之外，对于某些内核类型有必要在复位后执行一些特殊操作，以保证复位后的设备功能正常。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/cnblogs/JLinkScriptFile_dll_api_list.PNG&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;三、jlink-script在iar下调用方法&quot;&gt;三、JLink Script在IAR下调用方法&lt;/h3&gt;
&lt;p&gt;　　单纯的JLink Script没有意义，需要和工具链配合使用才能发挥最大作用，除了SEGGER工具之外（Embedded Studio、Ozone、SystemView），JLink Script还可以和常见的IDE环境（IAR/Keil/Eclipse）一起工作，痞子衡以IAR为例介绍三种调用JLink Script的方法（使用的是恩智浦i.MXRT685-EVK开发板做的测试）。&lt;/p&gt;
&lt;h4 id=&quot;31-jlinkdevicesxml中指定&quot;&gt;3.1 JLinkDevices.xml中指定&lt;/h4&gt;
&lt;p&gt;　　第一种方法是在 \SEGGER\JLink_Vxxx\JLinkDevices.xml 文件中指定，如果你对这个文件不了解，可先回顾下痞子衡之前写的文章 &lt;a href=&quot;https://www.cnblogs.com/henjay724/p/13770137.html&quot;&gt;《串行NOR Flash下载算法(J-Link工具篇)》&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;　　给板卡通上电，连上J-Link调试器，随便打开一个测试工程（\SDK_xxx_EVK-MIMXRT685\boards\evkmimxrt685\demo_apps\hello_world\iar），选择flash_debug，将其工程选项做如下更改：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;设置内核为Cortex-M33，即不启用Device里的NXP MIMXRT685S_CM33设置&lt;/li&gt;
&lt;li&gt;调试器选择J-Link/J-Trace，且不要勾选Use flash loader(s)&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/cnblogs/JLinkScriptFile_iar_proj_opt_cm33_jlink_flm.PNG&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这么做是为了在IAR下载时不用NXP MIMXRT685S_CM33默认指定的JLink下载算法，而弹出一个框让用户主动选择合适的JLink下载算法，我们修改JLinkDevices.xml如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;Note： \SEGGER\JLink_Vxxx\Devices\NXP\iMXRT6xx_UFL\iMXRT6xx_CortexM33.JLinkScript便是我们要测试的JLink Script，在里面我们可以加一句JLINK_SYS_Report(&quot;J-Link script: This UFL script comes from Segger package&quot;); 便于检查调用结果。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/cnblogs/JLinkScriptFile_test_jlinkdevices_xml.PNG&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　选好MIMXRT685_UFL这个指定下载算法后，直接在IAR里点击下载，进入正常调试后，可以在Debug Log里看到iMXRT6xx_CortexM33.JLinkScript确实被调用了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/cnblogs/JLinkScriptFile_test_iar_debug_info_for_jlinkdevices_xml.PNG&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　在上一小节测试基础上，将JLinkDevices.xml里的 JLinkScriptFile=&quot;Devices/NXP/iMXRT6xx_UFL/iMXRT6xx_CortexM33.JLinkScript&quot; 这一句去掉，即不在下载算法里直接调用JLink Script。然后将iMXRT6xx_CortexM33.JLinkScript文件拷贝一份放到\SDK_xxx_EVK-MIMXRT685\boards\evkmimxrt685\demo_apps\hello_world\iar目录下，并在IAR工程选项中做如下设置：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;Note： \SDK_xxx_EVK-MIMXRT685\boards\evkmimxrt685\demo_apps\hello_world\iar\iMXRT6xx_CortexM33.JLinkScript便是我们要测试的JLink Script，在里面我们可以加一句JLINK_SYS_Report(&quot;J-Link script: This UFL script comes from Extra Option&quot;); 便于检查调用结果。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/cnblogs/JLinkScriptFile_iar_proj_opt_extra_options.PNG&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　再次在IAR里点击下载，进入正常调试后，可以在Debug Log里看到新的iMXRT6xx_CortexM33.JLinkScript确实被调用了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/cnblogs/JLinkScriptFile_test_iar_debug_info_for_extra_option.PNG&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;33-工程目录settings文件下指定&quot;&gt;3.3 工程目录settings文件下指定&lt;/h4&gt;
&lt;p&gt;　　在上一小节测试基础上，不勾选IAR工程选项Extra Options中Use command line options。然后将iMXRT6xx_CortexM33.JLinkScript文件拷贝一份放到\SDK_xxx_EVK-MIMXRT685\boards\evkmimxrt685\demo_apps\hello_world\iar\settings目录下，需要重命名JLink Script文件与测试工程名一致：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;Note： \SDK_xxx_EVK-MIMXRT685\boards\evkmimxrt685\demo_apps\hello_world\iar\settings\hello_world_flash_debug.JLinkScript便是我们要测试的JLink Script，在里面我们可以加一句JLINK_SYS_Report(&quot;J-Link script: This UFL script comes from settings&quot;); 便于检查调用结果。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/cnblogs/JLinkScriptFile_test_put_script_to_settings.PNG&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　再次在IAR里点击下载，进入正常调试后，可以在Debug Log里看到hello_world_flash_debug.JLinkScript确实被调用了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/cnblogs/JLinkScriptFile_test_iar_debug_info_for_settings.PNG&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　至此，JLink Script文件基础及其在IAR下调用方法痞子衡便介绍完毕了，掌声在哪里~~~&lt;/p&gt;
&lt;h3 id=&quot;欢迎订阅&quot;&gt;欢迎订阅&lt;/h3&gt;
&lt;p&gt;文章会同时发布到我的 &lt;a href=&quot;https://www.cnblogs.com/henjay724/&quot;&gt;博客园主页&lt;/a&gt;、&lt;a href=&quot;https://blog.csdn.net/henjay724&quot;&gt;CSDN主页&lt;/a&gt;、&lt;a href=&quot;https://www.zhihu.com/people/henjay724&quot;&gt;知乎主页&lt;/a&gt;、&lt;a href=&quot;http://weixin.sogou.com/weixin?type=1&amp;amp;query=%E7%97%9E%E5%AD%90%E8%A1%A1%E5%B5%8C%E5%85%A5%E5%BC%8F&quot;&gt;微信公众号&lt;/a&gt; 平台上。&lt;/p&gt;
&lt;p&gt;微信搜索&quot;&lt;strong&gt;痞子衡嵌入式&lt;/strong&gt;&quot;或者扫描下面二维码，就可以在手机上第一时间看了哦。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/github/pzhMcu_qrcode_258x258.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Thu, 19 Nov 2020 15:40:00 +0000</pubDate>
<dc:creator>痞子衡</dc:creator>
<og:description>为什么需要JLink Script文件？有些情况下，需要定制J-Link执行的某些操作，比如J-Link连接顺序或者执行复位的方式等，或者一些定制的硬件板需要一些特殊处理，这些动作没法直接集成到J-L</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/henjay724/p/14008691.html</dc:identifier>
</item>
</channel>
</rss>