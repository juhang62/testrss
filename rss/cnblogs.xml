<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>6th.Mar.2019 - kgxpbqbyt</title>
<link>http://www.cnblogs.com/kgxw0430/p/10487211.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kgxw0430/p/10487211.html</guid>
<description>&lt;h4 id=&quot;取石子游戏&quot;&gt;取石子游戏&lt;/h4&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1208065/201903/1208065-20190306182301128-811731591.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;数据范围：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1208065/201903/1208065-20190306182336973-43751278.png&quot;/&gt;&lt;/p&gt;
&lt;ul readability=&quot;8&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;30分。直接暴力枚举剩下哪些堆。然后判断是否异或和为0、去掉的数量是否是d的倍数即可。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;50分。考虑dp。f[i] [j] [k]表示到了第i堆石子，留下了j堆，此时子集异或和为k的方案数。&lt;span class=&quot;math inline&quot;&gt;\(n^2*max(a[i])\)&lt;/span&gt;递推即可。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;70分。首先我们先把上面所述50分的dp优化一下，考虑真正对答案有贡献的肯定是去掉的个数为d的倍数。所以我们传递状态的时候，只需要考虑留下的堆的数量在mod d下是什么值就好。那么递推复杂度变为&lt;span class=&quot;math inline&quot;&gt;\(n*d*max(a[i])\)&lt;/span&gt;。有20分的数据，本质不同的a[i]只有不超过5个。显然可以用数组存起来所有子集异或和，递推的时候只考虑这些。复杂度是&lt;span class=&quot;math inline&quot;&gt;\(n*d*2^5\)&lt;/span&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;100分。前面的一个n我们已经优化到了d。所以现在考虑从a[i]下手。但是每次两个数异或的值随机大小，我们怎么给缩小范围啊？排序！反正排序不影响答案，我们把a数组按照从大到小排序。假如当前到了a[i],而&lt;span class=&quot;math inline&quot;&gt;\(a[i]&amp;lt;2^L\)&lt;/span&gt;，因为我们考虑的是如何让剩下的数异或和为0，那么它能影响到状态显然都小于&lt;span class=&quot;math inline&quot;&gt;\(2^L\)&lt;/span&gt;。所以只需要枚举&lt;span class=&quot;math inline&quot;&gt;\(0\)&lt;/span&gt;~&lt;span class=&quot;math inline&quot;&gt;\(2^L\)&lt;/span&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;复杂度证明：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1208065/201903/1208065-20190306183801256-308126482.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;小结：比赛的时候，一定先打暴力。比如这道题50分的暴力很好打（为了确保正确性可以先打30的暴力来对拍）。跟着数据范围想优化暴力，思考算法的可行性之后再敲。今天上午想了线性基好像可以做，就直接去码了。码了码，调调发现算法是假的。而这时候已经11点了，如果是省选我就凉了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;coding&quot;&gt;&lt;span&gt;Coding&lt;/span&gt;&lt;/h4&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
#define ll long long
using namespace std;
const int N=2e6+10;
const int mod=1e9+7;
ll n,d,a[N],f[2][12][N];
ll read(){
    char ch=getchar();ll num=0,f=1;
    while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}
    while(isdigit(ch)){num=(num&amp;lt;&amp;lt;1)+(num&amp;lt;&amp;lt;3)+(ch^48);ch=getchar();}
    return num*f;
}
bool cmp(ll a,ll b){return a&amp;gt;b;}
int main(){
    n=read(),d=read();
    for(int i=1;i&amp;lt;=n;++i) a[i]=read();
    sort(a+1,a+n+1,cmp);
    f[0][0][0]=1;ll last=0,now=1;
    for(int i=1;i&amp;lt;=n;++i){
        int l=log(1.0*a[i])/log(2.0)+1;
        for(int j=0;j&amp;lt;d;++j) for(int k=pow(2.0,1.0*l);k&amp;gt;=0;--k) f[now][j][k]=0;
        for(int j=0;j&amp;lt;d;++j){
            for(int k=pow(2.0,1.0*l);k&amp;gt;=0;--k){
                f[now][j][k]=(ll)(f[now][j][k]+f[last][(j-1+d)%d][k^a[i]])%mod;
                f[now][j][k]=(ll)(f[now][j][k]+f[last][j][k])%mod;
            }
        }
        int temp=now;now=last;last=temp;
    }
    int ans=f[last][n%d][0];
    if(n%d==0) ans=(ll)(ans-1+mod)%mod;
    cout&amp;lt;&amp;lt;ans&amp;lt;&amp;lt;endl;
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;路径计数&quot;&gt;路径计数&lt;/h4&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1208065/201903/1208065-20190306191649551-2144885119.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;数据范围：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1208065/201903/1208065-20190306191711584-1905008023.png&quot;/&gt;&lt;/p&gt;
&lt;ul readability=&quot;7&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;这题暴力dfs没法儿写吧，反正我是写不了，机房大佬不知道怎么算的复杂度，让老师+时限想卡过去，其实根本不可能好吧。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;必须朝dp的这个思路想才行。其实这种计数类的题目，又显然没有什么式子可以推，那就是dp了。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;设f[s] [t] [d] [j]表示以s为起点，t为终点，走了d步到达j，中途不经过s和t的方案数。这个显然可以&lt;span class=&quot;math inline&quot;&gt;\(n^4*d\)&lt;/span&gt;转移，查询O&lt;span class=&quot;math inline&quot;&gt;\((1)\)&lt;/span&gt;，复杂度O&lt;span class=&quot;math inline&quot;&gt;\((n^4*d+q)\)&lt;/span&gt;,50分get。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;上面所述状态因为要考虑中途不出现s和t，所以必须状态多了一维，考虑如何优化掉这一维。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;假如我们现在要求得是从s走到t，走了d步，中途任意的方案数，显然可以&lt;span class=&quot;math inline&quot;&gt;\(n^3*d\)&lt;/span&gt;求。具体来说，设g[s] [t] [d] 表示从s走d步到t，任意走的方案数。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[g[s][t][d]=\sum_{i=1}^{n}g[s][i][d-1]\]&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;如何求答案呢？其实是一个广义容斥，合法的方案数=所有的方案数-不合法的方案数。设f[s] [t] [d]表示从s走d到t的合法方案数。如何求不合法的方案数？想一下，一条不合法的路径，从s到t肯定有第一个不合法的点，即第一次遇到了s或者t。分两种情况：
&lt;ul&gt;&lt;li&gt;第一次遇到了t，那么不合法的方案即为&lt;span class=&quot;math inline&quot;&gt;\(f[s][t][i]*g[t][t][d-i]\)&lt;/span&gt;，i从1~d-1.&lt;/li&gt;
&lt;li&gt;第一次遇到了s，那么不合法的方案应该是从s到s，中途不经过s和t的方案数再乘上&lt;span class=&quot;math inline&quot;&gt;\(g[s][t][d-i]\)&lt;/span&gt;。我们定义从s到s，中途不经过s和t的方案数为&lt;span class=&quot;math inline&quot;&gt;\(h[s][t][i]\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;到此，f数组的求法已经知道。现在考虑如何求h数组。其实和f数组一样，我们仍然把路径分为两种情况：
&lt;ul&gt;&lt;li&gt;先遇到s，&lt;span class=&quot;math inline&quot;&gt;\(h[s][t][d]-\sum_{i=1}^{d-1}h[s][t][i]*g[s][s][d-i]\)&lt;/span&gt;.&lt;/li&gt;
&lt;li&gt;先遇到t，&lt;span class=&quot;math inline&quot;&gt;\(h[s][t][d]-\sum_{i=1}^{d-1}f[s][t][i]*g[t][s][d-i]\)&lt;/span&gt;.&lt;/li&gt;
&lt;li&gt;记得最初&lt;span class=&quot;math inline&quot;&gt;\(h[s][t][d]=g[s][s][d]\)&lt;/span&gt;.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;还有比较sb的一点是，手动取模，不然会T。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;coding-1&quot;&gt;&lt;span&gt;Coding&lt;/span&gt;&lt;/h4&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
#define ll long long
#define mul(a,b)    1LL*a*b%p
using namespace std;
const int N=110;
int f[N][N][52],g[N][N][52],h[N][N][52];
int n,m,p,q,a[N][N];
inline void add(int &amp;amp;a,int b){a+=b;a-= a&amp;gt;=p? p:0;}
inline void sub(int &amp;amp;a,int b){a-=b;a=(a+p)%p;}
int read(){
    char ch=getchar();int num=0,f=1;
    while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}
    while(isdigit(ch)){num=(num&amp;lt;&amp;lt;1)+(num&amp;lt;&amp;lt;3)+(ch^48);ch=getchar();}
    return num*f;
}
void work(){
    for(int i=1;i&amp;lt;=n;++i) g[i][i][0]=h[i][i][0]=f[i][i][0]=1;
    for(int d=2;d&amp;lt;=50;++d){
        for(int i=1;i&amp;lt;=n;++i){
            for(int j=1;j&amp;lt;=n;++j){
                for(int k=1;k&amp;lt;=n;++k){
                    add(g[i][j][d],mul(g[i][k][d-1],g[k][j][1]));
                }
            }
        }
    }
    for(int d=2;d&amp;lt;=50;++d){
        for(int s=1;s&amp;lt;=n;++s){
            for(int t=1;t&amp;lt;=n;++t){
                h[s][t][d]=g[s][s][d];
                for(int i=1;i&amp;lt;d;++i){
                    sub(h[s][t][d],mul(f[s][t][i],g[t][s][d-i]));
                    if(s==t) continue;
                    sub(h[s][t][d],mul(h[s][t][i],g[s][s][d-i]));
                }
                f[s][t][d]=g[s][t][d];
                for(int i=1;i&amp;lt;d;++i){
                    sub(f[s][t][d],mul(f[s][t][i],g[t][t][d-i]));
                    if(s==t) continue;
                    sub(f[s][t][d],mul(h[s][t][i],g[s][t][d-i]));
                }
            }
        }
    }
}
int main(){
    n=read(),m=read(),p=read();
    for(int i=1;i&amp;lt;=m;++i){
        int x,y;x=read(),y=read();
        a[x][y]=1;
        g[x][y][1]=1;
        f[x][y][1]=1;
    }
    work();
    q=read();
    for(int i=1;i&amp;lt;=q;++i){
        int x,y,z;x=read(),y=read(),z=read();
        printf(&quot;%d\n&quot;,f[x][y][z]);
    }
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 06 Mar 2019 23:39:00 +0000</pubDate>
<dc:creator>kgxpbqbyt</dc:creator>
<og:description>取石子游戏 数据范围： 30分。直接暴力枚举剩下哪些堆。然后判断是否异或和为0、去掉的数量是否是d的倍数即可。 50分。考虑dp。f[i] [j] [k]表示到了第i堆石子，留下了j堆，此时子集异或和</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kgxw0430/p/10487211.html</dc:identifier>
</item>
<item>
<title>python中线程和进程(二) - 小赵面面观</title>
<link>http://www.cnblogs.com/dianel/p/10487205.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dianel/p/10487205.html</guid>
<description>&lt;h2 id=&quot;线程同步&quot;&gt;&lt;span&gt;线程同步&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;线程同步，即线程之间协同工作，一个线程访问某些数据时，其他线程不能访问这些数据，直到该线程完成对数据的操作。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;不同的操作系统实现的技术有所不同，有临界区(Critical Section)、互斥量(Mutex)、信号量(Semaphore)、事件（Event）等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;event&quot;&gt;&lt;span&gt;Event&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;Event是线程间通信的最简单的方法：通过一个线程发出信号，其他线程等待它。&lt;/p&gt;
&lt;p&gt;Event对象管理一个内部标志，该标志通过&lt;code&gt;set()&lt;/code&gt;方法设置为true，也可以通过&lt;code&gt;clear()&lt;/code&gt;方法重置为false，使用&lt;code&gt;wait()&lt;/code&gt;方法时，将会被阻塞，直到该标志为真的时候，才放行。该标志一开始是false。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;is_set()&lt;/td&gt;
&lt;td&gt;当内部标志为真时，返回true&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;set()&lt;/td&gt;
&lt;td&gt;将内部标志设置为true，此时所有wait()线程将不会阻塞（唤醒）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;clear()&lt;/td&gt;
&lt;td&gt;将内部标志重置为false，此时，线程将会调用wait()阻塞，直到set()被用。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;wait(timeout=None)&lt;/td&gt;
&lt;td&gt;阻塞，直到内部标志为真，或者超时。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from threading import Event,Thread
import logging
import time


FORMAT = '%(asctime)s %(threadName)s %(thread)d %(message)s'
logging.basicConfig(format=FORMAT,level=logging.INFO)


def boss(event:Event):
    logging.info(&quot;I'm boss,wait...&quot;)
    event.wait()  # 阻塞，直到为true
    logging.info(&quot;good，thanks!&quot;)


def worker(event:Event,counts):
    logging.info(&quot;I'm working for boss.&quot;)
    cups = []
    while True:
        logging.info(&quot;make 1 cup&quot;)
        cups.append(1)
        time.sleep(0.5)
        logging.info(cups)
        if len(cups) &amp;gt;= counts:
            event.set()  # 完成，标记为true
            break
    logging.info(&quot;I finished my job，cups={}&quot;.format(cups))


event = Event()
b = Thread(target=boss,args=(event,))
w = Thread(target=worker,args=(event,10))
w.start()
b.start()&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;lock&quot;&gt;&lt;span&gt;Lock&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;锁，如果存在共享资源争抢的问题，就可以使用锁，从而保证一个使用者可以完全拥有这个资源。&lt;/p&gt;
&lt;p&gt;Lock拥有两种基本方法，&lt;code&gt;acquire()&lt;/code&gt;和&lt;code&gt;release()&lt;/code&gt;。&lt;code&gt;acquire&lt;/code&gt;将状态改为锁定，此时将会阻塞，直到调用&lt;code&gt;relase()&lt;/code&gt;解锁。&lt;code&gt;relase()&lt;/code&gt;方法只能在锁定的时候调用，否则将会应发RuntimeError异常。锁还支持上下文管理协议，锁的所有方法都是原子方式进行。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;acquire(blocking=True,timeout=-1)&lt;/td&gt;
&lt;td&gt;默认阻塞，阻塞是可以设置超时时间，返回True，否则返回False&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;release()&lt;/td&gt;
&lt;td&gt;解锁，可以从任何线程调用，而不仅仅是获取锁的线程&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;例子：车间生产1000个杯子，组织10人生产时，结果会超出数量（没有使用锁）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from threading import Thread,Lock
import logging
import time


FORMAT = '%(asctime)s %(threadName)s %(thread)d %(message)s'
logging.basicConfig(format=FORMAT,level=logging.INFO)


cups = []
def worker(counts=10):
    logging.info(&quot;I'm working for boss&quot;)
    while len(cups) &amp;lt; counts:
        time.sleep(0.0002)
        cups.append(1)
    logging.info(&quot;I'm finished,cups={}&quot;.format(len(cups)))

for _ in range(10):
    Thread(target=worker,args=(1000,)).start()

# 结果
''''''
2019-03-06 07:31:50,884 Thread-10 11052 I'm working for boss
2019-03-06 07:31:51,084 Thread-3 7108 I'm finished,cups=1000
2019-03-06 07:31:51,084 Thread-7 21188 I'm finished,cups=1001
2019-03-06 07:31:51,084 Thread-8 11592 I'm finished,cups=1002
2019-03-06 07:31:51,085 Thread-5 18288 I'm finished,cups=1003
2019-03-06 07:31:51,085 Thread-10 11052 I'm finished,cups=1004
''''''&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用锁后。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from threading import Thread,Lock
import logging
import time


FORMAT = '%(asctime)s %(threadName)s %(thread)d %(message)s'
logging.basicConfig(format=FORMAT,level=logging.INFO)


cups = []
lock = Lock()


def worker(counts=10):
    logging.info(&quot;I'm working for boss&quot;)
    flag = False
    while True:
        lock.acquire() # 加锁
        if len(cups) &amp;gt;= counts:
            flag = True
        time.sleep(0.0002)
        if not flag:
            cups.append(1)
        lock.release() #生产完之后，解锁
        if flag:
            break

    logging.info(&quot;I'm finished,cups={}&quot;.format(len(cups)))

for _ in range(10):
    Thread(target=worker,args=(1000,)).start()&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;rlock&quot;&gt;&lt;span&gt;RLock&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;RLock：可重入锁，是线程相关的锁。&lt;br/&gt;线程A获得可重入锁，可以多次获取，不会阻塞，但是最后在线程A中做和acquire次数相同的release才会释放。当锁没有释放完，其他线程取锁就会阻塞。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from threading import Thread,Lock,RLock
import logging
import time

FORMAT = '%(asctime)s %(threadName)s %(thread)d %(message)s'
logging.basicConfig(format=FORMAT,level=logging.INFO)


def say(l:RLock):
    l.acquire()  # 获取一次
    logging.info(&quot;acquire1&quot;)
    l.acquire()  # 获取2次
    logging.info(&quot;acquire2&quot;)
    l.release()  # 释放1次
    logging.info(&quot;release1&quot;)
    l.release()  # 释放2次
    logging.info(&quot;release2&quot;)

rlock = RLock()
t1 = Thread(target=say,args=(rlock,),name=&quot;t1&quot;)
t2 = Thread(target=say,args=(rlock,),name=&quot;t2&quot;)
t1.start()
t2.start()
# 结果
2019-03-06 20:41:40,830 t1 2036 acquire1
2019-03-06 20:41:40,830 t1 2036 acquire2
2019-03-06 20:41:40,830 t1 2036 release1
2019-03-06 20:41:40,830 t1 2036 release2
2019-03-06 20:41:40,831 t2 31984 acquire1
2019-03-06 20:41:40,831 t2 31984 acquire2
2019-03-06 20:41:40,831 t2 31984 release1
2019-03-06 20:41:40,831 t2 31984 release2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从结果也可以看出来，只有t1线程完全释放了相同次数的锁，t2线程才能获得锁。&lt;/p&gt;
&lt;h3 id=&quot;condition&quot;&gt;&lt;span&gt;Condition&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;条件变量Condition，总是和某种锁（通常是RLock）相互关联。条件变量也支持上下文管理协议。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;acquire()&lt;/td&gt;
&lt;td&gt;获取锁&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;release()&lt;/td&gt;
&lt;td&gt;释放锁&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;wait(timeout=None)&lt;/td&gt;
&lt;td&gt;等待通知或者直到超时，调用次方法前必须先获得锁&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;notify(n=1)&lt;/td&gt;
&lt;td&gt;唤醒指定数目的等待线程，如果调用此方法时，线程没有锁定，将会引发异常。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;notify_all()&lt;/td&gt;
&lt;td&gt;唤醒所有的线程&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;生产者消费者模型：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from threading import Event,Thread,Condition
import logging
import time
import random


class Dispatcher:
    def __init__(self):
        self.data = 0
        self.cond = Condition()

    def produce(self):
        print(&quot;开始生产包子&quot;)
        while True:
            with self.cond:
                self.data += 1
                print(&quot;生产了一个包子,现在有{}个。&quot;.format(self.data))
                self.cond.notify()
            time.sleep(1)

    def consume(self):
        print(&quot;开始买包子了...&quot;)
        while True:
            with self.cond:
                if self.data &amp;lt;= 5:
                    self.cond.wait()
                    print(&quot;包子太少了，等着了...&quot;)
                else:
                    self.data -= 1
                    print(&quot;我买了1个包子,还有{}个。&quot;.format(self.data))
                    self.cond.notify()
            time.sleep(2)



d = Dispatcher()
for i in range(2):
    Thread(target=d.produce).start()
for j in range(4):
    Thread(target=d.consume).start()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;开始生产包子
生产了一个包子,现在有1个。
开始生产包子
生产了一个包子,现在有2个。
开始买包子了...
开始买包子了...
开始买包子了...
开始买包子了...
生产了一个包子,现在有3个。
包子太少了，等着了...
生产了一个包子,现在有4个。
包子太少了，等着了...
生产了一个包子,现在有5个。
包子太少了，等着了...
生产了一个包子,现在有6个。
包子太少了，等着了...
生产了一个包子,现在有7个。
我买了1个包子,还有6个。
生产了一个包子,现在有7个。
我买了1个包子,还有6个。
生产了一个包子,现在有7个。
我买了1个包子,还有6个。
生产了一个包子,现在有7个。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用方法：&lt;br/&gt;使用Condition，必须先要获取锁，用完以后要释放，通常是使用with上下文，消费者如果不满足条件，wait等待通知，生产者生产好，对消费者发通知。&lt;/p&gt;
&lt;h3 id=&quot;barrier&quot;&gt;&lt;span&gt;Barrier&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;barrier，提供了简单的同步给需要相互等待的固定数量的线程使用，每个线程都会试图通过wait()方法来传递屏障，并将阻塞直到满足条件的线程数量都进行了调用，然后，将这些线程同时释放。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;10&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;6&quot;&gt;&lt;td&gt;Barrier(parties, action=None, timeout=None)&lt;/td&gt;
&lt;td&gt;构建Barrier对象，指定参与的数目。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;n_waiting&lt;/td&gt;
&lt;td&gt;当前屏障中等待的线程数&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;parties&lt;/td&gt;
&lt;td&gt;通过屏障需要等待线程数量&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;wait(time=None)&lt;/td&gt;
&lt;td&gt;等待通过屏障，返回0到线程-1的整数，每个线程返回不同。如果wiat方法设置了超时，并会超时发送，屏障将处于broken状态&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;reset()&lt;/td&gt;
&lt;td&gt;将屏障恢复为默认的空状态&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;broken()&lt;/td&gt;
&lt;td&gt;一个布尔值，True代表屏障处于断开状态。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;abort()&lt;/td&gt;
&lt;td&gt;屏障处于破碎状态，会导致任何等待或者调用的等待的方法的线程失败，抛出BrokenBarrierError。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from threading import Thread,Barrier,BrokenBarrierError,Event
import logging
import time


FORMAT = '%(asctime)s %(threadName)s %(thread)d %(message)s'
logging.basicConfig(format=FORMAT,level=logging.INFO)


def worker(barrier:Barrier):
    logging.info(&quot;waiting for {} threads.&quot;.format(barrier.n_waiting))
    try:
        barrier_id = barrier.wait()
        logging.info('after barrier {}'.format(barrier_id))
    except BrokenBarrierError:
        logging.info(&quot;Broken Barrier&quot;)

barrier = Barrier(3)
for x in range(6): #换成其他数
    Thread(target=worker,name=&quot;worker-{}&quot;.format(x),args=(barrier,)).start()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;2019-03-07 06:38:40,697 worker-0 26024 waiting for 0 threads.
2019-03-07 06:38:40,698 worker-1 4248 waiting for 1 threads.
2019-03-07 06:38:40,698 worker-2 23484 waiting for 2 threads.
2019-03-07 06:38:40,699 worker-2 23484 after barrier 2
2019-03-07 06:38:40,699 worker-0 26024 after barrier 0
2019-03-07 06:38:40,699 worker-1 4248 after barrier 1
2019-03-07 06:38:40,701 worker-3 29924 waiting for 0 threads.
2019-03-07 06:38:40,702 worker-4 29744 waiting for 1 threads.
2019-03-07 06:38:40,703 worker-5 1156 waiting for 2 threads.
2019-03-07 06:38:40,703 worker-5 1156 after barrier 2
2019-03-07 06:38:40,704 worker-3 29924 after barrier 0
2019-03-07 06:38:40,704 worker-4 29744 after barrier 1&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;semaphore&quot;&gt;&lt;span&gt;semaphore&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;信号量（semaphore）和Lock很像，信号量内部维护一个倒数计数器，每一次acquire都会减一，当计数为0时就会阻塞请求的线程，直到其他线程对信号量release后，计数如果大于0，继续恢复阻塞的线程。&lt;br/&gt;|名称|含义|&lt;br/&gt;|-----|-----|&lt;br/&gt;|Semaphore(value=1)|构造方法，value小于0，抛出ValueError|&lt;br/&gt;|acquire(blocking=True,timeout=None)|获取信号量，计数器减1，获取成功返回True|&lt;br/&gt;|release()|释放信号量，计数器加1|&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from threading import Thread,Semaphore
import time
import logging



FORMAT = '%(asctime)s %(threadName)s %(thread)d %(message)s'
logging.basicConfig(format=FORMAT,level=logging.INFO)

def task():
    with sm:
        logging.info(&quot;I get key...&quot;)
        time.sleep(4)


sm = Semaphore(5)
for _ in range(20):
    Thread(target=task).start()&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;gil&quot;&gt;&lt;span&gt;GIL&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;CPython在解释器进程级别有一把锁，叫全局解释器锁(GIL)。GIL保证在Cpython进程中，只有一个线程执行字节码，在多核CPU的情况下，也是如此。&lt;/p&gt;
&lt;p&gt;在CPython中，如果运行IO密集型程序，由于线程阻塞，就会调用其他线程。如果运行CPU密集型的程序，当前的线程可能会连续获得GIL，导致其他线程几乎无法使用CPU。所以，对于IO密集型，尽量多使用多线程。对于CPU密集型，使用多线程时候，尽量绕开GIL。&lt;/p&gt;
</description>
<pubDate>Wed, 06 Mar 2019 23:14:00 +0000</pubDate>
<dc:creator>小赵面面观</dc:creator>
<og:description>[TOC] 线程同步 线程同步，即线程之间协同工作，一个线程访问某些数据时，其他线程不能访问这些数据，直到该线程完成对数据的操作。 不同的操作系统实现的技术有所不同，有临界区(Critical Sec</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dianel/p/10487205.html</dc:identifier>
</item>
<item>
<title>震惊！博客园知名博主 Vamei 英年早逝！ - 纯洁的微笑</title>
<link>http://www.cnblogs.com/ityouknow/p/10487151.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ityouknow/p/10487151.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;http://www.itmind.net/assets/images/2019/life/Vamei4.png&quot;/&gt;&lt;br/&gt;博客首页停留在了2018-08-18&lt;/p&gt;
&lt;p&gt;大半夜的翻朋友圈突然看到这个消息，整晚无眠。&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;张腾飞， 笔名 Vamei，中国科学技术大学学士，南洋理工大学博士。著有《从Python开始学编程》等书，并写作 Java、网络协议、数据分析等方面的教程。他的博客访问量超过800万。现从事智能农业领域的创新创业，任睿畜科技首席技术官。&lt;/p&gt;
&lt;p&gt;2019年2月28日夜因抑郁症去世。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;大家都知道喜欢写博客的人，也都喜欢看博客。我每隔几天都会浏览一下各个技术社区的文章，这个习惯一致保持了快10年。特别是在我写博客的初期，专门研究了博客园推荐博客的 Top 100 的博主，那时候就注意到了 Vamei，写的文章通俗易懂，风趣幽默，受到广大读者的关注和好评。&lt;/p&gt;
&lt;p&gt;Vamei 的博客园地址：&lt;a href=&quot;https://www.cnblogs.com/vamei/&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/vamei/&lt;/a&gt; ，博客内容涉及到&lt;strong&gt;Python/Linux/网络协议/算法/Java/数据科学&lt;/strong&gt;系列文章，博文几乎涉及到了编程的各个领域，是我心目中标准的技术大神。&lt;/p&gt;
&lt;p&gt;给大家分享他在博客园的几个数字：博客园粉丝数：&lt;strong&gt;7735&lt;/strong&gt; 个，博客园积分排名在：&lt;strong&gt;157&lt;/strong&gt;，博客园总访问量超过&lt;strong&gt;800万&lt;/strong&gt;，他写的 Python 文章 62 篇几乎篇篇阅读量上万，部分文章单篇阅读量超过20万。前两天我在写&lt;a href=&quot;http://www.ityouknow.com/python/2019/02/21/python-history.html&quot;&gt;《人生苦短，我用 Python》&lt;/a&gt;时就大量引用了他的内容。&lt;/p&gt;
&lt;p&gt;在震惊之余，在网络上查找了他的相关资料，大概还原了他生前的一些故事。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.itmind.net/assets/images/2019/life/Vamei1.png&quot;/&gt;&lt;br/&gt;生前照片&lt;/p&gt;
&lt;p&gt;Vamei 真名 张腾飞 成都人，生于1988年，生前的最后一份工作是受朋友之邀担任睿畜科技的CTO，2012 开始以 Vamei 的笔名开始在博客园写作。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Vamei 的座右铭：世代傳承的意志，時代的變遷，人們的夢，只要人們繼續追求自由的答案，這一切的一切都將永不停止！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;生前写过三本书籍：&lt;/p&gt;
&lt;p&gt;大学在中国科学技术大学就读，专业是集成电路设计；博士就读于新加坡南洋理工大学，地球物理专业。这些专业貌似和编程都没有直接的关系，但他兴趣广泛特别在编程领域，比绝大部分专业出身的程序员更牛逼。&lt;/p&gt;
&lt;p&gt;读书期间总感觉大学里的创新研究离现实过于遥远，希望通过技术改变一个行业。他的创业经历和两件事有关联。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1、Vamei 的父亲曾从事畜牧业饲料、原料期货，这让他对畜牧产业也有所了解，但他本身对这个传统的行业不感兴趣。&lt;/li&gt;
&lt;li&gt;2、在大学参加的一次硬件比赛上，一个关于婴儿传感器的创业项目吸引了 Vamei 的注意，让他开始思考物联网、AI 技术能否在畜牧业迁移、应用。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;后来加入了朋友创建的公司睿畜科技，任睿畜科技首席技术官 CTO。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.itmind.net/assets/images/2019/life/Vamei2.png&quot;/&gt;&lt;br/&gt;睿畜科技公司官网&lt;/p&gt;
&lt;p&gt;睿畜科技是新加坡南洋理工大学孵化的优秀企业之一，从公开信息查询到，2018年公司获得千万元A轮融资，公司在新加坡、上海、成都均有办公区。&lt;/p&gt;
&lt;p&gt;公司的主要业务是利用 AI 技术来改造传统养猪行业，是一家专注于养猪产业智能化管理的创业公司。目前主要推出了两款产品——电子医生（eDoctor）和智能耳标（Smart ear tag），产品可实时监测生猪生理指数，帮助农场主低成本、规模化、标准化、精准化的管理猪的生理情况。&lt;/p&gt;
&lt;p&gt;到目前为止在睿畜科技公司官网上还可以看到 Vamei 的相关信息。&lt;/p&gt;
&lt;p&gt;回国之后，Vamei 有了一个幸福的家，妻子安静、温柔，坚定支持他创业，还刚刚出生了一个小儿子。外人来看真是生活美满事业有成，但大家不知道的是，他长期被抑郁症所折磨，终于这位NTU博士，在二月的最后一天离开他引以为豪的事业和家庭。&lt;/p&gt;
&lt;p&gt;永远地离开了这个人间……&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.itmind.net/assets/images/2019/life/Vamei3.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;根据世界卫生组织的数据：全球有超过3亿人患有抑郁症，遍布各个各年龄组，全球每年近80万抑郁症患者结束生命。到现在为止还经常听到身边的人说，有啥想不开的，都是性格问题等等的误解。&lt;/p&gt;
&lt;p&gt;抑郁症是一种心里疾病，他像我们正常的身体生病了是一个道理，需要吃药关环治疗。不是想开点就能好的，不要试图去感同身受他们的感受，你根本就不可能懂那种绝望的感觉，如果可以陪伴是最好的。&lt;/p&gt;
&lt;p&gt;对于我们普通的大众，唯一能做的就是不要带着有色眼镜去看待这个群体，在工作生活中把他们当作普通人，尊重他们、理解他们。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;世界很大，人生很短，珍惜我们生活的每一天！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;今夜，请大家记住这个ID：Vamei。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Vamei 是赤道附近一个台风的名字。按照气象规律，台风不常出现在赤道。所以，Vamei 是一个离群的风，无所顾忌地生长，不着边际地游荡。&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 06 Mar 2019 17:49:00 +0000</pubDate>
<dc:creator>纯洁的微笑</dc:creator>
<og:description>大半夜的翻朋友圈突然看到这个消息，整晚无眠。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ityouknow/p/10487151.html</dc:identifier>
</item>
<item>
<title>Django的rest_framework的认证组件之全局设置的源码解析 - bainianminguo</title>
<link>http://www.cnblogs.com/bainianminguo/p/10487059.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bainianminguo/p/10487059.html</guid>
<description>&lt;p&gt;前言：&lt;/p&gt;
&lt;p&gt;　　在我的上一篇博客我介绍了一下单独为某条url设置认证，但是如果我们想对所有的url设置认证，该怎么做呢？我们这篇博客就是给大家介绍一下在Rest_framework中如何实现全局的设置认证组件的功能。下面就请大家跟着我的思路看博客&lt;/p&gt;
&lt;p&gt;　　如果有对局部设置不清楚的，可以看我的上一篇博客，源码级的分析单独设置Rest_framework的认证组件：https://www.cnblogs.com/bainianminguo/p/10480887.html&lt;/p&gt;

&lt;p&gt;正文：&lt;/p&gt;
&lt;p&gt;我们在走一步流程&lt;/p&gt;
&lt;p&gt;1、进入urls路由文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
url(r'^login/', views.LoginCBV.as_view(),name=&quot;login&quot;),
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2、进入&lt;span&gt;&lt;strong&gt;as_view&lt;/strong&gt;&lt;/span&gt;这个方法，这个方法被类直接调用，那么这个方法一定会被&lt;strong&gt;&lt;span&gt;classmethod&lt;/span&gt;&lt;/strong&gt;修饰符修饰，是一个类方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
    @classmethod
    def as_view(cls, **initkwargs):
        &quot;&quot;&quot;
        Store the original class on the view function.

        This allows us to discover information about the view when we do URL
        reverse lookups.  Used for breadcrumb generation.
        &quot;&quot;&quot;
        if isinstance(getattr(cls, 'queryset', None), models.query.QuerySet):
            def force_evaluation():
                raise RuntimeError(
                    'Do not evaluate the `.queryset` attribute directly, '
                    'as the result will be cached and reused between requests. '
                    'Use `.all()` or call `.get_queryset()` instead.'
                )
            cls.queryset._fetch_all = force_evaluation

        view = super(APIView, cls).as_view(**initkwargs)
        view.cls = cls
        view.initkwargs = initkwargs

        # Note: session based authentication is explicitly CSRF validated,
        # all other authentication is CSRF exempt.
        return csrf_exempt(view)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;3、&lt;strong&gt;&lt;span&gt;as_view&lt;/span&gt;&lt;/strong&gt;这个方法，我们看到返回值为view的方法的返回值，而&lt;strong&gt;&lt;span&gt;view&lt;/span&gt;&lt;/strong&gt;这个方法又是什么？我们在&lt;span&gt;as_view&lt;/span&gt;方法中看到这样一段代码，就是执行&lt;strong&gt;&lt;span&gt;父类的as_view的方法&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
        view = super(APIView, cls).as_view(**initkwargs)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;4、进入APIView的父类的as_view方法，也就是&lt;strong&gt;&lt;span&gt;View类的as_view&lt;/span&gt;&lt;/strong&gt;方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;49&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
    @classonlymethod
    def as_view(cls, **initkwargs):
        &quot;&quot;&quot;
        Main entry point for a request-response process.
        &quot;&quot;&quot;
        for key in initkwargs:
            if key in cls.http_method_names:
                raise TypeError(&quot;You tried to pass in the %s method name as a &quot;
                                &quot;keyword argument to %s(). Don't do that.&quot;
                                % (key, cls.__name__))
            if not hasattr(cls, key):
                raise TypeError(&quot;%s() received an invalid keyword %r. as_view &quot;
                                &quot;only accepts arguments that are already &quot;
                                &quot;attributes of the class.&quot; % (cls.__name__, key))

        def view(request, *args, **kwargs):
            self = cls(**initkwargs)
            if hasattr(self, 'get') and not hasattr(self, 'head'):
                self.head = self.get
            self.request = request
            self.args = args
            self.kwargs = kwargs
            return self.dispatch(request, *args, **kwargs)
        view.view_class = cls
        view.view_initkwargs = initkwargs

        # take name and docstring from class
        update_wrapper(view, cls, updated=())

        # and possible attributes set by decorators
        # like csrf_exempt from dispatch
        update_wrapper(view, cls.dispatch, assigned=())
        return view
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;5、下面重点来分析View类的as_view方法，这个as_view方法返回是一个view方法的执行的结果，而view方法又干了什么，我们看下view方法，这个方法返回的是&lt;strong&gt;&lt;span&gt;dispatch方法&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
        def view(request, *args, **kwargs):
            self = cls(**initkwargs)
            if hasattr(self, 'get') and not hasattr(self, 'head'):
                self.head = self.get
            self.request = request
            self.args = args
            self.kwargs = kwargs
            return self.dispatch(request, *args, **kwargs)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;6、下面我们看下dispatch方法，这个&lt;strong&gt;&lt;span&gt;dispatch方法是APIView这个类&lt;/span&gt;&lt;/strong&gt;的方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;52&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
    def dispatch(self, request, *args, **kwargs):
        &quot;&quot;&quot;
        `.dispatch()` is pretty much the same as Django's regular dispatch,
        but with extra hooks for startup, finalize, and exception handling.
        &quot;&quot;&quot;
        self.args = args
        self.kwargs = kwargs
        request = self.initialize_request(request, *args, **kwargs)
        self.request = request
        self.headers = self.default_response_headers  # deprecate?

        try:
            self.initial(request, *args, **kwargs)

            # Get the appropriate handler method
            if request.method.lower() in self.http_method_names:
                handler = getattr(self, request.method.lower(),
                                  self.http_method_not_allowed)
            else:
                handler = self.http_method_not_allowed

            response = handler(request, *args, **kwargs)

        except Exception as exc:
            response = self.handle_exception(exc)

        self.response = self.finalize_response(request, response, *args, **kwargs)
        return self.response
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;7、先看这里，将源生的request进行初始化&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201903/1101486-20190306231725684-1043455602.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 8、看下&lt;strong&gt;&lt;span&gt;initialize_reques&lt;/span&gt;&lt;/strong&gt;t方法，这个方法返回了一个&lt;strong&gt;&lt;span&gt;新的Request类&lt;/span&gt;&lt;/strong&gt;的实例对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
    def initialize_request(self, request, *args, **kwargs):
        &quot;&quot;&quot;
        Returns the initial request object.
        &quot;&quot;&quot;
        parser_context = self.get_parser_context(request)

        return Request(
            request,
            parsers=self.get_parsers(),
            authenticators=self.get_authenticators(),
            negotiator=self.get_content_negotiator(),
            parser_context=parser_context
        )
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 9、因为我们这里在做认证的源码分析，我们重点看下authenticators这个属性的，也就是&lt;strong&gt;&lt;span&gt;get_authenticators方法&lt;/span&gt;&lt;/strong&gt;，这里要非常的注意，这里非常的关键，就是有&lt;span&gt;&lt;strong&gt;self.authentication_classes&lt;/strong&gt;&lt;/span&gt;这个属性&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
    def get_authenticators(self):
        &quot;&quot;&quot;
        Instantiates and returns the list of authenticators that this view can use.
        &quot;&quot;&quot;
        return [auth() for auth in self.authentication_classes]
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;重点是这个属性，大家一定要记住&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201903/1101486-20190306232053012-2118959746.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 10、下面我们接着步骤7在往后执行，看下&lt;strong&gt;&lt;span&gt;initial&lt;/span&gt;&lt;/strong&gt;这个方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201903/1101486-20190306232531912-197527132.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 11、进入这个initial这个方法，这里有3个组件，认证，权限，频率，我们重点看认证这个组件&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;45&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
    def initial(self, request, *args, **kwargs):
        &quot;&quot;&quot;
        Runs anything that needs to occur prior to calling the method handler.
        &quot;&quot;&quot;
        self.format_kwarg = self.get_format_suffix(**kwargs)

        # Perform content negotiation and store the accepted info on the request
        neg = self.perform_content_negotiation(request)
        request.accepted_renderer, request.accepted_media_type = neg

        # Determine the API version, if versioning is in use.
        version, scheme = self.determine_version(request, *args, **kwargs)
        request.version, request.versioning_scheme = version, scheme

        # Ensure that the incoming request is permitted
        self.perform_authentication(request)
        self.check_permissions(request)
        self.check_throttles(request)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201903/1101486-20190306232721294-988184534.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;12、看下认证组件的方法&lt;strong&gt;&lt;span&gt;perform_authenticatio&lt;/span&gt;&lt;/strong&gt;n这个方法，返回一个&lt;strong&gt;&lt;span&gt;request.user&lt;/span&gt;&lt;/strong&gt;这个，request是什么，我们看到在执行initial方法的时候，传了一个request进去，这个request就是&lt;strong&gt;&lt;span&gt;request.user的这个request&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
    def perform_authentication(self, request):
        &quot;&quot;&quot;
        Perform authentication on the incoming request.

        Note that if you override this and simply 'pass', then authentication
        will instead be performed lazily, the first time either
        `request.user` or `request.auth` is accessed.
        &quot;&quot;&quot;
        request.user
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 13、我们在汇过去看下inital方法传递的参数request，我们看到&lt;strong&gt;&lt;span&gt;initial方法的request是initalize_request方法&lt;/span&gt;&lt;/strong&gt;执行的结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201903/1101486-20190306232947696-404031746.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 14、下面看下initalize_request这个方法返回的是什么？返回了一个&lt;strong&gt;&lt;span&gt;request的实例对象&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
    def initialize_request(self, request, *args, **kwargs):
        &quot;&quot;&quot;
        Returns the initial request object.
        &quot;&quot;&quot;
        parser_context = self.get_parser_context(request)

        return Request(
            request,
            parsers=self.get_parsers(),
            authenticators=self.get_authenticators(),
            negotiator=self.get_content_negotiator(),
            parser_context=parser_context
        )
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 15、进入Request类，我们看下的user属性或者方法，看代码，发现这是一个&lt;span&gt;&lt;strong&gt;被propery修饰过的方法，调用这个方法的方法和调用属性的方法一样&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
    @property
    def user(self):
        &quot;&quot;&quot;
        Returns the user associated with the current request, as authenticated
        by the authentication classes provided to the request.
        &quot;&quot;&quot;
        if not hasattr(self, '_user'):
            with wrap_attributeerrors():
                self._authenticate()
        return self._user
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;16、Request这个类，我们看了下没有_user这个属性，所以会进入if的条件语句，下面我们看下&lt;strong&gt;&lt;span&gt;_authenticat&lt;/span&gt;&lt;/strong&gt;e方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
    def _authenticate(self):
        &quot;&quot;&quot;
        Attempt to authenticate the request using each authentication instance
        in turn.
        &quot;&quot;&quot;
        for authenticator in self.authenticators:
            try:
                user_auth_tuple = authenticator.authenticate(self)
            except exceptions.APIException:
                self._not_authenticated()
                raise

            if user_auth_tuple is not None:
                self._authenticator = authenticator
                self.user, self.auth = user_auth_tuple
                return

        self._not_authenticated()
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;17、这个方法有些参数大家可能也不清楚，我们在回答一下，先看下&lt;strong&gt;&lt;span&gt;authenticators，由于这个self是Request类的&lt;/span&gt;&lt;/strong&gt;一个实例对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
for authenticator in self.authenticators:
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们看下实例化&lt;strong&gt;&lt;span&gt;Request类&lt;/span&gt;&lt;/strong&gt;的传递参数&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
    def initialize_request(self, request, *args, **kwargs):
        &quot;&quot;&quot;
        Returns the initial request object.
        &quot;&quot;&quot;
        parser_context = self.get_parser_context(request)

        return Request(
            request,
            parsers=self.get_parsers(),
            authenticators=self.get_authenticators(),
            negotiator=self.get_content_negotiator(),
            parser_context=parser_context
        )
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们很清楚的可以看到authenticators这个值就是&lt;strong&gt;&lt;span&gt;get_authenticator&lt;/span&gt;&lt;/strong&gt;s这个方法的返回值，我们在看这个方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
    def get_authenticators(self):
        &quot;&quot;&quot;
        Instantiates and returns the list of authenticators that this view can use.
        &quot;&quot;&quot;
        return [auth() for auth in self.authentication_classe
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;authentication_classes&lt;/span&gt;&lt;/strong&gt;就是我们自己的配置的认证类&lt;/p&gt;


&lt;p&gt;18、在看下authenticator.authenticate这个方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201903/1101486-20190306234538292-2032106915.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 19、然后这个时候就可以看下面我们的认证配置&lt;/p&gt;
&lt;p&gt;首先定义了一个认证类，这个认证类有&lt;strong&gt;&lt;span&gt;authenticate方法，这个方法的返回值为一个元组，我已经圈起来来&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
class Book_auther(BaseAuthentication):
    def authenticate(self,request):
        token = request.GET.get(&quot;token&quot;)
        token_obj = models.Token.objects.filter(token=token).first()
        if token_obj:
            return token_obj.user.name,token_obj.token
        else:
            raise exceptions.AuthenticationFailed(&quot;验证失败&quot;)
    def authenticate_header(self,request):
        pass
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201903/1101486-20190306234730427-1139852143.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 然后在我们自己的视图类中定义了认证的类的列表，实例化我们的认证类&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
class Book_cbv(APIView):
    authentication_classes = [Book_auther,]
    def get(self,request):
        query_list = models.Book.objects.all()
        # bs = book_serializers(query_list,many=True)
        bs = bookmodelserializer(query_list,many=True,context={'request': request})


        return Response(bs.data)
    def post(self,request):
        bs = bookmodelserializer(data=request.data)
        print(request.data)
        if bs.is_valid():
            print(bs.validated_data)
            bs.save()
            return Response(bs.data)
        else:
            return Response(bs.errors)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201903/1101486-20190306234844525-887953031.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 20、这个时候，我们才能正式进入认证类的全局配置的地方，做全局配置，我们当然不能在每个视图类中配置，那么如果我们不配置这个authentication_classes这个属性呢？&lt;/p&gt;
&lt;p&gt;其实&lt;strong&gt;&lt;span&gt;APIView默认是有这个参数，如果我们没有配置，则用APIView这个类的属性&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201903/1101486-20190306235047449-1496814104.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 21、看到这句代码大家可能不懂，如果看不懂，大家可以下我的这篇博客，介绍面向对象的&lt;strong&gt;&lt;span&gt;__getattr__&lt;/span&gt;&lt;/strong&gt;方法的作用&lt;/p&gt;
&lt;p&gt;博客地址：https://www.cnblogs.com/bainianminguo/p/10475204.html&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
authentication_classes = api_settings.DEFAULT_AUTHENTICATION_CLASSES
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 22、下面我们进入api_settings这个实例，我们看到api_settings这个是APISettings类的实例对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
api_settings = APISettings(None, DEFAULTS, IMPORT_STRINGS)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;23、然后我们在看下APISettings这个类&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
class APISettings(object):
    &quot;&quot;&quot;
    A settings object, that allows API settings to be accessed as properties.
    For example:

        from rest_framework.settings import api_settings
        print(api_settings.DEFAULT_RENDERER_CLASSES)

    Any setting with string import paths will be automatically resolved
    and return the class, rather than the string literal.
    &quot;&quot;&quot;
    def __init__(self, user_settings=None, defaults=None, import_strings=None):
        if user_settings:
            self._user_settings = self.__check_user_settings(user_settings)
        self.defaults = defaults or DEFAULTS
        self.import_strings = import_strings or IMPORT_STRINGS
        self._cached_attrs = set()
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;24、看了我的博客，就会知道__getattr__这个方法的使用场景，也就知道下面这段代码实际就会执行APISettings类的__getattr__方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
    authentication_classes = api_settings.DEFAULT_AUTHENTICATION_CLASSES
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;25、下面我们看下APISettings类的__getattr__方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
    def __getattr__(self, attr):
        if attr not in self.defaults:
            raise AttributeError(&quot;Invalid API setting: '%s'&quot; % attr)

        try:
            # Check if present in user settings
            val = self.user_settings[attr]
        except KeyError:
            # Fall back to defaults
            val = self.defaults[attr]

        # Coerce import strings into classes
        if attr in self.import_strings:
            val = perform_import(val, attr)

        # Cache the result
        self._cached_attrs.add(attr)
        setattr(self, attr, val)
        return val
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201903/1101486-20190306235920022-1470785362.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在看下user_settings是是否有DEFAULT_AUTHENTICATION_CLASSES这个k值&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201903/1101486-20190306235952368-1224882602.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 然后看user_settings这个方法&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201903/1101486-20190307000224381-1434453897.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;下面就是在实例化APISettings类的时候代码，第一个参数user_settings，这个参数的值None&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201903/1101486-20190307000316818-1522502647.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 所以APISettings这个类的实例对象没有_user_settings这个属性，所以会进入if的流程中&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201903/1101486-20190307000454835-621793741.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 这个settings是什么呢？其实就是Djaong的project的settings文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201903/1101486-20190307000558967-537128061.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 所以我们就需要在settings中配置“REST_FRAMEWORK”这个属性的值为一个字典，我们看到后面如果拿不到“REST_FRAMEWORK”就会给赋值给空的字典&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201903/1101486-20190307000757862-1283549799.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 26、但是到了这里，我们字典该怎么写呢？大家一脸的懵逼了，我们可以看下这段代码，如果我们在settings没有配置“REST_FRAMEWORK”就会走下面的流程，我们看下面的流程的是什么东西&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201903/1101486-20190307001349144-43617558.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 27、self.defaults是什么，就是我们在实例时候APISetings这个类的时候传递的参数&lt;/p&gt;
&lt;p&gt; 在来回忆一下，实例化APISettings类&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201903/1101486-20190307001645944-795760903.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在看下初始化APISettings类的时候__init__方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201903/1101486-20190307001802898-1054214449.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 我们看下DEFAULTS是什么，就是下面的配置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201903/1101486-20190307001614764-669265561.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 我们模仿上面写我们的REST_FRAMEWORK&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201903/1101486-20190307002549982-190132615.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
REST_FRAMEWORK = {
    &quot;DEFAULT_AUTHENTICATION_CLASSES&quot;:(
        &quot;app1.utils.Book_auther&quot;,
    )
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt; 28、我们使用postman进行测试&lt;/p&gt;
&lt;p&gt;先使用get的方式访问book_cbv&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201903/1101486-20190307002640186-1860770381.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;然后使用post方式访问book_cbv&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201903/1101486-20190307002728353-491448564.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 最后使用post访问book_detail_cbv&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201903/1101486-20190307002822960-557251716.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 最后我们加上token在访问一次，访问了2个url，均可以访问成功&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201903/1101486-20190307002925161-38439297.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201903/1101486-20190307003004028-367328663.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 至此Rest_framework全局设置认证组件的源码剖析和实现我们多讲完了，大家请查看，并给出意见&lt;/p&gt;
</description>
<pubDate>Wed, 06 Mar 2019 16:31:00 +0000</pubDate>
<dc:creator>bainianminguo</dc:creator>
<og:description>前言： 在我的上一篇博客我介绍了一下单独为某条url设置认证，但是如果我们想对所有的url设置认证，该怎么做呢？我们这篇博客就是给大家介绍一下在Rest_framework中如何实现全局的设置认证组件</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bainianminguo/p/10487059.html</dc:identifier>
</item>
<item>
<title>如何保障Go语言基础代码质量？ - 大卡尔</title>
<link>http://www.cnblogs.com/jinsdu/p/10486645.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jinsdu/p/10486645.html</guid>
<description>&lt;h2 id=&quot;为什么要谈这个topic&quot;&gt;为什么要谈这个topic？&lt;/h2&gt;
&lt;p&gt;实践中，质量保障体系的建设，主要针对两个目标: 一是不断提高目标业务测试覆盖率，保障面向客户的产品质量；二就是尽可能的提高人效，增强迭代效率。而构建全链路质量卡点就是整个体系建设的核心手段。笔者用下图来描述这整个链路:&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/293394/201903/293394-20190306232505769-282109790.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，虽然保障业务迭代的方向性正确排在最前面，但在具体操作上，这一步需要的是强化流程规范和构建企业文化，同时对各负责人技能培训，可以说多数是软技能。而保障基础代码质量环节发力于自动化建设链路之始，是可以通过技术手段来消灭潜在的质量问题，所以构建好的话能极大的降低心智负担，非常值得关注。&lt;/p&gt;
&lt;p&gt;我们都知道，代码的好坏会直接影响到业务质量，团队协作，以及后期技术债等。有一个经典的图来描述代码质量的好坏，当能深切表达程序员的内心:&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/293394/201903/293394-20190306232522419-1362338876.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而同时我们相信，绝大部分程序员都有追求卓越的初心，且会尽可能的在自己能力范围内编写高质量的代码。&lt;/p&gt;
&lt;p&gt;但是，保障基础代码质量光靠程序员的个人素质一定是不全面，是人就会犯错，可能会疏忽。我们最需要的是一种自动化的机制来持续确保不出问题。这也是自动化的魅力，一次构建，持续收获价值。&lt;/p&gt;
&lt;p&gt;此类工具在业界一般叫linter，不同的语言有不同的实现。本文主要探究Go语言相关的。&lt;br/&gt;在介绍相关工具之前，我们先看看几个经典的代码坏味道:&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/293394/201903/293394-20190306232648434-1817989292.png&quot;/&gt;&lt;br/&gt;这段代码常规运行不会有问题，但是在一些场景下循环执行，那可能就会有问题了, 我们来看看:&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/293394/201903/293394-20190306232350120-507741700.png&quot;/&gt;&lt;br/&gt;(注:ex2是上述代码编译出的可执行文件名字)&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/293394/201903/293394-20190306232719391-224057809.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;很明显，有句柄泄露。原因也很简单，http response的body没有关闭。但这个关闭语句，一不注意也容易写错：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/293394/201903/293394-20190306233338252-349354079.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这时候如果百度挂了，上述程序程序就会因为空指针引用，造成非预期的panic，非常的不优雅。所以正确的做法应该是在err判断之后再行关闭body(关于Client.Do 具体的各种限制，大家可以参考这里: https://golang.org/pkg/net/http/#Client.Do)&lt;/p&gt;
&lt;p&gt;如此种种，此类小问题在实际编码活动中非常常见，且不容易一眼看出问题。甚至常规的测试可能也难检测出来，可谓非常棘手。好在Go语言的开发者们为我们想到了这一点，内置工具链中的vet命令，就能方便的检测到很多类似的问题。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/293394/201903/293394-20190306232823523-932091892.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还比如下面的代码场景，我在实际的测试用例和业务代码都看到过：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/293394/201903/293394-20190306232911135-479808320.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;go vet 可以很容易检测出这个问题(其他vet功能，可以参考这里: https://golang.org/cmd/vet/)。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/293394/201903/293394-20190306233645117-1245138060.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;go的工具链中，还有一个不得不提，那就是大名鼎鼎的go fmt，其了却了其他语言经常陷入的代码风格之争，是Go语言生态构建非常巧妙的地方。另外golint也是google主推的go语言代码代码风格工具，虽非强制，但强烈建议新项目适用。&lt;/p&gt;
&lt;h2 id=&quot;go-linters业界现状&quot;&gt;Go linters业界现状&lt;/h2&gt;
&lt;p&gt;上面主要说到Go工具链的内置工具，还有一些非官方的工具也比较有名，比如 &lt;a href=&quot;https://staticcheck.io/docs/checks&quot;&gt;staticcheck&lt;/a&gt;, &lt;a href=&quot;https://github.com/kisielk/errcheck&quot;&gt;errcheck&lt;/a&gt;在github上Star都较多。此类工具有个专门的的github库，收集的比较全，参见 &lt;a href=&quot;https://github.com/mre/awesome-static-analysis#go&quot;&gt;awesone-static-analysis&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;同时还有些项目旨在聚合此类工具，提供更方便的使用方式，以及一些酷炫的产品化。比如&lt;a href=&quot;https://github.com/golangci/golangci-lint&quot;&gt;golangci-lint&lt;/a&gt;, 其衍生的商业化项目，可以自动针对github PR做代码审核，对有问题的地方自动comments，比较有意思。&lt;/p&gt;
&lt;h2 id=&quot;如何才能优雅的落地linter检查&quot;&gt;如何才能优雅的落地linter检查？&lt;/h2&gt;
&lt;p&gt;linter工具必须为产品质量服务，不然就是做无用功。实践中，我们应该思考的是如何才能优雅的落地linter检查，如何才能建立有效的质量卡点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;推荐针对PR，做代码检查，保障入库代码质量。基于PR做事情是我比较看好的，因为这是调动所有研发力量，天然契合的地方。且进一步讲，这也是测试基础设施更能体现价值的地方。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;目前Github上有很多这方面的集成系统做的都比较好，能够快速的帮我们落地PR测的检查，比如Travis, Circle CI等。另外就是著名的Kubernetes社区，也自行构建了强大的Prow系统，其不光是基于CICD系统，还构建了chat ops模式，为参与Kubernetes的社区的贡献者提供了方便。&lt;/p&gt;
&lt;p&gt;细看Kubernetes库，会发现，其会针对每个PR都做如下静态检查:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;gofmt： https://github.com/kubernetes/kubernetes/blob/master/hack/verify-gofmt.sh&lt;/li&gt;
&lt;li&gt;govet: https://github.com/kubernetes/kubernetes/blob/master/hack/make-rules/vet.sh&lt;/li&gt;
&lt;li&gt;golint: https://github.com/kubernetes/kubernetes/blob/master/hack/verify-golint.sh&lt;br/&gt;因为golint只是纠正代码风格，并不是强制，所以k8s官方就弄了比较软的方案，对于当前已经存在的代码如果有问题，先排除掉(如下)。对于新生代码，如果检查失败，ci就挂掉。&lt;br/&gt;https://github.com/kubernetes/kubernetes/blob/master/hack/.golint_failures&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Kubernetes只利用了官方的几款工具, 在检测准确性上比较有保障。有了这些检查点，也能倒逼研发人员关注提交代码的质量，会迫使其在本地或者IDE上就配置好检查，确保每次提交的PR都能通过检查，不浪费CI资源。这也是合格工程师的基本要求。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;高质量的代码是业务质量保障的基础。而编写高质量的代码是技术问题，同时也应该是企业文化问题。因为当大家都开始注重技术，注重代码质量时，自然会朝着精益求精的路上行进，视糟糕的代码为仇寇。&lt;/p&gt;
&lt;p&gt;我的一位老板跟我说过，要做就做Number One。而在没达到第一的时候，那就要向业界标杆看齐，比如Netflix，Google，Facebook等。当大家都非常注重自己代码质量时，工程师才有时间去关注解决更加系统性的问题，而不用一直在Low Level徘徊。笔者深以为然。&lt;/p&gt;

&lt;p&gt;Email: jinsdu@outlook.com&lt;/p&gt;
&lt;p&gt;Blog: &lt;a href=&quot;http://www.cnblogs.com/jinsdu/&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/jinsdu/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Github: &lt;a href=&quot;https://github.com/CarlJi&quot; class=&quot;uri&quot;&gt;https://github.com/CarlJi&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 06 Mar 2019 15:58:00 +0000</pubDate>
<dc:creator>大卡尔</dc:creator>
<og:description>为什么要谈这个topic？ 实践中，质量保障体系的建设，主要针对两个目标: 一是不断提高目标业务测试覆盖率，保障面向客户的产品质量；二就是尽可能的提高人效，增强迭代效率。而构建全链路质量卡点就是整个体</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jinsdu/p/10486645.html</dc:identifier>
</item>
<item>
<title>python深拷贝与浅拷贝 - 漫漫芜</title>
<link>http://www.cnblogs.com/sheshouxin/p/10486898.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sheshouxin/p/10486898.html</guid>
<description>&lt;h3&gt;可变对象与不可变对象&lt;/h3&gt;
&lt;p&gt;要理解深拷贝和浅拷贝，首先要理解可变对象和不可变对象。&lt;/p&gt;
&lt;p&gt;不可变对象：该对象所指向的内存中的值不能被改变，修改对象的值时，由于其指向的值不能被改变，因此实际上是在内存中重新开辟一个地址用来存储新的值，然后将对象指向这个新值。本质上是两个对象，赋值前后对象id发生了变化。python中的不可变对象包括：bool、int、str、float、tuple、frozenset、None。&lt;/p&gt;
&lt;p&gt;可变对象：该对象所指向的内存中的值可以被改变。变量（引用）的值发生改变时，实际上是其指向的值直接发生改变，没有开辟新的内存地址。python中的可变对象包括：list、dict、set。&lt;/p&gt;
&lt;p&gt; python中的赋值语句不会创建对象的拷贝，仅仅只是将变量名称绑定到一个对象上。对于不可变对象，这种操作不会产生差别，但是处理可变对象或可变对象的集合时，你可能希望创建这些对象的“真实拷贝”，在修改创建的拷贝时不改变原始的对象。&lt;/p&gt;
&lt;p&gt;浅拷贝：通常指构造一个新的集合对象，然后用原始对象中的找到的子对象的引用来填充它。浅层的复制只有一层深度，复制过程中不会递归，所以不会创建子对象本身的副本。&lt;/p&gt;
&lt;p&gt;深拷贝：深拷贝使复制过程递归，即首先构造一个新的集合对象，然后递归地用在原始对象中找到的子对象的副本来填充它。通过深拷贝复制对象，是原始对象及其所有子对象的完全独立的克隆。&lt;/p&gt;
&lt;h3&gt;赋值与引用&lt;/h3&gt;
&lt;p&gt;python的赋值语句不会复制对象，而是创建一个对象的引用（可以理解为标签）。代码示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1606258/201903/1606258-20190306224445196-1251509489.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图示例中，创建了两个变量（实际两个变量表示的是同一个列表），但两个变量id相同，指向的是同一个内存地址。&lt;/p&gt;
&lt;h3&gt;创建浅拷贝&lt;/h3&gt;
&lt;p&gt;仍以python列表为例，通常我们会用list()函数来复制一个列表，这个复制过程，就是一个浅拷贝。代码示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1606258/201903/1606258-20190306225309164-1725297228.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，通过浅拷贝方式，确实是复制了一个列表。复制前后两个变量的id不同，两个变量指向两个不同的内存地址，且修改其中一个列表中的值，对另一个列表不会产生影响。&lt;/p&gt;
&lt;p&gt;而之所以称这种复制方式为浅拷贝，是因为这种拷贝只对一层对象有效，当列表中有子对象时，对子对象的修改将同时影响原始对象和拷贝对象。代码示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1606258/201903/1606258-20190306230706903-1730798565.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，修改第一层次的成员值，不会影响拷贝对象；修改子对象的成员值（第二层次），会同时影响原始对象和拷贝对象。这是因为浅拷贝没有递归复制原始对象的值，只复制了第一层，因此拷贝对象中复制了子对象的引用，并没有复制子对象的值。&lt;/p&gt;
&lt;h3&gt;创建深拷贝&lt;/h3&gt;
&lt;p&gt;python标准库中的copy模块提供了创建python对象的浅拷贝和深拷贝的接口。使用deepcopy()函数，可以创建一个对象的深拷贝。代码示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1606258/201903/1606258-20190306231808987-1545590857.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，通过深拷贝复制的对象递归克隆了原始对象，两者是完全独立的。无论怎样修改其中一个对象，都不会对另一个对象产生影响。&lt;/p&gt;
&lt;h3&gt;总结&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;不可变对象没有深拷贝和浅拷贝之分，可以理解为都是深拷贝&lt;/li&gt;
&lt;li&gt;创建对象的浅拷贝不会克隆子对象，不能完全对立与原始对象&lt;/li&gt;
&lt;li&gt;深拷贝会递归克隆原始对象，两者完全独立，互不影响，创建深拷贝的速度较慢&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Wed, 06 Mar 2019 15:27:00 +0000</pubDate>
<dc:creator>漫漫芜</dc:creator>
<og:description>可变对象与不可变对象 要理解深拷贝和浅拷贝，首先要理解可变对象和不可变对象。 不可变对象：该对象所指向的内存中的值不能被改变，修改对象的值时，由于其指向的值不能被改变，因此实际上是在内存中重新开辟一个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sheshouxin/p/10486898.html</dc:identifier>
</item>
<item>
<title>区域生长算法 全局分类 C++ &amp; matlab - 林-兮</title>
<link>http://www.cnblogs.com/lv-anchoret/p/10486891.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lv-anchoret/p/10486891.html</guid>
<description>&lt;p&gt;&lt;span&gt; &lt;strong&gt;// 注：本内容为作者原创，禁止在其他网站复述内容以及用于商业盈利，如需引用，请标明出处：&lt;a href=&quot;https://www.cnblogs.com/lv-anchoret/&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/lv-anchoret/&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/lv_anchoret/&quot; target=&quot;_blank&quot;&gt;&lt;br/&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;今天我们来介绍用C++算法如何来实现图像分割算法中的区域生长算法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://baike.baidu.com/item/%E5%8C%BA%E5%9F%9F%E7%94%9F%E9%95%BF/8366231?fr=aladdin&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;区域生长的简介&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们解决的是对一整张图像所有内容进行区域生长分类，当然，如果是对图像中的某一类型进行区域生长可能更容易一些&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;个人理解&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;区域生长算法需要确定一个阈值，这个值代表同一类图像信息灰度值的差值，比如，我要一个人脸图（假设眼睛是蓝色的），头发是黑色的但是不同光线反射原因或者位置不同，图像中显示的灰度颜色值有5、10、3等，虽然灰度值不一样，但是他们代表的都是黑色，都是头发，区域生长，就是把这些相似灰度值的一类事物统一标注显示，这也就达到了分类识别的目的，关于阈值，比如上述的头发，我们需要将所有是头发的像素点都标注出来，那么我们的阈值就应该设置为10，如果设置为3，可能灰度值为3和5的点会统一识别，但是10就被排除在外了。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;算法核心&lt;/strong&gt;&lt;/span&gt;就是一个bfs，设立一个种子点，向四周扩张，如果相邻的点的灰度值相对于种子点在阈值范围之内，那么，我们把它识别并包含统一进来，扩张完毕之后，所有相似的一类图像将被统一标注。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;关于标注我们还需要说一下，一开始，想起了四色定理，即用四种颜色就可以吧整个地图分类标注且相邻类别颜色不同，后来想了想还不如把同一类型区域中的所有点都设置为种子点灰度像素值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;之后想起来我们光线追踪一直用的ppm彩色文件格式，索性将灰度值转成rgb彩色图看着更爽&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;区域生长算法流程&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 找种子点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 扩张原则&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3. 终止条件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;数据介绍&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们的数据是一张灰度图 ： 见 &lt;a href=&quot;https://www.cnblogs.com/lv-anchoret/gallery/image/234346.html&quot; target=&quot;_blank&quot;&gt;纹理相册夹中的第二张图&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们处理输出的是一张彩色图像，图像格式是我们光线追踪的文件格式 .ppm，用我们光线追踪的图片解析器（ppmviewer）就能打开（没有的也没关系，搜索一下，下载不超过十几秒，超轻量级ppm解读器）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们都知道，C/C++ 中读取图像麻烦，特别是这种.jpg复杂格式数据，所以，我们用matlab先把图像读出来，输出到一个TXT中，存储为二维矩阵形式，然后用C++代码读取TXT文件内容，存储到一个二维数据序列中。（都有代码在后面）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们侧重实现算法本身，所以关于图像的读取和写入我们不做过多描述&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;算法介绍&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 算法自命名：首次左上区域生长算法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 时间复杂度：O(图像大小*种子数量*log（种子数量）)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;一、区域生长的三大要素确立：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）生长合并规则：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用户自定义阈值，根据种子点和当前点的差值，如果在阈值之内，那么合并，将当前点的灰度值设为种子灰度值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）种子选取：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;将图像左上角第一个点作为第一个种子，在扩张的过程中第一个不符合生长合并规则的位置，作为下一次生长的种子，即首次选定，后期自适应确定。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）算法结束：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;种子为空&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;二、优缺点&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;该算法的优点：  针对大型全局生长而衍生&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                该算法种子不会将同一个位置作为种子多次重复生长（时间空间复杂度优化）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                某个种子在开始生长时，如果已经被包含于另一个种子的生长区域中，那么该种子将不会进行生长（时间复杂度优化）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;该算法的缺点：  首次选定法不能用合适的灰度代表整个区域，只能是坐标小的点的灰度值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                生长出来的区域可能不是很完美，因为该区域是由该区域坐标最小的点生长而成的。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;三、灰度值转rgb算法设计&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为要将单一的灰度值映射到r、g、b,使其代表的颜色具有独特性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个可以自己设计，我的设计如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201903/1316111-20190306222109183-626269582.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;四、构架设计&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;含有一个类 —— regional&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;数据成员&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;_img：用于存储图像灰度矩阵&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;reset：用于记录某个位置的灰度是否被重置&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;_delt：阈值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;成员函数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;readfile：读图像灰度矩阵文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;bfs：进行区域生长&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;out：输出处理后的图像灰度矩阵&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;readout：读取处理后的图像灰度矩阵文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;gograph：将灰度图像转为rgb图像，由于ppmview显示空间有限，所以将此图划分为6块（将原图像分为3行2列的6块），分别输出6个图像&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;流程图如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201903/1316111-20190306224634170-1309990522.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;五、数据结构设计&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;：（C++描述）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用bfs算法进行的话，必然需要队列，但是种子们不能用队列去存，某个种子进行生长的时候可以用队列记录每一个生长状态&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此法采用8领域进行生长&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用队列存储当前种子生长过程中的状态点，进行bfs扩展，确定该种子生长所形成的区域&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用set容器存储各个种子，保证了种子点唯一性，即优点2，同时，set容器还会根据位置自动排序，所以导致了缺点2，其次，set容器的存取操作的时间复杂度均为O(n log n)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Bfs状态采用只包含x、y坐标的一个结构体&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;采用C++描述的首次左上区域生长算法针对2012*1881的灰度卫星图像矩阵数据处理时间为：78.9s&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201903/1316111-20190306224721782-1753825804.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;阈值为20&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201903/1316111-20190306224752907-1915076876.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    　　　　　　　　　　　　　　图1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先蓝色圈所代表的部分，如果是水域的深浅，那么这一块还是被划分的很清楚的，大致分了5部分&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;再看下阈值为25的图&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201903/1316111-20190306224819104-1793592639.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    　　　　　　　　　　　　图2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如我们所预期的那样，图1中蓝色圈的水深划分等级更少了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其次，我们看图1的红色圈代表的水体，内部中间划分出来的区域更小了，或者说水体的边缘区域扩张了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;再如，黑色圈代表的水域，中间的黑色圈有一块东西，它的区域更小了，不利于捕捉细微的水内状况&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果图1的黑色内的小黑圈部分看不太清楚，那么可以看一下下面这个，都是一样的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;XnView打开效果&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201903/1316111-20190306224847301-710046667.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　图3&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果把黄色部分看做是竖着的地质锤，那么图2显然少了锤头~&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;还有水边一片房子聚集地，也被基本划分为一种色调&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201903/1316111-20190306224916182-350311709.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　　　图4&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而针对下图以及图4以及原图上方一片森林山脉，将各种处理方法进行叠加，效果可能会更好，方案如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有很多星星点点的噪声，可以选择先去噪声，但是，效果也不是很好&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果要将其纳入到统一的大片区域中，还是选择先做一个平滑处理，将其尖锐的边缘过渡更加平滑些，再进行区域生长，加以阈值调整，星点可能会减少，可能还存在一些，但是不会那么显眼，和周围环境的色差不会那么大了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201903/1316111-20190306224947794-2075480652.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　图5&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;七、代码&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;matlab 代码&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;matlab：
&lt;br/&gt;function writetxt
 
I &lt;/span&gt;= imread(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;poyanghu.jpg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
 
fid &lt;/span&gt;= fopen(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;image.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
[x,y] &lt;/span&gt;=&lt;span&gt; size(I);
fprintf(fid,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%d %d\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,x,y);
 
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;:x
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; j = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;:y
        fprintf(fid,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%d &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,I(i,j));
    end
    fprintf(fid,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
end
 
fclose(fid);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;C++:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;regional.h&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//regional.h&lt;/span&gt;&lt;span&gt;#pragma&lt;/span&gt; once

&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; region
{
    constexpr &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; dir[&lt;span&gt;8&lt;/span&gt;][&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]
    {
        {&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;,-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;},
        {&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;},
        {&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;},
        { &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;,-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;},
        { &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;},
        { &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;,-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;},
        { &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;},
        { &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;}
    };

    constexpr size_t H &lt;/span&gt;= &lt;span&gt;2012&lt;/span&gt;&lt;span&gt;;
    constexpr size_t L &lt;/span&gt;= &lt;span&gt;1881&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; regional
    {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; pos
        {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; _x, _y;
            pos(&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; b) :_x(a), _y(b) {  }
            &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; &lt;span&gt;operator&lt;/span&gt;&amp;lt;(&lt;span&gt;const&lt;/span&gt; pos&amp;amp; p)&lt;span&gt;const&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (_x ==&lt;span&gt; p._x)
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; _y &amp;lt;&lt;span&gt; p._y;
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; _x &amp;lt;&lt;span&gt; p._x;
            }
        };

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
        regional(&lt;/span&gt;&lt;span&gt;const&lt;/span&gt;&lt;span&gt; size_t delt);

        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; readfile();

        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; bfs();

        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;out&lt;/span&gt;&lt;span&gt;();

        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; readout();

        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; gograph()&lt;span&gt;const&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;:

        &lt;/span&gt;&lt;span&gt;short&lt;/span&gt; _img[&lt;span&gt;2012&lt;/span&gt; + &lt;span&gt;1&lt;/span&gt;][&lt;span&gt;1881&lt;/span&gt; + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;];

        &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; reset[H + &lt;span&gt;1&lt;/span&gt;][L + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;];

        size_t _delt;

    };

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;regional.cpp&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
#include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;regional.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;iostream&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;fstream&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;queue&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;&lt;span&gt;set&lt;/span&gt;&amp;gt;
&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; region;

regional::regional(&lt;/span&gt;&lt;span&gt;const&lt;/span&gt;&lt;span&gt; size_t delt)
    :_delt(delt)
{
    memset(reset, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt; reset);
}


&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; regional::readfile()
{
    ifstream infile;
    infile.open(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;image.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;infile.is_open())
        cerr &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;open failed&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; x, y;
    infile &lt;/span&gt;&amp;gt;&amp;gt; x &amp;gt;&amp;gt;&lt;span&gt; y;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt;= x; ++&lt;span&gt;i)
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;1&lt;/span&gt;; j &amp;lt;= y; ++&lt;span&gt;j)
            infile &lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt; _img[i][j];
    infile.close();
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; regional::bfs()
{
    queue&lt;/span&gt;&amp;lt;pos&amp;gt;&lt;span&gt;  Qcurrent;
    &lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&amp;lt;pos&amp;gt;&lt;span&gt; Qnew;
    Qnew.insert(pos(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;));
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (Qnew.size())
    {
        Qcurrent.push(&lt;/span&gt;*&lt;span&gt;Qnew.begin());
        Qnew.erase(Qnew.begin());
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (reset[Qcurrent.front()._x][Qcurrent.front()._y])&lt;span&gt;//&lt;/span&gt;&lt;span&gt;该种子点已经访问过&lt;/span&gt;
&lt;span&gt;        {
            Qcurrent.pop();
            &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (Qcurrent.size())
        {
            pos seed &lt;/span&gt;=&lt;span&gt; Qcurrent.front();
            reset[seed._x][seed._y] &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            Qcurrent.pop();
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; trans = &lt;span&gt;0&lt;/span&gt;; trans &amp;lt; &lt;span&gt;8&lt;/span&gt;; ++&lt;span&gt;trans)
            {
                pos p(seed._x &lt;/span&gt;+ dir[trans][&lt;span&gt;0&lt;/span&gt;], seed._y + dir[trans][&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (p._x &amp;gt; &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; p._x &amp;lt;= H &amp;amp;&amp;amp; p._y &amp;gt; &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; p._y &amp;lt;= L &amp;amp;&amp;amp; !&lt;span&gt;reset[p._x][p._y])
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (abs(_img[p._x][p._y] - _img[seed._x][seed._y]) &amp;lt;&lt;span&gt; _delt)
                    {
                        _img[p._x][p._y] &lt;/span&gt;=&lt;span&gt; _img[seed._x][seed._y];
                        reset[p._x][p._y] &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                        Qcurrent.push(p);
                    }
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                        Qnew.insert(p);
            }

        }
    }
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; regional::&lt;span&gt;out&lt;/span&gt;&lt;span&gt;()
{
    ofstream outfile;
    outfile.open(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;outall.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;outfile.is_open())
        cerr &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;open failed&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt;= H; ++&lt;span&gt;i)
    {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;1&lt;/span&gt;; j &amp;lt;= L; ++&lt;span&gt;j)
            outfile &lt;/span&gt;&amp;lt;&amp;lt; _img[i][j] &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        outfile &lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt; endl;
    }
    
    outfile.close();
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; regional::readout()
{
    ifstream infile(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;outall.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;infile.is_open())
    {
        cerr &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;error open&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
    }

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt;= H; ++&lt;span&gt;i)
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;1&lt;/span&gt;; j &amp;lt;= L; ++&lt;span&gt;j)
            infile &lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt; _img[i][j];

    infile.close();
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; regional::gograph()&lt;span&gt;const&lt;/span&gt;&lt;span&gt;
{
    ofstream file;

    auto left &lt;/span&gt;= [&amp;amp;](&lt;span&gt;int&lt;/span&gt;&lt;span&gt; cnt)
    {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = (cnt - &lt;span&gt;1&lt;/span&gt;) * &lt;span&gt;700&lt;/span&gt; + &lt;span&gt;1&lt;/span&gt;; i &amp;lt;= &lt;span&gt;700&lt;/span&gt; * cnt; ++&lt;span&gt;i)
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;1&lt;/span&gt;; j &amp;lt;= &lt;span&gt;1000&lt;/span&gt;; ++&lt;span&gt;j)
                file &lt;/span&gt;&amp;lt;&amp;lt; (&lt;span&gt;int&lt;/span&gt;)((&lt;span&gt;0.2&lt;/span&gt; + &lt;span&gt;float&lt;/span&gt;(_img[i][j] % &lt;span&gt;10&lt;/span&gt;) / &lt;span&gt;10&lt;/span&gt;)*&lt;span&gt;_img[i][j])
                &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; (&lt;span&gt;int&lt;/span&gt;)((&lt;span&gt;0.5&lt;/span&gt; + &lt;span&gt;float&lt;/span&gt;(_img[i][j] % &lt;span&gt;10&lt;/span&gt;) / &lt;span&gt;10&lt;/span&gt;)*&lt;span&gt;_img[i][j])
                &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; (&lt;span&gt;int&lt;/span&gt;)((&lt;span&gt;0.7&lt;/span&gt; + &lt;span&gt;float&lt;/span&gt;(_img[i][j] % &lt;span&gt;10&lt;/span&gt;) / &lt;span&gt;10&lt;/span&gt;)*_img[i][j]) &amp;lt;&amp;lt;&lt;span&gt; endl;
    };

    auto right &lt;/span&gt;= [&amp;amp;](&lt;span&gt;int&lt;/span&gt;&lt;span&gt; cnt)
    {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = (cnt - &lt;span&gt;1&lt;/span&gt;) * &lt;span&gt;700&lt;/span&gt; + &lt;span&gt;1&lt;/span&gt;; i &amp;lt;= &lt;span&gt;700&lt;/span&gt; * cnt; ++&lt;span&gt;i)
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = L - &lt;span&gt;1000&lt;/span&gt; + &lt;span&gt;1&lt;/span&gt;; j &amp;lt;= L; ++&lt;span&gt;j)
                file &lt;/span&gt;&amp;lt;&amp;lt; (&lt;span&gt;int&lt;/span&gt;)((&lt;span&gt;0.2&lt;/span&gt; + &lt;span&gt;float&lt;/span&gt;(_img[i][j] % &lt;span&gt;10&lt;/span&gt;) / &lt;span&gt;10&lt;/span&gt;)*&lt;span&gt;_img[i][j])
                &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; (&lt;span&gt;int&lt;/span&gt;)((&lt;span&gt;0.5&lt;/span&gt; + &lt;span&gt;float&lt;/span&gt;(_img[i][j] % &lt;span&gt;10&lt;/span&gt;) / &lt;span&gt;10&lt;/span&gt;)*&lt;span&gt;_img[i][j])
                &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; (&lt;span&gt;int&lt;/span&gt;)((&lt;span&gt;0.7&lt;/span&gt; + &lt;span&gt;float&lt;/span&gt;(_img[i][j] % &lt;span&gt;10&lt;/span&gt;) / &lt;span&gt;10&lt;/span&gt;)*_img[i][j]) &amp;lt;&amp;lt;&lt;span&gt; endl;
    };

    file.open(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;slip1'.ppm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    file &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;P3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
    file &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;1000&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;700&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
    file &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;255&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
    left(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    file.close();

    file.open(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;slip2'.ppm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    file &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;P3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
    file &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;1000&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;700&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
    file &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;255&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
    right(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    file.close();

    file.open(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;slip3'.ppm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    file &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;P3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
    file &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;1000&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;700&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
    file &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;255&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
    left(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
    file.close();

    file.open(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;slip4'.ppm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    file &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;P3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
    file &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;1000&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;700&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
    file &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;255&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
    right(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
    file.close();


    file.open(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;slip5'.ppm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    file &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;P3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
    file &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;1000&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;700&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
    file &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;255&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
    left(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
    file.close();

    file.open(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;slip6'.ppm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    file &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;P3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
    file &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;1000&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;700&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
    file &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;255&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
    right(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
    file.close();

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;main.cpp&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
#include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;regional.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; region;
#include &lt;/span&gt;&amp;lt;iostream&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;fstream&amp;gt;
&lt;span&gt;#define&lt;/span&gt; stds std::

&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{

    regional reg(&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;&lt;span&gt;);
    reg.readfile();
    reg.bfs();
    reg.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt;();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;reg.readout();&lt;/span&gt;
&lt;span&gt;    reg.gograph();
    stds cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;complished&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; stds endl;

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;感谢您的阅读，生活愉快~&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 06 Mar 2019 15:26:00 +0000</pubDate>
<dc:creator>林-兮</dc:creator>
<og:description>// 注：本内容为作者原创，禁止在其他网站复述内容以及用于商业盈利，如需引用，请标明出处：https://www.cnblogs.com/lv-anchoret/ 今天我们来介绍用C++算法如何来实现</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lv-anchoret/p/10486891.html</dc:identifier>
</item>
<item>
<title>SpringMvc @InitBinder - 喜欢日向雏田一样的女子啊</title>
<link>http://www.cnblogs.com/lvbinbin2yujie/p/10459303.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lvbinbin2yujie/p/10459303.html</guid>
<description>&lt;p&gt;&lt;span&gt;这篇博客记录@InitBinder怎么起作用、起什么作用？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  首先,该注解被解析的时机，是该匹配Controller的请求执行映射的方法之前; 同时 @InitBinder标注的方法执行是多次的，一次请求来就执行一次。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  当某个Controller上的第一次请求由SpringMvc前端控制器匹配到该Controller&lt;span&gt;之后，根据Controller的 class 类型 查找 所有方法上标注了@InitBinder的方法，并且存入RequestMappingHandlerAdapter的 &lt;span&gt;initBinderCache，下次一请求执行对应业务方法之前时,可以走initBinderCache缓存,而不用再去解析@InitBinder; 所以 initBinder是controller级别的，一个controller实例中的所有@initBinder 只对该controller有效；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;功能一.注册Controller级别的 MVC属性编辑器 (属性编辑器功能就是将Web请求中的属性转成我们需要的类型) &lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;  @InitBinder唯一的一个属性value,作用是限制对哪些 @RequestMapping 方法起作用,具体筛选条件就是通过@RequestMapping方法入参来筛选，默认不写就代表对所有@RequestMapping的方法起作用;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  @InitBinder标注的方法, 方法入参和 @RequestMapping方法入参可选范围一样(这里指的是比如&lt;strong&gt;HttpServletRequest&lt;/strong&gt;、&lt;strong&gt;ModelMap&lt;/strong&gt;这些)， 通常一个入参 &lt;strong&gt;WebDataBinder&lt;/strong&gt; 就够我们使用了； @InitBinder标注的方法返回值, 必须为null，这里我理解的是&lt;span&gt;运行期&lt;/span&gt;的返回值;如果运行时返回值不为null,抛出异常 &lt;a href=&quot;mailto:“@InitBinder&quot;&gt;&lt;span&gt;“@InitBinder&lt;/span&gt;&lt;/a&gt; &lt;span&gt;methods should return void&lt;/span&gt;:”，编译时IDEA会提示@InitBinder应该返回null,但是不影响编译通过;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: java;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: true;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
@InitBinder
    public  void initBinder(WebDataBinder binder, HttpServletRequest request){
        System.out.println(request.getParameter(&quot;date&quot;));
        binder.registerCustomEditor(Date.class,new CustomDateEditor(new SimpleDateFormat(&quot;MM-dd-yyyy&quot;),false));
    }
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;  上面是一个@InitBinder的简单用法, 其中binder.registerCustomEditor(Date.class,new CustomDateEditor(new SimpleDateFormat(&quot;MM-dd-yyyy&quot;),false)); 这样一句话,作用就是将 自定义的MVC属性编辑器PropertyEditor 注册到当前binder的typeConverter的customEditors集合中,每一次请求和后端交互，&lt;span&gt;每一个Controller方法入参都会创建一个Binder对象&lt;/span&gt;,binder对象相当于来完成请求和后端之间参数类型转换的职能类;  注意，每次请求都会创建新的binder对象，就是说上次请求的customEditors不可复用 , 每次执行都会添加到当前方法入参交互的binder的customEditors中，而且每次执行真正请求方法之前，会把 匹配上的@InitBinder标注的方法执行一遍才开始处理；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  当请求中参数和方法入参开始进行转换的时候，都会先使用自定义注册的PropertyEditor，会首先根据需要的类型去binder的typeConverter的typeConverterDelegate的propertyEditorRegistry的cutomEditors集合中查找，有点绕，先记录下，typeConverterDelegate的propertyEditorRegistry就是typeConverter对象本身, 所以就是去typeConverter对象的cutomEditors寻找自定义注册的属性编辑器,又回到了原点。 比如去customEditors中根据key为Date.class查找editor,  分为两种情况，一种是找到了合适的属性编辑器,调用其setValue、setAsText方法, 之后使用getValue就得到转换后的值，  得到了转换后的值，可能不是我们想要的类型，这时候就会使用 conversionService 重新来过，放弃之前的转换；  是我们想要的类型就直接返回转换后的值; &lt;/span&gt; &lt;span&gt;第二种情况是没找到合适的属性编辑器， 直接调用 ConversionService 进行转换工作;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;上面方式是@InitBinder作为Controller级别的 SpringMvc属性编辑器,  下面记录一下全局级别（所有@Controller）的属性编辑器;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Xml中 注册全局属性编辑器到 ConfigurableWebBindingInitializer上，再将其注册到 RequestMappingHandlerAdapter里；记录原因，绑定binder的属性编辑器时候，会将当前的 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Initializer中的属性编辑器也给注册到binder中，这样就能实现全局的属性编辑器&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: java;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: true;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
&amp;lt;!--&amp;lt;mvc:annotation-driven/&amp;gt;--&amp;gt;
    &amp;lt;!--取消注解驱动的话Spring4.3就要手动注册RequestMappingHandlerMapping、RequestMappingHandlerAdapter--&amp;gt;

&amp;lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;&amp;gt;

&amp;lt;/bean&amp;gt;
&amp;lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;&amp;gt;
    &amp;lt;property name=&quot;webBindingInitializer&quot; ref=&quot;initializer1&quot;/&amp;gt;
&amp;lt;/bean&amp;gt;

&amp;lt;bean id=&quot;initializer1&quot; class=&quot;org.springframework.web.bind.support.ConfigurableWebBindingInitializer&quot;&amp;gt;
    &amp;lt;property name=&quot;propertyEditorRegistrars&quot;&amp;gt;
       &amp;lt;list&amp;gt;
            &amp;lt;bean class=&quot;demo2.MyPropertyEditor&quot;/&amp;gt;
       &amp;lt;/list&amp;gt;
    &amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/pre&gt;
&lt;p&gt;MyPropertyEditor.java&lt;/p&gt;
&lt;pre class=&quot;brush: java;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: true;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
public class MyPropertyEditor implements PropertyEditorRegistrar {

    @Override
    public void registerCustomEditors(PropertyEditorRegistry registry) {
        registry.registerCustomEditor(Date.class,new MyDateEditor());
    }

    public static class MyDateEditor extends PropertyEditorSupport {
        @Override
        public void setValue(Object value) {
            super.setValue(value);
        }

        @Override
        public void setAsText(String text) throws IllegalArgumentException {
            Date d=null;
            try {
                System.out.println(&quot;我调用自己的全局MVC属性编辑器&quot;);
                d=new SimpleDateFormat(&quot;MM-dd-yyyy&quot;).parse(text);
                setValue(d);
            } catch (ParseException e) {
                e.printStackTrace();
            }
        }
    }
}
&lt;/pre&gt;
&lt;p&gt;上面两段代码就可以注册 自定义的属性编辑器到 所有@Controller中，&lt;span&gt;相当于之前每个 Controller都使用了 @InitBinder&lt;/span&gt;;  但是这样写不太友好，SpringMvc&amp;lt;mvc:annotation-driven/&amp;gt;替我们注册的很多东西可能就没法使用了，意义不大，所以简单改造了一下： 在之前记录的Spring加载初始化容器的流程基础上改造了下;&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1550387/201903/1550387-20190301231218421-445902142.png&quot; alt=&quot;image&quot; width=&quot;900&quot; height=&quot;393&quot; border=&quot;0&quot; data-action=&quot;zoom&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;spring  XML文件仍然使用注解驱动:&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: java;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: true;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
&amp;lt;mvc:annotation-driven/&amp;gt;
&amp;lt;bean id=&quot;globalBeanDefinitionRegistry&quot; class=&quot;demo2.GlobalBeanDefinitionRegistry&quot;&amp;gt;
    &amp;lt;property name=&quot;editorRegistrars&quot;&amp;gt;
        &amp;lt;list&amp;gt;
            &amp;lt;bean class=&quot;demo2.MyPropertyEditor&quot;/&amp;gt;
        &amp;lt;/list&amp;gt;
    &amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/pre&gt;

&lt;p&gt;自定义的 GlobalBeanDefinitionRegistry代码如下:  简单说下原理，在Spring原有注解驱动的基础上，改变了webBindingInitializer，使它可以自由地配置方式添加属性编辑器；优点就是，不破坏SpringMvc注解驱动带给我们的好处，可以自定义添加属性全局的编辑器；缺点就是 代码中判断逻辑的 处理器映射器适配器 RequestMappingHandlerAdapter是硬编码的,Spring4可能还好用,Spring3突然又不支持了,同样也是有解决方案的&lt;/p&gt;
&lt;p&gt;用法其实就是在Spring初始化容器中对象之前移花接木地替换我们的 webBindingInitalizer.&lt;/p&gt;
&lt;pre class=&quot;brush: java;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: true;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
public class GlobalBeanDefinitionRegistry  implements BeanDefinitionRegistryPostProcessor {
        private PropertyEditorRegistrar[]  editorRegistrars;
    @Override
    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException {
        if(registry.containsBeanDefinition(&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;)){
            BeanDefinition beanDefinition = registry.getBeanDefinition(&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;);
            PropertyValue pv = beanDefinition.getPropertyValues().getPropertyValue(&quot;webBindingInitializer&quot;);
            BeanDefinition intializer= (BeanDefinition) pv.getValue();
            intializer.getPropertyValues().addPropertyValue(&quot;propertyEditorRegistrars&quot;,editorRegistrars);
        }
    }

    @Override
    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {

    }
    public void setEditorRegistrars(PropertyEditorRegistrar[] editorRegistrars) {
        this.editorRegistrars = editorRegistrars;
    }
&lt;/pre&gt;
&lt;pre class=&quot;brush: java;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: true;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
}
&lt;/pre&gt;
&lt;h4&gt;&lt;span&gt;因为@InitBinder方法 作为Controller级别的属性编辑器 和全局的自定义Mvc属性编辑器没有太大差别，所以下面讲一些别的用法：&lt;/span&gt;&lt;/h4&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;功能二. WebDatabinder的setFieldDefaultPrefix(String fieldDefaultPrefix)&lt;/h2&gt;
&lt;h3&gt;作用：将SpringMvc请求参数带有fieldDefaultPrefix的参数,去掉该前缀再绑定到对应请求入参上&lt;/h3&gt;
&lt;p&gt;  &lt;span&gt;想来想去，也没搞明白这个方法的意义，以及实际用途，想到一种实际中可能出现的情况，觉得是个有几率出现的事情，正好可以用该方法可以解决；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;问题：假设 后台 用两个对象来接受请求参数(SpringMvc可以做到)，Pojo、Pojo2对象，他们两个属性如下：发现两个对象都有个name属性，问题来了，前台我们不能传两个 name属性吧，那样接收肯定会出错（我这里没尝试过），原有对象不修改的基础上可行方案如下：&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: java;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: true;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
@Setter
@Getter
@ToString  // 代码整洁所以使用lombok,可以自行百度
public class Pojo {
    private String name;
    private String haircolor;
}

@Setter
@ToString
public class Pojo2 {
    private String name;
    private int age;
}
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在两个对象上各使用@ModelAttribute，来给对象分别起别名， @Initbinder这里value属性指定 别名，然后给不同的参数加上了前缀 person. 、cat.  ;注意这里的两个 &lt;span&gt;&lt;strong&gt;.&lt;/strong&gt;&lt;/span&gt; 号 &lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: java;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: true;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
 @RequestMapping(&quot;/test3&quot;)
    @ResponseBody
    public String test3(@ModelAttribute(&quot;person&quot;) Pojo person, @ModelAttribute(&quot;cat&quot;) Pojo2 cat){
        return &quot;test Response Ok!&quot;+person+&quot;,&quot;+cat;
    }

    @InitBinder(&quot;person&quot;)
    public void initPerson(WebDataBinder binder){
          binder.setFieldDefaultPrefix(&quot;person.&quot;);
    }

    @InitBinder(&quot;cat&quot;)
    public void initCat(WebDataBinder binder){
        binder.setFieldDefaultPrefix(&quot;cat.&quot;);
    }
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这样请求URL：………… &lt;a title=&quot;http://localhost:8090/initBinder/test3?person.name=lvbinbin&amp;amp;cat.name=xiaobinggan&amp;amp;haircolor=black&amp;amp;age=20&quot;&gt;test3?person.name=lvbinbin&amp;amp;cat.name=xiaobinggan&amp;amp;haircolor=black&amp;amp;age=20&lt;/a&gt; 这里前台改动的地方就是 person.name和 cat.name，而其他独有属性不需要前缀也可以对应赋给pojo、pojo2;  补充说明&lt;span&gt;,@ModelAttribute注解不可以省略，通过这个取的别名来决定哪个@InitBinder对其生效&lt;/span&gt;；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;查看效果图:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1550387/201903/1550387-20190301231219125-1016056830.png&quot; alt=&quot;image&quot; width=&quot;900&quot; height=&quot;56&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;简单记录下，因为这个 defaultPrefix 所在代码确实不好找:&lt;/p&gt;
&lt;pre class=&quot;brush: java;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: true;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
protected void doBind(MutablePropertyValues mpvs) {
                checkFieldDefaults(mpvs);    //这里就是 defaultPrefix生效的地方
                checkFieldMarkers(mpvs);
                super.doBind(mpvs);
        }
//效果就是请求中包含defaultPrefix的,将其前缀去掉保存
protected void checkFieldDefaults(MutablePropertyValues mpvs) {
        if (getFieldDefaultPrefix() != null) {
                String fieldDefaultPrefix = getFieldDefaultPrefix();
                PropertyValue[] pvArray = mpvs.getPropertyValues();
                for (PropertyValue pv : pvArray) {
                        if (pv.getName().startsWith(fieldDefaultPrefix)) {
                                String field = pv.getName().substring(fieldDefaultPrefix.length());
                                if (getPropertyAccessor().isWritableProperty(field) &amp;amp;&amp;amp; !mpvs.contains(field)) {
                                        mpvs.add(field, pv.getValue());
                                }
                                mpvs.removePropertyValue(pv);
                        }
                }
        }
}
&lt;/pre&gt;

&lt;h2&gt;功能三.WebDataBinder的setDisallowedFields(String ….disallowedFields);&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;作用：SpringMvc接收请求参数时候，有些参数禁止的，不想接收，我也没遇到过啥情况禁止接收参数，这时候可以设置setDisallowedFields不接受参数&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: java;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: true;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
 @RequestMapping(&quot;/test4&quot;)
    @ResponseBody
    public String test4(@ModelAttribute(&quot;pojo2&quot;) Pojo2 pojo){
        return &quot;test Response Ok!&quot;+pojo;
    }

    @InitBinder(&quot;pojo2&quot;)
    public void disallowFlied(WebDataBinder binder){
        binder.setDisallowedFields(&quot;age&quot;);
    }
&lt;/pre&gt;

&lt;p&gt;简单贴下效果图：&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1550387/201903/1550387-20190301231219596-1431675802.png&quot; alt=&quot;image&quot; width=&quot;900&quot; height=&quot;269&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;正好发现了日志输出证明这一点：&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1550387/201903/1550387-20190306231353088-1080966280.png&quot; alt=&quot;image&quot; width=&quot;902&quot; height=&quot;23&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那就顺便把代码贴一下，万一要用呢；  另外补充一下，disallowedFields支持 * 通配符；&lt;/p&gt;
&lt;pre class=&quot;brush: java;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: true;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
protected void checkAllowedFields(MutablePropertyValues mpvs) {
                PropertyValue[] pvs = mpvs.getPropertyValues();
                for (PropertyValue pv : pvs) {
                        String field = PropertyAccessorUtils.canonicalPropertyName(pv.getName());
                        if (!isAllowed(field)) {
                                mpvs.removePropertyValue(pv);
                                getBindingResult().recordSuppressedField(field);
                                if (logger.isDebugEnabled()) {
                                        logger.debug(&quot;Field [&quot; + field + &quot;] has been removed from PropertyValues &quot; +
                                                        &quot;and will not be bound, because it has not been found in the list of allowed fields&quot;);
                                }
                        }
                }
        }
protected boolean isAllowed(String field) {
        String[] allowed = getAllowedFields();
        String[] disallowed = getDisallowedFields();
        return ((ObjectUtils.isEmpty(allowed) || PatternMatchUtils.simpleMatch(allowed, field)) &amp;amp;&amp;amp;
                        (ObjectUtils.isEmpty(disallowed) || !PatternMatchUtils.simpleMatch(disallowed, field)));
}
&lt;/pre&gt;
&lt;pre class=&quot;brush: java;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: true;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
&lt;/pre&gt;

&lt;p&gt;@Initbinder的用法简而言之,就是Controller级别的属性编辑器,将请求中的String类型转为我们需要的参数,但是从效率、内存分析，感觉一直在创建新的属性编辑器集合，如果属性编辑器太多是不是会占用大量内存呢，那请求达到一定多的数量，这个对象是不是太多了呢？&lt;/p&gt;
</description>
<pubDate>Wed, 06 Mar 2019 15:20:00 +0000</pubDate>
<dc:creator>喜欢日向雏田一样的女子啊</dc:creator>
<og:description>这篇博客记录@InitBinder怎么起作用、起什么作用？ 首先,该注解被解析的时机，是该匹配Controller的请求执行映射的方法之前; 同时 @InitBinder标注的方法执行是多次的，一次请</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lvbinbin2yujie/p/10459303.html</dc:identifier>
</item>
<item>
<title>SpingBoot二——引入MySql数据库 - 胖喵~</title>
<link>http://www.cnblogs.com/by-dream/p/10486117.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/by-dream/p/10486117.html</guid>
<description>&lt;p&gt;　　◆&lt;strong&gt;版权声明：本文出自胖喵~的博客，转载必须注明出处。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　转载请注明出处：&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: SpingBoot二——引入MySql数据库&quot; href=&quot;https://www.cnblogs.com/by-dream/p/10486117.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/by-dream/p/10486117.html&lt;/a&gt; &lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: 阿里云部署SpingBoot服务过程记录&quot; href=&quot;https://www.cnblogs.com/by-dream/p/9957624.html&quot; target=&quot;_blank&quot;&gt;&lt;br/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;搭起一个简单的服务后，接下来我们加入数据库，通过服务去读取DB中的数据进行显示。顺便将模块划分再清晰一些。&lt;/p&gt;
&lt;p&gt;不说太多了，直接说代码吧。&lt;/p&gt;
&lt;p&gt;1、pom.xml的dependencies中入依赖&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; mybatis 数据库 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.mybatis.spring.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;mybatis-spring-boot-starter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.3.2&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; mysql 驱动 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;mysql&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;mysql-connector-java&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;        
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意这里我们引入mybatis，所有和数据库之间的操作都借助它来完成。&lt;/p&gt;
&lt;p&gt;2、resource中加入数据库配置和mapper的配置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 数据库配置&lt;/span&gt;
spring.datasource.url=jdbc:mysql://**.**.**.**:3306/rap?useUnicode=true&amp;amp;characterEncoding=utf-8&amp;amp;zeroDateTimeBehavior=convertToNull&amp;amp;allowMultiQueries=&lt;span&gt;true
spring.datasource.username&lt;/span&gt;=&lt;span&gt;root
spring.datasource.password&lt;/span&gt;=123456&lt;span&gt;
spring.datasource.driver&lt;/span&gt;-&lt;span&gt;class&lt;/span&gt;-name=&lt;span&gt;com.mysql.jdbc.Driver

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; mybatis 配置.xml文件路径&lt;/span&gt;
mybatis.mapper-locations=classpath:mapper/*.xml
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一列需要配置你的ip地址和端口，3306后面的第一个斜线后跟数据库名（也就是这里的rap）&lt;/p&gt;
&lt;p&gt;这里需要提前登录到服务上进行了建表：&lt;/p&gt;
&lt;p&gt;mysql -u root -p 后输入密码进入，创建数据库：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
create DATABASE rap;　　
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 然后建表：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;create table user (
    id bigint unsigned  &lt;/span&gt;&lt;span&gt;not&lt;/span&gt; null auto_increment comment &lt;span&gt;'&lt;/span&gt;&lt;span&gt;主键&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    gmt_create datetime  &lt;/span&gt;&lt;span&gt;not&lt;/span&gt; null comment &lt;span&gt;'&lt;/span&gt;&lt;span&gt;创建时间&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    gmt_modified datetime  &lt;/span&gt;&lt;span&gt;not&lt;/span&gt; null comment &lt;span&gt;'&lt;/span&gt;&lt;span&gt;修改时间&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    nick varchar(&lt;/span&gt;1024)  &lt;span&gt;not&lt;/span&gt; null comment &lt;span&gt;'&lt;/span&gt;&lt;span&gt;名字&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    age bigint unsigned  &lt;/span&gt;&lt;span&gt;not&lt;/span&gt; null comment &lt;span&gt;'&lt;/span&gt;&lt;span&gt;年龄&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    primary key (id)
) default charset&lt;/span&gt;=utf8 comment=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;这是一张用户表&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;插入一条数据：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
insert into user (nick, age) values (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bryan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, 27);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;建表完成后。我们还需要开启数据库远程链接。首先运行：&lt;/p&gt;
&lt;p&gt;GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY '123456'  ;&lt;br/&gt;这里的123456为你给新增权限用户设置的密码，%代表所有主机，也可以具体到你的主机ip地址&lt;br/&gt;接着运行  flush privileges;  这一步不可获取，否则不会成功。此时我们在本地远程登录到服务器上看下是否可行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/626346/201903/626346-20190306222207087-1601933625.png&quot; alt=&quot;&quot; width=&quot;214&quot; height=&quot;345&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 3、在resource中加入创建mapper：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/626346/201903/626346-20190306223545259-463969073.png&quot; alt=&quot;&quot; width=&quot;223&quot; height=&quot;84&quot;/&gt;&lt;/p&gt;
&lt;p&gt;**-mapper.xml 里面的内容有点像写sql一样，这里我们先实现一个findById的方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE mapper PUBLIC &quot;-//ibatis.apache.org//DTD Mapper 3.0//EN&quot; &quot;http://ibatis.apache.org/dtd/ibatis-3-mapper.dtd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mapper &lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt;=&quot;com.bryan.demo.dal.dao.UserMapper&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;resultMap &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;userMap&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;com.bryan.demo.dal.entity.UserDO&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;id&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;id&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;nick&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;nick&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;age&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;age&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;resultMap&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;sql &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;columns&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        id, nick, age
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;sql&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;findById&quot;&lt;/span&gt;&lt;span&gt; parameterType&lt;/span&gt;&lt;span&gt;=&quot;java.lang.Long&quot;&lt;/span&gt;&lt;span&gt; resultMap&lt;/span&gt;&lt;span&gt;=&quot;userMap&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        SELECT
        &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;include &lt;/span&gt;&lt;span&gt;refid&lt;/span&gt;&lt;span&gt;=&quot;columns&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;
        FROM user
        WHERE id = #{id}
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;mapper&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4、对应的我们需要建一个mapper的类和其对应的数据类do类：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/626346/201903/626346-20190306224040643-913121087.png&quot; alt=&quot;&quot; width=&quot;202&quot; height=&quot;98&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.bryan.demo.dal.dao;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.bryan.demo.dal.entity.UserDO;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.ibatis.annotations.Mapper;

@Mapper
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; UserMapper {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; UserDO findById(Long id);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.bryan.demo.dal.entity;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.Serializable;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; UserDO &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Serializable {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 主键
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Long id;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String nick;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getNick() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; nick;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setNick(String nick) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.nick =&lt;span&gt; nick;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getAge() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; age;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setAge(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; age) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;UserMapper类的作用就是提供数据库操作的方法，UserDO类的作用就是将数据库中的数据转化为Java数据类型；&lt;/p&gt;
&lt;p&gt;5、接下来Service层的实现：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/626346/201903/626346-20190306224602984-309275861.png&quot; alt=&quot;&quot; width=&quot;246&quot; height=&quot;88&quot;/&gt;&lt;/p&gt;
&lt;p&gt;定义接口：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.bryan.demo.service;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.bryan.demo.dal.entity.UserDO;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; UserService {
    UserDO findById(Long id);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接口的实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.bryan.demo.service.impl;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.bryan.demo.dal.dao.UserMapper;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.bryan.demo.dal.entity.UserDO;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.bryan.demo.service.UserService;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Service;

@Service
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; UserServiceImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; UserService {

    @Autowired
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; UserMapper userMapper;
    
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; UserDO findById(Long id) {

        UserDO userDO &lt;/span&gt;= userMapper.findById(1L&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; userDO;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;6、最终Controller层直接调用service的接口返回：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@RestController
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MachineInfoController {

    @Autowired
    UserService userService;

    @RequestMapping(&lt;/span&gt;&quot;/&quot;&lt;span&gt;)
    String homePage() {
        UserDO userDO &lt;/span&gt;= userService.findById(1L&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;name：&quot;+userDO.getNick() + &quot; age：&quot;+&lt;span&gt;userDO.getAge();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时我们在浏览器情况，查看：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/626346/201903/626346-20190306225604044-288276326.png&quot; alt=&quot;&quot; width=&quot;400&quot; height=&quot;192&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 好，看下整体的目录结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/626346/201903/626346-20190306225828343-504690002.png&quot; alt=&quot;&quot; width=&quot;254&quot; height=&quot;309&quot;/&gt;&lt;/p&gt;
&lt;p&gt;整理了一下关系链：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/626346/201903/626346-20190306230215123-1438554797.png&quot; alt=&quot;&quot; width=&quot;142&quot; height=&quot;101&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于本节只说数据库，所以整体的服务端的架构还没有特别的完善，下一节我会针对整体服务端架构进行分层，然后详细说明。&lt;/p&gt;
&lt;p&gt;代码我传到git上：&lt;/p&gt;



</description>
<pubDate>Wed, 06 Mar 2019 15:07:00 +0000</pubDate>
<dc:creator>胖喵~</dc:creator>
<og:description>◆版权声明：本文出自胖喵~的博客，转载必须注明出处。 转载请注明出处：https://www.cnblogs.com/by-dream/p/10486117.html 搭起一个简单的服务后，接下来我们</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/by-dream/p/10486117.html</dc:identifier>
</item>
<item>
<title>headfirst设计模式（8）—适配器模式与外观模式 - 纷飞丶</title>
<link>http://www.cnblogs.com/skyseavae/p/10486438.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/skyseavae/p/10486438.html</guid>
<description>&lt;h2&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;这一章主要讲2个模式，一个是，适配器模式（负责将一个类的接口适配成用户所期待的），另外一个是外观模式（为子系统提供一个共同的对外接口），看完的第一反应是，为什么要把它们两放在同一章，难道它们有什么不可告人的秘密？&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;难道是因为他们俩都很简单吗？不会不会，毕竟是大名鼎鼎的headfirst，怎么可能这么草率，这我是万万不相信的！&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;细想了一下，我和工作的点点滴滴，我发现，一般到项目的后期，好像都比较容易用上这两个东西...&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;当然，项目的后期并不是说一个项目自己从头发开到尾的项目，而是在它生命周期的后半段，比如适配器，用来适配老的接口，比如外观模式，用来隐藏各个子系统，各个模块的协作细节。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;不过外观模式却不一定都是在后期才发力的：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;1，前期如果系统比较复杂，在系统规划的时候，就会有意识的对系统分层，为上层模块提供一些高级的api。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;2，在系统的中期呢，开发过程中，发现子系统越来越复杂，也可以提供类似的操作。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;3，在系统后期，模块越来越多，功能越来越复杂，还有历史原因，外观模式就更加有用了，毕竟，有一个简单易用的API，比手动调用各个系统的逻辑那简直是不要太舒服！&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;为什么后期不重构？而是要做这些修修补补的工作呢？&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;举个例子，房子上有棵树，你觉得这棵树很碍事，就把树给干掉了，因为你以为，是房子上面长的，结果呢？特么是树把房子吊着的！类似的坑实在是太多了，所以，重构需谨慎，且构且珍惜。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;当然不是说重构不好，而是要综合考量各方面的因素，而且，重构也用得上这些啊，毕竟，重构不是重写...（诶，重写好像也要用）&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span&gt;适配器模式&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;先说说它是干嘛的，用通俗一点的话来讲就是，VGA转DVI，2线插头转3线插头...废话不多说，上个图就知道了&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/785526/201903/785526-20190306214720322-1506564450.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;什么？大家很想看个例子？那么我就来一个例子吧，就举一个小火鸡变成小鸭子的故事吧&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;先看看鸭子接口（对应Target）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 鸭子接口
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Duck {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 鸭叫
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; quack();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 飞行
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; fly();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后看一下火鸡的接口和实现类(对应Adaptee)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 火鸡接口
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Turkey {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 火鸡叫
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; gobble();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 飞行
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; fly();
}

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 野火鸡
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; WildTurkey &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Turkey {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; gobble() {
        System.out.println(&lt;/span&gt;&quot;咯咯&quot;&lt;span&gt;);
    }
 
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; fly() {
        System.out.println(&lt;/span&gt;&quot;我在飞，虽然我飞的很近&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;首先可以看出，它们的之间有一些共同之处，都有叫声，都可以飞行，这个也是适配的前提，有共同点！&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;如果没有共同点，是不是去隔壁的其他设计模式看看？&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;OK，接下来开始适配操作&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;火鸡适配器(Adapter)&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 火鸡适配器
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; TurkeyAdapter &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Duck {
    Turkey turkey;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;持有一个火鸡对象&lt;/span&gt;
 
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; TurkeyAdapter(Turkey turkey) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.turkey =&lt;span&gt; turkey;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 鸭叫
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; quack() {
        turkey.gobble();
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 飞行
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; fly() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;适配的时候，这里模拟飞行5次&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i= 0; i &amp;lt; 5; i++&lt;span&gt;) {
            turkey.fly();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;适配器的逻辑也很简单&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;首先，实现Duck接口，要让Client能够调用，那么首先得长得和别人一样啊&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;其次，持有一个真正的处理对象，然后再根据Duck接口来进行适配，比如这里，quack接口，就直接调用Turkey#gobble()，而fly()可能是因为某种神秘力量，需要火鸡飞行的距离和鸭子一样远，所以需要手动去适配，在这里添加了适配的代码&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;最后，适配器的作用就是把一个类转换成另外一个类，转换的时候可能需要一些逻辑上的处理，让它能符合用户的期待&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;测试下是不是成功的伪装了呢&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DuckClient {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化一只火鸡&lt;/span&gt;
        WildTurkey turkey = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; WildTurkey();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;伪装成一只鸭子&lt;/span&gt;
        Duck duck = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TurkeyAdapter(turkey);

        System.out.println(&lt;/span&gt;&quot;鸣叫:&quot;&lt;span&gt;);
        duck.quack();

        System.out.println(&lt;/span&gt;&quot;------------------&quot;&lt;span&gt;);

        System.out.println(&lt;/span&gt;&quot;飞行：&quot;&lt;span&gt;);
        duck.fly();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/785526/201903/785526-20190306214907747-1899798999.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;适配器模式模式确实很简单，但是确实也很实用，优点很明显，&lt;span class=&quot;md-expand&quot;&gt;&lt;strong&gt;&lt;span&gt;可以将目标类和适配者解耦，不需要改动原来的结构（新增了Adapter来封装了适配的逻辑），但是建议不要在系统设计阶段就盲目的使用它，增加系统的复杂度&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span&gt;外观模式&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;这个就更简单了，例子我可以举一堆，比如说，酒店前台的小姐姐，餐厅前台的小姐姐，医院的小姐姐...&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;核心思想：为子系统们提供一套通用的对外接口（高级API）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;为什么会有这样的需求呢？&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;各个子系统在设计过程中，或者在实际使用的过程中会发现，有一些通用的步骤，对于更加高的调用层来说，它们其实不需要知道底层是通过哪些步骤来实现的，更多的是，以一个统一的接口来调用。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;比如，在想在家里搞一个家庭影院，需要以下步骤：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;1，灯光不能太亮，亮度需要调低到10&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;2，需要打开投影机，并且要调整到宽屏模式&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;3，音响需要调整成环绕立体音，音量设置成5&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;4，打开DVD开始播放&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;灯光：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('c773ad03-f4be-4d52-9d79-6acf09e05f3c')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_c773ad03-f4be-4d52-9d79-6acf09e05f3c&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_c773ad03-f4be-4d52-9d79-6acf09e05f3c&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('c773ad03-f4be-4d52-9d79-6acf09e05f3c',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c773ad03-f4be-4d52-9d79-6acf09e05f3c&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 影院灯光
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TheaterLights {
    String description;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; TheaterLights(String description) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.description =&lt;span&gt; description;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; on() {
        System.out.println(description &lt;/span&gt;+ &quot; 打开&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; off() {
        System.out.println(description &lt;/span&gt;+ &quot; 关闭&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; dim(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; level) {
        System.out.println(description &lt;/span&gt;+ &quot; 亮度调节到：&quot; + level  + &quot;%&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; description;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;投影仪：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('362ed6b9-c46b-4ab1-bacb-cdd8212b14c9')&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_362ed6b9-c46b-4ab1-bacb-cdd8212b14c9&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_362ed6b9-c46b-4ab1-bacb-cdd8212b14c9&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('362ed6b9-c46b-4ab1-bacb-cdd8212b14c9',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_362ed6b9-c46b-4ab1-bacb-cdd8212b14c9&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 投影仪屏幕
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Screen {
    String description;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Screen(String description) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.description =&lt;span&gt; description;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; up() {
        System.out.println(description &lt;/span&gt;+ &quot; 上升&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; down() {
        System.out.println(description &lt;/span&gt;+ &quot; 下降&quot;&lt;span&gt;);
    }


    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; description;
    }
}
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 投影仪
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Projector {
    String description;
    DvdPlayer dvdPlayer;
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Projector(String description, DvdPlayer dvdPlayer) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.description =&lt;span&gt; description;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.dvdPlayer =&lt;span&gt; dvdPlayer;
    }
 
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; on() {
        System.out.println(description &lt;/span&gt;+ &quot; 打开&quot;&lt;span&gt;);
    }
 
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; off() {
        System.out.println(description &lt;/span&gt;+ &quot; 关闭&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; wideScreenMode() {
        System.out.println(description &lt;/span&gt;+ &quot; 调整到宽屏模式&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; tvMode() {
        System.out.println(description &lt;/span&gt;+ &quot; 调整到tv模式&quot;&lt;span&gt;);
    }
  
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; description;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;音响：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('f03d0b26-97c4-4632-a21f-e49a9a1a2d1d')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_f03d0b26-97c4-4632-a21f-e49a9a1a2d1d&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_f03d0b26-97c4-4632-a21f-e49a9a1a2d1d&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('f03d0b26-97c4-4632-a21f-e49a9a1a2d1d',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_f03d0b26-97c4-4632-a21f-e49a9a1a2d1d&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 音响
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Amplifier {
    String description;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Amplifier(String description) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.description =&lt;span&gt; description;
    }
 
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; on() {
        System.out.println(description &lt;/span&gt;+ &quot; 打开&quot;&lt;span&gt;);
    }
 
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; off() {
        System.out.println(description &lt;/span&gt;+ &quot; 关闭&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;立体声&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setStereoSound() {
        System.out.println(description &lt;/span&gt;+ &quot; 立体声模式&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;环绕声&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setSurroundSound() {
        System.out.println(description &lt;/span&gt;+ &quot; 环绕声模式&quot;&lt;span&gt;);
    }
 
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setVolume(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; level) {
        System.out.println(description &lt;/span&gt;+ &quot; 调整音量到： &quot; +&lt;span&gt; level);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; description;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;DVD播放器：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('6baa29c2-7b1d-4b09-9e07-3483eefd5ed1')&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_6baa29c2-7b1d-4b09-9e07-3483eefd5ed1&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_6baa29c2-7b1d-4b09-9e07-3483eefd5ed1&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('6baa29c2-7b1d-4b09-9e07-3483eefd5ed1',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_6baa29c2-7b1d-4b09-9e07-3483eefd5ed1&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * DVD播放器
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DvdPlayer {
    String description;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; currentTrack;
    Amplifier amplifier;
    String movie;
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; DvdPlayer(String description, Amplifier amplifier) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.description =&lt;span&gt; description;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.amplifier =&lt;span&gt; amplifier;
    }
 
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; on() {
        System.out.println(description &lt;/span&gt;+ &quot; 播放&quot;&lt;span&gt;);
    }
 
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; off() {
        System.out.println(description &lt;/span&gt;+ &quot; 关闭&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; play(String movie) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.movie =&lt;span&gt; movie;
        currentTrack &lt;/span&gt;= 0&lt;span&gt;;
        System.out.println(description &lt;/span&gt;+ &quot; 播放 \&quot;&quot; + movie + &quot;\&quot;&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; description;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;不重要的代码就折叠了，免得难得看，不使用外观模式，需要调用一堆代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 不使用外观模式
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Client {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        Amplifier amp &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Amplifier(&quot;Top-O-Line 扬声器&quot;&lt;span&gt;);
        DvdPlayer dvd &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; DvdPlayer(&quot;Top-O-Line DVD播放器&quot;&lt;span&gt;, amp);
        Projector projector &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Projector(&quot;Top-O-Line 投影仪&quot;&lt;span&gt;, dvd);
        TheaterLights lights &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; TheaterLights(&quot;客厅灯&quot;&lt;span&gt;);
        Screen screen &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Screen(&quot;投影仪银幕&quot;&lt;span&gt;);

        System.out.println(&lt;/span&gt;&quot;准备看电影...&quot;&lt;span&gt;);
        lights.dim(&lt;/span&gt;10&lt;span&gt;);
        screen.down();
        projector.on();
        projector.wideScreenMode();
        amp.on();
        amp.setSurroundSound();
        amp.setVolume(&lt;/span&gt;5&lt;span&gt;);
        dvd.on();
        dvd.play(&lt;/span&gt;&quot;夺宝奇兵&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用外观模式，一行解决：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 使用外观模式后的测试类
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FacadeClient {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; HomeTheaterFacade HOME_THEATER;
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt;{
        Amplifier amp &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Amplifier(&quot;Top-O-Line 扬声器&quot;&lt;span&gt;);
        DvdPlayer dvd &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; DvdPlayer(&quot;Top-O-Line DVD播放器&quot;&lt;span&gt;, amp);
        Projector projector &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Projector(&quot;Top-O-Line 投影仪&quot;&lt;span&gt;, dvd);
        TheaterLights lights &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; TheaterLights(&quot;客厅灯&quot;&lt;span&gt;);
        Screen screen &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Screen(&quot;投影仪银幕&quot;&lt;span&gt;);

        HOME_THEATER &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HomeTheaterFacade(amp, dvd, projector, screen, lights);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;看电影&lt;/span&gt;
        HOME_THEATER.watchMovie(&quot;夺宝奇兵&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我擦？咋还是这么多行？&lt;/p&gt;
&lt;p&gt;static块里面的代码是初始化代码，一般使用spring，都是依赖注入的东西，其实调用就一行：&lt;/p&gt;
&lt;pre&gt;
HOME_THEATER.watchMovie(&quot;夺宝奇兵&quot;&lt;span&gt;);&lt;/span&gt;
&lt;/pre&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;一键解决就是爽啊，如果说对比的话，相当于，去网上买了个床，小哥送来的是一堆零件让你组装，和小哥送来就是一张组装好了的床啊！&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;但是能够一键解决的，更多的是一些通用的操作，比如说，例子中，灯光不能太亮，你想把它调到5，不想用默认的10,，那么可能就只能自己写一遍外观模式封装的逻辑了。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;那么这里就有个问题了，能不能重载方法，让它支持可以自定义灯光亮度这个参数呢？对于这个我只能说，要看业务需求了，如果100个人里面只有1个人用，那么对于系统产生的复杂度可能比 产生的价值高，反过来，可能就需要去实现。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;但是，如果这种需求越来越多，系统变得越来越复杂，那外观模式还是一个简单可爱的小姐姐吗？如果不实现，就无法达到隐藏子系统复杂度的痛点，如果实现，就会产生新的API调用的复杂度，我终于知道为啥我特么还在学习设计模式了...&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;说了这么多，说说它的优缺点吧&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;优点：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;1，对客户屏蔽了子系统组件使用起来门槛更低。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;2，实现了子系统与客户之间的松耦合关系。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;3，虽然提供了访问子系统的统一入口，但是并不影响用户直接使用子系统类。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;缺点：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;1，通过外观类访问子系统时，减少了可变性和灵活性。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;2，在新的子系统加入，或者子系统接口变更时，可能需要修改外观类或客户端的源代码，违背了“开闭原则”。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 06 Mar 2019 14:04:00 +0000</pubDate>
<dc:creator>纷飞丶</dc:creator>
<og:description>前言 这一章主要讲2个模式，一个是，适配器模式（负责将一个类的接口适配成用户所期待的），另外一个是外观模式（为子系统提供一个共同的对外接口），看完的第一反应是，为什么要把它们两放在同一章，难道它们有什</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/skyseavae/p/10486438.html</dc:identifier>
</item>
</channel>
</rss>