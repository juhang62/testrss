<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>C#/.NET基于Topshelf创建Windows服务的守护程序作为服务启动的客户端桌面程序不显示UI界面的问题分析和解决方案 - Rector</title>
<link>http://www.cnblogs.com/bobositlife/p/10918354.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bobositlife/p/10918354.html</guid>
<description>&lt;p&gt;&lt;strong&gt;本文首发于：&lt;a href=&quot;https://codedefault.com/p/create-daemon-service-with-topshelf-in-csharp-application&quot;&gt;码友网&lt;/a&gt;&lt;/strong&gt;--一个专注.NET/.NET Core开发的编程爱好者社区。&lt;/p&gt;
&lt;h2 id=&quot;文章目录&quot;&gt;文章目录&lt;/h2&gt;
&lt;p&gt;C#/.NET基于Topshelf创建Windows服务的系列文章目录：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://codedefault.com/p/create-windows-service-with-topshelf-in-csharp-console-application&quot;&gt;C#/.NET基于Topshelf创建Windows服务程序及服务的安装和卸载&lt;/a&gt; (1)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://codedefault.com/p/create-daemon-service-with-topshelf-in-csharp-application&quot;&gt;在C#/.NET应用程序开发中创建一个基于Topshelf的应用程序守护进程(服务)&lt;/a&gt; (2)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://codedefault.com/p/launch-a-gui-application-from-a-windows-service-on-windows&quot;&gt;C#/.NET基于Topshelf创建Windows服务的守护程序作为服务启动的客户端桌面程序不显示UI界面的问题分析和解决方案&lt;/a&gt; (3)&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;在上一篇文章《在C#/.NET应用程序开发中创建一个基于Topshelf的应用程序守护进程(服务)》的最后，我给大家抛出了一个遗留的问题--在将&lt;code&gt;TopshelfDemoService&lt;/code&gt;程序作为Windows服务安装的情况下，由它守护并启动的客户端程序是没有UI界面的。到这里，我们得分析为什么会出现这个问题，为什么在桌面应用程序模式下可以显示UI界面，而在服务模式下没有UI界面？&lt;/p&gt;
&lt;h2 id=&quot;分析问题session-0-隔离&quot;&gt;分析问题(Session 0 隔离)&lt;/h2&gt;
&lt;p&gt;通过查阅资料，这是由于&lt;strong&gt;Session 0 隔离&lt;/strong&gt;作用的结果。那么什么又是Session 0 隔离呢？&lt;/p&gt;
&lt;p&gt;在Windows XP、Windows Server 2003 或早期Windows 系统时代，当第一个用户登录系统后服务和应用程序是在同一个Session 中运行的。这就是Session 0 如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://statics.codedefault.com/uploads/u/2019/04/5dvzuy9737.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是这种运行方式提高了系统安全风险，因为服务是通过提升了用户权限运行的，而应用程序往往是那些不具备管理员身份的普通用户运行的，其中的危险显而易见。&lt;/p&gt;
&lt;p&gt;从Vista 开始Session 0 中只包含系统服务，其他应用程序则通过分离的Session 运行，将服务与应用程序隔离提高系统的安全性。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://statics.codedefault.com/uploads/u/2019/04/o0v4k5ig4q.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样使得Session 0 与其他Session 之间无法进行交互，不能通过服务向桌面用户弹出信息窗口、UI 窗口等信息。这也就是为什么刚才我说那个图已经不能通过当前桌面进行截图了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://statics.codedefault.com/uploads/u/2019/04/2g8r627ksz.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;潜在的问题&quot;&gt;潜在的问题&lt;/h2&gt;
&lt;h2 id=&quot;解决方案&quot;&gt;解决方案&lt;/h2&gt;
&lt;p&gt;在了解了Session 0 隔离之后，给出一些有关创建服务程序以及由服务托管的驱动程序的建议：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;1、与应用程序通信时，使用RPC、命名管道等C/S模式代替窗口消息&lt;br/&gt;2、如果服务程序需要UI与用户交互的话，有两种方式：&lt;br/&gt;①用WTSSendMessage来创建一个消息框与用户交互&lt;br/&gt;②使用一个代理（agent）来完成跟用户的交互，服务程序通过CreateProcessAsUser创建代理。&lt;br/&gt;并用RPC或者命名管道等方式跟代理通信，从而完成复杂的界面交互。&lt;br/&gt;3、应该在用户的Session中查询显示属性，如果在Session 0中做这件事，将会得到不正确的结果。&lt;br/&gt;4、明确地使用Local或者Global为命名对象命名，Local/为Session//BaseNamedObject/，Global/为BaseNamedObject/&lt;br/&gt;5、将程序放在实际环境中测试是最好的方法，如果条件不允许，可以在XP的FUS下测试。在XP的FUS下能工作的服务程序将很可能可以在新版系统中工作，注意XP的FUS下的测试不能检测到在Session 0下跟视频驱动有关的问题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文我们的服务程序将通过CreateProcessAsUser创建代理来实现Session 0隔离的穿透。&lt;/p&gt;
&lt;p&gt;在项目[TopshelfDemoService]中创建一个静态扩展帮助类&lt;code&gt;ProcessExtensions.cs&lt;/code&gt;，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;using System;
using System.Runtime.InteropServices;

namespace TopshelfDemoService
{
    /// &amp;lt;summary&amp;gt;
    /// 进程静态扩展类
    /// &amp;lt;/summary&amp;gt;
    public static class ProcessExtensions
    {
        #region Win32 Constants

        private const int CREATE_UNICODE_ENVIRONMENT = 0x00000400;
        private const int CREATE_NO_WINDOW = 0x08000000;

        private const int CREATE_NEW_CONSOLE = 0x00000010;

        private const uint INVALID_SESSION_ID = 0xFFFFFFFF;
        private static readonly IntPtr WTS_CURRENT_SERVER_HANDLE = IntPtr.Zero;

        #endregion

        #region DllImports

        [DllImport(&quot;advapi32.dll&quot;, EntryPoint = &quot;CreateProcessAsUser&quot;, SetLastError = true, CharSet = CharSet.Ansi, CallingConvention = CallingConvention.StdCall)]
        private static extern bool CreateProcessAsUser(
            IntPtr hToken,
            String lpApplicationName,
            String lpCommandLine,
            IntPtr lpProcessAttributes,
            IntPtr lpThreadAttributes,
            bool bInheritHandle,
            uint dwCreationFlags,
            IntPtr lpEnvironment,
            String lpCurrentDirectory,
            ref STARTUPINFO lpStartupInfo,
            out PROCESS_INFORMATION lpProcessInformation);

        [DllImport(&quot;advapi32.dll&quot;, EntryPoint = &quot;DuplicateTokenEx&quot;)]
        private static extern bool DuplicateTokenEx(
            IntPtr ExistingTokenHandle,
            uint dwDesiredAccess,
            IntPtr lpThreadAttributes,
            int TokenType,
            int ImpersonationLevel,
            ref IntPtr DuplicateTokenHandle);

        [DllImport(&quot;userenv.dll&quot;, SetLastError = true)]
        private static extern bool CreateEnvironmentBlock(ref IntPtr lpEnvironment, IntPtr hToken, bool bInherit);

        [DllImport(&quot;userenv.dll&quot;, SetLastError = true)]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static extern bool DestroyEnvironmentBlock(IntPtr lpEnvironment);

        [DllImport(&quot;kernel32.dll&quot;, SetLastError = true)]
        private static extern bool CloseHandle(IntPtr hSnapshot);

        [DllImport(&quot;kernel32.dll&quot;)]
        private static extern uint WTSGetActiveConsoleSessionId();

        [DllImport(&quot;Wtsapi32.dll&quot;)]
        private static extern uint WTSQueryUserToken(uint SessionId, ref IntPtr phToken);

        [DllImport(&quot;wtsapi32.dll&quot;, SetLastError = true)]
        private static extern int WTSEnumerateSessions(
            IntPtr hServer,
            int Reserved,
            int Version,
            ref IntPtr ppSessionInfo,
            ref int pCount);

        #endregion

        #region Win32 Structs

        private enum SW
        {
            SW_HIDE = 0,
            SW_SHOWNORMAL = 1,
            SW_NORMAL = 1,
            SW_SHOWMINIMIZED = 2,
            SW_SHOWMAXIMIZED = 3,
            SW_MAXIMIZE = 3,
            SW_SHOWNOACTIVATE = 4,
            SW_SHOW = 5,
            SW_MINIMIZE = 6,
            SW_SHOWMINNOACTIVE = 7,
            SW_SHOWNA = 8,
            SW_RESTORE = 9,
            SW_SHOWDEFAULT = 10,
            SW_MAX = 10
        }

        private enum WTS_CONNECTSTATE_CLASS
        {
            WTSActive,
            WTSConnected,
            WTSConnectQuery,
            WTSShadow,
            WTSDisconnected,
            WTSIdle,
            WTSListen,
            WTSReset,
            WTSDown,
            WTSInit
        }

        [StructLayout(LayoutKind.Sequential)]
        private struct PROCESS_INFORMATION
        {
            public IntPtr hProcess;
            public IntPtr hThread;
            public uint dwProcessId;
            public uint dwThreadId;
        }

        private enum SECURITY_IMPERSONATION_LEVEL
        {
            SecurityAnonymous = 0,
            SecurityIdentification = 1,
            SecurityImpersonation = 2,
            SecurityDelegation = 3,
        }

        [StructLayout(LayoutKind.Sequential)]
        private struct STARTUPINFO
        {
            public int cb;
            public String lpReserved;
            public String lpDesktop;
            public String lpTitle;
            public uint dwX;
            public uint dwY;
            public uint dwXSize;
            public uint dwYSize;
            public uint dwXCountChars;
            public uint dwYCountChars;
            public uint dwFillAttribute;
            public uint dwFlags;
            public short wShowWindow;
            public short cbReserved2;
            public IntPtr lpReserved2;
            public IntPtr hStdInput;
            public IntPtr hStdOutput;
            public IntPtr hStdError;
        }

        private enum TOKEN_TYPE
        {
            TokenPrimary = 1,
            TokenImpersonation = 2
        }

        [StructLayout(LayoutKind.Sequential)]
        private struct WTS_SESSION_INFO
        {
            public readonly UInt32 SessionID;

            [MarshalAs(UnmanagedType.LPStr)]
            public readonly String pWinStationName;

            public readonly WTS_CONNECTSTATE_CLASS State;
        }

        #endregion

        // Gets the user token from the currently active session
        private static bool GetSessionUserToken(ref IntPtr phUserToken)
        {
            var bResult = false;
            var hImpersonationToken = IntPtr.Zero;
            var activeSessionId = INVALID_SESSION_ID;
            var pSessionInfo = IntPtr.Zero;
            var sessionCount = 0;

            // Get a handle to the user access token for the current active session.
            if (WTSEnumerateSessions(WTS_CURRENT_SERVER_HANDLE, 0, 1, ref pSessionInfo, ref sessionCount) != 0)
            {
                var arrayElementSize = Marshal.SizeOf(typeof(WTS_SESSION_INFO));
                var current = pSessionInfo;

                for (var i = 0; i &amp;lt; sessionCount; i++)
                {
                    var si = (WTS_SESSION_INFO)Marshal.PtrToStructure(current, typeof(WTS_SESSION_INFO));
                    current += arrayElementSize;

                    if (si.State == WTS_CONNECTSTATE_CLASS.WTSActive)
                    {
                        activeSessionId = si.SessionID;
                    }
                }
            }

            // If enumerating did not work, fall back to the old method
            if (activeSessionId == INVALID_SESSION_ID)
            {
                activeSessionId = WTSGetActiveConsoleSessionId();
            }

            if (WTSQueryUserToken(activeSessionId, ref hImpersonationToken) != 0)
            {
                // Convert the impersonation token to a primary token
                bResult = DuplicateTokenEx(hImpersonationToken, 0, IntPtr.Zero,
                    (int)SECURITY_IMPERSONATION_LEVEL.SecurityImpersonation, (int)TOKEN_TYPE.TokenPrimary,
                    ref phUserToken);

                CloseHandle(hImpersonationToken);
            }

            return bResult;
        }

        public static bool StartProcessAsCurrentUser(string appPath, string cmdLine = null, string workDir = null, bool visible = true)
        {
            var hUserToken = IntPtr.Zero;
            var startInfo = new STARTUPINFO();
            var procInfo = new PROCESS_INFORMATION();
            var pEnv = IntPtr.Zero;
            int iResultOfCreateProcessAsUser;

            startInfo.cb = Marshal.SizeOf(typeof(STARTUPINFO));

            try
            {
                if (!GetSessionUserToken(ref hUserToken))
                {
                    throw new Exception(&quot;StartProcessAsCurrentUser: GetSessionUserToken failed.&quot;);
                }

                uint dwCreationFlags = CREATE_UNICODE_ENVIRONMENT | (uint)(visible ? CREATE_NEW_CONSOLE : CREATE_NO_WINDOW);
                startInfo.wShowWindow = (short)(visible ? SW.SW_SHOW : SW.SW_HIDE);
                startInfo.lpDesktop = &quot;winsta0\\default&quot;;

                if (!CreateEnvironmentBlock(ref pEnv, hUserToken, false))
                {
                    throw new Exception(&quot;StartProcessAsCurrentUser: CreateEnvironmentBlock failed.&quot;);
                }

                if (!CreateProcessAsUser(hUserToken,
                    appPath, // Application Name
                    cmdLine, // Command Line
                    IntPtr.Zero,
                    IntPtr.Zero,
                    false,
                    dwCreationFlags,
                    pEnv,
                    workDir, // Working directory
                    ref startInfo,
                    out procInfo))
                {
                    iResultOfCreateProcessAsUser = Marshal.GetLastWin32Error();
                    throw new Exception(&quot;StartProcessAsCurrentUser: CreateProcessAsUser failed.  Error Code -&quot; + iResultOfCreateProcessAsUser);
                }

                iResultOfCreateProcessAsUser = Marshal.GetLastWin32Error();
            }
            finally
            {
                CloseHandle(hUserToken);
                if (pEnv != IntPtr.Zero)
                {
                    DestroyEnvironmentBlock(pEnv);
                }
                CloseHandle(procInfo.hThread);
                CloseHandle(procInfo.hProcess);
            }

            return true;
        }

    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改&lt;code&gt;ProcessHelper.cs&lt;/code&gt;为如下代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;

namespace TopshelfDemoService
{
    /// &amp;lt;summary&amp;gt;
    /// 进程处理帮助类
    /// &amp;lt;/summary&amp;gt;
    internal class ProcessorHelper
    {
        /// &amp;lt;summary&amp;gt;
        /// 获取当前计算机所有的进程列表(集合)
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public static List&amp;lt;Process&amp;gt; GetProcessList()
        {
            return GetProcesses().ToList();
        }

        /// &amp;lt;summary&amp;gt;
        /// 获取当前计算机所有的进程列表(数组)
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public static Process[] GetProcesses()
        {
            var processList = Process.GetProcesses();
            return processList;
        }

        /// &amp;lt;summary&amp;gt;
        /// 判断指定的进程是否存在
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;processName&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public static bool IsProcessExists(string processName)
        {
            return Process.GetProcessesByName(processName).Length &amp;gt; 0;
        }

        /// &amp;lt;summary&amp;gt;
        /// 启动一个指定路径的应用程序
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;applicationPath&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;args&quot;&amp;gt;&amp;lt;/param&amp;gt;
        public static void RunProcess(string applicationPath, string args = &quot;&quot;)
        {
            try
            {
                ProcessExtensions.StartProcessAsCurrentUser(applicationPath, args);
            }
            catch (Exception e)
            {
                var psi = new ProcessStartInfo
                {
                    FileName = applicationPath,
                    WindowStyle = ProcessWindowStyle.Normal,
                    Arguments = args
                };
                Process.Start(psi);
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;其中更改了方法&lt;code&gt;RunProcess()&lt;/code&gt;的调用方式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;重新编译服务程序项目[TopshelfDemoService]，并将它作为Windows服务安装，最后启动服务。守护进程服务将启动一个带UI界面的客户端程序。大功告成！！！&lt;/p&gt;
&lt;p&gt;我是Rector，希望本文的关于Topshelf服务和守护程序设计对需要的朋友有所帮助。&lt;/p&gt;
&lt;p&gt;感谢花你宝贵的时间阅读！！！&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/gnielee/archive/2010/04/07/session0-isolation-part1.html&quot;&gt;穿透Session 0 隔离（一）&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/wk89665944/article/details/53927028&quot;&gt;Windows中Session 0隔离对服务程序和驱动程序的影响&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://github.com/murrayju/CreateProcessAsUser&quot;&gt;CreateProcessAsUser&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;源代码下载&quot;&gt;源代码下载&lt;/h2&gt;
&lt;p&gt;本示例代码托管地址可以在原出处找到：&lt;a href=&quot;https://codedefault.com/p/launch-a-gui-application-from-a-windows-service-on-windows&quot;&gt;示例代码下载地址&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 24 May 2019 07:23:00 +0000</pubDate>
<dc:creator>Rector</dc:creator>
<og:description>本文首发于： '码友网' 一个专注.NET/.NET Core开发的编程爱好者社区。 文章目录 C /.NET基于Topshelf创建Windows服务的系列文章目录： 1. 'C /.NET基于To</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bobositlife/p/10918354.html</dc:identifier>
</item>
<item>
<title>复杂度分析 - 不该相遇在秋天</title>
<link>http://www.cnblogs.com/fengyumeng/p/10918037.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fengyumeng/p/10918037.html</guid>
<description>&lt;p&gt;　　同一个问题可以使用不同的算法解决，那么不同的算法孰优孰劣如何区分呢？因此我们需要一个表示方法来代表每个程序的效率。&lt;/p&gt;

&lt;p&gt;　　衡量一个程序好坏的标准，一般是运行时间与占用内存两个指标。&lt;/p&gt;
&lt;p&gt;　　不过我们在写代码的时候肯定无法去估量程序的执行时间，因为真实的执行时间受到多方面因素的影响，比如同样一段程序，放在高配服务器上跑和放在低配服务器上跑完全是两个表现效果，比如遍历一个数组的函数，执行时间完全取决于调用函数传入的数组大小。&lt;/p&gt;

&lt;p&gt;　　如何在不运行程序的情况下，判断出代码的执行时间呢？显然是不可能的。&lt;/p&gt;

&lt;p&gt;　　不过我们虽然无法预估代码的绝对执行时间，但是我们可以预估代码基本的执行次数。&lt;/p&gt;
&lt;p&gt;　　一段代码的执行时间如果有变化，则一定是受到外部输入的数据所影响，我们将代码中所有不变的因素，表示为大O，将变化的因素作为基数n，表示为：O(n)，大O的意思是忽略重要项以外的内容，我们常以这种大O表示法来判断比较各种算法的执行效率。&lt;/p&gt;

&lt;p&gt;　　接下来我会介绍几种常用的复杂度表示方法。&lt;/p&gt;

&lt;p&gt;　　PS:专业的解释必然全篇都是数学证明，未免太过于复杂，让学者更加迷茫，我这里写的并不是教材，而是最直白的理解。&lt;/p&gt;

&lt;h3&gt;时间复杂度&lt;/h3&gt;
&lt;p&gt;　　本节中例举的各种时间复杂度以好到差依次排序。&lt;/p&gt;
&lt;h4&gt;常数时间 O(1)&lt;/h4&gt;
&lt;p&gt;　　先看下这个函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; test(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n)
    {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; a = 2&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; b = 3&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; c = a+&lt;span&gt;b;
        System.out.println(c);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　一共4行代码，CPU要将a的值写入内存，b的值写入内存，a和b进行计算，将计算结果写入c，最后将c输出到控制台。&lt;/p&gt;
&lt;p&gt;　　尽管计算机内部要做这么多事情，这段代码的时间复杂度依然是&lt;strong&gt;O(1)&lt;/strong&gt;，原因是这几行代码所做的操作是固定的，是不变的因素。&lt;/p&gt;

&lt;p&gt;　　再看下这个函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; test(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n)
    {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;100000;i++&lt;span&gt;){
            System.out.println(i);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　循环10W次，可能你觉得功耗可能有点大，不过它的时间复杂度仍然是O(1)。&lt;/p&gt;

&lt;p&gt;　　我们可以这么固定的认为：&lt;strong&gt;无论接收的参数怎么变化，只要代码执行次数是无变化的，则用1来表示。 &lt;/strong&gt;凡是O(1)复杂度的代码，通常代表着它是效率最优的方案。&lt;/p&gt;

&lt;h4&gt;对数时间 O(log n)&lt;/h4&gt;
&lt;p&gt;　　普遍性的说法是复杂度减半，就像纸张对折。&lt;/p&gt;
&lt;p&gt;　　示例代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; test(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n)
    {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j=1;j&amp;lt;=n;j=j*2&lt;span&gt;){
            System.out.println(j);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这段代码的执行效果并非是一次折半，它是次次折半，以2为底，不断的进行幂运算，实际上只要有幂指数关系的，&lt;strong&gt;不管你的底数是几，只要能够对原复杂度进行求幂逆运算我们都可以称之为O(log n)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　比如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; test(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n)
    {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j=1;j&amp;lt;=n;j=j*3&lt;span&gt;){
            System.out.println(j);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在忽略系数、常数、底数之后，最后都可以表示为O(log n)，只不过我们遇到的算法几乎不会出现一些极端例外情况，对数时间的所在地常见以二分查找为代表。&lt;/p&gt;

&lt;h4&gt;线性时间 O(n)&lt;/h4&gt;
&lt;p&gt;　　我们将test方法稍稍修改一下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; test(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n)
    {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;n;i++&lt;span&gt;){
            System.out.println(i);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　修改之后这次不是执行10W次，而是执行n次，n是由参数传入的一个未知值，在没有真实运行的时候我们无法判断这个n到底是多少？因为它可以是任意int型数字，你可以这么认为：在理想的情况下，它的复杂度是O(1)，在恶劣的情况下，它的复杂度是无限大。完全取决于方法调用方。&lt;/p&gt;
&lt;p&gt;　　直白的说，for循环就是循环n次，因此这段代码的时间复杂度为&lt;strong&gt;O(n)&lt;/strong&gt;，这种复杂度常常表现为线性查找。&lt;/p&gt;

&lt;h4&gt;线性对数时间 O(n log n)&lt;/h4&gt;
&lt;p&gt;　　线性对数时间也就是线性时间嵌套对数时间：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; t(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n){
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;n;i++&lt;span&gt;){
            test(n);
        }
    }
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; test(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n)
    {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j=1;j&amp;lt;=n;j=j*2&lt;span&gt;){
            System.out.println(j);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　t这个方法的时间复杂度就是&lt;strong&gt;O(n log n)&lt;/strong&gt;。&lt;/p&gt;

&lt;h4&gt;平方时间 O(n^2)&lt;/h4&gt;
&lt;p&gt;　　平方时间就是执行程序需要的步骤数是输入参数的平方，最常见的是嵌套循环：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; test(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n)
    {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;n;i++&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j=n;j&amp;gt;0;j--&lt;span&gt;){
                System.out.println(j);
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;其他时间&lt;/h4&gt;
&lt;p&gt;　　比O(n^2)还要慢的自然有立方级O(n^3)&lt;/p&gt;
&lt;p&gt;　　比O(n^3)更慢慢的还有指数级O(2^n)&lt;/p&gt;
&lt;p&gt;　　慢到运行一次程序要绕地球三百圈的有O(n!)&lt;/p&gt;

&lt;p&gt;　　正常情况下我们不会接触到这些类型的算法。&lt;/p&gt;

&lt;h3&gt;空间复杂度&lt;/h3&gt;
&lt;p&gt;　　所谓空间，就是程序运行占用的内存空间，空间复杂度指的就是执行算法的空间成本。&lt;/p&gt;

&lt;p&gt;　　这里我们抛一道题来做例子：&lt;strong&gt;在一个数组中找出有重复的值，如数组[3,8,13,7,15,8,6,6] 找出8和6&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;　　解法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; test(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] arr)
    {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;arr.length;i++&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; j=0;j&amp;lt;i;j++&lt;span&gt;){
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(arr[j] ==&lt;span&gt; arr[i]){
                    System.out.println(&lt;/span&gt;&quot;找到了：&quot;+&lt;span&gt;arr[i]);
                }
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　很显然：时间复杂度为O(n^2)。&lt;/p&gt;

&lt;p&gt;　　那我们还可以使用一种更优的解法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; test(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] arr)
    {
        HashSet hashSet &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HashSet();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;arr.length;i++&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(hashSet.contains(arr[i])){
                System.out.println(&lt;/span&gt;&quot;找到了：&quot;+&lt;span&gt;arr[i]);
            }
            hashSet.add(arr[i]);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　也许你会惊讶的发现，时间复杂度被优化成了O(n)。&lt;/p&gt;

&lt;p&gt;　　虽然时间复杂度降低成了O(n)，但是付出的代价是空间复杂度变成了O(n)，因为新的解法使用了一个HashSet来存储数据，存储数据自然要占用内存空间，而占用的空间大小完全取决于传入数组大小。&lt;/p&gt;
&lt;p&gt;　　我们之所以说第二种解法更优，其实是一种常规思想，因为现实中绝大部分情况，时间复杂度显然比空间复杂度更为重要，我们宁愿多分配一些存储空间作为代价，来提升程序的执行速度。&lt;/p&gt;

&lt;p&gt;　　总而言之，比较两个算法优劣的指标有两个，时间复杂度与空间复杂度，优先比较时间复杂度，时间复杂度相同的情况下比较空间复杂度。&lt;/p&gt;

&lt;p&gt;　　最后：感谢阅读。&lt;/p&gt;
</description>
<pubDate>Fri, 24 May 2019 06:32:00 +0000</pubDate>
<dc:creator>不该相遇在秋天</dc:creator>
<og:description>同一个问题可以使用不同的算法解决，那么不同的算法孰优孰劣如何区分呢？因此我们需要一个表示方法来代表每个程序的效率。 衡量一个程序好坏的标准，一般是运行时间与占用内存两个指标。 不过我们在写代码的时候肯</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/fengyumeng/p/10918037.html</dc:identifier>
</item>
<item>
<title>shell高级-----初识sed和gawk - 秦广王</title>
<link>http://www.cnblogs.com/jinyuanliu/p/10916516.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jinyuanliu/p/10916516.html</guid>
<description>&lt;h2&gt;sed编辑器&lt;/h2&gt;
&lt;h4&gt;sed说明&lt;/h4&gt;
&lt;p&gt;sed是Linux下一款功能强大的非交互流式文本编辑器，可以对文本文件进行增、删、改、查等操作，支持按行、按字段、按正则匹配文本内容，灵活方便，特别适合于大文件的编辑。&lt;/p&gt;
&lt;h4&gt;sed使用方法&lt;/h4&gt;
&lt;p&gt;sed的使用方法，调用sed 命令的语法有两种：&lt;/p&gt;
&lt;p&gt;一.在命令行指定sed指令对文本进行处理：sed +选项  ‘指令’ 文件&lt;/p&gt;
&lt;p&gt;二.先将sed指令保存到文件中，将该文件作为参数进行调用：sed   +选项  -f  包含sed指令的文件  文件&lt;/p&gt;
&lt;h4&gt;sed的常用选项&lt;/h4&gt;
&lt;p&gt;-e：它告诉sed将下一个参数解释为一个sed指令，只有当命令行上给出多个sed指令时才需要使用-e选项&lt;/p&gt;&lt;p&gt;-f：后跟保存了sed指令的文件&lt;/p&gt;&lt;p&gt;&lt;strong&gt;-i：直接对内容进行修改，不加-i时默认只是预览，不会对文件做实际修改&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;-n：取消默认输出，sed默认会输出所有文本内容，使用-n参数后只显示处理过的行&lt;/p&gt;
&lt;h4&gt;sed中的编辑命令&lt;/h4&gt;
&lt;p&gt;a:追加  向匹配行后面插入内容&lt;/p&gt;&lt;p&gt;c:更改  更改匹配行的内容&lt;/p&gt;&lt;p&gt;i:插入  向匹配行前插入内容&lt;/p&gt;&lt;p&gt;d:删除  删除匹配的内容&lt;/p&gt;&lt;p&gt;&lt;strong&gt;s:替换  用斜线间指定的第二个文本字符串来替代第一个文本字符串。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
[root@node3 ljy]# more ceshi.sh 
this is one!
[root@node3 ljy]# sed -i 's/one/two/' ceshi.sh   
[root@node3 ljy]# more ceshi.sh                
this is two!
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;默认情况下，只会替换一行中的第一处。要想替换一行中不同地方出现的文件必须使用替换标记。&lt;/p&gt;
&lt;p&gt;s/pattern/replacement/flags&lt;/p&gt;
&lt;p&gt;有四种可用的替换标志：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;数字：表明新文件将替换第几处模式匹配的地方，比如2，替换每行中第二次出现的文本&lt;/li&gt;
&lt;li&gt;g ：表明新文件将会替换所有匹配的文本&lt;/li&gt;
&lt;li&gt;p : 表明原先行的内容要打印出来 ，通常与sed的-n一起使用&lt;/li&gt;
&lt;li&gt;w file ：将替换的结果写入到文件中&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
[root@node3 ljy]# more ceshi.sh                  
this is one,one,one
[root@node3 ljy]# sed -i 's/one/two/2 ' ceshi.sh                                         
[root@node3 ljy]# more ceshi.sh                  
this is one,two,one
[root@node3 ljy]# sed -i 's/one/two/g ' ceshi.sh  
[root@node3 ljy]# more ceshi.sh                  
this is two,two,two
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;p:打印  打印出匹配的内容，通常与-n选项和用&lt;/p&gt;&lt;p&gt;=:用来打印被匹配的行的行号&lt;/p&gt;&lt;p&gt;n:读取下一行，遇到n时会自动跳入下一行&lt;/p&gt;&lt;p&gt;r,w：读和写编辑命令，r用于将内容读入文件，w用于将匹配内容写入到文件&lt;/p&gt;

&lt;h2&gt;gawk程序&lt;/h2&gt;
&lt;p&gt;gawk提供了一种编程语言而不只是编程命令。&lt;/p&gt;
&lt;h4&gt;1、命令格式&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
gawk options program file*
&lt;/pre&gt;&lt;/div&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div readability=&quot;9.5&quot;&gt;
&lt;p&gt;options的可用选项有：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
 -F fs 指定行中分隔数据字段的字段分隔符。个人不建议使用这个选项，在BEGIN块中设置FS更好。这个选项只是提供了一个简洁的设置方式。
 -f file：指定读取程序的文件名
 -v var=value 定义gawk程序中的一个变量及其默认值。个人不建议使用这个选项，在BEGIN块中设置更好。
 -mf N 指定要处理的数据文件中的最大字段数
 -mr N 指定数据文件中的最大数据行数
 -W keyword 指定gawk的兼容模式或警告等级
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;h4&gt;2、从命令行读取脚本&lt;/h4&gt;
&lt;/div&gt;
&lt;div readability=&quot;23.5&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
[root@node1 ~]# awk '{print &quot;hello&quot;}'
asd
hello
adf
hello
asd
hello
qqq
hello
[root@n
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;要终止这个gawk程序，你必须表明数据流已经结束，&lt;/p&gt;
&lt;p&gt;ctrl+D组合键可以在bash中产生一个EOF字符。&lt;/p&gt;
&lt;h4&gt;3、使用数据字段变量&lt;/h4&gt;
&lt;p&gt;默认情况下，gawk会将如下变量分配给它在文本中发现的数据字段：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
$0  代表整个文本行
$1  代表文本行的第一个数据段
$n  代表文本行的第n个数据段
$NF  代表文本行的最后一个数据段
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;gwak中默认的字段分隔符书任意的空白字符。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;collapse:true;;gutter:true;&quot;&gt;
[root@node1 ~]# df -h | gawk '{print $5}'
已用%
5%
0%
0%
1%
0%
14%
0%
[root@node1 ~]# df -h | gawk '{print $NF}'
挂载点
/
/dev
/dev/shm
/run
/sys/fs/cgroup
/boot
/run/user/0
[root@node1 ~]# df -h | gawk '{print $0}' 
文件系统                 容量  已用  可用 已用% 挂载点
/dev/mapper/centos-root   42G  2.1G   40G    5% /
devtmpfs                 908M     0  908M    0% /dev
tmpfs                    920M     0  920M    0% /dev/shm
tmpfs                    920M  8.8M  911M    1% /run
tmpfs                    920M     0  920M    0% /sys/fs/cgroup
/dev/sda1               1014M  142M  873M   14% /boot
tmpfs                    184M     0  184M    0% /run/user/0
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;4、在程序脚本中使用多个命令&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
[root@node1 ~]# echo 'this is sam' | gawk '{$4=&quot;lisi&quot;;print $0}'  
this is sam lisi
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;5、从文件中读取程序&lt;/h4&gt;
&lt;p&gt;gawk编辑器允许将程序存储到文件中，然后在命令行中引用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
[root@node1 ljy]# more script.gawk 
{print $1 &quot;'s home directory is &quot; $6}
[root@node1 ljy]# gawk -F: -f script.gawk /etc/passwd
root's home directory is /root
bin's home directory is /bin
daemon's home directory is /sbin
adm's home directory is /var/adm
lp's home directory is /var/spool/lpd
sync's home directory is /sbin
shutdown's home directory is /sbin
halt's home directory is /sbin
mail's home directory is /var/spool/mail
operator's home directory is /root
games's home directory is /usr/games
ftp's home directory is /var/ftp
nobody's home directory is /
systemd-network's home directory is /
dbus's home directory is /
polkitd's home directory is /
sshd's home directory is /var/empty/sshd
postfix's home directory is /var/spool/postfix
chrony's home directory is /var/lib/chrony
mysql's home directory is /var/lib/mysql
dockerroot's home directory is /var/lib/docker
ljy's home directory is /home/ljy
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
</description>
<pubDate>Fri, 24 May 2019 06:00:00 +0000</pubDate>
<dc:creator>秦广王</dc:creator>
<og:description>sed编辑器 sed说明 sed是Linux下一款功能强大的非交互流式文本编辑器，可以对文本文件进行增、删、改、查等操作，支持按行、按字段、按正则匹配文本内容，灵活方便，特别适合于大文件的编辑。 se</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jinyuanliu/p/10916516.html</dc:identifier>
</item>
<item>
<title>Golang 入门 : 等待 goroutine 完成任务 - sparkdev</title>
<link>http://www.cnblogs.com/sparkdev/p/10917536.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sparkdev/p/10917536.html</guid>
<description>&lt;p&gt;&lt;span&gt;Goroutine 是 Golang 中非常有用的功能，但是在使用中我们经常碰到下面的场景：如果希望等待当前的 goroutine 执行完成，然后再接着往下执行，该怎么办？本文尝试介绍这类问题的解决方法。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;让我们运行下面的代码，并关注输出的结果：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package main

import (
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;time&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
    &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fmt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
)

func say(s &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;3&lt;/span&gt;; i++&lt;span&gt; {
        time.Sleep(&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; *&lt;span&gt; time.Millisecond)
        fmt.Println(s)
    }
}

func main() {
    go say(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello world&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    fmt.Println(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;over!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;输出的结果为：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;over!&lt;/span&gt;&lt;br/&gt;&lt;span&gt;因为 goroutine 以非阻塞的方式执行，所以程序输出字符串 &quot;over!&quot; 就退出了，这可不是我们想要的结果。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;要解决上面的问题，最简单、直接的方式就是通过 Sleep 函数死等 goroutine 执行完成：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;func main() {
    go say(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello world&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    time.Sleep(&lt;/span&gt;&lt;span&gt;1000&lt;/span&gt; *&lt;span&gt; time.Millisecond)
    fmt.Println(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;over!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;运行修改后的程序，结果如下：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;hello world&lt;/span&gt;&lt;br/&gt;&lt;span&gt;hello world&lt;/span&gt;&lt;br/&gt;&lt;span&gt;hello world&lt;/span&gt;&lt;br/&gt;&lt;span&gt;over!&lt;/span&gt;&lt;br/&gt;&lt;span&gt;结果符合预期，但是太 low 了，我们不知道实际执行中应该等待多长时间，所以不能接受这个方案！&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;通过 channel 也可以达到等待 goroutine 结束的目的，运行下面的代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;func main() {
    done :&lt;/span&gt;= make(chan &lt;span&gt;bool&lt;/span&gt;&lt;span&gt;)
    go func() {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;3&lt;/span&gt;; i++&lt;span&gt; {
            time.Sleep(&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; *&lt;span&gt; time.Millisecond)
            fmt.Println(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello world&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        }
        done &lt;/span&gt;&amp;lt;- &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
    }()

    &lt;/span&gt;&amp;lt;-&lt;span&gt;done
    fmt.Println(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;over!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;输出的结果也是：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;hello world&lt;/span&gt;&lt;br/&gt;&lt;span&gt;hello world&lt;/span&gt;&lt;br/&gt;&lt;span&gt;hello world&lt;/span&gt;&lt;br/&gt;&lt;span&gt;over!&lt;/span&gt;&lt;br/&gt;&lt;span&gt;这种方法的特点是执行多少次 done &amp;lt;- true 就得执行多少次 &amp;lt;-done，所以也不是优雅的解决方式。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Golang 官方在 sync 包中提供了 WaitGroup 类型来解决这个问题。其文档描述如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
A WaitGroup waits for a collection of goroutines to finish. The main goroutine calls Add to set the number of goroutines to wait for. Then each of the goroutines runs and calls Done when finished. At the same time, Wait can be used to block until all goroutines have finished.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;大意为：WaitGroup 用来等待单个或多个 goroutines 执行结束。在主逻辑中使用 WaitGroup 的 Add 方法设置需要等待的 goroutines 的数量。在每个 goroutine 执行的函数中，需要调用 WaitGroup 的 Done 方法。最后在主逻辑中调用 WaitGroup 的 Wait 方法进行阻塞等待，直到所有 goroutine 执行完成。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;使用方法可以总结为下面几点：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;创建一个 WaitGroup 实例，比如名称为：wg&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;调用 wg.Add(n)，其中 n 是等待的 goroutine 的数量&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;在每个 goroutine 运行的函数中执行 defer wg.Done()&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;调用 wg.Wait() 阻塞主逻辑&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;运行下面的代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package main

import (
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;time&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
    &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fmt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
    &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sync&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
)

func main() {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; wg sync.WaitGroup
    wg.Add(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;)
    say2(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &amp;amp;&lt;span&gt;wg)
    say2(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;world&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &amp;amp;&lt;span&gt;wg)
    fmt.Println(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;over!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
}

func say2(s &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;, waitGroup *&lt;span&gt;sync.WaitGroup) {
    defer waitGroup.Done()

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;3&lt;/span&gt;; i++&lt;span&gt; {
        fmt.Println(s)
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;输出的结果如下：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;hello&lt;/span&gt;&lt;br/&gt;&lt;span&gt;hello&lt;/span&gt;&lt;br/&gt;&lt;span&gt;hello&lt;/span&gt;&lt;br/&gt;&lt;span&gt;world&lt;/span&gt;&lt;br/&gt;&lt;span&gt;world&lt;/span&gt;&lt;br/&gt;&lt;span&gt;world&lt;/span&gt;&lt;br/&gt;&lt;span&gt;over!&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面是一个稍稍真实一点的例子，检查请求网站的返回状态。如果要在收到所有的结果后进一步处理这些返回状态，就需要等待所有的请求结果返回：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package main

import (
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fmt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
    &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sync&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
    &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;net/http&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
)

func main() {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; urls = []&lt;span&gt;string&lt;/span&gt;&lt;span&gt;{
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://www.baidu.com/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://www.cnblogs.com/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    }

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; wg sync.WaitGroup

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; _, url :=&lt;span&gt; range urls {
        wg.Add(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
        go fetch(url, &lt;/span&gt;&amp;amp;&lt;span&gt;wg)
    }

    wg.Wait()
}

func fetch(url &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;, wg *sync.WaitGroup) (&lt;span&gt;string&lt;/span&gt;&lt;span&gt;, error) {
    resp, err :&lt;/span&gt;=&lt;span&gt; http.Get(url)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil {
        fmt.Println(err)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;, err
    }
    wg.Done()
    fmt.Println(resp.Status)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; resp.Status, nil
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;运行上面的代码，输出的结果如下：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;200 OK&lt;/span&gt;&lt;br/&gt;&lt;span&gt;200 OK&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;参考：&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;a href=&quot;https://nathanleclaire.com/blog/2014/02/15/how-to-wait-for-all-goroutines-to-finish-executing-before-continuing/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;How to Wait for All Goroutines to Finish Executing Before Continuing&lt;/span&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://tutorialedge.net/golang/go-waitgroup-tutorial/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;Go WaitGroup Tutorial&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 24 May 2019 05:07:00 +0000</pubDate>
<dc:creator>sparkdev</dc:creator>
<og:description>Goroutine 是 Golang 中非常有用的功能，但是在使用中我们经常碰到下面的场景：如果希望等待当前的 goroutine 执行完成，然后再接着往下执行，该怎么办？本文尝试介绍这类问题的解决方</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sparkdev/p/10917536.html</dc:identifier>
</item>
<item>
<title>collection包1.1.0都升级了什么功能 - 轩脉刃</title>
<link>http://www.cnblogs.com/yjf512/p/10917551.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yjf512/p/10917551.html</guid>
<description>&lt;p&gt;jianfengye/collection（&lt;a href=&quot;https://github.com/jianfengye/collection&quot; class=&quot;uri&quot;&gt;https://github.com/jianfengye/collection&lt;/a&gt;） 这个包喜迎第一个子版本升级，从1.0.1升级到了1.1.0。这次还是做了不少改动的。&lt;/p&gt;

&lt;p&gt;这个需求是这个issue提出的： &lt;a href=&quot;https://github.com/jianfengye/collection/issues/10&quot; class=&quot;uri&quot;&gt;https://github.com/jianfengye/collection/issues/10&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;主要是在protobuf 生成的go代码里面是int32,int64的。&lt;/p&gt;
&lt;p&gt;增加一个类型的数组其实是很方便的事情了，只需要写一个Int32Collection的struct, 基于AbsCollection，实现几个必要的函数就可以了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package collection

import (
    &quot;errors&quot;
    &quot;fmt&quot;
)

type Int32Collection struct {
    AbsCollection
    objs []int32
}

func compareInt32(i interface{}, i2 interface{}) int {
    int1 := i.(int32)
    int2 := i2.(int32)
    if int1 &amp;gt; int2 {
        return 1
    }
    if int1 &amp;lt; int2 {
        return -1
    }
    return 0
}

// NewInt32Collection create a new Int32Collection
func NewInt32Collection(objs []int32) *Int32Collection {
    arr := &amp;amp;Int32Collection{
        objs: objs,
    }
    arr.AbsCollection.Parent = arr
    arr.SetCompare(compareInt32)
    return arr
}

...&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;这个是有一个读者在公众号留言提醒的。之前1.0.1版本的collection在new的时候直接将slice进行copy一份，是出于安全的考虑，Collection的使用一定不能修改到原有的slice。现在1.1.0在newCollection的时候并不复制slice，而是在需要对slice进行乱序或者变更操作的时候进行一次Copy操作。而我把Copy操作的时间也放到各个具体实现类中了。&lt;/p&gt;
&lt;p&gt;于是ICollection多实现了一个Copy方法，它会把当前Collection的Slice复制一份出来。然后在AbsCollection中记录一个是否已经拷贝的标记，isCopied，对于那些对原数组进行操作的方法会根据这个标记，如果之前没有复制，就复制一份，再进行操作&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func (arr *AbsCollection) Insert(index int, obj interface{}) ICollection {
    if arr.Err() != nil {
        return arr
    }
    if arr.Parent == nil {
        panic(&quot;no parent&quot;)
    }

    if arr.isCopied == false {
        arr.Copy()
        arr.isCopied = true
    }

    return arr.Parent.Insert(index, obj)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样就实现了延迟拷贝的功能。&lt;/p&gt;

&lt;p&gt;这个方法和Index方法是对应的，将数组的某个元素进行设置。&lt;/p&gt;
&lt;p&gt;这个方法的具体实现也在实现类中实现了，特别是对ObjCollection的SetIndex实现还是需要reflect进行绕的，其他的COllection不需要使用反射。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func (arr *ObjCollection) SetIndex(i int, val interface{}) ICollection {
    arr.objs.Index(i).Set(reflect.ValueOf(val))
    return arr
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;这个是这个issue提出的 &lt;a href=&quot;https://github.com/jianfengye/collection/issues/9&quot; class=&quot;uri&quot;&gt;https://github.com/jianfengye/collection/issues/9&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;之前的Sort我是使用冒泡排序实现的，确实效率有欠考虑。&lt;/p&gt;
&lt;p&gt;这次将Sort进行了快排实现。由于已经又了SetIndex, Index, 等方法，所以可以这个快排可以直接在AbsCollection中实现就行了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func (arr *AbsCollection) qsort(left, right int, isAscOrder bool) {
    tmp := arr.Index(left)
    p := left
    i, j := left, right
    for i &amp;lt;= j {
        for j &amp;gt;= p {
            c, err := arr.Index(j).Compare(tmp)
            if err != nil {
                arr.SetErr(err)
                return
            }
            if isAscOrder &amp;amp;&amp;amp; c &amp;gt;= 0 {
                j--
                continue
            }
            if !isAscOrder &amp;amp;&amp;amp; c &amp;lt;= 0 {
                j--
                continue
            }

            break
        }

        if j &amp;gt;= p {
            t, _ := arr.Index(j).ToInterface()
            arr.SetIndex(p, t)
            p = j
        }

        for i &amp;lt;= p {
            c, err := arr.Index(i).Compare(tmp)
            if err != nil {
                arr.SetErr(err)
                return
            }
            if isAscOrder &amp;amp;&amp;amp; c &amp;lt;= 0 {
                i++
                continue
            }
            if !isAscOrder &amp;amp;&amp;amp; c &amp;gt;= 0 {
                i++
                continue
            }
            break
        }

        if i &amp;lt;= p {
            t, _ := arr.Index(i).ToInterface()
            arr.SetIndex(p, t)
            p = i
        }
    }

    t, _ := tmp.ToInterface()
    arr.SetIndex(p, t)

    if p-left &amp;gt; 1 {
        arr.qsort(left, p-1, isAscOrder)
    }

    if right-p &amp;gt; 1 {
        arr.qsort(p+1, right, isAscOrder)
    }
}

func (arr *AbsCollection) Sort() ICollection {

    if arr.Err() != nil {
        return arr
    }
    if arr.compare == nil {
        return arr.SetErr(errors.New(&quot;sort: compare must be set&quot;))
    }

    if arr.isCopied {
        arr.qsort(0, arr.Count()-1, true)
        return arr
    }
    arr.Copy()
    return arr.Sort()
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;之前IMix的compare函数一定都需要调用SetCompare才能设置，现在如果这个IMix是从Collection进行创建的，比如Collection.Index(xx) IMix， 返回的IMix就直接将Collection中设置的compare函数直接传递过来。&lt;/p&gt;
&lt;p&gt;这样在使用过程中方便了不少。&lt;/p&gt;
&lt;p&gt;我也将各个类型的compare函数都整理在具体实现类的头部&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func compareInt32(i interface{}, i2 interface{}) int
func compareInt64(i interface{}, i2 interface{}) int
func compareInt(i interface{}, i2 interface{}) int
func compareString(a interface{}, b interface{}) int
...&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;1.1.0版本主要是根据issue反馈修复了一些使用和性能上的优化点。总体觉得已经可以发一个小版本了，于是打上了1.1.0的tag。&lt;/p&gt;
&lt;p&gt;该项目目前也有277个star了，欢迎在业务上试用 jianfengye/collection（&lt;a href=&quot;https://github.com/jianfengye/collection&quot; class=&quot;uri&quot;&gt;https://github.com/jianfengye/collection&lt;/a&gt;） 这个包，有问题请直接提issue，我会尽快响应。&lt;/p&gt;
</description>
<pubDate>Fri, 24 May 2019 05:05:00 +0000</pubDate>
<dc:creator>轩脉刃</dc:creator>
<og:description>collection包1.1.0都升级了什么功能 jianfengye/collection（https://github.com/jianfengye/collection） 这个包喜迎第一个子版本</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yjf512/p/10917551.html</dc:identifier>
</item>
<item>
<title>一个隐藏在支付系统很长时间的雷 - 猿界汪汪队</title>
<link>http://www.cnblogs.com/donlianli/p/10917499.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/donlianli/p/10917499.html</guid>
<description>&lt;p&gt;这个案例是最近刚发生不久的，只是这个雷的历史实在是久远。&lt;/p&gt;
&lt;p&gt;公司在3月底因为一次腾讯云专线故障，整个支付系统在高峰期停止服务将近10分钟。而且当时为了快速解决问题止损，重启了支付服务，事后也就没有了现场。我们支付组在技术架构上原先对专线故障的场景做了降级预案，但故障时预案并没有生效，所以这次我们需要排查清楚降级没有生效的原因（没有现场的事后排查，挑战非常大）。&lt;/p&gt;



&lt;p&gt;首先回顾一下微信支付的流程（也可以参考https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=7_4）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/544558/201905/544558-20190524123801088-2110864131.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;这个过程是同步的，如果我们的支付系统因为网络问题，没有取到prepay_id，那么用户就无法支付；&lt;/p&gt;


&lt;p&gt;我们的预案非常简单，就是在请求api.mch.weixin.qq.com时，在HTTPClient中设置了一个超时时间，当支付请求超时时，我们就请求微信支付的另外一个备用域名api2.mch.weixin.qq.com，我们的超时时间设置的是3秒；&lt;/p&gt;


&lt;p&gt;每次网络抖动的时候，我们从监控中都能发现，我们的超时时间并没有完全起作用。从故障后的监控看平均执行时间达到了10秒，超时时间（3秒）完全不管用：从日志中进一步分析到，很多请求都是在10秒以上，甚至10分钟后才报超时异常。10分钟后再降级到备份域名显然已经没有什么意义了。这让我们开发很不解，为什么HttpClient的超时设置没有生效，难道是HttpClient的bug?&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/544558/201905/544558-20190524123946807-1820254621.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以前我们也怀疑过自己封装的HTTPClient组件有问题，但是我们写了一个并发程序测试过，当时并没有测试出有串行问题或者不支持并发的问题；&lt;/p&gt;



&lt;p&gt;最近通过我们测试（我们组其中一个开发在测试环境对故障进行了复现）和调研后，我们发现支付系统使用的封装后的HttpsClient工具，同一时间最多只允许发起两个微信支付请求；当这两个请求没有迅速返回的时候（也就是网络抖动的时候），后面新的请求，只能排队等候，进而block住线程耗尽tomcat的线程；超时未生效的原因是因为CloseableHttpClient默认的实现对网络连接采用了连接池技术，当连接数达到最大连接数时，后续的请求只能排队等待连接，根本就无法取得发起网络请求的机会，所以也谈不上连接超时和响应超时；&lt;/p&gt;
&lt;p&gt;系统本来应该这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/544558/201905/544558-20190524124058145-1605922453.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;实际却是这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/544558/201905/544558-20190524124107116-476674421.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;我们从HttpClient的官方文档中证实了这一点，同时也写程序进行了验证（这其中的配置比较复杂和深入，计划后续再写一篇文章进行说明，请持续关注汪汪队）；&lt;/p&gt;
&lt;p&gt;官方文档：http://hc.apache.org/httpcomponents-client-4.5.x/tutorial/html/connmgmt.html 2.3.3. Pooling connection manager&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/544558/201905/544558-20190524124115565-1261791053.png&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们访问微信支付域名api.mch.weixin.qq.com，无论我们发起多少个请求， 在httpclient中就是对应一个route（一个host和port对应一个route），而每个route默认最多只有两个connection;而这个Route的默认值，我们代码中没有修改。所以，一台tomcat，实际上同一时间最多只会有两个请求发送到微信。网络抖动的时候，请求都会需要很长时间才能返回，因为我们设置的是3秒响应超时，所以，当网络抖动时，我们单台机器的qps就是3秒2个，极限情况下一分钟最多40个请求；更糟糕的情况，我们的程序中微信退款的超时时间设置的是30秒，所以如果是退款请求，那就是1分钟只能处理4个请求，10台服务器一分钟也就只能处理40个请求；因为支付和退款都是共用的一个HttpClient连接池，所以退款和支付会互相影响；&lt;/p&gt;
&lt;p&gt;按照HttpClient的设计，支付系统真实请求过程大概如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/544558/201905/544558-20190524124130488-609220087.png&quot; alt=&quot;&quot; width=&quot;700&quot;/&gt;&lt;/p&gt;


&lt;p&gt;1、对于微信支付，缺少压测。之前压测都是基于支付宝，而支付宝的调用模式和微信完全不一样，导致无法及时发现这个瓶颈；&lt;/p&gt;
&lt;p&gt;2、研发对HttpClient等使用&lt;strong&gt;池技术&lt;/strong&gt;的组件，原理了解不够深入，没有修改默认策略，最终形成了瓶颈；&lt;/p&gt;
&lt;p&gt;3、对报警细节观察不是很到位，每次网络抖动我们只看到了网络方面的问题，却忽略了程序中超时参数未生效的细节，从而多次错失发现程序缺陷的机会，所以“&lt;strong&gt;细节决定成败”；&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;知识点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、HttpClient,Route&lt;/p&gt;
&lt;p&gt;2、微信支付&lt;/p&gt;
&lt;p&gt;3、池技术&lt;/p&gt;

&lt;p&gt;更多案例请关注微信公众号猿界汪汪队&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/544558/201905/544558-20190524124222056-1754600286.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 24 May 2019 04:48:00 +0000</pubDate>
<dc:creator>猿界汪汪队</dc:creator>
<og:description>这个案例是最近刚发生不久的，只是这个雷的历史实在是久远。 公司在3月底因为一次腾讯云专线故障，整个支付系统在高峰期停止服务将近10分钟。而且当时为了快速解决问题止损，重启了支付服务，事后也就没有了现场</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/donlianli/p/10917499.html</dc:identifier>
</item>
<item>
<title>MySQL什么时候会使用内部临时表? - 小二郎**</title>
<link>http://www.cnblogs.com/sjks/p/10917383.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sjks/p/10917383.html</guid>
<description>&lt;p&gt;&lt;strong&gt;1.union执行过程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先我们创建一个表t1&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
create table t1(id int primary key, a int, b int, index(a));
delimiter ;;
create procedure idata()
begin
  declare i int;
  set i=1;
  while(i&amp;lt;=1000)do
    insert into t1 values(i, i, i);
    set i=i+1;
  end while;
end;;
delimiter ;
call idata();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后我们执行一下这条语句&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
explain &lt;span&gt;select&lt;/span&gt; &lt;span&gt;1000&lt;/span&gt; &lt;span&gt;as&lt;/span&gt; f &lt;span&gt;union&lt;/span&gt; (&lt;span&gt;select&lt;/span&gt; id &lt;span&gt;from&lt;/span&gt; t1 &lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; id &lt;span&gt;desc&lt;/span&gt; limit &lt;span&gt;2&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;首先说下union的语义，union的语义是取两个结果的并集，重复的保留一行,然后我们来看下explain的结果，第二行的key=PRIMARY，说明用到了主键索引。&lt;/p&gt;
&lt;p&gt;第三行的Extra的Using temporary说明用到了临时表&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1245814/201905/1245814-20190524120901325-284621315.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;下面我们看下这条语句的执行流程：&lt;/p&gt;
&lt;p&gt;1.创建一个临时表，只有f一个字段，且为主键&lt;/p&gt;
&lt;p&gt;2.将1000这个数据插入临时表&lt;/p&gt;
&lt;p&gt;3.子查询中步骤:&lt;/p&gt;
&lt;p&gt;1.插入1000进入临时表,因为主键冲突，插入失败&lt;/p&gt;
&lt;p&gt;2.插入第二行900，插入成功&lt;/p&gt;
&lt;p&gt;4.将临时表数据作为结果返回，并删除临时表&lt;/p&gt;
&lt;p&gt;这个过程的流程图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1245814/201905/1245814-20190524120919059-1263880975.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果我们把union改成union all，就不需要使用临时表了，因为union all是重复的也保留，&lt;/p&gt;
&lt;p&gt;大家可以看到extra这一列已经没有了Using temporary&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
explain select 1000 as f union all (select id from t1 order by id desc limit 2)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1245814/201905/1245814-20190524120955649-2121934243.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.group by执行过程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们来看下面这条语句:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
explain &lt;span&gt;select&lt;/span&gt; id&lt;span&gt;%&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;as&lt;/span&gt; m, &lt;span&gt;count&lt;/span&gt;(&lt;span&gt;*&lt;/span&gt;) &lt;span&gt;as&lt;/span&gt; c &lt;span&gt;from&lt;/span&gt; t1 &lt;span&gt;group&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; m;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1245814/201905/1245814-20190524121116048-673510408.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到explain结果&lt;/p&gt;
&lt;p&gt;Using index(使用到了覆盖索引a，不需要回表); Using temporary(用到了临时表); Using filesort(对数据进行了排序)&lt;/p&gt;
&lt;p&gt;这条语句的意思是将id%10进行分组统计，并按照m进行排序&lt;/p&gt;
&lt;p&gt;执行流程如下:&lt;/p&gt;
&lt;p&gt;1.创建临时表，增加m,c字段，m是主键&lt;/p&gt;
&lt;p&gt;2.计算id%10的结果记为x&lt;/p&gt;
&lt;p&gt;3.如果临时表里面没有主键为x的行，则插入(x,1)，如果有的话，就将该行的c值加1&lt;/p&gt;
&lt;p&gt;4.遍历完成后，按照m字段排序返回结果给客户端&lt;/p&gt;
&lt;p&gt;流程图如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1245814/201905/1245814-20190524121133978-979400516.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来我们看下这条语句的执行结果&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
explain &lt;span&gt;select&lt;/span&gt; id&lt;span&gt;%&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;as&lt;/span&gt; m, &lt;span&gt;count&lt;/span&gt;(&lt;span&gt;*&lt;/span&gt;) &lt;span&gt;as&lt;/span&gt; c &lt;span&gt;from&lt;/span&gt; t1 &lt;span&gt;group&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; m
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1245814/201905/1245814-20190524121207081-2127911626.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其实，如果我们不需要对查询结果进行排序，我们可以加一个order by null&lt;/p&gt;
&lt;p&gt;我们执行一下这条语句&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
explain &lt;span&gt;select&lt;/span&gt; id&lt;span&gt;%&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;as&lt;/span&gt; m, &lt;span&gt;count&lt;/span&gt;(&lt;span&gt;*&lt;/span&gt;) &lt;span&gt;as&lt;/span&gt; c &lt;span&gt;from&lt;/span&gt; t1 &lt;span&gt;group&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; m &lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1245814/201905/1245814-20190524121230895-313143054.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到这里没有进行排序，由于扫描是从表t的id是从1开始的，所以第一行是1&lt;/p&gt;
&lt;p&gt;如果我们执行下列语句，会发生什么呢？&lt;/p&gt;
&lt;p&gt;我们上面说的临时表，其实是内存临时表，如果我们把内存临时表的容量改的比我们要查询的数据的容量小，那么就会使用到磁盘临时表，磁盘临时表的默认引擎是innodb&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
et tmp_table_size=1024;
select id%100 as m, count(*) as c from t1 group by m order by null limit 10
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;group by 优化方法--直接排序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其实在上面的关于从内存临时表转化成磁盘临时表是很浪费时间的，也就是说mysql，在执行过程中发现空间不够了，在转成磁盘临时表，但是如果我们直接告诉mysql，我要查询的数据很大，那么mysql优化器就会想到，既然你告诉我数据很大，那么我就直接用sort_buffer进行排序，如果sort_buffer内存不够大，会用到磁盘临时表辅助排序。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; SQL_BIG_RESULT id&lt;span&gt;%&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; &lt;span&gt;as&lt;/span&gt; m, &lt;span&gt;count&lt;/span&gt;(&lt;span&gt;*&lt;/span&gt;) &lt;span&gt;as&lt;/span&gt; c &lt;span&gt;from&lt;/span&gt; t1 &lt;span&gt;group&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; m;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1245814/201905/1245814-20190524121417366-1686235122.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;小结一下:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.如果我们不需要对统计结果进行排序，可以加上order by null省去排序流程。&lt;/p&gt;
&lt;p&gt;2.尽量让排序过程用上内存临时表，可以通过适当调大tmp_table_size的值来避免用到磁盘临时表。&lt;/p&gt;
&lt;p&gt;3.如果数据量实在太大，使用SQL_BIG_RESULT告诉优化器，直接使用排序算法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1245814/201905/1245814-20190524121329383-425529513.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 24 May 2019 04:15:00 +0000</pubDate>
<dc:creator>小二郎**</dc:creator>
<og:description>1.union执行过程 首先我们创建一个表t1 然后我们执行一下这条语句 首先说下union的语义，union的语义是取两个结果的并集，重复的保留一行,然后我们来看下explain的结果，第二行的ke</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sjks/p/10917383.html</dc:identifier>
</item>
<item>
<title>Adobe Premiere Pro导入插件开发遇到的一个问题 - 24K纯开源</title>
<link>http://www.cnblogs.com/csuftzzk/p/adobe_premiere_pro_importer.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/csuftzzk/p/adobe_premiere_pro_importer.html</guid>
<description>&lt;p&gt;      最近在更新公司一款Premiere Pro CC导入插件的时候，遇到了一个神奇的现象。具体的现象是这样的：我们的插件需要将一些私有的文件数据放到插件中，比如说当前活动的文件名。当插件中收到不同的selector时，我们能够随时获取到这些私有数据进行操作。具体来说，我们是在收到imGetPrefs8这个selector时，进行设置的。回调函数代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
static prMALError
SDKGetPrefs8(
imStdParms                      *stdParms,
imFileAccessRec8        *fileInfo8,
imGetPrefsRec           *prefsRec)
{
        //-----------------
        // The first time you are called (or if you've been Quieted or Closed)
        // you will get asked for prefs data.  First time called, return the
        // size of the buffer you want Premiere to store prefs for your plug-in.

        // Note: if canOpen is not set to kPrTrue, I'm not getting this selector. Why?
        // Answer: because this selector is associated directly with &quot;hasSetup&quot;

        if (prefsRec-&amp;gt;prefsLength == 0) {
                prefsRec-&amp;gt;prefsLength = sizeof(MediaSettings);
        }
        else {
                MediaSettings* settings = (MediaSettings*)prefsRec-&amp;gt;prefs;
                //do not show dialog for the first time.
                if (fileInfo8-&amp;gt;fileref != imInvalidHandleValue) {
                        auto ctx = (FileContext*)(fileInfo8-&amp;gt;fileref);
                        if (!ctx || !ctx-&amp;gt;media_source) {
                                return malNoError;
                        }  
                        auto oldSettings = ctx-&amp;gt;media_source-&amp;gt;GetMediaSettings(); 
                        settings-&amp;gt;layout = oldSettings.layout;
                        settings-&amp;gt;lock_direction = oldSettings.lock_direction;
                        settings-&amp;gt;use_flowstate = oldSettings.use_flowstate;
                        settings-&amp;gt;media_case = oldSettings.media_case;
                        settings-&amp;gt;need_update = !settings-&amp;gt;need_update;
                        std::string currentFile = ctx-&amp;gt;media_source-&amp;gt;GetFilePath();
            ctx-&amp;gt;media_source-&amp;gt;ShowSettingsDialog(settings, currentFile);
                        updateSettingFromFile(settings);
                        ctx-&amp;gt;media_source-&amp;gt;UpdateSettings(settings);
                } 
                else {
                        //init settings
                        settings-&amp;gt;use_flowstate = true;
                } 
        }
        return malNoError;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　根据Adobe官方提供的文档说明，imGetPrefs8这个selector在文件导入的时候会连续发送两次。第一次调用回调函数是为了获取用户私有数据缓存区的大小，Host程序会给我们分配这么大的一块缓冲区。第二次调用的时候，这块缓冲区已经分配好了。我们只要往这块内存写入私有用户数据就行了。按道理说，这个过程非常清晰明了，不应该出现什么问题。可是在我实际调试的时候，弹窗获取到用户输入后，并没有马上生效！那么，我是怎么判断用户输入之后没有生效呢？一般来说，如果用户更改了什么设置，那么需要插件立即去调用SDKGetSourceVideo()函数的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt;&lt;span&gt;
prMALError
SDKGetSourceVideo(
imStdParms &lt;/span&gt;*&lt;span&gt;stdparms,
imFileRef    fileRef,
imSourceVideoRec &lt;/span&gt;*&lt;span&gt;sourceVideoRec)
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; ret;

    ImporterLocalRec8H ldataH &lt;/span&gt;= reinterpret_cast&amp;lt;ImporterLocalRec8H&amp;gt;(sourceVideoRec-&amp;gt;&lt;span&gt;inPrivateData);
    ImporterLocalRec8Ptr localRecP &lt;/span&gt;= reinterpret_cast&amp;lt;ImporterLocalRec8Ptr&amp;gt;(*&lt;span&gt;ldataH);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Get parameters for ReadFrameToBuffer()&lt;/span&gt;
    imFrameFormat* frameFormat = &amp;amp;sourceVideoRec-&amp;gt;inFrameFormats[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];
    prRect theRect;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (frameFormat-&amp;gt;inFrameWidth == &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; frameFormat-&amp;gt;inFrameHeight == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
    {
        frameFormat&lt;/span&gt;-&amp;gt;inFrameWidth = localRecP-&amp;gt;&lt;span&gt;theFile.width;
        frameFormat&lt;/span&gt;-&amp;gt;inFrameHeight = localRecP-&amp;gt;&lt;span&gt;theFile.height;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Windows and MacOS have different definitions of Rects, so use the cross-platform prSetRect&lt;/span&gt;
    prSetRect(&amp;amp;theRect, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, frameFormat-&amp;gt;inFrameWidth, frameFormat-&amp;gt;&lt;span&gt;inFrameHeight);
    localRecP&lt;/span&gt;-&amp;gt;PPixCreatorSuite-&amp;gt;CreatePPix(sourceVideoRec-&amp;gt;outFrame, PrPPixBufferAccess_ReadWrite, frameFormat-&amp;gt;inPixelFormat, &amp;amp;&lt;span&gt;theRect);
    csSDK_int32 theFrame &lt;/span&gt;= static_cast&amp;lt;csSDK_int32&amp;gt;(sourceVideoRec-&amp;gt;inFrameTime / (*ldataH)-&amp;gt;&lt;span&gt;theFile.frameRate);
    FileContext&lt;/span&gt;* ctx = (FileContext*)(localRecP)-&amp;gt;&lt;span&gt;fileRef;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ctx ==&lt;span&gt; nullptr) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; imNoContent;
    }
    
    ...
    ...
    

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; imNoErr;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       这个函数负责根据当用的用户设置来重新生成一帧数据传递给Host程序渲染，这样用户才能实时看到设置生效了。问题是，我们的用户输入改变之后，SDKGetSourceVideo()这个方法并没有再次调用！那是什么原因导致的呢？难道是Premiere主程序有什么Bug?经过不断调试才发现，这个锅Premiere不能背啊！原因是，我在imGetPrefs8的回调函数中并没有修改私有数据。也就是说，在上面的SDKGetPrefs8()方法中，我通过prefsRec获取到用户私有数据缓冲区之后，如果没有修改过这块内存区的数据的话，Premiere会认为不需要重新渲染画面，也就不会再次调用SDKGetSourceVideo()方法了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
MediaSettings* settings = (MediaSettings*)prefsRec-&amp;gt;prefs;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;      这么看来，Premiere的这个机制还是有道理的。如果用户私有数据没有更改，很大可能是不需要重新渲染画面的。这在某些计算频繁的场景下可能能够提供一定的性能提升。但是在文档里面并没有注明这一点。所以实际上，这个现象看起来像是一个锅实际上并不是一个锅……&lt;/p&gt;
</description>
<pubDate>Fri, 24 May 2019 04:12:00 +0000</pubDate>
<dc:creator>24K纯开源</dc:creator>
<og:description>最近在更新公司一款Premiere Pro CC导入插件的时候，遇到了一个神奇的现象。具体的现象是这样的：我们的插件需要将一些私有的文件数据放到插件中，比如说当前活动的文件名。当插件中收到不同的sel</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/csuftzzk/p/adobe_premiere_pro_importer.html</dc:identifier>
</item>
<item>
<title>从Activity的启动流程理解Binder - Jymoon</title>
<link>http://www.cnblogs.com/jymblog/p/10917345.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jymblog/p/10917345.html</guid>
<description>&lt;h2 id=&quot;简述&quot;&gt;简述&lt;/h2&gt;
&lt;p&gt;关于Activity启动流程和Binder的文章很多，大多数是分开来讲的，本文将二者结合起来，着重分析启动流程中跨进程方面的细节，其实，启动流程看似调用繁多，主要是复杂在Activity栈管理等方面，如果将其看作一个整体，整个启动流程就简单很多。在启动流程中，App和AMS的跨进程调用是其中的重点，理解了这个，会加深对Binder和启动流程的理解认知，也能窥到Framework层的冰山一角。另外我也发现，很多文章在讲启动流程的时候，关于ActivityMangagerService进程如何调用App进程的细节都没有讲清楚，这个问题也是我写这篇文章的初衷。阅读本文前建议了解一下AIDL，对Binder,Stub,Proxy等有一些印象。建议读一下这篇文章&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35519585&quot;&gt;写给 Android 应用工程师的 Binder 原理剖析&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;binder简介&quot;&gt;Binder简介&lt;/h2&gt;
&lt;p&gt;对于Binder，初学的人会对里面的概念比较模糊，因为看起来确实有些绕，我在这儿写几点帮助理解。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;所谓的“跨进程”能力指的是两个方面：一个是能够作为客户端调用远程服务的能力，一个是能够作为服务端接收客户端进程消息的能力，二者都是跨进程的一部分，分别对应transact和onTransact方法，而这两个方法的实现，分别位于BinderProxy和Binder两个类中，这两个类都在Binder.java这个文件中，读者可以自行阅读。&lt;/li&gt;
&lt;li&gt;BinderProxy具有发送消息的能力，通过transact方法，调用底层binder驱动，服务端的Binder具有接收底层binder驱动传过来的消息的能力，当接收到消息会调用onTransact方法。&lt;/li&gt;
&lt;li&gt;刚开始看AIDL的时候需要反复记忆理解一下，否则看别的代码容易混淆。这里说几个比较容易记忆的点：一个类继承了Stub类，表示这个类是远程服务端，Stub类有个asInterface的静态方法，这个方法用在拿到binder驱动传过来的BinderProxy对象时，将该对象转化成client端使用的本地代理xxxProxy，客户端用它调用远程service的方法。该代理跟service实现了同样的接口，只不过一个是真实现，一个是假实现，这里假实现指的是它通过Binder驱动调用S端方法，真正做工作的在Service端。简言之，Stub代表service端，Proxy代表service在客户端的代理。&lt;/li&gt;
&lt;li&gt;以AMS为例&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public class ActivityManagerService extends IActivityManager.Stub&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;AMS继承了Stub类，而Stub类一共实现了三个接口:IActivityManger，IBinder,IInterface，分别对应了三种能力，管理activity、跨进程，以及IInterface的asBinder，前两者好理解，那么这里的asBinder能力是干嘛的呢？这里先卖个关子，等下讲启动流程的时候会说明。&lt;/p&gt;
&lt;h2 id=&quot;启动流程&quot;&gt;启动流程&lt;/h2&gt;
&lt;p&gt;有了Binder的基础，我们去看启动流程，AMS和APP跨进程的过程简单说就是C端和S端分别通过二者在对方的代理去互相调用对方方法的过程。我们先从宏观角度思考，为什么要跨进程呢？我自己在客户端new一个Activity不行吗？不可以的，因为Android的安全机制以及为了统一管理Activity(比如activity栈)，需要有个大管家去进行所有Activity的管理和控制,而这个管家是运行在一个单独进程的，因此App端如果想发起一个Activity的请求，需要先把“申请”提交给大管家，也就是AMS。AMS处理完这个请求之后，需要再次通过跨进程通知App端，去执行剩下的相应的工作。因此这里的核心就在于两者如何互相调用对方了。&lt;/p&gt;
&lt;h4 id=&quot;app端如何调用ams方法&quot;&gt;App端如何调用AMS方法&lt;/h4&gt;
&lt;p&gt;下面看代码：用户启动一个页面时，会依次调用activity的startActivity--&amp;gt;Instrumentation的executestartActivity--&amp;gt;execStartActivitiesAsUser，这几个调用很容易找到，就简单带过，在最后这个方法里，执行了远程调用，即：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; int result = ActivityManager.getService()
                .startActivities(whoThread, who.getBasePackageName(), intents, resolvedTypes,
                        token, options, userId);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ActivityManager.getService获取的是什么？看ActivityMangaer.getService()这个代码里面：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public static IActivityManager getService() {
        return IActivityManagerSingleton.get();
    }

    private static final Singleton&amp;lt;IActivityManager&amp;gt; IActivityManagerSingleton =
            new Singleton&amp;lt;IActivityManager&amp;gt;() {
                @Override
                protected IActivityManager create() {
                    final IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE);
                    final IActivityManager am = IActivityManager.Stub.asInterface(b);
                    return am;
                }
            };&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果对Binder有所了解，应该很容易知道，这里取得的是AMS在客户端的代理，也就是代码中的最后一行返回的am。因为App要频繁的调用AMS的方法，因此用单例模式缓存在本地了一个AMS的本地代理，从单例的第一次获取可以看到，AMS的Binder是通过ServiceManager.getService()获取到的,那么ServiceMangaer是个什么东西，其实这个就是Android系统统一管理所有远程服务的“大管家”，比如AMS，WMS等系统服务都在这里注册了，客户端想调用任意一个服务，只需要知道名字就可以通过SM获取到相应的Server的Binder。拿到Binder之后便可以通过asInterface静态方法转化成本地代理，从而调用server的方法了。因此第一次获取AMS的Binder的过程实际上是客户端跟ServiceManager的一次跨进程通信。&lt;/p&gt;
&lt;h4 id=&quot;ams如何通知app进程&quot;&gt;AMS如何通知App进程&lt;/h4&gt;
&lt;h6 id=&quot;ams如何获取到app进程的binder的&quot;&gt;（1）AMS如何获取到App进程的Binder的&lt;/h6&gt;
&lt;p&gt;从上面的分析知道，App获取AMS的Binder实际上是通过ServiceManager这个大管家间接获取的，那反过来AMS处理完activity的管理任务(栈操作等)之后又如何通知App的呢？&lt;br/&gt;一个App总不可能像AMS那样在ServiceManger中注册吧，而且也没这个必要。那么到底是怎么通知的呢？&lt;br/&gt;答案就是：&lt;strong&gt;&lt;em&gt;App跨进程调用AMS的方法时，还顺便把App进程（这个时候App可以看作是服务端了）的Binder作为参数传给了AMS，AMS拿到这个APP的Binder之后，通过asInterface方法转化成在server端可以使用的代理，然后在需要回调App进程的时候通过这个代理来通知客户端&lt;/em&gt;&lt;/strong&gt;。其实跟App端逻辑是一致的，只不过C/S调了一下顺序，C变成了S，S变成了C。下面我们从代码里验证：&lt;br/&gt;我们以6.0之前版本的源码为例，新版本改成事务了，有些源码不容易看到，不如直接看老版本的，便于理解。&lt;br/&gt;首先看APP调用startActivity时是如何把App进程的Binder参数传过去的，刚才说了，startActivity实际上调用的是AMS本地代理的startActivity，而AMS本地代理是ActivityMangerProxy，这里AMP是AIDL自动生成的&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class ActivityManagerProxy implements IActivityManager
{
    public ActivityManagerProxy(IBinder remote)
    {
        mRemote = remote;
    }
    
    public IBinder asBinder()
    {
        return mRemote;
    }
    
    public int startActivity(IApplicationThread caller, Intent intent,
            String resolvedType, Uri[] grantedUriPermissions, int grantedMode,
            IBinder resultTo, String resultWho,
            int requestCode, boolean onlyIfNeeded,
            boolean debug, String profileFile, ParcelFileDescriptor profileFd,
            boolean autoStopProfiler) throws RemoteException {
        Parcel data = Parcel.obtain();
        Parcel reply = Parcel.obtain();
        data.writeInterfaceToken(IActivityManager.descriptor);
        data.writeStrongBinder(caller != null ? caller.asBinder() : null);
        intent.writeToParcel(data, 0);
        data.writeString(resolvedType);
        data.writeTypedArray(grantedUriPermissions, 0);
        data.writeInt(grantedMode);
        data.writeStrongBinder(resultTo);
        data.writeString(resultWho);
        data.writeInt(requestCode);
        data.writeInt(onlyIfNeeded ? 1 : 0);
        data.writeInt(debug ? 1 : 0);
        data.writeString(profileFile);
        if (profileFd != null) {
            data.writeInt(1);
            profileFd.writeToParcel(data, Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
        } else {
            data.writeInt(0);
        }
        data.writeInt(autoStopProfiler ? 1 : 0);
        mRemote.transact(START_ACTIVITY_TRANSACTION, data, reply, 0);
        reply.readException();
        int result = reply.readInt();
        reply.recycle();
        data.recycle();
        return result;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;startActivity方法的第一个参数caller,这个东西是IApplicationThread，这个IApplicationThread就是AMS去通知App做相应处理的接口，它跟IActivityManger配合组成了App和AMS交互的“协议”。那么这个传过来的IApplicationThread的是谁呢，通过看代码里的调用链：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Instrumentation:
int result = ActivityManager.getService()
                .startActivityAsUser(whoThread, who.getBasePackageName(), intent,
                        intent.resolveTypeIfNeeded(who.getContentResolver()),
                        token, resultWho,
                        requestCode, 0, null, options, user.getIdentifier());


ContextImpl:
        mMainThread.getInstrumentation().execStartActivities(
                getOuterContext(), mMainThread.getApplicationThread(), null,
                (Activity) null, intents, options);

ActivityThread:
    public ApplicationThread getApplicationThread()
    {
        return mAppThread;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以查到，首先是instrumentation类里传入的whoThread，whoThread是ContextImpl传进来的mMainThread.getApplicationThread(),而最后这个是mAppThread，这个东西就是ActivityThread这个类的内部类ApplicationThread,我们看代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; private class ApplicationThread extends IApplicationThread.Stub {&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;继承自Stub，因此从AIDL语法看出，是一个服务端，对应的客户端是谁呢？当然是AMS了，所以ApplicationThread这个类就是AMS向App进程发消息时的服务端。&lt;/p&gt;
&lt;p&gt;思路回到主线上，上面已经说明了，在客户端调用Binder的时候把ApplicationThread参数传给了AMP的startActivity方法，接下来会执行到：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;data.writeStrongBinder(caller != null ? caller.asBinder() : null);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意这里的caller.asBinder,这个方法就解释了前面遗留的问题，IInterface接口的方法asBinder就是在这个时候用的，即把S端（相对的）转成一个binder，之后binder写入到Parcel里，然后通过transact方法调用底层Binder驱动传给其他进程，这里也要注意，transact方法调用的是mRemote的transact，&lt;strong&gt;&lt;em&gt;而mRemote本质上是一个BinderProxy,千万不要理解成Binder了，因为这两个类都实现了IBinder接口，我们看代码的时候很可能会误认为调用的Binder的transact。&lt;/em&gt;&lt;/strong&gt;binderProxy的transact会调用transactNative函数，传给jni层，将之前保存在Parcel里的数据data传给Binder驱动，之后在传给AMS。可以这样理解，对于Binder驱动来说，它可以看成跨进程的一个“传送带”，从A进程传递给B进程，只要你实现了IInterface，就可以放到这个传送带上传送(writeStrongBinder方法)。总结一下就是IInterface接口表明了这个类可以转成一个binder从而在binder驱动中跨进程运输，IBinder接口表明了类具有跨进程的能力，即可以通过调用transact方法“使用”Binder驱动。&lt;/p&gt;
&lt;h6 id=&quot;获取到了binder之后&quot;&gt;（2）获取到了Binder之后&lt;/h6&gt;
&lt;p&gt;上面的讨论已经知道，AMS其实在App跨进程调用AMS的时候就把ApplicationThread转成Binder传过来了，传过来以后，AMS如果要用，必须得拿到ApplicationThread的代理，怎么拿到的呢？&lt;br/&gt;刚才说了AMS的onTransact方法会监听驱动传过来的对象，我们看onTransact的代码：AMS继承自IActivityManager.Stub，在源码中叫ActivityManagerNative：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public boolean onTransact(int code, Parcel data, Parcel reply, int flags)
            throws RemoteException {
        switch (code) {
        case START_ACTIVITY_TRANSACTION:
        {
            data.enforceInterface(IActivityManager.descriptor);
            IBinder b = data.readStrongBinder();
            IApplicationThread app = ApplicationThreadNative.asInterface(b);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到：&lt;br/&gt;IBinder b = data.readStrongBinder();客户端将binder write到Parcel中，服务端从Parcel中读了出来，然后通过asInterface转换成ApplicationThread的代理ApplicationThreadProxy这个类。注意：Binder驱动过来的IBinder不是Binder，而是BinderProxy，但是为什么我们之前传的参数是ApplicationThread，这个类是一个binder，为什么读出来以后变成了BinderProxy了呢？答案就在这个readStrongBinder里，看jni层的源码可以知道，系统在客户端收到(readStrongBinder)IBinder以后，会保存下来，通过Binder驱动传给Service时，会通过之前保存的Binder在底层创建BinderProxy，然后传给上层，其实看framework的源码，BinderProxy没有看到在java层的new方法，原来都在底层创建好了。&lt;br/&gt;有了代理对象后接下来既可以直接用了：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int result = startActivity(app, intent, resolvedType,
                    grantedUriPermissions, grantedMode, resultTo, resultWho,
                    requestCode, onlyIfNeeded, debug, profileFile, profileFd, autoStopProfiler);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;即进入到AMS对Activity启动管理流程中了，经过复杂的跳转，最后跑到ActivityStackSupervisor这个类的realStartActivityLocked方法中，里面最终会执行到这行代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken,
                    System.identityHashCode(r), r.info, new Configuration(mService.mConfiguration),
                    r.compat, r.task.voiceInteractor, app.repProcState, r.icicle, r.persistentState,
                    results, newIntents, !andResume, mService.isNextTransitionForward(),
                    profilerInfo);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的app.thread就是前面ApplicationThread在AMS中的代理，到了这里大家应该理清楚了，接下来通过代理调起App进程的ApplicationThread里的相应方法,即：scheduleLaunchActivity方法，这个方法会发送一个Message给主线程的handler ：H，然后在handleMessage里通过类加载器创建出一个Activity对象，并执行onCreate方法.balabala....&lt;/p&gt;
&lt;p&gt;最后用图片总结一下：&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2573909-298fad8065f14ade.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;binder.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后推荐一篇文章，目前发现的讲的binder最详细的，&lt;a href=&quot;https://juejin.im/post/58c90816a22b9d006413f624#heading-5&quot;&gt;听说你 Binder 机制学的不错，来解决下这几个问题&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 24 May 2019 04:04:00 +0000</pubDate>
<dc:creator>Jymoon</dc:creator>
<og:description>简述 关于Activity启动流程和Binder的文章很多，大多数是分开来讲的，本文将二者结合起来，着重分析启动流程中跨进程方面的细节，其实，启动流程看似调用繁多，主要是复杂在Activity栈管理等</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jymblog/p/10917345.html</dc:identifier>
</item>
<item>
<title>宜信开源微服务任务调度平台（SIA-TASK） - 宜信技术</title>
<link>http://www.cnblogs.com/yixinjishu/p/10917306.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yixinjishu/p/10917306.html</guid>
<description>&lt;p id=&quot;toc_0&quot;&gt; &lt;/p&gt;
&lt;h2 id=&quot;toc_1&quot;&gt;背景&lt;/h2&gt;
&lt;p&gt;无论是互联网应用或者企业级应用，都充斥着大量的批处理任务。常常需要一些任务调度系统帮助开发者解决问题。随着微服务化架构的逐步演进，单体架构逐渐演变为分布式、微服务架构。在此的背景下，很多原先的任务调度平台已经不能满足业务系统的需求。于是出现了一些基于分布式的任务调度平台。这些平台各有其特点，但各有不足之处，比如不支持任务编排、与业务高耦合、不支持跨平台等问题。非常不符合新一代微服务架构的需求，因此宜信公司开发了微服务任务调度平台（SIA-TASK）。&lt;/p&gt;
&lt;p&gt;SIA是宜信公司基础开发平台Simple is Awesome的简称，SIA-TASK（微服务任务调度平台）是其中的一项重要产品，SIA-TASK契合当前微服务架构模式，具有跨平台，可编排，高可用，无侵入，一致性，异步并行，动态扩展，实时监控等特点。&lt;/p&gt;
&lt;h2 id=&quot;toc_2&quot;&gt;项目简介&lt;/h2&gt;
&lt;p&gt;SIA-TASK是任务调度的一体式解决方案。对任务进行元数据采集，然后进行任务可视化编排，最终进行任务调度，并且对任务采取全流程监控，简单易用。对业务完全无侵入，通过简单灵活的配置即可生成符合预期的任务调度模型。&lt;/p&gt;
&lt;p&gt;SIA-TASK借鉴微服务的设计思想，获取分布在每个任务执行器上的任务元数据，上传到任务注册中心。利用在线方式进行任务编排，可动态修改任务时钟，采用HTTP作为任务调度协议，统一使用JSON数据格式，由调度中心进行时钟解析，执行任务流程，进行任务通知。&lt;/p&gt;
&lt;h2 id=&quot;toc_3&quot;&gt;关键术语&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;任务（Task）: 基本执行单元，执行器对外暴露的一个HTTP调用接口;&lt;/li&gt;
&lt;li&gt;作业（Job）: 由一个或者多个存在相互逻辑关系（串行/并行）的任务组成，任务调度中心调度的最小单位;&lt;/li&gt;
&lt;li&gt;计划（Plan）: 由若干个顺序执行的作业组成，每个作业都有自己的执行周期，计划没有执行周期;&lt;/li&gt;
&lt;li&gt;任务调度中心（Scheduler）: 根据每个的作业的执行周期进行调度，即按照计划、作业、任务的逻辑进行HTTP请求;&lt;/li&gt;
&lt;li&gt;任务编排中心（Config）: 编排中心使用任务来创建计划和作业;&lt;/li&gt;
&lt;li&gt;任务执行器（Executer）: 接收HTTP请求进行业务逻辑的执行;&lt;/li&gt;
&lt;li&gt;Hunter：Spring项目扩展包，负责执行器中的任务抓取，上传注册中心，业务可依赖该组件进行Task编写。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;toc_4&quot;&gt;微服务任务调度平台的特性&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;基于注解自动抓取任务，在暴露成HTTP服务的方法上加入@OnlineTask注解，@OnlineTask会自动抓取方法所在的IP地址，端口，请求路径，请求方法，请求参数格式等信息上传到任务注册中心(zookeeper)，并同步写入持久化存储中，此方法即任务;&lt;/li&gt;
&lt;li&gt;基于注解无侵入多线程控制，单一任务实例必须保持单线程运行，任务调度框架自动拦截@OnlineTask注解进行单线程运行控制，保持在一个任务运行时不会被再次调度。而且整个控制过程对开发者完全无感知。&lt;/li&gt;
&lt;li&gt;调度器自适应任务分配，任务执行过程中出现失败，异常时。可以根据任务定制的策略进行多点重新唤醒任务，保证任务的不间断执行。&lt;/li&gt;
&lt;li&gt;高度灵活任务编排模式，SIA-TASK的设计思想是以任务为原子，把多个任务按照执行的关系组合起来形成一个作业。同时运行时分为任务调度中心和任务编排中心，使得作业的调度和作业的编排分隔开来，互不影响。在我们需要调整作业的流程时，只需要在编排中心进行处理即可。同时编排中心支持任务按照串行，并行，分支等方式组织关系。在相同任务不同任务实例时，也支持多种调度方式进行处理。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;toc_5&quot;&gt;微服务任务调度平台设计&lt;/h2&gt;
&lt;p&gt;SIA-TASK主要分为五个部分:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;任务执行器&lt;/li&gt;
&lt;li&gt;任务调度中心&lt;/li&gt;
&lt;li&gt;任务编排中心&lt;/li&gt;
&lt;li&gt;任务注册中心（zookeeper）&lt;/li&gt;
&lt;li&gt;持久存储（Mysql）&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;img src=&quot;http://college.creditease.cn/resources/upload/image/20190523/1558579573502089465.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;SIA-TASK的主要运行逻辑:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;通过注解抓取任务执行器中的任务上报到任务注册中心&lt;/li&gt;
&lt;li&gt;任务编排中心从任务注册中心获取数据进行编排保存入持久化存储&lt;/li&gt;
&lt;li&gt;任务调度中心从持久化存储获取调度信息&lt;/li&gt;
&lt;li&gt;任务调度中心按照调度逻辑访问任务执行器&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;img src=&quot;http://college.creditease.cn/resources/upload/image/20190523/1558579634863031131.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;toc_6&quot;&gt;UI预览&lt;/h2&gt;
&lt;p&gt;首页提供多维度监控&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;调度器信息：展示调度器信息（负载能力，预警值），以及作业分布情况。&lt;/li&gt;
&lt;li&gt;调度信息：展示调度中心触发的调度次数，作业、任务多维度调度统计。&lt;/li&gt;
&lt;li&gt;对接项目统计：对使用项目的系统进行统计，作业个数，任务个数等等。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://college.creditease.cn/resources/upload/image/20190523/1558579675498020611.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;调度监控提供对已提交的作业进行实时监控展示。&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;作业状态实时监控：以项目组为单位面板，展示作业运行时状态。&lt;/li&gt;
&lt;li&gt;实时日志关联：可以通过涂色状态图标进行日志实时关联展示。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://college.creditease.cn/resources/upload/image/20190523/1558579796913058833.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;任务管理：提供任务元数据的相关操作&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;任务元数据录入：手动模式的任务，可在此进行录入。&lt;/li&gt;
&lt;li&gt;任务连通性测试：提供任务连通性功能测试。&lt;/li&gt;
&lt;li&gt;任务元数据其他操作：修改，删除。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://college.creditease.cn/resources/upload/image/20190523/1558579874369083818.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;http://college.creditease.cn/resources/upload/image/20190523/1558579958641070965.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;Job管理：提供作业相关操作&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;任务编排：进行作业的编排。&lt;/li&gt;
&lt;li&gt;发布作业: 作业的创建，修改，以及发布。&lt;/li&gt;
&lt;li&gt;级联设置：提供存在时间依赖的作业设置。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://college.creditease.cn/resources/upload/image/20190523/1558580011829032669.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;日志管理&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://college.creditease.cn/resources/upload/image/20190523/1558580106434046557.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;本地日志：日志界面简洁，查询快速；日志提供7天的调度日志，以供快速查询。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;toc_7&quot;&gt;开源地址&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;作者：宜信开发平台负责人/资深架构师梁鑫&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 24 May 2019 04:00:00 +0000</pubDate>
<dc:creator>宜信技术</dc:creator>
<og:description>宜信开源的微服务任务调度平台SIA-TASK，具有跨平台，可编排，高可用，无侵入，一致性，异步并行，动态扩展，实时监控等特点。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yixinjishu/p/10917306.html</dc:identifier>
</item>
</channel>
</rss>