<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>《Effective-Ruby》读书笔记 - 我没有三颗心脏</title>
<link>http://www.cnblogs.com/wmyskxz/p/10854327.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wmyskxz/p/10854327.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-97838390a82a86dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;本篇是在我接触了 Ruby 很短一段时间后有幸捧起的一本书，下面结合自己的一些思考，来输出一下自己的读书笔记&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;学习一门新的编程语言通常需要经过两个阶段：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;第一个阶段是学习这门编程语言的语法和结构&lt;/strong&gt;，如果我们具有其他编程语言的经验，那么这个过程通常只需要很短的时间；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第二个阶段是深入语言、学习语言风格&lt;/strong&gt;，许多编程语言在解决常见的问题时都会使用独特的方法，Ruby 也不例外。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;《Effictive Ruby》就是一本致力于让你在第二阶段更加深入和全面的了解 Ruby，编写出更具可读性、可维护性代码的书，下面我就着一些我认为的重点和自己的思考来进行一些精简和说明&lt;/p&gt;

&lt;h2 id=&quot;第-1-条理解-ruby-中的-true&quot;&gt;第 1 条：理解 Ruby 中的 True&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;每一门语言对于布尔类型的值都有自己的处理方式，在 Ruby 中，除了 false 和 nil，其他值都为真值，包括数字 0 值。&lt;/li&gt;
&lt;li&gt;如果你需要区分 false 和 nil，可以使用 nil? 的方式或 “==“ 操作符并将 false 作为左操作对象。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;ruby&quot;&gt;
&lt;code&gt;# 将 false 放在左边意味着 Ruby 会将表达式解析为 FalseClass#== 方法的调用（该方法继承自 Object 类）
# 这样我们可以很放心地知道：如果右边的操作对象也是 false 对象，那么返回值为 true
if false == x
    ...
end
 
# 换句话说，把 false 置为有操作对象是有风险的，可能不同于我们的期望，因为其他类可能覆盖 Object#== 方法从而改变下面这个比较
class Bad
    def == (other)
        true
    end
end
 
irb&amp;gt; false == Bad.new
---&amp;gt; false
irb&amp;gt; Bad.new == false
---&amp;gt; true&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;第-2-条所有对象的值都可能为-nil&quot;&gt;第 2 条：所有对象的值都可能为 nil&lt;/h2&gt;
&lt;p&gt;在 Ruby 中倡导接口高于类型，也就是说预期要求对象是某个给定类的实例，不如将注意力放在该对象能做什么上。没有什么会阻止你意外地把 Time 类型对象传递给接受 Date 对象的方法，这些类型的问题虽然可以通过测试避免，但仍然有一些多态替换的问题使这些经过测试的应用程序出现问题：&lt;/p&gt;
&lt;pre class=&quot;ruby&quot;&gt;
&lt;code&gt;undefined method 'fubar' for nil:NilClass (NoMethodError)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当你调用一个对象的方法而其返回值刚好是讨厌的 nil 对象时，这种情况就会发生···nil 是类 NilClass 的唯一对象。这样的错误会悄然逃过测试而仅在生产环境下出现：如果一个用户做了些超乎寻常的事。&lt;/p&gt;
&lt;p&gt;另一种导致该结果的情况是，当一个方法返回 nil 并将其作为参数直接传给一个方法时。事实上存在数量惊人的方式可以将 nil 意外地引入你运行中的程序。最好的防范方式是：假设任何对象都可以为 nil，包括方法参数和调用方法的返回值。&lt;/p&gt;
&lt;pre class=&quot;ruby&quot;&gt;
&lt;code&gt;# 最简单的方式是使用 nil? 方法
# 如果方法接受者（receiver）是 nil，该方法将返回真值，否则返回假值。
# 以下几行代码是等价的：
person.save if person
person.save if !person.nil?
person.save unless person.nil?
 
# 将变量显式转换成期望的类型常常比时刻担心其为 nil 要容易得多
# 尤其是在一个方法即使是部分输入为 nil 时也应该产生结果的时候
# Object 类定义了几种转换方法，它们能在这种情况下派上用场
# 比如，to_s 方法会将方法接受者转化为 string：
irb&amp;gt; 13.to_s
---&amp;gt; &quot;13&quot;
irb&amp;gt; nil.to_s
---&amp;gt; &quot;&quot;
 
# to_s 如此之棒的原因在于 String#to_s 方法只是简单返回 self 而不做任何转换和复制
# 如果一个变量是 string，那么调用 to_s 的开销最小
# 但如果变量期待 string 而恰好得到 nil，to_s 也能帮你扭转局面：
def fix_title (title)
    title.to_s.capitalize
end&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里还有一些适用于 nil 的最有用的例子：&lt;/p&gt;
&lt;pre class=&quot;ruby&quot;&gt;
&lt;code&gt;irb&amp;gt; nil.to_a
---&amp;gt; []
 
irb&amp;gt; nil.to_i
---&amp;gt; 0
 
irb&amp;gt; nil.to_f
---&amp;gt; 0.0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当需要同时考虑多个值的时候，你可以使用类 Array 提供的优雅的讨巧方式。Array#compact 方法返回去掉所有 nil 元素的方法接受者的副本。这在将一组可能为 nil 的变量组装成 string 时很常用。比如：如果一个人的名字由 first、middle 和 last 组成（其中任何一个都可能为 nil），那么你可以用下面的代码组成这个名字：&lt;/p&gt;
&lt;pre class=&quot;ruby&quot;&gt;
&lt;code&gt;name = [first, middle, last].compact.join(&quot; &quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;nil 对象的嗜好是在你不经意间偷偷溜进正在运行的程序中。无论它来自用户输入、无约束数据库，还是用 nil 来表示失败的方法，意味着每个变量都可能为 nil。&lt;/p&gt;
&lt;h2 id=&quot;第-3-条避免使用-ruby-中古怪的-perl-风格语法&quot;&gt;第 3 条：避免使用 Ruby 中古怪的 Perl 风格语法&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;推荐使用 String#match 替代 String#=~。前者将匹配信息以 MatchDate 对象返回，而非几个特殊的全局变量。&lt;/li&gt;
&lt;li&gt;使用更长、更表意的全局变量的别名，而非其短的、古怪的名字（比如，用 &lt;code&gt;$LOAD_PATH&lt;/code&gt; 替代 &lt;code&gt;$:&lt;/code&gt; ）。大多数长的名字需要在加载库 English 之后才能使用。&lt;/li&gt;
&lt;li&gt;避免使用隐式读写全局变量 $_ 的方法（比如，Kernel#print、Regexp#~ 等）&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;ruby&quot;&gt;
&lt;code&gt;# 这段代码中有两个 Perl 语法。
# 第一个：使用 String#=~ 方法
# 第二个：在上述代码中看起来好像是使用了一个全局变量 $1 导出第一个匹配组的内容，但其实不是...
def extract_error (message)
    if message =~ /^ERROR:\s+(.+)$/
        $1
    else
        &quot;no error&quot;
    end
end
 
# 以下是替代方法：
def extract_error (message)
    if m = message.match(/^ERROR:\s+(.+)$/)
        m[1]
    else
        &quot;no error&quot;
    end
end&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;第-4-条留神常量是可变的&quot;&gt;第 4 条：留神，常量是可变的&lt;/h2&gt;
&lt;p&gt;最开始接触 Ruby 时，对于常量的认识大概可能就是由大写字母加下划线组成的标识符，例如 STDIN、RUBY_VERSION。不过这并不是故事的全部，事实上，由大写字母开头的任何标识符都是常量，包括 String 或 Array，来看看这个：&lt;/p&gt;
&lt;pre class=&quot;ruby&quot;&gt;
&lt;code&gt;module Defaults
    NOTWORKS = [&quot;192.168.1&quot;,&quot;192.168.2&quot;]
end
def purge_unreachable (networks=Defaults::NETWORKS)
    networks.delete_if do |net|
        !ping(net + &quot;.1&quot;)
    end
end&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果调用方法 unreadchable 时没有加参数的话，会意外的改变一个常量的值。在 Ruby 中这样做甚至都不会警告你。好在有一种解决这个问题的方法——freeze 方法：&lt;/p&gt;
&lt;pre class=&quot;ruby&quot;&gt;
&lt;code&gt;module Defaults
    NOTWORKS = [&quot;192.168.1&quot;,&quot;192.168.2&quot;].freeze
end&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;加入你再想改变常量 NETWORKS 的值，purge_unreadchable 方法就会引入 RuntimeError 异常。根据一般的经验，总是通过冻结常量来阻止其被改变，然而不幸的是，冻结 NETWORKS 数组还不够，来看看这个：&lt;/p&gt;
&lt;pre class=&quot;ruby&quot;&gt;
&lt;code&gt;def host_addresses (host, networks=Defaults::NETWORKS)
    networks.map {|net| net &amp;lt;&amp;lt; &quot;.#{host}&quot;}
end&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果第二个参数没有赋值，那么 host_addresses 方法会修改数组 NETWORKS 的元素。即使数组 NETWORKS 自身被冻结，但是元素仍然是可变的，你可能无法从数组中增删元素，但你一定可以对存在的元素加以修改。因此，如果一个常量引用了一个集合，比如数组或者是散列，那么请冻结这个集合以及其中的元素：&lt;/p&gt;
&lt;pre class=&quot;ruby&quot;&gt;
&lt;code&gt;module Defaults
    NETWORKS = [
        &quot;192.168.1&quot;,
        &quot;192.168.2&quot;
    ].map(&amp;amp;:freeze).freeze
end&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;甚至，要达到防止常量被重新赋值的目的，我们可以冻结定义它的那个模块：&lt;/p&gt;
&lt;pre class=&quot;ruby&quot;&gt;
&lt;code&gt;module Defaults
    TIMEOUT = 5
end
 
Defaults.freeze&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;第-5-条留意运行时警告&quot;&gt;第 5 条：留意运行时警告&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;使用命令行选项 ”-w“ 来运行 Ruby 解释器以启用编译时和运行时的警告。设置环境变量 RUBYOPT 为 ”-w“ 也可以达到相同目的。&lt;/li&gt;
&lt;li&gt;如果必须禁用运行时的警告，可以临时将全局变量 $VERBOSE 设置为 nil。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;ruby&quot;&gt;
&lt;code&gt;# test.rb
def add (x, y)
    z = 1
    x + y
end
puts add 1, 2
 
# 使用不带 -w 参数的命令行
irb&amp;gt; ruby test.rb
---&amp;gt; 3
# 使用带 -w 参数的命令行
irb&amp;lt; ruby -w test.rb
---&amp;gt; test.rb:1: warning: parentheses after method name is interpreted as an argument list, not a decomposed argument
---&amp;gt; test.rb:2: warning: assigned but unused variable - z
---&amp;gt; 3&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;第-6-条了解-ruby-如何构建集成体系&quot;&gt;第 6 条：了解 Ruby 如何构建集成体系&lt;/h2&gt;
&lt;p&gt;让我们直接从代码入手吧：&lt;/p&gt;
&lt;pre class=&quot;ruby&quot;&gt;
&lt;code&gt;class Person
    def name
        ...
    end
end
 
class Customer &amp;lt; Person
    ...
end
irb&amp;gt; customer = Customer.new
---&amp;gt; #&amp;lt;Customer&amp;gt;
 
irb&amp;gt; customer.superclass
---&amp;gt; Person
 
irb&amp;gt; customer.respond_to?(:name)
---&amp;gt; true&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码几乎就和你预想的那样，当调用 customer 对象的 name 方法时，Customer 类会首先检查自身是否有这个实例方法，没有那么就继续搜索。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-cae0794a07515b82.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;顺着集成体系向上找到了 Person 类，在该类中找到了该方法并将其执行。（如果 Person 类中没有找到的话，Ruby 会继续向上直到到达 BasicObject）&lt;/p&gt;
&lt;p&gt;但是如果方法在查找过程中直到类树的根节点仍然没有找到匹配的办法，那么它将重新从起点开始查找，不过这一次会查找 method_missing 方法。&lt;/p&gt;
&lt;p&gt;下面我们开始让事情变得更加有趣一点：&lt;/p&gt;
&lt;pre class=&quot;ruby&quot;&gt;
&lt;code&gt;module ThingsWithNames
    def name
        ...
    end
end
 
class Person
    include(ThingsWithNames)
end
irb&amp;gt; Person.superclass
---&amp;gt; Object
irb&amp;gt; customer = Customer.new
---&amp;gt; #&amp;lt;Customer&amp;gt;
irb&amp;gt; customer.respond_to?(:name)
---&amp;gt; true&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里把 name 方法从 Person 类中取出并移到一个模块中，然后把模块引入到了 Person 类。Customer 类的实例仍然可以如你所料响应 name 方法，但是为什么呢？显然，模块 ThingsWithNames 并不在集成体系中，因为 Person 类的超类仍然是 Object 类，那会是什么呢？其实，Ruby 在这里对你撒谎了！当你 include 方法来将模块引入类时，Ruby 在幕后悄悄地做了一些事情。它创建了一个单例类并将它插入类体系中。这个匿名的不可见类被链向这个模块，因此它们共享了实力方法和常量。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-66bef8bfaff5448e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当每个模块被类包含时，它会立即被插入集成体系中包含它的类的上方，以后进先出（LIFO）的方式。每个对象都通过变量 superclass 链接，像单链表一样。这唯一的结果就是，&lt;strong&gt;当 Ruby 寻找一个方法时，它将以逆序访问访问每个模块，最后包含的模块最先访问到。很重要的一点是，模块永远不会重载类中的方法&lt;/strong&gt;，因为模块插入的位置是包含它的类的上方，而 Ruby 总是会在向上检查之前先检查类本身。&lt;br/&gt;（好吧······这不是全部的事实。确保你阅读了第 35 条，来看看 Ruby 2.0 中的 prepend 方法是如何使其复杂化的）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;要点回顾：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;要寻找一个方法，Ruby 只需要向上搜索类体系。如果没有找到这个方法，就从起点开始搜搜 method_missing 方法。&lt;/li&gt;
&lt;li&gt;包含模块时 Ruby 会悄悄地创建单例类，并将其插入在继承体系中包含它的类的上方。&lt;/li&gt;
&lt;li&gt;单例方法（类方法和针对对象的方法）存储于单例类中，它也会被插入继承体系中。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;第-7-条了解-super-的不同行为&quot;&gt;第 7 条：了解 super 的不同行为&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;当你想重载继承体系中的一个方法时，关键字 super 可以帮你调用它。&lt;/li&gt;
&lt;li&gt;不加括号地无参调用 super 等价于将宿主方法的素有参数传递给要调用的方法。&lt;/li&gt;
&lt;li&gt;如果希望使用 super 并且不向重载方法传递任何参数，必须使用空括号，即 super()。&lt;/li&gt;
&lt;li&gt;当 super 调用失败时，自定义的 method_missing 方法将丢弃一些有用的信息。在第 30 条中有 method_missing 的替代解决方案。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;第-8-条初始化子类时调用-super&quot;&gt;第 8 条：初始化子类时调用 super&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;当创建子类对象时，Ruby 不会自动调用超类中的 initialize 方法。作为替代，常规的方法查询规则也适用于 initialize 方法，只有第一个匹配的副本会被调用。&lt;/li&gt;
&lt;li&gt;当为显式使用继承的类定义 initialize 方法时，使用 super 来初始化其父类。在定义 initialize_copy 方法时，应使用相同的规则&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;ruby&quot;&gt;
&lt;code&gt;class Parent
    def initialize (name)
        @name = name
    end
end
 
class Child &amp;lt; Parent
    def initialize (grade)
        @grade = grade
    end
end
 
# 你能看到上面的窘境，Ruby 没有提供给子类和其超类的 initialize 方法建立联系的方式
# 我们可以使用通用意义上的 super 关键字来完成继承体系中位于高层的办法：
class Child &amp;lt; Parent
    def initialize (name, grade)
        super(name) # Initialize Parent.
        @grade = grade
    end
end&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;第-9-条提防-ruby-最棘手的解析&quot;&gt;第 9 条：提防 Ruby 最棘手的解析&lt;/h2&gt;
&lt;p&gt;这是一条关于 Ruby 可能会戏弄你的另一条提醒，要点在于：&lt;strong&gt;Ruby 在对变量赋值和对 setter 方法调用时的解析是有区别的！&lt;/strong&gt;直接看代码吧：&lt;/p&gt;
&lt;pre class=&quot;ruby&quot;&gt;
&lt;code&gt;# 这里把 initialize 方法体中的内容当做第 counter= 方法的调用也不是毫无道理
# 事实上 initialize 方法会创建一个新的局部变量 counter，并将其赋值为 0
# 这是因为 Ruby 在调用 setter 方法时要求存在一个显式接受者
class Counter
    attr_accessor(:counter)
 
    def initialize
        counter = 0
    end
    ...
end
 
# 你需要使用 self 充当这个接受者
class Counter
    attr_accessor(:counter)
 
    def initialize
        self.counter = 0
    end
    ...
end
 
# 而在你调用非 setter 方法时，不需要显式指定接受者
# 换句话说，不要使用不必要的 self，那会弄乱你的代码：
class Name
    attr_accessor(:first, :last)
     
    def initialize (first, last)
        self.first = first
        self.last = last
    end
 
    def full
        self.first + &quot; &quot; + self.last # 这里没有调用 setter 方法使用 self 多余了
    end
end
 
# 就像上面 full 方法里的注释，应该把方法体内的内容改为
first + &quot; &quot; + last&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;第-10-条推荐使用-struct-而非-hash-存储结构化数据&quot;&gt;第 10 条：推荐使用 Struct 而非 Hash 存储结构化数据&lt;/h2&gt;
&lt;p&gt;看代码吧：&lt;/p&gt;
&lt;pre class=&quot;ruby&quot;&gt;
&lt;code&gt;# 假设你要对一个保存了年度天气数据的 CSV 文件进行解析并存储
# 在 initialize 方法后，你会获得一个固定格式的哈希数组，但是存在以下的问题：
# 1.不能通过 getter 方法访问其属性，也不应该将这个哈希数组通过公共接口向外暴露，因为其中包含了实现细节
# 2.每次你想在类内部使用该哈希时，你不得不回头来看 initialize 方法
#   因为你不知道CSV具体的对应是怎样的，而且当类成熟情况可能还会发生变化
require('csv')
class AnnualWeather
    def initialize (file_name)
        @readings = []
     
        CSV.foreach(file_name, headers: true) do |row|
            @readings &amp;lt;&amp;lt; {
                :date =&amp;gt; Date.parse(row[2]),
                :high =&amp;gt; row[10].to_f,
                :low =&amp;gt; row[11].to_f,
            }
        end
    end
end
 
# 使用 Struct::new 方法的返回值赋给一个常量并利用它创建对象的实践：
class AnnualWeather
    # Create a new struct to hold reading data.
    Reading = Struct.new(:date, :high, :low)
 
    def initialize (file_name)
        @readings = []
     
        CSV.foreach(file_name, headers: true) do |row|
            @readings &amp;lt;&amp;lt; Reading.new(Date.parse(row[2]),
                                     row[10].to_f,
                                     row[11].to_f)
        end
    end
end
 
# Struct 类本身比你第一次使用时更加强大。除了属性列表，Struct::new 方法还能接受一个可选的块
# 也就是说，我们能在块中定义实例方法和类方法。比如，我们定义一个返回平均每月平均温度的 mean 方法：
Reading = Struct.new(:date, :high, :low) do
    def mean
        (high + low) / 2.0
    end
end&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;另外从其他地方看到了关于-structnew-的实践&quot;&gt;另外从其他地方看到了关于 Struct::new 的实践&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;考虑使用 Struct.new, 它可以定义一些琐碎的 accessors, constructor（构造函数） 和 comparison（比较） 操作。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;ruby&quot;&gt;
&lt;code&gt;# good
class Person
  attr_reader :first_name, :last_name
 
  def initialize(first_name, last_name)
    @first_name = first_name
    @last_name = last_name
  end
end
 
# better
class Person &amp;lt; Struct.new(:first_name, :last_name)
end&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;考虑使用 Struct.new，它替你定义了那些琐碎的存取器（accessors），构造器（constructor）以及比较操作符（comparison operators）。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;ruby&quot;&gt;
&lt;code&gt;# good
class Person
  attr_accessor :first_name, :last_name
 
  def initialize(first_name, last_name)
    @first_name = first_name
    @last_name = last_name
  end
end
 
# better
Person = Struct.new(:first_name, :last_name) do
end&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;要去 extend 一个 Struct.new - 它已经是一个新的 class。扩展它会产生一个多余的 class 层级 并且可能会产生怪异的错误如果文件被加载多次。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;第-11-条通过在模块中嵌入代码来创建命名空间&quot;&gt;第 11 条：通过在模块中嵌入代码来创建命名空间&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;通过在模块中嵌入代码来创建命名空间&lt;/li&gt;
&lt;li&gt;让你的命名空间结构和目录结构相同&lt;/li&gt;
&lt;li&gt;如果使用时可能出现歧义，可使用 ”::” 来限定顶级常量（比如，::Array）&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;第-12-条理解等价的不同用法&quot;&gt;第 12 条：理解等价的不同用法&lt;/h2&gt;
&lt;p&gt;看看下面的 IRB 回话然后自问一下：为什么方法 equal? 的返回值和操作符 “==” 的不同呢？&lt;/p&gt;
&lt;pre class=&quot;ruby&quot;&gt;
&lt;code&gt;irb&amp;gt; &quot;foo&quot; == &quot;foo&quot;
---&amp;gt; true
irb&amp;gt; &quot;foo&quot;.equal?(&quot;foo&quot;)
---&amp;gt; false&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;事实上，在 Ruby 中有四种方式来检查对象之间的等价性，下面来简单总个结吧：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;绝不要重载 equal? 方法。该方法的预期行为是，严格比较两个对象，仅当它们同时指向内存中同一对象时其值为真（即，当它们具有相同的 object_id 时）&lt;/li&gt;
&lt;li&gt;Hash 类在冲突检查时使用 eql? 方法来比较键对象。默认实现可能和你的想像不同。遵循第 13 条建议之后再使用别名 eql? 来替代 “==” 书写更合理的 hash 方法&lt;/li&gt;
&lt;li&gt;使用 “==” 操作符来测试两个对象是否表示相同的值。有些类比如表示数字的类会有一个粗糙的等号操作符进行类型转换&lt;/li&gt;
&lt;li&gt;case 表达式使用 “===“ 操作符来测试每个 when 语句的值。左操作数是 when 的参数，右操作数是 case 的参数&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;第-13-条通过-操作符实现比较和比较模块&quot;&gt;第 13 条：通过 &quot;&amp;lt;=&amp;gt;&quot; 操作符实现比较和比较模块&lt;/h2&gt;
&lt;p&gt;要记住在 Ruby 语言中，二元操作符最终会被转换成方法调用的形式，左操作数对应着方法的接受者，右操作数对应着方法第一个也是唯一的那个参数。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通过定义 &quot;&amp;lt;=&amp;gt;&quot; 操作符和引入 Comparable 模块实现对象的排序&lt;/li&gt;
&lt;li&gt;如果左操作数不能与右操作数进行比较，&quot;&amp;lt;=&amp;gt;&quot; 操作符应该返回 nil&lt;/li&gt;
&lt;li&gt;如果要实现类的 &quot;&amp;lt;=&amp;gt;&quot; 运算符，应该考虑将 eql? 方法设置为 &quot;==&quot; 操作符的别名，特别是当你希望该类的所有实例可以被用来作为哈希键的时候，就应该重载哈希方法&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;第-14-条通过-protected-方法共享私有状态&quot;&gt;第 14 条：通过 protected 方法共享私有状态&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;通过 protected 方法共享私有状态&lt;/li&gt;
&lt;li&gt;一个对象的 protected 方法若要被显式接受者调用，除非该对象与接受者是同类对象或其具有相同的定义该 protected 方法的超类&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;ruby&quot;&gt;
&lt;code&gt;# Ruby 语言中，私有方法的行为和其他面向对象的编程语言中不太相同。Ruby 语言仅仅在私有方法上加了一条限制————它们不能被显式接受者调用
# 无论你在继承关系中的哪一级，只要你没有使用接受者，你都可以调用祖先方法中的私有方法，但是你不能调用另一个对象的私有方法
# 考虑下面的例子：
# 方法 Widget#overlapping? 会检测其本身是否和另一个对象在屏幕上重合
# Widget 类的公共接口并没有将屏幕坐标对外暴露，它们的具体实现都隐藏在了内部
class Widget
    def overlapping? (other)
        x1, y1 = @screen_x, @screen_y
        x2, y2 = other.instance_eval {[@screen_x, @screen_y]}
        ...
    end
end
 
# 可以定义一个暴露私有屏幕坐标的方法，但并不通过公共接口来实现，其实现方式是声明该方法为 protected
# 这样我们既保持了原有的封装性，也使得 overlapping? 方法可以访问其自身以及其他传入的 widget 实例的坐标
# 这正式设计 protected 方法的原因————在相关类之间共享私有信息
class Widget
    def overlapping? (other)
        x1, y1 = @screen_x, @screen_y
        x2, y2 = other.screen_coordinates
        ...
    end
 
    protected
     
    def screen_coordinates
        [@screen_x, @screen_y]
    end
end&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;第-15-条优先使用实例变量而非类变量&quot;&gt;第 15 条：优先使用实例变量而非类变量&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;优先使用实例变量(@)而非类变量(@@)&lt;/li&gt;
&lt;li&gt;类也是对象，所以它们拥有自己的私有实例变量集合&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;第-16-条在改变作为参数的集合之前复制它们&quot;&gt;第 16 条：在改变作为参数的集合之前复制它们&lt;/h2&gt;
&lt;p&gt;在 Ruby 中多数对象都是通过引用而不是通过实际值来传递的，当将这种类型的对象插入容器时，集合类实际存储着该对象的引用而不是对象本身。&lt;br/&gt;（值得注意的是，这条准则是个例如：Fixnum 类的对象在传递时总是通过值而不是引用传递）&lt;/p&gt;
&lt;p&gt;这也就意味着当你把集合作为参数传入某个方法并进行修改时，原始集合也会因此被修改，有点间接，不过很容易看到这种情况的发生。&lt;/p&gt;
&lt;blockquote readability=&quot;21&quot;&gt;
&lt;p&gt;Ruby 语言自带了两个用来复制对象的方法：dup 和 clone。&lt;/p&gt;
&lt;p&gt;它们都会基于接收者创建新的对象，但是与 dup 方法不同的是，clone 方法会保留原始对象的两个附加特性。&lt;/p&gt;
&lt;p&gt;首先，clone 方法会保留接受者的冻结状态。如果原始对象的状态是冻结的，那么生成的副本也会是冻结的。而 dup 方法就不同了，它永远不会返回冻结的对象。&lt;/p&gt;
&lt;p&gt;其次，如果接受这种存在单例方法，使用 clone 也会复制单例类。由于 dup 方法不会这样做，所以当使用 dup 方法时，原始对象和使用 dup 方法创建的副本对于相同消息的响应可能是不同的。&lt;/p&gt;
&lt;pre class=&quot;ruby&quot;&gt;
&lt;code&gt;# 也可以使用 Marshal 类将一个集合及其所持有的元素序列化，然后再反序列化：
irb&amp;gt; a = [&quot;Monkey&quot;, &quot;Brains&quot;]
irb&amp;gt; b = Marshal.load(Marshal.dump(a))
irb&amp;gt; b.each(&amp;amp;:upcasel); b.first
---&amp;gt; &quot;MONKEY&quot;
irb&amp;gt; a.last
---&amp;gt; &quot;Brains&quot;&lt;/code&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;h2 id=&quot;第-17-条使用-array-方法将-nil-及标量对象转换成数组&quot;&gt;第 17 条：使用 Array 方法将 nil 及标量对象转换成数组&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;使用 Array 方法将 nil 及标量对象转换成数组&lt;/li&gt;
&lt;li&gt;不要将哈希传给 Array 方法，它会被转化成一个嵌套数组的集合&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;ruby&quot;&gt;
&lt;code&gt;# 考虑下面这样一个订披萨的类：
class Pizza
    def initialize (toppings)
        toppings.each do |topping|
            add_and_price_topping(topping)
        end
    end
end
 
# 上面的 initialize 方法期待的是一个 toppings 数组，但我们能传入单个 topping，甚至是在没有 topping 对象的时候直接传入 nil
# 你可能会想到使用可变长度参数列表来实现它，并将参数类型改为 *topping，这样会把所有的参数整合成一个数组。
# 尽管这样做可以让我们传入单个 topping 对象，担当传入一组对象给 initialize 方法的时候必须使用 &quot;*&quot; 显式将其拓展成一个数组。
# 所以这样做仅仅是拆东墙补西墙罢了，一个更好的解决方式是将传入的参数转换成一个数组，这样我们就明确地知道我要做的是什么了
# 先对 Array() 做一些探索：
irb&amp;gt; Array('Betelgeuse')
---&amp;gt; [&quot;Betelgeuse&quot;]
irb&amp;gt; Array(nil)
---&amp;gt; []
irb&amp;gt; Array(['Nadroj', 'Retep'])
---&amp;gt; [&quot;Nadroj&quot;, &quot;Retep&quot;]
irb&amp;gt; h = {pepperoni: 20,jalapenos: 2}
irb&amp;gt; Array(h)
---&amp;gt; [[:pepperoni, 20], [:jalapenos, 2]]
# 如果你想处理一组哈希最好采用第 10 条的建议那样
 
# 回答订披萨的问题上：
# 经过一番改造，它现在能够接受 topping 数组、单个 topping，或者没有 topping(nil or [])
class Pizza
    def initialize (toppings)
        Array(toppings).each do |topping|
            add_and_price_topping(topping)
        end
    end
    ...
end&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;第-18-条考虑使用集合高效检查元素的包含性&quot;&gt;第 18 条：考虑使用集合高效检查元素的包含性&lt;/h2&gt;
&lt;p&gt;（书上对于这一条建议的描述足足有 4 页半，但其实可以看下面结论就ok，结尾有实例代码）&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;考虑使用 Set 来高效地检测元素的包含性&lt;/li&gt;
&lt;li&gt;插入 Set 的对象必须也被当做哈希的键来用&lt;/li&gt;
&lt;li&gt;使用 Set 之前要引入它&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;ruby&quot;&gt;
&lt;code&gt;# 原始版本
class Role
    def initialize (name, permissions)
        @name, @permissions = name, permissions
    end
 
    def can? (permission)
        @permissions.include?(permission)
    end
end
 
# 版本1.0：使用 Hash 替代 Array 的 Role 类：
# 这样做基于两处权衡，首先，因为哈希只存储的键，所以数组中的任何重复在转换成哈希的过程中都会丢失。
# 其次，为了能够将数组转换成哈希，需要将整个数组映射，构建出一个更大的数组，从而转化为哈希。这将性能问题从 can? 方法转移到了 initialize 方法
class Role
    def initialize (name, permissions)
        @name = name
        @permissions = Hash[permissions.map {|p| [p, ture]}]
    end
 
    def can? (permission)
        @permissions.include?(permission)
    end
end
 
# 版本2.0：引入 Set：
# 性能几乎和上一个哈希版本的一样
require('set')
class Role
    def initialize (name, permissions)
        @name, @permissions = name, Set.new(permissions)
    end
         
    def can? (permission)
        @permissions.include?(permission)
    end
end
 
# 最终的例子
# 这个版本自动保证了集合中没有重复的记录，且重复条目是很快就能被检测到的
require('set')
require('csv')
class AnnualWeather
    Reading = Struct.new(:date, :high, :low) do
        def eql? (other) date.eql?(other.date); end
        def hash; date.hash; end
    end
 
    def initialize (file_name)
        @readings = Set.new
        CSV.foreach(file_name, headers: true) do |row|
            @readings &amp;lt;&amp;lt; Reading.new(Date.parse(row[2]),
                                     row[10].to_f,
                                     row[11].to_f)
        end
    end
end&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;第-19-条了解如何通过-reduce-方法折叠集合&quot;&gt;第 19 条：了解如何通过 reduce 方法折叠集合&lt;/h2&gt;
&lt;p&gt;尽管可能有点云里雾里，但还是考虑考虑先食用代码吧：&lt;/p&gt;
&lt;pre class=&quot;ruby&quot;&gt;
&lt;code&gt;# reduce 方法的参数是累加器的起始值，块的目的是创建并返回一个适用于下一次块迭代的累加器
# 如果原始集合为空，那么块永远也不会被执行，reduce 方法仅仅是简单地返回累加器的初始值
# 要注意块并没有做任何赋值。这是因为在每个迭代后，reduce 丢弃上次迭代的累加器并保留了块的返回值作为新的累加器
def sum (enum)
    enum.reduce(0) do |accumulator, element|
        accumulator + element
    end
end
 
# 另一个快捷操作方式对处理块本身很方便：可以给 reduce 传递一个符号（symbol）而不是块。
# 每个迭代 reduce 都使用符号作为消息名称发送消息给累加器，同时将当前元素作为参数
def sum (enum)
    enum.reduce(0, :+)
end
 
# 考虑一下把一个数组的值全部转换为哈希的键，而它们的值都是 true 的情况：
Hash[array.map {|x| [x, true]}]
# reduce 可能会提供更加完美的方案（注意此时 reduce 的起始值为一个空的哈希）：
array.reduce({}) do |hash, element|
    hash.update(element =&amp;gt; true)
end
 
# 再考虑一个场景：我们需要从一个存储用户的数组中筛选出那些年龄大于或等于 21 岁的人群，之后我们希望将这个用户数组转换成一个姓名数组
# 在没有 reduce 的时候，你可能会这样写：
users.select {|u| u.age &amp;gt;= 21}.map(&amp;amp;:name)
# 上面这样做当然可以，但并不高效，原因在于我们使用上面的语句时对数组进行了多次遍历
# 第一次是通过 select 筛选出了年龄大于或等于 21 岁的人，第二次则还需要映射成只包含名字的新数组
# 如果我们使用 reduce 则无需创建或遍历多个数组：
users.reduce([]) do |names, user|
    names &amp;lt;&amp;lt; user.name if user.age &amp;gt;= 21
    names
end&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;引入 Enumerable 模块的类会得到很多有用的实例方法，它们可用于对对象的集合进行过滤、遍历和转化。其中最为常用的应该是 map 和 select 方法，这些方法是如此强大以至于在几乎所有的 Ruby 程序中你都能见到它们的影子。&lt;/p&gt;
&lt;p&gt;像数组和哈希这样的集合类几乎已经是每个 Ruby 程序不可或缺的了，如果你还不熟悉 Enumberable 模块中定义的方法，你可能已经自己写了相当多的 Enumberable 模块已经具备的方法，知识你还不知道而已。&lt;/p&gt;
&lt;blockquote readability=&quot;22&quot;&gt;
&lt;p&gt;&lt;strong&gt;Enumberable 模块&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;戳开 Array 的源码你能看到 include Enumberable 的字样（引入的类必须实现 each 方法不然报错），我们来简单阐述一下 Enumberable API：&lt;/p&gt;
&lt;pre class=&quot;ruby&quot;&gt;
&lt;code&gt;irb&amp;gt; [1, 2, 3].map {|n| n + 1}
---&amp;gt; [2, 3, 4]
irb&amp;gt; %w[a l p h a b e t].sort
---&amp;gt; [&quot;a&quot;, &quot;a&quot;, &quot;b&quot;, &quot;e&quot;, &quot;h&quot;, &quot;l&quot;, &quot;p&quot;, &quot;t&quot;]
irb&amp;gt; [21, 42, 84].first
---&amp;gt; 21&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码中：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;首先，我们使用了流行的 map 方法遍历每个元素，并将每个元素 +1 处理，然后返回新的数组；&lt;/li&gt;
&lt;li&gt;其次，我们使用了 sort 方法对数组的元素进行排序，排序采用了 ASCII 字母排序&lt;/li&gt;
&lt;li&gt;最后，我们使用了查找方法 select 返回数组的第一个元素&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;reduce 方法到底干了什么？它为什么这么特别？在函数式编程的范畴中，它是一个可以将一个数据结构转换成另一种结构的折叠函数。&lt;/p&gt;
&lt;p&gt;让我们先从宏观的角度来看折叠函数，当使用如 reduce 这样的折叠函数时你需要了解如下三部分：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;枚举的对象是 reduce 消息的接受者。某种程度上这是你想转换的原始集合。显然，它的类必须引入 Enumberable 模块，否则你无法对它调用 reduce 方法；&lt;/li&gt;
&lt;li&gt;块会被源集合中的每个元素调用一次，和 each 方法调用块的方式类似。但和 each 不同的是，传入 reduce 方法的块必须产生一个返回值。这个返回值代表了通过当前元素最终折叠生成的数据结构。我们将会通过一些例子来巩固这一知识点。&lt;/li&gt;
&lt;li&gt;一个代表了目标数据结构起始值的对象，被称为累加器。每一次块的调用都会接受当前的累加器值并返回新的累加器值。在所有元素都被折叠进累加器后，它的最终结构也就是 reduce 的返回值。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;此时了解了这三部分你可以回头再去看一看代码。&lt;/p&gt;
&lt;p&gt;试着回想一下上一次使用 each 的场景，reduce 能够帮助你改善类似下面这样的模式：&lt;/p&gt;
&lt;pre class=&quot;ruby&quot;&gt;
&lt;code&gt;hash = {}
 
array.each do |element|
    hash[element] = true
end&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;第-20-条考虑使用默认哈希值&quot;&gt;第 20 条：考虑使用默认哈希值&lt;/h2&gt;
&lt;p&gt;我确定你是一个曾经在块的语法上徘徊许久的 Ruby 程序员，那么请告诉我，下面这样的模式在代码中出现的频率是多少？&lt;/p&gt;
&lt;pre class=&quot;ruby&quot;&gt;
&lt;code&gt;def frequency (array)
    array.reduce({}) do |hash, element|
        hash[element] ||= 0 # Make sure the key exists.
        hash[element] += 1  # Then increment it.
        hash                # Return the hash to reduce.
    end
end&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里特地使用了 &quot;||=&quot; 操作符以确保在修改哈希的值时它是被赋过值的。这样做的目的其实也就是确保哈希能有一个默认值，我们可以有更好的替代方案：&lt;/p&gt;
&lt;pre class=&quot;ruby&quot;&gt;
&lt;code&gt;def frequency (array)
    array.reduce(Hash.new(0)) do |hash, element|
        hash[element] += 1  # Then increment it.
        hash                # Return the hash to reduce.
    end
end&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看上去还真是那么一回事儿，但是小心，这里埋藏着一个隐蔽的关于哈希的陷阱。&lt;/p&gt;
&lt;pre class=&quot;ruby&quot;&gt;
&lt;code&gt;# 先来看一下这个 IRB 会话：
irb&amp;gt; h = Hash.new(42)
irb&amp;gt; h[:missing_key]
---&amp;gt; 42、
irb&amp;gt; h.keys # Hash is still empty!
---&amp;gt; []
irb&amp;gt; h[:missing_key] += 1
---&amp;gt; 43
irb&amp;gt; h.keys # Ah, there you are.
---&amp;gt; [:missing_key]
 
# 注意，当访问不存在的键时会返回默认值，但这不会修改哈希对象。
# 使用 &quot;+=&quot; 操作符的确会像你想象中那般更新哈希，但并不明确，回顾一下 &quot;+=&quot; 操作符会展开成什么可能会很有帮助：
# Short version:
hash[key] += 1
 
# Expands to:
hash[key] = hash[key] + 1
 
# 现在赋值的过程就很明确了，先取得默认值再进行 +1 的操作，最终将其返回的结果以同样的键名存入哈希
# 我们并没有以任何方式改变默认值，当然，上面一段代码的默认值是数字类型，它是不能修改的
# 但是如果我们使用一个可以修改的值作为默认值并在之后使用了它情况将会变得更加有趣：
irb&amp;gt; h = Hash.new([])
irb&amp;gt; h[:missing_key]
---&amp;gt; []
irb&amp;gt; h[:missing_key] &amp;lt;&amp;lt; &quot;Hey there!&quot;
---&amp;gt; [&quot;Hey there!&quot;]
irb&amp;gt; h.keys # Wait for it...
---&amp;gt; []
irb&amp;gt; h[:missing_key]
---&amp;gt; [&quot;Hey there!&quot;]
 
# 看到上面关于 &quot;&amp;lt;&amp;lt;&quot; 的小骗局了吗？我从没有改变哈希对象，当我插入一个元素之后，哈希并么有改变，但是默认值改变了
# 这也是 keys 方法提示这个哈希是空但是访问不存在的键时却反悔了最近修改的值的原因
# 如果你真想插入一个元素并设置一个键，你需要更深入的研究，但另一个不明显的副作用正等着你：
irb&amp;gt; h = Hash.new([])
irb&amp;gt; h[:weekdays] = h[:weekdays] &amp;lt;&amp;lt; &quot;Monday&quot;
irb&amp;gt; h[:months] = h[:months] &amp;lt;&amp;lt; &quot;Januray&quot;
irb&amp;gt; h.keys
---&amp;gt; [:weekdays, :months]
irb&amp;gt; h[:weekdays]
---&amp;gt; [&quot;Monday&quot;, &quot;January&quot;]
irb&amp;gt; h.default
---&amp;gt; [&quot;Monday&quot;, &quot;Januray&quot;]
 
# 两个键共享了同一个默认数组，多数情况你并不想这么做
# 我们真正想要的是当我们访问不存在的键时能返回一个全新的数组
# 如果给 Hash::new 一个块，当需要默认值时这个块就会被调用，并友好地返回一个新创建的数组：
irb&amp;gt; h = Hash.new{[]}
irb&amp;gt; h[:weekdays] = h[:weekdays] &amp;lt;&amp;lt; &quot;Monday&quot;
---&amp;gt; [&quot;Monday&quot;]
irb&amp;gt; h[:months] = h[:months] &amp;lt;&amp;lt; &quot;Januray&quot;
---&amp;gt; [&quot;Januray&quot;]
irb&amp;gt; h[:weekdays]
---&amp;gt; [&quot;Monday&quot;]
 
 
# 这样好多了，但我们还可以往前一步。
# 传给 Hash::new 的块可以有选择地接受两个参数：哈希本身和将要访问的键
# 这意味着我们如果想去改变哈希也是可的，那么当访问一个不存在的键时，为什么不将其对应的值设置为一个新的空数组呢？
irb&amp;gt; h = Hash.new{|hash, key| hash[key] = []}
irb&amp;gt; h[:weekdays] &amp;lt;&amp;lt; &quot;Monday&quot;
irb&amp;gt; h[:holidays]
---&amp;gt; []
irb&amp;gt; h.keys
---&amp;gt; [:weekdays, :holidays]
 
# 你可能发现上面这样的技巧存在着重要的不足：每当访问不存在的键时，块不仅会在哈希中创建新实体，同时还会创建一个新的数组
# 重申一遍：访问一个不存在的键会将这个键存入哈希，这暴露了默认值存在的通用问题：
# 正确的检查一个哈希是否包含某个键的方式是使用 hash_key? 方法或使用它的别名，但是深感内疚的是通常情况下默认值是 nil：
if hash[key]
    ...
end
 
# 如果一个哈希的默认值不是 nil 或者 false，这个条件判断会一直成功：将哈希的默认值设置成非 nil 可能会使程序变得不安全
# 另外还要提醒的是：通过获取其值来检查哈希某个键存在与否是草率的，其结果也可能和你所预期的不同
# 另一种处理默认值的方式，某些时候也是最好的方式，就是使用 Hash#fetch 方法
# 该方法的第一个参数是你希望从哈希中查找的键，但是 fetch 方法可以接受一个可选的第二个参数
# 如果指定的 key 在当前的哈希中找不到，那么取而代之，fetch 的第二个参数会返回
# 如果你省略了第二个参数，在你试图获取一个哈希中不存在的键时，fetch 方法会抛出一个异常
# 相比于对整个哈希设置默认值，这种方式更加安全
irb&amp;gt; h = {}
irb&amp;gt; h[:weekdays] = h.fetch(:weekdays, []) &amp;lt;&amp;lt; &quot;Monday&quot;
---&amp;gt; [&quot;Monday&quot;]
irb&amp;gt; h.fetch(:missing_key)
keyErro: key not found: :missing_key&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以看过上面的代码框隐藏的内容后你会发现：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如果某段代码在接受哈希的非法键时会返回 nil，不要为传入该方法的哈希使用默认值&lt;/li&gt;
&lt;li&gt;相比使用默认值，有些时候用 Hash#fetch 方法能更加安全&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;第-21-条对集合优先使用委托而非继承&quot;&gt;第 21 条：对集合优先使用委托而非继承&lt;/h2&gt;
&lt;p&gt;这一条也可以被命名为“对于核心类，优先使用委托而非继承”，因为它同样适用于 Ruby 的所有核心类。&lt;/p&gt;
&lt;p&gt;Ruby 的所有核心类都是通过 C语言 来实现的，指出这点是因为某些类的实例方法并没有考虑到子类，比如 Array#reverse 方法，它会返回一个新的数组而不是改变接受者。&lt;/p&gt;
&lt;p&gt;猜猜如果你继承了 Array 类并调用了子类的 reverse 方法后会发生什么？&lt;/p&gt;
&lt;pre class=&quot;ruby&quot;&gt;
&lt;code&gt;# 是的，LikeArray#reverse 返回了 Array 实例而不是 LikeArray 实例
# 但你不应该去责备 Array 类，在文档中有写的很明白会返回一个新的实例，所以达不到你的预期是很自然的
irb&amp;gt; class LikeArray &amp;lt; Array; end
irb&amp;gt; x = LikeArray.new([1, 2, 3])
---&amp;gt; [1, 2, 3]
irb&amp;gt; y = x.reverse
---&amp;gt; [3, 2, 1]
irb&amp;gt; y.class
---&amp;gt; Array&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然还不止这些，集合上的许多其他实例方法也是这样，集成比较操作符就更糟糕了。&lt;/p&gt;
&lt;p&gt;比如，它们允许子类的实例和父类的实例相比较，这说得通嘛？&lt;/p&gt;
&lt;pre class=&quot;ruby&quot;&gt;
&lt;code&gt;irb&amp;gt; LikeArray.new([1, 2, 3]) == [1, 2, 3,]
---&amp;gt; true&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;继承并不是 Ruby 的最佳选择，从核心的集合类中继承更是毫无道理的，替代方法就是使用“委托”。&lt;/p&gt;
&lt;p&gt;让我们来编写一个基于哈希但有一个重要不同的类，这个类在访问不存在的键时会抛出一个异常。&lt;/p&gt;
&lt;p&gt;实现它有很多不同的方式，但编写一个新类让我们可以简单的重用同一个实现。&lt;/p&gt;
&lt;p&gt;与继承 Hash 类后为保证正确而到处修修补补不同，我们这一次采用委托。我们只需要一个实例变量 @hash，它会替我们干所有的重活：&lt;/p&gt;
&lt;pre class=&quot;ruby&quot;&gt;
&lt;code&gt;# 在 Ruby 中实现委托的方式有很多，Forwardable 模块让使用委托的过程非常容易
# 它将一个存有要代理的方法的链表绑定到一个实例变量上，它是标准库的一部分（不是核心库），这也是需要显式引入的原因
require（'forwardable')
class RaisingHash
    extend(Forwardable)
    include(Enumerbale)
    def_delegators(:@hash, :[], :[]=, :delete, :each,
                           :keys, :values, :length,
                           :empty?, :hash_key?)
end&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（更多的探索在书上.这里只是简单给一下结论.感兴趣的童鞋再去看看吧!）&lt;/p&gt;
&lt;p&gt;所以要点回顾一下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对集合优先使用委托而非继承&lt;/li&gt;
&lt;li&gt;不要忘记编写用来复制委托目标的 initialize_copy 方法&lt;/li&gt;
&lt;li&gt;编写 freeze、taint 以及 untaint 方法时，先传递信息给委托目标，之后调用 super 方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;第-22-条使用定制的异常而不是抛出字符串&quot;&gt;第 22 条：使用定制的异常而不是抛出字符串&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;避免使用字符串作为异常，它们会被转换成原生的 RuntimeError 对象。取而代之，创建一个定制的异常类&lt;/li&gt;
&lt;li&gt;定制的异常类应该继承自 StandardError，且类名应该以 &quot;Error&quot; 结尾&lt;/li&gt;
&lt;li&gt;当为一个工程创建了不止一个异常类时，从创建一个继承自 StandardError 的基类开始。其他的异常类应该继承自该定制的基类&lt;/li&gt;
&lt;li&gt;如果你对你的定制异常类编写了 initialize 方法，务必确保其调用了 super 方法，最好在调用时以错误信息作为参数&lt;/li&gt;
&lt;li&gt;在 initialize 方法中设置错误信息时，请牢记：如果在 raise 方法中再度设置错误信息会覆盖原本在 initialize 中设置的那一条&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;ruby&quot;&gt;
&lt;code&gt;class TemperatureError &amp;lt; StandardError
    attr_reader(:temperature)
 
    def initialize(temperature)
        @temperature = temperature
        super(&quot;invalid temperature: #@temperature&quot;)
    end
end&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;第-23-条捕获可能的最具体的异常&quot;&gt;第 23 条：捕获可能的最具体的异常&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;只捕获那些你知道如何恢复的异常&lt;/li&gt;
&lt;li&gt;当捕获异常时，首先处理最特殊的类型。在异常的继承关系中位置越高的，越应该排在 rescue 链的后面&lt;/li&gt;
&lt;li&gt;避免捕获如 StandardError 这样的通用异常。如果你已经这么做了，就应该想想你真正想做的是不是可以通过 ensure 语句来实现&lt;/li&gt;
&lt;li&gt;在异常发生的情况下，从 resuce 语句中抛出的异常将会替换当前异常并离开当前的作用域&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;第-24-条通过块和-ensure-管理资源&quot;&gt;第 24 条：通过块和 ensure 管理资源&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;通过 ensure 语句来释放任何已获得的资源&lt;/li&gt;
&lt;li&gt;通过在类方法上使用块和 ensure 语句将资源管理的逻辑抽离出来&lt;/li&gt;
&lt;li&gt;确保 ensure 语句中使用的变量已经被初始化过了&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;第-25-条通过临近的-end-退出-ensure-语句&quot;&gt;第 25 条：通过临近的 end 退出 ensure 语句&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;避免在 ensure 语句中显式使用 return 语句，这意味着方法体内存在着某些错误的逻辑&lt;/li&gt;
&lt;li&gt;同样，不要在 ensure 语句中直接使用 throw，你应该将 throw 放在方法主体内&lt;/li&gt;
&lt;li&gt;当执行迭代时，不要在 ensure 语句中执行 next 或 break。仔细想想在迭代内到底需不需要 begin 块。将关系反转或许更加合理，就是将迭代放在 begin 块中&lt;/li&gt;
&lt;li&gt;一般来说，不要再 ensure 语句中改变控制流，在 rescue 语句中完成这样的工作，你的意图会更加清晰&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;第-26-条限制-retry-次数改变重试频率并记录异常信息&quot;&gt;第 26 条：限制 retry 次数，改变重试频率并记录异常信息&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;永远不要无条件 retry，要把它看做代码中的隐式循环；在代码块的外围定义重试次数，当超出最大重试次数时重新抛出异常&lt;/li&gt;
&lt;li&gt;retry 时记录具有审计作用的异常信息，如果重试有问题的代码解决不了问题，需要追根溯源地去了解异常是如何发生的&lt;/li&gt;
&lt;li&gt;当在 retry 之前使用延时时，需要考虑增加延时避免加剧问题&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;第-27-条throw-比-raise-更适合用来跳出作用域&quot;&gt;第 27 条：throw 比 raise 更适合用来跳出作用域&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;在复杂的流程控制中，可以考虑使用 throw 和 raise，这种方法一个额外的好处是可以把一个对象传递到上层调用栈并作为 catch 的最终返回值&lt;/li&gt;
&lt;li&gt;尽量使用简单的方法来控制程序结果，可以通过方法调用和 return 重写 catch 和 throw&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;第-28-条熟悉-ruby-模块和类的钩子方法&quot;&gt;第 28 条：熟悉 Ruby 模块和类的钩子方法&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;所有的钩子方法都需要被定义为单例方法&lt;/li&gt;
&lt;li&gt;添加、删除、取消定义方法的钩子方法参数是方法名，而不是类名，如果需要，使用 self 去获取类的信息&lt;/li&gt;
&lt;li&gt;定义 singleton_method_added 会出发自身&lt;/li&gt;
&lt;li&gt;不要覆盖 extend_object、append_features 和 prepend_features 方法，使用 extended、included 和 prepended 替代&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;第-29-条在类的钩子方法中执行-super-方法&quot;&gt;第 29 条：在类的钩子方法中执行 super 方法&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;在类的钩子方法中执行 super 方法&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;第-30-条推荐使用-define_method-而非-method_missing&quot;&gt;第 30 条：推荐使用 define_method 而非 method_missing&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;define_method 优于 method_missing&lt;/li&gt;
&lt;li&gt;如果必须使用 method_missing，最好也定义 respond_to_missing? 方法&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;第-31-条了解不同类型的-eval-间的差异&quot;&gt;第 31 条：了解不同类型的 eval 间的差异&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;使用 instance_eval 和 instance_exec 定义的单例方法&lt;/li&gt;
&lt;li&gt;class_eval、module_eval、class_exec 和 module_exec 方法只可以被模块或者方法使用。通过这些定义的方法都是实例方法&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;第-32-条慎用猴子补丁&quot;&gt;第 32 条：慎用猴子补丁&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;尽管 refinement 已经不再是实验性的功能，它仍然有可能被修改得更加成熟&lt;/li&gt;
&lt;li&gt;在不同的语法作用域，在使用 refinement 之前必须先激活它&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;第-33-条使用别名链执行被修改的方法&quot;&gt;第 33 条：使用别名链执行被修改的方法&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;在设置别名链时，需要确保别名是独一无二的&lt;/li&gt;
&lt;li&gt;必要的时候要考虑提供一个撤销别名链的方法&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;第-34-条支持多种-proc-参数数量&quot;&gt;第 34 条：支持多种 Proc 参数数量&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;与弱 Proc 对象不同，在参数数量不匹配时，强 Proc 对象会抛出 ArgumentError 异常&lt;/li&gt;
&lt;li&gt;可以使用 Proc#arity 方法得到 Proc 期望的参数数量，如果返回的是正数，则意味着有多少参数是必须的。如果返回的是负数，则意味着 Proc 有些参数是可选的，可以通过 &quot;~&quot; 来得到有多少是必须参数&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;第-35-条使用模块前置时请谨慎思考&quot;&gt;第 35 条：使用模块前置时请谨慎思考&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;prepend 方法在使用时对类体系机构的影响是：它将模块插入到接受者之前。这和 include 方法有很大不同：include 则是将模块插入到接受者和其超类之间&lt;/li&gt;
&lt;li&gt;与 included 和 extended 模块钩子一样，前置模块也会出发 prepended 钩子&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;第-36-条熟悉单元测试工具-minitest&quot;&gt;第 36 条：熟悉单元测试工具 MiniTest&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;测试方法需要以 &quot;test_&quot; 作为前缀&lt;/li&gt;
&lt;li&gt;简短的测试更容易理解，也更容易维护&lt;/li&gt;
&lt;li&gt;使用合适的断言方法生成更易读的出错信息&lt;/li&gt;
&lt;li&gt;断言（Assertion）和反演（refutation）的文档在 MiniTest::Assertions 中&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;第-37-条熟悉-minitest-的需求测试&quot;&gt;第 37 条：熟悉 MiniTest 的需求测试&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;使用 describe 方法创建测试类，使用 it 定义测试用例&lt;/li&gt;
&lt;li&gt;虽然在需求说明测试中，断言仍然可用，但是更推荐使用注入到 Object 中的期望方法&lt;/li&gt;
&lt;li&gt;在 MiniTest::Expectations 模块中，可以找到关于期望方法更详细的文档&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;第-38-条使用-mock-模拟特定对象&quot;&gt;第 38 条：使用 Mock 模拟特定对象&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;使用 Mock 来隔离外部系统的不稳定因素&lt;/li&gt;
&lt;li&gt;Mock 或者替换没有被测试过得方法，有可能会让这些被 Mock 的代码在生产环境中出现问题&lt;/li&gt;
&lt;li&gt;请确保在测试方法代码的最后调用了 MiniTest::Mock#verity 方法&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;第-39-条力争代码被有效测试过&quot;&gt;第 39 条：力争代码被有效测试过&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;使用模糊测试和属性测试工具，帮助测试代码的快乐路径和异常路径。&lt;/li&gt;
&lt;li&gt;测试覆盖率工具会给你一种虚假的安全感，因为被执行过的代码不代表这行代码是正确的&lt;/li&gt;
&lt;li&gt;在编写特性的同时就加上测试，会让测试容易得多&lt;/li&gt;
&lt;li&gt;在你开始寻找导致 bug 的根本原因之前，先写一个针对该 bug 的测试&lt;br/&gt;尽可能多地自动化你的测试&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;第-40-条学会使用-ruby-文档&quot;&gt;第 40 条：学会使用 Ruby 文档&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;ri 工具用来读取文档，rdoc 工具用来生成文档&lt;/li&gt;
&lt;li&gt;使用命令行选项 &quot;-d doc&quot; 来为 RI 工具制定在 &quot;doc&quot; 路径下查找文档&lt;br/&gt;运行 rdoc 时，后面跟上命令行选项 &quot;-f ri&quot; 来为 RI 工具生成文档。另外，用 &quot;-f darkfish&quot; 来生成 HTML 格式的文档(自己测试过..对于大型项目生成的 HTML 文档不是很友好..)&lt;/li&gt;
&lt;li&gt;完整的 RDoc 文档可以在 RDoc::Markup 类中找到（使用 RI 查阅）&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;第-41-条认识-irb-的高级特性&quot;&gt;第 41 条：认识 IRB 的高级特性&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;在 IRB::ExtendCommandBundle 模块，或者一个会被引入 IRB::ExtendCommandBundle 中的模块中自定义 IRB 命令&lt;/li&gt;
&lt;li&gt;利用下划线变量（&quot;&lt;em&gt;&quot;）来获取上一个表达式的结果（例如，last_elem =&lt;/em&gt; ）&lt;/li&gt;
&lt;li&gt;irb 命令可以用来创建一个新的会话，并将当前的评估上下文改变成任意对象&lt;br/&gt;考虑 Pry gem 作为 IRB 的替代品&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;第-42-条用-bundler-管理-gem-依赖&quot;&gt;第 42 条：用 Bundler 管理 Gem 依赖&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;在加载完 Bundler 之后，使用 Bundler.require 会牺牲一点点灵活性，但是可以加载 Gemfile 中所有的 gem&lt;/li&gt;
&lt;li&gt;当开发应用时，在 Gemfile 中列出所有的 gem，然后把 Gemfile.lock 添加到版本控制系统中&lt;/li&gt;
&lt;li&gt;当打包 RubyGem，在 gem 规格文件中列出 gem 所有依赖，但不要把 Gemfile.lock 添加到你的版本系统中&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;第-43-条为-gem-依赖设定版本上限&quot;&gt;第 43 条：为 Gem 依赖设定版本上限&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;忽略掉版本上限需求相当于你说了你可以支持未来所有的版本&lt;/li&gt;
&lt;li&gt;相对于悲观版本操作符，更加倾向于使用明确的版本范围&lt;/li&gt;
&lt;li&gt;当公布发布一个 gem 时，指明依赖包的版本限制要求，在安全的范围内越宽越好，上限可以扩展到下一个主要发布版本之前&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;第-44-条熟悉-ruby-的垃圾收集器&quot;&gt;第 44 条：熟悉 Ruby 的垃圾收集器&lt;/h2&gt;
&lt;blockquote readability=&quot;1.4166666666667&quot;&gt;
&lt;p&gt;扩展阅读：&lt;br/&gt;&lt;a href=&quot;https://ruby-china.org/topics/37118&quot;&gt;Ruby GC 自述 · Ruby China&lt;/a&gt; &lt;br/&gt;&lt;a href=&quot;http://tmm1.net/ruby21-rgengc/&quot;&gt;Ruby 2.1:RGenGC&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;垃圾收集器是个复杂的软件工程。从很高的层次看，Ruby 垃圾收集器使用一种被称为 &lt;strong&gt;标记-清除（mark and sweep）&lt;/strong&gt;的过程。（熟悉 Java 的童鞋应该会感到一丝熟悉）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-6e38752957186ca4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先，遍历对象图，能被访问到的对象会被标记为存活的。接着，任何未在第一阶段标记过的对象会被视为垃圾并被清楚，之后将内存释放回 Ruby 或操作系统。&lt;/p&gt;
&lt;p&gt;遍历整个对象图并标记可访问对象的开销太大。Ruby 2.1 通过新的&lt;strong&gt;分代式垃圾收集&lt;/strong&gt;器对性能进行了优化。对象被分为两类，年轻代和年老代。&lt;/p&gt;
&lt;p&gt;分代式垃圾收集器基于一个前提：大多数对象的生存时间都不会很长。如果我们知道了一个对象可以存活很久，那么就可以优化标记阶段，自动将这些老的对象标记为可访问，而不需要遍历整个对象图。&lt;/p&gt;
&lt;p&gt;如果年轻代对象在第一阶段的标记中存活了下来，那么 Ruby 的分代式垃圾收集器就把它们提升为年老代。也就是说，他们依然是可访问的。&lt;/p&gt;
&lt;p&gt;在年轻代对象和年老代对象的概念下，标记阶段可以分为两种模式：主要标记阶段（major）和次要标记阶段（minor）。&lt;/p&gt;
&lt;p&gt;在主要标记阶段，所有的对象（无论新老）都会被标记。该模式下，垃圾收集器不区分新老两代，所以开销很大。&lt;/p&gt;
&lt;p&gt;次要标记阶段，仅仅考虑年轻代对象，并自动标记年老代对象，而不检查能否被访问。这意味着年老代对象只会在主要标记阶段之后才会被清除。除非达到了一些阈值，保证整个过程全部作为主要标记之外，垃圾收集器倾向于使用次要标记。&lt;/p&gt;
&lt;p&gt;垃圾收集器的清除阶段也有优化机制，分为两种模式：即使模式和懒惰模式。&lt;/p&gt;
&lt;p&gt;在即使模式中，垃圾收集器会清除所有的未标记的对象。如果有很多对象需要被释放，那这种模式开销就很大。&lt;/p&gt;
&lt;p&gt;因此，清除阶段还支持懒惰模式，它将尝试释放尽可能少的对象。&lt;/p&gt;
&lt;p&gt;每当 Ruby 中创建一个新对象时，它可能尝试触发一次懒惰清除阶段，去释放一些空间。为了更好的理解这一点，我们需要看看垃圾收集器如何管理存储对象的内存。（简单概括：垃圾收集器通过维护一个由页组成的堆来管理内存。页又由槽组成。每个槽存储一个对象。）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-11e362645a4dd44e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们打开一个新的 IRB 会话，运行如下命令：&lt;/p&gt;
&lt;pre class=&quot;ruby&quot;&gt;
&lt;code&gt;`IRB``&amp;gt; ``GC``.stat`

`---&amp;gt; {``:count``=&amp;gt;``9``, ``:heap_length``=&amp;gt;``126``, ...}`&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;GC::stat 方法会返回一个散列，包含垃圾收集器相关的所有信息。请记住，该散列中的键以及它们对应垃圾收集器的意义可能在下一个版本发生变化。&lt;/p&gt;
&lt;p&gt;好了，让我们来看一些有趣的键：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;9&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;count&lt;/td&gt;
&lt;td&gt;垃圾收集器运行的总次数&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;major_gc_count&lt;/td&gt;
&lt;td&gt;主要模式下的运行次数&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;minor_gc_count&lt;/td&gt;
&lt;td&gt;次要模式下的运行次数&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;total_allocated_object&lt;/td&gt;
&lt;td&gt;程序开始时分配的对象总数&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;total_freed_object&lt;/td&gt;
&lt;td&gt;Ruby 释放的对象总数。与上面之差表示存活对象的数量，这可以通过 heap_live_slot 键来计算&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;heap_length&lt;/td&gt;
&lt;td&gt;当前堆中的页数&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;heap_live_slot 和 heap_free_slot&lt;/td&gt;
&lt;td&gt;表示全部页中被使用的槽数和未被使用的槽数&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;old_object&lt;/td&gt;
&lt;td&gt;年老代的对象数量，在次要标记阶段不会被处理。年轻代的对象数量可以用 heap_live_slot 减去 old_object 来获得&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;该散列中还有几个有趣的数字，但在介绍之前，让我们来学习垃圾收集器的最后一个要点。还记得对象是存在槽中的吧。Ruby 2.1 的槽大小为 40 字节，然而并不是所有的对象都是这么大。&lt;/p&gt;
&lt;p&gt;比如，一个包含 255 个字节的字符串对象。如果对象的大小超过了槽的大小，Ruby 就会额外向操作系统申请一块内存。&lt;/p&gt;
&lt;p&gt;当对象被销毁，槽被释放后，Ruby 会把多余的内存还给操作系统。现在让我们看看 GC::stat 散列中的这些键：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;6.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;malloc_increase&lt;/td&gt;
&lt;td&gt;所有超过槽大小的对象所占用的总比特数&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;malloc_limit&lt;/td&gt;
&lt;td&gt;阈值。如果 malloc_increase 的大小超过了 malloc_limit，垃圾收集器就会在次要模式下运行。一个 Ruby 应用程序的生命周期里，malloc_limit 是被动调整的。它的大小是当前 malloc_increase 的大小乘以调节因子，这个因子默认是 1.4。你可以通过环境变量 RUBY_GC_MALLOC_LIMIT_GROWTH_FACTOR 来设定这个因子&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;6&quot;&gt;&lt;td&gt;oldmalloc_increase 和 oldmalloc_limit&lt;/td&gt;
&lt;td&gt;是上面两个对应的年老代值。如果 oldmalloc_increase 的大小超过了 oldmalloc_limit，垃圾收集器就会在主要模式下运行。oldmalloc_limit 的调节因子more是 1.2。通过环境变量 RUBY_GC_OLDMALLOC_LIMIT_GROWTH_FACTOR 可以设定它&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;作为最后一部分，让我们来看针对特定应用程序进行垃圾收集器调优的环境变量。&lt;/p&gt;
&lt;p&gt;在下一个版本的 Ruby 中，GC::stat 散列中的值对应的环境变量可能会发生变化。好消息是 Ruby 2.2 将支持 3 个分代，Ruby 2.1 只支持两个。这可能会影响到上述变量的设定。&lt;/p&gt;
&lt;p&gt;有关垃圾收集器调优的环境变量的权威信息保存在 &quot;gc.c&quot; 文件中，是 Ruby 源程序的一部分。&lt;/p&gt;
&lt;p&gt;下面是 Ruby 2.1 中用于调优的环境变量（仅供参考）：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;22&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;RUBY_GC_HEAP_INIT_SLOTS&lt;/td&gt;
&lt;td&gt;初始槽的数量。默认为 10k，增加它的值可以让你的应用程序启动时减少垃圾收集器的工作效率&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;RUBY_GC_HEAP_FREE_SLOTS&lt;/td&gt;
&lt;td&gt;垃圾收集器运行后，空槽数量的最小值。如果空槽的数量小于这个值，那么 Ruby 会申请额外的页，并放入堆中。默认值是 4096&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;RUBY_GC_HEAP_GROWTH_FACTOR&lt;/td&gt;
&lt;td&gt;当需要额外的槽时，用于计算需要增加的页数的乘数因子。用已使用的页数乘以这个因子算出还需要增加的页数、默认值是 1.8&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;RUBY_GC_HEAP_GROWTH_MAX_SLOTS&lt;/td&gt;
&lt;td&gt;一次添加到堆中的最大槽数。默认值是0，表示没有限制。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;7&quot;&gt;&lt;td&gt;RUBY_GC_HEAP_OLDOBJECT_LIMIT_FACTOR&lt;/td&gt;
&lt;td&gt;用于计算出发主要模式垃圾收集器的门限值的乘数因子。门限由前一次主要清除后年老代对象数量乘以该因子得到。该门限与当前年老代对象数量成比例。默认值是 2.0。这意味着如果年老代对象在上次主要标记阶段过后的数量翻倍的话，新一轮的主要标记过程将被出发。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;RUBY_GC_MALLOC_LIMIT&lt;/td&gt;
&lt;td&gt;GC::stat 散列中 malloc_limit 的最小值。如果 malloc_increase 超过了 malloc_limit 的值，那么次要模式垃圾收集器就会运行一次。该设定用于确保 malloc_increase 不会小于特定值。它的默认值是 16 777 216（16MB）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;RUBY_GC_MALOC_LIMIT_MAX&lt;/td&gt;
&lt;td&gt;与 RUBY_GC_MALLOC_LIMIT 相反的值，这个设定保证 malloc_limit 不会变得太高。它可以被设置成 0 来取消上限。默认值是 33 554 432（32MB）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;RUBY_GC_MALLOC_LIMIT_GROWTH_FACTOR&lt;/td&gt;
&lt;td&gt;控制 malloc_limit 如何增长的乘数因子。新的 malloc_limit 值由当前 malloc_limit 值乘以这个因子来获得，默认值为 1.4&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;RUBY_GC_OLDMALLOC_LIMIT&lt;/td&gt;
&lt;td&gt;年老代对应的 RUBY_GC_MALLOC_LIMIT 值。默认值是 16 777 216（16MB）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;RUBY_GC_OLDMALLOC_LIMIT_MAX&lt;/td&gt;
&lt;td&gt;年老代对应的 RUBY_GC_MALLOC_LIMIT_MAX 值。默认值是 134 217 728（128MB）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;RUBY_GC_OLDMALLOC_LIMIT_GROWTH_FACTOR&lt;/td&gt;
&lt;td&gt;年老代对应的 RUBY_GC_MALLOC_LIMIT_GROWTH_FACTOR 值。默认值是 1.2&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;第-45-条用-finalizer-构建资源安全网&quot;&gt;第 45 条：用 Finalizer 构建资源安全网&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;最好使用 ensure 子句来保护有限的资源。&lt;/li&gt;
&lt;li&gt;如果必须要在 ensure 子句外报录一个资源（resource），那么就给它创建一个 finalizer（终结方法）&lt;/li&gt;
&lt;li&gt;永远不要再这样一个绑定中创建 finalizer Proc，该绑定引用了一个注定会被销毁的对象，这会造成垃圾收集器无法释放该对象&lt;/li&gt;
&lt;li&gt;记住，finalizer 可能在一个对象销毁后以及程序终止前的任何时间被调用&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;第-46-条认识-ruby-性能分析工具&quot;&gt;第 46 条：认识 Ruby 性能分析工具&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;在修改性能差的代码之前，先使用性能分析工具收集性能相关的信息。&lt;/li&gt;
&lt;li&gt;在 ruby-prof gem 和 Ruby 自带的标准 profile 库之间，选择前者，因为前者更快而且可以提供多种不同的报告。&lt;/li&gt;
&lt;li&gt;如果使用 Ruby 2.1 或者更新的版本，应该考虑使用 stackprof gem 和 memory_profiler gem。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;第-47-条避免在循环中使用对象字面量&quot;&gt;第 47 条：避免在循环中使用对象字面量&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;将循环中的不会变化的对象字面量变成常量。&lt;/li&gt;
&lt;li&gt;在 Ruby 2.1 及更高的版本中冻结字符串字面量，相当于把它作为常量，可以被整个运行程序共享。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;第-48-条考虑记忆化大开销计算&quot;&gt;第 48 条：考虑记忆化大开销计算&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;考虑提供一个方法通过将缓存的变量职位 nil 来重置记忆化。&lt;/li&gt;
&lt;li&gt;确保时钟认真考虑过这些由记忆化而跳过副作用所导致的后果。&lt;/li&gt;
&lt;li&gt;如果不希望调用者修改缓存的变量，那应该考虑让被记忆化的方法返回冻结对象。&lt;/li&gt;
&lt;li&gt;先用工具分析程序的性能，再考虑是否需要记忆化。&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;周末学习了两天才勉强看完了一遍，对于 Ruby 语言的有一些高级特性还是比较吃力的，需要自己反反复复的看才能理解一二。不过好在也是有收获吧，没有白费自己的努力，特地总结一个精简版方便后面的童鞋学习。&lt;/p&gt;
&lt;p&gt;另外这篇文章最开始是使用公司的文档空间创建的，发现 Markdown 虽然精简易于使用，但是功能性上比一些成熟的写文工具要差上很多，就比如对代码的支持吧，用公司的代码块还支持自定义标题、显示行号、是否能缩放、主题等一系列自定义的东西，写出来的东西也更加友好...&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;按照惯例黏一个尾巴：&lt;/p&gt;
&lt;blockquote readability=&quot;6.0896860986547&quot;&gt;
&lt;p&gt;欢迎转载，转载请注明出处！&lt;br/&gt;简书ID：&lt;a href=&quot;https://www.jianshu.com/u/a40d61a49221&quot;&gt;@我没有三颗心脏&lt;/a&gt;&lt;br/&gt;github：&lt;a href=&quot;https://github.com/wmyskxz/&quot;&gt;wmyskxz&lt;/a&gt;&lt;br/&gt;欢迎关注公众微信号：wmyskxz&lt;br/&gt;分享自己的学习 &amp;amp; 学习资料 &amp;amp; 生活&lt;br/&gt;想要交流的朋友也可以加qq群：3382693&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sun, 12 May 2019 15:33:00 +0000</pubDate>
<dc:creator>我没有三颗心脏</dc:creator>
<og:description>本篇是在我接触了 Ruby 很短一段时间后有幸捧起的一本书，下面结合自己的一些思考，来输出一下自己的读书笔记 前言 学习一门新的编程语言通常需要经过两个阶段： 第一个阶段是学习这门编程语言的语法和结构</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wmyskxz/p/10854327.html</dc:identifier>
</item>
<item>
<title>F#周报2019年第19期 - Ken.W</title>
<link>http://www.cnblogs.com/kenwoo/p/10854311.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kenwoo/p/10854311.html</guid>
<description>[unable to retrieve full-text content]新闻 &quot;介绍.NET 5&quot; &quot;发布.NET Core 3.0预览版5以及F 的REPL&quot; &quot;OpenFsharp CFP开启&quot; &quot;F 的Giraffe服务端stub生成器被添加到openapi generator中&quot; &quot;FsToolkit.ErrorHandling现在支持TaskResult&quot; &quot;</description>
<pubDate>Sun, 12 May 2019 15:27:00 +0000</pubDate>
<dc:creator>Ken.W</dc:creator>
<og:description>新闻 '介绍.NET 5' '发布.NET Core 3.0预览版5以及F 的REPL' 'OpenFsharp CFP开启' 'F 的Giraffe服务端stub生成器被添加到openapi gen</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kenwoo/p/10854311.html</dc:identifier>
</item>
<item>
<title>【OCR技术系列之三】大批量生成文字训练集 - 风骚的小柴犬</title>
<link>http://www.cnblogs.com/ZFJ1094038955/p/10854245.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ZFJ1094038955/p/10854245.html</guid>
<description>&lt;p&gt;到周末了，终于可以继续可以静下心写一写OCR方面的东西。上次谈到文字的切割，今天打算总结一下我们怎么得到用于训练的文字数据集。如果是想训练一个手写体识别的模型，用一些前人收集好的手写文字集就好了，比如中科院的&lt;a href=&quot;http://www.nlpr.ia.ac.cn/databases/handwriting/Offline_database.html&quot; target=&quot;_blank&quot;&gt;这些数据集&lt;/a&gt;。但是如果我们只是想要训练一个专门用于识别印刷汉字的模型，那么我们就需要各种印刷字体的训练集，那怎么获取呢？借助强大的图像库，自己生成就行了！&lt;/p&gt;
&lt;p&gt;先捋一捋思路，生成文字集需要什么步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;确定你要生成多少字体，生成一个记录着汉字与label的对应表。&lt;/li&gt;
&lt;li&gt;确定和收集需要用到的字体文件。&lt;/li&gt;
&lt;li&gt;生成字体图像，存储在规定的目录下。&lt;/li&gt;
&lt;li&gt;适当的数据增强。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;第三步的生成字体图像最为重要，如果仅仅是生成很正规的文字，那么用这个正规文字集去训练模型，第一图像数目有点少，第二模型泛化能力比较差，所以我们需要对字体图像做大量的图像处理工作，以增大我们的印刷体文字数据集。&lt;/p&gt;
&lt;p&gt;我总结了一下，我们可以做的一些图像增强工作有这些：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;文字扭曲&lt;/li&gt;
&lt;li&gt;背景噪声（椒盐）&lt;/li&gt;
&lt;li&gt;文字位置（设置文字的中心点）&lt;/li&gt;
&lt;li&gt;笔画粘连（膨胀来模拟）&lt;/li&gt;
&lt;li&gt;笔画断裂（腐蚀来模拟）&lt;/li&gt;
&lt;li&gt;文字倾斜（文字旋转）&lt;/li&gt;
&lt;li&gt;多种字体&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;做完以上增强后，我们得到的数据集已经非常庞大了。&lt;/p&gt;
&lt;p&gt;现在开始一步一步生成我们的3755个汉字的印刷体文字数据集。&lt;/p&gt;
&lt;h2 id=&quot;一生成汉字与label的对应表&quot;&gt;一、生成汉字与label的对应表&lt;/h2&gt;
&lt;p&gt;这里的汉字、label映射表的生成我使用了pickel模块，借助它生成一个id:汉字的映射文件存储下来。&lt;br/&gt;这里举个小例子说明怎么生成这个“汉字：id”映射表。&lt;/p&gt;
&lt;p&gt;首先在一个txt文件里写入你想要的汉字，如果对汉字对应的ID没有要求的话，我们不妨使用该汉字的排位作为其ID，比如“一二三四五”中，五的ID就是00005。如此类推，把汉字读入内存，建立一个字典，把这个关系记录下来，再使用pickle.dump存入文件保存。&lt;/p&gt;
&lt;h2 id=&quot;二收集字体文件&quot;&gt;二、收集字体文件&lt;/h2&gt;
&lt;p&gt;字体文件上网收集就好了，但是值得注意的是，不是每一种字体都支持汉字，所以我们需要筛选出真正适合汉字生成的字体文件才可以。我一共使用了十三种汉字字体作为我们接下来汉字数据集用到的字体，具体如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1093303/201802/1093303-20180209210217982-1742939776.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然，如果需要进一步扩大数据集来增强训练得到的模型的泛化能力，可以花更多的时间去收集各类汉字字体，那么模型在面对各种字体时也能从容应对，给出准确的预测。&lt;/p&gt;
&lt;h2 id=&quot;三文字图像生成&quot;&gt;三、文字图像生成&lt;/h2&gt;
&lt;p&gt;首先是定义好输入参数，其中包括输出目录、字体目录、测试集大小、图像尺寸、图像旋转幅度等等。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;79&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; args_parse():
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;解析输入参数&lt;/span&gt;
    parser =&lt;span&gt; argparse.ArgumentParser(
        description&lt;/span&gt;=description, formatter_class=&lt;span&gt;RawTextHelpFormatter)
    parser.add_argument(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;--out_dir&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, dest=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;out_dir&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                        default&lt;/span&gt;=None, required=&lt;span&gt;True,
                        help&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;write a caffe dir&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    parser.add_argument(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;--font_dir&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, dest=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;font_dir&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                        default&lt;/span&gt;=None, required=&lt;span&gt;True,
                        help&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;font dir to to produce images&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    parser.add_argument(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;--test_ratio&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, dest=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test_ratio&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                        default&lt;/span&gt;=0.2, required=&lt;span&gt;False,
                        help&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test dataset size&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    parser.add_argument(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;--width&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, dest=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;width&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                        default&lt;/span&gt;=None, required=&lt;span&gt;True,
                        help&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;width&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    parser.add_argument(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;--height&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, dest=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;height&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                        default&lt;/span&gt;=None, required=&lt;span&gt;True,
                        help&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;height&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    parser.add_argument(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;--no_crop&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, dest=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;no_crop&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                        default&lt;/span&gt;=True, required=&lt;span&gt;False,
                        help&lt;/span&gt;=&lt;span&gt;''&lt;/span&gt;, action=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;store_true&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    parser.add_argument(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;--margin&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, dest=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;margin&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                        default&lt;/span&gt;=0, required=&lt;span&gt;False,
                        help&lt;/span&gt;=&lt;span&gt;''&lt;/span&gt;&lt;span&gt;, )
    parser.add_argument(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;--rotate&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, dest=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;rotate&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                        default&lt;/span&gt;=0, required=&lt;span&gt;False,
                        help&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;max rotate degree 0-45&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    parser.add_argument(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;--rotate_step&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, dest=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;rotate_step&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                        default&lt;/span&gt;=0, required=&lt;span&gt;False,
                        help&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;rotate step for the rotate angle&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    parser.add_argument(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;--need_aug&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, dest=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;need_aug&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                        default&lt;/span&gt;=False, required=&lt;span&gt;False,
                        help&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;need data augmentation&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, action=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;store_true&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)   
    args &lt;/span&gt;=&lt;span&gt; vars(parser.parse_args()) 
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; args
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;接下来需要将我们第一步得到的对应表读入内存，因为这个表示ID到汉字的映射，我们在做一下转换，改成汉字到ID的映射，用于后面的字体生成。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;将汉字的label读入，得到（ID：汉字）的映射表label_dict&lt;/span&gt;
label_dict =&lt;span&gt; get_label_dict()

char_list&lt;/span&gt;=[]  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 汉字列表&lt;/span&gt;
value_list=[] &lt;span&gt;#&lt;/span&gt;&lt;span&gt; label列表&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; (value,chars) &lt;span&gt;in&lt;/span&gt;&lt;span&gt; label_dict.items():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt; (value,chars)
    char_list.append(chars)
    value_list.append(value)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 合并成新的映射关系表：（汉字：ID）&lt;/span&gt;
lang_chars =&lt;span&gt; dict(zip(char_list,value_list)) 
font_check &lt;/span&gt;= FontCheck(lang_chars) 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们对旋转的角度存储到列表中，旋转角度的范围是[-rotate,rotate].&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt; rotate &amp;lt;&lt;span&gt; 0:
    roate &lt;/span&gt;= -&lt;span&gt; rotate

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; rotate &amp;gt; 0 &lt;span&gt;and&lt;/span&gt; rotate &amp;lt;= 45&lt;span&gt;:
    all_rotate_angles &lt;/span&gt;=&lt;span&gt; []
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(0, rotate+1&lt;span&gt;, rotate_step):  
        all_rotate_angles.append(i)
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(-&lt;span&gt;rotate, 0, rotate_step):
        all_rotate_angles.append(i)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;print(all_rotate_angles)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;现在说一下字体图像是怎么生成的，首先我们使用的工具是PIL。PIL里面有很好用的汉字生成函数，我们用这个函数再结合我们提供的字体文件，就可以生成我们想要的数字化的汉字了。我们先设定好我们生成的字体颜色为黑底白色，字体尺寸由输入参数来动态设定。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1093303/201802/1093303-20180209210320013-473428024.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 生成字体图像&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Font2Image(object):

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self,
                 width, height,
                 need_crop, margin):
        self.width &lt;/span&gt;=&lt;span&gt; width
        self.height &lt;/span&gt;=&lt;span&gt; height
        self.need_crop &lt;/span&gt;=&lt;span&gt; need_crop
        self.margin &lt;/span&gt;=&lt;span&gt; margin

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; do(self, font_path, char, rotate=&lt;span&gt;0):
        find_image_bbox &lt;/span&gt;=&lt;span&gt; FindImageBBox()
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 黑色背景&lt;/span&gt;
        img = Image.new(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RGB&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, (self.width, self.height), &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;black&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        draw &lt;/span&gt;=&lt;span&gt; ImageDraw.Draw(img)
        font &lt;/span&gt;= ImageFont.truetype(font_path, int(self.width * 0.7&lt;span&gt;),)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 白色字体&lt;/span&gt;
        draw.text((0, 0), char, (255, 255, 255&lt;span&gt;),
                  font&lt;/span&gt;=&lt;span&gt;font)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; rotate !=&lt;span&gt; 0:
            img &lt;/span&gt;=&lt;span&gt; img.rotate(rotate)
        data &lt;/span&gt;=&lt;span&gt; list(img.getdata())
        sum_val &lt;/span&gt;=&lt;span&gt; 0
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i_data &lt;span&gt;in&lt;/span&gt;&lt;span&gt; data:
            sum_val &lt;/span&gt;+=&lt;span&gt; sum(i_data)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; sum_val &amp;gt; 2&lt;span&gt;:
            np_img &lt;/span&gt;= np.asarray(data, dtype=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;uint8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
            np_img &lt;/span&gt;=&lt;span&gt; np_img[:, 0]
            np_img &lt;/span&gt;=&lt;span&gt; np_img.reshape((self.height, self.width))
            cropped_box &lt;/span&gt;=&lt;span&gt; find_image_bbox.do(np_img)
            left, upper, right, lower &lt;/span&gt;=&lt;span&gt; cropped_box
            np_img &lt;/span&gt;= np_img[upper: lower + 1, left: right + 1&lt;span&gt;]
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; self.need_crop:
                preprocess_resize_keep_ratio_fill_bg &lt;/span&gt;=&lt;span&gt; \
                    PreprocessResizeKeepRatioFillBG(self.width, self.height,
                                                    fill_bg&lt;/span&gt;=&lt;span&gt;False,
                                                    margin&lt;/span&gt;=&lt;span&gt;self.margin)
                np_img &lt;/span&gt;=&lt;span&gt; preprocess_resize_keep_ratio_fill_bg.do(
                    np_img)
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; cv2.imwrite(path_img, np_img)&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; np_img
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;img doesn't exist.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们写两个循环，外层循环是汉字列表，内层循环是字体列表，对于每个汉字会得到一个image_list列表，里面存储着这个汉字的所有图像。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt; (char, value) &lt;span&gt;in&lt;/span&gt; lang_chars.items():  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 外层循环是字&lt;/span&gt;
    image_list =&lt;span&gt; []
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt; (char,value)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;char_dir = os.path.join(images_dir, &quot;%0.5d&quot; % value)&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; j, verified_font_path &lt;span&gt;in&lt;/span&gt; enumerate(verified_font_paths):    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 内层循环是字体   &lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; rotate ==&lt;span&gt; 0:
            image &lt;/span&gt;=&lt;span&gt; font2image.do(verified_font_path, char)
            image_list.append(image)
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; k &lt;span&gt;in&lt;/span&gt;&lt;span&gt; all_rotate_angles: 
                image &lt;/span&gt;= font2image.do(verified_font_path, char, rotate=&lt;span&gt;k)
                image_list.append(image)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们将image_list中图像按照比例分为训练集和测试集存储。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
  test_num = len(image_list) *&lt;span&gt; test_ratio
        random.shuffle(image_list)  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 图像列表打乱&lt;/span&gt;
        count =&lt;span&gt; 0
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(len(image_list)):
            img &lt;/span&gt;=&lt;span&gt; image_list[i]
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;print(img.shape)&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; count &amp;lt;&lt;span&gt; test_num :
                char_dir &lt;/span&gt;= os.path.join(test_images_dir, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%0.5d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; value)
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                char_dir &lt;/span&gt;= os.path.join(train_images_dir, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%0.5d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; value)

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; os.path.isdir(char_dir):
                os.makedirs(char_dir)

            path_image &lt;/span&gt;= os.path.join(char_dir,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d.png&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; count)
            cv2.imwrite(path_image,img)
            count &lt;/span&gt;+= 1
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;写好代码后，我们执行如下指令，开始生成印刷体文字汉字集。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs lua&quot;&gt; python gen_printed_char.py &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解析一下上述指令的附属参数：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;--out_dir 表示生成的汉字图像的存储目录&lt;/li&gt;
&lt;li&gt;--font_dir 表示放置汉字字体文件的路径&lt;/li&gt;
&lt;li&gt;--width --height 表示生成图像的高度和宽度&lt;/li&gt;
&lt;li&gt;--margin 表示字体与边缘的间隔&lt;/li&gt;
&lt;li&gt;--rotate 表示字体旋转的范围，[-rotate,rotate]&lt;/li&gt;
&lt;li&gt;--rotate_step 表示每次旋转的间隔&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;生成这么一个3755个汉字的数据集的所需的时间还是很久的，估计接近一个小时。其实这个生成过程可以用多线程、多进程并行加速，但是考虑到这种文字数据集只需生成一次就好，所以就没做这方面的优化了。数据集生成完我们可以发现，在dataset文件夹下得到train和test两个文件夹，train和test文件夹下都有3755个子文件夹，分别存储着生成的3755个汉字对应的图像，每个子文件的名字就是该汉字对应的id。随便选择一个train文件夹下的一个子文件夹打开，可以看到所获得的汉字图像，一共634个。&lt;/p&gt;
&lt;p&gt;dataset下自动生成测试集和训练集&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1093303/201802/1093303-20180209210356545-1280275168.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;测试集和训练集下都有3755个子文件夹，用于存储每个汉字的图像。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1093303/201802/1093303-20180209210507951-532205948.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;生成出来的汉字图像&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1093303/201802/1093303-20180209210545763-206700772.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;额外的图像增强&quot;&gt;额外的图像增强&lt;/h2&gt;
&lt;p&gt;第三步生成的汉字图像是最基本的数据集，它所做的图像处理仅有旋转这么一项，如果我们想在数据增强上再做多点东西，想必我们最终训练出来的OCR模型的性能会更加优秀。我们使用opencv来完成我们定制的汉字图像增强任务。&lt;/p&gt;
&lt;p&gt;因为生成的图像比较小，仅仅是30*30，如果对这么小的图像加噪声或者形态学处理，得到的字体图像会很糟糕，所以我们在做数据增强时，把图片尺寸适当增加，比如设置为100×100，再进行相应的数据增强，效果会更好。&lt;/p&gt;
&lt;h3 id=&quot;噪点增加&quot;&gt;噪点增加&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; add_noise(cls,img):
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(20): &lt;span&gt;#&lt;/span&gt;&lt;span&gt;添加点噪声&lt;/span&gt;
        temp_x =&lt;span&gt; np.random.randint(0,img.shape[0])
        temp_y &lt;/span&gt;= np.random.randint(0,img.shape[1&lt;span&gt;])
        img[temp_x][temp_y] &lt;/span&gt;= 255
    &lt;span&gt;return&lt;/span&gt; img
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&quot;适当腐蚀&quot;&gt;适当腐蚀&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; add_erode(cls,img):
    kernel &lt;/span&gt;= cv2.getStructuringElement(cv2.MORPH_RECT,(3, 3&lt;span&gt;))    
    img &lt;/span&gt;=&lt;span&gt; cv2.erode(img,kernel) 
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; img
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&quot;适当膨胀&quot;&gt;适当膨胀&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; add_dilate(cls,img):
    kernel &lt;/span&gt;= cv2.getStructuringElement(cv2.MORPH_RECT,(3, 3&lt;span&gt;))    
    img &lt;/span&gt;=&lt;span&gt; cv2.dilate(img,kernel) 
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; img
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然后做随机扰动&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt; do(self,img_list=&lt;span&gt;[]):
    aug_list&lt;/span&gt;=&lt;span&gt; copy.deepcopy(img_list)
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(len(img_list)):
        im &lt;/span&gt;=&lt;span&gt; img_list[i]
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; self.noise &lt;span&gt;and&lt;/span&gt; random.random()&amp;lt;0.5&lt;span&gt;:
            im &lt;/span&gt;=&lt;span&gt; self.add_noise(im)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; self.dilate &lt;span&gt;and&lt;/span&gt; random.random()&amp;lt;0.25&lt;span&gt;:
            im &lt;/span&gt;=&lt;span&gt; self.add_dilate(im)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; self.erode &lt;span&gt;and&lt;/span&gt; random.random()&amp;lt;0.25&lt;span&gt;:
            im &lt;/span&gt;=&lt;span&gt; self.add_erode(im)    
        aug_list.append(im)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; aug_list
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;输入指令&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs lua&quot;&gt;python gen_printed_char.py &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用这种生成的图像如下图所示，第一数据集扩大了两倍，第二图像的丰富性进一步提高，效果还是明显的。当然，如果要获得最好的效果，还需要调一下里面的参数，这里就不再详细说明了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1093303/201802/1093303-20180209210644091-99882600.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，我们所需的印刷体汉字数据集已经成功生成完毕，下一步要做的就是利用这些数据集设计一个卷积神经网络做文字识别了！完整的代码可以在&lt;a href=&quot;https://github.com/PythonCancer/OCR-/blob/master/OCR%E6%8A%80%E6%9C%AF%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%89&quot; target=&quot;_blank&quot;&gt;我的github&lt;/a&gt;获取。&lt;/p&gt;
</description>
<pubDate>Sun, 12 May 2019 15:15:00 +0000</pubDate>
<dc:creator>风骚的小柴犬</dc:creator>
<og:description>到周末了，终于可以继续可以静下心写一写OCR方面的东西。上次谈到文字的切割，今天打算总结一下我们怎么得到用于训练的文字数据集。如果是想训练一个手写体识别的模型，用一些前人收集好的手写文字集就好了，比如</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ZFJ1094038955/p/10854245.html</dc:identifier>
</item>
<item>
<title>mysql行锁和死锁检测 - 拍黄片的码农</title>
<link>http://www.cnblogs.com/sjks/p/10854145.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sjks/p/10854145.html</guid>
<description>&lt;p&gt;&lt;span&gt;行&lt;span&gt;锁顾名思义，就是针对单行数据加锁，在mysql中，锁的实现是由引擎层实现的,MyISAM引擎就不支持行锁&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不支持行锁就意味着并发控制只能使用表锁，也就是说同一时间，在这个表上只能有一个更新在执行，这就会&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;影响到业务的并发度。InnoDB是支持行锁的，这也是MyISAM被InnoDB替代的重要原因之一。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;两阶段锁协议&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 先举个例子，事务B的语句执行的时候会发生什么现象？这取决于事务A在执行完两条语句后持有那些锁，以及在什么时候释放？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1245814/201905/1245814-20190512221327319-1489471450.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;大家可以自己做个实验，是这样的，事务B在执行这条语句时会被阻塞，大家会不会有疑惑，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;前面两条语句不是执行完了吗？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为什么还会阻塞？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其实事务A的加锁时机是执行第一条语句的时候，释放锁的时候是commit完以后&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是事务B是在事务A commit前执行的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个时候事务A还持有id=1这行数据的锁，所以事务B会被阻塞。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;知道了这个原理对于我们有什么启示呢？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;既然知道了锁的释放是在commit之后&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么我们就可以把最可能造成锁冲突&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最可能影响并发度的锁尽量往后放&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;举个例子:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;业务:顾客A要在影院B买一张电影票&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;操作:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.从顾客A的账户余额中减掉电影票的价格&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.将影院B的账户余额增加这张电影票价&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.增加一条操作日志&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;大家想想看，这三个操作，那个最容易影响到并发度会造成锁冲突&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;很明显是第二个操作，为啥呢？想想看操作1中只是锁了这个用户的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这行数据，只对他自己有影响，这个时候如果有个顾客C也买了电影&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;票，那么这个时候的冲突就是操作2了，因为人家也需要更新影院的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;账户余额，所以我们要把操作2放在最后执行，因为这样对操作2涉及的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;行锁，锁住时间就会少一点，最大程度的减少了事务之间的等待&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;提升了并发度。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;死锁和死锁检测&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1245814/201905/1245814-20190512223548013-342840533.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如图所示，事务A在等待事务B释放id=2的锁，事务B在等待事务A释放id=1的锁&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这种情况就是死锁&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;发生死锁有两种方法解决&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.直接进入等待，直到超时。这个超时时间可以通过参数innodb_lock_wait_timeout来设置&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以执行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   将参数innodb_deadlock_detect设置为on，表示开启这个逻辑&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在innodb中，innodb_lock_wait_timeout的值默认是50s，以为着如果使用第一种方法，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一个被锁住的线程要过50s才会超时退出，然后其他线程才有可能继续执行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于在线服务来说，这个等待时间往往是无法接受的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是我们又不能把这个时间设置的很小，比如1s，如果这个时候不是死锁，而是正常的锁等待呢&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这样就会造成很多误伤,所以我们还是使用死锁检测好一些，好在innodb_deadlock_detect默认就是on&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;其实死锁检测也是会占用很多cpu资源的，当事务被锁住的时候，就要看看它锁依赖的线程有没有被别人锁住&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如此循环，最后判断是否出现了循环等待，也就是死锁&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 12 May 2019 14:52:00 +0000</pubDate>
<dc:creator>拍黄片的码农</dc:creator>
<og:description>行锁顾名思义，就是针对单行数据加锁，在mysql中，锁的实现是由引擎层实现的,MyISAM引擎就不支持行锁 不支持行锁就意味着并发控制只能使用表锁，也就是说同一时间，在这个表上只能有一个更新在执行，这</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sjks/p/10854145.html</dc:identifier>
</item>
<item>
<title>多进程PHP脚本实现海量数据转移总结 - 大佬sam要争气</title>
<link>http://www.cnblogs.com/yaozhengqi/p/10854123.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yaozhengqi/p/10854123.html</guid>
<description>

&lt;p&gt;由于项目的新版本有大改动，需求是将一些旧表的数据转移到新表来，于是使用PHP写了数据脚本，对MySQL的数据进行读取，计算，转移，插入等处理，实现千万级别数据的计算和转移。这里面也遇到一些问题，这里做下总结：&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;将几个旧表的数据拷到新表来，有些字段发生了变化，有些字段的值需要计算；&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li class=&quot;_mce_tagged_br&quot;&gt;单表数据量到达千万级，而且线上有多个库，要对脚本进行必要的优化；&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li class=&quot;_mce_tagged_br&quot;&gt;脚本执行时间控制在两个小时之内；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img class=&quot;rich_pages&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/LbuY6x6k27owZT1lG2Q1OEwP2H2Lc3trRQuhVtP59F6spstyN5YgAsZSpDLM0dXMA15HicjI2iaJxjYTd4FKNxqw/640?wx_fmt=jpeg&quot; alt=&quot;&quot; data-ratio=&quot;0.5&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;1200&quot;/&gt;&lt;/p&gt;

&lt;p&gt;1、&lt;strong&gt;分析表数据的关联性，整合脚本。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;分析了几个表数据之间的联系，可以将一些有关联的表的数据放在一个数据脚本中，比如user表和user_detail表，这两个表的数据是有一些关联的，一些数据值的计算不用重复读取，减少脚本的计算操作，节约时间；&lt;/p&gt;

&lt;p&gt;2、&lt;strong&gt;数据读取时，减少配置数据的加载操作，减少数据查询操作。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;开始数据转移时，必要的配置数据必须在脚本开始时全部加载进来，不能在转移时用到再去进行查询，因为每次查询都是意味着消耗更多时间。当然这里有个前提是你的机器内存要够大，PHP的这种加载是比较消耗内存的。一个脚本运行起来，内存都要占了很多G，这种其实就是用空间换时间的做法。当然，当机器内存不够大，或者性能不够强时，还是先保证脚本的健壮性，再来考虑性能。&lt;/p&gt;
&lt;p&gt;PHP可以使用set_time_limit ( 0 ); @ini_set('memory_limit','2048M');来指定脚本执行的最长时间和使用内存的最大值；&lt;/p&gt;

&lt;p&gt;3、&lt;strong&gt;脚本处理数据时，需要分段分批处理。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们在处理数据时，需要先读取出用户id，在根据id查询表的数据再做处理。就是我们的处理逻辑都是以用户id为基准，按照用户id做key，数据做value的方式，遍历数据。为了减少机器的负载，充分利用机器的性能，我们使用一个while循环，每次处理3000个用户的数据，转移完后再查询出3000个用户的数据，如此类推，直到所有数据处理完，也就是跳出while循环。&lt;/p&gt;
&lt;p&gt;同时必须要保证数据的有效性，不然insert不进去。这里还遇到过一个问题，就是在使用PHP的函数批量insert数据时，有时一个sql语句数据量太多，会超过MySQL最大的insert限制，所以在insert之前，需要将需要插入的数据进行分段，也就是对数据进行隔断处理，分批插入。PHP中可以使用array_slice()对数组数据进行分段。&lt;/p&gt;

&lt;p&gt;4、&lt;strong&gt;将多次MySQL处理集合在一次的commit上。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们在一次循环中是使用了一次try-catch来监控一次操作，当某个数据处理有异常时，就直接抛出异常，保证每次处理数据的完整性。我们每次处理开始前，先开启一个事务，处理完成后会进行一次提交事务。为了节省时间，可以优化成：开启一个事务，在遍历了多个用户数据后，再进行一次提交，或者在遇到异常后也提交一次，这样可以保证数据完整，也可以减少多次commit db的操作，节约时间。&lt;/p&gt;

&lt;p&gt;5、&lt;strong&gt;使用shell脚本整合每个PHP脚本，开启多个PHP进程。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为我们处理一个库的数据要涉及到多个PHP脚本，可以使用shell来整合多个脚本，并且让其顺序执行。使用nohub命令不挂断地运行命令（后面再单独介绍这个linux命令）。根据机器的核数来开启多少个PHP进程，充分发挥机器的性能。&lt;/p&gt;


&lt;p&gt;比如执行一个PHP脚本，可以这样子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
进程1：php move_user.php a &lt;span&gt;0&lt;/span&gt; &lt;span&gt;10000&lt;/span&gt;&lt;span&gt;

进程2：php move_user.php a &lt;/span&gt;&lt;span&gt;10000&lt;/span&gt; &lt;span&gt;20000&lt;/span&gt;&lt;span&gt;

进程3：php move_user.php b &lt;/span&gt;&lt;span&gt;0&lt;/span&gt; &lt;span&gt;10000&lt;/span&gt;&lt;span&gt;

进程4：php move_user.php b &lt;/span&gt;&lt;span&gt;10000&lt;/span&gt; &lt;span&gt;20000&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这样表示使用PHP cli模式（命令模式）执行一个PHP脚本，对于进程1，a 表示是数据库a，0 和10000表示从用户id 0开始，执行到用户id 10000 结束，一个进程处理10000个用户数据。&lt;/p&gt;
&lt;p&gt;进程2表示执行数据库a 10000 到20000的用户数据。&lt;/p&gt;
&lt;p&gt;这样多个进程，可以同时执行多个库的数据，多个区段的用户数据，节省时间。&lt;/p&gt;
&lt;p&gt;当然，每次处理多少个用户数据，每次开多少个进程，每次遍历多少数据，都是根据项目的业务数据，和机器的最大负载来综合处理，达到一个平衡状态。&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;此次数据处理原本预期要一个小时，结果由于其他原因，后面花费了两个多小时，但整体都是在计划之内，所以是正常的；&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li class=&quot;_mce_tagged_br&quot;&gt;PHP和MySQL做数据交互，充分利用了PHP的性能后，瓶颈就在与MySQL更新和插入数据了，我们就是通过分段循环处理，分段提交事务来平衡了MySQL的瓶颈；&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li class=&quot;_mce_tagged_br&quot;&gt;MySQL单表数据太大，后面需要单独对这块进行优化，不然以后对数据进行更新和备份时，都要浪费大量的时间；&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li class=&quot;_mce_tagged_br&quot;&gt;必须保证脚本逻辑没有问题，不然后面重跑就很蛋疼了。&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;---------------------------------------------------END----------------------------------------------------&lt;/p&gt;
&lt;p&gt;欢迎关注我的公众号【phper的进阶之路】&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/941257/201904/941257-20190407191944067-24565863.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不断更新各种技术心得，免费提供各种学习资源！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 12 May 2019 14:47:00 +0000</pubDate>
<dc:creator>大佬sam要争气</dc:creator>
<og:description>背景 由于项目的新版本有大改动，需求是将一些旧表的数据转移到新表来，于是使用PHP写了数据脚本，对MySQL的数据进行读取，计算，转移，插入等处理，实现千万级别数据的计算和转移。这里面也遇到一些问题，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yaozhengqi/p/10854123.html</dc:identifier>
</item>
<item>
<title>Docker从入门到动手实践 - 糯米粥</title>
<link>http://www.cnblogs.com/nsky/p/10853194.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nsky/p/10853194.html</guid>
<description>&lt;p&gt;一些理论知识，我这里就不累赘了&lt;/p&gt;
&lt;p&gt;docker 入门资料，参考：&lt;a href=&quot;https://yeasy.gitbooks.io/docker_practice/content/&quot; target=&quot;_blank&quot;&gt;https://yeasy.gitbooks.io/docker_practice/content/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Dockerfile常用命令，图片来源于网络&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/450977/201905/450977-20190512115951746-136143052.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Dockerfile 打包控制台应用程序&lt;/p&gt;
&lt;p&gt; 新建一个控制台程序，控制台程序添加一个文本文件，去掉.txt 扩展名，改成Dockerfile 输入以下代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
FROM microsoft/&lt;span&gt;dotnet:sdk AS build
WORKDIR &lt;/span&gt;/&lt;span&gt;code
COPY &lt;/span&gt;*.csproj /&lt;span&gt;code
RUN dotnet restore

COPY . &lt;/span&gt;/&lt;span&gt;code
RUN dotnet publish &lt;/span&gt;-c Release -o &lt;span&gt;out&lt;/span&gt;&lt;span&gt;

FROM microsoft&lt;/span&gt;/&lt;span&gt;dotnet:runtime
WORKDIR &lt;/span&gt;/&lt;span&gt;app
COPY &lt;/span&gt;--&lt;span&gt;from&lt;/span&gt;=build /code/&lt;span&gt;out&lt;/span&gt; /&lt;span&gt;app
ENTRYPOINT [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dotnet&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;console.dll&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Program.cs 中编写测试代码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/450977/201905/450977-20190512120451491-712765193.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 一切准备完成。就是build把项目打包成镜像了&lt;/p&gt;
&lt;p&gt;切换到当前项目路径下。输入：  &lt;span class=&quot;cnblogs_code&quot;&gt;docker build -t cn/console:v1 .&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;docker build -t ：是打包固有的命令&lt;/p&gt;
&lt;p&gt;cn/console:v1 ：&lt;/p&gt;
&lt;p&gt;cn：是组织名称或者说是用户名，如果你想把自己的镜像push到hub.docker 上，cn必须是你自己的用户名&lt;/p&gt;
&lt;p&gt;console：是镜像名称&lt;/p&gt;
&lt;p&gt;v1：是tag。一个标签，可以用来区分同一个镜像，不同用途。，如果不指定。默认是latest&lt;/p&gt;
&lt;p&gt;. ：代表当前目录为上下文，dockerfile也必定是在当前目录下&lt;/p&gt;
&lt;p&gt;回车后，会看到一系列的执行步骤，dockerfile中。一条命令就是一个步骤&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/450977/201905/450977-20190512121748301-50736504.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 通过 docker images 可以查看所有镜像&lt;/p&gt;
&lt;p&gt;通过docker images cn/console 查看相关镜像&lt;/p&gt;
&lt;p&gt;比如我本地有3个 cn/console镜像，但tag不同&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/450977/201905/450977-20190512122613150-1073119136.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;既然镜像有了。那么就可以根据镜像生成容器了。容器是镜像的一个实例。镜像运行起来才会有容器，就跟类和对象一样，new一个类，是实例化的操作&lt;/p&gt;
&lt;p&gt; 输入命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
docker run --name myfirst cn/console:v1
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/450977/201905/450977-20190512123935748-529065082.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;因为是占用前端线程运行容器，所有界面无法继续输入命令了。可以Ctrl+c 结束容器运行&lt;/p&gt;
&lt;p&gt; 从上面的dockerfile。你会发现，我们是把源码打包成镜像的。也就算执行了restore，到Release操作&lt;/p&gt;
&lt;p&gt;其实如果你是已经Release后的文件了。dockerfile可以更简单&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
FROM microsoft/&lt;span&gt;dotnet
WORKDIR &lt;/span&gt;/&lt;span&gt;app
COPY . &lt;/span&gt;/&lt;span&gt;app
CMD [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dotnet&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;run&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 以上就是一个基础的程序打包成镜像，我觉得这不是重点，常用的应该是应用程序，而不是控制台程序&lt;/p&gt;

&lt;p&gt;后面打算把net core api打包成镜像。在讲这个之前，我们先来搭建好环境。&lt;/p&gt;


&lt;p&gt;因为我有个阿里云服务器（CentOS7），然后有2台笔记本，一个是Docker for Windows 环境，一个是CentOS7，所以经常会在这3个环境中来回折腾&lt;/p&gt;
&lt;p&gt;两种系统还是有区别的，至少我弄的时候，遇到过不少问题&lt;/p&gt;
&lt;p&gt;1：for Windows中默认拉起的镜像都在C盘。会导致C盘越来越大，建议迁移&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/450977/201905/450977-20190512124841791-2138683431.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;如果迁移的盘。比如我这个E盘。路径中已经存在MobyLinuxVM.vhdx 。是迁移不过的。要删除，但之前的镜像都没有了&lt;/p&gt;
&lt;p&gt;如果你想保存，先重命名MobyLinuxVM.vhdx，迁移后。删除之后的。之前的重命名回来即可&lt;/p&gt;

&lt;p&gt;2：共享盘。为了数据卷挂载用&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/450977/201905/450977-20190512125027194-55387981.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 3：配置镜像加速（https://hlef8lmt.mirror.aliyuncs.com）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/450977/201905/450977-20190512135614247-1870508729.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 然后可以去hub.docker上寻找需要的镜像，官方的mysql有2个镜像&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/450977/201905/450977-20190512125257431-2136358648.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 当然你通过命令也可以收索到：  &lt;span class=&quot;cnblogs_code&quot;&gt;docker search mysql&lt;/span&gt; &lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/450977/201905/450977-20190512125453248-959723464.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 首先来看docker mysql&lt;/p&gt;
&lt;p&gt;准备需要挂载的目录和文件，上面我设置的共享盘是D盘，所以挂载的在D盘&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/450977/201905/450977-20190512125926185-840563285.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;my.cnf配置文件，主要是设置mysql的参数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[mysqld]
user&lt;/span&gt;=&lt;span&gt;mysql
character&lt;/span&gt;-&lt;span&gt;set&lt;/span&gt;-server=&lt;span&gt;utf8
[client]
&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;-character-&lt;span&gt;set&lt;/span&gt;=&lt;span&gt;utf8
[mysql]
&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;-character-&lt;span&gt;set&lt;/span&gt;=utf8
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;data是空的。当run的时候，mysql会写入文件&lt;/p&gt;
&lt;p&gt;sql是需要在运行myslq后执行的初始化文件，比如我这里是给刚创建的用户名分配权限&lt;/p&gt;
&lt;p&gt;这里为了说明sql是执行成功的。我在加条。创建数据库的sql，创建数据库 docker和user表，并插入一条数据&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
GRANT ALL PRIVILEGES ON *.* TO &lt;span&gt;'&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;@&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; WITH GRANT OPTION;&lt;br/&gt;Create DATABASE docker;&lt;br/&gt;USE docker;&lt;br/&gt;CREATE TABLE user (ID int auto_increment primary key,name nvarchar(20),address nvarchar(50));&lt;br/&gt;insert into user(name,address)values('刘德华','香港');
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;初始化后就执行的好处是。不用在run后，去手动执行，关于run后手动执行，&lt;/p&gt;
&lt;p&gt;可以查看我之前的docker安装mysql &lt;a href=&quot;https://www.cnblogs.com/nsky/p/10413136.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/nsky/p/10413136.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;全部配置完成后，开始敲命令，以下命令需要去掉注释&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
docker run -d -p &lt;span&gt;3306&lt;/span&gt;:&lt;span&gt;3306&lt;/span&gt; 
--&lt;span&gt;restart always #总是自动重启。比如系统重启，该容器会自动启动
&lt;/span&gt;-e MYSQL_USER=&lt;span&gt;test #创建用户名test
&lt;/span&gt;-e MYSQL_PASSWORD=&lt;span&gt;123456&lt;/span&gt;&lt;span&gt; #test密码
&lt;/span&gt;-e MYSQL_PASSWORD_HOST=%&lt;span&gt; #test 开启外部登陆
&lt;/span&gt;-e MYSQL_ROOT_PASSWORD=&lt;span&gt;123456&lt;/span&gt;&lt;span&gt;  #root密码
&lt;/span&gt;-e MYSQL_ROOT_HOST=%&lt;span&gt; #root开启外部登陆
&lt;/span&gt;-v /d/docker/mysql/my.cnf:/etc/&lt;span&gt;my.cnf #配置文件
&lt;/span&gt;-v /d/docker/mysql/sql:/docker-entrypoint-&lt;span&gt;initdb.d #初始化的sql
&lt;/span&gt;-v /d/docker/mysql/data:/&lt;span&gt;var&lt;/span&gt;/lib/&lt;span&gt;mysql  #data文件
&lt;/span&gt;--&lt;span&gt;name mysql #镜像名称
mysql #基于那个镜像创建容器&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;执行成功没有异常后。通过  &lt;span class=&quot;cnblogs_code&quot;&gt;docker ps&lt;/span&gt;  可以查看运行的容器，如果没有， 那就通过 &lt;span class=&quot;cnblogs_code&quot;&gt;docker ps -a &lt;/span&gt;一定会有的&lt;/p&gt;
&lt;p&gt;现在可以通过Navicat连接试试&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/450977/201905/450977-20190512133851799-1344886052.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;创建了docker库。user表也有数据，能看到mysql库，说明test用户是有权限的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/450977/201905/450977-20190512143645554-425743880.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 当我使用mysql-server 镜像时，创建容器会无法启动&lt;/p&gt;
&lt;p&gt;可以看到。启动失败后。又继续重启，因为参数指定了restart always&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/450977/201905/450977-20190512140234291-1766259132.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 输入命令  &lt;span class=&quot;cnblogs_code&quot;&gt;docker logs mysql&lt;/span&gt;  查看启动日志&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/450977/201905/450977-20190512140910484-1889681072.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 最后在my.cnf中加这个，经测试，启动成功，就不一一放图了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/450977/201905/450977-20190512141136879-689845893.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 数据库准备好了，那么就快速的构建一个net core api 接口&lt;/p&gt;
&lt;p&gt;1：引入NugGet包，MySql.Data.EntityFrameworkCore&lt;/p&gt;
&lt;p&gt;2：创建DbContext&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Docker.Api.Model;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.EntityFrameworkCore;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Docker.Api.Data
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DbUserInfoContext : DbContext
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DbUserInfoContext(DbContextOptions&amp;lt;DbUserInfoContext&amp;gt; options) : &lt;span&gt;base&lt;/span&gt;&lt;span&gt;(options) { }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DbSet&amp;lt;UseInfo&amp;gt; userInfos { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 模型创建时触发
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;modelBuilder&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnModelCreating(ModelBuilder modelBuilder)
        {
            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
             修改表名和主键，user对应数据库的表，mysql默认是区分大小写的
             查看：show variables like '%lower%';
            lower_case_table_names 为 0 区分，1 不区分
             &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            modelBuilder.Entity&lt;/span&gt;&amp;lt;UseInfo&amp;gt;(b =&amp;gt; b.ToTable(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).HasKey(u =&amp;gt;&lt;span&gt; u.id));

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;or
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;modelBuilder.Entity&amp;lt;user&amp;gt;()
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    .ToTable(&quot;user&quot;)
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    .HasKey(u =&amp;gt; u.id);&lt;/span&gt;

            &lt;span&gt;base&lt;/span&gt;&lt;span&gt;.OnModelCreating(modelBuilder);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;3：添加UserInfo控制器&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; Docker.Api.Data;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Http;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Mvc;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.EntityFrameworkCore;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Docker.Api.Controllers
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     [Route(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api/[controller]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    [ApiController]
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserInfoController : ControllerBase
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt;&lt;span&gt; DbUserInfoContext _DbUserInfoContext;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; UserInfoController(DbUserInfoContext context)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             _DbUserInfoContext =&lt;span&gt; context;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        [HttpGet]
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;IActionResult&amp;gt;&lt;span&gt; Get()
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; JsonResult(&lt;span&gt;await&lt;/span&gt;&lt;span&gt; _DbUserInfoContext.userInfos.FirstOrDefaultAsync());
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4：配置sql连接字符串： &lt;span class=&quot;cnblogs_code&quot;&gt;server=localhost;port=&lt;span&gt;3306&lt;/span&gt;;userid=test;password=&lt;span&gt;123456&lt;/span&gt;;database=docker&lt;/span&gt; &lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/450977/201905/450977-20190512145602491-1264723701.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;run项目。访问能成功获取信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/450977/201905/450977-20190512145634127-1667332453.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;接下来我们把这个api也打包成镜像，然后连接mysql镜像。这称之为容器互连&lt;/p&gt;
&lt;p&gt;容器互连有3种方式&lt;/p&gt;
&lt;p&gt;1：Link方式。已经被docker淘汰，docker官方不推荐使用该方式&lt;/p&gt;
&lt;p&gt;2：Bridger，桥接的方式，单台机器用&lt;/p&gt;
&lt;p&gt;3：Overlay 适用于集群时候用&lt;/p&gt;

&lt;p&gt;Overlay 就我目前环境不适合测试，集群也不懂。就不搞了&lt;/p&gt;
&lt;p&gt;说说LInk和Bridger方式，具体理论知识请看docker官方文档。我这里只实践&lt;/p&gt;

&lt;p&gt;现在一切来回忆下&lt;/p&gt;
&lt;p&gt;刚上面打包控制台应用程序用的是：microsoft/dotnet 镜像&lt;/p&gt;
&lt;p&gt;然后后面带上tag&lt;/p&gt;
&lt;p&gt;比如：&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;1&quot; cellpadding=&quot;1&quot; align=&quot;left&quot;&gt;&lt;tbody readability=&quot;5.5&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;&lt;span&gt;Micirosoft/dotnet:sdk&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;包含了运行时和sdk命令，打包后会很大，因为包含sdk，&lt;span&gt;一般用于测试环境&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;Microsoft/dotnet:&amp;lt;version&amp;gt;-runtime&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;包含运行时，不包含sdk，打包后就很小了，一般用于正式环境&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8&quot;&gt;&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;Microsoft/dotnet:&amp;lt;version&amp;gt;-runtime-deps&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;打包的时候，会自包含runtime，也就是部署的机器有没有runtime是没有关系&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上面2种，必须机器要包含core环境&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;修改程序port运行在80上&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/450977/201905/450977-20190512151922004-1990179842.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;编写api的Dockerfile&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我这里用的sdk，因为要用到sdk命令比如&lt;span&gt;dotnet restore，dotnet publish&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;如果已经&lt;span&gt;&lt;span&gt;publish&lt;/span&gt;&lt;/span&gt;的文件，直接用&lt;span&gt;runtime&lt;/span&gt;会方便很多。上面也有提及&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; #FROM mcr.microsoft.com/dotnet/core/sdk:&lt;span&gt;2.2&lt;/span&gt;&lt;span&gt; AS build
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; FROM microsoft/dotnet:&lt;span&gt;2.2&lt;/span&gt;-&lt;span&gt;sdk AS build
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; WORKDIR /&lt;span&gt;src
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; WORKDIR /&lt;span&gt;source
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; #这里的后面的 . 就是/&lt;span&gt;source 路径
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; #或者 COPY *.csproj /&lt;span&gt;source
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; COPY *&lt;span&gt;.csproj .
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;RUN dotnet restore
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;COPY . .
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; # 发布到 /source/&lt;span&gt;out&lt;/span&gt;&lt;span&gt; 下
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; RUN dotnet publish -c Release -o &lt;span&gt;out&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; #FROM mcr.microsoft.com/dotnet/core/runtime:&lt;span&gt;2.2&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; FROM microsoft/dotnet:&lt;span&gt;2.2&lt;/span&gt;-aspnetcore-&lt;span&gt;runtime
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; WORKDIR /&lt;span&gt;app
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; COPY --&lt;span&gt;from&lt;/span&gt;=build /source/&lt;span&gt;out&lt;/span&gt;&lt;span&gt; .
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; EXPOSE &lt;span&gt;80&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; ENTRYPOINT [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dotnet&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Docker.Api.dll&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;开始build项目 &lt;span class=&quot;cnblogs_code&quot;&gt;docker build -t cn/myapi .&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/450977/201905/450977-20190512151546403-1841969914.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;可以看到。这里没有指定tag。所以默认是latest，size也不大&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/450977/201905/450977-20190512151723835-556661079.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 成功后开始run一个容器，不过这之前要先：&lt;/p&gt;
&lt;p&gt;准备挂载目录。因为配置文件 appsettings 会需要动态配置，所以挂载出来&lt;/p&gt;
&lt;p&gt;还有，比如一个网站都有log日志，这些也需要挂载出来。便于管理。&lt;/p&gt;
&lt;p&gt;我这里就只挂载appsettings.json&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/450977/201905/450977-20190512151412229-893148985.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 执行命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
docker run -d -p &lt;span&gt;80&lt;/span&gt;:&lt;span&gt;80&lt;/span&gt; --restart always --link mysql:mysqldb -v /d/docker/myapi/appsettings.json:/app/appsettings.json --name api cn/myapi
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 分析：&lt;/p&gt;
&lt;p&gt;--restart always :总是重启&lt;/p&gt;
&lt;p&gt;-d：是在后台执行&lt;/p&gt;
&lt;p&gt;-p 80:80 ：第一个80是暴露给外部的。第二个80是程序的。&lt;/p&gt;
&lt;p&gt;--link mysql:mysqldb : mysql是容器名称，mysqldb是自定义名称，可以理解为服务器&lt;/p&gt;
&lt;p&gt;-v /d/docker/myapi/appsettings.json:/app/appsettings.json：这里就是挂载外部的数据卷了&lt;/p&gt;
&lt;p&gt;也许你会问。我怎么知道这个路径的：/app/appsettings.json。从编写的dockerfile能分析出来，待会也可以进入容器看看&lt;/p&gt;
&lt;p&gt;最有的工作目录是 根路径下： /app&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/450977/201905/450977-20190512153351597-703961452.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;然后通过页面访问试试&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/450977/201905/450977-20190512153433262-1841858062.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt; 发现依然无法访问，因为修改appsettings.json的连接方式&lt;/p&gt;
&lt;p&gt;记住这里是修改D:\docker\myapi\appsettings.json ,因为已经挂载出来&lt;/p&gt;
&lt;p&gt;把server改成mysqldb，然后重启容器： &lt;span class=&quot;cnblogs_code&quot;&gt;docker restart api&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/450977/201905/450977-20190512153614336-478616915.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;再次刷新页面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/450977/201905/450977-20190512153810847-1664127283.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 我们 进入容器看看： &lt;span class=&quot;cnblogs_code&quot;&gt;docker exec -it api bash&lt;/span&gt; 可以看到根目录下存在app目录&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/450977/201905/450977-20190512154020843-993503645.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;进入app目录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/450977/201905/450977-20190512154111567-106241272.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;个人认为link方式是最简单的。在这3种中，接下来看看Bridge方式&lt;/p&gt;
&lt;p&gt;1：首先创建一个网络 network，名称叫api2bridge&lt;/p&gt;
&lt;p&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;docker network create -d bridge api2bridge&lt;/span&gt; &lt;/p&gt;

&lt;p&gt;通过： &lt;span class=&quot;cnblogs_code&quot;&gt;docker network ls&lt;/span&gt; 可以查看到已经创建成功&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/450977/201905/450977-20190512162228797-2109479418.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2：实例化容器&lt;/p&gt;
&lt;p&gt;为了区别于上面的80端口，这里新增一个8081&lt;/p&gt;
&lt;p&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;docker run -d -p 8081:80 --restart always  -v /d/docker/myapi/appsettings.json:/app/appsettings.json --net api2bridge --name api2 cn/myapi&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 创建容器的时候，自定network 这里的--net api2bridge 就是上面的bridge&lt;/p&gt;

&lt;p&gt;3：连接2个容器，通过： &lt;span class=&quot;cnblogs_code&quot;&gt;docker network connect api2bridge mysql&lt;/span&gt;  把api2和mysql连接起来&lt;/p&gt;

&lt;p&gt; 4：修改appsettings.json  &lt;span class=&quot;cnblogs_code&quot;&gt;server=mysql&lt;/span&gt; &lt;/p&gt;

&lt;p&gt; 5 : restart 容器，如果是在创建容器前修改的配置文件。是不需要重启的，测试通过&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/450977/201905/450977-20190512162626792-2050531538.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 看看这两个容器是怎么连接的。通过命令：  &lt;span class=&quot;cnblogs_code&quot;&gt;docker inspect api2bridge&lt;/span&gt; 可以查看对象的元数据（容器或者网络）&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/450977/201905/450977-20190512163819641-564189728.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 分别看看；&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cnblogs_code&quot;&gt;docker inspect api2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/450977/201905/450977-20190512164128040-610964870.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/450977/201905/450977-20190512164157835-849794062.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;cnblogs_code&quot;&gt;docker inspect mysql&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/450977/201905/450977-20190512164002309-1079841901.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/450977/201905/450977-20190512164044353-1852955129.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 你会发现mysql有个&quot;IPAddress&quot;:地址，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/450977/201905/450977-20190512164708468-393516855.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 上面我们在api2中的appsettings.json的server是直接些的容器名称：mysql。也可以直接些这个ip地址。比如： &lt;span class=&quot;cnblogs_code&quot;&gt;server=&lt;span&gt;172.20&lt;/span&gt;.&lt;span&gt;0.3&lt;/span&gt;&lt;/span&gt; 同样是可以的。&lt;/p&gt;
&lt;p&gt; Overlay方式就不讲了。因为我也不知道。哈哈&lt;/p&gt;


&lt;p&gt;通过这几个例子你会发现。2个容器要部署2个，如果项目依赖mysql，redis，MQ等等。那得部署多次，如此重复性的工作会影响效率&lt;/p&gt;
&lt;p&gt;所以有了docker-compose，compose&lt;/p&gt;
&lt;p&gt;参考：&lt;a href=&quot;https://yeasy.gitbooks.io/docker_practice/content/compose/install.html&quot; target=&quot;_blank&quot;&gt;https://yeasy.gitbooks.io/docker_practice/content/compose/install.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安装：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
sudo curl -L https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;github.com/docker/compose/releases/download/1.17.1/docker-compose-`uname -s`-`uname -m` &amp;gt; /usr/local/bin/docker-compose&lt;/span&gt;
sudo chmod +x /usr/local/bin/docker-compose
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;安装完成后，可以通过： &lt;span class=&quot;cnblogs_code&quot;&gt;docker-compose --version&lt;/span&gt; 查看版本&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/450977/201905/450977-20190512165506094-136631578.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 通过： &lt;span class=&quot;cnblogs_code&quot;&gt;docker-compose --help&lt;/span&gt; 查看基本的命令&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/450977/201905/450977-20190512165633842-2121844996.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 不过我英文不好，就通过百度翻译了，翻译得有点生硬。仅供参考&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Commands:
  build              建立或重建服务
  bundle             从撰写文件生成Docker捆绑包
  config             验证并查看撰写文件
  create             创建服务
  down               停止并删除容器、网络、图像和卷
  events             从容器接收实时事件
  exec               在正在运行的容器中执行命令
  help               获取有关命令的帮助
  images             列表图像
  kill               杀死容器
  logs               查看容器的输出
  pause              暂停服务
  port               打印端口绑定的公共端口
  ps                 列表容器
  pull               拉取服务图像
  push               推送服务图像
  restart            重新启动服务
  rm                 移除停止的容器
  run                运行一次性命令
  scale              设置服务的容器数
  start              启动服务
  stop               停止服务
  top                显示正在运行的进程
  unpause            取消暂停服务
  up                 创建和启动容器
  version            显示Docker撰写版本信息&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;目前为止已经有3个容器了，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/450977/201905/450977-20190512170932847-773882134.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;为了区别于之前的mysql和api和api2，这里命名要修改，编写在程序根目录下添加docker-compose.yml文件&lt;/p&gt;
&lt;p&gt;compose用的是yml语法。可以参考阮一峰些的文章&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2016/07/yaml.html&quot; target=&quot;_blank&quot;&gt;http://www.ruanyifeng.com/blog/2016/07/yaml.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;项目准备。依然在上面的api项目中添砖加瓦&lt;/p&gt;
&lt;p&gt;还记得上面初始化的创建docker库，user表吗。这里我们通过在代码中来实现，&lt;/p&gt;
&lt;p&gt;场景：创建myslq的时候，判断数据库是否有数据，否则新增一条数据&lt;/p&gt;
&lt;p&gt;技术栈：项目依赖mysql，redis，其实我工作中用的都是mssql，所以待会也会介绍&lt;/p&gt;
&lt;p&gt; 1：init.sql 只保留一条sql语句&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/450977/201905/450977-20190512171908937-84323489.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 2：新增UserInit类。用于初始化数据&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Builder;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.EntityFrameworkCore;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.DependencyInjection;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.Logging;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Docker.Api.Data
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserInit
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; ILogger&amp;lt;UserInit&amp;gt;&lt;span&gt; _logger;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; UserInit(ILogger&amp;lt;UserInit&amp;gt;&lt;span&gt; logger)
        {
            _logger &lt;/span&gt;=&lt;span&gt; logger;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task InitData(IApplicationBuilder app, ILoggerFactory loggerFactory)
        {

            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; scope =&lt;span&gt; app.ApplicationServices.CreateScope())
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; context = scope.ServiceProvider.GetService&amp;lt;DbUserInfoContext&amp;gt;&lt;span&gt;();
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; logger = scope.ServiceProvider.GetService&amp;lt;ILogger&amp;lt;UserInit&amp;gt;&amp;gt;&lt;span&gt;();
                logger.LogDebug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;begin mysql init&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                context.Database.Migrate();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (context.userInfos.Count() &amp;lt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                {
                    context.userInfos.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Model.UseInfo
                    {
                        name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;admin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                        address &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;博客园&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                    });
                    context.SaveChanges();
                }
            }
            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; Task.CompletedTask;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;程序启动调用：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/450977/201905/450977-20190512180930277-1071366101.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;3：实体类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Docker.Api.Model
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UseInfo
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; id { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; address { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;4：DbContext 上面也列出，这里就不展示了&lt;/p&gt;
&lt;p&gt;5：RedisHelper网络有。这里也不提了&lt;/p&gt;
&lt;p&gt;只准备2个接口。用于测试redis。一个读，一个写&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Http;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Mvc;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Docker.Api.Controllers
{
    [Route(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api/[controller]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    [ApiController]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RedisController : ControllerBase
    {
        [HttpPost]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Post()
        {
            RedisCommon.GetRedis().StringSet(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;docker&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, TimeSpan.FromMinutes(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;));
        }
        [HttpGet]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; Get()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; docker = RedisCommon.GetRedis().GetStringKey(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;docker&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (docker.HasValue) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; docker.ToString();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;empty&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;6：根据Model生成Migration，这里简单过一下，具体参考我之前的：&lt;a href=&quot;https://www.cnblogs.com/nsky/p/10323415.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/nsky/p/10323415.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;调出程序包管理控制台&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/450977/201905/450977-20190512172636268-1576270775.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 输入： &lt;span class=&quot;cnblogs_code&quot;&gt;Add-Migration init&lt;/span&gt; &lt;/p&gt;

&lt;p&gt; 如果成功了就会这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/450977/201905/450977-20190512172824313-840008965.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 编写docker-compose.yml 文件，我这里的注释是便于理解。尽量不要写&lt;/p&gt;
&lt;p&gt;注：我是直接在项目中创建的文本文件，然后修改后缀名&lt;/p&gt;
&lt;p&gt;在网络上看到说。如果是在外部创建的记事本。要修改编码为：ASCII编码格式，我未测试&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
version: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

services:
  db:
    image: mysql
    container_name: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;mysql01&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    command: &lt;/span&gt;--character-&lt;span&gt;set&lt;/span&gt;-server=utf8 --collation-server=&lt;span&gt;utf8_general_ci
    restart: always
    ports:
      &lt;/span&gt;- &lt;span&gt;'&lt;/span&gt;&lt;span&gt;3307:3306&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    environment:
      MYSQL_USER: test
      MYSQL_PASSWORD: &lt;/span&gt;&lt;span&gt;123456&lt;/span&gt;&lt;span&gt;
      MYSQL_PASSWORD_HOST: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
      MYSQL_ROOT_PASSWORD: &lt;/span&gt;&lt;span&gt;123456&lt;/span&gt;&lt;span&gt;
      MYSQL_ROOT_HOST: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    volumes:
      &lt;/span&gt;- /d/docker/mysql02/my.cnf:/etc/&lt;span&gt;my.cnf
      &lt;/span&gt;- /d/docker/mysql02/data:/&lt;span&gt;var&lt;/span&gt;/lib/&lt;span&gt;mysql
      &lt;/span&gt;- /d/docker/mysql02/SqlInit:/docker-entrypoint-&lt;span&gt;initdb.d
  redis:
    image: redis
    container_name: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;redis&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    command: redis&lt;/span&gt;-server /usr/local/etc/redis/&lt;span&gt;redis.conf 
    restart: always
    ports:
      &lt;/span&gt;- &lt;span&gt;'&lt;/span&gt;&lt;span&gt;6379:6379&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    environment:
      requirepass: &lt;/span&gt;&lt;span&gt;123456&lt;/span&gt;&lt;span&gt; #redis密码
      appendonly: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;yes&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; #redis是否持久化
    volumes:
      &lt;/span&gt;- /d/docker/redis/conf/redis.conf:/usr/local/etc/redis/&lt;span&gt;redis.conf
      &lt;/span&gt;- /d/docker/redis/data:/&lt;span&gt;data #这里会保存持久化数据
  web:
    build: . #会执行当前目录下面的dockerfile文件
    container_name: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;api3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; #容器名称
    restart: always # web依赖于db，如果web比db启动快。就连接不上db导致web异常，web容器启动失败，restart可以不断重试，直到连接为止
    volumes:
      &lt;/span&gt;- /d/docker/myapi/appsettings.json:/app/&lt;span&gt;appsettings.json
    ports:
      &lt;/span&gt;- &lt;span&gt;'&lt;/span&gt;&lt;span&gt;8082:80&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    depends_on: #依赖db容器，并不代表执行顺序
      &lt;/span&gt;-&lt;span&gt; db
      &lt;/span&gt;- redis
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果想看编写的yml文件是否正确，可以去在线的网站，验证是否正确，比如：&lt;a href=&quot;http://nodeca.github.io/js-yaml/&quot; target=&quot;_blank&quot;&gt;http://nodeca.github.io/js-yaml/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; 切换到当前目录输入：  &lt;span class=&quot;cnblogs_code&quot;&gt;docker-compose build&lt;/span&gt; 会开始build项目成镜像&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/450977/201905/450977-20190512180217538-39599421.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 查看镜像：名字叫dockerapi_web&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/450977/201905/450977-20190512180237733-94081712.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 输入命令： &lt;span class=&quot;cnblogs_code&quot;&gt;docker-compose up&lt;/span&gt; 会开始创建容器并启动&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/450977/201905/450977-20190512181205261-1345466184.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输出的日志太多。这里只点几个有用的看&lt;/p&gt;
&lt;p&gt;EFcore插入Migration历史记录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/450977/201905/450977-20190512181333448-1228987163.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 创建表:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/450977/201905/450977-20190512181414651-2035360465.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 直到最后，程序阻塞。显示成功，因为这里没用用 -d 会阻塞，调试的时候不建议 -d&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/450977/201905/450977-20190512181441094-1606436449.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 然后新打开一个PowerShell，输入docker ps 查看运行的容器&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/450977/201905/450977-20190512181618586-1749949748.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 分别测试是否成功&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/450977/201905/450977-20190512181644889-651369845.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/450977/201905/450977-20190512181729483-1770508844.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 同样验证redis，用RedisDesktopManager连接&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/450977/201905/450977-20190512181836696-2077483231.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;从容器可以看出api3端口是8082，尝试访问下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/450977/201905/450977-20190512193753174-1748682612.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 测试写redis，打开Postman写入Redis&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/450977/201905/450977-20190512194023787-1667645806.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 写人成功&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/450977/201905/450977-20190512194052722-1841174563.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;那么读取就不是什么大问题了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/450977/201905/450977-20190512194209736-1873004860.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;




&lt;p&gt;问题汇总：&lt;/p&gt;
&lt;p&gt;如果你修改了代码，需要重新build。那么先删除容器： &lt;span class=&quot;cnblogs_code&quot;&gt;docker-compose down&lt;/span&gt; 会停止容器并删除&lt;/p&gt;
&lt;p&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;docker-compose ps&lt;/span&gt;  查看容器列表&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/450977/201905/450977-20190512194718914-901753391.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;   &lt;span class=&quot;cnblogs_code&quot;&gt;docker-compose up -d&lt;/span&gt;   后端运行，不阻塞前端&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/450977/201905/450977-20190512194916555-1337559736.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;  &lt;span class=&quot;cnblogs_code&quot;&gt;docker-compose restart&lt;/span&gt;  重启所有容器。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/450977/201905/450977-20190512194957140-1215996647.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 自此所有容器成功运行，但我感觉还不够，因为一直都是在windos上玩。而没有上CentOS7,可我又不缺CentOS环境。所以要玩一把&lt;/p&gt;

&lt;p&gt;技术栈：Jexus，mysql，mssql，redis&lt;/p&gt;
&lt;p&gt;关于jexus部署net core 可以参考我前面写的文章：https://www.cnblogs.com/nsky/p/10386460.html&lt;/p&gt;
&lt;p&gt;既然要加入新的成员。jexus 和 mssql，那么就得修改docker-compose文件&lt;/p&gt;
&lt;p&gt; 在通过docker-compose统一打包前，我们先来单独玩玩mssql&lt;/p&gt;
&lt;p&gt;准备数据卷挂载目录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/450977/201905/450977-20190512210142562-556476245.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; data：保存数据库文件&lt;/p&gt;
&lt;p&gt;sql：执行的脚本。mssql没有mysql的docker-entrypoint-initdb.d 挂载，启动mysql就执行sql。这里sql文件夹&lt;/p&gt;
&lt;p&gt;虽然保存的是.sql文件。但要手动执行，不知道是不是我没有找到具体的方案&lt;/p&gt;
&lt;p&gt;sql里面放一个init.sql文件。编写sql脚本如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/450977/201905/450977-20190512210401159-39129282.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 这里要注意一点，一条语句完成必须要带一个Go语句&lt;/p&gt;
&lt;p&gt;参考官方文档：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/zh-cn/sql/linux/quickstart-install-connect-docker?view=sql-server-2017&amp;amp;pivots=cs1-bash&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/zh-cn/sql/linux/quickstart-install-connect-docker?view=sql-server-2017&amp;amp;pivots=cs1-bash&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/zh-cn/sql/linux/tutorial-restore-backup-in-sql-server-container?view=sql-server-2017&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/zh-cn/sql/linux/tutorial-restore-backup-in-sql-server-container?view=sql-server-2017&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;镜像文档：&lt;a href=&quot;https://hub.docker.com/_/microsoft-mssql-server&quot; target=&quot;_blank&quot;&gt;https://hub.docker.com/_/microsoft-mssql-server&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注释部分&lt;/span&gt;
docker run -d -p &lt;span&gt;1433&lt;/span&gt;:&lt;span&gt;1433&lt;/span&gt;&lt;span&gt; \
&lt;/span&gt;-e ACCEPT_EULA=&lt;span&gt;Y \ #确认您接受最终用户许可协议。
&lt;/span&gt;-e SA_PASSWORD=DockerPwd123 \ #强大的系统管理员（SA）密码：至少8个字符，包括大写，小写字母，基数为10的数字和/&lt;span&gt;或非字母数字符号。
&lt;/span&gt;-e MSSQL_PID=&lt;span&gt;Express \ #版本（Developer，Express，Enterprise，EnterpriseCore）默认值：Developer  
&lt;/span&gt;-v /docker/mssql:/&lt;span&gt;var&lt;/span&gt;/opt/&lt;span&gt;mssql \  # 映射数据库
v &lt;/span&gt;/d/docker/mssql/sql:/&lt;span&gt;script #把需要执行的脚本放这里，script路径随便改，不是初始化执行，是手到执行
&lt;/span&gt;--&lt;span&gt;name mssql #容器名称
mcr.microsoft.com&lt;/span&gt;/mssql/server #镜像
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;执行成功后。数据卷挂载目录。生成了文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/450977/201905/450977-20190512211643578-1912771221.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;此时data也有默认的数据库了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/450977/201905/450977-20190512211724514-1227581883.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 通过 MSSMS(  Microsoft SQL Server Management Studio )连接试试&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/450977/201905/450977-20190512211904328-2109656846.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 刚上面说了sql中文件是没有被执行的。必须手动执行。&lt;/p&gt;
&lt;p&gt;手动执行前，先来看看其他一些相关命令&lt;/p&gt;
&lt;p&gt;进入容器后： &lt;span class=&quot;cnblogs_code&quot;&gt;docker exec -it mssql bash&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;登陆数据库：localhost也可以用指定的ip代替，如果有端口。则带端口号即可&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
/opt/mssql-tools/bin/sqlcmd -S localhost -U SA -&lt;span&gt;P DockerPwd123

&lt;/span&gt;-&lt;span&gt;S 是服务器，不管端口是多少，都不用写
&lt;/span&gt;-&lt;span&gt;U 是用户名 
&lt;/span&gt;-P 是密码
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果出现 1&amp;gt; 说明的登陆成功了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/450977/201905/450977-20190512213100402-548984407.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;可以输入语句：select getdate() 试试，回车后，需要加Go语句，不过日期怎么不对？好像是相差8个时区&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/450977/201905/450977-20190512213231655-635514408.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 执行sql中的文件&lt;/p&gt;
&lt;p&gt;登陆容器后执行操作： &lt;span class=&quot;cnblogs_code&quot;&gt;/opt/mssql-tools/bin/sqlcmd -S localhost -U SA -P DockerPwd123 -i /script/init.sql&lt;/span&gt; &lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/450977/201905/450977-20190512221321221-1103511674.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;挂载目录也有，这样就算容器无法进入。数据库也存在&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/450977/201905/450977-20190512221342717-1187640627.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;由于时间问题，docker-compose 就不加入mssql，只加jexus，修改docker-compose如下&lt;/p&gt;
&lt;p&gt;阿里云安装docker-compose 特别慢，今天就不写。后期在加上&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/450977/201905/450977-20190512223917366-118004364.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;关键时刻掉链子，写了这么多。其实也就一点皮毛而已，docker强大之处远远不止这些&lt;/p&gt;
&lt;p&gt;未完待续&lt;/p&gt;



&lt;p&gt;上传镜像到hub.docker&lt;/p&gt;

&lt;p&gt;源码：&lt;a href=&quot;https://github.com/byniqing/docker-compose&quot; target=&quot;_blank&quot;&gt;https://github.com/byniqing/docker-compose&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 12 May 2019 14:43:00 +0000</pubDate>
<dc:creator>糯米粥</dc:creator>
<og:description>由浅入深，Docker从入门到动手实践</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nsky/p/10853194.html</dc:identifier>
</item>
<item>
<title>D3.js 区域生成器 (V3版本) - 溢杨年华</title>
<link>http://www.cnblogs.com/littleSpill/p/10854021.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/littleSpill/p/10854021.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;区域生成器(Area Generator)&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;区域生成器(Area Generator)&lt;/strong&gt;用于生成一块区域，使用方法与线段生成器类似。线段生成器地址:数据访问器有x()、x0()、x1()、y()、y0()、y1()六个，数量很多，但不许要全部使用。举个例子:&lt;/span&gt;&lt;/p&gt;

&lt;div readability=&quot;14.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt;  　　　　&lt;span&gt;var&lt;/span&gt; width = 600;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;SVG绘制区域的宽度&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; height = 500;           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;SVG绘制区域的高度&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;        
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义画图区域svg&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; svg = d3.select(&quot;#body&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                     .append(&quot;svg&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                     .attr(&quot;width&quot;&lt;span&gt;,width)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                     .attr(&quot;height&quot;&lt;span&gt;,height)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义数据&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; dataList = [80,120,130,70,60,90&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个区域生成器&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; areaPath =&lt;span&gt; d3.svg.area()
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                         .x(&lt;span&gt;function&lt;/span&gt;(d,i){&lt;span&gt;return&lt;/span&gt; 50 + i * 80&lt;span&gt;})
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                         .y0(&lt;span&gt;function&lt;/span&gt;(d,i){&lt;span&gt;return&lt;/span&gt; height/2})
&lt;span&gt;16&lt;/span&gt;                         .y1(&lt;span&gt;function&lt;/span&gt;(d,i){&lt;span&gt;return&lt;/span&gt; height/2 - d})
&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;       
&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加路径&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;         svg.append(&quot;path&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             .attr(&quot;d&quot;,areaPath(dataList))       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用了区域生成器&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;             .attr(&quot;stroke&quot;,&quot;black&quot;)             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;线段的颜色&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;             .attr(&quot;stroke-width&quot;,&quot;3px&quot;)         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;线段的宽度&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;             .attr(&quot;fill&quot;,&quot;yellow&quot;)              &lt;span&gt;//&lt;/span&gt;&lt;span&gt;填充的颜色&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;div readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span&gt;上面代码定义了一个数组dataList和一个区域生成器areaPath。此区域生成器定制了三个访问器:&lt;strong&gt;x()&lt;/strong&gt;、&lt;strong&gt;y0()&lt;/strong&gt;、&lt;strong&gt;y1()&lt;/strong&gt;。将areaPath当中函数使用，&lt;strong&gt;areaPath(dataList)&lt;/strong&gt;返回的字符串直接作为&amp;lt;path&amp;gt;元素的d的值使用。结果如图: &lt;/span&gt;&lt;/p&gt;

&lt;div&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1557620/201905/1557620-20190512221346788-1270279576.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/div&gt;

&lt;div readability=&quot;11.5&quot;&gt;
&lt;div readability=&quot;18&quot;&gt;
&lt;p&gt;&lt;span&gt;上图中，上边界的折现是数组dataList中各值得反映。根据访问器的设定，可得到以下数值(height的值是500)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当d = 80,i = 0 时，x等于50, y0等于250, y1等于170。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当d = 120,i = 1 时，x等于50 + 1 * 80, y0等于250, y1等于130。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以此类推。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div readability=&quot;13.5&quot;&gt;
&lt;p&gt;&lt;span&gt;下图展示了各访问器的意义，x是各段的x坐标，y0是区域的下限坐标，y1是区域的上限坐标。如果不定制访问器，默认是:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;x为d[0]，y0为0，y1为d[1]。此外还有&lt;strong&gt;x0()&lt;/strong&gt;、&lt;strong&gt;x1()&lt;/strong&gt;、&lt;strong&gt;y()&lt;/strong&gt;三个访问器，意义类似，如果需要制作上图的横向图需要用到。&lt;/span&gt;&lt;/p&gt;

&lt;div&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1557620/201905/1557620-20190512221520589-1866430916.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/div&gt;


&lt;div readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span&gt;与线段生成器类似，区域生成器也有&lt;strong&gt;interpolate()&lt;/strong&gt;、&lt;strong&gt;tension()&lt;/strong&gt;、&lt;strong&gt;defined()&lt;/strong&gt;这些方法，意义相同。通过设定&lt;strong&gt;interpolate&lt;/strong&gt;，&lt;/span&gt;&lt;span&gt;两点之间的插值会发生相应变化，规则与线段生成器一样。但是，某些模式是区域生成器里没有的，如&lt;strong&gt;linear-closed&lt;/strong&gt;。因为区域本身&lt;/span&gt;&lt;span&gt;就是闭合的，所以不需要了。接下来给大家展示一下&lt;strong&gt;step&lt;/strong&gt;和&lt;strong&gt;basis&lt;/strong&gt;两种插值模式:&lt;/span&gt;&lt;/p&gt;

&lt;div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;step插值模式 :&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div readability=&quot;14.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; 　　　　 &lt;span&gt;var&lt;/span&gt; width = 600;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;SVG绘制区域的宽度&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; height = 500;           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;SVG绘制区域的高度&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;        
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义画图区域svg&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; svg = d3.select(&quot;#body&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                     .append(&quot;svg&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                     .attr(&quot;width&quot;&lt;span&gt;,width)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                     .attr(&quot;height&quot;&lt;span&gt;,height)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义数据&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; dataList = [80,120,130,70,60,90&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;       
&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;step插值模式&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; areaPath =&lt;span&gt; d3.svg.area()
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                         .interpolate(&quot;step&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                         .x(&lt;span&gt;function&lt;/span&gt;(d,i){&lt;span&gt;return&lt;/span&gt; 50 + i * 80&lt;span&gt;})
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                         .y0(&lt;span&gt;function&lt;/span&gt;(d,i){&lt;span&gt;return&lt;/span&gt; height/2})
&lt;span&gt;18&lt;/span&gt;                         .y1(&lt;span&gt;function&lt;/span&gt;(d,i){&lt;span&gt;return&lt;/span&gt; height/2-d})
&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加路径&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;         svg.append(&quot;path&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             .attr(&quot;d&quot;,areaPath(dataList))       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用了区域生成器&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;             .attr(&quot;stroke&quot;,&quot;black&quot;)             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;线段的颜色&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;             .attr(&quot;stroke-width&quot;,&quot;3px&quot;)         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;线段的宽度&lt;/span&gt;&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;             .attr(&quot;fill&quot;,&quot;yellow&quot;)              &lt;span&gt;//&lt;/span&gt;&lt;span&gt;填充的颜色&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;&lt;span&gt;效果图 :&lt;/span&gt;&lt;/p&gt;

&lt;div&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1557620/201905/1557620-20190512221803396-1723626734.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/div&gt;


&lt;div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;basis插值模式 :&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div readability=&quot;14.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt;   　　　 &lt;span&gt;var&lt;/span&gt; width = 600;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;SVG绘制区域的宽度&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; height = 500;           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;SVG绘制区域的高度&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;        
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义画图区域svg&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; svg = d3.select(&quot;#body&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                     .append(&quot;svg&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                     .attr(&quot;width&quot;&lt;span&gt;,width)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                     .attr(&quot;height&quot;&lt;span&gt;,height)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义数据&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; dataList = [80,120,130,70,60,90&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;       
&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;basis插值模式&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; areaPath =&lt;span&gt; d3.svg.area()
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                         .interpolate(&quot;basis&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                         .x(&lt;span&gt;function&lt;/span&gt;(d,i){&lt;span&gt;return&lt;/span&gt; 50 + i * 80&lt;span&gt;})
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                         .y0(&lt;span&gt;function&lt;/span&gt;(d,i){&lt;span&gt;return&lt;/span&gt; height/2})
&lt;span&gt;18&lt;/span&gt;                         .y1(&lt;span&gt;function&lt;/span&gt;(d,i){&lt;span&gt;return&lt;/span&gt; height/2 - d})
&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加路径&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;         svg.append(&quot;path&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             .attr(&quot;d&quot;,areaPath(dataList))       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用了区域生成器&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;             .attr(&quot;stroke&quot;,&quot;black&quot;)             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;线段的颜色&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;             .attr(&quot;stroke-width&quot;,&quot;3px&quot;)         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;线段的宽度&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;             .attr(&quot;fill&quot;,&quot;yellow&quot;)              &lt;span&gt;//&lt;/span&gt;&lt;span&gt;填充的颜色&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;&lt;span&gt;效果图 :&lt;/span&gt;&lt;/p&gt;

&lt;div&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1557620/201905/1557620-20190512221929039-592081601.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/div&gt;

&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;在需要生成折现或曲线下方的面积的时候，可以考虑使用区域生成器。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;


</description>
<pubDate>Sun, 12 May 2019 14:20:00 +0000</pubDate>
<dc:creator>溢杨年华</dc:creator>
<og:description>区域生成器(Area Generator) 区域生成器(Area Generator)用于生成一块区域，使用方法与线段生成器类似。线段生成器地址:数据访问器有x()、x0()、x1()、y()、y0(</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/littleSpill/p/10854021.html</dc:identifier>
</item>
<item>
<title>MySQL 联表查询 - 刘哇勇</title>
<link>http://www.cnblogs.com/Wayou/p/mysql_join.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Wayou/p/mysql_join.html</guid>
<description>&lt;p&gt;关系型数据库，免不了表之间存在各种引用与关联。这些关联是通过主键与外键搭配来形成的。所以，取数据时，很大情况下单张表无法满足需求，额外的数据则需要将其他表加入到查询中来，这便是 &lt;code&gt;JOIN&lt;/code&gt; 关键字完成的操作。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;MySQL 中 &lt;code&gt;JOIN&lt;/code&gt;, &lt;code&gt;CROSS JOIN&lt;/code&gt; 和 &lt;code&gt;INNER JOIN&lt;/code&gt; 三者语法功能上相同，可互换，而 SQL 标准中，&lt;code&gt;INNER JOIN&lt;/code&gt; 需要搭配 &lt;code&gt;ON&lt;/code&gt; 语句。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;多表联合查询时，可省略 JOIN 关键字，以逗号分隔多张表，此时默认会当作 INNER JOIN 来处理。比如,&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;SELECT&lt;/span&gt; table1.&lt;span class=&quot;pl-k&quot;&gt;*&lt;/span&gt;, 
       table2.&lt;span class=&quot;pl-k&quot;&gt;*&lt;/span&gt; 
&lt;span class=&quot;pl-k&quot;&gt;FROM&lt;/span&gt;   table1, 
       table2; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;等效于：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;SELECT&lt;/span&gt; table1.&lt;span class=&quot;pl-k&quot;&gt;*&lt;/span&gt;, 
       table2.&lt;span class=&quot;pl-k&quot;&gt;*&lt;/span&gt; 
&lt;span class=&quot;pl-k&quot;&gt;FROM&lt;/span&gt;   table1 
       &lt;span class=&quot;pl-k&quot;&gt;INNER JOIN&lt;/span&gt; table2; 
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;但这种通过逗号隐式指定的联表形式其优先级要低于直接通过关键字（&lt;code&gt;INNER JOIN&lt;/code&gt;, &lt;code&gt;CROSS JOIN&lt;/code&gt;, &lt;code&gt;LEFT JOIN&lt;/code&gt;）指定的形式。所以 &lt;code&gt;t1, t2 JOIN t3&lt;/code&gt; 会被解析成 &lt;code&gt;(t1, (t2 JOIN t3))&lt;/code&gt; 而不是 &lt;code&gt;((t1, t2) JOIN t3)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;需要注意的是，当逗号形式与其他联表关键词结合时，在指定了联表条件，比如通过 &lt;code&gt;ON&lt;/code&gt; 条件时，会报错。&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;code&gt;ON&lt;/code&gt; 指定的联表条件其语法同 &lt;code&gt;WHERE&lt;/code&gt;，所有后者可接受的表达式都可用于 &lt;code&gt;ON&lt;/code&gt;。两者看起来功能上雷同，&lt;code&gt;ON&lt;/code&gt; 一般用于指定联表条件，即表之间怎么被联合，而 &lt;code&gt;WHERE&lt;/code&gt; 则用于过滤结果。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;LEFT JOIN&lt;/code&gt; 时，右边表中不满足 &lt;code&gt;ON&lt;/code&gt; 或 &lt;code&gt;USING&lt;/code&gt; 指定的条件时，会在结果中以 &lt;code&gt;NULL&lt;/code&gt; 呈现。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;SELECT&lt;/span&gt; left_tbl.&lt;span class=&quot;pl-k&quot;&gt;*&lt;/span&gt;
  &lt;span class=&quot;pl-k&quot;&gt;FROM&lt;/span&gt; left_tbl &lt;span class=&quot;pl-k&quot;&gt;LEFT JOIN&lt;/span&gt; right_tbl &lt;span class=&quot;pl-k&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;left_tbl&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;right_tbl&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;id&lt;/span&gt;
  &lt;span class=&quot;pl-k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;right_tbl&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;id&lt;/span&gt; IS &lt;span class=&quot;pl-k&quot;&gt;NULL&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过此方法可方便地过滤出右边表中不符合条件的记录。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;联表查询时可为每张参与进来的表指定别名，方便在其他表达式中引用。两种方式，一个是通过 &lt;code&gt;AS&lt;/code&gt; 关键字 &lt;code&gt;tbl_name AS alias_name&lt;/code&gt;，另一种是直接在表名后面跟上别名，&lt;code&gt;tbl_name alias_name&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;t1&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;name&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;t2&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;salary&lt;/span&gt;
  &lt;span class=&quot;pl-k&quot;&gt;FROM&lt;/span&gt; employee &lt;span class=&quot;pl-k&quot;&gt;AS&lt;/span&gt; t1 &lt;span class=&quot;pl-k&quot;&gt;INNER JOIN&lt;/span&gt; info &lt;span class=&quot;pl-k&quot;&gt;AS&lt;/span&gt; t2 &lt;span class=&quot;pl-k&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;t1&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;t2&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;name&lt;/span&gt;;

&lt;span class=&quot;pl-k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;t1&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;name&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;t2&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;salary&lt;/span&gt;
  &lt;span class=&quot;pl-k&quot;&gt;FROM&lt;/span&gt; employee t1 &lt;span class=&quot;pl-k&quot;&gt;INNER JOIN&lt;/span&gt; info t2 &lt;span class=&quot;pl-k&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;t1&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;t2&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;name&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一条查询语句中的子查询必需取一个别名，这样才能在其他表达式中引用。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;FROM&lt;/span&gt; (&lt;span class=&quot;pl-k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;3&lt;/span&gt;) &lt;span class=&quot;pl-k&quot;&gt;AS&lt;/span&gt; t1;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;USING(join_column_list)&lt;/code&gt; 语句指定两个表中均包含的列，查询时只针对这里指定的列进行比较。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
a &lt;span class=&quot;pl-k&quot;&gt;LEFT JOIN&lt;/span&gt; b USING (c1, c2, c3)
&lt;/pre&gt;&lt;/div&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;NATURAL [LEFT] JOIN&lt;/code&gt; 与 &lt;code&gt;INNER JOIN&lt;/code&gt; 和 &lt;code&gt;LEFT JOIN&lt;/code&gt; 配合使用了 &lt;code&gt;USING&lt;/code&gt; 指定表中所有列的情况等效。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;code&gt;RIGHT JOIN&lt;/code&gt; 与 &lt;code&gt;LEFT JOIN&lt;/code&gt; 类似，只是最终结果是依据右边表，将左边表中不符合的在结果中以 NULL 呈现。为了方便在不同数据库间迁移，推荐始终使用 &lt;code&gt;LEFT JOIN&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;一些 &lt;code&gt;JOIN&lt;/code&gt; 示例：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;11&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;FROM&lt;/span&gt; table1, table2;

&lt;span class=&quot;pl-k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;FROM&lt;/span&gt; table1 &lt;span class=&quot;pl-k&quot;&gt;INNER JOIN&lt;/span&gt; table2 &lt;span class=&quot;pl-k&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;table1&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;table2&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;id&lt;/span&gt;;

&lt;span class=&quot;pl-k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;FROM&lt;/span&gt; table1 &lt;span class=&quot;pl-k&quot;&gt;LEFT JOIN&lt;/span&gt; table2 &lt;span class=&quot;pl-k&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;table1&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;table2&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;id&lt;/span&gt;;

&lt;span class=&quot;pl-k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;FROM&lt;/span&gt; table1 &lt;span class=&quot;pl-k&quot;&gt;LEFT JOIN&lt;/span&gt; table2 USING (id);

&lt;span class=&quot;pl-k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;FROM&lt;/span&gt; table1 &lt;span class=&quot;pl-k&quot;&gt;LEFT JOIN&lt;/span&gt; table2 &lt;span class=&quot;pl-k&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;table1&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;table2&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;id&lt;/span&gt;
  &lt;span class=&quot;pl-k&quot;&gt;LEFT JOIN&lt;/span&gt; table3 &lt;span class=&quot;pl-k&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;table2&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;table3&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;id&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;NATURAL JOIN&lt;/code&gt; 的结果中不会有重复的列。因为其与 &lt;code&gt;USING&lt;/code&gt; 雷同，所以 &lt;code&gt;USING&lt;/code&gt; 时也没有复杂的列。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;考察下面的示例：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;12&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;t1&lt;/span&gt; (i &lt;span class=&quot;pl-k&quot;&gt;INT&lt;/span&gt;, j &lt;span class=&quot;pl-k&quot;&gt;INT&lt;/span&gt;);
&lt;span class=&quot;pl-k&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;t2&lt;/span&gt; (k &lt;span class=&quot;pl-k&quot;&gt;INT&lt;/span&gt;, j &lt;span class=&quot;pl-k&quot;&gt;INT&lt;/span&gt;);
&lt;span class=&quot;pl-k&quot;&gt;INSERT INTO&lt;/span&gt; t1 &lt;span class=&quot;pl-k&quot;&gt;VALUES&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;);
&lt;span class=&quot;pl-k&quot;&gt;INSERT INTO&lt;/span&gt; t2 &lt;span class=&quot;pl-k&quot;&gt;VALUES&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;);
&lt;span class=&quot;pl-k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;FROM&lt;/span&gt; t1 &lt;span class=&quot;pl-k&quot;&gt;NATURAL JOIN&lt;/span&gt; t2;
&lt;span class=&quot;pl-k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;FROM&lt;/span&gt; t1 &lt;span class=&quot;pl-k&quot;&gt;JOIN&lt;/span&gt; t2 USING (j);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查询结果：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
+------+------+------+
&lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; j    &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; i    &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; k    &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;
+------+------+------+
&lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;    1 &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;    1 &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;    1 &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;
+------+------+------+
+------+------+------+
&lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; j    &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; i    &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; k    &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;
+------+------+------+
&lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;    1 &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;    1 &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;    1 &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;
+------+------+------+
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果中同名的列只出现一次，且都是值相同的那些记录。&lt;/p&gt;
&lt;p&gt;通过向两表中插入一条新记录，令它们的 &lt;code&gt;j&lt;/code&gt; 不相同，再进行测试。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;14&quot;&gt;
&lt;pre&gt;
mysql&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;INSERT INTO&lt;/span&gt; t1 &lt;span class=&quot;pl-k&quot;&gt;VALUES&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;2&lt;/span&gt;);
Query OK, &lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt; row affected (&lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;00&lt;/span&gt; sec)

mysql&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;INSERT INTO&lt;/span&gt; t2 &lt;span class=&quot;pl-k&quot;&gt;VALUES&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;3&lt;/span&gt;);
Query OK, &lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt; row affected (&lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;00&lt;/span&gt; sec)

mysql&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;from&lt;/span&gt; t1 &lt;span class=&quot;pl-k&quot;&gt;natural join&lt;/span&gt; t2;
&lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;--&lt;/span&gt;----+------+------+&lt;/span&gt;
| j    | i    | k    |
&lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;--&lt;/span&gt;----+------+------+&lt;/span&gt;
|    &lt;span class=&quot;pl-c1&quot;&gt;2&lt;/span&gt; |    &lt;span class=&quot;pl-c1&quot;&gt;2&lt;/span&gt; |    &lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt; |
&lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;--&lt;/span&gt;----+------+------+&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt; row &lt;span class=&quot;pl-k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;set&lt;/span&gt; (&lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;00&lt;/span&gt; sec)
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;USING&lt;/code&gt; 和 &lt;code&gt;ON&lt;/code&gt; 作为条件时其他限制的联合条件是一样的，可互相转换。但在 &lt;code&gt;SELECT *&lt;/code&gt; 返回结果时，还是有差异的。前者只在 &lt;code&gt;USING&lt;/code&gt; 中指定的列中返回合并后的结果，后者则针对的是表中所有列。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
a &lt;span class=&quot;pl-k&quot;&gt;LEFT JOIN&lt;/span&gt; b USING (c1, c2, c3)
a &lt;span class=&quot;pl-k&quot;&gt;LEFT JOIN&lt;/span&gt; b &lt;span class=&quot;pl-k&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;a&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;c1&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;b&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;c1&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;AND&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;a&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;c2&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;b&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;c2&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;AND&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;a&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;c3&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;b&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;c3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;USING&lt;/code&gt; 情况下的返回：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;12&quot;&gt;
&lt;pre&gt;
COALESCE(&lt;span class=&quot;pl-c1&quot;&gt;a&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;c1&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;b&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;c1&lt;/span&gt;), COALESCE(&lt;span class=&quot;pl-c1&quot;&gt;a&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;c2&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;b&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;c2&lt;/span&gt;), COALESCE(&lt;span class=&quot;pl-c1&quot;&gt;a&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;c3&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;b&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;c3&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;ON&lt;/code&gt; 的返回：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;12&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-c1&quot;&gt;a&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;c1&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;a&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;c2&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;a&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;c3&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;b&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;c1&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;b&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;c2&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;b&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;c3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;ON&lt;/code&gt; 语句中只能引用其操作表（operands）中的表。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;t1&lt;/span&gt; (i1 &lt;span class=&quot;pl-k&quot;&gt;INT&lt;/span&gt;);
&lt;span class=&quot;pl-k&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;t2&lt;/span&gt; (i2 &lt;span class=&quot;pl-k&quot;&gt;INT&lt;/span&gt;);
&lt;span class=&quot;pl-k&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;t3&lt;/span&gt; (i3 &lt;span class=&quot;pl-k&quot;&gt;INT&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;针对上面的表，以下查询会报错：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
mysql&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; SELECT &lt;span class=&quot;pl-k&quot;&gt;*&lt;/span&gt; FROM t1 JOIN t2 ON (i1 = i3) JOIN t3&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt;
ERROR 1054 (42S22): Unknown column &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;i3&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;on clause&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而以下查询则可以：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
mysql&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; SELECT &lt;span class=&quot;pl-k&quot;&gt;*&lt;/span&gt; FROM t1 JOIN t2 JOIN t3 ON (i1 = i3)&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt;
Empty &lt;span class=&quot;pl-c1&quot;&gt;set&lt;/span&gt; (0.00 sec)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为此时 &lt;code&gt;t3&lt;/code&gt; 在 &lt;code&gt;ON&lt;/code&gt; 语句的操作范围内了。&lt;/p&gt;
&lt;h2&gt;相关资源&lt;/h2&gt;
</description>
<pubDate>Sun, 12 May 2019 12:53:00 +0000</pubDate>
<dc:creator>刘哇勇</dc:creator>
<og:description>关系型数据库，免不了表之间存在各种引用与关联。这些关联是通过主键与外键搭配来形成的。所以，取数据时，很大情况下单张表无法满足需求，额外的数据则需要将其他表加入到查询中来，这便是 JOIN 关键字完成的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Wayou/p/mysql_join.html</dc:identifier>
</item>
<item>
<title>懒人模式开启Android模块自动化Api之旅 - toney.wu</title>
<link>http://www.cnblogs.com/sihaixuan/p/10853103.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sihaixuan/p/10853103.html</guid>
<description>&lt;p&gt;&lt;span&gt;在将业务进行模块化时，避免不了模块页面路由和模块通信， 大多数我们会用到ARouter,EventBus三方库。 模块化过程中有一个尴尬的问题摆在面前：Event事件、Router path放在哪里？ 因为很多业务module都需要收发Event事件,进行页面路由，所以只能将Event， Router path下沉到基础库。 这样导致的结果是基础库越来越大，至多 把Event事件、Router path摆放在独立的module,然后基础库依赖这个库，如下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/657146/201905/657146-20190512180420904-162357930.png&quot; alt=&quot;&quot; width=&quot;747&quot; height=&quot;710&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;我们希望业务模块发送的事件，注解使用的Router path都在模块自己这里定义，而不是下层到基础库,当其他module需要路由、事件、 接口就暴露出来。关于这点《&lt;a href=&quot;https://cloud.tencent.com/developer/article/1005631&quot; rel=&quot;nofollow&quot;&gt;微信Android模块化架构重构实践&lt;/a&gt;》 也提到了这件事情，并且自创性的使用了一种叫“.api”化的方式来解决这件事情。原理是在编译期将公用接口下沉到基础库同层级， 供其他module使用，而这段代码的维护仍然放到非基础库中。这种base库不会膨胀，代码维护的责任制更明确，确定挺不错。如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/657146/201905/657146-20190512180612762-717400448.png&quot; alt=&quot;&quot; width=&quot;917&quot; height=&quot;626&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;在ModuleA，B把XXXBusEvents、XXXRouterParams,暴露的公用接口文件后缀名以.api （并不要求一定.api后者，只要跟后续的自动Api化插件或者脚本一致就行）命名， rebuild之后自动生成ModuleA-api，ModuleB-api 模块，ModuleA，B也会自动添加各自对应 api module依赖。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;讲完了原理，下面就可以实现，这里使用ARouter,EventBus，只对Java文件进行Api化，步骤如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;新建工程，创建base、moduleA、moduleB 模块在moudleA,moduleB中创建api文件&lt;/span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/657146/201905/657146-20190512180910608-313617792.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;默认情况下，Android stuio 是不能识别.api文件，如果想编辑.api后缀的java文件， 为了能让Android Studio继续高亮该怎么办？可以在File Type中把.api作为java文件类型，操作如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/657146/201905/657146-20190512181013914-1520493179.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;设置好后，可以在.api文件中像java文件一样愉快撸代码了，其他类可以引用.api中的类。&lt;/p&gt;
&lt;p&gt;查看setting.gradle文件脚本如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; include &lt;span&gt;'&lt;/span&gt;&lt;span&gt;:app&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;:base&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:modulea&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:moduleb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;include 4个module,做个测试，在setting.gradle include test,同步后，test目录下只有iml文件， 没有build.gradle、AndroidManifest.xml等文件,所以除了拷贝.api文件到对应目录并重命名为.java， 还需要额外创建这两个文件，这里我事先在base module中准备了通用module的build.gradle文件， 拷贝到对应目录即可,AndroidManifest.xml就拷贝base module目录下的，脚本实现如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; includeWithApi(String moduleName,String baseModuleName) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     //&lt;span&gt;先正常加载这个模块
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    include(moduleName)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     //&lt;span&gt;找到这个模块的路径
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     String originDir =&lt;span&gt; project(moduleName).projectDir
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     //&lt;span&gt;这个是新的路径
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     String targetDir = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;${originDir}-api&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     //&lt;span&gt;新模块的路径
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; sdkName = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;${project(moduleName).name}-api&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     //&lt;span&gt;新模块名字
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     String apiName=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;${moduleName.substring(1,moduleName.length())}-api&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     //&lt;span&gt;这个是公共模块的位置，我预先放了一个 ApiBuildGralde.gradle 文件进去
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     String apiGradle =&lt;span&gt; project(baseModuleName).projectDir
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;     //&lt;span&gt; 每次编译删除之前的文件
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    deleteDir(targetDir)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;     //&lt;span&gt;复制.api文件到新的路径
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    copy() {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;from&lt;/span&gt;&lt;span&gt; originDir
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        into targetDir
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         exclude &lt;span&gt;'&lt;/span&gt;&lt;span&gt;**/build/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;         exclude &lt;span&gt;'&lt;/span&gt;&lt;span&gt;**/res/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;         include &lt;span&gt;'&lt;/span&gt;&lt;span&gt;**/*.api&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt;     //&lt;span&gt;直接复制公共模块的AndroidManifest文件到新的路径，作为该模块的文件
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;    copy() {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;${apiGradle}/src/main/AndroidManifest.xml&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;         into &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;${targetDir}/src/main/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt;     //file(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;${targetDir}/src/main/java/com/dhht/${apiName}/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).mkdirs()
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt;     //&lt;span&gt;修改AndroidManifest文件
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;     //fileReader(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;${targetDir}/src/main/AndroidManifest.xml&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,apiName);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; 
&lt;span&gt;41&lt;/span&gt;     //&lt;span&gt;复制 gradle文件到新的路径，作为该模块的gradle
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;    copy() {
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;         &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;${apiGradle}/ApiBuildGralde.gradle&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt;         into &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;${targetDir}/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; 
&lt;span&gt;47&lt;/span&gt;     //&lt;span&gt;删除空文件夹
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;    deleteEmptyDir(new File(targetDir))
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; 
&lt;span&gt;50&lt;/span&gt;     //&lt;span&gt;重命名一下gradle
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; build = new File(targetDir + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/ApiBuildGralde.gradle&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (build.exists()) {
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;         build.renameTo(new File(targetDir + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/build.gradle&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; 
&lt;span&gt;56&lt;/span&gt;     //&lt;span&gt; 重命名.api文件，生成正常的.java文件
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;     renameApiFiles(targetDir, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;.api&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;.java&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; 
&lt;span&gt;59&lt;/span&gt;     //&lt;span&gt;正常加载新的模块
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;     include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:$sdkName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;61&lt;/span&gt; 
&lt;span&gt;62&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;修改setting.gradle文件如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; include &lt;span&gt;'&lt;/span&gt;&lt;span&gt;:app&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;:base&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; includeWithApi(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:modulea&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:base&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; includeWithApi(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:moduleb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:base&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;rebuild后，就可以看到moduleA-api,moduleB-api,并有对应的java文件如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/657146/201905/657146-20190512181429387-89569408.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;添加moduleA路由到moduleB，moduleB给moduleA发送事件逻辑，进行打包，会报如下错误： &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/657146/201905/657146-20190512181516574-1127239379.png&quot; alt=&quot;&quot; width=&quot;1186&quot; height=&quot;255&quot;/&gt;&lt;/p&gt;

&lt;p&gt;很显然，ARouter注解处理器无法识别.api文件，path置为null处理，在moduleA,B添加对应的***-api模块依赖，就可以打包成功了。&lt;/p&gt;
&lt;p&gt;奔着偷懒的原则，不想每次手动添加***-api模块依赖，自动动态添加依赖，实现gradle脚本如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;ext{
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;      //自动添加***-&lt;span&gt;api依赖
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     autoImportApiDependency = {extension -&amp;gt; //&lt;span&gt;extension project对象
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;def&lt;/span&gt; children =&lt;span&gt; project.rootProject.childProjects
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         //&lt;span&gt;遍历所有child project
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         children.each {child -&amp;gt;
&lt;span&gt; 7&lt;/span&gt;             //判断 是否同时存在 *** module 和 ***-&lt;span&gt;api module
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(child.key.contains(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-api&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) &amp;amp;&amp;amp; children.containsKey(child.key.substring(0,child.key.length() - 4&lt;span&gt;))){
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 &lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;                 &lt;span&gt;def&lt;/span&gt; targetKey = child.key.substring(0,child.key.length() - 4&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 &lt;span&gt;def&lt;/span&gt; targetProject =&lt;span&gt; children[targetKey]
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;                targetProject.afterEvaluate {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;                     &lt;span&gt;print&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;*********************\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;                     &lt;span&gt;print&lt;/span&gt;&lt;span&gt; targetProject.dependencies
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                     //&lt;span&gt;通过打印 所有dependencies，推断需要添加如下两个依赖
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                     targetProject.dependencies.add(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;implementation&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,targetProject.dependencies.create(project(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; child.key)))
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                     targetProject.dependencies.add(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;implementationDependenciesMetadata&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,targetProject.dependencies.create(project(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; child.key)))
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;                     //&lt;span&gt;打印 module 添加的依赖
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                     targetProject.configurations.each {configuration -&amp;gt;
&lt;span&gt;24&lt;/span&gt;                         &lt;span&gt;print&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n---------------------------------------\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;                         configuration.allDependencies.each { dependency -&amp;gt;
&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;                             &lt;span&gt;print&lt;/span&gt; configuration.name + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;---&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +dependency.group + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + dependency.name + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + dependency.version +&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt;                     &lt;span&gt;print&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;*********************\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; 
&lt;span&gt;37&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; 
&lt;span&gt;39&lt;/span&gt; 
&lt;span&gt;40&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;autoImportApiDependency 方法封装在Config.gradle，在根build.gradle中调用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; apply &lt;span&gt;from&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Config.gradle&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; ext.autoImportApiDependency(this)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;可以正常打包，并成功运行了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;遇坑集锦&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;1.kotlin集成ARouter，尽管设置了AROUTER_MODULE_NAME，依然报如下错误： ARouter::Compiler An exception is encountered, [null] 可以考虑是否是gradle和 kotlin 版本的问题。&lt;/p&gt;
&lt;p&gt;2.业务模块moduleA处于集成模式时，即集成到App壳工程中去，也会将单一模块做 成App启动的源码和资源打包apk中，尽管设置了sourceSets,也没效果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/657146/201905/657146-20190512182051354-1156403929.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;问题就出在debug文件夹的名字，把debug文件夹改成其他名字，就没有这个问题了，是不是很奇怪！没去究其原因。&lt;/p&gt;
&lt;p&gt;传送门：&lt;a href=&quot;https://github.com/sihaixuan/ComponentDemo&quot; target=&quot;_blank&quot;&gt;懒人模式开启Android模块自动化Api之旅github&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;参考资料：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/article/1005631&quot; rel=&quot;nofollow&quot;&gt;微信 Android 模块化架构重构实践（上）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/c4d1704f9680&quot; rel=&quot;nofollow&quot;&gt;Android实现模块 api 化&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/393b8e3c0cfa&quot; rel=&quot;nofollow&quot;&gt;美团猫眼电影Android模块化实战总结&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;如果您对博主的更新内容持续感兴趣，请关注公众号！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/657146/201905/657146-20190512183111429-1007343220.jpg&quot; alt=&quot;&quot; width=&quot;146&quot; height=&quot;146&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 12 May 2019 10:33:00 +0000</pubDate>
<dc:creator>toney.wu</dc:creator>
<og:description>在将业务进行模块化时，避免不了模块页面路由和模块通信， 大多数我们会用到ARouter,EventBus三方库。 模块化过程中有一个尴尬的问题摆在面前：Event事件、Router path放在哪里？</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sihaixuan/p/10853103.html</dc:identifier>
</item>
<item>
<title>使用Mybatis实现动态SQL（二） - StanleyBlogs</title>
<link>http://www.cnblogs.com/StanleyBlogs/p/10852955.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/StanleyBlogs/p/10852955.html</guid>
<description>&lt;p&gt;作者 ： Stanley 罗昊&lt;/p&gt;
&lt;p&gt;【&lt;strong&gt;转载请注明出处和署名，谢谢！&lt;/strong&gt;】&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;写在前面：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;       *本章节适合有Mybatis基础者观看*&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;使用Mybatis实现动态SQL（一）链接：https://www.cnblogs.com/StanleyBlogs/p/10772878.html#4241746.&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 在上一章内容中，我介绍了一些在xml文件中使用一些标签来让我们一条sql语句更加灵活，那么下面，我将让条件变得更加多样性，根据需求去实现这些功能从而达到练习的目的；&lt;/p&gt;
&lt;p&gt;在工作当中，可能会遇到这样的业务：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;批量的删除或批量的查询，比如我们在网购的时候，在购物车中，我们往往可以批量的删除，勾选你想进行删除的商品，或者根据id批量的对这些数据进行处理，这个时候，我们确实要根据id去查询，但是根据一个id，那，确实很简单，但是要是类似于这种批量型的该怎么做呢&lt;/span&gt;&lt;/strong&gt;？&lt;/p&gt;
&lt;p&gt;其实很简单，只需要用的&lt;strong&gt;&lt;span&gt;foreache&lt;/span&gt;&lt;/strong&gt;这样标签就可以了，比如我们要进行批量删除，这个时候，传过来的一定是一串商品id，不再是单个id，因为批量嘛，所以这个时候传过来的值我们可以把它封装成list集合，再到我们的xml文件中，我们对接收过来的这个集合进行遍历处理是不是就达到了批量操作的目的啦？&lt;/p&gt;
&lt;h2&gt;&amp;lt;foreache&amp;gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;foreache可以迭代的类型：数组、集合、属性、对象数组&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们先来看一下本次的业务是什么：&lt;/p&gt;
&lt;p&gt;查询学号为1、2、53的学生信息；&lt;/p&gt;
&lt;p&gt;首先我们先编写一下sql：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; student &lt;span&gt;from&lt;/span&gt; student &lt;span&gt;where&lt;/span&gt; stuno &lt;span&gt;in&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;53&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么我现在要通过mybatis传参，传一个集合过来，比方说，1 2 53是外界传进来的，如果我们需要解析的话，我们就需要通过foreach标签进行解析；&lt;/p&gt;
&lt;p&gt;比如会儿我传进来一个ids，这个ids可能是数组，或是集合，这个东西里面就包含这三个 1 2 53；&lt;/p&gt;
&lt;p&gt;所以，我们的查询sql语句里面应该就写成：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; student &lt;span&gt;from&lt;/span&gt; student &lt;span&gt;where&lt;/span&gt; stuno &lt;span&gt;in&lt;/span&gt;(ids)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是光写成以上那样肯定不行，因为语法都不通过，所以，需要通过foreache标签来进行操作，因为你光写一个ids Mybatis里的Xml文件肯定不认识的，所以我们需要通过标签来把这个ids给解析出 1 2 53；&lt;/p&gt;
&lt;h3&gt;使用foreache迭代属性&lt;/h3&gt;
&lt;p&gt;迭代属性的话，首先，我们需要在学生类中定义一个学号属性：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;学号类名：Grade&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;学生信息类：Student&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;//学号&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;private List&amp;lt;Integer&amp;gt; stuNos;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;并且提供gat、set方法；&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所以在做项目的时候，在需求中看到需要根据id或者某些唯一的字段进行批量操作数据，那么，你就可以把这个类中的这个属性设置成集合类型；&lt;/p&gt;
&lt;p&gt;以上工作准备就绪后，我们就开始在xml文件中编写配置了；&lt;/p&gt;
&lt;p&gt;首先，我们编写select标签，标识本标签起到查询的作用，紧接着定义接收值类型：parametetType=“Grade” 返回值类型：resultType = “Student” ；&lt;/p&gt;
&lt;p&gt;因为我们要根据Grade类进行查询，所以，些一个where标签，让sql语句灵活起来，内部写一个if标签，用来判断传过来的这个Grade对象中的stuNos属性是否有值，如果有，就执行if中的sql语句；&lt;/p&gt;
&lt;p&gt;在if中记得加and 因为where可以自动处理第一个and，然后我们把sql语句写进去，写完之后先别着急，因为我们还需要把增强for循环写进去，因为我们需要解析grade中的stuNos这个集合,语法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;foreache collection = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;stuNos&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; open &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;and stuno in (&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; close = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; item = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ids&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; sepatator = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;

#｛ids｝

&lt;/span&gt;&amp;lt;/foreache&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们发现，我们的查询条件被分割了，前面的一半时查询条件+（；后面close括号中是另一半的括号；&lt;/p&gt;
&lt;p&gt;后面这个item想必各位都很熟了，没错，item双引号中的ids就是代表着传过来的stuNos集合中的每一个数据，说白了它就是 1 2 53；&lt;/p&gt;
&lt;p&gt;sepatator中写的是，迭代出来的数据用什么符号进行分割，如果不写，你迭代出来的数据就是 1253；&lt;/p&gt;
&lt;p&gt;如果1253作为条件，那么肯定不对，所以我们加了sepatator并且表用用“，”所以迭代出来的数据是这样的 1，2，53；&lt;/p&gt;
&lt;p&gt;接下来，我们完整的写出来实现按照以上业务完成对xml中编写动态sql：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;&lt;span&gt;select&lt;/span&gt; id = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;selectStudentInfoByid&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; parameterType = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;grade&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; resultType = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Student&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;gt;

&lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt;&lt;span&gt; Studnet

&lt;/span&gt;&amp;lt;&lt;span&gt;where&lt;/span&gt;&amp;gt;

&amp;lt;&lt;span&gt;if&lt;/span&gt; test &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;stuNos ! = null and stuNos.size&amp;gt;0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;

&amp;lt;foreache collection = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;stuNos&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; open &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;and stuno in (&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; close = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; item = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ids&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; sepatator = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;

#｛ids｝

&lt;/span&gt;&amp;lt;/foreache&amp;gt;

&amp;lt;/&lt;span&gt;where&lt;/span&gt;&amp;gt;

&amp;lt;/&lt;span&gt;select&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Sun, 12 May 2019 09:33:00 +0000</pubDate>
<dc:creator>StanleyBlogs</dc:creator>
<og:description>使用Mybatis实现动态SQL 作者 ： Stanley 罗昊 【转载请注明出处和署名，谢谢！】 写在前面： *本章节适合有Mybatis基础者观看* 使用Mybatis实现动态SQL（一）链接：h</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/StanleyBlogs/p/10852955.html</dc:identifier>
</item>
</channel>
</rss>